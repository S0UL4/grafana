(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["lokiPlugin"],{

/***/ "./public/app/plugins/datasource/loki/add_label_to_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLabelToQuery": () => (/* binding */ addLabelToQuery)
/* harmony export */ });
/* harmony import */ var _grafana_lezer_logql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@grafana-lezer-logql-virtual-3a1b0e2de7/0/cache/@grafana-lezer-logql-npm-0.0.12-b44b271763-d28780b41a.zip/node_modules/@grafana/lezer-logql/index.es.js");
/* harmony import */ var _querybuilder_LokiQueryModeller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var _querybuilder_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/parsing.ts");




/**
 * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.
 *
 * It uses LogQL parser to find instances of labels, alters them and then splices them back into the query.
 * In a case when we have parser, instead of adding new instance of label it adds label filter after the parser.
 *
 * This operates on substrings of the query with labels and operates just on those. This makes this
 * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.
 *
 * @param query
 * @param key
 * @param value
 * @param operator
 */
function addLabelToQuery(query, key, operator, value) {
  if (!key || !value) {
    throw new Error('Need label to add to query.');
  }

  const streamSelectorPositions = getStreamSelectorPositions(query);
  const parserPositions = getParserPositions(query);

  if (!streamSelectorPositions.length) {
    return query;
  }

  const filter = toLabelFilter(key, value, operator);

  if (!parserPositions.length) {
    return addFilterToStreamSelector(query, streamSelectorPositions, filter);
  } else {
    return addFilterAsLabelFilter(query, parserPositions, filter);
  }
}

/**
 * Parse the string and get all Selector positions in the query together with parsed representation of the
 * selector.
 * @param query
 */
function getStreamSelectorPositions(query) {
  const tree = _grafana_lezer_logql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(query);
  const positions = [];
  tree.iterate({
    enter: (type, from, to, get) => {
      if (type.name === 'Selector') {
        const visQuery = (0,_querybuilder_parsing__WEBPACK_IMPORTED_MODULE_2__.buildVisualQueryFromString)(query.substring(from, to));
        positions.push({
          query: visQuery.query,
          from,
          to
        });
        return false;
      }
    }
  });
  return positions;
}
/**
 * Parse the string and get all LabelParser positions in the query.
 * @param query
 */


function getParserPositions(query) {
  const tree = _grafana_lezer_logql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(query);
  const positions = [];
  tree.iterate({
    enter: (type, from, to, get) => {
      if (type.name === 'LabelParser') {
        positions.push({
          from,
          to
        });
        return false;
      }
    }
  });
  return positions;
}

function toLabelFilter(key, value, operator) {
  // We need to make sure that we convert the value back to string because it may be a number
  return {
    label: key,
    op: operator,
    value
  };
}
/**
 * Add filter as to stream selectors
 * @param query
 * @param vectorSelectorPositions
 * @param filter
 */


function addFilterToStreamSelector(query, vectorSelectorPositions, filter) {
  const modeller = new _querybuilder_LokiQueryModeller__WEBPACK_IMPORTED_MODULE_1__.LokiQueryModeller();
  let newQuery = '';
  let prev = 0;

  for (let i = 0; i < vectorSelectorPositions.length; i++) {
    // This is basically just doing splice on a string for each matched vector selector.
    const match = vectorSelectorPositions[i];
    const isLast = i === vectorSelectorPositions.length - 1;
    const start = query.substring(prev, match.from);
    const end = isLast ? query.substring(match.to) : '';

    if (!labelExists(match.query.labels, filter)) {
      // We don't want to add duplicate labels.
      match.query.labels.push(filter);
    }

    const newLabels = modeller.renderQuery(match.query);
    newQuery += start + newLabels + end;
    prev = match.to;
  }

  return newQuery;
}
/**
 * Add filter as label filter after the parsers
 * @param query
 * @param parserPositions
 * @param filter
 */


function addFilterAsLabelFilter(query, parserPositions, filter) {
  let newQuery = '';
  let prev = 0;

  for (let i = 0; i < parserPositions.length; i++) {
    // This is basically just doing splice on a string for each matched vector selector.
    const match = parserPositions[i];
    const isLast = i === parserPositions.length - 1;
    const start = query.substring(prev, match.to);
    const end = isLast ? query.substring(match.to) : '';
    const labelFilter = ` | ${filter.label}${filter.op}\`${filter.value}\``;
    newQuery += start + labelFilter + end;
    prev = match.to;
  }

  return newQuery;
}
/**
 * Check if label exists in the list of labels but ignore the operator.
 * @param labels
 * @param filter
 */


function labelExists(labels, filter) {
  return labels.find(label => label.label === filter.label && label.value === filter.value);
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/backendResultTransformer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transformBackendResult": () => (/* binding */ transformBackendResult)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _getDerivedFields__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/getDerivedFields.ts");
/* harmony import */ var _makeTableFrames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/makeTableFrames.ts");
/* harmony import */ var _query_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/query_utils.ts");
/* harmony import */ var _responseUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/responseUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
const _excluded = ["meta"],
      _excluded2 = ["data", "error"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








function isMetricFrame(frame) {
  return frame.fields.every(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time || field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number);
} // returns a new frame, with meta shallow merged with it's original meta


function setFrameMeta(frame, meta) {
  const {
    meta: oldMeta
  } = frame,
        rest = _objectWithoutPropertiesLoose(frame, _excluded); // meta maybe be undefined, we need to handle that


  const newMeta = Object.assign({}, oldMeta, meta);
  return Object.assign({}, rest, {
    meta: newMeta
  });
}

function processStreamFrame(frame, query, derivedFieldConfigs) {
  var _frame$meta;

  const custom = Object.assign({}, (_frame$meta = frame.meta) === null || _frame$meta === void 0 ? void 0 : _frame$meta.custom, {
    // keep the original meta.custom
    // used by logs_model
    lokiQueryStatKey: 'Summary: total bytes processed'
  });

  if ((0,_responseUtils__WEBPACK_IMPORTED_MODULE_4__.dataFrameHasLokiError)(frame)) {
    custom.error = 'Error when parsing some of the logs';
  }

  const meta = {
    preferredVisualisationType: 'logs',
    limit: query === null || query === void 0 ? void 0 : query.maxLines,
    searchWords: query !== undefined ? (0,_query_utils__WEBPACK_IMPORTED_MODULE_3__.getHighlighterExpressionsFromQuery)((0,_query_utils__WEBPACK_IMPORTED_MODULE_3__.formatQuery)(query.expr)) : undefined,
    custom
  };
  const newFrame = setFrameMeta(frame, meta);
  const derivedFields = (0,_getDerivedFields__WEBPACK_IMPORTED_MODULE_1__.getDerivedFields)(newFrame, derivedFieldConfigs);
  return Object.assign({}, newFrame, {
    fields: [...newFrame.fields, ...derivedFields]
  });
}

function processStreamsFrames(frames, queryMap, derivedFieldConfigs) {
  return frames.map(frame => {
    const query = frame.refId !== undefined ? queryMap.get(frame.refId) : undefined;
    return processStreamFrame(frame, query, derivedFieldConfigs);
  });
}

function processMetricInstantFrames(frames) {
  return frames.length > 0 ? (0,_makeTableFrames__WEBPACK_IMPORTED_MODULE_2__.makeTableFrames)(frames) : [];
}

function processMetricRangeFrames(frames) {
  const meta = {
    preferredVisualisationType: 'graph'
  };
  return frames.map(frame => setFrameMeta(frame, meta));
} // we split the frames into 3 groups, because we will handle
// each group slightly differently


function groupFrames(frames, queryMap) {
  const streamsFrames = [];
  const metricInstantFrames = [];
  const metricRangeFrames = [];
  frames.forEach(frame => {
    if (!isMetricFrame(frame)) {
      streamsFrames.push(frame);
    } else {
      var _queryMap$get;

      const isInstantFrame = frame.refId != null && ((_queryMap$get = queryMap.get(frame.refId)) === null || _queryMap$get === void 0 ? void 0 : _queryMap$get.queryType) === _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Instant;

      if (isInstantFrame) {
        metricInstantFrames.push(frame);
      } else {
        metricRangeFrames.push(frame);
      }
    }
  });
  return {
    streamsFrames,
    metricInstantFrames,
    metricRangeFrames
  };
}

function improveError(error, queryMap) {
  // many things are optional in an error-object, we need an error-message to exist,
  // and we need to find the loki-query, based on the refId in the error-object.
  if (error === undefined) {
    return error;
  }

  const {
    refId,
    message
  } = error;

  if (refId === undefined || message === undefined) {
    return error;
  }

  const query = queryMap.get(refId);

  if (query === undefined) {
    return error;
  }

  if (message.includes('escape') && query.expr.includes('\\')) {
    return Object.assign({}, error, {
      message: `${message}. Make sure that all special characters are escaped with \\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`
    });
  }

  return error;
}

function transformBackendResult(response, queries, derivedFieldConfigs) {
  const {
    data,
    error
  } = response,
        rest = _objectWithoutPropertiesLoose(response, _excluded2); // in the typescript type, data is an array of basically anything.
  // we do know that they have to be dataframes, so we make a quick check,
  // this way we can be sure, and also typescript is happy.


  const dataFrames = data.map(d => {
    if (!(0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.isDataFrame)(d)) {
      throw new Error('transformation only supports dataframe responses');
    }

    return d;
  });
  const queryMap = new Map(queries.map(query => [query.refId, query]));
  const {
    streamsFrames,
    metricInstantFrames,
    metricRangeFrames
  } = groupFrames(dataFrames, queryMap);
  return Object.assign({}, rest, {
    error: improveError(error, queryMap),
    data: [...processMetricRangeFrames(metricRangeFrames), ...processMetricInstantFrames(metricInstantFrames), ...processStreamsFrames(streamsFrames, queryMap, derivedFieldConfigs)]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/AnnotationsQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiAnnotationsQueryEditor": () => (/* binding */ LokiAnnotationsQueryEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _query_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/query_utils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
/* harmony import */ var _LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var _LokiQueryField__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
// Libraries


 // Types








const LokiAnnotationsQueryEditor = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function LokiAnnotationQueryEditor(props) {
  var _queryWithRefId$maxLi;

  const {
    annotation,
    onAnnotationChange
  } = props; // this should never happen, but we want to keep typescript happy

  if (annotation === undefined || onAnnotationChange === undefined) {
    return null;
  }

  const onChangeQuery = query => {
    // the current version of annotations only stores an optional boolean
    // field `instant` to handle the instant/range switch.
    // we need to maintain compatiblity for now, so we do the same.
    // we explicitly call `getNormalizedLokiQuery` to make sure `queryType`
    // is set up correctly.
    const instant = (0,_query_utils__WEBPACK_IMPORTED_MODULE_3__.getNormalizedLokiQuery)(query).queryType === _types__WEBPACK_IMPORTED_MODULE_4__.LokiQueryType.Instant;
    onAnnotationChange(Object.assign({}, annotation, {
      expr: query.expr,
      maxLines: query.maxLines,
      instant
    }));
  };

  const queryWithRefId = {
    refId: '',
    expr: annotation.expr,
    maxLines: annotation.maxLines,
    instant: annotation.instant,
    queryType: annotation.queryType
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
      className: "gf-form-group",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiQueryField__WEBPACK_IMPORTED_MODULE_6__.LokiQueryField, {
        datasource: props.datasource,
        query: queryWithRefId,
        onChange: onChangeQuery,
        onRunQuery: () => {},
        onBlur: () => {},
        history: [],
        ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.LokiOptionFields, {
          lineLimitValue: (queryWithRefId === null || queryWithRefId === void 0 ? void 0 : (_queryWithRefId$maxLi = queryWithRefId.maxLines) === null || _queryWithRefId$maxLi === void 0 ? void 0 : _queryWithRefId$maxLi.toString()) || '',
          resolution: queryWithRefId.resolution || 1,
          query: queryWithRefId,
          onRunQuery: () => {},
          onChange: onChangeQuery
        })
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Title",
        tooltip: 'Use either the name or a pattern. For example, {{instance}} is replaced with label value for the label instance.',
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
          type: "text",
          placeholder: "alertname",
          value: annotation.titleFormat,
          onChange: event => {
            onAnnotationChange(Object.assign({}, annotation, {
              titleFormat: event.currentTarget.value
            }));
          }
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Tags",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
          type: "text",
          placeholder: "label1,label2",
          value: annotation.tagKeys,
          onChange: event => {
            onAnnotationChange(Object.assign({}, annotation, {
              tagKeys: event.currentTarget.value
            }));
          }
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Text",
        tooltip: 'Use either the name or a pattern. For example, {{instance}} is replaced with label value for the label instance.',
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
          type: "text",
          placeholder: "instance",
          value: annotation.textFormat,
          onChange: event => {
            onAnnotationChange(Object.assign({}, annotation, {
              textFormat: event.currentTarget.value
            }));
          }
        })
      })]
    })]
  });
});

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LokiCheatSheet)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h, _div, _div2, _div3, _div4, _div5, _div6, _div7, _div8;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const DEFAULT_EXAMPLES = ['{job="default/prometheus"}'];
const PREFERRED_LABELS = ['job', 'app', 'k8s_app'];
const EXAMPLES_LIMIT = 5;
const LOGQL_EXAMPLES = [{
  title: 'Log pipeline',
  expression: '{job="mysql"} |= "metrics" | logfmt | duration > 10s',
  label: 'This query targets the MySQL job, filters out logs that donâ€™t contain the word "metrics" and parses each log line to extract more labels and filters with them.'
}, {
  title: 'Count over time',
  expression: 'count_over_time({job="mysql"}[5m])',
  label: 'This query counts all the log lines within the last five minutes for the MySQL job.'
}, {
  title: 'Rate',
  expression: 'rate(({job="mysql"} |= "error" != "timeout")[10s])',
  label: 'This query gets the per-second rate of all non-timeout errors within the last ten seconds for the MySQL job.'
}, {
  title: 'Aggregate, count, and group',
  expression: 'sum(count_over_time({job="mysql"}[5m])) by (level)',
  label: 'Get the count of logs during the last five minutes, grouping by level.'
}];
class LokiCheatSheet extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      userExamples: []
    });

    _defineProperty(this, "checkUserLabels", async () => {
      var _this$props$datasourc;

      // Set example from user labels
      const provider = (_this$props$datasourc = this.props.datasource) === null || _this$props$datasourc === void 0 ? void 0 : _this$props$datasourc.languageProvider;

      if (provider.started) {
        const labels = provider.getLabelKeys() || [];
        const preferredLabel = PREFERRED_LABELS.find(l => labels.includes(l));

        if (preferredLabel) {
          const values = await provider.getLabelValues(preferredLabel);
          const userExamples = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.shuffle)(values).slice(0, EXAMPLES_LIMIT).map(value => `{${preferredLabel}="${value}"}`);
          this.setState({
            userExamples
          });
        }
      } else {
        this.scheduleUserLabelChecking();
      }
    });
  }

  componentDidMount() {
    this.scheduleUserLabelChecking();
    (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.reportInteraction)('grafana_loki_cheatsheet_opened', {});
  }

  componentWillUnmount() {
    clearTimeout(this.userLabelTimer);
  }

  scheduleUserLabelChecking() {
    this.userLabelTimer = setTimeout(this.checkUserLabels, 1000);
  }

  renderExpression(expr) {
    const {
      onClickExample
    } = this.props;

    const onClick = query => {
      onClickExample(query);
      (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.reportInteraction)('grafana_loki_cheatsheet_example_clicked', {});
    };

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
      className: "cheat-sheet-item__example",
      onClick: e => onClick({
        refId: 'A',
        expr
      }),
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("code", {
        children: expr
      })
    }, expr);
  }

  render() {
    const {
      userExamples
    } = this.state;
    const hasUserExamples = userExamples.length > 0;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
      children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("h2", {
        children: "Loki Cheat Sheet"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: "See your logs"
        })), _div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
          className: "cheat-sheet-item__label",
          children: "Start by selecting a log stream from the Log browser, or alternatively you can write a stream selector into the query field."
        })), hasUserExamples ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
          children: [_div3 || (_div3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
            className: "cheat-sheet-item__label",
            children: "Here are some example streams from your logs:"
          })), userExamples.map(example => this.renderExpression(example))]
        }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
          children: [_div4 || (_div4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
            className: "cheat-sheet-item__label",
            children: "Here is an example of a log stream:"
          })), this.renderExpression(DEFAULT_EXAMPLES[0])]
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [_div5 || (_div5 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: "Combine stream selectors"
        })), this.renderExpression('{app="cassandra",namespace="prod"}'), _div6 || (_div6 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
          className: "cheat-sheet-item__label",
          children: "Returns all log lines from streams that have both labels."
        }))]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [_div7 || (_div7 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: "Filtering for search terms."
        })), this.renderExpression('{app="cassandra"} |~ "(duration|latency)s*(=|is|of)s*[d.]+"'), this.renderExpression('{app="cassandra"} |= "exact match"'), this.renderExpression('{app="cassandra"} != "do not match"'), _div8 || (_div8 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
          className: "cheat-sheet-item__label",
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("a", {
            href: "https://grafana.com/docs/loki/latest/logql/#log-pipeline",
            target: "logql",
            children: "LogQL"
          }), ' ', "supports exact and regular expression filters."]
        }))]
      }), LOGQL_EXAMPLES.map(item => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: item.title
        }), this.renderExpression(item.expression), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
          className: "cheat-sheet-item__label",
          children: item.label
        })]
      }, item.expression))]
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiExploreQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiExploreQueryEditor": () => (/* binding */ LokiExploreQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _LokiOptionFields__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var _LokiQueryField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
// Libraries
 // Types




const LokiExploreQueryEditor = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(props => {
  var _query$maxLines;

  const {
    query,
    data,
    datasource,
    history,
    onChange,
    onRunQuery,
    range
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_LokiQueryField__WEBPACK_IMPORTED_MODULE_2__.LokiQueryField, {
    datasource: datasource,
    query: query,
    onChange: onChange,
    onBlur: () => {},
    onRunQuery: onRunQuery,
    history: history,
    data: data,
    range: range,
    "data-testid": testIds.editor,
    ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_LokiOptionFields__WEBPACK_IMPORTED_MODULE_1__.LokiOptionFields, {
      lineLimitValue: (query === null || query === void 0 ? void 0 : (_query$maxLines = query.maxLines) === null || _query$maxLines === void 0 ? void 0 : _query$maxLines.toString()) || '',
      resolution: query.resolution || 1,
      query: query,
      onRunQuery: onRunQuery,
      onChange: onChange
    })
  });
});
LokiExploreQueryEditor.displayName = 'LokiExploreQueryEditor';
const testIds = {
  editor: 'loki-editor-explore'
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiLabelBrowser.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiLabelBrowser": () => (/* binding */ LokiLabelBrowser),
/* harmony export */   "UnthemedLokiLabelBrowser": () => (/* binding */ UnthemedLokiLabelBrowser),
/* harmony export */   "buildSelector": () => (/* binding */ buildSelector),
/* harmony export */   "facetLabels": () => (/* binding */ facetLabels)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_window__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/__virtual__/react-window-virtual-db79012d82/0/cache/react-window-npm-1.8.7-5a23226c09-1e122c2922.zip/node_modules/react-window/dist/index.esm.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/language_utils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _LoadingPlaceholder, _Label, _Label2, _Label3;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







 // Hard limit on labels to render



const MAX_LABEL_COUNT = 1000;
const MAX_VALUE_COUNT = 10000;
const MAX_AUTO_SELECT = 4;
const EMPTY_SELECTOR = '{}';
function buildSelector(labels) {
  const selectedLabels = [];

  for (const label of labels) {
    if (label.selected && label.values && label.values.length > 0) {
      const selectedValues = label.values.filter(value => value.selected).map(value => value.name);

      if (selectedValues.length > 1) {
        selectedLabels.push(`${label.name}=~"${selectedValues.map(_language_utils__WEBPACK_IMPORTED_MODULE_5__.escapeLabelValueInRegexSelector).join('|')}"`);
      } else if (selectedValues.length === 1) {
        selectedLabels.push(`${label.name}="${(0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.escapeLabelValueInExactSelector)(selectedValues[0])}"`);
      }
    }
  }

  return ['{', selectedLabels.join(','), '}'].join('');
}
function facetLabels(labels, possibleLabels, lastFacetted) {
  return labels.map(label => {
    const possibleValues = possibleLabels[label.name];

    if (possibleValues) {
      let existingValues;

      if (label.name === lastFacetted && label.values) {
        // Facetting this label, show all values
        existingValues = label.values;
      } else {
        var _label$values;

        // Keep selection in other facets
        const selectedValues = new Set(((_label$values = label.values) === null || _label$values === void 0 ? void 0 : _label$values.filter(value => value.selected).map(value => value.name)) || []); // Values for this label have not been requested yet, let's use the facetted ones as the initial values

        existingValues = possibleValues.map(value => ({
          name: value,
          selected: selectedValues.has(value)
        }));
      }

      return Object.assign({}, label, {
        loading: false,
        values: existingValues,
        facets: existingValues.length
      });
    } // Label is facetted out, hide all values


    return Object.assign({}, label, {
      loading: false,
      hidden: !possibleValues,
      values: undefined,
      facets: 0
    });
  });
}

const getStyles = theme => ({
  wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    background-color: ${theme.colors.background.secondary};
    padding: ${theme.spacing(2)};
    width: 100%;
  `,
  list: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-top: ${theme.spacing(1)};
    display: flex;
    flex-wrap: wrap;
    max-height: 200px;
    overflow: auto;
  `,
  section: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    & + & {
      margin: ${theme.spacing(2, 0)};
    }
    position: relative;
  `,
  selector: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    font-family: ${theme.typography.fontFamilyMonospace};
    margin-bottom: ${theme.spacing(1)};
  `,
  status: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding: ${theme.spacing(0.5)};
    color: ${theme.colors.text.secondary};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    /* using absolute positioning because flex interferes with ellipsis */
    position: absolute;
    width: 50%;
    right: 0;
    text-align: right;
    transition: opacity 100ms linear;
    opacity: 0;
  `,
  statusShowing: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    opacity: 1;
  `,
  error: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    color: ${theme.colors.error.main};
  `,
  valueList: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-right: ${theme.spacing(1)};
  `,
  valueListWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    border-left: 1px solid ${theme.colors.border.medium};
    margin: ${theme.spacing(1, 0)};
    padding: ${theme.spacing(1, 0, 1, 1)};
  `,
  valueListArea: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    flex-wrap: wrap;
    margin-top: ${theme.spacing(1)};
  `,
  valueTitle: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-left: -${theme.spacing(0.5)};
    margin-bottom: ${theme.spacing(1)};
  `,
  validationStatus: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding: ${theme.spacing(0.5)};
    margin-bottom: ${theme.spacing(1)};
    color: ${theme.colors.text.maxContrast};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  `
});

class UnthemedLokiLabelBrowser extends react__WEBPACK_IMPORTED_MODULE_2__.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      labels: [],
      searchTerm: '',
      status: 'Ready',
      error: '',
      validationStatus: ''
    });

    _defineProperty(this, "onChangeSearch", event => {
      this.setState({
        searchTerm: event.target.value
      });
    });

    _defineProperty(this, "onClickRunLogsQuery", () => {
      (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.reportInteraction)('grafana_loki_log_browser_closed', {
        app: this.props.app,
        closeType: 'showLogsButton'
      });
      const selector = buildSelector(this.state.labels);
      this.props.onChange(selector);
    });

    _defineProperty(this, "onClickRunMetricsQuery", () => {
      (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.reportInteraction)('grafana_loki_log_browser_closed', {
        app: this.props.app,
        closeType: 'showLogsRateButton'
      });
      const selector = buildSelector(this.state.labels);
      const query = `rate(${selector}[$__interval])`;
      this.props.onChange(query);
    });

    _defineProperty(this, "onClickClear", () => {
      (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.reportInteraction)('grafana_loki_log_browser_closed', {
        app: this.props.app,
        closeType: 'clearButton'
      });
      this.setState(state => {
        const labels = state.labels.map(label => Object.assign({}, label, {
          values: undefined,
          selected: false,
          loading: false,
          hidden: false,
          facets: undefined
        }));
        return {
          labels,
          searchTerm: '',
          status: '',
          error: '',
          validationStatus: ''
        };
      });
      this.props.deleteLastUsedLabels();
    });

    _defineProperty(this, "onClickLabel", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label) {
        return;
      } // Toggle selected state


      const selected = !label.selected;
      let nextValue = {
        selected
      };

      if (label.values && !selected) {
        // Deselect all values if label was deselected
        const values = label.values.map(value => Object.assign({}, value, {
          selected: false
        }));
        nextValue = Object.assign({}, nextValue, {
          facets: 0,
          values
        });
      } // Resetting search to prevent empty results


      this.setState({
        searchTerm: ''
      });
      this.updateLabelState(name, nextValue, '', () => this.doFacettingForLabel(name));
    });

    _defineProperty(this, "onClickValue", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label || !label.values) {
        return;
      } // Resetting search to prevent empty results


      this.setState({
        searchTerm: ''
      }); // Toggling value for selected label, leaving other values intact

      const values = label.values.map(v => Object.assign({}, v, {
        selected: v.name === value ? !v.selected : v.selected
      }));
      this.updateLabelState(name, {
        values
      }, '', () => this.doFacetting(name));
    });

    _defineProperty(this, "onClickValidate", () => {
      const selector = buildSelector(this.state.labels);
      this.validateSelector(selector);
    });

    _defineProperty(this, "doFacetting", lastFacetted => {
      const selector = buildSelector(this.state.labels);

      if (selector === EMPTY_SELECTOR) {
        // Clear up facetting
        const labels = this.state.labels.map(label => {
          return Object.assign({}, label, {
            facets: 0,
            values: undefined,
            hidden: false
          });
        });
        this.setState({
          labels
        }, () => {
          // Get fresh set of values
          this.state.labels.forEach(label => label.selected && this.fetchValues(label.name, selector));
        });
      } else {
        // Do facetting
        this.fetchSeries(selector, lastFacetted);
      }
    });
  }

  updateLabelState(name, updatedFields, status = '', cb) {
    this.setState(state => {
      const labels = state.labels.map(label => {
        if (label.name === name) {
          return Object.assign({}, label, updatedFields);
        }

        return label;
      }); // New status overrides errors

      const error = status ? '' : state.error;
      return {
        labels,
        status,
        error,
        validationStatus: ''
      };
    }, cb);
  }

  componentDidMount() {
    const {
      languageProvider,
      autoSelect = MAX_AUTO_SELECT,
      lastUsedLabels
    } = this.props;

    if (languageProvider) {
      const selectedLabels = lastUsedLabels;
      languageProvider.start().then(() => {
        let rawLabels = languageProvider.getLabelKeys();

        if (rawLabels.length > MAX_LABEL_COUNT) {
          const error = `Too many labels found (showing only ${MAX_LABEL_COUNT} of ${rawLabels.length})`;
          rawLabels = rawLabels.slice(0, MAX_LABEL_COUNT);
          this.setState({
            error
          });
        } // Auto-select all labels if label list is small enough


        const labels = rawLabels.map((label, i, arr) => ({
          name: label,
          selected: arr.length <= autoSelect && selectedLabels.length === 0 || selectedLabels.includes(label),
          loading: false
        })); // Pre-fetch values for selected labels

        this.setState({
          labels
        }, () => {
          this.state.labels.forEach(label => {
            if (label.selected) {
              this.fetchValues(label.name, EMPTY_SELECTOR);
            }
          });
        });
      });
    }
  }

  doFacettingForLabel(name) {
    const label = this.state.labels.find(l => l.name === name);

    if (!label) {
      return;
    }

    const selectedLabels = this.state.labels.filter(label => label.selected).map(label => label.name);
    this.props.storeLastUsedLabels(selectedLabels);

    if (label.selected) {
      // Refetch values for newly selected label...
      if (!label.values) {
        this.fetchValues(name, buildSelector(this.state.labels));
      }
    } else {
      // Only need to facet when deselecting labels
      this.doFacetting();
    }
  }

  async fetchValues(name, selector) {
    const {
      languageProvider
    } = this.props;
    this.updateLabelState(name, {
      loading: true
    }, `Fetching values for ${name}`);

    try {
      let rawValues = await languageProvider.getLabelValues(name); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        this.updateLabelState(name, {
          loading: false
        }, '');
        return;
      }

      if (rawValues.length > MAX_VALUE_COUNT) {
        const error = `Too many values for ${name} (showing only ${MAX_VALUE_COUNT} of ${rawValues.length})`;
        rawValues = rawValues.slice(0, MAX_VALUE_COUNT);
        this.setState({
          error
        });
      }

      const values = rawValues.map(value => ({
        name: value
      }));
      this.updateLabelState(name, {
        values,
        loading: false
      });
    } catch (error) {
      console.error(error);
    }
  }

  async fetchSeries(selector, lastFacetted) {
    const {
      languageProvider
    } = this.props;

    if (lastFacetted) {
      this.updateLabelState(lastFacetted, {
        loading: true
      }, `Facetting labels for ${selector}`);
    }

    try {
      const possibleLabels = await languageProvider.fetchSeriesLabels(selector, true); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        if (lastFacetted) {
          this.updateLabelState(lastFacetted, {
            loading: false
          });
        }

        return;
      }

      if (Object.keys(possibleLabels).length === 0) {
        this.setState({
          error: `Empty results, no matching label for ${selector}`
        });
        return;
      }

      const labels = facetLabels(this.state.labels, possibleLabels, lastFacetted);
      this.setState({
        labels,
        error: ''
      });

      if (lastFacetted) {
        this.updateLabelState(lastFacetted, {
          loading: false
        });
      }
    } catch (error) {
      console.error(error);
    }
  }

  async validateSelector(selector) {
    const {
      languageProvider
    } = this.props;
    this.setState({
      validationStatus: `Validating selector ${selector}`,
      error: ''
    });
    const streams = await languageProvider.fetchSeries(selector);
    this.setState({
      validationStatus: `Selector is valid (${streams.length} streams found)`
    });
  }

  render() {
    const {
      theme
    } = this.props;
    const {
      labels,
      searchTerm,
      status,
      error,
      validationStatus
    } = this.state;

    if (labels.length === 0) {
      return _LoadingPlaceholder || (_LoadingPlaceholder = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.LoadingPlaceholder, {
        text: "Loading labels..."
      }));
    }

    const styles = getStyles(theme);
    const selector = buildSelector(this.state.labels);
    const empty = selector === EMPTY_SELECTOR;
    let selectedLabels = labels.filter(label => label.selected && label.values);

    if (searchTerm) {
      selectedLabels = selectedLabels.map(label => {
        const searchResults = label.values.filter(value => {
          // Always return selected values
          if (value.selected) {
            value.highlightParts = undefined;
            return true;
          }

          const fuzzyMatchResult = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.fuzzyMatch)(value.name.toLowerCase(), searchTerm.toLowerCase());

          if (fuzzyMatchResult.found) {
            value.highlightParts = fuzzyMatchResult.ranges;
            value.order = fuzzyMatchResult.distance;
            return true;
          } else {
            return false;
          }
        });
        return Object.assign({}, label, {
          values: (0,lodash__WEBPACK_IMPORTED_MODULE_1__.sortBy)(searchResults, value => value.selected ? -Infinity : value.order)
        });
      });
    } else {
      // Clear highlight parts when searchTerm is cleared
      selectedLabels = this.state.labels.filter(label => label.selected && label.values).map(label => Object.assign({}, label, {
        values: label !== null && label !== void 0 && label.values ? label.values.map(value => Object.assign({}, value, {
          highlightParts: undefined
        })) : []
      }));
    }

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
      className: styles.wrapper,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
        className: styles.section,
        children: [_Label || (_Label = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Label, {
          description: "Which labels would you like to consider for your search?",
          children: "1. Select labels to search in"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
          className: styles.list,
          children: labels.map(label => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.BrowserLabel, {
            name: label.name,
            loading: label.loading,
            active: label.selected,
            hidden: label.hidden,
            facets: label.facets,
            onClick: this.onClickLabel
          }, label.name))
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
        className: styles.section,
        children: [_Label2 || (_Label2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Label, {
          description: "Choose the label values that you would like to use for the query. Use the search field to find values across selected labels.",
          children: "2. Find values for the selected labels"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Input, {
            onChange: this.onChangeSearch,
            "aria-label": "Filter expression for values",
            value: searchTerm
          })
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
          className: styles.valueListArea,
          children: selectedLabels.map(label => {
            var _label$values2, _label$values3;

            return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
              role: "list",
              className: styles.valueListWrapper,
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
                className: styles.valueTitle,
                "aria-label": `Values for ${label.name}`,
                children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.BrowserLabel, {
                  name: label.name,
                  loading: label.loading,
                  active: label.selected,
                  hidden: label.hidden //If no facets, we want to show number of all label values
                  ,
                  facets: label.facets || ((_label$values2 = label.values) === null || _label$values2 === void 0 ? void 0 : _label$values2.length),
                  onClick: this.onClickLabel
                })
              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(react_window__WEBPACK_IMPORTED_MODULE_7__.FixedSizeList, {
                height: 200,
                itemCount: ((_label$values3 = label.values) === null || _label$values3 === void 0 ? void 0 : _label$values3.length) || 0,
                itemSize: 28,
                itemKey: i => label.values[i].name,
                width: 200,
                className: styles.valueList,
                children: ({
                  index,
                  style
                }) => {
                  var _label$values4;

                  const value = (_label$values4 = label.values) === null || _label$values4 === void 0 ? void 0 : _label$values4[index];

                  if (!value) {
                    return null;
                  }

                  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
                    style: style,
                    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.BrowserLabel, {
                      name: label.name,
                      value: value === null || value === void 0 ? void 0 : value.name,
                      active: value === null || value === void 0 ? void 0 : value.selected,
                      highlightParts: value === null || value === void 0 ? void 0 : value.highlightParts,
                      onClick: this.onClickValue,
                      searchTerm: searchTerm
                    })
                  });
                }
              })]
            }, label.name);
          })
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
        className: styles.section,
        children: [_Label3 || (_Label3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Label, {
          children: "3. Resulting selector"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
          "aria-label": "selector",
          className: styles.selector,
          children: selector
        }), validationStatus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
          className: styles.validationStatus,
          children: validationStatus
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.HorizontalGroup, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
            "aria-label": "Use selector as logs button",
            disabled: empty,
            onClick: this.onClickRunLogsQuery,
            children: "Show logs"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
            "aria-label": "Use selector as metrics button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickRunMetricsQuery,
            children: "Show logs rate"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
            "aria-label": "Validate submit button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickValidate,
            children: "Validate selector"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
            "aria-label": "Selector clear button",
            variant: "secondary",
            onClick: this.onClickClear,
            children: "Clear"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
            className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.status, (status || error) && styles.statusShowing),
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("span", {
              className: error ? styles.error : '',
              children: error || status
            })
          })]
        })]
      })]
    });
  }

}
const LokiLabelBrowser = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.withTheme2)(UnthemedLokiLabelBrowser);

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_RESOLUTION": () => (/* binding */ DEFAULT_RESOLUTION),
/* harmony export */   "LokiOptionFields": () => (/* binding */ LokiOptionFields),
/* harmony export */   "RESOLUTION_OPTIONS": () => (/* binding */ RESOLUTION_OPTIONS),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "preprocessMaxLines": () => (/* binding */ preprocessMaxLines),
/* harmony export */   "queryTypeOptions": () => (/* binding */ queryTypeOptions)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel;

const _excluded = ["instant", "range"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// Libraries


 // Types






const queryTypeOptions = [{
  value: _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Range,
  label: 'Range',
  description: 'Run query over a range of time.'
}, {
  value: _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Instant,
  label: 'Instant',
  description: 'Run query against a single point in time. For this query, the "To" time is used.'
}];

if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.featureToggles.lokiLive) {
  queryTypeOptions.push({
    value: _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Stream,
    label: 'Stream',
    description: 'Run a query and keep sending results on an interval'
  });
}

const DEFAULT_RESOLUTION = {
  value: 1,
  label: '1/1'
};
const RESOLUTION_OPTIONS = [DEFAULT_RESOLUTION].concat((0,lodash__WEBPACK_IMPORTED_MODULE_1__.map)([2, 3, 4, 5, 10], value => ({
  value,
  label: '1/' + value
})));
function LokiOptionFields(props) {
  var _props$query, _query$queryType;

  const {
    lineLimitValue,
    resolution,
    onRunQuery,
    runOnBlur,
    onChange
  } = props;
  const query = (_props$query = props.query) !== null && _props$query !== void 0 ? _props$query : {};
  let queryType = (_query$queryType = query.queryType) !== null && _query$queryType !== void 0 ? _query$queryType : query.instant ? _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Instant : _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Range;

  function onChangeQueryLimit(value) {
    const nextQuery = Object.assign({}, query, {
      maxLines: preprocessMaxLines(value)
    });
    onChange(nextQuery);
  }

  function onQueryTypeChange(queryType) {
    const rest = _objectWithoutPropertiesLoose(query, _excluded);

    onChange(Object.assign({}, rest, {
      queryType
    }));
  }

  function onMaxLinesChange(e) {
    if (query.maxLines !== preprocessMaxLines(e.currentTarget.value)) {
      onChangeQueryLimit(e.currentTarget.value);
    }
  }

  function onReturnKeyDown(e) {
    if (e.key === 'Enter') {
      onRunQuery();
    }
  }

  function onResolutionChange(option) {
    const nextQuery = Object.assign({}, query, {
      resolution: option.value
    });
    onChange(nextQuery);
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
    "aria-label": "Loki extra field",
    className: "gf-form-inline",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
      "data-testid": "queryTypeField",
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)('gf-form explore-input-margin', _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
            flex-wrap: nowrap;
          `),
      "aria-label": "Query type field",
      children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineFormLabel, {
        width: "auto",
        children: "Query type"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.RadioButtonGroup, {
        options: queryTypeOptions,
        value: queryType,
        onChange: type => {
          onQueryTypeChange(type);

          if (runOnBlur) {
            onRunQuery();
          }
        }
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
      "data-testid": "lineLimitField",
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)('gf-form', _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
            flex-wrap: nowrap;
          `),
      "aria-label": "Line limit field",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
        label: "Line limit",
        tooltip: 'Upper limit for number of log lines returned by query.',
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Input, {
          className: "width-4",
          placeholder: "auto",
          type: "number",
          min: 0,
          onChange: onMaxLinesChange,
          onKeyDown: onReturnKeyDown,
          value: lineLimitValue,
          onBlur: () => {
            if (runOnBlur) {
              onRunQuery();
            }
          }
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
        label: "Resolution",
        tooltip: 'Resolution 1/1 sets step parameter of Loki metrics range queries such that each pixel corresponds to one data point. For better performance, lower resolutions can be picked. 1/2 only retrieves a data point for every other pixel, and 1/10 retrieves one data point per 10 pixels.',
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
          isSearchable: false,
          onChange: onResolutionChange,
          options: RESOLUTION_OPTIONS,
          value: resolution,
          "aria-label": "Select resolution"
        })
      })]
    })]
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_2__.memo)(LokiOptionFields));
function preprocessMaxLines(value) {
  if (value.length === 0) {
    // empty input - falls back to dataSource.maxLines limit
    return NaN;
  } else if (value.length > 0 && (isNaN(+value) || +value < 0)) {
    // input with at least 1 character and that is either incorrect (value in the input field is not a number) or negative
    // falls back to the limit of 0 lines
    return 0;
  } else {
    // default case - correct input
    return +value;
  }
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditor": () => (/* binding */ LokiQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _LokiOptionFields__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var _LokiQueryField__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel;

// Libraries
 // Types







function LokiQueryEditor(props) {
  var _query$maxLines;

  const {
    query,
    data,
    datasource,
    onChange,
    onRunQuery,
    range
  } = props;

  const onLegendChange = e => {
    const nextQuery = Object.assign({}, query, {
      legendFormat: e.currentTarget.value
    });
    onChange(nextQuery);
  };

  const legendField = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: "gf-form-inline",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: "gf-form",
      children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
        width: 6,
        tooltip: "Controls the name of the time series, using name or pattern. For example {{hostname}} will be replaced with label value for the label hostname. The legend only applies to metric queries.",
        children: "Legend"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("input", {
        type: "text",
        className: "gf-form-input",
        placeholder: "legend format",
        value: query.legendFormat || '',
        onChange: onLegendChange,
        onBlur: onRunQuery
      })]
    })
  });

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LokiQueryField__WEBPACK_IMPORTED_MODULE_3__.LokiQueryField, {
    datasource: datasource,
    query: query,
    onChange: onChange,
    onRunQuery: onRunQuery,
    onBlur: onRunQuery,
    history: [],
    data: data,
    "data-testid": testIds.editor,
    range: range,
    ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LokiOptionFields__WEBPACK_IMPORTED_MODULE_2__.LokiOptionFields, {
        lineLimitValue: (query === null || query === void 0 ? void 0 : (_query$maxLines = query.maxLines) === null || _query$maxLines === void 0 ? void 0 : _query$maxLines.toString()) || '',
        resolution: (query === null || query === void 0 ? void 0 : query.resolution) || 1,
        query: query,
        onRunQuery: onRunQuery,
        onChange: onChange,
        runOnBlur: true
      }), legendField]
    })
  });
}
const testIds = {
  editor: 'loki-editor'
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryEditorByApp.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditorByApp": () => (/* binding */ LokiQueryEditorByApp),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _querybuilder_components_LokiQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryEditorSelector.tsx");
/* harmony import */ var _LokiExploreQueryEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiExploreQueryEditor.tsx");
/* harmony import */ var _LokiQueryEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx");
/* harmony import */ var _LokiQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditorForAlerting.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








function LokiQueryEditorByApp(props) {
  const {
    app
  } = props;

  switch (app) {
    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.CloudAlerting:
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_6__.LokiQueryEditorForAlerting, Object.assign({}, props));

    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.featureToggles.lokiQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_LokiQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__.LokiQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiExploreQueryEditor__WEBPACK_IMPORTED_MODULE_4__.LokiExploreQueryEditor, Object.assign({}, props));

    default:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.featureToggles.lokiQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_LokiQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__.LokiQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiQueryEditor__WEBPACK_IMPORTED_MODULE_5__.LokiQueryEditor, Object.assign({}, props));
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(LokiQueryEditorByApp));

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryEditorForAlerting.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditorForAlerting": () => (/* binding */ LokiQueryEditorForAlerting),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _LokiQueryField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");



function LokiQueryEditorForAlerting(props) {
  const {
    query,
    data,
    datasource,
    onChange,
    onRunQuery
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_LokiQueryField__WEBPACK_IMPORTED_MODULE_1__.LokiQueryField, {
    datasource: datasource,
    query: query,
    onChange: onChange,
    onRunQuery: onRunQuery,
    onBlur: onRunQuery,
    history: [],
    data: data,
    placeholder: "Enter a Loki query",
    "data-testid": testIds.editor
  });
}
const testIds = {
  editor: 'loki-editor-cloud-alerting'
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryField": () => (/* binding */ LokiQueryField)
/* harmony export */ });
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.28.0-28f20a79ff-bde93fb2be.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/components/LocalStorageValueProvider/index.tsx");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/language_utils.ts");
/* harmony import */ var _LokiLabelBrowser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiLabelBrowser.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }











const LAST_USED_LABELS_KEY = 'grafana.datasources.loki.browser.labels';

function getChooserText(hasSyntax, hasLogLabels) {
  if (!hasSyntax) {
    return 'Loading labels...';
  }

  if (!hasLogLabels) {
    return '(No logs found)';
  }

  return 'Log browser';
}

function willApplySuggestion(suggestion, {
  typeaheadContext,
  typeaheadText
}) {
  // Modify suggestion based on context
  switch (typeaheadContext) {
    case 'context-labels':
      {
        const nextChar = _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.DOMUtil.getNextCharacter();

        if (!nextChar || nextChar === '}' || nextChar === ',') {
          suggestion += '=';
        }

        break;
      }

    case 'context-label-values':
      {
        // Always add quotes and remove existing ones instead
        let suggestionModified = '';

        if (!typeaheadText.match(/^(!?=~?"|")/)) {
          suggestionModified = '"';
        }

        suggestionModified += (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.escapeLabelValueInSelector)(suggestion, typeaheadText);

        if (_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.DOMUtil.getNextCharacter() !== '"') {
          suggestionModified += '"';
        }

        suggestion = suggestionModified;
        break;
      }

    default:
  }

  return suggestion;
}

class LokiQueryField extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "plugins", void 0);

    _defineProperty(this, "_isMounted", false);

    _defineProperty(this, "onChangeLabelBrowser", selector => {
      this.onChangeQuery(selector, true);
      this.setState({
        labelBrowserVisible: false
      });
    });

    _defineProperty(this, "onChangeQuery", (value, override) => {
      // Send text change to parent
      const {
        query,
        onChange,
        onRunQuery
      } = this.props;

      if (onChange) {
        const nextQuery = Object.assign({}, query, {
          expr: value
        });
        onChange(nextQuery);

        if (override && onRunQuery) {
          onRunQuery();
        }
      }
    });

    _defineProperty(this, "onClickChooserButton", () => {
      if (!this.state.labelBrowserVisible) {
        (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.reportInteraction)('grafana_loki_log_browser_opened', {
          app: this.props.app
        });
      } else {
        (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.reportInteraction)('grafana_loki_log_browser_closed', {
          app: this.props.app,
          closeType: 'logBrowserButton'
        });
      }

      this.setState(state => ({
        labelBrowserVisible: !state.labelBrowserVisible
      }));
    });

    _defineProperty(this, "onTypeahead", async typeahead => {
      const {
        datasource
      } = this.props;

      if (!datasource.languageProvider) {
        return {
          suggestions: []
        };
      }

      const lokiLanguageProvider = datasource.languageProvider;
      const {
        history
      } = this.props;
      const {
        prefix,
        text,
        value,
        wrapperClasses,
        labelKey
      } = typeahead;
      const result = await lokiLanguageProvider.provideCompletionItems({
        text,
        value,
        prefix,
        wrapperClasses,
        labelKey
      }, {
        history
      });
      return result;
    });

    this.state = {
      labelsLoaded: false,
      labelBrowserVisible: false
    };
    this.plugins = [(0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.BracesPlugin)(), (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.SlatePrism)({
      onlyIn: node => node.object === 'block' && node.type === 'code_block',
      getSyntax: node => 'logql'
    }, Object.assign({}, prismjs__WEBPACK_IMPORTED_MODULE_0__.languages, {
      logql: this.props.datasource.languageProvider.getSyntax()
    }))];
  }

  async componentDidMount() {
    this._isMounted = true;
    await this.props.datasource.languageProvider.start();

    if (this._isMounted) {
      this.setState({
        labelsLoaded: true
      });
    }
  }

  componentWillUnmount() {
    this._isMounted = false;
  }

  componentDidUpdate(prevProps) {
    const {
      range,
      datasource: {
        languageProvider
      }
    } = this.props;
    const refreshLabels = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.shouldRefreshLabels)(range, prevProps.range); // We want to refresh labels when range changes (we round up intervals to a minute)

    if (refreshLabels) {
      languageProvider.fetchLabels();
    }
  }

  render() {
    const {
      ExtraFieldElement,
      query,
      app,
      datasource,
      placeholder = 'Enter a Loki query (run with Shift+Enter)'
    } = this.props;
    const {
      labelsLoaded,
      labelBrowserVisible
    } = this.state;
    const lokiLanguageProvider = datasource.languageProvider;
    const cleanText = datasource.languageProvider ? lokiLanguageProvider.cleanText : undefined;
    const hasLogLabels = lokiLanguageProvider.getLabelKeys().length > 0;
    const chooserText = getChooserText(labelsLoaded, hasLogLabels);
    const buttonDisabled = !(labelsLoaded && hasLogLabels);
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_4__.LocalStorageValueProvider, {
      storageKey: LAST_USED_LABELS_KEY,
      defaultValue: [],
      children: (lastUsedLabels, onLastUsedLabelsSave, onLastUsedLabelsDelete) => {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.Fragment, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
            className: "gf-form-inline gf-form-inline--xs-view-flex-column flex-grow-1",
            "data-testid": this.props['data-testid'],
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("button", {
              className: "gf-form-label query-keyword pointer",
              onClick: this.onClickChooserButton,
              disabled: buttonDisabled,
              children: [chooserText, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
                name: labelBrowserVisible ? 'angle-down' : 'angle-right'
              })]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
              className: "gf-form gf-form--grow flex-shrink-1 min-width-15",
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.QueryField, {
                additionalPlugins: this.plugins,
                cleanText: cleanText,
                query: query.expr,
                onTypeahead: this.onTypeahead,
                onWillApplySuggestion: willApplySuggestion,
                onChange: this.onChangeQuery,
                onBlur: this.props.onBlur,
                onRunQuery: this.props.onRunQuery,
                placeholder: placeholder,
                portalOrigin: "loki"
              })
            })]
          }), labelBrowserVisible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
            className: "gf-form",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiLabelBrowser__WEBPACK_IMPORTED_MODULE_6__.LokiLabelBrowser, {
              languageProvider: lokiLanguageProvider,
              onChange: this.onChangeLabelBrowser,
              lastUsedLabels: lastUsedLabels || [],
              storeLastUsedLabels: onLastUsedLabelsSave,
              deleteLastUsedLabels: onLastUsedLabelsDelete,
              app: app
            })
          }), ExtraFieldElement]
        });
      }
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/ConfigEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigEditor": () => (/* binding */ ConfigEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/alerting/unified/utils/alertmanager.ts");
/* harmony import */ var _DerivedFields__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/DerivedFields.tsx");
/* harmony import */ var _MaxLinesField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/MaxLinesField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









const makeJsonUpdater = field => (options, value) => {
  return Object.assign({}, options, {
    jsonData: Object.assign({}, options.jsonData, {
      [field]: value
    })
  });
};

const setMaxLines = makeJsonUpdater('maxLines');
const setDerivedFields = makeJsonUpdater('derivedFields');
const ConfigEditor = props => {
  const {
    options,
    onOptionsChange
  } = props;
  const alertmanagers = (0,app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_2__.getAllAlertmanagerDataSources)();
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.DataSourceHttpSettings, {
      defaultUrl: 'http://localhost:3100',
      dataSourceConfig: options,
      showAccessOptions: false,
      onChange: onOptionsChange
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.AlertingSettings, {
      alertmanagerDataSources: alertmanagers,
      options: options,
      onOptionsChange: onOptionsChange
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: "gf-form-group",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_MaxLinesField__WEBPACK_IMPORTED_MODULE_4__.MaxLinesField, {
            value: options.jsonData.maxLines || '',
            onChange: value => onOptionsChange(setMaxLines(options, value))
          })
        })
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_DerivedFields__WEBPACK_IMPORTED_MODULE_3__.DerivedFields, {
      value: options.jsonData.derivedFields,
      onChange: value => onOptionsChange(setDerivedFields(options, value))
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/DebugSection.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebugSection": () => (/* binding */ DebugSection)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/classnames-npm-2.3.1-f2ae0a8d3c-14db8889d5.zip/node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _features_explore_utils_links__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/explore/utils/links.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _thead;









const {
  FormField
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.LegacyForms;
const DebugSection = props => {
  const {
    derivedFields,
    className
  } = props;
  const [debugText, setDebugText] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)('');
  let debugFields = [];

  if (debugText && derivedFields) {
    debugFields = makeDebugFields(derivedFields, debugText);
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
    className: className,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(FormField, {
      labelWidth: 12,
      label: 'Debug log message',
      inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("textarea", {
        placeholder: 'Paste an example log line here to test the regular expressions of your derived fields',
        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('gf-form-input gf-form-textarea', _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
                width: 100%;
              `),
        value: debugText,
        onChange: event => setDebugText(event.currentTarget.value)
      })
    }), !!debugFields.length && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(DebugFields, {
      fields: debugFields
    })]
  });
};

const DebugFields = ({
  fields
}) => {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("table", {
    className: 'filter-table',
    children: [_thead || (_thead = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("thead", {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("tr", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("th", {
          children: "Name"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("th", {
          children: "Value"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("th", {
          children: "Url"
        })]
      })
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("tbody", {
      children: fields.map(field => {
        let value = field.value;

        if (field.error) {
          value = field.error.message;
        } else if (field.href) {
          value = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("a", {
            href: field.href,
            children: value
          });
        }

        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("tr", {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("td", {
            children: field.name
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("td", {
            children: value
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("td", {
            children: field.href ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("a", {
              href: field.href,
              children: field.href
            }) : ''
          })]
        }, `${field.name}=${field.value}`);
      })
    })]
  });
};

function makeDebugFields(derivedFields, debugText) {
  return derivedFields.filter(field => field.name && field.matcherRegex).map(field => {
    try {
      const testMatch = debugText.match(field.matcherRegex);
      const value = testMatch && testMatch[1];
      let link = null;

      if (field.url && value) {
        link = (0,_features_explore_utils_links__WEBPACK_IMPORTED_MODULE_5__.getFieldLinksForExplore)({
          field: {
            name: '',
            type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.string,
            values: new _grafana_data__WEBPACK_IMPORTED_MODULE_3__.ArrayVector([value]),
            config: {
              links: [{
                title: '',
                url: field.url
              }]
            }
          },
          rowIndex: 0,
          range: {}
        })[0];
      }

      return {
        name: field.name,
        value: value || '<no match>',
        href: link && link.href
      };
    } catch (error) {
      return {
        name: field.name,
        error
      };
    }
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/DerivedField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DerivedField": () => (/* binding */ DerivedField)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







const {
  Switch,
  FormField
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.LegacyForms;
const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.stylesFactory)(() => ({
  row: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    align-items: baseline;
  `,
  nameField: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    flex: 2;
  `,
  regexField: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    flex: 3;
  `,
  urlField: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    flex: 1;
  `,
  urlDisplayLabelField: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    flex: 1;
  `
}));
const DerivedField = props => {
  const {
    value,
    onChange,
    onDelete,
    suggestions,
    className
  } = props;
  const styles = getStyles();
  const [showInternalLink, setShowInternalLink] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!!value.datasourceUid);
  const previousUid = (0,react_use__WEBPACK_IMPORTED_MODULE_5__["default"])(value.datasourceUid); // Force internal link visibility change if uid changed outside of this component.

  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (!previousUid && value.datasourceUid && !showInternalLink) {
      setShowInternalLink(true);
    }

    if (previousUid && !value.datasourceUid && showInternalLink) {
      setShowInternalLink(false);
    }
  }, [previousUid, value.datasourceUid, showInternalLink]);

  const handleChange = field => event => {
    onChange(Object.assign({}, value, {
      [field]: event.currentTarget.value
    }));
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
    className: className,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.row,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        className: styles.nameField,
        labelWidth: 5 // A bit of a hack to prevent using default value for the width from FormField
        ,
        inputWidth: null,
        label: "Name",
        type: "text",
        value: value.name,
        onChange: handleChange('name')
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        className: styles.regexField,
        inputWidth: null,
        label: "Regex",
        type: "text",
        value: value.matcherRegex,
        onChange: handleChange('matcherRegex'),
        tooltip: 'Use to parse and capture some part of the log message. You can use the captured groups in the template.'
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
        variant: "destructive",
        title: "Remove field",
        icon: "times",
        onClick: event => {
          event.preventDefault();
          onDelete();
        },
        className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
            margin-left: 8px;
          `
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.row,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        label: showInternalLink ? 'Query' : 'URL',
        inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.DataLinkInput, {
          placeholder: showInternalLink ? '${__value.raw}' : 'http://example.com/${__value.raw}',
          value: value.url || '',
          onChange: newValue => onChange(Object.assign({}, value, {
            url: newValue
          })),
          suggestions: suggestions
        }),
        className: styles.urlField
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        className: styles.urlDisplayLabelField,
        inputWidth: null,
        label: "URL Label",
        type: "text",
        value: value.urlDisplayLabel,
        onChange: handleChange('urlDisplayLabel'),
        tooltip: 'Use to override the button label when this derived field is found in a log.'
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.row,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Switch, {
        label: "Internal link",
        checked: showInternalLink,
        onChange: () => {
          if (showInternalLink) {
            onChange(Object.assign({}, value, {
              datasourceUid: undefined
            }));
          }

          setShowInternalLink(!showInternalLink);
        }
      }), showInternalLink && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.DataSourcePicker, {
        tracing: true,
        onChange: ds => onChange(Object.assign({}, value, {
          datasourceUid: ds.uid
        })),
        current: value.datasourceUid
      })]
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/DerivedFields.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DerivedFields": () => (/* binding */ DerivedFields)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _DebugSection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/DebugSection.tsx");
/* harmony import */ var _DerivedField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/DerivedField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;











const getStyles = theme => ({
  infoText: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding-bottom: ${theme.spacing(2)};
    color: ${theme.colors.text.secondary};
  `,
  derivedField: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-bottom: ${theme.spacing(1)};
  `
});

const DerivedFields = props => {
  const {
    value,
    onChange
  } = props;
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useTheme2)();
  const styles = getStyles(theme);
  const [showDebug, setShowDebug] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
    children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("h3", {
      className: "page-heading",
      children: "Derived fields"
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: styles.infoText,
      children: "Derived fields can be used to extract new fields from a log message and create a link from its value."
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
      className: "gf-form-group",
      children: [value && value.map((field, index) => {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_DerivedField__WEBPACK_IMPORTED_MODULE_5__.DerivedField, {
          className: styles.derivedField,
          value: field,
          onChange: newField => {
            const newDerivedFields = [...value];
            newDerivedFields.splice(index, 1, newField);
            onChange(newDerivedFields);
          },
          onDelete: () => {
            const newDerivedFields = [...value];
            newDerivedFields.splice(index, 1);
            onChange(newDerivedFields);
          },
          suggestions: [{
            value: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataLinkBuiltInVars.valueRaw,
            label: 'Raw value',
            documentation: 'Exact string captured by the regular expression',
            origin: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.VariableOrigin.Value
          }]
        }, index);
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          variant: "secondary",
          className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
              margin-right: 10px;
            `,
          icon: "plus",
          onClick: event => {
            event.preventDefault();
            const newDerivedFields = [...(value || []), {
              name: '',
              matcherRegex: ''
            }];
            onChange(newDerivedFields);
          },
          children: "Add"
        }), value && value.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          variant: "secondary",
          type: "button",
          onClick: () => setShowDebug(!showDebug),
          children: showDebug ? 'Hide example log message' : 'Show example log message'
        })]
      })]
    }), showDebug && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: "gf-form-group",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_DebugSection__WEBPACK_IMPORTED_MODULE_4__.DebugSection, {
        className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
              margin-bottom: 10px;
            `,
        derivedFields: value
      })
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/MaxLinesField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaxLinesField": () => (/* binding */ MaxLinesField)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




const {
  FormField
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_1__.LegacyForms;
const MaxLinesField = props => {
  const {
    value,
    onChange
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(FormField, {
    label: "Maximum lines",
    labelWidth: 11,
    inputWidth: 20,
    inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("input", {
      type: "number",
      className: "gf-form-input width-8 gf-form-input--has-help-icon",
      value: value,
      onChange: event => onChange(event.currentTarget.value),
      spellCheck: false,
      placeholder: "1000"
    }),
    tooltip: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
      children: "Loki queries must contain a limit of the maximum number of lines returned (default: 1000). Increase this limit to have a bigger result set for ad-hoc analysis. Decrease this limit if your browser becomes sluggish when displaying the log results."
    })
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/datasource.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_MAX_LINES": () => (/* binding */ DEFAULT_MAX_LINES),
/* harmony export */   "LOKI_ENDPOINT": () => (/* binding */ LOKI_ENDPOINT),
/* harmony export */   "LokiDatasource": () => (/* binding */ LokiDatasource),
/* harmony export */   "isMetricsQuery": () => (/* binding */ isMetricsQuery),
/* harmony export */   "lokiRegularEscape": () => (/* binding */ lokiRegularEscape),
/* harmony export */   "lokiSpecialRegexEscape": () => (/* binding */ lokiSpecialRegexEscape)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.28.0-28f20a79ff-bde93fb2be.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/throwError.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/merge.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/catchError.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/switchMap.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var app_core_logs_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/logs_model.ts");
/* harmony import */ var app_core_utils_explore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/utils/explore.ts");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
/* harmony import */ var app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/templating/template_srv.ts");
/* harmony import */ var _core_utils_fetch__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/core/utils/fetch.ts");
/* harmony import */ var _prometheus_legend__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/datasource/loki/add_label_to_query.ts");
/* harmony import */ var _backendResultTransformer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/loki/backendResultTransformer.ts");
/* harmony import */ var _components_AnnotationsQueryEditor__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/loki/components/AnnotationsQueryEditor.tsx");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/loki/language_provider.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/loki/language_utils.ts");
/* harmony import */ var _live_streams__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/datasource/loki/live_streams.ts");
/* harmony import */ var _query_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./public/app/plugins/datasource/loki/query_utils.ts");
/* harmony import */ var _sortDataFrame__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./public/app/plugins/datasource/loki/sortDataFrame.ts");
/* harmony import */ var _streaming__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./public/app/plugins/datasource/loki/streaming.ts");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
const _excluded = ["__interval", "__interval_ms"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Libraries



 // Types




















const DEFAULT_MAX_LINES = 1000;
const LOKI_ENDPOINT = '/loki/api/v1';
const NS_IN_MS = 1000000;

function makeRequest(query, range, app, requestId) {
  const intervalInfo = _grafana_data__WEBPACK_IMPORTED_MODULE_2__.rangeUtil.calculateInterval(range, 1);
  return {
    targets: [query],
    requestId,
    interval: intervalInfo.interval,
    intervalMs: intervalInfo.intervalMs,
    range: range,
    scopedVars: {},
    timezone: 'UTC',
    app,
    startTime: Date.now()
  };
}

class LokiDatasource extends _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.DataSourceWithBackend {
  constructor(instanceSettings, templateSrv = (0,app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_7__.getTemplateSrv)(), timeSrv = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_6__.getTimeSrv)()) {
    var _settingsData$maxLine;

    super(instanceSettings);

    _defineProperty(this, "streams", new _live_streams__WEBPACK_IMPORTED_MODULE_15__.LiveStreams());

    _defineProperty(this, "languageProvider", void 0);

    _defineProperty(this, "maxLines", void 0);

    _defineProperty(this, "runLiveQuery", (target, maxDataPoints) => {
      const liveTarget = this.createLiveTarget(target, maxDataPoints);
      return this.streams.getStream(liveTarget).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.map)(data => ({
        data: data || [],
        key: `loki-${liveTarget.refId}`,
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LoadingState.Streaming
      })), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.catchError)(err => {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.throwError)(() => `Live tailing was stopped due to following error: ${err.reason}`);
      }));
    });

    _defineProperty(this, "getLogRowContext", (row, options) => {
      const direction = options && options.direction || 'BACKWARD';
      const limit = options && options.limit || 10;
      const {
        query,
        range
      } = this.prepareLogRowContextQueryTarget(row, limit, direction);

      const processDataFrame = frame => {
        // log-row-context requires specific field-names to work, so we set them here: "ts", "line", "id"
        const cache = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldCache(frame);
        const timestampField = cache.getFirstFieldOfType(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.time);
        const lineField = cache.getFirstFieldOfType(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.string);
        const idField = cache.getFieldByName('id');

        if (timestampField === undefined || lineField === undefined || idField === undefined) {
          // this should never really happen, but i want to keep typescript happy
          return Object.assign({}, frame, {
            fields: []
          });
        }

        return Object.assign({}, frame, {
          fields: [Object.assign({}, timestampField, {
            name: 'ts'
          }), Object.assign({}, lineField, {
            name: 'line'
          }), Object.assign({}, idField, {
            name: 'id'
          })]
        });
      };

      const processResults = result => {
        const frames = result.data;
        const processedFrames = frames.map(frame => (0,_sortDataFrame__WEBPACK_IMPORTED_MODULE_17__.sortDataFrameByTime)(frame, 'DESCENDING')).map(frame => processDataFrame(frame)); // rename fields if needed

        return Object.assign({}, result, {
          data: processedFrames
        });
      }; // this can only be called from explore currently


      const app = _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Explore;
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.lastValueFrom)(this.query(makeRequest(query, range, app, `log-row-context-query-${direction}`)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.catchError)(err => {
        const error = {
          message: 'Error during context query. Please check JS console logs.',
          status: err.status,
          statusText: err.statusText
        };
        throw error;
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_25__.switchMap)(res => (0,rxjs__WEBPACK_IMPORTED_MODULE_26__.of)(processResults(res)))));
    });

    _defineProperty(this, "prepareLogRowContextQueryTarget", (row, limit, direction) => {
      const labels = this.languageProvider.getLabelKeys();
      const expr = Object.keys(row.labels).map(label => {
        if (labels.includes(label)) {
          // escape backslashes in label as users can't escape them by themselves
          return `${label}="${row.labels[label].replace(/\\/g, '\\\\')}"`;
        }

        return '';
      }) // Filter empty strings
      .filter(label => !!label).join(',');
      const contextTimeBuffer = 2 * 60 * 60 * 1000; // 2h buffer

      const queryDirection = direction === 'FORWARD' ? _types__WEBPACK_IMPORTED_MODULE_20__.LokiQueryDirection.Forward : _types__WEBPACK_IMPORTED_MODULE_20__.LokiQueryDirection.Backward;
      const query = {
        expr: `{${expr}}`,
        queryType: _types__WEBPACK_IMPORTED_MODULE_20__.LokiQueryType.Range,
        refId: '',
        maxLines: limit,
        direction: queryDirection
      };
      const fieldCache = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldCache(row.dataFrame);
      const tsField = fieldCache.getFirstFieldOfType(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.time);

      if (tsField === undefined) {
        throw new Error('loki: dataframe missing time-field, should never happen');
      }

      const tsValue = tsField.values.get(row.rowIndex);
      const timestamp = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toUtc)(tsValue);
      const range = queryDirection === _types__WEBPACK_IMPORTED_MODULE_20__.LokiQueryDirection.Forward ? {
        // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from
        // and any other that were logged in the same ns but before the row. Right now these rows will be lost
        // because the are before but came it he response that should return only rows after.
        from: timestamp,
        // convert to ns, we loose some precision here but it is not that important at the far points of the context
        to: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toUtc)(row.timeEpochMs + contextTimeBuffer)
      } : {
        // convert to ns, we loose some precision here but it is not that important at the far points of the context
        from: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toUtc)(row.timeEpochMs - contextTimeBuffer),
        to: timestamp
      };
      return {
        query,
        range: {
          from: range.from,
          to: range.to,
          raw: range
        }
      };
    });

    this.instanceSettings = instanceSettings;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.languageProvider = new _language_provider__WEBPACK_IMPORTED_MODULE_13__["default"](this);
    const settingsData = instanceSettings.jsonData || {};
    this.maxLines = parseInt((_settingsData$maxLine = settingsData.maxLines) !== null && _settingsData$maxLine !== void 0 ? _settingsData$maxLine : '0', 10) || DEFAULT_MAX_LINES;
    this.annotations = {
      QueryEditor: _components_AnnotationsQueryEditor__WEBPACK_IMPORTED_MODULE_12__.LokiAnnotationsQueryEditor
    };
  }

  getLogsVolumeDataProvider(request) {
    const isQuerySuitable = query => {
      const normalized = (0,_query_utils__WEBPACK_IMPORTED_MODULE_16__.getNormalizedLokiQuery)(query);
      const {
        expr
      } = normalized; // it has to be a logs-producing range-query

      return expr && !isMetricsQuery(expr) && normalized.queryType === _types__WEBPACK_IMPORTED_MODULE_20__.LokiQueryType.Range;
    };

    const isLogsVolumeAvailable = request.targets.some(isQuerySuitable);

    if (!isLogsVolumeAvailable) {
      return undefined;
    }

    const logsVolumeRequest = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(request);
    logsVolumeRequest.targets = logsVolumeRequest.targets.filter(isQuerySuitable).map(target => {
      return Object.assign({}, target, {
        instant: false,
        volumeQuery: true,
        expr: `sum by (level) (count_over_time(${target.expr}[$__interval]))`
      });
    });
    return (0,app_core_logs_model__WEBPACK_IMPORTED_MODULE_4__.queryLogsVolume)(this, logsVolumeRequest, {
      extractLevel,
      range: request.range,
      targets: request.targets
    });
  }

  query(request) {
    var _fixedRequest$rangeRa;

    const queries = request.targets.map(_query_utils__WEBPACK_IMPORTED_MODULE_16__.getNormalizedLokiQuery) // "fix" the `.queryType` prop
    .map(q => Object.assign({}, q, {
      maxLines: q.maxLines || this.maxLines
    })); // set maxLines if not set

    const fixedRequest = Object.assign({}, request, {
      targets: queries
    });
    const streamQueries = fixedRequest.targets.filter(q => q.queryType === _types__WEBPACK_IMPORTED_MODULE_20__.LokiQueryType.Stream);

    if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.featureToggles.lokiLive && streamQueries.length > 0 && ((_fixedRequest$rangeRa = fixedRequest.rangeRaw) === null || _fixedRequest$rangeRa === void 0 ? void 0 : _fixedRequest$rangeRa.to) === 'now') {
      // this is still an in-development feature,
      // we do not support mixing stream-queries with normal-queries for now.
      const streamRequest = Object.assign({}, fixedRequest, {
        targets: streamQueries
      });
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_27__.merge)(...streamQueries.map(q => (0,_streaming__WEBPACK_IMPORTED_MODULE_18__.doLokiChannelStream)(q, this, streamRequest)));
    }

    if (fixedRequest.liveStreaming) {
      return this.runLiveQueryThroughBackend(fixedRequest);
    } else {
      return super.query(fixedRequest).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.map)(response => {
        var _this$instanceSetting;

        return (0,_backendResultTransformer__WEBPACK_IMPORTED_MODULE_11__.transformBackendResult)(response, fixedRequest.targets, (_this$instanceSetting = this.instanceSettings.jsonData.derivedFields) !== null && _this$instanceSetting !== void 0 ? _this$instanceSetting : []);
      }));
    }
  }

  runLiveQueryThroughBackend(request) {
    // this only works in explore-mode, so variables don't need to be handled,
    //  and only for logs-queries, not metric queries
    const logsQueries = request.targets.filter(query => query.expr !== '' && !isMetricsQuery(query.expr));

    if (logsQueries.length === 0) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_26__.of)({
        data: [],
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LoadingState.Done
      });
    }

    const subQueries = logsQueries.map(query => {
      const maxDataPoints = query.maxLines || this.maxLines; // FIXME: currently we are running it through the frontend still.

      return this.runLiveQuery(query, maxDataPoints);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_27__.merge)(...subQueries);
  }

  createLiveTarget(target, maxDataPoints) {
    const query = target.expr;
    const baseUrl = this.instanceSettings.url;
    const params = (0,_core_utils_fetch__WEBPACK_IMPORTED_MODULE_8__.serializeParams)({
      query
    });
    return {
      query,
      url: (0,app_core_utils_explore__WEBPACK_IMPORTED_MODULE_5__.convertToWebSocketUrl)(`${baseUrl}/loki/api/v1/tail?${params}`),
      refId: target.refId,
      size: maxDataPoints
    };
  }
  /**
   * Runs live queries which in this case means creating a websocket and listening on it for new logs.
   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple
   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique
   * labels per row.
   */


  getRangeScopedVars(range = this.timeSrv.timeRange()) {
    const msRange = range.to.diff(range.from);
    const sRange = Math.round(msRange / 1000);
    return {
      __range_ms: {
        text: msRange,
        value: msRange
      },
      __range_s: {
        text: sRange,
        value: sRange
      },
      __range: {
        text: sRange + 's',
        value: sRange + 's'
      }
    };
  }

  interpolateVariablesInQueries(queries, scopedVars) {
    let expandedQueries = queries;

    if (queries && queries.length) {
      expandedQueries = queries.map(query => Object.assign({}, query, {
        datasource: this.getRef(),
        expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr)
      }));
    }

    return expandedQueries;
  }

  getQueryDisplayText(query) {
    return query.expr;
  }

  getTimeRangeParams() {
    const timeRange = this.timeSrv.timeRange();
    return {
      start: timeRange.from.valueOf() * NS_IN_MS,
      end: timeRange.to.valueOf() * NS_IN_MS
    };
  }

  async importFromAbstractQueries(abstractQueries) {
    await this.languageProvider.start();
    const existingKeys = this.languageProvider.labelKeys;

    if (existingKeys && existingKeys.length) {
      abstractQueries = abstractQueries.map(abstractQuery => {
        abstractQuery.labelMatchers = abstractQuery.labelMatchers.filter(labelMatcher => {
          return existingKeys.includes(labelMatcher.name);
        });
        return abstractQuery;
      });
    }

    return abstractQueries.map(abstractQuery => this.languageProvider.importFromAbstractQuery(abstractQuery));
  }

  async exportToAbstractQueries(queries) {
    return queries.map(query => this.languageProvider.exportToAbstractQuery(query));
  }

  async metadataRequest(url, params) {
    // url must not start with a `/`, otherwise the AJAX-request
    // going from the browser will contain `//`, which can cause problems.
    if (url.startsWith('/')) {
      throw new Error(`invalid metadata request url: ${url}`);
    }

    const res = await this.getResource(url, params);
    return res.data || [];
  }

  async metricFindQuery(query) {
    if (!query) {
      return Promise.resolve([]);
    }

    const interpolated = this.templateSrv.replace(query, {}, this.interpolateQueryExpr);
    return await this.processMetricFindQuery(interpolated);
  }

  async processMetricFindQuery(query) {
    const labelNamesRegex = /^label_names\(\)\s*$/;
    const labelValuesRegex = /^label_values\((?:(.+),\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\)\s*$/;
    const labelNames = query.match(labelNamesRegex);

    if (labelNames) {
      return await this.labelNamesQuery();
    }

    const labelValues = query.match(labelValuesRegex);

    if (labelValues) {
      // If we have query expr, use /series endpoint
      if (labelValues[1]) {
        return await this.labelValuesSeriesQuery(labelValues[1], labelValues[2]);
      }

      return await this.labelValuesQuery(labelValues[2]);
    }

    return Promise.resolve([]);
  }

  async labelNamesQuery() {
    const url = 'labels';
    const params = this.getTimeRangeParams();
    const result = await this.metadataRequest(url, params);
    return result.map(value => ({
      text: value
    }));
  }

  async labelValuesQuery(label) {
    const params = this.getTimeRangeParams();
    const url = `label/${label}/values`;
    const result = await this.metadataRequest(url, params);
    return result.map(value => ({
      text: value
    }));
  }

  async labelValuesSeriesQuery(expr, label) {
    const timeParams = this.getTimeRangeParams();
    const params = Object.assign({}, timeParams, {
      'match[]': expr
    });
    const url = 'series';
    const streams = new Set();
    const result = await this.metadataRequest(url, params);
    result.forEach(stream => {
      if (stream[label]) {
        streams.add({
          text: stream[label]
        });
      }
    });
    return Array.from(streams);
  } // By implementing getTagKeys and getTagValues we add ad-hoc filtters functionality


  async getTagKeys() {
    return await this.labelNamesQuery();
  }

  async getTagValues(options = {}) {
    return await this.labelValuesQuery(options.key);
  }

  interpolateQueryExpr(value, variable) {
    // if no multi or include all do not regexEscape
    if (!variable.multi && !variable.includeAll) {
      return lokiRegularEscape(value);
    }

    if (typeof value === 'string') {
      return lokiSpecialRegexEscape(value);
    }

    const escapedValues = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(value, lokiSpecialRegexEscape);
    return escapedValues.join('|');
  }

  modifyQuery(query, action) {
    var _query$expr;

    let expression = (_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : '';

    switch (action.type) {
      case 'ADD_FILTER':
        {
          expression = this.addLabelToQuery(expression, action.key, '=', action.value);
          break;
        }

      case 'ADD_FILTER_OUT':
        {
          expression = this.addLabelToQuery(expression, action.key, '!=', action.value);
          break;
        }

      default:
        break;
    }

    return Object.assign({}, query, {
      expr: expression
    });
  }

  getTime(date, roundUp) {
    if (typeof date === 'string') {
      date = _grafana_data__WEBPACK_IMPORTED_MODULE_2__.dateMath.parse(date, roundUp);
    }

    return Math.ceil(date.valueOf() * 1e6);
  }

  testDatasource() {
    // Consider only last 10 minutes otherwise request takes too long
    const nowMs = Date.now();
    const params = {
      start: (nowMs - 10 * 60 * 1000) * NS_IN_MS,
      end: nowMs * NS_IN_MS
    };
    return this.metadataRequest('labels', params).then(values => {
      return values.length > 0 ? {
        status: 'success',
        message: 'Data source connected and labels found.'
      } : {
        status: 'error',
        message: 'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.'
      };
    }, err => {
      var _err$data$message, _err$data;

      // we did a resource-call that failed.
      // the only info we have, if exists, is err.data.message
      // (when in development-mode, err.data.error exists too, but not in production-mode)
      // things like err.status & err.statusText does not help,
      // because those will only describe how the request between browser<>server failed
      const info = (_err$data$message = err === null || err === void 0 ? void 0 : (_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.message) !== null && _err$data$message !== void 0 ? _err$data$message : '';
      const infoInParentheses = info !== '' ? ` (${info})` : '';
      const message = `Unable to fetch labels from Loki${infoInParentheses}, please check the server logs for more details`;
      return {
        status: 'error',
        message: message
      };
    });
  }

  async annotationQuery(options) {
    const {
      expr,
      maxLines,
      instant,
      tagKeys = '',
      titleFormat = '',
      textFormat = ''
    } = options.annotation;

    if (!expr) {
      return [];
    }

    const id = `annotation-${options.annotation.name}`;
    const query = {
      refId: id,
      expr,
      maxLines,
      instant,
      queryType: instant ? _types__WEBPACK_IMPORTED_MODULE_20__.LokiQueryType.Instant : _types__WEBPACK_IMPORTED_MODULE_20__.LokiQueryType.Range
    };
    const request = makeRequest(query, options.range, _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Dashboard, id);
    const {
      data
    } = await (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.lastValueFrom)(this.query(request));
    const annotations = [];
    const splitKeys = tagKeys.split(',').filter(v => v !== '');

    for (const frame of data) {
      const view = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataFrameView(frame);
      view.forEach(row => {
        const {
          labels
        } = row;
        const maybeDuplicatedTags = Object.entries(labels).map(([key, val]) => [key, val.trim()]) // trim all label-values
        .filter(([key, val]) => {
          if (val === '') {
            // remove empty
            return false;
          } // if tags are specified, remove label if does not match tags


          if (splitKeys.length && !splitKeys.includes(key)) {
            return false;
          }

          return true;
        }).map(([key, val]) => val); // keep only the label-value
        // remove duplicates

        const tags = Array.from(new Set(maybeDuplicatedTags));
        annotations.push({
          time: new Date(row.Time).valueOf(),
          title: (0,_prometheus_legend__WEBPACK_IMPORTED_MODULE_9__.renderLegendFormat)(titleFormat, labels),
          text: (0,_prometheus_legend__WEBPACK_IMPORTED_MODULE_9__.renderLegendFormat)(textFormat, labels) || row.Line,
          tags
        });
      });
    }

    return annotations;
  }

  showContextToggle(row) {
    return (row && row.searchWords && row.searchWords.length > 0) === true;
  }

  processError(err, target) {
    let error = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(err);
    error.refId = target.refId;

    if (error.data && err.data.message.includes('escape') && target.expr.includes('\\')) {
      error.data.message = `Error: ${err.data.message}. Make sure that all special characters are escaped with \\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`;
    }

    return error;
  }

  addAdHocFilters(queryExpr) {
    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);
    let expr = queryExpr;
    expr = adhocFilters.reduce((acc, filter) => {
      const {
        key,
        operator,
        value
      } = filter;
      return this.addLabelToQuery(acc, key, operator, value);
    }, expr);
    return expr;
  }

  addLabelToQuery(queryExpr, key, operator, value) {
    const escapedValue = (0,_language_utils__WEBPACK_IMPORTED_MODULE_14__.escapeLabelValueInSelector)(value, operator);
    return (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_10__.addLabelToQuery)(queryExpr, key, operator, escapedValue);
  } // Used when running queries through backend


  filterQuery(query) {
    if (query.hide || query.expr === '') {
      return false;
    }

    return true;
  } // Used when running queries through backend


  applyTemplateVariables(target, scopedVars) {
    // We want to interpolate these variables on backend
    const rest = _objectWithoutPropertiesLoose(scopedVars, _excluded);

    const exprWithAdHoc = this.addAdHocFilters(target.expr);
    return Object.assign({}, target, {
      legendFormat: this.templateSrv.replace(target.legendFormat, rest),
      expr: this.templateSrv.replace(exprWithAdHoc, rest, this.interpolateQueryExpr)
    });
  }

  interpolateString(string) {
    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);
  }

  getVariables() {
    return this.templateSrv.getVariables().map(v => `$${v.name}`);
  }

}
function lokiRegularEscape(value) {
  if (typeof value === 'string') {
    return value.replace(/'/g, "\\\\'");
  }

  return value;
}
function lokiSpecialRegexEscape(value) {
  if (typeof value === 'string') {
    return lokiRegularEscape(value.replace(/\\/g, '\\\\\\\\').replace(/[$^*{}\[\]+?.()|]/g, '\\\\$&'));
  }

  return value;
}
/**
 * Checks if the query expression uses function and so should return a time series instead of logs.
 * Sometimes important to know that before we actually do the query.
 */

function isMetricsQuery(query) {
  if (!query) {
    return false;
  }

  const tokens = prismjs__WEBPACK_IMPORTED_MODULE_1___default().tokenize(query, _syntax__WEBPACK_IMPORTED_MODULE_19__["default"]);
  return tokens.some(t => {
    // Not sure in which cases it can be string maybe if nothing matched which means it should not be a function
    return typeof t !== 'string' && t.type === 'function';
  });
}

function extractLevel(dataFrame) {
  var _valueField;

  let valueField;

  try {
    valueField = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldCache(dataFrame).getFirstFieldOfType(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number);
  } catch {}

  return (_valueField = valueField) !== null && _valueField !== void 0 && _valueField.labels ? getLogLevelFromLabels(valueField.labels) : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LogLevel.unknown;
}

function getLogLevelFromLabels(labels) {
  const labelNames = ['level', 'lvl', 'loglevel'];
  let levelLabel;

  for (let labelName of labelNames) {
    if (labelName in labels) {
      levelLabel = labelName;
      break;
    }
  }

  return levelLabel ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.getLogLevelFromKey)(labels[levelLabel]) : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LogLevel.unknown;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/getDerivedFields.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDerivedFields": () => (/* binding */ getDerivedFields)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");



function getDerivedFields(dataFrame, derivedFieldConfigs) {
  if (!derivedFieldConfigs.length) {
    return [];
  }

  const derivedFieldsGrouped = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.groupBy)(derivedFieldConfigs, 'name');
  const newFields = Object.values(derivedFieldsGrouped).map(fieldFromDerivedFieldConfig); // line-field is the first string-field
  // NOTE: we should create some common log-frame-extra-string-field code somewhere

  const lineField = dataFrame.fields.find(f => f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string);

  if (lineField === undefined) {
    // if this is happening, something went wrong, let's raise an error
    throw new Error('invalid logs-dataframe, string-field missing');
  }

  lineField.values.toArray().forEach(line => {
    for (const field of newFields) {
      const logMatch = line.match(derivedFieldsGrouped[field.name][0].matcherRegex);
      field.values.add(logMatch && logMatch[1]);
    }
  });
  return newFields;
}
/**
 * Transform derivedField config into dataframe field with config that contains link.
 */

function fieldFromDerivedFieldConfig(derivedFieldConfigs) {
  const dataSourceSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.getDataSourceSrv)();
  const dataLinks = derivedFieldConfigs.reduce((acc, derivedFieldConfig) => {
    // Having field.datasourceUid means it is an internal link.
    if (derivedFieldConfig.datasourceUid) {
      var _dsSettings$name;

      const dsSettings = dataSourceSrv.getInstanceSettings(derivedFieldConfig.datasourceUid);
      acc.push({
        // Will be filled out later
        title: derivedFieldConfig.urlDisplayLabel || '',
        url: '',
        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object
        internal: {
          query: {
            query: derivedFieldConfig.url
          },
          datasourceUid: derivedFieldConfig.datasourceUid,
          datasourceName: (_dsSettings$name = dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name) !== null && _dsSettings$name !== void 0 ? _dsSettings$name : 'Data source not found'
        }
      });
    } else if (derivedFieldConfig.url) {
      acc.push({
        // We do not know what title to give here so we count on presentation layer to create a title from metadata.
        title: derivedFieldConfig.urlDisplayLabel || '',
        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object
        url: derivedFieldConfig.url
      });
    }

    return acc;
  }, []);
  return {
    name: derivedFieldConfigs[0].name,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string,
    config: {
      links: dataLinks
    },
    // We are adding values later on
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([])
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/language_provider.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LABEL_REFRESH_INTERVAL": () => (/* binding */ LABEL_REFRESH_INTERVAL),
/* harmony export */   "addHistoryMetadata": () => (/* binding */ addHistoryMetadata),
/* harmony export */   "default": () => (/* binding */ LokiLanguageProvider)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.10.1-5af910d0ed-e8b190d71e.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.28.0-28f20a79ff-bde93fb2be.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const DEFAULT_KEYS = ['job', 'namespace'];
const EMPTY_SELECTOR = '{}';
const HISTORY_ITEM_COUNT = 10;
const HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h

const NS_IN_MS = 1000000; // When changing RATE_RANGES, check if Prometheus/PromQL ranges should be changed too
// @see public/app/plugins/datasource/prometheus/promql.ts

const RATE_RANGES = [{
  label: '$__interval',
  sortValue: '$__interval'
}, {
  label: '$__range',
  sortValue: '$__range'
}, {
  label: '1m',
  sortValue: '00:01:00'
}, {
  label: '5m',
  sortValue: '00:05:00'
}, {
  label: '10m',
  sortValue: '00:10:00'
}, {
  label: '30m',
  sortValue: '00:30:00'
}, {
  label: '1h',
  sortValue: '01:00:00'
}, {
  label: '1d',
  sortValue: '24:00:00'
}];
const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec

const wrapLabel = label => ({
  label,
  filterText: `\"${label}\"`
});

function addHistoryMetadata(item, history) {
  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;
  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query.expr === item.label);
  let hint = `Queried ${historyForItem.length} times in the last 24h.`;
  const recent = historyForItem[0];

  if (recent) {
    const lastQueried = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(recent.ts).fromNow();
    hint = `${hint} Last queried ${lastQueried}.`;
  }

  return Object.assign({}, item, {
    documentation: hint
  });
}
class LokiLanguageProvider extends _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LanguageProvider {
  // Dynamically set to true for big/slow instances

  /**
   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does
   *  not account for different size of a response. If that is needed a `length` function can be added in the options.
   *  10 as a max size is totally arbitrary right now.
   */
  constructor(datasource, initialValues) {
    super();

    _defineProperty(this, "labelKeys", void 0);

    _defineProperty(this, "labelFetchTs", void 0);

    _defineProperty(this, "started", false);

    _defineProperty(this, "datasource", void 0);

    _defineProperty(this, "lookupsDisabled", false);

    _defineProperty(this, "seriesCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "labelsCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "cleanText", s => s.replace(/[{}[\]="(),!~+\-*/^%\|]/g, '').trim());

    _defineProperty(this, "request", async (url, params) => {
      try {
        return await this.datasource.metadataRequest(url, params);
      } catch (error) {
        console.error(error);
      }

      return undefined;
    });

    _defineProperty(this, "start", () => {
      if (!this.startTask) {
        this.startTask = this.fetchLabels().then(() => {
          this.started = true;
          return [];
        });
      }

      return this.startTask;
    });

    _defineProperty(this, "getBeginningCompletionItems", context => {
      return {
        suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions]
      };
    });

    _defineProperty(this, "getTermCompletionItems", () => {
      const suggestions = [];
      suggestions.push({
        prefixMatch: true,
        label: 'Functions',
        items: _syntax__WEBPACK_IMPORTED_MODULE_5__.FUNCTIONS.map(suggestion => Object.assign({}, suggestion, {
          kind: 'function'
        }))
      });
      return {
        suggestions
      };
    });

    _defineProperty(this, "getPipeCompletionItem", () => {
      const suggestions = [];
      suggestions.push({
        label: 'Operators',
        items: _syntax__WEBPACK_IMPORTED_MODULE_5__.PIPE_OPERATORS.map(suggestion => Object.assign({}, suggestion, {
          kind: 'operators'
        }))
      });
      suggestions.push({
        label: 'Parsers',
        items: _syntax__WEBPACK_IMPORTED_MODULE_5__.PIPE_PARSERS.map(suggestion => Object.assign({}, suggestion, {
          kind: 'parsers'
        }))
      });
      return {
        suggestions
      };
    });

    _defineProperty(this, "fetchSeriesLabels", async match => {
      const interpolatedMatch = this.datasource.interpolateString(match);
      const url = 'series';
      const {
        start,
        end
      } = this.datasource.getTimeRangeParams();
      const cacheKey = this.generateCacheKey(url, start, end, interpolatedMatch);
      let value = this.seriesCache.get(cacheKey);

      if (!value) {
        // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.
        this.seriesCache.set(cacheKey, {});
        const params = {
          'match[]': interpolatedMatch,
          start,
          end
        };
        const data = await this.request(url, params);
        const {
          values
        } = (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_4__.processLabels)(data);
        value = values;
        this.seriesCache.set(cacheKey, value);
      }

      return value;
    });

    _defineProperty(this, "fetchSeries", async match => {
      const url = 'series';
      const {
        start,
        end
      } = this.datasource.getTimeRangeParams();
      const params = {
        'match[]': match,
        start,
        end
      };
      return await this.request(url, params);
    });

    this.datasource = datasource;
    this.labelKeys = [];
    this.labelFetchTs = 0;
    Object.assign(this, initialValues);
  } // Strip syntax chars


  getSyntax() {
    return _syntax__WEBPACK_IMPORTED_MODULE_5__["default"];
  }

  getLabelKeys() {
    return this.labelKeys;
  }
  /**
   * Return suggestions based on input that can be then plugged into a typeahead dropdown.
   * Keep this DOM-free for testing
   * @param input
   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems
   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems
   * @param context.history Optional used only in getEmptyCompletionItems
   */


  async provideCompletionItems(input, context) {
    const {
      wrapperClasses,
      value,
      prefix,
      text
    } = input;
    const emptyResult = {
      suggestions: []
    };

    if (!value) {
      return emptyResult;
    } // Local text properties


    const empty = (value === null || value === void 0 ? void 0 : value.document.text.length) === 0;
    const selectedLines = value.document.getTextsAtRange(value.selection);
    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;
    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null; // Syntax spans have 3 classes by default. More indicate a recognized token

    const tokenRecognized = wrapperClasses.length > 3; // Non-empty prefix, but not inside known token

    const prefixUnrecognized = prefix && !tokenRecognized; // Prevent suggestions in `function(|suffix)`

    const noSuffix = !nextCharacter || nextCharacter === ')'; // Prefix is safe if it does not immediately follow a complete expression and has no text after it

    const safePrefix = prefix && !text.match(/^['"~=\]})\s]+$/) && noSuffix; // About to type next operand if preceded by binary operator

    const operatorsPattern = /[+\-*/^%]/;
    const isNextOperand = text.match(operatorsPattern); // Determine candidates by CSS context

    if (wrapperClasses.includes('context-range')) {
      // Suggestions for metric[|]
      return this.getRangeCompletionItems();
    } else if (wrapperClasses.includes('context-labels')) {
      // Suggestions for {|} and {foo=|}
      return await this.getLabelCompletionItems(input);
    } else if (wrapperClasses.includes('context-pipe')) {
      return this.getPipeCompletionItem();
    } else if (empty) {
      // Suggestions for empty query field
      return this.getEmptyCompletionItems(context);
    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {
      // Show term suggestions in a couple of scenarios
      return this.getBeginningCompletionItems(context);
    } else if (prefixUnrecognized && safePrefix) {
      // Show term suggestions in a couple of scenarios
      return this.getTermCompletionItems();
    }

    return emptyResult;
  }

  getEmptyCompletionItems(context) {
    const history = context === null || context === void 0 ? void 0 : context.history;
    const suggestions = [];

    if (history !== null && history !== void 0 && history.length) {
      const historyItems = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(history).map(h => h.query.expr).filter().uniq().take(HISTORY_ITEM_COUNT).map(wrapLabel).map(item => addHistoryMetadata(item, history)).value();
      suggestions.push({
        prefixMatch: true,
        skipSort: true,
        label: 'History',
        items: historyItems
      });
    }

    return {
      suggestions
    };
  }

  getRangeCompletionItems() {
    return {
      context: 'context-range',
      suggestions: [{
        label: 'Range vector',
        items: [...RATE_RANGES]
      }]
    };
  }

  async getLabelCompletionItems({
    text,
    wrapperClasses,
    labelKey,
    value
  }) {
    let context = 'context-labels';
    const suggestions = [];

    if (!value) {
      return {
        context,
        suggestions: []
      };
    }

    const line = value.anchorBlock.getText();
    const cursorOffset = value.selection.anchor.offset;
    const isValueStart = text.match(/^(=|=~|!=|!~)/); // Get normalized selector

    let selector;
    let parsedSelector;

    try {
      parsedSelector = (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_4__.parseSelector)(line, cursorOffset);
      selector = parsedSelector.selector;
    } catch {
      selector = EMPTY_SELECTOR;
    }

    if (!labelKey && selector === EMPTY_SELECTOR) {
      // start task gets all labels
      await this.start();
      const allLabels = this.getLabelKeys();
      return {
        context,
        suggestions: [{
          label: `Labels`,
          items: allLabels.map(wrapLabel)
        }]
      };
    }

    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];
    let labelValues; // Query labels for selector

    if (selector) {
      if (selector === EMPTY_SELECTOR && labelKey) {
        const labelValuesForKey = await this.getLabelValues(labelKey);
        labelValues = {
          [labelKey]: labelValuesForKey
        };
      } else {
        labelValues = await this.getSeriesLabels(selector);
      }
    }

    if (!labelValues) {
      console.warn(`Server did not return any values for selector = ${selector}`);
      return {
        context,
        suggestions
      };
    }

    if (text && isValueStart || wrapperClasses.includes('attr-value')) {
      // Label values
      if (labelKey && labelValues[labelKey]) {
        context = 'context-label-values';
        suggestions.push({
          label: `Label values for "${labelKey}"`,
          // Filter to prevent previously selected values from being repeatedly suggested
          items: labelValues[labelKey].map(wrapLabel).filter(({
            filterText
          }) => filterText !== text)
        });
      }
    } else {
      // Label keys
      const labelKeys = labelValues ? Object.keys(labelValues) : DEFAULT_KEYS;

      if (labelKeys) {
        const possibleKeys = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.difference)(labelKeys, existingKeys);

        if (possibleKeys.length) {
          const newItems = possibleKeys.map(key => ({
            label: key
          }));
          const newSuggestion = {
            label: `Labels`,
            items: newItems
          };
          suggestions.push(newSuggestion);
        }
      }
    }

    return {
      context,
      suggestions
    };
  }

  importFromAbstractQuery(labelBasedQuery) {
    return {
      refId: labelBasedQuery.refId,
      expr: (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_4__.toPromLikeExpr)(labelBasedQuery),
      queryType: _types__WEBPACK_IMPORTED_MODULE_6__.LokiQueryType.Range
    };
  }

  exportToAbstractQuery(query) {
    const lokiQuery = query.expr;

    if (!lokiQuery || lokiQuery.length === 0) {
      return {
        refId: query.refId,
        labelMatchers: []
      };
    }

    const tokens = prismjs__WEBPACK_IMPORTED_MODULE_2___default().tokenize(lokiQuery, _syntax__WEBPACK_IMPORTED_MODULE_5__["default"]);
    return {
      refId: query.refId,
      labelMatchers: (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_4__.extractLabelMatchers)(tokens)
    };
  }

  async getSeriesLabels(selector) {
    if (this.lookupsDisabled) {
      return undefined;
    }

    try {
      return await this.fetchSeriesLabels(selector);
    } catch (error) {
      // TODO: better error handling
      console.error(error);
      return undefined;
    }
  }
  /**
   * Fetches all label keys
   */


  async fetchLabels() {
    const url = 'labels';
    const timeRange = this.datasource.getTimeRangeParams();
    this.labelFetchTs = Date.now().valueOf();
    const res = await this.request(url, timeRange);

    if (Array.isArray(res)) {
      const labels = res.slice().sort().filter(label => label !== '__name__');
      this.labelKeys = labels;
    }

    return [];
  }

  async refreshLogLabels(forceRefresh) {
    if (this.labelKeys && Date.now().valueOf() - this.labelFetchTs > LABEL_REFRESH_INTERVAL || forceRefresh) {
      await this.fetchLabels();
    }
  }
  /**
   * Fetch labels for a selector. This is cached by it's args but also by the global timeRange currently selected as
   * they can change over requested time.
   * @param name
   */


  // Cache key is a bit different here. We round up to a minute the intervals.
  // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every
  // millisecond while still actually getting all the keys for the correct interval. This still can create problems
  // when user does not the newest values for a minute if already cached.
  generateCacheKey(url, start, end, param) {
    return [url, this.roundTime(start), this.roundTime(end), param].join();
  } // Round nanos epoch to nearest 5 minute interval


  roundTime(nanos) {
    return nanos ? Math.floor(nanos / NS_IN_MS / 1000 / 60 / 5) : 0;
  }

  async getLabelValues(key) {
    return await this.fetchLabelValues(key);
  }

  async fetchLabelValues(key) {
    var _labelValues;

    const interpolatedKey = encodeURIComponent(this.datasource.interpolateString(key));
    const url = `label/${interpolatedKey}/values`;
    const rangeParams = this.datasource.getTimeRangeParams();
    const {
      start,
      end
    } = rangeParams;
    const cacheKey = this.generateCacheKey(url, start, end, interpolatedKey);
    const params = {
      start,
      end
    };
    let labelValues = this.labelsCache.get(cacheKey);

    if (!labelValues) {
      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.
      this.labelsCache.set(cacheKey, []);
      const res = await this.request(url, params);

      if (Array.isArray(res)) {
        labelValues = res.slice().sort();
        this.labelsCache.set(cacheKey, labelValues);
      }
    }

    return (_labelValues = labelValues) !== null && _labelValues !== void 0 ? _labelValues : [];
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/language_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "escapeLabelValueInExactSelector": () => (/* binding */ escapeLabelValueInExactSelector),
/* harmony export */   "escapeLabelValueInRegexSelector": () => (/* binding */ escapeLabelValueInRegexSelector),
/* harmony export */   "escapeLabelValueInSelector": () => (/* binding */ escapeLabelValueInSelector),
/* harmony export */   "isRegexSelector": () => (/* binding */ isRegexSelector),
/* harmony export */   "shouldRefreshLabels": () => (/* binding */ shouldRefreshLabels)
/* harmony export */ });
function roundMsToMin(milliseconds) {
  return roundSecToMin(milliseconds / 1000);
}

function roundSecToMin(seconds) {
  return Math.floor(seconds / 60);
}

function shouldRefreshLabels(range, prevRange) {
  if (range && prevRange) {
    const sameMinuteFrom = roundMsToMin(range.from.valueOf()) === roundMsToMin(prevRange.from.valueOf());
    const sameMinuteTo = roundMsToMin(range.to.valueOf()) === roundMsToMin(prevRange.to.valueOf()); // If both are same, don't need to refresh

    return !(sameMinuteFrom && sameMinuteTo);
  }

  return false;
} // Loki regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),
// so every character that matches something in that list has to be escaped.
// the list of meta characters is: *+?()|\.[]{}^$
// we make a javascript regular expression that matches those characters:

const RE2_METACHARACTERS = /[*+?()|\\.\[\]{}^$]/g;

function escapeLokiRegexp(value) {
  return value.replace(RE2_METACHARACTERS, '\\$&');
} // based on the openmetrics-documentation, the 3 symbols we have to handle are:
// - \n ... the newline character
// - \  ... the backslash character
// - "  ... the double-quote character


function escapeLabelValueInExactSelector(labelValue) {
  return labelValue.replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/"/g, '\\"');
}
function escapeLabelValueInRegexSelector(labelValue) {
  return escapeLabelValueInExactSelector(escapeLokiRegexp(labelValue));
}
function escapeLabelValueInSelector(labelValue, selector) {
  return isRegexSelector(selector) ? escapeLabelValueInRegexSelector(labelValue) : escapeLabelValueInExactSelector(labelValue);
}
function isRegexSelector(selector) {
  if (selector && (selector.includes('=~') || selector.includes('!~'))) {
    return true;
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/live_streams.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LiveStreams": () => (/* binding */ LiveStreams)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/timer.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/throwError.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/retryWhen.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/finalize.js");
/* harmony import */ var rxjs_webSocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/webSocket.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _live_streams_result_transformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/live_streams_result_transformer.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







/**
 * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular
 * target it is returned and on subscription returns the latest dataFrame.
 */
class LiveStreams {
  constructor() {
    _defineProperty(this, "streams", {});
  }

  getStream(target, retryInterval = 5000) {
    let stream = this.streams[target.url];

    if (stream) {
      return stream;
    }

    const data = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.CircularDataFrame({
      capacity: target.size
    });
    data.addField({
      name: 'labels',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.other
    }); // The labels for each line

    data.addField({
      name: 'Time',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time,
      config: {}
    });
    data.addField({
      name: 'Line',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string
    }).labels = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.parseLabels)(target.query);
    data.addField({
      name: 'id',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string
    });
    data.addField({
      name: 'tsNs',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time,
      config: {}
    });
    data.meta = Object.assign({}, data.meta, {
      preferredVisualisationType: 'logs'
    });
    data.refId = target.refId;
    stream = (0,rxjs_webSocket__WEBPACK_IMPORTED_MODULE_2__.webSocket)(target.url).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(response => {
      (0,_live_streams_result_transformer__WEBPACK_IMPORTED_MODULE_1__.appendResponseToBufferedData)(response, data);
      return [data];
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.retryWhen)(attempts => attempts.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.mergeMap)((error, i) => {
      const retryAttempt = i + 1; // Code 1006 is used to indicate that a connection was closed abnormally.
      // Added hard limit of 30 on number of retries.
      // If connection was closed abnormally, and we wish to retry, otherwise throw error.

      if (error.code === 1006 && retryAttempt < 30) {
        if (retryAttempt > 10) {
          // If more than 10 times retried, consol.warn, but keep reconnecting
          console.warn(`Websocket connection is being disrupted. We keep reconnecting but consider starting new live tailing again. Error: ${error.reason}`);
        } // Retry every 5s


        return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.timer)(retryInterval);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_7__.throwError)(error);
    }))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.finalize)(() => {
      delete this.streams[target.url];
    }));
    this.streams[target.url] = stream;
    return stream;
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/live_streams_result_transformer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "appendResponseToBufferedData": () => (/* binding */ appendResponseToBufferedData)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");


const UUID_NAMESPACE = '6ec946da-0f49-47a8-983a-1d76d17e7c92';
/**
 * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be
 * a CircularDataFrame creating a fixed size rolling buffer.
 * TODO: Probably could be unified with the logStreamToDataFrame function.
 * @param response
 * @param data Needs to have ts, line, labels, id as fields
 */

function appendResponseToBufferedData(response, data) {
  // Should we do anything with: response.dropped_entries?
  const streams = response.streams;

  if (!streams || !streams.length) {
    return;
  }

  let baseLabels = {};

  for (const f of data.fields) {
    if (f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string) {
      if (f.labels) {
        baseLabels = f.labels;
      }

      break;
    }
  }

  const labelsField = data.fields[0];
  const tsField = data.fields[1];
  const lineField = data.fields[2];
  const idField = data.fields[3];
  const tsNsField = data.fields[4]; // We are comparing used ids only within the received stream. This could be a problem if the same line + labels + nanosecond timestamp came in 2 separate batches.
  // As this is very unlikely, and the result would only affect live-tailing css animation we have decided to not compare all received uids from data param as this would slow down processing.

  const usedUids = {};

  for (const stream of streams) {
    // Find unique labels
    const unique = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.findUniqueLabels)(stream.stream, baseLabels);
    const allLabelsString = Object.entries(stream.stream).map(([key, val]) => `${key}="${val}"`).sort().join(''); // Add each line

    for (const [ts, line] of stream.values) {
      tsField.values.add(new Date(parseInt(ts.slice(0, -6), 10)).toISOString());
      tsNsField.values.add(ts);
      lineField.values.add(line);
      labelsField.values.add(unique);
      idField.values.add(createUid(ts, allLabelsString, line, usedUids, data.refId));
    }
  }
}

function createUid(ts, labelsString, line, usedUids, refId) {
  // Generate id as hashed nanosecond timestamp, labels and line (this does not have to be unique)
  let id = (0,uuid__WEBPACK_IMPORTED_MODULE_1__["default"])(`${ts}_${labelsString}_${line}`, UUID_NAMESPACE); // Check if generated id is unique
  // If not and we've already used it, append it's count after it

  if (id in usedUids) {
    // Increase the count
    const newCount = usedUids[id] + 1;
    usedUids[id] = newCount; // Append count to generated id to make it unique

    id = `${id}_${newCount}`;
  } else {
    // If id is unique and wasn't used, add it to usedUids and start count at 0
    usedUids[id] = 0;
  } // Return unique id


  if (refId) {
    return `${id}_${refId}`;
  }

  return id;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/makeTableFrames.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeTableFrames": () => (/* binding */ makeTableFrames)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");


function makeTableFrames(instantMetricFrames) {
  // first we remove frames that have no refId
  // (we will group them by refId, so we need it to be set)
  const framesWithRefId = instantMetricFrames.filter(f => f.refId !== undefined);
  const framesByRefId = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.groupBy)(framesWithRefId, frame => frame.refId);
  return Object.entries(framesByRefId).map(([refId, frames]) => makeTableFrame(frames, refId));
}

function makeTableFrame(instantMetricFrames, refId) {
  const tableTimeField = {
    name: 'Time',
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector(),
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time
  };
  const tableValueField = {
    name: `Value #${refId}`,
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector(),
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.number
  }; // Sort metric labels, create columns for them and record their index

  const allLabelNames = new Set(instantMetricFrames.map(frame => frame.fields.map(field => {
    var _field$labels;

    return Object.keys((_field$labels = field.labels) !== null && _field$labels !== void 0 ? _field$labels : {});
  }).flat()).flat());
  const sortedLabelNames = Array.from(allLabelNames).sort();
  const labelFields = sortedLabelNames.map(labelName => ({
    name: labelName,
    config: {
      filterable: true
    },
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector(),
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string
  }));
  instantMetricFrames.forEach(frame => {
    var _valueField$labels;

    const timeField = frame.fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time);
    const valueField = frame.fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.number);

    if (timeField == null || valueField == null) {
      return;
    }

    const timeArray = timeField.values.toArray();
    const valueArray = valueField.values.toArray();

    for (let x of timeArray) {
      tableTimeField.values.add(x);
    }

    for (let x of valueArray) {
      tableValueField.values.add(x);
    }

    const labels = (_valueField$labels = valueField.labels) !== null && _valueField$labels !== void 0 ? _valueField$labels : {};

    for (let f of labelFields) {
      var _labels$f$name;

      const text = (_labels$f$name = labels[f.name]) !== null && _labels$f$name !== void 0 ? _labels$f$name : ''; // we insert the labels as many times as we have values

      for (let i = 0; i < valueArray.length; i++) {
        f.values.add(text);
      }
    }
  });
  return {
    fields: [tableTimeField, ...labelFields, tableValueField],
    refId,
    meta: {
      preferredVisualisationType: 'table'
    },
    length: tableTimeField.values.length
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/module.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "plugin": () => (/* binding */ plugin)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _components_LokiCheatSheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx");
/* harmony import */ var _components_LokiQueryEditorByApp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditorByApp.tsx");
/* harmony import */ var _configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/ConfigEditor.tsx");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/datasource.ts");





const plugin = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataSourcePlugin(_datasource__WEBPACK_IMPORTED_MODULE_4__.LokiDatasource).setQueryEditor(_components_LokiQueryEditorByApp__WEBPACK_IMPORTED_MODULE_2__["default"]).setConfigEditor(_configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_3__.ConfigEditor).setQueryEditorHelp(_components_LokiCheatSheet__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./public/app/plugins/datasource/loki/query_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "formatQuery": () => (/* binding */ formatQuery),
/* harmony export */   "getHighlighterExpressionsFromQuery": () => (/* binding */ getHighlighterExpressionsFromQuery),
/* harmony export */   "getNormalizedLokiQuery": () => (/* binding */ getNormalizedLokiQuery)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
const _excluded = ["instant", "range"],
      _excluded2 = ["instant", "range"],
      _excluded3 = ["instant", "range"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function formatQuery(selector) {
  return `${selector || ''}`.trim();
}
/**
 * Returns search terms from a LogQL query.
 * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.
 */

function getHighlighterExpressionsFromQuery(input) {
  let expression = input;
  const results = []; // Consume filter expression from left to right

  while (expression) {
    const filterStart = expression.search(/\|=|\|~|!=|!~/); // Nothing more to search

    if (filterStart === -1) {
      break;
    } // Drop terms for negative filters


    const filterOperator = expression.slice(filterStart, filterStart + 2);
    const skip = expression.slice(filterStart).search(/!=|!~/) === 0;
    expression = expression.slice(filterStart + 2);

    if (skip) {
      continue;
    } // Check if there is more chained


    const filterEnd = expression.search(/\|=|\|~|!=|!~/);
    let filterTerm;

    if (filterEnd === -1) {
      filterTerm = expression.trim();
    } else {
      filterTerm = expression.slice(0, filterEnd).trim();
      expression = expression.slice(filterEnd);
    }

    const quotedTerm = filterTerm.match(/"(.*?)"/);
    const backtickedTerm = filterTerm.match(/`(.*?)`/);
    const term = quotedTerm || backtickedTerm;

    if (term) {
      const unwrappedFilterTerm = term[1];
      const regexOperator = filterOperator === '|~'; // Only filter expressions with |~ operator are treated as regular expressions

      if (regexOperator) {
        // When using backticks, Loki doesn't require to escape special characters and we can just push regular expression to highlights array
        // When using quotes, we have extra backslash escaping and we need to replace \\ with \
        results.push(backtickedTerm ? unwrappedFilterTerm : unwrappedFilterTerm.replace(/\\\\/g, '\\'));
      } else {
        // We need to escape this string so it is not matched as regular expression
        results.push((0,lodash__WEBPACK_IMPORTED_MODULE_0__.escapeRegExp)(unwrappedFilterTerm));
      }
    } else {
      return results;
    }
  }

  return results;
} // we are migrating from `.instant` and `.range` to `.queryType`
// this function returns a new query object that:
// - has `.queryType`
// - does not have `.instant`
// - does not have `.range`

function getNormalizedLokiQuery(query) {
  //  if queryType field contains invalid data we behave as if the queryType is empty
  const {
    queryType
  } = query;
  const hasValidQueryType = queryType === _types__WEBPACK_IMPORTED_MODULE_1__.LokiQueryType.Range || queryType === _types__WEBPACK_IMPORTED_MODULE_1__.LokiQueryType.Instant || queryType === _types__WEBPACK_IMPORTED_MODULE_1__.LokiQueryType.Stream; // if queryType exists, it is respected

  if (hasValidQueryType) {
    const rest = _objectWithoutPropertiesLoose(query, _excluded);

    return rest;
  } // if no queryType, and instant===true, it's instant


  if (query.instant === true) {
    const rest = _objectWithoutPropertiesLoose(query, _excluded2);

    return Object.assign({}, rest, {
      queryType: _types__WEBPACK_IMPORTED_MODULE_1__.LokiQueryType.Instant
    });
  } // otherwise it is range


  const rest = _objectWithoutPropertiesLoose(query, _excluded3);

  return Object.assign({}, rest, {
    queryType: _types__WEBPACK_IMPORTED_MODULE_1__.LokiQueryType.Range
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryModeller": () => (/* binding */ LokiQueryModeller),
/* harmony export */   "lokiQueryModeller": () => (/* binding */ lokiQueryModeller)
/* harmony export */ });
/* harmony import */ var _prometheus_querybuilder_shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts");
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/operations.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");



class LokiQueryModeller extends _prometheus_querybuilder_shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_0__.LokiAndPromQueryModellerBase {
  constructor() {
    super(_operations__WEBPACK_IMPORTED_MODULE_1__.getOperationDefinitions);
    this.setOperationCategories([_types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.Aggregations, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.RangeFunctions, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.Formats, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.BinaryOps, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.LabelFilters, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.LineFilters]);
  }

  renderLabels(labels) {
    if (labels.length === 0) {
      return '{}';
    }

    return super.renderLabels(labels);
  }

  getQueryPatterns() {
    return [{
      name: 'Log query with parsing',
      // {} | logfmt | __error__=``
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }]
    }, {
      name: 'Log query with filtering and parsing',
      // {} |= `` | logfmt | __error__=``
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineContains,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }]
    }, {
      name: 'Log query with parsing and label filter',
      // {} |= `` | logfmt | __error__=`` | label=`value`
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineContains,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilter,
        params: ['label', '=', 'value']
      }]
    }, {
      name: 'Log query with parsing of nested json',
      // {} |= `` | json | line_format `{{ .message}}` | json
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineContains,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Json,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineFormat,
        params: ['{{.message}}']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Json,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }]
    }, {
      name: 'Log query with reformatted log line',
      // {} |= `` | logfmt | line_format `{{.message}}`
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineContains,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineFormat,
        params: ['{{.message}}']
      }]
    }, {
      name: 'Log query with mapped log level',
      // {} |= `` | logfmt | label_format level=lvl
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineContains,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFormat,
        params: ['lvl', 'level']
      }]
    }, {
      name: 'Metrics query on value inside log line',
      // sum(sum_over_time({ | logfmt | __error__=`` | unwrap | __error__=`` [$__interval]))
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineContains,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Unwrap,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.SumOverTime,
        params: ['$__interval']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Sum,
        params: []
      }]
    }, {
      name: 'Metrics query for total requests per label of streams',
      // sum by() (count_over_time({}[$__interval)
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineContains,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.CountOverTime,
        params: ['$__interval']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Sum,
        params: []
      }]
    }, {
      name: 'Metrics query for total requests per parsed label or label of streams',
      // sum by() (count_over_time({}| logfmt | __error__=`` [$__interval))
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineContains,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.CountOverTime,
        params: ['$__interval']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Sum,
        params: []
      }]
    }, {
      name: 'Metrics query for bytes used by log stream',
      // bytes_over_time({}[$__interval])
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineContains,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.BytesOverTime,
        params: ['$__interval']
      }]
    }, {
      name: 'Metrics query for count of log lines per stream',
      // count_over_time({}[$__interval])
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineContains,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.CountOverTime,
        params: ['$__interval']
      }]
    }, {
      name: 'Metrics query for top n results by label or parsed label',
      // topk(10, sum by () (count_over_time({} | logfmt | __error__=`` [$__interval])))
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.CountOverTime,
        params: ['$__interval']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Sum,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.TopK,
        params: [10]
      }]
    }, {
      name: 'Metrics query for extracted quantile',
      // quantile_over_time(0.5,{} | logfmt | unwrap latency[$__interval]) by ()
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Unwrap,
        params: ['latency']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.QuantileOverTime,
        params: [0.5, '$__interval']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Sum,
        params: []
      }]
    }];
  }

}
const lokiQueryModeller = new LokiQueryModeller();

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "binaryScalarDefs": () => (/* binding */ binaryScalarDefs),
/* harmony export */   "binaryScalarOperations": () => (/* binding */ binaryScalarOperations)
/* harmony export */ });
/* harmony import */ var _prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");


const binaryScalarDefs = [{
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Addition,
  name: 'Add scalar',
  sign: '+'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Subtraction,
  name: 'Subtract scalar',
  sign: '-'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.MultiplyBy,
  name: 'Multiply by scalar',
  sign: '*'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.DivideBy,
  name: 'Divide by scalar',
  sign: '/'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Modulo,
  name: 'Modulo by scalar',
  sign: '%'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Exponent,
  name: 'Exponent',
  sign: '^'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.EqualTo,
  name: 'Equal to',
  sign: '==',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.NotEqualTo,
  name: 'Not equal to',
  sign: '!=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.GreaterThan,
  name: 'Greater than',
  sign: '>',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.LessThan,
  name: 'Less than',
  sign: '<',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.GreaterOrEqual,
  name: 'Greater or equal to',
  sign: '>=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.LessOrEqual,
  name: 'Less or equal to',
  sign: '<=',
  comparison: true
}]; // Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies
// both the operator and the operand in a single input

const binaryScalarOperations = binaryScalarDefs.map(opDef => {
  const params = [{
    name: 'Value',
    type: 'number'
  }];
  const defaultParams = [2];

  if (opDef.comparison) {
    params.unshift({
      name: 'Bool',
      type: 'boolean',
      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.'
    });
    defaultParams.unshift(false);
  }

  return {
    id: opDef.id,
    name: opDef.name,
    params,
    defaultParams,
    alternativesKey: 'binary scalar operations',
    category: _types__WEBPACK_IMPORTED_MODULE_1__.LokiVisualQueryOperationCategory.BinaryOps,
    renderer: getSimpleBinaryRenderer(opDef.sign),
    addOperationHandler: _prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.defaultAddOperationHandler
  };
});

function getSimpleBinaryRenderer(operator) {
  return function binaryRenderer(model, def, innerExpr) {
    let param = model.params[0];
    let bool = '';

    if (model.params.length === 2) {
      param = model.params[1];
      bool = model.params[0] ? ' bool' : '';
    }

    return `${innerExpr} ${operator}${bool} ${param}`;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilder.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryBuilder": () => (/* binding */ LokiQueryBuilder)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_LabelFilters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/language_utils.ts");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");
/* harmony import */ var _NestedQueryList__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/NestedQueryList.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");












const LokiQueryBuilder = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  datasource,
  query,
  nested,
  onChange,
  onRunQuery
}) => {
  const onChangeLabels = labels => {
    onChange(Object.assign({}, query, {
      labels
    }));
  };

  const withTemplateVariableOptions = async optionsPromise => {
    const options = await optionsPromise;
    return [...datasource.getVariables(), ...options].map(value => ({
      label: value,
      value
    }));
  };

  const onGetLabelNames = async forLabel => {
    const labelsToConsider = query.labels.filter(x => x !== forLabel);

    if (labelsToConsider.length === 0) {
      await datasource.languageProvider.refreshLogLabels();
      return datasource.languageProvider.getLabelKeys();
    }

    const expr = _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__.lokiQueryModeller.renderLabels(labelsToConsider);
    const series = await datasource.languageProvider.fetchSeriesLabels(expr);
    return Object.keys(series).sort();
  };

  const onGetLabelValues = async forLabel => {
    if (!forLabel.label) {
      return [];
    }

    let values;
    const labelsToConsider = query.labels.filter(x => x !== forLabel);

    if (labelsToConsider.length === 0) {
      values = await datasource.languageProvider.fetchLabelValues(forLabel.label);
    } else {
      const expr = _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__.lokiQueryModeller.renderLabels(labelsToConsider);
      const result = await datasource.languageProvider.fetchSeriesLabels(expr);
      values = result[datasource.interpolateString(forLabel.label)];
    }

    return values ? values.map(v => (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.escapeLabelValueInSelector)(v, forLabel.op)) : []; // Escape values in return
  };

  const labelFilterError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    const {
      labels,
      operations: op
    } = query;

    if (!labels.length && op.length) {
      // We don't want to show error for initial state with empty line contains operation
      if (op.length === 1 && op[0].id === _types__WEBPACK_IMPORTED_MODULE_7__.LokiOperationId.LineContains && op[0].params[0] === '') {
        return undefined;
      }

      return 'You need to specify at least 1 label filter (stream selector)';
    }

    return undefined;
  }, [query]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_LabelFilters__WEBPACK_IMPORTED_MODULE_2__.LabelFilters, {
        onGetLabelNames: forLabel => withTemplateVariableOptions(onGetLabelNames(forLabel)),
        onGetLabelValues: forLabel => withTemplateVariableOptions(onGetLabelValues(forLabel)),
        labelsFilters: query.labels,
        onChange: onChangeLabels,
        error: labelFilterError
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_4__.OperationsEditorRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationList__WEBPACK_IMPORTED_MODULE_3__.OperationList, {
        queryModeller: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__.lokiQueryModeller,
        query: query,
        onChange: onChange,
        onRunQuery: onRunQuery,
        datasource: datasource
      })
    }), query.binaryQueries && query.binaryQueries.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_NestedQueryList__WEBPACK_IMPORTED_MODULE_8__.NestedQueryList, {
      query: query,
      datasource: datasource,
      onChange: onChange,
      onRunQuery: onRunQuery
    })]
  });
});
LokiQueryBuilder.displayName = 'LokiQueryBuilder';

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderContainer.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryBuilderContainer": () => (/* binding */ LokiQueryBuilderContainer)
/* harmony export */ });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/@reduxjs-toolkit-virtual-6cd1e25811/0/cache/@reduxjs-toolkit-npm-1.8.1-cf386ae48d-be5cdea975.zip/node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/parsing.ts");
/* harmony import */ var _LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilder.tsx");
/* harmony import */ var _QueryPreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/QueryPreview.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










/**
 * This component is here just to contain the translation logic between string query and the visual query builder model.
 */
function LokiQueryBuilderContainer(props) {
  const {
    query,
    onChange,
    onRunQuery,
    datasource,
    showRawQuery
  } = props;
  const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(stateSlice.reducer, {
    expr: query.expr,
    // Use initial visual query only if query.expr is empty string
    visQuery: query.expr === '' ? {
      labels: [],
      operations: [{
        id: '__line_contains',
        params: ['']
      }]
    } : undefined
  }); // Only rebuild visual query if expr changes from outside

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    dispatch(exprChanged(query.expr));
  }, [query.expr]);

  const onVisQueryChange = visQuery => {
    const expr = _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_1__.lokiQueryModeller.renderQuery(visQuery);
    dispatch(visualQueryChange({
      visQuery,
      expr
    }));
    onChange(Object.assign({}, props.query, {
      expr: expr
    }));
  };

  if (!state.visQuery) {
    return null;
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_3__.LokiQueryBuilder, {
      query: state.visQuery,
      datasource: datasource,
      onChange: onVisQueryChange,
      onRunQuery: onRunQuery
    }), showRawQuery && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_QueryPreview__WEBPACK_IMPORTED_MODULE_4__.QueryPreview, {
      query: query.expr
    })]
  });
}
const stateSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__.createSlice)({
  name: 'loki-builder-container',
  initialState: {
    expr: ''
  },
  reducers: {
    visualQueryChange: (state, action) => {
      state.expr = action.payload.expr;
      state.visQuery = action.payload.visQuery;
    },
    exprChanged: (state, action) => {
      if (!state.visQuery || state.expr !== action.payload) {
        state.expr = action.payload;
        const parseResult = (0,_parsing__WEBPACK_IMPORTED_MODULE_2__.buildVisualQueryFromString)(action.payload);
        state.visQuery = parseResult.query;
      }
    }
  }
});
const {
  visualQueryChange,
  exprChanged
} = stateSlice.actions;

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderExplained.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryBuilderExplained": () => (/* binding */ LokiQueryBuilderExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_RawQuery__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/RawQuery.tsx");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/parsing.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










const LokiQueryBuilderExplained = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  query
}) => {
  const visQuery = (0,_parsing__WEBPACK_IMPORTED_MODULE_7__.buildVisualQueryFromString)(query || '').query;
  const lang = {
    grammar: _syntax__WEBPACK_IMPORTED_MODULE_5__.lokiGrammar,
    name: 'lokiql'
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    gap: 0,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_2__.OperationExplainedBox, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_RawQuery__WEBPACK_IMPORTED_MODULE_4__.RawQuery, {
        query: query,
        lang: lang
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_2__.OperationExplainedBox, {
      stepNumber: 1,
      title: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_RawQuery__WEBPACK_IMPORTED_MODULE_4__.RawQuery, {
        query: `${_LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__.lokiQueryModeller.renderLabels(visQuery.labels)}`,
        lang: lang
      }),
      children: "Fetch all log lines matching label filters."
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_3__.OperationListExplained, {
      stepNumber: 2,
      queryModeller: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__.lokiQueryModeller,
      query: visQuery,
      lang: lang
    })]
  });
});
LokiQueryBuilderExplained.displayName = 'LokiQueryBuilderExplained';

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderOptions.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryBuilderOptions": () => (/* binding */ LokiQueryBuilderOptions)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx");
/* harmony import */ var _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/datasource.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










const LokiQueryBuilderOptions = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  app,
  query,
  onChange,
  onRunQuery
}) => {
  var _query$queryType, _query$maxLines$toStr, _query$maxLines;

  const onQueryTypeChange = value => {
    onChange(Object.assign({}, query, {
      queryType: value
    }));
    onRunQuery();
  };

  const onResolutionChange = option => {
    (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.reportInteraction)('grafana_loki_resolution_clicked', {
      app,
      resolution: option.value
    });
    onChange(Object.assign({}, query, {
      resolution: option.value
    }));
    onRunQuery();
  };

  const onLegendFormatChanged = evt => {
    onChange(Object.assign({}, query, {
      legendFormat: evt.currentTarget.value
    }));
    onRunQuery();
  };

  function onMaxLinesChange(e) {
    const newMaxLines = (0,_components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.preprocessMaxLines)(e.currentTarget.value);

    if (query.maxLines !== newMaxLines) {
      onChange(Object.assign({}, query, {
        maxLines: newMaxLines
      }));
      onRunQuery();
    }
  }

  let queryType = (_query$queryType = query.queryType) !== null && _query$queryType !== void 0 ? _query$queryType : query.instant ? _types__WEBPACK_IMPORTED_MODULE_7__.LokiQueryType.Instant : _types__WEBPACK_IMPORTED_MODULE_7__.LokiQueryType.Range;
  let showMaxLines = !(0,_datasource__WEBPACK_IMPORTED_MODULE_6__.isMetricsQuery)(query.expr);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)(app_plugins_datasource_prometheus_querybuilder_shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_4__.QueryOptionGroup, {
      title: "Options",
      collapsedInfo: getCollapsedInfo(query, queryType, showMaxLines),
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Legend",
        tooltip: "Series name override or template. Ex. {{hostname}} will be replaced with label value for hostname.",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.AutoSizeInput, {
          placeholder: "{{label}}",
          id: "loki-query-editor-legend-format",
          type: "string",
          minWidth: 14,
          defaultValue: query.legendFormat,
          onCommitChange: onLegendFormatChanged
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Type",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.RadioButtonGroup, {
          options: _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.queryTypeOptions,
          value: queryType,
          onChange: onQueryTypeChange
        })
      }), showMaxLines && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Line limit",
        tooltip: "Upper limit for number of log lines returned by query.",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.AutoSizeInput, {
          className: "width-4",
          placeholder: "auto",
          type: "number",
          min: 0,
          defaultValue: (_query$maxLines$toStr = (_query$maxLines = query.maxLines) === null || _query$maxLines === void 0 ? void 0 : _query$maxLines.toString()) !== null && _query$maxLines$toStr !== void 0 ? _query$maxLines$toStr : '',
          onCommitChange: onMaxLinesChange
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Resolution",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
          isSearchable: false,
          onChange: onResolutionChange,
          options: _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.RESOLUTION_OPTIONS,
          value: query.resolution || 1,
          "aria-label": "Select resolution"
        })
      })]
    })
  });
});

function getCollapsedInfo(query, queryType, showMaxLines) {
  const queryTypeLabel = _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.queryTypeOptions.find(x => x.value === queryType);
  const resolutionLabel = _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.RESOLUTION_OPTIONS.find(x => {
    var _query$resolution;

    return x.value === ((_query$resolution = query.resolution) !== null && _query$resolution !== void 0 ? _query$resolution : 1);
  });
  const items = [];

  if (query.legendFormat) {
    items.push(`Legend: ${query.legendFormat}`);
  }

  if (query.resolution) {
    items.push(`Resolution: ${resolutionLabel === null || resolutionLabel === void 0 ? void 0 : resolutionLabel.label}`);
  }

  items.push(`Type: ${queryTypeLabel === null || queryTypeLabel === void 0 ? void 0 : queryTypeLabel.label}`);

  if (showMaxLines && query.maxLines) {
    items.push(`Line limit: ${query.maxLines}`);
  }

  return items;
}

LokiQueryBuilderOptions.displayName = 'LokiQueryBuilderOptions';

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryCodeEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryCodeEditor": () => (/* binding */ LokiQueryCodeEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _components_LokiQueryEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx");
/* harmony import */ var _components_LokiQueryField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function LokiQueryCodeEditor({
  query,
  datasource,
  range,
  onRunQuery,
  onChange,
  data,
  app
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles); // the inner QueryField works like this when a blur event happens:
  // - if it has an onBlur prop, it calls it
  // - else it calls onRunQuery (some extra conditions apply)
  //
  // we want it to not do anything when a blur event happens in explore mode,
  // so we set an empty-function in such case. otherwise we set `undefined`,
  // which will cause it to run the query when blur happens.

  const onBlur = app === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Explore ? () => undefined : undefined;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
    className: styles.wrapper,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_components_LokiQueryField__WEBPACK_IMPORTED_MODULE_5__.LokiQueryField, {
      datasource: datasource,
      query: query,
      range: range,
      onRunQuery: onRunQuery,
      onChange: onChange,
      onBlur: onBlur,
      history: [],
      data: data,
      "data-testid": _components_LokiQueryEditor__WEBPACK_IMPORTED_MODULE_4__.testIds.editor,
      app: app
    })
  });
}

const getStyles = theme => {
  return {
    // This wrapper styling can be removed after the old PromQueryEditor is removed.
    // This is removing margin bottom on the old legacy inline form styles
    wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      .gf-form {
        margin-bottom: 0;
      }
    `
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryEditorSelector.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditorSelector": () => (/* binding */ LokiQueryEditorSelector)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_FeedbackLink__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/FeedbackLink.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_QueryHeaderSwitch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryHeaderSwitch.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/parsing.ts");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/state.ts");
/* harmony import */ var _LokiQueryBuilderContainer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderContainer.tsx");
/* harmony import */ var _LokiQueryBuilderExplained__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderExplained.tsx");
/* harmony import */ var _LokiQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderOptions.tsx");
/* harmony import */ var _LokiQueryCodeEditor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryCodeEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FeedbackLink, _FlexItem, _Space;




















const LokiQueryEditorSelector = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(props => {
  const {
    onChange,
    onRunQuery,
    data,
    app
  } = props;
  const [parseModalOpen, setParseModalOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [dataIsStale, setDataIsStale] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const query = (0,_state__WEBPACK_IMPORTED_MODULE_11__.getQueryWithDefaults)(props.query);
  const [rawQuery, setRawQuery] = (0,_state__WEBPACK_IMPORTED_MODULE_11__.useRawQuery)(); // This should be filled in from the defaults by now.

  const editorMode = query.editorMode;
  const onEditorModeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(newEditorMode => {
    var _query$editorMode;

    (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.reportInteraction)('grafana_loki_editor_mode_clicked', {
      newEditor: newEditorMode,
      previousEditor: (_query$editorMode = query.editorMode) !== null && _query$editorMode !== void 0 ? _query$editorMode : '',
      newQuery: !query.expr,
      app: app !== null && app !== void 0 ? app : ''
    });

    if (newEditorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_8__.QueryEditorMode.Builder) {
      const result = (0,_parsing__WEBPACK_IMPORTED_MODULE_10__.buildVisualQueryFromString)(query.expr || ''); // If there are errors, give user a chance to decide if they want to go to builder as that can loose some data.

      if (result.errors.length) {
        setParseModalOpen(true);
        return;
      }
    }

    (0,_state__WEBPACK_IMPORTED_MODULE_11__.changeEditorMode)(query, newEditorMode, onChange);
  }, [onChange, query, app]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    setDataIsStale(false);
  }, [data]);

  const onChangeInternal = query => {
    setDataIsStale(true);
    onChange(query);
  };

  const onQueryPreviewChange = event => {
    const isEnabled = event.currentTarget.checked;
    setRawQuery(isEnabled);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.ConfirmModal, {
      isOpen: parseModalOpen,
      title: "Query parsing",
      body: "There were errors while trying to parse the query. Continuing to visual builder may loose some parts of the query.",
      confirmText: "Continue",
      onConfirm: () => {
        onChange(Object.assign({}, query, {
          editorMode: app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_8__.QueryEditorMode.Builder
        }));
        setParseModalOpen(false);
      },
      onDismiss: () => setParseModalOpen(false)
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorHeader, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.InlineSelect, {
        value: null,
        placeholder: "Query patterns",
        allowCustomValue: true,
        onChange: ({
          value
        }) => {
          const result = (0,_parsing__WEBPACK_IMPORTED_MODULE_10__.buildVisualQueryFromString)(query.expr || '');
          result.query.operations = value === null || value === void 0 ? void 0 : value.operations;
          onChange(Object.assign({}, query, {
            expr: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_9__.lokiQueryModeller.renderQuery(result.query)
          }));
        },
        options: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_9__.lokiQueryModeller.getQueryPatterns().map(x => ({
          label: x.name,
          value: x
        }))
      }), editorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_8__.QueryEditorMode.Builder && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_QueryHeaderSwitch__WEBPACK_IMPORTED_MODULE_7__.QueryHeaderSwitch, {
          label: "Raw query",
          value: rawQuery,
          onChange: onQueryPreviewChange
        }), _FeedbackLink || (_FeedbackLink = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_FeedbackLink__WEBPACK_IMPORTED_MODULE_5__.FeedbackLink, {
          feedbackUrl: "https://github.com/grafana/grafana/discussions/50785"
        }))]
      }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), app !== _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
        variant: dataIsStale ? 'primary' : 'secondary',
        size: "sm",
        onClick: onRunQuery,
        icon: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading ? 'fa fa-spinner' : undefined,
        disabled: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading,
        children: "Run queries"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_6__.QueryEditorModeToggle, {
        mode: editorMode,
        onChange: onEditorModeChange
      })]
    }), _Space || (_Space = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Space, {
      v: 0.5
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorRows, {
      children: [editorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_8__.QueryEditorMode.Code && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_LokiQueryCodeEditor__WEBPACK_IMPORTED_MODULE_15__.LokiQueryCodeEditor, Object.assign({}, props, {
        onChange: onChangeInternal
      })), editorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_8__.QueryEditorMode.Builder && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_LokiQueryBuilderContainer__WEBPACK_IMPORTED_MODULE_12__.LokiQueryBuilderContainer, {
        datasource: props.datasource,
        query: query,
        onChange: onChangeInternal,
        onRunQuery: props.onRunQuery,
        showRawQuery: rawQuery
      }), editorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_8__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_LokiQueryBuilderExplained__WEBPACK_IMPORTED_MODULE_13__.LokiQueryBuilderExplained, {
        query: query.expr
      }), editorMode !== app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_8__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_LokiQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_14__.LokiQueryBuilderOptions, {
        query: query,
        onChange: onChange,
        onRunQuery: onRunQuery,
        app: app
      })]
    })]
  });
});
LokiQueryEditorSelector.displayName = 'LokiQueryEditorSelector';

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/NestedQuery.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQuery": () => (/* binding */ NestedQuery)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilder.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;










const NestedQuery = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  nestedQuery,
  index,
  datasource,
  onChange,
  onRemove,
  onRunQuery
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
    className: styles.card,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
      className: styles.header,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.name,
        children: "Operator"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
        width: "auto",
        options: operators,
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)(nestedQuery.operator),
        onChange: value => {
          onChange(index, Object.assign({}, nestedQuery, {
            operator: value.value
          }));
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.name,
        children: "Vector matches"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.vectorMatchWrapper,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
          width: "auto",
          value: nestedQuery.vectorMatchesType || 'on',
          allowCustomValue: true,
          options: [{
            value: 'on',
            label: 'on'
          }, {
            value: 'ignoring',
            label: 'ignoring'
          }],
          onChange: val => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatchesType: val.value
            }));
          }
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.AutoSizeInput, {
          className: styles.vectorMatchInput,
          minWidth: 20,
          defaultValue: nestedQuery.vectorMatches,
          onCommitChange: evt => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatches: evt.currentTarget.value,
              vectorMatchesType: nestedQuery.vectorMatchesType || 'on'
            }));
          }
        })]
      }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.IconButton, {
        name: "times",
        size: "sm",
        onClick: () => onRemove(index)
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
      className: styles.body,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorRows, {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_6__.LokiQueryBuilder, {
          query: nestedQuery.query,
          datasource: datasource,
          nested: true,
          onRunQuery: onRunQuery,
          onChange: update => {
            onChange(index, Object.assign({}, nestedQuery, {
              query: update
            }));
          }
        })
      })
    })]
  });
});
const operators = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_5__.binaryScalarDefs.map(def => ({
  label: def.sign,
  value: def.sign
}));
NestedQuery.displayName = 'NestedQuery';

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'card',
      display: 'flex',
      flexDirection: 'column',
      gap: theme.spacing(0.5)
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'header',
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      gap: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    name: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'name',
      whiteSpace: 'nowrap'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'body',
      paddingLeft: theme.spacing(2)
    }),
    vectorMatchInput: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchInput',
      marginLeft: -1
    }),
    vectorMatchWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchWrapper',
      display: 'flex'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/NestedQueryList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQueryList": () => (/* binding */ NestedQueryList)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _NestedQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/NestedQuery.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




function NestedQueryList({
  query,
  datasource,
  onChange,
  onRunQuery
}) {
  var _query$binaryQueries;

  const nestedQueries = (_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : [];

  const onNestedQueryUpdate = (index, update) => {
    const updatedList = [...nestedQueries];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...nestedQueries.slice(0, index), ...nestedQueries.slice(index + 1)];
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    direction: "column",
    gap: 1,
    children: nestedQueries.map((nestedQuery, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_NestedQuery__WEBPACK_IMPORTED_MODULE_2__.NestedQuery, {
      nestedQuery: nestedQuery,
      index: index,
      onChange: onNestedQueryUpdate,
      datasource: datasource,
      onRemove: onRemove,
      onRunQuery: onRunQuery
    }, index.toString()))
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/QueryPreview.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryPreview": () => (/* binding */ QueryPreview)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _prometheus_querybuilder_shared_RawQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/RawQuery.tsx");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function QueryPreview({
  query
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorFieldGroup, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Raw query",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_prometheus_querybuilder_shared_RawQuery__WEBPACK_IMPORTED_MODULE_2__.RawQuery, {
          query: query,
          lang: {
            grammar: _syntax__WEBPACK_IMPORTED_MODULE_3__.lokiGrammar,
            name: 'lokiql'
          }
        })
      })
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/operations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLokiOperation": () => (/* binding */ addLokiOperation),
/* harmony export */   "getOperationDefinitions": () => (/* binding */ getOperationDefinitions)
/* harmony export */ });
/* harmony import */ var _prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");




function getOperationDefinitions() {
  const aggregations = [_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Sum, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Min, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Max, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Avg, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Stddev, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Stdvar, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Count].flatMap(opId => (0,_prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.createAggregationOperation)(opId, {
    addOperationHandler: addLokiOperation,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.Last
  }));
  const aggregationsWithParam = [_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.TopK, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.BottomK].flatMap(opId => {
    return (0,_prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.createAggregationOperationWithParam)(opId, {
      params: [{
        name: 'K-value',
        type: 'number'
      }],
      defaultParams: [5]
    }, {
      addOperationHandler: addLokiOperation,
      orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.Last
    });
  });
  const list = [createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Rate), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.CountOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.SumOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.BytesRate), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.BytesOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.AbsentOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.AvgOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.MaxOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.MinOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.FirstOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LastOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.StdvarOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.StddevOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.QuantileOverTime), ...aggregations, ...aggregationsWithParam, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Json,
    name: 'Json',
    params: [],
    defaultParams: [],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: pipelineRenderer,
    addOperationHandler: addLokiOperation
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Logfmt,
    name: 'Logfmt',
    params: [],
    defaultParams: [],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: pipelineRenderer,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will extract all keys and values from a [logfmt](https://grafana.com/docs/loki/latest/logql/log_queries/#logfmt) formatted log line as labels. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Regexp,
    name: 'Regexp',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: '<re>',
      description: 'The regexp expression that matches the structure of a log line.',
      minWidth: 20
    }],
    defaultParams: [''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | regexp \`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `The [regexp parser](https://grafana.com/docs/loki/latest/logql/log_queries/#regular-expression) takes a single parameter | regexp "<re>" which is the regular expression using the Golang RE2 syntax. The regular expression must contain a least one named sub-match (e.g (?P<name>re)), each sub-match will extract a different label. The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Pattern,
    name: 'Pattern',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: '<pattern-expression>',
      description: 'The expression that matches the structure of a log line.',
      minWidth: 20
    }],
    defaultParams: [''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | pattern \`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `The [pattern parser](https://grafana.com/docs/loki/latest/logql/log_queries/#pattern) allows the explicit extraction of fields from log lines by defining a pattern expression (| pattern \`<pattern-expression>\`). The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Unpack,
    name: 'Unpack',
    params: [],
    defaultParams: [],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: pipelineRenderer,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will extract all keys and values from a JSON log line, [unpacking](https://grafana.com/docs/loki/latest/logql/log_queries/#unpack) all embedded labels in the pack stage. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineFormat,
    name: 'Line format',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: '{{.status_code}}',
      description: 'A line template that can refer to stream labels and extracted labels.',
      minWidth: 20
    }],
    defaultParams: [''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | line_format \`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will replace log line using a specified template. The template can refer to stream labels and extracted labels.

        Example: \`{{.status_code}} - {{.message}}\`

        [Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#line-format-expression) for more.
        `
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LabelFormat,
    name: 'Label format',
    params: [{
      name: 'Label',
      type: 'string'
    }, {
      name: 'Rename',
      type: 'string'
    }],
    defaultParams: ['', ''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | label_format ${model.params[1]}=\`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will change name of label to desired new label. In the example below, label "error_level" will be renamed to "level".

        Example: error_level=\`level\`

        [Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#labels-format-expression) for more.
        `
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineContains,
    name: 'Line contains',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: 'Text to find',
      description: 'Find log lines that contains this text',
      minWidth: 20,
      runQueryOnEnter: true
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('|='),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that contain string \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineContainsNot,
    name: 'Line does not contain',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: 'Text to exclude',
      description: 'Find log lines that does not contain this text',
      minWidth: 26,
      runQueryOnEnter: true
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('!='),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that does not contain string \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineMatchesRegex,
    name: 'Line contains regex match',
    params: [{
      name: 'Regex',
      type: 'string',
      hideName: true,
      placeholder: 'Pattern to match',
      description: 'Find log lines that match this regex pattern',
      minWidth: 30,
      runQueryOnEnter: true
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('|~'),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that match regex \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineMatchesRegexNot,
    name: 'Line does not match regex',
    params: [{
      name: 'Regex',
      type: 'string',
      hideName: true,
      placeholder: 'Pattern to exclude',
      description: 'Find log lines that does not match this regex pattern',
      minWidth: 30,
      runQueryOnEnter: true
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('!~'),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that does not match regex \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LabelFilter,
    name: 'Label filter expression',
    params: [{
      name: 'Label',
      type: 'string'
    }, {
      name: 'Operator',
      type: 'string',
      options: ['=', '!=', '>', '<', '>=', '<=']
    }, {
      name: 'Value',
      type: 'string'
    }],
    defaultParams: ['', '=', ''],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LabelFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LabelFilters,
    renderer: labelFilterRenderer,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `Label expression filter allows filtering using original and extracted labels.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LabelFilterNoErrors,
    name: 'No pipeline errors',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LabelFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.NoErrors,
    renderer: (model, def, innerExpr) => `${innerExpr} | __error__=\`\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `Filter out all formatting and parsing errors.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Unwrap,
    name: 'Unwrap',
    params: [{
      name: 'Identifier',
      type: 'string',
      hideName: true,
      minWidth: 16,
      placeholder: 'Label key'
    }],
    defaultParams: [''],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.Unwrap,
    renderer: (op, def, innerExpr) => `${innerExpr} | unwrap ${op.params[0]}`,
    addOperationHandler: addLokiOperation,
    explainHandler: op => {
      let label = String(op.params[0]).length > 0 ? op.params[0] : '<label>';
      return `Use the extracted label \`${label}\` as sample values instead of log lines for the subsequent range aggregation.`;
    }
  }, ..._binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__.binaryScalarOperations, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.NestedQuery,
    name: 'Binary operation with query',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.BinaryOps,
    renderer: (model, def, innerExpr) => innerExpr,
    addOperationHandler: addNestedQueryHandler
  }];
  return list;
}

function createRangeOperation(name) {
  const params = [getRangeVectorParamDef()];
  const defaultParams = ['$__interval'];
  let renderer = operationWithRangeVectorRenderer;

  if (name === _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.QuantileOverTime) {
    defaultParams.push('0.95');
    params.push({
      name: 'Quantile',
      type: 'number'
    });
    renderer = operationWithRangeVectorRendererAndParam;
  }

  return {
    id: name,
    name: (0,_prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.getPromAndLokiOperationDisplayName)(name),
    params,
    defaultParams,
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.RangeFunctions,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.RangeVectorFunction,
    renderer,
    addOperationHandler: addLokiOperation,
    explainHandler: (op, def) => {
      var _FUNCTIONS$find$docum, _FUNCTIONS$find;

      let opDocs = (_FUNCTIONS$find$docum = (_FUNCTIONS$find = _syntax__WEBPACK_IMPORTED_MODULE_1__.FUNCTIONS.find(x => x.insertText === op.id)) === null || _FUNCTIONS$find === void 0 ? void 0 : _FUNCTIONS$find.documentation) !== null && _FUNCTIONS$find$docum !== void 0 ? _FUNCTIONS$find$docum : '';

      if (op.params[0] === '$__interval') {
        return `${opDocs} \`$__interval\` is variable that will be replaced with a calculated interval based on **Max data points**,  **Min interval** and query time range. You find these options you find under **Query options** at the right of the data source select dropdown.`;
      } else {
        return `${opDocs} The [range vector](https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation) is set to \`${op.params[0]}\`.`;
      }
    }
  };
}

function getRangeVectorParamDef() {
  return {
    name: 'Range',
    type: 'string',
    options: ['$__interval', '$__range', '1m', '5m', '10m', '1h', '24h']
  };
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '$__interval';
  return `${def.id}(${innerExpr} [${rangeVector}])`;
}

function operationWithRangeVectorRendererAndParam(model, def, innerExpr) {
  var _model$params2, _params$;

  const params = (_model$params2 = model.params) !== null && _model$params2 !== void 0 ? _model$params2 : [];
  const rangeVector = (_params$ = params[0]) !== null && _params$ !== void 0 ? _params$ : '$__interval';
  const param = params[1];
  return `${def.id}(${param}, ${innerExpr} [${rangeVector}])`;
}

function getLineFilterRenderer(operation) {
  return function lineFilterRenderer(model, def, innerExpr) {
    return `${innerExpr} ${operation} \`${model.params[0]}\``;
  };
}

function labelFilterRenderer(model, def, innerExpr) {
  if (model.params[0] === '') {
    return innerExpr;
  }

  if (model.params[1] === '<' || model.params[1] === '>') {
    return `${innerExpr} | ${model.params[0]} ${model.params[1]} ${model.params[2]}`;
  }

  return `${innerExpr} | ${model.params[0]}${model.params[1]}\`${model.params[2]}\``;
}

function pipelineRenderer(model, def, innerExpr) {
  return `${innerExpr} | ${model.id}`;
}

function isRangeVectorFunction(def) {
  return def.category === _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.RangeFunctions;
}

function getIndexOfOrLast(operations, queryModeller, condition) {
  const index = operations.findIndex(x => {
    const opDef = queryModeller.getOperationDef(x.id);

    if (!opDef) {
      return false;
    }

    return condition(opDef);
  });
  return index === -1 ? operations.length : index;
}

function addLokiOperation(def, query, modeller) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  const operations = [...query.operations];
  const existingRangeVectorFunction = operations.find(x => {
    const opDef = modeller.getOperationDef(x.id);

    if (!opDef) {
      return false;
    }

    return isRangeVectorFunction(opDef);
  });

  switch (def.category) {
    case _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Aggregations:
    case _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Functions:
      // If we are adding a function but we have not range vector function yet add one
      if (!existingRangeVectorFunction) {
        const placeToInsert = getIndexOfOrLast(operations, modeller, def => def.category === _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Functions);
        operations.splice(placeToInsert, 0, {
          id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Rate,
          params: ['$__interval']
        });
      }

      operations.push(newOperation);
      break;

    case _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.RangeFunctions:
      // If adding a range function and range function is already added replace it
      if (existingRangeVectorFunction) {
        const index = operations.indexOf(existingRangeVectorFunction);
        operations[index] = newOperation;
        break;
      }

    // Add range functions after any formats, line filters and label filters

    default:
      const placeToInsert = getIndexOfOrLast(operations, modeller, x => {
        var _def$orderRank, _x$orderRank;

        return ((_def$orderRank = def.orderRank) !== null && _def$orderRank !== void 0 ? _def$orderRank : 100) < ((_x$orderRank = x.orderRank) !== null && _x$orderRank !== void 0 ? _x$orderRank : 100);
      });
      operations.splice(placeToInsert, 0, newOperation);
      break;
  }

  return Object.assign({}, query, {
    operations
  });
}

function addNestedQueryHandler(def, query) {
  var _query$binaryQueries;

  return Object.assign({}, query, {
    binaryQueries: [...((_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : []), {
      operator: '/',
      query
    }]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/parsing.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildVisualQueryFromString": () => (/* binding */ buildVisualQueryFromString),
/* harmony export */   "handleExpression": () => (/* binding */ handleExpression)
/* harmony export */ });
/* harmony import */ var _grafana_lezer_logql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@grafana-lezer-logql-virtual-3a1b0e2de7/0/cache/@grafana-lezer-logql-npm-0.0.12-b44b271763-d28780b41a.zip/node_modules/@grafana/lezer-logql/index.es.js");
/* harmony import */ var _prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts");



function buildVisualQueryFromString(expr) {
  const replacedExpr = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.replaceVariables)(expr);
  const tree = _grafana_lezer_logql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(replacedExpr);
  const node = tree.topNode; // This will be modified in the handleExpression

  const visQuery = {
    labels: [],
    operations: []
  };
  const context = {
    query: visQuery,
    errors: []
  };

  try {
    handleExpression(replacedExpr, node, context);
  } catch (err) {
    // Not ideal to log it here, but otherwise we would lose the stack trace.
    console.error(err);

    if (err instanceof Error) {
      context.errors.push({
        text: err.message
      });
    }
  } // If we have empty query, we want to reset errors


  if (isEmptyQuery(context.query)) {
    context.errors = [];
  }

  return context;
}
function handleExpression(expr, node, context) {
  const visQuery = context.query;

  switch (node.name) {
    case 'Matcher':
      {
        visQuery.labels.push(getLabel(expr, node));
        const err = node.getChild(_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.ErrorName);

        if (err) {
          context.errors.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeError)(expr, err));
        }

        break;
      }

    case 'LineFilter':
      {
        const {
          operation,
          error
        } = getLineFilter(expr, node);

        if (operation) {
          visQuery.operations.push(operation);
        } // Show error for query patterns not supported in visual query builder


        if (error) {
          context.errors.push(createNotSupportedError(expr, node, error));
        }

        break;
      }

    case 'LabelParser':
      {
        visQuery.operations.push(getLabelParser(expr, node));
        break;
      }

    case 'LabelFilter':
      {
        const {
          operation,
          error
        } = getLabelFilter(expr, node);

        if (operation) {
          visQuery.operations.push(operation);
        } // Show error for query patterns not supported in visual query builder


        if (error) {
          context.errors.push(createNotSupportedError(expr, node, error));
        }

        break;
      }

    case 'JsonExpressionParser':
      {
        // JsonExpressionParser is not supported in query builder
        const error = 'JsonExpressionParser not supported in visual query builder';
        context.errors.push(createNotSupportedError(expr, node, error));
      }

    case 'LineFormatExpr':
      {
        visQuery.operations.push(getLineFormat(expr, node));
        break;
      }

    case 'LabelFormatMatcher':
      {
        visQuery.operations.push(getLabelFormat(expr, node));
        break;
      }

    case 'UnwrapExpr':
      {
        const {
          operation,
          error
        } = handleUnwrapExpr(expr, node, context);

        if (operation) {
          visQuery.operations.push(operation);
        } // Show error for query patterns not supported in visual query builder


        if (error) {
          context.errors.push(createNotSupportedError(expr, node, error));
        }

        break;
      }

    case 'RangeAggregationExpr':
      {
        visQuery.operations.push(handleRangeAggregation(expr, node, context));
        break;
      }

    case 'VectorAggregationExpr':
      {
        visQuery.operations.push(handleVectorAggregation(expr, node, context));
        break;
      }

    case 'BinOpExpr':
      {
        handleBinary(expr, node, context);
        break;
      }

    case _prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.ErrorName:
      {
        if (isIntervalVariableError(node)) {
          break;
        }

        context.errors.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeError)(expr, node));
        break;
      }

    default:
      {
        // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper
        // nodes that can be skipped.
        // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to
        //  detect those and report back.
        let child = node.firstChild;

        while (child) {
          handleExpression(expr, child, context);
          child = child.nextSibling;
        }
      }
  }
}

function getLabel(expr, node) {
  const labelNode = node.getChild('Identifier');
  const label = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, labelNode);
  const op = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, labelNode.nextSibling);
  const value = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')).replace(/"/g, '');
  return {
    label,
    op,
    value
  };
}

function getLineFilter(expr, node) {
  // Check for nodes not supported in visual builder and return error
  const ipLineFilter = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getAllByType)(expr, node, 'Ip');

  if (ipLineFilter.length > 0) {
    return {
      error: 'Matching ip addresses not supported in query builder'
    };
  }

  const mapFilter = {
    '|=': '__line_contains',
    '!=': '__line_contains_not',
    '|~': '__line_matches_regex',
    '!~': '"__line_matches_regex"_not'
  };
  const filter = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('Filter'));
  const filterExpr = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')));
  return {
    operation: {
      id: mapFilter[filter],
      params: [filterExpr]
    }
  };
}

function getLabelParser(expr, node) {
  const parserNode = node.firstChild;
  const parser = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, parserNode);
  const string = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')));
  const params = !!string ? [string] : [];
  return {
    id: parser,
    params
  };
}

function getLabelFilter(expr, node) {
  // Check for nodes not supported in visual builder and return error
  if (node.getChild('Or') || node.getChild('And') || node.getChild('Comma')) {
    return {
      error: 'Label filter with comma, "and", "or" not supported in query builder'
    };
  }

  if (node.firstChild.name === 'IpLabelFilter') {
    return {
      error: 'IpLabelFilter not supported in query builder'
    };
  }

  const id = '__label_filter';

  if (node.firstChild.name === 'UnitFilter') {
    const filter = node.firstChild.firstChild;
    const label = filter.firstChild;
    const op = label.nextSibling;
    const value = op.nextSibling;
    const valueString = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, value));
    return {
      operation: {
        id,
        params: [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, label), (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, op), valueString]
      }
    };
  } // In this case it is Matcher or NumberFilter


  const filter = node.firstChild;
  const label = filter.firstChild;
  const op = label.nextSibling;
  const value = op.nextSibling;
  const params = [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, label), (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, op), handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, value))]; // Special case of pipe filtering - no errors

  if (params.join('') === `__error__=`) {
    return {
      operation: {
        id: '__label_filter_no_errors',
        params: []
      }
    };
  }

  return {
    operation: {
      id,
      params
    }
  };
}

function getLineFormat(expr, node) {
  const id = 'line_format';
  const string = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')));
  return {
    id,
    params: [string]
  };
}

function getLabelFormat(expr, node) {
  const id = 'label_format';
  const identifier = node.getChild('Identifier');
  const op = identifier.nextSibling;
  const value = op.nextSibling;
  let valueString = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, value));
  return {
    id,
    params: [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, identifier), valueString]
  };
}

function handleUnwrapExpr(expr, node, context) {
  const unwrapExprChild = node.getChild('UnwrapExpr');
  const labelFilterChild = node.getChild('LabelFilter');
  const unwrapChild = node.getChild('Unwrap');

  if (unwrapExprChild) {
    handleExpression(expr, unwrapExprChild, context);
  }

  if (labelFilterChild) {
    handleExpression(expr, labelFilterChild, context);
  }

  if (unwrapChild) {
    var _unwrapChild$nextSibl;

    if ((unwrapChild === null || unwrapChild === void 0 ? void 0 : (_unwrapChild$nextSibl = unwrapChild.nextSibling) === null || _unwrapChild$nextSibl === void 0 ? void 0 : _unwrapChild$nextSibl.type.name) === 'ConvOp') {
      return {
        error: 'Unwrap with conversion operator not supported in query builder'
      };
    }

    return {
      operation: {
        id: 'unwrap',
        params: [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, unwrapChild === null || unwrapChild === void 0 ? void 0 : unwrapChild.nextSibling)]
      }
    };
  }

  return {};
}

function handleRangeAggregation(expr, node, context) {
  const nameNode = node.getChild('RangeOp');
  const funcName = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, nameNode);
  const number = node.getChild('Number');
  const logExpr = node.getChild('LogRangeExpr');
  const params = number !== null && number !== undefined ? [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, number)] : [];
  let match = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node).match(/\[(.+)\]/);

  if (match !== null && match !== void 0 && match[1]) {
    params.push(match[1]);
  }

  const op = {
    id: funcName,
    params
  };

  if (logExpr) {
    handleExpression(expr, logExpr, context);
  }

  return op;
}

function handleVectorAggregation(expr, node, context) {
  const nameNode = node.getChild('VectorOp');
  let funcName = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, nameNode);
  const grouping = node.getChild('Grouping');
  const params = [];
  const numberNode = node.getChild('Number');

  if (numberNode) {
    params.push(Number((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, numberNode)));
  }

  if (grouping) {
    const byModifier = grouping.getChild(`By`);

    if (byModifier && funcName) {
      funcName = `__${funcName}_by`;
    }

    const withoutModifier = grouping.getChild(`Without`);

    if (withoutModifier) {
      funcName = `__${funcName}_without`;
    }

    params.push(...(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getAllByType)(expr, grouping, 'Identifier'));
  }

  const metricExpr = node.getChild('MetricExpr');
  const op = {
    id: funcName,
    params
  };

  if (metricExpr) {
    handleExpression(expr, metricExpr, context);
  }

  return op;
}

const operatorToOpName = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__.binaryScalarDefs.reduce((acc, def) => {
  acc[def.sign] = {
    id: def.id,
    comparison: def.comparison
  };
  return acc;
}, {});
/**
 * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is
 * just operation with scalar or it creates a binaryQuery when it's 2 queries.
 * @param expr
 * @param node
 * @param context
 */

function handleBinary(expr, node, context) {
  const visQuery = context.query;
  const left = node.firstChild;
  const op = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, left.nextSibling);
  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));
  const right = node.lastChild;
  const opDef = operatorToOpName[op];
  const leftNumber = getLastChildWithSelector(left, 'MetricExpr.LiteralExpr.Number');
  const rightNumber = getLastChildWithSelector(right, 'MetricExpr.LiteralExpr.Number');
  const rightBinary = right.getChild('BinOpExpr');

  if (leftNumber) {// TODO: this should be already handled in case parent is binary expression as it has to be added to parent
    //  if query starts with a number that isn't handled now.
  } else {
    // If this is binary we don't really know if there is a query or just chained scalars. So
    // we have to traverse a bit deeper to know
    handleExpression(expr, left, context);
  }

  if (rightNumber) {
    visQuery.operations.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeBinOp)(opDef, expr, right, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
  } else if (rightBinary) {
    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which
    // is a factor for a current binary operation. So we have to add it as an operation now.
    const leftMostChild = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getLeftMostChild)(right);

    if ((leftMostChild === null || leftMostChild === void 0 ? void 0 : leftMostChild.name) === 'Number') {
      visQuery.operations.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeBinOp)(opDef, expr, leftMostChild, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
    } // If we added the first number literal as operation here we still can continue and handle the rest as the first
    // number will be just skipped.


    handleExpression(expr, right, context);
  } else {
    visQuery.binaryQueries = visQuery.binaryQueries || [];
    const binQuery = {
      operator: op,
      query: {
        labels: [],
        operations: []
      }
    };

    if (binModifier !== null && binModifier !== void 0 && binModifier.isMatcher) {
      binQuery.vectorMatchesType = binModifier.matchType;
      binQuery.vectorMatches = binModifier.matches;
    }

    visQuery.binaryQueries.push(binQuery);
    handleExpression(expr, right, {
      query: binQuery.query,
      errors: context.errors
    });
  }
}

function getBinaryModifier(expr, node) {
  if (!node) {
    return undefined;
  }

  if (node.getChild('Bool')) {
    return {
      isBool: true,
      isMatcher: false
    };
  } else {
    var _matcher$getChild;

    const matcher = node.getChild('OnOrIgnoring');

    if (!matcher) {
      // Not sure what this could be, maybe should be an error.
      return undefined;
    }

    const labels = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, (_matcher$getChild = matcher.getChild('GroupingLabels')) === null || _matcher$getChild === void 0 ? void 0 : _matcher$getChild.getChild('GroupingLabelList'));
    return {
      isMatcher: true,
      isBool: false,
      matches: labels,
      matchType: matcher.getChild('On') ? 'on' : 'ignoring'
    };
  }
}

function isIntervalVariableError(node) {
  var _node$parent;

  return (node === null || node === void 0 ? void 0 : (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name) === 'Range';
}

function handleQuotes(string) {
  if (string[0] === `"` && string[string.length - 1] === `"`) {
    return string.replace(/"/g, '').replace(/\\\\/g, '\\');
  }

  return string.replace(/`/g, '');
}
/**
 * Simple helper to traverse the syntax tree. Instead of node.getChild('foo')?.getChild('bar')?.getChild('baz') you
 * can write getChildWithSelector(node, 'foo.bar.baz')
 * @param node
 * @param selector
 */


function getLastChildWithSelector(node, selector) {
  let child = node;
  const children = selector.split('.');

  for (const s of children) {
    child = child.getChild(s);

    if (!child) {
      return null;
    }
  }

  return child;
}
/**
 * Helper function to enrich error text with information that visual query builder doesn't support that logQL
 * @param expr
 * @param node
 * @param error
 */


function createNotSupportedError(expr, node, error) {
  const err = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeError)(expr, node);
  err.text = `${error}: ${err.text}`;
  return err;
}

function isEmptyQuery(query) {
  if (query.labels.length === 0 && query.operations.length === 0) {
    return true;
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/state.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "changeEditorMode": () => (/* binding */ changeEditorMode),
/* harmony export */   "getDefaultEditorMode": () => (/* binding */ getDefaultEditorMode),
/* harmony export */   "getQueryWithDefaults": () => (/* binding */ getQueryWithDefaults),
/* harmony export */   "useRawQuery": () => (/* binding */ useRawQuery)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var app_core_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/core/store.ts");
/* harmony import */ var _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");




const queryEditorModeDefaultLocalStorageKey = 'LokiQueryEditorModeDefault';
function changeEditorMode(query, editorMode, onChange) {
  // If empty query store new mode as default
  if (query.expr === '') {
    app_core_store__WEBPACK_IMPORTED_MODULE_1__["default"].set(queryEditorModeDefaultLocalStorageKey, editorMode);
  }

  onChange(Object.assign({}, query, {
    editorMode
  }));
}
function getDefaultEditorMode(expr) {
  // If we already have an expression default to code view
  if (expr != null && expr !== '') {
    return _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_2__.QueryEditorMode.Code;
  }

  const value = app_core_store__WEBPACK_IMPORTED_MODULE_1__["default"].get(queryEditorModeDefaultLocalStorageKey);

  switch (value) {
    case _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_2__.QueryEditorMode.Builder:
    case _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_2__.QueryEditorMode.Code:
    case _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_2__.QueryEditorMode.Explain:
      return value;

    default:
      return _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_2__.QueryEditorMode.Builder;
  }
}
/**
 * Returns query with defaults, and boolean true/false depending on change was required
 */

function getQueryWithDefaults(query) {
  // If no expr (ie new query) then default to builder
  let result = query;

  if (!query.editorMode) {
    result = Object.assign({}, query, {
      editorMode: getDefaultEditorMode(query.expr)
    });
  }

  if (query.expr == null) {
    result = Object.assign({}, result, {
      expr: ''
    });
  }

  if (query.queryType == null) {
    // Default to range query
    result = Object.assign({}, result, {
      queryType: _types__WEBPACK_IMPORTED_MODULE_3__.LokiQueryType.Range
    });
  }

  return result;
}
const queryEditorRawQueryLocalStorageKey = 'LokiQueryEditorRawQueryDefault';

function getRawQueryVisibility() {
  const val = app_core_store__WEBPACK_IMPORTED_MODULE_1__["default"].get(queryEditorRawQueryLocalStorageKey);
  return val === undefined ? true : Boolean(parseInt(val, 10));
}

function setRawQueryVisibility(value) {
  app_core_store__WEBPACK_IMPORTED_MODULE_1__["default"].set(queryEditorRawQueryLocalStorageKey, value ? '1' : '0');
}
/**
 * Use and store value of raw query switch in local storage.
 * Needs to be a hook with local state to trigger rerenders.
 */


function useRawQuery() {
  const [rawQuery, setRawQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getRawQueryVisibility());
  const setter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(value => {
    setRawQueryVisibility(value);
    setRawQuery(value);
  }, []);
  return [rawQuery, setter];
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiOperationId": () => (/* binding */ LokiOperationId),
/* harmony export */   "LokiOperationOrder": () => (/* binding */ LokiOperationOrder),
/* harmony export */   "LokiVisualQueryOperationCategory": () => (/* binding */ LokiVisualQueryOperationCategory)
/* harmony export */ });
/**
 * Visual query model
 */
let LokiVisualQueryOperationCategory;

(function (LokiVisualQueryOperationCategory) {
  LokiVisualQueryOperationCategory["Aggregations"] = "Aggregations";
  LokiVisualQueryOperationCategory["RangeFunctions"] = "Range functions";
  LokiVisualQueryOperationCategory["Functions"] = "Functions";
  LokiVisualQueryOperationCategory["Formats"] = "Formats";
  LokiVisualQueryOperationCategory["LineFilters"] = "Line filters";
  LokiVisualQueryOperationCategory["LabelFilters"] = "Label filters";
  LokiVisualQueryOperationCategory["BinaryOps"] = "Binary operations";
})(LokiVisualQueryOperationCategory || (LokiVisualQueryOperationCategory = {}));

let LokiOperationId;

(function (LokiOperationId) {
  LokiOperationId["Json"] = "json";
  LokiOperationId["Logfmt"] = "logfmt";
  LokiOperationId["Regexp"] = "regexp";
  LokiOperationId["Pattern"] = "pattern";
  LokiOperationId["Unpack"] = "unpack";
  LokiOperationId["LineFormat"] = "line_format";
  LokiOperationId["LabelFormat"] = "label_format";
  LokiOperationId["Rate"] = "rate";
  LokiOperationId["CountOverTime"] = "count_over_time";
  LokiOperationId["SumOverTime"] = "sum_over_time";
  LokiOperationId["AvgOverTime"] = "avg_over_time";
  LokiOperationId["MaxOverTime"] = "max_over_time";
  LokiOperationId["MinOverTime"] = "min_over_time";
  LokiOperationId["FirstOverTime"] = "first_over_time";
  LokiOperationId["LastOverTime"] = "last_over_time";
  LokiOperationId["StdvarOverTime"] = "stdvar_over_time";
  LokiOperationId["StddevOverTime"] = "stddev_over_time";
  LokiOperationId["QuantileOverTime"] = "quantile_over_time";
  LokiOperationId["BytesRate"] = "bytes_rate";
  LokiOperationId["BytesOverTime"] = "bytes_over_time";
  LokiOperationId["AbsentOverTime"] = "absent_over_time";
  LokiOperationId["Sum"] = "sum";
  LokiOperationId["Avg"] = "avg";
  LokiOperationId["Min"] = "min";
  LokiOperationId["Max"] = "max";
  LokiOperationId["Stddev"] = "stddev";
  LokiOperationId["Stdvar"] = "stdvar";
  LokiOperationId["Count"] = "count";
  LokiOperationId["TopK"] = "topk";
  LokiOperationId["BottomK"] = "bottomk";
  LokiOperationId["LineContains"] = "__line_contains";
  LokiOperationId["LineContainsNot"] = "__line_contains_not";
  LokiOperationId["LineMatchesRegex"] = "__line_matches_regex";
  LokiOperationId["LineMatchesRegexNot"] = "__line_matches_regex_not";
  LokiOperationId["LabelFilter"] = "__label_filter";
  LokiOperationId["LabelFilterNoErrors"] = "__label_filter_no_errors";
  LokiOperationId["Unwrap"] = "unwrap";
  LokiOperationId["Addition"] = "__addition";
  LokiOperationId["Subtraction"] = "__subtraction";
  LokiOperationId["MultiplyBy"] = "__multiply_by";
  LokiOperationId["DivideBy"] = "__divide_by";
  LokiOperationId["Modulo"] = "__modulo";
  LokiOperationId["Exponent"] = "__exponent";
  LokiOperationId["NestedQuery"] = "__nested_query";
  LokiOperationId["EqualTo"] = "__equal_to";
  LokiOperationId["NotEqualTo"] = "__not_equal_to";
  LokiOperationId["GreaterThan"] = "__greater_than";
  LokiOperationId["LessThan"] = "__less_than";
  LokiOperationId["GreaterOrEqual"] = "__greater_or_equal";
  LokiOperationId["LessOrEqual"] = "__less_or_equal";
})(LokiOperationId || (LokiOperationId = {}));

let LokiOperationOrder;

(function (LokiOperationOrder) {
  LokiOperationOrder[LokiOperationOrder["LineFilters"] = 1] = "LineFilters";
  LokiOperationOrder[LokiOperationOrder["LineFormats"] = 2] = "LineFormats";
  LokiOperationOrder[LokiOperationOrder["LabelFilters"] = 3] = "LabelFilters";
  LokiOperationOrder[LokiOperationOrder["Unwrap"] = 4] = "Unwrap";
  LokiOperationOrder[LokiOperationOrder["NoErrors"] = 5] = "NoErrors";
  LokiOperationOrder[LokiOperationOrder["RangeVectorFunction"] = 5] = "RangeVectorFunction";
  LokiOperationOrder[LokiOperationOrder["Last"] = 6] = "Last";
})(LokiOperationOrder || (LokiOperationOrder = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/loki/responseUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dataFrameHasLokiError": () => (/* binding */ dataFrameHasLokiError)
/* harmony export */ });
function dataFrameHasLokiError(frame) {
  var _frame$fields$find$va, _frame$fields$find;

  const labelSets = (_frame$fields$find$va = (_frame$fields$find = frame.fields.find(f => f.name === 'labels')) === null || _frame$fields$find === void 0 ? void 0 : _frame$fields$find.values.toArray()) !== null && _frame$fields$find$va !== void 0 ? _frame$fields$find$va : [];
  return labelSets.some(labels => labels.__error__ !== undefined);
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/sortDataFrame.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sortDataFrameByTime": () => (/* binding */ sortDataFrameByTime)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
const _excluded = ["fields"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



// creates the `index` for the sorting.
// this is needed by the `SortedVector`.
// the index is an array of numbers, and it defines an order.
// at every slot in the index the values is the position of
// the sorted item.
// for example, an index of [3,1,2] means that
// in the dataframe, that has 3 rows, after sorting:
// - the third row will become the first
// - the first row will become the second
// - the second row will become the third
function makeIndex(field, dir) {
  const fieldValues = field.values.toArray(); // we first build an array which is [0,1,2,3....]

  const index = Array(fieldValues.length);

  for (let i = 0; i < index.length; i++) {
    index[i] = i;
  }

  const isAsc = dir === 'ASCENDING';
  index.sort((a, b) => {
    // we need to answer this question:
    // in the field-used-for-sorting, how would we compare value-at-index-a to value-at-index-b?
    const valA = fieldValues[a];
    const valB = fieldValues[b];

    if (valA < valB) {
      return isAsc ? -1 : 1;
    }

    if (valA > valB) {
      return isAsc ? 1 : -1;
    }

    return 0;
  });
  return index;
} // sort a dataframe that is in the Loki format ascending or descending,
// based on the nanosecond-timestamp


function sortDataFrameByTime(frame, dir) {
  const {
    fields
  } = frame,
        rest = _objectWithoutPropertiesLoose(frame, _excluded); // we use the approach used in @grafana/data/sortDataframe.
  // we cannot use it directly, because our tsNs field has a type=time,
  // so we have to build the `index` manually.


  const tsNsField = fields.find(field => field.name === 'tsNs');

  if (tsNsField === undefined) {
    throw new Error('missing nanosecond-timestamp field. should never happen');
  }

  const index = makeIndex(tsNsField, dir);
  return Object.assign({}, rest, {
    fields: fields.map(field => Object.assign({}, field, {
      values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.SortedVector(field.values, index)
    }))
  });
  return frame;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/streaming.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "doLokiChannelStream": () => (/* binding */ doLokiChannelStream),
/* harmony export */   "getLiveStreamKey": () => (/* binding */ getLiveStreamKey)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/defer.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var app_features_live_data_StreamingDataFrame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/live/data/StreamingDataFrame.ts");





/**
 * Calculate a unique key for the query.  The key is used to pick a channel and should
 * be unique for each distinct query execution plan.  This key is not secure and is only picked to avoid
 * possible collisions
 */
async function getLiveStreamKey(query) {
  const str = JSON.stringify({
    expr: query.expr
  });
  const msgUint8 = new TextEncoder().encode(str); // encode as (utf-8) Uint8Array

  const hashBuffer = await crypto.subtle.digest('SHA-1', msgUint8); // hash the message

  const hashArray = Array.from(new Uint8Array(hashBuffer.slice(0, 8))); // first 8 bytes

  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
} // This will get both v1 and v2 result formats

function doLokiChannelStream(query, ds, options) {
  var _options$maxDataPoint;

  // maximum time to keep values
  const range = options.range;
  const maxDelta = range.to.valueOf() - range.from.valueOf() + 1000;
  let maxLength = (_options$maxDataPoint = options.maxDataPoints) !== null && _options$maxDataPoint !== void 0 ? _options$maxDataPoint : 1000;

  if (maxLength > 100) {
    // for small buffers, keep them small
    maxLength *= 2;
  }

  let frame = undefined;

  const updateFrame = msg => {
    if (msg !== null && msg !== void 0 && msg.message) {
      const p = msg.message;

      if (!frame) {
        frame = app_features_live_data_StreamingDataFrame__WEBPACK_IMPORTED_MODULE_2__.StreamingDataFrame.fromDataFrameJSON(p, {
          maxLength,
          maxDelta,
          displayNameFormat: query.legendFormat
        });
      } else {
        frame.push(p);
      }
    }

    return frame;
  };

  return (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.defer)(() => getLiveStreamKey(query)).pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_4__.mergeMap)(key => {
    return (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getGrafanaLiveSrv)().getStream({
      scope: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.LiveChannelScope.DataSource,
      namespace: ds.uid,
      path: `tail/${key}`,
      data: Object.assign({}, query, {
        timeRange: {
          from: range.from.valueOf().toString(),
          to: range.to.valueOf().toString()
        }
      })
    }).pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_5__.map)(evt => {
      const frame = updateFrame(evt);
      return {
        data: frame ? [frame] : [],
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.LoadingState.Streaming
      };
    }));
  }));
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/syntax.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FUNCTIONS": () => (/* binding */ FUNCTIONS),
/* harmony export */   "LOKI_KEYWORDS": () => (/* binding */ LOKI_KEYWORDS),
/* harmony export */   "PIPE_OPERATORS": () => (/* binding */ PIPE_OPERATORS),
/* harmony export */   "PIPE_PARSERS": () => (/* binding */ PIPE_PARSERS),
/* harmony export */   "RANGE_VEC_FUNCTIONS": () => (/* binding */ RANGE_VEC_FUNCTIONS),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "lokiGrammar": () => (/* binding */ lokiGrammar)
/* harmony export */ });
const AGGREGATION_OPERATORS = [{
  label: 'sum',
  insertText: 'sum',
  documentation: 'Calculate sum over dimensions'
}, {
  label: 'min',
  insertText: 'min',
  documentation: 'Select minimum over dimensions'
}, {
  label: 'max',
  insertText: 'max',
  documentation: 'Select maximum over dimensions'
}, {
  label: 'avg',
  insertText: 'avg',
  documentation: 'Calculate the average over dimensions'
}, {
  label: 'stddev',
  insertText: 'stddev',
  documentation: 'Calculate population standard deviation over dimensions'
}, {
  label: 'stdvar',
  insertText: 'stdvar',
  documentation: 'Calculate population standard variance over dimensions'
}, {
  label: 'count',
  insertText: 'count',
  documentation: 'Count number of elements in the vector'
}, {
  label: 'bottomk',
  insertText: 'bottomk',
  documentation: 'Smallest k elements by sample value'
}, {
  label: 'topk',
  insertText: 'topk',
  documentation: 'Largest k elements by sample value'
}];
const PIPE_PARSERS = [{
  label: 'json',
  insertText: 'json',
  documentation: 'Extracting labels from the log line using json parser. Only available in Loki 2.0+.'
}, {
  label: 'regexp',
  insertText: 'regexp ""',
  documentation: 'Extracting labels from the log line using regexp parser. Only available in Loki 2.0+.',
  move: -1
}, {
  label: 'logfmt',
  insertText: 'logfmt',
  documentation: 'Extracting labels from the log line using logfmt parser. Only available in Loki 2.0+.'
}, {
  label: 'pattern',
  insertText: 'pattern',
  documentation: 'Extracting labels from the log line using pattern parser. Only available in Loki 2.3+.'
}, {
  label: 'unpack',
  insertText: 'unpack',
  detail: 'unpack identifier',
  documentation: 'Parses a JSON log line, unpacking all embedded labels in the pack stage. A special property "_entry" will also be used to replace the original log line. Only available in Loki 2.2+.'
}];
const PIPE_OPERATORS = [{
  label: 'unwrap',
  insertText: 'unwrap',
  detail: 'unwrap identifier',
  documentation: 'Take labels and use the values as sample data for metric aggregations. Only available in Loki 2.0+.'
}, {
  label: 'label_format',
  insertText: 'label_format',
  documentation: 'Use to rename, modify or add labels. For example, | label_format foo=bar . Only available in Loki 2.0+.'
}, {
  label: 'line_format',
  insertText: 'line_format',
  documentation: 'Rewrites log line content. For example, | line_format "{{.query}} {{.duration}}" . Only available in Loki 2.0+.'
}];
const RANGE_VEC_FUNCTIONS = [{
  insertText: 'avg_over_time',
  label: 'avg_over_time',
  detail: 'avg_over_time(range-vector)',
  documentation: 'The average of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'min_over_time',
  label: 'min_over_time',
  detail: 'min_over_time(range-vector)',
  documentation: 'The minimum of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'max_over_time',
  label: 'max_over_time',
  detail: 'max_over_time(range-vector)',
  documentation: 'The maximum of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'first_over_time',
  label: 'first_over_time',
  detail: 'first_over_time(range-vector)',
  documentation: 'The first of all values in the specified interval. Only available in Loki 2.3+.'
}, {
  insertText: 'last_over_time',
  label: 'last_over_time',
  detail: 'last_over_time(range-vector)',
  documentation: 'The last of all values in the specified interval. Only available in Loki 2.3+.'
}, {
  insertText: 'sum_over_time',
  label: 'sum_over_time',
  detail: 'sum_over_time(range-vector)',
  documentation: 'The sum of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'count_over_time',
  label: 'count_over_time',
  detail: 'count_over_time(range-vector)',
  documentation: 'The count of all values in the specified interval.'
}, {
  insertText: 'stdvar_over_time',
  label: 'stdvar_over_time',
  detail: 'stdvar_over_time(range-vector)',
  documentation: 'The population standard variance of the values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'stddev_over_time',
  label: 'stddev_over_time',
  detail: 'stddev_over_time(range-vector)',
  documentation: 'The population standard deviation of the values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'quantile_over_time',
  label: 'quantile_over_time',
  detail: 'quantile_over_time(scalar, range-vector)',
  documentation: 'The Ï†-quantile (0 â‰¤ Ï† â‰¤ 1) of the values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'bytes_over_time',
  label: 'bytes_over_time',
  detail: 'bytes_over_time(range-vector)',
  documentation: 'Counts the amount of bytes used by each log stream for a given range'
}, {
  insertText: 'bytes_rate',
  label: 'bytes_rate',
  detail: 'bytes_rate(range-vector)',
  documentation: 'Calculates the number of bytes per second for each stream.'
}, {
  insertText: 'rate',
  label: 'rate',
  detail: 'rate(v range-vector)',
  documentation: 'Calculates the number of entries per second.'
}];
const FUNCTIONS = [...AGGREGATION_OPERATORS, ...RANGE_VEC_FUNCTIONS];
const LOKI_KEYWORDS = [...FUNCTIONS, ...PIPE_OPERATORS, ...PIPE_PARSERS].map(keyword => keyword.label);
const lokiGrammar = {
  comment: {
    pattern: /#.*/
  },
  'context-aggregation': {
    pattern: /((without|by)\s*)\([^)]*\)/,
    // by ()
    lookbehind: true,
    inside: {
      'label-key': {
        pattern: /[^(),\s][^,)]*[^),\s]*/,
        alias: 'attr-name'
      },
      punctuation: /[()]/
    }
  },
  'context-labels': {
    pattern: /\{[^}]*(?=}?)/,
    greedy: true,
    inside: {
      comment: {
        pattern: /#.*/
      },
      'label-key': {
        pattern: /[a-zA-Z_]\w*(?=\s*(=|!=|=~|!~))/,
        alias: 'attr-name',
        greedy: true
      },
      'label-value': {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: true,
        alias: 'attr-value'
      },
      punctuation: /[{]/
    }
  },
  'context-pipe': {
    pattern: /\s\|[^=~]\s?\w*/i,
    inside: {
      'pipe-operator': {
        pattern: /\|/i,
        alias: 'operator'
      },
      'pipe-operations': {
        pattern: new RegExp(`${[...PIPE_PARSERS, ...PIPE_OPERATORS].map(f => f.label).join('|')}`, 'i'),
        alias: 'keyword'
      }
    }
  },
  function: new RegExp(`\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\s*\\()`, 'i'),
  'context-range': [{
    pattern: /\[[^\]]*(?=\])/,
    // [1m]
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }, {
    pattern: /(offset\s+)\w+/,
    // offset 1m
    lookbehind: true,
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }],
  quote: {
    pattern: /"(?:\\.|[^\\"])*"/,
    alias: 'string',
    greedy: true
  },
  backticks: {
    pattern: /`(?:\\.|[^\\`])*`/,
    alias: 'string',
    greedy: true
  },
  number: /\b-?\d+((\.\d*)?([eE][+-]?\d+)?)?\b/,
  operator: /\s?(\|[=~]?|!=?|<(?:=>?|<|>)?|>[>=]?)\s?/i,
  punctuation: /[{}(),.]/
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lokiGrammar);

/***/ }),

/***/ "./public/app/plugins/datasource/loki/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryDirection": () => (/* binding */ LokiQueryDirection),
/* harmony export */   "LokiQueryType": () => (/* binding */ LokiQueryType),
/* harmony export */   "LokiResultType": () => (/* binding */ LokiResultType)
/* harmony export */ });
let LokiResultType;

(function (LokiResultType) {
  LokiResultType["Stream"] = "streams";
  LokiResultType["Vector"] = "vector";
  LokiResultType["Matrix"] = "matrix";
})(LokiResultType || (LokiResultType = {}));

let LokiQueryType;

(function (LokiQueryType) {
  LokiQueryType["Range"] = "range";
  LokiQueryType["Instant"] = "instant";
  LokiQueryType["Stream"] = "stream";
})(LokiQueryType || (LokiQueryType = {}));

let LokiQueryDirection;

(function (LokiQueryDirection) {
  LokiQueryDirection["Backward"] = "backward";
  LokiQueryDirection["Forward"] = "forward";
})(LokiQueryDirection || (LokiQueryDirection = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/add_label_to_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLabelToQuery": () => (/* binding */ addLabelToQuery)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _querybuilder_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");




/**
 * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.
 *
 * It uses PromQL parser to find instances of metric and labels, alters them and then splices them back into the query.
 * Ideally we could use the parse -> change -> render is a simple 3 steps but right now building the visual query
 * object does not support all possible queries.
 *
 * So instead this just operates on substrings of the query with labels and operates just on those. This makes this
 * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.
 * @param query
 * @param key
 * @param value
 * @param operator
 */
function addLabelToQuery(query, key, value, operator = '=') {
  if (!key || !value) {
    throw new Error('Need label to add to query.');
  }

  const vectorSelectorPositions = getVectorSelectorPositions(query);

  if (!vectorSelectorPositions.length) {
    return query;
  }

  const filter = toLabelFilter(key, value, operator);
  return addFilter(query, vectorSelectorPositions, filter);
}

/**
 * Parse the string and get all VectorSelector positions in the query together with parsed representation of the vector
 * selector.
 * @param query
 */
function getVectorSelectorPositions(query) {
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(query);
  const positions = [];
  tree.iterate({
    enter: (type, from, to, get) => {
      if (type.name === 'VectorSelector') {
        const visQuery = (0,_querybuilder_parsing__WEBPACK_IMPORTED_MODULE_2__.buildVisualQueryFromString)(query.substring(from, to));
        positions.push({
          query: visQuery.query,
          from,
          to
        });
        return false;
      }
    }
  });
  return positions;
}

function toLabelFilter(key, value, operator) {
  // We need to make sure that we convert the value back to string because it may be a number
  const transformedValue = value === Infinity ? '+Inf' : value.toString();
  return {
    label: key,
    op: operator,
    value: transformedValue
  };
}

function addFilter(query, vectorSelectorPositions, filter) {
  const modeller = new _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__.PromQueryModeller();
  let newQuery = '';
  let prev = 0;

  for (let i = 0; i < vectorSelectorPositions.length; i++) {
    // This is basically just doing splice on a string for each matched vector selector.
    const match = vectorSelectorPositions[i];
    const isLast = i === vectorSelectorPositions.length - 1;
    const start = query.substring(prev, match.from);
    const end = isLast ? query.substring(match.to) : '';

    if (!labelExists(match.query.labels, filter)) {
      // We don't want to add duplicate labels.
      match.query.labels.push(filter);
    }

    const newLabels = modeller.renderQuery(match.query);
    newQuery += start + newLabels + end;
    prev = match.to;
  }

  return newQuery;
}
/**
 * Check if label exists in the list of labels but ignore the operator.
 * @param labels
 * @param filter
 */


function labelExists(labels, filter) {
  return labels.find(label => label.label === filter.label && label.value === filter.value);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_provider.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUGGESTIONS_LIMIT": () => (/* binding */ SUGGESTIONS_LIMIT),
/* harmony export */   "addHistoryMetadata": () => (/* binding */ addHistoryMetadata),
/* harmony export */   "default": () => (/* binding */ PromQlLanguageProvider),
/* harmony export */   "getMetadataString": () => (/* binding */ getMetadataString)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.10.1-5af910d0ed-e8b190d71e.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.28.0-28f20a79ff-bde93fb2be.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const DEFAULT_KEYS = ['job', 'instance'];
const EMPTY_SELECTOR = '{}';
const HISTORY_ITEM_COUNT = 5;
const HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h
// Max number of items (metrics, labels, values) that we display as suggestions. Prevents from running out of memory.

const SUGGESTIONS_LIMIT = 10000;

const wrapLabel = label => ({
  label
});

const setFunctionKind = suggestion => {
  suggestion.kind = 'function';
  return suggestion;
};

function addHistoryMetadata(item, history) {
  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;
  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);
  const count = historyForItem.length;
  const recent = historyForItem[0];
  let hint = `Queried ${count} times in the last 24h.`;

  if (recent) {
    const lastQueried = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(recent.ts).fromNow();
    hint = `${hint} Last queried ${lastQueried}.`;
  }

  return Object.assign({}, item, {
    documentation: hint
  });
}

function addMetricsMetadata(metric, metadata) {
  const item = {
    label: metric
  };

  if (metadata && metadata[metric]) {
    item.documentation = getMetadataString(metric, metadata);
  }

  return item;
}

function getMetadataString(metric, metadata) {
  if (!metadata[metric]) {
    return undefined;
  }

  const {
    type,
    help
  } = metadata[metric];
  return `${type.toUpperCase()}: ${help}`;
}
const PREFIX_DELIMITER_REGEX = /(="|!="|=~"|!~"|\{|\[|\(|\+|-|\/|\*|%|\^|\band\b|\bor\b|\bunless\b|==|>=|!=|<=|>|<|=|~|,)/;
class PromQlLanguageProvider extends _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LanguageProvider {
  /**
   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does
   *  not account for different size of a response. If that is needed a `length` function can be added in the options.
   *  10 as a max size is totally arbitrary right now.
   */
  constructor(datasource, initialValues) {
    super();

    _defineProperty(this, "histogramMetrics", void 0);

    _defineProperty(this, "timeRange", void 0);

    _defineProperty(this, "metrics", void 0);

    _defineProperty(this, "metricsMetadata", void 0);

    _defineProperty(this, "datasource", void 0);

    _defineProperty(this, "labelKeys", []);

    _defineProperty(this, "labelsCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "request", async (url, defaultValue, params = {}) => {
      try {
        const res = await this.datasource.metadataRequest(url, params);
        return res.data.data;
      } catch (error) {
        console.error(error);
      }

      return defaultValue;
    });

    _defineProperty(this, "start", async () => {
      if (this.datasource.lookupsDisabled) {
        return [];
      } // TODO #33976: make those requests parallel


      await this.fetchLabels();
      this.metrics = (await this.fetchLabelValues('__name__')) || [];
      await this.loadMetricsMetadata();
      this.histogramMetrics = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processHistogramMetrics)(this.metrics).sort();
      return [];
    });

    _defineProperty(this, "provideCompletionItems", async ({
      prefix,
      text,
      value,
      labelKey,
      wrapperClasses
    }, context = {}) => {
      const emptyResult = {
        suggestions: []
      };

      if (!value) {
        return emptyResult;
      } // Local text properties


      const empty = value.document.text.length === 0;
      const selectedLines = value.document.getTextsAtRange(value.selection);
      const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;
      const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null; // Syntax spans have 3 classes by default. More indicate a recognized token

      const tokenRecognized = wrapperClasses.length > 3; // Non-empty prefix, but not inside known token

      const prefixUnrecognized = prefix && !tokenRecognized; // Prevent suggestions in `function(|suffix)`

      const noSuffix = !nextCharacter || nextCharacter === ')'; // Prefix is safe if it does not immediately follow a complete expression and has no text after it

      const safePrefix = prefix && !text.match(/^[\]})\s]+$/) && noSuffix; // About to type next operand if preceded by binary operator

      const operatorsPattern = /[+\-*/^%]/;
      const isNextOperand = text.match(operatorsPattern); // Determine candidates by CSS context

      if (wrapperClasses.includes('context-range')) {
        // Suggestions for metric[|]
        return this.getRangeCompletionItems();
      } else if (wrapperClasses.includes('context-labels')) {
        // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}
        return this.getLabelCompletionItems({
          prefix,
          text,
          value,
          labelKey,
          wrapperClasses
        });
      } else if (wrapperClasses.includes('context-aggregation')) {
        // Suggestions for sum(metric) by (|)
        return this.getAggregationCompletionItems(value);
      } else if (empty) {
        // Suggestions for empty query field
        return this.getEmptyCompletionItems(context);
      } else if (prefixUnrecognized && noSuffix && !isNextOperand) {
        // Show term suggestions in a couple of scenarios
        return this.getBeginningCompletionItems(context);
      } else if (prefixUnrecognized && safePrefix) {
        // Show term suggestions in a couple of scenarios
        return this.getTermCompletionItems();
      }

      return emptyResult;
    });

    _defineProperty(this, "getBeginningCompletionItems", context => {
      return {
        suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions]
      };
    });

    _defineProperty(this, "getEmptyCompletionItems", context => {
      const {
        history
      } = context;
      const suggestions = [];

      if (history && history.length) {
        const historyItems = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(history).map(h => h.query.expr).filter().uniq().take(HISTORY_ITEM_COUNT).map(wrapLabel).map(item => addHistoryMetadata(item, history)).value();
        suggestions.push({
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
          skipSort: true,
          label: 'History',
          items: historyItems
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getTermCompletionItems", () => {
      const {
        metrics,
        metricsMetadata
      } = this;
      const suggestions = [];
      suggestions.push({
        searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
        label: 'Functions',
        items: _promql__WEBPACK_IMPORTED_MODULE_6__.FUNCTIONS.map(setFunctionKind)
      });

      if (metrics && metrics.length) {
        suggestions.push({
          label: 'Metrics',
          items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getAggregationCompletionItems", async value => {
      const suggestions = []; // Stitch all query lines together to support multi-line queries

      let queryOffset;
      const queryText = value.document.getBlocks().reduce((text, block) => {
        if (text === undefined) {
          return '';
        }

        if (!block) {
          return text;
        }

        const blockText = block === null || block === void 0 ? void 0 : block.getText();

        if (value.anchorBlock.key === block.key) {
          // Newline characters are not accounted for but this is irrelevant
          // for the purpose of extracting the selector string
          queryOffset = value.selection.anchor.offset + text.length;
        }

        return text + blockText;
      }, ''); // Try search for selector part on the left-hand side, such as `sum (m) by (l)`

      const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);
      let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);
      let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex); // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`

      if (openParensSelectorIndex === -1) {
        const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);
        closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);
        openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);
      }

      const result = {
        suggestions,
        context: 'context-aggregation'
      }; // Suggestions are useless for alternative aggregation clauses without a selector in context

      if (openParensSelectorIndex === -1) {
        return result;
      } // Range vector syntax not accounted for by subsequent parse so discard it if present


      const selectorString = queryText.slice(openParensSelectorIndex + 1, closeParensSelectorIndex).replace(/\[[^\]]+\]$/, '');
      const selector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(selectorString, selectorString.length - 2).selector;
      const series = await this.getSeries(selector);
      const labelKeys = Object.keys(series);

      if (labelKeys.length > 0) {
        const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(labelKeys);
        suggestions.push({
          label: `Labels${limitInfo}`,
          items: labelKeys.map(wrapLabel),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return result;
    });

    _defineProperty(this, "getLabelCompletionItems", async ({
      text,
      wrapperClasses,
      labelKey,
      value
    }) => {
      if (!value) {
        return {
          suggestions: []
        };
      }

      const suggestions = [];
      const line = value.anchorBlock.getText();
      const cursorOffset = value.selection.anchor.offset;
      const suffix = line.substr(cursorOffset);
      const prefix = line.substr(0, cursorOffset);
      const isValueStart = text.match(/^(=|=~|!=|!~)/);
      const isValueEnd = suffix.match(/^"?[,}]|$/); // Detect cursor in front of value, e.g., {key=|"}

      const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^"/); // Don't suggest anything at the beginning or inside a value

      const isValueEmpty = isValueStart && isValueEnd;
      const hasValuePrefix = isValueEnd && !isValueStart;

      if (!isValueEmpty && !hasValuePrefix || isPreValue) {
        return {
          suggestions
        };
      } // Get normalized selector


      let selector;
      let parsedSelector;

      try {
        parsedSelector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(line, cursorOffset);
        selector = parsedSelector.selector;
      } catch {
        selector = EMPTY_SELECTOR;
      }

      const containsMetric = selector.includes('__name__=');
      const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];
      let series = {}; // Query labels for selector

      if (selector) {
        series = await this.getSeries(selector, !containsMetric);
      }

      if (Object.keys(series).length === 0) {
        console.warn(`Server did not return any values for selector = ${selector}`);
        return {
          suggestions
        };
      }

      let context;

      if (text && isValueStart || wrapperClasses.includes('attr-value')) {
        // Label values
        if (labelKey && series[labelKey]) {
          context = 'context-label-values';
          const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(series[labelKey]);
          suggestions.push({
            label: `Label values for "${labelKey}"${limitInfo}`,
            items: series[labelKey].map(wrapLabel),
            searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
          });
        }
      } else {
        // Label keys
        const labelKeys = series ? Object.keys(series) : containsMetric ? null : DEFAULT_KEYS;

        if (labelKeys) {
          const possibleKeys = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.difference)(labelKeys, existingKeys);

          if (possibleKeys.length) {
            context = 'context-labels';
            const newItems = possibleKeys.map(key => ({
              label: key
            }));
            const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(newItems);
            const newSuggestion = {
              label: `Labels${limitInfo}`,
              items: newItems,
              searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
            };
            suggestions.push(newSuggestion);
          }
        }
      }

      return {
        context,
        suggestions
      };
    });

    _defineProperty(this, "fetchLabelValues", async key => {
      const params = this.datasource.getTimeRangeParams();
      const url = `/api/v1/label/${this.datasource.interpolateString(key)}/values`;
      return await this.request(url, [], params);
    });

    _defineProperty(this, "fetchSeriesLabels", async (name, withName) => {
      const interpolatedName = this.datasource.interpolateString(name);
      const range = this.datasource.getTimeRangeParams();
      const urlParams = Object.assign({}, range, {
        'match[]': interpolatedName
      });
      const url = `/api/v1/series`; // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.
      // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every
      // millisecond while still actually getting all the keys for the correct interval. This still can create problems
      // when user does not the newest values for a minute if already cached.

      const cacheParams = new URLSearchParams({
        'match[]': interpolatedName,
        start: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.start, 10)).toString(),
        end: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.end, 10)).toString(),
        withName: withName ? 'true' : 'false'
      });
      const cacheKey = `/api/v1/series?${cacheParams.toString()}`;
      let value = this.labelsCache.get(cacheKey);

      if (!value) {
        const data = await this.request(url, [], urlParams);
        const {
          values
        } = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processLabels)(data, withName);
        value = values;
        this.labelsCache.set(cacheKey, value);
      }

      return value;
    });

    _defineProperty(this, "fetchSeries", async match => {
      const url = '/api/v1/series';
      const range = this.datasource.getTimeRangeParams();
      const params = Object.assign({}, range, {
        'match[]': match
      });
      return await this.request(url, {}, params);
    });

    _defineProperty(this, "fetchDefaultSeries", (0,lodash__WEBPACK_IMPORTED_MODULE_0__.once)(async () => {
      const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));
      return DEFAULT_KEYS.reduce((acc, key, i) => Object.assign({}, acc, {
        [key]: values[i]
      }), {});
    }));

    this.datasource = datasource;
    this.histogramMetrics = [];
    this.timeRange = {
      start: 0,
      end: 0
    };
    this.metrics = [];
    Object.assign(this, initialValues);
  } // Strip syntax chars so that typeahead suggestions can work on clean inputs


  cleanText(s) {
    const parts = s.split(PREFIX_DELIMITER_REGEX);
    const last = parts.pop();
    return last.trimLeft().replace(/"$/, '').replace(/^"/, '');
  }

  get syntax() {
    return _promql__WEBPACK_IMPORTED_MODULE_6__["default"];
  }

  async loadMetricsMetadata() {
    this.metricsMetadata = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.fixSummariesMetadata)(await this.request('/api/v1/metadata', {}));
  }

  getLabelKeys() {
    return this.labelKeys;
  }

  getRangeCompletionItems() {
    return {
      context: 'context-range',
      suggestions: [{
        label: 'Range vector',
        items: [..._promql__WEBPACK_IMPORTED_MODULE_6__.RATE_RANGES]
      }]
    };
  }

  importFromAbstractQuery(labelBasedQuery) {
    return (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.toPromLikeQuery)(labelBasedQuery);
  }

  exportToAbstractQuery(query) {
    const promQuery = query.expr;

    if (!promQuery || promQuery.length === 0) {
      return {
        refId: query.refId,
        labelMatchers: []
      };
    }

    const tokens = prismjs__WEBPACK_IMPORTED_MODULE_2___default().tokenize(promQuery, _promql__WEBPACK_IMPORTED_MODULE_6__["default"]);
    const labelMatchers = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.extractLabelMatchers)(tokens);
    const nameLabelValue = getNameLabelValue(promQuery, tokens);

    if (nameLabelValue && nameLabelValue.length > 0) {
      labelMatchers.push({
        name: '__name__',
        operator: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.AbstractLabelOperator.Equal,
        value: nameLabelValue
      });
    }

    return {
      refId: query.refId,
      labelMatchers
    };
  }

  async getSeries(selector, withName) {
    if (this.datasource.lookupsDisabled) {
      return {};
    }

    try {
      if (selector === EMPTY_SELECTOR) {
        return await this.fetchDefaultSeries();
      } else {
        return await this.fetchSeriesLabels(selector, withName);
      }
    } catch (error) {
      // TODO: better error handling
      console.error(error);
      return {};
    }
  }

  async getLabelValues(key) {
    return await this.fetchLabelValues(key);
  }
  /**
   * Fetches all label keys
   */


  async fetchLabels() {
    const url = '/api/v1/labels';
    const params = this.datasource.getTimeRangeParams();
    this.labelFetchTs = Date.now().valueOf();
    const res = await this.request(url, [], params);

    if (Array.isArray(res)) {
      this.labelKeys = res.slice().sort();
    }

    return [];
  }
  /**
   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as
   * they can change over requested time.
   * @param name
   * @param withName
   */


}

function getNameLabelValue(promQuery, tokens) {
  let nameLabelValue = '';

  for (let prop in tokens) {
    if (typeof tokens[prop] === 'string') {
      nameLabelValue = tokens[prop];
      break;
    }
  }

  return nameLabelValue;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLimitInfo": () => (/* binding */ addLimitInfo),
/* harmony export */   "escapeLabelValueInExactSelector": () => (/* binding */ escapeLabelValueInExactSelector),
/* harmony export */   "escapeLabelValueInRegexSelector": () => (/* binding */ escapeLabelValueInRegexSelector),
/* harmony export */   "expandRecordingRules": () => (/* binding */ expandRecordingRules),
/* harmony export */   "extractLabelMatchers": () => (/* binding */ extractLabelMatchers),
/* harmony export */   "fixSummariesMetadata": () => (/* binding */ fixSummariesMetadata),
/* harmony export */   "labelRegexp": () => (/* binding */ labelRegexp),
/* harmony export */   "limitSuggestions": () => (/* binding */ limitSuggestions),
/* harmony export */   "parseSelector": () => (/* binding */ parseSelector),
/* harmony export */   "processHistogramMetrics": () => (/* binding */ processHistogramMetrics),
/* harmony export */   "processLabels": () => (/* binding */ processLabels),
/* harmony export */   "roundMsToMin": () => (/* binding */ roundMsToMin),
/* harmony export */   "roundSecToMin": () => (/* binding */ roundSecToMin),
/* harmony export */   "selectorRegexp": () => (/* binding */ selectorRegexp),
/* harmony export */   "toPromLikeExpr": () => (/* binding */ toPromLikeExpr),
/* harmony export */   "toPromLikeQuery": () => (/* binding */ toPromLikeQuery)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.28.0-28f20a79ff-bde93fb2be.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/add_label_to_query.ts");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
const _excluded = ["__name__"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const processHistogramMetrics = metrics => {
  const resultSet = new Set();
  const regexp = new RegExp('_bucket($|:)');

  for (let index = 0; index < metrics.length; index++) {
    const metric = metrics[index];
    const isHistogramValue = regexp.test(metric);

    if (isHistogramValue) {
      resultSet.add(metric);
    }
  }

  return [...resultSet];
};
function processLabels(labels, withName = false) {
  // For processing we are going to use sets as they have significantly better performance than arrays
  // After we process labels, we will convert sets to arrays and return object with label values in arrays
  const valueSet = {};
  labels.forEach(label => {
    const {
      __name__
    } = label,
          rest = _objectWithoutPropertiesLoose(label, _excluded);

    if (withName) {
      valueSet['__name__'] = valueSet['__name__'] || new Set();

      if (!valueSet['__name__'].has(__name__)) {
        valueSet['__name__'].add(__name__);
      }
    }

    Object.keys(rest).forEach(key => {
      if (!valueSet[key]) {
        valueSet[key] = new Set();
      }

      if (!valueSet[key].has(rest[key])) {
        valueSet[key].add(rest[key]);
      }
    });
  }); // valueArray that we are going to return in the object

  const valueArray = {};
  limitSuggestions(Object.keys(valueSet)).forEach(key => {
    valueArray[key] = limitSuggestions(Array.from(valueSet[key]));
  });
  return {
    values: valueArray,
    keys: Object.keys(valueArray)
  };
} // const cleanSelectorRegexp = /\{(\w+="[^"\n]*?")(,\w+="[^"\n]*?")*\}/;

const selectorRegexp = /\{[^}]*?(\}|$)/;
const labelRegexp = /\b(\w+)(!?=~?)("[^"\n]*?")/g;
function parseSelector(query, cursorOffset = 1) {
  if (!query.match(selectorRegexp)) {
    // Special matcher for metrics
    if (query.match(/^[A-Za-z:][\w:]*$/)) {
      return {
        selector: `{__name__="${query}"}`,
        labelKeys: ['__name__']
      };
    }

    throw new Error('Query must contain a selector: ' + query);
  } // Check if inside a selector


  const prefix = query.slice(0, cursorOffset);
  const prefixOpen = prefix.lastIndexOf('{');
  const prefixClose = prefix.lastIndexOf('}');

  if (prefixOpen === -1) {
    throw new Error('Not inside selector, missing open brace: ' + prefix);
  }

  if (prefixClose > -1 && prefixClose > prefixOpen) {
    throw new Error('Not inside selector, previous selector already closed: ' + prefix);
  }

  const suffix = query.slice(cursorOffset);
  const suffixCloseIndex = suffix.indexOf('}');
  const suffixClose = suffixCloseIndex + cursorOffset;
  const suffixOpenIndex = suffix.indexOf('{');
  const suffixOpen = suffixOpenIndex + cursorOffset;

  if (suffixClose === -1) {
    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);
  }

  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {
    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);
  } // Extract clean labels to form clean selector, incomplete labels are dropped


  const selector = query.slice(prefixOpen, suffixClose);
  const labels = {};
  selector.replace(labelRegexp, (label, key, operator, value) => {
    const labelOffset = query.indexOf(label);
    const valueStart = labelOffset + key.length + operator.length + 1;
    const valueEnd = labelOffset + key.length + operator.length + value.length - 1; // Skip label if cursor is in value

    if (cursorOffset < valueStart || cursorOffset > valueEnd) {
      labels[key] = {
        value,
        operator
      };
    }

    return '';
  }); // Add metric if there is one before the selector

  const metricPrefix = query.slice(0, prefixOpen);
  const metricMatch = metricPrefix.match(/[A-Za-z:][\w:]*$/);

  if (metricMatch) {
    labels['__name__'] = {
      value: `"${metricMatch[0]}"`,
      operator: '='
    };
  } // Build sorted selector


  const labelKeys = Object.keys(labels).sort();
  const cleanSelector = labelKeys.map(key => `${key}${labels[key].operator}${labels[key].value}`).join(',');
  const selectorString = ['{', cleanSelector, '}'].join('');
  return {
    labelKeys,
    selector: selectorString
  };
}
function expandRecordingRules(query, mapping) {
  const ruleNames = Object.keys(mapping);
  const rulesRegex = new RegExp(`(\\s|^)(${ruleNames.join('|')})(\\s|$|\\(|\\[|\\{)`, 'ig');
  const expandedQuery = query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`); // Split query into array, so if query uses operators, we can correctly add labels to each individual part.

  const queryArray = expandedQuery.split(/(\+|\-|\*|\/|\%|\^)/); // Regex that matches occurrences of ){ or }{ or ]{ which is a sign of incorrecly added labels.

  const invalidLabelsRegex = /(\)\{|\}\{|\]\{)/;
  const correctlyExpandedQueryArray = queryArray.map(query => {
    return addLabelsToExpression(query, invalidLabelsRegex);
  });
  return correctlyExpandedQueryArray.join('');
}

function addLabelsToExpression(expr, invalidLabelsRegexp) {
  var _match$index;

  const match = expr.match(invalidLabelsRegexp);

  if (!match) {
    return expr;
  } // Split query into 2 parts - before the invalidLabelsRegex match and after.


  const indexOfRegexMatch = (_match$index = match.index) !== null && _match$index !== void 0 ? _match$index : 0;
  const exprBeforeRegexMatch = expr.slice(0, indexOfRegexMatch + 1);
  const exprAfterRegexMatch = expr.slice(indexOfRegexMatch + 1); // Create arrayOfLabelObjects with label objects that have key, operator and value.

  const arrayOfLabelObjects = [];
  exprAfterRegexMatch.replace(labelRegexp, (label, key, operator, value) => {
    arrayOfLabelObjects.push({
      key,
      operator,
      value
    });
    return '';
  }); // Loop through all label objects and add them to query.
  // As a starting point we have valid query without the labels.

  let result = exprBeforeRegexMatch;
  arrayOfLabelObjects.filter(Boolean).forEach(obj => {
    // Remove extra set of quotes from obj.value
    const value = obj.value.slice(1, -1);
    result = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_3__.addLabelToQuery)(result, obj.key, value, obj.operator);
  });
  return result;
}
/**
 * Adds metadata for synthetic metrics for which the API does not provide metadata.
 * See https://github.com/grafana/grafana/issues/22337 for details.
 *
 * @param metadata HELP and TYPE metadata from /api/v1/metadata
 */


function fixSummariesMetadata(metadata) {
  if (!metadata) {
    return metadata;
  }

  const baseMetadata = {};
  const summaryMetadata = {};

  for (const metric in metadata) {
    // NOTE: based on prometheus-documentation, we can receive
    // multiple metadata-entries for the given metric, it seems
    // it happens when the same metric is on multiple targets
    // and their help-text differs
    // (https://prometheus.io/docs/prometheus/latest/querying/api/#querying-metric-metadata)
    // for now we just use the first entry.
    const item = metadata[metric][0];
    baseMetadata[metric] = item;

    if (item.type === 'histogram') {
      summaryMetadata[`${metric}_bucket`] = {
        type: 'counter',
        help: `Cumulative counters for the observation buckets (${item.help})`
      };
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the histogram metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the histogram metric (${item.help})`
      };
    }

    if (item.type === 'summary') {
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the base metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the base metric (${item.help})`
      };
    }
  } // Synthetic series


  const syntheticMetadata = {};
  syntheticMetadata['ALERTS'] = {
    type: 'counter',
    help: 'Time series showing pending and firing alerts. The sample value is set to 1 as long as the alert is in the indicated active (pending or firing) state.'
  };
  return Object.assign({}, baseMetadata, summaryMetadata, syntheticMetadata);
}
function roundMsToMin(milliseconds) {
  return roundSecToMin(milliseconds / 1000);
}
function roundSecToMin(seconds) {
  return Math.floor(seconds / 60);
}
function limitSuggestions(items) {
  return items.slice(0, _language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT);
}
function addLimitInfo(items) {
  return items && items.length >= _language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT ? `, limited to the first ${_language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT} received items` : '';
} // NOTE: the following 2 exported functions are very similar to the prometheus*Escape
// functions in datasource.ts, but they are not exactly the same algorithm, and we found
// no way to reuse one in the another or vice versa.
// Prometheus regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),
// so every character that matches something in that list has to be escaped.
// the list of metacharacters is: *+?()|\.[]{}^$
// we make a javascript regular expression that matches those characters:

const RE2_METACHARACTERS = /[*+?()|\\.\[\]{}^$]/g;

function escapePrometheusRegexp(value) {
  return value.replace(RE2_METACHARACTERS, '\\$&');
} // based on the openmetrics-documentation, the 3 symbols we have to handle are:
// - \n ... the newline character
// - \  ... the backslash character
// - "  ... the double-quote character


function escapeLabelValueInExactSelector(labelValue) {
  return labelValue.replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/"/g, '\\"');
}
function escapeLabelValueInRegexSelector(labelValue) {
  return escapeLabelValueInExactSelector(escapePrometheusRegexp(labelValue));
}
const FromPromLikeMap = {
  '=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.Equal,
  '!=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqual,
  '=~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.EqualRegEx,
  '!~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqualRegEx
};
const ToPromLikeMap = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.invert)(FromPromLikeMap);
function toPromLikeExpr(labelBasedQuery) {
  const expr = labelBasedQuery.labelMatchers.map(selector => {
    const operator = ToPromLikeMap[selector.operator];

    if (operator) {
      return `${selector.name}${operator}"${selector.value}"`;
    } else {
      return '';
    }
  }).filter(e => e !== '').join(', ');
  return expr ? `{${expr}}` : '';
}
function toPromLikeQuery(labelBasedQuery) {
  return {
    refId: labelBasedQuery.refId,
    expr: toPromLikeExpr(labelBasedQuery),
    range: true
  };
}
function extractLabelMatchers(tokens) {
  const labelMatchers = [];

  for (let prop in tokens) {
    if (tokens[prop] instanceof prismjs__WEBPACK_IMPORTED_MODULE_1__.Token) {
      let token = tokens[prop];

      if (token.type === 'context-labels') {
        let labelKey = '';
        let labelValue = '';
        let labelOperator = '';
        let contentTokens = token.content;

        for (let currentToken in contentTokens) {
          if (typeof contentTokens[currentToken] === 'string') {
            let currentStr;
            currentStr = contentTokens[currentToken];

            if (currentStr === '=' || currentStr === '!=' || currentStr === '=~' || currentStr === '!~') {
              labelOperator = currentStr;
            }
          } else if (contentTokens[currentToken] instanceof prismjs__WEBPACK_IMPORTED_MODULE_1__.Token) {
            switch (contentTokens[currentToken].type) {
              case 'label-key':
                labelKey = contentTokens[currentToken].content;
                break;

              case 'label-value':
                labelValue = contentTokens[currentToken].content;
                labelValue = labelValue.substring(1, labelValue.length - 1);
                const labelComparator = FromPromLikeMap[labelOperator];

                if (labelComparator) {
                  labelMatchers.push({
                    name: labelKey,
                    operator: labelComparator,
                    value: labelValue
                  });
                }

                break;
            }
          }
        }
      }
    }
  }

  return labelMatchers;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/promql.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FUNCTIONS": () => (/* binding */ FUNCTIONS),
/* harmony export */   "LOGICAL_OPERATORS": () => (/* binding */ LOGICAL_OPERATORS),
/* harmony export */   "OPERATORS": () => (/* binding */ OPERATORS),
/* harmony export */   "PROM_KEYWORDS": () => (/* binding */ PROM_KEYWORDS),
/* harmony export */   "RATE_RANGES": () => (/* binding */ RATE_RANGES),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "promqlGrammar": () => (/* binding */ promqlGrammar)
/* harmony export */ });
// When changing RATE_RANGES, check if Loki/LogQL ranges should be changed too
// @see public/app/plugins/datasource/loki/language_provider.ts
const RATE_RANGES = [{
  label: '$__interval',
  sortValue: '$__interval'
}, {
  label: '$__rate_interval',
  sortValue: '$__rate_interval'
}, {
  label: '$__range',
  sortValue: '$__range'
}, {
  label: '1m',
  sortValue: '00:01:00'
}, {
  label: '5m',
  sortValue: '00:05:00'
}, {
  label: '10m',
  sortValue: '00:10:00'
}, {
  label: '30m',
  sortValue: '00:30:00'
}, {
  label: '1h',
  sortValue: '01:00:00'
}, {
  label: '1d',
  sortValue: '24:00:00'
}];
const OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];
const LOGICAL_OPERATORS = ['or', 'and', 'unless'];
const TRIGONOMETRIC_FUNCTIONS = [{
  label: 'acos',
  insertText: 'acos',
  detail: 'acos(v instant-vector)',
  documentation: 'calculates the arccosine of all elements in v'
}, {
  label: 'acosh',
  insertText: 'acosh',
  detail: 'acosh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic cosine of all elements in v'
}, {
  label: 'asin',
  insertText: 'asin',
  detail: 'asin(v instant-vector)',
  documentation: 'calculates the arcsine of all elements in v'
}, {
  label: 'asinh',
  insertText: 'asinh',
  detail: 'asinh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic sine of all elements in v'
}, {
  label: 'atan',
  insertText: 'atan',
  detail: 'atan(v instant-vector)',
  documentation: 'calculates the arctangent of all elements in v'
}, {
  label: 'atanh',
  insertText: 'atanh',
  detail: 'atanh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic tangent of all elements in v'
}, {
  label: 'cos',
  insertText: 'cos',
  detail: 'cos(v instant-vector)',
  documentation: 'calculates the cosine of all elements in v'
}, {
  label: 'cosh',
  insertText: 'cosh',
  detail: 'cosh(v instant-vector)',
  documentation: 'calculates the hyperbolic cosine of all elements in v'
}, {
  label: 'sin',
  insertText: 'sin',
  detail: 'sin(v instant-vector)',
  documentation: 'calculates the sine of all elements in v'
}, {
  label: 'sinh',
  insertText: 'sinh',
  detail: 'sinh(v instant-vector)',
  documentation: 'calculates the hyperbolic sine of all elements in v'
}, {
  label: 'tan',
  insertText: 'tan',
  detail: 'tan(v instant-vector)',
  documentation: 'calculates the tangent of all elements in v'
}, {
  label: 'tanh',
  insertText: 'tanh',
  detail: 'tanh(v instant-vector)',
  documentation: 'calculates the hyperbolic tangent of all elements in v'
}];
const AGGREGATION_OPERATORS = [{
  label: 'sum',
  insertText: 'sum',
  documentation: 'Calculate sum over dimensions'
}, {
  label: 'min',
  insertText: 'min',
  documentation: 'Select minimum over dimensions'
}, {
  label: 'max',
  insertText: 'max',
  documentation: 'Select maximum over dimensions'
}, {
  label: 'avg',
  insertText: 'avg',
  documentation: 'Calculate the average over dimensions'
}, {
  label: 'group',
  insertText: 'group',
  documentation: 'All values in the resulting vector are 1'
}, {
  label: 'stddev',
  insertText: 'stddev',
  documentation: 'Calculate population standard deviation over dimensions'
}, {
  label: 'stdvar',
  insertText: 'stdvar',
  documentation: 'Calculate population standard variance over dimensions'
}, {
  label: 'count',
  insertText: 'count',
  documentation: 'Count number of elements in the vector'
}, {
  label: 'count_values',
  insertText: 'count_values',
  documentation: 'Count number of elements with the same value'
}, {
  label: 'bottomk',
  insertText: 'bottomk',
  documentation: 'Smallest k elements by sample value'
}, {
  label: 'topk',
  insertText: 'topk',
  documentation: 'Largest k elements by sample value'
}, {
  label: 'quantile',
  insertText: 'quantile',
  documentation: 'Calculate Ï†-quantile (0 â‰¤ Ï† â‰¤ 1) over dimensions'
}];
const FUNCTIONS = [...AGGREGATION_OPERATORS, ...TRIGONOMETRIC_FUNCTIONS, {
  insertText: 'abs',
  label: 'abs',
  detail: 'abs(v instant-vector)',
  documentation: 'Returns the input vector with all sample values converted to their absolute value.'
}, {
  insertText: 'absent',
  label: 'absent',
  detail: 'absent(v instant-vector)',
  documentation: 'Returns an empty vector if the vector passed to it has any elements and a 1-element vector with the value 1 if the vector passed to it has no elements. This is useful for alerting on when no time series exist for a given metric name and label combination.'
}, {
  insertText: 'absent_over_time',
  label: 'absent_over_time',
  detail: 'absent(v range-vector)',
  documentation: 'Returns an empty vector if the range vector passed to it has any elements and a 1-element vector with the value 1 if the range vector passed to it has no elements.'
}, {
  insertText: 'ceil',
  label: 'ceil',
  detail: 'ceil(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` up to the nearest integer.'
}, {
  insertText: 'changes',
  label: 'changes',
  detail: 'changes(v range-vector)',
  documentation: 'For each input time series, `changes(v range-vector)` returns the number of times its value has changed within the provided time range as an instant vector.'
}, {
  insertText: 'clamp',
  label: 'clamp',
  detail: 'clamp(v instant-vector, min scalar, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min` and an upper limit of `max`.'
}, {
  insertText: 'clamp_max',
  label: 'clamp_max',
  detail: 'clamp_max(v instant-vector, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have an upper limit of `max`.'
}, {
  insertText: 'clamp_min',
  label: 'clamp_min',
  detail: 'clamp_min(v instant-vector, min scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min`.'
}, {
  insertText: 'count_scalar',
  label: 'count_scalar',
  detail: 'count_scalar(v instant-vector)',
  documentation: 'Returns the number of elements in a time series vector as a scalar. This is in contrast to the `count()` aggregation operator, which always returns a vector (an empty one if the input vector is empty) and allows grouping by labels via a `by` clause.'
}, {
  insertText: 'deg',
  label: 'deg',
  detail: 'deg(v instant-vector)',
  documentation: 'Converts radians to degrees for all elements in v'
}, {
  insertText: 'day_of_month',
  label: 'day_of_month',
  detail: 'day_of_month(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the month for each of the given times in UTC. Returned values are from 1 to 31.'
}, {
  insertText: 'day_of_week',
  label: 'day_of_week',
  detail: 'day_of_week(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the week for each of the given times in UTC. Returned values are from 0 to 6, where 0 means Sunday etc.'
}, {
  insertText: 'days_in_month',
  label: 'days_in_month',
  detail: 'days_in_month(v=vector(time()) instant-vector)',
  documentation: 'Returns number of days in the month for each of the given times in UTC. Returned values are from 28 to 31.'
}, {
  insertText: 'delta',
  label: 'delta',
  detail: 'delta(v range-vector)',
  documentation: 'Calculates the difference between the first and last value of each time series element in a range vector `v`, returning an instant vector with the given deltas and equivalent labels. The delta is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if the sample values are all integers.'
}, {
  insertText: 'deriv',
  label: 'deriv',
  detail: 'deriv(v range-vector)',
  documentation: 'Calculates the per-second derivative of the time series in a range vector `v`, using simple linear regression.'
}, {
  insertText: 'drop_common_labels',
  label: 'drop_common_labels',
  detail: 'drop_common_labels(instant-vector)',
  documentation: 'Drops all labels that have the same name and value across all series in the input vector.'
}, {
  insertText: 'exp',
  label: 'exp',
  detail: 'exp(v instant-vector)',
  documentation: 'Calculates the exponential function for all elements in `v`.\nSpecial cases are:\n* `Exp(+Inf) = +Inf` \n* `Exp(NaN) = NaN`'
}, {
  insertText: 'floor',
  label: 'floor',
  detail: 'floor(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` down to the nearest integer.'
}, {
  insertText: 'histogram_quantile',
  label: 'histogram_quantile',
  detail: 'histogram_quantile(Ï† float, b instant-vector)',
  documentation: 'Calculates the Ï†-quantile (0 â‰¤ Ï† â‰¤ 1) from the buckets `b` of a histogram. The samples in `b` are the counts of observations in each bucket. Each sample must have a label `le` where the label value denotes the inclusive upper bound of the bucket. (Samples without such a label are silently ignored.) The histogram metric type automatically provides time series with the `_bucket` suffix and the appropriate labels.'
}, {
  insertText: 'holt_winters',
  label: 'holt_winters',
  detail: 'holt_winters(v range-vector, sf scalar, tf scalar)',
  documentation: 'Produces a smoothed value for time series based on the range in `v`. The lower the smoothing factor `sf`, the more importance is given to old data. The higher the trend factor `tf`, the more trends in the data is considered. Both `sf` and `tf` must be between 0 and 1.'
}, {
  insertText: 'hour',
  label: 'hour',
  detail: 'hour(v=vector(time()) instant-vector)',
  documentation: 'Returns the hour of the day for each of the given times in UTC. Returned values are from 0 to 23.'
}, {
  insertText: 'idelta',
  label: 'idelta',
  detail: 'idelta(v range-vector)',
  documentation: 'Calculates the difference between the last two samples in the range vector `v`, returning an instant vector with the given deltas and equivalent labels.'
}, {
  insertText: 'increase',
  label: 'increase',
  detail: 'increase(v range-vector)',
  documentation: 'Calculates the increase in the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. The increase is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if a counter increases only by integer increments.'
}, {
  insertText: 'irate',
  label: 'irate',
  detail: 'irate(v range-vector)',
  documentation: 'Calculates the per-second instant rate of increase of the time series in the range vector. This is based on the last two data points. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for.'
}, {
  insertText: 'label_join',
  label: 'label_join',
  detail: 'label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)',
  documentation: 'For each timeseries in `v`, joins all the values of all the `src_labels` using `separator` and returns the timeseries with the label `dst_label` containing the joined value. There can be any number of `src_labels` in this function.'
}, {
  insertText: 'label_replace',
  label: 'label_replace',
  detail: 'label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)',
  documentation: "For each timeseries in `v`, `label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`  matches the regular expression `regex` against the label `src_label`.  If it matches, then the timeseries is returned with the label `dst_label` replaced by the expansion of `replacement`. `$1` is replaced with the first matching subgroup, `$2` with the second etc. If the regular expression doesn't match then the timeseries is returned unchanged."
}, {
  insertText: 'ln',
  label: 'ln',
  detail: 'ln(v instant-vector)',
  documentation: 'Calculates the natural logarithm for all elements in `v`.\nSpecial cases are:\n * `ln(+Inf) = +Inf`\n * `ln(0) = -Inf`\n * `ln(x < 0) = NaN`\n * `ln(NaN) = NaN`'
}, {
  insertText: 'log2',
  label: 'log2',
  detail: 'log2(v instant-vector)',
  documentation: 'Calculates the binary logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'log10',
  label: 'log10',
  detail: 'log10(v instant-vector)',
  documentation: 'Calculates the decimal logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'minute',
  label: 'minute',
  detail: 'minute(v=vector(time()) instant-vector)',
  documentation: 'Returns the minute of the hour for each of the given times in UTC. Returned values are from 0 to 59.'
}, {
  insertText: 'month',
  label: 'month',
  detail: 'month(v=vector(time()) instant-vector)',
  documentation: 'Returns the month of the year for each of the given times in UTC. Returned values are from 1 to 12, where 1 means January etc.'
}, {
  insertText: 'pi',
  label: 'pi',
  detail: 'pi()',
  documentation: 'Returns pi'
}, {
  insertText: 'predict_linear',
  label: 'predict_linear',
  detail: 'predict_linear(v range-vector, t scalar)',
  documentation: 'Predicts the value of time series `t` seconds from now, based on the range vector `v`, using simple linear regression.'
}, {
  insertText: 'rad',
  label: 'rad',
  detail: 'rad(v instant-vector)',
  documentation: 'Converts degrees to radians for all elements in v'
}, {
  insertText: 'rate',
  label: 'rate',
  detail: 'rate(v range-vector)',
  documentation: "Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period."
}, {
  insertText: 'resets',
  label: 'resets',
  detail: 'resets(v range-vector)',
  documentation: 'For each input time series, `resets(v range-vector)` returns the number of counter resets within the provided time range as an instant vector. Any decrease in the value between two consecutive samples is interpreted as a counter reset.'
}, {
  insertText: 'round',
  label: 'round',
  detail: 'round(v instant-vector, to_nearest=1 scalar)',
  documentation: 'Rounds the sample values of all elements in `v` to the nearest integer. Ties are resolved by rounding up. The optional `to_nearest` argument allows specifying the nearest multiple to which the sample values should be rounded. This multiple may also be a fraction.'
}, {
  insertText: 'scalar',
  label: 'scalar',
  detail: 'scalar(v instant-vector)',
  documentation: 'Given a single-element input vector, `scalar(v instant-vector)` returns the sample value of that single element as a scalar. If the input vector does not have exactly one element, `scalar` will return `NaN`.'
}, {
  insertText: 'sgn',
  label: 'sgn',
  detail: 'sgn(v instant-vector)',
  documentation: 'Returns a vector with all sample values converted to their sign, defined as this: 1 if v is positive, -1 if v is negative and 0 if v is equal to zero.'
}, {
  insertText: 'sort',
  label: 'sort',
  detail: 'sort(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in ascending order.'
}, {
  insertText: 'sort_desc',
  label: 'sort_desc',
  detail: 'sort_desc(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in descending order.'
}, {
  insertText: 'sqrt',
  label: 'sqrt',
  detail: 'sqrt(v instant-vector)',
  documentation: 'Calculates the square root of all elements in `v`.'
}, {
  insertText: 'time',
  label: 'time',
  detail: 'time()',
  documentation: 'Returns the number of seconds since January 1, 1970 UTC. Note that this does not actually return the current time, but the time at which the expression is to be evaluated.'
}, {
  insertText: 'timestamp',
  label: 'timestamp',
  detail: 'timestamp(v instant-vector)',
  documentation: 'Returns the timestamp of each of the samples of the given vector as the number of seconds since January 1, 1970 UTC.'
}, {
  insertText: 'vector',
  label: 'vector',
  detail: 'vector(s scalar)',
  documentation: 'Returns the scalar `s` as a vector with no labels.'
}, {
  insertText: 'year',
  label: 'year',
  detail: 'year(v=vector(time()) instant-vector)',
  documentation: 'Returns the year for each of the given times in UTC.'
}, {
  insertText: 'avg_over_time',
  label: 'avg_over_time',
  detail: 'avg_over_time(range-vector)',
  documentation: 'The average value of all points in the specified interval.'
}, {
  insertText: 'min_over_time',
  label: 'min_over_time',
  detail: 'min_over_time(range-vector)',
  documentation: 'The minimum value of all points in the specified interval.'
}, {
  insertText: 'max_over_time',
  label: 'max_over_time',
  detail: 'max_over_time(range-vector)',
  documentation: 'The maximum value of all points in the specified interval.'
}, {
  insertText: 'sum_over_time',
  label: 'sum_over_time',
  detail: 'sum_over_time(range-vector)',
  documentation: 'The sum of all values in the specified interval.'
}, {
  insertText: 'count_over_time',
  label: 'count_over_time',
  detail: 'count_over_time(range-vector)',
  documentation: 'The count of all values in the specified interval.'
}, {
  insertText: 'quantile_over_time',
  label: 'quantile_over_time',
  detail: 'quantile_over_time(scalar, range-vector)',
  documentation: 'The Ï†-quantile (0 â‰¤ Ï† â‰¤ 1) of the values in the specified interval.'
}, {
  insertText: 'stddev_over_time',
  label: 'stddev_over_time',
  detail: 'stddev_over_time(range-vector)',
  documentation: 'The population standard deviation of the values in the specified interval.'
}, {
  insertText: 'stdvar_over_time',
  label: 'stdvar_over_time',
  detail: 'stdvar_over_time(range-vector)',
  documentation: 'The population standard variance of the values in the specified interval.'
}, {
  insertText: 'last_over_time',
  label: 'last_over_time',
  detail: 'last_over_time(range-vector)',
  documentation: 'The most recent point value in specified interval.'
}];
const PROM_KEYWORDS = FUNCTIONS.map(keyword => keyword.label);
const promqlGrammar = {
  comment: {
    pattern: /#.*/
  },
  'context-aggregation': {
    pattern: /((by|without)\s*)\([^)]*\)/,
    // by ()
    lookbehind: true,
    inside: {
      'label-key': {
        pattern: /[^(),\s][^,)]*[^),\s]*/,
        alias: 'attr-name'
      },
      punctuation: /[()]/
    }
  },
  'context-labels': {
    pattern: /\{[^}]*(?=}?)/,
    greedy: true,
    inside: {
      comment: {
        pattern: /#.*/
      },
      'label-key': {
        pattern: /[a-z_]\w*(?=\s*(=|!=|=~|!~))/,
        alias: 'attr-name',
        greedy: true
      },
      'label-value': {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: true,
        alias: 'attr-value'
      },
      punctuation: /[{]/
    }
  },
  function: new RegExp(`\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\s*\\()`, 'i'),
  'context-range': [{
    pattern: /\[[^\]]*(?=])/,
    // [1m]
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }, {
    pattern: /(offset\s+)\w+/,
    // offset 1m
    lookbehind: true,
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }],
  idList: {
    pattern: /\d+(\|\d+)+/,
    alias: 'number'
  },
  number: /\b-?\d+((\.\d*)?([eE][+-]?\d+)?)?\b/,
  operator: new RegExp(`/[-+*/=%^~]|&&?|\\|?\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:${OPERATORS.join('|')})\\b`, 'i'),
  punctuation: /[{};()`,.]/
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (promqlGrammar);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryModeller": () => (/* binding */ PromQueryModeller),
/* harmony export */   "promQueryModeller": () => (/* binding */ promQueryModeller)
/* harmony export */ });
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
/* harmony import */ var _aggregations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts");
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");





class PromQueryModeller extends _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__.LokiAndPromQueryModellerBase {
  constructor() {
    super(() => {
      const allOperations = [...(0,_operations__WEBPACK_IMPORTED_MODULE_2__.getOperationDefinitions)(), ...(0,_aggregations__WEBPACK_IMPORTED_MODULE_1__.getAggregationOperations)()];

      for (const op of allOperations) {
        const func = _promql__WEBPACK_IMPORTED_MODULE_0__.FUNCTIONS.find(x => x.insertText === op.id);

        if (func) {
          op.documentation = func.documentation;
        }
      }

      return allOperations;
    });
    this.setOperationCategories([_types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Aggregations, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.RangeFunctions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Functions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.BinaryOps, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Trigonometric, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Time]);
  }

  getQueryPatterns() {
    return [{
      name: 'Rate then sum',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: 'sum',
        params: []
      }]
    }, {
      name: 'Rate then sum by(label) then avg',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['']
      }, {
        id: 'avg',
        params: []
      }]
    }, {
      name: 'Histogram quantile on rate',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }, {
      name: 'Histogram quantile on increase ',
      operations: [{
        id: 'increase',
        params: ['$__rate_interval']
      }, {
        id: '__max_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }];
  }

}
const promQueryModeller = new PromQueryModeller();

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAggregationOperations": () => (/* binding */ getAggregationOperations)
/* harmony export */ });
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");



function getAggregationOperations() {
  return [...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sum), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Avg), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Min), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Max), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Count), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.TopK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.BottomK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountValues, {
    params: [{
      name: 'Identifier',
      type: 'string'
    }],
    defaultParams: ['count']
  }), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.SumOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AvgOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MinOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MaxOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.LastOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.PresentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AbsentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.StddevOverTime)];
}

function createAggregationOverTime(name) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)()],
    defaultParams: ['$__interval'],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: _operations__WEBPACK_IMPORTED_MODULE_0__.addOperationWithRangeVector
  };
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '$__interval';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "binaryScalarDefs": () => (/* binding */ binaryScalarDefs),
/* harmony export */   "binaryScalarOperations": () => (/* binding */ binaryScalarOperations),
/* harmony export */   "binaryScalarOperatorToOperatorName": () => (/* binding */ binaryScalarOperatorToOperatorName)
/* harmony export */ });
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");


const binaryScalarDefs = [{
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Addition,
  name: 'Add scalar',
  sign: '+'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Subtraction,
  name: 'Subtract scalar',
  sign: '-'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.MultiplyBy,
  name: 'Multiply by scalar',
  sign: '*'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.DivideBy,
  name: 'Divide by scalar',
  sign: '/'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Modulo,
  name: 'Modulo by scalar',
  sign: '%'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Exponent,
  name: 'Exponent',
  sign: '^'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.EqualTo,
  name: 'Equal to',
  sign: '==',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.NotEqualTo,
  name: 'Not equal to',
  sign: '!=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.GreaterThan,
  name: 'Greater than',
  sign: '>',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.LessThan,
  name: 'Less than',
  sign: '<',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.GreaterOrEqual,
  name: 'Greater or equal to',
  sign: '>=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.LessOrEqual,
  name: 'Less or equal to',
  sign: '<=',
  comparison: true
}];
const binaryScalarOperatorToOperatorName = binaryScalarDefs.reduce((acc, def) => {
  acc[def.sign] = {
    id: def.id,
    comparison: def.comparison
  };
  return acc;
}, {}); // Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies
// both the operator and the operand in a single input

const binaryScalarOperations = binaryScalarDefs.map(opDef => {
  const params = [{
    name: 'Value',
    type: 'number'
  }];
  const defaultParams = [2];

  if (opDef.comparison) {
    params.push({
      name: 'Bool',
      type: 'boolean',
      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.'
    });
    defaultParams.push(false);
  }

  return {
    id: opDef.id,
    name: opDef.name,
    params,
    defaultParams,
    alternativesKey: 'binary scalar operations',
    category: _types__WEBPACK_IMPORTED_MODULE_1__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: getSimpleBinaryRenderer(opDef.sign),
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.defaultAddOperationHandler
  };
});

function getSimpleBinaryRenderer(operator) {
  return function binaryRenderer(model, def, innerExpr) {
    let param = model.params[0];
    let bool = '';

    if (model.params.length === 2) {
      bool = model.params[1] ? ' bool' : '';
    }

    return `${innerExpr} ${operator}${bool} ${param}`;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelParamEditor": () => (/* binding */ LabelParamEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function LabelParamEditor({
  onChange,
  index,
  operationIndex,
  value,
  query,
  datasource
}) {
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
    inputId: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(operationIndex, index),
    autoFocus: value === '' ? true : undefined,
    openMenuOnFocus: true,
    onOpenMenu: async () => {
      setState({
        isLoading: true
      });
      const options = await loadGroupByLabels(query, datasource);
      setState({
        options,
        isLoading: undefined
      });
    },
    isLoading: state.isLoading,
    allowCustomValue: true,
    noOptionsMessage: "No labels found",
    loadingMessage: "Loading labels",
    options: state.options,
    value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(value),
    onChange: value => onChange(index, value.value)
  });
}

async function loadGroupByLabels(query, datasource) {
  let labels = query.labels; // This function is used by both Prometheus and Loki and this the only difference.

  if (datasource.type === 'prometheus') {
    labels = [{
      label: '__name__',
      op: '=',
      value: query.metric
    }, ...query.labels];
  }

  const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderLabels(labels);
  const result = await datasource.languageProvider.fetchSeriesLabels(expr);
  return Object.keys(result).map(x => ({
    label: x,
    value: x
  }));
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/operations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addOperationWithRangeVector": () => (/* binding */ addOperationWithRangeVector),
/* harmony export */   "createFunction": () => (/* binding */ createFunction),
/* harmony export */   "createRangeFunction": () => (/* binding */ createRangeFunction),
/* harmony export */   "getOperationDefinitions": () => (/* binding */ getOperationDefinitions),
/* harmony export */   "operationWithRangeVectorRenderer": () => (/* binding */ operationWithRangeVectorRenderer)
/* harmony export */ });
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");




function getOperationDefinitions() {
  const list = [{
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.HistogramQuantile,
    name: 'Histogram quantile',
    params: [{
      name: 'Quantile',
      type: 'number',
      options: [0.99, 0.95, 0.9, 0.75, 0.5, 0.25]
    }],
    defaultParams: [0.9],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.LabelReplace,
    name: 'Label replace',
    params: [{
      name: 'Destination label',
      type: 'string'
    }, {
      name: 'Replacement',
      type: 'string'
    }, {
      name: 'Source label',
      type: 'string'
    }, {
      name: 'Regex',
      type: 'string'
    }],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    defaultParams: ['', '$1', '', '(.*)'],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererRight,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Ln,
    name: 'Ln',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Changes), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Rate, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Irate), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Increase, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Idelta), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Delta), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.HoltWinters,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Smoothing Factor',
      type: 'number'
    }, {
      name: 'Trend Factor',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5, 0.5],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.PredictLinear,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Seconds from now',
      type: 'number'
    }],
    defaultParams: ['$__interval', 60],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.QuantileOverTime,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Quantile',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererLeftWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), ..._binaryScalarOperations__WEBPACK_IMPORTED_MODULE_0__.binaryScalarOperations, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.NestedQuery,
    name: 'Binary operation with query',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: (model, def, innerExpr) => innerExpr,
    addOperationHandler: addNestedQueryHandler
  }, createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Absent
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Acos,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Acosh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Asin,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Asinh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Atan,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Atanh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Ceil
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Clamp,
    name: 'Clamp',
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }, {
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1, 1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.ClampMax,
    params: [{
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.ClampMin,
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Cos,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Cosh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DayOfMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DayOfWeek,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DaysInMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Deg
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Deriv), //
  createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Exp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Floor
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Group
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Hour
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.LabelJoin,
    params: [{
      name: 'Destination Label',
      type: 'string',
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }, {
      name: 'Separator',
      type: 'string'
    }, {
      name: 'Source Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }],
    defaultParams: ['', ',', ''],
    renderer: labelJoinRenderer,
    addOperationHandler: labelJoinAddOperationHandler
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Log10
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Log2
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Minute
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Month
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Pi,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Quantile,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Rad
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Resets), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Round,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    params: [{
      name: 'To Nearest',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Scalar
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sgn
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sin,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sinh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sort
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.SortDesc
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sqrt
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Stddev
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Tan,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Tanh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Time,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Timestamp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Vector,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: model => `${model.id}(${model.params[0]})`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Year
  })];
  return list;
}
function createFunction(definition) {
  var _definition$name, _definition$params, _definition$defaultPa, _definition$category, _definition$renderer, _definition$addOperat;

  return Object.assign({}, definition, {
    id: definition.id,
    name: (_definition$name = definition.name) !== null && _definition$name !== void 0 ? _definition$name : (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getPromAndLokiOperationDisplayName)(definition.id),
    params: (_definition$params = definition.params) !== null && _definition$params !== void 0 ? _definition$params : [],
    defaultParams: (_definition$defaultPa = definition.defaultParams) !== null && _definition$defaultPa !== void 0 ? _definition$defaultPa : [],
    category: (_definition$category = definition.category) !== null && _definition$category !== void 0 ? _definition$category : _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: (_definition$renderer = definition.renderer) !== null && _definition$renderer !== void 0 ? _definition$renderer : definition.params ? _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererRight : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: (_definition$addOperat = definition.addOperationHandler) !== null && _definition$addOperat !== void 0 ? _definition$addOperat : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  });
}
function createRangeFunction(name, withRateInterval = false) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(withRateInterval)],
    defaultParams: [withRateInterval ? '$__rate_interval' : '$__interval'],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  };
}

function operationTypeChangedHandlerForRangeFunction(operation, newDef) {
  // validate current parameter
  if (operation.params[0] === '$__rate_interval' && newDef.defaultParams[0] !== '$__rate_interval') {
    operation.params = newDef.defaultParams;
  } else if (operation.params[0] === '$__interval' && newDef.defaultParams[0] !== '$__interval') {
    operation.params = newDef.defaultParams;
  }

  return operation;
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}
/**
 * Since there can only be one operation with range vector this will replace the current one (if one was added )
 */

function addOperationWithRangeVector(def, query, modeller) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };

  if (query.operations.length > 0) {
    // If operation exists it has to be in the registry so no point to check if it was found
    const firstOp = modeller.getOperationDef(query.operations[0].id);

    if (firstOp.addOperationHandler === addOperationWithRangeVector) {
      return Object.assign({}, query, {
        operations: [newOperation, ...query.operations.slice(1)]
      });
    }
  }

  return Object.assign({}, query, {
    operations: [newOperation, ...query.operations]
  });
}

function addNestedQueryHandler(def, query) {
  var _query$binaryQueries;

  return Object.assign({}, query, {
    binaryQueries: [...((_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : []), {
      operator: '/',
      query
    }]
  });
}

function labelJoinRenderer(model, def, innerExpr) {
  if (typeof model.params[1] !== 'string') {
    throw 'The separator must be a string';
  }

  const separator = `"${model.params[1]}"`;
  return `${model.id}(${innerExpr}, "${model.params[0]}", ${separator}, "${model.params.slice(2).join(separator)}")`;
}

function labelJoinAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildVisualQueryFromString": () => (/* binding */ buildVisualQueryFromString),
/* harmony export */   "handleExpression": () => (/* binding */ handleExpression)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts");




/**
 * Parses a PromQL query into a visual query model.
 *
 * It traverses the tree and uses sort of state machine to update the query model. The query model is modified
 * during the traversal and sent to each handler as context.
 *
 * @param expr
 */
function buildVisualQueryFromString(expr) {
  const replacedExpr = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.replaceVariables)(expr);
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(replacedExpr);
  const node = tree.topNode; // This will be modified in the handlers.

  const visQuery = {
    metric: '',
    labels: [],
    operations: []
  };
  const context = {
    query: visQuery,
    errors: []
  };

  try {
    handleExpression(replacedExpr, node, context);
  } catch (err) {
    // Not ideal to log it here, but otherwise we would lose the stack trace.
    console.error(err);

    if (err instanceof Error) {
      context.errors.push({
        text: err.message
      });
    }
  } // If we have empty query, we want to reset errors


  if (isEmptyQuery(context.query)) {
    context.errors = [];
  }

  return context;
}

/**
 * Handler for default state. It will traverse the tree and call the appropriate handler for each node. The node
 * handled here does not necessarily need to be of type == Expr.
 * @param expr
 * @param node
 * @param context
 */
function handleExpression(expr, node, context) {
  const visQuery = context.query;

  switch (node.name) {
    case 'MetricIdentifier':
      {
        // Expectation is that there is only one of those per query.
        visQuery.metric = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node);
        break;
      }

    case 'LabelMatcher':
      {
        // Same as MetricIdentifier should be just one per query.
        visQuery.labels.push(getLabel(expr, node));
        const err = node.getChild(_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName);

        if (err) {
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, err));
        }

        break;
      }

    case 'FunctionCall':
      {
        handleFunction(expr, node, context);
        break;
      }

    case 'AggregateExpr':
      {
        handleAggregation(expr, node, context);
        break;
      }

    case 'BinaryExpr':
      {
        handleBinary(expr, node, context);
        break;
      }

    case _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName:
      {
        if (isIntervalVariableError(node)) {
          break;
        }

        context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        break;
      }

    default:
      {
        if (node.name === 'ParenExpr') {
          // We don't support parenthesis in the query to group expressions. We just report error but go on with the
          // parsing.
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        } // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper
        // nodes that can be skipped.
        // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to
        //  detect those and report back.


        let child = node.firstChild;

        while (child) {
          handleExpression(expr, child, context);
          child = child.nextSibling;
        }
      }
  }
}

function isIntervalVariableError(node) {
  var _node$prevSibling, _node$prevSibling2, _node$prevSibling2$fi;

  return ((_node$prevSibling = node.prevSibling) === null || _node$prevSibling === void 0 ? void 0 : _node$prevSibling.name) === 'Expr' && ((_node$prevSibling2 = node.prevSibling) === null || _node$prevSibling2 === void 0 ? void 0 : (_node$prevSibling2$fi = _node$prevSibling2.firstChild) === null || _node$prevSibling2$fi === void 0 ? void 0 : _node$prevSibling2$fi.name) === 'VectorSelector';
}

function getLabel(expr, node) {
  const label = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('LabelName'));
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('MatchOp'));
  const value = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('StringLiteral')).replace(/"/g, '');
  return {
    label,
    op,
    value
  };
}

const rangeFunctions = ['changes', 'rate', 'irate', 'increase', 'delta'];
/**
 * Handle function call which is usually and identifier and its body > arguments.
 * @param expr
 * @param node
 * @param context
 */

function handleFunction(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('FunctionIdentifier');
  const funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const params = [];
  let interval = ''; // This is a bit of a shortcut to get the interval argument. Reasons are
  // - interval is not part of the function args per promQL grammar but we model it as argument for the function in
  //   the query model.
  // - it is easier to handle template variables this way as template variable is an error for the parser

  if (rangeFunctions.includes(funcName) || funcName.endsWith('_over_time')) {
    let match = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).match(/\[(.+)\]/);

    if (match !== null && match !== void 0 && match[1]) {
      interval = match[1];
      params.push(match[1]);
    }
  }

  const op = {
    id: funcName,
    params
  }; // We unshift operations to keep the more natural order that we want to have in the visual query editor.

  visQuery.operations.unshift(op);

  if (callArgs) {
    if ((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, callArgs) === interval + ']') {
      // This is a special case where we have a function with a single argument and it is the interval.
      // This happens when you start adding operations in query builder and did not set a metric yet.
      return;
    }

    updateFunctionArgs(expr, callArgs, context, op);
  }
}
/**
 * Handle aggregation as they are distinct type from other functions.
 * @param expr
 * @param node
 * @param context
 */


function handleAggregation(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('AggregateOp');
  let funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const modifier = node.getChild('AggregateModifier');
  const labels = [];

  if (modifier) {
    const byModifier = modifier.getChild(`By`);

    if (byModifier && funcName) {
      funcName = `__${funcName}_by`;
    }

    const withoutModifier = modifier.getChild(`Without`);

    if (withoutModifier) {
      funcName = `__${funcName}_without`;
    }

    labels.push(...(0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getAllByType)(expr, modifier, 'GroupingLabel'));
  }

  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const op = {
    id: funcName,
    params: []
  };
  visQuery.operations.unshift(op);
  updateFunctionArgs(expr, callArgs, context, op); // We add labels after params in the visual query editor.

  op.params.push(...labels);
}
/**
 * Handle (probably) all types of arguments that function or aggregation can have.
 *
 *  FunctionCallArgs are nested bit weirdly basically its [firstArg, ...rest] where rest is again FunctionCallArgs so
 *  we cannot just get all the children and iterate them as arguments we have to again recursively traverse through
 *  them.
 *
 * @param expr
 * @param node
 * @param context
 * @param op - We need the operation to add the params to as an additional context.
 */


function updateFunctionArgs(expr, node, context, op) {
  if (!node) {
    return;
  }

  switch (node.name) {
    // In case we have an expression we don't know what kind so we have to look at the child as it can be anything.
    case 'Expr': // FunctionCallArgs are nested bit weirdly as mentioned so we have to go one deeper in this case.

    case 'FunctionCallArgs':
      {
        let child = node.firstChild;

        while (child) {
          updateFunctionArgs(expr, child, context, op);
          child = child.nextSibling;
        }

        break;
      }

    case 'NumberLiteral':
      {
        op.params.push(parseFloat((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node)));
        break;
      }

    case 'StringLiteral':
      {
        op.params.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).replace(/"/g, ''));
        break;
      }

    default:
      {
        // Means we get to something that does not seem like simple function arg and is probably nested query so jump
        // back to main context
        handleExpression(expr, node, context);
      }
  }
}
/**
 * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is
 * just operation with scalar or it creates a binaryQuery when it's 2 queries.
 * @param expr
 * @param node
 * @param context
 */


function handleBinary(expr, node, context) {
  const visQuery = context.query;
  const left = node.firstChild;
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, left.nextSibling);
  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));
  const right = node.lastChild;
  const opDef = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__.binaryScalarOperatorToOperatorName[op];
  const leftNumber = left.getChild('NumberLiteral');
  const rightNumber = right.getChild('NumberLiteral');
  const rightBinary = right.getChild('BinaryExpr');

  if (leftNumber) {// TODO: this should be already handled in case parent is binary expression as it has to be added to parent
    //  if query starts with a number that isn't handled now.
  } else {
    // If this is binary we don't really know if there is a query or just chained scalars. So
    // we have to traverse a bit deeper to know
    handleExpression(expr, left, context);
  }

  if (rightNumber) {
    visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, right, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
  } else if (rightBinary) {
    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which
    // is a factor for a current binary operation. So we have to add it as an operation now.
    const leftMostChild = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getLeftMostChild)(right);

    if ((leftMostChild === null || leftMostChild === void 0 ? void 0 : leftMostChild.name) === 'NumberLiteral') {
      visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, leftMostChild, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
    } // If we added the first number literal as operation here we still can continue and handle the rest as the first
    // number will be just skipped.


    handleExpression(expr, right, context);
  } else {
    visQuery.binaryQueries = visQuery.binaryQueries || [];
    const binQuery = {
      operator: op,
      query: {
        metric: '',
        labels: [],
        operations: []
      }
    };

    if (binModifier !== null && binModifier !== void 0 && binModifier.isMatcher) {
      binQuery.vectorMatchesType = binModifier.matchType;
      binQuery.vectorMatches = binModifier.matches;
    }

    visQuery.binaryQueries.push(binQuery);
    handleExpression(expr, right, {
      query: binQuery.query,
      errors: context.errors
    });
  }
}

function getBinaryModifier(expr, node) {
  if (!node) {
    return undefined;
  }

  if (node.getChild('Bool')) {
    return {
      isBool: true,
      isMatcher: false
    };
  } else {
    var _matcher$getChild;

    const matcher = node.getChild('OnOrIgnoring');

    if (!matcher) {
      // Not sure what this could be, maybe should be an error.
      return undefined;
    }

    const labels = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, (_matcher$getChild = matcher.getChild('GroupingLabels')) === null || _matcher$getChild === void 0 ? void 0 : _matcher$getChild.getChild('GroupingLabelList'));
    return {
      isMatcher: true,
      isBool: false,
      matches: labels,
      matchType: matcher.getChild('On') ? 'on' : 'ignoring'
    };
  }
}

function isEmptyQuery(query) {
  if (query.labels.length === 0 && query.operations.length === 0 && !query.metric) {
    return true;
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/FeedbackLink.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FeedbackLink": () => (/* binding */ FeedbackLink)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Icon;








function FeedbackLink({
  feedbackUrl
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);

  if (!_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.feedbackLinksEnabled) {
    return null;
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 1,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("a", {
      href: feedbackUrl,
      className: styles.link,
      title: "This query builder is new, please let us know how we can improve it",
      target: "_blank",
      rel: "noreferrer noopener",
      onClick: () => (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.reportInteraction)('grafana_feedback_link_clicked', {
        link: feedbackUrl
      }),
      children: [_Icon || (_Icon = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Icon, {
        name: "comment-alt-message"
      })), " Give feedback"]
    })
  });
}

function getStyles(theme) {
  return {
    link: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      fontSize: theme.typography.bodySmall.fontSize,
      ':hover': {
        color: theme.colors.text.link
      }
    })
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilterItem": () => (/* binding */ LabelFilterItem)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function LabelFilterItem({
  item,
  defaultOp,
  onChange,
  onDelete,
  onGetLabelNames,
  onGetLabelValues
}) {
  var _item$op2;

  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});

  const isMultiSelect = () => {
    return item.op === operators[0].label;
  };

  const getSelectOptionsFromString = item => {
    if (item) {
      if (item.indexOf('|') > 0) {
        return item.split('|');
      }

      return [item];
    }

    return [];
  };

  const getOptions = () => {
    const labelValues = state.labelValues ? [...state.labelValues] : [];
    const selectedOptions = getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption); // Remove possible duplicated values

    return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.uniqBy)([...selectedOptions, ...labelValues], 'value');
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
    "data-testid": "prometheus-dimensions-filter-item",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.InputGroup, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
        inputId: "prometheus-dimensions-filter-item-key",
        width: "auto",
        value: item.label ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)(item.label) : null,
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelNames: true
          });
          const labelNames = await onGetLabelNames(item);
          setState({
            labelNames,
            isLoadingLabelNames: undefined
          });
        },
        isLoading: state.isLoadingLabelNames,
        options: state.labelNames,
        onChange: change => {
          if (change.label) {
            var _item$op;

            onChange(Object.assign({}, item, {
              op: (_item$op = item.op) !== null && _item$op !== void 0 ? _item$op : defaultOp,
              label: change.label
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)((_item$op2 = item.op) !== null && _item$op2 !== void 0 ? _item$op2 : defaultOp),
        options: operators,
        width: "auto",
        onChange: change => {
          if (change.value != null) {
            onChange(Object.assign({}, item, {
              op: change.value
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
        inputId: "prometheus-dimensions-filter-item-value",
        width: "auto",
        value: isMultiSelect() ? getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption) : getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)[0],
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelValues: true
          });
          const labelValues = await onGetLabelValues(item);
          setState(Object.assign({}, state, {
            labelValues,
            isLoadingLabelValues: undefined
          }));
        },
        isMulti: isMultiSelect(),
        isLoading: state.isLoadingLabelValues,
        options: getOptions(),
        onChange: change => {
          if (change.value) {
            var _item$op3;

            onChange(Object.assign({}, item, {
              value: change.value,
              op: (_item$op3 = item.op) !== null && _item$op3 !== void 0 ? _item$op3 : defaultOp
            }));
          } else {
            var _item$op4;

            const changes = change.map(change => {
              return change.label;
            }).join('|');
            onChange(Object.assign({}, item, {
              value: changes,
              op: (_item$op4 = item.op) !== null && _item$op4 !== void 0 ? _item$op4 : defaultOp
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.AccessoryButton, {
        "aria-label": "remove",
        icon: "times",
        variant: "secondary",
        onClick: onDelete
      })]
    })
  });
}
const operators = [{
  label: '=~',
  value: '=~'
}, {
  label: '=',
  value: '='
}, {
  label: '!=',
  value: '!='
}, {
  label: '!~',
  value: '!~'
}];

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilters": () => (/* binding */ LabelFilters)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function LabelFilters({
  labelsFilters,
  onChange,
  onGetLabelNames,
  onGetLabelValues,
  error
}) {
  const defaultOp = '=';
  const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([{
    op: defaultOp
  }]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (labelsFilters.length > 0) {
      setItems(labelsFilters);
    } else {
      setItems([{
        op: defaultOp
      }]);
    }
  }, [labelsFilters]);

  const onLabelsChange = newItems => {
    setItems(newItems); // Extract full label filters with both label & value

    const newLabels = newItems.filter(x => x.label != null && x.value != null);

    if (!(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(newLabels, labelsFilters)) {
      onChange(newLabels);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorFieldGroup, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
      label: "Labels",
      error: error,
      invalid: !!error,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorList, {
        items: items,
        onChange: onLabelsChange,
        renderItem: (item, onChangeItem, onDelete) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__.LabelFilterItem, {
          item: item,
          defaultOp: defaultOp,
          onChange: onChangeItem,
          onDelete: onDelete,
          onGetLabelNames: onGetLabelNames,
          onGetLabelValues: onGetLabelValues
        })
      })
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiAndPromQueryModellerBase": () => (/* binding */ LokiAndPromQueryModellerBase)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class LokiAndPromQueryModellerBase {
  constructor(getOperations) {
    _defineProperty(this, "operationsRegisty", void 0);

    _defineProperty(this, "categories", []);

    this.operationsRegisty = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.Registry(getOperations);
  }

  setOperationCategories(categories) {
    this.categories = categories;
  }

  getOperationsForCategory(category) {
    return this.operationsRegisty.list().filter(op => op.category === category && !op.hideFromList);
  }

  getAlternativeOperations(key) {
    return this.operationsRegisty.list().filter(op => op.alternativesKey === key);
  }

  getCategories() {
    return this.categories;
  }

  getOperationDef(id) {
    return this.operationsRegisty.getIfExists(id);
  }

  renderOperations(queryString, operations) {
    for (const operation of operations) {
      const def = this.operationsRegisty.getIfExists(operation.id);

      if (!def) {
        throw new Error(`Could not find operation ${operation.id} in the registry`);
      }

      queryString = def.renderer(operation, def, queryString);
    }

    return queryString;
  }

  renderBinaryQueries(queryString, binaryQueries) {
    if (binaryQueries) {
      for (const binQuery of binaryQueries) {
        queryString = `${this.renderBinaryQuery(queryString, binQuery)}`;
      }
    }

    return queryString;
  }

  renderBinaryQuery(leftOperand, binaryQuery) {
    let result = leftOperand + ` ${binaryQuery.operator} `;

    if (binaryQuery.vectorMatches) {
      result += `${binaryQuery.vectorMatchesType}(${binaryQuery.vectorMatches}) `;
    }

    return result + this.renderQuery(binaryQuery.query, true);
  }

  renderLabels(labels) {
    if (labels.length === 0) {
      return '';
    }

    let expr = '{';

    for (const filter of labels) {
      if (expr !== '{') {
        expr += ', ';
      }

      expr += `${filter.label}${filter.op}"${filter.value}"`;
    }

    return expr + `}`;
  }

  renderQuery(query, nested) {
    var _query$metric, _query$binaryQueries, _query$binaryQueries2;

    let queryString = `${(_query$metric = query.metric) !== null && _query$metric !== void 0 ? _query$metric : ''}${this.renderLabels(query.labels)}`;
    queryString = this.renderOperations(queryString, query.operations);

    if (!nested && this.hasBinaryOp(query) && Boolean((_query$binaryQueries = query.binaryQueries) === null || _query$binaryQueries === void 0 ? void 0 : _query$binaryQueries.length)) {
      queryString = `(${queryString})`;
    }

    queryString = this.renderBinaryQueries(queryString, query.binaryQueries);

    if (nested && (this.hasBinaryOp(query) || Boolean((_query$binaryQueries2 = query.binaryQueries) === null || _query$binaryQueries2 === void 0 ? void 0 : _query$binaryQueries2.length))) {
      queryString = `(${queryString})`;
    }

    return queryString;
  }

  hasBinaryOp(query) {
    return query.operations.find(op => {
      const def = this.getOperationDef(op.id);
      return (def === null || def === void 0 ? void 0 : def.category) === _types__WEBPACK_IMPORTED_MODULE_1__.PromVisualQueryOperationCategory.BinaryOps;
    }) !== undefined;
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationEditor": () => (/* binding */ OperationEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationHeader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx");
/* harmony import */ var _OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










function OperationEditor({
  operation,
  index,
  onRemove,
  onChange,
  onRunQuery,
  queryModeller,
  query,
  datasource,
  highlight
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const def = queryModeller.getOperationDef(operation.id);
  const shouldHighlight = useHighlight(highlight);

  if (!def) {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("span", {
      children: ["Operation ", operation.id, " not found"]
    });
  }

  const onParamValueChanged = (paramIdx, value) => {
    const update = Object.assign({}, operation, {
      params: [...operation.params]
    });
    update.params[paramIdx] = value;
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const onAddRestParam = () => {
    const update = Object.assign({}, operation, {
      params: [...operation.params, '']
    });
    callParamChangedThenOnChange(def, update, index, operation.params.length, onChange);
  };

  const onRemoveRestParam = paramIdx => {
    const update = Object.assign({}, operation, {
      params: [...operation.params.slice(0, paramIdx), ...operation.params.slice(paramIdx + 1)]
    });
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const operationElements = [];

  for (let paramIndex = 0; paramIndex < operation.params.length; paramIndex++) {
    const paramDef = def.params[Math.min(def.params.length - 1, paramIndex)];
    const Editor = (0,_OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__.getOperationParamEditor)(paramDef);
    operationElements.push( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
      className: styles.paramRow,
      children: [!paramDef.hideName && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.paramName,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("label", {
          htmlFor: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_6__.getOperationParamId)(index, paramIndex),
          children: paramDef.name
        }), paramDef.description && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Tooltip, {
          placement: "top",
          content: paramDef.description,
          theme: "info",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
            name: "info-circle",
            size: "sm",
            className: styles.infoIcon
          })
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.paramValue,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
          gap: 0.5,
          direction: "row",
          alignItems: "center",
          wrap: false,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(Editor, {
            index: paramIndex,
            paramDef: paramDef,
            value: operation.params[paramIndex],
            operation: operation,
            operationIndex: index,
            onChange: onParamValueChanged,
            onRunQuery: onRunQuery,
            query: query,
            datasource: datasource
          }), paramDef.restParam && (operation.params.length > def.params.length || paramDef.optional) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            "data-testid": `operations.${index}.remove-rest-param`,
            size: "sm",
            fill: "text",
            icon: "times",
            variant: "secondary",
            title: `Remove ${paramDef.name}`,
            onClick: () => onRemoveRestParam(paramIndex)
          })]
        })
      })]
    }, `${paramIndex}-1`));
  } // Handle adding button for rest params


  let restParam;

  if (def.params.length > 0) {
    const lastParamDef = def.params[def.params.length - 1];

    if (lastParamDef.restParam) {
      restParam = renderAddRestParamButton(lastParamDef, onAddRestParam, index, operation.params.length, styles);
    }
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__.Draggable, {
    draggableId: `operation-${index}`,
    index: index,
    children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", Object.assign({
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.card, shouldHighlight && styles.cardHighlight),
      ref: provided.innerRef
    }, provided.draggableProps, {
      "data-testid": `operations.${index}.wrapper`,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_OperationHeader__WEBPACK_IMPORTED_MODULE_4__.OperationHeader, {
        operation: operation,
        dragHandleProps: provided.dragHandleProps,
        def: def,
        index: index,
        onChange: onChange,
        onRemove: onRemove,
        queryModeller: queryModeller
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.body,
        children: operationElements
      }), restParam, index < query.operations.length - 1 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.arrow,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowLine
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowArrow
        })]
      })]
    }))
  });
}
/**
 * When highlight is switched on makes sure it is switched of right away, so we just flash the highlight and then fade
 * out.
 * @param highlight
 */

function useHighlight(highlight) {
  const [keepHighlight, setKeepHighlight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    let t;

    if (highlight) {
      t = setTimeout(() => {
        setKeepHighlight(false);
      }, 1);
    } else {
      setKeepHighlight(true);
    }

    return () => clearTimeout(t);
  }, [highlight]);
  return keepHighlight && highlight;
}

function renderAddRestParamButton(paramDef, onAddRestParam, operationIndex, paramIndex, styles) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
    className: styles.restParam,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
      size: "sm",
      icon: "plus",
      title: `Add ${paramDef.name}`,
      variant: "secondary",
      onClick: onAddRestParam,
      "data-testid": `operations.${operationIndex}.add-rest-param`,
      children: paramDef.name
    })
  }, `${paramIndex}-2`);
}

function callParamChangedThenOnChange(def, operation, operationIndex, paramIndex, onChange) {
  if (def.paramChangedHandler) {
    onChange(operationIndex, def.paramChangedHandler(paramIndex, operation, def));
  } else {
    onChange(operationIndex, operation);
  }
}

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.medium}`,
      display: 'flex',
      flexDirection: 'column',
      cursor: 'grab',
      borderRadius: theme.shape.borderRadius(1),
      marginBottom: theme.spacing(1),
      position: 'relative',
      transition: 'all 1s ease-in 0s'
    }),
    cardHighlight: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      boxShadow: `0px 0px 4px 0px ${theme.colors.primary.border}`,
      border: `1px solid ${theme.colors.primary.border}`
    }),
    infoIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(0.5),
      color: theme.colors.text.secondary,
      ':hover': {
        color: theme.colors.text.primary
      }
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      margin: theme.spacing(1, 1, 0.5, 1),
      display: 'table'
    }),
    paramRow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramRow',
      display: 'table-row',
      verticalAlign: 'middle'
    }),
    paramName: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'table-cell',
      padding: theme.spacing(0, 1, 0, 0),
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      verticalAlign: 'middle',
      height: '32px'
    }),
    paramValue: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramValue',
      display: 'table-cell',
      verticalAlign: 'middle'
    }),
    restParam: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(0, 1, 1, 1)
    }),
    arrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      position: 'absolute',
      top: '0',
      right: '-18px',
      display: 'flex'
    }),
    arrowLine: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      height: '2px',
      width: '8px',
      backgroundColor: theme.colors.border.strong,
      position: 'relative',
      top: '14px'
    }),
    arrowArrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      width: 0,
      height: 0,
      borderTop: `5px solid transparent`,
      borderBottom: `5px solid transparent`,
      borderLeft: `7px solid ${theme.colors.border.strong}`,
      position: 'relative',
      top: '10px'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationExplainedBox": () => (/* binding */ OperationExplainedBox)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function OperationExplainedBox({
  title,
  stepNumber,
  markdown,
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
    className: styles.box,
    children: [stepNumber !== undefined && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.stepNumber,
      children: stepNumber
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.boxInner,
      children: [title && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.header,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: title
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.body,
        children: [markdown && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          dangerouslySetInnerHTML: {
            __html: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.renderMarkdown)(markdown)
          }
        }), children]
      })]
    })]
  });
}

const getStyles = theme => {
  return {
    box: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.secondary,
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      position: 'relative'
    }),
    boxInner: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(4)
    }),
    stepNumber: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontWeight: theme.typography.fontWeightMedium,
      background: theme.colors.secondary.main,
      width: '20px',
      height: '20px',
      borderRadius: '50%',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'absolute',
      top: '10px',
      left: '11px',
      fontSize: theme.typography.bodySmall.fontSize
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingBottom: theme.spacing(0.5),
      display: 'flex',
      alignItems: 'center',
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      'p:last-child': {
        margin: 0
      },
      a: {
        color: theme.colors.text.link,
        textDecoration: 'underline'
      }
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationHeader": () => (/* binding */ OperationHeader)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;









const OperationHeader = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  operation,
  def,
  index,
  onChange,
  onRemove,
  queryModeller,
  dragHandleProps
}) => {
  var _def$name;

  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});

  const onToggleSwitcher = () => {
    if (state.isOpen) {
      setState(Object.assign({}, state, {
        isOpen: false
      }));
    } else {
      const alternatives = queryModeller.getAlternativeOperations(def.alternativesKey).map(alt => ({
        label: alt.name,
        value: alt
      }));
      setState({
        isOpen: true,
        alternatives
      });
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: styles.header,
    children: [!state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", Object.assign({}, dragHandleProps, {
        children: (_def$name = def.name) !== null && _def$name !== void 0 ? _def$name : def.id
      })), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: `${styles.operationHeaderButtons} operation-header-show-on-hover`,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: "angle-down",
          size: "sm",
          onClick: onToggleSwitcher,
          fill: "text",
          variant: "secondary",
          title: "Click to view alternative operations"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__.OperationInfoButton, {
          def: def,
          operation: operation
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: "times",
          size: "sm",
          onClick: () => onRemove(index),
          fill: "text",
          variant: "secondary",
          title: "Remove operation"
        })]
      })]
    }), state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: styles.selectWrapper,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        autoFocus: true,
        openMenuOnFocus: true,
        placeholder: "Replace with",
        options: state.alternatives,
        isOpen: true,
        onCloseMenu: onToggleSwitcher,
        onChange: value => {
          if (value.value) {
            // Operation should exist if it is selectable
            const newDef = queryModeller.getOperationDef(value.value.id);
            let changedOp = Object.assign({}, operation, {
              id: value.value.id
            });
            onChange(index, def.changeTypeHandler ? def.changeTypeHandler(changedOp, newDef) : changedOp);
          }
        }
      })
    })]
  });
});
OperationHeader.displayName = 'OperationHeader';

const getStyles = theme => {
  return {
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      borderBottom: `1px solid ${theme.colors.border.medium}`,
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      display: 'flex',
      alignItems: 'center',
      '&:hover .operation-header-show-on-hover': (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
        opacity: 1
      })
    }),
    operationHeaderButtons: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      transition: theme.transitions.create(['opacity'], {
        duration: theme.transitions.duration.short
      })
    }),
    selectWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingRight: theme.spacing(2)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationInfoButton": () => (/* binding */ OperationInfoButton)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-popper-tooltip-virtual-ff0da4b2fd/0/cache/react-popper-tooltip-npm-4.4.1-2214480dbc-58dacdf9bc.zip/node_modules/react-popper-tooltip/dist/esm/react-popper-tooltip.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;










const OperationInfoButton = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  def,
  operation
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  const [show, setShow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const {
    getTooltipProps,
    setTooltipRef,
    setTriggerRef,
    visible
  } = (0,react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__.usePopperTooltip)({
    placement: 'top',
    visible: show,
    offset: [0, 16],
    onVisibleChange: setShow,
    interactive: true,
    trigger: ['click']
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
      title: "Click to show description",
      ref: setTriggerRef,
      icon: "info-circle",
      size: "sm",
      variant: "secondary",
      fill: "text"
    }), visible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Portal, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
        ref: setTooltipRef
      }, getTooltipProps(), {
        className: styles.docBox,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: styles.docBoxHeader,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
            children: def.renderer(operation, def, '<expr>')
          }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.FlexItem, {
            grow: 1
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
            icon: "times",
            onClick: () => setShow(false),
            fill: "text",
            variant: "secondary",
            title: "Remove operation"
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: styles.docBoxBody,
          dangerouslySetInnerHTML: {
            __html: getOperationDocs(def, operation)
          }
        })]
      }))
    })]
  });
});
OperationInfoButton.displayName = 'OperationDocs';

const getStyles = theme => {
  return {
    docBox: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      overflow: 'hidden',
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.strong}`,
      boxShadow: theme.shadows.z3,
      maxWidth: '600px',
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      zIndex: theme.zIndex.tooltip
    }),
    docBoxHeader: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.h5.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace,
      paddingBottom: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    docBoxBody: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      // The markdown paragraph has a marginBottom this removes it
      marginBottom: theme.spacing(-1),
      color: theme.colors.text.secondary
    }),
    signature: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.bodySmall.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    dropdown: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      color: theme.colors.text.secondary
    })
  };
};

function getOperationDocs(def, op) {
  var _def$documentation;

  return (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.renderMarkdown)(def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs');
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationList": () => (/* binding */ OperationList)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useMountedState.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









function OperationList({
  query,
  datasource,
  queryModeller,
  onChange,
  onRunQuery
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const {
    operations
  } = query;
  const opsToHighlight = useOperationsHighlight(operations);
  const [cascaderOpen, setCascaderOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);

  const onOperationChange = (index, update) => {
    const updatedList = [...operations];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...operations.slice(0, index), ...operations.slice(index + 1)];
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const addOptions = queryModeller.getCategories().map(category => {
    return {
      value: category,
      label: category,
      items: queryModeller.getOperationsForCategory(category).map(operation => ({
        value: operation.id,
        label: operation.name,
        isLeaf: true
      }))
    };
  });

  const onAddOperation = value => {
    const operationDef = queryModeller.getOperationDef(value);

    if (!operationDef) {
      return;
    }

    onChange(operationDef.addOperationHandler(operationDef, query, queryModeller));
    setCascaderOpen(false);
  };

  const onDragEnd = result => {
    if (!result.destination) {
      return;
    }

    const updatedList = [...operations];
    const element = updatedList[result.source.index];
    updatedList.splice(result.source.index, 1);
    updatedList.splice(result.destination.index, 0, element);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onCascaderBlur = () => {
    setCascaderOpen(false);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 1,
    direction: "column",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
      gap: 1,
      children: [operations.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.DragDropContext, {
        onDragEnd: onDragEnd,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Droppable, {
          droppableId: "sortable-field-mappings",
          direction: "horizontal",
          children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
            className: styles.operationList,
            ref: provided.innerRef
          }, provided.droppableProps, {
            children: [operations.map((op, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationEditor__WEBPACK_IMPORTED_MODULE_4__.OperationEditor, {
              queryModeller: queryModeller,
              index: index,
              operation: op,
              query: query,
              datasource: datasource,
              onChange: onOperationChange,
              onRemove: onRemove,
              onRunQuery: onRunQuery,
              highlight: opsToHighlight[index]
            }, op.id + index)), provided.placeholder]
          }))
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: styles.addButton,
        children: cascaderOpen ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Cascader, {
          options: addOptions,
          onSelect: onAddOperation,
          onBlur: onCascaderBlur,
          autoFocus: true,
          alwaysOpen: true,
          hideActiveLevelLabel: true,
          placeholder: 'Search'
        }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: 'plus',
          variant: 'secondary',
          onClick: () => setCascaderOpen(true),
          title: 'Add operation',
          children: "Operations"
        })
      })]
    })
  });
}
/**
 * Returns indexes of operations that should be highlighted. We check the diff of operations added but at the same time
 * we want to highlight operations only after the initial render, so we check for mounted state and calculate the diff
 * only after.
 * @param operations
 */

function useOperationsHighlight(operations) {
  const isMounted = (0,react_use__WEBPACK_IMPORTED_MODULE_7__["default"])();
  const prevOperations = (0,react_use__WEBPACK_IMPORTED_MODULE_8__["default"])(operations);

  if (!isMounted()) {
    return operations.map(() => false);
  }

  if (!prevOperations) {
    return operations.map(() => true);
  }

  let newOps = [];

  if (prevOperations.length - 1 === operations.length && operations.every(op => prevOperations.includes(op))) {
    // In case we remove one op and does not change any ops then don't highlight anything.
    return operations.map(() => false);
  }

  if (prevOperations.length + 1 === operations.length && prevOperations.every(op => operations.includes(op))) {
    // If we add a single op just find it and highlight just that.
    const newOp = operations.find(op => !prevOperations.includes(op));
    newOps = operations.map(op => {
      return op === newOp;
    });
  } else {
    // Default diff of all ops.
    newOps = operations.map((op, index) => {
      var _prevOperations$index;

      return !isSameOp(op.id, (_prevOperations$index = prevOperations[index]) === null || _prevOperations$index === void 0 ? void 0 : _prevOperations$index.id);
    });
  }

  return newOps;
}

function isSameOp(op1, op2) {
  return op1 === op2 || `__${op1}_by` === op2 || op1 === `__${op2}_by`;
}

const getStyles = theme => {
  return {
    heading: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'heading',
      fontSize: 12,
      fontWeight: theme.typography.fontWeightMedium,
      marginBottom: 0
    }),
    operationList: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'operationList',
      display: 'flex',
      flexWrap: 'wrap',
      gap: theme.spacing(2)
    }),
    addButton: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'addButton',
      width: 126,
      paddingBottom: theme.spacing(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationListExplained": () => (/* binding */ OperationListExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var _RawQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/RawQuery.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function OperationListExplained({
  query,
  queryModeller,
  stepNumber,
  lang
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {
    children: query.operations.map((op, index) => {
      var _def$documentation;

      const def = queryModeller.getOperationDef(op.id);

      if (!def) {
        return `Operation ${op.id} not found`;
      }

      const title = def.renderer(op, def, '<expr>');
      const body = def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs';
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__.OperationExplainedBox, {
        stepNumber: index + stepNumber,
        title: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_RawQuery__WEBPACK_IMPORTED_MODULE_2__.RawQuery, {
          query: title,
          lang: lang
        }),
        markdown: body
      }, index);
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOperationParamEditor": () => (/* binding */ getOperationParamEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function getOperationParamEditor(paramDef) {
  if (paramDef.editor) {
    return paramDef.editor;
  }

  if (paramDef.options) {
    return SelectInputParamEditor;
  }

  switch (paramDef.type) {
    case 'boolean':
      return BoolInputParamEditor;

    case 'number':
    case 'string':
    default:
      return SimpleInputParamEditor;
  }
}

function SimpleInputParamEditor(props) {
  var _props$value;

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.AutoSizeInput, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_3__.getOperationParamId)(props.operationIndex, props.index),
    defaultValue: (_props$value = props.value) === null || _props$value === void 0 ? void 0 : _props$value.toString(),
    minWidth: props.paramDef.minWidth,
    placeholder: props.paramDef.placeholder,
    title: props.paramDef.description,
    onCommitChange: evt => {
      props.onChange(props.index, evt.currentTarget.value);

      if (props.paramDef.runQueryOnEnter && evt.type === 'keydown') {
        props.onRunQuery();
      }
    }
  });
}

function BoolInputParamEditor(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Checkbox, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_3__.getOperationParamId)(props.operationIndex, props.index),
    value: props.value,
    onChange: evt => props.onChange(props.index, evt.currentTarget.checked)
  });
}

function SelectInputParamEditor({
  paramDef,
  value,
  index,
  operationIndex,
  onChange
}) {
  var _selectOptions$, _selectOptions$find;

  let selectOptions = paramDef.options;

  if (!((_selectOptions$ = selectOptions[0]) !== null && _selectOptions$ !== void 0 && _selectOptions$.label)) {
    selectOptions = paramDef.options.map(option => ({
      label: option.toString(),
      value: option
    }));
  }

  let valueOption = (_selectOptions$find = selectOptions.find(x => x.value === value)) !== null && _selectOptions$find !== void 0 ? _selectOptions$find : (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(value);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_3__.getOperationParamId)(operationIndex, index),
    value: valueOption,
    options: selectOptions,
    placeholder: paramDef.placeholder,
    allowCustomValue: true,
    onChange: value => onChange(index, value.value)
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationsEditorRow": () => (/* binding */ OperationsEditorRow)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function OperationsEditorRow({
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: styles.root,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
      gap: 1,
      children: children
    })
  });
}

const getStyles = theme => {
  return {
    root: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(1, 1, 0, 1),
      backgroundColor: theme.colors.background.secondary,
      borderRadius: theme.shape.borderRadius(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorModeToggle": () => (/* binding */ QueryEditorModeToggle)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const editorModes = [{
  label: 'Explain',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Explain
}, {
  label: 'Builder',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Builder,
  component: () => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Tag, {
    className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: 10,
      padding: '1px 5px',
      verticalAlign: 'text-bottom'
    }),
    name: 'Beta',
    colorIndex: 1
  })
}, {
  label: 'Code',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Code
}];
function QueryEditorModeToggle({
  mode,
  onChange
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    "data-testid": 'QueryEditorModeToggle',
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.RadioButtonGroup, {
      options: editorModes,
      size: "sm",
      value: mode,
      onChange: onChange
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryHeaderSwitch.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryHeaderSwitch": () => (/* binding */ QueryHeaderSwitch)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["label"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








function QueryHeaderSwitch(_ref) {
  let {
    label
  } = _ref,
      inputProps = _objectWithoutPropertiesLoose(_ref, _excluded);

  const dashedLabel = label.replace(' ', '-');
  const switchIdRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)((0,lodash__WEBPACK_IMPORTED_MODULE_1__.uniqueId)(`switch-${dashedLabel}`));
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.Stack, {
    gap: 1,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("label", {
      htmlFor: switchIdRef.current,
      className: styles.switchLabel,
      children: label
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Switch, Object.assign({}, inputProps, {
      id: switchIdRef.current
    }))]
  });
}

const getStyles = theme => {
  return {
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      cursor: 'pointer',
      fontSize: theme.typography.bodySmall.fontSize,
      '&:hover': {
        color: theme.colors.text.primary
      }
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryOptionGroup": () => (/* binding */ QueryOptionGroup)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useToggle.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function QueryOptionGroup({
  title,
  children,
  collapsedInfo
}) {
  const [isOpen, toggleOpen] = (0,react_use__WEBPACK_IMPORTED_MODULE_5__["default"])(false);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 0,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.header,
      onClick: toggleOpen,
      title: "Click to edit options",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.toggle,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
          name: isOpen ? 'angle-down' : 'angle-right'
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("h6", {
        className: styles.title,
        children: title
      }), !isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.description,
        children: collapsedInfo.map((x, i) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: x
        }, i))
      })]
    }), isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.body,
      children: children
    })]
  });
}

const getStyles = theme => {
  return {
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      cursor: 'pointer',
      fontSize: theme.typography.bodySmall.fontSize,
      '&:hover': {
        color: theme.colors.text.primary
      }
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'flex',
      cursor: 'pointer',
      alignItems: 'baseline',
      color: theme.colors.text.primary,
      '&:hover': {
        background: theme.colors.emphasize(theme.colors.background.primary, 0.03)
      }
    }),
    title: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      flexGrow: 1,
      overflow: 'hidden',
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      margin: 0
    }),
    description: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      fontSize: theme.typography.bodySmall.fontSize,
      paddingLeft: theme.spacing(2),
      gap: theme.spacing(2),
      display: 'flex'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'flex',
      paddingTop: theme.spacing(2),
      gap: theme.spacing(2),
      flexWrap: 'wrap'
    }),
    toggle: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      marginRight: `${theme.spacing(1)}`
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/RawQuery.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RawQuery": () => (/* binding */ RawQuery)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.28.0-28f20a79ff-bde93fb2be.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui_src__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function RawQuery({
  query,
  lang
}) {
  const theme = (0,_grafana_ui_src__WEBPACK_IMPORTED_MODULE_3__.useTheme2)();
  const styles = getStyles(theme);
  const highlighted = prismjs__WEBPACK_IMPORTED_MODULE_1___default().highlight(query, lang.grammar, lang.name);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.editorField, 'prism-syntax-highlight'),
    "aria-label": "selector",
    dangerouslySetInnerHTML: {
      __html: highlighted
    }
  });
}

const getStyles = theme => {
  return {
    editorField: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontFamily: theme.typography.fontFamilyMonospace,
      fontSize: theme.typography.bodySmall.fontSize
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAggregationOperation": () => (/* binding */ createAggregationOperation),
/* harmony export */   "createAggregationOperationWithParam": () => (/* binding */ createAggregationOperationWithParam),
/* harmony export */   "defaultAddOperationHandler": () => (/* binding */ defaultAddOperationHandler),
/* harmony export */   "functionRendererLeft": () => (/* binding */ functionRendererLeft),
/* harmony export */   "functionRendererRight": () => (/* binding */ functionRendererRight),
/* harmony export */   "getOperationParamId": () => (/* binding */ getOperationParamId),
/* harmony export */   "getPromAndLokiOperationDisplayName": () => (/* binding */ getPromAndLokiOperationDisplayName),
/* harmony export */   "getRangeVectorParamDef": () => (/* binding */ getRangeVectorParamDef),
/* harmony export */   "rangeRendererLeftWithParams": () => (/* binding */ rangeRendererLeftWithParams),
/* harmony export */   "rangeRendererRightWithParams": () => (/* binding */ rangeRendererRightWithParams)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/pluralize-npm-8.0.0-f5f044ed52-08931d4a6a.zip/node_modules/pluralize/pluralize.js");
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pluralize__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");




function functionRendererLeft(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.push(innerExpr);
  }

  return str + params.join(', ') + ')';
}
function functionRendererRight(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.unshift(innerExpr);
  }

  return str + params.join(', ') + ')';
}

function rangeRendererWithParams(model, def, innerExpr, renderLeft) {
  var _, _model$params;

  if (def.params.length < 2) {
    throw `Cannot render a function with params of length [${def.params.length}]`;
  }

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m'; // Next frame the remaining parameters, but get rid of the first one because it's used to move the
  // instant vector into a range vector.

  const params = renderParams(Object.assign({}, model, {
    params: model.params.slice(1)
  }), Object.assign({}, def, {
    params: def.params.slice(1),
    defaultParams: def.defaultParams.slice(1)
  }), innerExpr);
  const str = model.id + '('; // Depending on the renderLeft variable, render parameters to the left or right
  // renderLeft === true (renderLeft) => (param1, param2, rangeVector[...])
  // renderLeft === false (renderRight) => (rangeVector[...], param1, param2)

  if (innerExpr) {
    renderLeft ? params.push(`${innerExpr}[${rangeVector}]`) : params.unshift(`${innerExpr}[${rangeVector}]`);
  } // stick everything together


  return str + params.join(', ') + ')';
}

function rangeRendererRightWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, false);
}
function rangeRendererLeftWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, true);
}

function renderParams(model, def, innerExpr) {
  var _model$params2;

  return ((_model$params2 = model.params) !== null && _model$params2 !== void 0 ? _model$params2 : []).map((value, index) => {
    const paramDef = def.params[index];

    if (paramDef.type === 'string') {
      return '"' + value + '"';
    }

    return value;
  });
}

function defaultAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}
function getPromAndLokiOperationDisplayName(funcName) {
  return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(funcName.replace(/_/g, ' '));
}
function getOperationParamId(operationIndex, paramIndex) {
  return `operations.${operationIndex}.param.${paramIndex}`;
}
function getRangeVectorParamDef(withRateInterval = false) {
  const param = {
    name: 'Range',
    type: 'string',
    options: [{
      label: '$__interval',
      value: '$__interval' // tooltip: 'Dynamic interval based on max data points, scrape and min interval',

    }, {
      label: '1m',
      value: '1m'
    }, {
      label: '5m',
      value: '5m'
    }, {
      label: '10m',
      value: '10m'
    }, {
      label: '1h',
      value: '1h'
    }, {
      label: '24h',
      value: '24h'
    }]
  };

  if (withRateInterval) {
    param.options.unshift({
      label: '$__rate_interval',
      value: '$__rate_interval' // tooltip: 'Always above 4x scrape interval',

    });
  }

  return param;
}
/**
 * This function is shared between Prometheus and Loki variants
 */

function createAggregationOperation(name, overrides = {}) {
  const operations = [Object.assign({
    id: name,
    name: getPromAndLokiOperationDisplayName(name),
    params: [{
      name: 'By label',
      type: 'string',
      restParam: true,
      optional: true
    }],
    defaultParams: [],
    alternativesKey: 'plain aggregations',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: functionRendererLeft,
    paramChangedHandler: getOnLabelAddedHandler(`__${name}_by`),
    explainHandler: getAggregationExplainer(name, ''),
    addOperationHandler: defaultAddOperationHandler
  }, overrides), Object.assign({
    id: `__${name}_by`,
    name: `${getPromAndLokiOperationDisplayName(name)} by`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationByRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'by'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides), Object.assign({
    id: `__${name}_without`,
    name: `${getPromAndLokiOperationDisplayName(name)} without`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationWithoutRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'without'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides)];
  return operations;
}
function createAggregationOperationWithParam(name, paramsDef, overrides = {}) {
  const operations = createAggregationOperation(name, overrides);
  operations[0].params.unshift(...paramsDef.params);
  operations[1].params.unshift(...paramsDef.params);
  operations[2].params.unshift(...paramsDef.params);
  operations[0].defaultParams = paramsDef.defaultParams;
  operations[1].defaultParams = [...paramsDef.defaultParams, ''];
  operations[2].defaultParams = [...paramsDef.defaultParams, ''];
  operations[1].renderer = getAggregationByRendererWithParameter(name);
  operations[2].renderer = getAggregationByRendererWithParameter(name);
  return operations;
}

function getAggregationByRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} by(${model.params.join(', ')}) (${innerExpr})`;
  };
}

function getAggregationWithoutRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} without(${model.params.join(', ')}) (${innerExpr})`;
  };
}
/**
 * Very simple poc implementation, needs to be modified to support all aggregation operators
 */


function getAggregationExplainer(aggregationName, mode) {
  return function aggregationExplainer(model) {
    const labels = model.params.map(label => `\`${label}\``).join(' and ');
    const labelWord = pluralize__WEBPACK_IMPORTED_MODULE_1___default()('label', model.params.length);

    switch (mode) {
      case 'by':
        return `Calculates ${aggregationName} over dimensions while preserving ${labelWord} ${labels}.`;

      case 'without':
        return `Calculates ${aggregationName} over the dimensions ${labels}. All other labels are preserved.`;

      default:
        return `Calculates ${aggregationName} over the dimensions.`;
    }
  };
}

function getAggregationByRendererWithParameter(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    function mapType(p) {
      if (typeof p === 'string') {
        return `\"${p}\"`;
      }

      return p;
    }

    const params = model.params.slice(0, -1);
    const restParams = model.params.slice(1);
    return `${aggregation} by(${restParams.join(', ')}) (${params.map(mapType).join(', ')}, ${innerExpr})`;
  };
}
/**
 * This function will transform operations without labels to their plan aggregation operation
 */


function getLastLabelRemovedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // If definition has more params then is defined there are no optional rest params anymore.
    // We then transform this operation into a different one
    if (op.params.length < def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

function getOnLabelAddedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // Check if we actually have the label param. As it's optional the aggregation can have one less, which is the
    // case of just simple aggregation without label. When user adds the label it now has the same number of params
    // as it's definition, and now we can change it to it's `_by` variant.
    if (op.params.length === def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorName": () => (/* binding */ ErrorName),
/* harmony export */   "getAllByType": () => (/* binding */ getAllByType),
/* harmony export */   "getLeftMostChild": () => (/* binding */ getLeftMostChild),
/* harmony export */   "getString": () => (/* binding */ getString),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "makeBinOp": () => (/* binding */ makeBinOp),
/* harmony export */   "makeError": () => (/* binding */ makeError),
/* harmony export */   "replaceVariables": () => (/* binding */ replaceVariables)
/* harmony export */ });
// This is used for error type for some reason
const ErrorName = 'âš ';
function getLeftMostChild(cur) {
  return cur.firstChild ? getLeftMostChild(cur.firstChild) : cur;
}
function makeError(expr, node) {
  var _node$parent;

  return {
    text: getString(expr, node),
    // TODO: this are positions in the string with the replaced variables. Means it cannot be used to show exact
    //  placement of the error for the user. We need some translation table to positions before the variable
    //  replace.
    from: node.from,
    to: node.to,
    parentType: (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name
  };
} // Taken from template_srv, but copied so to not mess with the regex.index which is manipulated in the service

/*
 * This regex matches 3 types of variable reference with an optional format specifier
 * \$(\w+)                          $var1
 * \[\[([\s\S]+?)(?::(\w+))?\]\]    [[var2]] or [[var2:fmt2]]
 * \${(\w+)(?::(\w+))?}             ${var3} or ${var3:fmt3}
 */

const variableRegex = /\$(\w+)|\[\[([\s\S]+?)(?::(\w+))?\]\]|\${(\w+)(?:\.([^:^\}]+))?(?::([^\}]+))?}/g;
/**
 * As variables with $ are creating parsing errors, we first replace them with magic string that is parsable and at
 * the same time we can get the variable and it's format back from it.
 * @param expr
 */

function replaceVariables(expr) {
  return expr.replace(variableRegex, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {
    const fmt = fmt2 || fmt3;
    let variable = var1;
    let varType = '0';

    if (var2) {
      variable = var2;
      varType = '1';
    }

    if (var3) {
      variable = var3;
      varType = '2';
    }

    return `__V_${varType}__` + variable + '__V__' + (fmt ? '__F__' + fmt + '__F__' : '');
  });
}
const varTypeFunc = [(v, f) => `\$${v}`, (v, f) => `[[${v}${f ? `:${f}` : ''}]]`, (v, f) => `\$\{${v}${f ? `:${f}` : ''}\}`];
/**
 * Get back the text with variables in their original format.
 * @param expr
 */

function returnVariables(expr) {
  return expr.replace(/__V_(\d)__(.+?)__V__(?:__F__(\w+)__F__)?/g, (match, type, v, f) => {
    return varTypeFunc[parseInt(type, 10)](v, f);
  });
}
/**
 * Get the actual string of the expression. That is not stored in the tree so we have to get the indexes from the node
 * and then based on that get it from the expression.
 * @param expr
 * @param node
 */


function getString(expr, node) {
  if (!node) {
    return '';
  }

  return returnVariables(expr.substring(node.from, node.to));
}
/**
 * Create simple scalar binary op object.
 * @param opDef - definition of the op to be created
 * @param expr
 * @param numberNode - the node for the scalar
 * @param hasBool - whether operation has a bool modifier. Is used only for ops for which it makes sense.
 */

function makeBinOp(opDef, expr, numberNode, hasBool) {
  const params = [parseFloat(getString(expr, numberNode))];

  if (opDef.comparison) {
    params.push(hasBool);
  }

  return {
    id: opDef.id,
    params
  };
}
/**
 * Get all nodes with type in the tree. This traverses the tree so it is safe only when you know there shouldn't be
 * too much nesting but you just want to skip some of the wrappers. For example getting function args this way would
 * not be safe is it would also find arguments of nested functions.
 * @param expr
 * @param cur
 * @param type
 */

function getAllByType(expr, cur, type) {
  if (cur.name === type) {
    return [getString(expr, cur)];
  }

  const values = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    values.push(...getAllByType(expr, child, type));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  return values;
} // Debugging function for convenience. Gives you nice output similar to linux tree util.
// @ts-ignore

function log(expr, cur) {
  if (!cur) {
    console.log('<empty>');
    return;
  }

  const json = toJson(expr, cur);
  const text = jsonToText(json);

  if (!text) {
    console.log('<empty>');
    return;
  }

  console.log(text);
}

function toJson(expr, cur) {
  const treeJson = {};
  const name = nodeToString(expr, cur);
  const children = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    children.push(toJson(expr, child));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  treeJson.name = name;
  treeJson.children = children;
  return treeJson;
}

function jsonToText(node, context = {
  lastChild: true,
  indent: ''
}) {
  const name = node.name;
  const {
    lastChild,
    indent
  } = context;
  const newIndent = indent !== '' ? indent + (lastChild ? 'â””â”€' : 'â”œâ”€') : '';
  let text = newIndent + name;
  const children = node.children;
  children.forEach((child, index) => {
    const isLastChild = index === children.length - 1;
    text += '\n' + jsonToText(child, {
      lastChild: isLastChild,
      indent: indent + (lastChild ? '  ' : 'â”‚ ')
    });
  });
  return text;
}

function nodeToString(expr, node) {
  return node.name + ': ' + getString(expr, node);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorMode": () => (/* binding */ QueryEditorMode)
/* harmony export */ });
/**
 * Shared types that can be reused by Loki and other data sources
 */
let QueryEditorMode;

(function (QueryEditorMode) {
  QueryEditorMode["Code"] = "code";
  QueryEditorMode["Builder"] = "builder";
  QueryEditorMode["Explain"] = "explain";
})(QueryEditorMode || (QueryEditorMode = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromOperationId": () => (/* binding */ PromOperationId),
/* harmony export */   "PromVisualQueryOperationCategory": () => (/* binding */ PromVisualQueryOperationCategory)
/* harmony export */ });
/**
 * Visual query model
 */
let PromVisualQueryOperationCategory;

(function (PromVisualQueryOperationCategory) {
  PromVisualQueryOperationCategory["Aggregations"] = "Aggregations";
  PromVisualQueryOperationCategory["RangeFunctions"] = "Range functions";
  PromVisualQueryOperationCategory["Functions"] = "Functions";
  PromVisualQueryOperationCategory["BinaryOps"] = "Binary operations";
  PromVisualQueryOperationCategory["Trigonometric"] = "Trigonometric";
  PromVisualQueryOperationCategory["Time"] = "Time Functions";
})(PromVisualQueryOperationCategory || (PromVisualQueryOperationCategory = {}));

let PromOperationId;

(function (PromOperationId) {
  PromOperationId["Abs"] = "abs";
  PromOperationId["Absent"] = "absent";
  PromOperationId["AbsentOverTime"] = "absent_over_time";
  PromOperationId["Acos"] = "acos";
  PromOperationId["Acosh"] = "acosh";
  PromOperationId["Asin"] = "asin";
  PromOperationId["Asinh"] = "asinh";
  PromOperationId["Atan"] = "atan";
  PromOperationId["Atanh"] = "atanh";
  PromOperationId["Avg"] = "avg";
  PromOperationId["AvgOverTime"] = "avg_over_time";
  PromOperationId["BottomK"] = "bottomk";
  PromOperationId["Ceil"] = "ceil";
  PromOperationId["Changes"] = "changes";
  PromOperationId["Clamp"] = "clamp";
  PromOperationId["ClampMax"] = "clamp_max";
  PromOperationId["ClampMin"] = "clamp_min";
  PromOperationId["Cos"] = "cos";
  PromOperationId["Cosh"] = "cosh";
  PromOperationId["Count"] = "count";
  PromOperationId["CountOverTime"] = "count_over_time";
  PromOperationId["CountScalar"] = "count_scalar";
  PromOperationId["CountValues"] = "count_values";
  PromOperationId["DayOfMonth"] = "day_of_month";
  PromOperationId["DayOfWeek"] = "day_of_week";
  PromOperationId["DaysInMonth"] = "days_in_month";
  PromOperationId["Deg"] = "deg";
  PromOperationId["Delta"] = "delta";
  PromOperationId["Deriv"] = "deriv";
  PromOperationId["DropCommonLabels"] = "drop_common_labels";
  PromOperationId["Exp"] = "exp";
  PromOperationId["Floor"] = "floor";
  PromOperationId["Group"] = "group";
  PromOperationId["HistogramQuantile"] = "histogram_quantile";
  PromOperationId["HoltWinters"] = "holt_winters";
  PromOperationId["Hour"] = "hour";
  PromOperationId["Idelta"] = "idelta";
  PromOperationId["Increase"] = "increase";
  PromOperationId["Irate"] = "irate";
  PromOperationId["LabelJoin"] = "label_join";
  PromOperationId["LabelReplace"] = "label_replace";
  PromOperationId["Last"] = "last";
  PromOperationId["LastOverTime"] = "last_over_time";
  PromOperationId["Ln"] = "ln";
  PromOperationId["Log10"] = "log10";
  PromOperationId["Log2"] = "log2";
  PromOperationId["Max"] = "max";
  PromOperationId["MaxOverTime"] = "max_over_time";
  PromOperationId["Min"] = "min";
  PromOperationId["MinOverTime"] = "min_over_time";
  PromOperationId["Minute"] = "minute";
  PromOperationId["Month"] = "month";
  PromOperationId["Pi"] = "pi";
  PromOperationId["PredictLinear"] = "predict_linear";
  PromOperationId["Present"] = "present";
  PromOperationId["PresentOverTime"] = "present_over_time";
  PromOperationId["Quantile"] = "quantile";
  PromOperationId["QuantileOverTime"] = "quantile_over_time";
  PromOperationId["Rad"] = "rad";
  PromOperationId["Rate"] = "rate";
  PromOperationId["Resets"] = "resets";
  PromOperationId["Round"] = "round";
  PromOperationId["Scalar"] = "scalar";
  PromOperationId["Sgn"] = "sgn";
  PromOperationId["Sin"] = "sin";
  PromOperationId["Sinh"] = "sinh";
  PromOperationId["Sort"] = "sort";
  PromOperationId["SortDesc"] = "sort_desc";
  PromOperationId["Sqrt"] = "sqrt";
  PromOperationId["Stddev"] = "stddev";
  PromOperationId["StddevOverTime"] = "stddev_over_time";
  PromOperationId["Sum"] = "sum";
  PromOperationId["SumOverTime"] = "sum_over_time";
  PromOperationId["Tan"] = "tan";
  PromOperationId["Tanh"] = "tanh";
  PromOperationId["Time"] = "time";
  PromOperationId["Timestamp"] = "timestamp";
  PromOperationId["TopK"] = "topk";
  PromOperationId["Vector"] = "vector";
  PromOperationId["Year"] = "year";
  PromOperationId["Addition"] = "__addition";
  PromOperationId["Subtraction"] = "__subtraction";
  PromOperationId["MultiplyBy"] = "__multiply_by";
  PromOperationId["DivideBy"] = "__divide_by";
  PromOperationId["Modulo"] = "__modulo";
  PromOperationId["Exponent"] = "__exponent";
  PromOperationId["NestedQuery"] = "__nested_query";
  PromOperationId["EqualTo"] = "__equal_to";
  PromOperationId["NotEqualTo"] = "__not_equal_to";
  PromOperationId["GreaterThan"] = "__greater_than";
  PromOperationId["LessThan"] = "__less_than";
  PromOperationId["GreaterOrEqual"] = "__greater_or_equal";
  PromOperationId["LessOrEqual"] = "__less_or_equal";
})(PromOperationId || (PromOperationId = {}));

/***/ }),

/***/ "./.yarn/__virtual__/react-popper-tooltip-virtual-ff0da4b2fd/0/cache/react-popper-tooltip-npm-4.4.1-2214480dbc-58dacdf9bc.zip/node_modules/react-popper-tooltip/dist/esm/react-popper-tooltip.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "usePopperTooltip": () => (/* binding */ usePopperTooltip)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@babel-runtime-npm-7.18.3-1883c70fa6-db8526226a.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@babel-runtime-npm-7.18.3-1883c70fa6-db8526226a.zip/node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_popper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/react-popper-virtual-44630d53ac/0/cache/react-popper-npm-2.3.0-1045578379-837111c987.zip/node_modules/react-popper/lib/esm/usePopper.js");





function useGetLatest(val) {
  var ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(val);
  ref.current = val;
  return react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function () {
    return ref.current;
  }, []);
}

var noop = function noop() {// do nothing
};

function useControlledState(_ref) {
  var initial = _ref.initial,
      value = _ref.value,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? noop : _ref$onChange;

  if (initial === undefined && value === undefined) {
    throw new TypeError('Either "value" or "initial" variable must be set. Now both are undefined');
  }

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_2__.useState(initial),
      state = _React$useState[0],
      setState = _React$useState[1];

  var getLatest = useGetLatest(state);
  var set = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function (updater) {
    var state = getLatest();
    var updatedState = typeof updater === 'function' ? updater(state) : updater;
    if (typeof updatedState.persist === 'function') updatedState.persist();
    setState(updatedState);
    if (typeof onChange === 'function') onChange(updatedState);
  }, [getLatest, onChange]);
  var isControlled = value !== undefined;
  return [isControlled ? value : state, isControlled ? onChange : set];
}
function generateBoundingClientRect(x, y) {
  if (x === void 0) {
    x = 0;
  }

  if (y === void 0) {
    y = 0;
  }

  return function () {
    return {
      width: 0,
      height: 0,
      top: y,
      right: x,
      bottom: y,
      left: x,
      x: 0,
      y: 0,
      toJSON: function toJSON() {
        return null;
      }
    };
  };
}

var _excluded = ["styles", "attributes"];
var virtualElement = {
  getBoundingClientRect: generateBoundingClientRect()
};
var defaultConfig = {
  closeOnOutsideClick: true,
  closeOnTriggerHidden: false,
  defaultVisible: false,
  delayHide: 0,
  delayShow: 0,
  followCursor: false,
  interactive: false,
  mutationObserverOptions: {
    attributes: true,
    childList: true,
    subtree: true
  },
  offset: [0, 6],
  trigger: 'hover'
};
function usePopperTooltip(config, popperOptions) {
  var _popperProps$state, _popperProps$state$mo, _popperProps$state$mo2;

  if (config === void 0) {
    config = {};
  }

  if (popperOptions === void 0) {
    popperOptions = {};
  }

  // Merging options with default options.
  // Keys with undefined values are replaced with the default ones if any.
  // Keys with other values pass through.
  var finalConfig = Object.keys(defaultConfig).reduce(function (config, key) {
    var _extends2;

    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, config, (_extends2 = {}, _extends2[key] = config[key] !== undefined ? config[key] : defaultConfig[key], _extends2));
  }, config);
  var defaultModifiers = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(function () {
    return [{
      name: 'offset',
      options: {
        offset: finalConfig.offset
      }
    }];
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  Array.isArray(finalConfig.offset) ? finalConfig.offset : []);

  var finalPopperOptions = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, popperOptions, {
    placement: popperOptions.placement || finalConfig.placement,
    modifiers: popperOptions.modifiers || defaultModifiers
  });

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_2__.useState(null),
      triggerRef = _React$useState[0],
      setTriggerRef = _React$useState[1];

  var _React$useState2 = react__WEBPACK_IMPORTED_MODULE_2__.useState(null),
      tooltipRef = _React$useState2[0],
      setTooltipRef = _React$useState2[1];

  var _useControlledState = useControlledState({
    initial: finalConfig.defaultVisible,
    value: finalConfig.visible,
    onChange: finalConfig.onVisibleChange
  }),
      visible = _useControlledState[0],
      setVisible = _useControlledState[1];

  var timer = react__WEBPACK_IMPORTED_MODULE_2__.useRef();
  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    return function () {
      return clearTimeout(timer.current);
    };
  }, []);

  var _usePopper = (0,react_popper__WEBPACK_IMPORTED_MODULE_3__.usePopper)(finalConfig.followCursor ? virtualElement : triggerRef, tooltipRef, finalPopperOptions),
      styles = _usePopper.styles,
      attributes = _usePopper.attributes,
      popperProps = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(_usePopper, _excluded);

  var update = popperProps.update;
  var getLatest = useGetLatest({
    visible: visible,
    triggerRef: triggerRef,
    tooltipRef: tooltipRef,
    finalConfig: finalConfig
  });
  var isTriggeredBy = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function (trigger) {
    return Array.isArray(finalConfig.trigger) ? finalConfig.trigger.includes(trigger) : finalConfig.trigger === trigger;
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  Array.isArray(finalConfig.trigger) ? finalConfig.trigger : [finalConfig.trigger]);
  var hideTooltip = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function () {
    clearTimeout(timer.current);
    timer.current = window.setTimeout(function () {
      return setVisible(false);
    }, finalConfig.delayHide);
  }, [finalConfig.delayHide, setVisible]);
  var showTooltip = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function () {
    clearTimeout(timer.current);
    timer.current = window.setTimeout(function () {
      return setVisible(true);
    }, finalConfig.delayShow);
  }, [finalConfig.delayShow, setVisible]);
  var toggleTooltip = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function () {
    if (getLatest().visible) {
      hideTooltip();
    } else {
      showTooltip();
    }
  }, [getLatest, hideTooltip, showTooltip]); // Handle click outside

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (!getLatest().finalConfig.closeOnOutsideClick) return;

    var handleClickOutside = function handleClickOutside(event) {
      var _event$composedPath;

      var _getLatest = getLatest(),
          tooltipRef = _getLatest.tooltipRef,
          triggerRef = _getLatest.triggerRef;

      var target = (event.composedPath == null ? void 0 : (_event$composedPath = event.composedPath()) == null ? void 0 : _event$composedPath[0]) || event.target;

      if (target instanceof Node) {
        if (tooltipRef != null && triggerRef != null && !tooltipRef.contains(target) && !triggerRef.contains(target)) {
          hideTooltip();
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return function () {
      return document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [getLatest, hideTooltip]); // Trigger: click

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (triggerRef == null || !isTriggeredBy('click')) return;
    triggerRef.addEventListener('click', toggleTooltip);
    return function () {
      return triggerRef.removeEventListener('click', toggleTooltip);
    };
  }, [triggerRef, isTriggeredBy, toggleTooltip]); // Trigger: double-click

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (triggerRef == null || !isTriggeredBy('double-click')) return;
    triggerRef.addEventListener('dblclick', toggleTooltip);
    return function () {
      return triggerRef.removeEventListener('dblclick', toggleTooltip);
    };
  }, [triggerRef, isTriggeredBy, toggleTooltip]); // Trigger: right-click

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (triggerRef == null || !isTriggeredBy('right-click')) return;

    var preventDefaultAndToggle = function preventDefaultAndToggle(event) {
      // Don't show the context menu
      event.preventDefault();
      toggleTooltip();
    };

    triggerRef.addEventListener('contextmenu', preventDefaultAndToggle);
    return function () {
      return triggerRef.removeEventListener('contextmenu', preventDefaultAndToggle);
    };
  }, [triggerRef, isTriggeredBy, toggleTooltip]); // Trigger: focus

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (triggerRef == null || !isTriggeredBy('focus')) return;
    triggerRef.addEventListener('focus', showTooltip);
    triggerRef.addEventListener('blur', hideTooltip);
    return function () {
      triggerRef.removeEventListener('focus', showTooltip);
      triggerRef.removeEventListener('blur', hideTooltip);
    };
  }, [triggerRef, isTriggeredBy, showTooltip, hideTooltip]); // Trigger: hover on trigger

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (triggerRef == null || !isTriggeredBy('hover')) return;
    triggerRef.addEventListener('mouseenter', showTooltip);
    triggerRef.addEventListener('mouseleave', hideTooltip);
    return function () {
      triggerRef.removeEventListener('mouseenter', showTooltip);
      triggerRef.removeEventListener('mouseleave', hideTooltip);
    };
  }, [triggerRef, isTriggeredBy, showTooltip, hideTooltip]); // Trigger: hover on tooltip, keep it open if hovered

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (tooltipRef == null || !getLatest().finalConfig.interactive) return;
    tooltipRef.addEventListener('mouseenter', showTooltip);
    tooltipRef.addEventListener('mouseleave', hideTooltip);
    return function () {
      tooltipRef.removeEventListener('mouseenter', showTooltip);
      tooltipRef.removeEventListener('mouseleave', hideTooltip);
    };
  }, [tooltipRef, showTooltip, hideTooltip, getLatest]); // Handle closing tooltip if trigger hidden

  var isReferenceHidden = popperProps == null ? void 0 : (_popperProps$state = popperProps.state) == null ? void 0 : (_popperProps$state$mo = _popperProps$state.modifiersData) == null ? void 0 : (_popperProps$state$mo2 = _popperProps$state$mo.hide) == null ? void 0 : _popperProps$state$mo2.isReferenceHidden;
  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (finalConfig.closeOnTriggerHidden && isReferenceHidden) hideTooltip();
  }, [finalConfig.closeOnTriggerHidden, hideTooltip, isReferenceHidden]); // Handle follow cursor

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (!finalConfig.followCursor || triggerRef == null) return;

    function setMousePosition(_ref) {
      var clientX = _ref.clientX,
          clientY = _ref.clientY;
      virtualElement.getBoundingClientRect = generateBoundingClientRect(clientX, clientY);
      update == null ? void 0 : update();
    }

    triggerRef.addEventListener('mousemove', setMousePosition);
    return function () {
      return triggerRef.removeEventListener('mousemove', setMousePosition);
    };
  }, [finalConfig.followCursor, triggerRef, update]); // Handle tooltip DOM mutation changes (aka mutation observer)

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (tooltipRef == null || update == null || finalConfig.mutationObserverOptions == null) return;
    var observer = new MutationObserver(update);
    observer.observe(tooltipRef, finalConfig.mutationObserverOptions);
    return function () {
      return observer.disconnect();
    };
  }, [finalConfig.mutationObserverOptions, tooltipRef, update]); // Tooltip props getter

  var getTooltipProps = function getTooltipProps(args) {
    if (args === void 0) {
      args = {};
    }

    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, args, {
      style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, args.style, styles.popper)
    }, attributes.popper, {
      'data-popper-interactive': finalConfig.interactive
    });
  }; // Arrow props getter


  var getArrowProps = function getArrowProps(args) {
    if (args === void 0) {
      args = {};
    }

    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, args, attributes.arrow, {
      style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, args.style, styles.arrow),
      'data-popper-arrow': true
    });
  };

  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
    getArrowProps: getArrowProps,
    getTooltipProps: getTooltipProps,
    setTooltipRef: setTooltipRef,
    setTriggerRef: setTriggerRef,
    tooltipRef: tooltipRef,
    triggerRef: triggerRef,
    visible: visible
  }, popperProps);
}


//# sourceMappingURL=react-popper-tooltip.js.map


/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/usePrevious.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ usePrevious)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

function usePrevious(state) {
    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
        ref.current = state;
    });
    return ref.current;
}


/***/ }),

/***/ "./.yarn/cache/lru-cache-npm-7.10.1-5af910d0ed-e8b190d71e.zip/node_modules/lru-cache/index.js":
/***/ ((module) => {

const perf =
  typeof performance === 'object' &&
  performance &&
  typeof performance.now === 'function'
    ? performance
    : Date

const hasAbortController = typeof AbortController === 'function'

// minimal backwards-compatibility polyfill
// this doesn't have nearly all the checks and whatnot that
// actual AbortController/Signal has, but it's enough for
// our purposes, and if used properly, behaves the same.
const AC = hasAbortController
  ? AbortController
  : class AbortController {
      constructor() {
        this.signal = new AS()
      }
      abort() {
        this.signal.dispatchEvent('abort')
      }
    }

const AS = hasAbortController
  ? AbortSignal
  : class AbortSignal {
      constructor() {
        this.aborted = false
        this._listeners = []
      }
      dispatchEvent(type) {
        if (type === 'abort') {
          this.aborted = true
          const e = { type, target: this }
          this.onabort(e)
          this._listeners.forEach(f => f(e), this)
        }
      }
      onabort() {}
      addEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners.push(fn)
        }
      }
      removeEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners = this._listeners.filter(f => f !== fn)
        }
      }
    }

const warned = new Set()
const deprecatedOption = (opt, instead) => {
  const code = `LRU_CACHE_OPTION_${opt}`
  if (shouldWarn(code)) {
    warn(code, `${opt} option`, `options.${instead}`, LRUCache)
  }
}
const deprecatedMethod = (method, instead) => {
  const code = `LRU_CACHE_METHOD_${method}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, method)
    warn(code, `${method} method`, `cache.${instead}()`, get)
  }
}
const deprecatedProperty = (field, instead) => {
  const code = `LRU_CACHE_PROPERTY_${field}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, field)
    warn(code, `${field} property`, `cache.${instead}`, get)
  }
}

const emitWarning = (...a) => {
  typeof process === 'object' &&
  process &&
  typeof process.emitWarning === 'function'
    ? process.emitWarning(...a)
    : console.error(...a)
}

const shouldWarn = code => !warned.has(code)

const warn = (code, what, instead, fn) => {
  warned.add(code)
  const msg = `The ${what} is deprecated. Please use ${instead} instead.`
  emitWarning(msg, 'DeprecationWarning', code, fn)
}

const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)

/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */
const getUintArray = max =>
  !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
    ? Uint8Array
    : max <= Math.pow(2, 16)
    ? Uint16Array
    : max <= Math.pow(2, 32)
    ? Uint32Array
    : max <= Number.MAX_SAFE_INTEGER
    ? ZeroArray
    : null

class ZeroArray extends Array {
  constructor(size) {
    super(size)
    this.fill(0)
  }
}

class Stack {
  constructor(max) {
    if (max === 0) {
      return []
    }
    const UintArray = getUintArray(max)
    this.heap = new UintArray(max)
    this.length = 0
  }
  push(n) {
    this.heap[this.length++] = n
  }
  pop() {
    return this.heap[--this.length]
  }
}

class LRUCache {
  constructor(options = {}) {
    const {
      max = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      updateAgeOnHas,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      sizeCalculation,
      fetchMethod,
      noDeleteOnFetchRejection,
    } = options

    // deprecated options, don't trigger a warning for getting them if
    // the thing being passed in is another LRUCache we're copying.
    const { length, maxAge, stale } =
      options instanceof LRUCache ? {} : options

    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError('max option must be a nonnegative integer')
    }

    const UintArray = max ? getUintArray(max) : Array
    if (!UintArray) {
      throw new Error('invalid max value: ' + max)
    }

    this.max = max
    this.maxSize = maxSize
    this.sizeCalculation = sizeCalculation || length
    if (this.sizeCalculation) {
      if (!this.maxSize) {
        throw new TypeError(
          'cannot set sizeCalculation without setting maxSize'
        )
      }
      if (typeof this.sizeCalculation !== 'function') {
        throw new TypeError('sizeCalculation set to non-function')
      }
    }

    this.fetchMethod = fetchMethod || null
    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
      throw new TypeError(
        'fetchMethod must be a function if specified'
      )
    }

    this.keyMap = new Map()
    this.keyList = new Array(max).fill(null)
    this.valList = new Array(max).fill(null)
    this.next = new UintArray(max)
    this.prev = new UintArray(max)
    this.head = 0
    this.tail = 0
    this.free = new Stack(max)
    this.initialFill = 1
    this.size = 0

    if (typeof dispose === 'function') {
      this.dispose = dispose
    }
    if (typeof disposeAfter === 'function') {
      this.disposeAfter = disposeAfter
      this.disposed = []
    } else {
      this.disposeAfter = null
      this.disposed = null
    }
    this.noDisposeOnSet = !!noDisposeOnSet
    this.noUpdateTTL = !!noUpdateTTL
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection

    if (this.maxSize !== 0) {
      if (!isPosInt(this.maxSize)) {
        throw new TypeError(
          'maxSize must be a positive integer if specified'
        )
      }
      this.initializeSizeTracking()
    }

    this.allowStale = !!allowStale || !!stale
    this.updateAgeOnGet = !!updateAgeOnGet
    this.updateAgeOnHas = !!updateAgeOnHas
    this.ttlResolution =
      isPosInt(ttlResolution) || ttlResolution === 0
        ? ttlResolution
        : 1
    this.ttlAutopurge = !!ttlAutopurge
    this.ttl = ttl || maxAge || 0
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError(
          'ttl must be a positive integer if specified'
        )
      }
      this.initializeTTLTracking()
    }

    // do not allow completely unbounded caches
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError(
        'At least one of max, maxSize, or ttl is required'
      )
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code = 'LRU_CACHE_UNBOUNDED'
      if (shouldWarn(code)) {
        warned.add(code)
        const msg =
          'TTL caching without ttlAutopurge, max, or maxSize can ' +
          'result in unbounded memory consumption.'
        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
      }
    }

    if (stale) {
      deprecatedOption('stale', 'allowStale')
    }
    if (maxAge) {
      deprecatedOption('maxAge', 'ttl')
    }
    if (length) {
      deprecatedOption('length', 'sizeCalculation')
    }
  }

  getRemainingTTL(key) {
    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0
  }

  initializeTTLTracking() {
    this.ttls = new ZeroArray(this.max)
    this.starts = new ZeroArray(this.max)

    this.setItemTTL = (index, ttl) => {
      this.starts[index] = ttl !== 0 ? perf.now() : 0
      this.ttls[index] = ttl
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.isStale(index)) {
            this.delete(this.keyList[index])
          }
        }, ttl + 1)
        /* istanbul ignore else - unref() not supported on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
    }

    this.updateItemAge = index => {
      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0
    }

    // debounce calls to perf.now() to 1s so we're not hitting
    // that costly call repeatedly.
    let cachedNow = 0
    const getNow = () => {
      const n = perf.now()
      if (this.ttlResolution > 0) {
        cachedNow = n
        const t = setTimeout(
          () => (cachedNow = 0),
          this.ttlResolution
        )
        /* istanbul ignore else - not available on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
      return n
    }

    this.getRemainingTTL = key => {
      const index = this.keyMap.get(key)
      if (index === undefined) {
        return 0
      }
      return this.ttls[index] === 0 || this.starts[index] === 0
        ? Infinity
        : this.starts[index] +
            this.ttls[index] -
            (cachedNow || getNow())
    }

    this.isStale = index => {
      return (
        this.ttls[index] !== 0 &&
        this.starts[index] !== 0 &&
        (cachedNow || getNow()) - this.starts[index] >
          this.ttls[index]
      )
    }
  }
  updateItemAge(index) {}
  setItemTTL(index, ttl) {}
  isStale(index) {
    return false
  }

  initializeSizeTracking() {
    this.calculatedSize = 0
    this.sizes = new ZeroArray(this.max)
    this.removeItemSize = index =>
      (this.calculatedSize -= this.sizes[index])
    this.requireSize = (k, v, size, sizeCalculation) => {
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== 'function') {
            throw new TypeError('sizeCalculation must be a function')
          }
          size = sizeCalculation(v, k)
          if (!isPosInt(size)) {
            throw new TypeError(
              'sizeCalculation return invalid (expect positive integer)'
            )
          }
        } else {
          throw new TypeError(
            'invalid size value (must be positive integer)'
          )
        }
      }
      return size
    }
    this.addItemSize = (index, v, k, size) => {
      this.sizes[index] = size
      const maxSize = this.maxSize - this.sizes[index]
      while (this.calculatedSize > maxSize) {
        this.evict(true)
      }
      this.calculatedSize += this.sizes[index]
    }
  }
  removeItemSize(index) {}
  addItemSize(index, v, k, size) {}
  requireSize(k, v, size, sizeCalculation) {
    if (size || sizeCalculation) {
      throw new TypeError(
        'cannot set size without setting maxSize on cache'
      )
    }
  }

  *indexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.tail; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.head) {
          break
        } else {
          i = this.prev[i]
        }
      }
    }
  }

  *rindexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.head; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.tail) {
          break
        } else {
          i = this.next[i]
        }
      }
    }
  }

  isValidIndex(index) {
    return this.keyMap.get(this.keyList[index]) === index
  }

  *entries() {
    for (const i of this.indexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }
  *rentries() {
    for (const i of this.rindexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }

  *keys() {
    for (const i of this.indexes()) {
      yield this.keyList[i]
    }
  }
  *rkeys() {
    for (const i of this.rindexes()) {
      yield this.keyList[i]
    }
  }

  *values() {
    for (const i of this.indexes()) {
      yield this.valList[i]
    }
  }
  *rvalues() {
    for (const i of this.rindexes()) {
      yield this.valList[i]
    }
  }

  [Symbol.iterator]() {
    return this.entries()
  }

  find(fn, getOptions = {}) {
    for (const i of this.indexes()) {
      if (fn(this.valList[i], this.keyList[i], this)) {
        return this.get(this.keyList[i], getOptions)
      }
    }
  }

  forEach(fn, thisp = this) {
    for (const i of this.indexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  rforEach(fn, thisp = this) {
    for (const i of this.rindexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  get prune() {
    deprecatedMethod('prune', 'purgeStale')
    return this.purgeStale
  }

  purgeStale() {
    let deleted = false
    for (const i of this.rindexes({ allowStale: true })) {
      if (this.isStale(i)) {
        this.delete(this.keyList[i])
        deleted = true
      }
    }
    return deleted
  }

  dump() {
    const arr = []
    for (const i of this.indexes()) {
      const key = this.keyList[i]
      const value = this.valList[i]
      const entry = { value }
      if (this.ttls) {
        entry.ttl = this.ttls[i]
      }
      if (this.sizes) {
        entry.size = this.sizes[i]
      }
      arr.unshift([key, entry])
    }
    return arr
  }

  load(arr) {
    this.clear()
    for (const [key, entry] of arr) {
      this.set(key, entry.value, entry)
    }
  }

  dispose(v, k, reason) {}

  set(
    k,
    v,
    {
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
    } = {}
  ) {
    size = this.requireSize(k, v, size, sizeCalculation)
    let index = this.size === 0 ? undefined : this.keyMap.get(k)
    if (index === undefined) {
      // addition
      index = this.newIndex()
      this.keyList[index] = k
      this.valList[index] = v
      this.keyMap.set(k, index)
      this.next[this.tail] = index
      this.prev[index] = this.tail
      this.tail = index
      this.size++
      this.addItemSize(index, v, k, size)
      noUpdateTTL = false
    } else {
      // update
      const oldVal = this.valList[index]
      if (v !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort()
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k, 'set')
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k, 'set'])
            }
          }
        }
        this.removeItemSize(index)
        this.valList[index] = v
        this.addItemSize(index, v, k, size)
      }
      this.moveToTail(index)
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking()
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index, ttl)
    }
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return this
  }

  newIndex() {
    if (this.size === 0) {
      return this.tail
    }
    if (this.size === this.max && this.max !== 0) {
      return this.evict(false)
    }
    if (this.free.length !== 0) {
      return this.free.pop()
    }
    // initial fill, just keep writing down the list
    return this.initialFill++
  }

  pop() {
    if (this.size) {
      const val = this.valList[this.head]
      this.evict(true)
      return val
    }
  }

  evict(free) {
    const head = this.head
    const k = this.keyList[head]
    const v = this.valList[head]
    if (this.isBackgroundFetch(v)) {
      v.__abortController.abort()
    } else {
      this.dispose(v, k, 'evict')
      if (this.disposeAfter) {
        this.disposed.push([v, k, 'evict'])
      }
    }
    this.removeItemSize(head)
    // if we aren't about to use the index, then null these out
    if (free) {
      this.keyList[head] = null
      this.valList[head] = null
      this.free.push(head)
    }
    this.head = this.next[head]
    this.keyMap.delete(k)
    this.size--
    return head
  }

  has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      if (!this.isStale(index)) {
        if (updateAgeOnHas) {
          this.updateItemAge(index)
        }
        return true
      }
    }
    return false
  }

  // like get(), but without any LRU updating or TTL expiration
  peek(k, { allowStale = this.allowStale } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined && (allowStale || !this.isStale(index))) {
      return this.valList[index]
    }
  }

  backgroundFetch(k, index, options) {
    const v = index === undefined ? undefined : this.valList[index]
    if (this.isBackgroundFetch(v)) {
      return v
    }
    const ac = new AC()
    const fetchOpts = {
      signal: ac.signal,
      options,
    }
    const cb = v => {
      if (!ac.signal.aborted) {
        this.set(k, v, fetchOpts.options)
      }
      return v
    }
    const eb = er => {
      if (this.valList[index] === p) {
        const del =
          !options.noDeleteOnFetchRejection ||
          p.__staleWhileFetching === undefined
        if (del) {
          this.delete(k)
        } else {
          // still replace the *promise* with the stale value,
          // since we are done with the promise at this point.
          this.valList[index] = p.__staleWhileFetching
        }
      }
      if (p.__returned === p) {
        throw er
      }
    }
    const pcall = res => res(this.fetchMethod(k, v, fetchOpts))
    const p = new Promise(pcall).then(cb, eb)
    p.__abortController = ac
    p.__staleWhileFetching = v
    p.__returned = null
    if (index === undefined) {
      this.set(k, p, fetchOpts.options)
      index = this.keyMap.get(k)
    } else {
      this.valList[index] = p
    }
    return p
  }

  isBackgroundFetch(p) {
    return (
      p &&
      typeof p === 'object' &&
      typeof p.then === 'function' &&
      Object.prototype.hasOwnProperty.call(
        p,
        '__staleWhileFetching'
      ) &&
      Object.prototype.hasOwnProperty.call(p, '__returned') &&
      (p.__returned === p || p.__returned === null)
    )
  }

  // this takes the union of get() and set() opts, because it does both
  async fetch(
    k,
    {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
    } = {}
  ) {
    if (!this.fetchMethod) {
      return this.get(k, { allowStale, updateAgeOnGet })
    }

    const options = {
      allowStale,
      updateAgeOnGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
    }

    let index = this.keyMap.get(k)
    if (index === undefined) {
      const p = this.backgroundFetch(k, index, options)
      return (p.__returned = p)
    } else {
      // in cache, maybe already fetching
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        return allowStale && v.__staleWhileFetching !== undefined
          ? v.__staleWhileFetching
          : (v.__returned = v)
      }

      if (!this.isStale(index)) {
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return v
      }

      // ok, it is stale, and not already fetching
      // refresh the cache.
      const p = this.backgroundFetch(k, index, options)
      return allowStale && p.__staleWhileFetching !== undefined
        ? p.__staleWhileFetching
        : (p.__returned = p)
    }
  }

  get(
    k,
    {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
    } = {}
  ) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      const value = this.valList[index]
      const fetching = this.isBackgroundFetch(value)
      if (this.isStale(index)) {
        // delete only if not an in-flight background fetch
        if (!fetching) {
          this.delete(k)
          return allowStale ? value : undefined
        } else {
          return allowStale ? value.__staleWhileFetching : undefined
        }
      } else {
        // if we're currently fetching it, we don't actually have it yet
        // it's not stale, which means this isn't a staleWhileRefetching,
        // so we just return undefined
        if (fetching) {
          return undefined
        }
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return value
      }
    }
  }

  connect(p, n) {
    this.prev[n] = p
    this.next[p] = n
  }

  moveToTail(index) {
    // if tail already, nothing to do
    // if head, move head to next[index]
    // else
    //   move next[prev[index]] to next[index] (head has no prev)
    //   move prev[next[index]] to prev[index]
    // prev[index] = tail
    // next[tail] = index
    // tail = index
    if (index !== this.tail) {
      if (index === this.head) {
        this.head = this.next[index]
      } else {
        this.connect(this.prev[index], this.next[index])
      }
      this.connect(this.tail, index)
      this.tail = index
    }
  }

  get del() {
    deprecatedMethod('del', 'delete')
    return this.delete
  }

  delete(k) {
    let deleted = false
    if (this.size !== 0) {
      const index = this.keyMap.get(k)
      if (index !== undefined) {
        deleted = true
        if (this.size === 1) {
          this.clear()
        } else {
          this.removeItemSize(index)
          const v = this.valList[index]
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort()
          } else {
            this.dispose(v, k, 'delete')
            if (this.disposeAfter) {
              this.disposed.push([v, k, 'delete'])
            }
          }
          this.keyMap.delete(k)
          this.keyList[index] = null
          this.valList[index] = null
          if (index === this.tail) {
            this.tail = this.prev[index]
          } else if (index === this.head) {
            this.head = this.next[index]
          } else {
            this.next[this.prev[index]] = this.next[index]
            this.prev[this.next[index]] = this.prev[index]
          }
          this.size--
          this.free.push(index)
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return deleted
  }

  clear() {
    for (const index of this.rindexes({ allowStale: true })) {
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort()
      } else {
        const k = this.keyList[index]
        this.dispose(v, k, 'delete')
        if (this.disposeAfter) {
          this.disposed.push([v, k, 'delete'])
        }
      }
    }

    this.keyMap.clear()
    this.valList.fill(null)
    this.keyList.fill(null)
    if (this.ttls) {
      this.ttls.fill(0)
      this.starts.fill(0)
    }
    if (this.sizes) {
      this.sizes.fill(0)
    }
    this.head = 0
    this.tail = 0
    this.initialFill = 1
    this.free.length = 0
    this.calculatedSize = 0
    this.size = 0
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
  }

  get reset() {
    deprecatedMethod('reset', 'clear')
    return this.clear
  }

  get length() {
    deprecatedProperty('length', 'size')
    return this.size
  }

  static get AbortController() {
    return AC
  }
  static get AbortSignal() {
    return AS
  }
}

module.exports = LRUCache


/***/ }),

/***/ "./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/WebSocketSubject.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocketSubject": () => (/* binding */ WebSocketSubject)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/tslib-npm-2.3.1-0e21e18015-de17a98d46.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subscriber.js");
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Observable.js");
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");






var DEFAULT_WEBSOCKET_CONFIG = {
    url: '',
    deserializer: function (e) { return JSON.parse(e.data); },
    serializer: function (value) { return JSON.stringify(value); },
};
var WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';
var WebSocketSubject = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(WebSocketSubject, _super);
    function WebSocketSubject(urlConfigOrSource, destination) {
        var _this = _super.call(this) || this;
        _this._socket = null;
        if (urlConfigOrSource instanceof _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable) {
            _this.destination = destination;
            _this.source = urlConfigOrSource;
        }
        else {
            var config = (_this._config = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, DEFAULT_WEBSOCKET_CONFIG));
            _this._output = new _Subject__WEBPACK_IMPORTED_MODULE_2__.Subject();
            if (typeof urlConfigOrSource === 'string') {
                config.url = urlConfigOrSource;
            }
            else {
                for (var key in urlConfigOrSource) {
                    if (urlConfigOrSource.hasOwnProperty(key)) {
                        config[key] = urlConfigOrSource[key];
                    }
                }
            }
            if (!config.WebSocketCtor && WebSocket) {
                config.WebSocketCtor = WebSocket;
            }
            else if (!config.WebSocketCtor) {
                throw new Error('no WebSocket constructor can be found');
            }
            _this.destination = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__.ReplaySubject();
        }
        return _this;
    }
    WebSocketSubject.prototype.lift = function (operator) {
        var sock = new WebSocketSubject(this._config, this.destination);
        sock.operator = operator;
        sock.source = this;
        return sock;
    };
    WebSocketSubject.prototype._resetState = function () {
        this._socket = null;
        if (!this.source) {
            this.destination = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__.ReplaySubject();
        }
        this._output = new _Subject__WEBPACK_IMPORTED_MODULE_2__.Subject();
    };
    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
        var self = this;
        return new _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable(function (observer) {
            try {
                self.next(subMsg());
            }
            catch (err) {
                observer.error(err);
            }
            var subscription = self.subscribe({
                next: function (x) {
                    try {
                        if (messageFilter(x)) {
                            observer.next(x);
                        }
                    }
                    catch (err) {
                        observer.error(err);
                    }
                },
                error: function (err) { return observer.error(err); },
                complete: function () { return observer.complete(); },
            });
            return function () {
                try {
                    self.next(unsubMsg());
                }
                catch (err) {
                    observer.error(err);
                }
                subscription.unsubscribe();
            };
        });
    };
    WebSocketSubject.prototype._connectSocket = function () {
        var _this = this;
        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;
        var observer = this._output;
        var socket = null;
        try {
            socket = protocol ? new WebSocketCtor(url, protocol) : new WebSocketCtor(url);
            this._socket = socket;
            if (binaryType) {
                this._socket.binaryType = binaryType;
            }
        }
        catch (e) {
            observer.error(e);
            return;
        }
        var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_4__.Subscription(function () {
            _this._socket = null;
            if (socket && socket.readyState === 1) {
                socket.close();
            }
        });
        socket.onopen = function (evt) {
            var _socket = _this._socket;
            if (!_socket) {
                socket.close();
                _this._resetState();
                return;
            }
            var openObserver = _this._config.openObserver;
            if (openObserver) {
                openObserver.next(evt);
            }
            var queue = _this.destination;
            _this.destination = _Subscriber__WEBPACK_IMPORTED_MODULE_5__.Subscriber.create(function (x) {
                if (socket.readyState === 1) {
                    try {
                        var serializer = _this._config.serializer;
                        socket.send(serializer(x));
                    }
                    catch (e) {
                        _this.destination.error(e);
                    }
                }
            }, function (err) {
                var closingObserver = _this._config.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                if (err && err.code) {
                    socket.close(err.code, err.reason);
                }
                else {
                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));
                }
                _this._resetState();
            }, function () {
                var closingObserver = _this._config.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                socket.close();
                _this._resetState();
            });
            if (queue && queue instanceof _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__.ReplaySubject) {
                subscription.add(queue.subscribe(_this.destination));
            }
        };
        socket.onerror = function (e) {
            _this._resetState();
            observer.error(e);
        };
        socket.onclose = function (e) {
            if (socket === _this._socket) {
                _this._resetState();
            }
            var closeObserver = _this._config.closeObserver;
            if (closeObserver) {
                closeObserver.next(e);
            }
            if (e.wasClean) {
                observer.complete();
            }
            else {
                observer.error(e);
            }
        };
        socket.onmessage = function (e) {
            try {
                var deserializer = _this._config.deserializer;
                observer.next(deserializer(e));
            }
            catch (err) {
                observer.error(err);
            }
        };
    };
    WebSocketSubject.prototype._subscribe = function (subscriber) {
        var _this = this;
        var source = this.source;
        if (source) {
            return source.subscribe(subscriber);
        }
        if (!this._socket) {
            this._connectSocket();
        }
        this._output.subscribe(subscriber);
        subscriber.add(function () {
            var _socket = _this._socket;
            if (_this._output.observers.length === 0) {
                if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {
                    _socket.close();
                }
                _this._resetState();
            }
        });
        return subscriber;
    };
    WebSocketSubject.prototype.unsubscribe = function () {
        var _socket = this._socket;
        if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {
            _socket.close();
        }
        this._resetState();
        _super.prototype.unsubscribe.call(this);
    };
    return WebSocketSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_2__.AnonymousSubject));

//# sourceMappingURL=WebSocketSubject.js.map

/***/ }),

/***/ "./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/webSocket.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "webSocket": () => (/* binding */ webSocket)
/* harmony export */ });
/* harmony import */ var _WebSocketSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/WebSocketSubject.js");

function webSocket(urlConfigOrSource) {
    return new _WebSocketSubject__WEBPACK_IMPORTED_MODULE_0__.WebSocketSubject(urlConfigOrSource);
}
//# sourceMappingURL=webSocket.js.map

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/parse.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/validate.js");


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/sha1.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v35.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/parse.js");



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v5.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "./.yarn/__virtual__/@grafana-lezer-logql-virtual-3a1b0e2de7/0/cache/@grafana-lezer-logql-npm-0.0.12-b44b271763-d28780b41a.zip/node_modules/@grafana/lezer-logql/index.es.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbsentOverTime": () => (/* binding */ AbsentOverTime),
/* harmony export */   "Add": () => (/* binding */ Add),
/* harmony export */   "And": () => (/* binding */ And),
/* harmony export */   "Avg": () => (/* binding */ Avg),
/* harmony export */   "AvgOverTime": () => (/* binding */ AvgOverTime),
/* harmony export */   "BinOpExpr": () => (/* binding */ BinOpExpr),
/* harmony export */   "BinOpModifier": () => (/* binding */ BinOpModifier),
/* harmony export */   "Bool": () => (/* binding */ Bool),
/* harmony export */   "Bottomk": () => (/* binding */ Bottomk),
/* harmony export */   "By": () => (/* binding */ By),
/* harmony export */   "Bytes": () => (/* binding */ Bytes),
/* harmony export */   "BytesConv": () => (/* binding */ BytesConv),
/* harmony export */   "BytesFilter": () => (/* binding */ BytesFilter),
/* harmony export */   "BytesOverTime": () => (/* binding */ BytesOverTime),
/* harmony export */   "BytesRate": () => (/* binding */ BytesRate),
/* harmony export */   "ConvOp": () => (/* binding */ ConvOp),
/* harmony export */   "Count": () => (/* binding */ Count),
/* harmony export */   "CountOverTime": () => (/* binding */ CountOverTime),
/* harmony export */   "Div": () => (/* binding */ Div),
/* harmony export */   "Duration": () => (/* binding */ Duration),
/* harmony export */   "DurationConv": () => (/* binding */ DurationConv),
/* harmony export */   "DurationFilter": () => (/* binding */ DurationFilter),
/* harmony export */   "DurationSecondsConv": () => (/* binding */ DurationSecondsConv),
/* harmony export */   "Eq": () => (/* binding */ Eq),
/* harmony export */   "Eql": () => (/* binding */ Eql),
/* harmony export */   "Expr": () => (/* binding */ Expr),
/* harmony export */   "Filter": () => (/* binding */ Filter),
/* harmony export */   "FilterOp": () => (/* binding */ FilterOp),
/* harmony export */   "FirstOverTime": () => (/* binding */ FirstOverTime),
/* harmony export */   "GroupLeft": () => (/* binding */ GroupLeft),
/* harmony export */   "GroupRight": () => (/* binding */ GroupRight),
/* harmony export */   "Grouping": () => (/* binding */ Grouping),
/* harmony export */   "GroupingLabel": () => (/* binding */ GroupingLabel),
/* harmony export */   "GroupingLabelList": () => (/* binding */ GroupingLabelList),
/* harmony export */   "GroupingLabels": () => (/* binding */ GroupingLabels),
/* harmony export */   "Gte": () => (/* binding */ Gte),
/* harmony export */   "Gtr": () => (/* binding */ Gtr),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Ignoring": () => (/* binding */ Ignoring),
/* harmony export */   "Ip": () => (/* binding */ Ip),
/* harmony export */   "IpLabelFilter": () => (/* binding */ IpLabelFilter),
/* harmony export */   "Json": () => (/* binding */ Json),
/* harmony export */   "JsonExpression": () => (/* binding */ JsonExpression),
/* harmony export */   "JsonExpressionList": () => (/* binding */ JsonExpressionList),
/* harmony export */   "JsonExpressionParser": () => (/* binding */ JsonExpressionParser),
/* harmony export */   "LabelFilter": () => (/* binding */ LabelFilter),
/* harmony export */   "LabelFormat": () => (/* binding */ LabelFormat),
/* harmony export */   "LabelFormatExpr": () => (/* binding */ LabelFormatExpr),
/* harmony export */   "LabelFormatMatcher": () => (/* binding */ LabelFormatMatcher),
/* harmony export */   "LabelName": () => (/* binding */ LabelName),
/* harmony export */   "LabelParser": () => (/* binding */ LabelParser),
/* harmony export */   "LabelReplace": () => (/* binding */ LabelReplace),
/* harmony export */   "LabelReplaceExpr": () => (/* binding */ LabelReplaceExpr),
/* harmony export */   "Labels": () => (/* binding */ Labels),
/* harmony export */   "LabelsFormat": () => (/* binding */ LabelsFormat),
/* harmony export */   "LastOverTime": () => (/* binding */ LastOverTime),
/* harmony export */   "LineComment": () => (/* binding */ LineComment),
/* harmony export */   "LineFilter": () => (/* binding */ LineFilter),
/* harmony export */   "LineFilters": () => (/* binding */ LineFilters),
/* harmony export */   "LineFormat": () => (/* binding */ LineFormat),
/* harmony export */   "LineFormatExpr": () => (/* binding */ LineFormatExpr),
/* harmony export */   "LiteralExpr": () => (/* binding */ LiteralExpr),
/* harmony export */   "LogExpr": () => (/* binding */ LogExpr),
/* harmony export */   "LogQL": () => (/* binding */ LogQL),
/* harmony export */   "LogRangeExpr": () => (/* binding */ LogRangeExpr),
/* harmony export */   "Logfmt": () => (/* binding */ Logfmt),
/* harmony export */   "Lss": () => (/* binding */ Lss),
/* harmony export */   "Lte": () => (/* binding */ Lte),
/* harmony export */   "Matcher": () => (/* binding */ Matcher),
/* harmony export */   "Matchers": () => (/* binding */ Matchers),
/* harmony export */   "Max": () => (/* binding */ Max),
/* harmony export */   "MaxOverTime": () => (/* binding */ MaxOverTime),
/* harmony export */   "MetricExpr": () => (/* binding */ MetricExpr),
/* harmony export */   "Min": () => (/* binding */ Min),
/* harmony export */   "MinOverTime": () => (/* binding */ MinOverTime),
/* harmony export */   "Mod": () => (/* binding */ Mod),
/* harmony export */   "Mul": () => (/* binding */ Mul),
/* harmony export */   "Neq": () => (/* binding */ Neq),
/* harmony export */   "Nre": () => (/* binding */ Nre),
/* harmony export */   "Number": () => (/* binding */ Number),
/* harmony export */   "NumberFilter": () => (/* binding */ NumberFilter),
/* harmony export */   "Offset": () => (/* binding */ Offset),
/* harmony export */   "OffsetExpr": () => (/* binding */ OffsetExpr),
/* harmony export */   "On": () => (/* binding */ On),
/* harmony export */   "OnOrIgnoringModifier": () => (/* binding */ OnOrIgnoringModifier),
/* harmony export */   "Or": () => (/* binding */ Or),
/* harmony export */   "Pattern": () => (/* binding */ Pattern),
/* harmony export */   "Pipe": () => (/* binding */ Pipe),
/* harmony export */   "PipeExact": () => (/* binding */ PipeExact),
/* harmony export */   "PipeMatch": () => (/* binding */ PipeMatch),
/* harmony export */   "PipelineExpr": () => (/* binding */ PipelineExpr),
/* harmony export */   "PipelineStage": () => (/* binding */ PipelineStage),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "QuantileOverTime": () => (/* binding */ QuantileOverTime),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "RangeAggregationExpr": () => (/* binding */ RangeAggregationExpr),
/* harmony export */   "RangeOp": () => (/* binding */ RangeOp),
/* harmony export */   "Rate": () => (/* binding */ Rate),
/* harmony export */   "Re": () => (/* binding */ Re),
/* harmony export */   "Regexp": () => (/* binding */ Regexp),
/* harmony export */   "Selector": () => (/* binding */ Selector),
/* harmony export */   "Stddev": () => (/* binding */ Stddev),
/* harmony export */   "StddevOverTime": () => (/* binding */ StddevOverTime),
/* harmony export */   "Stdvar": () => (/* binding */ Stdvar),
/* harmony export */   "StdvarOverTime": () => (/* binding */ StdvarOverTime),
/* harmony export */   "String": () => (/* binding */ String),
/* harmony export */   "Sub": () => (/* binding */ Sub),
/* harmony export */   "Sum": () => (/* binding */ Sum),
/* harmony export */   "SumOverTime": () => (/* binding */ SumOverTime),
/* harmony export */   "Topk": () => (/* binding */ Topk),
/* harmony export */   "UnitFilter": () => (/* binding */ UnitFilter),
/* harmony export */   "Unless": () => (/* binding */ Unless),
/* harmony export */   "Unpack": () => (/* binding */ Unpack),
/* harmony export */   "Unwrap": () => (/* binding */ Unwrap),
/* harmony export */   "UnwrapExpr": () => (/* binding */ UnwrapExpr),
/* harmony export */   "VectorAggregationExpr": () => (/* binding */ VectorAggregationExpr),
/* harmony export */   "VectorOp": () => (/* binding */ VectorOp),
/* harmony export */   "Without": () => (/* binding */ Without),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js");


// This file was generated by lezer-generator. You probably shouldn't edit it.
const Json$1 = 1,
  Logfmt$1 = 2,
  Unpack$1 = 3,
  Pattern$1 = 4,
  Regexp$1 = 5,
  Unwrap$1 = 6,
  Ip$1 = 7,
  LabelFormat$1 = 8,
  LineFormat$1 = 9,
  LabelReplace$1 = 10,
  Offset$1 = 11,
  Bool$1 = 12,
  On$1 = 13,
  Ignoring$1 = 14,
  GroupLeft$1 = 15,
  GroupRight$1 = 16,
  By$1 = 17,
  Without$1 = 18,
  And$1 = 19,
  Or$1 = 20,
  Unless$1 = 21,
  Sum$1 = 22,
  Avg$1 = 23,
  Count$1 = 24,
  Max$1 = 25,
  Min$1 = 26,
  Stddev$1 = 27,
  Stdvar$1 = 28,
  Bottomk$1 = 29,
  Topk$1 = 30;

const keywordTokens = {
    json: Json$1,
    logfmt : Logfmt$1,
    unpack: Unpack$1,
    pattern : Pattern$1,
    regexp : Regexp$1,
    ip : Ip$1,
    label_format : LabelFormat$1,
    line_format : LineFormat$1,
    label_replace: LabelReplace$1,
    offset: Offset$1,
    bool: Bool$1,
    on: On$1,
    ignoring: Ignoring$1,
    group_left: GroupLeft$1,
    group_right: GroupRight$1,
    unwrap: Unwrap$1,
};

const specializeIdentifier = (value, stack) => {
    return keywordTokens[value.toLowerCase()] || -1;
};


const contextualKeywordTokens = {
    by: By$1,
    without: Without$1,
    and: And$1,
    or: Or$1,
    unless: Unless$1,
    sum: Sum$1,
    avg: Avg$1,
    count: Count$1,
    max: Max$1,
    min: Min$1,
    stddev: Stddev$1,
    stdvar: Stdvar$1,
    bottomk: Bottomk$1,
    topk: Topk$1
};

const extendIdentifier = (value, stack) => {
    return contextualKeywordTokens[value.toLowerCase()] || -1;
};

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,count_over_time:255, rate:257, bytes_over_time:259, bytes_rate:261, avg_over_time:263, sum_over_time:265, min_over_time:267, max_over_time:269, stddev_over_time:271, stdvar_over_time:273, quantile_over_time:275, first_over_time:277, last_over_time:279, absent_over_time:281, bytes:287, duration:289, duration_seconds:291};
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 13,
  states: "ASOYQPOOO#VQPO'#DPO$fQPO'#DOOYQPO'#DOOOQO'#D{'#D{O$sQPO'#DzOOQO'#Eg'#EgO$xQPO'#EfQ%TQPOOOOQO'#Eu'#EuO&UQPO'#EuO&ZQPO'#EvOOQO'#Dy'#DyOOQO'#C}'#C}OOQO'#D|'#D|OOQO'#D}'#D}OOQO'#EO'#EOOOQO'#EP'#EPOOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETOOQO'#EU'#EUOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EY'#EYOOQO'#EZ'#EZO&`QPO'#DROOQO'#DQ'#DQO&nQPO,59kOOQO'#D^'#D^O&vQPO'#D]O'OQPO'#D[OOQO'#DZ'#DZO(iQPO'#DZOOQO'#DY'#DYO*bQPO,59jO+pQPO,59jO+wQPO,5:eO,OQPO,5:fO,ZQPO'#EdO.YQPO,5;QO.aQPO,5;QO.fQPO,5;SO.fQPO,5;SO.fQPO,5;SO.fQPO,5;SO.fQPO,5;SO.fQPO,5;SOOQO,5;a,5;aOYQPO,5;bO0lQPO,59mO0qQPO1G/VOOQO1G/V1G/VOOQO'#Da'#DaOOQO,59w,59wO0yQPO,59wOOQO,59v,59vO1OQPO'#DRO1mQPO'#DcOOQO'#Dc'#DcO3ZQPO'#DcOOQO'#Di'#DiOOQO'#Dg'#DgO)OQPO'#DgO3`QPO,59uO4yQPO'#DuO5OQPO'#DvOOQO,59u,59uOOQO,59t,59tOOQO1G/U1G/UOOQO1G0P1G0PO5TQPO'#E[O,RQPO'#E[O5iQPO1G0QO5nQPO1G0QO5sQPO,5;OO5{QPO1G0lO7WQPO1G0lO7_QPO1G0lO7fQPO'#EjO9hQPO'#EiO9rQPO'#EiOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nO9|QPO1G0|OOQO1G/X1G/XOOQO1G/W1G/WOOQO7+$q7+$qO:TQPO1G/cO:YQPO,59mO:`QPO,5:UO:kQPO'#DfO:pQPO'#DeOOQO,5:O,5:OOOQO,59},59}O<ZQPO,5:RO)OQPO,5:RO)OQPO,5:ROOQO,5:a,5:aO<iQPO'#DxOOQO'#Dw'#DwO<nQPO,5:bO>XQPO'#DZO5TQPO,5:vO>`QPO'#E]O>eQPO,5:vO?OQPO,5:vO?YQPO,5:vO?aQPO,5:vO?fQPO7+%lO,RQPO7+%lOOQO'#Ee'#EeO@vQPO1G0jOOQO1G0j1G0jOAOQPO7+&WOYQPO7+&WOB`QPO7+&WOBgQPO7+&WOBnQQO'#EkOOQO,5;U,5;UODpQPO,5;TODwQPO,5;TOFYQPO7+&YOFaQPO7+&YOOQO7+&Y7+&YOFnQPO7+&YOFuQPO7+&YOGzQPO7+&YOH[QPO7+&hOHaQPO7+$}OHfQPO1G/nOOQO1G/p1G/pOOQO1G/w1G/wOOQO1G/y1G/yOHkQPO,5:QOHpQPO,5:POOQO1G/m1G/mOHuQPO1G/mOJ`QPO,5:dO5OQPO,5:cOJhQPO,5:yO>eQPO1G0bOJvQPO1G0bOKOQPO,5:wO)OQPO,5:yOKTQPO1G0bOK[QPO'#E^OKaQPO1G0bOKTQPO1G0bOKiQPO1G0bOKpQPO1G0bO5dQPO1G0bOOQO1G0b1G0bOOQO<<IW<<IWOK{QPO<<IWOLQQPO,5;POOQO7+&U7+&UOOQO<<Ir<<IrOLVQPO<<IrOYQPO<<IrOOQO'#Em'#EmOL^QPO,5;VOOQO'#El'#ElOOQO,5;V,5;VOOQO1G0o1G0oOLfQPO1G0oONcQPO<<JSOOQO<<Hi<<HiONhQPO7+%YOOQO1G/l1G/lOOQO1G/k1G/kOOQO1G0O1G0OOOQO1G/}1G/}OOQO'#E`'#E`OOQO1G0e1G0eONmQPO1G0eOOQO'#Ea'#EaOOQO'#Eb'#EbOOQO'#Ec'#EcOOQO7+%|7+%|OOQO1G0c1G0cONrQPO1G0eO! WQPO7+%|OOQO,5:x,5:xO! `QPO7+%|O5dQPO7+%|O! gQPO7+%|O! rQPOAN>rOOQO1G0k1G0kO!#SQPOAN?^O!$dQPOAN?^O!$kQQO1G0qOOQO1G0q1G0qOOQO7+&Z7+&ZO!$sQPOAN?nO!$xQPO<<HtO!$}QPO7+&PO!%SQPO<<IhO!%[QPO<<IhO!%dQPO<<IhO!%lQPO'#E_OOQO<<Ih<<IhOOQOG24^G24^OOQOG24xG24xOOQO1G0r1G0rOOQO7+&]7+&]O!%qQPOG25YOOQOAN>`AN>`O!%vQPO<<IkOOQOAN?SAN?SO!%{QPOAN?SO!&TQPOLD*tOOQOAN?VAN?VOOQO,5:b,5:bO!&YQPO!$'N`O!&_QPO!)9CzO!&dQPO!.K9fOOQO!4//Q!4//QO5OQPO'#DvO!&iQPO'#DZO!'WQPO,59jO!'bQPO'#DOOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nO.fQPO,5;SO.fQPO,5;SO.fQPO,5;SO.fQPO,5;SO.fQPO,5;SO.fQPO,5;SO!(mQPO7+&YO!(tQPO7+&YO!)RQPO7+&YO!*ZQPO7+&YO!*bQPO7+&YO!)YQPO'#Eh",
  stateData: "!*o~O#mOSoOS~OYZOfUOgUOhUOiUOjUOkUOlUOmUOnUO!hXO#cYO#dYO#nPO#qRO#s^O#t_O#u`O#vaO#wbO#xcO#ydO#zeO#{fO#|gO#}hO$OiO$PjO$QkO~OvlO~OyoO{oO!RoO!SoOcrXdrXerX!_rX!arX!brX!crX!drX#crX#drX#erX#frX#grX#hrX~O!UsO#krX#rrX~P#[O#qxO~OayObyO#qzO~Oc}Od|Oe}Oy!RO!_!RO!a!RO!b!RO!c!RO!d!RO#c!OO#d!OO#e!PO#f!PO#g!PO#h!QO~O!h!SO~O#q!TO~Ow!UOy!UOz!UO{!UO~O#o!VO#p!WO~OV!XOx!YO~OyoO{oO!RoO!SoOc!OXd!OXe!OX!U!OX!_!OX!a!OX!b!OX!c!OX!d!OX#c!OX#d!OX#e!OX#f!OX#g!OX#h!OX#k!OX#r!OX$R!OX#o!OX~OP!^OQ!_OR!_OS!`OT!`OW!fOX!eOv!]O#q!cO~OyoO{oO!RoO!SoOcradraera!_ra!ara!bra!cra!dra#cra#dra#era#fra#gra#hra~O!UsO#kra#rra~P)WOcqXdqXeqXyqX!_qX!aqX!bqX!cqX!dqX#cqX#dqX#eqX#fqX#gqX#hqX~O#r!iO~P*oO#r!jO~P*oO!h!nO#nPO#q!lO~O#q!oO~OYZOfUOgUOhUOiUOjUOkUOlUOmUOnUO#cYO#dYO#nPO#qRO#s^O#t_O#u`O#vaO#wbO#xcO#ydO#zeO#{fO#|gO#}hO$OiO$PjO$QkO~O!h!qO~P,`O#q!rO~O[!uO]!sO^!sOY#]Pf#]Pg#]Ph#]Pi#]Pj#]Pk#]Pl#]Pm#]Pn#]P!h#]P#c#]P#d#]P#n#]P#q#]P#s#]P#t#]P#u#]P#v#]P#w#]P#x#]P#y#]P#z#]P#{#]P#|#]P#}#]P$O#]P$P#]P$Q#]P~Ox!}O~OvlO#p#PO~O#q#QO~Ow#ROy#ROz!UO{!UO!_#SO!a#SO!b#SO!c#SO!d#SO~Ov#TOc!VXd!VXe!VXy!VX{!VX!R!VX!S!VX!U!VX!_!VX!a!VX!b!VX!c!VX!d!VX#c!VX#d!VX#e!VX#f!VX#g!VX#h!VX#k!VX#r!VX$R!VX#o!VX~Ox#WO~Oc#YOd#ZO#o#YOe}ay}a{}a!R}a!S}a!U}a!_}a!a}a!b}a!c}a!d}a#c}a#d}a#e}a#f}a#g}a#h}a#k}a#r}a$R}a~Ox#[O~Ov#]O~OyoO{oO!RoO!SoO!U#`O$R#bO~O#r#gO~O#o#hO~Ov#iO#r#kO~O#r#lO~P*oOc#iXd#iXe#iXy#iX!_#iX!a#iX!b#iX!c#iX!d#iX#c#iX#d#iX#e#iX#f#iX#g#iX#h#iX#r#iX~O#o#mO~P6SO!h#oO~P,`O#q#pO~OY#]Xf#]Xg#]Xh#]Xi#]Xj#]Xk#]Xl#]Xm#]Xn#]X!h#]X#c#]X#d#]X#n#]X#q#]X#s#]X#t#]X#u#]X#v#]X#w#]X#x#]X#y#]X#z#]X#{#]X#|#]X#}#]X$O#]X$P#]X$Q#]X~O_#rO`#rO~P7kO]!sO^!sO~P7kO#o#zO~P*oOx#{O~OV#|Ox!}O!`#}O!f$OO!h$PO~Ow$QO~O#o$ROc!XXd!XXe!XXy!XX{!XX!R!XX!S!XX!U!XX!_!XX!a!XX!b!XX!c!XX!d!XX#c!XX#d!XX#e!XX#f!XX#g!XX#h!XX#k!XX#r!XX$R!XX~Oc#YOd#ZO#o#YO#r$SO~Ow$UO~O#o$VOc!jad!jae!jay!ja{!ja!R!ja!S!ja!U!ja!_!ja!a!ja!b!ja!c!ja!d!ja#c!ja#d!ja#e!ja#f!ja#g!ja#h!ja#k!ja#r!ja$R!ja~OU$WO~P(iO!`$ZO~O!U$[O$R#bO~OyoO{oO!RoO!SoO!U#`O~OZ$^O#r#Oa~P>mO#r$cO~P5TO#r$dO~OayObyOc!nqd!nqe!nqy!nq!_!nq!a!nq!b!nq!c!nq!d!nq#c!nq#d!nq#e!nq#f!nq#g!nq#h!nq#k!nq#r!nq#o!nq~O#o$gO#r$hO~OayObyOc#Yqd#Yqe#Yqy#Yq!_#Yq!a#Yq!b#Yq!c#Yq!d#Yq#c#Yq#d#Yq#e#Yq#f#Yq#g#Yq#h#Yq#k#Yq#r#Yq#o#Yq~O#r$iO~P*oO#o$kO~P6SO#b$lO#r$oO~OY#]af#]ag#]ah#]ai#]aj#]ak#]al#]am#]an#]a!h#]a#c#]a#d#]a#n#]a#s#]a#t#]a#u#]a#v#]a#w#]a#x#]a#y#]a#z#]a#{#]a#|#]a#}#]a$O#]a$P#]a$Q#]a~O#q#pO~PBvO_$qO`$qO#q#]a~PBvOc}Oe}Oy!RO!_!RO!a!RO!b!RO!c!RO!d!RO#c!OO#d!OO#e#[q#f#[q#g#[q#h#[q#k#[q#r#[q~Od#[q~PEUOc#[qd#[qe#[q~PE[Od|O~PEUO#k#[q#r#[q~P%TOc#[qd#[qe#[qy#[q!_#[q!a#[q!b#[q!c#[q!d#[q#e#[q#f#[q#g#[q#h#[q~O#c!OO#d!OO#k#[q#r#[q~PGPOx$rO~O#r$sO~O#q$tO~Ox$uO~Ov#TO~Oc#YO#o#YOd!Zie!Ziy!Zi{!Zi!R!Zi!S!Zi!U!Zi!_!Zi!a!Zi!b!Zi!c!Zi!d!Zi#c!Zi#d!Zi#e!Zi#f!Zi#g!Zi#h!Zi#k!Zi#r!Zi$R!Zi~Ov$wOx$wO~Ov$zO$T$|O$U$}O$V%OO~OZ$^O#r#Oi~O$S%QO~O#r#Oi~P>mO!`%TO~O!U$[O#r#Oi~O#r%VO~P5TO!U$[O#r%VO$R#bO~O#r%XO~Ov%YO~O#r%ZO~P*oO#o%]O#r%^O~O#q#pOY#]if#]ig#]ih#]ii#]ij#]ik#]il#]im#]in#]i!h#]i#c#]i#d#]i#n#]i#s#]i#t#]i#u#]i#v#]i#w#]i#x#]i#y#]i#z#]i#{#]i#|#]i#}#]i$O#]i$P#]i$Q#]i~O#o%`O~Ox%aO~O#q%bO~Oc#YOd#ZO#o#YO!U#Ri$R#Ri#r#Ri~O!U$[O#r#Oq~O#r#Oq~P>mOZ%eO!U%fO#r#Oq~OayObyOc!n!Rd!n!Re!n!Ry!n!R!_!n!R!a!n!R!b!n!R!c!n!R!d!n!R#c!n!R#d!n!R#e!n!R#f!n!R#g!n!R#h!n!R#k!n!R#r!n!R#o!n!R~OayObyOc#Y!Rd#Y!Re#Y!Ry#Y!R!_#Y!R!a#Y!R!b#Y!R!c#Y!R!d#Y!R#c#Y!R#d#Y!R#e#Y!R#f#Y!R#g#Y!R#h#Y!R#k#Y!R#r#Y!R#o#Y!R~O#r%iO~P*oO#b$lO#r%kO~Ox%lO~O#r%mO~Ov%nO~O!U$[O#r#Oy~OZ$^O#r#Oy~O!U%fO!`%TO~OU$WO~O#o%qO~O#r%rO~O!U$[O#r#O!R~Ox%tO~O#o%uO~Ox%vO~O#r%wO~OP!^OQ!_OR!_OS!`OT!`OW%xOX!eOv!]O#q!cO~O!U%yO#ora~P)WO!U%yO#orX~P#[Oc&TOe&TOy&XO!_&XO!a&XO!b&XO!c&XO!d&XO#c&UO#d&UO#e#[q#f#[q#g#[q#h#[q#o#[q~Od#[q~P!'lOc#[qd#[qe#[q~P!'rOd&SO~P!'lOc&TOd&SOe&TOy&XO!_&XO!a&XO!b&XO!c&XO!d&XO#c&UO#d&UO#e&VO#f&VO#g&VO#h&WO~O#o#[q~P!)YO#c&UO#d&UO#o#[q~PGPO",
  goto: "/]#kPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#l$k%S%r%uPPPPPP&U&h&x'W'iPP'xP'{'{(Q(T(Z(l(l(uPPPPPP(uP(lP'{'{)O)U)]*O*e*z*z*z*z*z*z*z*z*z*z*z*z*z*z+a+j+},Z,s,v,v,v,y-Y*O-]*O-r.h.y/S/VPPPPPPP*O*O[WORz!r#m$kQ#t!vQ#u!wS#v!x&OQ#w!yQ#x!zQ#y!{Q&Y%|Q&Z%}Q&[&PQ&]&QQ&^&RR&_!Tt]Oz!T!r!v!w!x!y!z!{#m$k%|%}&O&P&Q&RRvRjQORz!T!r!v!w!x!y!z!{#m$kS!kx#hQ#e!l]%{%|%}&O&P&Q&RRnPQmP^!bs!c#Y#Z#`$[%yR#O!VQuQQ#a!kQ$]#dQ$a#eQ%U$`R%z%{[tQ!k#d#e$`%{]!hu#a$]$a%U%zirQu!k#a#d#e$]$`$a%U%z%{hqQu!k#a#d#e$]$`$a%U%z%{R![qkpQqu!k#a#d#e$]$`$a%U%z%{R!ZpV!gs#`%yR#V!^Q#U!^R$v$RU!ds#`%yQ#X!cQ$S#YQ$T#ZR%R$[_!bs!c#Y#Z#`$[%y_!as!c#Y#Z#`$[%yQ#_!fR%s%xS#^!f%xR$x$Vj]O!v!w!x!y!z!{%|%}&O&P&Q&RQwRQ!pzQ!|!TQ#n!rQ$j#mR%[$kw[ORz!T!r!v!w!x!y!z!{#m$k%|%}&O&P&Q&RwTORz!T!r!v!w!x!y!z!{#m$k%|%}&O&P&Q&RwSORz!T!r!v!w!x!y!z!{#m$k%|%}&O&P&Q&RQ!mxQ#f!lR$f#hS#d!k#eW$Y#a#c$a$bQ%P$XQ%W$cR%d%VQ$`#dQ%P$YQ%g%WR%o%dQ#c!kS$X#a$aQ$_#dQ$b#eS%S$]$`S%c%U%WR%p%eR${$WR$y$WQ{VQ$e#gQ$i#lQ%h%XR%i%ZR#j!owVORz!T!r!v!w!x!y!z!{#m$k%|%}&O&P&Q&RQ!v|Q!w}Q!x!OQ!y!PQ!z!QQ!{!RQ%|&SQ%}&TQ&O&UQ&P&VQ&Q&WR&R&Xh!t|}!O!P!Q!R&S&T&U&V&W&XR#s!uQ#q!sQ$p#rR%_$qR$m#pQ$n#pR%j%]",
  nodeNames: "âš  Json Logfmt Unpack Pattern Regexp Unwrap Ip LabelFormat LineFormat LabelReplace Offset Bool On Ignoring GroupLeft GroupRight By Without And Or Unless Sum Avg Count Max Min Stddev Stdvar Bottomk Topk LineComment LogQL Expr LogExpr Selector Matchers Matcher Identifier Eq String Neq Re Nre PipelineExpr PipelineStage LineFilters LineFilter Filter PipeExact PipeMatch FilterOp Pipe LabelParser JsonExpressionParser JsonExpressionList JsonExpression LabelFilter IpLabelFilter UnitFilter DurationFilter Gtr Duration Gte Lss Lte Eql BytesFilter Bytes NumberFilter Number LineFormatExpr LabelFormatExpr LabelsFormat LabelFormatMatcher MetricExpr RangeAggregationExpr RangeOp CountOverTime Rate BytesOverTime BytesRate AvgOverTime SumOverTime MinOverTime MaxOverTime StddevOverTime StdvarOverTime QuantileOverTime FirstOverTime LastOverTime AbsentOverTime LogRangeExpr Range OffsetExpr UnwrapExpr ConvOp BytesConv DurationConv DurationSecondsConv Grouping Labels VectorAggregationExpr VectorOp BinOpExpr BinOpModifier OnOrIgnoringModifier GroupingLabels GroupingLabelList GroupingLabel LabelName Add Sub Mul Div Mod Pow LiteralExpr LabelReplaceExpr",
  maxTerm: 145,
  skippedNodes: [0,31],
  repeatNodeCount: 0,
  tokenData: "3{~RwX^#lpq#lqr$ars$tst%huv%swx%xxy&gyz&lz{&q{|&v|}&{}!O'Q!O!P'V!P!Q(V!Q!R([!R![)r![!]0r!^!_1W!_!`1e!`!a1z!c!}2X!}#O2o#P#Q2t#Q#R2y#R#S2X#S#T3O#T#o2X#o#p3[#p#q3a#q#r3v#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~#qY#m~X^#lpq#l#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~$dQ!_!`$j#r#s$o~$oOy~~$tO{~~$yUx~OY$tZr$trs%]s#O$t#O#P%b#P~$t~%bOx~~%ePO~$t~%mQo~OY%hZ~%h~%xO#g~~%}Ux~OY%xZw%xwx%]x#O%x#O#P&a#P~%x~&dPO~%x~&lO#q~~&qO#r~~&vO#e~~&{O#c~~'QO#o~~'VO#d~~'YP!Q![']~'bR!h~!Q![']!g!h'k#X#Y'k~'nR{|'w}!O'w!Q!['}~'zP!Q!['}~(SP!h~!Q!['}~([O#f~~(ae!h~!O!P']!Q![)r!g!h+V!i!j+t!m!n+t!o!p+t!r!s+t!v!w+t#U#V+i#W#X+}#X#Y.P#Z#[.c#[#],f#_#`.c#a#b.l#d#e.c#g#h-n#h#i.c#k#l.}#l#m0W#m#n/i~)wd!h~!O!P']!Q![)r!g!h+V!i!j+t!m!n+t!o!p+t!r!s+t!v!w+t#U#V+i#W#X+}#X#Y.P#Z#[.c#[#],f#_#`.c#a#b.l#d#e.c#g#h-n#h#i.c#k#l.}#m#n/i~+YT{|'w}!O'w!Q!['}!d!e+i#]#^+n~+nO!f~~+qP#U#V+i~+wQ!d!e+i#]#^+n~,SP!`~!Q![,V~,YS!Q![,V#[#],f#a#b,z#g#h-n~,kP!`~!Q![,n~,qR!Q![,n#a#b,z#g#h-n~-PQ!`~!Q![-V#g#h-i~-YR!Q![-V#a#b-c#g#h-n~-fP#g#h-i~-nO!`~~-sP!`~!Q![-v~-yQ!Q![-v#a#b-c~.ST{|'w}!O'w!Q!['}#U#V+i#]#^+n~.fQ#U#V+i#]#^+n~.qS!`~!Q![-V#U#V+i#]#^+n#g#h-i~/SP!`~!Q![/V~/YT!Q![/V#W#X+}#[#],f#a#b,z#g#h-n~/nP!`~!Q![/q~/tU!Q![/q#W#X+}#[#],f#a#b,z#g#h-n#k#l.}~0ZR!Q![0d!c!i0d#T#Z0d~0iR!h~!Q![0d!c!i0d#T#Z0dP0wTvP!Q![0r![!]0r!c!}0r#R#S0r#T#o0r~1]P!b~!_!`1`~1eO!c~~1jQw~!_!`1p#r#s1u~1uO!d~~1zOz~~2PP!_~!_!`2S~2XO!a~R2`TvP#bQ!Q![2X![!]0r!c!}2X#R#S2X#T#o2X~2tO$R~~2yO$S~~3OO#h~~3RRO#S3O#S#T%]#T~3O~3aO#n~~3fQ!U~!_!`3l#r#s3q~3qO!R~~3vO!S~~3{O#p~",
  tokenizers: [0, 1],
  topRules: {"LogQL":[0,32]},
  specialized: [{term: 38, get: (value, stack) => (specializeIdentifier(value) << 1)},{term: 38, get: (value, stack) => (extendIdentifier(value) << 1) | 1},{term: 38, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 0
});
// This file was generated by lezer-generator. You probably shouldn't edit it.
const Json = 1,
  Logfmt = 2,
  Unpack = 3,
  Pattern = 4,
  Regexp = 5,
  Unwrap = 6,
  Ip = 7,
  LabelFormat = 8,
  LineFormat = 9,
  LabelReplace = 10,
  Offset = 11,
  Bool = 12,
  On = 13,
  Ignoring = 14,
  GroupLeft = 15,
  GroupRight = 16,
  By = 17,
  Without = 18,
  And = 19,
  Or = 20,
  Unless = 21,
  Sum = 22,
  Avg = 23,
  Count = 24,
  Max = 25,
  Min = 26,
  Stddev = 27,
  Stdvar = 28,
  Bottomk = 29,
  Topk = 30,
  LineComment = 31,
  LogQL = 32,
  Expr = 33,
  LogExpr = 34,
  Selector = 35,
  Matchers = 36,
  Matcher = 37,
  Identifier = 38,
  Eq = 39,
  String = 40,
  Neq = 41,
  Re = 42,
  Nre = 43,
  PipelineExpr = 44,
  PipelineStage = 45,
  LineFilters = 46,
  LineFilter = 47,
  Filter = 48,
  PipeExact = 49,
  PipeMatch = 50,
  FilterOp = 51,
  Pipe = 52,
  LabelParser = 53,
  JsonExpressionParser = 54,
  JsonExpressionList = 55,
  JsonExpression = 56,
  LabelFilter = 57,
  IpLabelFilter = 58,
  UnitFilter = 59,
  DurationFilter = 60,
  Gtr = 61,
  Duration = 62,
  Gte = 63,
  Lss = 64,
  Lte = 65,
  Eql = 66,
  BytesFilter = 67,
  Bytes = 68,
  NumberFilter = 69,
  Number = 70,
  LineFormatExpr = 71,
  LabelFormatExpr = 72,
  LabelsFormat = 73,
  LabelFormatMatcher = 74,
  MetricExpr = 75,
  RangeAggregationExpr = 76,
  RangeOp = 77,
  CountOverTime = 78,
  Rate = 79,
  BytesOverTime = 80,
  BytesRate = 81,
  AvgOverTime = 82,
  SumOverTime = 83,
  MinOverTime = 84,
  MaxOverTime = 85,
  StddevOverTime = 86,
  StdvarOverTime = 87,
  QuantileOverTime = 88,
  FirstOverTime = 89,
  LastOverTime = 90,
  AbsentOverTime = 91,
  LogRangeExpr = 92,
  Range = 93,
  OffsetExpr = 94,
  UnwrapExpr = 95,
  ConvOp = 96,
  BytesConv = 97,
  DurationConv = 98,
  DurationSecondsConv = 99,
  Grouping = 100,
  Labels = 101,
  VectorAggregationExpr = 102,
  VectorOp = 103,
  BinOpExpr = 104,
  BinOpModifier = 105,
  OnOrIgnoringModifier = 106,
  GroupingLabels = 107,
  GroupingLabelList = 108,
  GroupingLabel = 109,
  LabelName = 110,
  Add = 111,
  Sub = 112,
  Mul = 113,
  Div = 114,
  Mod = 115,
  Pow = 116,
  LiteralExpr = 117,
  LabelReplaceExpr = 118;




/***/ }),

/***/ "./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Abs": () => (/* binding */ Abs),
/* harmony export */   "Absent": () => (/* binding */ Absent),
/* harmony export */   "AbsentOverTime": () => (/* binding */ AbsentOverTime),
/* harmony export */   "Acos": () => (/* binding */ Acos),
/* harmony export */   "Acosh": () => (/* binding */ Acosh),
/* harmony export */   "Add": () => (/* binding */ Add),
/* harmony export */   "AggregateExpr": () => (/* binding */ AggregateExpr),
/* harmony export */   "AggregateModifier": () => (/* binding */ AggregateModifier),
/* harmony export */   "AggregateOp": () => (/* binding */ AggregateOp),
/* harmony export */   "And": () => (/* binding */ And$1),
/* harmony export */   "Asin": () => (/* binding */ Asin),
/* harmony export */   "Asinh": () => (/* binding */ Asinh),
/* harmony export */   "At": () => (/* binding */ At),
/* harmony export */   "AtModifierPreprocessors": () => (/* binding */ AtModifierPreprocessors),
/* harmony export */   "Atan": () => (/* binding */ Atan),
/* harmony export */   "Atan2": () => (/* binding */ Atan2$1),
/* harmony export */   "Atanh": () => (/* binding */ Atanh),
/* harmony export */   "Avg": () => (/* binding */ Avg$1),
/* harmony export */   "AvgOverTime": () => (/* binding */ AvgOverTime),
/* harmony export */   "BinModifiers": () => (/* binding */ BinModifiers),
/* harmony export */   "BinaryExpr": () => (/* binding */ BinaryExpr),
/* harmony export */   "Bool": () => (/* binding */ Bool$1),
/* harmony export */   "Bottomk": () => (/* binding */ Bottomk$1),
/* harmony export */   "By": () => (/* binding */ By$1),
/* harmony export */   "Ceil": () => (/* binding */ Ceil),
/* harmony export */   "Changes": () => (/* binding */ Changes),
/* harmony export */   "Clamp": () => (/* binding */ Clamp),
/* harmony export */   "ClampMax": () => (/* binding */ ClampMax),
/* harmony export */   "ClampMin": () => (/* binding */ ClampMin),
/* harmony export */   "Cos": () => (/* binding */ Cos),
/* harmony export */   "Cosh": () => (/* binding */ Cosh),
/* harmony export */   "Count": () => (/* binding */ Count$1),
/* harmony export */   "CountOverTime": () => (/* binding */ CountOverTime),
/* harmony export */   "CountValues": () => (/* binding */ CountValues$1),
/* harmony export */   "DayOfMonth": () => (/* binding */ DayOfMonth),
/* harmony export */   "DayOfWeek": () => (/* binding */ DayOfWeek),
/* harmony export */   "DaysInMonth": () => (/* binding */ DaysInMonth),
/* harmony export */   "Deg": () => (/* binding */ Deg),
/* harmony export */   "Delta": () => (/* binding */ Delta),
/* harmony export */   "Deriv": () => (/* binding */ Deriv),
/* harmony export */   "Div": () => (/* binding */ Div),
/* harmony export */   "Duration": () => (/* binding */ Duration),
/* harmony export */   "End": () => (/* binding */ End$1),
/* harmony export */   "Eql": () => (/* binding */ Eql),
/* harmony export */   "EqlRegex": () => (/* binding */ EqlRegex),
/* harmony export */   "EqlSingle": () => (/* binding */ EqlSingle),
/* harmony export */   "Exp": () => (/* binding */ Exp),
/* harmony export */   "Expr": () => (/* binding */ Expr),
/* harmony export */   "Floor": () => (/* binding */ Floor),
/* harmony export */   "FunctionCall": () => (/* binding */ FunctionCall),
/* harmony export */   "FunctionCallArgs": () => (/* binding */ FunctionCallArgs),
/* harmony export */   "FunctionCallBody": () => (/* binding */ FunctionCallBody),
/* harmony export */   "FunctionIdentifier": () => (/* binding */ FunctionIdentifier),
/* harmony export */   "Group": () => (/* binding */ Group$1),
/* harmony export */   "GroupLeft": () => (/* binding */ GroupLeft$1),
/* harmony export */   "GroupRight": () => (/* binding */ GroupRight$1),
/* harmony export */   "GroupingLabel": () => (/* binding */ GroupingLabel),
/* harmony export */   "GroupingLabelList": () => (/* binding */ GroupingLabelList),
/* harmony export */   "GroupingLabels": () => (/* binding */ GroupingLabels),
/* harmony export */   "Gte": () => (/* binding */ Gte),
/* harmony export */   "Gtr": () => (/* binding */ Gtr),
/* harmony export */   "HistogramQuantile": () => (/* binding */ HistogramQuantile),
/* harmony export */   "HoltWinters": () => (/* binding */ HoltWinters),
/* harmony export */   "Hour": () => (/* binding */ Hour),
/* harmony export */   "Idelta": () => (/* binding */ Idelta),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Ignoring": () => (/* binding */ Ignoring$1),
/* harmony export */   "Increase": () => (/* binding */ Increase),
/* harmony export */   "Irate": () => (/* binding */ Irate),
/* harmony export */   "LabelJoin": () => (/* binding */ LabelJoin),
/* harmony export */   "LabelMatchList": () => (/* binding */ LabelMatchList),
/* harmony export */   "LabelMatcher": () => (/* binding */ LabelMatcher),
/* harmony export */   "LabelMatchers": () => (/* binding */ LabelMatchers),
/* harmony export */   "LabelName": () => (/* binding */ LabelName),
/* harmony export */   "LabelReplace": () => (/* binding */ LabelReplace),
/* harmony export */   "LastOverTime": () => (/* binding */ LastOverTime),
/* harmony export */   "LineComment": () => (/* binding */ LineComment),
/* harmony export */   "Ln": () => (/* binding */ Ln),
/* harmony export */   "Log10": () => (/* binding */ Log10),
/* harmony export */   "Log2": () => (/* binding */ Log2),
/* harmony export */   "Lss": () => (/* binding */ Lss),
/* harmony export */   "Lte": () => (/* binding */ Lte),
/* harmony export */   "MatchOp": () => (/* binding */ MatchOp),
/* harmony export */   "MatrixSelector": () => (/* binding */ MatrixSelector),
/* harmony export */   "Max": () => (/* binding */ Max$1),
/* harmony export */   "MaxOverTime": () => (/* binding */ MaxOverTime),
/* harmony export */   "MetricIdentifier": () => (/* binding */ MetricIdentifier),
/* harmony export */   "MetricName": () => (/* binding */ MetricName),
/* harmony export */   "Min": () => (/* binding */ Min$1),
/* harmony export */   "MinOverTime": () => (/* binding */ MinOverTime),
/* harmony export */   "Minute": () => (/* binding */ Minute),
/* harmony export */   "Mod": () => (/* binding */ Mod),
/* harmony export */   "Month": () => (/* binding */ Month),
/* harmony export */   "Mul": () => (/* binding */ Mul),
/* harmony export */   "Neq": () => (/* binding */ Neq),
/* harmony export */   "NeqRegex": () => (/* binding */ NeqRegex),
/* harmony export */   "NumberLiteral": () => (/* binding */ NumberLiteral),
/* harmony export */   "Offset": () => (/* binding */ Offset$1),
/* harmony export */   "OffsetExpr": () => (/* binding */ OffsetExpr),
/* harmony export */   "On": () => (/* binding */ On$1),
/* harmony export */   "OnOrIgnoring": () => (/* binding */ OnOrIgnoring),
/* harmony export */   "Or": () => (/* binding */ Or$1),
/* harmony export */   "ParenExpr": () => (/* binding */ ParenExpr),
/* harmony export */   "Pi": () => (/* binding */ Pi),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "PredictLinear": () => (/* binding */ PredictLinear),
/* harmony export */   "PresentOverTime": () => (/* binding */ PresentOverTime),
/* harmony export */   "PromQL": () => (/* binding */ PromQL),
/* harmony export */   "Quantile": () => (/* binding */ Quantile$1),
/* harmony export */   "QuantileOverTime": () => (/* binding */ QuantileOverTime),
/* harmony export */   "Rad": () => (/* binding */ Rad),
/* harmony export */   "Rate": () => (/* binding */ Rate),
/* harmony export */   "Resets": () => (/* binding */ Resets),
/* harmony export */   "Round": () => (/* binding */ Round),
/* harmony export */   "Scalar": () => (/* binding */ Scalar),
/* harmony export */   "Sgn": () => (/* binding */ Sgn),
/* harmony export */   "Sin": () => (/* binding */ Sin),
/* harmony export */   "Sinh": () => (/* binding */ Sinh),
/* harmony export */   "Sort": () => (/* binding */ Sort),
/* harmony export */   "SortDesc": () => (/* binding */ SortDesc),
/* harmony export */   "Sqrt": () => (/* binding */ Sqrt),
/* harmony export */   "Start": () => (/* binding */ Start$1),
/* harmony export */   "Stddev": () => (/* binding */ Stddev$1),
/* harmony export */   "StddevOverTime": () => (/* binding */ StddevOverTime),
/* harmony export */   "Stdvar": () => (/* binding */ Stdvar$1),
/* harmony export */   "StdvarOverTime": () => (/* binding */ StdvarOverTime),
/* harmony export */   "StepInvariantExpr": () => (/* binding */ StepInvariantExpr),
/* harmony export */   "StringLiteral": () => (/* binding */ StringLiteral),
/* harmony export */   "Sub": () => (/* binding */ Sub),
/* harmony export */   "SubqueryExpr": () => (/* binding */ SubqueryExpr),
/* harmony export */   "Sum": () => (/* binding */ Sum$1),
/* harmony export */   "SumOverTime": () => (/* binding */ SumOverTime),
/* harmony export */   "Tan": () => (/* binding */ Tan),
/* harmony export */   "Tanh": () => (/* binding */ Tanh),
/* harmony export */   "Time": () => (/* binding */ Time),
/* harmony export */   "Timestamp": () => (/* binding */ Timestamp),
/* harmony export */   "Topk": () => (/* binding */ Topk$1),
/* harmony export */   "UnaryExpr": () => (/* binding */ UnaryExpr),
/* harmony export */   "UnaryOp": () => (/* binding */ UnaryOp),
/* harmony export */   "Unless": () => (/* binding */ Unless$1),
/* harmony export */   "Vector": () => (/* binding */ Vector),
/* harmony export */   "VectorSelector": () => (/* binding */ VectorSelector),
/* harmony export */   "Without": () => (/* binding */ Without$1),
/* harmony export */   "Year": () => (/* binding */ Year),
/* harmony export */   "inf": () => (/* binding */ inf$1),
/* harmony export */   "nan": () => (/* binding */ nan$1),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js");


// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf = 146,
  nan = 147,
  Bool = 1,
  Ignoring = 2,
  On = 3,
  GroupLeft = 4,
  GroupRight = 5,
  Offset = 6,
  Atan2 = 7,
  Avg = 8,
  Bottomk = 9,
  Count = 10,
  CountValues = 11,
  Group = 12,
  Max = 13,
  Min = 14,
  Quantile = 15,
  Stddev = 16,
  Stdvar = 17,
  Sum = 18,
  Topk = 19,
  By = 20,
  Without = 21,
  And = 22,
  Or = 23,
  Unless = 24,
  Start = 25,
  End = 26;

// Copyright 2021 The Prometheus Authors

const keywordTokens = {
    inf: inf,
    nan: nan,
    bool: Bool,
    ignoring: Ignoring,
    on: On,
    group_left: GroupLeft,
    group_right: GroupRight,
    offset: Offset,
};

const specializeIdentifier = (value, stack) => {
    return keywordTokens[value.toLowerCase()] || -1;
};

const contextualKeywordTokens = {
    avg: Avg,
    atan2: Atan2,
    bottomk: Bottomk,
    count: Count,
    count_values: CountValues,
    group: Group,
    max: Max,
    min: Min,
    quantile: Quantile,
    stddev: Stddev,
    stdvar: Stdvar,
    sum: Sum,
    topk: Topk,
    by: By,
    without: Without,
    and: And,
    or: Or,
    unless: Unless,
    start: Start,
    end: End,
};

const extendIdentifier = (value, stack) => {
    return contextualKeywordTokens[value.toLowerCase()] || -1;
};

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,absent_over_time:307, absent:309, abs:311, acos:313, acosh:315, asin:317, asinh:319, atan:321, atanh:323, avg_over_time:325, ceil:327, changes:329, clamp:331, clamp_max:333, clamp_min:335, cos:337, cosh:339, count_over_time:341, days_in_month:343, day_of_month:345, day_of_week:347, deg:349, delta:351, deriv:353, exp:355, floor:357, histogram_quantile:359, holt_winters:361, hour:363, idelta:365, increase:367, irate:369, label_replace:371, label_join:373, last_over_time:375, ln:377, log10:379, log2:381, max_over_time:383, min_over_time:385, minute:387, month:389, pi:391, predict_linear:393, present_over_time:395, quantile_over_time:397, rad:399, rate:401, resets:403, round:405, scalar:407, sgn:409, sin:411, sinh:413, sort:415, sort_desc:417, sqrt:419, stddev_over_time:421, stdvar_over_time:423, sum_over_time:425, tan:427, tanh:429, timestamp:431, time:433, vector:435, year:437};
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 13,
  states: "6[OYQPOOO&{QPOOOOQO'#C{'#C{O'QQPO'#CzQ']QQOOOOQO'#De'#DeO'WQPO'#DdOOQO'#E}'#E}O(jQPO'#FTOYQPO'#FPOYQPO'#FSOOQO'#FV'#FVO.fQSO'#FWO.nQQO'#FUOOQO'#FU'#FUOOQO'#Cy'#CyOOQO'#Df'#DfOOQO'#Dh'#DhOOQO'#Di'#DiOOQO'#Dj'#DjOOQO'#Dk'#DkOOQO'#Dl'#DlOOQO'#Dm'#DmOOQO'#Dn'#DnOOQO'#Do'#DoOOQO'#Dp'#DpOOQO'#Dq'#DqOOQO'#Dr'#DrOOQO'#Ds'#DsOOQO'#Dt'#DtOOQO'#Du'#DuOOQO'#Dv'#DvOOQO'#Dw'#DwOOQO'#Dx'#DxOOQO'#Dy'#DyOOQO'#Dz'#DzOOQO'#D{'#D{OOQO'#D|'#D|OOQO'#D}'#D}OOQO'#EO'#EOOOQO'#EP'#EPOOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETOOQO'#EU'#EUOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EY'#EYOOQO'#EZ'#EZOOQO'#E['#E[OOQO'#E]'#E]OOQO'#E^'#E^OOQO'#E_'#E_OOQO'#E`'#E`OOQO'#Ea'#EaOOQO'#Eb'#EbOOQO'#Ec'#EcOOQO'#Ed'#EdOOQO'#Ee'#EeOOQO'#Ef'#EfOOQO'#Eg'#EgOOQO'#Eh'#EhOOQO'#Ei'#EiOOQO'#Ej'#EjOOQO'#Ek'#EkOOQO'#El'#ElOOQO'#Em'#EmOOQO'#En'#EnOOQO'#Eo'#EoOOQO'#Ep'#EpOOQO'#Eq'#EqOOQO'#Er'#ErOOQO'#Es'#EsOOQO'#Et'#EtOOQO'#Eu'#EuOOQO'#Ev'#EvOOQO'#Ew'#EwOOQO'#Ex'#ExOOQO'#Ey'#EyOOQO'#Ez'#EzQOQPOOO0XQPO'#C|O0^QPO'#DRO'WQPO,59fO0eQQO,59fO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO7}QQO,5;gO8SQQO,5;jO8[QPO,5;yOOQO,5:O,5:OOOQO,5;i,5;iO8sQQO,5;kO8zQQO,5;nO:bQPO'#FYO:pQPO,5;rOOQO'#FX'#FXOOQO,5;r,5;rOOQO,5;p,5;pO:xQSO'#C}OOQO,59h,59hO;QQPO,59mO;YQQO'#DSOOQO,59m,59mOOQO1G/Q1G/QO0XQPO'#DWOAVQPO'#DVOAaQPO'#DVOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOAkQSO1G1ROOQO1G1U1G1UOAsQQO1G1UOAxQPO'#E}OOQO'#Fa'#FaOOQO1G1e1G1eOBTQPO1G1eOOQO1G1V1G1VOOQO'#FZ'#FZOBYQPO,5;tOB_QSO1G1^OOQO1G1^1G1^OOQO'#DP'#DPOBgQPO,59iOOQO'#DO'#DOOOQO,59i,59iOYQPO,59nOOQO1G/X1G/XOOQO,59r,59rOH_QPO,59qOHfQPO,59qOI}QQO7+$uOJ_QQO7+$uOKsQQO7+$uOLZQQO7+$uOMrQQO7+$uOOQO7+&m7+&mON]QQO7+&sOOQO7+&p7+&pONeQPO7+'POOQO1G1`1G1`OOQO1G1_1G1_OOQO7+&x7+&xONjQSO1G/TOOQO1G/T1G/TONrQQO1G/YOOQO1G/]1G/]ON|QPO1G/]OOQO<<J_<<J_O!&oQPO<<J_OOQO<<Jk<<JkOOQO1G/U1G/UOOQO7+$o7+$oOOQO7+$w7+$wOOQOAN?yAN?y",
  stateData: "!&t~O$ZOSkOS~OWQOXQOYQOZQO[QO]QO^QO_QO`QOaQObQOcQO!ZZO#t_O$WVO$XVO$[XO$_`O$`aO$abO$bcO$cdO$deO$efO$fgO$ghO$hiO$ijO$jkO$klO$lmO$mnO$noO$opO$pqO$qrO$rsO$stO$tuO$uvO$vwO$wxO$xyO$yzO$z{O${|O$|}O$}!OO%O!PO%P!QO%Q!RO%R!SO%S!TO%T!UO%U!VO%V!WO%W!XO%X!YO%Y!ZO%Z![O%[!]O%]!^O%^!_O%_!`O%`!aO%a!bO%b!cO%c!dO%d!eO%e!fO%f!gO%g!hO%h!iO%i!jO%j!kO%k!lO%l!mO%m!nO%n!oO%o!pO%p!qO%q!rO%r!sO%uWO%vWO%wVO%y[O~O!ZZO~Od!uOe!uO$[!vO~OU#POV!yOf!|Og!}Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O$S#QO%s#OO~O$W#SO$X#SO%w#SOW#wXX#wXY#wXZ#wX[#wX]#wX^#wX_#wX`#wXa#wXb#wXc#wX!Z#wX#t#wX$W#wX$X#wX$[#wX$_#wX$`#wX$a#wX$b#wX$c#wX$d#wX$e#wX$f#wX$g#wX$h#wX$i#wX$j#wX$k#wX$l#wX$m#wX$n#wX$o#wX$p#wX$q#wX$r#wX$s#wX$t#wX$u#wX$v#wX$w#wX$x#wX$y#wX$z#wX${#wX$|#wX$}#wX%O#wX%P#wX%Q#wX%R#wX%S#wX%T#wX%U#wX%V#wX%W#wX%X#wX%Y#wX%Z#wX%[#wX%]#wX%^#wX%_#wX%`#wX%a#wX%b#wX%c#wX%d#wX%e#wX%f#wX%g#wX%h#wX%i#wX%j#wX%k#wX%l#wX%m#wX%n#wX%o#wX%p#wX%q#wX%r#wX%u#wX%v#wX%w#wX%y#wX~Ot#VO%z#YO~O%y[OU#xXV#xXf#xXg#xXh#xXx#xX{#xX|#xX}#xX!O#xX!P#xX!Q#xX!R#xX!S#xX!T#xX!U#xX!V#xX$S#xX$V#xX%s#xX$^#xX$]#xX~O$[#[O~O$^#`O~PYOd!uOe!uOUnaVnafnagnahnaxna{na|na}na!Ona!Pna!Qna!Rna!Sna!Tna!Una!Vna$Sna$Vna%sna$^na$]na~OP#dOQ#bOR#bOWyPXyPYyPZyP[yP]yP^yP_yP`yPayPbyPcyP!ZyP#tyP$WyP$XyP$[yP$_yP$`yP$ayP$byP$cyP$dyP$eyP$fyP$gyP$hyP$iyP$jyP$kyP$lyP$myP$nyP$oyP$pyP$qyP$ryP$syP$tyP$uyP$vyP$wyP$xyP$yyP$zyP${yP$|yP$}yP%OyP%PyP%QyP%RyP%SyP%TyP%UyP%VyP%WyP%XyP%YyP%ZyP%[yP%]yP%^yP%_yP%`yP%ayP%byP%cyP%dyP%eyP%fyP%gyP%hyP%iyP%jyP%kyP%lyP%myP%nyP%oyP%pyP%qyP%ryP%uyP%vyP%wyP%yyP~O#p#jO~O!P#lO#p#kO~Oi#nOj#nO$WVO$XVO%u#mO%v#mO%wVO~O$^#qO~P']Ox!yOU#vaV#vaf#vag#vah#va{#va|#va}#va!O#va!P#va!Q#va!R#va!S#va!T#va!U#va!V#va$S#va$V#va%s#va$^#va$]#va~O!V#rO$O#rO$P#rO$Q#rO~O$]#tO%z#uO~Ot#vO$^#yO~O$]#zO$^#{O~O$]vX$^vX~P']OWyXXyXYyXZyX[yX]yX^yX_yX`yXayXbyXcyX!ZyX#tyX$WyX$XyX$[yX$_yX$`yX$ayX$byX$cyX$dyX$eyX$fyX$gyX$hyX$iyX$jyX$kyX$lyX$myX$nyX$oyX$pyX$qyX$ryX$syX$tyX$uyX$vyX$wyX$xyX$yyX$zyX${yX$|yX$}yX%OyX%PyX%QyX%RyX%SyX%TyX%UyX%VyX%WyX%XyX%YyX%ZyX%[yX%]yX%^yX%_yX%`yX%ayX%byX%cyX%dyX%eyX%fyX%gyX%hyX%iyX%jyX%kyX%lyX%myX%nyX%oyX%pyX%qyX%ryX%uyX%vyX%wyX%yyX~OS#}OT#}O~P;dOQ#bOR#bO~P;dO%t$UO%x$VO~O#p$WO~O$W#SO$X#SO%w#SO~O$[$XO~O#t$YO~Ot#VO%z$[O~O$]$]O$^$^O~OWyaXyaYyaZya[ya]ya^ya_ya`yaayabyacya!Zya#tya$Wya$Xya$_ya$`ya$aya$bya$cya$dya$eya$fya$gya$hya$iya$jya$kya$lya$mya$nya$oya$pya$qya$rya$sya$tya$uya$vya$wya$xya$yya$zya${ya$|ya$}ya%Oya%Pya%Qya%Rya%Sya%Tya%Uya%Vya%Wya%Xya%Yya%Zya%[ya%]ya%^ya%_ya%`ya%aya%bya%cya%dya%eya%fya%gya%hya%iya%jya%kya%lya%mya%nya%oya%pya%qya%rya%uya%vya%wya%yya~O$[#[O~PBoOS$aOT$aO$[ya~PBoOx!yOUwqfwqgwqhwq!Owq!Pwq!Qwq!Rwq!Swq!Twq!Uwq!Vwq$Swq$Vwq%swq$^wq$]wq~OVwq{wq|wq}wq~PHsOV!yO{!yO|!yO}!yO~PHsOV!yOx!yO{!yO|!yO}!yO!O!zO!P!zOUwqfwqgwqhwq$Swq$Vwq%swq$^wq$]wq~O!Qwq!Rwq!Swq!Twq!Uwq!Vwq~PJoO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~PJoOV!yOf!|Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~OUwqgwq$Swq$Vwq%swq$^wq$]wq~PLqO#p$cO%t$bO~O$^$dO~Ot#vO$^$fO~O$]vi$^vi~P']O$[#[OWyiXyiYyiZyi[yi]yi^yi_yi`yiayibyicyi!Zyi#tyi$Wyi$Xyi$_yi$`yi$ayi$byi$cyi$dyi$eyi$fyi$gyi$hyi$iyi$jyi$kyi$lyi$myi$nyi$oyi$pyi$qyi$ryi$syi$tyi$uyi$vyi$wyi$xyi$yyi$zyi${yi$|yi$}yi%Oyi%Pyi%Qyi%Ryi%Syi%Tyi%Uyi%Vyi%Wyi%Xyi%Yyi%Zyi%[yi%]yi%^yi%_yi%`yi%ayi%byi%cyi%dyi%eyi%fyi%gyi%hyi%iyi%jyi%kyi%lyi%myi%nyi%oyi%pyi%qyi%ryi%uyi%vyi%wyi%yyi~O%t$hO~O",
  goto: "(u$UPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$V$u%R%_%e%q%tP%z&T$uP&W&gPPPPPPPPPPP$u&q&}P&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}$uP'Z$u$uP$u$u'j$u'v(V(f(i(oPPP$uP(rQSOQ#TXQ#UYQ#_!vQ$P#eQ$Q#fQ$R#gQ$S#hQ$T#iR$_#ze_OXY!v#e#f#g#h#i#zeROXY!v#e#f#g#h#i#zQ!wRR#a!xQ#]!uQ#|#bQ$`#}R$g$aR#w#[Q#x#[R$e$]Q!xRQ#RUR#a!wR#^!vQ#e!yQ#f!zQ#g!{Q#h!|R#i!}Y#c!y!z!{!|!}R$O#deUOXY!v#e#f#g#h#i#zeTOXY!v#e#f#g#h#i#zd_OXY!v#e#f#g#h#i#zR#o#QeYOXY!v#e#f#g#h#i#zd]OXY!v#e#f#g#h#i#zR!tPd^OXY!v#e#f#g#h#i#zR#Z]R#W[Q#X[R$Z#tR#s#VR#p#Q",
  nodeNames: "âš  Bool Ignoring On GroupLeft GroupRight Offset Atan2 Avg Bottomk Count CountValues Group Max Min Quantile Stddev Stdvar Sum Topk By Without And Or Unless Start End LineComment PromQL Expr AggregateExpr AggregateOp AggregateModifier GroupingLabels GroupingLabelList GroupingLabel LabelName FunctionCallBody FunctionCallArgs BinaryExpr Pow BinModifiers OnOrIgnoring Mul Div Mod Add Sub Eql Gte Gtr Lte Lss Neq FunctionCall FunctionIdentifier AbsentOverTime Identifier Absent Abs Acos Acosh Asin Asinh Atan Atanh AvgOverTime Ceil Changes Clamp ClampMax ClampMin Cos Cosh CountOverTime DaysInMonth DayOfMonth DayOfWeek Deg Delta Deriv Exp Floor HistogramQuantile HoltWinters Hour Idelta Increase Irate LabelReplace LabelJoin LastOverTime Ln Log10 Log2 MaxOverTime MinOverTime Minute Month Pi PredictLinear PresentOverTime QuantileOverTime Rad Rate Resets Round Scalar Sgn Sin Sinh Sort SortDesc Sqrt StddevOverTime StdvarOverTime SumOverTime Tan Tanh Timestamp Time Vector Year MatrixSelector Duration NumberLiteral OffsetExpr ParenExpr StringLiteral SubqueryExpr UnaryExpr UnaryOp VectorSelector MetricIdentifier LabelMatchers LabelMatchList LabelMatcher MatchOp EqlSingle EqlRegex NeqRegex StepInvariantExpr At AtModifierPreprocessors MetricName",
  maxTerm: 226,
  skippedNodes: [0,27],
  repeatNodeCount: 0,
  tokenData: "1R~RwX^#lpq#lqr$ars$tst%huv%swx%xxy&gyz&lz{&q{|&v|}&}}!O'S!O!P'Z!P!Q(Z!Q!R(`!R![)W![!]-r!^!_.n!_!`.{!`!a/b!b!c/o!c!}/t!}#O0[#P#Q0a#Q#R0f#R#S/t#S#T0k#T#o/t#o#p0w#q#r0|#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~#qY$Z~X^#lpq#l#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~$dQ!_!`$j#r#s$o~$oO!V~~$tO$Q~~$yU#t~OY$tZr$trs%]s#O$t#O#P%b#P~$t~%bO#t~~%ePO~$t~%mQk~OY%hZ~%h~%xO}~~%}U#t~OY%xZw%xwx%]x#O%x#O#P&a#P~%x~&dPO~%x~&lO$[~~&qO$^~~&vO{~R&}O%vP!OQ~'SO$]~R'ZO%uP!PQP'^P!Q!['aP'fR%wP!Q!['a!g!h'o#X#Y'oP'rR{|'{}!O'{!Q![(RP(OP!Q![(RP(WP%wP!Q![(R~(`O|~R(eZ%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#l#m-W#m#n,iR)]Y%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#m#n,iQ*QP#pQ!Q![*TQ*WS!Q![*T#[#]*d#a#b*x#g#h+lQ*iP#pQ!Q![*lQ*oR!Q![*l#a#b*x#g#h+lQ*}Q#pQ!Q![+T#g#h+gQ+WR!Q![+T#a#b+a#g#h+lQ+dP#g#h+gQ+lO#pQQ+qP#pQ!Q![+tQ+wQ!Q![+t#a#b+aQ,SP#pQ!Q![,VQ,YT!Q![,V#W#X){#[#]*d#a#b*x#g#h+lQ,nP#pQ!Q![,qQ,tU!Q![,q#W#X){#[#]*d#a#b*x#g#h+l#k#l+}P-ZR!Q![-d!c!i-d#T#Z-dP-iR%wP!Q![-d!c!i-d#T#Z-dV-yT%xS!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.YR._T!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.Y~.sP!U~!_!`.v~.{O!T~~/QQ$OP!_!`/W#r#s/]Q/]O!QQ~/bO$P~~/gP!S~!_!`/j~/oO!R~~/tO$S~V/{T!ZRtS!Q![/t![!].Y!c!}/t#R#S/t#T#o/t~0aO%s~~0fO%t~~0kOx~~0nRO#S0k#S#T%]#T~0k~0|O%y~~1RO%z~",
  tokenizers: [0, 1, 2],
  topRules: {"PromQL":[0,28],"MetricName":[1,144]},
  specialized: [{term: 57, get: (value, stack) => (specializeIdentifier(value) << 1)},{term: 57, get: (value, stack) => (extendIdentifier(value) << 1) | 1},{term: 57, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 0
});
// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf$1 = 146,
  nan$1 = 147,
  Bool$1 = 1,
  Ignoring$1 = 2,
  On$1 = 3,
  GroupLeft$1 = 4,
  GroupRight$1 = 5,
  Offset$1 = 6,
  Atan2$1 = 7,
  Avg$1 = 8,
  Bottomk$1 = 9,
  Count$1 = 10,
  CountValues$1 = 11,
  Group$1 = 12,
  Max$1 = 13,
  Min$1 = 14,
  Quantile$1 = 15,
  Stddev$1 = 16,
  Stdvar$1 = 17,
  Sum$1 = 18,
  Topk$1 = 19,
  By$1 = 20,
  Without$1 = 21,
  And$1 = 22,
  Or$1 = 23,
  Unless$1 = 24,
  Start$1 = 25,
  End$1 = 26,
  LineComment = 27,
  PromQL = 28,
  Expr = 29,
  AggregateExpr = 30,
  AggregateOp = 31,
  AggregateModifier = 32,
  GroupingLabels = 33,
  GroupingLabelList = 34,
  GroupingLabel = 35,
  LabelName = 36,
  FunctionCallBody = 37,
  FunctionCallArgs = 38,
  BinaryExpr = 39,
  Pow = 40,
  BinModifiers = 41,
  OnOrIgnoring = 42,
  Mul = 43,
  Div = 44,
  Mod = 45,
  Add = 46,
  Sub = 47,
  Eql = 48,
  Gte = 49,
  Gtr = 50,
  Lte = 51,
  Lss = 52,
  Neq = 53,
  FunctionCall = 54,
  FunctionIdentifier = 55,
  AbsentOverTime = 56,
  Identifier = 57,
  Absent = 58,
  Abs = 59,
  Acos = 60,
  Acosh = 61,
  Asin = 62,
  Asinh = 63,
  Atan = 64,
  Atanh = 65,
  AvgOverTime = 66,
  Ceil = 67,
  Changes = 68,
  Clamp = 69,
  ClampMax = 70,
  ClampMin = 71,
  Cos = 72,
  Cosh = 73,
  CountOverTime = 74,
  DaysInMonth = 75,
  DayOfMonth = 76,
  DayOfWeek = 77,
  Deg = 78,
  Delta = 79,
  Deriv = 80,
  Exp = 81,
  Floor = 82,
  HistogramQuantile = 83,
  HoltWinters = 84,
  Hour = 85,
  Idelta = 86,
  Increase = 87,
  Irate = 88,
  LabelReplace = 89,
  LabelJoin = 90,
  LastOverTime = 91,
  Ln = 92,
  Log10 = 93,
  Log2 = 94,
  MaxOverTime = 95,
  MinOverTime = 96,
  Minute = 97,
  Month = 98,
  Pi = 99,
  PredictLinear = 100,
  PresentOverTime = 101,
  QuantileOverTime = 102,
  Rad = 103,
  Rate = 104,
  Resets = 105,
  Round = 106,
  Scalar = 107,
  Sgn = 108,
  Sin = 109,
  Sinh = 110,
  Sort = 111,
  SortDesc = 112,
  Sqrt = 113,
  StddevOverTime = 114,
  StdvarOverTime = 115,
  SumOverTime = 116,
  Tan = 117,
  Tanh = 118,
  Timestamp = 119,
  Time = 120,
  Vector = 121,
  Year = 122,
  MatrixSelector = 123,
  Duration = 124,
  NumberLiteral = 125,
  OffsetExpr = 126,
  ParenExpr = 127,
  StringLiteral = 128,
  SubqueryExpr = 129,
  UnaryExpr = 130,
  UnaryOp = 131,
  VectorSelector = 132,
  MetricIdentifier = 133,
  LabelMatchers = 134,
  LabelMatchList = 135,
  LabelMatcher = 136,
  MatchOp = 137,
  EqlSingle = 138,
  EqlRegex = 139,
  NeqRegex = 140,
  StepInvariantExpr = 141,
  At = 142,
  AtModifierPreprocessors = 143,
  MetricName = 144;




/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.18.3-1883c70fa6-db8526226a.zip/node_modules/@babel/runtime/helpers/esm/extends.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.18.3-1883c70fa6-db8526226a.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _objectWithoutPropertiesLoose)
/* harmony export */ });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultBufferLength": () => (/* binding */ DefaultBufferLength),
/* harmony export */   "MountedTree": () => (/* binding */ MountedTree),
/* harmony export */   "NodeProp": () => (/* binding */ NodeProp),
/* harmony export */   "NodeSet": () => (/* binding */ NodeSet),
/* harmony export */   "NodeType": () => (/* binding */ NodeType),
/* harmony export */   "Parser": () => (/* binding */ Parser),
/* harmony export */   "Tree": () => (/* binding */ Tree),
/* harmony export */   "TreeBuffer": () => (/* binding */ TreeBuffer),
/* harmony export */   "TreeCursor": () => (/* binding */ TreeCursor),
/* harmony export */   "TreeFragment": () => (/* binding */ TreeFragment),
/* harmony export */   "parseMixed": () => (/* binding */ parseMixed)
/* harmony export */ });
// FIXME profile adding a per-Tree TreeNode cache, validating it by
// parent pointer
/// The default maximum length of a `TreeBuffer` node (1024).
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)
/// can have metadata associated with it in props. Instances of this
/// class represent prop names.
class NodeProp {
    /// Create a new node prop type.
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#common.NodeSet.extend) or
    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
    /// prop values for each node type in the set. Takes a [match
    /// object](#common.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
/// The hash of the [context](#lr.ContextTracker.constructor)
/// that the node was parsed in, if any. Used to limit reuse of
/// contextual nodes.
NodeProp.contextHash = new NodeProp({ perNode: true });
/// The distance beyond the end of the node that the tokenizer
/// looked ahead for any of the tokens inside the node. (The LR
/// parser only stores this when it is larger than 25, for
/// efficiency reasons.)
NodeProp.lookAhead = new NodeProp({ perNode: true });
/// This per-node prop is used to replace a given node, or part of a
/// node, with another tree. This is useful to include trees from
/// different languages.
NodeProp.mounted = new NodeProp({ perNode: true });
/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on
/// a tree node to indicate that parts of its content are
/// represented by another tree.
class MountedTree {
    constructor(
    /// The inner tree.
    tree, 
    /// If this is null, this tree replaces the entire node (it will
    /// be included in the regular iteration instead of its host
    /// node). If not, only the given ranges are considered to be
    /// covered by this tree. This is used for trees that are mixed in
    /// a way that isn't strictly hierarchical. Such mounted trees are
    /// only entered by [`resolveInner`](#common.Tree.resolveInner)
    /// and [`enter`](#common.SyntaxNode.enter).
    overlay, 
    /// The parser used to create this subtree.
    parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
}
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#common.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#common.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a numeric array. Each parser
/// [has](#lr.LRParser.nodeSet) a node set, and [tree
/// buffers](#common.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536) node
/// types in it, so that the ids fit into 16-bit typed array slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#common.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the [`TreeCursor`](#common.TreeCursor) or
/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
/// a view on some part of this data structure, and can be used to
/// move around to adjacent nodes.
class Tree {
    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    constructor(
    /// The type of the top node.
    type, 
    /// This node's child nodes.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length, 
    /// Per-node [node props](#common.NodeProp) to associate with this node.
    props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        /// @internal
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    /// @internal
    toString() {
        let mounted = this.prop(NodeProp.mounted);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#common.TreeCursor) that, unlike regular
    /// cursors, doesn't skip through
    /// [anonymous](#common.NodeType.isAnonymous) nodes and doesn't
    /// automatically enter mounted nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, 1 /* Full */);
    }
    /// Get a [syntax node](#common.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#common.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    /// Like [`resolve`](#common.Tree.resolve), but will enter
    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    /// pointing into the innermost overlaid tree at the given position
    /// (with parent links going through all parent structure, including
    /// the host trees).
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, that node will
    /// not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor(), get = () => c.node;;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to, get);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Get the value of the given [node prop](#common.NodeProp) for this
    /// node. Works with both per-node and per-type props.
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
    /// format that can be passed to the [`Tree`](#common.Tree)
    /// constructor.
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    /// Balance the direct children of this tree, producing a copy of
    /// which may have children grouped into subtrees with type
    /// [`NodeType.none`](#common.NodeType^none).
    balance(config = {}) {
        return this.children.length <= 8 /* BranchFactor */ ? this :
            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer.
    constructor(
    /// The buffer's content.
    buffer, 
    /// The total length of the group of nodes in the buffer.
    length, 
    /// The node set used in this buffer.
    set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    /// @internal
    get type() { return NodeType.none; }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    /// @internal
    slice(startI, endI, from, to) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI);
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
        }
        return new TreeBuffer(copy, to - from, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2 /* Before */: return from < pos;
        case -1 /* AtOrBefore */: return to >= pos && from < pos;
        case 0 /* Around */: return from < pos && to > pos;
        case 1 /* AtOrAfter */: return from <= pos && to > pos;
        case 2 /* After */: return to > pos;
        case 4 /* DontCare */: return true;
    }
}
function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
        let last = scan.lastChild;
        if (!last || last.to != scan.to)
            break;
        if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
        }
        else {
            scan = last;
        }
    }
    return node;
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    // Must go up out of overlays when those do not overlap with pos
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, true)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, overlays);
        if (!inner)
            return node;
        node = inner;
    }
}
class TreeNode {
    constructor(node, _from, 
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
        this.node = node;
        this._from = _from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get from() { return this._from; }
    get to() { return this._from + this.node.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent._from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & 2 /* NoEnterBuffer */)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & 1 /* Full */) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & 1 /* Full */) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & 1 /* Full */) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & 1 /* Full */) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent.node.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos, -2 /* Before */); }
    enter(pos, side, overlays = true, buffers = true) {
        let mounted;
        if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, buffers ? 0 : 2 /* NoEnterBuffer */);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return this.node; }
    toTree() { return this.node; }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }
    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.child(1, pos, 2 /* After */); }
    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }
    enter(pos, side, overlays, buffers = true) {
        if (!buffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
            children.push(buffer.slice(startI, endI, from, to));
            positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, 
    /// @internal
    mode = 0) {
        this.mode = mode;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }
    /// Move the cursor to the first child that ends after `pos`.
    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }
    /// Move to the last child that starts before `pos`.
    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }
    /// Move the cursor to the child around `pos`. If side is -1 the
    /// child may end at that position, when 1 it may start there. This
    /// will also enter [overlaid](#common.MountedTree.overlay)
    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    /// set to false.
    enter(pos, side, overlays = true, buffers = true) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & 1 /* Full */), buffers));
        return buffers ? this.enterChild(1, pos, side) : false;
    }
    /// Move to the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & 1 /* Full */) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & 1 /* Full */) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                    let child = parent.node.children[i];
                    if ((this.mode & 1 /* Full */) || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty or `enter` is false, its next sibling or
    /// the next sibling of the first parent node that has one.
    next(enter = true) { return this.move(1, enter); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by its last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev(enter = true) { return this.move(-1, enter); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#common.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#common.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead;
        while (size < 0) {
            cursor.next();
            if (size == -1 /* Reuse */) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3 /* ContextChange */) { // Context change
                contextHash = id;
                return;
            }
            else if (size == -4 /* LookAhead */) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function makeBalanced(type) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead = 0, props) {
        if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat && nodeSize >= 0) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3 /* ContextChange */)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3 /* ContextChange */) {
            contextHash = id;
        }
        else if (size == -4 /* LookAhead */) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(
// The type the balanced tree's inner nodes.
balanceType, 
// The direct children and their positions
children, positions, 
// The index range in children/positions to use
from, to, 
// The start position of the nodes, relative to their parent.
start, 
// Length of the outer node
length, 
// Function to build the top node of the balanced tree
mkTop, 
// Function to build internal nodes for the balanced tree
mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom]; // Only trees can have a size > 1
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}

/// Tree fragments are used during [incremental
/// parsing](#common.Parser.startParse) to track parts of old trees
/// that can be reused in a new parse. An array of fragments is used
/// to track regions of an old tree whose nodes might be reused in new
/// parses. Use the static
/// [`applyChanges`](#common.TreeFragment^applyChanges) method to
/// update fragments for document changes.
class TreeFragment {
    /// Construct a tree fragment.
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);
    }
    /// Whether the start of the fragment represents the start of a
    /// parse, or the end of a change. (In the second case, it may not
    /// be safe to reuse some nodes at the start, depending on the
    /// parsing algorithm.)
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    /// Whether the end of the fragment represents the end of a
    /// full-document parse, or the start of a change.
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the resulting
    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    /// true.
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
/// A superclass that parsers should extend.
class Parser {
    /// Start a parse, returning a [partial parse](#common.PartialParse)
    /// object. [`fragments`](#common.TreeFragment) can be passed in to
    /// make the parse incremental.
    ///
    /// By default, the entire input is parsed. You can pass `ranges`,
    /// which should be a sorted array of non-empty, non-overlapping
    /// ranges, to parse only those ranges. The tree returned in that
    /// case will start at `ranges[0].from`.
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    /// Run a full parse, returning the resulting tree.
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}

/// Create a parse wrapper that, after the inner parse completes,
/// scans its tree for mixed language regions with the `nest`
/// function, runs the resulting [inner parses](#common.NestedParse),
/// and then [mounts](#common.NodeProp^mounted) their results onto the
/// tree.
///
/// The nesting function is passed a cursor to provide context for a
/// node, but _should not_ move that cursor, only inspect its
/// properties and optionally access its
/// [node object](#common.TreeCursor.node).
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, ranges) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.ranges = ranges;
    }
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            // This is a somewhat dodgy but super helpful hack where we
            // patch up nodes created by the inner parse (and thus
            // presumably not aliased anywhere else) to hold the information
            // about the inner parse.
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].ranges[0].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), 1 /* Full */);
        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {
            let enter = true, range;
            if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2 /* Full */;
            }
            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
                    if (ranges.length)
                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new Range(cursor.from, cursor.to);
                if (range.from < range.to)
                    overlay.ranges.push(range);
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length)
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;
    }
    return 0 /* None */;
}
// Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];
        nodes.push(buf.slice(startI, endI, from, to));
        positions.push(from - off);
    }
}
// This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.
function materialize(cursor) {
    let { node } = cursor, depth = 0;
    // Scan up to the nearest tree
    do {
        cursor.parent();
        depth++;
    } while (!cursor.tree);
    // Find the index of the buffer in that tree
    let i = 0, base = cursor.tree, off = 0;
    for (;; i++) {
        off = base.positions[i] + cursor.from;
        if (off <= node.from && off + base.children[i].length >= node.to)
            break;
    }
    let buf = base.children[i], b = buf.buffer;
    // Split a level in the buffer, putting the nodes before and after
    // the child that contains `node` into new buffers.
    function split(startI, endI, type, innerOffset, length) {
        let i = startI;
        while (b[i + 2] + off <= node.from)
            i = b[i + 3];
        let children = [], positions = [];
        sliceBuf(buf, startI, i, children, positions, innerOffset);
        let from = b[i + 1], to = b[i + 2];
        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;
        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));
        positions.push(from - innerOffset);
        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);
        return new Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
    // Move the cursor back to the target node
    for (let d = 0; d <= depth; d++)
        cursor.childAfter(node.from);
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.fullCursor();
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
// Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
        }
    }
    return result;
}




/***/ }),

/***/ "./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContextTracker": () => (/* binding */ ContextTracker),
/* harmony export */   "ExternalTokenizer": () => (/* binding */ ExternalTokenizer),
/* harmony export */   "InputStream": () => (/* binding */ InputStream),
/* harmony export */   "LRParser": () => (/* binding */ LRParser),
/* harmony export */   "Stack": () => (/* binding */ Stack)
/* harmony export */ });
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js");


/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// The parse that this stack is part of @internal
    p, 
    /// Holds state, input pos, buffer index triplets for all but the
    /// top state @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    /// @internal
    curContext, 
    /// @internal
    lookAhead = 0, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.p = p;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(p, state, pos = 0) {
        let cx = p.parser.context;
        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /// The stack's current [context](#lr.ContextTracker) value, if
    /// any. Its type will depend on the context tracker's type
    /// parameter, or it will be `null` if there is no context
    /// tracker.
    get context() { return this.curContext ? this.curContext.context : null; }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.p;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            // Zero-depth reductions are a special caseâ€”they add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.reduceContext(type, this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
        this.reduceContext(type, start);
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        let start = this.pos;
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let nextState = action, { parser } = this.p;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            this.shiftContext(next, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            this.pos = nextEnd;
            this.shiftContext(next, start);
            if (next <= this.p.parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /// @internal
    useNode(value, next) {
        let index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190 /* Delete */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = [];
            for (let i = 0, s; i < nextStates.length; i += 2) {
                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                    best.push(nextStates[i], s);
            }
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {
                    let s = nextStates[i + 1];
                    if (!best.some((v, i) => (i & 1) && v == s))
                        best.push(nextStates[i], s);
                }
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {
            let s = nextStates[i + 1];
            if (s == this.state)
                continue;
            let stack = this.split();
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.pushState(s, this.pos);
            stack.shiftContext(nextStates[i], this.pos);
            stack.score -= 200 /* Insert */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        let { parser } = this.p;
        if (!parser.validAction(this.state, reduce)) {
            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;
            let target = this.stack.length - depth * 3;
            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)
                return false;
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {
            if (!this.forceReduce()) {
                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);
                break;
            }
        }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.p;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.p.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }
    shiftContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    /// @internal
    emitContext() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3)
            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    /// @internal
    emitLookAhead() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4)
            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
        if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash)
                this.emitContext();
            this.curContext = newCx;
        }
    }
    /// @internal
    setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
        }
    }
    /// @internal
    close() {
        if (this.curContext && this.curContext.tracker.strict)
            this.emitContext();
        if (this.lookAhead > 0)
            this.emitLookAhead();
    }
}
class StackContext {
    constructor(tracker, context) {
        this.tracker = tracker;
        this.context = context;
        this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
}
var Recover;
(function (Recover) {
    Recover[Recover["Insert"] = 200] = "Insert";
    Recover[Recover["Delete"] = 190] = "Delete";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(start) {
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.stack == this.start.stack)
                this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
        }
        else {
            this.base -= (depth - 1) * 3;
        }
        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

class CachedToken {
    constructor() {
        this.start = -1;
        this.value = -1;
        this.end = -1;
        this.extended = -1;
        this.lookAhead = 0;
        this.mask = 0;
        this.context = 0;
    }
}
const nullToken = new CachedToken;
/// [Tokenizers](#lr.ExternalTokenizer) interact with the input
/// through this interface. It presents the input as a stream of
/// characters, tracking lookahead and hiding the complexity of
/// [ranges](#common.Parser.parse^ranges) from tokenizer code.
class InputStream {
    /// @internal
    constructor(
    /// @internal
    input, 
    /// @internal
    ranges) {
        this.input = input;
        this.ranges = ranges;
        /// @internal
        this.chunk = "";
        /// @internal
        this.chunkOff = 0;
        /// Backup chunk
        this.chunk2 = "";
        this.chunk2Pos = 0;
        /// The character code of the next code unit in the input, or -1
        /// when the stream is at the end of the input.
        this.next = -1;
        /// @internal
        this.token = nullToken;
        this.rangeIndex = 0;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
    }
    resolveOffset(offset, assoc) {
        let range = this.range, index = this.rangeIndex;
        let pos = this.pos + offset;
        while (pos < range.from) {
            if (!index)
                return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
            if (index == this.ranges.length - 1)
                return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
        }
        return pos;
    }
    /// Look at a code unit near the stream position. `.peek(0)` equals
    /// `.next`, `.peek(-1)` gives you the previous character, and so
    /// on.
    ///
    /// Note that looking around during tokenizing creates dependencies
    /// on potentially far-away content, which may reduce the
    /// effectiveness incremental parsingâ€”when looking forwardâ€”or even
    /// cause invalid reparses when looking backward more than 25 code
    /// units, since the library does not track lookbehind.
    peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
        }
        else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null)
                return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            }
            else {
                let i = this.rangeIndex, range = this.range;
                while (range.to <= pos)
                    range = this.ranges[++i];
                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                if (pos + this.chunk2.length > range.to)
                    this.chunk2 = this.chunk2.slice(0, range.to - pos);
                result = this.chunk2.charCodeAt(0);
            }
        }
        if (pos >= this.token.lookAhead)
            this.token.lookAhead = pos + 1;
        return result;
    }
    /// Accept a token. By default, the end of the token is set to the
    /// current stream position, but you can pass an offset (relative to
    /// the stream position) to change that.
    acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start)
            throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
    }
    getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk, chunkPos } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
        }
        else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
        }
    }
    readNext() {
        if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length)
                return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /// Move the stream forward N (defaults to 1) code units. Returns
    /// the new value of [`next`](#lr.InputStream.next).
    advance(n = 1) {
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
            if (this.rangeIndex == this.ranges.length - 1)
                return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead)
            this.token.lookAhead = this.pos + 1;
        return this.readNext();
    }
    setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
    }
    /// @internal
    reset(pos, token) {
        if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
        }
        else {
            this.token = nullToken;
        }
        if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
                this.setDone();
                return this;
            }
            while (pos < this.range.from)
                this.range = this.ranges[--this.rangeIndex];
            while (pos >= this.range.to)
                this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                this.chunkOff = pos - this.chunkPos;
            }
            else {
                this.chunk = "";
                this.chunkOff = 0;
            }
            this.readNext();
        }
        return this;
    }
    /// @internal
    read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
        if (from >= this.range.from && to <= this.range.to)
            return this.input.read(from, to);
        let result = "";
        for (let r of this.ranges) {
            if (r.from >= to)
                break;
            if (r.to > from)
                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
        }
        return result;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, stack) { readToken(this.data, input, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// `@external tokens` declarations in the grammar should resolve to
/// an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream, scans for the types of tokens it
    /// recognizes at the stream's position, and calls
    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    /// one.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, stack, group) {
    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;
    scan: for (;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {
                    input.acceptToken(term);
                    break;
                }
            }
        // Do a binary search on the state's edges
        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                input.advance();
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output
const verbose = typeof process != "undefined" && /\bparse\b/.test(({"NODE_ENV":"development"}).LOG);
let stackIDs = null;
var Safety;
(function (Safety) {
    Safety[Safety["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree, pos, side) {
    let cursor = tree.fullCursor();
    cursor.moveTo(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))
                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments, nodeSet) {
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {
                if (start == pos) {
                    if (start < this.safeFrom)
                        return null;
                    let end = start + next.length;
                    if (end <= this.safeTo) {
                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);
                        if (!lookAhead || end + lookAhead < this.fragment.to)
                            return next;
                    }
                }
                this.index[last]++;
                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
            else {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
        }
    }
}
class TokenCache {
    constructor(parser, stream) {
        this.stream = stream;
        this.tokens = [];
        this.mainToken = null;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.p, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        let context = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                this.updateCachedToken(token, tokenizer, stack);
                token.mask = mask;
                token.context = context;
            }
            if (token.lookAhead > token.end + 25 /* Margin */)
                lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (lookAhead)
            stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
            main = new CachedToken;
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
    }
    getMainToken(stack) {
        if (this.mainToken)
            return this.mainToken;
        let main = new CachedToken, { pos, p } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;
        return main;
    }
    updateCachedToken(token, tokenizer, stack) {
        tokenizer.token(this.stream.reset(stack.pos, token), stack);
        if (token.value > -1) {
            let { parser } = stack.p;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else {
            token.value = 0 /* Err */;
            token.end = Math.min(stack.p.stream.end, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.p, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 2), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    // When two stacks have been running independently long enough to
    // add this many elements to their buffers, prune one.
    Rec[Rec["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    // Once a stack reaches this depth (in .stack.length) force-reduce
    // it back to CutTo to avoid creating trees that overflow the stack
    // on recursive traversal.
    Rec[Rec["CutDepth"] = 15000] = "CutDepth";
    Rec[Rec["CutTo"] = 9000] = "CutTo";
})(Rec || (Rec = {}));
class Parse {
    constructor(parser, input, fragments, ranges) {
        this.parser = parser;
        this.input = input;
        this.ranges = ranges;
        this.recovering = 0;
        this.nextStackID = 0x2654; // â™”, â™•, â™–, â™—, â™˜, â™™, â™ , â™¡, â™¢, â™£, â™¤, â™¥, â™¦, â™§
        this.minStackPos = 0;
        this.reused = [];
        this.stoppedAt = null;
        this.stream = new InputStream(input, ranges);
        this.tokens = new TokenCache(parser, this.stream);
        this.topTerm = parser.top[1];
        let { from } = ranges[0];
        this.stacks = [Stack.start(this, parser.top[0], from)];
        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4
            ? new FragmentCursor(fragments, parser.nodeSet) : null;
    }
    get parsedPos() {
        return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i];
            for (;;) {
                this.tokens.mainToken = null;
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.getMainToken(stack);
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]
                : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.minStackPos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.minStackPos)
                this.minStackPos = newStacks[i].pos;
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt)
            return stack.forceReduce() ? stack : null;
        if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        if (stack.stack.length >= 15000 /* CutDepth */) {
            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }
        }
        let actions = this.tokens.getActions(stack);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done)
                    continue;
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done)
                    break;
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.stream.end > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
        stack.close();
        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm });
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
const id = x => x;
/// Context trackers are used to track stateful context (such as
/// indentation in the Python grammar, or parent elements in the XML
/// grammar) needed by external tokenizers. You declare them in a
/// grammar file as `@context exportName from "module"`.
///
/// Context values should be immutable, and can be updated (replaced)
/// on shift or reduce actions.
///
/// The export used in a `@context` declaration should be of this
/// type.
class ContextTracker {
    /// Define a context tracker.
    constructor(spec) {
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (() => 0);
        this.strict = spec.strict !== false;
    }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {
    /// @internal
    constructor(spec) {
        super();
        /// @internal
        this.wrappers = [];
        if (spec.version != 13 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        this.strict = false;
        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
        let parse = new Parse(this, input, fragments, ranges);
        for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
        return parse;
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {
                let value = this.data[i + 1];
                if (!result.some((v, i) => (i & 1) && v == value))
                    result.push(this.data[i], value);
            }
        }
        return result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(LRParser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.contextTracker)
            copy.context = config.contextTracker;
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.wrap)
            copy.wrappers = copy.wrappers.concat(config.wrap);
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// The type of top node produced by the parser.
    get topNode() { return this.nodeSet.types[this.top[1]]; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new LRParser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        let stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&
            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtHQUFBQSxvQkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QndGO0FBQzFDO0FBQzNCO0FBQ1U7O0FBRXpDO0FBQ0EsWUFBWSx5Q0FBWTtBQUN4QjtBQUNBLFNBQVMsOENBQWlCO0FBQzFCO0FBQ0EsR0FBRztBQUNIOztBQUVBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsMkNBQWM7QUFDdEM7QUFDQTs7QUFFQTtBQUNBLFlBQVksOENBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSwrQkFBK0IsSUFBSTtBQUNoRDtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLCtCQUErQixJQUFJO0FBQ2pEO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyx1Q0FBdUMsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSwrQkFBK0IsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoN0I0QztBQUNjO0FBQ1o7QUFDQTtBQUNJO0FBQ0U7QUFDcEQ7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0QsbUNBQW1DLCtCQUErQjtBQUNsRTtBQUNBLGdKQUFnSiw4QkFBOEI7QUFDOUs7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1EQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtDQUFRLEdBQUc7QUFDckQsZ0NBQWdDLDZDQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlEQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5REFBYTtBQUNoRDtBQUNBLDJCQUEyQiw2Q0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsd0NBQXdDLDZCQUE2QjtBQUNyRSx3Q0FBd0MsNkJBQTZCO0FBQ3JFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1REFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMERBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwwQ0FBMEMseURBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLHNEQUFnQjtBQUNVO0FBQzVCOzs7Ozs7Ozs7Ozs7O0FDNU5zRDtBQUMvQztBQUNQLGVBQWUsK0RBQWdCO0FBQy9CO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNKcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUs7Ozs7Ozs7Ozs7OztBQ2xDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0ZvQjtBQUNSOztBQUUvQjtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDQTtBQUNQLDZCQUFlLG9DQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFEQUFLO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcseURBQVM7QUFDcEIsSUFBSTs7O0FBR0o7QUFDQSw4QkFBOEI7QUFDOUIsSUFBSSxlQUFlOzs7QUFHbkI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDL0QyQjtBQUNFO0FBQzdCLFNBQVMsbURBQUcsYUFBYSxnREFBSTtBQUM3QixpRUFBZSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hvQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLGVBQWUsMkRBQW9CO0FBQ25DO0FBQ0Esd0RBQXdELElBQUksMkZBQTJGLElBQUksb0JBQW9CLElBQUksNlNBQTZTLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsUUFBUSxJQUFJLFNBQVMsMFJBQTBSLElBQUksbU9BQW1PLElBQUksOFBBQThQLElBQUksVUFBVSxVQUFVLG1GQUFtRiwrUEFBK1AsZ0JBQWdCLGlFQUFpRSxvQkFBb0IsSUFBSSxtR0FBbUcsSUFBSSx5UUFBeVEsaUtBQWlLLHNNQUFzTSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVU7QUFDMWhGLGdIQUFnSCxRQUFRLHlCQUF5QixzR0FBc0csTUFBTSx5RkFBeUYsK0JBQStCLG1KQUFtSix1UUFBdVEsUUFBUSx3SkFBd0osVUFBVSx1QkFBdUIsaUNBQWlDLG1EQUFtRCxvSEFBb0gsR0FBRyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxtQkFBbUIsNlFBQTZRLFVBQVUsMkRBQTJELFVBQVUsS0FBSyx5Q0FBeUMsMElBQTBJLDBIQUEwSCw4WEFBOFgsVUFBVSxrREFBa0QsR0FBRyx1UUFBdVEsaUhBQWlILGdPQUFnTyxVQUFVO0FBQ2w2RiwrRUFBK0UsRUFBRSwwQkFBMEIsRUFBRSw0Q0FBNEMsb0ZBQW9GLFVBQVUsd0NBQXdDLFFBQVEsZ0NBQWdDLGtCQUFrQixJQUFJLCtEQUErRCxhQUFhLHNDQUFzQyx3QkFBd0IsNkJBQTZCLDRIQUE0SCxJQUFJLHdEQUF3RCxRQUFRLDZCQUE2QixRQUFRLDZCQUE2QixRQUFRLHVIQUF1SCxTQUFTLCtDQUErQyxRQUFRLGdCQUFnQixrQkFBa0IsVUFBVSwyQkFBMkI7QUFDNWdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QyxHQUFHLEtBQUssR0FBRyx3REFBd0QsSUFBSSxzTkFBc04seUVBQXlFLCtEQUErRCwwREFBMEQsSUFBSSxVQUFVLFVBQVUsYUFBYSwwRUFBMEUsc0RBQXNELCtFQUErRSxzREFBc0QsV0FBVyxJQUFJLFVBQVUscU5BQXFOLElBQUksVUFBVSx3RkFBd0YsK0NBQStDLHdCQUF3QixxRUFBcUUsOEdBQThHLGtHQUFrRztBQUNsL0M7QUFDQSxhQUFhLGVBQWU7QUFDNUIsaUJBQWlCLG9FQUFvRSxFQUFFLG9FQUFvRSxFQUFFLHFEQUFxRDtBQUNsTjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2dkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Tnh0Qzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsZUFBZSwyREFBb0I7QUFDbkM7QUFDQSxzQkFBc0IsWUFBWSxJQUFJLCtDQUErQyxJQUFJLDRVQUE0VSxJQUFJLG9CQUFvQixJQUFJLHVtQkFBdW1CLE1BQU0sVUFBVSxVQUFVLG9CQUFvQixJQUFJLFVBQVUsVUFBVSxvQkFBb0Isb0JBQW9CLElBQUksUUFBUSxJQUFJLFdBQVcsY0FBYyxVQUFVLHFKQUFxSixtRUFBbUUsNkhBQTZIO0FBQzloRCxtTUFBbU0sR0FBRyxLQUFLLEdBQUcsd09BQXdPLFVBQVUsUUFBUSxpQkFBaUIsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLG1QQUFtUCxVQUFVLGdQQUFnUCxRQUFRLGlIQUFpSCxNQUFNLDhPQUE4TyxRQUFRLHNQQUFzUCxRQUFRLDRIQUE0SCwwTEFBMEwsUUFBUSxtS0FBbUssSUFBSSxJQUFJLGFBQWEsaVBBQWlQLFFBQVEscVFBQXFRLE1BQU0sWUFBWSxRQUFRLGlCQUFpQixRQUFRLGdGQUFnRixLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssdUJBQXVCLFFBQVEsaUJBQWlCLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyx3UEFBd1AsUUFBUTtBQUMzaUcscUZBQXFGLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxnSkFBZ0oscURBQXFELFVBQVUsU0FBUyxJQUFJO0FBQ3BiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEdBQUcsS0FBSyxHQUFHLDhDQUE4QyxnQkFBZ0IsSUFBSSx3UkFBd1IsSUFBSSwyREFBMkQsSUFBSSxnRUFBZ0UsSUFBSSxJQUFJLGtFQUFrRSw4QkFBOEIsMkNBQTJDLDhCQUE4QixxRkFBcUYsaUhBQWlILCtDQUErQyx3QkFBd0IseUVBQXlFLHFDQUFxQyw4QkFBOEIsbUVBQW1FLHNCQUFzQjtBQUNwc0M7QUFDQSxhQUFhLHFDQUFxQztBQUNsRCxpQkFBaUIsb0VBQW9FLEVBQUUsb0VBQW9FLEVBQUUscURBQXFEO0FBQ2xOO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0ckQ7Ozs7Ozs7Ozs7Ozs7QUNuUDdxRDtBQUNmO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2ZlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsa0NBQWtDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBLGdDQUFnQztBQUNoQyx1QkFBdUIsc0JBQXNCLG1EQUFtRCxRQUFRO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBLGVBQWUsVUFBVSx5QkFBeUI7QUFDbEQ7QUFDQSwwRkFBMEYsUUFBUTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxPQUFPO0FBQzdFLG9DQUFvQyxHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRHQUE0RztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1QkFBdUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHVEQUF1RDtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsMkRBQTJELHlDQUF5QztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSw4QkFBOEIscUNBQXFDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9hZGRfbGFiZWxfdG9fcXVlcnkudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvYmFja2VuZFJlc3VsdFRyYW5zZm9ybWVyLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbXBvbmVudHMvQW5ub3RhdGlvbnNRdWVyeUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29tcG9uZW50cy9Mb2tpQ2hlYXRTaGVldC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29tcG9uZW50cy9Mb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb21wb25lbnRzL0xva2lMYWJlbEJyb3dzZXIudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbXBvbmVudHMvTG9raU9wdGlvbkZpZWxkcy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29tcG9uZW50cy9Mb2tpUXVlcnlFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbXBvbmVudHMvTG9raVF1ZXJ5RWRpdG9yQnlBcHAudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbXBvbmVudHMvTG9raVF1ZXJ5RWRpdG9yRm9yQWxlcnRpbmcudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbXBvbmVudHMvTG9raVF1ZXJ5RmllbGQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbmZpZ3VyYXRpb24vQ29uZmlnRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb25maWd1cmF0aW9uL0RlYnVnU2VjdGlvbi50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29uZmlndXJhdGlvbi9EZXJpdmVkRmllbGQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbmZpZ3VyYXRpb24vRGVyaXZlZEZpZWxkcy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29uZmlndXJhdGlvbi9NYXhMaW5lc0ZpZWxkLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9kYXRhc291cmNlLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2dldERlcml2ZWRGaWVsZHMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvbGFuZ3VhZ2VfcHJvdmlkZXIudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvbGFuZ3VhZ2VfdXRpbHMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvbGl2ZV9zdHJlYW1zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2xpdmVfc3RyZWFtc19yZXN1bHRfdHJhbnNmb3JtZXIudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvbWFrZVRhYmxlRnJhbWVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL21vZHVsZS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeV91dGlscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeWJ1aWxkZXIvTG9raVF1ZXJ5TW9kZWxsZXIudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5QnVpbGRlci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5QnVpbGRlckNvbnRhaW5lci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5QnVpbGRlckV4cGxhaW5lZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5QnVpbGRlck9wdGlvbnMudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL0xva2lRdWVyeUNvZGVFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL0xva2lRdWVyeUVkaXRvclNlbGVjdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9OZXN0ZWRRdWVyeS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTmVzdGVkUXVlcnlMaXN0LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9RdWVyeVByZXZpZXcudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9vcGVyYXRpb25zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9wYXJzaW5nLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9zdGF0ZS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeWJ1aWxkZXIvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcmVzcG9uc2VVdGlscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9zb3J0RGF0YUZyYW1lLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3N0cmVhbWluZy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9zeW50YXgudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvYWRkX2xhYmVsX3RvX3F1ZXJ5LnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2xhbmd1YWdlX3Byb3ZpZGVyLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2xhbmd1YWdlX3V0aWxzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3Byb21xbC50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvUHJvbVF1ZXJ5TW9kZWxsZXIudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2FnZ3JlZ2F0aW9ucy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvYmluYXJ5U2NhbGFyT3BlcmF0aW9ucy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9MYWJlbFBhcmFtRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvb3BlcmF0aW9ucy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvcGFyc2luZy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0ZlZWRiYWNrTGluay50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9MYWJlbEZpbHRlckl0ZW0udHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvTGFiZWxGaWx0ZXJzLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25FZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uRXhwbGFpbmVkQm94LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkhlYWRlci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25JbmZvQnV0dG9uLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkxpc3QudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uTGlzdEV4cGxhaW5lZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25QYXJhbUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25zRWRpdG9yUm93LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL1F1ZXJ5RWRpdG9yTW9kZVRvZ2dsZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9RdWVyeUhlYWRlclN3aXRjaC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9RdWVyeU9wdGlvbkdyb3VwLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL1Jhd1F1ZXJ5LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL29wZXJhdGlvblV0aWxzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvcGFyc2luZ1V0aWxzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3R5cGVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1wb3BwZXItdG9vbHRpcC12aXJ0dWFsLWZmMGRhNGIyZmQvMC9jYWNoZS9yZWFjdC1wb3BwZXItdG9vbHRpcC1ucG0tNC40LjEtMjIxNDQ4MGRiYy01OGRhY2RmOWJjLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtcG9wcGVyLXRvb2x0aXAvZGlzdC9lc20vcmVhY3QtcG9wcGVyLXRvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL19fdmlydHVhbF9fL3JlYWN0LXVzZS12aXJ0dWFsLWNlYThlODI2ZGMvMC9jYWNoZS9yZWFjdC11c2UtbnBtLTE3LjQuMC0wZWY0NTIxNTQ0LTA4ODlkYTkxOWIuemlwL25vZGVfbW9kdWxlcy9yZWFjdC11c2UvZXNtL3VzZVByZXZpb3VzLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9scnUtY2FjaGUtbnBtLTcuMTAuMS01YWY5MTBkMGVkLWU4YjE5MGQ3MWUuemlwL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3J4anMtbnBtLTcuNS41LWQwNTQ2YjFjY2ItZTAzNGY2MDgwNS56aXAvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29ic2VydmFibGUvZG9tL1dlYlNvY2tldFN1YmplY3QuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3J4anMtbnBtLTcuNS41LWQwNTQ2YjFjY2ItZTAzNGY2MDgwNS56aXAvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29ic2VydmFibGUvZG9tL3dlYlNvY2tldC5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvdXVpZC1ucG0tOC4zLjItZWNhMGJhYmE1My01NTc1YThhNzVjLnppcC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3BhcnNlLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS91dWlkLW5wbS04LjMuMi1lY2EwYmFiYTUzLTU1NzVhOGE3NWMuemlwL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc2hhMS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvdXVpZC1ucG0tOC4zLjItZWNhMGJhYmE1My01NTc1YThhNzVjLnppcC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzNS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvdXVpZC1ucG0tOC4zLjItZWNhMGJhYmE1My01NTc1YThhNzVjLnppcC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y1LmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9AZ3JhZmFuYS1sZXplci1sb2dxbC12aXJ0dWFsLTNhMWIwZTJkZTcvMC9jYWNoZS9AZ3JhZmFuYS1sZXplci1sb2dxbC1ucG0tMC4wLjEyLWI0NGIyNzE3NjMtZDI4NzgwYjQxYS56aXAvbm9kZV9tb2R1bGVzL0BncmFmYW5hL2xlemVyLWxvZ3FsL2luZGV4LmVzLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9sZXplci1wcm9tcWwtdmlydHVhbC1lYWY4OGFhNzdhLzAvY2FjaGUvbGV6ZXItcHJvbXFsLW5wbS0wLjIyLjAtODY3ZGE2YWZhYS1jZGNlMDU0NzAwLnppcC9ub2RlX21vZHVsZXMvbGV6ZXItcHJvbXFsL2luZGV4LmVzLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xOC4zLTE4ODNjNzBmYTYtZGI4NTI2MjI2YS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjE4LjMtMTg4M2M3MGZhNi1kYjg1MjYyMjZhLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGxlemVyLWNvbW1vbi1ucG0tMC4xNS4xMi02MjAxNzI3MmIwLWRhZTY1ODE2MTguemlwL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BsZXplci1sci1ucG0tMC4xNS44LThjNDgxYzM5Y2QtZTc0MTIyNWQ2YS56aXAvbm9kZV9tb2R1bGVzL0BsZXplci9sci9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlciB9IGZyb20gJ0BncmFmYW5hL2xlemVyLWxvZ3FsJztcblxuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIgfSBmcm9tICcuLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBMb2tpUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vcXVlcnlidWlsZGVyL0xva2lRdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvcGFyc2luZyc7XG5pbXBvcnQgeyBMb2tpVmlzdWFsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5YnVpbGRlci90eXBlcyc7XG5cbi8qKlxuICogQWRkcyBsYWJlbCBmaWx0ZXIgdG8gZXhpc3RpbmcgcXVlcnkuIFVzZWZ1bCBmb3IgcXVlcnkgbW9kaWZpY2F0aW9uIGZvciBleGFtcGxlIGZvciBhZCBob2MgZmlsdGVycy5cbiAqXG4gKiBJdCB1c2VzIExvZ1FMIHBhcnNlciB0byBmaW5kIGluc3RhbmNlcyBvZiBsYWJlbHMsIGFsdGVycyB0aGVtIGFuZCB0aGVuIHNwbGljZXMgdGhlbSBiYWNrIGludG8gdGhlIHF1ZXJ5LlxuICogSW4gYSBjYXNlIHdoZW4gd2UgaGF2ZSBwYXJzZXIsIGluc3RlYWQgb2YgYWRkaW5nIG5ldyBpbnN0YW5jZSBvZiBsYWJlbCBpdCBhZGRzIGxhYmVsIGZpbHRlciBhZnRlciB0aGUgcGFyc2VyLlxuICpcbiAqIFRoaXMgb3BlcmF0ZXMgb24gc3Vic3RyaW5ncyBvZiB0aGUgcXVlcnkgd2l0aCBsYWJlbHMgYW5kIG9wZXJhdGVzIGp1c3Qgb24gdGhvc2UuIFRoaXMgbWFrZXMgdGhpc1xuICogbW9yZSByb2J1c3QgYW5kIGNhbiBhbHRlciBldmVuIGludmFsaWQgcXVlcmllcywgYW5kIHByZXNlcnZlcyBpbiBnZW5lcmFsIHRoZSBxdWVyeSBzdHJ1Y3R1cmUgYW5kIHdoaXRlc3BhY2UuXG4gKlxuICogQHBhcmFtIHF1ZXJ5XG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBvcGVyYXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTGFiZWxUb1F1ZXJ5KHF1ZXJ5OiBzdHJpbmcsIGtleTogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFrZXkgfHwgIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGxhYmVsIHRvIGFkZCB0byBxdWVyeS4nKTtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbVNlbGVjdG9yUG9zaXRpb25zID0gZ2V0U3RyZWFtU2VsZWN0b3JQb3NpdGlvbnMocXVlcnkpO1xuICBjb25zdCBwYXJzZXJQb3NpdGlvbnMgPSBnZXRQYXJzZXJQb3NpdGlvbnMocXVlcnkpO1xuICBpZiAoIXN0cmVhbVNlbGVjdG9yUG9zaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIGNvbnN0IGZpbHRlciA9IHRvTGFiZWxGaWx0ZXIoa2V5LCB2YWx1ZSwgb3BlcmF0b3IpO1xuICBpZiAoIXBhcnNlclBvc2l0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWRkRmlsdGVyVG9TdHJlYW1TZWxlY3RvcihxdWVyeSwgc3RyZWFtU2VsZWN0b3JQb3NpdGlvbnMsIGZpbHRlcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFkZEZpbHRlckFzTGFiZWxGaWx0ZXIocXVlcnksIHBhcnNlclBvc2l0aW9ucywgZmlsdGVyKTtcbiAgfVxufVxuXG50eXBlIFN0cmVhbVNlbGVjdG9yUG9zaXRpb24gPSB7IGZyb206IG51bWJlcjsgdG86IG51bWJlcjsgcXVlcnk6IExva2lWaXN1YWxRdWVyeSB9O1xudHlwZSBQaXBlbGluZVN0YWdlUG9zaXRpb24gPSB7IGZyb206IG51bWJlcjsgdG86IG51bWJlciB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBzdHJpbmcgYW5kIGdldCBhbGwgU2VsZWN0b3IgcG9zaXRpb25zIGluIHRoZSBxdWVyeSB0b2dldGhlciB3aXRoIHBhcnNlZCByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAqIHNlbGVjdG9yLlxuICogQHBhcmFtIHF1ZXJ5XG4gKi9cbmZ1bmN0aW9uIGdldFN0cmVhbVNlbGVjdG9yUG9zaXRpb25zKHF1ZXJ5OiBzdHJpbmcpOiBTdHJlYW1TZWxlY3RvclBvc2l0aW9uW10ge1xuICBjb25zdCB0cmVlID0gcGFyc2VyLnBhcnNlKHF1ZXJ5KTtcbiAgY29uc3QgcG9zaXRpb25zOiBTdHJlYW1TZWxlY3RvclBvc2l0aW9uW10gPSBbXTtcbiAgdHJlZS5pdGVyYXRlKHtcbiAgICBlbnRlcjogKHR5cGUsIGZyb20sIHRvLCBnZXQpOiBmYWxzZSB8IHZvaWQgPT4ge1xuICAgICAgaWYgKHR5cGUubmFtZSA9PT0gJ1NlbGVjdG9yJykge1xuICAgICAgICBjb25zdCB2aXNRdWVyeSA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKHF1ZXJ5LnN1YnN0cmluZyhmcm9tLCB0bykpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaCh7IHF1ZXJ5OiB2aXNRdWVyeS5xdWVyeSwgZnJvbSwgdG8gfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgc3RyaW5nIGFuZCBnZXQgYWxsIExhYmVsUGFyc2VyIHBvc2l0aW9ucyBpbiB0aGUgcXVlcnkuXG4gKiBAcGFyYW0gcXVlcnlcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyc2VyUG9zaXRpb25zKHF1ZXJ5OiBzdHJpbmcpOiBQaXBlbGluZVN0YWdlUG9zaXRpb25bXSB7XG4gIGNvbnN0IHRyZWUgPSBwYXJzZXIucGFyc2UocXVlcnkpO1xuICBjb25zdCBwb3NpdGlvbnM6IFBpcGVsaW5lU3RhZ2VQb3NpdGlvbltdID0gW107XG4gIHRyZWUuaXRlcmF0ZSh7XG4gICAgZW50ZXI6ICh0eXBlLCBmcm9tLCB0bywgZ2V0KTogZmFsc2UgfCB2b2lkID0+IHtcbiAgICAgIGlmICh0eXBlLm5hbWUgPT09ICdMYWJlbFBhcnNlcicpIHtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xuICByZXR1cm4gcG9zaXRpb25zO1xufVxuXG5mdW5jdGlvbiB0b0xhYmVsRmlsdGVyKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nKTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGNvbnZlcnQgdGhlIHZhbHVlIGJhY2sgdG8gc3RyaW5nIGJlY2F1c2UgaXQgbWF5IGJlIGEgbnVtYmVyXG4gIHJldHVybiB7IGxhYmVsOiBrZXksIG9wOiBvcGVyYXRvciwgdmFsdWUgfTtcbn1cblxuLyoqXG4gKiBBZGQgZmlsdGVyIGFzIHRvIHN0cmVhbSBzZWxlY3RvcnNcbiAqIEBwYXJhbSBxdWVyeVxuICogQHBhcmFtIHZlY3RvclNlbGVjdG9yUG9zaXRpb25zXG4gKiBAcGFyYW0gZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIGFkZEZpbHRlclRvU3RyZWFtU2VsZWN0b3IoXG4gIHF1ZXJ5OiBzdHJpbmcsXG4gIHZlY3RvclNlbGVjdG9yUG9zaXRpb25zOiBTdHJlYW1TZWxlY3RvclBvc2l0aW9uW10sXG4gIGZpbHRlcjogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJcbik6IHN0cmluZyB7XG4gIGNvbnN0IG1vZGVsbGVyID0gbmV3IExva2lRdWVyeU1vZGVsbGVyKCk7XG4gIGxldCBuZXdRdWVyeSA9ICcnO1xuICBsZXQgcHJldiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIC8vIFRoaXMgaXMgYmFzaWNhbGx5IGp1c3QgZG9pbmcgc3BsaWNlIG9uIGEgc3RyaW5nIGZvciBlYWNoIG1hdGNoZWQgdmVjdG9yIHNlbGVjdG9yLlxuXG4gICAgY29uc3QgbWF0Y2ggPSB2ZWN0b3JTZWxlY3RvclBvc2l0aW9uc1tpXTtcbiAgICBjb25zdCBpc0xhc3QgPSBpID09PSB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucy5sZW5ndGggLSAxO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBxdWVyeS5zdWJzdHJpbmcocHJldiwgbWF0Y2guZnJvbSk7XG4gICAgY29uc3QgZW5kID0gaXNMYXN0ID8gcXVlcnkuc3Vic3RyaW5nKG1hdGNoLnRvKSA6ICcnO1xuXG4gICAgaWYgKCFsYWJlbEV4aXN0cyhtYXRjaC5xdWVyeS5sYWJlbHMsIGZpbHRlcikpIHtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYWRkIGR1cGxpY2F0ZSBsYWJlbHMuXG4gICAgICBtYXRjaC5xdWVyeS5sYWJlbHMucHVzaChmaWx0ZXIpO1xuICAgIH1cbiAgICBjb25zdCBuZXdMYWJlbHMgPSBtb2RlbGxlci5yZW5kZXJRdWVyeShtYXRjaC5xdWVyeSk7XG4gICAgbmV3UXVlcnkgKz0gc3RhcnQgKyBuZXdMYWJlbHMgKyBlbmQ7XG4gICAgcHJldiA9IG1hdGNoLnRvO1xuICB9XG4gIHJldHVybiBuZXdRdWVyeTtcbn1cblxuLyoqXG4gKiBBZGQgZmlsdGVyIGFzIGxhYmVsIGZpbHRlciBhZnRlciB0aGUgcGFyc2Vyc1xuICogQHBhcmFtIHF1ZXJ5XG4gKiBAcGFyYW0gcGFyc2VyUG9zaXRpb25zXG4gKiBAcGFyYW0gZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIGFkZEZpbHRlckFzTGFiZWxGaWx0ZXIoXG4gIHF1ZXJ5OiBzdHJpbmcsXG4gIHBhcnNlclBvc2l0aW9uczogUGlwZWxpbmVTdGFnZVBvc2l0aW9uW10sXG4gIGZpbHRlcjogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJcbik6IHN0cmluZyB7XG4gIGxldCBuZXdRdWVyeSA9ICcnO1xuICBsZXQgcHJldiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZXJQb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBUaGlzIGlzIGJhc2ljYWxseSBqdXN0IGRvaW5nIHNwbGljZSBvbiBhIHN0cmluZyBmb3IgZWFjaCBtYXRjaGVkIHZlY3RvciBzZWxlY3Rvci5cbiAgICBjb25zdCBtYXRjaCA9IHBhcnNlclBvc2l0aW9uc1tpXTtcbiAgICBjb25zdCBpc0xhc3QgPSBpID09PSBwYXJzZXJQb3NpdGlvbnMubGVuZ3RoIC0gMTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gcXVlcnkuc3Vic3RyaW5nKHByZXYsIG1hdGNoLnRvKTtcbiAgICBjb25zdCBlbmQgPSBpc0xhc3QgPyBxdWVyeS5zdWJzdHJpbmcobWF0Y2gudG8pIDogJyc7XG5cbiAgICBjb25zdCBsYWJlbEZpbHRlciA9IGAgfCAke2ZpbHRlci5sYWJlbH0ke2ZpbHRlci5vcH1cXGAke2ZpbHRlci52YWx1ZX1cXGBgO1xuICAgIG5ld1F1ZXJ5ICs9IHN0YXJ0ICsgbGFiZWxGaWx0ZXIgKyBlbmQ7XG4gICAgcHJldiA9IG1hdGNoLnRvO1xuICB9XG4gIHJldHVybiBuZXdRdWVyeTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBsYWJlbCBleGlzdHMgaW4gdGhlIGxpc3Qgb2YgbGFiZWxzIGJ1dCBpZ25vcmUgdGhlIG9wZXJhdG9yLlxuICogQHBhcmFtIGxhYmVsc1xuICogQHBhcmFtIGZpbHRlclxuICovXG5mdW5jdGlvbiBsYWJlbEV4aXN0cyhsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10sIGZpbHRlcjogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIpIHtcbiAgcmV0dXJuIGxhYmVscy5maW5kKChsYWJlbCkgPT4gbGFiZWwubGFiZWwgPT09IGZpbHRlci5sYWJlbCAmJiBsYWJlbC52YWx1ZSA9PT0gZmlsdGVyLnZhbHVlKTtcbn1cbiIsImltcG9ydCB7IERhdGFRdWVyeVJlc3BvbnNlLCBEYXRhRnJhbWUsIGlzRGF0YUZyYW1lLCBGaWVsZFR5cGUsIFF1ZXJ5UmVzdWx0TWV0YSwgRGF0YVF1ZXJ5RXJyb3IgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgZ2V0RGVyaXZlZEZpZWxkcyB9IGZyb20gJy4vZ2V0RGVyaXZlZEZpZWxkcyc7XG5pbXBvcnQgeyBtYWtlVGFibGVGcmFtZXMgfSBmcm9tICcuL21ha2VUYWJsZUZyYW1lcyc7XG5pbXBvcnQgeyBmb3JtYXRRdWVyeSwgZ2V0SGlnaGxpZ2h0ZXJFeHByZXNzaW9uc0Zyb21RdWVyeSB9IGZyb20gJy4vcXVlcnlfdXRpbHMnO1xuaW1wb3J0IHsgZGF0YUZyYW1lSGFzTG9raUVycm9yIH0gZnJvbSAnLi9yZXNwb25zZVV0aWxzJztcbmltcG9ydCB7IERlcml2ZWRGaWVsZENvbmZpZywgTG9raVF1ZXJ5LCBMb2tpUXVlcnlUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmZ1bmN0aW9uIGlzTWV0cmljRnJhbWUoZnJhbWU6IERhdGFGcmFtZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gZnJhbWUuZmllbGRzLmV2ZXJ5KChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLnRpbWUgfHwgZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLm51bWJlcik7XG59XG5cbi8vIHJldHVybnMgYSBuZXcgZnJhbWUsIHdpdGggbWV0YSBzaGFsbG93IG1lcmdlZCB3aXRoIGl0J3Mgb3JpZ2luYWwgbWV0YVxuZnVuY3Rpb24gc2V0RnJhbWVNZXRhKGZyYW1lOiBEYXRhRnJhbWUsIG1ldGE6IFF1ZXJ5UmVzdWx0TWV0YSk6IERhdGFGcmFtZSB7XG4gIGNvbnN0IHsgbWV0YTogb2xkTWV0YSwgLi4ucmVzdCB9ID0gZnJhbWU7XG4gIC8vIG1ldGEgbWF5YmUgYmUgdW5kZWZpbmVkLCB3ZSBuZWVkIHRvIGhhbmRsZSB0aGF0XG4gIGNvbnN0IG5ld01ldGEgPSB7IC4uLm9sZE1ldGEsIC4uLm1ldGEgfTtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN0LFxuICAgIG1ldGE6IG5ld01ldGEsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1GcmFtZShcbiAgZnJhbWU6IERhdGFGcmFtZSxcbiAgcXVlcnk6IExva2lRdWVyeSB8IHVuZGVmaW5lZCxcbiAgZGVyaXZlZEZpZWxkQ29uZmlnczogRGVyaXZlZEZpZWxkQ29uZmlnW11cbik6IERhdGFGcmFtZSB7XG4gIGNvbnN0IGN1c3RvbTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAuLi5mcmFtZS5tZXRhPy5jdXN0b20sIC8vIGtlZXAgdGhlIG9yaWdpbmFsIG1ldGEuY3VzdG9tXG4gICAgLy8gdXNlZCBieSBsb2dzX21vZGVsXG4gICAgbG9raVF1ZXJ5U3RhdEtleTogJ1N1bW1hcnk6IHRvdGFsIGJ5dGVzIHByb2Nlc3NlZCcsXG4gIH07XG5cbiAgaWYgKGRhdGFGcmFtZUhhc0xva2lFcnJvcihmcmFtZSkpIHtcbiAgICBjdXN0b20uZXJyb3IgPSAnRXJyb3Igd2hlbiBwYXJzaW5nIHNvbWUgb2YgdGhlIGxvZ3MnO1xuICB9XG5cbiAgY29uc3QgbWV0YTogUXVlcnlSZXN1bHRNZXRhID0ge1xuICAgIHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAnbG9ncycsXG4gICAgbGltaXQ6IHF1ZXJ5Py5tYXhMaW5lcyxcbiAgICBzZWFyY2hXb3JkczogcXVlcnkgIT09IHVuZGVmaW5lZCA/IGdldEhpZ2hsaWdodGVyRXhwcmVzc2lvbnNGcm9tUXVlcnkoZm9ybWF0UXVlcnkocXVlcnkuZXhwcikpIDogdW5kZWZpbmVkLFxuICAgIGN1c3RvbSxcbiAgfTtcblxuICBjb25zdCBuZXdGcmFtZSA9IHNldEZyYW1lTWV0YShmcmFtZSwgbWV0YSk7XG4gIGNvbnN0IGRlcml2ZWRGaWVsZHMgPSBnZXREZXJpdmVkRmllbGRzKG5ld0ZyYW1lLCBkZXJpdmVkRmllbGRDb25maWdzKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5uZXdGcmFtZSxcbiAgICBmaWVsZHM6IFsuLi5uZXdGcmFtZS5maWVsZHMsIC4uLmRlcml2ZWRGaWVsZHNdLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzU3RyZWFtc0ZyYW1lcyhcbiAgZnJhbWVzOiBEYXRhRnJhbWVbXSxcbiAgcXVlcnlNYXA6IE1hcDxzdHJpbmcsIExva2lRdWVyeT4sXG4gIGRlcml2ZWRGaWVsZENvbmZpZ3M6IERlcml2ZWRGaWVsZENvbmZpZ1tdXG4pOiBEYXRhRnJhbWVbXSB7XG4gIHJldHVybiBmcmFtZXMubWFwKChmcmFtZSkgPT4ge1xuICAgIGNvbnN0IHF1ZXJ5ID0gZnJhbWUucmVmSWQgIT09IHVuZGVmaW5lZCA/IHF1ZXJ5TWFwLmdldChmcmFtZS5yZWZJZCkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHByb2Nlc3NTdHJlYW1GcmFtZShmcmFtZSwgcXVlcnksIGRlcml2ZWRGaWVsZENvbmZpZ3MpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc01ldHJpY0luc3RhbnRGcmFtZXMoZnJhbWVzOiBEYXRhRnJhbWVbXSk6IERhdGFGcmFtZVtdIHtcbiAgcmV0dXJuIGZyYW1lcy5sZW5ndGggPiAwID8gbWFrZVRhYmxlRnJhbWVzKGZyYW1lcykgOiBbXTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc01ldHJpY1JhbmdlRnJhbWVzKGZyYW1lczogRGF0YUZyYW1lW10pOiBEYXRhRnJhbWVbXSB7XG4gIGNvbnN0IG1ldGE6IFF1ZXJ5UmVzdWx0TWV0YSA9IHsgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6ICdncmFwaCcgfTtcbiAgcmV0dXJuIGZyYW1lcy5tYXAoKGZyYW1lKSA9PiBzZXRGcmFtZU1ldGEoZnJhbWUsIG1ldGEpKTtcbn1cblxuLy8gd2Ugc3BsaXQgdGhlIGZyYW1lcyBpbnRvIDMgZ3JvdXBzLCBiZWNhdXNlIHdlIHdpbGwgaGFuZGxlXG4vLyBlYWNoIGdyb3VwIHNsaWdodGx5IGRpZmZlcmVudGx5XG5mdW5jdGlvbiBncm91cEZyYW1lcyhcbiAgZnJhbWVzOiBEYXRhRnJhbWVbXSxcbiAgcXVlcnlNYXA6IE1hcDxzdHJpbmcsIExva2lRdWVyeT5cbik6IHtcbiAgc3RyZWFtc0ZyYW1lczogRGF0YUZyYW1lW107XG4gIG1ldHJpY0luc3RhbnRGcmFtZXM6IERhdGFGcmFtZVtdO1xuICBtZXRyaWNSYW5nZUZyYW1lczogRGF0YUZyYW1lW107XG59IHtcbiAgY29uc3Qgc3RyZWFtc0ZyYW1lczogRGF0YUZyYW1lW10gPSBbXTtcbiAgY29uc3QgbWV0cmljSW5zdGFudEZyYW1lczogRGF0YUZyYW1lW10gPSBbXTtcbiAgY29uc3QgbWV0cmljUmFuZ2VGcmFtZXM6IERhdGFGcmFtZVtdID0gW107XG5cbiAgZnJhbWVzLmZvckVhY2goKGZyYW1lKSA9PiB7XG4gICAgaWYgKCFpc01ldHJpY0ZyYW1lKGZyYW1lKSkge1xuICAgICAgc3RyZWFtc0ZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNJbnN0YW50RnJhbWUgPSBmcmFtZS5yZWZJZCAhPSBudWxsICYmIHF1ZXJ5TWFwLmdldChmcmFtZS5yZWZJZCk/LnF1ZXJ5VHlwZSA9PT0gTG9raVF1ZXJ5VHlwZS5JbnN0YW50O1xuICAgICAgaWYgKGlzSW5zdGFudEZyYW1lKSB7XG4gICAgICAgIG1ldHJpY0luc3RhbnRGcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRyaWNSYW5nZUZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7IHN0cmVhbXNGcmFtZXMsIG1ldHJpY0luc3RhbnRGcmFtZXMsIG1ldHJpY1JhbmdlRnJhbWVzIH07XG59XG5cbmZ1bmN0aW9uIGltcHJvdmVFcnJvcihlcnJvcjogRGF0YVF1ZXJ5RXJyb3IgfCB1bmRlZmluZWQsIHF1ZXJ5TWFwOiBNYXA8c3RyaW5nLCBMb2tpUXVlcnk+KTogRGF0YVF1ZXJ5RXJyb3IgfCB1bmRlZmluZWQge1xuICAvLyBtYW55IHRoaW5ncyBhcmUgb3B0aW9uYWwgaW4gYW4gZXJyb3Itb2JqZWN0LCB3ZSBuZWVkIGFuIGVycm9yLW1lc3NhZ2UgdG8gZXhpc3QsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGxva2ktcXVlcnksIGJhc2VkIG9uIHRoZSByZWZJZCBpbiB0aGUgZXJyb3Itb2JqZWN0LlxuICBpZiAoZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIGNvbnN0IHsgcmVmSWQsIG1lc3NhZ2UgfSA9IGVycm9yO1xuICBpZiAocmVmSWQgPT09IHVuZGVmaW5lZCB8fCBtZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICBjb25zdCBxdWVyeSA9IHF1ZXJ5TWFwLmdldChyZWZJZCk7XG4gIGlmIChxdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoJ2VzY2FwZScpICYmIHF1ZXJ5LmV4cHIuaW5jbHVkZXMoJ1xcXFwnKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5lcnJvcixcbiAgICAgIG1lc3NhZ2U6IGAke21lc3NhZ2V9LiBNYWtlIHN1cmUgdGhhdCBhbGwgc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIHdpdGggXFxcXC4gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZXNjYXBpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzIHZpc2l0IExvZ1FMIGRvY3VtZW50YXRpb24gYXQgaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsLy5gLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZXJyb3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1CYWNrZW5kUmVzdWx0KFxuICByZXNwb25zZTogRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIHF1ZXJpZXM6IExva2lRdWVyeVtdLFxuICBkZXJpdmVkRmllbGRDb25maWdzOiBEZXJpdmVkRmllbGRDb25maWdbXVxuKTogRGF0YVF1ZXJ5UmVzcG9uc2Uge1xuICBjb25zdCB7IGRhdGEsIGVycm9yLCAuLi5yZXN0IH0gPSByZXNwb25zZTtcblxuICAvLyBpbiB0aGUgdHlwZXNjcmlwdCB0eXBlLCBkYXRhIGlzIGFuIGFycmF5IG9mIGJhc2ljYWxseSBhbnl0aGluZy5cbiAgLy8gd2UgZG8ga25vdyB0aGF0IHRoZXkgaGF2ZSB0byBiZSBkYXRhZnJhbWVzLCBzbyB3ZSBtYWtlIGEgcXVpY2sgY2hlY2ssXG4gIC8vIHRoaXMgd2F5IHdlIGNhbiBiZSBzdXJlLCBhbmQgYWxzbyB0eXBlc2NyaXB0IGlzIGhhcHB5LlxuICBjb25zdCBkYXRhRnJhbWVzID0gZGF0YS5tYXAoKGQpID0+IHtcbiAgICBpZiAoIWlzRGF0YUZyYW1lKGQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zZm9ybWF0aW9uIG9ubHkgc3VwcG9ydHMgZGF0YWZyYW1lIHJlc3BvbnNlcycpO1xuICAgIH1cbiAgICByZXR1cm4gZDtcbiAgfSk7XG5cbiAgY29uc3QgcXVlcnlNYXAgPSBuZXcgTWFwKHF1ZXJpZXMubWFwKChxdWVyeSkgPT4gW3F1ZXJ5LnJlZklkLCBxdWVyeV0pKTtcblxuICBjb25zdCB7IHN0cmVhbXNGcmFtZXMsIG1ldHJpY0luc3RhbnRGcmFtZXMsIG1ldHJpY1JhbmdlRnJhbWVzIH0gPSBncm91cEZyYW1lcyhkYXRhRnJhbWVzLCBxdWVyeU1hcCk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN0LFxuICAgIGVycm9yOiBpbXByb3ZlRXJyb3IoZXJyb3IsIHF1ZXJ5TWFwKSxcbiAgICBkYXRhOiBbXG4gICAgICAuLi5wcm9jZXNzTWV0cmljUmFuZ2VGcmFtZXMobWV0cmljUmFuZ2VGcmFtZXMpLFxuICAgICAgLi4ucHJvY2Vzc01ldHJpY0luc3RhbnRGcmFtZXMobWV0cmljSW5zdGFudEZyYW1lcyksXG4gICAgICAuLi5wcm9jZXNzU3RyZWFtc0ZyYW1lcyhzdHJlYW1zRnJhbWVzLCBxdWVyeU1hcCwgZGVyaXZlZEZpZWxkQ29uZmlncyksXG4gICAgXSxcbiAgfTtcbn1cbiIsIi8vIExpYnJhcmllc1xuaW1wb3J0IFJlYWN0LCB7IG1lbW8gfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEFubm90YXRpb25RdWVyeSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9yUm93LCBFZGl0b3JGaWVsZCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuLy8gVHlwZXNcbmltcG9ydCB7IGdldE5vcm1hbGl6ZWRMb2tpUXVlcnkgfSBmcm9tICcuLi9xdWVyeV91dGlscyc7XG5pbXBvcnQgeyBMb2tpUXVlcnksIExva2lRdWVyeVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IExva2lPcHRpb25GaWVsZHMgfSBmcm9tICcuL0xva2lPcHRpb25GaWVsZHMnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5RmllbGQgfSBmcm9tICcuL0xva2lRdWVyeUZpZWxkJztcbmltcG9ydCB7IExva2lRdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbnR5cGUgUHJvcHMgPSBMb2tpUXVlcnlFZGl0b3JQcm9wcyAmIHtcbiAgYW5ub3RhdGlvbj86IEFubm90YXRpb25RdWVyeTxMb2tpUXVlcnk+O1xuICBvbkFubm90YXRpb25DaGFuZ2U/OiAoYW5ub3RhdGlvbjogQW5ub3RhdGlvblF1ZXJ5PExva2lRdWVyeT4pID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgY29uc3QgTG9raUFubm90YXRpb25zUXVlcnlFZGl0b3IgPSBtZW1vKGZ1bmN0aW9uIExva2lBbm5vdGF0aW9uUXVlcnlFZGl0b3IocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgYW5ub3RhdGlvbiwgb25Bbm5vdGF0aW9uQ2hhbmdlIH0gPSBwcm9wcztcblxuICAvLyB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCB3ZSB3YW50IHRvIGtlZXAgdHlwZXNjcmlwdCBoYXBweVxuICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IG9uQW5ub3RhdGlvbkNoYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBvbkNoYW5nZVF1ZXJ5ID0gKHF1ZXJ5OiBMb2tpUXVlcnkpID0+IHtcbiAgICAvLyB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIGFubm90YXRpb25zIG9ubHkgc3RvcmVzIGFuIG9wdGlvbmFsIGJvb2xlYW5cbiAgICAvLyBmaWVsZCBgaW5zdGFudGAgdG8gaGFuZGxlIHRoZSBpbnN0YW50L3JhbmdlIHN3aXRjaC5cbiAgICAvLyB3ZSBuZWVkIHRvIG1haW50YWluIGNvbXBhdGlibGl0eSBmb3Igbm93LCBzbyB3ZSBkbyB0aGUgc2FtZS5cbiAgICAvLyB3ZSBleHBsaWNpdGx5IGNhbGwgYGdldE5vcm1hbGl6ZWRMb2tpUXVlcnlgIHRvIG1ha2Ugc3VyZSBgcXVlcnlUeXBlYFxuICAgIC8vIGlzIHNldCB1cCBjb3JyZWN0bHkuXG4gICAgY29uc3QgaW5zdGFudCA9IGdldE5vcm1hbGl6ZWRMb2tpUXVlcnkocXVlcnkpLnF1ZXJ5VHlwZSA9PT0gTG9raVF1ZXJ5VHlwZS5JbnN0YW50O1xuICAgIG9uQW5ub3RhdGlvbkNoYW5nZSh7XG4gICAgICAuLi5hbm5vdGF0aW9uLFxuICAgICAgZXhwcjogcXVlcnkuZXhwcixcbiAgICAgIG1heExpbmVzOiBxdWVyeS5tYXhMaW5lcyxcbiAgICAgIGluc3RhbnQsXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgcXVlcnlXaXRoUmVmSWQ6IExva2lRdWVyeSA9IHtcbiAgICByZWZJZDogJycsXG4gICAgZXhwcjogYW5ub3RhdGlvbi5leHByLFxuICAgIG1heExpbmVzOiBhbm5vdGF0aW9uLm1heExpbmVzLFxuICAgIGluc3RhbnQ6IGFubm90YXRpb24uaW5zdGFudCxcbiAgICBxdWVyeVR5cGU6IGFubm90YXRpb24ucXVlcnlUeXBlLFxuICB9O1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0tZ3JvdXBcIj5cbiAgICAgICAgPExva2lRdWVyeUZpZWxkXG4gICAgICAgICAgZGF0YXNvdXJjZT17cHJvcHMuZGF0YXNvdXJjZX1cbiAgICAgICAgICBxdWVyeT17cXVlcnlXaXRoUmVmSWR9XG4gICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlUXVlcnl9XG4gICAgICAgICAgb25SdW5RdWVyeT17KCkgPT4ge319XG4gICAgICAgICAgb25CbHVyPXsoKSA9PiB7fX1cbiAgICAgICAgICBoaXN0b3J5PXtbXX1cbiAgICAgICAgICBFeHRyYUZpZWxkRWxlbWVudD17XG4gICAgICAgICAgICA8TG9raU9wdGlvbkZpZWxkc1xuICAgICAgICAgICAgICBsaW5lTGltaXRWYWx1ZT17cXVlcnlXaXRoUmVmSWQ/Lm1heExpbmVzPy50b1N0cmluZygpIHx8ICcnfVxuICAgICAgICAgICAgICByZXNvbHV0aW9uPXtxdWVyeVdpdGhSZWZJZC5yZXNvbHV0aW9uIHx8IDF9XG4gICAgICAgICAgICAgIHF1ZXJ5PXtxdWVyeVdpdGhSZWZJZH1cbiAgICAgICAgICAgICAgb25SdW5RdWVyeT17KCkgPT4ge319XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZVF1ZXJ5fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICB9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPEVkaXRvclJvdz5cbiAgICAgICAgPEVkaXRvckZpZWxkXG4gICAgICAgICAgbGFiZWw9XCJUaXRsZVwiXG4gICAgICAgICAgdG9vbHRpcD17XG4gICAgICAgICAgICAnVXNlIGVpdGhlciB0aGUgbmFtZSBvciBhIHBhdHRlcm4uIEZvciBleGFtcGxlLCB7e2luc3RhbmNlfX0gaXMgcmVwbGFjZWQgd2l0aCBsYWJlbCB2YWx1ZSBmb3IgdGhlIGxhYmVsIGluc3RhbmNlLidcbiAgICAgICAgICB9XG4gICAgICAgID5cbiAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiYWxlcnRuYW1lXCJcbiAgICAgICAgICAgIHZhbHVlPXthbm5vdGF0aW9uLnRpdGxlRm9ybWF0fVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhldmVudCkgPT4ge1xuICAgICAgICAgICAgICBvbkFubm90YXRpb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIC4uLmFubm90YXRpb24sXG4gICAgICAgICAgICAgICAgdGl0bGVGb3JtYXQ6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgICA8RWRpdG9yRmllbGQgbGFiZWw9XCJUYWdzXCI+XG4gICAgICAgICAgPElucHV0XG4gICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cImxhYmVsMSxsYWJlbDJcIlxuICAgICAgICAgICAgdmFsdWU9e2Fubm90YXRpb24udGFnS2V5c31cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgb25Bbm5vdGF0aW9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi5hbm5vdGF0aW9uLFxuICAgICAgICAgICAgICAgIHRhZ0tleXM6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgICA8RWRpdG9yRmllbGRcbiAgICAgICAgICBsYWJlbD1cIlRleHRcIlxuICAgICAgICAgIHRvb2x0aXA9e1xuICAgICAgICAgICAgJ1VzZSBlaXRoZXIgdGhlIG5hbWUgb3IgYSBwYXR0ZXJuLiBGb3IgZXhhbXBsZSwge3tpbnN0YW5jZX19IGlzIHJlcGxhY2VkIHdpdGggbGFiZWwgdmFsdWUgZm9yIHRoZSBsYWJlbCBpbnN0YW5jZS4nXG4gICAgICAgICAgfVxuICAgICAgICA+XG4gICAgICAgICAgPElucHV0XG4gICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cImluc3RhbmNlXCJcbiAgICAgICAgICAgIHZhbHVlPXthbm5vdGF0aW9uLnRleHRGb3JtYXR9XG4gICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIG9uQW5ub3RhdGlvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgICB0ZXh0Rm9ybWF0OiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgIDwvRWRpdG9yUm93PlxuICAgIDwvPlxuICApO1xufSk7XG4iLCJpbXBvcnQgeyBzaHVmZmxlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBRdWVyeUVkaXRvckhlbHBQcm9wcyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgcmVwb3J0SW50ZXJhY3Rpb24gfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcblxuaW1wb3J0IExva2lMYW5ndWFnZVByb3ZpZGVyIGZyb20gJy4uL2xhbmd1YWdlX3Byb3ZpZGVyJztcbmltcG9ydCB7IExva2lRdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgREVGQVVMVF9FWEFNUExFUyA9IFsne2pvYj1cImRlZmF1bHQvcHJvbWV0aGV1c1wifSddO1xuY29uc3QgUFJFRkVSUkVEX0xBQkVMUyA9IFsnam9iJywgJ2FwcCcsICdrOHNfYXBwJ107XG5jb25zdCBFWEFNUExFU19MSU1JVCA9IDU7XG5cbmNvbnN0IExPR1FMX0VYQU1QTEVTID0gW1xuICB7XG4gICAgdGl0bGU6ICdMb2cgcGlwZWxpbmUnLFxuICAgIGV4cHJlc3Npb246ICd7am9iPVwibXlzcWxcIn0gfD0gXCJtZXRyaWNzXCIgfCBsb2dmbXQgfCBkdXJhdGlvbiA+IDEwcycsXG4gICAgbGFiZWw6XG4gICAgICAnVGhpcyBxdWVyeSB0YXJnZXRzIHRoZSBNeVNRTCBqb2IsIGZpbHRlcnMgb3V0IGxvZ3MgdGhhdCBkb27igJl0IGNvbnRhaW4gdGhlIHdvcmQgXCJtZXRyaWNzXCIgYW5kIHBhcnNlcyBlYWNoIGxvZyBsaW5lIHRvIGV4dHJhY3QgbW9yZSBsYWJlbHMgYW5kIGZpbHRlcnMgd2l0aCB0aGVtLicsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0NvdW50IG92ZXIgdGltZScsXG4gICAgZXhwcmVzc2lvbjogJ2NvdW50X292ZXJfdGltZSh7am9iPVwibXlzcWxcIn1bNW1dKScsXG4gICAgbGFiZWw6ICdUaGlzIHF1ZXJ5IGNvdW50cyBhbGwgdGhlIGxvZyBsaW5lcyB3aXRoaW4gdGhlIGxhc3QgZml2ZSBtaW51dGVzIGZvciB0aGUgTXlTUUwgam9iLicsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ1JhdGUnLFxuICAgIGV4cHJlc3Npb246ICdyYXRlKCh7am9iPVwibXlzcWxcIn0gfD0gXCJlcnJvclwiICE9IFwidGltZW91dFwiKVsxMHNdKScsXG4gICAgbGFiZWw6XG4gICAgICAnVGhpcyBxdWVyeSBnZXRzIHRoZSBwZXItc2Vjb25kIHJhdGUgb2YgYWxsIG5vbi10aW1lb3V0IGVycm9ycyB3aXRoaW4gdGhlIGxhc3QgdGVuIHNlY29uZHMgZm9yIHRoZSBNeVNRTCBqb2IuJyxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQWdncmVnYXRlLCBjb3VudCwgYW5kIGdyb3VwJyxcbiAgICBleHByZXNzaW9uOiAnc3VtKGNvdW50X292ZXJfdGltZSh7am9iPVwibXlzcWxcIn1bNW1dKSkgYnkgKGxldmVsKScsXG4gICAgbGFiZWw6ICdHZXQgdGhlIGNvdW50IG9mIGxvZ3MgZHVyaW5nIHRoZSBsYXN0IGZpdmUgbWludXRlcywgZ3JvdXBpbmcgYnkgbGV2ZWwuJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExva2lDaGVhdFNoZWV0IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxRdWVyeUVkaXRvckhlbHBQcm9wczxMb2tpUXVlcnk+LCB7IHVzZXJFeGFtcGxlczogc3RyaW5nW10gfT4ge1xuICBkZWNsYXJlIHVzZXJMYWJlbFRpbWVyOiBOb2RlSlMuVGltZW91dDtcbiAgc3RhdGUgPSB7XG4gICAgdXNlckV4YW1wbGVzOiBbXSxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNjaGVkdWxlVXNlckxhYmVsQ2hlY2tpbmcoKTtcbiAgICByZXBvcnRJbnRlcmFjdGlvbignZ3JhZmFuYV9sb2tpX2NoZWF0c2hlZXRfb3BlbmVkJywge30pO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudXNlckxhYmVsVGltZXIpO1xuICB9XG5cbiAgc2NoZWR1bGVVc2VyTGFiZWxDaGVja2luZygpIHtcbiAgICB0aGlzLnVzZXJMYWJlbFRpbWVyID0gc2V0VGltZW91dCh0aGlzLmNoZWNrVXNlckxhYmVscywgMTAwMCk7XG4gIH1cblxuICBjaGVja1VzZXJMYWJlbHMgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gU2V0IGV4YW1wbGUgZnJvbSB1c2VyIGxhYmVsc1xuICAgIGNvbnN0IHByb3ZpZGVyOiBMb2tpTGFuZ3VhZ2VQcm92aWRlciA9IHRoaXMucHJvcHMuZGF0YXNvdXJjZT8ubGFuZ3VhZ2VQcm92aWRlcjtcbiAgICBpZiAocHJvdmlkZXIuc3RhcnRlZCkge1xuICAgICAgY29uc3QgbGFiZWxzID0gcHJvdmlkZXIuZ2V0TGFiZWxLZXlzKCkgfHwgW107XG4gICAgICBjb25zdCBwcmVmZXJyZWRMYWJlbCA9IFBSRUZFUlJFRF9MQUJFTFMuZmluZCgobCkgPT4gbGFiZWxzLmluY2x1ZGVzKGwpKTtcbiAgICAgIGlmIChwcmVmZXJyZWRMYWJlbCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBhd2FpdCBwcm92aWRlci5nZXRMYWJlbFZhbHVlcyhwcmVmZXJyZWRMYWJlbCk7XG4gICAgICAgIGNvbnN0IHVzZXJFeGFtcGxlcyA9IHNodWZmbGUodmFsdWVzKVxuICAgICAgICAgIC5zbGljZSgwLCBFWEFNUExFU19MSU1JVClcbiAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4gYHske3ByZWZlcnJlZExhYmVsfT1cIiR7dmFsdWV9XCJ9YCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyB1c2VyRXhhbXBsZXMgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVVc2VyTGFiZWxDaGVja2luZygpO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXJFeHByZXNzaW9uKGV4cHI6IHN0cmluZykge1xuICAgIGNvbnN0IHsgb25DbGlja0V4YW1wbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgb25DbGljayA9IChxdWVyeTogTG9raVF1ZXJ5KSA9PiB7XG4gICAgICBvbkNsaWNrRXhhbXBsZShxdWVyeSk7XG4gICAgICByZXBvcnRJbnRlcmFjdGlvbignZ3JhZmFuYV9sb2tpX2NoZWF0c2hlZXRfZXhhbXBsZV9jbGlja2VkJywge30pO1xuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX19leGFtcGxlXCIga2V5PXtleHByfSBvbkNsaWNrPXsoZSkgPT4gb25DbGljayh7IHJlZklkOiAnQScsIGV4cHIgfSl9PlxuICAgICAgICA8Y29kZT57ZXhwcn08L2NvZGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgdXNlckV4YW1wbGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGhhc1VzZXJFeGFtcGxlcyA9IHVzZXJFeGFtcGxlcy5sZW5ndGggPiAwO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxoMj5Mb2tpIENoZWF0IFNoZWV0PC9oMj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX190aXRsZVwiPlNlZSB5b3VyIGxvZ3M8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1fX2xhYmVsXCI+XG4gICAgICAgICAgICBTdGFydCBieSBzZWxlY3RpbmcgYSBsb2cgc3RyZWFtIGZyb20gdGhlIExvZyBicm93c2VyLCBvciBhbHRlcm5hdGl2ZWx5IHlvdSBjYW4gd3JpdGUgYSBzdHJlYW0gc2VsZWN0b3IgaW50b1xuICAgICAgICAgICAgdGhlIHF1ZXJ5IGZpZWxkLlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHtoYXNVc2VyRXhhbXBsZXMgPyAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1fX2xhYmVsXCI+SGVyZSBhcmUgc29tZSBleGFtcGxlIHN0cmVhbXMgZnJvbSB5b3VyIGxvZ3M6PC9kaXY+XG4gICAgICAgICAgICAgIHt1c2VyRXhhbXBsZXMubWFwKChleGFtcGxlKSA9PiB0aGlzLnJlbmRlckV4cHJlc3Npb24oZXhhbXBsZSkpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fbGFiZWxcIj5IZXJlIGlzIGFuIGV4YW1wbGUgb2YgYSBsb2cgc3RyZWFtOjwvZGl2PlxuICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJFeHByZXNzaW9uKERFRkFVTFRfRVhBTVBMRVNbMF0pfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fdGl0bGVcIj5Db21iaW5lIHN0cmVhbSBzZWxlY3RvcnM8L2Rpdj5cbiAgICAgICAgICB7dGhpcy5yZW5kZXJFeHByZXNzaW9uKCd7YXBwPVwiY2Fzc2FuZHJhXCIsbmFtZXNwYWNlPVwicHJvZFwifScpfVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fbGFiZWxcIj5SZXR1cm5zIGFsbCBsb2cgbGluZXMgZnJvbSBzdHJlYW1zIHRoYXQgaGF2ZSBib3RoIGxhYmVscy48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX190aXRsZVwiPkZpbHRlcmluZyBmb3Igc2VhcmNoIHRlcm1zLjwvZGl2PlxuICAgICAgICAgIHt0aGlzLnJlbmRlckV4cHJlc3Npb24oJ3thcHA9XCJjYXNzYW5kcmFcIn0gfH4gXCIoZHVyYXRpb258bGF0ZW5jeSlzKig9fGlzfG9mKXMqW2QuXStcIicpfVxuICAgICAgICAgIHt0aGlzLnJlbmRlckV4cHJlc3Npb24oJ3thcHA9XCJjYXNzYW5kcmFcIn0gfD0gXCJleGFjdCBtYXRjaFwiJyl9XG4gICAgICAgICAge3RoaXMucmVuZGVyRXhwcmVzc2lvbigne2FwcD1cImNhc3NhbmRyYVwifSAhPSBcImRvIG5vdCBtYXRjaFwiJyl9XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX19sYWJlbFwiPlxuICAgICAgICAgICAgPGEgaHJlZj1cImh0dHBzOi8vZ3JhZmFuYS5jb20vZG9jcy9sb2tpL2xhdGVzdC9sb2dxbC8jbG9nLXBpcGVsaW5lXCIgdGFyZ2V0PVwibG9ncWxcIj5cbiAgICAgICAgICAgICAgTG9nUUxcbiAgICAgICAgICAgIDwvYT57JyAnfVxuICAgICAgICAgICAgc3VwcG9ydHMgZXhhY3QgYW5kIHJlZ3VsYXIgZXhwcmVzc2lvbiBmaWx0ZXJzLlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAge0xPR1FMX0VYQU1QTEVTLm1hcCgoaXRlbSkgPT4gKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbVwiIGtleT17aXRlbS5leHByZXNzaW9ufT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fdGl0bGVcIj57aXRlbS50aXRsZX08L2Rpdj5cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlckV4cHJlc3Npb24oaXRlbS5leHByZXNzaW9uKX1cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fbGFiZWxcIj57aXRlbS5sYWJlbH08L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBMaWJyYXJpZXNcbmltcG9ydCBSZWFjdCwgeyBtZW1vIH0gZnJvbSAncmVhY3QnO1xuXG4vLyBUeXBlc1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5pbXBvcnQgeyBMb2tpRGF0YXNvdXJjZSB9IGZyb20gJy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5LCBMb2tpT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgTG9raU9wdGlvbkZpZWxkcyB9IGZyb20gJy4vTG9raU9wdGlvbkZpZWxkcyc7XG5pbXBvcnQgeyBMb2tpUXVlcnlGaWVsZCB9IGZyb20gJy4vTG9raVF1ZXJ5RmllbGQnO1xuXG50eXBlIFByb3BzID0gUXVlcnlFZGl0b3JQcm9wczxMb2tpRGF0YXNvdXJjZSwgTG9raVF1ZXJ5LCBMb2tpT3B0aW9ucz47XG5cbmV4cG9ydCBjb25zdCBMb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yID0gbWVtbygocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgcXVlcnksIGRhdGEsIGRhdGFzb3VyY2UsIGhpc3RvcnksIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5LCByYW5nZSB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8TG9raVF1ZXJ5RmllbGRcbiAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICBxdWVyeT17cXVlcnl9XG4gICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICBvbkJsdXI9eygpID0+IHt9fVxuICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgIGhpc3Rvcnk9e2hpc3Rvcnl9XG4gICAgICBkYXRhPXtkYXRhfVxuICAgICAgcmFuZ2U9e3JhbmdlfVxuICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMuZWRpdG9yfVxuICAgICAgRXh0cmFGaWVsZEVsZW1lbnQ9e1xuICAgICAgICA8TG9raU9wdGlvbkZpZWxkc1xuICAgICAgICAgIGxpbmVMaW1pdFZhbHVlPXtxdWVyeT8ubWF4TGluZXM/LnRvU3RyaW5nKCkgfHwgJyd9XG4gICAgICAgICAgcmVzb2x1dGlvbj17cXVlcnkucmVzb2x1dGlvbiB8fCAxfVxuICAgICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgLz5cbiAgICAgIH1cbiAgICAvPlxuICApO1xufSk7XG5cbkxva2lFeHBsb3JlUXVlcnlFZGl0b3IuZGlzcGxheU5hbWUgPSAnTG9raUV4cGxvcmVRdWVyeUVkaXRvcic7XG5cbmV4cG9ydCBjb25zdCB0ZXN0SWRzID0ge1xuICBlZGl0b3I6ICdsb2tpLWVkaXRvci1leHBsb3JlJyxcbn07XG4iLCJpbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IHNvcnRCeSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgQ2hhbmdlRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBGaXhlZFNpemVMaXN0IH0gZnJvbSAncmVhY3Qtd2luZG93JztcblxuaW1wb3J0IHsgQ29yZUFwcCwgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgcmVwb3J0SW50ZXJhY3Rpb24gfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCB7XG4gIEJ1dHRvbixcbiAgSGlnaGxpZ2h0UGFydCxcbiAgSG9yaXpvbnRhbEdyb3VwLFxuICBJbnB1dCxcbiAgTGFiZWwsXG4gIExvYWRpbmdQbGFjZWhvbGRlcixcbiAgd2l0aFRoZW1lMixcbiAgQnJvd3NlckxhYmVsIGFzIExva2lMYWJlbCxcbiAgZnV6enlNYXRjaCxcbn0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgUHJvbVFsTGFuZ3VhZ2VQcm92aWRlciBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL2xhbmd1YWdlX3Byb3ZpZGVyJztcbmltcG9ydCBMb2tpTGFuZ3VhZ2VQcm92aWRlciBmcm9tICcuLi9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgeyBlc2NhcGVMYWJlbFZhbHVlSW5FeGFjdFNlbGVjdG9yLCBlc2NhcGVMYWJlbFZhbHVlSW5SZWdleFNlbGVjdG9yIH0gZnJvbSAnLi4vbGFuZ3VhZ2VfdXRpbHMnO1xuXG4vLyBIYXJkIGxpbWl0IG9uIGxhYmVscyB0byByZW5kZXJcbmNvbnN0IE1BWF9MQUJFTF9DT1VOVCA9IDEwMDA7XG5jb25zdCBNQVhfVkFMVUVfQ09VTlQgPSAxMDAwMDtcbmNvbnN0IE1BWF9BVVRPX1NFTEVDVCA9IDQ7XG5jb25zdCBFTVBUWV9TRUxFQ1RPUiA9ICd7fSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnJvd3NlclByb3BzIHtcbiAgLy8gVE9ETyAjMzM5NzY6IElzIGl0IHBvc3NpYmxlIHRvIHVzZSBhIGNvbW1vbiBpbnRlcmZhY2UgaGVyZT8gRm9yIGV4YW1wbGU6IExhYmVsc0xhbmd1YWdlUHJvdmlkZXJcbiAgbGFuZ3VhZ2VQcm92aWRlcjogTG9raUxhbmd1YWdlUHJvdmlkZXIgfCBQcm9tUWxMYW5ndWFnZVByb3ZpZGVyO1xuICBvbkNoYW5nZTogKHNlbGVjdG9yOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHRoZW1lOiBHcmFmYW5hVGhlbWUyO1xuICBhcHA/OiBDb3JlQXBwO1xuICBhdXRvU2VsZWN0PzogbnVtYmVyO1xuICBoaWRlPzogKCkgPT4gdm9pZDtcbiAgbGFzdFVzZWRMYWJlbHM6IHN0cmluZ1tdO1xuICBzdG9yZUxhc3RVc2VkTGFiZWxzOiAobGFiZWxzOiBzdHJpbmdbXSkgPT4gdm9pZDtcbiAgZGVsZXRlTGFzdFVzZWRMYWJlbHM6ICgpID0+IHZvaWQ7XG59XG5cbmludGVyZmFjZSBCcm93c2VyU3RhdGUge1xuICBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdO1xuICBzZWFyY2hUZXJtOiBzdHJpbmc7XG4gIHN0YXR1czogc3RyaW5nO1xuICBlcnJvcjogc3RyaW5nO1xuICB2YWxpZGF0aW9uU3RhdHVzOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBGYWNldHRhYmxlVmFsdWUge1xuICBuYW1lOiBzdHJpbmc7XG4gIHNlbGVjdGVkPzogYm9vbGVhbjtcbiAgaGlnaGxpZ2h0UGFydHM/OiBIaWdobGlnaHRQYXJ0W107XG4gIG9yZGVyPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGFibGVMYWJlbCB7XG4gIG5hbWU6IHN0cmluZztcbiAgc2VsZWN0ZWQ/OiBib29sZWFuO1xuICBsb2FkaW5nPzogYm9vbGVhbjtcbiAgdmFsdWVzPzogRmFjZXR0YWJsZVZhbHVlW107XG4gIGhpZGRlbj86IGJvb2xlYW47XG4gIGZhY2V0cz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU2VsZWN0b3IobGFiZWxzOiBTZWxlY3RhYmxlTGFiZWxbXSk6IHN0cmluZyB7XG4gIGNvbnN0IHNlbGVjdGVkTGFiZWxzID0gW107XG4gIGZvciAoY29uc3QgbGFiZWwgb2YgbGFiZWxzKSB7XG4gICAgaWYgKGxhYmVsLnNlbGVjdGVkICYmIGxhYmVsLnZhbHVlcyAmJiBsYWJlbC52YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZXMgPSBsYWJlbC52YWx1ZXMuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUuc2VsZWN0ZWQpLm1hcCgodmFsdWUpID0+IHZhbHVlLm5hbWUpO1xuICAgICAgaWYgKHNlbGVjdGVkVmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2VsZWN0ZWRMYWJlbHMucHVzaChgJHtsYWJlbC5uYW1lfT1+XCIke3NlbGVjdGVkVmFsdWVzLm1hcChlc2NhcGVMYWJlbFZhbHVlSW5SZWdleFNlbGVjdG9yKS5qb2luKCd8Jyl9XCJgKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHNlbGVjdGVkTGFiZWxzLnB1c2goYCR7bGFiZWwubmFtZX09XCIke2VzY2FwZUxhYmVsVmFsdWVJbkV4YWN0U2VsZWN0b3Ioc2VsZWN0ZWRWYWx1ZXNbMF0pfVwiYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbJ3snLCBzZWxlY3RlZExhYmVscy5qb2luKCcsJyksICd9J10uam9pbignJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWNldExhYmVscyhcbiAgbGFiZWxzOiBTZWxlY3RhYmxlTGFiZWxbXSxcbiAgcG9zc2libGVMYWJlbHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPixcbiAgbGFzdEZhY2V0dGVkPzogc3RyaW5nXG4pOiBTZWxlY3RhYmxlTGFiZWxbXSB7XG4gIHJldHVybiBsYWJlbHMubWFwKChsYWJlbCkgPT4ge1xuICAgIGNvbnN0IHBvc3NpYmxlVmFsdWVzID0gcG9zc2libGVMYWJlbHNbbGFiZWwubmFtZV07XG4gICAgaWYgKHBvc3NpYmxlVmFsdWVzKSB7XG4gICAgICBsZXQgZXhpc3RpbmdWYWx1ZXM6IEZhY2V0dGFibGVWYWx1ZVtdO1xuICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IGxhc3RGYWNldHRlZCAmJiBsYWJlbC52YWx1ZXMpIHtcbiAgICAgICAgLy8gRmFjZXR0aW5nIHRoaXMgbGFiZWwsIHNob3cgYWxsIHZhbHVlc1xuICAgICAgICBleGlzdGluZ1ZhbHVlcyA9IGxhYmVsLnZhbHVlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEtlZXAgc2VsZWN0aW9uIGluIG90aGVyIGZhY2V0c1xuICAgICAgICBjb25zdCBzZWxlY3RlZFZhbHVlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KFxuICAgICAgICAgIGxhYmVsLnZhbHVlcz8uZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUuc2VsZWN0ZWQpLm1hcCgodmFsdWUpID0+IHZhbHVlLm5hbWUpIHx8IFtdXG4gICAgICAgICk7XG4gICAgICAgIC8vIFZhbHVlcyBmb3IgdGhpcyBsYWJlbCBoYXZlIG5vdCBiZWVuIHJlcXVlc3RlZCB5ZXQsIGxldCdzIHVzZSB0aGUgZmFjZXR0ZWQgb25lcyBhcyB0aGUgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgZXhpc3RpbmdWYWx1ZXMgPSBwb3NzaWJsZVZhbHVlcy5tYXAoKHZhbHVlKSA9PiAoeyBuYW1lOiB2YWx1ZSwgc2VsZWN0ZWQ6IHNlbGVjdGVkVmFsdWVzLmhhcyh2YWx1ZSkgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgLi4ubGFiZWwsIGxvYWRpbmc6IGZhbHNlLCB2YWx1ZXM6IGV4aXN0aW5nVmFsdWVzLCBmYWNldHM6IGV4aXN0aW5nVmFsdWVzLmxlbmd0aCB9O1xuICAgIH1cblxuICAgIC8vIExhYmVsIGlzIGZhY2V0dGVkIG91dCwgaGlkZSBhbGwgdmFsdWVzXG4gICAgcmV0dXJuIHsgLi4ubGFiZWwsIGxvYWRpbmc6IGZhbHNlLCBoaWRkZW46ICFwb3NzaWJsZVZhbHVlcywgdmFsdWVzOiB1bmRlZmluZWQsIGZhY2V0czogMCB9O1xuICB9KTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiAoe1xuICB3cmFwcGVyOiBjc3NgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWNvbmRhcnl9O1xuICAgIHBhZGRpbmc6ICR7dGhlbWUuc3BhY2luZygyKX07XG4gICAgd2lkdGg6IDEwMCU7XG4gIGAsXG4gIGxpc3Q6IGNzc2BcbiAgICBtYXJnaW4tdG9wOiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIG1heC1oZWlnaHQ6IDIwMHB4O1xuICAgIG92ZXJmbG93OiBhdXRvO1xuICBgLFxuICBzZWN0aW9uOiBjc3NgXG4gICAgJiArICYge1xuICAgICAgbWFyZ2luOiAke3RoZW1lLnNwYWNpbmcoMiwgMCl9O1xuICAgIH1cbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGAsXG4gIHNlbGVjdG9yOiBjc3NgXG4gICAgZm9udC1mYW1pbHk6ICR7dGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5TW9ub3NwYWNlfTtcbiAgICBtYXJnaW4tYm90dG9tOiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICBgLFxuICBzdGF0dXM6IGNzc2BcbiAgICBwYWRkaW5nOiAke3RoZW1lLnNwYWNpbmcoMC41KX07XG4gICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5fTtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgLyogdXNpbmcgYWJzb2x1dGUgcG9zaXRpb25pbmcgYmVjYXVzZSBmbGV4IGludGVyZmVyZXMgd2l0aCBlbGxpcHNpcyAqL1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogNTAlO1xuICAgIHJpZ2h0OiAwO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMTAwbXMgbGluZWFyO1xuICAgIG9wYWNpdHk6IDA7XG4gIGAsXG4gIHN0YXR1c1Nob3dpbmc6IGNzc2BcbiAgICBvcGFjaXR5OiAxO1xuICBgLFxuICBlcnJvcjogY3NzYFxuICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy5lcnJvci5tYWlufTtcbiAgYCxcbiAgdmFsdWVMaXN0OiBjc3NgXG4gICAgbWFyZ2luLXJpZ2h0OiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICBgLFxuICB2YWx1ZUxpc3RXcmFwcGVyOiBjc3NgXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ib3JkZXIubWVkaXVtfTtcbiAgICBtYXJnaW46ICR7dGhlbWUuc3BhY2luZygxLCAwKX07XG4gICAgcGFkZGluZzogJHt0aGVtZS5zcGFjaW5nKDEsIDAsIDEsIDEpfTtcbiAgYCxcbiAgdmFsdWVMaXN0QXJlYTogY3NzYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIG1hcmdpbi10b3A6ICR7dGhlbWUuc3BhY2luZygxKX07XG4gIGAsXG4gIHZhbHVlVGl0bGU6IGNzc2BcbiAgICBtYXJnaW4tbGVmdDogLSR7dGhlbWUuc3BhY2luZygwLjUpfTtcbiAgICBtYXJnaW4tYm90dG9tOiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICBgLFxuICB2YWxpZGF0aW9uU3RhdHVzOiBjc3NgXG4gICAgcGFkZGluZzogJHt0aGVtZS5zcGFjaW5nKDAuNSl9O1xuICAgIG1hcmdpbi1ib3R0b206ICR7dGhlbWUuc3BhY2luZygxKX07XG4gICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnRleHQubWF4Q29udHJhc3R9O1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgYCxcbn0pO1xuXG5leHBvcnQgY2xhc3MgVW50aGVtZWRMb2tpTGFiZWxCcm93c2VyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PEJyb3dzZXJQcm9wcywgQnJvd3NlclN0YXRlPiB7XG4gIHN0YXRlOiBCcm93c2VyU3RhdGUgPSB7XG4gICAgbGFiZWxzOiBbXSBhcyBTZWxlY3RhYmxlTGFiZWxbXSxcbiAgICBzZWFyY2hUZXJtOiAnJyxcbiAgICBzdGF0dXM6ICdSZWFkeScsXG4gICAgZXJyb3I6ICcnLFxuICAgIHZhbGlkYXRpb25TdGF0dXM6ICcnLFxuICB9O1xuXG4gIG9uQ2hhbmdlU2VhcmNoID0gKGV2ZW50OiBDaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzZWFyY2hUZXJtOiBldmVudC50YXJnZXQudmFsdWUgfSk7XG4gIH07XG5cbiAgb25DbGlja1J1bkxvZ3NRdWVyeSA9ICgpID0+IHtcbiAgICByZXBvcnRJbnRlcmFjdGlvbignZ3JhZmFuYV9sb2tpX2xvZ19icm93c2VyX2Nsb3NlZCcsIHtcbiAgICAgIGFwcDogdGhpcy5wcm9wcy5hcHAsXG4gICAgICBjbG9zZVR5cGU6ICdzaG93TG9nc0J1dHRvbicsXG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKTtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHNlbGVjdG9yKTtcbiAgfTtcblxuICBvbkNsaWNrUnVuTWV0cmljc1F1ZXJ5ID0gKCkgPT4ge1xuICAgIHJlcG9ydEludGVyYWN0aW9uKCdncmFmYW5hX2xva2lfbG9nX2Jyb3dzZXJfY2xvc2VkJywge1xuICAgICAgYXBwOiB0aGlzLnByb3BzLmFwcCxcbiAgICAgIGNsb3NlVHlwZTogJ3Nob3dMb2dzUmF0ZUJ1dHRvbicsXG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKTtcbiAgICBjb25zdCBxdWVyeSA9IGByYXRlKCR7c2VsZWN0b3J9WyRfX2ludGVydmFsXSlgO1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2UocXVlcnkpO1xuICB9O1xuXG4gIG9uQ2xpY2tDbGVhciA9ICgpID0+IHtcbiAgICByZXBvcnRJbnRlcmFjdGlvbignZ3JhZmFuYV9sb2tpX2xvZ19icm93c2VyX2Nsb3NlZCcsIHtcbiAgICAgIGFwcDogdGhpcy5wcm9wcy5hcHAsXG4gICAgICBjbG9zZVR5cGU6ICdjbGVhckJ1dHRvbicsXG4gICAgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10gPSBzdGF0ZS5sYWJlbHMubWFwKChsYWJlbCkgPT4gKHtcbiAgICAgICAgLi4ubGFiZWwsXG4gICAgICAgIHZhbHVlczogdW5kZWZpbmVkLFxuICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICBmYWNldHM6IHVuZGVmaW5lZCxcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB7IGxhYmVscywgc2VhcmNoVGVybTogJycsIHN0YXR1czogJycsIGVycm9yOiAnJywgdmFsaWRhdGlvblN0YXR1czogJycgfTtcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLmRlbGV0ZUxhc3RVc2VkTGFiZWxzKCk7XG4gIH07XG5cbiAgb25DbGlja0xhYmVsID0gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVG9nZ2xlIHNlbGVjdGVkIHN0YXRlXG4gICAgY29uc3Qgc2VsZWN0ZWQgPSAhbGFiZWwuc2VsZWN0ZWQ7XG4gICAgbGV0IG5leHRWYWx1ZTogUGFydGlhbDxTZWxlY3RhYmxlTGFiZWw+ID0geyBzZWxlY3RlZCB9O1xuICAgIGlmIChsYWJlbC52YWx1ZXMgJiYgIXNlbGVjdGVkKSB7XG4gICAgICAvLyBEZXNlbGVjdCBhbGwgdmFsdWVzIGlmIGxhYmVsIHdhcyBkZXNlbGVjdGVkXG4gICAgICBjb25zdCB2YWx1ZXMgPSBsYWJlbC52YWx1ZXMubWFwKCh2YWx1ZSkgPT4gKHsgLi4udmFsdWUsIHNlbGVjdGVkOiBmYWxzZSB9KSk7XG4gICAgICBuZXh0VmFsdWUgPSB7IC4uLm5leHRWYWx1ZSwgZmFjZXRzOiAwLCB2YWx1ZXMgfTtcbiAgICB9XG4gICAgLy8gUmVzZXR0aW5nIHNlYXJjaCB0byBwcmV2ZW50IGVtcHR5IHJlc3VsdHNcbiAgICB0aGlzLnNldFN0YXRlKHsgc2VhcmNoVGVybTogJycgfSk7XG4gICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIG5leHRWYWx1ZSwgJycsICgpID0+IHRoaXMuZG9GYWNldHRpbmdGb3JMYWJlbChuYW1lKSk7XG4gIH07XG5cbiAgb25DbGlja1ZhbHVlID0gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwgfHwgIWxhYmVsLnZhbHVlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXNldHRpbmcgc2VhcmNoIHRvIHByZXZlbnQgZW1wdHkgcmVzdWx0c1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzZWFyY2hUZXJtOiAnJyB9KTtcbiAgICAvLyBUb2dnbGluZyB2YWx1ZSBmb3Igc2VsZWN0ZWQgbGFiZWwsIGxlYXZpbmcgb3RoZXIgdmFsdWVzIGludGFjdFxuICAgIGNvbnN0IHZhbHVlcyA9IGxhYmVsLnZhbHVlcy5tYXAoKHYpID0+ICh7IC4uLnYsIHNlbGVjdGVkOiB2Lm5hbWUgPT09IHZhbHVlID8gIXYuc2VsZWN0ZWQgOiB2LnNlbGVjdGVkIH0pKTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyB2YWx1ZXMgfSwgJycsICgpID0+IHRoaXMuZG9GYWNldHRpbmcobmFtZSkpO1xuICB9O1xuXG4gIG9uQ2xpY2tWYWxpZGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGJ1aWxkU2VsZWN0b3IodGhpcy5zdGF0ZS5sYWJlbHMpO1xuICAgIHRoaXMudmFsaWRhdGVTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG5cbiAgdXBkYXRlTGFiZWxTdGF0ZShuYW1lOiBzdHJpbmcsIHVwZGF0ZWRGaWVsZHM6IFBhcnRpYWw8U2VsZWN0YWJsZUxhYmVsPiwgc3RhdHVzID0gJycsIGNiPzogKCkgPT4gdm9pZCkge1xuICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gc3RhdGUubGFiZWxzLm1hcCgobGFiZWwpID0+IHtcbiAgICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4geyAuLi5sYWJlbCwgLi4udXBkYXRlZEZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0pO1xuICAgICAgLy8gTmV3IHN0YXR1cyBvdmVycmlkZXMgZXJyb3JzXG4gICAgICBjb25zdCBlcnJvciA9IHN0YXR1cyA/ICcnIDogc3RhdGUuZXJyb3I7XG4gICAgICByZXR1cm4geyBsYWJlbHMsIHN0YXR1cywgZXJyb3IsIHZhbGlkYXRpb25TdGF0dXM6ICcnIH07XG4gICAgfSwgY2IpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBsYW5ndWFnZVByb3ZpZGVyLCBhdXRvU2VsZWN0ID0gTUFYX0FVVE9fU0VMRUNULCBsYXN0VXNlZExhYmVscyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAobGFuZ3VhZ2VQcm92aWRlcikge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRMYWJlbHM6IHN0cmluZ1tdID0gbGFzdFVzZWRMYWJlbHM7XG4gICAgICBsYW5ndWFnZVByb3ZpZGVyLnN0YXJ0KCkudGhlbigoKSA9PiB7XG4gICAgICAgIGxldCByYXdMYWJlbHM6IHN0cmluZ1tdID0gbGFuZ3VhZ2VQcm92aWRlci5nZXRMYWJlbEtleXMoKTtcbiAgICAgICAgaWYgKHJhd0xhYmVscy5sZW5ndGggPiBNQVhfTEFCRUxfQ09VTlQpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IGBUb28gbWFueSBsYWJlbHMgZm91bmQgKHNob3dpbmcgb25seSAke01BWF9MQUJFTF9DT1VOVH0gb2YgJHtyYXdMYWJlbHMubGVuZ3RofSlgO1xuICAgICAgICAgIHJhd0xhYmVscyA9IHJhd0xhYmVscy5zbGljZSgwLCBNQVhfTEFCRUxfQ09VTlQpO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdXRvLXNlbGVjdCBhbGwgbGFiZWxzIGlmIGxhYmVsIGxpc3QgaXMgc21hbGwgZW5vdWdoXG4gICAgICAgIGNvbnN0IGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10gPSByYXdMYWJlbHMubWFwKChsYWJlbCwgaSwgYXJyKSA9PiAoe1xuICAgICAgICAgIG5hbWU6IGxhYmVsLFxuICAgICAgICAgIHNlbGVjdGVkOiAoYXJyLmxlbmd0aCA8PSBhdXRvU2VsZWN0ICYmIHNlbGVjdGVkTGFiZWxzLmxlbmd0aCA9PT0gMCkgfHwgc2VsZWN0ZWRMYWJlbHMuaW5jbHVkZXMobGFiZWwpLFxuICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIFByZS1mZXRjaCB2YWx1ZXMgZm9yIHNlbGVjdGVkIGxhYmVsc1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzIH0sICgpID0+IHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmxhYmVscy5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhYmVsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmV0Y2hWYWx1ZXMobGFiZWwubmFtZSwgRU1QVFlfU0VMRUNUT1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGRvRmFjZXR0aW5nRm9yTGFiZWwobmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscy5maWx0ZXIoKGxhYmVsKSA9PiBsYWJlbC5zZWxlY3RlZCkubWFwKChsYWJlbCkgPT4gbGFiZWwubmFtZSk7XG4gICAgdGhpcy5wcm9wcy5zdG9yZUxhc3RVc2VkTGFiZWxzKHNlbGVjdGVkTGFiZWxzKTtcbiAgICBpZiAobGFiZWwuc2VsZWN0ZWQpIHtcbiAgICAgIC8vIFJlZmV0Y2ggdmFsdWVzIGZvciBuZXdseSBzZWxlY3RlZCBsYWJlbC4uLlxuICAgICAgaWYgKCFsYWJlbC52YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5mZXRjaFZhbHVlcyhuYW1lLCBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgbmVlZCB0byBmYWNldCB3aGVuIGRlc2VsZWN0aW5nIGxhYmVsc1xuICAgICAgdGhpcy5kb0ZhY2V0dGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGRvRmFjZXR0aW5nID0gKGxhc3RGYWNldHRlZD86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgaWYgKHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUikge1xuICAgICAgLy8gQ2xlYXIgdXAgZmFjZXR0aW5nXG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gdGhpcy5zdGF0ZS5sYWJlbHMubWFwKChsYWJlbCkgPT4ge1xuICAgICAgICByZXR1cm4geyAuLi5sYWJlbCwgZmFjZXRzOiAwLCB2YWx1ZXM6IHVuZGVmaW5lZCwgaGlkZGVuOiBmYWxzZSB9O1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzIH0sICgpID0+IHtcbiAgICAgICAgLy8gR2V0IGZyZXNoIHNldCBvZiB2YWx1ZXNcbiAgICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMuZm9yRWFjaCgobGFiZWwpID0+IGxhYmVsLnNlbGVjdGVkICYmIHRoaXMuZmV0Y2hWYWx1ZXMobGFiZWwubmFtZSwgc2VsZWN0b3IpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEbyBmYWNldHRpbmdcbiAgICAgIHRoaXMuZmV0Y2hTZXJpZXMoc2VsZWN0b3IsIGxhc3RGYWNldHRlZCk7XG4gICAgfVxuICB9O1xuXG4gIGFzeW5jIGZldGNoVmFsdWVzKG5hbWU6IHN0cmluZywgc2VsZWN0b3I6IHN0cmluZykge1xuICAgIGNvbnN0IHsgbGFuZ3VhZ2VQcm92aWRlciB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyBsb2FkaW5nOiB0cnVlIH0sIGBGZXRjaGluZyB2YWx1ZXMgZm9yICR7bmFtZX1gKTtcbiAgICB0cnkge1xuICAgICAgbGV0IHJhd1ZhbHVlcyA9IGF3YWl0IGxhbmd1YWdlUHJvdmlkZXIuZ2V0TGFiZWxWYWx1ZXMobmFtZSk7XG4gICAgICAvLyBJZiBzZWxlY3RvciBjaGFuZ2VkLCBjbGVhciBsb2FkaW5nIHN0YXRlIGFuZCBkaXNjYXJkIHJlc3VsdCBieSByZXR1cm5pbmcgZWFybHlcbiAgICAgIGlmIChzZWxlY3RvciAhPT0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscykpIHtcbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIHsgbG9hZGluZzogZmFsc2UgfSwgJycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmF3VmFsdWVzLmxlbmd0aCA+IE1BWF9WQUxVRV9DT1VOVCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IGBUb28gbWFueSB2YWx1ZXMgZm9yICR7bmFtZX0gKHNob3dpbmcgb25seSAke01BWF9WQUxVRV9DT1VOVH0gb2YgJHtyYXdWYWx1ZXMubGVuZ3RofSlgO1xuICAgICAgICByYXdWYWx1ZXMgPSByYXdWYWx1ZXMuc2xpY2UoMCwgTUFYX1ZBTFVFX0NPVU5UKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9yIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVzOiBGYWNldHRhYmxlVmFsdWVbXSA9IHJhd1ZhbHVlcy5tYXAoKHZhbHVlKSA9PiAoeyBuYW1lOiB2YWx1ZSB9KSk7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyB2YWx1ZXMsIGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmZXRjaFNlcmllcyhzZWxlY3Rvcjogc3RyaW5nLCBsYXN0RmFjZXR0ZWQ/OiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKGxhc3RGYWNldHRlZCkge1xuICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKGxhc3RGYWNldHRlZCwgeyBsb2FkaW5nOiB0cnVlIH0sIGBGYWNldHRpbmcgbGFiZWxzIGZvciAke3NlbGVjdG9yfWApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcG9zc2libGVMYWJlbHMgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzTGFiZWxzKHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgIC8vIElmIHNlbGVjdG9yIGNoYW5nZWQsIGNsZWFyIGxvYWRpbmcgc3RhdGUgYW5kIGRpc2NhcmQgcmVzdWx0IGJ5IHJldHVybmluZyBlYXJseVxuICAgICAgaWYgKHNlbGVjdG9yICE9PSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKSkge1xuICAgICAgICBpZiAobGFzdEZhY2V0dGVkKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKGxhc3RGYWNldHRlZCwgeyBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMocG9zc2libGVMYWJlbHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IGBFbXB0eSByZXN1bHRzLCBubyBtYXRjaGluZyBsYWJlbCBmb3IgJHtzZWxlY3Rvcn1gIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gZmFjZXRMYWJlbHModGhpcy5zdGF0ZS5sYWJlbHMsIHBvc3NpYmxlTGFiZWxzLCBsYXN0RmFjZXR0ZWQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVscywgZXJyb3I6ICcnIH0pO1xuICAgICAgaWYgKGxhc3RGYWNldHRlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobGFzdEZhY2V0dGVkLCB7IGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZVNlbGVjdG9yKHNlbGVjdG9yOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHZhbGlkYXRpb25TdGF0dXM6IGBWYWxpZGF0aW5nIHNlbGVjdG9yICR7c2VsZWN0b3J9YCwgZXJyb3I6ICcnIH0pO1xuICAgIGNvbnN0IHN0cmVhbXMgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzKHNlbGVjdG9yKTtcbiAgICB0aGlzLnNldFN0YXRlKHsgdmFsaWRhdGlvblN0YXR1czogYFNlbGVjdG9yIGlzIHZhbGlkICgke3N0cmVhbXMubGVuZ3RofSBzdHJlYW1zIGZvdW5kKWAgfSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyB0aGVtZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGxhYmVscywgc2VhcmNoVGVybSwgc3RhdHVzLCBlcnJvciwgdmFsaWRhdGlvblN0YXR1cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDxMb2FkaW5nUGxhY2Vob2xkZXIgdGV4dD1cIkxvYWRpbmcgbGFiZWxzLi4uXCIgLz47XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlcyh0aGVtZSk7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKTtcbiAgICBjb25zdCBlbXB0eSA9IHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUjtcblxuICAgIGxldCBzZWxlY3RlZExhYmVscyA9IGxhYmVscy5maWx0ZXIoKGxhYmVsKSA9PiBsYWJlbC5zZWxlY3RlZCAmJiBsYWJlbC52YWx1ZXMpO1xuICAgIGlmIChzZWFyY2hUZXJtKSB7XG4gICAgICBzZWxlY3RlZExhYmVscyA9IHNlbGVjdGVkTGFiZWxzLm1hcCgobGFiZWwpID0+IHtcbiAgICAgICAgY29uc3Qgc2VhcmNoUmVzdWx0cyA9IGxhYmVsLnZhbHVlcyEuZmlsdGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gc2VsZWN0ZWQgdmFsdWVzXG4gICAgICAgICAgaWYgKHZhbHVlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YWx1ZS5oaWdobGlnaHRQYXJ0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmdXp6eU1hdGNoUmVzdWx0ID0gZnV6enlNYXRjaCh2YWx1ZS5uYW1lLnRvTG93ZXJDYXNlKCksIHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgaWYgKGZ1enp5TWF0Y2hSZXN1bHQuZm91bmQpIHtcbiAgICAgICAgICAgIHZhbHVlLmhpZ2hsaWdodFBhcnRzID0gZnV6enlNYXRjaFJlc3VsdC5yYW5nZXM7XG4gICAgICAgICAgICB2YWx1ZS5vcmRlciA9IGZ1enp5TWF0Y2hSZXN1bHQuZGlzdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ubGFiZWwsXG4gICAgICAgICAgdmFsdWVzOiBzb3J0Qnkoc2VhcmNoUmVzdWx0cywgKHZhbHVlKSA9PiAodmFsdWUuc2VsZWN0ZWQgPyAtSW5maW5pdHkgOiB2YWx1ZS5vcmRlcikpLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIGhpZ2hsaWdodCBwYXJ0cyB3aGVuIHNlYXJjaFRlcm0gaXMgY2xlYXJlZFxuICAgICAgc2VsZWN0ZWRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVsc1xuICAgICAgICAuZmlsdGVyKChsYWJlbCkgPT4gbGFiZWwuc2VsZWN0ZWQgJiYgbGFiZWwudmFsdWVzKVxuICAgICAgICAubWFwKChsYWJlbCkgPT4gKHtcbiAgICAgICAgICAuLi5sYWJlbCxcbiAgICAgICAgICB2YWx1ZXM6IGxhYmVsPy52YWx1ZXMgPyBsYWJlbC52YWx1ZXMubWFwKCh2YWx1ZSkgPT4gKHsgLi4udmFsdWUsIGhpZ2hsaWdodFBhcnRzOiB1bmRlZmluZWQgfSkpIDogW10sXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICA8TGFiZWwgZGVzY3JpcHRpb249XCJXaGljaCBsYWJlbHMgd291bGQgeW91IGxpa2UgdG8gY29uc2lkZXIgZm9yIHlvdXIgc2VhcmNoP1wiPlxuICAgICAgICAgICAgMS4gU2VsZWN0IGxhYmVscyB0byBzZWFyY2ggaW5cbiAgICAgICAgICA8L0xhYmVsPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubGlzdH0+XG4gICAgICAgICAgICB7bGFiZWxzLm1hcCgobGFiZWwpID0+IChcbiAgICAgICAgICAgICAgPExva2lMYWJlbFxuICAgICAgICAgICAgICAgIGtleT17bGFiZWwubmFtZX1cbiAgICAgICAgICAgICAgICBuYW1lPXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgIGxvYWRpbmc9e2xhYmVsLmxvYWRpbmd9XG4gICAgICAgICAgICAgICAgYWN0aXZlPXtsYWJlbC5zZWxlY3RlZH1cbiAgICAgICAgICAgICAgICBoaWRkZW49e2xhYmVsLmhpZGRlbn1cbiAgICAgICAgICAgICAgICBmYWNldHM9e2xhYmVsLmZhY2V0c31cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tMYWJlbH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICA8TGFiZWwgZGVzY3JpcHRpb249XCJDaG9vc2UgdGhlIGxhYmVsIHZhbHVlcyB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIHVzZSBmb3IgdGhlIHF1ZXJ5LiBVc2UgdGhlIHNlYXJjaCBmaWVsZCB0byBmaW5kIHZhbHVlcyBhY3Jvc3Mgc2VsZWN0ZWQgbGFiZWxzLlwiPlxuICAgICAgICAgICAgMi4gRmluZCB2YWx1ZXMgZm9yIHRoZSBzZWxlY3RlZCBsYWJlbHNcbiAgICAgICAgICA8L0xhYmVsPlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8SW5wdXQgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2VTZWFyY2h9IGFyaWEtbGFiZWw9XCJGaWx0ZXIgZXhwcmVzc2lvbiBmb3IgdmFsdWVzXCIgdmFsdWU9e3NlYXJjaFRlcm19IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3RBcmVhfT5cbiAgICAgICAgICAgIHtzZWxlY3RlZExhYmVscy5tYXAoKGxhYmVsKSA9PiAoXG4gICAgICAgICAgICAgIDxkaXYgcm9sZT1cImxpc3RcIiBrZXk9e2xhYmVsLm5hbWV9IGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlTGlzdFdyYXBwZXJ9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmFsdWVUaXRsZX0gYXJpYS1sYWJlbD17YFZhbHVlcyBmb3IgJHtsYWJlbC5uYW1lfWB9PlxuICAgICAgICAgICAgICAgICAgPExva2lMYWJlbFxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsYWJlbC5sb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e2xhYmVsLnNlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICBoaWRkZW49e2xhYmVsLmhpZGRlbn1cbiAgICAgICAgICAgICAgICAgICAgLy9JZiBubyBmYWNldHMsIHdlIHdhbnQgdG8gc2hvdyBudW1iZXIgb2YgYWxsIGxhYmVsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBmYWNldHM9e2xhYmVsLmZhY2V0cyB8fCBsYWJlbC52YWx1ZXM/Lmxlbmd0aH1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsaWNrTGFiZWx9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxGaXhlZFNpemVMaXN0XG4gICAgICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cbiAgICAgICAgICAgICAgICAgIGl0ZW1Db3VudD17bGFiZWwudmFsdWVzPy5sZW5ndGggfHwgMH1cbiAgICAgICAgICAgICAgICAgIGl0ZW1TaXplPXsyOH1cbiAgICAgICAgICAgICAgICAgIGl0ZW1LZXk9eyhpKSA9PiAobGFiZWwudmFsdWVzIGFzIEZhY2V0dGFibGVWYWx1ZVtdKVtpXS5uYW1lfVxuICAgICAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlTGlzdH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7KHsgaW5kZXgsIHN0eWxlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBsYWJlbC52YWx1ZXM/LltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxMb2tpTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17bGFiZWwubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlPy5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e3ZhbHVlPy5zZWxlY3RlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UGFydHM9e3ZhbHVlPy5oaWdobGlnaHRQYXJ0c31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsaWNrVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFRlcm09e3NlYXJjaFRlcm19XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA8L0ZpeGVkU2l6ZUxpc3Q+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNlY3Rpb259PlxuICAgICAgICAgIDxMYWJlbD4zLiBSZXN1bHRpbmcgc2VsZWN0b3I8L0xhYmVsPlxuICAgICAgICAgIDxkaXYgYXJpYS1sYWJlbD1cInNlbGVjdG9yXCIgY2xhc3NOYW1lPXtzdHlsZXMuc2VsZWN0b3J9PlxuICAgICAgICAgICAge3NlbGVjdG9yfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHt2YWxpZGF0aW9uU3RhdHVzICYmIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmFsaWRhdGlvblN0YXR1c30+e3ZhbGlkYXRpb25TdGF0dXN9PC9kaXY+fVxuICAgICAgICAgIDxIb3Jpem9udGFsR3JvdXA+XG4gICAgICAgICAgICA8QnV0dG9uIGFyaWEtbGFiZWw9XCJVc2Ugc2VsZWN0b3IgYXMgbG9ncyBidXR0b25cIiBkaXNhYmxlZD17ZW1wdHl9IG9uQ2xpY2s9e3RoaXMub25DbGlja1J1bkxvZ3NRdWVyeX0+XG4gICAgICAgICAgICAgIFNob3cgbG9nc1xuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJVc2Ugc2VsZWN0b3IgYXMgbWV0cmljcyBidXR0b25cIlxuICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2VtcHR5fVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tSdW5NZXRyaWNzUXVlcnl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFNob3cgbG9ncyByYXRlXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlZhbGlkYXRlIHN1Ym1pdCBidXR0b25cIlxuICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2VtcHR5fVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tWYWxpZGF0ZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgVmFsaWRhdGUgc2VsZWN0b3JcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPEJ1dHRvbiBhcmlhLWxhYmVsPVwiU2VsZWN0b3IgY2xlYXIgYnV0dG9uXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9e3RoaXMub25DbGlja0NsZWFyfT5cbiAgICAgICAgICAgICAgQ2xlYXJcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2N4KHN0eWxlcy5zdGF0dXMsIChzdGF0dXMgfHwgZXJyb3IpICYmIHN0eWxlcy5zdGF0dXNTaG93aW5nKX0+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17ZXJyb3IgPyBzdHlsZXMuZXJyb3IgOiAnJ30+e2Vycm9yIHx8IHN0YXR1c308L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L0hvcml6b250YWxHcm91cD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBMb2tpTGFiZWxCcm93c2VyID0gd2l0aFRoZW1lMihVbnRoZW1lZExva2lMYWJlbEJyb3dzZXIpO1xuIiwiLy8gTGlicmFyaWVzXG5pbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcblxuLy8gVHlwZXNcbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBJbmxpbmVGb3JtTGFiZWwsIFJhZGlvQnV0dG9uR3JvdXAsIElubGluZUZpZWxkLCBJbnB1dCwgU2VsZWN0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBMb2tpUXVlcnksIExva2lRdWVyeVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raU9wdGlvbkZpZWxkc1Byb3BzIHtcbiAgbGluZUxpbWl0VmFsdWU6IHN0cmluZztcbiAgcmVzb2x1dGlvbjogbnVtYmVyO1xuICBxdWVyeTogTG9raVF1ZXJ5O1xuICBvbkNoYW5nZTogKHZhbHVlOiBMb2tpUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIHJ1bk9uQmx1cj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBxdWVyeVR5cGVPcHRpb25zOiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8TG9raVF1ZXJ5VHlwZT4+ID0gW1xuICB7IHZhbHVlOiBMb2tpUXVlcnlUeXBlLlJhbmdlLCBsYWJlbDogJ1JhbmdlJywgZGVzY3JpcHRpb246ICdSdW4gcXVlcnkgb3ZlciBhIHJhbmdlIG9mIHRpbWUuJyB9LFxuICB7XG4gICAgdmFsdWU6IExva2lRdWVyeVR5cGUuSW5zdGFudCxcbiAgICBsYWJlbDogJ0luc3RhbnQnLFxuICAgIGRlc2NyaXB0aW9uOiAnUnVuIHF1ZXJ5IGFnYWluc3QgYSBzaW5nbGUgcG9pbnQgaW4gdGltZS4gRm9yIHRoaXMgcXVlcnksIHRoZSBcIlRvXCIgdGltZSBpcyB1c2VkLicsXG4gIH0sXG5dO1xuXG5pZiAoY29uZmlnLmZlYXR1cmVUb2dnbGVzLmxva2lMaXZlKSB7XG4gIHF1ZXJ5VHlwZU9wdGlvbnMucHVzaCh7XG4gICAgdmFsdWU6IExva2lRdWVyeVR5cGUuU3RyZWFtLFxuICAgIGxhYmVsOiAnU3RyZWFtJyxcbiAgICBkZXNjcmlwdGlvbjogJ1J1biBhIHF1ZXJ5IGFuZCBrZWVwIHNlbmRpbmcgcmVzdWx0cyBvbiBhbiBpbnRlcnZhbCcsXG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9SRVNPTFVUSU9OOiBTZWxlY3RhYmxlVmFsdWU8bnVtYmVyPiA9IHtcbiAgdmFsdWU6IDEsXG4gIGxhYmVsOiAnMS8xJyxcbn07XG5cbmV4cG9ydCBjb25zdCBSRVNPTFVUSU9OX09QVElPTlM6IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxudW1iZXI+PiA9IFtERUZBVUxUX1JFU09MVVRJT05dLmNvbmNhdChcbiAgbWFwKFsyLCAzLCA0LCA1LCAxMF0sICh2YWx1ZTogbnVtYmVyKSA9PiAoe1xuICAgIHZhbHVlLFxuICAgIGxhYmVsOiAnMS8nICsgdmFsdWUsXG4gIH0pKVxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIExva2lPcHRpb25GaWVsZHMocHJvcHM6IExva2lPcHRpb25GaWVsZHNQcm9wcykge1xuICBjb25zdCB7IGxpbmVMaW1pdFZhbHVlLCByZXNvbHV0aW9uLCBvblJ1blF1ZXJ5LCBydW5PbkJsdXIsIG9uQ2hhbmdlIH0gPSBwcm9wcztcbiAgY29uc3QgcXVlcnkgPSBwcm9wcy5xdWVyeSA/PyB7fTtcbiAgbGV0IHF1ZXJ5VHlwZSA9IHF1ZXJ5LnF1ZXJ5VHlwZSA/PyAocXVlcnkuaW5zdGFudCA/IExva2lRdWVyeVR5cGUuSW5zdGFudCA6IExva2lRdWVyeVR5cGUuUmFuZ2UpO1xuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlUXVlcnlMaW1pdCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgbmV4dFF1ZXJ5ID0geyAuLi5xdWVyeSwgbWF4TGluZXM6IHByZXByb2Nlc3NNYXhMaW5lcyh2YWx1ZSkgfTtcbiAgICBvbkNoYW5nZShuZXh0UXVlcnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25RdWVyeVR5cGVDaGFuZ2UocXVlcnlUeXBlOiBMb2tpUXVlcnlUeXBlKSB7XG4gICAgY29uc3QgeyBpbnN0YW50LCByYW5nZSwgLi4ucmVzdCB9ID0gcXVlcnk7XG4gICAgb25DaGFuZ2UoeyAuLi5yZXN0LCBxdWVyeVR5cGUgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbk1heExpbmVzQ2hhbmdlKGU6IFJlYWN0LlN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSB7XG4gICAgaWYgKHF1ZXJ5Lm1heExpbmVzICE9PSBwcmVwcm9jZXNzTWF4TGluZXMoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKSkge1xuICAgICAgb25DaGFuZ2VRdWVyeUxpbWl0KGUuY3VycmVudFRhcmdldC52YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZXR1cm5LZXlEb3duKGU6IFJlYWN0LktleWJvYXJkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pIHtcbiAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgIG9uUnVuUXVlcnkoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblJlc29sdXRpb25DaGFuZ2Uob3B0aW9uOiBTZWxlY3RhYmxlVmFsdWU8bnVtYmVyPikge1xuICAgIGNvbnN0IG5leHRRdWVyeSA9IHsgLi4ucXVlcnksIHJlc29sdXRpb246IG9wdGlvbi52YWx1ZSB9O1xuICAgIG9uQ2hhbmdlKG5leHRRdWVyeSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgYXJpYS1sYWJlbD1cIkxva2kgZXh0cmEgZmllbGRcIiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgey8qUXVlcnkgdHlwZSBmaWVsZCovfVxuICAgICAgPGRpdlxuICAgICAgICBkYXRhLXRlc3RpZD1cInF1ZXJ5VHlwZUZpZWxkXCJcbiAgICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAgICAnZ2YtZm9ybSBleHBsb3JlLWlucHV0LW1hcmdpbicsXG4gICAgICAgICAgY3NzYFxuICAgICAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XG4gICAgICAgICAgYFxuICAgICAgICApfVxuICAgICAgICBhcmlhLWxhYmVsPVwiUXVlcnkgdHlwZSBmaWVsZFwiXG4gICAgICA+XG4gICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgd2lkdGg9XCJhdXRvXCI+UXVlcnkgdHlwZTwvSW5saW5lRm9ybUxhYmVsPlxuXG4gICAgICAgIDxSYWRpb0J1dHRvbkdyb3VwXG4gICAgICAgICAgb3B0aW9ucz17cXVlcnlUeXBlT3B0aW9uc31cbiAgICAgICAgICB2YWx1ZT17cXVlcnlUeXBlfVxuICAgICAgICAgIG9uQ2hhbmdlPXsodHlwZTogTG9raVF1ZXJ5VHlwZSkgPT4ge1xuICAgICAgICAgICAgb25RdWVyeVR5cGVDaGFuZ2UodHlwZSk7XG4gICAgICAgICAgICBpZiAocnVuT25CbHVyKSB7XG4gICAgICAgICAgICAgIG9uUnVuUXVlcnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgICB7LypMaW5lIGxpbWl0IGZpZWxkKi99XG4gICAgICA8ZGl2XG4gICAgICAgIGRhdGEtdGVzdGlkPVwibGluZUxpbWl0RmllbGRcIlxuICAgICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICAgICdnZi1mb3JtJyxcbiAgICAgICAgICBjc3NgXG4gICAgICAgICAgICBmbGV4LXdyYXA6IG5vd3JhcDtcbiAgICAgICAgICBgXG4gICAgICAgICl9XG4gICAgICAgIGFyaWEtbGFiZWw9XCJMaW5lIGxpbWl0IGZpZWxkXCJcbiAgICAgID5cbiAgICAgICAgPElubGluZUZpZWxkIGxhYmVsPVwiTGluZSBsaW1pdFwiIHRvb2x0aXA9eydVcHBlciBsaW1pdCBmb3IgbnVtYmVyIG9mIGxvZyBsaW5lcyByZXR1cm5lZCBieSBxdWVyeS4nfT5cbiAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTRcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJhdXRvXCJcbiAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgbWluPXswfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uTWF4TGluZXNDaGFuZ2V9XG4gICAgICAgICAgICBvbktleURvd249e29uUmV0dXJuS2V5RG93bn1cbiAgICAgICAgICAgIHZhbHVlPXtsaW5lTGltaXRWYWx1ZX1cbiAgICAgICAgICAgIG9uQmx1cj17KCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocnVuT25CbHVyKSB7XG4gICAgICAgICAgICAgICAgb25SdW5RdWVyeSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvSW5saW5lRmllbGQ+XG4gICAgICAgIDxJbmxpbmVGaWVsZFxuICAgICAgICAgIGxhYmVsPVwiUmVzb2x1dGlvblwiXG4gICAgICAgICAgdG9vbHRpcD17XG4gICAgICAgICAgICAnUmVzb2x1dGlvbiAxLzEgc2V0cyBzdGVwIHBhcmFtZXRlciBvZiBMb2tpIG1ldHJpY3MgcmFuZ2UgcXVlcmllcyBzdWNoIHRoYXQgZWFjaCBwaXhlbCBjb3JyZXNwb25kcyB0byBvbmUgZGF0YSBwb2ludC4gRm9yIGJldHRlciBwZXJmb3JtYW5jZSwgbG93ZXIgcmVzb2x1dGlvbnMgY2FuIGJlIHBpY2tlZC4gMS8yIG9ubHkgcmV0cmlldmVzIGEgZGF0YSBwb2ludCBmb3IgZXZlcnkgb3RoZXIgcGl4ZWwsIGFuZCAxLzEwIHJldHJpZXZlcyBvbmUgZGF0YSBwb2ludCBwZXIgMTAgcGl4ZWxzLidcbiAgICAgICAgICB9XG4gICAgICAgID5cbiAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICBpc1NlYXJjaGFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uUmVzb2x1dGlvbkNoYW5nZX1cbiAgICAgICAgICAgIG9wdGlvbnM9e1JFU09MVVRJT05fT1BUSU9OU31cbiAgICAgICAgICAgIHZhbHVlPXtyZXNvbHV0aW9ufVxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlNlbGVjdCByZXNvbHV0aW9uXCJcbiAgICAgICAgICAvPlxuICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW8oTG9raU9wdGlvbkZpZWxkcyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzTWF4TGluZXModmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBlbXB0eSBpbnB1dCAtIGZhbGxzIGJhY2sgdG8gZGF0YVNvdXJjZS5tYXhMaW5lcyBsaW1pdFxuICAgIHJldHVybiBOYU47XG4gIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID4gMCAmJiAoaXNOYU4oK3ZhbHVlKSB8fCArdmFsdWUgPCAwKSkge1xuICAgIC8vIGlucHV0IHdpdGggYXQgbGVhc3QgMSBjaGFyYWN0ZXIgYW5kIHRoYXQgaXMgZWl0aGVyIGluY29ycmVjdCAodmFsdWUgaW4gdGhlIGlucHV0IGZpZWxkIGlzIG5vdCBhIG51bWJlcikgb3IgbmVnYXRpdmVcbiAgICAvLyBmYWxscyBiYWNrIHRvIHRoZSBsaW1pdCBvZiAwIGxpbmVzXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVmYXVsdCBjYXNlIC0gY29ycmVjdCBpbnB1dFxuICAgIHJldHVybiArdmFsdWU7XG4gIH1cbn1cbiIsIi8vIExpYnJhcmllc1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLy8gVHlwZXNcbmltcG9ydCB7IElubGluZUZvcm1MYWJlbCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgTG9raU9wdGlvbkZpZWxkcyB9IGZyb20gJy4vTG9raU9wdGlvbkZpZWxkcyc7XG5pbXBvcnQgeyBMb2tpUXVlcnlGaWVsZCB9IGZyb20gJy4vTG9raVF1ZXJ5RmllbGQnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5RWRpdG9yUHJvcHMgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIExva2lRdWVyeUVkaXRvcihwcm9wczogTG9raVF1ZXJ5RWRpdG9yUHJvcHMpIHtcbiAgY29uc3QgeyBxdWVyeSwgZGF0YSwgZGF0YXNvdXJjZSwgb25DaGFuZ2UsIG9uUnVuUXVlcnksIHJhbmdlIH0gPSBwcm9wcztcblxuICBjb25zdCBvbkxlZ2VuZENoYW5nZSA9IChlOiBSZWFjdC5TeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IG5leHRRdWVyeSA9IHsgLi4ucXVlcnksIGxlZ2VuZEZvcm1hdDogZS5jdXJyZW50VGFyZ2V0LnZhbHVlIH07XG4gICAgb25DaGFuZ2UobmV4dFF1ZXJ5KTtcbiAgfTtcblxuICBjb25zdCBsZWdlbmRGaWVsZCA9IChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgPElubGluZUZvcm1MYWJlbFxuICAgICAgICAgIHdpZHRoPXs2fVxuICAgICAgICAgIHRvb2x0aXA9XCJDb250cm9scyB0aGUgbmFtZSBvZiB0aGUgdGltZSBzZXJpZXMsIHVzaW5nIG5hbWUgb3IgcGF0dGVybi4gRm9yIGV4YW1wbGVcbiAgICAgICAge3tob3N0bmFtZX19IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBsYWJlbCB2YWx1ZSBmb3IgdGhlIGxhYmVsIGhvc3RuYW1lLiBUaGUgbGVnZW5kIG9ubHkgYXBwbGllcyB0byBtZXRyaWMgcXVlcmllcy5cIlxuICAgICAgICA+XG4gICAgICAgICAgTGVnZW5kXG4gICAgICAgIDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbnB1dFwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJsZWdlbmQgZm9ybWF0XCJcbiAgICAgICAgICB2YWx1ZT17cXVlcnkubGVnZW5kRm9ybWF0IHx8ICcnfVxuICAgICAgICAgIG9uQ2hhbmdlPXtvbkxlZ2VuZENoYW5nZX1cbiAgICAgICAgICBvbkJsdXI9e29uUnVuUXVlcnl9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxMb2tpUXVlcnlGaWVsZFxuICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICBvbkJsdXI9e29uUnVuUXVlcnl9XG4gICAgICBoaXN0b3J5PXtbXX1cbiAgICAgIGRhdGE9e2RhdGF9XG4gICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5lZGl0b3J9XG4gICAgICByYW5nZT17cmFuZ2V9XG4gICAgICBFeHRyYUZpZWxkRWxlbWVudD17XG4gICAgICAgIDw+XG4gICAgICAgICAgPExva2lPcHRpb25GaWVsZHNcbiAgICAgICAgICAgIGxpbmVMaW1pdFZhbHVlPXtxdWVyeT8ubWF4TGluZXM/LnRvU3RyaW5nKCkgfHwgJyd9XG4gICAgICAgICAgICByZXNvbHV0aW9uPXtxdWVyeT8ucmVzb2x1dGlvbiB8fCAxfVxuICAgICAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgIHJ1bk9uQmx1cj17dHJ1ZX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIHtsZWdlbmRGaWVsZH1cbiAgICAgICAgPC8+XG4gICAgICB9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IHRlc3RJZHMgPSB7XG4gIGVkaXRvcjogJ2xva2ktZWRpdG9yJyxcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgQ29yZUFwcCB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5cbmltcG9ydCB7IExva2lRdWVyeUVkaXRvclNlbGVjdG9yIH0gZnJvbSAnLi4vcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3InO1xuXG5pbXBvcnQgeyBMb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yIH0gZnJvbSAnLi9Mb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yJztcbmltcG9ydCB7IExva2lRdWVyeUVkaXRvciB9IGZyb20gJy4vTG9raVF1ZXJ5RWRpdG9yJztcbmltcG9ydCB7IExva2lRdWVyeUVkaXRvckZvckFsZXJ0aW5nIH0gZnJvbSAnLi9Mb2tpUXVlcnlFZGl0b3JGb3JBbGVydGluZyc7XG5pbXBvcnQgeyBMb2tpUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gTG9raVF1ZXJ5RWRpdG9yQnlBcHAocHJvcHM6IExva2lRdWVyeUVkaXRvclByb3BzKSB7XG4gIGNvbnN0IHsgYXBwIH0gPSBwcm9wcztcblxuICBzd2l0Y2ggKGFwcCkge1xuICAgIGNhc2UgQ29yZUFwcC5DbG91ZEFsZXJ0aW5nOlxuICAgICAgcmV0dXJuIDxMb2tpUXVlcnlFZGl0b3JGb3JBbGVydGluZyB7Li4ucHJvcHN9IC8+O1xuICAgIGNhc2UgQ29yZUFwcC5FeHBsb3JlOlxuICAgICAgaWYgKGNvbmZpZy5mZWF0dXJlVG9nZ2xlcy5sb2tpUXVlcnlCdWlsZGVyKSB7XG4gICAgICAgIHJldHVybiA8TG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3Igey4uLnByb3BzfSAvPjtcbiAgICAgIH1cbiAgICAgIHJldHVybiA8TG9raUV4cGxvcmVRdWVyeUVkaXRvciB7Li4ucHJvcHN9IC8+O1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY29uZmlnLmZlYXR1cmVUb2dnbGVzLmxva2lRdWVyeUJ1aWxkZXIpIHtcbiAgICAgICAgcmV0dXJuIDxMb2tpUXVlcnlFZGl0b3JTZWxlY3RvciB7Li4ucHJvcHN9IC8+O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDxMb2tpUXVlcnlFZGl0b3Igey4uLnByb3BzfSAvPjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vKExva2lRdWVyeUVkaXRvckJ5QXBwKTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IExva2lRdWVyeUZpZWxkIH0gZnJvbSAnLi9Mb2tpUXVlcnlGaWVsZCc7XG5pbXBvcnQgeyBMb2tpUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gTG9raVF1ZXJ5RWRpdG9yRm9yQWxlcnRpbmcocHJvcHM6IExva2lRdWVyeUVkaXRvclByb3BzKSB7XG4gIGNvbnN0IHsgcXVlcnksIGRhdGEsIGRhdGFzb3VyY2UsIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0gPSBwcm9wcztcblxuICByZXR1cm4gKFxuICAgIDxMb2tpUXVlcnlGaWVsZFxuICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICBvbkJsdXI9e29uUnVuUXVlcnl9XG4gICAgICBoaXN0b3J5PXtbXX1cbiAgICAgIGRhdGE9e2RhdGF9XG4gICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIGEgTG9raSBxdWVyeVwiXG4gICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5lZGl0b3J9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IHRlc3RJZHMgPSB7XG4gIGVkaXRvcjogJ2xva2ktZWRpdG9yLWNsb3VkLWFsZXJ0aW5nJyxcbn07XG4iLCJpbXBvcnQgeyBMYW5ndWFnZU1hcCwgbGFuZ3VhZ2VzIGFzIHByaXNtTGFuZ3VhZ2VzIH0gZnJvbSAncHJpc21qcyc7XG5pbXBvcnQgUmVhY3QsIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUGx1Z2luLCBOb2RlIH0gZnJvbSAnc2xhdGUnO1xuXG5pbXBvcnQgeyBRdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyByZXBvcnRJbnRlcmFjdGlvbiB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHtcbiAgU2xhdGVQcmlzbSxcbiAgVHlwZWFoZWFkT3V0cHV0LFxuICBTdWdnZXN0aW9uc1N0YXRlLFxuICBRdWVyeUZpZWxkLFxuICBUeXBlYWhlYWRJbnB1dCxcbiAgQnJhY2VzUGx1Z2luLFxuICBET01VdGlsLFxuICBJY29uLFxufSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBMb2NhbFN0b3JhZ2VWYWx1ZVByb3ZpZGVyIH0gZnJvbSAnYXBwL2NvcmUvY29tcG9uZW50cy9Mb2NhbFN0b3JhZ2VWYWx1ZVByb3ZpZGVyJztcblxuaW1wb3J0IHsgTG9raURhdGFzb3VyY2UgfSBmcm9tICcuLi9kYXRhc291cmNlJztcbmltcG9ydCBMb2tpTGFuZ3VhZ2VQcm92aWRlciBmcm9tICcuLi9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgeyBlc2NhcGVMYWJlbFZhbHVlSW5TZWxlY3Rvciwgc2hvdWxkUmVmcmVzaExhYmVscyB9IGZyb20gJy4uL2xhbmd1YWdlX3V0aWxzJztcbmltcG9ydCB7IExva2lRdWVyeSwgTG9raU9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IExva2lMYWJlbEJyb3dzZXIgfSBmcm9tICcuL0xva2lMYWJlbEJyb3dzZXInO1xuXG5jb25zdCBMQVNUX1VTRURfTEFCRUxTX0tFWSA9ICdncmFmYW5hLmRhdGFzb3VyY2VzLmxva2kuYnJvd3Nlci5sYWJlbHMnO1xuXG5mdW5jdGlvbiBnZXRDaG9vc2VyVGV4dChoYXNTeW50YXg6IGJvb2xlYW4sIGhhc0xvZ0xhYmVsczogYm9vbGVhbikge1xuICBpZiAoIWhhc1N5bnRheCkge1xuICAgIHJldHVybiAnTG9hZGluZyBsYWJlbHMuLi4nO1xuICB9XG4gIGlmICghaGFzTG9nTGFiZWxzKSB7XG4gICAgcmV0dXJuICcoTm8gbG9ncyBmb3VuZCknO1xuICB9XG4gIHJldHVybiAnTG9nIGJyb3dzZXInO1xufVxuXG5mdW5jdGlvbiB3aWxsQXBwbHlTdWdnZXN0aW9uKHN1Z2dlc3Rpb246IHN0cmluZywgeyB0eXBlYWhlYWRDb250ZXh0LCB0eXBlYWhlYWRUZXh0IH06IFN1Z2dlc3Rpb25zU3RhdGUpOiBzdHJpbmcge1xuICAvLyBNb2RpZnkgc3VnZ2VzdGlvbiBiYXNlZCBvbiBjb250ZXh0XG4gIHN3aXRjaCAodHlwZWFoZWFkQ29udGV4dCkge1xuICAgIGNhc2UgJ2NvbnRleHQtbGFiZWxzJzoge1xuICAgICAgY29uc3QgbmV4dENoYXIgPSBET01VdGlsLmdldE5leHRDaGFyYWN0ZXIoKTtcbiAgICAgIGlmICghbmV4dENoYXIgfHwgbmV4dENoYXIgPT09ICd9JyB8fCBuZXh0Q2hhciA9PT0gJywnKSB7XG4gICAgICAgIHN1Z2dlc3Rpb24gKz0gJz0nO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnY29udGV4dC1sYWJlbC12YWx1ZXMnOiB7XG4gICAgICAvLyBBbHdheXMgYWRkIHF1b3RlcyBhbmQgcmVtb3ZlIGV4aXN0aW5nIG9uZXMgaW5zdGVhZFxuICAgICAgbGV0IHN1Z2dlc3Rpb25Nb2RpZmllZCA9ICcnO1xuXG4gICAgICBpZiAoIXR5cGVhaGVhZFRleHQubWF0Y2goL14oIT89fj9cInxcIikvKSkge1xuICAgICAgICBzdWdnZXN0aW9uTW9kaWZpZWQgPSAnXCInO1xuICAgICAgfVxuXG4gICAgICBzdWdnZXN0aW9uTW9kaWZpZWQgKz0gZXNjYXBlTGFiZWxWYWx1ZUluU2VsZWN0b3Ioc3VnZ2VzdGlvbiwgdHlwZWFoZWFkVGV4dCk7XG5cbiAgICAgIGlmIChET01VdGlsLmdldE5leHRDaGFyYWN0ZXIoKSAhPT0gJ1wiJykge1xuICAgICAgICBzdWdnZXN0aW9uTW9kaWZpZWQgKz0gJ1wiJztcbiAgICAgIH1cblxuICAgICAgc3VnZ2VzdGlvbiA9IHN1Z2dlc3Rpb25Nb2RpZmllZDtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgfVxuXG4gIHJldHVybiBzdWdnZXN0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lRdWVyeUZpZWxkUHJvcHMgZXh0ZW5kcyBRdWVyeUVkaXRvclByb3BzPExva2lEYXRhc291cmNlLCBMb2tpUXVlcnksIExva2lPcHRpb25zPiB7XG4gIEV4dHJhRmllbGRFbGVtZW50PzogUmVhY3ROb2RlO1xuICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgJ2RhdGEtdGVzdGlkJz86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIExva2lRdWVyeUZpZWxkU3RhdGUge1xuICBsYWJlbHNMb2FkZWQ6IGJvb2xlYW47XG4gIGxhYmVsQnJvd3NlclZpc2libGU6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBMb2tpUXVlcnlGaWVsZCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8TG9raVF1ZXJ5RmllbGRQcm9wcywgTG9raVF1ZXJ5RmllbGRTdGF0ZT4ge1xuICBwbHVnaW5zOiBQbHVnaW5bXTtcbiAgX2lzTW91bnRlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBMb2tpUXVlcnlGaWVsZFByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHsgbGFiZWxzTG9hZGVkOiBmYWxzZSwgbGFiZWxCcm93c2VyVmlzaWJsZTogZmFsc2UgfTtcblxuICAgIHRoaXMucGx1Z2lucyA9IFtcbiAgICAgIEJyYWNlc1BsdWdpbigpLFxuICAgICAgU2xhdGVQcmlzbShcbiAgICAgICAge1xuICAgICAgICAgIG9ubHlJbjogKG5vZGU6IE5vZGUpID0+IG5vZGUub2JqZWN0ID09PSAnYmxvY2snICYmIG5vZGUudHlwZSA9PT0gJ2NvZGVfYmxvY2snLFxuICAgICAgICAgIGdldFN5bnRheDogKG5vZGU6IE5vZGUpID0+ICdsb2dxbCcsXG4gICAgICAgIH0sXG4gICAgICAgIHsgLi4uKHByaXNtTGFuZ3VhZ2VzIGFzIExhbmd1YWdlTWFwKSwgbG9ncWw6IHRoaXMucHJvcHMuZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmdldFN5bnRheCgpIH1cbiAgICAgICksXG4gICAgXTtcbiAgfVxuXG4gIGFzeW5jIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgYXdhaXQgdGhpcy5wcm9wcy5kYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuc3RhcnQoKTtcbiAgICBpZiAodGhpcy5faXNNb3VudGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzTG9hZGVkOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogTG9raVF1ZXJ5RmllbGRQcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhbmdlLFxuICAgICAgZGF0YXNvdXJjZTogeyBsYW5ndWFnZVByb3ZpZGVyIH0sXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgcmVmcmVzaExhYmVscyA9IHNob3VsZFJlZnJlc2hMYWJlbHMocmFuZ2UsIHByZXZQcm9wcy5yYW5nZSk7XG4gICAgLy8gV2Ugd2FudCB0byByZWZyZXNoIGxhYmVscyB3aGVuIHJhbmdlIGNoYW5nZXMgKHdlIHJvdW5kIHVwIGludGVydmFscyB0byBhIG1pbnV0ZSlcbiAgICBpZiAocmVmcmVzaExhYmVscykge1xuICAgICAgbGFuZ3VhZ2VQcm92aWRlci5mZXRjaExhYmVscygpO1xuICAgIH1cbiAgfVxuXG4gIG9uQ2hhbmdlTGFiZWxCcm93c2VyID0gKHNlbGVjdG9yOiBzdHJpbmcpID0+IHtcbiAgICB0aGlzLm9uQ2hhbmdlUXVlcnkoc2VsZWN0b3IsIHRydWUpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBsYWJlbEJyb3dzZXJWaXNpYmxlOiBmYWxzZSB9KTtcbiAgfTtcblxuICBvbkNoYW5nZVF1ZXJ5ID0gKHZhbHVlOiBzdHJpbmcsIG92ZXJyaWRlPzogYm9vbGVhbikgPT4ge1xuICAgIC8vIFNlbmQgdGV4dCBjaGFuZ2UgdG8gcGFyZW50XG4gICAgY29uc3QgeyBxdWVyeSwgb25DaGFuZ2UsIG9uUnVuUXVlcnkgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICBjb25zdCBuZXh0UXVlcnkgPSB7IC4uLnF1ZXJ5LCBleHByOiB2YWx1ZSB9O1xuICAgICAgb25DaGFuZ2UobmV4dFF1ZXJ5KTtcblxuICAgICAgaWYgKG92ZXJyaWRlICYmIG9uUnVuUXVlcnkpIHtcbiAgICAgICAgb25SdW5RdWVyeSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBvbkNsaWNrQ2hvb3NlckJ1dHRvbiA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuc3RhdGUubGFiZWxCcm93c2VyVmlzaWJsZSkge1xuICAgICAgcmVwb3J0SW50ZXJhY3Rpb24oJ2dyYWZhbmFfbG9raV9sb2dfYnJvd3Nlcl9vcGVuZWQnLCB7XG4gICAgICAgIGFwcDogdGhpcy5wcm9wcy5hcHAsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwb3J0SW50ZXJhY3Rpb24oJ2dyYWZhbmFfbG9raV9sb2dfYnJvd3Nlcl9jbG9zZWQnLCB7XG4gICAgICAgIGFwcDogdGhpcy5wcm9wcy5hcHAsXG4gICAgICAgIGNsb3NlVHlwZTogJ2xvZ0Jyb3dzZXJCdXR0b24nLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiAoeyBsYWJlbEJyb3dzZXJWaXNpYmxlOiAhc3RhdGUubGFiZWxCcm93c2VyVmlzaWJsZSB9KSk7XG4gIH07XG5cbiAgb25UeXBlYWhlYWQgPSBhc3luYyAodHlwZWFoZWFkOiBUeXBlYWhlYWRJbnB1dCk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiA9PiB7XG4gICAgY29uc3QgeyBkYXRhc291cmNlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKCFkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zOiBbXSB9O1xuICAgIH1cblxuICAgIGNvbnN0IGxva2lMYW5ndWFnZVByb3ZpZGVyID0gZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyIGFzIExva2lMYW5ndWFnZVByb3ZpZGVyO1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHByZWZpeCwgdGV4dCwgdmFsdWUsIHdyYXBwZXJDbGFzc2VzLCBsYWJlbEtleSB9ID0gdHlwZWFoZWFkO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9raUxhbmd1YWdlUHJvdmlkZXIucHJvdmlkZUNvbXBsZXRpb25JdGVtcyhcbiAgICAgIHsgdGV4dCwgdmFsdWUsIHByZWZpeCwgd3JhcHBlckNsYXNzZXMsIGxhYmVsS2V5IH0sXG4gICAgICB7IGhpc3RvcnkgfVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgRXh0cmFGaWVsZEVsZW1lbnQsXG4gICAgICBxdWVyeSxcbiAgICAgIGFwcCxcbiAgICAgIGRhdGFzb3VyY2UsXG4gICAgICBwbGFjZWhvbGRlciA9ICdFbnRlciBhIExva2kgcXVlcnkgKHJ1biB3aXRoIFNoaWZ0K0VudGVyKScsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB7IGxhYmVsc0xvYWRlZCwgbGFiZWxCcm93c2VyVmlzaWJsZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBsb2tpTGFuZ3VhZ2VQcm92aWRlciA9IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlciBhcyBMb2tpTGFuZ3VhZ2VQcm92aWRlcjtcbiAgICBjb25zdCBjbGVhblRleHQgPSBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIgPyBsb2tpTGFuZ3VhZ2VQcm92aWRlci5jbGVhblRleHQgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaGFzTG9nTGFiZWxzID0gbG9raUxhbmd1YWdlUHJvdmlkZXIuZ2V0TGFiZWxLZXlzKCkubGVuZ3RoID4gMDtcbiAgICBjb25zdCBjaG9vc2VyVGV4dCA9IGdldENob29zZXJUZXh0KGxhYmVsc0xvYWRlZCwgaGFzTG9nTGFiZWxzKTtcbiAgICBjb25zdCBidXR0b25EaXNhYmxlZCA9ICEobGFiZWxzTG9hZGVkICYmIGhhc0xvZ0xhYmVscyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPExvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXI8c3RyaW5nW10+IHN0b3JhZ2VLZXk9e0xBU1RfVVNFRF9MQUJFTFNfS0VZfSBkZWZhdWx0VmFsdWU9e1tdfT5cbiAgICAgICAgeyhsYXN0VXNlZExhYmVscywgb25MYXN0VXNlZExhYmVsc1NhdmUsIG9uTGFzdFVzZWRMYWJlbHNEZWxldGUpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lIGdmLWZvcm0taW5saW5lLS14cy12aWV3LWZsZXgtY29sdW1uIGZsZXgtZ3Jvdy0xXCJcbiAgICAgICAgICAgICAgICBkYXRhLXRlc3RpZD17dGhpcy5wcm9wc1snZGF0YS10ZXN0aWQnXX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdmLWZvcm0tbGFiZWwgcXVlcnkta2V5d29yZCBwb2ludGVyXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja0Nob29zZXJCdXR0b259XG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17YnV0dG9uRGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge2Nob29zZXJUZXh0fVxuICAgICAgICAgICAgICAgICAgPEljb24gbmFtZT17bGFiZWxCcm93c2VyVmlzaWJsZSA/ICdhbmdsZS1kb3duJyA6ICdhbmdsZS1yaWdodCd9IC8+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtIGdmLWZvcm0tLWdyb3cgZmxleC1zaHJpbmstMSBtaW4td2lkdGgtMTVcIj5cbiAgICAgICAgICAgICAgICAgIDxRdWVyeUZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQbHVnaW5zPXt0aGlzLnBsdWdpbnN9XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVGV4dD17Y2xlYW5UZXh0fVxuICAgICAgICAgICAgICAgICAgICBxdWVyeT17cXVlcnkuZXhwcn1cbiAgICAgICAgICAgICAgICAgICAgb25UeXBlYWhlYWQ9e3RoaXMub25UeXBlYWhlYWR9XG4gICAgICAgICAgICAgICAgICAgIG9uV2lsbEFwcGx5U3VnZ2VzdGlvbj17d2lsbEFwcGx5U3VnZ2VzdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2VRdWVyeX1cbiAgICAgICAgICAgICAgICAgICAgb25CbHVyPXt0aGlzLnByb3BzLm9uQmx1cn1cbiAgICAgICAgICAgICAgICAgICAgb25SdW5RdWVyeT17dGhpcy5wcm9wcy5vblJ1blF1ZXJ5fVxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbE9yaWdpbj1cImxva2lcIlxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIHtsYWJlbEJyb3dzZXJWaXNpYmxlICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgICAgIDxMb2tpTGFiZWxCcm93c2VyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlUHJvdmlkZXI9e2xva2lMYW5ndWFnZVByb3ZpZGVyfVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZUxhYmVsQnJvd3Nlcn1cbiAgICAgICAgICAgICAgICAgICAgbGFzdFVzZWRMYWJlbHM9e2xhc3RVc2VkTGFiZWxzIHx8IFtdfVxuICAgICAgICAgICAgICAgICAgICBzdG9yZUxhc3RVc2VkTGFiZWxzPXtvbkxhc3RVc2VkTGFiZWxzU2F2ZX1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGFzdFVzZWRMYWJlbHM9e29uTGFzdFVzZWRMYWJlbHNEZWxldGV9XG4gICAgICAgICAgICAgICAgICAgIGFwcD17YXBwfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICB7RXh0cmFGaWVsZEVsZW1lbnR9XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgICApO1xuICAgICAgICB9fVxuICAgICAgPC9Mb2NhbFN0b3JhZ2VWYWx1ZVByb3ZpZGVyPlxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IERhdGFTb3VyY2VQbHVnaW5PcHRpb25zRWRpdG9yUHJvcHMsIERhdGFTb3VyY2VTZXR0aW5ncyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgQWxlcnRpbmdTZXR0aW5ncywgRGF0YVNvdXJjZUh0dHBTZXR0aW5ncyB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IGdldEFsbEFsZXJ0bWFuYWdlckRhdGFTb3VyY2VzIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2FsZXJ0aW5nL3VuaWZpZWQvdXRpbHMvYWxlcnRtYW5hZ2VyJztcblxuaW1wb3J0IHsgTG9raU9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IERlcml2ZWRGaWVsZHMgfSBmcm9tICcuL0Rlcml2ZWRGaWVsZHMnO1xuaW1wb3J0IHsgTWF4TGluZXNGaWVsZCB9IGZyb20gJy4vTWF4TGluZXNGaWVsZCc7XG5cbmV4cG9ydCB0eXBlIFByb3BzID0gRGF0YVNvdXJjZVBsdWdpbk9wdGlvbnNFZGl0b3JQcm9wczxMb2tpT3B0aW9ucz47XG5cbmNvbnN0IG1ha2VKc29uVXBkYXRlciA9XG4gIDxUIGV4dGVuZHMgYW55PihmaWVsZDoga2V5b2YgTG9raU9wdGlvbnMpID0+XG4gIChvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8TG9raU9wdGlvbnM+LCB2YWx1ZTogVCk6IERhdGFTb3VyY2VTZXR0aW5nczxMb2tpT3B0aW9ucz4gPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAganNvbkRhdGE6IHtcbiAgICAgICAgLi4ub3B0aW9ucy5qc29uRGF0YSxcbiAgICAgICAgW2ZpZWxkXTogdmFsdWUsXG4gICAgICB9LFxuICAgIH07XG4gIH07XG5cbmNvbnN0IHNldE1heExpbmVzID0gbWFrZUpzb25VcGRhdGVyKCdtYXhMaW5lcycpO1xuY29uc3Qgc2V0RGVyaXZlZEZpZWxkcyA9IG1ha2VKc29uVXBkYXRlcignZGVyaXZlZEZpZWxkcycpO1xuXG5leHBvcnQgY29uc3QgQ29uZmlnRWRpdG9yID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICBjb25zdCB7IG9wdGlvbnMsIG9uT3B0aW9uc0NoYW5nZSB9ID0gcHJvcHM7XG4gIGNvbnN0IGFsZXJ0bWFuYWdlcnMgPSBnZXRBbGxBbGVydG1hbmFnZXJEYXRhU291cmNlcygpO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxEYXRhU291cmNlSHR0cFNldHRpbmdzXG4gICAgICAgIGRlZmF1bHRVcmw9eydodHRwOi8vbG9jYWxob3N0OjMxMDAnfVxuICAgICAgICBkYXRhU291cmNlQ29uZmlnPXtvcHRpb25zfVxuICAgICAgICBzaG93QWNjZXNzT3B0aW9ucz17ZmFsc2V9XG4gICAgICAgIG9uQ2hhbmdlPXtvbk9wdGlvbnNDaGFuZ2V9XG4gICAgICAvPlxuXG4gICAgICA8QWxlcnRpbmdTZXR0aW5nczxMb2tpT3B0aW9ucz5cbiAgICAgICAgYWxlcnRtYW5hZ2VyRGF0YVNvdXJjZXM9e2FsZXJ0bWFuYWdlcnN9XG4gICAgICAgIG9wdGlvbnM9e29wdGlvbnN9XG4gICAgICAgIG9uT3B0aW9uc0NoYW5nZT17b25PcHRpb25zQ2hhbmdlfVxuICAgICAgLz5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWdyb3VwXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgIDxNYXhMaW5lc0ZpZWxkXG4gICAgICAgICAgICAgIHZhbHVlPXtvcHRpb25zLmpzb25EYXRhLm1heExpbmVzIHx8ICcnfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiBvbk9wdGlvbnNDaGFuZ2Uoc2V0TWF4TGluZXMob3B0aW9ucywgdmFsdWUpKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxEZXJpdmVkRmllbGRzXG4gICAgICAgIHZhbHVlPXtvcHRpb25zLmpzb25EYXRhLmRlcml2ZWRGaWVsZHN9XG4gICAgICAgIG9uQ2hhbmdlPXsodmFsdWUpID0+IG9uT3B0aW9uc0NoYW5nZShzZXREZXJpdmVkRmllbGRzKG9wdGlvbnMsIHZhbHVlKSl9XG4gICAgICAvPlxuICAgIDwvPlxuICApO1xufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEFycmF5VmVjdG9yLCBGaWVsZCwgRmllbGRUeXBlLCBMaW5rTW9kZWwgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IExlZ2FjeUZvcm1zIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBnZXRGaWVsZExpbmtzRm9yRXhwbG9yZSB9IGZyb20gJy4uLy4uLy4uLy4uL2ZlYXR1cmVzL2V4cGxvcmUvdXRpbHMvbGlua3MnO1xuaW1wb3J0IHsgRGVyaXZlZEZpZWxkQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCB7IEZvcm1GaWVsZCB9ID0gTGVnYWN5Rm9ybXM7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGRlcml2ZWRGaWVsZHM/OiBEZXJpdmVkRmllbGRDb25maWdbXTtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufTtcbmV4cG9ydCBjb25zdCBEZWJ1Z1NlY3Rpb24gPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgZGVyaXZlZEZpZWxkcywgY2xhc3NOYW1lIH0gPSBwcm9wcztcbiAgY29uc3QgW2RlYnVnVGV4dCwgc2V0RGVidWdUZXh0XSA9IHVzZVN0YXRlKCcnKTtcblxuICBsZXQgZGVidWdGaWVsZHM6IERlYnVnRmllbGRbXSA9IFtdO1xuICBpZiAoZGVidWdUZXh0ICYmIGRlcml2ZWRGaWVsZHMpIHtcbiAgICBkZWJ1Z0ZpZWxkcyA9IG1ha2VEZWJ1Z0ZpZWxkcyhkZXJpdmVkRmllbGRzLCBkZWJ1Z1RleHQpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgIDxGb3JtRmllbGRcbiAgICAgICAgbGFiZWxXaWR0aD17MTJ9XG4gICAgICAgIGxhYmVsPXsnRGVidWcgbG9nIG1lc3NhZ2UnfVxuICAgICAgICBpbnB1dEVsPXtcbiAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPXsnUGFzdGUgYW4gZXhhbXBsZSBsb2cgbGluZSBoZXJlIHRvIHRlc3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb2YgeW91ciBkZXJpdmVkIGZpZWxkcyd9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICAgICAgICAnZ2YtZm9ybS1pbnB1dCBnZi1mb3JtLXRleHRhcmVhJyxcbiAgICAgICAgICAgICAgY3NzYFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICBgXG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgdmFsdWU9e2RlYnVnVGV4dH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+IHNldERlYnVnVGV4dChldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAvPlxuICAgICAgICB9XG4gICAgICAvPlxuICAgICAgeyEhZGVidWdGaWVsZHMubGVuZ3RoICYmIDxEZWJ1Z0ZpZWxkcyBmaWVsZHM9e2RlYnVnRmllbGRzfSAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbnR5cGUgRGVidWdGaWVsZEl0ZW1Qcm9wcyA9IHtcbiAgZmllbGRzOiBEZWJ1Z0ZpZWxkW107XG59O1xuY29uc3QgRGVidWdGaWVsZHMgPSAoeyBmaWVsZHMgfTogRGVidWdGaWVsZEl0ZW1Qcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDx0YWJsZSBjbGFzc05hbWU9eydmaWx0ZXItdGFibGUnfT5cbiAgICAgIDx0aGVhZD5cbiAgICAgICAgPHRyPlxuICAgICAgICAgIDx0aD5OYW1lPC90aD5cbiAgICAgICAgICA8dGg+VmFsdWU8L3RoPlxuICAgICAgICAgIDx0aD5Vcmw8L3RoPlxuICAgICAgICA8L3RyPlxuICAgICAgPC90aGVhZD5cbiAgICAgIDx0Ym9keT5cbiAgICAgICAge2ZpZWxkcy5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlOiBhbnkgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgICBpZiAoZmllbGQuZXJyb3IpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQuZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLmhyZWYpIHtcbiAgICAgICAgICAgIHZhbHVlID0gPGEgaHJlZj17ZmllbGQuaHJlZn0+e3ZhbHVlfTwvYT47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8dHIga2V5PXtgJHtmaWVsZC5uYW1lfT0ke2ZpZWxkLnZhbHVlfWB9PlxuICAgICAgICAgICAgICA8dGQ+e2ZpZWxkLm5hbWV9PC90ZD5cbiAgICAgICAgICAgICAgPHRkPnt2YWx1ZX08L3RkPlxuICAgICAgICAgICAgICA8dGQ+e2ZpZWxkLmhyZWYgPyA8YSBocmVmPXtmaWVsZC5ocmVmfT57ZmllbGQuaHJlZn08L2E+IDogJyd9PC90ZD5cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG4gICAgICA8L3Rib2R5PlxuICAgIDwvdGFibGU+XG4gICk7XG59O1xuXG50eXBlIERlYnVnRmllbGQgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgZXJyb3I/OiBhbnk7XG4gIHZhbHVlPzogc3RyaW5nO1xuICBocmVmPzogc3RyaW5nO1xufTtcblxuZnVuY3Rpb24gbWFrZURlYnVnRmllbGRzKGRlcml2ZWRGaWVsZHM6IERlcml2ZWRGaWVsZENvbmZpZ1tdLCBkZWJ1Z1RleHQ6IHN0cmluZyk6IERlYnVnRmllbGRbXSB7XG4gIHJldHVybiBkZXJpdmVkRmllbGRzXG4gICAgLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLm5hbWUgJiYgZmllbGQubWF0Y2hlclJlZ2V4KVxuICAgIC5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0ZXN0TWF0Y2ggPSBkZWJ1Z1RleHQubWF0Y2goZmllbGQubWF0Y2hlclJlZ2V4KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0ZXN0TWF0Y2ggJiYgdGVzdE1hdGNoWzFdO1xuICAgICAgICBsZXQgbGluazogTGlua01vZGVsPEZpZWxkPiB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGlmIChmaWVsZC51cmwgJiYgdmFsdWUpIHtcbiAgICAgICAgICBsaW5rID0gZ2V0RmllbGRMaW5rc0ZvckV4cGxvcmUoe1xuICAgICAgICAgICAgZmllbGQ6IHtcbiAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcsXG4gICAgICAgICAgICAgIHZhbHVlczogbmV3IEFycmF5VmVjdG9yKFt2YWx1ZV0pLFxuICAgICAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICAgICBsaW5rczogW3sgdGl0bGU6ICcnLCB1cmw6IGZpZWxkLnVybCB9XSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByb3dJbmRleDogMCxcbiAgICAgICAgICAgIHJhbmdlOiB7fSBhcyBhbnksXG4gICAgICAgICAgfSlbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlIHx8ICc8bm8gbWF0Y2g+JyxcbiAgICAgICAgICBocmVmOiBsaW5rICYmIGxpbmsuaHJlZixcbiAgICAgICAgfSBhcyBEZWJ1Z0ZpZWxkO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICB9IGFzIERlYnVnRmllbGQ7XG4gICAgICB9XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VQcmV2aW91cyB9IGZyb20gJ3JlYWN0LXVzZSc7XG5cbmltcG9ydCB7IFZhcmlhYmxlU3VnZ2VzdGlvbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRGF0YVNvdXJjZVBpY2tlciB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgQnV0dG9uLCBEYXRhTGlua0lucHV0LCBzdHlsZXNGYWN0b3J5LCBMZWdhY3lGb3JtcyB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgRGVyaXZlZEZpZWxkQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCB7IFN3aXRjaCwgRm9ybUZpZWxkIH0gPSBMZWdhY3lGb3JtcztcblxuY29uc3QgZ2V0U3R5bGVzID0gc3R5bGVzRmFjdG9yeSgoKSA9PiAoe1xuICByb3c6IGNzc2BcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBiYXNlbGluZTtcbiAgYCxcbiAgbmFtZUZpZWxkOiBjc3NgXG4gICAgZmxleDogMjtcbiAgYCxcbiAgcmVnZXhGaWVsZDogY3NzYFxuICAgIGZsZXg6IDM7XG4gIGAsXG4gIHVybEZpZWxkOiBjc3NgXG4gICAgZmxleDogMTtcbiAgYCxcbiAgdXJsRGlzcGxheUxhYmVsRmllbGQ6IGNzc2BcbiAgICBmbGV4OiAxO1xuICBgLFxufSkpO1xuXG50eXBlIFByb3BzID0ge1xuICB2YWx1ZTogRGVyaXZlZEZpZWxkQ29uZmlnO1xuICBvbkNoYW5nZTogKHZhbHVlOiBEZXJpdmVkRmllbGRDb25maWcpID0+IHZvaWQ7XG4gIG9uRGVsZXRlOiAoKSA9PiB2b2lkO1xuICBzdWdnZXN0aW9uczogVmFyaWFibGVTdWdnZXN0aW9uW107XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn07XG5leHBvcnQgY29uc3QgRGVyaXZlZEZpZWxkID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICBjb25zdCB7IHZhbHVlLCBvbkNoYW5nZSwgb25EZWxldGUsIHN1Z2dlc3Rpb25zLCBjbGFzc05hbWUgfSA9IHByb3BzO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZXMoKTtcbiAgY29uc3QgW3Nob3dJbnRlcm5hbExpbmssIHNldFNob3dJbnRlcm5hbExpbmtdID0gdXNlU3RhdGUoISF2YWx1ZS5kYXRhc291cmNlVWlkKTtcbiAgY29uc3QgcHJldmlvdXNVaWQgPSB1c2VQcmV2aW91cyh2YWx1ZS5kYXRhc291cmNlVWlkKTtcblxuICAvLyBGb3JjZSBpbnRlcm5hbCBsaW5rIHZpc2liaWxpdHkgY2hhbmdlIGlmIHVpZCBjaGFuZ2VkIG91dHNpZGUgb2YgdGhpcyBjb21wb25lbnQuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwcmV2aW91c1VpZCAmJiB2YWx1ZS5kYXRhc291cmNlVWlkICYmICFzaG93SW50ZXJuYWxMaW5rKSB7XG4gICAgICBzZXRTaG93SW50ZXJuYWxMaW5rKHRydWUpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNVaWQgJiYgIXZhbHVlLmRhdGFzb3VyY2VVaWQgJiYgc2hvd0ludGVybmFsTGluaykge1xuICAgICAgc2V0U2hvd0ludGVybmFsTGluayhmYWxzZSk7XG4gICAgfVxuICB9LCBbcHJldmlvdXNVaWQsIHZhbHVlLmRhdGFzb3VyY2VVaWQsIHNob3dJbnRlcm5hbExpbmtdKTtcblxuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoZmllbGQ6IGtleW9mIHR5cGVvZiB2YWx1ZSkgPT4gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIG9uQ2hhbmdlKHtcbiAgICAgIC4uLnZhbHVlLFxuICAgICAgW2ZpZWxkXTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5yb3d9PlxuICAgICAgICA8Rm9ybUZpZWxkXG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubmFtZUZpZWxkfVxuICAgICAgICAgIGxhYmVsV2lkdGg9ezV9XG4gICAgICAgICAgLy8gQSBiaXQgb2YgYSBoYWNrIHRvIHByZXZlbnQgdXNpbmcgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHdpZHRoIGZyb20gRm9ybUZpZWxkXG4gICAgICAgICAgaW5wdXRXaWR0aD17bnVsbH1cbiAgICAgICAgICBsYWJlbD1cIk5hbWVcIlxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICB2YWx1ZT17dmFsdWUubmFtZX1cbiAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlKCduYW1lJyl9XG4gICAgICAgIC8+XG4gICAgICAgIDxGb3JtRmllbGRcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5yZWdleEZpZWxkfVxuICAgICAgICAgIGlucHV0V2lkdGg9e251bGx9XG4gICAgICAgICAgbGFiZWw9XCJSZWdleFwiXG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIHZhbHVlPXt2YWx1ZS5tYXRjaGVyUmVnZXh9XG4gICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZSgnbWF0Y2hlclJlZ2V4Jyl9XG4gICAgICAgICAgdG9vbHRpcD17XG4gICAgICAgICAgICAnVXNlIHRvIHBhcnNlIGFuZCBjYXB0dXJlIHNvbWUgcGFydCBvZiB0aGUgbG9nIG1lc3NhZ2UuIFlvdSBjYW4gdXNlIHRoZSBjYXB0dXJlZCBncm91cHMgaW4gdGhlIHRlbXBsYXRlLidcbiAgICAgICAgICB9XG4gICAgICAgIC8+XG4gICAgICAgIDxCdXR0b25cbiAgICAgICAgICB2YXJpYW50PVwiZGVzdHJ1Y3RpdmVcIlxuICAgICAgICAgIHRpdGxlPVwiUmVtb3ZlIGZpZWxkXCJcbiAgICAgICAgICBpY29uPVwidGltZXNcIlxuICAgICAgICAgIG9uQ2xpY2s9eyhldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uRGVsZXRlKCk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBjbGFzc05hbWU9e2Nzc2BcbiAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiA4cHg7XG4gICAgICAgICAgYH1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnJvd30+XG4gICAgICAgIDxGb3JtRmllbGRcbiAgICAgICAgICBsYWJlbD17c2hvd0ludGVybmFsTGluayA/ICdRdWVyeScgOiAnVVJMJ31cbiAgICAgICAgICBpbnB1dEVsPXtcbiAgICAgICAgICAgIDxEYXRhTGlua0lucHV0XG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtzaG93SW50ZXJuYWxMaW5rID8gJyR7X192YWx1ZS5yYXd9JyA6ICdodHRwOi8vZXhhbXBsZS5jb20vJHtfX3ZhbHVlLnJhd30nfVxuICAgICAgICAgICAgICB2YWx1ZT17dmFsdWUudXJsIHx8ICcnfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KG5ld1ZhbHVlKSA9PlxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgdXJsOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN1Z2dlc3Rpb25zPXtzdWdnZXN0aW9uc31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnVybEZpZWxkfVxuICAgICAgICAvPlxuICAgICAgICA8Rm9ybUZpZWxkXG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudXJsRGlzcGxheUxhYmVsRmllbGR9XG4gICAgICAgICAgaW5wdXRXaWR0aD17bnVsbH1cbiAgICAgICAgICBsYWJlbD1cIlVSTCBMYWJlbFwiXG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIHZhbHVlPXt2YWx1ZS51cmxEaXNwbGF5TGFiZWx9XG4gICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZSgndXJsRGlzcGxheUxhYmVsJyl9XG4gICAgICAgICAgdG9vbHRpcD17J1VzZSB0byBvdmVycmlkZSB0aGUgYnV0dG9uIGxhYmVsIHdoZW4gdGhpcyBkZXJpdmVkIGZpZWxkIGlzIGZvdW5kIGluIGEgbG9nLid9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5yb3d9PlxuICAgICAgICA8U3dpdGNoXG4gICAgICAgICAgbGFiZWw9XCJJbnRlcm5hbCBsaW5rXCJcbiAgICAgICAgICBjaGVja2VkPXtzaG93SW50ZXJuYWxMaW5rfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvd0ludGVybmFsTGluaykge1xuICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YXNvdXJjZVVpZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFNob3dJbnRlcm5hbExpbmsoIXNob3dJbnRlcm5hbExpbmspO1xuICAgICAgICAgIH19XG4gICAgICAgIC8+XG5cbiAgICAgICAge3Nob3dJbnRlcm5hbExpbmsgJiYgKFxuICAgICAgICAgIDxEYXRhU291cmNlUGlja2VyXG4gICAgICAgICAgICB0cmFjaW5nPXt0cnVlfVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhkcykgPT5cbiAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGFzb3VyY2VVaWQ6IGRzLnVpZCxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQ9e3ZhbHVlLmRhdGFzb3VyY2VVaWR9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIsIFZhcmlhYmxlT3JpZ2luLCBEYXRhTGlua0J1aWx0SW5WYXJzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBCdXR0b24sIHVzZVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgRGVyaXZlZEZpZWxkQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBEZWJ1Z1NlY3Rpb24gfSBmcm9tICcuL0RlYnVnU2VjdGlvbic7XG5pbXBvcnQgeyBEZXJpdmVkRmllbGQgfSBmcm9tICcuL0Rlcml2ZWRGaWVsZCc7XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgaW5mb1RleHQ6IGNzc2BcbiAgICBwYWRkaW5nLWJvdHRvbTogJHt0aGVtZS5zcGFjaW5nKDIpfTtcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuICBgLFxuICBkZXJpdmVkRmllbGQ6IGNzc2BcbiAgICBtYXJnaW4tYm90dG9tOiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICBgLFxufSk7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIHZhbHVlPzogRGVyaXZlZEZpZWxkQ29uZmlnW107XG4gIG9uQ2hhbmdlOiAodmFsdWU6IERlcml2ZWRGaWVsZENvbmZpZ1tdKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IGNvbnN0IERlcml2ZWRGaWVsZHMgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgdmFsdWUsIG9uQ2hhbmdlIH0gPSBwcm9wcztcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZTIoKTtcbiAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVzKHRoZW1lKTtcblxuICBjb25zdCBbc2hvd0RlYnVnLCBzZXRTaG93RGVidWddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxoMyBjbGFzc05hbWU9XCJwYWdlLWhlYWRpbmdcIj5EZXJpdmVkIGZpZWxkczwvaDM+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5mb1RleHR9PlxuICAgICAgICBEZXJpdmVkIGZpZWxkcyBjYW4gYmUgdXNlZCB0byBleHRyYWN0IG5ldyBmaWVsZHMgZnJvbSBhIGxvZyBtZXNzYWdlIGFuZCBjcmVhdGUgYSBsaW5rIGZyb20gaXRzIHZhbHVlLlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1ncm91cFwiPlxuICAgICAgICB7dmFsdWUgJiZcbiAgICAgICAgICB2YWx1ZS5tYXAoKGZpZWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPERlcml2ZWRGaWVsZFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmRlcml2ZWRGaWVsZH1cbiAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICAgIHZhbHVlPXtmaWVsZH1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KG5ld0ZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdEZXJpdmVkRmllbGRzID0gWy4uLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgIG5ld0Rlcml2ZWRGaWVsZHMuc3BsaWNlKGluZGV4LCAxLCBuZXdGaWVsZCk7XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZShuZXdEZXJpdmVkRmllbGRzKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uRGVsZXRlPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdEZXJpdmVkRmllbGRzID0gWy4uLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgIG5ld0Rlcml2ZWRGaWVsZHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKG5ld0Rlcml2ZWRGaWVsZHMpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvbnM9e1tcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IERhdGFMaW5rQnVpbHRJblZhcnMudmFsdWVSYXcsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnUmF3IHZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJ0V4YWN0IHN0cmluZyBjYXB0dXJlZCBieSB0aGUgcmVndWxhciBleHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBWYXJpYWJsZU9yaWdpbi5WYWx1ZSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSl9XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICBjbGFzc05hbWU9e2Nzc2BcbiAgICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xuICAgICAgICAgICAgYH1cbiAgICAgICAgICAgIGljb249XCJwbHVzXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eyhldmVudCkgPT4ge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBjb25zdCBuZXdEZXJpdmVkRmllbGRzID0gWy4uLih2YWx1ZSB8fCBbXSksIHsgbmFtZTogJycsIG1hdGNoZXJSZWdleDogJycgfV07XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKG5ld0Rlcml2ZWRGaWVsZHMpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICBBZGRcbiAgICAgICAgICA8L0J1dHRvbj5cblxuICAgICAgICAgIHt2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgIDxCdXR0b24gdmFyaWFudD1cInNlY29uZGFyeVwiIHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXsoKSA9PiBzZXRTaG93RGVidWcoIXNob3dEZWJ1Zyl9PlxuICAgICAgICAgICAgICB7c2hvd0RlYnVnID8gJ0hpZGUgZXhhbXBsZSBsb2cgbWVzc2FnZScgOiAnU2hvdyBleGFtcGxlIGxvZyBtZXNzYWdlJ31cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHtzaG93RGVidWcgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0tZ3JvdXBcIj5cbiAgICAgICAgICA8RGVidWdTZWN0aW9uXG4gICAgICAgICAgICBjbGFzc05hbWU9e2Nzc2BcbiAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDtcbiAgICAgICAgICAgIGB9XG4gICAgICAgICAgICBkZXJpdmVkRmllbGRzPXt2YWx1ZX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC8+XG4gICk7XG59O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgTGVnYWN5Rm9ybXMgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5jb25zdCB7IEZvcm1GaWVsZCB9ID0gTGVnYWN5Rm9ybXM7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIHZhbHVlOiBzdHJpbmc7XG4gIG9uQ2hhbmdlOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBjb25zdCBNYXhMaW5lc0ZpZWxkID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICBjb25zdCB7IHZhbHVlLCBvbkNoYW5nZSB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPEZvcm1GaWVsZFxuICAgICAgbGFiZWw9XCJNYXhpbXVtIGxpbmVzXCJcbiAgICAgIGxhYmVsV2lkdGg9ezExfVxuICAgICAgaW5wdXRXaWR0aD17MjB9XG4gICAgICBpbnB1dEVsPXtcbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbnB1dCB3aWR0aC04IGdmLWZvcm0taW5wdXQtLWhhcy1oZWxwLWljb25cIlxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiBvbkNoYW5nZShldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICBzcGVsbENoZWNrPXtmYWxzZX1cbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIjEwMDBcIlxuICAgICAgICAvPlxuICAgICAgfVxuICAgICAgdG9vbHRpcD17XG4gICAgICAgIDw+XG4gICAgICAgICAgTG9raSBxdWVyaWVzIG11c3QgY29udGFpbiBhIGxpbWl0IG9mIHRoZSBtYXhpbXVtIG51bWJlciBvZiBsaW5lcyByZXR1cm5lZCAoZGVmYXVsdDogMTAwMCkuIEluY3JlYXNlIHRoaXMgbGltaXRcbiAgICAgICAgICB0byBoYXZlIGEgYmlnZ2VyIHJlc3VsdCBzZXQgZm9yIGFkLWhvYyBhbmFseXNpcy4gRGVjcmVhc2UgdGhpcyBsaW1pdCBpZiB5b3VyIGJyb3dzZXIgYmVjb21lcyBzbHVnZ2lzaCB3aGVuXG4gICAgICAgICAgZGlzcGxheWluZyB0aGUgbG9nIHJlc3VsdHMuXG4gICAgICAgIDwvPlxuICAgICAgfVxuICAgIC8+XG4gICk7XG59O1xuIiwiLy8gTGlicmFyaWVzXG5pbXBvcnQgeyBjbG9uZURlZXAsIG1hcCBhcyBsb2Rhc2hNYXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFByaXNtIGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0IHsgbGFzdFZhbHVlRnJvbSwgbWVyZ2UsIE9ic2VydmFibGUsIG9mLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBtYXAsIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLy8gVHlwZXNcbmltcG9ydCB7XG4gIEFubm90YXRpb25FdmVudCxcbiAgQW5ub3RhdGlvblF1ZXJ5UmVxdWVzdCxcbiAgQ29yZUFwcCxcbiAgRGF0YUZyYW1lLFxuICBEYXRhRnJhbWVWaWV3LFxuICBEYXRhUXVlcnlFcnJvcixcbiAgRGF0YVF1ZXJ5UmVxdWVzdCxcbiAgRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIERhdGFTb3VyY2VJbnN0YW5jZVNldHRpbmdzLFxuICBEYXRhU291cmNlV2l0aExvZ3NDb250ZXh0U3VwcG9ydCxcbiAgRGF0YVNvdXJjZVdpdGhMb2dzVm9sdW1lU3VwcG9ydCxcbiAgRGF0YVNvdXJjZVdpdGhRdWVyeUV4cG9ydFN1cHBvcnQsXG4gIERhdGFTb3VyY2VXaXRoUXVlcnlJbXBvcnRTdXBwb3J0LFxuICBkYXRlTWF0aCxcbiAgRGF0ZVRpbWUsXG4gIEZpZWxkQ2FjaGUsXG4gIEFic3RyYWN0UXVlcnksXG4gIEZpZWxkVHlwZSxcbiAgZ2V0TG9nTGV2ZWxGcm9tS2V5LFxuICBMYWJlbHMsXG4gIExvYWRpbmdTdGF0ZSxcbiAgTG9nTGV2ZWwsXG4gIExvZ1Jvd01vZGVsLFxuICBTY29wZWRWYXJzLFxuICBUaW1lUmFuZ2UsXG4gIHJhbmdlVXRpbCxcbiAgdG9VdGMsXG59IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRmV0Y2hFcnJvciwgY29uZmlnLCBEYXRhU291cmNlV2l0aEJhY2tlbmQgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCB7IFJvd0NvbnRleHRPcHRpb25zIH0gZnJvbSAnQGdyYWZhbmEvdWkvc3JjL2NvbXBvbmVudHMvTG9ncy9Mb2dSb3dDb250ZXh0UHJvdmlkZXInO1xuaW1wb3J0IHsgcXVlcnlMb2dzVm9sdW1lIH0gZnJvbSAnYXBwL2NvcmUvbG9nc19tb2RlbCc7XG5pbXBvcnQgeyBjb252ZXJ0VG9XZWJTb2NrZXRVcmwgfSBmcm9tICdhcHAvY29yZS91dGlscy9leHBsb3JlJztcbmltcG9ydCB7IGdldFRpbWVTcnYsIFRpbWVTcnYgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGFzaGJvYXJkL3NlcnZpY2VzL1RpbWVTcnYnO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGVTcnYsIFRlbXBsYXRlU3J2IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL3RlbXBsYXRpbmcvdGVtcGxhdGVfc3J2JztcblxuaW1wb3J0IHsgc2VyaWFsaXplUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vY29yZS91dGlscy9mZXRjaCc7XG5pbXBvcnQgeyByZW5kZXJMZWdlbmRGb3JtYXQgfSBmcm9tICcuLi9wcm9tZXRoZXVzL2xlZ2VuZCc7XG5cbmltcG9ydCB7IGFkZExhYmVsVG9RdWVyeSB9IGZyb20gJy4vYWRkX2xhYmVsX3RvX3F1ZXJ5JztcbmltcG9ydCB7IHRyYW5zZm9ybUJhY2tlbmRSZXN1bHQgfSBmcm9tICcuL2JhY2tlbmRSZXN1bHRUcmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBMb2tpQW5ub3RhdGlvbnNRdWVyeUVkaXRvciB9IGZyb20gJy4vY29tcG9uZW50cy9Bbm5vdGF0aW9uc1F1ZXJ5RWRpdG9yJztcbmltcG9ydCBMYW5ndWFnZVByb3ZpZGVyIGZyb20gJy4vbGFuZ3VhZ2VfcHJvdmlkZXInO1xuaW1wb3J0IHsgZXNjYXBlTGFiZWxWYWx1ZUluU2VsZWN0b3IgfSBmcm9tICcuL2xhbmd1YWdlX3V0aWxzJztcbmltcG9ydCB7IExpdmVTdHJlYW1zLCBMb2tpTGl2ZVRhcmdldCB9IGZyb20gJy4vbGl2ZV9zdHJlYW1zJztcbmltcG9ydCB7IGdldE5vcm1hbGl6ZWRMb2tpUXVlcnkgfSBmcm9tICcuL3F1ZXJ5X3V0aWxzJztcbmltcG9ydCB7IHNvcnREYXRhRnJhbWVCeVRpbWUgfSBmcm9tICcuL3NvcnREYXRhRnJhbWUnO1xuaW1wb3J0IHsgZG9Mb2tpQ2hhbm5lbFN0cmVhbSB9IGZyb20gJy4vc3RyZWFtaW5nJztcbmltcG9ydCBzeW50YXggZnJvbSAnLi9zeW50YXgnO1xuaW1wb3J0IHsgTG9raU9wdGlvbnMsIExva2lRdWVyeSwgTG9raVF1ZXJ5RGlyZWN0aW9uLCBMb2tpUXVlcnlUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIFJhbmdlUXVlcnlPcHRpb25zID0gRGF0YVF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+IHwgQW5ub3RhdGlvblF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX0xJTkVTID0gMTAwMDtcbmV4cG9ydCBjb25zdCBMT0tJX0VORFBPSU5UID0gJy9sb2tpL2FwaS92MSc7XG5jb25zdCBOU19JTl9NUyA9IDEwMDAwMDA7XG5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0KHF1ZXJ5OiBMb2tpUXVlcnksIHJhbmdlOiBUaW1lUmFuZ2UsIGFwcDogQ29yZUFwcCwgcmVxdWVzdElkOiBzdHJpbmcpOiBEYXRhUXVlcnlSZXF1ZXN0PExva2lRdWVyeT4ge1xuICBjb25zdCBpbnRlcnZhbEluZm8gPSByYW5nZVV0aWwuY2FsY3VsYXRlSW50ZXJ2YWwocmFuZ2UsIDEpO1xuICByZXR1cm4ge1xuICAgIHRhcmdldHM6IFtxdWVyeV0sXG4gICAgcmVxdWVzdElkLFxuICAgIGludGVydmFsOiBpbnRlcnZhbEluZm8uaW50ZXJ2YWwsXG4gICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxJbmZvLmludGVydmFsTXMsXG4gICAgcmFuZ2U6IHJhbmdlLFxuICAgIHNjb3BlZFZhcnM6IHt9LFxuICAgIHRpbWV6b25lOiAnVVRDJyxcbiAgICBhcHAsXG4gICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICB9O1xufVxuXG5leHBvcnQgY2xhc3MgTG9raURhdGFzb3VyY2VcbiAgZXh0ZW5kcyBEYXRhU291cmNlV2l0aEJhY2tlbmQ8TG9raVF1ZXJ5LCBMb2tpT3B0aW9ucz5cbiAgaW1wbGVtZW50c1xuICAgIERhdGFTb3VyY2VXaXRoTG9nc0NvbnRleHRTdXBwb3J0LFxuICAgIERhdGFTb3VyY2VXaXRoTG9nc1ZvbHVtZVN1cHBvcnQ8TG9raVF1ZXJ5PixcbiAgICBEYXRhU291cmNlV2l0aFF1ZXJ5SW1wb3J0U3VwcG9ydDxMb2tpUXVlcnk+LFxuICAgIERhdGFTb3VyY2VXaXRoUXVlcnlFeHBvcnRTdXBwb3J0PExva2lRdWVyeT5cbntcbiAgcHJpdmF0ZSBzdHJlYW1zID0gbmV3IExpdmVTdHJlYW1zKCk7XG4gIGxhbmd1YWdlUHJvdmlkZXI6IExhbmd1YWdlUHJvdmlkZXI7XG4gIG1heExpbmVzOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpbnN0YW5jZVNldHRpbmdzOiBEYXRhU291cmNlSW5zdGFuY2VTZXR0aW5nczxMb2tpT3B0aW9ucz4sXG4gICAgcHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZVNydjogVGVtcGxhdGVTcnYgPSBnZXRUZW1wbGF0ZVNydigpLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGltZVNydjogVGltZVNydiA9IGdldFRpbWVTcnYoKVxuICApIHtcbiAgICBzdXBlcihpbnN0YW5jZVNldHRpbmdzKTtcblxuICAgIHRoaXMubGFuZ3VhZ2VQcm92aWRlciA9IG5ldyBMYW5ndWFnZVByb3ZpZGVyKHRoaXMpO1xuICAgIGNvbnN0IHNldHRpbmdzRGF0YSA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEgfHwge307XG4gICAgdGhpcy5tYXhMaW5lcyA9IHBhcnNlSW50KHNldHRpbmdzRGF0YS5tYXhMaW5lcyA/PyAnMCcsIDEwKSB8fCBERUZBVUxUX01BWF9MSU5FUztcbiAgICB0aGlzLmFubm90YXRpb25zID0ge1xuICAgICAgUXVlcnlFZGl0b3I6IExva2lBbm5vdGF0aW9uc1F1ZXJ5RWRpdG9yLFxuICAgIH07XG4gIH1cblxuICBnZXRMb2dzVm9sdW1lRGF0YVByb3ZpZGVyKHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8TG9raVF1ZXJ5Pik6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpc1F1ZXJ5U3VpdGFibGUgPSAocXVlcnk6IExva2lRdWVyeSkgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGdldE5vcm1hbGl6ZWRMb2tpUXVlcnkocXVlcnkpO1xuICAgICAgY29uc3QgeyBleHByIH0gPSBub3JtYWxpemVkO1xuICAgICAgLy8gaXQgaGFzIHRvIGJlIGEgbG9ncy1wcm9kdWNpbmcgcmFuZ2UtcXVlcnlcbiAgICAgIHJldHVybiBleHByICYmICFpc01ldHJpY3NRdWVyeShleHByKSAmJiBub3JtYWxpemVkLnF1ZXJ5VHlwZSA9PT0gTG9raVF1ZXJ5VHlwZS5SYW5nZTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNMb2dzVm9sdW1lQXZhaWxhYmxlID0gcmVxdWVzdC50YXJnZXRzLnNvbWUoaXNRdWVyeVN1aXRhYmxlKTtcblxuICAgIGlmICghaXNMb2dzVm9sdW1lQXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGxvZ3NWb2x1bWVSZXF1ZXN0ID0gY2xvbmVEZWVwKHJlcXVlc3QpO1xuICAgIGxvZ3NWb2x1bWVSZXF1ZXN0LnRhcmdldHMgPSBsb2dzVm9sdW1lUmVxdWVzdC50YXJnZXRzLmZpbHRlcihpc1F1ZXJ5U3VpdGFibGUpLm1hcCgodGFyZ2V0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgIGluc3RhbnQ6IGZhbHNlLFxuICAgICAgICB2b2x1bWVRdWVyeTogdHJ1ZSxcbiAgICAgICAgZXhwcjogYHN1bSBieSAobGV2ZWwpIChjb3VudF9vdmVyX3RpbWUoJHt0YXJnZXQuZXhwcn1bJF9faW50ZXJ2YWxdKSlgLFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBxdWVyeUxvZ3NWb2x1bWUodGhpcywgbG9nc1ZvbHVtZVJlcXVlc3QsIHtcbiAgICAgIGV4dHJhY3RMZXZlbCxcbiAgICAgIHJhbmdlOiByZXF1ZXN0LnJhbmdlLFxuICAgICAgdGFyZ2V0czogcmVxdWVzdC50YXJnZXRzLFxuICAgIH0pO1xuICB9XG5cbiAgcXVlcnkocmVxdWVzdDogRGF0YVF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+KTogT2JzZXJ2YWJsZTxEYXRhUXVlcnlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHF1ZXJpZXMgPSByZXF1ZXN0LnRhcmdldHNcbiAgICAgIC5tYXAoZ2V0Tm9ybWFsaXplZExva2lRdWVyeSkgLy8gXCJmaXhcIiB0aGUgYC5xdWVyeVR5cGVgIHByb3BcbiAgICAgIC5tYXAoKHEpID0+ICh7IC4uLnEsIG1heExpbmVzOiBxLm1heExpbmVzIHx8IHRoaXMubWF4TGluZXMgfSkpOyAvLyBzZXQgbWF4TGluZXMgaWYgbm90IHNldFxuXG4gICAgY29uc3QgZml4ZWRSZXF1ZXN0ID0ge1xuICAgICAgLi4ucmVxdWVzdCxcbiAgICAgIHRhcmdldHM6IHF1ZXJpZXMsXG4gICAgfTtcblxuICAgIGNvbnN0IHN0cmVhbVF1ZXJpZXMgPSBmaXhlZFJlcXVlc3QudGFyZ2V0cy5maWx0ZXIoKHEpID0+IHEucXVlcnlUeXBlID09PSBMb2tpUXVlcnlUeXBlLlN0cmVhbSk7XG4gICAgaWYgKGNvbmZpZy5mZWF0dXJlVG9nZ2xlcy5sb2tpTGl2ZSAmJiBzdHJlYW1RdWVyaWVzLmxlbmd0aCA+IDAgJiYgZml4ZWRSZXF1ZXN0LnJhbmdlUmF3Py50byA9PT0gJ25vdycpIHtcbiAgICAgIC8vIHRoaXMgaXMgc3RpbGwgYW4gaW4tZGV2ZWxvcG1lbnQgZmVhdHVyZSxcbiAgICAgIC8vIHdlIGRvIG5vdCBzdXBwb3J0IG1peGluZyBzdHJlYW0tcXVlcmllcyB3aXRoIG5vcm1hbC1xdWVyaWVzIGZvciBub3cuXG4gICAgICBjb25zdCBzdHJlYW1SZXF1ZXN0ID0ge1xuICAgICAgICAuLi5maXhlZFJlcXVlc3QsXG4gICAgICAgIHRhcmdldHM6IHN0cmVhbVF1ZXJpZXMsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG1lcmdlKC4uLnN0cmVhbVF1ZXJpZXMubWFwKChxKSA9PiBkb0xva2lDaGFubmVsU3RyZWFtKHEsIHRoaXMsIHN0cmVhbVJlcXVlc3QpKSk7XG4gICAgfVxuXG4gICAgaWYgKGZpeGVkUmVxdWVzdC5saXZlU3RyZWFtaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydW5MaXZlUXVlcnlUaHJvdWdoQmFja2VuZChmaXhlZFJlcXVlc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXJcbiAgICAgICAgLnF1ZXJ5KGZpeGVkUmVxdWVzdClcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgbWFwKChyZXNwb25zZSkgPT5cbiAgICAgICAgICAgIHRyYW5zZm9ybUJhY2tlbmRSZXN1bHQocmVzcG9uc2UsIGZpeGVkUmVxdWVzdC50YXJnZXRzLCB0aGlzLmluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEuZGVyaXZlZEZpZWxkcyA/PyBbXSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcnVuTGl2ZVF1ZXJ5VGhyb3VnaEJhY2tlbmQocmVxdWVzdDogRGF0YVF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+KTogT2JzZXJ2YWJsZTxEYXRhUXVlcnlSZXNwb25zZT4ge1xuICAgIC8vIHRoaXMgb25seSB3b3JrcyBpbiBleHBsb3JlLW1vZGUsIHNvIHZhcmlhYmxlcyBkb24ndCBuZWVkIHRvIGJlIGhhbmRsZWQsXG4gICAgLy8gIGFuZCBvbmx5IGZvciBsb2dzLXF1ZXJpZXMsIG5vdCBtZXRyaWMgcXVlcmllc1xuICAgIGNvbnN0IGxvZ3NRdWVyaWVzID0gcmVxdWVzdC50YXJnZXRzLmZpbHRlcigocXVlcnkpID0+IHF1ZXJ5LmV4cHIgIT09ICcnICYmICFpc01ldHJpY3NRdWVyeShxdWVyeS5leHByKSk7XG5cbiAgICBpZiAobG9nc1F1ZXJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gb2Yoe1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgc3RhdGU6IExvYWRpbmdTdGF0ZS5Eb25lLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IGxvZ3NRdWVyaWVzLm1hcCgocXVlcnkpID0+IHtcbiAgICAgIGNvbnN0IG1heERhdGFQb2ludHMgPSBxdWVyeS5tYXhMaW5lcyB8fCB0aGlzLm1heExpbmVzO1xuICAgICAgLy8gRklYTUU6IGN1cnJlbnRseSB3ZSBhcmUgcnVubmluZyBpdCB0aHJvdWdoIHRoZSBmcm9udGVuZCBzdGlsbC5cbiAgICAgIHJldHVybiB0aGlzLnJ1bkxpdmVRdWVyeShxdWVyeSwgbWF4RGF0YVBvaW50cyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWVyZ2UoLi4uc3ViUXVlcmllcyk7XG4gIH1cblxuICBjcmVhdGVMaXZlVGFyZ2V0KHRhcmdldDogTG9raVF1ZXJ5LCBtYXhEYXRhUG9pbnRzOiBudW1iZXIpOiBMb2tpTGl2ZVRhcmdldCB7XG4gICAgY29uc3QgcXVlcnkgPSB0YXJnZXQuZXhwcjtcbiAgICBjb25zdCBiYXNlVXJsID0gdGhpcy5pbnN0YW5jZVNldHRpbmdzLnVybDtcbiAgICBjb25zdCBwYXJhbXMgPSBzZXJpYWxpemVQYXJhbXMoeyBxdWVyeSB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBxdWVyeSxcbiAgICAgIHVybDogY29udmVydFRvV2ViU29ja2V0VXJsKGAke2Jhc2VVcmx9L2xva2kvYXBpL3YxL3RhaWw/JHtwYXJhbXN9YCksXG4gICAgICByZWZJZDogdGFyZ2V0LnJlZklkLFxuICAgICAgc2l6ZTogbWF4RGF0YVBvaW50cyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgbGl2ZSBxdWVyaWVzIHdoaWNoIGluIHRoaXMgY2FzZSBtZWFucyBjcmVhdGluZyBhIHdlYnNvY2tldCBhbmQgbGlzdGVuaW5nIG9uIGl0IGZvciBuZXcgbG9ncy5cbiAgICogVGhpcyByZXR1cm5zIGEgYml0IGRpZmZlcmVudCBkYXRhRnJhbWUgdGhhbiBydW5RdWVyaWVzIGFzIGl0IHJldHVybnMgc2luZ2xlIGRhdGFmcmFtZSBldmVuIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuICAgKiBMb2tpIHN0cmVhbXMsIHNldHMgb25seSBjb21tb24gbGFiZWxzIG9uIGRhdGFmcmFtZS5sYWJlbHMgYW5kIGhhcyBhZGRpdGlvbmFsIGRhdGFmcmFtZS5maWVsZHMubGFiZWxzIGZvciB1bmlxdWVcbiAgICogbGFiZWxzIHBlciByb3cuXG4gICAqL1xuICBydW5MaXZlUXVlcnkgPSAodGFyZ2V0OiBMb2tpUXVlcnksIG1heERhdGFQb2ludHM6IG51bWJlcik6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+ID0+IHtcbiAgICBjb25zdCBsaXZlVGFyZ2V0ID0gdGhpcy5jcmVhdGVMaXZlVGFyZ2V0KHRhcmdldCwgbWF4RGF0YVBvaW50cyk7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJlYW1zLmdldFN0cmVhbShsaXZlVGFyZ2V0KS5waXBlKFxuICAgICAgbWFwKChkYXRhKSA9PiAoe1xuICAgICAgICBkYXRhOiBkYXRhIHx8IFtdLFxuICAgICAgICBrZXk6IGBsb2tpLSR7bGl2ZVRhcmdldC5yZWZJZH1gLFxuICAgICAgICBzdGF0ZTogTG9hZGluZ1N0YXRlLlN0cmVhbWluZyxcbiAgICAgIH0pKSxcbiAgICAgIGNhdGNoRXJyb3IoKGVycjogYW55KSA9PiB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCgpID0+IGBMaXZlIHRhaWxpbmcgd2FzIHN0b3BwZWQgZHVlIHRvIGZvbGxvd2luZyBlcnJvcjogJHtlcnIucmVhc29ufWApO1xuICAgICAgfSlcbiAgICApO1xuICB9O1xuXG4gIGdldFJhbmdlU2NvcGVkVmFycyhyYW5nZTogVGltZVJhbmdlID0gdGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpKSB7XG4gICAgY29uc3QgbXNSYW5nZSA9IHJhbmdlLnRvLmRpZmYocmFuZ2UuZnJvbSk7XG4gICAgY29uc3Qgc1JhbmdlID0gTWF0aC5yb3VuZChtc1JhbmdlIC8gMTAwMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fcmFuZ2VfbXM6IHsgdGV4dDogbXNSYW5nZSwgdmFsdWU6IG1zUmFuZ2UgfSxcbiAgICAgIF9fcmFuZ2VfczogeyB0ZXh0OiBzUmFuZ2UsIHZhbHVlOiBzUmFuZ2UgfSxcbiAgICAgIF9fcmFuZ2U6IHsgdGV4dDogc1JhbmdlICsgJ3MnLCB2YWx1ZTogc1JhbmdlICsgJ3MnIH0sXG4gICAgfTtcbiAgfVxuXG4gIGludGVycG9sYXRlVmFyaWFibGVzSW5RdWVyaWVzKHF1ZXJpZXM6IExva2lRdWVyeVtdLCBzY29wZWRWYXJzOiBTY29wZWRWYXJzKTogTG9raVF1ZXJ5W10ge1xuICAgIGxldCBleHBhbmRlZFF1ZXJpZXMgPSBxdWVyaWVzO1xuICAgIGlmIChxdWVyaWVzICYmIHF1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICBleHBhbmRlZFF1ZXJpZXMgPSBxdWVyaWVzLm1hcCgocXVlcnkpID0+ICh7XG4gICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICBkYXRhc291cmNlOiB0aGlzLmdldFJlZigpLFxuICAgICAgICBleHByOiB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UocXVlcnkuZXhwciwgc2NvcGVkVmFycywgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwciksXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cGFuZGVkUXVlcmllcztcbiAgfVxuXG4gIGdldFF1ZXJ5RGlzcGxheVRleHQocXVlcnk6IExva2lRdWVyeSkge1xuICAgIHJldHVybiBxdWVyeS5leHByO1xuICB9XG5cbiAgZ2V0VGltZVJhbmdlUGFyYW1zKCkge1xuICAgIGNvbnN0IHRpbWVSYW5nZSA9IHRoaXMudGltZVNydi50aW1lUmFuZ2UoKTtcbiAgICByZXR1cm4geyBzdGFydDogdGltZVJhbmdlLmZyb20udmFsdWVPZigpICogTlNfSU5fTVMsIGVuZDogdGltZVJhbmdlLnRvLnZhbHVlT2YoKSAqIE5TX0lOX01TIH07XG4gIH1cblxuICBhc3luYyBpbXBvcnRGcm9tQWJzdHJhY3RRdWVyaWVzKGFic3RyYWN0UXVlcmllczogQWJzdHJhY3RRdWVyeVtdKTogUHJvbWlzZTxMb2tpUXVlcnlbXT4ge1xuICAgIGF3YWl0IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5zdGFydCgpO1xuICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5sYWJlbEtleXM7XG5cbiAgICBpZiAoZXhpc3RpbmdLZXlzICYmIGV4aXN0aW5nS2V5cy5sZW5ndGgpIHtcbiAgICAgIGFic3RyYWN0UXVlcmllcyA9IGFic3RyYWN0UXVlcmllcy5tYXAoKGFic3RyYWN0UXVlcnkpID0+IHtcbiAgICAgICAgYWJzdHJhY3RRdWVyeS5sYWJlbE1hdGNoZXJzID0gYWJzdHJhY3RRdWVyeS5sYWJlbE1hdGNoZXJzLmZpbHRlcigobGFiZWxNYXRjaGVyKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nS2V5cy5pbmNsdWRlcyhsYWJlbE1hdGNoZXIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWJzdHJhY3RRdWVyeTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhYnN0cmFjdFF1ZXJpZXMubWFwKChhYnN0cmFjdFF1ZXJ5KSA9PiB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkoYWJzdHJhY3RRdWVyeSkpO1xuICB9XG5cbiAgYXN5bmMgZXhwb3J0VG9BYnN0cmFjdFF1ZXJpZXMocXVlcmllczogTG9raVF1ZXJ5W10pOiBQcm9taXNlPEFic3RyYWN0UXVlcnlbXT4ge1xuICAgIHJldHVybiBxdWVyaWVzLm1hcCgocXVlcnkpID0+IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5leHBvcnRUb0Fic3RyYWN0UXVlcnkocXVlcnkpKTtcbiAgfVxuXG4gIGFzeW5jIG1ldGFkYXRhUmVxdWVzdCh1cmw6IHN0cmluZywgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPikge1xuICAgIC8vIHVybCBtdXN0IG5vdCBzdGFydCB3aXRoIGEgYC9gLCBvdGhlcndpc2UgdGhlIEFKQVgtcmVxdWVzdFxuICAgIC8vIGdvaW5nIGZyb20gdGhlIGJyb3dzZXIgd2lsbCBjb250YWluIGAvL2AsIHdoaWNoIGNhbiBjYXVzZSBwcm9ibGVtcy5cbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG1ldGFkYXRhIHJlcXVlc3QgdXJsOiAke3VybH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldFJlc291cmNlKHVybCwgcGFyYW1zKTtcbiAgICByZXR1cm4gcmVzLmRhdGEgfHwgW107XG4gIH1cblxuICBhc3luYyBtZXRyaWNGaW5kUXVlcnkocXVlcnk6IHN0cmluZykge1xuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cblxuICAgIGNvbnN0IGludGVycG9sYXRlZCA9IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShxdWVyeSwge30sIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnByb2Nlc3NNZXRyaWNGaW5kUXVlcnkoaW50ZXJwb2xhdGVkKTtcbiAgfVxuXG4gIGFzeW5jIHByb2Nlc3NNZXRyaWNGaW5kUXVlcnkocXVlcnk6IHN0cmluZykge1xuICAgIGNvbnN0IGxhYmVsTmFtZXNSZWdleCA9IC9ebGFiZWxfbmFtZXNcXChcXClcXHMqJC87XG4gICAgY29uc3QgbGFiZWxWYWx1ZXNSZWdleCA9IC9ebGFiZWxfdmFsdWVzXFwoKD86KC4rKSxcXHMqKT8oW2EtekEtWl9dW2EtekEtWjAtOV9dKilcXClcXHMqJC87XG5cbiAgICBjb25zdCBsYWJlbE5hbWVzID0gcXVlcnkubWF0Y2gobGFiZWxOYW1lc1JlZ2V4KTtcbiAgICBpZiAobGFiZWxOYW1lcykge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubGFiZWxOYW1lc1F1ZXJ5KCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxWYWx1ZXMgPSBxdWVyeS5tYXRjaChsYWJlbFZhbHVlc1JlZ2V4KTtcbiAgICBpZiAobGFiZWxWYWx1ZXMpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgcXVlcnkgZXhwciwgdXNlIC9zZXJpZXMgZW5kcG9pbnRcbiAgICAgIGlmIChsYWJlbFZhbHVlc1sxXSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sYWJlbFZhbHVlc1Nlcmllc1F1ZXJ5KGxhYmVsVmFsdWVzWzFdLCBsYWJlbFZhbHVlc1syXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5sYWJlbFZhbHVlc1F1ZXJ5KGxhYmVsVmFsdWVzWzJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIGFzeW5jIGxhYmVsTmFtZXNRdWVyeSgpIHtcbiAgICBjb25zdCB1cmwgPSAnbGFiZWxzJztcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKTtcbiAgICByZXR1cm4gcmVzdWx0Lm1hcCgodmFsdWU6IHN0cmluZykgPT4gKHsgdGV4dDogdmFsdWUgfSkpO1xuICB9XG5cbiAgYXN5bmMgbGFiZWxWYWx1ZXNRdWVyeShsYWJlbDogc3RyaW5nKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCB1cmwgPSBgbGFiZWwvJHtsYWJlbH0vdmFsdWVzYDtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHJlc3VsdC5tYXAoKHZhbHVlOiBzdHJpbmcpID0+ICh7IHRleHQ6IHZhbHVlIH0pKTtcbiAgfVxuXG4gIGFzeW5jIGxhYmVsVmFsdWVzU2VyaWVzUXVlcnkoZXhwcjogc3RyaW5nLCBsYWJlbDogc3RyaW5nKSB7XG4gICAgY29uc3QgdGltZVBhcmFtcyA9IHRoaXMuZ2V0VGltZVJhbmdlUGFyYW1zKCk7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgLi4udGltZVBhcmFtcyxcbiAgICAgICdtYXRjaFtdJzogZXhwcixcbiAgICB9O1xuICAgIGNvbnN0IHVybCA9ICdzZXJpZXMnO1xuICAgIGNvbnN0IHN0cmVhbXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpO1xuICAgIHJlc3VsdC5mb3JFYWNoKChzdHJlYW06IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0pID0+IHtcbiAgICAgIGlmIChzdHJlYW1bbGFiZWxdKSB7XG4gICAgICAgIHN0cmVhbXMuYWRkKHsgdGV4dDogc3RyZWFtW2xhYmVsXSB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBBcnJheS5mcm9tKHN0cmVhbXMpO1xuICB9XG5cbiAgLy8gQnkgaW1wbGVtZW50aW5nIGdldFRhZ0tleXMgYW5kIGdldFRhZ1ZhbHVlcyB3ZSBhZGQgYWQtaG9jIGZpbHR0ZXJzIGZ1bmN0aW9uYWxpdHlcbiAgYXN5bmMgZ2V0VGFnS2V5cygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5sYWJlbE5hbWVzUXVlcnkoKTtcbiAgfVxuXG4gIGFzeW5jIGdldFRhZ1ZhbHVlcyhvcHRpb25zOiBhbnkgPSB7fSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmxhYmVsVmFsdWVzUXVlcnkob3B0aW9ucy5rZXkpO1xuICB9XG5cbiAgaW50ZXJwb2xhdGVRdWVyeUV4cHIodmFsdWU6IGFueSwgdmFyaWFibGU6IGFueSkge1xuICAgIC8vIGlmIG5vIG11bHRpIG9yIGluY2x1ZGUgYWxsIGRvIG5vdCByZWdleEVzY2FwZVxuICAgIGlmICghdmFyaWFibGUubXVsdGkgJiYgIXZhcmlhYmxlLmluY2x1ZGVBbGwpIHtcbiAgICAgIHJldHVybiBsb2tpUmVndWxhckVzY2FwZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBsb2tpU3BlY2lhbFJlZ2V4RXNjYXBlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBlc2NhcGVkVmFsdWVzID0gbG9kYXNoTWFwKHZhbHVlLCBsb2tpU3BlY2lhbFJlZ2V4RXNjYXBlKTtcbiAgICByZXR1cm4gZXNjYXBlZFZhbHVlcy5qb2luKCd8Jyk7XG4gIH1cblxuICBtb2RpZnlRdWVyeShxdWVyeTogTG9raVF1ZXJ5LCBhY3Rpb246IGFueSk6IExva2lRdWVyeSB7XG4gICAgbGV0IGV4cHJlc3Npb24gPSBxdWVyeS5leHByID8/ICcnO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ0FERF9GSUxURVInOiB7XG4gICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLmFkZExhYmVsVG9RdWVyeShleHByZXNzaW9uLCBhY3Rpb24ua2V5LCAnPScsIGFjdGlvbi52YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnQUREX0ZJTFRFUl9PVVQnOiB7XG4gICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLmFkZExhYmVsVG9RdWVyeShleHByZXNzaW9uLCBhY3Rpb24ua2V5LCAnIT0nLCBhY3Rpb24udmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5xdWVyeSwgZXhwcjogZXhwcmVzc2lvbiB9O1xuICB9XG5cbiAgZ2V0VGltZShkYXRlOiBzdHJpbmcgfCBEYXRlVGltZSwgcm91bmRVcDogYm9vbGVhbikge1xuICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGUgPSBkYXRlTWF0aC5wYXJzZShkYXRlLCByb3VuZFVwKSE7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguY2VpbChkYXRlLnZhbHVlT2YoKSAqIDFlNik7XG4gIH1cblxuICBnZXRMb2dSb3dDb250ZXh0ID0gKHJvdzogTG9nUm93TW9kZWwsIG9wdGlvbnM/OiBSb3dDb250ZXh0T3B0aW9ucyk6IFByb21pc2U8eyBkYXRhOiBEYXRhRnJhbWVbXSB9PiA9PiB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5kaXJlY3Rpb24pIHx8ICdCQUNLV0FSRCc7XG4gICAgY29uc3QgbGltaXQgPSAob3B0aW9ucyAmJiBvcHRpb25zLmxpbWl0KSB8fCAxMDtcbiAgICBjb25zdCB7IHF1ZXJ5LCByYW5nZSB9ID0gdGhpcy5wcmVwYXJlTG9nUm93Q29udGV4dFF1ZXJ5VGFyZ2V0KHJvdywgbGltaXQsIGRpcmVjdGlvbik7XG5cbiAgICBjb25zdCBwcm9jZXNzRGF0YUZyYW1lID0gKGZyYW1lOiBEYXRhRnJhbWUpOiBEYXRhRnJhbWUgPT4ge1xuICAgICAgLy8gbG9nLXJvdy1jb250ZXh0IHJlcXVpcmVzIHNwZWNpZmljIGZpZWxkLW5hbWVzIHRvIHdvcmssIHNvIHdlIHNldCB0aGVtIGhlcmU6IFwidHNcIiwgXCJsaW5lXCIsIFwiaWRcIlxuICAgICAgY29uc3QgY2FjaGUgPSBuZXcgRmllbGRDYWNoZShmcmFtZSk7XG4gICAgICBjb25zdCB0aW1lc3RhbXBGaWVsZCA9IGNhY2hlLmdldEZpcnN0RmllbGRPZlR5cGUoRmllbGRUeXBlLnRpbWUpO1xuICAgICAgY29uc3QgbGluZUZpZWxkID0gY2FjaGUuZ2V0Rmlyc3RGaWVsZE9mVHlwZShGaWVsZFR5cGUuc3RyaW5nKTtcbiAgICAgIGNvbnN0IGlkRmllbGQgPSBjYWNoZS5nZXRGaWVsZEJ5TmFtZSgnaWQnKTtcblxuICAgICAgaWYgKHRpbWVzdGFtcEZpZWxkID09PSB1bmRlZmluZWQgfHwgbGluZUZpZWxkID09PSB1bmRlZmluZWQgfHwgaWRGaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRoaXMgc2hvdWxkIG5ldmVyIHJlYWxseSBoYXBwZW4sIGJ1dCBpIHdhbnQgdG8ga2VlcCB0eXBlc2NyaXB0IGhhcHB5XG4gICAgICAgIHJldHVybiB7IC4uLmZyYW1lLCBmaWVsZHM6IFtdIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmZyYW1lLFxuICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi50aW1lc3RhbXBGaWVsZCxcbiAgICAgICAgICAgIG5hbWU6ICd0cycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5saW5lRmllbGQsXG4gICAgICAgICAgICBuYW1lOiAnbGluZScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5pZEZpZWxkLFxuICAgICAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgcHJvY2Vzc1Jlc3VsdHMgPSAocmVzdWx0OiBEYXRhUXVlcnlSZXNwb25zZSk6IERhdGFRdWVyeVJlc3BvbnNlID0+IHtcbiAgICAgIGNvbnN0IGZyYW1lczogRGF0YUZyYW1lW10gPSByZXN1bHQuZGF0YTtcbiAgICAgIGNvbnN0IHByb2Nlc3NlZEZyYW1lcyA9IGZyYW1lc1xuICAgICAgICAubWFwKChmcmFtZSkgPT4gc29ydERhdGFGcmFtZUJ5VGltZShmcmFtZSwgJ0RFU0NFTkRJTkcnKSlcbiAgICAgICAgLm1hcCgoZnJhbWUpID0+IHByb2Nlc3NEYXRhRnJhbWUoZnJhbWUpKTsgLy8gcmVuYW1lIGZpZWxkcyBpZiBuZWVkZWRcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICBkYXRhOiBwcm9jZXNzZWRGcmFtZXMsXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyB0aGlzIGNhbiBvbmx5IGJlIGNhbGxlZCBmcm9tIGV4cGxvcmUgY3VycmVudGx5XG4gICAgY29uc3QgYXBwID0gQ29yZUFwcC5FeHBsb3JlO1xuXG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICB0aGlzLnF1ZXJ5KG1ha2VSZXF1ZXN0KHF1ZXJ5LCByYW5nZSwgYXBwLCBgbG9nLXJvdy1jb250ZXh0LXF1ZXJ5LSR7ZGlyZWN0aW9ufWApKS5waXBlKFxuICAgICAgICBjYXRjaEVycm9yKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zdCBlcnJvcjogRGF0YVF1ZXJ5RXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnRXJyb3IgZHVyaW5nIGNvbnRleHQgcXVlcnkuIFBsZWFzZSBjaGVjayBKUyBjb25zb2xlIGxvZ3MuJyxcbiAgICAgICAgICAgIHN0YXR1czogZXJyLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IGVyci5zdGF0dXNUZXh0LFxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pLFxuICAgICAgICBzd2l0Y2hNYXAoKHJlcykgPT4gb2YocHJvY2Vzc1Jlc3VsdHMocmVzKSkpXG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICBwcmVwYXJlTG9nUm93Q29udGV4dFF1ZXJ5VGFyZ2V0ID0gKFxuICAgIHJvdzogTG9nUm93TW9kZWwsXG4gICAgbGltaXQ6IG51bWJlcixcbiAgICBkaXJlY3Rpb246ICdCQUNLV0FSRCcgfCAnRk9SV0FSRCdcbiAgKTogeyBxdWVyeTogTG9raVF1ZXJ5OyByYW5nZTogVGltZVJhbmdlIH0gPT4ge1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5nZXRMYWJlbEtleXMoKTtcbiAgICBjb25zdCBleHByID0gT2JqZWN0LmtleXMocm93LmxhYmVscylcbiAgICAgIC5tYXAoKGxhYmVsOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGxhYmVscy5pbmNsdWRlcyhsYWJlbCkpIHtcbiAgICAgICAgICAvLyBlc2NhcGUgYmFja3NsYXNoZXMgaW4gbGFiZWwgYXMgdXNlcnMgY2FuJ3QgZXNjYXBlIHRoZW0gYnkgdGhlbXNlbHZlc1xuICAgICAgICAgIHJldHVybiBgJHtsYWJlbH09XCIke3Jvdy5sYWJlbHNbbGFiZWxdLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJyl9XCJgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0pXG4gICAgICAvLyBGaWx0ZXIgZW1wdHkgc3RyaW5nc1xuICAgICAgLmZpbHRlcigobGFiZWwpID0+ICEhbGFiZWwpXG4gICAgICAuam9pbignLCcpO1xuXG4gICAgY29uc3QgY29udGV4dFRpbWVCdWZmZXIgPSAyICogNjAgKiA2MCAqIDEwMDA7IC8vIDJoIGJ1ZmZlclxuXG4gICAgY29uc3QgcXVlcnlEaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09ICdGT1JXQVJEJyA/IExva2lRdWVyeURpcmVjdGlvbi5Gb3J3YXJkIDogTG9raVF1ZXJ5RGlyZWN0aW9uLkJhY2t3YXJkO1xuXG4gICAgY29uc3QgcXVlcnk6IExva2lRdWVyeSA9IHtcbiAgICAgIGV4cHI6IGB7JHtleHByfX1gLFxuICAgICAgcXVlcnlUeXBlOiBMb2tpUXVlcnlUeXBlLlJhbmdlLFxuICAgICAgcmVmSWQ6ICcnLFxuICAgICAgbWF4TGluZXM6IGxpbWl0LFxuICAgICAgZGlyZWN0aW9uOiBxdWVyeURpcmVjdGlvbixcbiAgICB9O1xuXG4gICAgY29uc3QgZmllbGRDYWNoZSA9IG5ldyBGaWVsZENhY2hlKHJvdy5kYXRhRnJhbWUpO1xuICAgIGNvbnN0IHRzRmllbGQgPSBmaWVsZENhY2hlLmdldEZpcnN0RmllbGRPZlR5cGUoRmllbGRUeXBlLnRpbWUpO1xuICAgIGlmICh0c0ZpZWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbG9raTogZGF0YWZyYW1lIG1pc3NpbmcgdGltZS1maWVsZCwgc2hvdWxkIG5ldmVyIGhhcHBlbicpO1xuICAgIH1cbiAgICBjb25zdCB0c1ZhbHVlID0gdHNGaWVsZC52YWx1ZXMuZ2V0KHJvdy5yb3dJbmRleCk7XG4gICAgY29uc3QgdGltZXN0YW1wID0gdG9VdGModHNWYWx1ZSk7XG5cbiAgICBjb25zdCByYW5nZSA9XG4gICAgICBxdWVyeURpcmVjdGlvbiA9PT0gTG9raVF1ZXJ5RGlyZWN0aW9uLkZvcndhcmRcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAvLyBzdGFydCBwYXJhbSBpbiBMb2tpIEFQSSBpcyBpbmNsdXNpdmUgc28gd2UnbGwgaGF2ZSB0byBmaWx0ZXIgb3V0IHRoZSByb3cgdGhhdCB0aGlzIHJlcXVlc3QgaXMgYmFzZWQgZnJvbVxuICAgICAgICAgICAgLy8gYW5kIGFueSBvdGhlciB0aGF0IHdlcmUgbG9nZ2VkIGluIHRoZSBzYW1lIG5zIGJ1dCBiZWZvcmUgdGhlIHJvdy4gUmlnaHQgbm93IHRoZXNlIHJvd3Mgd2lsbCBiZSBsb3N0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBhcmUgYmVmb3JlIGJ1dCBjYW1lIGl0IGhlIHJlc3BvbnNlIHRoYXQgc2hvdWxkIHJldHVybiBvbmx5IHJvd3MgYWZ0ZXIuXG4gICAgICAgICAgICBmcm9tOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIG5zLCB3ZSBsb29zZSBzb21lIHByZWNpc2lvbiBoZXJlIGJ1dCBpdCBpcyBub3QgdGhhdCBpbXBvcnRhbnQgYXQgdGhlIGZhciBwb2ludHMgb2YgdGhlIGNvbnRleHRcbiAgICAgICAgICAgIHRvOiB0b1V0Yyhyb3cudGltZUVwb2NoTXMgKyBjb250ZXh0VGltZUJ1ZmZlciksXG4gICAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gbnMsIHdlIGxvb3NlIHNvbWUgcHJlY2lzaW9uIGhlcmUgYnV0IGl0IGlzIG5vdCB0aGF0IGltcG9ydGFudCBhdCB0aGUgZmFyIHBvaW50cyBvZiB0aGUgY29udGV4dFxuICAgICAgICAgICAgZnJvbTogdG9VdGMocm93LnRpbWVFcG9jaE1zIC0gY29udGV4dFRpbWVCdWZmZXIpLFxuICAgICAgICAgICAgdG86IHRpbWVzdGFtcCxcbiAgICAgICAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgcmFuZ2U6IHtcbiAgICAgICAgZnJvbTogcmFuZ2UuZnJvbSxcbiAgICAgICAgdG86IHJhbmdlLnRvLFxuICAgICAgICByYXc6IHJhbmdlLFxuICAgICAgfSxcbiAgICB9O1xuICB9O1xuXG4gIHRlc3REYXRhc291cmNlKCk6IFByb21pc2U8eyBzdGF0dXM6IHN0cmluZzsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICAvLyBDb25zaWRlciBvbmx5IGxhc3QgMTAgbWludXRlcyBvdGhlcndpc2UgcmVxdWVzdCB0YWtlcyB0b28gbG9uZ1xuICAgIGNvbnN0IG5vd01zID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBzdGFydDogKG5vd01zIC0gMTAgKiA2MCAqIDEwMDApICogTlNfSU5fTVMsXG4gICAgICBlbmQ6IG5vd01zICogTlNfSU5fTVMsXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhUmVxdWVzdCgnbGFiZWxzJywgcGFyYW1zKS50aGVuKFxuICAgICAgKHZhbHVlcykgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IHsgc3RhdHVzOiAnc3VjY2VzcycsIG1lc3NhZ2U6ICdEYXRhIHNvdXJjZSBjb25uZWN0ZWQgYW5kIGxhYmVscyBmb3VuZC4nIH1cbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICdEYXRhIHNvdXJjZSBjb25uZWN0ZWQsIGJ1dCBubyBsYWJlbHMgcmVjZWl2ZWQuIFZlcmlmeSB0aGF0IExva2kgYW5kIFByb210YWlsIGlzIGNvbmZpZ3VyZWQgcHJvcGVybHkuJyxcbiAgICAgICAgICAgIH07XG4gICAgICB9LFxuICAgICAgKGVycikgPT4ge1xuICAgICAgICAvLyB3ZSBkaWQgYSByZXNvdXJjZS1jYWxsIHRoYXQgZmFpbGVkLlxuICAgICAgICAvLyB0aGUgb25seSBpbmZvIHdlIGhhdmUsIGlmIGV4aXN0cywgaXMgZXJyLmRhdGEubWVzc2FnZVxuICAgICAgICAvLyAod2hlbiBpbiBkZXZlbG9wbWVudC1tb2RlLCBlcnIuZGF0YS5lcnJvciBleGlzdHMgdG9vLCBidXQgbm90IGluIHByb2R1Y3Rpb24tbW9kZSlcbiAgICAgICAgLy8gdGhpbmdzIGxpa2UgZXJyLnN0YXR1cyAmIGVyci5zdGF0dXNUZXh0IGRvZXMgbm90IGhlbHAsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhvc2Ugd2lsbCBvbmx5IGRlc2NyaWJlIGhvdyB0aGUgcmVxdWVzdCBiZXR3ZWVuIGJyb3dzZXI8PnNlcnZlciBmYWlsZWRcbiAgICAgICAgY29uc3QgaW5mbzogc3RyaW5nID0gZXJyPy5kYXRhPy5tZXNzYWdlID8/ICcnO1xuICAgICAgICBjb25zdCBpbmZvSW5QYXJlbnRoZXNlcyA9IGluZm8gIT09ICcnID8gYCAoJHtpbmZvfSlgIDogJyc7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVW5hYmxlIHRvIGZldGNoIGxhYmVscyBmcm9tIExva2kke2luZm9JblBhcmVudGhlc2VzfSwgcGxlYXNlIGNoZWNrIHRoZSBzZXJ2ZXIgbG9ncyBmb3IgbW9yZSBkZXRhaWxzYDtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBtZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGFubm90YXRpb25RdWVyeShvcHRpb25zOiBhbnkpOiBQcm9taXNlPEFubm90YXRpb25FdmVudFtdPiB7XG4gICAgY29uc3QgeyBleHByLCBtYXhMaW5lcywgaW5zdGFudCwgdGFnS2V5cyA9ICcnLCB0aXRsZUZvcm1hdCA9ICcnLCB0ZXh0Rm9ybWF0ID0gJycgfSA9IG9wdGlvbnMuYW5ub3RhdGlvbjtcblxuICAgIGlmICghZXhwcikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gYGFubm90YXRpb24tJHtvcHRpb25zLmFubm90YXRpb24ubmFtZX1gO1xuXG4gICAgY29uc3QgcXVlcnk6IExva2lRdWVyeSA9IHtcbiAgICAgIHJlZklkOiBpZCxcbiAgICAgIGV4cHIsXG4gICAgICBtYXhMaW5lcyxcbiAgICAgIGluc3RhbnQsXG4gICAgICBxdWVyeVR5cGU6IGluc3RhbnQgPyBMb2tpUXVlcnlUeXBlLkluc3RhbnQgOiBMb2tpUXVlcnlUeXBlLlJhbmdlLFxuICAgIH07XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gbWFrZVJlcXVlc3QocXVlcnksIG9wdGlvbnMucmFuZ2UsIENvcmVBcHAuRGFzaGJvYXJkLCBpZCk7XG5cbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGxhc3RWYWx1ZUZyb20odGhpcy5xdWVyeShyZXF1ZXN0KSk7XG5cbiAgICBjb25zdCBhbm5vdGF0aW9uczogQW5ub3RhdGlvbkV2ZW50W10gPSBbXTtcbiAgICBjb25zdCBzcGxpdEtleXM6IHN0cmluZ1tdID0gdGFnS2V5cy5zcGxpdCgnLCcpLmZpbHRlcigodjogc3RyaW5nKSA9PiB2ICE9PSAnJyk7XG5cbiAgICBmb3IgKGNvbnN0IGZyYW1lIG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YUZyYW1lVmlldzx7IFRpbWU6IHN0cmluZzsgTGluZTogc3RyaW5nOyBsYWJlbHM6IExhYmVscyB9PihmcmFtZSk7XG5cbiAgICAgIHZpZXcuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbGFiZWxzIH0gPSByb3c7XG5cbiAgICAgICAgY29uc3QgbWF5YmVEdXBsaWNhdGVkVGFncyA9IE9iamVjdC5lbnRyaWVzKGxhYmVscylcbiAgICAgICAgICAubWFwKChba2V5LCB2YWxdKSA9PiBba2V5LCB2YWwudHJpbSgpXSkgLy8gdHJpbSBhbGwgbGFiZWwtdmFsdWVzXG4gICAgICAgICAgLmZpbHRlcigoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGFncyBhcmUgc3BlY2lmaWVkLCByZW1vdmUgbGFiZWwgaWYgZG9lcyBub3QgbWF0Y2ggdGFnc1xuICAgICAgICAgICAgaWYgKHNwbGl0S2V5cy5sZW5ndGggJiYgIXNwbGl0S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAubWFwKChba2V5LCB2YWxdKSA9PiB2YWwpOyAvLyBrZWVwIG9ubHkgdGhlIGxhYmVsLXZhbHVlXG5cbiAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgICAgY29uc3QgdGFncyA9IEFycmF5LmZyb20obmV3IFNldChtYXliZUR1cGxpY2F0ZWRUYWdzKSk7XG5cbiAgICAgICAgYW5ub3RhdGlvbnMucHVzaCh7XG4gICAgICAgICAgdGltZTogbmV3IERhdGUocm93LlRpbWUpLnZhbHVlT2YoKSxcbiAgICAgICAgICB0aXRsZTogcmVuZGVyTGVnZW5kRm9ybWF0KHRpdGxlRm9ybWF0LCBsYWJlbHMpLFxuICAgICAgICAgIHRleHQ6IHJlbmRlckxlZ2VuZEZvcm1hdCh0ZXh0Rm9ybWF0LCBsYWJlbHMpIHx8IHJvdy5MaW5lLFxuICAgICAgICAgIHRhZ3MsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFubm90YXRpb25zO1xuICB9XG5cbiAgc2hvd0NvbnRleHRUb2dnbGUocm93PzogTG9nUm93TW9kZWwpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHJvdyAmJiByb3cuc2VhcmNoV29yZHMgJiYgcm93LnNlYXJjaFdvcmRzLmxlbmd0aCA+IDApID09PSB0cnVlO1xuICB9XG5cbiAgcHJvY2Vzc0Vycm9yKGVycjogRmV0Y2hFcnJvciwgdGFyZ2V0OiBMb2tpUXVlcnkpIHtcbiAgICBsZXQgZXJyb3I6IERhdGFRdWVyeUVycm9yID0gY2xvbmVEZWVwKGVycik7XG4gICAgZXJyb3IucmVmSWQgPSB0YXJnZXQucmVmSWQ7XG5cbiAgICBpZiAoZXJyb3IuZGF0YSAmJiBlcnIuZGF0YS5tZXNzYWdlLmluY2x1ZGVzKCdlc2NhcGUnKSAmJiB0YXJnZXQuZXhwci5pbmNsdWRlcygnXFxcXCcpKSB7XG4gICAgICBlcnJvci5kYXRhLm1lc3NhZ2UgPSBgRXJyb3I6ICR7ZXJyLmRhdGEubWVzc2FnZX0uIE1ha2Ugc3VyZSB0aGF0IGFsbCBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgd2l0aCBcXFxcLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBlc2NhcGluZyBvZiBzcGVjaWFsIGNoYXJhY3RlcnMgdmlzaXQgTG9nUUwgZG9jdW1lbnRhdGlvbiBhdCBodHRwczovL2dyYWZhbmEuY29tL2RvY3MvbG9raS9sYXRlc3QvbG9ncWwvLmA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgYWRkQWRIb2NGaWx0ZXJzKHF1ZXJ5RXhwcjogc3RyaW5nKSB7XG4gICAgY29uc3QgYWRob2NGaWx0ZXJzID0gdGhpcy50ZW1wbGF0ZVNydi5nZXRBZGhvY0ZpbHRlcnModGhpcy5uYW1lKTtcbiAgICBsZXQgZXhwciA9IHF1ZXJ5RXhwcjtcblxuICAgIGV4cHIgPSBhZGhvY0ZpbHRlcnMucmVkdWNlKChhY2M6IHN0cmluZywgZmlsdGVyOiB7IGtleTogc3RyaW5nOyBvcGVyYXRvcjogc3RyaW5nOyB2YWx1ZTogc3RyaW5nIH0pID0+IHtcbiAgICAgIGNvbnN0IHsga2V5LCBvcGVyYXRvciwgdmFsdWUgfSA9IGZpbHRlcjtcbiAgICAgIHJldHVybiB0aGlzLmFkZExhYmVsVG9RdWVyeShhY2MsIGtleSwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9LCBleHByKTtcblxuICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgYWRkTGFiZWxUb1F1ZXJ5KHF1ZXJ5RXhwcjogc3RyaW5nLCBrZXk6IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IGVzY2FwZWRWYWx1ZSA9IGVzY2FwZUxhYmVsVmFsdWVJblNlbGVjdG9yKHZhbHVlLCBvcGVyYXRvcik7XG4gICAgcmV0dXJuIGFkZExhYmVsVG9RdWVyeShxdWVyeUV4cHIsIGtleSwgb3BlcmF0b3IsIGVzY2FwZWRWYWx1ZSk7XG4gIH1cblxuICAvLyBVc2VkIHdoZW4gcnVubmluZyBxdWVyaWVzIHRocm91Z2ggYmFja2VuZFxuICBmaWx0ZXJRdWVyeShxdWVyeTogTG9raVF1ZXJ5KTogYm9vbGVhbiB7XG4gICAgaWYgKHF1ZXJ5LmhpZGUgfHwgcXVlcnkuZXhwciA9PT0gJycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBVc2VkIHdoZW4gcnVubmluZyBxdWVyaWVzIHRocm91Z2ggYmFja2VuZFxuICBhcHBseVRlbXBsYXRlVmFyaWFibGVzKHRhcmdldDogTG9raVF1ZXJ5LCBzY29wZWRWYXJzOiBTY29wZWRWYXJzKTogTG9raVF1ZXJ5IHtcbiAgICAvLyBXZSB3YW50IHRvIGludGVycG9sYXRlIHRoZXNlIHZhcmlhYmxlcyBvbiBiYWNrZW5kXG4gICAgY29uc3QgeyBfX2ludGVydmFsLCBfX2ludGVydmFsX21zLCAuLi5yZXN0IH0gPSBzY29wZWRWYXJzO1xuXG4gICAgY29uc3QgZXhwcldpdGhBZEhvYyA9IHRoaXMuYWRkQWRIb2NGaWx0ZXJzKHRhcmdldC5leHByKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBsZWdlbmRGb3JtYXQ6IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZSh0YXJnZXQubGVnZW5kRm9ybWF0LCByZXN0KSxcbiAgICAgIGV4cHI6IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShleHByV2l0aEFkSG9jLCByZXN0LCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKSxcbiAgICB9O1xuICB9XG5cbiAgaW50ZXJwb2xhdGVTdHJpbmcoc3RyaW5nOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHN0cmluZywgdW5kZWZpbmVkLCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGVTcnYuZ2V0VmFyaWFibGVzKCkubWFwKCh2KSA9PiBgJCR7di5uYW1lfWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2tpUmVndWxhckVzY2FwZSh2YWx1ZTogYW55KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLycvZywgXCJcXFxcXFxcXCdcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9raVNwZWNpYWxSZWdleEVzY2FwZSh2YWx1ZTogYW55KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGxva2lSZWd1bGFyRXNjYXBlKHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcXFxcXFxcXFwnKS5yZXBsYWNlKC9bJF4qe31cXFtcXF0rPy4oKXxdL2csICdcXFxcXFxcXCQmJykpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHF1ZXJ5IGV4cHJlc3Npb24gdXNlcyBmdW5jdGlvbiBhbmQgc28gc2hvdWxkIHJldHVybiBhIHRpbWUgc2VyaWVzIGluc3RlYWQgb2YgbG9ncy5cbiAqIFNvbWV0aW1lcyBpbXBvcnRhbnQgdG8ga25vdyB0aGF0IGJlZm9yZSB3ZSBhY3R1YWxseSBkbyB0aGUgcXVlcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc01ldHJpY3NRdWVyeShxdWVyeTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdG9rZW5zID0gUHJpc20udG9rZW5pemUocXVlcnksIHN5bnRheCk7XG4gIHJldHVybiB0b2tlbnMuc29tZSgodCkgPT4ge1xuICAgIC8vIE5vdCBzdXJlIGluIHdoaWNoIGNhc2VzIGl0IGNhbiBiZSBzdHJpbmcgbWF5YmUgaWYgbm90aGluZyBtYXRjaGVkIHdoaWNoIG1lYW5zIGl0IHNob3VsZCBub3QgYmUgYSBmdW5jdGlvblxuICAgIHJldHVybiB0eXBlb2YgdCAhPT0gJ3N0cmluZycgJiYgdC50eXBlID09PSAnZnVuY3Rpb24nO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdExldmVsKGRhdGFGcmFtZTogRGF0YUZyYW1lKTogTG9nTGV2ZWwge1xuICBsZXQgdmFsdWVGaWVsZDtcbiAgdHJ5IHtcbiAgICB2YWx1ZUZpZWxkID0gbmV3IEZpZWxkQ2FjaGUoZGF0YUZyYW1lKS5nZXRGaXJzdEZpZWxkT2ZUeXBlKEZpZWxkVHlwZS5udW1iZXIpO1xuICB9IGNhdGNoIHt9XG4gIHJldHVybiB2YWx1ZUZpZWxkPy5sYWJlbHMgPyBnZXRMb2dMZXZlbEZyb21MYWJlbHModmFsdWVGaWVsZC5sYWJlbHMpIDogTG9nTGV2ZWwudW5rbm93bjtcbn1cblxuZnVuY3Rpb24gZ2V0TG9nTGV2ZWxGcm9tTGFiZWxzKGxhYmVsczogTGFiZWxzKTogTG9nTGV2ZWwge1xuICBjb25zdCBsYWJlbE5hbWVzID0gWydsZXZlbCcsICdsdmwnLCAnbG9nbGV2ZWwnXTtcbiAgbGV0IGxldmVsTGFiZWw7XG4gIGZvciAobGV0IGxhYmVsTmFtZSBvZiBsYWJlbE5hbWVzKSB7XG4gICAgaWYgKGxhYmVsTmFtZSBpbiBsYWJlbHMpIHtcbiAgICAgIGxldmVsTGFiZWwgPSBsYWJlbE5hbWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxldmVsTGFiZWwgPyBnZXRMb2dMZXZlbEZyb21LZXkobGFiZWxzW2xldmVsTGFiZWxdKSA6IExvZ0xldmVsLnVua25vd247XG59XG4iLCJpbXBvcnQgeyBncm91cEJ5IH0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHsgRmllbGRUeXBlLCBEYXRhRnJhbWUsIEFycmF5VmVjdG9yLCBEYXRhTGluaywgRmllbGQgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGdldERhdGFTb3VyY2VTcnYgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcblxuaW1wb3J0IHsgRGVyaXZlZEZpZWxkQ29uZmlnIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXJpdmVkRmllbGRzKGRhdGFGcmFtZTogRGF0YUZyYW1lLCBkZXJpdmVkRmllbGRDb25maWdzOiBEZXJpdmVkRmllbGRDb25maWdbXSk6IEZpZWxkW10ge1xuICBpZiAoIWRlcml2ZWRGaWVsZENvbmZpZ3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGRlcml2ZWRGaWVsZHNHcm91cGVkID0gZ3JvdXBCeShkZXJpdmVkRmllbGRDb25maWdzLCAnbmFtZScpO1xuXG4gIGNvbnN0IG5ld0ZpZWxkcyA9IE9iamVjdC52YWx1ZXMoZGVyaXZlZEZpZWxkc0dyb3VwZWQpLm1hcChmaWVsZEZyb21EZXJpdmVkRmllbGRDb25maWcpO1xuXG4gIC8vIGxpbmUtZmllbGQgaXMgdGhlIGZpcnN0IHN0cmluZy1maWVsZFxuICAvLyBOT1RFOiB3ZSBzaG91bGQgY3JlYXRlIHNvbWUgY29tbW9uIGxvZy1mcmFtZS1leHRyYS1zdHJpbmctZmllbGQgY29kZSBzb21ld2hlcmVcbiAgY29uc3QgbGluZUZpZWxkID0gZGF0YUZyYW1lLmZpZWxkcy5maW5kKChmKSA9PiBmLnR5cGUgPT09IEZpZWxkVHlwZS5zdHJpbmcpO1xuXG4gIGlmIChsaW5lRmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGlmIHRoaXMgaXMgaGFwcGVuaW5nLCBzb21ldGhpbmcgd2VudCB3cm9uZywgbGV0J3MgcmFpc2UgYW4gZXJyb3JcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbG9ncy1kYXRhZnJhbWUsIHN0cmluZy1maWVsZCBtaXNzaW5nJyk7XG4gIH1cblxuICBsaW5lRmllbGQudmFsdWVzLnRvQXJyYXkoKS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBuZXdGaWVsZHMpIHtcbiAgICAgIGNvbnN0IGxvZ01hdGNoID0gbGluZS5tYXRjaChkZXJpdmVkRmllbGRzR3JvdXBlZFtmaWVsZC5uYW1lXVswXS5tYXRjaGVyUmVnZXgpO1xuICAgICAgZmllbGQudmFsdWVzLmFkZChsb2dNYXRjaCAmJiBsb2dNYXRjaFsxXSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbmV3RmllbGRzO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBkZXJpdmVkRmllbGQgY29uZmlnIGludG8gZGF0YWZyYW1lIGZpZWxkIHdpdGggY29uZmlnIHRoYXQgY29udGFpbnMgbGluay5cbiAqL1xuZnVuY3Rpb24gZmllbGRGcm9tRGVyaXZlZEZpZWxkQ29uZmlnKGRlcml2ZWRGaWVsZENvbmZpZ3M6IERlcml2ZWRGaWVsZENvbmZpZ1tdKTogRmllbGQ8YW55LCBBcnJheVZlY3Rvcj4ge1xuICBjb25zdCBkYXRhU291cmNlU3J2ID0gZ2V0RGF0YVNvdXJjZVNydigpO1xuXG4gIGNvbnN0IGRhdGFMaW5rcyA9IGRlcml2ZWRGaWVsZENvbmZpZ3MucmVkdWNlKChhY2MsIGRlcml2ZWRGaWVsZENvbmZpZykgPT4ge1xuICAgIC8vIEhhdmluZyBmaWVsZC5kYXRhc291cmNlVWlkIG1lYW5zIGl0IGlzIGFuIGludGVybmFsIGxpbmsuXG4gICAgaWYgKGRlcml2ZWRGaWVsZENvbmZpZy5kYXRhc291cmNlVWlkKSB7XG4gICAgICBjb25zdCBkc1NldHRpbmdzID0gZGF0YVNvdXJjZVNydi5nZXRJbnN0YW5jZVNldHRpbmdzKGRlcml2ZWRGaWVsZENvbmZpZy5kYXRhc291cmNlVWlkKTtcblxuICAgICAgYWNjLnB1c2goe1xuICAgICAgICAvLyBXaWxsIGJlIGZpbGxlZCBvdXQgbGF0ZXJcbiAgICAgICAgdGl0bGU6IGRlcml2ZWRGaWVsZENvbmZpZy51cmxEaXNwbGF5TGFiZWwgfHwgJycsXG4gICAgICAgIHVybDogJycsXG4gICAgICAgIC8vIFRoaXMgaXMgaGFyZGNvZGVkIGZvciBKYWVnZXIgb3IgWmlwa2luIG5vdCB3YXkgcmlnaHQgbm93IHRvIHNwZWNpZnkgZGF0YXNvdXJjZSBzcGVjaWZpYyBxdWVyeSBvYmplY3RcbiAgICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgICBxdWVyeTogeyBxdWVyeTogZGVyaXZlZEZpZWxkQ29uZmlnLnVybCB9LFxuICAgICAgICAgIGRhdGFzb3VyY2VVaWQ6IGRlcml2ZWRGaWVsZENvbmZpZy5kYXRhc291cmNlVWlkLFxuICAgICAgICAgIGRhdGFzb3VyY2VOYW1lOiBkc1NldHRpbmdzPy5uYW1lID8/ICdEYXRhIHNvdXJjZSBub3QgZm91bmQnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkZXJpdmVkRmllbGRDb25maWcudXJsKSB7XG4gICAgICBhY2MucHVzaCh7XG4gICAgICAgIC8vIFdlIGRvIG5vdCBrbm93IHdoYXQgdGl0bGUgdG8gZ2l2ZSBoZXJlIHNvIHdlIGNvdW50IG9uIHByZXNlbnRhdGlvbiBsYXllciB0byBjcmVhdGUgYSB0aXRsZSBmcm9tIG1ldGFkYXRhLlxuICAgICAgICB0aXRsZTogZGVyaXZlZEZpZWxkQ29uZmlnLnVybERpc3BsYXlMYWJlbCB8fCAnJyxcbiAgICAgICAgLy8gVGhpcyBpcyBoYXJkY29kZWQgZm9yIEphZWdlciBvciBaaXBraW4gbm90IHdheSByaWdodCBub3cgdG8gc3BlY2lmeSBkYXRhc291cmNlIHNwZWNpZmljIHF1ZXJ5IG9iamVjdFxuICAgICAgICB1cmw6IGRlcml2ZWRGaWVsZENvbmZpZy51cmwsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10gYXMgRGF0YUxpbmtbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBkZXJpdmVkRmllbGRDb25maWdzWzBdLm5hbWUsXG4gICAgdHlwZTogRmllbGRUeXBlLnN0cmluZyxcbiAgICBjb25maWc6IHtcbiAgICAgIGxpbmtzOiBkYXRhTGlua3MsXG4gICAgfSxcbiAgICAvLyBXZSBhcmUgYWRkaW5nIHZhbHVlcyBsYXRlciBvblxuICAgIHZhbHVlczogbmV3IEFycmF5VmVjdG9yPHN0cmluZz4oW10pLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgY2hhaW4sIGRpZmZlcmVuY2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IExSVSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IFByaXNtLCB7IEdyYW1tYXIgfSBmcm9tICdwcmlzbWpzJztcblxuaW1wb3J0IHsgZGF0ZVRpbWUsIEFic29sdXRlVGltZVJhbmdlLCBMYW5ndWFnZVByb3ZpZGVyLCBIaXN0b3J5SXRlbSwgQWJzdHJhY3RRdWVyeSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgQ29tcGxldGlvbkl0ZW0sIFR5cGVhaGVhZElucHV0LCBUeXBlYWhlYWRPdXRwdXQsIENvbXBsZXRpb25JdGVtR3JvdXAgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQge1xuICBleHRyYWN0TGFiZWxNYXRjaGVycyxcbiAgcGFyc2VTZWxlY3RvcixcbiAgcHJvY2Vzc0xhYmVscyxcbiAgdG9Qcm9tTGlrZUV4cHIsXG59IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9sYW5ndWFnZV91dGlscyc7XG5cbmltcG9ydCB7IExva2lEYXRhc291cmNlIH0gZnJvbSAnLi9kYXRhc291cmNlJztcbmltcG9ydCBzeW50YXgsIHsgRlVOQ1RJT05TLCBQSVBFX1BBUlNFUlMsIFBJUEVfT1BFUkFUT1JTIH0gZnJvbSAnLi9zeW50YXgnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5LCBMb2tpUXVlcnlUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IERFRkFVTFRfS0VZUyA9IFsnam9iJywgJ25hbWVzcGFjZSddO1xuY29uc3QgRU1QVFlfU0VMRUNUT1IgPSAne30nO1xuY29uc3QgSElTVE9SWV9JVEVNX0NPVU5UID0gMTA7XG5jb25zdCBISVNUT1JZX0NPVU5UX0NVVE9GRiA9IDEwMDAgKiA2MCAqIDYwICogMjQ7IC8vIDI0aFxuY29uc3QgTlNfSU5fTVMgPSAxMDAwMDAwO1xuXG4vLyBXaGVuIGNoYW5naW5nIFJBVEVfUkFOR0VTLCBjaGVjayBpZiBQcm9tZXRoZXVzL1Byb21RTCByYW5nZXMgc2hvdWxkIGJlIGNoYW5nZWQgdG9vXG4vLyBAc2VlIHB1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcHJvbXFsLnRzXG5jb25zdCBSQVRFX1JBTkdFUzogQ29tcGxldGlvbkl0ZW1bXSA9IFtcbiAgeyBsYWJlbDogJyRfX2ludGVydmFsJywgc29ydFZhbHVlOiAnJF9faW50ZXJ2YWwnIH0sXG4gIHsgbGFiZWw6ICckX19yYW5nZScsIHNvcnRWYWx1ZTogJyRfX3JhbmdlJyB9LFxuICB7IGxhYmVsOiAnMW0nLCBzb3J0VmFsdWU6ICcwMDowMTowMCcgfSxcbiAgeyBsYWJlbDogJzVtJywgc29ydFZhbHVlOiAnMDA6MDU6MDAnIH0sXG4gIHsgbGFiZWw6ICcxMG0nLCBzb3J0VmFsdWU6ICcwMDoxMDowMCcgfSxcbiAgeyBsYWJlbDogJzMwbScsIHNvcnRWYWx1ZTogJzAwOjMwOjAwJyB9LFxuICB7IGxhYmVsOiAnMWgnLCBzb3J0VmFsdWU6ICcwMTowMDowMCcgfSxcbiAgeyBsYWJlbDogJzFkJywgc29ydFZhbHVlOiAnMjQ6MDA6MDAnIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgTEFCRUxfUkVGUkVTSF9JTlRFUlZBTCA9IDEwMDAgKiAzMDsgLy8gMzBzZWNcblxuY29uc3Qgd3JhcExhYmVsID0gKGxhYmVsOiBzdHJpbmcpID0+ICh7IGxhYmVsLCBmaWx0ZXJUZXh0OiBgXFxcIiR7bGFiZWx9XFxcImAgfSk7XG5cbmV4cG9ydCB0eXBlIExva2lIaXN0b3J5SXRlbSA9IEhpc3RvcnlJdGVtPExva2lRdWVyeT47XG5cbnR5cGUgVHlwZWFoZWFkQ29udGV4dCA9IHtcbiAgaGlzdG9yeT86IExva2lIaXN0b3J5SXRlbVtdO1xuICBhYnNvbHV0ZVJhbmdlPzogQWJzb2x1dGVUaW1lUmFuZ2U7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkSGlzdG9yeU1ldGFkYXRhKGl0ZW06IENvbXBsZXRpb25JdGVtLCBoaXN0b3J5OiBMb2tpSGlzdG9yeUl0ZW1bXSk6IENvbXBsZXRpb25JdGVtIHtcbiAgY29uc3QgY3V0b2ZmVHMgPSBEYXRlLm5vdygpIC0gSElTVE9SWV9DT1VOVF9DVVRPRkY7XG4gIGNvbnN0IGhpc3RvcnlGb3JJdGVtID0gaGlzdG9yeS5maWx0ZXIoKGgpID0+IGgudHMgPiBjdXRvZmZUcyAmJiBoLnF1ZXJ5LmV4cHIgPT09IGl0ZW0ubGFiZWwpO1xuICBsZXQgaGludCA9IGBRdWVyaWVkICR7aGlzdG9yeUZvckl0ZW0ubGVuZ3RofSB0aW1lcyBpbiB0aGUgbGFzdCAyNGguYDtcbiAgY29uc3QgcmVjZW50ID0gaGlzdG9yeUZvckl0ZW1bMF07XG5cbiAgaWYgKHJlY2VudCkge1xuICAgIGNvbnN0IGxhc3RRdWVyaWVkID0gZGF0ZVRpbWUocmVjZW50LnRzKS5mcm9tTm93KCk7XG4gICAgaGludCA9IGAke2hpbnR9IExhc3QgcXVlcmllZCAke2xhc3RRdWVyaWVkfS5gO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5pdGVtLFxuICAgIGRvY3VtZW50YXRpb246IGhpbnQsXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExva2lMYW5ndWFnZVByb3ZpZGVyIGV4dGVuZHMgTGFuZ3VhZ2VQcm92aWRlciB7XG4gIGxhYmVsS2V5czogc3RyaW5nW107XG4gIGxhYmVsRmV0Y2hUczogbnVtYmVyO1xuICBzdGFydGVkID0gZmFsc2U7XG4gIGRhdGFzb3VyY2U6IExva2lEYXRhc291cmNlO1xuICBsb29rdXBzRGlzYWJsZWQgPSBmYWxzZTsgLy8gRHluYW1pY2FsbHkgc2V0IHRvIHRydWUgZm9yIGJpZy9zbG93IGluc3RhbmNlc1xuXG4gIC8qKlxuICAgKiAgQ2FjaGUgZm9yIGxhYmVscyBvZiBzZXJpZXMuIFRoaXMgaXMgYml0IHNpbXBsaXN0aWMgaW4gdGhlIHNlbnNlIHRoYXQgaXQganVzdCBjb3VudHMgcmVzcG9uc2VzIGVhY2ggYXMgYSAxIGFuZCBkb2VzXG4gICAqICBub3QgYWNjb3VudCBmb3IgZGlmZmVyZW50IHNpemUgb2YgYSByZXNwb25zZS4gSWYgdGhhdCBpcyBuZWVkZWQgYSBgbGVuZ3RoYCBmdW5jdGlvbiBjYW4gYmUgYWRkZWQgaW4gdGhlIG9wdGlvbnMuXG4gICAqICAxMCBhcyBhIG1heCBzaXplIGlzIHRvdGFsbHkgYXJiaXRyYXJ5IHJpZ2h0IG5vdy5cbiAgICovXG4gIHByaXZhdGUgc2VyaWVzQ2FjaGUgPSBuZXcgTFJVPHN0cmluZywgUmVjb3JkPHN0cmluZywgc3RyaW5nW10+Pih7IG1heDogMTAgfSk7XG4gIHByaXZhdGUgbGFiZWxzQ2FjaGUgPSBuZXcgTFJVPHN0cmluZywgc3RyaW5nW10+KHsgbWF4OiAxMCB9KTtcblxuICBjb25zdHJ1Y3RvcihkYXRhc291cmNlOiBMb2tpRGF0YXNvdXJjZSwgaW5pdGlhbFZhbHVlcz86IGFueSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRhdGFzb3VyY2UgPSBkYXRhc291cmNlO1xuICAgIHRoaXMubGFiZWxLZXlzID0gW107XG4gICAgdGhpcy5sYWJlbEZldGNoVHMgPSAwO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbml0aWFsVmFsdWVzKTtcbiAgfVxuXG4gIC8vIFN0cmlwIHN5bnRheCBjaGFyc1xuICBjbGVhblRleHQgPSAoczogc3RyaW5nKSA9PiBzLnJlcGxhY2UoL1t7fVtcXF09XCIoKSwhfitcXC0qL14lXFx8XS9nLCAnJykudHJpbSgpO1xuXG4gIGdldFN5bnRheCgpOiBHcmFtbWFyIHtcbiAgICByZXR1cm4gc3ludGF4O1xuICB9XG5cbiAgcmVxdWVzdCA9IGFzeW5jICh1cmw6IHN0cmluZywgcGFyYW1zPzogYW55KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGF0YXNvdXJjZS5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXNlIHRoZSBsYW5ndWFnZSBwcm92aWRlciBieSBmZXRjaGluZyBzZXQgb2YgbGFiZWxzLiBXaXRob3V0IHRoaXMgaW5pdGlhbGlzYXRpb24gdGhlIHByb3ZpZGVyIHdvdWxkIHJldHVyblxuICAgKiBqdXN0IGEgc2V0IG9mIGhhcmRjb2RlZCBkZWZhdWx0IGxhYmVscyBvbiBwcm92aWRlQ29tcGxldGlvbkl0ZW1zIG9yIGEgcmVjZW50IHF1ZXJpZXMgZnJvbSBoaXN0b3J5LlxuICAgKi9cbiAgc3RhcnQgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0VGFzaykge1xuICAgICAgdGhpcy5zdGFydFRhc2sgPSB0aGlzLmZldGNoTGFiZWxzKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YXJ0VGFzaztcbiAgfTtcblxuICBnZXRMYWJlbEtleXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmxhYmVsS2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gc3VnZ2VzdGlvbnMgYmFzZWQgb24gaW5wdXQgdGhhdCBjYW4gYmUgdGhlbiBwbHVnZ2VkIGludG8gYSB0eXBlYWhlYWQgZHJvcGRvd24uXG4gICAqIEtlZXAgdGhpcyBET00tZnJlZSBmb3IgdGVzdGluZ1xuICAgKiBAcGFyYW0gaW5wdXRcbiAgICogQHBhcmFtIGNvbnRleHQgSXMgb3B0aW9uYWwgaW4gdHlwZXMgYnV0IGlzIHJlcXVpcmVkIGluIGNhc2Ugd2UgYXJlIGRvaW5nIGdldExhYmVsQ29tcGxldGlvbkl0ZW1zXG4gICAqIEBwYXJhbSBjb250ZXh0LmFic29sdXRlUmFuZ2UgUmVxdWlyZWQgaW4gY2FzZSB3ZSBhcmUgZG9pbmcgZ2V0TGFiZWxDb21wbGV0aW9uSXRlbXNcbiAgICogQHBhcmFtIGNvbnRleHQuaGlzdG9yeSBPcHRpb25hbCB1c2VkIG9ubHkgaW4gZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXNcbiAgICovXG4gIGFzeW5jIHByb3ZpZGVDb21wbGV0aW9uSXRlbXMoaW5wdXQ6IFR5cGVhaGVhZElucHV0LCBjb250ZXh0PzogVHlwZWFoZWFkQ29udGV4dCk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiB7XG4gICAgY29uc3QgeyB3cmFwcGVyQ2xhc3NlcywgdmFsdWUsIHByZWZpeCwgdGV4dCB9ID0gaW5wdXQ7XG4gICAgY29uc3QgZW1wdHlSZXN1bHQ6IFR5cGVhaGVhZE91dHB1dCA9IHsgc3VnZ2VzdGlvbnM6IFtdIH07XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gZW1wdHlSZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gTG9jYWwgdGV4dCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZW1wdHkgPSB2YWx1ZT8uZG9jdW1lbnQudGV4dC5sZW5ndGggPT09IDA7XG4gICAgY29uc3Qgc2VsZWN0ZWRMaW5lcyA9IHZhbHVlLmRvY3VtZW50LmdldFRleHRzQXRSYW5nZSh2YWx1ZS5zZWxlY3Rpb24pO1xuICAgIGNvbnN0IGN1cnJlbnRMaW5lID0gc2VsZWN0ZWRMaW5lcy5zaXplID09PSAxID8gc2VsZWN0ZWRMaW5lcy5maXJzdCgpLmdldFRleHQoKSA6IG51bGw7XG5cbiAgICBjb25zdCBuZXh0Q2hhcmFjdGVyID0gY3VycmVudExpbmUgPyBjdXJyZW50TGluZVt2YWx1ZS5zZWxlY3Rpb24uYW5jaG9yLm9mZnNldF0gOiBudWxsO1xuXG4gICAgLy8gU3ludGF4IHNwYW5zIGhhdmUgMyBjbGFzc2VzIGJ5IGRlZmF1bHQuIE1vcmUgaW5kaWNhdGUgYSByZWNvZ25pemVkIHRva2VuXG4gICAgY29uc3QgdG9rZW5SZWNvZ25pemVkID0gd3JhcHBlckNsYXNzZXMubGVuZ3RoID4gMztcblxuICAgIC8vIE5vbi1lbXB0eSBwcmVmaXgsIGJ1dCBub3QgaW5zaWRlIGtub3duIHRva2VuXG4gICAgY29uc3QgcHJlZml4VW5yZWNvZ25pemVkID0gcHJlZml4ICYmICF0b2tlblJlY29nbml6ZWQ7XG5cbiAgICAvLyBQcmV2ZW50IHN1Z2dlc3Rpb25zIGluIGBmdW5jdGlvbih8c3VmZml4KWBcbiAgICBjb25zdCBub1N1ZmZpeCA9ICFuZXh0Q2hhcmFjdGVyIHx8IG5leHRDaGFyYWN0ZXIgPT09ICcpJztcblxuICAgIC8vIFByZWZpeCBpcyBzYWZlIGlmIGl0IGRvZXMgbm90IGltbWVkaWF0ZWx5IGZvbGxvdyBhIGNvbXBsZXRlIGV4cHJlc3Npb24gYW5kIGhhcyBubyB0ZXh0IGFmdGVyIGl0XG4gICAgY29uc3Qgc2FmZVByZWZpeCA9IHByZWZpeCAmJiAhdGV4dC5tYXRjaCgvXlsnXCJ+PVxcXX0pXFxzXSskLykgJiYgbm9TdWZmaXg7XG5cbiAgICAvLyBBYm91dCB0byB0eXBlIG5leHQgb3BlcmFuZCBpZiBwcmVjZWRlZCBieSBiaW5hcnkgb3BlcmF0b3JcbiAgICBjb25zdCBvcGVyYXRvcnNQYXR0ZXJuID0gL1srXFwtKi9eJV0vO1xuICAgIGNvbnN0IGlzTmV4dE9wZXJhbmQgPSB0ZXh0Lm1hdGNoKG9wZXJhdG9yc1BhdHRlcm4pO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGNhbmRpZGF0ZXMgYnkgQ1NTIGNvbnRleHRcbiAgICBpZiAod3JhcHBlckNsYXNzZXMuaW5jbHVkZXMoJ2NvbnRleHQtcmFuZ2UnKSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIG1ldHJpY1t8XVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFuZ2VDb21wbGV0aW9uSXRlbXMoKTtcbiAgICB9IGVsc2UgaWYgKHdyYXBwZXJDbGFzc2VzLmluY2x1ZGVzKCdjb250ZXh0LWxhYmVscycpKSB7XG4gICAgICAvLyBTdWdnZXN0aW9ucyBmb3Ige3x9IGFuZCB7Zm9vPXx9XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRMYWJlbENvbXBsZXRpb25JdGVtcyhpbnB1dCk7XG4gICAgfSBlbHNlIGlmICh3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnY29udGV4dC1waXBlJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBpcGVDb21wbGV0aW9uSXRlbSgpO1xuICAgIH0gZWxzZSBpZiAoZW1wdHkpIHtcbiAgICAgIC8vIFN1Z2dlc3Rpb25zIGZvciBlbXB0eSBxdWVyeSBmaWVsZFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXMoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChwcmVmaXhVbnJlY29nbml6ZWQgJiYgbm9TdWZmaXggJiYgIWlzTmV4dE9wZXJhbmQpIHtcbiAgICAgIC8vIFNob3cgdGVybSBzdWdnZXN0aW9ucyBpbiBhIGNvdXBsZSBvZiBzY2VuYXJpb3NcbiAgICAgIHJldHVybiB0aGlzLmdldEJlZ2lubmluZ0NvbXBsZXRpb25JdGVtcyhjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeFVucmVjb2duaXplZCAmJiBzYWZlUHJlZml4KSB7XG4gICAgICAvLyBTaG93IHRlcm0gc3VnZ2VzdGlvbnMgaW4gYSBjb3VwbGUgb2Ygc2NlbmFyaW9zXG4gICAgICByZXR1cm4gdGhpcy5nZXRUZXJtQ29tcGxldGlvbkl0ZW1zKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVtcHR5UmVzdWx0O1xuICB9XG5cbiAgZ2V0QmVnaW5uaW5nQ29tcGxldGlvbkl0ZW1zID0gKGNvbnRleHQ/OiBUeXBlYWhlYWRDb250ZXh0KTogVHlwZWFoZWFkT3V0cHV0ID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VnZ2VzdGlvbnM6IFsuLi50aGlzLmdldEVtcHR5Q29tcGxldGlvbkl0ZW1zKGNvbnRleHQpLnN1Z2dlc3Rpb25zLCAuLi50aGlzLmdldFRlcm1Db21wbGV0aW9uSXRlbXMoKS5zdWdnZXN0aW9uc10sXG4gICAgfTtcbiAgfTtcblxuICBnZXRFbXB0eUNvbXBsZXRpb25JdGVtcyhjb250ZXh0PzogVHlwZWFoZWFkQ29udGV4dCk6IFR5cGVhaGVhZE91dHB1dCB7XG4gICAgY29uc3QgaGlzdG9yeSA9IGNvbnRleHQ/Lmhpc3Rvcnk7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnMgPSBbXTtcblxuICAgIGlmIChoaXN0b3J5Py5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlJdGVtcyA9IGNoYWluKGhpc3RvcnkpXG4gICAgICAgIC5tYXAoKGgpID0+IGgucXVlcnkuZXhwcilcbiAgICAgICAgLmZpbHRlcigpXG4gICAgICAgIC51bmlxKClcbiAgICAgICAgLnRha2UoSElTVE9SWV9JVEVNX0NPVU5UKVxuICAgICAgICAubWFwKHdyYXBMYWJlbClcbiAgICAgICAgLm1hcCgoaXRlbSkgPT4gYWRkSGlzdG9yeU1ldGFkYXRhKGl0ZW0sIGhpc3RvcnkpKVxuICAgICAgICAudmFsdWUoKTtcblxuICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgIHByZWZpeE1hdGNoOiB0cnVlLFxuICAgICAgICBza2lwU29ydDogdHJ1ZSxcbiAgICAgICAgbGFiZWw6ICdIaXN0b3J5JyxcbiAgICAgICAgaXRlbXM6IGhpc3RvcnlJdGVtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zIH07XG4gIH1cblxuICBnZXRUZXJtQ29tcGxldGlvbkl0ZW1zID0gKCk6IFR5cGVhaGVhZE91dHB1dCA9PiB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnMgPSBbXTtcblxuICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgcHJlZml4TWF0Y2g6IHRydWUsXG4gICAgICBsYWJlbDogJ0Z1bmN0aW9ucycsXG4gICAgICBpdGVtczogRlVOQ1RJT05TLm1hcCgoc3VnZ2VzdGlvbikgPT4gKHsgLi4uc3VnZ2VzdGlvbiwga2luZDogJ2Z1bmN0aW9uJyB9KSksXG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBzdWdnZXN0aW9ucyB9O1xuICB9O1xuXG4gIGdldFBpcGVDb21wbGV0aW9uSXRlbSA9ICgpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gW107XG5cbiAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgIGxhYmVsOiAnT3BlcmF0b3JzJyxcbiAgICAgIGl0ZW1zOiBQSVBFX09QRVJBVE9SUy5tYXAoKHN1Z2dlc3Rpb24pID0+ICh7IC4uLnN1Z2dlc3Rpb24sIGtpbmQ6ICdvcGVyYXRvcnMnIH0pKSxcbiAgICB9KTtcblxuICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgbGFiZWw6ICdQYXJzZXJzJyxcbiAgICAgIGl0ZW1zOiBQSVBFX1BBUlNFUlMubWFwKChzdWdnZXN0aW9uKSA9PiAoeyAuLi5zdWdnZXN0aW9uLCBraW5kOiAncGFyc2VycycgfSkpLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgfTtcblxuICBnZXRSYW5nZUNvbXBsZXRpb25JdGVtcygpOiBUeXBlYWhlYWRPdXRwdXQge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0OiAnY29udGV4dC1yYW5nZScsXG4gICAgICBzdWdnZXN0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6ICdSYW5nZSB2ZWN0b3InLFxuICAgICAgICAgIGl0ZW1zOiBbLi4uUkFURV9SQU5HRVNdLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgZ2V0TGFiZWxDb21wbGV0aW9uSXRlbXMoeyB0ZXh0LCB3cmFwcGVyQ2xhc3NlcywgbGFiZWxLZXksIHZhbHVlIH06IFR5cGVhaGVhZElucHV0KTogUHJvbWlzZTxUeXBlYWhlYWRPdXRwdXQ+IHtcbiAgICBsZXQgY29udGV4dCA9ICdjb250ZXh0LWxhYmVscyc7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IENvbXBsZXRpb25JdGVtR3JvdXBbXSA9IFtdO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGNvbnRleHQsIHN1Z2dlc3Rpb25zOiBbXSB9O1xuICAgIH1cbiAgICBjb25zdCBsaW5lID0gdmFsdWUuYW5jaG9yQmxvY2suZ2V0VGV4dCgpO1xuICAgIGNvbnN0IGN1cnNvck9mZnNldCA9IHZhbHVlLnNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICAgIGNvbnN0IGlzVmFsdWVTdGFydCA9IHRleHQubWF0Y2goL14oPXw9fnwhPXwhfikvKTtcblxuICAgIC8vIEdldCBub3JtYWxpemVkIHNlbGVjdG9yXG4gICAgbGV0IHNlbGVjdG9yO1xuICAgIGxldCBwYXJzZWRTZWxlY3RvcjtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkU2VsZWN0b3IgPSBwYXJzZVNlbGVjdG9yKGxpbmUsIGN1cnNvck9mZnNldCk7XG4gICAgICBzZWxlY3RvciA9IHBhcnNlZFNlbGVjdG9yLnNlbGVjdG9yO1xuICAgIH0gY2F0Y2gge1xuICAgICAgc2VsZWN0b3IgPSBFTVBUWV9TRUxFQ1RPUjtcbiAgICB9XG5cbiAgICBpZiAoIWxhYmVsS2V5ICYmIHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUikge1xuICAgICAgLy8gc3RhcnQgdGFzayBnZXRzIGFsbCBsYWJlbHNcbiAgICAgIGF3YWl0IHRoaXMuc3RhcnQoKTtcbiAgICAgIGNvbnN0IGFsbExhYmVscyA9IHRoaXMuZ2V0TGFiZWxLZXlzKCk7XG4gICAgICByZXR1cm4geyBjb250ZXh0LCBzdWdnZXN0aW9uczogW3sgbGFiZWw6IGBMYWJlbHNgLCBpdGVtczogYWxsTGFiZWxzLm1hcCh3cmFwTGFiZWwpIH1dIH07XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdLZXlzID0gcGFyc2VkU2VsZWN0b3IgPyBwYXJzZWRTZWxlY3Rvci5sYWJlbEtleXMgOiBbXTtcblxuICAgIGxldCBsYWJlbFZhbHVlcztcbiAgICAvLyBRdWVyeSBsYWJlbHMgZm9yIHNlbGVjdG9yXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IEVNUFRZX1NFTEVDVE9SICYmIGxhYmVsS2V5KSB7XG4gICAgICAgIGNvbnN0IGxhYmVsVmFsdWVzRm9yS2V5ID0gYXdhaXQgdGhpcy5nZXRMYWJlbFZhbHVlcyhsYWJlbEtleSk7XG4gICAgICAgIGxhYmVsVmFsdWVzID0geyBbbGFiZWxLZXldOiBsYWJlbFZhbHVlc0ZvcktleSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxWYWx1ZXMgPSBhd2FpdCB0aGlzLmdldFNlcmllc0xhYmVscyhzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFsYWJlbFZhbHVlcykge1xuICAgICAgY29uc29sZS53YXJuKGBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gYW55IHZhbHVlcyBmb3Igc2VsZWN0b3IgPSAke3NlbGVjdG9yfWApO1xuICAgICAgcmV0dXJuIHsgY29udGV4dCwgc3VnZ2VzdGlvbnMgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRleHQgJiYgaXNWYWx1ZVN0YXJ0KSB8fCB3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnYXR0ci12YWx1ZScpKSB7XG4gICAgICAvLyBMYWJlbCB2YWx1ZXNcbiAgICAgIGlmIChsYWJlbEtleSAmJiBsYWJlbFZhbHVlc1tsYWJlbEtleV0pIHtcbiAgICAgICAgY29udGV4dCA9ICdjb250ZXh0LWxhYmVsLXZhbHVlcyc7XG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgIGxhYmVsOiBgTGFiZWwgdmFsdWVzIGZvciBcIiR7bGFiZWxLZXl9XCJgLFxuICAgICAgICAgIC8vIEZpbHRlciB0byBwcmV2ZW50IHByZXZpb3VzbHkgc2VsZWN0ZWQgdmFsdWVzIGZyb20gYmVpbmcgcmVwZWF0ZWRseSBzdWdnZXN0ZWRcbiAgICAgICAgICBpdGVtczogbGFiZWxWYWx1ZXNbbGFiZWxLZXldLm1hcCh3cmFwTGFiZWwpLmZpbHRlcigoeyBmaWx0ZXJUZXh0IH0pID0+IGZpbHRlclRleHQgIT09IHRleHQpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGFiZWwga2V5c1xuICAgICAgY29uc3QgbGFiZWxLZXlzID0gbGFiZWxWYWx1ZXMgPyBPYmplY3Qua2V5cyhsYWJlbFZhbHVlcykgOiBERUZBVUxUX0tFWVM7XG4gICAgICBpZiAobGFiZWxLZXlzKSB7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlS2V5cyA9IGRpZmZlcmVuY2UobGFiZWxLZXlzLCBleGlzdGluZ0tleXMpO1xuICAgICAgICBpZiAocG9zc2libGVLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IG5ld0l0ZW1zID0gcG9zc2libGVLZXlzLm1hcCgoa2V5KSA9PiAoeyBsYWJlbDoga2V5IH0pKTtcbiAgICAgICAgICBjb25zdCBuZXdTdWdnZXN0aW9uOiBDb21wbGV0aW9uSXRlbUdyb3VwID0geyBsYWJlbDogYExhYmVsc2AsIGl0ZW1zOiBuZXdJdGVtcyB9O1xuICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2gobmV3U3VnZ2VzdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBjb250ZXh0LCBzdWdnZXN0aW9ucyB9O1xuICB9XG5cbiAgaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkobGFiZWxCYXNlZFF1ZXJ5OiBBYnN0cmFjdFF1ZXJ5KTogTG9raVF1ZXJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmSWQ6IGxhYmVsQmFzZWRRdWVyeS5yZWZJZCxcbiAgICAgIGV4cHI6IHRvUHJvbUxpa2VFeHByKGxhYmVsQmFzZWRRdWVyeSksXG4gICAgICBxdWVyeVR5cGU6IExva2lRdWVyeVR5cGUuUmFuZ2UsXG4gICAgfTtcbiAgfVxuXG4gIGV4cG9ydFRvQWJzdHJhY3RRdWVyeShxdWVyeTogTG9raVF1ZXJ5KTogQWJzdHJhY3RRdWVyeSB7XG4gICAgY29uc3QgbG9raVF1ZXJ5ID0gcXVlcnkuZXhwcjtcbiAgICBpZiAoIWxva2lRdWVyeSB8fCBsb2tpUXVlcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4geyByZWZJZDogcXVlcnkucmVmSWQsIGxhYmVsTWF0Y2hlcnM6IFtdIH07XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IFByaXNtLnRva2VuaXplKGxva2lRdWVyeSwgc3ludGF4KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmSWQ6IHF1ZXJ5LnJlZklkLFxuICAgICAgbGFiZWxNYXRjaGVyczogZXh0cmFjdExhYmVsTWF0Y2hlcnModG9rZW5zKSxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgZ2V0U2VyaWVzTGFiZWxzKHNlbGVjdG9yOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5sb29rdXBzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaFNlcmllc0xhYmVscyhzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFRPRE86IGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGFsbCBsYWJlbCBrZXlzXG4gICAqL1xuICBhc3luYyBmZXRjaExhYmVscygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgdXJsID0gJ2xhYmVscyc7XG4gICAgY29uc3QgdGltZVJhbmdlID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIHRoaXMubGFiZWxGZXRjaFRzID0gRGF0ZS5ub3coKS52YWx1ZU9mKCk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcXVlc3QodXJsLCB0aW1lUmFuZ2UpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHJlc1xuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5maWx0ZXIoKGxhYmVsKSA9PiBsYWJlbCAhPT0gJ19fbmFtZV9fJyk7XG4gICAgICB0aGlzLmxhYmVsS2V5cyA9IGxhYmVscztcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBhc3luYyByZWZyZXNoTG9nTGFiZWxzKGZvcmNlUmVmcmVzaD86IGJvb2xlYW4pIHtcbiAgICBpZiAoKHRoaXMubGFiZWxLZXlzICYmIERhdGUubm93KCkudmFsdWVPZigpIC0gdGhpcy5sYWJlbEZldGNoVHMgPiBMQUJFTF9SRUZSRVNIX0lOVEVSVkFMKSB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICAgIGF3YWl0IHRoaXMuZmV0Y2hMYWJlbHMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGFiZWxzIGZvciBhIHNlbGVjdG9yLiBUaGlzIGlzIGNhY2hlZCBieSBpdCdzIGFyZ3MgYnV0IGFsc28gYnkgdGhlIGdsb2JhbCB0aW1lUmFuZ2UgY3VycmVudGx5IHNlbGVjdGVkIGFzXG4gICAqIHRoZXkgY2FuIGNoYW5nZSBvdmVyIHJlcXVlc3RlZCB0aW1lLlxuICAgKiBAcGFyYW0gbmFtZVxuICAgKi9cbiAgZmV0Y2hTZXJpZXNMYWJlbHMgPSBhc3luYyAobWF0Y2g6IHN0cmluZyk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nW10+PiA9PiB7XG4gICAgY29uc3QgaW50ZXJwb2xhdGVkTWF0Y2ggPSB0aGlzLmRhdGFzb3VyY2UuaW50ZXJwb2xhdGVTdHJpbmcobWF0Y2gpO1xuICAgIGNvbnN0IHVybCA9ICdzZXJpZXMnO1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdlbmVyYXRlQ2FjaGVLZXkodXJsLCBzdGFydCwgZW5kLCBpbnRlcnBvbGF0ZWRNYXRjaCk7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5zZXJpZXNDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIC8vIENsZWFyIHZhbHVlIHdoZW4gcmVxdWVzdGluZyBuZXcgb25lLiBFbXB0eSBvYmplY3QgYmVpbmcgdHJ1dGh5IGFsc28gbWFrZXMgc3VyZSB3ZSBkb24ndCByZXF1ZXN0IHR3aWNlLlxuICAgICAgdGhpcy5zZXJpZXNDYWNoZS5zZXQoY2FjaGVLZXksIHt9KTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHsgJ21hdGNoW10nOiBpbnRlcnBvbGF0ZWRNYXRjaCwgc3RhcnQsIGVuZCB9O1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIHBhcmFtcyk7XG4gICAgICBjb25zdCB7IHZhbHVlcyB9ID0gcHJvY2Vzc0xhYmVscyhkYXRhKTtcbiAgICAgIHZhbHVlID0gdmFsdWVzO1xuICAgICAgdGhpcy5zZXJpZXNDYWNoZS5zZXQoY2FjaGVLZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGZXRjaCBzZXJpZXMgZm9yIGEgc2VsZWN0b3IuIFVzZSB0aGlzIGZvciByYXcgcmVzdWx0cy4gVXNlIGZldGNoU2VyaWVzTGFiZWxzKCkgdG8gZ2V0IGxhYmVscy5cbiAgICogQHBhcmFtIG1hdGNoXG4gICAqL1xuICBmZXRjaFNlcmllcyA9IGFzeW5jIChtYXRjaDogc3RyaW5nKTogUHJvbWlzZTxBcnJheTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+Pj4gPT4ge1xuICAgIGNvbnN0IHVybCA9ICdzZXJpZXMnO1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgJ21hdGNoW10nOiBtYXRjaCwgc3RhcnQsIGVuZCB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3QodXJsLCBwYXJhbXMpO1xuICB9O1xuXG4gIC8vIENhY2hlIGtleSBpcyBhIGJpdCBkaWZmZXJlbnQgaGVyZS4gV2Ugcm91bmQgdXAgdG8gYSBtaW51dGUgdGhlIGludGVydmFscy5cbiAgLy8gVGhlIHJvdW5kaW5nIG1heSBzZWVtIHN0cmFuZ2UgYnV0IG1ha2VzIHJlbGF0aXZlIGludGVydmFscyBsaWtlIG5vdy0xaCBsZXNzIHByb25lIHRvIG5lZWQgc2VwYXJhdGUgcmVxdWVzdCBldmVyeVxuICAvLyBtaWxsaXNlY29uZCB3aGlsZSBzdGlsbCBhY3R1YWxseSBnZXR0aW5nIGFsbCB0aGUga2V5cyBmb3IgdGhlIGNvcnJlY3QgaW50ZXJ2YWwuIFRoaXMgc3RpbGwgY2FuIGNyZWF0ZSBwcm9ibGVtc1xuICAvLyB3aGVuIHVzZXIgZG9lcyBub3QgdGhlIG5ld2VzdCB2YWx1ZXMgZm9yIGEgbWludXRlIGlmIGFscmVhZHkgY2FjaGVkLlxuICBnZW5lcmF0ZUNhY2hlS2V5KHVybDogc3RyaW5nLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgcGFyYW06IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFt1cmwsIHRoaXMucm91bmRUaW1lKHN0YXJ0KSwgdGhpcy5yb3VuZFRpbWUoZW5kKSwgcGFyYW1dLmpvaW4oKTtcbiAgfVxuXG4gIC8vIFJvdW5kIG5hbm9zIGVwb2NoIHRvIG5lYXJlc3QgNSBtaW51dGUgaW50ZXJ2YWxcbiAgcm91bmRUaW1lKG5hbm9zOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBuYW5vcyA/IE1hdGguZmxvb3IobmFub3MgLyBOU19JTl9NUyAvIDEwMDAgLyA2MCAvIDUpIDogMDtcbiAgfVxuXG4gIGFzeW5jIGdldExhYmVsVmFsdWVzKGtleTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoTGFiZWxWYWx1ZXMoa2V5KTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoTGFiZWxWYWx1ZXMoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgaW50ZXJwb2xhdGVkS2V5ID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuZGF0YXNvdXJjZS5pbnRlcnBvbGF0ZVN0cmluZyhrZXkpKTtcblxuICAgIGNvbnN0IHVybCA9IGBsYWJlbC8ke2ludGVycG9sYXRlZEtleX0vdmFsdWVzYDtcbiAgICBjb25zdCByYW5nZVBhcmFtcyA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlUGFyYW1zO1xuXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdlbmVyYXRlQ2FjaGVLZXkodXJsLCBzdGFydCwgZW5kLCBpbnRlcnBvbGF0ZWRLZXkpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgc3RhcnQsIGVuZCB9O1xuXG4gICAgbGV0IGxhYmVsVmFsdWVzID0gdGhpcy5sYWJlbHNDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghbGFiZWxWYWx1ZXMpIHtcbiAgICAgIC8vIENsZWFyIHZhbHVlIHdoZW4gcmVxdWVzdGluZyBuZXcgb25lLiBFbXB0eSBvYmplY3QgYmVpbmcgdHJ1dGh5IGFsc28gbWFrZXMgc3VyZSB3ZSBkb24ndCByZXF1ZXN0IHR3aWNlLlxuICAgICAgdGhpcy5sYWJlbHNDYWNoZS5zZXQoY2FjaGVLZXksIFtdKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIHBhcmFtcyk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKSB7XG4gICAgICAgIGxhYmVsVmFsdWVzID0gcmVzLnNsaWNlKCkuc29ydCgpO1xuICAgICAgICB0aGlzLmxhYmVsc0NhY2hlLnNldChjYWNoZUtleSwgbGFiZWxWYWx1ZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbFZhbHVlcyA/PyBbXTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgVGltZVJhbmdlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmZ1bmN0aW9uIHJvdW5kTXNUb01pbihtaWxsaXNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiByb3VuZFNlY1RvTWluKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xufVxuXG5mdW5jdGlvbiByb3VuZFNlY1RvTWluKHNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRSZWZyZXNoTGFiZWxzKHJhbmdlPzogVGltZVJhbmdlLCBwcmV2UmFuZ2U/OiBUaW1lUmFuZ2UpOiBib29sZWFuIHtcbiAgaWYgKHJhbmdlICYmIHByZXZSYW5nZSkge1xuICAgIGNvbnN0IHNhbWVNaW51dGVGcm9tID0gcm91bmRNc1RvTWluKHJhbmdlLmZyb20udmFsdWVPZigpKSA9PT0gcm91bmRNc1RvTWluKHByZXZSYW5nZS5mcm9tLnZhbHVlT2YoKSk7XG4gICAgY29uc3Qgc2FtZU1pbnV0ZVRvID0gcm91bmRNc1RvTWluKHJhbmdlLnRvLnZhbHVlT2YoKSkgPT09IHJvdW5kTXNUb01pbihwcmV2UmFuZ2UudG8udmFsdWVPZigpKTtcbiAgICAvLyBJZiBib3RoIGFyZSBzYW1lLCBkb24ndCBuZWVkIHRvIHJlZnJlc2hcbiAgICByZXR1cm4gIShzYW1lTWludXRlRnJvbSAmJiBzYW1lTWludXRlVG8pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gTG9raSByZWd1bGFyLWV4cHJlc3Npb25zIHVzZSB0aGUgUkUyIHN5bnRheCAoaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9yZTIvd2lraS9TeW50YXgpLFxuLy8gc28gZXZlcnkgY2hhcmFjdGVyIHRoYXQgbWF0Y2hlcyBzb21ldGhpbmcgaW4gdGhhdCBsaXN0IGhhcyB0byBiZSBlc2NhcGVkLlxuLy8gdGhlIGxpc3Qgb2YgbWV0YSBjaGFyYWN0ZXJzIGlzOiAqKz8oKXxcXC5bXXt9XiRcbi8vIHdlIG1ha2UgYSBqYXZhc2NyaXB0IHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgdGhvc2UgY2hhcmFjdGVyczpcbmNvbnN0IFJFMl9NRVRBQ0hBUkFDVEVSUyA9IC9bKis/KCl8XFxcXC5cXFtcXF17fV4kXS9nO1xuZnVuY3Rpb24gZXNjYXBlTG9raVJlZ2V4cCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoUkUyX01FVEFDSEFSQUNURVJTLCAnXFxcXCQmJyk7XG59XG5cbi8vIGJhc2VkIG9uIHRoZSBvcGVubWV0cmljcy1kb2N1bWVudGF0aW9uLCB0aGUgMyBzeW1ib2xzIHdlIGhhdmUgdG8gaGFuZGxlIGFyZTpcbi8vIC0gXFxuIC4uLiB0aGUgbmV3bGluZSBjaGFyYWN0ZXJcbi8vIC0gXFwgIC4uLiB0aGUgYmFja3NsYXNoIGNoYXJhY3RlclxuLy8gLSBcIiAgLi4uIHRoZSBkb3VibGUtcXVvdGUgY2hhcmFjdGVyXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3RvcihsYWJlbFZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gbGFiZWxWYWx1ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVMYWJlbFZhbHVlSW5SZWdleFNlbGVjdG9yKGxhYmVsVmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBlc2NhcGVMYWJlbFZhbHVlSW5FeGFjdFNlbGVjdG9yKGVzY2FwZUxva2lSZWdleHAobGFiZWxWYWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlTGFiZWxWYWx1ZUluU2VsZWN0b3IobGFiZWxWYWx1ZTogc3RyaW5nLCBzZWxlY3Rvcj86IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBpc1JlZ2V4U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgPyBlc2NhcGVMYWJlbFZhbHVlSW5SZWdleFNlbGVjdG9yKGxhYmVsVmFsdWUpXG4gICAgOiBlc2NhcGVMYWJlbFZhbHVlSW5FeGFjdFNlbGVjdG9yKGxhYmVsVmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWdleFNlbGVjdG9yKHNlbGVjdG9yPzogc3RyaW5nKSB7XG4gIGlmIChzZWxlY3RvciAmJiAoc2VsZWN0b3IuaW5jbHVkZXMoJz1+JykgfHwgc2VsZWN0b3IuaW5jbHVkZXMoJyF+JykpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgdGhyb3dFcnJvciwgdGltZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbmFsaXplLCBtYXAsIHJldHJ5V2hlbiwgbWVyZ2VNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyB3ZWJTb2NrZXQgfSBmcm9tICdyeGpzL3dlYlNvY2tldCc7XG5cbmltcG9ydCB7IERhdGFGcmFtZSwgRmllbGRUeXBlLCBwYXJzZUxhYmVscywgS2V5VmFsdWUsIENpcmN1bGFyRGF0YUZyYW1lIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IGFwcGVuZFJlc3BvbnNlVG9CdWZmZXJlZERhdGEgfSBmcm9tICcuL2xpdmVfc3RyZWFtc19yZXN1bHRfdHJhbnNmb3JtZXInO1xuaW1wb3J0IHsgTG9raVRhaWxSZXNwb25zZSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIE1hcHMgZGlyZWN0bHkgdG8gYSBxdWVyeSBpbiB0aGUgVUkgKHJlZklkIGlzIGtleSlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2tpTGl2ZVRhcmdldCB7XG4gIHF1ZXJ5OiBzdHJpbmc7XG4gIHVybDogc3RyaW5nO1xuICByZWZJZDogc3RyaW5nO1xuICBzaXplOiBudW1iZXI7XG59XG5cbi8qKlxuICogQ2FjaGUgb2Ygd2Vic29ja2V0IHN0cmVhbXMgdGhhdCBjYW4gYmUgcmV0dXJuZWQgYXMgb2JzZXJ2YWJsZS4gSW4gY2FzZSB0aGVyZSBhbHJlYWR5IGlzIGEgc3RyZWFtIGZvciBwYXJ0aWN1bGFyXG4gKiB0YXJnZXQgaXQgaXMgcmV0dXJuZWQgYW5kIG9uIHN1YnNjcmlwdGlvbiByZXR1cm5zIHRoZSBsYXRlc3QgZGF0YUZyYW1lLlxuICovXG5leHBvcnQgY2xhc3MgTGl2ZVN0cmVhbXMge1xuICBwcml2YXRlIHN0cmVhbXM6IEtleVZhbHVlPE9ic2VydmFibGU8RGF0YUZyYW1lW10+PiA9IHt9O1xuXG4gIGdldFN0cmVhbSh0YXJnZXQ6IExva2lMaXZlVGFyZ2V0LCByZXRyeUludGVydmFsID0gNTAwMCk6IE9ic2VydmFibGU8RGF0YUZyYW1lW10+IHtcbiAgICBsZXQgc3RyZWFtID0gdGhpcy5zdHJlYW1zW3RhcmdldC51cmxdO1xuXG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gbmV3IENpcmN1bGFyRGF0YUZyYW1lKHsgY2FwYWNpdHk6IHRhcmdldC5zaXplIH0pO1xuICAgIGRhdGEuYWRkRmllbGQoeyBuYW1lOiAnbGFiZWxzJywgdHlwZTogRmllbGRUeXBlLm90aGVyIH0pOyAvLyBUaGUgbGFiZWxzIGZvciBlYWNoIGxpbmVcbiAgICBkYXRhLmFkZEZpZWxkKHsgbmFtZTogJ1RpbWUnLCB0eXBlOiBGaWVsZFR5cGUudGltZSwgY29uZmlnOiB7fSB9KTtcbiAgICBkYXRhLmFkZEZpZWxkKHsgbmFtZTogJ0xpbmUnLCB0eXBlOiBGaWVsZFR5cGUuc3RyaW5nIH0pLmxhYmVscyA9IHBhcnNlTGFiZWxzKHRhcmdldC5xdWVyeSk7XG4gICAgZGF0YS5hZGRGaWVsZCh7IG5hbWU6ICdpZCcsIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcgfSk7XG4gICAgZGF0YS5hZGRGaWVsZCh7IG5hbWU6ICd0c05zJywgdHlwZTogRmllbGRUeXBlLnRpbWUsIGNvbmZpZzoge30gfSk7XG4gICAgZGF0YS5tZXRhID0geyAuLi5kYXRhLm1ldGEsIHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAnbG9ncycgfTtcbiAgICBkYXRhLnJlZklkID0gdGFyZ2V0LnJlZklkO1xuXG4gICAgc3RyZWFtID0gd2ViU29ja2V0PExva2lUYWlsUmVzcG9uc2U+KHRhcmdldC51cmwpLnBpcGUoXG4gICAgICBtYXAoKHJlc3BvbnNlOiBMb2tpVGFpbFJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGFwcGVuZFJlc3BvbnNlVG9CdWZmZXJlZERhdGEocmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICByZXR1cm4gW2RhdGFdO1xuICAgICAgfSksXG4gICAgICByZXRyeVdoZW4oKGF0dGVtcHRzOiBPYnNlcnZhYmxlPGFueT4pID0+XG4gICAgICAgIGF0dGVtcHRzLnBpcGUoXG4gICAgICAgICAgbWVyZ2VNYXAoKGVycm9yLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXRyeUF0dGVtcHQgPSBpICsgMTtcbiAgICAgICAgICAgIC8vIENvZGUgMTAwNiBpcyB1c2VkIHRvIGluZGljYXRlIHRoYXQgYSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYWJub3JtYWxseS5cbiAgICAgICAgICAgIC8vIEFkZGVkIGhhcmQgbGltaXQgb2YgMzAgb24gbnVtYmVyIG9mIHJldHJpZXMuXG4gICAgICAgICAgICAvLyBJZiBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYWJub3JtYWxseSwgYW5kIHdlIHdpc2ggdG8gcmV0cnksIG90aGVyd2lzZSB0aHJvdyBlcnJvci5cbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSAxMDA2ICYmIHJldHJ5QXR0ZW1wdCA8IDMwKSB7XG4gICAgICAgICAgICAgIGlmIChyZXRyeUF0dGVtcHQgPiAxMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIG1vcmUgdGhhbiAxMCB0aW1lcyByZXRyaWVkLCBjb25zb2wud2FybiwgYnV0IGtlZXAgcmVjb25uZWN0aW5nXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgYFdlYnNvY2tldCBjb25uZWN0aW9uIGlzIGJlaW5nIGRpc3J1cHRlZC4gV2Uga2VlcCByZWNvbm5lY3RpbmcgYnV0IGNvbnNpZGVyIHN0YXJ0aW5nIG5ldyBsaXZlIHRhaWxpbmcgYWdhaW4uIEVycm9yOiAke2Vycm9yLnJlYXNvbn1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBSZXRyeSBldmVyeSA1c1xuICAgICAgICAgICAgICByZXR1cm4gdGltZXIocmV0cnlJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvcik7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGZpbmFsaXplKCgpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtc1t0YXJnZXQudXJsXTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN0cmVhbXNbdGFyZ2V0LnVybF0gPSBzdHJlYW07XG5cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG59XG4iLCJpbXBvcnQgeyB2NSBhcyB1dWlkdjUgfSBmcm9tICd1dWlkJztcblxuaW1wb3J0IHsgRmllbGRUeXBlLCBMYWJlbHMsIE11dGFibGVEYXRhRnJhbWUsIGZpbmRVbmlxdWVMYWJlbHMgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgTG9raVN0cmVhbVJlc3VsdCwgTG9raVRhaWxSZXNwb25zZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBVVUlEX05BTUVTUEFDRSA9ICc2ZWM5NDZkYS0wZjQ5LTQ3YTgtOTgzYS0xZDc2ZDE3ZTdjOTInO1xuXG4vKipcbiAqIFRyYW5zZm9ybSBMb2tpUmVzcG9uc2UgZGF0YSBhbmQgYXBwZW5kcyBpdCB0byBNdXRhYmxlRGF0YUZyYW1lLiBVc2VkIGZvciBzdHJlYW1pbmcgd2hlcmUgdGhlIGRhdGFGcmFtZSBjYW4gYmVcbiAqIGEgQ2lyY3VsYXJEYXRhRnJhbWUgY3JlYXRpbmcgYSBmaXhlZCBzaXplIHJvbGxpbmcgYnVmZmVyLlxuICogVE9ETzogUHJvYmFibHkgY291bGQgYmUgdW5pZmllZCB3aXRoIHRoZSBsb2dTdHJlYW1Ub0RhdGFGcmFtZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSByZXNwb25zZVxuICogQHBhcmFtIGRhdGEgTmVlZHMgdG8gaGF2ZSB0cywgbGluZSwgbGFiZWxzLCBpZCBhcyBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZFJlc3BvbnNlVG9CdWZmZXJlZERhdGEocmVzcG9uc2U6IExva2lUYWlsUmVzcG9uc2UsIGRhdGE6IE11dGFibGVEYXRhRnJhbWUpIHtcbiAgLy8gU2hvdWxkIHdlIGRvIGFueXRoaW5nIHdpdGg6IHJlc3BvbnNlLmRyb3BwZWRfZW50cmllcz9cblxuICBjb25zdCBzdHJlYW1zOiBMb2tpU3RyZWFtUmVzdWx0W10gPSByZXNwb25zZS5zdHJlYW1zO1xuICBpZiAoIXN0cmVhbXMgfHwgIXN0cmVhbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGJhc2VMYWJlbHM6IExhYmVscyA9IHt9O1xuICBmb3IgKGNvbnN0IGYgb2YgZGF0YS5maWVsZHMpIHtcbiAgICBpZiAoZi50eXBlID09PSBGaWVsZFR5cGUuc3RyaW5nKSB7XG4gICAgICBpZiAoZi5sYWJlbHMpIHtcbiAgICAgICAgYmFzZUxhYmVscyA9IGYubGFiZWxzO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbGFiZWxzRmllbGQgPSBkYXRhLmZpZWxkc1swXTtcbiAgY29uc3QgdHNGaWVsZCA9IGRhdGEuZmllbGRzWzFdO1xuICBjb25zdCBsaW5lRmllbGQgPSBkYXRhLmZpZWxkc1syXTtcbiAgY29uc3QgaWRGaWVsZCA9IGRhdGEuZmllbGRzWzNdO1xuICBjb25zdCB0c05zRmllbGQgPSBkYXRhLmZpZWxkc1s0XTtcblxuICAvLyBXZSBhcmUgY29tcGFyaW5nIHVzZWQgaWRzIG9ubHkgd2l0aGluIHRoZSByZWNlaXZlZCBzdHJlYW0uIFRoaXMgY291bGQgYmUgYSBwcm9ibGVtIGlmIHRoZSBzYW1lIGxpbmUgKyBsYWJlbHMgKyBuYW5vc2Vjb25kIHRpbWVzdGFtcCBjYW1lIGluIDIgc2VwYXJhdGUgYmF0Y2hlcy5cbiAgLy8gQXMgdGhpcyBpcyB2ZXJ5IHVubGlrZWx5LCBhbmQgdGhlIHJlc3VsdCB3b3VsZCBvbmx5IGFmZmVjdCBsaXZlLXRhaWxpbmcgY3NzIGFuaW1hdGlvbiB3ZSBoYXZlIGRlY2lkZWQgdG8gbm90IGNvbXBhcmUgYWxsIHJlY2VpdmVkIHVpZHMgZnJvbSBkYXRhIHBhcmFtIGFzIHRoaXMgd291bGQgc2xvdyBkb3duIHByb2Nlc3NpbmcuXG4gIGNvbnN0IHVzZWRVaWRzOiB7IHN0cmluZz86IG51bWJlciB9ID0ge307XG5cbiAgZm9yIChjb25zdCBzdHJlYW0gb2Ygc3RyZWFtcykge1xuICAgIC8vIEZpbmQgdW5pcXVlIGxhYmVsc1xuICAgIGNvbnN0IHVuaXF1ZSA9IGZpbmRVbmlxdWVMYWJlbHMoc3RyZWFtLnN0cmVhbSwgYmFzZUxhYmVscyk7XG4gICAgY29uc3QgYWxsTGFiZWxzU3RyaW5nID0gT2JqZWN0LmVudHJpZXMoc3RyZWFtLnN0cmVhbSlcbiAgICAgIC5tYXAoKFtrZXksIHZhbF0pID0+IGAke2tleX09XCIke3ZhbH1cImApXG4gICAgICAuc29ydCgpXG4gICAgICAuam9pbignJyk7XG5cbiAgICAvLyBBZGQgZWFjaCBsaW5lXG4gICAgZm9yIChjb25zdCBbdHMsIGxpbmVdIG9mIHN0cmVhbS52YWx1ZXMpIHtcbiAgICAgIHRzRmllbGQudmFsdWVzLmFkZChuZXcgRGF0ZShwYXJzZUludCh0cy5zbGljZSgwLCAtNiksIDEwKSkudG9JU09TdHJpbmcoKSk7XG4gICAgICB0c05zRmllbGQudmFsdWVzLmFkZCh0cyk7XG4gICAgICBsaW5lRmllbGQudmFsdWVzLmFkZChsaW5lKTtcbiAgICAgIGxhYmVsc0ZpZWxkLnZhbHVlcy5hZGQodW5pcXVlKTtcbiAgICAgIGlkRmllbGQudmFsdWVzLmFkZChjcmVhdGVVaWQodHMsIGFsbExhYmVsc1N0cmluZywgbGluZSwgdXNlZFVpZHMsIGRhdGEucmVmSWQpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVWlkKHRzOiBzdHJpbmcsIGxhYmVsc1N0cmluZzogc3RyaW5nLCBsaW5lOiBzdHJpbmcsIHVzZWRVaWRzOiBhbnksIHJlZklkPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gR2VuZXJhdGUgaWQgYXMgaGFzaGVkIG5hbm9zZWNvbmQgdGltZXN0YW1wLCBsYWJlbHMgYW5kIGxpbmUgKHRoaXMgZG9lcyBub3QgaGF2ZSB0byBiZSB1bmlxdWUpXG4gIGxldCBpZCA9IHV1aWR2NShgJHt0c31fJHtsYWJlbHNTdHJpbmd9XyR7bGluZX1gLCBVVUlEX05BTUVTUEFDRSk7XG5cbiAgLy8gQ2hlY2sgaWYgZ2VuZXJhdGVkIGlkIGlzIHVuaXF1ZVxuICAvLyBJZiBub3QgYW5kIHdlJ3ZlIGFscmVhZHkgdXNlZCBpdCwgYXBwZW5kIGl0J3MgY291bnQgYWZ0ZXIgaXRcbiAgaWYgKGlkIGluIHVzZWRVaWRzKSB7XG4gICAgLy8gSW5jcmVhc2UgdGhlIGNvdW50XG4gICAgY29uc3QgbmV3Q291bnQgPSB1c2VkVWlkc1tpZF0gKyAxO1xuICAgIHVzZWRVaWRzW2lkXSA9IG5ld0NvdW50O1xuICAgIC8vIEFwcGVuZCBjb3VudCB0byBnZW5lcmF0ZWQgaWQgdG8gbWFrZSBpdCB1bmlxdWVcbiAgICBpZCA9IGAke2lkfV8ke25ld0NvdW50fWA7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgaWQgaXMgdW5pcXVlIGFuZCB3YXNuJ3QgdXNlZCwgYWRkIGl0IHRvIHVzZWRVaWRzIGFuZCBzdGFydCBjb3VudCBhdCAwXG4gICAgdXNlZFVpZHNbaWRdID0gMDtcbiAgfVxuICAvLyBSZXR1cm4gdW5pcXVlIGlkXG4gIGlmIChyZWZJZCkge1xuICAgIHJldHVybiBgJHtpZH1fJHtyZWZJZH1gO1xuICB9XG4gIHJldHVybiBpZDtcbn1cbiIsImltcG9ydCB7IGdyb3VwQnkgfSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBEYXRhRnJhbWUsIEZpZWxkLCBGaWVsZFR5cGUsIEFycmF5VmVjdG9yIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlVGFibGVGcmFtZXMoaW5zdGFudE1ldHJpY0ZyYW1lczogRGF0YUZyYW1lW10pOiBEYXRhRnJhbWVbXSB7XG4gIC8vIGZpcnN0IHdlIHJlbW92ZSBmcmFtZXMgdGhhdCBoYXZlIG5vIHJlZklkXG4gIC8vICh3ZSB3aWxsIGdyb3VwIHRoZW0gYnkgcmVmSWQsIHNvIHdlIG5lZWQgaXQgdG8gYmUgc2V0KVxuICBjb25zdCBmcmFtZXNXaXRoUmVmSWQgPSBpbnN0YW50TWV0cmljRnJhbWVzLmZpbHRlcigoZikgPT4gZi5yZWZJZCAhPT0gdW5kZWZpbmVkKTtcblxuICBjb25zdCBmcmFtZXNCeVJlZklkID0gZ3JvdXBCeShmcmFtZXNXaXRoUmVmSWQsIChmcmFtZSkgPT4gZnJhbWUucmVmSWQpO1xuXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhmcmFtZXNCeVJlZklkKS5tYXAoKFtyZWZJZCwgZnJhbWVzXSkgPT4gbWFrZVRhYmxlRnJhbWUoZnJhbWVzLCByZWZJZCkpO1xufVxuXG50eXBlIE51bWJlckZpZWxkID0gRmllbGQ8bnVtYmVyLCBBcnJheVZlY3RvcjxudW1iZXI+PjtcbnR5cGUgU3RyaW5nRmllbGQgPSBGaWVsZDxzdHJpbmcsIEFycmF5VmVjdG9yPHN0cmluZz4+O1xuXG5mdW5jdGlvbiBtYWtlVGFibGVGcmFtZShpbnN0YW50TWV0cmljRnJhbWVzOiBEYXRhRnJhbWVbXSwgcmVmSWQ6IHN0cmluZyk6IERhdGFGcmFtZSB7XG4gIGNvbnN0IHRhYmxlVGltZUZpZWxkOiBOdW1iZXJGaWVsZCA9IHsgbmFtZTogJ1RpbWUnLCBjb25maWc6IHt9LCB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcigpLCB0eXBlOiBGaWVsZFR5cGUudGltZSB9O1xuICBjb25zdCB0YWJsZVZhbHVlRmllbGQ6IE51bWJlckZpZWxkID0ge1xuICAgIG5hbWU6IGBWYWx1ZSAjJHtyZWZJZH1gLFxuICAgIGNvbmZpZzoge30sXG4gICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3IoKSxcbiAgICB0eXBlOiBGaWVsZFR5cGUubnVtYmVyLFxuICB9O1xuXG4gIC8vIFNvcnQgbWV0cmljIGxhYmVscywgY3JlYXRlIGNvbHVtbnMgZm9yIHRoZW0gYW5kIHJlY29yZCB0aGVpciBpbmRleFxuICBjb25zdCBhbGxMYWJlbE5hbWVzID0gbmV3IFNldChcbiAgICBpbnN0YW50TWV0cmljRnJhbWVzLm1hcCgoZnJhbWUpID0+IGZyYW1lLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBPYmplY3Qua2V5cyhmaWVsZC5sYWJlbHMgPz8ge30pKS5mbGF0KCkpLmZsYXQoKVxuICApO1xuXG4gIGNvbnN0IHNvcnRlZExhYmVsTmFtZXMgPSBBcnJheS5mcm9tKGFsbExhYmVsTmFtZXMpLnNvcnQoKTtcblxuICBjb25zdCBsYWJlbEZpZWxkczogU3RyaW5nRmllbGRbXSA9IHNvcnRlZExhYmVsTmFtZXMubWFwKChsYWJlbE5hbWUpID0+ICh7XG4gICAgbmFtZTogbGFiZWxOYW1lLFxuICAgIGNvbmZpZzogeyBmaWx0ZXJhYmxlOiB0cnVlIH0sXG4gICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3IoKSxcbiAgICB0eXBlOiBGaWVsZFR5cGUuc3RyaW5nLFxuICB9KSk7XG5cbiAgaW5zdGFudE1ldHJpY0ZyYW1lcy5mb3JFYWNoKChmcmFtZSkgPT4ge1xuICAgIGNvbnN0IHRpbWVGaWVsZCA9IGZyYW1lLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLnRpbWUpO1xuICAgIGNvbnN0IHZhbHVlRmllbGQgPSBmcmFtZS5maWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLnR5cGUgPT09IEZpZWxkVHlwZS5udW1iZXIpO1xuICAgIGlmICh0aW1lRmllbGQgPT0gbnVsbCB8fCB2YWx1ZUZpZWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lQXJyYXkgPSB0aW1lRmllbGQudmFsdWVzLnRvQXJyYXkoKTtcbiAgICBjb25zdCB2YWx1ZUFycmF5ID0gdmFsdWVGaWVsZC52YWx1ZXMudG9BcnJheSgpO1xuXG4gICAgZm9yIChsZXQgeCBvZiB0aW1lQXJyYXkpIHtcbiAgICAgIHRhYmxlVGltZUZpZWxkLnZhbHVlcy5hZGQoeCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgeCBvZiB2YWx1ZUFycmF5KSB7XG4gICAgICB0YWJsZVZhbHVlRmllbGQudmFsdWVzLmFkZCh4KTtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbHMgPSB2YWx1ZUZpZWxkLmxhYmVscyA/PyB7fTtcblxuICAgIGZvciAobGV0IGYgb2YgbGFiZWxGaWVsZHMpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBsYWJlbHNbZi5uYW1lXSA/PyAnJztcbiAgICAgIC8vIHdlIGluc2VydCB0aGUgbGFiZWxzIGFzIG1hbnkgdGltZXMgYXMgd2UgaGF2ZSB2YWx1ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmLnZhbHVlcy5hZGQodGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGZpZWxkczogW3RhYmxlVGltZUZpZWxkLCAuLi5sYWJlbEZpZWxkcywgdGFibGVWYWx1ZUZpZWxkXSxcbiAgICByZWZJZCxcbiAgICBtZXRhOiB7IHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAndGFibGUnIH0sXG4gICAgbGVuZ3RoOiB0YWJsZVRpbWVGaWVsZC52YWx1ZXMubGVuZ3RoLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgRGF0YVNvdXJjZVBsdWdpbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5pbXBvcnQgTG9raUNoZWF0U2hlZXQgZnJvbSAnLi9jb21wb25lbnRzL0xva2lDaGVhdFNoZWV0JztcbmltcG9ydCBMb2tpUXVlcnlFZGl0b3JCeUFwcCBmcm9tICcuL2NvbXBvbmVudHMvTG9raVF1ZXJ5RWRpdG9yQnlBcHAnO1xuaW1wb3J0IHsgQ29uZmlnRWRpdG9yIH0gZnJvbSAnLi9jb25maWd1cmF0aW9uL0NvbmZpZ0VkaXRvcic7XG5pbXBvcnQgeyBMb2tpRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5cbmV4cG9ydCBjb25zdCBwbHVnaW4gPSBuZXcgRGF0YVNvdXJjZVBsdWdpbihMb2tpRGF0YXNvdXJjZSlcbiAgLnNldFF1ZXJ5RWRpdG9yKExva2lRdWVyeUVkaXRvckJ5QXBwKVxuICAuc2V0Q29uZmlnRWRpdG9yKENvbmZpZ0VkaXRvcilcbiAgLnNldFF1ZXJ5RWRpdG9ySGVscChMb2tpQ2hlYXRTaGVldCk7XG4iLCJpbXBvcnQgeyBlc2NhcGVSZWdFeHAgfSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBMb2tpUXVlcnksIExva2lRdWVyeVR5cGUgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFF1ZXJ5KHNlbGVjdG9yOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7c2VsZWN0b3IgfHwgJyd9YC50cmltKCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBzZWFyY2ggdGVybXMgZnJvbSBhIExvZ1FMIHF1ZXJ5LlxuICogRS5nLiwgYHt9IHw9IGZvbyB8PWJhciAhPSBiYXpgIHJldHVybnMgYFsnZm9vJywgJ2JhciddYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhpZ2hsaWdodGVyRXhwcmVzc2lvbnNGcm9tUXVlcnkoaW5wdXQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgbGV0IGV4cHJlc3Npb24gPSBpbnB1dDtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gIC8vIENvbnN1bWUgZmlsdGVyIGV4cHJlc3Npb24gZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gIHdoaWxlIChleHByZXNzaW9uKSB7XG4gICAgY29uc3QgZmlsdGVyU3RhcnQgPSBleHByZXNzaW9uLnNlYXJjaCgvXFx8PXxcXHx+fCE9fCF+Lyk7XG4gICAgLy8gTm90aGluZyBtb3JlIHRvIHNlYXJjaFxuICAgIGlmIChmaWx0ZXJTdGFydCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBEcm9wIHRlcm1zIGZvciBuZWdhdGl2ZSBmaWx0ZXJzXG4gICAgY29uc3QgZmlsdGVyT3BlcmF0b3IgPSBleHByZXNzaW9uLnNsaWNlKGZpbHRlclN0YXJ0LCBmaWx0ZXJTdGFydCArIDIpO1xuICAgIGNvbnN0IHNraXAgPSBleHByZXNzaW9uLnNsaWNlKGZpbHRlclN0YXJ0KS5zZWFyY2goLyE9fCF+LykgPT09IDA7XG4gICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uc2xpY2UoZmlsdGVyU3RhcnQgKyAyKTtcbiAgICBpZiAoc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIG1vcmUgY2hhaW5lZFxuICAgIGNvbnN0IGZpbHRlckVuZCA9IGV4cHJlc3Npb24uc2VhcmNoKC9cXHw9fFxcfH58IT18IX4vKTtcbiAgICBsZXQgZmlsdGVyVGVybTtcbiAgICBpZiAoZmlsdGVyRW5kID09PSAtMSkge1xuICAgICAgZmlsdGVyVGVybSA9IGV4cHJlc3Npb24udHJpbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWx0ZXJUZXJtID0gZXhwcmVzc2lvbi5zbGljZSgwLCBmaWx0ZXJFbmQpLnRyaW0oKTtcbiAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnNsaWNlKGZpbHRlckVuZCk7XG4gICAgfVxuXG4gICAgY29uc3QgcXVvdGVkVGVybSA9IGZpbHRlclRlcm0ubWF0Y2goL1wiKC4qPylcIi8pO1xuICAgIGNvbnN0IGJhY2t0aWNrZWRUZXJtID0gZmlsdGVyVGVybS5tYXRjaCgvYCguKj8pYC8pO1xuICAgIGNvbnN0IHRlcm0gPSBxdW90ZWRUZXJtIHx8IGJhY2t0aWNrZWRUZXJtO1xuXG4gICAgaWYgKHRlcm0pIHtcbiAgICAgIGNvbnN0IHVud3JhcHBlZEZpbHRlclRlcm0gPSB0ZXJtWzFdO1xuICAgICAgY29uc3QgcmVnZXhPcGVyYXRvciA9IGZpbHRlck9wZXJhdG9yID09PSAnfH4nO1xuXG4gICAgICAvLyBPbmx5IGZpbHRlciBleHByZXNzaW9ucyB3aXRoIHx+IG9wZXJhdG9yIGFyZSB0cmVhdGVkIGFzIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgICAgIGlmIChyZWdleE9wZXJhdG9yKSB7XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgYmFja3RpY2tzLCBMb2tpIGRvZXNuJ3QgcmVxdWlyZSB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCB3ZSBjYW4ganVzdCBwdXNoIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBoaWdobGlnaHRzIGFycmF5XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgcXVvdGVzLCB3ZSBoYXZlIGV4dHJhIGJhY2tzbGFzaCBlc2NhcGluZyBhbmQgd2UgbmVlZCB0byByZXBsYWNlIFxcXFwgd2l0aCBcXFxuICAgICAgICByZXN1bHRzLnB1c2goYmFja3RpY2tlZFRlcm0gPyB1bndyYXBwZWRGaWx0ZXJUZXJtIDogdW53cmFwcGVkRmlsdGVyVGVybS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZXNjYXBlIHRoaXMgc3RyaW5nIHNvIGl0IGlzIG5vdCBtYXRjaGVkIGFzIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAgICByZXN1bHRzLnB1c2goZXNjYXBlUmVnRXhwKHVud3JhcHBlZEZpbHRlclRlcm0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8vIHdlIGFyZSBtaWdyYXRpbmcgZnJvbSBgLmluc3RhbnRgIGFuZCBgLnJhbmdlYCB0byBgLnF1ZXJ5VHlwZWBcbi8vIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBxdWVyeSBvYmplY3QgdGhhdDpcbi8vIC0gaGFzIGAucXVlcnlUeXBlYFxuLy8gLSBkb2VzIG5vdCBoYXZlIGAuaW5zdGFudGBcbi8vIC0gZG9lcyBub3QgaGF2ZSBgLnJhbmdlYFxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRMb2tpUXVlcnkocXVlcnk6IExva2lRdWVyeSk6IExva2lRdWVyeSB7XG4gIC8vICBpZiBxdWVyeVR5cGUgZmllbGQgY29udGFpbnMgaW52YWxpZCBkYXRhIHdlIGJlaGF2ZSBhcyBpZiB0aGUgcXVlcnlUeXBlIGlzIGVtcHR5XG4gIGNvbnN0IHsgcXVlcnlUeXBlIH0gPSBxdWVyeTtcbiAgY29uc3QgaGFzVmFsaWRRdWVyeVR5cGUgPVxuICAgIHF1ZXJ5VHlwZSA9PT0gTG9raVF1ZXJ5VHlwZS5SYW5nZSB8fCBxdWVyeVR5cGUgPT09IExva2lRdWVyeVR5cGUuSW5zdGFudCB8fCBxdWVyeVR5cGUgPT09IExva2lRdWVyeVR5cGUuU3RyZWFtO1xuXG4gIC8vIGlmIHF1ZXJ5VHlwZSBleGlzdHMsIGl0IGlzIHJlc3BlY3RlZFxuICBpZiAoaGFzVmFsaWRRdWVyeVR5cGUpIHtcbiAgICBjb25zdCB7IGluc3RhbnQsIHJhbmdlLCAuLi5yZXN0IH0gPSBxdWVyeTtcbiAgICByZXR1cm4gcmVzdDtcbiAgfVxuXG4gIC8vIGlmIG5vIHF1ZXJ5VHlwZSwgYW5kIGluc3RhbnQ9PT10cnVlLCBpdCdzIGluc3RhbnRcbiAgaWYgKHF1ZXJ5Lmluc3RhbnQgPT09IHRydWUpIHtcbiAgICBjb25zdCB7IGluc3RhbnQsIHJhbmdlLCAuLi5yZXN0IH0gPSBxdWVyeTtcbiAgICByZXR1cm4geyAuLi5yZXN0LCBxdWVyeVR5cGU6IExva2lRdWVyeVR5cGUuSW5zdGFudCB9O1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlIGl0IGlzIHJhbmdlXG4gIGNvbnN0IHsgaW5zdGFudCwgcmFuZ2UsIC4uLnJlc3QgfSA9IHF1ZXJ5O1xuICByZXR1cm4geyAuLi5yZXN0LCBxdWVyeVR5cGU6IExva2lRdWVyeVR5cGUuUmFuZ2UgfTtcbn1cbiIsImltcG9ydCB7IExva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UgfSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB9IGZyb20gJy4uLy4uL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5cbmltcG9ydCB7IGdldE9wZXJhdGlvbkRlZmluaXRpb25zIH0gZnJvbSAnLi9vcGVyYXRpb25zJztcbmltcG9ydCB7IExva2lPcGVyYXRpb25JZCwgTG9raVF1ZXJ5UGF0dGVybiwgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIExva2lRdWVyeU1vZGVsbGVyIGV4dGVuZHMgTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGdldE9wZXJhdGlvbkRlZmluaXRpb25zKTtcblxuICAgIHRoaXMuc2V0T3BlcmF0aW9uQ2F0ZWdvcmllcyhbXG4gICAgICBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICAgIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5CaW5hcnlPcHMsXG4gICAgICBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5MYWJlbEZpbHRlcnMsXG4gICAgICBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5MaW5lRmlsdGVycyxcbiAgICBdKTtcbiAgfVxuXG4gIHJlbmRlckxhYmVscyhsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10pIHtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICd7fSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnJlbmRlckxhYmVscyhsYWJlbHMpO1xuICB9XG5cbiAgZ2V0UXVlcnlQYXR0ZXJucygpOiBMb2tpUXVlcnlQYXR0ZXJuW10ge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdMb2cgcXVlcnkgd2l0aCBwYXJzaW5nJyxcbiAgICAgICAgLy8ge30gfCBsb2dmbXQgfCBfX2Vycm9yX189YGBcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5Mb2dmbXQsIHBhcmFtczogW10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGFiZWxGaWx0ZXJOb0Vycm9ycywgcGFyYW1zOiBbXSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0xvZyBxdWVyeSB3aXRoIGZpbHRlcmluZyBhbmQgcGFyc2luZycsXG4gICAgICAgIC8vIHt9IHw9IGBgIHwgbG9nZm10IHwgX19lcnJvcl9fPWBgXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGluZUNvbnRhaW5zLCBwYXJhbXM6IFsnJ10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTG9nZm10LCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRmlsdGVyTm9FcnJvcnMsIHBhcmFtczogW10gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdMb2cgcXVlcnkgd2l0aCBwYXJzaW5nIGFuZCBsYWJlbCBmaWx0ZXInLFxuICAgICAgICAvLyB7fSB8PSBgYCB8IGxvZ2ZtdCB8IF9fZXJyb3JfXz1gYCB8IGxhYmVsPWB2YWx1ZWBcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lQ29udGFpbnMsIHBhcmFtczogWycnXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5Mb2dmbXQsIHBhcmFtczogW10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGFiZWxGaWx0ZXJOb0Vycm9ycywgcGFyYW1zOiBbXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MYWJlbEZpbHRlciwgcGFyYW1zOiBbJ2xhYmVsJywgJz0nLCAndmFsdWUnXSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0xvZyBxdWVyeSB3aXRoIHBhcnNpbmcgb2YgbmVzdGVkIGpzb24nLFxuICAgICAgICAvLyB7fSB8PSBgYCB8IGpzb24gfCBsaW5lX2Zvcm1hdCBge3sgLm1lc3NhZ2V9fWAgfCBqc29uXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGluZUNvbnRhaW5zLCBwYXJhbXM6IFsnJ10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuSnNvbiwgcGFyYW1zOiBbXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MYWJlbEZpbHRlck5vRXJyb3JzLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkxpbmVGb3JtYXQsIHBhcmFtczogWyd7ey5tZXNzYWdlfX0nXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5Kc29uLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRmlsdGVyTm9FcnJvcnMsIHBhcmFtczogW10gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdMb2cgcXVlcnkgd2l0aCByZWZvcm1hdHRlZCBsb2cgbGluZScsXG4gICAgICAgIC8vIHt9IHw9IGBgIHwgbG9nZm10IHwgbGluZV9mb3JtYXQgYHt7Lm1lc3NhZ2V9fWBcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lQ29udGFpbnMsIHBhcmFtczogWycnXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5Mb2dmbXQsIHBhcmFtczogW10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGFiZWxGaWx0ZXJOb0Vycm9ycywgcGFyYW1zOiBbXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lRm9ybWF0LCBwYXJhbXM6IFsne3subWVzc2FnZX19J10gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdMb2cgcXVlcnkgd2l0aCBtYXBwZWQgbG9nIGxldmVsJyxcbiAgICAgICAgLy8ge30gfD0gYGAgfCBsb2dmbXQgfCBsYWJlbF9mb3JtYXQgbGV2ZWw9bHZsXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGluZUNvbnRhaW5zLCBwYXJhbXM6IFsnJ10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTG9nZm10LCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRmlsdGVyTm9FcnJvcnMsIHBhcmFtczogW10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGFiZWxGb3JtYXQsIHBhcmFtczogWydsdmwnLCAnbGV2ZWwnXSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ01ldHJpY3MgcXVlcnkgb24gdmFsdWUgaW5zaWRlIGxvZyBsaW5lJyxcbiAgICAgICAgLy8gc3VtKHN1bV9vdmVyX3RpbWUoeyB8IGxvZ2ZtdCB8IF9fZXJyb3JfXz1gYCB8IHVud3JhcCB8IF9fZXJyb3JfXz1gYCBbJF9faW50ZXJ2YWxdKSlcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lQ29udGFpbnMsIHBhcmFtczogWycnXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5Mb2dmbXQsIHBhcmFtczogW10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGFiZWxGaWx0ZXJOb0Vycm9ycywgcGFyYW1zOiBbXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5VbndyYXAsIHBhcmFtczogWycnXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MYWJlbEZpbHRlck5vRXJyb3JzLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLlN1bU92ZXJUaW1lLCBwYXJhbXM6IFsnJF9faW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5TdW0sIHBhcmFtczogW10gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdNZXRyaWNzIHF1ZXJ5IGZvciB0b3RhbCByZXF1ZXN0cyBwZXIgbGFiZWwgb2Ygc3RyZWFtcycsXG4gICAgICAgIC8vIHN1bSBieSgpIChjb3VudF9vdmVyX3RpbWUoe31bJF9faW50ZXJ2YWwpXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGluZUNvbnRhaW5zLCBwYXJhbXM6IFsnJ10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuQ291bnRPdmVyVGltZSwgcGFyYW1zOiBbJyRfX2ludGVydmFsJ10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuU3VtLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnTWV0cmljcyBxdWVyeSBmb3IgdG90YWwgcmVxdWVzdHMgcGVyIHBhcnNlZCBsYWJlbCBvciBsYWJlbCBvZiBzdHJlYW1zJyxcbiAgICAgICAgLy8gc3VtIGJ5KCkgKGNvdW50X292ZXJfdGltZSh7fXwgbG9nZm10IHwgX19lcnJvcl9fPWBgIFskX19pbnRlcnZhbCkpXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGluZUNvbnRhaW5zLCBwYXJhbXM6IFsnJ10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTG9nZm10LCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRmlsdGVyTm9FcnJvcnMsIHBhcmFtczogW10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuQ291bnRPdmVyVGltZSwgcGFyYW1zOiBbJyRfX2ludGVydmFsJ10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuU3VtLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnTWV0cmljcyBxdWVyeSBmb3IgYnl0ZXMgdXNlZCBieSBsb2cgc3RyZWFtJyxcbiAgICAgICAgLy8gYnl0ZXNfb3Zlcl90aW1lKHt9WyRfX2ludGVydmFsXSlcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lQ29udGFpbnMsIHBhcmFtczogWycnXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5CeXRlc092ZXJUaW1lLCBwYXJhbXM6IFsnJF9faW50ZXJ2YWwnXSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ01ldHJpY3MgcXVlcnkgZm9yIGNvdW50IG9mIGxvZyBsaW5lcyBwZXIgc3RyZWFtJyxcbiAgICAgICAgLy8gY291bnRfb3Zlcl90aW1lKHt9WyRfX2ludGVydmFsXSlcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lQ29udGFpbnMsIHBhcmFtczogWycnXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5Db3VudE92ZXJUaW1lLCBwYXJhbXM6IFsnJF9faW50ZXJ2YWwnXSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ01ldHJpY3MgcXVlcnkgZm9yIHRvcCBuIHJlc3VsdHMgYnkgbGFiZWwgb3IgcGFyc2VkIGxhYmVsJyxcbiAgICAgICAgLy8gdG9waygxMCwgc3VtIGJ5ICgpIChjb3VudF9vdmVyX3RpbWUoe30gfCBsb2dmbXQgfCBfX2Vycm9yX189YGAgWyRfX2ludGVydmFsXSkpKVxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkxvZ2ZtdCwgcGFyYW1zOiBbXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MYWJlbEZpbHRlck5vRXJyb3JzLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkNvdW50T3ZlclRpbWUsIHBhcmFtczogWyckX19pbnRlcnZhbCddIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLlN1bSwgcGFyYW1zOiBbXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5Ub3BLLCBwYXJhbXM6IFsxMF0gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdNZXRyaWNzIHF1ZXJ5IGZvciBleHRyYWN0ZWQgcXVhbnRpbGUnLFxuICAgICAgICAvLyBxdWFudGlsZV9vdmVyX3RpbWUoMC41LHt9IHwgbG9nZm10IHwgdW53cmFwIGxhdGVuY3lbJF9faW50ZXJ2YWxdKSBieSAoKVxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkxvZ2ZtdCwgcGFyYW1zOiBbXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MYWJlbEZpbHRlck5vRXJyb3JzLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLlVud3JhcCwgcGFyYW1zOiBbJ2xhdGVuY3knXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MYWJlbEZpbHRlck5vRXJyb3JzLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLlF1YW50aWxlT3ZlclRpbWUsIHBhcmFtczogWzAuNSwgJyRfX2ludGVydmFsJ10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuU3VtLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIF07XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxva2lRdWVyeU1vZGVsbGVyID0gbmV3IExva2lRdWVyeU1vZGVsbGVyKCk7XG4iLCJpbXBvcnQgeyBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlciB9IGZyb20gJy4uLy4uL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9vcGVyYXRpb25VdGlscyc7XG5pbXBvcnQge1xuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYsXG59IGZyb20gJy4uLy4uL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5cbmltcG9ydCB7IExva2lPcGVyYXRpb25JZCwgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IGJpbmFyeVNjYWxhckRlZnMgPSBbXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLkFkZGl0aW9uLFxuICAgIG5hbWU6ICdBZGQgc2NhbGFyJyxcbiAgICBzaWduOiAnKycsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLlN1YnRyYWN0aW9uLFxuICAgIG5hbWU6ICdTdWJ0cmFjdCBzY2FsYXInLFxuICAgIHNpZ246ICctJyxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTXVsdGlwbHlCeSxcbiAgICBuYW1lOiAnTXVsdGlwbHkgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnKicsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLkRpdmlkZUJ5LFxuICAgIG5hbWU6ICdEaXZpZGUgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnLycsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLk1vZHVsbyxcbiAgICBuYW1lOiAnTW9kdWxvIGJ5IHNjYWxhcicsXG4gICAgc2lnbjogJyUnLFxuICB9LFxuICB7XG4gICAgaWQ6IExva2lPcGVyYXRpb25JZC5FeHBvbmVudCxcbiAgICBuYW1lOiAnRXhwb25lbnQnLFxuICAgIHNpZ246ICdeJyxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuRXF1YWxUbyxcbiAgICBuYW1lOiAnRXF1YWwgdG8nLFxuICAgIHNpZ246ICc9PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTm90RXF1YWxUbyxcbiAgICBuYW1lOiAnTm90IGVxdWFsIHRvJyxcbiAgICBzaWduOiAnIT0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLkdyZWF0ZXJUaGFuLFxuICAgIG5hbWU6ICdHcmVhdGVyIHRoYW4nLFxuICAgIHNpZ246ICc+JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IExva2lPcGVyYXRpb25JZC5MZXNzVGhhbixcbiAgICBuYW1lOiAnTGVzcyB0aGFuJyxcbiAgICBzaWduOiAnPCcsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuR3JlYXRlck9yRXF1YWwsXG4gICAgbmFtZTogJ0dyZWF0ZXIgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc+PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTGVzc09yRXF1YWwsXG4gICAgbmFtZTogJ0xlc3Mgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc8PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbl07XG5cbi8vIE5vdCBzdXJlIGFib3V0IHRoaXMgb25lLiBJdCBjb3VsZCBhbHNvIGJlIGEgbW9yZSBnZW5lcmljICdTaW1wbGUgbWF0aCBvcGVyYXRpb24nIHdoZXJlIHVzZXIgc3BlY2lmaWVzXG4vLyBib3RoIHRoZSBvcGVyYXRvciBhbmQgdGhlIG9wZXJhbmQgaW4gYSBzaW5nbGUgaW5wdXRcbmV4cG9ydCBjb25zdCBiaW5hcnlTY2FsYXJPcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSA9IGJpbmFyeVNjYWxhckRlZnMubWFwKChvcERlZikgPT4ge1xuICBjb25zdCBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW10gPSBbeyBuYW1lOiAnVmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XTtcbiAgY29uc3QgZGVmYXVsdFBhcmFtczogYW55W10gPSBbMl07XG4gIGlmIChvcERlZi5jb21wYXJpc29uKSB7XG4gICAgcGFyYW1zLnVuc2hpZnQoe1xuICAgICAgbmFtZTogJ0Jvb2wnLFxuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVzY3JpcHRpb246ICdJZiBjaGVja2VkIGNvbXBhcmlzb24gd2lsbCByZXR1cm4gMCBvciAxIGZvciB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gZmlsdGVyaW5nLicsXG4gICAgfSk7XG4gICAgZGVmYXVsdFBhcmFtcy51bnNoaWZ0KGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaWQ6IG9wRGVmLmlkLFxuICAgIG5hbWU6IG9wRGVmLm5hbWUsXG4gICAgcGFyYW1zLFxuICAgIGRlZmF1bHRQYXJhbXMsXG4gICAgYWx0ZXJuYXRpdmVzS2V5OiAnYmluYXJ5IHNjYWxhciBvcGVyYXRpb25zJyxcbiAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQmluYXJ5T3BzLFxuICAgIHJlbmRlcmVyOiBnZXRTaW1wbGVCaW5hcnlSZW5kZXJlcihvcERlZi5zaWduKSxcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRTaW1wbGVCaW5hcnlSZW5kZXJlcihvcGVyYXRvcjogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBiaW5hcnlSZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICBsZXQgcGFyYW0gPSBtb2RlbC5wYXJhbXNbMF07XG4gICAgbGV0IGJvb2wgPSAnJztcbiAgICBpZiAobW9kZWwucGFyYW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgcGFyYW0gPSBtb2RlbC5wYXJhbXNbMV07XG4gICAgICBib29sID0gbW9kZWwucGFyYW1zWzBdID8gJyBib29sJyA6ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBgJHtpbm5lckV4cHJ9ICR7b3BlcmF0b3J9JHtib29sfSAke3BhcmFtfWA7XG4gIH07XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JSb3cgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgTGFiZWxGaWx0ZXJzIH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvTGFiZWxGaWx0ZXJzJztcbmltcG9ydCB7IE9wZXJhdGlvbkxpc3QgfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25MaXN0JztcbmltcG9ydCB7IE9wZXJhdGlvbnNFZGl0b3JSb3cgfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25zRWRpdG9yUm93JztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBMb2tpRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgZXNjYXBlTGFiZWxWYWx1ZUluU2VsZWN0b3IgfSBmcm9tICcuLi8uLi9sYW5ndWFnZV91dGlscyc7XG5pbXBvcnQgeyBsb2tpUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL0xva2lRdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IExva2lPcGVyYXRpb25JZCwgTG9raVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBOZXN0ZWRRdWVyeUxpc3QgfSBmcm9tICcuL05lc3RlZFF1ZXJ5TGlzdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogTG9raVZpc3VhbFF1ZXJ5O1xuICBkYXRhc291cmNlOiBMb2tpRGF0YXNvdXJjZTtcbiAgb25DaGFuZ2U6ICh1cGRhdGU6IExva2lWaXN1YWxRdWVyeSkgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbiAgbmVzdGVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IExva2lRdWVyeUJ1aWxkZXIgPSBSZWFjdC5tZW1vPFByb3BzPigoeyBkYXRhc291cmNlLCBxdWVyeSwgbmVzdGVkLCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9KSA9PiB7XG4gIGNvbnN0IG9uQ2hhbmdlTGFiZWxzID0gKGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSkgPT4ge1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGxhYmVscyB9KTtcbiAgfTtcblxuICBjb25zdCB3aXRoVGVtcGxhdGVWYXJpYWJsZU9wdGlvbnMgPSBhc3luYyAob3B0aW9uc1Byb21pc2U6IFByb21pc2U8c3RyaW5nW10+KTogUHJvbWlzZTxTZWxlY3RhYmxlVmFsdWVbXT4gPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBvcHRpb25zUHJvbWlzZTtcbiAgICByZXR1cm4gWy4uLmRhdGFzb3VyY2UuZ2V0VmFyaWFibGVzKCksIC4uLm9wdGlvbnNdLm1hcCgodmFsdWUpID0+ICh7IGxhYmVsOiB2YWx1ZSwgdmFsdWUgfSkpO1xuICB9O1xuXG4gIGNvbnN0IG9uR2V0TGFiZWxOYW1lcyA9IGFzeW5jIChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pOiBQcm9taXNlPGFueT4gPT4ge1xuICAgIGNvbnN0IGxhYmVsc1RvQ29uc2lkZXIgPSBxdWVyeS5sYWJlbHMuZmlsdGVyKCh4KSA9PiB4ICE9PSBmb3JMYWJlbCk7XG5cbiAgICBpZiAobGFiZWxzVG9Db25zaWRlci5sZW5ndGggPT09IDApIHtcbiAgICAgIGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5yZWZyZXNoTG9nTGFiZWxzKCk7XG4gICAgICByZXR1cm4gZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsS2V5cygpO1xuICAgIH1cblxuICAgIGNvbnN0IGV4cHIgPSBsb2tpUXVlcnlNb2RlbGxlci5yZW5kZXJMYWJlbHMobGFiZWxzVG9Db25zaWRlcik7XG4gICAgY29uc3Qgc2VyaWVzID0gYXdhaXQgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzTGFiZWxzKGV4cHIpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzZXJpZXMpLnNvcnQoKTtcbiAgfTtcblxuICBjb25zdCBvbkdldExhYmVsVmFsdWVzID0gYXN5bmMgKGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPikgPT4ge1xuICAgIGlmICghZm9yTGFiZWwubGFiZWwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgdmFsdWVzO1xuICAgIGNvbnN0IGxhYmVsc1RvQ29uc2lkZXIgPSBxdWVyeS5sYWJlbHMuZmlsdGVyKCh4KSA9PiB4ICE9PSBmb3JMYWJlbCk7XG4gICAgaWYgKGxhYmVsc1RvQ29uc2lkZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YWx1ZXMgPSBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hMYWJlbFZhbHVlcyhmb3JMYWJlbC5sYWJlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4cHIgPSBsb2tpUXVlcnlNb2RlbGxlci5yZW5kZXJMYWJlbHMobGFiZWxzVG9Db25zaWRlcik7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hTZXJpZXNMYWJlbHMoZXhwcik7XG4gICAgICB2YWx1ZXMgPSByZXN1bHRbZGF0YXNvdXJjZS5pbnRlcnBvbGF0ZVN0cmluZyhmb3JMYWJlbC5sYWJlbCldO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXMgPyB2YWx1ZXMubWFwKCh2KSA9PiBlc2NhcGVMYWJlbFZhbHVlSW5TZWxlY3Rvcih2LCBmb3JMYWJlbC5vcCkpIDogW107IC8vIEVzY2FwZSB2YWx1ZXMgaW4gcmV0dXJuXG4gIH07XG5cbiAgY29uc3QgbGFiZWxGaWx0ZXJFcnJvcjogc3RyaW5nIHwgdW5kZWZpbmVkID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgeyBsYWJlbHMsIG9wZXJhdGlvbnM6IG9wIH0gPSBxdWVyeTtcbiAgICBpZiAoIWxhYmVscy5sZW5ndGggJiYgb3AubGVuZ3RoKSB7XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHNob3cgZXJyb3IgZm9yIGluaXRpYWwgc3RhdGUgd2l0aCBlbXB0eSBsaW5lIGNvbnRhaW5zIG9wZXJhdGlvblxuICAgICAgaWYgKG9wLmxlbmd0aCA9PT0gMSAmJiBvcFswXS5pZCA9PT0gTG9raU9wZXJhdGlvbklkLkxpbmVDb250YWlucyAmJiBvcFswXS5wYXJhbXNbMF0gPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1lvdSBuZWVkIHRvIHNwZWNpZnkgYXQgbGVhc3QgMSBsYWJlbCBmaWx0ZXIgKHN0cmVhbSBzZWxlY3RvciknO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBbcXVlcnldKTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8RWRpdG9yUm93PlxuICAgICAgICA8TGFiZWxGaWx0ZXJzXG4gICAgICAgICAgb25HZXRMYWJlbE5hbWVzPXsoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PlxuICAgICAgICAgICAgd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zKG9uR2V0TGFiZWxOYW1lcyhmb3JMYWJlbCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIG9uR2V0TGFiZWxWYWx1ZXM9eyhmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+XG4gICAgICAgICAgICB3aXRoVGVtcGxhdGVWYXJpYWJsZU9wdGlvbnMob25HZXRMYWJlbFZhbHVlcyhmb3JMYWJlbCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGxhYmVsc0ZpbHRlcnM9e3F1ZXJ5LmxhYmVsc31cbiAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VMYWJlbHN9XG4gICAgICAgICAgZXJyb3I9e2xhYmVsRmlsdGVyRXJyb3J9XG4gICAgICAgIC8+XG4gICAgICA8L0VkaXRvclJvdz5cbiAgICAgIDxPcGVyYXRpb25zRWRpdG9yUm93PlxuICAgICAgICA8T3BlcmF0aW9uTGlzdFxuICAgICAgICAgIHF1ZXJ5TW9kZWxsZXI9e2xva2lRdWVyeU1vZGVsbGVyfVxuICAgICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlIGFzIERhdGFTb3VyY2VBcGl9XG4gICAgICAgIC8+XG4gICAgICA8L09wZXJhdGlvbnNFZGl0b3JSb3c+XG4gICAgICB7cXVlcnkuYmluYXJ5UXVlcmllcyAmJiBxdWVyeS5iaW5hcnlRdWVyaWVzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICA8TmVzdGVkUXVlcnlMaXN0IHF1ZXJ5PXtxdWVyeX0gZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX0gb25DaGFuZ2U9e29uQ2hhbmdlfSBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fSAvPlxuICAgICAgKX1cbiAgICA8Lz5cbiAgKTtcbn0pO1xuXG5Mb2tpUXVlcnlCdWlsZGVyLmRpc3BsYXlOYW1lID0gJ0xva2lRdWVyeUJ1aWxkZXInO1xuIiwiaW1wb3J0IHsgY3JlYXRlU2xpY2UsIFBheWxvYWRBY3Rpb24gfSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZHVjZXIgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IExva2lEYXRhc291cmNlIH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBMb2tpUXVlcnkgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBsb2tpUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL0xva2lRdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi4vcGFyc2luZyc7XG5pbXBvcnQgeyBMb2tpVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IExva2lRdWVyeUJ1aWxkZXIgfSBmcm9tICcuL0xva2lRdWVyeUJ1aWxkZXInO1xuaW1wb3J0IHsgUXVlcnlQcmV2aWV3IH0gZnJvbSAnLi9RdWVyeVByZXZpZXcnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IExva2lRdWVyeTtcbiAgZGF0YXNvdXJjZTogTG9raURhdGFzb3VyY2U7XG4gIG9uQ2hhbmdlOiAodXBkYXRlOiBMb2tpUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIHNob3dSYXdRdWVyeTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZSB7XG4gIHZpc1F1ZXJ5PzogTG9raVZpc3VhbFF1ZXJ5O1xuICBleHByOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaXMgaGVyZSBqdXN0IHRvIGNvbnRhaW4gdGhlIHRyYW5zbGF0aW9uIGxvZ2ljIGJldHdlZW4gc3RyaW5nIHF1ZXJ5IGFuZCB0aGUgdmlzdWFsIHF1ZXJ5IGJ1aWxkZXIgbW9kZWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBMb2tpUXVlcnlCdWlsZGVyQ29udGFpbmVyKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IHF1ZXJ5LCBvbkNoYW5nZSwgb25SdW5RdWVyeSwgZGF0YXNvdXJjZSwgc2hvd1Jhd1F1ZXJ5IH0gPSBwcm9wcztcbiAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSB1c2VSZWR1Y2VyKHN0YXRlU2xpY2UucmVkdWNlciwge1xuICAgIGV4cHI6IHF1ZXJ5LmV4cHIsXG4gICAgLy8gVXNlIGluaXRpYWwgdmlzdWFsIHF1ZXJ5IG9ubHkgaWYgcXVlcnkuZXhwciBpcyBlbXB0eSBzdHJpbmdcbiAgICB2aXNRdWVyeTpcbiAgICAgIHF1ZXJ5LmV4cHIgPT09ICcnXG4gICAgICAgID8ge1xuICAgICAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgICAgIG9wZXJhdGlvbnM6IFt7IGlkOiAnX19saW5lX2NvbnRhaW5zJywgcGFyYW1zOiBbJyddIH1dLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQsXG4gIH0pO1xuXG4gIC8vIE9ubHkgcmVidWlsZCB2aXN1YWwgcXVlcnkgaWYgZXhwciBjaGFuZ2VzIGZyb20gb3V0c2lkZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGRpc3BhdGNoKGV4cHJDaGFuZ2VkKHF1ZXJ5LmV4cHIpKTtcbiAgfSwgW3F1ZXJ5LmV4cHJdKTtcblxuICBjb25zdCBvblZpc1F1ZXJ5Q2hhbmdlID0gKHZpc1F1ZXJ5OiBMb2tpVmlzdWFsUXVlcnkpID0+IHtcbiAgICBjb25zdCBleHByID0gbG9raVF1ZXJ5TW9kZWxsZXIucmVuZGVyUXVlcnkodmlzUXVlcnkpO1xuICAgIGRpc3BhdGNoKHZpc3VhbFF1ZXJ5Q2hhbmdlKHsgdmlzUXVlcnksIGV4cHIgfSkpO1xuICAgIG9uQ2hhbmdlKHsgLi4ucHJvcHMucXVlcnksIGV4cHI6IGV4cHIgfSk7XG4gIH07XG5cbiAgaWYgKCFzdGF0ZS52aXNRdWVyeSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPExva2lRdWVyeUJ1aWxkZXJcbiAgICAgICAgcXVlcnk9e3N0YXRlLnZpc1F1ZXJ5fVxuICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICBvbkNoYW5nZT17b25WaXNRdWVyeUNoYW5nZX1cbiAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgIC8+XG4gICAgICB7c2hvd1Jhd1F1ZXJ5ICYmIDxRdWVyeVByZXZpZXcgcXVlcnk9e3F1ZXJ5LmV4cHJ9IC8+fVxuICAgIDwvPlxuICApO1xufVxuXG5jb25zdCBzdGF0ZVNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICBuYW1lOiAnbG9raS1idWlsZGVyLWNvbnRhaW5lcicsXG4gIGluaXRpYWxTdGF0ZTogeyBleHByOiAnJyB9IGFzIFN0YXRlLFxuICByZWR1Y2Vyczoge1xuICAgIHZpc3VhbFF1ZXJ5Q2hhbmdlOiAoc3RhdGUsIGFjdGlvbjogUGF5bG9hZEFjdGlvbjx7IHZpc1F1ZXJ5OiBMb2tpVmlzdWFsUXVlcnk7IGV4cHI6IHN0cmluZyB9PikgPT4ge1xuICAgICAgc3RhdGUuZXhwciA9IGFjdGlvbi5wYXlsb2FkLmV4cHI7XG4gICAgICBzdGF0ZS52aXNRdWVyeSA9IGFjdGlvbi5wYXlsb2FkLnZpc1F1ZXJ5O1xuICAgIH0sXG4gICAgZXhwckNoYW5nZWQ6IChzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPHN0cmluZz4pID0+IHtcbiAgICAgIGlmICghc3RhdGUudmlzUXVlcnkgfHwgc3RhdGUuZXhwciAhPT0gYWN0aW9uLnBheWxvYWQpIHtcbiAgICAgICAgc3RhdGUuZXhwciA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgc3RhdGUudmlzUXVlcnkgPSBwYXJzZVJlc3VsdC5xdWVyeTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxufSk7XG5cbmNvbnN0IHsgdmlzdWFsUXVlcnlDaGFuZ2UsIGV4cHJDaGFuZ2VkIH0gPSBzdGF0ZVNsaWNlLmFjdGlvbnM7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBPcGVyYXRpb25FeHBsYWluZWRCb3ggfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25FeHBsYWluZWRCb3gnO1xuaW1wb3J0IHsgT3BlcmF0aW9uTGlzdEV4cGxhaW5lZCB9IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkxpc3RFeHBsYWluZWQnO1xuaW1wb3J0IHsgUmF3UXVlcnkgfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9SYXdRdWVyeSc7XG5cbmltcG9ydCB7IGxva2lHcmFtbWFyIH0gZnJvbSAnLi4vLi4vc3ludGF4JztcbmltcG9ydCB7IGxva2lRdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vTG9raVF1ZXJ5TW9kZWxsZXInO1xuaW1wb3J0IHsgYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcgfSBmcm9tICcuLi9wYXJzaW5nJztcbmltcG9ydCB7IExva2lWaXN1YWxRdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBMb2tpUXVlcnlCdWlsZGVyRXhwbGFpbmVkID0gUmVhY3QubWVtbzxQcm9wcz4oKHsgcXVlcnkgfSkgPT4ge1xuICBjb25zdCB2aXNRdWVyeSA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKHF1ZXJ5IHx8ICcnKS5xdWVyeTtcbiAgY29uc3QgbGFuZyA9IHsgZ3JhbW1hcjogbG9raUdyYW1tYXIsIG5hbWU6ICdsb2tpcWwnIH07XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZ2FwPXswfSBkaXJlY3Rpb249XCJjb2x1bW5cIj5cbiAgICAgIDxPcGVyYXRpb25FeHBsYWluZWRCb3g+XG4gICAgICAgIDxSYXdRdWVyeSBxdWVyeT17cXVlcnl9IGxhbmc9e2xhbmd9IC8+XG4gICAgICA8L09wZXJhdGlvbkV4cGxhaW5lZEJveD5cbiAgICAgIDxPcGVyYXRpb25FeHBsYWluZWRCb3hcbiAgICAgICAgc3RlcE51bWJlcj17MX1cbiAgICAgICAgdGl0bGU9ezxSYXdRdWVyeSBxdWVyeT17YCR7bG9raVF1ZXJ5TW9kZWxsZXIucmVuZGVyTGFiZWxzKHZpc1F1ZXJ5LmxhYmVscyl9YH0gbGFuZz17bGFuZ30gLz59XG4gICAgICA+XG4gICAgICAgIEZldGNoIGFsbCBsb2cgbGluZXMgbWF0Y2hpbmcgbGFiZWwgZmlsdGVycy5cbiAgICAgIDwvT3BlcmF0aW9uRXhwbGFpbmVkQm94PlxuICAgICAgPE9wZXJhdGlvbkxpc3RFeHBsYWluZWQ8TG9raVZpc3VhbFF1ZXJ5PlxuICAgICAgICBzdGVwTnVtYmVyPXsyfVxuICAgICAgICBxdWVyeU1vZGVsbGVyPXtsb2tpUXVlcnlNb2RlbGxlcn1cbiAgICAgICAgcXVlcnk9e3Zpc1F1ZXJ5fVxuICAgICAgICBsYW5nPXtsYW5nfVxuICAgICAgLz5cbiAgICA8L1N0YWNrPlxuICApO1xufSk7XG5cbkxva2lRdWVyeUJ1aWxkZXJFeHBsYWluZWQuZGlzcGxheU5hbWUgPSAnTG9raVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCc7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBDb3JlQXBwLCBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEVkaXRvclJvdywgRWRpdG9yRmllbGQgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgcmVwb3J0SW50ZXJhY3Rpb24gfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCB7IFJhZGlvQnV0dG9uR3JvdXAsIFNlbGVjdCwgQXV0b1NpemVJbnB1dCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IFF1ZXJ5T3B0aW9uR3JvdXAgfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9RdWVyeU9wdGlvbkdyb3VwJztcblxuaW1wb3J0IHsgcHJlcHJvY2Vzc01heExpbmVzLCBxdWVyeVR5cGVPcHRpb25zLCBSRVNPTFVUSU9OX09QVElPTlMgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL0xva2lPcHRpb25GaWVsZHMnO1xuaW1wb3J0IHsgaXNNZXRyaWNzUXVlcnkgfSBmcm9tICcuLi8uLi9kYXRhc291cmNlJztcbmltcG9ydCB7IExva2lRdWVyeSwgTG9raVF1ZXJ5VHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBMb2tpUXVlcnk7XG4gIG9uQ2hhbmdlOiAodXBkYXRlOiBMb2tpUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIGFwcD86IENvcmVBcHA7XG59XG5cbmV4cG9ydCBjb25zdCBMb2tpUXVlcnlCdWlsZGVyT3B0aW9ucyA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IGFwcCwgcXVlcnksIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0pID0+IHtcbiAgY29uc3Qgb25RdWVyeVR5cGVDaGFuZ2UgPSAodmFsdWU6IExva2lRdWVyeVR5cGUpID0+IHtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBxdWVyeVR5cGU6IHZhbHVlIH0pO1xuICAgIG9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICBjb25zdCBvblJlc29sdXRpb25DaGFuZ2UgPSAob3B0aW9uOiBTZWxlY3RhYmxlVmFsdWU8bnVtYmVyPikgPT4ge1xuICAgIHJlcG9ydEludGVyYWN0aW9uKCdncmFmYW5hX2xva2lfcmVzb2x1dGlvbl9jbGlja2VkJywge1xuICAgICAgYXBwLFxuICAgICAgcmVzb2x1dGlvbjogb3B0aW9uLnZhbHVlLFxuICAgIH0pO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIHJlc29sdXRpb246IG9wdGlvbi52YWx1ZSB9KTtcbiAgICBvblJ1blF1ZXJ5KCk7XG4gIH07XG5cbiAgY29uc3Qgb25MZWdlbmRGb3JtYXRDaGFuZ2VkID0gKGV2dDogUmVhY3QuRm9ybUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgbGVnZW5kRm9ybWF0OiBldnQuY3VycmVudFRhcmdldC52YWx1ZSB9KTtcbiAgICBvblJ1blF1ZXJ5KCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gb25NYXhMaW5lc0NoYW5nZShlOiBSZWFjdC5TeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50Pikge1xuICAgIGNvbnN0IG5ld01heExpbmVzID0gcHJlcHJvY2Vzc01heExpbmVzKGUuY3VycmVudFRhcmdldC52YWx1ZSk7XG4gICAgaWYgKHF1ZXJ5Lm1heExpbmVzICE9PSBuZXdNYXhMaW5lcykge1xuICAgICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgbWF4TGluZXM6IG5ld01heExpbmVzIH0pO1xuICAgICAgb25SdW5RdWVyeSgpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBxdWVyeVR5cGUgPSBxdWVyeS5xdWVyeVR5cGUgPz8gKHF1ZXJ5Lmluc3RhbnQgPyBMb2tpUXVlcnlUeXBlLkluc3RhbnQgOiBMb2tpUXVlcnlUeXBlLlJhbmdlKTtcbiAgbGV0IHNob3dNYXhMaW5lcyA9ICFpc01ldHJpY3NRdWVyeShxdWVyeS5leHByKTtcblxuICByZXR1cm4gKFxuICAgIDxFZGl0b3JSb3c+XG4gICAgICA8UXVlcnlPcHRpb25Hcm91cCB0aXRsZT1cIk9wdGlvbnNcIiBjb2xsYXBzZWRJbmZvPXtnZXRDb2xsYXBzZWRJbmZvKHF1ZXJ5LCBxdWVyeVR5cGUsIHNob3dNYXhMaW5lcyl9PlxuICAgICAgICA8RWRpdG9yRmllbGRcbiAgICAgICAgICBsYWJlbD1cIkxlZ2VuZFwiXG4gICAgICAgICAgdG9vbHRpcD1cIlNlcmllcyBuYW1lIG92ZXJyaWRlIG9yIHRlbXBsYXRlLiBFeC4ge3tob3N0bmFtZX19IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBsYWJlbCB2YWx1ZSBmb3IgaG9zdG5hbWUuXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxBdXRvU2l6ZUlucHV0XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cInt7bGFiZWx9fVwiXG4gICAgICAgICAgICBpZD1cImxva2ktcXVlcnktZWRpdG9yLWxlZ2VuZC1mb3JtYXRcIlxuICAgICAgICAgICAgdHlwZT1cInN0cmluZ1wiXG4gICAgICAgICAgICBtaW5XaWR0aD17MTR9XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU9e3F1ZXJ5LmxlZ2VuZEZvcm1hdH1cbiAgICAgICAgICAgIG9uQ29tbWl0Q2hhbmdlPXtvbkxlZ2VuZEZvcm1hdENoYW5nZWR9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiVHlwZVwiPlxuICAgICAgICAgIDxSYWRpb0J1dHRvbkdyb3VwIG9wdGlvbnM9e3F1ZXJ5VHlwZU9wdGlvbnN9IHZhbHVlPXtxdWVyeVR5cGV9IG9uQ2hhbmdlPXtvblF1ZXJ5VHlwZUNoYW5nZX0gLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAge3Nob3dNYXhMaW5lcyAmJiAoXG4gICAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiTGluZSBsaW1pdFwiIHRvb2x0aXA9XCJVcHBlciBsaW1pdCBmb3IgbnVtYmVyIG9mIGxvZyBsaW5lcyByZXR1cm5lZCBieSBxdWVyeS5cIj5cbiAgICAgICAgICAgIDxBdXRvU2l6ZUlucHV0XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTRcIlxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cImF1dG9cIlxuICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgbWluPXswfVxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9e3F1ZXJ5Lm1heExpbmVzPy50b1N0cmluZygpID8/ICcnfVxuICAgICAgICAgICAgICBvbkNvbW1pdENoYW5nZT17b25NYXhMaW5lc0NoYW5nZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAgKX1cbiAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiUmVzb2x1dGlvblwiPlxuICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgIGlzU2VhcmNoYWJsZT17ZmFsc2V9XG4gICAgICAgICAgICBvbkNoYW5nZT17b25SZXNvbHV0aW9uQ2hhbmdlfVxuICAgICAgICAgICAgb3B0aW9ucz17UkVTT0xVVElPTl9PUFRJT05TfVxuICAgICAgICAgICAgdmFsdWU9e3F1ZXJ5LnJlc29sdXRpb24gfHwgMX1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJTZWxlY3QgcmVzb2x1dGlvblwiXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgIDwvUXVlcnlPcHRpb25Hcm91cD5cbiAgICA8L0VkaXRvclJvdz5cbiAgKTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRDb2xsYXBzZWRJbmZvKHF1ZXJ5OiBMb2tpUXVlcnksIHF1ZXJ5VHlwZTogTG9raVF1ZXJ5VHlwZSwgc2hvd01heExpbmVzOiBib29sZWFuKTogc3RyaW5nW10ge1xuICBjb25zdCBxdWVyeVR5cGVMYWJlbCA9IHF1ZXJ5VHlwZU9wdGlvbnMuZmluZCgoeCkgPT4geC52YWx1ZSA9PT0gcXVlcnlUeXBlKTtcbiAgY29uc3QgcmVzb2x1dGlvbkxhYmVsID0gUkVTT0xVVElPTl9PUFRJT05TLmZpbmQoKHgpID0+IHgudmFsdWUgPT09IChxdWVyeS5yZXNvbHV0aW9uID8/IDEpKTtcblxuICBjb25zdCBpdGVtczogc3RyaW5nW10gPSBbXTtcblxuICBpZiAocXVlcnkubGVnZW5kRm9ybWF0KSB7XG4gICAgaXRlbXMucHVzaChgTGVnZW5kOiAke3F1ZXJ5LmxlZ2VuZEZvcm1hdH1gKTtcbiAgfVxuXG4gIGlmIChxdWVyeS5yZXNvbHV0aW9uKSB7XG4gICAgaXRlbXMucHVzaChgUmVzb2x1dGlvbjogJHtyZXNvbHV0aW9uTGFiZWw/LmxhYmVsfWApO1xuICB9XG5cbiAgaXRlbXMucHVzaChgVHlwZTogJHtxdWVyeVR5cGVMYWJlbD8ubGFiZWx9YCk7XG5cbiAgaWYgKHNob3dNYXhMaW5lcyAmJiBxdWVyeS5tYXhMaW5lcykge1xuICAgIGl0ZW1zLnB1c2goYExpbmUgbGltaXQ6ICR7cXVlcnkubWF4TGluZXN9YCk7XG4gIH1cblxuICByZXR1cm4gaXRlbXM7XG59XG5cbkxva2lRdWVyeUJ1aWxkZXJPcHRpb25zLmRpc3BsYXlOYW1lID0gJ0xva2lRdWVyeUJ1aWxkZXJPcHRpb25zJztcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBDb3JlQXBwLCBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyB0ZXN0SWRzIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9Mb2tpUXVlcnlFZGl0b3InO1xuaW1wb3J0IHsgTG9raVF1ZXJ5RmllbGQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL0xva2lRdWVyeUZpZWxkJztcbmltcG9ydCB7IExva2lRdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBMb2tpUXVlcnlDb2RlRWRpdG9yKHtcbiAgcXVlcnksXG4gIGRhdGFzb3VyY2UsXG4gIHJhbmdlLFxuICBvblJ1blF1ZXJ5LFxuICBvbkNoYW5nZSxcbiAgZGF0YSxcbiAgYXBwLFxufTogTG9raVF1ZXJ5RWRpdG9yUHJvcHMpIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIC8vIHRoZSBpbm5lciBRdWVyeUZpZWxkIHdvcmtzIGxpa2UgdGhpcyB3aGVuIGEgYmx1ciBldmVudCBoYXBwZW5zOlxuICAvLyAtIGlmIGl0IGhhcyBhbiBvbkJsdXIgcHJvcCwgaXQgY2FsbHMgaXRcbiAgLy8gLSBlbHNlIGl0IGNhbGxzIG9uUnVuUXVlcnkgKHNvbWUgZXh0cmEgY29uZGl0aW9ucyBhcHBseSlcbiAgLy9cbiAgLy8gd2Ugd2FudCBpdCB0byBub3QgZG8gYW55dGhpbmcgd2hlbiBhIGJsdXIgZXZlbnQgaGFwcGVucyBpbiBleHBsb3JlIG1vZGUsXG4gIC8vIHNvIHdlIHNldCBhbiBlbXB0eS1mdW5jdGlvbiBpbiBzdWNoIGNhc2UuIG90aGVyd2lzZSB3ZSBzZXQgYHVuZGVmaW5lZGAsXG4gIC8vIHdoaWNoIHdpbGwgY2F1c2UgaXQgdG8gcnVuIHRoZSBxdWVyeSB3aGVuIGJsdXIgaGFwcGVucy5cbiAgY29uc3Qgb25CbHVyID0gYXBwID09PSBDb3JlQXBwLkV4cGxvcmUgPyAoKSA9PiB1bmRlZmluZWQgOiB1bmRlZmluZWQ7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLndyYXBwZXJ9PlxuICAgICAgPExva2lRdWVyeUZpZWxkXG4gICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgcmFuZ2U9e3JhbmdlfVxuICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAgIG9uQmx1cj17b25CbHVyfVxuICAgICAgICBoaXN0b3J5PXtbXX1cbiAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMuZWRpdG9yfVxuICAgICAgICBhcHA9e2FwcH1cbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgd3JhcHBlciBzdHlsaW5nIGNhbiBiZSByZW1vdmVkIGFmdGVyIHRoZSBvbGQgUHJvbVF1ZXJ5RWRpdG9yIGlzIHJlbW92ZWQuXG4gICAgLy8gVGhpcyBpcyByZW1vdmluZyBtYXJnaW4gYm90dG9tIG9uIHRoZSBvbGQgbGVnYWN5IGlubGluZSBmb3JtIHN0eWxlc1xuICAgIHdyYXBwZXI6IGNzc2BcbiAgICAgIC5nZi1mb3JtIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgIH1cbiAgICBgLFxuICB9O1xufTtcbiIsImltcG9ydCBSZWFjdCwgeyBTeW50aGV0aWNFdmVudCwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IENvcmVBcHAsIExvYWRpbmdTdGF0ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9ySGVhZGVyLCBFZGl0b3JSb3dzLCBGbGV4SXRlbSwgSW5saW5lU2VsZWN0LCBTcGFjZSB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyByZXBvcnRJbnRlcmFjdGlvbiB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgQnV0dG9uLCBDb25maXJtTW9kYWwgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBGZWVkYmFja0xpbmsgfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9GZWVkYmFja0xpbmsnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlVG9nZ2xlIH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvUXVlcnlFZGl0b3JNb2RlVG9nZ2xlJztcbmltcG9ydCB7IFF1ZXJ5SGVhZGVyU3dpdGNoIH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvUXVlcnlIZWFkZXJTd2l0Y2gnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBMb2tpUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvdHlwZXMnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5IH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgbG9raVF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9Mb2tpUXVlcnlNb2RlbGxlcic7XG5pbXBvcnQgeyBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyB9IGZyb20gJy4uL3BhcnNpbmcnO1xuaW1wb3J0IHsgY2hhbmdlRWRpdG9yTW9kZSwgZ2V0UXVlcnlXaXRoRGVmYXVsdHMsIHVzZVJhd1F1ZXJ5IH0gZnJvbSAnLi4vc3RhdGUnO1xuXG5pbXBvcnQgeyBMb2tpUXVlcnlCdWlsZGVyQ29udGFpbmVyIH0gZnJvbSAnLi9Mb2tpUXVlcnlCdWlsZGVyQ29udGFpbmVyJztcbmltcG9ydCB7IExva2lRdWVyeUJ1aWxkZXJFeHBsYWluZWQgfSBmcm9tICcuL0xva2lRdWVyeUJ1aWxkZXJFeHBsYWluZWQnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5QnVpbGRlck9wdGlvbnMgfSBmcm9tICcuL0xva2lRdWVyeUJ1aWxkZXJPcHRpb25zJztcbmltcG9ydCB7IExva2lRdWVyeUNvZGVFZGl0b3IgfSBmcm9tICcuL0xva2lRdWVyeUNvZGVFZGl0b3InO1xuXG5leHBvcnQgY29uc3QgTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3IgPSBSZWFjdC5tZW1vPExva2lRdWVyeUVkaXRvclByb3BzPigocHJvcHMpID0+IHtcbiAgY29uc3QgeyBvbkNoYW5nZSwgb25SdW5RdWVyeSwgZGF0YSwgYXBwIH0gPSBwcm9wcztcbiAgY29uc3QgW3BhcnNlTW9kYWxPcGVuLCBzZXRQYXJzZU1vZGFsT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtkYXRhSXNTdGFsZSwgc2V0RGF0YUlzU3RhbGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IHF1ZXJ5ID0gZ2V0UXVlcnlXaXRoRGVmYXVsdHMocHJvcHMucXVlcnkpO1xuICBjb25zdCBbcmF3UXVlcnksIHNldFJhd1F1ZXJ5XSA9IHVzZVJhd1F1ZXJ5KCk7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGZpbGxlZCBpbiBmcm9tIHRoZSBkZWZhdWx0cyBieSBub3cuXG4gIGNvbnN0IGVkaXRvck1vZGUgPSBxdWVyeS5lZGl0b3JNb2RlITtcblxuICBjb25zdCBvbkVkaXRvck1vZGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAobmV3RWRpdG9yTW9kZTogUXVlcnlFZGl0b3JNb2RlKSA9PiB7XG4gICAgICByZXBvcnRJbnRlcmFjdGlvbignZ3JhZmFuYV9sb2tpX2VkaXRvcl9tb2RlX2NsaWNrZWQnLCB7XG4gICAgICAgIG5ld0VkaXRvcjogbmV3RWRpdG9yTW9kZSxcbiAgICAgICAgcHJldmlvdXNFZGl0b3I6IHF1ZXJ5LmVkaXRvck1vZGUgPz8gJycsXG4gICAgICAgIG5ld1F1ZXJ5OiAhcXVlcnkuZXhwcixcbiAgICAgICAgYXBwOiBhcHAgPz8gJycsXG4gICAgICB9KTtcblxuICAgICAgaWYgKG5ld0VkaXRvck1vZGUgPT09IFF1ZXJ5RWRpdG9yTW9kZS5CdWlsZGVyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKHF1ZXJ5LmV4cHIgfHwgJycpO1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgZXJyb3JzLCBnaXZlIHVzZXIgYSBjaGFuY2UgdG8gZGVjaWRlIGlmIHRoZXkgd2FudCB0byBnbyB0byBidWlsZGVyIGFzIHRoYXQgY2FuIGxvb3NlIHNvbWUgZGF0YS5cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgc2V0UGFyc2VNb2RhbE9wZW4odHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGFuZ2VFZGl0b3JNb2RlKHF1ZXJ5LCBuZXdFZGl0b3JNb2RlLCBvbkNoYW5nZSk7XG4gICAgfSxcbiAgICBbb25DaGFuZ2UsIHF1ZXJ5LCBhcHBdXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXREYXRhSXNTdGFsZShmYWxzZSk7XG4gIH0sIFtkYXRhXSk7XG5cbiAgY29uc3Qgb25DaGFuZ2VJbnRlcm5hbCA9IChxdWVyeTogTG9raVF1ZXJ5KSA9PiB7XG4gICAgc2V0RGF0YUlzU3RhbGUodHJ1ZSk7XG4gICAgb25DaGFuZ2UocXVlcnkpO1xuICB9O1xuXG4gIGNvbnN0IG9uUXVlcnlQcmV2aWV3Q2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGlzRW5hYmxlZCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuY2hlY2tlZDtcbiAgICBzZXRSYXdRdWVyeShpc0VuYWJsZWQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxDb25maXJtTW9kYWxcbiAgICAgICAgaXNPcGVuPXtwYXJzZU1vZGFsT3Blbn1cbiAgICAgICAgdGl0bGU9XCJRdWVyeSBwYXJzaW5nXCJcbiAgICAgICAgYm9keT1cIlRoZXJlIHdlcmUgZXJyb3JzIHdoaWxlIHRyeWluZyB0byBwYXJzZSB0aGUgcXVlcnkuIENvbnRpbnVpbmcgdG8gdmlzdWFsIGJ1aWxkZXIgbWF5IGxvb3NlIHNvbWUgcGFydHMgb2YgdGhlIHF1ZXJ5LlwiXG4gICAgICAgIGNvbmZpcm1UZXh0PVwiQ29udGludWVcIlxuICAgICAgICBvbkNvbmZpcm09eygpID0+IHtcbiAgICAgICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBlZGl0b3JNb2RlOiBRdWVyeUVkaXRvck1vZGUuQnVpbGRlciB9KTtcbiAgICAgICAgICBzZXRQYXJzZU1vZGFsT3BlbihmYWxzZSk7XG4gICAgICAgIH19XG4gICAgICAgIG9uRGlzbWlzcz17KCkgPT4gc2V0UGFyc2VNb2RhbE9wZW4oZmFsc2UpfVxuICAgICAgLz5cbiAgICAgIDxFZGl0b3JIZWFkZXI+XG4gICAgICAgIDxJbmxpbmVTZWxlY3RcbiAgICAgICAgICB2YWx1ZT17bnVsbH1cbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIlF1ZXJ5IHBhdHRlcm5zXCJcbiAgICAgICAgICBhbGxvd0N1c3RvbVZhbHVlXG4gICAgICAgICAgb25DaGFuZ2U9eyh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKHF1ZXJ5LmV4cHIgfHwgJycpO1xuICAgICAgICAgICAgcmVzdWx0LnF1ZXJ5Lm9wZXJhdGlvbnMgPSB2YWx1ZT8ub3BlcmF0aW9ucyE7XG4gICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICBleHByOiBsb2tpUXVlcnlNb2RlbGxlci5yZW5kZXJRdWVyeShyZXN1bHQucXVlcnkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBvcHRpb25zPXtsb2tpUXVlcnlNb2RlbGxlci5nZXRRdWVyeVBhdHRlcm5zKCkubWFwKCh4KSA9PiAoeyBsYWJlbDogeC5uYW1lLCB2YWx1ZTogeCB9KSl9XG4gICAgICAgIC8+XG4gICAgICAgIHtlZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuQnVpbGRlciAmJiAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDxRdWVyeUhlYWRlclN3aXRjaCBsYWJlbD1cIlJhdyBxdWVyeVwiIHZhbHVlPXtyYXdRdWVyeX0gb25DaGFuZ2U9e29uUXVlcnlQcmV2aWV3Q2hhbmdlfSAvPlxuICAgICAgICAgICAgPEZlZWRiYWNrTGluayBmZWVkYmFja1VybD1cImh0dHBzOi8vZ2l0aHViLmNvbS9ncmFmYW5hL2dyYWZhbmEvZGlzY3Vzc2lvbnMvNTA3ODVcIiAvPlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgICA8RmxleEl0ZW0gZ3Jvdz17MX0gLz5cbiAgICAgICAge2FwcCAhPT0gQ29yZUFwcC5FeHBsb3JlICYmIChcbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICB2YXJpYW50PXtkYXRhSXNTdGFsZSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknfVxuICAgICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9e29uUnVuUXVlcnl9XG4gICAgICAgICAgICBpY29uPXtkYXRhPy5zdGF0ZSA9PT0gTG9hZGluZ1N0YXRlLkxvYWRpbmcgPyAnZmEgZmEtc3Bpbm5lcicgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICBkaXNhYmxlZD17ZGF0YT8uc3RhdGUgPT09IExvYWRpbmdTdGF0ZS5Mb2FkaW5nfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIFJ1biBxdWVyaWVzXG4gICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICl9XG4gICAgICAgIDxRdWVyeUVkaXRvck1vZGVUb2dnbGUgbW9kZT17ZWRpdG9yTW9kZSF9IG9uQ2hhbmdlPXtvbkVkaXRvck1vZGVDaGFuZ2V9IC8+XG4gICAgICA8L0VkaXRvckhlYWRlcj5cbiAgICAgIDxTcGFjZSB2PXswLjV9IC8+XG4gICAgICA8RWRpdG9yUm93cz5cbiAgICAgICAge2VkaXRvck1vZGUgPT09IFF1ZXJ5RWRpdG9yTW9kZS5Db2RlICYmIDxMb2tpUXVlcnlDb2RlRWRpdG9yIHsuLi5wcm9wc30gb25DaGFuZ2U9e29uQ2hhbmdlSW50ZXJuYWx9IC8+fVxuICAgICAgICB7ZWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIgJiYgKFxuICAgICAgICAgIDxMb2tpUXVlcnlCdWlsZGVyQ29udGFpbmVyXG4gICAgICAgICAgICBkYXRhc291cmNlPXtwcm9wcy5kYXRhc291cmNlfVxuICAgICAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlSW50ZXJuYWx9XG4gICAgICAgICAgICBvblJ1blF1ZXJ5PXtwcm9wcy5vblJ1blF1ZXJ5fVxuICAgICAgICAgICAgc2hvd1Jhd1F1ZXJ5PXtyYXdRdWVyeX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgICB7ZWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW4gJiYgPExva2lRdWVyeUJ1aWxkZXJFeHBsYWluZWQgcXVlcnk9e3F1ZXJ5LmV4cHJ9IC8+fVxuICAgICAgICB7ZWRpdG9yTW9kZSAhPT0gUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW4gJiYgKFxuICAgICAgICAgIDxMb2tpUXVlcnlCdWlsZGVyT3B0aW9ucyBxdWVyeT17cXVlcnl9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gb25SdW5RdWVyeT17b25SdW5RdWVyeX0gYXBwPXthcHB9IC8+XG4gICAgICAgICl9XG4gICAgICA8L0VkaXRvclJvd3M+XG4gICAgPC8+XG4gICk7XG59KTtcblxuTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3IuZGlzcGxheU5hbWUgPSAnTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3InO1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIsIHRvT3B0aW9uIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JSb3dzLCBGbGV4SXRlbSB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBBdXRvU2l6ZUlucHV0LCBJY29uQnV0dG9uLCBTZWxlY3QsIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IExva2lEYXRhc291cmNlIH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBiaW5hcnlTY2FsYXJEZWZzIH0gZnJvbSAnLi4vYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBMb2tpVmlzdWFsUXVlcnlCaW5hcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IExva2lRdWVyeUJ1aWxkZXIgfSBmcm9tICcuL0xva2lRdWVyeUJ1aWxkZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgbmVzdGVkUXVlcnk6IExva2lWaXN1YWxRdWVyeUJpbmFyeTtcbiAgZGF0YXNvdXJjZTogTG9raURhdGFzb3VyY2U7XG4gIGluZGV4OiBudW1iZXI7XG4gIG9uQ2hhbmdlOiAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBMb2tpVmlzdWFsUXVlcnlCaW5hcnkpID0+IHZvaWQ7XG4gIG9uUmVtb3ZlOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGNvbnN0IE5lc3RlZFF1ZXJ5ID0gUmVhY3QubWVtbzxQcm9wcz4oKHsgbmVzdGVkUXVlcnksIGluZGV4LCBkYXRhc291cmNlLCBvbkNoYW5nZSwgb25SZW1vdmUsIG9uUnVuUXVlcnkgfSkgPT4ge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNhcmR9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5oZWFkZXJ9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLm5hbWV9Pk9wZXJhdG9yPC9kaXY+XG4gICAgICAgIDxTZWxlY3RcbiAgICAgICAgICB3aWR0aD1cImF1dG9cIlxuICAgICAgICAgIG9wdGlvbnM9e29wZXJhdG9yc31cbiAgICAgICAgICB2YWx1ZT17dG9PcHRpb24obmVzdGVkUXVlcnkub3BlcmF0b3IpfVxuICAgICAgICAgIG9uQ2hhbmdlPXsodmFsdWUpID0+IHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKGluZGV4LCB7XG4gICAgICAgICAgICAgIC4uLm5lc3RlZFF1ZXJ5LFxuICAgICAgICAgICAgICBvcGVyYXRvcjogdmFsdWUudmFsdWUhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5uYW1lfT5WZWN0b3IgbWF0Y2hlczwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnZlY3Rvck1hdGNoV3JhcHBlcn0+XG4gICAgICAgICAgPFNlbGVjdDxMb2tpVmlzdWFsUXVlcnlCaW5hcnlbJ3ZlY3Rvck1hdGNoZXNUeXBlJ10+XG4gICAgICAgICAgICB3aWR0aD1cImF1dG9cIlxuICAgICAgICAgICAgdmFsdWU9e25lc3RlZFF1ZXJ5LnZlY3Rvck1hdGNoZXNUeXBlIHx8ICdvbid9XG4gICAgICAgICAgICBhbGxvd0N1c3RvbVZhbHVlXG4gICAgICAgICAgICBvcHRpb25zPXtbXG4gICAgICAgICAgICAgIHsgdmFsdWU6ICdvbicsIGxhYmVsOiAnb24nIH0sXG4gICAgICAgICAgICAgIHsgdmFsdWU6ICdpZ25vcmluZycsIGxhYmVsOiAnaWdub3JpbmcnIH0sXG4gICAgICAgICAgICBdfVxuICAgICAgICAgICAgb25DaGFuZ2U9eyh2YWwpID0+IHtcbiAgICAgICAgICAgICAgb25DaGFuZ2UoaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAuLi5uZXN0ZWRRdWVyeSxcbiAgICAgICAgICAgICAgICB2ZWN0b3JNYXRjaGVzVHlwZTogdmFsLnZhbHVlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8QXV0b1NpemVJbnB1dFxuICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudmVjdG9yTWF0Y2hJbnB1dH1cbiAgICAgICAgICAgIG1pbldpZHRoPXsyMH1cbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17bmVzdGVkUXVlcnkudmVjdG9yTWF0Y2hlc31cbiAgICAgICAgICAgIG9uQ29tbWl0Q2hhbmdlPXsoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKGluZGV4LCB7XG4gICAgICAgICAgICAgICAgLi4ubmVzdGVkUXVlcnksXG4gICAgICAgICAgICAgICAgdmVjdG9yTWF0Y2hlczogZXZ0LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICAgICAgICAgICAgdmVjdG9yTWF0Y2hlc1R5cGU6IG5lc3RlZFF1ZXJ5LnZlY3Rvck1hdGNoZXNUeXBlIHx8ICdvbicsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPEZsZXhJdGVtIGdyb3c9ezF9IC8+XG4gICAgICAgIDxJY29uQnV0dG9uIG5hbWU9XCJ0aW1lc1wiIHNpemU9XCJzbVwiIG9uQ2xpY2s9eygpID0+IG9uUmVtb3ZlKGluZGV4KX0gLz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ib2R5fT5cbiAgICAgICAgPEVkaXRvclJvd3M+XG4gICAgICAgICAgPExva2lRdWVyeUJ1aWxkZXJcbiAgICAgICAgICAgIHF1ZXJ5PXtuZXN0ZWRRdWVyeS5xdWVyeX1cbiAgICAgICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgICAgICBuZXN0ZWQ9e3RydWV9XG4gICAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAgICAgb25DaGFuZ2U9eyh1cGRhdGUpID0+IHtcbiAgICAgICAgICAgICAgb25DaGFuZ2UoaW5kZXgsIHsgLi4ubmVzdGVkUXVlcnksIHF1ZXJ5OiB1cGRhdGUgfSk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvRWRpdG9yUm93cz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufSk7XG5cbmNvbnN0IG9wZXJhdG9ycyA9IGJpbmFyeVNjYWxhckRlZnMubWFwKChkZWYpID0+ICh7IGxhYmVsOiBkZWYuc2lnbiwgdmFsdWU6IGRlZi5zaWduIH0pKTtcblxuTmVzdGVkUXVlcnkuZGlzcGxheU5hbWUgPSAnTmVzdGVkUXVlcnknO1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjYXJkOiBjc3Moe1xuICAgICAgbGFiZWw6ICdjYXJkJyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgZ2FwOiB0aGVtZS5zcGFjaW5nKDAuNSksXG4gICAgfSksXG4gICAgaGVhZGVyOiBjc3Moe1xuICAgICAgbGFiZWw6ICdoZWFkZXInLFxuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZygwLjUsIDAuNSwgMC41LCAxKSxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygxKSxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIH0pLFxuICAgIG5hbWU6IGNzcyh7XG4gICAgICBsYWJlbDogJ25hbWUnLFxuICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgfSksXG4gICAgYm9keTogY3NzKHtcbiAgICAgIGxhYmVsOiAnYm9keScsXG4gICAgICBwYWRkaW5nTGVmdDogdGhlbWUuc3BhY2luZygyKSxcbiAgICB9KSxcbiAgICB2ZWN0b3JNYXRjaElucHV0OiBjc3Moe1xuICAgICAgbGFiZWw6ICd2ZWN0b3JNYXRjaElucHV0JyxcbiAgICAgIG1hcmdpbkxlZnQ6IC0xLFxuICAgIH0pLFxuICAgIHZlY3Rvck1hdGNoV3JhcHBlcjogY3NzKHtcbiAgICAgIGxhYmVsOiAndmVjdG9yTWF0Y2hXcmFwcGVyJyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5cbmltcG9ydCB7IExva2lEYXRhc291cmNlIH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBMb2tpVmlzdWFsUXVlcnksIExva2lWaXN1YWxRdWVyeUJpbmFyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgTmVzdGVkUXVlcnkgfSBmcm9tICcuL05lc3RlZFF1ZXJ5JztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBMb2tpVmlzdWFsUXVlcnk7XG4gIGRhdGFzb3VyY2U6IExva2lEYXRhc291cmNlO1xuICBvbkNoYW5nZTogKHF1ZXJ5OiBMb2tpVmlzdWFsUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBOZXN0ZWRRdWVyeUxpc3QoeyBxdWVyeSwgZGF0YXNvdXJjZSwgb25DaGFuZ2UsIG9uUnVuUXVlcnkgfTogUHJvcHMpIHtcbiAgY29uc3QgbmVzdGVkUXVlcmllcyA9IHF1ZXJ5LmJpbmFyeVF1ZXJpZXMgPz8gW107XG5cbiAgY29uc3Qgb25OZXN0ZWRRdWVyeVVwZGF0ZSA9IChpbmRleDogbnVtYmVyLCB1cGRhdGU6IExva2lWaXN1YWxRdWVyeUJpbmFyeSkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWRMaXN0ID0gWy4uLm5lc3RlZFF1ZXJpZXNdO1xuICAgIHVwZGF0ZWRMaXN0LnNwbGljZShpbmRleCwgMSwgdXBkYXRlKTtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBiaW5hcnlRdWVyaWVzOiB1cGRhdGVkTGlzdCB9KTtcbiAgfTtcblxuICBjb25zdCBvblJlbW92ZSA9IChpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZExpc3QgPSBbLi4ubmVzdGVkUXVlcmllcy5zbGljZSgwLCBpbmRleCksIC4uLm5lc3RlZFF1ZXJpZXMuc2xpY2UoaW5kZXggKyAxKV07XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgYmluYXJ5UXVlcmllczogdXBkYXRlZExpc3QgfSk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZGlyZWN0aW9uPVwiY29sdW1uXCIgZ2FwPXsxfT5cbiAgICAgIHtuZXN0ZWRRdWVyaWVzLm1hcCgobmVzdGVkUXVlcnksIGluZGV4KSA9PiAoXG4gICAgICAgIDxOZXN0ZWRRdWVyeVxuICAgICAgICAgIGtleT17aW5kZXgudG9TdHJpbmcoKX1cbiAgICAgICAgICBuZXN0ZWRRdWVyeT17bmVzdGVkUXVlcnl9XG4gICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgIG9uQ2hhbmdlPXtvbk5lc3RlZFF1ZXJ5VXBkYXRlfVxuICAgICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgICAgb25SZW1vdmU9e29uUmVtb3ZlfVxuICAgICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgIC8+XG4gICAgICApKX1cbiAgICA8L1N0YWNrPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRWRpdG9yRmllbGQsIEVkaXRvckZpZWxkR3JvdXAsIEVkaXRvclJvdyB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5cbmltcG9ydCB7IFJhd1F1ZXJ5IH0gZnJvbSAnLi4vLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL1Jhd1F1ZXJ5JztcbmltcG9ydCB7IGxva2lHcmFtbWFyIH0gZnJvbSAnLi4vLi4vc3ludGF4JztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeVByZXZpZXcoeyBxdWVyeSB9OiBQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxFZGl0b3JSb3c+XG4gICAgICA8RWRpdG9yRmllbGRHcm91cD5cbiAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiUmF3IHF1ZXJ5XCI+XG4gICAgICAgICAgPFJhd1F1ZXJ5IHF1ZXJ5PXtxdWVyeX0gbGFuZz17eyBncmFtbWFyOiBsb2tpR3JhbW1hciwgbmFtZTogJ2xva2lxbCcgfX0gLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgIDwvRWRpdG9yRmllbGRHcm91cD5cbiAgICA8L0VkaXRvclJvdz5cbiAgKTtcbn1cbiIsImltcG9ydCB7XG4gIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uLFxuICBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbSxcbiAgZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZSxcbn0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL29wZXJhdGlvblV0aWxzJztcbmltcG9ydCB7XG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZixcbiAgVmlzdWFsUXVlcnlNb2RlbGxlcixcbn0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IEZVTkNUSU9OUyB9IGZyb20gJy4uL3N5bnRheCc7XG5cbmltcG9ydCB7IGJpbmFyeVNjYWxhck9wZXJhdGlvbnMgfSBmcm9tICcuL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMnO1xuaW1wb3J0IHsgTG9raU9wZXJhdGlvbklkLCBMb2tpT3BlcmF0aW9uT3JkZXIsIExva2lWaXN1YWxRdWVyeSwgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdGlvbkRlZmluaXRpb25zKCk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdIHtcbiAgY29uc3QgYWdncmVnYXRpb25zID0gW1xuICAgIExva2lPcGVyYXRpb25JZC5TdW0sXG4gICAgTG9raU9wZXJhdGlvbklkLk1pbixcbiAgICBMb2tpT3BlcmF0aW9uSWQuTWF4LFxuICAgIExva2lPcGVyYXRpb25JZC5BdmcsXG4gICAgTG9raU9wZXJhdGlvbklkLlN0ZGRldixcbiAgICBMb2tpT3BlcmF0aW9uSWQuU3RkdmFyLFxuICAgIExva2lPcGVyYXRpb25JZC5Db3VudCxcbiAgXS5mbGF0TWFwKChvcElkKSA9PlxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uKG9wSWQsIHtcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MYXN0LFxuICAgIH0pXG4gICk7XG5cbiAgY29uc3QgYWdncmVnYXRpb25zV2l0aFBhcmFtID0gW0xva2lPcGVyYXRpb25JZC5Ub3BLLCBMb2tpT3BlcmF0aW9uSWQuQm90dG9tS10uZmxhdE1hcCgob3BJZCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbShcbiAgICAgIG9wSWQsXG4gICAgICB7XG4gICAgICAgIHBhcmFtczogW3sgbmFtZTogJ0stdmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgICAgZGVmYXVsdFBhcmFtczogWzVdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGFzdCxcbiAgICAgIH1cbiAgICApO1xuICB9KTtcblxuICBjb25zdCBsaXN0OiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSA9IFtcbiAgICBjcmVhdGVSYW5nZU9wZXJhdGlvbihMb2tpT3BlcmF0aW9uSWQuUmF0ZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkNvdW50T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5TdW1PdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkJ5dGVzUmF0ZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkJ5dGVzT3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5BYnNlbnRPdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkF2Z092ZXJUaW1lKSxcbiAgICBjcmVhdGVSYW5nZU9wZXJhdGlvbihMb2tpT3BlcmF0aW9uSWQuTWF4T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5NaW5PdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkZpcnN0T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5MYXN0T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5TdGR2YXJPdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLlN0ZGRldk92ZXJUaW1lKSxcbiAgICBjcmVhdGVSYW5nZU9wZXJhdGlvbihMb2tpT3BlcmF0aW9uSWQuUXVhbnRpbGVPdmVyVGltZSksXG4gICAgLi4uYWdncmVnYXRpb25zLFxuICAgIC4uLmFnZ3JlZ2F0aW9uc1dpdGhQYXJhbSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkpzb24sXG4gICAgICBuYW1lOiAnSnNvbicsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiBwaXBlbGluZVJlbmRlcmVyLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTG9nZm10LFxuICAgICAgbmFtZTogJ0xvZ2ZtdCcsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiBwaXBlbGluZVJlbmRlcmVyLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhpcyB3aWxsIGV4dHJhY3QgYWxsIGtleXMgYW5kIHZhbHVlcyBmcm9tIGEgW2xvZ2ZtdF0oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyNsb2dmbXQpIGZvcm1hdHRlZCBsb2cgbGluZSBhcyBsYWJlbHMuIFRoZSBleHRyYWN0ZWQgbGFiZWxzIGNhbiBiZSB1c2VkIGluIGxhYmVsIGZpbHRlciBleHByZXNzaW9ucyBhbmQgdXNlZCBhcyB2YWx1ZXMgZm9yIGEgcmFuZ2UgYWdncmVnYXRpb24gdmlhIHRoZSB1bndyYXAgb3BlcmF0aW9uLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLlJlZ2V4cCxcbiAgICAgIG5hbWU6ICdSZWdleHAnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnU3RyaW5nJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBoaWRlTmFtZTogdHJ1ZSxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJzxyZT4nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIHJlZ2V4cCBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyB0aGUgc3RydWN0dXJlIG9mIGEgbG9nIGxpbmUuJyxcbiAgICAgICAgICBtaW5XaWR0aDogMjAsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ2Zvcm1hdCcsXG4gICAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRm9ybWF0cyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLkxpbmVGb3JtYXRzLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCwgZGVmLCBpbm5lckV4cHIpID0+IGAke2lubmVyRXhwcn0gfCByZWdleHAgXFxgJHttb2RlbC5wYXJhbXNbMF19XFxgYCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKCkgPT5cbiAgICAgICAgYFRoZSBbcmVnZXhwIHBhcnNlcl0oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyNyZWd1bGFyLWV4cHJlc3Npb24pIHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlciB8IHJlZ2V4cCBcIjxyZT5cIiB3aGljaCBpcyB0aGUgcmVndWxhciBleHByZXNzaW9uIHVzaW5nIHRoZSBHb2xhbmcgUkUyIHN5bnRheC4gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBtdXN0IGNvbnRhaW4gYSBsZWFzdCBvbmUgbmFtZWQgc3ViLW1hdGNoIChlLmcgKD9QPG5hbWU+cmUpKSwgZWFjaCBzdWItbWF0Y2ggd2lsbCBleHRyYWN0IGEgZGlmZmVyZW50IGxhYmVsLiBUaGUgZXhwcmVzc2lvbiBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgYSBsb2cgbGluZS4gVGhlIGV4dHJhY3RlZCBsYWJlbHMgY2FuIGJlIHVzZWQgaW4gbGFiZWwgZmlsdGVyIGV4cHJlc3Npb25zIGFuZCB1c2VkIGFzIHZhbHVlcyBmb3IgYSByYW5nZSBhZ2dyZWdhdGlvbiB2aWEgdGhlIHVud3JhcCBvcGVyYXRpb24uYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuUGF0dGVybixcbiAgICAgIG5hbWU6ICdQYXR0ZXJuJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ1N0cmluZycsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgaGlkZU5hbWU6IHRydWUsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICc8cGF0dGVybi1leHByZXNzaW9uPicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgdGhlIHN0cnVjdHVyZSBvZiBhIGxvZyBsaW5lLicsXG4gICAgICAgICAgbWluV2lkdGg6IDIwLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJ10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwsIGRlZiwgaW5uZXJFeHByKSA9PiBgJHtpbm5lckV4cHJ9IHwgcGF0dGVybiBcXGAke21vZGVsLnBhcmFtc1swXX1cXGBgLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhlIFtwYXR0ZXJuIHBhcnNlcl0oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyNwYXR0ZXJuKSBhbGxvd3MgdGhlIGV4cGxpY2l0IGV4dHJhY3Rpb24gb2YgZmllbGRzIGZyb20gbG9nIGxpbmVzIGJ5IGRlZmluaW5nIGEgcGF0dGVybiBleHByZXNzaW9uICh8IHBhdHRlcm4gXFxgPHBhdHRlcm4tZXhwcmVzc2lvbj5cXGApLiBUaGUgZXhwcmVzc2lvbiBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgYSBsb2cgbGluZS4gVGhlIGV4dHJhY3RlZCBsYWJlbHMgY2FuIGJlIHVzZWQgaW4gbGFiZWwgZmlsdGVyIGV4cHJlc3Npb25zIGFuZCB1c2VkIGFzIHZhbHVlcyBmb3IgYSByYW5nZSBhZ2dyZWdhdGlvbiB2aWEgdGhlIHVud3JhcCBvcGVyYXRpb24uYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuVW5wYWNrLFxuICAgICAgbmFtZTogJ1VucGFjaycsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiBwaXBlbGluZVJlbmRlcmVyLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhpcyB3aWxsIGV4dHJhY3QgYWxsIGtleXMgYW5kIHZhbHVlcyBmcm9tIGEgSlNPTiBsb2cgbGluZSwgW3VucGFja2luZ10oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyN1bnBhY2spIGFsbCBlbWJlZGRlZCBsYWJlbHMgaW4gdGhlIHBhY2sgc3RhZ2UuIFRoZSBleHRyYWN0ZWQgbGFiZWxzIGNhbiBiZSB1c2VkIGluIGxhYmVsIGZpbHRlciBleHByZXNzaW9ucyBhbmQgdXNlZCBhcyB2YWx1ZXMgZm9yIGEgcmFuZ2UgYWdncmVnYXRpb24gdmlhIHRoZSB1bndyYXAgb3BlcmF0aW9uLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxpbmVGb3JtYXQsXG4gICAgICBuYW1lOiAnTGluZSBmb3JtYXQnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnU3RyaW5nJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBoaWRlTmFtZTogdHJ1ZSxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJ3t7LnN0YXR1c19jb2RlfX0nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBsaW5lIHRlbXBsYXRlIHRoYXQgY2FuIHJlZmVyIHRvIHN0cmVhbSBsYWJlbHMgYW5kIGV4dHJhY3RlZCBsYWJlbHMuJyxcbiAgICAgICAgICBtaW5XaWR0aDogMjAsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ2Zvcm1hdCcsXG4gICAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRm9ybWF0cyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLkxpbmVGb3JtYXRzLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCwgZGVmLCBpbm5lckV4cHIpID0+IGAke2lubmVyRXhwcn0gfCBsaW5lX2Zvcm1hdCBcXGAke21vZGVsLnBhcmFtc1swXX1cXGBgLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhpcyB3aWxsIHJlcGxhY2UgbG9nIGxpbmUgdXNpbmcgYSBzcGVjaWZpZWQgdGVtcGxhdGUuIFRoZSB0ZW1wbGF0ZSBjYW4gcmVmZXIgdG8gc3RyZWFtIGxhYmVscyBhbmQgZXh0cmFjdGVkIGxhYmVscy5cblxuICAgICAgICBFeGFtcGxlOiBcXGB7ey5zdGF0dXNfY29kZX19IC0ge3subWVzc2FnZX19XFxgXG5cbiAgICAgICAgW1JlYWQgdGhlIGRvY3NdKGh0dHBzOi8vZ3JhZmFuYS5jb20vZG9jcy9sb2tpL2xhdGVzdC9sb2dxbC9sb2dfcXVlcmllcy8jbGluZS1mb3JtYXQtZXhwcmVzc2lvbikgZm9yIG1vcmUuXG4gICAgICAgIGAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRm9ybWF0LFxuICAgICAgbmFtZTogJ0xhYmVsIGZvcm1hdCcsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAgeyBuYW1lOiAnTGFiZWwnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdSZW5hbWUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJywgJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnZm9ybWF0JyxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Gb3JtYXRzLFxuICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGluZUZvcm1hdHMsXG4gICAgICByZW5kZXJlcjogKG1vZGVsLCBkZWYsIGlubmVyRXhwcikgPT4gYCR7aW5uZXJFeHByfSB8IGxhYmVsX2Zvcm1hdCAke21vZGVsLnBhcmFtc1sxXX09XFxgJHttb2RlbC5wYXJhbXNbMF19XFxgYCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKCkgPT5cbiAgICAgICAgYFRoaXMgd2lsbCBjaGFuZ2UgbmFtZSBvZiBsYWJlbCB0byBkZXNpcmVkIG5ldyBsYWJlbC4gSW4gdGhlIGV4YW1wbGUgYmVsb3csIGxhYmVsIFwiZXJyb3JfbGV2ZWxcIiB3aWxsIGJlIHJlbmFtZWQgdG8gXCJsZXZlbFwiLlxuXG4gICAgICAgIEV4YW1wbGU6IGVycm9yX2xldmVsPVxcYGxldmVsXFxgXG5cbiAgICAgICAgW1JlYWQgdGhlIGRvY3NdKGh0dHBzOi8vZ3JhZmFuYS5jb20vZG9jcy9sb2tpL2xhdGVzdC9sb2dxbC9sb2dfcXVlcmllcy8jbGFiZWxzLWZvcm1hdC1leHByZXNzaW9uKSBmb3IgbW9yZS5cbiAgICAgICAgYCxcbiAgICB9LFxuXG4gICAge1xuICAgICAgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lQ29udGFpbnMsXG4gICAgICBuYW1lOiAnTGluZSBjb250YWlucycsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdTdHJpbmcnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGhpZGVOYW1lOiB0cnVlLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnVGV4dCB0byBmaW5kJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0ZpbmQgbG9nIGxpbmVzIHRoYXQgY29udGFpbnMgdGhpcyB0ZXh0JyxcbiAgICAgICAgICBtaW5XaWR0aDogMjAsXG4gICAgICAgICAgcnVuUXVlcnlPbkVudGVyOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJ10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdsaW5lIGZpbHRlcicsXG4gICAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuTGluZUZpbHRlcnMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRmlsdGVycyxcbiAgICAgIHJlbmRlcmVyOiBnZXRMaW5lRmlsdGVyUmVuZGVyZXIoJ3w9JyksXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRMb2tpT3BlcmF0aW9uLFxuICAgICAgZXhwbGFpbkhhbmRsZXI6IChvcCkgPT4gYFJldHVybiBsb2cgbGluZXMgdGhhdCBjb250YWluIHN0cmluZyBcXGAke29wLnBhcmFtc1swXX1cXGAuYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTGluZUNvbnRhaW5zTm90LFxuICAgICAgbmFtZTogJ0xpbmUgZG9lcyBub3QgY29udGFpbicsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdTdHJpbmcnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGhpZGVOYW1lOiB0cnVlLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnVGV4dCB0byBleGNsdWRlJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0ZpbmQgbG9nIGxpbmVzIHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGlzIHRleHQnLFxuICAgICAgICAgIG1pbldpZHRoOiAyNixcbiAgICAgICAgICBydW5RdWVyeU9uRW50ZXI6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ2xpbmUgZmlsdGVyJyxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5MaW5lRmlsdGVycyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLkxpbmVGaWx0ZXJzLFxuICAgICAgcmVuZGVyZXI6IGdldExpbmVGaWx0ZXJSZW5kZXJlcignIT0nKSxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKG9wKSA9PiBgUmV0dXJuIGxvZyBsaW5lcyB0aGF0IGRvZXMgbm90IGNvbnRhaW4gc3RyaW5nIFxcYCR7b3AucGFyYW1zWzBdfVxcYC5gLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lTWF0Y2hlc1JlZ2V4LFxuICAgICAgbmFtZTogJ0xpbmUgY29udGFpbnMgcmVnZXggbWF0Y2gnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnUmVnZXgnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGhpZGVOYW1lOiB0cnVlLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnUGF0dGVybiB0byBtYXRjaCcsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdGaW5kIGxvZyBsaW5lcyB0aGF0IG1hdGNoIHRoaXMgcmVnZXggcGF0dGVybicsXG4gICAgICAgICAgbWluV2lkdGg6IDMwLFxuICAgICAgICAgIHJ1blF1ZXJ5T25FbnRlcjogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnbGluZSBmaWx0ZXInLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkxpbmVGaWx0ZXJzLFxuICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGluZUZpbHRlcnMsXG4gICAgICByZW5kZXJlcjogZ2V0TGluZUZpbHRlclJlbmRlcmVyKCd8ficpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAob3ApID0+IGBSZXR1cm4gbG9nIGxpbmVzIHRoYXQgbWF0Y2ggcmVnZXggXFxgJHtvcC5wYXJhbXNbMF19XFxgLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxpbmVNYXRjaGVzUmVnZXhOb3QsXG4gICAgICBuYW1lOiAnTGluZSBkb2VzIG5vdCBtYXRjaCByZWdleCcsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdSZWdleCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgaGlkZU5hbWU6IHRydWUsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICdQYXR0ZXJuIHRvIGV4Y2x1ZGUnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmluZCBsb2cgbGluZXMgdGhhdCBkb2VzIG5vdCBtYXRjaCB0aGlzIHJlZ2V4IHBhdHRlcm4nLFxuICAgICAgICAgIG1pbldpZHRoOiAzMCxcbiAgICAgICAgICBydW5RdWVyeU9uRW50ZXI6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ2xpbmUgZmlsdGVyJyxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5MaW5lRmlsdGVycyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLkxpbmVGaWx0ZXJzLFxuICAgICAgcmVuZGVyZXI6IGdldExpbmVGaWx0ZXJSZW5kZXJlcignIX4nKSxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKG9wKSA9PiBgUmV0dXJuIGxvZyBsaW5lcyB0aGF0IGRvZXMgbm90IG1hdGNoIHJlZ2V4IFxcYCR7b3AucGFyYW1zWzBdfVxcYC5gLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IExva2lPcGVyYXRpb25JZC5MYWJlbEZpbHRlcixcbiAgICAgIG5hbWU6ICdMYWJlbCBmaWx0ZXIgZXhwcmVzc2lvbicsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAgeyBuYW1lOiAnTGFiZWwnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdPcGVyYXRvcicsIHR5cGU6ICdzdHJpbmcnLCBvcHRpb25zOiBbJz0nLCAnIT0nLCAnPicsICc8JywgJz49JywgJzw9J10gfSxcbiAgICAgICAgeyBuYW1lOiAnVmFsdWUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJywgJz0nLCAnJ10sXG4gICAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuTGFiZWxGaWx0ZXJzLFxuICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGFiZWxGaWx0ZXJzLFxuICAgICAgcmVuZGVyZXI6IGxhYmVsRmlsdGVyUmVuZGVyZXIsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRMb2tpT3BlcmF0aW9uLFxuICAgICAgZXhwbGFpbkhhbmRsZXI6ICgpID0+IGBMYWJlbCBleHByZXNzaW9uIGZpbHRlciBhbGxvd3MgZmlsdGVyaW5nIHVzaW5nIG9yaWdpbmFsIGFuZCBleHRyYWN0ZWQgbGFiZWxzLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRmlsdGVyTm9FcnJvcnMsXG4gICAgICBuYW1lOiAnTm8gcGlwZWxpbmUgZXJyb3JzJyxcbiAgICAgIHBhcmFtczogW10sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbXSxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5MYWJlbEZpbHRlcnMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5Ob0Vycm9ycyxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwsIGRlZiwgaW5uZXJFeHByKSA9PiBgJHtpbm5lckV4cHJ9IHwgX19lcnJvcl9fPVxcYFxcYGAsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRMb2tpT3BlcmF0aW9uLFxuICAgICAgZXhwbGFpbkhhbmRsZXI6ICgpID0+IGBGaWx0ZXIgb3V0IGFsbCBmb3JtYXR0aW5nIGFuZCBwYXJzaW5nIGVycm9ycy5gLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IExva2lPcGVyYXRpb25JZC5VbndyYXAsXG4gICAgICBuYW1lOiAnVW53cmFwJyxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ0lkZW50aWZpZXInLCB0eXBlOiAnc3RyaW5nJywgaGlkZU5hbWU6IHRydWUsIG1pbldpZHRoOiAxNiwgcGxhY2Vob2xkZXI6ICdMYWJlbCBrZXknIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnXSxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Gb3JtYXRzLFxuICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuVW53cmFwLFxuICAgICAgcmVuZGVyZXI6IChvcCwgZGVmLCBpbm5lckV4cHIpID0+IGAke2lubmVyRXhwcn0gfCB1bndyYXAgJHtvcC5wYXJhbXNbMF19YCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKG9wKSA9PiB7XG4gICAgICAgIGxldCBsYWJlbCA9IFN0cmluZyhvcC5wYXJhbXNbMF0pLmxlbmd0aCA+IDAgPyBvcC5wYXJhbXNbMF0gOiAnPGxhYmVsPic7XG4gICAgICAgIHJldHVybiBgVXNlIHRoZSBleHRyYWN0ZWQgbGFiZWwgXFxgJHtsYWJlbH1cXGAgYXMgc2FtcGxlIHZhbHVlcyBpbnN0ZWFkIG9mIGxvZyBsaW5lcyBmb3IgdGhlIHN1YnNlcXVlbnQgcmFuZ2UgYWdncmVnYXRpb24uYDtcbiAgICAgIH0sXG4gICAgfSxcbiAgICAuLi5iaW5hcnlTY2FsYXJPcGVyYXRpb25zLFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTmVzdGVkUXVlcnksXG4gICAgICBuYW1lOiAnQmluYXJ5IG9wZXJhdGlvbiB3aXRoIHF1ZXJ5JyxcbiAgICAgIHBhcmFtczogW10sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbXSxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5CaW5hcnlPcHMsXG4gICAgICByZW5kZXJlcjogKG1vZGVsLCBkZWYsIGlubmVyRXhwcikgPT4gaW5uZXJFeHByLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTmVzdGVkUXVlcnlIYW5kbGVyLFxuICAgIH0sXG4gIF07XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKG5hbWU6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB7XG4gIGNvbnN0IHBhcmFtcyA9IFtnZXRSYW5nZVZlY3RvclBhcmFtRGVmKCldO1xuICBjb25zdCBkZWZhdWx0UGFyYW1zID0gWyckX19pbnRlcnZhbCddO1xuICBsZXQgcmVuZGVyZXIgPSBvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlcjtcblxuICBpZiAobmFtZSA9PT0gTG9raU9wZXJhdGlvbklkLlF1YW50aWxlT3ZlclRpbWUpIHtcbiAgICBkZWZhdWx0UGFyYW1zLnB1c2goJzAuOTUnKTtcbiAgICBwYXJhbXMucHVzaCh7XG4gICAgICBuYW1lOiAnUXVhbnRpbGUnLFxuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgfSk7XG4gICAgcmVuZGVyZXIgPSBvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlckFuZFBhcmFtO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogbmFtZSxcbiAgICBuYW1lOiBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpLFxuICAgIHBhcmFtcyxcbiAgICBkZWZhdWx0UGFyYW1zLFxuICAgIGFsdGVybmF0aXZlc0tleTogJ3JhbmdlIGZ1bmN0aW9uJyxcbiAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuUmFuZ2VWZWN0b3JGdW5jdGlvbixcbiAgICByZW5kZXJlcixcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRMb2tpT3BlcmF0aW9uLFxuICAgIGV4cGxhaW5IYW5kbGVyOiAob3AsIGRlZikgPT4ge1xuICAgICAgbGV0IG9wRG9jcyA9IEZVTkNUSU9OUy5maW5kKCh4KSA9PiB4Lmluc2VydFRleHQgPT09IG9wLmlkKT8uZG9jdW1lbnRhdGlvbiA/PyAnJztcblxuICAgICAgaWYgKG9wLnBhcmFtc1swXSA9PT0gJyRfX2ludGVydmFsJykge1xuICAgICAgICByZXR1cm4gYCR7b3BEb2NzfSBcXGAkX19pbnRlcnZhbFxcYCBpcyB2YXJpYWJsZSB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIGNhbGN1bGF0ZWQgaW50ZXJ2YWwgYmFzZWQgb24gKipNYXggZGF0YSBwb2ludHMqKiwgICoqTWluIGludGVydmFsKiogYW5kIHF1ZXJ5IHRpbWUgcmFuZ2UuIFlvdSBmaW5kIHRoZXNlIG9wdGlvbnMgeW91IGZpbmQgdW5kZXIgKipRdWVyeSBvcHRpb25zKiogYXQgdGhlIHJpZ2h0IG9mIHRoZSBkYXRhIHNvdXJjZSBzZWxlY3QgZHJvcGRvd24uYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtvcERvY3N9IFRoZSBbcmFuZ2UgdmVjdG9yXShodHRwczovL2dyYWZhbmEuY29tL2RvY3MvbG9raS9sYXRlc3QvbG9ncWwvbWV0cmljX3F1ZXJpZXMvI3JhbmdlLXZlY3Rvci1hZ2dyZWdhdGlvbikgaXMgc2V0IHRvIFxcYCR7b3AucGFyYW1zWzBdfVxcYC5gO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJhbmdlVmVjdG9yUGFyYW1EZWYoKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYge1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdSYW5nZScsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uczogWyckX19pbnRlcnZhbCcsICckX19yYW5nZScsICcxbScsICc1bScsICcxMG0nLCAnMWgnLCAnMjRoJ10sXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmdcbikge1xuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnJF9faW50ZXJ2YWwnO1xuICByZXR1cm4gYCR7ZGVmLmlkfSgke2lubmVyRXhwcn0gWyR7cmFuZ2VWZWN0b3J9XSlgO1xufVxuXG5mdW5jdGlvbiBvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlckFuZFBhcmFtKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmdcbikge1xuICBjb25zdCBwYXJhbXMgPSBtb2RlbC5wYXJhbXMgPz8gW107XG4gIGNvbnN0IHJhbmdlVmVjdG9yID0gcGFyYW1zWzBdID8/ICckX19pbnRlcnZhbCc7XG4gIGNvbnN0IHBhcmFtID0gcGFyYW1zWzFdO1xuICByZXR1cm4gYCR7ZGVmLmlkfSgke3BhcmFtfSwgJHtpbm5lckV4cHJ9IFske3JhbmdlVmVjdG9yfV0pYDtcbn1cblxuZnVuY3Rpb24gZ2V0TGluZUZpbHRlclJlbmRlcmVyKG9wZXJhdGlvbjogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBsaW5lRmlsdGVyUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke2lubmVyRXhwcn0gJHtvcGVyYXRpb259IFxcYCR7bW9kZWwucGFyYW1zWzBdfVxcYGA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGxhYmVsRmlsdGVyUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gIGlmIChtb2RlbC5wYXJhbXNbMF0gPT09ICcnKSB7XG4gICAgcmV0dXJuIGlubmVyRXhwcjtcbiAgfVxuXG4gIGlmIChtb2RlbC5wYXJhbXNbMV0gPT09ICc8JyB8fCBtb2RlbC5wYXJhbXNbMV0gPT09ICc+Jykge1xuICAgIHJldHVybiBgJHtpbm5lckV4cHJ9IHwgJHttb2RlbC5wYXJhbXNbMF19ICR7bW9kZWwucGFyYW1zWzFdfSAke21vZGVsLnBhcmFtc1syXX1gO1xuICB9XG5cbiAgcmV0dXJuIGAke2lubmVyRXhwcn0gfCAke21vZGVsLnBhcmFtc1swXX0ke21vZGVsLnBhcmFtc1sxXX1cXGAke21vZGVsLnBhcmFtc1syXX1cXGBgO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZVJlbmRlcmVyKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICByZXR1cm4gYCR7aW5uZXJFeHByfSB8ICR7bW9kZWwuaWR9YDtcbn1cblxuZnVuY3Rpb24gaXNSYW5nZVZlY3RvckZ1bmN0aW9uKGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmKSB7XG4gIHJldHVybiBkZWYuY2F0ZWdvcnkgPT09IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleE9mT3JMYXN0KFxuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXSxcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcixcbiAgY29uZGl0aW9uOiAoZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYpID0+IGJvb2xlYW5cbikge1xuICBjb25zdCBpbmRleCA9IG9wZXJhdGlvbnMuZmluZEluZGV4KCh4KSA9PiB7XG4gICAgY29uc3Qgb3BEZWYgPSBxdWVyeU1vZGVsbGVyLmdldE9wZXJhdGlvbkRlZih4LmlkKTtcbiAgICBpZiAoIW9wRGVmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjb25kaXRpb24ob3BEZWYpO1xuICB9KTtcblxuICByZXR1cm4gaW5kZXggPT09IC0xID8gb3BlcmF0aW9ucy5sZW5ndGggOiBpbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExva2lPcGVyYXRpb24oXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBxdWVyeTogTG9raVZpc3VhbFF1ZXJ5LFxuICBtb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlclxuKTogTG9raVZpc3VhbFF1ZXJ5IHtcbiAgY29uc3QgbmV3T3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBwYXJhbXM6IGRlZi5kZWZhdWx0UGFyYW1zLFxuICB9O1xuXG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBbLi4ucXVlcnkub3BlcmF0aW9uc107XG5cbiAgY29uc3QgZXhpc3RpbmdSYW5nZVZlY3RvckZ1bmN0aW9uID0gb3BlcmF0aW9ucy5maW5kKCh4KSA9PiB7XG4gICAgY29uc3Qgb3BEZWYgPSBtb2RlbGxlci5nZXRPcGVyYXRpb25EZWYoeC5pZCk7XG4gICAgaWYgKCFvcERlZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNSYW5nZVZlY3RvckZ1bmN0aW9uKG9wRGVmKTtcbiAgfSk7XG5cbiAgc3dpdGNoIChkZWYuY2F0ZWdvcnkpIHtcbiAgICBjYXNlIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkFnZ3JlZ2F0aW9uczpcbiAgICBjYXNlIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9uczpcbiAgICAgIC8vIElmIHdlIGFyZSBhZGRpbmcgYSBmdW5jdGlvbiBidXQgd2UgaGF2ZSBub3QgcmFuZ2UgdmVjdG9yIGZ1bmN0aW9uIHlldCBhZGQgb25lXG4gICAgICBpZiAoIWV4aXN0aW5nUmFuZ2VWZWN0b3JGdW5jdGlvbikge1xuICAgICAgICBjb25zdCBwbGFjZVRvSW5zZXJ0ID0gZ2V0SW5kZXhPZk9yTGFzdChcbiAgICAgICAgICBvcGVyYXRpb25zLFxuICAgICAgICAgIG1vZGVsbGVyLFxuICAgICAgICAgIChkZWYpID0+IGRlZi5jYXRlZ29yeSA9PT0gTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zXG4gICAgICAgICk7XG4gICAgICAgIG9wZXJhdGlvbnMuc3BsaWNlKHBsYWNlVG9JbnNlcnQsIDAsIHsgaWQ6IExva2lPcGVyYXRpb25JZC5SYXRlLCBwYXJhbXM6IFsnJF9faW50ZXJ2YWwnXSB9KTtcbiAgICAgIH1cbiAgICAgIG9wZXJhdGlvbnMucHVzaChuZXdPcGVyYXRpb24pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9uczpcbiAgICAgIC8vIElmIGFkZGluZyBhIHJhbmdlIGZ1bmN0aW9uIGFuZCByYW5nZSBmdW5jdGlvbiBpcyBhbHJlYWR5IGFkZGVkIHJlcGxhY2UgaXRcbiAgICAgIGlmIChleGlzdGluZ1JhbmdlVmVjdG9yRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvcGVyYXRpb25zLmluZGV4T2YoZXhpc3RpbmdSYW5nZVZlY3RvckZ1bmN0aW9uKTtcbiAgICAgICAgb3BlcmF0aW9uc1tpbmRleF0gPSBuZXdPcGVyYXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgLy8gQWRkIHJhbmdlIGZ1bmN0aW9ucyBhZnRlciBhbnkgZm9ybWF0cywgbGluZSBmaWx0ZXJzIGFuZCBsYWJlbCBmaWx0ZXJzXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnN0IHBsYWNlVG9JbnNlcnQgPSBnZXRJbmRleE9mT3JMYXN0KFxuICAgICAgICBvcGVyYXRpb25zLFxuICAgICAgICBtb2RlbGxlcixcbiAgICAgICAgKHgpID0+IChkZWYub3JkZXJSYW5rID8/IDEwMCkgPCAoeC5vcmRlclJhbmsgPz8gMTAwKVxuICAgICAgKTtcbiAgICAgIG9wZXJhdGlvbnMuc3BsaWNlKHBsYWNlVG9JbnNlcnQsIDAsIG5ld09wZXJhdGlvbik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucXVlcnksXG4gICAgb3BlcmF0aW9ucyxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkTmVzdGVkUXVlcnlIYW5kbGVyKGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBxdWVyeTogTG9raVZpc3VhbFF1ZXJ5KTogTG9raVZpc3VhbFF1ZXJ5IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5xdWVyeSxcbiAgICBiaW5hcnlRdWVyaWVzOiBbXG4gICAgICAuLi4ocXVlcnkuYmluYXJ5UXVlcmllcyA/PyBbXSksXG4gICAgICB7XG4gICAgICAgIG9wZXJhdG9yOiAnLycsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgfSxcbiAgICBdLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgU3ludGF4Tm9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG5pbXBvcnQgeyBwYXJzZXIgfSBmcm9tICdAZ3JhZmFuYS9sZXplci1sb2dxbCc7XG5cbmltcG9ydCB7XG4gIEVycm9yTmFtZSxcbiAgZ2V0QWxsQnlUeXBlLFxuICBnZXRMZWZ0TW9zdENoaWxkLFxuICBnZXRTdHJpbmcsXG4gIG1ha2VCaW5PcCxcbiAgbWFrZUVycm9yLFxuICByZXBsYWNlVmFyaWFibGVzLFxufSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvcGFyc2luZ1V0aWxzJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gfSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBiaW5hcnlTY2FsYXJEZWZzIH0gZnJvbSAnLi9iaW5hcnlTY2FsYXJPcGVyYXRpb25zJztcbmltcG9ydCB7IExva2lWaXN1YWxRdWVyeSwgTG9raVZpc3VhbFF1ZXJ5QmluYXJ5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmludGVyZmFjZSBDb250ZXh0IHtcbiAgcXVlcnk6IExva2lWaXN1YWxRdWVyeTtcbiAgZXJyb3JzOiBQYXJzaW5nRXJyb3JbXTtcbn1cblxuaW50ZXJmYWNlIFBhcnNpbmdFcnJvciB7XG4gIHRleHQ6IHN0cmluZztcbiAgZnJvbT86IG51bWJlcjtcbiAgdG8/OiBudW1iZXI7XG4gIHBhcmVudFR5cGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyhleHByOiBzdHJpbmcpOiBDb250ZXh0IHtcbiAgY29uc3QgcmVwbGFjZWRFeHByID0gcmVwbGFjZVZhcmlhYmxlcyhleHByKTtcbiAgY29uc3QgdHJlZSA9IHBhcnNlci5wYXJzZShyZXBsYWNlZEV4cHIpO1xuICBjb25zdCBub2RlID0gdHJlZS50b3BOb2RlO1xuXG4gIC8vIFRoaXMgd2lsbCBiZSBtb2RpZmllZCBpbiB0aGUgaGFuZGxlRXhwcmVzc2lvblxuICBjb25zdCB2aXNRdWVyeTogTG9raVZpc3VhbFF1ZXJ5ID0ge1xuICAgIGxhYmVsczogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gIH07XG5cbiAgY29uc3QgY29udGV4dDogQ29udGV4dCA9IHtcbiAgICBxdWVyeTogdmlzUXVlcnksXG4gICAgZXJyb3JzOiBbXSxcbiAgfTtcblxuICB0cnkge1xuICAgIGhhbmRsZUV4cHJlc3Npb24ocmVwbGFjZWRFeHByLCBub2RlLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gTm90IGlkZWFsIHRvIGxvZyBpdCBoZXJlLCBidXQgb3RoZXJ3aXNlIHdlIHdvdWxkIGxvc2UgdGhlIHN0YWNrIHRyYWNlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goe1xuICAgICAgICB0ZXh0OiBlcnIubWVzc2FnZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgZW1wdHkgcXVlcnksIHdlIHdhbnQgdG8gcmVzZXQgZXJyb3JzXG4gIGlmIChpc0VtcHR5UXVlcnkoY29udGV4dC5xdWVyeSkpIHtcbiAgICBjb250ZXh0LmVycm9ycyA9IFtdO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRXhwcmVzc2lvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgdmlzUXVlcnkgPSBjb250ZXh0LnF1ZXJ5O1xuICBzd2l0Y2ggKG5vZGUubmFtZSkge1xuICAgIGNhc2UgJ01hdGNoZXInOiB7XG4gICAgICB2aXNRdWVyeS5sYWJlbHMucHVzaChnZXRMYWJlbChleHByLCBub2RlKSk7XG4gICAgICBjb25zdCBlcnIgPSBub2RlLmdldENoaWxkKEVycm9yTmFtZSk7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2gobWFrZUVycm9yKGV4cHIsIGVycikpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTGluZUZpbHRlcic6IHtcbiAgICAgIGNvbnN0IHsgb3BlcmF0aW9uLCBlcnJvciB9ID0gZ2V0TGluZUZpbHRlcihleHByLCBub2RlKTtcbiAgICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICB9XG4gICAgICAvLyBTaG93IGVycm9yIGZvciBxdWVyeSBwYXR0ZXJucyBub3Qgc3VwcG9ydGVkIGluIHZpc3VhbCBxdWVyeSBidWlsZGVyXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcihleHByLCBub2RlLCBlcnJvcikpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTGFiZWxQYXJzZXInOiB7XG4gICAgICB2aXNRdWVyeS5vcGVyYXRpb25zLnB1c2goZ2V0TGFiZWxQYXJzZXIoZXhwciwgbm9kZSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTGFiZWxGaWx0ZXInOiB7XG4gICAgICBjb25zdCB7IG9wZXJhdGlvbiwgZXJyb3IgfSA9IGdldExhYmVsRmlsdGVyKGV4cHIsIG5vZGUpO1xuICAgICAgaWYgKG9wZXJhdGlvbikge1xuICAgICAgICB2aXNRdWVyeS5vcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8vIFNob3cgZXJyb3IgZm9yIHF1ZXJ5IHBhdHRlcm5zIG5vdCBzdXBwb3J0ZWQgaW4gdmlzdWFsIHF1ZXJ5IGJ1aWxkZXJcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKGV4cHIsIG5vZGUsIGVycm9yKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdKc29uRXhwcmVzc2lvblBhcnNlcic6IHtcbiAgICAgIC8vIEpzb25FeHByZXNzaW9uUGFyc2VyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gcXVlcnkgYnVpbGRlclxuICAgICAgY29uc3QgZXJyb3IgPSAnSnNvbkV4cHJlc3Npb25QYXJzZXIgbm90IHN1cHBvcnRlZCBpbiB2aXN1YWwgcXVlcnkgYnVpbGRlcic7XG5cbiAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoZXhwciwgbm9kZSwgZXJyb3IpKTtcbiAgICB9XG5cbiAgICBjYXNlICdMaW5lRm9ybWF0RXhwcic6IHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChnZXRMaW5lRm9ybWF0KGV4cHIsIG5vZGUpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0xhYmVsRm9ybWF0TWF0Y2hlcic6IHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChnZXRMYWJlbEZvcm1hdChleHByLCBub2RlKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdVbndyYXBFeHByJzoge1xuICAgICAgY29uc3QgeyBvcGVyYXRpb24sIGVycm9yIH0gPSBoYW5kbGVVbndyYXBFeHByKGV4cHIsIG5vZGUsIGNvbnRleHQpO1xuICAgICAgaWYgKG9wZXJhdGlvbikge1xuICAgICAgICB2aXNRdWVyeS5vcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8vIFNob3cgZXJyb3IgZm9yIHF1ZXJ5IHBhdHRlcm5zIG5vdCBzdXBwb3J0ZWQgaW4gdmlzdWFsIHF1ZXJ5IGJ1aWxkZXJcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKGV4cHIsIG5vZGUsIGVycm9yKSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ1JhbmdlQWdncmVnYXRpb25FeHByJzoge1xuICAgICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKGhhbmRsZVJhbmdlQWdncmVnYXRpb24oZXhwciwgbm9kZSwgY29udGV4dCkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnVmVjdG9yQWdncmVnYXRpb25FeHByJzoge1xuICAgICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKGhhbmRsZVZlY3RvckFnZ3JlZ2F0aW9uKGV4cHIsIG5vZGUsIGNvbnRleHQpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0Jpbk9wRXhwcic6IHtcbiAgICAgIGhhbmRsZUJpbmFyeShleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgRXJyb3JOYW1lOiB7XG4gICAgICBpZiAoaXNJbnRlcnZhbFZhcmlhYmxlRXJyb3Iobm9kZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG1ha2VFcnJvcihleHByLCBub2RlKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICAvLyBBbnkgb3RoZXIgbm9kZXMgd2UganVzdCBpZ25vcmUgYW5kIGdvIHRvIGl0J3MgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIGZpbmUgYXMgdGhlcmUgYXJlIGxvdCdzIG9mIHdyYXBwZXJcbiAgICAgIC8vIG5vZGVzIHRoYXQgY2FuIGJlIHNraXBwZWQuXG4gICAgICAvLyBUT0RPOiB0aGVyZSBhcmUgcHJvYmFibHkgY2FzZXMgd2hlcmUgd2Ugd2lsbCBqdXN0IHNraXAgbm9kZXMgd2UgZG9uJ3Qgc3VwcG9ydCBhbmQgd2Ugc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgIC8vICBkZXRlY3QgdGhvc2UgYW5kIHJlcG9ydCBiYWNrLlxuICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMYWJlbChleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB7XG4gIGNvbnN0IGxhYmVsTm9kZSA9IG5vZGUuZ2V0Q2hpbGQoJ0lkZW50aWZpZXInKTtcbiAgY29uc3QgbGFiZWwgPSBnZXRTdHJpbmcoZXhwciwgbGFiZWxOb2RlKTtcbiAgY29uc3Qgb3AgPSBnZXRTdHJpbmcoZXhwciwgbGFiZWxOb2RlIS5uZXh0U2libGluZyk7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ1N0cmluZycpKS5yZXBsYWNlKC9cIi9nLCAnJyk7XG5cbiAgcmV0dXJuIHtcbiAgICBsYWJlbCxcbiAgICBvcCxcbiAgICB2YWx1ZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TGluZUZpbHRlcihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpOiB7IG9wZXJhdGlvbj86IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gIC8vIENoZWNrIGZvciBub2RlcyBub3Qgc3VwcG9ydGVkIGluIHZpc3VhbCBidWlsZGVyIGFuZCByZXR1cm4gZXJyb3JcbiAgY29uc3QgaXBMaW5lRmlsdGVyID0gZ2V0QWxsQnlUeXBlKGV4cHIsIG5vZGUsICdJcCcpO1xuICBpZiAoaXBMaW5lRmlsdGVyLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6ICdNYXRjaGluZyBpcCBhZGRyZXNzZXMgbm90IHN1cHBvcnRlZCBpbiBxdWVyeSBidWlsZGVyJyxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgbWFwRmlsdGVyOiBhbnkgPSB7XG4gICAgJ3w9JzogJ19fbGluZV9jb250YWlucycsXG4gICAgJyE9JzogJ19fbGluZV9jb250YWluc19ub3QnLFxuICAgICd8fic6ICdfX2xpbmVfbWF0Y2hlc19yZWdleCcsXG4gICAgJyF+JzogJ1wiX19saW5lX21hdGNoZXNfcmVnZXhcIl9ub3QnLFxuICB9O1xuICBjb25zdCBmaWx0ZXIgPSBnZXRTdHJpbmcoZXhwciwgbm9kZS5nZXRDaGlsZCgnRmlsdGVyJykpO1xuICBjb25zdCBmaWx0ZXJFeHByID0gaGFuZGxlUXVvdGVzKGdldFN0cmluZyhleHByLCBub2RlLmdldENoaWxkKCdTdHJpbmcnKSkpO1xuXG4gIHJldHVybiB7XG4gICAgb3BlcmF0aW9uOiB7XG4gICAgICBpZDogbWFwRmlsdGVyW2ZpbHRlcl0sXG4gICAgICBwYXJhbXM6IFtmaWx0ZXJFeHByXSxcbiAgICB9LFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRMYWJlbFBhcnNlcihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24ge1xuICBjb25zdCBwYXJzZXJOb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBjb25zdCBwYXJzZXIgPSBnZXRTdHJpbmcoZXhwciwgcGFyc2VyTm9kZSk7XG5cbiAgY29uc3Qgc3RyaW5nID0gaGFuZGxlUXVvdGVzKGdldFN0cmluZyhleHByLCBub2RlLmdldENoaWxkKCdTdHJpbmcnKSkpO1xuICBjb25zdCBwYXJhbXMgPSAhIXN0cmluZyA/IFtzdHJpbmddIDogW107XG4gIHJldHVybiB7XG4gICAgaWQ6IHBhcnNlcixcbiAgICBwYXJhbXMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldExhYmVsRmlsdGVyKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSk6IHsgb3BlcmF0aW9uPzogUXVlcnlCdWlsZGVyT3BlcmF0aW9uOyBlcnJvcj86IHN0cmluZyB9IHtcbiAgLy8gQ2hlY2sgZm9yIG5vZGVzIG5vdCBzdXBwb3J0ZWQgaW4gdmlzdWFsIGJ1aWxkZXIgYW5kIHJldHVybiBlcnJvclxuICBpZiAobm9kZS5nZXRDaGlsZCgnT3InKSB8fCBub2RlLmdldENoaWxkKCdBbmQnKSB8fCBub2RlLmdldENoaWxkKCdDb21tYScpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiAnTGFiZWwgZmlsdGVyIHdpdGggY29tbWEsIFwiYW5kXCIsIFwib3JcIiBub3Qgc3VwcG9ydGVkIGluIHF1ZXJ5IGJ1aWxkZXInLFxuICAgIH07XG4gIH1cbiAgaWYgKG5vZGUuZmlyc3RDaGlsZCEubmFtZSA9PT0gJ0lwTGFiZWxGaWx0ZXInKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiAnSXBMYWJlbEZpbHRlciBub3Qgc3VwcG9ydGVkIGluIHF1ZXJ5IGJ1aWxkZXInLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBpZCA9ICdfX2xhYmVsX2ZpbHRlcic7XG4gIGlmIChub2RlLmZpcnN0Q2hpbGQhLm5hbWUgPT09ICdVbml0RmlsdGVyJykge1xuICAgIGNvbnN0IGZpbHRlciA9IG5vZGUuZmlyc3RDaGlsZCEuZmlyc3RDaGlsZDtcbiAgICBjb25zdCBsYWJlbCA9IGZpbHRlciEuZmlyc3RDaGlsZDtcbiAgICBjb25zdCBvcCA9IGxhYmVsIS5uZXh0U2libGluZztcbiAgICBjb25zdCB2YWx1ZSA9IG9wIS5uZXh0U2libGluZztcbiAgICBjb25zdCB2YWx1ZVN0cmluZyA9IGhhbmRsZVF1b3RlcyhnZXRTdHJpbmcoZXhwciwgdmFsdWUpKTtcblxuICAgIHJldHVybiB7XG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHBhcmFtczogW2dldFN0cmluZyhleHByLCBsYWJlbCksIGdldFN0cmluZyhleHByLCBvcCksIHZhbHVlU3RyaW5nXSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICAvLyBJbiB0aGlzIGNhc2UgaXQgaXMgTWF0Y2hlciBvciBOdW1iZXJGaWx0ZXJcbiAgY29uc3QgZmlsdGVyID0gbm9kZS5maXJzdENoaWxkO1xuICBjb25zdCBsYWJlbCA9IGZpbHRlciEuZmlyc3RDaGlsZDtcbiAgY29uc3Qgb3AgPSBsYWJlbCEubmV4dFNpYmxpbmc7XG4gIGNvbnN0IHZhbHVlID0gb3AhLm5leHRTaWJsaW5nO1xuICBjb25zdCBwYXJhbXMgPSBbZ2V0U3RyaW5nKGV4cHIsIGxhYmVsKSwgZ2V0U3RyaW5nKGV4cHIsIG9wKSwgaGFuZGxlUXVvdGVzKGdldFN0cmluZyhleHByLCB2YWx1ZSkpXTtcblxuICAvLyBTcGVjaWFsIGNhc2Ugb2YgcGlwZSBmaWx0ZXJpbmcgLSBubyBlcnJvcnNcbiAgaWYgKHBhcmFtcy5qb2luKCcnKSA9PT0gYF9fZXJyb3JfXz1gKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICBpZDogJ19fbGFiZWxfZmlsdGVyX25vX2Vycm9ycycsXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9wZXJhdGlvbjoge1xuICAgICAgaWQsXG4gICAgICBwYXJhbXMsXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TGluZUZvcm1hdChleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24ge1xuICBjb25zdCBpZCA9ICdsaW5lX2Zvcm1hdCc7XG4gIGNvbnN0IHN0cmluZyA9IGhhbmRsZVF1b3RlcyhnZXRTdHJpbmcoZXhwciwgbm9kZS5nZXRDaGlsZCgnU3RyaW5nJykpKTtcblxuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIHBhcmFtczogW3N0cmluZ10sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldExhYmVsRm9ybWF0KGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB7XG4gIGNvbnN0IGlkID0gJ2xhYmVsX2Zvcm1hdCc7XG4gIGNvbnN0IGlkZW50aWZpZXIgPSBub2RlLmdldENoaWxkKCdJZGVudGlmaWVyJyk7XG4gIGNvbnN0IG9wID0gaWRlbnRpZmllciEubmV4dFNpYmxpbmc7XG4gIGNvbnN0IHZhbHVlID0gb3AhLm5leHRTaWJsaW5nO1xuXG4gIGxldCB2YWx1ZVN0cmluZyA9IGhhbmRsZVF1b3RlcyhnZXRTdHJpbmcoZXhwciwgdmFsdWUpKTtcblxuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIHBhcmFtczogW2dldFN0cmluZyhleHByLCBpZGVudGlmaWVyKSwgdmFsdWVTdHJpbmddLFxuICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVVbndyYXBFeHByKFxuICBleHByOiBzdHJpbmcsXG4gIG5vZGU6IFN5bnRheE5vZGUsXG4gIGNvbnRleHQ6IENvbnRleHRcbik6IHsgb3BlcmF0aW9uPzogUXVlcnlCdWlsZGVyT3BlcmF0aW9uOyBlcnJvcj86IHN0cmluZyB9IHtcbiAgY29uc3QgdW53cmFwRXhwckNoaWxkID0gbm9kZS5nZXRDaGlsZCgnVW53cmFwRXhwcicpO1xuICBjb25zdCBsYWJlbEZpbHRlckNoaWxkID0gbm9kZS5nZXRDaGlsZCgnTGFiZWxGaWx0ZXInKTtcbiAgY29uc3QgdW53cmFwQ2hpbGQgPSBub2RlLmdldENoaWxkKCdVbndyYXAnKTtcblxuICBpZiAodW53cmFwRXhwckNoaWxkKSB7XG4gICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCB1bndyYXBFeHByQ2hpbGQsIGNvbnRleHQpO1xuICB9XG5cbiAgaWYgKGxhYmVsRmlsdGVyQ2hpbGQpIHtcbiAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIGxhYmVsRmlsdGVyQ2hpbGQsIGNvbnRleHQpO1xuICB9XG5cbiAgaWYgKHVud3JhcENoaWxkKSB7XG4gICAgaWYgKHVud3JhcENoaWxkPy5uZXh0U2libGluZz8udHlwZS5uYW1lID09PSAnQ29udk9wJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6ICdVbndyYXAgd2l0aCBjb252ZXJzaW9uIG9wZXJhdG9yIG5vdCBzdXBwb3J0ZWQgaW4gcXVlcnkgYnVpbGRlcicsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgaWQ6ICd1bndyYXAnLFxuICAgICAgICBwYXJhbXM6IFtnZXRTdHJpbmcoZXhwciwgdW53cmFwQ2hpbGQ/Lm5leHRTaWJsaW5nKV0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge307XG59XG5mdW5jdGlvbiBoYW5kbGVSYW5nZUFnZ3JlZ2F0aW9uKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSwgY29udGV4dDogQ29udGV4dCkge1xuICBjb25zdCBuYW1lTm9kZSA9IG5vZGUuZ2V0Q2hpbGQoJ1JhbmdlT3AnKTtcbiAgY29uc3QgZnVuY05hbWUgPSBnZXRTdHJpbmcoZXhwciwgbmFtZU5vZGUpO1xuICBjb25zdCBudW1iZXIgPSBub2RlLmdldENoaWxkKCdOdW1iZXInKTtcbiAgY29uc3QgbG9nRXhwciA9IG5vZGUuZ2V0Q2hpbGQoJ0xvZ1JhbmdlRXhwcicpO1xuICBjb25zdCBwYXJhbXMgPSBudW1iZXIgIT09IG51bGwgJiYgbnVtYmVyICE9PSB1bmRlZmluZWQgPyBbZ2V0U3RyaW5nKGV4cHIsIG51bWJlcildIDogW107XG5cbiAgbGV0IG1hdGNoID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUpLm1hdGNoKC9cXFsoLispXFxdLyk7XG4gIGlmIChtYXRjaD8uWzFdKSB7XG4gICAgcGFyYW1zLnB1c2gobWF0Y2hbMV0pO1xuICB9XG5cbiAgY29uc3Qgb3AgPSB7XG4gICAgaWQ6IGZ1bmNOYW1lLFxuICAgIHBhcmFtcyxcbiAgfTtcblxuICBpZiAobG9nRXhwcikge1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgbG9nRXhwciwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gb3A7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVZlY3RvckFnZ3JlZ2F0aW9uKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSwgY29udGV4dDogQ29udGV4dCkge1xuICBjb25zdCBuYW1lTm9kZSA9IG5vZGUuZ2V0Q2hpbGQoJ1ZlY3Rvck9wJyk7XG4gIGxldCBmdW5jTmFtZSA9IGdldFN0cmluZyhleHByLCBuYW1lTm9kZSk7XG5cbiAgY29uc3QgZ3JvdXBpbmcgPSBub2RlLmdldENoaWxkKCdHcm91cGluZycpO1xuICBjb25zdCBwYXJhbXMgPSBbXTtcblxuICBjb25zdCBudW1iZXJOb2RlID0gbm9kZS5nZXRDaGlsZCgnTnVtYmVyJyk7XG5cbiAgaWYgKG51bWJlck5vZGUpIHtcbiAgICBwYXJhbXMucHVzaChOdW1iZXIoZ2V0U3RyaW5nKGV4cHIsIG51bWJlck5vZGUpKSk7XG4gIH1cblxuICBpZiAoZ3JvdXBpbmcpIHtcbiAgICBjb25zdCBieU1vZGlmaWVyID0gZ3JvdXBpbmcuZ2V0Q2hpbGQoYEJ5YCk7XG4gICAgaWYgKGJ5TW9kaWZpZXIgJiYgZnVuY05hbWUpIHtcbiAgICAgIGZ1bmNOYW1lID0gYF9fJHtmdW5jTmFtZX1fYnlgO1xuICAgIH1cblxuICAgIGNvbnN0IHdpdGhvdXRNb2RpZmllciA9IGdyb3VwaW5nLmdldENoaWxkKGBXaXRob3V0YCk7XG4gICAgaWYgKHdpdGhvdXRNb2RpZmllcikge1xuICAgICAgZnVuY05hbWUgPSBgX18ke2Z1bmNOYW1lfV93aXRob3V0YDtcbiAgICB9XG5cbiAgICBwYXJhbXMucHVzaCguLi5nZXRBbGxCeVR5cGUoZXhwciwgZ3JvdXBpbmcsICdJZGVudGlmaWVyJykpO1xuICB9XG5cbiAgY29uc3QgbWV0cmljRXhwciA9IG5vZGUuZ2V0Q2hpbGQoJ01ldHJpY0V4cHInKTtcbiAgY29uc3Qgb3A6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiA9IHsgaWQ6IGZ1bmNOYW1lLCBwYXJhbXMgfTtcblxuICBpZiAobWV0cmljRXhwcikge1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgbWV0cmljRXhwciwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gb3A7XG59XG5cbmNvbnN0IG9wZXJhdG9yVG9PcE5hbWUgPSBiaW5hcnlTY2FsYXJEZWZzLnJlZHVjZSgoYWNjLCBkZWYpID0+IHtcbiAgYWNjW2RlZi5zaWduXSA9IHtcbiAgICBpZDogZGVmLmlkLFxuICAgIGNvbXBhcmlzb246IGRlZi5jb21wYXJpc29uLFxuICB9O1xuICByZXR1cm4gYWNjO1xufSwge30gYXMgUmVjb3JkPHN0cmluZywgeyBpZDogc3RyaW5nOyBjb21wYXJpc29uPzogYm9vbGVhbiB9Pik7XG5cbi8qKlxuICogUmlnaHQgbm93IGJpbmFyeSBleHByZXNzaW9ucyBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXkgaW4gdmlzdWFsIHF1ZXJ5LiBBcyBhZGRpdGlvbmFsIG9wZXJhdGlvbiBpbiBjYXNlIGl0IGlzXG4gKiBqdXN0IG9wZXJhdGlvbiB3aXRoIHNjYWxhciBvciBpdCBjcmVhdGVzIGEgYmluYXJ5UXVlcnkgd2hlbiBpdCdzIDIgcXVlcmllcy5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQmluYXJ5KGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSwgY29udGV4dDogQ29udGV4dCkge1xuICBjb25zdCB2aXNRdWVyeSA9IGNvbnRleHQucXVlcnk7XG4gIGNvbnN0IGxlZnQgPSBub2RlLmZpcnN0Q2hpbGQhO1xuICBjb25zdCBvcCA9IGdldFN0cmluZyhleHByLCBsZWZ0Lm5leHRTaWJsaW5nKTtcbiAgY29uc3QgYmluTW9kaWZpZXIgPSBnZXRCaW5hcnlNb2RpZmllcihleHByLCBub2RlLmdldENoaWxkKCdCaW5Nb2RpZmllcnMnKSk7XG5cbiAgY29uc3QgcmlnaHQgPSBub2RlLmxhc3RDaGlsZCE7XG5cbiAgY29uc3Qgb3BEZWYgPSBvcGVyYXRvclRvT3BOYW1lW29wXTtcblxuICBjb25zdCBsZWZ0TnVtYmVyID0gZ2V0TGFzdENoaWxkV2l0aFNlbGVjdG9yKGxlZnQsICdNZXRyaWNFeHByLkxpdGVyYWxFeHByLk51bWJlcicpO1xuICBjb25zdCByaWdodE51bWJlciA9IGdldExhc3RDaGlsZFdpdGhTZWxlY3RvcihyaWdodCwgJ01ldHJpY0V4cHIuTGl0ZXJhbEV4cHIuTnVtYmVyJyk7XG5cbiAgY29uc3QgcmlnaHRCaW5hcnkgPSByaWdodC5nZXRDaGlsZCgnQmluT3BFeHByJyk7XG5cbiAgaWYgKGxlZnROdW1iZXIpIHtcbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhbHJlYWR5IGhhbmRsZWQgaW4gY2FzZSBwYXJlbnQgaXMgYmluYXJ5IGV4cHJlc3Npb24gYXMgaXQgaGFzIHRvIGJlIGFkZGVkIHRvIHBhcmVudFxuICAgIC8vICBpZiBxdWVyeSBzdGFydHMgd2l0aCBhIG51bWJlciB0aGF0IGlzbid0IGhhbmRsZWQgbm93LlxuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoaXMgaXMgYmluYXJ5IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIHRoZXJlIGlzIGEgcXVlcnkgb3IganVzdCBjaGFpbmVkIHNjYWxhcnMuIFNvXG4gICAgLy8gd2UgaGF2ZSB0byB0cmF2ZXJzZSBhIGJpdCBkZWVwZXIgdG8ga25vd1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgbGVmdCwgY29udGV4dCk7XG4gIH1cblxuICBpZiAocmlnaHROdW1iZXIpIHtcbiAgICB2aXNRdWVyeS5vcGVyYXRpb25zLnB1c2gobWFrZUJpbk9wKG9wRGVmLCBleHByLCByaWdodCwgISFiaW5Nb2RpZmllcj8uaXNCb29sKSk7XG4gIH0gZWxzZSBpZiAocmlnaHRCaW5hcnkpIHtcbiAgICAvLyBEdWUgdG8gdGhlIHdheSBiaW5hcnkgb3BzIGFyZSBwYXJzZWQgd2UgY2FuIGdldCBhIGJpbmFyeSBvcGVyYXRpb24gb24gdGhlIHJpZ2h0IHRoYXQgc3RhcnRzIHdpdGggYSBudW1iZXIgd2hpY2hcbiAgICAvLyBpcyBhIGZhY3RvciBmb3IgYSBjdXJyZW50IGJpbmFyeSBvcGVyYXRpb24uIFNvIHdlIGhhdmUgdG8gYWRkIGl0IGFzIGFuIG9wZXJhdGlvbiBub3cuXG4gICAgY29uc3QgbGVmdE1vc3RDaGlsZCA9IGdldExlZnRNb3N0Q2hpbGQocmlnaHQpO1xuICAgIGlmIChsZWZ0TW9zdENoaWxkPy5uYW1lID09PSAnTnVtYmVyJykge1xuICAgICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKG1ha2VCaW5PcChvcERlZiwgZXhwciwgbGVmdE1vc3RDaGlsZCwgISFiaW5Nb2RpZmllcj8uaXNCb29sKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYWRkZWQgdGhlIGZpcnN0IG51bWJlciBsaXRlcmFsIGFzIG9wZXJhdGlvbiBoZXJlIHdlIHN0aWxsIGNhbiBjb250aW51ZSBhbmQgaGFuZGxlIHRoZSByZXN0IGFzIHRoZSBmaXJzdFxuICAgIC8vIG51bWJlciB3aWxsIGJlIGp1c3Qgc2tpcHBlZC5cbiAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIHJpZ2h0LCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2aXNRdWVyeS5iaW5hcnlRdWVyaWVzID0gdmlzUXVlcnkuYmluYXJ5UXVlcmllcyB8fCBbXTtcbiAgICBjb25zdCBiaW5RdWVyeTogTG9raVZpc3VhbFF1ZXJ5QmluYXJ5ID0ge1xuICAgICAgb3BlcmF0b3I6IG9wLFxuICAgICAgcXVlcnk6IHtcbiAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgb3BlcmF0aW9uczogW10sXG4gICAgICB9LFxuICAgIH07XG4gICAgaWYgKGJpbk1vZGlmaWVyPy5pc01hdGNoZXIpIHtcbiAgICAgIGJpblF1ZXJ5LnZlY3Rvck1hdGNoZXNUeXBlID0gYmluTW9kaWZpZXIubWF0Y2hUeXBlO1xuICAgICAgYmluUXVlcnkudmVjdG9yTWF0Y2hlcyA9IGJpbk1vZGlmaWVyLm1hdGNoZXM7XG4gICAgfVxuICAgIHZpc1F1ZXJ5LmJpbmFyeVF1ZXJpZXMucHVzaChiaW5RdWVyeSk7XG4gICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCByaWdodCwge1xuICAgICAgcXVlcnk6IGJpblF1ZXJ5LnF1ZXJ5LFxuICAgICAgZXJyb3JzOiBjb250ZXh0LmVycm9ycyxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5hcnlNb2RpZmllcihcbiAgZXhwcjogc3RyaW5nLFxuICBub2RlOiBTeW50YXhOb2RlIHwgbnVsbFxuKTpcbiAgfCB7IGlzQm9vbDogdHJ1ZTsgaXNNYXRjaGVyOiBmYWxzZSB9XG4gIHwgeyBpc0Jvb2w6IGZhbHNlOyBpc01hdGNoZXI6IHRydWU7IG1hdGNoZXM6IHN0cmluZzsgbWF0Y2hUeXBlOiAnaWdub3JpbmcnIHwgJ29uJyB9XG4gIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAobm9kZS5nZXRDaGlsZCgnQm9vbCcpKSB7XG4gICAgcmV0dXJuIHsgaXNCb29sOiB0cnVlLCBpc01hdGNoZXI6IGZhbHNlIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0Y2hlciA9IG5vZGUuZ2V0Q2hpbGQoJ09uT3JJZ25vcmluZycpO1xuICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgLy8gTm90IHN1cmUgd2hhdCB0aGlzIGNvdWxkIGJlLCBtYXliZSBzaG91bGQgYmUgYW4gZXJyb3IuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSBnZXRTdHJpbmcoZXhwciwgbWF0Y2hlci5nZXRDaGlsZCgnR3JvdXBpbmdMYWJlbHMnKT8uZ2V0Q2hpbGQoJ0dyb3VwaW5nTGFiZWxMaXN0JykpO1xuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoZXI6IHRydWUsXG4gICAgICBpc0Jvb2w6IGZhbHNlLFxuICAgICAgbWF0Y2hlczogbGFiZWxzLFxuICAgICAgbWF0Y2hUeXBlOiBtYXRjaGVyLmdldENoaWxkKCdPbicpID8gJ29uJyA6ICdpZ25vcmluZycsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVydmFsVmFyaWFibGVFcnJvcihub2RlOiBTeW50YXhOb2RlKSB7XG4gIHJldHVybiBub2RlPy5wYXJlbnQ/Lm5hbWUgPT09ICdSYW5nZSc7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVF1b3RlcyhzdHJpbmc6IHN0cmluZykge1xuICBpZiAoc3RyaW5nWzBdID09PSBgXCJgICYmIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09IGBcImApIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1wiL2csICcnKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuICB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvYC9nLCAnJyk7XG59XG5cbi8qKlxuICogU2ltcGxlIGhlbHBlciB0byB0cmF2ZXJzZSB0aGUgc3ludGF4IHRyZWUuIEluc3RlYWQgb2Ygbm9kZS5nZXRDaGlsZCgnZm9vJyk/LmdldENoaWxkKCdiYXInKT8uZ2V0Q2hpbGQoJ2JheicpIHlvdVxuICogY2FuIHdyaXRlIGdldENoaWxkV2l0aFNlbGVjdG9yKG5vZGUsICdmb28uYmFyLmJheicpXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIHNlbGVjdG9yXG4gKi9cbmZ1bmN0aW9uIGdldExhc3RDaGlsZFdpdGhTZWxlY3Rvcihub2RlOiBTeW50YXhOb2RlLCBzZWxlY3Rvcjogc3RyaW5nKSB7XG4gIGxldCBjaGlsZDogU3ludGF4Tm9kZSB8IG51bGwgPSBub2RlO1xuICBjb25zdCBjaGlsZHJlbiA9IHNlbGVjdG9yLnNwbGl0KCcuJyk7XG4gIGZvciAoY29uc3QgcyBvZiBjaGlsZHJlbikge1xuICAgIGNoaWxkID0gY2hpbGQuZ2V0Q2hpbGQocyk7XG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZW5yaWNoIGVycm9yIHRleHQgd2l0aCBpbmZvcm1hdGlvbiB0aGF0IHZpc3VhbCBxdWVyeSBidWlsZGVyIGRvZXNuJ3Qgc3VwcG9ydCB0aGF0IGxvZ1FMXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIG5vZGVcbiAqIEBwYXJhbSBlcnJvclxuICovXG5mdW5jdGlvbiBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGVycm9yOiBzdHJpbmcpIHtcbiAgY29uc3QgZXJyID0gbWFrZUVycm9yKGV4cHIsIG5vZGUpO1xuICBlcnIudGV4dCA9IGAke2Vycm9yfTogJHtlcnIudGV4dH1gO1xuICByZXR1cm4gZXJyO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5UXVlcnkocXVlcnk6IExva2lWaXN1YWxRdWVyeSkge1xuICBpZiAocXVlcnkubGFiZWxzLmxlbmd0aCA9PT0gMCAmJiBxdWVyeS5vcGVyYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHN0b3JlIGZyb20gJ2FwcC9jb3JlL3N0b3JlJztcblxuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IExva2lRdWVyeSwgTG9raVF1ZXJ5VHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgcXVlcnlFZGl0b3JNb2RlRGVmYXVsdExvY2FsU3RvcmFnZUtleSA9ICdMb2tpUXVlcnlFZGl0b3JNb2RlRGVmYXVsdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VFZGl0b3JNb2RlKHF1ZXJ5OiBMb2tpUXVlcnksIGVkaXRvck1vZGU6IFF1ZXJ5RWRpdG9yTW9kZSwgb25DaGFuZ2U6IChxdWVyeTogTG9raVF1ZXJ5KSA9PiB2b2lkKSB7XG4gIC8vIElmIGVtcHR5IHF1ZXJ5IHN0b3JlIG5ldyBtb2RlIGFzIGRlZmF1bHRcbiAgaWYgKHF1ZXJ5LmV4cHIgPT09ICcnKSB7XG4gICAgc3RvcmUuc2V0KHF1ZXJ5RWRpdG9yTW9kZURlZmF1bHRMb2NhbFN0b3JhZ2VLZXksIGVkaXRvck1vZGUpO1xuICB9XG5cbiAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgZWRpdG9yTW9kZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRFZGl0b3JNb2RlKGV4cHI6IHN0cmluZykge1xuICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYW4gZXhwcmVzc2lvbiBkZWZhdWx0IHRvIGNvZGUgdmlld1xuICBpZiAoZXhwciAhPSBudWxsICYmIGV4cHIgIT09ICcnKSB7XG4gICAgcmV0dXJuIFF1ZXJ5RWRpdG9yTW9kZS5Db2RlO1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSBzdG9yZS5nZXQocXVlcnlFZGl0b3JNb2RlRGVmYXVsdExvY2FsU3RvcmFnZUtleSkgYXMgUXVlcnlFZGl0b3JNb2RlO1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcjpcbiAgICBjYXNlIFF1ZXJ5RWRpdG9yTW9kZS5Db2RlOlxuICAgIGNhc2UgUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW46XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcjtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgcXVlcnkgd2l0aCBkZWZhdWx0cywgYW5kIGJvb2xlYW4gdHJ1ZS9mYWxzZSBkZXBlbmRpbmcgb24gY2hhbmdlIHdhcyByZXF1aXJlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVlcnlXaXRoRGVmYXVsdHMocXVlcnk6IExva2lRdWVyeSk6IExva2lRdWVyeSB7XG4gIC8vIElmIG5vIGV4cHIgKGllIG5ldyBxdWVyeSkgdGhlbiBkZWZhdWx0IHRvIGJ1aWxkZXJcbiAgbGV0IHJlc3VsdCA9IHF1ZXJ5O1xuXG4gIGlmICghcXVlcnkuZWRpdG9yTW9kZSkge1xuICAgIHJlc3VsdCA9IHsgLi4ucXVlcnksIGVkaXRvck1vZGU6IGdldERlZmF1bHRFZGl0b3JNb2RlKHF1ZXJ5LmV4cHIpIH07XG4gIH1cblxuICBpZiAocXVlcnkuZXhwciA9PSBudWxsKSB7XG4gICAgcmVzdWx0ID0geyAuLi5yZXN1bHQsIGV4cHI6ICcnIH07XG4gIH1cblxuICBpZiAocXVlcnkucXVlcnlUeXBlID09IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHRvIHJhbmdlIHF1ZXJ5XG4gICAgcmVzdWx0ID0geyAuLi5yZXN1bHQsIHF1ZXJ5VHlwZTogTG9raVF1ZXJ5VHlwZS5SYW5nZSB9O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgcXVlcnlFZGl0b3JSYXdRdWVyeUxvY2FsU3RvcmFnZUtleSA9ICdMb2tpUXVlcnlFZGl0b3JSYXdRdWVyeURlZmF1bHQnO1xuXG5mdW5jdGlvbiBnZXRSYXdRdWVyeVZpc2liaWxpdHkoKTogYm9vbGVhbiB7XG4gIGNvbnN0IHZhbCA9IHN0b3JlLmdldChxdWVyeUVkaXRvclJhd1F1ZXJ5TG9jYWxTdG9yYWdlS2V5KTtcbiAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IEJvb2xlYW4ocGFyc2VJbnQodmFsLCAxMCkpO1xufVxuXG5mdW5jdGlvbiBzZXRSYXdRdWVyeVZpc2liaWxpdHkodmFsdWU6IGJvb2xlYW4pIHtcbiAgc3RvcmUuc2V0KHF1ZXJ5RWRpdG9yUmF3UXVlcnlMb2NhbFN0b3JhZ2VLZXksIHZhbHVlID8gJzEnIDogJzAnKTtcbn1cblxuLyoqXG4gKiBVc2UgYW5kIHN0b3JlIHZhbHVlIG9mIHJhdyBxdWVyeSBzd2l0Y2ggaW4gbG9jYWwgc3RvcmFnZS5cbiAqIE5lZWRzIHRvIGJlIGEgaG9vayB3aXRoIGxvY2FsIHN0YXRlIHRvIHRyaWdnZXIgcmVyZW5kZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmF3UXVlcnkoKTogW2Jvb2xlYW4sICh2YWw6IGJvb2xlYW4pID0+IHZvaWRdIHtcbiAgY29uc3QgW3Jhd1F1ZXJ5LCBzZXRSYXdRdWVyeV0gPSB1c2VTdGF0ZShnZXRSYXdRdWVyeVZpc2liaWxpdHkoKSk7XG4gIGNvbnN0IHNldHRlciA9IHVzZUNhbGxiYWNrKCh2YWx1ZTogYm9vbGVhbikgPT4ge1xuICAgIHNldFJhd1F1ZXJ5VmlzaWJpbGl0eSh2YWx1ZSk7XG4gICAgc2V0UmF3UXVlcnkodmFsdWUpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIFtyYXdRdWVyeSwgc2V0dGVyXTtcbn1cbiIsImltcG9ydCB7IFZpc3VhbFF1ZXJ5QmluYXJ5IH0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB9IGZyb20gJy4uLy4uL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5cbi8qKlxuICogVmlzdWFsIHF1ZXJ5IG1vZGVsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9raVZpc3VhbFF1ZXJ5IHtcbiAgbGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdO1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbiAgYmluYXJ5UXVlcmllcz86IExva2lWaXN1YWxRdWVyeUJpbmFyeVtdO1xufVxuXG5leHBvcnQgdHlwZSBMb2tpVmlzdWFsUXVlcnlCaW5hcnkgPSBWaXN1YWxRdWVyeUJpbmFyeTxMb2tpVmlzdWFsUXVlcnk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIExva2lRdWVyeVBhdHRlcm4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIG9wZXJhdGlvbnM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbltdO1xufVxuXG5leHBvcnQgZW51bSBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB7XG4gIEFnZ3JlZ2F0aW9ucyA9ICdBZ2dyZWdhdGlvbnMnLFxuICBSYW5nZUZ1bmN0aW9ucyA9ICdSYW5nZSBmdW5jdGlvbnMnLFxuICBGdW5jdGlvbnMgPSAnRnVuY3Rpb25zJyxcbiAgRm9ybWF0cyA9ICdGb3JtYXRzJyxcbiAgTGluZUZpbHRlcnMgPSAnTGluZSBmaWx0ZXJzJyxcbiAgTGFiZWxGaWx0ZXJzID0gJ0xhYmVsIGZpbHRlcnMnLFxuICBCaW5hcnlPcHMgPSAnQmluYXJ5IG9wZXJhdGlvbnMnLFxufVxuXG5leHBvcnQgZW51bSBMb2tpT3BlcmF0aW9uSWQge1xuICBKc29uID0gJ2pzb24nLFxuICBMb2dmbXQgPSAnbG9nZm10JyxcbiAgUmVnZXhwID0gJ3JlZ2V4cCcsXG4gIFBhdHRlcm4gPSAncGF0dGVybicsXG4gIFVucGFjayA9ICd1bnBhY2snLFxuICBMaW5lRm9ybWF0ID0gJ2xpbmVfZm9ybWF0JyxcbiAgTGFiZWxGb3JtYXQgPSAnbGFiZWxfZm9ybWF0JyxcbiAgUmF0ZSA9ICdyYXRlJyxcbiAgQ291bnRPdmVyVGltZSA9ICdjb3VudF9vdmVyX3RpbWUnLFxuICBTdW1PdmVyVGltZSA9ICdzdW1fb3Zlcl90aW1lJyxcbiAgQXZnT3ZlclRpbWUgPSAnYXZnX292ZXJfdGltZScsXG4gIE1heE92ZXJUaW1lID0gJ21heF9vdmVyX3RpbWUnLFxuICBNaW5PdmVyVGltZSA9ICdtaW5fb3Zlcl90aW1lJyxcbiAgRmlyc3RPdmVyVGltZSA9ICdmaXJzdF9vdmVyX3RpbWUnLFxuICBMYXN0T3ZlclRpbWUgPSAnbGFzdF9vdmVyX3RpbWUnLFxuICBTdGR2YXJPdmVyVGltZSA9ICdzdGR2YXJfb3Zlcl90aW1lJyxcbiAgU3RkZGV2T3ZlclRpbWUgPSAnc3RkZGV2X292ZXJfdGltZScsXG4gIFF1YW50aWxlT3ZlclRpbWUgPSAncXVhbnRpbGVfb3Zlcl90aW1lJyxcbiAgQnl0ZXNSYXRlID0gJ2J5dGVzX3JhdGUnLFxuICBCeXRlc092ZXJUaW1lID0gJ2J5dGVzX292ZXJfdGltZScsXG4gIEFic2VudE92ZXJUaW1lID0gJ2Fic2VudF9vdmVyX3RpbWUnLFxuICBTdW0gPSAnc3VtJyxcbiAgQXZnID0gJ2F2ZycsXG4gIE1pbiA9ICdtaW4nLFxuICBNYXggPSAnbWF4JyxcbiAgU3RkZGV2ID0gJ3N0ZGRldicsXG4gIFN0ZHZhciA9ICdzdGR2YXInLFxuICBDb3VudCA9ICdjb3VudCcsXG4gIFRvcEsgPSAndG9waycsXG4gIEJvdHRvbUsgPSAnYm90dG9taycsXG4gIExpbmVDb250YWlucyA9ICdfX2xpbmVfY29udGFpbnMnLFxuICBMaW5lQ29udGFpbnNOb3QgPSAnX19saW5lX2NvbnRhaW5zX25vdCcsXG4gIExpbmVNYXRjaGVzUmVnZXggPSAnX19saW5lX21hdGNoZXNfcmVnZXgnLFxuICBMaW5lTWF0Y2hlc1JlZ2V4Tm90ID0gJ19fbGluZV9tYXRjaGVzX3JlZ2V4X25vdCcsXG4gIExhYmVsRmlsdGVyID0gJ19fbGFiZWxfZmlsdGVyJyxcbiAgTGFiZWxGaWx0ZXJOb0Vycm9ycyA9ICdfX2xhYmVsX2ZpbHRlcl9ub19lcnJvcnMnLFxuICBVbndyYXAgPSAndW53cmFwJyxcbiAgLy8gQmluYXJ5IG9wc1xuICBBZGRpdGlvbiA9ICdfX2FkZGl0aW9uJyxcbiAgU3VidHJhY3Rpb24gPSAnX19zdWJ0cmFjdGlvbicsXG4gIE11bHRpcGx5QnkgPSAnX19tdWx0aXBseV9ieScsXG4gIERpdmlkZUJ5ID0gJ19fZGl2aWRlX2J5JyxcbiAgTW9kdWxvID0gJ19fbW9kdWxvJyxcbiAgRXhwb25lbnQgPSAnX19leHBvbmVudCcsXG4gIE5lc3RlZFF1ZXJ5ID0gJ19fbmVzdGVkX3F1ZXJ5JyxcbiAgRXF1YWxUbyA9ICdfX2VxdWFsX3RvJyxcbiAgTm90RXF1YWxUbyA9ICdfX25vdF9lcXVhbF90bycsXG4gIEdyZWF0ZXJUaGFuID0gJ19fZ3JlYXRlcl90aGFuJyxcbiAgTGVzc1RoYW4gPSAnX19sZXNzX3RoYW4nLFxuICBHcmVhdGVyT3JFcXVhbCA9ICdfX2dyZWF0ZXJfb3JfZXF1YWwnLFxuICBMZXNzT3JFcXVhbCA9ICdfX2xlc3Nfb3JfZXF1YWwnLFxufVxuXG5leHBvcnQgZW51bSBMb2tpT3BlcmF0aW9uT3JkZXIge1xuICBMaW5lRmlsdGVycyA9IDEsXG4gIExpbmVGb3JtYXRzID0gMixcbiAgTGFiZWxGaWx0ZXJzID0gMyxcbiAgVW53cmFwID0gNCxcbiAgTm9FcnJvcnMgPSA1LFxuICBSYW5nZVZlY3RvckZ1bmN0aW9uID0gNSxcbiAgTGFzdCA9IDYsXG59XG4iLCJpbXBvcnQgeyBEYXRhRnJhbWUsIExhYmVscyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5leHBvcnQgZnVuY3Rpb24gZGF0YUZyYW1lSGFzTG9raUVycm9yKGZyYW1lOiBEYXRhRnJhbWUpOiBib29sZWFuIHtcbiAgY29uc3QgbGFiZWxTZXRzOiBMYWJlbHNbXSA9IGZyYW1lLmZpZWxkcy5maW5kKChmKSA9PiBmLm5hbWUgPT09ICdsYWJlbHMnKT8udmFsdWVzLnRvQXJyYXkoKSA/PyBbXTtcbiAgcmV0dXJuIGxhYmVsU2V0cy5zb21lKChsYWJlbHMpID0+IGxhYmVscy5fX2Vycm9yX18gIT09IHVuZGVmaW5lZCk7XG59XG4iLCJpbXBvcnQgeyBEYXRhRnJhbWUsIEZpZWxkLCBTb3J0ZWRWZWN0b3IgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxudHlwZSBTb3J0RGlyZWN0aW9uID0gJ0FTQ0VORElORycgfCAnREVTQ0VORElORyc7XG5cbi8vIGNyZWF0ZXMgdGhlIGBpbmRleGAgZm9yIHRoZSBzb3J0aW5nLlxuLy8gdGhpcyBpcyBuZWVkZWQgYnkgdGhlIGBTb3J0ZWRWZWN0b3JgLlxuLy8gdGhlIGluZGV4IGlzIGFuIGFycmF5IG9mIG51bWJlcnMsIGFuZCBpdCBkZWZpbmVzIGFuIG9yZGVyLlxuLy8gYXQgZXZlcnkgc2xvdCBpbiB0aGUgaW5kZXggdGhlIHZhbHVlcyBpcyB0aGUgcG9zaXRpb24gb2Zcbi8vIHRoZSBzb3J0ZWQgaXRlbS5cbi8vIGZvciBleGFtcGxlLCBhbiBpbmRleCBvZiBbMywxLDJdIG1lYW5zIHRoYXRcbi8vIGluIHRoZSBkYXRhZnJhbWUsIHRoYXQgaGFzIDMgcm93cywgYWZ0ZXIgc29ydGluZzpcbi8vIC0gdGhlIHRoaXJkIHJvdyB3aWxsIGJlY29tZSB0aGUgZmlyc3Rcbi8vIC0gdGhlIGZpcnN0IHJvdyB3aWxsIGJlY29tZSB0aGUgc2Vjb25kXG4vLyAtIHRoZSBzZWNvbmQgcm93IHdpbGwgYmVjb21lIHRoZSB0aGlyZFxuZnVuY3Rpb24gbWFrZUluZGV4KGZpZWxkOiBGaWVsZDxzdHJpbmc+LCBkaXI6IFNvcnREaXJlY3Rpb24pOiBudW1iZXJbXSB7XG4gIGNvbnN0IGZpZWxkVmFsdWVzOiBzdHJpbmdbXSA9IGZpZWxkLnZhbHVlcy50b0FycmF5KCk7XG5cbiAgLy8gd2UgZmlyc3QgYnVpbGQgYW4gYXJyYXkgd2hpY2ggaXMgWzAsMSwyLDMuLi4uXVxuICBjb25zdCBpbmRleCA9IEFycmF5KGZpZWxkVmFsdWVzLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICBpbmRleFtpXSA9IGk7XG4gIH1cblxuICBjb25zdCBpc0FzYyA9IGRpciA9PT0gJ0FTQ0VORElORyc7XG5cbiAgaW5kZXguc29ydCgoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgIC8vIHdlIG5lZWQgdG8gYW5zd2VyIHRoaXMgcXVlc3Rpb246XG4gICAgLy8gaW4gdGhlIGZpZWxkLXVzZWQtZm9yLXNvcnRpbmcsIGhvdyB3b3VsZCB3ZSBjb21wYXJlIHZhbHVlLWF0LWluZGV4LWEgdG8gdmFsdWUtYXQtaW5kZXgtYj9cbiAgICBjb25zdCB2YWxBID0gZmllbGRWYWx1ZXNbYV07XG4gICAgY29uc3QgdmFsQiA9IGZpZWxkVmFsdWVzW2JdO1xuICAgIGlmICh2YWxBIDwgdmFsQikge1xuICAgICAgcmV0dXJuIGlzQXNjID8gLTEgOiAxO1xuICAgIH1cblxuICAgIGlmICh2YWxBID4gdmFsQikge1xuICAgICAgcmV0dXJuIGlzQXNjID8gMSA6IC0xO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9KTtcblxuICByZXR1cm4gaW5kZXg7XG59XG5cbi8vIHNvcnQgYSBkYXRhZnJhbWUgdGhhdCBpcyBpbiB0aGUgTG9raSBmb3JtYXQgYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcsXG4vLyBiYXNlZCBvbiB0aGUgbmFub3NlY29uZC10aW1lc3RhbXBcbmV4cG9ydCBmdW5jdGlvbiBzb3J0RGF0YUZyYW1lQnlUaW1lKGZyYW1lOiBEYXRhRnJhbWUsIGRpcjogU29ydERpcmVjdGlvbik6IERhdGFGcmFtZSB7XG4gIGNvbnN0IHsgZmllbGRzLCAuLi5yZXN0IH0gPSBmcmFtZTtcblxuICAvLyB3ZSB1c2UgdGhlIGFwcHJvYWNoIHVzZWQgaW4gQGdyYWZhbmEvZGF0YS9zb3J0RGF0YWZyYW1lLlxuICAvLyB3ZSBjYW5ub3QgdXNlIGl0IGRpcmVjdGx5LCBiZWNhdXNlIG91ciB0c05zIGZpZWxkIGhhcyBhIHR5cGU9dGltZSxcbiAgLy8gc28gd2UgaGF2ZSB0byBidWlsZCB0aGUgYGluZGV4YCBtYW51YWxseS5cblxuICBjb25zdCB0c05zRmllbGQgPSBmaWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09ICd0c05zJyk7XG4gIGlmICh0c05zRmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBuYW5vc2Vjb25kLXRpbWVzdGFtcCBmaWVsZC4gc2hvdWxkIG5ldmVyIGhhcHBlbicpO1xuICB9XG5cbiAgY29uc3QgaW5kZXggPSBtYWtlSW5kZXgodHNOc0ZpZWxkLCBkaXIpO1xuXG4gIHJldHVybiB7XG4gICAgLi4ucmVzdCxcbiAgICBmaWVsZHM6IGZpZWxkcy5tYXAoKGZpZWxkKSA9PiAoe1xuICAgICAgLi4uZmllbGQsXG4gICAgICB2YWx1ZXM6IG5ldyBTb3J0ZWRWZWN0b3IoZmllbGQudmFsdWVzLCBpbmRleCksXG4gICAgfSkpLFxuICB9O1xuXG4gIHJldHVybiBmcmFtZTtcbn1cbiIsImltcG9ydCB7IG1hcCwgT2JzZXJ2YWJsZSwgZGVmZXIsIG1lcmdlTWFwIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERhdGFGcmFtZUpTT04sIERhdGFRdWVyeVJlcXVlc3QsIERhdGFRdWVyeVJlc3BvbnNlLCBMaXZlQ2hhbm5lbFNjb3BlLCBMb2FkaW5nU3RhdGUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGdldEdyYWZhbmFMaXZlU3J2IH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBTdHJlYW1pbmdEYXRhRnJhbWUgfSBmcm9tICdhcHAvZmVhdHVyZXMvbGl2ZS9kYXRhL1N0cmVhbWluZ0RhdGFGcmFtZSc7XG5cbmltcG9ydCB7IExva2lEYXRhc291cmNlIH0gZnJvbSAnLi9kYXRhc291cmNlJztcbmltcG9ydCB7IExva2lRdWVyeSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBhIHVuaXF1ZSBrZXkgZm9yIHRoZSBxdWVyeS4gIFRoZSBrZXkgaXMgdXNlZCB0byBwaWNrIGEgY2hhbm5lbCBhbmQgc2hvdWxkXG4gKiBiZSB1bmlxdWUgZm9yIGVhY2ggZGlzdGluY3QgcXVlcnkgZXhlY3V0aW9uIHBsYW4uICBUaGlzIGtleSBpcyBub3Qgc2VjdXJlIGFuZCBpcyBvbmx5IHBpY2tlZCB0byBhdm9pZFxuICogcG9zc2libGUgY29sbGlzaW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TGl2ZVN0cmVhbUtleShxdWVyeTogTG9raVF1ZXJ5KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkoeyBleHByOiBxdWVyeS5leHByIH0pO1xuXG4gIGNvbnN0IG1zZ1VpbnQ4ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7IC8vIGVuY29kZSBhcyAodXRmLTgpIFVpbnQ4QXJyYXlcbiAgY29uc3QgaGFzaEJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMScsIG1zZ1VpbnQ4KTsgLy8gaGFzaCB0aGUgbWVzc2FnZVxuICBjb25zdCBoYXNoQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGhhc2hCdWZmZXIuc2xpY2UoMCwgOCkpKTsgLy8gZmlyc3QgOCBieXRlc1xuICByZXR1cm4gaGFzaEFycmF5Lm1hcCgoYikgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XG59XG5cbi8vIFRoaXMgd2lsbCBnZXQgYm90aCB2MSBhbmQgdjIgcmVzdWx0IGZvcm1hdHNcbmV4cG9ydCBmdW5jdGlvbiBkb0xva2lDaGFubmVsU3RyZWFtKFxuICBxdWVyeTogTG9raVF1ZXJ5LFxuICBkczogTG9raURhdGFzb3VyY2UsXG4gIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8TG9raVF1ZXJ5PlxuKTogT2JzZXJ2YWJsZTxEYXRhUXVlcnlSZXNwb25zZT4ge1xuICAvLyBtYXhpbXVtIHRpbWUgdG8ga2VlcCB2YWx1ZXNcbiAgY29uc3QgcmFuZ2UgPSBvcHRpb25zLnJhbmdlO1xuICBjb25zdCBtYXhEZWx0YSA9IHJhbmdlLnRvLnZhbHVlT2YoKSAtIHJhbmdlLmZyb20udmFsdWVPZigpICsgMTAwMDtcbiAgbGV0IG1heExlbmd0aCA9IG9wdGlvbnMubWF4RGF0YVBvaW50cyA/PyAxMDAwO1xuICBpZiAobWF4TGVuZ3RoID4gMTAwKSB7XG4gICAgLy8gZm9yIHNtYWxsIGJ1ZmZlcnMsIGtlZXAgdGhlbSBzbWFsbFxuICAgIG1heExlbmd0aCAqPSAyO1xuICB9XG5cbiAgbGV0IGZyYW1lOiBTdHJlYW1pbmdEYXRhRnJhbWUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGNvbnN0IHVwZGF0ZUZyYW1lID0gKG1zZzogYW55KSA9PiB7XG4gICAgaWYgKG1zZz8ubWVzc2FnZSkge1xuICAgICAgY29uc3QgcCA9IG1zZy5tZXNzYWdlIGFzIERhdGFGcmFtZUpTT047XG4gICAgICBpZiAoIWZyYW1lKSB7XG4gICAgICAgIGZyYW1lID0gU3RyZWFtaW5nRGF0YUZyYW1lLmZyb21EYXRhRnJhbWVKU09OKHAsIHtcbiAgICAgICAgICBtYXhMZW5ndGgsXG4gICAgICAgICAgbWF4RGVsdGEsXG4gICAgICAgICAgZGlzcGxheU5hbWVGb3JtYXQ6IHF1ZXJ5LmxlZ2VuZEZvcm1hdCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFtZS5wdXNoKHApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhbWU7XG4gIH07XG5cbiAgcmV0dXJuIGRlZmVyKCgpID0+IGdldExpdmVTdHJlYW1LZXkocXVlcnkpKS5waXBlKFxuICAgIG1lcmdlTWFwKChrZXkpID0+IHtcbiAgICAgIHJldHVybiBnZXRHcmFmYW5hTGl2ZVNydigpXG4gICAgICAgIC5nZXRTdHJlYW08YW55Pih7XG4gICAgICAgICAgc2NvcGU6IExpdmVDaGFubmVsU2NvcGUuRGF0YVNvdXJjZSxcbiAgICAgICAgICBuYW1lc3BhY2U6IGRzLnVpZCxcbiAgICAgICAgICBwYXRoOiBgdGFpbC8ke2tleX1gLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgdGltZVJhbmdlOiB7XG4gICAgICAgICAgICAgIGZyb206IHJhbmdlLmZyb20udmFsdWVPZigpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgIHRvOiByYW5nZS50by52YWx1ZU9mKCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgbWFwKChldnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gdXBkYXRlRnJhbWUoZXZ0KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IGZyYW1lID8gW2ZyYW1lXSA6IFtdLFxuICAgICAgICAgICAgICBzdGF0ZTogTG9hZGluZ1N0YXRlLlN0cmVhbWluZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9KVxuICApO1xufVxuIiwiaW1wb3J0IHsgR3JhbW1hciB9IGZyb20gJ3ByaXNtanMnO1xuXG5pbXBvcnQgeyBDb21wbGV0aW9uSXRlbSB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuY29uc3QgQUdHUkVHQVRJT05fT1BFUkFUT1JTOiBDb21wbGV0aW9uSXRlbVtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdzdW0nLFxuICAgIGluc2VydFRleHQ6ICdzdW0nLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgc3VtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21pbicsXG4gICAgaW5zZXJ0VGV4dDogJ21pbicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtaW5pbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21heCcsXG4gICAgaW5zZXJ0VGV4dDogJ21heCcsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtYXhpbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2F2ZycsXG4gICAgaW5zZXJ0VGV4dDogJ2F2ZycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSB0aGUgYXZlcmFnZSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdzdGRkZXYnLFxuICAgIGluc2VydFRleHQ6ICdzdGRkZXYnLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgcG9wdWxhdGlvbiBzdGFuZGFyZCBkZXZpYXRpb24gb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnc3RkdmFyJyxcbiAgICBpbnNlcnRUZXh0OiAnc3RkdmFyJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlIHBvcHVsYXRpb24gc3RhbmRhcmQgdmFyaWFuY2Ugb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnY291bnQnLFxuICAgIGluc2VydFRleHQ6ICdjb3VudCcsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NvdW50IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdmVjdG9yJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYm90dG9taycsXG4gICAgaW5zZXJ0VGV4dDogJ2JvdHRvbWsnLFxuICAgIGRvY3VtZW50YXRpb246ICdTbWFsbGVzdCBrIGVsZW1lbnRzIGJ5IHNhbXBsZSB2YWx1ZScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3RvcGsnLFxuICAgIGluc2VydFRleHQ6ICd0b3BrJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnTGFyZ2VzdCBrIGVsZW1lbnRzIGJ5IHNhbXBsZSB2YWx1ZScsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgUElQRV9QQVJTRVJTOiBDb21wbGV0aW9uSXRlbVtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdqc29uJyxcbiAgICBpbnNlcnRUZXh0OiAnanNvbicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0V4dHJhY3RpbmcgbGFiZWxzIGZyb20gdGhlIGxvZyBsaW5lIHVzaW5nIGpzb24gcGFyc2VyLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAncmVnZXhwJyxcbiAgICBpbnNlcnRUZXh0OiAncmVnZXhwIFwiXCInLFxuICAgIGRvY3VtZW50YXRpb246ICdFeHRyYWN0aW5nIGxhYmVscyBmcm9tIHRoZSBsb2cgbGluZSB1c2luZyByZWdleHAgcGFyc2VyLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgICBtb3ZlOiAtMSxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnbG9nZm10JyxcbiAgICBpbnNlcnRUZXh0OiAnbG9nZm10JyxcbiAgICBkb2N1bWVudGF0aW9uOiAnRXh0cmFjdGluZyBsYWJlbHMgZnJvbSB0aGUgbG9nIGxpbmUgdXNpbmcgbG9nZm10IHBhcnNlci4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3BhdHRlcm4nLFxuICAgIGluc2VydFRleHQ6ICdwYXR0ZXJuJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnRXh0cmFjdGluZyBsYWJlbHMgZnJvbSB0aGUgbG9nIGxpbmUgdXNpbmcgcGF0dGVybiBwYXJzZXIuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4zKy4nLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICd1bnBhY2snLFxuICAgIGluc2VydFRleHQ6ICd1bnBhY2snLFxuICAgIGRldGFpbDogJ3VucGFjayBpZGVudGlmaWVyJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1BhcnNlcyBhIEpTT04gbG9nIGxpbmUsIHVucGFja2luZyBhbGwgZW1iZWRkZWQgbGFiZWxzIGluIHRoZSBwYWNrIHN0YWdlLiBBIHNwZWNpYWwgcHJvcGVydHkgXCJfZW50cnlcIiB3aWxsIGFsc28gYmUgdXNlZCB0byByZXBsYWNlIHRoZSBvcmlnaW5hbCBsb2cgbGluZS4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjIrLicsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgUElQRV9PUEVSQVRPUlM6IENvbXBsZXRpb25JdGVtW10gPSBbXG4gIHtcbiAgICBsYWJlbDogJ3Vud3JhcCcsXG4gICAgaW5zZXJ0VGV4dDogJ3Vud3JhcCcsXG4gICAgZGV0YWlsOiAndW53cmFwIGlkZW50aWZpZXInLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnVGFrZSBsYWJlbHMgYW5kIHVzZSB0aGUgdmFsdWVzIGFzIHNhbXBsZSBkYXRhIGZvciBtZXRyaWMgYWdncmVnYXRpb25zLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnbGFiZWxfZm9ybWF0JyxcbiAgICBpbnNlcnRUZXh0OiAnbGFiZWxfZm9ybWF0JyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1VzZSB0byByZW5hbWUsIG1vZGlmeSBvciBhZGQgbGFiZWxzLiBGb3IgZXhhbXBsZSwgfCBsYWJlbF9mb3JtYXQgZm9vPWJhciAuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4wKy4nLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdsaW5lX2Zvcm1hdCcsXG4gICAgaW5zZXJ0VGV4dDogJ2xpbmVfZm9ybWF0JyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1Jld3JpdGVzIGxvZyBsaW5lIGNvbnRlbnQuIEZvciBleGFtcGxlLCB8IGxpbmVfZm9ybWF0IFwie3sucXVlcnl9fSB7ey5kdXJhdGlvbn19XCIgLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBSQU5HRV9WRUNfRlVOQ1RJT05TID0gW1xuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2F2Z19vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnYXZnX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnYXZnX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIGF2ZXJhZ2Ugb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdtaW5fb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ21pbl9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ21pbl9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBtaW5pbXVtIG9mIGFsbCB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbWF4X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdtYXhfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdtYXhfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbWF4aW11bSBvZiBhbGwgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4wKy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2ZpcnN0X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdmaXJzdF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2ZpcnN0X292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIGZpcnN0IG9mIGFsbCB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjMrLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbGFzdF9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnbGFzdF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2xhc3Rfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbGFzdCBvZiBhbGwgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4zKy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N1bV9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3VtX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3VtX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIHN1bSBvZiBhbGwgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4wKy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NvdW50X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdjb3VudF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2NvdW50X292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIGNvdW50IG9mIGFsbCB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N0ZHZhcl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3RkdmFyX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3RkdmFyX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1RoZSBwb3B1bGF0aW9uIHN0YW5kYXJkIHZhcmlhbmNlIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc3RkZGV2X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdzdGRkZXZfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdzdGRkZXZfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnVGhlIHBvcHVsYXRpb24gc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncXVhbnRpbGVfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3F1YW50aWxlX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAncXVhbnRpbGVfb3Zlcl90aW1lKHNjYWxhciwgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSDPhi1xdWFudGlsZSAoMCDiiaQgz4Yg4omkIDEpIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYnl0ZXNfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2J5dGVzX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnYnl0ZXNfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDb3VudHMgdGhlIGFtb3VudCBvZiBieXRlcyB1c2VkIGJ5IGVhY2ggbG9nIHN0cmVhbSBmb3IgYSBnaXZlbiByYW5nZScsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYnl0ZXNfcmF0ZScsXG4gICAgbGFiZWw6ICdieXRlc19yYXRlJyxcbiAgICBkZXRhaWw6ICdieXRlc19yYXRlKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgcGVyIHNlY29uZCBmb3IgZWFjaCBzdHJlYW0uJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdyYXRlJyxcbiAgICBsYWJlbDogJ3JhdGUnLFxuICAgIGRldGFpbDogJ3JhdGUodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGVudHJpZXMgcGVyIHNlY29uZC4nLFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IEZVTkNUSU9OUyA9IFsuLi5BR0dSRUdBVElPTl9PUEVSQVRPUlMsIC4uLlJBTkdFX1ZFQ19GVU5DVElPTlNdO1xuZXhwb3J0IGNvbnN0IExPS0lfS0VZV09SRFMgPSBbLi4uRlVOQ1RJT05TLCAuLi5QSVBFX09QRVJBVE9SUywgLi4uUElQRV9QQVJTRVJTXS5tYXAoKGtleXdvcmQpID0+IGtleXdvcmQubGFiZWwpO1xuXG5leHBvcnQgY29uc3QgbG9raUdyYW1tYXI6IEdyYW1tYXIgPSB7XG4gIGNvbW1lbnQ6IHtcbiAgICBwYXR0ZXJuOiAvIy4qLyxcbiAgfSxcbiAgJ2NvbnRleHQtYWdncmVnYXRpb24nOiB7XG4gICAgcGF0dGVybjogLygod2l0aG91dHxieSlcXHMqKVxcKFteKV0qXFwpLywgLy8gYnkgKClcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2xhYmVsLWtleSc6IHtcbiAgICAgICAgcGF0dGVybjogL1teKCksXFxzXVteLCldKlteKSxcXHNdKi8sXG4gICAgICAgIGFsaWFzOiAnYXR0ci1uYW1lJyxcbiAgICAgIH0sXG4gICAgICBwdW5jdHVhdGlvbjogL1soKV0vLFxuICAgIH0sXG4gIH0sXG4gICdjb250ZXh0LWxhYmVscyc6IHtcbiAgICBwYXR0ZXJuOiAvXFx7W159XSooPz19PykvLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgcGF0dGVybjogLyMuKi8sXG4gICAgICB9LFxuICAgICAgJ2xhYmVsLWtleSc6IHtcbiAgICAgICAgcGF0dGVybjogL1thLXpBLVpfXVxcdyooPz1cXHMqKD18IT18PX58IX4pKS8sXG4gICAgICAgIGFsaWFzOiAnYXR0ci1uYW1lJyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgfSxcbiAgICAgICdsYWJlbC12YWx1ZSc6IHtcbiAgICAgICAgcGF0dGVybjogL1wiKD86XFxcXC58W15cXFxcXCJdKSpcIi8sXG4gICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdhdHRyLXZhbHVlJyxcbiAgICAgIH0sXG4gICAgICBwdW5jdHVhdGlvbjogL1t7XS8sXG4gICAgfSxcbiAgfSxcbiAgJ2NvbnRleHQtcGlwZSc6IHtcbiAgICBwYXR0ZXJuOiAvXFxzXFx8W149fl1cXHM/XFx3Ki9pLFxuICAgIGluc2lkZToge1xuICAgICAgJ3BpcGUtb3BlcmF0b3InOiB7XG4gICAgICAgIHBhdHRlcm46IC9cXHwvaSxcbiAgICAgICAgYWxpYXM6ICdvcGVyYXRvcicsXG4gICAgICB9LFxuICAgICAgJ3BpcGUtb3BlcmF0aW9ucyc6IHtcbiAgICAgICAgcGF0dGVybjogbmV3IFJlZ0V4cChgJHtbLi4uUElQRV9QQVJTRVJTLCAuLi5QSVBFX09QRVJBVE9SU10ubWFwKChmKSA9PiBmLmxhYmVsKS5qb2luKCd8Jyl9YCwgJ2knKSxcbiAgICAgICAgYWxpYXM6ICdrZXl3b3JkJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbiAgZnVuY3Rpb246IG5ldyBSZWdFeHAoYFxcXFxiKD86JHtGVU5DVElPTlMubWFwKChmKSA9PiBmLmxhYmVsKS5qb2luKCd8Jyl9KSg/PVxcXFxzKlxcXFwoKWAsICdpJyksXG4gICdjb250ZXh0LXJhbmdlJzogW1xuICAgIHtcbiAgICAgIHBhdHRlcm46IC9cXFtbXlxcXV0qKD89XFxdKS8sIC8vIFsxbV1cbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKG9mZnNldFxccyspXFx3Ky8sIC8vIG9mZnNldCAxbVxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbiAgcXVvdGU6IHtcbiAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcLnxbXlxcXFxcIl0pKlwiLyxcbiAgICBhbGlhczogJ3N0cmluZycsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICB9LFxuICBiYWNrdGlja3M6IHtcbiAgICBwYXR0ZXJuOiAvYCg/OlxcXFwufFteXFxcXGBdKSpgLyxcbiAgICBhbGlhczogJ3N0cmluZycsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICB9LFxuICBudW1iZXI6IC9cXGItP1xcZCsoKFxcLlxcZCopPyhbZUVdWystXT9cXGQrKT8pP1xcYi8sXG4gIG9wZXJhdG9yOiAvXFxzPyhcXHxbPX5dP3whPT98PCg/Oj0+P3w8fD4pP3w+Wz49XT8pXFxzPy9pLFxuICBwdW5jdHVhdGlvbjogL1t7fSgpLC5dLyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxva2lHcmFtbWFyO1xuIiwiaW1wb3J0IHsgRGF0YVF1ZXJ5LCBEYXRhU291cmNlSnNvbkRhdGEsIFF1ZXJ5UmVzdWx0TWV0YSwgU2NvcGVkVmFycyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5pbXBvcnQgeyBRdWVyeUVkaXRvck1vZGUgfSBmcm9tICcuLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExva2lJbnN0YW50UXVlcnlSZXF1ZXN0IHtcbiAgcXVlcnk6IHN0cmluZztcbiAgbGltaXQ/OiBudW1iZXI7XG4gIHRpbWU/OiBzdHJpbmc7XG4gIGRpcmVjdGlvbj86ICdCQUNLV0FSRCcgfCAnRk9SV0FSRCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raVJhbmdlUXVlcnlSZXF1ZXN0IHtcbiAgcXVlcnk6IHN0cmluZztcbiAgbGltaXQ/OiBudW1iZXI7XG4gIHN0YXJ0PzogbnVtYmVyO1xuICBlbmQ/OiBudW1iZXI7XG4gIHN0ZXA/OiBudW1iZXI7XG4gIGRpcmVjdGlvbj86ICdCQUNLV0FSRCcgfCAnRk9SV0FSRCc7XG59XG5cbmV4cG9ydCBlbnVtIExva2lSZXN1bHRUeXBlIHtcbiAgU3RyZWFtID0gJ3N0cmVhbXMnLFxuICBWZWN0b3IgPSAndmVjdG9yJyxcbiAgTWF0cml4ID0gJ21hdHJpeCcsXG59XG5cbmV4cG9ydCBlbnVtIExva2lRdWVyeVR5cGUge1xuICBSYW5nZSA9ICdyYW5nZScsXG4gIEluc3RhbnQgPSAnaW5zdGFudCcsXG4gIFN0cmVhbSA9ICdzdHJlYW0nLFxufVxuXG5leHBvcnQgZW51bSBMb2tpUXVlcnlEaXJlY3Rpb24ge1xuICBCYWNrd2FyZCA9ICdiYWNrd2FyZCcsXG4gIEZvcndhcmQgPSAnZm9yd2FyZCcsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raVF1ZXJ5IGV4dGVuZHMgRGF0YVF1ZXJ5IHtcbiAgcXVlcnlUeXBlPzogTG9raVF1ZXJ5VHlwZTtcbiAgZXhwcjogc3RyaW5nO1xuICBkaXJlY3Rpb24/OiBMb2tpUXVlcnlEaXJlY3Rpb247XG4gIGxlZ2VuZEZvcm1hdD86IHN0cmluZztcbiAgbWF4TGluZXM/OiBudW1iZXI7XG4gIHJlc29sdXRpb24/OiBudW1iZXI7XG4gIC8qKiBVc2VkIGluIHJhbmdlIHF1ZXJpZXMgKi9cbiAgdm9sdW1lUXVlcnk/OiBib29sZWFuO1xuICAvKiBAZGVwcmVjYXRlZCBub3cgdXNlIHF1ZXJ5VHlwZSAqL1xuICByYW5nZT86IGJvb2xlYW47XG4gIC8qIEBkZXByZWNhdGVkIG5vdyB1c2UgcXVlcnlUeXBlICovXG4gIGluc3RhbnQ/OiBib29sZWFuO1xuICBlZGl0b3JNb2RlPzogUXVlcnlFZGl0b3JNb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lPcHRpb25zIGV4dGVuZHMgRGF0YVNvdXJjZUpzb25EYXRhIHtcbiAgbWF4TGluZXM/OiBzdHJpbmc7XG4gIGRlcml2ZWRGaWVsZHM/OiBEZXJpdmVkRmllbGRDb25maWdbXTtcbiAgYWxlcnRtYW5hZ2VyPzogc3RyaW5nO1xuICBrZWVwQ29va2llcz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lTdGF0cyB7XG4gIFtjb21wb25lbnQ6IHN0cmluZ106IHtcbiAgICBbbGFiZWw6IHN0cmluZ106IG51bWJlcjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpVmVjdG9yUmVzdWx0IHtcbiAgbWV0cmljOiB7IFtsYWJlbDogc3RyaW5nXTogc3RyaW5nIH07XG4gIHZhbHVlOiBbbnVtYmVyLCBzdHJpbmddO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lWZWN0b3JSZXNwb25zZSB7XG4gIHN0YXR1czogc3RyaW5nO1xuICBkYXRhOiB7XG4gICAgcmVzdWx0VHlwZTogTG9raVJlc3VsdFR5cGUuVmVjdG9yO1xuICAgIHJlc3VsdDogTG9raVZlY3RvclJlc3VsdFtdO1xuICAgIHN0YXRzPzogTG9raVN0YXRzO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lNYXRyaXhSZXN1bHQge1xuICBtZXRyaWM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHZhbHVlczogQXJyYXk8W251bWJlciwgc3RyaW5nXT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raU1hdHJpeFJlc3BvbnNlIHtcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIGRhdGE6IHtcbiAgICByZXN1bHRUeXBlOiBMb2tpUmVzdWx0VHlwZS5NYXRyaXg7XG4gICAgcmVzdWx0OiBMb2tpTWF0cml4UmVzdWx0W107XG4gICAgc3RhdHM/OiBMb2tpU3RhdHM7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raVN0cmVhbVJlc3VsdCB7XG4gIHN0cmVhbTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgdmFsdWVzOiBBcnJheTxbc3RyaW5nLCBzdHJpbmddPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpU3RyZWFtUmVzcG9uc2Uge1xuICBzdGF0dXM6IHN0cmluZztcbiAgZGF0YToge1xuICAgIHJlc3VsdFR5cGU6IExva2lSZXN1bHRUeXBlLlN0cmVhbTtcbiAgICByZXN1bHQ6IExva2lTdHJlYW1SZXN1bHRbXTtcbiAgICBzdGF0cz86IExva2lTdGF0cztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpVGFpbFJlc3BvbnNlIHtcbiAgc3RyZWFtczogTG9raVN0cmVhbVJlc3VsdFtdO1xuICBkcm9wcGVkX2VudHJpZXM/OiBBcnJheTx7XG4gICAgbGFiZWxzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIHRpbWVzdGFtcDogc3RyaW5nO1xuICB9PiB8IG51bGw7XG59XG5cbmV4cG9ydCB0eXBlIExva2lSZXN1bHQgPSBMb2tpVmVjdG9yUmVzdWx0IHwgTG9raU1hdHJpeFJlc3VsdCB8IExva2lTdHJlYW1SZXN1bHQ7XG5leHBvcnQgdHlwZSBMb2tpUmVzcG9uc2UgPSBMb2tpVmVjdG9yUmVzcG9uc2UgfCBMb2tpTWF0cml4UmVzcG9uc2UgfCBMb2tpU3RyZWFtUmVzcG9uc2U7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raUxvZ3NTdHJlYW1FbnRyeSB7XG4gIGxpbmU6IHN0cmluZztcbiAgdHM6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpRXhwcmVzc2lvbiB7XG4gIHJlZ2V4cDogc3RyaW5nO1xuICBxdWVyeTogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBEZXJpdmVkRmllbGRDb25maWcgPSB7XG4gIG1hdGNoZXJSZWdleDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHVybD86IHN0cmluZztcbiAgdXJsRGlzcGxheUxhYmVsPzogc3RyaW5nO1xuICBkYXRhc291cmNlVWlkPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1lck9wdGlvbnMge1xuICBsZWdlbmRGb3JtYXQ/OiBzdHJpbmc7XG4gIHF1ZXJ5OiBzdHJpbmc7XG4gIHJlZklkOiBzdHJpbmc7XG4gIHNjb3BlZFZhcnM6IFNjb3BlZFZhcnM7XG4gIG1ldGE/OiBRdWVyeVJlc3VsdE1ldGE7XG59XG4iLCJpbXBvcnQgeyBwYXJzZXIgfSBmcm9tICdsZXplci1wcm9tcWwnO1xuXG5pbXBvcnQgeyBQcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vcXVlcnlidWlsZGVyL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvcGFyc2luZyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB9IGZyb20gJy4vcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5YnVpbGRlci90eXBlcyc7XG5cbi8qKlxuICogQWRkcyBsYWJlbCBmaWx0ZXIgdG8gZXhpc3RpbmcgcXVlcnkuIFVzZWZ1bCBmb3IgcXVlcnkgbW9kaWZpY2F0aW9uIGZvciBleGFtcGxlIGZvciBhZCBob2MgZmlsdGVycy5cbiAqXG4gKiBJdCB1c2VzIFByb21RTCBwYXJzZXIgdG8gZmluZCBpbnN0YW5jZXMgb2YgbWV0cmljIGFuZCBsYWJlbHMsIGFsdGVycyB0aGVtIGFuZCB0aGVuIHNwbGljZXMgdGhlbSBiYWNrIGludG8gdGhlIHF1ZXJ5LlxuICogSWRlYWxseSB3ZSBjb3VsZCB1c2UgdGhlIHBhcnNlIC0+IGNoYW5nZSAtPiByZW5kZXIgaXMgYSBzaW1wbGUgMyBzdGVwcyBidXQgcmlnaHQgbm93IGJ1aWxkaW5nIHRoZSB2aXN1YWwgcXVlcnlcbiAqIG9iamVjdCBkb2VzIG5vdCBzdXBwb3J0IGFsbCBwb3NzaWJsZSBxdWVyaWVzLlxuICpcbiAqIFNvIGluc3RlYWQgdGhpcyBqdXN0IG9wZXJhdGVzIG9uIHN1YnN0cmluZ3Mgb2YgdGhlIHF1ZXJ5IHdpdGggbGFiZWxzIGFuZCBvcGVyYXRlcyBqdXN0IG9uIHRob3NlLiBUaGlzIG1ha2VzIHRoaXNcbiAqIG1vcmUgcm9idXN0IGFuZCBjYW4gYWx0ZXIgZXZlbiBpbnZhbGlkIHF1ZXJpZXMsIGFuZCBwcmVzZXJ2ZXMgaW4gZ2VuZXJhbCB0aGUgcXVlcnkgc3RydWN0dXJlIGFuZCB3aGl0ZXNwYWNlLlxuICogQHBhcmFtIHF1ZXJ5XG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBvcGVyYXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTGFiZWxUb1F1ZXJ5KHF1ZXJ5OiBzdHJpbmcsIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBvcGVyYXRvciA9ICc9Jyk6IHN0cmluZyB7XG4gIGlmICgha2V5IHx8ICF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBsYWJlbCB0byBhZGQgdG8gcXVlcnkuJyk7XG4gIH1cblxuICBjb25zdCB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucyA9IGdldFZlY3RvclNlbGVjdG9yUG9zaXRpb25zKHF1ZXJ5KTtcbiAgaWYgKCF2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cblxuICBjb25zdCBmaWx0ZXIgPSB0b0xhYmVsRmlsdGVyKGtleSwgdmFsdWUsIG9wZXJhdG9yKTtcbiAgcmV0dXJuIGFkZEZpbHRlcihxdWVyeSwgdmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMsIGZpbHRlcik7XG59XG5cbnR5cGUgVmVjdG9yU2VsZWN0b3JQb3NpdGlvbiA9IHsgZnJvbTogbnVtYmVyOyB0bzogbnVtYmVyOyBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5IH07XG5cbi8qKlxuICogUGFyc2UgdGhlIHN0cmluZyBhbmQgZ2V0IGFsbCBWZWN0b3JTZWxlY3RvciBwb3NpdGlvbnMgaW4gdGhlIHF1ZXJ5IHRvZ2V0aGVyIHdpdGggcGFyc2VkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqIHNlbGVjdG9yLlxuICogQHBhcmFtIHF1ZXJ5XG4gKi9cbmZ1bmN0aW9uIGdldFZlY3RvclNlbGVjdG9yUG9zaXRpb25zKHF1ZXJ5OiBzdHJpbmcpOiBWZWN0b3JTZWxlY3RvclBvc2l0aW9uW10ge1xuICBjb25zdCB0cmVlID0gcGFyc2VyLnBhcnNlKHF1ZXJ5KTtcbiAgY29uc3QgcG9zaXRpb25zOiBWZWN0b3JTZWxlY3RvclBvc2l0aW9uW10gPSBbXTtcbiAgdHJlZS5pdGVyYXRlKHtcbiAgICBlbnRlcjogKHR5cGUsIGZyb20sIHRvLCBnZXQpOiBmYWxzZSB8IHZvaWQgPT4ge1xuICAgICAgaWYgKHR5cGUubmFtZSA9PT0gJ1ZlY3RvclNlbGVjdG9yJykge1xuICAgICAgICBjb25zdCB2aXNRdWVyeSA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKHF1ZXJ5LnN1YnN0cmluZyhmcm9tLCB0bykpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaCh7IHF1ZXJ5OiB2aXNRdWVyeS5xdWVyeSwgZnJvbSwgdG8gfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cblxuZnVuY3Rpb24gdG9MYWJlbEZpbHRlcihrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IG51bWJlciwgb3BlcmF0b3I6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIHtcbiAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBjb252ZXJ0IHRoZSB2YWx1ZSBiYWNrIHRvIHN0cmluZyBiZWNhdXNlIGl0IG1heSBiZSBhIG51bWJlclxuICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlID0gdmFsdWUgPT09IEluZmluaXR5ID8gJytJbmYnIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHsgbGFiZWw6IGtleSwgb3A6IG9wZXJhdG9yLCB2YWx1ZTogdHJhbnNmb3JtZWRWYWx1ZSB9O1xufVxuXG5mdW5jdGlvbiBhZGRGaWx0ZXIoXG4gIHF1ZXJ5OiBzdHJpbmcsXG4gIHZlY3RvclNlbGVjdG9yUG9zaXRpb25zOiBWZWN0b3JTZWxlY3RvclBvc2l0aW9uW10sXG4gIGZpbHRlcjogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJcbik6IHN0cmluZyB7XG4gIGNvbnN0IG1vZGVsbGVyID0gbmV3IFByb21RdWVyeU1vZGVsbGVyKCk7XG4gIGxldCBuZXdRdWVyeSA9ICcnO1xuICBsZXQgcHJldiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIC8vIFRoaXMgaXMgYmFzaWNhbGx5IGp1c3QgZG9pbmcgc3BsaWNlIG9uIGEgc3RyaW5nIGZvciBlYWNoIG1hdGNoZWQgdmVjdG9yIHNlbGVjdG9yLlxuXG4gICAgY29uc3QgbWF0Y2ggPSB2ZWN0b3JTZWxlY3RvclBvc2l0aW9uc1tpXTtcbiAgICBjb25zdCBpc0xhc3QgPSBpID09PSB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucy5sZW5ndGggLSAxO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBxdWVyeS5zdWJzdHJpbmcocHJldiwgbWF0Y2guZnJvbSk7XG4gICAgY29uc3QgZW5kID0gaXNMYXN0ID8gcXVlcnkuc3Vic3RyaW5nKG1hdGNoLnRvKSA6ICcnO1xuXG4gICAgaWYgKCFsYWJlbEV4aXN0cyhtYXRjaC5xdWVyeS5sYWJlbHMsIGZpbHRlcikpIHtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYWRkIGR1cGxpY2F0ZSBsYWJlbHMuXG4gICAgICBtYXRjaC5xdWVyeS5sYWJlbHMucHVzaChmaWx0ZXIpO1xuICAgIH1cbiAgICBjb25zdCBuZXdMYWJlbHMgPSBtb2RlbGxlci5yZW5kZXJRdWVyeShtYXRjaC5xdWVyeSk7XG4gICAgbmV3UXVlcnkgKz0gc3RhcnQgKyBuZXdMYWJlbHMgKyBlbmQ7XG4gICAgcHJldiA9IG1hdGNoLnRvO1xuICB9XG4gIHJldHVybiBuZXdRdWVyeTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBsYWJlbCBleGlzdHMgaW4gdGhlIGxpc3Qgb2YgbGFiZWxzIGJ1dCBpZ25vcmUgdGhlIG9wZXJhdG9yLlxuICogQHBhcmFtIGxhYmVsc1xuICogQHBhcmFtIGZpbHRlclxuICovXG5mdW5jdGlvbiBsYWJlbEV4aXN0cyhsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10sIGZpbHRlcjogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIpIHtcbiAgcmV0dXJuIGxhYmVscy5maW5kKChsYWJlbCkgPT4gbGFiZWwubGFiZWwgPT09IGZpbHRlci5sYWJlbCAmJiBsYWJlbC52YWx1ZSA9PT0gZmlsdGVyLnZhbHVlKTtcbn1cbiIsImltcG9ydCB7IG9uY2UsIGNoYWluLCBkaWZmZXJlbmNlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBMUlUgZnJvbSAnbHJ1LWNhY2hlJztcbmltcG9ydCBQcmlzbSBmcm9tICdwcmlzbWpzJztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSAnc2xhdGUnO1xuXG5pbXBvcnQge1xuICBBYnN0cmFjdExhYmVsTWF0Y2hlcixcbiAgQWJzdHJhY3RMYWJlbE9wZXJhdG9yLFxuICBBYnN0cmFjdFF1ZXJ5LFxuICBkYXRlVGltZSxcbiAgSGlzdG9yeUl0ZW0sXG4gIExhbmd1YWdlUHJvdmlkZXIsXG59IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgQ29tcGxldGlvbkl0ZW0sIENvbXBsZXRpb25JdGVtR3JvdXAsIFNlYXJjaEZ1bmN0aW9uVHlwZSwgVHlwZWFoZWFkSW5wdXQsIFR5cGVhaGVhZE91dHB1dCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHtcbiAgYWRkTGltaXRJbmZvLFxuICBleHRyYWN0TGFiZWxNYXRjaGVycyxcbiAgZml4U3VtbWFyaWVzTWV0YWRhdGEsXG4gIHBhcnNlU2VsZWN0b3IsXG4gIHByb2Nlc3NIaXN0b2dyYW1NZXRyaWNzLFxuICBwcm9jZXNzTGFiZWxzLFxuICByb3VuZFNlY1RvTWluLFxuICB0b1Byb21MaWtlUXVlcnksXG59IGZyb20gJy4vbGFuZ3VhZ2VfdXRpbHMnO1xuaW1wb3J0IFByb21xbFN5bnRheCwgeyBGVU5DVElPTlMsIFJBVEVfUkFOR0VTIH0gZnJvbSAnLi9wcm9tcWwnO1xuaW1wb3J0IHsgUHJvbU1ldHJpY3NNZXRhZGF0YSwgUHJvbVF1ZXJ5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IERFRkFVTFRfS0VZUyA9IFsnam9iJywgJ2luc3RhbmNlJ107XG5jb25zdCBFTVBUWV9TRUxFQ1RPUiA9ICd7fSc7XG5jb25zdCBISVNUT1JZX0lURU1fQ09VTlQgPSA1O1xuY29uc3QgSElTVE9SWV9DT1VOVF9DVVRPRkYgPSAxMDAwICogNjAgKiA2MCAqIDI0OyAvLyAyNGhcbi8vIE1heCBudW1iZXIgb2YgaXRlbXMgKG1ldHJpY3MsIGxhYmVscywgdmFsdWVzKSB0aGF0IHdlIGRpc3BsYXkgYXMgc3VnZ2VzdGlvbnMuIFByZXZlbnRzIGZyb20gcnVubmluZyBvdXQgb2YgbWVtb3J5LlxuZXhwb3J0IGNvbnN0IFNVR0dFU1RJT05TX0xJTUlUID0gMTAwMDA7XG5cbmNvbnN0IHdyYXBMYWJlbCA9IChsYWJlbDogc3RyaW5nKTogQ29tcGxldGlvbkl0ZW0gPT4gKHsgbGFiZWwgfSk7XG5cbmNvbnN0IHNldEZ1bmN0aW9uS2luZCA9IChzdWdnZXN0aW9uOiBDb21wbGV0aW9uSXRlbSk6IENvbXBsZXRpb25JdGVtID0+IHtcbiAgc3VnZ2VzdGlvbi5raW5kID0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHN1Z2dlc3Rpb247XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkSGlzdG9yeU1ldGFkYXRhKGl0ZW06IENvbXBsZXRpb25JdGVtLCBoaXN0b3J5OiBhbnlbXSk6IENvbXBsZXRpb25JdGVtIHtcbiAgY29uc3QgY3V0b2ZmVHMgPSBEYXRlLm5vdygpIC0gSElTVE9SWV9DT1VOVF9DVVRPRkY7XG4gIGNvbnN0IGhpc3RvcnlGb3JJdGVtID0gaGlzdG9yeS5maWx0ZXIoKGgpID0+IGgudHMgPiBjdXRvZmZUcyAmJiBoLnF1ZXJ5ID09PSBpdGVtLmxhYmVsKTtcbiAgY29uc3QgY291bnQgPSBoaXN0b3J5Rm9ySXRlbS5sZW5ndGg7XG4gIGNvbnN0IHJlY2VudCA9IGhpc3RvcnlGb3JJdGVtWzBdO1xuICBsZXQgaGludCA9IGBRdWVyaWVkICR7Y291bnR9IHRpbWVzIGluIHRoZSBsYXN0IDI0aC5gO1xuXG4gIGlmIChyZWNlbnQpIHtcbiAgICBjb25zdCBsYXN0UXVlcmllZCA9IGRhdGVUaW1lKHJlY2VudC50cykuZnJvbU5vdygpO1xuICAgIGhpbnQgPSBgJHtoaW50fSBMYXN0IHF1ZXJpZWQgJHtsYXN0UXVlcmllZH0uYDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uaXRlbSxcbiAgICBkb2N1bWVudGF0aW9uOiBoaW50LFxuICB9O1xufVxuXG5mdW5jdGlvbiBhZGRNZXRyaWNzTWV0YWRhdGEobWV0cmljOiBzdHJpbmcsIG1ldGFkYXRhPzogUHJvbU1ldHJpY3NNZXRhZGF0YSk6IENvbXBsZXRpb25JdGVtIHtcbiAgY29uc3QgaXRlbTogQ29tcGxldGlvbkl0ZW0gPSB7IGxhYmVsOiBtZXRyaWMgfTtcbiAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhW21ldHJpY10pIHtcbiAgICBpdGVtLmRvY3VtZW50YXRpb24gPSBnZXRNZXRhZGF0YVN0cmluZyhtZXRyaWMsIG1ldGFkYXRhKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGFkYXRhU3RyaW5nKG1ldHJpYzogc3RyaW5nLCBtZXRhZGF0YTogUHJvbU1ldHJpY3NNZXRhZGF0YSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmICghbWV0YWRhdGFbbWV0cmljXSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgeyB0eXBlLCBoZWxwIH0gPSBtZXRhZGF0YVttZXRyaWNdO1xuICByZXR1cm4gYCR7dHlwZS50b1VwcGVyQ2FzZSgpfTogJHtoZWxwfWA7XG59XG5cbmNvbnN0IFBSRUZJWF9ERUxJTUlURVJfUkVHRVggPVxuICAvKD1cInwhPVwifD1+XCJ8IX5cInxcXHt8XFxbfFxcKHxcXCt8LXxcXC98XFwqfCV8XFxefFxcYmFuZFxcYnxcXGJvclxcYnxcXGJ1bmxlc3NcXGJ8PT18Pj18IT18PD18Pnw8fD18fnwsKS87XG5cbmludGVyZmFjZSBBdXRvY29tcGxldGVDb250ZXh0IHtcbiAgaGlzdG9yeT86IEFycmF5PEhpc3RvcnlJdGVtPFByb21RdWVyeT4+O1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvbVFsTGFuZ3VhZ2VQcm92aWRlciBleHRlbmRzIExhbmd1YWdlUHJvdmlkZXIge1xuICBoaXN0b2dyYW1NZXRyaWNzOiBzdHJpbmdbXTtcbiAgdGltZVJhbmdlPzogeyBzdGFydDogbnVtYmVyOyBlbmQ6IG51bWJlciB9O1xuICBtZXRyaWNzOiBzdHJpbmdbXTtcbiAgbWV0cmljc01ldGFkYXRhPzogUHJvbU1ldHJpY3NNZXRhZGF0YTtcbiAgZGVjbGFyZSBzdGFydFRhc2s6IFByb21pc2U8YW55PjtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG4gIGxhYmVsS2V5czogc3RyaW5nW10gPSBbXTtcbiAgZGVjbGFyZSBsYWJlbEZldGNoVHM6IG51bWJlcjtcblxuICAvKipcbiAgICogIENhY2hlIGZvciBsYWJlbHMgb2Ygc2VyaWVzLiBUaGlzIGlzIGJpdCBzaW1wbGlzdGljIGluIHRoZSBzZW5zZSB0aGF0IGl0IGp1c3QgY291bnRzIHJlc3BvbnNlcyBlYWNoIGFzIGEgMSBhbmQgZG9lc1xuICAgKiAgbm90IGFjY291bnQgZm9yIGRpZmZlcmVudCBzaXplIG9mIGEgcmVzcG9uc2UuIElmIHRoYXQgaXMgbmVlZGVkIGEgYGxlbmd0aGAgZnVuY3Rpb24gY2FuIGJlIGFkZGVkIGluIHRoZSBvcHRpb25zLlxuICAgKiAgMTAgYXMgYSBtYXggc2l6ZSBpcyB0b3RhbGx5IGFyYml0cmFyeSByaWdodCBub3cuXG4gICAqL1xuICBwcml2YXRlIGxhYmVsc0NhY2hlID0gbmV3IExSVTxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPj4oeyBtYXg6IDEwIH0pO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlLCBpbml0aWFsVmFsdWVzPzogUGFydGlhbDxQcm9tUWxMYW5ndWFnZVByb3ZpZGVyPikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRhdGFzb3VyY2UgPSBkYXRhc291cmNlO1xuICAgIHRoaXMuaGlzdG9ncmFtTWV0cmljcyA9IFtdO1xuICAgIHRoaXMudGltZVJhbmdlID0geyBzdGFydDogMCwgZW5kOiAwIH07XG4gICAgdGhpcy5tZXRyaWNzID0gW107XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGluaXRpYWxWYWx1ZXMpO1xuICB9XG5cbiAgLy8gU3RyaXAgc3ludGF4IGNoYXJzIHNvIHRoYXQgdHlwZWFoZWFkIHN1Z2dlc3Rpb25zIGNhbiB3b3JrIG9uIGNsZWFuIGlucHV0c1xuICBjbGVhblRleHQoczogc3RyaW5nKSB7XG4gICAgY29uc3QgcGFydHMgPSBzLnNwbGl0KFBSRUZJWF9ERUxJTUlURVJfUkVHRVgpO1xuICAgIGNvbnN0IGxhc3QgPSBwYXJ0cy5wb3AoKSE7XG4gICAgcmV0dXJuIGxhc3QudHJpbUxlZnQoKS5yZXBsYWNlKC9cIiQvLCAnJykucmVwbGFjZSgvXlwiLywgJycpO1xuICB9XG5cbiAgZ2V0IHN5bnRheCgpIHtcbiAgICByZXR1cm4gUHJvbXFsU3ludGF4O1xuICB9XG5cbiAgcmVxdWVzdCA9IGFzeW5jICh1cmw6IHN0cmluZywgZGVmYXVsdFZhbHVlOiBhbnksIHBhcmFtcyA9IHt9KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcyk7XG4gICAgICByZXR1cm4gcmVzLmRhdGEuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfTtcblxuICBzdGFydCA9IGFzeW5jICgpOiBQcm9taXNlPGFueVtdPiA9PiB7XG4gICAgaWYgKHRoaXMuZGF0YXNvdXJjZS5sb29rdXBzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPICMzMzk3NjogbWFrZSB0aG9zZSByZXF1ZXN0cyBwYXJhbGxlbFxuICAgIGF3YWl0IHRoaXMuZmV0Y2hMYWJlbHMoKTtcbiAgICB0aGlzLm1ldHJpY3MgPSAoYXdhaXQgdGhpcy5mZXRjaExhYmVsVmFsdWVzKCdfX25hbWVfXycpKSB8fCBbXTtcbiAgICBhd2FpdCB0aGlzLmxvYWRNZXRyaWNzTWV0YWRhdGEoKTtcbiAgICB0aGlzLmhpc3RvZ3JhbU1ldHJpY3MgPSBwcm9jZXNzSGlzdG9ncmFtTWV0cmljcyh0aGlzLm1ldHJpY3MpLnNvcnQoKTtcbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgYXN5bmMgbG9hZE1ldHJpY3NNZXRhZGF0YSgpIHtcbiAgICB0aGlzLm1ldHJpY3NNZXRhZGF0YSA9IGZpeFN1bW1hcmllc01ldGFkYXRhKGF3YWl0IHRoaXMucmVxdWVzdCgnL2FwaS92MS9tZXRhZGF0YScsIHt9KSk7XG4gIH1cblxuICBnZXRMYWJlbEtleXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmxhYmVsS2V5cztcbiAgfVxuXG4gIHByb3ZpZGVDb21wbGV0aW9uSXRlbXMgPSBhc3luYyAoXG4gICAgeyBwcmVmaXgsIHRleHQsIHZhbHVlLCBsYWJlbEtleSwgd3JhcHBlckNsYXNzZXMgfTogVHlwZWFoZWFkSW5wdXQsXG4gICAgY29udGV4dDogQXV0b2NvbXBsZXRlQ29udGV4dCA9IHt9XG4gICk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiA9PiB7XG4gICAgY29uc3QgZW1wdHlSZXN1bHQ6IFR5cGVhaGVhZE91dHB1dCA9IHsgc3VnZ2VzdGlvbnM6IFtdIH07XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gZW1wdHlSZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gTG9jYWwgdGV4dCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZW1wdHkgPSB2YWx1ZS5kb2N1bWVudC50ZXh0Lmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBzZWxlY3RlZExpbmVzID0gdmFsdWUuZG9jdW1lbnQuZ2V0VGV4dHNBdFJhbmdlKHZhbHVlLnNlbGVjdGlvbik7XG4gICAgY29uc3QgY3VycmVudExpbmUgPSBzZWxlY3RlZExpbmVzLnNpemUgPT09IDEgPyBzZWxlY3RlZExpbmVzLmZpcnN0KCkuZ2V0VGV4dCgpIDogbnVsbDtcblxuICAgIGNvbnN0IG5leHRDaGFyYWN0ZXIgPSBjdXJyZW50TGluZSA/IGN1cnJlbnRMaW5lW3ZhbHVlLnNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0XSA6IG51bGw7XG5cbiAgICAvLyBTeW50YXggc3BhbnMgaGF2ZSAzIGNsYXNzZXMgYnkgZGVmYXVsdC4gTW9yZSBpbmRpY2F0ZSBhIHJlY29nbml6ZWQgdG9rZW5cbiAgICBjb25zdCB0b2tlblJlY29nbml6ZWQgPSB3cmFwcGVyQ2xhc3Nlcy5sZW5ndGggPiAzO1xuICAgIC8vIE5vbi1lbXB0eSBwcmVmaXgsIGJ1dCBub3QgaW5zaWRlIGtub3duIHRva2VuXG4gICAgY29uc3QgcHJlZml4VW5yZWNvZ25pemVkID0gcHJlZml4ICYmICF0b2tlblJlY29nbml6ZWQ7XG5cbiAgICAvLyBQcmV2ZW50IHN1Z2dlc3Rpb25zIGluIGBmdW5jdGlvbih8c3VmZml4KWBcbiAgICBjb25zdCBub1N1ZmZpeCA9ICFuZXh0Q2hhcmFjdGVyIHx8IG5leHRDaGFyYWN0ZXIgPT09ICcpJztcblxuICAgIC8vIFByZWZpeCBpcyBzYWZlIGlmIGl0IGRvZXMgbm90IGltbWVkaWF0ZWx5IGZvbGxvdyBhIGNvbXBsZXRlIGV4cHJlc3Npb24gYW5kIGhhcyBubyB0ZXh0IGFmdGVyIGl0XG4gICAgY29uc3Qgc2FmZVByZWZpeCA9IHByZWZpeCAmJiAhdGV4dC5tYXRjaCgvXltcXF19KVxcc10rJC8pICYmIG5vU3VmZml4O1xuXG4gICAgLy8gQWJvdXQgdG8gdHlwZSBuZXh0IG9wZXJhbmQgaWYgcHJlY2VkZWQgYnkgYmluYXJ5IG9wZXJhdG9yXG4gICAgY29uc3Qgb3BlcmF0b3JzUGF0dGVybiA9IC9bK1xcLSovXiVdLztcbiAgICBjb25zdCBpc05leHRPcGVyYW5kID0gdGV4dC5tYXRjaChvcGVyYXRvcnNQYXR0ZXJuKTtcblxuICAgIC8vIERldGVybWluZSBjYW5kaWRhdGVzIGJ5IENTUyBjb250ZXh0XG4gICAgaWYgKHdyYXBwZXJDbGFzc2VzLmluY2x1ZGVzKCdjb250ZXh0LXJhbmdlJykpIHtcbiAgICAgIC8vIFN1Z2dlc3Rpb25zIGZvciBtZXRyaWNbfF1cbiAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlQ29tcGxldGlvbkl0ZW1zKCk7XG4gICAgfSBlbHNlIGlmICh3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnY29udGV4dC1sYWJlbHMnKSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIG1ldHJpY3t8fSBhbmQgbWV0cmlje2Zvbz18fSwgYXMgd2VsbCBhcyBtZXRyaWMtaW5kZXBlbmRlbnQgbGFiZWwgcXVlcmllcyBsaWtlIHt8fVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFiZWxDb21wbGV0aW9uSXRlbXMoeyBwcmVmaXgsIHRleHQsIHZhbHVlLCBsYWJlbEtleSwgd3JhcHBlckNsYXNzZXMgfSk7XG4gICAgfSBlbHNlIGlmICh3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnY29udGV4dC1hZ2dyZWdhdGlvbicpKSB7XG4gICAgICAvLyBTdWdnZXN0aW9ucyBmb3Igc3VtKG1ldHJpYykgYnkgKHwpXG4gICAgICByZXR1cm4gdGhpcy5nZXRBZ2dyZWdhdGlvbkNvbXBsZXRpb25JdGVtcyh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChlbXB0eSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIGVtcHR5IHF1ZXJ5IGZpZWxkXG4gICAgICByZXR1cm4gdGhpcy5nZXRFbXB0eUNvbXBsZXRpb25JdGVtcyhjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeFVucmVjb2duaXplZCAmJiBub1N1ZmZpeCAmJiAhaXNOZXh0T3BlcmFuZCkge1xuICAgICAgLy8gU2hvdyB0ZXJtIHN1Z2dlc3Rpb25zIGluIGEgY291cGxlIG9mIHNjZW5hcmlvc1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVnaW5uaW5nQ29tcGxldGlvbkl0ZW1zKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocHJlZml4VW5yZWNvZ25pemVkICYmIHNhZmVQcmVmaXgpIHtcbiAgICAgIC8vIFNob3cgdGVybSBzdWdnZXN0aW9ucyBpbiBhIGNvdXBsZSBvZiBzY2VuYXJpb3NcbiAgICAgIHJldHVybiB0aGlzLmdldFRlcm1Db21wbGV0aW9uSXRlbXMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHlSZXN1bHQ7XG4gIH07XG5cbiAgZ2V0QmVnaW5uaW5nQ29tcGxldGlvbkl0ZW1zID0gKGNvbnRleHQ6IEF1dG9jb21wbGV0ZUNvbnRleHQpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzdWdnZXN0aW9uczogWy4uLnRoaXMuZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXMoY29udGV4dCkuc3VnZ2VzdGlvbnMsIC4uLnRoaXMuZ2V0VGVybUNvbXBsZXRpb25JdGVtcygpLnN1Z2dlc3Rpb25zXSxcbiAgICB9O1xuICB9O1xuXG4gIGdldEVtcHR5Q29tcGxldGlvbkl0ZW1zID0gKGNvbnRleHQ6IEF1dG9jb21wbGV0ZUNvbnRleHQpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gY29udGV4dDtcbiAgICBjb25zdCBzdWdnZXN0aW9uczogQ29tcGxldGlvbkl0ZW1Hcm91cFtdID0gW107XG5cbiAgICBpZiAoaGlzdG9yeSAmJiBoaXN0b3J5Lmxlbmd0aCkge1xuICAgICAgY29uc3QgaGlzdG9yeUl0ZW1zID0gY2hhaW4oaGlzdG9yeSlcbiAgICAgICAgLm1hcCgoaCkgPT4gaC5xdWVyeS5leHByKVxuICAgICAgICAuZmlsdGVyKClcbiAgICAgICAgLnVuaXEoKVxuICAgICAgICAudGFrZShISVNUT1JZX0lURU1fQ09VTlQpXG4gICAgICAgIC5tYXAod3JhcExhYmVsKVxuICAgICAgICAubWFwKChpdGVtKSA9PiBhZGRIaXN0b3J5TWV0YWRhdGEoaXRlbSwgaGlzdG9yeSkpXG4gICAgICAgIC52YWx1ZSgpO1xuXG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuUHJlZml4LFxuICAgICAgICBza2lwU29ydDogdHJ1ZSxcbiAgICAgICAgbGFiZWw6ICdIaXN0b3J5JyxcbiAgICAgICAgaXRlbXM6IGhpc3RvcnlJdGVtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zIH07XG4gIH07XG5cbiAgZ2V0VGVybUNvbXBsZXRpb25JdGVtcyA9ICgpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIGNvbnN0IHsgbWV0cmljcywgbWV0cmljc01ldGFkYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBDb21wbGV0aW9uSXRlbUdyb3VwW10gPSBbXTtcblxuICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuUHJlZml4LFxuICAgICAgbGFiZWw6ICdGdW5jdGlvbnMnLFxuICAgICAgaXRlbXM6IEZVTkNUSU9OUy5tYXAoc2V0RnVuY3Rpb25LaW5kKSxcbiAgICB9KTtcblxuICAgIGlmIChtZXRyaWNzICYmIG1ldHJpY3MubGVuZ3RoKSB7XG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgbGFiZWw6ICdNZXRyaWNzJyxcbiAgICAgICAgaXRlbXM6IG1ldHJpY3MubWFwKChtKSA9PiBhZGRNZXRyaWNzTWV0YWRhdGEobSwgbWV0cmljc01ldGFkYXRhKSksXG4gICAgICAgIHNlYXJjaEZ1bmN0aW9uVHlwZTogU2VhcmNoRnVuY3Rpb25UeXBlLkZ1enp5LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgfTtcblxuICBnZXRSYW5nZUNvbXBsZXRpb25JdGVtcygpOiBUeXBlYWhlYWRPdXRwdXQge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0OiAnY29udGV4dC1yYW5nZScsXG4gICAgICBzdWdnZXN0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6ICdSYW5nZSB2ZWN0b3InLFxuICAgICAgICAgIGl0ZW1zOiBbLi4uUkFURV9SQU5HRVNdLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0QWdncmVnYXRpb25Db21wbGV0aW9uSXRlbXMgPSBhc3luYyAodmFsdWU6IFZhbHVlKTogUHJvbWlzZTxUeXBlYWhlYWRPdXRwdXQ+ID0+IHtcbiAgICBjb25zdCBzdWdnZXN0aW9uczogQ29tcGxldGlvbkl0ZW1Hcm91cFtdID0gW107XG5cbiAgICAvLyBTdGl0Y2ggYWxsIHF1ZXJ5IGxpbmVzIHRvZ2V0aGVyIHRvIHN1cHBvcnQgbXVsdGktbGluZSBxdWVyaWVzXG4gICAgbGV0IHF1ZXJ5T2Zmc2V0O1xuICAgIGNvbnN0IHF1ZXJ5VGV4dCA9IHZhbHVlLmRvY3VtZW50LmdldEJsb2NrcygpLnJlZHVjZSgodGV4dCwgYmxvY2spID0+IHtcbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gYmxvY2s/LmdldFRleHQoKTtcblxuICAgICAgaWYgKHZhbHVlLmFuY2hvckJsb2NrLmtleSA9PT0gYmxvY2sua2V5KSB7XG4gICAgICAgIC8vIE5ld2xpbmUgY2hhcmFjdGVycyBhcmUgbm90IGFjY291bnRlZCBmb3IgYnV0IHRoaXMgaXMgaXJyZWxldmFudFxuICAgICAgICAvLyBmb3IgdGhlIHB1cnBvc2Ugb2YgZXh0cmFjdGluZyB0aGUgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgIHF1ZXJ5T2Zmc2V0ID0gdmFsdWUuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHQgKyBibG9ja1RleHQ7XG4gICAgfSwgJycpO1xuXG4gICAgLy8gVHJ5IHNlYXJjaCBmb3Igc2VsZWN0b3IgcGFydCBvbiB0aGUgbGVmdC1oYW5kIHNpZGUsIHN1Y2ggYXMgYHN1bSAobSkgYnkgKGwpYFxuICAgIGNvbnN0IG9wZW5QYXJlbnNBZ2dyZWdhdGlvbkluZGV4ID0gcXVlcnlUZXh0Lmxhc3RJbmRleE9mKCcoJywgcXVlcnlPZmZzZXQpO1xuICAgIGxldCBvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5sYXN0SW5kZXhPZignKCcsIG9wZW5QYXJlbnNBZ2dyZWdhdGlvbkluZGV4IC0gMSk7XG4gICAgbGV0IGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5pbmRleE9mKCcpJywgb3BlblBhcmVuc1NlbGVjdG9ySW5kZXgpO1xuXG4gICAgLy8gVHJ5IHNlYXJjaCBmb3Igc2VsZWN0b3IgcGFydCBvZiBhbiBhbHRlcm5hdGUgYWdncmVnYXRpb24gY2xhdXNlLCBzdWNoIGFzIGBzdW0gYnkgKGwpIChtKWBcbiAgICBpZiAob3BlblBhcmVuc1NlbGVjdG9ySW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zdCBjbG9zZVBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXggPSBxdWVyeVRleHQuaW5kZXhPZignKScsIHF1ZXJ5T2Zmc2V0KTtcbiAgICAgIGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5pbmRleE9mKCcpJywgY2xvc2VQYXJlbnNBZ2dyZWdhdGlvbkluZGV4ICsgMSk7XG4gICAgICBvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5sYXN0SW5kZXhPZignKCcsIGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgc3VnZ2VzdGlvbnMsXG4gICAgICBjb250ZXh0OiAnY29udGV4dC1hZ2dyZWdhdGlvbicsXG4gICAgfTtcblxuICAgIC8vIFN1Z2dlc3Rpb25zIGFyZSB1c2VsZXNzIGZvciBhbHRlcm5hdGl2ZSBhZ2dyZWdhdGlvbiBjbGF1c2VzIHdpdGhvdXQgYSBzZWxlY3RvciBpbiBjb250ZXh0XG4gICAgaWYgKG9wZW5QYXJlbnNTZWxlY3RvckluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBSYW5nZSB2ZWN0b3Igc3ludGF4IG5vdCBhY2NvdW50ZWQgZm9yIGJ5IHN1YnNlcXVlbnQgcGFyc2Ugc28gZGlzY2FyZCBpdCBpZiBwcmVzZW50XG4gICAgY29uc3Qgc2VsZWN0b3JTdHJpbmcgPSBxdWVyeVRleHRcbiAgICAgIC5zbGljZShvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCArIDEsIGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleClcbiAgICAgIC5yZXBsYWNlKC9cXFtbXlxcXV0rXFxdJC8sICcnKTtcblxuICAgIGNvbnN0IHNlbGVjdG9yID0gcGFyc2VTZWxlY3RvcihzZWxlY3RvclN0cmluZywgc2VsZWN0b3JTdHJpbmcubGVuZ3RoIC0gMikuc2VsZWN0b3I7XG5cbiAgICBjb25zdCBzZXJpZXMgPSBhd2FpdCB0aGlzLmdldFNlcmllcyhzZWxlY3Rvcik7XG4gICAgY29uc3QgbGFiZWxLZXlzID0gT2JqZWN0LmtleXMoc2VyaWVzKTtcbiAgICBpZiAobGFiZWxLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxpbWl0SW5mbyA9IGFkZExpbWl0SW5mbyhsYWJlbEtleXMpO1xuICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgIGxhYmVsOiBgTGFiZWxzJHtsaW1pdEluZm99YCxcbiAgICAgICAgaXRlbXM6IGxhYmVsS2V5cy5tYXAod3JhcExhYmVsKSxcbiAgICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuRnV6enksXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBnZXRMYWJlbENvbXBsZXRpb25JdGVtcyA9IGFzeW5jICh7XG4gICAgdGV4dCxcbiAgICB3cmFwcGVyQ2xhc3NlcyxcbiAgICBsYWJlbEtleSxcbiAgICB2YWx1ZSxcbiAgfTogVHlwZWFoZWFkSW5wdXQpOiBQcm9taXNlPFR5cGVhaGVhZE91dHB1dD4gPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zOiBbXSB9O1xuICAgIH1cblxuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBDb21wbGV0aW9uSXRlbUdyb3VwW10gPSBbXTtcbiAgICBjb25zdCBsaW5lID0gdmFsdWUuYW5jaG9yQmxvY2suZ2V0VGV4dCgpO1xuICAgIGNvbnN0IGN1cnNvck9mZnNldCA9IHZhbHVlLnNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICAgIGNvbnN0IHN1ZmZpeCA9IGxpbmUuc3Vic3RyKGN1cnNvck9mZnNldCk7XG4gICAgY29uc3QgcHJlZml4ID0gbGluZS5zdWJzdHIoMCwgY3Vyc29yT2Zmc2V0KTtcbiAgICBjb25zdCBpc1ZhbHVlU3RhcnQgPSB0ZXh0Lm1hdGNoKC9eKD18PX58IT18IX4pLyk7XG4gICAgY29uc3QgaXNWYWx1ZUVuZCA9IHN1ZmZpeC5tYXRjaCgvXlwiP1ssfV18JC8pO1xuICAgIC8vIERldGVjdCBjdXJzb3IgaW4gZnJvbnQgb2YgdmFsdWUsIGUuZy4sIHtrZXk9fFwifVxuICAgIGNvbnN0IGlzUHJlVmFsdWUgPSBwcmVmaXgubWF0Y2goLyg9fD1+fCE9fCF+KSQvKSAmJiBzdWZmaXgubWF0Y2goL15cIi8pO1xuXG4gICAgLy8gRG9uJ3Qgc3VnZ2VzdCBhbnl0aGluZyBhdCB0aGUgYmVnaW5uaW5nIG9yIGluc2lkZSBhIHZhbHVlXG4gICAgY29uc3QgaXNWYWx1ZUVtcHR5ID0gaXNWYWx1ZVN0YXJ0ICYmIGlzVmFsdWVFbmQ7XG4gICAgY29uc3QgaGFzVmFsdWVQcmVmaXggPSBpc1ZhbHVlRW5kICYmICFpc1ZhbHVlU3RhcnQ7XG4gICAgaWYgKCghaXNWYWx1ZUVtcHR5ICYmICFoYXNWYWx1ZVByZWZpeCkgfHwgaXNQcmVWYWx1ZSkge1xuICAgICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbm9ybWFsaXplZCBzZWxlY3RvclxuICAgIGxldCBzZWxlY3RvcjtcbiAgICBsZXQgcGFyc2VkU2VsZWN0b3I7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFNlbGVjdG9yID0gcGFyc2VTZWxlY3RvcihsaW5lLCBjdXJzb3JPZmZzZXQpO1xuICAgICAgc2VsZWN0b3IgPSBwYXJzZWRTZWxlY3Rvci5zZWxlY3RvcjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHNlbGVjdG9yID0gRU1QVFlfU0VMRUNUT1I7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGFpbnNNZXRyaWMgPSBzZWxlY3Rvci5pbmNsdWRlcygnX19uYW1lX189Jyk7XG4gICAgY29uc3QgZXhpc3RpbmdLZXlzID0gcGFyc2VkU2VsZWN0b3IgPyBwYXJzZWRTZWxlY3Rvci5sYWJlbEtleXMgOiBbXTtcblxuICAgIGxldCBzZXJpZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuICAgIC8vIFF1ZXJ5IGxhYmVscyBmb3Igc2VsZWN0b3JcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHNlcmllcyA9IGF3YWl0IHRoaXMuZ2V0U2VyaWVzKHNlbGVjdG9yLCAhY29udGFpbnNNZXRyaWMpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhzZXJpZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKGBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gYW55IHZhbHVlcyBmb3Igc2VsZWN0b3IgPSAke3NlbGVjdG9yfWApO1xuICAgICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgICB9XG5cbiAgICBsZXQgY29udGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCh0ZXh0ICYmIGlzVmFsdWVTdGFydCkgfHwgd3JhcHBlckNsYXNzZXMuaW5jbHVkZXMoJ2F0dHItdmFsdWUnKSkge1xuICAgICAgLy8gTGFiZWwgdmFsdWVzXG4gICAgICBpZiAobGFiZWxLZXkgJiYgc2VyaWVzW2xhYmVsS2V5XSkge1xuICAgICAgICBjb250ZXh0ID0gJ2NvbnRleHQtbGFiZWwtdmFsdWVzJztcbiAgICAgICAgY29uc3QgbGltaXRJbmZvID0gYWRkTGltaXRJbmZvKHNlcmllc1tsYWJlbEtleV0pO1xuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICBsYWJlbDogYExhYmVsIHZhbHVlcyBmb3IgXCIke2xhYmVsS2V5fVwiJHtsaW1pdEluZm99YCxcbiAgICAgICAgICBpdGVtczogc2VyaWVzW2xhYmVsS2V5XS5tYXAod3JhcExhYmVsKSxcbiAgICAgICAgICBzZWFyY2hGdW5jdGlvblR5cGU6IFNlYXJjaEZ1bmN0aW9uVHlwZS5GdXp6eSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExhYmVsIGtleXNcbiAgICAgIGNvbnN0IGxhYmVsS2V5cyA9IHNlcmllcyA/IE9iamVjdC5rZXlzKHNlcmllcykgOiBjb250YWluc01ldHJpYyA/IG51bGwgOiBERUZBVUxUX0tFWVM7XG5cbiAgICAgIGlmIChsYWJlbEtleXMpIHtcbiAgICAgICAgY29uc3QgcG9zc2libGVLZXlzID0gZGlmZmVyZW5jZShsYWJlbEtleXMsIGV4aXN0aW5nS2V5cyk7XG4gICAgICAgIGlmIChwb3NzaWJsZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGV4dCA9ICdjb250ZXh0LWxhYmVscyc7XG4gICAgICAgICAgY29uc3QgbmV3SXRlbXMgPSBwb3NzaWJsZUtleXMubWFwKChrZXkpID0+ICh7IGxhYmVsOiBrZXkgfSkpO1xuICAgICAgICAgIGNvbnN0IGxpbWl0SW5mbyA9IGFkZExpbWl0SW5mbyhuZXdJdGVtcyk7XG4gICAgICAgICAgY29uc3QgbmV3U3VnZ2VzdGlvbjogQ29tcGxldGlvbkl0ZW1Hcm91cCA9IHtcbiAgICAgICAgICAgIGxhYmVsOiBgTGFiZWxzJHtsaW1pdEluZm99YCxcbiAgICAgICAgICAgIGl0ZW1zOiBuZXdJdGVtcyxcbiAgICAgICAgICAgIHNlYXJjaEZ1bmN0aW9uVHlwZTogU2VhcmNoRnVuY3Rpb25UeXBlLkZ1enp5LFxuICAgICAgICAgIH07XG4gICAgICAgICAgc3VnZ2VzdGlvbnMucHVzaChuZXdTdWdnZXN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGNvbnRleHQsIHN1Z2dlc3Rpb25zIH07XG4gIH07XG5cbiAgaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkobGFiZWxCYXNlZFF1ZXJ5OiBBYnN0cmFjdFF1ZXJ5KTogUHJvbVF1ZXJ5IHtcbiAgICByZXR1cm4gdG9Qcm9tTGlrZVF1ZXJ5KGxhYmVsQmFzZWRRdWVyeSk7XG4gIH1cblxuICBleHBvcnRUb0Fic3RyYWN0UXVlcnkocXVlcnk6IFByb21RdWVyeSk6IEFic3RyYWN0UXVlcnkge1xuICAgIGNvbnN0IHByb21RdWVyeSA9IHF1ZXJ5LmV4cHI7XG4gICAgaWYgKCFwcm9tUXVlcnkgfHwgcHJvbVF1ZXJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgcmVmSWQ6IHF1ZXJ5LnJlZklkLCBsYWJlbE1hdGNoZXJzOiBbXSB9O1xuICAgIH1cbiAgICBjb25zdCB0b2tlbnMgPSBQcmlzbS50b2tlbml6ZShwcm9tUXVlcnksIFByb21xbFN5bnRheCk7XG4gICAgY29uc3QgbGFiZWxNYXRjaGVyczogQWJzdHJhY3RMYWJlbE1hdGNoZXJbXSA9IGV4dHJhY3RMYWJlbE1hdGNoZXJzKHRva2Vucyk7XG4gICAgY29uc3QgbmFtZUxhYmVsVmFsdWUgPSBnZXROYW1lTGFiZWxWYWx1ZShwcm9tUXVlcnksIHRva2Vucyk7XG4gICAgaWYgKG5hbWVMYWJlbFZhbHVlICYmIG5hbWVMYWJlbFZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGxhYmVsTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdfX25hbWVfXycsXG4gICAgICAgIG9wZXJhdG9yOiBBYnN0cmFjdExhYmVsT3BlcmF0b3IuRXF1YWwsXG4gICAgICAgIHZhbHVlOiBuYW1lTGFiZWxWYWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZWZJZDogcXVlcnkucmVmSWQsXG4gICAgICBsYWJlbE1hdGNoZXJzLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBnZXRTZXJpZXMoc2VsZWN0b3I6IHN0cmluZywgd2l0aE5hbWU/OiBib29sZWFuKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4+IHtcbiAgICBpZiAodGhpcy5kYXRhc291cmNlLmxvb2t1cHNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaERlZmF1bHRTZXJpZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoU2VyaWVzTGFiZWxzKHNlbGVjdG9yLCB3aXRoTmFtZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFRPRE86IGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgZmV0Y2hMYWJlbFZhbHVlcyA9IGFzeW5jIChrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+ID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0VGltZVJhbmdlUGFyYW1zKCk7XG4gICAgY29uc3QgdXJsID0gYC9hcGkvdjEvbGFiZWwvJHt0aGlzLmRhdGFzb3VyY2UuaW50ZXJwb2xhdGVTdHJpbmcoa2V5KX0vdmFsdWVzYDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwgW10sIHBhcmFtcyk7XG4gIH07XG5cbiAgYXN5bmMgZ2V0TGFiZWxWYWx1ZXMoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hMYWJlbFZhbHVlcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYWxsIGxhYmVsIGtleXNcbiAgICovXG4gIGFzeW5jIGZldGNoTGFiZWxzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCB1cmwgPSAnL2FwaS92MS9sYWJlbHMnO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICB0aGlzLmxhYmVsRmV0Y2hUcyA9IERhdGUubm93KCkudmFsdWVPZigpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwgW10sIHBhcmFtcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSkge1xuICAgICAgdGhpcy5sYWJlbEtleXMgPSByZXMuc2xpY2UoKS5zb3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxhYmVscyBmb3IgYSBzZXJpZXMuIFRoaXMgaXMgY2FjaGVkIGJ5IGl0J3MgYXJncyBidXQgYWxzbyBieSB0aGUgZ2xvYmFsIHRpbWVSYW5nZSBjdXJyZW50bHkgc2VsZWN0ZWQgYXNcbiAgICogdGhleSBjYW4gY2hhbmdlIG92ZXIgcmVxdWVzdGVkIHRpbWUuXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwYXJhbSB3aXRoTmFtZVxuICAgKi9cbiAgZmV0Y2hTZXJpZXNMYWJlbHMgPSBhc3luYyAobmFtZTogc3RyaW5nLCB3aXRoTmFtZT86IGJvb2xlYW4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPj4gPT4ge1xuICAgIGNvbnN0IGludGVycG9sYXRlZE5hbWUgPSB0aGlzLmRhdGFzb3VyY2UuaW50ZXJwb2xhdGVTdHJpbmcobmFtZSk7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0VGltZVJhbmdlUGFyYW1zKCk7XG4gICAgY29uc3QgdXJsUGFyYW1zID0ge1xuICAgICAgLi4ucmFuZ2UsXG4gICAgICAnbWF0Y2hbXSc6IGludGVycG9sYXRlZE5hbWUsXG4gICAgfTtcbiAgICBjb25zdCB1cmwgPSBgL2FwaS92MS9zZXJpZXNgO1xuICAgIC8vIENhY2hlIGtleSBpcyBhIGJpdCBkaWZmZXJlbnQgaGVyZS4gV2UgYWRkIHRoZSBgd2l0aE5hbWVgIHBhcmFtIGFuZCBhbHNvIHJvdW5kIHVwIHRvIGEgbWludXRlIHRoZSBpbnRlcnZhbHMuXG4gICAgLy8gVGhlIHJvdW5kaW5nIG1heSBzZWVtIHN0cmFuZ2UgYnV0IG1ha2VzIHJlbGF0aXZlIGludGVydmFscyBsaWtlIG5vdy0xaCBsZXNzIHByb25lIHRvIG5lZWQgc2VwYXJhdGUgcmVxdWVzdCBldmVyeVxuICAgIC8vIG1pbGxpc2Vjb25kIHdoaWxlIHN0aWxsIGFjdHVhbGx5IGdldHRpbmcgYWxsIHRoZSBrZXlzIGZvciB0aGUgY29ycmVjdCBpbnRlcnZhbC4gVGhpcyBzdGlsbCBjYW4gY3JlYXRlIHByb2JsZW1zXG4gICAgLy8gd2hlbiB1c2VyIGRvZXMgbm90IHRoZSBuZXdlc3QgdmFsdWVzIGZvciBhIG1pbnV0ZSBpZiBhbHJlYWR5IGNhY2hlZC5cbiAgICBjb25zdCBjYWNoZVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgJ21hdGNoW10nOiBpbnRlcnBvbGF0ZWROYW1lLFxuICAgICAgc3RhcnQ6IHJvdW5kU2VjVG9NaW4ocGFyc2VJbnQocmFuZ2Uuc3RhcnQsIDEwKSkudG9TdHJpbmcoKSxcbiAgICAgIGVuZDogcm91bmRTZWNUb01pbihwYXJzZUludChyYW5nZS5lbmQsIDEwKSkudG9TdHJpbmcoKSxcbiAgICAgIHdpdGhOYW1lOiB3aXRoTmFtZSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjYWNoZUtleSA9IGAvYXBpL3YxL3Nlcmllcz8ke2NhY2hlUGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmxhYmVsc0NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIFtdLCB1cmxQYXJhbXMpO1xuICAgICAgY29uc3QgeyB2YWx1ZXMgfSA9IHByb2Nlc3NMYWJlbHMoZGF0YSwgd2l0aE5hbWUpO1xuICAgICAgdmFsdWUgPSB2YWx1ZXM7XG4gICAgICB0aGlzLmxhYmVsc0NhY2hlLnNldChjYWNoZUtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZldGNoIHNlcmllcyBmb3IgYSBzZWxlY3Rvci4gVXNlIHRoaXMgZm9yIHJhdyByZXN1bHRzLiBVc2UgZmV0Y2hTZXJpZXNMYWJlbHMoKSB0byBnZXQgbGFiZWxzLlxuICAgKiBAcGFyYW0gbWF0Y2hcbiAgICovXG4gIGZldGNoU2VyaWVzID0gYXN5bmMgKG1hdGNoOiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PFJlY29yZDxzdHJpbmcsIHN0cmluZz4+PiA9PiB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvdjEvc2VyaWVzJztcbiAgICBjb25zdCByYW5nZSA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7IC4uLnJhbmdlLCAnbWF0Y2hbXSc6IG1hdGNoIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIHt9LCBwYXJhbXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGlzIG9ubHkgb25lIGFzIHdlIGFzc3VtZSB0aGlzIHdvbid0IGNoYW5nZSBvdmVyIHRpbWUuIFRoaXMgaXMgY2FjaGVkIGRpZmZlcmVudGx5IGZyb20gZmV0Y2hTZXJpZXNMYWJlbHNcbiAgICogYmVjYXVzZSB3ZSBjYW4gY2FjaGUgbW9yZSBhZ2dyZXNzaXZlbHkgaGVyZSBhbmQgYWxzbyB3ZSBkbyBub3Qgd2FudCB0byBpbnZhbGlkYXRlIHRoaXMgY2FjaGUgdGhlIHNhbWUgd2F5IGFzIGluXG4gICAqIGZldGNoU2VyaWVzTGFiZWxzLlxuICAgKi9cbiAgZmV0Y2hEZWZhdWx0U2VyaWVzID0gb25jZShhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoREVGQVVMVF9LRVlTLm1hcCgoa2V5KSA9PiB0aGlzLmZldGNoTGFiZWxWYWx1ZXMoa2V5KSkpO1xuICAgIHJldHVybiBERUZBVUxUX0tFWVMucmVkdWNlKChhY2MsIGtleSwgaSkgPT4gKHsgLi4uYWNjLCBba2V5XTogdmFsdWVzW2ldIH0pLCB7fSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXROYW1lTGFiZWxWYWx1ZShwcm9tUXVlcnk6IHN0cmluZywgdG9rZW5zOiBhbnkpOiBzdHJpbmcge1xuICBsZXQgbmFtZUxhYmVsVmFsdWUgPSAnJztcbiAgZm9yIChsZXQgcHJvcCBpbiB0b2tlbnMpIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1twcm9wXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVMYWJlbFZhbHVlID0gdG9rZW5zW3Byb3BdIGFzIHN0cmluZztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmFtZUxhYmVsVmFsdWU7XG59XG4iLCJpbXBvcnQgeyBpbnZlcnQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVG9rZW4gfSBmcm9tICdwcmlzbWpzJztcblxuaW1wb3J0IHsgRGF0YVF1ZXJ5LCBBYnN0cmFjdFF1ZXJ5LCBBYnN0cmFjdExhYmVsT3BlcmF0b3IsIEFic3RyYWN0TGFiZWxNYXRjaGVyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IGFkZExhYmVsVG9RdWVyeSB9IGZyb20gJy4vYWRkX2xhYmVsX3RvX3F1ZXJ5JztcbmltcG9ydCB7IFNVR0dFU1RJT05TX0xJTUlUIH0gZnJvbSAnLi9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgeyBQcm9tTWV0cmljc01ldGFkYXRhLCBQcm9tTWV0cmljc01ldGFkYXRhSXRlbSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgcHJvY2Vzc0hpc3RvZ3JhbU1ldHJpY3MgPSAobWV0cmljczogc3RyaW5nW10pID0+IHtcbiAgY29uc3QgcmVzdWx0U2V0OiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cCgnX2J1Y2tldCgkfDopJyk7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtZXRyaWNzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IG1ldHJpYyA9IG1ldHJpY3NbaW5kZXhdO1xuICAgIGNvbnN0IGlzSGlzdG9ncmFtVmFsdWUgPSByZWdleHAudGVzdChtZXRyaWMpO1xuICAgIGlmIChpc0hpc3RvZ3JhbVZhbHVlKSB7XG4gICAgICByZXN1bHRTZXQuYWRkKG1ldHJpYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbLi4ucmVzdWx0U2V0XTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzTGFiZWxzKGxhYmVsczogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfT4sIHdpdGhOYW1lID0gZmFsc2UpIHtcbiAgLy8gRm9yIHByb2Nlc3Npbmcgd2UgYXJlIGdvaW5nIHRvIHVzZSBzZXRzIGFzIHRoZXkgaGF2ZSBzaWduaWZpY2FudGx5IGJldHRlciBwZXJmb3JtYW5jZSB0aGFuIGFycmF5c1xuICAvLyBBZnRlciB3ZSBwcm9jZXNzIGxhYmVscywgd2Ugd2lsbCBjb252ZXJ0IHNldHMgdG8gYXJyYXlzIGFuZCByZXR1cm4gb2JqZWN0IHdpdGggbGFiZWwgdmFsdWVzIGluIGFycmF5c1xuICBjb25zdCB2YWx1ZVNldDogeyBba2V5OiBzdHJpbmddOiBTZXQ8c3RyaW5nPiB9ID0ge307XG4gIGxhYmVscy5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgIGNvbnN0IHsgX19uYW1lX18sIC4uLnJlc3QgfSA9IGxhYmVsO1xuICAgIGlmICh3aXRoTmFtZSkge1xuICAgICAgdmFsdWVTZXRbJ19fbmFtZV9fJ10gPSB2YWx1ZVNldFsnX19uYW1lX18nXSB8fCBuZXcgU2V0KCk7XG4gICAgICBpZiAoIXZhbHVlU2V0WydfX25hbWVfXyddLmhhcyhfX25hbWVfXykpIHtcbiAgICAgICAgdmFsdWVTZXRbJ19fbmFtZV9fJ10uYWRkKF9fbmFtZV9fKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhyZXN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICghdmFsdWVTZXRba2V5XSkge1xuICAgICAgICB2YWx1ZVNldFtrZXldID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWx1ZVNldFtrZXldLmhhcyhyZXN0W2tleV0pKSB7XG4gICAgICAgIHZhbHVlU2V0W2tleV0uYWRkKHJlc3Rba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHZhbHVlQXJyYXkgdGhhdCB3ZSBhcmUgZ29pbmcgdG8gcmV0dXJuIGluIHRoZSBvYmplY3RcbiAgY29uc3QgdmFsdWVBcnJheTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmdbXSB9ID0ge307XG4gIGxpbWl0U3VnZ2VzdGlvbnMoT2JqZWN0LmtleXModmFsdWVTZXQpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICB2YWx1ZUFycmF5W2tleV0gPSBsaW1pdFN1Z2dlc3Rpb25zKEFycmF5LmZyb20odmFsdWVTZXRba2V5XSkpO1xuICB9KTtcblxuICByZXR1cm4geyB2YWx1ZXM6IHZhbHVlQXJyYXksIGtleXM6IE9iamVjdC5rZXlzKHZhbHVlQXJyYXkpIH07XG59XG5cbi8vIGNvbnN0IGNsZWFuU2VsZWN0b3JSZWdleHAgPSAvXFx7KFxcdys9XCJbXlwiXFxuXSo/XCIpKCxcXHcrPVwiW15cIlxcbl0qP1wiKSpcXH0vO1xuZXhwb3J0IGNvbnN0IHNlbGVjdG9yUmVnZXhwID0gL1xce1tefV0qPyhcXH18JCkvO1xuZXhwb3J0IGNvbnN0IGxhYmVsUmVnZXhwID0gL1xcYihcXHcrKSghPz1+PykoXCJbXlwiXFxuXSo/XCIpL2c7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTZWxlY3RvcihxdWVyeTogc3RyaW5nLCBjdXJzb3JPZmZzZXQgPSAxKTogeyBsYWJlbEtleXM6IGFueVtdOyBzZWxlY3Rvcjogc3RyaW5nIH0ge1xuICBpZiAoIXF1ZXJ5Lm1hdGNoKHNlbGVjdG9yUmVnZXhwKSkge1xuICAgIC8vIFNwZWNpYWwgbWF0Y2hlciBmb3IgbWV0cmljc1xuICAgIGlmIChxdWVyeS5tYXRjaCgvXltBLVphLXo6XVtcXHc6XSokLykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9yOiBge19fbmFtZV9fPVwiJHtxdWVyeX1cIn1gLFxuICAgICAgICBsYWJlbEtleXM6IFsnX19uYW1lX18nXSxcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkgbXVzdCBjb250YWluIGEgc2VsZWN0b3I6ICcgKyBxdWVyeSk7XG4gIH1cblxuICAvLyBDaGVjayBpZiBpbnNpZGUgYSBzZWxlY3RvclxuICBjb25zdCBwcmVmaXggPSBxdWVyeS5zbGljZSgwLCBjdXJzb3JPZmZzZXQpO1xuICBjb25zdCBwcmVmaXhPcGVuID0gcHJlZml4Lmxhc3RJbmRleE9mKCd7Jyk7XG4gIGNvbnN0IHByZWZpeENsb3NlID0gcHJlZml4Lmxhc3RJbmRleE9mKCd9Jyk7XG4gIGlmIChwcmVmaXhPcGVuID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGluc2lkZSBzZWxlY3RvciwgbWlzc2luZyBvcGVuIGJyYWNlOiAnICsgcHJlZml4KTtcbiAgfVxuICBpZiAocHJlZml4Q2xvc2UgPiAtMSAmJiBwcmVmaXhDbG9zZSA+IHByZWZpeE9wZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbnNpZGUgc2VsZWN0b3IsIHByZXZpb3VzIHNlbGVjdG9yIGFscmVhZHkgY2xvc2VkOiAnICsgcHJlZml4KTtcbiAgfVxuICBjb25zdCBzdWZmaXggPSBxdWVyeS5zbGljZShjdXJzb3JPZmZzZXQpO1xuICBjb25zdCBzdWZmaXhDbG9zZUluZGV4ID0gc3VmZml4LmluZGV4T2YoJ30nKTtcbiAgY29uc3Qgc3VmZml4Q2xvc2UgPSBzdWZmaXhDbG9zZUluZGV4ICsgY3Vyc29yT2Zmc2V0O1xuICBjb25zdCBzdWZmaXhPcGVuSW5kZXggPSBzdWZmaXguaW5kZXhPZigneycpO1xuICBjb25zdCBzdWZmaXhPcGVuID0gc3VmZml4T3BlbkluZGV4ICsgY3Vyc29yT2Zmc2V0O1xuICBpZiAoc3VmZml4Q2xvc2UgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW5zaWRlIHNlbGVjdG9yLCBtaXNzaW5nIGNsb3NpbmcgYnJhY2UgaW4gc3VmZml4OiAnICsgc3VmZml4KTtcbiAgfVxuICBpZiAoc3VmZml4T3BlbkluZGV4ID4gLTEgJiYgc3VmZml4T3BlbiA8IHN1ZmZpeENsb3NlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW5zaWRlIHNlbGVjdG9yLCBuZXh0IHNlbGVjdG9yIG9wZW5zIGJlZm9yZSB0aGlzIG9uZSBjbG9zZWQ6ICcgKyBzdWZmaXgpO1xuICB9XG5cbiAgLy8gRXh0cmFjdCBjbGVhbiBsYWJlbHMgdG8gZm9ybSBjbGVhbiBzZWxlY3RvciwgaW5jb21wbGV0ZSBsYWJlbHMgYXJlIGRyb3BwZWRcbiAgY29uc3Qgc2VsZWN0b3IgPSBxdWVyeS5zbGljZShwcmVmaXhPcGVuLCBzdWZmaXhDbG9zZSk7XG4gIGNvbnN0IGxhYmVsczogeyBba2V5OiBzdHJpbmddOiB7IHZhbHVlOiBzdHJpbmc7IG9wZXJhdG9yOiBzdHJpbmcgfSB9ID0ge307XG4gIHNlbGVjdG9yLnJlcGxhY2UobGFiZWxSZWdleHAsIChsYWJlbCwga2V5LCBvcGVyYXRvciwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBsYWJlbE9mZnNldCA9IHF1ZXJ5LmluZGV4T2YobGFiZWwpO1xuICAgIGNvbnN0IHZhbHVlU3RhcnQgPSBsYWJlbE9mZnNldCArIGtleS5sZW5ndGggKyBvcGVyYXRvci5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHZhbHVlRW5kID0gbGFiZWxPZmZzZXQgKyBrZXkubGVuZ3RoICsgb3BlcmF0b3IubGVuZ3RoICsgdmFsdWUubGVuZ3RoIC0gMTtcbiAgICAvLyBTa2lwIGxhYmVsIGlmIGN1cnNvciBpcyBpbiB2YWx1ZVxuICAgIGlmIChjdXJzb3JPZmZzZXQgPCB2YWx1ZVN0YXJ0IHx8IGN1cnNvck9mZnNldCA+IHZhbHVlRW5kKSB7XG4gICAgICBsYWJlbHNba2V5XSA9IHsgdmFsdWUsIG9wZXJhdG9yIH07XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG5cbiAgLy8gQWRkIG1ldHJpYyBpZiB0aGVyZSBpcyBvbmUgYmVmb3JlIHRoZSBzZWxlY3RvclxuICBjb25zdCBtZXRyaWNQcmVmaXggPSBxdWVyeS5zbGljZSgwLCBwcmVmaXhPcGVuKTtcbiAgY29uc3QgbWV0cmljTWF0Y2ggPSBtZXRyaWNQcmVmaXgubWF0Y2goL1tBLVphLXo6XVtcXHc6XSokLyk7XG4gIGlmIChtZXRyaWNNYXRjaCkge1xuICAgIGxhYmVsc1snX19uYW1lX18nXSA9IHsgdmFsdWU6IGBcIiR7bWV0cmljTWF0Y2hbMF19XCJgLCBvcGVyYXRvcjogJz0nIH07XG4gIH1cblxuICAvLyBCdWlsZCBzb3J0ZWQgc2VsZWN0b3JcbiAgY29uc3QgbGFiZWxLZXlzID0gT2JqZWN0LmtleXMobGFiZWxzKS5zb3J0KCk7XG4gIGNvbnN0IGNsZWFuU2VsZWN0b3IgPSBsYWJlbEtleXMubWFwKChrZXkpID0+IGAke2tleX0ke2xhYmVsc1trZXldLm9wZXJhdG9yfSR7bGFiZWxzW2tleV0udmFsdWV9YCkuam9pbignLCcpO1xuXG4gIGNvbnN0IHNlbGVjdG9yU3RyaW5nID0gWyd7JywgY2xlYW5TZWxlY3RvciwgJ30nXS5qb2luKCcnKTtcblxuICByZXR1cm4geyBsYWJlbEtleXMsIHNlbGVjdG9yOiBzZWxlY3RvclN0cmluZyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kUmVjb3JkaW5nUnVsZXMocXVlcnk6IHN0cmluZywgbWFwcGluZzogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH0pOiBzdHJpbmcge1xuICBjb25zdCBydWxlTmFtZXMgPSBPYmplY3Qua2V5cyhtYXBwaW5nKTtcbiAgY29uc3QgcnVsZXNSZWdleCA9IG5ldyBSZWdFeHAoYChcXFxcc3xeKSgke3J1bGVOYW1lcy5qb2luKCd8Jyl9KShcXFxcc3wkfFxcXFwofFxcXFxbfFxcXFx7KWAsICdpZycpO1xuICBjb25zdCBleHBhbmRlZFF1ZXJ5ID0gcXVlcnkucmVwbGFjZShydWxlc1JlZ2V4LCAobWF0Y2gsIHByZSwgbmFtZSwgcG9zdCkgPT4gYCR7cHJlfSR7bWFwcGluZ1tuYW1lXX0ke3Bvc3R9YCk7XG5cbiAgLy8gU3BsaXQgcXVlcnkgaW50byBhcnJheSwgc28gaWYgcXVlcnkgdXNlcyBvcGVyYXRvcnMsIHdlIGNhbiBjb3JyZWN0bHkgYWRkIGxhYmVscyB0byBlYWNoIGluZGl2aWR1YWwgcGFydC5cbiAgY29uc3QgcXVlcnlBcnJheSA9IGV4cGFuZGVkUXVlcnkuc3BsaXQoLyhcXCt8XFwtfFxcKnxcXC98XFwlfFxcXikvKTtcblxuICAvLyBSZWdleCB0aGF0IG1hdGNoZXMgb2NjdXJyZW5jZXMgb2YgKXsgb3IgfXsgb3IgXXsgd2hpY2ggaXMgYSBzaWduIG9mIGluY29ycmVjbHkgYWRkZWQgbGFiZWxzLlxuICBjb25zdCBpbnZhbGlkTGFiZWxzUmVnZXggPSAvKFxcKVxce3xcXH1cXHt8XFxdXFx7KS87XG4gIGNvbnN0IGNvcnJlY3RseUV4cGFuZGVkUXVlcnlBcnJheSA9IHF1ZXJ5QXJyYXkubWFwKChxdWVyeSkgPT4ge1xuICAgIHJldHVybiBhZGRMYWJlbHNUb0V4cHJlc3Npb24ocXVlcnksIGludmFsaWRMYWJlbHNSZWdleCk7XG4gIH0pO1xuXG4gIHJldHVybiBjb3JyZWN0bHlFeHBhbmRlZFF1ZXJ5QXJyYXkuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGFkZExhYmVsc1RvRXhwcmVzc2lvbihleHByOiBzdHJpbmcsIGludmFsaWRMYWJlbHNSZWdleHA6IFJlZ0V4cCkge1xuICBjb25zdCBtYXRjaCA9IGV4cHIubWF0Y2goaW52YWxpZExhYmVsc1JlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIFNwbGl0IHF1ZXJ5IGludG8gMiBwYXJ0cyAtIGJlZm9yZSB0aGUgaW52YWxpZExhYmVsc1JlZ2V4IG1hdGNoIGFuZCBhZnRlci5cbiAgY29uc3QgaW5kZXhPZlJlZ2V4TWF0Y2ggPSBtYXRjaC5pbmRleCA/PyAwO1xuICBjb25zdCBleHByQmVmb3JlUmVnZXhNYXRjaCA9IGV4cHIuc2xpY2UoMCwgaW5kZXhPZlJlZ2V4TWF0Y2ggKyAxKTtcbiAgY29uc3QgZXhwckFmdGVyUmVnZXhNYXRjaCA9IGV4cHIuc2xpY2UoaW5kZXhPZlJlZ2V4TWF0Y2ggKyAxKTtcblxuICAvLyBDcmVhdGUgYXJyYXlPZkxhYmVsT2JqZWN0cyB3aXRoIGxhYmVsIG9iamVjdHMgdGhhdCBoYXZlIGtleSwgb3BlcmF0b3IgYW5kIHZhbHVlLlxuICBjb25zdCBhcnJheU9mTGFiZWxPYmplY3RzOiBBcnJheTx7IGtleTogc3RyaW5nOyBvcGVyYXRvcjogc3RyaW5nOyB2YWx1ZTogc3RyaW5nIH0+ID0gW107XG4gIGV4cHJBZnRlclJlZ2V4TWF0Y2gucmVwbGFjZShsYWJlbFJlZ2V4cCwgKGxhYmVsLCBrZXksIG9wZXJhdG9yLCB2YWx1ZSkgPT4ge1xuICAgIGFycmF5T2ZMYWJlbE9iamVjdHMucHVzaCh7IGtleSwgb3BlcmF0b3IsIHZhbHVlIH0pO1xuICAgIHJldHVybiAnJztcbiAgfSk7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIGFsbCBsYWJlbCBvYmplY3RzIGFuZCBhZGQgdGhlbSB0byBxdWVyeS5cbiAgLy8gQXMgYSBzdGFydGluZyBwb2ludCB3ZSBoYXZlIHZhbGlkIHF1ZXJ5IHdpdGhvdXQgdGhlIGxhYmVscy5cbiAgbGV0IHJlc3VsdCA9IGV4cHJCZWZvcmVSZWdleE1hdGNoO1xuICBhcnJheU9mTGFiZWxPYmplY3RzLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKChvYmopID0+IHtcbiAgICAvLyBSZW1vdmUgZXh0cmEgc2V0IG9mIHF1b3RlcyBmcm9tIG9iai52YWx1ZVxuICAgIGNvbnN0IHZhbHVlID0gb2JqLnZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICByZXN1bHQgPSBhZGRMYWJlbFRvUXVlcnkocmVzdWx0LCBvYmoua2V5LCB2YWx1ZSwgb2JqLm9wZXJhdG9yKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBZGRzIG1ldGFkYXRhIGZvciBzeW50aGV0aWMgbWV0cmljcyBmb3Igd2hpY2ggdGhlIEFQSSBkb2VzIG5vdCBwcm92aWRlIG1ldGFkYXRhLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFmYW5hL2dyYWZhbmEvaXNzdWVzLzIyMzM3IGZvciBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSBtZXRhZGF0YSBIRUxQIGFuZCBUWVBFIG1ldGFkYXRhIGZyb20gL2FwaS92MS9tZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZml4U3VtbWFyaWVzTWV0YWRhdGEobWV0YWRhdGE6IHsgW21ldHJpYzogc3RyaW5nXTogUHJvbU1ldHJpY3NNZXRhZGF0YUl0ZW1bXSB9KTogUHJvbU1ldHJpY3NNZXRhZGF0YSB7XG4gIGlmICghbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH1cbiAgY29uc3QgYmFzZU1ldGFkYXRhOiBQcm9tTWV0cmljc01ldGFkYXRhID0ge307XG4gIGNvbnN0IHN1bW1hcnlNZXRhZGF0YTogUHJvbU1ldHJpY3NNZXRhZGF0YSA9IHt9O1xuICBmb3IgKGNvbnN0IG1ldHJpYyBpbiBtZXRhZGF0YSkge1xuICAgIC8vIE5PVEU6IGJhc2VkIG9uIHByb21ldGhldXMtZG9jdW1lbnRhdGlvbiwgd2UgY2FuIHJlY2VpdmVcbiAgICAvLyBtdWx0aXBsZSBtZXRhZGF0YS1lbnRyaWVzIGZvciB0aGUgZ2l2ZW4gbWV0cmljLCBpdCBzZWVtc1xuICAgIC8vIGl0IGhhcHBlbnMgd2hlbiB0aGUgc2FtZSBtZXRyaWMgaXMgb24gbXVsdGlwbGUgdGFyZ2V0c1xuICAgIC8vIGFuZCB0aGVpciBoZWxwLXRleHQgZGlmZmVyc1xuICAgIC8vIChodHRwczovL3Byb21ldGhldXMuaW8vZG9jcy9wcm9tZXRoZXVzL2xhdGVzdC9xdWVyeWluZy9hcGkvI3F1ZXJ5aW5nLW1ldHJpYy1tZXRhZGF0YSlcbiAgICAvLyBmb3Igbm93IHdlIGp1c3QgdXNlIHRoZSBmaXJzdCBlbnRyeS5cbiAgICBjb25zdCBpdGVtID0gbWV0YWRhdGFbbWV0cmljXVswXTtcbiAgICBiYXNlTWV0YWRhdGFbbWV0cmljXSA9IGl0ZW07XG5cbiAgICBpZiAoaXRlbS50eXBlID09PSAnaGlzdG9ncmFtJykge1xuICAgICAgc3VtbWFyeU1ldGFkYXRhW2Ake21ldHJpY31fYnVja2V0YF0gPSB7XG4gICAgICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICAgICAgaGVscDogYEN1bXVsYXRpdmUgY291bnRlcnMgZm9yIHRoZSBvYnNlcnZhdGlvbiBidWNrZXRzICgke2l0ZW0uaGVscH0pYCxcbiAgICAgIH07XG4gICAgICBzdW1tYXJ5TWV0YWRhdGFbYCR7bWV0cmljfV9jb3VudGBdID0ge1xuICAgICAgICB0eXBlOiAnY291bnRlcicsXG4gICAgICAgIGhlbHA6IGBDb3VudCBvZiBldmVudHMgdGhhdCBoYXZlIGJlZW4gb2JzZXJ2ZWQgZm9yIHRoZSBoaXN0b2dyYW0gbWV0cmljICgke2l0ZW0uaGVscH0pYCxcbiAgICAgIH07XG4gICAgICBzdW1tYXJ5TWV0YWRhdGFbYCR7bWV0cmljfV9zdW1gXSA9IHtcbiAgICAgICAgdHlwZTogJ2NvdW50ZXInLFxuICAgICAgICBoZWxwOiBgVG90YWwgc3VtIG9mIGFsbCBvYnNlcnZlZCB2YWx1ZXMgZm9yIHRoZSBoaXN0b2dyYW0gbWV0cmljICgke2l0ZW0uaGVscH0pYCxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpdGVtLnR5cGUgPT09ICdzdW1tYXJ5Jykge1xuICAgICAgc3VtbWFyeU1ldGFkYXRhW2Ake21ldHJpY31fY291bnRgXSA9IHtcbiAgICAgICAgdHlwZTogJ2NvdW50ZXInLFxuICAgICAgICBoZWxwOiBgQ291bnQgb2YgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIG9ic2VydmVkIGZvciB0aGUgYmFzZSBtZXRyaWMgKCR7aXRlbS5oZWxwfSlgLFxuICAgICAgfTtcbiAgICAgIHN1bW1hcnlNZXRhZGF0YVtgJHttZXRyaWN9X3N1bWBdID0ge1xuICAgICAgICB0eXBlOiAnY291bnRlcicsXG4gICAgICAgIGhlbHA6IGBUb3RhbCBzdW0gb2YgYWxsIG9ic2VydmVkIHZhbHVlcyBmb3IgdGhlIGJhc2UgbWV0cmljICgke2l0ZW0uaGVscH0pYCxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8vIFN5bnRoZXRpYyBzZXJpZXNcbiAgY29uc3Qgc3ludGhldGljTWV0YWRhdGE6IFByb21NZXRyaWNzTWV0YWRhdGEgPSB7fTtcbiAgc3ludGhldGljTWV0YWRhdGFbJ0FMRVJUUyddID0ge1xuICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICBoZWxwOiAnVGltZSBzZXJpZXMgc2hvd2luZyBwZW5kaW5nIGFuZCBmaXJpbmcgYWxlcnRzLiBUaGUgc2FtcGxlIHZhbHVlIGlzIHNldCB0byAxIGFzIGxvbmcgYXMgdGhlIGFsZXJ0IGlzIGluIHRoZSBpbmRpY2F0ZWQgYWN0aXZlIChwZW5kaW5nIG9yIGZpcmluZykgc3RhdGUuJyxcbiAgfTtcblxuICByZXR1cm4geyAuLi5iYXNlTWV0YWRhdGEsIC4uLnN1bW1hcnlNZXRhZGF0YSwgLi4uc3ludGhldGljTWV0YWRhdGEgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kTXNUb01pbihtaWxsaXNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiByb3VuZFNlY1RvTWluKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRTZWNUb01pbihzZWNvbmRzOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGltaXRTdWdnZXN0aW9ucyhpdGVtczogc3RyaW5nW10pIHtcbiAgcmV0dXJuIGl0ZW1zLnNsaWNlKDAsIFNVR0dFU1RJT05TX0xJTUlUKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExpbWl0SW5mbyhpdGVtczogYW55W10gfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICByZXR1cm4gaXRlbXMgJiYgaXRlbXMubGVuZ3RoID49IFNVR0dFU1RJT05TX0xJTUlUID8gYCwgbGltaXRlZCB0byB0aGUgZmlyc3QgJHtTVUdHRVNUSU9OU19MSU1JVH0gcmVjZWl2ZWQgaXRlbXNgIDogJyc7XG59XG5cbi8vIE5PVEU6IHRoZSBmb2xsb3dpbmcgMiBleHBvcnRlZCBmdW5jdGlvbnMgYXJlIHZlcnkgc2ltaWxhciB0byB0aGUgcHJvbWV0aGV1cypFc2NhcGVcbi8vIGZ1bmN0aW9ucyBpbiBkYXRhc291cmNlLnRzLCBidXQgdGhleSBhcmUgbm90IGV4YWN0bHkgdGhlIHNhbWUgYWxnb3JpdGhtLCBhbmQgd2UgZm91bmRcbi8vIG5vIHdheSB0byByZXVzZSBvbmUgaW4gdGhlIGFub3RoZXIgb3IgdmljZSB2ZXJzYS5cblxuLy8gUHJvbWV0aGV1cyByZWd1bGFyLWV4cHJlc3Npb25zIHVzZSB0aGUgUkUyIHN5bnRheCAoaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9yZTIvd2lraS9TeW50YXgpLFxuLy8gc28gZXZlcnkgY2hhcmFjdGVyIHRoYXQgbWF0Y2hlcyBzb21ldGhpbmcgaW4gdGhhdCBsaXN0IGhhcyB0byBiZSBlc2NhcGVkLlxuLy8gdGhlIGxpc3Qgb2YgbWV0YWNoYXJhY3RlcnMgaXM6ICorPygpfFxcLltde31eJFxuLy8gd2UgbWFrZSBhIGphdmFzY3JpcHQgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyB0aG9zZSBjaGFyYWN0ZXJzOlxuY29uc3QgUkUyX01FVEFDSEFSQUNURVJTID0gL1sqKz8oKXxcXFxcLlxcW1xcXXt9XiRdL2c7XG5mdW5jdGlvbiBlc2NhcGVQcm9tZXRoZXVzUmVnZXhwKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShSRTJfTUVUQUNIQVJBQ1RFUlMsICdcXFxcJCYnKTtcbn1cblxuLy8gYmFzZWQgb24gdGhlIG9wZW5tZXRyaWNzLWRvY3VtZW50YXRpb24sIHRoZSAzIHN5bWJvbHMgd2UgaGF2ZSB0byBoYW5kbGUgYXJlOlxuLy8gLSBcXG4gLi4uIHRoZSBuZXdsaW5lIGNoYXJhY3RlclxuLy8gLSBcXCAgLi4uIHRoZSBiYWNrc2xhc2ggY2hhcmFjdGVyXG4vLyAtIFwiICAuLi4gdGhlIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVMYWJlbFZhbHVlSW5FeGFjdFNlbGVjdG9yKGxhYmVsVmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBsYWJlbFZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUxhYmVsVmFsdWVJblJlZ2V4U2VsZWN0b3IobGFiZWxWYWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGVzY2FwZUxhYmVsVmFsdWVJbkV4YWN0U2VsZWN0b3IoZXNjYXBlUHJvbWV0aGV1c1JlZ2V4cChsYWJlbFZhbHVlKSk7XG59XG5cbmNvbnN0IEZyb21Qcm9tTGlrZU1hcDogUmVjb3JkPHN0cmluZywgQWJzdHJhY3RMYWJlbE9wZXJhdG9yPiA9IHtcbiAgJz0nOiBBYnN0cmFjdExhYmVsT3BlcmF0b3IuRXF1YWwsXG4gICchPSc6IEFic3RyYWN0TGFiZWxPcGVyYXRvci5Ob3RFcXVhbCxcbiAgJz1+JzogQWJzdHJhY3RMYWJlbE9wZXJhdG9yLkVxdWFsUmVnRXgsXG4gICchfic6IEFic3RyYWN0TGFiZWxPcGVyYXRvci5Ob3RFcXVhbFJlZ0V4LFxufTtcbmNvbnN0IFRvUHJvbUxpa2VNYXA6IFJlY29yZDxBYnN0cmFjdExhYmVsT3BlcmF0b3IsIHN0cmluZz4gPSBpbnZlcnQoRnJvbVByb21MaWtlTWFwKSBhcyBSZWNvcmQ8XG4gIEFic3RyYWN0TGFiZWxPcGVyYXRvcixcbiAgc3RyaW5nXG4+O1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Qcm9tTGlrZUV4cHIobGFiZWxCYXNlZFF1ZXJ5OiBBYnN0cmFjdFF1ZXJ5KTogc3RyaW5nIHtcbiAgY29uc3QgZXhwciA9IGxhYmVsQmFzZWRRdWVyeS5sYWJlbE1hdGNoZXJzXG4gICAgLm1hcCgoc2VsZWN0b3I6IEFic3RyYWN0TGFiZWxNYXRjaGVyKSA9PiB7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IFRvUHJvbUxpa2VNYXBbc2VsZWN0b3Iub3BlcmF0b3JdO1xuICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBgJHtzZWxlY3Rvci5uYW1lfSR7b3BlcmF0b3J9XCIke3NlbGVjdG9yLnZhbHVlfVwiYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9KVxuICAgIC5maWx0ZXIoKGU6IHN0cmluZykgPT4gZSAhPT0gJycpXG4gICAgLmpvaW4oJywgJyk7XG5cbiAgcmV0dXJuIGV4cHIgPyBgeyR7ZXhwcn19YCA6ICcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9Qcm9tTGlrZVF1ZXJ5KGxhYmVsQmFzZWRRdWVyeTogQWJzdHJhY3RRdWVyeSk6IFByb21MaWtlUXVlcnkge1xuICByZXR1cm4ge1xuICAgIHJlZklkOiBsYWJlbEJhc2VkUXVlcnkucmVmSWQsXG4gICAgZXhwcjogdG9Qcm9tTGlrZUV4cHIobGFiZWxCYXNlZFF1ZXJ5KSxcbiAgICByYW5nZTogdHJ1ZSxcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTGlrZVF1ZXJ5IGV4dGVuZHMgRGF0YVF1ZXJ5IHtcbiAgZXhwcjogc3RyaW5nO1xuICByYW5nZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RMYWJlbE1hdGNoZXJzKHRva2VuczogQXJyYXk8c3RyaW5nIHwgVG9rZW4+KTogQWJzdHJhY3RMYWJlbE1hdGNoZXJbXSB7XG4gIGNvbnN0IGxhYmVsTWF0Y2hlcnM6IEFic3RyYWN0TGFiZWxNYXRjaGVyW10gPSBbXTtcblxuICBmb3IgKGxldCBwcm9wIGluIHRva2Vucykge1xuICAgIGlmICh0b2tlbnNbcHJvcF0gaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgbGV0IHRva2VuOiBUb2tlbiA9IHRva2Vuc1twcm9wXSBhcyBUb2tlbjtcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSAnY29udGV4dC1sYWJlbHMnKSB7XG4gICAgICAgIGxldCBsYWJlbEtleSA9ICcnO1xuICAgICAgICBsZXQgbGFiZWxWYWx1ZSA9ICcnO1xuICAgICAgICBsZXQgbGFiZWxPcGVyYXRvciA9ICcnO1xuICAgICAgICBsZXQgY29udGVudFRva2VuczogYW55W10gPSB0b2tlbi5jb250ZW50IGFzIGFueVtdO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50VG9rZW4gaW4gY29udGVudFRva2Vucykge1xuICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRTdHI6IHN0cmluZztcbiAgICAgICAgICAgIGN1cnJlbnRTdHIgPSBjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0gYXMgc3RyaW5nO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHIgPT09ICc9JyB8fCBjdXJyZW50U3RyID09PSAnIT0nIHx8IGN1cnJlbnRTdHIgPT09ICc9ficgfHwgY3VycmVudFN0ciA9PT0gJyF+Jykge1xuICAgICAgICAgICAgICBsYWJlbE9wZXJhdG9yID0gY3VycmVudFN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXSBpbnN0YW5jZW9mIFRva2VuKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXS50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2xhYmVsLWtleSc6XG4gICAgICAgICAgICAgICAgbGFiZWxLZXkgPSBjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0uY29udGVudCBhcyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2xhYmVsLXZhbHVlJzpcbiAgICAgICAgICAgICAgICBsYWJlbFZhbHVlID0gY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dLmNvbnRlbnQgYXMgc3RyaW5nO1xuICAgICAgICAgICAgICAgIGxhYmVsVmFsdWUgPSBsYWJlbFZhbHVlLnN1YnN0cmluZygxLCBsYWJlbFZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsQ29tcGFyYXRvciA9IEZyb21Qcm9tTGlrZU1hcFtsYWJlbE9wZXJhdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxDb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICBsYWJlbE1hdGNoZXJzLnB1c2goeyBuYW1lOiBsYWJlbEtleSwgb3BlcmF0b3I6IGxhYmVsQ29tcGFyYXRvciwgdmFsdWU6IGxhYmVsVmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYWJlbE1hdGNoZXJzO1xufVxuIiwiaW1wb3J0IHsgR3JhbW1hciB9IGZyb20gJ3ByaXNtanMnO1xuXG5pbXBvcnQgeyBDb21wbGV0aW9uSXRlbSB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuLy8gV2hlbiBjaGFuZ2luZyBSQVRFX1JBTkdFUywgY2hlY2sgaWYgTG9raS9Mb2dRTCByYW5nZXMgc2hvdWxkIGJlIGNoYW5nZWQgdG9vXG4vLyBAc2VlIHB1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvbGFuZ3VhZ2VfcHJvdmlkZXIudHNcbmV4cG9ydCBjb25zdCBSQVRFX1JBTkdFUzogQ29tcGxldGlvbkl0ZW1bXSA9IFtcbiAgeyBsYWJlbDogJyRfX2ludGVydmFsJywgc29ydFZhbHVlOiAnJF9faW50ZXJ2YWwnIH0sXG4gIHsgbGFiZWw6ICckX19yYXRlX2ludGVydmFsJywgc29ydFZhbHVlOiAnJF9fcmF0ZV9pbnRlcnZhbCcgfSxcbiAgeyBsYWJlbDogJyRfX3JhbmdlJywgc29ydFZhbHVlOiAnJF9fcmFuZ2UnIH0sXG4gIHsgbGFiZWw6ICcxbScsIHNvcnRWYWx1ZTogJzAwOjAxOjAwJyB9LFxuICB7IGxhYmVsOiAnNW0nLCBzb3J0VmFsdWU6ICcwMDowNTowMCcgfSxcbiAgeyBsYWJlbDogJzEwbScsIHNvcnRWYWx1ZTogJzAwOjEwOjAwJyB9LFxuICB7IGxhYmVsOiAnMzBtJywgc29ydFZhbHVlOiAnMDA6MzA6MDAnIH0sXG4gIHsgbGFiZWw6ICcxaCcsIHNvcnRWYWx1ZTogJzAxOjAwOjAwJyB9LFxuICB7IGxhYmVsOiAnMWQnLCBzb3J0VmFsdWU6ICcyNDowMDowMCcgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBPUEVSQVRPUlMgPSBbJ2J5JywgJ2dyb3VwX2xlZnQnLCAnZ3JvdXBfcmlnaHQnLCAnaWdub3JpbmcnLCAnb24nLCAnb2Zmc2V0JywgJ3dpdGhvdXQnXTtcbmV4cG9ydCBjb25zdCBMT0dJQ0FMX09QRVJBVE9SUyA9IFsnb3InLCAnYW5kJywgJ3VubGVzcyddO1xuXG5jb25zdCBUUklHT05PTUVUUklDX0ZVTkNUSU9OUzogQ29tcGxldGlvbkl0ZW1bXSA9IFtcbiAge1xuICAgIGxhYmVsOiAnYWNvcycsXG4gICAgaW5zZXJ0VGV4dDogJ2Fjb3MnLFxuICAgIGRldGFpbDogJ2Fjb3ModiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBhcmNjb3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhY29zaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2Fjb3NoJyxcbiAgICBkZXRhaWw6ICdhY29zaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGludmVyc2UgaHlwZXJib2xpYyBjb3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhc2luJyxcbiAgICBpbnNlcnRUZXh0OiAnYXNpbicsXG4gICAgZGV0YWlsOiAnYXNpbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGFyY3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhc2luaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2FzaW5oJyxcbiAgICBkZXRhaWw6ICdhc2luaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGludmVyc2UgaHlwZXJib2xpYyBzaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXRhbicsXG4gICAgaW5zZXJ0VGV4dDogJ2F0YW4nLFxuICAgIGRldGFpbDogJ2F0YW4odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBhcmN0YW5nZW50IG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXRhbmgnLFxuICAgIGluc2VydFRleHQ6ICdhdGFuaCcsXG4gICAgZGV0YWlsOiAnYXRhbmgodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBpbnZlcnNlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2NvcycsXG4gICAgaW5zZXJ0VGV4dDogJ2NvcycsXG4gICAgZGV0YWlsOiAnY29zKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgY29zaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnY29zaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2Nvc2gnLFxuICAgIGRldGFpbDogJ2Nvc2godiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3NpbicsXG4gICAgaW5zZXJ0VGV4dDogJ3NpbicsXG4gICAgZGV0YWlsOiAnc2luKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3NpbmgnLFxuICAgIGluc2VydFRleHQ6ICdzaW5oJyxcbiAgICBkZXRhaWw6ICdzaW5oKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAndGFuJyxcbiAgICBpbnNlcnRUZXh0OiAndGFuJyxcbiAgICBkZXRhaWw6ICd0YW4odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSB0YW5nZW50IG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAndGFuaCcsXG4gICAgaW5zZXJ0VGV4dDogJ3RhbmgnLFxuICAgIGRldGFpbDogJ3RhbmgodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuXTtcblxuY29uc3QgQUdHUkVHQVRJT05fT1BFUkFUT1JTOiBDb21wbGV0aW9uSXRlbVtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdzdW0nLFxuICAgIGluc2VydFRleHQ6ICdzdW0nLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgc3VtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21pbicsXG4gICAgaW5zZXJ0VGV4dDogJ21pbicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtaW5pbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21heCcsXG4gICAgaW5zZXJ0VGV4dDogJ21heCcsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtYXhpbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2F2ZycsXG4gICAgaW5zZXJ0VGV4dDogJ2F2ZycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSB0aGUgYXZlcmFnZSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdncm91cCcsXG4gICAgaW5zZXJ0VGV4dDogJ2dyb3VwJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQWxsIHZhbHVlcyBpbiB0aGUgcmVzdWx0aW5nIHZlY3RvciBhcmUgMScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3N0ZGRldicsXG4gICAgaW5zZXJ0VGV4dDogJ3N0ZGRldicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSBwb3B1bGF0aW9uIHN0YW5kYXJkIGRldmlhdGlvbiBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdzdGR2YXInLFxuICAgIGluc2VydFRleHQ6ICdzdGR2YXInLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgcG9wdWxhdGlvbiBzdGFuZGFyZCB2YXJpYW5jZSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdjb3VudCcsXG4gICAgaW5zZXJ0VGV4dDogJ2NvdW50JyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ291bnQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB2ZWN0b3InLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdjb3VudF92YWx1ZXMnLFxuICAgIGluc2VydFRleHQ6ICdjb3VudF92YWx1ZXMnLFxuICAgIGRvY3VtZW50YXRpb246ICdDb3VudCBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSB2YWx1ZScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2JvdHRvbWsnLFxuICAgIGluc2VydFRleHQ6ICdib3R0b21rJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnU21hbGxlc3QgayBlbGVtZW50cyBieSBzYW1wbGUgdmFsdWUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICd0b3BrJyxcbiAgICBpbnNlcnRUZXh0OiAndG9waycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0xhcmdlc3QgayBlbGVtZW50cyBieSBzYW1wbGUgdmFsdWUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdxdWFudGlsZScsXG4gICAgaW5zZXJ0VGV4dDogJ3F1YW50aWxlJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlIM+GLXF1YW50aWxlICgwIOKJpCDPhiDiiaQgMSkgb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBGVU5DVElPTlMgPSBbXG4gIC4uLkFHR1JFR0FUSU9OX09QRVJBVE9SUyxcbiAgLi4uVFJJR09OT01FVFJJQ19GVU5DVElPTlMsXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzJyxcbiAgICBsYWJlbDogJ2FicycsXG4gICAgZGV0YWlsOiAnYWJzKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB0aGUgaW5wdXQgdmVjdG9yIHdpdGggYWxsIHNhbXBsZSB2YWx1ZXMgY29udmVydGVkIHRvIHRoZWlyIGFic29sdXRlIHZhbHVlLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzZW50JyxcbiAgICBsYWJlbDogJ2Fic2VudCcsXG4gICAgZGV0YWlsOiAnYWJzZW50KHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgYW4gZW1wdHkgdmVjdG9yIGlmIHRoZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBhbnkgZWxlbWVudHMgYW5kIGEgMS1lbGVtZW50IHZlY3RvciB3aXRoIHRoZSB2YWx1ZSAxIGlmIHRoZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBubyBlbGVtZW50cy4gVGhpcyBpcyB1c2VmdWwgZm9yIGFsZXJ0aW5nIG9uIHdoZW4gbm8gdGltZSBzZXJpZXMgZXhpc3QgZm9yIGEgZ2l2ZW4gbWV0cmljIG5hbWUgYW5kIGxhYmVsIGNvbWJpbmF0aW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzZW50X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdhYnNlbnRfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdhYnNlbnQodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgYW4gZW1wdHkgdmVjdG9yIGlmIHRoZSByYW5nZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBhbnkgZWxlbWVudHMgYW5kIGEgMS1lbGVtZW50IHZlY3RvciB3aXRoIHRoZSB2YWx1ZSAxIGlmIHRoZSByYW5nZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBubyBlbGVtZW50cy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NlaWwnLFxuICAgIGxhYmVsOiAnY2VpbCcsXG4gICAgZGV0YWlsOiAnY2VpbCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JvdW5kcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIHVwIHRvIHRoZSBuZWFyZXN0IGludGVnZXIuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjaGFuZ2VzJyxcbiAgICBsYWJlbDogJ2NoYW5nZXMnLFxuICAgIGRldGFpbDogJ2NoYW5nZXModiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0ZvciBlYWNoIGlucHV0IHRpbWUgc2VyaWVzLCBgY2hhbmdlcyh2IHJhbmdlLXZlY3RvcilgIHJldHVybnMgdGhlIG51bWJlciBvZiB0aW1lcyBpdHMgdmFsdWUgaGFzIGNoYW5nZWQgd2l0aGluIHRoZSBwcm92aWRlZCB0aW1lIHJhbmdlIGFzIGFuIGluc3RhbnQgdmVjdG9yLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY2xhbXAnLFxuICAgIGxhYmVsOiAnY2xhbXAnLFxuICAgIGRldGFpbDogJ2NsYW1wKHYgaW5zdGFudC12ZWN0b3IsIG1pbiBzY2FsYXIsIG1heCBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NsYW1wcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIHRvIGhhdmUgYSBsb3dlciBsaW1pdCBvZiBgbWluYCBhbmQgYW4gdXBwZXIgbGltaXQgb2YgYG1heGAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjbGFtcF9tYXgnLFxuICAgIGxhYmVsOiAnY2xhbXBfbWF4JyxcbiAgICBkZXRhaWw6ICdjbGFtcF9tYXgodiBpbnN0YW50LXZlY3RvciwgbWF4IHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDbGFtcHMgdGhlIHNhbXBsZSB2YWx1ZXMgb2YgYWxsIGVsZW1lbnRzIGluIGB2YCB0byBoYXZlIGFuIHVwcGVyIGxpbWl0IG9mIGBtYXhgLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY2xhbXBfbWluJyxcbiAgICBsYWJlbDogJ2NsYW1wX21pbicsXG4gICAgZGV0YWlsOiAnY2xhbXBfbWluKHYgaW5zdGFudC12ZWN0b3IsIG1pbiBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2xhbXBzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgdG8gaGF2ZSBhIGxvd2VyIGxpbWl0IG9mIGBtaW5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY291bnRfc2NhbGFyJyxcbiAgICBsYWJlbDogJ2NvdW50X3NjYWxhcicsXG4gICAgZGV0YWlsOiAnY291bnRfc2NhbGFyKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhIHRpbWUgc2VyaWVzIHZlY3RvciBhcyBhIHNjYWxhci4gVGhpcyBpcyBpbiBjb250cmFzdCB0byB0aGUgYGNvdW50KClgIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLCB3aGljaCBhbHdheXMgcmV0dXJucyBhIHZlY3RvciAoYW4gZW1wdHkgb25lIGlmIHRoZSBpbnB1dCB2ZWN0b3IgaXMgZW1wdHkpIGFuZCBhbGxvd3MgZ3JvdXBpbmcgYnkgbGFiZWxzIHZpYSBhIGBieWAgY2xhdXNlLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGVnJyxcbiAgICBsYWJlbDogJ2RlZycsXG4gICAgZGV0YWlsOiAnZGVnKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ29udmVydHMgcmFkaWFucyB0byBkZWdyZWVzIGZvciBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGF5X29mX21vbnRoJyxcbiAgICBsYWJlbDogJ2RheV9vZl9tb250aCcsXG4gICAgZGV0YWlsOiAnZGF5X29mX21vbnRoKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB0aGUgZGF5IG9mIHRoZSBtb250aCBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMSB0byAzMS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2RheV9vZl93ZWVrJyxcbiAgICBsYWJlbDogJ2RheV9vZl93ZWVrJyxcbiAgICBkZXRhaWw6ICdkYXlfb2Zfd2Vlayh2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDAgdG8gNiwgd2hlcmUgMCBtZWFucyBTdW5kYXkgZXRjLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGF5c19pbl9tb250aCcsXG4gICAgbGFiZWw6ICdkYXlzX2luX21vbnRoJyxcbiAgICBkZXRhaWw6ICdkYXlzX2luX21vbnRoKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRoIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuIFJldHVybmVkIHZhbHVlcyBhcmUgZnJvbSAyOCB0byAzMS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2RlbHRhJyxcbiAgICBsYWJlbDogJ2RlbHRhJyxcbiAgICBkZXRhaWw6ICdkZWx0YSh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCB2YWx1ZSBvZiBlYWNoIHRpbWUgc2VyaWVzIGVsZW1lbnQgaW4gYSByYW5nZSB2ZWN0b3IgYHZgLCByZXR1cm5pbmcgYW4gaW5zdGFudCB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gZGVsdGFzIGFuZCBlcXVpdmFsZW50IGxhYmVscy4gVGhlIGRlbHRhIGlzIGV4dHJhcG9sYXRlZCB0byBjb3ZlciB0aGUgZnVsbCB0aW1lIHJhbmdlIGFzIHNwZWNpZmllZCBpbiB0aGUgcmFuZ2UgdmVjdG9yIHNlbGVjdG9yLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGdldCBhIG5vbi1pbnRlZ2VyIHJlc3VsdCBldmVuIGlmIHRoZSBzYW1wbGUgdmFsdWVzIGFyZSBhbGwgaW50ZWdlcnMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkZXJpdicsXG4gICAgbGFiZWw6ICdkZXJpdicsXG4gICAgZGV0YWlsOiAnZGVyaXYodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIHBlci1zZWNvbmQgZGVyaXZhdGl2ZSBvZiB0aGUgdGltZSBzZXJpZXMgaW4gYSByYW5nZSB2ZWN0b3IgYHZgLCB1c2luZyBzaW1wbGUgbGluZWFyIHJlZ3Jlc3Npb24uJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkcm9wX2NvbW1vbl9sYWJlbHMnLFxuICAgIGxhYmVsOiAnZHJvcF9jb21tb25fbGFiZWxzJyxcbiAgICBkZXRhaWw6ICdkcm9wX2NvbW1vbl9sYWJlbHMoaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnRHJvcHMgYWxsIGxhYmVscyB0aGF0IGhhdmUgdGhlIHNhbWUgbmFtZSBhbmQgdmFsdWUgYWNyb3NzIGFsbCBzZXJpZXMgaW4gdGhlIGlucHV0IHZlY3Rvci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2V4cCcsXG4gICAgbGFiZWw6ICdleHAnLFxuICAgIGRldGFpbDogJ2V4cCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBleHBvbmVudGlhbCBmdW5jdGlvbiBmb3IgYWxsIGVsZW1lbnRzIGluIGB2YC5cXG5TcGVjaWFsIGNhc2VzIGFyZTpcXG4qIGBFeHAoK0luZikgPSArSW5mYCBcXG4qIGBFeHAoTmFOKSA9IE5hTmAnLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2Zsb29yJyxcbiAgICBsYWJlbDogJ2Zsb29yJyxcbiAgICBkZXRhaWw6ICdmbG9vcih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JvdW5kcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIGRvd24gdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2hpc3RvZ3JhbV9xdWFudGlsZScsXG4gICAgbGFiZWw6ICdoaXN0b2dyYW1fcXVhbnRpbGUnLFxuICAgIGRldGFpbDogJ2hpc3RvZ3JhbV9xdWFudGlsZSjPhiBmbG9hdCwgYiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgz4YtcXVhbnRpbGUgKDAg4omkIM+GIOKJpCAxKSBmcm9tIHRoZSBidWNrZXRzIGBiYCBvZiBhIGhpc3RvZ3JhbS4gVGhlIHNhbXBsZXMgaW4gYGJgIGFyZSB0aGUgY291bnRzIG9mIG9ic2VydmF0aW9ucyBpbiBlYWNoIGJ1Y2tldC4gRWFjaCBzYW1wbGUgbXVzdCBoYXZlIGEgbGFiZWwgYGxlYCB3aGVyZSB0aGUgbGFiZWwgdmFsdWUgZGVub3RlcyB0aGUgaW5jbHVzaXZlIHVwcGVyIGJvdW5kIG9mIHRoZSBidWNrZXQuIChTYW1wbGVzIHdpdGhvdXQgc3VjaCBhIGxhYmVsIGFyZSBzaWxlbnRseSBpZ25vcmVkLikgVGhlIGhpc3RvZ3JhbSBtZXRyaWMgdHlwZSBhdXRvbWF0aWNhbGx5IHByb3ZpZGVzIHRpbWUgc2VyaWVzIHdpdGggdGhlIGBfYnVja2V0YCBzdWZmaXggYW5kIHRoZSBhcHByb3ByaWF0ZSBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdob2x0X3dpbnRlcnMnLFxuICAgIGxhYmVsOiAnaG9sdF93aW50ZXJzJyxcbiAgICBkZXRhaWw6ICdob2x0X3dpbnRlcnModiByYW5nZS12ZWN0b3IsIHNmIHNjYWxhciwgdGYgc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdQcm9kdWNlcyBhIHNtb290aGVkIHZhbHVlIGZvciB0aW1lIHNlcmllcyBiYXNlZCBvbiB0aGUgcmFuZ2UgaW4gYHZgLiBUaGUgbG93ZXIgdGhlIHNtb290aGluZyBmYWN0b3IgYHNmYCwgdGhlIG1vcmUgaW1wb3J0YW5jZSBpcyBnaXZlbiB0byBvbGQgZGF0YS4gVGhlIGhpZ2hlciB0aGUgdHJlbmQgZmFjdG9yIGB0ZmAsIHRoZSBtb3JlIHRyZW5kcyBpbiB0aGUgZGF0YSBpcyBjb25zaWRlcmVkLiBCb3RoIGBzZmAgYW5kIGB0ZmAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdob3VyJyxcbiAgICBsYWJlbDogJ2hvdXInLFxuICAgIGRldGFpbDogJ2hvdXIodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHRoZSBob3VyIG9mIHRoZSBkYXkgZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDAgdG8gMjMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpZGVsdGEnLFxuICAgIGxhYmVsOiAnaWRlbHRhJyxcbiAgICBkZXRhaWw6ICdpZGVsdGEodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbGFzdCB0d28gc2FtcGxlcyBpbiB0aGUgcmFuZ2UgdmVjdG9yIGB2YCwgcmV0dXJuaW5nIGFuIGluc3RhbnQgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGRlbHRhcyBhbmQgZXF1aXZhbGVudCBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpbmNyZWFzZScsXG4gICAgbGFiZWw6ICdpbmNyZWFzZScsXG4gICAgZGV0YWlsOiAnaW5jcmVhc2UodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGluY3JlYXNlIGluIHRoZSB0aW1lIHNlcmllcyBpbiB0aGUgcmFuZ2UgdmVjdG9yLiBCcmVha3MgaW4gbW9ub3RvbmljaXR5IChzdWNoIGFzIGNvdW50ZXIgcmVzZXRzIGR1ZSB0byB0YXJnZXQgcmVzdGFydHMpIGFyZSBhdXRvbWF0aWNhbGx5IGFkanVzdGVkIGZvci4gVGhlIGluY3JlYXNlIGlzIGV4dHJhcG9sYXRlZCB0byBjb3ZlciB0aGUgZnVsbCB0aW1lIHJhbmdlIGFzIHNwZWNpZmllZCBpbiB0aGUgcmFuZ2UgdmVjdG9yIHNlbGVjdG9yLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGdldCBhIG5vbi1pbnRlZ2VyIHJlc3VsdCBldmVuIGlmIGEgY291bnRlciBpbmNyZWFzZXMgb25seSBieSBpbnRlZ2VyIGluY3JlbWVudHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpcmF0ZScsXG4gICAgbGFiZWw6ICdpcmF0ZScsXG4gICAgZGV0YWlsOiAnaXJhdGUodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIHBlci1zZWNvbmQgaW5zdGFudCByYXRlIG9mIGluY3JlYXNlIG9mIHRoZSB0aW1lIHNlcmllcyBpbiB0aGUgcmFuZ2UgdmVjdG9yLiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBsYXN0IHR3byBkYXRhIHBvaW50cy4gQnJlYWtzIGluIG1vbm90b25pY2l0eSAoc3VjaCBhcyBjb3VudGVyIHJlc2V0cyBkdWUgdG8gdGFyZ2V0IHJlc3RhcnRzKSBhcmUgYXV0b21hdGljYWxseSBhZGp1c3RlZCBmb3IuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdsYWJlbF9qb2luJyxcbiAgICBsYWJlbDogJ2xhYmVsX2pvaW4nLFxuICAgIGRldGFpbDpcbiAgICAgICdsYWJlbF9qb2luKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHNlcGFyYXRvciBzdHJpbmcsIHNyY19sYWJlbF8xIHN0cmluZywgc3JjX2xhYmVsXzIgc3RyaW5nLCAuLi4pJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0ZvciBlYWNoIHRpbWVzZXJpZXMgaW4gYHZgLCBqb2lucyBhbGwgdGhlIHZhbHVlcyBvZiBhbGwgdGhlIGBzcmNfbGFiZWxzYCB1c2luZyBgc2VwYXJhdG9yYCBhbmQgcmV0dXJucyB0aGUgdGltZXNlcmllcyB3aXRoIHRoZSBsYWJlbCBgZHN0X2xhYmVsYCBjb250YWluaW5nIHRoZSBqb2luZWQgdmFsdWUuIFRoZXJlIGNhbiBiZSBhbnkgbnVtYmVyIG9mIGBzcmNfbGFiZWxzYCBpbiB0aGlzIGZ1bmN0aW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbGFiZWxfcmVwbGFjZScsXG4gICAgbGFiZWw6ICdsYWJlbF9yZXBsYWNlJyxcbiAgICBkZXRhaWw6ICdsYWJlbF9yZXBsYWNlKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHJlcGxhY2VtZW50IHN0cmluZywgc3JjX2xhYmVsIHN0cmluZywgcmVnZXggc3RyaW5nKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgIFwiRm9yIGVhY2ggdGltZXNlcmllcyBpbiBgdmAsIGBsYWJlbF9yZXBsYWNlKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHJlcGxhY2VtZW50IHN0cmluZywgc3JjX2xhYmVsIHN0cmluZywgcmVnZXggc3RyaW5nKWAgIG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBgcmVnZXhgIGFnYWluc3QgdGhlIGxhYmVsIGBzcmNfbGFiZWxgLiAgSWYgaXQgbWF0Y2hlcywgdGhlbiB0aGUgdGltZXNlcmllcyBpcyByZXR1cm5lZCB3aXRoIHRoZSBsYWJlbCBgZHN0X2xhYmVsYCByZXBsYWNlZCBieSB0aGUgZXhwYW5zaW9uIG9mIGByZXBsYWNlbWVudGAuIGAkMWAgaXMgcmVwbGFjZWQgd2l0aCB0aGUgZmlyc3QgbWF0Y2hpbmcgc3ViZ3JvdXAsIGAkMmAgd2l0aCB0aGUgc2Vjb25kIGV0Yy4gSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkb2Vzbid0IG1hdGNoIHRoZW4gdGhlIHRpbWVzZXJpZXMgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlwiLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xuJyxcbiAgICBsYWJlbDogJ2xuJyxcbiAgICBkZXRhaWw6ICdsbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBmb3IgYWxsIGVsZW1lbnRzIGluIGB2YC5cXG5TcGVjaWFsIGNhc2VzIGFyZTpcXG4gKiBgbG4oK0luZikgPSArSW5mYFxcbiAqIGBsbigwKSA9IC1JbmZgXFxuICogYGxuKHggPCAwKSA9IE5hTmBcXG4gKiBgbG4oTmFOKSA9IE5hTmAnLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xvZzInLFxuICAgIGxhYmVsOiAnbG9nMicsXG4gICAgZGV0YWlsOiAnbG9nMih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBiaW5hcnkgbG9nYXJpdGhtIGZvciBhbGwgZWxlbWVudHMgaW4gYHZgLiBUaGUgc3BlY2lhbCBjYXNlcyBhcmUgZXF1aXZhbGVudCB0byB0aG9zZSBpbiBgbG5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbG9nMTAnLFxuICAgIGxhYmVsOiAnbG9nMTAnLFxuICAgIGRldGFpbDogJ2xvZzEwKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGRlY2ltYWwgbG9nYXJpdGhtIGZvciBhbGwgZWxlbWVudHMgaW4gYHZgLiBUaGUgc3BlY2lhbCBjYXNlcyBhcmUgZXF1aXZhbGVudCB0byB0aG9zZSBpbiBgbG5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbWludXRlJyxcbiAgICBsYWJlbDogJ21pbnV0ZScsXG4gICAgZGV0YWlsOiAnbWludXRlKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIG1pbnV0ZSBvZiB0aGUgaG91ciBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMCB0byA1OS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ21vbnRoJyxcbiAgICBsYWJlbDogJ21vbnRoJyxcbiAgICBkZXRhaWw6ICdtb250aCh2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBtb250aCBvZiB0aGUgeWVhciBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMSB0byAxMiwgd2hlcmUgMSBtZWFucyBKYW51YXJ5IGV0Yy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3BpJyxcbiAgICBsYWJlbDogJ3BpJyxcbiAgICBkZXRhaWw6ICdwaSgpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyBwaScsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncHJlZGljdF9saW5lYXInLFxuICAgIGxhYmVsOiAncHJlZGljdF9saW5lYXInLFxuICAgIGRldGFpbDogJ3ByZWRpY3RfbGluZWFyKHYgcmFuZ2UtdmVjdG9yLCB0IHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUHJlZGljdHMgdGhlIHZhbHVlIG9mIHRpbWUgc2VyaWVzIGB0YCBzZWNvbmRzIGZyb20gbm93LCBiYXNlZCBvbiB0aGUgcmFuZ2UgdmVjdG9yIGB2YCwgdXNpbmcgc2ltcGxlIGxpbmVhciByZWdyZXNzaW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmFkJyxcbiAgICBsYWJlbDogJ3JhZCcsXG4gICAgZGV0YWlsOiAncmFkKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ29udmVydHMgZGVncmVlcyB0byByYWRpYW5zIGZvciBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmF0ZScsXG4gICAgbGFiZWw6ICdyYXRlJyxcbiAgICBkZXRhaWw6ICdyYXRlKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgIFwiQ2FsY3VsYXRlcyB0aGUgcGVyLXNlY29uZCBhdmVyYWdlIHJhdGUgb2YgaW5jcmVhc2Ugb2YgdGhlIHRpbWUgc2VyaWVzIGluIHRoZSByYW5nZSB2ZWN0b3IuIEJyZWFrcyBpbiBtb25vdG9uaWNpdHkgKHN1Y2ggYXMgY291bnRlciByZXNldHMgZHVlIHRvIHRhcmdldCByZXN0YXJ0cykgYXJlIGF1dG9tYXRpY2FsbHkgYWRqdXN0ZWQgZm9yLiBBbHNvLCB0aGUgY2FsY3VsYXRpb24gZXh0cmFwb2xhdGVzIHRvIHRoZSBlbmRzIG9mIHRoZSB0aW1lIHJhbmdlLCBhbGxvd2luZyBmb3IgbWlzc2VkIHNjcmFwZXMgb3IgaW1wZXJmZWN0IGFsaWdubWVudCBvZiBzY3JhcGUgY3ljbGVzIHdpdGggdGhlIHJhbmdlJ3MgdGltZSBwZXJpb2QuXCIsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmVzZXRzJyxcbiAgICBsYWJlbDogJ3Jlc2V0cycsXG4gICAgZGV0YWlsOiAncmVzZXRzKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdGb3IgZWFjaCBpbnB1dCB0aW1lIHNlcmllcywgYHJlc2V0cyh2IHJhbmdlLXZlY3RvcilgIHJldHVybnMgdGhlIG51bWJlciBvZiBjb3VudGVyIHJlc2V0cyB3aXRoaW4gdGhlIHByb3ZpZGVkIHRpbWUgcmFuZ2UgYXMgYW4gaW5zdGFudCB2ZWN0b3IuIEFueSBkZWNyZWFzZSBpbiB0aGUgdmFsdWUgYmV0d2VlbiB0d28gY29uc2VjdXRpdmUgc2FtcGxlcyBpcyBpbnRlcnByZXRlZCBhcyBhIGNvdW50ZXIgcmVzZXQuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdyb3VuZCcsXG4gICAgbGFiZWw6ICdyb3VuZCcsXG4gICAgZGV0YWlsOiAncm91bmQodiBpbnN0YW50LXZlY3RvciwgdG9fbmVhcmVzdD0xIHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUm91bmRzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4gVGllcyBhcmUgcmVzb2x2ZWQgYnkgcm91bmRpbmcgdXAuIFRoZSBvcHRpb25hbCBgdG9fbmVhcmVzdGAgYXJndW1lbnQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIG5lYXJlc3QgbXVsdGlwbGUgdG8gd2hpY2ggdGhlIHNhbXBsZSB2YWx1ZXMgc2hvdWxkIGJlIHJvdW5kZWQuIFRoaXMgbXVsdGlwbGUgbWF5IGFsc28gYmUgYSBmcmFjdGlvbi4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NjYWxhcicsXG4gICAgbGFiZWw6ICdzY2FsYXInLFxuICAgIGRldGFpbDogJ3NjYWxhcih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdHaXZlbiBhIHNpbmdsZS1lbGVtZW50IGlucHV0IHZlY3RvciwgYHNjYWxhcih2IGluc3RhbnQtdmVjdG9yKWAgcmV0dXJucyB0aGUgc2FtcGxlIHZhbHVlIG9mIHRoYXQgc2luZ2xlIGVsZW1lbnQgYXMgYSBzY2FsYXIuIElmIHRoZSBpbnB1dCB2ZWN0b3IgZG9lcyBub3QgaGF2ZSBleGFjdGx5IG9uZSBlbGVtZW50LCBgc2NhbGFyYCB3aWxsIHJldHVybiBgTmFOYC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NnbicsXG4gICAgbGFiZWw6ICdzZ24nLFxuICAgIGRldGFpbDogJ3Nnbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIGEgdmVjdG9yIHdpdGggYWxsIHNhbXBsZSB2YWx1ZXMgY29udmVydGVkIHRvIHRoZWlyIHNpZ24sIGRlZmluZWQgYXMgdGhpczogMSBpZiB2IGlzIHBvc2l0aXZlLCAtMSBpZiB2IGlzIG5lZ2F0aXZlIGFuZCAwIGlmIHYgaXMgZXF1YWwgdG8gemVyby4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NvcnQnLFxuICAgIGxhYmVsOiAnc29ydCcsXG4gICAgZGV0YWlsOiAnc29ydCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdmVjdG9yIGVsZW1lbnRzIHNvcnRlZCBieSB0aGVpciBzYW1wbGUgdmFsdWVzLCBpbiBhc2NlbmRpbmcgb3JkZXIuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzb3J0X2Rlc2MnLFxuICAgIGxhYmVsOiAnc29ydF9kZXNjJyxcbiAgICBkZXRhaWw6ICdzb3J0X2Rlc2ModiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHZlY3RvciBlbGVtZW50cyBzb3J0ZWQgYnkgdGhlaXIgc2FtcGxlIHZhbHVlcywgaW4gZGVzY2VuZGluZyBvcmRlci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NxcnQnLFxuICAgIGxhYmVsOiAnc3FydCcsXG4gICAgZGV0YWlsOiAnc3FydCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZXMgdGhlIHNxdWFyZSByb290IG9mIGFsbCBlbGVtZW50cyBpbiBgdmAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICd0aW1lJyxcbiAgICBsYWJlbDogJ3RpbWUnLFxuICAgIGRldGFpbDogJ3RpbWUoKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAgVVRDLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhY3R1YWxseSByZXR1cm4gdGhlIGN1cnJlbnQgdGltZSwgYnV0IHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBleHByZXNzaW9uIGlzIHRvIGJlIGV2YWx1YXRlZC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3RpbWVzdGFtcCcsXG4gICAgbGFiZWw6ICd0aW1lc3RhbXAnLFxuICAgIGRldGFpbDogJ3RpbWVzdGFtcCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSB0aW1lc3RhbXAgb2YgZWFjaCBvZiB0aGUgc2FtcGxlcyBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGFzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAgVVRDLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAndmVjdG9yJyxcbiAgICBsYWJlbDogJ3ZlY3RvcicsXG4gICAgZGV0YWlsOiAndmVjdG9yKHMgc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdGhlIHNjYWxhciBgc2AgYXMgYSB2ZWN0b3Igd2l0aCBubyBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICd5ZWFyJyxcbiAgICBsYWJlbDogJ3llYXInLFxuICAgIGRldGFpbDogJ3llYXIodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHRoZSB5ZWFyIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdhdmdfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2F2Z19vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2F2Z19vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBhdmVyYWdlIHZhbHVlIG9mIGFsbCBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ21pbl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnbWluX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnbWluX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIG1pbmltdW0gdmFsdWUgb2YgYWxsIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbWF4X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdtYXhfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdtYXhfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbWF4aW11bSB2YWx1ZSBvZiBhbGwgcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzdW1fb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3N1bV9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ3N1bV9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBzdW0gb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY291bnRfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2NvdW50X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnY291bnRfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgY291bnQgb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncXVhbnRpbGVfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3F1YW50aWxlX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAncXVhbnRpbGVfb3Zlcl90aW1lKHNjYWxhciwgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSDPhi1xdWFudGlsZSAoMCDiiaQgz4Yg4omkIDEpIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N0ZGRldl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3RkZGV2X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3RkZGV2X292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIHBvcHVsYXRpb24gc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N0ZHZhcl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3RkdmFyX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3RkdmFyX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIHBvcHVsYXRpb24gc3RhbmRhcmQgdmFyaWFuY2Ugb2YgdGhlIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbGFzdF9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnbGFzdF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2xhc3Rfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbW9zdCByZWNlbnQgcG9pbnQgdmFsdWUgaW4gc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgUFJPTV9LRVlXT1JEUyA9IEZVTkNUSU9OUy5tYXAoKGtleXdvcmQpID0+IGtleXdvcmQubGFiZWwpO1xuXG5leHBvcnQgY29uc3QgcHJvbXFsR3JhbW1hcjogR3JhbW1hciA9IHtcbiAgY29tbWVudDoge1xuICAgIHBhdHRlcm46IC8jLiovLFxuICB9LFxuICAnY29udGV4dC1hZ2dyZWdhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKChieXx3aXRob3V0KVxccyopXFwoW14pXSpcXCkvLCAvLyBieSAoKVxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnbGFiZWwta2V5Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvW14oKSxcXHNdW14sKV0qW14pLFxcc10qLyxcbiAgICAgICAgYWxpYXM6ICdhdHRyLW5hbWUnLFxuICAgICAgfSxcbiAgICAgIHB1bmN0dWF0aW9uOiAvWygpXS8sXG4gICAgfSxcbiAgfSxcbiAgJ2NvbnRleHQtbGFiZWxzJzoge1xuICAgIHBhdHRlcm46IC9cXHtbXn1dKig/PX0/KS8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgY29tbWVudDoge1xuICAgICAgICBwYXR0ZXJuOiAvIy4qLyxcbiAgICAgIH0sXG4gICAgICAnbGFiZWwta2V5Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvW2Etel9dXFx3Kig/PVxccyooPXwhPXw9fnwhfikpLyxcbiAgICAgICAgYWxpYXM6ICdhdHRyLW5hbWUnLFxuICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICB9LFxuICAgICAgJ2xhYmVsLXZhbHVlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcLnxbXlxcXFxcIl0pKlwiLyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBhbGlhczogJ2F0dHItdmFsdWUnLFxuICAgICAgfSxcbiAgICAgIHB1bmN0dWF0aW9uOiAvW3tdLyxcbiAgICB9LFxuICB9LFxuICBmdW5jdGlvbjogbmV3IFJlZ0V4cChgXFxcXGIoPzoke0ZVTkNUSU9OUy5tYXAoKGYpID0+IGYubGFiZWwpLmpvaW4oJ3wnKX0pKD89XFxcXHMqXFxcXCgpYCwgJ2knKSxcbiAgJ2NvbnRleHQtcmFuZ2UnOiBbXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcW1teXFxdXSooPz1dKS8sIC8vIFsxbV1cbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKG9mZnNldFxccyspXFx3Ky8sIC8vIG9mZnNldCAxbVxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbiAgaWRMaXN0OiB7XG4gICAgcGF0dGVybjogL1xcZCsoXFx8XFxkKykrLyxcbiAgICBhbGlhczogJ251bWJlcicsXG4gIH0sXG4gIG51bWJlcjogL1xcYi0/XFxkKygoXFwuXFxkKik/KFtlRV1bKy1dP1xcZCspPyk/XFxiLyxcbiAgb3BlcmF0b3I6IG5ldyBSZWdFeHAoYC9bLSsqLz0lXn5dfCYmP3xcXFxcfD9cXFxcfHwhPT98PCg/Oj0+P3w8fD4pP3w+Wz49XT98XFxcXGIoPzoke09QRVJBVE9SUy5qb2luKCd8Jyl9KVxcXFxiYCwgJ2knKSxcbiAgcHVuY3R1YXRpb246IC9be307KClgLC5dLyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByb21xbEdyYW1tYXI7XG4iLCJpbXBvcnQgeyBGVU5DVElPTlMgfSBmcm9tICcuLi9wcm9tcWwnO1xuXG5pbXBvcnQgeyBnZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMgfSBmcm9tICcuL2FnZ3JlZ2F0aW9ucyc7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25EZWZpbml0aW9ucyB9IGZyb20gJy4vb3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIH0gZnJvbSAnLi9zaGFyZWQvTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnlQYXR0ZXJuLCBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgUHJvbVF1ZXJ5TW9kZWxsZXIgZXh0ZW5kcyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKCkgPT4ge1xuICAgICAgY29uc3QgYWxsT3BlcmF0aW9ucyA9IFsuLi5nZXRPcGVyYXRpb25EZWZpbml0aW9ucygpLCAuLi5nZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMoKV07XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIGFsbE9wZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZnVuYyA9IEZVTkNUSU9OUy5maW5kKCh4KSA9PiB4Lmluc2VydFRleHQgPT09IG9wLmlkKTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICBvcC5kb2N1bWVudGF0aW9uID0gZnVuYy5kb2N1bWVudGF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsT3BlcmF0aW9ucztcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0T3BlcmF0aW9uQ2F0ZWdvcmllcyhbXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5UaW1lLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0UXVlcnlQYXR0ZXJucygpOiBQcm9tUXVlcnlQYXR0ZXJuW10ge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdSYXRlIHRoZW4gc3VtJyxcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6ICdyYXRlJywgcGFyYW1zOiBbJyRfX3JhdGVfaW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdzdW0nLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnUmF0ZSB0aGVuIHN1bSBieShsYWJlbCkgdGhlbiBhdmcnLFxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogJ3JhdGUnLCBwYXJhbXM6IFsnJF9fcmF0ZV9pbnRlcnZhbCddIH0sXG4gICAgICAgICAgeyBpZDogJ19fc3VtX2J5JywgcGFyYW1zOiBbJyddIH0sXG4gICAgICAgICAgeyBpZDogJ2F2ZycsIHBhcmFtczogW10gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdIaXN0b2dyYW0gcXVhbnRpbGUgb24gcmF0ZScsXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiAncmF0ZScsIHBhcmFtczogWyckX19yYXRlX2ludGVydmFsJ10gfSxcbiAgICAgICAgICB7IGlkOiAnX19zdW1fYnknLCBwYXJhbXM6IFsnbGUnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdoaXN0b2dyYW1fcXVhbnRpbGUnLCBwYXJhbXM6IFswLjk1XSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0hpc3RvZ3JhbSBxdWFudGlsZSBvbiBpbmNyZWFzZSAnLFxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogJ2luY3JlYXNlJywgcGFyYW1zOiBbJyRfX3JhdGVfaW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdfX21heF9ieScsIHBhcmFtczogWydsZSddIH0sXG4gICAgICAgICAgeyBpZDogJ2hpc3RvZ3JhbV9xdWFudGlsZScsIHBhcmFtczogWzAuOTVdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIF07XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHByb21RdWVyeU1vZGVsbGVyID0gbmV3IFByb21RdWVyeU1vZGVsbGVyKCk7XG4iLCJpbXBvcnQgeyBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IgfSBmcm9tICcuL29wZXJhdGlvbnMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24sXG4gIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtLFxuICBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lLFxuICBnZXRSYW5nZVZlY3RvclBhcmFtRGVmLFxufSBmcm9tICcuL3NoYXJlZC9vcGVyYXRpb25VdGlscyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB9IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LCBQcm9tT3BlcmF0aW9uSWQgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFnZ3JlZ2F0aW9uT3BlcmF0aW9ucygpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIHJldHVybiBbXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLlN1bSksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLkF2ZyksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLk1pbiksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLk1heCksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLkNvdW50KSxcbiAgICAuLi5jcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbShQcm9tT3BlcmF0aW9uSWQuVG9wSywge1xuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnSy12YWx1ZScsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzVdLFxuICAgIH0pLFxuICAgIC4uLmNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtKFByb21PcGVyYXRpb25JZC5Cb3R0b21LLCB7XG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdLLXZhbHVlJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbNV0sXG4gICAgfSksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0oUHJvbU9wZXJhdGlvbklkLkNvdW50VmFsdWVzLCB7XG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdJZGVudGlmaWVyJywgdHlwZTogJ3N0cmluZycgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJ2NvdW50J10sXG4gICAgfSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuU3VtT3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkF2Z092ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5NaW5PdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuTWF4T3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkNvdW50T3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkxhc3RPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuUHJlc2VudE92ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5BYnNlbnRPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuU3RkZGV2T3ZlclRpbWUpLFxuICBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKG5hbWU6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB7XG4gIHJldHVybiB7XG4gICAgaWQ6IG5hbWUsXG4gICAgbmFtZTogZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKSxcbiAgICBwYXJhbXM6IFtnZXRSYW5nZVZlY3RvclBhcmFtRGVmKCldLFxuICAgIGRlZmF1bHRQYXJhbXM6IFsnJF9faW50ZXJ2YWwnXSxcbiAgICBhbHRlcm5hdGl2ZXNLZXk6ICdvdmVydGltZSBmdW5jdGlvbicsXG4gICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgIHJlbmRlcmVyOiBvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlcixcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IsXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmdcbikge1xuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnJF9faW50ZXJ2YWwnO1xuICByZXR1cm4gYCR7ZGVmLmlkfSgke2lubmVyRXhwcn1bJHtyYW5nZVZlY3Rvcn1dKWA7XG59XG4iLCJpbXBvcnQgeyBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlciB9IGZyb20gJy4vc2hhcmVkL29wZXJhdGlvblV0aWxzJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZiB9IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21PcGVyYXRpb25JZCwgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IGJpbmFyeVNjYWxhckRlZnMgPSBbXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkFkZGl0aW9uLFxuICAgIG5hbWU6ICdBZGQgc2NhbGFyJyxcbiAgICBzaWduOiAnKycsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLlN1YnRyYWN0aW9uLFxuICAgIG5hbWU6ICdTdWJ0cmFjdCBzY2FsYXInLFxuICAgIHNpZ246ICctJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTXVsdGlwbHlCeSxcbiAgICBuYW1lOiAnTXVsdGlwbHkgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnKicsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRpdmlkZUJ5LFxuICAgIG5hbWU6ICdEaXZpZGUgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnLycsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLk1vZHVsbyxcbiAgICBuYW1lOiAnTW9kdWxvIGJ5IHNjYWxhcicsXG4gICAgc2lnbjogJyUnLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5FeHBvbmVudCxcbiAgICBuYW1lOiAnRXhwb25lbnQnLFxuICAgIHNpZ246ICdeJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuRXF1YWxUbyxcbiAgICBuYW1lOiAnRXF1YWwgdG8nLFxuICAgIHNpZ246ICc9PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTm90RXF1YWxUbyxcbiAgICBuYW1lOiAnTm90IGVxdWFsIHRvJyxcbiAgICBzaWduOiAnIT0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkdyZWF0ZXJUaGFuLFxuICAgIG5hbWU6ICdHcmVhdGVyIHRoYW4nLFxuICAgIHNpZ246ICc+JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5MZXNzVGhhbixcbiAgICBuYW1lOiAnTGVzcyB0aGFuJyxcbiAgICBzaWduOiAnPCcsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuR3JlYXRlck9yRXF1YWwsXG4gICAgbmFtZTogJ0dyZWF0ZXIgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc+PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTGVzc09yRXF1YWwsXG4gICAgbmFtZTogJ0xlc3Mgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc8PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBiaW5hcnlTY2FsYXJPcGVyYXRvclRvT3BlcmF0b3JOYW1lID0gYmluYXJ5U2NhbGFyRGVmcy5yZWR1Y2UoKGFjYywgZGVmKSA9PiB7XG4gIGFjY1tkZWYuc2lnbl0gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBjb21wYXJpc29uOiBkZWYuY29tcGFyaXNvbixcbiAgfTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHsgaWQ6IHN0cmluZzsgY29tcGFyaXNvbj86IGJvb2xlYW4gfT4pO1xuXG4vLyBOb3Qgc3VyZSBhYm91dCB0aGlzIG9uZS4gSXQgY291bGQgYWxzbyBiZSBhIG1vcmUgZ2VuZXJpYyAnU2ltcGxlIG1hdGggb3BlcmF0aW9uJyB3aGVyZSB1c2VyIHNwZWNpZmllc1xuLy8gYm90aCB0aGUgb3BlcmF0b3IgYW5kIHRoZSBvcGVyYW5kIGluIGEgc2luZ2xlIGlucHV0XG5leHBvcnQgY29uc3QgYmluYXJ5U2NhbGFyT3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10gPSBiaW5hcnlTY2FsYXJEZWZzLm1hcCgob3BEZWYpID0+IHtcbiAgY29uc3QgcGFyYW1zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZltdID0gW3sgbmFtZTogJ1ZhbHVlJywgdHlwZTogJ251bWJlcicgfV07XG4gIGNvbnN0IGRlZmF1bHRQYXJhbXM6IGFueVtdID0gWzJdO1xuICBpZiAob3BEZWYuY29tcGFyaXNvbikge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIG5hbWU6ICdCb29sJyxcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnSWYgY2hlY2tlZCBjb21wYXJpc29uIHdpbGwgcmV0dXJuIDAgb3IgMSBmb3IgdGhlIHZhbHVlIHJhdGhlciB0aGFuIGZpbHRlcmluZy4nLFxuICAgIH0pO1xuICAgIGRlZmF1bHRQYXJhbXMucHVzaChmYWxzZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkOiBvcERlZi5pZCxcbiAgICBuYW1lOiBvcERlZi5uYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkZWZhdWx0UGFyYW1zLFxuICAgIGFsdGVybmF0aXZlc0tleTogJ2JpbmFyeSBzY2FsYXIgb3BlcmF0aW9ucycsXG4gICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICByZW5kZXJlcjogZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIob3BEZWYuc2lnbiksXG4gICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gIH07XG59KTtcblxuZnVuY3Rpb24gZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIob3BlcmF0b3I6IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gYmluYXJ5UmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgbGV0IHBhcmFtID0gbW9kZWwucGFyYW1zWzBdO1xuICAgIGxldCBib29sID0gJyc7XG4gICAgaWYgKG1vZGVsLnBhcmFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGJvb2wgPSBtb2RlbC5wYXJhbXNbMV0gPyAnIGJvb2wnIDogJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2lubmVyRXhwcn0gJHtvcGVyYXRvcn0ke2Jvb2x9ICR7cGFyYW19YDtcbiAgfTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgU2VsZWN0YWJsZVZhbHVlLCB0b09wdGlvbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU2VsZWN0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBwcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGdldE9wZXJhdGlvblBhcmFtSWQgfSBmcm9tICcuLi9zaGFyZWQvb3BlcmF0aW9uVXRpbHMnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gTGFiZWxQYXJhbUVkaXRvcih7XG4gIG9uQ2hhbmdlLFxuICBpbmRleCxcbiAgb3BlcmF0aW9uSW5kZXgsXG4gIHZhbHVlLFxuICBxdWVyeSxcbiAgZGF0YXNvdXJjZSxcbn06IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTx7XG4gICAgb3B0aW9ucz86IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxhbnk+PjtcbiAgICBpc0xvYWRpbmc/OiBib29sZWFuO1xuICB9Pih7fSk7XG5cbiAgcmV0dXJuIChcbiAgICA8U2VsZWN0XG4gICAgICBpbnB1dElkPXtnZXRPcGVyYXRpb25QYXJhbUlkKG9wZXJhdGlvbkluZGV4LCBpbmRleCl9XG4gICAgICBhdXRvRm9jdXM9e3ZhbHVlID09PSAnJyA/IHRydWUgOiB1bmRlZmluZWR9XG4gICAgICBvcGVuTWVudU9uRm9jdXNcbiAgICAgIG9uT3Blbk1lbnU9e2FzeW5jICgpID0+IHtcbiAgICAgICAgc2V0U3RhdGUoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBsb2FkR3JvdXBCeUxhYmVscyhxdWVyeSwgZGF0YXNvdXJjZSk7XG4gICAgICAgIHNldFN0YXRlKHsgb3B0aW9ucywgaXNMb2FkaW5nOiB1bmRlZmluZWQgfSk7XG4gICAgICB9fVxuICAgICAgaXNMb2FkaW5nPXtzdGF0ZS5pc0xvYWRpbmd9XG4gICAgICBhbGxvd0N1c3RvbVZhbHVlXG4gICAgICBub09wdGlvbnNNZXNzYWdlPVwiTm8gbGFiZWxzIGZvdW5kXCJcbiAgICAgIGxvYWRpbmdNZXNzYWdlPVwiTG9hZGluZyBsYWJlbHNcIlxuICAgICAgb3B0aW9ucz17c3RhdGUub3B0aW9uc31cbiAgICAgIHZhbHVlPXt0b09wdGlvbih2YWx1ZSBhcyBzdHJpbmcpfVxuICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4gb25DaGFuZ2UoaW5kZXgsIHZhbHVlLnZhbHVlISl9XG4gICAgLz5cbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZEdyb3VwQnlMYWJlbHMoXG4gIHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnksXG4gIGRhdGFzb3VyY2U6IERhdGFTb3VyY2VBcGlcbik6IFByb21pc2U8QXJyYXk8U2VsZWN0YWJsZVZhbHVlPGFueT4+PiB7XG4gIGxldCBsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10gPSBxdWVyeS5sYWJlbHM7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IGJvdGggUHJvbWV0aGV1cyBhbmQgTG9raSBhbmQgdGhpcyB0aGUgb25seSBkaWZmZXJlbmNlLlxuICBpZiAoZGF0YXNvdXJjZS50eXBlID09PSAncHJvbWV0aGV1cycpIHtcbiAgICBsYWJlbHMgPSBbeyBsYWJlbDogJ19fbmFtZV9fJywgb3A6ICc9JywgdmFsdWU6IHF1ZXJ5Lm1ldHJpYyB9LCAuLi5xdWVyeS5sYWJlbHNdO1xuICB9XG5cbiAgY29uc3QgZXhwciA9IHByb21RdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyhsYWJlbHMpO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hTZXJpZXNMYWJlbHMoZXhwcik7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3VsdCkubWFwKCh4KSA9PiAoe1xuICAgIGxhYmVsOiB4LFxuICAgIHZhbHVlOiB4LFxuICB9KSk7XG59XG4iLCJpbXBvcnQgeyBiaW5hcnlTY2FsYXJPcGVyYXRpb25zIH0gZnJvbSAnLi9iaW5hcnlTY2FsYXJPcGVyYXRpb25zJztcbmltcG9ydCB7IExhYmVsUGFyYW1FZGl0b3IgfSBmcm9tICcuL2NvbXBvbmVudHMvTGFiZWxQYXJhbUVkaXRvcic7XG5pbXBvcnQge1xuICBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gIGZ1bmN0aW9uUmVuZGVyZXJSaWdodCxcbiAgZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZSxcbiAgZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZixcbiAgcmFuZ2VSZW5kZXJlckxlZnRXaXRoUGFyYW1zLFxuICByYW5nZVJlbmRlcmVyUmlnaHRXaXRoUGFyYW1zLFxufSBmcm9tICcuL3NoYXJlZC9vcGVyYXRpb25VdGlscyc7XG5pbXBvcnQge1xuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgUXVlcnlXaXRoT3BlcmF0aW9ucyxcbiAgVmlzdWFsUXVlcnlNb2RlbGxlcixcbn0gZnJvbSAnLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbU9wZXJhdGlvbklkLCBQcm9tVmlzdWFsUXVlcnksIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25EZWZpbml0aW9ucygpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIGNvbnN0IGxpc3Q6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdID0gW1xuICAgIHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuSGlzdG9ncmFtUXVhbnRpbGUsXG4gICAgICBuYW1lOiAnSGlzdG9ncmFtIHF1YW50aWxlJyxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ1F1YW50aWxlJywgdHlwZTogJ251bWJlcicsIG9wdGlvbnM6IFswLjk5LCAwLjk1LCAwLjksIDAuNzUsIDAuNSwgMC4yNV0gfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMC45XSxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTGFiZWxSZXBsYWNlLFxuICAgICAgbmFtZTogJ0xhYmVsIHJlcGxhY2UnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHsgbmFtZTogJ0Rlc3RpbmF0aW9uIGxhYmVsJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBuYW1lOiAnUmVwbGFjZW1lbnQnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdTb3VyY2UgbGFiZWwnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdSZWdleCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICBdLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJywgJyQxJywgJycsICcoLiopJ10sXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlclJpZ2h0LFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkxuLFxuICAgICAgbmFtZTogJ0xuJyxcbiAgICAgIHBhcmFtczogW10sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbXSxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICB9LFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLkNoYW5nZXMpLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLlJhdGUsIHRydWUpLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLklyYXRlKSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5JbmNyZWFzZSwgdHJ1ZSksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuSWRlbHRhKSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5EZWx0YSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5Ib2x0V2ludGVycyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICBnZXRSYW5nZVZlY3RvclBhcmFtRGVmKCksXG4gICAgICAgIHsgbmFtZTogJ1Ntb290aGluZyBGYWN0b3InLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IG5hbWU6ICdUcmVuZCBGYWN0b3InLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJF9faW50ZXJ2YWwnLCAwLjUsIDAuNV0sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdyYW5nZSBmdW5jdGlvbicsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogcmFuZ2VSZW5kZXJlclJpZ2h0V2l0aFBhcmFtcyxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcixcbiAgICAgIGNoYW5nZVR5cGVIYW5kbGVyOiBvcGVyYXRpb25UeXBlQ2hhbmdlZEhhbmRsZXJGb3JSYW5nZUZ1bmN0aW9uLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUHJlZGljdExpbmVhcixcbiAgICAgIHBhcmFtczogW2dldFJhbmdlVmVjdG9yUGFyYW1EZWYoKSwgeyBuYW1lOiAnU2Vjb25kcyBmcm9tIG5vdycsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWyckX19pbnRlcnZhbCcsIDYwXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ3JhbmdlIGZ1bmN0aW9uJyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICAgIHJlbmRlcmVyOiByYW5nZVJlbmRlcmVyUmlnaHRXaXRoUGFyYW1zLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yLFxuICAgICAgY2hhbmdlVHlwZUhhbmRsZXI6IG9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24sXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5RdWFudGlsZU92ZXJUaW1lLFxuICAgICAgcGFyYW1zOiBbZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZigpLCB7IG5hbWU6ICdRdWFudGlsZScsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWyckX19pbnRlcnZhbCcsIDAuNV0sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdvdmVydGltZSBmdW5jdGlvbicsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogcmFuZ2VSZW5kZXJlckxlZnRXaXRoUGFyYW1zLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yLFxuICAgICAgY2hhbmdlVHlwZUhhbmRsZXI6IG9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24sXG4gICAgfSksXG4gICAgLi4uYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyxcbiAgICB7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLk5lc3RlZFF1ZXJ5LFxuICAgICAgbmFtZTogJ0JpbmFyeSBvcGVyYXRpb24gd2l0aCBxdWVyeScsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQmluYXJ5T3BzLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCwgZGVmLCBpbm5lckV4cHIpID0+IGlubmVyRXhwcixcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE5lc3RlZFF1ZXJ5SGFuZGxlcixcbiAgICB9LFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5BYnNlbnQgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5BY29zLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5BY29zaCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQXNpbixcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQXNpbmgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkF0YW4sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkF0YW5oLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkNlaWwgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5DbGFtcCxcbiAgICAgIG5hbWU6ICdDbGFtcCcsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAgeyBuYW1lOiAnTWluaW11bSBTY2FsYXInLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IG5hbWU6ICdNYXhpbXVtIFNjYWxhcicsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzEsIDFdLFxuICAgIH0pLFxuXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5DbGFtcE1heCxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ01heGltdW0gU2NhbGFyJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5DbGFtcE1pbixcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ01pbmltdW0gU2NhbGFyJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5Db3MsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkNvc2gsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRheU9mTW9udGgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVGltZSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRheU9mV2VlayxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5UaW1lLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuRGF5c0luTW9udGgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVGltZSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuRGVnIH0pLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLkRlcml2KSxcbiAgICAvL1xuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5FeHAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkZsb29yIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Hcm91cCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuSG91ciB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkxhYmVsSm9pbixcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ0Rlc3RpbmF0aW9uIExhYmVsJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlZGl0b3I6IExhYmVsUGFyYW1FZGl0b3IsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnU2VwYXJhdG9yJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdTb3VyY2UgTGFiZWwnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIHJlc3RQYXJhbTogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICBlZGl0b3I6IExhYmVsUGFyYW1FZGl0b3IsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnLCAnLCcsICcnXSxcbiAgICAgIHJlbmRlcmVyOiBsYWJlbEpvaW5SZW5kZXJlcixcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGxhYmVsSm9pbkFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkxvZzEwIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Mb2cyIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5NaW51dGUgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLk1vbnRoIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUGksXG4gICAgICByZW5kZXJlcjogKG1vZGVsKSA9PiBgJHttb2RlbC5pZH0oKWAsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5RdWFudGlsZSxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ1ZhbHVlJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlJhZCB9KSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5SZXNldHMpLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUm91bmQsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zLFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnVG8gTmVhcmVzdCcsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzFdLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5TY2FsYXIgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNnbiB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU2luLCBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlNpbmgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU29ydCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU29ydERlc2MgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNxcnQgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlN0ZGRldiB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlRhbixcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuVGFuaCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuVGltZSxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwpID0+IGAke21vZGVsLmlkfSgpYCxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuVGltZXN0YW1wIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuVmVjdG9yLFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnVmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsxXSxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwpID0+IGAke21vZGVsLmlkfSgke21vZGVsLnBhcmFtc1swXX0pYCxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuWWVhciB9KSxcbiAgXTtcblxuICByZXR1cm4gbGlzdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uKGRlZmluaXRpb246IFBhcnRpYWw8UXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPik6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB7XG4gIHJldHVybiB7XG4gICAgLi4uZGVmaW5pdGlvbixcbiAgICBpZDogZGVmaW5pdGlvbi5pZCEsXG4gICAgbmFtZTogZGVmaW5pdGlvbi5uYW1lID8/IGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUoZGVmaW5pdGlvbi5pZCEpLFxuICAgIHBhcmFtczogZGVmaW5pdGlvbi5wYXJhbXMgPz8gW10sXG4gICAgZGVmYXVsdFBhcmFtczogZGVmaW5pdGlvbi5kZWZhdWx0UGFyYW1zID8/IFtdLFxuICAgIGNhdGVnb3J5OiBkZWZpbml0aW9uLmNhdGVnb3J5ID8/IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICByZW5kZXJlcjogZGVmaW5pdGlvbi5yZW5kZXJlciA/PyAoZGVmaW5pdGlvbi5wYXJhbXMgPyBmdW5jdGlvblJlbmRlcmVyUmlnaHQgOiBmdW5jdGlvblJlbmRlcmVyTGVmdCksXG4gICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmaW5pdGlvbi5hZGRPcGVyYXRpb25IYW5kbGVyID8/IGRlZmF1bHRBZGRPcGVyYXRpb25IYW5kbGVyLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmFuZ2VGdW5jdGlvbihuYW1lOiBzdHJpbmcsIHdpdGhSYXRlSW50ZXJ2YWwgPSBmYWxzZSk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB7XG4gIHJldHVybiB7XG4gICAgaWQ6IG5hbWUsXG4gICAgbmFtZTogZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKSxcbiAgICBwYXJhbXM6IFtnZXRSYW5nZVZlY3RvclBhcmFtRGVmKHdpdGhSYXRlSW50ZXJ2YWwpXSxcbiAgICBkZWZhdWx0UGFyYW1zOiBbd2l0aFJhdGVJbnRlcnZhbCA/ICckX19yYXRlX2ludGVydmFsJyA6ICckX19pbnRlcnZhbCddLFxuICAgIGFsdGVybmF0aXZlc0tleTogJ3JhbmdlIGZ1bmN0aW9uJyxcbiAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgcmVuZGVyZXI6IG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyLFxuICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcixcbiAgICBjaGFuZ2VUeXBlSGFuZGxlcjogb3BlcmF0aW9uVHlwZUNoYW5nZWRIYW5kbGVyRm9yUmFuZ2VGdW5jdGlvbixcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3BlcmF0aW9uVHlwZUNoYW5nZWRIYW5kbGVyRm9yUmFuZ2VGdW5jdGlvbihcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIG5ld0RlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmXG4pIHtcbiAgLy8gdmFsaWRhdGUgY3VycmVudCBwYXJhbWV0ZXJcbiAgaWYgKG9wZXJhdGlvbi5wYXJhbXNbMF0gPT09ICckX19yYXRlX2ludGVydmFsJyAmJiBuZXdEZWYuZGVmYXVsdFBhcmFtc1swXSAhPT0gJyRfX3JhdGVfaW50ZXJ2YWwnKSB7XG4gICAgb3BlcmF0aW9uLnBhcmFtcyA9IG5ld0RlZi5kZWZhdWx0UGFyYW1zO1xuICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5wYXJhbXNbMF0gPT09ICckX19pbnRlcnZhbCcgJiYgbmV3RGVmLmRlZmF1bHRQYXJhbXNbMF0gIT09ICckX19pbnRlcnZhbCcpIHtcbiAgICBvcGVyYXRpb24ucGFyYW1zID0gbmV3RGVmLmRlZmF1bHRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gb3BlcmF0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yUmVuZGVyZXIoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIGxldCByYW5nZVZlY3RvciA9IChtb2RlbC5wYXJhbXMgPz8gW10pWzBdID8/ICc1bSc7XG4gIHJldHVybiBgJHtkZWYuaWR9KCR7aW5uZXJFeHByfVske3JhbmdlVmVjdG9yfV0pYDtcbn1cblxuLyoqXG4gKiBTaW5jZSB0aGVyZSBjYW4gb25seSBiZSBvbmUgb3BlcmF0aW9uIHdpdGggcmFuZ2UgdmVjdG9yIHRoaXMgd2lsbCByZXBsYWNlIHRoZSBjdXJyZW50IG9uZSAoaWYgb25lIHdhcyBhZGRlZCApXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IoXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5LFxuICBtb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlclxuKSB7XG4gIGNvbnN0IG5ld09wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgcGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcyxcbiAgfTtcblxuICBpZiAocXVlcnkub3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgLy8gSWYgb3BlcmF0aW9uIGV4aXN0cyBpdCBoYXMgdG8gYmUgaW4gdGhlIHJlZ2lzdHJ5IHNvIG5vIHBvaW50IHRvIGNoZWNrIGlmIGl0IHdhcyBmb3VuZFxuICAgIGNvbnN0IGZpcnN0T3AgPSBtb2RlbGxlci5nZXRPcGVyYXRpb25EZWYocXVlcnkub3BlcmF0aW9uc1swXS5pZCkhO1xuXG4gICAgaWYgKGZpcnN0T3AuYWRkT3BlcmF0aW9uSGFuZGxlciA9PT0gYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgb3BlcmF0aW9uczogW25ld09wZXJhdGlvbiwgLi4ucXVlcnkub3BlcmF0aW9ucy5zbGljZSgxKV0sXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucXVlcnksXG4gICAgb3BlcmF0aW9uczogW25ld09wZXJhdGlvbiwgLi4ucXVlcnkub3BlcmF0aW9uc10sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZE5lc3RlZFF1ZXJ5SGFuZGxlcihkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgcXVlcnk6IFByb21WaXN1YWxRdWVyeSk6IFByb21WaXN1YWxRdWVyeSB7XG4gIHJldHVybiB7XG4gICAgLi4ucXVlcnksXG4gICAgYmluYXJ5UXVlcmllczogW1xuICAgICAgLi4uKHF1ZXJ5LmJpbmFyeVF1ZXJpZXMgPz8gW10pLFxuICAgICAge1xuICAgICAgICBvcGVyYXRvcjogJy8nLFxuICAgICAgICBxdWVyeSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbGFiZWxKb2luUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwucGFyYW1zWzFdICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93ICdUaGUgc2VwYXJhdG9yIG11c3QgYmUgYSBzdHJpbmcnO1xuICB9XG4gIGNvbnN0IHNlcGFyYXRvciA9IGBcIiR7bW9kZWwucGFyYW1zWzFdfVwiYDtcbiAgcmV0dXJuIGAke21vZGVsLmlkfSgke2lubmVyRXhwcn0sIFwiJHttb2RlbC5wYXJhbXNbMF19XCIsICR7c2VwYXJhdG9yfSwgXCIke21vZGVsLnBhcmFtcy5zbGljZSgyKS5qb2luKHNlcGFyYXRvcil9XCIpYDtcbn1cblxuZnVuY3Rpb24gbGFiZWxKb2luQWRkT3BlcmF0aW9uSGFuZGxlcjxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4oZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIHF1ZXJ5OiBUKSB7XG4gIGNvbnN0IG5ld09wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgcGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcyxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIG9wZXJhdGlvbnM6IFsuLi5xdWVyeS5vcGVyYXRpb25zLCBuZXdPcGVyYXRpb25dLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgU3ludGF4Tm9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnbGV6ZXItcHJvbXFsJztcblxuaW1wb3J0IHsgYmluYXJ5U2NhbGFyT3BlcmF0b3JUb09wZXJhdG9yTmFtZSB9IGZyb20gJy4vYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyc7XG5pbXBvcnQge1xuICBFcnJvck5hbWUsXG4gIGdldEFsbEJ5VHlwZSxcbiAgZ2V0TGVmdE1vc3RDaGlsZCxcbiAgZ2V0U3RyaW5nLFxuICBtYWtlQmluT3AsXG4gIG1ha2VFcnJvcixcbiAgcmVwbGFjZVZhcmlhYmxlcyxcbn0gZnJvbSAnLi9zaGFyZWQvcGFyc2luZ1V0aWxzJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gfSBmcm9tICcuL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnksIFByb21WaXN1YWxRdWVyeUJpbmFyeSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFBhcnNlcyBhIFByb21RTCBxdWVyeSBpbnRvIGEgdmlzdWFsIHF1ZXJ5IG1vZGVsLlxuICpcbiAqIEl0IHRyYXZlcnNlcyB0aGUgdHJlZSBhbmQgdXNlcyBzb3J0IG9mIHN0YXRlIG1hY2hpbmUgdG8gdXBkYXRlIHRoZSBxdWVyeSBtb2RlbC4gVGhlIHF1ZXJ5IG1vZGVsIGlzIG1vZGlmaWVkXG4gKiBkdXJpbmcgdGhlIHRyYXZlcnNhbCBhbmQgc2VudCB0byBlYWNoIGhhbmRsZXIgYXMgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gZXhwclxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcoZXhwcjogc3RyaW5nKTogQ29udGV4dCB7XG4gIGNvbnN0IHJlcGxhY2VkRXhwciA9IHJlcGxhY2VWYXJpYWJsZXMoZXhwcik7XG4gIGNvbnN0IHRyZWUgPSBwYXJzZXIucGFyc2UocmVwbGFjZWRFeHByKTtcbiAgY29uc3Qgbm9kZSA9IHRyZWUudG9wTm9kZTtcblxuICAvLyBUaGlzIHdpbGwgYmUgbW9kaWZpZWQgaW4gdGhlIGhhbmRsZXJzLlxuICBjb25zdCB2aXNRdWVyeTogUHJvbVZpc3VhbFF1ZXJ5ID0ge1xuICAgIG1ldHJpYzogJycsXG4gICAgbGFiZWxzOiBbXSxcbiAgICBvcGVyYXRpb25zOiBbXSxcbiAgfTtcbiAgY29uc3QgY29udGV4dDogQ29udGV4dCA9IHtcbiAgICBxdWVyeTogdmlzUXVlcnksXG4gICAgZXJyb3JzOiBbXSxcbiAgfTtcblxuICB0cnkge1xuICAgIGhhbmRsZUV4cHJlc3Npb24ocmVwbGFjZWRFeHByLCBub2RlLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gTm90IGlkZWFsIHRvIGxvZyBpdCBoZXJlLCBidXQgb3RoZXJ3aXNlIHdlIHdvdWxkIGxvc2UgdGhlIHN0YWNrIHRyYWNlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goe1xuICAgICAgICB0ZXh0OiBlcnIubWVzc2FnZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgZW1wdHkgcXVlcnksIHdlIHdhbnQgdG8gcmVzZXQgZXJyb3JzXG4gIGlmIChpc0VtcHR5UXVlcnkoY29udGV4dC5xdWVyeSkpIHtcbiAgICBjb250ZXh0LmVycm9ycyA9IFtdO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5pbnRlcmZhY2UgUGFyc2luZ0Vycm9yIHtcbiAgdGV4dDogc3RyaW5nO1xuICBmcm9tPzogbnVtYmVyO1xuICB0bz86IG51bWJlcjtcbiAgcGFyZW50VHlwZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIENvbnRleHQge1xuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5O1xuICBlcnJvcnM6IFBhcnNpbmdFcnJvcltdO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGRlZmF1bHQgc3RhdGUuIEl0IHdpbGwgdHJhdmVyc2UgdGhlIHRyZWUgYW5kIGNhbGwgdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXIgZm9yIGVhY2ggbm9kZS4gVGhlIG5vZGVcbiAqIGhhbmRsZWQgaGVyZSBkb2VzIG5vdCBuZWNlc3NhcmlseSBuZWVkIHRvIGJlIG9mIHR5cGUgPT0gRXhwci5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUV4cHJlc3Npb24oZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgc3dpdGNoIChub2RlLm5hbWUpIHtcbiAgICBjYXNlICdNZXRyaWNJZGVudGlmaWVyJzoge1xuICAgICAgLy8gRXhwZWN0YXRpb24gaXMgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBvZiB0aG9zZSBwZXIgcXVlcnkuXG4gICAgICB2aXNRdWVyeS5tZXRyaWMgPSBnZXRTdHJpbmcoZXhwciwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMYWJlbE1hdGNoZXInOiB7XG4gICAgICAvLyBTYW1lIGFzIE1ldHJpY0lkZW50aWZpZXIgc2hvdWxkIGJlIGp1c3Qgb25lIHBlciBxdWVyeS5cbiAgICAgIHZpc1F1ZXJ5LmxhYmVscy5wdXNoKGdldExhYmVsKGV4cHIsIG5vZGUpKTtcbiAgICAgIGNvbnN0IGVyciA9IG5vZGUuZ2V0Q2hpbGQoRXJyb3JOYW1lKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgZXJyKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdGdW5jdGlvbkNhbGwnOiB7XG4gICAgICBoYW5kbGVGdW5jdGlvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0FnZ3JlZ2F0ZUV4cHInOiB7XG4gICAgICBoYW5kbGVBZ2dyZWdhdGlvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0JpbmFyeUV4cHInOiB7XG4gICAgICBoYW5kbGVCaW5hcnkoZXhwciwgbm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIEVycm9yTmFtZToge1xuICAgICAgaWYgKGlzSW50ZXJ2YWxWYXJpYWJsZUVycm9yKG5vZGUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgbm9kZSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKG5vZGUubmFtZSA9PT0gJ1BhcmVuRXhwcicpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBwYXJlbnRoZXNpcyBpbiB0aGUgcXVlcnkgdG8gZ3JvdXAgZXhwcmVzc2lvbnMuIFdlIGp1c3QgcmVwb3J0IGVycm9yIGJ1dCBnbyBvbiB3aXRoIHRoZVxuICAgICAgICAvLyBwYXJzaW5nLlxuICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG1ha2VFcnJvcihleHByLCBub2RlKSk7XG4gICAgICB9XG4gICAgICAvLyBBbnkgb3RoZXIgbm9kZXMgd2UganVzdCBpZ25vcmUgYW5kIGdvIHRvIGl0J3MgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIGZpbmUgYXMgdGhlcmUgYXJlIGxvdCdzIG9mIHdyYXBwZXJcbiAgICAgIC8vIG5vZGVzIHRoYXQgY2FuIGJlIHNraXBwZWQuXG4gICAgICAvLyBUT0RPOiB0aGVyZSBhcmUgcHJvYmFibHkgY2FzZXMgd2hlcmUgd2Ugd2lsbCBqdXN0IHNraXAgbm9kZXMgd2UgZG9uJ3Qgc3VwcG9ydCBhbmQgd2Ugc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgIC8vICBkZXRlY3QgdGhvc2UgYW5kIHJlcG9ydCBiYWNrLlxuICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVydmFsVmFyaWFibGVFcnJvcihub2RlOiBTeW50YXhOb2RlKSB7XG4gIHJldHVybiBub2RlLnByZXZTaWJsaW5nPy5uYW1lID09PSAnRXhwcicgJiYgbm9kZS5wcmV2U2libGluZz8uZmlyc3RDaGlsZD8ubmFtZSA9PT0gJ1ZlY3RvclNlbGVjdG9yJztcbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWwoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICBjb25zdCBsYWJlbCA9IGdldFN0cmluZyhleHByLCBub2RlLmdldENoaWxkKCdMYWJlbE5hbWUnKSk7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ01hdGNoT3AnKSk7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ1N0cmluZ0xpdGVyYWwnKSkucmVwbGFjZSgvXCIvZywgJycpO1xuICByZXR1cm4ge1xuICAgIGxhYmVsLFxuICAgIG9wLFxuICAgIHZhbHVlLFxuICB9O1xufVxuXG5jb25zdCByYW5nZUZ1bmN0aW9ucyA9IFsnY2hhbmdlcycsICdyYXRlJywgJ2lyYXRlJywgJ2luY3JlYXNlJywgJ2RlbHRhJ107XG4vKipcbiAqIEhhbmRsZSBmdW5jdGlvbiBjYWxsIHdoaWNoIGlzIHVzdWFsbHkgYW5kIGlkZW50aWZpZXIgYW5kIGl0cyBib2R5ID4gYXJndW1lbnRzLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBoYW5kbGVGdW5jdGlvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgdmlzUXVlcnkgPSBjb250ZXh0LnF1ZXJ5O1xuICBjb25zdCBuYW1lTm9kZSA9IG5vZGUuZ2V0Q2hpbGQoJ0Z1bmN0aW9uSWRlbnRpZmllcicpO1xuICBjb25zdCBmdW5jTmFtZSA9IGdldFN0cmluZyhleHByLCBuYW1lTm9kZSk7XG5cbiAgY29uc3QgYm9keSA9IG5vZGUuZ2V0Q2hpbGQoJ0Z1bmN0aW9uQ2FsbEJvZHknKTtcbiAgY29uc3QgY2FsbEFyZ3MgPSBib2R5IS5nZXRDaGlsZCgnRnVuY3Rpb25DYWxsQXJncycpO1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgbGV0IGludGVydmFsID0gJyc7XG5cbiAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIHNob3J0Y3V0IHRvIGdldCB0aGUgaW50ZXJ2YWwgYXJndW1lbnQuIFJlYXNvbnMgYXJlXG4gIC8vIC0gaW50ZXJ2YWwgaXMgbm90IHBhcnQgb2YgdGhlIGZ1bmN0aW9uIGFyZ3MgcGVyIHByb21RTCBncmFtbWFyIGJ1dCB3ZSBtb2RlbCBpdCBhcyBhcmd1bWVudCBmb3IgdGhlIGZ1bmN0aW9uIGluXG4gIC8vICAgdGhlIHF1ZXJ5IG1vZGVsLlxuICAvLyAtIGl0IGlzIGVhc2llciB0byBoYW5kbGUgdGVtcGxhdGUgdmFyaWFibGVzIHRoaXMgd2F5IGFzIHRlbXBsYXRlIHZhcmlhYmxlIGlzIGFuIGVycm9yIGZvciB0aGUgcGFyc2VyXG4gIGlmIChyYW5nZUZ1bmN0aW9ucy5pbmNsdWRlcyhmdW5jTmFtZSkgfHwgZnVuY05hbWUuZW5kc1dpdGgoJ19vdmVyX3RpbWUnKSkge1xuICAgIGxldCBtYXRjaCA9IGdldFN0cmluZyhleHByLCBub2RlKS5tYXRjaCgvXFxbKC4rKVxcXS8pO1xuICAgIGlmIChtYXRjaD8uWzFdKSB7XG4gICAgICBpbnRlcnZhbCA9IG1hdGNoWzFdO1xuICAgICAgcGFyYW1zLnB1c2gobWF0Y2hbMV0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9wID0geyBpZDogZnVuY05hbWUsIHBhcmFtcyB9O1xuICAvLyBXZSB1bnNoaWZ0IG9wZXJhdGlvbnMgdG8ga2VlcCB0aGUgbW9yZSBuYXR1cmFsIG9yZGVyIHRoYXQgd2Ugd2FudCB0byBoYXZlIGluIHRoZSB2aXN1YWwgcXVlcnkgZWRpdG9yLlxuICB2aXNRdWVyeS5vcGVyYXRpb25zLnVuc2hpZnQob3ApO1xuXG4gIGlmIChjYWxsQXJncykge1xuICAgIGlmIChnZXRTdHJpbmcoZXhwciwgY2FsbEFyZ3MpID09PSBpbnRlcnZhbCArICddJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBoYXZlIGEgZnVuY3Rpb24gd2l0aCBhIHNpbmdsZSBhcmd1bWVudCBhbmQgaXQgaXMgdGhlIGludGVydmFsLlxuICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4geW91IHN0YXJ0IGFkZGluZyBvcGVyYXRpb25zIGluIHF1ZXJ5IGJ1aWxkZXIgYW5kIGRpZCBub3Qgc2V0IGEgbWV0cmljIHlldC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHIsIGNhbGxBcmdzLCBjb250ZXh0LCBvcCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgYWdncmVnYXRpb24gYXMgdGhleSBhcmUgZGlzdGluY3QgdHlwZSBmcm9tIG90aGVyIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQWdncmVnYXRpb24oZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgY29uc3QgbmFtZU5vZGUgPSBub2RlLmdldENoaWxkKCdBZ2dyZWdhdGVPcCcpO1xuICBsZXQgZnVuY05hbWUgPSBnZXRTdHJpbmcoZXhwciwgbmFtZU5vZGUpO1xuXG4gIGNvbnN0IG1vZGlmaWVyID0gbm9kZS5nZXRDaGlsZCgnQWdncmVnYXRlTW9kaWZpZXInKTtcbiAgY29uc3QgbGFiZWxzID0gW107XG5cbiAgaWYgKG1vZGlmaWVyKSB7XG4gICAgY29uc3QgYnlNb2RpZmllciA9IG1vZGlmaWVyLmdldENoaWxkKGBCeWApO1xuICAgIGlmIChieU1vZGlmaWVyICYmIGZ1bmNOYW1lKSB7XG4gICAgICBmdW5jTmFtZSA9IGBfXyR7ZnVuY05hbWV9X2J5YDtcbiAgICB9XG5cbiAgICBjb25zdCB3aXRob3V0TW9kaWZpZXIgPSBtb2RpZmllci5nZXRDaGlsZChgV2l0aG91dGApO1xuICAgIGlmICh3aXRob3V0TW9kaWZpZXIpIHtcbiAgICAgIGZ1bmNOYW1lID0gYF9fJHtmdW5jTmFtZX1fd2l0aG91dGA7XG4gICAgfVxuXG4gICAgbGFiZWxzLnB1c2goLi4uZ2V0QWxsQnlUeXBlKGV4cHIsIG1vZGlmaWVyLCAnR3JvdXBpbmdMYWJlbCcpKTtcbiAgfVxuXG4gIGNvbnN0IGJvZHkgPSBub2RlLmdldENoaWxkKCdGdW5jdGlvbkNhbGxCb2R5Jyk7XG4gIGNvbnN0IGNhbGxBcmdzID0gYm9keSEuZ2V0Q2hpbGQoJ0Z1bmN0aW9uQ2FsbEFyZ3MnKTtcblxuICBjb25zdCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyBpZDogZnVuY05hbWUsIHBhcmFtczogW10gfTtcbiAgdmlzUXVlcnkub3BlcmF0aW9ucy51bnNoaWZ0KG9wKTtcbiAgdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHIsIGNhbGxBcmdzLCBjb250ZXh0LCBvcCk7XG4gIC8vIFdlIGFkZCBsYWJlbHMgYWZ0ZXIgcGFyYW1zIGluIHRoZSB2aXN1YWwgcXVlcnkgZWRpdG9yLlxuICBvcC5wYXJhbXMucHVzaCguLi5sYWJlbHMpO1xufVxuXG4vKipcbiAqIEhhbmRsZSAocHJvYmFibHkpIGFsbCB0eXBlcyBvZiBhcmd1bWVudHMgdGhhdCBmdW5jdGlvbiBvciBhZ2dyZWdhdGlvbiBjYW4gaGF2ZS5cbiAqXG4gKiAgRnVuY3Rpb25DYWxsQXJncyBhcmUgbmVzdGVkIGJpdCB3ZWlyZGx5IGJhc2ljYWxseSBpdHMgW2ZpcnN0QXJnLCAuLi5yZXN0XSB3aGVyZSByZXN0IGlzIGFnYWluIEZ1bmN0aW9uQ2FsbEFyZ3Mgc29cbiAqICB3ZSBjYW5ub3QganVzdCBnZXQgYWxsIHRoZSBjaGlsZHJlbiBhbmQgaXRlcmF0ZSB0aGVtIGFzIGFyZ3VtZW50cyB3ZSBoYXZlIHRvIGFnYWluIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRocm91Z2hcbiAqICB0aGVtLlxuICpcbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqIEBwYXJhbSBvcCAtIFdlIG5lZWQgdGhlIG9wZXJhdGlvbiB0byBhZGQgdGhlIHBhcmFtcyB0byBhcyBhbiBhZGRpdGlvbmFsIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQXJncyhleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUgfCBudWxsLCBjb250ZXh0OiBDb250ZXh0LCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzd2l0Y2ggKG5vZGUubmFtZSkge1xuICAgIC8vIEluIGNhc2Ugd2UgaGF2ZSBhbiBleHByZXNzaW9uIHdlIGRvbid0IGtub3cgd2hhdCBraW5kIHNvIHdlIGhhdmUgdG8gbG9vayBhdCB0aGUgY2hpbGQgYXMgaXQgY2FuIGJlIGFueXRoaW5nLlxuICAgIGNhc2UgJ0V4cHInOlxuICAgIC8vIEZ1bmN0aW9uQ2FsbEFyZ3MgYXJlIG5lc3RlZCBiaXQgd2VpcmRseSBhcyBtZW50aW9uZWQgc28gd2UgaGF2ZSB0byBnbyBvbmUgZGVlcGVyIGluIHRoaXMgY2FzZS5cbiAgICBjYXNlICdGdW5jdGlvbkNhbGxBcmdzJzoge1xuICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHVwZGF0ZUZ1bmN0aW9uQXJncyhleHByLCBjaGlsZCwgY29udGV4dCwgb3ApO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTnVtYmVyTGl0ZXJhbCc6IHtcbiAgICAgIG9wLnBhcmFtcy5wdXNoKHBhcnNlRmxvYXQoZ2V0U3RyaW5nKGV4cHIsIG5vZGUpKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzoge1xuICAgICAgb3AucGFyYW1zLnB1c2goZ2V0U3RyaW5nKGV4cHIsIG5vZGUpLnJlcGxhY2UoL1wiL2csICcnKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICAvLyBNZWFucyB3ZSBnZXQgdG8gc29tZXRoaW5nIHRoYXQgZG9lcyBub3Qgc2VlbSBsaWtlIHNpbXBsZSBmdW5jdGlvbiBhcmcgYW5kIGlzIHByb2JhYmx5IG5lc3RlZCBxdWVyeSBzbyBqdW1wXG4gICAgICAvLyBiYWNrIHRvIG1haW4gY29udGV4dFxuICAgICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSaWdodCBub3cgYmluYXJ5IGV4cHJlc3Npb25zIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheSBpbiB2aXN1YWwgcXVlcnkuIEFzIGFkZGl0aW9uYWwgb3BlcmF0aW9uIGluIGNhc2UgaXQgaXNcbiAqIGp1c3Qgb3BlcmF0aW9uIHdpdGggc2NhbGFyIG9yIGl0IGNyZWF0ZXMgYSBiaW5hcnlRdWVyeSB3aGVuIGl0J3MgMiBxdWVyaWVzLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBoYW5kbGVCaW5hcnkoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgY29uc3QgbGVmdCA9IG5vZGUuZmlyc3RDaGlsZCE7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIGxlZnQubmV4dFNpYmxpbmcpO1xuICBjb25zdCBiaW5Nb2RpZmllciA9IGdldEJpbmFyeU1vZGlmaWVyKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ0Jpbk1vZGlmaWVycycpKTtcblxuICBjb25zdCByaWdodCA9IG5vZGUubGFzdENoaWxkITtcblxuICBjb25zdCBvcERlZiA9IGJpbmFyeVNjYWxhck9wZXJhdG9yVG9PcGVyYXRvck5hbWVbb3BdO1xuXG4gIGNvbnN0IGxlZnROdW1iZXIgPSBsZWZ0LmdldENoaWxkKCdOdW1iZXJMaXRlcmFsJyk7XG4gIGNvbnN0IHJpZ2h0TnVtYmVyID0gcmlnaHQuZ2V0Q2hpbGQoJ051bWJlckxpdGVyYWwnKTtcblxuICBjb25zdCByaWdodEJpbmFyeSA9IHJpZ2h0LmdldENoaWxkKCdCaW5hcnlFeHByJyk7XG5cbiAgaWYgKGxlZnROdW1iZXIpIHtcbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhbHJlYWR5IGhhbmRsZWQgaW4gY2FzZSBwYXJlbnQgaXMgYmluYXJ5IGV4cHJlc3Npb24gYXMgaXQgaGFzIHRvIGJlIGFkZGVkIHRvIHBhcmVudFxuICAgIC8vICBpZiBxdWVyeSBzdGFydHMgd2l0aCBhIG51bWJlciB0aGF0IGlzbid0IGhhbmRsZWQgbm93LlxuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoaXMgaXMgYmluYXJ5IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIHRoZXJlIGlzIGEgcXVlcnkgb3IganVzdCBjaGFpbmVkIHNjYWxhcnMuIFNvXG4gICAgLy8gd2UgaGF2ZSB0byB0cmF2ZXJzZSBhIGJpdCBkZWVwZXIgdG8ga25vd1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgbGVmdCwgY29udGV4dCk7XG4gIH1cblxuICBpZiAocmlnaHROdW1iZXIpIHtcbiAgICB2aXNRdWVyeS5vcGVyYXRpb25zLnB1c2gobWFrZUJpbk9wKG9wRGVmLCBleHByLCByaWdodCwgISFiaW5Nb2RpZmllcj8uaXNCb29sKSk7XG4gIH0gZWxzZSBpZiAocmlnaHRCaW5hcnkpIHtcbiAgICAvLyBEdWUgdG8gdGhlIHdheSBiaW5hcnkgb3BzIGFyZSBwYXJzZWQgd2UgY2FuIGdldCBhIGJpbmFyeSBvcGVyYXRpb24gb24gdGhlIHJpZ2h0IHRoYXQgc3RhcnRzIHdpdGggYSBudW1iZXIgd2hpY2hcbiAgICAvLyBpcyBhIGZhY3RvciBmb3IgYSBjdXJyZW50IGJpbmFyeSBvcGVyYXRpb24uIFNvIHdlIGhhdmUgdG8gYWRkIGl0IGFzIGFuIG9wZXJhdGlvbiBub3cuXG4gICAgY29uc3QgbGVmdE1vc3RDaGlsZCA9IGdldExlZnRNb3N0Q2hpbGQocmlnaHQpO1xuICAgIGlmIChsZWZ0TW9zdENoaWxkPy5uYW1lID09PSAnTnVtYmVyTGl0ZXJhbCcpIHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChtYWtlQmluT3Aob3BEZWYsIGV4cHIsIGxlZnRNb3N0Q2hpbGQsICEhYmluTW9kaWZpZXI/LmlzQm9vbCkpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFkZGVkIHRoZSBmaXJzdCBudW1iZXIgbGl0ZXJhbCBhcyBvcGVyYXRpb24gaGVyZSB3ZSBzdGlsbCBjYW4gY29udGludWUgYW5kIGhhbmRsZSB0aGUgcmVzdCBhcyB0aGUgZmlyc3RcbiAgICAvLyBudW1iZXIgd2lsbCBiZSBqdXN0IHNraXBwZWQuXG4gICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCByaWdodCwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmlzUXVlcnkuYmluYXJ5UXVlcmllcyA9IHZpc1F1ZXJ5LmJpbmFyeVF1ZXJpZXMgfHwgW107XG4gICAgY29uc3QgYmluUXVlcnk6IFByb21WaXN1YWxRdWVyeUJpbmFyeSA9IHtcbiAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIG1ldHJpYzogJycsXG4gICAgICAgIGxhYmVsczogW10sXG4gICAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChiaW5Nb2RpZmllcj8uaXNNYXRjaGVyKSB7XG4gICAgICBiaW5RdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSA9IGJpbk1vZGlmaWVyLm1hdGNoVHlwZTtcbiAgICAgIGJpblF1ZXJ5LnZlY3Rvck1hdGNoZXMgPSBiaW5Nb2RpZmllci5tYXRjaGVzO1xuICAgIH1cbiAgICB2aXNRdWVyeS5iaW5hcnlRdWVyaWVzLnB1c2goYmluUXVlcnkpO1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgcmlnaHQsIHtcbiAgICAgIHF1ZXJ5OiBiaW5RdWVyeS5xdWVyeSxcbiAgICAgIGVycm9yczogY29udGV4dC5lcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5TW9kaWZpZXIoXG4gIGV4cHI6IHN0cmluZyxcbiAgbm9kZTogU3ludGF4Tm9kZSB8IG51bGxcbik6XG4gIHwgeyBpc0Jvb2w6IHRydWU7IGlzTWF0Y2hlcjogZmFsc2UgfVxuICB8IHsgaXNCb29sOiBmYWxzZTsgaXNNYXRjaGVyOiB0cnVlOyBtYXRjaGVzOiBzdHJpbmc7IG1hdGNoVHlwZTogJ2lnbm9yaW5nJyB8ICdvbicgfVxuICB8IHVuZGVmaW5lZCB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG5vZGUuZ2V0Q2hpbGQoJ0Jvb2wnKSkge1xuICAgIHJldHVybiB7IGlzQm9vbDogdHJ1ZSwgaXNNYXRjaGVyOiBmYWxzZSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1hdGNoZXIgPSBub2RlLmdldENoaWxkKCdPbk9ySWdub3JpbmcnKTtcbiAgICBpZiAoIW1hdGNoZXIpIHtcbiAgICAgIC8vIE5vdCBzdXJlIHdoYXQgdGhpcyBjb3VsZCBiZSwgbWF5YmUgc2hvdWxkIGJlIGFuIGVycm9yLlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gZ2V0U3RyaW5nKGV4cHIsIG1hdGNoZXIuZ2V0Q2hpbGQoJ0dyb3VwaW5nTGFiZWxzJyk/LmdldENoaWxkKCdHcm91cGluZ0xhYmVsTGlzdCcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaGVyOiB0cnVlLFxuICAgICAgaXNCb29sOiBmYWxzZSxcbiAgICAgIG1hdGNoZXM6IGxhYmVscyxcbiAgICAgIG1hdGNoVHlwZTogbWF0Y2hlci5nZXRDaGlsZCgnT24nKSA/ICdvbicgOiAnaWdub3JpbmcnLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFbXB0eVF1ZXJ5KHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkpIHtcbiAgaWYgKHF1ZXJ5LmxhYmVscy5sZW5ndGggPT09IDAgJiYgcXVlcnkub3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgIXF1ZXJ5Lm1ldHJpYykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBjb25maWcsIHJlcG9ydEludGVyYWN0aW9uIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBJY29uLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgZmVlZGJhY2tVcmw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGZWVkYmFja0xpbmsoeyBmZWVkYmFja1VybCB9OiBQcm9wcykge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgaWYgKCFjb25maWcuZmVlZGJhY2tMaW5rc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFN0YWNrIGdhcD17MX0+XG4gICAgICA8YVxuICAgICAgICBocmVmPXtmZWVkYmFja1VybH1cbiAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubGlua31cbiAgICAgICAgdGl0bGU9XCJUaGlzIHF1ZXJ5IGJ1aWxkZXIgaXMgbmV3LCBwbGVhc2UgbGV0IHVzIGtub3cgaG93IHdlIGNhbiBpbXByb3ZlIGl0XCJcbiAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgcmVsPVwibm9yZWZlcnJlciBub29wZW5lclwiXG4gICAgICAgIG9uQ2xpY2s9eygpID0+XG4gICAgICAgICAgcmVwb3J0SW50ZXJhY3Rpb24oJ2dyYWZhbmFfZmVlZGJhY2tfbGlua19jbGlja2VkJywge1xuICAgICAgICAgICAgbGluazogZmVlZGJhY2tVcmwsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgPlxuICAgICAgICA8SWNvbiBuYW1lPVwiY29tbWVudC1hbHQtbWVzc2FnZVwiIC8+IEdpdmUgZmVlZGJhY2tcbiAgICAgIDwvYT5cbiAgICA8L1N0YWNrPlxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRTdHlsZXModGhlbWU6IEdyYWZhbmFUaGVtZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBsaW5rOiBjc3Moe1xuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgICc6aG92ZXInOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5saW5rLFxuICAgICAgfSxcbiAgICB9KSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IHVuaXFCeSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSwgdG9PcHRpb24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEFjY2Vzc29yeUJ1dHRvbiwgSW5wdXRHcm91cCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBkZWZhdWx0T3A6IHN0cmluZztcbiAgaXRlbTogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj47XG4gIG9uQ2hhbmdlOiAodmFsdWU6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyKSA9PiB2b2lkO1xuICBvbkdldExhYmVsTmFtZXM6IChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+O1xuICBvbkdldExhYmVsVmFsdWVzOiAoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PiBQcm9taXNlPFNlbGVjdGFibGVWYWx1ZVtdPjtcbiAgb25EZWxldGU6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBMYWJlbEZpbHRlckl0ZW0oeyBpdGVtLCBkZWZhdWx0T3AsIG9uQ2hhbmdlLCBvbkRlbGV0ZSwgb25HZXRMYWJlbE5hbWVzLCBvbkdldExhYmVsVmFsdWVzIH06IFByb3BzKSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8e1xuICAgIGxhYmVsTmFtZXM/OiBTZWxlY3RhYmxlVmFsdWVbXTtcbiAgICBsYWJlbFZhbHVlcz86IFNlbGVjdGFibGVWYWx1ZVtdO1xuICAgIGlzTG9hZGluZ0xhYmVsTmFtZXM/OiBib29sZWFuO1xuICAgIGlzTG9hZGluZ0xhYmVsVmFsdWVzPzogYm9vbGVhbjtcbiAgfT4oe30pO1xuXG4gIGNvbnN0IGlzTXVsdGlTZWxlY3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGl0ZW0ub3AgPT09IG9wZXJhdG9yc1swXS5sYWJlbDtcbiAgfTtcblxuICBjb25zdCBnZXRTZWxlY3RPcHRpb25zRnJvbVN0cmluZyA9IChpdGVtPzogc3RyaW5nKTogc3RyaW5nW10gPT4ge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbS5pbmRleE9mKCd8JykgPiAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnNwbGl0KCd8Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2l0ZW1dO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgY29uc3QgZ2V0T3B0aW9ucyA9ICgpOiBTZWxlY3RhYmxlVmFsdWVbXSA9PiB7XG4gICAgY29uc3QgbGFiZWxWYWx1ZXMgPSBzdGF0ZS5sYWJlbFZhbHVlcyA/IFsuLi5zdGF0ZS5sYWJlbFZhbHVlc10gOiBbXTtcbiAgICBjb25zdCBzZWxlY3RlZE9wdGlvbnMgPSBnZXRTZWxlY3RPcHRpb25zRnJvbVN0cmluZyhpdGVtPy52YWx1ZSkubWFwKHRvT3B0aW9uKTtcblxuICAgIC8vIFJlbW92ZSBwb3NzaWJsZSBkdXBsaWNhdGVkIHZhbHVlc1xuICAgIHJldHVybiB1bmlxQnkoWy4uLnNlbGVjdGVkT3B0aW9ucywgLi4ubGFiZWxWYWx1ZXNdLCAndmFsdWUnKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJwcm9tZXRoZXVzLWRpbWVuc2lvbnMtZmlsdGVyLWl0ZW1cIj5cbiAgICAgIDxJbnB1dEdyb3VwPlxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgaW5wdXRJZD1cInByb21ldGhldXMtZGltZW5zaW9ucy1maWx0ZXItaXRlbS1rZXlcIlxuICAgICAgICAgIHdpZHRoPVwiYXV0b1wiXG4gICAgICAgICAgdmFsdWU9e2l0ZW0ubGFiZWwgPyB0b09wdGlvbihpdGVtLmxhYmVsKSA6IG51bGx9XG4gICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgIG9uT3Blbk1lbnU9e2FzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgaXNMb2FkaW5nTGFiZWxOYW1lczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsTmFtZXMgPSBhd2FpdCBvbkdldExhYmVsTmFtZXMoaXRlbSk7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGxhYmVsTmFtZXMsIGlzTG9hZGluZ0xhYmVsTmFtZXM6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGlzTG9hZGluZz17c3RhdGUuaXNMb2FkaW5nTGFiZWxOYW1lc31cbiAgICAgICAgICBvcHRpb25zPXtzdGF0ZS5sYWJlbE5hbWVzfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLmxhYmVsKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgIG9wOiBpdGVtLm9wID8/IGRlZmF1bHRPcCxcbiAgICAgICAgICAgICAgICBsYWJlbDogY2hhbmdlLmxhYmVsLFxuICAgICAgICAgICAgICB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cblxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgdmFsdWU9e3RvT3B0aW9uKGl0ZW0ub3AgPz8gZGVmYXVsdE9wKX1cbiAgICAgICAgICBvcHRpb25zPXtvcGVyYXRvcnN9XG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICBvbkNoYW5nZT17KGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHsgLi4uaXRlbSwgb3A6IGNoYW5nZS52YWx1ZSB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cblxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgaW5wdXRJZD1cInByb21ldGhldXMtZGltZW5zaW9ucy1maWx0ZXItaXRlbS12YWx1ZVwiXG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICB2YWx1ZT17XG4gICAgICAgICAgICBpc011bHRpU2VsZWN0KClcbiAgICAgICAgICAgICAgPyBnZXRTZWxlY3RPcHRpb25zRnJvbVN0cmluZyhpdGVtPy52YWx1ZSkubWFwKHRvT3B0aW9uKVxuICAgICAgICAgICAgICA6IGdldFNlbGVjdE9wdGlvbnNGcm9tU3RyaW5nKGl0ZW0/LnZhbHVlKS5tYXAodG9PcHRpb24pWzBdXG4gICAgICAgICAgfVxuICAgICAgICAgIGFsbG93Q3VzdG9tVmFsdWVcbiAgICAgICAgICBvbk9wZW5NZW51PXthc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGlzTG9hZGluZ0xhYmVsVmFsdWVzOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxWYWx1ZXMgPSBhd2FpdCBvbkdldExhYmVsVmFsdWVzKGl0ZW0pO1xuICAgICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgbGFiZWxWYWx1ZXMsXG4gICAgICAgICAgICAgIGlzTG9hZGluZ0xhYmVsVmFsdWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGlzTXVsdGk9e2lzTXVsdGlTZWxlY3QoKX1cbiAgICAgICAgICBpc0xvYWRpbmc9e3N0YXRlLmlzTG9hZGluZ0xhYmVsVmFsdWVzfVxuICAgICAgICAgIG9wdGlvbnM9e2dldE9wdGlvbnMoKX1cbiAgICAgICAgICBvbkNoYW5nZT17KGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS52YWx1ZSkge1xuICAgICAgICAgICAgICBvbkNoYW5nZSh7IC4uLml0ZW0sIHZhbHVlOiBjaGFuZ2UudmFsdWUsIG9wOiBpdGVtLm9wID8/IGRlZmF1bHRPcCB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gY2hhbmdlXG4gICAgICAgICAgICAgICAgLm1hcCgoY2hhbmdlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2UubGFiZWw7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignfCcpO1xuICAgICAgICAgICAgICBvbkNoYW5nZSh7IC4uLml0ZW0sIHZhbHVlOiBjaGFuZ2VzLCBvcDogaXRlbS5vcCA/PyBkZWZhdWx0T3AgfSBhcyBhbnkgYXMgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICAgIDxBY2Nlc3NvcnlCdXR0b24gYXJpYS1sYWJlbD1cInJlbW92ZVwiIGljb249XCJ0aW1lc1wiIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiBvbkNsaWNrPXtvbkRlbGV0ZX0gLz5cbiAgICAgIDwvSW5wdXRHcm91cD5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuY29uc3Qgb3BlcmF0b3JzID0gW1xuICB7IGxhYmVsOiAnPX4nLCB2YWx1ZTogJz1+JyB9LFxuICB7IGxhYmVsOiAnPScsIHZhbHVlOiAnPScgfSxcbiAgeyBsYWJlbDogJyE9JywgdmFsdWU6ICchPScgfSxcbiAgeyBsYWJlbDogJyF+JywgdmFsdWU6ICchficgfSxcbl07XG4iLCJpbXBvcnQgeyBpc0VxdWFsIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEVkaXRvckZpZWxkR3JvdXAsIEVkaXRvckxpc3QsIEVkaXRvckZpZWxkIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcblxuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBMYWJlbEZpbHRlckl0ZW0gfSBmcm9tICcuL0xhYmVsRmlsdGVySXRlbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBsYWJlbHNGaWx0ZXJzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdO1xuICBvbkNoYW5nZTogKGxhYmVsRmlsdGVyczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSkgPT4gdm9pZDtcbiAgb25HZXRMYWJlbE5hbWVzOiAoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PiBQcm9taXNlPFNlbGVjdGFibGVWYWx1ZVtdPjtcbiAgb25HZXRMYWJlbFZhbHVlczogKGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPikgPT4gUHJvbWlzZTxTZWxlY3RhYmxlVmFsdWVbXT47XG4gIGVycm9yPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTGFiZWxGaWx0ZXJzKHsgbGFiZWxzRmlsdGVycywgb25DaGFuZ2UsIG9uR2V0TGFiZWxOYW1lcywgb25HZXRMYWJlbFZhbHVlcywgZXJyb3IgfTogUHJvcHMpIHtcbiAgY29uc3QgZGVmYXVsdE9wID0gJz0nO1xuICBjb25zdCBbaXRlbXMsIHNldEl0ZW1zXSA9IHVzZVN0YXRlPEFycmF5PFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+Pj4oW3sgb3A6IGRlZmF1bHRPcCB9XSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobGFiZWxzRmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBzZXRJdGVtcyhsYWJlbHNGaWx0ZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SXRlbXMoW3sgb3A6IGRlZmF1bHRPcCB9XSk7XG4gICAgfVxuICB9LCBbbGFiZWxzRmlsdGVyc10pO1xuXG4gIGNvbnN0IG9uTGFiZWxzQ2hhbmdlID0gKG5ld0l0ZW1zOiBBcnJheTxQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPj4pID0+IHtcbiAgICBzZXRJdGVtcyhuZXdJdGVtcyk7XG5cbiAgICAvLyBFeHRyYWN0IGZ1bGwgbGFiZWwgZmlsdGVycyB3aXRoIGJvdGggbGFiZWwgJiB2YWx1ZVxuICAgIGNvbnN0IG5ld0xhYmVscyA9IG5ld0l0ZW1zLmZpbHRlcigoeCkgPT4geC5sYWJlbCAhPSBudWxsICYmIHgudmFsdWUgIT0gbnVsbCk7XG4gICAgaWYgKCFpc0VxdWFsKG5ld0xhYmVscywgbGFiZWxzRmlsdGVycykpIHtcbiAgICAgIG9uQ2hhbmdlKG5ld0xhYmVscyBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8RWRpdG9yRmllbGRHcm91cD5cbiAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIkxhYmVsc1wiIGVycm9yPXtlcnJvcn0gaW52YWxpZD17ISFlcnJvcn0+XG4gICAgICAgIDxFZGl0b3JMaXN0XG4gICAgICAgICAgaXRlbXM9e2l0ZW1zfVxuICAgICAgICAgIG9uQ2hhbmdlPXtvbkxhYmVsc0NoYW5nZX1cbiAgICAgICAgICByZW5kZXJJdGVtPXsoaXRlbSwgb25DaGFuZ2VJdGVtLCBvbkRlbGV0ZSkgPT4gKFxuICAgICAgICAgICAgPExhYmVsRmlsdGVySXRlbVxuICAgICAgICAgICAgICBpdGVtPXtpdGVtfVxuICAgICAgICAgICAgICBkZWZhdWx0T3A9e2RlZmF1bHRPcH1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlSXRlbX1cbiAgICAgICAgICAgICAgb25EZWxldGU9e29uRGVsZXRlfVxuICAgICAgICAgICAgICBvbkdldExhYmVsTmFtZXM9e29uR2V0TGFiZWxOYW1lc31cbiAgICAgICAgICAgICAgb25HZXRMYWJlbFZhbHVlcz17b25HZXRMYWJlbFZhbHVlc31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgLz5cbiAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgPC9FZGl0b3JGaWVsZEdyb3VwPlxuICApO1xufVxuIiwiaW1wb3J0IHsgUmVnaXN0cnkgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgVmlzdWFsUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZpc3VhbFF1ZXJ5QmluYXJ5PFQ+IHtcbiAgb3BlcmF0b3I6IHN0cmluZztcbiAgdmVjdG9yTWF0Y2hlc1R5cGU/OiAnb24nIHwgJ2lnbm9yaW5nJztcbiAgdmVjdG9yTWF0Y2hlcz86IHN0cmluZztcbiAgcXVlcnk6IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbUxva2lWaXN1YWxRdWVyeSB7XG4gIG1ldHJpYz86IHN0cmluZztcbiAgbGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdO1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbiAgYmluYXJ5UXVlcmllcz86IEFycmF5PFZpc3VhbFF1ZXJ5QmluYXJ5PFByb21Mb2tpVmlzdWFsUXVlcnk+Pjtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UgaW1wbGVtZW50cyBWaXN1YWxRdWVyeU1vZGVsbGVyIHtcbiAgcHJvdGVjdGVkIG9wZXJhdGlvbnNSZWdpc3R5OiBSZWdpc3RyeTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+O1xuICBwcml2YXRlIGNhdGVnb3JpZXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZ2V0T3BlcmF0aW9uczogKCkgPT4gUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10pIHtcbiAgICB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5ID0gbmV3IFJlZ2lzdHJ5PFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj4oZ2V0T3BlcmF0aW9ucyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0T3BlcmF0aW9uQ2F0ZWdvcmllcyhjYXRlZ29yaWVzOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XG4gIH1cblxuICBnZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkoY2F0ZWdvcnk6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5Lmxpc3QoKS5maWx0ZXIoKG9wKSA9PiBvcC5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkgJiYgIW9wLmhpZGVGcm9tTGlzdCk7XG4gIH1cblxuICBnZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMoa2V5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zUmVnaXN0eS5saXN0KCkuZmlsdGVyKChvcCkgPT4gb3AuYWx0ZXJuYXRpdmVzS2V5ID09PSBrZXkpO1xuICB9XG5cbiAgZ2V0Q2F0ZWdvcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5jYXRlZ29yaWVzO1xuICB9XG5cbiAgZ2V0T3BlcmF0aW9uRGVmKGlkOiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5LmdldElmRXhpc3RzKGlkKTtcbiAgfVxuXG4gIHJlbmRlck9wZXJhdGlvbnMocXVlcnlTdHJpbmc6IHN0cmluZywgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW10pIHtcbiAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBvcGVyYXRpb25zKSB7XG4gICAgICBjb25zdCBkZWYgPSB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5LmdldElmRXhpc3RzKG9wZXJhdGlvbi5pZCk7XG4gICAgICBpZiAoIWRlZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIG9wZXJhdGlvbiAke29wZXJhdGlvbi5pZH0gaW4gdGhlIHJlZ2lzdHJ5YCk7XG4gICAgICB9XG4gICAgICBxdWVyeVN0cmluZyA9IGRlZi5yZW5kZXJlcihvcGVyYXRpb24sIGRlZiwgcXVlcnlTdHJpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeVN0cmluZztcbiAgfVxuXG4gIHJlbmRlckJpbmFyeVF1ZXJpZXMocXVlcnlTdHJpbmc6IHN0cmluZywgYmluYXJ5UXVlcmllcz86IEFycmF5PFZpc3VhbFF1ZXJ5QmluYXJ5PFByb21Mb2tpVmlzdWFsUXVlcnk+Pikge1xuICAgIGlmIChiaW5hcnlRdWVyaWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGJpblF1ZXJ5IG9mIGJpbmFyeVF1ZXJpZXMpIHtcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBgJHt0aGlzLnJlbmRlckJpbmFyeVF1ZXJ5KHF1ZXJ5U3RyaW5nLCBiaW5RdWVyeSl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5U3RyaW5nO1xuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJCaW5hcnlRdWVyeShsZWZ0T3BlcmFuZDogc3RyaW5nLCBiaW5hcnlRdWVyeTogVmlzdWFsUXVlcnlCaW5hcnk8UHJvbUxva2lWaXN1YWxRdWVyeT4pIHtcbiAgICBsZXQgcmVzdWx0ID0gbGVmdE9wZXJhbmQgKyBgICR7YmluYXJ5UXVlcnkub3BlcmF0b3J9IGA7XG5cbiAgICBpZiAoYmluYXJ5UXVlcnkudmVjdG9yTWF0Y2hlcykge1xuICAgICAgcmVzdWx0ICs9IGAke2JpbmFyeVF1ZXJ5LnZlY3Rvck1hdGNoZXNUeXBlfSgke2JpbmFyeVF1ZXJ5LnZlY3Rvck1hdGNoZXN9KSBgO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgKyB0aGlzLnJlbmRlclF1ZXJ5KGJpbmFyeVF1ZXJ5LnF1ZXJ5LCB0cnVlKTtcbiAgfVxuXG4gIHJlbmRlckxhYmVscyhsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10pIHtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGxldCBleHByID0gJ3snO1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGxhYmVscykge1xuICAgICAgaWYgKGV4cHIgIT09ICd7Jykge1xuICAgICAgICBleHByICs9ICcsICc7XG4gICAgICB9XG5cbiAgICAgIGV4cHIgKz0gYCR7ZmlsdGVyLmxhYmVsfSR7ZmlsdGVyLm9wfVwiJHtmaWx0ZXIudmFsdWV9XCJgO1xuICAgIH1cblxuICAgIHJldHVybiBleHByICsgYH1gO1xuICB9XG5cbiAgcmVuZGVyUXVlcnkocXVlcnk6IFByb21Mb2tpVmlzdWFsUXVlcnksIG5lc3RlZD86IGJvb2xlYW4pIHtcbiAgICBsZXQgcXVlcnlTdHJpbmcgPSBgJHtxdWVyeS5tZXRyaWMgPz8gJyd9JHt0aGlzLnJlbmRlckxhYmVscyhxdWVyeS5sYWJlbHMpfWA7XG4gICAgcXVlcnlTdHJpbmcgPSB0aGlzLnJlbmRlck9wZXJhdGlvbnMocXVlcnlTdHJpbmcsIHF1ZXJ5Lm9wZXJhdGlvbnMpO1xuXG4gICAgaWYgKCFuZXN0ZWQgJiYgdGhpcy5oYXNCaW5hcnlPcChxdWVyeSkgJiYgQm9vbGVhbihxdWVyeS5iaW5hcnlRdWVyaWVzPy5sZW5ndGgpKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IGAoJHtxdWVyeVN0cmluZ30pYDtcbiAgICB9XG5cbiAgICBxdWVyeVN0cmluZyA9IHRoaXMucmVuZGVyQmluYXJ5UXVlcmllcyhxdWVyeVN0cmluZywgcXVlcnkuYmluYXJ5UXVlcmllcyk7XG5cbiAgICBpZiAobmVzdGVkICYmICh0aGlzLmhhc0JpbmFyeU9wKHF1ZXJ5KSB8fCBCb29sZWFuKHF1ZXJ5LmJpbmFyeVF1ZXJpZXM/Lmxlbmd0aCkpKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IGAoJHtxdWVyeVN0cmluZ30pYDtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnlTdHJpbmc7XG4gIH1cblxuICBoYXNCaW5hcnlPcChxdWVyeTogUHJvbUxva2lWaXN1YWxRdWVyeSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICBxdWVyeS5vcGVyYXRpb25zLmZpbmQoKG9wKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuZ2V0T3BlcmF0aW9uRGVmKG9wLmlkKTtcbiAgICAgICAgcmV0dXJuIGRlZj8uY2F0ZWdvcnkgPT09IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcztcbiAgICAgIH0pICE9PSB1bmRlZmluZWRcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlIH0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XG5cbmltcG9ydCB7IERhdGFTb3VyY2VBcGksIEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEJ1dHRvbiwgSWNvbiwgVG9vbHRpcCwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHtcbiAgVmlzdWFsUXVlcnlNb2RlbGxlcixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLFxufSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBPcGVyYXRpb25IZWFkZXIgfSBmcm9tICcuL09wZXJhdGlvbkhlYWRlcic7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25QYXJhbUVkaXRvciB9IGZyb20gJy4vT3BlcmF0aW9uUGFyYW1FZGl0b3InO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uUGFyYW1JZCB9IGZyb20gJy4vb3BlcmF0aW9uVXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247XG4gIGluZGV4OiBudW1iZXI7XG4gIHF1ZXJ5OiBhbnk7XG4gIGRhdGFzb3VyY2U6IERhdGFTb3VyY2VBcGk7XG4gIHF1ZXJ5TW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXI7XG4gIG9uQ2hhbmdlOiAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pID0+IHZvaWQ7XG4gIG9uUmVtb3ZlOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbiAgaGlnaGxpZ2h0PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbkVkaXRvcih7XG4gIG9wZXJhdGlvbixcbiAgaW5kZXgsXG4gIG9uUmVtb3ZlLFxuICBvbkNoYW5nZSxcbiAgb25SdW5RdWVyeSxcbiAgcXVlcnlNb2RlbGxlcixcbiAgcXVlcnksXG4gIGRhdGFzb3VyY2UsXG4gIGhpZ2hsaWdodCxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgY29uc3QgZGVmID0gcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25EZWYob3BlcmF0aW9uLmlkKTtcbiAgY29uc3Qgc2hvdWxkSGlnaGxpZ2h0ID0gdXNlSGlnaGxpZ2h0KGhpZ2hsaWdodCk7XG5cbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm4gPHNwYW4+T3BlcmF0aW9uIHtvcGVyYXRpb24uaWR9IG5vdCBmb3VuZDwvc3Bhbj47XG4gIH1cblxuICBjb25zdCBvblBhcmFtVmFsdWVDaGFuZ2VkID0gKHBhcmFtSWR4OiBudW1iZXIsIHZhbHVlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7IC4uLm9wZXJhdGlvbiwgcGFyYW1zOiBbLi4ub3BlcmF0aW9uLnBhcmFtc10gfTtcbiAgICB1cGRhdGUucGFyYW1zW3BhcmFtSWR4XSA9IHZhbHVlO1xuICAgIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoZGVmLCB1cGRhdGUsIGluZGV4LCBwYXJhbUlkeCwgb25DaGFuZ2UpO1xuICB9O1xuXG4gIGNvbnN0IG9uQWRkUmVzdFBhcmFtID0gKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyAuLi5vcGVyYXRpb24sIHBhcmFtczogWy4uLm9wZXJhdGlvbi5wYXJhbXMsICcnXSB9O1xuICAgIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoZGVmLCB1cGRhdGUsIGluZGV4LCBvcGVyYXRpb24ucGFyYW1zLmxlbmd0aCwgb25DaGFuZ2UpO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVtb3ZlUmVzdFBhcmFtID0gKHBhcmFtSWR4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiA9IHtcbiAgICAgIC4uLm9wZXJhdGlvbixcbiAgICAgIHBhcmFtczogWy4uLm9wZXJhdGlvbi5wYXJhbXMuc2xpY2UoMCwgcGFyYW1JZHgpLCAuLi5vcGVyYXRpb24ucGFyYW1zLnNsaWNlKHBhcmFtSWR4ICsgMSldLFxuICAgIH07XG4gICAgY2FsbFBhcmFtQ2hhbmdlZFRoZW5PbkNoYW5nZShkZWYsIHVwZGF0ZSwgaW5kZXgsIHBhcmFtSWR4LCBvbkNoYW5nZSk7XG4gIH07XG5cbiAgY29uc3Qgb3BlcmF0aW9uRWxlbWVudHM6IFJlYWN0LlJlYWN0Tm9kZVtdID0gW107XG5cbiAgZm9yIChsZXQgcGFyYW1JbmRleCA9IDA7IHBhcmFtSW5kZXggPCBvcGVyYXRpb24ucGFyYW1zLmxlbmd0aDsgcGFyYW1JbmRleCsrKSB7XG4gICAgY29uc3QgcGFyYW1EZWYgPSBkZWYucGFyYW1zW01hdGgubWluKGRlZi5wYXJhbXMubGVuZ3RoIC0gMSwgcGFyYW1JbmRleCldO1xuICAgIGNvbnN0IEVkaXRvciA9IGdldE9wZXJhdGlvblBhcmFtRWRpdG9yKHBhcmFtRGVmKTtcblxuICAgIG9wZXJhdGlvbkVsZW1lbnRzLnB1c2goXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBhcmFtUm93fSBrZXk9e2Ake3BhcmFtSW5kZXh9LTFgfT5cbiAgICAgICAgeyFwYXJhbURlZi5oaWRlTmFtZSAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5wYXJhbU5hbWV9PlxuICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e2dldE9wZXJhdGlvblBhcmFtSWQoaW5kZXgsIHBhcmFtSW5kZXgpfT57cGFyYW1EZWYubmFtZX08L2xhYmVsPlxuICAgICAgICAgICAge3BhcmFtRGVmLmRlc2NyaXB0aW9uICYmIChcbiAgICAgICAgICAgICAgPFRvb2x0aXAgcGxhY2VtZW50PVwidG9wXCIgY29udGVudD17cGFyYW1EZWYuZGVzY3JpcHRpb259IHRoZW1lPVwiaW5mb1wiPlxuICAgICAgICAgICAgICAgIDxJY29uIG5hbWU9XCJpbmZvLWNpcmNsZVwiIHNpemU9XCJzbVwiIGNsYXNzTmFtZT17c3R5bGVzLmluZm9JY29ufSAvPlxuICAgICAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBhcmFtVmFsdWV9PlxuICAgICAgICAgIDxTdGFjayBnYXA9ezAuNX0gZGlyZWN0aW9uPVwicm93XCIgYWxpZ25JdGVtcz1cImNlbnRlclwiIHdyYXA9e2ZhbHNlfT5cbiAgICAgICAgICAgIDxFZGl0b3JcbiAgICAgICAgICAgICAgaW5kZXg9e3BhcmFtSW5kZXh9XG4gICAgICAgICAgICAgIHBhcmFtRGVmPXtwYXJhbURlZn1cbiAgICAgICAgICAgICAgdmFsdWU9e29wZXJhdGlvbi5wYXJhbXNbcGFyYW1JbmRleF19XG4gICAgICAgICAgICAgIG9wZXJhdGlvbj17b3BlcmF0aW9ufVxuICAgICAgICAgICAgICBvcGVyYXRpb25JbmRleD17aW5kZXh9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvblBhcmFtVmFsdWVDaGFuZ2VkfVxuICAgICAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge3BhcmFtRGVmLnJlc3RQYXJhbSAmJiAob3BlcmF0aW9uLnBhcmFtcy5sZW5ndGggPiBkZWYucGFyYW1zLmxlbmd0aCB8fCBwYXJhbURlZi5vcHRpb25hbCkgJiYgKFxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9e2BvcGVyYXRpb25zLiR7aW5kZXh9LnJlbW92ZS1yZXN0LXBhcmFtYH1cbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIGZpbGw9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBpY29uPVwidGltZXNcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIHRpdGxlPXtgUmVtb3ZlICR7cGFyYW1EZWYubmFtZX1gfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUmVtb3ZlUmVzdFBhcmFtKHBhcmFtSW5kZXgpfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L1N0YWNrPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICAvLyBIYW5kbGUgYWRkaW5nIGJ1dHRvbiBmb3IgcmVzdCBwYXJhbXNcbiAgbGV0IHJlc3RQYXJhbTogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkO1xuICBpZiAoZGVmLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbGFzdFBhcmFtRGVmID0gZGVmLnBhcmFtc1tkZWYucGFyYW1zLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0UGFyYW1EZWYucmVzdFBhcmFtKSB7XG4gICAgICByZXN0UGFyYW0gPSByZW5kZXJBZGRSZXN0UGFyYW1CdXR0b24obGFzdFBhcmFtRGVmLCBvbkFkZFJlc3RQYXJhbSwgaW5kZXgsIG9wZXJhdGlvbi5wYXJhbXMubGVuZ3RoLCBzdHlsZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPERyYWdnYWJsZSBkcmFnZ2FibGVJZD17YG9wZXJhdGlvbi0ke2luZGV4fWB9IGluZGV4PXtpbmRleH0+XG4gICAgICB7KHByb3ZpZGVkKSA9PiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9e2N4KHN0eWxlcy5jYXJkLCBzaG91bGRIaWdobGlnaHQgJiYgc3R5bGVzLmNhcmRIaWdobGlnaHQpfVxuICAgICAgICAgIHJlZj17cHJvdmlkZWQuaW5uZXJSZWZ9XG4gICAgICAgICAgey4uLnByb3ZpZGVkLmRyYWdnYWJsZVByb3BzfVxuICAgICAgICAgIGRhdGEtdGVzdGlkPXtgb3BlcmF0aW9ucy4ke2luZGV4fS53cmFwcGVyYH1cbiAgICAgICAgPlxuICAgICAgICAgIDxPcGVyYXRpb25IZWFkZXJcbiAgICAgICAgICAgIG9wZXJhdGlvbj17b3BlcmF0aW9ufVxuICAgICAgICAgICAgZHJhZ0hhbmRsZVByb3BzPXtwcm92aWRlZC5kcmFnSGFuZGxlUHJvcHN9XG4gICAgICAgICAgICBkZWY9e2RlZn1cbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgIG9uUmVtb3ZlPXtvblJlbW92ZX1cbiAgICAgICAgICAgIHF1ZXJ5TW9kZWxsZXI9e3F1ZXJ5TW9kZWxsZXJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PntvcGVyYXRpb25FbGVtZW50c308L2Rpdj5cbiAgICAgICAgICB7cmVzdFBhcmFtfVxuICAgICAgICAgIHtpbmRleCA8IHF1ZXJ5Lm9wZXJhdGlvbnMubGVuZ3RoIC0gMSAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmFycm93fT5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5hcnJvd0xpbmV9IC8+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYXJyb3dBcnJvd30gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L0RyYWdnYWJsZT5cbiAgKTtcbn1cblxuLyoqXG4gKiBXaGVuIGhpZ2hsaWdodCBpcyBzd2l0Y2hlZCBvbiBtYWtlcyBzdXJlIGl0IGlzIHN3aXRjaGVkIG9mIHJpZ2h0IGF3YXksIHNvIHdlIGp1c3QgZmxhc2ggdGhlIGhpZ2hsaWdodCBhbmQgdGhlbiBmYWRlXG4gKiBvdXQuXG4gKiBAcGFyYW0gaGlnaGxpZ2h0XG4gKi9cbmZ1bmN0aW9uIHVzZUhpZ2hsaWdodChoaWdobGlnaHQ/OiBib29sZWFuKSB7XG4gIGNvbnN0IFtrZWVwSGlnaGxpZ2h0LCBzZXRLZWVwSGlnaGxpZ2h0XSA9IHVzZVN0YXRlKHRydWUpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB0OiBhbnk7XG4gICAgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRLZWVwSGlnaGxpZ2h0KGZhbHNlKTtcbiAgICAgIH0sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRLZWVwSGlnaGxpZ2h0KHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodCk7XG4gIH0sIFtoaWdobGlnaHRdKTtcblxuICByZXR1cm4ga2VlcEhpZ2hsaWdodCAmJiBoaWdobGlnaHQ7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFkZFJlc3RQYXJhbUJ1dHRvbihcbiAgcGFyYW1EZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLFxuICBvbkFkZFJlc3RQYXJhbTogKCkgPT4gdm9pZCxcbiAgb3BlcmF0aW9uSW5kZXg6IG51bWJlcixcbiAgcGFyYW1JbmRleDogbnVtYmVyLFxuICBzdHlsZXM6IE9wZXJhdGlvbkVkaXRvclN0eWxlc1xuKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5yZXN0UGFyYW19IGtleT17YCR7cGFyYW1JbmRleH0tMmB9PlxuICAgICAgPEJ1dHRvblxuICAgICAgICBzaXplPVwic21cIlxuICAgICAgICBpY29uPVwicGx1c1wiXG4gICAgICAgIHRpdGxlPXtgQWRkICR7cGFyYW1EZWYubmFtZX1gfVxuICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgb25DbGljaz17b25BZGRSZXN0UGFyYW19XG4gICAgICAgIGRhdGEtdGVzdGlkPXtgb3BlcmF0aW9ucy4ke29wZXJhdGlvbkluZGV4fS5hZGQtcmVzdC1wYXJhbWB9XG4gICAgICA+XG4gICAgICAgIHtwYXJhbURlZi5uYW1lfVxuICAgICAgPC9CdXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgb3BlcmF0aW9uSW5kZXg6IG51bWJlcixcbiAgcGFyYW1JbmRleDogbnVtYmVyLFxuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB2b2lkXG4pIHtcbiAgaWYgKGRlZi5wYXJhbUNoYW5nZWRIYW5kbGVyKSB7XG4gICAgb25DaGFuZ2Uob3BlcmF0aW9uSW5kZXgsIGRlZi5wYXJhbUNoYW5nZWRIYW5kbGVyKHBhcmFtSW5kZXgsIG9wZXJhdGlvbiwgZGVmKSk7XG4gIH0gZWxzZSB7XG4gICAgb25DaGFuZ2Uob3BlcmF0aW9uSW5kZXgsIG9wZXJhdGlvbik7XG4gIH1cbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY2FyZDogY3NzKHtcbiAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnksXG4gICAgICBib3JkZXI6IGAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuYm9yZGVyLm1lZGl1bX1gLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICBjdXJzb3I6ICdncmFiJyxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKDEpLFxuICAgICAgbWFyZ2luQm90dG9tOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDFzIGVhc2UtaW4gMHMnLFxuICAgIH0pLFxuICAgIGNhcmRIaWdobGlnaHQ6IGNzcyh7XG4gICAgICBib3hTaGFkb3c6IGAwcHggMHB4IDRweCAwcHggJHt0aGVtZS5jb2xvcnMucHJpbWFyeS5ib3JkZXJ9YCxcbiAgICAgIGJvcmRlcjogYDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5wcmltYXJ5LmJvcmRlcn1gLFxuICAgIH0pLFxuICAgIGluZm9JY29uOiBjc3Moe1xuICAgICAgbWFyZ2luTGVmdDogdGhlbWUuc3BhY2luZygwLjUpLFxuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgICc6aG92ZXInOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5LFxuICAgICAgfSxcbiAgICB9KSxcbiAgICBib2R5OiBjc3Moe1xuICAgICAgbWFyZ2luOiB0aGVtZS5zcGFjaW5nKDEsIDEsIDAuNSwgMSksXG4gICAgICBkaXNwbGF5OiAndGFibGUnLFxuICAgIH0pLFxuICAgIHBhcmFtUm93OiBjc3Moe1xuICAgICAgbGFiZWw6ICdwYXJhbVJvdycsXG4gICAgICBkaXNwbGF5OiAndGFibGUtcm93JyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgIH0pLFxuICAgIHBhcmFtTmFtZTogY3NzKHtcbiAgICAgIGRpc3BsYXk6ICd0YWJsZS1jZWxsJyxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMCwgMSwgMCwgMCksXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgIGhlaWdodDogJzMycHgnLFxuICAgIH0pLFxuICAgIHBhcmFtVmFsdWU6IGNzcyh7XG4gICAgICBsYWJlbDogJ3BhcmFtVmFsdWUnLFxuICAgICAgZGlzcGxheTogJ3RhYmxlLWNlbGwnLFxuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgfSksXG4gICAgcmVzdFBhcmFtOiBjc3Moe1xuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZygwLCAxLCAxLCAxKSxcbiAgICB9KSxcbiAgICBhcnJvdzogY3NzKHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICByaWdodDogJy0xOHB4JyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICB9KSxcbiAgICBhcnJvd0xpbmU6IGNzcyh7XG4gICAgICBoZWlnaHQ6ICcycHgnLFxuICAgICAgd2lkdGg6ICc4cHgnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5jb2xvcnMuYm9yZGVyLnN0cm9uZyxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgdG9wOiAnMTRweCcsXG4gICAgfSksXG4gICAgYXJyb3dBcnJvdzogY3NzKHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgYm9yZGVyVG9wOiBgNXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgIGJvcmRlckJvdHRvbTogYDVweCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICBib3JkZXJMZWZ0OiBgN3B4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5zdHJvbmd9YCxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgdG9wOiAnMTBweCcsXG4gICAgfSksXG4gIH07XG59O1xuXG50eXBlIE9wZXJhdGlvbkVkaXRvclN0eWxlcyA9IFJldHVyblR5cGU8dHlwZW9mIGdldFN0eWxlcz47XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgcmVuZGVyTWFya2Rvd24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICB0aXRsZT86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIG1hcmtkb3duPzogc3RyaW5nO1xuICBzdGVwTnVtYmVyPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlcmF0aW9uRXhwbGFpbmVkQm94KHsgdGl0bGUsIHN0ZXBOdW1iZXIsIG1hcmtkb3duLCBjaGlsZHJlbiB9OiBQcm9wcykge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJveH0+XG4gICAgICB7c3RlcE51bWJlciAhPT0gdW5kZWZpbmVkICYmIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3RlcE51bWJlcn0+e3N0ZXBOdW1iZXJ9PC9kaXY+fVxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ib3hJbm5lcn0+XG4gICAgICAgIHt0aXRsZSAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5oZWFkZXJ9PlxuICAgICAgICAgICAgPHNwYW4+e3RpdGxlfTwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ib2R5fT5cbiAgICAgICAgICB7bWFya2Rvd24gJiYgPGRpdiBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IHJlbmRlck1hcmtkb3duKG1hcmtkb3duKSB9fT48L2Rpdj59XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBib3g6IGNzcyh7XG4gICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWNvbmRhcnksXG4gICAgICBwYWRkaW5nOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5zaGFwZS5ib3JkZXJSYWRpdXMoKSxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIH0pLFxuICAgIGJveElubmVyOiBjc3Moe1xuICAgICAgbWFyZ2luTGVmdDogdGhlbWUuc3BhY2luZyg0KSxcbiAgICB9KSxcbiAgICBzdGVwTnVtYmVyOiBjc3Moe1xuICAgICAgZm9udFdlaWdodDogdGhlbWUudHlwb2dyYXBoeS5mb250V2VpZ2h0TWVkaXVtLFxuICAgICAgYmFja2dyb3VuZDogdGhlbWUuY29sb3JzLnNlY29uZGFyeS5tYWluLFxuICAgICAgd2lkdGg6ICcyMHB4JyxcbiAgICAgIGhlaWdodDogJzIwcHgnLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3A6ICcxMHB4JyxcbiAgICAgIGxlZnQ6ICcxMXB4JyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICB9KSxcbiAgICBoZWFkZXI6IGNzcyh7XG4gICAgICBwYWRkaW5nQm90dG9tOiB0aGVtZS5zcGFjaW5nKDAuNSksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseU1vbm9zcGFjZSxcbiAgICB9KSxcbiAgICBib2R5OiBjc3Moe1xuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgICdwOmxhc3QtY2hpbGQnOiB7XG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgIH0sXG4gICAgICBhOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5saW5rLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ3VuZGVybGluZScsXG4gICAgICB9LFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIsIFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRmxleEl0ZW0gfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgQnV0dG9uLCBTZWxlY3QsIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IE9wZXJhdGlvbkluZm9CdXR0b24gfSBmcm9tICcuL09wZXJhdGlvbkluZm9CdXR0b24nO1xuaW1wb3J0IHsgVmlzdWFsUXVlcnlNb2RlbGxlciwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgZHJhZ0hhbmRsZVByb3BzOiBhbnk7XG4gIG9uQ2hhbmdlOiAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pID0+IHZvaWQ7XG4gIG9uUmVtb3ZlOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFN0YXRlIHtcbiAgaXNPcGVuPzogYm9vbGVhbjtcbiAgYWx0ZXJuYXRpdmVzPzogQXJyYXk8U2VsZWN0YWJsZVZhbHVlPFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj4+O1xufVxuXG5leHBvcnQgY29uc3QgT3BlcmF0aW9uSGVhZGVyID0gUmVhY3QubWVtbzxQcm9wcz4oXG4gICh7IG9wZXJhdGlvbiwgZGVmLCBpbmRleCwgb25DaGFuZ2UsIG9uUmVtb3ZlLCBxdWVyeU1vZGVsbGVyLCBkcmFnSGFuZGxlUHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPFN0YXRlPih7fSk7XG5cbiAgICBjb25zdCBvblRvZ2dsZVN3aXRjaGVyID0gKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlLmlzT3Blbikge1xuICAgICAgICBzZXRTdGF0ZSh7IC4uLnN0YXRlLCBpc09wZW46IGZhbHNlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWx0ZXJuYXRpdmVzID0gcXVlcnlNb2RlbGxlclxuICAgICAgICAgIC5nZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMoZGVmLmFsdGVybmF0aXZlc0tleSEpXG4gICAgICAgICAgLm1hcCgoYWx0KSA9PiAoeyBsYWJlbDogYWx0Lm5hbWUsIHZhbHVlOiBhbHQgfSkpO1xuICAgICAgICBzZXRTdGF0ZSh7IGlzT3BlbjogdHJ1ZSwgYWx0ZXJuYXRpdmVzIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5oZWFkZXJ9PlxuICAgICAgICB7IXN0YXRlLmlzT3BlbiAmJiAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDxkaXYgey4uLmRyYWdIYW5kbGVQcm9wc30+e2RlZi5uYW1lID8/IGRlZi5pZH08L2Rpdj5cbiAgICAgICAgICAgIDxGbGV4SXRlbSBncm93PXsxfSAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3N0eWxlcy5vcGVyYXRpb25IZWFkZXJCdXR0b25zfSBvcGVyYXRpb24taGVhZGVyLXNob3ctb24taG92ZXJgfT5cbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIGljb249XCJhbmdsZS1kb3duXCJcbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uVG9nZ2xlU3dpdGNoZXJ9XG4gICAgICAgICAgICAgICAgZmlsbD1cInRleHRcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIHRpdGxlPVwiQ2xpY2sgdG8gdmlldyBhbHRlcm5hdGl2ZSBvcGVyYXRpb25zXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPE9wZXJhdGlvbkluZm9CdXR0b24gZGVmPXtkZWZ9IG9wZXJhdGlvbj17b3BlcmF0aW9ufSAvPlxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgaWNvbj1cInRpbWVzXCJcbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUmVtb3ZlKGluZGV4KX1cbiAgICAgICAgICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJSZW1vdmUgb3BlcmF0aW9uXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgICB7c3RhdGUuaXNPcGVuICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNlbGVjdFdyYXBwZXJ9PlxuICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICBhdXRvRm9jdXNcbiAgICAgICAgICAgICAgb3Blbk1lbnVPbkZvY3VzXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiUmVwbGFjZSB3aXRoXCJcbiAgICAgICAgICAgICAgb3B0aW9ucz17c3RhdGUuYWx0ZXJuYXRpdmVzfVxuICAgICAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgICAgIG9uQ2xvc2VNZW51PXtvblRvZ2dsZVN3aXRjaGVyfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBPcGVyYXRpb24gc2hvdWxkIGV4aXN0IGlmIGl0IGlzIHNlbGVjdGFibGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RlZiA9IHF1ZXJ5TW9kZWxsZXIuZ2V0T3BlcmF0aW9uRGVmKHZhbHVlLnZhbHVlLmlkKSE7XG4gICAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZE9wID0geyAuLi5vcGVyYXRpb24sIGlkOiB2YWx1ZS52YWx1ZS5pZCB9O1xuICAgICAgICAgICAgICAgICAgb25DaGFuZ2UoaW5kZXgsIGRlZi5jaGFuZ2VUeXBlSGFuZGxlciA/IGRlZi5jaGFuZ2VUeXBlSGFuZGxlcihjaGFuZ2VkT3AsIG5ld0RlZikgOiBjaGFuZ2VkT3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG4pO1xuXG5PcGVyYXRpb25IZWFkZXIuZGlzcGxheU5hbWUgPSAnT3BlcmF0aW9uSGVhZGVyJztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgaGVhZGVyOiBjc3Moe1xuICAgICAgYm9yZGVyQm90dG9tOiBgMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5tZWRpdW19YCxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMC41LCAwLjUsIDAuNSwgMSksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICcmOmhvdmVyIC5vcGVyYXRpb24taGVhZGVyLXNob3ctb24taG92ZXInOiBjc3Moe1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgfSksXG4gICAgfSksXG4gICAgb3BlcmF0aW9uSGVhZGVyQnV0dG9uczogY3NzKHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoWydvcGFjaXR5J10sIHtcbiAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0LFxuICAgICAgfSksXG4gICAgfSksXG4gICAgc2VsZWN0V3JhcHBlcjogY3NzKHtcbiAgICAgIHBhZGRpbmdSaWdodDogdGhlbWUuc3BhY2luZygyKSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUG9wcGVyVG9vbHRpcCB9IGZyb20gJ3JlYWN0LXBvcHBlci10b29sdGlwJztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgcmVuZGVyTWFya2Rvd24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEZsZXhJdGVtIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEJ1dHRvbiwgUG9ydGFsLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247XG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmO1xufVxuXG5leHBvcnQgY29uc3QgT3BlcmF0aW9uSW5mb0J1dHRvbiA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IGRlZiwgb3BlcmF0aW9uIH0pID0+IHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuICBjb25zdCBbc2hvdywgc2V0U2hvd10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHsgZ2V0VG9vbHRpcFByb3BzLCBzZXRUb29sdGlwUmVmLCBzZXRUcmlnZ2VyUmVmLCB2aXNpYmxlIH0gPSB1c2VQb3BwZXJUb29sdGlwKHtcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHZpc2libGU6IHNob3csXG4gICAgb2Zmc2V0OiBbMCwgMTZdLFxuICAgIG9uVmlzaWJsZUNoYW5nZTogc2V0U2hvdyxcbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICB0cmlnZ2VyOiBbJ2NsaWNrJ10sXG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxCdXR0b25cbiAgICAgICAgdGl0bGU9XCJDbGljayB0byBzaG93IGRlc2NyaXB0aW9uXCJcbiAgICAgICAgcmVmPXtzZXRUcmlnZ2VyUmVmfVxuICAgICAgICBpY29uPVwiaW5mby1jaXJjbGVcIlxuICAgICAgICBzaXplPVwic21cIlxuICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgZmlsbD1cInRleHRcIlxuICAgICAgLz5cbiAgICAgIHt2aXNpYmxlICYmIChcbiAgICAgICAgPFBvcnRhbD5cbiAgICAgICAgICA8ZGl2IHJlZj17c2V0VG9vbHRpcFJlZn0gey4uLmdldFRvb2x0aXBQcm9wcygpfSBjbGFzc05hbWU9e3N0eWxlcy5kb2NCb3h9PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kb2NCb3hIZWFkZXJ9PlxuICAgICAgICAgICAgICA8c3Bhbj57ZGVmLnJlbmRlcmVyKG9wZXJhdGlvbiwgZGVmLCAnPGV4cHI+Jyl9PC9zcGFuPlxuICAgICAgICAgICAgICA8RmxleEl0ZW0gZ3Jvdz17MX0gLz5cbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIGljb249XCJ0aW1lc1wiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2hvdyhmYWxzZSl9XG4gICAgICAgICAgICAgICAgZmlsbD1cInRleHRcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIHRpdGxlPVwiUmVtb3ZlIG9wZXJhdGlvblwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuZG9jQm94Qm9keX1cbiAgICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBnZXRPcGVyYXRpb25Eb2NzKGRlZiwgb3BlcmF0aW9uKSB9fVxuICAgICAgICAgICAgPjwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L1BvcnRhbD5cbiAgICAgICl9XG4gICAgPC8+XG4gICk7XG59KTtcblxuT3BlcmF0aW9uSW5mb0J1dHRvbi5kaXNwbGF5TmFtZSA9ICdPcGVyYXRpb25Eb2NzJztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZG9jQm94OiBjc3Moe1xuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgYmFja2dyb3VuZDogdGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeSxcbiAgICAgIGJvcmRlcjogYDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ib3JkZXIuc3Ryb25nfWAsXG4gICAgICBib3hTaGFkb3c6IHRoZW1lLnNoYWRvd3MuejMsXG4gICAgICBtYXhXaWR0aDogJzYwMHB4JyxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgICBib3JkZXJSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cygpLFxuICAgICAgekluZGV4OiB0aGVtZS56SW5kZXgudG9vbHRpcCxcbiAgICB9KSxcbiAgICBkb2NCb3hIZWFkZXI6IGNzcyh7XG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5oNS5mb250U2l6ZSxcbiAgICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseU1vbm9zcGFjZSxcbiAgICAgIHBhZGRpbmdCb3R0b206IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICB9KSxcbiAgICBkb2NCb3hCb2R5OiBjc3Moe1xuICAgICAgLy8gVGhlIG1hcmtkb3duIHBhcmFncmFwaCBoYXMgYSBtYXJnaW5Cb3R0b20gdGhpcyByZW1vdmVzIGl0XG4gICAgICBtYXJnaW5Cb3R0b206IHRoZW1lLnNwYWNpbmcoLTEpLFxuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICB9KSxcbiAgICBzaWduYXR1cmU6IGNzcyh7XG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBmb250RmFtaWx5OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHlNb25vc3BhY2UsXG4gICAgfSksXG4gICAgZHJvcGRvd246IGNzcyh7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICB9KSxcbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25Eb2NzKGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKTogc3RyaW5nIHtcbiAgcmV0dXJuIHJlbmRlck1hcmtkb3duKGRlZi5leHBsYWluSGFuZGxlciA/IGRlZi5leHBsYWluSGFuZGxlcihvcCwgZGVmKSA6IGRlZi5kb2N1bWVudGF0aW9uID8/ICdubyBkb2NzJyk7XG59XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRHJhZ0Ryb3BDb250ZXh0LCBEcm9wcGFibGUsIERyb3BSZXN1bHQgfSBmcm9tICdyZWFjdC1iZWF1dGlmdWwtZG5kJztcbmltcG9ydCB7IHVzZU1vdW50ZWRTdGF0ZSwgdXNlUHJldmlvdXMgfSBmcm9tICdyZWFjdC11c2UnO1xuXG5pbXBvcnQgeyBEYXRhU291cmNlQXBpLCBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBCdXR0b24sIENhc2NhZGVyLCBDYXNjYWRlck9wdGlvbiwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBRdWVyeVdpdGhPcGVyYXRpb25zLCBWaXN1YWxRdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuaW1wb3J0IHsgT3BlcmF0aW9uRWRpdG9yIH0gZnJvbSAnLi9PcGVyYXRpb25FZGl0b3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzPFQgZXh0ZW5kcyBRdWVyeVdpdGhPcGVyYXRpb25zPiB7XG4gIHF1ZXJ5OiBUO1xuICBkYXRhc291cmNlOiBEYXRhU291cmNlQXBpO1xuICBvbkNoYW5nZTogKHF1ZXJ5OiBUKSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xuICBxdWVyeU1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyO1xuICBleHBsYWluTW9kZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBPcGVyYXRpb25MaXN0PFQgZXh0ZW5kcyBRdWVyeVdpdGhPcGVyYXRpb25zPih7XG4gIHF1ZXJ5LFxuICBkYXRhc291cmNlLFxuICBxdWVyeU1vZGVsbGVyLFxuICBvbkNoYW5nZSxcbiAgb25SdW5RdWVyeSxcbn06IFByb3BzPFQ+KSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgY29uc3QgeyBvcGVyYXRpb25zIH0gPSBxdWVyeTtcblxuICBjb25zdCBvcHNUb0hpZ2hsaWdodCA9IHVzZU9wZXJhdGlvbnNIaWdobGlnaHQob3BlcmF0aW9ucyk7XG5cbiAgY29uc3QgW2Nhc2NhZGVyT3Blbiwgc2V0Q2FzY2FkZXJPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICBjb25zdCBvbk9wZXJhdGlvbkNoYW5nZSA9IChpbmRleDogbnVtYmVyLCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWRMaXN0ID0gWy4uLm9wZXJhdGlvbnNdO1xuICAgIHVwZGF0ZWRMaXN0LnNwbGljZShpbmRleCwgMSwgdXBkYXRlKTtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBvcGVyYXRpb25zOiB1cGRhdGVkTGlzdCB9KTtcbiAgfTtcblxuICBjb25zdCBvblJlbW92ZSA9IChpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZExpc3QgPSBbLi4ub3BlcmF0aW9ucy5zbGljZSgwLCBpbmRleCksIC4uLm9wZXJhdGlvbnMuc2xpY2UoaW5kZXggKyAxKV07XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgb3BlcmF0aW9uczogdXBkYXRlZExpc3QgfSk7XG4gIH07XG5cbiAgY29uc3QgYWRkT3B0aW9uczogQ2FzY2FkZXJPcHRpb25bXSA9IHF1ZXJ5TW9kZWxsZXIuZ2V0Q2F0ZWdvcmllcygpLm1hcCgoY2F0ZWdvcnkpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGNhdGVnb3J5LFxuICAgICAgbGFiZWw6IGNhdGVnb3J5LFxuICAgICAgaXRlbXM6IHF1ZXJ5TW9kZWxsZXIuZ2V0T3BlcmF0aW9uc0ZvckNhdGVnb3J5KGNhdGVnb3J5KS5tYXAoKG9wZXJhdGlvbikgPT4gKHtcbiAgICAgICAgdmFsdWU6IG9wZXJhdGlvbi5pZCxcbiAgICAgICAgbGFiZWw6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICBpc0xlYWY6IHRydWUsXG4gICAgICB9KSksXG4gICAgfTtcbiAgfSk7XG5cbiAgY29uc3Qgb25BZGRPcGVyYXRpb24gPSAodmFsdWU6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IG9wZXJhdGlvbkRlZiA9IHF1ZXJ5TW9kZWxsZXIuZ2V0T3BlcmF0aW9uRGVmKHZhbHVlKTtcbiAgICBpZiAoIW9wZXJhdGlvbkRlZikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvbkNoYW5nZShvcGVyYXRpb25EZWYuYWRkT3BlcmF0aW9uSGFuZGxlcihvcGVyYXRpb25EZWYsIHF1ZXJ5LCBxdWVyeU1vZGVsbGVyKSk7XG4gICAgc2V0Q2FzY2FkZXJPcGVuKGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBvbkRyYWdFbmQgPSAocmVzdWx0OiBEcm9wUmVzdWx0KSA9PiB7XG4gICAgaWYgKCFyZXN1bHQuZGVzdGluYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVkTGlzdCA9IFsuLi5vcGVyYXRpb25zXTtcbiAgICBjb25zdCBlbGVtZW50ID0gdXBkYXRlZExpc3RbcmVzdWx0LnNvdXJjZS5pbmRleF07XG4gICAgdXBkYXRlZExpc3Quc3BsaWNlKHJlc3VsdC5zb3VyY2UuaW5kZXgsIDEpO1xuICAgIHVwZGF0ZWRMaXN0LnNwbGljZShyZXN1bHQuZGVzdGluYXRpb24uaW5kZXgsIDAsIGVsZW1lbnQpO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIG9wZXJhdGlvbnM6IHVwZGF0ZWRMaXN0IH0pO1xuICB9O1xuXG4gIGNvbnN0IG9uQ2FzY2FkZXJCbHVyID0gKCkgPT4ge1xuICAgIHNldENhc2NhZGVyT3BlbihmYWxzZSk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZ2FwPXsxfSBkaXJlY3Rpb249XCJjb2x1bW5cIj5cbiAgICAgIDxTdGFjayBnYXA9ezF9PlxuICAgICAgICB7b3BlcmF0aW9ucy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICA8RHJhZ0Ryb3BDb250ZXh0IG9uRHJhZ0VuZD17b25EcmFnRW5kfT5cbiAgICAgICAgICAgIDxEcm9wcGFibGUgZHJvcHBhYmxlSWQ9XCJzb3J0YWJsZS1maWVsZC1tYXBwaW5nc1wiIGRpcmVjdGlvbj1cImhvcml6b250YWxcIj5cbiAgICAgICAgICAgICAgeyhwcm92aWRlZCkgPT4gKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMub3BlcmF0aW9uTGlzdH0gcmVmPXtwcm92aWRlZC5pbm5lclJlZn0gey4uLnByb3ZpZGVkLmRyb3BwYWJsZVByb3BzfT5cbiAgICAgICAgICAgICAgICAgIHtvcGVyYXRpb25zLm1hcCgob3AsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxPcGVyYXRpb25FZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgICBrZXk9e29wLmlkICsgaW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgcXVlcnlNb2RlbGxlcj17cXVlcnlNb2RlbGxlcn1cbiAgICAgICAgICAgICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uPXtvcH1cbiAgICAgICAgICAgICAgICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25PcGVyYXRpb25DaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgb25SZW1vdmU9e29uUmVtb3ZlfVxuICAgICAgICAgICAgICAgICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0PXtvcHNUb0hpZ2hsaWdodFtpbmRleF19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICAgIHtwcm92aWRlZC5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvRHJvcHBhYmxlPlxuICAgICAgICAgIDwvRHJhZ0Ryb3BDb250ZXh0PlxuICAgICAgICApfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmFkZEJ1dHRvbn0+XG4gICAgICAgICAge2Nhc2NhZGVyT3BlbiA/IChcbiAgICAgICAgICAgIDxDYXNjYWRlclxuICAgICAgICAgICAgICBvcHRpb25zPXthZGRPcHRpb25zfVxuICAgICAgICAgICAgICBvblNlbGVjdD17b25BZGRPcGVyYXRpb259XG4gICAgICAgICAgICAgIG9uQmx1cj17b25DYXNjYWRlckJsdXJ9XG4gICAgICAgICAgICAgIGF1dG9Gb2N1cz17dHJ1ZX1cbiAgICAgICAgICAgICAgYWx3YXlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICAgICAgaGlkZUFjdGl2ZUxldmVsTGFiZWw9e3RydWV9XG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXsnU2VhcmNoJ31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxCdXR0b24gaWNvbj17J3BsdXMnfSB2YXJpYW50PXsnc2Vjb25kYXJ5J30gb25DbGljaz17KCkgPT4gc2V0Q2FzY2FkZXJPcGVuKHRydWUpfSB0aXRsZT17J0FkZCBvcGVyYXRpb24nfT5cbiAgICAgICAgICAgICAgT3BlcmF0aW9uc1xuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L1N0YWNrPlxuICAgIDwvU3RhY2s+XG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyBpbmRleGVzIG9mIG9wZXJhdGlvbnMgdGhhdCBzaG91bGQgYmUgaGlnaGxpZ2h0ZWQuIFdlIGNoZWNrIHRoZSBkaWZmIG9mIG9wZXJhdGlvbnMgYWRkZWQgYnV0IGF0IHRoZSBzYW1lIHRpbWVcbiAqIHdlIHdhbnQgdG8gaGlnaGxpZ2h0IG9wZXJhdGlvbnMgb25seSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXIsIHNvIHdlIGNoZWNrIGZvciBtb3VudGVkIHN0YXRlIGFuZCBjYWxjdWxhdGUgdGhlIGRpZmZcbiAqIG9ubHkgYWZ0ZXIuXG4gKiBAcGFyYW0gb3BlcmF0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VPcGVyYXRpb25zSGlnaGxpZ2h0KG9wZXJhdGlvbnM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbltdKSB7XG4gIGNvbnN0IGlzTW91bnRlZCA9IHVzZU1vdW50ZWRTdGF0ZSgpO1xuICBjb25zdCBwcmV2T3BlcmF0aW9ucyA9IHVzZVByZXZpb3VzKG9wZXJhdGlvbnMpO1xuXG4gIGlmICghaXNNb3VudGVkKCkpIHtcbiAgICByZXR1cm4gb3BlcmF0aW9ucy5tYXAoKCkgPT4gZmFsc2UpO1xuICB9XG5cbiAgaWYgKCFwcmV2T3BlcmF0aW9ucykge1xuICAgIHJldHVybiBvcGVyYXRpb25zLm1hcCgoKSA9PiB0cnVlKTtcbiAgfVxuXG4gIGxldCBuZXdPcHM6IGJvb2xlYW5bXSA9IFtdO1xuXG4gIGlmIChwcmV2T3BlcmF0aW9ucy5sZW5ndGggLSAxID09PSBvcGVyYXRpb25zLmxlbmd0aCAmJiBvcGVyYXRpb25zLmV2ZXJ5KChvcCkgPT4gcHJldk9wZXJhdGlvbnMuaW5jbHVkZXMob3ApKSkge1xuICAgIC8vIEluIGNhc2Ugd2UgcmVtb3ZlIG9uZSBvcCBhbmQgZG9lcyBub3QgY2hhbmdlIGFueSBvcHMgdGhlbiBkb24ndCBoaWdobGlnaHQgYW55dGhpbmcuXG4gICAgcmV0dXJuIG9wZXJhdGlvbnMubWFwKCgpID0+IGZhbHNlKTtcbiAgfVxuICBpZiAocHJldk9wZXJhdGlvbnMubGVuZ3RoICsgMSA9PT0gb3BlcmF0aW9ucy5sZW5ndGggJiYgcHJldk9wZXJhdGlvbnMuZXZlcnkoKG9wKSA9PiBvcGVyYXRpb25zLmluY2x1ZGVzKG9wKSkpIHtcbiAgICAvLyBJZiB3ZSBhZGQgYSBzaW5nbGUgb3AganVzdCBmaW5kIGl0IGFuZCBoaWdobGlnaHQganVzdCB0aGF0LlxuICAgIGNvbnN0IG5ld09wID0gb3BlcmF0aW9ucy5maW5kKChvcCkgPT4gIXByZXZPcGVyYXRpb25zLmluY2x1ZGVzKG9wKSk7XG4gICAgbmV3T3BzID0gb3BlcmF0aW9ucy5tYXAoKG9wKSA9PiB7XG4gICAgICByZXR1cm4gb3AgPT09IG5ld09wO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIERlZmF1bHQgZGlmZiBvZiBhbGwgb3BzLlxuICAgIG5ld09wcyA9IG9wZXJhdGlvbnMubWFwKChvcCwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiAhaXNTYW1lT3Aob3AuaWQsIHByZXZPcGVyYXRpb25zW2luZGV4XT8uaWQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXdPcHM7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9wKG9wMT86IHN0cmluZywgb3AyPzogc3RyaW5nKSB7XG4gIHJldHVybiBvcDEgPT09IG9wMiB8fCBgX18ke29wMX1fYnlgID09PSBvcDIgfHwgb3AxID09PSBgX18ke29wMn1fYnlgO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBoZWFkaW5nOiBjc3Moe1xuICAgICAgbGFiZWw6ICdoZWFkaW5nJyxcbiAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgIGZvbnRXZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIG1hcmdpbkJvdHRvbTogMCxcbiAgICB9KSxcbiAgICBvcGVyYXRpb25MaXN0OiBjc3Moe1xuICAgICAgbGFiZWw6ICdvcGVyYXRpb25MaXN0JyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXhXcmFwOiAnd3JhcCcsXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgfSksXG4gICAgYWRkQnV0dG9uOiBjc3Moe1xuICAgICAgbGFiZWw6ICdhZGRCdXR0b24nLFxuICAgICAgd2lkdGg6IDEyNixcbiAgICAgIHBhZGRpbmdCb3R0b206IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgR3JhbW1hciB9IGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgT3BlcmF0aW9uRXhwbGFpbmVkQm94IH0gZnJvbSAnLi9PcGVyYXRpb25FeHBsYWluZWRCb3gnO1xuaW1wb3J0IHsgUmF3UXVlcnkgfSBmcm9tICcuL1Jhd1F1ZXJ5JztcbmltcG9ydCB7IFF1ZXJ5V2l0aE9wZXJhdGlvbnMsIFZpc3VhbFF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wczxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4ge1xuICBxdWVyeTogVDtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgZXhwbGFpbk1vZGU/OiBib29sZWFuO1xuICBzdGVwTnVtYmVyOiBudW1iZXI7XG4gIGxhbmc6IHtcbiAgICBncmFtbWFyOiBHcmFtbWFyO1xuICAgIG5hbWU6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbkxpc3RFeHBsYWluZWQ8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KHtcbiAgcXVlcnksXG4gIHF1ZXJ5TW9kZWxsZXIsXG4gIHN0ZXBOdW1iZXIsXG4gIGxhbmcsXG59OiBQcm9wczxUPikge1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7cXVlcnkub3BlcmF0aW9ucy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBkZWYgPSBxdWVyeU1vZGVsbGVyLmdldE9wZXJhdGlvbkRlZihvcC5pZCk7XG4gICAgICAgIGlmICghZGVmKSB7XG4gICAgICAgICAgcmV0dXJuIGBPcGVyYXRpb24gJHtvcC5pZH0gbm90IGZvdW5kYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aXRsZSA9IGRlZi5yZW5kZXJlcihvcCwgZGVmLCAnPGV4cHI+Jyk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBkZWYuZXhwbGFpbkhhbmRsZXIgPyBkZWYuZXhwbGFpbkhhbmRsZXIob3AsIGRlZikgOiBkZWYuZG9jdW1lbnRhdGlvbiA/PyAnbm8gZG9jcyc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8T3BlcmF0aW9uRXhwbGFpbmVkQm94XG4gICAgICAgICAgICBzdGVwTnVtYmVyPXtpbmRleCArIHN0ZXBOdW1iZXJ9XG4gICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgdGl0bGU9ezxSYXdRdWVyeSBxdWVyeT17dGl0bGV9IGxhbmc9e2xhbmd9IC8+fVxuICAgICAgICAgICAgbWFya2Rvd249e2JvZHl9XG4gICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSwgdG9PcHRpb24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEF1dG9TaXplSW5wdXQsIENoZWNrYm94LCBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uUGFyYW1JZCB9IGZyb20gJy4vb3BlcmF0aW9uVXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlcmF0aW9uUGFyYW1FZGl0b3IoXG4gIHBhcmFtRGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZlxuKTogQ29tcG9uZW50VHlwZTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzPiB7XG4gIGlmIChwYXJhbURlZi5lZGl0b3IpIHtcbiAgICByZXR1cm4gcGFyYW1EZWYuZWRpdG9yO1xuICB9XG5cbiAgaWYgKHBhcmFtRGVmLm9wdGlvbnMpIHtcbiAgICByZXR1cm4gU2VsZWN0SW5wdXRQYXJhbUVkaXRvcjtcbiAgfVxuXG4gIHN3aXRjaCAocGFyYW1EZWYudHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIEJvb2xJbnB1dFBhcmFtRWRpdG9yO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFNpbXBsZUlucHV0UGFyYW1FZGl0b3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gU2ltcGxlSW5wdXRQYXJhbUVkaXRvcihwcm9wczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxBdXRvU2l6ZUlucHV0XG4gICAgICBpZD17Z2V0T3BlcmF0aW9uUGFyYW1JZChwcm9wcy5vcGVyYXRpb25JbmRleCwgcHJvcHMuaW5kZXgpfVxuICAgICAgZGVmYXVsdFZhbHVlPXtwcm9wcy52YWx1ZT8udG9TdHJpbmcoKX1cbiAgICAgIG1pbldpZHRoPXtwcm9wcy5wYXJhbURlZi5taW5XaWR0aH1cbiAgICAgIHBsYWNlaG9sZGVyPXtwcm9wcy5wYXJhbURlZi5wbGFjZWhvbGRlcn1cbiAgICAgIHRpdGxlPXtwcm9wcy5wYXJhbURlZi5kZXNjcmlwdGlvbn1cbiAgICAgIG9uQ29tbWl0Q2hhbmdlPXsoZXZ0KSA9PiB7XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlKHByb3BzLmluZGV4LCBldnQuY3VycmVudFRhcmdldC52YWx1ZSk7XG4gICAgICAgIGlmIChwcm9wcy5wYXJhbURlZi5ydW5RdWVyeU9uRW50ZXIgJiYgZXZ0LnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgIHByb3BzLm9uUnVuUXVlcnkoKTtcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAvPlxuICApO1xufVxuXG5mdW5jdGlvbiBCb29sSW5wdXRQYXJhbUVkaXRvcihwcm9wczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxDaGVja2JveFxuICAgICAgaWQ9e2dldE9wZXJhdGlvblBhcmFtSWQocHJvcHMub3BlcmF0aW9uSW5kZXgsIHByb3BzLmluZGV4KX1cbiAgICAgIHZhbHVlPXtwcm9wcy52YWx1ZSBhcyBib29sZWFufVxuICAgICAgb25DaGFuZ2U9eyhldnQpID0+IHByb3BzLm9uQ2hhbmdlKHByb3BzLmluZGV4LCBldnQuY3VycmVudFRhcmdldC5jaGVja2VkKX1cbiAgICAvPlxuICApO1xufVxuXG5mdW5jdGlvbiBTZWxlY3RJbnB1dFBhcmFtRWRpdG9yKHtcbiAgcGFyYW1EZWYsXG4gIHZhbHVlLFxuICBpbmRleCxcbiAgb3BlcmF0aW9uSW5kZXgsXG4gIG9uQ2hhbmdlLFxufTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcykge1xuICBsZXQgc2VsZWN0T3B0aW9ucyA9IHBhcmFtRGVmLm9wdGlvbnMgYXMgQXJyYXk8U2VsZWN0YWJsZVZhbHVlPGFueT4+O1xuXG4gIGlmICghc2VsZWN0T3B0aW9uc1swXT8ubGFiZWwpIHtcbiAgICBzZWxlY3RPcHRpb25zID0gcGFyYW1EZWYub3B0aW9ucyEubWFwKChvcHRpb24pID0+ICh7XG4gICAgICBsYWJlbDogb3B0aW9uLnRvU3RyaW5nKCksXG4gICAgICB2YWx1ZTogb3B0aW9uIGFzIHN0cmluZyxcbiAgICB9KSk7XG4gIH1cblxuICBsZXQgdmFsdWVPcHRpb24gPSBzZWxlY3RPcHRpb25zLmZpbmQoKHgpID0+IHgudmFsdWUgPT09IHZhbHVlKSA/PyB0b09wdGlvbih2YWx1ZSBhcyBzdHJpbmcpO1xuXG4gIHJldHVybiAoXG4gICAgPFNlbGVjdFxuICAgICAgaWQ9e2dldE9wZXJhdGlvblBhcmFtSWQob3BlcmF0aW9uSW5kZXgsIGluZGV4KX1cbiAgICAgIHZhbHVlPXt2YWx1ZU9wdGlvbn1cbiAgICAgIG9wdGlvbnM9e3NlbGVjdE9wdGlvbnN9XG4gICAgICBwbGFjZWhvbGRlcj17cGFyYW1EZWYucGxhY2Vob2xkZXJ9XG4gICAgICBhbGxvd0N1c3RvbVZhbHVlPXt0cnVlfVxuICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4gb25DaGFuZ2UoaW5kZXgsIHZhbHVlLnZhbHVlISl9XG4gICAgLz5cbiAgKTtcbn1cbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlcmF0aW9uc0VkaXRvclJvdyh7IGNoaWxkcmVuIH06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucm9vdH0+XG4gICAgICA8U3RhY2sgZ2FwPXsxfT57Y2hpbGRyZW59PC9TdGFjaz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgcm9vdDogY3NzKHtcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMSwgMSwgMCwgMSksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlY29uZGFyeSxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKDEpLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBSYWRpb0J1dHRvbkdyb3VwLCBUYWcgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFF1ZXJ5RWRpdG9yTW9kZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgbW9kZTogUXVlcnlFZGl0b3JNb2RlO1xuICBvbkNoYW5nZTogKG1vZGU6IFF1ZXJ5RWRpdG9yTW9kZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgZWRpdG9yTW9kZXMgPSBbXG4gIHsgbGFiZWw6ICdFeHBsYWluJywgdmFsdWU6IFF1ZXJ5RWRpdG9yTW9kZS5FeHBsYWluIH0sXG4gIHtcbiAgICBsYWJlbDogJ0J1aWxkZXInLFxuICAgIHZhbHVlOiBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcixcbiAgICBjb21wb25lbnQ6ICgpID0+IChcbiAgICAgIDxUYWdcbiAgICAgICAgY2xhc3NOYW1lPXtjc3Moe1xuICAgICAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgICAgICBwYWRkaW5nOiAnMXB4IDVweCcsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogJ3RleHQtYm90dG9tJyxcbiAgICAgICAgfSl9XG4gICAgICAgIG5hbWU9eydCZXRhJ31cbiAgICAgICAgY29sb3JJbmRleD17MX1cbiAgICAgIC8+XG4gICAgKSxcbiAgfSxcbiAgeyBsYWJlbDogJ0NvZGUnLCB2YWx1ZTogUXVlcnlFZGl0b3JNb2RlLkNvZGUgfSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeUVkaXRvck1vZGVUb2dnbGUoeyBtb2RlLCBvbkNoYW5nZSB9OiBQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXYgZGF0YS10ZXN0aWQ9eydRdWVyeUVkaXRvck1vZGVUb2dnbGUnfT5cbiAgICAgIDxSYWRpb0J1dHRvbkdyb3VwIG9wdGlvbnM9e2VkaXRvck1vZGVzfSBzaXplPVwic21cIiB2YWx1ZT17bW9kZX0gb25DaGFuZ2U9e29uQ2hhbmdlfSAvPlxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IHVuaXF1ZUlkIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCwgeyBIVE1MUHJvcHMsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgU3dpdGNoLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIGV4dGVuZHMgT21pdDxIVE1MUHJvcHM8SFRNTElucHV0RWxlbWVudD4sICd2YWx1ZScgfCAncmVmJz4ge1xuICB2YWx1ZT86IGJvb2xlYW47XG4gIGxhYmVsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeUhlYWRlclN3aXRjaCh7IGxhYmVsLCAuLi5pbnB1dFByb3BzIH06IFByb3BzKSB7XG4gIGNvbnN0IGRhc2hlZExhYmVsID0gbGFiZWwucmVwbGFjZSgnICcsICctJyk7XG4gIGNvbnN0IHN3aXRjaElkUmVmID0gdXNlUmVmKHVuaXF1ZUlkKGBzd2l0Y2gtJHtkYXNoZWRMYWJlbH1gKSk7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxTdGFjayBnYXA9ezF9PlxuICAgICAgPGxhYmVsIGh0bWxGb3I9e3N3aXRjaElkUmVmLmN1cnJlbnR9IGNsYXNzTmFtZT17c3R5bGVzLnN3aXRjaExhYmVsfT5cbiAgICAgICAge2xhYmVsfVxuICAgICAgPC9sYWJlbD5cbiAgICAgIDxTd2l0Y2ggey4uLmlucHV0UHJvcHN9IGlkPXtzd2l0Y2hJZFJlZi5jdXJyZW50fSAvPlxuICAgIDwvU3RhY2s+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIHN3aXRjaExhYmVsOiBjc3Moe1xuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5LFxuICAgICAgfSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVRvZ2dsZSB9IGZyb20gJ3JlYWN0LXVzZSc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEljb24sIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICB0aXRsZTogc3RyaW5nO1xuICBjb2xsYXBzZWRJbmZvOiBzdHJpbmdbXTtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFF1ZXJ5T3B0aW9uR3JvdXAoeyB0aXRsZSwgY2hpbGRyZW4sIGNvbGxhcHNlZEluZm8gfTogUHJvcHMpIHtcbiAgY29uc3QgW2lzT3BlbiwgdG9nZ2xlT3Blbl0gPSB1c2VUb2dnbGUoZmFsc2UpO1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZ2FwPXswfSBkaXJlY3Rpb249XCJjb2x1bW5cIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyfSBvbkNsaWNrPXt0b2dnbGVPcGVufSB0aXRsZT1cIkNsaWNrIHRvIGVkaXQgb3B0aW9uc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnRvZ2dsZX0+XG4gICAgICAgICAgPEljb24gbmFtZT17aXNPcGVuID8gJ2FuZ2xlLWRvd24nIDogJ2FuZ2xlLXJpZ2h0J30gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxoNiBjbGFzc05hbWU9e3N0eWxlcy50aXRsZX0+e3RpdGxlfTwvaDY+XG4gICAgICAgIHshaXNPcGVuICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRlc2NyaXB0aW9ufT5cbiAgICAgICAgICAgIHtjb2xsYXBzZWRJbmZvLm1hcCgoeCwgaSkgPT4gKFxuICAgICAgICAgICAgICA8c3BhbiBrZXk9e2l9Pnt4fTwvc3Bhbj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgICB7aXNPcGVuICYmIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm9keX0+e2NoaWxkcmVufTwvZGl2Pn1cbiAgICA8L1N0YWNrPlxuICApO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzd2l0Y2hMYWJlbDogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQucHJpbWFyeSxcbiAgICAgIH0sXG4gICAgfSksXG4gICAgaGVhZGVyOiBjc3Moe1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICBhbGlnbkl0ZW1zOiAnYmFzZWxpbmUnLFxuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnksXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZDogdGhlbWUuY29sb3JzLmVtcGhhc2l6ZSh0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5wcmltYXJ5LCAwLjAzKSxcbiAgICAgIH0sXG4gICAgfSksXG4gICAgdGl0bGU6IGNzcyh7XG4gICAgICBmbGV4R3JvdzogMSxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIG1hcmdpbjogMCxcbiAgICB9KSxcbiAgICBkZXNjcmlwdGlvbjogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBwYWRkaW5nTGVmdDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICB9KSxcbiAgICBib2R5OiBjc3Moe1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgcGFkZGluZ1RvcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGZsZXhXcmFwOiAnd3JhcCcsXG4gICAgfSksXG4gICAgdG9nZ2xlOiBjc3Moe1xuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgIG1hcmdpblJpZ2h0OiBgJHt0aGVtZS5zcGFjaW5nKDEpfWAsXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgY3NzLCBjeCB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUHJpc20sIHsgR3JhbW1hciB9IGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEvc3JjJztcbmltcG9ydCB7IHVzZVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL3VpL3NyYyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogc3RyaW5nO1xuICBsYW5nOiB7XG4gICAgZ3JhbW1hcjogR3JhbW1hcjtcbiAgICBuYW1lOiBzdHJpbmc7XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gUmF3UXVlcnkoeyBxdWVyeSwgbGFuZyB9OiBQcm9wcykge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lMigpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZXModGhlbWUpO1xuICBjb25zdCBoaWdobGlnaHRlZCA9IFByaXNtLmhpZ2hsaWdodChxdWVyeSwgbGFuZy5ncmFtbWFyLCBsYW5nLm5hbWUpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPXtjeChzdHlsZXMuZWRpdG9yRmllbGQsICdwcmlzbS1zeW50YXgtaGlnaGxpZ2h0Jyl9XG4gICAgICBhcmlhLWxhYmVsPVwic2VsZWN0b3JcIlxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBoaWdobGlnaHRlZCB9fVxuICAgIC8+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGVkaXRvckZpZWxkOiBjc3Moe1xuICAgICAgZm9udEZhbWlseTogdGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5TW9ub3NwYWNlLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNhcGl0YWxpemUgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHBsdXJhbGl6ZSBmcm9tICdwbHVyYWxpemUnO1xuXG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhL3NyYyc7XG5cbmltcG9ydCB7IExhYmVsUGFyYW1FZGl0b3IgfSBmcm9tICcuLi9jb21wb25lbnRzL0xhYmVsUGFyYW1FZGl0b3InO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSxcbiAgUXVlcnlXaXRoT3BlcmF0aW9ucyxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvblJlbmRlcmVyTGVmdChtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgY29uc3QgcGFyYW1zID0gcmVuZGVyUGFyYW1zKG1vZGVsLCBkZWYsIGlubmVyRXhwcik7XG4gIGNvbnN0IHN0ciA9IG1vZGVsLmlkICsgJygnO1xuXG4gIGlmIChpbm5lckV4cHIpIHtcbiAgICBwYXJhbXMucHVzaChpbm5lckV4cHIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ciArIHBhcmFtcy5qb2luKCcsICcpICsgJyknO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVuY3Rpb25SZW5kZXJlclJpZ2h0KG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICBjb25zdCBwYXJhbXMgPSByZW5kZXJQYXJhbXMobW9kZWwsIGRlZiwgaW5uZXJFeHByKTtcbiAgY29uc3Qgc3RyID0gbW9kZWwuaWQgKyAnKCc7XG5cbiAgaWYgKGlubmVyRXhwcikge1xuICAgIHBhcmFtcy51bnNoaWZ0KGlubmVyRXhwcik7XG4gIH1cblxuICByZXR1cm4gc3RyICsgcGFyYW1zLmpvaW4oJywgJykgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmcsXG4gIHJlbmRlckxlZnQ6IGJvb2xlYW5cbikge1xuICBpZiAoZGVmLnBhcmFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgYENhbm5vdCByZW5kZXIgYSBmdW5jdGlvbiB3aXRoIHBhcmFtcyBvZiBsZW5ndGggWyR7ZGVmLnBhcmFtcy5sZW5ndGh9XWA7XG4gIH1cblxuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnNW0nO1xuXG4gIC8vIE5leHQgZnJhbWUgdGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzLCBidXQgZ2V0IHJpZCBvZiB0aGUgZmlyc3Qgb25lIGJlY2F1c2UgaXQncyB1c2VkIHRvIG1vdmUgdGhlXG4gIC8vIGluc3RhbnQgdmVjdG9yIGludG8gYSByYW5nZSB2ZWN0b3IuXG4gIGNvbnN0IHBhcmFtcyA9IHJlbmRlclBhcmFtcyhcbiAgICB7XG4gICAgICAuLi5tb2RlbCxcbiAgICAgIHBhcmFtczogbW9kZWwucGFyYW1zLnNsaWNlKDEpLFxuICAgIH0sXG4gICAge1xuICAgICAgLi4uZGVmLFxuICAgICAgcGFyYW1zOiBkZWYucGFyYW1zLnNsaWNlKDEpLFxuICAgICAgZGVmYXVsdFBhcmFtczogZGVmLmRlZmF1bHRQYXJhbXMuc2xpY2UoMSksXG4gICAgfSxcbiAgICBpbm5lckV4cHJcbiAgKTtcblxuICBjb25zdCBzdHIgPSBtb2RlbC5pZCArICcoJztcblxuICAvLyBEZXBlbmRpbmcgb24gdGhlIHJlbmRlckxlZnQgdmFyaWFibGUsIHJlbmRlciBwYXJhbWV0ZXJzIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gIC8vIHJlbmRlckxlZnQgPT09IHRydWUgKHJlbmRlckxlZnQpID0+IChwYXJhbTEsIHBhcmFtMiwgcmFuZ2VWZWN0b3JbLi4uXSlcbiAgLy8gcmVuZGVyTGVmdCA9PT0gZmFsc2UgKHJlbmRlclJpZ2h0KSA9PiAocmFuZ2VWZWN0b3JbLi4uXSwgcGFyYW0xLCBwYXJhbTIpXG4gIGlmIChpbm5lckV4cHIpIHtcbiAgICByZW5kZXJMZWZ0ID8gcGFyYW1zLnB1c2goYCR7aW5uZXJFeHByfVske3JhbmdlVmVjdG9yfV1gKSA6IHBhcmFtcy51bnNoaWZ0KGAke2lubmVyRXhwcn1bJHtyYW5nZVZlY3Rvcn1dYCk7XG4gIH1cblxuICAvLyBzdGljayBldmVyeXRoaW5nIHRvZ2V0aGVyXG4gIHJldHVybiBzdHIgKyBwYXJhbXMuam9pbignLCAnKSArICcpJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJSaWdodFdpdGhQYXJhbXMoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIHJldHVybiByYW5nZVJlbmRlcmVyV2l0aFBhcmFtcyhtb2RlbCwgZGVmLCBpbm5lckV4cHIsIGZhbHNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJMZWZ0V2l0aFBhcmFtcyhcbiAgbW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIGlubmVyRXhwcjogc3RyaW5nXG4pIHtcbiAgcmV0dXJuIHJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zKG1vZGVsLCBkZWYsIGlubmVyRXhwciwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBhcmFtcyhtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChtb2RlbC5wYXJhbXMgPz8gW10pLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFyYW1EZWYgPSBkZWYucGFyYW1zW2luZGV4XTtcbiAgICBpZiAocGFyYW1EZWYudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcjxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4oZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIHF1ZXJ5OiBUKSB7XG4gIGNvbnN0IG5ld09wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgcGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcyxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIG9wZXJhdGlvbnM6IFsuLi5xdWVyeS5vcGVyYXRpb25zLCBuZXdPcGVyYXRpb25dLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShmdW5jTmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBjYXBpdGFsaXplKGZ1bmNOYW1lLnJlcGxhY2UoL18vZywgJyAnKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbUlkKG9wZXJhdGlvbkluZGV4OiBudW1iZXIsIHBhcmFtSW5kZXg6IG51bWJlcikge1xuICByZXR1cm4gYG9wZXJhdGlvbnMuJHtvcGVyYXRpb25JbmRleH0ucGFyYW0uJHtwYXJhbUluZGV4fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5nZVZlY3RvclBhcmFtRGVmKHdpdGhSYXRlSW50ZXJ2YWwgPSBmYWxzZSk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmIHtcbiAgY29uc3QgcGFyYW06IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmID0ge1xuICAgIG5hbWU6ICdSYW5nZScsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uczogW1xuICAgICAge1xuICAgICAgICBsYWJlbDogJyRfX2ludGVydmFsJyxcbiAgICAgICAgdmFsdWU6ICckX19pbnRlcnZhbCcsXG4gICAgICAgIC8vIHRvb2x0aXA6ICdEeW5hbWljIGludGVydmFsIGJhc2VkIG9uIG1heCBkYXRhIHBvaW50cywgc2NyYXBlIGFuZCBtaW4gaW50ZXJ2YWwnLFxuICAgICAgfSxcbiAgICAgIHsgbGFiZWw6ICcxbScsIHZhbHVlOiAnMW0nIH0sXG4gICAgICB7IGxhYmVsOiAnNW0nLCB2YWx1ZTogJzVtJyB9LFxuICAgICAgeyBsYWJlbDogJzEwbScsIHZhbHVlOiAnMTBtJyB9LFxuICAgICAgeyBsYWJlbDogJzFoJywgdmFsdWU6ICcxaCcgfSxcbiAgICAgIHsgbGFiZWw6ICcyNGgnLCB2YWx1ZTogJzI0aCcgfSxcbiAgICBdLFxuICB9O1xuXG4gIGlmICh3aXRoUmF0ZUludGVydmFsKSB7XG4gICAgKHBhcmFtLm9wdGlvbnMgYXMgQXJyYXk8U2VsZWN0YWJsZVZhbHVlPHN0cmluZz4+KS51bnNoaWZ0KHtcbiAgICAgIGxhYmVsOiAnJF9fcmF0ZV9pbnRlcnZhbCcsXG4gICAgICB2YWx1ZTogJyRfX3JhdGVfaW50ZXJ2YWwnLFxuICAgICAgLy8gdG9vbHRpcDogJ0Fsd2F5cyBhYm92ZSA0eCBzY3JhcGUgaW50ZXJ2YWwnLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgc2hhcmVkIGJldHdlZW4gUHJvbWV0aGV1cyBhbmQgTG9raSB2YXJpYW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb248VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KFxuICBuYW1lOiBzdHJpbmcsXG4gIG92ZXJyaWRlczogUGFydGlhbDxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+ID0ge31cbik6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdIHtcbiAgY29uc3Qgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10gPSBbXG4gICAge1xuICAgICAgaWQ6IG5hbWUsXG4gICAgICBuYW1lOiBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnQnkgbGFiZWwnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIHJlc3RQYXJhbTogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ3BsYWluIGFnZ3JlZ2F0aW9ucycsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQWdncmVnYXRpb25zLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICAgICAgcGFyYW1DaGFuZ2VkSGFuZGxlcjogZ2V0T25MYWJlbEFkZGVkSGFuZGxlcihgX18ke25hbWV9X2J5YCksXG4gICAgICBleHBsYWluSGFuZGxlcjogZ2V0QWdncmVnYXRpb25FeHBsYWluZXIobmFtZSwgJycpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogYF9fJHtuYW1lfV9ieWAsXG4gICAgICBuYW1lOiBgJHtnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpfSBieWAsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnYWdncmVnYXRpb25zIGJ5JyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICByZW5kZXJlcjogZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyKG5hbWUpLFxuICAgICAgcGFyYW1DaGFuZ2VkSGFuZGxlcjogZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIobmFtZSksXG4gICAgICBleHBsYWluSGFuZGxlcjogZ2V0QWdncmVnYXRpb25FeHBsYWluZXIobmFtZSwgJ2J5JyksXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICAgIGhpZGVGcm9tTGlzdDogdHJ1ZSxcbiAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBgX18ke25hbWV9X3dpdGhvdXRgLFxuICAgICAgbmFtZTogYCR7Z2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKX0gd2l0aG91dGAsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnYWdncmVnYXRpb25zIGJ5JyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICByZW5kZXJlcjogZ2V0QWdncmVnYXRpb25XaXRob3V0UmVuZGVyZXIobmFtZSksXG4gICAgICBwYXJhbUNoYW5nZWRIYW5kbGVyOiBnZXRMYXN0TGFiZWxSZW1vdmVkSGFuZGxlcihuYW1lKSxcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiBnZXRBZ2dyZWdhdGlvbkV4cGxhaW5lcihuYW1lLCAnd2l0aG91dCcpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgICBoaWRlRnJvbUxpc3Q6IHRydWUsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfSxcbiAgXTtcblxuICByZXR1cm4gb3BlcmF0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtKFxuICBuYW1lOiBzdHJpbmcsXG4gIHBhcmFtc0RlZjogeyBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW107IGRlZmF1bHRQYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWVbXSB9LFxuICBvdmVycmlkZXM6IFBhcnRpYWw8UXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPiA9IHt9XG4pOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbihuYW1lLCBvdmVycmlkZXMpO1xuICBvcGVyYXRpb25zWzBdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzFdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzJdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzBdLmRlZmF1bHRQYXJhbXMgPSBwYXJhbXNEZWYuZGVmYXVsdFBhcmFtcztcbiAgb3BlcmF0aW9uc1sxXS5kZWZhdWx0UGFyYW1zID0gWy4uLnBhcmFtc0RlZi5kZWZhdWx0UGFyYW1zLCAnJ107XG4gIG9wZXJhdGlvbnNbMl0uZGVmYXVsdFBhcmFtcyA9IFsuLi5wYXJhbXNEZWYuZGVmYXVsdFBhcmFtcywgJyddO1xuICBvcGVyYXRpb25zWzFdLnJlbmRlcmVyID0gZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyV2l0aFBhcmFtZXRlcihuYW1lKTtcbiAgb3BlcmF0aW9uc1syXS5yZW5kZXJlciA9IGdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlcldpdGhQYXJhbWV0ZXIobmFtZSk7XG4gIHJldHVybiBvcGVyYXRpb25zO1xufVxuXG5mdW5jdGlvbiBnZXRBZ2dyZWdhdGlvbkJ5UmVuZGVyZXIoYWdncmVnYXRpb246IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gYWdncmVnYXRpb25SZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7YWdncmVnYXRpb259IGJ5KCR7bW9kZWwucGFyYW1zLmpvaW4oJywgJyl9KSAoJHtpbm5lckV4cHJ9KWA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFnZ3JlZ2F0aW9uV2l0aG91dFJlbmRlcmVyKGFnZ3JlZ2F0aW9uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFnZ3JlZ2F0aW9uUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke2FnZ3JlZ2F0aW9ufSB3aXRob3V0KCR7bW9kZWwucGFyYW1zLmpvaW4oJywgJyl9KSAoJHtpbm5lckV4cHJ9KWA7XG4gIH07XG59XG5cbi8qKlxuICogVmVyeSBzaW1wbGUgcG9jIGltcGxlbWVudGF0aW9uLCBuZWVkcyB0byBiZSBtb2RpZmllZCB0byBzdXBwb3J0IGFsbCBhZ2dyZWdhdGlvbiBvcGVyYXRvcnNcbiAqL1xuZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25FeHBsYWluZXIoYWdncmVnYXRpb25OYW1lOiBzdHJpbmcsIG1vZGU6ICdieScgfCAnd2l0aG91dCcgfCAnJykge1xuICByZXR1cm4gZnVuY3Rpb24gYWdncmVnYXRpb25FeHBsYWluZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikge1xuICAgIGNvbnN0IGxhYmVscyA9IG1vZGVsLnBhcmFtcy5tYXAoKGxhYmVsKSA9PiBgXFxgJHtsYWJlbH1cXGBgKS5qb2luKCcgYW5kICcpO1xuICAgIGNvbnN0IGxhYmVsV29yZCA9IHBsdXJhbGl6ZSgnbGFiZWwnLCBtb2RlbC5wYXJhbXMubGVuZ3RoKTtcblxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSAnYnknOlxuICAgICAgICByZXR1cm4gYENhbGN1bGF0ZXMgJHthZ2dyZWdhdGlvbk5hbWV9IG92ZXIgZGltZW5zaW9ucyB3aGlsZSBwcmVzZXJ2aW5nICR7bGFiZWxXb3JkfSAke2xhYmVsc30uYDtcbiAgICAgIGNhc2UgJ3dpdGhvdXQnOlxuICAgICAgICByZXR1cm4gYENhbGN1bGF0ZXMgJHthZ2dyZWdhdGlvbk5hbWV9IG92ZXIgdGhlIGRpbWVuc2lvbnMgJHtsYWJlbHN9LiBBbGwgb3RoZXIgbGFiZWxzIGFyZSBwcmVzZXJ2ZWQuYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgQ2FsY3VsYXRlcyAke2FnZ3JlZ2F0aW9uTmFtZX0gb3ZlciB0aGUgZGltZW5zaW9ucy5gO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyV2l0aFBhcmFtZXRlcihhZ2dyZWdhdGlvbjogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhZ2dyZWdhdGlvblJlbmRlcmVyKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICAgIGZ1bmN0aW9uIG1hcFR5cGUocDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYFxcXCIke3B9XFxcImA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gbW9kZWwucGFyYW1zLnNsaWNlKDAsIC0xKTtcbiAgICBjb25zdCByZXN0UGFyYW1zID0gbW9kZWwucGFyYW1zLnNsaWNlKDEpO1xuICAgIHJldHVybiBgJHthZ2dyZWdhdGlvbn0gYnkoJHtyZXN0UGFyYW1zLmpvaW4oJywgJyl9KSAoJHtwYXJhbXMubWFwKG1hcFR5cGUpLmpvaW4oJywgJyl9LCAke2lubmVyRXhwcn0pYDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdHJhbnNmb3JtIG9wZXJhdGlvbnMgd2l0aG91dCBsYWJlbHMgdG8gdGhlaXIgcGxhbiBhZ2dyZWdhdGlvbiBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIoY2hhbmdlVG9PcGVyYXRpb25JZDogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvblBhcmFtQ2hhbmdlZChpbmRleDogbnVtYmVyLCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZikge1xuICAgIC8vIElmIGRlZmluaXRpb24gaGFzIG1vcmUgcGFyYW1zIHRoZW4gaXMgZGVmaW5lZCB0aGVyZSBhcmUgbm8gb3B0aW9uYWwgcmVzdCBwYXJhbXMgYW55bW9yZS5cbiAgICAvLyBXZSB0aGVuIHRyYW5zZm9ybSB0aGlzIG9wZXJhdGlvbiBpbnRvIGEgZGlmZmVyZW50IG9uZVxuICAgIGlmIChvcC5wYXJhbXMubGVuZ3RoIDwgZGVmLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wLFxuICAgICAgICBpZDogY2hhbmdlVG9PcGVyYXRpb25JZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPbkxhYmVsQWRkZWRIYW5kbGVyKGNoYW5nZVRvT3BlcmF0aW9uSWQ6IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gb25QYXJhbUNoYW5nZWQoaW5kZXg6IG51bWJlciwgb3A6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYpIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBhY3R1YWxseSBoYXZlIHRoZSBsYWJlbCBwYXJhbS4gQXMgaXQncyBvcHRpb25hbCB0aGUgYWdncmVnYXRpb24gY2FuIGhhdmUgb25lIGxlc3MsIHdoaWNoIGlzIHRoZVxuICAgIC8vIGNhc2Ugb2YganVzdCBzaW1wbGUgYWdncmVnYXRpb24gd2l0aG91dCBsYWJlbC4gV2hlbiB1c2VyIGFkZHMgdGhlIGxhYmVsIGl0IG5vdyBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIHBhcmFtc1xuICAgIC8vIGFzIGl0J3MgZGVmaW5pdGlvbiwgYW5kIG5vdyB3ZSBjYW4gY2hhbmdlIGl0IHRvIGl0J3MgYF9ieWAgdmFyaWFudC5cbiAgICBpZiAob3AucGFyYW1zLmxlbmd0aCA9PT0gZGVmLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wLFxuICAgICAgICBpZDogY2hhbmdlVG9PcGVyYXRpb25JZCxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcDtcbiAgfTtcbn1cbiIsImltcG9ydCB7IFN5bnRheE5vZGUsIFRyZWVDdXJzb3IgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuaW1wb3J0IHsgUXVlcnlCdWlsZGVyT3BlcmF0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIFRoaXMgaXMgdXNlZCBmb3IgZXJyb3IgdHlwZSBmb3Igc29tZSByZWFzb25cbmV4cG9ydCBjb25zdCBFcnJvck5hbWUgPSAn4pqgJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldExlZnRNb3N0Q2hpbGQoY3VyOiBTeW50YXhOb2RlKTogU3ludGF4Tm9kZSB7XG4gIHJldHVybiBjdXIuZmlyc3RDaGlsZCA/IGdldExlZnRNb3N0Q2hpbGQoY3VyLmZpcnN0Q2hpbGQpIDogY3VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVycm9yKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSkge1xuICByZXR1cm4ge1xuICAgIHRleHQ6IGdldFN0cmluZyhleHByLCBub2RlKSxcbiAgICAvLyBUT0RPOiB0aGlzIGFyZSBwb3NpdGlvbnMgaW4gdGhlIHN0cmluZyB3aXRoIHRoZSByZXBsYWNlZCB2YXJpYWJsZXMuIE1lYW5zIGl0IGNhbm5vdCBiZSB1c2VkIHRvIHNob3cgZXhhY3RcbiAgICAvLyAgcGxhY2VtZW50IG9mIHRoZSBlcnJvciBmb3IgdGhlIHVzZXIuIFdlIG5lZWQgc29tZSB0cmFuc2xhdGlvbiB0YWJsZSB0byBwb3NpdGlvbnMgYmVmb3JlIHRoZSB2YXJpYWJsZVxuICAgIC8vICByZXBsYWNlLlxuICAgIGZyb206IG5vZGUuZnJvbSxcbiAgICB0bzogbm9kZS50byxcbiAgICBwYXJlbnRUeXBlOiBub2RlLnBhcmVudD8ubmFtZSxcbiAgfTtcbn1cblxuLy8gVGFrZW4gZnJvbSB0ZW1wbGF0ZV9zcnYsIGJ1dCBjb3BpZWQgc28gdG8gbm90IG1lc3Mgd2l0aCB0aGUgcmVnZXguaW5kZXggd2hpY2ggaXMgbWFuaXB1bGF0ZWQgaW4gdGhlIHNlcnZpY2Vcbi8qXG4gKiBUaGlzIHJlZ2V4IG1hdGNoZXMgMyB0eXBlcyBvZiB2YXJpYWJsZSByZWZlcmVuY2Ugd2l0aCBhbiBvcHRpb25hbCBmb3JtYXQgc3BlY2lmaWVyXG4gKiBcXCQoXFx3KykgICAgICAgICAgICAgICAgICAgICAgICAgICR2YXIxXG4gKiBcXFtcXFsoW1xcc1xcU10rPykoPzo6KFxcdyspKT9cXF1cXF0gICAgW1t2YXIyXV0gb3IgW1t2YXIyOmZtdDJdXVxuICogXFwkeyhcXHcrKSg/OjooXFx3KykpP30gICAgICAgICAgICAgJHt2YXIzfSBvciAke3ZhcjM6Zm10M31cbiAqL1xuY29uc3QgdmFyaWFibGVSZWdleCA9IC9cXCQoXFx3Kyl8XFxbXFxbKFtcXHNcXFNdKz8pKD86OihcXHcrKSk/XFxdXFxdfFxcJHsoXFx3KykoPzpcXC4oW146XlxcfV0rKSk/KD86OihbXlxcfV0rKSk/fS9nO1xuXG4vKipcbiAqIEFzIHZhcmlhYmxlcyB3aXRoICQgYXJlIGNyZWF0aW5nIHBhcnNpbmcgZXJyb3JzLCB3ZSBmaXJzdCByZXBsYWNlIHRoZW0gd2l0aCBtYWdpYyBzdHJpbmcgdGhhdCBpcyBwYXJzYWJsZSBhbmQgYXRcbiAqIHRoZSBzYW1lIHRpbWUgd2UgY2FuIGdldCB0aGUgdmFyaWFibGUgYW5kIGl0J3MgZm9ybWF0IGJhY2sgZnJvbSBpdC5cbiAqIEBwYXJhbSBleHByXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlVmFyaWFibGVzKGV4cHI6IHN0cmluZykge1xuICByZXR1cm4gZXhwci5yZXBsYWNlKHZhcmlhYmxlUmVnZXgsIChtYXRjaCwgdmFyMSwgdmFyMiwgZm10MiwgdmFyMywgZmllbGRQYXRoLCBmbXQzKSA9PiB7XG4gICAgY29uc3QgZm10ID0gZm10MiB8fCBmbXQzO1xuICAgIGxldCB2YXJpYWJsZSA9IHZhcjE7XG4gICAgbGV0IHZhclR5cGUgPSAnMCc7XG5cbiAgICBpZiAodmFyMikge1xuICAgICAgdmFyaWFibGUgPSB2YXIyO1xuICAgICAgdmFyVHlwZSA9ICcxJztcbiAgICB9XG5cbiAgICBpZiAodmFyMykge1xuICAgICAgdmFyaWFibGUgPSB2YXIzO1xuICAgICAgdmFyVHlwZSA9ICcyJztcbiAgICB9XG5cbiAgICByZXR1cm4gYF9fVl8ke3ZhclR5cGV9X19gICsgdmFyaWFibGUgKyAnX19WX18nICsgKGZtdCA/ICdfX0ZfXycgKyBmbXQgKyAnX19GX18nIDogJycpO1xuICB9KTtcbn1cblxuY29uc3QgdmFyVHlwZUZ1bmMgPSBbXG4gICh2OiBzdHJpbmcsIGY/OiBzdHJpbmcpID0+IGBcXCQke3Z9YCxcbiAgKHY6IHN0cmluZywgZj86IHN0cmluZykgPT4gYFtbJHt2fSR7ZiA/IGA6JHtmfWAgOiAnJ31dXWAsXG4gICh2OiBzdHJpbmcsIGY/OiBzdHJpbmcpID0+IGBcXCRcXHske3Z9JHtmID8gYDoke2Z9YCA6ICcnfVxcfWAsXG5dO1xuXG4vKipcbiAqIEdldCBiYWNrIHRoZSB0ZXh0IHdpdGggdmFyaWFibGVzIGluIHRoZWlyIG9yaWdpbmFsIGZvcm1hdC5cbiAqIEBwYXJhbSBleHByXG4gKi9cbmZ1bmN0aW9uIHJldHVyblZhcmlhYmxlcyhleHByOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGV4cHIucmVwbGFjZSgvX19WXyhcXGQpX18oLis/KV9fVl9fKD86X19GX18oXFx3KylfX0ZfXyk/L2csIChtYXRjaCwgdHlwZSwgdiwgZikgPT4ge1xuICAgIHJldHVybiB2YXJUeXBlRnVuY1twYXJzZUludCh0eXBlLCAxMCldKHYsIGYpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFjdHVhbCBzdHJpbmcgb2YgdGhlIGV4cHJlc3Npb24uIFRoYXQgaXMgbm90IHN0b3JlZCBpbiB0aGUgdHJlZSBzbyB3ZSBoYXZlIHRvIGdldCB0aGUgaW5kZXhlcyBmcm9tIHRoZSBub2RlXG4gKiBhbmQgdGhlbiBiYXNlZCBvbiB0aGF0IGdldCBpdCBmcm9tIHRoZSBleHByZXNzaW9uLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHJpbmcoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlIHwgVHJlZUN1cnNvciB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiByZXR1cm5WYXJpYWJsZXMoZXhwci5zdWJzdHJpbmcobm9kZS5mcm9tLCBub2RlLnRvKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHNpbXBsZSBzY2FsYXIgYmluYXJ5IG9wIG9iamVjdC5cbiAqIEBwYXJhbSBvcERlZiAtIGRlZmluaXRpb24gb2YgdGhlIG9wIHRvIGJlIGNyZWF0ZWRcbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbnVtYmVyTm9kZSAtIHRoZSBub2RlIGZvciB0aGUgc2NhbGFyXG4gKiBAcGFyYW0gaGFzQm9vbCAtIHdoZXRoZXIgb3BlcmF0aW9uIGhhcyBhIGJvb2wgbW9kaWZpZXIuIElzIHVzZWQgb25seSBmb3Igb3BzIGZvciB3aGljaCBpdCBtYWtlcyBzZW5zZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VCaW5PcChcbiAgb3BEZWY6IHsgaWQ6IHN0cmluZzsgY29tcGFyaXNvbj86IGJvb2xlYW4gfSxcbiAgZXhwcjogc3RyaW5nLFxuICBudW1iZXJOb2RlOiBTeW50YXhOb2RlLFxuICBoYXNCb29sOiBib29sZWFuXG4pOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24ge1xuICBjb25zdCBwYXJhbXM6IGFueVtdID0gW3BhcnNlRmxvYXQoZ2V0U3RyaW5nKGV4cHIsIG51bWJlck5vZGUpKV07XG4gIGlmIChvcERlZi5jb21wYXJpc29uKSB7XG4gICAgcGFyYW1zLnB1c2goaGFzQm9vbCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZDogb3BEZWYuaWQsXG4gICAgcGFyYW1zLFxuICB9O1xufVxuXG4vKipcbiAqIEdldCBhbGwgbm9kZXMgd2l0aCB0eXBlIGluIHRoZSB0cmVlLiBUaGlzIHRyYXZlcnNlcyB0aGUgdHJlZSBzbyBpdCBpcyBzYWZlIG9ubHkgd2hlbiB5b3Uga25vdyB0aGVyZSBzaG91bGRuJ3QgYmVcbiAqIHRvbyBtdWNoIG5lc3RpbmcgYnV0IHlvdSBqdXN0IHdhbnQgdG8gc2tpcCBzb21lIG9mIHRoZSB3cmFwcGVycy4gRm9yIGV4YW1wbGUgZ2V0dGluZyBmdW5jdGlvbiBhcmdzIHRoaXMgd2F5IHdvdWxkXG4gKiBub3QgYmUgc2FmZSBpcyBpdCB3b3VsZCBhbHNvIGZpbmQgYXJndW1lbnRzIG9mIG5lc3RlZCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIGN1clxuICogQHBhcmFtIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbEJ5VHlwZShleHByOiBzdHJpbmcsIGN1cjogU3ludGF4Tm9kZSwgdHlwZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICBpZiAoY3VyLm5hbWUgPT09IHR5cGUpIHtcbiAgICByZXR1cm4gW2dldFN0cmluZyhleHByLCBjdXIpXTtcbiAgfVxuICBjb25zdCB2YWx1ZXM6IHN0cmluZ1tdID0gW107XG4gIGxldCBwb3MgPSAwO1xuICBsZXQgY2hpbGQgPSBjdXIuY2hpbGRBZnRlcihwb3MpO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICB2YWx1ZXMucHVzaCguLi5nZXRBbGxCeVR5cGUoZXhwciwgY2hpbGQsIHR5cGUpKTtcbiAgICBwb3MgPSBjaGlsZC50bztcbiAgICBjaGlsZCA9IGN1ci5jaGlsZEFmdGVyKHBvcyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gRGVidWdnaW5nIGZ1bmN0aW9uIGZvciBjb252ZW5pZW5jZS4gR2l2ZXMgeW91IG5pY2Ugb3V0cHV0IHNpbWlsYXIgdG8gbGludXggdHJlZSB1dGlsLlxuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGZ1bmN0aW9uIGxvZyhleHByOiBzdHJpbmcsIGN1cj86IFN5bnRheE5vZGUpIHtcbiAgaWYgKCFjdXIpIHtcbiAgICBjb25zb2xlLmxvZygnPGVtcHR5PicpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBqc29uID0gdG9Kc29uKGV4cHIsIGN1cik7XG4gIGNvbnN0IHRleHQgPSBqc29uVG9UZXh0KGpzb24pO1xuXG4gIGlmICghdGV4dCkge1xuICAgIGNvbnNvbGUubG9nKCc8ZW1wdHk+Jyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUubG9nKHRleHQpO1xufVxuXG5mdW5jdGlvbiB0b0pzb24oZXhwcjogc3RyaW5nLCBjdXI6IFN5bnRheE5vZGUpIHtcbiAgY29uc3QgdHJlZUpzb246IGFueSA9IHt9O1xuICBjb25zdCBuYW1lID0gbm9kZVRvU3RyaW5nKGV4cHIsIGN1cik7XG4gIGNvbnN0IGNoaWxkcmVuID0gW107XG5cbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBjaGlsZCA9IGN1ci5jaGlsZEFmdGVyKHBvcyk7XG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGNoaWxkcmVuLnB1c2godG9Kc29uKGV4cHIsIGNoaWxkKSk7XG4gICAgcG9zID0gY2hpbGQudG87XG4gICAgY2hpbGQgPSBjdXIuY2hpbGRBZnRlcihwb3MpO1xuICB9XG5cbiAgdHJlZUpzb24ubmFtZSA9IG5hbWU7XG4gIHRyZWVKc29uLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHJldHVybiB0cmVlSnNvbjtcbn1cblxudHlwZSBKc29uTm9kZSA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICBjaGlsZHJlbjogSnNvbk5vZGVbXTtcbn07XG5cbmZ1bmN0aW9uIGpzb25Ub1RleHQoXG4gIG5vZGU6IEpzb25Ob2RlLFxuICBjb250ZXh0OiB7IGxhc3RDaGlsZDogYm9vbGVhbjsgaW5kZW50OiBzdHJpbmcgfSA9IHtcbiAgICBsYXN0Q2hpbGQ6IHRydWUsXG4gICAgaW5kZW50OiAnJyxcbiAgfVxuKSB7XG4gIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gIGNvbnN0IHsgbGFzdENoaWxkLCBpbmRlbnQgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IG5ld0luZGVudCA9IGluZGVudCAhPT0gJycgPyBpbmRlbnQgKyAobGFzdENoaWxkID8gJ+KUlOKUgCcgOiAn4pSc4pSAJykgOiAnJztcbiAgbGV0IHRleHQgPSBuZXdJbmRlbnQgKyBuYW1lO1xuXG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQ6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGlzTGFzdENoaWxkID0gaW5kZXggPT09IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgdGV4dCArPVxuICAgICAgJ1xcbicgK1xuICAgICAganNvblRvVGV4dChjaGlsZCwge1xuICAgICAgICBsYXN0Q2hpbGQ6IGlzTGFzdENoaWxkLFxuICAgICAgICBpbmRlbnQ6IGluZGVudCArIChsYXN0Q2hpbGQgPyAnICAnIDogJ+KUgiAnKSxcbiAgICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGV4dDtcbn1cblxuZnVuY3Rpb24gbm9kZVRvU3RyaW5nKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSkge1xuICByZXR1cm4gbm9kZS5uYW1lICsgJzogJyArIGdldFN0cmluZyhleHByLCBub2RlKTtcbn1cbiIsIi8qKlxuICogU2hhcmVkIHR5cGVzIHRoYXQgY2FuIGJlIHJldXNlZCBieSBMb2tpIGFuZCBvdGhlciBkYXRhIHNvdXJjZXNcbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBEYXRhU291cmNlQXBpLCBSZWdpc3RyeUl0ZW0sIFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIHtcbiAgbGFiZWw6IHN0cmluZztcbiAgb3A6IHN0cmluZztcbiAgdmFsdWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb24ge1xuICBpZDogc3RyaW5nO1xuICBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeVdpdGhPcGVyYXRpb25zIHtcbiAgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPFQgPSBhbnk+IGV4dGVuZHMgUmVnaXN0cnlJdGVtIHtcbiAgZG9jdW1lbnRhdGlvbj86IHN0cmluZztcbiAgcGFyYW1zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZltdO1xuICBkZWZhdWx0UGFyYW1zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlW107XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIGhpZGVGcm9tTGlzdD86IGJvb2xlYW47XG4gIGFsdGVybmF0aXZlc0tleT86IHN0cmluZztcbiAgLyoqIENhbiBiZSB1c2VkIHRvIGNvbnRyb2wgb3BlcmF0aW9uIHBsYWNlbWVudCB3aGVuIGFkZGluZyBhIG5ldyBvcGVyYXRpb25zLCBsb3dlciBhcmUgcGxhY2VkIGZpcnN0ICovXG4gIG9yZGVyUmFuaz86IG51bWJlcjtcbiAgcmVuZGVyZXI6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblJlbmRlcmVyO1xuICBhZGRPcGVyYXRpb25IYW5kbGVyOiBRdWVyeUJ1aWxkZXJBZGRPcGVyYXRpb25IYW5kbGVyPFQ+O1xuICBwYXJhbUNoYW5nZWRIYW5kbGVyPzogUXVlcnlCdWlsZGVyT25QYXJhbUNoYW5nZWRIYW5kbGVyO1xuICBleHBsYWluSGFuZGxlcj86IFF1ZXJ5QnVpbGRlckV4cGxhaW5PcGVyYXRpb25IYW5kbGVyO1xuICBjaGFuZ2VUeXBlSGFuZGxlcj86IChvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBuZXdEZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZjxUPikgPT4gUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xufVxuXG5leHBvcnQgdHlwZSBRdWVyeUJ1aWxkZXJBZGRPcGVyYXRpb25IYW5kbGVyPFQ+ID0gKFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgcXVlcnk6IFQsXG4gIG1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyXG4pID0+IFQ7XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlckV4cGxhaW5PcGVyYXRpb25IYW5kbGVyID0gKG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmKSA9PiBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlck9uUGFyYW1DaGFuZ2VkSGFuZGxlciA9IChcbiAgaW5kZXg6IG51bWJlcixcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIG9wZXJhdGlvbkRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmXG4pID0+IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUmVuZGVyZXIgPSAoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSA9PiBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWUgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuO1xuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmIHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiAnc3RyaW5nJyB8ICdudW1iZXInIHwgJ2Jvb2xlYW4nO1xuICBvcHRpb25zPzogc3RyaW5nW10gfCBudW1iZXJbXSB8IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+PjtcbiAgaGlkZU5hbWU/OiBib29sZWFuO1xuICByZXN0UGFyYW0/OiBib29sZWFuO1xuICBvcHRpb25hbD86IGJvb2xlYW47XG4gIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgbWluV2lkdGg/OiBudW1iZXI7XG4gIGVkaXRvcj86IENvbXBvbmVudFR5cGU8UXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcz47XG4gIHJ1blF1ZXJ5T25FbnRlcj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRWRpdG9yUHJvcHMge1xuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgcXVlcnk6IGFueTtcbiAgZGF0YXNvdXJjZTogRGF0YVNvdXJjZUFwaTtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikgPT4gdm9pZDtcbiAgb25SZW1vdmU6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMge1xuICB2YWx1ZT86IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWU7XG4gIHBhcmFtRGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZjtcbiAgLyoqIFBhcmFtZXRlciBpbmRleCAqL1xuICBpbmRleDogbnVtYmVyO1xuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcbiAgb3BlcmF0aW9uSW5kZXg6IG51bWJlcjtcbiAgcXVlcnk6IGFueTtcbiAgZGF0YXNvdXJjZTogRGF0YVNvdXJjZUFwaTtcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCB2YWx1ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSkgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGVudW0gUXVlcnlFZGl0b3JNb2RlIHtcbiAgQ29kZSA9ICdjb2RlJyxcbiAgQnVpbGRlciA9ICdidWlsZGVyJyxcbiAgRXhwbGFpbiA9ICdleHBsYWluJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaXN1YWxRdWVyeU1vZGVsbGVyIHtcbiAgZ2V0T3BlcmF0aW9uc0ZvckNhdGVnb3J5KGNhdGVnb3J5OiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXTtcbiAgZ2V0QWx0ZXJuYXRpdmVPcGVyYXRpb25zKGtleTogc3RyaW5nKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW107XG4gIGdldENhdGVnb3JpZXMoKTogc3RyaW5nW107XG4gIGdldE9wZXJhdGlvbkRlZihpZDogc3RyaW5nKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIHwgdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHsgVmlzdWFsUXVlcnlCaW5hcnkgfSBmcm9tICcuL3NoYXJlZC9Mb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gfSBmcm9tICcuL3NoYXJlZC90eXBlcyc7XG5cbi8qKlxuICogVmlzdWFsIHF1ZXJ5IG1vZGVsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVZpc3VhbFF1ZXJ5IHtcbiAgbWV0cmljOiBzdHJpbmc7XG4gIGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXTtcbiAgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW107XG4gIGJpbmFyeVF1ZXJpZXM/OiBQcm9tVmlzdWFsUXVlcnlCaW5hcnlbXTtcbn1cblxuZXhwb3J0IHR5cGUgUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5ID0gVmlzdWFsUXVlcnlCaW5hcnk8UHJvbVZpc3VhbFF1ZXJ5PjtcblxuZXhwb3J0IGVudW0gUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkge1xuICBBZ2dyZWdhdGlvbnMgPSAnQWdncmVnYXRpb25zJyxcbiAgUmFuZ2VGdW5jdGlvbnMgPSAnUmFuZ2UgZnVuY3Rpb25zJyxcbiAgRnVuY3Rpb25zID0gJ0Z1bmN0aW9ucycsXG4gIEJpbmFyeU9wcyA9ICdCaW5hcnkgb3BlcmF0aW9ucycsXG4gIFRyaWdvbm9tZXRyaWMgPSAnVHJpZ29ub21ldHJpYycsXG4gIFRpbWUgPSAnVGltZSBGdW5jdGlvbnMnLFxufVxuXG5leHBvcnQgZW51bSBQcm9tT3BlcmF0aW9uSWQge1xuICBBYnMgPSAnYWJzJyxcbiAgQWJzZW50ID0gJ2Fic2VudCcsXG4gIEFic2VudE92ZXJUaW1lID0gJ2Fic2VudF9vdmVyX3RpbWUnLFxuICBBY29zID0gJ2Fjb3MnLFxuICBBY29zaCA9ICdhY29zaCcsXG4gIEFzaW4gPSAnYXNpbicsXG4gIEFzaW5oID0gJ2FzaW5oJyxcbiAgQXRhbiA9ICdhdGFuJyxcbiAgQXRhbmggPSAnYXRhbmgnLFxuICBBdmcgPSAnYXZnJyxcbiAgQXZnT3ZlclRpbWUgPSAnYXZnX292ZXJfdGltZScsXG4gIEJvdHRvbUsgPSAnYm90dG9taycsXG4gIENlaWwgPSAnY2VpbCcsXG4gIENoYW5nZXMgPSAnY2hhbmdlcycsXG4gIENsYW1wID0gJ2NsYW1wJyxcbiAgQ2xhbXBNYXggPSAnY2xhbXBfbWF4JyxcbiAgQ2xhbXBNaW4gPSAnY2xhbXBfbWluJyxcbiAgQ29zID0gJ2NvcycsXG4gIENvc2ggPSAnY29zaCcsXG4gIENvdW50ID0gJ2NvdW50JyxcbiAgQ291bnRPdmVyVGltZSA9ICdjb3VudF9vdmVyX3RpbWUnLFxuICBDb3VudFNjYWxhciA9ICdjb3VudF9zY2FsYXInLFxuICBDb3VudFZhbHVlcyA9ICdjb3VudF92YWx1ZXMnLFxuICBEYXlPZk1vbnRoID0gJ2RheV9vZl9tb250aCcsXG4gIERheU9mV2VlayA9ICdkYXlfb2Zfd2VlaycsXG4gIERheXNJbk1vbnRoID0gJ2RheXNfaW5fbW9udGgnLFxuICBEZWcgPSAnZGVnJyxcbiAgRGVsdGEgPSAnZGVsdGEnLFxuICBEZXJpdiA9ICdkZXJpdicsXG4gIERyb3BDb21tb25MYWJlbHMgPSAnZHJvcF9jb21tb25fbGFiZWxzJyxcbiAgRXhwID0gJ2V4cCcsXG4gIEZsb29yID0gJ2Zsb29yJyxcbiAgR3JvdXAgPSAnZ3JvdXAnLFxuICBIaXN0b2dyYW1RdWFudGlsZSA9ICdoaXN0b2dyYW1fcXVhbnRpbGUnLFxuICBIb2x0V2ludGVycyA9ICdob2x0X3dpbnRlcnMnLFxuICBIb3VyID0gJ2hvdXInLFxuICBJZGVsdGEgPSAnaWRlbHRhJyxcbiAgSW5jcmVhc2UgPSAnaW5jcmVhc2UnLFxuICBJcmF0ZSA9ICdpcmF0ZScsXG4gIExhYmVsSm9pbiA9ICdsYWJlbF9qb2luJyxcbiAgTGFiZWxSZXBsYWNlID0gJ2xhYmVsX3JlcGxhY2UnLFxuICBMYXN0ID0gJ2xhc3QnLFxuICBMYXN0T3ZlclRpbWUgPSAnbGFzdF9vdmVyX3RpbWUnLFxuICBMbiA9ICdsbicsXG4gIExvZzEwID0gJ2xvZzEwJyxcbiAgTG9nMiA9ICdsb2cyJyxcbiAgTWF4ID0gJ21heCcsXG4gIE1heE92ZXJUaW1lID0gJ21heF9vdmVyX3RpbWUnLFxuICBNaW4gPSAnbWluJyxcbiAgTWluT3ZlclRpbWUgPSAnbWluX292ZXJfdGltZScsXG4gIE1pbnV0ZSA9ICdtaW51dGUnLFxuICBNb250aCA9ICdtb250aCcsXG4gIFBpID0gJ3BpJyxcbiAgUHJlZGljdExpbmVhciA9ICdwcmVkaWN0X2xpbmVhcicsXG4gIFByZXNlbnQgPSAncHJlc2VudCcsXG4gIFByZXNlbnRPdmVyVGltZSA9ICdwcmVzZW50X292ZXJfdGltZScsXG4gIFF1YW50aWxlID0gJ3F1YW50aWxlJyxcbiAgUXVhbnRpbGVPdmVyVGltZSA9ICdxdWFudGlsZV9vdmVyX3RpbWUnLFxuICBSYWQgPSAncmFkJyxcbiAgUmF0ZSA9ICdyYXRlJyxcbiAgUmVzZXRzID0gJ3Jlc2V0cycsXG4gIFJvdW5kID0gJ3JvdW5kJyxcbiAgU2NhbGFyID0gJ3NjYWxhcicsXG4gIFNnbiA9ICdzZ24nLFxuICBTaW4gPSAnc2luJyxcbiAgU2luaCA9ICdzaW5oJyxcbiAgU29ydCA9ICdzb3J0JyxcbiAgU29ydERlc2MgPSAnc29ydF9kZXNjJyxcbiAgU3FydCA9ICdzcXJ0JyxcbiAgU3RkZGV2ID0gJ3N0ZGRldicsXG4gIFN0ZGRldk92ZXJUaW1lID0gJ3N0ZGRldl9vdmVyX3RpbWUnLFxuICBTdW0gPSAnc3VtJyxcbiAgU3VtT3ZlclRpbWUgPSAnc3VtX292ZXJfdGltZScsXG4gIFRhbiA9ICd0YW4nLFxuICBUYW5oID0gJ3RhbmgnLFxuICBUaW1lID0gJ3RpbWUnLFxuICBUaW1lc3RhbXAgPSAndGltZXN0YW1wJyxcbiAgVG9wSyA9ICd0b3BrJyxcbiAgVmVjdG9yID0gJ3ZlY3RvcicsXG4gIFllYXIgPSAneWVhcicsXG4gIC8vIEJpbmFyeSBvcHNcbiAgQWRkaXRpb24gPSAnX19hZGRpdGlvbicsXG4gIFN1YnRyYWN0aW9uID0gJ19fc3VidHJhY3Rpb24nLFxuICBNdWx0aXBseUJ5ID0gJ19fbXVsdGlwbHlfYnknLFxuICBEaXZpZGVCeSA9ICdfX2RpdmlkZV9ieScsXG4gIE1vZHVsbyA9ICdfX21vZHVsbycsXG4gIEV4cG9uZW50ID0gJ19fZXhwb25lbnQnLFxuICBOZXN0ZWRRdWVyeSA9ICdfX25lc3RlZF9xdWVyeScsXG4gIEVxdWFsVG8gPSAnX19lcXVhbF90bycsXG4gIE5vdEVxdWFsVG8gPSAnX19ub3RfZXF1YWxfdG8nLFxuICBHcmVhdGVyVGhhbiA9ICdfX2dyZWF0ZXJfdGhhbicsXG4gIExlc3NUaGFuID0gJ19fbGVzc190aGFuJyxcbiAgR3JlYXRlck9yRXF1YWwgPSAnX19ncmVhdGVyX29yX2VxdWFsJyxcbiAgTGVzc09yRXF1YWwgPSAnX19sZXNzX29yX2VxdWFsJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tUXVlcnlQYXR0ZXJuIHtcbiAgbmFtZTogc3RyaW5nO1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbn1cbiIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlJztcbmltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVBvcHBlciB9IGZyb20gJ3JlYWN0LXBvcHBlcic7XG5cbmZ1bmN0aW9uIHVzZUdldExhdGVzdCh2YWwpIHtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZih2YWwpO1xuICByZWYuY3VycmVudCA9IHZhbDtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbn1cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkgey8vIGRvIG5vdGhpbmdcbn07XG5cbmZ1bmN0aW9uIHVzZUNvbnRyb2xsZWRTdGF0ZShfcmVmKSB7XG4gIHZhciBpbml0aWFsID0gX3JlZi5pbml0aWFsLFxuICAgICAgdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgICAgX3JlZiRvbkNoYW5nZSA9IF9yZWYub25DaGFuZ2UsXG4gICAgICBvbkNoYW5nZSA9IF9yZWYkb25DaGFuZ2UgPT09IHZvaWQgMCA/IG5vb3AgOiBfcmVmJG9uQ2hhbmdlO1xuXG4gIGlmIChpbml0aWFsID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VpdGhlciBcInZhbHVlXCIgb3IgXCJpbml0aWFsXCIgdmFyaWFibGUgbXVzdCBiZSBzZXQuIE5vdyBib3RoIGFyZSB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsKSxcbiAgICAgIHN0YXRlID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0U3RhdGUgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIGdldExhdGVzdCA9IHVzZUdldExhdGVzdChzdGF0ZSk7XG4gIHZhciBzZXQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodXBkYXRlcikge1xuICAgIHZhciBzdGF0ZSA9IGdldExhdGVzdCgpO1xuICAgIHZhciB1cGRhdGVkU3RhdGUgPSB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIoc3RhdGUpIDogdXBkYXRlcjtcbiAgICBpZiAodHlwZW9mIHVwZGF0ZWRTdGF0ZS5wZXJzaXN0ID09PSAnZnVuY3Rpb24nKSB1cGRhdGVkU3RhdGUucGVyc2lzdCgpO1xuICAgIHNldFN0YXRlKHVwZGF0ZWRTdGF0ZSk7XG4gICAgaWYgKHR5cGVvZiBvbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykgb25DaGFuZ2UodXBkYXRlZFN0YXRlKTtcbiAgfSwgW2dldExhdGVzdCwgb25DaGFuZ2VdKTtcbiAgdmFyIGlzQ29udHJvbGxlZCA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gIHJldHVybiBbaXNDb250cm9sbGVkID8gdmFsdWUgOiBzdGF0ZSwgaXNDb250cm9sbGVkID8gb25DaGFuZ2UgOiBzZXRdO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVCb3VuZGluZ0NsaWVudFJlY3QoeCwgeSkge1xuICBpZiAoeCA9PT0gdm9pZCAwKSB7XG4gICAgeCA9IDA7XG4gIH1cblxuICBpZiAoeSA9PT0gdm9pZCAwKSB7XG4gICAgeSA9IDA7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHRvcDogeSxcbiAgICAgIHJpZ2h0OiB4LFxuICAgICAgYm90dG9tOiB5LFxuICAgICAgbGVmdDogeCxcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJzdHlsZXNcIiwgXCJhdHRyaWJ1dGVzXCJdO1xudmFyIHZpcnR1YWxFbGVtZW50ID0ge1xuICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGdlbmVyYXRlQm91bmRpbmdDbGllbnRSZWN0KClcbn07XG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgY2xvc2VPbk91dHNpZGVDbGljazogdHJ1ZSxcbiAgY2xvc2VPblRyaWdnZXJIaWRkZW46IGZhbHNlLFxuICBkZWZhdWx0VmlzaWJsZTogZmFsc2UsXG4gIGRlbGF5SGlkZTogMCxcbiAgZGVsYXlTaG93OiAwLFxuICBmb2xsb3dDdXJzb3I6IGZhbHNlLFxuICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gIG11dGF0aW9uT2JzZXJ2ZXJPcHRpb25zOiB7XG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZVxuICB9LFxuICBvZmZzZXQ6IFswLCA2XSxcbiAgdHJpZ2dlcjogJ2hvdmVyJ1xufTtcbmZ1bmN0aW9uIHVzZVBvcHBlclRvb2x0aXAoY29uZmlnLCBwb3BwZXJPcHRpb25zKSB7XG4gIHZhciBfcG9wcGVyUHJvcHMkc3RhdGUsIF9wb3BwZXJQcm9wcyRzdGF0ZSRtbywgX3BvcHBlclByb3BzJHN0YXRlJG1vMjtcblxuICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIGlmIChwb3BwZXJPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBwb3BwZXJPcHRpb25zID0ge307XG4gIH1cblxuICAvLyBNZXJnaW5nIG9wdGlvbnMgd2l0aCBkZWZhdWx0IG9wdGlvbnMuXG4gIC8vIEtleXMgd2l0aCB1bmRlZmluZWQgdmFsdWVzIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBkZWZhdWx0IG9uZXMgaWYgYW55LlxuICAvLyBLZXlzIHdpdGggb3RoZXIgdmFsdWVzIHBhc3MgdGhyb3VnaC5cbiAgdmFyIGZpbmFsQ29uZmlnID0gT2JqZWN0LmtleXMoZGVmYXVsdENvbmZpZykucmVkdWNlKGZ1bmN0aW9uIChjb25maWcsIGtleSkge1xuICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbmZpZywgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJba2V5XSA9IGNvbmZpZ1trZXldICE9PSB1bmRlZmluZWQgPyBjb25maWdba2V5XSA6IGRlZmF1bHRDb25maWdba2V5XSwgX2V4dGVuZHMyKSk7XG4gIH0sIGNvbmZpZyk7XG4gIHZhciBkZWZhdWx0TW9kaWZpZXJzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgb2Zmc2V0OiBmaW5hbENvbmZpZy5vZmZzZXRcbiAgICAgIH1cbiAgICB9XTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBBcnJheS5pc0FycmF5KGZpbmFsQ29uZmlnLm9mZnNldCkgPyBmaW5hbENvbmZpZy5vZmZzZXQgOiBbXSk7XG5cbiAgdmFyIGZpbmFsUG9wcGVyT3B0aW9ucyA9IF9leHRlbmRzKHt9LCBwb3BwZXJPcHRpb25zLCB7XG4gICAgcGxhY2VtZW50OiBwb3BwZXJPcHRpb25zLnBsYWNlbWVudCB8fCBmaW5hbENvbmZpZy5wbGFjZW1lbnQsXG4gICAgbW9kaWZpZXJzOiBwb3BwZXJPcHRpb25zLm1vZGlmaWVycyB8fCBkZWZhdWx0TW9kaWZpZXJzXG4gIH0pO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShudWxsKSxcbiAgICAgIHRyaWdnZXJSZWYgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRUcmlnZ2VyUmVmID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUyID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICB0b29sdGlwUmVmID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldFRvb2x0aXBSZWYgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfdXNlQ29udHJvbGxlZFN0YXRlID0gdXNlQ29udHJvbGxlZFN0YXRlKHtcbiAgICBpbml0aWFsOiBmaW5hbENvbmZpZy5kZWZhdWx0VmlzaWJsZSxcbiAgICB2YWx1ZTogZmluYWxDb25maWcudmlzaWJsZSxcbiAgICBvbkNoYW5nZTogZmluYWxDb25maWcub25WaXNpYmxlQ2hhbmdlXG4gIH0pLFxuICAgICAgdmlzaWJsZSA9IF91c2VDb250cm9sbGVkU3RhdGVbMF0sXG4gICAgICBzZXRWaXNpYmxlID0gX3VzZUNvbnRyb2xsZWRTdGF0ZVsxXTtcblxuICB2YXIgdGltZXIgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aW1lci5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgdmFyIF91c2VQb3BwZXIgPSB1c2VQb3BwZXIoZmluYWxDb25maWcuZm9sbG93Q3Vyc29yID8gdmlydHVhbEVsZW1lbnQgOiB0cmlnZ2VyUmVmLCB0b29sdGlwUmVmLCBmaW5hbFBvcHBlck9wdGlvbnMpLFxuICAgICAgc3R5bGVzID0gX3VzZVBvcHBlci5zdHlsZXMsXG4gICAgICBhdHRyaWJ1dGVzID0gX3VzZVBvcHBlci5hdHRyaWJ1dGVzLFxuICAgICAgcG9wcGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdXNlUG9wcGVyLCBfZXhjbHVkZWQpO1xuXG4gIHZhciB1cGRhdGUgPSBwb3BwZXJQcm9wcy51cGRhdGU7XG4gIHZhciBnZXRMYXRlc3QgPSB1c2VHZXRMYXRlc3Qoe1xuICAgIHZpc2libGU6IHZpc2libGUsXG4gICAgdHJpZ2dlclJlZjogdHJpZ2dlclJlZixcbiAgICB0b29sdGlwUmVmOiB0b29sdGlwUmVmLFxuICAgIGZpbmFsQ29uZmlnOiBmaW5hbENvbmZpZ1xuICB9KTtcbiAgdmFyIGlzVHJpZ2dlcmVkQnkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodHJpZ2dlcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGZpbmFsQ29uZmlnLnRyaWdnZXIpID8gZmluYWxDb25maWcudHJpZ2dlci5pbmNsdWRlcyh0cmlnZ2VyKSA6IGZpbmFsQ29uZmlnLnRyaWdnZXIgPT09IHRyaWdnZXI7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgQXJyYXkuaXNBcnJheShmaW5hbENvbmZpZy50cmlnZ2VyKSA/IGZpbmFsQ29uZmlnLnRyaWdnZXIgOiBbZmluYWxDb25maWcudHJpZ2dlcl0pO1xuICB2YXIgaGlkZVRvb2x0aXAgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyLmN1cnJlbnQpO1xuICAgIHRpbWVyLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgZmluYWxDb25maWcuZGVsYXlIaWRlKTtcbiAgfSwgW2ZpbmFsQ29uZmlnLmRlbGF5SGlkZSwgc2V0VmlzaWJsZV0pO1xuICB2YXIgc2hvd1Rvb2x0aXAgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyLmN1cnJlbnQpO1xuICAgIHRpbWVyLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2V0VmlzaWJsZSh0cnVlKTtcbiAgICB9LCBmaW5hbENvbmZpZy5kZWxheVNob3cpO1xuICB9LCBbZmluYWxDb25maWcuZGVsYXlTaG93LCBzZXRWaXNpYmxlXSk7XG4gIHZhciB0b2dnbGVUb29sdGlwID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGlmIChnZXRMYXRlc3QoKS52aXNpYmxlKSB7XG4gICAgICBoaWRlVG9vbHRpcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG93VG9vbHRpcCgpO1xuICAgIH1cbiAgfSwgW2dldExhdGVzdCwgaGlkZVRvb2x0aXAsIHNob3dUb29sdGlwXSk7IC8vIEhhbmRsZSBjbGljayBvdXRzaWRlXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWdldExhdGVzdCgpLmZpbmFsQ29uZmlnLmNsb3NlT25PdXRzaWRlQ2xpY2spIHJldHVybjtcblxuICAgIHZhciBoYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiBoYW5kbGVDbGlja091dHNpZGUoZXZlbnQpIHtcbiAgICAgIHZhciBfZXZlbnQkY29tcG9zZWRQYXRoO1xuXG4gICAgICB2YXIgX2dldExhdGVzdCA9IGdldExhdGVzdCgpLFxuICAgICAgICAgIHRvb2x0aXBSZWYgPSBfZ2V0TGF0ZXN0LnRvb2x0aXBSZWYsXG4gICAgICAgICAgdHJpZ2dlclJlZiA9IF9nZXRMYXRlc3QudHJpZ2dlclJlZjtcblxuICAgICAgdmFyIHRhcmdldCA9IChldmVudC5jb21wb3NlZFBhdGggPT0gbnVsbCA/IHZvaWQgMCA6IChfZXZlbnQkY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCkpID09IG51bGwgPyB2b2lkIDAgOiBfZXZlbnQkY29tcG9zZWRQYXRoWzBdKSB8fCBldmVudC50YXJnZXQ7XG5cbiAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIGlmICh0b29sdGlwUmVmICE9IG51bGwgJiYgdHJpZ2dlclJlZiAhPSBudWxsICYmICF0b29sdGlwUmVmLmNvbnRhaW5zKHRhcmdldCkgJiYgIXRyaWdnZXJSZWYuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XG4gICAgfTtcbiAgfSwgW2dldExhdGVzdCwgaGlkZVRvb2x0aXBdKTsgLy8gVHJpZ2dlcjogY2xpY2tcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0cmlnZ2VyUmVmID09IG51bGwgfHwgIWlzVHJpZ2dlcmVkQnkoJ2NsaWNrJykpIHJldHVybjtcbiAgICB0cmlnZ2VyUmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdG9nZ2xlVG9vbHRpcCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdG9nZ2xlVG9vbHRpcCk7XG4gICAgfTtcbiAgfSwgW3RyaWdnZXJSZWYsIGlzVHJpZ2dlcmVkQnksIHRvZ2dsZVRvb2x0aXBdKTsgLy8gVHJpZ2dlcjogZG91YmxlLWNsaWNrXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHJpZ2dlclJlZiA9PSBudWxsIHx8ICFpc1RyaWdnZXJlZEJ5KCdkb3VibGUtY2xpY2snKSkgcmV0dXJuO1xuICAgIHRyaWdnZXJSZWYuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0b2dnbGVUb29sdGlwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0b2dnbGVUb29sdGlwKTtcbiAgICB9O1xuICB9LCBbdHJpZ2dlclJlZiwgaXNUcmlnZ2VyZWRCeSwgdG9nZ2xlVG9vbHRpcF0pOyAvLyBUcmlnZ2VyOiByaWdodC1jbGlja1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRyaWdnZXJSZWYgPT0gbnVsbCB8fCAhaXNUcmlnZ2VyZWRCeSgncmlnaHQtY2xpY2snKSkgcmV0dXJuO1xuXG4gICAgdmFyIHByZXZlbnREZWZhdWx0QW5kVG9nZ2xlID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHRBbmRUb2dnbGUoZXZlbnQpIHtcbiAgICAgIC8vIERvbid0IHNob3cgdGhlIGNvbnRleHQgbWVudVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRvZ2dsZVRvb2x0aXAoKTtcbiAgICB9O1xuXG4gICAgdHJpZ2dlclJlZi5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0QW5kVG9nZ2xlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdEFuZFRvZ2dsZSk7XG4gICAgfTtcbiAgfSwgW3RyaWdnZXJSZWYsIGlzVHJpZ2dlcmVkQnksIHRvZ2dsZVRvb2x0aXBdKTsgLy8gVHJpZ2dlcjogZm9jdXNcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0cmlnZ2VyUmVmID09IG51bGwgfHwgIWlzVHJpZ2dlcmVkQnkoJ2ZvY3VzJykpIHJldHVybjtcbiAgICB0cmlnZ2VyUmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgc2hvd1Rvb2x0aXApO1xuICAgIHRyaWdnZXJSZWYuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhpZGVUb29sdGlwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdHJpZ2dlclJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHNob3dUb29sdGlwKTtcbiAgICAgIHRyaWdnZXJSZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhpZGVUb29sdGlwKTtcbiAgICB9O1xuICB9LCBbdHJpZ2dlclJlZiwgaXNUcmlnZ2VyZWRCeSwgc2hvd1Rvb2x0aXAsIGhpZGVUb29sdGlwXSk7IC8vIFRyaWdnZXI6IGhvdmVyIG9uIHRyaWdnZXJcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0cmlnZ2VyUmVmID09IG51bGwgfHwgIWlzVHJpZ2dlcmVkQnkoJ2hvdmVyJykpIHJldHVybjtcbiAgICB0cmlnZ2VyUmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBzaG93VG9vbHRpcCk7XG4gICAgdHJpZ2dlclJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgaGlkZVRvb2x0aXApO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmlnZ2VyUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBzaG93VG9vbHRpcCk7XG4gICAgICB0cmlnZ2VyUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBoaWRlVG9vbHRpcCk7XG4gICAgfTtcbiAgfSwgW3RyaWdnZXJSZWYsIGlzVHJpZ2dlcmVkQnksIHNob3dUb29sdGlwLCBoaWRlVG9vbHRpcF0pOyAvLyBUcmlnZ2VyOiBob3ZlciBvbiB0b29sdGlwLCBrZWVwIGl0IG9wZW4gaWYgaG92ZXJlZFxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRvb2x0aXBSZWYgPT0gbnVsbCB8fCAhZ2V0TGF0ZXN0KCkuZmluYWxDb25maWcuaW50ZXJhY3RpdmUpIHJldHVybjtcbiAgICB0b29sdGlwUmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBzaG93VG9vbHRpcCk7XG4gICAgdG9vbHRpcFJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgaGlkZVRvb2x0aXApO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB0b29sdGlwUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBzaG93VG9vbHRpcCk7XG4gICAgICB0b29sdGlwUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBoaWRlVG9vbHRpcCk7XG4gICAgfTtcbiAgfSwgW3Rvb2x0aXBSZWYsIHNob3dUb29sdGlwLCBoaWRlVG9vbHRpcCwgZ2V0TGF0ZXN0XSk7IC8vIEhhbmRsZSBjbG9zaW5nIHRvb2x0aXAgaWYgdHJpZ2dlciBoaWRkZW5cblxuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBwb3BwZXJQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogKF9wb3BwZXJQcm9wcyRzdGF0ZSA9IHBvcHBlclByb3BzLnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogKF9wb3BwZXJQcm9wcyRzdGF0ZSRtbyA9IF9wb3BwZXJQcm9wcyRzdGF0ZS5tb2RpZmllcnNEYXRhKSA9PSBudWxsID8gdm9pZCAwIDogKF9wb3BwZXJQcm9wcyRzdGF0ZSRtbzIgPSBfcG9wcGVyUHJvcHMkc3RhdGUkbW8uaGlkZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wb3BwZXJQcm9wcyRzdGF0ZSRtbzIuaXNSZWZlcmVuY2VIaWRkZW47XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZpbmFsQ29uZmlnLmNsb3NlT25UcmlnZ2VySGlkZGVuICYmIGlzUmVmZXJlbmNlSGlkZGVuKSBoaWRlVG9vbHRpcCgpO1xuICB9LCBbZmluYWxDb25maWcuY2xvc2VPblRyaWdnZXJIaWRkZW4sIGhpZGVUb29sdGlwLCBpc1JlZmVyZW5jZUhpZGRlbl0pOyAvLyBIYW5kbGUgZm9sbG93IGN1cnNvclxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFmaW5hbENvbmZpZy5mb2xsb3dDdXJzb3IgfHwgdHJpZ2dlclJlZiA9PSBudWxsKSByZXR1cm47XG5cbiAgICBmdW5jdGlvbiBzZXRNb3VzZVBvc2l0aW9uKF9yZWYpIHtcbiAgICAgIHZhciBjbGllbnRYID0gX3JlZi5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmLmNsaWVudFk7XG4gICAgICB2aXJ0dWFsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBnZW5lcmF0ZUJvdW5kaW5nQ2xpZW50UmVjdChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgIHVwZGF0ZSA9PSBudWxsID8gdm9pZCAwIDogdXBkYXRlKCk7XG4gICAgfVxuXG4gICAgdHJpZ2dlclJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzZXRNb3VzZVBvc2l0aW9uKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc2V0TW91c2VQb3NpdGlvbik7XG4gICAgfTtcbiAgfSwgW2ZpbmFsQ29uZmlnLmZvbGxvd0N1cnNvciwgdHJpZ2dlclJlZiwgdXBkYXRlXSk7IC8vIEhhbmRsZSB0b29sdGlwIERPTSBtdXRhdGlvbiBjaGFuZ2VzIChha2EgbXV0YXRpb24gb2JzZXJ2ZXIpXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodG9vbHRpcFJlZiA9PSBudWxsIHx8IHVwZGF0ZSA9PSBudWxsIHx8IGZpbmFsQ29uZmlnLm11dGF0aW9uT2JzZXJ2ZXJPcHRpb25zID09IG51bGwpIHJldHVybjtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih1cGRhdGUpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodG9vbHRpcFJlZiwgZmluYWxDb25maWcubXV0YXRpb25PYnNlcnZlck9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtmaW5hbENvbmZpZy5tdXRhdGlvbk9ic2VydmVyT3B0aW9ucywgdG9vbHRpcFJlZiwgdXBkYXRlXSk7IC8vIFRvb2x0aXAgcHJvcHMgZ2V0dGVyXG5cbiAgdmFyIGdldFRvb2x0aXBQcm9wcyA9IGZ1bmN0aW9uIGdldFRvb2x0aXBQcm9wcyhhcmdzKSB7XG4gICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkge1xuICAgICAgYXJncyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYXJncywge1xuICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBhcmdzLnN0eWxlLCBzdHlsZXMucG9wcGVyKVxuICAgIH0sIGF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgICAnZGF0YS1wb3BwZXItaW50ZXJhY3RpdmUnOiBmaW5hbENvbmZpZy5pbnRlcmFjdGl2ZVxuICAgIH0pO1xuICB9OyAvLyBBcnJvdyBwcm9wcyBnZXR0ZXJcblxuXG4gIHZhciBnZXRBcnJvd1Byb3BzID0gZnVuY3Rpb24gZ2V0QXJyb3dQcm9wcyhhcmdzKSB7XG4gICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkge1xuICAgICAgYXJncyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYXJncywgYXR0cmlidXRlcy5hcnJvdywge1xuICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBhcmdzLnN0eWxlLCBzdHlsZXMuYXJyb3cpLFxuICAgICAgJ2RhdGEtcG9wcGVyLWFycm93JzogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgZ2V0QXJyb3dQcm9wczogZ2V0QXJyb3dQcm9wcyxcbiAgICBnZXRUb29sdGlwUHJvcHM6IGdldFRvb2x0aXBQcm9wcyxcbiAgICBzZXRUb29sdGlwUmVmOiBzZXRUb29sdGlwUmVmLFxuICAgIHNldFRyaWdnZXJSZWY6IHNldFRyaWdnZXJSZWYsXG4gICAgdG9vbHRpcFJlZjogdG9vbHRpcFJlZixcbiAgICB0cmlnZ2VyUmVmOiB0cmlnZ2VyUmVmLFxuICAgIHZpc2libGU6IHZpc2libGVcbiAgfSwgcG9wcGVyUHJvcHMpO1xufVxuXG5leHBvcnQgeyB1c2VQb3BwZXJUb29sdGlwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1wb3BwZXItdG9vbHRpcC5qcy5tYXBcbiIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlUHJldmlvdXMoc3RhdGUpIHtcbiAgICB2YXIgcmVmID0gdXNlUmVmKCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBzdGF0ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG4iLCJjb25zdCBwZXJmID1cbiAgdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJlxuICBwZXJmb3JtYW5jZSAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nXG4gICAgPyBwZXJmb3JtYW5jZVxuICAgIDogRGF0ZVxuXG5jb25zdCBoYXNBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSAnZnVuY3Rpb24nXG5cbi8vIG1pbmltYWwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgcG9seWZpbGxcbi8vIHRoaXMgZG9lc24ndCBoYXZlIG5lYXJseSBhbGwgdGhlIGNoZWNrcyBhbmQgd2hhdG5vdCB0aGF0XG4vLyBhY3R1YWwgQWJvcnRDb250cm9sbGVyL1NpZ25hbCBoYXMsIGJ1dCBpdCdzIGVub3VnaCBmb3Jcbi8vIG91ciBwdXJwb3NlcywgYW5kIGlmIHVzZWQgcHJvcGVybHksIGJlaGF2ZXMgdGhlIHNhbWUuXG5jb25zdCBBQyA9IGhhc0Fib3J0Q29udHJvbGxlclxuICA/IEFib3J0Q29udHJvbGxlclxuICA6IGNsYXNzIEFib3J0Q29udHJvbGxlciB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaWduYWwgPSBuZXcgQVMoKVxuICAgICAgfVxuICAgICAgYWJvcnQoKSB7XG4gICAgICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQoJ2Fib3J0JylcbiAgICAgIH1cbiAgICB9XG5cbmNvbnN0IEFTID0gaGFzQWJvcnRDb250cm9sbGVyXG4gID8gQWJvcnRTaWduYWxcbiAgOiBjbGFzcyBBYm9ydFNpZ25hbCB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hYm9ydGVkID0gZmFsc2VcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW11cbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoRXZlbnQodHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2Fib3J0Jykge1xuICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWVcbiAgICAgICAgICBjb25zdCBlID0geyB0eXBlLCB0YXJnZXQ6IHRoaXMgfVxuICAgICAgICAgIHRoaXMub25hYm9ydChlKVxuICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGYgPT4gZihlKSwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25hYm9ydCgpIHt9XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGV2LCBmbikge1xuICAgICAgICBpZiAoZXYgPT09ICdhYm9ydCcpIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChmbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgZm4pIHtcbiAgICAgICAgaWYgKGV2ID09PSAnYWJvcnQnKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmZpbHRlcihmID0+IGYgIT09IGZuKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG5jb25zdCB3YXJuZWQgPSBuZXcgU2V0KClcbmNvbnN0IGRlcHJlY2F0ZWRPcHRpb24gPSAob3B0LCBpbnN0ZWFkKSA9PiB7XG4gIGNvbnN0IGNvZGUgPSBgTFJVX0NBQ0hFX09QVElPTl8ke29wdH1gXG4gIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgd2Fybihjb2RlLCBgJHtvcHR9IG9wdGlvbmAsIGBvcHRpb25zLiR7aW5zdGVhZH1gLCBMUlVDYWNoZSlcbiAgfVxufVxuY29uc3QgZGVwcmVjYXRlZE1ldGhvZCA9IChtZXRob2QsIGluc3RlYWQpID0+IHtcbiAgY29uc3QgY29kZSA9IGBMUlVfQ0FDSEVfTUVUSE9EXyR7bWV0aG9kfWBcbiAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICBjb25zdCB7IHByb3RvdHlwZSB9ID0gTFJVQ2FjaGVcbiAgICBjb25zdCB7IGdldCB9ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIG1ldGhvZClcbiAgICB3YXJuKGNvZGUsIGAke21ldGhvZH0gbWV0aG9kYCwgYGNhY2hlLiR7aW5zdGVhZH0oKWAsIGdldClcbiAgfVxufVxuY29uc3QgZGVwcmVjYXRlZFByb3BlcnR5ID0gKGZpZWxkLCBpbnN0ZWFkKSA9PiB7XG4gIGNvbnN0IGNvZGUgPSBgTFJVX0NBQ0hFX1BST1BFUlRZXyR7ZmllbGR9YFxuICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgIGNvbnN0IHsgcHJvdG90eXBlIH0gPSBMUlVDYWNoZVxuICAgIGNvbnN0IHsgZ2V0IH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgZmllbGQpXG4gICAgd2Fybihjb2RlLCBgJHtmaWVsZH0gcHJvcGVydHlgLCBgY2FjaGUuJHtpbnN0ZWFkfWAsIGdldClcbiAgfVxufVxuXG5jb25zdCBlbWl0V2FybmluZyA9ICguLi5hKSA9PiB7XG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzICYmXG4gIHR5cGVvZiBwcm9jZXNzLmVtaXRXYXJuaW5nID09PSAnZnVuY3Rpb24nXG4gICAgPyBwcm9jZXNzLmVtaXRXYXJuaW5nKC4uLmEpXG4gICAgOiBjb25zb2xlLmVycm9yKC4uLmEpXG59XG5cbmNvbnN0IHNob3VsZFdhcm4gPSBjb2RlID0+ICF3YXJuZWQuaGFzKGNvZGUpXG5cbmNvbnN0IHdhcm4gPSAoY29kZSwgd2hhdCwgaW5zdGVhZCwgZm4pID0+IHtcbiAgd2FybmVkLmFkZChjb2RlKVxuICBjb25zdCBtc2cgPSBgVGhlICR7d2hhdH0gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAke2luc3RlYWR9IGluc3RlYWQuYFxuICBlbWl0V2FybmluZyhtc2csICdEZXByZWNhdGlvbldhcm5pbmcnLCBjb2RlLCBmbilcbn1cblxuY29uc3QgaXNQb3NJbnQgPSBuID0+IG4gJiYgbiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID4gMCAmJiBpc0Zpbml0ZShuKVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFRoaXMgaXMgYSBsaXR0bGUgYml0IHJpZGljdWxvdXMsIHRiaC5cbiAqIFRoZSBtYXhpbXVtIGFycmF5IGxlbmd0aCBpcyAyXjMyLTEgb3IgdGhlcmVhYm91dHMgb24gbW9zdCBKUyBpbXBscy5cbiAqIEFuZCB3ZWxsIGJlZm9yZSB0aGF0IHBvaW50LCB5b3UncmUgY2FjaGluZyB0aGUgZW50aXJlIHdvcmxkLCBJIG1lYW4sXG4gKiB0aGF0J3MgfjMyR0Igb2YganVzdCBpbnRlZ2VycyBmb3IgdGhlIG5leHQvcHJldiBsaW5rcywgcGx1cyB3aGF0ZXZlclxuICogZWxzZSB0byBob2xkIHRoYXQgbWFueSBrZXlzIGFuZCB2YWx1ZXMuICBKdXN0IGZpbGxpbmcgdGhlIG1lbW9yeSB3aXRoXG4gKiB6ZXJvZXMgYXQgaW5pdCB0aW1lIGlzIGJydXRhbCB3aGVuIHlvdSBnZXQgdGhhdCBiaWcuXG4gKiBCdXQgd2h5IG5vdCBiZSBjb21wbGV0ZT9cbiAqIE1heWJlIGluIHRoZSBmdXR1cmUsIHRoZXNlIGxpbWl0cyB3aWxsIGhhdmUgZXhwYW5kZWQuICovXG5jb25zdCBnZXRVaW50QXJyYXkgPSBtYXggPT5cbiAgIWlzUG9zSW50KG1heClcbiAgICA/IG51bGxcbiAgICA6IG1heCA8PSBNYXRoLnBvdygyLCA4KVxuICAgID8gVWludDhBcnJheVxuICAgIDogbWF4IDw9IE1hdGgucG93KDIsIDE2KVxuICAgID8gVWludDE2QXJyYXlcbiAgICA6IG1heCA8PSBNYXRoLnBvdygyLCAzMilcbiAgICA/IFVpbnQzMkFycmF5XG4gICAgOiBtYXggPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICA/IFplcm9BcnJheVxuICAgIDogbnVsbFxuXG5jbGFzcyBaZXJvQXJyYXkgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICBzdXBlcihzaXplKVxuICAgIHRoaXMuZmlsbCgwKVxuICB9XG59XG5cbmNsYXNzIFN0YWNrIHtcbiAgY29uc3RydWN0b3IobWF4KSB7XG4gICAgaWYgKG1heCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICAgIGNvbnN0IFVpbnRBcnJheSA9IGdldFVpbnRBcnJheShtYXgpXG4gICAgdGhpcy5oZWFwID0gbmV3IFVpbnRBcnJheShtYXgpXG4gICAgdGhpcy5sZW5ndGggPSAwXG4gIH1cbiAgcHVzaChuKSB7XG4gICAgdGhpcy5oZWFwW3RoaXMubGVuZ3RoKytdID0gblxuICB9XG4gIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFwWy0tdGhpcy5sZW5ndGhdXG4gIH1cbn1cblxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXggPSAwLFxuICAgICAgdHRsLFxuICAgICAgdHRsUmVzb2x1dGlvbiA9IDEsXG4gICAgICB0dGxBdXRvcHVyZ2UsXG4gICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgIHVwZGF0ZUFnZU9uSGFzLFxuICAgICAgYWxsb3dTdGFsZSxcbiAgICAgIGRpc3Bvc2UsXG4gICAgICBkaXNwb3NlQWZ0ZXIsXG4gICAgICBub0Rpc3Bvc2VPblNldCxcbiAgICAgIG5vVXBkYXRlVFRMLFxuICAgICAgbWF4U2l6ZSA9IDAsXG4gICAgICBzaXplQ2FsY3VsYXRpb24sXG4gICAgICBmZXRjaE1ldGhvZCxcbiAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbixcbiAgICB9ID0gb3B0aW9uc1xuXG4gICAgLy8gZGVwcmVjYXRlZCBvcHRpb25zLCBkb24ndCB0cmlnZ2VyIGEgd2FybmluZyBmb3IgZ2V0dGluZyB0aGVtIGlmXG4gICAgLy8gdGhlIHRoaW5nIGJlaW5nIHBhc3NlZCBpbiBpcyBhbm90aGVyIExSVUNhY2hlIHdlJ3JlIGNvcHlpbmcuXG4gICAgY29uc3QgeyBsZW5ndGgsIG1heEFnZSwgc3RhbGUgfSA9XG4gICAgICBvcHRpb25zIGluc3RhbmNlb2YgTFJVQ2FjaGUgPyB7fSA6IG9wdGlvbnNcblxuICAgIGlmIChtYXggIT09IDAgJiYgIWlzUG9zSW50KG1heCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBvcHRpb24gbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKVxuICAgIH1cblxuICAgIGNvbnN0IFVpbnRBcnJheSA9IG1heCA/IGdldFVpbnRBcnJheShtYXgpIDogQXJyYXlcbiAgICBpZiAoIVVpbnRBcnJheSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1heCB2YWx1ZTogJyArIG1heClcbiAgICB9XG5cbiAgICB0aGlzLm1heCA9IG1heFxuICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemVcbiAgICB0aGlzLnNpemVDYWxjdWxhdGlvbiA9IHNpemVDYWxjdWxhdGlvbiB8fCBsZW5ndGhcbiAgICBpZiAodGhpcy5zaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgIGlmICghdGhpcy5tYXhTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ2Nhbm5vdCBzZXQgc2l6ZUNhbGN1bGF0aW9uIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2l6ZUNhbGN1bGF0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiBzZXQgdG8gbm9uLWZ1bmN0aW9uJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZldGNoTWV0aG9kID0gZmV0Y2hNZXRob2QgfHwgbnVsbFxuICAgIGlmICh0aGlzLmZldGNoTWV0aG9kICYmIHR5cGVvZiB0aGlzLmZldGNoTWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnZmV0Y2hNZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHNwZWNpZmllZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKVxuICAgIHRoaXMua2V5TGlzdCA9IG5ldyBBcnJheShtYXgpLmZpbGwobnVsbClcbiAgICB0aGlzLnZhbExpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKG51bGwpXG4gICAgdGhpcy5uZXh0ID0gbmV3IFVpbnRBcnJheShtYXgpXG4gICAgdGhpcy5wcmV2ID0gbmV3IFVpbnRBcnJheShtYXgpXG4gICAgdGhpcy5oZWFkID0gMFxuICAgIHRoaXMudGFpbCA9IDBcbiAgICB0aGlzLmZyZWUgPSBuZXcgU3RhY2sobWF4KVxuICAgIHRoaXMuaW5pdGlhbEZpbGwgPSAxXG4gICAgdGhpcy5zaXplID0gMFxuXG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmRpc3Bvc2UgPSBkaXNwb3NlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGlzcG9zZUFmdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VBZnRlciA9IGRpc3Bvc2VBZnRlclxuICAgICAgdGhpcy5kaXNwb3NlZCA9IFtdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcG9zZUFmdGVyID0gbnVsbFxuICAgICAgdGhpcy5kaXNwb3NlZCA9IG51bGxcbiAgICB9XG4gICAgdGhpcy5ub0Rpc3Bvc2VPblNldCA9ICEhbm9EaXNwb3NlT25TZXRcbiAgICB0aGlzLm5vVXBkYXRlVFRMID0gISFub1VwZGF0ZVRUTFxuICAgIHRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uID0gISFub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb25cblxuICAgIGlmICh0aGlzLm1heFNpemUgIT09IDApIHtcbiAgICAgIGlmICghaXNQb3NJbnQodGhpcy5tYXhTaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdtYXhTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCdcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgdGhpcy5pbml0aWFsaXplU2l6ZVRyYWNraW5nKClcbiAgICB9XG5cbiAgICB0aGlzLmFsbG93U3RhbGUgPSAhIWFsbG93U3RhbGUgfHwgISFzdGFsZVxuICAgIHRoaXMudXBkYXRlQWdlT25HZXQgPSAhIXVwZGF0ZUFnZU9uR2V0XG4gICAgdGhpcy51cGRhdGVBZ2VPbkhhcyA9ICEhdXBkYXRlQWdlT25IYXNcbiAgICB0aGlzLnR0bFJlc29sdXRpb24gPVxuICAgICAgaXNQb3NJbnQodHRsUmVzb2x1dGlvbikgfHwgdHRsUmVzb2x1dGlvbiA9PT0gMFxuICAgICAgICA/IHR0bFJlc29sdXRpb25cbiAgICAgICAgOiAxXG4gICAgdGhpcy50dGxBdXRvcHVyZ2UgPSAhIXR0bEF1dG9wdXJnZVxuICAgIHRoaXMudHRsID0gdHRsIHx8IG1heEFnZSB8fCAwXG4gICAgaWYgKHRoaXMudHRsKSB7XG4gICAgICBpZiAoIWlzUG9zSW50KHRoaXMudHRsKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICd0dGwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgICB0aGlzLmluaXRpYWxpemVUVExUcmFja2luZygpXG4gICAgfVxuXG4gICAgLy8gZG8gbm90IGFsbG93IGNvbXBsZXRlbHkgdW5ib3VuZGVkIGNhY2hlc1xuICAgIGlmICh0aGlzLm1heCA9PT0gMCAmJiB0aGlzLnR0bCA9PT0gMCAmJiB0aGlzLm1heFNpemUgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdBdCBsZWFzdCBvbmUgb2YgbWF4LCBtYXhTaXplLCBvciB0dGwgaXMgcmVxdWlyZWQnXG4gICAgICApXG4gICAgfVxuICAgIGlmICghdGhpcy50dGxBdXRvcHVyZ2UgJiYgIXRoaXMubWF4ICYmICF0aGlzLm1heFNpemUpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSAnTFJVX0NBQ0hFX1VOQk9VTkRFRCdcbiAgICAgIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgICAgIHdhcm5lZC5hZGQoY29kZSlcbiAgICAgICAgY29uc3QgbXNnID1cbiAgICAgICAgICAnVFRMIGNhY2hpbmcgd2l0aG91dCB0dGxBdXRvcHVyZ2UsIG1heCwgb3IgbWF4U2l6ZSBjYW4gJyArXG4gICAgICAgICAgJ3Jlc3VsdCBpbiB1bmJvdW5kZWQgbWVtb3J5IGNvbnN1bXB0aW9uLidcbiAgICAgICAgZW1pdFdhcm5pbmcobXNnLCAnVW5ib3VuZGVkQ2FjaGVXYXJuaW5nJywgY29kZSwgTFJVQ2FjaGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YWxlKSB7XG4gICAgICBkZXByZWNhdGVkT3B0aW9uKCdzdGFsZScsICdhbGxvd1N0YWxlJylcbiAgICB9XG4gICAgaWYgKG1heEFnZSkge1xuICAgICAgZGVwcmVjYXRlZE9wdGlvbignbWF4QWdlJywgJ3R0bCcpXG4gICAgfVxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGRlcHJlY2F0ZWRPcHRpb24oJ2xlbmd0aCcsICdzaXplQ2FsY3VsYXRpb24nKVxuICAgIH1cbiAgfVxuXG4gIGdldFJlbWFpbmluZ1RUTChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoa2V5LCB7IHVwZGF0ZUFnZU9uSGFzOiBmYWxzZSB9KSA/IEluZmluaXR5IDogMFxuICB9XG5cbiAgaW5pdGlhbGl6ZVRUTFRyYWNraW5nKCkge1xuICAgIHRoaXMudHRscyA9IG5ldyBaZXJvQXJyYXkodGhpcy5tYXgpXG4gICAgdGhpcy5zdGFydHMgPSBuZXcgWmVyb0FycmF5KHRoaXMubWF4KVxuXG4gICAgdGhpcy5zZXRJdGVtVFRMID0gKGluZGV4LCB0dGwpID0+IHtcbiAgICAgIHRoaXMuc3RhcnRzW2luZGV4XSA9IHR0bCAhPT0gMCA/IHBlcmYubm93KCkgOiAwXG4gICAgICB0aGlzLnR0bHNbaW5kZXhdID0gdHRsXG4gICAgICBpZiAodHRsICE9PSAwICYmIHRoaXMudHRsQXV0b3B1cmdlKSB7XG4gICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5pc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUodGhpcy5rZXlMaXN0W2luZGV4XSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHR0bCArIDEpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gdW5yZWYoKSBub3Qgc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMgKi9cbiAgICAgICAgaWYgKHQudW5yZWYpIHtcbiAgICAgICAgICB0LnVucmVmKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlSXRlbUFnZSA9IGluZGV4ID0+IHtcbiAgICAgIHRoaXMuc3RhcnRzW2luZGV4XSA9IHRoaXMudHRsc1tpbmRleF0gIT09IDAgPyBwZXJmLm5vdygpIDogMFxuICAgIH1cblxuICAgIC8vIGRlYm91bmNlIGNhbGxzIHRvIHBlcmYubm93KCkgdG8gMXMgc28gd2UncmUgbm90IGhpdHRpbmdcbiAgICAvLyB0aGF0IGNvc3RseSBjYWxsIHJlcGVhdGVkbHkuXG4gICAgbGV0IGNhY2hlZE5vdyA9IDBcbiAgICBjb25zdCBnZXROb3cgPSAoKSA9PiB7XG4gICAgICBjb25zdCBuID0gcGVyZi5ub3coKVxuICAgICAgaWYgKHRoaXMudHRsUmVzb2x1dGlvbiA+IDApIHtcbiAgICAgICAgY2FjaGVkTm93ID0gblxuICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dChcbiAgICAgICAgICAoKSA9PiAoY2FjaGVkTm93ID0gMCksXG4gICAgICAgICAgdGhpcy50dGxSZXNvbHV0aW9uXG4gICAgICAgIClcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBub3QgYXZhaWxhYmxlIG9uIGFsbCBwbGF0Zm9ybXMgKi9cbiAgICAgICAgaWYgKHQudW5yZWYpIHtcbiAgICAgICAgICB0LnVucmVmKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5cbiAgICB9XG5cbiAgICB0aGlzLmdldFJlbWFpbmluZ1RUTCA9IGtleSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrZXkpXG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudHRsc1tpbmRleF0gPT09IDAgfHwgdGhpcy5zdGFydHNbaW5kZXhdID09PSAwXG4gICAgICAgID8gSW5maW5pdHlcbiAgICAgICAgOiB0aGlzLnN0YXJ0c1tpbmRleF0gK1xuICAgICAgICAgICAgdGhpcy50dGxzW2luZGV4XSAtXG4gICAgICAgICAgICAoY2FjaGVkTm93IHx8IGdldE5vdygpKVxuICAgIH1cblxuICAgIHRoaXMuaXNTdGFsZSA9IGluZGV4ID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudHRsc1tpbmRleF0gIT09IDAgJiZcbiAgICAgICAgdGhpcy5zdGFydHNbaW5kZXhdICE9PSAwICYmXG4gICAgICAgIChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpIC0gdGhpcy5zdGFydHNbaW5kZXhdID5cbiAgICAgICAgICB0aGlzLnR0bHNbaW5kZXhdXG4gICAgICApXG4gICAgfVxuICB9XG4gIHVwZGF0ZUl0ZW1BZ2UoaW5kZXgpIHt9XG4gIHNldEl0ZW1UVEwoaW5kZXgsIHR0bCkge31cbiAgaXNTdGFsZShpbmRleCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaW5pdGlhbGl6ZVNpemVUcmFja2luZygpIHtcbiAgICB0aGlzLmNhbGN1bGF0ZWRTaXplID0gMFxuICAgIHRoaXMuc2l6ZXMgPSBuZXcgWmVyb0FycmF5KHRoaXMubWF4KVxuICAgIHRoaXMucmVtb3ZlSXRlbVNpemUgPSBpbmRleCA9PlxuICAgICAgKHRoaXMuY2FsY3VsYXRlZFNpemUgLT0gdGhpcy5zaXplc1tpbmRleF0pXG4gICAgdGhpcy5yZXF1aXJlU2l6ZSA9IChrLCB2LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pID0+IHtcbiAgICAgIGlmICghaXNQb3NJbnQoc2l6ZSkpIHtcbiAgICAgICAgaWYgKHNpemVDYWxjdWxhdGlvbikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc2l6ZUNhbGN1bGF0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICAgICAgICB9XG4gICAgICAgICAgc2l6ZSA9IHNpemVDYWxjdWxhdGlvbih2LCBrKVxuICAgICAgICAgIGlmICghaXNQb3NJbnQoc2l6ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICdzaXplQ2FsY3VsYXRpb24gcmV0dXJuIGludmFsaWQgKGV4cGVjdCBwb3NpdGl2ZSBpbnRlZ2VyKSdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdpbnZhbGlkIHNpemUgdmFsdWUgKG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlciknXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2l6ZVxuICAgIH1cbiAgICB0aGlzLmFkZEl0ZW1TaXplID0gKGluZGV4LCB2LCBrLCBzaXplKSA9PiB7XG4gICAgICB0aGlzLnNpemVzW2luZGV4XSA9IHNpemVcbiAgICAgIGNvbnN0IG1heFNpemUgPSB0aGlzLm1heFNpemUgLSB0aGlzLnNpemVzW2luZGV4XVxuICAgICAgd2hpbGUgKHRoaXMuY2FsY3VsYXRlZFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIHRoaXMuZXZpY3QodHJ1ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY3VsYXRlZFNpemUgKz0gdGhpcy5zaXplc1tpbmRleF1cbiAgICB9XG4gIH1cbiAgcmVtb3ZlSXRlbVNpemUoaW5kZXgpIHt9XG4gIGFkZEl0ZW1TaXplKGluZGV4LCB2LCBrLCBzaXplKSB7fVxuICByZXF1aXJlU2l6ZShrLCB2LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pIHtcbiAgICBpZiAoc2l6ZSB8fCBzaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdjYW5ub3Qgc2V0IHNpemUgd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb24gY2FjaGUnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgKmluZGV4ZXMoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnRhaWw7IHRydWU7ICkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy5pc1N0YWxlKGkpKSB7XG4gICAgICAgICAgeWllbGQgaVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkgPSB0aGlzLnByZXZbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICpyaW5kZXhlcyh7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhZDsgdHJ1ZTsgKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd1N0YWxlIHx8ICF0aGlzLmlzU3RhbGUoaSkpIHtcbiAgICAgICAgICB5aWVsZCBpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IHRoaXMudGFpbCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSA9IHRoaXMubmV4dFtpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNWYWxpZEluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMua2V5TWFwLmdldCh0aGlzLmtleUxpc3RbaW5kZXhdKSA9PT0gaW5kZXhcbiAgfVxuXG4gICplbnRyaWVzKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgW3RoaXMua2V5TGlzdFtpXSwgdGhpcy52YWxMaXN0W2ldXVxuICAgIH1cbiAgfVxuICAqcmVudHJpZXMoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgW3RoaXMua2V5TGlzdFtpXSwgdGhpcy52YWxMaXN0W2ldXVxuICAgIH1cbiAgfVxuXG4gICprZXlzKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgdGhpcy5rZXlMaXN0W2ldXG4gICAgfVxuICB9XG4gICpya2V5cygpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5yaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCB0aGlzLmtleUxpc3RbaV1cbiAgICB9XG4gIH1cblxuICAqdmFsdWVzKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgdGhpcy52YWxMaXN0W2ldXG4gICAgfVxuICB9XG4gICpydmFsdWVzKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKCkpIHtcbiAgICAgIHlpZWxkIHRoaXMudmFsTGlzdFtpXVxuICAgIH1cbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKVxuICB9XG5cbiAgZmluZChmbiwgZ2V0T3B0aW9ucyA9IHt9KSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICBpZiAoZm4odGhpcy52YWxMaXN0W2ldLCB0aGlzLmtleUxpc3RbaV0sIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLmtleUxpc3RbaV0sIGdldE9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yRWFjaChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICBmbi5jYWxsKHRoaXNwLCB0aGlzLnZhbExpc3RbaV0sIHRoaXMua2V5TGlzdFtpXSwgdGhpcylcbiAgICB9XG4gIH1cblxuICByZm9yRWFjaChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgZm4uY2FsbCh0aGlzcCwgdGhpcy52YWxMaXN0W2ldLCB0aGlzLmtleUxpc3RbaV0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgZ2V0IHBydW5lKCkge1xuICAgIGRlcHJlY2F0ZWRNZXRob2QoJ3BydW5lJywgJ3B1cmdlU3RhbGUnKVxuICAgIHJldHVybiB0aGlzLnB1cmdlU3RhbGVcbiAgfVxuXG4gIHB1cmdlU3RhbGUoKSB7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZVxuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgaWYgKHRoaXMuaXNTdGFsZShpKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZSh0aGlzLmtleUxpc3RbaV0pXG4gICAgICAgIGRlbGV0ZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWxldGVkXG4gIH1cblxuICBkdW1wKCkge1xuICAgIGNvbnN0IGFyciA9IFtdXG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmtleUxpc3RbaV1cbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWxMaXN0W2ldXG4gICAgICBjb25zdCBlbnRyeSA9IHsgdmFsdWUgfVxuICAgICAgaWYgKHRoaXMudHRscykge1xuICAgICAgICBlbnRyeS50dGwgPSB0aGlzLnR0bHNbaV1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpemVzKSB7XG4gICAgICAgIGVudHJ5LnNpemUgPSB0aGlzLnNpemVzW2ldXG4gICAgICB9XG4gICAgICBhcnIudW5zaGlmdChba2V5LCBlbnRyeV0pXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGxvYWQoYXJyKSB7XG4gICAgdGhpcy5jbGVhcigpXG4gICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgYXJyKSB7XG4gICAgICB0aGlzLnNldChrZXksIGVudHJ5LnZhbHVlLCBlbnRyeSlcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKHYsIGssIHJlYXNvbikge31cblxuICBzZXQoXG4gICAgayxcbiAgICB2LFxuICAgIHtcbiAgICAgIHR0bCA9IHRoaXMudHRsLFxuICAgICAgbm9EaXNwb3NlT25TZXQgPSB0aGlzLm5vRGlzcG9zZU9uU2V0LFxuICAgICAgc2l6ZSA9IDAsXG4gICAgICBzaXplQ2FsY3VsYXRpb24gPSB0aGlzLnNpemVDYWxjdWxhdGlvbixcbiAgICAgIG5vVXBkYXRlVFRMID0gdGhpcy5ub1VwZGF0ZVRUTCxcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc2l6ZSA9IHRoaXMucmVxdWlyZVNpemUoaywgdiwgc2l6ZSwgc2l6ZUNhbGN1bGF0aW9uKVxuICAgIGxldCBpbmRleCA9IHRoaXMuc2l6ZSA9PT0gMCA/IHVuZGVmaW5lZCA6IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhZGRpdGlvblxuICAgICAgaW5kZXggPSB0aGlzLm5ld0luZGV4KClcbiAgICAgIHRoaXMua2V5TGlzdFtpbmRleF0gPSBrXG4gICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gdlxuICAgICAgdGhpcy5rZXlNYXAuc2V0KGssIGluZGV4KVxuICAgICAgdGhpcy5uZXh0W3RoaXMudGFpbF0gPSBpbmRleFxuICAgICAgdGhpcy5wcmV2W2luZGV4XSA9IHRoaXMudGFpbFxuICAgICAgdGhpcy50YWlsID0gaW5kZXhcbiAgICAgIHRoaXMuc2l6ZSsrXG4gICAgICB0aGlzLmFkZEl0ZW1TaXplKGluZGV4LCB2LCBrLCBzaXplKVxuICAgICAgbm9VcGRhdGVUVEwgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVcbiAgICAgIGNvbnN0IG9sZFZhbCA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIGlmICh2ICE9PSBvbGRWYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2gob2xkVmFsKSkge1xuICAgICAgICAgIG9sZFZhbC5fX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFub0Rpc3Bvc2VPblNldCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKG9sZFZhbCwgaywgJ3NldCcpXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlZC5wdXNoKFtvbGRWYWwsIGssICdzZXQnXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtU2l6ZShpbmRleClcbiAgICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHZcbiAgICAgICAgdGhpcy5hZGRJdGVtU2l6ZShpbmRleCwgdiwgaywgc2l6ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMubW92ZVRvVGFpbChpbmRleClcbiAgICB9XG4gICAgaWYgKHR0bCAhPT0gMCAmJiB0aGlzLnR0bCA9PT0gMCAmJiAhdGhpcy50dGxzKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVUVExUcmFja2luZygpXG4gICAgfVxuICAgIGlmICghbm9VcGRhdGVUVEwpIHtcbiAgICAgIHRoaXMuc2V0SXRlbVRUTChpbmRleCwgdHRsKVxuICAgIH1cbiAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgIHdoaWxlICh0aGlzLmRpc3Bvc2VkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VBZnRlciguLi50aGlzLmRpc3Bvc2VkLnNoaWZ0KCkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBuZXdJbmRleCgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWlsXG4gICAgfVxuICAgIGlmICh0aGlzLnNpemUgPT09IHRoaXMubWF4ICYmIHRoaXMubWF4ICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmljdChmYWxzZSlcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJlZS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmZyZWUucG9wKClcbiAgICB9XG4gICAgLy8gaW5pdGlhbCBmaWxsLCBqdXN0IGtlZXAgd3JpdGluZyBkb3duIHRoZSBsaXN0XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbEZpbGwrK1xuICB9XG5cbiAgcG9wKCkge1xuICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMudmFsTGlzdFt0aGlzLmhlYWRdXG4gICAgICB0aGlzLmV2aWN0KHRydWUpXG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICB9XG5cbiAgZXZpY3QoZnJlZSkge1xuICAgIGNvbnN0IGhlYWQgPSB0aGlzLmhlYWRcbiAgICBjb25zdCBrID0gdGhpcy5rZXlMaXN0W2hlYWRdXG4gICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtoZWFkXVxuICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwb3NlKHYsIGssICdldmljdCcpXG4gICAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlZC5wdXNoKFt2LCBrLCAnZXZpY3QnXSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW1vdmVJdGVtU2l6ZShoZWFkKVxuICAgIC8vIGlmIHdlIGFyZW4ndCBhYm91dCB0byB1c2UgdGhlIGluZGV4LCB0aGVuIG51bGwgdGhlc2Ugb3V0XG4gICAgaWYgKGZyZWUpIHtcbiAgICAgIHRoaXMua2V5TGlzdFtoZWFkXSA9IG51bGxcbiAgICAgIHRoaXMudmFsTGlzdFtoZWFkXSA9IG51bGxcbiAgICAgIHRoaXMuZnJlZS5wdXNoKGhlYWQpXG4gICAgfVxuICAgIHRoaXMuaGVhZCA9IHRoaXMubmV4dFtoZWFkXVxuICAgIHRoaXMua2V5TWFwLmRlbGV0ZShrKVxuICAgIHRoaXMuc2l6ZS0tXG4gICAgcmV0dXJuIGhlYWRcbiAgfVxuXG4gIGhhcyhrLCB7IHVwZGF0ZUFnZU9uSGFzID0gdGhpcy51cGRhdGVBZ2VPbkhhcyB9ID0ge30pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXRoaXMuaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgaWYgKHVwZGF0ZUFnZU9uSGFzKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVJdGVtQWdlKGluZGV4KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gbGlrZSBnZXQoKSwgYnV0IHdpdGhvdXQgYW55IExSVSB1cGRhdGluZyBvciBUVEwgZXhwaXJhdGlvblxuICBwZWVrKGssIHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIChhbGxvd1N0YWxlIHx8ICF0aGlzLmlzU3RhbGUoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICB9XG4gIH1cblxuICBiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB2ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgcmV0dXJuIHZcbiAgICB9XG4gICAgY29uc3QgYWMgPSBuZXcgQUMoKVxuICAgIGNvbnN0IGZldGNoT3B0cyA9IHtcbiAgICAgIHNpZ25hbDogYWMuc2lnbmFsLFxuICAgICAgb3B0aW9ucyxcbiAgICB9XG4gICAgY29uc3QgY2IgPSB2ID0+IHtcbiAgICAgIGlmICghYWMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdiwgZmV0Y2hPcHRzLm9wdGlvbnMpXG4gICAgICB9XG4gICAgICByZXR1cm4gdlxuICAgIH1cbiAgICBjb25zdCBlYiA9IGVyID0+IHtcbiAgICAgIGlmICh0aGlzLnZhbExpc3RbaW5kZXhdID09PSBwKSB7XG4gICAgICAgIGNvbnN0IGRlbCA9XG4gICAgICAgICAgIW9wdGlvbnMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uIHx8XG4gICAgICAgICAgcC5fX3N0YWxlV2hpbGVGZXRjaGluZyA9PT0gdW5kZWZpbmVkXG4gICAgICAgIGlmIChkZWwpIHtcbiAgICAgICAgICB0aGlzLmRlbGV0ZShrKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN0aWxsIHJlcGxhY2UgdGhlICpwcm9taXNlKiB3aXRoIHRoZSBzdGFsZSB2YWx1ZSxcbiAgICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBwcm9taXNlIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHAuX19yZXR1cm5lZCA9PT0gcCkge1xuICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwY2FsbCA9IHJlcyA9PiByZXModGhpcy5mZXRjaE1ldGhvZChrLCB2LCBmZXRjaE9wdHMpKVxuICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZShwY2FsbCkudGhlbihjYiwgZWIpXG4gICAgcC5fX2Fib3J0Q29udHJvbGxlciA9IGFjXG4gICAgcC5fX3N0YWxlV2hpbGVGZXRjaGluZyA9IHZcbiAgICBwLl9fcmV0dXJuZWQgPSBudWxsXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0KGssIHAsIGZldGNoT3B0cy5vcHRpb25zKVxuICAgICAgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHBcbiAgICB9XG4gICAgcmV0dXJuIHBcbiAgfVxuXG4gIGlzQmFja2dyb3VuZEZldGNoKHApIHtcbiAgICByZXR1cm4gKFxuICAgICAgcCAmJlxuICAgICAgdHlwZW9mIHAgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICAgIHAsXG4gICAgICAgICdfX3N0YWxlV2hpbGVGZXRjaGluZydcbiAgICAgICkgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwLCAnX19yZXR1cm5lZCcpICYmXG4gICAgICAocC5fX3JldHVybmVkID09PSBwIHx8IHAuX19yZXR1cm5lZCA9PT0gbnVsbClcbiAgICApXG4gIH1cblxuICAvLyB0aGlzIHRha2VzIHRoZSB1bmlvbiBvZiBnZXQoKSBhbmQgc2V0KCkgb3B0cywgYmVjYXVzZSBpdCBkb2VzIGJvdGhcbiAgYXN5bmMgZmV0Y2goXG4gICAgayxcbiAgICB7XG4gICAgICAvLyBnZXQgb3B0aW9uc1xuICAgICAgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSxcbiAgICAgIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCxcbiAgICAgIC8vIHNldCBvcHRpb25zXG4gICAgICB0dGwgPSB0aGlzLnR0bCxcbiAgICAgIG5vRGlzcG9zZU9uU2V0ID0gdGhpcy5ub0Rpc3Bvc2VPblNldCxcbiAgICAgIHNpemUgPSAwLFxuICAgICAgc2l6ZUNhbGN1bGF0aW9uID0gdGhpcy5zaXplQ2FsY3VsYXRpb24sXG4gICAgICBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwsXG4gICAgICAvLyBmZXRjaCBleGNsdXNpdmUgb3B0aW9uc1xuICAgICAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uID0gdGhpcy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24sXG4gICAgfSA9IHt9XG4gICkge1xuICAgIGlmICghdGhpcy5mZXRjaE1ldGhvZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGssIHsgYWxsb3dTdGFsZSwgdXBkYXRlQWdlT25HZXQgfSlcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgYWxsb3dTdGFsZSxcbiAgICAgIHVwZGF0ZUFnZU9uR2V0LFxuICAgICAgdHRsLFxuICAgICAgbm9EaXNwb3NlT25TZXQsXG4gICAgICBzaXplLFxuICAgICAgc2l6ZUNhbGN1bGF0aW9uLFxuICAgICAgbm9VcGRhdGVUVEwsXG4gICAgICBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24sXG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLmJhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucylcbiAgICAgIHJldHVybiAocC5fX3JldHVybmVkID0gcClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gY2FjaGUsIG1heWJlIGFscmVhZHkgZmV0Y2hpbmdcbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSAmJiB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICA6ICh2Ll9fcmV0dXJuZWQgPSB2KVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG9UYWlsKGluZGV4KVxuICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1BZ2UoaW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZcbiAgICAgIH1cblxuICAgICAgLy8gb2ssIGl0IGlzIHN0YWxlLCBhbmQgbm90IGFscmVhZHkgZmV0Y2hpbmdcbiAgICAgIC8vIHJlZnJlc2ggdGhlIGNhY2hlLlxuICAgICAgY29uc3QgcCA9IHRoaXMuYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zKVxuICAgICAgcmV0dXJuIGFsbG93U3RhbGUgJiYgcC5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcC5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICA6IChwLl9fcmV0dXJuZWQgPSBwKVxuICAgIH1cbiAgfVxuXG4gIGdldChcbiAgICBrLFxuICAgIHtcbiAgICAgIGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsXG4gICAgICB1cGRhdGVBZ2VPbkdldCA9IHRoaXMudXBkYXRlQWdlT25HZXQsXG4gICAgfSA9IHt9XG4gICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgY29uc3QgZmV0Y2hpbmcgPSB0aGlzLmlzQmFja2dyb3VuZEZldGNoKHZhbHVlKVxuICAgICAgaWYgKHRoaXMuaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgLy8gZGVsZXRlIG9ubHkgaWYgbm90IGFuIGluLWZsaWdodCBiYWNrZ3JvdW5kIGZldGNoXG4gICAgICAgIGlmICghZmV0Y2hpbmcpIHtcbiAgICAgICAgICB0aGlzLmRlbGV0ZShrKVxuICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUgOiB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSA/IHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIGN1cnJlbnRseSBmZXRjaGluZyBpdCwgd2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSBpdCB5ZXRcbiAgICAgICAgLy8gaXQncyBub3Qgc3RhbGUsIHdoaWNoIG1lYW5zIHRoaXMgaXNuJ3QgYSBzdGFsZVdoaWxlUmVmZXRjaGluZyxcbiAgICAgICAgLy8gc28gd2UganVzdCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmIChmZXRjaGluZykge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmVUb1RhaWwoaW5kZXgpXG4gICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlSXRlbUFnZShpbmRleClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25uZWN0KHAsIG4pIHtcbiAgICB0aGlzLnByZXZbbl0gPSBwXG4gICAgdGhpcy5uZXh0W3BdID0gblxuICB9XG5cbiAgbW92ZVRvVGFpbChpbmRleCkge1xuICAgIC8vIGlmIHRhaWwgYWxyZWFkeSwgbm90aGluZyB0byBkb1xuICAgIC8vIGlmIGhlYWQsIG1vdmUgaGVhZCB0byBuZXh0W2luZGV4XVxuICAgIC8vIGVsc2VcbiAgICAvLyAgIG1vdmUgbmV4dFtwcmV2W2luZGV4XV0gdG8gbmV4dFtpbmRleF0gKGhlYWQgaGFzIG5vIHByZXYpXG4gICAgLy8gICBtb3ZlIHByZXZbbmV4dFtpbmRleF1dIHRvIHByZXZbaW5kZXhdXG4gICAgLy8gcHJldltpbmRleF0gPSB0YWlsXG4gICAgLy8gbmV4dFt0YWlsXSA9IGluZGV4XG4gICAgLy8gdGFpbCA9IGluZGV4XG4gICAgaWYgKGluZGV4ICE9PSB0aGlzLnRhaWwpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMubmV4dFtpbmRleF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLnByZXZbaW5kZXhdLCB0aGlzLm5leHRbaW5kZXhdKVxuICAgICAgfVxuICAgICAgdGhpcy5jb25uZWN0KHRoaXMudGFpbCwgaW5kZXgpXG4gICAgICB0aGlzLnRhaWwgPSBpbmRleFxuICAgIH1cbiAgfVxuXG4gIGdldCBkZWwoKSB7XG4gICAgZGVwcmVjYXRlZE1ldGhvZCgnZGVsJywgJ2RlbGV0ZScpXG4gICAgcmV0dXJuIHRoaXMuZGVsZXRlXG4gIH1cblxuICBkZWxldGUoaykge1xuICAgIGxldCBkZWxldGVkID0gZmFsc2VcbiAgICBpZiAodGhpcy5zaXplICE9PSAwKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlZCA9IHRydWVcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuY2xlYXIoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbVNpemUoaW5kZXgpXG4gICAgICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSh2LCBrLCAnZGVsZXRlJylcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW3YsIGssICdkZWxldGUnXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5rZXlNYXAuZGVsZXRlKGspXG4gICAgICAgICAgdGhpcy5rZXlMaXN0W2luZGV4XSA9IG51bGxcbiAgICAgICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gbnVsbFxuICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy50YWlsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnByZXZbaW5kZXhdXG4gICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLm5leHRbaW5kZXhdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFt0aGlzLnByZXZbaW5kZXhdXSA9IHRoaXMubmV4dFtpbmRleF1cbiAgICAgICAgICAgIHRoaXMucHJldlt0aGlzLm5leHRbaW5kZXhdXSA9IHRoaXMucHJldltpbmRleF1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zaXplLS1cbiAgICAgICAgICB0aGlzLmZyZWUucHVzaChpbmRleClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgd2hpbGUgKHRoaXMuZGlzcG9zZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFmdGVyKC4uLnRoaXMuZGlzcG9zZWQuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlbGV0ZWRcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGhpcy5yaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLmtleUxpc3RbaW5kZXhdXG4gICAgICAgIHRoaXMuZGlzcG9zZSh2LCBrLCAnZGVsZXRlJylcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlZC5wdXNoKFt2LCBrLCAnZGVsZXRlJ10pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmtleU1hcC5jbGVhcigpXG4gICAgdGhpcy52YWxMaXN0LmZpbGwobnVsbClcbiAgICB0aGlzLmtleUxpc3QuZmlsbChudWxsKVxuICAgIGlmICh0aGlzLnR0bHMpIHtcbiAgICAgIHRoaXMudHRscy5maWxsKDApXG4gICAgICB0aGlzLnN0YXJ0cy5maWxsKDApXG4gICAgfVxuICAgIGlmICh0aGlzLnNpemVzKSB7XG4gICAgICB0aGlzLnNpemVzLmZpbGwoMClcbiAgICB9XG4gICAgdGhpcy5oZWFkID0gMFxuICAgIHRoaXMudGFpbCA9IDBcbiAgICB0aGlzLmluaXRpYWxGaWxsID0gMVxuICAgIHRoaXMuZnJlZS5sZW5ndGggPSAwXG4gICAgdGhpcy5jYWxjdWxhdGVkU2l6ZSA9IDBcbiAgICB0aGlzLnNpemUgPSAwXG4gICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgIHdoaWxlICh0aGlzLmRpc3Bvc2VkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VBZnRlciguLi50aGlzLmRpc3Bvc2VkLnNoaWZ0KCkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IHJlc2V0KCkge1xuICAgIGRlcHJlY2F0ZWRNZXRob2QoJ3Jlc2V0JywgJ2NsZWFyJylcbiAgICByZXR1cm4gdGhpcy5jbGVhclxuICB9XG5cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICBkZXByZWNhdGVkUHJvcGVydHkoJ2xlbmd0aCcsICdzaXplJylcbiAgICByZXR1cm4gdGhpcy5zaXplXG4gIH1cblxuICBzdGF0aWMgZ2V0IEFib3J0Q29udHJvbGxlcigpIHtcbiAgICByZXR1cm4gQUNcbiAgfVxuICBzdGF0aWMgZ2V0IEFib3J0U2lnbmFsKCkge1xuICAgIHJldHVybiBBU1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFN1YmplY3QsIEFub255bW91c1N1YmplY3QgfSBmcm9tICcuLi8uLi9TdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi8uLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uLy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0IH0gZnJvbSAnLi4vLi4vUmVwbGF5U3ViamVjdCc7XG52YXIgREVGQVVMVF9XRUJTT0NLRVRfQ09ORklHID0ge1xuICAgIHVybDogJycsXG4gICAgZGVzZXJpYWxpemVyOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gSlNPTi5wYXJzZShlLmRhdGEpOyB9LFxuICAgIHNlcmlhbGl6ZXI6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpOyB9LFxufTtcbnZhciBXRUJTT0NLRVRTVUJKRUNUX0lOVkFMSURfRVJST1JfT0JKRUNUID0gJ1dlYlNvY2tldFN1YmplY3QuZXJyb3IgbXVzdCBiZSBjYWxsZWQgd2l0aCBhbiBvYmplY3Qgd2l0aCBhbiBlcnJvciBjb2RlLCBhbmQgYW4gb3B0aW9uYWwgcmVhc29uOiB7IGNvZGU6IG51bWJlciwgcmVhc29uOiBzdHJpbmcgfSc7XG52YXIgV2ViU29ja2V0U3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdlYlNvY2tldFN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2ViU29ja2V0U3ViamVjdCh1cmxDb25maWdPclNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3NvY2tldCA9IG51bGw7XG4gICAgICAgIGlmICh1cmxDb25maWdPclNvdXJjZSBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgICAgICBfdGhpcy5zb3VyY2UgPSB1cmxDb25maWdPclNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSAoX3RoaXMuX2NvbmZpZyA9IF9fYXNzaWduKHt9LCBERUZBVUxUX1dFQlNPQ0tFVF9DT05GSUcpKTtcbiAgICAgICAgICAgIF90aGlzLl9vdXRwdXQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmxDb25maWdPclNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25maWcudXJsID0gdXJsQ29uZmlnT3JTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdXJsQ29uZmlnT3JTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybENvbmZpZ09yU291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ1trZXldID0gdXJsQ29uZmlnT3JTb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29uZmlnLldlYlNvY2tldEN0b3IgJiYgV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLldlYlNvY2tldEN0b3IgPSBXZWJTb2NrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY29uZmlnLldlYlNvY2tldEN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFdlYlNvY2tldCBjb25zdHJ1Y3RvciBjYW4gYmUgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gbmV3IFJlcGxheVN1YmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIHNvY2sgPSBuZXcgV2ViU29ja2V0U3ViamVjdCh0aGlzLl9jb25maWcsIHRoaXMuZGVzdGluYXRpb24pO1xuICAgICAgICBzb2NrLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHNvY2suc291cmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNvY2s7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRTdWJqZWN0LnByb3RvdHlwZS5fcmVzZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBSZXBsYXlTdWJqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3V0cHV0ID0gbmV3IFN1YmplY3QoKTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLm11bHRpcGxleCA9IGZ1bmN0aW9uIChzdWJNc2csIHVuc3ViTXNnLCBtZXNzYWdlRmlsdGVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZWxmLm5leHQoc3ViTXNnKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc2VsZi5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZUZpbHRlcih4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIG9ic2VydmVyLmVycm9yKGVycik7IH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLmNvbXBsZXRlKCk7IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5uZXh0KHVuc3ViTXNnKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRTdWJqZWN0LnByb3RvdHlwZS5fY29ubmVjdFNvY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fY29uZmlnLCBXZWJTb2NrZXRDdG9yID0gX2EuV2ViU29ja2V0Q3RvciwgcHJvdG9jb2wgPSBfYS5wcm90b2NvbCwgdXJsID0gX2EudXJsLCBiaW5hcnlUeXBlID0gX2EuYmluYXJ5VHlwZTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5fb3V0cHV0O1xuICAgICAgICB2YXIgc29ja2V0ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvY2tldCA9IHByb3RvY29sID8gbmV3IFdlYlNvY2tldEN0b3IodXJsLCBwcm90b2NvbCkgOiBuZXcgV2ViU29ja2V0Q3Rvcih1cmwpO1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuICAgICAgICAgICAgaWYgKGJpbmFyeVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb2NrZXQuYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9zb2NrZXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNvY2tldCAmJiBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIHZhciBfc29ja2V0ID0gX3RoaXMuX3NvY2tldDtcbiAgICAgICAgICAgIGlmICghX3NvY2tldCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wZW5PYnNlcnZlciA9IF90aGlzLl9jb25maWcub3Blbk9ic2VydmVyO1xuICAgICAgICAgICAgaWYgKG9wZW5PYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIG9wZW5PYnNlcnZlci5uZXh0KGV2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcXVldWUgPSBfdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gU3Vic2NyaWJlci5jcmVhdGUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVyID0gX3RoaXMuX2NvbmZpZy5zZXJpYWxpemVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc2VyaWFsaXplcih4KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBjbG9zaW5nT2JzZXJ2ZXIgPSBfdGhpcy5fY29uZmlnLmNsb3NpbmdPYnNlcnZlcjtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2luZ09ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NpbmdPYnNlcnZlci5uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKGVyci5jb2RlLCBlcnIucmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKG5ldyBUeXBlRXJyb3IoV0VCU09DS0VUU1VCSkVDVF9JTlZBTElEX0VSUk9SX09CSkVDVCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjbG9zaW5nT2JzZXJ2ZXIgPSBfdGhpcy5fY29uZmlnLmNsb3NpbmdPYnNlcnZlcjtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2luZ09ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NpbmdPYnNlcnZlci5uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChxdWV1ZSAmJiBxdWV1ZSBpbnN0YW5jZW9mIFJlcGxheVN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uYWRkKHF1ZXVlLnN1YnNjcmliZShfdGhpcy5kZXN0aW5hdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5vbmNsb3NlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQgPT09IF90aGlzLl9zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsb3NlT2JzZXJ2ZXIgPSBfdGhpcy5fY29uZmlnLmNsb3NlT2JzZXJ2ZXI7XG4gICAgICAgICAgICBpZiAoY2xvc2VPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIGNsb3NlT2JzZXJ2ZXIubmV4dChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2VyaWFsaXplciA9IF90aGlzLl9jb25maWcuZGVzZXJpYWxpemVyO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZGVzZXJpYWxpemVyKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgV2ViU29ja2V0U3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RTb2NrZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vdXRwdXQuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICBzdWJzY3JpYmVyLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3NvY2tldCA9IF90aGlzLl9zb2NrZXQ7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX291dHB1dC5vYnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9zb2NrZXQgJiYgKF9zb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSB8fCBfc29ja2V0LnJlYWR5U3RhdGUgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH07XG4gICAgV2ViU29ja2V0U3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfc29ja2V0ID0gdGhpcy5fc29ja2V0O1xuICAgICAgICBpZiAoX3NvY2tldCAmJiAoX3NvY2tldC5yZWFkeVN0YXRlID09PSAxIHx8IF9zb2NrZXQucmVhZHlTdGF0ZSA9PT0gMCkpIHtcbiAgICAgICAgICAgIF9zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBXZWJTb2NrZXRTdWJqZWN0O1xufShBbm9ueW1vdXNTdWJqZWN0KSk7XG5leHBvcnQgeyBXZWJTb2NrZXRTdWJqZWN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJTb2NrZXRTdWJqZWN0LmpzLm1hcCIsImltcG9ydCB7IFdlYlNvY2tldFN1YmplY3QgfSBmcm9tICcuL1dlYlNvY2tldFN1YmplY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIHdlYlNvY2tldCh1cmxDb25maWdPclNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgV2ViU29ja2V0U3ViamVjdCh1cmxDb25maWdPclNvdXJjZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJTb2NrZXQuanMubWFwIiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgdmFyIHY7XG4gIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7IiwiLy8gQWRhcHRlZCBmcm9tIENocmlzIFZlbmVzcycgU0hBMSBjb2RlIGF0XG4vLyBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL3NoYTEuaHRtbFxuZnVuY3Rpb24gZihzLCB4LCB5LCB6KSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB4ICYgeSBeIH54ICYgejtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4geCAmIHkgXiB4ICYgeiBeIHkgJiB6O1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgfVxufVxuXG5mdW5jdGlvbiBST1RMKHgsIG4pIHtcbiAgcmV0dXJuIHggPDwgbiB8IHggPj4+IDMyIC0gbjtcbn1cblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICB2YXIgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgdmFyIEggPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF07XG5cbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzLnB1c2gobXNnLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICAvLyBDb252ZXJ0IEFycmF5LWxpa2UgdG8gQXJyYXlcbiAgICBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzKTtcbiAgfVxuXG4gIGJ5dGVzLnB1c2goMHg4MCk7XG4gIHZhciBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIHZhciBOID0gTWF0aC5jZWlsKGwgLyAxNik7XG4gIHZhciBNID0gbmV3IEFycmF5KE4pO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBOOyArK19pKSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50MzJBcnJheSgxNik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIGFycltqXSA9IGJ5dGVzW19pICogNjQgKyBqICogNF0gPDwgMjQgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAxXSA8PCAxNiB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAzXTtcbiAgICB9XG5cbiAgICBNW19pXSA9IGFycjtcbiAgfVxuXG4gIE1bTiAtIDFdWzE0XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggLyBNYXRoLnBvdygyLCAzMik7XG4gIE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgTVtOIC0gMV1bMTVdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAmIDB4ZmZmZmZmZmY7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgTjsgKytfaTIpIHtcbiAgICB2YXIgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgIFdbdF0gPSBNW19pMl1bdF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX3QgPSAxNjsgX3QgPCA4MDsgKytfdCkge1xuICAgICAgV1tfdF0gPSBST1RMKFdbX3QgLSAzXSBeIFdbX3QgLSA4XSBeIFdbX3QgLSAxNF0gXiBXW190IC0gMTZdLCAxKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IEhbMF07XG4gICAgdmFyIGIgPSBIWzFdO1xuICAgIHZhciBjID0gSFsyXTtcbiAgICB2YXIgZCA9IEhbM107XG4gICAgdmFyIGUgPSBIWzRdO1xuXG4gICAgZm9yICh2YXIgX3QyID0gMDsgX3QyIDwgODA7ICsrX3QyKSB7XG4gICAgICB2YXIgcyA9IE1hdGguZmxvb3IoX3QyIC8gMjApO1xuICAgICAgdmFyIFQgPSBST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1tfdDJdID4+PiAwO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBST1RMKGIsIDMwKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IFQ7XG4gICAgfVxuXG4gICAgSFswXSA9IEhbMF0gKyBhID4+PiAwO1xuICAgIEhbMV0gPSBIWzFdICsgYiA+Pj4gMDtcbiAgICBIWzJdID0gSFsyXSArIGMgPj4+IDA7XG4gICAgSFszXSA9IEhbM10gKyBkID4+PiAwO1xuICAgIEhbNF0gPSBIWzRdICsgZSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiBbSFswXSA+PiAyNCAmIDB4ZmYsIEhbMF0gPj4gMTYgJiAweGZmLCBIWzBdID4+IDggJiAweGZmLCBIWzBdICYgMHhmZiwgSFsxXSA+PiAyNCAmIDB4ZmYsIEhbMV0gPj4gMTYgJiAweGZmLCBIWzFdID4+IDggJiAweGZmLCBIWzFdICYgMHhmZiwgSFsyXSA+PiAyNCAmIDB4ZmYsIEhbMl0gPj4gMTYgJiAweGZmLCBIWzJdID4+IDggJiAweGZmLCBIWzJdICYgMHhmZiwgSFszXSA+PiAyNCAmIDB4ZmYsIEhbM10gPj4gMTYgJiAweGZmLCBIWzNdID4+IDggJiAweGZmLCBIWzNdICYgMHhmZiwgSFs0XSA+PiAyNCAmIDB4ZmYsIEhbNF0gPj4gMTYgJiAweGZmLCBIWzRdID4+IDggJiAweGZmLCBIWzRdICYgMHhmZl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoYTE7IiwiaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTsgLy8gVVRGOCBlc2NhcGVcblxuICB2YXIgYnl0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgdmFyIEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IHZhciBVUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9IC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG5cblxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2ICsgdmFsdWUubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlKTtcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaGZ1bmMoYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbnZhciB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyIsImltcG9ydCB7IExSUGFyc2VyIH0gZnJvbSAnQGxlemVyL2xyJztcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBKc29uJDEgPSAxLFxuICBMb2dmbXQkMSA9IDIsXG4gIFVucGFjayQxID0gMyxcbiAgUGF0dGVybiQxID0gNCxcbiAgUmVnZXhwJDEgPSA1LFxuICBVbndyYXAkMSA9IDYsXG4gIElwJDEgPSA3LFxuICBMYWJlbEZvcm1hdCQxID0gOCxcbiAgTGluZUZvcm1hdCQxID0gOSxcbiAgTGFiZWxSZXBsYWNlJDEgPSAxMCxcbiAgT2Zmc2V0JDEgPSAxMSxcbiAgQm9vbCQxID0gMTIsXG4gIE9uJDEgPSAxMyxcbiAgSWdub3JpbmckMSA9IDE0LFxuICBHcm91cExlZnQkMSA9IDE1LFxuICBHcm91cFJpZ2h0JDEgPSAxNixcbiAgQnkkMSA9IDE3LFxuICBXaXRob3V0JDEgPSAxOCxcbiAgQW5kJDEgPSAxOSxcbiAgT3IkMSA9IDIwLFxuICBVbmxlc3MkMSA9IDIxLFxuICBTdW0kMSA9IDIyLFxuICBBdmckMSA9IDIzLFxuICBDb3VudCQxID0gMjQsXG4gIE1heCQxID0gMjUsXG4gIE1pbiQxID0gMjYsXG4gIFN0ZGRldiQxID0gMjcsXG4gIFN0ZHZhciQxID0gMjgsXG4gIEJvdHRvbWskMSA9IDI5LFxuICBUb3BrJDEgPSAzMDtcblxuY29uc3Qga2V5d29yZFRva2VucyA9IHtcbiAgICBqc29uOiBKc29uJDEsXG4gICAgbG9nZm10IDogTG9nZm10JDEsXG4gICAgdW5wYWNrOiBVbnBhY2skMSxcbiAgICBwYXR0ZXJuIDogUGF0dGVybiQxLFxuICAgIHJlZ2V4cCA6IFJlZ2V4cCQxLFxuICAgIGlwIDogSXAkMSxcbiAgICBsYWJlbF9mb3JtYXQgOiBMYWJlbEZvcm1hdCQxLFxuICAgIGxpbmVfZm9ybWF0IDogTGluZUZvcm1hdCQxLFxuICAgIGxhYmVsX3JlcGxhY2U6IExhYmVsUmVwbGFjZSQxLFxuICAgIG9mZnNldDogT2Zmc2V0JDEsXG4gICAgYm9vbDogQm9vbCQxLFxuICAgIG9uOiBPbiQxLFxuICAgIGlnbm9yaW5nOiBJZ25vcmluZyQxLFxuICAgIGdyb3VwX2xlZnQ6IEdyb3VwTGVmdCQxLFxuICAgIGdyb3VwX3JpZ2h0OiBHcm91cFJpZ2h0JDEsXG4gICAgdW53cmFwOiBVbndyYXAkMSxcbn07XG5cbmNvbnN0IHNwZWNpYWxpemVJZGVudGlmaWVyID0gKHZhbHVlLCBzdGFjaykgPT4ge1xuICAgIHJldHVybiBrZXl3b3JkVG9rZW5zW3ZhbHVlLnRvTG93ZXJDYXNlKCldIHx8IC0xO1xufTtcblxuXG5jb25zdCBjb250ZXh0dWFsS2V5d29yZFRva2VucyA9IHtcbiAgICBieTogQnkkMSxcbiAgICB3aXRob3V0OiBXaXRob3V0JDEsXG4gICAgYW5kOiBBbmQkMSxcbiAgICBvcjogT3IkMSxcbiAgICB1bmxlc3M6IFVubGVzcyQxLFxuICAgIHN1bTogU3VtJDEsXG4gICAgYXZnOiBBdmckMSxcbiAgICBjb3VudDogQ291bnQkMSxcbiAgICBtYXg6IE1heCQxLFxuICAgIG1pbjogTWluJDEsXG4gICAgc3RkZGV2OiBTdGRkZXYkMSxcbiAgICBzdGR2YXI6IFN0ZHZhciQxLFxuICAgIGJvdHRvbWs6IEJvdHRvbWskMSxcbiAgICB0b3BrOiBUb3BrJDFcbn07XG5cbmNvbnN0IGV4dGVuZElkZW50aWZpZXIgPSAodmFsdWUsIHN0YWNrKSA9PiB7XG4gICAgcmV0dXJuIGNvbnRleHR1YWxLZXl3b3JkVG9rZW5zW3ZhbHVlLnRvTG93ZXJDYXNlKCldIHx8IC0xO1xufTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX0lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsY291bnRfb3Zlcl90aW1lOjI1NSwgcmF0ZToyNTcsIGJ5dGVzX292ZXJfdGltZToyNTksIGJ5dGVzX3JhdGU6MjYxLCBhdmdfb3Zlcl90aW1lOjI2Mywgc3VtX292ZXJfdGltZToyNjUsIG1pbl9vdmVyX3RpbWU6MjY3LCBtYXhfb3Zlcl90aW1lOjI2OSwgc3RkZGV2X292ZXJfdGltZToyNzEsIHN0ZHZhcl9vdmVyX3RpbWU6MjczLCBxdWFudGlsZV9vdmVyX3RpbWU6Mjc1LCBmaXJzdF9vdmVyX3RpbWU6Mjc3LCBsYXN0X292ZXJfdGltZToyNzksIGFic2VudF9vdmVyX3RpbWU6MjgxLCBieXRlczoyODcsIGR1cmF0aW9uOjI4OSwgZHVyYXRpb25fc2Vjb25kczoyOTF9O1xuY29uc3QgcGFyc2VyID0gTFJQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxMyxcbiAgc3RhdGVzOiBcIkFTT1lRUE9PTyNWUVBPJyNEUE8kZlFQTycjRE9PWVFQTycjRE9PT1FPJyNEeycjRHtPJHNRUE8nI0R6T09RTycjRWcnI0VnTyR4UVBPJyNFZlElVFFQT09PT1FPJyNFdScjRXVPJlVRUE8nI0V1TyZaUVBPJyNFdk9PUU8nI0R5JyNEeU9PUU8nI0N9JyNDfU9PUU8nI0R8JyNEfE9PUU8nI0R9JyNEfU9PUU8nI0VPJyNFT09PUU8nI0VQJyNFUE9PUU8nI0VRJyNFUU9PUU8nI0VSJyNFUk9PUU8nI0VTJyNFU09PUU8nI0VUJyNFVE9PUU8nI0VVJyNFVU9PUU8nI0VWJyNFVk9PUU8nI0VXJyNFV09PUU8nI0VYJyNFWE9PUU8nI0VZJyNFWU9PUU8nI0VaJyNFWk8mYFFQTycjRFJPT1FPJyNEUScjRFFPJm5RUE8sNTlrT09RTycjRF4nI0ReTyZ2UVBPJyNEXU8nT1FQTycjRFtPT1FPJyNEWicjRFpPKGlRUE8nI0RaT09RTycjRFknI0RZTypiUVBPLDU5ak8rcFFQTyw1OWpPK3dRUE8sNTplTyxPUVBPLDU6Zk8sWlFQTycjRWRPLllRUE8sNTtRTy5hUVBPLDU7UU8uZlFQTyw1O1NPLmZRUE8sNTtTTy5mUVBPLDU7U08uZlFQTyw1O1NPLmZRUE8sNTtTTy5mUVBPLDU7U09PUU8sNTthLDU7YU9ZUVBPLDU7Yk8wbFFQTyw1OW1PMHFRUE8xRy9WT09RTzFHL1YxRy9WT09RTycjRGEnI0RhT09RTyw1OXcsNTl3TzB5UVBPLDU5d09PUU8sNTl2LDU5dk8xT1FQTycjRFJPMW1RUE8nI0RjT09RTycjRGMnI0RjTzNaUVBPJyNEY09PUU8nI0RpJyNEaU9PUU8nI0RnJyNEZ08pT1FQTycjRGdPM2BRUE8sNTl1TzR5UVBPJyNEdU81T1FQTycjRHZPT1FPLDU5dSw1OXVPT1FPLDU5dCw1OXRPT1FPMUcvVTFHL1VPT1FPMUcwUDFHMFBPNVRRUE8nI0VbTyxSUVBPJyNFW081aVFQTzFHMFFPNW5RUE8xRzBRTzVzUVBPLDU7T081e1FQTzFHMGxPN1dRUE8xRzBsTzdfUVBPMUcwbE83ZlFQTycjRWpPOWhRUE8nI0VpTzlyUVBPJyNFaU9ZUVBPMUcwbk9ZUVBPMUcwbk9ZUVBPMUcwbk9ZUVBPMUcwbk9ZUVBPMUcwbk9ZUVBPMUcwbk85fFFQTzFHMHxPT1FPMUcvWDFHL1hPT1FPMUcvVzFHL1dPT1FPNyskcTcrJHFPOlRRUE8xRy9jTzpZUVBPLDU5bU86YFFQTyw1OlVPOmtRUE8nI0RmTzpwUVBPJyNEZU9PUU8sNTpPLDU6T09PUU8sNTl9LDU5fU88WlFQTyw1OlJPKU9RUE8sNTpSTylPUVBPLDU6Uk9PUU8sNTphLDU6YU88aVFQTycjRHhPT1FPJyNEdycjRHdPPG5RUE8sNTpiTz5YUVBPJyNEWk81VFFQTyw1OnZPPmBRUE8nI0VdTz5lUVBPLDU6dk8/T1FQTyw1OnZPP1lRUE8sNTp2Tz9hUVBPLDU6dk8/ZlFQTzcrJWxPLFJRUE83KyVsT09RTycjRWUnI0VlT0B2UVBPMUcwak9PUU8xRzBqMUcwak9BT1FQTzcrJldPWVFQTzcrJldPQmBRUE83KyZXT0JnUVBPNysmV09CblFRTycjRWtPT1FPLDU7VSw1O1VPRHBRUE8sNTtUT0R3UVBPLDU7VE9GWVFQTzcrJllPRmFRUE83KyZZT09RTzcrJlk3KyZZT0ZuUVBPNysmWU9GdVFQTzcrJllPR3pRUE83KyZZT0hbUVBPNysmaE9IYVFQTzcrJH1PSGZRUE8xRy9uT09RTzFHL3AxRy9wT09RTzFHL3cxRy93T09RTzFHL3kxRy95T0hrUVBPLDU6UU9IcFFQTyw1OlBPT1FPMUcvbTFHL21PSHVRUE8xRy9tT0pgUVBPLDU6ZE81T1FQTyw1OmNPSmhRUE8sNTp5Tz5lUVBPMUcwYk9KdlFQTzFHMGJPS09RUE8sNTp3TylPUVBPLDU6eU9LVFFQTzFHMGJPS1tRUE8nI0VeT0thUVBPMUcwYk9LVFFQTzFHMGJPS2lRUE8xRzBiT0twUVBPMUcwYk81ZFFQTzFHMGJPT1FPMUcwYjFHMGJPT1FPPDxJVzw8SVdPS3tRUE88PElXT0xRUVBPLDU7UE9PUU83KyZVNysmVU9PUU88PElyPDxJck9MVlFQTzw8SXJPWVFQTzw8SXJPT1FPJyNFbScjRW1PTF5RUE8sNTtWT09RTycjRWwnI0VsT09RTyw1O1YsNTtWT09RTzFHMG8xRzBvT0xmUVBPMUcwb09OY1FQTzw8SlNPT1FPPDxIaTw8SGlPTmhRUE83KyVZT09RTzFHL2wxRy9sT09RTzFHL2sxRy9rT09RTzFHME8xRzBPT09RTzFHL30xRy99T09RTycjRWAnI0VgT09RTzFHMGUxRzBlT05tUVBPMUcwZU9PUU8nI0VhJyNFYU9PUU8nI0ViJyNFYk9PUU8nI0VjJyNFY09PUU83KyV8NyslfE9PUU8xRzBjMUcwY09OclFQTzFHMGVPISBXUVBPNyslfE9PUU8sNTp4LDU6eE8hIGBRUE83KyV8TzVkUVBPNyslfE8hIGdRUE83KyV8TyEgclFQT0FOPnJPT1FPMUcwazFHMGtPISNTUVBPQU4/Xk8hJGRRUE9BTj9eTyEka1FRTzFHMHFPT1FPMUcwcTFHMHFPT1FPNysmWjcrJlpPISRzUVBPQU4/bk8hJHhRUE88PEh0TyEkfVFQTzcrJlBPISVTUVBPPDxJaE8hJVtRUE88PEloTyElZFFQTzw8SWhPISVsUVBPJyNFX09PUU88PEloPDxJaE9PUU9HMjReRzI0Xk9PUU9HMjR4RzI0eE9PUU8xRzByMUcwck9PUU83KyZdNysmXU8hJXFRUE9HMjVZT09RT0FOPmBBTj5gTyEldlFQTzw8SWtPT1FPQU4/U0FOP1NPISV7UVBPQU4/U08hJlRRUE9MRCp0T09RT0FOP1ZBTj9WT09RTyw1OmIsNTpiTyEmWVFQTyEkJ05gTyEmX1FQTyEpOUN6TyEmZFFQTyEuSzlmT09RTyE0Ly9RITQvL1FPNU9RUE8nI0R2TyEmaVFQTycjRFpPISdXUVBPLDU5ak8hJ2JRUE8nI0RPT1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuTy5mUVBPLDU7U08uZlFQTyw1O1NPLmZRUE8sNTtTTy5mUVBPLDU7U08uZlFQTyw1O1NPLmZRUE8sNTtTTyEobVFQTzcrJllPISh0UVBPNysmWU8hKVJRUE83KyZZTyEqWlFQTzcrJllPISpiUVBPNysmWU8hKVlRUE8nI0VoXCIsXG4gIHN0YXRlRGF0YTogXCIhKm9+TyNtT1NvT1N+T1laT2ZVT2dVT2hVT2lVT2pVT2tVT2xVT21VT25VTyFoWE8jY1lPI2RZTyNuUE8jcVJPI3NeTyN0X08jdWBPI3ZhTyN3Yk8jeGNPI3lkTyN6ZU8je2ZPI3xnTyN9aE8kT2lPJFBqTyRRa09+T3ZsT35PeW9Pe29PIVJvTyFTb09jclhkclhlclghX3JYIWFyWCFiclghY3JYIWRyWCNjclgjZHJYI2VyWCNmclgjZ3JYI2hyWH5PIVVzTyNrclgjcnJYflAjW08jcXhPfk9heU9ieU8jcXpPfk9jfU9kfE9lfU95IVJPIV8hUk8hYSFSTyFiIVJPIWMhUk8hZCFSTyNjIU9PI2QhT08jZSFQTyNmIVBPI2chUE8jaCFRT35PIWghU09+TyNxIVRPfk93IVVPeSFVT3ohVU97IVVPfk8jbyFWTyNwIVdPfk9WIVhPeCFZT35PeW9Pe29PIVJvTyFTb09jIU9YZCFPWGUhT1ghVSFPWCFfIU9YIWEhT1ghYiFPWCFjIU9YIWQhT1gjYyFPWCNkIU9YI2UhT1gjZiFPWCNnIU9YI2ghT1gjayFPWCNyIU9YJFIhT1gjbyFPWH5PUCFeT1EhX09SIV9PUyFgT1QhYE9XIWZPWCFlT3YhXU8jcSFjT35PeW9Pe29PIVJvTyFTb09jcmFkcmFlcmEhX3JhIWFyYSFicmEhY3JhIWRyYSNjcmEjZHJhI2VyYSNmcmEjZ3JhI2hyYX5PIVVzTyNrcmEjcnJhflApV09jcVhkcVhlcVh5cVghX3FYIWFxWCFicVghY3FYIWRxWCNjcVgjZHFYI2VxWCNmcVgjZ3FYI2hxWH5PI3IhaU9+UCpvTyNyIWpPflAqb08haCFuTyNuUE8jcSFsT35PI3Ehb09+T1laT2ZVT2dVT2hVT2lVT2pVT2tVT2xVT21VT25VTyNjWU8jZFlPI25QTyNxUk8jc15PI3RfTyN1YE8jdmFPI3diTyN4Y08jeWRPI3plTyN7Zk8jfGdPI31oTyRPaU8kUGpPJFFrT35PIWghcU9+UCxgTyNxIXJPfk9bIXVPXSFzT14hc09ZI11QZiNdUGcjXVBoI11QaSNdUGojXVBrI11QbCNdUG0jXVBuI11QIWgjXVAjYyNdUCNkI11QI24jXVAjcSNdUCNzI11QI3QjXVAjdSNdUCN2I11QI3cjXVAjeCNdUCN5I11QI3ojXVAjeyNdUCN8I11QI30jXVAkTyNdUCRQI11QJFEjXVB+T3ghfU9+T3ZsTyNwI1BPfk8jcSNRT35PdyNST3kjUk96IVVPeyFVTyFfI1NPIWEjU08hYiNTTyFjI1NPIWQjU09+T3YjVE9jIVZYZCFWWGUhVlh5IVZYeyFWWCFSIVZYIVMhVlghVSFWWCFfIVZYIWEhVlghYiFWWCFjIVZYIWQhVlgjYyFWWCNkIVZYI2UhVlgjZiFWWCNnIVZYI2ghVlgjayFWWCNyIVZYJFIhVlgjbyFWWH5PeCNXT35PYyNZT2QjWk8jbyNZT2V9YXl9YXt9YSFSfWEhU31hIVV9YSFffWEhYX1hIWJ9YSFjfWEhZH1hI2N9YSNkfWEjZX1hI2Z9YSNnfWEjaH1hI2t9YSNyfWEkUn1hfk94I1tPfk92I11Pfk95b097b08hUm9PIVNvTyFVI2BPJFIjYk9+TyNyI2dPfk8jbyNoT35PdiNpTyNyI2tPfk8jciNsT35QKm9PYyNpWGQjaVhlI2lYeSNpWCFfI2lYIWEjaVghYiNpWCFjI2lYIWQjaVgjYyNpWCNkI2lYI2UjaVgjZiNpWCNnI2lYI2gjaVgjciNpWH5PI28jbU9+UDZTTyFoI29PflAsYE8jcSNwT35PWSNdWGYjXVhnI11YaCNdWGkjXVhqI11YayNdWGwjXVhtI11YbiNdWCFoI11YI2MjXVgjZCNdWCNuI11YI3EjXVgjcyNdWCN0I11YI3UjXVgjdiNdWCN3I11YI3gjXVgjeSNdWCN6I11YI3sjXVgjfCNdWCN9I11YJE8jXVgkUCNdWCRRI11Yfk9fI3JPYCNyT35QN2tPXSFzT14hc09+UDdrTyNvI3pPflAqb094I3tPfk9WI3xPeCF9TyFgI31PIWYkT08haCRQT35PdyRRT35PI28kUk9jIVhYZCFYWGUhWFh5IVhYeyFYWCFSIVhYIVMhWFghVSFYWCFfIVhYIWEhWFghYiFYWCFjIVhYIWQhWFgjYyFYWCNkIVhYI2UhWFgjZiFYWCNnIVhYI2ghWFgjayFYWCNyIVhYJFIhWFh+T2MjWU9kI1pPI28jWU8jciRTT35PdyRVT35PI28kVk9jIWphZCFqYWUhamF5IWpheyFqYSFSIWphIVMhamEhVSFqYSFfIWphIWEhamEhYiFqYSFjIWphIWQhamEjYyFqYSNkIWphI2UhamEjZiFqYSNnIWphI2ghamEjayFqYSNyIWphJFIhamF+T1UkV09+UChpTyFgJFpPfk8hVSRbTyRSI2JPfk95b097b08hUm9PIVNvTyFVI2BPfk9aJF5PI3IjT2F+UD5tTyNyJGNPflA1VE8jciRkT35PYXlPYnlPYyFucWQhbnFlIW5xeSFucSFfIW5xIWEhbnEhYiFucSFjIW5xIWQhbnEjYyFucSNkIW5xI2UhbnEjZiFucSNnIW5xI2ghbnEjayFucSNyIW5xI28hbnF+TyNvJGdPI3IkaE9+T2F5T2J5T2MjWXFkI1lxZSNZcXkjWXEhXyNZcSFhI1lxIWIjWXEhYyNZcSFkI1lxI2MjWXEjZCNZcSNlI1lxI2YjWXEjZyNZcSNoI1lxI2sjWXEjciNZcSNvI1lxfk8jciRpT35QKm9PI28ka09+UDZTTyNiJGxPI3Ikb09+T1kjXWFmI11hZyNdYWgjXWFpI11haiNdYWsjXWFsI11hbSNdYW4jXWEhaCNdYSNjI11hI2QjXWEjbiNdYSNzI11hI3QjXWEjdSNdYSN2I11hI3cjXWEjeCNdYSN5I11hI3ojXWEjeyNdYSN8I11hI30jXWEkTyNdYSRQI11hJFEjXWF+TyNxI3BPflBCdk9fJHFPYCRxTyNxI11hflBCdk9jfU9lfU95IVJPIV8hUk8hYSFSTyFiIVJPIWMhUk8hZCFSTyNjIU9PI2QhT08jZSNbcSNmI1txI2cjW3EjaCNbcSNrI1txI3IjW3F+T2QjW3F+UEVVT2MjW3FkI1txZSNbcX5QRVtPZHxPflBFVU8jayNbcSNyI1txflAlVE9jI1txZCNbcWUjW3F5I1txIV8jW3EhYSNbcSFiI1txIWMjW3EhZCNbcSNlI1txI2YjW3EjZyNbcSNoI1txfk8jYyFPTyNkIU9PI2sjW3EjciNbcX5QR1BPeCRyT35PI3Ikc09+TyNxJHRPfk94JHVPfk92I1RPfk9jI1lPI28jWU9kIVppZSFaaXkhWml7IVppIVIhWmkhUyFaaSFVIVppIV8hWmkhYSFaaSFiIVppIWMhWmkhZCFaaSNjIVppI2QhWmkjZSFaaSNmIVppI2chWmkjaCFaaSNrIVppI3IhWmkkUiFaaX5PdiR3T3gkd09+T3Ykek8kVCR8TyRVJH1PJFYlT09+T1okXk8jciNPaX5PJFMlUU9+TyNyI09pflA+bU8hYCVUT35PIVUkW08jciNPaX5PI3IlVk9+UDVUTyFVJFtPI3IlVk8kUiNiT35PI3IlWE9+T3YlWU9+TyNyJVpPflAqb08jbyVdTyNyJV5Pfk8jcSNwT1kjXWlmI11pZyNdaWgjXWlpI11paiNdaWsjXWlsI11pbSNdaW4jXWkhaCNdaSNjI11pI2QjXWkjbiNdaSNzI11pI3QjXWkjdSNdaSN2I11pI3cjXWkjeCNdaSN5I11pI3ojXWkjeyNdaSN8I11pI30jXWkkTyNdaSRQI11pJFEjXWl+TyNvJWBPfk94JWFPfk8jcSViT35PYyNZT2QjWk8jbyNZTyFVI1JpJFIjUmkjciNSaX5PIVUkW08jciNPcX5PI3IjT3F+UD5tT1olZU8hVSVmTyNyI09xfk9heU9ieU9jIW4hUmQhbiFSZSFuIVJ5IW4hUiFfIW4hUiFhIW4hUiFiIW4hUiFjIW4hUiFkIW4hUiNjIW4hUiNkIW4hUiNlIW4hUiNmIW4hUiNnIW4hUiNoIW4hUiNrIW4hUiNyIW4hUiNvIW4hUn5PYXlPYnlPYyNZIVJkI1khUmUjWSFSeSNZIVIhXyNZIVIhYSNZIVIhYiNZIVIhYyNZIVIhZCNZIVIjYyNZIVIjZCNZIVIjZSNZIVIjZiNZIVIjZyNZIVIjaCNZIVIjayNZIVIjciNZIVIjbyNZIVJ+TyNyJWlPflAqb08jYiRsTyNyJWtPfk94JWxPfk8jciVtT35PdiVuT35PIVUkW08jciNPeX5PWiReTyNyI095fk8hVSVmTyFgJVRPfk9VJFdPfk8jbyVxT35PI3Ilck9+TyFVJFtPI3IjTyFSfk94JXRPfk8jbyV1T35PeCV2T35PI3Ild09+T1AhXk9RIV9PUiFfT1MhYE9UIWBPVyV4T1ghZU92IV1PI3EhY09+TyFVJXlPI29yYX5QKVdPIVUleU8jb3JYflAjW09jJlRPZSZUT3kmWE8hXyZYTyFhJlhPIWImWE8hYyZYTyFkJlhPI2MmVU8jZCZVTyNlI1txI2YjW3EjZyNbcSNoI1txI28jW3F+T2QjW3F+UCEnbE9jI1txZCNbcWUjW3F+UCEnck9kJlNPflAhJ2xPYyZUT2QmU09lJlRPeSZYTyFfJlhPIWEmWE8hYiZYTyFjJlhPIWQmWE8jYyZVTyNkJlVPI2UmVk8jZiZWTyNnJlZPI2gmV09+TyNvI1txflAhKVlPI2MmVU8jZCZVTyNvI1txflBHUE9cIixcbiAgZ290bzogXCIvXSNrUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQI2wkayVTJXIldVBQUFBQUCZVJmgmeCdXJ2lQUCd4UCd7J3soUShUKFoobChsKHVQUFBQUFAodVAobFAneyd7KU8pVSldKk8qZSp6Knoqeip6Knoqeip6Knoqeip6Knoqeip6KnorYStqK30sWixzLHYsdix2LHktWSpPLV0qTy1yLmgueS9TL1ZQUFBQUFBQKk8qT1tXT1J6IXIjbSRrUSN0IXZRI3Uhd1MjdiF4Jk9RI3cheVEjeCF6USN5IXtRJlklfFEmWiV9USZbJlBRJl0mUVEmXiZSUiZfIVR0XU96IVQhciF2IXcheCF5IXoheyNtJGslfCV9Jk8mUCZRJlJSdlJqUU9SeiFUIXIhdiF3IXgheSF6IXsjbSRrUyFreCNoUSNlIWxdJXslfCV9Jk8mUCZRJlJSblBRbVBeIWJzIWMjWSNaI2AkWyV5UiNPIVZRdVFRI2Eha1EkXSNkUSRhI2VRJVUkYFIleiV7W3RRIWsjZCNlJGAle10haHUjYSRdJGElVSV6aXJRdSFrI2EjZCNlJF0kYCRhJVUleiV7aHFRdSFrI2EjZCNlJF0kYCRhJVUleiV7UiFbcWtwUXF1IWsjYSNkI2UkXSRgJGElVSV6JXtSIVpwViFncyNgJXlSI1YhXlEjVSFeUiR2JFJVIWRzI2AleVEjWCFjUSRTI1lRJFQjWlIlUiRbXyFicyFjI1kjWiNgJFsleV8hYXMhYyNZI1ojYCRbJXlRI18hZlIlcyV4UyNeIWYleFIkeCRWal1PIXYhdyF4IXkheiF7JXwlfSZPJlAmUSZSUXdSUSFwelEhfCFUUSNuIXJRJGojbVIlWyRrd1tPUnohVCFyIXYhdyF4IXkheiF7I20kayV8JX0mTyZQJlEmUndUT1J6IVQhciF2IXcheCF5IXoheyNtJGslfCV9Jk8mUCZRJlJ3U09SeiFUIXIhdiF3IXgheSF6IXsjbSRrJXwlfSZPJlAmUSZSUSFteFEjZiFsUiRmI2hTI2QhayNlVyRZI2EjYyRhJGJRJVAkWFElVyRjUiVkJVZRJGAjZFElUCRZUSVnJVdSJW8lZFEjYyFrUyRYI2EkYVEkXyNkUSRiI2VTJVMkXSRgUyVjJVUlV1IlcCVlUiR7JFdSJHkkV1F7VlEkZSNnUSRpI2xRJWglWFIlaSVaUiNqIW93Vk9SeiFUIXIhdiF3IXgheSF6IXsjbSRrJXwlfSZPJlAmUSZSUSF2fFEhd31RIXghT1EheSFQUSF6IVFRIXshUlElfCZTUSV9JlRRJk8mVVEmUCZWUSZRJldSJlImWGghdHx9IU8hUCFRIVImUyZUJlUmViZXJlhSI3MhdVEjcSFzUSRwI3JSJV8kcVIkbSNwUSRuI3BSJWolXVwiLFxuICBub2RlTmFtZXM6IFwi4pqgIEpzb24gTG9nZm10IFVucGFjayBQYXR0ZXJuIFJlZ2V4cCBVbndyYXAgSXAgTGFiZWxGb3JtYXQgTGluZUZvcm1hdCBMYWJlbFJlcGxhY2UgT2Zmc2V0IEJvb2wgT24gSWdub3JpbmcgR3JvdXBMZWZ0IEdyb3VwUmlnaHQgQnkgV2l0aG91dCBBbmQgT3IgVW5sZXNzIFN1bSBBdmcgQ291bnQgTWF4IE1pbiBTdGRkZXYgU3RkdmFyIEJvdHRvbWsgVG9wayBMaW5lQ29tbWVudCBMb2dRTCBFeHByIExvZ0V4cHIgU2VsZWN0b3IgTWF0Y2hlcnMgTWF0Y2hlciBJZGVudGlmaWVyIEVxIFN0cmluZyBOZXEgUmUgTnJlIFBpcGVsaW5lRXhwciBQaXBlbGluZVN0YWdlIExpbmVGaWx0ZXJzIExpbmVGaWx0ZXIgRmlsdGVyIFBpcGVFeGFjdCBQaXBlTWF0Y2ggRmlsdGVyT3AgUGlwZSBMYWJlbFBhcnNlciBKc29uRXhwcmVzc2lvblBhcnNlciBKc29uRXhwcmVzc2lvbkxpc3QgSnNvbkV4cHJlc3Npb24gTGFiZWxGaWx0ZXIgSXBMYWJlbEZpbHRlciBVbml0RmlsdGVyIER1cmF0aW9uRmlsdGVyIEd0ciBEdXJhdGlvbiBHdGUgTHNzIEx0ZSBFcWwgQnl0ZXNGaWx0ZXIgQnl0ZXMgTnVtYmVyRmlsdGVyIE51bWJlciBMaW5lRm9ybWF0RXhwciBMYWJlbEZvcm1hdEV4cHIgTGFiZWxzRm9ybWF0IExhYmVsRm9ybWF0TWF0Y2hlciBNZXRyaWNFeHByIFJhbmdlQWdncmVnYXRpb25FeHByIFJhbmdlT3AgQ291bnRPdmVyVGltZSBSYXRlIEJ5dGVzT3ZlclRpbWUgQnl0ZXNSYXRlIEF2Z092ZXJUaW1lIFN1bU92ZXJUaW1lIE1pbk92ZXJUaW1lIE1heE92ZXJUaW1lIFN0ZGRldk92ZXJUaW1lIFN0ZHZhck92ZXJUaW1lIFF1YW50aWxlT3ZlclRpbWUgRmlyc3RPdmVyVGltZSBMYXN0T3ZlclRpbWUgQWJzZW50T3ZlclRpbWUgTG9nUmFuZ2VFeHByIFJhbmdlIE9mZnNldEV4cHIgVW53cmFwRXhwciBDb252T3AgQnl0ZXNDb252IER1cmF0aW9uQ29udiBEdXJhdGlvblNlY29uZHNDb252IEdyb3VwaW5nIExhYmVscyBWZWN0b3JBZ2dyZWdhdGlvbkV4cHIgVmVjdG9yT3AgQmluT3BFeHByIEJpbk9wTW9kaWZpZXIgT25Pcklnbm9yaW5nTW9kaWZpZXIgR3JvdXBpbmdMYWJlbHMgR3JvdXBpbmdMYWJlbExpc3QgR3JvdXBpbmdMYWJlbCBMYWJlbE5hbWUgQWRkIFN1YiBNdWwgRGl2IE1vZCBQb3cgTGl0ZXJhbEV4cHIgTGFiZWxSZXBsYWNlRXhwclwiLFxuICBtYXhUZXJtOiAxNDUsXG4gIHNraXBwZWROb2RlczogWzAsMzFdLFxuICByZXBlYXROb2RlQ291bnQ6IDAsXG4gIHRva2VuRGF0YTogXCIze35Sd1heI2xwcSNscXIkYXJzJHRzdCVodXYlc3d4JXh4eSZneXombHp7JnF7fCZ2fH0me30hTydRIU8hUCdWIVAhUShWIVEhUihbIVIhWylyIVshXTByIV4hXzFXIV8hYDFlIWAhYTF6IWMhfTJYIX0jTzJvI1AjUTJ0I1EjUjJ5I1IjUzJYI1MjVDNPI1QjbzJYI28jcDNbI3AjcTNhI3EjcjN2I3kjeiNsJGYkZyNsI0JZI0JaI2wkSVMkSV8jbCRJfCRKTyNsJEpUJEpVI2wkS1YkS1cjbCZGVSZGViNsfiNxWSNtflheI2xwcSNsI3kjeiNsJGYkZyNsI0JZI0JaI2wkSVMkSV8jbCRJfCRKTyNsJEpUJEpVI2wkS1YkS1cjbCZGVSZGViNsfiRkUSFfIWAkaiNyI3Mkb34kb095fn4kdE97fn4keVV4fk9ZJHRaciR0cnMlXXMjTyR0I08jUCViI1B+JHR+JWJPeH5+JWVQT34kdH4lbVFvfk9ZJWhafiVofiV4TyNnfn4lfVV4fk9ZJXhadyV4d3glXXgjTyV4I08jUCZhI1B+JXh+JmRQT34leH4mbE8jcX5+JnFPI3J+fiZ2TyNlfn4me08jY35+J1FPI29+fidWTyNkfn4nWVAhUSFbJ11+J2JSIWh+IVEhWyddIWchaCdrI1gjWSdrfiduUnt8J3d9IU8ndyFRIVsnfX4nelAhUSFbJ31+KFNQIWh+IVEhWyd9fihbTyNmfn4oYWUhaH4hTyFQJ10hUSFbKXIhZyFoK1YhaSFqK3QhbSFuK3QhbyFwK3QhciFzK3QhdiF3K3QjVSNWK2kjVyNYK30jWCNZLlAjWiNbLmMjWyNdLGYjXyNgLmMjYSNiLmwjZCNlLmMjZyNoLW4jaCNpLmMjayNsLn0jbCNtMFcjbSNuL2l+KXdkIWh+IU8hUCddIVEhWylyIWchaCtWIWkhait0IW0hbit0IW8hcCt0IXIhcyt0IXYhdyt0I1UjVitpI1cjWCt9I1gjWS5QI1ojWy5jI1sjXSxmI18jYC5jI2EjYi5sI2QjZS5jI2cjaC1uI2gjaS5jI2sjbC59I20jbi9pfitZVHt8J3d9IU8ndyFRIVsnfSFkIWUraSNdI14rbn4rbk8hZn5+K3FQI1UjVitpfit3USFkIWUraSNdI14rbn4sU1AhYH4hUSFbLFZ+LFlTIVEhWyxWI1sjXSxmI2EjYix6I2cjaC1ufixrUCFgfiFRIVssbn4scVIhUSFbLG4jYSNiLHojZyNoLW5+LVBRIWB+IVEhWy1WI2cjaC1pfi1ZUiFRIVstViNhI2ItYyNnI2gtbn4tZlAjZyNoLWl+LW5PIWB+fi1zUCFgfiFRIVstdn4teVEhUSFbLXYjYSNiLWN+LlNUe3wnd30hTyd3IVEhWyd9I1UjVitpI10jXitufi5mUSNVI1YraSNdI14rbn4ucVMhYH4hUSFbLVYjVSNWK2kjXSNeK24jZyNoLWl+L1NQIWB+IVEhWy9Wfi9ZVCFRIVsvViNXI1grfSNbI10sZiNhI2IseiNnI2gtbn4vblAhYH4hUSFbL3F+L3RVIVEhWy9xI1cjWCt9I1sjXSxmI2EjYix6I2cjaC1uI2sjbC59fjBaUiFRIVswZCFjIWkwZCNUI1owZH4waVIhaH4hUSFbMGQhYyFpMGQjVCNaMGRQMHdUdlAhUSFbMHIhWyFdMHIhYyF9MHIjUiNTMHIjVCNvMHJ+MV1QIWJ+IV8hYDFgfjFlTyFjfn4xalF3fiFfIWAxcCNyI3MxdX4xdU8hZH5+MXpPen5+MlBQIV9+IV8hYDJTfjJYTyFhflIyYFR2UCNiUSFRIVsyWCFbIV0wciFjIX0yWCNSI1MyWCNUI28yWH4ydE8kUn5+MnlPJFN+fjNPTyNofn4zUlJPI1MzTyNTI1QlXSNUfjNPfjNhTyNufn4zZlEhVX4hXyFgM2wjciNzM3F+M3FPIVJ+fjN2TyFTfn4ze08jcH5cIixcbiAgdG9rZW5pemVyczogWzAsIDFdLFxuICB0b3BSdWxlczoge1wiTG9nUUxcIjpbMCwzMl19LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiAzOCwgZ2V0OiAodmFsdWUsIHN0YWNrKSA9PiAoc3BlY2lhbGl6ZUlkZW50aWZpZXIodmFsdWUpIDw8IDEpfSx7dGVybTogMzgsIGdldDogKHZhbHVlLCBzdGFjaykgPT4gKGV4dGVuZElkZW50aWZpZXIodmFsdWUpIDw8IDEpIHwgMX0se3Rlcm06IDM4LCBnZXQ6IHZhbHVlID0+IHNwZWNfSWRlbnRpZmllclt2YWx1ZV0gfHwgLTF9XSxcbiAgdG9rZW5QcmVjOiAwXG59KTtcbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgSnNvbiA9IDEsXG4gIExvZ2ZtdCA9IDIsXG4gIFVucGFjayA9IDMsXG4gIFBhdHRlcm4gPSA0LFxuICBSZWdleHAgPSA1LFxuICBVbndyYXAgPSA2LFxuICBJcCA9IDcsXG4gIExhYmVsRm9ybWF0ID0gOCxcbiAgTGluZUZvcm1hdCA9IDksXG4gIExhYmVsUmVwbGFjZSA9IDEwLFxuICBPZmZzZXQgPSAxMSxcbiAgQm9vbCA9IDEyLFxuICBPbiA9IDEzLFxuICBJZ25vcmluZyA9IDE0LFxuICBHcm91cExlZnQgPSAxNSxcbiAgR3JvdXBSaWdodCA9IDE2LFxuICBCeSA9IDE3LFxuICBXaXRob3V0ID0gMTgsXG4gIEFuZCA9IDE5LFxuICBPciA9IDIwLFxuICBVbmxlc3MgPSAyMSxcbiAgU3VtID0gMjIsXG4gIEF2ZyA9IDIzLFxuICBDb3VudCA9IDI0LFxuICBNYXggPSAyNSxcbiAgTWluID0gMjYsXG4gIFN0ZGRldiA9IDI3LFxuICBTdGR2YXIgPSAyOCxcbiAgQm90dG9tayA9IDI5LFxuICBUb3BrID0gMzAsXG4gIExpbmVDb21tZW50ID0gMzEsXG4gIExvZ1FMID0gMzIsXG4gIEV4cHIgPSAzMyxcbiAgTG9nRXhwciA9IDM0LFxuICBTZWxlY3RvciA9IDM1LFxuICBNYXRjaGVycyA9IDM2LFxuICBNYXRjaGVyID0gMzcsXG4gIElkZW50aWZpZXIgPSAzOCxcbiAgRXEgPSAzOSxcbiAgU3RyaW5nID0gNDAsXG4gIE5lcSA9IDQxLFxuICBSZSA9IDQyLFxuICBOcmUgPSA0MyxcbiAgUGlwZWxpbmVFeHByID0gNDQsXG4gIFBpcGVsaW5lU3RhZ2UgPSA0NSxcbiAgTGluZUZpbHRlcnMgPSA0NixcbiAgTGluZUZpbHRlciA9IDQ3LFxuICBGaWx0ZXIgPSA0OCxcbiAgUGlwZUV4YWN0ID0gNDksXG4gIFBpcGVNYXRjaCA9IDUwLFxuICBGaWx0ZXJPcCA9IDUxLFxuICBQaXBlID0gNTIsXG4gIExhYmVsUGFyc2VyID0gNTMsXG4gIEpzb25FeHByZXNzaW9uUGFyc2VyID0gNTQsXG4gIEpzb25FeHByZXNzaW9uTGlzdCA9IDU1LFxuICBKc29uRXhwcmVzc2lvbiA9IDU2LFxuICBMYWJlbEZpbHRlciA9IDU3LFxuICBJcExhYmVsRmlsdGVyID0gNTgsXG4gIFVuaXRGaWx0ZXIgPSA1OSxcbiAgRHVyYXRpb25GaWx0ZXIgPSA2MCxcbiAgR3RyID0gNjEsXG4gIER1cmF0aW9uID0gNjIsXG4gIEd0ZSA9IDYzLFxuICBMc3MgPSA2NCxcbiAgTHRlID0gNjUsXG4gIEVxbCA9IDY2LFxuICBCeXRlc0ZpbHRlciA9IDY3LFxuICBCeXRlcyA9IDY4LFxuICBOdW1iZXJGaWx0ZXIgPSA2OSxcbiAgTnVtYmVyID0gNzAsXG4gIExpbmVGb3JtYXRFeHByID0gNzEsXG4gIExhYmVsRm9ybWF0RXhwciA9IDcyLFxuICBMYWJlbHNGb3JtYXQgPSA3MyxcbiAgTGFiZWxGb3JtYXRNYXRjaGVyID0gNzQsXG4gIE1ldHJpY0V4cHIgPSA3NSxcbiAgUmFuZ2VBZ2dyZWdhdGlvbkV4cHIgPSA3NixcbiAgUmFuZ2VPcCA9IDc3LFxuICBDb3VudE92ZXJUaW1lID0gNzgsXG4gIFJhdGUgPSA3OSxcbiAgQnl0ZXNPdmVyVGltZSA9IDgwLFxuICBCeXRlc1JhdGUgPSA4MSxcbiAgQXZnT3ZlclRpbWUgPSA4MixcbiAgU3VtT3ZlclRpbWUgPSA4MyxcbiAgTWluT3ZlclRpbWUgPSA4NCxcbiAgTWF4T3ZlclRpbWUgPSA4NSxcbiAgU3RkZGV2T3ZlclRpbWUgPSA4NixcbiAgU3RkdmFyT3ZlclRpbWUgPSA4NyxcbiAgUXVhbnRpbGVPdmVyVGltZSA9IDg4LFxuICBGaXJzdE92ZXJUaW1lID0gODksXG4gIExhc3RPdmVyVGltZSA9IDkwLFxuICBBYnNlbnRPdmVyVGltZSA9IDkxLFxuICBMb2dSYW5nZUV4cHIgPSA5MixcbiAgUmFuZ2UgPSA5MyxcbiAgT2Zmc2V0RXhwciA9IDk0LFxuICBVbndyYXBFeHByID0gOTUsXG4gIENvbnZPcCA9IDk2LFxuICBCeXRlc0NvbnYgPSA5NyxcbiAgRHVyYXRpb25Db252ID0gOTgsXG4gIER1cmF0aW9uU2Vjb25kc0NvbnYgPSA5OSxcbiAgR3JvdXBpbmcgPSAxMDAsXG4gIExhYmVscyA9IDEwMSxcbiAgVmVjdG9yQWdncmVnYXRpb25FeHByID0gMTAyLFxuICBWZWN0b3JPcCA9IDEwMyxcbiAgQmluT3BFeHByID0gMTA0LFxuICBCaW5PcE1vZGlmaWVyID0gMTA1LFxuICBPbk9ySWdub3JpbmdNb2RpZmllciA9IDEwNixcbiAgR3JvdXBpbmdMYWJlbHMgPSAxMDcsXG4gIEdyb3VwaW5nTGFiZWxMaXN0ID0gMTA4LFxuICBHcm91cGluZ0xhYmVsID0gMTA5LFxuICBMYWJlbE5hbWUgPSAxMTAsXG4gIEFkZCA9IDExMSxcbiAgU3ViID0gMTEyLFxuICBNdWwgPSAxMTMsXG4gIERpdiA9IDExNCxcbiAgTW9kID0gMTE1LFxuICBQb3cgPSAxMTYsXG4gIExpdGVyYWxFeHByID0gMTE3LFxuICBMYWJlbFJlcGxhY2VFeHByID0gMTE4O1xuXG5leHBvcnQgeyBBYnNlbnRPdmVyVGltZSwgQWRkLCBBbmQsIEF2ZywgQXZnT3ZlclRpbWUsIEJpbk9wRXhwciwgQmluT3BNb2RpZmllciwgQm9vbCwgQm90dG9taywgQnksIEJ5dGVzLCBCeXRlc0NvbnYsIEJ5dGVzRmlsdGVyLCBCeXRlc092ZXJUaW1lLCBCeXRlc1JhdGUsIENvbnZPcCwgQ291bnQsIENvdW50T3ZlclRpbWUsIERpdiwgRHVyYXRpb24sIER1cmF0aW9uQ29udiwgRHVyYXRpb25GaWx0ZXIsIER1cmF0aW9uU2Vjb25kc0NvbnYsIEVxLCBFcWwsIEV4cHIsIEZpbHRlciwgRmlsdGVyT3AsIEZpcnN0T3ZlclRpbWUsIEdyb3VwTGVmdCwgR3JvdXBSaWdodCwgR3JvdXBpbmcsIEdyb3VwaW5nTGFiZWwsIEdyb3VwaW5nTGFiZWxMaXN0LCBHcm91cGluZ0xhYmVscywgR3RlLCBHdHIsIElkZW50aWZpZXIsIElnbm9yaW5nLCBJcCwgSXBMYWJlbEZpbHRlciwgSnNvbiwgSnNvbkV4cHJlc3Npb24sIEpzb25FeHByZXNzaW9uTGlzdCwgSnNvbkV4cHJlc3Npb25QYXJzZXIsIExhYmVsRmlsdGVyLCBMYWJlbEZvcm1hdCwgTGFiZWxGb3JtYXRFeHByLCBMYWJlbEZvcm1hdE1hdGNoZXIsIExhYmVsTmFtZSwgTGFiZWxQYXJzZXIsIExhYmVsUmVwbGFjZSwgTGFiZWxSZXBsYWNlRXhwciwgTGFiZWxzLCBMYWJlbHNGb3JtYXQsIExhc3RPdmVyVGltZSwgTGluZUNvbW1lbnQsIExpbmVGaWx0ZXIsIExpbmVGaWx0ZXJzLCBMaW5lRm9ybWF0LCBMaW5lRm9ybWF0RXhwciwgTGl0ZXJhbEV4cHIsIExvZ0V4cHIsIExvZ1FMLCBMb2dSYW5nZUV4cHIsIExvZ2ZtdCwgTHNzLCBMdGUsIE1hdGNoZXIsIE1hdGNoZXJzLCBNYXgsIE1heE92ZXJUaW1lLCBNZXRyaWNFeHByLCBNaW4sIE1pbk92ZXJUaW1lLCBNb2QsIE11bCwgTmVxLCBOcmUsIE51bWJlciwgTnVtYmVyRmlsdGVyLCBPZmZzZXQsIE9mZnNldEV4cHIsIE9uLCBPbk9ySWdub3JpbmdNb2RpZmllciwgT3IsIFBhdHRlcm4sIFBpcGUsIFBpcGVFeGFjdCwgUGlwZU1hdGNoLCBQaXBlbGluZUV4cHIsIFBpcGVsaW5lU3RhZ2UsIFBvdywgUXVhbnRpbGVPdmVyVGltZSwgUmFuZ2UsIFJhbmdlQWdncmVnYXRpb25FeHByLCBSYW5nZU9wLCBSYXRlLCBSZSwgUmVnZXhwLCBTZWxlY3RvciwgU3RkZGV2LCBTdGRkZXZPdmVyVGltZSwgU3RkdmFyLCBTdGR2YXJPdmVyVGltZSwgU3RyaW5nLCBTdWIsIFN1bSwgU3VtT3ZlclRpbWUsIFRvcGssIFVuaXRGaWx0ZXIsIFVubGVzcywgVW5wYWNrLCBVbndyYXAsIFVud3JhcEV4cHIsIFZlY3RvckFnZ3JlZ2F0aW9uRXhwciwgVmVjdG9yT3AsIFdpdGhvdXQsIHBhcnNlciB9O1xuIiwiaW1wb3J0IHsgTFJQYXJzZXIgfSBmcm9tICdAbGV6ZXIvbHInO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IFxuICBpbmYgPSAxNDYsXG4gIG5hbiA9IDE0NyxcbiAgQm9vbCA9IDEsXG4gIElnbm9yaW5nID0gMixcbiAgT24gPSAzLFxuICBHcm91cExlZnQgPSA0LFxuICBHcm91cFJpZ2h0ID0gNSxcbiAgT2Zmc2V0ID0gNixcbiAgQXRhbjIgPSA3LFxuICBBdmcgPSA4LFxuICBCb3R0b21rID0gOSxcbiAgQ291bnQgPSAxMCxcbiAgQ291bnRWYWx1ZXMgPSAxMSxcbiAgR3JvdXAgPSAxMixcbiAgTWF4ID0gMTMsXG4gIE1pbiA9IDE0LFxuICBRdWFudGlsZSA9IDE1LFxuICBTdGRkZXYgPSAxNixcbiAgU3RkdmFyID0gMTcsXG4gIFN1bSA9IDE4LFxuICBUb3BrID0gMTksXG4gIEJ5ID0gMjAsXG4gIFdpdGhvdXQgPSAyMSxcbiAgQW5kID0gMjIsXG4gIE9yID0gMjMsXG4gIFVubGVzcyA9IDI0LFxuICBTdGFydCA9IDI1LFxuICBFbmQgPSAyNjtcblxuLy8gQ29weXJpZ2h0IDIwMjEgVGhlIFByb21ldGhldXMgQXV0aG9yc1xuXG5jb25zdCBrZXl3b3JkVG9rZW5zID0ge1xuICAgIGluZjogaW5mLFxuICAgIG5hbjogbmFuLFxuICAgIGJvb2w6IEJvb2wsXG4gICAgaWdub3Jpbmc6IElnbm9yaW5nLFxuICAgIG9uOiBPbixcbiAgICBncm91cF9sZWZ0OiBHcm91cExlZnQsXG4gICAgZ3JvdXBfcmlnaHQ6IEdyb3VwUmlnaHQsXG4gICAgb2Zmc2V0OiBPZmZzZXQsXG59O1xuXG5jb25zdCBzcGVjaWFsaXplSWRlbnRpZmllciA9ICh2YWx1ZSwgc3RhY2spID0+IHtcbiAgICByZXR1cm4ga2V5d29yZFRva2Vuc1t2YWx1ZS50b0xvd2VyQ2FzZSgpXSB8fCAtMTtcbn07XG5cbmNvbnN0IGNvbnRleHR1YWxLZXl3b3JkVG9rZW5zID0ge1xuICAgIGF2ZzogQXZnLFxuICAgIGF0YW4yOiBBdGFuMixcbiAgICBib3R0b21rOiBCb3R0b21rLFxuICAgIGNvdW50OiBDb3VudCxcbiAgICBjb3VudF92YWx1ZXM6IENvdW50VmFsdWVzLFxuICAgIGdyb3VwOiBHcm91cCxcbiAgICBtYXg6IE1heCxcbiAgICBtaW46IE1pbixcbiAgICBxdWFudGlsZTogUXVhbnRpbGUsXG4gICAgc3RkZGV2OiBTdGRkZXYsXG4gICAgc3RkdmFyOiBTdGR2YXIsXG4gICAgc3VtOiBTdW0sXG4gICAgdG9wazogVG9wayxcbiAgICBieTogQnksXG4gICAgd2l0aG91dDogV2l0aG91dCxcbiAgICBhbmQ6IEFuZCxcbiAgICBvcjogT3IsXG4gICAgdW5sZXNzOiBVbmxlc3MsXG4gICAgc3RhcnQ6IFN0YXJ0LFxuICAgIGVuZDogRW5kLFxufTtcblxuY29uc3QgZXh0ZW5kSWRlbnRpZmllciA9ICh2YWx1ZSwgc3RhY2spID0+IHtcbiAgICByZXR1cm4gY29udGV4dHVhbEtleXdvcmRUb2tlbnNbdmFsdWUudG9Mb3dlckNhc2UoKV0gfHwgLTE7XG59O1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNwZWNfSWRlbnRpZmllciA9IHtfX3Byb3RvX186bnVsbCxhYnNlbnRfb3Zlcl90aW1lOjMwNywgYWJzZW50OjMwOSwgYWJzOjMxMSwgYWNvczozMTMsIGFjb3NoOjMxNSwgYXNpbjozMTcsIGFzaW5oOjMxOSwgYXRhbjozMjEsIGF0YW5oOjMyMywgYXZnX292ZXJfdGltZTozMjUsIGNlaWw6MzI3LCBjaGFuZ2VzOjMyOSwgY2xhbXA6MzMxLCBjbGFtcF9tYXg6MzMzLCBjbGFtcF9taW46MzM1LCBjb3M6MzM3LCBjb3NoOjMzOSwgY291bnRfb3Zlcl90aW1lOjM0MSwgZGF5c19pbl9tb250aDozNDMsIGRheV9vZl9tb250aDozNDUsIGRheV9vZl93ZWVrOjM0NywgZGVnOjM0OSwgZGVsdGE6MzUxLCBkZXJpdjozNTMsIGV4cDozNTUsIGZsb29yOjM1NywgaGlzdG9ncmFtX3F1YW50aWxlOjM1OSwgaG9sdF93aW50ZXJzOjM2MSwgaG91cjozNjMsIGlkZWx0YTozNjUsIGluY3JlYXNlOjM2NywgaXJhdGU6MzY5LCBsYWJlbF9yZXBsYWNlOjM3MSwgbGFiZWxfam9pbjozNzMsIGxhc3Rfb3Zlcl90aW1lOjM3NSwgbG46Mzc3LCBsb2cxMDozNzksIGxvZzI6MzgxLCBtYXhfb3Zlcl90aW1lOjM4MywgbWluX292ZXJfdGltZTozODUsIG1pbnV0ZTozODcsIG1vbnRoOjM4OSwgcGk6MzkxLCBwcmVkaWN0X2xpbmVhcjozOTMsIHByZXNlbnRfb3Zlcl90aW1lOjM5NSwgcXVhbnRpbGVfb3Zlcl90aW1lOjM5NywgcmFkOjM5OSwgcmF0ZTo0MDEsIHJlc2V0czo0MDMsIHJvdW5kOjQwNSwgc2NhbGFyOjQwNywgc2duOjQwOSwgc2luOjQxMSwgc2luaDo0MTMsIHNvcnQ6NDE1LCBzb3J0X2Rlc2M6NDE3LCBzcXJ0OjQxOSwgc3RkZGV2X292ZXJfdGltZTo0MjEsIHN0ZHZhcl9vdmVyX3RpbWU6NDIzLCBzdW1fb3Zlcl90aW1lOjQyNSwgdGFuOjQyNywgdGFuaDo0MjksIHRpbWVzdGFtcDo0MzEsIHRpbWU6NDMzLCB2ZWN0b3I6NDM1LCB5ZWFyOjQzN307XG5jb25zdCBwYXJzZXIgPSBMUlBhcnNlci5kZXNlcmlhbGl6ZSh7XG4gIHZlcnNpb246IDEzLFxuICBzdGF0ZXM6IFwiNltPWVFQT09PJntRUE9PT09RTycjQ3snI0N7TydRUVBPJyNDelEnXVFRT09PT1FPJyNEZScjRGVPJ1dRUE8nI0RkT09RTycjRX0nI0V9TyhqUVBPJyNGVE9ZUVBPJyNGUE9ZUVBPJyNGU09PUU8nI0ZWJyNGVk8uZlFTTycjRldPLm5RUU8nI0ZVT09RTycjRlUnI0ZVT09RTycjQ3knI0N5T09RTycjRGYnI0RmT09RTycjRGgnI0RoT09RTycjRGknI0RpT09RTycjRGonI0RqT09RTycjRGsnI0RrT09RTycjRGwnI0RsT09RTycjRG0nI0RtT09RTycjRG4nI0RuT09RTycjRG8nI0RvT09RTycjRHAnI0RwT09RTycjRHEnI0RxT09RTycjRHInI0RyT09RTycjRHMnI0RzT09RTycjRHQnI0R0T09RTycjRHUnI0R1T09RTycjRHYnI0R2T09RTycjRHcnI0R3T09RTycjRHgnI0R4T09RTycjRHknI0R5T09RTycjRHonI0R6T09RTycjRHsnI0R7T09RTycjRHwnI0R8T09RTycjRH0nI0R9T09RTycjRU8nI0VPT09RTycjRVAnI0VQT09RTycjRVEnI0VRT09RTycjRVInI0VST09RTycjRVMnI0VTT09RTycjRVQnI0VUT09RTycjRVUnI0VVT09RTycjRVYnI0VWT09RTycjRVcnI0VXT09RTycjRVgnI0VYT09RTycjRVknI0VZT09RTycjRVonI0VaT09RTycjRVsnI0VbT09RTycjRV0nI0VdT09RTycjRV4nI0VeT09RTycjRV8nI0VfT09RTycjRWAnI0VgT09RTycjRWEnI0VhT09RTycjRWInI0ViT09RTycjRWMnI0VjT09RTycjRWQnI0VkT09RTycjRWUnI0VlT09RTycjRWYnI0VmT09RTycjRWcnI0VnT09RTycjRWgnI0VoT09RTycjRWknI0VpT09RTycjRWonI0VqT09RTycjRWsnI0VrT09RTycjRWwnI0VsT09RTycjRW0nI0VtT09RTycjRW4nI0VuT09RTycjRW8nI0VvT09RTycjRXAnI0VwT09RTycjRXEnI0VxT09RTycjRXInI0VyT09RTycjRXMnI0VzT09RTycjRXQnI0V0T09RTycjRXUnI0V1T09RTycjRXYnI0V2T09RTycjRXcnI0V3T09RTycjRXgnI0V4T09RTycjRXknI0V5T09RTycjRXonI0V6UU9RUE9PTzBYUVBPJyNDfE8wXlFQTycjRFJPJ1dRUE8sNTlmTzBlUVFPLDU5Zk8yUlFQTyw1OW9PMlJRUE8sNTlvTzJSUVBPLDU5b08yUlFQTyw1OW9PMlJRUE8sNTlvTzd9UVFPLDU7Z084U1FRTyw1O2pPOFtRUE8sNTt5T09RTyw1Ok8sNTpPT09RTyw1O2ksNTtpTzhzUVFPLDU7a084elFRTyw1O25POmJRUE8nI0ZZTzpwUVBPLDU7ck9PUU8nI0ZYJyNGWE9PUU8sNTtyLDU7ck9PUU8sNTtwLDU7cE86eFFTTycjQ31PT1FPLDU5aCw1OWhPO1FRUE8sNTltTztZUVFPJyNEU09PUU8sNTltLDU5bU9PUU8xRy9RMUcvUU8wWFFQTycjRFdPQVZRUE8nI0RWT0FhUVBPJyNEVk9ZUVBPMUcvWk9ZUVBPMUcvWk9ZUVBPMUcvWk9ZUVBPMUcvWk9ZUVBPMUcvWk9Ba1FTTzFHMVJPT1FPMUcxVTFHMVVPQXNRUU8xRzFVT0F4UVBPJyNFfU9PUU8nI0ZhJyNGYU9PUU8xRzFlMUcxZU9CVFFQTzFHMWVPT1FPMUcxVjFHMVZPT1FPJyNGWicjRlpPQllRUE8sNTt0T0JfUVNPMUcxXk9PUU8xRzFeMUcxXk9PUU8nI0RQJyNEUE9CZ1FQTyw1OWlPT1FPJyNETycjRE9PT1FPLDU5aSw1OWlPWVFQTyw1OW5PT1FPMUcvWDFHL1hPT1FPLDU5ciw1OXJPSF9RUE8sNTlxT0hmUVBPLDU5cU9JfVFRTzcrJHVPSl9RUU83KyR1T0tzUVFPNyskdU9MWlFRTzcrJHVPTXJRUU83KyR1T09RTzcrJm03KyZtT05dUVFPNysmc09PUU83KyZwNysmcE9OZVFQTzcrJ1BPT1FPMUcxYDFHMWBPT1FPMUcxXzFHMV9PT1FPNysmeDcrJnhPTmpRU08xRy9UT09RTzFHL1QxRy9UT05yUVFPMUcvWU9PUU8xRy9dMUcvXU9OfFFQTzFHL11PT1FPPDxKXzw8Sl9PISZvUVBPPDxKX09PUU88PEprPDxKa09PUU8xRy9VMUcvVU9PUU83KyRvNyskb09PUU83KyR3Nyskd09PUU9BTj95QU4/eVwiLFxuICBzdGF0ZURhdGE6IFwiISZ0fk8kWk9Ta09Tfk9XUU9YUU9ZUU9aUU9bUU9dUU9eUU9fUU9gUU9hUU9iUU9jUU8hWlpPI3RfTyRXVk8kWFZPJFtYTyRfYE8kYGFPJGFiTyRiY08kY2RPJGRlTyRlZk8kZmdPJGdoTyRoaU8kaWpPJGprTyRrbE8kbG1PJG1uTyRub08kb3BPJHBxTyRxck8kcnNPJHN0TyR0dU8kdXZPJHZ3TyR3eE8keHlPJHl6TyR6e08ke3xPJHx9TyR9IU9PJU8hUE8lUCFRTyVRIVJPJVIhU08lUyFUTyVUIVVPJVUhVk8lViFXTyVXIVhPJVghWU8lWSFaTyVaIVtPJVshXU8lXSFeTyVeIV9PJV8hYE8lYCFhTyVhIWJPJWIhY08lYyFkTyVkIWVPJWUhZk8lZiFnTyVnIWhPJWghaU8laSFqTyVqIWtPJWshbE8lbCFtTyVtIW5PJW4hb08lbyFwTyVwIXFPJXEhck8lciFzTyV1V08ldldPJXdWTyV5W09+TyFaWk9+T2QhdU9lIXVPJFshdk9+T1UjUE9WIXlPZiF8T2chfU9oIXxPeCF5T3sheU98IXlPfSF5TyFPIXpPIVAhek8hUSF7TyFSIXtPIVMhe08hVCF7TyFVIXtPIVYhe08kUyNRTyVzI09Pfk8kVyNTTyRYI1NPJXcjU09XI3dYWCN3WFkjd1haI3dYWyN3WF0jd1heI3dYXyN3WGAjd1hhI3dYYiN3WGMjd1ghWiN3WCN0I3dYJFcjd1gkWCN3WCRbI3dYJF8jd1gkYCN3WCRhI3dYJGIjd1gkYyN3WCRkI3dYJGUjd1gkZiN3WCRnI3dYJGgjd1gkaSN3WCRqI3dYJGsjd1gkbCN3WCRtI3dYJG4jd1gkbyN3WCRwI3dYJHEjd1gkciN3WCRzI3dYJHQjd1gkdSN3WCR2I3dYJHcjd1gkeCN3WCR5I3dYJHojd1gkeyN3WCR8I3dYJH0jd1glTyN3WCVQI3dYJVEjd1glUiN3WCVTI3dYJVQjd1glVSN3WCVWI3dYJVcjd1glWCN3WCVZI3dYJVojd1glWyN3WCVdI3dYJV4jd1glXyN3WCVgI3dYJWEjd1glYiN3WCVjI3dYJWQjd1glZSN3WCVmI3dYJWcjd1glaCN3WCVpI3dYJWojd1glayN3WCVsI3dYJW0jd1glbiN3WCVvI3dYJXAjd1glcSN3WCVyI3dYJXUjd1gldiN3WCV3I3dYJXkjd1h+T3QjVk8leiNZT35PJXlbT1UjeFhWI3hYZiN4WGcjeFhoI3hYeCN4WHsjeFh8I3hYfSN4WCFPI3hYIVAjeFghUSN4WCFSI3hYIVMjeFghVCN4WCFVI3hYIVYjeFgkUyN4WCRWI3hYJXMjeFgkXiN4WCRdI3hYfk8kWyNbT35PJF4jYE9+UFlPZCF1T2UhdU9VbmFWbmFmbmFnbmFobmF4bmF7bmF8bmF9bmEhT25hIVBuYSFRbmEhUm5hIVNuYSFUbmEhVW5hIVZuYSRTbmEkVm5hJXNuYSRebmEkXW5hfk9QI2RPUSNiT1IjYk9XeVBYeVBZeVBaeVBbeVBdeVBeeVBfeVBgeVBheVBieVBjeVAhWnlQI3R5UCRXeVAkWHlQJFt5UCRfeVAkYHlQJGF5UCRieVAkY3lQJGR5UCRleVAkZnlQJGd5UCRoeVAkaXlQJGp5UCRreVAkbHlQJG15UCRueVAkb3lQJHB5UCRxeVAkcnlQJHN5UCR0eVAkdXlQJHZ5UCR3eVAkeHlQJHl5UCR6eVAke3lQJHx5UCR9eVAlT3lQJVB5UCVReVAlUnlQJVN5UCVUeVAlVXlQJVZ5UCVXeVAlWHlQJVl5UCVaeVAlW3lQJV15UCVeeVAlX3lQJWB5UCVheVAlYnlQJWN5UCVkeVAlZXlQJWZ5UCVneVAlaHlQJWl5UCVqeVAla3lQJWx5UCVteVAlbnlQJW95UCVweVAlcXlQJXJ5UCV1eVAldnlQJXd5UCV5eVB+TyNwI2pPfk8hUCNsTyNwI2tPfk9pI25PaiNuTyRXVk8kWFZPJXUjbU8ldiNtTyV3Vk9+TyReI3FPflAnXU94IXlPVSN2YVYjdmFmI3ZhZyN2YWgjdmF7I3ZhfCN2YX0jdmEhTyN2YSFQI3ZhIVEjdmEhUiN2YSFTI3ZhIVQjdmEhVSN2YSFWI3ZhJFMjdmEkViN2YSVzI3ZhJF4jdmEkXSN2YX5PIVYjck8kTyNyTyRQI3JPJFEjck9+TyRdI3RPJXojdU9+T3Qjdk8kXiN5T35PJF0jek8kXiN7T35PJF12WCRedlh+UCddT1d5WFh5WFl5WFp5WFt5WF15WF55WF95WGB5WGF5WGJ5WGN5WCFaeVgjdHlYJFd5WCRYeVgkW3lYJF95WCRgeVgkYXlYJGJ5WCRjeVgkZHlYJGV5WCRmeVgkZ3lYJGh5WCRpeVgkanlYJGt5WCRseVgkbXlYJG55WCRveVgkcHlYJHF5WCRyeVgkc3lYJHR5WCR1eVgkdnlYJHd5WCR4eVgkeXlYJHp5WCR7eVgkfHlYJH15WCVPeVglUHlYJVF5WCVSeVglU3lYJVR5WCVVeVglVnlYJVd5WCVYeVglWXlYJVp5WCVbeVglXXlYJV55WCVfeVglYHlYJWF5WCVieVglY3lYJWR5WCVleVglZnlYJWd5WCVoeVglaXlYJWp5WCVreVglbHlYJW15WCVueVglb3lYJXB5WCVxeVglcnlYJXV5WCV2eVgld3lYJXl5WH5PUyN9T1QjfU9+UDtkT1EjYk9SI2JPflA7ZE8ldCRVTyV4JFZPfk8jcCRXT35PJFcjU08kWCNTTyV3I1NPfk8kWyRYT35PI3QkWU9+T3QjVk8leiRbT35PJF0kXU8kXiReT35PV3lhWHlhWXlhWnlhW3lhXXlhXnlhX3lhYHlhYXlhYnlhY3lhIVp5YSN0eWEkV3lhJFh5YSRfeWEkYHlhJGF5YSRieWEkY3lhJGR5YSRleWEkZnlhJGd5YSRoeWEkaXlhJGp5YSRreWEkbHlhJG15YSRueWEkb3lhJHB5YSRxeWEkcnlhJHN5YSR0eWEkdXlhJHZ5YSR3eWEkeHlhJHl5YSR6eWEke3lhJHx5YSR9eWElT3lhJVB5YSVReWElUnlhJVN5YSVUeWElVXlhJVZ5YSVXeWElWHlhJVl5YSVaeWElW3lhJV15YSVeeWElX3lhJWB5YSVheWElYnlhJWN5YSVkeWElZXlhJWZ5YSVneWElaHlhJWl5YSVqeWEla3lhJWx5YSVteWElbnlhJW95YSVweWElcXlhJXJ5YSV1eWEldnlhJXd5YSV5eWF+TyRbI1tPflBCb09TJGFPVCRhTyRbeWF+UEJvT3gheU9Vd3Fmd3Fnd3Fod3EhT3dxIVB3cSFRd3EhUndxIVN3cSFUd3EhVXdxIVZ3cSRTd3EkVndxJXN3cSRed3EkXXdxfk9Wd3F7d3F8d3F9d3F+UEhzT1YheU97IXlPfCF5T30heU9+UEhzT1YheU94IXlPeyF5T3wheU99IXlPIU8hek8hUCF6T1V3cWZ3cWd3cWh3cSRTd3EkVndxJXN3cSRed3EkXXdxfk8hUXdxIVJ3cSFTd3EhVHdxIVV3cSFWd3F+UEpvTyFRIXtPIVIhe08hUyF7TyFUIXtPIVUhe08hViF7T35QSm9PViF5T2YhfE9oIXxPeCF5T3sheU98IXlPfSF5TyFPIXpPIVAhek8hUSF7TyFSIXtPIVMhe08hVCF7TyFVIXtPIVYhe09+T1V3cWd3cSRTd3EkVndxJXN3cSRed3EkXXdxflBMcU8jcCRjTyV0JGJPfk8kXiRkT35PdCN2TyReJGZPfk8kXXZpJF52aX5QJ11PJFsjW09XeWlYeWlZeWlaeWlbeWldeWleeWlfeWlgeWlheWlieWljeWkhWnlpI3R5aSRXeWkkWHlpJF95aSRgeWkkYXlpJGJ5aSRjeWkkZHlpJGV5aSRmeWkkZ3lpJGh5aSRpeWkkanlpJGt5aSRseWkkbXlpJG55aSRveWkkcHlpJHF5aSRyeWkkc3lpJHR5aSR1eWkkdnlpJHd5aSR4eWkkeXlpJHp5aSR7eWkkfHlpJH15aSVPeWklUHlpJVF5aSVSeWklU3lpJVR5aSVVeWklVnlpJVd5aSVYeWklWXlpJVp5aSVbeWklXXlpJV55aSVfeWklYHlpJWF5aSVieWklY3lpJWR5aSVleWklZnlpJWd5aSVoeWklaXlpJWp5aSVreWklbHlpJW15aSVueWklb3lpJXB5aSVxeWklcnlpJXV5aSV2eWkld3lpJXl5aX5PJXQkaE9+T1wiLFxuICBnb3RvOiBcIih1JFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUCRWJHUlUiVfJWUlcSV0UCV6JlQkdVAmVyZnUFBQUFBQUFBQUFAkdSZxJn1QJn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSR1UCdaJHUkdVAkdSR1J2okdSd2KFYoZihpKG9QUFAkdVAoclFTT1EjVFhRI1VZUSNfIXZRJFAjZVEkUSNmUSRSI2dRJFMjaFEkVCNpUiRfI3plX09YWSF2I2UjZiNnI2gjaSN6ZVJPWFkhdiNlI2YjZyNoI2kjelEhd1JSI2EheFEjXSF1USN8I2JRJGAjfVIkZyRhUiN3I1tRI3gjW1IkZSRdUSF4UlEjUlVSI2Ehd1IjXiF2USNlIXlRI2YhelEjZyF7USNoIXxSI2khfVkjYyF5IXoheyF8IX1SJE8jZGVVT1hZIXYjZSNmI2cjaCNpI3plVE9YWSF2I2UjZiNnI2gjaSN6ZF9PWFkhdiNlI2YjZyNoI2kjelIjbyNRZVlPWFkhdiNlI2YjZyNoI2kjemRdT1hZIXYjZSNmI2cjaCNpI3pSIXRQZF5PWFkhdiNlI2YjZyNoI2kjelIjWl1SI1dbUSNYW1IkWiN0UiNzI1ZSI3AjUVwiLFxuICBub2RlTmFtZXM6IFwi4pqgIEJvb2wgSWdub3JpbmcgT24gR3JvdXBMZWZ0IEdyb3VwUmlnaHQgT2Zmc2V0IEF0YW4yIEF2ZyBCb3R0b21rIENvdW50IENvdW50VmFsdWVzIEdyb3VwIE1heCBNaW4gUXVhbnRpbGUgU3RkZGV2IFN0ZHZhciBTdW0gVG9wayBCeSBXaXRob3V0IEFuZCBPciBVbmxlc3MgU3RhcnQgRW5kIExpbmVDb21tZW50IFByb21RTCBFeHByIEFnZ3JlZ2F0ZUV4cHIgQWdncmVnYXRlT3AgQWdncmVnYXRlTW9kaWZpZXIgR3JvdXBpbmdMYWJlbHMgR3JvdXBpbmdMYWJlbExpc3QgR3JvdXBpbmdMYWJlbCBMYWJlbE5hbWUgRnVuY3Rpb25DYWxsQm9keSBGdW5jdGlvbkNhbGxBcmdzIEJpbmFyeUV4cHIgUG93IEJpbk1vZGlmaWVycyBPbk9ySWdub3JpbmcgTXVsIERpdiBNb2QgQWRkIFN1YiBFcWwgR3RlIEd0ciBMdGUgTHNzIE5lcSBGdW5jdGlvbkNhbGwgRnVuY3Rpb25JZGVudGlmaWVyIEFic2VudE92ZXJUaW1lIElkZW50aWZpZXIgQWJzZW50IEFicyBBY29zIEFjb3NoIEFzaW4gQXNpbmggQXRhbiBBdGFuaCBBdmdPdmVyVGltZSBDZWlsIENoYW5nZXMgQ2xhbXAgQ2xhbXBNYXggQ2xhbXBNaW4gQ29zIENvc2ggQ291bnRPdmVyVGltZSBEYXlzSW5Nb250aCBEYXlPZk1vbnRoIERheU9mV2VlayBEZWcgRGVsdGEgRGVyaXYgRXhwIEZsb29yIEhpc3RvZ3JhbVF1YW50aWxlIEhvbHRXaW50ZXJzIEhvdXIgSWRlbHRhIEluY3JlYXNlIElyYXRlIExhYmVsUmVwbGFjZSBMYWJlbEpvaW4gTGFzdE92ZXJUaW1lIExuIExvZzEwIExvZzIgTWF4T3ZlclRpbWUgTWluT3ZlclRpbWUgTWludXRlIE1vbnRoIFBpIFByZWRpY3RMaW5lYXIgUHJlc2VudE92ZXJUaW1lIFF1YW50aWxlT3ZlclRpbWUgUmFkIFJhdGUgUmVzZXRzIFJvdW5kIFNjYWxhciBTZ24gU2luIFNpbmggU29ydCBTb3J0RGVzYyBTcXJ0IFN0ZGRldk92ZXJUaW1lIFN0ZHZhck92ZXJUaW1lIFN1bU92ZXJUaW1lIFRhbiBUYW5oIFRpbWVzdGFtcCBUaW1lIFZlY3RvciBZZWFyIE1hdHJpeFNlbGVjdG9yIER1cmF0aW9uIE51bWJlckxpdGVyYWwgT2Zmc2V0RXhwciBQYXJlbkV4cHIgU3RyaW5nTGl0ZXJhbCBTdWJxdWVyeUV4cHIgVW5hcnlFeHByIFVuYXJ5T3AgVmVjdG9yU2VsZWN0b3IgTWV0cmljSWRlbnRpZmllciBMYWJlbE1hdGNoZXJzIExhYmVsTWF0Y2hMaXN0IExhYmVsTWF0Y2hlciBNYXRjaE9wIEVxbFNpbmdsZSBFcWxSZWdleCBOZXFSZWdleCBTdGVwSW52YXJpYW50RXhwciBBdCBBdE1vZGlmaWVyUHJlcHJvY2Vzc29ycyBNZXRyaWNOYW1lXCIsXG4gIG1heFRlcm06IDIyNixcbiAgc2tpcHBlZE5vZGVzOiBbMCwyN10sXG4gIHJlcGVhdE5vZGVDb3VudDogMCxcbiAgdG9rZW5EYXRhOiBcIjFSflJ3WF4jbHBxI2xxciRhcnMkdHN0JWh1diVzd3gleHh5Jmd5eiZsensmcXt8JnZ8fSZ9fSFPJ1MhTyFQJ1ohUCFRKFohUSFSKGAhUiFbKVchWyFdLXIhXiFfLm4hXyFgLnshYCFhL2IhYiFjL28hYyF9L3QhfSNPMFsjUCNRMGEjUSNSMGYjUiNTL3QjUyNUMGsjVCNvL3QjbyNwMHcjcSNyMHwjeSN6I2wkZiRnI2wjQlkjQlojbCRJUyRJXyNsJEl8JEpPI2wkSlQkSlUjbCRLViRLVyNsJkZVJkZWI2x+I3FZJFp+WF4jbHBxI2wjeSN6I2wkZiRnI2wjQlkjQlojbCRJUyRJXyNsJEl8JEpPI2wkSlQkSlUjbCRLViRLVyNsJkZVJkZWI2x+JGRRIV8hYCRqI3IjcyRvfiRvTyFWfn4kdE8kUX5+JHlVI3R+T1kkdFpyJHRycyVdcyNPJHQjTyNQJWIjUH4kdH4lYk8jdH5+JWVQT34kdH4lbVFrfk9ZJWhafiVofiV4T31+fiV9VSN0fk9ZJXhadyV4d3glXXgjTyV4I08jUCZhI1B+JXh+JmRQT34leH4mbE8kW35+JnFPJF5+fiZ2T3t+UiZ9TyV2UCFPUX4nU08kXX5SJ1pPJXVQIVBRUCdeUCFRIVsnYVAnZlIld1AhUSFbJ2EhZyFoJ28jWCNZJ29QJ3JSe3wne30hTyd7IVEhWyhSUChPUCFRIVsoUlAoV1Ald1AhUSFbKFJ+KGBPfH5SKGVaJXdQIU8hUCdhIVEhWylXIWchaCdvI1cjWCl7I1gjWSdvI1sjXSpkI2EjYip4I2cjaCtsI2sjbCt9I2wjbS1XI20jbixpUildWSV3UCFPIVAnYSFRIVspVyFnIWgnbyNXI1gpeyNYI1knbyNbI10qZCNhI2IqeCNnI2grbCNrI2wrfSNtI24saVEqUVAjcFEhUSFbKlRRKldTIVEhWypUI1sjXSpkI2EjYip4I2cjaCtsUSppUCNwUSFRIVsqbFEqb1IhUSFbKmwjYSNiKngjZyNoK2xRKn1RI3BRIVEhWytUI2cjaCtnUStXUiFRIVsrVCNhI2IrYSNnI2grbFErZFAjZyNoK2dRK2xPI3BRUStxUCNwUSFRIVsrdFErd1EhUSFbK3QjYSNiK2FRLFNQI3BRIVEhWyxWUSxZVCFRIVssViNXI1gpeyNbI10qZCNhI2IqeCNnI2grbFEsblAjcFEhUSFbLHFRLHRVIVEhWyxxI1cjWCl7I1sjXSpkI2EjYip4I2cjaCtsI2sjbCt9UC1aUiFRIVstZCFjIWktZCNUI1otZFAtaVIld1AhUSFbLWQhYyFpLWQjVCNaLWRWLXlUJXhTIVpSIVEhWy5ZIVshXS5ZIWMhfS5ZI1IjUy5ZI1Qjby5ZUi5fVCFaUiFRIVsuWSFbIV0uWSFjIX0uWSNSI1MuWSNUI28uWX4uc1AhVX4hXyFgLnZ+LntPIVR+fi9RUSRPUCFfIWAvVyNyI3MvXVEvXU8hUVF+L2JPJFB+fi9nUCFTfiFfIWAvan4vb08hUn5+L3RPJFN+Vi97VCFaUnRTIVEhWy90IVshXS5ZIWMhfS90I1IjUy90I1Qjby90fjBhTyVzfn4wZk8ldH5+MGtPeH5+MG5STyNTMGsjUyNUJV0jVH4wa34wfE8leX5+MVJPJXp+XCIsXG4gIHRva2VuaXplcnM6IFswLCAxLCAyXSxcbiAgdG9wUnVsZXM6IHtcIlByb21RTFwiOlswLDI4XSxcIk1ldHJpY05hbWVcIjpbMSwxNDRdfSxcbiAgc3BlY2lhbGl6ZWQ6IFt7dGVybTogNTcsIGdldDogKHZhbHVlLCBzdGFjaykgPT4gKHNwZWNpYWxpemVJZGVudGlmaWVyKHZhbHVlKSA8PCAxKX0se3Rlcm06IDU3LCBnZXQ6ICh2YWx1ZSwgc3RhY2spID0+IChleHRlbmRJZGVudGlmaWVyKHZhbHVlKSA8PCAxKSB8IDF9LHt0ZXJtOiA1NywgZ2V0OiB2YWx1ZSA9PiBzcGVjX0lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogMFxufSk7XG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IFxuICBpbmYkMSA9IDE0NixcbiAgbmFuJDEgPSAxNDcsXG4gIEJvb2wkMSA9IDEsXG4gIElnbm9yaW5nJDEgPSAyLFxuICBPbiQxID0gMyxcbiAgR3JvdXBMZWZ0JDEgPSA0LFxuICBHcm91cFJpZ2h0JDEgPSA1LFxuICBPZmZzZXQkMSA9IDYsXG4gIEF0YW4yJDEgPSA3LFxuICBBdmckMSA9IDgsXG4gIEJvdHRvbWskMSA9IDksXG4gIENvdW50JDEgPSAxMCxcbiAgQ291bnRWYWx1ZXMkMSA9IDExLFxuICBHcm91cCQxID0gMTIsXG4gIE1heCQxID0gMTMsXG4gIE1pbiQxID0gMTQsXG4gIFF1YW50aWxlJDEgPSAxNSxcbiAgU3RkZGV2JDEgPSAxNixcbiAgU3RkdmFyJDEgPSAxNyxcbiAgU3VtJDEgPSAxOCxcbiAgVG9wayQxID0gMTksXG4gIEJ5JDEgPSAyMCxcbiAgV2l0aG91dCQxID0gMjEsXG4gIEFuZCQxID0gMjIsXG4gIE9yJDEgPSAyMyxcbiAgVW5sZXNzJDEgPSAyNCxcbiAgU3RhcnQkMSA9IDI1LFxuICBFbmQkMSA9IDI2LFxuICBMaW5lQ29tbWVudCA9IDI3LFxuICBQcm9tUUwgPSAyOCxcbiAgRXhwciA9IDI5LFxuICBBZ2dyZWdhdGVFeHByID0gMzAsXG4gIEFnZ3JlZ2F0ZU9wID0gMzEsXG4gIEFnZ3JlZ2F0ZU1vZGlmaWVyID0gMzIsXG4gIEdyb3VwaW5nTGFiZWxzID0gMzMsXG4gIEdyb3VwaW5nTGFiZWxMaXN0ID0gMzQsXG4gIEdyb3VwaW5nTGFiZWwgPSAzNSxcbiAgTGFiZWxOYW1lID0gMzYsXG4gIEZ1bmN0aW9uQ2FsbEJvZHkgPSAzNyxcbiAgRnVuY3Rpb25DYWxsQXJncyA9IDM4LFxuICBCaW5hcnlFeHByID0gMzksXG4gIFBvdyA9IDQwLFxuICBCaW5Nb2RpZmllcnMgPSA0MSxcbiAgT25Pcklnbm9yaW5nID0gNDIsXG4gIE11bCA9IDQzLFxuICBEaXYgPSA0NCxcbiAgTW9kID0gNDUsXG4gIEFkZCA9IDQ2LFxuICBTdWIgPSA0NyxcbiAgRXFsID0gNDgsXG4gIEd0ZSA9IDQ5LFxuICBHdHIgPSA1MCxcbiAgTHRlID0gNTEsXG4gIExzcyA9IDUyLFxuICBOZXEgPSA1MyxcbiAgRnVuY3Rpb25DYWxsID0gNTQsXG4gIEZ1bmN0aW9uSWRlbnRpZmllciA9IDU1LFxuICBBYnNlbnRPdmVyVGltZSA9IDU2LFxuICBJZGVudGlmaWVyID0gNTcsXG4gIEFic2VudCA9IDU4LFxuICBBYnMgPSA1OSxcbiAgQWNvcyA9IDYwLFxuICBBY29zaCA9IDYxLFxuICBBc2luID0gNjIsXG4gIEFzaW5oID0gNjMsXG4gIEF0YW4gPSA2NCxcbiAgQXRhbmggPSA2NSxcbiAgQXZnT3ZlclRpbWUgPSA2NixcbiAgQ2VpbCA9IDY3LFxuICBDaGFuZ2VzID0gNjgsXG4gIENsYW1wID0gNjksXG4gIENsYW1wTWF4ID0gNzAsXG4gIENsYW1wTWluID0gNzEsXG4gIENvcyA9IDcyLFxuICBDb3NoID0gNzMsXG4gIENvdW50T3ZlclRpbWUgPSA3NCxcbiAgRGF5c0luTW9udGggPSA3NSxcbiAgRGF5T2ZNb250aCA9IDc2LFxuICBEYXlPZldlZWsgPSA3NyxcbiAgRGVnID0gNzgsXG4gIERlbHRhID0gNzksXG4gIERlcml2ID0gODAsXG4gIEV4cCA9IDgxLFxuICBGbG9vciA9IDgyLFxuICBIaXN0b2dyYW1RdWFudGlsZSA9IDgzLFxuICBIb2x0V2ludGVycyA9IDg0LFxuICBIb3VyID0gODUsXG4gIElkZWx0YSA9IDg2LFxuICBJbmNyZWFzZSA9IDg3LFxuICBJcmF0ZSA9IDg4LFxuICBMYWJlbFJlcGxhY2UgPSA4OSxcbiAgTGFiZWxKb2luID0gOTAsXG4gIExhc3RPdmVyVGltZSA9IDkxLFxuICBMbiA9IDkyLFxuICBMb2cxMCA9IDkzLFxuICBMb2cyID0gOTQsXG4gIE1heE92ZXJUaW1lID0gOTUsXG4gIE1pbk92ZXJUaW1lID0gOTYsXG4gIE1pbnV0ZSA9IDk3LFxuICBNb250aCA9IDk4LFxuICBQaSA9IDk5LFxuICBQcmVkaWN0TGluZWFyID0gMTAwLFxuICBQcmVzZW50T3ZlclRpbWUgPSAxMDEsXG4gIFF1YW50aWxlT3ZlclRpbWUgPSAxMDIsXG4gIFJhZCA9IDEwMyxcbiAgUmF0ZSA9IDEwNCxcbiAgUmVzZXRzID0gMTA1LFxuICBSb3VuZCA9IDEwNixcbiAgU2NhbGFyID0gMTA3LFxuICBTZ24gPSAxMDgsXG4gIFNpbiA9IDEwOSxcbiAgU2luaCA9IDExMCxcbiAgU29ydCA9IDExMSxcbiAgU29ydERlc2MgPSAxMTIsXG4gIFNxcnQgPSAxMTMsXG4gIFN0ZGRldk92ZXJUaW1lID0gMTE0LFxuICBTdGR2YXJPdmVyVGltZSA9IDExNSxcbiAgU3VtT3ZlclRpbWUgPSAxMTYsXG4gIFRhbiA9IDExNyxcbiAgVGFuaCA9IDExOCxcbiAgVGltZXN0YW1wID0gMTE5LFxuICBUaW1lID0gMTIwLFxuICBWZWN0b3IgPSAxMjEsXG4gIFllYXIgPSAxMjIsXG4gIE1hdHJpeFNlbGVjdG9yID0gMTIzLFxuICBEdXJhdGlvbiA9IDEyNCxcbiAgTnVtYmVyTGl0ZXJhbCA9IDEyNSxcbiAgT2Zmc2V0RXhwciA9IDEyNixcbiAgUGFyZW5FeHByID0gMTI3LFxuICBTdHJpbmdMaXRlcmFsID0gMTI4LFxuICBTdWJxdWVyeUV4cHIgPSAxMjksXG4gIFVuYXJ5RXhwciA9IDEzMCxcbiAgVW5hcnlPcCA9IDEzMSxcbiAgVmVjdG9yU2VsZWN0b3IgPSAxMzIsXG4gIE1ldHJpY0lkZW50aWZpZXIgPSAxMzMsXG4gIExhYmVsTWF0Y2hlcnMgPSAxMzQsXG4gIExhYmVsTWF0Y2hMaXN0ID0gMTM1LFxuICBMYWJlbE1hdGNoZXIgPSAxMzYsXG4gIE1hdGNoT3AgPSAxMzcsXG4gIEVxbFNpbmdsZSA9IDEzOCxcbiAgRXFsUmVnZXggPSAxMzksXG4gIE5lcVJlZ2V4ID0gMTQwLFxuICBTdGVwSW52YXJpYW50RXhwciA9IDE0MSxcbiAgQXQgPSAxNDIsXG4gIEF0TW9kaWZpZXJQcmVwcm9jZXNzb3JzID0gMTQzLFxuICBNZXRyaWNOYW1lID0gMTQ0O1xuXG5leHBvcnQgeyBBYnMsIEFic2VudCwgQWJzZW50T3ZlclRpbWUsIEFjb3MsIEFjb3NoLCBBZGQsIEFnZ3JlZ2F0ZUV4cHIsIEFnZ3JlZ2F0ZU1vZGlmaWVyLCBBZ2dyZWdhdGVPcCwgQW5kJDEgYXMgQW5kLCBBc2luLCBBc2luaCwgQXQsIEF0TW9kaWZpZXJQcmVwcm9jZXNzb3JzLCBBdGFuLCBBdGFuMiQxIGFzIEF0YW4yLCBBdGFuaCwgQXZnJDEgYXMgQXZnLCBBdmdPdmVyVGltZSwgQmluTW9kaWZpZXJzLCBCaW5hcnlFeHByLCBCb29sJDEgYXMgQm9vbCwgQm90dG9tayQxIGFzIEJvdHRvbWssIEJ5JDEgYXMgQnksIENlaWwsIENoYW5nZXMsIENsYW1wLCBDbGFtcE1heCwgQ2xhbXBNaW4sIENvcywgQ29zaCwgQ291bnQkMSBhcyBDb3VudCwgQ291bnRPdmVyVGltZSwgQ291bnRWYWx1ZXMkMSBhcyBDb3VudFZhbHVlcywgRGF5T2ZNb250aCwgRGF5T2ZXZWVrLCBEYXlzSW5Nb250aCwgRGVnLCBEZWx0YSwgRGVyaXYsIERpdiwgRHVyYXRpb24sIEVuZCQxIGFzIEVuZCwgRXFsLCBFcWxSZWdleCwgRXFsU2luZ2xlLCBFeHAsIEV4cHIsIEZsb29yLCBGdW5jdGlvbkNhbGwsIEZ1bmN0aW9uQ2FsbEFyZ3MsIEZ1bmN0aW9uQ2FsbEJvZHksIEZ1bmN0aW9uSWRlbnRpZmllciwgR3JvdXAkMSBhcyBHcm91cCwgR3JvdXBMZWZ0JDEgYXMgR3JvdXBMZWZ0LCBHcm91cFJpZ2h0JDEgYXMgR3JvdXBSaWdodCwgR3JvdXBpbmdMYWJlbCwgR3JvdXBpbmdMYWJlbExpc3QsIEdyb3VwaW5nTGFiZWxzLCBHdGUsIEd0ciwgSGlzdG9ncmFtUXVhbnRpbGUsIEhvbHRXaW50ZXJzLCBIb3VyLCBJZGVsdGEsIElkZW50aWZpZXIsIElnbm9yaW5nJDEgYXMgSWdub3JpbmcsIEluY3JlYXNlLCBJcmF0ZSwgTGFiZWxKb2luLCBMYWJlbE1hdGNoTGlzdCwgTGFiZWxNYXRjaGVyLCBMYWJlbE1hdGNoZXJzLCBMYWJlbE5hbWUsIExhYmVsUmVwbGFjZSwgTGFzdE92ZXJUaW1lLCBMaW5lQ29tbWVudCwgTG4sIExvZzEwLCBMb2cyLCBMc3MsIEx0ZSwgTWF0Y2hPcCwgTWF0cml4U2VsZWN0b3IsIE1heCQxIGFzIE1heCwgTWF4T3ZlclRpbWUsIE1ldHJpY0lkZW50aWZpZXIsIE1ldHJpY05hbWUsIE1pbiQxIGFzIE1pbiwgTWluT3ZlclRpbWUsIE1pbnV0ZSwgTW9kLCBNb250aCwgTXVsLCBOZXEsIE5lcVJlZ2V4LCBOdW1iZXJMaXRlcmFsLCBPZmZzZXQkMSBhcyBPZmZzZXQsIE9mZnNldEV4cHIsIE9uJDEgYXMgT24sIE9uT3JJZ25vcmluZywgT3IkMSBhcyBPciwgUGFyZW5FeHByLCBQaSwgUG93LCBQcmVkaWN0TGluZWFyLCBQcmVzZW50T3ZlclRpbWUsIFByb21RTCwgUXVhbnRpbGUkMSBhcyBRdWFudGlsZSwgUXVhbnRpbGVPdmVyVGltZSwgUmFkLCBSYXRlLCBSZXNldHMsIFJvdW5kLCBTY2FsYXIsIFNnbiwgU2luLCBTaW5oLCBTb3J0LCBTb3J0RGVzYywgU3FydCwgU3RhcnQkMSBhcyBTdGFydCwgU3RkZGV2JDEgYXMgU3RkZGV2LCBTdGRkZXZPdmVyVGltZSwgU3RkdmFyJDEgYXMgU3RkdmFyLCBTdGR2YXJPdmVyVGltZSwgU3RlcEludmFyaWFudEV4cHIsIFN0cmluZ0xpdGVyYWwsIFN1YiwgU3VicXVlcnlFeHByLCBTdW0kMSBhcyBTdW0sIFN1bU92ZXJUaW1lLCBUYW4sIFRhbmgsIFRpbWUsIFRpbWVzdGFtcCwgVG9wayQxIGFzIFRvcGssIFVuYXJ5RXhwciwgVW5hcnlPcCwgVW5sZXNzJDEgYXMgVW5sZXNzLCBWZWN0b3IsIFZlY3RvclNlbGVjdG9yLCBXaXRob3V0JDEgYXMgV2l0aG91dCwgWWVhciwgaW5mJDEgYXMgaW5mLCBuYW4kMSBhcyBuYW4sIHBhcnNlciB9O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsIi8vIEZJWE1FIHByb2ZpbGUgYWRkaW5nIGEgcGVyLVRyZWUgVHJlZU5vZGUgY2FjaGUsIHZhbGlkYXRpbmcgaXQgYnlcbi8vIHBhcmVudCBwb2ludGVyXG4vLy8gVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZSAoMTAyNCkuXG5jb25zdCBEZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTAyNDtcbmxldCBuZXh0UHJvcElEID0gMDtcbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuLy8vIEVhY2ggW25vZGUgdHlwZV0oI2NvbW1vbi5Ob2RlVHlwZSkgb3IgW2luZGl2aWR1YWwgdHJlZV0oI2NvbW1vbi5UcmVlKVxuLy8vIGNhbiBoYXZlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBpdCBpbiBwcm9wcy4gSW5zdGFuY2VzIG9mIHRoaXNcbi8vLyBjbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbmNsYXNzIE5vZGVQcm9wIHtcbiAgICAvLy8gQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0UHJvcElEKys7XG4gICAgICAgIHRoaXMucGVyTm9kZSA9ICEhY29uZmlnLnBlck5vZGU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBjb25maWcuZGVzZXJpYWxpemUgfHwgKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgZGVmaW5lIGEgZGVzZXJpYWxpemUgZnVuY3Rpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy8gVGhpcyBpcyBtZWFudCB0byBiZSB1c2VkIHdpdGhcbiAgICAvLy8gW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgLy8vIFtgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLlBhcnNlckNvbmZpZy5wcm9wcykgdG8gY29tcHV0ZVxuICAgIC8vLyBwcm9wIHZhbHVlcyBmb3IgZWFjaCBub2RlIHR5cGUgaW4gdGhlIHNldC4gVGFrZXMgYSBbbWF0Y2hcbiAgICAvLy8gb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgLy8vIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICAgIC8vLyBpdCBkb2VzLlxuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIFByb3AgdGhhdCBpcyB1c2VkIHRvIGRlc2NyaWJlIG1hdGNoaW5nIGRlbGltaXRlcnMuIEZvciBvcGVuaW5nXG4vLy8gZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbi8vLyBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nIHdoZW4gZGVjbGFyaW5nIHRoaXMgcHJvcCBpbiBhIGdyYW1tYXIpXG4vLy8gZm9yIHRoZSBub2RlIHR5cGVzIG9mIGNsb3NpbmcgZGVsaW1pdGVycyB0aGF0IG1hdGNoIGl0LlxuTm9kZVByb3AuY2xvc2VkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vLy8gVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG4vLy8gYXR0YWNoZWQgdG8gY2xvc2luZyBkZWxpbWl0ZXJzLCBob2xkaW5nIGFuIGFycmF5IG9mIG5vZGUgbmFtZXNcbi8vLyBvZiB0eXBlcyBvZiBtYXRjaGluZyBvcGVuaW5nIGRlbGltaXRlcnMuXG5Ob2RlUHJvcC5vcGVuZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBVc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG4vLy8gdHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxuLy8vIGBcIkV4cHJlc3Npb25cImAgZ3JvdXApLlxuTm9kZVByb3AuZ3JvdXAgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vLy8gVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG4vLy8gdGhhdCB0aGUgbm9kZSB3YXMgcGFyc2VkIGluLCBpZiBhbnkuIFVzZWQgdG8gbGltaXQgcmV1c2Ugb2Zcbi8vLyBjb250ZXh0dWFsIG5vZGVzLlxuTm9kZVByb3AuY29udGV4dEhhc2ggPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIFRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbi8vLyBsb29rZWQgYWhlYWQgZm9yIGFueSBvZiB0aGUgdG9rZW5zIGluc2lkZSB0aGUgbm9kZS4gKFRoZSBMUlxuLy8vIHBhcnNlciBvbmx5IHN0b3JlcyB0aGlzIHdoZW4gaXQgaXMgbGFyZ2VyIHRoYW4gMjUsIGZvclxuLy8vIGVmZmljaWVuY3kgcmVhc29ucy4pXG5Ob2RlUHJvcC5sb29rQWhlYWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIFRoaXMgcGVyLW5vZGUgcHJvcCBpcyB1c2VkIHRvIHJlcGxhY2UgYSBnaXZlbiBub2RlLCBvciBwYXJ0IG9mIGFcbi8vLyBub2RlLCB3aXRoIGFub3RoZXIgdHJlZS4gVGhpcyBpcyB1c2VmdWwgdG8gaW5jbHVkZSB0cmVlcyBmcm9tXG4vLy8gZGlmZmVyZW50IGxhbmd1YWdlcy5cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIEEgbW91bnRlZCB0cmVlLCB3aGljaCBjYW4gYmUgW3N0b3JlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBvblxuLy8vIGEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG4vLy8gcmVwcmVzZW50ZWQgYnkgYW5vdGhlciB0cmVlLlxuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgaW5uZXIgdHJlZS5cbiAgICB0cmVlLCBcbiAgICAvLy8gSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgLy8vIGJlIGluY2x1ZGVkIGluIHRoZSByZWd1bGFyIGl0ZXJhdGlvbiBpbnN0ZWFkIG9mIGl0cyBob3N0XG4gICAgLy8vIG5vZGUpLiBJZiBub3QsIG9ubHkgdGhlIGdpdmVuIHJhbmdlcyBhcmUgY29uc2lkZXJlZCB0byBiZVxuICAgIC8vLyBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIC8vLyBhIHdheSB0aGF0IGlzbid0IHN0cmljdGx5IGhpZXJhcmNoaWNhbC4gU3VjaCBtb3VudGVkIHRyZWVzIGFyZVxuICAgIC8vLyBvbmx5IGVudGVyZWQgYnkgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKVxuICAgIC8vLyBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgb3ZlcmxheSwgXG4gICAgLy8vIFRoZSBwYXJzZXIgdXNlZCB0byBjcmVhdGUgdGhpcyBzdWJ0cmVlLlxuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG59XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vLyBFYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZS4gTm90IG5lY2Vzc2FyaWx5IHVuaXF1ZSwgYnV0IGlmIHRoZVxuICAgIC8vLyBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIC8vLyBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICAvLy8gcm9sZS5cbiAgICBuYW1lLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcHJvcHMsIFxuICAgIC8vLyBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIC8vLyB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgaWQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBUb3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIFNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZXMgYSBub2RlIHByb3AgZm9yIHRoaXMgdHlwZS4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWZcbiAgICAvLy8gdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIGlzIHRoZSB0b3Agbm9kZSBvZiBhIGdyYW1tYXIuXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFRvcCAqLykgPiAwOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgZ2V0IGlzU2tpcHBlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBTa2lwcGVkICovKSA+IDA7IH1cbiAgICAvLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIEVycm9yICovKSA+IDA7IH1cbiAgICAvLy8gV2hlbiB0cnVlLCB0aGlzIG5vZGUgdHlwZSBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gYSB1c2VyLWRlY2xhcmVkXG4gICAgLy8vIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBBbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8vLyBSZXR1cm5zIHRydWUgd2hlbiB0aGlzIG5vZGUncyBuYW1lIG9yIG9uZSBvZiBpdHNcbiAgICAvLy8gW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLiBZb3UgY2FuIHB1dCBtdWx0aXBsZVxuICAgIC8vLyBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICAvLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICBzdGF0aWMgbWF0Y2gobWFwKSB7XG4gICAgICAgIGxldCBkaXJlY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgZGlyZWN0W25hbWVdID0gbWFwW3Byb3BdO1xuICAgICAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwcyA9IG5vZGUucHJvcChOb2RlUHJvcC5ncm91cCksIGkgPSAtMTsgaSA8IChncm91cHMgPyBncm91cHMubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpcmVjdFtpIDwgMCA/IG5vZGUubmFtZSA6IGdyb3Vwc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIEFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogQW5vbnltb3VzICovKTtcbi8vLyBBIG5vZGUgc2V0IGhvbGRzIGEgY29sbGVjdGlvbiBvZiBub2RlIHR5cGVzLiBJdCBpcyB1c2VkIHRvXG4vLy8gY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG4vLy8gZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuLy8vIFtoYXNdKCNsci5MUlBhcnNlci5ub2RlU2V0KSBhIG5vZGUgc2V0LCBhbmQgW3RyZWVcbi8vLyBidWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbi8vLyB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheSBzbG90cy5cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8vLyBDcmVhdGUgYSBzZXQgd2l0aCB0aGUgZ2l2ZW4gdHlwZXMuIFRoZSBgaWRgIHByb3BlcnR5IG9mIGVhY2hcbiAgICAvLy8gdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5vZGUgdHlwZXMgaW4gdGhpcyBzZXQsIGJ5IGlkLlxuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICAvLy8gYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBjcmVhdGVkIHdpdGhcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG4vLy8gdHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuLy8vIGNvbnZlbmllbnQgd2F5LlxuLy8vXG4vLy8gU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG4vLy8gb2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG4vLy9cbi8vLyBIb3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xuLy8vIHVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuLy8vIFtgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG4vLy8gYSB2aWV3IG9uIHNvbWUgcGFydCBvZiB0aGlzIGRhdGEgc3RydWN0dXJlLCBhbmQgY2FuIGJlIHVzZWQgdG9cbi8vLyBtb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWUge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHR5cGUgb2YgdGhlIHRvcCBub2RlLlxuICAgIHR5cGUsIFxuICAgIC8vLyBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICBjaGlsZHJlbiwgXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICAvLy8gdGhlIGNoaWxkcmVuLlxuICAgIHBvc2l0aW9ucywgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gUGVyLW5vZGUgW25vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3ApIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgbm9kZS5cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSB0aGlzLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gbW91bnRlZC50cmVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBjaC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gXCIsXCI7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcm9vdGVkIGF0IHRoaXMgdHJlZS4gV2hlblxuICAgIC8vLyBgcG9zYCBpcyBnaXZlbiwgdGhlIGN1cnNvciBpcyBbbW92ZWRdKCNjb21tb24uVHJlZUN1cnNvci5tb3ZlVG8pXG4gICAgLy8vIHRvIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS5cbiAgICBjdXJzb3IocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSAocG9zICE9IG51bGwgJiYgQ2FjaGVkTm9kZS5nZXQodGhpcykpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdXJzb3IubW92ZVRvKHBvcywgc2lkZSk7XG4gICAgICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgdGhhdCwgdW5saWtlIHJlZ3VsYXJcbiAgICAvLy8gY3Vyc29ycywgZG9lc24ndCBza2lwIHRocm91Z2hcbiAgICAvLy8gW2Fub255bW91c10oI2NvbW1vbi5Ob2RlVHlwZS5pc0Fub255bW91cykgbm9kZXMgYW5kIGRvZXNuJ3RcbiAgICAvLy8gYXV0b21hdGljYWxseSBlbnRlciBtb3VudGVkIG5vZGVzLlxuICAgIGZ1bGxDdXJzb3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIDEgLyogRnVsbCAqLyk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIC8vLyB0cmVlLlxuICAgIGdldCB0b3BOb2RlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIC8vLyBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXG4gICAgLy8vIHBvc2l0aW9uLiBJZiAxLCBpdCdsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBzdGFydCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIC8vLyBmcm9tIGJvdGggc2lkZXMuXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gICAgLy8vIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSBub2RlcywgcHJvZHVjaW5nIGEgc3ludGF4IG5vZGVcbiAgICAvLy8gcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgLy8vICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgICAvLy8gdGhlIGhvc3QgdHJlZXMpLlxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgLy8vIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICAvLy8gcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIC8vLyBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIC8vLyBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IoKSwgZ2V0ID0gKCkgPT4gYy5ub2RlOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjLmZyb20gPD0gdG8gJiYgYy50byA+PSBmcm9tICYmIChjLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIoYy50eXBlLCBjLmZyb20sIGMudG8sIGdldCkgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RMZWF2ZSAmJiBsZWF2ZSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoYy50eXBlLCBjLmZyb20sIGMudG8sIGdldCk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gYy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghYy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIFtub2RlIHByb3BdKCNjb21tb24uTm9kZVByb3ApIGZvciB0aGlzXG4gICAgLy8vIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgcHJvcChwcm9wKSB7XG4gICAgICAgIHJldHVybiAhcHJvcC5wZXJOb2RlID8gdGhpcy50eXBlLnByb3AocHJvcCkgOiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1twcm9wLmlkXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5vZGUncyBbcGVyLW5vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3AucGVyTm9kZSkgaW4gYVxuICAgIC8vLyBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgLy8vIGNvbnN0cnVjdG9yLlxuICAgIGdldCBwcm9wVmFsdWVzKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5wcm9wcylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbK2lkLCB0aGlzLnByb3BzW2lkXV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIC8vLyB3aGljaCBtYXkgaGF2ZSBjaGlsZHJlbiBncm91cGVkIGludG8gc3VidHJlZXMgd2l0aCB0eXBlXG4gICAgLy8vIFtgTm9kZVR5cGUubm9uZWBdKCNjb21tb24uTm9kZVR5cGVebm9uZSkuXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCcmFuY2hGYWN0b3IgKi8gPyB0aGlzIDpcbiAgICAgICAgICAgIGJhbGFuY2VSYW5nZShOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIHRoaXMubGVuZ3RoLCAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgdGhpcy5wcm9wVmFsdWVzKSwgY29uZmlnLm1ha2VUcmVlIHx8ICgoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vLyBCdWlsZCBhIHRyZWUgZnJvbSBhIHBvc3RmaXgtb3JkZXJlZCBidWZmZXIgb2Ygbm9kZSBpbmZvcm1hdGlvbixcbiAgICAvLy8gb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8vLyBUaGUgZW1wdHkgdHJlZVxuVHJlZS5lbXB0eSA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgMCk7XG5jbGFzcyBGbGF0QnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIGdldCBwb3MoKSB7IHJldHVybiB0aGlzLmluZGV4OyB9XG4gICAgbmV4dCgpIHsgdGhpcy5pbmRleCAtPSA0OyB9XG4gICAgZm9yaygpIHsgcmV0dXJuIG5ldyBGbGF0QnVmZmVyQ3Vyc29yKHRoaXMuYnVmZmVyLCB0aGlzLmluZGV4KTsgfVxufVxuLy8vIFRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbi8vLyBub2RlLiBJbiBzdWNoIGEgYnVmZmVyLCBub2RlcyBhcmUgc3RvcmVkIGluIHByZWZpeCBvcmRlciAocGFyZW50c1xuLy8vIGJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG4vLy8gY2hpbGRyZW4gYmVsb25nIHRvIGl0KVxuY2xhc3MgVHJlZUJ1ZmZlciB7XG4gICAgLy8vIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgYnVmZmVyJ3MgY29udGVudC5cbiAgICBidWZmZXIsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBncm91cCBvZiBub2RlcyBpbiB0aGUgYnVmZmVyLlxuICAgIGxlbmd0aCwgXG4gICAgLy8vIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgIHNldCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGg7KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNoaWxkU3RyaW5nKGluZGV4KSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuYnVmZmVyW2luZGV4XSwgZW5kSW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xuICAgICAgICBpZiAoL1xcVy8udGVzdChyZXN1bHQpICYmICF0eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAoZW5kSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBcIihcIiArIGNoaWxkcmVuLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCB0byAtIGZyb20sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIEJlZm9yZSAqLzogcmV0dXJuIGZyb20gPCBwb3M7XG4gICAgICAgIGNhc2UgLTEgLyogQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIEF0T3JBZnRlciAqLzogcmV0dXJuIGZyb20gPD0gcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDIgLyogQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIERvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShub2RlLCBwb3MpIHtcbiAgICBsZXQgc2NhbiA9IG5vZGUuY2hpbGRCZWZvcmUocG9zKTtcbiAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xuICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUobm9kZSwgcG9zLCBzaWRlLCBvdmVybGF5cykge1xuICAgIHZhciBfYTtcbiAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICB3aGlsZSAobm9kZS5mcm9tID09IG5vZGUudG8gfHxcbiAgICAgICAgKHNpZGUgPCAxID8gbm9kZS5mcm9tID49IHBvcyA6IG5vZGUuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgKHNpZGUgPiAtMSA/IG5vZGUudG8gPD0gcG9zIDogbm9kZS50byA8IHBvcykpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICFvdmVybGF5cyAmJiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgbm9kZS5pbmRleCA8IDAgPyBudWxsIDogbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8vIE11c3QgZ28gdXAgb3V0IG9mIG92ZXJsYXlzIHdoZW4gdGhvc2UgZG8gbm90IG92ZXJsYXAgd2l0aCBwb3NcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBwYXJlbnQgPSBzY2FuLnBhcmVudDsgcGFyZW50OyBzY2FuID0gcGFyZW50LCBwYXJlbnQgPSBzY2FuLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHNjYW4gaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBzY2FuLmluZGV4IDwgMCAmJiAoKF9hID0gcGFyZW50LmVudGVyKHBvcywgc2lkZSwgdHJ1ZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAhPSBzY2FuLmZyb20pXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIF9mcm9tLCBcbiAgICAvLyBJbmRleCBpbiBwYXJlbnQgbm9kZSwgc2V0IHRvIC0xIGlmIHRoZSBub2RlIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBfcGFyZW50Lm5vZGUgKG92ZXJsYXkpXG4gICAgaW5kZXgsIF9wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5fZnJvbSA9IF9mcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5ub2RlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMubm9kZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuX2Zyb207IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLl9mcm9tICsgdGhpcy5ub2RlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5ub2RlLCBlID0gZGlyID4gMCA/IGNoaWxkcmVuLmxlbmd0aCA6IC0xOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltpXSwgc3RhcnQgPSBwb3NpdGlvbnNbaV0gKyBwYXJlbnQuX2Zyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIDIgLyogTm9FbnRlckJ1ZmZlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgcG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobW9kZSAmIDEgLyogRnVsbCAqLykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgMSAvKiBGdWxsICovKSAmJiBuZXh0LnByb3BzICYmIChtb3VudGVkID0gbmV4dC5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobW9kZSAmIDEgLyogRnVsbCAqLykgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgMiAvKiBBZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cyA9IHRydWUsIGJ1ZmZlcnMgPSB0cnVlKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAob3ZlcmxheXMgJiYgKG1vdW50ZWQgPSB0aGlzLm5vZGUucHJvcChOb2RlUHJvcC5tb3VudGVkKSkgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgclBvcyA9IHBvcyAtIHRoaXMuZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPiAwID8gZnJvbSA8PSByUG9zIDogZnJvbSA8IHJQb3MpICYmXG4gICAgICAgICAgICAgICAgICAgIChzaWRlIDwgMCA/IHRvID49IHJQb3MgOiB0byA+IHJQb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgbW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyB0aGlzLmZyb20sIC0xLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCBzaWRlLCBidWZmZXJzID8gMCA6IDIgLyogTm9FbnRlckJ1ZmZlciAqLyk7XG4gICAgfVxuICAgIG5leHRTaWduaWZpY2FudFBhcmVudCgpIHtcbiAgICAgICAgbGV0IHZhbCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh2YWwudHlwZS5pc0Fub255bW91cyAmJiB2YWwuX3BhcmVudClcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fcGFyZW50O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCArIDEsIDEsIDAsIDQgLyogRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBjdXJzb3IoKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzKTsgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5ub2RlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5ub2RlOyB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcykgeyByZXR1cm4gZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUodGhpcywgcG9zKTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5ub2RlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IsIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIHdoaWxlICghY3VyLnR5cGUuaXMoYmVmb3JlKSlcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cywgYnVmZmVycyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFidWZmZXJzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgc2lkZSA+IDAgPyAxIDogLTEsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICB9XG4gICAgZXh0ZXJuYWxTaWJsaW5nKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gbnVsbCA6IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dENoaWxkKHRoaXMuY29udGV4dC5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIERvbnRDYXJlICovKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXSwgdG8gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG59XG4vLy8gQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG4vLy8gYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGUuY29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSBub2RlLl9wYXJlbnQ7IG47IG4gPSBuLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG4uaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSwgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuYnVmZmVyLnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihpbmRleCk7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgLy8vIGZhbHNlLCB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIGFuZCB0aGUgY3Vyc29yIGhhcyBub3QgYmVlbiBtb3ZlZC5cbiAgICBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgIGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdCBjaGlsZCB0aGF0IGVuZHMgYWZ0ZXIgYHBvc2AuXG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIDIgLyogQWZ0ZXIgKi8pOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIGxhc3QgY2hpbGQgdGhhdCBzdGFydHMgYmVmb3JlIGBwb3NgLlxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCBwb3MsIC0yIC8qIEJlZm9yZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gICAgLy8vIGNoaWxkIG1heSBlbmQgYXQgdGhhdCBwb3NpdGlvbiwgd2hlbiAxIGl0IG1heSBzdGFydCB0aGVyZS4gVGhpc1xuICAgIC8vLyB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgLy8vIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gICAgLy8vIHNldCB0byBmYWxzZS5cbiAgICBlbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzID0gdHJ1ZSwgYnVmZmVycyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cyAmJiAhKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLyksIGJ1ZmZlcnMpKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnMgPyB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUoKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLykgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaWJsaW5nKGRpcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl90cmVlLl9wYXJlbnQgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLmluZGV4IDwgMCA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBwcmV2aW91cyBzaWJsaW5nLCBpZiBhbnkuXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQubm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLm1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogRG9udENhcmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgLy8vIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcl8oTkxSKSlcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIC8vLyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgLy8vIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICAvLy8gaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIC8vLyBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgLy8vIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUubm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUuY2hpbGRyZW4uc29tZShjaCA9PiBjaCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgIWNoLnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQoY2gpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGJ1ZmZlciwgbm9kZVNldCwgbWF4QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aCwgcmV1c2VkID0gW10sIG1pblJlcGVhdFR5cGUgPSBub2RlU2V0LnR5cGVzLmxlbmd0aCB9ID0gZGF0YTtcbiAgICBsZXQgY3Vyc29yID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gbmV3IEZsYXRCdWZmZXJDdXJzb3IoYnVmZmVyLCBidWZmZXIubGVuZ3RoKSA6IGJ1ZmZlcjtcbiAgICBsZXQgdHlwZXMgPSBub2RlU2V0LnR5cGVzO1xuICAgIGxldCBjb250ZXh0SGFzaCA9IDAsIGxvb2tBaGVhZCA9IDA7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgbGV0IGxvb2tBaGVhZEF0U3RhcnQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHdoaWxlIChzaXplIDwgMCkge1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChzaXplID09IC0xIC8qIFJldXNlICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXVzZWRbaWRdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIExvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnJlY29nbml6ZWQgcmVjb3JkIHNpemU6ICR7c2l6ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2lkXSwgbm9kZSwgYnVmZmVyO1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBzdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPD0gbWF4QnVmZmVyTGVuZ3RoICYmIChidWZmZXIgPSBmaW5kQnVmZmVyU2l6ZShjdXJzb3IucG9zIC0gbWluUG9zLCBpblJlcGVhdCkpKSB7XG4gICAgICAgICAgICAvLyBTbWFsbCBlbm91Z2ggZm9yIGEgYnVmZmVyLCBhbmQgbm8gcmV1c2VkIG5vZGVzIGluc2lkZVxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNpemUgLSBidWZmZXIuc2tpcCk7XG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIGJ1ZmZlci5zaXplLCBpbmRleCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyLnN0YXJ0LCBkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICBub2RlID0gbmV3IFRyZWVCdWZmZXIoZGF0YSwgZW5kIC0gYnVmZmVyLnN0YXJ0LCBub2RlU2V0KTtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gYnVmZmVyLnN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE1ha2UgaXQgYSBub2RlXG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIHNpemU7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBsb2NhbEluUmVwZWF0ID0gaWQgPj0gbWluUmVwZWF0VHlwZSA/IGlkIDogLTE7XG4gICAgICAgICAgICBsZXQgbGFzdEdyb3VwID0gMCwgbGFzdEVuZCA9IGVuZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBjdXJzb3IuaWQgPT0gbG9jYWxJblJlcGVhdCAmJiBjdXJzb3Iuc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZW5kIDw9IGxhc3RFbmQgLSBtYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBjdXJzb3IuZW5kLCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHcm91cCA9IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVuZCA9IGN1cnNvci5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VOb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsb2NhbEluUmVwZWF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGxhc3RHcm91cCA+IDAgJiYgbGFzdEdyb3VwIDwgbG9jYWxDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2UgPSBtYWtlQmFsYW5jZWQodHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUJhbGFuY2VkKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSAwLCBsYXN0SSA9IGNoaWxkcmVuLmxlbmd0aCAtIDEsIGxhc3QsIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICBpZiAobGFzdEkgPj0gMCAmJiAobGFzdCA9IGNoaWxkcmVuW2xhc3RJXSkgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0SSAmJiBsYXN0LnR5cGUgPT0gdHlwZSAmJiBsYXN0Lmxlbmd0aCA9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsb29rQWhlYWRQcm9wID0gbGFzdC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCkpXG4gICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IHBvc2l0aW9uc1tsYXN0SV0gKyBsYXN0Lmxlbmd0aCArIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUmVwZWF0TGVhZihjaGlsZHJlbiwgcG9zaXRpb25zLCBiYXNlLCBpLCBmcm9tLCB0bywgdHlwZSwgbG9va0FoZWFkKSB7XG4gICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggPiBpKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW4ucG9wKCkpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnMucG9wKCkgKyBiYXNlIC0gZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVHJlZShub2RlU2V0LnR5cGVzW3R5cGVdLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgdG8gLSBmcm9tLCBsb29rQWhlYWQgLSB0bykpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gYmFzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkID0gMCwgcHJvcHMpIHtcbiAgICAgICAgaWYgKGNvbnRleHRIYXNoKSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5jb250ZXh0SGFzaCwgY29udGV4dEhhc2hdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiAyNSkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AubG9va0FoZWFkLCBsb29rQWhlYWRdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHByb3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEJ1ZmZlclNpemUobWF4U2l6ZSwgaW5SZXBlYXQpIHtcbiAgICAgICAgLy8gU2NhbiB0aHJvdWdoIHRoZSBidWZmZXIgdG8gZmluZCBwcmV2aW91cyBzaWJsaW5ncyB0aGF0IGZpdFxuICAgICAgICAvLyB0b2dldGhlciBpbiBhIFRyZWVCdWZmZXIsIGFuZCBkb24ndCBjb250YWluIGFueSByZXVzZWQgbm9kZXNcbiAgICAgICAgLy8gKHdoaWNoIGNhbid0IGJlIHN0b3JlZCBpbiBhIGJ1ZmZlcikuXG4gICAgICAgIC8vIElmIGBpblJlcGVhdGAgaXMgPiAtMSwgaWdub3JlIG5vZGUgYm91bmRhcmllcyBvZiB0aGF0IHR5cGUgZm9yXG4gICAgICAgIC8vIG5lc3RpbmcsIGJ1dCBtYWtlIHN1cmUgdGhlIGVuZCBmYWxscyBlaXRoZXIgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIChgbWF4U2l6ZWApIG9yIGJlZm9yZSBzdWNoIGEgbm9kZS5cbiAgICAgICAgbGV0IGZvcmsgPSBjdXJzb3IuZm9yaygpO1xuICAgICAgICBsZXQgc2l6ZSA9IDAsIHN0YXJ0ID0gMCwgc2tpcCA9IDAsIG1pblN0YXJ0ID0gZm9yay5lbmQgLSBtYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHNpemU6IDAsIHN0YXJ0OiAwLCBza2lwOiAwIH07XG4gICAgICAgIHNjYW46IGZvciAobGV0IG1pblBvcyA9IGZvcmsucG9zIC0gbWF4U2l6ZTsgZm9yay5wb3MgPiBtaW5Qb3M7KSB7XG4gICAgICAgICAgICBsZXQgbm9kZVNpemUgPSBmb3JrLnNpemU7XG4gICAgICAgICAgICAvLyBQcmV0ZW5kIG5lc3RlZCByZXBlYXQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBkb24ndCBleGlzdFxuICAgICAgICAgICAgaWYgKGZvcmsuaWQgPT0gaW5SZXBlYXQgJiYgbm9kZVNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgICAgICAgICBza2lwICs9IDQ7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0UG9zID0gZm9yay5wb3MgLSBub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChub2RlU2l6ZSA8IDAgfHwgc3RhcnRQb3MgPCBtaW5Qb3MgfHwgZm9yay5zdGFydCA8IG1pblN0YXJ0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGxvY2FsU2tpcHBlZCA9IGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSA/IDQgOiAwO1xuICAgICAgICAgICAgbGV0IG5vZGVTdGFydCA9IGZvcmsuc3RhcnQ7XG4gICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlIChmb3JrLnBvcyA+IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChzaXplID49IDAgJiYgaWQgPCBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgZGF0YS5idWZmZXJTdGFydCB8fCAwLCBjaGlsZHJlbiwgcG9zaXRpb25zLCAtMSk7XG4gICAgbGV0IGxlbmd0aCA9IChfYSA9IGRhdGEubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoY2hpbGRyZW4ubGVuZ3RoID8gcG9zaXRpb25zWzBdICsgY2hpbGRyZW5bMF0ubGVuZ3RoIDogMCk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKHR5cGVzW2RhdGEudG9wSURdLCBjaGlsZHJlbi5yZXZlcnNlKCksIHBvc2l0aW9ucy5yZXZlcnNlKCksIGxlbmd0aCk7XG59XG5jb25zdCBub2RlU2l6ZUNhY2hlID0gbmV3IFdlYWtNYXA7XG5mdW5jdGlvbiBub2RlU2l6ZShiYWxhbmNlVHlwZSwgbm9kZSkge1xuICAgIGlmICghYmFsYW5jZVR5cGUuaXNBbm9ueW1vdXMgfHwgbm9kZSBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgbm9kZS50eXBlICE9IGJhbGFuY2VUeXBlKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgc2l6ZSA9IG5vZGVTaXplQ2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9IGJhbGFuY2VUeXBlIHx8ICEoY2hpbGQgaW5zdGFuY2VvZiBUcmVlKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVTaXplQ2FjaGUuc2V0KG5vZGUsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VSYW5nZShcbi8vIFRoZSB0eXBlIHRoZSBiYWxhbmNlZCB0cmVlJ3MgaW5uZXIgbm9kZXMuXG5iYWxhbmNlVHlwZSwgXG4vLyBUaGUgZGlyZWN0IGNoaWxkcmVuIGFuZCB0aGVpciBwb3NpdGlvbnNcbmNoaWxkcmVuLCBwb3NpdGlvbnMsIFxuLy8gVGhlIGluZGV4IHJhbmdlIGluIGNoaWxkcmVuL3Bvc2l0aW9ucyB0byB1c2VcbmZyb20sIHRvLCBcbi8vIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgbm9kZXMsIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudC5cbnN0YXJ0LCBcbi8vIExlbmd0aCBvZiB0aGUgb3V0ZXIgbm9kZVxubGVuZ3RoLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIHRoZSB0b3Agbm9kZSBvZiB0aGUgYmFsYW5jZWQgdHJlZVxubWtUb3AsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgaW50ZXJuYWwgbm9kZXMgZm9yIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RyZWUpIHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgICAgdG90YWwgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICBsZXQgbWF4Q2hpbGQgPSBNYXRoLmNlaWwoKHRvdGFsICogMS41KSAvIDggLyogQnJhbmNoRmFjdG9yICovKTtcbiAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBGcm9tID0gaSwgZ3JvdXBTdGFydCA9IHBvc2l0aW9uc1tpXSwgZ3JvdXBTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0U2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSArIG5leHRTaXplID49IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBncm91cFNpemUgKz0gbmV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSA+IG1heENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTsgLy8gT25seSB0cmVlcyBjYW4gaGF2ZSBhIHNpemUgPiAxXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZShvbmx5LmNoaWxkcmVuLCBvbmx5LnBvc2l0aW9ucywgMCwgb25seS5jaGlsZHJlbi5sZW5ndGgsIHBvc2l0aW9uc1tncm91cEZyb21dICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQ7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGJhbGFuY2VSYW5nZShiYWxhbmNlVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZ3JvdXBGcm9tLCBpLCBncm91cFN0YXJ0LCBsZW5ndGgsIG51bGwsIG1rVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0ICsgb2Zmc2V0IC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgMCk7XG4gICAgcmV0dXJuIChta1RvcCB8fCBta1RyZWUpKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsZW5ndGgpO1xufVxuXG4vLy8gVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxuLy8vIHBhcnNpbmddKCNjb21tb24uUGFyc2VyLnN0YXJ0UGFyc2UpIHRvIHRyYWNrIHBhcnRzIG9mIG9sZCB0cmVlc1xuLy8vIHRoYXQgY2FuIGJlIHJldXNlZCBpbiBhIG5ldyBwYXJzZS4gQW4gYXJyYXkgb2YgZnJhZ21lbnRzIGlzIHVzZWRcbi8vLyB0byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbi8vLyBwYXJzZXMuIFVzZSB0aGUgc3RhdGljXG4vLy8gW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0b1xuLy8vIHVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgLy8vIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgLy8vIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICBmcm9tLCBcbiAgICAvLy8gVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgIHRvLCBcbiAgICAvLy8gVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgIHRyZWUsIFxuICAgIC8vLyBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICAvLy8gdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICAvLy8gZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIC8vLyBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgb2Zmc2V0LCBvcGVuU3RhcnQgPSBmYWxzZSwgb3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IChvcGVuU3RhcnQgPyAxIC8qIFN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogRW5kICovIDogMCk7XG4gICAgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgYVxuICAgIC8vLyBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIC8vLyBiZSBzYWZlIHRvIHJldXNlIHNvbWUgbm9kZXMgYXQgdGhlIHN0YXJ0LCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8vIHBhcnNpbmcgYWxnb3JpdGhtLilcbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogU3RhcnQgKi8pID4gMDsgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhXG4gICAgLy8vIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIEVuZCAqLykgPiAwOyB9XG4gICAgLy8vIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIC8vLyBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICAvLy8gd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIC8vLyB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIC8vLyBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgLy8vIHRydWUuXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICAvLy8gc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIC8vLyBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICAvLy8gb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgLy8vIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIC8vL1xuICAgIC8vLyBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIC8vLyB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICAvLy8gcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIC8vLyBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLy8vIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vLy8gQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuLy8vIHNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuLy8vIGZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG4vLy8gYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG4vLy8gdHJlZS5cbi8vL1xuLy8vIFRoZSBuZXN0aW5nIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGN1cnNvciB0byBwcm92aWRlIGNvbnRleHQgZm9yIGFcbi8vLyBub2RlLCBidXQgX3Nob3VsZCBub3RfIG1vdmUgdGhhdCBjdXJzb3IsIG9ubHkgaW5zcGVjdCBpdHNcbi8vLyBwcm9wZXJ0aWVzIGFuZCBvcHRpb25hbGx5IGFjY2VzcyBpdHNcbi8vLyBbbm9kZSBvYmplY3RdKCNjb21tb24uVHJlZUN1cnNvci5ub2RlKS5cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLnJhbmdlc1swXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCAxIC8qIEZ1bGwgKi8pO1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBuZXN0LCBpc0NvdmVyZWQ7IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgfHwgY3Vyc29yLmZyb20gPCB0aGlzLnN0b3BwZWRBdDspIHtcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50Q3Vyc29yLmhhc05vZGUoY3Vyc29yKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IG92ZXJsYXkubW91bnRzLmZpbmQobSA9PiBtLmZyYWcuZnJvbSA8PSBjdXJzb3IuZnJvbSAmJiBtLmZyYWcudG8gPj0gY3Vyc29yLnRvICYmIG0ubW91bnQub3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgbWF0Y2gubW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gci5mcm9tICsgbWF0Y2gucG9zLCB0byA9IHIudG8gKyBtYXRjaC5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPj0gY3Vyc29yLmZyb20gJiYgdG8gPD0gY3Vyc29yLnRvICYmICFvdmVybGF5LnJhbmdlcy5zb21lKHIgPT4gci5mcm9tIDwgdG8gJiYgci50byA+IGZyb20pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3ZlcmVkICYmIChpc0NvdmVyZWQgPSBjaGVja0NvdmVyKGNvdmVyZWQucmFuZ2VzLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKSkpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGlzQ292ZXJlZCAhPSAyIC8qIEZ1bGwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLnR5cGUuaXNBbm9ueW1vdXMgJiYgY3Vyc29yLmZyb20gPCBjdXJzb3IudG8gJiYgKG5lc3QgPSB0aGlzLm5lc3QoY3Vyc29yLCB0aGlzLmlucHV0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbGl6ZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGxldCBvbGRNb3VudHMgPSBmcmFnbWVudEN1cnNvci5maW5kTW91bnRzKGN1cnNvci5mcm9tLCBuZXN0LnBhcnNlcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXN0Lm92ZXJsYXkgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBuZXcgQWN0aXZlT3ZlcmxheShuZXN0LnBhcnNlciwgbmVzdC5vdmVybGF5LCBvbGRNb3VudHMsIHRoaXMuaW5uZXIubGVuZ3RoLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRyZWUsIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBuZXN0Lm92ZXJsYXkgfHwgW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIucHVzaChuZXcgSW5uZXJQYXJzZShuZXN0LnBhcnNlciwgbmVzdC5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvbGRNb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG5lc3Qub3ZlcmxheSA/IG5lc3Qub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gY3Vyc29yLmZyb20sIHIudG8gLSBjdXJzb3IuZnJvbSkpIDogbnVsbCwgY3Vyc29yLnRyZWUsIHJhbmdlcykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5lc3Qub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0geyByYW5nZXMsIGRlcHRoOiAwLCBwcmV2OiBjb3ZlcmVkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAmJiAocmFuZ2UgPSBvdmVybGF5LnByZWRpY2F0ZShjdXJzb3IpKSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPCByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50ZXIgJiYgY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmRlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgJiYgIS0tb3ZlcmxheS5kZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBvdmVybGF5LnJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnNwbGljZShvdmVybGF5LmluZGV4LCAwLCBuZXcgSW5uZXJQYXJzZShvdmVybGF5LnBhcnNlciwgb3ZlcmxheS5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvdmVybGF5Lm1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgb3ZlcmxheS5yYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIG92ZXJsYXkuc3RhcnQsIHIudG8gLSBvdmVybGF5LnN0YXJ0KSksIG92ZXJsYXkudGFyZ2V0LCByYW5nZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSBjb3ZlcmVkLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tDb3Zlcihjb3ZlcmVkLCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIGNvdmVyZWQpIHtcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZnJvbSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIEZ1bGwgKi8gOiAxIC8qIFBhcnRpYWwgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59XG4vLyBUYWtlIGEgcGllY2Ugb2YgYnVmZmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYSBzdGFuZC1hbG9uZVxuLy8gVHJlZUJ1ZmZlci5cbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcbiAgICBpZiAoc3RhcnRJIDwgZW5kSSkge1xuICAgICAgICBsZXQgZnJvbSA9IGJ1Zi5idWZmZXJbc3RhcnRJICsgMV0sIHRvID0gYnVmLmJ1ZmZlcltlbmRJIC0gMl07XG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBkZXB0aCA9IDA7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xuICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgIG9mZiA9IGJhc2UucG9zaXRpb25zW2ldICsgY3Vyc29yLmZyb207XG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBsZXQgaSA9IHN0YXJ0STtcbiAgICAgICAgd2hpbGUgKGJbaSArIDJdICsgb2ZmIDw9IG5vZGUuZnJvbSlcbiAgICAgICAgICAgIGkgPSBiW2kgKyAzXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgaSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbaSArIDFdLCB0byA9IGJbaSArIDJdO1xuICAgICAgICBsZXQgaXNUYXJnZXQgPSBmcm9tICsgb2ZmID09IG5vZGUuZnJvbSAmJiB0byArIG9mZiA9PSBub2RlLnRvICYmIGJbaV0gPT0gbm9kZS50eXBlLmlkO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGlzVGFyZ2V0ID8gbm9kZS50b1RyZWUoKSA6IHNwbGl0KGkgKyA0LCBiW2kgKyAzXSwgYnVmLnNldC50eXBlc1tiW2ldXSwgZnJvbSwgdG8gLSBmcm9tKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XG4gICAgICAgIHNsaWNlQnVmKGJ1ZiwgYltpICsgM10sIGVuZEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIGJhc2UuY2hpbGRyZW5baV0gPSBzcGxpdCgwLCBiLmxlbmd0aCwgTm9kZVR5cGUubm9uZSwgMCwgYnVmLmxlbmd0aCk7XG4gICAgLy8gTW92ZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPD0gZGVwdGg7IGQrKylcbiAgICAgICAgY3Vyc29yLmNoaWxkQWZ0ZXIobm9kZS5mcm9tKTtcbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmZ1bGxDdXJzb3IoKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBmYWxzZSwgZmFsc2UpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLm5leHQoZmFsc2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oY3Vyc29yLmZyb20pO1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSAmJiB0aGlzLmN1cnNvci5mcm9tICsgdGhpcy5vZmZzZXQgPT0gY3Vyc29yLmZyb20gJiYgdGhpcy5jdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSA9IHRoaXMuY3Vyc29yLnRyZWU7Oykge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlID09IGN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJlZS5jaGlsZHJlbi5sZW5ndGggJiYgdHJlZS5wb3NpdGlvbnNbMF0gPT0gMCAmJiB0cmVlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmN1clRvID0gMDtcbiAgICAgICAgdGhpcy5mcmFnSSA9IDA7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmN1ckZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZmlyc3QudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpcnN0LnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZmlyc3QudHJlZSwgLWZpcnN0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VyRnJhZyAmJiBub2RlLmZyb20gPj0gdGhpcy5jdXJUbylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyRnJhZyAmJiB0aGlzLmN1ckZyYWcuZnJvbSA8PSBub2RlLmZyb20gJiYgdGhpcy5jdXJUbyA+PSBub2RlLnRvICYmIHRoaXMuaW5uZXIuaGFzTm9kZShub2RlKTtcbiAgICB9XG4gICAgbmV4dEZyYWcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xuICAgICAgICBpZiAodGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1ckZyYWcgPSB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdJXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmcmFnLnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmcmFnLnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZnJhZy50cmVlLCAtZnJhZy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRNb3VudHMocG9zLCBwYXJzZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyLmN1cnNvci5tb3ZlVG8ocG9zLCAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBtb3VudCA9IChfYSA9IHBvcy50cmVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQucGFyc2VyID09IHBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFnSTsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZnJvbSA+PSBwb3MudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy50cmVlID09IHRoaXMuY3VyRnJhZy50cmVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3MuZnJvbSAtIGZyYWcub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVuY2hSYW5nZXMob3V0ZXIsIHJhbmdlcykge1xuICAgIGxldCBjb3B5ID0gbnVsbCwgY3VycmVudCA9IHJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG91dGVyW2kgLSAxXS50bywgZ2FwVG8gPSBvdXRlcltpXS5mcm9tO1xuICAgICAgICBmb3IgKDsgaiA8IGN1cnJlbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByID0gY3VycmVudFtqXTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gZ2FwVG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA8PSBnYXBGcm9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb3B5ID0gcmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoci5mcm9tIDwgZ2FwRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvcHlbal0gPSBuZXcgUmFuZ2Uoci5mcm9tLCBnYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoci50byA+IGdhcFRvKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqICsgMSwgMCwgbmV3IFJhbmdlKGdhcFRvLCByLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyLnRvID4gZ2FwVG8pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2otLV0gPSBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGZpbmRDb3ZlckNoYW5nZXMoYSwgYiwgZnJvbSwgdG8pIHtcbiAgICBsZXQgaUEgPSAwLCBpQiA9IDAsIGluQSA9IGZhbHNlLCBpbkIgPSBmYWxzZSwgcG9zID0gLTFlOTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbmV4dEEgPSBpQSA9PSBhLmxlbmd0aCA/IDFlOSA6IGluQSA/IGFbaUFdLnRvIDogYVtpQV0uZnJvbTtcbiAgICAgICAgbGV0IG5leHRCID0gaUIgPT0gYi5sZW5ndGggPyAxZTkgOiBpbkIgPyBiW2lCXS50byA6IGJbaUJdLmZyb207XG4gICAgICAgIGlmIChpbkEgIT0gaW5CKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIsIHRvKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IE1hdGgubWluKG5leHRBLCBuZXh0Qik7XG4gICAgICAgIGlmIChwb3MgPT0gMWU5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0QSA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5BKVxuICAgICAgICAgICAgICAgIGluQSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0QiA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5CKVxuICAgICAgICAgICAgICAgIGluQiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBHaXZlbiBhIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoZSBvdXRlciB0cmVlLCBhbmQgYSBzZXQgb2YgcmFuZ2VzXG4vLyB0byBwYXJzZSwgZmluZCBmcmFnbWVudHMgZm9yIGlubmVyIHRyZWVzIG1vdW50ZWQgYXJvdW5kIHRob3NlXG4vLyByYW5nZXMsIGlmIGFueS5cbmZ1bmN0aW9uIGVudGVyRnJhZ21lbnRzKG1vdW50cywgcmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgcG9zLCBtb3VudCwgZnJhZyB9IG9mIG1vdW50cykge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBwb3MgKyAobW91bnQub3ZlcmxheSA/IG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA6IDApLCBlbmRQb3MgPSBzdGFydFBvcyArIG1vdW50LnRyZWUubGVuZ3RoO1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KGZyYWcuZnJvbSwgc3RhcnRQb3MpLCB0byA9IE1hdGgubWluKGZyYWcudG8sIGVuZFBvcyk7XG4gICAgICAgIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxheSA9IG1vdW50Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSArIHBvcywgci50byArIHBvcykpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBmaW5kQ292ZXJDaGFuZ2VzKHJhbmdlcywgb3ZlcmxheSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IGZyb207OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gY2hhbmdlcy5sZW5ndGgsIGVuZCA9IGxhc3QgPyB0byA6IGNoYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KHBvcywgZW5kLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBwb3MsIGZyYWcudG8gPD0gZW5kKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IGNoYW5nZXNbaV0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KGZyb20sIHRvLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBzdGFydFBvcywgZnJhZy50byA8PSBlbmRQb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBNb3VudGVkVHJlZSwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBQYXJzZXIsIFRyZWUsIFRyZWVCdWZmZXIsIFRyZWVDdXJzb3IsIFRyZWVGcmFnbWVudCwgcGFyc2VNaXhlZCB9O1xuIiwiaW1wb3J0IHsgUGFyc2VyLCBOb2RlU2V0LCBOb2RlVHlwZSwgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgTm9kZVByb3AsIFRyZWUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLy8vIEEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xuLy8vIHBhcnNpbmcgcHJvZ3Jlc3MuIFRoZXkgYWxzbyBwcm92aWRlIHNvbWUgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xuLy8vIHRoYXQgZXh0ZXJuYWwgY29kZSBzdWNoIGFzIGEgdG9rZW5pemVyIGNhbiB1c2UgdG8gZ2V0IGluZm9ybWF0aW9uXG4vLy8gYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuY2xhc3MgU3RhY2sge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHBhcnNlIHRoYXQgdGhpcyBzdGFjayBpcyBwYXJ0IG9mIEBpbnRlcm5hbFxuICAgIHAsIFxuICAgIC8vLyBIb2xkcyBzdGF0ZSwgaW5wdXQgcG9zLCBidWZmZXIgaW5kZXggdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSBAaW50ZXJuYWxcbiAgICBzdGFjaywgXG4gICAgLy8vIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgIHN0YXRlLCBcbiAgICAvLyBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIG5leHQgcmVkdWNlIHNob3VsZCB0YWtlIHBsYWNlLiBUaGlzXG4gICAgLy8gY2FuIGJlIGxlc3MgdGhhbiBgdGhpcy5wb3NgIHdoZW4gc2tpcHBlZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgc3RhY2sgKHdoaWNoIHNob3VsZCBiZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBuZXh0XG4gICAgLy8gcmVkdWN0aW9uKVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2VQb3MsIFxuICAgIC8vLyBUaGUgaW5wdXQgcG9zaXRpb24gdXAgdG8gd2hpY2ggdGhpcyBzdGFjayBoYXMgcGFyc2VkLlxuICAgIHBvcywgXG4gICAgLy8vIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIC8vLyBhbmQgZXJyb3ItcmVjb3ZlcnkgcGVuYWx0aWVzXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyQmFzZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGN1ckNvbnRleHQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBsb29rQWhlYWQgPSAwLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcmVudCkge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSByZWR1Y2VQb3M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlckJhc2UgPSBidWZmZXJCYXNlO1xuICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBjdXJDb250ZXh0O1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YWNrLmZpbHRlcigoXywgaSkgPT4gaSAlIDMgPT0gMCkuY29uY2F0KHRoaXMuc3RhdGUpfV1AJHt0aGlzLnBvc30ke3RoaXMuc2NvcmUgPyBcIiFcIiArIHRoaXMuc2NvcmUgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRpYyBzdGFydChwLCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICBsZXQgY3ggPSBwLnBhcnNlci5jb250ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHAsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBjeCA/IG5ldyBTdGFja0NvbnRleHQoY3gsIGN4LnN0YXJ0KSA6IG51bGwsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gVGhlIHN0YWNrJ3MgY3VycmVudCBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyKSB2YWx1ZSwgaWZcbiAgICAvLy8gYW55LiBJdHMgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgY29udGV4dCB0cmFja2VyJ3MgdHlwZVxuICAgIC8vLyBwYXJhbWV0ZXIsIG9yIGl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGNvbnRleHRcbiAgICAvLy8gdHJhY2tlci5cbiAgICBnZXQgY29udGV4dCgpIHsgcmV0dXJuIHRoaXMuY3VyQ29udGV4dCA/IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0IDogbnVsbDsgfVxuICAgIC8vIFB1c2ggYSBzdGF0ZSBvbnRvIHRoZSBzdGFjaywgdHJhY2tpbmcgaXRzIHN0YXJ0IHBvc2l0aW9uIGFzIHdlbGxcbiAgICAvLyBhcyB0aGUgYnVmZmVyIGJhc2UgYXQgdGhhdCBwb2ludC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBsZXQgZFByZWMgPSBwYXJzZXIuZHluYW1pY1ByZWNlZGVuY2UodHlwZSk7XG4gICAgICAgIGlmIChkUHJlYylcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gZFByZWM7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwYXJzZXIuZ2V0R290byh0aGlzLnN0YXRlLCB0eXBlLCB0cnVlKSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLyA/IDYgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFja1tiYXNlIC0gMl07XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gdGhpcy5zdGFja1tiYXNlIC0gMV0sIGNvdW50ID0gdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoIC0gYnVmZmVyQmFzZTtcbiAgICAgICAgLy8gU3RvcmUgbm9ybWFsIHRlcm1zIG9yIGBSIC0+IFIgUmAgcmVwZWF0IHJlZHVjdGlvbnNcbiAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSB8fCAoYWN0aW9uICYgMTMxMDcyIC8qIFJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmFzZVN0YXRlSUQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAzXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJzZXIuZ2V0R290byhiYXNlU3RhdGVJRCwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gYmFzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgfVxuICAgIC8vIFNoaWZ0IGEgdmFsdWUgaW50byB0aGUgYnVmZmVyXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0b3JlTm9kZSh0ZXJtLCBzdGFydCwgZW5kLCBzaXplID0gNCwgaXNSZWR1Y2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGVybSA9PSAwIC8qIEVyciAqLykgeyAvLyBUcnkgdG8gb21pdC9tZXJnZSBhZGphY2VudCBlcnJvciBub2Rlc1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMsIHRvcCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3AgPT0gMCAmJiBjdXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gY3VyLmJ1ZmZlckJhc2UgLSBjdXIucGFyZW50LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgPiAwICYmIGN1ci5idWZmZXJbdG9wIC0gNF0gPT0gMCAvKiBFcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZHVjZSB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSAyXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoaXMgcmVjb3JkIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGhpcy5idWZmZXJbaW5kZXggLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gM107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gdGhpcy5idWZmZXJbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSAtPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRlcm07XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYSBzaGlmdCBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBpZiAoYWN0aW9uICYgMTMxMDcyIC8qIEdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovKSA9PSAwKSB7IC8vIFJlZ3VsYXIgc2hpZnRcbiAgICAgICAgICAgIGxldCBuZXh0U3RhdGUgPSBhY3Rpb24sIHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgICAgICBpZiAobmV4dEVuZCA+IHRoaXMucG9zIHx8IG5leHQgPD0gcGFyc2VyLm1heE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuc3RhdGVGbGFnKG5leHRTdGF0ZSwgMSAvKiBTa2lwcGVkICovKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHN0YXJ0LCBuZXh0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCBzdGFydCwgbmV4dEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGFwcGx5KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLylcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgKHJldXNlZCkgbm9kZSBpbnRvIHRoZSBidWZmZXIuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHVzZU5vZGUodmFsdWUsIG5leHQpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5wLnJldXNlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMucC5yZXVzZWRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnAucmV1c2VkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcyA9IHN0YXJ0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0LCBzdGFydCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5kZXgsIHN0YXJ0LCB0aGlzLnJlZHVjZVBvcywgLTEgLyogc2l6ZSA9PSAtMSBtZWFucyB0aGlzIGlzIGEgcmV1c2VkIHZhbHVlICovKTtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZXVzZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdmFsdWUsIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQodGhpcy5wb3MgLSB2YWx1ZS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IHRoZSBzdGFjay4gRHVlIHRvIHRoZSBidWZmZXIgc2hhcmluZyBhbmQgdGhlIGZhY3RcbiAgICAvLyB0aGF0IGB0aGlzLnN0YWNrYCB0ZW5kcyB0byBzdGF5IHF1aXRlIHNoYWxsb3csIHRoaXMgaXNuJ3QgdmVyeVxuICAgIC8vIGV4cGVuc2l2ZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgb2ZmID0gcGFyZW50LmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHRvcCBvZiB0aGUgYnVmZmVyIChhZnRlciB0aGlzLnBvcykgbWF5IGJlIG11dGF0ZWRcbiAgICAgICAgLy8gdG8gcmVvcmRlciByZWR1Y3Rpb25zIGFuZCBza2lwcGVkIHRva2VucywgYW5kIHNoYXJlZCBidWZmZXJzXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbW11dGFibGUsIHRoaXMgY29waWVzIGFueSBvdXRzdGFuZGluZyBza2lwcGVkIHRva2Vuc1xuICAgICAgICAvLyB0byB0aGUgbmV3IGJ1ZmZlciwgYW5kIHB1dHMgdGhlIGJhc2UgcG9pbnRlciBiZWZvcmUgdGhlbS5cbiAgICAgICAgd2hpbGUgKG9mZiA+IDAgJiYgcGFyZW50LmJ1ZmZlcltvZmYgLSAyXSA+IHBhcmVudC5yZWR1Y2VQb3MpXG4gICAgICAgICAgICBvZmYgLT0gNDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHBhcmVudC5idWZmZXIuc2xpY2Uob2ZmKSwgYmFzZSA9IHBhcmVudC5idWZmZXJCYXNlICsgb2ZmO1xuICAgICAgICAvLyBNYWtlIHN1cmUgcGFyZW50IHBvaW50cyB0byBhbiBhY3R1YWwgcGFyZW50IHdpdGggY29udGVudCwgaWYgdGhlcmUgaXMgc3VjaCBhIHBhcmVudC5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBiYXNlID09IHBhcmVudC5idWZmZXJCYXNlKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayh0aGlzLnAsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHRoaXMuY3VyQ29udGV4dCwgdGhpcy5sb29rQWhlYWQsIHBhcmVudCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5RGVsZXRlKG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IGlzTm9kZSA9IG5leHQgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlO1xuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQsIDQpO1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMTkwIC8qIERlbGV0ZSAqLztcbiAgICB9XG4gICAgLy8vIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICAgIC8vLyBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICAvLy8gZXh0ZXJuYWwgdG9rZW5pemVycyB0aGF0IHdhbnQgdG8gbWFrZSBzdXJlIHRoZXkgb25seSBwcm92aWRlIGFcbiAgICAvLy8gZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAgIGNhblNoaWZ0KHRlcm0pIHtcbiAgICAgICAgZm9yIChsZXQgc2ltID0gbmV3IFNpbXVsYXRlZFN0YWNrKHRoaXMpOzspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdChzaW0uc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLykgfHwgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24oc2ltLnN0YXRlLCB0ZXJtKTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdXAgdG8gUmVjb3Zlci5NYXhOZXh0IHJlY292ZXJ5IGFjdGlvbnMgdGhhdCBjb25jZXB0dWFsbHlcbiAgICAvLyBpbnNlcnRzIHNvbWUgbWlzc2luZyB0b2tlbiBvciBydWxlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlJbnNlcnQobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwIC8qIE1heEluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBuZXh0U3RhdGVzID0gdGhpcy5wLnBhcnNlci5uZXh0U3RhdGVzKHRoaXMuc3RhdGUpO1xuICAgICAgICBpZiAobmV4dFN0YXRlcy5sZW5ndGggPiA0IC8qIE1heE5leHQgKi8gPDwgMSB8fCB0aGlzLnN0YWNrLmxlbmd0aCA+PSAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLykge1xuICAgICAgICAgICAgbGV0IGJlc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICgocyA9IG5leHRTdGF0ZXNbaSArIDFdKSAhPSB0aGlzLnN0YXRlICYmIHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHMsIG5leHQpKVxuICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgYmVzdC5sZW5ndGggPCA0IC8qIE1heE5leHQgKi8gPDwgMSAmJiBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3Quc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICBpZiAocyA9PSB0aGlzLnN0YXRlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgc3RhY2suc3RvcmVOb2RlKDAgLyogRXJyICovLCBzdGFjay5wb3MsIHN0YWNrLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFjay5wdXNoU3RhdGUocywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc2hpZnRDb250ZXh0KG5leHRTdGF0ZXNbaV0sIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnNjb3JlIC09IDIwMCAvKiBJbnNlcnQgKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlUmVkdWNlKCkge1xuICAgICAgICBsZXQgcmVkdWNlID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNSAvKiBGb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBpZiAoIXBhcnNlci52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCByZWR1Y2UpKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSByZWR1Y2UgPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLywgdGVybSA9IHJlZHVjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLztcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIGRlcHRoICogMztcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPCAwIHx8IHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgLT0gMTAwIC8qIFJlZHVjZSAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZShyZWR1Y2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlQWxsKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMucC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogQWNjZXB0aW5nICovKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcmNlUmVkdWNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBoYXMgbm8gZnVydGhlciBhY3Rpb25zIChhc3N1bWVkIHRvIGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSwgc2luY2UgYW55IG90aGVyIHN0YXRlcyBtdXN0IGJlIGFibGUgdG8gY29udGludWVcbiAgICAvLy8gc29tZWhvdykuIEBpbnRlcm5hbFxuICAgIGdldCBkZWFkRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGF0YVtwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDEgLyogQWN0aW9ucyAqLyldID09IDY1NTM1IC8qIEVuZCAqLyAmJlxuICAgICAgICAgICAgIXBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKTtcbiAgICB9XG4gICAgLy8vIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICAvLy8gd2hlbiB0aGlzLnN0YWNrLmxlbmd0aCA9PSAzIChzdGF0ZSBpcyBkaXJlY3RseSBiZWxvdyB0aGUgdG9wXG4gICAgLy8vIHN0YXRlKS4gQGludGVybmFsXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNhbWVTdGF0ZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPSBvdGhlci5zdGF0ZSB8fCB0aGlzLnN0YWNrLmxlbmd0aCAhPSBvdGhlci5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrW2ldICE9IG90aGVyLnN0YWNrW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgZ2V0IHBhcnNlcigpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXI7IH1cbiAgICAvLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gZGlhbGVjdCAoYnkgbnVtZXJpYyBJRCwgYXMgZXhwb3J0ZWQgZnJvbVxuICAgIC8vLyB0aGUgdGVybXMgZmlsZSkgaXMgZW5hYmxlZC5cbiAgICBkaWFsZWN0RW5hYmxlZChkaWFsZWN0SUQpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXIuZGlhbGVjdC5mbGFnc1tkaWFsZWN0SURdOyB9XG4gICAgc2hpZnRDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc2hpZnQodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIHJlZHVjZUNvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZWR1Y2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbWl0Q29udGV4dCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTMpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VyQ29udGV4dC5oYXNoLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIC0zKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGVtaXRMb29rQWhlYWQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC00KVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmxvb2tBaGVhZCwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCAtNCk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCAhPSB0aGlzLmN1ckNvbnRleHQuY29udGV4dCkge1xuICAgICAgICAgICAgbGV0IG5ld0N4ID0gbmV3IFN0YWNrQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlciwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAobmV3Q3guaGFzaCAhPSB0aGlzLmN1ckNvbnRleHQuaGFzaClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBuZXdDeDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2V0TG9va0FoZWFkKGxvb2tBaGVhZCkge1xuICAgICAgICBpZiAobG9va0FoZWFkID4gdGhpcy5sb29rQWhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgICAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdClcbiAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9va0FoZWFkID4gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0cmFja2VyLnN0cmljdCA/IHRyYWNrZXIuaGFzaChjb250ZXh0KSA6IDA7XG4gICAgfVxufVxudmFyIFJlY292ZXI7XG4oZnVuY3Rpb24gKFJlY292ZXIpIHtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJJbnNlcnRcIl0gPSAyMDBdID0gXCJJbnNlcnRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJEZWxldGVcIl0gPSAxOTBdID0gXCJEZWxldGVcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJSZWR1Y2VcIl0gPSAxMDBdID0gXCJSZWR1Y2VcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhOZXh0XCJdID0gNF0gPSBcIk1heE5leHRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhJbnNlcnRTdGFja0RlcHRoXCJdID0gMzAwXSA9IFwiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIl0gPSAxMjBdID0gXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCI7XG59KShSZWNvdmVyIHx8IChSZWNvdmVyID0ge30pKTtcbi8vIFVzZWQgdG8gY2hlYXBseSBydW4gc29tZSByZWR1Y3Rpb25zIHRvIHNjYW4gYWhlYWQgd2l0aG91dCBtdXRhdGluZ1xuLy8gYW4gZW50aXJlIHN0YWNrXG5jbGFzcyBTaW11bGF0ZWRTdGFjayB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFydC5zdGFjaztcbiAgICAgICAgdGhpcy5iYXNlID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgfVxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IHRlcm0gPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi87XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjayA9PSB0aGlzLnN0YXJ0LnN0YWNrKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSAtPSAoZGVwdGggLSAxKSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvdG8gPSB0aGlzLnN0YXJ0LnAucGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0aGlzLmJhc2UgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBnb3RvO1xuICAgIH1cbn1cbi8vIFRoaXMgaXMgZ2l2ZW4gdG8gYFRyZWUuYnVpbGRgIHRvIGJ1aWxkIGEgYnVmZmVyLCBhbmQgZW5jYXBzdWxhdGVzXG4vLyB0aGUgcGFyZW50LXN0YWNrLXdhbGtpbmcgbmVjZXNzYXJ5IHRvIHJlYWQgdGhlIG5vZGVzLlxuY2xhc3MgU3RhY2tCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrLCBwb3MsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBzdGFjay5idWZmZXI7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHN0YWNrLCBwb3MgPSBzdGFjay5idWZmZXJCYXNlICsgc3RhY2suYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHN0YWNrLCBwb3MsIHBvcyAtIHN0YWNrLmJ1ZmZlckJhc2UpO1xuICAgIH1cbiAgICBtYXliZU5leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5zdGFjay5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLmJ1ZmZlckJhc2UgLSBuZXh0LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV4dDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV4dC5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5pbmRleCAtPSA0O1xuICAgICAgICB0aGlzLnBvcyAtPSA0O1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgZm9yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcih0aGlzLnN0YWNrLCB0aGlzLnBvcywgdGhpcy5pbmRleCk7XG4gICAgfVxufVxuXG5jbGFzcyBDYWNoZWRUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IC0xO1xuICAgICAgICB0aGlzLmVuZCA9IC0xO1xuICAgICAgICB0aGlzLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gMDtcbiAgICAgICAgdGhpcy5tYXNrID0gMDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gMDtcbiAgICB9XG59XG5jb25zdCBudWxsVG9rZW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4vLy8gW1Rva2VuaXplcnNdKCNsci5FeHRlcm5hbFRva2VuaXplcikgaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXRcbi8vLyB0aHJvdWdoIHRoaXMgaW50ZXJmYWNlLiBJdCBwcmVzZW50cyB0aGUgaW5wdXQgYXMgYSBzdHJlYW0gb2Zcbi8vLyBjaGFyYWN0ZXJzLCB0cmFja2luZyBsb29rYWhlYWQgYW5kIGhpZGluZyB0aGUgY29tcGxleGl0eSBvZlxuLy8vIFtyYW5nZXNdKCNjb21tb24uUGFyc2VyLnBhcnNlXnJhbmdlcykgZnJvbSB0b2tlbml6ZXIgY29kZS5cbmNsYXNzIElucHV0U3RyZWFtIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGlucHV0LCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIC8vLyBCYWNrdXAgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVuazIgPSBcIlwiO1xuICAgICAgICB0aGlzLmNodW5rMlBvcyA9IDA7XG4gICAgICAgIC8vLyBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIG5leHQgY29kZSB1bml0IGluIHRoZSBpbnB1dCwgb3IgLTFcbiAgICAgICAgLy8vIHdoZW4gdGhlIHN0cmVhbSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuZW5kID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICByZXNvbHZlT2Zmc2V0KG9mZnNldCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yYW5nZSwgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghaW5kZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWy0taW5kZXhdO1xuICAgICAgICAgICAgcG9zIC09IHJhbmdlLmZyb20gLSBuZXh0LnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhc3NvYyA8IDAgPyBwb3MgPiByYW5nZS50byA6IHBvcyA+PSByYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWysraW5kZXhdO1xuICAgICAgICAgICAgcG9zICs9IG5leHQuZnJvbSAtIHJhbmdlLnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8vLyBMb29rIGF0IGEgY29kZSB1bml0IG5lYXIgdGhlIHN0cmVhbSBwb3NpdGlvbi4gYC5wZWVrKDApYCBlcXVhbHNcbiAgICAvLy8gYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICAgIC8vLyBvbi5cbiAgICAvLy9cbiAgICAvLy8gTm90ZSB0aGF0IGxvb2tpbmcgYXJvdW5kIGR1cmluZyB0b2tlbml6aW5nIGNyZWF0ZXMgZGVwZW5kZW5jaWVzXG4gICAgLy8vIG9uIHBvdGVudGlhbGx5IGZhci1hd2F5IGNvbnRlbnQsIHdoaWNoIG1heSByZWR1Y2UgdGhlXG4gICAgLy8vIGVmZmVjdGl2ZW5lc3MgaW5jcmVtZW50YWwgcGFyc2luZ+KAlHdoZW4gbG9va2luZyBmb3J3YXJk4oCUb3IgZXZlblxuICAgIC8vLyBjYXVzZSBpbnZhbGlkIHJlcGFyc2VzIHdoZW4gbG9va2luZyBiYWNrd2FyZCBtb3JlIHRoYW4gMjUgY29kZVxuICAgIC8vLyB1bml0cywgc2luY2UgdGhlIGxpYnJhcnkgZG9lcyBub3QgdHJhY2sgbG9va2JlaGluZC5cbiAgICBwZWVrKG9mZnNldCkge1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5jaHVua09mZiArIG9mZnNldCwgcG9zLCByZXN1bHQ7XG4gICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPCB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQoaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZU9mZnNldChvZmZzZXQsIDEpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcG9zID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdChwb3MgLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHRoaXMucmFuZ2VJbmRleCwgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZS50byA8PSBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5yYW5nZXNbKytpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5jaHVuazJQb3MgPSBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgKyB0aGlzLmNodW5rMi5sZW5ndGggPiByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rMi5zbGljZSgwLCByYW5nZS50byAtIHBvcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQWNjZXB0IGEgdG9rZW4uIEJ5IGRlZmF1bHQsIHRoZSBlbmQgb2YgdGhlIHRva2VuIGlzIHNldCB0byB0aGVcbiAgICAvLy8gY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICAgIC8vLyB0aGUgc3RyZWFtIHBvc2l0aW9uKSB0byBjaGFuZ2UgdGhhdC5cbiAgICBhY2NlcHRUb2tlbih0b2tlbiwgZW5kT2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZW5kID0gZW5kT2Zmc2V0ID8gdGhpcy5yZXNvbHZlT2Zmc2V0KGVuZE9mZnNldCwgLTEpIDogdGhpcy5wb3M7XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCB8fCBlbmQgPCB0aGlzLnRva2VuLnN0YXJ0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUb2tlbiBlbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgdGhpcy50b2tlbi52YWx1ZSA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgZ2V0Q2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiB0aGlzLnBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBjaHVuaywgY2h1bmtQb3MgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gdGhpcy5jaHVuazI7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5jaHVuazJQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSBjaHVua1BvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSB0aGlzLnBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICBsZXQgbmV4dENodW5rID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLnBvcyk7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgKyBuZXh0Q2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IGVuZCA+IHRoaXMucmFuZ2UudG8gPyBuZXh0Q2h1bmsuc2xpY2UoMCwgdGhpcy5yYW5nZS50byAtIHRoaXMucG9zKSA6IG5leHRDaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5jaHVua09mZiA+PSB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5nZXRDaHVuaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPT0gdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQodGhpcy5jaHVua09mZik7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRoZSBzdHJlYW0gZm9yd2FyZCBOIChkZWZhdWx0cyB0byAxKSBjb2RlIHVuaXRzLiBSZXR1cm5zXG4gICAgLy8vIHRoZSBuZXcgdmFsdWUgb2YgW2BuZXh0YF0oI2xyLklucHV0U3RyZWFtLm5leHQpLlxuICAgIGFkdmFuY2UobiA9IDEpIHtcbiAgICAgICAgdGhpcy5jaHVua09mZiArPSBuO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgKyBuID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlSW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICBuIC09IHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmFuZ2UuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBuO1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgc2V0RG9uZSgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gdGhpcy5lbmQ7XG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXggPSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlc2V0KHBvcywgdG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICB0b2tlbi5zdGFydCA9IHBvcztcbiAgICAgICAgICAgIHRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHRva2VuLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSB0aGlzLmVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMucmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbLS10aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA+PSB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmtQb3MgJiYgcG9zIDwgdGhpcy5jaHVua1BvcyArIHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVua1BvcyAmJiB0byA8PSB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuay5zbGljZShmcm9tIC0gdGhpcy5jaHVua1BvcywgdG8gLSB0aGlzLmNodW5rUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVuazJQb3MgJiYgdG8gPD0gdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuazIuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmsyUG9zLCB0byAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5yYW5nZS5mcm9tICYmIHRvIDw9IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yZWFkKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuaW5wdXQucmVhZChNYXRoLm1heChyLmZyb20sIGZyb20pLCBNYXRoLm1pbihyLnRvLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEBpbnRlcm5hbFxuY2xhc3MgVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgc3RhY2spIHsgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHN0YWNrLCB0aGlzLmlkKTsgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vLy8gYEBleHRlcm5hbCB0b2tlbnNgIGRlY2xhcmF0aW9ucyBpbiB0aGUgZ3JhbW1hciBzaG91bGQgcmVzb2x2ZSB0b1xuLy8vIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG5jbGFzcyBFeHRlcm5hbFRva2VuaXplciB7XG4gICAgLy8vIENyZWF0ZSBhIHRva2VuaXplci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBmdW5jdGlvbiB0aGF0LFxuICAgIC8vLyBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gICAgLy8vIHJlY29nbml6ZXMgYXQgdGhlIHN0cmVhbSdzIHBvc2l0aW9uLCBhbmQgY2FsbHNcbiAgICAvLy8gW2BhY2NlcHRUb2tlbmBdKCNsci5JbnB1dFN0cmVhbS5hY2NlcHRUb2tlbikgd2hlbiBpdCBmaW5kc1xuICAgIC8vLyBvbmUuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGB0b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHN0YWNrLCBncm91cCkge1xuICAgIGxldCBzdGF0ZSA9IDAsIGdyb3VwTWFzayA9IDEgPDwgZ3JvdXAsIHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IGRpYWxlY3QgfSA9IHBhcnNlcjtcbiAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5wdXQudG9rZW4udmFsdWUgPT0gLTEgfHwgaW5wdXQudG9rZW4udmFsdWUgPT0gdGVybSB8fCBwYXJzZXIub3ZlcnJpZGVzKHRlcm0sIGlucHV0LnRva2VuLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGVybSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAobGV0IG5leHQgPSBpbnB1dC5uZXh0LCBsb3cgPSAwLCBoaWdoID0gZGF0YVtzdGF0ZSArIDJdOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49IHRvKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8vIFNlZSBsZXplci1nZW5lcmF0b3Ivc3JjL2VuY29kZS50cyBmb3IgY29tbWVudHMgYWJvdXQgdGhlIGVuY29kaW5nXG4vLyB1c2VkIGhlcmVcbmZ1bmN0aW9uIGRlY29kZUFycmF5KGlucHV0LCBUeXBlID0gVWludDE2QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICBsZXQgYXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIG91dCA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKSwgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gMTI2IC8qIEJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEdhcDIgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgaWYgKG5leHQgPj0gMzQgLyogR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogQmFzZSAqLykge1xuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDQ2IC8qIEJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLy8gRklYTUUgZmluZCBzb21lIHdheSB0byByZWR1Y2UgcmVjb3Zlcnkgd29yayBkb25lIHdoZW4gdGhlIGlucHV0XG4vLyBkb2Vzbid0IG1hdGNoIHRoZSBncmFtbWFyIGF0IGFsbC5cbi8vIEVudmlyb25tZW50IHZhcmlhYmxlIHVzZWQgdG8gY29udHJvbCBjb25zb2xlIG91dHB1dFxuY29uc3QgdmVyYm9zZSA9IHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgL1xcYnBhcnNlXFxiLy50ZXN0KHByb2Nlc3MuZW52LkxPRyk7XG5sZXQgc3RhY2tJRHMgPSBudWxsO1xudmFyIFNhZmV0eTtcbihmdW5jdGlvbiAoU2FmZXR5KSB7XG4gICAgU2FmZXR5W1NhZmV0eVtcIk1hcmdpblwiXSA9IDI1XSA9IFwiTWFyZ2luXCI7XG59KShTYWZldHkgfHwgKFNhZmV0eSA9IHt9KSk7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5mdWxsQ3Vyc29yKCk7XG4gICAgY3Vyc29yLm1vdmVUbyhwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPCBwb3MgOiBjdXJzb3IuZnJvbSA+IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnNvci50byAtIDEsIHBvcyAtIDI1IC8qIE1hcmdpbiAqLykpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKHRyZWUubGVuZ3RoLCBNYXRoLm1heChjdXJzb3IuZnJvbSArIDEsIHBvcyArIDI1IC8qIE1hcmdpbiAqLykpO1xuICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyAwIDogdHJlZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cywgbm9kZVNldCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbm9kZVNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FmZUZyb20gPSAtMTtcbiAgICAgICAgdGhpcy5zYWZlVG8gPSAtMTtcbiAgICAgICAgdGhpcy50cmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICBsZXQgZnIgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5pID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IG51bGwgOiB0aGlzLmZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgICAgIGlmIChmcikge1xuICAgICAgICAgICAgdGhpcy5zYWZlRnJvbSA9IGZyLm9wZW5TdGFydCA/IGN1dEF0KGZyLnRyZWUsIGZyLmZyb20gKyBmci5vZmZzZXQsIDEpIC0gZnIub2Zmc2V0IDogZnIuZnJvbTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvID0gZnIub3BlbkVuZCA/IGN1dEF0KGZyLnRyZWUsIGZyLnRvICsgZnIub2Zmc2V0LCAtMSkgLSBmci5vZmZzZXQgOiBmci50bztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRyZWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKGZyLnRyZWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKC1mci5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLm5leHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLnNhZmVUbyA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnRyZWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHsgLy8gRW5kIG9mIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudHJlZXNbbGFzdF0sIGluZGV4ID0gdGhpcy5pbmRleFtsYXN0XTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0b3AuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YXJ0W2xhc3RdICsgdG9wLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCB0aGlzLnNhZmVGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kIDw9IHRoaXMuc2FmZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gbmV4dC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb2tBaGVhZCB8fCBlbmQgKyBsb29rQWhlYWQgPCB0aGlzLmZyYWdtZW50LnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgKyBuZXh0Lmxlbmd0aCA+PSBNYXRoLm1heCh0aGlzLnNhZmVGcm9tLCBwb3MpKSB7IC8vIEVudGVyIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgVG9rZW5DYWNoZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zID0gcGFyc2VyLnRva2VuaXplcnMubWFwKF8gPT4gbmV3IENhY2hlZFRva2VuKTtcbiAgICB9XG4gICAgZ2V0QWN0aW9ucyhzdGFjaykge1xuICAgICAgICBsZXQgYWN0aW9uSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWFpbiA9IG51bGw7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyB0b2tlbml6ZXJzIH0gPSBwYXJzZXI7XG4gICAgICAgIGxldCBtYXNrID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgMyAvKiBUb2tlbml6ZXJNYXNrICovKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzdGFjay5jdXJDb250ZXh0ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgoMSA8PCBpKSAmIG1hc2spID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdG9rZW5pemVyID0gdG9rZW5pemVyc1tpXSwgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmIChtYWluICYmICF0b2tlbml6ZXIuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodG9rZW5pemVyLmNvbnRleHR1YWwgfHwgdG9rZW4uc3RhcnQgIT0gc3RhY2sucG9zIHx8IHRva2VuLm1hc2sgIT0gbWFzayB8fCB0b2tlbi5jb250ZXh0ICE9IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZFRva2VuKHRva2VuLCB0b2tlbml6ZXIsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXNrID0gbWFzaztcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi5sb29rQWhlYWQgPiB0b2tlbi5lbmQgKyAyNSAvKiBNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gTWF0aC5tYXgodG9rZW4ubG9va0FoZWFkLCBsb29rQWhlYWQpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlICE9IDAgLyogRXJyICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZXh0ZW5kZWQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLmV4dGVuZGVkLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4udmFsdWUsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5pemVyLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25JbmRleCA+IHN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuYWN0aW9ucy5sZW5ndGggPiBhY3Rpb25JbmRleClcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcbiAgICAgICAgaWYgKGxvb2tBaGVhZClcbiAgICAgICAgICAgIHN0YWNrLnNldExvb2tBaGVhZChsb29rQWhlYWQpO1xuICAgICAgICBpZiAoIW1haW4gJiYgc3RhY2sucG9zID09IHRoaXMuc3RyZWFtLmVuZCkge1xuICAgICAgICAgICAgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbjtcbiAgICAgICAgICAgIG1haW4udmFsdWUgPSBzdGFjay5wLnBhcnNlci5lb2ZUZXJtO1xuICAgICAgICAgICAgbWFpbi5zdGFydCA9IG1haW4uZW5kID0gc3RhY2sucG9zO1xuICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIG1haW4udmFsdWUsIG1haW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBtYWluO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zO1xuICAgIH1cbiAgICBnZXRNYWluVG9rZW4oc3RhY2spIHtcbiAgICAgICAgaWYgKHRoaXMubWFpblRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpblRva2VuO1xuICAgICAgICBsZXQgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbiwgeyBwb3MsIHAgfSA9IHN0YWNrO1xuICAgICAgICBtYWluLnN0YXJ0ID0gcG9zO1xuICAgICAgICBtYWluLmVuZCA9IE1hdGgubWluKHBvcyArIDEsIHAuc3RyZWFtLmVuZCk7XG4gICAgICAgIG1haW4udmFsdWUgPSBwb3MgPT0gcC5zdHJlYW0uZW5kID8gcC5wYXJzZXIuZW9mVGVybSA6IDAgLyogRXJyICovO1xuICAgICAgICByZXR1cm4gbWFpbjtcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spIHtcbiAgICAgICAgdG9rZW5pemVyLnRva2VuKHRoaXMuc3RyZWFtLnJlc2V0KHN0YWNrLnBvcywgdG9rZW4pLCBzdGFjayk7XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlci5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNwZWNpYWxpemVkW2ldID09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZXIuc3BlY2lhbGl6ZXJzW2ldKHRoaXMuc3RyZWFtLnJlYWQodG9rZW4uc3RhcnQsIHRva2VuLmVuZCksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwICYmIHN0YWNrLnAucGFyc2VyLmRpYWxlY3QuYWxsb3dzKHJlc3VsdCA+PiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgJiAxKSA9PSAwIC8qIFNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogRXJyICovO1xuICAgICAgICAgICAgdG9rZW4uZW5kID0gTWF0aC5taW4oc3RhY2sucC5zdHJlYW0uZW5kLCBzdGFjay5wb3MgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXRBY3Rpb24oYWN0aW9uLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICAvLyBEb24ndCBhZGQgZHVwbGljYXRlIGFjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpXSA9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBhY3Rpb247XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IHRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBlbmQ7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHN0YWNrLCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyBkYXRhIH0gPSBwYXJzZXI7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VyLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBTa2lwICovIDogMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gMCAmJiBkYXRhW2kgKyAxXSA9PSAyIC8qIE90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMiksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDEpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbnZhciBSZWM7XG4oZnVuY3Rpb24gKFJlYykge1xuICAgIFJlY1tSZWNbXCJEaXN0YW5jZVwiXSA9IDVdID0gXCJEaXN0YW5jZVwiO1xuICAgIFJlY1tSZWNbXCJNYXhSZW1haW5pbmdQZXJTdGVwXCJdID0gM10gPSBcIk1heFJlbWFpbmluZ1BlclN0ZXBcIjtcbiAgICAvLyBXaGVuIHR3byBzdGFja3MgaGF2ZSBiZWVuIHJ1bm5pbmcgaW5kZXBlbmRlbnRseSBsb25nIGVub3VnaCB0b1xuICAgIC8vIGFkZCB0aGlzIG1hbnkgZWxlbWVudHMgdG8gdGhlaXIgYnVmZmVycywgcHJ1bmUgb25lLlxuICAgIFJlY1tSZWNbXCJNaW5CdWZmZXJMZW5ndGhQcnVuZVwiXSA9IDUwMF0gPSBcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCI7XG4gICAgUmVjW1JlY1tcIkZvcmNlUmVkdWNlTGltaXRcIl0gPSAxMF0gPSBcIkZvcmNlUmVkdWNlTGltaXRcIjtcbiAgICAvLyBPbmNlIGEgc3RhY2sgcmVhY2hlcyB0aGlzIGRlcHRoIChpbiAuc3RhY2subGVuZ3RoKSBmb3JjZS1yZWR1Y2VcbiAgICAvLyBpdCBiYWNrIHRvIEN1dFRvIHRvIGF2b2lkIGNyZWF0aW5nIHRyZWVzIHRoYXQgb3ZlcmZsb3cgdGhlIHN0YWNrXG4gICAgLy8gb24gcmVjdXJzaXZlIHRyYXZlcnNhbC5cbiAgICBSZWNbUmVjW1wiQ3V0RGVwdGhcIl0gPSAxNTAwMF0gPSBcIkN1dERlcHRoXCI7XG4gICAgUmVjW1JlY1tcIkN1dFRvXCJdID0gOTAwMF0gPSBcIkN1dFRvXCI7XG59KShSZWMgfHwgKFJlYyA9IHt9KSk7XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFN0YWNrSUQgPSAweDI2NTQ7IC8vIOKZlCwg4pmVLCDimZYsIOKZlywg4pmYLCDimZksIOKZoCwg4pmhLCDimaIsIOKZoywg4pmkLCDimaUsIOKZpiwg4pmnXG4gICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSAwO1xuICAgICAgICB0aGlzLnJldXNlZCA9IFtdO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IElucHV0U3RyZWFtKGlucHV0LCByYW5nZXMpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlciwgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICBsZXQgeyBmcm9tIH0gPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIGZyb20pXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoICYmIHRoaXMuc3RyZWFtLmVuZCAtIGZyb20gPiBwYXJzZXIuYnVmZmVyTGVuZ3RoICogNFxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzLCBwYXJzZXIubm9kZVNldCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5TdGFja1BvcztcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5taW5TdGFja1BvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICAvLyBLZWVwIGFkdmFuY2luZyBhbnkgc3RhY2tzIGF0IGBwb3NgIHVudGlsIHRoZXkgZWl0aGVyIG1vdmVcbiAgICAgICAgLy8gZm9yd2FyZCBvciBjYW4ndCBiZSBhZHZhbmNlZC4gR2F0aGVyIHN0YWNrcyB0aGF0IGNhbid0IGJlXG4gICAgICAgIC8vIGFkdmFuY2VkIGZ1cnRoZXIgaW4gYHN0b3BwZWRgLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBuZXdTdGFja3MsIHN0YWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9rID0gdGhpcy50b2tlbnMuZ2V0TWFpblRva2VuKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2Vucy5wdXNoKHRvay52YWx1ZSwgdG9rLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbmV3U3RhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gc3RvcHBlZCAmJiBmaW5kRmluaXNoZWQoc3RvcHBlZCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VyLnN0cmljdCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlICYmIHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3R1Y2sgd2l0aCB0b2tlbiBcIiArICh0aGlzLnRva2Vucy5tYWluVG9rZW4gPyB0aGlzLnBhcnNlci5nZXROYW1lKHRoaXMudG9rZW5zLm1haW5Ub2tlbi52YWx1ZSkgOiBcIm5vbmVcIikpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk5vIHBhcnNlIGF0IFwiICsgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvdmVyaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDUgLyogRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0b3BwZWRbMF0ucG9zID4gdGhpcy5zdG9wcGVkQXQgPyBzdG9wcGVkWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQuZm9yY2VBbGwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZykge1xuICAgICAgICAgICAgbGV0IG1heFJlbWFpbmluZyA9IHRoaXMucmVjb3ZlcmluZyA9PSAxID8gMSA6IHRoaXMucmVjb3ZlcmluZyAqIDMgLyogTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBNaW5CdWZmZXJMZW5ndGhQcnVuZSAqLyAmJiBvdGhlci5idWZmZXIubGVuZ3RoID4gNTAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChzdGFjay5zY29yZSAtIG90aGVyLnNjb3JlKSB8fCAoc3RhY2suYnVmZmVyLmxlbmd0aCAtIG90aGVyLmJ1ZmZlci5sZW5ndGgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1swXS5wb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5wb3MgPCB0aGlzLm1pblN0YWNrUG9zKVxuICAgICAgICAgICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbaV0ucG9zO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiB0aGlzLnN0b3BwZWRBdCA8IHBvcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgbW92ZSBzdG9wcGVkQXQgZm9yd2FyZFwiKTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYW4gdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBzdGFjaywgb3IgbnVsbCBpZiB0aGVcbiAgICAvLyBzdGFjayBjYW4ndCBhZHZhbmNlIG5vcm1hbGx5LiBXaGVuIGBzcGxpdGAgYW5kIGBzdGFja3NgIGFyZVxuICAgIC8vIGdpdmVuLCBzdGFja3Mgc3BsaXQgb2ZmIGJ5IGFtYmlndW91cyBvcGVyYXRpb25zIHdpbGwgYmUgcHVzaGVkIHRvXG4gICAgLy8gYHNwbGl0YCwgb3IgYWRkZWQgdG8gYHN0YWNrc2AgaWYgdGhleSBtb3ZlIGBwb3NgIGZvcndhcmQuXG4gICAgYWR2YW5jZVN0YWNrKHN0YWNrLCBzdGFja3MsIHNwbGl0KSB7XG4gICAgICAgIGxldCBzdGFydCA9IHN0YWNrLnBvcywgeyBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0YXJ0ID4gdGhpcy5zdG9wcGVkQXQpXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suZm9yY2VSZWR1Y2UoKSA/IHN0YWNrIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICBsZXQgc3RyaWN0Q3ggPSBzdGFjay5jdXJDb250ZXh0ICYmIHN0YWNrLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QsIGN4SGFzaCA9IHN0cmljdEN4ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNhY2hlZCA9IHRoaXMuZnJhZ21lbnRzLm5vZGVBdChzdGFydCk7IGNhY2hlZDspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW2NhY2hlZC50eXBlLmlkXSA9PSBjYWNoZWQudHlwZSA/IHBhcnNlci5nZXRHb3RvKHN0YWNrLnN0YXRlLCBjYWNoZWQudHlwZS5pZCkgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPiAtMSAmJiBjYWNoZWQubGVuZ3RoICYmICghc3RyaWN0Q3ggfHwgKGNhY2hlZC5wcm9wKE5vZGVQcm9wLmNvbnRleHRIYXNoKSB8fCAwKSA9PSBjeEhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVzZU5vZGUoY2FjaGVkLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmV1c2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShjYWNoZWQudHlwZS5pZCl9KWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVkIGluc3RhbmNlb2YgVHJlZSkgfHwgY2FjaGVkLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IGNhY2hlZC5wb3NpdGlvbnNbMF0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjYWNoZWQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyIGluc3RhbmNlb2YgVHJlZSAmJiBjYWNoZWQucG9zaXRpb25zWzBdID09IDApXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoZGVmYXVsdFJlZHVjZSA+IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZShkZWZhdWx0UmVkdWNlKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIGFsd2F5cy1yZWR1Y2UgJHtwYXJzZXIuZ2V0TmFtZShkZWZhdWx0UmVkdWNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovKX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suc3RhY2subGVuZ3RoID49IDE1MDAwIC8qIEN1dERlcHRoICovKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2suc3RhY2subGVuZ3RoID4gOTAwMCAvKiBDdXRUbyAqLyAmJiBzdGFjay5mb3JjZVJlZHVjZSgpKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMudG9rZW5zLmdldEFjdGlvbnMoc3RhY2spO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNbaSsrXSwgdGVybSA9IGFjdGlvbnNbaSsrXSwgZW5kID0gYWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGFjdGlvbnMubGVuZ3RoIHx8ICFzcGxpdDtcbiAgICAgICAgICAgIGxldCBsb2NhbFN0YWNrID0gbGFzdCA/IHN0YWNrIDogc3RhY2suc3BsaXQoKTtcbiAgICAgICAgICAgIGxvY2FsU3RhY2suYXBwbHkoYWN0aW9uLCB0ZXJtLCBlbmQpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChsb2NhbFN0YWNrKSArIGAgKHZpYSAkeyhhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwID8gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgIDogYHJlZHVjZSBvZiAke3BhcnNlci5nZXROYW1lKGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLyl9YH0gZm9yICR7cGFyc2VyLmdldE5hbWUodGVybSl9IEAgJHtzdGFydH0ke2xvY2FsU3RhY2sgPT0gc3RhY2sgPyBcIlwiIDogXCIsIHNwbGl0XCJ9KWApO1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChsb2NhbFN0YWNrLnBvcyA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNwbGl0LnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZHZhbmNlIGEgZ2l2ZW4gc3RhY2sgZm9yd2FyZCBhcyBmYXIgYXMgaXQgd2lsbCBnby4gUmV0dXJucyB0aGVcbiAgICAvLyAocG9zc2libHkgdXBkYXRlZCkgc3RhY2sgaWYgaXQgZ290IHN0dWNrLCBvciBudWxsIGlmIGl0IG1vdmVkXG4gICAgLy8gZm9yd2FyZCBhbmQgd2FzIGdpdmVuIHRvIGBwdXNoU3RhY2tEZWR1cGAuXG4gICAgYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IHBvcyA9IHN0YWNrLnBvcztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbnVsbCwgbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJ1blJlY292ZXJ5KHN0YWNrcywgdG9rZW5zLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IGZpbmlzaGVkID0gbnVsbCwgcmVzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV0sIHRva2VuID0gdG9rZW5zW2kgPDwgMV0sIHRva2VuRW5kID0gdG9rZW5zWyhpIDw8IDEpICsgMV07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHN0YWNrLmRlYWRFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAocmVzdGFydGVkKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHN0YWNrLnNwbGl0KCksIGZvcmNlQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgZm9yY2UuZm9yY2VSZWR1Y2UoKSAmJiBqIDwgMTAgLyogRm9yY2VSZWR1Y2VMaW1pdCAqLzsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZvcmNlQmFzZSArIHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAodmlhIGZvcmNlLXJlZHVjZSlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShmb3JjZSwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQmFzZSA9IHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAtPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGluc2VydCBvZiBzdGFjay5yZWNvdmVyQnlJbnNlcnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoaW5zZXJ0KSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUZ1bGx5KGluc2VydCwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbS5lbmQgPiBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5FbmQgPT0gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kKys7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gMCAvKiBFcnIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrLnJlY292ZXJCeURlbGV0ZSh0b2tlbiwgdG9rZW5FbmQpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZWNvdmVyLWRlbGV0ZSAke3RoaXMucGFyc2VyLmdldE5hbWUodG9rZW4pfSlgKTtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaW5pc2hlZCB8fCBmaW5pc2hlZC5zY29yZSA8IHN0YWNrLnNjb3JlKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHN0YWNrJ3MgYnVmZmVyIHRvIGEgc3ludGF4IHRyZWUuXG4gICAgc3RhY2tUb1RyZWUoc3RhY2spIHtcbiAgICAgICAgc3RhY2suY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIFRyZWUuYnVpbGQoeyBidWZmZXI6IFN0YWNrQnVmZmVyQ3Vyc29yLmNyZWF0ZShzdGFjayksXG4gICAgICAgICAgICBub2RlU2V0OiB0aGlzLnBhcnNlci5ub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IHRoaXMudG9wVGVybSxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogdGhpcy5wYXJzZXIuYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLnJldXNlZCxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBzdGFjay5wb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbWluUmVwZWF0VHlwZTogdGhpcy5wYXJzZXIubWluUmVwZWF0VGVybSB9KTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG5jb25zdCBpZCA9IHggPT4geDtcbi8vLyBDb250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbi8vLyBpbmRlbnRhdGlvbiBpbiB0aGUgUHl0aG9uIGdyYW1tYXIsIG9yIHBhcmVudCBlbGVtZW50cyBpbiB0aGUgWE1MXG4vLy8gZ3JhbW1hcikgbmVlZGVkIGJ5IGV4dGVybmFsIHRva2VuaXplcnMuIFlvdSBkZWNsYXJlIHRoZW0gaW4gYVxuLy8vIGdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuLy8vXG4vLy8gQ29udGV4dCB2YWx1ZXMgc2hvdWxkIGJlIGltbXV0YWJsZSwgYW5kIGNhbiBiZSB1cGRhdGVkIChyZXBsYWNlZClcbi8vLyBvbiBzaGlmdCBvciByZWR1Y2UgYWN0aW9ucy5cbi8vL1xuLy8vIFRoZSBleHBvcnQgdXNlZCBpbiBhIGBAY29udGV4dGAgZGVjbGFyYXRpb24gc2hvdWxkIGJlIG9mIHRoaXNcbi8vLyB0eXBlLlxuY2xhc3MgQ29udGV4dFRyYWNrZXIge1xuICAgIC8vLyBEZWZpbmUgYSBjb250ZXh0IHRyYWNrZXIuXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3BlYy5zdGFydDtcbiAgICAgICAgdGhpcy5zaGlmdCA9IHNwZWMuc2hpZnQgfHwgaWQ7XG4gICAgICAgIHRoaXMucmVkdWNlID0gc3BlYy5yZWR1Y2UgfHwgaWQ7XG4gICAgICAgIHRoaXMucmV1c2UgPSBzcGVjLnJldXNlIHx8IGlkO1xuICAgICAgICB0aGlzLmhhc2ggPSBzcGVjLmhhc2ggfHwgKCgpID0+IDApO1xuICAgICAgICB0aGlzLnN0cmljdCA9IHNwZWMuc3RyaWN0ICE9PSBmYWxzZTtcbiAgICB9XG59XG4vLy8gQSBwYXJzZXIgaG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWRcbi8vLyBieSBgbGV6ZXItZ2VuZXJhdG9yYC5cbmNsYXNzIExSUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMud3JhcHBlcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxMyAvKiBWZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezEzIC8qIFZlcnNpb24gKi99KWApO1xuICAgICAgICBsZXQgbm9kZU5hbWVzID0gc3BlYy5ub2RlTmFtZXMuc3BsaXQoXCIgXCIpO1xuICAgICAgICB0aGlzLm1pblJlcGVhdFRlcm0gPSBub2RlTmFtZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMucmVwZWF0Tm9kZUNvdW50OyBpKyspXG4gICAgICAgICAgICBub2RlTmFtZXMucHVzaChcIlwiKTtcbiAgICAgICAgbGV0IHRvcFRlcm1zID0gT2JqZWN0LmtleXMoc3BlYy50b3BSdWxlcykubWFwKHIgPT4gc3BlYy50b3BSdWxlc1tyXVsxXSk7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IE5vZGVTZXQobm9kZU5hbWVzLm1hcCgobmFtZSwgaSkgPT4gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCB0b2tlbkFycmF5ID0gZGVjb2RlQXJyYXkoc3BlYy50b2tlbkRhdGEpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBzcGVjLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkoc3BlYy5zcGVjaWFsaXplZCA/IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoIDogMCk7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnNwZWNpYWxpemVkKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0udGVybTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVyc1tpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0uZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgdGhpcy5tYXhUZXJtID0gc3BlYy5tYXhUZXJtO1xuICAgICAgICB0aGlzLnRva2VuaXplcnMgPSBzcGVjLnRva2VuaXplcnMubWFwKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gbmV3IFRva2VuR3JvdXAodG9rZW5BcnJheSwgdmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB0aGlzLnRvcFJ1bGVzID0gc3BlYy50b3BSdWxlcztcbiAgICAgICAgdGhpcy5kaWFsZWN0cyA9IHNwZWMuZGlhbGVjdHMgfHwge307XG4gICAgICAgIHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzID0gc3BlYy5keW5hbWljUHJlY2VkZW5jZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50b2tlblByZWNUYWJsZSA9IHNwZWMudG9rZW5QcmVjO1xuICAgICAgICB0aGlzLnRlcm1OYW1lcyA9IHNwZWMudGVybU5hbWVzIHx8IG51bGw7XG4gICAgICAgIHRoaXMubWF4Tm9kZSA9IHRoaXMubm9kZVNldC50eXBlcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdCgpO1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wUnVsZXNbT2JqZWN0LmtleXModGhpcy50b3BSdWxlcylbMF1dO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHcgb2YgdGhpcy53cmFwcGVycylcbiAgICAgICAgICAgIHBhcnNlID0gdyhwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyksIG5leHQ7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPSBkYXRhW2ldKSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSB0ZXJtaW5hbCB8fCBuZXh0ID09IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlRmxhZyhzdGF0ZSwgZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIEZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHZhbGlkQWN0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gcGFpcih0aGlzLmRhdGEsIGkgKyAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIC8vLyBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICBuZXh0U3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5kYXRhW2kgKyAyXSAmICg2NTUzNiAvKiBSZWR1Y2VGbGFnICovID4+IDE2KSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIG92ZXJyaWRlcyh0b2tlbiwgcHJldikge1xuICAgICAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRoaXMuZGF0YSwgdGhpcy50b2tlblByZWNUYWJsZSwgcHJldik7XG4gICAgICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHRva2VuKSA8IGlQcmV2O1xuICAgIH1cbiAgICAvLy8gQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIC8vLyBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIC8vLyBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKExSUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0VHJhY2tlcilcbiAgICAgICAgICAgIGNvcHkuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0VHJhY2tlcjtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICBjb3B5LndyYXBwZXJzID0gY29weS53cmFwcGVycy5jb25jYXQoY29uZmlnLndyYXApO1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVybS4gVGhpcyB3aWxsIG9ubHlcbiAgICAvLy8gd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gICAgLy8vIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgICAvLy8gc3RvcmVkLlxuICAgIGdldE5hbWUodGVybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1t0ZXJtXSA6IFN0cmluZyh0ZXJtIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbdGVybV0ubmFtZSB8fCB0ZXJtKTtcbiAgICB9XG4gICAgLy8vIFRoZSBlb2YgdGVybSBpZCBpcyBhbHdheXMgYWxsb2NhdGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBub2RlXG4gICAgLy8vIHR5cGVzLiBAaW50ZXJuYWxcbiAgICBnZXQgZW9mVGVybSgpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSArIDE7IH1cbiAgICAvLy8gVGhlIHR5cGUgb2YgdG9wIG5vZGUgcHJvZHVjZWQgYnkgdGhlIHBhcnNlci5cbiAgICBnZXQgdG9wTm9kZSgpIHsgcmV0dXJuIHRoaXMubm9kZVNldC50eXBlc1t0aGlzLnRvcFsxXV07IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZHluYW1pY1ByZWNlZGVuY2UodGVybSkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzO1xuICAgICAgICByZXR1cm4gcHJlYyA9PSBudWxsID8gMCA6IHByZWNbdGVybV0gfHwgMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcnNlRGlhbGVjdChkaWFsZWN0KSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgZmxhZ3MgPSB2YWx1ZXMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKGRpYWxlY3QpXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIGRpYWxlY3Quc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdmFsdWVzLmluZGV4T2YocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkID49IDApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFmbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpYWxlY3RzW3ZhbHVlc1tpXV0sIGlkOyAoaWQgPSB0aGlzLmRhdGFbaisrXSkgIT0gNjU1MzUgLyogRW5kICovOylcbiAgICAgICAgICAgICAgICAgICAgKGRpc2FibGVkIHx8IChkaXNhYmxlZCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEaWFsZWN0KGRpYWxlY3QsIGZsYWdzLCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIC8vLyAodXNlZCBieSB0aGUgb3V0cHV0IG9mIHRoZSBwYXJzZXIgZ2VuZXJhdG9yKSBAaW50ZXJuYWxcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IExSUGFyc2VyKHNwZWMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhaXIoZGF0YSwgb2ZmKSB7IHJldHVybiBkYXRhW29mZl0gfCAoZGF0YVtvZmYgKyAxXSA8PCAxNik7IH1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogRW5kICovOyBpKyspXG4gICAgICAgIGlmIChuZXh0ID09IHRlcm0pXG4gICAgICAgICAgICByZXR1cm4gaSAtIHN0YXJ0O1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGZpbmRGaW5pc2hlZChzdGFja3MpIHtcbiAgICBsZXQgYmVzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGxldCBzdG9wcGVkID0gc3RhY2sucC5zdG9wcGVkQXQ7XG4gICAgICAgIGlmICgoc3RhY2sucG9zID09IHN0YWNrLnAuc3RyZWFtLmVuZCB8fCBzdG9wcGVkICE9IG51bGwgJiYgc3RhY2sucG9zID4gc3RvcHBlZCkgJiZcbiAgICAgICAgICAgIHN0YWNrLnAucGFyc2VyLnN0YXRlRmxhZyhzdGFjay5zdGF0ZSwgMiAvKiBBY2NlcHRpbmcgKi8pICYmXG4gICAgICAgICAgICAoIWJlc3QgfHwgYmVzdC5zY29yZSA8IHN0YWNrLnNjb3JlKSlcbiAgICAgICAgICAgIGJlc3QgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG59XG5cbmV4cG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgSW5wdXRTdHJlYW0sIExSUGFyc2VyLCBTdGFjayB9O1xuIl0sIm5hbWVzIjpbInBhcnNlciIsIkxva2lRdWVyeU1vZGVsbGVyIiwiYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmciLCJhZGRMYWJlbFRvUXVlcnkiLCJxdWVyeSIsImtleSIsIm9wZXJhdG9yIiwidmFsdWUiLCJFcnJvciIsInN0cmVhbVNlbGVjdG9yUG9zaXRpb25zIiwiZ2V0U3RyZWFtU2VsZWN0b3JQb3NpdGlvbnMiLCJwYXJzZXJQb3NpdGlvbnMiLCJnZXRQYXJzZXJQb3NpdGlvbnMiLCJsZW5ndGgiLCJmaWx0ZXIiLCJ0b0xhYmVsRmlsdGVyIiwiYWRkRmlsdGVyVG9TdHJlYW1TZWxlY3RvciIsImFkZEZpbHRlckFzTGFiZWxGaWx0ZXIiLCJ0cmVlIiwicGFyc2UiLCJwb3NpdGlvbnMiLCJpdGVyYXRlIiwiZW50ZXIiLCJ0eXBlIiwiZnJvbSIsInRvIiwiZ2V0IiwibmFtZSIsInZpc1F1ZXJ5Iiwic3Vic3RyaW5nIiwicHVzaCIsImxhYmVsIiwib3AiLCJ2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucyIsIm1vZGVsbGVyIiwibmV3UXVlcnkiLCJwcmV2IiwiaSIsIm1hdGNoIiwiaXNMYXN0Iiwic3RhcnQiLCJlbmQiLCJsYWJlbEV4aXN0cyIsImxhYmVscyIsIm5ld0xhYmVscyIsInJlbmRlclF1ZXJ5IiwibGFiZWxGaWx0ZXIiLCJmaW5kIiwiaXNEYXRhRnJhbWUiLCJGaWVsZFR5cGUiLCJnZXREZXJpdmVkRmllbGRzIiwibWFrZVRhYmxlRnJhbWVzIiwiZm9ybWF0UXVlcnkiLCJnZXRIaWdobGlnaHRlckV4cHJlc3Npb25zRnJvbVF1ZXJ5IiwiZGF0YUZyYW1lSGFzTG9raUVycm9yIiwiTG9raVF1ZXJ5VHlwZSIsImlzTWV0cmljRnJhbWUiLCJmcmFtZSIsImZpZWxkcyIsImV2ZXJ5IiwiZmllbGQiLCJ0aW1lIiwibnVtYmVyIiwic2V0RnJhbWVNZXRhIiwibWV0YSIsIm9sZE1ldGEiLCJyZXN0IiwibmV3TWV0YSIsInByb2Nlc3NTdHJlYW1GcmFtZSIsImRlcml2ZWRGaWVsZENvbmZpZ3MiLCJjdXN0b20iLCJsb2tpUXVlcnlTdGF0S2V5IiwiZXJyb3IiLCJwcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZSIsImxpbWl0IiwibWF4TGluZXMiLCJzZWFyY2hXb3JkcyIsInVuZGVmaW5lZCIsImV4cHIiLCJuZXdGcmFtZSIsImRlcml2ZWRGaWVsZHMiLCJwcm9jZXNzU3RyZWFtc0ZyYW1lcyIsImZyYW1lcyIsInF1ZXJ5TWFwIiwibWFwIiwicmVmSWQiLCJwcm9jZXNzTWV0cmljSW5zdGFudEZyYW1lcyIsInByb2Nlc3NNZXRyaWNSYW5nZUZyYW1lcyIsImdyb3VwRnJhbWVzIiwic3RyZWFtc0ZyYW1lcyIsIm1ldHJpY0luc3RhbnRGcmFtZXMiLCJtZXRyaWNSYW5nZUZyYW1lcyIsImZvckVhY2giLCJpc0luc3RhbnRGcmFtZSIsInF1ZXJ5VHlwZSIsIkluc3RhbnQiLCJpbXByb3ZlRXJyb3IiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJ0cmFuc2Zvcm1CYWNrZW5kUmVzdWx0IiwicmVzcG9uc2UiLCJxdWVyaWVzIiwiZGF0YSIsImRhdGFGcmFtZXMiLCJkIiwiTWFwIiwiUmVhY3QiLCJtZW1vIiwiRWRpdG9yUm93IiwiRWRpdG9yRmllbGQiLCJJbnB1dCIsImdldE5vcm1hbGl6ZWRMb2tpUXVlcnkiLCJMb2tpT3B0aW9uRmllbGRzIiwiTG9raVF1ZXJ5RmllbGQiLCJMb2tpQW5ub3RhdGlvbnNRdWVyeUVkaXRvciIsIkxva2lBbm5vdGF0aW9uUXVlcnlFZGl0b3IiLCJwcm9wcyIsImFubm90YXRpb24iLCJvbkFubm90YXRpb25DaGFuZ2UiLCJvbkNoYW5nZVF1ZXJ5IiwiaW5zdGFudCIsInF1ZXJ5V2l0aFJlZklkIiwiZGF0YXNvdXJjZSIsInRvU3RyaW5nIiwicmVzb2x1dGlvbiIsInRpdGxlRm9ybWF0IiwiZXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFnS2V5cyIsInRleHRGb3JtYXQiLCJzaHVmZmxlIiwiUHVyZUNvbXBvbmVudCIsInJlcG9ydEludGVyYWN0aW9uIiwiREVGQVVMVF9FWEFNUExFUyIsIlBSRUZFUlJFRF9MQUJFTFMiLCJFWEFNUExFU19MSU1JVCIsIkxPR1FMX0VYQU1QTEVTIiwidGl0bGUiLCJleHByZXNzaW9uIiwiTG9raUNoZWF0U2hlZXQiLCJ1c2VyRXhhbXBsZXMiLCJwcm92aWRlciIsImxhbmd1YWdlUHJvdmlkZXIiLCJzdGFydGVkIiwiZ2V0TGFiZWxLZXlzIiwicHJlZmVycmVkTGFiZWwiLCJsIiwidmFsdWVzIiwiZ2V0TGFiZWxWYWx1ZXMiLCJzbGljZSIsInNldFN0YXRlIiwic2NoZWR1bGVVc2VyTGFiZWxDaGVja2luZyIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJjbGVhclRpbWVvdXQiLCJ1c2VyTGFiZWxUaW1lciIsInNldFRpbWVvdXQiLCJjaGVja1VzZXJMYWJlbHMiLCJyZW5kZXJFeHByZXNzaW9uIiwib25DbGlja0V4YW1wbGUiLCJvbkNsaWNrIiwiZSIsInJlbmRlciIsInN0YXRlIiwiaGFzVXNlckV4YW1wbGVzIiwiZXhhbXBsZSIsIml0ZW0iLCJMb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yIiwiaGlzdG9yeSIsIm9uQ2hhbmdlIiwib25SdW5RdWVyeSIsInJhbmdlIiwidGVzdElkcyIsImVkaXRvciIsImRpc3BsYXlOYW1lIiwiY3NzIiwiY3giLCJzb3J0QnkiLCJGaXhlZFNpemVMaXN0IiwiQnV0dG9uIiwiSG9yaXpvbnRhbEdyb3VwIiwiTGFiZWwiLCJMb2FkaW5nUGxhY2Vob2xkZXIiLCJ3aXRoVGhlbWUyIiwiQnJvd3NlckxhYmVsIiwiTG9raUxhYmVsIiwiZnV6enlNYXRjaCIsImVzY2FwZUxhYmVsVmFsdWVJbkV4YWN0U2VsZWN0b3IiLCJlc2NhcGVMYWJlbFZhbHVlSW5SZWdleFNlbGVjdG9yIiwiTUFYX0xBQkVMX0NPVU5UIiwiTUFYX1ZBTFVFX0NPVU5UIiwiTUFYX0FVVE9fU0VMRUNUIiwiRU1QVFlfU0VMRUNUT1IiLCJidWlsZFNlbGVjdG9yIiwic2VsZWN0ZWRMYWJlbHMiLCJzZWxlY3RlZCIsInNlbGVjdGVkVmFsdWVzIiwiam9pbiIsImZhY2V0TGFiZWxzIiwicG9zc2libGVMYWJlbHMiLCJsYXN0RmFjZXR0ZWQiLCJwb3NzaWJsZVZhbHVlcyIsImV4aXN0aW5nVmFsdWVzIiwiU2V0IiwiaGFzIiwibG9hZGluZyIsImZhY2V0cyIsImhpZGRlbiIsImdldFN0eWxlcyIsInRoZW1lIiwid3JhcHBlciIsImNvbG9ycyIsImJhY2tncm91bmQiLCJzZWNvbmRhcnkiLCJzcGFjaW5nIiwibGlzdCIsInNlY3Rpb24iLCJzZWxlY3RvciIsInR5cG9ncmFwaHkiLCJmb250RmFtaWx5TW9ub3NwYWNlIiwic3RhdHVzIiwidGV4dCIsInN0YXR1c1Nob3dpbmciLCJtYWluIiwidmFsdWVMaXN0IiwidmFsdWVMaXN0V3JhcHBlciIsImJvcmRlciIsIm1lZGl1bSIsInZhbHVlTGlzdEFyZWEiLCJ2YWx1ZVRpdGxlIiwidmFsaWRhdGlvblN0YXR1cyIsIm1heENvbnRyYXN0IiwiVW50aGVtZWRMb2tpTGFiZWxCcm93c2VyIiwiQ29tcG9uZW50Iiwic2VhcmNoVGVybSIsInRhcmdldCIsImFwcCIsImNsb3NlVHlwZSIsImRlbGV0ZUxhc3RVc2VkTGFiZWxzIiwibmV4dFZhbHVlIiwidXBkYXRlTGFiZWxTdGF0ZSIsImRvRmFjZXR0aW5nRm9yTGFiZWwiLCJ2IiwiZG9GYWNldHRpbmciLCJ2YWxpZGF0ZVNlbGVjdG9yIiwiZmV0Y2hWYWx1ZXMiLCJmZXRjaFNlcmllcyIsInVwZGF0ZWRGaWVsZHMiLCJjYiIsImF1dG9TZWxlY3QiLCJsYXN0VXNlZExhYmVscyIsInRoZW4iLCJyYXdMYWJlbHMiLCJhcnIiLCJzdG9yZUxhc3RVc2VkTGFiZWxzIiwicmF3VmFsdWVzIiwiY29uc29sZSIsImZldGNoU2VyaWVzTGFiZWxzIiwiT2JqZWN0Iiwia2V5cyIsInN0cmVhbXMiLCJzdHlsZXMiLCJlbXB0eSIsInNlYXJjaFJlc3VsdHMiLCJoaWdobGlnaHRQYXJ0cyIsImZ1enp5TWF0Y2hSZXN1bHQiLCJ0b0xvd2VyQ2FzZSIsImZvdW5kIiwicmFuZ2VzIiwib3JkZXIiLCJkaXN0YW5jZSIsIkluZmluaXR5Iiwib25DbGlja0xhYmVsIiwib25DaGFuZ2VTZWFyY2giLCJpbmRleCIsInN0eWxlIiwib25DbGlja1ZhbHVlIiwib25DbGlja1J1bkxvZ3NRdWVyeSIsIm9uQ2xpY2tSdW5NZXRyaWNzUXVlcnkiLCJvbkNsaWNrVmFsaWRhdGUiLCJvbkNsaWNrQ2xlYXIiLCJMb2tpTGFiZWxCcm93c2VyIiwiY29uZmlnIiwiSW5saW5lRm9ybUxhYmVsIiwiUmFkaW9CdXR0b25Hcm91cCIsIklubGluZUZpZWxkIiwiU2VsZWN0IiwicXVlcnlUeXBlT3B0aW9ucyIsIlJhbmdlIiwiZGVzY3JpcHRpb24iLCJmZWF0dXJlVG9nZ2xlcyIsImxva2lMaXZlIiwiU3RyZWFtIiwiREVGQVVMVF9SRVNPTFVUSU9OIiwiUkVTT0xVVElPTl9PUFRJT05TIiwiY29uY2F0IiwibGluZUxpbWl0VmFsdWUiLCJydW5PbkJsdXIiLCJvbkNoYW5nZVF1ZXJ5TGltaXQiLCJuZXh0UXVlcnkiLCJwcmVwcm9jZXNzTWF4TGluZXMiLCJvblF1ZXJ5VHlwZUNoYW5nZSIsIm9uTWF4TGluZXNDaGFuZ2UiLCJvblJldHVybktleURvd24iLCJvblJlc29sdXRpb25DaGFuZ2UiLCJvcHRpb24iLCJOYU4iLCJpc05hTiIsIkxva2lRdWVyeUVkaXRvciIsIm9uTGVnZW5kQ2hhbmdlIiwibGVnZW5kRm9ybWF0IiwibGVnZW5kRmllbGQiLCJDb3JlQXBwIiwiTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3IiLCJMb2tpUXVlcnlFZGl0b3JGb3JBbGVydGluZyIsIkxva2lRdWVyeUVkaXRvckJ5QXBwIiwiQ2xvdWRBbGVydGluZyIsIkV4cGxvcmUiLCJsb2tpUXVlcnlCdWlsZGVyIiwibGFuZ3VhZ2VzIiwicHJpc21MYW5ndWFnZXMiLCJTbGF0ZVByaXNtIiwiUXVlcnlGaWVsZCIsIkJyYWNlc1BsdWdpbiIsIkRPTVV0aWwiLCJJY29uIiwiTG9jYWxTdG9yYWdlVmFsdWVQcm92aWRlciIsImVzY2FwZUxhYmVsVmFsdWVJblNlbGVjdG9yIiwic2hvdWxkUmVmcmVzaExhYmVscyIsIkxBU1RfVVNFRF9MQUJFTFNfS0VZIiwiZ2V0Q2hvb3NlclRleHQiLCJoYXNTeW50YXgiLCJoYXNMb2dMYWJlbHMiLCJ3aWxsQXBwbHlTdWdnZXN0aW9uIiwic3VnZ2VzdGlvbiIsInR5cGVhaGVhZENvbnRleHQiLCJ0eXBlYWhlYWRUZXh0IiwibmV4dENoYXIiLCJnZXROZXh0Q2hhcmFjdGVyIiwic3VnZ2VzdGlvbk1vZGlmaWVkIiwiY29uc3RydWN0b3IiLCJsYWJlbEJyb3dzZXJWaXNpYmxlIiwib3ZlcnJpZGUiLCJ0eXBlYWhlYWQiLCJzdWdnZXN0aW9ucyIsImxva2lMYW5ndWFnZVByb3ZpZGVyIiwicHJlZml4Iiwid3JhcHBlckNsYXNzZXMiLCJsYWJlbEtleSIsInJlc3VsdCIsInByb3ZpZGVDb21wbGV0aW9uSXRlbXMiLCJsYWJlbHNMb2FkZWQiLCJwbHVnaW5zIiwib25seUluIiwibm9kZSIsIm9iamVjdCIsImdldFN5bnRheCIsImxvZ3FsIiwiX2lzTW91bnRlZCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInJlZnJlc2hMYWJlbHMiLCJmZXRjaExhYmVscyIsIkV4dHJhRmllbGRFbGVtZW50IiwicGxhY2Vob2xkZXIiLCJjbGVhblRleHQiLCJjaG9vc2VyVGV4dCIsImJ1dHRvbkRpc2FibGVkIiwib25MYXN0VXNlZExhYmVsc1NhdmUiLCJvbkxhc3RVc2VkTGFiZWxzRGVsZXRlIiwib25DbGlja0Nob29zZXJCdXR0b24iLCJvblR5cGVhaGVhZCIsIm9uQmx1ciIsIm9uQ2hhbmdlTGFiZWxCcm93c2VyIiwiQWxlcnRpbmdTZXR0aW5ncyIsIkRhdGFTb3VyY2VIdHRwU2V0dGluZ3MiLCJnZXRBbGxBbGVydG1hbmFnZXJEYXRhU291cmNlcyIsIkRlcml2ZWRGaWVsZHMiLCJNYXhMaW5lc0ZpZWxkIiwibWFrZUpzb25VcGRhdGVyIiwib3B0aW9ucyIsImpzb25EYXRhIiwic2V0TWF4TGluZXMiLCJzZXREZXJpdmVkRmllbGRzIiwiQ29uZmlnRWRpdG9yIiwib25PcHRpb25zQ2hhbmdlIiwiYWxlcnRtYW5hZ2VycyIsInVzZVN0YXRlIiwiQXJyYXlWZWN0b3IiLCJMZWdhY3lGb3JtcyIsImdldEZpZWxkTGlua3NGb3JFeHBsb3JlIiwiRm9ybUZpZWxkIiwiRGVidWdTZWN0aW9uIiwiY2xhc3NOYW1lIiwiZGVidWdUZXh0Iiwic2V0RGVidWdUZXh0IiwiZGVidWdGaWVsZHMiLCJtYWtlRGVidWdGaWVsZHMiLCJEZWJ1Z0ZpZWxkcyIsImhyZWYiLCJtYXRjaGVyUmVnZXgiLCJ0ZXN0TWF0Y2giLCJsaW5rIiwidXJsIiwic3RyaW5nIiwibGlua3MiLCJyb3dJbmRleCIsInVzZUVmZmVjdCIsInVzZVByZXZpb3VzIiwiRGF0YVNvdXJjZVBpY2tlciIsIkRhdGFMaW5rSW5wdXQiLCJzdHlsZXNGYWN0b3J5IiwiU3dpdGNoIiwicm93IiwibmFtZUZpZWxkIiwicmVnZXhGaWVsZCIsInVybEZpZWxkIiwidXJsRGlzcGxheUxhYmVsRmllbGQiLCJEZXJpdmVkRmllbGQiLCJvbkRlbGV0ZSIsInNob3dJbnRlcm5hbExpbmsiLCJzZXRTaG93SW50ZXJuYWxMaW5rIiwiZGF0YXNvdXJjZVVpZCIsInByZXZpb3VzVWlkIiwiaGFuZGxlQ2hhbmdlIiwicHJldmVudERlZmF1bHQiLCJuZXdWYWx1ZSIsInVybERpc3BsYXlMYWJlbCIsImRzIiwidWlkIiwiVmFyaWFibGVPcmlnaW4iLCJEYXRhTGlua0J1aWx0SW5WYXJzIiwidXNlVGhlbWUyIiwiaW5mb1RleHQiLCJkZXJpdmVkRmllbGQiLCJzaG93RGVidWciLCJzZXRTaG93RGVidWciLCJuZXdGaWVsZCIsIm5ld0Rlcml2ZWRGaWVsZHMiLCJzcGxpY2UiLCJ2YWx1ZVJhdyIsImRvY3VtZW50YXRpb24iLCJvcmlnaW4iLCJWYWx1ZSIsImNsb25lRGVlcCIsImxvZGFzaE1hcCIsIlByaXNtIiwibGFzdFZhbHVlRnJvbSIsIm1lcmdlIiwib2YiLCJ0aHJvd0Vycm9yIiwiY2F0Y2hFcnJvciIsInN3aXRjaE1hcCIsIkRhdGFGcmFtZVZpZXciLCJkYXRlTWF0aCIsIkZpZWxkQ2FjaGUiLCJnZXRMb2dMZXZlbEZyb21LZXkiLCJMb2FkaW5nU3RhdGUiLCJMb2dMZXZlbCIsInJhbmdlVXRpbCIsInRvVXRjIiwiRGF0YVNvdXJjZVdpdGhCYWNrZW5kIiwicXVlcnlMb2dzVm9sdW1lIiwiY29udmVydFRvV2ViU29ja2V0VXJsIiwiZ2V0VGltZVNydiIsImdldFRlbXBsYXRlU3J2Iiwic2VyaWFsaXplUGFyYW1zIiwicmVuZGVyTGVnZW5kRm9ybWF0IiwiTGFuZ3VhZ2VQcm92aWRlciIsIkxpdmVTdHJlYW1zIiwic29ydERhdGFGcmFtZUJ5VGltZSIsImRvTG9raUNoYW5uZWxTdHJlYW0iLCJzeW50YXgiLCJMb2tpUXVlcnlEaXJlY3Rpb24iLCJERUZBVUxUX01BWF9MSU5FUyIsIkxPS0lfRU5EUE9JTlQiLCJOU19JTl9NUyIsIm1ha2VSZXF1ZXN0IiwicmVxdWVzdElkIiwiaW50ZXJ2YWxJbmZvIiwiY2FsY3VsYXRlSW50ZXJ2YWwiLCJ0YXJnZXRzIiwiaW50ZXJ2YWwiLCJpbnRlcnZhbE1zIiwic2NvcGVkVmFycyIsInRpbWV6b25lIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsIkxva2lEYXRhc291cmNlIiwiaW5zdGFuY2VTZXR0aW5ncyIsInRlbXBsYXRlU3J2IiwidGltZVNydiIsIm1heERhdGFQb2ludHMiLCJsaXZlVGFyZ2V0IiwiY3JlYXRlTGl2ZVRhcmdldCIsImdldFN0cmVhbSIsInBpcGUiLCJTdHJlYW1pbmciLCJlcnIiLCJyZWFzb24iLCJkaXJlY3Rpb24iLCJwcmVwYXJlTG9nUm93Q29udGV4dFF1ZXJ5VGFyZ2V0IiwicHJvY2Vzc0RhdGFGcmFtZSIsImNhY2hlIiwidGltZXN0YW1wRmllbGQiLCJnZXRGaXJzdEZpZWxkT2ZUeXBlIiwibGluZUZpZWxkIiwiaWRGaWVsZCIsImdldEZpZWxkQnlOYW1lIiwicHJvY2Vzc1Jlc3VsdHMiLCJwcm9jZXNzZWRGcmFtZXMiLCJzdGF0dXNUZXh0IiwicmVzIiwicmVwbGFjZSIsImNvbnRleHRUaW1lQnVmZmVyIiwicXVlcnlEaXJlY3Rpb24iLCJGb3J3YXJkIiwiQmFja3dhcmQiLCJmaWVsZENhY2hlIiwiZGF0YUZyYW1lIiwidHNGaWVsZCIsInRzVmFsdWUiLCJ0aW1lc3RhbXAiLCJ0aW1lRXBvY2hNcyIsInJhdyIsInNldHRpbmdzRGF0YSIsInBhcnNlSW50IiwiYW5ub3RhdGlvbnMiLCJRdWVyeUVkaXRvciIsImdldExvZ3NWb2x1bWVEYXRhUHJvdmlkZXIiLCJyZXF1ZXN0IiwiaXNRdWVyeVN1aXRhYmxlIiwibm9ybWFsaXplZCIsImlzTWV0cmljc1F1ZXJ5IiwiaXNMb2dzVm9sdW1lQXZhaWxhYmxlIiwic29tZSIsImxvZ3NWb2x1bWVSZXF1ZXN0Iiwidm9sdW1lUXVlcnkiLCJleHRyYWN0TGV2ZWwiLCJxIiwiZml4ZWRSZXF1ZXN0Iiwic3RyZWFtUXVlcmllcyIsInJhbmdlUmF3Iiwic3RyZWFtUmVxdWVzdCIsImxpdmVTdHJlYW1pbmciLCJydW5MaXZlUXVlcnlUaHJvdWdoQmFja2VuZCIsImxvZ3NRdWVyaWVzIiwiRG9uZSIsInN1YlF1ZXJpZXMiLCJydW5MaXZlUXVlcnkiLCJiYXNlVXJsIiwicGFyYW1zIiwic2l6ZSIsImdldFJhbmdlU2NvcGVkVmFycyIsInRpbWVSYW5nZSIsIm1zUmFuZ2UiLCJkaWZmIiwic1JhbmdlIiwiTWF0aCIsInJvdW5kIiwiX19yYW5nZV9tcyIsIl9fcmFuZ2VfcyIsIl9fcmFuZ2UiLCJpbnRlcnBvbGF0ZVZhcmlhYmxlc0luUXVlcmllcyIsImV4cGFuZGVkUXVlcmllcyIsImdldFJlZiIsImludGVycG9sYXRlUXVlcnlFeHByIiwiZ2V0UXVlcnlEaXNwbGF5VGV4dCIsImdldFRpbWVSYW5nZVBhcmFtcyIsInZhbHVlT2YiLCJpbXBvcnRGcm9tQWJzdHJhY3RRdWVyaWVzIiwiYWJzdHJhY3RRdWVyaWVzIiwiZXhpc3RpbmdLZXlzIiwibGFiZWxLZXlzIiwiYWJzdHJhY3RRdWVyeSIsImxhYmVsTWF0Y2hlcnMiLCJsYWJlbE1hdGNoZXIiLCJpbXBvcnRGcm9tQWJzdHJhY3RRdWVyeSIsImV4cG9ydFRvQWJzdHJhY3RRdWVyaWVzIiwiZXhwb3J0VG9BYnN0cmFjdFF1ZXJ5IiwibWV0YWRhdGFSZXF1ZXN0Iiwic3RhcnRzV2l0aCIsImdldFJlc291cmNlIiwibWV0cmljRmluZFF1ZXJ5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbnRlcnBvbGF0ZWQiLCJwcm9jZXNzTWV0cmljRmluZFF1ZXJ5IiwibGFiZWxOYW1lc1JlZ2V4IiwibGFiZWxWYWx1ZXNSZWdleCIsImxhYmVsTmFtZXMiLCJsYWJlbE5hbWVzUXVlcnkiLCJsYWJlbFZhbHVlcyIsImxhYmVsVmFsdWVzU2VyaWVzUXVlcnkiLCJsYWJlbFZhbHVlc1F1ZXJ5IiwidGltZVBhcmFtcyIsInN0cmVhbSIsImFkZCIsIkFycmF5IiwiZ2V0VGFnS2V5cyIsImdldFRhZ1ZhbHVlcyIsInZhcmlhYmxlIiwibXVsdGkiLCJpbmNsdWRlQWxsIiwibG9raVJlZ3VsYXJFc2NhcGUiLCJsb2tpU3BlY2lhbFJlZ2V4RXNjYXBlIiwiZXNjYXBlZFZhbHVlcyIsIm1vZGlmeVF1ZXJ5IiwiYWN0aW9uIiwiZ2V0VGltZSIsImRhdGUiLCJyb3VuZFVwIiwiY2VpbCIsInRlc3REYXRhc291cmNlIiwibm93TXMiLCJpbmZvIiwiaW5mb0luUGFyZW50aGVzZXMiLCJhbm5vdGF0aW9uUXVlcnkiLCJpZCIsIkRhc2hib2FyZCIsInNwbGl0S2V5cyIsInNwbGl0IiwidmlldyIsIm1heWJlRHVwbGljYXRlZFRhZ3MiLCJlbnRyaWVzIiwidmFsIiwidHJpbSIsInRhZ3MiLCJUaW1lIiwiTGluZSIsInNob3dDb250ZXh0VG9nZ2xlIiwicHJvY2Vzc0Vycm9yIiwiYWRkQWRIb2NGaWx0ZXJzIiwicXVlcnlFeHByIiwiYWRob2NGaWx0ZXJzIiwiZ2V0QWRob2NGaWx0ZXJzIiwicmVkdWNlIiwiYWNjIiwiZXNjYXBlZFZhbHVlIiwiZmlsdGVyUXVlcnkiLCJoaWRlIiwiYXBwbHlUZW1wbGF0ZVZhcmlhYmxlcyIsImV4cHJXaXRoQWRIb2MiLCJpbnRlcnBvbGF0ZVN0cmluZyIsImdldFZhcmlhYmxlcyIsInRva2VucyIsInRva2VuaXplIiwidCIsInZhbHVlRmllbGQiLCJnZXRMb2dMZXZlbEZyb21MYWJlbHMiLCJ1bmtub3duIiwibGV2ZWxMYWJlbCIsImxhYmVsTmFtZSIsImdyb3VwQnkiLCJnZXREYXRhU291cmNlU3J2IiwiZGVyaXZlZEZpZWxkc0dyb3VwZWQiLCJuZXdGaWVsZHMiLCJmaWVsZEZyb21EZXJpdmVkRmllbGRDb25maWciLCJmIiwidG9BcnJheSIsImxpbmUiLCJsb2dNYXRjaCIsImRhdGFTb3VyY2VTcnYiLCJkYXRhTGlua3MiLCJkZXJpdmVkRmllbGRDb25maWciLCJkc1NldHRpbmdzIiwiZ2V0SW5zdGFuY2VTZXR0aW5ncyIsImludGVybmFsIiwiZGF0YXNvdXJjZU5hbWUiLCJjaGFpbiIsImRpZmZlcmVuY2UiLCJMUlUiLCJkYXRlVGltZSIsImV4dHJhY3RMYWJlbE1hdGNoZXJzIiwicGFyc2VTZWxlY3RvciIsInByb2Nlc3NMYWJlbHMiLCJ0b1Byb21MaWtlRXhwciIsIkZVTkNUSU9OUyIsIlBJUEVfUEFSU0VSUyIsIlBJUEVfT1BFUkFUT1JTIiwiREVGQVVMVF9LRVlTIiwiSElTVE9SWV9JVEVNX0NPVU5UIiwiSElTVE9SWV9DT1VOVF9DVVRPRkYiLCJSQVRFX1JBTkdFUyIsInNvcnRWYWx1ZSIsIkxBQkVMX1JFRlJFU0hfSU5URVJWQUwiLCJ3cmFwTGFiZWwiLCJmaWx0ZXJUZXh0IiwiYWRkSGlzdG9yeU1ldGFkYXRhIiwiY3V0b2ZmVHMiLCJoaXN0b3J5Rm9ySXRlbSIsImgiLCJ0cyIsImhpbnQiLCJyZWNlbnQiLCJsYXN0UXVlcmllZCIsImZyb21Ob3ciLCJMb2tpTGFuZ3VhZ2VQcm92aWRlciIsImluaXRpYWxWYWx1ZXMiLCJtYXgiLCJzIiwic3RhcnRUYXNrIiwiY29udGV4dCIsImdldEVtcHR5Q29tcGxldGlvbkl0ZW1zIiwiZ2V0VGVybUNvbXBsZXRpb25JdGVtcyIsInByZWZpeE1hdGNoIiwiaXRlbXMiLCJraW5kIiwiaW50ZXJwb2xhdGVkTWF0Y2giLCJjYWNoZUtleSIsImdlbmVyYXRlQ2FjaGVLZXkiLCJzZXJpZXNDYWNoZSIsInNldCIsImxhYmVsRmV0Y2hUcyIsImFzc2lnbiIsImlucHV0IiwiZW1wdHlSZXN1bHQiLCJkb2N1bWVudCIsInNlbGVjdGVkTGluZXMiLCJnZXRUZXh0c0F0UmFuZ2UiLCJzZWxlY3Rpb24iLCJjdXJyZW50TGluZSIsImZpcnN0IiwiZ2V0VGV4dCIsIm5leHRDaGFyYWN0ZXIiLCJhbmNob3IiLCJvZmZzZXQiLCJ0b2tlblJlY29nbml6ZWQiLCJwcmVmaXhVbnJlY29nbml6ZWQiLCJub1N1ZmZpeCIsInNhZmVQcmVmaXgiLCJvcGVyYXRvcnNQYXR0ZXJuIiwiaXNOZXh0T3BlcmFuZCIsImdldFJhbmdlQ29tcGxldGlvbkl0ZW1zIiwiZ2V0TGFiZWxDb21wbGV0aW9uSXRlbXMiLCJnZXRQaXBlQ29tcGxldGlvbkl0ZW0iLCJnZXRCZWdpbm5pbmdDb21wbGV0aW9uSXRlbXMiLCJoaXN0b3J5SXRlbXMiLCJ1bmlxIiwidGFrZSIsInNraXBTb3J0IiwiYW5jaG9yQmxvY2siLCJjdXJzb3JPZmZzZXQiLCJpc1ZhbHVlU3RhcnQiLCJwYXJzZWRTZWxlY3RvciIsImFsbExhYmVscyIsImxhYmVsVmFsdWVzRm9yS2V5IiwiZ2V0U2VyaWVzTGFiZWxzIiwid2FybiIsInBvc3NpYmxlS2V5cyIsIm5ld0l0ZW1zIiwibmV3U3VnZ2VzdGlvbiIsImxhYmVsQmFzZWRRdWVyeSIsImxva2lRdWVyeSIsImxvb2t1cHNEaXNhYmxlZCIsImlzQXJyYXkiLCJzb3J0IiwicmVmcmVzaExvZ0xhYmVscyIsImZvcmNlUmVmcmVzaCIsInBhcmFtIiwicm91bmRUaW1lIiwibmFub3MiLCJmbG9vciIsImZldGNoTGFiZWxWYWx1ZXMiLCJpbnRlcnBvbGF0ZWRLZXkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyYW5nZVBhcmFtcyIsImxhYmVsc0NhY2hlIiwicm91bmRNc1RvTWluIiwibWlsbGlzZWNvbmRzIiwicm91bmRTZWNUb01pbiIsInNlY29uZHMiLCJwcmV2UmFuZ2UiLCJzYW1lTWludXRlRnJvbSIsInNhbWVNaW51dGVUbyIsIlJFMl9NRVRBQ0hBUkFDVEVSUyIsImVzY2FwZUxva2lSZWdleHAiLCJsYWJlbFZhbHVlIiwiaXNSZWdleFNlbGVjdG9yIiwidGltZXIiLCJmaW5hbGl6ZSIsInJldHJ5V2hlbiIsIm1lcmdlTWFwIiwid2ViU29ja2V0IiwicGFyc2VMYWJlbHMiLCJDaXJjdWxhckRhdGFGcmFtZSIsImFwcGVuZFJlc3BvbnNlVG9CdWZmZXJlZERhdGEiLCJyZXRyeUludGVydmFsIiwiY2FwYWNpdHkiLCJhZGRGaWVsZCIsIm90aGVyIiwiYXR0ZW1wdHMiLCJyZXRyeUF0dGVtcHQiLCJjb2RlIiwidjUiLCJ1dWlkdjUiLCJmaW5kVW5pcXVlTGFiZWxzIiwiVVVJRF9OQU1FU1BBQ0UiLCJiYXNlTGFiZWxzIiwibGFiZWxzRmllbGQiLCJ0c05zRmllbGQiLCJ1c2VkVWlkcyIsInVuaXF1ZSIsImFsbExhYmVsc1N0cmluZyIsInRvSVNPU3RyaW5nIiwiY3JlYXRlVWlkIiwibGFiZWxzU3RyaW5nIiwibmV3Q291bnQiLCJpbnN0YW50TWV0cmljRnJhbWVzIiwiZnJhbWVzV2l0aFJlZklkIiwiZnJhbWVzQnlSZWZJZCIsIm1ha2VUYWJsZUZyYW1lIiwidGFibGVUaW1lRmllbGQiLCJ0YWJsZVZhbHVlRmllbGQiLCJhbGxMYWJlbE5hbWVzIiwiZmxhdCIsInNvcnRlZExhYmVsTmFtZXMiLCJsYWJlbEZpZWxkcyIsImZpbHRlcmFibGUiLCJ0aW1lRmllbGQiLCJ0aW1lQXJyYXkiLCJ2YWx1ZUFycmF5IiwieCIsIkRhdGFTb3VyY2VQbHVnaW4iLCJwbHVnaW4iLCJzZXRRdWVyeUVkaXRvciIsInNldENvbmZpZ0VkaXRvciIsInNldFF1ZXJ5RWRpdG9ySGVscCIsImVzY2FwZVJlZ0V4cCIsInJlc3VsdHMiLCJmaWx0ZXJTdGFydCIsInNlYXJjaCIsImZpbHRlck9wZXJhdG9yIiwic2tpcCIsImZpbHRlckVuZCIsImZpbHRlclRlcm0iLCJxdW90ZWRUZXJtIiwiYmFja3RpY2tlZFRlcm0iLCJ0ZXJtIiwidW53cmFwcGVkRmlsdGVyVGVybSIsInJlZ2V4T3BlcmF0b3IiLCJoYXNWYWxpZFF1ZXJ5VHlwZSIsIkxva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UiLCJnZXRPcGVyYXRpb25EZWZpbml0aW9ucyIsIkxva2lPcGVyYXRpb25JZCIsIkxva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5Iiwic2V0T3BlcmF0aW9uQ2F0ZWdvcmllcyIsIkFnZ3JlZ2F0aW9ucyIsIlJhbmdlRnVuY3Rpb25zIiwiRm9ybWF0cyIsIkJpbmFyeU9wcyIsIkxhYmVsRmlsdGVycyIsIkxpbmVGaWx0ZXJzIiwicmVuZGVyTGFiZWxzIiwiZ2V0UXVlcnlQYXR0ZXJucyIsIm9wZXJhdGlvbnMiLCJMb2dmbXQiLCJMYWJlbEZpbHRlck5vRXJyb3JzIiwiTGluZUNvbnRhaW5zIiwiTGFiZWxGaWx0ZXIiLCJKc29uIiwiTGluZUZvcm1hdCIsIkxhYmVsRm9ybWF0IiwiVW53cmFwIiwiU3VtT3ZlclRpbWUiLCJTdW0iLCJDb3VudE92ZXJUaW1lIiwiQnl0ZXNPdmVyVGltZSIsIlRvcEsiLCJRdWFudGlsZU92ZXJUaW1lIiwibG9raVF1ZXJ5TW9kZWxsZXIiLCJkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlciIsImJpbmFyeVNjYWxhckRlZnMiLCJBZGRpdGlvbiIsInNpZ24iLCJTdWJ0cmFjdGlvbiIsIk11bHRpcGx5QnkiLCJEaXZpZGVCeSIsIk1vZHVsbyIsIkV4cG9uZW50IiwiRXF1YWxUbyIsImNvbXBhcmlzb24iLCJOb3RFcXVhbFRvIiwiR3JlYXRlclRoYW4iLCJMZXNzVGhhbiIsIkdyZWF0ZXJPckVxdWFsIiwiTGVzc09yRXF1YWwiLCJiaW5hcnlTY2FsYXJPcGVyYXRpb25zIiwib3BEZWYiLCJkZWZhdWx0UGFyYW1zIiwidW5zaGlmdCIsImFsdGVybmF0aXZlc0tleSIsImNhdGVnb3J5IiwicmVuZGVyZXIiLCJnZXRTaW1wbGVCaW5hcnlSZW5kZXJlciIsImFkZE9wZXJhdGlvbkhhbmRsZXIiLCJiaW5hcnlSZW5kZXJlciIsIm1vZGVsIiwiZGVmIiwiaW5uZXJFeHByIiwiYm9vbCIsInVzZU1lbW8iLCJPcGVyYXRpb25MaXN0IiwiT3BlcmF0aW9uc0VkaXRvclJvdyIsIk5lc3RlZFF1ZXJ5TGlzdCIsIkxva2lRdWVyeUJ1aWxkZXIiLCJuZXN0ZWQiLCJvbkNoYW5nZUxhYmVscyIsIndpdGhUZW1wbGF0ZVZhcmlhYmxlT3B0aW9ucyIsIm9wdGlvbnNQcm9taXNlIiwib25HZXRMYWJlbE5hbWVzIiwiZm9yTGFiZWwiLCJsYWJlbHNUb0NvbnNpZGVyIiwic2VyaWVzIiwib25HZXRMYWJlbFZhbHVlcyIsImxhYmVsRmlsdGVyRXJyb3IiLCJiaW5hcnlRdWVyaWVzIiwiY3JlYXRlU2xpY2UiLCJ1c2VSZWR1Y2VyIiwiUXVlcnlQcmV2aWV3IiwiTG9raVF1ZXJ5QnVpbGRlckNvbnRhaW5lciIsInNob3dSYXdRdWVyeSIsImRpc3BhdGNoIiwic3RhdGVTbGljZSIsInJlZHVjZXIiLCJleHByQ2hhbmdlZCIsIm9uVmlzUXVlcnlDaGFuZ2UiLCJ2aXN1YWxRdWVyeUNoYW5nZSIsImluaXRpYWxTdGF0ZSIsInJlZHVjZXJzIiwicGF5bG9hZCIsInBhcnNlUmVzdWx0IiwiYWN0aW9ucyIsIlN0YWNrIiwiT3BlcmF0aW9uRXhwbGFpbmVkQm94IiwiT3BlcmF0aW9uTGlzdEV4cGxhaW5lZCIsIlJhd1F1ZXJ5IiwibG9raUdyYW1tYXIiLCJMb2tpUXVlcnlCdWlsZGVyRXhwbGFpbmVkIiwibGFuZyIsImdyYW1tYXIiLCJBdXRvU2l6ZUlucHV0IiwiUXVlcnlPcHRpb25Hcm91cCIsIkxva2lRdWVyeUJ1aWxkZXJPcHRpb25zIiwib25MZWdlbmRGb3JtYXRDaGFuZ2VkIiwiZXZ0IiwibmV3TWF4TGluZXMiLCJzaG93TWF4TGluZXMiLCJnZXRDb2xsYXBzZWRJbmZvIiwicXVlcnlUeXBlTGFiZWwiLCJyZXNvbHV0aW9uTGFiZWwiLCJ1c2VTdHlsZXMyIiwiTG9raVF1ZXJ5Q29kZUVkaXRvciIsInVzZUNhbGxiYWNrIiwiRWRpdG9ySGVhZGVyIiwiRWRpdG9yUm93cyIsIkZsZXhJdGVtIiwiSW5saW5lU2VsZWN0IiwiU3BhY2UiLCJDb25maXJtTW9kYWwiLCJGZWVkYmFja0xpbmsiLCJRdWVyeUVkaXRvck1vZGVUb2dnbGUiLCJRdWVyeUhlYWRlclN3aXRjaCIsIlF1ZXJ5RWRpdG9yTW9kZSIsImNoYW5nZUVkaXRvck1vZGUiLCJnZXRRdWVyeVdpdGhEZWZhdWx0cyIsInVzZVJhd1F1ZXJ5IiwicGFyc2VNb2RhbE9wZW4iLCJzZXRQYXJzZU1vZGFsT3BlbiIsImRhdGFJc1N0YWxlIiwic2V0RGF0YUlzU3RhbGUiLCJyYXdRdWVyeSIsInNldFJhd1F1ZXJ5IiwiZWRpdG9yTW9kZSIsIm9uRWRpdG9yTW9kZUNoYW5nZSIsIm5ld0VkaXRvck1vZGUiLCJuZXdFZGl0b3IiLCJwcmV2aW91c0VkaXRvciIsIkJ1aWxkZXIiLCJlcnJvcnMiLCJvbkNoYW5nZUludGVybmFsIiwib25RdWVyeVByZXZpZXdDaGFuZ2UiLCJpc0VuYWJsZWQiLCJjaGVja2VkIiwiTG9hZGluZyIsIkNvZGUiLCJFeHBsYWluIiwidG9PcHRpb24iLCJJY29uQnV0dG9uIiwiTmVzdGVkUXVlcnkiLCJuZXN0ZWRRdWVyeSIsIm9uUmVtb3ZlIiwiY2FyZCIsImhlYWRlciIsIm9wZXJhdG9ycyIsInZlY3Rvck1hdGNoV3JhcHBlciIsInZlY3Rvck1hdGNoZXNUeXBlIiwidmVjdG9yTWF0Y2hJbnB1dCIsInZlY3Rvck1hdGNoZXMiLCJib2R5IiwidXBkYXRlIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJnYXAiLCJwYWRkaW5nIiwiYWxpZ25JdGVtcyIsIndoaXRlU3BhY2UiLCJwYWRkaW5nTGVmdCIsIm1hcmdpbkxlZnQiLCJuZXN0ZWRRdWVyaWVzIiwib25OZXN0ZWRRdWVyeVVwZGF0ZSIsInVwZGF0ZWRMaXN0IiwiRWRpdG9yRmllbGRHcm91cCIsImNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uIiwiY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0iLCJnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lIiwiTG9raU9wZXJhdGlvbk9yZGVyIiwiYWdncmVnYXRpb25zIiwiTWluIiwiTWF4IiwiQXZnIiwiU3RkZGV2IiwiU3RkdmFyIiwiQ291bnQiLCJmbGF0TWFwIiwib3BJZCIsImFkZExva2lPcGVyYXRpb24iLCJvcmRlclJhbmsiLCJMYXN0IiwiYWdncmVnYXRpb25zV2l0aFBhcmFtIiwiQm90dG9tSyIsImNyZWF0ZVJhbmdlT3BlcmF0aW9uIiwiUmF0ZSIsIkJ5dGVzUmF0ZSIsIkFic2VudE92ZXJUaW1lIiwiQXZnT3ZlclRpbWUiLCJNYXhPdmVyVGltZSIsIk1pbk92ZXJUaW1lIiwiRmlyc3RPdmVyVGltZSIsIkxhc3RPdmVyVGltZSIsIlN0ZHZhck92ZXJUaW1lIiwiU3RkZGV2T3ZlclRpbWUiLCJMaW5lRm9ybWF0cyIsInBpcGVsaW5lUmVuZGVyZXIiLCJleHBsYWluSGFuZGxlciIsIlJlZ2V4cCIsImhpZGVOYW1lIiwibWluV2lkdGgiLCJQYXR0ZXJuIiwiVW5wYWNrIiwicnVuUXVlcnlPbkVudGVyIiwiZ2V0TGluZUZpbHRlclJlbmRlcmVyIiwiTGluZUNvbnRhaW5zTm90IiwiTGluZU1hdGNoZXNSZWdleCIsIkxpbmVNYXRjaGVzUmVnZXhOb3QiLCJsYWJlbEZpbHRlclJlbmRlcmVyIiwiTm9FcnJvcnMiLCJTdHJpbmciLCJhZGROZXN0ZWRRdWVyeUhhbmRsZXIiLCJnZXRSYW5nZVZlY3RvclBhcmFtRGVmIiwib3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yUmVuZGVyZXIiLCJvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlckFuZFBhcmFtIiwiUmFuZ2VWZWN0b3JGdW5jdGlvbiIsIm9wRG9jcyIsImluc2VydFRleHQiLCJyYW5nZVZlY3RvciIsIm9wZXJhdGlvbiIsImxpbmVGaWx0ZXJSZW5kZXJlciIsImlzUmFuZ2VWZWN0b3JGdW5jdGlvbiIsImdldEluZGV4T2ZPckxhc3QiLCJxdWVyeU1vZGVsbGVyIiwiY29uZGl0aW9uIiwiZmluZEluZGV4IiwiZ2V0T3BlcmF0aW9uRGVmIiwibmV3T3BlcmF0aW9uIiwiZXhpc3RpbmdSYW5nZVZlY3RvckZ1bmN0aW9uIiwiRnVuY3Rpb25zIiwicGxhY2VUb0luc2VydCIsImluZGV4T2YiLCJFcnJvck5hbWUiLCJnZXRBbGxCeVR5cGUiLCJnZXRMZWZ0TW9zdENoaWxkIiwiZ2V0U3RyaW5nIiwibWFrZUJpbk9wIiwibWFrZUVycm9yIiwicmVwbGFjZVZhcmlhYmxlcyIsInJlcGxhY2VkRXhwciIsInRvcE5vZGUiLCJoYW5kbGVFeHByZXNzaW9uIiwiaXNFbXB0eVF1ZXJ5IiwiZ2V0TGFiZWwiLCJnZXRDaGlsZCIsImdldExpbmVGaWx0ZXIiLCJjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciIsImdldExhYmVsUGFyc2VyIiwiZ2V0TGFiZWxGaWx0ZXIiLCJnZXRMaW5lRm9ybWF0IiwiZ2V0TGFiZWxGb3JtYXQiLCJoYW5kbGVVbndyYXBFeHByIiwiaGFuZGxlUmFuZ2VBZ2dyZWdhdGlvbiIsImhhbmRsZVZlY3RvckFnZ3JlZ2F0aW9uIiwiaGFuZGxlQmluYXJ5IiwiaXNJbnRlcnZhbFZhcmlhYmxlRXJyb3IiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsImxhYmVsTm9kZSIsImlwTGluZUZpbHRlciIsIm1hcEZpbHRlciIsImZpbHRlckV4cHIiLCJoYW5kbGVRdW90ZXMiLCJwYXJzZXJOb2RlIiwidmFsdWVTdHJpbmciLCJpZGVudGlmaWVyIiwidW53cmFwRXhwckNoaWxkIiwibGFiZWxGaWx0ZXJDaGlsZCIsInVud3JhcENoaWxkIiwibmFtZU5vZGUiLCJmdW5jTmFtZSIsImxvZ0V4cHIiLCJncm91cGluZyIsIm51bWJlck5vZGUiLCJOdW1iZXIiLCJieU1vZGlmaWVyIiwid2l0aG91dE1vZGlmaWVyIiwibWV0cmljRXhwciIsIm9wZXJhdG9yVG9PcE5hbWUiLCJsZWZ0IiwiYmluTW9kaWZpZXIiLCJnZXRCaW5hcnlNb2RpZmllciIsInJpZ2h0IiwibGFzdENoaWxkIiwibGVmdE51bWJlciIsImdldExhc3RDaGlsZFdpdGhTZWxlY3RvciIsInJpZ2h0TnVtYmVyIiwicmlnaHRCaW5hcnkiLCJpc0Jvb2wiLCJsZWZ0TW9zdENoaWxkIiwiYmluUXVlcnkiLCJpc01hdGNoZXIiLCJtYXRjaFR5cGUiLCJtYXRjaGVzIiwibWF0Y2hlciIsInBhcmVudCIsImNoaWxkcmVuIiwic3RvcmUiLCJxdWVyeUVkaXRvck1vZGVEZWZhdWx0TG9jYWxTdG9yYWdlS2V5IiwiZ2V0RGVmYXVsdEVkaXRvck1vZGUiLCJxdWVyeUVkaXRvclJhd1F1ZXJ5TG9jYWxTdG9yYWdlS2V5IiwiZ2V0UmF3UXVlcnlWaXNpYmlsaXR5IiwiQm9vbGVhbiIsInNldFJhd1F1ZXJ5VmlzaWJpbGl0eSIsInNldHRlciIsImxhYmVsU2V0cyIsIl9fZXJyb3JfXyIsIlNvcnRlZFZlY3RvciIsIm1ha2VJbmRleCIsImRpciIsImZpZWxkVmFsdWVzIiwiaXNBc2MiLCJhIiwiYiIsInZhbEEiLCJ2YWxCIiwiZGVmZXIiLCJMaXZlQ2hhbm5lbFNjb3BlIiwiZ2V0R3JhZmFuYUxpdmVTcnYiLCJTdHJlYW1pbmdEYXRhRnJhbWUiLCJnZXRMaXZlU3RyZWFtS2V5Iiwic3RyIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1zZ1VpbnQ4IiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJoYXNoQnVmZmVyIiwiY3J5cHRvIiwic3VidGxlIiwiZGlnZXN0IiwiaGFzaEFycmF5IiwiVWludDhBcnJheSIsInBhZFN0YXJ0IiwibWF4RGVsdGEiLCJtYXhMZW5ndGgiLCJ1cGRhdGVGcmFtZSIsIm1zZyIsInAiLCJmcm9tRGF0YUZyYW1lSlNPTiIsImRpc3BsYXlOYW1lRm9ybWF0Iiwic2NvcGUiLCJEYXRhU291cmNlIiwibmFtZXNwYWNlIiwicGF0aCIsIkFHR1JFR0FUSU9OX09QRVJBVE9SUyIsIm1vdmUiLCJkZXRhaWwiLCJSQU5HRV9WRUNfRlVOQ1RJT05TIiwiTE9LSV9LRVlXT1JEUyIsImtleXdvcmQiLCJjb21tZW50IiwicGF0dGVybiIsImxvb2tiZWhpbmQiLCJpbnNpZGUiLCJhbGlhcyIsInB1bmN0dWF0aW9uIiwiZ3JlZWR5IiwiUmVnRXhwIiwiZnVuY3Rpb24iLCJxdW90ZSIsImJhY2t0aWNrcyIsIkxva2lSZXN1bHRUeXBlIiwiUHJvbVF1ZXJ5TW9kZWxsZXIiLCJnZXRWZWN0b3JTZWxlY3RvclBvc2l0aW9ucyIsImFkZEZpbHRlciIsInRyYW5zZm9ybWVkVmFsdWUiLCJvbmNlIiwiQWJzdHJhY3RMYWJlbE9wZXJhdG9yIiwiU2VhcmNoRnVuY3Rpb25UeXBlIiwiYWRkTGltaXRJbmZvIiwiZml4U3VtbWFyaWVzTWV0YWRhdGEiLCJwcm9jZXNzSGlzdG9ncmFtTWV0cmljcyIsInRvUHJvbUxpa2VRdWVyeSIsIlByb21xbFN5bnRheCIsIlNVR0dFU1RJT05TX0xJTUlUIiwic2V0RnVuY3Rpb25LaW5kIiwiY291bnQiLCJhZGRNZXRyaWNzTWV0YWRhdGEiLCJtZXRyaWMiLCJtZXRhZGF0YSIsImdldE1ldGFkYXRhU3RyaW5nIiwiaGVscCIsInRvVXBwZXJDYXNlIiwiUFJFRklYX0RFTElNSVRFUl9SRUdFWCIsIlByb21RbExhbmd1YWdlUHJvdmlkZXIiLCJkZWZhdWx0VmFsdWUiLCJtZXRyaWNzIiwibG9hZE1ldHJpY3NNZXRhZGF0YSIsImhpc3RvZ3JhbU1ldHJpY3MiLCJnZXRBZ2dyZWdhdGlvbkNvbXBsZXRpb25JdGVtcyIsInNlYXJjaEZ1bmN0aW9uVHlwZSIsIlByZWZpeCIsIm1ldHJpY3NNZXRhZGF0YSIsIm0iLCJGdXp6eSIsInF1ZXJ5T2Zmc2V0IiwicXVlcnlUZXh0IiwiZ2V0QmxvY2tzIiwiYmxvY2siLCJibG9ja1RleHQiLCJvcGVuUGFyZW5zQWdncmVnYXRpb25JbmRleCIsImxhc3RJbmRleE9mIiwib3BlblBhcmVuc1NlbGVjdG9ySW5kZXgiLCJjbG9zZVBhcmVuc1NlbGVjdG9ySW5kZXgiLCJjbG9zZVBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXgiLCJzZWxlY3RvclN0cmluZyIsImdldFNlcmllcyIsImxpbWl0SW5mbyIsInN1ZmZpeCIsInN1YnN0ciIsImlzVmFsdWVFbmQiLCJpc1ByZVZhbHVlIiwiaXNWYWx1ZUVtcHR5IiwiaGFzVmFsdWVQcmVmaXgiLCJjb250YWluc01ldHJpYyIsIndpdGhOYW1lIiwiaW50ZXJwb2xhdGVkTmFtZSIsInVybFBhcmFtcyIsImNhY2hlUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYWxsIiwicGFydHMiLCJsYXN0IiwicG9wIiwidHJpbUxlZnQiLCJwcm9tUXVlcnkiLCJuYW1lTGFiZWxWYWx1ZSIsImdldE5hbWVMYWJlbFZhbHVlIiwiRXF1YWwiLCJmZXRjaERlZmF1bHRTZXJpZXMiLCJwcm9wIiwiaW52ZXJ0IiwiVG9rZW4iLCJyZXN1bHRTZXQiLCJyZWdleHAiLCJpc0hpc3RvZ3JhbVZhbHVlIiwidGVzdCIsInZhbHVlU2V0IiwiX19uYW1lX18iLCJsaW1pdFN1Z2dlc3Rpb25zIiwic2VsZWN0b3JSZWdleHAiLCJsYWJlbFJlZ2V4cCIsInByZWZpeE9wZW4iLCJwcmVmaXhDbG9zZSIsInN1ZmZpeENsb3NlSW5kZXgiLCJzdWZmaXhDbG9zZSIsInN1ZmZpeE9wZW5JbmRleCIsInN1ZmZpeE9wZW4iLCJsYWJlbE9mZnNldCIsInZhbHVlU3RhcnQiLCJ2YWx1ZUVuZCIsIm1ldHJpY1ByZWZpeCIsIm1ldHJpY01hdGNoIiwiY2xlYW5TZWxlY3RvciIsImV4cGFuZFJlY29yZGluZ1J1bGVzIiwibWFwcGluZyIsInJ1bGVOYW1lcyIsInJ1bGVzUmVnZXgiLCJleHBhbmRlZFF1ZXJ5IiwicHJlIiwicG9zdCIsInF1ZXJ5QXJyYXkiLCJpbnZhbGlkTGFiZWxzUmVnZXgiLCJjb3JyZWN0bHlFeHBhbmRlZFF1ZXJ5QXJyYXkiLCJhZGRMYWJlbHNUb0V4cHJlc3Npb24iLCJpbnZhbGlkTGFiZWxzUmVnZXhwIiwiaW5kZXhPZlJlZ2V4TWF0Y2giLCJleHByQmVmb3JlUmVnZXhNYXRjaCIsImV4cHJBZnRlclJlZ2V4TWF0Y2giLCJhcnJheU9mTGFiZWxPYmplY3RzIiwib2JqIiwiYmFzZU1ldGFkYXRhIiwic3VtbWFyeU1ldGFkYXRhIiwic3ludGhldGljTWV0YWRhdGEiLCJlc2NhcGVQcm9tZXRoZXVzUmVnZXhwIiwiRnJvbVByb21MaWtlTWFwIiwiTm90RXF1YWwiLCJFcXVhbFJlZ0V4IiwiTm90RXF1YWxSZWdFeCIsIlRvUHJvbUxpa2VNYXAiLCJ0b2tlbiIsImxhYmVsT3BlcmF0b3IiLCJjb250ZW50VG9rZW5zIiwiY29udGVudCIsImN1cnJlbnRUb2tlbiIsImN1cnJlbnRTdHIiLCJsYWJlbENvbXBhcmF0b3IiLCJPUEVSQVRPUlMiLCJMT0dJQ0FMX09QRVJBVE9SUyIsIlRSSUdPTk9NRVRSSUNfRlVOQ1RJT05TIiwiUFJPTV9LRVlXT1JEUyIsInByb21xbEdyYW1tYXIiLCJpZExpc3QiLCJnZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMiLCJQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSIsImFsbE9wZXJhdGlvbnMiLCJmdW5jIiwiVHJpZ29ub21ldHJpYyIsInByb21RdWVyeU1vZGVsbGVyIiwiYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yIiwiUHJvbU9wZXJhdGlvbklkIiwiQ291bnRWYWx1ZXMiLCJjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lIiwiUHJlc2VudE92ZXJUaW1lIiwiYmluYXJ5U2NhbGFyT3BlcmF0b3JUb09wZXJhdG9yTmFtZSIsImdldE9wZXJhdGlvblBhcmFtSWQiLCJMYWJlbFBhcmFtRWRpdG9yIiwib3BlcmF0aW9uSW5kZXgiLCJpc0xvYWRpbmciLCJsb2FkR3JvdXBCeUxhYmVscyIsImZ1bmN0aW9uUmVuZGVyZXJMZWZ0IiwiZnVuY3Rpb25SZW5kZXJlclJpZ2h0IiwicmFuZ2VSZW5kZXJlckxlZnRXaXRoUGFyYW1zIiwicmFuZ2VSZW5kZXJlclJpZ2h0V2l0aFBhcmFtcyIsIkhpc3RvZ3JhbVF1YW50aWxlIiwiTGFiZWxSZXBsYWNlIiwiTG4iLCJjcmVhdGVSYW5nZUZ1bmN0aW9uIiwiQ2hhbmdlcyIsIklyYXRlIiwiSW5jcmVhc2UiLCJJZGVsdGEiLCJEZWx0YSIsImNyZWF0ZUZ1bmN0aW9uIiwiSG9sdFdpbnRlcnMiLCJjaGFuZ2VUeXBlSGFuZGxlciIsIm9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24iLCJQcmVkaWN0TGluZWFyIiwiQWJzZW50IiwiQWNvcyIsIkFjb3NoIiwiQXNpbiIsIkFzaW5oIiwiQXRhbiIsIkF0YW5oIiwiQ2VpbCIsIkNsYW1wIiwiQ2xhbXBNYXgiLCJDbGFtcE1pbiIsIkNvcyIsIkNvc2giLCJEYXlPZk1vbnRoIiwiRGF5T2ZXZWVrIiwiRGF5c0luTW9udGgiLCJEZWciLCJEZXJpdiIsIkV4cCIsIkZsb29yIiwiR3JvdXAiLCJIb3VyIiwiTGFiZWxKb2luIiwicmVzdFBhcmFtIiwib3B0aW9uYWwiLCJsYWJlbEpvaW5SZW5kZXJlciIsImxhYmVsSm9pbkFkZE9wZXJhdGlvbkhhbmRsZXIiLCJMb2cxMCIsIkxvZzIiLCJNaW51dGUiLCJNb250aCIsIlBpIiwiUXVhbnRpbGUiLCJSYWQiLCJSZXNldHMiLCJSb3VuZCIsIlNjYWxhciIsIlNnbiIsIlNpbiIsIlNpbmgiLCJTb3J0IiwiU29ydERlc2MiLCJTcXJ0IiwiVGFuIiwiVGFuaCIsIlRpbWVzdGFtcCIsIlZlY3RvciIsIlllYXIiLCJkZWZpbml0aW9uIiwid2l0aFJhdGVJbnRlcnZhbCIsIm5ld0RlZiIsImZpcnN0T3AiLCJzZXBhcmF0b3IiLCJoYW5kbGVGdW5jdGlvbiIsImhhbmRsZUFnZ3JlZ2F0aW9uIiwicHJldlNpYmxpbmciLCJyYW5nZUZ1bmN0aW9ucyIsImNhbGxBcmdzIiwiZW5kc1dpdGgiLCJ1cGRhdGVGdW5jdGlvbkFyZ3MiLCJtb2RpZmllciIsInBhcnNlRmxvYXQiLCJmZWVkYmFja1VybCIsImZlZWRiYWNrTGlua3NFbmFibGVkIiwiY29sb3IiLCJmb250U2l6ZSIsImJvZHlTbWFsbCIsInVuaXFCeSIsIkFjY2Vzc29yeUJ1dHRvbiIsIklucHV0R3JvdXAiLCJMYWJlbEZpbHRlckl0ZW0iLCJkZWZhdWx0T3AiLCJpc011bHRpU2VsZWN0IiwiZ2V0U2VsZWN0T3B0aW9uc0Zyb21TdHJpbmciLCJnZXRPcHRpb25zIiwic2VsZWN0ZWRPcHRpb25zIiwiaXNMb2FkaW5nTGFiZWxOYW1lcyIsImNoYW5nZSIsImlzTG9hZGluZ0xhYmVsVmFsdWVzIiwiY2hhbmdlcyIsImlzRXF1YWwiLCJFZGl0b3JMaXN0IiwibGFiZWxzRmlsdGVycyIsInNldEl0ZW1zIiwib25MYWJlbHNDaGFuZ2UiLCJvbkNoYW5nZUl0ZW0iLCJSZWdpc3RyeSIsImdldE9wZXJhdGlvbnMiLCJvcGVyYXRpb25zUmVnaXN0eSIsImNhdGVnb3JpZXMiLCJnZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkiLCJoaWRlRnJvbUxpc3QiLCJnZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMiLCJnZXRDYXRlZ29yaWVzIiwiZ2V0SWZFeGlzdHMiLCJyZW5kZXJPcGVyYXRpb25zIiwicXVlcnlTdHJpbmciLCJyZW5kZXJCaW5hcnlRdWVyaWVzIiwicmVuZGVyQmluYXJ5UXVlcnkiLCJsZWZ0T3BlcmFuZCIsImJpbmFyeVF1ZXJ5IiwiaGFzQmluYXJ5T3AiLCJEcmFnZ2FibGUiLCJUb29sdGlwIiwiT3BlcmF0aW9uSGVhZGVyIiwiZ2V0T3BlcmF0aW9uUGFyYW1FZGl0b3IiLCJPcGVyYXRpb25FZGl0b3IiLCJoaWdobGlnaHQiLCJzaG91bGRIaWdobGlnaHQiLCJ1c2VIaWdobGlnaHQiLCJvblBhcmFtVmFsdWVDaGFuZ2VkIiwicGFyYW1JZHgiLCJjYWxsUGFyYW1DaGFuZ2VkVGhlbk9uQ2hhbmdlIiwib25BZGRSZXN0UGFyYW0iLCJvblJlbW92ZVJlc3RQYXJhbSIsIm9wZXJhdGlvbkVsZW1lbnRzIiwicGFyYW1JbmRleCIsInBhcmFtRGVmIiwibWluIiwiRWRpdG9yIiwicGFyYW1Sb3ciLCJwYXJhbU5hbWUiLCJpbmZvSWNvbiIsInBhcmFtVmFsdWUiLCJsYXN0UGFyYW1EZWYiLCJyZW5kZXJBZGRSZXN0UGFyYW1CdXR0b24iLCJwcm92aWRlZCIsImNhcmRIaWdobGlnaHQiLCJpbm5lclJlZiIsImRyYWdnYWJsZVByb3BzIiwiZHJhZ0hhbmRsZVByb3BzIiwiYXJyb3ciLCJhcnJvd0xpbmUiLCJhcnJvd0Fycm93Iiwia2VlcEhpZ2hsaWdodCIsInNldEtlZXBIaWdobGlnaHQiLCJwYXJhbUNoYW5nZWRIYW5kbGVyIiwicHJpbWFyeSIsImN1cnNvciIsImJvcmRlclJhZGl1cyIsInNoYXBlIiwibWFyZ2luQm90dG9tIiwicG9zaXRpb24iLCJ0cmFuc2l0aW9uIiwiYm94U2hhZG93IiwibWFyZ2luIiwidmVydGljYWxBbGlnbiIsImZvbnRXZWlnaHQiLCJmb250V2VpZ2h0TWVkaXVtIiwiaGVpZ2h0IiwidG9wIiwid2lkdGgiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzdHJvbmciLCJib3JkZXJUb3AiLCJib3JkZXJCb3R0b20iLCJib3JkZXJMZWZ0IiwicmVuZGVyTWFya2Rvd24iLCJzdGVwTnVtYmVyIiwibWFya2Rvd24iLCJib3giLCJib3hJbm5lciIsIl9faHRtbCIsImp1c3RpZnlDb250ZW50IiwicGFkZGluZ0JvdHRvbSIsImZvbnRGYW1pbHkiLCJ0ZXh0RGVjb3JhdGlvbiIsIk9wZXJhdGlvbkluZm9CdXR0b24iLCJvblRvZ2dsZVN3aXRjaGVyIiwiaXNPcGVuIiwiYWx0ZXJuYXRpdmVzIiwiYWx0Iiwib3BlcmF0aW9uSGVhZGVyQnV0dG9ucyIsInNlbGVjdFdyYXBwZXIiLCJjaGFuZ2VkT3AiLCJvcGFjaXR5IiwidHJhbnNpdGlvbnMiLCJjcmVhdGUiLCJkdXJhdGlvbiIsInNob3J0IiwicGFkZGluZ1JpZ2h0IiwidXNlUG9wcGVyVG9vbHRpcCIsIlBvcnRhbCIsInNob3ciLCJzZXRTaG93IiwiZ2V0VG9vbHRpcFByb3BzIiwic2V0VG9vbHRpcFJlZiIsInNldFRyaWdnZXJSZWYiLCJ2aXNpYmxlIiwicGxhY2VtZW50Iiwib25WaXNpYmxlQ2hhbmdlIiwiaW50ZXJhY3RpdmUiLCJ0cmlnZ2VyIiwiZG9jQm94IiwiZG9jQm94SGVhZGVyIiwiZG9jQm94Qm9keSIsImdldE9wZXJhdGlvbkRvY3MiLCJvdmVyZmxvdyIsInNoYWRvd3MiLCJ6MyIsIm1heFdpZHRoIiwiekluZGV4IiwidG9vbHRpcCIsImg1Iiwic2lnbmF0dXJlIiwiZHJvcGRvd24iLCJEcmFnRHJvcENvbnRleHQiLCJEcm9wcGFibGUiLCJ1c2VNb3VudGVkU3RhdGUiLCJDYXNjYWRlciIsIm9wc1RvSGlnaGxpZ2h0IiwidXNlT3BlcmF0aW9uc0hpZ2hsaWdodCIsImNhc2NhZGVyT3BlbiIsInNldENhc2NhZGVyT3BlbiIsIm9uT3BlcmF0aW9uQ2hhbmdlIiwiYWRkT3B0aW9ucyIsImlzTGVhZiIsIm9uQWRkT3BlcmF0aW9uIiwib3BlcmF0aW9uRGVmIiwib25EcmFnRW5kIiwiZGVzdGluYXRpb24iLCJlbGVtZW50Iiwic291cmNlIiwib25DYXNjYWRlckJsdXIiLCJvcGVyYXRpb25MaXN0IiwiZHJvcHBhYmxlUHJvcHMiLCJhZGRCdXR0b24iLCJpc01vdW50ZWQiLCJwcmV2T3BlcmF0aW9ucyIsIm5ld09wcyIsIm5ld09wIiwiaXNTYW1lT3AiLCJvcDEiLCJvcDIiLCJoZWFkaW5nIiwiZmxleFdyYXAiLCJDaGVja2JveCIsIlNlbGVjdElucHV0UGFyYW1FZGl0b3IiLCJCb29sSW5wdXRQYXJhbUVkaXRvciIsIlNpbXBsZUlucHV0UGFyYW1FZGl0b3IiLCJzZWxlY3RPcHRpb25zIiwidmFsdWVPcHRpb24iLCJyb290IiwiVGFnIiwiZWRpdG9yTW9kZXMiLCJjb21wb25lbnQiLCJtb2RlIiwidW5pcXVlSWQiLCJ1c2VSZWYiLCJpbnB1dFByb3BzIiwiZGFzaGVkTGFiZWwiLCJzd2l0Y2hJZFJlZiIsImN1cnJlbnQiLCJzd2l0Y2hMYWJlbCIsInVzZVRvZ2dsZSIsImNvbGxhcHNlZEluZm8iLCJ0b2dnbGVPcGVuIiwidG9nZ2xlIiwiZW1waGFzaXplIiwiZmxleEdyb3ciLCJwYWRkaW5nVG9wIiwibWFyZ2luUmlnaHQiLCJoaWdobGlnaHRlZCIsImVkaXRvckZpZWxkIiwiY2FwaXRhbGl6ZSIsInBsdXJhbGl6ZSIsInJlbmRlclBhcmFtcyIsInJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zIiwicmVuZGVyTGVmdCIsIm92ZXJyaWRlcyIsImdldE9uTGFiZWxBZGRlZEhhbmRsZXIiLCJnZXRBZ2dyZWdhdGlvbkV4cGxhaW5lciIsImdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlciIsImdldExhc3RMYWJlbFJlbW92ZWRIYW5kbGVyIiwiZ2V0QWdncmVnYXRpb25XaXRob3V0UmVuZGVyZXIiLCJwYXJhbXNEZWYiLCJnZXRBZ2dyZWdhdGlvbkJ5UmVuZGVyZXJXaXRoUGFyYW1ldGVyIiwiYWdncmVnYXRpb24iLCJhZ2dyZWdhdGlvblJlbmRlcmVyIiwiYWdncmVnYXRpb25OYW1lIiwiYWdncmVnYXRpb25FeHBsYWluZXIiLCJsYWJlbFdvcmQiLCJtYXBUeXBlIiwicmVzdFBhcmFtcyIsImNoYW5nZVRvT3BlcmF0aW9uSWQiLCJvblBhcmFtQ2hhbmdlZCIsImN1ciIsInBhcmVudFR5cGUiLCJ2YXJpYWJsZVJlZ2V4IiwidmFyMSIsInZhcjIiLCJmbXQyIiwidmFyMyIsImZpZWxkUGF0aCIsImZtdDMiLCJmbXQiLCJ2YXJUeXBlIiwidmFyVHlwZUZ1bmMiLCJyZXR1cm5WYXJpYWJsZXMiLCJoYXNCb29sIiwicG9zIiwiY2hpbGRBZnRlciIsImxvZyIsImpzb24iLCJ0b0pzb24iLCJqc29uVG9UZXh0IiwidHJlZUpzb24iLCJub2RlVG9TdHJpbmciLCJpbmRlbnQiLCJuZXdJbmRlbnQiLCJpc0xhc3RDaGlsZCJdLCJzb3VyY2VSb290IjoiIn0=