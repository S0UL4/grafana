(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["prometheusPlugin"],{

/***/ "./public/app/core/utils/CancelablePromise.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isCancelablePromiseRejection": () => (/* binding */ isCancelablePromiseRejection),
/* harmony export */   "makePromiseCancelable": () => (/* binding */ makePromiseCancelable)
/* harmony export */ });
// https://github.com/facebook/react/issues/5465
function isCancelablePromiseRejection(promise) {
  return typeof promise === 'object' && promise !== null && 'isCanceled' in promise;
}
const makePromiseCancelable = promise => {
  let hasCanceled_ = false;
  const wrappedPromise = new Promise((resolve, reject) => {
    const canceledPromiseRejection = {
      isCanceled: true
    };
    promise.then(val => hasCanceled_ ? reject(canceledPromiseRejection) : resolve(val));
    promise.catch(error => hasCanceled_ ? reject(canceledPromiseRejection) : reject(error));
  });
  return {
    promise: wrappedPromise,

    cancel() {
      hasCanceled_ = true;
    }

  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/add_label_to_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLabelToQuery": () => (/* binding */ addLabelToQuery)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _querybuilder_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");




/**
 * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.
 *
 * It uses PromQL parser to find instances of metric and labels, alters them and then splices them back into the query.
 * Ideally we could use the parse -> change -> render is a simple 3 steps but right now building the visual query
 * object does not support all possible queries.
 *
 * So instead this just operates on substrings of the query with labels and operates just on those. This makes this
 * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.
 * @param query
 * @param key
 * @param value
 * @param operator
 */
function addLabelToQuery(query, key, value, operator = '=') {
  if (!key || !value) {
    throw new Error('Need label to add to query.');
  }

  const vectorSelectorPositions = getVectorSelectorPositions(query);

  if (!vectorSelectorPositions.length) {
    return query;
  }

  const filter = toLabelFilter(key, value, operator);
  return addFilter(query, vectorSelectorPositions, filter);
}

/**
 * Parse the string and get all VectorSelector positions in the query together with parsed representation of the vector
 * selector.
 * @param query
 */
function getVectorSelectorPositions(query) {
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(query);
  const positions = [];
  tree.iterate({
    enter: (type, from, to, get) => {
      if (type.name === 'VectorSelector') {
        const visQuery = (0,_querybuilder_parsing__WEBPACK_IMPORTED_MODULE_2__.buildVisualQueryFromString)(query.substring(from, to));
        positions.push({
          query: visQuery.query,
          from,
          to
        });
        return false;
      }
    }
  });
  return positions;
}

function toLabelFilter(key, value, operator) {
  // We need to make sure that we convert the value back to string because it may be a number
  const transformedValue = value === Infinity ? '+Inf' : value.toString();
  return {
    label: key,
    op: operator,
    value: transformedValue
  };
}

function addFilter(query, vectorSelectorPositions, filter) {
  const modeller = new _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__.PromQueryModeller();
  let newQuery = '';
  let prev = 0;

  for (let i = 0; i < vectorSelectorPositions.length; i++) {
    // This is basically just doing splice on a string for each matched vector selector.
    const match = vectorSelectorPositions[i];
    const isLast = i === vectorSelectorPositions.length - 1;
    const start = query.substring(prev, match.from);
    const end = isLast ? query.substring(match.to) : '';

    if (!labelExists(match.query.labels, filter)) {
      // We don't want to add duplicate labels.
      match.query.labels.push(filter);
    }

    const newLabels = modeller.renderQuery(match.query);
    newQuery += start + newLabels + end;
    prev = match.to;
  }

  return newQuery;
}
/**
 * Check if label exists in the list of labels but ignore the operator.
 * @param labels
 * @param filter
 */


function labelExists(labels, filter) {
  return labels.find(label => label.label === filter.label && label.value === filter.value);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/AnnotationQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationQueryEditor": () => (/* binding */ AnnotationQueryEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _querybuilder_components_PromQueryCodeEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryCodeEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _code, _code2, _Space;








function AnnotationQueryEditor(props) {
  // This is because of problematic typing. See AnnotationQueryEditorProps in grafana-data/annotations.ts.
  const annotation = props.annotation;
  const onAnnotationChange = props.onAnnotationChange;
  const query = {
    expr: annotation.expr,
    refId: annotation.name,
    interval: annotation.step
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRows, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_querybuilder_components_PromQueryCodeEditor__WEBPACK_IMPORTED_MODULE_3__.PromQueryCodeEditor, Object.assign({}, props, {
        query: query,
        onChange: query => {
          onAnnotationChange(Object.assign({}, annotation, {
            expr: query.expr
          }));
        }
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
          label: "Min step",
          tooltip: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
            children: ["An additional lower limit for the step parameter of the Prometheus query and for the", ' ', _code || (_code = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("code", {
              children: "$__interval"
            })), " and ", _code2 || (_code2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("code", {
              children: "$__rate_interval"
            })), " variables."]
          }),
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.AutoSizeInput, {
            type: "text",
            "aria-label": "Set lower limit for the step parameter",
            placeholder: 'auto',
            minWidth: 10,
            onCommitChange: ev => {
              onAnnotationChange(Object.assign({}, annotation, {
                step: ev.currentTarget.value
              }));
            },
            defaultValue: query.interval
          })
        })
      })]
    }), _Space || (_Space = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Space, {
      v: 0.5
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Title",
        tooltip: 'Use either the name or a pattern. For example, {{instance}} is replaced with label value for the label instance.',
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
          type: "text",
          placeholder: "{{alertname}}",
          value: annotation.titleFormat,
          onChange: event => {
            onAnnotationChange(Object.assign({}, annotation, {
              titleFormat: event.currentTarget.value
            }));
          }
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Tags",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
          type: "text",
          placeholder: "label1,label2",
          value: annotation.tagKeys,
          onChange: event => {
            onAnnotationChange(Object.assign({}, annotation, {
              tagKeys: event.currentTarget.value
            }));
          }
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Text",
        tooltip: 'Use either the name or a pattern. For example, {{instance}} is replaced with label value for the label instance.',
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
          type: "text",
          placeholder: "{{instance}}",
          value: annotation.textFormat,
          onChange: event => {
            onAnnotationChange(Object.assign({}, annotation, {
              textFormat: event.currentTarget.value
            }));
          }
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Series value as timestamp",
        tooltip: 'The unit of timestamp is milliseconds. If the unit of the series value is seconds, multiply its range vector by 1000.',
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorSwitch, {
          value: annotation.useValueForTime,
          onChange: event => {
            onAnnotationChange(Object.assign({}, annotation, {
              useValueForTime: event.currentTarget.value
            }));
          }
        })
      })]
    })]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;




const CHEAT_SHEET_ITEMS = [{
  title: 'Request Rate',
  expression: 'rate(http_request_total[5m])',
  label: 'Given an HTTP request counter, this query calculates the per-second average request rate over the last 5 minutes.'
}, {
  title: '95th Percentile of Request Latencies',
  expression: 'histogram_quantile(0.95, sum(rate(prometheus_http_request_duration_seconds_bucket[5m])) by (le))',
  label: 'Calculates the 95th percentile of HTTP request rate over 5 minute windows.'
}, {
  title: 'Alerts Firing',
  expression: 'sort_desc(sum(sum_over_time(ALERTS{alertstate="firing"}[24h])) by (alertname))',
  label: 'Sums up the alerts that have been firing over the last 24 hours.'
}, {
  title: 'Step',
  label: 'Defines the graph resolution using a duration format (15s, 1m, 3h, ...). Small steps create high-resolution graphs but can be slow over larger time ranges. Using a longer step lowers the resolution and smooths the graph by producing fewer datapoints. If no step is given the resolution is calculated automatically.'
}];

const PromCheatSheet = props => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
  children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("h2", {
    children: "PromQL Cheat Sheet"
  })), CHEAT_SHEET_ITEMS.map((item, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
    className: "cheat-sheet-item",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "cheat-sheet-item__title",
      children: item.title
    }), item.expression ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "cheat-sheet-item__example",
      onClick: e => props.onClickExample({
        refId: 'A',
        expr: item.expression
      }),
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("code", {
        children: item.expression
      })
    }) : null, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "cheat-sheet-item__label",
      children: item.label
    })]
  }, index))]
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PromCheatSheet);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromExemplarField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromExemplarField": () => (/* binding */ PromExemplarField)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["datasource", "onChange", "query"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function PromExemplarField(_ref) {
  let {
    datasource,
    onChange,
    query
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);

  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const prevError = (0,react_use__WEBPACK_IMPORTED_MODULE_4__["default"])(error);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (!datasource.exemplarsAvailable) {
      setError('Exemplars for this query are not available');
      onChange(false);
    } else if (query.instant && !query.range) {
      setError('Exemplars are not available for instant queries');
      onChange(false);
    } else {
      setError(null); // If error is cleared, we want to change exemplar to true

      if (prevError && !error) {
        onChange(true);
      }
    }
  }, [datasource.exemplarsAvailable, query.instant, query.range, onChange, prevError, error]);
  const iconButtonStyles = (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)({
    [styles.activeIcon]: !!query.exemplar
  }, styles.eyeIcon);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineLabel, {
    width: "auto",
    "data-testid": rest['data-testid'],
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Tooltip, {
      content: error !== null && error !== void 0 ? error : '',
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
        className: styles.iconWrapper,
        children: ["Exemplars", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.IconButton, {
          name: "eye",
          tooltip: !!query.exemplar ? 'Disable query with exemplars' : 'Enable query with exemplars',
          disabled: !!error,
          className: iconButtonStyles,
          onClick: () => {
            onChange(!query.exemplar);
          }
        })]
      })
    })
  });
}

function getStyles(theme) {
  return {
    eyeIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      margin-left: ${theme.spacing(2)};
    `,
    activeIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      color: ${theme.colors.primary.main};
    `,
    iconWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      display: flex;
      align-items: center;
    `
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromExploreExtraField": () => (/* binding */ PromExploreExtraField),
/* harmony export */   "getQueryTypeChangeHandler": () => (/* binding */ getQueryTypeChangeHandler),
/* harmony export */   "getQueryTypeOptions": () => (/* binding */ getQueryTypeOptions),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromExemplarField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExemplarField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _InlineFormLabel2;









const PromExploreExtraField = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_2__.memo)(({
  query,
  datasource,
  onChange,
  onRunQuery
}) => {
  var _query$interval;

  const rangeOptions = getQueryTypeOptions(true);
  const prevQuery = (0,react_use__WEBPACK_IMPORTED_MODULE_6__["default"])(query);
  const onExemplarChange = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(exemplar => {
    if (!(0,lodash__WEBPACK_IMPORTED_MODULE_1__.isEqual)(query, prevQuery) || exemplar !== query.exemplar) {
      onChange(Object.assign({}, query, {
        exemplar
      }));
    }
  }, [prevQuery, query, onChange]);

  function onChangeQueryStep(interval) {
    onChange(Object.assign({}, query, {
      interval
    }));
  }

  function onStepChange(e) {
    if (e.currentTarget.value !== query.interval) {
      onChangeQueryStep(e.currentTarget.value);
    }
  }

  function onReturnKeyDown(e) {
    if (e.key === 'Enter' && e.shiftKey) {
      onRunQuery();
    }
  }

  const onQueryTypeChange = getQueryTypeChangeHandler(query, onChange);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    "aria-label": "Prometheus extra field",
    className: "gf-form-inline",
    "data-testid": testIds.extraFieldEditor,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
      "data-testid": testIds.queryTypeField,
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)('gf-form explore-input-margin', _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
              flex-wrap: nowrap;
            `),
      "aria-label": "Query type field",
      children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
        width: "auto",
        children: "Query type"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.RadioButtonGroup, {
        options: rangeOptions,
        value: query.range && query.instant ? 'both' : query.instant ? 'instant' : 'range',
        onChange: onQueryTypeChange
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
      "data-testid": testIds.stepField,
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)('gf-form', _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
              flex-wrap: nowrap;
            `),
      "aria-label": "Step field",
      children: [_InlineFormLabel2 || (_InlineFormLabel2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
        width: 6,
        tooltip: 'Time units and built-in variables can be used here, for example: $__interval, $__rate_interval, 5s, 1m, 3h, 1d, 1y (Default if no unit is specified: s)',
        children: "Min step"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("input", {
        type: 'text',
        className: "gf-form-input width-4",
        placeholder: 'auto',
        onChange: onStepChange,
        onKeyDown: onReturnKeyDown,
        value: (_query$interval = query.interval) !== null && _query$interval !== void 0 ? _query$interval : ''
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_PromExemplarField__WEBPACK_IMPORTED_MODULE_4__.PromExemplarField, {
      onChange: onExemplarChange,
      datasource: datasource,
      query: query
    })]
  });
});
PromExploreExtraField.displayName = 'PromExploreExtraField';
function getQueryTypeOptions(includeBoth) {
  const rangeOptions = [{
    value: 'range',
    label: 'Range',
    description: 'Run query over a range of time'
  }, {
    value: 'instant',
    label: 'Instant',
    description: 'Run query against a single point in time. For this query, the "To" time is used'
  }];

  if (includeBoth) {
    rangeOptions.push({
      value: 'both',
      label: 'Both',
      description: 'Run an Instant query and a Range query'
    });
  }

  return rangeOptions;
}
function getQueryTypeChangeHandler(query, onChange) {
  return queryType => {
    if (queryType === 'instant') {
      onChange(Object.assign({}, query, {
        instant: true,
        range: false,
        exemplar: false
      }));
    } else if (queryType === 'range') {
      onChange(Object.assign({}, query, {
        instant: false,
        range: true
      }));
    } else {
      onChange(Object.assign({}, query, {
        instant: true,
        range: true
      }));
    }
  };
}
const testIds = {
  extraFieldEditor: 'prom-editor-extra-field',
  stepField: 'prom-editor-extra-field-step',
  queryTypeField: 'prom-editor-extra-field-query-type'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromExploreQueryEditor": () => (/* binding */ PromExploreQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _PromExploreExtraField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx");
/* harmony import */ var _PromQueryField__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const PromExploreQueryEditor = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(props => {
  const {
    range,
    query,
    data,
    datasource,
    history,
    onChange,
    onRunQuery
  } = props; // Setting default values

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (query.expr === undefined) {
      onChange(Object.assign({}, query, {
        expr: ''
      }));
    }

    if (query.exemplar === undefined) {
      onChange(Object.assign({}, query, {
        exemplar: true
      }));
    } // Override query type to "Both" only for new queries (no query.expr).


    if (!query.instant && !query.range && !query.expr) {
      onChange(Object.assign({}, query, {
        instant: true,
        range: true
      }));
    }
  }, [onChange, query]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_PromQueryField__WEBPACK_IMPORTED_MODULE_3__["default"], {
    app: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore,
    datasource: datasource,
    query: query,
    range: range,
    onRunQuery: onRunQuery,
    onChange: onChange,
    onBlur: () => {},
    history: history,
    data: data,
    "data-testid": testIds.editor,
    ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_2__.PromExploreExtraField, {
      query: query,
      onChange: onChange,
      datasource: datasource,
      onRunQuery: onRunQuery
    })
  });
});
PromExploreQueryEditor.displayName = 'PromExploreQueryEditor';
const testIds = {
  editor: 'prom-editor-explore'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromLink.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const PromLink = ({
  panelData,
  query,
  datasource
}) => {
  const [href, setHref] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (panelData) {
      const getExternalLink = () => {
        if (!panelData.request) {
          return '';
        }

        const {
          request: {
            range,
            interval,
            scopedVars
          }
        } = panelData;
        const start = datasource.getPrometheusTime(range.from, false);
        const end = datasource.getPrometheusTime(range.to, true);
        const rangeDiff = Math.ceil(end - start);
        const endTime = range.to.utc().format('YYYY-MM-DD HH:mm');
        const enrichedScopedVars = Object.assign({}, scopedVars, datasource.getRateIntervalScopedVariable(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.rangeUtil.intervalToSeconds(interval), _grafana_data__WEBPACK_IMPORTED_MODULE_2__.rangeUtil.intervalToSeconds(datasource.interval)));
        const options = {
          interval,
          scopedVars: enrichedScopedVars
        };
        const customQueryParameters = {};

        if (datasource.customQueryParameters) {
          for (const [k, v] of datasource.customQueryParameters) {
            customQueryParameters[k] = v;
          }
        }

        const queryOptions = datasource.createQuery(query, options, start, end);
        const expr = Object.assign({}, customQueryParameters, {
          'g0.expr': queryOptions.expr,
          'g0.range_input': rangeDiff + 's',
          'g0.end_input': endTime,
          'g0.step_input': queryOptions.step,
          'g0.tab': 0
        });
        const args = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(expr, (v, k) => {
          return k + '=' + encodeURIComponent(v);
        }).join('&');
        return `${datasource.directUrl}/graph?${args}`;
      };

      setHref(getExternalLink());
    }
  }, [datasource, panelData, query]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("a", {
    href: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.textUtil.sanitizeUrl(href),
    target: "_blank",
    rel: "noopener noreferrer",
    children: "Prometheus"
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(PromLink));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FORMAT_OPTIONS": () => (/* binding */ FORMAT_OPTIONS),
/* harmony export */   "INTERVAL_FACTOR_OPTIONS": () => (/* binding */ INTERVAL_FACTOR_OPTIONS),
/* harmony export */   "PromQueryEditor": () => (/* binding */ PromQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromExemplarField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExemplarField.tsx");
/* harmony import */ var _PromLink__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromLink.tsx");
/* harmony import */ var _PromQueryField__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _InlineFormLabel2, _div, _div2;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


 // Types









const {
  Switch
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.LegacyForms;
const FORMAT_OPTIONS = [{
  label: 'Time series',
  value: 'time_series'
}, {
  label: 'Table',
  value: 'table'
}, {
  label: 'Heatmap',
  value: 'heatmap'
}];
const INTERVAL_FACTOR_OPTIONS = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)([1, 2, 3, 4, 5, 10], value => ({
  value,
  label: '1/' + value
}));
class PromQueryEditor extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {
  // Query target to be modified and used for queries
  constructor(props) {
    super(props); // Use default query to prevent undefined input values

    _defineProperty(this, "query", void 0);

    _defineProperty(this, "onFieldChange", (query, override) => {
      this.query.expr = query.expr;
    });

    _defineProperty(this, "onFormatChange", option => {
      this.query.format = option.value;
      this.setState({
        formatOption: option
      }, this.onRunQuery);
    });

    _defineProperty(this, "onInstantChange", e => {
      const instant = e.target.checked;
      this.query.instant = instant;
      this.setState({
        instant
      }, this.onRunQuery);
    });

    _defineProperty(this, "onIntervalChange", e => {
      const interval = e.currentTarget.value;
      this.query.interval = interval;
      this.setState({
        interval
      });
    });

    _defineProperty(this, "onIntervalFactorChange", option => {
      this.query.intervalFactor = option.value;
      this.setState({
        intervalFactorOption: option
      }, this.onRunQuery);
    });

    _defineProperty(this, "onLegendChange", e => {
      const legendFormat = e.currentTarget.value;
      this.query.legendFormat = legendFormat;
      this.setState({
        legendFormat
      });
    });

    _defineProperty(this, "onExemplarChange", isEnabled => {
      this.query.exemplar = isEnabled;
      this.setState({
        exemplar: isEnabled
      }, this.onRunQuery);
    });

    _defineProperty(this, "onRunQuery", () => {
      const {
        query
      } = this; // Change of query.hide happens outside of this component and is just passed as prop. We have to update it when running queries.

      const {
        hide
      } = this.props.query;
      this.props.onChange(Object.assign({}, query, {
        hide
      }));
      this.props.onRunQuery();
    });

    const defaultQuery = {
      expr: '',
      legendFormat: '',
      interval: '',
      // Set exemplar to false for alerting queries
      exemplar: props.app === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.UnifiedAlerting ? false : true
    };

    const _query = Object.assign({}, defaultQuery, props.query);

    this.query = _query; // Query target properties that are fully controlled inputs

    this.state = {
      // Fully controlled text inputs
      interval: _query.interval,
      legendFormat: _query.legendFormat,
      // Select options
      formatOption: FORMAT_OPTIONS.find(option => option.value === _query.format) || FORMAT_OPTIONS[0],
      intervalFactorOption: INTERVAL_FACTOR_OPTIONS.find(option => option.value === _query.intervalFactor) || INTERVAL_FACTOR_OPTIONS[0],
      // Switch options
      instant: Boolean(_query.instant),
      exemplar: Boolean(_query.exemplar)
    };
  }

  render() {
    const {
      datasource,
      query,
      range,
      data
    } = this.props;
    const {
      formatOption,
      instant,
      interval,
      intervalFactorOption,
      legendFormat
    } = this.state; //We want to hide exemplar field for unified alerting as exemplars in alerting don't make sense and are source of confusion

    const showExemplarField = this.props.app !== _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.UnifiedAlerting;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromQueryField__WEBPACK_IMPORTED_MODULE_6__["default"], {
      datasource: datasource,
      query: query,
      range: range,
      onRunQuery: this.onRunQuery,
      onChange: this.onFieldChange,
      history: [],
      data: data,
      "data-testid": testIds.editor,
      ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: "gf-form-inline",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
            width: 7,
            tooltip: "Controls the name of the time series, using name or pattern. For example {{hostname}} will be replaced with label value for the label hostname.",
            children: "Legend"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("input", {
            type: "text",
            className: "gf-form-input",
            placeholder: "legend format",
            value: legendFormat,
            onChange: this.onLegendChange,
            onBlur: this.onRunQuery
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel2 || (_InlineFormLabel2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
            width: 7,
            tooltip: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.Fragment, {
              children: ["An additional lower limit for the step parameter of the Prometheus query and for the", ' ', /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("code", {
                children: "$__interval"
              }), " and ", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("code", {
                children: "$__rate_interval"
              }), " variables. The limit is absolute and not modified by the \"Resolution\" setting."]
            }),
            children: "Min step"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("input", {
            type: "text",
            className: "gf-form-input width-8",
            "aria-label": "Set lower limit for the step parameter",
            placeholder: interval,
            onChange: this.onIntervalChange,
            onBlur: this.onRunQuery,
            value: interval
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
            className: "gf-form-label",
            children: "Resolution"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
            "aria-label": "Select resolution",
            isSearchable: false,
            options: INTERVAL_FACTOR_OPTIONS,
            onChange: this.onIntervalFactorChange,
            value: intervalFactorOption
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
            className: "gf-form-label width-7",
            children: "Format"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
            className: "select-container",
            width: 16,
            isSearchable: false,
            options: FORMAT_OPTIONS,
            onChange: this.onFormatChange,
            value: formatOption,
            "aria-label": "Select format"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(Switch, {
            label: "Instant",
            checked: instant,
            onChange: this.onInstantChange
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
            width: 10,
            tooltip: "Link to Graph in Prometheus",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromLink__WEBPACK_IMPORTED_MODULE_5__["default"], {
              datasource: datasource,
              query: this.query // Use modified query
              ,
              panelData: data
            })
          })]
        }), showExemplarField && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromExemplarField__WEBPACK_IMPORTED_MODULE_4__.PromExemplarField, {
          onChange: this.onExemplarChange,
          datasource: datasource,
          query: this.query,
          "data-testid": testIds.exemplar
        })]
      })
    });
  }

}
const testIds = {
  editor: 'prom-editor',
  exemplar: 'exemplar-editor'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryEditorByApp.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryEditorByApp": () => (/* binding */ PromQueryEditorByApp),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _querybuilder_components_PromQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryEditorSelector.tsx");
/* harmony import */ var _PromExploreQueryEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx");
/* harmony import */ var _PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx");
/* harmony import */ var _PromQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditorForAlerting.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








function PromQueryEditorByApp(props) {
  const {
    app
  } = props;

  switch (app) {
    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.CloudAlerting:
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_6__.PromQueryEditorForAlerting, Object.assign({}, props));

    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.featureToggles.promQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_PromQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__.PromQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromExploreQueryEditor__WEBPACK_IMPORTED_MODULE_4__.PromExploreQueryEditor, Object.assign({}, props));

    default:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.featureToggles.promQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_PromQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__.PromQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.PromQueryEditor, Object.assign({}, props));
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(PromQueryEditorByApp));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryEditorForAlerting.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryEditorForAlerting": () => (/* binding */ PromQueryEditorForAlerting),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _PromQueryField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");



function PromQueryEditorForAlerting(props) {
  const {
    datasource,
    query,
    range,
    data,
    onChange,
    onRunQuery
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_PromQueryField__WEBPACK_IMPORTED_MODULE_1__["default"], {
    datasource: datasource,
    query: query,
    onRunQuery: onRunQuery,
    onChange: onChange,
    history: [],
    range: range,
    data: data,
    "data-testid": testIds.editor
  });
}
const testIds = {
  editor: 'prom-editor-cloud-alerting'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RECORDING_RULES_GROUP": () => (/* binding */ RECORDING_RULES_GROUP),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "willApplySuggestion": () => (/* binding */ willApplySuggestion)
/* harmony export */ });
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.28.0-28f20a79ff-bde93fb2be.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/components/LocalStorageValueProvider/index.tsx");
/* harmony import */ var app_core_utils_CancelablePromise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/utils/CancelablePromise.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _PrometheusMetricsBrowser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PrometheusMetricsBrowser.tsx");
/* harmony import */ var _monaco_query_field_MonacoQueryFieldWrapper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldWrapper.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













const RECORDING_RULES_GROUP = '__recording_rules__';
const LAST_USED_LABELS_KEY = 'grafana.datasources.prometheus.browser.labels';

function getChooserText(metricsLookupDisabled, hasSyntax, hasMetrics) {
  if (metricsLookupDisabled) {
    return '(Disabled)';
  }

  if (!hasSyntax) {
    return 'Loading metrics...';
  }

  if (!hasMetrics) {
    return '(No metrics found)';
  }

  return 'Metrics browser';
}

function willApplySuggestion(suggestion, {
  typeaheadContext,
  typeaheadText
}) {
  // Modify suggestion based on context
  switch (typeaheadContext) {
    case 'context-labels':
      {
        const nextChar = _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.DOMUtil.getNextCharacter();

        if (!nextChar || nextChar === '}' || nextChar === ',') {
          suggestion += '=';
        }

        break;
      }

    case 'context-label-values':
      {
        // Always add quotes and remove existing ones instead
        if (!typeaheadText.match(/^(!?=~?"|")/)) {
          suggestion = `"${suggestion}`;
        }

        if (_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.DOMUtil.getNextCharacter() !== '"') {
          suggestion = `${suggestion}"`;
        }

        break;
      }

    default:
  }

  return suggestion;
}

class PromQueryField extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {
  constructor(props, context) {
    super(props, context);

    _defineProperty(this, "plugins", void 0);

    _defineProperty(this, "refreshHint", () => {
      const {
        datasource,
        query,
        data
      } = this.props;
      const initHints = datasource.getInitHints();
      const initHint = initHints.length > 0 ? initHints[0] : null;

      if (!data || data.series.length === 0) {
        this.setState({
          hint: initHint
        });
        return;
      }

      const result = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.isDataFrame)(data.series[0]) ? data.series.map(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toLegacyResponseData) : data.series;
      const queryHints = datasource.getQueryHints(query, result);
      let queryHint = queryHints.length > 0 ? queryHints[0] : null;
      this.setState({
        hint: queryHint !== null && queryHint !== void 0 ? queryHint : initHint
      });
    });

    _defineProperty(this, "refreshMetrics", async () => {
      const {
        datasource: {
          languageProvider
        }
      } = this.props;
      this.languageProviderInitializationPromise = (0,app_core_utils_CancelablePromise__WEBPACK_IMPORTED_MODULE_5__.makePromiseCancelable)(languageProvider.start());

      try {
        const remainingTasks = await this.languageProviderInitializationPromise.promise;
        await Promise.all(remainingTasks);
        this.onUpdateLanguage();
      } catch (err) {
        if ((0,app_core_utils_CancelablePromise__WEBPACK_IMPORTED_MODULE_5__.isCancelablePromiseRejection)(err) && err.isCanceled) {// do nothing, promise was canceled
        } else {
          throw err;
        }
      }
    });

    _defineProperty(this, "onChangeLabelBrowser", selector => {
      this.onChangeQuery(selector, true);
      this.setState({
        labelBrowserVisible: false
      });
    });

    _defineProperty(this, "onChangeQuery", (value, override) => {
      // Send text change to parent
      const {
        query,
        onChange,
        onRunQuery
      } = this.props;

      if (onChange) {
        const nextQuery = Object.assign({}, query, {
          expr: value
        });
        onChange(nextQuery);

        if (override && onRunQuery) {
          onRunQuery();
        }
      }
    });

    _defineProperty(this, "onClickChooserButton", () => {
      this.setState(state => ({
        labelBrowserVisible: !state.labelBrowserVisible
      }));
    });

    _defineProperty(this, "onClickHintFix", () => {
      const {
        datasource,
        query,
        onChange,
        onRunQuery
      } = this.props;
      const {
        hint
      } = this.state;
      onChange(datasource.modifyQuery(query, hint.fix.action));
      onRunQuery();
    });

    _defineProperty(this, "onUpdateLanguage", () => {
      const {
        datasource: {
          languageProvider
        }
      } = this.props;
      const {
        metrics
      } = languageProvider;

      if (!metrics) {
        return;
      }

      this.setState({
        syntaxLoaded: true
      });
    });

    _defineProperty(this, "onTypeahead", async typeahead => {
      const {
        datasource: {
          languageProvider
        }
      } = this.props;

      if (!languageProvider) {
        return {
          suggestions: []
        };
      }

      const {
        history
      } = this.props;
      const {
        prefix,
        text,
        value,
        wrapperClasses,
        labelKey
      } = typeahead;
      const result = await languageProvider.provideCompletionItems({
        text,
        value,
        prefix,
        wrapperClasses,
        labelKey
      }, {
        history
      });
      return result;
    });

    this.plugins = [(0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.BracesPlugin)(), (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.SlatePrism)({
      onlyIn: node => node.type === 'code_block',
      getSyntax: node => 'promql'
    }, Object.assign({}, prismjs__WEBPACK_IMPORTED_MODULE_0__.languages, {
      promql: this.props.datasource.languageProvider.syntax
    }))];
    this.state = {
      labelBrowserVisible: false,
      syntaxLoaded: false,
      hint: null
    };
  }

  componentDidMount() {
    if (this.props.datasource.languageProvider) {
      this.refreshMetrics();
    }

    this.refreshHint();
  }

  componentWillUnmount() {
    if (this.languageProviderInitializationPromise) {
      this.languageProviderInitializationPromise.cancel();
    }
  }

  componentDidUpdate(prevProps) {
    const {
      data,
      datasource: {
        languageProvider
      },
      range
    } = this.props;

    if (languageProvider !== prevProps.datasource.languageProvider) {
      // We reset this only on DS change so we do not flesh loading state on every rangeChange which happens on every
      // query run if using relative range.
      this.setState({
        syntaxLoaded: false
      });
    }

    const changedRangeToRefresh = this.rangeChangedToRefresh(range, prevProps.range); // We want to refresh metrics when language provider changes and/or when range changes (we round up intervals to a minute)

    if (languageProvider !== prevProps.datasource.languageProvider || changedRangeToRefresh) {
      this.refreshMetrics();
    }

    if (data && prevProps.data && prevProps.data.series !== data.series) {
      this.refreshHint();
    }
  }

  rangeChangedToRefresh(range, prevRange) {
    if (range && prevRange) {
      const sameMinuteFrom = (0,_language_utils__WEBPACK_IMPORTED_MODULE_6__.roundMsToMin)(range.from.valueOf()) === (0,_language_utils__WEBPACK_IMPORTED_MODULE_6__.roundMsToMin)(prevRange.from.valueOf());
      const sameMinuteTo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_6__.roundMsToMin)(range.to.valueOf()) === (0,_language_utils__WEBPACK_IMPORTED_MODULE_6__.roundMsToMin)(prevRange.to.valueOf()); // If both are same, don't need to refresh.

      return !(sameMinuteFrom && sameMinuteTo);
    }

    return false;
  }
  /**
   * TODO #33976: Remove this, add histogram group (query = `histogram_quantile(0.95, sum(rate(${metric}[5m])) by (le))`;)
   */


  render() {
    const {
      datasource,
      datasource: {
        languageProvider
      },
      query,
      ExtraFieldElement,
      history = []
    } = this.props;
    const {
      labelBrowserVisible,
      syntaxLoaded,
      hint
    } = this.state;
    const hasMetrics = languageProvider.metrics.length > 0;
    const chooserText = getChooserText(datasource.lookupsDisabled, syntaxLoaded, hasMetrics);
    const buttonDisabled = !(syntaxLoaded && hasMetrics);
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_4__.LocalStorageValueProvider, {
      storageKey: LAST_USED_LABELS_KEY,
      defaultValue: [],
      children: (lastUsedLabels, onLastUsedLabelsSave, onLastUsedLabelsDelete) => {
        var _query$expr;

        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.Fragment, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
            className: "gf-form-inline gf-form-inline--xs-view-flex-column flex-grow-1",
            "data-testid": this.props['data-testid'],
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("button", {
              className: "gf-form-label query-keyword pointer",
              onClick: this.onClickChooserButton,
              disabled: buttonDisabled,
              children: [chooserText, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
                name: labelBrowserVisible ? 'angle-down' : 'angle-right'
              })]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
              className: "gf-form gf-form--grow flex-shrink-1 min-width-15",
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_monaco_query_field_MonacoQueryFieldWrapper__WEBPACK_IMPORTED_MODULE_8__.MonacoQueryFieldWrapper, {
                runQueryOnBlur: this.props.app !== _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Explore,
                languageProvider: languageProvider,
                history: history,
                onChange: this.onChangeQuery,
                onRunQuery: this.props.onRunQuery,
                initialValue: (_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : ''
              })
            })]
          }), labelBrowserVisible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "gf-form",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_PrometheusMetricsBrowser__WEBPACK_IMPORTED_MODULE_7__.PrometheusMetricsBrowser, {
              languageProvider: languageProvider,
              onChange: this.onChangeLabelBrowser,
              lastUsedLabels: lastUsedLabels || [],
              storeLastUsedLabels: onLastUsedLabelsSave,
              deleteLastUsedLabels: onLastUsedLabelsDelete
            })
          }), ExtraFieldElement, hint ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "query-row-break",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
              className: "prom-query-field-info text-warning",
              children: [hint.label, ' ', hint.fix ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("a", {
                className: "text-link muted",
                onClick: this.onClickHintFix,
                children: hint.fix.label
              }) : null]
            })
          }) : null]
        });
      }
    });
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PromQueryField);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PrometheusMetricsBrowser.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrometheusMetricsBrowser": () => (/* binding */ PrometheusMetricsBrowser),
/* harmony export */   "UnthemedPrometheusMetricsBrowser": () => (/* binding */ UnthemedPrometheusMetricsBrowser),
/* harmony export */   "buildSelector": () => (/* binding */ buildSelector),
/* harmony export */   "facetLabels": () => (/* binding */ facetLabels)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_window__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-window-virtual-db79012d82/0/cache/react-window-npm-1.8.7-5a23226c09-1e122c2922.zip/node_modules/react-window/dist/index.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _LoadingPlaceholder, _Label, _Label2, _Label3, _Label4;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





 // Hard limit on labels to render



const EMPTY_SELECTOR = '{}';
const METRIC_LABEL = '__name__';
const LIST_ITEM_SIZE = 25;
function buildSelector(labels) {
  let singleMetric = '';
  const selectedLabels = [];

  for (const label of labels) {
    if ((label.name === METRIC_LABEL || label.selected) && label.values && label.values.length > 0) {
      const selectedValues = label.values.filter(value => value.selected).map(value => value.name);

      if (selectedValues.length > 1) {
        selectedLabels.push(`${label.name}=~"${selectedValues.map(_language_utils__WEBPACK_IMPORTED_MODULE_3__.escapeLabelValueInRegexSelector).join('|')}"`);
      } else if (selectedValues.length === 1) {
        if (label.name === METRIC_LABEL) {
          singleMetric = selectedValues[0];
        } else {
          selectedLabels.push(`${label.name}="${(0,_language_utils__WEBPACK_IMPORTED_MODULE_3__.escapeLabelValueInExactSelector)(selectedValues[0])}"`);
        }
      }
    }
  }

  return [singleMetric, '{', selectedLabels.join(','), '}'].join('');
}
function facetLabels(labels, possibleLabels, lastFacetted) {
  return labels.map(label => {
    const possibleValues = possibleLabels[label.name];

    if (possibleValues) {
      let existingValues;

      if (label.name === lastFacetted && label.values) {
        // Facetting this label, show all values
        existingValues = label.values;
      } else {
        var _label$values;

        // Keep selection in other facets
        const selectedValues = new Set(((_label$values = label.values) === null || _label$values === void 0 ? void 0 : _label$values.filter(value => value.selected).map(value => value.name)) || []); // Values for this label have not been requested yet, let's use the facetted ones as the initial values

        existingValues = possibleValues.map(value => ({
          name: value,
          selected: selectedValues.has(value)
        }));
      }

      return Object.assign({}, label, {
        loading: false,
        values: existingValues,
        hidden: !possibleValues,
        facets: existingValues.length
      });
    } // Label is facetted out, hide all values


    return Object.assign({}, label, {
      loading: false,
      hidden: !possibleValues,
      values: undefined,
      facets: 0
    });
  });
}
const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.stylesFactory)(theme => ({
  wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    background-color: ${theme.colors.bg2};
    padding: ${theme.spacing.sm};
    width: 100%;
  `,
  list: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-top: ${theme.spacing.sm};
    display: flex;
    flex-wrap: wrap;
    max-height: 200px;
    overflow: auto;
    align-content: flex-start;
  `,
  section: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    & + & {
      margin: ${theme.spacing.md} 0;
    }
    position: relative;
  `,
  selector: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    font-family: ${theme.typography.fontFamily.monospace};
    margin-bottom: ${theme.spacing.sm};
  `,
  status: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding: ${theme.spacing.xs};
    color: ${theme.colors.textSemiWeak};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    /* using absolute positioning because flex interferes with ellipsis */
    position: absolute;
    width: 50%;
    right: 0;
    text-align: right;
    transition: opacity 100ms linear;
    opacity: 0;
  `,
  statusShowing: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    opacity: 1;
  `,
  error: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    color: ${theme.palette.brandDanger};
  `,
  valueList: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-right: ${theme.spacing.sm};
  `,
  valueListWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    border-left: 1px solid ${theme.colors.border2};
    margin: ${theme.spacing.sm} 0;
    padding: ${theme.spacing.sm} 0 ${theme.spacing.sm} ${theme.spacing.sm};
  `,
  valueListArea: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    flex-wrap: wrap;
    margin-top: ${theme.spacing.sm};
  `,
  valueTitle: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-left: -${theme.spacing.xs};
    margin-bottom: ${theme.spacing.sm};
  `,
  validationStatus: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding: ${theme.spacing.xs};
    margin-bottom: ${theme.spacing.sm};
    color: ${theme.colors.textStrong};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  `
}));
/**
 * TODO #33976: Remove duplicated code. The component is very similar to LokiLabelBrowser.tsx. Check if it's possible
 *              to create a single, generic component.
 */

class UnthemedPrometheusMetricsBrowser extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "valueListsRef", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createRef());

    _defineProperty(this, "state", {
      labels: [],
      labelSearchTerm: '',
      metricSearchTerm: '',
      status: 'Ready',
      error: '',
      validationStatus: '',
      valueSearchTerm: ''
    });

    _defineProperty(this, "onChangeLabelSearch", event => {
      this.setState({
        labelSearchTerm: event.target.value
      });
    });

    _defineProperty(this, "onChangeMetricSearch", event => {
      this.setState({
        metricSearchTerm: event.target.value
      });
    });

    _defineProperty(this, "onChangeValueSearch", event => {
      this.setState({
        valueSearchTerm: event.target.value
      });
    });

    _defineProperty(this, "onClickRunQuery", () => {
      const selector = buildSelector(this.state.labels);
      this.props.onChange(selector);
    });

    _defineProperty(this, "onClickRunRateQuery", () => {
      const selector = buildSelector(this.state.labels);
      const query = `rate(${selector}[$__interval])`;
      this.props.onChange(query);
    });

    _defineProperty(this, "onClickClear", () => {
      this.setState(state => {
        const labels = state.labels.map(label => Object.assign({}, label, {
          values: undefined,
          selected: false,
          loading: false,
          hidden: false,
          facets: undefined
        }));
        return {
          labels,
          labelSearchTerm: '',
          metricSearchTerm: '',
          status: '',
          error: '',
          validationStatus: '',
          valueSearchTerm: ''
        };
      });
      this.props.deleteLastUsedLabels(); // Get metrics

      this.fetchValues(METRIC_LABEL, EMPTY_SELECTOR);
    });

    _defineProperty(this, "onClickLabel", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label) {
        return;
      } // Toggle selected state


      const selected = !label.selected;
      let nextValue = {
        selected
      };

      if (label.values && !selected) {
        // Deselect all values if label was deselected
        const values = label.values.map(value => Object.assign({}, value, {
          selected: false
        }));
        nextValue = Object.assign({}, nextValue, {
          facets: 0,
          values
        });
      } // Resetting search to prevent empty results


      this.setState({
        labelSearchTerm: ''
      });
      this.updateLabelState(name, nextValue, '', () => this.doFacettingForLabel(name));
    });

    _defineProperty(this, "onClickValue", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label || !label.values) {
        return;
      } // Resetting search to prevent empty results


      this.setState({
        labelSearchTerm: ''
      }); // Toggling value for selected label, leaving other values intact

      const values = label.values.map(v => Object.assign({}, v, {
        selected: v.name === value ? !v.selected : v.selected
      }));
      this.updateLabelState(name, {
        values
      }, '', () => this.doFacetting(name));
    });

    _defineProperty(this, "onClickMetric", (name, value, event) => {
      // Finding special metric label
      const label = this.state.labels.find(l => l.name === name);

      if (!label || !label.values) {
        return;
      } // Resetting search to prevent empty results


      this.setState({
        metricSearchTerm: ''
      }); // Toggling value for selected label, leaving other values intact

      const values = label.values.map(v => Object.assign({}, v, {
        selected: v.name === value || v.selected ? !v.selected : v.selected
      })); // Toggle selected state of special metrics label

      const selected = values.some(v => v.selected);
      this.updateLabelState(name, {
        selected,
        values
      }, '', () => this.doFacetting(name));
    });

    _defineProperty(this, "onClickValidate", () => {
      const selector = buildSelector(this.state.labels);
      this.validateSelector(selector);
    });

    _defineProperty(this, "doFacetting", lastFacetted => {
      const selector = buildSelector(this.state.labels);

      if (selector === EMPTY_SELECTOR) {
        // Clear up facetting
        const labels = this.state.labels.map(label => {
          return Object.assign({}, label, {
            facets: 0,
            values: undefined,
            hidden: false
          });
        });
        this.setState({
          labels
        }, () => {
          // Get fresh set of values
          this.state.labels.forEach(label => (label.selected || label.name === METRIC_LABEL) && this.fetchValues(label.name, selector));
        });
      } else {
        // Do facetting
        this.fetchSeries(selector, lastFacetted);
      }
    });
  }

  updateLabelState(name, updatedFields, status = '', cb) {
    this.setState(state => {
      const labels = state.labels.map(label => {
        if (label.name === name) {
          return Object.assign({}, label, updatedFields);
        }

        return label;
      }); // New status overrides errors

      const error = status ? '' : state.error;
      return {
        labels,
        status,
        error,
        validationStatus: ''
      };
    }, cb);
  }

  componentDidMount() {
    const {
      languageProvider,
      lastUsedLabels
    } = this.props;

    if (languageProvider) {
      const selectedLabels = lastUsedLabels;
      languageProvider.start().then(() => {
        let rawLabels = languageProvider.getLabelKeys(); // Get metrics

        this.fetchValues(METRIC_LABEL, EMPTY_SELECTOR); // Auto-select previously selected labels

        const labels = rawLabels.map((label, i, arr) => ({
          name: label,
          selected: selectedLabels.includes(label),
          loading: false
        })); // Pre-fetch values for selected labels

        this.setState({
          labels
        }, () => {
          this.state.labels.forEach(label => {
            if (label.selected) {
              this.fetchValues(label.name, EMPTY_SELECTOR);
            }
          });
        });
      });
    }
  }

  doFacettingForLabel(name) {
    const label = this.state.labels.find(l => l.name === name);

    if (!label) {
      return;
    }

    const selectedLabels = this.state.labels.filter(label => label.selected).map(label => label.name);
    this.props.storeLastUsedLabels(selectedLabels);

    if (label.selected) {
      // Refetch values for newly selected label...
      if (!label.values) {
        this.fetchValues(name, buildSelector(this.state.labels));
      }
    } else {
      // Only need to facet when deselecting labels
      this.doFacetting();
    }
  }

  async fetchValues(name, selector) {
    const {
      languageProvider
    } = this.props;
    this.updateLabelState(name, {
      loading: true
    }, `Fetching values for ${name}`);

    try {
      let rawValues = await languageProvider.getLabelValues(name); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        this.updateLabelState(name, {
          loading: false
        });
        return;
      }

      const values = [];
      const {
        metricsMetadata
      } = languageProvider;

      for (const labelValue of rawValues) {
        const value = {
          name: labelValue
        }; // Adding type/help text to metrics

        if (name === METRIC_LABEL && metricsMetadata) {
          const meta = metricsMetadata[labelValue];

          if (meta) {
            value.details = `(${meta.type}) ${meta.help}`;
          }
        }

        values.push(value);
      }

      this.updateLabelState(name, {
        values,
        loading: false
      });
    } catch (error) {
      console.error(error);
    }
  }

  async fetchSeries(selector, lastFacetted) {
    const {
      languageProvider
    } = this.props;

    if (lastFacetted) {
      this.updateLabelState(lastFacetted, {
        loading: true
      }, `Facetting labels for ${selector}`);
    }

    try {
      const possibleLabels = await languageProvider.fetchSeriesLabels(selector, true); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        if (lastFacetted) {
          this.updateLabelState(lastFacetted, {
            loading: false
          });
        }

        return;
      }

      if (Object.keys(possibleLabels).length === 0) {
        this.setState({
          error: `Empty results, no matching label for ${selector}`
        });
        return;
      }

      const labels = facetLabels(this.state.labels, possibleLabels, lastFacetted);
      this.setState({
        labels,
        error: ''
      });

      if (lastFacetted) {
        this.updateLabelState(lastFacetted, {
          loading: false
        });
      }
    } catch (error) {
      console.error(error);
    }
  }

  async validateSelector(selector) {
    const {
      languageProvider
    } = this.props;
    this.setState({
      validationStatus: `Validating selector ${selector}`,
      error: ''
    });
    const streams = await languageProvider.fetchSeries(selector);
    this.setState({
      validationStatus: `Selector is valid (${streams.length} series found)`
    });
  }

  render() {
    var _metrics, _metrics$values2;

    const {
      theme
    } = this.props;
    const {
      labels,
      labelSearchTerm,
      metricSearchTerm,
      status,
      error,
      validationStatus,
      valueSearchTerm
    } = this.state;
    const styles = getStyles(theme);

    if (labels.length === 0) {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.wrapper,
        children: _LoadingPlaceholder || (_LoadingPlaceholder = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.LoadingPlaceholder, {
          text: "Loading labels..."
        }))
      });
    } // Filter metrics


    let metrics = labels.find(label => label.name === METRIC_LABEL);

    if (metrics && metricSearchTerm) {
      var _metrics$values;

      metrics = Object.assign({}, metrics, {
        values: (_metrics$values = metrics.values) === null || _metrics$values === void 0 ? void 0 : _metrics$values.filter(value => value.selected || value.name.includes(metricSearchTerm))
      });
    } // Filter labels


    let nonMetricLabels = labels.filter(label => !label.hidden && label.name !== METRIC_LABEL);

    if (labelSearchTerm) {
      nonMetricLabels = nonMetricLabels.filter(label => label.selected || label.name.includes(labelSearchTerm));
    } // Filter non-metric label values


    let selectedLabels = nonMetricLabels.filter(label => label.selected && label.values);

    if (valueSearchTerm) {
      selectedLabels = selectedLabels.map(label => {
        var _label$values2;

        return Object.assign({}, label, {
          values: (_label$values2 = label.values) === null || _label$values2 === void 0 ? void 0 : _label$values2.filter(value => value.selected || value.name.includes(valueSearchTerm))
        });
      });
    }

    const selector = buildSelector(this.state.labels);
    const empty = selector === EMPTY_SELECTOR;
    const metricCount = ((_metrics = metrics) === null || _metrics === void 0 ? void 0 : (_metrics$values2 = _metrics.values) === null || _metrics$values2 === void 0 ? void 0 : _metrics$values2.length) || 0;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.wrapper,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.HorizontalGroup, {
        align: "flex-start",
        spacing: "lg",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
            className: styles.section,
            children: [_Label || (_Label = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Label, {
              description: "Once a metric is selected only possible labels are shown.",
              children: "1. Select a metric"
            })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
                onChange: this.onChangeMetricSearch,
                "aria-label": "Filter expression for metric",
                value: metricSearchTerm
              })
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              role: "list",
              className: styles.valueListWrapper,
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_window__WEBPACK_IMPORTED_MODULE_5__.FixedSizeList, {
                height: Math.min(450, metricCount * LIST_ITEM_SIZE),
                itemCount: metricCount,
                itemSize: LIST_ITEM_SIZE,
                itemKey: i => metrics.values[i].name,
                width: 300,
                className: styles.valueList,
                children: ({
                  index,
                  style
                }) => {
                  var _metrics2, _metrics2$values;

                  const value = (_metrics2 = metrics) === null || _metrics2 === void 0 ? void 0 : (_metrics2$values = _metrics2.values) === null || _metrics2$values === void 0 ? void 0 : _metrics2$values[index];

                  if (!value) {
                    return null;
                  }

                  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
                    style: style,
                    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.BrowserLabel, {
                      name: metrics.name,
                      value: value === null || value === void 0 ? void 0 : value.name,
                      title: value.details,
                      active: value === null || value === void 0 ? void 0 : value.selected,
                      onClick: this.onClickMetric,
                      searchTerm: metricSearchTerm
                    })
                  });
                }
              })
            })]
          })
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
            className: styles.section,
            children: [_Label2 || (_Label2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Label, {
              description: "Once label values are selected, only possible label combinations are shown.",
              children: "2. Select labels to search in"
            })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
                onChange: this.onChangeLabelSearch,
                "aria-label": "Filter expression for label",
                value: labelSearchTerm
              })
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              className: styles.list,
              style: {
                height: 120
              },
              children: nonMetricLabels.map(label => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.BrowserLabel, {
                name: label.name,
                loading: label.loading,
                active: label.selected,
                hidden: label.hidden,
                facets: label.facets,
                onClick: this.onClickLabel,
                searchTerm: labelSearchTerm
              }, label.name))
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
            className: styles.section,
            children: [_Label3 || (_Label3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Label, {
              description: "Use the search field to find values across selected labels.",
              children: "3. Select (multiple) values for your labels"
            })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
                onChange: this.onChangeValueSearch,
                "aria-label": "Filter expression for label values",
                value: valueSearchTerm
              })
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              className: styles.valueListArea,
              ref: this.valueListsRef,
              children: selectedLabels.map(label => {
                var _label$values3, _label$values4, _label$values5;

                return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
                  role: "list",
                  "aria-label": `Values for ${label.name}`,
                  className: styles.valueListWrapper,
                  children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
                    className: styles.valueTitle,
                    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.BrowserLabel, {
                      name: label.name,
                      loading: label.loading,
                      active: label.selected,
                      hidden: label.hidden //If no facets, we want to show number of all label values
                      ,
                      facets: label.facets || ((_label$values3 = label.values) === null || _label$values3 === void 0 ? void 0 : _label$values3.length),
                      onClick: this.onClickLabel
                    })
                  }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_window__WEBPACK_IMPORTED_MODULE_5__.FixedSizeList, {
                    height: Math.min(200, LIST_ITEM_SIZE * (((_label$values4 = label.values) === null || _label$values4 === void 0 ? void 0 : _label$values4.length) || 0)),
                    itemCount: ((_label$values5 = label.values) === null || _label$values5 === void 0 ? void 0 : _label$values5.length) || 0,
                    itemSize: 28,
                    itemKey: i => label.values[i].name,
                    width: 200,
                    className: styles.valueList,
                    children: ({
                      index,
                      style
                    }) => {
                      var _label$values6;

                      const value = (_label$values6 = label.values) === null || _label$values6 === void 0 ? void 0 : _label$values6[index];

                      if (!value) {
                        return null;
                      }

                      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
                        style: style,
                        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.BrowserLabel, {
                          name: label.name,
                          value: value === null || value === void 0 ? void 0 : value.name,
                          active: value === null || value === void 0 ? void 0 : value.selected,
                          onClick: this.onClickValue,
                          searchTerm: valueSearchTerm
                        })
                      });
                    }
                  })]
                }, label.name);
              })
            })]
          })]
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.section,
        children: [_Label4 || (_Label4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Label, {
          children: "4. Resulting selector"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          "aria-label": "selector",
          className: styles.selector,
          children: selector
        }), validationStatus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: styles.validationStatus,
          children: validationStatus
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.HorizontalGroup, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            "aria-label": "Use selector for query button",
            disabled: empty,
            onClick: this.onClickRunQuery,
            children: "Use query"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            "aria-label": "Use selector as metrics button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickRunRateQuery,
            children: "Use as rate query"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            "aria-label": "Validate submit button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickValidate,
            children: "Validate selector"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            "aria-label": "Selector clear button",
            variant: "secondary",
            onClick: this.onClickClear,
            children: "Clear"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
            className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.status, (status || error) && styles.statusShowing),
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
              className: error ? styles.error : '',
              children: error || status
            })
          })]
        })]
      })]
    });
  }

}
const PrometheusMetricsBrowser = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.withTheme)(UnthemedPrometheusMetricsBrowser);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldLazy.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MonacoQueryFieldLazy": () => (/* binding */ MonacoQueryFieldLazy)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");


const Field = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.lazy(() => __webpack_require__.e(/* import() | prom-query-field */ "prom-query-field").then(__webpack_require__.bind(__webpack_require__, "./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryField.tsx")));
const MonacoQueryFieldLazy = props => {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {
    fallback: null,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Field, Object.assign({}, props))
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldWrapper.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MonacoQueryFieldWrapper": () => (/* binding */ MonacoQueryFieldWrapper)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _MonacoQueryFieldLazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldLazy.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["runQueryOnBlur", "onRunQuery", "onChange"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




const MonacoQueryFieldWrapper = props => {
  const lastRunValueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);

  const {
    runQueryOnBlur,
    onRunQuery,
    onChange
  } = props,
        rest = _objectWithoutPropertiesLoose(props, _excluded);

  const handleRunQuery = value => {
    lastRunValueRef.current = value;
    onChange(value);
    onRunQuery();
  };

  const handleBlur = value => {
    if (runQueryOnBlur) {
      // run handleRunQuery only if the current value is different from the last-time-executed value
      if (value !== lastRunValueRef.current) {
        handleRunQuery(value);
      }
    } else {
      onChange(value);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_MonacoQueryFieldLazy__WEBPACK_IMPORTED_MODULE_1__.MonacoQueryFieldLazy, Object.assign({
    onRunQuery: handleRunQuery,
    onBlur: handleBlur
  }, rest));
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureAuthSettings.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureAuthSettings": () => (/* binding */ AzureAuthSettings),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _AzureCredentials__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts");
/* harmony import */ var _AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsConfig.ts");
/* harmony import */ var _AzureCredentialsForm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsForm.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h, _h2;










const AzureAuthSettings = props => {
  const {
    dataSourceConfig,
    onChange
  } = props;
  const [overrideAudienceAllowed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.config.featureToggles.prometheusAzureOverrideAudience || !!dataSourceConfig.jsonData.azureEndpointResourceId);
  const [overrideAudienceChecked, setOverrideAudienceChecked] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!!dataSourceConfig.jsonData.azureEndpointResourceId);
  const credentials = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_4__.getCredentials)(dataSourceConfig), [dataSourceConfig]);

  const onCredentialsChange = credentials => {
    onChange((0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_4__.updateCredentials)(dataSourceConfig, credentials));
  };

  const onOverrideAudienceChange = ev => {
    setOverrideAudienceChecked(ev.currentTarget.checked);

    if (!ev.currentTarget.checked) {
      onChange(Object.assign({}, dataSourceConfig, {
        jsonData: Object.assign({}, dataSourceConfig.jsonData, {
          azureEndpointResourceId: undefined
        })
      }));
    }
  };

  const onResourceIdChange = ev => {
    if (overrideAudienceChecked) {
      onChange(Object.assign({}, dataSourceConfig, {
        jsonData: Object.assign({}, dataSourceConfig.jsonData, {
          azureEndpointResourceId: ev.currentTarget.value
        })
      }));
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
    children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("h6", {
      children: "Azure Authentication"
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_AzureCredentialsForm__WEBPACK_IMPORTED_MODULE_5__.AzureCredentialsForm, {
      managedIdentityEnabled: _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.config.azure.managedIdentityEnabled,
      credentials: credentials,
      azureCloudOptions: _AzureCredentials__WEBPACK_IMPORTED_MODULE_3__.KnownAzureClouds,
      onCredentialsChange: onCredentialsChange
    }), overrideAudienceAllowed && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
      children: [_h2 || (_h2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("h6", {
        children: "Azure Configuration"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
        className: "gf-form-group",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFieldRow, {
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineField, {
            labelWidth: 26,
            label: "Override AAD audience",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineSwitch, {
              value: overrideAudienceChecked,
              onChange: onOverrideAudienceChange
            })
          })
        }), overrideAudienceChecked && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFieldRow, {
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineField, {
            labelWidth: 26,
            label: "Resource ID",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
              className: "width-30",
              value: dataSourceConfig.jsonData.azureEndpointResourceId || '',
              onChange: onResourceIdChange
            })
          })
        })]
      })]
    })]
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AzureAuthSettings);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureCloud": () => (/* binding */ AzureCloud),
/* harmony export */   "KnownAzureClouds": () => (/* binding */ KnownAzureClouds),
/* harmony export */   "isCredentialsComplete": () => (/* binding */ isCredentialsComplete)
/* harmony export */ });
let AzureCloud;

(function (AzureCloud) {
  AzureCloud["Public"] = "AzureCloud";
  AzureCloud["China"] = "AzureChinaCloud";
  AzureCloud["USGovernment"] = "AzureUSGovernment";
  AzureCloud["Germany"] = "AzureGermanCloud";
  AzureCloud["None"] = "";
})(AzureCloud || (AzureCloud = {}));

const KnownAzureClouds = [{
  value: AzureCloud.Public,
  label: 'Azure'
}, {
  value: AzureCloud.China,
  label: 'Azure China'
}, {
  value: AzureCloud.USGovernment,
  label: 'Azure US Government'
}, {
  value: AzureCloud.Germany,
  label: 'Azure Germany'
}];
function isCredentialsComplete(credentials) {
  switch (credentials.authType) {
    case 'msi':
      return true;

    case 'clientsecret':
      return !!(credentials.azureCloud && credentials.tenantId && credentials.clientId && credentials.clientSecret);
  }
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsConfig.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCredentials": () => (/* binding */ getCredentials),
/* harmony export */   "getDefaultCredentials": () => (/* binding */ getDefaultCredentials),
/* harmony export */   "hasCredentials": () => (/* binding */ hasCredentials),
/* harmony export */   "resetCredentials": () => (/* binding */ resetCredentials),
/* harmony export */   "setDefaultCredentials": () => (/* binding */ setDefaultCredentials),
/* harmony export */   "updateCredentials": () => (/* binding */ updateCredentials)
/* harmony export */ });
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _AzureCredentials__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts");


const concealed = Symbol('Concealed client secret');

function getDefaultAzureCloud() {
  return _grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.cloud || _AzureCredentials__WEBPACK_IMPORTED_MODULE_1__.AzureCloud.Public;
}

function getSecret(options) {
  if (options.secureJsonFields.azureClientSecret) {
    // The secret is concealed on server
    return concealed;
  } else {
    var _options$secureJsonDa;

    const secret = (_options$secureJsonDa = options.secureJsonData) === null || _options$secureJsonDa === void 0 ? void 0 : _options$secureJsonDa.azureClientSecret;
    return typeof secret === 'string' && secret.length > 0 ? secret : undefined;
  }
}

function hasCredentials(options) {
  return !!options.jsonData.azureCredentials;
}
function getDefaultCredentials() {
  if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.managedIdentityEnabled) {
    return {
      authType: 'msi'
    };
  } else {
    return {
      authType: 'clientsecret',
      azureCloud: getDefaultAzureCloud()
    };
  }
}
function getCredentials(options) {
  const credentials = options.jsonData.azureCredentials; // If no credentials saved, then return empty credentials
  // of type based on whether the managed identity enabled

  if (!credentials) {
    return getDefaultCredentials();
  }

  switch (credentials.authType) {
    case 'msi':
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.managedIdentityEnabled) {
        return {
          authType: 'msi'
        };
      } else {
        // If authentication type is managed identity but managed identities were disabled in Grafana config,
        // then we should fallback to an empty app registration (client secret) configuration
        return {
          authType: 'clientsecret',
          azureCloud: getDefaultAzureCloud()
        };
      }

    case 'clientsecret':
      return {
        authType: 'clientsecret',
        azureCloud: credentials.azureCloud || getDefaultAzureCloud(),
        tenantId: credentials.tenantId,
        clientId: credentials.clientId,
        clientSecret: getSecret(options)
      };
  }
}
function updateCredentials(options, credentials) {
  switch (credentials.authType) {
    case 'msi':
      if (!_grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.managedIdentityEnabled) {
        throw new Error('Managed Identity authentication is not enabled in Grafana config.');
      }

      options = Object.assign({}, options, {
        jsonData: Object.assign({}, options.jsonData, {
          azureCredentials: {
            authType: 'msi'
          }
        })
      });
      return options;

    case 'clientsecret':
      options = Object.assign({}, options, {
        jsonData: Object.assign({}, options.jsonData, {
          azureCredentials: {
            authType: 'clientsecret',
            azureCloud: credentials.azureCloud || getDefaultAzureCloud(),
            tenantId: credentials.tenantId,
            clientId: credentials.clientId
          }
        }),
        secureJsonData: Object.assign({}, options.secureJsonData, {
          azureClientSecret: typeof credentials.clientSecret === 'string' && credentials.clientSecret.length > 0 ? credentials.clientSecret : undefined
        }),
        secureJsonFields: Object.assign({}, options.secureJsonFields, {
          azureClientSecret: typeof credentials.clientSecret === 'symbol'
        })
      });
      return options;
  }
}
function setDefaultCredentials(options) {
  return {
    jsonData: Object.assign({}, options.jsonData, {
      azureCredentials: getDefaultCredentials()
    })
  };
}
function resetCredentials(options) {
  return {
    jsonData: Object.assign({}, options.jsonData, {
      azureAuth: undefined,
      azureCredentials: undefined,
      azureEndpointResourceId: undefined
    })
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsForm.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureCredentialsForm": () => (/* binding */ AzureCredentialsForm),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/components/index.ts");
/* harmony import */ var _grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/Legacy/Input/Input.tsx");
/* harmony import */ var _grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/Legacy/Select/Select.tsx");
/* harmony import */ var _AzureCredentials__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _InlineFormLabel2, _InlineFormLabel3, _InlineFormLabel4, _div, _InlineFormLabel5, _InlineFormLabel6;









const authTypeOptions = [{
  value: 'msi',
  label: 'Managed Identity'
}, {
  value: 'clientsecret',
  label: 'App Registration'
}];
const AzureCredentialsForm = props => {
  const {
    credentials,
    azureCloudOptions,
    onCredentialsChange,
    getSubscriptions
  } = props;
  const hasRequiredFields = (0,_AzureCredentials__WEBPACK_IMPORTED_MODULE_4__.isCredentialsComplete)(credentials);
  const [subscriptions, setSubscriptions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
  const [loadSubscriptionsClicked, onLoadSubscriptions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(val => val + 1, 0);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!getSubscriptions || !hasRequiredFields) {
      updateSubscriptions([]);
      return;
    }

    let canceled = false;
    getSubscriptions().then(result => {
      if (!canceled) {
        updateSubscriptions(result, loadSubscriptionsClicked);
      }
    });
    return () => {
      canceled = true;
    }; // This effect is intended to be called only once initially and on Load Subscriptions click
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [loadSubscriptionsClicked]);

  const updateSubscriptions = (received, autoSelect = false) => {
    setSubscriptions(received);

    if (getSubscriptions) {
      if (autoSelect && !credentials.defaultSubscriptionId && received.length > 0) {
        // Selecting the default subscription if subscriptions received but no default subscription selected
        onSubscriptionChange(received[0]);
      } else if (credentials.defaultSubscriptionId) {
        const found = received.find(opt => opt.value === credentials.defaultSubscriptionId);

        if (!found) {
          // Unselecting the default subscription if it isn't found among the received subscriptions
          onSubscriptionChange(undefined);
        }
      }
    }
  };

  const onAuthTypeChange = selected => {
    if (onCredentialsChange) {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        authType: selected.value || 'msi',
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onAzureCloudChange = selected => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        azureCloud: selected.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onTenantIdChange = event => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        tenantId: event.target.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onClientIdChange = event => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        clientId: event.target.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onClientSecretChange = event => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        clientSecret: event.target.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onClientSecretReset = () => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        clientSecret: '',
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onSubscriptionChange = selected => {
    if (onCredentialsChange) {
      const updated = Object.assign({}, credentials, {
        defaultSubscriptionId: selected === null || selected === void 0 ? void 0 : selected.value
      });
      onCredentialsChange(updated);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: "gf-form-group",
    children: [props.managedIdentityEnabled && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: "gf-form-inline",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: "gf-form",
        children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
          className: "width-12",
          tooltip: "Choose the type of authentication to Azure services",
          children: "Authentication"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_3__.Select, {
          className: "width-15",
          value: authTypeOptions.find(opt => opt.value === credentials.authType),
          options: authTypeOptions,
          onChange: onAuthTypeChange
        })]
      })
    }), credentials.authType === 'clientsecret' && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [azureCloudOptions && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel2 || (_InlineFormLabel2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            tooltip: "Choose an Azure Cloud",
            children: "Azure Cloud"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_3__.Select, {
            className: "width-15",
            value: azureCloudOptions.find(opt => opt.value === credentials.azureCloud),
            options: azureCloudOptions,
            onChange: onAzureCloudChange
          })]
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel3 || (_InlineFormLabel3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Directory (tenant) ID"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-15",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_2__.Input, {
              className: "width-30",
              placeholder: "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
              value: credentials.tenantId || '',
              onChange: onTenantIdChange
            })
          })]
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel4 || (_InlineFormLabel4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Application (client) ID"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-15",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_2__.Input, {
              className: "width-30",
              placeholder: "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
              value: credentials.clientId || '',
              onChange: onClientIdChange
            })
          })]
        })
      }), typeof credentials.clientSecret === 'symbol' ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: "gf-form-inline",
        children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Client Secret"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_2__.Input, {
            className: "width-25",
            placeholder: "configured",
            disabled: true
          })]
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "max-width-30 gf-form-inline",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.Button, {
              variant: "secondary",
              type: "button",
              onClick: onClientSecretReset,
              children: "reset"
            })
          })
        })]
      }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel5 || (_InlineFormLabel5 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Client Secret"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-15",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_2__.Input, {
              className: "width-30",
              placeholder: "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
              value: credentials.clientSecret || '',
              onChange: onClientSecretChange
            })
          })]
        })
      })]
    }), getSubscriptions && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel6 || (_InlineFormLabel6 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Default Subscription"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-25",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_3__.Select, {
              value: credentials.defaultSubscriptionId ? subscriptions.find(opt => opt.value === credentials.defaultSubscriptionId) : undefined,
              options: subscriptions,
              onChange: onSubscriptionChange
            })
          })]
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "max-width-30 gf-form-inline",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.Button, {
              variant: "secondary",
              size: "sm",
              type: "button",
              onClick: onLoadSubscriptions,
              disabled: !hasRequiredFields,
              children: "Load Subscriptions"
            })
          })
        })
      })]
    })]
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AzureCredentialsForm);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigEditor": () => (/* binding */ ConfigEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_aws_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@grafana-aws-sdk-npm-0.0.36-8ab4b07904-c243f7c900.zip/node_modules/@grafana/aws-sdk/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/core/config.ts");
/* harmony import */ var app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/alerting/unified/utils/alertmanager.ts");
/* harmony import */ var _AzureAuthSettings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureAuthSettings.tsx");
/* harmony import */ var _AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsConfig.ts");
/* harmony import */ var _PromSettings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Alert;












const ConfigEditor = props => {
  const {
    options,
    onOptionsChange
  } = props;
  const alertmanagers = (0,app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_4__.getAllAlertmanagerDataSources)();
  const azureAuthSettings = {
    azureAuthSupported: !!app_core_config__WEBPACK_IMPORTED_MODULE_3__.config.featureToggles.prometheus_azure_auth,
    getAzureAuthEnabled: config => (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_6__.hasCredentials)(config),
    setAzureAuthEnabled: (config, enabled) => enabled ? (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_6__.setDefaultCredentials)(config) : (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_6__.resetCredentials)(config),
    azureSettingsUI: _AzureAuthSettings__WEBPACK_IMPORTED_MODULE_5__.AzureAuthSettings
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.Fragment, {
    children: [options.access === 'direct' && (_Alert || (_Alert = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Alert, {
      title: "Deprecation Notice",
      severity: "warning",
      children: "Browser access mode in the Prometheus datasource is deprecated and will be removed in a future release."
    }))), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.DataSourceHttpSettings, {
      defaultUrl: "http://localhost:9090",
      dataSourceConfig: options,
      showAccessOptions: true,
      onChange: onOptionsChange,
      sigV4AuthToggleEnabled: app_core_config__WEBPACK_IMPORTED_MODULE_3__.config.sigV4AuthEnabled,
      azureAuthSettings: azureAuthSettings,
      renderSigV4Editor: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_aws_sdk__WEBPACK_IMPORTED_MODULE_1__.SIGV4ConnectionConfig, Object.assign({}, props))
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.AlertingSettings, {
      alertmanagerDataSources: alertmanagers,
      options: options,
      onOptionsChange: onOptionsChange
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_PromSettings__WEBPACK_IMPORTED_MODULE_7__.PromSettings, {
      options: options,
      onOptionsChange: onOptionsChange
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/ExemplarSetting.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ExemplarSetting)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-e2e-selectors/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








function ExemplarSetting({
  value,
  onChange,
  onDelete
}) {
  const [isInternalLink, setIsInternalLink] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Boolean(value.datasourceUid));
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: "gf-form-group",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
      label: "Internal link",
      labelWidth: 24,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineSwitch, {
          value: isInternalLink,
          "aria-label": _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_2__.selectors.components.DataSource.Prometheus.configPage.internalLinkSwitch,
          onChange: ev => setIsInternalLink(ev.currentTarget.checked)
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
          variant: "destructive",
          title: "Remove link",
          icon: "times",
          onClick: event => {
            event.preventDefault();
            onDelete();
          },
          className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
              margin-left: 8px;
            `
        })]
      })
    }), isInternalLink ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
      label: "Data source",
      labelWidth: 24,
      tooltip: "The data source the exemplar is going to navigate to.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.DataSourcePicker, {
        tracing: true,
        current: value.datasourceUid,
        noDefault: true,
        width: 40,
        onChange: ds => onChange(Object.assign({}, value, {
          datasourceUid: ds.uid,
          url: undefined
        }))
      })
    }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
      label: "URL",
      labelWidth: 24,
      tooltip: "The URL of the trace backend the user would go to see its trace.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Input, {
        placeholder: "https://example.com/${__value.raw}",
        spellCheck: false,
        width: 40,
        value: value.url,
        onChange: event => onChange(Object.assign({}, value, {
          datasourceUid: undefined,
          url: event.currentTarget.value
        }))
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
      label: "URL Label",
      labelWidth: 24,
      tooltip: "Use to override the button label on the exemplar traceID field.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Input, {
        placeholder: "Go to example.com",
        spellCheck: false,
        width: 40,
        value: value.urlDisplayLabel,
        onChange: event => onChange(Object.assign({}, value, {
          urlDisplayLabel: event.currentTarget.value
        }))
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
      label: "Label name",
      labelWidth: 24,
      tooltip: "The name of the field in the labels object that should be used to get the traceID.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Input, {
        placeholder: "traceID",
        spellCheck: false,
        width: 40,
        value: value.name,
        onChange: event => onChange(Object.assign({}, value, {
          name: event.currentTarget.value
        }))
      })
    })]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/ExemplarsSettings.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExemplarsSettings": () => (/* binding */ ExemplarsSettings)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-e2e-selectors/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _ExemplarSetting__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/ExemplarSetting.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;









function ExemplarsSettings({
  options,
  onChange
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("h3", {
      className: "page-heading",
      children: "Exemplars"
    })), options && options.map((option, index) => {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_ExemplarSetting__WEBPACK_IMPORTED_MODULE_4__["default"], {
        value: option,
        onChange: newField => {
          const newOptions = [...options];
          newOptions.splice(index, 1, newField);
          onChange(newOptions);
        },
        onDelete: () => {
          const newOptions = [...options];
          newOptions.splice(index, 1);
          onChange(newOptions);
        }
      }, index);
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
      variant: "secondary",
      "aria-label": _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_2__.selectors.components.DataSource.Prometheus.configPage.exemplarsAddButton,
      className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
          margin-bottom: 10px;
        `,
      icon: "plus",
      onClick: event => {
        event.preventDefault();
        const newOptions = [...(options || []), {
          name: 'traceID'
        }];
        onChange(newOptions);
      },
      children: "Add"
    })]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromSettings": () => (/* binding */ PromSettings),
/* harmony export */   "getValueFromEventItem": () => (/* binding */ getValueFromEventItem),
/* harmony export */   "promSettingsValidationEvents": () => (/* binding */ promSettingsValidationEvents)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _ExemplarsSettings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/ExemplarsSettings.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _h;








const {
  Select,
  Input,
  FormField
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_2__.LegacyForms;
const httpOptions = [{
  value: 'POST',
  label: 'POST'
}, {
  value: 'GET',
  label: 'GET'
}];
const PromSettings = props => {
  var _options$jsonData$dis;

  const {
    options,
    onOptionsChange
  } = props; // We are explicitly adding httpMethod so it is correctly displayed in dropdown. This way, it is more predictable for users.

  if (!options.jsonData.httpMethod) {
    options.jsonData.httpMethod = 'POST';
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: "gf-form-group",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
            label: "Scrape interval",
            labelWidth: 13,
            inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Input, {
              className: "width-6",
              value: options.jsonData.timeInterval,
              spellCheck: false,
              placeholder: "15s",
              onChange: onChangeHandler('timeInterval', options, onOptionsChange),
              validationEvents: promSettingsValidationEvents
            }),
            tooltip: "Set this to the typical scrape and evaluation interval configured in Prometheus. Defaults to 15s."
          })
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
            label: "Query timeout",
            labelWidth: 13,
            inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Input, {
              className: "width-6",
              value: options.jsonData.queryTimeout,
              onChange: onChangeHandler('queryTimeout', options, onOptionsChange),
              spellCheck: false,
              placeholder: "60s",
              validationEvents: promSettingsValidationEvents
            }),
            tooltip: "Set the Prometheus query timeout."
          })
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: "gf-form",
        children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFormLabel, {
          width: 13,
          tooltip: "You can use either POST or GET HTTP method to query your Prometheus data source. POST is the recommended method as it allows bigger queries. Change this to GET if you have a Prometheus version older than 2.1 or if POST requests are restricted in your network.",
          children: "HTTP Method"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Select, {
          "aria-label": "Select HTTP method",
          options: httpOptions,
          value: httpOptions.find(o => o.value === options.jsonData.httpMethod),
          onChange: onChangeHandler('httpMethod', options, onOptionsChange),
          width: 7
        })]
      })]
    }), _h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("h3", {
      className: "page-heading",
      children: "Misc"
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: "gf-form-group",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineField, {
          labelWidth: 28,
          label: "Disable metrics lookup",
          tooltip: "Checking this option will disable the metrics chooser and metric/label support in the query field's autocomplete. This helps if you have performance issues with bigger Prometheus instances.",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineSwitch, {
            value: (_options$jsonData$dis = options.jsonData.disableMetricsLookup) !== null && _options$jsonData$dis !== void 0 ? _options$jsonData$dis : false,
            onChange: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.onUpdateDatasourceJsonDataOptionChecked)(props, 'disableMetricsLookup')
          })
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: "gf-form max-width-30",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
            label: "Custom query parameters",
            labelWidth: 14,
            tooltip: "Add Custom parameters to all Prometheus or Thanos queries.",
            inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Input, {
              className: "width-25",
              value: options.jsonData.customQueryParameters,
              onChange: onChangeHandler('customQueryParameters', options, onOptionsChange),
              spellCheck: false,
              placeholder: "Example: max_source_resolution=5m&timeout=10"
            })
          })
        })
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_ExemplarsSettings__WEBPACK_IMPORTED_MODULE_3__.ExemplarsSettings, {
      options: options.jsonData.exemplarTraceIdDestinations,
      onChange: exemplarOptions => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.updateDatasourcePluginJsonDataOption)({
        onOptionsChange,
        options
      }, 'exemplarTraceIdDestinations', exemplarOptions)
    })]
  });
};
const promSettingsValidationEvents = {
  [_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.EventsWithValidation.onBlur]: [(0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.regexValidation)(/^$|^\d+(ms|[Mwdhmsy])$/, 'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s')]
};
const getValueFromEventItem = eventItem => {
  if (!eventItem) {
    return '';
  }

  if (eventItem.hasOwnProperty('currentTarget')) {
    return eventItem.currentTarget.value;
  }

  return eventItem.value;
};

const onChangeHandler = (key, options, onOptionsChange) => eventItem => {
  onOptionsChange(Object.assign({}, options, {
    jsonData: Object.assign({}, options.jsonData, {
      [key]: getValueFromEventItem(eventItem)
    })
  }));
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/datasource.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrometheusDatasource": () => (/* binding */ PrometheusDatasource),
/* harmony export */   "alignRange": () => (/* binding */ alignRange),
/* harmony export */   "extractRuleMappingFromGroups": () => (/* binding */ extractRuleMappingFromGroups),
/* harmony export */   "prometheusRegularEscape": () => (/* binding */ prometheusRegularEscape),
/* harmony export */   "prometheusSpecialRegexEscape": () => (/* binding */ prometheusSpecialRegexEscape)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.10.1-5af910d0ed-e8b190d71e.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/util/pipe.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/merge.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/throwError.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/tap.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/catchError.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_utils_explore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/core/utils/explore.ts");
/* harmony import */ var app_features_alerting_unified_api_buildInfo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/alerting/unified/api/buildInfo.ts");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
/* harmony import */ var app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/features/templating/template_srv.ts");
/* harmony import */ var app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/types/unified-alerting-dto.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/prometheus/add_label_to_query.ts");
/* harmony import */ var _components_AnnotationQueryEditor__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/AnnotationQueryEditor.tsx");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
/* harmony import */ var _metric_find_query__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./public/app/plugins/datasource/prometheus/metric_find_query.ts");
/* harmony import */ var _query_hints__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./public/app/plugins/datasource/prometheus/query_hints.ts");
/* harmony import */ var _result_transformer__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./public/app/plugins/datasource/prometheus/result_transformer.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _variables__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./public/app/plugins/datasource/prometheus/variables.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Badge, _Badge2, _Tooltip, _div, _div2;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



























const ANNOTATION_QUERY_STEP_DEFAULT = '60s';
const GET_AND_POST_METADATA_ENDPOINTS = ['api/v1/query', 'api/v1/query_range', 'api/v1/series', 'api/v1/labels'];
class PrometheusDatasource extends _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.DataSourceWithBackend {
  constructor(instanceSettings, templateSrv = (0,app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_9__.getTemplateSrv)(), timeSrv = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_8__.getTimeSrv)(), languageProvider) {
    var _instanceSettings$jso, _instanceSettings$jso2;

    super(instanceSettings);

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "editorSrc", void 0);

    _defineProperty(this, "ruleMappings", void 0);

    _defineProperty(this, "url", void 0);

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "directUrl", void 0);

    _defineProperty(this, "access", void 0);

    _defineProperty(this, "basicAuth", void 0);

    _defineProperty(this, "withCredentials", void 0);

    _defineProperty(this, "metricsNameCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "interval", void 0);

    _defineProperty(this, "queryTimeout", void 0);

    _defineProperty(this, "httpMethod", void 0);

    _defineProperty(this, "languageProvider", void 0);

    _defineProperty(this, "exemplarTraceIdDestinations", void 0);

    _defineProperty(this, "lookupsDisabled", void 0);

    _defineProperty(this, "customQueryParameters", void 0);

    _defineProperty(this, "exemplarsAvailable", void 0);

    _defineProperty(this, "subType", void 0);

    _defineProperty(this, "rulerEnabled", void 0);

    _defineProperty(this, "init", async () => {
      this.loadRules();
      this.exemplarsAvailable = await this.areExemplarsAvailable();
    });

    _defineProperty(this, "prepareTargets", (options, start, end) => {
      const queries = [];
      const activeTargets = [];
      const clonedTargets = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(options.targets);

      for (const target of clonedTargets) {
        if (!target.expr || target.hide) {
          continue;
        }

        target.requestId = options.panelId + target.refId;
        const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // In Explore, we run both (instant and range) queries if both are true (selected) or both are undefined (legacy Explore queries)

        if (options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore && target.range === target.instant) {
          // Create instant target
          const instantTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
          instantTarget.format = 'table';
          instantTarget.instant = true;
          instantTarget.range = false;
          instantTarget.valueWithRefId = true;
          delete instantTarget.maxDataPoints;
          instantTarget.requestId += '_instant'; // Create range target

          const rangeTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
          rangeTarget.format = 'time_series';
          rangeTarget.instant = false;
          instantTarget.range = true; // Create exemplar query

          if (target.exemplar) {
            // Only create exemplar target for different metric names
            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {
              const exemplarTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
              exemplarTarget.instant = false;
              exemplarTarget.requestId += '_exemplar';
              queries.push(this.createQuery(exemplarTarget, options, start, end));
              activeTargets.push(exemplarTarget);
            }

            instantTarget.exemplar = false;
            rangeTarget.exemplar = false;
          } // Add both targets to activeTargets and queries arrays


          activeTargets.push(instantTarget, rangeTarget);
          queries.push(this.createQuery(instantTarget, options, start, end), this.createQuery(rangeTarget, options, start, end)); // If running only instant query in Explore, format as table
        } else if (target.instant && options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore) {
          const instantTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
          instantTarget.format = 'table';
          queries.push(this.createQuery(instantTarget, options, start, end));
          activeTargets.push(instantTarget);
        } else {
          // It doesn't make sense to query for exemplars in dashboard if only instant is selected
          if (target.exemplar && !target.instant) {
            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {
              const exemplarTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
              exemplarTarget.requestId += '_exemplar';
              queries.push(this.createQuery(exemplarTarget, options, start, end));
              activeTargets.push(exemplarTarget);
            }

            target.exemplar = false;
          }

          queries.push(this.createQuery(target, options, start, end));
          activeTargets.push(target);
        }
      }

      return {
        queries,
        activeTargets
      };
    });

    _defineProperty(this, "handleErrors", (err, target) => {
      const error = {
        message: err && err.statusText || 'Unknown error during query transaction. Please check JS console logs.',
        refId: target.refId
      };

      if (err.data) {
        if (typeof err.data === 'string') {
          error.message = err.data;
        } else if (err.data.error) {
          error.message = (0,app_core_utils_explore__WEBPACK_IMPORTED_MODULE_6__.safeStringifyValue)(err.data.error);
        }
      } else if (err.message) {
        error.message = err.message;
      } else if (typeof err === 'string') {
        error.message = err;
      }

      error.status = err.status;
      error.statusText = err.statusText;
      return error;
    });

    _defineProperty(this, "processAnnotationResponse", (options, data) => {
      const frames = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.toDataQueryResponse)({
        data: data
      }).data;

      if (!frames || !frames.length) {
        return [];
      }

      const annotation = options.annotation;
      const {
        tagKeys = '',
        titleFormat = '',
        textFormat = ''
      } = annotation;
      const step = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(annotation.step || ANNOTATION_QUERY_STEP_DEFAULT) * 1000;
      const tagKeysArray = tagKeys.split(',');
      const eventList = [];

      for (const frame of frames) {
        const timeField = frame.fields[0];
        const valueField = frame.fields[1];
        const labels = (valueField === null || valueField === void 0 ? void 0 : valueField.labels) || {};
        const tags = Object.keys(labels).filter(label => tagKeysArray.includes(label)).map(label => labels[label]);
        const timeValueTuple = [];
        let idx = 0;
        valueField.values.toArray().forEach(value => {
          let timeStampValue;
          let valueValue;
          const time = timeField.values.get(idx); // If we want to use value as a time, we use value as timeStampValue and valueValue will be 1

          if (options.annotation.useValueForTime) {
            timeStampValue = Math.floor(parseFloat(value));
            valueValue = 1;
          } else {
            timeStampValue = Math.floor(parseFloat(time));
            valueValue = parseFloat(value);
          }

          idx++;
          timeValueTuple.push([timeStampValue, valueValue]);
        });
        const activeValues = timeValueTuple.filter(value => value[1] >= 1);
        const activeValuesTimestamps = activeValues.map(value => value[0]); // Instead of creating singular annotation for each active event we group events into region if they are less
        // or equal to `step` apart.

        let latestEvent = null;

        for (const timestamp of activeValuesTimestamps) {
          var _latestEvent$timeEnd;

          // We already have event `open` and we have new event that is inside the `step` so we just update the end.
          if (latestEvent && ((_latestEvent$timeEnd = latestEvent.timeEnd) !== null && _latestEvent$timeEnd !== void 0 ? _latestEvent$timeEnd : 0) + step >= timestamp) {
            latestEvent.timeEnd = timestamp;
            continue;
          } // Event exists but new one is outside of the `step` so we add it to eventList.


          if (latestEvent) {
            eventList.push(latestEvent);
          } // We start a new region.


          latestEvent = {
            time: timestamp,
            timeEnd: timestamp,
            annotation,
            title: (0,_legend__WEBPACK_IMPORTED_MODULE_15__.renderLegendFormat)(titleFormat, labels),
            tags,
            text: (0,_legend__WEBPACK_IMPORTED_MODULE_15__.renderLegendFormat)(textFormat, labels)
          };
        }

        if (latestEvent) {
          // Finish up last point if we have one
          latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];
          eventList.push(latestEvent);
        }
      }

      return eventList;
    });

    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.type = 'prometheus';
    this.subType = app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus;
    this.rulerEnabled = false;
    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';
    this.id = instanceSettings.id;
    this.url = instanceSettings.url;
    this.access = instanceSettings.access;
    this.basicAuth = instanceSettings.basicAuth;
    this.withCredentials = instanceSettings.withCredentials;
    this.interval = instanceSettings.jsonData.timeInterval || '15s';
    this.queryTimeout = instanceSettings.jsonData.queryTimeout;
    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET'; // `directUrl` is never undefined, we set it at https://github.com/grafana/grafana/blob/main/pkg/api/frontendsettings.go#L108
    // here we "fall back" to this.url to make typescript happy, but it should never happen

    this.directUrl = (_instanceSettings$jso = instanceSettings.jsonData.directUrl) !== null && _instanceSettings$jso !== void 0 ? _instanceSettings$jso : this.url;
    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;
    this.ruleMappings = {};
    this.languageProvider = languageProvider !== null && languageProvider !== void 0 ? languageProvider : new _language_provider__WEBPACK_IMPORTED_MODULE_13__["default"](this);
    this.lookupsDisabled = (_instanceSettings$jso2 = instanceSettings.jsonData.disableMetricsLookup) !== null && _instanceSettings$jso2 !== void 0 ? _instanceSettings$jso2 : false;
    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);
    this.variables = new _variables__WEBPACK_IMPORTED_MODULE_20__.PrometheusVariableSupport(this, this.templateSrv, this.timeSrv);
    this.exemplarsAvailable = true; // This needs to be here and cannot be static because of how annotations typing affects casting of data source
    // objects to DataSourceApi types.
    // We don't use the default processing for prometheus.
    // See standardAnnotationSupport.ts/[shouldUseMappingUI|shouldUseLegacyRunner]

    this.annotations = {
      QueryEditor: _components_AnnotationQueryEditor__WEBPACK_IMPORTED_MODULE_12__.AnnotationQueryEditor
    };
  }

  getQueryDisplayText(query) {
    return query.expr;
  }

  _addTracingHeaders(httpOptions, options) {
    httpOptions.headers = {};
    const proxyMode = !this.url.match(/^http/);

    if (proxyMode) {
      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;
      httpOptions.headers['X-Panel-Id'] = options.panelId;
    }
  }
  /**
   * Any request done from this data source should go through here as it contains some common processing for the
   * request. Any processing done here needs to be also copied on the backend as this goes through data source proxy
   * but not through the same code as alerting.
   */


  _request(url, data, overrides = {}) {
    data = data || {};

    for (const [key, value] of this.customQueryParameters) {
      if (data[key] == null) {
        data[key] = value;
      }
    }

    let queryUrl = this.url + url;

    if (url.startsWith(`/api/datasources/${this.id}`)) {
      // This url is meant to be a replacement for the whole URL. Replace the entire URL
      queryUrl = url;
    }

    const options = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.defaults)(overrides, {
      url: queryUrl,
      method: this.httpMethod,
      headers: {}
    });

    if (options.method === 'GET') {
      if (data && Object.keys(data).length) {
        options.url = options.url + (options.url.search(/\?/) >= 0 ? '&' : '?') + Object.entries(data).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');
      }
    } else {
      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
      options.data = data;
    }

    if (this.basicAuth || this.withCredentials) {
      options.withCredentials = true;
    }

    if (this.basicAuth) {
      options.headers.Authorization = this.basicAuth;
    }

    return (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().fetch(options);
  }

  async importFromAbstractQueries(abstractQueries) {
    return abstractQueries.map(abstractQuery => this.languageProvider.importFromAbstractQuery(abstractQuery));
  }

  async exportToAbstractQueries(queries) {
    return queries.map(query => this.languageProvider.exportToAbstractQuery(query));
  } // Use this for tab completion features, wont publish response to other components


  async metadataRequest(url, params = {}) {
    // If URL includes endpoint that supports POST and GET method, try to use configured method. This might fail as POST is supported only in v2.10+.
    if (GET_AND_POST_METADATA_ENDPOINTS.some(endpoint => url.includes(endpoint))) {
      try {
        return await (0,rxjs__WEBPACK_IMPORTED_MODULE_22__.lastValueFrom)(this._request(`/api/datasources/${this.id}/resources${url}`, params, {
          method: this.httpMethod,
          hideFromInspector: true,
          showErrorAlert: false
        }));
      } catch (err) {
        // If status code of error is Method Not Allowed (405) and HTTP method is POST, retry with GET
        if (this.httpMethod === 'POST' && (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.isFetchError)(err) && (err.status === 405 || err.status === 400)) {
          console.warn(`Couldn't use configured POST HTTP method for this request. Trying to use GET method instead.`);
        } else {
          throw err;
        }
      }
    }

    return await (0,rxjs__WEBPACK_IMPORTED_MODULE_22__.lastValueFrom)(this._request(`/api/datasources/${this.id}/resources${url}`, params, {
      method: 'GET',
      hideFromInspector: true
    })); // toPromise until we change getTagValues, getTagKeys to Observable
  }

  interpolateQueryExpr(value = [], variable) {
    // if no multi or include all do not regexEscape
    if (!variable.multi && !variable.includeAll) {
      return prometheusRegularEscape(value);
    }

    if (typeof value === 'string') {
      return prometheusSpecialRegexEscape(value);
    }

    const escapedValues = value.map(val => prometheusSpecialRegexEscape(val));

    if (escapedValues.length === 1) {
      return escapedValues[0];
    }

    return '(' + escapedValues.join('|') + ')';
  }

  targetContainsTemplate(target) {
    return this.templateSrv.containsTemplate(target.expr);
  }

  shouldRunExemplarQuery(target, request) {
    if (target.exemplar) {
      // We check all already processed targets and only create exemplar target for not used metric names
      const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // Remove targets that weren't processed yet (in targets array they are after current target)

      const currentTargetIdx = request.targets.findIndex(t => t.refId === target.refId);
      const targets = request.targets.slice(0, currentTargetIdx).filter(t => !t.hide);

      if (!metricName || metricName && !targets.some(t => t.expr.includes(metricName))) {
        return true;
      }

      return false;
    }

    return false;
  }

  processTargetV2(target, request) {
    const processedTarget = Object.assign({}, target, {
      queryType: _types__WEBPACK_IMPORTED_MODULE_19__.PromQueryType.timeSeriesQuery,
      exemplar: this.shouldRunExemplarQuery(target, request),
      requestId: request.panelId + target.refId,
      // We need to pass utcOffsetSec to backend to calculate aligned range
      utcOffsetSec: this.timeSrv.timeRange().to.utcOffset() * 60
    });
    return processedTarget;
  }

  query(request) {
    if (this.access === 'proxy') {
      const targets = request.targets.map(target => this.processTargetV2(target, request));
      return super.query(Object.assign({}, request, {
        targets
      })).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.map)(response => (0,_result_transformer__WEBPACK_IMPORTED_MODULE_18__.transformV2)(response, request, {
        exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
      }))); // Run queries trough browser/proxy
    } else {
      const start = this.getPrometheusTime(request.range.from, false);
      const end = this.getPrometheusTime(request.range.to, true);
      const {
        queries,
        activeTargets
      } = this.prepareTargets(request, start, end); // No valid targets, return the empty result to save a round trip.

      if (!queries || !queries.length) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.of)({
          data: [],
          state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
        });
      }

      if (request.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore) {
        return this.exploreQuery(queries, activeTargets, end);
      }

      return this.panelsQuery(queries, activeTargets, end, request.requestId, request.scopedVars);
    }
  }

  exploreQuery(queries, activeTargets, end) {
    let runningQueriesCount = queries.length;
    const subQueries = queries.map((query, index) => {
      const target = activeTargets[index];
      const filterAndMapResponse = (0,rxjs__WEBPACK_IMPORTED_MODULE_25__.pipe)( // Decrease the counter here. We assume that each request returns only single value and then completes
      // (should hold until there is some streaming requests involved).
      (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.tap)(() => runningQueriesCount--), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.filter)(response => response.cancelled ? false : true), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.map)(response => {
        const data = (0,_result_transformer__WEBPACK_IMPORTED_MODULE_18__.transform)(response, {
          query,
          target,
          responseListLength: queries.length,
          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
        });
        return {
          data,
          key: query.requestId,
          state: runningQueriesCount === 0 ? _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done : _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Loading
        };
      }));
      return this.runQuery(query, end, filterAndMapResponse);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_28__.merge)(...subQueries);
  }

  panelsQuery(queries, activeTargets, end, requestId, scopedVars) {
    const observables = queries.map((query, index) => {
      const target = activeTargets[index];
      const filterAndMapResponse = (0,rxjs__WEBPACK_IMPORTED_MODULE_25__.pipe)((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_27__.filter)(response => response.cancelled ? false : true), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.map)(response => {
        const data = (0,_result_transformer__WEBPACK_IMPORTED_MODULE_18__.transform)(response, {
          query,
          target,
          responseListLength: queries.length,
          scopedVars,
          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
        });
        return data;
      }));
      return this.runQuery(query, end, filterAndMapResponse);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_29__.forkJoin)(observables).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.map)(results => {
      const data = results.reduce((result, current) => {
        return [...result, ...current];
      }, []);
      return {
        data,
        key: requestId,
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
      };
    }));
  }

  runQuery(query, end, filter) {
    if (query.instant) {
      return this.performInstantQuery(query, end).pipe(filter);
    }

    if (query.exemplar) {
      return this.getExemplars(query).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.catchError)(() => {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.of)({
          data: [],
          state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
        });
      }), filter);
    }

    return this.performTimeSeriesQuery(query, query.start, query.end).pipe(filter);
  }

  createQuery(target, options, start, end) {
    const query = {
      hinting: target.hinting,
      instant: target.instant,
      exemplar: target.exemplar,
      step: 0,
      expr: '',
      requestId: target.requestId,
      refId: target.refId,
      start: 0,
      end: 0
    };
    const range = Math.ceil(end - start); // options.interval is the dynamically calculated interval

    let interval = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(options.interval); // Minimum interval ("Min step"), if specified for the query, or same as interval otherwise.

    const minInterval = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval || options.interval, options.scopedVars)); // Scrape interval as specified for the query ("Min step") or otherwise taken from the datasource.
    // Min step field can have template variables in it, make sure to replace it.

    const scrapeInterval = target.interval ? _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval, options.scopedVars)) : _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.interval);
    const intervalFactor = target.intervalFactor || 1; // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits

    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);
    let scopedVars = Object.assign({}, options.scopedVars, this.getRangeScopedVars(options.range), this.getRateIntervalScopedVariable(adjustedInterval, scrapeInterval)); // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars

    if (interval !== adjustedInterval) {
      interval = adjustedInterval;
      scopedVars = Object.assign({}, options.scopedVars, Object.assign({
        __interval: {
          text: interval + 's',
          value: interval + 's'
        },
        __interval_ms: {
          text: interval * 1000,
          value: interval * 1000
        }
      }, this.getRateIntervalScopedVariable(interval, scrapeInterval), this.getRangeScopedVars(options.range)));
    }

    query.step = interval;
    let expr = target.expr; // Apply adhoc filters

    expr = this.enhanceExprWithAdHocFilters(expr); // Only replace vars in expression after having (possibly) updated interval vars

    query.expr = this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr); // Align query interval with step to allow query caching and to ensure
    // that about-same-time query results look the same.

    const adjusted = alignRange(start, end, query.step, this.timeSrv.timeRange().to.utcOffset() * 60);
    query.start = adjusted.start;
    query.end = adjusted.end;

    this._addTracingHeaders(query, options);

    return query;
  }

  getRateIntervalScopedVariable(interval, scrapeInterval) {
    // Fall back to the default scrape interval of 15s if scrapeInterval is 0 for some reason.
    if (scrapeInterval === 0) {
      scrapeInterval = 15;
    }

    const rateInterval = Math.max(interval + scrapeInterval, 4 * scrapeInterval);
    return {
      __rate_interval: {
        text: rateInterval + 's',
        value: rateInterval + 's'
      }
    };
  }

  adjustInterval(interval, minInterval, range, intervalFactor) {
    // Prometheus will drop queries that might return more than 11000 data points.
    // Calculate a safe interval as an additional minimum to take into account.
    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1
    // If this is the case take the ceil of the value.
    let safeInterval = range / 11000;

    if (safeInterval > 1) {
      safeInterval = Math.ceil(safeInterval);
    }

    return Math.max(interval * intervalFactor, minInterval, safeInterval);
  }

  performTimeSeriesQuery(query, start, end) {
    if (start > end) {
      throw {
        message: 'Invalid time range'
      };
    }

    const url = '/api/v1/query_range';
    const data = {
      query: query.expr,
      start,
      end,
      step: query.step
    };

    if (this.queryTimeout) {
      data['timeout'] = this.queryTimeout;
    }

    return this._request(url, data, {
      requestId: query.requestId,
      headers: query.headers
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.catchError)(err => {
      if (err.cancelled) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.of)(err);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_31__.throwError)(this.handleErrors(err, query));
    }));
  }

  performInstantQuery(query, time) {
    const url = '/api/v1/query';
    const data = {
      query: query.expr,
      time
    };

    if (this.queryTimeout) {
      data['timeout'] = this.queryTimeout;
    }

    return this._request(url, data, {
      requestId: query.requestId,
      headers: query.headers
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_30__.catchError)(err => {
      if (err.cancelled) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.of)(err);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_31__.throwError)(this.handleErrors(err, query));
    }));
  }

  metricFindQuery(query) {
    if (!query) {
      return Promise.resolve([]);
    }

    const scopedVars = Object.assign({
      __interval: {
        text: this.interval,
        value: this.interval
      },
      __interval_ms: {
        text: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToMs(this.interval),
        value: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToMs(this.interval)
      }
    }, this.getRangeScopedVars(this.timeSrv.timeRange()));
    const interpolated = this.templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);
    const metricFindQuery = new _metric_find_query__WEBPACK_IMPORTED_MODULE_16__["default"](this, interpolated);
    return metricFindQuery.process();
  }

  getRangeScopedVars(range = this.timeSrv.timeRange()) {
    const msRange = range.to.diff(range.from);
    const sRange = Math.round(msRange / 1000);
    return {
      __range_ms: {
        text: msRange,
        value: msRange
      },
      __range_s: {
        text: sRange,
        value: sRange
      },
      __range: {
        text: sRange + 's',
        value: sRange + 's'
      }
    };
  }

  async annotationQuery(options) {
    const annotation = options.annotation;
    const {
      expr = ''
    } = annotation;

    if (!expr) {
      return Promise.resolve([]);
    }

    const step = options.annotation.step || ANNOTATION_QUERY_STEP_DEFAULT;
    const queryModel = {
      expr,
      range: true,
      instant: false,
      exemplar: false,
      interval: step,
      queryType: _types__WEBPACK_IMPORTED_MODULE_19__.PromQueryType.timeSeriesQuery,
      refId: 'X',
      datasource: this.getRef()
    };
    return await (0,rxjs__WEBPACK_IMPORTED_MODULE_22__.lastValueFrom)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().fetch({
      url: '/api/ds/query',
      method: 'POST',
      data: {
        from: (this.getPrometheusTime(options.range.from, false) * 1000).toString(),
        to: (this.getPrometheusTime(options.range.to, true) * 1000).toString(),
        queries: [this.applyTemplateVariables(queryModel, {})]
      },
      requestId: `prom-query-${annotation.name}`
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.map)(rsp => {
      return this.processAnnotationResponse(options, rsp.data);
    })));
  }

  getExemplars(query) {
    const url = '/api/v1/query_exemplars';
    return this._request(url, {
      query: query.expr,
      start: query.start.toString(),
      end: query.end.toString()
    }, {
      requestId: query.requestId,
      headers: query.headers
    });
  }

  async getSubtitle() {
    const buildInfo = await this.getBuildInfo();
    return buildInfo ? this.getBuildInfoMessage(buildInfo) : null;
  }

  async getTagKeys(options) {
    if (options !== null && options !== void 0 && options.series) {
      // Get tags for the provided series only
      const seriesLabels = await Promise.all(options.series.map(series => this.languageProvider.fetchSeriesLabels(series))); // Combines tags from all options.series provided

      let tags = [];
      seriesLabels.map(value => tags = tags.concat(Object.keys(value)));
      const uniqueLabels = [...new Set(tags)];
      return uniqueLabels.map(value => ({
        text: value
      }));
    } else {
      var _result$data$data$map, _result$data, _result$data$data;

      // Get all tags
      const result = await this.metadataRequest('/api/v1/labels');
      return (_result$data$data$map = result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : (_result$data$data = _result$data.data) === null || _result$data$data === void 0 ? void 0 : _result$data$data.map(value => ({
        text: value
      }))) !== null && _result$data$data$map !== void 0 ? _result$data$data$map : [];
    }
  }

  async getTagValues(options = {}) {
    var _result$data$data$map2, _result$data2, _result$data2$data;

    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);
    return (_result$data$data$map2 = result === null || result === void 0 ? void 0 : (_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : (_result$data2$data = _result$data2.data) === null || _result$data2$data === void 0 ? void 0 : _result$data2$data.map(value => ({
      text: value
    }))) !== null && _result$data$data$map2 !== void 0 ? _result$data$data$map2 : [];
  }

  async getBuildInfo() {
    try {
      const buildInfo = await (0,app_features_alerting_unified_api_buildInfo__WEBPACK_IMPORTED_MODULE_7__.discoverDataSourceFeatures)({
        url: this.url,
        name: this.name,
        type: 'prometheus'
      });
      return buildInfo;
    } catch (error) {
      // We don't want to break the rest of functionality if build info does not work correctly
      return undefined;
    }
  }

  getBuildInfoMessage(buildInfo) {
    var _buildInfo$applicatio, _buildInfo$applicatio2;

    const enabled = _Badge || (_Badge = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
      color: "green",
      icon: "check",
      text: "Ruler API enabled"
    }));

    const disabled = _Badge2 || (_Badge2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
      color: "orange",
      icon: "exclamation-triangle",
      text: "Ruler API not enabled"
    }));

    const unsupported = _Tooltip || (_Tooltip = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Tooltip, {
      placement: "top",
      content: "Prometheus does not allow editing rules, connect to either a Mimir or Cortex datasource to manage alerts via Grafana.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)("div", {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
          color: "red",
          icon: "exclamation-triangle",
          text: "Ruler API not supported"
        })
      })
    }));

    const LOGOS = {
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Lotex]: '/public/app/plugins/datasource/prometheus/img/cortex_logo.svg',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Mimir]: '/public/app/plugins/datasource/prometheus/img/mimir_logo.svg',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]: '/public/app/plugins/datasource/prometheus/img/prometheus_logo.svg'
    };
    const COLORS = {
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Lotex]: 'blue',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Mimir]: 'orange',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]: 'red'
    };
    const AppDisplayNames = {
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Lotex]: 'Cortex',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Mimir]: 'Mimir',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]: 'Prometheus'
    }; // this will inform the user about what "subtype" the datasource is; Mimir, Cortex or vanilla Prometheus

    const applicationSubType = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
      text: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsxs)("span", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)("img", {
          style: {
            width: 14,
            height: 14,
            verticalAlign: 'text-bottom'
          },
          src: LOGOS[(_buildInfo$applicatio = buildInfo.application) !== null && _buildInfo$applicatio !== void 0 ? _buildInfo$applicatio : app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]
        }), ' ', buildInfo.application ? AppDisplayNames[buildInfo.application] : 'Unknown']
      }),
      color: COLORS[(_buildInfo$applicatio2 = buildInfo.application) !== null && _buildInfo$applicatio2 !== void 0 ? _buildInfo$applicatio2 : app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]
    });

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsxs)("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'max-content max-content',
        rowGap: '0.5rem',
        columnGap: '2rem',
        marginTop: '1rem'
      },
      children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)("div", {
        children: "Type"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)("div", {
        children: applicationSubType
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.Fragment, {
        children: [_div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)("div", {
          children: "Ruler API"
        })), buildInfo.application === app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)("div", {
          children: unsupported
        }), buildInfo.application !== app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_21__.jsx)("div", {
          children: buildInfo.features.rulerApiEnabled ? enabled : disabled
        })]
      })]
    });
  }

  async testDatasource() {
    const now = new Date().getTime();
    const request = {
      targets: [{
        refId: 'test',
        expr: '1+1',
        instant: true
      }],
      requestId: `${this.id}-health`,
      scopedVars: {},
      dashboardId: 0,
      panelId: 0,
      interval: '1m',
      intervalMs: 60000,
      maxDataPoints: 1,
      range: {
        from: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(now - 1000),
        to: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(now)
      }
    };
    const buildInfo = await this.getBuildInfo();
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_22__.lastValueFrom)(this.query(request)).then(res => {
      if (!res || !res.data || res.state !== _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done) {
        var _res$error;

        return {
          status: 'error',
          message: `Error reading Prometheus: ${res === null || res === void 0 ? void 0 : (_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message}`
        };
      } else {
        return {
          status: 'success',
          message: 'Data source is working',
          details: buildInfo && {
            verboseMessage: this.getBuildInfoMessage(buildInfo)
          }
        };
      }
    }).catch(err => {
      console.error('Prometheus Error', err);
      return {
        status: 'error',
        message: err.message
      };
    });
  }

  interpolateVariablesInQueries(queries, scopedVars) {
    let expandedQueries = queries;

    if (queries && queries.length) {
      expandedQueries = queries.map(query => {
        const expandedQuery = Object.assign({}, query, {
          datasource: this.getRef(),
          expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),
          interval: this.templateSrv.replace(query.interval, scopedVars)
        });
        return expandedQuery;
      });
    }

    return expandedQueries;
  }

  getQueryHints(query, result) {
    var _query$expr;

    return (0,_query_hints__WEBPACK_IMPORTED_MODULE_17__.getQueryHints)((_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : '', result, this);
  }

  getInitHints() {
    return (0,_query_hints__WEBPACK_IMPORTED_MODULE_17__.getInitHints)(this);
  }

  async loadRules() {
    try {
      var _res$data, _res$data$data;

      const res = await this.metadataRequest('/api/v1/rules');
      const groups = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : (_res$data$data = _res$data.data) === null || _res$data$data === void 0 ? void 0 : _res$data$data.groups;

      if (groups) {
        this.ruleMappings = extractRuleMappingFromGroups(groups);
      }
    } catch (e) {
      console.log('Rules API is experimental. Ignore next error.');
      console.error(e);
    }
  }

  async areExemplarsAvailable() {
    try {
      const res = await this.getResource('/api/v1/query_exemplars', {
        query: 'test',
        start: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)().subtract(30, 'minutes').valueOf(),
        end: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)().valueOf()
      });

      if (res.data.status === 'success') {
        return true;
      }

      return false;
    } catch (err) {
      return false;
    }
  }

  modifyQuery(query, action) {
    var _query$expr2;

    let expression = (_query$expr2 = query.expr) !== null && _query$expr2 !== void 0 ? _query$expr2 : '';

    switch (action.type) {
      case 'ADD_FILTER':
        {
          expression = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_11__.addLabelToQuery)(expression, action.key, action.value);
          break;
        }

      case 'ADD_FILTER_OUT':
        {
          expression = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_11__.addLabelToQuery)(expression, action.key, action.value, '!=');
          break;
        }

      case 'ADD_HISTOGRAM_QUANTILE':
        {
          expression = `histogram_quantile(0.95, sum(rate(${expression}[$__rate_interval])) by (le))`;
          break;
        }

      case 'ADD_RATE':
        {
          expression = `rate(${expression}[$__rate_interval])`;
          break;
        }

      case 'ADD_SUM':
        {
          expression = `sum(${expression.trim()}) by ($1)`;
          break;
        }

      case 'EXPAND_RULES':
        {
          if (action.mapping) {
            expression = (0,_language_utils__WEBPACK_IMPORTED_MODULE_14__.expandRecordingRules)(expression, action.mapping);
          }

          break;
        }

      default:
        break;
    }

    return Object.assign({}, query, {
      expr: expression
    });
  }

  getPrometheusTime(date, roundUp) {
    if (typeof date === 'string') {
      date = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateMath.parse(date, roundUp);
    }

    return Math.ceil(date.valueOf() / 1000);
  }

  getTimeRangeParams() {
    const range = this.timeSrv.timeRange();
    return {
      start: this.getPrometheusTime(range.from, false).toString(),
      end: this.getPrometheusTime(range.to, true).toString()
    };
  }

  getOriginalMetricName(labelData) {
    return (0,_result_transformer__WEBPACK_IMPORTED_MODULE_18__.getOriginalMetricName)(labelData);
  }

  enhanceExprWithAdHocFilters(expr) {
    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);
    const finalQuery = adhocFilters.reduce((acc, filter) => {
      const {
        key,
        operator
      } = filter;
      let {
        value
      } = filter;

      if (operator === '=~' || operator === '!~') {
        value = prometheusRegularEscape(value);
      }

      return (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_11__.addLabelToQuery)(acc, key, value, operator);
    }, expr);
    return finalQuery;
  } // Used when running queries trough backend


  filterQuery(query) {
    if (query.hide || !query.expr) {
      return false;
    }

    return true;
  } // Used when running queries trough backend


  applyTemplateVariables(target, scopedVars) {
    const variables = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(scopedVars); // We want to interpolate these variables on backend

    delete variables.__interval;
    delete variables.__interval_ms; //Add ad hoc filters

    const expr = this.enhanceExprWithAdHocFilters(target.expr);
    return Object.assign({}, target, {
      legendFormat: this.templateSrv.replace(target.legendFormat, variables),
      expr: this.templateSrv.replace(expr, variables, this.interpolateQueryExpr),
      interval: this.templateSrv.replace(target.interval, variables)
    });
  }

  getVariables() {
    return this.templateSrv.getVariables().map(v => `$${v.name}`);
  }

  interpolateString(string) {
    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);
  }

}
/**
 * Align query range to step.
 * Rounds start and end down to a multiple of step.
 * @param start Timestamp marking the beginning of the range.
 * @param end Timestamp marking the end of the range.
 * @param step Interval to align start and end with.
 * @param utcOffsetSec Number of seconds current timezone is offset from UTC
 */

function alignRange(start, end, step, utcOffsetSec) {
  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;
  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;
  return {
    end: alignedEnd,
    start: alignedStart
  };
}
function extractRuleMappingFromGroups(groups) {
  return groups.reduce((mapping, group) => group.rules.filter(rule => rule.type === 'recording').reduce((acc, rule) => Object.assign({}, acc, {
    [rule.name]: rule.query
  }), mapping), {});
} // NOTE: these two functions are very similar to the escapeLabelValueIn* functions
// in language_utils.ts, but they are not exactly the same algorithm, and we found
// no way to reuse one in the another or vice versa.

function prometheusRegularEscape(value) {
  return typeof value === 'string' ? value.replace(/\\/g, '\\\\').replace(/'/g, "\\\\'") : value;
}
function prometheusSpecialRegexEscape(value) {
  return typeof value === 'string' ? value.replace(/\\/g, '\\\\\\\\').replace(/[$^*{}\[\]\'+?.()|]/g, '\\\\$&') : value;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_provider.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUGGESTIONS_LIMIT": () => (/* binding */ SUGGESTIONS_LIMIT),
/* harmony export */   "addHistoryMetadata": () => (/* binding */ addHistoryMetadata),
/* harmony export */   "default": () => (/* binding */ PromQlLanguageProvider),
/* harmony export */   "getMetadataString": () => (/* binding */ getMetadataString)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.10.1-5af910d0ed-e8b190d71e.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.28.0-28f20a79ff-bde93fb2be.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const DEFAULT_KEYS = ['job', 'instance'];
const EMPTY_SELECTOR = '{}';
const HISTORY_ITEM_COUNT = 5;
const HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h
// Max number of items (metrics, labels, values) that we display as suggestions. Prevents from running out of memory.

const SUGGESTIONS_LIMIT = 10000;

const wrapLabel = label => ({
  label
});

const setFunctionKind = suggestion => {
  suggestion.kind = 'function';
  return suggestion;
};

function addHistoryMetadata(item, history) {
  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;
  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);
  const count = historyForItem.length;
  const recent = historyForItem[0];
  let hint = `Queried ${count} times in the last 24h.`;

  if (recent) {
    const lastQueried = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(recent.ts).fromNow();
    hint = `${hint} Last queried ${lastQueried}.`;
  }

  return Object.assign({}, item, {
    documentation: hint
  });
}

function addMetricsMetadata(metric, metadata) {
  const item = {
    label: metric
  };

  if (metadata && metadata[metric]) {
    item.documentation = getMetadataString(metric, metadata);
  }

  return item;
}

function getMetadataString(metric, metadata) {
  if (!metadata[metric]) {
    return undefined;
  }

  const {
    type,
    help
  } = metadata[metric];
  return `${type.toUpperCase()}: ${help}`;
}
const PREFIX_DELIMITER_REGEX = /(="|!="|=~"|!~"|\{|\[|\(|\+|-|\/|\*|%|\^|\band\b|\bor\b|\bunless\b|==|>=|!=|<=|>|<|=|~|,)/;
class PromQlLanguageProvider extends _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LanguageProvider {
  /**
   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does
   *  not account for different size of a response. If that is needed a `length` function can be added in the options.
   *  10 as a max size is totally arbitrary right now.
   */
  constructor(datasource, initialValues) {
    super();

    _defineProperty(this, "histogramMetrics", void 0);

    _defineProperty(this, "timeRange", void 0);

    _defineProperty(this, "metrics", void 0);

    _defineProperty(this, "metricsMetadata", void 0);

    _defineProperty(this, "datasource", void 0);

    _defineProperty(this, "labelKeys", []);

    _defineProperty(this, "labelsCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "request", async (url, defaultValue, params = {}) => {
      try {
        const res = await this.datasource.metadataRequest(url, params);
        return res.data.data;
      } catch (error) {
        console.error(error);
      }

      return defaultValue;
    });

    _defineProperty(this, "start", async () => {
      if (this.datasource.lookupsDisabled) {
        return [];
      } // TODO #33976: make those requests parallel


      await this.fetchLabels();
      this.metrics = (await this.fetchLabelValues('__name__')) || [];
      await this.loadMetricsMetadata();
      this.histogramMetrics = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processHistogramMetrics)(this.metrics).sort();
      return [];
    });

    _defineProperty(this, "provideCompletionItems", async ({
      prefix,
      text,
      value,
      labelKey,
      wrapperClasses
    }, context = {}) => {
      const emptyResult = {
        suggestions: []
      };

      if (!value) {
        return emptyResult;
      } // Local text properties


      const empty = value.document.text.length === 0;
      const selectedLines = value.document.getTextsAtRange(value.selection);
      const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;
      const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null; // Syntax spans have 3 classes by default. More indicate a recognized token

      const tokenRecognized = wrapperClasses.length > 3; // Non-empty prefix, but not inside known token

      const prefixUnrecognized = prefix && !tokenRecognized; // Prevent suggestions in `function(|suffix)`

      const noSuffix = !nextCharacter || nextCharacter === ')'; // Prefix is safe if it does not immediately follow a complete expression and has no text after it

      const safePrefix = prefix && !text.match(/^[\]})\s]+$/) && noSuffix; // About to type next operand if preceded by binary operator

      const operatorsPattern = /[+\-*/^%]/;
      const isNextOperand = text.match(operatorsPattern); // Determine candidates by CSS context

      if (wrapperClasses.includes('context-range')) {
        // Suggestions for metric[|]
        return this.getRangeCompletionItems();
      } else if (wrapperClasses.includes('context-labels')) {
        // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}
        return this.getLabelCompletionItems({
          prefix,
          text,
          value,
          labelKey,
          wrapperClasses
        });
      } else if (wrapperClasses.includes('context-aggregation')) {
        // Suggestions for sum(metric) by (|)
        return this.getAggregationCompletionItems(value);
      } else if (empty) {
        // Suggestions for empty query field
        return this.getEmptyCompletionItems(context);
      } else if (prefixUnrecognized && noSuffix && !isNextOperand) {
        // Show term suggestions in a couple of scenarios
        return this.getBeginningCompletionItems(context);
      } else if (prefixUnrecognized && safePrefix) {
        // Show term suggestions in a couple of scenarios
        return this.getTermCompletionItems();
      }

      return emptyResult;
    });

    _defineProperty(this, "getBeginningCompletionItems", context => {
      return {
        suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions]
      };
    });

    _defineProperty(this, "getEmptyCompletionItems", context => {
      const {
        history
      } = context;
      const suggestions = [];

      if (history && history.length) {
        const historyItems = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(history).map(h => h.query.expr).filter().uniq().take(HISTORY_ITEM_COUNT).map(wrapLabel).map(item => addHistoryMetadata(item, history)).value();
        suggestions.push({
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
          skipSort: true,
          label: 'History',
          items: historyItems
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getTermCompletionItems", () => {
      const {
        metrics,
        metricsMetadata
      } = this;
      const suggestions = [];
      suggestions.push({
        searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
        label: 'Functions',
        items: _promql__WEBPACK_IMPORTED_MODULE_6__.FUNCTIONS.map(setFunctionKind)
      });

      if (metrics && metrics.length) {
        suggestions.push({
          label: 'Metrics',
          items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getAggregationCompletionItems", async value => {
      const suggestions = []; // Stitch all query lines together to support multi-line queries

      let queryOffset;
      const queryText = value.document.getBlocks().reduce((text, block) => {
        if (text === undefined) {
          return '';
        }

        if (!block) {
          return text;
        }

        const blockText = block === null || block === void 0 ? void 0 : block.getText();

        if (value.anchorBlock.key === block.key) {
          // Newline characters are not accounted for but this is irrelevant
          // for the purpose of extracting the selector string
          queryOffset = value.selection.anchor.offset + text.length;
        }

        return text + blockText;
      }, ''); // Try search for selector part on the left-hand side, such as `sum (m) by (l)`

      const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);
      let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);
      let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex); // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`

      if (openParensSelectorIndex === -1) {
        const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);
        closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);
        openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);
      }

      const result = {
        suggestions,
        context: 'context-aggregation'
      }; // Suggestions are useless for alternative aggregation clauses without a selector in context

      if (openParensSelectorIndex === -1) {
        return result;
      } // Range vector syntax not accounted for by subsequent parse so discard it if present


      const selectorString = queryText.slice(openParensSelectorIndex + 1, closeParensSelectorIndex).replace(/\[[^\]]+\]$/, '');
      const selector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(selectorString, selectorString.length - 2).selector;
      const series = await this.getSeries(selector);
      const labelKeys = Object.keys(series);

      if (labelKeys.length > 0) {
        const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(labelKeys);
        suggestions.push({
          label: `Labels${limitInfo}`,
          items: labelKeys.map(wrapLabel),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return result;
    });

    _defineProperty(this, "getLabelCompletionItems", async ({
      text,
      wrapperClasses,
      labelKey,
      value
    }) => {
      if (!value) {
        return {
          suggestions: []
        };
      }

      const suggestions = [];
      const line = value.anchorBlock.getText();
      const cursorOffset = value.selection.anchor.offset;
      const suffix = line.substr(cursorOffset);
      const prefix = line.substr(0, cursorOffset);
      const isValueStart = text.match(/^(=|=~|!=|!~)/);
      const isValueEnd = suffix.match(/^"?[,}]|$/); // Detect cursor in front of value, e.g., {key=|"}

      const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^"/); // Don't suggest anything at the beginning or inside a value

      const isValueEmpty = isValueStart && isValueEnd;
      const hasValuePrefix = isValueEnd && !isValueStart;

      if (!isValueEmpty && !hasValuePrefix || isPreValue) {
        return {
          suggestions
        };
      } // Get normalized selector


      let selector;
      let parsedSelector;

      try {
        parsedSelector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(line, cursorOffset);
        selector = parsedSelector.selector;
      } catch {
        selector = EMPTY_SELECTOR;
      }

      const containsMetric = selector.includes('__name__=');
      const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];
      let series = {}; // Query labels for selector

      if (selector) {
        series = await this.getSeries(selector, !containsMetric);
      }

      if (Object.keys(series).length === 0) {
        console.warn(`Server did not return any values for selector = ${selector}`);
        return {
          suggestions
        };
      }

      let context;

      if (text && isValueStart || wrapperClasses.includes('attr-value')) {
        // Label values
        if (labelKey && series[labelKey]) {
          context = 'context-label-values';
          const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(series[labelKey]);
          suggestions.push({
            label: `Label values for "${labelKey}"${limitInfo}`,
            items: series[labelKey].map(wrapLabel),
            searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
          });
        }
      } else {
        // Label keys
        const labelKeys = series ? Object.keys(series) : containsMetric ? null : DEFAULT_KEYS;

        if (labelKeys) {
          const possibleKeys = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.difference)(labelKeys, existingKeys);

          if (possibleKeys.length) {
            context = 'context-labels';
            const newItems = possibleKeys.map(key => ({
              label: key
            }));
            const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(newItems);
            const newSuggestion = {
              label: `Labels${limitInfo}`,
              items: newItems,
              searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
            };
            suggestions.push(newSuggestion);
          }
        }
      }

      return {
        context,
        suggestions
      };
    });

    _defineProperty(this, "fetchLabelValues", async key => {
      const params = this.datasource.getTimeRangeParams();
      const url = `/api/v1/label/${this.datasource.interpolateString(key)}/values`;
      return await this.request(url, [], params);
    });

    _defineProperty(this, "fetchSeriesLabels", async (name, withName) => {
      const interpolatedName = this.datasource.interpolateString(name);
      const range = this.datasource.getTimeRangeParams();
      const urlParams = Object.assign({}, range, {
        'match[]': interpolatedName
      });
      const url = `/api/v1/series`; // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.
      // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every
      // millisecond while still actually getting all the keys for the correct interval. This still can create problems
      // when user does not the newest values for a minute if already cached.

      const cacheParams = new URLSearchParams({
        'match[]': interpolatedName,
        start: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.start, 10)).toString(),
        end: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.end, 10)).toString(),
        withName: withName ? 'true' : 'false'
      });
      const cacheKey = `/api/v1/series?${cacheParams.toString()}`;
      let value = this.labelsCache.get(cacheKey);

      if (!value) {
        const data = await this.request(url, [], urlParams);
        const {
          values
        } = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processLabels)(data, withName);
        value = values;
        this.labelsCache.set(cacheKey, value);
      }

      return value;
    });

    _defineProperty(this, "fetchSeries", async match => {
      const url = '/api/v1/series';
      const range = this.datasource.getTimeRangeParams();
      const params = Object.assign({}, range, {
        'match[]': match
      });
      return await this.request(url, {}, params);
    });

    _defineProperty(this, "fetchDefaultSeries", (0,lodash__WEBPACK_IMPORTED_MODULE_0__.once)(async () => {
      const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));
      return DEFAULT_KEYS.reduce((acc, key, i) => Object.assign({}, acc, {
        [key]: values[i]
      }), {});
    }));

    this.datasource = datasource;
    this.histogramMetrics = [];
    this.timeRange = {
      start: 0,
      end: 0
    };
    this.metrics = [];
    Object.assign(this, initialValues);
  } // Strip syntax chars so that typeahead suggestions can work on clean inputs


  cleanText(s) {
    const parts = s.split(PREFIX_DELIMITER_REGEX);
    const last = parts.pop();
    return last.trimLeft().replace(/"$/, '').replace(/^"/, '');
  }

  get syntax() {
    return _promql__WEBPACK_IMPORTED_MODULE_6__["default"];
  }

  async loadMetricsMetadata() {
    this.metricsMetadata = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.fixSummariesMetadata)(await this.request('/api/v1/metadata', {}));
  }

  getLabelKeys() {
    return this.labelKeys;
  }

  getRangeCompletionItems() {
    return {
      context: 'context-range',
      suggestions: [{
        label: 'Range vector',
        items: [..._promql__WEBPACK_IMPORTED_MODULE_6__.RATE_RANGES]
      }]
    };
  }

  importFromAbstractQuery(labelBasedQuery) {
    return (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.toPromLikeQuery)(labelBasedQuery);
  }

  exportToAbstractQuery(query) {
    const promQuery = query.expr;

    if (!promQuery || promQuery.length === 0) {
      return {
        refId: query.refId,
        labelMatchers: []
      };
    }

    const tokens = prismjs__WEBPACK_IMPORTED_MODULE_2___default().tokenize(promQuery, _promql__WEBPACK_IMPORTED_MODULE_6__["default"]);
    const labelMatchers = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.extractLabelMatchers)(tokens);
    const nameLabelValue = getNameLabelValue(promQuery, tokens);

    if (nameLabelValue && nameLabelValue.length > 0) {
      labelMatchers.push({
        name: '__name__',
        operator: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.AbstractLabelOperator.Equal,
        value: nameLabelValue
      });
    }

    return {
      refId: query.refId,
      labelMatchers
    };
  }

  async getSeries(selector, withName) {
    if (this.datasource.lookupsDisabled) {
      return {};
    }

    try {
      if (selector === EMPTY_SELECTOR) {
        return await this.fetchDefaultSeries();
      } else {
        return await this.fetchSeriesLabels(selector, withName);
      }
    } catch (error) {
      // TODO: better error handling
      console.error(error);
      return {};
    }
  }

  async getLabelValues(key) {
    return await this.fetchLabelValues(key);
  }
  /**
   * Fetches all label keys
   */


  async fetchLabels() {
    const url = '/api/v1/labels';
    const params = this.datasource.getTimeRangeParams();
    this.labelFetchTs = Date.now().valueOf();
    const res = await this.request(url, [], params);

    if (Array.isArray(res)) {
      this.labelKeys = res.slice().sort();
    }

    return [];
  }
  /**
   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as
   * they can change over requested time.
   * @param name
   * @param withName
   */


}

function getNameLabelValue(promQuery, tokens) {
  let nameLabelValue = '';

  for (let prop in tokens) {
    if (typeof tokens[prop] === 'string') {
      nameLabelValue = tokens[prop];
      break;
    }
  }

  return nameLabelValue;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLimitInfo": () => (/* binding */ addLimitInfo),
/* harmony export */   "escapeLabelValueInExactSelector": () => (/* binding */ escapeLabelValueInExactSelector),
/* harmony export */   "escapeLabelValueInRegexSelector": () => (/* binding */ escapeLabelValueInRegexSelector),
/* harmony export */   "expandRecordingRules": () => (/* binding */ expandRecordingRules),
/* harmony export */   "extractLabelMatchers": () => (/* binding */ extractLabelMatchers),
/* harmony export */   "fixSummariesMetadata": () => (/* binding */ fixSummariesMetadata),
/* harmony export */   "labelRegexp": () => (/* binding */ labelRegexp),
/* harmony export */   "limitSuggestions": () => (/* binding */ limitSuggestions),
/* harmony export */   "parseSelector": () => (/* binding */ parseSelector),
/* harmony export */   "processHistogramMetrics": () => (/* binding */ processHistogramMetrics),
/* harmony export */   "processLabels": () => (/* binding */ processLabels),
/* harmony export */   "roundMsToMin": () => (/* binding */ roundMsToMin),
/* harmony export */   "roundSecToMin": () => (/* binding */ roundSecToMin),
/* harmony export */   "selectorRegexp": () => (/* binding */ selectorRegexp),
/* harmony export */   "toPromLikeExpr": () => (/* binding */ toPromLikeExpr),
/* harmony export */   "toPromLikeQuery": () => (/* binding */ toPromLikeQuery)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.28.0-28f20a79ff-bde93fb2be.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/add_label_to_query.ts");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
const _excluded = ["__name__"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const processHistogramMetrics = metrics => {
  const resultSet = new Set();
  const regexp = new RegExp('_bucket($|:)');

  for (let index = 0; index < metrics.length; index++) {
    const metric = metrics[index];
    const isHistogramValue = regexp.test(metric);

    if (isHistogramValue) {
      resultSet.add(metric);
    }
  }

  return [...resultSet];
};
function processLabels(labels, withName = false) {
  // For processing we are going to use sets as they have significantly better performance than arrays
  // After we process labels, we will convert sets to arrays and return object with label values in arrays
  const valueSet = {};
  labels.forEach(label => {
    const {
      __name__
    } = label,
          rest = _objectWithoutPropertiesLoose(label, _excluded);

    if (withName) {
      valueSet['__name__'] = valueSet['__name__'] || new Set();

      if (!valueSet['__name__'].has(__name__)) {
        valueSet['__name__'].add(__name__);
      }
    }

    Object.keys(rest).forEach(key => {
      if (!valueSet[key]) {
        valueSet[key] = new Set();
      }

      if (!valueSet[key].has(rest[key])) {
        valueSet[key].add(rest[key]);
      }
    });
  }); // valueArray that we are going to return in the object

  const valueArray = {};
  limitSuggestions(Object.keys(valueSet)).forEach(key => {
    valueArray[key] = limitSuggestions(Array.from(valueSet[key]));
  });
  return {
    values: valueArray,
    keys: Object.keys(valueArray)
  };
} // const cleanSelectorRegexp = /\{(\w+="[^"\n]*?")(,\w+="[^"\n]*?")*\}/;

const selectorRegexp = /\{[^}]*?(\}|$)/;
const labelRegexp = /\b(\w+)(!?=~?)("[^"\n]*?")/g;
function parseSelector(query, cursorOffset = 1) {
  if (!query.match(selectorRegexp)) {
    // Special matcher for metrics
    if (query.match(/^[A-Za-z:][\w:]*$/)) {
      return {
        selector: `{__name__="${query}"}`,
        labelKeys: ['__name__']
      };
    }

    throw new Error('Query must contain a selector: ' + query);
  } // Check if inside a selector


  const prefix = query.slice(0, cursorOffset);
  const prefixOpen = prefix.lastIndexOf('{');
  const prefixClose = prefix.lastIndexOf('}');

  if (prefixOpen === -1) {
    throw new Error('Not inside selector, missing open brace: ' + prefix);
  }

  if (prefixClose > -1 && prefixClose > prefixOpen) {
    throw new Error('Not inside selector, previous selector already closed: ' + prefix);
  }

  const suffix = query.slice(cursorOffset);
  const suffixCloseIndex = suffix.indexOf('}');
  const suffixClose = suffixCloseIndex + cursorOffset;
  const suffixOpenIndex = suffix.indexOf('{');
  const suffixOpen = suffixOpenIndex + cursorOffset;

  if (suffixClose === -1) {
    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);
  }

  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {
    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);
  } // Extract clean labels to form clean selector, incomplete labels are dropped


  const selector = query.slice(prefixOpen, suffixClose);
  const labels = {};
  selector.replace(labelRegexp, (label, key, operator, value) => {
    const labelOffset = query.indexOf(label);
    const valueStart = labelOffset + key.length + operator.length + 1;
    const valueEnd = labelOffset + key.length + operator.length + value.length - 1; // Skip label if cursor is in value

    if (cursorOffset < valueStart || cursorOffset > valueEnd) {
      labels[key] = {
        value,
        operator
      };
    }

    return '';
  }); // Add metric if there is one before the selector

  const metricPrefix = query.slice(0, prefixOpen);
  const metricMatch = metricPrefix.match(/[A-Za-z:][\w:]*$/);

  if (metricMatch) {
    labels['__name__'] = {
      value: `"${metricMatch[0]}"`,
      operator: '='
    };
  } // Build sorted selector


  const labelKeys = Object.keys(labels).sort();
  const cleanSelector = labelKeys.map(key => `${key}${labels[key].operator}${labels[key].value}`).join(',');
  const selectorString = ['{', cleanSelector, '}'].join('');
  return {
    labelKeys,
    selector: selectorString
  };
}
function expandRecordingRules(query, mapping) {
  const ruleNames = Object.keys(mapping);
  const rulesRegex = new RegExp(`(\\s|^)(${ruleNames.join('|')})(\\s|$|\\(|\\[|\\{)`, 'ig');
  const expandedQuery = query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`); // Split query into array, so if query uses operators, we can correctly add labels to each individual part.

  const queryArray = expandedQuery.split(/(\+|\-|\*|\/|\%|\^)/); // Regex that matches occurrences of ){ or }{ or ]{ which is a sign of incorrecly added labels.

  const invalidLabelsRegex = /(\)\{|\}\{|\]\{)/;
  const correctlyExpandedQueryArray = queryArray.map(query => {
    return addLabelsToExpression(query, invalidLabelsRegex);
  });
  return correctlyExpandedQueryArray.join('');
}

function addLabelsToExpression(expr, invalidLabelsRegexp) {
  var _match$index;

  const match = expr.match(invalidLabelsRegexp);

  if (!match) {
    return expr;
  } // Split query into 2 parts - before the invalidLabelsRegex match and after.


  const indexOfRegexMatch = (_match$index = match.index) !== null && _match$index !== void 0 ? _match$index : 0;
  const exprBeforeRegexMatch = expr.slice(0, indexOfRegexMatch + 1);
  const exprAfterRegexMatch = expr.slice(indexOfRegexMatch + 1); // Create arrayOfLabelObjects with label objects that have key, operator and value.

  const arrayOfLabelObjects = [];
  exprAfterRegexMatch.replace(labelRegexp, (label, key, operator, value) => {
    arrayOfLabelObjects.push({
      key,
      operator,
      value
    });
    return '';
  }); // Loop through all label objects and add them to query.
  // As a starting point we have valid query without the labels.

  let result = exprBeforeRegexMatch;
  arrayOfLabelObjects.filter(Boolean).forEach(obj => {
    // Remove extra set of quotes from obj.value
    const value = obj.value.slice(1, -1);
    result = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_3__.addLabelToQuery)(result, obj.key, value, obj.operator);
  });
  return result;
}
/**
 * Adds metadata for synthetic metrics for which the API does not provide metadata.
 * See https://github.com/grafana/grafana/issues/22337 for details.
 *
 * @param metadata HELP and TYPE metadata from /api/v1/metadata
 */


function fixSummariesMetadata(metadata) {
  if (!metadata) {
    return metadata;
  }

  const baseMetadata = {};
  const summaryMetadata = {};

  for (const metric in metadata) {
    // NOTE: based on prometheus-documentation, we can receive
    // multiple metadata-entries for the given metric, it seems
    // it happens when the same metric is on multiple targets
    // and their help-text differs
    // (https://prometheus.io/docs/prometheus/latest/querying/api/#querying-metric-metadata)
    // for now we just use the first entry.
    const item = metadata[metric][0];
    baseMetadata[metric] = item;

    if (item.type === 'histogram') {
      summaryMetadata[`${metric}_bucket`] = {
        type: 'counter',
        help: `Cumulative counters for the observation buckets (${item.help})`
      };
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the histogram metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the histogram metric (${item.help})`
      };
    }

    if (item.type === 'summary') {
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the base metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the base metric (${item.help})`
      };
    }
  } // Synthetic series


  const syntheticMetadata = {};
  syntheticMetadata['ALERTS'] = {
    type: 'counter',
    help: 'Time series showing pending and firing alerts. The sample value is set to 1 as long as the alert is in the indicated active (pending or firing) state.'
  };
  return Object.assign({}, baseMetadata, summaryMetadata, syntheticMetadata);
}
function roundMsToMin(milliseconds) {
  return roundSecToMin(milliseconds / 1000);
}
function roundSecToMin(seconds) {
  return Math.floor(seconds / 60);
}
function limitSuggestions(items) {
  return items.slice(0, _language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT);
}
function addLimitInfo(items) {
  return items && items.length >= _language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT ? `, limited to the first ${_language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT} received items` : '';
} // NOTE: the following 2 exported functions are very similar to the prometheus*Escape
// functions in datasource.ts, but they are not exactly the same algorithm, and we found
// no way to reuse one in the another or vice versa.
// Prometheus regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),
// so every character that matches something in that list has to be escaped.
// the list of metacharacters is: *+?()|\.[]{}^$
// we make a javascript regular expression that matches those characters:

const RE2_METACHARACTERS = /[*+?()|\\.\[\]{}^$]/g;

function escapePrometheusRegexp(value) {
  return value.replace(RE2_METACHARACTERS, '\\$&');
} // based on the openmetrics-documentation, the 3 symbols we have to handle are:
// - \n ... the newline character
// - \  ... the backslash character
// - "  ... the double-quote character


function escapeLabelValueInExactSelector(labelValue) {
  return labelValue.replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/"/g, '\\"');
}
function escapeLabelValueInRegexSelector(labelValue) {
  return escapeLabelValueInExactSelector(escapePrometheusRegexp(labelValue));
}
const FromPromLikeMap = {
  '=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.Equal,
  '!=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqual,
  '=~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.EqualRegEx,
  '!~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqualRegEx
};
const ToPromLikeMap = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.invert)(FromPromLikeMap);
function toPromLikeExpr(labelBasedQuery) {
  const expr = labelBasedQuery.labelMatchers.map(selector => {
    const operator = ToPromLikeMap[selector.operator];

    if (operator) {
      return `${selector.name}${operator}"${selector.value}"`;
    } else {
      return '';
    }
  }).filter(e => e !== '').join(', ');
  return expr ? `{${expr}}` : '';
}
function toPromLikeQuery(labelBasedQuery) {
  return {
    refId: labelBasedQuery.refId,
    expr: toPromLikeExpr(labelBasedQuery),
    range: true
  };
}
function extractLabelMatchers(tokens) {
  const labelMatchers = [];

  for (let prop in tokens) {
    if (tokens[prop] instanceof prismjs__WEBPACK_IMPORTED_MODULE_1__.Token) {
      let token = tokens[prop];

      if (token.type === 'context-labels') {
        let labelKey = '';
        let labelValue = '';
        let labelOperator = '';
        let contentTokens = token.content;

        for (let currentToken in contentTokens) {
          if (typeof contentTokens[currentToken] === 'string') {
            let currentStr;
            currentStr = contentTokens[currentToken];

            if (currentStr === '=' || currentStr === '!=' || currentStr === '=~' || currentStr === '!~') {
              labelOperator = currentStr;
            }
          } else if (contentTokens[currentToken] instanceof prismjs__WEBPACK_IMPORTED_MODULE_1__.Token) {
            switch (contentTokens[currentToken].type) {
              case 'label-key':
                labelKey = contentTokens[currentToken].content;
                break;

              case 'label-value':
                labelValue = contentTokens[currentToken].content;
                labelValue = labelValue.substring(1, labelValue.length - 1);
                const labelComparator = FromPromLikeMap[labelOperator];

                if (labelComparator) {
                  labelMatchers.push({
                    name: labelKey,
                    operator: labelComparator,
                    value: labelValue
                  });
                }

                break;
            }
          }
        }
      }
    }
  }

  return labelMatchers;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/metric_find_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PrometheusMetricFindQuery)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





class PrometheusMetricFindQuery {
  constructor(datasource, query) {
    _defineProperty(this, "range", void 0);

    this.datasource = datasource;
    this.query = query;
    this.datasource = datasource;
    this.query = query;
    this.range = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_1__.getTimeSrv)().timeRange();
  }

  process() {
    const labelNamesRegex = /^label_names\(\)\s*$/;
    const labelValuesRegex = /^label_values\((?:(.+),\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\)\s*$/;
    const metricNamesRegex = /^metrics\((.+)\)\s*$/;
    const queryResultRegex = /^query_result\((.+)\)\s*$/;
    const labelNamesQuery = this.query.match(labelNamesRegex);

    if (labelNamesQuery) {
      return this.labelNamesQuery();
    }

    const labelValuesQuery = this.query.match(labelValuesRegex);

    if (labelValuesQuery) {
      if (labelValuesQuery[1]) {
        return this.labelValuesQuery(labelValuesQuery[2], labelValuesQuery[1]);
      } else {
        return this.labelValuesQuery(labelValuesQuery[2]);
      }
    }

    const metricNamesQuery = this.query.match(metricNamesRegex);

    if (metricNamesQuery) {
      return this.metricNameQuery(metricNamesQuery[1]);
    }

    const queryResultQuery = this.query.match(queryResultRegex);

    if (queryResultQuery) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.lastValueFrom)(this.queryResultQuery(queryResultQuery[1]));
    } // if query contains full metric name, return metric name and label list


    return this.metricNameAndLabelsQuery(this.query);
  }

  labelNamesQuery() {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/labels`;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, value => {
        return {
          text: value
        };
      });
    });
  }

  labelValuesQuery(label, metric) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    let url;

    if (!metric) {
      const params = {
        start: start.toString(),
        end: end.toString()
      }; // return label values globally

      url = `/api/v1/label/${label}/values`;
      return this.datasource.metadataRequest(url, params).then(result => {
        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, value => {
          return {
            text: value
          };
        });
      });
    } else {
      const params = {
        'match[]': metric,
        start: start.toString(),
        end: end.toString()
      };
      url = `/api/v1/series`;
      return this.datasource.metadataRequest(url, params).then(result => {
        const _labels = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, metric => {
          return metric[label] || '';
        }).filter(label => {
          return label !== '';
        });

        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.uniq)(_labels).map(metric => {
          return {
            text: metric,
            expandable: true
          };
        });
      });
    }
  }

  metricNameQuery(metricFilterPattern) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/label/__name__/values`;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(result.data.data).filter(metricName => {
        const r = new RegExp(metricFilterPattern);
        return r.test(metricName);
      }).map(matchedMetricName => {
        return {
          text: matchedMetricName,
          expandable: true
        };
      }).value();
    });
  }

  queryResultQuery(query) {
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const instantQuery = {
      expr: query
    };
    return this.datasource.performInstantQuery(instantQuery, end).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data.result, metricData => {
        let text = metricData.metric.__name__ || '';
        delete metricData.metric.__name__;
        text += '{' + (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(metricData.metric, (v, k) => {
          return k + '="' + v + '"';
        }).join(',') + '}';
        text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;
        return {
          text: text,
          expandable: true
        };
      });
    }));
  }

  metricNameAndLabelsQuery(query) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      'match[]': query,
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/series`;
    const self = this;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, metric => {
        return {
          text: self.datasource.getOriginalMetricName(metric),
          expandable: true
        };
      });
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/module.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "plugin": () => (/* binding */ plugin)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _components_PromCheatSheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx");
/* harmony import */ var _components_PromQueryEditorByApp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditorByApp.tsx");
/* harmony import */ var _configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/datasource.tsx");





const plugin = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataSourcePlugin(_datasource__WEBPACK_IMPORTED_MODULE_4__.PrometheusDatasource).setQueryEditor(_components_PromQueryEditorByApp__WEBPACK_IMPORTED_MODULE_2__["default"]).setConfigEditor(_configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_3__.ConfigEditor).setQueryEditorHelp(_components_PromCheatSheet__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/promql.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FUNCTIONS": () => (/* binding */ FUNCTIONS),
/* harmony export */   "LOGICAL_OPERATORS": () => (/* binding */ LOGICAL_OPERATORS),
/* harmony export */   "OPERATORS": () => (/* binding */ OPERATORS),
/* harmony export */   "PROM_KEYWORDS": () => (/* binding */ PROM_KEYWORDS),
/* harmony export */   "RATE_RANGES": () => (/* binding */ RATE_RANGES),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "promqlGrammar": () => (/* binding */ promqlGrammar)
/* harmony export */ });
// When changing RATE_RANGES, check if Loki/LogQL ranges should be changed too
// @see public/app/plugins/datasource/loki/language_provider.ts
const RATE_RANGES = [{
  label: '$__interval',
  sortValue: '$__interval'
}, {
  label: '$__rate_interval',
  sortValue: '$__rate_interval'
}, {
  label: '$__range',
  sortValue: '$__range'
}, {
  label: '1m',
  sortValue: '00:01:00'
}, {
  label: '5m',
  sortValue: '00:05:00'
}, {
  label: '10m',
  sortValue: '00:10:00'
}, {
  label: '30m',
  sortValue: '00:30:00'
}, {
  label: '1h',
  sortValue: '01:00:00'
}, {
  label: '1d',
  sortValue: '24:00:00'
}];
const OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];
const LOGICAL_OPERATORS = ['or', 'and', 'unless'];
const TRIGONOMETRIC_FUNCTIONS = [{
  label: 'acos',
  insertText: 'acos',
  detail: 'acos(v instant-vector)',
  documentation: 'calculates the arccosine of all elements in v'
}, {
  label: 'acosh',
  insertText: 'acosh',
  detail: 'acosh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic cosine of all elements in v'
}, {
  label: 'asin',
  insertText: 'asin',
  detail: 'asin(v instant-vector)',
  documentation: 'calculates the arcsine of all elements in v'
}, {
  label: 'asinh',
  insertText: 'asinh',
  detail: 'asinh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic sine of all elements in v'
}, {
  label: 'atan',
  insertText: 'atan',
  detail: 'atan(v instant-vector)',
  documentation: 'calculates the arctangent of all elements in v'
}, {
  label: 'atanh',
  insertText: 'atanh',
  detail: 'atanh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic tangent of all elements in v'
}, {
  label: 'cos',
  insertText: 'cos',
  detail: 'cos(v instant-vector)',
  documentation: 'calculates the cosine of all elements in v'
}, {
  label: 'cosh',
  insertText: 'cosh',
  detail: 'cosh(v instant-vector)',
  documentation: 'calculates the hyperbolic cosine of all elements in v'
}, {
  label: 'sin',
  insertText: 'sin',
  detail: 'sin(v instant-vector)',
  documentation: 'calculates the sine of all elements in v'
}, {
  label: 'sinh',
  insertText: 'sinh',
  detail: 'sinh(v instant-vector)',
  documentation: 'calculates the hyperbolic sine of all elements in v'
}, {
  label: 'tan',
  insertText: 'tan',
  detail: 'tan(v instant-vector)',
  documentation: 'calculates the tangent of all elements in v'
}, {
  label: 'tanh',
  insertText: 'tanh',
  detail: 'tanh(v instant-vector)',
  documentation: 'calculates the hyperbolic tangent of all elements in v'
}];
const AGGREGATION_OPERATORS = [{
  label: 'sum',
  insertText: 'sum',
  documentation: 'Calculate sum over dimensions'
}, {
  label: 'min',
  insertText: 'min',
  documentation: 'Select minimum over dimensions'
}, {
  label: 'max',
  insertText: 'max',
  documentation: 'Select maximum over dimensions'
}, {
  label: 'avg',
  insertText: 'avg',
  documentation: 'Calculate the average over dimensions'
}, {
  label: 'group',
  insertText: 'group',
  documentation: 'All values in the resulting vector are 1'
}, {
  label: 'stddev',
  insertText: 'stddev',
  documentation: 'Calculate population standard deviation over dimensions'
}, {
  label: 'stdvar',
  insertText: 'stdvar',
  documentation: 'Calculate population standard variance over dimensions'
}, {
  label: 'count',
  insertText: 'count',
  documentation: 'Count number of elements in the vector'
}, {
  label: 'count_values',
  insertText: 'count_values',
  documentation: 'Count number of elements with the same value'
}, {
  label: 'bottomk',
  insertText: 'bottomk',
  documentation: 'Smallest k elements by sample value'
}, {
  label: 'topk',
  insertText: 'topk',
  documentation: 'Largest k elements by sample value'
}, {
  label: 'quantile',
  insertText: 'quantile',
  documentation: 'Calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions'
}];
const FUNCTIONS = [...AGGREGATION_OPERATORS, ...TRIGONOMETRIC_FUNCTIONS, {
  insertText: 'abs',
  label: 'abs',
  detail: 'abs(v instant-vector)',
  documentation: 'Returns the input vector with all sample values converted to their absolute value.'
}, {
  insertText: 'absent',
  label: 'absent',
  detail: 'absent(v instant-vector)',
  documentation: 'Returns an empty vector if the vector passed to it has any elements and a 1-element vector with the value 1 if the vector passed to it has no elements. This is useful for alerting on when no time series exist for a given metric name and label combination.'
}, {
  insertText: 'absent_over_time',
  label: 'absent_over_time',
  detail: 'absent(v range-vector)',
  documentation: 'Returns an empty vector if the range vector passed to it has any elements and a 1-element vector with the value 1 if the range vector passed to it has no elements.'
}, {
  insertText: 'ceil',
  label: 'ceil',
  detail: 'ceil(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` up to the nearest integer.'
}, {
  insertText: 'changes',
  label: 'changes',
  detail: 'changes(v range-vector)',
  documentation: 'For each input time series, `changes(v range-vector)` returns the number of times its value has changed within the provided time range as an instant vector.'
}, {
  insertText: 'clamp',
  label: 'clamp',
  detail: 'clamp(v instant-vector, min scalar, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min` and an upper limit of `max`.'
}, {
  insertText: 'clamp_max',
  label: 'clamp_max',
  detail: 'clamp_max(v instant-vector, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have an upper limit of `max`.'
}, {
  insertText: 'clamp_min',
  label: 'clamp_min',
  detail: 'clamp_min(v instant-vector, min scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min`.'
}, {
  insertText: 'count_scalar',
  label: 'count_scalar',
  detail: 'count_scalar(v instant-vector)',
  documentation: 'Returns the number of elements in a time series vector as a scalar. This is in contrast to the `count()` aggregation operator, which always returns a vector (an empty one if the input vector is empty) and allows grouping by labels via a `by` clause.'
}, {
  insertText: 'deg',
  label: 'deg',
  detail: 'deg(v instant-vector)',
  documentation: 'Converts radians to degrees for all elements in v'
}, {
  insertText: 'day_of_month',
  label: 'day_of_month',
  detail: 'day_of_month(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the month for each of the given times in UTC. Returned values are from 1 to 31.'
}, {
  insertText: 'day_of_week',
  label: 'day_of_week',
  detail: 'day_of_week(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the week for each of the given times in UTC. Returned values are from 0 to 6, where 0 means Sunday etc.'
}, {
  insertText: 'days_in_month',
  label: 'days_in_month',
  detail: 'days_in_month(v=vector(time()) instant-vector)',
  documentation: 'Returns number of days in the month for each of the given times in UTC. Returned values are from 28 to 31.'
}, {
  insertText: 'delta',
  label: 'delta',
  detail: 'delta(v range-vector)',
  documentation: 'Calculates the difference between the first and last value of each time series element in a range vector `v`, returning an instant vector with the given deltas and equivalent labels. The delta is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if the sample values are all integers.'
}, {
  insertText: 'deriv',
  label: 'deriv',
  detail: 'deriv(v range-vector)',
  documentation: 'Calculates the per-second derivative of the time series in a range vector `v`, using simple linear regression.'
}, {
  insertText: 'drop_common_labels',
  label: 'drop_common_labels',
  detail: 'drop_common_labels(instant-vector)',
  documentation: 'Drops all labels that have the same name and value across all series in the input vector.'
}, {
  insertText: 'exp',
  label: 'exp',
  detail: 'exp(v instant-vector)',
  documentation: 'Calculates the exponential function for all elements in `v`.\nSpecial cases are:\n* `Exp(+Inf) = +Inf` \n* `Exp(NaN) = NaN`'
}, {
  insertText: 'floor',
  label: 'floor',
  detail: 'floor(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` down to the nearest integer.'
}, {
  insertText: 'histogram_quantile',
  label: 'histogram_quantile',
  detail: 'histogram_quantile(φ float, b instant-vector)',
  documentation: 'Calculates the φ-quantile (0 ≤ φ ≤ 1) from the buckets `b` of a histogram. The samples in `b` are the counts of observations in each bucket. Each sample must have a label `le` where the label value denotes the inclusive upper bound of the bucket. (Samples without such a label are silently ignored.) The histogram metric type automatically provides time series with the `_bucket` suffix and the appropriate labels.'
}, {
  insertText: 'holt_winters',
  label: 'holt_winters',
  detail: 'holt_winters(v range-vector, sf scalar, tf scalar)',
  documentation: 'Produces a smoothed value for time series based on the range in `v`. The lower the smoothing factor `sf`, the more importance is given to old data. The higher the trend factor `tf`, the more trends in the data is considered. Both `sf` and `tf` must be between 0 and 1.'
}, {
  insertText: 'hour',
  label: 'hour',
  detail: 'hour(v=vector(time()) instant-vector)',
  documentation: 'Returns the hour of the day for each of the given times in UTC. Returned values are from 0 to 23.'
}, {
  insertText: 'idelta',
  label: 'idelta',
  detail: 'idelta(v range-vector)',
  documentation: 'Calculates the difference between the last two samples in the range vector `v`, returning an instant vector with the given deltas and equivalent labels.'
}, {
  insertText: 'increase',
  label: 'increase',
  detail: 'increase(v range-vector)',
  documentation: 'Calculates the increase in the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. The increase is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if a counter increases only by integer increments.'
}, {
  insertText: 'irate',
  label: 'irate',
  detail: 'irate(v range-vector)',
  documentation: 'Calculates the per-second instant rate of increase of the time series in the range vector. This is based on the last two data points. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for.'
}, {
  insertText: 'label_join',
  label: 'label_join',
  detail: 'label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)',
  documentation: 'For each timeseries in `v`, joins all the values of all the `src_labels` using `separator` and returns the timeseries with the label `dst_label` containing the joined value. There can be any number of `src_labels` in this function.'
}, {
  insertText: 'label_replace',
  label: 'label_replace',
  detail: 'label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)',
  documentation: "For each timeseries in `v`, `label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`  matches the regular expression `regex` against the label `src_label`.  If it matches, then the timeseries is returned with the label `dst_label` replaced by the expansion of `replacement`. `$1` is replaced with the first matching subgroup, `$2` with the second etc. If the regular expression doesn't match then the timeseries is returned unchanged."
}, {
  insertText: 'ln',
  label: 'ln',
  detail: 'ln(v instant-vector)',
  documentation: 'Calculates the natural logarithm for all elements in `v`.\nSpecial cases are:\n * `ln(+Inf) = +Inf`\n * `ln(0) = -Inf`\n * `ln(x < 0) = NaN`\n * `ln(NaN) = NaN`'
}, {
  insertText: 'log2',
  label: 'log2',
  detail: 'log2(v instant-vector)',
  documentation: 'Calculates the binary logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'log10',
  label: 'log10',
  detail: 'log10(v instant-vector)',
  documentation: 'Calculates the decimal logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'minute',
  label: 'minute',
  detail: 'minute(v=vector(time()) instant-vector)',
  documentation: 'Returns the minute of the hour for each of the given times in UTC. Returned values are from 0 to 59.'
}, {
  insertText: 'month',
  label: 'month',
  detail: 'month(v=vector(time()) instant-vector)',
  documentation: 'Returns the month of the year for each of the given times in UTC. Returned values are from 1 to 12, where 1 means January etc.'
}, {
  insertText: 'pi',
  label: 'pi',
  detail: 'pi()',
  documentation: 'Returns pi'
}, {
  insertText: 'predict_linear',
  label: 'predict_linear',
  detail: 'predict_linear(v range-vector, t scalar)',
  documentation: 'Predicts the value of time series `t` seconds from now, based on the range vector `v`, using simple linear regression.'
}, {
  insertText: 'rad',
  label: 'rad',
  detail: 'rad(v instant-vector)',
  documentation: 'Converts degrees to radians for all elements in v'
}, {
  insertText: 'rate',
  label: 'rate',
  detail: 'rate(v range-vector)',
  documentation: "Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period."
}, {
  insertText: 'resets',
  label: 'resets',
  detail: 'resets(v range-vector)',
  documentation: 'For each input time series, `resets(v range-vector)` returns the number of counter resets within the provided time range as an instant vector. Any decrease in the value between two consecutive samples is interpreted as a counter reset.'
}, {
  insertText: 'round',
  label: 'round',
  detail: 'round(v instant-vector, to_nearest=1 scalar)',
  documentation: 'Rounds the sample values of all elements in `v` to the nearest integer. Ties are resolved by rounding up. The optional `to_nearest` argument allows specifying the nearest multiple to which the sample values should be rounded. This multiple may also be a fraction.'
}, {
  insertText: 'scalar',
  label: 'scalar',
  detail: 'scalar(v instant-vector)',
  documentation: 'Given a single-element input vector, `scalar(v instant-vector)` returns the sample value of that single element as a scalar. If the input vector does not have exactly one element, `scalar` will return `NaN`.'
}, {
  insertText: 'sgn',
  label: 'sgn',
  detail: 'sgn(v instant-vector)',
  documentation: 'Returns a vector with all sample values converted to their sign, defined as this: 1 if v is positive, -1 if v is negative and 0 if v is equal to zero.'
}, {
  insertText: 'sort',
  label: 'sort',
  detail: 'sort(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in ascending order.'
}, {
  insertText: 'sort_desc',
  label: 'sort_desc',
  detail: 'sort_desc(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in descending order.'
}, {
  insertText: 'sqrt',
  label: 'sqrt',
  detail: 'sqrt(v instant-vector)',
  documentation: 'Calculates the square root of all elements in `v`.'
}, {
  insertText: 'time',
  label: 'time',
  detail: 'time()',
  documentation: 'Returns the number of seconds since January 1, 1970 UTC. Note that this does not actually return the current time, but the time at which the expression is to be evaluated.'
}, {
  insertText: 'timestamp',
  label: 'timestamp',
  detail: 'timestamp(v instant-vector)',
  documentation: 'Returns the timestamp of each of the samples of the given vector as the number of seconds since January 1, 1970 UTC.'
}, {
  insertText: 'vector',
  label: 'vector',
  detail: 'vector(s scalar)',
  documentation: 'Returns the scalar `s` as a vector with no labels.'
}, {
  insertText: 'year',
  label: 'year',
  detail: 'year(v=vector(time()) instant-vector)',
  documentation: 'Returns the year for each of the given times in UTC.'
}, {
  insertText: 'avg_over_time',
  label: 'avg_over_time',
  detail: 'avg_over_time(range-vector)',
  documentation: 'The average value of all points in the specified interval.'
}, {
  insertText: 'min_over_time',
  label: 'min_over_time',
  detail: 'min_over_time(range-vector)',
  documentation: 'The minimum value of all points in the specified interval.'
}, {
  insertText: 'max_over_time',
  label: 'max_over_time',
  detail: 'max_over_time(range-vector)',
  documentation: 'The maximum value of all points in the specified interval.'
}, {
  insertText: 'sum_over_time',
  label: 'sum_over_time',
  detail: 'sum_over_time(range-vector)',
  documentation: 'The sum of all values in the specified interval.'
}, {
  insertText: 'count_over_time',
  label: 'count_over_time',
  detail: 'count_over_time(range-vector)',
  documentation: 'The count of all values in the specified interval.'
}, {
  insertText: 'quantile_over_time',
  label: 'quantile_over_time',
  detail: 'quantile_over_time(scalar, range-vector)',
  documentation: 'The φ-quantile (0 ≤ φ ≤ 1) of the values in the specified interval.'
}, {
  insertText: 'stddev_over_time',
  label: 'stddev_over_time',
  detail: 'stddev_over_time(range-vector)',
  documentation: 'The population standard deviation of the values in the specified interval.'
}, {
  insertText: 'stdvar_over_time',
  label: 'stdvar_over_time',
  detail: 'stdvar_over_time(range-vector)',
  documentation: 'The population standard variance of the values in the specified interval.'
}, {
  insertText: 'last_over_time',
  label: 'last_over_time',
  detail: 'last_over_time(range-vector)',
  documentation: 'The most recent point value in specified interval.'
}];
const PROM_KEYWORDS = FUNCTIONS.map(keyword => keyword.label);
const promqlGrammar = {
  comment: {
    pattern: /#.*/
  },
  'context-aggregation': {
    pattern: /((by|without)\s*)\([^)]*\)/,
    // by ()
    lookbehind: true,
    inside: {
      'label-key': {
        pattern: /[^(),\s][^,)]*[^),\s]*/,
        alias: 'attr-name'
      },
      punctuation: /[()]/
    }
  },
  'context-labels': {
    pattern: /\{[^}]*(?=}?)/,
    greedy: true,
    inside: {
      comment: {
        pattern: /#.*/
      },
      'label-key': {
        pattern: /[a-z_]\w*(?=\s*(=|!=|=~|!~))/,
        alias: 'attr-name',
        greedy: true
      },
      'label-value': {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: true,
        alias: 'attr-value'
      },
      punctuation: /[{]/
    }
  },
  function: new RegExp(`\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\s*\\()`, 'i'),
  'context-range': [{
    pattern: /\[[^\]]*(?=])/,
    // [1m]
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }, {
    pattern: /(offset\s+)\w+/,
    // offset 1m
    lookbehind: true,
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }],
  idList: {
    pattern: /\d+(\|\d+)+/,
    alias: 'number'
  },
  number: /\b-?\d+((\.\d*)?([eE][+-]?\d+)?)?\b/,
  operator: new RegExp(`/[-+*/=%^~]|&&?|\\|?\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:${OPERATORS.join('|')})\\b`, 'i'),
  punctuation: /[{};()`,.]/
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (promqlGrammar);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/query_hints.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUM_HINT_THRESHOLD_COUNT": () => (/* binding */ SUM_HINT_THRESHOLD_COUNT),
/* harmony export */   "getInitHints": () => (/* binding */ getInitHints),
/* harmony export */   "getQueryHints": () => (/* binding */ getQueryHints)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);


/**
 * Number of time series results needed before starting to suggest sum aggregation hints
 */
const SUM_HINT_THRESHOLD_COUNT = 20;
function getQueryHints(query, series, datasource) {
  const hints = []; // ..._bucket metric needs a histogram_quantile()

  const histogramMetric = query.trim().match(/^\w+_bucket$|^\w+_bucket{.*}$/);

  if (histogramMetric) {
    const label = 'Selected metric has buckets.';
    hints.push({
      type: 'HISTOGRAM_QUANTILE',
      label,
      fix: {
        label: 'Consider calculating aggregated quantile by adding histogram_quantile().',
        action: {
          type: 'ADD_HISTOGRAM_QUANTILE',
          query
        }
      }
    });
  } // Check for need of rate()


  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {
    var _datasource$languageP, _datasource$languageP2;

    // Use metric metadata for exact types
    const nameMatch = query.match(/\b(\w+_(total|sum|count))\b/);
    let counterNameMetric = nameMatch ? nameMatch[1] : '';
    const metricsMetadata = (_datasource$languageP = datasource === null || datasource === void 0 ? void 0 : (_datasource$languageP2 = datasource.languageProvider) === null || _datasource$languageP2 === void 0 ? void 0 : _datasource$languageP2.metricsMetadata) !== null && _datasource$languageP !== void 0 ? _datasource$languageP : {};
    const metricMetadataKeys = Object.keys(metricsMetadata);
    let certain = false;

    if (metricMetadataKeys.length > 0) {
      var _metricMetadataKeys$f;

      counterNameMetric = (_metricMetadataKeys$f = metricMetadataKeys.find(metricName => {
        // Only considering first type information, could be non-deterministic
        const metadata = metricsMetadata[metricName];

        if (metadata.type.toLowerCase() === 'counter') {
          const metricRegex = new RegExp(`\\b${metricName}\\b`);

          if (query.match(metricRegex)) {
            certain = true;
            return true;
          }
        }

        return false;
      })) !== null && _metricMetadataKeys$f !== void 0 ? _metricMetadataKeys$f : '';
    }

    if (counterNameMetric) {
      // FixableQuery consists of metric name and optionally label-value pairs. We are not offering fix for complex queries yet.
      const fixableQuery = query.trim().match(/^\w+$|^\w+{.*}$/);
      const verb = certain ? 'is' : 'looks like';
      let label = `Selected metric ${verb} a counter.`;
      let fix;

      if (fixableQuery) {
        fix = {
          label: 'Consider calculating rate of counter by adding rate().',
          action: {
            type: 'ADD_RATE',
            query
          }
        };
      } else {
        label = `${label} Consider calculating rate of counter by adding rate().`;
      }

      hints.push({
        type: 'APPLY_RATE',
        label,
        fix
      });
    }
  } // Check for recording rules expansion


  if (datasource && datasource.ruleMappings) {
    const mapping = datasource.ruleMappings;
    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {
      if (query.search(ruleName) > -1) {
        return Object.assign({}, acc, {
          [ruleName]: mapping[ruleName]
        });
      }

      return acc;
    }, {});

    if ((0,lodash__WEBPACK_IMPORTED_MODULE_0__.size)(mappingForQuery) > 0) {
      const label = 'Query contains recording rules.';
      hints.push({
        type: 'EXPAND_RULES',
        label,
        fix: {
          label: 'Expand rules',
          action: {
            type: 'EXPAND_RULES',
            query,
            mapping: mappingForQuery
          }
        }
      });
    }
  }

  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {
    const simpleMetric = query.trim().match(/^\w+$/);

    if (simpleMetric) {
      hints.push({
        type: 'ADD_SUM',
        label: 'Many time series results returned.',
        fix: {
          label: 'Consider aggregating with sum().',
          action: {
            type: 'ADD_SUM',
            query: query,
            preventSubmit: true
          }
        }
      });
    }
  }

  return hints;
}
function getInitHints(datasource) {
  const hints = []; // Hint if using Loki as Prometheus data source

  if (datasource.directUrl.includes('/loki') && !datasource.languageProvider.metrics.length) {
    hints.push({
      label: `Using Loki as a Prometheus data source is no longer supported. You must use the Loki data source for your Loki instance.`,
      type: 'INFO'
    });
  } // Hint for big disabled lookups


  if (datasource.lookupsDisabled) {
    hints.push({
      label: `Labels and metrics lookup was disabled in data source settings.`,
      type: 'INFO'
    });
  }

  return hints;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryModeller": () => (/* binding */ PromQueryModeller),
/* harmony export */   "promQueryModeller": () => (/* binding */ promQueryModeller)
/* harmony export */ });
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
/* harmony import */ var _aggregations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts");
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");





class PromQueryModeller extends _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__.LokiAndPromQueryModellerBase {
  constructor() {
    super(() => {
      const allOperations = [...(0,_operations__WEBPACK_IMPORTED_MODULE_2__.getOperationDefinitions)(), ...(0,_aggregations__WEBPACK_IMPORTED_MODULE_1__.getAggregationOperations)()];

      for (const op of allOperations) {
        const func = _promql__WEBPACK_IMPORTED_MODULE_0__.FUNCTIONS.find(x => x.insertText === op.id);

        if (func) {
          op.documentation = func.documentation;
        }
      }

      return allOperations;
    });
    this.setOperationCategories([_types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Aggregations, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.RangeFunctions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Functions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.BinaryOps, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Trigonometric, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Time]);
  }

  getQueryPatterns() {
    return [{
      name: 'Rate then sum',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: 'sum',
        params: []
      }]
    }, {
      name: 'Rate then sum by(label) then avg',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['']
      }, {
        id: 'avg',
        params: []
      }]
    }, {
      name: 'Histogram quantile on rate',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }, {
      name: 'Histogram quantile on increase ',
      operations: [{
        id: 'increase',
        params: ['$__rate_interval']
      }, {
        id: '__max_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }];
  }

}
const promQueryModeller = new PromQueryModeller();

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAggregationOperations": () => (/* binding */ getAggregationOperations)
/* harmony export */ });
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");



function getAggregationOperations() {
  return [...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sum), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Avg), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Min), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Max), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Count), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.TopK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.BottomK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountValues, {
    params: [{
      name: 'Identifier',
      type: 'string'
    }],
    defaultParams: ['count']
  }), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.SumOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AvgOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MinOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MaxOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.LastOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.PresentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AbsentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.StddevOverTime)];
}

function createAggregationOverTime(name) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)()],
    defaultParams: ['$__interval'],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: _operations__WEBPACK_IMPORTED_MODULE_0__.addOperationWithRangeVector
  };
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '$__interval';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "binaryScalarDefs": () => (/* binding */ binaryScalarDefs),
/* harmony export */   "binaryScalarOperations": () => (/* binding */ binaryScalarOperations),
/* harmony export */   "binaryScalarOperatorToOperatorName": () => (/* binding */ binaryScalarOperatorToOperatorName)
/* harmony export */ });
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");


const binaryScalarDefs = [{
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Addition,
  name: 'Add scalar',
  sign: '+'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Subtraction,
  name: 'Subtract scalar',
  sign: '-'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.MultiplyBy,
  name: 'Multiply by scalar',
  sign: '*'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.DivideBy,
  name: 'Divide by scalar',
  sign: '/'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Modulo,
  name: 'Modulo by scalar',
  sign: '%'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Exponent,
  name: 'Exponent',
  sign: '^'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.EqualTo,
  name: 'Equal to',
  sign: '==',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.NotEqualTo,
  name: 'Not equal to',
  sign: '!=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.GreaterThan,
  name: 'Greater than',
  sign: '>',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.LessThan,
  name: 'Less than',
  sign: '<',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.GreaterOrEqual,
  name: 'Greater or equal to',
  sign: '>=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.LessOrEqual,
  name: 'Less or equal to',
  sign: '<=',
  comparison: true
}];
const binaryScalarOperatorToOperatorName = binaryScalarDefs.reduce((acc, def) => {
  acc[def.sign] = {
    id: def.id,
    comparison: def.comparison
  };
  return acc;
}, {}); // Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies
// both the operator and the operand in a single input

const binaryScalarOperations = binaryScalarDefs.map(opDef => {
  const params = [{
    name: 'Value',
    type: 'number'
  }];
  const defaultParams = [2];

  if (opDef.comparison) {
    params.push({
      name: 'Bool',
      type: 'boolean',
      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.'
    });
    defaultParams.push(false);
  }

  return {
    id: opDef.id,
    name: opDef.name,
    params,
    defaultParams,
    alternativesKey: 'binary scalar operations',
    category: _types__WEBPACK_IMPORTED_MODULE_1__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: getSimpleBinaryRenderer(opDef.sign),
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.defaultAddOperationHandler
  };
});

function getSimpleBinaryRenderer(operator) {
  return function binaryRenderer(model, def, innerExpr) {
    let param = model.params[0];
    let bool = '';

    if (model.params.length === 2) {
      bool = model.params[1] ? ' bool' : '';
    }

    return `${innerExpr} ${operator}${bool} ${param}`;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelParamEditor": () => (/* binding */ LabelParamEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function LabelParamEditor({
  onChange,
  index,
  operationIndex,
  value,
  query,
  datasource
}) {
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
    inputId: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(operationIndex, index),
    autoFocus: value === '' ? true : undefined,
    openMenuOnFocus: true,
    onOpenMenu: async () => {
      setState({
        isLoading: true
      });
      const options = await loadGroupByLabels(query, datasource);
      setState({
        options,
        isLoading: undefined
      });
    },
    isLoading: state.isLoading,
    allowCustomValue: true,
    noOptionsMessage: "No labels found",
    loadingMessage: "Loading labels",
    options: state.options,
    value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(value),
    onChange: value => onChange(index, value.value)
  });
}

async function loadGroupByLabels(query, datasource) {
  let labels = query.labels; // This function is used by both Prometheus and Loki and this the only difference.

  if (datasource.type === 'prometheus') {
    labels = [{
      label: '__name__',
      op: '=',
      value: query.metric
    }, ...query.labels];
  }

  const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderLabels(labels);
  const result = await datasource.languageProvider.fetchSeriesLabels(expr);
  return Object.keys(result).map(x => ({
    label: x,
    value: x
  }));
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/MetricSelect.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MetricSelect": () => (/* binding */ MetricSelect)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_highlight_words__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/react-highlight-words-virtual-cb0ac01bed/0/cache/react-highlight-words-npm-0.18.0-101bfefffe-ff9759e7eb.zip/node_modules/react-highlight-words/dist/main.js");
/* harmony import */ var react_highlight_words__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_highlight_words__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");

 // @ts-ignore






// We are matching words split with space
const splitSeparator = ' ';
function MetricSelect({
  query,
  onChange,
  onGetMetrics
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.useStyles2)(getStyles);
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});
  const customFilterOption = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((option, searchQuery) => {
    var _option$label;

    const label = (_option$label = option.label) !== null && _option$label !== void 0 ? _option$label : option.value;

    if (!label) {
      return false;
    } // custom value is not a string label but a react node


    if (!label.toLowerCase) {
      return true;
    }

    const searchWords = searchQuery.split(splitSeparator);
    return searchWords.reduce((acc, cur) => acc && label.toLowerCase().includes(cur.toLowerCase()), true);
  }, []);
  const formatOptionLabel = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((option, meta) => {
    var _option$label2;

    // For newly created custom value we don't want to add highlight
    if (option['__isNew__']) {
      return option.label;
    }

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)((react_highlight_words__WEBPACK_IMPORTED_MODULE_2___default()), {
      searchWords: meta.inputValue.split(splitSeparator),
      textToHighlight: (_option$label2 = option.label) !== null && _option$label2 !== void 0 ? _option$label2 : '',
      highlightClassName: styles.highlight
    });
  }, [styles.highlight]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_4__.EditorFieldGroup, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_4__.EditorField, {
      label: "Metric",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Select, {
        inputId: "prometheus-metric-select",
        className: styles.select,
        value: query.metric ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.toOption)(query.metric) : undefined,
        placeholder: "Select metric",
        allowCustomValue: true,
        formatOptionLabel: formatOptionLabel,
        filterOption: customFilterOption,
        onOpenMenu: async () => {
          setState({
            isLoading: true
          });
          const metrics = await onGetMetrics();
          setState({
            metrics,
            isLoading: undefined
          });
        },
        isLoading: state.isLoading,
        options: state.metrics,
        onChange: ({
          value
        }) => {
          if (value) {
            onChange(Object.assign({}, query, {
              metric: value
            }));
          }
        }
      })
    })
  });
}

const getStyles = theme => ({
  select: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    min-width: 125px;
  `,
  highlight: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    label: select__match-highlight;
    background: inherit;
    padding: inherit;
    color: ${theme.colors.warning.contrastText};
    background-color: ${theme.colors.warning.main};
  `
});

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQuery.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQuery": () => (/* binding */ NestedQuery)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _PromQueryBuilder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilder.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;










const NestedQuery = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  nestedQuery,
  index,
  datasource,
  onChange,
  onRemove,
  onRunQuery
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
    className: styles.card,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
      className: styles.header,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.name,
        children: "Operator"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
        width: "auto",
        options: operators,
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)(nestedQuery.operator),
        onChange: value => {
          onChange(index, Object.assign({}, nestedQuery, {
            operator: value.value
          }));
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.name,
        children: "Vector matches"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.vectorMatchWrapper,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
          width: "auto",
          value: nestedQuery.vectorMatchesType || 'on',
          allowCustomValue: true,
          options: [{
            value: 'on',
            label: 'on'
          }, {
            value: 'ignoring',
            label: 'ignoring'
          }],
          onChange: val => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatchesType: val.value
            }));
          }
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.AutoSizeInput, {
          className: styles.vectorMatchInput,
          minWidth: 20,
          defaultValue: nestedQuery.vectorMatches,
          onCommitChange: evt => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatches: evt.currentTarget.value,
              vectorMatchesType: nestedQuery.vectorMatchesType || 'on'
            }));
          }
        })]
      }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.IconButton, {
        name: "times",
        size: "sm",
        onClick: () => onRemove(index)
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
      className: styles.body,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorRows, {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromQueryBuilder__WEBPACK_IMPORTED_MODULE_6__.PromQueryBuilder, {
          query: nestedQuery.query,
          datasource: datasource,
          nested: true,
          onRunQuery: onRunQuery,
          onChange: update => {
            onChange(index, Object.assign({}, nestedQuery, {
              query: update
            }));
          }
        })
      })
    })]
  });
});
const operators = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_5__.binaryScalarDefs.map(def => ({
  label: def.sign,
  value: def.sign
}));
NestedQuery.displayName = 'NestedQuery';

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'card',
      display: 'flex',
      flexDirection: 'column',
      gap: theme.spacing(0.5)
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'header',
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      gap: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    name: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'name',
      whiteSpace: 'nowrap'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'body',
      paddingLeft: theme.spacing(2)
    }),
    vectorMatchInput: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchInput',
      marginLeft: -1
    }),
    vectorMatchWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchWrapper',
      display: 'flex'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQueryList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQueryList": () => (/* binding */ NestedQueryList)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _NestedQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQuery.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




function NestedQueryList({
  query,
  datasource,
  onChange,
  onRunQuery
}) {
  var _query$binaryQueries;

  const nestedQueries = (_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : [];

  const onNestedQueryUpdate = (index, update) => {
    const updatedList = [...nestedQueries];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...nestedQueries.slice(0, index), ...nestedQueries.slice(index + 1)];
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    direction: "column",
    gap: 1,
    children: nestedQueries.map((nestedQuery, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_NestedQuery__WEBPACK_IMPORTED_MODULE_2__.NestedQuery, {
      nestedQuery: nestedQuery,
      index: index,
      onChange: onNestedQueryUpdate,
      datasource: datasource,
      onRemove: onRemove,
      onRunQuery: onRunQuery
    }, index.toString()))
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilder.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilder": () => (/* binding */ PromQueryBuilder)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _shared_LabelFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx");
/* harmony import */ var _shared_OperationList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx");
/* harmony import */ var _shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx");
/* harmony import */ var _MetricSelect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/MetricSelect.tsx");
/* harmony import */ var _NestedQueryList__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQueryList.tsx");
/* harmony import */ var _PromQueryBuilderHints__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderHints.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");













const PromQueryBuilder = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  datasource,
  query,
  onChange,
  onRunQuery,
  data
}) => {
  const onChangeLabels = labels => {
    onChange(Object.assign({}, query, {
      labels
    }));
  };
  /**
   * Map metric metadata to SelectableValue for Select component and also adds defined template variables to the list.
   */


  const withTemplateVariableOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async optionsPromise => {
    const variables = datasource.getVariables();
    const options = await optionsPromise;
    return [...variables.map(value => ({
      label: value,
      value
    })), ...options.map(option => ({
      label: option.value,
      value: option.value,
      title: option.description
    }))];
  }, [datasource]);

  const onGetLabelNames = async forLabel => {
    // If no metric we need to use a different method
    if (!query.metric) {
      // Todo add caching but inside language provider!
      await datasource.languageProvider.fetchLabels();
      return datasource.languageProvider.getLabelKeys().map(k => ({
        value: k
      }));
    }

    const labelsToConsider = query.labels.filter(x => x !== forLabel);
    labelsToConsider.push({
      label: '__name__',
      op: '=',
      value: query.metric
    });
    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderLabels(labelsToConsider);
    const labelsIndex = await datasource.languageProvider.fetchSeriesLabels(expr); // filter out already used labels

    return Object.keys(labelsIndex).filter(labelName => !labelsToConsider.find(filter => filter.label === labelName)).map(k => ({
      value: k
    }));
  };

  const onGetLabelValues = async forLabel => {
    var _result$forLabelInter;

    if (!forLabel.label) {
      return [];
    } // If no metric we need to use a different method


    if (!query.metric) {
      return (await datasource.languageProvider.getLabelValues(forLabel.label)).map(v => ({
        value: v
      }));
    }

    const labelsToConsider = query.labels.filter(x => x !== forLabel);
    labelsToConsider.push({
      label: '__name__',
      op: '=',
      value: query.metric
    });
    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderLabels(labelsToConsider);
    const result = await datasource.languageProvider.fetchSeriesLabels(expr);
    const forLabelInterpolated = datasource.interpolateString(forLabel.label);
    return (_result$forLabelInter = result[forLabelInterpolated].map(v => ({
      value: v
    }))) !== null && _result$forLabelInter !== void 0 ? _result$forLabelInter : [];
  };

  const onGetMetrics = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    return withTemplateVariableOptions(getMetrics(datasource, query));
  }, [datasource, query, withTemplateVariableOptions]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_MetricSelect__WEBPACK_IMPORTED_MODULE_7__.MetricSelect, {
        query: query,
        onChange: onChange,
        onGetMetrics: onGetMetrics
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_shared_LabelFilters__WEBPACK_IMPORTED_MODULE_4__.LabelFilters, {
        labelsFilters: query.labels,
        onChange: onChangeLabels,
        onGetLabelNames: forLabel => withTemplateVariableOptions(onGetLabelNames(forLabel)),
        onGetLabelValues: forLabel => withTemplateVariableOptions(onGetLabelValues(forLabel))
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsxs)(_shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_6__.OperationsEditorRow, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_shared_OperationList__WEBPACK_IMPORTED_MODULE_5__.OperationList, {
        queryModeller: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller,
        datasource: datasource,
        query: query,
        onChange: onChange,
        onRunQuery: onRunQuery
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_PromQueryBuilderHints__WEBPACK_IMPORTED_MODULE_9__.PromQueryBuilderHints, {
        datasource: datasource,
        query: query,
        onChange: onChange,
        data: data
      })]
    }), query.binaryQueries && query.binaryQueries.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_NestedQueryList__WEBPACK_IMPORTED_MODULE_8__.NestedQueryList, {
      query: query,
      datasource: datasource,
      onChange: onChange,
      onRunQuery: onRunQuery
    })]
  });
});
/**
 * Returns list of metrics, either all or filtered by query param. It also adds description string to each metric if it
 * exists.
 * @param datasource
 * @param query
 */

async function getMetrics(datasource, query) {
  // Makes sure we loaded the metadata for metrics. Usually this is done in the start() method of the provider but we
  // don't use it with the visual builder and there is no need to run all the start() setup anyway.
  if (!datasource.languageProvider.metricsMetadata) {
    await datasource.languageProvider.loadMetricsMetadata();
  }

  let metrics;

  if (query.labels.length > 0) {
    var _await$datasource$lan;

    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderLabels(query.labels);
    metrics = (_await$datasource$lan = (await datasource.languageProvider.getSeries(expr, true))['__name__']) !== null && _await$datasource$lan !== void 0 ? _await$datasource$lan : [];
  } else {
    var _await$datasource$lan2;

    metrics = (_await$datasource$lan2 = await datasource.languageProvider.getLabelValues('__name__')) !== null && _await$datasource$lan2 !== void 0 ? _await$datasource$lan2 : [];
  }

  return metrics.map(m => ({
    value: m,
    description: (0,_language_provider__WEBPACK_IMPORTED_MODULE_2__.getMetadataString)(m, datasource.languageProvider.metricsMetadata)
  }));
}

PromQueryBuilder.displayName = 'PromQueryBuilder';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderContainer.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderContainer": () => (/* binding */ PromQueryBuilderContainer)
/* harmony export */ });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/@reduxjs-toolkit-virtual-6cd1e25811/0/cache/@reduxjs-toolkit-npm-1.8.1-cf386ae48d-be5cdea975.zip/node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var _PromQueryBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilder.tsx");
/* harmony import */ var _QueryPreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/QueryPreview.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










/**
 * This component is here just to contain the translation logic between string query and the visual query builder model.
 */
function PromQueryBuilderContainer(props) {
  const {
    query,
    onChange,
    onRunQuery,
    datasource,
    data,
    showRawQuery
  } = props;
  const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(stateSlice.reducer, {
    expr: query.expr
  }); // Only rebuild visual query if expr changes from outside

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    dispatch(exprChanged(query.expr));
  }, [query.expr]);

  const onVisQueryChange = visQuery => {
    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__.promQueryModeller.renderQuery(visQuery);
    dispatch(visualQueryChange({
      visQuery,
      expr
    }));
    onChange(Object.assign({}, props.query, {
      expr: expr
    }));
  };

  if (!state.visQuery) {
    return null;
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_PromQueryBuilder__WEBPACK_IMPORTED_MODULE_3__.PromQueryBuilder, {
      query: state.visQuery,
      datasource: datasource,
      onChange: onVisQueryChange,
      onRunQuery: onRunQuery,
      data: data
    }), showRawQuery && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_QueryPreview__WEBPACK_IMPORTED_MODULE_4__.QueryPreview, {
      query: query.expr
    })]
  });
}
const stateSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__.createSlice)({
  name: 'prom-builder-container',
  initialState: {
    expr: ''
  },
  reducers: {
    visualQueryChange: (state, action) => {
      state.expr = action.payload.expr;
      state.visQuery = action.payload.visQuery;
    },
    exprChanged: (state, action) => {
      if (!state.visQuery || state.expr !== action.payload) {
        state.expr = action.payload;
        const parseResult = (0,_parsing__WEBPACK_IMPORTED_MODULE_2__.buildVisualQueryFromString)(action.payload);
        state.visQuery = parseResult.query;
      }
    }
  }
});
const {
  visualQueryChange,
  exprChanged
} = stateSlice.actions;

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderExplained.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderExplained": () => (/* binding */ PromQueryBuilderExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var _shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var _shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx");
/* harmony import */ var _shared_RawQuery__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/RawQuery.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










const PromQueryBuilderExplained = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  query
}) => {
  const visQuery = (0,_parsing__WEBPACK_IMPORTED_MODULE_4__.buildVisualQueryFromString)(query || '').query;
  const lang = {
    grammar: _promql__WEBPACK_IMPORTED_MODULE_2__["default"],
    name: 'promql'
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    gap: 0.5,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_5__.OperationExplainedBox, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_shared_RawQuery__WEBPACK_IMPORTED_MODULE_7__.RawQuery, {
        query: query,
        lang: lang
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_5__.OperationExplainedBox, {
      stepNumber: 1,
      title: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_shared_RawQuery__WEBPACK_IMPORTED_MODULE_7__.RawQuery, {
        query: `${visQuery.metric} ${_PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderLabels(visQuery.labels)}`,
        lang: lang
      }),
      children: "Fetch all series matching metric name and label filters."
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_6__.OperationListExplained, {
      stepNumber: 2,
      queryModeller: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller,
      query: visQuery,
      lang: lang
    })]
  });
});
PromQueryBuilderExplained.displayName = 'PromQueryBuilderExplained';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderHints.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderHints": () => (/* binding */ PromQueryBuilderHints)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







const PromQueryBuilderHints = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  datasource,
  query,
  onChange,
  data
}) => {
  const [hints, setHints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    const promQuery = {
      expr: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderQuery(query),
      refId: ''
    }; // For now show only actionable hints

    const hints = datasource.getQueryHints(promQuery, (data === null || data === void 0 ? void 0 : data.series) || []).filter(hint => {
      var _hint$fix;

      return (_hint$fix = hint.fix) === null || _hint$fix === void 0 ? void 0 : _hint$fix.action;
    });
    setHints(hints);
  }, [datasource, query, onChange, data, styles.hint]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: hints.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: styles.container,
      children: hints.map(hint => {
        var _hint$fix2, _hint$fix3, _hint$fix3$action;

        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Tooltip, {
          content: `${hint.label} ${(_hint$fix2 = hint.fix) === null || _hint$fix2 === void 0 ? void 0 : _hint$fix2.label}`,
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            onClick: () => {
              const promQuery = {
                expr: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderQuery(query),
                refId: ''
              };
              const newPromQuery = datasource.modifyQuery(promQuery, hint.fix.action);
              const visualQuery = (0,_parsing__WEBPACK_IMPORTED_MODULE_4__.buildVisualQueryFromString)(newPromQuery.expr);
              return onChange(visualQuery.query);
            },
            fill: "outline",
            size: "sm",
            className: styles.hint,
            children: 'hint: ' + ((_hint$fix3 = hint.fix) === null || _hint$fix3 === void 0 ? void 0 : (_hint$fix3$action = _hint$fix3.action) === null || _hint$fix3$action === void 0 ? void 0 : _hint$fix3$action.type.toLowerCase().replace('_', ' ')) + '()'
          })
        }, hint.type);
      })
    })
  });
});
PromQueryBuilderHints.displayName = 'PromQueryBuilderHints';

const getStyles = theme => {
  return {
    container: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      display: flex;
      margin-bottom: ${theme.spacing(1)};
      align-items: center;
    `,
    hint: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      margin-right: ${theme.spacing(1)};
    `
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderOptions.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderOptions": () => (/* binding */ PromQueryBuilderOptions)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _components_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx");
/* harmony import */ var _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx");
/* harmony import */ var _shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx");
/* harmony import */ var _PromQueryLegendEditor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryLegendEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _code, _code2;












const PromQueryBuilderOptions = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  query,
  app,
  onChange,
  onRunQuery
}) => {
  const onChangeFormat = value => {
    onChange(Object.assign({}, query, {
      format: value.value
    }));
    onRunQuery();
  };

  const onChangeStep = evt => {
    onChange(Object.assign({}, query, {
      interval: evt.currentTarget.value
    }));
    onRunQuery();
  };

  const queryTypeOptions = (0,_components_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_4__.getQueryTypeOptions)(app === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore);
  const onQueryTypeChange = (0,_components_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_4__.getQueryTypeChangeHandler)(query, onChange);

  const onExemplarChange = event => {
    const isEnabled = event.currentTarget.checked;
    onChange(Object.assign({}, query, {
      exemplar: isEnabled
    }));
    onRunQuery();
  };

  const onIntervalFactorChange = value => {
    onChange(Object.assign({}, query, {
      intervalFactor: value.value
    }));
    onRunQuery();
  };

  const formatOption = _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.FORMAT_OPTIONS.find(option => option.value === query.format) || _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.FORMAT_OPTIONS[0];
  const queryTypeValue = getQueryTypeValue(query);
  const queryTypeLabel = queryTypeOptions.find(x => x.value === queryTypeValue).label;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorRow, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)(_shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_6__.QueryOptionGroup, {
      title: "Options",
      collapsedInfo: getCollapsedInfo(query, formatOption.label, queryTypeLabel),
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_PromQueryLegendEditor__WEBPACK_IMPORTED_MODULE_7__.PromQueryLegendEditor, {
        legendFormat: query.legendFormat,
        onChange: legendFormat => onChange(Object.assign({}, query, {
          legendFormat
        })),
        onRunQuery: onRunQuery
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
        label: "Min step",
        tooltip: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.Fragment, {
          children: ["An additional lower limit for the step parameter of the Prometheus query and for the", ' ', _code || (_code = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("code", {
            children: "$__interval"
          })), " and ", _code2 || (_code2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("code", {
            children: "$__rate_interval"
          })), " variables."]
        }),
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.AutoSizeInput, {
          type: "text",
          "aria-label": "Set lower limit for the step parameter",
          placeholder: 'auto',
          minWidth: 10,
          onCommitChange: onChangeStep,
          defaultValue: query.interval
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
        label: "Format",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
          value: formatOption,
          allowCustomValue: true,
          onChange: onChangeFormat,
          options: _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.FORMAT_OPTIONS
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
        label: "Type",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.RadioButtonGroup, {
          options: queryTypeOptions,
          value: queryTypeValue,
          onChange: onQueryTypeChange
        })
      }), shouldShowExemplarSwitch(query, app) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
        label: "Exemplars",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorSwitch, {
          value: query.exemplar,
          onChange: onExemplarChange
        })
      }), query.intervalFactor && query.intervalFactor > 1 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
        label: "Resolution",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
          "aria-label": "Select resolution",
          isSearchable: false,
          options: _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.INTERVAL_FACTOR_OPTIONS,
          onChange: onIntervalFactorChange,
          value: _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.INTERVAL_FACTOR_OPTIONS.find(option => option.value === query.intervalFactor)
        })
      })]
    })
  });
});

function shouldShowExemplarSwitch(query, app) {
  if (app === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.UnifiedAlerting || !query.range) {
    return false;
  }

  return true;
}

function getQueryTypeValue(query) {
  return query.range && query.instant ? 'both' : query.instant ? 'instant' : 'range';
}

function getCollapsedInfo(query, formatOption, queryType) {
  var _query$interval;

  const items = [];
  items.push(`Legend: ${(0,_PromQueryLegendEditor__WEBPACK_IMPORTED_MODULE_7__.getLegendModeLabel)(query.legendFormat)}`);
  items.push(`Format: ${formatOption}`);
  items.push(`Step: ${(_query$interval = query.interval) !== null && _query$interval !== void 0 ? _query$interval : 'auto'}`);
  items.push(`Type: ${queryType}`);

  if (query.exemplar) {
    items.push(`Exemplars: true`);
  }

  return items;
}

PromQueryBuilderOptions.displayName = 'PromQueryBuilderOptions';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryCodeEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryCodeEditor": () => (/* binding */ PromQueryCodeEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx");
/* harmony import */ var _components_PromQueryField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function PromQueryCodeEditor({
  query,
  datasource,
  range,
  onRunQuery,
  onChange,
  data,
  app
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
    className: styles.wrapper,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_components_PromQueryField__WEBPACK_IMPORTED_MODULE_4__["default"], {
      datasource: datasource,
      query: query,
      range: range,
      onRunQuery: onRunQuery,
      onChange: onChange,
      history: [],
      data: data,
      "data-testid": _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_3__.testIds.editor,
      app: app
    })
  });
}

const getStyles = theme => {
  return {
    // This wrapper styling can be removed after the old PromQueryEditor is removed.
    // This is removing margin bottom on the old legacy inline form styles
    wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      .gf-form {
        margin-bottom: 0;
      }
    `
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryEditorSelector.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryEditorSelector": () => (/* binding */ PromQueryEditorSelector)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var _shared_FeedbackLink__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/FeedbackLink.tsx");
/* harmony import */ var _shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx");
/* harmony import */ var _shared_QueryHeaderSwitch__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryHeaderSwitch.tsx");
/* harmony import */ var _shared_types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/state.ts");
/* harmony import */ var _PromQueryBuilderContainer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderContainer.tsx");
/* harmony import */ var _PromQueryBuilderExplained__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderExplained.tsx");
/* harmony import */ var _PromQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderOptions.tsx");
/* harmony import */ var _PromQueryCodeEditor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryCodeEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FeedbackLink, _FlexItem, _Space;




















const PromQueryEditorSelector = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(props => {
  const {
    onChange,
    onRunQuery,
    data,
    app
  } = props;
  const [parseModalOpen, setParseModalOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [dataIsStale, setDataIsStale] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const query = (0,_state__WEBPACK_IMPORTED_MODULE_11__.getQueryWithDefaults)(props.query, app);
  const [rawQuery, setRawQuery] = (0,_state__WEBPACK_IMPORTED_MODULE_11__.useRawQuery)(); // This should be filled in from the defaults by now.

  const editorMode = query.editorMode;
  const onEditorModeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(newMetricEditorMode => {
    var _query$editorMode;

    (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.reportInteraction)('user_grafana_prometheus_editor_mode_clicked', {
      newEditor: newMetricEditorMode,
      previousEditor: (_query$editorMode = query.editorMode) !== null && _query$editorMode !== void 0 ? _query$editorMode : '',
      newQuery: !query.expr,
      app: app !== null && app !== void 0 ? app : ''
    });

    if (newMetricEditorMode === _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Builder) {
      const result = (0,_parsing__WEBPACK_IMPORTED_MODULE_6__.buildVisualQueryFromString)(query.expr || ''); // If there are errors, give user a chance to decide if they want to go to builder as that can loose some data.

      if (result.errors.length) {
        setParseModalOpen(true);
        return;
      }
    }

    (0,_state__WEBPACK_IMPORTED_MODULE_11__.changeEditorMode)(query, newMetricEditorMode, onChange);
  }, [onChange, query, app]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    setDataIsStale(false);
  }, [data]);

  const onQueryPreviewChange = event => {
    const isEnabled = event.currentTarget.checked;
    setRawQuery(isEnabled);
  };

  const onChangeInternal = query => {
    setDataIsStale(true);
    onChange(query);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.ConfirmModal, {
      isOpen: parseModalOpen,
      title: "Query parsing",
      body: "There were errors while trying to parse the query. Continuing to visual builder may loose some parts of the query.",
      confirmText: "Continue",
      onConfirm: () => {
        (0,_state__WEBPACK_IMPORTED_MODULE_11__.changeEditorMode)(query, _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Builder, onChange);
        setParseModalOpen(false);
      },
      onDismiss: () => setParseModalOpen(false)
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorHeader, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.InlineSelect, {
        value: null,
        placeholder: "Query patterns",
        allowCustomValue: true,
        onChange: ({
          value
        }) => {
          // TODO: Bit convoluted as we don't have access to visualQuery model here. Maybe would make sense to
          //  move it inside the editor?
          const result = (0,_parsing__WEBPACK_IMPORTED_MODULE_6__.buildVisualQueryFromString)(query.expr || '');
          result.query.operations = value === null || value === void 0 ? void 0 : value.operations;
          onChange(Object.assign({}, query, {
            expr: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_5__.promQueryModeller.renderQuery(result.query)
          }));
        },
        options: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_5__.promQueryModeller.getQueryPatterns().map(x => ({
          label: x.name,
          value: x
        }))
      }), editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Builder && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_shared_QueryHeaderSwitch__WEBPACK_IMPORTED_MODULE_9__.QueryHeaderSwitch, {
          label: "Raw query",
          value: rawQuery,
          onChange: onQueryPreviewChange
        }), _FeedbackLink || (_FeedbackLink = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_shared_FeedbackLink__WEBPACK_IMPORTED_MODULE_7__.FeedbackLink, {
          feedbackUrl: "https://github.com/grafana/grafana/discussions/47693"
        }))]
      }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), app !== _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
        variant: dataIsStale ? 'primary' : 'secondary',
        size: "sm",
        onClick: onRunQuery,
        icon: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading ? 'fa fa-spinner' : undefined,
        disabled: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading,
        children: "Run queries"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_8__.QueryEditorModeToggle, {
        mode: editorMode,
        onChange: onEditorModeChange
      })]
    }), _Space || (_Space = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Space, {
      v: 0.5
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorRows, {
      children: [editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Code && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_PromQueryCodeEditor__WEBPACK_IMPORTED_MODULE_15__.PromQueryCodeEditor, Object.assign({}, props)), editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Builder && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_PromQueryBuilderContainer__WEBPACK_IMPORTED_MODULE_12__.PromQueryBuilderContainer, {
        query: query,
        datasource: props.datasource,
        onChange: onChangeInternal,
        onRunQuery: props.onRunQuery,
        data: data,
        showRawQuery: rawQuery
      }), editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_PromQueryBuilderExplained__WEBPACK_IMPORTED_MODULE_13__.PromQueryBuilderExplained, {
        query: query.expr
      }), editorMode !== _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_PromQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_14__.PromQueryBuilderOptions, {
        query: query,
        app: props.app,
        onChange: onChange,
        onRunQuery: onRunQuery
      })]
    })]
  });
});
PromQueryEditorSelector.displayName = 'PromQueryEditorSelector';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryLegendEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryLegendEditor": () => (/* binding */ PromQueryLegendEditor),
/* harmony export */   "getLegendModeLabel": () => (/* binding */ getLegendModeLabel)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







const legendModeOptions = [{
  label: 'Auto',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto,
  description: 'Only includes unique labels'
}, {
  label: 'Verbose',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Verbose,
  description: 'All label names and values'
}, {
  label: 'Custom',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom,
  description: 'Provide a naming template'
}];
/**
 * Tests for this component are on the parent level (PromQueryBuilderOptions).
 */

const PromQueryLegendEditor = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  legendFormat,
  onChange,
  onRunQuery
}) => {
  const mode = getLegendMode(legendFormat);
  const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);

  const onLegendFormatChanged = evt => {
    let newFormat = evt.currentTarget.value;

    if (newFormat.length === 0) {
      newFormat = _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto;
    }

    if (newFormat !== legendFormat) {
      onChange(newFormat);
      onRunQuery();
    }
  };

  const onLegendModeChanged = value => {
    switch (value.value) {
      case _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto:
        onChange(_types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto);
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom:
        onChange('{{label_name}}');
        setTimeout(() => {
          var _inputRef$current, _inputRef$current2;

          (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
          (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.setSelectionRange(2, 12, 'forward');
        }, 10);
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Verbose:
        onChange('');
        break;
    }

    onRunQuery();
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
    label: "Legend",
    tooltip: "Series name override or template. Ex. {{hostname}} will be replaced with label value for hostname.",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
      children: [mode === _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.AutoSizeInput, {
        id: "legendFormat",
        minWidth: 22,
        placeholder: "auto",
        defaultValue: legendFormat,
        onCommitChange: onLegendFormatChanged,
        ref: inputRef
      }), mode !== _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
        inputId: "legend.mode",
        isSearchable: false,
        placeholder: "Select legend mode",
        options: legendModeOptions,
        width: 22,
        onChange: onLegendModeChanged,
        value: legendModeOptions.find(x => x.value === mode)
      })]
    })
  });
});
PromQueryLegendEditor.displayName = 'PromQueryLegendEditor';

function getLegendMode(legendFormat) {
  // This special value means the new smart minimal series naming
  if (legendFormat === _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto) {
    return _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto;
  } // Missing or empty legend format is the old verbose behavior


  if (legendFormat == null || legendFormat === '') {
    return _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Verbose;
  }

  return _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom;
}

function getLegendModeLabel(legendFormat) {
  const mode = getLegendMode(legendFormat);

  if (mode !== _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom) {
    var _legendModeOptions$fi;

    return (_legendModeOptions$fi = legendModeOptions.find(x => x.value === mode)) === null || _legendModeOptions$fi === void 0 ? void 0 : _legendModeOptions$fi.label;
  }

  return legendFormat;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/QueryPreview.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryPreview": () => (/* binding */ QueryPreview)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
/* harmony import */ var _shared_RawQuery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/RawQuery.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function QueryPreview({
  query
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorFieldGroup, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Raw query",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_shared_RawQuery__WEBPACK_IMPORTED_MODULE_3__.RawQuery, {
          query: query,
          lang: {
            grammar: _promql__WEBPACK_IMPORTED_MODULE_2__["default"],
            name: 'promql'
          }
        })
      })
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/operations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addOperationWithRangeVector": () => (/* binding */ addOperationWithRangeVector),
/* harmony export */   "createFunction": () => (/* binding */ createFunction),
/* harmony export */   "createRangeFunction": () => (/* binding */ createRangeFunction),
/* harmony export */   "getOperationDefinitions": () => (/* binding */ getOperationDefinitions),
/* harmony export */   "operationWithRangeVectorRenderer": () => (/* binding */ operationWithRangeVectorRenderer)
/* harmony export */ });
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");




function getOperationDefinitions() {
  const list = [{
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.HistogramQuantile,
    name: 'Histogram quantile',
    params: [{
      name: 'Quantile',
      type: 'number',
      options: [0.99, 0.95, 0.9, 0.75, 0.5, 0.25]
    }],
    defaultParams: [0.9],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.LabelReplace,
    name: 'Label replace',
    params: [{
      name: 'Destination label',
      type: 'string'
    }, {
      name: 'Replacement',
      type: 'string'
    }, {
      name: 'Source label',
      type: 'string'
    }, {
      name: 'Regex',
      type: 'string'
    }],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    defaultParams: ['', '$1', '', '(.*)'],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererRight,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Ln,
    name: 'Ln',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Changes), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Rate, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Irate), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Increase, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Idelta), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Delta), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.HoltWinters,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Smoothing Factor',
      type: 'number'
    }, {
      name: 'Trend Factor',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5, 0.5],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.PredictLinear,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Seconds from now',
      type: 'number'
    }],
    defaultParams: ['$__interval', 60],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.QuantileOverTime,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Quantile',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererLeftWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), ..._binaryScalarOperations__WEBPACK_IMPORTED_MODULE_0__.binaryScalarOperations, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.NestedQuery,
    name: 'Binary operation with query',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: (model, def, innerExpr) => innerExpr,
    addOperationHandler: addNestedQueryHandler
  }, createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Absent
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Acos,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Acosh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Asin,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Asinh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Atan,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Atanh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Ceil
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Clamp,
    name: 'Clamp',
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }, {
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1, 1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.ClampMax,
    params: [{
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.ClampMin,
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Cos,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Cosh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DayOfMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DayOfWeek,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DaysInMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Deg
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Deriv), //
  createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Exp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Floor
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Group
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Hour
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.LabelJoin,
    params: [{
      name: 'Destination Label',
      type: 'string',
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }, {
      name: 'Separator',
      type: 'string'
    }, {
      name: 'Source Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }],
    defaultParams: ['', ',', ''],
    renderer: labelJoinRenderer,
    addOperationHandler: labelJoinAddOperationHandler
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Log10
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Log2
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Minute
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Month
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Pi,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Quantile,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Rad
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Resets), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Round,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    params: [{
      name: 'To Nearest',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Scalar
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sgn
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sin,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sinh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sort
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.SortDesc
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sqrt
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Stddev
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Tan,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Tanh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Time,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Timestamp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Vector,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: model => `${model.id}(${model.params[0]})`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Year
  })];
  return list;
}
function createFunction(definition) {
  var _definition$name, _definition$params, _definition$defaultPa, _definition$category, _definition$renderer, _definition$addOperat;

  return Object.assign({}, definition, {
    id: definition.id,
    name: (_definition$name = definition.name) !== null && _definition$name !== void 0 ? _definition$name : (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getPromAndLokiOperationDisplayName)(definition.id),
    params: (_definition$params = definition.params) !== null && _definition$params !== void 0 ? _definition$params : [],
    defaultParams: (_definition$defaultPa = definition.defaultParams) !== null && _definition$defaultPa !== void 0 ? _definition$defaultPa : [],
    category: (_definition$category = definition.category) !== null && _definition$category !== void 0 ? _definition$category : _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: (_definition$renderer = definition.renderer) !== null && _definition$renderer !== void 0 ? _definition$renderer : definition.params ? _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererRight : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: (_definition$addOperat = definition.addOperationHandler) !== null && _definition$addOperat !== void 0 ? _definition$addOperat : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  });
}
function createRangeFunction(name, withRateInterval = false) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(withRateInterval)],
    defaultParams: [withRateInterval ? '$__rate_interval' : '$__interval'],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  };
}

function operationTypeChangedHandlerForRangeFunction(operation, newDef) {
  // validate current parameter
  if (operation.params[0] === '$__rate_interval' && newDef.defaultParams[0] !== '$__rate_interval') {
    operation.params = newDef.defaultParams;
  } else if (operation.params[0] === '$__interval' && newDef.defaultParams[0] !== '$__interval') {
    operation.params = newDef.defaultParams;
  }

  return operation;
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}
/**
 * Since there can only be one operation with range vector this will replace the current one (if one was added )
 */

function addOperationWithRangeVector(def, query, modeller) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };

  if (query.operations.length > 0) {
    // If operation exists it has to be in the registry so no point to check if it was found
    const firstOp = modeller.getOperationDef(query.operations[0].id);

    if (firstOp.addOperationHandler === addOperationWithRangeVector) {
      return Object.assign({}, query, {
        operations: [newOperation, ...query.operations.slice(1)]
      });
    }
  }

  return Object.assign({}, query, {
    operations: [newOperation, ...query.operations]
  });
}

function addNestedQueryHandler(def, query) {
  var _query$binaryQueries;

  return Object.assign({}, query, {
    binaryQueries: [...((_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : []), {
      operator: '/',
      query
    }]
  });
}

function labelJoinRenderer(model, def, innerExpr) {
  if (typeof model.params[1] !== 'string') {
    throw 'The separator must be a string';
  }

  const separator = `"${model.params[1]}"`;
  return `${model.id}(${innerExpr}, "${model.params[0]}", ${separator}, "${model.params.slice(2).join(separator)}")`;
}

function labelJoinAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildVisualQueryFromString": () => (/* binding */ buildVisualQueryFromString),
/* harmony export */   "handleExpression": () => (/* binding */ handleExpression)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts");




/**
 * Parses a PromQL query into a visual query model.
 *
 * It traverses the tree and uses sort of state machine to update the query model. The query model is modified
 * during the traversal and sent to each handler as context.
 *
 * @param expr
 */
function buildVisualQueryFromString(expr) {
  const replacedExpr = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.replaceVariables)(expr);
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(replacedExpr);
  const node = tree.topNode; // This will be modified in the handlers.

  const visQuery = {
    metric: '',
    labels: [],
    operations: []
  };
  const context = {
    query: visQuery,
    errors: []
  };

  try {
    handleExpression(replacedExpr, node, context);
  } catch (err) {
    // Not ideal to log it here, but otherwise we would lose the stack trace.
    console.error(err);

    if (err instanceof Error) {
      context.errors.push({
        text: err.message
      });
    }
  } // If we have empty query, we want to reset errors


  if (isEmptyQuery(context.query)) {
    context.errors = [];
  }

  return context;
}

/**
 * Handler for default state. It will traverse the tree and call the appropriate handler for each node. The node
 * handled here does not necessarily need to be of type == Expr.
 * @param expr
 * @param node
 * @param context
 */
function handleExpression(expr, node, context) {
  const visQuery = context.query;

  switch (node.name) {
    case 'MetricIdentifier':
      {
        // Expectation is that there is only one of those per query.
        visQuery.metric = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node);
        break;
      }

    case 'LabelMatcher':
      {
        // Same as MetricIdentifier should be just one per query.
        visQuery.labels.push(getLabel(expr, node));
        const err = node.getChild(_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName);

        if (err) {
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, err));
        }

        break;
      }

    case 'FunctionCall':
      {
        handleFunction(expr, node, context);
        break;
      }

    case 'AggregateExpr':
      {
        handleAggregation(expr, node, context);
        break;
      }

    case 'BinaryExpr':
      {
        handleBinary(expr, node, context);
        break;
      }

    case _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName:
      {
        if (isIntervalVariableError(node)) {
          break;
        }

        context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        break;
      }

    default:
      {
        if (node.name === 'ParenExpr') {
          // We don't support parenthesis in the query to group expressions. We just report error but go on with the
          // parsing.
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        } // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper
        // nodes that can be skipped.
        // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to
        //  detect those and report back.


        let child = node.firstChild;

        while (child) {
          handleExpression(expr, child, context);
          child = child.nextSibling;
        }
      }
  }
}

function isIntervalVariableError(node) {
  var _node$prevSibling, _node$prevSibling2, _node$prevSibling2$fi;

  return ((_node$prevSibling = node.prevSibling) === null || _node$prevSibling === void 0 ? void 0 : _node$prevSibling.name) === 'Expr' && ((_node$prevSibling2 = node.prevSibling) === null || _node$prevSibling2 === void 0 ? void 0 : (_node$prevSibling2$fi = _node$prevSibling2.firstChild) === null || _node$prevSibling2$fi === void 0 ? void 0 : _node$prevSibling2$fi.name) === 'VectorSelector';
}

function getLabel(expr, node) {
  const label = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('LabelName'));
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('MatchOp'));
  const value = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('StringLiteral')).replace(/"/g, '');
  return {
    label,
    op,
    value
  };
}

const rangeFunctions = ['changes', 'rate', 'irate', 'increase', 'delta'];
/**
 * Handle function call which is usually and identifier and its body > arguments.
 * @param expr
 * @param node
 * @param context
 */

function handleFunction(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('FunctionIdentifier');
  const funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const params = [];
  let interval = ''; // This is a bit of a shortcut to get the interval argument. Reasons are
  // - interval is not part of the function args per promQL grammar but we model it as argument for the function in
  //   the query model.
  // - it is easier to handle template variables this way as template variable is an error for the parser

  if (rangeFunctions.includes(funcName) || funcName.endsWith('_over_time')) {
    let match = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).match(/\[(.+)\]/);

    if (match !== null && match !== void 0 && match[1]) {
      interval = match[1];
      params.push(match[1]);
    }
  }

  const op = {
    id: funcName,
    params
  }; // We unshift operations to keep the more natural order that we want to have in the visual query editor.

  visQuery.operations.unshift(op);

  if (callArgs) {
    if ((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, callArgs) === interval + ']') {
      // This is a special case where we have a function with a single argument and it is the interval.
      // This happens when you start adding operations in query builder and did not set a metric yet.
      return;
    }

    updateFunctionArgs(expr, callArgs, context, op);
  }
}
/**
 * Handle aggregation as they are distinct type from other functions.
 * @param expr
 * @param node
 * @param context
 */


function handleAggregation(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('AggregateOp');
  let funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const modifier = node.getChild('AggregateModifier');
  const labels = [];

  if (modifier) {
    const byModifier = modifier.getChild(`By`);

    if (byModifier && funcName) {
      funcName = `__${funcName}_by`;
    }

    const withoutModifier = modifier.getChild(`Without`);

    if (withoutModifier) {
      funcName = `__${funcName}_without`;
    }

    labels.push(...(0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getAllByType)(expr, modifier, 'GroupingLabel'));
  }

  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const op = {
    id: funcName,
    params: []
  };
  visQuery.operations.unshift(op);
  updateFunctionArgs(expr, callArgs, context, op); // We add labels after params in the visual query editor.

  op.params.push(...labels);
}
/**
 * Handle (probably) all types of arguments that function or aggregation can have.
 *
 *  FunctionCallArgs are nested bit weirdly basically its [firstArg, ...rest] where rest is again FunctionCallArgs so
 *  we cannot just get all the children and iterate them as arguments we have to again recursively traverse through
 *  them.
 *
 * @param expr
 * @param node
 * @param context
 * @param op - We need the operation to add the params to as an additional context.
 */


function updateFunctionArgs(expr, node, context, op) {
  if (!node) {
    return;
  }

  switch (node.name) {
    // In case we have an expression we don't know what kind so we have to look at the child as it can be anything.
    case 'Expr': // FunctionCallArgs are nested bit weirdly as mentioned so we have to go one deeper in this case.

    case 'FunctionCallArgs':
      {
        let child = node.firstChild;

        while (child) {
          updateFunctionArgs(expr, child, context, op);
          child = child.nextSibling;
        }

        break;
      }

    case 'NumberLiteral':
      {
        op.params.push(parseFloat((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node)));
        break;
      }

    case 'StringLiteral':
      {
        op.params.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).replace(/"/g, ''));
        break;
      }

    default:
      {
        // Means we get to something that does not seem like simple function arg and is probably nested query so jump
        // back to main context
        handleExpression(expr, node, context);
      }
  }
}
/**
 * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is
 * just operation with scalar or it creates a binaryQuery when it's 2 queries.
 * @param expr
 * @param node
 * @param context
 */


function handleBinary(expr, node, context) {
  const visQuery = context.query;
  const left = node.firstChild;
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, left.nextSibling);
  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));
  const right = node.lastChild;
  const opDef = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__.binaryScalarOperatorToOperatorName[op];
  const leftNumber = left.getChild('NumberLiteral');
  const rightNumber = right.getChild('NumberLiteral');
  const rightBinary = right.getChild('BinaryExpr');

  if (leftNumber) {// TODO: this should be already handled in case parent is binary expression as it has to be added to parent
    //  if query starts with a number that isn't handled now.
  } else {
    // If this is binary we don't really know if there is a query or just chained scalars. So
    // we have to traverse a bit deeper to know
    handleExpression(expr, left, context);
  }

  if (rightNumber) {
    visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, right, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
  } else if (rightBinary) {
    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which
    // is a factor for a current binary operation. So we have to add it as an operation now.
    const leftMostChild = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getLeftMostChild)(right);

    if ((leftMostChild === null || leftMostChild === void 0 ? void 0 : leftMostChild.name) === 'NumberLiteral') {
      visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, leftMostChild, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
    } // If we added the first number literal as operation here we still can continue and handle the rest as the first
    // number will be just skipped.


    handleExpression(expr, right, context);
  } else {
    visQuery.binaryQueries = visQuery.binaryQueries || [];
    const binQuery = {
      operator: op,
      query: {
        metric: '',
        labels: [],
        operations: []
      }
    };

    if (binModifier !== null && binModifier !== void 0 && binModifier.isMatcher) {
      binQuery.vectorMatchesType = binModifier.matchType;
      binQuery.vectorMatches = binModifier.matches;
    }

    visQuery.binaryQueries.push(binQuery);
    handleExpression(expr, right, {
      query: binQuery.query,
      errors: context.errors
    });
  }
}

function getBinaryModifier(expr, node) {
  if (!node) {
    return undefined;
  }

  if (node.getChild('Bool')) {
    return {
      isBool: true,
      isMatcher: false
    };
  } else {
    var _matcher$getChild;

    const matcher = node.getChild('OnOrIgnoring');

    if (!matcher) {
      // Not sure what this could be, maybe should be an error.
      return undefined;
    }

    const labels = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, (_matcher$getChild = matcher.getChild('GroupingLabels')) === null || _matcher$getChild === void 0 ? void 0 : _matcher$getChild.getChild('GroupingLabelList'));
    return {
      isMatcher: true,
      isBool: false,
      matches: labels,
      matchType: matcher.getChild('On') ? 'on' : 'ignoring'
    };
  }
}

function isEmptyQuery(query) {
  if (query.labels.length === 0 && query.operations.length === 0 && !query.metric) {
    return true;
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/FeedbackLink.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FeedbackLink": () => (/* binding */ FeedbackLink)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Icon;








function FeedbackLink({
  feedbackUrl
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);

  if (!_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.feedbackLinksEnabled) {
    return null;
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 1,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("a", {
      href: feedbackUrl,
      className: styles.link,
      title: "This query builder is new, please let us know how we can improve it",
      target: "_blank",
      rel: "noreferrer noopener",
      onClick: () => (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.reportInteraction)('grafana_feedback_link_clicked', {
        link: feedbackUrl
      }),
      children: [_Icon || (_Icon = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Icon, {
        name: "comment-alt-message"
      })), " Give feedback"]
    })
  });
}

function getStyles(theme) {
  return {
    link: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      fontSize: theme.typography.bodySmall.fontSize,
      ':hover': {
        color: theme.colors.text.link
      }
    })
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilterItem": () => (/* binding */ LabelFilterItem)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function LabelFilterItem({
  item,
  defaultOp,
  onChange,
  onDelete,
  onGetLabelNames,
  onGetLabelValues
}) {
  var _item$op2;

  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});

  const isMultiSelect = () => {
    return item.op === operators[0].label;
  };

  const getSelectOptionsFromString = item => {
    if (item) {
      if (item.indexOf('|') > 0) {
        return item.split('|');
      }

      return [item];
    }

    return [];
  };

  const getOptions = () => {
    const labelValues = state.labelValues ? [...state.labelValues] : [];
    const selectedOptions = getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption); // Remove possible duplicated values

    return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.uniqBy)([...selectedOptions, ...labelValues], 'value');
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
    "data-testid": "prometheus-dimensions-filter-item",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.InputGroup, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
        inputId: "prometheus-dimensions-filter-item-key",
        width: "auto",
        value: item.label ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)(item.label) : null,
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelNames: true
          });
          const labelNames = await onGetLabelNames(item);
          setState({
            labelNames,
            isLoadingLabelNames: undefined
          });
        },
        isLoading: state.isLoadingLabelNames,
        options: state.labelNames,
        onChange: change => {
          if (change.label) {
            var _item$op;

            onChange(Object.assign({}, item, {
              op: (_item$op = item.op) !== null && _item$op !== void 0 ? _item$op : defaultOp,
              label: change.label
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)((_item$op2 = item.op) !== null && _item$op2 !== void 0 ? _item$op2 : defaultOp),
        options: operators,
        width: "auto",
        onChange: change => {
          if (change.value != null) {
            onChange(Object.assign({}, item, {
              op: change.value
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
        inputId: "prometheus-dimensions-filter-item-value",
        width: "auto",
        value: isMultiSelect() ? getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption) : getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)[0],
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelValues: true
          });
          const labelValues = await onGetLabelValues(item);
          setState(Object.assign({}, state, {
            labelValues,
            isLoadingLabelValues: undefined
          }));
        },
        isMulti: isMultiSelect(),
        isLoading: state.isLoadingLabelValues,
        options: getOptions(),
        onChange: change => {
          if (change.value) {
            var _item$op3;

            onChange(Object.assign({}, item, {
              value: change.value,
              op: (_item$op3 = item.op) !== null && _item$op3 !== void 0 ? _item$op3 : defaultOp
            }));
          } else {
            var _item$op4;

            const changes = change.map(change => {
              return change.label;
            }).join('|');
            onChange(Object.assign({}, item, {
              value: changes,
              op: (_item$op4 = item.op) !== null && _item$op4 !== void 0 ? _item$op4 : defaultOp
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.AccessoryButton, {
        "aria-label": "remove",
        icon: "times",
        variant: "secondary",
        onClick: onDelete
      })]
    })
  });
}
const operators = [{
  label: '=~',
  value: '=~'
}, {
  label: '=',
  value: '='
}, {
  label: '!=',
  value: '!='
}, {
  label: '!~',
  value: '!~'
}];

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilters": () => (/* binding */ LabelFilters)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function LabelFilters({
  labelsFilters,
  onChange,
  onGetLabelNames,
  onGetLabelValues,
  error
}) {
  const defaultOp = '=';
  const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([{
    op: defaultOp
  }]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (labelsFilters.length > 0) {
      setItems(labelsFilters);
    } else {
      setItems([{
        op: defaultOp
      }]);
    }
  }, [labelsFilters]);

  const onLabelsChange = newItems => {
    setItems(newItems); // Extract full label filters with both label & value

    const newLabels = newItems.filter(x => x.label != null && x.value != null);

    if (!(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(newLabels, labelsFilters)) {
      onChange(newLabels);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorFieldGroup, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
      label: "Labels",
      error: error,
      invalid: !!error,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorList, {
        items: items,
        onChange: onLabelsChange,
        renderItem: (item, onChangeItem, onDelete) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__.LabelFilterItem, {
          item: item,
          defaultOp: defaultOp,
          onChange: onChangeItem,
          onDelete: onDelete,
          onGetLabelNames: onGetLabelNames,
          onGetLabelValues: onGetLabelValues
        })
      })
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiAndPromQueryModellerBase": () => (/* binding */ LokiAndPromQueryModellerBase)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class LokiAndPromQueryModellerBase {
  constructor(getOperations) {
    _defineProperty(this, "operationsRegisty", void 0);

    _defineProperty(this, "categories", []);

    this.operationsRegisty = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.Registry(getOperations);
  }

  setOperationCategories(categories) {
    this.categories = categories;
  }

  getOperationsForCategory(category) {
    return this.operationsRegisty.list().filter(op => op.category === category && !op.hideFromList);
  }

  getAlternativeOperations(key) {
    return this.operationsRegisty.list().filter(op => op.alternativesKey === key);
  }

  getCategories() {
    return this.categories;
  }

  getOperationDef(id) {
    return this.operationsRegisty.getIfExists(id);
  }

  renderOperations(queryString, operations) {
    for (const operation of operations) {
      const def = this.operationsRegisty.getIfExists(operation.id);

      if (!def) {
        throw new Error(`Could not find operation ${operation.id} in the registry`);
      }

      queryString = def.renderer(operation, def, queryString);
    }

    return queryString;
  }

  renderBinaryQueries(queryString, binaryQueries) {
    if (binaryQueries) {
      for (const binQuery of binaryQueries) {
        queryString = `${this.renderBinaryQuery(queryString, binQuery)}`;
      }
    }

    return queryString;
  }

  renderBinaryQuery(leftOperand, binaryQuery) {
    let result = leftOperand + ` ${binaryQuery.operator} `;

    if (binaryQuery.vectorMatches) {
      result += `${binaryQuery.vectorMatchesType}(${binaryQuery.vectorMatches}) `;
    }

    return result + this.renderQuery(binaryQuery.query, true);
  }

  renderLabels(labels) {
    if (labels.length === 0) {
      return '';
    }

    let expr = '{';

    for (const filter of labels) {
      if (expr !== '{') {
        expr += ', ';
      }

      expr += `${filter.label}${filter.op}"${filter.value}"`;
    }

    return expr + `}`;
  }

  renderQuery(query, nested) {
    var _query$metric, _query$binaryQueries, _query$binaryQueries2;

    let queryString = `${(_query$metric = query.metric) !== null && _query$metric !== void 0 ? _query$metric : ''}${this.renderLabels(query.labels)}`;
    queryString = this.renderOperations(queryString, query.operations);

    if (!nested && this.hasBinaryOp(query) && Boolean((_query$binaryQueries = query.binaryQueries) === null || _query$binaryQueries === void 0 ? void 0 : _query$binaryQueries.length)) {
      queryString = `(${queryString})`;
    }

    queryString = this.renderBinaryQueries(queryString, query.binaryQueries);

    if (nested && (this.hasBinaryOp(query) || Boolean((_query$binaryQueries2 = query.binaryQueries) === null || _query$binaryQueries2 === void 0 ? void 0 : _query$binaryQueries2.length))) {
      queryString = `(${queryString})`;
    }

    return queryString;
  }

  hasBinaryOp(query) {
    return query.operations.find(op => {
      const def = this.getOperationDef(op.id);
      return (def === null || def === void 0 ? void 0 : def.category) === _types__WEBPACK_IMPORTED_MODULE_1__.PromVisualQueryOperationCategory.BinaryOps;
    }) !== undefined;
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationEditor": () => (/* binding */ OperationEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationHeader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx");
/* harmony import */ var _OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










function OperationEditor({
  operation,
  index,
  onRemove,
  onChange,
  onRunQuery,
  queryModeller,
  query,
  datasource,
  highlight
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const def = queryModeller.getOperationDef(operation.id);
  const shouldHighlight = useHighlight(highlight);

  if (!def) {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("span", {
      children: ["Operation ", operation.id, " not found"]
    });
  }

  const onParamValueChanged = (paramIdx, value) => {
    const update = Object.assign({}, operation, {
      params: [...operation.params]
    });
    update.params[paramIdx] = value;
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const onAddRestParam = () => {
    const update = Object.assign({}, operation, {
      params: [...operation.params, '']
    });
    callParamChangedThenOnChange(def, update, index, operation.params.length, onChange);
  };

  const onRemoveRestParam = paramIdx => {
    const update = Object.assign({}, operation, {
      params: [...operation.params.slice(0, paramIdx), ...operation.params.slice(paramIdx + 1)]
    });
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const operationElements = [];

  for (let paramIndex = 0; paramIndex < operation.params.length; paramIndex++) {
    const paramDef = def.params[Math.min(def.params.length - 1, paramIndex)];
    const Editor = (0,_OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__.getOperationParamEditor)(paramDef);
    operationElements.push( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
      className: styles.paramRow,
      children: [!paramDef.hideName && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.paramName,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("label", {
          htmlFor: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_6__.getOperationParamId)(index, paramIndex),
          children: paramDef.name
        }), paramDef.description && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Tooltip, {
          placement: "top",
          content: paramDef.description,
          theme: "info",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
            name: "info-circle",
            size: "sm",
            className: styles.infoIcon
          })
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.paramValue,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
          gap: 0.5,
          direction: "row",
          alignItems: "center",
          wrap: false,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(Editor, {
            index: paramIndex,
            paramDef: paramDef,
            value: operation.params[paramIndex],
            operation: operation,
            operationIndex: index,
            onChange: onParamValueChanged,
            onRunQuery: onRunQuery,
            query: query,
            datasource: datasource
          }), paramDef.restParam && (operation.params.length > def.params.length || paramDef.optional) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            "data-testid": `operations.${index}.remove-rest-param`,
            size: "sm",
            fill: "text",
            icon: "times",
            variant: "secondary",
            title: `Remove ${paramDef.name}`,
            onClick: () => onRemoveRestParam(paramIndex)
          })]
        })
      })]
    }, `${paramIndex}-1`));
  } // Handle adding button for rest params


  let restParam;

  if (def.params.length > 0) {
    const lastParamDef = def.params[def.params.length - 1];

    if (lastParamDef.restParam) {
      restParam = renderAddRestParamButton(lastParamDef, onAddRestParam, index, operation.params.length, styles);
    }
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__.Draggable, {
    draggableId: `operation-${index}`,
    index: index,
    children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", Object.assign({
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.card, shouldHighlight && styles.cardHighlight),
      ref: provided.innerRef
    }, provided.draggableProps, {
      "data-testid": `operations.${index}.wrapper`,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_OperationHeader__WEBPACK_IMPORTED_MODULE_4__.OperationHeader, {
        operation: operation,
        dragHandleProps: provided.dragHandleProps,
        def: def,
        index: index,
        onChange: onChange,
        onRemove: onRemove,
        queryModeller: queryModeller
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.body,
        children: operationElements
      }), restParam, index < query.operations.length - 1 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.arrow,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowLine
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowArrow
        })]
      })]
    }))
  });
}
/**
 * When highlight is switched on makes sure it is switched of right away, so we just flash the highlight and then fade
 * out.
 * @param highlight
 */

function useHighlight(highlight) {
  const [keepHighlight, setKeepHighlight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    let t;

    if (highlight) {
      t = setTimeout(() => {
        setKeepHighlight(false);
      }, 1);
    } else {
      setKeepHighlight(true);
    }

    return () => clearTimeout(t);
  }, [highlight]);
  return keepHighlight && highlight;
}

function renderAddRestParamButton(paramDef, onAddRestParam, operationIndex, paramIndex, styles) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
    className: styles.restParam,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
      size: "sm",
      icon: "plus",
      title: `Add ${paramDef.name}`,
      variant: "secondary",
      onClick: onAddRestParam,
      "data-testid": `operations.${operationIndex}.add-rest-param`,
      children: paramDef.name
    })
  }, `${paramIndex}-2`);
}

function callParamChangedThenOnChange(def, operation, operationIndex, paramIndex, onChange) {
  if (def.paramChangedHandler) {
    onChange(operationIndex, def.paramChangedHandler(paramIndex, operation, def));
  } else {
    onChange(operationIndex, operation);
  }
}

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.medium}`,
      display: 'flex',
      flexDirection: 'column',
      cursor: 'grab',
      borderRadius: theme.shape.borderRadius(1),
      marginBottom: theme.spacing(1),
      position: 'relative',
      transition: 'all 1s ease-in 0s'
    }),
    cardHighlight: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      boxShadow: `0px 0px 4px 0px ${theme.colors.primary.border}`,
      border: `1px solid ${theme.colors.primary.border}`
    }),
    infoIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(0.5),
      color: theme.colors.text.secondary,
      ':hover': {
        color: theme.colors.text.primary
      }
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      margin: theme.spacing(1, 1, 0.5, 1),
      display: 'table'
    }),
    paramRow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramRow',
      display: 'table-row',
      verticalAlign: 'middle'
    }),
    paramName: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'table-cell',
      padding: theme.spacing(0, 1, 0, 0),
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      verticalAlign: 'middle',
      height: '32px'
    }),
    paramValue: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramValue',
      display: 'table-cell',
      verticalAlign: 'middle'
    }),
    restParam: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(0, 1, 1, 1)
    }),
    arrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      position: 'absolute',
      top: '0',
      right: '-18px',
      display: 'flex'
    }),
    arrowLine: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      height: '2px',
      width: '8px',
      backgroundColor: theme.colors.border.strong,
      position: 'relative',
      top: '14px'
    }),
    arrowArrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      width: 0,
      height: 0,
      borderTop: `5px solid transparent`,
      borderBottom: `5px solid transparent`,
      borderLeft: `7px solid ${theme.colors.border.strong}`,
      position: 'relative',
      top: '10px'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationExplainedBox": () => (/* binding */ OperationExplainedBox)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function OperationExplainedBox({
  title,
  stepNumber,
  markdown,
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
    className: styles.box,
    children: [stepNumber !== undefined && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.stepNumber,
      children: stepNumber
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.boxInner,
      children: [title && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.header,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: title
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.body,
        children: [markdown && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          dangerouslySetInnerHTML: {
            __html: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.renderMarkdown)(markdown)
          }
        }), children]
      })]
    })]
  });
}

const getStyles = theme => {
  return {
    box: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.secondary,
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      position: 'relative'
    }),
    boxInner: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(4)
    }),
    stepNumber: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontWeight: theme.typography.fontWeightMedium,
      background: theme.colors.secondary.main,
      width: '20px',
      height: '20px',
      borderRadius: '50%',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'absolute',
      top: '10px',
      left: '11px',
      fontSize: theme.typography.bodySmall.fontSize
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingBottom: theme.spacing(0.5),
      display: 'flex',
      alignItems: 'center',
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      'p:last-child': {
        margin: 0
      },
      a: {
        color: theme.colors.text.link,
        textDecoration: 'underline'
      }
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationHeader": () => (/* binding */ OperationHeader)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;









const OperationHeader = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  operation,
  def,
  index,
  onChange,
  onRemove,
  queryModeller,
  dragHandleProps
}) => {
  var _def$name;

  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});

  const onToggleSwitcher = () => {
    if (state.isOpen) {
      setState(Object.assign({}, state, {
        isOpen: false
      }));
    } else {
      const alternatives = queryModeller.getAlternativeOperations(def.alternativesKey).map(alt => ({
        label: alt.name,
        value: alt
      }));
      setState({
        isOpen: true,
        alternatives
      });
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: styles.header,
    children: [!state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", Object.assign({}, dragHandleProps, {
        children: (_def$name = def.name) !== null && _def$name !== void 0 ? _def$name : def.id
      })), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: `${styles.operationHeaderButtons} operation-header-show-on-hover`,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: "angle-down",
          size: "sm",
          onClick: onToggleSwitcher,
          fill: "text",
          variant: "secondary",
          title: "Click to view alternative operations"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__.OperationInfoButton, {
          def: def,
          operation: operation
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: "times",
          size: "sm",
          onClick: () => onRemove(index),
          fill: "text",
          variant: "secondary",
          title: "Remove operation"
        })]
      })]
    }), state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: styles.selectWrapper,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        autoFocus: true,
        openMenuOnFocus: true,
        placeholder: "Replace with",
        options: state.alternatives,
        isOpen: true,
        onCloseMenu: onToggleSwitcher,
        onChange: value => {
          if (value.value) {
            // Operation should exist if it is selectable
            const newDef = queryModeller.getOperationDef(value.value.id);
            let changedOp = Object.assign({}, operation, {
              id: value.value.id
            });
            onChange(index, def.changeTypeHandler ? def.changeTypeHandler(changedOp, newDef) : changedOp);
          }
        }
      })
    })]
  });
});
OperationHeader.displayName = 'OperationHeader';

const getStyles = theme => {
  return {
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      borderBottom: `1px solid ${theme.colors.border.medium}`,
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      display: 'flex',
      alignItems: 'center',
      '&:hover .operation-header-show-on-hover': (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
        opacity: 1
      })
    }),
    operationHeaderButtons: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      transition: theme.transitions.create(['opacity'], {
        duration: theme.transitions.duration.short
      })
    }),
    selectWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingRight: theme.spacing(2)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationInfoButton": () => (/* binding */ OperationInfoButton)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-popper-tooltip-virtual-ff0da4b2fd/0/cache/react-popper-tooltip-npm-4.4.1-2214480dbc-58dacdf9bc.zip/node_modules/react-popper-tooltip/dist/esm/react-popper-tooltip.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;










const OperationInfoButton = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  def,
  operation
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  const [show, setShow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const {
    getTooltipProps,
    setTooltipRef,
    setTriggerRef,
    visible
  } = (0,react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__.usePopperTooltip)({
    placement: 'top',
    visible: show,
    offset: [0, 16],
    onVisibleChange: setShow,
    interactive: true,
    trigger: ['click']
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
      title: "Click to show description",
      ref: setTriggerRef,
      icon: "info-circle",
      size: "sm",
      variant: "secondary",
      fill: "text"
    }), visible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Portal, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
        ref: setTooltipRef
      }, getTooltipProps(), {
        className: styles.docBox,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: styles.docBoxHeader,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
            children: def.renderer(operation, def, '<expr>')
          }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.FlexItem, {
            grow: 1
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
            icon: "times",
            onClick: () => setShow(false),
            fill: "text",
            variant: "secondary",
            title: "Remove operation"
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: styles.docBoxBody,
          dangerouslySetInnerHTML: {
            __html: getOperationDocs(def, operation)
          }
        })]
      }))
    })]
  });
});
OperationInfoButton.displayName = 'OperationDocs';

const getStyles = theme => {
  return {
    docBox: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      overflow: 'hidden',
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.strong}`,
      boxShadow: theme.shadows.z3,
      maxWidth: '600px',
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      zIndex: theme.zIndex.tooltip
    }),
    docBoxHeader: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.h5.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace,
      paddingBottom: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    docBoxBody: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      // The markdown paragraph has a marginBottom this removes it
      marginBottom: theme.spacing(-1),
      color: theme.colors.text.secondary
    }),
    signature: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.bodySmall.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    dropdown: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      color: theme.colors.text.secondary
    })
  };
};

function getOperationDocs(def, op) {
  var _def$documentation;

  return (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.renderMarkdown)(def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs');
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationList": () => (/* binding */ OperationList)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useMountedState.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









function OperationList({
  query,
  datasource,
  queryModeller,
  onChange,
  onRunQuery
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const {
    operations
  } = query;
  const opsToHighlight = useOperationsHighlight(operations);
  const [cascaderOpen, setCascaderOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);

  const onOperationChange = (index, update) => {
    const updatedList = [...operations];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...operations.slice(0, index), ...operations.slice(index + 1)];
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const addOptions = queryModeller.getCategories().map(category => {
    return {
      value: category,
      label: category,
      items: queryModeller.getOperationsForCategory(category).map(operation => ({
        value: operation.id,
        label: operation.name,
        isLeaf: true
      }))
    };
  });

  const onAddOperation = value => {
    const operationDef = queryModeller.getOperationDef(value);

    if (!operationDef) {
      return;
    }

    onChange(operationDef.addOperationHandler(operationDef, query, queryModeller));
    setCascaderOpen(false);
  };

  const onDragEnd = result => {
    if (!result.destination) {
      return;
    }

    const updatedList = [...operations];
    const element = updatedList[result.source.index];
    updatedList.splice(result.source.index, 1);
    updatedList.splice(result.destination.index, 0, element);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onCascaderBlur = () => {
    setCascaderOpen(false);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 1,
    direction: "column",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
      gap: 1,
      children: [operations.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.DragDropContext, {
        onDragEnd: onDragEnd,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Droppable, {
          droppableId: "sortable-field-mappings",
          direction: "horizontal",
          children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
            className: styles.operationList,
            ref: provided.innerRef
          }, provided.droppableProps, {
            children: [operations.map((op, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationEditor__WEBPACK_IMPORTED_MODULE_4__.OperationEditor, {
              queryModeller: queryModeller,
              index: index,
              operation: op,
              query: query,
              datasource: datasource,
              onChange: onOperationChange,
              onRemove: onRemove,
              onRunQuery: onRunQuery,
              highlight: opsToHighlight[index]
            }, op.id + index)), provided.placeholder]
          }))
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: styles.addButton,
        children: cascaderOpen ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Cascader, {
          options: addOptions,
          onSelect: onAddOperation,
          onBlur: onCascaderBlur,
          autoFocus: true,
          alwaysOpen: true,
          hideActiveLevelLabel: true,
          placeholder: 'Search'
        }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: 'plus',
          variant: 'secondary',
          onClick: () => setCascaderOpen(true),
          title: 'Add operation',
          children: "Operations"
        })
      })]
    })
  });
}
/**
 * Returns indexes of operations that should be highlighted. We check the diff of operations added but at the same time
 * we want to highlight operations only after the initial render, so we check for mounted state and calculate the diff
 * only after.
 * @param operations
 */

function useOperationsHighlight(operations) {
  const isMounted = (0,react_use__WEBPACK_IMPORTED_MODULE_7__["default"])();
  const prevOperations = (0,react_use__WEBPACK_IMPORTED_MODULE_8__["default"])(operations);

  if (!isMounted()) {
    return operations.map(() => false);
  }

  if (!prevOperations) {
    return operations.map(() => true);
  }

  let newOps = [];

  if (prevOperations.length - 1 === operations.length && operations.every(op => prevOperations.includes(op))) {
    // In case we remove one op and does not change any ops then don't highlight anything.
    return operations.map(() => false);
  }

  if (prevOperations.length + 1 === operations.length && prevOperations.every(op => operations.includes(op))) {
    // If we add a single op just find it and highlight just that.
    const newOp = operations.find(op => !prevOperations.includes(op));
    newOps = operations.map(op => {
      return op === newOp;
    });
  } else {
    // Default diff of all ops.
    newOps = operations.map((op, index) => {
      var _prevOperations$index;

      return !isSameOp(op.id, (_prevOperations$index = prevOperations[index]) === null || _prevOperations$index === void 0 ? void 0 : _prevOperations$index.id);
    });
  }

  return newOps;
}

function isSameOp(op1, op2) {
  return op1 === op2 || `__${op1}_by` === op2 || op1 === `__${op2}_by`;
}

const getStyles = theme => {
  return {
    heading: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'heading',
      fontSize: 12,
      fontWeight: theme.typography.fontWeightMedium,
      marginBottom: 0
    }),
    operationList: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'operationList',
      display: 'flex',
      flexWrap: 'wrap',
      gap: theme.spacing(2)
    }),
    addButton: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'addButton',
      width: 126,
      paddingBottom: theme.spacing(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationListExplained": () => (/* binding */ OperationListExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var _RawQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/RawQuery.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function OperationListExplained({
  query,
  queryModeller,
  stepNumber,
  lang
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {
    children: query.operations.map((op, index) => {
      var _def$documentation;

      const def = queryModeller.getOperationDef(op.id);

      if (!def) {
        return `Operation ${op.id} not found`;
      }

      const title = def.renderer(op, def, '<expr>');
      const body = def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs';
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__.OperationExplainedBox, {
        stepNumber: index + stepNumber,
        title: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_RawQuery__WEBPACK_IMPORTED_MODULE_2__.RawQuery, {
          query: title,
          lang: lang
        }),
        markdown: body
      }, index);
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOperationParamEditor": () => (/* binding */ getOperationParamEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function getOperationParamEditor(paramDef) {
  if (paramDef.editor) {
    return paramDef.editor;
  }

  if (paramDef.options) {
    return SelectInputParamEditor;
  }

  switch (paramDef.type) {
    case 'boolean':
      return BoolInputParamEditor;

    case 'number':
    case 'string':
    default:
      return SimpleInputParamEditor;
  }
}

function SimpleInputParamEditor(props) {
  var _props$value;

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.AutoSizeInput, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_3__.getOperationParamId)(props.operationIndex, props.index),
    defaultValue: (_props$value = props.value) === null || _props$value === void 0 ? void 0 : _props$value.toString(),
    minWidth: props.paramDef.minWidth,
    placeholder: props.paramDef.placeholder,
    title: props.paramDef.description,
    onCommitChange: evt => {
      props.onChange(props.index, evt.currentTarget.value);

      if (props.paramDef.runQueryOnEnter && evt.type === 'keydown') {
        props.onRunQuery();
      }
    }
  });
}

function BoolInputParamEditor(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Checkbox, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_3__.getOperationParamId)(props.operationIndex, props.index),
    value: props.value,
    onChange: evt => props.onChange(props.index, evt.currentTarget.checked)
  });
}

function SelectInputParamEditor({
  paramDef,
  value,
  index,
  operationIndex,
  onChange
}) {
  var _selectOptions$, _selectOptions$find;

  let selectOptions = paramDef.options;

  if (!((_selectOptions$ = selectOptions[0]) !== null && _selectOptions$ !== void 0 && _selectOptions$.label)) {
    selectOptions = paramDef.options.map(option => ({
      label: option.toString(),
      value: option
    }));
  }

  let valueOption = (_selectOptions$find = selectOptions.find(x => x.value === value)) !== null && _selectOptions$find !== void 0 ? _selectOptions$find : (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(value);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_3__.getOperationParamId)(operationIndex, index),
    value: valueOption,
    options: selectOptions,
    placeholder: paramDef.placeholder,
    allowCustomValue: true,
    onChange: value => onChange(index, value.value)
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationsEditorRow": () => (/* binding */ OperationsEditorRow)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function OperationsEditorRow({
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: styles.root,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
      gap: 1,
      children: children
    })
  });
}

const getStyles = theme => {
  return {
    root: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(1, 1, 0, 1),
      backgroundColor: theme.colors.background.secondary,
      borderRadius: theme.shape.borderRadius(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorModeToggle": () => (/* binding */ QueryEditorModeToggle)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const editorModes = [{
  label: 'Explain',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Explain
}, {
  label: 'Builder',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Builder,
  component: () => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Tag, {
    className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: 10,
      padding: '1px 5px',
      verticalAlign: 'text-bottom'
    }),
    name: 'Beta',
    colorIndex: 1
  })
}, {
  label: 'Code',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Code
}];
function QueryEditorModeToggle({
  mode,
  onChange
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    "data-testid": 'QueryEditorModeToggle',
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.RadioButtonGroup, {
      options: editorModes,
      size: "sm",
      value: mode,
      onChange: onChange
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryHeaderSwitch.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryHeaderSwitch": () => (/* binding */ QueryHeaderSwitch)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["label"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








function QueryHeaderSwitch(_ref) {
  let {
    label
  } = _ref,
      inputProps = _objectWithoutPropertiesLoose(_ref, _excluded);

  const dashedLabel = label.replace(' ', '-');
  const switchIdRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)((0,lodash__WEBPACK_IMPORTED_MODULE_1__.uniqueId)(`switch-${dashedLabel}`));
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.Stack, {
    gap: 1,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("label", {
      htmlFor: switchIdRef.current,
      className: styles.switchLabel,
      children: label
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Switch, Object.assign({}, inputProps, {
      id: switchIdRef.current
    }))]
  });
}

const getStyles = theme => {
  return {
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      cursor: 'pointer',
      fontSize: theme.typography.bodySmall.fontSize,
      '&:hover': {
        color: theme.colors.text.primary
      }
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryOptionGroup": () => (/* binding */ QueryOptionGroup)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useToggle.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-45ce772437/0/cache/@grafana-experimental-npm-0.0.2-canary.32-3892e62f7b-71924e6d03.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function QueryOptionGroup({
  title,
  children,
  collapsedInfo
}) {
  const [isOpen, toggleOpen] = (0,react_use__WEBPACK_IMPORTED_MODULE_5__["default"])(false);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 0,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.header,
      onClick: toggleOpen,
      title: "Click to edit options",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.toggle,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
          name: isOpen ? 'angle-down' : 'angle-right'
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("h6", {
        className: styles.title,
        children: title
      }), !isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.description,
        children: collapsedInfo.map((x, i) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: x
        }, i))
      })]
    }), isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.body,
      children: children
    })]
  });
}

const getStyles = theme => {
  return {
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      cursor: 'pointer',
      fontSize: theme.typography.bodySmall.fontSize,
      '&:hover': {
        color: theme.colors.text.primary
      }
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'flex',
      cursor: 'pointer',
      alignItems: 'baseline',
      color: theme.colors.text.primary,
      '&:hover': {
        background: theme.colors.emphasize(theme.colors.background.primary, 0.03)
      }
    }),
    title: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      flexGrow: 1,
      overflow: 'hidden',
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      margin: 0
    }),
    description: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      fontSize: theme.typography.bodySmall.fontSize,
      paddingLeft: theme.spacing(2),
      gap: theme.spacing(2),
      display: 'flex'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'flex',
      paddingTop: theme.spacing(2),
      gap: theme.spacing(2),
      flexWrap: 'wrap'
    }),
    toggle: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      marginRight: `${theme.spacing(1)}`
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/RawQuery.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RawQuery": () => (/* binding */ RawQuery)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.28.0-28f20a79ff-bde93fb2be.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui_src__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function RawQuery({
  query,
  lang
}) {
  const theme = (0,_grafana_ui_src__WEBPACK_IMPORTED_MODULE_3__.useTheme2)();
  const styles = getStyles(theme);
  const highlighted = prismjs__WEBPACK_IMPORTED_MODULE_1___default().highlight(query, lang.grammar, lang.name);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.editorField, 'prism-syntax-highlight'),
    "aria-label": "selector",
    dangerouslySetInnerHTML: {
      __html: highlighted
    }
  });
}

const getStyles = theme => {
  return {
    editorField: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontFamily: theme.typography.fontFamilyMonospace,
      fontSize: theme.typography.bodySmall.fontSize
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAggregationOperation": () => (/* binding */ createAggregationOperation),
/* harmony export */   "createAggregationOperationWithParam": () => (/* binding */ createAggregationOperationWithParam),
/* harmony export */   "defaultAddOperationHandler": () => (/* binding */ defaultAddOperationHandler),
/* harmony export */   "functionRendererLeft": () => (/* binding */ functionRendererLeft),
/* harmony export */   "functionRendererRight": () => (/* binding */ functionRendererRight),
/* harmony export */   "getOperationParamId": () => (/* binding */ getOperationParamId),
/* harmony export */   "getPromAndLokiOperationDisplayName": () => (/* binding */ getPromAndLokiOperationDisplayName),
/* harmony export */   "getRangeVectorParamDef": () => (/* binding */ getRangeVectorParamDef),
/* harmony export */   "rangeRendererLeftWithParams": () => (/* binding */ rangeRendererLeftWithParams),
/* harmony export */   "rangeRendererRightWithParams": () => (/* binding */ rangeRendererRightWithParams)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/pluralize-npm-8.0.0-f5f044ed52-08931d4a6a.zip/node_modules/pluralize/pluralize.js");
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pluralize__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");




function functionRendererLeft(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.push(innerExpr);
  }

  return str + params.join(', ') + ')';
}
function functionRendererRight(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.unshift(innerExpr);
  }

  return str + params.join(', ') + ')';
}

function rangeRendererWithParams(model, def, innerExpr, renderLeft) {
  var _, _model$params;

  if (def.params.length < 2) {
    throw `Cannot render a function with params of length [${def.params.length}]`;
  }

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m'; // Next frame the remaining parameters, but get rid of the first one because it's used to move the
  // instant vector into a range vector.

  const params = renderParams(Object.assign({}, model, {
    params: model.params.slice(1)
  }), Object.assign({}, def, {
    params: def.params.slice(1),
    defaultParams: def.defaultParams.slice(1)
  }), innerExpr);
  const str = model.id + '('; // Depending on the renderLeft variable, render parameters to the left or right
  // renderLeft === true (renderLeft) => (param1, param2, rangeVector[...])
  // renderLeft === false (renderRight) => (rangeVector[...], param1, param2)

  if (innerExpr) {
    renderLeft ? params.push(`${innerExpr}[${rangeVector}]`) : params.unshift(`${innerExpr}[${rangeVector}]`);
  } // stick everything together


  return str + params.join(', ') + ')';
}

function rangeRendererRightWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, false);
}
function rangeRendererLeftWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, true);
}

function renderParams(model, def, innerExpr) {
  var _model$params2;

  return ((_model$params2 = model.params) !== null && _model$params2 !== void 0 ? _model$params2 : []).map((value, index) => {
    const paramDef = def.params[index];

    if (paramDef.type === 'string') {
      return '"' + value + '"';
    }

    return value;
  });
}

function defaultAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}
function getPromAndLokiOperationDisplayName(funcName) {
  return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(funcName.replace(/_/g, ' '));
}
function getOperationParamId(operationIndex, paramIndex) {
  return `operations.${operationIndex}.param.${paramIndex}`;
}
function getRangeVectorParamDef(withRateInterval = false) {
  const param = {
    name: 'Range',
    type: 'string',
    options: [{
      label: '$__interval',
      value: '$__interval' // tooltip: 'Dynamic interval based on max data points, scrape and min interval',

    }, {
      label: '1m',
      value: '1m'
    }, {
      label: '5m',
      value: '5m'
    }, {
      label: '10m',
      value: '10m'
    }, {
      label: '1h',
      value: '1h'
    }, {
      label: '24h',
      value: '24h'
    }]
  };

  if (withRateInterval) {
    param.options.unshift({
      label: '$__rate_interval',
      value: '$__rate_interval' // tooltip: 'Always above 4x scrape interval',

    });
  }

  return param;
}
/**
 * This function is shared between Prometheus and Loki variants
 */

function createAggregationOperation(name, overrides = {}) {
  const operations = [Object.assign({
    id: name,
    name: getPromAndLokiOperationDisplayName(name),
    params: [{
      name: 'By label',
      type: 'string',
      restParam: true,
      optional: true
    }],
    defaultParams: [],
    alternativesKey: 'plain aggregations',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: functionRendererLeft,
    paramChangedHandler: getOnLabelAddedHandler(`__${name}_by`),
    explainHandler: getAggregationExplainer(name, ''),
    addOperationHandler: defaultAddOperationHandler
  }, overrides), Object.assign({
    id: `__${name}_by`,
    name: `${getPromAndLokiOperationDisplayName(name)} by`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationByRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'by'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides), Object.assign({
    id: `__${name}_without`,
    name: `${getPromAndLokiOperationDisplayName(name)} without`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationWithoutRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'without'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides)];
  return operations;
}
function createAggregationOperationWithParam(name, paramsDef, overrides = {}) {
  const operations = createAggregationOperation(name, overrides);
  operations[0].params.unshift(...paramsDef.params);
  operations[1].params.unshift(...paramsDef.params);
  operations[2].params.unshift(...paramsDef.params);
  operations[0].defaultParams = paramsDef.defaultParams;
  operations[1].defaultParams = [...paramsDef.defaultParams, ''];
  operations[2].defaultParams = [...paramsDef.defaultParams, ''];
  operations[1].renderer = getAggregationByRendererWithParameter(name);
  operations[2].renderer = getAggregationByRendererWithParameter(name);
  return operations;
}

function getAggregationByRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} by(${model.params.join(', ')}) (${innerExpr})`;
  };
}

function getAggregationWithoutRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} without(${model.params.join(', ')}) (${innerExpr})`;
  };
}
/**
 * Very simple poc implementation, needs to be modified to support all aggregation operators
 */


function getAggregationExplainer(aggregationName, mode) {
  return function aggregationExplainer(model) {
    const labels = model.params.map(label => `\`${label}\``).join(' and ');
    const labelWord = pluralize__WEBPACK_IMPORTED_MODULE_1___default()('label', model.params.length);

    switch (mode) {
      case 'by':
        return `Calculates ${aggregationName} over dimensions while preserving ${labelWord} ${labels}.`;

      case 'without':
        return `Calculates ${aggregationName} over the dimensions ${labels}. All other labels are preserved.`;

      default:
        return `Calculates ${aggregationName} over the dimensions.`;
    }
  };
}

function getAggregationByRendererWithParameter(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    function mapType(p) {
      if (typeof p === 'string') {
        return `\"${p}\"`;
      }

      return p;
    }

    const params = model.params.slice(0, -1);
    const restParams = model.params.slice(1);
    return `${aggregation} by(${restParams.join(', ')}) (${params.map(mapType).join(', ')}, ${innerExpr})`;
  };
}
/**
 * This function will transform operations without labels to their plan aggregation operation
 */


function getLastLabelRemovedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // If definition has more params then is defined there are no optional rest params anymore.
    // We then transform this operation into a different one
    if (op.params.length < def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

function getOnLabelAddedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // Check if we actually have the label param. As it's optional the aggregation can have one less, which is the
    // case of just simple aggregation without label. When user adds the label it now has the same number of params
    // as it's definition, and now we can change it to it's `_by` variant.
    if (op.params.length === def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorName": () => (/* binding */ ErrorName),
/* harmony export */   "getAllByType": () => (/* binding */ getAllByType),
/* harmony export */   "getLeftMostChild": () => (/* binding */ getLeftMostChild),
/* harmony export */   "getString": () => (/* binding */ getString),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "makeBinOp": () => (/* binding */ makeBinOp),
/* harmony export */   "makeError": () => (/* binding */ makeError),
/* harmony export */   "replaceVariables": () => (/* binding */ replaceVariables)
/* harmony export */ });
// This is used for error type for some reason
const ErrorName = '⚠';
function getLeftMostChild(cur) {
  return cur.firstChild ? getLeftMostChild(cur.firstChild) : cur;
}
function makeError(expr, node) {
  var _node$parent;

  return {
    text: getString(expr, node),
    // TODO: this are positions in the string with the replaced variables. Means it cannot be used to show exact
    //  placement of the error for the user. We need some translation table to positions before the variable
    //  replace.
    from: node.from,
    to: node.to,
    parentType: (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name
  };
} // Taken from template_srv, but copied so to not mess with the regex.index which is manipulated in the service

/*
 * This regex matches 3 types of variable reference with an optional format specifier
 * \$(\w+)                          $var1
 * \[\[([\s\S]+?)(?::(\w+))?\]\]    [[var2]] or [[var2:fmt2]]
 * \${(\w+)(?::(\w+))?}             ${var3} or ${var3:fmt3}
 */

const variableRegex = /\$(\w+)|\[\[([\s\S]+?)(?::(\w+))?\]\]|\${(\w+)(?:\.([^:^\}]+))?(?::([^\}]+))?}/g;
/**
 * As variables with $ are creating parsing errors, we first replace them with magic string that is parsable and at
 * the same time we can get the variable and it's format back from it.
 * @param expr
 */

function replaceVariables(expr) {
  return expr.replace(variableRegex, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {
    const fmt = fmt2 || fmt3;
    let variable = var1;
    let varType = '0';

    if (var2) {
      variable = var2;
      varType = '1';
    }

    if (var3) {
      variable = var3;
      varType = '2';
    }

    return `__V_${varType}__` + variable + '__V__' + (fmt ? '__F__' + fmt + '__F__' : '');
  });
}
const varTypeFunc = [(v, f) => `\$${v}`, (v, f) => `[[${v}${f ? `:${f}` : ''}]]`, (v, f) => `\$\{${v}${f ? `:${f}` : ''}\}`];
/**
 * Get back the text with variables in their original format.
 * @param expr
 */

function returnVariables(expr) {
  return expr.replace(/__V_(\d)__(.+?)__V__(?:__F__(\w+)__F__)?/g, (match, type, v, f) => {
    return varTypeFunc[parseInt(type, 10)](v, f);
  });
}
/**
 * Get the actual string of the expression. That is not stored in the tree so we have to get the indexes from the node
 * and then based on that get it from the expression.
 * @param expr
 * @param node
 */


function getString(expr, node) {
  if (!node) {
    return '';
  }

  return returnVariables(expr.substring(node.from, node.to));
}
/**
 * Create simple scalar binary op object.
 * @param opDef - definition of the op to be created
 * @param expr
 * @param numberNode - the node for the scalar
 * @param hasBool - whether operation has a bool modifier. Is used only for ops for which it makes sense.
 */

function makeBinOp(opDef, expr, numberNode, hasBool) {
  const params = [parseFloat(getString(expr, numberNode))];

  if (opDef.comparison) {
    params.push(hasBool);
  }

  return {
    id: opDef.id,
    params
  };
}
/**
 * Get all nodes with type in the tree. This traverses the tree so it is safe only when you know there shouldn't be
 * too much nesting but you just want to skip some of the wrappers. For example getting function args this way would
 * not be safe is it would also find arguments of nested functions.
 * @param expr
 * @param cur
 * @param type
 */

function getAllByType(expr, cur, type) {
  if (cur.name === type) {
    return [getString(expr, cur)];
  }

  const values = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    values.push(...getAllByType(expr, child, type));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  return values;
} // Debugging function for convenience. Gives you nice output similar to linux tree util.
// @ts-ignore

function log(expr, cur) {
  if (!cur) {
    console.log('<empty>');
    return;
  }

  const json = toJson(expr, cur);
  const text = jsonToText(json);

  if (!text) {
    console.log('<empty>');
    return;
  }

  console.log(text);
}

function toJson(expr, cur) {
  const treeJson = {};
  const name = nodeToString(expr, cur);
  const children = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    children.push(toJson(expr, child));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  treeJson.name = name;
  treeJson.children = children;
  return treeJson;
}

function jsonToText(node, context = {
  lastChild: true,
  indent: ''
}) {
  const name = node.name;
  const {
    lastChild,
    indent
  } = context;
  const newIndent = indent !== '' ? indent + (lastChild ? '└─' : '├─') : '';
  let text = newIndent + name;
  const children = node.children;
  children.forEach((child, index) => {
    const isLastChild = index === children.length - 1;
    text += '\n' + jsonToText(child, {
      lastChild: isLastChild,
      indent: indent + (lastChild ? '  ' : '│ ')
    });
  });
  return text;
}

function nodeToString(expr, node) {
  return node.name + ': ' + getString(expr, node);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorMode": () => (/* binding */ QueryEditorMode)
/* harmony export */ });
/**
 * Shared types that can be reused by Loki and other data sources
 */
let QueryEditorMode;

(function (QueryEditorMode) {
  QueryEditorMode["Code"] = "code";
  QueryEditorMode["Builder"] = "builder";
  QueryEditorMode["Explain"] = "explain";
})(QueryEditorMode || (QueryEditorMode = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/state.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "changeEditorMode": () => (/* binding */ changeEditorMode),
/* harmony export */   "getQueryWithDefaults": () => (/* binding */ getQueryWithDefaults),
/* harmony export */   "useRawQuery": () => (/* binding */ useRawQuery)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var app_core_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/store.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _shared_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");





const queryEditorModeDefaultLocalStorageKey = 'PrometheusQueryEditorModeDefault';
function changeEditorMode(query, editorMode, onChange) {
  // If empty query store new mode as default
  if (query.expr === '') {
    app_core_store__WEBPACK_IMPORTED_MODULE_2__["default"].set(queryEditorModeDefaultLocalStorageKey, editorMode);
  }

  onChange(Object.assign({}, query, {
    editorMode
  }));
}

function getDefaultEditorMode(expr) {
  // If we already have an expression default to code view
  if (expr != null && expr !== '') {
    return _shared_types__WEBPACK_IMPORTED_MODULE_4__.QueryEditorMode.Code;
  }

  const value = app_core_store__WEBPACK_IMPORTED_MODULE_2__["default"].get(queryEditorModeDefaultLocalStorageKey);

  switch (value) {
    case _shared_types__WEBPACK_IMPORTED_MODULE_4__.QueryEditorMode.Builder:
    case _shared_types__WEBPACK_IMPORTED_MODULE_4__.QueryEditorMode.Code:
    case _shared_types__WEBPACK_IMPORTED_MODULE_4__.QueryEditorMode.Explain:
      return value;

    default:
      return _shared_types__WEBPACK_IMPORTED_MODULE_4__.QueryEditorMode.Builder;
  }
}
/**
 * Returns query with defaults, and boolean true/false depending on change was required
 */


function getQueryWithDefaults(query, app) {
  let result = query;

  if (!query.editorMode) {
    result = Object.assign({}, query, {
      editorMode: getDefaultEditorMode(query.expr)
    });
  }

  if (query.expr == null) {
    result = Object.assign({}, result, {
      expr: '',
      legendFormat: _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto
    });
  }

  if (query.range == null && query.instant == null) {
    // Default to range query
    result = Object.assign({}, result, {
      range: true
    }); // In explore we default to both instant & range

    if (app === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore) {
      result.instant = true;
    }
  }

  return result;
}
const queryEditorRawQueryLocalStorageKey = 'PrometheusQueryEditorRawQueryDefault';

function getRawQueryVisibility() {
  const val = app_core_store__WEBPACK_IMPORTED_MODULE_2__["default"].get(queryEditorRawQueryLocalStorageKey);
  return val === undefined ? true : Boolean(parseInt(val, 10));
}

function setRawQueryVisibility(value) {
  app_core_store__WEBPACK_IMPORTED_MODULE_2__["default"].set(queryEditorRawQueryLocalStorageKey, value ? '1' : '0');
}
/**
 * Use and store value of raw query switch in local storage.
 * Needs to be a hook with local state to trigger rerenders.
 */


function useRawQuery() {
  const [rawQuery, setRawQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getRawQueryVisibility());
  const setter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(value => {
    setRawQueryVisibility(value);
    setRawQuery(value);
  }, []);
  return [rawQuery, setter];
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromOperationId": () => (/* binding */ PromOperationId),
/* harmony export */   "PromVisualQueryOperationCategory": () => (/* binding */ PromVisualQueryOperationCategory)
/* harmony export */ });
/**
 * Visual query model
 */
let PromVisualQueryOperationCategory;

(function (PromVisualQueryOperationCategory) {
  PromVisualQueryOperationCategory["Aggregations"] = "Aggregations";
  PromVisualQueryOperationCategory["RangeFunctions"] = "Range functions";
  PromVisualQueryOperationCategory["Functions"] = "Functions";
  PromVisualQueryOperationCategory["BinaryOps"] = "Binary operations";
  PromVisualQueryOperationCategory["Trigonometric"] = "Trigonometric";
  PromVisualQueryOperationCategory["Time"] = "Time Functions";
})(PromVisualQueryOperationCategory || (PromVisualQueryOperationCategory = {}));

let PromOperationId;

(function (PromOperationId) {
  PromOperationId["Abs"] = "abs";
  PromOperationId["Absent"] = "absent";
  PromOperationId["AbsentOverTime"] = "absent_over_time";
  PromOperationId["Acos"] = "acos";
  PromOperationId["Acosh"] = "acosh";
  PromOperationId["Asin"] = "asin";
  PromOperationId["Asinh"] = "asinh";
  PromOperationId["Atan"] = "atan";
  PromOperationId["Atanh"] = "atanh";
  PromOperationId["Avg"] = "avg";
  PromOperationId["AvgOverTime"] = "avg_over_time";
  PromOperationId["BottomK"] = "bottomk";
  PromOperationId["Ceil"] = "ceil";
  PromOperationId["Changes"] = "changes";
  PromOperationId["Clamp"] = "clamp";
  PromOperationId["ClampMax"] = "clamp_max";
  PromOperationId["ClampMin"] = "clamp_min";
  PromOperationId["Cos"] = "cos";
  PromOperationId["Cosh"] = "cosh";
  PromOperationId["Count"] = "count";
  PromOperationId["CountOverTime"] = "count_over_time";
  PromOperationId["CountScalar"] = "count_scalar";
  PromOperationId["CountValues"] = "count_values";
  PromOperationId["DayOfMonth"] = "day_of_month";
  PromOperationId["DayOfWeek"] = "day_of_week";
  PromOperationId["DaysInMonth"] = "days_in_month";
  PromOperationId["Deg"] = "deg";
  PromOperationId["Delta"] = "delta";
  PromOperationId["Deriv"] = "deriv";
  PromOperationId["DropCommonLabels"] = "drop_common_labels";
  PromOperationId["Exp"] = "exp";
  PromOperationId["Floor"] = "floor";
  PromOperationId["Group"] = "group";
  PromOperationId["HistogramQuantile"] = "histogram_quantile";
  PromOperationId["HoltWinters"] = "holt_winters";
  PromOperationId["Hour"] = "hour";
  PromOperationId["Idelta"] = "idelta";
  PromOperationId["Increase"] = "increase";
  PromOperationId["Irate"] = "irate";
  PromOperationId["LabelJoin"] = "label_join";
  PromOperationId["LabelReplace"] = "label_replace";
  PromOperationId["Last"] = "last";
  PromOperationId["LastOverTime"] = "last_over_time";
  PromOperationId["Ln"] = "ln";
  PromOperationId["Log10"] = "log10";
  PromOperationId["Log2"] = "log2";
  PromOperationId["Max"] = "max";
  PromOperationId["MaxOverTime"] = "max_over_time";
  PromOperationId["Min"] = "min";
  PromOperationId["MinOverTime"] = "min_over_time";
  PromOperationId["Minute"] = "minute";
  PromOperationId["Month"] = "month";
  PromOperationId["Pi"] = "pi";
  PromOperationId["PredictLinear"] = "predict_linear";
  PromOperationId["Present"] = "present";
  PromOperationId["PresentOverTime"] = "present_over_time";
  PromOperationId["Quantile"] = "quantile";
  PromOperationId["QuantileOverTime"] = "quantile_over_time";
  PromOperationId["Rad"] = "rad";
  PromOperationId["Rate"] = "rate";
  PromOperationId["Resets"] = "resets";
  PromOperationId["Round"] = "round";
  PromOperationId["Scalar"] = "scalar";
  PromOperationId["Sgn"] = "sgn";
  PromOperationId["Sin"] = "sin";
  PromOperationId["Sinh"] = "sinh";
  PromOperationId["Sort"] = "sort";
  PromOperationId["SortDesc"] = "sort_desc";
  PromOperationId["Sqrt"] = "sqrt";
  PromOperationId["Stddev"] = "stddev";
  PromOperationId["StddevOverTime"] = "stddev_over_time";
  PromOperationId["Sum"] = "sum";
  PromOperationId["SumOverTime"] = "sum_over_time";
  PromOperationId["Tan"] = "tan";
  PromOperationId["Tanh"] = "tanh";
  PromOperationId["Time"] = "time";
  PromOperationId["Timestamp"] = "timestamp";
  PromOperationId["TopK"] = "topk";
  PromOperationId["Vector"] = "vector";
  PromOperationId["Year"] = "year";
  PromOperationId["Addition"] = "__addition";
  PromOperationId["Subtraction"] = "__subtraction";
  PromOperationId["MultiplyBy"] = "__multiply_by";
  PromOperationId["DivideBy"] = "__divide_by";
  PromOperationId["Modulo"] = "__modulo";
  PromOperationId["Exponent"] = "__exponent";
  PromOperationId["NestedQuery"] = "__nested_query";
  PromOperationId["EqualTo"] = "__equal_to";
  PromOperationId["NotEqualTo"] = "__not_equal_to";
  PromOperationId["GreaterThan"] = "__greater_than";
  PromOperationId["LessThan"] = "__less_than";
  PromOperationId["GreaterOrEqual"] = "__greater_or_equal";
  PromOperationId["LessOrEqual"] = "__less_or_equal";
})(PromOperationId || (PromOperationId = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/result_transformer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOriginalMetricName": () => (/* binding */ getOriginalMetricName),
/* harmony export */   "parseSampleValue": () => (/* binding */ parseSampleValue),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformDFToTable": () => (/* binding */ transformDFToTable),
/* harmony export */   "transformV2": () => (/* binding */ transformV2)
/* harmony export */ });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/d3-npm-5.15.0-0c7696026f-7342d82e55.zip/node_modules/d3/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
const _excluded = ["__name__"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






 // handles case-insensitive Inf, +Inf, -Inf (with optional "inity" suffix)

const INFINITY_SAMPLE_REGEX = /^[+-]?inf(?:inity)?$/i;

const isTableResult = (dataFrame, options) => {
  var _dataFrame$meta, _dataFrame$meta$custo, _dataFrame$meta2, _dataFrame$meta2$cust;

  // We want to process vector and scalar results in Explore as table
  if (options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Explore && (((_dataFrame$meta = dataFrame.meta) === null || _dataFrame$meta === void 0 ? void 0 : (_dataFrame$meta$custo = _dataFrame$meta.custom) === null || _dataFrame$meta$custo === void 0 ? void 0 : _dataFrame$meta$custo.resultType) === 'vector' || ((_dataFrame$meta2 = dataFrame.meta) === null || _dataFrame$meta2 === void 0 ? void 0 : (_dataFrame$meta2$cust = _dataFrame$meta2.custom) === null || _dataFrame$meta2$cust === void 0 ? void 0 : _dataFrame$meta2$cust.resultType) === 'scalar')) {
    return true;
  } // We want to process all dataFrames with target.format === 'table' as table


  const target = options.targets.find(target => target.refId === dataFrame.refId);
  return (target === null || target === void 0 ? void 0 : target.format) === 'table';
};

const isHeatmapResult = (dataFrame, options) => {
  const target = options.targets.find(target => target.refId === dataFrame.refId);
  return (target === null || target === void 0 ? void 0 : target.format) === 'heatmap';
}; // V2 result trasnformer used to transform query results from queries that were run trough prometheus backend


function transformV2(response, request, options) {
  const [tableFrames, framesWithoutTable] = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.partition)(response.data, df => isTableResult(df, request));
  const processedTableFrames = transformDFToTable(tableFrames);
  const [exemplarFrames, framesWithoutTableAndExemplars] = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.partition)(framesWithoutTable, df => {
    var _df$meta, _df$meta$custom;

    return ((_df$meta = df.meta) === null || _df$meta === void 0 ? void 0 : (_df$meta$custom = _df$meta.custom) === null || _df$meta$custom === void 0 ? void 0 : _df$meta$custom.resultType) === 'exemplar';
  }); // EXEMPLAR FRAMES: We enrich exemplar frames with data links and add dataTopic meta info

  const {
    exemplarTraceIdDestinations: destinations
  } = options;
  const processedExemplarFrames = exemplarFrames.map(dataFrame => {
    if (destinations !== null && destinations !== void 0 && destinations.length) {
      for (const exemplarTraceIdDestination of destinations) {
        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);

        if (traceIDField) {
          var _traceIDField$config$;

          const links = getDataLinks(exemplarTraceIdDestination);
          traceIDField.config.links = (_traceIDField$config$ = traceIDField.config.links) !== null && _traceIDField$config$ !== void 0 && _traceIDField$config$.length ? [...traceIDField.config.links, ...links] : links;
        }
      }
    }

    return Object.assign({}, dataFrame, {
      meta: Object.assign({}, dataFrame.meta, {
        dataTopic: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataTopic.Annotations
      })
    });
  });
  const [heatmapResults, framesWithoutTableHeatmapsAndExemplars] = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.partition)(framesWithoutTableAndExemplars, df => isHeatmapResult(df, request));
  const processedHeatmapFrames = mergeHeatmapFrames(transformToHistogramOverTime(heatmapResults.sort(sortSeriesByLabel))); // Everything else is processed as time_series result and graph preferredVisualisationType

  const otherFrames = framesWithoutTableHeatmapsAndExemplars.map(dataFrame => {
    const df = Object.assign({}, dataFrame, {
      meta: Object.assign({}, dataFrame.meta, {
        preferredVisualisationType: 'graph'
      })
    });
    return df;
  });
  return Object.assign({}, response, {
    data: [...otherFrames, ...processedTableFrames, ...processedHeatmapFrames, ...processedExemplarFrames]
  });
}
function transformDFToTable(dfs) {
  // If no dataFrames or if 1 dataFrames with no values, return original dataFrame
  if (dfs.length === 0 || dfs.length === 1 && dfs[0].length === 0) {
    return dfs;
  } // Group results by refId and process dataFrames with the same refId as 1 dataFrame


  const dataFramesByRefId = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.groupBy)(dfs, 'refId');
  const refIds = Object.keys(dataFramesByRefId);
  const frames = refIds.map(refId => {
    // Create timeField, valueField and labelFields
    const valueText = getValueText(refIds.length, refId);
    const valueField = getValueField({
      data: [],
      valueName: valueText
    });
    const timeField = getTimeField([]);
    const labelFields = []; // Fill labelsFields with labels from dataFrames

    dataFramesByRefId[refId].forEach(df => {
      var _frameValueField$labe;

      const frameValueField = df.fields[1];
      const promLabels = (_frameValueField$labe = frameValueField.labels) !== null && _frameValueField$labe !== void 0 ? _frameValueField$labe : {};
      Object.keys(promLabels).sort().forEach(label => {
        // If we don't have label in labelFields, add it
        if (!labelFields.some(l => l.name === label)) {
          const numberField = label === 'le';
          labelFields.push({
            name: label,
            config: {
              filterable: true
            },
            type: numberField ? _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.string,
            values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector()
          });
        }
      });
    }); // Fill valueField, timeField and labelFields with values

    dataFramesByRefId[refId].forEach(df => {
      df.fields[0].values.toArray().forEach(value => timeField.values.add(value));
      df.fields[1].values.toArray().forEach(value => {
        var _df$fields$1$labels;

        valueField.values.add(parseSampleValue(value));
        const labelsForField = (_df$fields$1$labels = df.fields[1].labels) !== null && _df$fields$1$labels !== void 0 ? _df$fields$1$labels : {};
        labelFields.forEach(field => field.values.add(getLabelValue(labelsForField, field.name)));
      });
    });
    const fields = [timeField, ...labelFields, valueField];
    return {
      refId,
      fields,
      meta: Object.assign({}, dfs[0].meta, {
        preferredVisualisationType: 'table'
      }),
      length: timeField.values.length
    };
  });
  return frames;
}

function getValueText(responseLength, refId = '') {
  return responseLength > 1 ? `Value #${refId}` : 'Value';
}

function transform(response, transformOptions) {
  // Create options object from transformOptions
  const options = {
    format: transformOptions.target.format,
    step: transformOptions.query.step,
    legendFormat: transformOptions.target.legendFormat,
    start: transformOptions.query.start,
    end: transformOptions.query.end,
    query: transformOptions.query.expr,
    responseListLength: transformOptions.responseListLength,
    scopedVars: transformOptions.scopedVars,
    refId: transformOptions.target.refId,
    valueWithRefId: transformOptions.target.valueWithRefId,
    meta: {
      // Fix for showing of Prometheus results in Explore table
      preferredVisualisationType: transformOptions.query.instant ? 'table' : 'graph'
    }
  };
  const prometheusResult = response.data.data;

  if ((0,_types__WEBPACK_IMPORTED_MODULE_5__.isExemplarData)(prometheusResult)) {
    var _transformOptions$exe;

    const events = [];
    prometheusResult.forEach(exemplarData => {
      const data = exemplarData.exemplars.map(exemplar => {
        return Object.assign({
          [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_TIME_FIELD_NAME]: exemplar.timestamp * 1000,
          [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME]: exemplar.value
        }, exemplar.labels, exemplarData.seriesLabels);
      });
      events.push(...data);
    }); // Grouping exemplars by step

    const sampledExemplars = sampleExemplars(events, options);
    const dataFrame = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayDataFrame(sampledExemplars);
    dataFrame.meta = {
      dataTopic: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataTopic.Annotations
    }; // Add data links if configured

    if ((_transformOptions$exe = transformOptions.exemplarTraceIdDestinations) !== null && _transformOptions$exe !== void 0 && _transformOptions$exe.length) {
      for (const exemplarTraceIdDestination of transformOptions.exemplarTraceIdDestinations) {
        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);

        if (traceIDField) {
          var _traceIDField$config$2;

          const links = getDataLinks(exemplarTraceIdDestination);
          traceIDField.config.links = (_traceIDField$config$2 = traceIDField.config.links) !== null && _traceIDField$config$2 !== void 0 && _traceIDField$config$2.length ? [...traceIDField.config.links, ...links] : links;
        }
      }
    }

    return [dataFrame];
  }

  if (!(prometheusResult !== null && prometheusResult !== void 0 && prometheusResult.result)) {
    return [];
  } // Return early if result type is scalar


  if (prometheusResult.resultType === 'scalar') {
    return [{
      meta: options.meta,
      refId: options.refId,
      length: 1,
      fields: [getTimeField([prometheusResult.result]), getValueField({
        data: [prometheusResult.result]
      })]
    }];
  } // Return early again if the format is table, this needs special transformation.


  if (options.format === 'table') {
    const tableData = transformMetricDataToTable(prometheusResult.result, options);
    return [tableData];
  } // Process matrix and vector results to DataFrame


  const dataFrame = [];
  prometheusResult.result.forEach(data => dataFrame.push(transformToDataFrame(data, options))); // When format is heatmap use the already created data frames and transform it more

  if (options.format === 'heatmap') {
    return mergeHeatmapFrames(transformToHistogramOverTime(dataFrame.sort(sortSeriesByLabel)));
  } // Return matrix or vector result as DataFrame[]


  return dataFrame;
}

function getDataLinks(options) {
  const dataLinks = [];

  if (options.datasourceUid) {
    const dataSourceSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.getDataSourceSrv)();
    const dsSettings = dataSourceSrv.getInstanceSettings(options.datasourceUid); // dsSettings is undefined because of the reasons below:
    // - permissions issues (probably most likely)
    // - deleted datasource
    // - misconfiguration

    if (dsSettings) {
      var _dsSettings$name;

      dataLinks.push({
        title: options.urlDisplayLabel || `Query with ${dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name}`,
        url: '',
        internal: {
          query: {
            query: '${__value.raw}',
            queryType: 'traceId'
          },
          datasourceUid: options.datasourceUid,
          datasourceName: (_dsSettings$name = dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name) !== null && _dsSettings$name !== void 0 ? _dsSettings$name : 'Data source not found'
        }
      });
    }
  }

  if (options.url) {
    dataLinks.push({
      title: options.urlDisplayLabel || `Go to ${options.url}`,
      url: options.url,
      targetBlank: true
    });
  }

  return dataLinks;
}
/**
 * Reduce the density of the exemplars by making sure that the highest value exemplar is included
 * and then only the ones that are 2 times the standard deviation of the all the values.
 * This makes sure not to show too many dots near each other.
 */


function sampleExemplars(events, options) {
  const step = options.step || 15;
  const bucketedExemplars = {};
  const values = [];

  for (const exemplar of events) {
    // Align exemplar timestamp to nearest step second
    const alignedTs = String(Math.floor(exemplar[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_TIME_FIELD_NAME] / 1000 / step) * step * 1000);

    if (!bucketedExemplars[alignedTs]) {
      // New bucket found
      bucketedExemplars[alignedTs] = [];
    }

    bucketedExemplars[alignedTs].push(exemplar);
    values.push(exemplar[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME]);
  } // Getting exemplars from each bucket


  const standardDeviation = (0,d3__WEBPACK_IMPORTED_MODULE_0__.deviation)(values);
  const sampledBuckets = Object.keys(bucketedExemplars).sort();
  const sampledExemplars = [];

  for (const ts of sampledBuckets) {
    const exemplarsInBucket = bucketedExemplars[ts];

    if (exemplarsInBucket.length === 1) {
      sampledExemplars.push(exemplarsInBucket[0]);
    } else {
      // Choose which values to sample
      const bucketValues = exemplarsInBucket.map(ex => ex[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME]).sort(d3__WEBPACK_IMPORTED_MODULE_0__.descending);
      const sampledBucketValues = bucketValues.reduce((acc, curr) => {
        if (acc.length === 0) {
          // First value is max and is always added
          acc.push(curr);
        } else {
          // Then take values only when at least 2 standard deviation distance to previously taken value
          const prev = acc[acc.length - 1];

          if (standardDeviation && prev - curr >= 2 * standardDeviation) {
            acc.push(curr);
          }
        }

        return acc;
      }, []); // Find the exemplars for the sampled values

      sampledExemplars.push(...sampledBucketValues.map(value => exemplarsInBucket.find(ex => ex[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME] === value)));
    }
  }

  return sampledExemplars;
}
/**
 * Transforms matrix and vector result from Prometheus result to DataFrame
 */


function transformToDataFrame(data, options) {
  const {
    name,
    labels
  } = createLabelInfo(data.metric, options);
  const fields = [];

  if ((0,_types__WEBPACK_IMPORTED_MODULE_5__.isMatrixData)(data)) {
    const stepMs = options.step ? options.step * 1000 : NaN;
    let baseTimestamp = options.start * 1000;
    const dps = [];

    for (const value of data.values) {
      let dpValue = parseSampleValue(value[1]);

      if (isNaN(dpValue)) {
        dpValue = null;
      }

      const timestamp = value[0] * 1000;

      for (let t = baseTimestamp; t < timestamp; t += stepMs) {
        dps.push([t, null]);
      }

      baseTimestamp = timestamp + stepMs;
      dps.push([timestamp, dpValue]);
    }

    const endTimestamp = options.end * 1000;

    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {
      dps.push([t, null]);
    }

    fields.push(getTimeField(dps, true));
    fields.push(getValueField({
      data: dps,
      parseValue: false,
      labels,
      displayNameFromDS: name
    }));
  } else {
    fields.push(getTimeField([data.value]));
    fields.push(getValueField({
      data: [data.value],
      labels,
      displayNameFromDS: name
    }));
  }

  return {
    meta: options.meta,
    refId: options.refId,
    length: fields[0].values.length,
    fields,
    name
  };
}

function transformMetricDataToTable(md, options) {
  if (!md || md.length === 0) {
    return {
      meta: options.meta,
      refId: options.refId,
      length: 0,
      fields: []
    };
  }

  const valueText = options.responseListLength > 1 || options.valueWithRefId ? `Value #${options.refId}` : 'Value';
  const timeField = getTimeField([]);
  const metricFields = Object.keys(md.reduce((acc, series) => Object.assign({}, acc, series.metric), {})).sort().map(label => {
    // Labels have string field type, otherwise table tries to figure out the type which can result in unexpected results
    // Only "le" label has a number field type
    const numberField = label === 'le';
    return {
      name: label,
      config: {
        filterable: true
      },
      type: numberField ? _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.string,
      values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector()
    };
  });
  const valueField = getValueField({
    data: [],
    valueName: valueText
  });
  md.forEach(d => {
    if ((0,_types__WEBPACK_IMPORTED_MODULE_5__.isMatrixData)(d)) {
      d.values.forEach(val => {
        timeField.values.add(val[0] * 1000);
        metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));
        valueField.values.add(parseSampleValue(val[1]));
      });
    } else {
      timeField.values.add(d.value[0] * 1000);
      metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));
      valueField.values.add(parseSampleValue(d.value[1]));
    }
  });
  return {
    meta: options.meta,
    refId: options.refId,
    length: timeField.values.length,
    fields: [timeField, ...metricFields, valueField]
  };
}

function getLabelValue(metric, label) {
  if (metric.hasOwnProperty(label)) {
    if (label === 'le') {
      return parseSampleValue(metric[label]);
    }

    return metric[label];
  }

  return '';
}

function getTimeField(data, isMs = false) {
  return {
    name: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_TIME_FIELD_NAME,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.time,
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector(data.map(val => isMs ? val[0] : val[0] * 1000))
  };
}

function getValueField({
  data,
  valueName = _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME,
  parseValue = true,
  labels,
  displayNameFromDS
}) {
  return {
    name: valueName,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number,
    display: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.getDisplayProcessor)(),
    config: {
      displayNameFromDS
    },
    labels,
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector(data.map(val => parseValue ? parseSampleValue(val[1]) : val[1]))
  };
}

function createLabelInfo(labels, options) {
  if (options !== null && options !== void 0 && options.legendFormat) {
    const title = (0,_legend__WEBPACK_IMPORTED_MODULE_4__.renderLegendFormat)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.getTemplateSrv)().replace(options.legendFormat, options === null || options === void 0 ? void 0 : options.scopedVars), labels);
    return {
      name: title,
      labels
    };
  }

  const {
    __name__
  } = labels,
        labelsWithoutName = _objectWithoutPropertiesLoose(labels, _excluded);

  const labelPart = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.formatLabels)(labelsWithoutName);
  let title = `${__name__ !== null && __name__ !== void 0 ? __name__ : ''}${labelPart}`;

  if (!title) {
    title = options.query;
  }

  return {
    name: title,
    labels: labelsWithoutName
  };
}

function getOriginalMetricName(labelData) {
  const metricName = labelData.__name__ || '';
  delete labelData.__name__;
  const labelPart = Object.entries(labelData).map(label => `${label[0]}="${label[1]}"`).join(',');
  return `${metricName}{${labelPart}}`;
}

function mergeHeatmapFrames(frames) {
  if (frames.length === 0) {
    return [];
  }

  const timeField = frames[0].fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.time);
  const countFields = frames.map(frame => {
    let field = frame.fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number);
    return Object.assign({}, field, {
      name: field.config.displayNameFromDS
    });
  });
  return [Object.assign({}, frames[0], {
    meta: Object.assign({}, frames[0].meta, {
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataFrameType.HeatmapRows
    }),
    fields: [timeField, ...countFields]
  })];
}

function transformToHistogramOverTime(seriesList) {
  /*      t1 = timestamp1, t2 = timestamp2 etc.
            t1  t2  t3          t1  t2  t3
    le10    10  10  0     =>    10  10  0
    le20    20  10  30    =>    10  0   30
    le30    30  10  35    =>    10  0   5
    */
  for (let i = seriesList.length - 1; i > 0; i--) {
    const topSeries = seriesList[i].fields.find(s => s.name === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME);
    const bottomSeries = seriesList[i - 1].fields.find(s => s.name === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME);

    if (!topSeries || !bottomSeries) {
      throw new Error('Prometheus heatmap transform error: data should be a time series');
    }

    for (let j = 0; j < topSeries.values.length; j++) {
      const bottomPoint = bottomSeries.values.get(j) || [0];
      topSeries.values.toArray()[j] -= bottomPoint;
    }
  }

  return seriesList;
}

function sortSeriesByLabel(s1, s2) {
  let le1, le2;

  try {
    var _s1$name, _s2$name;

    // fail if not integer. might happen with bad queries
    le1 = parseSampleValue((_s1$name = s1.name) !== null && _s1$name !== void 0 ? _s1$name : '');
    le2 = parseSampleValue((_s2$name = s2.name) !== null && _s2$name !== void 0 ? _s2$name : '');
  } catch (err) {
    console.error(err);
    return 0;
  }

  if (le1 > le2) {
    return 1;
  }

  if (le1 < le2) {
    return -1;
  }

  return 0;
}
/** @internal */


function parseSampleValue(value) {
  if (INFINITY_SAMPLE_REGEX.test(value)) {
    return value[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  }

  return parseFloat(value);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LegendFormatMode": () => (/* binding */ LegendFormatMode),
/* harmony export */   "PromQueryType": () => (/* binding */ PromQueryType),
/* harmony export */   "isExemplarData": () => (/* binding */ isExemplarData),
/* harmony export */   "isMatrixData": () => (/* binding */ isMatrixData)
/* harmony export */ });
let PromQueryType;

(function (PromQueryType) {
  PromQueryType["timeSeriesQuery"] = "timeSeriesQuery";
})(PromQueryType || (PromQueryType = {}));

function isMatrixData(result) {
  return 'values' in result;
}
function isExemplarData(result) {
  if (result == null || !Array.isArray(result)) {
    return false;
  }

  return result.length ? 'exemplars' in result[0] : false;
}

/**
 * Auto = query.legendFormat == '__auto'
 * Verbose = query.legendFormat == null/undefined/''
 * Custom query.legendFormat.length > 0 && query.legendFormat !== '__auto'
 */
let LegendFormatMode;

(function (LegendFormatMode) {
  LegendFormatMode["Auto"] = "__auto";
  LegendFormatMode["Verbose"] = "__verbose";
  LegendFormatMode["Custom"] = "__custom";
})(LegendFormatMode || (LegendFormatMode = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/variables.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrometheusVariableSupport": () => (/* binding */ PrometheusVariableSupport)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/from.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
/* harmony import */ var _metric_find_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/metric_find_query.ts");






class PrometheusVariableSupport extends _grafana_data__WEBPACK_IMPORTED_MODULE_0__.StandardVariableSupport {
  constructor(datasource, templateSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getTemplateSrv)(), timeSrv = (0,_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_2__.getTimeSrv)()) {
    super();
    this.datasource = datasource;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.query = this.query.bind(this);
  }

  query(request) {
    const query = request.targets[0].expr;

    if (!query) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.of)({
        data: []
      });
    }

    const scopedVars = Object.assign({}, request.scopedVars, {
      __interval: {
        text: this.datasource.interval,
        value: this.datasource.interval
      },
      __interval_ms: {
        text: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.rangeUtil.intervalToMs(this.datasource.interval),
        value: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.rangeUtil.intervalToMs(this.datasource.interval)
      }
    }, this.datasource.getRangeScopedVars(this.timeSrv.timeRange()));
    const interpolated = this.templateSrv.replace(query, scopedVars, this.datasource.interpolateQueryExpr);
    const metricFindQuery = new _metric_find_query__WEBPACK_IMPORTED_MODULE_3__["default"](this.datasource, interpolated);
    const metricFindStream = (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.from)(metricFindQuery.process());
    return metricFindStream.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(results => ({
      data: results
    })));
  }

  toDataQuery(query) {
    return {
      refId: 'PrometheusDatasource-VariableQuery',
      expr: query.query
    };
  }

}

/***/ }),

/***/ "./.yarn/__virtual__/react-popper-tooltip-virtual-ff0da4b2fd/0/cache/react-popper-tooltip-npm-4.4.1-2214480dbc-58dacdf9bc.zip/node_modules/react-popper-tooltip/dist/esm/react-popper-tooltip.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "usePopperTooltip": () => (/* binding */ usePopperTooltip)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@babel-runtime-npm-7.18.3-1883c70fa6-db8526226a.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@babel-runtime-npm-7.18.3-1883c70fa6-db8526226a.zip/node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_popper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/react-popper-virtual-44630d53ac/0/cache/react-popper-npm-2.3.0-1045578379-837111c987.zip/node_modules/react-popper/lib/esm/usePopper.js");





function useGetLatest(val) {
  var ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(val);
  ref.current = val;
  return react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function () {
    return ref.current;
  }, []);
}

var noop = function noop() {// do nothing
};

function useControlledState(_ref) {
  var initial = _ref.initial,
      value = _ref.value,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? noop : _ref$onChange;

  if (initial === undefined && value === undefined) {
    throw new TypeError('Either "value" or "initial" variable must be set. Now both are undefined');
  }

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_2__.useState(initial),
      state = _React$useState[0],
      setState = _React$useState[1];

  var getLatest = useGetLatest(state);
  var set = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function (updater) {
    var state = getLatest();
    var updatedState = typeof updater === 'function' ? updater(state) : updater;
    if (typeof updatedState.persist === 'function') updatedState.persist();
    setState(updatedState);
    if (typeof onChange === 'function') onChange(updatedState);
  }, [getLatest, onChange]);
  var isControlled = value !== undefined;
  return [isControlled ? value : state, isControlled ? onChange : set];
}
function generateBoundingClientRect(x, y) {
  if (x === void 0) {
    x = 0;
  }

  if (y === void 0) {
    y = 0;
  }

  return function () {
    return {
      width: 0,
      height: 0,
      top: y,
      right: x,
      bottom: y,
      left: x,
      x: 0,
      y: 0,
      toJSON: function toJSON() {
        return null;
      }
    };
  };
}

var _excluded = ["styles", "attributes"];
var virtualElement = {
  getBoundingClientRect: generateBoundingClientRect()
};
var defaultConfig = {
  closeOnOutsideClick: true,
  closeOnTriggerHidden: false,
  defaultVisible: false,
  delayHide: 0,
  delayShow: 0,
  followCursor: false,
  interactive: false,
  mutationObserverOptions: {
    attributes: true,
    childList: true,
    subtree: true
  },
  offset: [0, 6],
  trigger: 'hover'
};
function usePopperTooltip(config, popperOptions) {
  var _popperProps$state, _popperProps$state$mo, _popperProps$state$mo2;

  if (config === void 0) {
    config = {};
  }

  if (popperOptions === void 0) {
    popperOptions = {};
  }

  // Merging options with default options.
  // Keys with undefined values are replaced with the default ones if any.
  // Keys with other values pass through.
  var finalConfig = Object.keys(defaultConfig).reduce(function (config, key) {
    var _extends2;

    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, config, (_extends2 = {}, _extends2[key] = config[key] !== undefined ? config[key] : defaultConfig[key], _extends2));
  }, config);
  var defaultModifiers = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(function () {
    return [{
      name: 'offset',
      options: {
        offset: finalConfig.offset
      }
    }];
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  Array.isArray(finalConfig.offset) ? finalConfig.offset : []);

  var finalPopperOptions = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, popperOptions, {
    placement: popperOptions.placement || finalConfig.placement,
    modifiers: popperOptions.modifiers || defaultModifiers
  });

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_2__.useState(null),
      triggerRef = _React$useState[0],
      setTriggerRef = _React$useState[1];

  var _React$useState2 = react__WEBPACK_IMPORTED_MODULE_2__.useState(null),
      tooltipRef = _React$useState2[0],
      setTooltipRef = _React$useState2[1];

  var _useControlledState = useControlledState({
    initial: finalConfig.defaultVisible,
    value: finalConfig.visible,
    onChange: finalConfig.onVisibleChange
  }),
      visible = _useControlledState[0],
      setVisible = _useControlledState[1];

  var timer = react__WEBPACK_IMPORTED_MODULE_2__.useRef();
  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    return function () {
      return clearTimeout(timer.current);
    };
  }, []);

  var _usePopper = (0,react_popper__WEBPACK_IMPORTED_MODULE_3__.usePopper)(finalConfig.followCursor ? virtualElement : triggerRef, tooltipRef, finalPopperOptions),
      styles = _usePopper.styles,
      attributes = _usePopper.attributes,
      popperProps = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(_usePopper, _excluded);

  var update = popperProps.update;
  var getLatest = useGetLatest({
    visible: visible,
    triggerRef: triggerRef,
    tooltipRef: tooltipRef,
    finalConfig: finalConfig
  });
  var isTriggeredBy = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function (trigger) {
    return Array.isArray(finalConfig.trigger) ? finalConfig.trigger.includes(trigger) : finalConfig.trigger === trigger;
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  Array.isArray(finalConfig.trigger) ? finalConfig.trigger : [finalConfig.trigger]);
  var hideTooltip = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function () {
    clearTimeout(timer.current);
    timer.current = window.setTimeout(function () {
      return setVisible(false);
    }, finalConfig.delayHide);
  }, [finalConfig.delayHide, setVisible]);
  var showTooltip = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function () {
    clearTimeout(timer.current);
    timer.current = window.setTimeout(function () {
      return setVisible(true);
    }, finalConfig.delayShow);
  }, [finalConfig.delayShow, setVisible]);
  var toggleTooltip = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(function () {
    if (getLatest().visible) {
      hideTooltip();
    } else {
      showTooltip();
    }
  }, [getLatest, hideTooltip, showTooltip]); // Handle click outside

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (!getLatest().finalConfig.closeOnOutsideClick) return;

    var handleClickOutside = function handleClickOutside(event) {
      var _event$composedPath;

      var _getLatest = getLatest(),
          tooltipRef = _getLatest.tooltipRef,
          triggerRef = _getLatest.triggerRef;

      var target = (event.composedPath == null ? void 0 : (_event$composedPath = event.composedPath()) == null ? void 0 : _event$composedPath[0]) || event.target;

      if (target instanceof Node) {
        if (tooltipRef != null && triggerRef != null && !tooltipRef.contains(target) && !triggerRef.contains(target)) {
          hideTooltip();
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return function () {
      return document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [getLatest, hideTooltip]); // Trigger: click

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (triggerRef == null || !isTriggeredBy('click')) return;
    triggerRef.addEventListener('click', toggleTooltip);
    return function () {
      return triggerRef.removeEventListener('click', toggleTooltip);
    };
  }, [triggerRef, isTriggeredBy, toggleTooltip]); // Trigger: double-click

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (triggerRef == null || !isTriggeredBy('double-click')) return;
    triggerRef.addEventListener('dblclick', toggleTooltip);
    return function () {
      return triggerRef.removeEventListener('dblclick', toggleTooltip);
    };
  }, [triggerRef, isTriggeredBy, toggleTooltip]); // Trigger: right-click

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (triggerRef == null || !isTriggeredBy('right-click')) return;

    var preventDefaultAndToggle = function preventDefaultAndToggle(event) {
      // Don't show the context menu
      event.preventDefault();
      toggleTooltip();
    };

    triggerRef.addEventListener('contextmenu', preventDefaultAndToggle);
    return function () {
      return triggerRef.removeEventListener('contextmenu', preventDefaultAndToggle);
    };
  }, [triggerRef, isTriggeredBy, toggleTooltip]); // Trigger: focus

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (triggerRef == null || !isTriggeredBy('focus')) return;
    triggerRef.addEventListener('focus', showTooltip);
    triggerRef.addEventListener('blur', hideTooltip);
    return function () {
      triggerRef.removeEventListener('focus', showTooltip);
      triggerRef.removeEventListener('blur', hideTooltip);
    };
  }, [triggerRef, isTriggeredBy, showTooltip, hideTooltip]); // Trigger: hover on trigger

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (triggerRef == null || !isTriggeredBy('hover')) return;
    triggerRef.addEventListener('mouseenter', showTooltip);
    triggerRef.addEventListener('mouseleave', hideTooltip);
    return function () {
      triggerRef.removeEventListener('mouseenter', showTooltip);
      triggerRef.removeEventListener('mouseleave', hideTooltip);
    };
  }, [triggerRef, isTriggeredBy, showTooltip, hideTooltip]); // Trigger: hover on tooltip, keep it open if hovered

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (tooltipRef == null || !getLatest().finalConfig.interactive) return;
    tooltipRef.addEventListener('mouseenter', showTooltip);
    tooltipRef.addEventListener('mouseleave', hideTooltip);
    return function () {
      tooltipRef.removeEventListener('mouseenter', showTooltip);
      tooltipRef.removeEventListener('mouseleave', hideTooltip);
    };
  }, [tooltipRef, showTooltip, hideTooltip, getLatest]); // Handle closing tooltip if trigger hidden

  var isReferenceHidden = popperProps == null ? void 0 : (_popperProps$state = popperProps.state) == null ? void 0 : (_popperProps$state$mo = _popperProps$state.modifiersData) == null ? void 0 : (_popperProps$state$mo2 = _popperProps$state$mo.hide) == null ? void 0 : _popperProps$state$mo2.isReferenceHidden;
  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (finalConfig.closeOnTriggerHidden && isReferenceHidden) hideTooltip();
  }, [finalConfig.closeOnTriggerHidden, hideTooltip, isReferenceHidden]); // Handle follow cursor

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (!finalConfig.followCursor || triggerRef == null) return;

    function setMousePosition(_ref) {
      var clientX = _ref.clientX,
          clientY = _ref.clientY;
      virtualElement.getBoundingClientRect = generateBoundingClientRect(clientX, clientY);
      update == null ? void 0 : update();
    }

    triggerRef.addEventListener('mousemove', setMousePosition);
    return function () {
      return triggerRef.removeEventListener('mousemove', setMousePosition);
    };
  }, [finalConfig.followCursor, triggerRef, update]); // Handle tooltip DOM mutation changes (aka mutation observer)

  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(function () {
    if (tooltipRef == null || update == null || finalConfig.mutationObserverOptions == null) return;
    var observer = new MutationObserver(update);
    observer.observe(tooltipRef, finalConfig.mutationObserverOptions);
    return function () {
      return observer.disconnect();
    };
  }, [finalConfig.mutationObserverOptions, tooltipRef, update]); // Tooltip props getter

  var getTooltipProps = function getTooltipProps(args) {
    if (args === void 0) {
      args = {};
    }

    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, args, {
      style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, args.style, styles.popper)
    }, attributes.popper, {
      'data-popper-interactive': finalConfig.interactive
    });
  }; // Arrow props getter


  var getArrowProps = function getArrowProps(args) {
    if (args === void 0) {
      args = {};
    }

    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, args, attributes.arrow, {
      style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, args.style, styles.arrow),
      'data-popper-arrow': true
    });
  };

  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
    getArrowProps: getArrowProps,
    getTooltipProps: getTooltipProps,
    setTooltipRef: setTooltipRef,
    setTriggerRef: setTriggerRef,
    tooltipRef: tooltipRef,
    triggerRef: triggerRef,
    visible: visible
  }, popperProps);
}


//# sourceMappingURL=react-popper-tooltip.js.map


/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/usePrevious.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ usePrevious)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

function usePrevious(state) {
    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
        ref.current = state;
    });
    return ref.current;
}


/***/ }),

/***/ "./.yarn/cache/@grafana-aws-sdk-npm-0.0.36-8ab4b07904-c243f7c900.zip/node_modules/@grafana/aws-sdk/dist/index.development.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
var React__default = _interopDefault(React);
var ui = __webpack_require__("./packages/grafana-ui/src/index.ts");
var data = __webpack_require__("./packages/grafana-data/src/index.ts");
var lodash = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

var standardRegions = [
    'af-south-1',
    'ap-east-1',
    'ap-northeast-1',
    'ap-northeast-2',
    'ap-northeast-3',
    'ap-south-1',
    'ap-southeast-1',
    'ap-southeast-2',
    'ca-central-1',
    'cn-north-1',
    'cn-northwest-1',
    'eu-central-1',
    'eu-north-1',
    'eu-west-1',
    'eu-west-2',
    'eu-west-3',
    'me-south-1',
    'sa-east-1',
    'us-east-1',
    'us-east-2',
    'us-gov-east-1',
    'us-gov-west-1',
    'us-iso-east-1',
    'us-isob-east-1',
    'us-west-1',
    'us-west-2',
];

(function (AwsAuthType) {
    AwsAuthType["Keys"] = "keys";
    AwsAuthType["Credentials"] = "credentials";
    AwsAuthType["Default"] = "default";
    AwsAuthType["EC2IAMRole"] = "ec2_iam_role";
    /**
     * @deprecated use default
     */
    AwsAuthType["ARN"] = "arn";
})(exports.AwsAuthType || (exports.AwsAuthType = {}));

var awsAuthProviderOptions = [
    {
        label: 'Workspace IAM Role',
        value: exports.AwsAuthType.EC2IAMRole,
    },
    {
        label: 'AWS SDK Default',
        value: exports.AwsAuthType.Default,
    },
    {
        label: 'Access & secret key',
        value: exports.AwsAuthType.Keys,
    },
    {
        label: 'Credentials file',
        value: exports.AwsAuthType.Credentials,
    },
];

var toOption = function (value) { return ({ value: value, label: value }); };
var ConnectionConfig = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    var _k = __read(React.useState((props.standardRegions || standardRegions).map(toOption)), 2), regions = _k[0], setRegions = _k[1];
    var loadRegions = props.loadRegions, onOptionsChange = props.onOptionsChange, _l = props.skipHeader, skipHeader = _l === void 0 ? false : _l, _m = props.skipEndpoint, skipEndpoint = _m === void 0 ? false : _m;
    var options = props.options;
    var profile = options.jsonData.profile;
    if (profile === undefined) {
        profile = options.database;
    }
    var settings = window.grafanaBootData.settings;
    var awsAllowedAuthProviders = (_a = settings.awsAllowedAuthProviders) !== null && _a !== void 0 ? _a : [
        exports.AwsAuthType.Default,
        exports.AwsAuthType.Keys,
        exports.AwsAuthType.Credentials,
    ];
    var awsAssumeRoleEnabled = (_b = settings.awsAssumeRoleEnabled) !== null && _b !== void 0 ? _b : true;
    var currentProvider = awsAuthProviderOptions.find(function (p) { return p.value === options.jsonData.authType; });
    React.useEffect(function () {
        // Make sure a authType exists in the current model
        if (!currentProvider && awsAllowedAuthProviders.length) {
            onOptionsChange(__assign(__assign({}, options), { jsonData: __assign(__assign({}, options.jsonData), { authType: awsAllowedAuthProviders[0] }) }));
        }
    }, [currentProvider, options, onOptionsChange]);
    React.useEffect(function () {
        if (!loadRegions) {
            return;
        }
        loadRegions().then(function (regions) { return setRegions(regions.map(toOption)); });
    }, [loadRegions]);
    return (React__default.createElement(ui.FieldSet, { label: skipHeader ? '' : 'Connection Details', "data-testid": "connection-config" },
        React__default.createElement(ui.InlineField, { label: "Authentication Provider", labelWidth: 28, tooltip: "Specify which AWS credentials chain to use." },
            React__default.createElement(ui.Select, { "aria-label": "Authentication Provider", className: "width-30", value: currentProvider, options: awsAuthProviderOptions.filter(function (opt) { return awsAllowedAuthProviders.includes(opt.value); }), defaultValue: options.jsonData.authType, onChange: function (option) {
                    data.onUpdateDatasourceJsonDataOptionSelect(props, 'authType')(option);
                }, menuShouldPortal: true })),
        options.jsonData.authType === 'credentials' && (React__default.createElement(ui.InlineField, { label: "Credentials Profile Name", labelWidth: 28, tooltip: "Credentials profile name, as specified in ~/.aws/credentials, leave blank for default." },
            React__default.createElement(ui.Input, { "aria-label": "Credentials Profile Name", className: "width-30", placeholder: "default", value: profile, onChange: data.onUpdateDatasourceJsonDataOption(props, 'profile') }))),
        options.jsonData.authType === 'keys' && (React__default.createElement(React__default.Fragment, null,
            React__default.createElement(ui.InlineField, { label: "Access Key ID", labelWidth: 28 }, ((_c = props.options.secureJsonFields) === null || _c === void 0 ? void 0 : _c.accessKey) ? (React__default.createElement(ui.ButtonGroup, { className: "width-30" },
                React__default.createElement(ui.Input, { disabled: true, placeholder: "Configured" }),
                React__default.createElement(ui.ToolbarButton, { icon: "edit", tooltip: "Edit Access Key ID", type: "button", onClick: data.onUpdateDatasourceResetOption(props, 'accessKey') }))) : (React__default.createElement(ui.Input, { "aria-label": "Access Key ID", className: "width-30", value: (_e = (_d = options.secureJsonData) === null || _d === void 0 ? void 0 : _d.accessKey) !== null && _e !== void 0 ? _e : '', onChange: data.onUpdateDatasourceSecureJsonDataOption(props, 'accessKey') }))),
            React__default.createElement(ui.InlineField, { label: "Secret Access Key", labelWidth: 28 }, ((_f = props.options.secureJsonFields) === null || _f === void 0 ? void 0 : _f.secretKey) ? (React__default.createElement(ui.ButtonGroup, { className: "width-30" },
                React__default.createElement(ui.Input, { disabled: true, placeholder: "Configured" }),
                React__default.createElement(ui.ToolbarButton, { icon: "edit", type: "button", tooltip: "Edit Secret Access Key", onClick: data.onUpdateDatasourceResetOption(props, 'secretKey') }))) : (React__default.createElement(ui.Input, { "aria-label": "Secret Access Key", className: "width-30", value: (_h = (_g = options.secureJsonData) === null || _g === void 0 ? void 0 : _g.secretKey) !== null && _h !== void 0 ? _h : '', onChange: data.onUpdateDatasourceSecureJsonDataOption(props, 'secretKey') }))))),
        awsAssumeRoleEnabled && (React__default.createElement(React__default.Fragment, null,
            React__default.createElement(ui.InlineField, { label: "Assume Role ARN", labelWidth: 28, tooltip: "Optionally, specify the ARN of a role to assume. Specifying a role here will ensure that the selected authentication provider is used to assume the specified role rather than using the credentials directly. Leave blank if you don't need to assume a role at all" },
                React__default.createElement(ui.Input, { "aria-label": "Assume Role ARN", className: "width-30", placeholder: "arn:aws:iam:*", value: options.jsonData.assumeRoleArn || '', onChange: data.onUpdateDatasourceJsonDataOption(props, 'assumeRoleArn') })),
            React__default.createElement(ui.InlineField, { label: "External ID", labelWidth: 28, tooltip: "If you are assuming a role in another account, that has been created with an external ID, specify the external ID here." },
                React__default.createElement(ui.Input, { "aria-label": "External ID", className: "width-30", placeholder: "External ID", value: options.jsonData.externalId || '', onChange: data.onUpdateDatasourceJsonDataOption(props, 'externalId') })))),
        !skipEndpoint && (React__default.createElement(ui.InlineField, { label: "Endpoint", labelWidth: 28, tooltip: "Optionally, specify a custom endpoint for the service" },
            React__default.createElement(ui.Input, { "aria-label": "Endpoint", className: "width-30", placeholder: (_j = props.defaultEndpoint) !== null && _j !== void 0 ? _j : 'https://{service}.{region}.amazonaws.com', value: options.jsonData.endpoint || '', onChange: data.onUpdateDatasourceJsonDataOption(props, 'endpoint') }))),
        React__default.createElement(ui.InlineField, { label: "Default Region", labelWidth: 28, tooltip: "Specify the region, such as for US West (Oregon) use ` us-west-2 ` as the region." },
            React__default.createElement(ui.Select, { "aria-label": "Default Region", className: "width-30", value: regions.find(function (region) { return region.value === options.jsonData.defaultRegion; }), options: regions, defaultValue: options.jsonData.defaultRegion, allowCustomValue: true, onChange: data.onUpdateDatasourceJsonDataOptionSelect(props, 'defaultRegion'), formatCreateLabel: function (r) { return "Use region: " + r; }, menuShouldPortal: true })),
        props.children));
};

var SIGV4ConnectionConfig = function (props) {
    var _a, _b, _c, _d;
    var onOptionsChange = props.onOptionsChange, options = props.options;
    // Map HttpSettings props to ConnectionConfigProps
    var connectionConfigProps = {
        onOptionsChange: function (awsDataSourceSettings) {
            var _a, _b, _c, _d;
            var dataSourceSettings = __assign(__assign({}, options), { jsonData: __assign(__assign({}, options.jsonData), { sigV4AuthType: awsDataSourceSettings.jsonData.authType, sigV4Profile: awsDataSourceSettings.jsonData.profile, sigV4AssumeRoleArn: awsDataSourceSettings.jsonData.assumeRoleArn, sigV4ExternalId: awsDataSourceSettings.jsonData.externalId, sigV4Region: awsDataSourceSettings.jsonData.defaultRegion, sigV4Endpoint: awsDataSourceSettings.jsonData.endpoint }), secureJsonFields: {
                    sigV4AccessKey: (_a = awsDataSourceSettings.secureJsonFields) === null || _a === void 0 ? void 0 : _a.accessKey,
                    sigV4SecretKey: (_b = awsDataSourceSettings.secureJsonFields) === null || _b === void 0 ? void 0 : _b.secretKey,
                }, secureJsonData: {
                    sigV4AccessKey: (_c = awsDataSourceSettings.secureJsonData) === null || _c === void 0 ? void 0 : _c.accessKey,
                    sigV4SecretKey: (_d = awsDataSourceSettings.secureJsonData) === null || _d === void 0 ? void 0 : _d.secretKey,
                } });
            onOptionsChange(dataSourceSettings);
        },
        options: __assign(__assign({}, options), { jsonData: __assign(__assign({}, options.jsonData), { authType: options.jsonData.sigV4AuthType, profile: options.jsonData.sigV4Profile, assumeRoleArn: options.jsonData.sigV4AssumeRoleArn, externalId: options.jsonData.sigV4ExternalId, defaultRegion: options.jsonData.sigV4Region, endpoint: options.jsonData.sigV4Endpoint }), secureJsonFields: {
                accessKey: (_a = options.secureJsonFields) === null || _a === void 0 ? void 0 : _a.sigV4AccessKey,
                secretKey: (_b = options.secureJsonFields) === null || _b === void 0 ? void 0 : _b.sigV4SecretKey,
            }, secureJsonData: {
                accessKey: (_c = options.secureJsonData) === null || _c === void 0 ? void 0 : _c.sigV4AccessKey,
                secretKey: (_d = options.secureJsonData) === null || _d === void 0 ? void 0 : _d.sigV4SecretKey,
            } }),
    };
    return (React__default.createElement(React__default.Fragment, null,
        React__default.createElement("div", { className: "gf-form" },
            React__default.createElement("h6", null, "SigV4 Auth Details")),
        React__default.createElement(ConnectionConfig, __assign({}, connectionConfigProps, { skipHeader: true, skipEndpoint: true }))));
};

var defaultKey = '__default';

function ResourceSelector(props) {
    var _this = this;
    var _a = __read(React.useState(props.value || props.default || null), 2), resource = _a[0], setResource = _a[1];
    var _b = __read(React.useState(resource ? [resource] : []), 2), resources = _b[0], setResources = _b[1];
    var _c = __read(React.useState(props.dependencies), 2), dependencies = _c[0], setDependencies = _c[1];
    var _d = __read(React.useState(false), 2), isLoading = _d[0], setIsLoading = _d[1];
    var _e = __read(React.useState(false), 2), fetched = _e[0], setFetched = _e[1];
    var defaultOpts = React.useMemo(function () {
        var opts = [
            {
                label: "default (" + props.default + ")",
                value: defaultKey,
                description: "Default value set in the data source",
            },
        ];
        if (props.value && props.value !== defaultKey) {
            opts.push({ label: props.value, value: props.value });
        }
        return opts;
    }, [props.default, props.value]);
    var _f = __read(React.useState(props.default ? defaultOpts : []), 2), options = _f[0], setOptions = _f[1];
    React.useEffect(function () {
        if (props.resources !== undefined) {
            setResources(props.resources);
        }
    }, [props.resources]);
    React.useEffect(function () {
        var newOptions = props.default ? defaultOpts : [];
        if (resources.length) {
            resources.forEach(function (r) {
                var value = typeof r === 'string' ? r : r.value;
                if (!newOptions.find(function (o) { return o.value === value; })) {
                    typeof r === 'string' ? newOptions.push({ label: r, value: r }) : newOptions.push(r);
                }
            });
            setOptions(newOptions);
        }
        else {
            setOptions([]);
        }
    }, [resources, defaultOpts, props.default]);
    React.useEffect(function () {
        // A change in the dependencies cause a state clean-up
        if (!lodash.isEqual(props.dependencies, dependencies)) {
            setFetched(false);
            setResource(null);
            props.onChange(null);
            setDependencies(props.dependencies);
        }
    }, [props, dependencies]);
    var fetch = function () { return __awaiter(_this, void 0, void 0, function () {
        var resources_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (fetched) {
                        return [2 /*return*/];
                    }
                    if (!props.saveOptions) return [3 /*break*/, 2];
                    return [4 /*yield*/, props.saveOptions()];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, , 4, 5]);
                    return [4 /*yield*/, props.fetch()];
                case 3:
                    resources_1 = _a.sent();
                    setResources(resources_1);
                    return [3 /*break*/, 5];
                case 4:
                    setFetched(true);
                    return [7 /*endfinally*/];
                case 5: return [2 /*return*/];
            }
        });
    }); };
    var onChange = function (e) {
        props.onChange(e);
        if (e.value) {
            setResource(e.value);
        }
    };
    var onClick = function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    setIsLoading(true);
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 4]);
                    return [4 /*yield*/, fetch()];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    setIsLoading(false);
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
            }
        });
    }); };
    return (React__default.createElement(ui.InlineField, { label: props.label, labelWidth: props.labelWidth, tooltip: props.tooltip, hidden: props.hidden },
        React__default.createElement("div", { "data-testid": props['data-testid'], title: props.title },
            React__default.createElement(ui.Select, __assign({}, props, { "aria-label": props.label, options: options, onChange: onChange, isLoading: isLoading, className: props.className || 'min-width-6', onOpenMenu: function () { return props.fetch && onClick(); }, menuShouldPortal: true })))));
}

function ConfigSelect(props) {
    var jsonData = props.options.jsonData;
    var commonProps = {
        title: jsonData.defaultRegion ? '' : 'select a default region',
        labelWidth: 28,
        className: 'width-30',
    };
    // Any change in the AWS connection details will affect selectors
    var dependencies = [
        props.options.jsonData.assumeRoleArn,
        props.options.jsonData.authType,
        props.options.jsonData.defaultRegion,
        props.options.jsonData.endpoint,
        props.options.jsonData.externalId,
        props.options.jsonData.profile,
    ].concat(props.dependencies);
    return (React__default.createElement(ResourceSelector, __assign({ label: props.label, "data-testid": props['data-testid'], onChange: props.onChange, fetch: props.fetch, value: props.value, saveOptions: props.saveOptions, dependencies: dependencies, hidden: props.hidden, disabled: props.disabled || !jsonData.defaultRegion, allowCustomValue: props.allowCustomValue, autoFocus: props.autoFocus, backspaceRemovesValue: props.backspaceRemovesValue, className: props.className, invalid: props.invalid, isClearable: props.isClearable, isMulti: props.isMulti, inputId: props.inputId, showAllSelectedWhenOpen: props.showAllSelectedWhenOpen, maxMenuHeight: props.maxMenuHeight, minMenuHeight: props.minMenuHeight, maxVisibleValues: props.maxVisibleValues, menuPlacement: props.menuPlacement, menuPosition: props.menuPosition, noOptionsMessage: props.noOptionsMessage, onBlur: props.onBlur, onCreateOption: props.onCreateOption, onInputChange: props.onInputChange, placeholder: props.placeholder, width: props.width, isOptionDisabled: props.isOptionDisabled }, commonProps)));
}

function InlineInput(props) {
    return (React__default.createElement(ui.InlineField, { label: props.label, labelWidth: 28, tooltip: props.tooltip, hidden: props.hidden, disabled: props.disabled },
        React__default.createElement(ui.Input, { "data-testid": props['data-testid'], className: "width-30", value: props.value, onChange: props.onChange, placeholder: props.placeholder, disabled: props.disabled })));
}

function QueryCodeEditor(props) {
    var getSuggestions = props.getSuggestions, query = props.query;
    var rawSQL = lodash.defaults(props.query, { rawSQL: '' }).rawSQL;
    var onRawSqlChange = function (rawSQL) {
        var query = __assign(__assign({}, props.query), { rawSQL: rawSQL });
        props.onChange(query);
        props.onRunQuery();
    };
    // Use a reference for suggestions because a bug in CodeEditor getSuggestions
    // https://github.com/grafana/grafana/issues/40121
    // It was been fixed in 8.3 but keeping the workaround here to support older
    // versions.
    var suggestionsRef = React.useRef([]);
    React.useEffect(function () {
        suggestionsRef.current = getSuggestions(query);
    }, [getSuggestions, query]);
    return (React__default.createElement(ui.CodeEditor, __assign({ language: props.language, value: rawSQL, onBlur: onRawSqlChange, showMiniMap: false, showLineNumbers: true, getSuggestions: function () { return suggestionsRef.current; }, height: "240px" }, props.editorProps)));
}

function FormatSelect(props) {
    var onChangeFormat = function (e) {
        props.onChange(__assign(__assign({}, props.query), { format: e.value || 0 }));
        props.onRunQuery();
    };
    return (React__default.createElement(ui.InlineField, { label: "Format as", labelWidth: 11 },
        React__default.createElement(ui.Select, { "aria-label": "Format as", options: props.options, value: props.query.format, onChange: onChangeFormat, className: "width-12", menuShouldPortal: true })));
}

(function (FillValueOptions) {
    FillValueOptions[FillValueOptions["Previous"] = 0] = "Previous";
    FillValueOptions[FillValueOptions["Null"] = 1] = "Null";
    FillValueOptions[FillValueOptions["Value"] = 2] = "Value";
})(exports.FillValueOptions || (exports.FillValueOptions = {}));
var SelectableFillValueOptions = [
    {
        label: 'Previous Value',
        value: exports.FillValueOptions.Previous,
    },
    {
        label: 'NULL',
        value: exports.FillValueOptions.Null,
    },
    {
        label: 'Value',
        value: exports.FillValueOptions.Value,
    },
];
function FillValueSelect(props) {
    var _a, _b, _c;
    return (React__default.createElement(React__default.Fragment, null,
        React__default.createElement(ui.InlineField, { label: "Fill value", tooltip: "value to fill missing points" },
            React__default.createElement(ui.Select, { "aria-label": "Fill value", options: SelectableFillValueOptions, value: (_b = (_a = props.query.fillMode) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : exports.FillValueOptions.Previous, onChange: function (_a) {
                    var value = _a.value;
                    props.onChange(__assign(__assign({}, props.query), { 
                        // Keep the fillMode.value in case FillValueOptions.Value mode is selected back
                        fillMode: __assign(__assign({}, props.query.fillMode), { mode: value }) }));
                    props.onRunQuery();
                }, className: "width-12", menuShouldPortal: true })),
        ((_c = props.query.fillMode) === null || _c === void 0 ? void 0 : _c.mode) === exports.FillValueOptions.Value && (React__default.createElement(ui.InlineField, { label: "Value", labelWidth: 11 },
            React__default.createElement(ui.Input, { type: "number", "aria-label": "Value", value: props.query.fillMode.value, onChange: function (_a) {
                    var currentTarget = _a.currentTarget;
                    return props.onChange(__assign(__assign({}, props.query), { fillMode: {
                            mode: exports.FillValueOptions.Value,
                            value: currentTarget.valueAsNumber,
                        } }));
                }, onBlur: function () { return props.onRunQuery(); } })))));
}

/**
 * Do not execute queries that do not exist yet
 */
function filterSQLQuery(query) {
    return !!query.rawSQL;
}
function applySQLTemplateVariables(query, scopedVars, getTemplateSrv) {
    var templateSrv = getTemplateSrv();
    return __assign(__assign({}, query), { rawSQL: templateSrv.replace(query.rawSQL, scopedVars, interpolateVariable) });
}
function interpolateVariable(value) {
    if (typeof value === 'string') {
        return value;
    }
    var quotedValues = value.map(function (v) {
        return quoteLiteral(v);
    });
    return quotedValues.join(',');
}
function quoteLiteral(value) {
    return "'" + String(value).replace(/'/g, "''") + "'";
}
var appendTemplateVariablesAsSuggestions = function (getTemplateSrv, sugs) {
    var templateSrv = getTemplateSrv();
    var templateSugs = [];
    templateSrv.getVariables().forEach(function (variable) {
        var label = '$' + variable.name;
        var val = templateSrv.replace(label);
        if (val === label) {
            val = '';
        }
        templateSugs.push({
            label: label,
            kind: ui.CodeEditorSuggestionItemKind.Text,
            detail: "(Template Variable) " + val,
        });
    });
    return sugs.concat(templateSugs);
};

exports.ConfigSelect = ConfigSelect;
exports.ConnectionConfig = ConnectionConfig;
exports.FillValueSelect = FillValueSelect;
exports.FormatSelect = FormatSelect;
exports.InlineInput = InlineInput;
exports.QueryCodeEditor = QueryCodeEditor;
exports.ResourceSelector = ResourceSelector;
exports.SIGV4ConnectionConfig = SIGV4ConnectionConfig;
exports.appendTemplateVariablesAsSuggestions = appendTemplateVariablesAsSuggestions;
exports.applySQLTemplateVariables = applySQLTemplateVariables;
exports.awsAuthProviderOptions = awsAuthProviderOptions;
exports.filterSQLQuery = filterSQLQuery;
exports.standardRegions = standardRegions;
//# sourceMappingURL=index.development.js.map


/***/ }),

/***/ "./.yarn/cache/@grafana-aws-sdk-npm-0.0.36-8ab4b07904-c243f7c900.zip/node_modules/@grafana/aws-sdk/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__("./.yarn/cache/@grafana-aws-sdk-npm-0.0.36-8ab4b07904-c243f7c900.zip/node_modules/@grafana/aws-sdk/dist/index.development.js");
}


/***/ }),

/***/ "./.yarn/cache/lru-cache-npm-7.10.1-5af910d0ed-e8b190d71e.zip/node_modules/lru-cache/index.js":
/***/ ((module) => {

const perf =
  typeof performance === 'object' &&
  performance &&
  typeof performance.now === 'function'
    ? performance
    : Date

const hasAbortController = typeof AbortController === 'function'

// minimal backwards-compatibility polyfill
// this doesn't have nearly all the checks and whatnot that
// actual AbortController/Signal has, but it's enough for
// our purposes, and if used properly, behaves the same.
const AC = hasAbortController
  ? AbortController
  : class AbortController {
      constructor() {
        this.signal = new AS()
      }
      abort() {
        this.signal.dispatchEvent('abort')
      }
    }

const AS = hasAbortController
  ? AbortSignal
  : class AbortSignal {
      constructor() {
        this.aborted = false
        this._listeners = []
      }
      dispatchEvent(type) {
        if (type === 'abort') {
          this.aborted = true
          const e = { type, target: this }
          this.onabort(e)
          this._listeners.forEach(f => f(e), this)
        }
      }
      onabort() {}
      addEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners.push(fn)
        }
      }
      removeEventListener(ev, fn) {
        if (ev === 'abort') {
          this._listeners = this._listeners.filter(f => f !== fn)
        }
      }
    }

const warned = new Set()
const deprecatedOption = (opt, instead) => {
  const code = `LRU_CACHE_OPTION_${opt}`
  if (shouldWarn(code)) {
    warn(code, `${opt} option`, `options.${instead}`, LRUCache)
  }
}
const deprecatedMethod = (method, instead) => {
  const code = `LRU_CACHE_METHOD_${method}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, method)
    warn(code, `${method} method`, `cache.${instead}()`, get)
  }
}
const deprecatedProperty = (field, instead) => {
  const code = `LRU_CACHE_PROPERTY_${field}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, field)
    warn(code, `${field} property`, `cache.${instead}`, get)
  }
}

const emitWarning = (...a) => {
  typeof process === 'object' &&
  process &&
  typeof process.emitWarning === 'function'
    ? process.emitWarning(...a)
    : console.error(...a)
}

const shouldWarn = code => !warned.has(code)

const warn = (code, what, instead, fn) => {
  warned.add(code)
  const msg = `The ${what} is deprecated. Please use ${instead} instead.`
  emitWarning(msg, 'DeprecationWarning', code, fn)
}

const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)

/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */
const getUintArray = max =>
  !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
    ? Uint8Array
    : max <= Math.pow(2, 16)
    ? Uint16Array
    : max <= Math.pow(2, 32)
    ? Uint32Array
    : max <= Number.MAX_SAFE_INTEGER
    ? ZeroArray
    : null

class ZeroArray extends Array {
  constructor(size) {
    super(size)
    this.fill(0)
  }
}

class Stack {
  constructor(max) {
    if (max === 0) {
      return []
    }
    const UintArray = getUintArray(max)
    this.heap = new UintArray(max)
    this.length = 0
  }
  push(n) {
    this.heap[this.length++] = n
  }
  pop() {
    return this.heap[--this.length]
  }
}

class LRUCache {
  constructor(options = {}) {
    const {
      max = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      updateAgeOnHas,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      sizeCalculation,
      fetchMethod,
      noDeleteOnFetchRejection,
    } = options

    // deprecated options, don't trigger a warning for getting them if
    // the thing being passed in is another LRUCache we're copying.
    const { length, maxAge, stale } =
      options instanceof LRUCache ? {} : options

    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError('max option must be a nonnegative integer')
    }

    const UintArray = max ? getUintArray(max) : Array
    if (!UintArray) {
      throw new Error('invalid max value: ' + max)
    }

    this.max = max
    this.maxSize = maxSize
    this.sizeCalculation = sizeCalculation || length
    if (this.sizeCalculation) {
      if (!this.maxSize) {
        throw new TypeError(
          'cannot set sizeCalculation without setting maxSize'
        )
      }
      if (typeof this.sizeCalculation !== 'function') {
        throw new TypeError('sizeCalculation set to non-function')
      }
    }

    this.fetchMethod = fetchMethod || null
    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
      throw new TypeError(
        'fetchMethod must be a function if specified'
      )
    }

    this.keyMap = new Map()
    this.keyList = new Array(max).fill(null)
    this.valList = new Array(max).fill(null)
    this.next = new UintArray(max)
    this.prev = new UintArray(max)
    this.head = 0
    this.tail = 0
    this.free = new Stack(max)
    this.initialFill = 1
    this.size = 0

    if (typeof dispose === 'function') {
      this.dispose = dispose
    }
    if (typeof disposeAfter === 'function') {
      this.disposeAfter = disposeAfter
      this.disposed = []
    } else {
      this.disposeAfter = null
      this.disposed = null
    }
    this.noDisposeOnSet = !!noDisposeOnSet
    this.noUpdateTTL = !!noUpdateTTL
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection

    if (this.maxSize !== 0) {
      if (!isPosInt(this.maxSize)) {
        throw new TypeError(
          'maxSize must be a positive integer if specified'
        )
      }
      this.initializeSizeTracking()
    }

    this.allowStale = !!allowStale || !!stale
    this.updateAgeOnGet = !!updateAgeOnGet
    this.updateAgeOnHas = !!updateAgeOnHas
    this.ttlResolution =
      isPosInt(ttlResolution) || ttlResolution === 0
        ? ttlResolution
        : 1
    this.ttlAutopurge = !!ttlAutopurge
    this.ttl = ttl || maxAge || 0
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError(
          'ttl must be a positive integer if specified'
        )
      }
      this.initializeTTLTracking()
    }

    // do not allow completely unbounded caches
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError(
        'At least one of max, maxSize, or ttl is required'
      )
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code = 'LRU_CACHE_UNBOUNDED'
      if (shouldWarn(code)) {
        warned.add(code)
        const msg =
          'TTL caching without ttlAutopurge, max, or maxSize can ' +
          'result in unbounded memory consumption.'
        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
      }
    }

    if (stale) {
      deprecatedOption('stale', 'allowStale')
    }
    if (maxAge) {
      deprecatedOption('maxAge', 'ttl')
    }
    if (length) {
      deprecatedOption('length', 'sizeCalculation')
    }
  }

  getRemainingTTL(key) {
    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0
  }

  initializeTTLTracking() {
    this.ttls = new ZeroArray(this.max)
    this.starts = new ZeroArray(this.max)

    this.setItemTTL = (index, ttl) => {
      this.starts[index] = ttl !== 0 ? perf.now() : 0
      this.ttls[index] = ttl
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.isStale(index)) {
            this.delete(this.keyList[index])
          }
        }, ttl + 1)
        /* istanbul ignore else - unref() not supported on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
    }

    this.updateItemAge = index => {
      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0
    }

    // debounce calls to perf.now() to 1s so we're not hitting
    // that costly call repeatedly.
    let cachedNow = 0
    const getNow = () => {
      const n = perf.now()
      if (this.ttlResolution > 0) {
        cachedNow = n
        const t = setTimeout(
          () => (cachedNow = 0),
          this.ttlResolution
        )
        /* istanbul ignore else - not available on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
      return n
    }

    this.getRemainingTTL = key => {
      const index = this.keyMap.get(key)
      if (index === undefined) {
        return 0
      }
      return this.ttls[index] === 0 || this.starts[index] === 0
        ? Infinity
        : this.starts[index] +
            this.ttls[index] -
            (cachedNow || getNow())
    }

    this.isStale = index => {
      return (
        this.ttls[index] !== 0 &&
        this.starts[index] !== 0 &&
        (cachedNow || getNow()) - this.starts[index] >
          this.ttls[index]
      )
    }
  }
  updateItemAge(index) {}
  setItemTTL(index, ttl) {}
  isStale(index) {
    return false
  }

  initializeSizeTracking() {
    this.calculatedSize = 0
    this.sizes = new ZeroArray(this.max)
    this.removeItemSize = index =>
      (this.calculatedSize -= this.sizes[index])
    this.requireSize = (k, v, size, sizeCalculation) => {
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== 'function') {
            throw new TypeError('sizeCalculation must be a function')
          }
          size = sizeCalculation(v, k)
          if (!isPosInt(size)) {
            throw new TypeError(
              'sizeCalculation return invalid (expect positive integer)'
            )
          }
        } else {
          throw new TypeError(
            'invalid size value (must be positive integer)'
          )
        }
      }
      return size
    }
    this.addItemSize = (index, v, k, size) => {
      this.sizes[index] = size
      const maxSize = this.maxSize - this.sizes[index]
      while (this.calculatedSize > maxSize) {
        this.evict(true)
      }
      this.calculatedSize += this.sizes[index]
    }
  }
  removeItemSize(index) {}
  addItemSize(index, v, k, size) {}
  requireSize(k, v, size, sizeCalculation) {
    if (size || sizeCalculation) {
      throw new TypeError(
        'cannot set size without setting maxSize on cache'
      )
    }
  }

  *indexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.tail; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.head) {
          break
        } else {
          i = this.prev[i]
        }
      }
    }
  }

  *rindexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.head; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.tail) {
          break
        } else {
          i = this.next[i]
        }
      }
    }
  }

  isValidIndex(index) {
    return this.keyMap.get(this.keyList[index]) === index
  }

  *entries() {
    for (const i of this.indexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }
  *rentries() {
    for (const i of this.rindexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }

  *keys() {
    for (const i of this.indexes()) {
      yield this.keyList[i]
    }
  }
  *rkeys() {
    for (const i of this.rindexes()) {
      yield this.keyList[i]
    }
  }

  *values() {
    for (const i of this.indexes()) {
      yield this.valList[i]
    }
  }
  *rvalues() {
    for (const i of this.rindexes()) {
      yield this.valList[i]
    }
  }

  [Symbol.iterator]() {
    return this.entries()
  }

  find(fn, getOptions = {}) {
    for (const i of this.indexes()) {
      if (fn(this.valList[i], this.keyList[i], this)) {
        return this.get(this.keyList[i], getOptions)
      }
    }
  }

  forEach(fn, thisp = this) {
    for (const i of this.indexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  rforEach(fn, thisp = this) {
    for (const i of this.rindexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  get prune() {
    deprecatedMethod('prune', 'purgeStale')
    return this.purgeStale
  }

  purgeStale() {
    let deleted = false
    for (const i of this.rindexes({ allowStale: true })) {
      if (this.isStale(i)) {
        this.delete(this.keyList[i])
        deleted = true
      }
    }
    return deleted
  }

  dump() {
    const arr = []
    for (const i of this.indexes()) {
      const key = this.keyList[i]
      const value = this.valList[i]
      const entry = { value }
      if (this.ttls) {
        entry.ttl = this.ttls[i]
      }
      if (this.sizes) {
        entry.size = this.sizes[i]
      }
      arr.unshift([key, entry])
    }
    return arr
  }

  load(arr) {
    this.clear()
    for (const [key, entry] of arr) {
      this.set(key, entry.value, entry)
    }
  }

  dispose(v, k, reason) {}

  set(
    k,
    v,
    {
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
    } = {}
  ) {
    size = this.requireSize(k, v, size, sizeCalculation)
    let index = this.size === 0 ? undefined : this.keyMap.get(k)
    if (index === undefined) {
      // addition
      index = this.newIndex()
      this.keyList[index] = k
      this.valList[index] = v
      this.keyMap.set(k, index)
      this.next[this.tail] = index
      this.prev[index] = this.tail
      this.tail = index
      this.size++
      this.addItemSize(index, v, k, size)
      noUpdateTTL = false
    } else {
      // update
      const oldVal = this.valList[index]
      if (v !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort()
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k, 'set')
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k, 'set'])
            }
          }
        }
        this.removeItemSize(index)
        this.valList[index] = v
        this.addItemSize(index, v, k, size)
      }
      this.moveToTail(index)
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking()
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index, ttl)
    }
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return this
  }

  newIndex() {
    if (this.size === 0) {
      return this.tail
    }
    if (this.size === this.max && this.max !== 0) {
      return this.evict(false)
    }
    if (this.free.length !== 0) {
      return this.free.pop()
    }
    // initial fill, just keep writing down the list
    return this.initialFill++
  }

  pop() {
    if (this.size) {
      const val = this.valList[this.head]
      this.evict(true)
      return val
    }
  }

  evict(free) {
    const head = this.head
    const k = this.keyList[head]
    const v = this.valList[head]
    if (this.isBackgroundFetch(v)) {
      v.__abortController.abort()
    } else {
      this.dispose(v, k, 'evict')
      if (this.disposeAfter) {
        this.disposed.push([v, k, 'evict'])
      }
    }
    this.removeItemSize(head)
    // if we aren't about to use the index, then null these out
    if (free) {
      this.keyList[head] = null
      this.valList[head] = null
      this.free.push(head)
    }
    this.head = this.next[head]
    this.keyMap.delete(k)
    this.size--
    return head
  }

  has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      if (!this.isStale(index)) {
        if (updateAgeOnHas) {
          this.updateItemAge(index)
        }
        return true
      }
    }
    return false
  }

  // like get(), but without any LRU updating or TTL expiration
  peek(k, { allowStale = this.allowStale } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined && (allowStale || !this.isStale(index))) {
      return this.valList[index]
    }
  }

  backgroundFetch(k, index, options) {
    const v = index === undefined ? undefined : this.valList[index]
    if (this.isBackgroundFetch(v)) {
      return v
    }
    const ac = new AC()
    const fetchOpts = {
      signal: ac.signal,
      options,
    }
    const cb = v => {
      if (!ac.signal.aborted) {
        this.set(k, v, fetchOpts.options)
      }
      return v
    }
    const eb = er => {
      if (this.valList[index] === p) {
        const del =
          !options.noDeleteOnFetchRejection ||
          p.__staleWhileFetching === undefined
        if (del) {
          this.delete(k)
        } else {
          // still replace the *promise* with the stale value,
          // since we are done with the promise at this point.
          this.valList[index] = p.__staleWhileFetching
        }
      }
      if (p.__returned === p) {
        throw er
      }
    }
    const pcall = res => res(this.fetchMethod(k, v, fetchOpts))
    const p = new Promise(pcall).then(cb, eb)
    p.__abortController = ac
    p.__staleWhileFetching = v
    p.__returned = null
    if (index === undefined) {
      this.set(k, p, fetchOpts.options)
      index = this.keyMap.get(k)
    } else {
      this.valList[index] = p
    }
    return p
  }

  isBackgroundFetch(p) {
    return (
      p &&
      typeof p === 'object' &&
      typeof p.then === 'function' &&
      Object.prototype.hasOwnProperty.call(
        p,
        '__staleWhileFetching'
      ) &&
      Object.prototype.hasOwnProperty.call(p, '__returned') &&
      (p.__returned === p || p.__returned === null)
    )
  }

  // this takes the union of get() and set() opts, because it does both
  async fetch(
    k,
    {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
    } = {}
  ) {
    if (!this.fetchMethod) {
      return this.get(k, { allowStale, updateAgeOnGet })
    }

    const options = {
      allowStale,
      updateAgeOnGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
    }

    let index = this.keyMap.get(k)
    if (index === undefined) {
      const p = this.backgroundFetch(k, index, options)
      return (p.__returned = p)
    } else {
      // in cache, maybe already fetching
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        return allowStale && v.__staleWhileFetching !== undefined
          ? v.__staleWhileFetching
          : (v.__returned = v)
      }

      if (!this.isStale(index)) {
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return v
      }

      // ok, it is stale, and not already fetching
      // refresh the cache.
      const p = this.backgroundFetch(k, index, options)
      return allowStale && p.__staleWhileFetching !== undefined
        ? p.__staleWhileFetching
        : (p.__returned = p)
    }
  }

  get(
    k,
    {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
    } = {}
  ) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      const value = this.valList[index]
      const fetching = this.isBackgroundFetch(value)
      if (this.isStale(index)) {
        // delete only if not an in-flight background fetch
        if (!fetching) {
          this.delete(k)
          return allowStale ? value : undefined
        } else {
          return allowStale ? value.__staleWhileFetching : undefined
        }
      } else {
        // if we're currently fetching it, we don't actually have it yet
        // it's not stale, which means this isn't a staleWhileRefetching,
        // so we just return undefined
        if (fetching) {
          return undefined
        }
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return value
      }
    }
  }

  connect(p, n) {
    this.prev[n] = p
    this.next[p] = n
  }

  moveToTail(index) {
    // if tail already, nothing to do
    // if head, move head to next[index]
    // else
    //   move next[prev[index]] to next[index] (head has no prev)
    //   move prev[next[index]] to prev[index]
    // prev[index] = tail
    // next[tail] = index
    // tail = index
    if (index !== this.tail) {
      if (index === this.head) {
        this.head = this.next[index]
      } else {
        this.connect(this.prev[index], this.next[index])
      }
      this.connect(this.tail, index)
      this.tail = index
    }
  }

  get del() {
    deprecatedMethod('del', 'delete')
    return this.delete
  }

  delete(k) {
    let deleted = false
    if (this.size !== 0) {
      const index = this.keyMap.get(k)
      if (index !== undefined) {
        deleted = true
        if (this.size === 1) {
          this.clear()
        } else {
          this.removeItemSize(index)
          const v = this.valList[index]
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort()
          } else {
            this.dispose(v, k, 'delete')
            if (this.disposeAfter) {
              this.disposed.push([v, k, 'delete'])
            }
          }
          this.keyMap.delete(k)
          this.keyList[index] = null
          this.valList[index] = null
          if (index === this.tail) {
            this.tail = this.prev[index]
          } else if (index === this.head) {
            this.head = this.next[index]
          } else {
            this.next[this.prev[index]] = this.next[index]
            this.prev[this.next[index]] = this.prev[index]
          }
          this.size--
          this.free.push(index)
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return deleted
  }

  clear() {
    for (const index of this.rindexes({ allowStale: true })) {
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort()
      } else {
        const k = this.keyList[index]
        this.dispose(v, k, 'delete')
        if (this.disposeAfter) {
          this.disposed.push([v, k, 'delete'])
        }
      }
    }

    this.keyMap.clear()
    this.valList.fill(null)
    this.keyList.fill(null)
    if (this.ttls) {
      this.ttls.fill(0)
      this.starts.fill(0)
    }
    if (this.sizes) {
      this.sizes.fill(0)
    }
    this.head = 0
    this.tail = 0
    this.initialFill = 1
    this.free.length = 0
    this.calculatedSize = 0
    this.size = 0
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
  }

  get reset() {
    deprecatedMethod('reset', 'clear')
    return this.clear
  }

  get length() {
    deprecatedProperty('length', 'size')
    return this.size
  }

  static get AbortController() {
    return AC
  }
  static get AbortSignal() {
    return AS
  }
}

module.exports = LRUCache


/***/ }),

/***/ "./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Abs": () => (/* binding */ Abs),
/* harmony export */   "Absent": () => (/* binding */ Absent),
/* harmony export */   "AbsentOverTime": () => (/* binding */ AbsentOverTime),
/* harmony export */   "Acos": () => (/* binding */ Acos),
/* harmony export */   "Acosh": () => (/* binding */ Acosh),
/* harmony export */   "Add": () => (/* binding */ Add),
/* harmony export */   "AggregateExpr": () => (/* binding */ AggregateExpr),
/* harmony export */   "AggregateModifier": () => (/* binding */ AggregateModifier),
/* harmony export */   "AggregateOp": () => (/* binding */ AggregateOp),
/* harmony export */   "And": () => (/* binding */ And$1),
/* harmony export */   "Asin": () => (/* binding */ Asin),
/* harmony export */   "Asinh": () => (/* binding */ Asinh),
/* harmony export */   "At": () => (/* binding */ At),
/* harmony export */   "AtModifierPreprocessors": () => (/* binding */ AtModifierPreprocessors),
/* harmony export */   "Atan": () => (/* binding */ Atan),
/* harmony export */   "Atan2": () => (/* binding */ Atan2$1),
/* harmony export */   "Atanh": () => (/* binding */ Atanh),
/* harmony export */   "Avg": () => (/* binding */ Avg$1),
/* harmony export */   "AvgOverTime": () => (/* binding */ AvgOverTime),
/* harmony export */   "BinModifiers": () => (/* binding */ BinModifiers),
/* harmony export */   "BinaryExpr": () => (/* binding */ BinaryExpr),
/* harmony export */   "Bool": () => (/* binding */ Bool$1),
/* harmony export */   "Bottomk": () => (/* binding */ Bottomk$1),
/* harmony export */   "By": () => (/* binding */ By$1),
/* harmony export */   "Ceil": () => (/* binding */ Ceil),
/* harmony export */   "Changes": () => (/* binding */ Changes),
/* harmony export */   "Clamp": () => (/* binding */ Clamp),
/* harmony export */   "ClampMax": () => (/* binding */ ClampMax),
/* harmony export */   "ClampMin": () => (/* binding */ ClampMin),
/* harmony export */   "Cos": () => (/* binding */ Cos),
/* harmony export */   "Cosh": () => (/* binding */ Cosh),
/* harmony export */   "Count": () => (/* binding */ Count$1),
/* harmony export */   "CountOverTime": () => (/* binding */ CountOverTime),
/* harmony export */   "CountValues": () => (/* binding */ CountValues$1),
/* harmony export */   "DayOfMonth": () => (/* binding */ DayOfMonth),
/* harmony export */   "DayOfWeek": () => (/* binding */ DayOfWeek),
/* harmony export */   "DaysInMonth": () => (/* binding */ DaysInMonth),
/* harmony export */   "Deg": () => (/* binding */ Deg),
/* harmony export */   "Delta": () => (/* binding */ Delta),
/* harmony export */   "Deriv": () => (/* binding */ Deriv),
/* harmony export */   "Div": () => (/* binding */ Div),
/* harmony export */   "Duration": () => (/* binding */ Duration),
/* harmony export */   "End": () => (/* binding */ End$1),
/* harmony export */   "Eql": () => (/* binding */ Eql),
/* harmony export */   "EqlRegex": () => (/* binding */ EqlRegex),
/* harmony export */   "EqlSingle": () => (/* binding */ EqlSingle),
/* harmony export */   "Exp": () => (/* binding */ Exp),
/* harmony export */   "Expr": () => (/* binding */ Expr),
/* harmony export */   "Floor": () => (/* binding */ Floor),
/* harmony export */   "FunctionCall": () => (/* binding */ FunctionCall),
/* harmony export */   "FunctionCallArgs": () => (/* binding */ FunctionCallArgs),
/* harmony export */   "FunctionCallBody": () => (/* binding */ FunctionCallBody),
/* harmony export */   "FunctionIdentifier": () => (/* binding */ FunctionIdentifier),
/* harmony export */   "Group": () => (/* binding */ Group$1),
/* harmony export */   "GroupLeft": () => (/* binding */ GroupLeft$1),
/* harmony export */   "GroupRight": () => (/* binding */ GroupRight$1),
/* harmony export */   "GroupingLabel": () => (/* binding */ GroupingLabel),
/* harmony export */   "GroupingLabelList": () => (/* binding */ GroupingLabelList),
/* harmony export */   "GroupingLabels": () => (/* binding */ GroupingLabels),
/* harmony export */   "Gte": () => (/* binding */ Gte),
/* harmony export */   "Gtr": () => (/* binding */ Gtr),
/* harmony export */   "HistogramQuantile": () => (/* binding */ HistogramQuantile),
/* harmony export */   "HoltWinters": () => (/* binding */ HoltWinters),
/* harmony export */   "Hour": () => (/* binding */ Hour),
/* harmony export */   "Idelta": () => (/* binding */ Idelta),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Ignoring": () => (/* binding */ Ignoring$1),
/* harmony export */   "Increase": () => (/* binding */ Increase),
/* harmony export */   "Irate": () => (/* binding */ Irate),
/* harmony export */   "LabelJoin": () => (/* binding */ LabelJoin),
/* harmony export */   "LabelMatchList": () => (/* binding */ LabelMatchList),
/* harmony export */   "LabelMatcher": () => (/* binding */ LabelMatcher),
/* harmony export */   "LabelMatchers": () => (/* binding */ LabelMatchers),
/* harmony export */   "LabelName": () => (/* binding */ LabelName),
/* harmony export */   "LabelReplace": () => (/* binding */ LabelReplace),
/* harmony export */   "LastOverTime": () => (/* binding */ LastOverTime),
/* harmony export */   "LineComment": () => (/* binding */ LineComment),
/* harmony export */   "Ln": () => (/* binding */ Ln),
/* harmony export */   "Log10": () => (/* binding */ Log10),
/* harmony export */   "Log2": () => (/* binding */ Log2),
/* harmony export */   "Lss": () => (/* binding */ Lss),
/* harmony export */   "Lte": () => (/* binding */ Lte),
/* harmony export */   "MatchOp": () => (/* binding */ MatchOp),
/* harmony export */   "MatrixSelector": () => (/* binding */ MatrixSelector),
/* harmony export */   "Max": () => (/* binding */ Max$1),
/* harmony export */   "MaxOverTime": () => (/* binding */ MaxOverTime),
/* harmony export */   "MetricIdentifier": () => (/* binding */ MetricIdentifier),
/* harmony export */   "MetricName": () => (/* binding */ MetricName),
/* harmony export */   "Min": () => (/* binding */ Min$1),
/* harmony export */   "MinOverTime": () => (/* binding */ MinOverTime),
/* harmony export */   "Minute": () => (/* binding */ Minute),
/* harmony export */   "Mod": () => (/* binding */ Mod),
/* harmony export */   "Month": () => (/* binding */ Month),
/* harmony export */   "Mul": () => (/* binding */ Mul),
/* harmony export */   "Neq": () => (/* binding */ Neq),
/* harmony export */   "NeqRegex": () => (/* binding */ NeqRegex),
/* harmony export */   "NumberLiteral": () => (/* binding */ NumberLiteral),
/* harmony export */   "Offset": () => (/* binding */ Offset$1),
/* harmony export */   "OffsetExpr": () => (/* binding */ OffsetExpr),
/* harmony export */   "On": () => (/* binding */ On$1),
/* harmony export */   "OnOrIgnoring": () => (/* binding */ OnOrIgnoring),
/* harmony export */   "Or": () => (/* binding */ Or$1),
/* harmony export */   "ParenExpr": () => (/* binding */ ParenExpr),
/* harmony export */   "Pi": () => (/* binding */ Pi),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "PredictLinear": () => (/* binding */ PredictLinear),
/* harmony export */   "PresentOverTime": () => (/* binding */ PresentOverTime),
/* harmony export */   "PromQL": () => (/* binding */ PromQL),
/* harmony export */   "Quantile": () => (/* binding */ Quantile$1),
/* harmony export */   "QuantileOverTime": () => (/* binding */ QuantileOverTime),
/* harmony export */   "Rad": () => (/* binding */ Rad),
/* harmony export */   "Rate": () => (/* binding */ Rate),
/* harmony export */   "Resets": () => (/* binding */ Resets),
/* harmony export */   "Round": () => (/* binding */ Round),
/* harmony export */   "Scalar": () => (/* binding */ Scalar),
/* harmony export */   "Sgn": () => (/* binding */ Sgn),
/* harmony export */   "Sin": () => (/* binding */ Sin),
/* harmony export */   "Sinh": () => (/* binding */ Sinh),
/* harmony export */   "Sort": () => (/* binding */ Sort),
/* harmony export */   "SortDesc": () => (/* binding */ SortDesc),
/* harmony export */   "Sqrt": () => (/* binding */ Sqrt),
/* harmony export */   "Start": () => (/* binding */ Start$1),
/* harmony export */   "Stddev": () => (/* binding */ Stddev$1),
/* harmony export */   "StddevOverTime": () => (/* binding */ StddevOverTime),
/* harmony export */   "Stdvar": () => (/* binding */ Stdvar$1),
/* harmony export */   "StdvarOverTime": () => (/* binding */ StdvarOverTime),
/* harmony export */   "StepInvariantExpr": () => (/* binding */ StepInvariantExpr),
/* harmony export */   "StringLiteral": () => (/* binding */ StringLiteral),
/* harmony export */   "Sub": () => (/* binding */ Sub),
/* harmony export */   "SubqueryExpr": () => (/* binding */ SubqueryExpr),
/* harmony export */   "Sum": () => (/* binding */ Sum$1),
/* harmony export */   "SumOverTime": () => (/* binding */ SumOverTime),
/* harmony export */   "Tan": () => (/* binding */ Tan),
/* harmony export */   "Tanh": () => (/* binding */ Tanh),
/* harmony export */   "Time": () => (/* binding */ Time),
/* harmony export */   "Timestamp": () => (/* binding */ Timestamp),
/* harmony export */   "Topk": () => (/* binding */ Topk$1),
/* harmony export */   "UnaryExpr": () => (/* binding */ UnaryExpr),
/* harmony export */   "UnaryOp": () => (/* binding */ UnaryOp),
/* harmony export */   "Unless": () => (/* binding */ Unless$1),
/* harmony export */   "Vector": () => (/* binding */ Vector),
/* harmony export */   "VectorSelector": () => (/* binding */ VectorSelector),
/* harmony export */   "Without": () => (/* binding */ Without$1),
/* harmony export */   "Year": () => (/* binding */ Year),
/* harmony export */   "inf": () => (/* binding */ inf$1),
/* harmony export */   "nan": () => (/* binding */ nan$1),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js");


// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf = 146,
  nan = 147,
  Bool = 1,
  Ignoring = 2,
  On = 3,
  GroupLeft = 4,
  GroupRight = 5,
  Offset = 6,
  Atan2 = 7,
  Avg = 8,
  Bottomk = 9,
  Count = 10,
  CountValues = 11,
  Group = 12,
  Max = 13,
  Min = 14,
  Quantile = 15,
  Stddev = 16,
  Stdvar = 17,
  Sum = 18,
  Topk = 19,
  By = 20,
  Without = 21,
  And = 22,
  Or = 23,
  Unless = 24,
  Start = 25,
  End = 26;

// Copyright 2021 The Prometheus Authors

const keywordTokens = {
    inf: inf,
    nan: nan,
    bool: Bool,
    ignoring: Ignoring,
    on: On,
    group_left: GroupLeft,
    group_right: GroupRight,
    offset: Offset,
};

const specializeIdentifier = (value, stack) => {
    return keywordTokens[value.toLowerCase()] || -1;
};

const contextualKeywordTokens = {
    avg: Avg,
    atan2: Atan2,
    bottomk: Bottomk,
    count: Count,
    count_values: CountValues,
    group: Group,
    max: Max,
    min: Min,
    quantile: Quantile,
    stddev: Stddev,
    stdvar: Stdvar,
    sum: Sum,
    topk: Topk,
    by: By,
    without: Without,
    and: And,
    or: Or,
    unless: Unless,
    start: Start,
    end: End,
};

const extendIdentifier = (value, stack) => {
    return contextualKeywordTokens[value.toLowerCase()] || -1;
};

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,absent_over_time:307, absent:309, abs:311, acos:313, acosh:315, asin:317, asinh:319, atan:321, atanh:323, avg_over_time:325, ceil:327, changes:329, clamp:331, clamp_max:333, clamp_min:335, cos:337, cosh:339, count_over_time:341, days_in_month:343, day_of_month:345, day_of_week:347, deg:349, delta:351, deriv:353, exp:355, floor:357, histogram_quantile:359, holt_winters:361, hour:363, idelta:365, increase:367, irate:369, label_replace:371, label_join:373, last_over_time:375, ln:377, log10:379, log2:381, max_over_time:383, min_over_time:385, minute:387, month:389, pi:391, predict_linear:393, present_over_time:395, quantile_over_time:397, rad:399, rate:401, resets:403, round:405, scalar:407, sgn:409, sin:411, sinh:413, sort:415, sort_desc:417, sqrt:419, stddev_over_time:421, stdvar_over_time:423, sum_over_time:425, tan:427, tanh:429, timestamp:431, time:433, vector:435, year:437};
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 13,
  states: "6[OYQPOOO&{QPOOOOQO'#C{'#C{O'QQPO'#CzQ']QQOOOOQO'#De'#DeO'WQPO'#DdOOQO'#E}'#E}O(jQPO'#FTOYQPO'#FPOYQPO'#FSOOQO'#FV'#FVO.fQSO'#FWO.nQQO'#FUOOQO'#FU'#FUOOQO'#Cy'#CyOOQO'#Df'#DfOOQO'#Dh'#DhOOQO'#Di'#DiOOQO'#Dj'#DjOOQO'#Dk'#DkOOQO'#Dl'#DlOOQO'#Dm'#DmOOQO'#Dn'#DnOOQO'#Do'#DoOOQO'#Dp'#DpOOQO'#Dq'#DqOOQO'#Dr'#DrOOQO'#Ds'#DsOOQO'#Dt'#DtOOQO'#Du'#DuOOQO'#Dv'#DvOOQO'#Dw'#DwOOQO'#Dx'#DxOOQO'#Dy'#DyOOQO'#Dz'#DzOOQO'#D{'#D{OOQO'#D|'#D|OOQO'#D}'#D}OOQO'#EO'#EOOOQO'#EP'#EPOOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETOOQO'#EU'#EUOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EY'#EYOOQO'#EZ'#EZOOQO'#E['#E[OOQO'#E]'#E]OOQO'#E^'#E^OOQO'#E_'#E_OOQO'#E`'#E`OOQO'#Ea'#EaOOQO'#Eb'#EbOOQO'#Ec'#EcOOQO'#Ed'#EdOOQO'#Ee'#EeOOQO'#Ef'#EfOOQO'#Eg'#EgOOQO'#Eh'#EhOOQO'#Ei'#EiOOQO'#Ej'#EjOOQO'#Ek'#EkOOQO'#El'#ElOOQO'#Em'#EmOOQO'#En'#EnOOQO'#Eo'#EoOOQO'#Ep'#EpOOQO'#Eq'#EqOOQO'#Er'#ErOOQO'#Es'#EsOOQO'#Et'#EtOOQO'#Eu'#EuOOQO'#Ev'#EvOOQO'#Ew'#EwOOQO'#Ex'#ExOOQO'#Ey'#EyOOQO'#Ez'#EzQOQPOOO0XQPO'#C|O0^QPO'#DRO'WQPO,59fO0eQQO,59fO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO7}QQO,5;gO8SQQO,5;jO8[QPO,5;yOOQO,5:O,5:OOOQO,5;i,5;iO8sQQO,5;kO8zQQO,5;nO:bQPO'#FYO:pQPO,5;rOOQO'#FX'#FXOOQO,5;r,5;rOOQO,5;p,5;pO:xQSO'#C}OOQO,59h,59hO;QQPO,59mO;YQQO'#DSOOQO,59m,59mOOQO1G/Q1G/QO0XQPO'#DWOAVQPO'#DVOAaQPO'#DVOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOAkQSO1G1ROOQO1G1U1G1UOAsQQO1G1UOAxQPO'#E}OOQO'#Fa'#FaOOQO1G1e1G1eOBTQPO1G1eOOQO1G1V1G1VOOQO'#FZ'#FZOBYQPO,5;tOB_QSO1G1^OOQO1G1^1G1^OOQO'#DP'#DPOBgQPO,59iOOQO'#DO'#DOOOQO,59i,59iOYQPO,59nOOQO1G/X1G/XOOQO,59r,59rOH_QPO,59qOHfQPO,59qOI}QQO7+$uOJ_QQO7+$uOKsQQO7+$uOLZQQO7+$uOMrQQO7+$uOOQO7+&m7+&mON]QQO7+&sOOQO7+&p7+&pONeQPO7+'POOQO1G1`1G1`OOQO1G1_1G1_OOQO7+&x7+&xONjQSO1G/TOOQO1G/T1G/TONrQQO1G/YOOQO1G/]1G/]ON|QPO1G/]OOQO<<J_<<J_O!&oQPO<<J_OOQO<<Jk<<JkOOQO1G/U1G/UOOQO7+$o7+$oOOQO7+$w7+$wOOQOAN?yAN?y",
  stateData: "!&t~O$ZOSkOS~OWQOXQOYQOZQO[QO]QO^QO_QO`QOaQObQOcQO!ZZO#t_O$WVO$XVO$[XO$_`O$`aO$abO$bcO$cdO$deO$efO$fgO$ghO$hiO$ijO$jkO$klO$lmO$mnO$noO$opO$pqO$qrO$rsO$stO$tuO$uvO$vwO$wxO$xyO$yzO$z{O${|O$|}O$}!OO%O!PO%P!QO%Q!RO%R!SO%S!TO%T!UO%U!VO%V!WO%W!XO%X!YO%Y!ZO%Z![O%[!]O%]!^O%^!_O%_!`O%`!aO%a!bO%b!cO%c!dO%d!eO%e!fO%f!gO%g!hO%h!iO%i!jO%j!kO%k!lO%l!mO%m!nO%n!oO%o!pO%p!qO%q!rO%r!sO%uWO%vWO%wVO%y[O~O!ZZO~Od!uOe!uO$[!vO~OU#POV!yOf!|Og!}Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O$S#QO%s#OO~O$W#SO$X#SO%w#SOW#wXX#wXY#wXZ#wX[#wX]#wX^#wX_#wX`#wXa#wXb#wXc#wX!Z#wX#t#wX$W#wX$X#wX$[#wX$_#wX$`#wX$a#wX$b#wX$c#wX$d#wX$e#wX$f#wX$g#wX$h#wX$i#wX$j#wX$k#wX$l#wX$m#wX$n#wX$o#wX$p#wX$q#wX$r#wX$s#wX$t#wX$u#wX$v#wX$w#wX$x#wX$y#wX$z#wX${#wX$|#wX$}#wX%O#wX%P#wX%Q#wX%R#wX%S#wX%T#wX%U#wX%V#wX%W#wX%X#wX%Y#wX%Z#wX%[#wX%]#wX%^#wX%_#wX%`#wX%a#wX%b#wX%c#wX%d#wX%e#wX%f#wX%g#wX%h#wX%i#wX%j#wX%k#wX%l#wX%m#wX%n#wX%o#wX%p#wX%q#wX%r#wX%u#wX%v#wX%w#wX%y#wX~Ot#VO%z#YO~O%y[OU#xXV#xXf#xXg#xXh#xXx#xX{#xX|#xX}#xX!O#xX!P#xX!Q#xX!R#xX!S#xX!T#xX!U#xX!V#xX$S#xX$V#xX%s#xX$^#xX$]#xX~O$[#[O~O$^#`O~PYOd!uOe!uOUnaVnafnagnahnaxna{na|na}na!Ona!Pna!Qna!Rna!Sna!Tna!Una!Vna$Sna$Vna%sna$^na$]na~OP#dOQ#bOR#bOWyPXyPYyPZyP[yP]yP^yP_yP`yPayPbyPcyP!ZyP#tyP$WyP$XyP$[yP$_yP$`yP$ayP$byP$cyP$dyP$eyP$fyP$gyP$hyP$iyP$jyP$kyP$lyP$myP$nyP$oyP$pyP$qyP$ryP$syP$tyP$uyP$vyP$wyP$xyP$yyP$zyP${yP$|yP$}yP%OyP%PyP%QyP%RyP%SyP%TyP%UyP%VyP%WyP%XyP%YyP%ZyP%[yP%]yP%^yP%_yP%`yP%ayP%byP%cyP%dyP%eyP%fyP%gyP%hyP%iyP%jyP%kyP%lyP%myP%nyP%oyP%pyP%qyP%ryP%uyP%vyP%wyP%yyP~O#p#jO~O!P#lO#p#kO~Oi#nOj#nO$WVO$XVO%u#mO%v#mO%wVO~O$^#qO~P']Ox!yOU#vaV#vaf#vag#vah#va{#va|#va}#va!O#va!P#va!Q#va!R#va!S#va!T#va!U#va!V#va$S#va$V#va%s#va$^#va$]#va~O!V#rO$O#rO$P#rO$Q#rO~O$]#tO%z#uO~Ot#vO$^#yO~O$]#zO$^#{O~O$]vX$^vX~P']OWyXXyXYyXZyX[yX]yX^yX_yX`yXayXbyXcyX!ZyX#tyX$WyX$XyX$[yX$_yX$`yX$ayX$byX$cyX$dyX$eyX$fyX$gyX$hyX$iyX$jyX$kyX$lyX$myX$nyX$oyX$pyX$qyX$ryX$syX$tyX$uyX$vyX$wyX$xyX$yyX$zyX${yX$|yX$}yX%OyX%PyX%QyX%RyX%SyX%TyX%UyX%VyX%WyX%XyX%YyX%ZyX%[yX%]yX%^yX%_yX%`yX%ayX%byX%cyX%dyX%eyX%fyX%gyX%hyX%iyX%jyX%kyX%lyX%myX%nyX%oyX%pyX%qyX%ryX%uyX%vyX%wyX%yyX~OS#}OT#}O~P;dOQ#bOR#bO~P;dO%t$UO%x$VO~O#p$WO~O$W#SO$X#SO%w#SO~O$[$XO~O#t$YO~Ot#VO%z$[O~O$]$]O$^$^O~OWyaXyaYyaZya[ya]ya^ya_ya`yaayabyacya!Zya#tya$Wya$Xya$_ya$`ya$aya$bya$cya$dya$eya$fya$gya$hya$iya$jya$kya$lya$mya$nya$oya$pya$qya$rya$sya$tya$uya$vya$wya$xya$yya$zya${ya$|ya$}ya%Oya%Pya%Qya%Rya%Sya%Tya%Uya%Vya%Wya%Xya%Yya%Zya%[ya%]ya%^ya%_ya%`ya%aya%bya%cya%dya%eya%fya%gya%hya%iya%jya%kya%lya%mya%nya%oya%pya%qya%rya%uya%vya%wya%yya~O$[#[O~PBoOS$aOT$aO$[ya~PBoOx!yOUwqfwqgwqhwq!Owq!Pwq!Qwq!Rwq!Swq!Twq!Uwq!Vwq$Swq$Vwq%swq$^wq$]wq~OVwq{wq|wq}wq~PHsOV!yO{!yO|!yO}!yO~PHsOV!yOx!yO{!yO|!yO}!yO!O!zO!P!zOUwqfwqgwqhwq$Swq$Vwq%swq$^wq$]wq~O!Qwq!Rwq!Swq!Twq!Uwq!Vwq~PJoO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~PJoOV!yOf!|Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~OUwqgwq$Swq$Vwq%swq$^wq$]wq~PLqO#p$cO%t$bO~O$^$dO~Ot#vO$^$fO~O$]vi$^vi~P']O$[#[OWyiXyiYyiZyi[yi]yi^yi_yi`yiayibyicyi!Zyi#tyi$Wyi$Xyi$_yi$`yi$ayi$byi$cyi$dyi$eyi$fyi$gyi$hyi$iyi$jyi$kyi$lyi$myi$nyi$oyi$pyi$qyi$ryi$syi$tyi$uyi$vyi$wyi$xyi$yyi$zyi${yi$|yi$}yi%Oyi%Pyi%Qyi%Ryi%Syi%Tyi%Uyi%Vyi%Wyi%Xyi%Yyi%Zyi%[yi%]yi%^yi%_yi%`yi%ayi%byi%cyi%dyi%eyi%fyi%gyi%hyi%iyi%jyi%kyi%lyi%myi%nyi%oyi%pyi%qyi%ryi%uyi%vyi%wyi%yyi~O%t$hO~O",
  goto: "(u$UPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$V$u%R%_%e%q%tP%z&T$uP&W&gPPPPPPPPPPP$u&q&}P&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}$uP'Z$u$uP$u$u'j$u'v(V(f(i(oPPP$uP(rQSOQ#TXQ#UYQ#_!vQ$P#eQ$Q#fQ$R#gQ$S#hQ$T#iR$_#ze_OXY!v#e#f#g#h#i#zeROXY!v#e#f#g#h#i#zQ!wRR#a!xQ#]!uQ#|#bQ$`#}R$g$aR#w#[Q#x#[R$e$]Q!xRQ#RUR#a!wR#^!vQ#e!yQ#f!zQ#g!{Q#h!|R#i!}Y#c!y!z!{!|!}R$O#deUOXY!v#e#f#g#h#i#zeTOXY!v#e#f#g#h#i#zd_OXY!v#e#f#g#h#i#zR#o#QeYOXY!v#e#f#g#h#i#zd]OXY!v#e#f#g#h#i#zR!tPd^OXY!v#e#f#g#h#i#zR#Z]R#W[Q#X[R$Z#tR#s#VR#p#Q",
  nodeNames: "⚠ Bool Ignoring On GroupLeft GroupRight Offset Atan2 Avg Bottomk Count CountValues Group Max Min Quantile Stddev Stdvar Sum Topk By Without And Or Unless Start End LineComment PromQL Expr AggregateExpr AggregateOp AggregateModifier GroupingLabels GroupingLabelList GroupingLabel LabelName FunctionCallBody FunctionCallArgs BinaryExpr Pow BinModifiers OnOrIgnoring Mul Div Mod Add Sub Eql Gte Gtr Lte Lss Neq FunctionCall FunctionIdentifier AbsentOverTime Identifier Absent Abs Acos Acosh Asin Asinh Atan Atanh AvgOverTime Ceil Changes Clamp ClampMax ClampMin Cos Cosh CountOverTime DaysInMonth DayOfMonth DayOfWeek Deg Delta Deriv Exp Floor HistogramQuantile HoltWinters Hour Idelta Increase Irate LabelReplace LabelJoin LastOverTime Ln Log10 Log2 MaxOverTime MinOverTime Minute Month Pi PredictLinear PresentOverTime QuantileOverTime Rad Rate Resets Round Scalar Sgn Sin Sinh Sort SortDesc Sqrt StddevOverTime StdvarOverTime SumOverTime Tan Tanh Timestamp Time Vector Year MatrixSelector Duration NumberLiteral OffsetExpr ParenExpr StringLiteral SubqueryExpr UnaryExpr UnaryOp VectorSelector MetricIdentifier LabelMatchers LabelMatchList LabelMatcher MatchOp EqlSingle EqlRegex NeqRegex StepInvariantExpr At AtModifierPreprocessors MetricName",
  maxTerm: 226,
  skippedNodes: [0,27],
  repeatNodeCount: 0,
  tokenData: "1R~RwX^#lpq#lqr$ars$tst%huv%swx%xxy&gyz&lz{&q{|&v|}&}}!O'S!O!P'Z!P!Q(Z!Q!R(`!R![)W![!]-r!^!_.n!_!`.{!`!a/b!b!c/o!c!}/t!}#O0[#P#Q0a#Q#R0f#R#S/t#S#T0k#T#o/t#o#p0w#q#r0|#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~#qY$Z~X^#lpq#l#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~$dQ!_!`$j#r#s$o~$oO!V~~$tO$Q~~$yU#t~OY$tZr$trs%]s#O$t#O#P%b#P~$t~%bO#t~~%ePO~$t~%mQk~OY%hZ~%h~%xO}~~%}U#t~OY%xZw%xwx%]x#O%x#O#P&a#P~%x~&dPO~%x~&lO$[~~&qO$^~~&vO{~R&}O%vP!OQ~'SO$]~R'ZO%uP!PQP'^P!Q!['aP'fR%wP!Q!['a!g!h'o#X#Y'oP'rR{|'{}!O'{!Q![(RP(OP!Q![(RP(WP%wP!Q![(R~(`O|~R(eZ%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#l#m-W#m#n,iR)]Y%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#m#n,iQ*QP#pQ!Q![*TQ*WS!Q![*T#[#]*d#a#b*x#g#h+lQ*iP#pQ!Q![*lQ*oR!Q![*l#a#b*x#g#h+lQ*}Q#pQ!Q![+T#g#h+gQ+WR!Q![+T#a#b+a#g#h+lQ+dP#g#h+gQ+lO#pQQ+qP#pQ!Q![+tQ+wQ!Q![+t#a#b+aQ,SP#pQ!Q![,VQ,YT!Q![,V#W#X){#[#]*d#a#b*x#g#h+lQ,nP#pQ!Q![,qQ,tU!Q![,q#W#X){#[#]*d#a#b*x#g#h+l#k#l+}P-ZR!Q![-d!c!i-d#T#Z-dP-iR%wP!Q![-d!c!i-d#T#Z-dV-yT%xS!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.YR._T!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.Y~.sP!U~!_!`.v~.{O!T~~/QQ$OP!_!`/W#r#s/]Q/]O!QQ~/bO$P~~/gP!S~!_!`/j~/oO!R~~/tO$S~V/{T!ZRtS!Q![/t![!].Y!c!}/t#R#S/t#T#o/t~0aO%s~~0fO%t~~0kOx~~0nRO#S0k#S#T%]#T~0k~0|O%y~~1RO%z~",
  tokenizers: [0, 1, 2],
  topRules: {"PromQL":[0,28],"MetricName":[1,144]},
  specialized: [{term: 57, get: (value, stack) => (specializeIdentifier(value) << 1)},{term: 57, get: (value, stack) => (extendIdentifier(value) << 1) | 1},{term: 57, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 0
});
// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf$1 = 146,
  nan$1 = 147,
  Bool$1 = 1,
  Ignoring$1 = 2,
  On$1 = 3,
  GroupLeft$1 = 4,
  GroupRight$1 = 5,
  Offset$1 = 6,
  Atan2$1 = 7,
  Avg$1 = 8,
  Bottomk$1 = 9,
  Count$1 = 10,
  CountValues$1 = 11,
  Group$1 = 12,
  Max$1 = 13,
  Min$1 = 14,
  Quantile$1 = 15,
  Stddev$1 = 16,
  Stdvar$1 = 17,
  Sum$1 = 18,
  Topk$1 = 19,
  By$1 = 20,
  Without$1 = 21,
  And$1 = 22,
  Or$1 = 23,
  Unless$1 = 24,
  Start$1 = 25,
  End$1 = 26,
  LineComment = 27,
  PromQL = 28,
  Expr = 29,
  AggregateExpr = 30,
  AggregateOp = 31,
  AggregateModifier = 32,
  GroupingLabels = 33,
  GroupingLabelList = 34,
  GroupingLabel = 35,
  LabelName = 36,
  FunctionCallBody = 37,
  FunctionCallArgs = 38,
  BinaryExpr = 39,
  Pow = 40,
  BinModifiers = 41,
  OnOrIgnoring = 42,
  Mul = 43,
  Div = 44,
  Mod = 45,
  Add = 46,
  Sub = 47,
  Eql = 48,
  Gte = 49,
  Gtr = 50,
  Lte = 51,
  Lss = 52,
  Neq = 53,
  FunctionCall = 54,
  FunctionIdentifier = 55,
  AbsentOverTime = 56,
  Identifier = 57,
  Absent = 58,
  Abs = 59,
  Acos = 60,
  Acosh = 61,
  Asin = 62,
  Asinh = 63,
  Atan = 64,
  Atanh = 65,
  AvgOverTime = 66,
  Ceil = 67,
  Changes = 68,
  Clamp = 69,
  ClampMax = 70,
  ClampMin = 71,
  Cos = 72,
  Cosh = 73,
  CountOverTime = 74,
  DaysInMonth = 75,
  DayOfMonth = 76,
  DayOfWeek = 77,
  Deg = 78,
  Delta = 79,
  Deriv = 80,
  Exp = 81,
  Floor = 82,
  HistogramQuantile = 83,
  HoltWinters = 84,
  Hour = 85,
  Idelta = 86,
  Increase = 87,
  Irate = 88,
  LabelReplace = 89,
  LabelJoin = 90,
  LastOverTime = 91,
  Ln = 92,
  Log10 = 93,
  Log2 = 94,
  MaxOverTime = 95,
  MinOverTime = 96,
  Minute = 97,
  Month = 98,
  Pi = 99,
  PredictLinear = 100,
  PresentOverTime = 101,
  QuantileOverTime = 102,
  Rad = 103,
  Rate = 104,
  Resets = 105,
  Round = 106,
  Scalar = 107,
  Sgn = 108,
  Sin = 109,
  Sinh = 110,
  Sort = 111,
  SortDesc = 112,
  Sqrt = 113,
  StddevOverTime = 114,
  StdvarOverTime = 115,
  SumOverTime = 116,
  Tan = 117,
  Tanh = 118,
  Timestamp = 119,
  Time = 120,
  Vector = 121,
  Year = 122,
  MatrixSelector = 123,
  Duration = 124,
  NumberLiteral = 125,
  OffsetExpr = 126,
  ParenExpr = 127,
  StringLiteral = 128,
  SubqueryExpr = 129,
  UnaryExpr = 130,
  UnaryOp = 131,
  VectorSelector = 132,
  MetricIdentifier = 133,
  LabelMatchers = 134,
  LabelMatchList = 135,
  LabelMatcher = 136,
  MatchOp = 137,
  EqlSingle = 138,
  EqlRegex = 139,
  NeqRegex = 140,
  StepInvariantExpr = 141,
  At = 142,
  AtModifierPreprocessors = 143,
  MetricName = 144;




/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.18.3-1883c70fa6-db8526226a.zip/node_modules/@babel/runtime/helpers/esm/extends.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.18.3-1883c70fa6-db8526226a.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _objectWithoutPropertiesLoose)
/* harmony export */ });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultBufferLength": () => (/* binding */ DefaultBufferLength),
/* harmony export */   "MountedTree": () => (/* binding */ MountedTree),
/* harmony export */   "NodeProp": () => (/* binding */ NodeProp),
/* harmony export */   "NodeSet": () => (/* binding */ NodeSet),
/* harmony export */   "NodeType": () => (/* binding */ NodeType),
/* harmony export */   "Parser": () => (/* binding */ Parser),
/* harmony export */   "Tree": () => (/* binding */ Tree),
/* harmony export */   "TreeBuffer": () => (/* binding */ TreeBuffer),
/* harmony export */   "TreeCursor": () => (/* binding */ TreeCursor),
/* harmony export */   "TreeFragment": () => (/* binding */ TreeFragment),
/* harmony export */   "parseMixed": () => (/* binding */ parseMixed)
/* harmony export */ });
// FIXME profile adding a per-Tree TreeNode cache, validating it by
// parent pointer
/// The default maximum length of a `TreeBuffer` node (1024).
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)
/// can have metadata associated with it in props. Instances of this
/// class represent prop names.
class NodeProp {
    /// Create a new node prop type.
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#common.NodeSet.extend) or
    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
    /// prop values for each node type in the set. Takes a [match
    /// object](#common.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
/// The hash of the [context](#lr.ContextTracker.constructor)
/// that the node was parsed in, if any. Used to limit reuse of
/// contextual nodes.
NodeProp.contextHash = new NodeProp({ perNode: true });
/// The distance beyond the end of the node that the tokenizer
/// looked ahead for any of the tokens inside the node. (The LR
/// parser only stores this when it is larger than 25, for
/// efficiency reasons.)
NodeProp.lookAhead = new NodeProp({ perNode: true });
/// This per-node prop is used to replace a given node, or part of a
/// node, with another tree. This is useful to include trees from
/// different languages.
NodeProp.mounted = new NodeProp({ perNode: true });
/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on
/// a tree node to indicate that parts of its content are
/// represented by another tree.
class MountedTree {
    constructor(
    /// The inner tree.
    tree, 
    /// If this is null, this tree replaces the entire node (it will
    /// be included in the regular iteration instead of its host
    /// node). If not, only the given ranges are considered to be
    /// covered by this tree. This is used for trees that are mixed in
    /// a way that isn't strictly hierarchical. Such mounted trees are
    /// only entered by [`resolveInner`](#common.Tree.resolveInner)
    /// and [`enter`](#common.SyntaxNode.enter).
    overlay, 
    /// The parser used to create this subtree.
    parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
}
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#common.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#common.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a numeric array. Each parser
/// [has](#lr.LRParser.nodeSet) a node set, and [tree
/// buffers](#common.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536) node
/// types in it, so that the ids fit into 16-bit typed array slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#common.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the [`TreeCursor`](#common.TreeCursor) or
/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
/// a view on some part of this data structure, and can be used to
/// move around to adjacent nodes.
class Tree {
    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    constructor(
    /// The type of the top node.
    type, 
    /// This node's child nodes.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length, 
    /// Per-node [node props](#common.NodeProp) to associate with this node.
    props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        /// @internal
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    /// @internal
    toString() {
        let mounted = this.prop(NodeProp.mounted);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#common.TreeCursor) that, unlike regular
    /// cursors, doesn't skip through
    /// [anonymous](#common.NodeType.isAnonymous) nodes and doesn't
    /// automatically enter mounted nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, 1 /* Full */);
    }
    /// Get a [syntax node](#common.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#common.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    /// Like [`resolve`](#common.Tree.resolve), but will enter
    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    /// pointing into the innermost overlaid tree at the given position
    /// (with parent links going through all parent structure, including
    /// the host trees).
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, that node will
    /// not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor(), get = () => c.node;;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to, get);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Get the value of the given [node prop](#common.NodeProp) for this
    /// node. Works with both per-node and per-type props.
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
    /// format that can be passed to the [`Tree`](#common.Tree)
    /// constructor.
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    /// Balance the direct children of this tree, producing a copy of
    /// which may have children grouped into subtrees with type
    /// [`NodeType.none`](#common.NodeType^none).
    balance(config = {}) {
        return this.children.length <= 8 /* BranchFactor */ ? this :
            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer.
    constructor(
    /// The buffer's content.
    buffer, 
    /// The total length of the group of nodes in the buffer.
    length, 
    /// The node set used in this buffer.
    set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    /// @internal
    get type() { return NodeType.none; }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    /// @internal
    slice(startI, endI, from, to) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI);
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
        }
        return new TreeBuffer(copy, to - from, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2 /* Before */: return from < pos;
        case -1 /* AtOrBefore */: return to >= pos && from < pos;
        case 0 /* Around */: return from < pos && to > pos;
        case 1 /* AtOrAfter */: return from <= pos && to > pos;
        case 2 /* After */: return to > pos;
        case 4 /* DontCare */: return true;
    }
}
function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
        let last = scan.lastChild;
        if (!last || last.to != scan.to)
            break;
        if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
        }
        else {
            scan = last;
        }
    }
    return node;
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    // Must go up out of overlays when those do not overlap with pos
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, true)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, overlays);
        if (!inner)
            return node;
        node = inner;
    }
}
class TreeNode {
    constructor(node, _from, 
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
        this.node = node;
        this._from = _from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get from() { return this._from; }
    get to() { return this._from + this.node.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent._from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & 2 /* NoEnterBuffer */)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & 1 /* Full */) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & 1 /* Full */) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & 1 /* Full */) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & 1 /* Full */) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent.node.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos, -2 /* Before */); }
    enter(pos, side, overlays = true, buffers = true) {
        let mounted;
        if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, buffers ? 0 : 2 /* NoEnterBuffer */);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return this.node; }
    toTree() { return this.node; }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }
    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.child(1, pos, 2 /* After */); }
    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }
    enter(pos, side, overlays, buffers = true) {
        if (!buffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
            children.push(buffer.slice(startI, endI, from, to));
            positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, 
    /// @internal
    mode = 0) {
        this.mode = mode;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }
    /// Move the cursor to the first child that ends after `pos`.
    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }
    /// Move to the last child that starts before `pos`.
    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }
    /// Move the cursor to the child around `pos`. If side is -1 the
    /// child may end at that position, when 1 it may start there. This
    /// will also enter [overlaid](#common.MountedTree.overlay)
    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    /// set to false.
    enter(pos, side, overlays = true, buffers = true) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & 1 /* Full */), buffers));
        return buffers ? this.enterChild(1, pos, side) : false;
    }
    /// Move to the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & 1 /* Full */) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & 1 /* Full */) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                    let child = parent.node.children[i];
                    if ((this.mode & 1 /* Full */) || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty or `enter` is false, its next sibling or
    /// the next sibling of the first parent node that has one.
    next(enter = true) { return this.move(1, enter); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by its last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev(enter = true) { return this.move(-1, enter); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#common.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#common.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead;
        while (size < 0) {
            cursor.next();
            if (size == -1 /* Reuse */) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3 /* ContextChange */) { // Context change
                contextHash = id;
                return;
            }
            else if (size == -4 /* LookAhead */) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function makeBalanced(type) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead = 0, props) {
        if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat && nodeSize >= 0) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3 /* ContextChange */)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3 /* ContextChange */) {
            contextHash = id;
        }
        else if (size == -4 /* LookAhead */) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(
// The type the balanced tree's inner nodes.
balanceType, 
// The direct children and their positions
children, positions, 
// The index range in children/positions to use
from, to, 
// The start position of the nodes, relative to their parent.
start, 
// Length of the outer node
length, 
// Function to build the top node of the balanced tree
mkTop, 
// Function to build internal nodes for the balanced tree
mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom]; // Only trees can have a size > 1
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}

/// Tree fragments are used during [incremental
/// parsing](#common.Parser.startParse) to track parts of old trees
/// that can be reused in a new parse. An array of fragments is used
/// to track regions of an old tree whose nodes might be reused in new
/// parses. Use the static
/// [`applyChanges`](#common.TreeFragment^applyChanges) method to
/// update fragments for document changes.
class TreeFragment {
    /// Construct a tree fragment.
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);
    }
    /// Whether the start of the fragment represents the start of a
    /// parse, or the end of a change. (In the second case, it may not
    /// be safe to reuse some nodes at the start, depending on the
    /// parsing algorithm.)
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    /// Whether the end of the fragment represents the end of a
    /// full-document parse, or the start of a change.
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the resulting
    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    /// true.
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
/// A superclass that parsers should extend.
class Parser {
    /// Start a parse, returning a [partial parse](#common.PartialParse)
    /// object. [`fragments`](#common.TreeFragment) can be passed in to
    /// make the parse incremental.
    ///
    /// By default, the entire input is parsed. You can pass `ranges`,
    /// which should be a sorted array of non-empty, non-overlapping
    /// ranges, to parse only those ranges. The tree returned in that
    /// case will start at `ranges[0].from`.
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    /// Run a full parse, returning the resulting tree.
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}

/// Create a parse wrapper that, after the inner parse completes,
/// scans its tree for mixed language regions with the `nest`
/// function, runs the resulting [inner parses](#common.NestedParse),
/// and then [mounts](#common.NodeProp^mounted) their results onto the
/// tree.
///
/// The nesting function is passed a cursor to provide context for a
/// node, but _should not_ move that cursor, only inspect its
/// properties and optionally access its
/// [node object](#common.TreeCursor.node).
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, ranges) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.ranges = ranges;
    }
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            // This is a somewhat dodgy but super helpful hack where we
            // patch up nodes created by the inner parse (and thus
            // presumably not aliased anywhere else) to hold the information
            // about the inner parse.
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].ranges[0].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), 1 /* Full */);
        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {
            let enter = true, range;
            if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2 /* Full */;
            }
            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
                    if (ranges.length)
                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new Range(cursor.from, cursor.to);
                if (range.from < range.to)
                    overlay.ranges.push(range);
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length)
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;
    }
    return 0 /* None */;
}
// Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];
        nodes.push(buf.slice(startI, endI, from, to));
        positions.push(from - off);
    }
}
// This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.
function materialize(cursor) {
    let { node } = cursor, depth = 0;
    // Scan up to the nearest tree
    do {
        cursor.parent();
        depth++;
    } while (!cursor.tree);
    // Find the index of the buffer in that tree
    let i = 0, base = cursor.tree, off = 0;
    for (;; i++) {
        off = base.positions[i] + cursor.from;
        if (off <= node.from && off + base.children[i].length >= node.to)
            break;
    }
    let buf = base.children[i], b = buf.buffer;
    // Split a level in the buffer, putting the nodes before and after
    // the child that contains `node` into new buffers.
    function split(startI, endI, type, innerOffset, length) {
        let i = startI;
        while (b[i + 2] + off <= node.from)
            i = b[i + 3];
        let children = [], positions = [];
        sliceBuf(buf, startI, i, children, positions, innerOffset);
        let from = b[i + 1], to = b[i + 2];
        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;
        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));
        positions.push(from - innerOffset);
        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);
        return new Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
    // Move the cursor back to the target node
    for (let d = 0; d <= depth; d++)
        cursor.childAfter(node.from);
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.fullCursor();
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
// Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
        }
    }
    return result;
}




/***/ }),

/***/ "./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContextTracker": () => (/* binding */ ContextTracker),
/* harmony export */   "ExternalTokenizer": () => (/* binding */ ExternalTokenizer),
/* harmony export */   "InputStream": () => (/* binding */ InputStream),
/* harmony export */   "LRParser": () => (/* binding */ LRParser),
/* harmony export */   "Stack": () => (/* binding */ Stack)
/* harmony export */ });
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js");


/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// The parse that this stack is part of @internal
    p, 
    /// Holds state, input pos, buffer index triplets for all but the
    /// top state @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    /// @internal
    curContext, 
    /// @internal
    lookAhead = 0, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.p = p;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(p, state, pos = 0) {
        let cx = p.parser.context;
        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /// The stack's current [context](#lr.ContextTracker) value, if
    /// any. Its type will depend on the context tracker's type
    /// parameter, or it will be `null` if there is no context
    /// tracker.
    get context() { return this.curContext ? this.curContext.context : null; }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.p;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            // Zero-depth reductions are a special case—they add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.reduceContext(type, this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
        this.reduceContext(type, start);
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        let start = this.pos;
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let nextState = action, { parser } = this.p;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            this.shiftContext(next, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            this.pos = nextEnd;
            this.shiftContext(next, start);
            if (next <= this.p.parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /// @internal
    useNode(value, next) {
        let index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190 /* Delete */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = [];
            for (let i = 0, s; i < nextStates.length; i += 2) {
                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                    best.push(nextStates[i], s);
            }
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {
                    let s = nextStates[i + 1];
                    if (!best.some((v, i) => (i & 1) && v == s))
                        best.push(nextStates[i], s);
                }
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {
            let s = nextStates[i + 1];
            if (s == this.state)
                continue;
            let stack = this.split();
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.pushState(s, this.pos);
            stack.shiftContext(nextStates[i], this.pos);
            stack.score -= 200 /* Insert */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        let { parser } = this.p;
        if (!parser.validAction(this.state, reduce)) {
            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;
            let target = this.stack.length - depth * 3;
            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)
                return false;
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {
            if (!this.forceReduce()) {
                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);
                break;
            }
        }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.p;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.p.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }
    shiftContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    /// @internal
    emitContext() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3)
            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    /// @internal
    emitLookAhead() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4)
            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
        if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash)
                this.emitContext();
            this.curContext = newCx;
        }
    }
    /// @internal
    setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
        }
    }
    /// @internal
    close() {
        if (this.curContext && this.curContext.tracker.strict)
            this.emitContext();
        if (this.lookAhead > 0)
            this.emitLookAhead();
    }
}
class StackContext {
    constructor(tracker, context) {
        this.tracker = tracker;
        this.context = context;
        this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
}
var Recover;
(function (Recover) {
    Recover[Recover["Insert"] = 200] = "Insert";
    Recover[Recover["Delete"] = 190] = "Delete";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(start) {
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.stack == this.start.stack)
                this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
        }
        else {
            this.base -= (depth - 1) * 3;
        }
        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

class CachedToken {
    constructor() {
        this.start = -1;
        this.value = -1;
        this.end = -1;
        this.extended = -1;
        this.lookAhead = 0;
        this.mask = 0;
        this.context = 0;
    }
}
const nullToken = new CachedToken;
/// [Tokenizers](#lr.ExternalTokenizer) interact with the input
/// through this interface. It presents the input as a stream of
/// characters, tracking lookahead and hiding the complexity of
/// [ranges](#common.Parser.parse^ranges) from tokenizer code.
class InputStream {
    /// @internal
    constructor(
    /// @internal
    input, 
    /// @internal
    ranges) {
        this.input = input;
        this.ranges = ranges;
        /// @internal
        this.chunk = "";
        /// @internal
        this.chunkOff = 0;
        /// Backup chunk
        this.chunk2 = "";
        this.chunk2Pos = 0;
        /// The character code of the next code unit in the input, or -1
        /// when the stream is at the end of the input.
        this.next = -1;
        /// @internal
        this.token = nullToken;
        this.rangeIndex = 0;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
    }
    resolveOffset(offset, assoc) {
        let range = this.range, index = this.rangeIndex;
        let pos = this.pos + offset;
        while (pos < range.from) {
            if (!index)
                return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
            if (index == this.ranges.length - 1)
                return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
        }
        return pos;
    }
    /// Look at a code unit near the stream position. `.peek(0)` equals
    /// `.next`, `.peek(-1)` gives you the previous character, and so
    /// on.
    ///
    /// Note that looking around during tokenizing creates dependencies
    /// on potentially far-away content, which may reduce the
    /// effectiveness incremental parsing—when looking forward—or even
    /// cause invalid reparses when looking backward more than 25 code
    /// units, since the library does not track lookbehind.
    peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
        }
        else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null)
                return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            }
            else {
                let i = this.rangeIndex, range = this.range;
                while (range.to <= pos)
                    range = this.ranges[++i];
                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                if (pos + this.chunk2.length > range.to)
                    this.chunk2 = this.chunk2.slice(0, range.to - pos);
                result = this.chunk2.charCodeAt(0);
            }
        }
        if (pos >= this.token.lookAhead)
            this.token.lookAhead = pos + 1;
        return result;
    }
    /// Accept a token. By default, the end of the token is set to the
    /// current stream position, but you can pass an offset (relative to
    /// the stream position) to change that.
    acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start)
            throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
    }
    getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk, chunkPos } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
        }
        else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
        }
    }
    readNext() {
        if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length)
                return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /// Move the stream forward N (defaults to 1) code units. Returns
    /// the new value of [`next`](#lr.InputStream.next).
    advance(n = 1) {
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
            if (this.rangeIndex == this.ranges.length - 1)
                return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead)
            this.token.lookAhead = this.pos + 1;
        return this.readNext();
    }
    setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
    }
    /// @internal
    reset(pos, token) {
        if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
        }
        else {
            this.token = nullToken;
        }
        if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
                this.setDone();
                return this;
            }
            while (pos < this.range.from)
                this.range = this.ranges[--this.rangeIndex];
            while (pos >= this.range.to)
                this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                this.chunkOff = pos - this.chunkPos;
            }
            else {
                this.chunk = "";
                this.chunkOff = 0;
            }
            this.readNext();
        }
        return this;
    }
    /// @internal
    read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
        if (from >= this.range.from && to <= this.range.to)
            return this.input.read(from, to);
        let result = "";
        for (let r of this.ranges) {
            if (r.from >= to)
                break;
            if (r.to > from)
                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
        }
        return result;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, stack) { readToken(this.data, input, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// `@external tokens` declarations in the grammar should resolve to
/// an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream, scans for the types of tokens it
    /// recognizes at the stream's position, and calls
    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    /// one.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, stack, group) {
    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;
    scan: for (;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {
                    input.acceptToken(term);
                    break;
                }
            }
        // Do a binary search on the state's edges
        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                input.advance();
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output
const verbose = typeof process != "undefined" && /\bparse\b/.test(({"NODE_ENV":"development"}).LOG);
let stackIDs = null;
var Safety;
(function (Safety) {
    Safety[Safety["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree, pos, side) {
    let cursor = tree.fullCursor();
    cursor.moveTo(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))
                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments, nodeSet) {
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {
                if (start == pos) {
                    if (start < this.safeFrom)
                        return null;
                    let end = start + next.length;
                    if (end <= this.safeTo) {
                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);
                        if (!lookAhead || end + lookAhead < this.fragment.to)
                            return next;
                    }
                }
                this.index[last]++;
                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
            else {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
        }
    }
}
class TokenCache {
    constructor(parser, stream) {
        this.stream = stream;
        this.tokens = [];
        this.mainToken = null;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.p, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        let context = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                this.updateCachedToken(token, tokenizer, stack);
                token.mask = mask;
                token.context = context;
            }
            if (token.lookAhead > token.end + 25 /* Margin */)
                lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (lookAhead)
            stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
            main = new CachedToken;
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
    }
    getMainToken(stack) {
        if (this.mainToken)
            return this.mainToken;
        let main = new CachedToken, { pos, p } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;
        return main;
    }
    updateCachedToken(token, tokenizer, stack) {
        tokenizer.token(this.stream.reset(stack.pos, token), stack);
        if (token.value > -1) {
            let { parser } = stack.p;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else {
            token.value = 0 /* Err */;
            token.end = Math.min(stack.p.stream.end, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.p, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 2), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    // When two stacks have been running independently long enough to
    // add this many elements to their buffers, prune one.
    Rec[Rec["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    // Once a stack reaches this depth (in .stack.length) force-reduce
    // it back to CutTo to avoid creating trees that overflow the stack
    // on recursive traversal.
    Rec[Rec["CutDepth"] = 15000] = "CutDepth";
    Rec[Rec["CutTo"] = 9000] = "CutTo";
})(Rec || (Rec = {}));
class Parse {
    constructor(parser, input, fragments, ranges) {
        this.parser = parser;
        this.input = input;
        this.ranges = ranges;
        this.recovering = 0;
        this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧
        this.minStackPos = 0;
        this.reused = [];
        this.stoppedAt = null;
        this.stream = new InputStream(input, ranges);
        this.tokens = new TokenCache(parser, this.stream);
        this.topTerm = parser.top[1];
        let { from } = ranges[0];
        this.stacks = [Stack.start(this, parser.top[0], from)];
        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4
            ? new FragmentCursor(fragments, parser.nodeSet) : null;
    }
    get parsedPos() {
        return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i];
            for (;;) {
                this.tokens.mainToken = null;
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.getMainToken(stack);
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]
                : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.minStackPos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.minStackPos)
                this.minStackPos = newStacks[i].pos;
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt)
            return stack.forceReduce() ? stack : null;
        if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        if (stack.stack.length >= 15000 /* CutDepth */) {
            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }
        }
        let actions = this.tokens.getActions(stack);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done)
                    continue;
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done)
                    break;
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.stream.end > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
        stack.close();
        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm });
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
const id = x => x;
/// Context trackers are used to track stateful context (such as
/// indentation in the Python grammar, or parent elements in the XML
/// grammar) needed by external tokenizers. You declare them in a
/// grammar file as `@context exportName from "module"`.
///
/// Context values should be immutable, and can be updated (replaced)
/// on shift or reduce actions.
///
/// The export used in a `@context` declaration should be of this
/// type.
class ContextTracker {
    /// Define a context tracker.
    constructor(spec) {
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (() => 0);
        this.strict = spec.strict !== false;
    }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {
    /// @internal
    constructor(spec) {
        super();
        /// @internal
        this.wrappers = [];
        if (spec.version != 13 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        this.strict = false;
        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
        let parse = new Parse(this, input, fragments, ranges);
        for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
        return parse;
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {
                let value = this.data[i + 1];
                if (!result.some((v, i) => (i & 1) && v == value))
                    result.push(this.data[i], value);
            }
        }
        return result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(LRParser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.contextTracker)
            copy.context = config.contextTracker;
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.wrap)
            copy.wrappers = copy.wrappers.concat(config.wrap);
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// The type of top node produced by the parser.
    get topNode() { return this.nodeSet.types[this.top[1]]; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new LRParser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        let stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&
            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvbWV0aGV1c1BsdWdpbi41MmI2MTVjMWQxODhhNTRmNjlmYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBV08sU0FBU0EsNEJBQVQsQ0FBc0NDLE9BQXRDLEVBQStGO0VBQ3BHLE9BQU8sT0FBT0EsT0FBUCxLQUFtQixRQUFuQixJQUErQkEsT0FBTyxLQUFLLElBQTNDLElBQW1ELGdCQUFnQkEsT0FBMUU7QUFDRDtBQUVNLE1BQU1DLHFCQUFxQixHQUFPRCxPQUFKLElBQWtEO0VBQ3JGLElBQUlFLFlBQVksR0FBRyxLQUFuQjtFQUVBLE1BQU1DLGNBQWMsR0FBRyxJQUFJQyxPQUFKLENBQWUsQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0lBQ3pELE1BQU1DLHdCQUFvRCxHQUFHO01BQUVDLFVBQVUsRUFBRTtJQUFkLENBQTdEO0lBQ0FSLE9BQU8sQ0FBQ1MsSUFBUixDQUFjQyxHQUFELElBQVVSLFlBQVksR0FBR0ksTUFBTSxDQUFDQyx3QkFBRCxDQUFULEdBQXNDRixPQUFPLENBQUNLLEdBQUQsQ0FBaEY7SUFDQVYsT0FBTyxDQUFDVyxLQUFSLENBQWVDLEtBQUQsSUFBWVYsWUFBWSxHQUFHSSxNQUFNLENBQUNDLHdCQUFELENBQVQsR0FBc0NELE1BQU0sQ0FBQ00sS0FBRCxDQUFsRjtFQUNELENBSnNCLENBQXZCO0VBTUEsT0FBTztJQUNMWixPQUFPLEVBQUVHLGNBREo7O0lBRUxVLE1BQU0sR0FBRztNQUNQWCxZQUFZLEdBQUcsSUFBZjtJQUNEOztFQUpJLENBQVA7QUFNRCxDQWZNOzs7Ozs7Ozs7Ozs7Ozs7QUNmUDtBQUVBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNlLGVBQVQsQ0FBeUJDLEtBQXpCLEVBQXdDQyxHQUF4QyxFQUFxREMsS0FBckQsRUFBNkVDLFFBQVEsR0FBRyxHQUF4RixFQUFxRztFQUMxRyxJQUFJLENB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QU07O0FBRU47QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSwrQkFBK0IsSUFBSTtBQUNoRDtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLCtCQUErQixJQUFJO0FBQ2pEO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyx1Q0FBdUMsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSwrQkFBK0IsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoN0JxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsYUFBYSxVQUFVO0FBQzdFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsV0FBVztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDRCQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw2REFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLGFBQWEsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUSxXQUFXLFNBQVMsYUFBYSxPQUFPO0FBQzlELDBCQUEwQixTQUFTO0FBQ25DLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQjtBQUM3RDtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxPQUFPO0FBQ25FO0FBQ0EsOEVBQThFLCtEQUFvQjtBQUNsRztBQUNBO0FBQ0EsbUZBQW1GLCtCQUErQjtBQUNsSDtBQUNBO0FBQ0Esd0NBQXdDLCtDQUFJO0FBQzVDO0FBQ0E7QUFDQSxxQ0FBcUMsK0NBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLHNEQUFzRDtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsbUNBQW1DLCtDQUErQyxHQUFHLE1BQU0sc0JBQXNCLElBQUksTUFBTSxFQUFFLHFDQUFxQztBQUNsSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFzRDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLDJCQUEyQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBVSxHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsYUFBYSxtQ0FBbUMsaUJBQWlCO0FBQ3JIO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0RBQU8sNEJBQTRCLDBEQUFlO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRCQUE0Qiw4REFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQyw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsMkRBQTJELHlDQUF5QztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSw4QkFBOEIscUNBQXFDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9jb3JlL3V0aWxzL0NhbmNlbGFibGVQcm9taXNlLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2FkZF9sYWJlbF90b19xdWVyeS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL0Fubm90YXRpb25RdWVyeUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9Qcm9tQ2hlYXRTaGVldC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9Qcm9tRXhlbXBsYXJGaWVsZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9Qcm9tRXhwbG9yZUV4dHJhRmllbGQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvUHJvbUV4cGxvcmVRdWVyeUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9Qcm9tTGluay50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9Qcm9tUXVlcnlFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvUHJvbVF1ZXJ5RWRpdG9yQnlBcHAudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvUHJvbVF1ZXJ5RWRpdG9yRm9yQWxlcnRpbmcudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvUHJvbVF1ZXJ5RmllbGQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvUHJvbWV0aGV1c01ldHJpY3NCcm93c2VyLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL21vbmFjby1xdWVyeS1maWVsZC9Nb25hY29RdWVyeUZpZWxkTGF6eS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9tb25hY28tcXVlcnktZmllbGQvTW9uYWNvUXVlcnlGaWVsZFdyYXBwZXIudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbmZpZ3VyYXRpb24vQXp1cmVBdXRoU2V0dGluZ3MudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbmZpZ3VyYXRpb24vQXp1cmVDcmVkZW50aWFscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb25maWd1cmF0aW9uL0F6dXJlQ3JlZGVudGlhbHNDb25maWcudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29uZmlndXJhdGlvbi9BenVyZUNyZWRlbnRpYWxzRm9ybS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29uZmlndXJhdGlvbi9Db25maWdFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbmZpZ3VyYXRpb24vRXhlbXBsYXJTZXR0aW5nLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb25maWd1cmF0aW9uL0V4ZW1wbGFyc1NldHRpbmdzLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb25maWd1cmF0aW9uL1Byb21TZXR0aW5ncy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvZGF0YXNvdXJjZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvbGFuZ3VhZ2VfcHJvdmlkZXIudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvbGFuZ3VhZ2VfdXRpbHMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvbWV0cmljX2ZpbmRfcXVlcnkudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvbW9kdWxlLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3Byb21xbC50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeV9oaW50cy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvUHJvbVF1ZXJ5TW9kZWxsZXIudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2FnZ3JlZ2F0aW9ucy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvYmluYXJ5U2NhbGFyT3BlcmF0aW9ucy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9MYWJlbFBhcmFtRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9NZXRyaWNTZWxlY3QudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL05lc3RlZFF1ZXJ5LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9OZXN0ZWRRdWVyeUxpc3QudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL1Byb21RdWVyeUJ1aWxkZXIudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL1Byb21RdWVyeUJ1aWxkZXJDb250YWluZXIudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL1Byb21RdWVyeUJ1aWxkZXJFeHBsYWluZWQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL1Byb21RdWVyeUJ1aWxkZXJIaW50cy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvUHJvbVF1ZXJ5QnVpbGRlck9wdGlvbnMudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL1Byb21RdWVyeUNvZGVFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL1Byb21RdWVyeUVkaXRvclNlbGVjdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9Qcm9tUXVlcnlMZWdlbmRFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL1F1ZXJ5UHJldmlldy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL29wZXJhdGlvbnMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3BhcnNpbmcudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9GZWVkYmFja0xpbmsudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvTGFiZWxGaWx0ZXJJdGVtLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xhYmVsRmlsdGVycy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9Mb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkV4cGxhaW5lZEJveC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25IZWFkZXIudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uSW5mb0J1dHRvbi50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25MaXN0LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkxpc3RFeHBsYWluZWQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uUGFyYW1FZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uc0VkaXRvclJvdy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9RdWVyeUVkaXRvck1vZGVUb2dnbGUudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvUXVlcnlIZWFkZXJTd2l0Y2gudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvUXVlcnlPcHRpb25Hcm91cC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9SYXdRdWVyeS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9vcGVyYXRpb25VdGlscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3BhcnNpbmdVdGlscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zdGF0ZS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcmVzdWx0X3RyYW5zZm9ybWVyLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3R5cGVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3ZhcmlhYmxlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtcG9wcGVyLXRvb2x0aXAtdmlydHVhbC1mZjBkYTRiMmZkLzAvY2FjaGUvcmVhY3QtcG9wcGVyLXRvb2x0aXAtbnBtLTQuNC4xLTIyMTQ0ODBkYmMtNThkYWNkZjliYy56aXAvbm9kZV9tb2R1bGVzL3JlYWN0LXBvcHBlci10b29sdGlwL2Rpc3QvZXNtL3JlYWN0LXBvcHBlci10b29sdGlwLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC11c2UtdmlydHVhbC1jZWE4ZTgyNmRjLzAvY2FjaGUvcmVhY3QtdXNlLW5wbS0xNy40LjAtMGVmNDUyMTU0NC0wODg5ZGE5MTliLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtdXNlL2VzbS91c2VQcmV2aW91cy5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGdyYWZhbmEtYXdzLXNkay1ucG0tMC4wLjM2LThhYjRiMDc5MDQtYzI0M2Y3YzkwMC56aXAvbm9kZV9tb2R1bGVzL0BncmFmYW5hL2F3cy1zZGsvZGlzdC9pbmRleC5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGdyYWZhbmEtYXdzLXNkay1ucG0tMC4wLjM2LThhYjRiMDc5MDQtYzI0M2Y3YzkwMC56aXAvbm9kZV9tb2R1bGVzL0BncmFmYW5hL2F3cy1zZGsvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL2xydS1jYWNoZS1ucG0tNy4xMC4xLTVhZjkxMGQwZWQtZThiMTkwZDcxZS56aXAvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vbGV6ZXItcHJvbXFsLXZpcnR1YWwtZWFmODhhYTc3YS8wL2NhY2hlL2xlemVyLXByb21xbC1ucG0tMC4yMi4wLTg2N2RhNmFmYWEtY2RjZTA1NDcwMC56aXAvbm9kZV9tb2R1bGVzL2xlemVyLXByb21xbC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTguMy0xODgzYzcwZmE2LWRiODUyNjIyNmEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xOC4zLTE4ODNjNzBmYTYtZGI4NTI2MjI2YS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BsZXplci1jb21tb24tbnBtLTAuMTUuMTItNjIwMTcyNzJiMC1kYWU2NTgxNjE4LnppcC9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9AbGV6ZXItbHItbnBtLTAuMTUuOC04YzQ4MWMzOWNkLWU3NDEyMjVkNmEuemlwL25vZGVfbW9kdWxlcy9AbGV6ZXIvbHIvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzU0NjVcblxuZXhwb3J0IGludGVyZmFjZSBDYW5jZWxhYmxlUHJvbWlzZTxUPiB7XG4gIHByb21pc2U6IFByb21pc2U8VD47XG4gIGNhbmNlbDogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYW5jZWxhYmxlUHJvbWlzZVJlamVjdGlvbiB7XG4gIGlzQ2FuY2VsZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbmNlbGFibGVQcm9taXNlUmVqZWN0aW9uKHByb21pc2U6IHVua25vd24pOiBwcm9taXNlIGlzIENhbmNlbGFibGVQcm9taXNlUmVqZWN0aW9uIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9taXNlID09PSAnb2JqZWN0JyAmJiBwcm9taXNlICE9PSBudWxsICYmICdpc0NhbmNlbGVkJyBpbiBwcm9taXNlO1xufVxuXG5leHBvcnQgY29uc3QgbWFrZVByb21pc2VDYW5jZWxhYmxlID0gPFQ+KHByb21pc2U6IFByb21pc2U8VD4pOiBDYW5jZWxhYmxlUHJvbWlzZTxUPiA9PiB7XG4gIGxldCBoYXNDYW5jZWxlZF8gPSBmYWxzZTtcblxuICBjb25zdCB3cmFwcGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBjYW5jZWxlZFByb21pc2VSZWplY3Rpb246IENhbmNlbGFibGVQcm9taXNlUmVqZWN0aW9uID0geyBpc0NhbmNlbGVkOiB0cnVlIH07XG4gICAgcHJvbWlzZS50aGVuKCh2YWwpID0+IChoYXNDYW5jZWxlZF8gPyByZWplY3QoY2FuY2VsZWRQcm9taXNlUmVqZWN0aW9uKSA6IHJlc29sdmUodmFsKSkpO1xuICAgIHByb21pc2UuY2F0Y2goKGVycm9yKSA9PiAoaGFzQ2FuY2VsZWRfID8gcmVqZWN0KGNhbmNlbGVkUHJvbWlzZVJlamVjdGlvbikgOiByZWplY3QoZXJyb3IpKSk7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgcHJvbWlzZTogd3JhcHBlZFByb21pc2UsXG4gICAgY2FuY2VsKCkge1xuICAgICAgaGFzQ2FuY2VsZWRfID0gdHJ1ZTtcbiAgICB9LFxuICB9O1xufTtcbiIsImltcG9ydCB7IHBhcnNlciB9IGZyb20gJ2xlemVyLXByb21xbCc7XG5cbmltcG9ydCB7IFByb21RdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvUHJvbVF1ZXJ5TW9kZWxsZXInO1xuaW1wb3J0IHsgYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcgfSBmcm9tICcuL3F1ZXJ5YnVpbGRlci9wYXJzaW5nJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeSB9IGZyb20gJy4vcXVlcnlidWlsZGVyL3R5cGVzJztcblxuLyoqXG4gKiBBZGRzIGxhYmVsIGZpbHRlciB0byBleGlzdGluZyBxdWVyeS4gVXNlZnVsIGZvciBxdWVyeSBtb2RpZmljYXRpb24gZm9yIGV4YW1wbGUgZm9yIGFkIGhvYyBmaWx0ZXJzLlxuICpcbiAqIEl0IHVzZXMgUHJvbVFMIHBhcnNlciB0byBmaW5kIGluc3RhbmNlcyBvZiBtZXRyaWMgYW5kIGxhYmVscywgYWx0ZXJzIHRoZW0gYW5kIHRoZW4gc3BsaWNlcyB0aGVtIGJhY2sgaW50byB0aGUgcXVlcnkuXG4gKiBJZGVhbGx5IHdlIGNvdWxkIHVzZSB0aGUgcGFyc2UgLT4gY2hhbmdlIC0+IHJlbmRlciBpcyBhIHNpbXBsZSAzIHN0ZXBzIGJ1dCByaWdodCBub3cgYnVpbGRpbmcgdGhlIHZpc3VhbCBxdWVyeVxuICogb2JqZWN0IGRvZXMgbm90IHN1cHBvcnQgYWxsIHBvc3NpYmxlIHF1ZXJpZXMuXG4gKlxuICogU28gaW5zdGVhZCB0aGlzIGp1c3Qgb3BlcmF0ZXMgb24gc3Vic3RyaW5ncyBvZiB0aGUgcXVlcnkgd2l0aCBsYWJlbHMgYW5kIG9wZXJhdGVzIGp1c3Qgb24gdGhvc2UuIFRoaXMgbWFrZXMgdGhpc1xuICogbW9yZSByb2J1c3QgYW5kIGNhbiBhbHRlciBldmVuIGludmFsaWQgcXVlcmllcywgYW5kIHByZXNlcnZlcyBpbiBnZW5lcmFsIHRoZSBxdWVyeSBzdHJ1Y3R1cmUgYW5kIHdoaXRlc3BhY2UuXG4gKiBAcGFyYW0gcXVlcnlcbiAqIEBwYXJhbSBrZXlcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG9wZXJhdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRMYWJlbFRvUXVlcnkocXVlcnk6IHN0cmluZywga2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIsIG9wZXJhdG9yID0gJz0nKTogc3RyaW5nIHtcbiAgaWYgKCFrZXkgfHwgIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGxhYmVsIHRvIGFkZCB0byBxdWVyeS4nKTtcbiAgfVxuXG4gIGNvbnN0IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zID0gZ2V0VmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMocXVlcnkpO1xuICBpZiAoIXZlY3RvclNlbGVjdG9yUG9zaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIGNvbnN0IGZpbHRlciA9IHRvTGFiZWxGaWx0ZXIoa2V5LCB2YWx1ZSwgb3BlcmF0b3IpO1xuICByZXR1cm4gYWRkRmlsdGVyKHF1ZXJ5LCB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucywgZmlsdGVyKTtcbn1cblxudHlwZSBWZWN0b3JTZWxlY3RvclBvc2l0aW9uID0geyBmcm9tOiBudW1iZXI7IHRvOiBudW1iZXI7IHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgc3RyaW5nIGFuZCBnZXQgYWxsIFZlY3RvclNlbGVjdG9yIHBvc2l0aW9ucyBpbiB0aGUgcXVlcnkgdG9nZXRoZXIgd2l0aCBwYXJzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICogc2VsZWN0b3IuXG4gKiBAcGFyYW0gcXVlcnlcbiAqL1xuZnVuY3Rpb24gZ2V0VmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMocXVlcnk6IHN0cmluZyk6IFZlY3RvclNlbGVjdG9yUG9zaXRpb25bXSB7XG4gIGNvbnN0IHRyZWUgPSBwYXJzZXIucGFyc2UocXVlcnkpO1xuICBjb25zdCBwb3NpdGlvbnM6IFZlY3RvclNlbGVjdG9yUG9zaXRpb25bXSA9IFtdO1xuICB0cmVlLml0ZXJhdGUoe1xuICAgIGVudGVyOiAodHlwZSwgZnJvbSwgdG8sIGdldCk6IGZhbHNlIHwgdm9pZCA9PiB7XG4gICAgICBpZiAodHlwZS5uYW1lID09PSAnVmVjdG9yU2VsZWN0b3InKSB7XG4gICAgICAgIGNvbnN0IHZpc1F1ZXJ5ID0gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcocXVlcnkuc3Vic3RyaW5nKGZyb20sIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHsgcXVlcnk6IHZpc1F1ZXJ5LnF1ZXJ5LCBmcm9tLCB0byB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xuICByZXR1cm4gcG9zaXRpb25zO1xufVxuXG5mdW5jdGlvbiB0b0xhYmVsRmlsdGVyKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBvcGVyYXRvcjogc3RyaW5nKTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGNvbnZlcnQgdGhlIHZhbHVlIGJhY2sgdG8gc3RyaW5nIGJlY2F1c2UgaXQgbWF5IGJlIGEgbnVtYmVyXG4gIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWUgPSB2YWx1ZSA9PT0gSW5maW5pdHkgPyAnK0luZicgOiB2YWx1ZS50b1N0cmluZygpO1xuICByZXR1cm4geyBsYWJlbDoga2V5LCBvcDogb3BlcmF0b3IsIHZhbHVlOiB0cmFuc2Zvcm1lZFZhbHVlIH07XG59XG5cbmZ1bmN0aW9uIGFkZEZpbHRlcihcbiAgcXVlcnk6IHN0cmluZyxcbiAgdmVjdG9yU2VsZWN0b3JQb3NpdGlvbnM6IFZlY3RvclNlbGVjdG9yUG9zaXRpb25bXSxcbiAgZmlsdGVyOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlclxuKTogc3RyaW5nIHtcbiAgY29uc3QgbW9kZWxsZXIgPSBuZXcgUHJvbVF1ZXJ5TW9kZWxsZXIoKTtcbiAgbGV0IG5ld1F1ZXJ5ID0gJyc7XG4gIGxldCBwcmV2ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gVGhpcyBpcyBiYXNpY2FsbHkganVzdCBkb2luZyBzcGxpY2Ugb24gYSBzdHJpbmcgZm9yIGVhY2ggbWF0Y2hlZCB2ZWN0b3Igc2VsZWN0b3IuXG5cbiAgICBjb25zdCBtYXRjaCA9IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zW2ldO1xuICAgIGNvbnN0IGlzTGFzdCA9IGkgPT09IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zLmxlbmd0aCAtIDE7XG5cbiAgICBjb25zdCBzdGFydCA9IHF1ZXJ5LnN1YnN0cmluZyhwcmV2LCBtYXRjaC5mcm9tKTtcbiAgICBjb25zdCBlbmQgPSBpc0xhc3QgPyBxdWVyeS5zdWJzdHJpbmcobWF0Y2gudG8pIDogJyc7XG5cbiAgICBpZiAoIWxhYmVsRXhpc3RzKG1hdGNoLnF1ZXJ5LmxhYmVscywgZmlsdGVyKSkge1xuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBhZGQgZHVwbGljYXRlIGxhYmVscy5cbiAgICAgIG1hdGNoLnF1ZXJ5LmxhYmVscy5wdXNoKGZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IG5ld0xhYmVscyA9IG1vZGVsbGVyLnJlbmRlclF1ZXJ5KG1hdGNoLnF1ZXJ5KTtcbiAgICBuZXdRdWVyeSArPSBzdGFydCArIG5ld0xhYmVscyArIGVuZDtcbiAgICBwcmV2ID0gbWF0Y2gudG87XG4gIH1cbiAgcmV0dXJuIG5ld1F1ZXJ5O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGxhYmVsIGV4aXN0cyBpbiB0aGUgbGlzdCBvZiBsYWJlbHMgYnV0IGlnbm9yZSB0aGUgb3BlcmF0b3IuXG4gKiBAcGFyYW0gbGFiZWxzXG4gKiBAcGFyYW0gZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIGxhYmVsRXhpc3RzKGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSwgZmlsdGVyOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcikge1xuICByZXR1cm4gbGFiZWxzLmZpbmQoKGxhYmVsKSA9PiBsYWJlbC5sYWJlbCA9PT0gZmlsdGVyLmxhYmVsICYmIGxhYmVsLnZhbHVlID09PSBmaWx0ZXIudmFsdWUpO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgQW5ub3RhdGlvblF1ZXJ5IH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JSb3csIEVkaXRvckZpZWxkLCBFZGl0b3JTd2l0Y2gsIFNwYWNlLCBFZGl0b3JSb3dzIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IElucHV0LCBBdXRvU2l6ZUlucHV0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBQcm9tUXVlcnlDb2RlRWRpdG9yIH0gZnJvbSAnLi4vcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvUHJvbVF1ZXJ5Q29kZUVkaXRvcic7XG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFByb21RdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbnR5cGUgUHJvcHMgPSBQcm9tUXVlcnlFZGl0b3JQcm9wcyAmIHtcbiAgYW5ub3RhdGlvbj86IEFubm90YXRpb25RdWVyeTxQcm9tUXVlcnk+O1xuICBvbkFubm90YXRpb25DaGFuZ2U/OiAoYW5ub3RhdGlvbjogQW5ub3RhdGlvblF1ZXJ5PFByb21RdWVyeT4pID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gQW5ub3RhdGlvblF1ZXJ5RWRpdG9yKHByb3BzOiBQcm9wcykge1xuICAvLyBUaGlzIGlzIGJlY2F1c2Ugb2YgcHJvYmxlbWF0aWMgdHlwaW5nLiBTZWUgQW5ub3RhdGlvblF1ZXJ5RWRpdG9yUHJvcHMgaW4gZ3JhZmFuYS1kYXRhL2Fubm90YXRpb25zLnRzLlxuICBjb25zdCBhbm5vdGF0aW9uID0gcHJvcHMuYW5ub3RhdGlvbiE7XG4gIGNvbnN0IG9uQW5ub3RhdGlvbkNoYW5nZSA9IHByb3BzLm9uQW5ub3RhdGlvbkNoYW5nZSE7XG4gIGNvbnN0IHF1ZXJ5ID0geyBleHByOiBhbm5vdGF0aW9uLmV4cHIsIHJlZklkOiBhbm5vdGF0aW9uLm5hbWUsIGludGVydmFsOiBhbm5vdGF0aW9uLnN0ZXAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8RWRpdG9yUm93cz5cbiAgICAgICAgPFByb21RdWVyeUNvZGVFZGl0b3JcbiAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICAgIG9uQ2hhbmdlPXsocXVlcnkpID0+IHtcbiAgICAgICAgICAgIG9uQW5ub3RhdGlvbkNoYW5nZSh7XG4gICAgICAgICAgICAgIC4uLmFubm90YXRpb24sXG4gICAgICAgICAgICAgIGV4cHI6IHF1ZXJ5LmV4cHIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgICA8RWRpdG9yUm93PlxuICAgICAgICAgIDxFZGl0b3JGaWVsZFxuICAgICAgICAgICAgbGFiZWw9XCJNaW4gc3RlcFwiXG4gICAgICAgICAgICB0b29sdGlwPXtcbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICBBbiBhZGRpdGlvbmFsIGxvd2VyIGxpbWl0IGZvciB0aGUgc3RlcCBwYXJhbWV0ZXIgb2YgdGhlIFByb21ldGhldXMgcXVlcnkgYW5kIGZvciB0aGV7JyAnfVxuICAgICAgICAgICAgICAgIDxjb2RlPiRfX2ludGVydmFsPC9jb2RlPiBhbmQgPGNvZGU+JF9fcmF0ZV9pbnRlcnZhbDwvY29kZT4gdmFyaWFibGVzLlxuICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8QXV0b1NpemVJbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJTZXQgbG93ZXIgbGltaXQgZm9yIHRoZSBzdGVwIHBhcmFtZXRlclwiXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXsnYXV0byd9XG4gICAgICAgICAgICAgIG1pbldpZHRoPXsxMH1cbiAgICAgICAgICAgICAgb25Db21taXRDaGFuZ2U9eyhldikgPT4ge1xuICAgICAgICAgICAgICAgIG9uQW5ub3RhdGlvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAuLi5hbm5vdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgc3RlcDogZXYuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtxdWVyeS5pbnRlcnZhbH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAgPC9FZGl0b3JSb3c+XG4gICAgICA8L0VkaXRvclJvd3M+XG4gICAgICA8U3BhY2Ugdj17MC41fSAvPlxuICAgICAgPEVkaXRvclJvdz5cbiAgICAgICAgPEVkaXRvckZpZWxkXG4gICAgICAgICAgbGFiZWw9XCJUaXRsZVwiXG4gICAgICAgICAgdG9vbHRpcD17XG4gICAgICAgICAgICAnVXNlIGVpdGhlciB0aGUgbmFtZSBvciBhIHBhdHRlcm4uIEZvciBleGFtcGxlLCB7e2luc3RhbmNlfX0gaXMgcmVwbGFjZWQgd2l0aCBsYWJlbCB2YWx1ZSBmb3IgdGhlIGxhYmVsIGluc3RhbmNlLidcbiAgICAgICAgICB9XG4gICAgICAgID5cbiAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwie3thbGVydG5hbWV9fVwiXG4gICAgICAgICAgICB2YWx1ZT17YW5ub3RhdGlvbi50aXRsZUZvcm1hdH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgb25Bbm5vdGF0aW9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi5hbm5vdGF0aW9uLFxuICAgICAgICAgICAgICAgIHRpdGxlRm9ybWF0OiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiVGFnc1wiPlxuICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJsYWJlbDEsbGFiZWwyXCJcbiAgICAgICAgICAgIHZhbHVlPXthbm5vdGF0aW9uLnRhZ0tleXN9XG4gICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIG9uQW5ub3RhdGlvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgICB0YWdLZXlzOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAgPEVkaXRvckZpZWxkXG4gICAgICAgICAgbGFiZWw9XCJUZXh0XCJcbiAgICAgICAgICB0b29sdGlwPXtcbiAgICAgICAgICAgICdVc2UgZWl0aGVyIHRoZSBuYW1lIG9yIGEgcGF0dGVybi4gRm9yIGV4YW1wbGUsIHt7aW5zdGFuY2V9fSBpcyByZXBsYWNlZCB3aXRoIGxhYmVsIHZhbHVlIGZvciB0aGUgbGFiZWwgaW5zdGFuY2UuJ1xuICAgICAgICAgIH1cbiAgICAgICAgPlxuICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJ7e2luc3RhbmNlfX1cIlxuICAgICAgICAgICAgdmFsdWU9e2Fubm90YXRpb24udGV4dEZvcm1hdH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgb25Bbm5vdGF0aW9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi5hbm5vdGF0aW9uLFxuICAgICAgICAgICAgICAgIHRleHRGb3JtYXQ6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgICA8RWRpdG9yRmllbGRcbiAgICAgICAgICBsYWJlbD1cIlNlcmllcyB2YWx1ZSBhcyB0aW1lc3RhbXBcIlxuICAgICAgICAgIHRvb2x0aXA9e1xuICAgICAgICAgICAgJ1RoZSB1bml0IG9mIHRpbWVzdGFtcCBpcyBtaWxsaXNlY29uZHMuIElmIHRoZSB1bml0IG9mIHRoZSBzZXJpZXMgdmFsdWUgaXMgc2Vjb25kcywgbXVsdGlwbHkgaXRzIHJhbmdlIHZlY3RvciBieSAxMDAwLidcbiAgICAgICAgICB9XG4gICAgICAgID5cbiAgICAgICAgICA8RWRpdG9yU3dpdGNoXG4gICAgICAgICAgICB2YWx1ZT17YW5ub3RhdGlvbi51c2VWYWx1ZUZvclRpbWV9XG4gICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIG9uQW5ub3RhdGlvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZUZvclRpbWU6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgPC9FZGl0b3JSb3c+XG4gICAgPC8+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBRdWVyeUVkaXRvckhlbHBQcm9wcyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IENIRUFUX1NIRUVUX0lURU1TID0gW1xuICB7XG4gICAgdGl0bGU6ICdSZXF1ZXN0IFJhdGUnLFxuICAgIGV4cHJlc3Npb246ICdyYXRlKGh0dHBfcmVxdWVzdF90b3RhbFs1bV0pJyxcbiAgICBsYWJlbDpcbiAgICAgICdHaXZlbiBhbiBIVFRQIHJlcXVlc3QgY291bnRlciwgdGhpcyBxdWVyeSBjYWxjdWxhdGVzIHRoZSBwZXItc2Vjb25kIGF2ZXJhZ2UgcmVxdWVzdCByYXRlIG92ZXIgdGhlIGxhc3QgNSBtaW51dGVzLicsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJzk1dGggUGVyY2VudGlsZSBvZiBSZXF1ZXN0IExhdGVuY2llcycsXG4gICAgZXhwcmVzc2lvbjogJ2hpc3RvZ3JhbV9xdWFudGlsZSgwLjk1LCBzdW0ocmF0ZShwcm9tZXRoZXVzX2h0dHBfcmVxdWVzdF9kdXJhdGlvbl9zZWNvbmRzX2J1Y2tldFs1bV0pKSBieSAobGUpKScsXG4gICAgbGFiZWw6ICdDYWxjdWxhdGVzIHRoZSA5NXRoIHBlcmNlbnRpbGUgb2YgSFRUUCByZXF1ZXN0IHJhdGUgb3ZlciA1IG1pbnV0ZSB3aW5kb3dzLicsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FsZXJ0cyBGaXJpbmcnLFxuICAgIGV4cHJlc3Npb246ICdzb3J0X2Rlc2Moc3VtKHN1bV9vdmVyX3RpbWUoQUxFUlRTe2FsZXJ0c3RhdGU9XCJmaXJpbmdcIn1bMjRoXSkpIGJ5IChhbGVydG5hbWUpKScsXG4gICAgbGFiZWw6ICdTdW1zIHVwIHRoZSBhbGVydHMgdGhhdCBoYXZlIGJlZW4gZmlyaW5nIG92ZXIgdGhlIGxhc3QgMjQgaG91cnMuJyxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnU3RlcCcsXG4gICAgbGFiZWw6XG4gICAgICAnRGVmaW5lcyB0aGUgZ3JhcGggcmVzb2x1dGlvbiB1c2luZyBhIGR1cmF0aW9uIGZvcm1hdCAoMTVzLCAxbSwgM2gsIC4uLikuIFNtYWxsIHN0ZXBzIGNyZWF0ZSBoaWdoLXJlc29sdXRpb24gZ3JhcGhzIGJ1dCBjYW4gYmUgc2xvdyBvdmVyIGxhcmdlciB0aW1lIHJhbmdlcy4gVXNpbmcgYSBsb25nZXIgc3RlcCBsb3dlcnMgdGhlIHJlc29sdXRpb24gYW5kIHNtb290aHMgdGhlIGdyYXBoIGJ5IHByb2R1Y2luZyBmZXdlciBkYXRhcG9pbnRzLiBJZiBubyBzdGVwIGlzIGdpdmVuIHRoZSByZXNvbHV0aW9uIGlzIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseS4nLFxuICB9LFxuXTtcblxuY29uc3QgUHJvbUNoZWF0U2hlZXQgPSAocHJvcHM6IFF1ZXJ5RWRpdG9ySGVscFByb3BzPFByb21RdWVyeT4pID0+IChcbiAgPGRpdj5cbiAgICA8aDI+UHJvbVFMIENoZWF0IFNoZWV0PC9oMj5cbiAgICB7Q0hFQVRfU0hFRVRfSVRFTVMubWFwKChpdGVtLCBpbmRleCkgPT4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtXCIga2V5PXtpbmRleH0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fdGl0bGVcIj57aXRlbS50aXRsZX08L2Rpdj5cbiAgICAgICAge2l0ZW0uZXhwcmVzc2lvbiA/IChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX19leGFtcGxlXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiBwcm9wcy5vbkNsaWNrRXhhbXBsZSh7IHJlZklkOiAnQScsIGV4cHI6IGl0ZW0uZXhwcmVzc2lvbiB9KX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Y29kZT57aXRlbS5leHByZXNzaW9ufTwvY29kZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSA6IG51bGx9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fbGFiZWxcIj57aXRlbS5sYWJlbH08L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICkpfVxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFByb21DaGVhdFNoZWV0O1xuIiwiaW1wb3J0IHsgY3NzLCBjeCB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVByZXZpb3VzIH0gZnJvbSAncmVhY3QtdXNlJztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgSWNvbkJ1dHRvbiwgSW5saW5lTGFiZWwsIFRvb2x0aXAsIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gIG9uQ2hhbmdlOiAoZXhlbXBsYXI6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlO1xuICBxdWVyeTogUHJvbVF1ZXJ5O1xuICAnZGF0YS10ZXN0aWQnPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUHJvbUV4ZW1wbGFyRmllbGQoeyBkYXRhc291cmNlLCBvbkNoYW5nZSwgcXVlcnksIC4uLnJlc3QgfTogUHJvcHMpIHtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuICBjb25zdCBwcmV2RXJyb3IgPSB1c2VQcmV2aW91cyhlcnJvcik7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWRhdGFzb3VyY2UuZXhlbXBsYXJzQXZhaWxhYmxlKSB7XG4gICAgICBzZXRFcnJvcignRXhlbXBsYXJzIGZvciB0aGlzIHF1ZXJ5IGFyZSBub3QgYXZhaWxhYmxlJyk7XG4gICAgICBvbkNoYW5nZShmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChxdWVyeS5pbnN0YW50ICYmICFxdWVyeS5yYW5nZSkge1xuICAgICAgc2V0RXJyb3IoJ0V4ZW1wbGFycyBhcmUgbm90IGF2YWlsYWJsZSBmb3IgaW5zdGFudCBxdWVyaWVzJyk7XG4gICAgICBvbkNoYW5nZShmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgLy8gSWYgZXJyb3IgaXMgY2xlYXJlZCwgd2Ugd2FudCB0byBjaGFuZ2UgZXhlbXBsYXIgdG8gdHJ1ZVxuICAgICAgaWYgKHByZXZFcnJvciAmJiAhZXJyb3IpIHtcbiAgICAgICAgb25DaGFuZ2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbZGF0YXNvdXJjZS5leGVtcGxhcnNBdmFpbGFibGUsIHF1ZXJ5Lmluc3RhbnQsIHF1ZXJ5LnJhbmdlLCBvbkNoYW5nZSwgcHJldkVycm9yLCBlcnJvcl0pO1xuXG4gIGNvbnN0IGljb25CdXR0b25TdHlsZXMgPSBjeChcbiAgICB7XG4gICAgICBbc3R5bGVzLmFjdGl2ZUljb25dOiAhIXF1ZXJ5LmV4ZW1wbGFyLFxuICAgIH0sXG4gICAgc3R5bGVzLmV5ZUljb25cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxJbmxpbmVMYWJlbCB3aWR0aD1cImF1dG9cIiBkYXRhLXRlc3RpZD17cmVzdFsnZGF0YS10ZXN0aWQnXX0+XG4gICAgICA8VG9vbHRpcCBjb250ZW50PXtlcnJvciA/PyAnJ30+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaWNvbldyYXBwZXJ9PlxuICAgICAgICAgIEV4ZW1wbGFyc1xuICAgICAgICAgIDxJY29uQnV0dG9uXG4gICAgICAgICAgICBuYW1lPVwiZXllXCJcbiAgICAgICAgICAgIHRvb2x0aXA9eyEhcXVlcnkuZXhlbXBsYXIgPyAnRGlzYWJsZSBxdWVyeSB3aXRoIGV4ZW1wbGFycycgOiAnRW5hYmxlIHF1ZXJ5IHdpdGggZXhlbXBsYXJzJ31cbiAgICAgICAgICAgIGRpc2FibGVkPXshIWVycm9yfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtpY29uQnV0dG9uU3R5bGVzfVxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICBvbkNoYW5nZSghcXVlcnkuZXhlbXBsYXIpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvVG9vbHRpcD5cbiAgICA8L0lubGluZUxhYmVsPlxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRTdHlsZXModGhlbWU6IEdyYWZhbmFUaGVtZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBleWVJY29uOiBjc3NgXG4gICAgICBtYXJnaW4tbGVmdDogJHt0aGVtZS5zcGFjaW5nKDIpfTtcbiAgICBgLFxuICAgIGFjdGl2ZUljb246IGNzc2BcbiAgICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy5wcmltYXJ5Lm1haW59O1xuICAgIGAsXG4gICAgaWNvbldyYXBwZXI6IGNzc2BcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGAsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IGlzRXF1YWwgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0LCB7IG1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUHJldmlvdXMgfSBmcm9tICdyZWFjdC11c2UnO1xuXG5pbXBvcnQgeyBJbmxpbmVGb3JtTGFiZWwsIFJhZGlvQnV0dG9uR3JvdXAgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFByb21FeGVtcGxhckZpZWxkIH0gZnJvbSAnLi9Qcm9tRXhlbXBsYXJGaWVsZCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbUV4cGxvcmVFeHRyYUZpZWxkUHJvcHMge1xuICBxdWVyeTogUHJvbVF1ZXJ5O1xuICBvbkNoYW5nZTogKHZhbHVlOiBQcm9tUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlO1xufVxuXG5leHBvcnQgY29uc3QgUHJvbUV4cGxvcmVFeHRyYUZpZWxkOiBSZWFjdC5GQzxQcm9tRXhwbG9yZUV4dHJhRmllbGRQcm9wcz4gPSBtZW1vKFxuICAoeyBxdWVyeSwgZGF0YXNvdXJjZSwgb25DaGFuZ2UsIG9uUnVuUXVlcnkgfSkgPT4ge1xuICAgIGNvbnN0IHJhbmdlT3B0aW9ucyA9IGdldFF1ZXJ5VHlwZU9wdGlvbnModHJ1ZSk7XG4gICAgY29uc3QgcHJldlF1ZXJ5ID0gdXNlUHJldmlvdXMocXVlcnkpO1xuXG4gICAgY29uc3Qgb25FeGVtcGxhckNoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGV4ZW1wbGFyOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmICghaXNFcXVhbChxdWVyeSwgcHJldlF1ZXJ5KSB8fCBleGVtcGxhciAhPT0gcXVlcnkuZXhlbXBsYXIpIHtcbiAgICAgICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBleGVtcGxhciB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtwcmV2UXVlcnksIHF1ZXJ5LCBvbkNoYW5nZV1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2VRdWVyeVN0ZXAoaW50ZXJ2YWw6IHN0cmluZykge1xuICAgICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgaW50ZXJ2YWwgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TdGVwQ2hhbmdlKGU6IFJlYWN0LlN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSB7XG4gICAgICBpZiAoZS5jdXJyZW50VGFyZ2V0LnZhbHVlICE9PSBxdWVyeS5pbnRlcnZhbCkge1xuICAgICAgICBvbkNoYW5nZVF1ZXJ5U3RlcChlLmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmV0dXJuS2V5RG93bihlOiBSZWFjdC5LZXlib2FyZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSB7XG4gICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiYgZS5zaGlmdEtleSkge1xuICAgICAgICBvblJ1blF1ZXJ5KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb25RdWVyeVR5cGVDaGFuZ2UgPSBnZXRRdWVyeVR5cGVDaGFuZ2VIYW5kbGVyKHF1ZXJ5LCBvbkNoYW5nZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBhcmlhLWxhYmVsPVwiUHJvbWV0aGV1cyBleHRyYSBmaWVsZFwiIGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCIgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMuZXh0cmFGaWVsZEVkaXRvcn0+XG4gICAgICAgIHsvKlF1ZXJ5IHR5cGUgZmllbGQqL31cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGRhdGEtdGVzdGlkPXt0ZXN0SWRzLnF1ZXJ5VHlwZUZpZWxkfVxuICAgICAgICAgIGNsYXNzTmFtZT17Y3goXG4gICAgICAgICAgICAnZ2YtZm9ybSBleHBsb3JlLWlucHV0LW1hcmdpbicsXG4gICAgICAgICAgICBjc3NgXG4gICAgICAgICAgICAgIGZsZXgtd3JhcDogbm93cmFwO1xuICAgICAgICAgICAgYFxuICAgICAgICAgICl9XG4gICAgICAgICAgYXJpYS1sYWJlbD1cIlF1ZXJ5IHR5cGUgZmllbGRcIlxuICAgICAgICA+XG4gICAgICAgICAgPElubGluZUZvcm1MYWJlbCB3aWR0aD1cImF1dG9cIj5RdWVyeSB0eXBlPC9JbmxpbmVGb3JtTGFiZWw+XG5cbiAgICAgICAgICA8UmFkaW9CdXR0b25Hcm91cFxuICAgICAgICAgICAgb3B0aW9ucz17cmFuZ2VPcHRpb25zfVxuICAgICAgICAgICAgdmFsdWU9e3F1ZXJ5LnJhbmdlICYmIHF1ZXJ5Lmluc3RhbnQgPyAnYm90aCcgOiBxdWVyeS5pbnN0YW50ID8gJ2luc3RhbnQnIDogJ3JhbmdlJ31cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvblF1ZXJ5VHlwZUNoYW5nZX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgey8qU3RlcCBmaWVsZCovfVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMuc3RlcEZpZWxkfVxuICAgICAgICAgIGNsYXNzTmFtZT17Y3goXG4gICAgICAgICAgICAnZ2YtZm9ybScsXG4gICAgICAgICAgICBjc3NgXG4gICAgICAgICAgICAgIGZsZXgtd3JhcDogbm93cmFwO1xuICAgICAgICAgICAgYFxuICAgICAgICAgICl9XG4gICAgICAgICAgYXJpYS1sYWJlbD1cIlN0ZXAgZmllbGRcIlxuICAgICAgICA+XG4gICAgICAgICAgPElubGluZUZvcm1MYWJlbFxuICAgICAgICAgICAgd2lkdGg9ezZ9XG4gICAgICAgICAgICB0b29sdGlwPXtcbiAgICAgICAgICAgICAgJ1RpbWUgdW5pdHMgYW5kIGJ1aWx0LWluIHZhcmlhYmxlcyBjYW4gYmUgdXNlZCBoZXJlLCBmb3IgZXhhbXBsZTogJF9faW50ZXJ2YWwsICRfX3JhdGVfaW50ZXJ2YWwsIDVzLCAxbSwgM2gsIDFkLCAxeSAoRGVmYXVsdCBpZiBubyB1bml0IGlzIHNwZWNpZmllZDogcyknXG4gICAgICAgICAgICB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgTWluIHN0ZXBcbiAgICAgICAgICA8L0lubGluZUZvcm1MYWJlbD5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHR5cGU9eyd0ZXh0J31cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImdmLWZvcm0taW5wdXQgd2lkdGgtNFwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17J2F1dG8nfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uU3RlcENoYW5nZX1cbiAgICAgICAgICAgIG9uS2V5RG93bj17b25SZXR1cm5LZXlEb3dufVxuICAgICAgICAgICAgdmFsdWU9e3F1ZXJ5LmludGVydmFsID8/ICcnfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxQcm9tRXhlbXBsYXJGaWVsZCBvbkNoYW5nZT17b25FeGVtcGxhckNoYW5nZX0gZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX0gcXVlcnk9e3F1ZXJ5fSAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuKTtcblxuUHJvbUV4cGxvcmVFeHRyYUZpZWxkLmRpc3BsYXlOYW1lID0gJ1Byb21FeHBsb3JlRXh0cmFGaWVsZCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWVyeVR5cGVPcHRpb25zKGluY2x1ZGVCb3RoOiBib29sZWFuKSB7XG4gIGNvbnN0IHJhbmdlT3B0aW9ucyA9IFtcbiAgICB7IHZhbHVlOiAncmFuZ2UnLCBsYWJlbDogJ1JhbmdlJywgZGVzY3JpcHRpb246ICdSdW4gcXVlcnkgb3ZlciBhIHJhbmdlIG9mIHRpbWUnIH0sXG4gICAge1xuICAgICAgdmFsdWU6ICdpbnN0YW50JyxcbiAgICAgIGxhYmVsOiAnSW5zdGFudCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ1J1biBxdWVyeSBhZ2FpbnN0IGEgc2luZ2xlIHBvaW50IGluIHRpbWUuIEZvciB0aGlzIHF1ZXJ5LCB0aGUgXCJUb1wiIHRpbWUgaXMgdXNlZCcsXG4gICAgfSxcbiAgXTtcblxuICBpZiAoaW5jbHVkZUJvdGgpIHtcbiAgICByYW5nZU9wdGlvbnMucHVzaCh7IHZhbHVlOiAnYm90aCcsIGxhYmVsOiAnQm90aCcsIGRlc2NyaXB0aW9uOiAnUnVuIGFuIEluc3RhbnQgcXVlcnkgYW5kIGEgUmFuZ2UgcXVlcnknIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlT3B0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFF1ZXJ5VHlwZUNoYW5nZUhhbmRsZXIocXVlcnk6IFByb21RdWVyeSwgb25DaGFuZ2U6ICh1cGRhdGU6IFByb21RdWVyeSkgPT4gdm9pZCkge1xuICByZXR1cm4gKHF1ZXJ5VHlwZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHF1ZXJ5VHlwZSA9PT0gJ2luc3RhbnQnKSB7XG4gICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBpbnN0YW50OiB0cnVlLCByYW5nZTogZmFsc2UsIGV4ZW1wbGFyOiBmYWxzZSB9KTtcbiAgICB9IGVsc2UgaWYgKHF1ZXJ5VHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgaW5zdGFudDogZmFsc2UsIHJhbmdlOiB0cnVlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBpbnN0YW50OiB0cnVlLCByYW5nZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCB0ZXN0SWRzID0ge1xuICBleHRyYUZpZWxkRWRpdG9yOiAncHJvbS1lZGl0b3ItZXh0cmEtZmllbGQnLFxuICBzdGVwRmllbGQ6ICdwcm9tLWVkaXRvci1leHRyYS1maWVsZC1zdGVwJyxcbiAgcXVlcnlUeXBlRmllbGQ6ICdwcm9tLWVkaXRvci1leHRyYS1maWVsZC1xdWVyeS10eXBlJyxcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgbWVtbywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBRdWVyeUVkaXRvclByb3BzLCBDb3JlQXBwIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnksIFByb21PcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBQcm9tRXhwbG9yZUV4dHJhRmllbGQgfSBmcm9tICcuL1Byb21FeHBsb3JlRXh0cmFGaWVsZCc7XG5pbXBvcnQgUHJvbVF1ZXJ5RmllbGQgZnJvbSAnLi9Qcm9tUXVlcnlGaWVsZCc7XG5cbmV4cG9ydCB0eXBlIFByb3BzID0gUXVlcnlFZGl0b3JQcm9wczxQcm9tZXRoZXVzRGF0YXNvdXJjZSwgUHJvbVF1ZXJ5LCBQcm9tT3B0aW9ucz47XG5cbmV4cG9ydCBjb25zdCBQcm9tRXhwbG9yZVF1ZXJ5RWRpdG9yID0gbWVtbygocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgcmFuZ2UsIHF1ZXJ5LCBkYXRhLCBkYXRhc291cmNlLCBoaXN0b3J5LCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9ID0gcHJvcHM7XG5cbiAgLy8gU2V0dGluZyBkZWZhdWx0IHZhbHVlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChxdWVyeS5leHByID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGV4cHI6ICcnIH0pO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZXhlbXBsYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgZXhlbXBsYXI6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgcXVlcnkgdHlwZSB0byBcIkJvdGhcIiBvbmx5IGZvciBuZXcgcXVlcmllcyAobm8gcXVlcnkuZXhwcikuXG4gICAgaWYgKCFxdWVyeS5pbnN0YW50ICYmICFxdWVyeS5yYW5nZSAmJiAhcXVlcnkuZXhwcikge1xuICAgICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgaW5zdGFudDogdHJ1ZSwgcmFuZ2U6IHRydWUgfSk7XG4gICAgfVxuICB9LCBbb25DaGFuZ2UsIHF1ZXJ5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8UHJvbVF1ZXJ5RmllbGRcbiAgICAgIGFwcD17Q29yZUFwcC5FeHBsb3JlfVxuICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgIHJhbmdlPXtyYW5nZX1cbiAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICBvbkJsdXI9eygpID0+IHt9fVxuICAgICAgaGlzdG9yeT17aGlzdG9yeX1cbiAgICAgIGRhdGE9e2RhdGF9XG4gICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5lZGl0b3J9XG4gICAgICBFeHRyYUZpZWxkRWxlbWVudD17XG4gICAgICAgIDxQcm9tRXhwbG9yZUV4dHJhRmllbGQgcXVlcnk9e3F1ZXJ5fSBvbkNoYW5nZT17b25DaGFuZ2V9IGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9IG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9IC8+XG4gICAgICB9XG4gICAgLz5cbiAgKTtcbn0pO1xuXG5Qcm9tRXhwbG9yZVF1ZXJ5RWRpdG9yLmRpc3BsYXlOYW1lID0gJ1Byb21FeHBsb3JlUXVlcnlFZGl0b3InO1xuXG5leHBvcnQgY29uc3QgdGVzdElkcyA9IHtcbiAgZWRpdG9yOiAncHJvbS1lZGl0b3ItZXhwbG9yZScsXG59O1xuIiwiaW1wb3J0IHsgbWFwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCwgeyBGQywgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgbWVtbyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRGF0YVF1ZXJ5UmVxdWVzdCwgUGFuZWxEYXRhLCBTY29wZWRWYXJzLCB0ZXh0VXRpbCwgcmFuZ2VVdGlsIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gIGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlO1xuICBxdWVyeTogUHJvbVF1ZXJ5O1xuICBwYW5lbERhdGE/OiBQYW5lbERhdGE7XG59XG5cbmNvbnN0IFByb21MaW5rOiBGQzxQcm9wcz4gPSAoeyBwYW5lbERhdGEsIHF1ZXJ5LCBkYXRhc291cmNlIH0pID0+IHtcbiAgY29uc3QgW2hyZWYsIHNldEhyZWZdID0gdXNlU3RhdGUoJycpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHBhbmVsRGF0YSkge1xuICAgICAgY29uc3QgZ2V0RXh0ZXJuYWxMaW5rID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXBhbmVsRGF0YS5yZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlcXVlc3Q6IHsgcmFuZ2UsIGludGVydmFsLCBzY29wZWRWYXJzIH0sXG4gICAgICAgIH0gPSBwYW5lbERhdGE7XG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBkYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHJhbmdlLmZyb20sIGZhbHNlKTtcbiAgICAgICAgY29uc3QgZW5kID0gZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZShyYW5nZS50bywgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHJhbmdlRGlmZiA9IE1hdGguY2VpbChlbmQgLSBzdGFydCk7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSByYW5nZS50by51dGMoKS5mb3JtYXQoJ1lZWVktTU0tREQgSEg6bW0nKTtcblxuICAgICAgICBjb25zdCBlbnJpY2hlZFNjb3BlZFZhcnM6IFNjb3BlZFZhcnMgPSB7XG4gICAgICAgICAgLi4uc2NvcGVkVmFycyxcbiAgICAgICAgICAvLyBBcyB3ZSBzdXBwb3J0ICRfX3JhdGVfaW50ZXJ2YWwgdmFyaWFibGUgaW4gbWluIHN0ZXAsIHdlIG5lZWQgYWRkIGl0IHRvIHNjb3BlZFZhcnNcbiAgICAgICAgICAuLi5kYXRhc291cmNlLmdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlKFxuICAgICAgICAgICAgcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKGludGVydmFsKSxcbiAgICAgICAgICAgIHJhbmdlVXRpbC5pbnRlcnZhbFRvU2Vjb25kcyhkYXRhc291cmNlLmludGVydmFsKVxuICAgICAgICAgICksXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBpbnRlcnZhbCxcbiAgICAgICAgICBzY29wZWRWYXJzOiBlbnJpY2hlZFNjb3BlZFZhcnMsXG4gICAgICAgIH0gYXMgRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+O1xuXG4gICAgICAgIGNvbnN0IGN1c3RvbVF1ZXJ5UGFyYW1ldGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICAgICAgICBpZiAoZGF0YXNvdXJjZS5jdXN0b21RdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBkYXRhc291cmNlLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgICAgICAgY3VzdG9tUXVlcnlQYXJhbWV0ZXJzW2tdID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSBkYXRhc291cmNlLmNyZWF0ZVF1ZXJ5KHF1ZXJ5LCBvcHRpb25zLCBzdGFydCwgZW5kKTtcblxuICAgICAgICBjb25zdCBleHByID0ge1xuICAgICAgICAgIC4uLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAnZzAuZXhwcic6IHF1ZXJ5T3B0aW9ucy5leHByLFxuICAgICAgICAgICdnMC5yYW5nZV9pbnB1dCc6IHJhbmdlRGlmZiArICdzJyxcbiAgICAgICAgICAnZzAuZW5kX2lucHV0JzogZW5kVGltZSxcbiAgICAgICAgICAnZzAuc3RlcF9pbnB1dCc6IHF1ZXJ5T3B0aW9ucy5zdGVwLFxuICAgICAgICAgICdnMC50YWInOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBtYXAoZXhwciwgKHY6IHN0cmluZywgazogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGsgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodik7XG4gICAgICAgIH0pLmpvaW4oJyYnKTtcbiAgICAgICAgcmV0dXJuIGAke2RhdGFzb3VyY2UuZGlyZWN0VXJsfS9ncmFwaD8ke2FyZ3N9YDtcbiAgICAgIH07XG5cbiAgICAgIHNldEhyZWYoZ2V0RXh0ZXJuYWxMaW5rKCkpO1xuICAgIH1cbiAgfSwgW2RhdGFzb3VyY2UsIHBhbmVsRGF0YSwgcXVlcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxhIGhyZWY9e3RleHRVdGlsLnNhbml0aXplVXJsKGhyZWYpfSB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCI+XG4gICAgICBQcm9tZXRoZXVzXG4gICAgPC9hPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWVtbyhQcm9tTGluayk7XG4iLCJpbXBvcnQgeyBtYXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbi8vIFR5cGVzXG5pbXBvcnQgeyBDb3JlQXBwLCBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IElubGluZUZvcm1MYWJlbCwgTGVnYWN5Rm9ybXMsIFNlbGVjdCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUHJvbVF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBQcm9tRXhlbXBsYXJGaWVsZCB9IGZyb20gJy4vUHJvbUV4ZW1wbGFyRmllbGQnO1xuaW1wb3J0IFByb21MaW5rIGZyb20gJy4vUHJvbUxpbmsnO1xuaW1wb3J0IFByb21RdWVyeUZpZWxkIGZyb20gJy4vUHJvbVF1ZXJ5RmllbGQnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5RWRpdG9yUHJvcHMgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgeyBTd2l0Y2ggfSA9IExlZ2FjeUZvcm1zO1xuXG5leHBvcnQgY29uc3QgRk9STUFUX09QVElPTlM6IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+PiA9IFtcbiAgeyBsYWJlbDogJ1RpbWUgc2VyaWVzJywgdmFsdWU6ICd0aW1lX3NlcmllcycgfSxcbiAgeyBsYWJlbDogJ1RhYmxlJywgdmFsdWU6ICd0YWJsZScgfSxcbiAgeyBsYWJlbDogJ0hlYXRtYXAnLCB2YWx1ZTogJ2hlYXRtYXAnIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgSU5URVJWQUxfRkFDVE9SX09QVElPTlM6IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxudW1iZXI+PiA9IG1hcChbMSwgMiwgMywgNCwgNSwgMTBdLCAodmFsdWU6IG51bWJlcikgPT4gKHtcbiAgdmFsdWUsXG4gIGxhYmVsOiAnMS8nICsgdmFsdWUsXG59KSk7XG5cbmludGVyZmFjZSBTdGF0ZSB7XG4gIGxlZ2VuZEZvcm1hdD86IHN0cmluZztcbiAgZm9ybWF0T3B0aW9uOiBTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPjtcbiAgaW50ZXJ2YWw/OiBzdHJpbmc7XG4gIGludGVydmFsRmFjdG9yT3B0aW9uOiBTZWxlY3RhYmxlVmFsdWU8bnVtYmVyPjtcbiAgaW5zdGFudDogYm9vbGVhbjtcbiAgZXhlbXBsYXI6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9tUXVlcnlFZGl0b3IgZXh0ZW5kcyBQdXJlQ29tcG9uZW50PFByb21RdWVyeUVkaXRvclByb3BzLCBTdGF0ZT4ge1xuICAvLyBRdWVyeSB0YXJnZXQgdG8gYmUgbW9kaWZpZWQgYW5kIHVzZWQgZm9yIHF1ZXJpZXNcbiAgcXVlcnk6IFByb21RdWVyeTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvbVF1ZXJ5RWRpdG9yUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgLy8gVXNlIGRlZmF1bHQgcXVlcnkgdG8gcHJldmVudCB1bmRlZmluZWQgaW5wdXQgdmFsdWVzXG4gICAgY29uc3QgZGVmYXVsdFF1ZXJ5OiBQYXJ0aWFsPFByb21RdWVyeT4gPSB7XG4gICAgICBleHByOiAnJyxcbiAgICAgIGxlZ2VuZEZvcm1hdDogJycsXG4gICAgICBpbnRlcnZhbDogJycsXG4gICAgICAvLyBTZXQgZXhlbXBsYXIgdG8gZmFsc2UgZm9yIGFsZXJ0aW5nIHF1ZXJpZXNcbiAgICAgIGV4ZW1wbGFyOiBwcm9wcy5hcHAgPT09IENvcmVBcHAuVW5pZmllZEFsZXJ0aW5nID8gZmFsc2UgOiB0cnVlLFxuICAgIH07XG4gICAgY29uc3QgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UXVlcnksIHByb3BzLnF1ZXJ5KTtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgLy8gUXVlcnkgdGFyZ2V0IHByb3BlcnRpZXMgdGhhdCBhcmUgZnVsbHkgY29udHJvbGxlZCBpbnB1dHNcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLy8gRnVsbHkgY29udHJvbGxlZCB0ZXh0IGlucHV0c1xuICAgICAgaW50ZXJ2YWw6IHF1ZXJ5LmludGVydmFsLFxuICAgICAgbGVnZW5kRm9ybWF0OiBxdWVyeS5sZWdlbmRGb3JtYXQsXG4gICAgICAvLyBTZWxlY3Qgb3B0aW9uc1xuICAgICAgZm9ybWF0T3B0aW9uOiBGT1JNQVRfT1BUSU9OUy5maW5kKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSA9PT0gcXVlcnkuZm9ybWF0KSB8fCBGT1JNQVRfT1BUSU9OU1swXSxcbiAgICAgIGludGVydmFsRmFjdG9yT3B0aW9uOlxuICAgICAgICBJTlRFUlZBTF9GQUNUT1JfT1BUSU9OUy5maW5kKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSA9PT0gcXVlcnkuaW50ZXJ2YWxGYWN0b3IpIHx8IElOVEVSVkFMX0ZBQ1RPUl9PUFRJT05TWzBdLFxuICAgICAgLy8gU3dpdGNoIG9wdGlvbnNcbiAgICAgIGluc3RhbnQ6IEJvb2xlYW4ocXVlcnkuaW5zdGFudCksXG4gICAgICBleGVtcGxhcjogQm9vbGVhbihxdWVyeS5leGVtcGxhciksXG4gICAgfTtcbiAgfVxuXG4gIG9uRmllbGRDaGFuZ2UgPSAocXVlcnk6IFByb21RdWVyeSwgb3ZlcnJpZGU/OiBhbnkpID0+IHtcbiAgICB0aGlzLnF1ZXJ5LmV4cHIgPSBxdWVyeS5leHByO1xuICB9O1xuXG4gIG9uRm9ybWF0Q2hhbmdlID0gKG9wdGlvbjogU2VsZWN0YWJsZVZhbHVlPHN0cmluZz4pID0+IHtcbiAgICB0aGlzLnF1ZXJ5LmZvcm1hdCA9IG9wdGlvbi52YWx1ZTtcbiAgICB0aGlzLnNldFN0YXRlKHsgZm9ybWF0T3B0aW9uOiBvcHRpb24gfSwgdGhpcy5vblJ1blF1ZXJ5KTtcbiAgfTtcblxuICBvbkluc3RhbnRDaGFuZ2UgPSAoZTogUmVhY3QuU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCBpbnN0YW50ID0gKGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQ7XG4gICAgdGhpcy5xdWVyeS5pbnN0YW50ID0gaW5zdGFudDtcbiAgICB0aGlzLnNldFN0YXRlKHsgaW5zdGFudCB9LCB0aGlzLm9uUnVuUXVlcnkpO1xuICB9O1xuXG4gIG9uSW50ZXJ2YWxDaGFuZ2UgPSAoZTogUmVhY3QuU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IGUuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICB0aGlzLnF1ZXJ5LmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGludGVydmFsIH0pO1xuICB9O1xuXG4gIG9uSW50ZXJ2YWxGYWN0b3JDaGFuZ2UgPSAob3B0aW9uOiBTZWxlY3RhYmxlVmFsdWU8bnVtYmVyPikgPT4ge1xuICAgIHRoaXMucXVlcnkuaW50ZXJ2YWxGYWN0b3IgPSBvcHRpb24udmFsdWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGludGVydmFsRmFjdG9yT3B0aW9uOiBvcHRpb24gfSwgdGhpcy5vblJ1blF1ZXJ5KTtcbiAgfTtcblxuICBvbkxlZ2VuZENoYW5nZSA9IChlOiBSZWFjdC5TeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGxlZ2VuZEZvcm1hdCA9IGUuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICB0aGlzLnF1ZXJ5LmxlZ2VuZEZvcm1hdCA9IGxlZ2VuZEZvcm1hdDtcbiAgICB0aGlzLnNldFN0YXRlKHsgbGVnZW5kRm9ybWF0IH0pO1xuICB9O1xuXG4gIG9uRXhlbXBsYXJDaGFuZ2UgPSAoaXNFbmFibGVkOiBib29sZWFuKSA9PiB7XG4gICAgdGhpcy5xdWVyeS5leGVtcGxhciA9IGlzRW5hYmxlZDtcbiAgICB0aGlzLnNldFN0YXRlKHsgZXhlbXBsYXI6IGlzRW5hYmxlZCB9LCB0aGlzLm9uUnVuUXVlcnkpO1xuICB9O1xuXG4gIG9uUnVuUXVlcnkgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBxdWVyeSB9ID0gdGhpcztcbiAgICAvLyBDaGFuZ2Ugb2YgcXVlcnkuaGlkZSBoYXBwZW5zIG91dHNpZGUgb2YgdGhpcyBjb21wb25lbnQgYW5kIGlzIGp1c3QgcGFzc2VkIGFzIHByb3AuIFdlIGhhdmUgdG8gdXBkYXRlIGl0IHdoZW4gcnVubmluZyBxdWVyaWVzLlxuICAgIGNvbnN0IHsgaGlkZSB9ID0gdGhpcy5wcm9wcy5xdWVyeTtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHsgLi4ucXVlcnksIGhpZGUgfSk7XG4gICAgdGhpcy5wcm9wcy5vblJ1blF1ZXJ5KCk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZGF0YXNvdXJjZSwgcXVlcnksIHJhbmdlLCBkYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZm9ybWF0T3B0aW9uLCBpbnN0YW50LCBpbnRlcnZhbCwgaW50ZXJ2YWxGYWN0b3JPcHRpb24sIGxlZ2VuZEZvcm1hdCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAvL1dlIHdhbnQgdG8gaGlkZSBleGVtcGxhciBmaWVsZCBmb3IgdW5pZmllZCBhbGVydGluZyBhcyBleGVtcGxhcnMgaW4gYWxlcnRpbmcgZG9uJ3QgbWFrZSBzZW5zZSBhbmQgYXJlIHNvdXJjZSBvZiBjb25mdXNpb25cbiAgICBjb25zdCBzaG93RXhlbXBsYXJGaWVsZCA9IHRoaXMucHJvcHMuYXBwICE9PSBDb3JlQXBwLlVuaWZpZWRBbGVydGluZztcblxuICAgIHJldHVybiAoXG4gICAgICA8UHJvbVF1ZXJ5RmllbGRcbiAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICByYW5nZT17cmFuZ2V9XG4gICAgICAgIG9uUnVuUXVlcnk9e3RoaXMub25SdW5RdWVyeX1cbiAgICAgICAgb25DaGFuZ2U9e3RoaXMub25GaWVsZENoYW5nZX1cbiAgICAgICAgaGlzdG9yeT17W119XG4gICAgICAgIGRhdGE9e2RhdGF9XG4gICAgICAgIGRhdGEtdGVzdGlkPXt0ZXN0SWRzLmVkaXRvcn1cbiAgICAgICAgRXh0cmFGaWVsZEVsZW1lbnQ9e1xuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsXG4gICAgICAgICAgICAgICAgd2lkdGg9ezd9XG4gICAgICAgICAgICAgICAgdG9vbHRpcD1cIkNvbnRyb2xzIHRoZSBuYW1lIG9mIHRoZSB0aW1lIHNlcmllcywgdXNpbmcgbmFtZSBvciBwYXR0ZXJuLiBGb3IgZXhhbXBsZVxuICAgICAgICB7e2hvc3RuYW1lfX0gd2lsbCBiZSByZXBsYWNlZCB3aXRoIGxhYmVsIHZhbHVlIGZvciB0aGUgbGFiZWwgaG9zdG5hbWUuXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIExlZ2VuZFxuICAgICAgICAgICAgICA8L0lubGluZUZvcm1MYWJlbD5cbiAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdmLWZvcm0taW5wdXRcIlxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwibGVnZW5kIGZvcm1hdFwiXG4gICAgICAgICAgICAgICAgdmFsdWU9e2xlZ2VuZEZvcm1hdH1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkxlZ2VuZENoYW5nZX1cbiAgICAgICAgICAgICAgICBvbkJsdXI9e3RoaXMub25SdW5RdWVyeX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgPElubGluZUZvcm1MYWJlbFxuICAgICAgICAgICAgICAgIHdpZHRoPXs3fVxuICAgICAgICAgICAgICAgIHRvb2x0aXA9e1xuICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgQW4gYWRkaXRpb25hbCBsb3dlciBsaW1pdCBmb3IgdGhlIHN0ZXAgcGFyYW1ldGVyIG9mIHRoZSBQcm9tZXRoZXVzIHF1ZXJ5IGFuZCBmb3IgdGhleycgJ31cbiAgICAgICAgICAgICAgICAgICAgPGNvZGU+JF9faW50ZXJ2YWw8L2NvZGU+IGFuZCA8Y29kZT4kX19yYXRlX2ludGVydmFsPC9jb2RlPiB2YXJpYWJsZXMuIFRoZSBsaW1pdCBpcyBhYnNvbHV0ZSBhbmQgbm90XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkIGJ5IHRoZSAmcXVvdDtSZXNvbHV0aW9uJnF1b3Q7IHNldHRpbmcuXG4gICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBNaW4gc3RlcFxuICAgICAgICAgICAgICA8L0lubGluZUZvcm1MYWJlbD5cbiAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdmLWZvcm0taW5wdXQgd2lkdGgtOFwiXG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlNldCBsb3dlciBsaW1pdCBmb3IgdGhlIHN0ZXAgcGFyYW1ldGVyXCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17aW50ZXJ2YWx9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25JbnRlcnZhbENoYW5nZX1cbiAgICAgICAgICAgICAgICBvbkJsdXI9e3RoaXMub25SdW5RdWVyeX1cbiAgICAgICAgICAgICAgICB2YWx1ZT17aW50ZXJ2YWx9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1sYWJlbFwiPlJlc29sdXRpb248L2Rpdj5cbiAgICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJTZWxlY3QgcmVzb2x1dGlvblwiXG4gICAgICAgICAgICAgICAgaXNTZWFyY2hhYmxlPXtmYWxzZX1cbiAgICAgICAgICAgICAgICBvcHRpb25zPXtJTlRFUlZBTF9GQUNUT1JfT1BUSU9OU31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkludGVydmFsRmFjdG9yQ2hhbmdlfVxuICAgICAgICAgICAgICAgIHZhbHVlPXtpbnRlcnZhbEZhY3Rvck9wdGlvbn1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWxhYmVsIHdpZHRoLTdcIj5Gb3JtYXQ8L2Rpdj5cbiAgICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInNlbGVjdC1jb250YWluZXJcIlxuICAgICAgICAgICAgICAgIHdpZHRoPXsxNn1cbiAgICAgICAgICAgICAgICBpc1NlYXJjaGFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgICAgIG9wdGlvbnM9e0ZPUk1BVF9PUFRJT05TfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uRm9ybWF0Q2hhbmdlfVxuICAgICAgICAgICAgICAgIHZhbHVlPXtmb3JtYXRPcHRpb259XG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlNlbGVjdCBmb3JtYXRcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8U3dpdGNoIGxhYmVsPVwiSW5zdGFudFwiIGNoZWNrZWQ9e2luc3RhbnR9IG9uQ2hhbmdlPXt0aGlzLm9uSW5zdGFudENoYW5nZX0gLz5cblxuICAgICAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsIHdpZHRoPXsxMH0gdG9vbHRpcD1cIkxpbmsgdG8gR3JhcGggaW4gUHJvbWV0aGV1c1wiPlxuICAgICAgICAgICAgICAgIDxQcm9tTGlua1xuICAgICAgICAgICAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgICAgICAgICAgICAgIHF1ZXJ5PXt0aGlzLnF1ZXJ5fSAvLyBVc2UgbW9kaWZpZWQgcXVlcnlcbiAgICAgICAgICAgICAgICAgIHBhbmVsRGF0YT17ZGF0YX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L0lubGluZUZvcm1MYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge3Nob3dFeGVtcGxhckZpZWxkICYmIChcbiAgICAgICAgICAgICAgPFByb21FeGVtcGxhckZpZWxkXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25FeGVtcGxhckNoYW5nZX1cbiAgICAgICAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgICAgICAgIHF1ZXJ5PXt0aGlzLnF1ZXJ5fVxuICAgICAgICAgICAgICAgIGRhdGEtdGVzdGlkPXt0ZXN0SWRzLmV4ZW1wbGFyfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgfVxuICAgICAgLz5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0ZXN0SWRzID0ge1xuICBlZGl0b3I6ICdwcm9tLWVkaXRvcicsXG4gIGV4ZW1wbGFyOiAnZXhlbXBsYXItZWRpdG9yJyxcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgQ29yZUFwcCB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5cbmltcG9ydCB7IFByb21RdWVyeUVkaXRvclNlbGVjdG9yIH0gZnJvbSAnLi4vcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvUHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3InO1xuXG5pbXBvcnQgeyBQcm9tRXhwbG9yZVF1ZXJ5RWRpdG9yIH0gZnJvbSAnLi9Qcm9tRXhwbG9yZVF1ZXJ5RWRpdG9yJztcbmltcG9ydCB7IFByb21RdWVyeUVkaXRvciB9IGZyb20gJy4vUHJvbVF1ZXJ5RWRpdG9yJztcbmltcG9ydCB7IFByb21RdWVyeUVkaXRvckZvckFsZXJ0aW5nIH0gZnJvbSAnLi9Qcm9tUXVlcnlFZGl0b3JGb3JBbGVydGluZyc7XG5pbXBvcnQgeyBQcm9tUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gUHJvbVF1ZXJ5RWRpdG9yQnlBcHAocHJvcHM6IFByb21RdWVyeUVkaXRvclByb3BzKSB7XG4gIGNvbnN0IHsgYXBwIH0gPSBwcm9wcztcblxuICBzd2l0Y2ggKGFwcCkge1xuICAgIGNhc2UgQ29yZUFwcC5DbG91ZEFsZXJ0aW5nOlxuICAgICAgcmV0dXJuIDxQcm9tUXVlcnlFZGl0b3JGb3JBbGVydGluZyB7Li4ucHJvcHN9IC8+O1xuICAgIGNhc2UgQ29yZUFwcC5FeHBsb3JlOlxuICAgICAgaWYgKGNvbmZpZy5mZWF0dXJlVG9nZ2xlcy5wcm9tUXVlcnlCdWlsZGVyKSB7XG4gICAgICAgIHJldHVybiA8UHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3Igey4uLnByb3BzfSAvPjtcbiAgICAgIH1cbiAgICAgIHJldHVybiA8UHJvbUV4cGxvcmVRdWVyeUVkaXRvciB7Li4ucHJvcHN9IC8+O1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY29uZmlnLmZlYXR1cmVUb2dnbGVzLnByb21RdWVyeUJ1aWxkZXIpIHtcbiAgICAgICAgcmV0dXJuIDxQcm9tUXVlcnlFZGl0b3JTZWxlY3RvciB7Li4ucHJvcHN9IC8+O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDxQcm9tUXVlcnlFZGl0b3Igey4uLnByb3BzfSAvPjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vKFByb21RdWVyeUVkaXRvckJ5QXBwKTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBQcm9tUXVlcnlGaWVsZCBmcm9tICcuL1Byb21RdWVyeUZpZWxkJztcbmltcG9ydCB7IFByb21RdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm9tUXVlcnlFZGl0b3JGb3JBbGVydGluZyhwcm9wczogUHJvbVF1ZXJ5RWRpdG9yUHJvcHMpIHtcbiAgY29uc3QgeyBkYXRhc291cmNlLCBxdWVyeSwgcmFuZ2UsIGRhdGEsIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0gPSBwcm9wcztcblxuICByZXR1cm4gKFxuICAgIDxQcm9tUXVlcnlGaWVsZFxuICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICBoaXN0b3J5PXtbXX1cbiAgICAgIHJhbmdlPXtyYW5nZX1cbiAgICAgIGRhdGE9e2RhdGF9XG4gICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5lZGl0b3J9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IHRlc3RJZHMgPSB7XG4gIGVkaXRvcjogJ3Byb20tZWRpdG9yLWNsb3VkLWFsZXJ0aW5nJyxcbn07XG4iLCJpbXBvcnQgeyBMYW5ndWFnZU1hcCwgbGFuZ3VhZ2VzIGFzIHByaXNtTGFuZ3VhZ2VzIH0gZnJvbSAncHJpc21qcyc7XG5pbXBvcnQgUmVhY3QsIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnc2xhdGUnO1xuXG5pbXBvcnQgeyBRdWVyeUVkaXRvclByb3BzLCBRdWVyeUhpbnQsIGlzRGF0YUZyYW1lLCB0b0xlZ2FjeVJlc3BvbnNlRGF0YSwgVGltZVJhbmdlLCBDb3JlQXBwIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQge1xuICBTbGF0ZVByaXNtLFxuICBUeXBlYWhlYWRJbnB1dCxcbiAgVHlwZWFoZWFkT3V0cHV0LFxuICBCcmFjZXNQbHVnaW4sXG4gIERPTVV0aWwsXG4gIFN1Z2dlc3Rpb25zU3RhdGUsXG4gIEljb24sXG59IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXIgfSBmcm9tICdhcHAvY29yZS9jb21wb25lbnRzL0xvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXInO1xuaW1wb3J0IHtcbiAgQ2FuY2VsYWJsZVByb21pc2UsXG4gIGlzQ2FuY2VsYWJsZVByb21pc2VSZWplY3Rpb24sXG4gIG1ha2VQcm9taXNlQ2FuY2VsYWJsZSxcbn0gZnJvbSAnYXBwL2NvcmUvdXRpbHMvQ2FuY2VsYWJsZVByb21pc2UnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgcm91bmRNc1RvTWluIH0gZnJvbSAnLi4vbGFuZ3VhZ2VfdXRpbHMnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5LCBQcm9tT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c01ldHJpY3NCcm93c2VyIH0gZnJvbSAnLi9Qcm9tZXRoZXVzTWV0cmljc0Jyb3dzZXInO1xuaW1wb3J0IHsgTW9uYWNvUXVlcnlGaWVsZFdyYXBwZXIgfSBmcm9tICcuL21vbmFjby1xdWVyeS1maWVsZC9Nb25hY29RdWVyeUZpZWxkV3JhcHBlcic7XG5cbmV4cG9ydCBjb25zdCBSRUNPUkRJTkdfUlVMRVNfR1JPVVAgPSAnX19yZWNvcmRpbmdfcnVsZXNfXyc7XG5jb25zdCBMQVNUX1VTRURfTEFCRUxTX0tFWSA9ICdncmFmYW5hLmRhdGFzb3VyY2VzLnByb21ldGhldXMuYnJvd3Nlci5sYWJlbHMnO1xuXG5mdW5jdGlvbiBnZXRDaG9vc2VyVGV4dChtZXRyaWNzTG9va3VwRGlzYWJsZWQ6IGJvb2xlYW4sIGhhc1N5bnRheDogYm9vbGVhbiwgaGFzTWV0cmljczogYm9vbGVhbikge1xuICBpZiAobWV0cmljc0xvb2t1cERpc2FibGVkKSB7XG4gICAgcmV0dXJuICcoRGlzYWJsZWQpJztcbiAgfVxuXG4gIGlmICghaGFzU3ludGF4KSB7XG4gICAgcmV0dXJuICdMb2FkaW5nIG1ldHJpY3MuLi4nO1xuICB9XG5cbiAgaWYgKCFoYXNNZXRyaWNzKSB7XG4gICAgcmV0dXJuICcoTm8gbWV0cmljcyBmb3VuZCknO1xuICB9XG5cbiAgcmV0dXJuICdNZXRyaWNzIGJyb3dzZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2lsbEFwcGx5U3VnZ2VzdGlvbihzdWdnZXN0aW9uOiBzdHJpbmcsIHsgdHlwZWFoZWFkQ29udGV4dCwgdHlwZWFoZWFkVGV4dCB9OiBTdWdnZXN0aW9uc1N0YXRlKTogc3RyaW5nIHtcbiAgLy8gTW9kaWZ5IHN1Z2dlc3Rpb24gYmFzZWQgb24gY29udGV4dFxuICBzd2l0Y2ggKHR5cGVhaGVhZENvbnRleHQpIHtcbiAgICBjYXNlICdjb250ZXh0LWxhYmVscyc6IHtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gRE9NVXRpbC5nZXROZXh0Q2hhcmFjdGVyKCk7XG4gICAgICBpZiAoIW5leHRDaGFyIHx8IG5leHRDaGFyID09PSAnfScgfHwgbmV4dENoYXIgPT09ICcsJykge1xuICAgICAgICBzdWdnZXN0aW9uICs9ICc9JztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ2NvbnRleHQtbGFiZWwtdmFsdWVzJzoge1xuICAgICAgLy8gQWx3YXlzIGFkZCBxdW90ZXMgYW5kIHJlbW92ZSBleGlzdGluZyBvbmVzIGluc3RlYWRcbiAgICAgIGlmICghdHlwZWFoZWFkVGV4dC5tYXRjaCgvXighPz1+P1wifFwiKS8pKSB7XG4gICAgICAgIHN1Z2dlc3Rpb24gPSBgXCIke3N1Z2dlc3Rpb259YDtcbiAgICAgIH1cbiAgICAgIGlmIChET01VdGlsLmdldE5leHRDaGFyYWN0ZXIoKSAhPT0gJ1wiJykge1xuICAgICAgICBzdWdnZXN0aW9uID0gYCR7c3VnZ2VzdGlvbn1cImA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OlxuICB9XG4gIHJldHVybiBzdWdnZXN0aW9uO1xufVxuXG5pbnRlcmZhY2UgUHJvbVF1ZXJ5RmllbGRQcm9wcyBleHRlbmRzIFF1ZXJ5RWRpdG9yUHJvcHM8UHJvbWV0aGV1c0RhdGFzb3VyY2UsIFByb21RdWVyeSwgUHJvbU9wdGlvbnM+IHtcbiAgRXh0cmFGaWVsZEVsZW1lbnQ/OiBSZWFjdE5vZGU7XG4gICdkYXRhLXRlc3RpZCc/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBQcm9tUXVlcnlGaWVsZFN0YXRlIHtcbiAgbGFiZWxCcm93c2VyVmlzaWJsZTogYm9vbGVhbjtcbiAgc3ludGF4TG9hZGVkOiBib29sZWFuO1xuICBoaW50OiBRdWVyeUhpbnQgfCBudWxsO1xufVxuXG5jbGFzcyBQcm9tUXVlcnlGaWVsZCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvbVF1ZXJ5RmllbGRQcm9wcywgUHJvbVF1ZXJ5RmllbGRTdGF0ZT4ge1xuICBwbHVnaW5zOiBQbHVnaW5bXTtcbiAgZGVjbGFyZSBsYW5ndWFnZVByb3ZpZGVySW5pdGlhbGl6YXRpb25Qcm9taXNlOiBDYW5jZWxhYmxlUHJvbWlzZTxhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9tUXVlcnlGaWVsZFByb3BzLCBjb250ZXh0OiBSZWFjdC5Db250ZXh0PGFueT4pIHtcbiAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG5cbiAgICB0aGlzLnBsdWdpbnMgPSBbXG4gICAgICBCcmFjZXNQbHVnaW4oKSxcbiAgICAgIFNsYXRlUHJpc20oXG4gICAgICAgIHtcbiAgICAgICAgICBvbmx5SW46IChub2RlOiBhbnkpID0+IG5vZGUudHlwZSA9PT0gJ2NvZGVfYmxvY2snLFxuICAgICAgICAgIGdldFN5bnRheDogKG5vZGU6IGFueSkgPT4gJ3Byb21xbCcsXG4gICAgICAgIH0sXG4gICAgICAgIHsgLi4uKHByaXNtTGFuZ3VhZ2VzIGFzIExhbmd1YWdlTWFwKSwgcHJvbXFsOiB0aGlzLnByb3BzLmRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5zeW50YXggfVxuICAgICAgKSxcbiAgICBdO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxhYmVsQnJvd3NlclZpc2libGU6IGZhbHNlLFxuICAgICAgc3ludGF4TG9hZGVkOiBmYWxzZSxcbiAgICAgIGhpbnQ6IG51bGwsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLmRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlcikge1xuICAgICAgdGhpcy5yZWZyZXNoTWV0cmljcygpO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2hIaW50KCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5sYW5ndWFnZVByb3ZpZGVySW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgICB0aGlzLmxhbmd1YWdlUHJvdmlkZXJJbml0aWFsaXphdGlvblByb21pc2UuY2FuY2VsKCk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogUHJvbVF1ZXJ5RmllbGRQcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBkYXRhc291cmNlOiB7IGxhbmd1YWdlUHJvdmlkZXIgfSxcbiAgICAgIHJhbmdlLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGxhbmd1YWdlUHJvdmlkZXIgIT09IHByZXZQcm9wcy5kYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIpIHtcbiAgICAgIC8vIFdlIHJlc2V0IHRoaXMgb25seSBvbiBEUyBjaGFuZ2Ugc28gd2UgZG8gbm90IGZsZXNoIGxvYWRpbmcgc3RhdGUgb24gZXZlcnkgcmFuZ2VDaGFuZ2Ugd2hpY2ggaGFwcGVucyBvbiBldmVyeVxuICAgICAgLy8gcXVlcnkgcnVuIGlmIHVzaW5nIHJlbGF0aXZlIHJhbmdlLlxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN5bnRheExvYWRlZDogZmFsc2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkUmFuZ2VUb1JlZnJlc2ggPSB0aGlzLnJhbmdlQ2hhbmdlZFRvUmVmcmVzaChyYW5nZSwgcHJldlByb3BzLnJhbmdlKTtcbiAgICAvLyBXZSB3YW50IHRvIHJlZnJlc2ggbWV0cmljcyB3aGVuIGxhbmd1YWdlIHByb3ZpZGVyIGNoYW5nZXMgYW5kL29yIHdoZW4gcmFuZ2UgY2hhbmdlcyAod2Ugcm91bmQgdXAgaW50ZXJ2YWxzIHRvIGEgbWludXRlKVxuICAgIGlmIChsYW5ndWFnZVByb3ZpZGVyICE9PSBwcmV2UHJvcHMuZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyIHx8IGNoYW5nZWRSYW5nZVRvUmVmcmVzaCkge1xuICAgICAgdGhpcy5yZWZyZXNoTWV0cmljcygpO1xuICAgIH1cblxuICAgIGlmIChkYXRhICYmIHByZXZQcm9wcy5kYXRhICYmIHByZXZQcm9wcy5kYXRhLnNlcmllcyAhPT0gZGF0YS5zZXJpZXMpIHtcbiAgICAgIHRoaXMucmVmcmVzaEhpbnQoKTtcbiAgICB9XG4gIH1cblxuICByZWZyZXNoSGludCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGFzb3VyY2UsIHF1ZXJ5LCBkYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGluaXRIaW50cyA9IGRhdGFzb3VyY2UuZ2V0SW5pdEhpbnRzKCk7XG4gICAgY29uc3QgaW5pdEhpbnQgPSBpbml0SGludHMubGVuZ3RoID4gMCA/IGluaXRIaW50c1swXSA6IG51bGw7XG5cbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5zZXJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaGludDogaW5pdEhpbnQsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBpc0RhdGFGcmFtZShkYXRhLnNlcmllc1swXSkgPyBkYXRhLnNlcmllcy5tYXAodG9MZWdhY3lSZXNwb25zZURhdGEpIDogZGF0YS5zZXJpZXM7XG4gICAgY29uc3QgcXVlcnlIaW50cyA9IGRhdGFzb3VyY2UuZ2V0UXVlcnlIaW50cyhxdWVyeSwgcmVzdWx0KTtcbiAgICBsZXQgcXVlcnlIaW50ID0gcXVlcnlIaW50cy5sZW5ndGggPiAwID8gcXVlcnlIaW50c1swXSA6IG51bGw7XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgaGludDogcXVlcnlIaW50ID8/IGluaXRIaW50IH0pO1xuICB9O1xuXG4gIHJlZnJlc2hNZXRyaWNzID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFzb3VyY2U6IHsgbGFuZ3VhZ2VQcm92aWRlciB9LFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5sYW5ndWFnZVByb3ZpZGVySW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbWFrZVByb21pc2VDYW5jZWxhYmxlKGxhbmd1YWdlUHJvdmlkZXIuc3RhcnQoKSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVtYWluaW5nVGFza3MgPSBhd2FpdCB0aGlzLmxhbmd1YWdlUHJvdmlkZXJJbml0aWFsaXphdGlvblByb21pc2UucHJvbWlzZTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlbWFpbmluZ1Rhc2tzKTtcbiAgICAgIHRoaXMub25VcGRhdGVMYW5ndWFnZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGlzQ2FuY2VsYWJsZVByb21pc2VSZWplY3Rpb24oZXJyKSAmJiBlcnIuaXNDYW5jZWxlZCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nLCBwcm9taXNlIHdhcyBjYW5jZWxlZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByYW5nZUNoYW5nZWRUb1JlZnJlc2gocmFuZ2U/OiBUaW1lUmFuZ2UsIHByZXZSYW5nZT86IFRpbWVSYW5nZSk6IGJvb2xlYW4ge1xuICAgIGlmIChyYW5nZSAmJiBwcmV2UmFuZ2UpIHtcbiAgICAgIGNvbnN0IHNhbWVNaW51dGVGcm9tID0gcm91bmRNc1RvTWluKHJhbmdlLmZyb20udmFsdWVPZigpKSA9PT0gcm91bmRNc1RvTWluKHByZXZSYW5nZS5mcm9tLnZhbHVlT2YoKSk7XG4gICAgICBjb25zdCBzYW1lTWludXRlVG8gPSByb3VuZE1zVG9NaW4ocmFuZ2UudG8udmFsdWVPZigpKSA9PT0gcm91bmRNc1RvTWluKHByZXZSYW5nZS50by52YWx1ZU9mKCkpO1xuICAgICAgLy8gSWYgYm90aCBhcmUgc2FtZSwgZG9uJ3QgbmVlZCB0byByZWZyZXNoLlxuICAgICAgcmV0dXJuICEoc2FtZU1pbnV0ZUZyb20gJiYgc2FtZU1pbnV0ZVRvKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE8gIzMzOTc2OiBSZW1vdmUgdGhpcywgYWRkIGhpc3RvZ3JhbSBncm91cCAocXVlcnkgPSBgaGlzdG9ncmFtX3F1YW50aWxlKDAuOTUsIHN1bShyYXRlKCR7bWV0cmljfVs1bV0pKSBieSAobGUpKWA7KVxuICAgKi9cbiAgb25DaGFuZ2VMYWJlbEJyb3dzZXIgPSAoc2VsZWN0b3I6IHN0cmluZykgPT4ge1xuICAgIHRoaXMub25DaGFuZ2VRdWVyeShzZWxlY3RvciwgdHJ1ZSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVsQnJvd3NlclZpc2libGU6IGZhbHNlIH0pO1xuICB9O1xuXG4gIG9uQ2hhbmdlUXVlcnkgPSAodmFsdWU6IHN0cmluZywgb3ZlcnJpZGU/OiBib29sZWFuKSA9PiB7XG4gICAgLy8gU2VuZCB0ZXh0IGNoYW5nZSB0byBwYXJlbnRcbiAgICBjb25zdCB7IHF1ZXJ5LCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIGNvbnN0IG5leHRRdWVyeTogUHJvbVF1ZXJ5ID0geyAuLi5xdWVyeSwgZXhwcjogdmFsdWUgfTtcbiAgICAgIG9uQ2hhbmdlKG5leHRRdWVyeSk7XG5cbiAgICAgIGlmIChvdmVycmlkZSAmJiBvblJ1blF1ZXJ5KSB7XG4gICAgICAgIG9uUnVuUXVlcnkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgb25DbGlja0Nob29zZXJCdXR0b24gPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSgoc3RhdGUpID0+ICh7IGxhYmVsQnJvd3NlclZpc2libGU6ICFzdGF0ZS5sYWJlbEJyb3dzZXJWaXNpYmxlIH0pKTtcbiAgfTtcblxuICBvbkNsaWNrSGludEZpeCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGFzb3VyY2UsIHF1ZXJ5LCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGhpbnQgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBvbkNoYW5nZShkYXRhc291cmNlLm1vZGlmeVF1ZXJ5KHF1ZXJ5LCBoaW50IS5maXghLmFjdGlvbikpO1xuICAgIG9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICBvblVwZGF0ZUxhbmd1YWdlID0gKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFzb3VyY2U6IHsgbGFuZ3VhZ2VQcm92aWRlciB9LFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgbWV0cmljcyB9ID0gbGFuZ3VhZ2VQcm92aWRlcjtcblxuICAgIGlmICghbWV0cmljcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoeyBzeW50YXhMb2FkZWQ6IHRydWUgfSk7XG4gIH07XG5cbiAgb25UeXBlYWhlYWQgPSBhc3luYyAodHlwZWFoZWFkOiBUeXBlYWhlYWRJbnB1dCk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YXNvdXJjZTogeyBsYW5ndWFnZVByb3ZpZGVyIH0sXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoIWxhbmd1YWdlUHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zOiBbXSB9O1xuICAgIH1cblxuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHByZWZpeCwgdGV4dCwgdmFsdWUsIHdyYXBwZXJDbGFzc2VzLCBsYWJlbEtleSB9ID0gdHlwZWFoZWFkO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGFuZ3VhZ2VQcm92aWRlci5wcm92aWRlQ29tcGxldGlvbkl0ZW1zKFxuICAgICAgeyB0ZXh0LCB2YWx1ZSwgcHJlZml4LCB3cmFwcGVyQ2xhc3NlcywgbGFiZWxLZXkgfSxcbiAgICAgIHsgaGlzdG9yeSB9XG4gICAgKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFzb3VyY2UsXG4gICAgICBkYXRhc291cmNlOiB7IGxhbmd1YWdlUHJvdmlkZXIgfSxcbiAgICAgIHF1ZXJ5LFxuICAgICAgRXh0cmFGaWVsZEVsZW1lbnQsXG4gICAgICBoaXN0b3J5ID0gW10sXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB7IGxhYmVsQnJvd3NlclZpc2libGUsIHN5bnRheExvYWRlZCwgaGludCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBoYXNNZXRyaWNzID0gbGFuZ3VhZ2VQcm92aWRlci5tZXRyaWNzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgY2hvb3NlclRleHQgPSBnZXRDaG9vc2VyVGV4dChkYXRhc291cmNlLmxvb2t1cHNEaXNhYmxlZCwgc3ludGF4TG9hZGVkLCBoYXNNZXRyaWNzKTtcbiAgICBjb25zdCBidXR0b25EaXNhYmxlZCA9ICEoc3ludGF4TG9hZGVkICYmIGhhc01ldHJpY3MpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxMb2NhbFN0b3JhZ2VWYWx1ZVByb3ZpZGVyPHN0cmluZ1tdPiBzdG9yYWdlS2V5PXtMQVNUX1VTRURfTEFCRUxTX0tFWX0gZGVmYXVsdFZhbHVlPXtbXX0+XG4gICAgICAgIHsobGFzdFVzZWRMYWJlbHMsIG9uTGFzdFVzZWRMYWJlbHNTYXZlLCBvbkxhc3RVc2VkTGFiZWxzRGVsZXRlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZSBnZi1mb3JtLWlubGluZS0teHMtdmlldy1mbGV4LWNvbHVtbiBmbGV4LWdyb3ctMVwiXG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9e3RoaXMucHJvcHNbJ2RhdGEtdGVzdGlkJ119XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJnZi1mb3JtLWxhYmVsIHF1ZXJ5LWtleXdvcmQgcG9pbnRlclwiXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tDaG9vc2VyQnV0dG9ufVxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2J1dHRvbkRpc2FibGVkfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtjaG9vc2VyVGV4dH1cbiAgICAgICAgICAgICAgICAgIDxJY29uIG5hbWU9e2xhYmVsQnJvd3NlclZpc2libGUgPyAnYW5nbGUtZG93bicgOiAnYW5nbGUtcmlnaHQnfSAvPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtIGdmLWZvcm0tLWdyb3cgZmxleC1zaHJpbmstMSBtaW4td2lkdGgtMTVcIj5cbiAgICAgICAgICAgICAgICAgIDxNb25hY29RdWVyeUZpZWxkV3JhcHBlclxuICAgICAgICAgICAgICAgICAgICBydW5RdWVyeU9uQmx1cj17dGhpcy5wcm9wcy5hcHAgIT09IENvcmVBcHAuRXhwbG9yZX1cbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VQcm92aWRlcj17bGFuZ3VhZ2VQcm92aWRlcn1cbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yeT17aGlzdG9yeX1cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2VRdWVyeX1cbiAgICAgICAgICAgICAgICAgICAgb25SdW5RdWVyeT17dGhpcy5wcm9wcy5vblJ1blF1ZXJ5fVxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWU9e3F1ZXJ5LmV4cHIgPz8gJyd9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAge2xhYmVsQnJvd3NlclZpc2libGUgJiYgKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICAgICAgPFByb21ldGhldXNNZXRyaWNzQnJvd3NlclxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZVByb3ZpZGVyPXtsYW5ndWFnZVByb3ZpZGVyfVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZUxhYmVsQnJvd3Nlcn1cbiAgICAgICAgICAgICAgICAgICAgbGFzdFVzZWRMYWJlbHM9e2xhc3RVc2VkTGFiZWxzIHx8IFtdfVxuICAgICAgICAgICAgICAgICAgICBzdG9yZUxhc3RVc2VkTGFiZWxzPXtvbkxhc3RVc2VkTGFiZWxzU2F2ZX1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGFzdFVzZWRMYWJlbHM9e29uTGFzdFVzZWRMYWJlbHNEZWxldGV9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgIHtFeHRyYUZpZWxkRWxlbWVudH1cbiAgICAgICAgICAgICAge2hpbnQgPyAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJxdWVyeS1yb3ctYnJlYWtcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHJvbS1xdWVyeS1maWVsZC1pbmZvIHRleHQtd2FybmluZ1wiPlxuICAgICAgICAgICAgICAgICAgICB7aGludC5sYWJlbH17JyAnfVxuICAgICAgICAgICAgICAgICAgICB7aGludC5maXggPyAoXG4gICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwidGV4dC1saW5rIG11dGVkXCIgb25DbGljaz17dGhpcy5vbkNsaWNrSGludEZpeH0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7aGludC5maXgubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICAgICk7XG4gICAgICAgIH19XG4gICAgICA8L0xvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcm9tUXVlcnlGaWVsZDtcbiIsImltcG9ydCB7IGNzcywgY3ggfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IENoYW5nZUV2ZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRml4ZWRTaXplTGlzdCB9IGZyb20gJ3JlYWN0LXdpbmRvdyc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHtcbiAgQnV0dG9uLFxuICBIb3Jpem9udGFsR3JvdXAsXG4gIElucHV0LFxuICBMYWJlbCxcbiAgTG9hZGluZ1BsYWNlaG9sZGVyLFxuICBzdHlsZXNGYWN0b3J5LFxuICB3aXRoVGhlbWUsXG4gIEJyb3dzZXJMYWJlbCBhcyBQcm9tTGFiZWwsXG59IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IFByb21RbExhbmd1YWdlUHJvdmlkZXIgZnJvbSAnLi4vbGFuZ3VhZ2VfcHJvdmlkZXInO1xuaW1wb3J0IHsgZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3RvciwgZXNjYXBlTGFiZWxWYWx1ZUluUmVnZXhTZWxlY3RvciB9IGZyb20gJy4uL2xhbmd1YWdlX3V0aWxzJztcblxuLy8gSGFyZCBsaW1pdCBvbiBsYWJlbHMgdG8gcmVuZGVyXG5jb25zdCBFTVBUWV9TRUxFQ1RPUiA9ICd7fSc7XG5jb25zdCBNRVRSSUNfTEFCRUwgPSAnX19uYW1lX18nO1xuY29uc3QgTElTVF9JVEVNX1NJWkUgPSAyNTtcblxuZXhwb3J0IGludGVyZmFjZSBCcm93c2VyUHJvcHMge1xuICBsYW5ndWFnZVByb3ZpZGVyOiBQcm9tUWxMYW5ndWFnZVByb3ZpZGVyO1xuICBvbkNoYW5nZTogKHNlbGVjdG9yOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHRoZW1lOiBHcmFmYW5hVGhlbWU7XG4gIGF1dG9TZWxlY3Q/OiBudW1iZXI7XG4gIGhpZGU/OiAoKSA9PiB2b2lkO1xuICBsYXN0VXNlZExhYmVsczogc3RyaW5nW107XG4gIHN0b3JlTGFzdFVzZWRMYWJlbHM6IChsYWJlbHM6IHN0cmluZ1tdKSA9PiB2b2lkO1xuICBkZWxldGVMYXN0VXNlZExhYmVsczogKCkgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIEJyb3dzZXJTdGF0ZSB7XG4gIGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW107XG4gIGxhYmVsU2VhcmNoVGVybTogc3RyaW5nO1xuICBtZXRyaWNTZWFyY2hUZXJtOiBzdHJpbmc7XG4gIHN0YXR1czogc3RyaW5nO1xuICBlcnJvcjogc3RyaW5nO1xuICB2YWxpZGF0aW9uU3RhdHVzOiBzdHJpbmc7XG4gIHZhbHVlU2VhcmNoVGVybTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmFjZXR0YWJsZVZhbHVlIHtcbiAgbmFtZTogc3RyaW5nO1xuICBzZWxlY3RlZD86IGJvb2xlYW47XG4gIGRldGFpbHM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0YWJsZUxhYmVsIHtcbiAgbmFtZTogc3RyaW5nO1xuICBzZWxlY3RlZD86IGJvb2xlYW47XG4gIGxvYWRpbmc/OiBib29sZWFuO1xuICB2YWx1ZXM/OiBGYWNldHRhYmxlVmFsdWVbXTtcbiAgaGlkZGVuPzogYm9vbGVhbjtcbiAgZmFjZXRzPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTZWxlY3RvcihsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdKTogc3RyaW5nIHtcbiAgbGV0IHNpbmdsZU1ldHJpYyA9ICcnO1xuICBjb25zdCBzZWxlY3RlZExhYmVscyA9IFtdO1xuICBmb3IgKGNvbnN0IGxhYmVsIG9mIGxhYmVscykge1xuICAgIGlmICgobGFiZWwubmFtZSA9PT0gTUVUUklDX0xBQkVMIHx8IGxhYmVsLnNlbGVjdGVkKSAmJiBsYWJlbC52YWx1ZXMgJiYgbGFiZWwudmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVmFsdWVzID0gbGFiZWwudmFsdWVzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnNlbGVjdGVkKS5tYXAoKHZhbHVlKSA9PiB2YWx1ZS5uYW1lKTtcbiAgICAgIGlmIChzZWxlY3RlZFZhbHVlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNlbGVjdGVkTGFiZWxzLnB1c2goYCR7bGFiZWwubmFtZX09flwiJHtzZWxlY3RlZFZhbHVlcy5tYXAoZXNjYXBlTGFiZWxWYWx1ZUluUmVnZXhTZWxlY3Rvcikuam9pbignfCcpfVwiYCk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAobGFiZWwubmFtZSA9PT0gTUVUUklDX0xBQkVMKSB7XG4gICAgICAgICAgc2luZ2xlTWV0cmljID0gc2VsZWN0ZWRWYWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWRMYWJlbHMucHVzaChgJHtsYWJlbC5uYW1lfT1cIiR7ZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3RvcihzZWxlY3RlZFZhbHVlc1swXSl9XCJgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gW3NpbmdsZU1ldHJpYywgJ3snLCBzZWxlY3RlZExhYmVscy5qb2luKCcsJyksICd9J10uam9pbignJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWNldExhYmVscyhcbiAgbGFiZWxzOiBTZWxlY3RhYmxlTGFiZWxbXSxcbiAgcG9zc2libGVMYWJlbHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPixcbiAgbGFzdEZhY2V0dGVkPzogc3RyaW5nXG4pOiBTZWxlY3RhYmxlTGFiZWxbXSB7XG4gIHJldHVybiBsYWJlbHMubWFwKChsYWJlbCkgPT4ge1xuICAgIGNvbnN0IHBvc3NpYmxlVmFsdWVzID0gcG9zc2libGVMYWJlbHNbbGFiZWwubmFtZV07XG4gICAgaWYgKHBvc3NpYmxlVmFsdWVzKSB7XG4gICAgICBsZXQgZXhpc3RpbmdWYWx1ZXM6IEZhY2V0dGFibGVWYWx1ZVtdO1xuICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IGxhc3RGYWNldHRlZCAmJiBsYWJlbC52YWx1ZXMpIHtcbiAgICAgICAgLy8gRmFjZXR0aW5nIHRoaXMgbGFiZWwsIHNob3cgYWxsIHZhbHVlc1xuICAgICAgICBleGlzdGluZ1ZhbHVlcyA9IGxhYmVsLnZhbHVlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEtlZXAgc2VsZWN0aW9uIGluIG90aGVyIGZhY2V0c1xuICAgICAgICBjb25zdCBzZWxlY3RlZFZhbHVlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KFxuICAgICAgICAgIGxhYmVsLnZhbHVlcz8uZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUuc2VsZWN0ZWQpLm1hcCgodmFsdWUpID0+IHZhbHVlLm5hbWUpIHx8IFtdXG4gICAgICAgICk7XG4gICAgICAgIC8vIFZhbHVlcyBmb3IgdGhpcyBsYWJlbCBoYXZlIG5vdCBiZWVuIHJlcXVlc3RlZCB5ZXQsIGxldCdzIHVzZSB0aGUgZmFjZXR0ZWQgb25lcyBhcyB0aGUgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgZXhpc3RpbmdWYWx1ZXMgPSBwb3NzaWJsZVZhbHVlcy5tYXAoKHZhbHVlKSA9PiAoeyBuYW1lOiB2YWx1ZSwgc2VsZWN0ZWQ6IHNlbGVjdGVkVmFsdWVzLmhhcyh2YWx1ZSkgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubGFiZWwsXG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICB2YWx1ZXM6IGV4aXN0aW5nVmFsdWVzLFxuICAgICAgICBoaWRkZW46ICFwb3NzaWJsZVZhbHVlcyxcbiAgICAgICAgZmFjZXRzOiBleGlzdGluZ1ZhbHVlcy5sZW5ndGgsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIExhYmVsIGlzIGZhY2V0dGVkIG91dCwgaGlkZSBhbGwgdmFsdWVzXG4gICAgcmV0dXJuIHsgLi4ubGFiZWwsIGxvYWRpbmc6IGZhbHNlLCBoaWRkZW46ICFwb3NzaWJsZVZhbHVlcywgdmFsdWVzOiB1bmRlZmluZWQsIGZhY2V0czogMCB9O1xuICB9KTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gc3R5bGVzRmFjdG9yeSgodGhlbWU6IEdyYWZhbmFUaGVtZSkgPT4gKHtcbiAgd3JhcHBlcjogY3NzYFxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLmJnMn07XG4gICAgcGFkZGluZzogJHt0aGVtZS5zcGFjaW5nLnNtfTtcbiAgICB3aWR0aDogMTAwJTtcbiAgYCxcbiAgbGlzdDogY3NzYFxuICAgIG1hcmdpbi10b3A6ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAgbWF4LWhlaWdodDogMjAwcHg7XG4gICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcbiAgYCxcbiAgc2VjdGlvbjogY3NzYFxuICAgICYgKyAmIHtcbiAgICAgIG1hcmdpbjogJHt0aGVtZS5zcGFjaW5nLm1kfSAwO1xuICAgIH1cbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGAsXG4gIHNlbGVjdG9yOiBjc3NgXG4gICAgZm9udC1mYW1pbHk6ICR7dGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5Lm1vbm9zcGFjZX07XG4gICAgbWFyZ2luLWJvdHRvbTogJHt0aGVtZS5zcGFjaW5nLnNtfTtcbiAgYCxcbiAgc3RhdHVzOiBjc3NgXG4gICAgcGFkZGluZzogJHt0aGVtZS5zcGFjaW5nLnhzfTtcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMudGV4dFNlbWlXZWFrfTtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgLyogdXNpbmcgYWJzb2x1dGUgcG9zaXRpb25pbmcgYmVjYXVzZSBmbGV4IGludGVyZmVyZXMgd2l0aCBlbGxpcHNpcyAqL1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogNTAlO1xuICAgIHJpZ2h0OiAwO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMTAwbXMgbGluZWFyO1xuICAgIG9wYWNpdHk6IDA7XG4gIGAsXG4gIHN0YXR1c1Nob3dpbmc6IGNzc2BcbiAgICBvcGFjaXR5OiAxO1xuICBgLFxuICBlcnJvcjogY3NzYFxuICAgIGNvbG9yOiAke3RoZW1lLnBhbGV0dGUuYnJhbmREYW5nZXJ9O1xuICBgLFxuICB2YWx1ZUxpc3Q6IGNzc2BcbiAgICBtYXJnaW4tcmlnaHQ6ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gIGAsXG4gIHZhbHVlTGlzdFdyYXBwZXI6IGNzc2BcbiAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlcjJ9O1xuICAgIG1hcmdpbjogJHt0aGVtZS5zcGFjaW5nLnNtfSAwO1xuICAgIHBhZGRpbmc6ICR7dGhlbWUuc3BhY2luZy5zbX0gMCAke3RoZW1lLnNwYWNpbmcuc219ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gIGAsXG4gIHZhbHVlTGlzdEFyZWE6IGNzc2BcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBtYXJnaW4tdG9wOiAke3RoZW1lLnNwYWNpbmcuc219O1xuICBgLFxuICB2YWx1ZVRpdGxlOiBjc3NgXG4gICAgbWFyZ2luLWxlZnQ6IC0ke3RoZW1lLnNwYWNpbmcueHN9O1xuICAgIG1hcmdpbi1ib3R0b206ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gIGAsXG4gIHZhbGlkYXRpb25TdGF0dXM6IGNzc2BcbiAgICBwYWRkaW5nOiAke3RoZW1lLnNwYWNpbmcueHN9O1xuICAgIG1hcmdpbi1ib3R0b206ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnRleHRTdHJvbmd9O1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgYCxcbn0pKTtcblxuLyoqXG4gKiBUT0RPICMzMzk3NjogUmVtb3ZlIGR1cGxpY2F0ZWQgY29kZS4gVGhlIGNvbXBvbmVudCBpcyB2ZXJ5IHNpbWlsYXIgdG8gTG9raUxhYmVsQnJvd3Nlci50c3guIENoZWNrIGlmIGl0J3MgcG9zc2libGVcbiAqICAgICAgICAgICAgICB0byBjcmVhdGUgYSBzaW5nbGUsIGdlbmVyaWMgY29tcG9uZW50LlxuICovXG5leHBvcnQgY2xhc3MgVW50aGVtZWRQcm9tZXRoZXVzTWV0cmljc0Jyb3dzZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8QnJvd3NlclByb3BzLCBCcm93c2VyU3RhdGU+IHtcbiAgdmFsdWVMaXN0c1JlZiA9IFJlYWN0LmNyZWF0ZVJlZjxIVE1MRGl2RWxlbWVudD4oKTtcbiAgc3RhdGU6IEJyb3dzZXJTdGF0ZSA9IHtcbiAgICBsYWJlbHM6IFtdIGFzIFNlbGVjdGFibGVMYWJlbFtdLFxuICAgIGxhYmVsU2VhcmNoVGVybTogJycsXG4gICAgbWV0cmljU2VhcmNoVGVybTogJycsXG4gICAgc3RhdHVzOiAnUmVhZHknLFxuICAgIGVycm9yOiAnJyxcbiAgICB2YWxpZGF0aW9uU3RhdHVzOiAnJyxcbiAgICB2YWx1ZVNlYXJjaFRlcm06ICcnLFxuICB9O1xuXG4gIG9uQ2hhbmdlTGFiZWxTZWFyY2ggPSAoZXZlbnQ6IENoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVsU2VhcmNoVGVybTogZXZlbnQudGFyZ2V0LnZhbHVlIH0pO1xuICB9O1xuXG4gIG9uQ2hhbmdlTWV0cmljU2VhcmNoID0gKGV2ZW50OiBDaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBtZXRyaWNTZWFyY2hUZXJtOiBldmVudC50YXJnZXQudmFsdWUgfSk7XG4gIH07XG5cbiAgb25DaGFuZ2VWYWx1ZVNlYXJjaCA9IChldmVudDogQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgdmFsdWVTZWFyY2hUZXJtOiBldmVudC50YXJnZXQudmFsdWUgfSk7XG4gIH07XG5cbiAgb25DbGlja1J1blF1ZXJ5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZShzZWxlY3Rvcik7XG4gIH07XG5cbiAgb25DbGlja1J1blJhdGVRdWVyeSA9ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGJ1aWxkU2VsZWN0b3IodGhpcy5zdGF0ZS5sYWJlbHMpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gYHJhdGUoJHtzZWxlY3Rvcn1bJF9faW50ZXJ2YWxdKWA7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZShxdWVyeSk7XG4gIH07XG5cbiAgb25DbGlja0NsZWFyID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gc3RhdGUubGFiZWxzLm1hcCgobGFiZWwpID0+ICh7XG4gICAgICAgIC4uLmxhYmVsLFxuICAgICAgICB2YWx1ZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgZmFjZXRzOiB1bmRlZmluZWQsXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYWJlbHMsXG4gICAgICAgIGxhYmVsU2VhcmNoVGVybTogJycsXG4gICAgICAgIG1ldHJpY1NlYXJjaFRlcm06ICcnLFxuICAgICAgICBzdGF0dXM6ICcnLFxuICAgICAgICBlcnJvcjogJycsXG4gICAgICAgIHZhbGlkYXRpb25TdGF0dXM6ICcnLFxuICAgICAgICB2YWx1ZVNlYXJjaFRlcm06ICcnLFxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLmRlbGV0ZUxhc3RVc2VkTGFiZWxzKCk7XG4gICAgLy8gR2V0IG1ldHJpY3NcbiAgICB0aGlzLmZldGNoVmFsdWVzKE1FVFJJQ19MQUJFTCwgRU1QVFlfU0VMRUNUT1IpO1xuICB9O1xuXG4gIG9uQ2xpY2tMYWJlbCA9IChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5zdGF0ZS5sYWJlbHMuZmluZCgobCkgPT4gbC5uYW1lID09PSBuYW1lKTtcbiAgICBpZiAoIWxhYmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRvZ2dsZSBzZWxlY3RlZCBzdGF0ZVxuICAgIGNvbnN0IHNlbGVjdGVkID0gIWxhYmVsLnNlbGVjdGVkO1xuICAgIGxldCBuZXh0VmFsdWU6IFBhcnRpYWw8U2VsZWN0YWJsZUxhYmVsPiA9IHsgc2VsZWN0ZWQgfTtcbiAgICBpZiAobGFiZWwudmFsdWVzICYmICFzZWxlY3RlZCkge1xuICAgICAgLy8gRGVzZWxlY3QgYWxsIHZhbHVlcyBpZiBsYWJlbCB3YXMgZGVzZWxlY3RlZFxuICAgICAgY29uc3QgdmFsdWVzID0gbGFiZWwudmFsdWVzLm1hcCgodmFsdWUpID0+ICh7IC4uLnZhbHVlLCBzZWxlY3RlZDogZmFsc2UgfSkpO1xuICAgICAgbmV4dFZhbHVlID0geyAuLi5uZXh0VmFsdWUsIGZhY2V0czogMCwgdmFsdWVzIH07XG4gICAgfVxuICAgIC8vIFJlc2V0dGluZyBzZWFyY2ggdG8gcHJldmVudCBlbXB0eSByZXN1bHRzXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVsU2VhcmNoVGVybTogJycgfSk7XG4gICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIG5leHRWYWx1ZSwgJycsICgpID0+IHRoaXMuZG9GYWNldHRpbmdGb3JMYWJlbChuYW1lKSk7XG4gIH07XG5cbiAgb25DbGlja1ZhbHVlID0gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwgfHwgIWxhYmVsLnZhbHVlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXNldHRpbmcgc2VhcmNoIHRvIHByZXZlbnQgZW1wdHkgcmVzdWx0c1xuICAgIHRoaXMuc2V0U3RhdGUoeyBsYWJlbFNlYXJjaFRlcm06ICcnIH0pO1xuICAgIC8vIFRvZ2dsaW5nIHZhbHVlIGZvciBzZWxlY3RlZCBsYWJlbCwgbGVhdmluZyBvdGhlciB2YWx1ZXMgaW50YWN0XG4gICAgY29uc3QgdmFsdWVzID0gbGFiZWwudmFsdWVzLm1hcCgodikgPT4gKHsgLi4udiwgc2VsZWN0ZWQ6IHYubmFtZSA9PT0gdmFsdWUgPyAhdi5zZWxlY3RlZCA6IHYuc2VsZWN0ZWQgfSkpO1xuICAgIHRoaXMudXBkYXRlTGFiZWxTdGF0ZShuYW1lLCB7IHZhbHVlcyB9LCAnJywgKCkgPT4gdGhpcy5kb0ZhY2V0dGluZyhuYW1lKSk7XG4gIH07XG5cbiAgb25DbGlja01ldHJpYyA9IChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxFbGVtZW50PikgPT4ge1xuICAgIC8vIEZpbmRpbmcgc3BlY2lhbCBtZXRyaWMgbGFiZWxcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuc3RhdGUubGFiZWxzLmZpbmQoKGwpID0+IGwubmFtZSA9PT0gbmFtZSk7XG4gICAgaWYgKCFsYWJlbCB8fCAhbGFiZWwudmFsdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlc2V0dGluZyBzZWFyY2ggdG8gcHJldmVudCBlbXB0eSByZXN1bHRzXG4gICAgdGhpcy5zZXRTdGF0ZSh7IG1ldHJpY1NlYXJjaFRlcm06ICcnIH0pO1xuICAgIC8vIFRvZ2dsaW5nIHZhbHVlIGZvciBzZWxlY3RlZCBsYWJlbCwgbGVhdmluZyBvdGhlciB2YWx1ZXMgaW50YWN0XG4gICAgY29uc3QgdmFsdWVzID0gbGFiZWwudmFsdWVzLm1hcCgodikgPT4gKHtcbiAgICAgIC4uLnYsXG4gICAgICBzZWxlY3RlZDogdi5uYW1lID09PSB2YWx1ZSB8fCB2LnNlbGVjdGVkID8gIXYuc2VsZWN0ZWQgOiB2LnNlbGVjdGVkLFxuICAgIH0pKTtcbiAgICAvLyBUb2dnbGUgc2VsZWN0ZWQgc3RhdGUgb2Ygc3BlY2lhbCBtZXRyaWNzIGxhYmVsXG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB2YWx1ZXMuc29tZSgodikgPT4gdi5zZWxlY3RlZCk7XG4gICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIHsgc2VsZWN0ZWQsIHZhbHVlcyB9LCAnJywgKCkgPT4gdGhpcy5kb0ZhY2V0dGluZyhuYW1lKSk7XG4gIH07XG5cbiAgb25DbGlja1ZhbGlkYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgdGhpcy52YWxpZGF0ZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcblxuICB1cGRhdGVMYWJlbFN0YXRlKG5hbWU6IHN0cmluZywgdXBkYXRlZEZpZWxkczogUGFydGlhbDxTZWxlY3RhYmxlTGFiZWw+LCBzdGF0dXMgPSAnJywgY2I/OiAoKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10gPSBzdGF0ZS5sYWJlbHMubWFwKChsYWJlbCkgPT4ge1xuICAgICAgICBpZiAobGFiZWwubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiB7IC4uLmxhYmVsLCAuLi51cGRhdGVkRmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSk7XG4gICAgICAvLyBOZXcgc3RhdHVzIG92ZXJyaWRlcyBlcnJvcnNcbiAgICAgIGNvbnN0IGVycm9yID0gc3RhdHVzID8gJycgOiBzdGF0ZS5lcnJvcjtcbiAgICAgIHJldHVybiB7IGxhYmVscywgc3RhdHVzLCBlcnJvciwgdmFsaWRhdGlvblN0YXR1czogJycgfTtcbiAgICB9LCBjYik7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIsIGxhc3RVc2VkTGFiZWxzIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChsYW5ndWFnZVByb3ZpZGVyKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZExhYmVsczogc3RyaW5nW10gPSBsYXN0VXNlZExhYmVscztcbiAgICAgIGxhbmd1YWdlUHJvdmlkZXIuc3RhcnQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgbGV0IHJhd0xhYmVsczogc3RyaW5nW10gPSBsYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsS2V5cygpO1xuICAgICAgICAvLyBHZXQgbWV0cmljc1xuICAgICAgICB0aGlzLmZldGNoVmFsdWVzKE1FVFJJQ19MQUJFTCwgRU1QVFlfU0VMRUNUT1IpO1xuICAgICAgICAvLyBBdXRvLXNlbGVjdCBwcmV2aW91c2x5IHNlbGVjdGVkIGxhYmVsc1xuICAgICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gcmF3TGFiZWxzLm1hcCgobGFiZWwsIGksIGFycikgPT4gKHtcbiAgICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRMYWJlbHMuaW5jbHVkZXMobGFiZWwpLFxuICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIFByZS1mZXRjaCB2YWx1ZXMgZm9yIHNlbGVjdGVkIGxhYmVsc1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzIH0sICgpID0+IHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmxhYmVscy5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhYmVsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmV0Y2hWYWx1ZXMobGFiZWwubmFtZSwgRU1QVFlfU0VMRUNUT1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGRvRmFjZXR0aW5nRm9yTGFiZWwobmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscy5maWx0ZXIoKGxhYmVsKSA9PiBsYWJlbC5zZWxlY3RlZCkubWFwKChsYWJlbCkgPT4gbGFiZWwubmFtZSk7XG4gICAgdGhpcy5wcm9wcy5zdG9yZUxhc3RVc2VkTGFiZWxzKHNlbGVjdGVkTGFiZWxzKTtcbiAgICBpZiAobGFiZWwuc2VsZWN0ZWQpIHtcbiAgICAgIC8vIFJlZmV0Y2ggdmFsdWVzIGZvciBuZXdseSBzZWxlY3RlZCBsYWJlbC4uLlxuICAgICAgaWYgKCFsYWJlbC52YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5mZXRjaFZhbHVlcyhuYW1lLCBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgbmVlZCB0byBmYWNldCB3aGVuIGRlc2VsZWN0aW5nIGxhYmVsc1xuICAgICAgdGhpcy5kb0ZhY2V0dGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGRvRmFjZXR0aW5nID0gKGxhc3RGYWNldHRlZD86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgaWYgKHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUikge1xuICAgICAgLy8gQ2xlYXIgdXAgZmFjZXR0aW5nXG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gdGhpcy5zdGF0ZS5sYWJlbHMubWFwKChsYWJlbCkgPT4ge1xuICAgICAgICByZXR1cm4geyAuLi5sYWJlbCwgZmFjZXRzOiAwLCB2YWx1ZXM6IHVuZGVmaW5lZCwgaGlkZGVuOiBmYWxzZSB9O1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzIH0sICgpID0+IHtcbiAgICAgICAgLy8gR2V0IGZyZXNoIHNldCBvZiB2YWx1ZXNcbiAgICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMuZm9yRWFjaChcbiAgICAgICAgICAobGFiZWwpID0+IChsYWJlbC5zZWxlY3RlZCB8fCBsYWJlbC5uYW1lID09PSBNRVRSSUNfTEFCRUwpICYmIHRoaXMuZmV0Y2hWYWx1ZXMobGFiZWwubmFtZSwgc2VsZWN0b3IpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG8gZmFjZXR0aW5nXG4gICAgICB0aGlzLmZldGNoU2VyaWVzKHNlbGVjdG9yLCBsYXN0RmFjZXR0ZWQpO1xuICAgIH1cbiAgfTtcblxuICBhc3luYyBmZXRjaFZhbHVlcyhuYW1lOiBzdHJpbmcsIHNlbGVjdG9yOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIHsgbG9hZGluZzogdHJ1ZSB9LCBgRmV0Y2hpbmcgdmFsdWVzIGZvciAke25hbWV9YCk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByYXdWYWx1ZXMgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsVmFsdWVzKG5hbWUpO1xuICAgICAgLy8gSWYgc2VsZWN0b3IgY2hhbmdlZCwgY2xlYXIgbG9hZGluZyBzdGF0ZSBhbmQgZGlzY2FyZCByZXN1bHQgYnkgcmV0dXJuaW5nIGVhcmx5XG4gICAgICBpZiAoc2VsZWN0b3IgIT09IGJ1aWxkU2VsZWN0b3IodGhpcy5zdGF0ZS5sYWJlbHMpKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxTdGF0ZShuYW1lLCB7IGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZXM6IEZhY2V0dGFibGVWYWx1ZVtdID0gW107XG4gICAgICBjb25zdCB7IG1ldHJpY3NNZXRhZGF0YSB9ID0gbGFuZ3VhZ2VQcm92aWRlcjtcbiAgICAgIGZvciAoY29uc3QgbGFiZWxWYWx1ZSBvZiByYXdWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWU6IEZhY2V0dGFibGVWYWx1ZSA9IHsgbmFtZTogbGFiZWxWYWx1ZSB9O1xuICAgICAgICAvLyBBZGRpbmcgdHlwZS9oZWxwIHRleHQgdG8gbWV0cmljc1xuICAgICAgICBpZiAobmFtZSA9PT0gTUVUUklDX0xBQkVMICYmIG1ldHJpY3NNZXRhZGF0YSkge1xuICAgICAgICAgIGNvbnN0IG1ldGEgPSBtZXRyaWNzTWV0YWRhdGFbbGFiZWxWYWx1ZV07XG4gICAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIHZhbHVlLmRldGFpbHMgPSBgKCR7bWV0YS50eXBlfSkgJHttZXRhLmhlbHB9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIHsgdmFsdWVzLCBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hTZXJpZXMoc2VsZWN0b3I6IHN0cmluZywgbGFzdEZhY2V0dGVkPzogc3RyaW5nKSB7XG4gICAgY29uc3QgeyBsYW5ndWFnZVByb3ZpZGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChsYXN0RmFjZXR0ZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlTGFiZWxTdGF0ZShsYXN0RmFjZXR0ZWQsIHsgbG9hZGluZzogdHJ1ZSB9LCBgRmFjZXR0aW5nIGxhYmVscyBmb3IgJHtzZWxlY3Rvcn1gKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBvc3NpYmxlTGFiZWxzID0gYXdhaXQgbGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllc0xhYmVscyhzZWxlY3RvciwgdHJ1ZSk7XG4gICAgICAvLyBJZiBzZWxlY3RvciBjaGFuZ2VkLCBjbGVhciBsb2FkaW5nIHN0YXRlIGFuZCBkaXNjYXJkIHJlc3VsdCBieSByZXR1cm5pbmcgZWFybHlcbiAgICAgIGlmIChzZWxlY3RvciAhPT0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscykpIHtcbiAgICAgICAgaWYgKGxhc3RGYWNldHRlZCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWxTdGF0ZShsYXN0RmFjZXR0ZWQsIHsgbG9hZGluZzogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHBvc3NpYmxlTGFiZWxzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9yOiBgRW1wdHkgcmVzdWx0cywgbm8gbWF0Y2hpbmcgbGFiZWwgZm9yICR7c2VsZWN0b3J9YCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxzOiBTZWxlY3RhYmxlTGFiZWxbXSA9IGZhY2V0TGFiZWxzKHRoaXMuc3RhdGUubGFiZWxzLCBwb3NzaWJsZUxhYmVscywgbGFzdEZhY2V0dGVkKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBsYWJlbHMsIGVycm9yOiAnJyB9KTtcbiAgICAgIGlmIChsYXN0RmFjZXR0ZWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKGxhc3RGYWNldHRlZCwgeyBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdmFsaWRhdGVTZWxlY3RvcihzZWxlY3Rvcjogc3RyaW5nKSB7XG4gICAgY29uc3QgeyBsYW5ndWFnZVByb3ZpZGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWxpZGF0aW9uU3RhdHVzOiBgVmFsaWRhdGluZyBzZWxlY3RvciAke3NlbGVjdG9yfWAsIGVycm9yOiAnJyB9KTtcbiAgICBjb25zdCBzdHJlYW1zID0gYXdhaXQgbGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllcyhzZWxlY3Rvcik7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHZhbGlkYXRpb25TdGF0dXM6IGBTZWxlY3RvciBpcyB2YWxpZCAoJHtzdHJlYW1zLmxlbmd0aH0gc2VyaWVzIGZvdW5kKWAgfSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyB0aGVtZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGxhYmVscywgbGFiZWxTZWFyY2hUZXJtLCBtZXRyaWNTZWFyY2hUZXJtLCBzdGF0dXMsIGVycm9yLCB2YWxpZGF0aW9uU3RhdHVzLCB2YWx1ZVNlYXJjaFRlcm0gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVzKHRoZW1lKTtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgICAgICA8TG9hZGluZ1BsYWNlaG9sZGVyIHRleHQ9XCJMb2FkaW5nIGxhYmVscy4uLlwiIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgbWV0cmljc1xuICAgIGxldCBtZXRyaWNzID0gbGFiZWxzLmZpbmQoKGxhYmVsKSA9PiBsYWJlbC5uYW1lID09PSBNRVRSSUNfTEFCRUwpO1xuICAgIGlmIChtZXRyaWNzICYmIG1ldHJpY1NlYXJjaFRlcm0pIHtcbiAgICAgIG1ldHJpY3MgPSB7XG4gICAgICAgIC4uLm1ldHJpY3MsXG4gICAgICAgIHZhbHVlczogbWV0cmljcy52YWx1ZXM/LmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnNlbGVjdGVkIHx8IHZhbHVlLm5hbWUuaW5jbHVkZXMobWV0cmljU2VhcmNoVGVybSkpLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgbGFiZWxzXG4gICAgbGV0IG5vbk1ldHJpY0xhYmVscyA9IGxhYmVscy5maWx0ZXIoKGxhYmVsKSA9PiAhbGFiZWwuaGlkZGVuICYmIGxhYmVsLm5hbWUgIT09IE1FVFJJQ19MQUJFTCk7XG4gICAgaWYgKGxhYmVsU2VhcmNoVGVybSkge1xuICAgICAgbm9uTWV0cmljTGFiZWxzID0gbm9uTWV0cmljTGFiZWxzLmZpbHRlcigobGFiZWwpID0+IGxhYmVsLnNlbGVjdGVkIHx8IGxhYmVsLm5hbWUuaW5jbHVkZXMobGFiZWxTZWFyY2hUZXJtKSk7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIG5vbi1tZXRyaWMgbGFiZWwgdmFsdWVzXG4gICAgbGV0IHNlbGVjdGVkTGFiZWxzID0gbm9uTWV0cmljTGFiZWxzLmZpbHRlcigobGFiZWwpID0+IGxhYmVsLnNlbGVjdGVkICYmIGxhYmVsLnZhbHVlcyk7XG4gICAgaWYgKHZhbHVlU2VhcmNoVGVybSkge1xuICAgICAgc2VsZWN0ZWRMYWJlbHMgPSBzZWxlY3RlZExhYmVscy5tYXAoKGxhYmVsKSA9PiAoe1xuICAgICAgICAuLi5sYWJlbCxcbiAgICAgICAgdmFsdWVzOiBsYWJlbC52YWx1ZXM/LmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnNlbGVjdGVkIHx8IHZhbHVlLm5hbWUuaW5jbHVkZXModmFsdWVTZWFyY2hUZXJtKSksXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgY29uc3QgZW1wdHkgPSBzZWxlY3RvciA9PT0gRU1QVFlfU0VMRUNUT1I7XG4gICAgY29uc3QgbWV0cmljQ291bnQgPSBtZXRyaWNzPy52YWx1ZXM/Lmxlbmd0aCB8fCAwO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMud3JhcHBlcn0+XG4gICAgICAgIDxIb3Jpem9udGFsR3JvdXAgYWxpZ249XCJmbGV4LXN0YXJ0XCIgc3BhY2luZz1cImxnXCI+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc2VjdGlvbn0+XG4gICAgICAgICAgICAgIDxMYWJlbCBkZXNjcmlwdGlvbj1cIk9uY2UgYSBtZXRyaWMgaXMgc2VsZWN0ZWQgb25seSBwb3NzaWJsZSBsYWJlbHMgYXJlIHNob3duLlwiPjEuIFNlbGVjdCBhIG1ldHJpYzwvTGFiZWw+XG4gICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZU1ldHJpY1NlYXJjaH1cbiAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJGaWx0ZXIgZXhwcmVzc2lvbiBmb3IgbWV0cmljXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXttZXRyaWNTZWFyY2hUZXJtfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IHJvbGU9XCJsaXN0XCIgY2xhc3NOYW1lPXtzdHlsZXMudmFsdWVMaXN0V3JhcHBlcn0+XG4gICAgICAgICAgICAgICAgPEZpeGVkU2l6ZUxpc3RcbiAgICAgICAgICAgICAgICAgIGhlaWdodD17TWF0aC5taW4oNDUwLCBtZXRyaWNDb3VudCAqIExJU1RfSVRFTV9TSVpFKX1cbiAgICAgICAgICAgICAgICAgIGl0ZW1Db3VudD17bWV0cmljQ291bnR9XG4gICAgICAgICAgICAgICAgICBpdGVtU2l6ZT17TElTVF9JVEVNX1NJWkV9XG4gICAgICAgICAgICAgICAgICBpdGVtS2V5PXsoaSkgPT4gKG1ldHJpY3MhLnZhbHVlcyBhcyBGYWNldHRhYmxlVmFsdWVbXSlbaV0ubmFtZX1cbiAgICAgICAgICAgICAgICAgIHdpZHRoPXszMDB9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3R9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgeyh7IGluZGV4LCBzdHlsZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWV0cmljcz8udmFsdWVzPy5baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXtzdHlsZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvbUxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e21ldHJpY3MhLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZT8ubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3ZhbHVlLmRldGFpbHN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZT17dmFsdWU/LnNlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tNZXRyaWN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFRlcm09e21ldHJpY1NlYXJjaFRlcm19XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA8L0ZpeGVkU2l6ZUxpc3Q+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICAgICAgPExhYmVsIGRlc2NyaXB0aW9uPVwiT25jZSBsYWJlbCB2YWx1ZXMgYXJlIHNlbGVjdGVkLCBvbmx5IHBvc3NpYmxlIGxhYmVsIGNvbWJpbmF0aW9ucyBhcmUgc2hvd24uXCI+XG4gICAgICAgICAgICAgICAgMi4gU2VsZWN0IGxhYmVscyB0byBzZWFyY2ggaW5cbiAgICAgICAgICAgICAgPC9MYWJlbD5cbiAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlTGFiZWxTZWFyY2h9XG4gICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiRmlsdGVyIGV4cHJlc3Npb24gZm9yIGxhYmVsXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtsYWJlbFNlYXJjaFRlcm19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIHsvKiBVc2luZyBmaXhlZCBoZWlnaHQgaGVyZSB0byBwcmV2ZW50IGp1bXB5IGxheW91dCAqL31cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5saXN0fSBzdHlsZT17eyBoZWlnaHQ6IDEyMCB9fT5cbiAgICAgICAgICAgICAgICB7bm9uTWV0cmljTGFiZWxzLm1hcCgobGFiZWwpID0+IChcbiAgICAgICAgICAgICAgICAgIDxQcm9tTGFiZWxcbiAgICAgICAgICAgICAgICAgICAga2V5PXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsYWJlbC5sb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e2xhYmVsLnNlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICBoaWRkZW49e2xhYmVsLmhpZGRlbn1cbiAgICAgICAgICAgICAgICAgICAgZmFjZXRzPXtsYWJlbC5mYWNldHN9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja0xhYmVsfVxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hUZXJtPXtsYWJlbFNlYXJjaFRlcm19XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICAgICAgPExhYmVsIGRlc2NyaXB0aW9uPVwiVXNlIHRoZSBzZWFyY2ggZmllbGQgdG8gZmluZCB2YWx1ZXMgYWNyb3NzIHNlbGVjdGVkIGxhYmVscy5cIj5cbiAgICAgICAgICAgICAgICAzLiBTZWxlY3QgKG11bHRpcGxlKSB2YWx1ZXMgZm9yIHlvdXIgbGFiZWxzXG4gICAgICAgICAgICAgIDwvTGFiZWw+XG4gICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZVZhbHVlU2VhcmNofVxuICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkZpbHRlciBleHByZXNzaW9uIGZvciBsYWJlbCB2YWx1ZXNcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlU2VhcmNoVGVybX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3RBcmVhfSByZWY9e3RoaXMudmFsdWVMaXN0c1JlZn0+XG4gICAgICAgICAgICAgICAge3NlbGVjdGVkTGFiZWxzLm1hcCgobGFiZWwpID0+IChcbiAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cImxpc3RcIlxuICAgICAgICAgICAgICAgICAgICBrZXk9e2xhYmVsLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2BWYWx1ZXMgZm9yICR7bGFiZWwubmFtZX1gfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3RXcmFwcGVyfVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlVGl0bGV9PlxuICAgICAgICAgICAgICAgICAgICAgIDxQcm9tTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e2xhYmVsLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsYWJlbC5sb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXtsYWJlbC5zZWxlY3RlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbj17bGFiZWwuaGlkZGVufVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBubyBmYWNldHMsIHdlIHdhbnQgdG8gc2hvdyBudW1iZXIgb2YgYWxsIGxhYmVsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZXRzPXtsYWJlbC5mYWNldHMgfHwgbGFiZWwudmFsdWVzPy5sZW5ndGh9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tMYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPEZpeGVkU2l6ZUxpc3RcbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9e01hdGgubWluKDIwMCwgTElTVF9JVEVNX1NJWkUgKiAobGFiZWwudmFsdWVzPy5sZW5ndGggfHwgMCkpfVxuICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db3VudD17bGFiZWwudmFsdWVzPy5sZW5ndGggfHwgMH1cbiAgICAgICAgICAgICAgICAgICAgICBpdGVtU2l6ZT17Mjh9XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbUtleT17KGkpID0+IChsYWJlbC52YWx1ZXMgYXMgRmFjZXR0YWJsZVZhbHVlW10pW2ldLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3R9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7KHsgaW5kZXgsIHN0eWxlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbGFiZWwudmFsdWVzPy5baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UHJvbUxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlPy5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXt2YWx1ZT8uc2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFRlcm09e3ZhbHVlU2VhcmNoVGVybX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgPC9GaXhlZFNpemVMaXN0PlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvSG9yaXpvbnRhbEdyb3VwPlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc2VjdGlvbn0+XG4gICAgICAgICAgPExhYmVsPjQuIFJlc3VsdGluZyBzZWxlY3RvcjwvTGFiZWw+XG4gICAgICAgICAgPGRpdiBhcmlhLWxhYmVsPVwic2VsZWN0b3JcIiBjbGFzc05hbWU9e3N0eWxlcy5zZWxlY3Rvcn0+XG4gICAgICAgICAgICB7c2VsZWN0b3J9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3ZhbGlkYXRpb25TdGF0dXMgJiYgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52YWxpZGF0aW9uU3RhdHVzfT57dmFsaWRhdGlvblN0YXR1c308L2Rpdj59XG4gICAgICAgICAgPEhvcml6b250YWxHcm91cD5cbiAgICAgICAgICAgIDxCdXR0b24gYXJpYS1sYWJlbD1cIlVzZSBzZWxlY3RvciBmb3IgcXVlcnkgYnV0dG9uXCIgZGlzYWJsZWQ9e2VtcHR5fSBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tSdW5RdWVyeX0+XG4gICAgICAgICAgICAgIFVzZSBxdWVyeVxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJVc2Ugc2VsZWN0b3IgYXMgbWV0cmljcyBidXR0b25cIlxuICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2VtcHR5fVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tSdW5SYXRlUXVlcnl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFVzZSBhcyByYXRlIHF1ZXJ5XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlZhbGlkYXRlIHN1Ym1pdCBidXR0b25cIlxuICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2VtcHR5fVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tWYWxpZGF0ZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgVmFsaWRhdGUgc2VsZWN0b3JcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPEJ1dHRvbiBhcmlhLWxhYmVsPVwiU2VsZWN0b3IgY2xlYXIgYnV0dG9uXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9e3RoaXMub25DbGlja0NsZWFyfT5cbiAgICAgICAgICAgICAgQ2xlYXJcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2N4KHN0eWxlcy5zdGF0dXMsIChzdGF0dXMgfHwgZXJyb3IpICYmIHN0eWxlcy5zdGF0dXNTaG93aW5nKX0+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17ZXJyb3IgPyBzdHlsZXMuZXJyb3IgOiAnJ30+e2Vycm9yIHx8IHN0YXR1c308L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L0hvcml6b250YWxHcm91cD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBQcm9tZXRoZXVzTWV0cmljc0Jyb3dzZXIgPSB3aXRoVGhlbWUoVW50aGVtZWRQcm9tZXRoZXVzTWV0cmljc0Jyb3dzZXIpO1xuIiwiaW1wb3J0IFJlYWN0LCB7IFN1c3BlbnNlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBQcm9wcyB9IGZyb20gJy4vTW9uYWNvUXVlcnlGaWVsZFByb3BzJztcblxuY29uc3QgRmllbGQgPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcInByb20tcXVlcnktZmllbGRcIiAqLyAnLi9Nb25hY29RdWVyeUZpZWxkJykpO1xuXG5leHBvcnQgY29uc3QgTW9uYWNvUXVlcnlGaWVsZExhenkgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtudWxsfT5cbiAgICAgIDxGaWVsZCB7Li4ucHJvcHN9IC8+XG4gICAgPC9TdXNwZW5zZT5cbiAgKTtcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBNb25hY29RdWVyeUZpZWxkTGF6eSB9IGZyb20gJy4vTW9uYWNvUXVlcnlGaWVsZExhenknO1xuaW1wb3J0IHsgUHJvcHMgYXMgTW9uYWNvUHJvcHMgfSBmcm9tICcuL01vbmFjb1F1ZXJ5RmllbGRQcm9wcyc7XG5cbnR5cGUgUHJvcHMgPSBPbWl0PE1vbmFjb1Byb3BzLCAnb25SdW5RdWVyeScgfCAnb25CbHVyJz4gJiB7XG4gIG9uQ2hhbmdlOiAocXVlcnk6IHN0cmluZykgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbiAgcnVuUXVlcnlPbkJsdXI6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgY29uc3QgTW9uYWNvUXVlcnlGaWVsZFdyYXBwZXIgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IGxhc3RSdW5WYWx1ZVJlZiA9IHVzZVJlZjxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgeyBydW5RdWVyeU9uQmx1ciwgb25SdW5RdWVyeSwgb25DaGFuZ2UsIC4uLnJlc3QgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGhhbmRsZVJ1blF1ZXJ5ID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICBsYXN0UnVuVmFsdWVSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIG9uQ2hhbmdlKHZhbHVlKTtcbiAgICBvblJ1blF1ZXJ5KCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQmx1ciA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHJ1blF1ZXJ5T25CbHVyKSB7XG4gICAgICAvLyBydW4gaGFuZGxlUnVuUXVlcnkgb25seSBpZiB0aGUgY3VycmVudCB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbGFzdC10aW1lLWV4ZWN1dGVkIHZhbHVlXG4gICAgICBpZiAodmFsdWUgIT09IGxhc3RSdW5WYWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGhhbmRsZVJ1blF1ZXJ5KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25DaGFuZ2UodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gPE1vbmFjb1F1ZXJ5RmllbGRMYXp5IG9uUnVuUXVlcnk9e2hhbmRsZVJ1blF1ZXJ5fSBvbkJsdXI9e2hhbmRsZUJsdXJ9IHsuLi5yZXN0fSAvPjtcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgRnVuY3Rpb25Db21wb25lbnQsIEZvcm1FdmVudCwgdXNlTWVtbywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgSW5saW5lRmllbGQsIElubGluZUZpZWxkUm93LCBJbmxpbmVTd2l0Y2gsIElucHV0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgSHR0cFNldHRpbmdzQmFzZVByb3BzIH0gZnJvbSAnQGdyYWZhbmEvdWkvc3JjL2NvbXBvbmVudHMvRGF0YVNvdXJjZVNldHRpbmdzL3R5cGVzJztcblxuaW1wb3J0IHsgS25vd25BenVyZUNsb3VkcywgQXp1cmVDcmVkZW50aWFscyB9IGZyb20gJy4vQXp1cmVDcmVkZW50aWFscyc7XG5pbXBvcnQgeyBnZXRDcmVkZW50aWFscywgdXBkYXRlQ3JlZGVudGlhbHMgfSBmcm9tICcuL0F6dXJlQ3JlZGVudGlhbHNDb25maWcnO1xuaW1wb3J0IHsgQXp1cmVDcmVkZW50aWFsc0Zvcm0gfSBmcm9tICcuL0F6dXJlQ3JlZGVudGlhbHNGb3JtJztcblxuZXhwb3J0IGNvbnN0IEF6dXJlQXV0aFNldHRpbmdzOiBGdW5jdGlvbkNvbXBvbmVudDxIdHRwU2V0dGluZ3NCYXNlUHJvcHM+ID0gKHByb3BzOiBIdHRwU2V0dGluZ3NCYXNlUHJvcHMpID0+IHtcbiAgY29uc3QgeyBkYXRhU291cmNlQ29uZmlnLCBvbkNoYW5nZSB9ID0gcHJvcHM7XG5cbiAgY29uc3QgW292ZXJyaWRlQXVkaWVuY2VBbGxvd2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KFxuICAgIGNvbmZpZy5mZWF0dXJlVG9nZ2xlcy5wcm9tZXRoZXVzQXp1cmVPdmVycmlkZUF1ZGllbmNlIHx8ICEhZGF0YVNvdXJjZUNvbmZpZy5qc29uRGF0YS5henVyZUVuZHBvaW50UmVzb3VyY2VJZFxuICApO1xuICBjb25zdCBbb3ZlcnJpZGVBdWRpZW5jZUNoZWNrZWQsIHNldE92ZXJyaWRlQXVkaWVuY2VDaGVja2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KFxuICAgICEhZGF0YVNvdXJjZUNvbmZpZy5qc29uRGF0YS5henVyZUVuZHBvaW50UmVzb3VyY2VJZFxuICApO1xuXG4gIGNvbnN0IGNyZWRlbnRpYWxzID0gdXNlTWVtbygoKSA9PiBnZXRDcmVkZW50aWFscyhkYXRhU291cmNlQ29uZmlnKSwgW2RhdGFTb3VyY2VDb25maWddKTtcblxuICBjb25zdCBvbkNyZWRlbnRpYWxzQ2hhbmdlID0gKGNyZWRlbnRpYWxzOiBBenVyZUNyZWRlbnRpYWxzKTogdm9pZCA9PiB7XG4gICAgb25DaGFuZ2UodXBkYXRlQ3JlZGVudGlhbHMoZGF0YVNvdXJjZUNvbmZpZywgY3JlZGVudGlhbHMpKTtcbiAgfTtcblxuICBjb25zdCBvbk92ZXJyaWRlQXVkaWVuY2VDaGFuZ2UgPSAoZXY6IEZvcm1FdmVudDxIVE1MSW5wdXRFbGVtZW50Pik6IHZvaWQgPT4ge1xuICAgIHNldE92ZXJyaWRlQXVkaWVuY2VDaGVja2VkKGV2LmN1cnJlbnRUYXJnZXQuY2hlY2tlZCk7XG4gICAgaWYgKCFldi5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgLi4uZGF0YVNvdXJjZUNvbmZpZyxcbiAgICAgICAganNvbkRhdGE6IHsgLi4uZGF0YVNvdXJjZUNvbmZpZy5qc29uRGF0YSwgYXp1cmVFbmRwb2ludFJlc291cmNlSWQ6IHVuZGVmaW5lZCB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uUmVzb3VyY2VJZENoYW5nZSA9IChldjogRm9ybUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KTogdm9pZCA9PiB7XG4gICAgaWYgKG92ZXJyaWRlQXVkaWVuY2VDaGVja2VkKSB7XG4gICAgICBvbkNoYW5nZSh7XG4gICAgICAgIC4uLmRhdGFTb3VyY2VDb25maWcsXG4gICAgICAgIGpzb25EYXRhOiB7IC4uLmRhdGFTb3VyY2VDb25maWcuanNvbkRhdGEsIGF6dXJlRW5kcG9pbnRSZXNvdXJjZUlkOiBldi5jdXJyZW50VGFyZ2V0LnZhbHVlIH0sXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGg2PkF6dXJlIEF1dGhlbnRpY2F0aW9uPC9oNj5cbiAgICAgIDxBenVyZUNyZWRlbnRpYWxzRm9ybVxuICAgICAgICBtYW5hZ2VkSWRlbnRpdHlFbmFibGVkPXtjb25maWcuYXp1cmUubWFuYWdlZElkZW50aXR5RW5hYmxlZH1cbiAgICAgICAgY3JlZGVudGlhbHM9e2NyZWRlbnRpYWxzfVxuICAgICAgICBhenVyZUNsb3VkT3B0aW9ucz17S25vd25BenVyZUNsb3Vkc31cbiAgICAgICAgb25DcmVkZW50aWFsc0NoYW5nZT17b25DcmVkZW50aWFsc0NoYW5nZX1cbiAgICAgIC8+XG4gICAgICB7b3ZlcnJpZGVBdWRpZW5jZUFsbG93ZWQgJiYgKFxuICAgICAgICA8PlxuICAgICAgICAgIDxoNj5BenVyZSBDb25maWd1cmF0aW9uPC9oNj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0tZ3JvdXBcIj5cbiAgICAgICAgICAgIDxJbmxpbmVGaWVsZFJvdz5cbiAgICAgICAgICAgICAgPElubGluZUZpZWxkIGxhYmVsV2lkdGg9ezI2fSBsYWJlbD1cIk92ZXJyaWRlIEFBRCBhdWRpZW5jZVwiPlxuICAgICAgICAgICAgICAgIDxJbmxpbmVTd2l0Y2ggdmFsdWU9e292ZXJyaWRlQXVkaWVuY2VDaGVja2VkfSBvbkNoYW5nZT17b25PdmVycmlkZUF1ZGllbmNlQ2hhbmdlfSAvPlxuICAgICAgICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgICAgICAgPC9JbmxpbmVGaWVsZFJvdz5cbiAgICAgICAgICAgIHtvdmVycmlkZUF1ZGllbmNlQ2hlY2tlZCAmJiAoXG4gICAgICAgICAgICAgIDxJbmxpbmVGaWVsZFJvdz5cbiAgICAgICAgICAgICAgICA8SW5saW5lRmllbGQgbGFiZWxXaWR0aD17MjZ9IGxhYmVsPVwiUmVzb3VyY2UgSURcIj5cbiAgICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3aWR0aC0zMFwiXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtkYXRhU291cmNlQ29uZmlnLmpzb25EYXRhLmF6dXJlRW5kcG9pbnRSZXNvdXJjZUlkIHx8ICcnfVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25SZXNvdXJjZUlkQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgICAgICAgICA8L0lubGluZUZpZWxkUm93PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgICApfVxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXp1cmVBdXRoU2V0dGluZ3M7XG4iLCJpbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuZXhwb3J0IGVudW0gQXp1cmVDbG91ZCB7XG4gIFB1YmxpYyA9ICdBenVyZUNsb3VkJyxcbiAgQ2hpbmEgPSAnQXp1cmVDaGluYUNsb3VkJyxcbiAgVVNHb3Zlcm5tZW50ID0gJ0F6dXJlVVNHb3Zlcm5tZW50JyxcbiAgR2VybWFueSA9ICdBenVyZUdlcm1hbkNsb3VkJyxcbiAgTm9uZSA9ICcnLFxufVxuXG5leHBvcnQgY29uc3QgS25vd25BenVyZUNsb3VkcyA9IFtcbiAgeyB2YWx1ZTogQXp1cmVDbG91ZC5QdWJsaWMsIGxhYmVsOiAnQXp1cmUnIH0sXG4gIHsgdmFsdWU6IEF6dXJlQ2xvdWQuQ2hpbmEsIGxhYmVsOiAnQXp1cmUgQ2hpbmEnIH0sXG4gIHsgdmFsdWU6IEF6dXJlQ2xvdWQuVVNHb3Zlcm5tZW50LCBsYWJlbDogJ0F6dXJlIFVTIEdvdmVybm1lbnQnIH0sXG4gIHsgdmFsdWU6IEF6dXJlQ2xvdWQuR2VybWFueSwgbGFiZWw6ICdBenVyZSBHZXJtYW55JyB9LFxuXSBhcyBTZWxlY3RhYmxlVmFsdWVbXTtcblxuZXhwb3J0IHR5cGUgQXp1cmVBdXRoVHlwZSA9ICdtc2knIHwgJ2NsaWVudHNlY3JldCc7XG5cbmV4cG9ydCB0eXBlIENvbmNlYWxlZFNlY3JldCA9IHN5bWJvbDtcblxuaW50ZXJmYWNlIEF6dXJlQ3JlZGVudGlhbHNCYXNlIHtcbiAgYXV0aFR5cGU6IEF6dXJlQXV0aFR5cGU7XG4gIGRlZmF1bHRTdWJzY3JpcHRpb25JZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBenVyZU1hbmFnZWRJZGVudGl0eUNyZWRlbnRpYWxzIGV4dGVuZHMgQXp1cmVDcmVkZW50aWFsc0Jhc2Uge1xuICBhdXRoVHlwZTogJ21zaSc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXp1cmVDbGllbnRTZWNyZXRDcmVkZW50aWFscyBleHRlbmRzIEF6dXJlQ3JlZGVudGlhbHNCYXNlIHtcbiAgYXV0aFR5cGU6ICdjbGllbnRzZWNyZXQnO1xuICBhenVyZUNsb3VkPzogc3RyaW5nO1xuICB0ZW5hbnRJZD86IHN0cmluZztcbiAgY2xpZW50SWQ/OiBzdHJpbmc7XG4gIGNsaWVudFNlY3JldD86IHN0cmluZyB8IENvbmNlYWxlZFNlY3JldDtcbn1cblxuZXhwb3J0IHR5cGUgQXp1cmVDcmVkZW50aWFscyA9IEF6dXJlTWFuYWdlZElkZW50aXR5Q3JlZGVudGlhbHMgfCBBenVyZUNsaWVudFNlY3JldENyZWRlbnRpYWxzO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDcmVkZW50aWFsc0NvbXBsZXRlKGNyZWRlbnRpYWxzOiBBenVyZUNyZWRlbnRpYWxzKTogYm9vbGVhbiB7XG4gIHN3aXRjaCAoY3JlZGVudGlhbHMuYXV0aFR5cGUpIHtcbiAgICBjYXNlICdtc2knOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnY2xpZW50c2VjcmV0JzpcbiAgICAgIHJldHVybiAhIShjcmVkZW50aWFscy5henVyZUNsb3VkICYmIGNyZWRlbnRpYWxzLnRlbmFudElkICYmIGNyZWRlbnRpYWxzLmNsaWVudElkICYmIGNyZWRlbnRpYWxzLmNsaWVudFNlY3JldCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGFTb3VyY2VTZXR0aW5ncyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5cbmltcG9ydCB7IEF6dXJlQ2xvdWQsIEF6dXJlQ3JlZGVudGlhbHMsIENvbmNlYWxlZFNlY3JldCB9IGZyb20gJy4vQXp1cmVDcmVkZW50aWFscyc7XG5cbmNvbnN0IGNvbmNlYWxlZDogQ29uY2VhbGVkU2VjcmV0ID0gU3ltYm9sKCdDb25jZWFsZWQgY2xpZW50IHNlY3JldCcpO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0QXp1cmVDbG91ZCgpOiBzdHJpbmcge1xuICByZXR1cm4gY29uZmlnLmF6dXJlLmNsb3VkIHx8IEF6dXJlQ2xvdWQuUHVibGljO1xufVxuXG5mdW5jdGlvbiBnZXRTZWNyZXQob3B0aW9uczogRGF0YVNvdXJjZVNldHRpbmdzPGFueSwgYW55Pik6IHVuZGVmaW5lZCB8IHN0cmluZyB8IENvbmNlYWxlZFNlY3JldCB7XG4gIGlmIChvcHRpb25zLnNlY3VyZUpzb25GaWVsZHMuYXp1cmVDbGllbnRTZWNyZXQpIHtcbiAgICAvLyBUaGUgc2VjcmV0IGlzIGNvbmNlYWxlZCBvbiBzZXJ2ZXJcbiAgICByZXR1cm4gY29uY2VhbGVkO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNlY3JldCA9IG9wdGlvbnMuc2VjdXJlSnNvbkRhdGE/LmF6dXJlQ2xpZW50U2VjcmV0O1xuICAgIHJldHVybiB0eXBlb2Ygc2VjcmV0ID09PSAnc3RyaW5nJyAmJiBzZWNyZXQubGVuZ3RoID4gMCA/IHNlY3JldCA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQ3JlZGVudGlhbHMob3B0aW9uczogRGF0YVNvdXJjZVNldHRpbmdzPGFueSwgYW55Pik6IGJvb2xlYW4ge1xuICByZXR1cm4gISFvcHRpb25zLmpzb25EYXRhLmF6dXJlQ3JlZGVudGlhbHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0Q3JlZGVudGlhbHMoKTogQXp1cmVDcmVkZW50aWFscyB7XG4gIGlmIChjb25maWcuYXp1cmUubWFuYWdlZElkZW50aXR5RW5hYmxlZCkge1xuICAgIHJldHVybiB7IGF1dGhUeXBlOiAnbXNpJyB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGF1dGhUeXBlOiAnY2xpZW50c2VjcmV0JywgYXp1cmVDbG91ZDogZ2V0RGVmYXVsdEF6dXJlQ2xvdWQoKSB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVkZW50aWFscyhvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+KTogQXp1cmVDcmVkZW50aWFscyB7XG4gIGNvbnN0IGNyZWRlbnRpYWxzID0gb3B0aW9ucy5qc29uRGF0YS5henVyZUNyZWRlbnRpYWxzIGFzIEF6dXJlQ3JlZGVudGlhbHMgfCB1bmRlZmluZWQ7XG5cbiAgLy8gSWYgbm8gY3JlZGVudGlhbHMgc2F2ZWQsIHRoZW4gcmV0dXJuIGVtcHR5IGNyZWRlbnRpYWxzXG4gIC8vIG9mIHR5cGUgYmFzZWQgb24gd2hldGhlciB0aGUgbWFuYWdlZCBpZGVudGl0eSBlbmFibGVkXG4gIGlmICghY3JlZGVudGlhbHMpIHtcbiAgICByZXR1cm4gZ2V0RGVmYXVsdENyZWRlbnRpYWxzKCk7XG4gIH1cblxuICBzd2l0Y2ggKGNyZWRlbnRpYWxzLmF1dGhUeXBlKSB7XG4gICAgY2FzZSAnbXNpJzpcbiAgICAgIGlmIChjb25maWcuYXp1cmUubWFuYWdlZElkZW50aXR5RW5hYmxlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGF1dGhUeXBlOiAnbXNpJyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGF1dGhlbnRpY2F0aW9uIHR5cGUgaXMgbWFuYWdlZCBpZGVudGl0eSBidXQgbWFuYWdlZCBpZGVudGl0aWVzIHdlcmUgZGlzYWJsZWQgaW4gR3JhZmFuYSBjb25maWcsXG4gICAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIGZhbGxiYWNrIHRvIGFuIGVtcHR5IGFwcCByZWdpc3RyYXRpb24gKGNsaWVudCBzZWNyZXQpIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhdXRoVHlwZTogJ2NsaWVudHNlY3JldCcsXG4gICAgICAgICAgYXp1cmVDbG91ZDogZ2V0RGVmYXVsdEF6dXJlQ2xvdWQoKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdjbGllbnRzZWNyZXQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aFR5cGU6ICdjbGllbnRzZWNyZXQnLFxuICAgICAgICBhenVyZUNsb3VkOiBjcmVkZW50aWFscy5henVyZUNsb3VkIHx8IGdldERlZmF1bHRBenVyZUNsb3VkKCksXG4gICAgICAgIHRlbmFudElkOiBjcmVkZW50aWFscy50ZW5hbnRJZCxcbiAgICAgICAgY2xpZW50SWQ6IGNyZWRlbnRpYWxzLmNsaWVudElkLFxuICAgICAgICBjbGllbnRTZWNyZXQ6IGdldFNlY3JldChvcHRpb25zKSxcbiAgICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNyZWRlbnRpYWxzKFxuICBvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+LFxuICBjcmVkZW50aWFsczogQXp1cmVDcmVkZW50aWFsc1xuKTogRGF0YVNvdXJjZVNldHRpbmdzPGFueSwgYW55PiB7XG4gIHN3aXRjaCAoY3JlZGVudGlhbHMuYXV0aFR5cGUpIHtcbiAgICBjYXNlICdtc2knOlxuICAgICAgaWYgKCFjb25maWcuYXp1cmUubWFuYWdlZElkZW50aXR5RW5hYmxlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbmFnZWQgSWRlbnRpdHkgYXV0aGVudGljYXRpb24gaXMgbm90IGVuYWJsZWQgaW4gR3JhZmFuYSBjb25maWcuJyk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGpzb25EYXRhOiB7XG4gICAgICAgICAgLi4ub3B0aW9ucy5qc29uRGF0YSxcbiAgICAgICAgICBhenVyZUNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgICBhdXRoVHlwZTogJ21zaScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuXG4gICAgY2FzZSAnY2xpZW50c2VjcmV0JzpcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGpzb25EYXRhOiB7XG4gICAgICAgICAgLi4ub3B0aW9ucy5qc29uRGF0YSxcbiAgICAgICAgICBhenVyZUNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgICBhdXRoVHlwZTogJ2NsaWVudHNlY3JldCcsXG4gICAgICAgICAgICBhenVyZUNsb3VkOiBjcmVkZW50aWFscy5henVyZUNsb3VkIHx8IGdldERlZmF1bHRBenVyZUNsb3VkKCksXG4gICAgICAgICAgICB0ZW5hbnRJZDogY3JlZGVudGlhbHMudGVuYW50SWQsXG4gICAgICAgICAgICBjbGllbnRJZDogY3JlZGVudGlhbHMuY2xpZW50SWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgc2VjdXJlSnNvbkRhdGE6IHtcbiAgICAgICAgICAuLi5vcHRpb25zLnNlY3VyZUpzb25EYXRhLFxuICAgICAgICAgIGF6dXJlQ2xpZW50U2VjcmV0OlxuICAgICAgICAgICAgdHlwZW9mIGNyZWRlbnRpYWxzLmNsaWVudFNlY3JldCA9PT0gJ3N0cmluZycgJiYgY3JlZGVudGlhbHMuY2xpZW50U2VjcmV0Lmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgPyBjcmVkZW50aWFscy5jbGllbnRTZWNyZXRcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIHNlY3VyZUpzb25GaWVsZHM6IHtcbiAgICAgICAgICAuLi5vcHRpb25zLnNlY3VyZUpzb25GaWVsZHMsXG4gICAgICAgICAgYXp1cmVDbGllbnRTZWNyZXQ6IHR5cGVvZiBjcmVkZW50aWFscy5jbGllbnRTZWNyZXQgPT09ICdzeW1ib2wnLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRDcmVkZW50aWFscyhvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+KTogUGFydGlhbDxEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+PiB7XG4gIHJldHVybiB7XG4gICAganNvbkRhdGE6IHtcbiAgICAgIC4uLm9wdGlvbnMuanNvbkRhdGEsXG4gICAgICBhenVyZUNyZWRlbnRpYWxzOiBnZXREZWZhdWx0Q3JlZGVudGlhbHMoKSxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRDcmVkZW50aWFscyhvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+KTogUGFydGlhbDxEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+PiB7XG4gIHJldHVybiB7XG4gICAganNvbkRhdGE6IHtcbiAgICAgIC4uLm9wdGlvbnMuanNvbkRhdGEsXG4gICAgICBhenVyZUF1dGg6IHVuZGVmaW5lZCxcbiAgICAgIGF6dXJlQ3JlZGVudGlhbHM6IHVuZGVmaW5lZCxcbiAgICAgIGF6dXJlRW5kcG9pbnRSZXNvdXJjZUlkOiB1bmRlZmluZWQsXG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDaGFuZ2VFdmVudCwgRnVuY3Rpb25Db21wb25lbnQsIHVzZUVmZmVjdCwgdXNlUmVkdWNlciwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgSW5saW5lRm9ybUxhYmVsLCBCdXR0b24gfSBmcm9tICdAZ3JhZmFuYS91aS9zcmMvY29tcG9uZW50cyc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJ0BncmFmYW5hL3VpL3NyYy9jb21wb25lbnRzL0Zvcm1zL0xlZ2FjeS9JbnB1dC9JbnB1dCc7XG5pbXBvcnQgeyBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aS9zcmMvY29tcG9uZW50cy9Gb3Jtcy9MZWdhY3kvU2VsZWN0L1NlbGVjdCc7XG5cbmltcG9ydCB7IEF6dXJlQXV0aFR5cGUsIEF6dXJlQ3JlZGVudGlhbHMsIGlzQ3JlZGVudGlhbHNDb21wbGV0ZSB9IGZyb20gJy4vQXp1cmVDcmVkZW50aWFscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBtYW5hZ2VkSWRlbnRpdHlFbmFibGVkOiBib29sZWFuO1xuICBjcmVkZW50aWFsczogQXp1cmVDcmVkZW50aWFscztcbiAgYXp1cmVDbG91ZE9wdGlvbnM/OiBTZWxlY3RhYmxlVmFsdWVbXTtcbiAgb25DcmVkZW50aWFsc0NoYW5nZTogKHVwZGF0ZWRDcmVkZW50aWFsczogQXp1cmVDcmVkZW50aWFscykgPT4gdm9pZDtcbiAgZ2V0U3Vic2NyaXB0aW9ucz86ICgpID0+IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+O1xufVxuXG5jb25zdCBhdXRoVHlwZU9wdGlvbnM6IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxBenVyZUF1dGhUeXBlPj4gPSBbXG4gIHtcbiAgICB2YWx1ZTogJ21zaScsXG4gICAgbGFiZWw6ICdNYW5hZ2VkIElkZW50aXR5JyxcbiAgfSxcbiAge1xuICAgIHZhbHVlOiAnY2xpZW50c2VjcmV0JyxcbiAgICBsYWJlbDogJ0FwcCBSZWdpc3RyYXRpb24nLFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IEF6dXJlQ3JlZGVudGlhbHNGb3JtOiBGdW5jdGlvbkNvbXBvbmVudDxQcm9wcz4gPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY3JlZGVudGlhbHMsIGF6dXJlQ2xvdWRPcHRpb25zLCBvbkNyZWRlbnRpYWxzQ2hhbmdlLCBnZXRTdWJzY3JpcHRpb25zIH0gPSBwcm9wcztcbiAgY29uc3QgaGFzUmVxdWlyZWRGaWVsZHMgPSBpc0NyZWRlbnRpYWxzQ29tcGxldGUoY3JlZGVudGlhbHMpO1xuXG4gIGNvbnN0IFtzdWJzY3JpcHRpb25zLCBzZXRTdWJzY3JpcHRpb25zXSA9IHVzZVN0YXRlPEFycmF5PFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+Pj4oW10pO1xuICBjb25zdCBbbG9hZFN1YnNjcmlwdGlvbnNDbGlja2VkLCBvbkxvYWRTdWJzY3JpcHRpb25zXSA9IHVzZVJlZHVjZXIoKHZhbCkgPT4gdmFsICsgMSwgMCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFnZXRTdWJzY3JpcHRpb25zIHx8ICFoYXNSZXF1aXJlZEZpZWxkcykge1xuICAgICAgdXBkYXRlU3Vic2NyaXB0aW9ucyhbXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGdldFN1YnNjcmlwdGlvbnMoKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGlmICghY2FuY2VsZWQpIHtcbiAgICAgICAgdXBkYXRlU3Vic2NyaXB0aW9ucyhyZXN1bHQsIGxvYWRTdWJzY3JpcHRpb25zQ2xpY2tlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIFRoaXMgZWZmZWN0IGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IG9uY2UgaW5pdGlhbGx5IGFuZCBvbiBMb2FkIFN1YnNjcmlwdGlvbnMgY2xpY2tcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtsb2FkU3Vic2NyaXB0aW9uc0NsaWNrZWRdKTtcblxuICBjb25zdCB1cGRhdGVTdWJzY3JpcHRpb25zID0gKHJlY2VpdmVkOiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPj4sIGF1dG9TZWxlY3QgPSBmYWxzZSkgPT4ge1xuICAgIHNldFN1YnNjcmlwdGlvbnMocmVjZWl2ZWQpO1xuICAgIGlmIChnZXRTdWJzY3JpcHRpb25zKSB7XG4gICAgICBpZiAoYXV0b1NlbGVjdCAmJiAhY3JlZGVudGlhbHMuZGVmYXVsdFN1YnNjcmlwdGlvbklkICYmIHJlY2VpdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gU2VsZWN0aW5nIHRoZSBkZWZhdWx0IHN1YnNjcmlwdGlvbiBpZiBzdWJzY3JpcHRpb25zIHJlY2VpdmVkIGJ1dCBubyBkZWZhdWx0IHN1YnNjcmlwdGlvbiBzZWxlY3RlZFxuICAgICAgICBvblN1YnNjcmlwdGlvbkNoYW5nZShyZWNlaXZlZFswXSk7XG4gICAgICB9IGVsc2UgaWYgKGNyZWRlbnRpYWxzLmRlZmF1bHRTdWJzY3JpcHRpb25JZCkge1xuICAgICAgICBjb25zdCBmb3VuZCA9IHJlY2VpdmVkLmZpbmQoKG9wdCkgPT4gb3B0LnZhbHVlID09PSBjcmVkZW50aWFscy5kZWZhdWx0U3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgLy8gVW5zZWxlY3RpbmcgdGhlIGRlZmF1bHQgc3Vic2NyaXB0aW9uIGlmIGl0IGlzbid0IGZvdW5kIGFtb25nIHRoZSByZWNlaXZlZCBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgb25TdWJzY3JpcHRpb25DaGFuZ2UodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbkF1dGhUeXBlQ2hhbmdlID0gKHNlbGVjdGVkOiBTZWxlY3RhYmxlVmFsdWU8QXp1cmVBdXRoVHlwZT4pID0+IHtcbiAgICBpZiAob25DcmVkZW50aWFsc0NoYW5nZSkge1xuICAgICAgc2V0U3Vic2NyaXB0aW9ucyhbXSk7XG4gICAgICBjb25zdCB1cGRhdGVkOiBBenVyZUNyZWRlbnRpYWxzID0ge1xuICAgICAgICAuLi5jcmVkZW50aWFscyxcbiAgICAgICAgYXV0aFR5cGU6IHNlbGVjdGVkLnZhbHVlIHx8ICdtc2knLFxuICAgICAgICBkZWZhdWx0U3Vic2NyaXB0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBvbkNyZWRlbnRpYWxzQ2hhbmdlKHVwZGF0ZWQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbkF6dXJlQ2xvdWRDaGFuZ2UgPSAoc2VsZWN0ZWQ6IFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+KSA9PiB7XG4gICAgaWYgKG9uQ3JlZGVudGlhbHNDaGFuZ2UgJiYgY3JlZGVudGlhbHMuYXV0aFR5cGUgPT09ICdjbGllbnRzZWNyZXQnKSB7XG4gICAgICBzZXRTdWJzY3JpcHRpb25zKFtdKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQ6IEF6dXJlQ3JlZGVudGlhbHMgPSB7XG4gICAgICAgIC4uLmNyZWRlbnRpYWxzLFxuICAgICAgICBhenVyZUNsb3VkOiBzZWxlY3RlZC52YWx1ZSxcbiAgICAgICAgZGVmYXVsdFN1YnNjcmlwdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgICAgb25DcmVkZW50aWFsc0NoYW5nZSh1cGRhdGVkKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25UZW5hbnRJZENoYW5nZSA9IChldmVudDogQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBpZiAob25DcmVkZW50aWFsc0NoYW5nZSAmJiBjcmVkZW50aWFscy5hdXRoVHlwZSA9PT0gJ2NsaWVudHNlY3JldCcpIHtcbiAgICAgIHNldFN1YnNjcmlwdGlvbnMoW10pO1xuICAgICAgY29uc3QgdXBkYXRlZDogQXp1cmVDcmVkZW50aWFscyA9IHtcbiAgICAgICAgLi4uY3JlZGVudGlhbHMsXG4gICAgICAgIHRlbmFudElkOiBldmVudC50YXJnZXQudmFsdWUsXG4gICAgICAgIGRlZmF1bHRTdWJzY3JpcHRpb25JZDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIG9uQ3JlZGVudGlhbHNDaGFuZ2UodXBkYXRlZCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uQ2xpZW50SWRDaGFuZ2UgPSAoZXZlbnQ6IENoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKG9uQ3JlZGVudGlhbHNDaGFuZ2UgJiYgY3JlZGVudGlhbHMuYXV0aFR5cGUgPT09ICdjbGllbnRzZWNyZXQnKSB7XG4gICAgICBzZXRTdWJzY3JpcHRpb25zKFtdKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQ6IEF6dXJlQ3JlZGVudGlhbHMgPSB7XG4gICAgICAgIC4uLmNyZWRlbnRpYWxzLFxuICAgICAgICBjbGllbnRJZDogZXZlbnQudGFyZ2V0LnZhbHVlLFxuICAgICAgICBkZWZhdWx0U3Vic2NyaXB0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBvbkNyZWRlbnRpYWxzQ2hhbmdlKHVwZGF0ZWQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbkNsaWVudFNlY3JldENoYW5nZSA9IChldmVudDogQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBpZiAob25DcmVkZW50aWFsc0NoYW5nZSAmJiBjcmVkZW50aWFscy5hdXRoVHlwZSA9PT0gJ2NsaWVudHNlY3JldCcpIHtcbiAgICAgIHNldFN1YnNjcmlwdGlvbnMoW10pO1xuICAgICAgY29uc3QgdXBkYXRlZDogQXp1cmVDcmVkZW50aWFscyA9IHtcbiAgICAgICAgLi4uY3JlZGVudGlhbHMsXG4gICAgICAgIGNsaWVudFNlY3JldDogZXZlbnQudGFyZ2V0LnZhbHVlLFxuICAgICAgICBkZWZhdWx0U3Vic2NyaXB0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBvbkNyZWRlbnRpYWxzQ2hhbmdlKHVwZGF0ZWQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbkNsaWVudFNlY3JldFJlc2V0ID0gKCkgPT4ge1xuICAgIGlmIChvbkNyZWRlbnRpYWxzQ2hhbmdlICYmIGNyZWRlbnRpYWxzLmF1dGhUeXBlID09PSAnY2xpZW50c2VjcmV0Jykge1xuICAgICAgc2V0U3Vic2NyaXB0aW9ucyhbXSk7XG4gICAgICBjb25zdCB1cGRhdGVkOiBBenVyZUNyZWRlbnRpYWxzID0ge1xuICAgICAgICAuLi5jcmVkZW50aWFscyxcbiAgICAgICAgY2xpZW50U2VjcmV0OiAnJyxcbiAgICAgICAgZGVmYXVsdFN1YnNjcmlwdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgICAgb25DcmVkZW50aWFsc0NoYW5nZSh1cGRhdGVkKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25TdWJzY3JpcHRpb25DaGFuZ2UgPSAoc2VsZWN0ZWQ6IFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+IHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgaWYgKG9uQ3JlZGVudGlhbHNDaGFuZ2UpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQ6IEF6dXJlQ3JlZGVudGlhbHMgPSB7XG4gICAgICAgIC4uLmNyZWRlbnRpYWxzLFxuICAgICAgICBkZWZhdWx0U3Vic2NyaXB0aW9uSWQ6IHNlbGVjdGVkPy52YWx1ZSxcbiAgICAgIH07XG4gICAgICBvbkNyZWRlbnRpYWxzQ2hhbmdlKHVwZGF0ZWQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1ncm91cFwiPlxuICAgICAge3Byb3BzLm1hbmFnZWRJZGVudGl0eUVuYWJsZWQgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsIGNsYXNzTmFtZT1cIndpZHRoLTEyXCIgdG9vbHRpcD1cIkNob29zZSB0aGUgdHlwZSBvZiBhdXRoZW50aWNhdGlvbiB0byBBenVyZSBzZXJ2aWNlc1wiPlxuICAgICAgICAgICAgICBBdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTE1XCJcbiAgICAgICAgICAgICAgdmFsdWU9e2F1dGhUeXBlT3B0aW9ucy5maW5kKChvcHQpID0+IG9wdC52YWx1ZSA9PT0gY3JlZGVudGlhbHMuYXV0aFR5cGUpfVxuICAgICAgICAgICAgICBvcHRpb25zPXthdXRoVHlwZU9wdGlvbnN9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkF1dGhUeXBlQ2hhbmdlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAge2NyZWRlbnRpYWxzLmF1dGhUeXBlID09PSAnY2xpZW50c2VjcmV0JyAmJiAoXG4gICAgICAgIDw+XG4gICAgICAgICAge2F6dXJlQ2xvdWRPcHRpb25zICYmIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgICAgPElubGluZUZvcm1MYWJlbCBjbGFzc05hbWU9XCJ3aWR0aC0xMlwiIHRvb2x0aXA9XCJDaG9vc2UgYW4gQXp1cmUgQ2xvdWRcIj5cbiAgICAgICAgICAgICAgICAgIEF6dXJlIENsb3VkXG4gICAgICAgICAgICAgICAgPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2lkdGgtMTVcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e2F6dXJlQ2xvdWRPcHRpb25zLmZpbmQoKG9wdCkgPT4gb3B0LnZhbHVlID09PSBjcmVkZW50aWFscy5henVyZUNsb3VkKX1cbiAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e2F6dXJlQ2xvdWRPcHRpb25zfVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQXp1cmVDbG91ZENoYW5nZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgY2xhc3NOYW1lPVwid2lkdGgtMTJcIj5EaXJlY3RvcnkgKHRlbmFudCkgSUQ8L0lubGluZUZvcm1MYWJlbD5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3aWR0aC0xNVwiPlxuICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2lkdGgtMzBcIlxuICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e2NyZWRlbnRpYWxzLnRlbmFudElkIHx8ICcnfVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uVGVuYW50SWRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgPElubGluZUZvcm1MYWJlbCBjbGFzc05hbWU9XCJ3aWR0aC0xMlwiPkFwcGxpY2F0aW9uIChjbGllbnQpIElEPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkdGgtMTVcIj5cbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTMwXCJcbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtjcmVkZW50aWFscy5jbGllbnRJZCB8fCAnJ31cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNsaWVudElkQ2hhbmdlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3R5cGVvZiBjcmVkZW50aWFscy5jbGllbnRTZWNyZXQgPT09ICdzeW1ib2wnID8gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsIGNsYXNzTmFtZT1cIndpZHRoLTEyXCI+Q2xpZW50IFNlY3JldDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgICAgICAgIDxJbnB1dCBjbGFzc05hbWU9XCJ3aWR0aC0yNVwiIHBsYWNlaG9sZGVyPVwiY29uZmlndXJlZFwiIGRpc2FibGVkPXt0cnVlfSAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtd2lkdGgtMzAgZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICAgICAgICAgIDxCdXR0b24gdmFyaWFudD1cInNlY29uZGFyeVwiIHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXtvbkNsaWVudFNlY3JldFJlc2V0fT5cbiAgICAgICAgICAgICAgICAgICAgcmVzZXRcbiAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgY2xhc3NOYW1lPVwid2lkdGgtMTJcIj5DbGllbnQgU2VjcmV0PC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3aWR0aC0xNVwiPlxuICAgICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTMwXCJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcIlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Y3JlZGVudGlhbHMuY2xpZW50U2VjcmV0IHx8ICcnfVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25DbGllbnRTZWNyZXRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvPlxuICAgICAgKX1cbiAgICAgIHtnZXRTdWJzY3JpcHRpb25zICYmIChcbiAgICAgICAgPD5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgPElubGluZUZvcm1MYWJlbCBjbGFzc05hbWU9XCJ3aWR0aC0xMlwiPkRlZmF1bHQgU3Vic2NyaXB0aW9uPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkdGgtMjVcIj5cbiAgICAgICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgICAgICB2YWx1ZT17XG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzLmRlZmF1bHRTdWJzY3JpcHRpb25JZFxuICAgICAgICAgICAgICAgICAgICAgID8gc3Vic2NyaXB0aW9ucy5maW5kKChvcHQpID0+IG9wdC52YWx1ZSA9PT0gY3JlZGVudGlhbHMuZGVmYXVsdFN1YnNjcmlwdGlvbklkKVxuICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvcHRpb25zPXtzdWJzY3JpcHRpb25zfVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uU3Vic2NyaXB0aW9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXdpZHRoLTMwIGdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbkxvYWRTdWJzY3JpcHRpb25zfVxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFoYXNSZXF1aXJlZEZpZWxkc31cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBMb2FkIFN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXp1cmVDcmVkZW50aWFsc0Zvcm07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBTSUdWNENvbm5lY3Rpb25Db25maWcgfSBmcm9tICdAZ3JhZmFuYS9hd3Mtc2RrJztcbmltcG9ydCB7IERhdGFTb3VyY2VQbHVnaW5PcHRpb25zRWRpdG9yUHJvcHMsIERhdGFTb3VyY2VTZXR0aW5ncyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgQWxlcnRpbmdTZXR0aW5ncywgRGF0YVNvdXJjZUh0dHBTZXR0aW5ncywgQWxlcnQgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdhcHAvY29yZS9jb25maWcnO1xuaW1wb3J0IHsgZ2V0QWxsQWxlcnRtYW5hZ2VyRGF0YVNvdXJjZXMgfSBmcm9tICdhcHAvZmVhdHVyZXMvYWxlcnRpbmcvdW5pZmllZC91dGlscy9hbGVydG1hbmFnZXInO1xuXG5pbXBvcnQgeyBQcm9tT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgQXp1cmVBdXRoU2V0dGluZ3MgfSBmcm9tICcuL0F6dXJlQXV0aFNldHRpbmdzJztcbmltcG9ydCB7IGhhc0NyZWRlbnRpYWxzLCBzZXREZWZhdWx0Q3JlZGVudGlhbHMsIHJlc2V0Q3JlZGVudGlhbHMgfSBmcm9tICcuL0F6dXJlQ3JlZGVudGlhbHNDb25maWcnO1xuaW1wb3J0IHsgUHJvbVNldHRpbmdzIH0gZnJvbSAnLi9Qcm9tU2V0dGluZ3MnO1xuXG5leHBvcnQgdHlwZSBQcm9wcyA9IERhdGFTb3VyY2VQbHVnaW5PcHRpb25zRWRpdG9yUHJvcHM8UHJvbU9wdGlvbnM+O1xuZXhwb3J0IGNvbnN0IENvbmZpZ0VkaXRvciA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgeyBvcHRpb25zLCBvbk9wdGlvbnNDaGFuZ2UgfSA9IHByb3BzO1xuICBjb25zdCBhbGVydG1hbmFnZXJzID0gZ2V0QWxsQWxlcnRtYW5hZ2VyRGF0YVNvdXJjZXMoKTtcblxuICBjb25zdCBhenVyZUF1dGhTZXR0aW5ncyA9IHtcbiAgICBhenVyZUF1dGhTdXBwb3J0ZWQ6ICEhY29uZmlnLmZlYXR1cmVUb2dnbGVzLnByb21ldGhldXNfYXp1cmVfYXV0aCxcbiAgICBnZXRBenVyZUF1dGhFbmFibGVkOiAoY29uZmlnOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+KTogYm9vbGVhbiA9PiBoYXNDcmVkZW50aWFscyhjb25maWcpLFxuICAgIHNldEF6dXJlQXV0aEVuYWJsZWQ6IChjb25maWc6IERhdGFTb3VyY2VTZXR0aW5nczxhbnksIGFueT4sIGVuYWJsZWQ6IGJvb2xlYW4pID0+XG4gICAgICBlbmFibGVkID8gc2V0RGVmYXVsdENyZWRlbnRpYWxzKGNvbmZpZykgOiByZXNldENyZWRlbnRpYWxzKGNvbmZpZyksXG4gICAgYXp1cmVTZXR0aW5nc1VJOiBBenVyZUF1dGhTZXR0aW5ncyxcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7b3B0aW9ucy5hY2Nlc3MgPT09ICdkaXJlY3QnICYmIChcbiAgICAgICAgPEFsZXJ0IHRpdGxlPVwiRGVwcmVjYXRpb24gTm90aWNlXCIgc2V2ZXJpdHk9XCJ3YXJuaW5nXCI+XG4gICAgICAgICAgQnJvd3NlciBhY2Nlc3MgbW9kZSBpbiB0aGUgUHJvbWV0aGV1cyBkYXRhc291cmNlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICAgICAgICA8L0FsZXJ0PlxuICAgICAgKX1cblxuICAgICAgPERhdGFTb3VyY2VIdHRwU2V0dGluZ3NcbiAgICAgICAgZGVmYXVsdFVybD1cImh0dHA6Ly9sb2NhbGhvc3Q6OTA5MFwiXG4gICAgICAgIGRhdGFTb3VyY2VDb25maWc9e29wdGlvbnN9XG4gICAgICAgIHNob3dBY2Nlc3NPcHRpb25zPXt0cnVlfVxuICAgICAgICBvbkNoYW5nZT17b25PcHRpb25zQ2hhbmdlfVxuICAgICAgICBzaWdWNEF1dGhUb2dnbGVFbmFibGVkPXtjb25maWcuc2lnVjRBdXRoRW5hYmxlZH1cbiAgICAgICAgYXp1cmVBdXRoU2V0dGluZ3M9e2F6dXJlQXV0aFNldHRpbmdzfVxuICAgICAgICByZW5kZXJTaWdWNEVkaXRvcj17PFNJR1Y0Q29ubmVjdGlvbkNvbmZpZyB7Li4ucHJvcHN9PjwvU0lHVjRDb25uZWN0aW9uQ29uZmlnPn1cbiAgICAgIC8+XG5cbiAgICAgIDxBbGVydGluZ1NldHRpbmdzPFByb21PcHRpb25zPlxuICAgICAgICBhbGVydG1hbmFnZXJEYXRhU291cmNlcz17YWxlcnRtYW5hZ2Vyc31cbiAgICAgICAgb3B0aW9ucz17b3B0aW9uc31cbiAgICAgICAgb25PcHRpb25zQ2hhbmdlPXtvbk9wdGlvbnNDaGFuZ2V9XG4gICAgICAvPlxuXG4gICAgICA8UHJvbVNldHRpbmdzIG9wdGlvbnM9e29wdGlvbnN9IG9uT3B0aW9uc0NoYW5nZT17b25PcHRpb25zQ2hhbmdlfSAvPlxuICAgIDwvPlxuICApO1xufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IHNlbGVjdG9ycyB9IGZyb20gJ0BncmFmYW5hL2UyZS1zZWxlY3RvcnMnO1xuaW1wb3J0IHsgRGF0YVNvdXJjZVBpY2tlciB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgQnV0dG9uLCBJbmxpbmVGaWVsZCwgSW5saW5lU3dpdGNoLCBJbnB1dCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24gfSBmcm9tICcuLi90eXBlcyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIHZhbHVlOiBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbjtcbiAgb25DaGFuZ2U6ICh2YWx1ZTogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24pID0+IHZvaWQ7XG4gIG9uRGVsZXRlOiAoKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRXhlbXBsYXJTZXR0aW5nKHsgdmFsdWUsIG9uQ2hhbmdlLCBvbkRlbGV0ZSB9OiBQcm9wcykge1xuICBjb25zdCBbaXNJbnRlcm5hbExpbmssIHNldElzSW50ZXJuYWxMaW5rXSA9IHVzZVN0YXRlKEJvb2xlYW4odmFsdWUuZGF0YXNvdXJjZVVpZCkpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWdyb3VwXCI+XG4gICAgICA8SW5saW5lRmllbGQgbGFiZWw9XCJJbnRlcm5hbCBsaW5rXCIgbGFiZWxXaWR0aD17MjR9PlxuICAgICAgICA8PlxuICAgICAgICAgIDxJbmxpbmVTd2l0Y2hcbiAgICAgICAgICAgIHZhbHVlPXtpc0ludGVybmFsTGlua31cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e3NlbGVjdG9ycy5jb21wb25lbnRzLkRhdGFTb3VyY2UuUHJvbWV0aGV1cy5jb25maWdQYWdlLmludGVybmFsTGlua1N3aXRjaH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXYpID0+IHNldElzSW50ZXJuYWxMaW5rKGV2LmN1cnJlbnRUYXJnZXQuY2hlY2tlZCl9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICB2YXJpYW50PVwiZGVzdHJ1Y3RpdmVcIlxuICAgICAgICAgICAgdGl0bGU9XCJSZW1vdmUgbGlua1wiXG4gICAgICAgICAgICBpY29uPVwidGltZXNcIlxuICAgICAgICAgICAgb25DbGljaz17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIG9uRGVsZXRlKCk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NgXG4gICAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiA4cHg7XG4gICAgICAgICAgICBgfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvPlxuICAgICAgPC9JbmxpbmVGaWVsZD5cblxuICAgICAge2lzSW50ZXJuYWxMaW5rID8gKFxuICAgICAgICA8SW5saW5lRmllbGRcbiAgICAgICAgICBsYWJlbD1cIkRhdGEgc291cmNlXCJcbiAgICAgICAgICBsYWJlbFdpZHRoPXsyNH1cbiAgICAgICAgICB0b29sdGlwPVwiVGhlIGRhdGEgc291cmNlIHRoZSBleGVtcGxhciBpcyBnb2luZyB0byBuYXZpZ2F0ZSB0by5cIlxuICAgICAgICA+XG4gICAgICAgICAgPERhdGFTb3VyY2VQaWNrZXJcbiAgICAgICAgICAgIHRyYWNpbmc9e3RydWV9XG4gICAgICAgICAgICBjdXJyZW50PXt2YWx1ZS5kYXRhc291cmNlVWlkfVxuICAgICAgICAgICAgbm9EZWZhdWx0PXt0cnVlfVxuICAgICAgICAgICAgd2lkdGg9ezQwfVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhkcykgPT5cbiAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGFzb3VyY2VVaWQ6IGRzLnVpZCxcbiAgICAgICAgICAgICAgICB1cmw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgKSA6IChcbiAgICAgICAgPElubGluZUZpZWxkXG4gICAgICAgICAgbGFiZWw9XCJVUkxcIlxuICAgICAgICAgIGxhYmVsV2lkdGg9ezI0fVxuICAgICAgICAgIHRvb2x0aXA9XCJUaGUgVVJMIG9mIHRoZSB0cmFjZSBiYWNrZW5kIHRoZSB1c2VyIHdvdWxkIGdvIHRvIHNlZSBpdHMgdHJhY2UuXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJodHRwczovL2V4YW1wbGUuY29tLyR7X192YWx1ZS5yYXd9XCJcbiAgICAgICAgICAgIHNwZWxsQ2hlY2s9e2ZhbHNlfVxuICAgICAgICAgICAgd2lkdGg9ezQwfVxuICAgICAgICAgICAgdmFsdWU9e3ZhbHVlLnVybH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhc291cmNlVWlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdXJsOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvSW5saW5lRmllbGQ+XG4gICAgICApfVxuXG4gICAgICA8SW5saW5lRmllbGRcbiAgICAgICAgbGFiZWw9XCJVUkwgTGFiZWxcIlxuICAgICAgICBsYWJlbFdpZHRoPXsyNH1cbiAgICAgICAgdG9vbHRpcD1cIlVzZSB0byBvdmVycmlkZSB0aGUgYnV0dG9uIGxhYmVsIG9uIHRoZSBleGVtcGxhciB0cmFjZUlEIGZpZWxkLlwiXG4gICAgICA+XG4gICAgICAgIDxJbnB1dFxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiR28gdG8gZXhhbXBsZS5jb21cIlxuICAgICAgICAgIHNwZWxsQ2hlY2s9e2ZhbHNlfVxuICAgICAgICAgIHdpZHRoPXs0MH1cbiAgICAgICAgICB2YWx1ZT17dmFsdWUudXJsRGlzcGxheUxhYmVsfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+XG4gICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICB1cmxEaXNwbGF5TGFiZWw6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgLz5cbiAgICAgIDwvSW5saW5lRmllbGQ+XG4gICAgICA8SW5saW5lRmllbGRcbiAgICAgICAgbGFiZWw9XCJMYWJlbCBuYW1lXCJcbiAgICAgICAgbGFiZWxXaWR0aD17MjR9XG4gICAgICAgIHRvb2x0aXA9XCJUaGUgbmFtZSBvZiB0aGUgZmllbGQgaW4gdGhlIGxhYmVscyBvYmplY3QgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBnZXQgdGhlIHRyYWNlSUQuXCJcbiAgICAgID5cbiAgICAgICAgPElucHV0XG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJ0cmFjZUlEXCJcbiAgICAgICAgICBzcGVsbENoZWNrPXtmYWxzZX1cbiAgICAgICAgICB3aWR0aD17NDB9XG4gICAgICAgICAgdmFsdWU9e3ZhbHVlLm5hbWV9XG4gICAgICAgICAgb25DaGFuZ2U9eyhldmVudCkgPT5cbiAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgIG5hbWU6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgLz5cbiAgICAgIDwvSW5saW5lRmllbGQ+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgc2VsZWN0b3JzIH0gZnJvbSAnQGdyYWZhbmEvZTJlLXNlbGVjdG9ycyc7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgRXhlbXBsYXJTZXR0aW5nIGZyb20gJy4vRXhlbXBsYXJTZXR0aW5nJztcblxudHlwZSBQcm9wcyA9IHtcbiAgb3B0aW9ucz86IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uW107XG4gIG9uQ2hhbmdlOiAodmFsdWU6IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uW10pID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gRXhlbXBsYXJzU2V0dGluZ3MoeyBvcHRpb25zLCBvbkNoYW5nZSB9OiBQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8aDMgY2xhc3NOYW1lPVwicGFnZS1oZWFkaW5nXCI+RXhlbXBsYXJzPC9oMz5cblxuICAgICAge29wdGlvbnMgJiZcbiAgICAgICAgb3B0aW9ucy5tYXAoKG9wdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEV4ZW1wbGFyU2V0dGluZ1xuICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICB2YWx1ZT17b3B0aW9ufVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KG5ld0ZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IFsuLi5vcHRpb25zXTtcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25zLnNwbGljZShpbmRleCwgMSwgbmV3RmllbGQpO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKG5ld09wdGlvbnMpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBvbkRlbGV0ZT17KCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBbLi4ub3B0aW9uc107XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKG5ld09wdGlvbnMpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cblxuICAgICAgPEJ1dHRvblxuICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgYXJpYS1sYWJlbD17c2VsZWN0b3JzLmNvbXBvbmVudHMuRGF0YVNvdXJjZS5Qcm9tZXRoZXVzLmNvbmZpZ1BhZ2UuZXhlbXBsYXJzQWRkQnV0dG9ufVxuICAgICAgICBjbGFzc05hbWU9e2Nzc2BcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xuICAgICAgICBgfVxuICAgICAgICBpY29uPVwicGx1c1wiXG4gICAgICAgIG9uQ2xpY2s9eyhldmVudCkgPT4ge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IFsuLi4ob3B0aW9ucyB8fCBbXSksIHsgbmFtZTogJ3RyYWNlSUQnIH1dO1xuICAgICAgICAgIG9uQ2hhbmdlKG5ld09wdGlvbnMpO1xuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICBBZGRcbiAgICAgIDwvQnV0dG9uPlxuICAgIDwvPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IFN5bnRoZXRpY0V2ZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQge1xuICBEYXRhU291cmNlUGx1Z2luT3B0aW9uc0VkaXRvclByb3BzLFxuICBvblVwZGF0ZURhdGFzb3VyY2VKc29uRGF0YU9wdGlvbkNoZWNrZWQsXG4gIFNlbGVjdGFibGVWYWx1ZSxcbiAgdXBkYXRlRGF0YXNvdXJjZVBsdWdpbkpzb25EYXRhT3B0aW9uLFxufSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7XG4gIElubGluZUZpZWxkLFxuICBJbmxpbmVTd2l0Y2gsXG4gIEV2ZW50c1dpdGhWYWxpZGF0aW9uLFxuICBJbmxpbmVGb3JtTGFiZWwsXG4gIExlZ2FjeUZvcm1zLFxuICByZWdleFZhbGlkYXRpb24sXG59IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUHJvbU9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IEV4ZW1wbGFyc1NldHRpbmdzIH0gZnJvbSAnLi9FeGVtcGxhcnNTZXR0aW5ncyc7XG5jb25zdCB7IFNlbGVjdCwgSW5wdXQsIEZvcm1GaWVsZCB9ID0gTGVnYWN5Rm9ybXM7XG5cbmNvbnN0IGh0dHBPcHRpb25zID0gW1xuICB7IHZhbHVlOiAnUE9TVCcsIGxhYmVsOiAnUE9TVCcgfSxcbiAgeyB2YWx1ZTogJ0dFVCcsIGxhYmVsOiAnR0VUJyB9LFxuXTtcblxudHlwZSBQcm9wcyA9IFBpY2s8RGF0YVNvdXJjZVBsdWdpbk9wdGlvbnNFZGl0b3JQcm9wczxQcm9tT3B0aW9ucz4sICdvcHRpb25zJyB8ICdvbk9wdGlvbnNDaGFuZ2UnPjtcblxuZXhwb3J0IGNvbnN0IFByb21TZXR0aW5ncyA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgeyBvcHRpb25zLCBvbk9wdGlvbnNDaGFuZ2UgfSA9IHByb3BzO1xuXG4gIC8vIFdlIGFyZSBleHBsaWNpdGx5IGFkZGluZyBodHRwTWV0aG9kIHNvIGl0IGlzIGNvcnJlY3RseSBkaXNwbGF5ZWQgaW4gZHJvcGRvd24uIFRoaXMgd2F5LCBpdCBpcyBtb3JlIHByZWRpY3RhYmxlIGZvciB1c2Vycy5cblxuICBpZiAoIW9wdGlvbnMuanNvbkRhdGEuaHR0cE1ldGhvZCkge1xuICAgIG9wdGlvbnMuanNvbkRhdGEuaHR0cE1ldGhvZCA9ICdQT1NUJztcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1ncm91cFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICA8Rm9ybUZpZWxkXG4gICAgICAgICAgICAgIGxhYmVsPVwiU2NyYXBlIGludGVydmFsXCJcbiAgICAgICAgICAgICAgbGFiZWxXaWR0aD17MTN9XG4gICAgICAgICAgICAgIGlucHV0RWw9e1xuICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2lkdGgtNlwiXG4gICAgICAgICAgICAgICAgICB2YWx1ZT17b3B0aW9ucy5qc29uRGF0YS50aW1lSW50ZXJ2YWx9XG4gICAgICAgICAgICAgICAgICBzcGVsbENoZWNrPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiMTVzXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZUhhbmRsZXIoJ3RpbWVJbnRlcnZhbCcsIG9wdGlvbnMsIG9uT3B0aW9uc0NoYW5nZSl9XG4gICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXZlbnRzPXtwcm9tU2V0dGluZ3NWYWxpZGF0aW9uRXZlbnRzfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9vbHRpcD1cIlNldCB0aGlzIHRvIHRoZSB0eXBpY2FsIHNjcmFwZSBhbmQgZXZhbHVhdGlvbiBpbnRlcnZhbCBjb25maWd1cmVkIGluIFByb21ldGhldXMuIERlZmF1bHRzIHRvIDE1cy5cIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgIDxGb3JtRmllbGRcbiAgICAgICAgICAgICAgbGFiZWw9XCJRdWVyeSB0aW1lb3V0XCJcbiAgICAgICAgICAgICAgbGFiZWxXaWR0aD17MTN9XG4gICAgICAgICAgICAgIGlucHV0RWw9e1xuICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2lkdGgtNlwiXG4gICAgICAgICAgICAgICAgICB2YWx1ZT17b3B0aW9ucy5qc29uRGF0YS5xdWVyeVRpbWVvdXR9XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VIYW5kbGVyKCdxdWVyeVRpbWVvdXQnLCBvcHRpb25zLCBvbk9wdGlvbnNDaGFuZ2UpfVxuICAgICAgICAgICAgICAgICAgc3BlbGxDaGVjaz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIjYwc1wiXG4gICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXZlbnRzPXtwcm9tU2V0dGluZ3NWYWxpZGF0aW9uRXZlbnRzfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9vbHRpcD1cIlNldCB0aGUgUHJvbWV0aGV1cyBxdWVyeSB0aW1lb3V0LlwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgPElubGluZUZvcm1MYWJlbFxuICAgICAgICAgICAgd2lkdGg9ezEzfVxuICAgICAgICAgICAgdG9vbHRpcD1cIllvdSBjYW4gdXNlIGVpdGhlciBQT1NUIG9yIEdFVCBIVFRQIG1ldGhvZCB0byBxdWVyeSB5b3VyIFByb21ldGhldXMgZGF0YSBzb3VyY2UuIFBPU1QgaXMgdGhlIHJlY29tbWVuZGVkIG1ldGhvZCBhcyBpdCBhbGxvd3MgYmlnZ2VyIHF1ZXJpZXMuIENoYW5nZSB0aGlzIHRvIEdFVCBpZiB5b3UgaGF2ZSBhIFByb21ldGhldXMgdmVyc2lvbiBvbGRlciB0aGFuIDIuMSBvciBpZiBQT1NUIHJlcXVlc3RzIGFyZSByZXN0cmljdGVkIGluIHlvdXIgbmV0d29yay5cIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIEhUVFAgTWV0aG9kXG4gICAgICAgICAgPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlNlbGVjdCBIVFRQIG1ldGhvZFwiXG4gICAgICAgICAgICBvcHRpb25zPXtodHRwT3B0aW9uc31cbiAgICAgICAgICAgIHZhbHVlPXtodHRwT3B0aW9ucy5maW5kKChvKSA9PiBvLnZhbHVlID09PSBvcHRpb25zLmpzb25EYXRhLmh0dHBNZXRob2QpfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlSGFuZGxlcignaHR0cE1ldGhvZCcsIG9wdGlvbnMsIG9uT3B0aW9uc0NoYW5nZSl9XG4gICAgICAgICAgICB3aWR0aD17N31cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGgzIGNsYXNzTmFtZT1cInBhZ2UtaGVhZGluZ1wiPk1pc2M8L2gzPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWdyb3VwXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgIDxJbmxpbmVGaWVsZFxuICAgICAgICAgICAgbGFiZWxXaWR0aD17Mjh9XG4gICAgICAgICAgICBsYWJlbD1cIkRpc2FibGUgbWV0cmljcyBsb29rdXBcIlxuICAgICAgICAgICAgdG9vbHRpcD1cIkNoZWNraW5nIHRoaXMgb3B0aW9uIHdpbGwgZGlzYWJsZSB0aGUgbWV0cmljcyBjaG9vc2VyIGFuZCBtZXRyaWMvbGFiZWwgc3VwcG9ydCBpbiB0aGUgcXVlcnkgZmllbGQncyBhdXRvY29tcGxldGUuIFRoaXMgaGVscHMgaWYgeW91IGhhdmUgcGVyZm9ybWFuY2UgaXNzdWVzIHdpdGggYmlnZ2VyIFByb21ldGhldXMgaW5zdGFuY2VzLlwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPElubGluZVN3aXRjaFxuICAgICAgICAgICAgICB2YWx1ZT17b3B0aW9ucy5qc29uRGF0YS5kaXNhYmxlTWV0cmljc0xvb2t1cCA/PyBmYWxzZX1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e29uVXBkYXRlRGF0YXNvdXJjZUpzb25EYXRhT3B0aW9uQ2hlY2tlZChwcm9wcywgJ2Rpc2FibGVNZXRyaWNzTG9va3VwJyl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvSW5saW5lRmllbGQ+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtIG1heC13aWR0aC0zMFwiPlxuICAgICAgICAgICAgPEZvcm1GaWVsZFxuICAgICAgICAgICAgICBsYWJlbD1cIkN1c3RvbSBxdWVyeSBwYXJhbWV0ZXJzXCJcbiAgICAgICAgICAgICAgbGFiZWxXaWR0aD17MTR9XG4gICAgICAgICAgICAgIHRvb2x0aXA9XCJBZGQgQ3VzdG9tIHBhcmFtZXRlcnMgdG8gYWxsIFByb21ldGhldXMgb3IgVGhhbm9zIHF1ZXJpZXMuXCJcbiAgICAgICAgICAgICAgaW5wdXRFbD17XG4gICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3aWR0aC0yNVwiXG4gICAgICAgICAgICAgICAgICB2YWx1ZT17b3B0aW9ucy5qc29uRGF0YS5jdXN0b21RdWVyeVBhcmFtZXRlcnN9XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VIYW5kbGVyKCdjdXN0b21RdWVyeVBhcmFtZXRlcnMnLCBvcHRpb25zLCBvbk9wdGlvbnNDaGFuZ2UpfVxuICAgICAgICAgICAgICAgICAgc3BlbGxDaGVjaz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkV4YW1wbGU6IG1heF9zb3VyY2VfcmVzb2x1dGlvbj01bSZ0aW1lb3V0PTEwXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPEV4ZW1wbGFyc1NldHRpbmdzXG4gICAgICAgIG9wdGlvbnM9e29wdGlvbnMuanNvbkRhdGEuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zfVxuICAgICAgICBvbkNoYW5nZT17KGV4ZW1wbGFyT3B0aW9ucykgPT5cbiAgICAgICAgICB1cGRhdGVEYXRhc291cmNlUGx1Z2luSnNvbkRhdGFPcHRpb24oXG4gICAgICAgICAgICB7IG9uT3B0aW9uc0NoYW5nZSwgb3B0aW9ucyB9LFxuICAgICAgICAgICAgJ2V4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucycsXG4gICAgICAgICAgICBleGVtcGxhck9wdGlvbnNcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIC8+XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgcHJvbVNldHRpbmdzVmFsaWRhdGlvbkV2ZW50cyA9IHtcbiAgW0V2ZW50c1dpdGhWYWxpZGF0aW9uLm9uQmx1cl06IFtcbiAgICByZWdleFZhbGlkYXRpb24oXG4gICAgICAvXiR8XlxcZCsobXN8W013ZGhtc3ldKSQvLFxuICAgICAgJ1ZhbHVlIGlzIG5vdCB2YWxpZCwgeW91IGNhbiB1c2UgbnVtYmVyIHdpdGggdGltZSB1bml0IHNwZWNpZmllcjogeSwgTSwgdywgZCwgaCwgbSwgcydcbiAgICApLFxuICBdLFxufTtcblxuZXhwb3J0IGNvbnN0IGdldFZhbHVlRnJvbUV2ZW50SXRlbSA9IChldmVudEl0ZW06IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+IHwgU2VsZWN0YWJsZVZhbHVlPHN0cmluZz4pID0+IHtcbiAgaWYgKCFldmVudEl0ZW0pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoZXZlbnRJdGVtLmhhc093blByb3BlcnR5KCdjdXJyZW50VGFyZ2V0JykpIHtcbiAgICByZXR1cm4gZXZlbnRJdGVtLmN1cnJlbnRUYXJnZXQudmFsdWU7XG4gIH1cblxuICByZXR1cm4gKGV2ZW50SXRlbSBhcyBTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPikudmFsdWU7XG59O1xuXG5jb25zdCBvbkNoYW5nZUhhbmRsZXIgPVxuICAoa2V5OiBrZXlvZiBQcm9tT3B0aW9ucywgb3B0aW9uczogUHJvcHNbJ29wdGlvbnMnXSwgb25PcHRpb25zQ2hhbmdlOiBQcm9wc1snb25PcHRpb25zQ2hhbmdlJ10pID0+XG4gIChldmVudEl0ZW06IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+IHwgU2VsZWN0YWJsZVZhbHVlPHN0cmluZz4pID0+IHtcbiAgICBvbk9wdGlvbnNDaGFuZ2Uoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGpzb25EYXRhOiB7XG4gICAgICAgIC4uLm9wdGlvbnMuanNvbkRhdGEsXG4gICAgICAgIFtrZXldOiBnZXRWYWx1ZUZyb21FdmVudEl0ZW0oZXZlbnRJdGVtKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH07XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGRlZmF1bHRzIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBMUlUgZnJvbSAnbHJ1LWNhY2hlJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmb3JrSm9pbiwgbGFzdFZhbHVlRnJvbSwgbWVyZ2UsIE9ic2VydmFibGUsIG9mLCBPcGVyYXRvckZ1bmN0aW9uLCBwaXBlLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBmaWx0ZXIsIG1hcCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQge1xuICBBbm5vdGF0aW9uRXZlbnQsXG4gIENvcmVBcHAsXG4gIERhdGFRdWVyeUVycm9yLFxuICBEYXRhUXVlcnlSZXF1ZXN0LFxuICBEYXRhUXVlcnlSZXNwb25zZSxcbiAgRGF0YVNvdXJjZUluc3RhbmNlU2V0dGluZ3MsXG4gIERhdGFTb3VyY2VXaXRoUXVlcnlFeHBvcnRTdXBwb3J0LFxuICBEYXRhU291cmNlV2l0aFF1ZXJ5SW1wb3J0U3VwcG9ydCxcbiAgZGF0ZU1hdGgsXG4gIERhdGVUaW1lLFxuICBBYnN0cmFjdFF1ZXJ5LFxuICBMb2FkaW5nU3RhdGUsXG4gIHJhbmdlVXRpbCxcbiAgU2NvcGVkVmFycyxcbiAgVGltZVJhbmdlLFxuICBEYXRhRnJhbWUsXG4gIGRhdGVUaW1lLFxufSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7XG4gIEJhY2tlbmRTcnZSZXF1ZXN0LFxuICBGZXRjaEVycm9yLFxuICBGZXRjaFJlc3BvbnNlLFxuICBnZXRCYWNrZW5kU3J2LFxuICBEYXRhU291cmNlV2l0aEJhY2tlbmQsXG4gIEJhY2tlbmREYXRhU291cmNlUmVzcG9uc2UsXG4gIHRvRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIGlzRmV0Y2hFcnJvcixcbn0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBCYWRnZSwgQmFkZ2VDb2xvciwgVG9vbHRpcCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IHNhZmVTdHJpbmdpZnlWYWx1ZSB9IGZyb20gJ2FwcC9jb3JlL3V0aWxzL2V4cGxvcmUnO1xuaW1wb3J0IHsgZGlzY292ZXJEYXRhU291cmNlRmVhdHVyZXMgfSBmcm9tICdhcHAvZmVhdHVyZXMvYWxlcnRpbmcvdW5pZmllZC9hcGkvYnVpbGRJbmZvJztcbmltcG9ydCB7IGdldFRpbWVTcnYsIFRpbWVTcnYgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGFzaGJvYXJkL3NlcnZpY2VzL1RpbWVTcnYnO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGVTcnYsIFRlbXBsYXRlU3J2IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL3RlbXBsYXRpbmcvdGVtcGxhdGVfc3J2JztcbmltcG9ydCB7IFByb21BcHBsaWNhdGlvbiwgUHJvbUFwaUZlYXR1cmVzIH0gZnJvbSAnYXBwL3R5cGVzL3VuaWZpZWQtYWxlcnRpbmctZHRvJztcblxuaW1wb3J0IHsgYWRkTGFiZWxUb1F1ZXJ5IH0gZnJvbSAnLi9hZGRfbGFiZWxfdG9fcXVlcnknO1xuaW1wb3J0IHsgQW5ub3RhdGlvblF1ZXJ5RWRpdG9yIH0gZnJvbSAnLi9jb21wb25lbnRzL0Fubm90YXRpb25RdWVyeUVkaXRvcic7XG5pbXBvcnQgUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXIgZnJvbSAnLi9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgeyBleHBhbmRSZWNvcmRpbmdSdWxlcyB9IGZyb20gJy4vbGFuZ3VhZ2VfdXRpbHMnO1xuaW1wb3J0IHsgcmVuZGVyTGVnZW5kRm9ybWF0IH0gZnJvbSAnLi9sZWdlbmQnO1xuaW1wb3J0IFByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkgZnJvbSAnLi9tZXRyaWNfZmluZF9xdWVyeSc7XG5pbXBvcnQgeyBnZXRJbml0SGludHMsIGdldFF1ZXJ5SGludHMgfSBmcm9tICcuL3F1ZXJ5X2hpbnRzJztcbmltcG9ydCB7IGdldE9yaWdpbmFsTWV0cmljTmFtZSwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1WMiB9IGZyb20gJy4vcmVzdWx0X3RyYW5zZm9ybWVyJztcbmltcG9ydCB7XG4gIEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uLFxuICBQcm9tRGF0YUVycm9yUmVzcG9uc2UsXG4gIFByb21EYXRhU3VjY2Vzc1Jlc3BvbnNlLFxuICBQcm9tRXhlbXBsYXJEYXRhLFxuICBQcm9tTWF0cml4RGF0YSxcbiAgUHJvbU9wdGlvbnMsXG4gIFByb21RdWVyeSxcbiAgUHJvbVF1ZXJ5UmVxdWVzdCxcbiAgUHJvbVF1ZXJ5VHlwZSxcbiAgUHJvbVNjYWxhckRhdGEsXG4gIFByb21WZWN0b3JEYXRhLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFByb21ldGhldXNWYXJpYWJsZVN1cHBvcnQgfSBmcm9tICcuL3ZhcmlhYmxlcyc7XG5cbmNvbnN0IEFOTk9UQVRJT05fUVVFUllfU1RFUF9ERUZBVUxUID0gJzYwcyc7XG5jb25zdCBHRVRfQU5EX1BPU1RfTUVUQURBVEFfRU5EUE9JTlRTID0gWydhcGkvdjEvcXVlcnknLCAnYXBpL3YxL3F1ZXJ5X3JhbmdlJywgJ2FwaS92MS9zZXJpZXMnLCAnYXBpL3YxL2xhYmVscyddO1xuXG5leHBvcnQgY2xhc3MgUHJvbWV0aGV1c0RhdGFzb3VyY2VcbiAgZXh0ZW5kcyBEYXRhU291cmNlV2l0aEJhY2tlbmQ8UHJvbVF1ZXJ5LCBQcm9tT3B0aW9ucz5cbiAgaW1wbGVtZW50cyBEYXRhU291cmNlV2l0aFF1ZXJ5SW1wb3J0U3VwcG9ydDxQcm9tUXVlcnk+LCBEYXRhU291cmNlV2l0aFF1ZXJ5RXhwb3J0U3VwcG9ydDxQcm9tUXVlcnk+XG57XG4gIHR5cGU6IHN0cmluZztcbiAgZWRpdG9yU3JjOiBzdHJpbmc7XG4gIHJ1bGVNYXBwaW5nczogeyBbaW5kZXg6IHN0cmluZ106IHN0cmluZyB9O1xuICB1cmw6IHN0cmluZztcbiAgaWQ6IG51bWJlcjtcbiAgZGlyZWN0VXJsOiBzdHJpbmc7XG4gIGFjY2VzczogJ2RpcmVjdCcgfCAncHJveHknO1xuICBiYXNpY0F1dGg6IGFueTtcbiAgd2l0aENyZWRlbnRpYWxzOiBhbnk7XG4gIG1ldHJpY3NOYW1lQ2FjaGUgPSBuZXcgTFJVPHN0cmluZywgc3RyaW5nW10+KHsgbWF4OiAxMCB9KTtcbiAgaW50ZXJ2YWw6IHN0cmluZztcbiAgcXVlcnlUaW1lb3V0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGh0dHBNZXRob2Q6IHN0cmluZztcbiAgbGFuZ3VhZ2VQcm92aWRlcjogUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXI7XG4gIGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uczogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25bXSB8IHVuZGVmaW5lZDtcbiAgbG9va3Vwc0Rpc2FibGVkOiBib29sZWFuO1xuICBjdXN0b21RdWVyeVBhcmFtZXRlcnM6IGFueTtcbiAgZXhlbXBsYXJzQXZhaWxhYmxlOiBib29sZWFuO1xuICBzdWJUeXBlOiBQcm9tQXBwbGljYXRpb247XG4gIHJ1bGVyRW5hYmxlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBpbnN0YW5jZVNldHRpbmdzOiBEYXRhU291cmNlSW5zdGFuY2VTZXR0aW5nczxQcm9tT3B0aW9ucz4sXG4gICAgcHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZVNydjogVGVtcGxhdGVTcnYgPSBnZXRUZW1wbGF0ZVNydigpLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGltZVNydjogVGltZVNydiA9IGdldFRpbWVTcnYoKSxcbiAgICBsYW5ndWFnZVByb3ZpZGVyPzogUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXJcbiAgKSB7XG4gICAgc3VwZXIoaW5zdGFuY2VTZXR0aW5ncyk7XG5cbiAgICB0aGlzLnR5cGUgPSAncHJvbWV0aGV1cyc7XG4gICAgdGhpcy5zdWJUeXBlID0gUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXM7XG4gICAgdGhpcy5ydWxlckVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVkaXRvclNyYyA9ICdhcHAvZmVhdHVyZXMvcHJvbWV0aGV1cy9wYXJ0aWFscy9xdWVyeS5lZGl0b3IuaHRtbCc7XG4gICAgdGhpcy5pZCA9IGluc3RhbmNlU2V0dGluZ3MuaWQ7XG4gICAgdGhpcy51cmwgPSBpbnN0YW5jZVNldHRpbmdzLnVybCE7XG4gICAgdGhpcy5hY2Nlc3MgPSBpbnN0YW5jZVNldHRpbmdzLmFjY2VzcztcbiAgICB0aGlzLmJhc2ljQXV0aCA9IGluc3RhbmNlU2V0dGluZ3MuYmFzaWNBdXRoO1xuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gaW5zdGFuY2VTZXR0aW5ncy53aXRoQ3JlZGVudGlhbHM7XG4gICAgdGhpcy5pbnRlcnZhbCA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEudGltZUludGVydmFsIHx8ICcxNXMnO1xuICAgIHRoaXMucXVlcnlUaW1lb3V0ID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5xdWVyeVRpbWVvdXQ7XG4gICAgdGhpcy5odHRwTWV0aG9kID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5odHRwTWV0aG9kIHx8ICdHRVQnO1xuICAgIC8vIGBkaXJlY3RVcmxgIGlzIG5ldmVyIHVuZGVmaW5lZCwgd2Ugc2V0IGl0IGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFmYW5hL2dyYWZhbmEvYmxvYi9tYWluL3BrZy9hcGkvZnJvbnRlbmRzZXR0aW5ncy5nbyNMMTA4XG4gICAgLy8gaGVyZSB3ZSBcImZhbGwgYmFja1wiIHRvIHRoaXMudXJsIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweSwgYnV0IGl0IHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICB0aGlzLmRpcmVjdFVybCA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEuZGlyZWN0VXJsID8/IHRoaXMudXJsO1xuICAgIHRoaXMuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5leGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM7XG4gICAgdGhpcy5ydWxlTWFwcGluZ3MgPSB7fTtcbiAgICB0aGlzLmxhbmd1YWdlUHJvdmlkZXIgPSBsYW5ndWFnZVByb3ZpZGVyID8/IG5ldyBQcm9tZXRoZXVzTGFuZ3VhZ2VQcm92aWRlcih0aGlzKTtcbiAgICB0aGlzLmxvb2t1cHNEaXNhYmxlZCA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEuZGlzYWJsZU1ldHJpY3NMb29rdXAgPz8gZmFsc2U7XG4gICAgdGhpcy5jdXN0b21RdWVyeVBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEuY3VzdG9tUXVlcnlQYXJhbWV0ZXJzKTtcbiAgICB0aGlzLnZhcmlhYmxlcyA9IG5ldyBQcm9tZXRoZXVzVmFyaWFibGVTdXBwb3J0KHRoaXMsIHRoaXMudGVtcGxhdGVTcnYsIHRoaXMudGltZVNydik7XG4gICAgdGhpcy5leGVtcGxhcnNBdmFpbGFibGUgPSB0cnVlO1xuXG4gICAgLy8gVGhpcyBuZWVkcyB0byBiZSBoZXJlIGFuZCBjYW5ub3QgYmUgc3RhdGljIGJlY2F1c2Ugb2YgaG93IGFubm90YXRpb25zIHR5cGluZyBhZmZlY3RzIGNhc3Rpbmcgb2YgZGF0YSBzb3VyY2VcbiAgICAvLyBvYmplY3RzIHRvIERhdGFTb3VyY2VBcGkgdHlwZXMuXG4gICAgLy8gV2UgZG9uJ3QgdXNlIHRoZSBkZWZhdWx0IHByb2Nlc3NpbmcgZm9yIHByb21ldGhldXMuXG4gICAgLy8gU2VlIHN0YW5kYXJkQW5ub3RhdGlvblN1cHBvcnQudHMvW3Nob3VsZFVzZU1hcHBpbmdVSXxzaG91bGRVc2VMZWdhY3lSdW5uZXJdXG4gICAgdGhpcy5hbm5vdGF0aW9ucyA9IHtcbiAgICAgIFF1ZXJ5RWRpdG9yOiBBbm5vdGF0aW9uUXVlcnlFZGl0b3IsXG4gICAgfTtcbiAgfVxuXG4gIGluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgdGhpcy5sb2FkUnVsZXMoKTtcbiAgICB0aGlzLmV4ZW1wbGFyc0F2YWlsYWJsZSA9IGF3YWl0IHRoaXMuYXJlRXhlbXBsYXJzQXZhaWxhYmxlKCk7XG4gIH07XG5cbiAgZ2V0UXVlcnlEaXNwbGF5VGV4dChxdWVyeTogUHJvbVF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5LmV4cHI7XG4gIH1cblxuICBfYWRkVHJhY2luZ0hlYWRlcnMoaHR0cE9wdGlvbnM6IFByb21RdWVyeVJlcXVlc3QsIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pikge1xuICAgIGh0dHBPcHRpb25zLmhlYWRlcnMgPSB7fTtcbiAgICBjb25zdCBwcm94eU1vZGUgPSAhdGhpcy51cmwubWF0Y2goL15odHRwLyk7XG4gICAgaWYgKHByb3h5TW9kZSkge1xuICAgICAgaHR0cE9wdGlvbnMuaGVhZGVyc1snWC1EYXNoYm9hcmQtSWQnXSA9IG9wdGlvbnMuZGFzaGJvYXJkSWQ7XG4gICAgICBodHRwT3B0aW9ucy5oZWFkZXJzWydYLVBhbmVsLUlkJ10gPSBvcHRpb25zLnBhbmVsSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFueSByZXF1ZXN0IGRvbmUgZnJvbSB0aGlzIGRhdGEgc291cmNlIHNob3VsZCBnbyB0aHJvdWdoIGhlcmUgYXMgaXQgY29udGFpbnMgc29tZSBjb21tb24gcHJvY2Vzc2luZyBmb3IgdGhlXG4gICAqIHJlcXVlc3QuIEFueSBwcm9jZXNzaW5nIGRvbmUgaGVyZSBuZWVkcyB0byBiZSBhbHNvIGNvcGllZCBvbiB0aGUgYmFja2VuZCBhcyB0aGlzIGdvZXMgdGhyb3VnaCBkYXRhIHNvdXJjZSBwcm94eVxuICAgKiBidXQgbm90IHRocm91Z2ggdGhlIHNhbWUgY29kZSBhcyBhbGVydGluZy5cbiAgICovXG4gIF9yZXF1ZXN0PFQgPSBhbnk+KFxuICAgIHVybDogc3RyaW5nLFxuICAgIGRhdGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBudWxsLFxuICAgIG92ZXJyaWRlczogUGFydGlhbDxCYWNrZW5kU3J2UmVxdWVzdD4gPSB7fVxuICApOiBPYnNlcnZhYmxlPEZldGNoUmVzcG9uc2U8VD4+IHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgaWYgKGRhdGFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBxdWVyeVVybCA9IHRoaXMudXJsICsgdXJsO1xuICAgIGlmICh1cmwuc3RhcnRzV2l0aChgL2FwaS9kYXRhc291cmNlcy8ke3RoaXMuaWR9YCkpIHtcbiAgICAgIC8vIFRoaXMgdXJsIGlzIG1lYW50IHRvIGJlIGEgcmVwbGFjZW1lbnQgZm9yIHRoZSB3aG9sZSBVUkwuIFJlcGxhY2UgdGhlIGVudGlyZSBVUkxcbiAgICAgIHF1ZXJ5VXJsID0gdXJsO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnM6IEJhY2tlbmRTcnZSZXF1ZXN0ID0gZGVmYXVsdHMob3ZlcnJpZGVzLCB7XG4gICAgICB1cmw6IHF1ZXJ5VXJsLFxuICAgICAgbWV0aG9kOiB0aGlzLmh0dHBNZXRob2QsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgIGlmIChkYXRhICYmIE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCkge1xuICAgICAgICBvcHRpb25zLnVybCA9XG4gICAgICAgICAgb3B0aW9ucy51cmwgK1xuICAgICAgICAgIChvcHRpb25zLnVybC5zZWFyY2goL1xcPy8pID49IDAgPyAnJicgOiAnPycpICtcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhkYXRhKVxuICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiBgJHtlbmNvZGVVUklDb21wb25lbnQoayl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHYpfWApXG4gICAgICAgICAgICAuam9pbignJicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMhWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgb3B0aW9ucy5kYXRhID0gZGF0YTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iYXNpY0F1dGggfHwgdGhpcy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIG9wdGlvbnMud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iYXNpY0F1dGgpIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycyEuQXV0aG9yaXphdGlvbiA9IHRoaXMuYmFzaWNBdXRoO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRCYWNrZW5kU3J2KCkuZmV0Y2g8VD4ob3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBpbXBvcnRGcm9tQWJzdHJhY3RRdWVyaWVzKGFic3RyYWN0UXVlcmllczogQWJzdHJhY3RRdWVyeVtdKTogUHJvbWlzZTxQcm9tUXVlcnlbXT4ge1xuICAgIHJldHVybiBhYnN0cmFjdFF1ZXJpZXMubWFwKChhYnN0cmFjdFF1ZXJ5KSA9PiB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkoYWJzdHJhY3RRdWVyeSkpO1xuICB9XG5cbiAgYXN5bmMgZXhwb3J0VG9BYnN0cmFjdFF1ZXJpZXMocXVlcmllczogUHJvbVF1ZXJ5W10pOiBQcm9taXNlPEFic3RyYWN0UXVlcnlbXT4ge1xuICAgIHJldHVybiBxdWVyaWVzLm1hcCgocXVlcnkpID0+IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5leHBvcnRUb0Fic3RyYWN0UXVlcnkocXVlcnkpKTtcbiAgfVxuXG4gIC8vIFVzZSB0aGlzIGZvciB0YWIgY29tcGxldGlvbiBmZWF0dXJlcywgd29udCBwdWJsaXNoIHJlc3BvbnNlIHRvIG90aGVyIGNvbXBvbmVudHNcbiAgYXN5bmMgbWV0YWRhdGFSZXF1ZXN0PFQgPSBhbnk+KHVybDogc3RyaW5nLCBwYXJhbXMgPSB7fSkge1xuICAgIC8vIElmIFVSTCBpbmNsdWRlcyBlbmRwb2ludCB0aGF0IHN1cHBvcnRzIFBPU1QgYW5kIEdFVCBtZXRob2QsIHRyeSB0byB1c2UgY29uZmlndXJlZCBtZXRob2QuIFRoaXMgbWlnaHQgZmFpbCBhcyBQT1NUIGlzIHN1cHBvcnRlZCBvbmx5IGluIHYyLjEwKy5cbiAgICBpZiAoR0VUX0FORF9QT1NUX01FVEFEQVRBX0VORFBPSU5UUy5zb21lKChlbmRwb2ludCkgPT4gdXJsLmluY2x1ZGVzKGVuZHBvaW50KSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBsYXN0VmFsdWVGcm9tKFxuICAgICAgICAgIHRoaXMuX3JlcXVlc3Q8VD4oYC9hcGkvZGF0YXNvdXJjZXMvJHt0aGlzLmlkfS9yZXNvdXJjZXMke3VybH1gLCBwYXJhbXMsIHtcbiAgICAgICAgICAgIG1ldGhvZDogdGhpcy5odHRwTWV0aG9kLFxuICAgICAgICAgICAgaGlkZUZyb21JbnNwZWN0b3I6IHRydWUsXG4gICAgICAgICAgICBzaG93RXJyb3JBbGVydDogZmFsc2UsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZiBzdGF0dXMgY29kZSBvZiBlcnJvciBpcyBNZXRob2QgTm90IEFsbG93ZWQgKDQwNSkgYW5kIEhUVFAgbWV0aG9kIGlzIFBPU1QsIHJldHJ5IHdpdGggR0VUXG4gICAgICAgIGlmICh0aGlzLmh0dHBNZXRob2QgPT09ICdQT1NUJyAmJiBpc0ZldGNoRXJyb3IoZXJyKSAmJiAoZXJyLnN0YXR1cyA9PT0gNDA1IHx8IGVyci5zdGF0dXMgPT09IDQwMCkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkbid0IHVzZSBjb25maWd1cmVkIFBPU1QgSFRUUCBtZXRob2QgZm9yIHRoaXMgcmVxdWVzdC4gVHJ5aW5nIHRvIHVzZSBHRVQgbWV0aG9kIGluc3RlYWQuYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IGxhc3RWYWx1ZUZyb20oXG4gICAgICB0aGlzLl9yZXF1ZXN0PFQ+KGAvYXBpL2RhdGFzb3VyY2VzLyR7dGhpcy5pZH0vcmVzb3VyY2VzJHt1cmx9YCwgcGFyYW1zLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhpZGVGcm9tSW5zcGVjdG9yOiB0cnVlLFxuICAgICAgfSlcbiAgICApOyAvLyB0b1Byb21pc2UgdW50aWwgd2UgY2hhbmdlIGdldFRhZ1ZhbHVlcywgZ2V0VGFnS2V5cyB0byBPYnNlcnZhYmxlXG4gIH1cblxuICBpbnRlcnBvbGF0ZVF1ZXJ5RXhwcih2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10gPSBbXSwgdmFyaWFibGU6IGFueSkge1xuICAgIC8vIGlmIG5vIG11bHRpIG9yIGluY2x1ZGUgYWxsIGRvIG5vdCByZWdleEVzY2FwZVxuICAgIGlmICghdmFyaWFibGUubXVsdGkgJiYgIXZhcmlhYmxlLmluY2x1ZGVBbGwpIHtcbiAgICAgIHJldHVybiBwcm9tZXRoZXVzUmVndWxhckVzY2FwZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBwcm9tZXRoZXVzU3BlY2lhbFJlZ2V4RXNjYXBlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBlc2NhcGVkVmFsdWVzID0gdmFsdWUubWFwKCh2YWwpID0+IHByb21ldGhldXNTcGVjaWFsUmVnZXhFc2NhcGUodmFsKSk7XG5cbiAgICBpZiAoZXNjYXBlZFZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBlc2NhcGVkVmFsdWVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiAnKCcgKyBlc2NhcGVkVmFsdWVzLmpvaW4oJ3wnKSArICcpJztcbiAgfVxuXG4gIHRhcmdldENvbnRhaW5zVGVtcGxhdGUodGFyZ2V0OiBQcm9tUXVlcnkpIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVNydi5jb250YWluc1RlbXBsYXRlKHRhcmdldC5leHByKTtcbiAgfVxuXG4gIHByZXBhcmVUYXJnZXRzID0gKG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Piwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBxdWVyaWVzOiBQcm9tUXVlcnlSZXF1ZXN0W10gPSBbXTtcbiAgICBjb25zdCBhY3RpdmVUYXJnZXRzOiBQcm9tUXVlcnlbXSA9IFtdO1xuICAgIGNvbnN0IGNsb25lZFRhcmdldHMgPSBjbG9uZURlZXAob3B0aW9ucy50YXJnZXRzKTtcblxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIGNsb25lZFRhcmdldHMpIHtcbiAgICAgIGlmICghdGFyZ2V0LmV4cHIgfHwgdGFyZ2V0LmhpZGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5yZXF1ZXN0SWQgPSBvcHRpb25zLnBhbmVsSWQgKyB0YXJnZXQucmVmSWQ7XG4gICAgICBjb25zdCBtZXRyaWNOYW1lID0gdGhpcy5sYW5ndWFnZVByb3ZpZGVyLmhpc3RvZ3JhbU1ldHJpY3MuZmluZCgobSkgPT4gdGFyZ2V0LmV4cHIuaW5jbHVkZXMobSkpO1xuXG4gICAgICAvLyBJbiBFeHBsb3JlLCB3ZSBydW4gYm90aCAoaW5zdGFudCBhbmQgcmFuZ2UpIHF1ZXJpZXMgaWYgYm90aCBhcmUgdHJ1ZSAoc2VsZWN0ZWQpIG9yIGJvdGggYXJlIHVuZGVmaW5lZCAobGVnYWN5IEV4cGxvcmUgcXVlcmllcylcbiAgICAgIGlmIChvcHRpb25zLmFwcCA9PT0gQ29yZUFwcC5FeHBsb3JlICYmIHRhcmdldC5yYW5nZSA9PT0gdGFyZ2V0Lmluc3RhbnQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGluc3RhbnQgdGFyZ2V0XG4gICAgICAgIGNvbnN0IGluc3RhbnRUYXJnZXQ6IGFueSA9IGNsb25lRGVlcCh0YXJnZXQpO1xuICAgICAgICBpbnN0YW50VGFyZ2V0LmZvcm1hdCA9ICd0YWJsZSc7XG4gICAgICAgIGluc3RhbnRUYXJnZXQuaW5zdGFudCA9IHRydWU7XG4gICAgICAgIGluc3RhbnRUYXJnZXQucmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgaW5zdGFudFRhcmdldC52YWx1ZVdpdGhSZWZJZCA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSBpbnN0YW50VGFyZ2V0Lm1heERhdGFQb2ludHM7XG4gICAgICAgIGluc3RhbnRUYXJnZXQucmVxdWVzdElkICs9ICdfaW5zdGFudCc7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHJhbmdlIHRhcmdldFxuICAgICAgICBjb25zdCByYW5nZVRhcmdldDogYW55ID0gY2xvbmVEZWVwKHRhcmdldCk7XG4gICAgICAgIHJhbmdlVGFyZ2V0LmZvcm1hdCA9ICd0aW1lX3Nlcmllcyc7XG4gICAgICAgIHJhbmdlVGFyZ2V0Lmluc3RhbnQgPSBmYWxzZTtcbiAgICAgICAgaW5zdGFudFRhcmdldC5yYW5nZSA9IHRydWU7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGV4ZW1wbGFyIHF1ZXJ5XG4gICAgICAgIGlmICh0YXJnZXQuZXhlbXBsYXIpIHtcbiAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBleGVtcGxhciB0YXJnZXQgZm9yIGRpZmZlcmVudCBtZXRyaWMgbmFtZXNcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWV0cmljTmFtZSB8fFxuICAgICAgICAgICAgKG1ldHJpY05hbWUgJiYgIWFjdGl2ZVRhcmdldHMuc29tZSgoYWN0aXZlVGFyZ2V0KSA9PiBhY3RpdmVUYXJnZXQuZXhwci5pbmNsdWRlcyhtZXRyaWNOYW1lKSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBleGVtcGxhclRhcmdldCA9IGNsb25lRGVlcCh0YXJnZXQpO1xuICAgICAgICAgICAgZXhlbXBsYXJUYXJnZXQuaW5zdGFudCA9IGZhbHNlO1xuICAgICAgICAgICAgZXhlbXBsYXJUYXJnZXQucmVxdWVzdElkICs9ICdfZXhlbXBsYXInO1xuICAgICAgICAgICAgcXVlcmllcy5wdXNoKHRoaXMuY3JlYXRlUXVlcnkoZXhlbXBsYXJUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaChleGVtcGxhclRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbnRUYXJnZXQuZXhlbXBsYXIgPSBmYWxzZTtcbiAgICAgICAgICByYW5nZVRhcmdldC5leGVtcGxhciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGJvdGggdGFyZ2V0cyB0byBhY3RpdmVUYXJnZXRzIGFuZCBxdWVyaWVzIGFycmF5c1xuICAgICAgICBhY3RpdmVUYXJnZXRzLnB1c2goaW5zdGFudFRhcmdldCwgcmFuZ2VUYXJnZXQpO1xuICAgICAgICBxdWVyaWVzLnB1c2goXG4gICAgICAgICAgdGhpcy5jcmVhdGVRdWVyeShpbnN0YW50VGFyZ2V0LCBvcHRpb25zLCBzdGFydCwgZW5kKSxcbiAgICAgICAgICB0aGlzLmNyZWF0ZVF1ZXJ5KHJhbmdlVGFyZ2V0LCBvcHRpb25zLCBzdGFydCwgZW5kKVxuICAgICAgICApO1xuICAgICAgICAvLyBJZiBydW5uaW5nIG9ubHkgaW5zdGFudCBxdWVyeSBpbiBFeHBsb3JlLCBmb3JtYXQgYXMgdGFibGVcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmluc3RhbnQgJiYgb3B0aW9ucy5hcHAgPT09IENvcmVBcHAuRXhwbG9yZSkge1xuICAgICAgICBjb25zdCBpbnN0YW50VGFyZ2V0OiBhbnkgPSBjbG9uZURlZXAodGFyZ2V0KTtcbiAgICAgICAgaW5zdGFudFRhcmdldC5mb3JtYXQgPSAndGFibGUnO1xuICAgICAgICBxdWVyaWVzLnB1c2godGhpcy5jcmVhdGVRdWVyeShpbnN0YW50VGFyZ2V0LCBvcHRpb25zLCBzdGFydCwgZW5kKSk7XG4gICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaChpbnN0YW50VGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBxdWVyeSBmb3IgZXhlbXBsYXJzIGluIGRhc2hib2FyZCBpZiBvbmx5IGluc3RhbnQgaXMgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHRhcmdldC5leGVtcGxhciAmJiAhdGFyZ2V0Lmluc3RhbnQpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWV0cmljTmFtZSB8fFxuICAgICAgICAgICAgKG1ldHJpY05hbWUgJiYgIWFjdGl2ZVRhcmdldHMuc29tZSgoYWN0aXZlVGFyZ2V0KSA9PiBhY3RpdmVUYXJnZXQuZXhwci5pbmNsdWRlcyhtZXRyaWNOYW1lKSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBleGVtcGxhclRhcmdldCA9IGNsb25lRGVlcCh0YXJnZXQpO1xuICAgICAgICAgICAgZXhlbXBsYXJUYXJnZXQucmVxdWVzdElkICs9ICdfZXhlbXBsYXInO1xuICAgICAgICAgICAgcXVlcmllcy5wdXNoKHRoaXMuY3JlYXRlUXVlcnkoZXhlbXBsYXJUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaChleGVtcGxhclRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5leGVtcGxhciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJpZXMucHVzaCh0aGlzLmNyZWF0ZVF1ZXJ5KHRhcmdldCwgb3B0aW9ucywgc3RhcnQsIGVuZCkpO1xuICAgICAgICBhY3RpdmVUYXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcXVlcmllcyxcbiAgICAgIGFjdGl2ZVRhcmdldHMsXG4gICAgfTtcbiAgfTtcblxuICBzaG91bGRSdW5FeGVtcGxhclF1ZXJ5KHRhcmdldDogUHJvbVF1ZXJ5LCByZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4pOiBib29sZWFuIHtcbiAgICBpZiAodGFyZ2V0LmV4ZW1wbGFyKSB7XG4gICAgICAvLyBXZSBjaGVjayBhbGwgYWxyZWFkeSBwcm9jZXNzZWQgdGFyZ2V0cyBhbmQgb25seSBjcmVhdGUgZXhlbXBsYXIgdGFyZ2V0IGZvciBub3QgdXNlZCBtZXRyaWMgbmFtZXNcbiAgICAgIGNvbnN0IG1ldHJpY05hbWUgPSB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuaGlzdG9ncmFtTWV0cmljcy5maW5kKChtKSA9PiB0YXJnZXQuZXhwci5pbmNsdWRlcyhtKSk7XG4gICAgICAvLyBSZW1vdmUgdGFyZ2V0cyB0aGF0IHdlcmVuJ3QgcHJvY2Vzc2VkIHlldCAoaW4gdGFyZ2V0cyBhcnJheSB0aGV5IGFyZSBhZnRlciBjdXJyZW50IHRhcmdldClcbiAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXRJZHggPSByZXF1ZXN0LnRhcmdldHMuZmluZEluZGV4KCh0KSA9PiB0LnJlZklkID09PSB0YXJnZXQucmVmSWQpO1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IHJlcXVlc3QudGFyZ2V0cy5zbGljZSgwLCBjdXJyZW50VGFyZ2V0SWR4KS5maWx0ZXIoKHQpID0+ICF0LmhpZGUpO1xuXG4gICAgICBpZiAoIW1ldHJpY05hbWUgfHwgKG1ldHJpY05hbWUgJiYgIXRhcmdldHMuc29tZSgodCkgPT4gdC5leHByLmluY2x1ZGVzKG1ldHJpY05hbWUpKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByb2Nlc3NUYXJnZXRWMih0YXJnZXQ6IFByb21RdWVyeSwgcmVxdWVzdDogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+KSB7XG4gICAgY29uc3QgcHJvY2Vzc2VkVGFyZ2V0ID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgcXVlcnlUeXBlOiBQcm9tUXVlcnlUeXBlLnRpbWVTZXJpZXNRdWVyeSxcbiAgICAgIGV4ZW1wbGFyOiB0aGlzLnNob3VsZFJ1bkV4ZW1wbGFyUXVlcnkodGFyZ2V0LCByZXF1ZXN0KSxcbiAgICAgIHJlcXVlc3RJZDogcmVxdWVzdC5wYW5lbElkICsgdGFyZ2V0LnJlZklkLFxuICAgICAgLy8gV2UgbmVlZCB0byBwYXNzIHV0Y09mZnNldFNlYyB0byBiYWNrZW5kIHRvIGNhbGN1bGF0ZSBhbGlnbmVkIHJhbmdlXG4gICAgICB1dGNPZmZzZXRTZWM6IHRoaXMudGltZVNydi50aW1lUmFuZ2UoKS50by51dGNPZmZzZXQoKSAqIDYwLFxuICAgIH07XG4gICAgcmV0dXJuIHByb2Nlc3NlZFRhcmdldDtcbiAgfVxuXG4gIHF1ZXJ5KHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pik6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+IHtcbiAgICBpZiAodGhpcy5hY2Nlc3MgPT09ICdwcm94eScpIHtcbiAgICAgIGNvbnN0IHRhcmdldHMgPSByZXF1ZXN0LnRhcmdldHMubWFwKCh0YXJnZXQpID0+IHRoaXMucHJvY2Vzc1RhcmdldFYyKHRhcmdldCwgcmVxdWVzdCkpO1xuICAgICAgcmV0dXJuIHN1cGVyXG4gICAgICAgIC5xdWVyeSh7IC4uLnJlcXVlc3QsIHRhcmdldHMgfSlcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgbWFwKChyZXNwb25zZSkgPT5cbiAgICAgICAgICAgIHRyYW5zZm9ybVYyKHJlc3BvbnNlLCByZXF1ZXN0LCB7IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uczogdGhpcy5leGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAvLyBSdW4gcXVlcmllcyB0cm91Z2ggYnJvd3Nlci9wcm94eVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGFydCA9IHRoaXMuZ2V0UHJvbWV0aGV1c1RpbWUocmVxdWVzdC5yYW5nZS5mcm9tLCBmYWxzZSk7XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLmdldFByb21ldGhldXNUaW1lKHJlcXVlc3QucmFuZ2UudG8sIHRydWUpO1xuICAgICAgY29uc3QgeyBxdWVyaWVzLCBhY3RpdmVUYXJnZXRzIH0gPSB0aGlzLnByZXBhcmVUYXJnZXRzKHJlcXVlc3QsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAvLyBObyB2YWxpZCB0YXJnZXRzLCByZXR1cm4gdGhlIGVtcHR5IHJlc3VsdCB0byBzYXZlIGEgcm91bmQgdHJpcC5cbiAgICAgIGlmICghcXVlcmllcyB8fCAhcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9mKHtcbiAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICBzdGF0ZTogTG9hZGluZ1N0YXRlLkRvbmUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdC5hcHAgPT09IENvcmVBcHAuRXhwbG9yZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBsb3JlUXVlcnkocXVlcmllcywgYWN0aXZlVGFyZ2V0cywgZW5kKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFuZWxzUXVlcnkocXVlcmllcywgYWN0aXZlVGFyZ2V0cywgZW5kLCByZXF1ZXN0LnJlcXVlc3RJZCwgcmVxdWVzdC5zY29wZWRWYXJzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGV4cGxvcmVRdWVyeShxdWVyaWVzOiBQcm9tUXVlcnlSZXF1ZXN0W10sIGFjdGl2ZVRhcmdldHM6IFByb21RdWVyeVtdLCBlbmQ6IG51bWJlcikge1xuICAgIGxldCBydW5uaW5nUXVlcmllc0NvdW50ID0gcXVlcmllcy5sZW5ndGg7XG5cbiAgICBjb25zdCBzdWJRdWVyaWVzID0gcXVlcmllcy5tYXAoKHF1ZXJ5LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gYWN0aXZlVGFyZ2V0c1tpbmRleF07XG5cbiAgICAgIGNvbnN0IGZpbHRlckFuZE1hcFJlc3BvbnNlID0gcGlwZShcbiAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGNvdW50ZXIgaGVyZS4gV2UgYXNzdW1lIHRoYXQgZWFjaCByZXF1ZXN0IHJldHVybnMgb25seSBzaW5nbGUgdmFsdWUgYW5kIHRoZW4gY29tcGxldGVzXG4gICAgICAgIC8vIChzaG91bGQgaG9sZCB1bnRpbCB0aGVyZSBpcyBzb21lIHN0cmVhbWluZyByZXF1ZXN0cyBpbnZvbHZlZCkuXG4gICAgICAgIHRhcCgoKSA9PiBydW5uaW5nUXVlcmllc0NvdW50LS0pLFxuICAgICAgICBmaWx0ZXIoKHJlc3BvbnNlOiBhbnkpID0+IChyZXNwb25zZS5jYW5jZWxsZWQgPyBmYWxzZSA6IHRydWUpKSxcbiAgICAgICAgbWFwKChyZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHRyYW5zZm9ybShyZXNwb25zZSwge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICByZXNwb25zZUxpc3RMZW5ndGg6IHF1ZXJpZXMubGVuZ3RoLFxuICAgICAgICAgICAgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zOiB0aGlzLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGtleTogcXVlcnkucmVxdWVzdElkLFxuICAgICAgICAgICAgc3RhdGU6IHJ1bm5pbmdRdWVyaWVzQ291bnQgPT09IDAgPyBMb2FkaW5nU3RhdGUuRG9uZSA6IExvYWRpbmdTdGF0ZS5Mb2FkaW5nLFxuICAgICAgICAgIH0gYXMgRGF0YVF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdGhpcy5ydW5RdWVyeShxdWVyeSwgZW5kLCBmaWx0ZXJBbmRNYXBSZXNwb25zZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWVyZ2UoLi4uc3ViUXVlcmllcyk7XG4gIH1cblxuICBwcml2YXRlIHBhbmVsc1F1ZXJ5KFxuICAgIHF1ZXJpZXM6IFByb21RdWVyeVJlcXVlc3RbXSxcbiAgICBhY3RpdmVUYXJnZXRzOiBQcm9tUXVlcnlbXSxcbiAgICBlbmQ6IG51bWJlcixcbiAgICByZXF1ZXN0SWQ6IHN0cmluZyxcbiAgICBzY29wZWRWYXJzOiBTY29wZWRWYXJzXG4gICkge1xuICAgIGNvbnN0IG9ic2VydmFibGVzID0gcXVlcmllcy5tYXAoKHF1ZXJ5LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gYWN0aXZlVGFyZ2V0c1tpbmRleF07XG5cbiAgICAgIGNvbnN0IGZpbHRlckFuZE1hcFJlc3BvbnNlID0gcGlwZShcbiAgICAgICAgZmlsdGVyKChyZXNwb25zZTogYW55KSA9PiAocmVzcG9uc2UuY2FuY2VsbGVkID8gZmFsc2UgOiB0cnVlKSksXG4gICAgICAgIG1hcCgocmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB0cmFuc2Zvcm0ocmVzcG9uc2UsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgcmVzcG9uc2VMaXN0TGVuZ3RoOiBxdWVyaWVzLmxlbmd0aCxcbiAgICAgICAgICAgIHNjb3BlZFZhcnMsXG4gICAgICAgICAgICBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM6IHRoaXMuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRoaXMucnVuUXVlcnkocXVlcnksIGVuZCwgZmlsdGVyQW5kTWFwUmVzcG9uc2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZvcmtKb2luKG9ic2VydmFibGVzKS5waXBlKFxuICAgICAgbWFwKChyZXN1bHRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXN1bHRzLnJlZHVjZSgocmVzdWx0LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFsuLi5yZXN1bHQsIC4uLmN1cnJlbnRdO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBrZXk6IHJlcXVlc3RJZCxcbiAgICAgICAgICBzdGF0ZTogTG9hZGluZ1N0YXRlLkRvbmUsXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHJ1blF1ZXJ5PFQ+KHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0LCBlbmQ6IG51bWJlciwgZmlsdGVyOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgVD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICBpZiAocXVlcnkuaW5zdGFudCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybUluc3RhbnRRdWVyeShxdWVyeSwgZW5kKS5waXBlKGZpbHRlcik7XG4gICAgfVxuXG4gICAgaWYgKHF1ZXJ5LmV4ZW1wbGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRFeGVtcGxhcnMocXVlcnkpLnBpcGUoXG4gICAgICAgIGNhdGNoRXJyb3IoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvZih7XG4gICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIHN0YXRlOiBMb2FkaW5nU3RhdGUuRG9uZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGZpbHRlclxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wZXJmb3JtVGltZVNlcmllc1F1ZXJ5KHF1ZXJ5LCBxdWVyeS5zdGFydCwgcXVlcnkuZW5kKS5waXBlKGZpbHRlcik7XG4gIH1cblxuICBjcmVhdGVRdWVyeSh0YXJnZXQ6IFByb21RdWVyeSwgb3B0aW9uczogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+LCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgIGNvbnN0IHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0ID0ge1xuICAgICAgaGludGluZzogdGFyZ2V0LmhpbnRpbmcsXG4gICAgICBpbnN0YW50OiB0YXJnZXQuaW5zdGFudCxcbiAgICAgIGV4ZW1wbGFyOiB0YXJnZXQuZXhlbXBsYXIsXG4gICAgICBzdGVwOiAwLFxuICAgICAgZXhwcjogJycsXG4gICAgICByZXF1ZXN0SWQ6IHRhcmdldC5yZXF1ZXN0SWQsXG4gICAgICByZWZJZDogdGFyZ2V0LnJlZklkLFxuICAgICAgc3RhcnQ6IDAsXG4gICAgICBlbmQ6IDAsXG4gICAgfTtcbiAgICBjb25zdCByYW5nZSA9IE1hdGguY2VpbChlbmQgLSBzdGFydCk7XG5cbiAgICAvLyBvcHRpb25zLmludGVydmFsIGlzIHRoZSBkeW5hbWljYWxseSBjYWxjdWxhdGVkIGludGVydmFsXG4gICAgbGV0IGludGVydmFsOiBudW1iZXIgPSByYW5nZVV0aWwuaW50ZXJ2YWxUb1NlY29uZHMob3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgLy8gTWluaW11bSBpbnRlcnZhbCAoXCJNaW4gc3RlcFwiKSwgaWYgc3BlY2lmaWVkIGZvciB0aGUgcXVlcnksIG9yIHNhbWUgYXMgaW50ZXJ2YWwgb3RoZXJ3aXNlLlxuICAgIGNvbnN0IG1pbkludGVydmFsID0gcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKFxuICAgICAgdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5pbnRlcnZhbCB8fCBvcHRpb25zLmludGVydmFsLCBvcHRpb25zLnNjb3BlZFZhcnMpXG4gICAgKTtcbiAgICAvLyBTY3JhcGUgaW50ZXJ2YWwgYXMgc3BlY2lmaWVkIGZvciB0aGUgcXVlcnkgKFwiTWluIHN0ZXBcIikgb3Igb3RoZXJ3aXNlIHRha2VuIGZyb20gdGhlIGRhdGFzb3VyY2UuXG4gICAgLy8gTWluIHN0ZXAgZmllbGQgY2FuIGhhdmUgdGVtcGxhdGUgdmFyaWFibGVzIGluIGl0LCBtYWtlIHN1cmUgdG8gcmVwbGFjZSBpdC5cbiAgICBjb25zdCBzY3JhcGVJbnRlcnZhbCA9IHRhcmdldC5pbnRlcnZhbFxuICAgICAgPyByYW5nZVV0aWwuaW50ZXJ2YWxUb1NlY29uZHModGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5pbnRlcnZhbCwgb3B0aW9ucy5zY29wZWRWYXJzKSlcbiAgICAgIDogcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKHRoaXMuaW50ZXJ2YWwpO1xuXG4gICAgY29uc3QgaW50ZXJ2YWxGYWN0b3IgPSB0YXJnZXQuaW50ZXJ2YWxGYWN0b3IgfHwgMTtcbiAgICAvLyBBZGp1c3QgdGhlIGludGVydmFsIHRvIHRha2UgaW50byBhY2NvdW50IGFueSBzcGVjaWZpZWQgbWluaW11bSBhbmQgaW50ZXJ2YWwgZmFjdG9yIHBsdXMgUHJvbWV0aGV1cyBsaW1pdHNcbiAgICBjb25zdCBhZGp1c3RlZEludGVydmFsID0gdGhpcy5hZGp1c3RJbnRlcnZhbChpbnRlcnZhbCwgbWluSW50ZXJ2YWwsIHJhbmdlLCBpbnRlcnZhbEZhY3Rvcik7XG4gICAgbGV0IHNjb3BlZFZhcnMgPSB7XG4gICAgICAuLi5vcHRpb25zLnNjb3BlZFZhcnMsXG4gICAgICAuLi50aGlzLmdldFJhbmdlU2NvcGVkVmFycyhvcHRpb25zLnJhbmdlKSxcbiAgICAgIC4uLnRoaXMuZ2V0UmF0ZUludGVydmFsU2NvcGVkVmFyaWFibGUoYWRqdXN0ZWRJbnRlcnZhbCwgc2NyYXBlSW50ZXJ2YWwpLFxuICAgIH07XG4gICAgLy8gSWYgdGhlIGludGVydmFsIHdhcyBhZGp1c3RlZCwgbWFrZSBhIHNoYWxsb3cgY29weSBvZiBzY29wZWRWYXJzIHdpdGggdXBkYXRlZCBpbnRlcnZhbCB2YXJzXG4gICAgaWYgKGludGVydmFsICE9PSBhZGp1c3RlZEludGVydmFsKSB7XG4gICAgICBpbnRlcnZhbCA9IGFkanVzdGVkSW50ZXJ2YWw7XG4gICAgICBzY29wZWRWYXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5zY29wZWRWYXJzLCB7XG4gICAgICAgIF9faW50ZXJ2YWw6IHsgdGV4dDogaW50ZXJ2YWwgKyAncycsIHZhbHVlOiBpbnRlcnZhbCArICdzJyB9LFxuICAgICAgICBfX2ludGVydmFsX21zOiB7IHRleHQ6IGludGVydmFsICogMTAwMCwgdmFsdWU6IGludGVydmFsICogMTAwMCB9LFxuICAgICAgICAuLi50aGlzLmdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlKGludGVydmFsLCBzY3JhcGVJbnRlcnZhbCksXG4gICAgICAgIC4uLnRoaXMuZ2V0UmFuZ2VTY29wZWRWYXJzKG9wdGlvbnMucmFuZ2UpLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHF1ZXJ5LnN0ZXAgPSBpbnRlcnZhbDtcblxuICAgIGxldCBleHByID0gdGFyZ2V0LmV4cHI7XG5cbiAgICAvLyBBcHBseSBhZGhvYyBmaWx0ZXJzXG4gICAgZXhwciA9IHRoaXMuZW5oYW5jZUV4cHJXaXRoQWRIb2NGaWx0ZXJzKGV4cHIpO1xuXG4gICAgLy8gT25seSByZXBsYWNlIHZhcnMgaW4gZXhwcmVzc2lvbiBhZnRlciBoYXZpbmcgKHBvc3NpYmx5KSB1cGRhdGVkIGludGVydmFsIHZhcnNcbiAgICBxdWVyeS5leHByID0gdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKGV4cHIsIHNjb3BlZFZhcnMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpO1xuXG4gICAgLy8gQWxpZ24gcXVlcnkgaW50ZXJ2YWwgd2l0aCBzdGVwIHRvIGFsbG93IHF1ZXJ5IGNhY2hpbmcgYW5kIHRvIGVuc3VyZVxuICAgIC8vIHRoYXQgYWJvdXQtc2FtZS10aW1lIHF1ZXJ5IHJlc3VsdHMgbG9vayB0aGUgc2FtZS5cbiAgICBjb25zdCBhZGp1c3RlZCA9IGFsaWduUmFuZ2Uoc3RhcnQsIGVuZCwgcXVlcnkuc3RlcCwgdGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpLnRvLnV0Y09mZnNldCgpICogNjApO1xuICAgIHF1ZXJ5LnN0YXJ0ID0gYWRqdXN0ZWQuc3RhcnQ7XG4gICAgcXVlcnkuZW5kID0gYWRqdXN0ZWQuZW5kO1xuICAgIHRoaXMuX2FkZFRyYWNpbmdIZWFkZXJzKHF1ZXJ5LCBvcHRpb25zKTtcblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIGdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlKGludGVydmFsOiBudW1iZXIsIHNjcmFwZUludGVydmFsOiBudW1iZXIpIHtcbiAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgc2NyYXBlIGludGVydmFsIG9mIDE1cyBpZiBzY3JhcGVJbnRlcnZhbCBpcyAwIGZvciBzb21lIHJlYXNvbi5cbiAgICBpZiAoc2NyYXBlSW50ZXJ2YWwgPT09IDApIHtcbiAgICAgIHNjcmFwZUludGVydmFsID0gMTU7XG4gICAgfVxuICAgIGNvbnN0IHJhdGVJbnRlcnZhbCA9IE1hdGgubWF4KGludGVydmFsICsgc2NyYXBlSW50ZXJ2YWwsIDQgKiBzY3JhcGVJbnRlcnZhbCk7XG4gICAgcmV0dXJuIHsgX19yYXRlX2ludGVydmFsOiB7IHRleHQ6IHJhdGVJbnRlcnZhbCArICdzJywgdmFsdWU6IHJhdGVJbnRlcnZhbCArICdzJyB9IH07XG4gIH1cblxuICBhZGp1c3RJbnRlcnZhbChpbnRlcnZhbDogbnVtYmVyLCBtaW5JbnRlcnZhbDogbnVtYmVyLCByYW5nZTogbnVtYmVyLCBpbnRlcnZhbEZhY3RvcjogbnVtYmVyKSB7XG4gICAgLy8gUHJvbWV0aGV1cyB3aWxsIGRyb3AgcXVlcmllcyB0aGF0IG1pZ2h0IHJldHVybiBtb3JlIHRoYW4gMTEwMDAgZGF0YSBwb2ludHMuXG4gICAgLy8gQ2FsY3VsYXRlIGEgc2FmZSBpbnRlcnZhbCBhcyBhbiBhZGRpdGlvbmFsIG1pbmltdW0gdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgLy8gRnJhY3Rpb25hbCBzYWZlSW50ZXJ2YWxzIGFyZSBhbGxvd2VkLCBob3dldmVyIHNlcnZlIGxpdHRsZSBwdXJwb3NlIGlmIHRoZSBpbnRlcnZhbCBpcyBncmVhdGVyIHRoYW4gMVxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGNhc2UgdGFrZSB0aGUgY2VpbCBvZiB0aGUgdmFsdWUuXG4gICAgbGV0IHNhZmVJbnRlcnZhbCA9IHJhbmdlIC8gMTEwMDA7XG4gICAgaWYgKHNhZmVJbnRlcnZhbCA+IDEpIHtcbiAgICAgIHNhZmVJbnRlcnZhbCA9IE1hdGguY2VpbChzYWZlSW50ZXJ2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoaW50ZXJ2YWwgKiBpbnRlcnZhbEZhY3RvciwgbWluSW50ZXJ2YWwsIHNhZmVJbnRlcnZhbCk7XG4gIH1cblxuICBwZXJmb3JtVGltZVNlcmllc1F1ZXJ5KHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0LCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnSW52YWxpZCB0aW1lIHJhbmdlJyB9O1xuICAgIH1cblxuICAgIGNvbnN0IHVybCA9ICcvYXBpL3YxL3F1ZXJ5X3JhbmdlJztcbiAgICBjb25zdCBkYXRhOiBhbnkgPSB7XG4gICAgICBxdWVyeTogcXVlcnkuZXhwcixcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgc3RlcDogcXVlcnkuc3RlcCxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMucXVlcnlUaW1lb3V0KSB7XG4gICAgICBkYXRhWyd0aW1lb3V0J10gPSB0aGlzLnF1ZXJ5VGltZW91dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tTWF0cml4RGF0YT4+KHVybCwgZGF0YSwge1xuICAgICAgcmVxdWVzdElkOiBxdWVyeS5yZXF1ZXN0SWQsXG4gICAgICBoZWFkZXJzOiBxdWVyeS5oZWFkZXJzLFxuICAgIH0pLnBpcGUoXG4gICAgICBjYXRjaEVycm9yKChlcnI6IEZldGNoRXJyb3I8UHJvbURhdGFFcnJvclJlc3BvbnNlPFByb21NYXRyaXhEYXRhPj4pID0+IHtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm4gb2YoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHRoaXMuaGFuZGxlRXJyb3JzKGVyciwgcXVlcnkpKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHBlcmZvcm1JbnN0YW50UXVlcnkoXG4gICAgcXVlcnk6IFByb21RdWVyeVJlcXVlc3QsXG4gICAgdGltZTogbnVtYmVyXG4gICk6IE9ic2VydmFibGU8RmV0Y2hSZXNwb25zZTxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tVmVjdG9yRGF0YSB8IFByb21TY2FsYXJEYXRhPj4gfCBGZXRjaEVycm9yPiB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvdjEvcXVlcnknO1xuICAgIGNvbnN0IGRhdGE6IGFueSA9IHtcbiAgICAgIHF1ZXJ5OiBxdWVyeS5leHByLFxuICAgICAgdGltZSxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMucXVlcnlUaW1lb3V0KSB7XG4gICAgICBkYXRhWyd0aW1lb3V0J10gPSB0aGlzLnF1ZXJ5VGltZW91dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tVmVjdG9yRGF0YSB8IFByb21TY2FsYXJEYXRhPj4odXJsLCBkYXRhLCB7XG4gICAgICByZXF1ZXN0SWQ6IHF1ZXJ5LnJlcXVlc3RJZCxcbiAgICAgIGhlYWRlcnM6IHF1ZXJ5LmhlYWRlcnMsXG4gICAgfSkucGlwZShcbiAgICAgIGNhdGNoRXJyb3IoKGVycjogRmV0Y2hFcnJvcjxQcm9tRGF0YUVycm9yUmVzcG9uc2U8UHJvbVZlY3RvckRhdGEgfCBQcm9tU2NhbGFyRGF0YT4+KSA9PiB7XG4gICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuIG9mKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih0aGlzLmhhbmRsZUVycm9ycyhlcnIsIHF1ZXJ5KSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBoYW5kbGVFcnJvcnMgPSAoZXJyOiBhbnksIHRhcmdldDogUHJvbVF1ZXJ5KSA9PiB7XG4gICAgY29uc3QgZXJyb3I6IERhdGFRdWVyeUVycm9yID0ge1xuICAgICAgbWVzc2FnZTogKGVyciAmJiBlcnIuc3RhdHVzVGV4dCkgfHwgJ1Vua25vd24gZXJyb3IgZHVyaW5nIHF1ZXJ5IHRyYW5zYWN0aW9uLiBQbGVhc2UgY2hlY2sgSlMgY29uc29sZSBsb2dzLicsXG4gICAgICByZWZJZDogdGFyZ2V0LnJlZklkLFxuICAgIH07XG5cbiAgICBpZiAoZXJyLmRhdGEpIHtcbiAgICAgIGlmICh0eXBlb2YgZXJyLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSBlcnIuZGF0YTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyLmRhdGEuZXJyb3IpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IHNhZmVTdHJpbmdpZnlWYWx1ZShlcnIuZGF0YS5lcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgZXJyb3IubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBlcnI7XG4gICAgfVxuXG4gICAgZXJyb3Iuc3RhdHVzID0gZXJyLnN0YXR1cztcbiAgICBlcnJvci5zdGF0dXNUZXh0ID0gZXJyLnN0YXR1c1RleHQ7XG5cbiAgICByZXR1cm4gZXJyb3I7XG4gIH07XG5cbiAgbWV0cmljRmluZFF1ZXJ5KHF1ZXJ5OiBzdHJpbmcpIHtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICBjb25zdCBzY29wZWRWYXJzID0ge1xuICAgICAgX19pbnRlcnZhbDogeyB0ZXh0OiB0aGlzLmludGVydmFsLCB2YWx1ZTogdGhpcy5pbnRlcnZhbCB9LFxuICAgICAgX19pbnRlcnZhbF9tczogeyB0ZXh0OiByYW5nZVV0aWwuaW50ZXJ2YWxUb01zKHRoaXMuaW50ZXJ2YWwpLCB2YWx1ZTogcmFuZ2VVdGlsLmludGVydmFsVG9Ncyh0aGlzLmludGVydmFsKSB9LFxuICAgICAgLi4udGhpcy5nZXRSYW5nZVNjb3BlZFZhcnModGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpKSxcbiAgICB9O1xuICAgIGNvbnN0IGludGVycG9sYXRlZCA9IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShxdWVyeSwgc2NvcGVkVmFycywgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwcik7XG4gICAgY29uc3QgbWV0cmljRmluZFF1ZXJ5ID0gbmV3IFByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkodGhpcywgaW50ZXJwb2xhdGVkKTtcbiAgICByZXR1cm4gbWV0cmljRmluZFF1ZXJ5LnByb2Nlc3MoKTtcbiAgfVxuXG4gIGdldFJhbmdlU2NvcGVkVmFycyhyYW5nZTogVGltZVJhbmdlID0gdGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpKSB7XG4gICAgY29uc3QgbXNSYW5nZSA9IHJhbmdlLnRvLmRpZmYocmFuZ2UuZnJvbSk7XG4gICAgY29uc3Qgc1JhbmdlID0gTWF0aC5yb3VuZChtc1JhbmdlIC8gMTAwMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fcmFuZ2VfbXM6IHsgdGV4dDogbXNSYW5nZSwgdmFsdWU6IG1zUmFuZ2UgfSxcbiAgICAgIF9fcmFuZ2VfczogeyB0ZXh0OiBzUmFuZ2UsIHZhbHVlOiBzUmFuZ2UgfSxcbiAgICAgIF9fcmFuZ2U6IHsgdGV4dDogc1JhbmdlICsgJ3MnLCB2YWx1ZTogc1JhbmdlICsgJ3MnIH0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGFubm90YXRpb25RdWVyeShvcHRpb25zOiBhbnkpOiBQcm9taXNlPEFubm90YXRpb25FdmVudFtdPiB7XG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IG9wdGlvbnMuYW5ub3RhdGlvbjtcbiAgICBjb25zdCB7IGV4cHIgPSAnJyB9ID0gYW5ub3RhdGlvbjtcblxuICAgIGlmICghZXhwcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RlcCA9IG9wdGlvbnMuYW5ub3RhdGlvbi5zdGVwIHx8IEFOTk9UQVRJT05fUVVFUllfU1RFUF9ERUZBVUxUO1xuICAgIGNvbnN0IHF1ZXJ5TW9kZWwgPSB7XG4gICAgICBleHByLFxuICAgICAgcmFuZ2U6IHRydWUsXG4gICAgICBpbnN0YW50OiBmYWxzZSxcbiAgICAgIGV4ZW1wbGFyOiBmYWxzZSxcbiAgICAgIGludGVydmFsOiBzdGVwLFxuICAgICAgcXVlcnlUeXBlOiBQcm9tUXVlcnlUeXBlLnRpbWVTZXJpZXNRdWVyeSxcbiAgICAgIHJlZklkOiAnWCcsXG4gICAgICBkYXRhc291cmNlOiB0aGlzLmdldFJlZigpLFxuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgbGFzdFZhbHVlRnJvbShcbiAgICAgIGdldEJhY2tlbmRTcnYoKVxuICAgICAgICAuZmV0Y2g8QmFja2VuZERhdGFTb3VyY2VSZXNwb25zZT4oe1xuICAgICAgICAgIHVybDogJy9hcGkvZHMvcXVlcnknLFxuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGZyb206ICh0aGlzLmdldFByb21ldGhldXNUaW1lKG9wdGlvbnMucmFuZ2UuZnJvbSwgZmFsc2UpICogMTAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHRvOiAodGhpcy5nZXRQcm9tZXRoZXVzVGltZShvcHRpb25zLnJhbmdlLnRvLCB0cnVlKSAqIDEwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBxdWVyaWVzOiBbdGhpcy5hcHBseVRlbXBsYXRlVmFyaWFibGVzKHF1ZXJ5TW9kZWwsIHt9KV0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1ZXN0SWQ6IGBwcm9tLXF1ZXJ5LSR7YW5ub3RhdGlvbi5uYW1lfWAsXG4gICAgICAgIH0pXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIG1hcCgocnNwOiBGZXRjaFJlc3BvbnNlPEJhY2tlbmREYXRhU291cmNlUmVzcG9uc2U+KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzQW5ub3RhdGlvblJlc3BvbnNlKG9wdGlvbnMsIHJzcC5kYXRhKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByb2Nlc3NBbm5vdGF0aW9uUmVzcG9uc2UgPSAob3B0aW9uczogYW55LCBkYXRhOiBCYWNrZW5kRGF0YVNvdXJjZVJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3QgZnJhbWVzOiBEYXRhRnJhbWVbXSA9IHRvRGF0YVF1ZXJ5UmVzcG9uc2UoeyBkYXRhOiBkYXRhIH0pLmRhdGE7XG4gICAgaWYgKCFmcmFtZXMgfHwgIWZyYW1lcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBhbm5vdGF0aW9uID0gb3B0aW9ucy5hbm5vdGF0aW9uO1xuICAgIGNvbnN0IHsgdGFnS2V5cyA9ICcnLCB0aXRsZUZvcm1hdCA9ICcnLCB0ZXh0Rm9ybWF0ID0gJycgfSA9IGFubm90YXRpb247XG5cbiAgICBjb25zdCBzdGVwID0gcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKGFubm90YXRpb24uc3RlcCB8fCBBTk5PVEFUSU9OX1FVRVJZX1NURVBfREVGQVVMVCkgKiAxMDAwO1xuICAgIGNvbnN0IHRhZ0tleXNBcnJheSA9IHRhZ0tleXMuc3BsaXQoJywnKTtcblxuICAgIGNvbnN0IGV2ZW50TGlzdDogQW5ub3RhdGlvbkV2ZW50W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZnJhbWUgb2YgZnJhbWVzKSB7XG4gICAgICBjb25zdCB0aW1lRmllbGQgPSBmcmFtZS5maWVsZHNbMF07XG4gICAgICBjb25zdCB2YWx1ZUZpZWxkID0gZnJhbWUuZmllbGRzWzFdO1xuICAgICAgY29uc3QgbGFiZWxzID0gdmFsdWVGaWVsZD8ubGFiZWxzIHx8IHt9O1xuXG4gICAgICBjb25zdCB0YWdzID0gT2JqZWN0LmtleXMobGFiZWxzKVxuICAgICAgICAuZmlsdGVyKChsYWJlbCkgPT4gdGFnS2V5c0FycmF5LmluY2x1ZGVzKGxhYmVsKSlcbiAgICAgICAgLm1hcCgobGFiZWwpID0+IGxhYmVsc1tsYWJlbF0pO1xuXG4gICAgICBjb25zdCB0aW1lVmFsdWVUdXBsZTogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbXTtcblxuICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICB2YWx1ZUZpZWxkLnZhbHVlcy50b0FycmF5KCkuZm9yRWFjaCgodmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgdGltZVN0YW1wVmFsdWU6IG51bWJlcjtcbiAgICAgICAgbGV0IHZhbHVlVmFsdWU6IG51bWJlcjtcbiAgICAgICAgY29uc3QgdGltZSA9IHRpbWVGaWVsZC52YWx1ZXMuZ2V0KGlkeCk7XG5cbiAgICAgICAgLy8gSWYgd2Ugd2FudCB0byB1c2UgdmFsdWUgYXMgYSB0aW1lLCB3ZSB1c2UgdmFsdWUgYXMgdGltZVN0YW1wVmFsdWUgYW5kIHZhbHVlVmFsdWUgd2lsbCBiZSAxXG4gICAgICAgIGlmIChvcHRpb25zLmFubm90YXRpb24udXNlVmFsdWVGb3JUaW1lKSB7XG4gICAgICAgICAgdGltZVN0YW1wVmFsdWUgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgICAgICB2YWx1ZVZhbHVlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lU3RhbXBWYWx1ZSA9IE1hdGguZmxvb3IocGFyc2VGbG9hdCh0aW1lKSk7XG4gICAgICAgICAgdmFsdWVWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWR4Kys7XG4gICAgICAgIHRpbWVWYWx1ZVR1cGxlLnB1c2goW3RpbWVTdGFtcFZhbHVlLCB2YWx1ZVZhbHVlXSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWN0aXZlVmFsdWVzID0gdGltZVZhbHVlVHVwbGUuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWVbMV0gPj0gMSk7XG4gICAgICBjb25zdCBhY3RpdmVWYWx1ZXNUaW1lc3RhbXBzID0gYWN0aXZlVmFsdWVzLm1hcCgodmFsdWUpID0+IHZhbHVlWzBdKTtcblxuICAgICAgLy8gSW5zdGVhZCBvZiBjcmVhdGluZyBzaW5ndWxhciBhbm5vdGF0aW9uIGZvciBlYWNoIGFjdGl2ZSBldmVudCB3ZSBncm91cCBldmVudHMgaW50byByZWdpb24gaWYgdGhleSBhcmUgbGVzc1xuICAgICAgLy8gb3IgZXF1YWwgdG8gYHN0ZXBgIGFwYXJ0LlxuICAgICAgbGV0IGxhdGVzdEV2ZW50OiBBbm5vdGF0aW9uRXZlbnQgfCBudWxsID0gbnVsbDtcblxuICAgICAgZm9yIChjb25zdCB0aW1lc3RhbXAgb2YgYWN0aXZlVmFsdWVzVGltZXN0YW1wcykge1xuICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgZXZlbnQgYG9wZW5gIGFuZCB3ZSBoYXZlIG5ldyBldmVudCB0aGF0IGlzIGluc2lkZSB0aGUgYHN0ZXBgIHNvIHdlIGp1c3QgdXBkYXRlIHRoZSBlbmQuXG4gICAgICAgIGlmIChsYXRlc3RFdmVudCAmJiAobGF0ZXN0RXZlbnQudGltZUVuZCA/PyAwKSArIHN0ZXAgPj0gdGltZXN0YW1wKSB7XG4gICAgICAgICAgbGF0ZXN0RXZlbnQudGltZUVuZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2ZW50IGV4aXN0cyBidXQgbmV3IG9uZSBpcyBvdXRzaWRlIG9mIHRoZSBgc3RlcGAgc28gd2UgYWRkIGl0IHRvIGV2ZW50TGlzdC5cbiAgICAgICAgaWYgKGxhdGVzdEV2ZW50KSB7XG4gICAgICAgICAgZXZlbnRMaXN0LnB1c2gobGF0ZXN0RXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugc3RhcnQgYSBuZXcgcmVnaW9uLlxuICAgICAgICBsYXRlc3RFdmVudCA9IHtcbiAgICAgICAgICB0aW1lOiB0aW1lc3RhbXAsXG4gICAgICAgICAgdGltZUVuZDogdGltZXN0YW1wLFxuICAgICAgICAgIGFubm90YXRpb24sXG4gICAgICAgICAgdGl0bGU6IHJlbmRlckxlZ2VuZEZvcm1hdCh0aXRsZUZvcm1hdCwgbGFiZWxzKSxcbiAgICAgICAgICB0YWdzLFxuICAgICAgICAgIHRleHQ6IHJlbmRlckxlZ2VuZEZvcm1hdCh0ZXh0Rm9ybWF0LCBsYWJlbHMpLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobGF0ZXN0RXZlbnQpIHtcbiAgICAgICAgLy8gRmluaXNoIHVwIGxhc3QgcG9pbnQgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgbGF0ZXN0RXZlbnQudGltZUVuZCA9IGFjdGl2ZVZhbHVlc1RpbWVzdGFtcHNbYWN0aXZlVmFsdWVzVGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICAgICAgZXZlbnRMaXN0LnB1c2gobGF0ZXN0RXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmVudExpc3Q7XG4gIH07XG5cbiAgZ2V0RXhlbXBsYXJzKHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0KSB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvdjEvcXVlcnlfZXhlbXBsYXJzJztcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tRXhlbXBsYXJEYXRhPj4oXG4gICAgICB1cmwsXG4gICAgICB7IHF1ZXJ5OiBxdWVyeS5leHByLCBzdGFydDogcXVlcnkuc3RhcnQudG9TdHJpbmcoKSwgZW5kOiBxdWVyeS5lbmQudG9TdHJpbmcoKSB9LFxuICAgICAgeyByZXF1ZXN0SWQ6IHF1ZXJ5LnJlcXVlc3RJZCwgaGVhZGVyczogcXVlcnkuaGVhZGVycyB9XG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGdldFN1YnRpdGxlKCk6IFByb21pc2U8SlNYLkVsZW1lbnQgfCBudWxsPiB7XG4gICAgY29uc3QgYnVpbGRJbmZvID0gYXdhaXQgdGhpcy5nZXRCdWlsZEluZm8oKTtcbiAgICByZXR1cm4gYnVpbGRJbmZvID8gdGhpcy5nZXRCdWlsZEluZm9NZXNzYWdlKGJ1aWxkSW5mbykgOiBudWxsO1xuICB9XG5cbiAgYXN5bmMgZ2V0VGFnS2V5cyhvcHRpb25zPzogYW55KSB7XG4gICAgaWYgKG9wdGlvbnM/LnNlcmllcykge1xuICAgICAgLy8gR2V0IHRhZ3MgZm9yIHRoZSBwcm92aWRlZCBzZXJpZXMgb25seVxuICAgICAgY29uc3Qgc2VyaWVzTGFiZWxzOiBBcnJheTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4+ID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIG9wdGlvbnMuc2VyaWVzLm1hcCgoc2VyaWVzOiBzdHJpbmcpID0+IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllc0xhYmVscyhzZXJpZXMpKVxuICAgICAgKTtcbiAgICAgIC8vIENvbWJpbmVzIHRhZ3MgZnJvbSBhbGwgb3B0aW9ucy5zZXJpZXMgcHJvdmlkZWRcbiAgICAgIGxldCB0YWdzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgc2VyaWVzTGFiZWxzLm1hcCgodmFsdWUpID0+ICh0YWdzID0gdGFncy5jb25jYXQoT2JqZWN0LmtleXModmFsdWUpKSkpO1xuICAgICAgY29uc3QgdW5pcXVlTGFiZWxzID0gWy4uLm5ldyBTZXQodGFncyldO1xuICAgICAgcmV0dXJuIHVuaXF1ZUxhYmVscy5tYXAoKHZhbHVlOiBhbnkpID0+ICh7IHRleHQ6IHZhbHVlIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR2V0IGFsbCB0YWdzXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm1ldGFkYXRhUmVxdWVzdCgnL2FwaS92MS9sYWJlbHMnKTtcbiAgICAgIHJldHVybiByZXN1bHQ/LmRhdGE/LmRhdGE/Lm1hcCgodmFsdWU6IGFueSkgPT4gKHsgdGV4dDogdmFsdWUgfSkpID8/IFtdO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFRhZ1ZhbHVlcyhvcHRpb25zOiB7IGtleT86IHN0cmluZyB9ID0ge30pIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm1ldGFkYXRhUmVxdWVzdChgL2FwaS92MS9sYWJlbC8ke29wdGlvbnMua2V5fS92YWx1ZXNgKTtcbiAgICByZXR1cm4gcmVzdWx0Py5kYXRhPy5kYXRhPy5tYXAoKHZhbHVlOiBhbnkpID0+ICh7IHRleHQ6IHZhbHVlIH0pKSA/PyBbXTtcbiAgfVxuXG4gIGFzeW5jIGdldEJ1aWxkSW5mbygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnVpbGRJbmZvID0gYXdhaXQgZGlzY292ZXJEYXRhU291cmNlRmVhdHVyZXMoeyB1cmw6IHRoaXMudXJsLCBuYW1lOiB0aGlzLm5hbWUsIHR5cGU6ICdwcm9tZXRoZXVzJyB9KTtcbiAgICAgIHJldHVybiBidWlsZEluZm87XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYnJlYWsgdGhlIHJlc3Qgb2YgZnVuY3Rpb25hbGl0eSBpZiBidWlsZCBpbmZvIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGdldEJ1aWxkSW5mb01lc3NhZ2UoYnVpbGRJbmZvOiBQcm9tQXBpRmVhdHVyZXMpIHtcbiAgICBjb25zdCBlbmFibGVkID0gPEJhZGdlIGNvbG9yPVwiZ3JlZW5cIiBpY29uPVwiY2hlY2tcIiB0ZXh0PVwiUnVsZXIgQVBJIGVuYWJsZWRcIiAvPjtcbiAgICBjb25zdCBkaXNhYmxlZCA9IDxCYWRnZSBjb2xvcj1cIm9yYW5nZVwiIGljb249XCJleGNsYW1hdGlvbi10cmlhbmdsZVwiIHRleHQ9XCJSdWxlciBBUEkgbm90IGVuYWJsZWRcIiAvPjtcbiAgICBjb25zdCB1bnN1cHBvcnRlZCA9IChcbiAgICAgIDxUb29sdGlwXG4gICAgICAgIHBsYWNlbWVudD1cInRvcFwiXG4gICAgICAgIGNvbnRlbnQ9XCJQcm9tZXRoZXVzIGRvZXMgbm90IGFsbG93IGVkaXRpbmcgcnVsZXMsIGNvbm5lY3QgdG8gZWl0aGVyIGEgTWltaXIgb3IgQ29ydGV4IGRhdGFzb3VyY2UgdG8gbWFuYWdlIGFsZXJ0cyB2aWEgR3JhZmFuYS5cIlxuICAgICAgPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxCYWRnZSBjb2xvcj1cInJlZFwiIGljb249XCJleGNsYW1hdGlvbi10cmlhbmdsZVwiIHRleHQ9XCJSdWxlciBBUEkgbm90IHN1cHBvcnRlZFwiIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9Ub29sdGlwPlxuICAgICk7XG5cbiAgICBjb25zdCBMT0dPUyA9IHtcbiAgICAgIFtQcm9tQXBwbGljYXRpb24uTG90ZXhdOiAnL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvaW1nL2NvcnRleF9sb2dvLnN2ZycsXG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLk1pbWlyXTogJy9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2ltZy9taW1pcl9sb2dvLnN2ZycsXG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXNdOiAnL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvaW1nL3Byb21ldGhldXNfbG9nby5zdmcnLFxuICAgIH07XG5cbiAgICBjb25zdCBDT0xPUlM6IFJlY29yZDxQcm9tQXBwbGljYXRpb24sIEJhZGdlQ29sb3I+ID0ge1xuICAgICAgW1Byb21BcHBsaWNhdGlvbi5Mb3RleF06ICdibHVlJyxcbiAgICAgIFtQcm9tQXBwbGljYXRpb24uTWltaXJdOiAnb3JhbmdlJyxcbiAgICAgIFtQcm9tQXBwbGljYXRpb24uUHJvbWV0aGV1c106ICdyZWQnLFxuICAgIH07XG5cbiAgICBjb25zdCBBcHBEaXNwbGF5TmFtZXM6IFJlY29yZDxQcm9tQXBwbGljYXRpb24sIHN0cmluZz4gPSB7XG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLkxvdGV4XTogJ0NvcnRleCcsXG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLk1pbWlyXTogJ01pbWlyJyxcbiAgICAgIFtQcm9tQXBwbGljYXRpb24uUHJvbWV0aGV1c106ICdQcm9tZXRoZXVzJyxcbiAgICB9O1xuXG4gICAgLy8gdGhpcyB3aWxsIGluZm9ybSB0aGUgdXNlciBhYm91dCB3aGF0IFwic3VidHlwZVwiIHRoZSBkYXRhc291cmNlIGlzOyBNaW1pciwgQ29ydGV4IG9yIHZhbmlsbGEgUHJvbWV0aGV1c1xuICAgIGNvbnN0IGFwcGxpY2F0aW9uU3ViVHlwZSA9IChcbiAgICAgIDxCYWRnZVxuICAgICAgICB0ZXh0PXtcbiAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IDE0LCBoZWlnaHQ6IDE0LCB2ZXJ0aWNhbEFsaWduOiAndGV4dC1ib3R0b20nIH19XG4gICAgICAgICAgICAgIHNyYz17TE9HT1NbYnVpbGRJbmZvLmFwcGxpY2F0aW9uID8/IFByb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzXX1cbiAgICAgICAgICAgIC8+eycgJ31cbiAgICAgICAgICAgIHtidWlsZEluZm8uYXBwbGljYXRpb24gPyBBcHBEaXNwbGF5TmFtZXNbYnVpbGRJbmZvLmFwcGxpY2F0aW9uXSA6ICdVbmtub3duJ31cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIH1cbiAgICAgICAgY29sb3I9e0NPTE9SU1tidWlsZEluZm8uYXBwbGljYXRpb24gPz8gUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXNdfVxuICAgICAgLz5cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogJ21heC1jb250ZW50IG1heC1jb250ZW50JyxcbiAgICAgICAgICByb3dHYXA6ICcwLjVyZW0nLFxuICAgICAgICAgIGNvbHVtbkdhcDogJzJyZW0nLFxuICAgICAgICAgIG1hcmdpblRvcDogJzFyZW0nLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICA8ZGl2PlR5cGU8L2Rpdj5cbiAgICAgICAgPGRpdj57YXBwbGljYXRpb25TdWJUeXBlfTwvZGl2PlxuICAgICAgICA8PlxuICAgICAgICAgIDxkaXY+UnVsZXIgQVBJPC9kaXY+XG4gICAgICAgICAgey8qIFByb21ldGhldXMgZG9lcyBub3QgaGF2ZSBhIFJ1bGVyIEFQSSDigJMgc28gc2hvdyB0aGF0IGl0IGlzIG5vdCBzdXBwb3J0ZWQgKi99XG4gICAgICAgICAge2J1aWxkSW5mby5hcHBsaWNhdGlvbiA9PT0gUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXMgJiYgPGRpdj57dW5zdXBwb3J0ZWR9PC9kaXY+fVxuICAgICAgICAgIHtidWlsZEluZm8uYXBwbGljYXRpb24gIT09IFByb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzICYmIChcbiAgICAgICAgICAgIDxkaXY+e2J1aWxkSW5mby5mZWF0dXJlcy5ydWxlckFwaUVuYWJsZWQgPyBlbmFibGVkIDogZGlzYWJsZWR9PC9kaXY+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgYXN5bmMgdGVzdERhdGFzb3VyY2UoKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgcmVxdWVzdDogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+ID0ge1xuICAgICAgdGFyZ2V0czogW3sgcmVmSWQ6ICd0ZXN0JywgZXhwcjogJzErMScsIGluc3RhbnQ6IHRydWUgfV0sXG4gICAgICByZXF1ZXN0SWQ6IGAke3RoaXMuaWR9LWhlYWx0aGAsXG4gICAgICBzY29wZWRWYXJzOiB7fSxcbiAgICAgIGRhc2hib2FyZElkOiAwLFxuICAgICAgcGFuZWxJZDogMCxcbiAgICAgIGludGVydmFsOiAnMW0nLFxuICAgICAgaW50ZXJ2YWxNczogNjAwMDAsXG4gICAgICBtYXhEYXRhUG9pbnRzOiAxLFxuICAgICAgcmFuZ2U6IHtcbiAgICAgICAgZnJvbTogZGF0ZVRpbWUobm93IC0gMTAwMCksXG4gICAgICAgIHRvOiBkYXRlVGltZShub3cpLFxuICAgICAgfSxcbiAgICB9IGFzIERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5PjtcblxuICAgIGNvbnN0IGJ1aWxkSW5mbyA9IGF3YWl0IHRoaXMuZ2V0QnVpbGRJbmZvKCk7XG5cbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbSh0aGlzLnF1ZXJ5KHJlcXVlc3QpKVxuICAgICAgLnRoZW4oKHJlczogRGF0YVF1ZXJ5UmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKCFyZXMgfHwgIXJlcy5kYXRhIHx8IHJlcy5zdGF0ZSAhPT0gTG9hZGluZ1N0YXRlLkRvbmUpIHtcbiAgICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6IGBFcnJvciByZWFkaW5nIFByb21ldGhldXM6ICR7cmVzPy5lcnJvcj8ubWVzc2FnZX1gIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0RhdGEgc291cmNlIGlzIHdvcmtpbmcnLFxuICAgICAgICAgICAgZGV0YWlsczogYnVpbGRJbmZvICYmIHtcbiAgICAgICAgICAgICAgdmVyYm9zZU1lc3NhZ2U6IHRoaXMuZ2V0QnVpbGRJbmZvTWVzc2FnZShidWlsZEluZm8pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnI6IGFueSkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdQcm9tZXRoZXVzIEVycm9yJywgZXJyKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBtZXNzYWdlOiBlcnIubWVzc2FnZSB9O1xuICAgICAgfSk7XG4gIH1cblxuICBpbnRlcnBvbGF0ZVZhcmlhYmxlc0luUXVlcmllcyhxdWVyaWVzOiBQcm9tUXVlcnlbXSwgc2NvcGVkVmFyczogU2NvcGVkVmFycyk6IFByb21RdWVyeVtdIHtcbiAgICBsZXQgZXhwYW5kZWRRdWVyaWVzID0gcXVlcmllcztcbiAgICBpZiAocXVlcmllcyAmJiBxdWVyaWVzLmxlbmd0aCkge1xuICAgICAgZXhwYW5kZWRRdWVyaWVzID0gcXVlcmllcy5tYXAoKHF1ZXJ5KSA9PiB7XG4gICAgICAgIGNvbnN0IGV4cGFuZGVkUXVlcnkgPSB7XG4gICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgZGF0YXNvdXJjZTogdGhpcy5nZXRSZWYoKSxcbiAgICAgICAgICBleHByOiB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UocXVlcnkuZXhwciwgc2NvcGVkVmFycywgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwciksXG4gICAgICAgICAgaW50ZXJ2YWw6IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShxdWVyeS5pbnRlcnZhbCwgc2NvcGVkVmFycyksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBleHBhbmRlZFF1ZXJ5O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRlZFF1ZXJpZXM7XG4gIH1cblxuICBnZXRRdWVyeUhpbnRzKHF1ZXJ5OiBQcm9tUXVlcnksIHJlc3VsdDogYW55W10pIHtcbiAgICByZXR1cm4gZ2V0UXVlcnlIaW50cyhxdWVyeS5leHByID8/ICcnLCByZXN1bHQsIHRoaXMpO1xuICB9XG5cbiAgZ2V0SW5pdEhpbnRzKCkge1xuICAgIHJldHVybiBnZXRJbml0SGludHModGhpcyk7XG4gIH1cblxuICBhc3luYyBsb2FkUnVsZXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KCcvYXBpL3YxL3J1bGVzJyk7XG4gICAgICBjb25zdCBncm91cHMgPSByZXMuZGF0YT8uZGF0YT8uZ3JvdXBzO1xuXG4gICAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgIHRoaXMucnVsZU1hcHBpbmdzID0gZXh0cmFjdFJ1bGVNYXBwaW5nRnJvbUdyb3Vwcyhncm91cHMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdSdWxlcyBBUEkgaXMgZXhwZXJpbWVudGFsLiBJZ25vcmUgbmV4dCBlcnJvci4nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgYXJlRXhlbXBsYXJzQXZhaWxhYmxlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldFJlc291cmNlKCcvYXBpL3YxL3F1ZXJ5X2V4ZW1wbGFycycsIHtcbiAgICAgICAgcXVlcnk6ICd0ZXN0JyxcbiAgICAgICAgc3RhcnQ6IGRhdGVUaW1lKCkuc3VidHJhY3QoMzAsICdtaW51dGVzJykudmFsdWVPZigpLFxuICAgICAgICBlbmQ6IGRhdGVUaW1lKCkudmFsdWVPZigpLFxuICAgICAgfSk7XG4gICAgICBpZiAocmVzLmRhdGEuc3RhdHVzID09PSAnc3VjY2VzcycpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgbW9kaWZ5UXVlcnkocXVlcnk6IFByb21RdWVyeSwgYWN0aW9uOiBhbnkpOiBQcm9tUXVlcnkge1xuICAgIGxldCBleHByZXNzaW9uID0gcXVlcnkuZXhwciA/PyAnJztcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdBRERfRklMVEVSJzoge1xuICAgICAgICBleHByZXNzaW9uID0gYWRkTGFiZWxUb1F1ZXJ5KGV4cHJlc3Npb24sIGFjdGlvbi5rZXksIGFjdGlvbi52YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnQUREX0ZJTFRFUl9PVVQnOiB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBhZGRMYWJlbFRvUXVlcnkoZXhwcmVzc2lvbiwgYWN0aW9uLmtleSwgYWN0aW9uLnZhbHVlLCAnIT0nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdBRERfSElTVE9HUkFNX1FVQU5USUxFJzoge1xuICAgICAgICBleHByZXNzaW9uID0gYGhpc3RvZ3JhbV9xdWFudGlsZSgwLjk1LCBzdW0ocmF0ZSgke2V4cHJlc3Npb259WyRfX3JhdGVfaW50ZXJ2YWxdKSkgYnkgKGxlKSlgO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0FERF9SQVRFJzoge1xuICAgICAgICBleHByZXNzaW9uID0gYHJhdGUoJHtleHByZXNzaW9ufVskX19yYXRlX2ludGVydmFsXSlgO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0FERF9TVU0nOiB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBgc3VtKCR7ZXhwcmVzc2lvbi50cmltKCl9KSBieSAoJDEpYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdFWFBBTkRfUlVMRVMnOiB7XG4gICAgICAgIGlmIChhY3Rpb24ubWFwcGluZykge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBleHBhbmRSZWNvcmRpbmdSdWxlcyhleHByZXNzaW9uLCBhY3Rpb24ubWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4ucXVlcnksIGV4cHI6IGV4cHJlc3Npb24gfTtcbiAgfVxuXG4gIGdldFByb21ldGhldXNUaW1lKGRhdGU6IHN0cmluZyB8IERhdGVUaW1lLCByb3VuZFVwOiBib29sZWFuKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgZGF0ZSA9IGRhdGVNYXRoLnBhcnNlKGRhdGUsIHJvdW5kVXApITtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5jZWlsKGRhdGUudmFsdWVPZigpIC8gMTAwMCk7XG4gIH1cblxuICBnZXRUaW1lUmFuZ2VQYXJhbXMoKTogeyBzdGFydDogc3RyaW5nOyBlbmQ6IHN0cmluZyB9IHtcbiAgICBjb25zdCByYW5nZSA9IHRoaXMudGltZVNydi50aW1lUmFuZ2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHRoaXMuZ2V0UHJvbWV0aGV1c1RpbWUocmFuZ2UuZnJvbSwgZmFsc2UpLnRvU3RyaW5nKCksXG4gICAgICBlbmQ6IHRoaXMuZ2V0UHJvbWV0aGV1c1RpbWUocmFuZ2UudG8sIHRydWUpLnRvU3RyaW5nKCksXG4gICAgfTtcbiAgfVxuXG4gIGdldE9yaWdpbmFsTWV0cmljTmFtZShsYWJlbERhdGE6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0pIHtcbiAgICByZXR1cm4gZ2V0T3JpZ2luYWxNZXRyaWNOYW1lKGxhYmVsRGF0YSk7XG4gIH1cblxuICBlbmhhbmNlRXhwcldpdGhBZEhvY0ZpbHRlcnMoZXhwcjogc3RyaW5nKSB7XG4gICAgY29uc3QgYWRob2NGaWx0ZXJzID0gdGhpcy50ZW1wbGF0ZVNydi5nZXRBZGhvY0ZpbHRlcnModGhpcy5uYW1lKTtcblxuICAgIGNvbnN0IGZpbmFsUXVlcnkgPSBhZGhvY0ZpbHRlcnMucmVkdWNlKChhY2M6IHN0cmluZywgZmlsdGVyOiB7IGtleT86IGFueTsgb3BlcmF0b3I/OiBhbnk7IHZhbHVlPzogYW55IH0pID0+IHtcbiAgICAgIGNvbnN0IHsga2V5LCBvcGVyYXRvciB9ID0gZmlsdGVyO1xuICAgICAgbGV0IHsgdmFsdWUgfSA9IGZpbHRlcjtcbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJz1+JyB8fCBvcGVyYXRvciA9PT0gJyF+Jykge1xuICAgICAgICB2YWx1ZSA9IHByb21ldGhldXNSZWd1bGFyRXNjYXBlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZGRMYWJlbFRvUXVlcnkoYWNjLCBrZXksIHZhbHVlLCBvcGVyYXRvcik7XG4gICAgfSwgZXhwcik7XG4gICAgcmV0dXJuIGZpbmFsUXVlcnk7XG4gIH1cblxuICAvLyBVc2VkIHdoZW4gcnVubmluZyBxdWVyaWVzIHRyb3VnaCBiYWNrZW5kXG4gIGZpbHRlclF1ZXJ5KHF1ZXJ5OiBQcm9tUXVlcnkpOiBib29sZWFuIHtcbiAgICBpZiAocXVlcnkuaGlkZSB8fCAhcXVlcnkuZXhwcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFVzZWQgd2hlbiBydW5uaW5nIHF1ZXJpZXMgdHJvdWdoIGJhY2tlbmRcbiAgYXBwbHlUZW1wbGF0ZVZhcmlhYmxlcyh0YXJnZXQ6IFByb21RdWVyeSwgc2NvcGVkVmFyczogU2NvcGVkVmFycyk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IGNsb25lRGVlcChzY29wZWRWYXJzKTtcblxuICAgIC8vIFdlIHdhbnQgdG8gaW50ZXJwb2xhdGUgdGhlc2UgdmFyaWFibGVzIG9uIGJhY2tlbmRcbiAgICBkZWxldGUgdmFyaWFibGVzLl9faW50ZXJ2YWw7XG4gICAgZGVsZXRlIHZhcmlhYmxlcy5fX2ludGVydmFsX21zO1xuXG4gICAgLy9BZGQgYWQgaG9jIGZpbHRlcnNcbiAgICBjb25zdCBleHByID0gdGhpcy5lbmhhbmNlRXhwcldpdGhBZEhvY0ZpbHRlcnModGFyZ2V0LmV4cHIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIGxlZ2VuZEZvcm1hdDogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5sZWdlbmRGb3JtYXQsIHZhcmlhYmxlcyksXG4gICAgICBleHByOiB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UoZXhwciwgdmFyaWFibGVzLCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKSxcbiAgICAgIGludGVydmFsOiB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UodGFyZ2V0LmludGVydmFsLCB2YXJpYWJsZXMpLFxuICAgIH07XG4gIH1cblxuICBnZXRWYXJpYWJsZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlU3J2LmdldFZhcmlhYmxlcygpLm1hcCgodikgPT4gYCQke3YubmFtZX1gKTtcbiAgfVxuXG4gIGludGVycG9sYXRlU3RyaW5nKHN0cmluZzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShzdHJpbmcsIHVuZGVmaW5lZCwgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwcik7XG4gIH1cbn1cblxuLyoqXG4gKiBBbGlnbiBxdWVyeSByYW5nZSB0byBzdGVwLlxuICogUm91bmRzIHN0YXJ0IGFuZCBlbmQgZG93biB0byBhIG11bHRpcGxlIG9mIHN0ZXAuXG4gKiBAcGFyYW0gc3RhcnQgVGltZXN0YW1wIG1hcmtpbmcgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0gZW5kIFRpbWVzdGFtcCBtYXJraW5nIHRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHN0ZXAgSW50ZXJ2YWwgdG8gYWxpZ24gc3RhcnQgYW5kIGVuZCB3aXRoLlxuICogQHBhcmFtIHV0Y09mZnNldFNlYyBOdW1iZXIgb2Ygc2Vjb25kcyBjdXJyZW50IHRpbWV6b25lIGlzIG9mZnNldCBmcm9tIFVUQ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWxpZ25SYW5nZShcbiAgc3RhcnQ6IG51bWJlcixcbiAgZW5kOiBudW1iZXIsXG4gIHN0ZXA6IG51bWJlcixcbiAgdXRjT2Zmc2V0U2VjOiBudW1iZXJcbik6IHsgZW5kOiBudW1iZXI7IHN0YXJ0OiBudW1iZXIgfSB7XG4gIGNvbnN0IGFsaWduZWRFbmQgPSBNYXRoLmZsb29yKChlbmQgKyB1dGNPZmZzZXRTZWMpIC8gc3RlcCkgKiBzdGVwIC0gdXRjT2Zmc2V0U2VjO1xuICBjb25zdCBhbGlnbmVkU3RhcnQgPSBNYXRoLmZsb29yKChzdGFydCArIHV0Y09mZnNldFNlYykgLyBzdGVwKSAqIHN0ZXAgLSB1dGNPZmZzZXRTZWM7XG4gIHJldHVybiB7XG4gICAgZW5kOiBhbGlnbmVkRW5kLFxuICAgIHN0YXJ0OiBhbGlnbmVkU3RhcnQsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UnVsZU1hcHBpbmdGcm9tR3JvdXBzKGdyb3VwczogYW55W10pIHtcbiAgcmV0dXJuIGdyb3Vwcy5yZWR1Y2UoXG4gICAgKG1hcHBpbmcsIGdyb3VwKSA9PlxuICAgICAgZ3JvdXAucnVsZXNcbiAgICAgICAgLmZpbHRlcigocnVsZTogYW55KSA9PiBydWxlLnR5cGUgPT09ICdyZWNvcmRpbmcnKVxuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgIChhY2M6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sIHJ1bGU6IGFueSkgPT4gKHtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIFtydWxlLm5hbWVdOiBydWxlLnF1ZXJ5LFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG1hcHBpbmdcbiAgICAgICAgKSxcbiAgICB7fVxuICApO1xufVxuXG4vLyBOT1RFOiB0aGVzZSB0d28gZnVuY3Rpb25zIGFyZSB2ZXJ5IHNpbWlsYXIgdG8gdGhlIGVzY2FwZUxhYmVsVmFsdWVJbiogZnVuY3Rpb25zXG4vLyBpbiBsYW5ndWFnZV91dGlscy50cywgYnV0IHRoZXkgYXJlIG5vdCBleGFjdGx5IHRoZSBzYW1lIGFsZ29yaXRobSwgYW5kIHdlIGZvdW5kXG4vLyBubyB3YXkgdG8gcmV1c2Ugb25lIGluIHRoZSBhbm90aGVyIG9yIHZpY2UgdmVyc2EuXG5leHBvcnQgZnVuY3Rpb24gcHJvbWV0aGV1c1JlZ3VsYXJFc2NhcGUodmFsdWU6IGFueSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvJy9nLCBcIlxcXFxcXFxcJ1wiKSA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvbWV0aGV1c1NwZWNpYWxSZWdleEVzY2FwZSh2YWx1ZTogYW55KSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFxcXFxcXFxcXCcpLnJlcGxhY2UoL1skXip7fVxcW1xcXVxcJys/LigpfF0vZywgJ1xcXFxcXFxcJCYnKSA6IHZhbHVlO1xufVxuIiwiaW1wb3J0IHsgb25jZSwgY2hhaW4sIGRpZmZlcmVuY2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IExSVSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IFByaXNtIGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdzbGF0ZSc7XG5cbmltcG9ydCB7XG4gIEFic3RyYWN0TGFiZWxNYXRjaGVyLFxuICBBYnN0cmFjdExhYmVsT3BlcmF0b3IsXG4gIEFic3RyYWN0UXVlcnksXG4gIGRhdGVUaW1lLFxuICBIaXN0b3J5SXRlbSxcbiAgTGFuZ3VhZ2VQcm92aWRlcixcbn0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBDb21wbGV0aW9uSXRlbSwgQ29tcGxldGlvbkl0ZW1Hcm91cCwgU2VhcmNoRnVuY3Rpb25UeXBlLCBUeXBlYWhlYWRJbnB1dCwgVHlwZWFoZWFkT3V0cHV0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5pbXBvcnQge1xuICBhZGRMaW1pdEluZm8sXG4gIGV4dHJhY3RMYWJlbE1hdGNoZXJzLFxuICBmaXhTdW1tYXJpZXNNZXRhZGF0YSxcbiAgcGFyc2VTZWxlY3RvcixcbiAgcHJvY2Vzc0hpc3RvZ3JhbU1ldHJpY3MsXG4gIHByb2Nlc3NMYWJlbHMsXG4gIHJvdW5kU2VjVG9NaW4sXG4gIHRvUHJvbUxpa2VRdWVyeSxcbn0gZnJvbSAnLi9sYW5ndWFnZV91dGlscyc7XG5pbXBvcnQgUHJvbXFsU3ludGF4LCB7IEZVTkNUSU9OUywgUkFURV9SQU5HRVMgfSBmcm9tICcuL3Byb21xbCc7XG5pbXBvcnQgeyBQcm9tTWV0cmljc01ldGFkYXRhLCBQcm9tUXVlcnkgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgREVGQVVMVF9LRVlTID0gWydqb2InLCAnaW5zdGFuY2UnXTtcbmNvbnN0IEVNUFRZX1NFTEVDVE9SID0gJ3t9JztcbmNvbnN0IEhJU1RPUllfSVRFTV9DT1VOVCA9IDU7XG5jb25zdCBISVNUT1JZX0NPVU5UX0NVVE9GRiA9IDEwMDAgKiA2MCAqIDYwICogMjQ7IC8vIDI0aFxuLy8gTWF4IG51bWJlciBvZiBpdGVtcyAobWV0cmljcywgbGFiZWxzLCB2YWx1ZXMpIHRoYXQgd2UgZGlzcGxheSBhcyBzdWdnZXN0aW9ucy4gUHJldmVudHMgZnJvbSBydW5uaW5nIG91dCBvZiBtZW1vcnkuXG5leHBvcnQgY29uc3QgU1VHR0VTVElPTlNfTElNSVQgPSAxMDAwMDtcblxuY29uc3Qgd3JhcExhYmVsID0gKGxhYmVsOiBzdHJpbmcpOiBDb21wbGV0aW9uSXRlbSA9PiAoeyBsYWJlbCB9KTtcblxuY29uc3Qgc2V0RnVuY3Rpb25LaW5kID0gKHN1Z2dlc3Rpb246IENvbXBsZXRpb25JdGVtKTogQ29tcGxldGlvbkl0ZW0gPT4ge1xuICBzdWdnZXN0aW9uLmtpbmQgPSAnZnVuY3Rpb24nO1xuICByZXR1cm4gc3VnZ2VzdGlvbjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRIaXN0b3J5TWV0YWRhdGEoaXRlbTogQ29tcGxldGlvbkl0ZW0sIGhpc3Rvcnk6IGFueVtdKTogQ29tcGxldGlvbkl0ZW0ge1xuICBjb25zdCBjdXRvZmZUcyA9IERhdGUubm93KCkgLSBISVNUT1JZX0NPVU5UX0NVVE9GRjtcbiAgY29uc3QgaGlzdG9yeUZvckl0ZW0gPSBoaXN0b3J5LmZpbHRlcigoaCkgPT4gaC50cyA+IGN1dG9mZlRzICYmIGgucXVlcnkgPT09IGl0ZW0ubGFiZWwpO1xuICBjb25zdCBjb3VudCA9IGhpc3RvcnlGb3JJdGVtLmxlbmd0aDtcbiAgY29uc3QgcmVjZW50ID0gaGlzdG9yeUZvckl0ZW1bMF07XG4gIGxldCBoaW50ID0gYFF1ZXJpZWQgJHtjb3VudH0gdGltZXMgaW4gdGhlIGxhc3QgMjRoLmA7XG5cbiAgaWYgKHJlY2VudCkge1xuICAgIGNvbnN0IGxhc3RRdWVyaWVkID0gZGF0ZVRpbWUocmVjZW50LnRzKS5mcm9tTm93KCk7XG4gICAgaGludCA9IGAke2hpbnR9IExhc3QgcXVlcmllZCAke2xhc3RRdWVyaWVkfS5gO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5pdGVtLFxuICAgIGRvY3VtZW50YXRpb246IGhpbnQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZE1ldHJpY3NNZXRhZGF0YShtZXRyaWM6IHN0cmluZywgbWV0YWRhdGE/OiBQcm9tTWV0cmljc01ldGFkYXRhKTogQ29tcGxldGlvbkl0ZW0ge1xuICBjb25zdCBpdGVtOiBDb21wbGV0aW9uSXRlbSA9IHsgbGFiZWw6IG1ldHJpYyB9O1xuICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGFbbWV0cmljXSkge1xuICAgIGl0ZW0uZG9jdW1lbnRhdGlvbiA9IGdldE1ldGFkYXRhU3RyaW5nKG1ldHJpYywgbWV0YWRhdGEpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0YWRhdGFTdHJpbmcobWV0cmljOiBzdHJpbmcsIG1ldGFkYXRhOiBQcm9tTWV0cmljc01ldGFkYXRhKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFtZXRhZGF0YVttZXRyaWNdKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCB7IHR5cGUsIGhlbHAgfSA9IG1ldGFkYXRhW21ldHJpY107XG4gIHJldHVybiBgJHt0eXBlLnRvVXBwZXJDYXNlKCl9OiAke2hlbHB9YDtcbn1cblxuY29uc3QgUFJFRklYX0RFTElNSVRFUl9SRUdFWCA9XG4gIC8oPVwifCE9XCJ8PX5cInwhflwifFxce3xcXFt8XFwofFxcK3wtfFxcL3xcXCp8JXxcXF58XFxiYW5kXFxifFxcYm9yXFxifFxcYnVubGVzc1xcYnw9PXw+PXwhPXw8PXw+fDx8PXx+fCwpLztcblxuaW50ZXJmYWNlIEF1dG9jb21wbGV0ZUNvbnRleHQge1xuICBoaXN0b3J5PzogQXJyYXk8SGlzdG9yeUl0ZW08UHJvbVF1ZXJ5Pj47XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9tUWxMYW5ndWFnZVByb3ZpZGVyIGV4dGVuZHMgTGFuZ3VhZ2VQcm92aWRlciB7XG4gIGhpc3RvZ3JhbU1ldHJpY3M6IHN0cmluZ1tdO1xuICB0aW1lUmFuZ2U/OiB7IHN0YXJ0OiBudW1iZXI7IGVuZDogbnVtYmVyIH07XG4gIG1ldHJpY3M6IHN0cmluZ1tdO1xuICBtZXRyaWNzTWV0YWRhdGE/OiBQcm9tTWV0cmljc01ldGFkYXRhO1xuICBkZWNsYXJlIHN0YXJ0VGFzazogUHJvbWlzZTxhbnk+O1xuICBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZTtcbiAgbGFiZWxLZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBkZWNsYXJlIGxhYmVsRmV0Y2hUczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiAgQ2FjaGUgZm9yIGxhYmVscyBvZiBzZXJpZXMuIFRoaXMgaXMgYml0IHNpbXBsaXN0aWMgaW4gdGhlIHNlbnNlIHRoYXQgaXQganVzdCBjb3VudHMgcmVzcG9uc2VzIGVhY2ggYXMgYSAxIGFuZCBkb2VzXG4gICAqICBub3QgYWNjb3VudCBmb3IgZGlmZmVyZW50IHNpemUgb2YgYSByZXNwb25zZS4gSWYgdGhhdCBpcyBuZWVkZWQgYSBgbGVuZ3RoYCBmdW5jdGlvbiBjYW4gYmUgYWRkZWQgaW4gdGhlIG9wdGlvbnMuXG4gICAqICAxMCBhcyBhIG1heCBzaXplIGlzIHRvdGFsbHkgYXJiaXRyYXJ5IHJpZ2h0IG5vdy5cbiAgICovXG4gIHByaXZhdGUgbGFiZWxzQ2FjaGUgPSBuZXcgTFJVPHN0cmluZywgUmVjb3JkPHN0cmluZywgc3RyaW5nW10+Pih7IG1heDogMTAgfSk7XG5cbiAgY29uc3RydWN0b3IoZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2UsIGluaXRpYWxWYWx1ZXM/OiBQYXJ0aWFsPFByb21RbExhbmd1YWdlUHJvdmlkZXI+KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZGF0YXNvdXJjZSA9IGRhdGFzb3VyY2U7XG4gICAgdGhpcy5oaXN0b2dyYW1NZXRyaWNzID0gW107XG4gICAgdGhpcy50aW1lUmFuZ2UgPSB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgICB0aGlzLm1ldHJpY3MgPSBbXTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgaW5pdGlhbFZhbHVlcyk7XG4gIH1cblxuICAvLyBTdHJpcCBzeW50YXggY2hhcnMgc28gdGhhdCB0eXBlYWhlYWQgc3VnZ2VzdGlvbnMgY2FuIHdvcmsgb24gY2xlYW4gaW5wdXRzXG4gIGNsZWFuVGV4dChzOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHMuc3BsaXQoUFJFRklYX0RFTElNSVRFUl9SRUdFWCk7XG4gICAgY29uc3QgbGFzdCA9IHBhcnRzLnBvcCgpITtcbiAgICByZXR1cm4gbGFzdC50cmltTGVmdCgpLnJlcGxhY2UoL1wiJC8sICcnKS5yZXBsYWNlKC9eXCIvLCAnJyk7XG4gIH1cblxuICBnZXQgc3ludGF4KCkge1xuICAgIHJldHVybiBQcm9tcWxTeW50YXg7XG4gIH1cblxuICByZXF1ZXN0ID0gYXN5bmMgKHVybDogc3RyaW5nLCBkZWZhdWx0VmFsdWU6IGFueSwgcGFyYW1zID0ge30pOiBQcm9taXNlPGFueT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRhdGFzb3VyY2UubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKTtcbiAgICAgIHJldHVybiByZXMuZGF0YS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9O1xuXG4gIHN0YXJ0ID0gYXN5bmMgKCk6IFByb21pc2U8YW55W10+ID0+IHtcbiAgICBpZiAodGhpcy5kYXRhc291cmNlLmxvb2t1cHNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIFRPRE8gIzMzOTc2OiBtYWtlIHRob3NlIHJlcXVlc3RzIHBhcmFsbGVsXG4gICAgYXdhaXQgdGhpcy5mZXRjaExhYmVscygpO1xuICAgIHRoaXMubWV0cmljcyA9IChhd2FpdCB0aGlzLmZldGNoTGFiZWxWYWx1ZXMoJ19fbmFtZV9fJykpIHx8IFtdO1xuICAgIGF3YWl0IHRoaXMubG9hZE1ldHJpY3NNZXRhZGF0YSgpO1xuICAgIHRoaXMuaGlzdG9ncmFtTWV0cmljcyA9IHByb2Nlc3NIaXN0b2dyYW1NZXRyaWNzKHRoaXMubWV0cmljcykuc29ydCgpO1xuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICBhc3luYyBsb2FkTWV0cmljc01ldGFkYXRhKCkge1xuICAgIHRoaXMubWV0cmljc01ldGFkYXRhID0gZml4U3VtbWFyaWVzTWV0YWRhdGEoYXdhaXQgdGhpcy5yZXF1ZXN0KCcvYXBpL3YxL21ldGFkYXRhJywge30pKTtcbiAgfVxuXG4gIGdldExhYmVsS2V5cygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMubGFiZWxLZXlzO1xuICB9XG5cbiAgcHJvdmlkZUNvbXBsZXRpb25JdGVtcyA9IGFzeW5jIChcbiAgICB7IHByZWZpeCwgdGV4dCwgdmFsdWUsIGxhYmVsS2V5LCB3cmFwcGVyQ2xhc3NlcyB9OiBUeXBlYWhlYWRJbnB1dCxcbiAgICBjb250ZXh0OiBBdXRvY29tcGxldGVDb250ZXh0ID0ge31cbiAgKTogUHJvbWlzZTxUeXBlYWhlYWRPdXRwdXQ+ID0+IHtcbiAgICBjb25zdCBlbXB0eVJlc3VsdDogVHlwZWFoZWFkT3V0cHV0ID0geyBzdWdnZXN0aW9uczogW10gfTtcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBlbXB0eVJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBMb2NhbCB0ZXh0IHByb3BlcnRpZXNcbiAgICBjb25zdCBlbXB0eSA9IHZhbHVlLmRvY3VtZW50LnRleHQubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IHNlbGVjdGVkTGluZXMgPSB2YWx1ZS5kb2N1bWVudC5nZXRUZXh0c0F0UmFuZ2UodmFsdWUuc2VsZWN0aW9uKTtcbiAgICBjb25zdCBjdXJyZW50TGluZSA9IHNlbGVjdGVkTGluZXMuc2l6ZSA9PT0gMSA/IHNlbGVjdGVkTGluZXMuZmlyc3QoKS5nZXRUZXh0KCkgOiBudWxsO1xuXG4gICAgY29uc3QgbmV4dENoYXJhY3RlciA9IGN1cnJlbnRMaW5lID8gY3VycmVudExpbmVbdmFsdWUuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXRdIDogbnVsbDtcblxuICAgIC8vIFN5bnRheCBzcGFucyBoYXZlIDMgY2xhc3NlcyBieSBkZWZhdWx0LiBNb3JlIGluZGljYXRlIGEgcmVjb2duaXplZCB0b2tlblxuICAgIGNvbnN0IHRva2VuUmVjb2duaXplZCA9IHdyYXBwZXJDbGFzc2VzLmxlbmd0aCA+IDM7XG4gICAgLy8gTm9uLWVtcHR5IHByZWZpeCwgYnV0IG5vdCBpbnNpZGUga25vd24gdG9rZW5cbiAgICBjb25zdCBwcmVmaXhVbnJlY29nbml6ZWQgPSBwcmVmaXggJiYgIXRva2VuUmVjb2duaXplZDtcblxuICAgIC8vIFByZXZlbnQgc3VnZ2VzdGlvbnMgaW4gYGZ1bmN0aW9uKHxzdWZmaXgpYFxuICAgIGNvbnN0IG5vU3VmZml4ID0gIW5leHRDaGFyYWN0ZXIgfHwgbmV4dENoYXJhY3RlciA9PT0gJyknO1xuXG4gICAgLy8gUHJlZml4IGlzIHNhZmUgaWYgaXQgZG9lcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93IGEgY29tcGxldGUgZXhwcmVzc2lvbiBhbmQgaGFzIG5vIHRleHQgYWZ0ZXIgaXRcbiAgICBjb25zdCBzYWZlUHJlZml4ID0gcHJlZml4ICYmICF0ZXh0Lm1hdGNoKC9eW1xcXX0pXFxzXSskLykgJiYgbm9TdWZmaXg7XG5cbiAgICAvLyBBYm91dCB0byB0eXBlIG5leHQgb3BlcmFuZCBpZiBwcmVjZWRlZCBieSBiaW5hcnkgb3BlcmF0b3JcbiAgICBjb25zdCBvcGVyYXRvcnNQYXR0ZXJuID0gL1srXFwtKi9eJV0vO1xuICAgIGNvbnN0IGlzTmV4dE9wZXJhbmQgPSB0ZXh0Lm1hdGNoKG9wZXJhdG9yc1BhdHRlcm4pO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGNhbmRpZGF0ZXMgYnkgQ1NTIGNvbnRleHRcbiAgICBpZiAod3JhcHBlckNsYXNzZXMuaW5jbHVkZXMoJ2NvbnRleHQtcmFuZ2UnKSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIG1ldHJpY1t8XVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFuZ2VDb21wbGV0aW9uSXRlbXMoKTtcbiAgICB9IGVsc2UgaWYgKHdyYXBwZXJDbGFzc2VzLmluY2x1ZGVzKCdjb250ZXh0LWxhYmVscycpKSB7XG4gICAgICAvLyBTdWdnZXN0aW9ucyBmb3IgbWV0cmlje3x9IGFuZCBtZXRyaWN7Zm9vPXx9LCBhcyB3ZWxsIGFzIG1ldHJpYy1pbmRlcGVuZGVudCBsYWJlbCBxdWVyaWVzIGxpa2Uge3x9XG4gICAgICByZXR1cm4gdGhpcy5nZXRMYWJlbENvbXBsZXRpb25JdGVtcyh7IHByZWZpeCwgdGV4dCwgdmFsdWUsIGxhYmVsS2V5LCB3cmFwcGVyQ2xhc3NlcyB9KTtcbiAgICB9IGVsc2UgaWYgKHdyYXBwZXJDbGFzc2VzLmluY2x1ZGVzKCdjb250ZXh0LWFnZ3JlZ2F0aW9uJykpIHtcbiAgICAgIC8vIFN1Z2dlc3Rpb25zIGZvciBzdW0obWV0cmljKSBieSAofClcbiAgICAgIHJldHVybiB0aGlzLmdldEFnZ3JlZ2F0aW9uQ29tcGxldGlvbkl0ZW1zKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGVtcHR5KSB7XG4gICAgICAvLyBTdWdnZXN0aW9ucyBmb3IgZW1wdHkgcXVlcnkgZmllbGRcbiAgICAgIHJldHVybiB0aGlzLmdldEVtcHR5Q29tcGxldGlvbkl0ZW1zKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocHJlZml4VW5yZWNvZ25pemVkICYmIG5vU3VmZml4ICYmICFpc05leHRPcGVyYW5kKSB7XG4gICAgICAvLyBTaG93IHRlcm0gc3VnZ2VzdGlvbnMgaW4gYSBjb3VwbGUgb2Ygc2NlbmFyaW9zXG4gICAgICByZXR1cm4gdGhpcy5nZXRCZWdpbm5pbmdDb21wbGV0aW9uSXRlbXMoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChwcmVmaXhVbnJlY29nbml6ZWQgJiYgc2FmZVByZWZpeCkge1xuICAgICAgLy8gU2hvdyB0ZXJtIHN1Z2dlc3Rpb25zIGluIGEgY291cGxlIG9mIHNjZW5hcmlvc1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGVybUNvbXBsZXRpb25JdGVtcygpO1xuICAgIH1cblxuICAgIHJldHVybiBlbXB0eVJlc3VsdDtcbiAgfTtcblxuICBnZXRCZWdpbm5pbmdDb21wbGV0aW9uSXRlbXMgPSAoY29udGV4dDogQXV0b2NvbXBsZXRlQ29udGV4dCk6IFR5cGVhaGVhZE91dHB1dCA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Z2dlc3Rpb25zOiBbLi4udGhpcy5nZXRFbXB0eUNvbXBsZXRpb25JdGVtcyhjb250ZXh0KS5zdWdnZXN0aW9ucywgLi4udGhpcy5nZXRUZXJtQ29tcGxldGlvbkl0ZW1zKCkuc3VnZ2VzdGlvbnNdLFxuICAgIH07XG4gIH07XG5cbiAgZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXMgPSAoY29udGV4dDogQXV0b2NvbXBsZXRlQ29udGV4dCk6IFR5cGVhaGVhZE91dHB1dCA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBDb21wbGV0aW9uSXRlbUdyb3VwW10gPSBbXTtcblxuICAgIGlmIChoaXN0b3J5ICYmIGhpc3RvcnkubGVuZ3RoKSB7XG4gICAgICBjb25zdCBoaXN0b3J5SXRlbXMgPSBjaGFpbihoaXN0b3J5KVxuICAgICAgICAubWFwKChoKSA9PiBoLnF1ZXJ5LmV4cHIpXG4gICAgICAgIC5maWx0ZXIoKVxuICAgICAgICAudW5pcSgpXG4gICAgICAgIC50YWtlKEhJU1RPUllfSVRFTV9DT1VOVClcbiAgICAgICAgLm1hcCh3cmFwTGFiZWwpXG4gICAgICAgIC5tYXAoKGl0ZW0pID0+IGFkZEhpc3RvcnlNZXRhZGF0YShpdGVtLCBoaXN0b3J5KSlcbiAgICAgICAgLnZhbHVlKCk7XG5cbiAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICBzZWFyY2hGdW5jdGlvblR5cGU6IFNlYXJjaEZ1bmN0aW9uVHlwZS5QcmVmaXgsXG4gICAgICAgIHNraXBTb3J0OiB0cnVlLFxuICAgICAgICBsYWJlbDogJ0hpc3RvcnknLFxuICAgICAgICBpdGVtczogaGlzdG9yeUl0ZW1zLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgfTtcblxuICBnZXRUZXJtQ29tcGxldGlvbkl0ZW1zID0gKCk6IFR5cGVhaGVhZE91dHB1dCA9PiB7XG4gICAgY29uc3QgeyBtZXRyaWNzLCBtZXRyaWNzTWV0YWRhdGEgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IENvbXBsZXRpb25JdGVtR3JvdXBbXSA9IFtdO1xuXG4gICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICBzZWFyY2hGdW5jdGlvblR5cGU6IFNlYXJjaEZ1bmN0aW9uVHlwZS5QcmVmaXgsXG4gICAgICBsYWJlbDogJ0Z1bmN0aW9ucycsXG4gICAgICBpdGVtczogRlVOQ1RJT05TLm1hcChzZXRGdW5jdGlvbktpbmQpLFxuICAgIH0pO1xuXG4gICAgaWYgKG1ldHJpY3MgJiYgbWV0cmljcy5sZW5ndGgpIHtcbiAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICBsYWJlbDogJ01ldHJpY3MnLFxuICAgICAgICBpdGVtczogbWV0cmljcy5tYXAoKG0pID0+IGFkZE1ldHJpY3NNZXRhZGF0YShtLCBtZXRyaWNzTWV0YWRhdGEpKSxcbiAgICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuRnV6enksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdWdnZXN0aW9ucyB9O1xuICB9O1xuXG4gIGdldFJhbmdlQ29tcGxldGlvbkl0ZW1zKCk6IFR5cGVhaGVhZE91dHB1dCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQ6ICdjb250ZXh0LXJhbmdlJyxcbiAgICAgIHN1Z2dlc3Rpb25zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBsYWJlbDogJ1JhbmdlIHZlY3RvcicsXG4gICAgICAgICAgaXRlbXM6IFsuLi5SQVRFX1JBTkdFU10sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH1cblxuICBnZXRBZ2dyZWdhdGlvbkNvbXBsZXRpb25JdGVtcyA9IGFzeW5jICh2YWx1ZTogVmFsdWUpOiBQcm9taXNlPFR5cGVhaGVhZE91dHB1dD4gPT4ge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBDb21wbGV0aW9uSXRlbUdyb3VwW10gPSBbXTtcblxuICAgIC8vIFN0aXRjaCBhbGwgcXVlcnkgbGluZXMgdG9nZXRoZXIgdG8gc3VwcG9ydCBtdWx0aS1saW5lIHF1ZXJpZXNcbiAgICBsZXQgcXVlcnlPZmZzZXQ7XG4gICAgY29uc3QgcXVlcnlUZXh0ID0gdmFsdWUuZG9jdW1lbnQuZ2V0QmxvY2tzKCkucmVkdWNlKCh0ZXh0LCBibG9jaykgPT4ge1xuICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBibG9ja1RleHQgPSBibG9jaz8uZ2V0VGV4dCgpO1xuXG4gICAgICBpZiAodmFsdWUuYW5jaG9yQmxvY2sua2V5ID09PSBibG9jay5rZXkpIHtcbiAgICAgICAgLy8gTmV3bGluZSBjaGFyYWN0ZXJzIGFyZSBub3QgYWNjb3VudGVkIGZvciBidXQgdGhpcyBpcyBpcnJlbGV2YW50XG4gICAgICAgIC8vIGZvciB0aGUgcHVycG9zZSBvZiBleHRyYWN0aW5nIHRoZSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgcXVlcnlPZmZzZXQgPSB2YWx1ZS5zZWxlY3Rpb24uYW5jaG9yLm9mZnNldCArIHRleHQubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dCArIGJsb2NrVGV4dDtcbiAgICB9LCAnJyk7XG5cbiAgICAvLyBUcnkgc2VhcmNoIGZvciBzZWxlY3RvciBwYXJ0IG9uIHRoZSBsZWZ0LWhhbmQgc2lkZSwgc3VjaCBhcyBgc3VtIChtKSBieSAobClgXG4gICAgY29uc3Qgb3BlblBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXggPSBxdWVyeVRleHQubGFzdEluZGV4T2YoJygnLCBxdWVyeU9mZnNldCk7XG4gICAgbGV0IG9wZW5QYXJlbnNTZWxlY3RvckluZGV4ID0gcXVlcnlUZXh0Lmxhc3RJbmRleE9mKCcoJywgb3BlblBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXggLSAxKTtcbiAgICBsZXQgY2xvc2VQYXJlbnNTZWxlY3RvckluZGV4ID0gcXVlcnlUZXh0LmluZGV4T2YoJyknLCBvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCk7XG5cbiAgICAvLyBUcnkgc2VhcmNoIGZvciBzZWxlY3RvciBwYXJ0IG9mIGFuIGFsdGVybmF0ZSBhZ2dyZWdhdGlvbiBjbGF1c2UsIHN1Y2ggYXMgYHN1bSBieSAobCkgKG0pYFxuICAgIGlmIChvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IGNsb3NlUGFyZW5zQWdncmVnYXRpb25JbmRleCA9IHF1ZXJ5VGV4dC5pbmRleE9mKCcpJywgcXVlcnlPZmZzZXQpO1xuICAgICAgY2xvc2VQYXJlbnNTZWxlY3RvckluZGV4ID0gcXVlcnlUZXh0LmluZGV4T2YoJyknLCBjbG9zZVBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXggKyAxKTtcbiAgICAgIG9wZW5QYXJlbnNTZWxlY3RvckluZGV4ID0gcXVlcnlUZXh0Lmxhc3RJbmRleE9mKCcoJywgY2xvc2VQYXJlbnNTZWxlY3RvckluZGV4KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBzdWdnZXN0aW9ucyxcbiAgICAgIGNvbnRleHQ6ICdjb250ZXh0LWFnZ3JlZ2F0aW9uJyxcbiAgICB9O1xuXG4gICAgLy8gU3VnZ2VzdGlvbnMgYXJlIHVzZWxlc3MgZm9yIGFsdGVybmF0aXZlIGFnZ3JlZ2F0aW9uIGNsYXVzZXMgd2l0aG91dCBhIHNlbGVjdG9yIGluIGNvbnRleHRcbiAgICBpZiAob3BlblBhcmVuc1NlbGVjdG9ySW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFJhbmdlIHZlY3RvciBzeW50YXggbm90IGFjY291bnRlZCBmb3IgYnkgc3Vic2VxdWVudCBwYXJzZSBzbyBkaXNjYXJkIGl0IGlmIHByZXNlbnRcbiAgICBjb25zdCBzZWxlY3RvclN0cmluZyA9IHF1ZXJ5VGV4dFxuICAgICAgLnNsaWNlKG9wZW5QYXJlbnNTZWxlY3RvckluZGV4ICsgMSwgY2xvc2VQYXJlbnNTZWxlY3RvckluZGV4KVxuICAgICAgLnJlcGxhY2UoL1xcW1teXFxdXStcXF0kLywgJycpO1xuXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBwYXJzZVNlbGVjdG9yKHNlbGVjdG9yU3RyaW5nLCBzZWxlY3RvclN0cmluZy5sZW5ndGggLSAyKS5zZWxlY3RvcjtcblxuICAgIGNvbnN0IHNlcmllcyA9IGF3YWl0IHRoaXMuZ2V0U2VyaWVzKHNlbGVjdG9yKTtcbiAgICBjb25zdCBsYWJlbEtleXMgPSBPYmplY3Qua2V5cyhzZXJpZXMpO1xuICAgIGlmIChsYWJlbEtleXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGltaXRJbmZvID0gYWRkTGltaXRJbmZvKGxhYmVsS2V5cyk7XG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgbGFiZWw6IGBMYWJlbHMke2xpbWl0SW5mb31gLFxuICAgICAgICBpdGVtczogbGFiZWxLZXlzLm1hcCh3cmFwTGFiZWwpLFxuICAgICAgICBzZWFyY2hGdW5jdGlvblR5cGU6IFNlYXJjaEZ1bmN0aW9uVHlwZS5GdXp6eSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGdldExhYmVsQ29tcGxldGlvbkl0ZW1zID0gYXN5bmMgKHtcbiAgICB0ZXh0LFxuICAgIHdyYXBwZXJDbGFzc2VzLFxuICAgIGxhYmVsS2V5LFxuICAgIHZhbHVlLFxuICB9OiBUeXBlYWhlYWRJbnB1dCk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnM6IFtdIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IENvbXBsZXRpb25JdGVtR3JvdXBbXSA9IFtdO1xuICAgIGNvbnN0IGxpbmUgPSB2YWx1ZS5hbmNob3JCbG9jay5nZXRUZXh0KCk7XG4gICAgY29uc3QgY3Vyc29yT2Zmc2V0ID0gdmFsdWUuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQ7XG4gICAgY29uc3Qgc3VmZml4ID0gbGluZS5zdWJzdHIoY3Vyc29yT2Zmc2V0KTtcbiAgICBjb25zdCBwcmVmaXggPSBsaW5lLnN1YnN0cigwLCBjdXJzb3JPZmZzZXQpO1xuICAgIGNvbnN0IGlzVmFsdWVTdGFydCA9IHRleHQubWF0Y2goL14oPXw9fnwhPXwhfikvKTtcbiAgICBjb25zdCBpc1ZhbHVlRW5kID0gc3VmZml4Lm1hdGNoKC9eXCI/Wyx9XXwkLyk7XG4gICAgLy8gRGV0ZWN0IGN1cnNvciBpbiBmcm9udCBvZiB2YWx1ZSwgZS5nLiwge2tleT18XCJ9XG4gICAgY29uc3QgaXNQcmVWYWx1ZSA9IHByZWZpeC5tYXRjaCgvKD18PX58IT18IX4pJC8pICYmIHN1ZmZpeC5tYXRjaCgvXlwiLyk7XG5cbiAgICAvLyBEb24ndCBzdWdnZXN0IGFueXRoaW5nIGF0IHRoZSBiZWdpbm5pbmcgb3IgaW5zaWRlIGEgdmFsdWVcbiAgICBjb25zdCBpc1ZhbHVlRW1wdHkgPSBpc1ZhbHVlU3RhcnQgJiYgaXNWYWx1ZUVuZDtcbiAgICBjb25zdCBoYXNWYWx1ZVByZWZpeCA9IGlzVmFsdWVFbmQgJiYgIWlzVmFsdWVTdGFydDtcbiAgICBpZiAoKCFpc1ZhbHVlRW1wdHkgJiYgIWhhc1ZhbHVlUHJlZml4KSB8fCBpc1ByZVZhbHVlKSB7XG4gICAgICByZXR1cm4geyBzdWdnZXN0aW9ucyB9O1xuICAgIH1cblxuICAgIC8vIEdldCBub3JtYWxpemVkIHNlbGVjdG9yXG4gICAgbGV0IHNlbGVjdG9yO1xuICAgIGxldCBwYXJzZWRTZWxlY3RvcjtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkU2VsZWN0b3IgPSBwYXJzZVNlbGVjdG9yKGxpbmUsIGN1cnNvck9mZnNldCk7XG4gICAgICBzZWxlY3RvciA9IHBhcnNlZFNlbGVjdG9yLnNlbGVjdG9yO1xuICAgIH0gY2F0Y2gge1xuICAgICAgc2VsZWN0b3IgPSBFTVBUWV9TRUxFQ1RPUjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250YWluc01ldHJpYyA9IHNlbGVjdG9yLmluY2x1ZGVzKCdfX25hbWVfXz0nKTtcbiAgICBjb25zdCBleGlzdGluZ0tleXMgPSBwYXJzZWRTZWxlY3RvciA/IHBhcnNlZFNlbGVjdG9yLmxhYmVsS2V5cyA6IFtdO1xuXG4gICAgbGV0IHNlcmllczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge307XG4gICAgLy8gUXVlcnkgbGFiZWxzIGZvciBzZWxlY3RvclxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgc2VyaWVzID0gYXdhaXQgdGhpcy5nZXRTZXJpZXMoc2VsZWN0b3IsICFjb250YWluc01ldHJpYyk7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHNlcmllcykubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFNlcnZlciBkaWQgbm90IHJldHVybiBhbnkgdmFsdWVzIGZvciBzZWxlY3RvciA9ICR7c2VsZWN0b3J9YCk7XG4gICAgICByZXR1cm4geyBzdWdnZXN0aW9ucyB9O1xuICAgIH1cblxuICAgIGxldCBjb250ZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoKHRleHQgJiYgaXNWYWx1ZVN0YXJ0KSB8fCB3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnYXR0ci12YWx1ZScpKSB7XG4gICAgICAvLyBMYWJlbCB2YWx1ZXNcbiAgICAgIGlmIChsYWJlbEtleSAmJiBzZXJpZXNbbGFiZWxLZXldKSB7XG4gICAgICAgIGNvbnRleHQgPSAnY29udGV4dC1sYWJlbC12YWx1ZXMnO1xuICAgICAgICBjb25zdCBsaW1pdEluZm8gPSBhZGRMaW1pdEluZm8oc2VyaWVzW2xhYmVsS2V5XSk7XG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgIGxhYmVsOiBgTGFiZWwgdmFsdWVzIGZvciBcIiR7bGFiZWxLZXl9XCIke2xpbWl0SW5mb31gLFxuICAgICAgICAgIGl0ZW1zOiBzZXJpZXNbbGFiZWxLZXldLm1hcCh3cmFwTGFiZWwpLFxuICAgICAgICAgIHNlYXJjaEZ1bmN0aW9uVHlwZTogU2VhcmNoRnVuY3Rpb25UeXBlLkZ1enp5LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGFiZWwga2V5c1xuICAgICAgY29uc3QgbGFiZWxLZXlzID0gc2VyaWVzID8gT2JqZWN0LmtleXMoc2VyaWVzKSA6IGNvbnRhaW5zTWV0cmljID8gbnVsbCA6IERFRkFVTFRfS0VZUztcblxuICAgICAgaWYgKGxhYmVsS2V5cykge1xuICAgICAgICBjb25zdCBwb3NzaWJsZUtleXMgPSBkaWZmZXJlbmNlKGxhYmVsS2V5cywgZXhpc3RpbmdLZXlzKTtcbiAgICAgICAgaWYgKHBvc3NpYmxlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZXh0ID0gJ2NvbnRleHQtbGFiZWxzJztcbiAgICAgICAgICBjb25zdCBuZXdJdGVtcyA9IHBvc3NpYmxlS2V5cy5tYXAoKGtleSkgPT4gKHsgbGFiZWw6IGtleSB9KSk7XG4gICAgICAgICAgY29uc3QgbGltaXRJbmZvID0gYWRkTGltaXRJbmZvKG5ld0l0ZW1zKTtcbiAgICAgICAgICBjb25zdCBuZXdTdWdnZXN0aW9uOiBDb21wbGV0aW9uSXRlbUdyb3VwID0ge1xuICAgICAgICAgICAgbGFiZWw6IGBMYWJlbHMke2xpbWl0SW5mb31gLFxuICAgICAgICAgICAgaXRlbXM6IG5ld0l0ZW1zLFxuICAgICAgICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuRnV6enksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKG5ld1N1Z2dlc3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY29udGV4dCwgc3VnZ2VzdGlvbnMgfTtcbiAgfTtcblxuICBpbXBvcnRGcm9tQWJzdHJhY3RRdWVyeShsYWJlbEJhc2VkUXVlcnk6IEFic3RyYWN0UXVlcnkpOiBQcm9tUXVlcnkge1xuICAgIHJldHVybiB0b1Byb21MaWtlUXVlcnkobGFiZWxCYXNlZFF1ZXJ5KTtcbiAgfVxuXG4gIGV4cG9ydFRvQWJzdHJhY3RRdWVyeShxdWVyeTogUHJvbVF1ZXJ5KTogQWJzdHJhY3RRdWVyeSB7XG4gICAgY29uc3QgcHJvbVF1ZXJ5ID0gcXVlcnkuZXhwcjtcbiAgICBpZiAoIXByb21RdWVyeSB8fCBwcm9tUXVlcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4geyByZWZJZDogcXVlcnkucmVmSWQsIGxhYmVsTWF0Y2hlcnM6IFtdIH07XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IFByaXNtLnRva2VuaXplKHByb21RdWVyeSwgUHJvbXFsU3ludGF4KTtcbiAgICBjb25zdCBsYWJlbE1hdGNoZXJzOiBBYnN0cmFjdExhYmVsTWF0Y2hlcltdID0gZXh0cmFjdExhYmVsTWF0Y2hlcnModG9rZW5zKTtcbiAgICBjb25zdCBuYW1lTGFiZWxWYWx1ZSA9IGdldE5hbWVMYWJlbFZhbHVlKHByb21RdWVyeSwgdG9rZW5zKTtcbiAgICBpZiAobmFtZUxhYmVsVmFsdWUgJiYgbmFtZUxhYmVsVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgbGFiZWxNYXRjaGVycy5wdXNoKHtcbiAgICAgICAgbmFtZTogJ19fbmFtZV9fJyxcbiAgICAgICAgb3BlcmF0b3I6IEFic3RyYWN0TGFiZWxPcGVyYXRvci5FcXVhbCxcbiAgICAgICAgdmFsdWU6IG5hbWVMYWJlbFZhbHVlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZklkOiBxdWVyeS5yZWZJZCxcbiAgICAgIGxhYmVsTWF0Y2hlcnMsXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldFNlcmllcyhzZWxlY3Rvcjogc3RyaW5nLCB3aXRoTmFtZT86IGJvb2xlYW4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPj4ge1xuICAgIGlmICh0aGlzLmRhdGFzb3VyY2UubG9va3Vwc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IEVNUFRZX1NFTEVDVE9SKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoRGVmYXVsdFNlcmllcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hTZXJpZXNMYWJlbHMoc2VsZWN0b3IsIHdpdGhOYW1lKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVE9ETzogYmV0dGVyIGVycm9yIGhhbmRsaW5nXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICBmZXRjaExhYmVsVmFsdWVzID0gYXN5bmMgKGtleTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4gPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCB1cmwgPSBgL2FwaS92MS9sYWJlbC8ke3RoaXMuZGF0YXNvdXJjZS5pbnRlcnBvbGF0ZVN0cmluZyhrZXkpfS92YWx1ZXNgO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3QodXJsLCBbXSwgcGFyYW1zKTtcbiAgfTtcblxuICBhc3luYyBnZXRMYWJlbFZhbHVlcyhrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaExhYmVsVmFsdWVzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgbGFiZWwga2V5c1xuICAgKi9cbiAgYXN5bmMgZmV0Y2hMYWJlbHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHVybCA9ICcvYXBpL3YxL2xhYmVscyc7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIHRoaXMubGFiZWxGZXRjaFRzID0gRGF0ZS5ub3coKS52YWx1ZU9mKCk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcXVlc3QodXJsLCBbXSwgcGFyYW1zKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKSB7XG4gICAgICB0aGlzLmxhYmVsS2V5cyA9IHJlcy5zbGljZSgpLnNvcnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGFiZWxzIGZvciBhIHNlcmllcy4gVGhpcyBpcyBjYWNoZWQgYnkgaXQncyBhcmdzIGJ1dCBhbHNvIGJ5IHRoZSBnbG9iYWwgdGltZVJhbmdlIGN1cnJlbnRseSBzZWxlY3RlZCBhc1xuICAgKiB0aGV5IGNhbiBjaGFuZ2Ugb3ZlciByZXF1ZXN0ZWQgdGltZS5cbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHBhcmFtIHdpdGhOYW1lXG4gICAqL1xuICBmZXRjaFNlcmllc0xhYmVscyA9IGFzeW5jIChuYW1lOiBzdHJpbmcsIHdpdGhOYW1lPzogYm9vbGVhbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nW10+PiA9PiB7XG4gICAgY29uc3QgaW50ZXJwb2xhdGVkTmFtZSA9IHRoaXMuZGF0YXNvdXJjZS5pbnRlcnBvbGF0ZVN0cmluZyhuYW1lKTtcbiAgICBjb25zdCByYW5nZSA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCB1cmxQYXJhbXMgPSB7XG4gICAgICAuLi5yYW5nZSxcbiAgICAgICdtYXRjaFtdJzogaW50ZXJwb2xhdGVkTmFtZSxcbiAgICB9O1xuICAgIGNvbnN0IHVybCA9IGAvYXBpL3YxL3Nlcmllc2A7XG4gICAgLy8gQ2FjaGUga2V5IGlzIGEgYml0IGRpZmZlcmVudCBoZXJlLiBXZSBhZGQgdGhlIGB3aXRoTmFtZWAgcGFyYW0gYW5kIGFsc28gcm91bmQgdXAgdG8gYSBtaW51dGUgdGhlIGludGVydmFscy5cbiAgICAvLyBUaGUgcm91bmRpbmcgbWF5IHNlZW0gc3RyYW5nZSBidXQgbWFrZXMgcmVsYXRpdmUgaW50ZXJ2YWxzIGxpa2Ugbm93LTFoIGxlc3MgcHJvbmUgdG8gbmVlZCBzZXBhcmF0ZSByZXF1ZXN0IGV2ZXJ5XG4gICAgLy8gbWlsbGlzZWNvbmQgd2hpbGUgc3RpbGwgYWN0dWFsbHkgZ2V0dGluZyBhbGwgdGhlIGtleXMgZm9yIHRoZSBjb3JyZWN0IGludGVydmFsLiBUaGlzIHN0aWxsIGNhbiBjcmVhdGUgcHJvYmxlbXNcbiAgICAvLyB3aGVuIHVzZXIgZG9lcyBub3QgdGhlIG5ld2VzdCB2YWx1ZXMgZm9yIGEgbWludXRlIGlmIGFscmVhZHkgY2FjaGVkLlxuICAgIGNvbnN0IGNhY2hlUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAnbWF0Y2hbXSc6IGludGVycG9sYXRlZE5hbWUsXG4gICAgICBzdGFydDogcm91bmRTZWNUb01pbihwYXJzZUludChyYW5nZS5zdGFydCwgMTApKS50b1N0cmluZygpLFxuICAgICAgZW5kOiByb3VuZFNlY1RvTWluKHBhcnNlSW50KHJhbmdlLmVuZCwgMTApKS50b1N0cmluZygpLFxuICAgICAgd2l0aE5hbWU6IHdpdGhOYW1lID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNhY2hlS2V5ID0gYC9hcGkvdjEvc2VyaWVzPyR7Y2FjaGVQYXJhbXMudG9TdHJpbmcoKX1gO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubGFiZWxzQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwgW10sIHVybFBhcmFtcyk7XG4gICAgICBjb25zdCB7IHZhbHVlcyB9ID0gcHJvY2Vzc0xhYmVscyhkYXRhLCB3aXRoTmFtZSk7XG4gICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgIHRoaXMubGFiZWxzQ2FjaGUuc2V0KGNhY2hlS2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogRmV0Y2ggc2VyaWVzIGZvciBhIHNlbGVjdG9yLiBVc2UgdGhpcyBmb3IgcmF3IHJlc3VsdHMuIFVzZSBmZXRjaFNlcmllc0xhYmVscygpIHRvIGdldCBsYWJlbHMuXG4gICAqIEBwYXJhbSBtYXRjaFxuICAgKi9cbiAgZmV0Y2hTZXJpZXMgPSBhc3luYyAobWF0Y2g6IHN0cmluZyk6IFByb21pc2U8QXJyYXk8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4+ID0+IHtcbiAgICBjb25zdCB1cmwgPSAnL2FwaS92MS9zZXJpZXMnO1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgLi4ucmFuZ2UsICdtYXRjaFtdJzogbWF0Y2ggfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwge30sIHBhcmFtcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoaXMgb25seSBvbmUgYXMgd2UgYXNzdW1lIHRoaXMgd29uJ3QgY2hhbmdlIG92ZXIgdGltZS4gVGhpcyBpcyBjYWNoZWQgZGlmZmVyZW50bHkgZnJvbSBmZXRjaFNlcmllc0xhYmVsc1xuICAgKiBiZWNhdXNlIHdlIGNhbiBjYWNoZSBtb3JlIGFnZ3Jlc3NpdmVseSBoZXJlIGFuZCBhbHNvIHdlIGRvIG5vdCB3YW50IHRvIGludmFsaWRhdGUgdGhpcyBjYWNoZSB0aGUgc2FtZSB3YXkgYXMgaW5cbiAgICogZmV0Y2hTZXJpZXNMYWJlbHMuXG4gICAqL1xuICBmZXRjaERlZmF1bHRTZXJpZXMgPSBvbmNlKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChERUZBVUxUX0tFWVMubWFwKChrZXkpID0+IHRoaXMuZmV0Y2hMYWJlbFZhbHVlcyhrZXkpKSk7XG4gICAgcmV0dXJuIERFRkFVTFRfS0VZUy5yZWR1Y2UoKGFjYywga2V5LCBpKSA9PiAoeyAuLi5hY2MsIFtrZXldOiB2YWx1ZXNbaV0gfSksIHt9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE5hbWVMYWJlbFZhbHVlKHByb21RdWVyeTogc3RyaW5nLCB0b2tlbnM6IGFueSk6IHN0cmluZyB7XG4gIGxldCBuYW1lTGFiZWxWYWx1ZSA9ICcnO1xuICBmb3IgKGxldCBwcm9wIGluIHRva2Vucykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW3Byb3BdID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZUxhYmVsVmFsdWUgPSB0b2tlbnNbcHJvcF0gYXMgc3RyaW5nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBuYW1lTGFiZWxWYWx1ZTtcbn1cbiIsImltcG9ydCB7IGludmVydCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gJ3ByaXNtanMnO1xuXG5pbXBvcnQgeyBEYXRhUXVlcnksIEFic3RyYWN0UXVlcnksIEFic3RyYWN0TGFiZWxPcGVyYXRvciwgQWJzdHJhY3RMYWJlbE1hdGNoZXIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgYWRkTGFiZWxUb1F1ZXJ5IH0gZnJvbSAnLi9hZGRfbGFiZWxfdG9fcXVlcnknO1xuaW1wb3J0IHsgU1VHR0VTVElPTlNfTElNSVQgfSBmcm9tICcuL2xhbmd1YWdlX3Byb3ZpZGVyJztcbmltcG9ydCB7IFByb21NZXRyaWNzTWV0YWRhdGEsIFByb21NZXRyaWNzTWV0YWRhdGFJdGVtIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBwcm9jZXNzSGlzdG9ncmFtTWV0cmljcyA9IChtZXRyaWNzOiBzdHJpbmdbXSkgPT4ge1xuICBjb25zdCByZXN1bHRTZXQ6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKCdfYnVja2V0KCR8OiknKTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG1ldHJpY3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgbWV0cmljID0gbWV0cmljc1tpbmRleF07XG4gICAgY29uc3QgaXNIaXN0b2dyYW1WYWx1ZSA9IHJlZ2V4cC50ZXN0KG1ldHJpYyk7XG4gICAgaWYgKGlzSGlzdG9ncmFtVmFsdWUpIHtcbiAgICAgIHJlc3VsdFNldC5hZGQobWV0cmljKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5yZXN1bHRTZXRdO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NMYWJlbHMobGFiZWxzOiBBcnJheTx7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9Piwgd2l0aE5hbWUgPSBmYWxzZSkge1xuICAvLyBGb3IgcHJvY2Vzc2luZyB3ZSBhcmUgZ29pbmcgdG8gdXNlIHNldHMgYXMgdGhleSBoYXZlIHNpZ25pZmljYW50bHkgYmV0dGVyIHBlcmZvcm1hbmNlIHRoYW4gYXJyYXlzXG4gIC8vIEFmdGVyIHdlIHByb2Nlc3MgbGFiZWxzLCB3ZSB3aWxsIGNvbnZlcnQgc2V0cyB0byBhcnJheXMgYW5kIHJldHVybiBvYmplY3Qgd2l0aCBsYWJlbCB2YWx1ZXMgaW4gYXJyYXlzXG4gIGNvbnN0IHZhbHVlU2V0OiB7IFtrZXk6IHN0cmluZ106IFNldDxzdHJpbmc+IH0gPSB7fTtcbiAgbGFiZWxzLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgY29uc3QgeyBfX25hbWVfXywgLi4ucmVzdCB9ID0gbGFiZWw7XG4gICAgaWYgKHdpdGhOYW1lKSB7XG4gICAgICB2YWx1ZVNldFsnX19uYW1lX18nXSA9IHZhbHVlU2V0WydfX25hbWVfXyddIHx8IG5ldyBTZXQoKTtcbiAgICAgIGlmICghdmFsdWVTZXRbJ19fbmFtZV9fJ10uaGFzKF9fbmFtZV9fKSkge1xuICAgICAgICB2YWx1ZVNldFsnX19uYW1lX18nXS5hZGQoX19uYW1lX18pO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHJlc3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKCF2YWx1ZVNldFtrZXldKSB7XG4gICAgICAgIHZhbHVlU2V0W2tleV0gPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbHVlU2V0W2tleV0uaGFzKHJlc3Rba2V5XSkpIHtcbiAgICAgICAgdmFsdWVTZXRba2V5XS5hZGQocmVzdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdmFsdWVBcnJheSB0aGF0IHdlIGFyZSBnb2luZyB0byByZXR1cm4gaW4gdGhlIG9iamVjdFxuICBjb25zdCB2YWx1ZUFycmF5OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZ1tdIH0gPSB7fTtcbiAgbGltaXRTdWdnZXN0aW9ucyhPYmplY3Qua2V5cyh2YWx1ZVNldCkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHZhbHVlQXJyYXlba2V5XSA9IGxpbWl0U3VnZ2VzdGlvbnMoQXJyYXkuZnJvbSh2YWx1ZVNldFtrZXldKSk7XG4gIH0pO1xuXG4gIHJldHVybiB7IHZhbHVlczogdmFsdWVBcnJheSwga2V5czogT2JqZWN0LmtleXModmFsdWVBcnJheSkgfTtcbn1cblxuLy8gY29uc3QgY2xlYW5TZWxlY3RvclJlZ2V4cCA9IC9cXHsoXFx3Kz1cIlteXCJcXG5dKj9cIikoLFxcdys9XCJbXlwiXFxuXSo/XCIpKlxcfS87XG5leHBvcnQgY29uc3Qgc2VsZWN0b3JSZWdleHAgPSAvXFx7W159XSo/KFxcfXwkKS87XG5leHBvcnQgY29uc3QgbGFiZWxSZWdleHAgPSAvXFxiKFxcdyspKCE/PX4/KShcIlteXCJcXG5dKj9cIikvZztcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNlbGVjdG9yKHF1ZXJ5OiBzdHJpbmcsIGN1cnNvck9mZnNldCA9IDEpOiB7IGxhYmVsS2V5czogYW55W107IHNlbGVjdG9yOiBzdHJpbmcgfSB7XG4gIGlmICghcXVlcnkubWF0Y2goc2VsZWN0b3JSZWdleHApKSB7XG4gICAgLy8gU3BlY2lhbCBtYXRjaGVyIGZvciBtZXRyaWNzXG4gICAgaWYgKHF1ZXJ5Lm1hdGNoKC9eW0EtWmEtejpdW1xcdzpdKiQvKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3I6IGB7X19uYW1lX189XCIke3F1ZXJ5fVwifWAsXG4gICAgICAgIGxhYmVsS2V5czogWydfX25hbWVfXyddLFxuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeSBtdXN0IGNvbnRhaW4gYSBzZWxlY3RvcjogJyArIHF1ZXJ5KTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGluc2lkZSBhIHNlbGVjdG9yXG4gIGNvbnN0IHByZWZpeCA9IHF1ZXJ5LnNsaWNlKDAsIGN1cnNvck9mZnNldCk7XG4gIGNvbnN0IHByZWZpeE9wZW4gPSBwcmVmaXgubGFzdEluZGV4T2YoJ3snKTtcbiAgY29uc3QgcHJlZml4Q2xvc2UgPSBwcmVmaXgubGFzdEluZGV4T2YoJ30nKTtcbiAgaWYgKHByZWZpeE9wZW4gPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW5zaWRlIHNlbGVjdG9yLCBtaXNzaW5nIG9wZW4gYnJhY2U6ICcgKyBwcmVmaXgpO1xuICB9XG4gIGlmIChwcmVmaXhDbG9zZSA+IC0xICYmIHByZWZpeENsb3NlID4gcHJlZml4T3Blbikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGluc2lkZSBzZWxlY3RvciwgcHJldmlvdXMgc2VsZWN0b3IgYWxyZWFkeSBjbG9zZWQ6ICcgKyBwcmVmaXgpO1xuICB9XG4gIGNvbnN0IHN1ZmZpeCA9IHF1ZXJ5LnNsaWNlKGN1cnNvck9mZnNldCk7XG4gIGNvbnN0IHN1ZmZpeENsb3NlSW5kZXggPSBzdWZmaXguaW5kZXhPZignfScpO1xuICBjb25zdCBzdWZmaXhDbG9zZSA9IHN1ZmZpeENsb3NlSW5kZXggKyBjdXJzb3JPZmZzZXQ7XG4gIGNvbnN0IHN1ZmZpeE9wZW5JbmRleCA9IHN1ZmZpeC5pbmRleE9mKCd7Jyk7XG4gIGNvbnN0IHN1ZmZpeE9wZW4gPSBzdWZmaXhPcGVuSW5kZXggKyBjdXJzb3JPZmZzZXQ7XG4gIGlmIChzdWZmaXhDbG9zZSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbnNpZGUgc2VsZWN0b3IsIG1pc3NpbmcgY2xvc2luZyBicmFjZSBpbiBzdWZmaXg6ICcgKyBzdWZmaXgpO1xuICB9XG4gIGlmIChzdWZmaXhPcGVuSW5kZXggPiAtMSAmJiBzdWZmaXhPcGVuIDwgc3VmZml4Q2xvc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbnNpZGUgc2VsZWN0b3IsIG5leHQgc2VsZWN0b3Igb3BlbnMgYmVmb3JlIHRoaXMgb25lIGNsb3NlZDogJyArIHN1ZmZpeCk7XG4gIH1cblxuICAvLyBFeHRyYWN0IGNsZWFuIGxhYmVscyB0byBmb3JtIGNsZWFuIHNlbGVjdG9yLCBpbmNvbXBsZXRlIGxhYmVscyBhcmUgZHJvcHBlZFxuICBjb25zdCBzZWxlY3RvciA9IHF1ZXJ5LnNsaWNlKHByZWZpeE9wZW4sIHN1ZmZpeENsb3NlKTtcbiAgY29uc3QgbGFiZWxzOiB7IFtrZXk6IHN0cmluZ106IHsgdmFsdWU6IHN0cmluZzsgb3BlcmF0b3I6IHN0cmluZyB9IH0gPSB7fTtcbiAgc2VsZWN0b3IucmVwbGFjZShsYWJlbFJlZ2V4cCwgKGxhYmVsLCBrZXksIG9wZXJhdG9yLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGxhYmVsT2Zmc2V0ID0gcXVlcnkuaW5kZXhPZihsYWJlbCk7XG4gICAgY29uc3QgdmFsdWVTdGFydCA9IGxhYmVsT2Zmc2V0ICsga2V5Lmxlbmd0aCArIG9wZXJhdG9yLmxlbmd0aCArIDE7XG4gICAgY29uc3QgdmFsdWVFbmQgPSBsYWJlbE9mZnNldCArIGtleS5sZW5ndGggKyBvcGVyYXRvci5sZW5ndGggKyB2YWx1ZS5sZW5ndGggLSAxO1xuICAgIC8vIFNraXAgbGFiZWwgaWYgY3Vyc29yIGlzIGluIHZhbHVlXG4gICAgaWYgKGN1cnNvck9mZnNldCA8IHZhbHVlU3RhcnQgfHwgY3Vyc29yT2Zmc2V0ID4gdmFsdWVFbmQpIHtcbiAgICAgIGxhYmVsc1trZXldID0geyB2YWx1ZSwgb3BlcmF0b3IgfTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9KTtcblxuICAvLyBBZGQgbWV0cmljIGlmIHRoZXJlIGlzIG9uZSBiZWZvcmUgdGhlIHNlbGVjdG9yXG4gIGNvbnN0IG1ldHJpY1ByZWZpeCA9IHF1ZXJ5LnNsaWNlKDAsIHByZWZpeE9wZW4pO1xuICBjb25zdCBtZXRyaWNNYXRjaCA9IG1ldHJpY1ByZWZpeC5tYXRjaCgvW0EtWmEtejpdW1xcdzpdKiQvKTtcbiAgaWYgKG1ldHJpY01hdGNoKSB7XG4gICAgbGFiZWxzWydfX25hbWVfXyddID0geyB2YWx1ZTogYFwiJHttZXRyaWNNYXRjaFswXX1cImAsIG9wZXJhdG9yOiAnPScgfTtcbiAgfVxuXG4gIC8vIEJ1aWxkIHNvcnRlZCBzZWxlY3RvclxuICBjb25zdCBsYWJlbEtleXMgPSBPYmplY3Qua2V5cyhsYWJlbHMpLnNvcnQoKTtcbiAgY29uc3QgY2xlYW5TZWxlY3RvciA9IGxhYmVsS2V5cy5tYXAoKGtleSkgPT4gYCR7a2V5fSR7bGFiZWxzW2tleV0ub3BlcmF0b3J9JHtsYWJlbHNba2V5XS52YWx1ZX1gKS5qb2luKCcsJyk7XG5cbiAgY29uc3Qgc2VsZWN0b3JTdHJpbmcgPSBbJ3snLCBjbGVhblNlbGVjdG9yLCAnfSddLmpvaW4oJycpO1xuXG4gIHJldHVybiB7IGxhYmVsS2V5cywgc2VsZWN0b3I6IHNlbGVjdG9yU3RyaW5nIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRSZWNvcmRpbmdSdWxlcyhxdWVyeTogc3RyaW5nLCBtYXBwaW5nOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSk6IHN0cmluZyB7XG4gIGNvbnN0IHJ1bGVOYW1lcyA9IE9iamVjdC5rZXlzKG1hcHBpbmcpO1xuICBjb25zdCBydWxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFxzfF4pKCR7cnVsZU5hbWVzLmpvaW4oJ3wnKX0pKFxcXFxzfCR8XFxcXCh8XFxcXFt8XFxcXHspYCwgJ2lnJyk7XG4gIGNvbnN0IGV4cGFuZGVkUXVlcnkgPSBxdWVyeS5yZXBsYWNlKHJ1bGVzUmVnZXgsIChtYXRjaCwgcHJlLCBuYW1lLCBwb3N0KSA9PiBgJHtwcmV9JHttYXBwaW5nW25hbWVdfSR7cG9zdH1gKTtcblxuICAvLyBTcGxpdCBxdWVyeSBpbnRvIGFycmF5LCBzbyBpZiBxdWVyeSB1c2VzIG9wZXJhdG9ycywgd2UgY2FuIGNvcnJlY3RseSBhZGQgbGFiZWxzIHRvIGVhY2ggaW5kaXZpZHVhbCBwYXJ0LlxuICBjb25zdCBxdWVyeUFycmF5ID0gZXhwYW5kZWRRdWVyeS5zcGxpdCgvKFxcK3xcXC18XFwqfFxcL3xcXCV8XFxeKS8pO1xuXG4gIC8vIFJlZ2V4IHRoYXQgbWF0Y2hlcyBvY2N1cnJlbmNlcyBvZiApeyBvciB9eyBvciBdeyB3aGljaCBpcyBhIHNpZ24gb2YgaW5jb3JyZWNseSBhZGRlZCBsYWJlbHMuXG4gIGNvbnN0IGludmFsaWRMYWJlbHNSZWdleCA9IC8oXFwpXFx7fFxcfVxce3xcXF1cXHspLztcbiAgY29uc3QgY29ycmVjdGx5RXhwYW5kZWRRdWVyeUFycmF5ID0gcXVlcnlBcnJheS5tYXAoKHF1ZXJ5KSA9PiB7XG4gICAgcmV0dXJuIGFkZExhYmVsc1RvRXhwcmVzc2lvbihxdWVyeSwgaW52YWxpZExhYmVsc1JlZ2V4KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvcnJlY3RseUV4cGFuZGVkUXVlcnlBcnJheS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gYWRkTGFiZWxzVG9FeHByZXNzaW9uKGV4cHI6IHN0cmluZywgaW52YWxpZExhYmVsc1JlZ2V4cDogUmVnRXhwKSB7XG4gIGNvbnN0IG1hdGNoID0gZXhwci5tYXRjaChpbnZhbGlkTGFiZWxzUmVnZXhwKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gU3BsaXQgcXVlcnkgaW50byAyIHBhcnRzIC0gYmVmb3JlIHRoZSBpbnZhbGlkTGFiZWxzUmVnZXggbWF0Y2ggYW5kIGFmdGVyLlxuICBjb25zdCBpbmRleE9mUmVnZXhNYXRjaCA9IG1hdGNoLmluZGV4ID8/IDA7XG4gIGNvbnN0IGV4cHJCZWZvcmVSZWdleE1hdGNoID0gZXhwci5zbGljZSgwLCBpbmRleE9mUmVnZXhNYXRjaCArIDEpO1xuICBjb25zdCBleHByQWZ0ZXJSZWdleE1hdGNoID0gZXhwci5zbGljZShpbmRleE9mUmVnZXhNYXRjaCArIDEpO1xuXG4gIC8vIENyZWF0ZSBhcnJheU9mTGFiZWxPYmplY3RzIHdpdGggbGFiZWwgb2JqZWN0cyB0aGF0IGhhdmUga2V5LCBvcGVyYXRvciBhbmQgdmFsdWUuXG4gIGNvbnN0IGFycmF5T2ZMYWJlbE9iamVjdHM6IEFycmF5PHsga2V5OiBzdHJpbmc7IG9wZXJhdG9yOiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfT4gPSBbXTtcbiAgZXhwckFmdGVyUmVnZXhNYXRjaC5yZXBsYWNlKGxhYmVsUmVnZXhwLCAobGFiZWwsIGtleSwgb3BlcmF0b3IsIHZhbHVlKSA9PiB7XG4gICAgYXJyYXlPZkxhYmVsT2JqZWN0cy5wdXNoKHsga2V5LCBvcGVyYXRvciwgdmFsdWUgfSk7XG4gICAgcmV0dXJuICcnO1xuICB9KTtcblxuICAvLyBMb29wIHRocm91Z2ggYWxsIGxhYmVsIG9iamVjdHMgYW5kIGFkZCB0aGVtIHRvIHF1ZXJ5LlxuICAvLyBBcyBhIHN0YXJ0aW5nIHBvaW50IHdlIGhhdmUgdmFsaWQgcXVlcnkgd2l0aG91dCB0aGUgbGFiZWxzLlxuICBsZXQgcmVzdWx0ID0gZXhwckJlZm9yZVJlZ2V4TWF0Y2g7XG4gIGFycmF5T2ZMYWJlbE9iamVjdHMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKG9iaikgPT4ge1xuICAgIC8vIFJlbW92ZSBleHRyYSBzZXQgb2YgcXVvdGVzIGZyb20gb2JqLnZhbHVlXG4gICAgY29uc3QgdmFsdWUgPSBvYmoudmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgIHJlc3VsdCA9IGFkZExhYmVsVG9RdWVyeShyZXN1bHQsIG9iai5rZXksIHZhbHVlLCBvYmoub3BlcmF0b3IpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFkZHMgbWV0YWRhdGEgZm9yIHN5bnRoZXRpYyBtZXRyaWNzIGZvciB3aGljaCB0aGUgQVBJIGRvZXMgbm90IHByb3ZpZGUgbWV0YWRhdGEuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyYWZhbmEvZ3JhZmFuYS9pc3N1ZXMvMjIzMzcgZm9yIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIG1ldGFkYXRhIEhFTFAgYW5kIFRZUEUgbWV0YWRhdGEgZnJvbSAvYXBpL3YxL21ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhTdW1tYXJpZXNNZXRhZGF0YShtZXRhZGF0YTogeyBbbWV0cmljOiBzdHJpbmddOiBQcm9tTWV0cmljc01ldGFkYXRhSXRlbVtdIH0pOiBQcm9tTWV0cmljc01ldGFkYXRhIHtcbiAgaWYgKCFtZXRhZGF0YSkge1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfVxuICBjb25zdCBiYXNlTWV0YWRhdGE6IFByb21NZXRyaWNzTWV0YWRhdGEgPSB7fTtcbiAgY29uc3Qgc3VtbWFyeU1ldGFkYXRhOiBQcm9tTWV0cmljc01ldGFkYXRhID0ge307XG4gIGZvciAoY29uc3QgbWV0cmljIGluIG1ldGFkYXRhKSB7XG4gICAgLy8gTk9URTogYmFzZWQgb24gcHJvbWV0aGV1cy1kb2N1bWVudGF0aW9uLCB3ZSBjYW4gcmVjZWl2ZVxuICAgIC8vIG11bHRpcGxlIG1ldGFkYXRhLWVudHJpZXMgZm9yIHRoZSBnaXZlbiBtZXRyaWMsIGl0IHNlZW1zXG4gICAgLy8gaXQgaGFwcGVucyB3aGVuIHRoZSBzYW1lIG1ldHJpYyBpcyBvbiBtdWx0aXBsZSB0YXJnZXRzXG4gICAgLy8gYW5kIHRoZWlyIGhlbHAtdGV4dCBkaWZmZXJzXG4gICAgLy8gKGh0dHBzOi8vcHJvbWV0aGV1cy5pby9kb2NzL3Byb21ldGhldXMvbGF0ZXN0L3F1ZXJ5aW5nL2FwaS8jcXVlcnlpbmctbWV0cmljLW1ldGFkYXRhKVxuICAgIC8vIGZvciBub3cgd2UganVzdCB1c2UgdGhlIGZpcnN0IGVudHJ5LlxuICAgIGNvbnN0IGl0ZW0gPSBtZXRhZGF0YVttZXRyaWNdWzBdO1xuICAgIGJhc2VNZXRhZGF0YVttZXRyaWNdID0gaXRlbTtcblxuICAgIGlmIChpdGVtLnR5cGUgPT09ICdoaXN0b2dyYW0nKSB7XG4gICAgICBzdW1tYXJ5TWV0YWRhdGFbYCR7bWV0cmljfV9idWNrZXRgXSA9IHtcbiAgICAgICAgdHlwZTogJ2NvdW50ZXInLFxuICAgICAgICBoZWxwOiBgQ3VtdWxhdGl2ZSBjb3VudGVycyBmb3IgdGhlIG9ic2VydmF0aW9uIGJ1Y2tldHMgKCR7aXRlbS5oZWxwfSlgLFxuICAgICAgfTtcbiAgICAgIHN1bW1hcnlNZXRhZGF0YVtgJHttZXRyaWN9X2NvdW50YF0gPSB7XG4gICAgICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICAgICAgaGVscDogYENvdW50IG9mIGV2ZW50cyB0aGF0IGhhdmUgYmVlbiBvYnNlcnZlZCBmb3IgdGhlIGhpc3RvZ3JhbSBtZXRyaWMgKCR7aXRlbS5oZWxwfSlgLFxuICAgICAgfTtcbiAgICAgIHN1bW1hcnlNZXRhZGF0YVtgJHttZXRyaWN9X3N1bWBdID0ge1xuICAgICAgICB0eXBlOiAnY291bnRlcicsXG4gICAgICAgIGhlbHA6IGBUb3RhbCBzdW0gb2YgYWxsIG9ic2VydmVkIHZhbHVlcyBmb3IgdGhlIGhpc3RvZ3JhbSBtZXRyaWMgKCR7aXRlbS5oZWxwfSlgLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3N1bW1hcnknKSB7XG4gICAgICBzdW1tYXJ5TWV0YWRhdGFbYCR7bWV0cmljfV9jb3VudGBdID0ge1xuICAgICAgICB0eXBlOiAnY291bnRlcicsXG4gICAgICAgIGhlbHA6IGBDb3VudCBvZiBldmVudHMgdGhhdCBoYXZlIGJlZW4gb2JzZXJ2ZWQgZm9yIHRoZSBiYXNlIG1ldHJpYyAoJHtpdGVtLmhlbHB9KWAsXG4gICAgICB9O1xuICAgICAgc3VtbWFyeU1ldGFkYXRhW2Ake21ldHJpY31fc3VtYF0gPSB7XG4gICAgICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICAgICAgaGVscDogYFRvdGFsIHN1bSBvZiBhbGwgb2JzZXJ2ZWQgdmFsdWVzIGZvciB0aGUgYmFzZSBtZXRyaWMgKCR7aXRlbS5oZWxwfSlgLFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLy8gU3ludGhldGljIHNlcmllc1xuICBjb25zdCBzeW50aGV0aWNNZXRhZGF0YTogUHJvbU1ldHJpY3NNZXRhZGF0YSA9IHt9O1xuICBzeW50aGV0aWNNZXRhZGF0YVsnQUxFUlRTJ10gPSB7XG4gICAgdHlwZTogJ2NvdW50ZXInLFxuICAgIGhlbHA6ICdUaW1lIHNlcmllcyBzaG93aW5nIHBlbmRpbmcgYW5kIGZpcmluZyBhbGVydHMuIFRoZSBzYW1wbGUgdmFsdWUgaXMgc2V0IHRvIDEgYXMgbG9uZyBhcyB0aGUgYWxlcnQgaXMgaW4gdGhlIGluZGljYXRlZCBhY3RpdmUgKHBlbmRpbmcgb3IgZmlyaW5nKSBzdGF0ZS4nLFxuICB9O1xuXG4gIHJldHVybiB7IC4uLmJhc2VNZXRhZGF0YSwgLi4uc3VtbWFyeU1ldGFkYXRhLCAuLi5zeW50aGV0aWNNZXRhZGF0YSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRNc1RvTWluKG1pbGxpc2Vjb25kczogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHJvdW5kU2VjVG9NaW4obWlsbGlzZWNvbmRzIC8gMTAwMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFNlY1RvTWluKHNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW1pdFN1Z2dlc3Rpb25zKGl0ZW1zOiBzdHJpbmdbXSkge1xuICByZXR1cm4gaXRlbXMuc2xpY2UoMCwgU1VHR0VTVElPTlNfTElNSVQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTGltaXRJbmZvKGl0ZW1zOiBhbnlbXSB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gIHJldHVybiBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPj0gU1VHR0VTVElPTlNfTElNSVQgPyBgLCBsaW1pdGVkIHRvIHRoZSBmaXJzdCAke1NVR0dFU1RJT05TX0xJTUlUfSByZWNlaXZlZCBpdGVtc2AgOiAnJztcbn1cblxuLy8gTk9URTogdGhlIGZvbGxvd2luZyAyIGV4cG9ydGVkIGZ1bmN0aW9ucyBhcmUgdmVyeSBzaW1pbGFyIHRvIHRoZSBwcm9tZXRoZXVzKkVzY2FwZVxuLy8gZnVuY3Rpb25zIGluIGRhdGFzb3VyY2UudHMsIGJ1dCB0aGV5IGFyZSBub3QgZXhhY3RseSB0aGUgc2FtZSBhbGdvcml0aG0sIGFuZCB3ZSBmb3VuZFxuLy8gbm8gd2F5IHRvIHJldXNlIG9uZSBpbiB0aGUgYW5vdGhlciBvciB2aWNlIHZlcnNhLlxuXG4vLyBQcm9tZXRoZXVzIHJlZ3VsYXItZXhwcmVzc2lvbnMgdXNlIHRoZSBSRTIgc3ludGF4IChodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3JlMi93aWtpL1N5bnRheCksXG4vLyBzbyBldmVyeSBjaGFyYWN0ZXIgdGhhdCBtYXRjaGVzIHNvbWV0aGluZyBpbiB0aGF0IGxpc3QgaGFzIHRvIGJlIGVzY2FwZWQuXG4vLyB0aGUgbGlzdCBvZiBtZXRhY2hhcmFjdGVycyBpczogKis/KCl8XFwuW117fV4kXG4vLyB3ZSBtYWtlIGEgamF2YXNjcmlwdCByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIHRob3NlIGNoYXJhY3RlcnM6XG5jb25zdCBSRTJfTUVUQUNIQVJBQ1RFUlMgPSAvWyorPygpfFxcXFwuXFxbXFxde31eJF0vZztcbmZ1bmN0aW9uIGVzY2FwZVByb21ldGhldXNSZWdleHAodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKFJFMl9NRVRBQ0hBUkFDVEVSUywgJ1xcXFwkJicpO1xufVxuXG4vLyBiYXNlZCBvbiB0aGUgb3Blbm1ldHJpY3MtZG9jdW1lbnRhdGlvbiwgdGhlIDMgc3ltYm9scyB3ZSBoYXZlIHRvIGhhbmRsZSBhcmU6XG4vLyAtIFxcbiAuLi4gdGhlIG5ld2xpbmUgY2hhcmFjdGVyXG4vLyAtIFxcICAuLi4gdGhlIGJhY2tzbGFzaCBjaGFyYWN0ZXJcbi8vIC0gXCIgIC4uLiB0aGUgZG91YmxlLXF1b3RlIGNoYXJhY3RlclxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUxhYmVsVmFsdWVJbkV4YWN0U2VsZWN0b3IobGFiZWxWYWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGxhYmVsVmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlTGFiZWxWYWx1ZUluUmVnZXhTZWxlY3RvcihsYWJlbFZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3Rvcihlc2NhcGVQcm9tZXRoZXVzUmVnZXhwKGxhYmVsVmFsdWUpKTtcbn1cblxuY29uc3QgRnJvbVByb21MaWtlTWFwOiBSZWNvcmQ8c3RyaW5nLCBBYnN0cmFjdExhYmVsT3BlcmF0b3I+ID0ge1xuICAnPSc6IEFic3RyYWN0TGFiZWxPcGVyYXRvci5FcXVhbCxcbiAgJyE9JzogQWJzdHJhY3RMYWJlbE9wZXJhdG9yLk5vdEVxdWFsLFxuICAnPX4nOiBBYnN0cmFjdExhYmVsT3BlcmF0b3IuRXF1YWxSZWdFeCxcbiAgJyF+JzogQWJzdHJhY3RMYWJlbE9wZXJhdG9yLk5vdEVxdWFsUmVnRXgsXG59O1xuY29uc3QgVG9Qcm9tTGlrZU1hcDogUmVjb3JkPEFic3RyYWN0TGFiZWxPcGVyYXRvciwgc3RyaW5nPiA9IGludmVydChGcm9tUHJvbUxpa2VNYXApIGFzIFJlY29yZDxcbiAgQWJzdHJhY3RMYWJlbE9wZXJhdG9yLFxuICBzdHJpbmdcbj47XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1Byb21MaWtlRXhwcihsYWJlbEJhc2VkUXVlcnk6IEFic3RyYWN0UXVlcnkpOiBzdHJpbmcge1xuICBjb25zdCBleHByID0gbGFiZWxCYXNlZFF1ZXJ5LmxhYmVsTWF0Y2hlcnNcbiAgICAubWFwKChzZWxlY3RvcjogQWJzdHJhY3RMYWJlbE1hdGNoZXIpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gVG9Qcm9tTGlrZU1hcFtzZWxlY3Rvci5vcGVyYXRvcl07XG4gICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGAke3NlbGVjdG9yLm5hbWV9JHtvcGVyYXRvcn1cIiR7c2VsZWN0b3IudmFsdWV9XCJgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmZpbHRlcigoZTogc3RyaW5nKSA9PiBlICE9PSAnJylcbiAgICAuam9pbignLCAnKTtcblxuICByZXR1cm4gZXhwciA/IGB7JHtleHByfX1gIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1Byb21MaWtlUXVlcnkobGFiZWxCYXNlZFF1ZXJ5OiBBYnN0cmFjdFF1ZXJ5KTogUHJvbUxpa2VRdWVyeSB7XG4gIHJldHVybiB7XG4gICAgcmVmSWQ6IGxhYmVsQmFzZWRRdWVyeS5yZWZJZCxcbiAgICBleHByOiB0b1Byb21MaWtlRXhwcihsYWJlbEJhc2VkUXVlcnkpLFxuICAgIHJhbmdlOiB0cnVlLFxuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21MaWtlUXVlcnkgZXh0ZW5kcyBEYXRhUXVlcnkge1xuICBleHByOiBzdHJpbmc7XG4gIHJhbmdlOiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdExhYmVsTWF0Y2hlcnModG9rZW5zOiBBcnJheTxzdHJpbmcgfCBUb2tlbj4pOiBBYnN0cmFjdExhYmVsTWF0Y2hlcltdIHtcbiAgY29uc3QgbGFiZWxNYXRjaGVyczogQWJzdHJhY3RMYWJlbE1hdGNoZXJbXSA9IFtdO1xuXG4gIGZvciAobGV0IHByb3AgaW4gdG9rZW5zKSB7XG4gICAgaWYgKHRva2Vuc1twcm9wXSBpbnN0YW5jZW9mIFRva2VuKSB7XG4gICAgICBsZXQgdG9rZW46IFRva2VuID0gdG9rZW5zW3Byb3BdIGFzIFRva2VuO1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdjb250ZXh0LWxhYmVscycpIHtcbiAgICAgICAgbGV0IGxhYmVsS2V5ID0gJyc7XG4gICAgICAgIGxldCBsYWJlbFZhbHVlID0gJyc7XG4gICAgICAgIGxldCBsYWJlbE9wZXJhdG9yID0gJyc7XG4gICAgICAgIGxldCBjb250ZW50VG9rZW5zOiBhbnlbXSA9IHRva2VuLmNvbnRlbnQgYXMgYW55W107XG4gICAgICAgIGZvciAobGV0IGN1cnJlbnRUb2tlbiBpbiBjb250ZW50VG9rZW5zKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFN0cjogc3RyaW5nO1xuICAgICAgICAgICAgY3VycmVudFN0ciA9IGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXSBhcyBzdHJpbmc7XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0ciA9PT0gJz0nIHx8IGN1cnJlbnRTdHIgPT09ICchPScgfHwgY3VycmVudFN0ciA9PT0gJz1+JyB8fCBjdXJyZW50U3RyID09PSAnIX4nKSB7XG4gICAgICAgICAgICAgIGxhYmVsT3BlcmF0b3IgPSBjdXJyZW50U3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnbGFiZWwta2V5JzpcbiAgICAgICAgICAgICAgICBsYWJlbEtleSA9IGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXS5jb250ZW50IGFzIHN0cmluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnbGFiZWwtdmFsdWUnOlxuICAgICAgICAgICAgICAgIGxhYmVsVmFsdWUgPSBjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0uY29udGVudCBhcyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgbGFiZWxWYWx1ZSA9IGxhYmVsVmFsdWUuc3Vic3RyaW5nKDEsIGxhYmVsVmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxDb21wYXJhdG9yID0gRnJvbVByb21MaWtlTWFwW2xhYmVsT3BlcmF0b3JdO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbENvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGxhYmVsTWF0Y2hlcnMucHVzaCh7IG5hbWU6IGxhYmVsS2V5LCBvcGVyYXRvcjogbGFiZWxDb21wYXJhdG9yLCB2YWx1ZTogbGFiZWxWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhYmVsTWF0Y2hlcnM7XG59XG4iLCJpbXBvcnQgeyBjaGFpbiwgbWFwIGFzIF9tYXAsIHVuaXEgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgbGFzdFZhbHVlRnJvbSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBNZXRyaWNGaW5kVmFsdWUsIFRpbWVSYW5nZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgZ2V0VGltZVNydiB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kYXNoYm9hcmQvc2VydmljZXMvVGltZVNydic7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi9kYXRhc291cmNlJztcbmltcG9ydCB7IFByb21RdWVyeVJlcXVlc3QgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvbWV0aGV1c01ldHJpY0ZpbmRRdWVyeSB7XG4gIHJhbmdlOiBUaW1lUmFuZ2U7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZSwgcHJpdmF0ZSBxdWVyeTogc3RyaW5nKSB7XG4gICAgdGhpcy5kYXRhc291cmNlID0gZGF0YXNvdXJjZTtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgdGhpcy5yYW5nZSA9IGdldFRpbWVTcnYoKS50aW1lUmFuZ2UoKTtcbiAgfVxuXG4gIHByb2Nlc3MoKTogUHJvbWlzZTxNZXRyaWNGaW5kVmFsdWVbXT4ge1xuICAgIGNvbnN0IGxhYmVsTmFtZXNSZWdleCA9IC9ebGFiZWxfbmFtZXNcXChcXClcXHMqJC87XG4gICAgY29uc3QgbGFiZWxWYWx1ZXNSZWdleCA9IC9ebGFiZWxfdmFsdWVzXFwoKD86KC4rKSxcXHMqKT8oW2EtekEtWl9dW2EtekEtWjAtOV9dKilcXClcXHMqJC87XG4gICAgY29uc3QgbWV0cmljTmFtZXNSZWdleCA9IC9ebWV0cmljc1xcKCguKylcXClcXHMqJC87XG4gICAgY29uc3QgcXVlcnlSZXN1bHRSZWdleCA9IC9ecXVlcnlfcmVzdWx0XFwoKC4rKVxcKVxccyokLztcbiAgICBjb25zdCBsYWJlbE5hbWVzUXVlcnkgPSB0aGlzLnF1ZXJ5Lm1hdGNoKGxhYmVsTmFtZXNSZWdleCk7XG4gICAgaWYgKGxhYmVsTmFtZXNRdWVyeSkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWxOYW1lc1F1ZXJ5KCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxWYWx1ZXNRdWVyeSA9IHRoaXMucXVlcnkubWF0Y2gobGFiZWxWYWx1ZXNSZWdleCk7XG4gICAgaWYgKGxhYmVsVmFsdWVzUXVlcnkpIHtcbiAgICAgIGlmIChsYWJlbFZhbHVlc1F1ZXJ5WzFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsVmFsdWVzUXVlcnkobGFiZWxWYWx1ZXNRdWVyeVsyXSwgbGFiZWxWYWx1ZXNRdWVyeVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFZhbHVlc1F1ZXJ5KGxhYmVsVmFsdWVzUXVlcnlbMl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1ldHJpY05hbWVzUXVlcnkgPSB0aGlzLnF1ZXJ5Lm1hdGNoKG1ldHJpY05hbWVzUmVnZXgpO1xuICAgIGlmIChtZXRyaWNOYW1lc1F1ZXJ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXRyaWNOYW1lUXVlcnkobWV0cmljTmFtZXNRdWVyeVsxXSk7XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnlSZXN1bHRRdWVyeSA9IHRoaXMucXVlcnkubWF0Y2gocXVlcnlSZXN1bHRSZWdleCk7XG4gICAgaWYgKHF1ZXJ5UmVzdWx0UXVlcnkpIHtcbiAgICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKHRoaXMucXVlcnlSZXN1bHRRdWVyeShxdWVyeVJlc3VsdFF1ZXJ5WzFdKSk7XG4gICAgfVxuXG4gICAgLy8gaWYgcXVlcnkgY29udGFpbnMgZnVsbCBtZXRyaWMgbmFtZSwgcmV0dXJuIG1ldHJpYyBuYW1lIGFuZCBsYWJlbCBsaXN0XG4gICAgcmV0dXJuIHRoaXMubWV0cmljTmFtZUFuZExhYmVsc1F1ZXJ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgbGFiZWxOYW1lc1F1ZXJ5KCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UuZnJvbSwgZmFsc2UpO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLnRvLCB0cnVlKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBzdGFydDogc3RhcnQudG9TdHJpbmcoKSxcbiAgICAgIGVuZDogZW5kLnRvU3RyaW5nKCksXG4gICAgfTtcblxuICAgIGNvbnN0IHVybCA9IGAvYXBpL3YxL2xhYmVsc2A7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcykudGhlbigocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgIHJldHVybiBfbWFwKHJlc3VsdC5kYXRhLmRhdGEsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiB2YWx1ZSB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBsYWJlbFZhbHVlc1F1ZXJ5KGxhYmVsOiBzdHJpbmcsIG1ldHJpYz86IHN0cmluZykge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UuZnJvbSwgZmFsc2UpO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLnRvLCB0cnVlKTtcblxuICAgIGxldCB1cmw6IHN0cmluZztcblxuICAgIGlmICghbWV0cmljKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIHN0YXJ0OiBzdGFydC50b1N0cmluZygpLFxuICAgICAgICBlbmQ6IGVuZC50b1N0cmluZygpLFxuICAgICAgfTtcbiAgICAgIC8vIHJldHVybiBsYWJlbCB2YWx1ZXMgZ2xvYmFsbHlcbiAgICAgIHVybCA9IGAvYXBpL3YxL2xhYmVsLyR7bGFiZWx9L3ZhbHVlc2A7XG5cbiAgICAgIHJldHVybiB0aGlzLmRhdGFzb3VyY2UubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgICByZXR1cm4gX21hcChyZXN1bHQuZGF0YS5kYXRhLCAodmFsdWUpID0+IHtcbiAgICAgICAgICByZXR1cm4geyB0ZXh0OiB2YWx1ZSB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICdtYXRjaFtdJzogbWV0cmljLFxuICAgICAgICBzdGFydDogc3RhcnQudG9TdHJpbmcoKSxcbiAgICAgICAgZW5kOiBlbmQudG9TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgICB1cmwgPSBgL2FwaS92MS9zZXJpZXNgO1xuXG4gICAgICByZXR1cm4gdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcykudGhlbigocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgX2xhYmVscyA9IF9tYXAocmVzdWx0LmRhdGEuZGF0YSwgKG1ldHJpYykgPT4ge1xuICAgICAgICAgIHJldHVybiBtZXRyaWNbbGFiZWxdIHx8ICcnO1xuICAgICAgICB9KS5maWx0ZXIoKGxhYmVsKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxhYmVsICE9PSAnJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHVuaXEoX2xhYmVscykubWFwKChtZXRyaWMpID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogbWV0cmljLFxuICAgICAgICAgICAgZXhwYW5kYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG1ldHJpY05hbWVRdWVyeShtZXRyaWNGaWx0ZXJQYXR0ZXJuOiBzdHJpbmcpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLmZyb20sIGZhbHNlKTtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS50bywgdHJ1ZSk7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LnRvU3RyaW5nKCksXG4gICAgICBlbmQ6IGVuZC50b1N0cmluZygpLFxuICAgIH07XG4gICAgY29uc3QgdXJsID0gYC9hcGkvdjEvbGFiZWwvX19uYW1lX18vdmFsdWVzYDtcblxuICAgIHJldHVybiB0aGlzLmRhdGFzb3VyY2UubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIGNoYWluKHJlc3VsdC5kYXRhLmRhdGEpXG4gICAgICAgIC5maWx0ZXIoKG1ldHJpY05hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCByID0gbmV3IFJlZ0V4cChtZXRyaWNGaWx0ZXJQYXR0ZXJuKTtcbiAgICAgICAgICByZXR1cm4gci50ZXN0KG1ldHJpY05hbWUpO1xuICAgICAgICB9KVxuICAgICAgICAubWFwKChtYXRjaGVkTWV0cmljTmFtZSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaGVkTWV0cmljTmFtZSxcbiAgICAgICAgICAgIGV4cGFuZGFibGU6IHRydWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgLnZhbHVlKCk7XG4gICAgfSk7XG4gIH1cblxuICBxdWVyeVJlc3VsdFF1ZXJ5KHF1ZXJ5OiBzdHJpbmcpIHtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS50bywgdHJ1ZSk7XG4gICAgY29uc3QgaW5zdGFudFF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0ID0geyBleHByOiBxdWVyeSB9IGFzIFByb21RdWVyeVJlcXVlc3Q7XG4gICAgcmV0dXJuIHRoaXMuZGF0YXNvdXJjZS5wZXJmb3JtSW5zdGFudFF1ZXJ5KGluc3RhbnRRdWVyeSwgZW5kKS5waXBlKFxuICAgICAgbWFwKChyZXN1bHQpID0+IHtcbiAgICAgICAgcmV0dXJuIF9tYXAocmVzdWx0LmRhdGEuZGF0YS5yZXN1bHQsIChtZXRyaWNEYXRhKSA9PiB7XG4gICAgICAgICAgbGV0IHRleHQgPSBtZXRyaWNEYXRhLm1ldHJpYy5fX25hbWVfXyB8fCAnJztcbiAgICAgICAgICBkZWxldGUgbWV0cmljRGF0YS5tZXRyaWMuX19uYW1lX187XG4gICAgICAgICAgdGV4dCArPVxuICAgICAgICAgICAgJ3snICtcbiAgICAgICAgICAgIF9tYXAobWV0cmljRGF0YS5tZXRyaWMsICh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBrICsgJz1cIicgKyB2ICsgJ1wiJztcbiAgICAgICAgICAgIH0pLmpvaW4oJywnKSArXG4gICAgICAgICAgICAnfSc7XG4gICAgICAgICAgdGV4dCArPSAnICcgKyBtZXRyaWNEYXRhLnZhbHVlWzFdICsgJyAnICsgbWV0cmljRGF0YS52YWx1ZVswXSAqIDEwMDA7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIGV4cGFuZGFibGU6IHRydWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBtZXRyaWNOYW1lQW5kTGFiZWxzUXVlcnkocXVlcnk6IHN0cmluZyk6IFByb21pc2U8TWV0cmljRmluZFZhbHVlW10+IHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLmZyb20sIGZhbHNlKTtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS50bywgdHJ1ZSk7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgJ21hdGNoW10nOiBxdWVyeSxcbiAgICAgIHN0YXJ0OiBzdGFydC50b1N0cmluZygpLFxuICAgICAgZW5kOiBlbmQudG9TdHJpbmcoKSxcbiAgICB9O1xuXG4gICAgY29uc3QgdXJsID0gYC9hcGkvdjEvc2VyaWVzYDtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLmRhdGFzb3VyY2UubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIF9tYXAocmVzdWx0LmRhdGEuZGF0YSwgKG1ldHJpYzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRleHQ6IHNlbGYuZGF0YXNvdXJjZS5nZXRPcmlnaW5hbE1ldHJpY05hbWUobWV0cmljKSxcbiAgICAgICAgICBleHBhbmRhYmxlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGFTb3VyY2VQbHVnaW4gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IFByb21DaGVhdFNoZWV0IGZyb20gJy4vY29tcG9uZW50cy9Qcm9tQ2hlYXRTaGVldCc7XG5pbXBvcnQgUHJvbVF1ZXJ5RWRpdG9yQnlBcHAgZnJvbSAnLi9jb21wb25lbnRzL1Byb21RdWVyeUVkaXRvckJ5QXBwJztcbmltcG9ydCB7IENvbmZpZ0VkaXRvciB9IGZyb20gJy4vY29uZmlndXJhdGlvbi9Db25maWdFZGl0b3InO1xuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuL2RhdGFzb3VyY2UnO1xuXG5leHBvcnQgY29uc3QgcGx1Z2luID0gbmV3IERhdGFTb3VyY2VQbHVnaW4oUHJvbWV0aGV1c0RhdGFzb3VyY2UpXG4gIC5zZXRRdWVyeUVkaXRvcihQcm9tUXVlcnlFZGl0b3JCeUFwcClcbiAgLnNldENvbmZpZ0VkaXRvcihDb25maWdFZGl0b3IpXG4gIC5zZXRRdWVyeUVkaXRvckhlbHAoUHJvbUNoZWF0U2hlZXQpO1xuIiwiaW1wb3J0IHsgR3JhbW1hciB9IGZyb20gJ3ByaXNtanMnO1xuXG5pbXBvcnQgeyBDb21wbGV0aW9uSXRlbSB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuLy8gV2hlbiBjaGFuZ2luZyBSQVRFX1JBTkdFUywgY2hlY2sgaWYgTG9raS9Mb2dRTCByYW5nZXMgc2hvdWxkIGJlIGNoYW5nZWQgdG9vXG4vLyBAc2VlIHB1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvbGFuZ3VhZ2VfcHJvdmlkZXIudHNcbmV4cG9ydCBjb25zdCBSQVRFX1JBTkdFUzogQ29tcGxldGlvbkl0ZW1bXSA9IFtcbiAgeyBsYWJlbDogJyRfX2ludGVydmFsJywgc29ydFZhbHVlOiAnJF9faW50ZXJ2YWwnIH0sXG4gIHsgbGFiZWw6ICckX19yYXRlX2ludGVydmFsJywgc29ydFZhbHVlOiAnJF9fcmF0ZV9pbnRlcnZhbCcgfSxcbiAgeyBsYWJlbDogJyRfX3JhbmdlJywgc29ydFZhbHVlOiAnJF9fcmFuZ2UnIH0sXG4gIHsgbGFiZWw6ICcxbScsIHNvcnRWYWx1ZTogJzAwOjAxOjAwJyB9LFxuICB7IGxhYmVsOiAnNW0nLCBzb3J0VmFsdWU6ICcwMDowNTowMCcgfSxcbiAgeyBsYWJlbDogJzEwbScsIHNvcnRWYWx1ZTogJzAwOjEwOjAwJyB9LFxuICB7IGxhYmVsOiAnMzBtJywgc29ydFZhbHVlOiAnMDA6MzA6MDAnIH0sXG4gIHsgbGFiZWw6ICcxaCcsIHNvcnRWYWx1ZTogJzAxOjAwOjAwJyB9LFxuICB7IGxhYmVsOiAnMWQnLCBzb3J0VmFsdWU6ICcyNDowMDowMCcgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBPUEVSQVRPUlMgPSBbJ2J5JywgJ2dyb3VwX2xlZnQnLCAnZ3JvdXBfcmlnaHQnLCAnaWdub3JpbmcnLCAnb24nLCAnb2Zmc2V0JywgJ3dpdGhvdXQnXTtcbmV4cG9ydCBjb25zdCBMT0dJQ0FMX09QRVJBVE9SUyA9IFsnb3InLCAnYW5kJywgJ3VubGVzcyddO1xuXG5jb25zdCBUUklHT05PTUVUUklDX0ZVTkNUSU9OUzogQ29tcGxldGlvbkl0ZW1bXSA9IFtcbiAge1xuICAgIGxhYmVsOiAnYWNvcycsXG4gICAgaW5zZXJ0VGV4dDogJ2Fjb3MnLFxuICAgIGRldGFpbDogJ2Fjb3ModiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBhcmNjb3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhY29zaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2Fjb3NoJyxcbiAgICBkZXRhaWw6ICdhY29zaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGludmVyc2UgaHlwZXJib2xpYyBjb3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhc2luJyxcbiAgICBpbnNlcnRUZXh0OiAnYXNpbicsXG4gICAgZGV0YWlsOiAnYXNpbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGFyY3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhc2luaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2FzaW5oJyxcbiAgICBkZXRhaWw6ICdhc2luaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGludmVyc2UgaHlwZXJib2xpYyBzaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXRhbicsXG4gICAgaW5zZXJ0VGV4dDogJ2F0YW4nLFxuICAgIGRldGFpbDogJ2F0YW4odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBhcmN0YW5nZW50IG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXRhbmgnLFxuICAgIGluc2VydFRleHQ6ICdhdGFuaCcsXG4gICAgZGV0YWlsOiAnYXRhbmgodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBpbnZlcnNlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2NvcycsXG4gICAgaW5zZXJ0VGV4dDogJ2NvcycsXG4gICAgZGV0YWlsOiAnY29zKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgY29zaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnY29zaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2Nvc2gnLFxuICAgIGRldGFpbDogJ2Nvc2godiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3NpbicsXG4gICAgaW5zZXJ0VGV4dDogJ3NpbicsXG4gICAgZGV0YWlsOiAnc2luKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3NpbmgnLFxuICAgIGluc2VydFRleHQ6ICdzaW5oJyxcbiAgICBkZXRhaWw6ICdzaW5oKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAndGFuJyxcbiAgICBpbnNlcnRUZXh0OiAndGFuJyxcbiAgICBkZXRhaWw6ICd0YW4odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSB0YW5nZW50IG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAndGFuaCcsXG4gICAgaW5zZXJ0VGV4dDogJ3RhbmgnLFxuICAgIGRldGFpbDogJ3RhbmgodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuXTtcblxuY29uc3QgQUdHUkVHQVRJT05fT1BFUkFUT1JTOiBDb21wbGV0aW9uSXRlbVtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdzdW0nLFxuICAgIGluc2VydFRleHQ6ICdzdW0nLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgc3VtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21pbicsXG4gICAgaW5zZXJ0VGV4dDogJ21pbicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtaW5pbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21heCcsXG4gICAgaW5zZXJ0VGV4dDogJ21heCcsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtYXhpbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2F2ZycsXG4gICAgaW5zZXJ0VGV4dDogJ2F2ZycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSB0aGUgYXZlcmFnZSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdncm91cCcsXG4gICAgaW5zZXJ0VGV4dDogJ2dyb3VwJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQWxsIHZhbHVlcyBpbiB0aGUgcmVzdWx0aW5nIHZlY3RvciBhcmUgMScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3N0ZGRldicsXG4gICAgaW5zZXJ0VGV4dDogJ3N0ZGRldicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSBwb3B1bGF0aW9uIHN0YW5kYXJkIGRldmlhdGlvbiBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdzdGR2YXInLFxuICAgIGluc2VydFRleHQ6ICdzdGR2YXInLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgcG9wdWxhdGlvbiBzdGFuZGFyZCB2YXJpYW5jZSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdjb3VudCcsXG4gICAgaW5zZXJ0VGV4dDogJ2NvdW50JyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ291bnQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB2ZWN0b3InLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdjb3VudF92YWx1ZXMnLFxuICAgIGluc2VydFRleHQ6ICdjb3VudF92YWx1ZXMnLFxuICAgIGRvY3VtZW50YXRpb246ICdDb3VudCBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSB2YWx1ZScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2JvdHRvbWsnLFxuICAgIGluc2VydFRleHQ6ICdib3R0b21rJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnU21hbGxlc3QgayBlbGVtZW50cyBieSBzYW1wbGUgdmFsdWUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICd0b3BrJyxcbiAgICBpbnNlcnRUZXh0OiAndG9waycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0xhcmdlc3QgayBlbGVtZW50cyBieSBzYW1wbGUgdmFsdWUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdxdWFudGlsZScsXG4gICAgaW5zZXJ0VGV4dDogJ3F1YW50aWxlJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlIM+GLXF1YW50aWxlICgwIOKJpCDPhiDiiaQgMSkgb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBGVU5DVElPTlMgPSBbXG4gIC4uLkFHR1JFR0FUSU9OX09QRVJBVE9SUyxcbiAgLi4uVFJJR09OT01FVFJJQ19GVU5DVElPTlMsXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzJyxcbiAgICBsYWJlbDogJ2FicycsXG4gICAgZGV0YWlsOiAnYWJzKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB0aGUgaW5wdXQgdmVjdG9yIHdpdGggYWxsIHNhbXBsZSB2YWx1ZXMgY29udmVydGVkIHRvIHRoZWlyIGFic29sdXRlIHZhbHVlLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzZW50JyxcbiAgICBsYWJlbDogJ2Fic2VudCcsXG4gICAgZGV0YWlsOiAnYWJzZW50KHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgYW4gZW1wdHkgdmVjdG9yIGlmIHRoZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBhbnkgZWxlbWVudHMgYW5kIGEgMS1lbGVtZW50IHZlY3RvciB3aXRoIHRoZSB2YWx1ZSAxIGlmIHRoZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBubyBlbGVtZW50cy4gVGhpcyBpcyB1c2VmdWwgZm9yIGFsZXJ0aW5nIG9uIHdoZW4gbm8gdGltZSBzZXJpZXMgZXhpc3QgZm9yIGEgZ2l2ZW4gbWV0cmljIG5hbWUgYW5kIGxhYmVsIGNvbWJpbmF0aW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzZW50X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdhYnNlbnRfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdhYnNlbnQodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgYW4gZW1wdHkgdmVjdG9yIGlmIHRoZSByYW5nZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBhbnkgZWxlbWVudHMgYW5kIGEgMS1lbGVtZW50IHZlY3RvciB3aXRoIHRoZSB2YWx1ZSAxIGlmIHRoZSByYW5nZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBubyBlbGVtZW50cy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NlaWwnLFxuICAgIGxhYmVsOiAnY2VpbCcsXG4gICAgZGV0YWlsOiAnY2VpbCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JvdW5kcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIHVwIHRvIHRoZSBuZWFyZXN0IGludGVnZXIuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjaGFuZ2VzJyxcbiAgICBsYWJlbDogJ2NoYW5nZXMnLFxuICAgIGRldGFpbDogJ2NoYW5nZXModiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0ZvciBlYWNoIGlucHV0IHRpbWUgc2VyaWVzLCBgY2hhbmdlcyh2IHJhbmdlLXZlY3RvcilgIHJldHVybnMgdGhlIG51bWJlciBvZiB0aW1lcyBpdHMgdmFsdWUgaGFzIGNoYW5nZWQgd2l0aGluIHRoZSBwcm92aWRlZCB0aW1lIHJhbmdlIGFzIGFuIGluc3RhbnQgdmVjdG9yLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY2xhbXAnLFxuICAgIGxhYmVsOiAnY2xhbXAnLFxuICAgIGRldGFpbDogJ2NsYW1wKHYgaW5zdGFudC12ZWN0b3IsIG1pbiBzY2FsYXIsIG1heCBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NsYW1wcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIHRvIGhhdmUgYSBsb3dlciBsaW1pdCBvZiBgbWluYCBhbmQgYW4gdXBwZXIgbGltaXQgb2YgYG1heGAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjbGFtcF9tYXgnLFxuICAgIGxhYmVsOiAnY2xhbXBfbWF4JyxcbiAgICBkZXRhaWw6ICdjbGFtcF9tYXgodiBpbnN0YW50LXZlY3RvciwgbWF4IHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDbGFtcHMgdGhlIHNhbXBsZSB2YWx1ZXMgb2YgYWxsIGVsZW1lbnRzIGluIGB2YCB0byBoYXZlIGFuIHVwcGVyIGxpbWl0IG9mIGBtYXhgLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY2xhbXBfbWluJyxcbiAgICBsYWJlbDogJ2NsYW1wX21pbicsXG4gICAgZGV0YWlsOiAnY2xhbXBfbWluKHYgaW5zdGFudC12ZWN0b3IsIG1pbiBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2xhbXBzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgdG8gaGF2ZSBhIGxvd2VyIGxpbWl0IG9mIGBtaW5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY291bnRfc2NhbGFyJyxcbiAgICBsYWJlbDogJ2NvdW50X3NjYWxhcicsXG4gICAgZGV0YWlsOiAnY291bnRfc2NhbGFyKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhIHRpbWUgc2VyaWVzIHZlY3RvciBhcyBhIHNjYWxhci4gVGhpcyBpcyBpbiBjb250cmFzdCB0byB0aGUgYGNvdW50KClgIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLCB3aGljaCBhbHdheXMgcmV0dXJucyBhIHZlY3RvciAoYW4gZW1wdHkgb25lIGlmIHRoZSBpbnB1dCB2ZWN0b3IgaXMgZW1wdHkpIGFuZCBhbGxvd3MgZ3JvdXBpbmcgYnkgbGFiZWxzIHZpYSBhIGBieWAgY2xhdXNlLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGVnJyxcbiAgICBsYWJlbDogJ2RlZycsXG4gICAgZGV0YWlsOiAnZGVnKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ29udmVydHMgcmFkaWFucyB0byBkZWdyZWVzIGZvciBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGF5X29mX21vbnRoJyxcbiAgICBsYWJlbDogJ2RheV9vZl9tb250aCcsXG4gICAgZGV0YWlsOiAnZGF5X29mX21vbnRoKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB0aGUgZGF5IG9mIHRoZSBtb250aCBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMSB0byAzMS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2RheV9vZl93ZWVrJyxcbiAgICBsYWJlbDogJ2RheV9vZl93ZWVrJyxcbiAgICBkZXRhaWw6ICdkYXlfb2Zfd2Vlayh2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDAgdG8gNiwgd2hlcmUgMCBtZWFucyBTdW5kYXkgZXRjLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGF5c19pbl9tb250aCcsXG4gICAgbGFiZWw6ICdkYXlzX2luX21vbnRoJyxcbiAgICBkZXRhaWw6ICdkYXlzX2luX21vbnRoKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRoIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuIFJldHVybmVkIHZhbHVlcyBhcmUgZnJvbSAyOCB0byAzMS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2RlbHRhJyxcbiAgICBsYWJlbDogJ2RlbHRhJyxcbiAgICBkZXRhaWw6ICdkZWx0YSh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCB2YWx1ZSBvZiBlYWNoIHRpbWUgc2VyaWVzIGVsZW1lbnQgaW4gYSByYW5nZSB2ZWN0b3IgYHZgLCByZXR1cm5pbmcgYW4gaW5zdGFudCB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gZGVsdGFzIGFuZCBlcXVpdmFsZW50IGxhYmVscy4gVGhlIGRlbHRhIGlzIGV4dHJhcG9sYXRlZCB0byBjb3ZlciB0aGUgZnVsbCB0aW1lIHJhbmdlIGFzIHNwZWNpZmllZCBpbiB0aGUgcmFuZ2UgdmVjdG9yIHNlbGVjdG9yLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGdldCBhIG5vbi1pbnRlZ2VyIHJlc3VsdCBldmVuIGlmIHRoZSBzYW1wbGUgdmFsdWVzIGFyZSBhbGwgaW50ZWdlcnMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkZXJpdicsXG4gICAgbGFiZWw6ICdkZXJpdicsXG4gICAgZGV0YWlsOiAnZGVyaXYodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIHBlci1zZWNvbmQgZGVyaXZhdGl2ZSBvZiB0aGUgdGltZSBzZXJpZXMgaW4gYSByYW5nZSB2ZWN0b3IgYHZgLCB1c2luZyBzaW1wbGUgbGluZWFyIHJlZ3Jlc3Npb24uJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkcm9wX2NvbW1vbl9sYWJlbHMnLFxuICAgIGxhYmVsOiAnZHJvcF9jb21tb25fbGFiZWxzJyxcbiAgICBkZXRhaWw6ICdkcm9wX2NvbW1vbl9sYWJlbHMoaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnRHJvcHMgYWxsIGxhYmVscyB0aGF0IGhhdmUgdGhlIHNhbWUgbmFtZSBhbmQgdmFsdWUgYWNyb3NzIGFsbCBzZXJpZXMgaW4gdGhlIGlucHV0IHZlY3Rvci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2V4cCcsXG4gICAgbGFiZWw6ICdleHAnLFxuICAgIGRldGFpbDogJ2V4cCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBleHBvbmVudGlhbCBmdW5jdGlvbiBmb3IgYWxsIGVsZW1lbnRzIGluIGB2YC5cXG5TcGVjaWFsIGNhc2VzIGFyZTpcXG4qIGBFeHAoK0luZikgPSArSW5mYCBcXG4qIGBFeHAoTmFOKSA9IE5hTmAnLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2Zsb29yJyxcbiAgICBsYWJlbDogJ2Zsb29yJyxcbiAgICBkZXRhaWw6ICdmbG9vcih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JvdW5kcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIGRvd24gdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2hpc3RvZ3JhbV9xdWFudGlsZScsXG4gICAgbGFiZWw6ICdoaXN0b2dyYW1fcXVhbnRpbGUnLFxuICAgIGRldGFpbDogJ2hpc3RvZ3JhbV9xdWFudGlsZSjPhiBmbG9hdCwgYiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgz4YtcXVhbnRpbGUgKDAg4omkIM+GIOKJpCAxKSBmcm9tIHRoZSBidWNrZXRzIGBiYCBvZiBhIGhpc3RvZ3JhbS4gVGhlIHNhbXBsZXMgaW4gYGJgIGFyZSB0aGUgY291bnRzIG9mIG9ic2VydmF0aW9ucyBpbiBlYWNoIGJ1Y2tldC4gRWFjaCBzYW1wbGUgbXVzdCBoYXZlIGEgbGFiZWwgYGxlYCB3aGVyZSB0aGUgbGFiZWwgdmFsdWUgZGVub3RlcyB0aGUgaW5jbHVzaXZlIHVwcGVyIGJvdW5kIG9mIHRoZSBidWNrZXQuIChTYW1wbGVzIHdpdGhvdXQgc3VjaCBhIGxhYmVsIGFyZSBzaWxlbnRseSBpZ25vcmVkLikgVGhlIGhpc3RvZ3JhbSBtZXRyaWMgdHlwZSBhdXRvbWF0aWNhbGx5IHByb3ZpZGVzIHRpbWUgc2VyaWVzIHdpdGggdGhlIGBfYnVja2V0YCBzdWZmaXggYW5kIHRoZSBhcHByb3ByaWF0ZSBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdob2x0X3dpbnRlcnMnLFxuICAgIGxhYmVsOiAnaG9sdF93aW50ZXJzJyxcbiAgICBkZXRhaWw6ICdob2x0X3dpbnRlcnModiByYW5nZS12ZWN0b3IsIHNmIHNjYWxhciwgdGYgc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdQcm9kdWNlcyBhIHNtb290aGVkIHZhbHVlIGZvciB0aW1lIHNlcmllcyBiYXNlZCBvbiB0aGUgcmFuZ2UgaW4gYHZgLiBUaGUgbG93ZXIgdGhlIHNtb290aGluZyBmYWN0b3IgYHNmYCwgdGhlIG1vcmUgaW1wb3J0YW5jZSBpcyBnaXZlbiB0byBvbGQgZGF0YS4gVGhlIGhpZ2hlciB0aGUgdHJlbmQgZmFjdG9yIGB0ZmAsIHRoZSBtb3JlIHRyZW5kcyBpbiB0aGUgZGF0YSBpcyBjb25zaWRlcmVkLiBCb3RoIGBzZmAgYW5kIGB0ZmAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdob3VyJyxcbiAgICBsYWJlbDogJ2hvdXInLFxuICAgIGRldGFpbDogJ2hvdXIodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHRoZSBob3VyIG9mIHRoZSBkYXkgZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDAgdG8gMjMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpZGVsdGEnLFxuICAgIGxhYmVsOiAnaWRlbHRhJyxcbiAgICBkZXRhaWw6ICdpZGVsdGEodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbGFzdCB0d28gc2FtcGxlcyBpbiB0aGUgcmFuZ2UgdmVjdG9yIGB2YCwgcmV0dXJuaW5nIGFuIGluc3RhbnQgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGRlbHRhcyBhbmQgZXF1aXZhbGVudCBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpbmNyZWFzZScsXG4gICAgbGFiZWw6ICdpbmNyZWFzZScsXG4gICAgZGV0YWlsOiAnaW5jcmVhc2UodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGluY3JlYXNlIGluIHRoZSB0aW1lIHNlcmllcyBpbiB0aGUgcmFuZ2UgdmVjdG9yLiBCcmVha3MgaW4gbW9ub3RvbmljaXR5IChzdWNoIGFzIGNvdW50ZXIgcmVzZXRzIGR1ZSB0byB0YXJnZXQgcmVzdGFydHMpIGFyZSBhdXRvbWF0aWNhbGx5IGFkanVzdGVkIGZvci4gVGhlIGluY3JlYXNlIGlzIGV4dHJhcG9sYXRlZCB0byBjb3ZlciB0aGUgZnVsbCB0aW1lIHJhbmdlIGFzIHNwZWNpZmllZCBpbiB0aGUgcmFuZ2UgdmVjdG9yIHNlbGVjdG9yLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGdldCBhIG5vbi1pbnRlZ2VyIHJlc3VsdCBldmVuIGlmIGEgY291bnRlciBpbmNyZWFzZXMgb25seSBieSBpbnRlZ2VyIGluY3JlbWVudHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpcmF0ZScsXG4gICAgbGFiZWw6ICdpcmF0ZScsXG4gICAgZGV0YWlsOiAnaXJhdGUodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIHBlci1zZWNvbmQgaW5zdGFudCByYXRlIG9mIGluY3JlYXNlIG9mIHRoZSB0aW1lIHNlcmllcyBpbiB0aGUgcmFuZ2UgdmVjdG9yLiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBsYXN0IHR3byBkYXRhIHBvaW50cy4gQnJlYWtzIGluIG1vbm90b25pY2l0eSAoc3VjaCBhcyBjb3VudGVyIHJlc2V0cyBkdWUgdG8gdGFyZ2V0IHJlc3RhcnRzKSBhcmUgYXV0b21hdGljYWxseSBhZGp1c3RlZCBmb3IuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdsYWJlbF9qb2luJyxcbiAgICBsYWJlbDogJ2xhYmVsX2pvaW4nLFxuICAgIGRldGFpbDpcbiAgICAgICdsYWJlbF9qb2luKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHNlcGFyYXRvciBzdHJpbmcsIHNyY19sYWJlbF8xIHN0cmluZywgc3JjX2xhYmVsXzIgc3RyaW5nLCAuLi4pJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0ZvciBlYWNoIHRpbWVzZXJpZXMgaW4gYHZgLCBqb2lucyBhbGwgdGhlIHZhbHVlcyBvZiBhbGwgdGhlIGBzcmNfbGFiZWxzYCB1c2luZyBgc2VwYXJhdG9yYCBhbmQgcmV0dXJucyB0aGUgdGltZXNlcmllcyB3aXRoIHRoZSBsYWJlbCBgZHN0X2xhYmVsYCBjb250YWluaW5nIHRoZSBqb2luZWQgdmFsdWUuIFRoZXJlIGNhbiBiZSBhbnkgbnVtYmVyIG9mIGBzcmNfbGFiZWxzYCBpbiB0aGlzIGZ1bmN0aW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbGFiZWxfcmVwbGFjZScsXG4gICAgbGFiZWw6ICdsYWJlbF9yZXBsYWNlJyxcbiAgICBkZXRhaWw6ICdsYWJlbF9yZXBsYWNlKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHJlcGxhY2VtZW50IHN0cmluZywgc3JjX2xhYmVsIHN0cmluZywgcmVnZXggc3RyaW5nKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgIFwiRm9yIGVhY2ggdGltZXNlcmllcyBpbiBgdmAsIGBsYWJlbF9yZXBsYWNlKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHJlcGxhY2VtZW50IHN0cmluZywgc3JjX2xhYmVsIHN0cmluZywgcmVnZXggc3RyaW5nKWAgIG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBgcmVnZXhgIGFnYWluc3QgdGhlIGxhYmVsIGBzcmNfbGFiZWxgLiAgSWYgaXQgbWF0Y2hlcywgdGhlbiB0aGUgdGltZXNlcmllcyBpcyByZXR1cm5lZCB3aXRoIHRoZSBsYWJlbCBgZHN0X2xhYmVsYCByZXBsYWNlZCBieSB0aGUgZXhwYW5zaW9uIG9mIGByZXBsYWNlbWVudGAuIGAkMWAgaXMgcmVwbGFjZWQgd2l0aCB0aGUgZmlyc3QgbWF0Y2hpbmcgc3ViZ3JvdXAsIGAkMmAgd2l0aCB0aGUgc2Vjb25kIGV0Yy4gSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkb2Vzbid0IG1hdGNoIHRoZW4gdGhlIHRpbWVzZXJpZXMgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlwiLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xuJyxcbiAgICBsYWJlbDogJ2xuJyxcbiAgICBkZXRhaWw6ICdsbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBmb3IgYWxsIGVsZW1lbnRzIGluIGB2YC5cXG5TcGVjaWFsIGNhc2VzIGFyZTpcXG4gKiBgbG4oK0luZikgPSArSW5mYFxcbiAqIGBsbigwKSA9IC1JbmZgXFxuICogYGxuKHggPCAwKSA9IE5hTmBcXG4gKiBgbG4oTmFOKSA9IE5hTmAnLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xvZzInLFxuICAgIGxhYmVsOiAnbG9nMicsXG4gICAgZGV0YWlsOiAnbG9nMih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBiaW5hcnkgbG9nYXJpdGhtIGZvciBhbGwgZWxlbWVudHMgaW4gYHZgLiBUaGUgc3BlY2lhbCBjYXNlcyBhcmUgZXF1aXZhbGVudCB0byB0aG9zZSBpbiBgbG5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbG9nMTAnLFxuICAgIGxhYmVsOiAnbG9nMTAnLFxuICAgIGRldGFpbDogJ2xvZzEwKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGRlY2ltYWwgbG9nYXJpdGhtIGZvciBhbGwgZWxlbWVudHMgaW4gYHZgLiBUaGUgc3BlY2lhbCBjYXNlcyBhcmUgZXF1aXZhbGVudCB0byB0aG9zZSBpbiBgbG5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbWludXRlJyxcbiAgICBsYWJlbDogJ21pbnV0ZScsXG4gICAgZGV0YWlsOiAnbWludXRlKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIG1pbnV0ZSBvZiB0aGUgaG91ciBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMCB0byA1OS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ21vbnRoJyxcbiAgICBsYWJlbDogJ21vbnRoJyxcbiAgICBkZXRhaWw6ICdtb250aCh2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBtb250aCBvZiB0aGUgeWVhciBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMSB0byAxMiwgd2hlcmUgMSBtZWFucyBKYW51YXJ5IGV0Yy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3BpJyxcbiAgICBsYWJlbDogJ3BpJyxcbiAgICBkZXRhaWw6ICdwaSgpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyBwaScsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncHJlZGljdF9saW5lYXInLFxuICAgIGxhYmVsOiAncHJlZGljdF9saW5lYXInLFxuICAgIGRldGFpbDogJ3ByZWRpY3RfbGluZWFyKHYgcmFuZ2UtdmVjdG9yLCB0IHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUHJlZGljdHMgdGhlIHZhbHVlIG9mIHRpbWUgc2VyaWVzIGB0YCBzZWNvbmRzIGZyb20gbm93LCBiYXNlZCBvbiB0aGUgcmFuZ2UgdmVjdG9yIGB2YCwgdXNpbmcgc2ltcGxlIGxpbmVhciByZWdyZXNzaW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmFkJyxcbiAgICBsYWJlbDogJ3JhZCcsXG4gICAgZGV0YWlsOiAncmFkKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ29udmVydHMgZGVncmVlcyB0byByYWRpYW5zIGZvciBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmF0ZScsXG4gICAgbGFiZWw6ICdyYXRlJyxcbiAgICBkZXRhaWw6ICdyYXRlKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgIFwiQ2FsY3VsYXRlcyB0aGUgcGVyLXNlY29uZCBhdmVyYWdlIHJhdGUgb2YgaW5jcmVhc2Ugb2YgdGhlIHRpbWUgc2VyaWVzIGluIHRoZSByYW5nZSB2ZWN0b3IuIEJyZWFrcyBpbiBtb25vdG9uaWNpdHkgKHN1Y2ggYXMgY291bnRlciByZXNldHMgZHVlIHRvIHRhcmdldCByZXN0YXJ0cykgYXJlIGF1dG9tYXRpY2FsbHkgYWRqdXN0ZWQgZm9yLiBBbHNvLCB0aGUgY2FsY3VsYXRpb24gZXh0cmFwb2xhdGVzIHRvIHRoZSBlbmRzIG9mIHRoZSB0aW1lIHJhbmdlLCBhbGxvd2luZyBmb3IgbWlzc2VkIHNjcmFwZXMgb3IgaW1wZXJmZWN0IGFsaWdubWVudCBvZiBzY3JhcGUgY3ljbGVzIHdpdGggdGhlIHJhbmdlJ3MgdGltZSBwZXJpb2QuXCIsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmVzZXRzJyxcbiAgICBsYWJlbDogJ3Jlc2V0cycsXG4gICAgZGV0YWlsOiAncmVzZXRzKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdGb3IgZWFjaCBpbnB1dCB0aW1lIHNlcmllcywgYHJlc2V0cyh2IHJhbmdlLXZlY3RvcilgIHJldHVybnMgdGhlIG51bWJlciBvZiBjb3VudGVyIHJlc2V0cyB3aXRoaW4gdGhlIHByb3ZpZGVkIHRpbWUgcmFuZ2UgYXMgYW4gaW5zdGFudCB2ZWN0b3IuIEFueSBkZWNyZWFzZSBpbiB0aGUgdmFsdWUgYmV0d2VlbiB0d28gY29uc2VjdXRpdmUgc2FtcGxlcyBpcyBpbnRlcnByZXRlZCBhcyBhIGNvdW50ZXIgcmVzZXQuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdyb3VuZCcsXG4gICAgbGFiZWw6ICdyb3VuZCcsXG4gICAgZGV0YWlsOiAncm91bmQodiBpbnN0YW50LXZlY3RvciwgdG9fbmVhcmVzdD0xIHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUm91bmRzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4gVGllcyBhcmUgcmVzb2x2ZWQgYnkgcm91bmRpbmcgdXAuIFRoZSBvcHRpb25hbCBgdG9fbmVhcmVzdGAgYXJndW1lbnQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIG5lYXJlc3QgbXVsdGlwbGUgdG8gd2hpY2ggdGhlIHNhbXBsZSB2YWx1ZXMgc2hvdWxkIGJlIHJvdW5kZWQuIFRoaXMgbXVsdGlwbGUgbWF5IGFsc28gYmUgYSBmcmFjdGlvbi4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NjYWxhcicsXG4gICAgbGFiZWw6ICdzY2FsYXInLFxuICAgIGRldGFpbDogJ3NjYWxhcih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdHaXZlbiBhIHNpbmdsZS1lbGVtZW50IGlucHV0IHZlY3RvciwgYHNjYWxhcih2IGluc3RhbnQtdmVjdG9yKWAgcmV0dXJucyB0aGUgc2FtcGxlIHZhbHVlIG9mIHRoYXQgc2luZ2xlIGVsZW1lbnQgYXMgYSBzY2FsYXIuIElmIHRoZSBpbnB1dCB2ZWN0b3IgZG9lcyBub3QgaGF2ZSBleGFjdGx5IG9uZSBlbGVtZW50LCBgc2NhbGFyYCB3aWxsIHJldHVybiBgTmFOYC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NnbicsXG4gICAgbGFiZWw6ICdzZ24nLFxuICAgIGRldGFpbDogJ3Nnbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIGEgdmVjdG9yIHdpdGggYWxsIHNhbXBsZSB2YWx1ZXMgY29udmVydGVkIHRvIHRoZWlyIHNpZ24sIGRlZmluZWQgYXMgdGhpczogMSBpZiB2IGlzIHBvc2l0aXZlLCAtMSBpZiB2IGlzIG5lZ2F0aXZlIGFuZCAwIGlmIHYgaXMgZXF1YWwgdG8gemVyby4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NvcnQnLFxuICAgIGxhYmVsOiAnc29ydCcsXG4gICAgZGV0YWlsOiAnc29ydCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdmVjdG9yIGVsZW1lbnRzIHNvcnRlZCBieSB0aGVpciBzYW1wbGUgdmFsdWVzLCBpbiBhc2NlbmRpbmcgb3JkZXIuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzb3J0X2Rlc2MnLFxuICAgIGxhYmVsOiAnc29ydF9kZXNjJyxcbiAgICBkZXRhaWw6ICdzb3J0X2Rlc2ModiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHZlY3RvciBlbGVtZW50cyBzb3J0ZWQgYnkgdGhlaXIgc2FtcGxlIHZhbHVlcywgaW4gZGVzY2VuZGluZyBvcmRlci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NxcnQnLFxuICAgIGxhYmVsOiAnc3FydCcsXG4gICAgZGV0YWlsOiAnc3FydCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZXMgdGhlIHNxdWFyZSByb290IG9mIGFsbCBlbGVtZW50cyBpbiBgdmAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICd0aW1lJyxcbiAgICBsYWJlbDogJ3RpbWUnLFxuICAgIGRldGFpbDogJ3RpbWUoKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAgVVRDLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhY3R1YWxseSByZXR1cm4gdGhlIGN1cnJlbnQgdGltZSwgYnV0IHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBleHByZXNzaW9uIGlzIHRvIGJlIGV2YWx1YXRlZC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3RpbWVzdGFtcCcsXG4gICAgbGFiZWw6ICd0aW1lc3RhbXAnLFxuICAgIGRldGFpbDogJ3RpbWVzdGFtcCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSB0aW1lc3RhbXAgb2YgZWFjaCBvZiB0aGUgc2FtcGxlcyBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGFzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAgVVRDLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAndmVjdG9yJyxcbiAgICBsYWJlbDogJ3ZlY3RvcicsXG4gICAgZGV0YWlsOiAndmVjdG9yKHMgc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdGhlIHNjYWxhciBgc2AgYXMgYSB2ZWN0b3Igd2l0aCBubyBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICd5ZWFyJyxcbiAgICBsYWJlbDogJ3llYXInLFxuICAgIGRldGFpbDogJ3llYXIodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHRoZSB5ZWFyIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdhdmdfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2F2Z19vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2F2Z19vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBhdmVyYWdlIHZhbHVlIG9mIGFsbCBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ21pbl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnbWluX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnbWluX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIG1pbmltdW0gdmFsdWUgb2YgYWxsIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbWF4X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdtYXhfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdtYXhfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbWF4aW11bSB2YWx1ZSBvZiBhbGwgcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzdW1fb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3N1bV9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ3N1bV9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBzdW0gb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY291bnRfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2NvdW50X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnY291bnRfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgY291bnQgb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncXVhbnRpbGVfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3F1YW50aWxlX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAncXVhbnRpbGVfb3Zlcl90aW1lKHNjYWxhciwgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSDPhi1xdWFudGlsZSAoMCDiiaQgz4Yg4omkIDEpIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N0ZGRldl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3RkZGV2X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3RkZGV2X292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIHBvcHVsYXRpb24gc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N0ZHZhcl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3RkdmFyX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3RkdmFyX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIHBvcHVsYXRpb24gc3RhbmRhcmQgdmFyaWFuY2Ugb2YgdGhlIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbGFzdF9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnbGFzdF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2xhc3Rfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbW9zdCByZWNlbnQgcG9pbnQgdmFsdWUgaW4gc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgUFJPTV9LRVlXT1JEUyA9IEZVTkNUSU9OUy5tYXAoKGtleXdvcmQpID0+IGtleXdvcmQubGFiZWwpO1xuXG5leHBvcnQgY29uc3QgcHJvbXFsR3JhbW1hcjogR3JhbW1hciA9IHtcbiAgY29tbWVudDoge1xuICAgIHBhdHRlcm46IC8jLiovLFxuICB9LFxuICAnY29udGV4dC1hZ2dyZWdhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKChieXx3aXRob3V0KVxccyopXFwoW14pXSpcXCkvLCAvLyBieSAoKVxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnbGFiZWwta2V5Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvW14oKSxcXHNdW14sKV0qW14pLFxcc10qLyxcbiAgICAgICAgYWxpYXM6ICdhdHRyLW5hbWUnLFxuICAgICAgfSxcbiAgICAgIHB1bmN0dWF0aW9uOiAvWygpXS8sXG4gICAgfSxcbiAgfSxcbiAgJ2NvbnRleHQtbGFiZWxzJzoge1xuICAgIHBhdHRlcm46IC9cXHtbXn1dKig/PX0/KS8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgY29tbWVudDoge1xuICAgICAgICBwYXR0ZXJuOiAvIy4qLyxcbiAgICAgIH0sXG4gICAgICAnbGFiZWwta2V5Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvW2Etel9dXFx3Kig/PVxccyooPXwhPXw9fnwhfikpLyxcbiAgICAgICAgYWxpYXM6ICdhdHRyLW5hbWUnLFxuICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICB9LFxuICAgICAgJ2xhYmVsLXZhbHVlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcLnxbXlxcXFxcIl0pKlwiLyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBhbGlhczogJ2F0dHItdmFsdWUnLFxuICAgICAgfSxcbiAgICAgIHB1bmN0dWF0aW9uOiAvW3tdLyxcbiAgICB9LFxuICB9LFxuICBmdW5jdGlvbjogbmV3IFJlZ0V4cChgXFxcXGIoPzoke0ZVTkNUSU9OUy5tYXAoKGYpID0+IGYubGFiZWwpLmpvaW4oJ3wnKX0pKD89XFxcXHMqXFxcXCgpYCwgJ2knKSxcbiAgJ2NvbnRleHQtcmFuZ2UnOiBbXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcW1teXFxdXSooPz1dKS8sIC8vIFsxbV1cbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKG9mZnNldFxccyspXFx3Ky8sIC8vIG9mZnNldCAxbVxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbiAgaWRMaXN0OiB7XG4gICAgcGF0dGVybjogL1xcZCsoXFx8XFxkKykrLyxcbiAgICBhbGlhczogJ251bWJlcicsXG4gIH0sXG4gIG51bWJlcjogL1xcYi0/XFxkKygoXFwuXFxkKik/KFtlRV1bKy1dP1xcZCspPyk/XFxiLyxcbiAgb3BlcmF0b3I6IG5ldyBSZWdFeHAoYC9bLSsqLz0lXn5dfCYmP3xcXFxcfD9cXFxcfHwhPT98PCg/Oj0+P3w8fD4pP3w+Wz49XT98XFxcXGIoPzoke09QRVJBVE9SUy5qb2luKCd8Jyl9KVxcXFxiYCwgJ2knKSxcbiAgcHVuY3R1YXRpb246IC9be307KClgLC5dLyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByb21xbEdyYW1tYXI7XG4iLCJpbXBvcnQgeyBzaXplIH0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHsgUXVlcnlIaW50LCBRdWVyeUZpeCB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5cbi8qKlxuICogTnVtYmVyIG9mIHRpbWUgc2VyaWVzIHJlc3VsdHMgbmVlZGVkIGJlZm9yZSBzdGFydGluZyB0byBzdWdnZXN0IHN1bSBhZ2dyZWdhdGlvbiBoaW50c1xuICovXG5leHBvcnQgY29uc3QgU1VNX0hJTlRfVEhSRVNIT0xEX0NPVU5UID0gMjA7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWVyeUhpbnRzKHF1ZXJ5OiBzdHJpbmcsIHNlcmllcz86IGFueVtdLCBkYXRhc291cmNlPzogUHJvbWV0aGV1c0RhdGFzb3VyY2UpOiBRdWVyeUhpbnRbXSB7XG4gIGNvbnN0IGhpbnRzID0gW107XG5cbiAgLy8gLi4uX2J1Y2tldCBtZXRyaWMgbmVlZHMgYSBoaXN0b2dyYW1fcXVhbnRpbGUoKVxuICBjb25zdCBoaXN0b2dyYW1NZXRyaWMgPSBxdWVyeS50cmltKCkubWF0Y2goL15cXHcrX2J1Y2tldCR8XlxcdytfYnVja2V0ey4qfSQvKTtcbiAgaWYgKGhpc3RvZ3JhbU1ldHJpYykge1xuICAgIGNvbnN0IGxhYmVsID0gJ1NlbGVjdGVkIG1ldHJpYyBoYXMgYnVja2V0cy4nO1xuICAgIGhpbnRzLnB1c2goe1xuICAgICAgdHlwZTogJ0hJU1RPR1JBTV9RVUFOVElMRScsXG4gICAgICBsYWJlbCxcbiAgICAgIGZpeDoge1xuICAgICAgICBsYWJlbDogJ0NvbnNpZGVyIGNhbGN1bGF0aW5nIGFnZ3JlZ2F0ZWQgcXVhbnRpbGUgYnkgYWRkaW5nIGhpc3RvZ3JhbV9xdWFudGlsZSgpLicsXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgIHR5cGU6ICdBRERfSElTVE9HUkFNX1FVQU5USUxFJyxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgfSxcbiAgICAgIH0gYXMgUXVlcnlGaXgsXG4gICAgfSk7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgbmVlZCBvZiByYXRlKClcbiAgaWYgKHF1ZXJ5LmluZGV4T2YoJ3JhdGUoJykgPT09IC0xICYmIHF1ZXJ5LmluZGV4T2YoJ2luY3JlYXNlKCcpID09PSAtMSkge1xuICAgIC8vIFVzZSBtZXRyaWMgbWV0YWRhdGEgZm9yIGV4YWN0IHR5cGVzXG4gICAgY29uc3QgbmFtZU1hdGNoID0gcXVlcnkubWF0Y2goL1xcYihcXHcrXyh0b3RhbHxzdW18Y291bnQpKVxcYi8pO1xuICAgIGxldCBjb3VudGVyTmFtZU1ldHJpYyA9IG5hbWVNYXRjaCA/IG5hbWVNYXRjaFsxXSA6ICcnO1xuICAgIGNvbnN0IG1ldHJpY3NNZXRhZGF0YSA9IGRhdGFzb3VyY2U/Lmxhbmd1YWdlUHJvdmlkZXI/Lm1ldHJpY3NNZXRhZGF0YSA/PyB7fTtcbiAgICBjb25zdCBtZXRyaWNNZXRhZGF0YUtleXMgPSBPYmplY3Qua2V5cyhtZXRyaWNzTWV0YWRhdGEpO1xuICAgIGxldCBjZXJ0YWluID0gZmFsc2U7XG5cbiAgICBpZiAobWV0cmljTWV0YWRhdGFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvdW50ZXJOYW1lTWV0cmljID1cbiAgICAgICAgbWV0cmljTWV0YWRhdGFLZXlzLmZpbmQoKG1ldHJpY05hbWUpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IGNvbnNpZGVyaW5nIGZpcnN0IHR5cGUgaW5mb3JtYXRpb24sIGNvdWxkIGJlIG5vbi1kZXRlcm1pbmlzdGljXG4gICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBtZXRyaWNzTWV0YWRhdGFbbWV0cmljTmFtZV07XG4gICAgICAgICAgaWYgKG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2NvdW50ZXInKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRyaWNSZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxiJHttZXRyaWNOYW1lfVxcXFxiYCk7XG4gICAgICAgICAgICBpZiAocXVlcnkubWF0Y2gobWV0cmljUmVnZXgpKSB7XG4gICAgICAgICAgICAgIGNlcnRhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSA/PyAnJztcbiAgICB9XG5cbiAgICBpZiAoY291bnRlck5hbWVNZXRyaWMpIHtcbiAgICAgIC8vIEZpeGFibGVRdWVyeSBjb25zaXN0cyBvZiBtZXRyaWMgbmFtZSBhbmQgb3B0aW9uYWxseSBsYWJlbC12YWx1ZSBwYWlycy4gV2UgYXJlIG5vdCBvZmZlcmluZyBmaXggZm9yIGNvbXBsZXggcXVlcmllcyB5ZXQuXG4gICAgICBjb25zdCBmaXhhYmxlUXVlcnkgPSBxdWVyeS50cmltKCkubWF0Y2goL15cXHcrJHxeXFx3K3suKn0kLyk7XG4gICAgICBjb25zdCB2ZXJiID0gY2VydGFpbiA/ICdpcycgOiAnbG9va3MgbGlrZSc7XG4gICAgICBsZXQgbGFiZWwgPSBgU2VsZWN0ZWQgbWV0cmljICR7dmVyYn0gYSBjb3VudGVyLmA7XG4gICAgICBsZXQgZml4OiBRdWVyeUZpeCB8IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGZpeGFibGVRdWVyeSkge1xuICAgICAgICBmaXggPSB7XG4gICAgICAgICAgbGFiZWw6ICdDb25zaWRlciBjYWxjdWxhdGluZyByYXRlIG9mIGNvdW50ZXIgYnkgYWRkaW5nIHJhdGUoKS4nLFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogJ0FERF9SQVRFJyxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbCA9IGAke2xhYmVsfSBDb25zaWRlciBjYWxjdWxhdGluZyByYXRlIG9mIGNvdW50ZXIgYnkgYWRkaW5nIHJhdGUoKS5gO1xuICAgICAgfVxuXG4gICAgICBoaW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0FQUExZX1JBVEUnLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZml4LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHJlY29yZGluZyBydWxlcyBleHBhbnNpb25cbiAgaWYgKGRhdGFzb3VyY2UgJiYgZGF0YXNvdXJjZS5ydWxlTWFwcGluZ3MpIHtcbiAgICBjb25zdCBtYXBwaW5nID0gZGF0YXNvdXJjZS5ydWxlTWFwcGluZ3M7XG4gICAgY29uc3QgbWFwcGluZ0ZvclF1ZXJ5ID0gT2JqZWN0LmtleXMobWFwcGluZykucmVkdWNlKChhY2MsIHJ1bGVOYW1lKSA9PiB7XG4gICAgICBpZiAocXVlcnkuc2VhcmNoKHJ1bGVOYW1lKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgIFtydWxlTmFtZV06IG1hcHBpbmdbcnVsZU5hbWVdLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgaWYgKHNpemUobWFwcGluZ0ZvclF1ZXJ5KSA+IDApIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gJ1F1ZXJ5IGNvbnRhaW5zIHJlY29yZGluZyBydWxlcy4nO1xuICAgICAgaGludHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdFWFBBTkRfUlVMRVMnLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZml4OiB7XG4gICAgICAgICAgbGFiZWw6ICdFeHBhbmQgcnVsZXMnLFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogJ0VYUEFORF9SVUxFUycsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIG1hcHBpbmc6IG1hcHBpbmdGb3JRdWVyeSxcbiAgICAgICAgICB9LFxuICAgICAgICB9IGFzIGFueSBhcyBRdWVyeUZpeCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZXJpZXMgJiYgc2VyaWVzLmxlbmd0aCA+PSBTVU1fSElOVF9USFJFU0hPTERfQ09VTlQpIHtcbiAgICBjb25zdCBzaW1wbGVNZXRyaWMgPSBxdWVyeS50cmltKCkubWF0Y2goL15cXHcrJC8pO1xuICAgIGlmIChzaW1wbGVNZXRyaWMpIHtcbiAgICAgIGhpbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnQUREX1NVTScsXG4gICAgICAgIGxhYmVsOiAnTWFueSB0aW1lIHNlcmllcyByZXN1bHRzIHJldHVybmVkLicsXG4gICAgICAgIGZpeDoge1xuICAgICAgICAgIGxhYmVsOiAnQ29uc2lkZXIgYWdncmVnYXRpbmcgd2l0aCBzdW0oKS4nLFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogJ0FERF9TVU0nLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgcHJldmVudFN1Ym1pdDogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9IGFzIFF1ZXJ5Rml4LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5pdEhpbnRzKGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlKTogUXVlcnlIaW50W10ge1xuICBjb25zdCBoaW50cyA9IFtdO1xuICAvLyBIaW50IGlmIHVzaW5nIExva2kgYXMgUHJvbWV0aGV1cyBkYXRhIHNvdXJjZVxuICBpZiAoZGF0YXNvdXJjZS5kaXJlY3RVcmwuaW5jbHVkZXMoJy9sb2tpJykgJiYgIWRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5tZXRyaWNzLmxlbmd0aCkge1xuICAgIGhpbnRzLnB1c2goe1xuICAgICAgbGFiZWw6IGBVc2luZyBMb2tpIGFzIGEgUHJvbWV0aGV1cyBkYXRhIHNvdXJjZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBZb3UgbXVzdCB1c2UgdGhlIExva2kgZGF0YSBzb3VyY2UgZm9yIHlvdXIgTG9raSBpbnN0YW5jZS5gLFxuICAgICAgdHlwZTogJ0lORk8nLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gSGludCBmb3IgYmlnIGRpc2FibGVkIGxvb2t1cHNcbiAgaWYgKGRhdGFzb3VyY2UubG9va3Vwc0Rpc2FibGVkKSB7XG4gICAgaGludHMucHVzaCh7XG4gICAgICBsYWJlbDogYExhYmVscyBhbmQgbWV0cmljcyBsb29rdXAgd2FzIGRpc2FibGVkIGluIGRhdGEgc291cmNlIHNldHRpbmdzLmAsXG4gICAgICB0eXBlOiAnSU5GTycsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaGludHM7XG59XG4iLCJpbXBvcnQgeyBGVU5DVElPTlMgfSBmcm9tICcuLi9wcm9tcWwnO1xuXG5pbXBvcnQgeyBnZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMgfSBmcm9tICcuL2FnZ3JlZ2F0aW9ucyc7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25EZWZpbml0aW9ucyB9IGZyb20gJy4vb3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIH0gZnJvbSAnLi9zaGFyZWQvTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnlQYXR0ZXJuLCBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgUHJvbVF1ZXJ5TW9kZWxsZXIgZXh0ZW5kcyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKCkgPT4ge1xuICAgICAgY29uc3QgYWxsT3BlcmF0aW9ucyA9IFsuLi5nZXRPcGVyYXRpb25EZWZpbml0aW9ucygpLCAuLi5nZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMoKV07XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIGFsbE9wZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZnVuYyA9IEZVTkNUSU9OUy5maW5kKCh4KSA9PiB4Lmluc2VydFRleHQgPT09IG9wLmlkKTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICBvcC5kb2N1bWVudGF0aW9uID0gZnVuYy5kb2N1bWVudGF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsT3BlcmF0aW9ucztcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0T3BlcmF0aW9uQ2F0ZWdvcmllcyhbXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5UaW1lLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0UXVlcnlQYXR0ZXJucygpOiBQcm9tUXVlcnlQYXR0ZXJuW10ge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdSYXRlIHRoZW4gc3VtJyxcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6ICdyYXRlJywgcGFyYW1zOiBbJyRfX3JhdGVfaW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdzdW0nLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnUmF0ZSB0aGVuIHN1bSBieShsYWJlbCkgdGhlbiBhdmcnLFxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogJ3JhdGUnLCBwYXJhbXM6IFsnJF9fcmF0ZV9pbnRlcnZhbCddIH0sXG4gICAgICAgICAgeyBpZDogJ19fc3VtX2J5JywgcGFyYW1zOiBbJyddIH0sXG4gICAgICAgICAgeyBpZDogJ2F2ZycsIHBhcmFtczogW10gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdIaXN0b2dyYW0gcXVhbnRpbGUgb24gcmF0ZScsXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiAncmF0ZScsIHBhcmFtczogWyckX19yYXRlX2ludGVydmFsJ10gfSxcbiAgICAgICAgICB7IGlkOiAnX19zdW1fYnknLCBwYXJhbXM6IFsnbGUnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdoaXN0b2dyYW1fcXVhbnRpbGUnLCBwYXJhbXM6IFswLjk1XSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0hpc3RvZ3JhbSBxdWFudGlsZSBvbiBpbmNyZWFzZSAnLFxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogJ2luY3JlYXNlJywgcGFyYW1zOiBbJyRfX3JhdGVfaW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdfX21heF9ieScsIHBhcmFtczogWydsZSddIH0sXG4gICAgICAgICAgeyBpZDogJ2hpc3RvZ3JhbV9xdWFudGlsZScsIHBhcmFtczogWzAuOTVdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIF07XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHByb21RdWVyeU1vZGVsbGVyID0gbmV3IFByb21RdWVyeU1vZGVsbGVyKCk7XG4iLCJpbXBvcnQgeyBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IgfSBmcm9tICcuL29wZXJhdGlvbnMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24sXG4gIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtLFxuICBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lLFxuICBnZXRSYW5nZVZlY3RvclBhcmFtRGVmLFxufSBmcm9tICcuL3NoYXJlZC9vcGVyYXRpb25VdGlscyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB9IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LCBQcm9tT3BlcmF0aW9uSWQgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFnZ3JlZ2F0aW9uT3BlcmF0aW9ucygpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIHJldHVybiBbXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLlN1bSksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLkF2ZyksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLk1pbiksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLk1heCksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLkNvdW50KSxcbiAgICAuLi5jcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbShQcm9tT3BlcmF0aW9uSWQuVG9wSywge1xuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnSy12YWx1ZScsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzVdLFxuICAgIH0pLFxuICAgIC4uLmNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtKFByb21PcGVyYXRpb25JZC5Cb3R0b21LLCB7XG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdLLXZhbHVlJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbNV0sXG4gICAgfSksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0oUHJvbU9wZXJhdGlvbklkLkNvdW50VmFsdWVzLCB7XG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdJZGVudGlmaWVyJywgdHlwZTogJ3N0cmluZycgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJ2NvdW50J10sXG4gICAgfSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuU3VtT3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkF2Z092ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5NaW5PdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuTWF4T3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkNvdW50T3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkxhc3RPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuUHJlc2VudE92ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5BYnNlbnRPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuU3RkZGV2T3ZlclRpbWUpLFxuICBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKG5hbWU6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB7XG4gIHJldHVybiB7XG4gICAgaWQ6IG5hbWUsXG4gICAgbmFtZTogZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKSxcbiAgICBwYXJhbXM6IFtnZXRSYW5nZVZlY3RvclBhcmFtRGVmKCldLFxuICAgIGRlZmF1bHRQYXJhbXM6IFsnJF9faW50ZXJ2YWwnXSxcbiAgICBhbHRlcm5hdGl2ZXNLZXk6ICdvdmVydGltZSBmdW5jdGlvbicsXG4gICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgIHJlbmRlcmVyOiBvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlcixcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IsXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmdcbikge1xuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnJF9faW50ZXJ2YWwnO1xuICByZXR1cm4gYCR7ZGVmLmlkfSgke2lubmVyRXhwcn1bJHtyYW5nZVZlY3Rvcn1dKWA7XG59XG4iLCJpbXBvcnQgeyBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlciB9IGZyb20gJy4vc2hhcmVkL29wZXJhdGlvblV0aWxzJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZiB9IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21PcGVyYXRpb25JZCwgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IGJpbmFyeVNjYWxhckRlZnMgPSBbXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkFkZGl0aW9uLFxuICAgIG5hbWU6ICdBZGQgc2NhbGFyJyxcbiAgICBzaWduOiAnKycsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLlN1YnRyYWN0aW9uLFxuICAgIG5hbWU6ICdTdWJ0cmFjdCBzY2FsYXInLFxuICAgIHNpZ246ICctJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTXVsdGlwbHlCeSxcbiAgICBuYW1lOiAnTXVsdGlwbHkgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnKicsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRpdmlkZUJ5LFxuICAgIG5hbWU6ICdEaXZpZGUgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnLycsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLk1vZHVsbyxcbiAgICBuYW1lOiAnTW9kdWxvIGJ5IHNjYWxhcicsXG4gICAgc2lnbjogJyUnLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5FeHBvbmVudCxcbiAgICBuYW1lOiAnRXhwb25lbnQnLFxuICAgIHNpZ246ICdeJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuRXF1YWxUbyxcbiAgICBuYW1lOiAnRXF1YWwgdG8nLFxuICAgIHNpZ246ICc9PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTm90RXF1YWxUbyxcbiAgICBuYW1lOiAnTm90IGVxdWFsIHRvJyxcbiAgICBzaWduOiAnIT0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkdyZWF0ZXJUaGFuLFxuICAgIG5hbWU6ICdHcmVhdGVyIHRoYW4nLFxuICAgIHNpZ246ICc+JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5MZXNzVGhhbixcbiAgICBuYW1lOiAnTGVzcyB0aGFuJyxcbiAgICBzaWduOiAnPCcsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuR3JlYXRlck9yRXF1YWwsXG4gICAgbmFtZTogJ0dyZWF0ZXIgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc+PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTGVzc09yRXF1YWwsXG4gICAgbmFtZTogJ0xlc3Mgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc8PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBiaW5hcnlTY2FsYXJPcGVyYXRvclRvT3BlcmF0b3JOYW1lID0gYmluYXJ5U2NhbGFyRGVmcy5yZWR1Y2UoKGFjYywgZGVmKSA9PiB7XG4gIGFjY1tkZWYuc2lnbl0gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBjb21wYXJpc29uOiBkZWYuY29tcGFyaXNvbixcbiAgfTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHsgaWQ6IHN0cmluZzsgY29tcGFyaXNvbj86IGJvb2xlYW4gfT4pO1xuXG4vLyBOb3Qgc3VyZSBhYm91dCB0aGlzIG9uZS4gSXQgY291bGQgYWxzbyBiZSBhIG1vcmUgZ2VuZXJpYyAnU2ltcGxlIG1hdGggb3BlcmF0aW9uJyB3aGVyZSB1c2VyIHNwZWNpZmllc1xuLy8gYm90aCB0aGUgb3BlcmF0b3IgYW5kIHRoZSBvcGVyYW5kIGluIGEgc2luZ2xlIGlucHV0XG5leHBvcnQgY29uc3QgYmluYXJ5U2NhbGFyT3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10gPSBiaW5hcnlTY2FsYXJEZWZzLm1hcCgob3BEZWYpID0+IHtcbiAgY29uc3QgcGFyYW1zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZltdID0gW3sgbmFtZTogJ1ZhbHVlJywgdHlwZTogJ251bWJlcicgfV07XG4gIGNvbnN0IGRlZmF1bHRQYXJhbXM6IGFueVtdID0gWzJdO1xuICBpZiAob3BEZWYuY29tcGFyaXNvbikge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIG5hbWU6ICdCb29sJyxcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnSWYgY2hlY2tlZCBjb21wYXJpc29uIHdpbGwgcmV0dXJuIDAgb3IgMSBmb3IgdGhlIHZhbHVlIHJhdGhlciB0aGFuIGZpbHRlcmluZy4nLFxuICAgIH0pO1xuICAgIGRlZmF1bHRQYXJhbXMucHVzaChmYWxzZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkOiBvcERlZi5pZCxcbiAgICBuYW1lOiBvcERlZi5uYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkZWZhdWx0UGFyYW1zLFxuICAgIGFsdGVybmF0aXZlc0tleTogJ2JpbmFyeSBzY2FsYXIgb3BlcmF0aW9ucycsXG4gICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICByZW5kZXJlcjogZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIob3BEZWYuc2lnbiksXG4gICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gIH07XG59KTtcblxuZnVuY3Rpb24gZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIob3BlcmF0b3I6IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gYmluYXJ5UmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgbGV0IHBhcmFtID0gbW9kZWwucGFyYW1zWzBdO1xuICAgIGxldCBib29sID0gJyc7XG4gICAgaWYgKG1vZGVsLnBhcmFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGJvb2wgPSBtb2RlbC5wYXJhbXNbMV0gPyAnIGJvb2wnIDogJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2lubmVyRXhwcn0gJHtvcGVyYXRvcn0ke2Jvb2x9ICR7cGFyYW19YDtcbiAgfTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgU2VsZWN0YWJsZVZhbHVlLCB0b09wdGlvbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU2VsZWN0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBwcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGdldE9wZXJhdGlvblBhcmFtSWQgfSBmcm9tICcuLi9zaGFyZWQvb3BlcmF0aW9uVXRpbHMnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gTGFiZWxQYXJhbUVkaXRvcih7XG4gIG9uQ2hhbmdlLFxuICBpbmRleCxcbiAgb3BlcmF0aW9uSW5kZXgsXG4gIHZhbHVlLFxuICBxdWVyeSxcbiAgZGF0YXNvdXJjZSxcbn06IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTx7XG4gICAgb3B0aW9ucz86IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxhbnk+PjtcbiAgICBpc0xvYWRpbmc/OiBib29sZWFuO1xuICB9Pih7fSk7XG5cbiAgcmV0dXJuIChcbiAgICA8U2VsZWN0XG4gICAgICBpbnB1dElkPXtnZXRPcGVyYXRpb25QYXJhbUlkKG9wZXJhdGlvbkluZGV4LCBpbmRleCl9XG4gICAgICBhdXRvRm9jdXM9e3ZhbHVlID09PSAnJyA/IHRydWUgOiB1bmRlZmluZWR9XG4gICAgICBvcGVuTWVudU9uRm9jdXNcbiAgICAgIG9uT3Blbk1lbnU9e2FzeW5jICgpID0+IHtcbiAgICAgICAgc2V0U3RhdGUoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBsb2FkR3JvdXBCeUxhYmVscyhxdWVyeSwgZGF0YXNvdXJjZSk7XG4gICAgICAgIHNldFN0YXRlKHsgb3B0aW9ucywgaXNMb2FkaW5nOiB1bmRlZmluZWQgfSk7XG4gICAgICB9fVxuICAgICAgaXNMb2FkaW5nPXtzdGF0ZS5pc0xvYWRpbmd9XG4gICAgICBhbGxvd0N1c3RvbVZhbHVlXG4gICAgICBub09wdGlvbnNNZXNzYWdlPVwiTm8gbGFiZWxzIGZvdW5kXCJcbiAgICAgIGxvYWRpbmdNZXNzYWdlPVwiTG9hZGluZyBsYWJlbHNcIlxuICAgICAgb3B0aW9ucz17c3RhdGUub3B0aW9uc31cbiAgICAgIHZhbHVlPXt0b09wdGlvbih2YWx1ZSBhcyBzdHJpbmcpfVxuICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4gb25DaGFuZ2UoaW5kZXgsIHZhbHVlLnZhbHVlISl9XG4gICAgLz5cbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZEdyb3VwQnlMYWJlbHMoXG4gIHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnksXG4gIGRhdGFzb3VyY2U6IERhdGFTb3VyY2VBcGlcbik6IFByb21pc2U8QXJyYXk8U2VsZWN0YWJsZVZhbHVlPGFueT4+PiB7XG4gIGxldCBsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10gPSBxdWVyeS5sYWJlbHM7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IGJvdGggUHJvbWV0aGV1cyBhbmQgTG9raSBhbmQgdGhpcyB0aGUgb25seSBkaWZmZXJlbmNlLlxuICBpZiAoZGF0YXNvdXJjZS50eXBlID09PSAncHJvbWV0aGV1cycpIHtcbiAgICBsYWJlbHMgPSBbeyBsYWJlbDogJ19fbmFtZV9fJywgb3A6ICc9JywgdmFsdWU6IHF1ZXJ5Lm1ldHJpYyB9LCAuLi5xdWVyeS5sYWJlbHNdO1xuICB9XG5cbiAgY29uc3QgZXhwciA9IHByb21RdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyhsYWJlbHMpO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hTZXJpZXNMYWJlbHMoZXhwcik7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3VsdCkubWFwKCh4KSA9PiAoe1xuICAgIGxhYmVsOiB4LFxuICAgIHZhbHVlOiB4LFxuICB9KSk7XG59XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0Jztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBIaWdobGlnaHRlciBmcm9tICdyZWFjdC1oaWdobGlnaHQtd29yZHMnO1xuXG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUsIHRvT3B0aW9uLCBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JGaWVsZCwgRWRpdG9yRmllbGRHcm91cCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBTZWxlY3QsIEZvcm1hdE9wdGlvbkxhYmVsTWV0YSwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vLyBXZSBhcmUgbWF0Y2hpbmcgd29yZHMgc3BsaXQgd2l0aCBzcGFjZVxuY29uc3Qgc3BsaXRTZXBhcmF0b3IgPSAnICc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5O1xuICBvbkNoYW5nZTogKHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkpID0+IHZvaWQ7XG4gIG9uR2V0TWV0cmljczogKCkgPT4gUHJvbWlzZTxTZWxlY3RhYmxlVmFsdWVbXT47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBNZXRyaWNTZWxlY3QoeyBxdWVyeSwgb25DaGFuZ2UsIG9uR2V0TWV0cmljcyB9OiBQcm9wcykge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8e1xuICAgIG1ldHJpY3M/OiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8YW55Pj47XG4gICAgaXNMb2FkaW5nPzogYm9vbGVhbjtcbiAgfT4oe30pO1xuXG4gIGNvbnN0IGN1c3RvbUZpbHRlck9wdGlvbiA9IHVzZUNhbGxiYWNrKChvcHRpb246IFNlbGVjdGFibGVWYWx1ZTxhbnk+LCBzZWFyY2hRdWVyeTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSBvcHRpb24ubGFiZWwgPz8gb3B0aW9uLnZhbHVlO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjdXN0b20gdmFsdWUgaXMgbm90IGEgc3RyaW5nIGxhYmVsIGJ1dCBhIHJlYWN0IG5vZGVcbiAgICBpZiAoIWxhYmVsLnRvTG93ZXJDYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWFyY2hXb3JkcyA9IHNlYXJjaFF1ZXJ5LnNwbGl0KHNwbGl0U2VwYXJhdG9yKTtcbiAgICByZXR1cm4gc2VhcmNoV29yZHMucmVkdWNlKChhY2MsIGN1cikgPT4gYWNjICYmIGxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoY3VyLnRvTG93ZXJDYXNlKCkpLCB0cnVlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGZvcm1hdE9wdGlvbkxhYmVsID0gdXNlQ2FsbGJhY2soXG4gICAgKG9wdGlvbjogU2VsZWN0YWJsZVZhbHVlPGFueT4sIG1ldGE6IEZvcm1hdE9wdGlvbkxhYmVsTWV0YTxhbnk+KSA9PiB7XG4gICAgICAvLyBGb3IgbmV3bHkgY3JlYXRlZCBjdXN0b20gdmFsdWUgd2UgZG9uJ3Qgd2FudCB0byBhZGQgaGlnaGxpZ2h0XG4gICAgICBpZiAob3B0aW9uWydfX2lzTmV3X18nXSkge1xuICAgICAgICByZXR1cm4gb3B0aW9uLmxhYmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8SGlnaGxpZ2h0ZXJcbiAgICAgICAgICBzZWFyY2hXb3Jkcz17bWV0YS5pbnB1dFZhbHVlLnNwbGl0KHNwbGl0U2VwYXJhdG9yKX1cbiAgICAgICAgICB0ZXh0VG9IaWdobGlnaHQ9e29wdGlvbi5sYWJlbCA/PyAnJ31cbiAgICAgICAgICBoaWdobGlnaHRDbGFzc05hbWU9e3N0eWxlcy5oaWdobGlnaHR9XG4gICAgICAgIC8+XG4gICAgICApO1xuICAgIH0sXG4gICAgW3N0eWxlcy5oaWdobGlnaHRdXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8RWRpdG9yRmllbGRHcm91cD5cbiAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIk1ldHJpY1wiPlxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgaW5wdXRJZD1cInByb21ldGhldXMtbWV0cmljLXNlbGVjdFwiXG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuc2VsZWN0fVxuICAgICAgICAgIHZhbHVlPXtxdWVyeS5tZXRyaWMgPyB0b09wdGlvbihxdWVyeS5tZXRyaWMpIDogdW5kZWZpbmVkfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiU2VsZWN0IG1ldHJpY1wiXG4gICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgIGZvcm1hdE9wdGlvbkxhYmVsPXtmb3JtYXRPcHRpb25MYWJlbH1cbiAgICAgICAgICBmaWx0ZXJPcHRpb249e2N1c3RvbUZpbHRlck9wdGlvbn1cbiAgICAgICAgICBvbk9wZW5NZW51PXthc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBhd2FpdCBvbkdldE1ldHJpY3MoKTtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgbWV0cmljcywgaXNMb2FkaW5nOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBpc0xvYWRpbmc9e3N0YXRlLmlzTG9hZGluZ31cbiAgICAgICAgICBvcHRpb25zPXtzdGF0ZS5tZXRyaWNzfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgbWV0cmljOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICA8L0VkaXRvckZpZWxkR3JvdXA+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgc2VsZWN0OiBjc3NgXG4gICAgbWluLXdpZHRoOiAxMjVweDtcbiAgYCxcbiAgaGlnaGxpZ2h0OiBjc3NgXG4gICAgbGFiZWw6IHNlbGVjdF9fbWF0Y2gtaGlnaGxpZ2h0O1xuICAgIGJhY2tncm91bmQ6IGluaGVyaXQ7XG4gICAgcGFkZGluZzogaW5oZXJpdDtcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMud2FybmluZy5jb250cmFzdFRleHR9O1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLndhcm5pbmcubWFpbn07XG4gIGAsXG59KTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyLCB0b09wdGlvbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9yUm93cywgRmxleEl0ZW0gfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgQXV0b1NpemVJbnB1dCwgSWNvbkJ1dHRvbiwgU2VsZWN0LCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgYmluYXJ5U2NhbGFyRGVmcyB9IGZyb20gJy4uL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBQcm9tUXVlcnlCdWlsZGVyIH0gZnJvbSAnLi9Qcm9tUXVlcnlCdWlsZGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIG5lc3RlZFF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnlCaW5hcnk7XG4gIGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlO1xuICBpbmRleDogbnVtYmVyO1xuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5KSA9PiB2b2lkO1xuICBvblJlbW92ZTogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBOZXN0ZWRRdWVyeSA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IG5lc3RlZFF1ZXJ5LCBpbmRleCwgZGF0YXNvdXJjZSwgb25DaGFuZ2UsIG9uUmVtb3ZlLCBvblJ1blF1ZXJ5IH0pID0+IHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jYXJkfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5uYW1lfT5PcGVyYXRvcjwvZGl2PlxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICBvcHRpb25zPXtvcGVyYXRvcnN9XG4gICAgICAgICAgdmFsdWU9e3RvT3B0aW9uKG5lc3RlZFF1ZXJ5Lm9wZXJhdG9yKX1cbiAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBvbkNoYW5nZShpbmRleCwge1xuICAgICAgICAgICAgICAuLi5uZXN0ZWRRdWVyeSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6IHZhbHVlLnZhbHVlISxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubmFtZX0+VmVjdG9yIG1hdGNoZXM8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52ZWN0b3JNYXRjaFdyYXBwZXJ9PlxuICAgICAgICAgIDxTZWxlY3Q8UHJvbVZpc3VhbFF1ZXJ5QmluYXJ5Wyd2ZWN0b3JNYXRjaGVzVHlwZSddPlxuICAgICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICAgIHZhbHVlPXtuZXN0ZWRRdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSB8fCAnb24nfVxuICAgICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgICAgb3B0aW9ucz17W1xuICAgICAgICAgICAgICB7IHZhbHVlOiAnb24nLCBsYWJlbDogJ29uJyB9LFxuICAgICAgICAgICAgICB7IHZhbHVlOiAnaWdub3JpbmcnLCBsYWJlbDogJ2lnbm9yaW5nJyB9LFxuICAgICAgICAgICAgXX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsodmFsKSA9PiB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKGluZGV4LCB7XG4gICAgICAgICAgICAgICAgLi4ubmVzdGVkUXVlcnksXG4gICAgICAgICAgICAgICAgdmVjdG9yTWF0Y2hlc1R5cGU6IHZhbC52YWx1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEF1dG9TaXplSW5wdXRcbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnZlY3Rvck1hdGNoSW5wdXR9XG4gICAgICAgICAgICBtaW5XaWR0aD17MjB9XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU9e25lc3RlZFF1ZXJ5LnZlY3Rvck1hdGNoZXN9XG4gICAgICAgICAgICBvbkNvbW1pdENoYW5nZT17KGV2dCkgPT4ge1xuICAgICAgICAgICAgICBvbkNoYW5nZShpbmRleCwge1xuICAgICAgICAgICAgICAgIC4uLm5lc3RlZFF1ZXJ5LFxuICAgICAgICAgICAgICAgIHZlY3Rvck1hdGNoZXM6IGV2dC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHZlY3Rvck1hdGNoZXNUeXBlOiBuZXN0ZWRRdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSB8fCAnb24nLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxGbGV4SXRlbSBncm93PXsxfSAvPlxuICAgICAgICA8SWNvbkJ1dHRvbiBuYW1lPVwidGltZXNcIiBzaXplPVwic21cIiBvbkNsaWNrPXsoKSA9PiBvblJlbW92ZShpbmRleCl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm9keX0+XG4gICAgICAgIDxFZGl0b3JSb3dzPlxuICAgICAgICAgIDxQcm9tUXVlcnlCdWlsZGVyXG4gICAgICAgICAgICBxdWVyeT17bmVzdGVkUXVlcnkucXVlcnl9XG4gICAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgICAgbmVzdGVkPXt0cnVlfVxuICAgICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsodXBkYXRlKSA9PiB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKGluZGV4LCB7IC4uLm5lc3RlZFF1ZXJ5LCBxdWVyeTogdXBkYXRlIH0pO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRvclJvd3M+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn0pO1xuXG5jb25zdCBvcGVyYXRvcnMgPSBiaW5hcnlTY2FsYXJEZWZzLm1hcCgoZGVmKSA9PiAoeyBsYWJlbDogZGVmLnNpZ24sIHZhbHVlOiBkZWYuc2lnbiB9KSk7XG5cbk5lc3RlZFF1ZXJ5LmRpc3BsYXlOYW1lID0gJ05lc3RlZFF1ZXJ5JztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY2FyZDogY3NzKHtcbiAgICAgIGxhYmVsOiAnY2FyZCcsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygwLjUpLFxuICAgIH0pLFxuICAgIGhlYWRlcjogY3NzKHtcbiAgICAgIGxhYmVsOiAnaGVhZGVyJyxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMC41LCAwLjUsIDAuNSwgMSksXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICB9KSxcbiAgICBuYW1lOiBjc3Moe1xuICAgICAgbGFiZWw6ICduYW1lJyxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH0pLFxuICAgIGJvZHk6IGNzcyh7XG4gICAgICBsYWJlbDogJ2JvZHknLFxuICAgICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgfSksXG4gICAgdmVjdG9yTWF0Y2hJbnB1dDogY3NzKHtcbiAgICAgIGxhYmVsOiAndmVjdG9yTWF0Y2hJbnB1dCcsXG4gICAgICBtYXJnaW5MZWZ0OiAtMSxcbiAgICB9KSxcbiAgICB2ZWN0b3JNYXRjaFdyYXBwZXI6IGNzcyh7XG4gICAgICBsYWJlbDogJ3ZlY3Rvck1hdGNoV3JhcHBlcicsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5LCBQcm9tVmlzdWFsUXVlcnlCaW5hcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IE5lc3RlZFF1ZXJ5IH0gZnJvbSAnLi9OZXN0ZWRRdWVyeSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5O1xuICBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZTtcbiAgb25DaGFuZ2U6IChxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5KSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTmVzdGVkUXVlcnlMaXN0KHsgcXVlcnksIGRhdGFzb3VyY2UsIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH06IFByb3BzKSB7XG4gIGNvbnN0IG5lc3RlZFF1ZXJpZXMgPSBxdWVyeS5iaW5hcnlRdWVyaWVzID8/IFtdO1xuXG4gIGNvbnN0IG9uTmVzdGVkUXVlcnlVcGRhdGUgPSAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBQcm9tVmlzdWFsUXVlcnlCaW5hcnkpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkTGlzdCA9IFsuLi5uZXN0ZWRRdWVyaWVzXTtcbiAgICB1cGRhdGVkTGlzdC5zcGxpY2UoaW5kZXgsIDEsIHVwZGF0ZSk7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgYmluYXJ5UXVlcmllczogdXBkYXRlZExpc3QgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25SZW1vdmUgPSAoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWRMaXN0ID0gWy4uLm5lc3RlZFF1ZXJpZXMuc2xpY2UoMCwgaW5kZXgpLCAuLi5uZXN0ZWRRdWVyaWVzLnNsaWNlKGluZGV4ICsgMSldO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGJpbmFyeVF1ZXJpZXM6IHVwZGF0ZWRMaXN0IH0pO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPFN0YWNrIGRpcmVjdGlvbj1cImNvbHVtblwiIGdhcD17MX0+XG4gICAgICB7bmVzdGVkUXVlcmllcy5tYXAoKG5lc3RlZFF1ZXJ5LCBpbmRleCkgPT4gKFxuICAgICAgICA8TmVzdGVkUXVlcnlcbiAgICAgICAgICBrZXk9e2luZGV4LnRvU3RyaW5nKCl9XG4gICAgICAgICAgbmVzdGVkUXVlcnk9e25lc3RlZFF1ZXJ5fVxuICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICBvbkNoYW5nZT17b25OZXN0ZWRRdWVyeVVwZGF0ZX1cbiAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgIG9uUmVtb3ZlPXtvblJlbW92ZX1cbiAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAvPlxuICAgICAgKSl9XG4gICAgPC9TdGFjaz5cbiAgKTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgUGFuZWxEYXRhLCBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEVkaXRvclJvdyB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBnZXRNZXRhZGF0YVN0cmluZyB9IGZyb20gJy4uLy4uL2xhbmd1YWdlX3Byb3ZpZGVyJztcbmltcG9ydCB7IHByb21RdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vUHJvbVF1ZXJ5TW9kZWxsZXInO1xuaW1wb3J0IHsgTGFiZWxGaWx0ZXJzIH0gZnJvbSAnLi4vc2hhcmVkL0xhYmVsRmlsdGVycyc7XG5pbXBvcnQgeyBPcGVyYXRpb25MaXN0IH0gZnJvbSAnLi4vc2hhcmVkL09wZXJhdGlvbkxpc3QnO1xuaW1wb3J0IHsgT3BlcmF0aW9uc0VkaXRvclJvdyB9IGZyb20gJy4uL3NoYXJlZC9PcGVyYXRpb25zRWRpdG9yUm93JztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgTWV0cmljU2VsZWN0IH0gZnJvbSAnLi9NZXRyaWNTZWxlY3QnO1xuaW1wb3J0IHsgTmVzdGVkUXVlcnlMaXN0IH0gZnJvbSAnLi9OZXN0ZWRRdWVyeUxpc3QnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5QnVpbGRlckhpbnRzIH0gZnJvbSAnLi9Qcm9tUXVlcnlCdWlsZGVySGludHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IFByb21WaXN1YWxRdWVyeTtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG4gIG9uQ2hhbmdlOiAodXBkYXRlOiBQcm9tVmlzdWFsUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIG5lc3RlZD86IGJvb2xlYW47XG4gIGRhdGE/OiBQYW5lbERhdGE7XG59XG5cbmV4cG9ydCBjb25zdCBQcm9tUXVlcnlCdWlsZGVyID0gUmVhY3QubWVtbzxQcm9wcz4oKHsgZGF0YXNvdXJjZSwgcXVlcnksIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5LCBkYXRhIH0pID0+IHtcbiAgY29uc3Qgb25DaGFuZ2VMYWJlbHMgPSAobGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdKSA9PiB7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgbGFiZWxzIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXAgbWV0cmljIG1ldGFkYXRhIHRvIFNlbGVjdGFibGVWYWx1ZSBmb3IgU2VsZWN0IGNvbXBvbmVudCBhbmQgYWxzbyBhZGRzIGRlZmluZWQgdGVtcGxhdGUgdmFyaWFibGVzIHRvIHRoZSBsaXN0LlxuICAgKi9cbiAgY29uc3Qgd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKG9wdGlvbnNQcm9taXNlOiBQcm9taXNlPEFycmF5PHsgdmFsdWU6IHN0cmluZzsgZGVzY3JpcHRpb24/OiBzdHJpbmcgfT4+KTogUHJvbWlzZTxTZWxlY3RhYmxlVmFsdWVbXT4gPT4ge1xuICAgICAgY29uc3QgdmFyaWFibGVzID0gZGF0YXNvdXJjZS5nZXRWYXJpYWJsZXMoKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBvcHRpb25zUHJvbWlzZTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC4uLnZhcmlhYmxlcy5tYXAoKHZhbHVlKSA9PiAoeyBsYWJlbDogdmFsdWUsIHZhbHVlIH0pKSxcbiAgICAgICAgLi4ub3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gKHsgbGFiZWw6IG9wdGlvbi52YWx1ZSwgdmFsdWU6IG9wdGlvbi52YWx1ZSwgdGl0bGU6IG9wdGlvbi5kZXNjcmlwdGlvbiB9KSksXG4gICAgICBdO1xuICAgIH0sXG4gICAgW2RhdGFzb3VyY2VdXG4gICk7XG5cbiAgY29uc3Qgb25HZXRMYWJlbE5hbWVzID0gYXN5bmMgKGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPik6IFByb21pc2U8QXJyYXk8eyB2YWx1ZTogc3RyaW5nIH0+PiA9PiB7XG4gICAgLy8gSWYgbm8gbWV0cmljIHdlIG5lZWQgdG8gdXNlIGEgZGlmZmVyZW50IG1ldGhvZFxuICAgIGlmICghcXVlcnkubWV0cmljKSB7XG4gICAgICAvLyBUb2RvIGFkZCBjYWNoaW5nIGJ1dCBpbnNpZGUgbGFuZ3VhZ2UgcHJvdmlkZXIhXG4gICAgICBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hMYWJlbHMoKTtcbiAgICAgIHJldHVybiBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZ2V0TGFiZWxLZXlzKCkubWFwKChrKSA9PiAoeyB2YWx1ZTogayB9KSk7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxzVG9Db25zaWRlciA9IHF1ZXJ5LmxhYmVscy5maWx0ZXIoKHgpID0+IHggIT09IGZvckxhYmVsKTtcbiAgICBsYWJlbHNUb0NvbnNpZGVyLnB1c2goeyBsYWJlbDogJ19fbmFtZV9fJywgb3A6ICc9JywgdmFsdWU6IHF1ZXJ5Lm1ldHJpYyB9KTtcbiAgICBjb25zdCBleHByID0gcHJvbVF1ZXJ5TW9kZWxsZXIucmVuZGVyTGFiZWxzKGxhYmVsc1RvQ29uc2lkZXIpO1xuICAgIGNvbnN0IGxhYmVsc0luZGV4ID0gYXdhaXQgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzTGFiZWxzKGV4cHIpO1xuXG4gICAgLy8gZmlsdGVyIG91dCBhbHJlYWR5IHVzZWQgbGFiZWxzXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxhYmVsc0luZGV4KVxuICAgICAgLmZpbHRlcigobGFiZWxOYW1lKSA9PiAhbGFiZWxzVG9Db25zaWRlci5maW5kKChmaWx0ZXIpID0+IGZpbHRlci5sYWJlbCA9PT0gbGFiZWxOYW1lKSlcbiAgICAgIC5tYXAoKGspID0+ICh7IHZhbHVlOiBrIH0pKTtcbiAgfTtcblxuICBjb25zdCBvbkdldExhYmVsVmFsdWVzID0gYXN5bmMgKGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPikgPT4ge1xuICAgIGlmICghZm9yTGFiZWwubGFiZWwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBJZiBubyBtZXRyaWMgd2UgbmVlZCB0byB1c2UgYSBkaWZmZXJlbnQgbWV0aG9kXG4gICAgaWYgKCFxdWVyeS5tZXRyaWMpIHtcbiAgICAgIHJldHVybiAoYXdhaXQgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsVmFsdWVzKGZvckxhYmVsLmxhYmVsKSkubWFwKCh2KSA9PiAoeyB2YWx1ZTogdiB9KSk7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxzVG9Db25zaWRlciA9IHF1ZXJ5LmxhYmVscy5maWx0ZXIoKHgpID0+IHggIT09IGZvckxhYmVsKTtcbiAgICBsYWJlbHNUb0NvbnNpZGVyLnB1c2goeyBsYWJlbDogJ19fbmFtZV9fJywgb3A6ICc9JywgdmFsdWU6IHF1ZXJ5Lm1ldHJpYyB9KTtcbiAgICBjb25zdCBleHByID0gcHJvbVF1ZXJ5TW9kZWxsZXIucmVuZGVyTGFiZWxzKGxhYmVsc1RvQ29uc2lkZXIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllc0xhYmVscyhleHByKTtcbiAgICBjb25zdCBmb3JMYWJlbEludGVycG9sYXRlZCA9IGRhdGFzb3VyY2UuaW50ZXJwb2xhdGVTdHJpbmcoZm9yTGFiZWwubGFiZWwpO1xuICAgIHJldHVybiByZXN1bHRbZm9yTGFiZWxJbnRlcnBvbGF0ZWRdLm1hcCgodikgPT4gKHsgdmFsdWU6IHYgfSkpID8/IFtdO1xuICB9O1xuXG4gIGNvbnN0IG9uR2V0TWV0cmljcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zKGdldE1ldHJpY3MoZGF0YXNvdXJjZSwgcXVlcnkpKTtcbiAgfSwgW2RhdGFzb3VyY2UsIHF1ZXJ5LCB3aXRoVGVtcGxhdGVWYXJpYWJsZU9wdGlvbnNdKTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8RWRpdG9yUm93PlxuICAgICAgICA8TWV0cmljU2VsZWN0IHF1ZXJ5PXtxdWVyeX0gb25DaGFuZ2U9e29uQ2hhbmdlfSBvbkdldE1ldHJpY3M9e29uR2V0TWV0cmljc30gLz5cbiAgICAgICAgPExhYmVsRmlsdGVyc1xuICAgICAgICAgIGxhYmVsc0ZpbHRlcnM9e3F1ZXJ5LmxhYmVsc31cbiAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VMYWJlbHN9XG4gICAgICAgICAgb25HZXRMYWJlbE5hbWVzPXsoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PlxuICAgICAgICAgICAgd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zKG9uR2V0TGFiZWxOYW1lcyhmb3JMYWJlbCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIG9uR2V0TGFiZWxWYWx1ZXM9eyhmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+XG4gICAgICAgICAgICB3aXRoVGVtcGxhdGVWYXJpYWJsZU9wdGlvbnMob25HZXRMYWJlbFZhbHVlcyhmb3JMYWJlbCkpXG4gICAgICAgICAgfVxuICAgICAgICAvPlxuICAgICAgPC9FZGl0b3JSb3c+XG4gICAgICA8T3BlcmF0aW9uc0VkaXRvclJvdz5cbiAgICAgICAgPE9wZXJhdGlvbkxpc3Q8UHJvbVZpc3VhbFF1ZXJ5PlxuICAgICAgICAgIHF1ZXJ5TW9kZWxsZXI9e3Byb21RdWVyeU1vZGVsbGVyfVxuICAgICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2UgYXMgRGF0YVNvdXJjZUFwaX1cbiAgICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgIC8+XG4gICAgICAgIDxQcm9tUXVlcnlCdWlsZGVySGludHMgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX0gcXVlcnk9e3F1ZXJ5fSBvbkNoYW5nZT17b25DaGFuZ2V9IGRhdGE9e2RhdGF9IC8+XG4gICAgICA8L09wZXJhdGlvbnNFZGl0b3JSb3c+XG4gICAgICB7cXVlcnkuYmluYXJ5UXVlcmllcyAmJiBxdWVyeS5iaW5hcnlRdWVyaWVzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICA8TmVzdGVkUXVlcnlMaXN0IHF1ZXJ5PXtxdWVyeX0gZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX0gb25DaGFuZ2U9e29uQ2hhbmdlfSBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fSAvPlxuICAgICAgKX1cbiAgICA8Lz5cbiAgKTtcbn0pO1xuXG4vKipcbiAqIFJldHVybnMgbGlzdCBvZiBtZXRyaWNzLCBlaXRoZXIgYWxsIG9yIGZpbHRlcmVkIGJ5IHF1ZXJ5IHBhcmFtLiBJdCBhbHNvIGFkZHMgZGVzY3JpcHRpb24gc3RyaW5nIHRvIGVhY2ggbWV0cmljIGlmIGl0XG4gKiBleGlzdHMuXG4gKiBAcGFyYW0gZGF0YXNvdXJjZVxuICogQHBhcmFtIHF1ZXJ5XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldE1ldHJpY3MoXG4gIGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlLFxuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5XG4pOiBQcm9taXNlPEFycmF5PHsgdmFsdWU6IHN0cmluZzsgZGVzY3JpcHRpb24/OiBzdHJpbmcgfT4+IHtcbiAgLy8gTWFrZXMgc3VyZSB3ZSBsb2FkZWQgdGhlIG1ldGFkYXRhIGZvciBtZXRyaWNzLiBVc3VhbGx5IHRoaXMgaXMgZG9uZSBpbiB0aGUgc3RhcnQoKSBtZXRob2Qgb2YgdGhlIHByb3ZpZGVyIGJ1dCB3ZVxuICAvLyBkb24ndCB1c2UgaXQgd2l0aCB0aGUgdmlzdWFsIGJ1aWxkZXIgYW5kIHRoZXJlIGlzIG5vIG5lZWQgdG8gcnVuIGFsbCB0aGUgc3RhcnQoKSBzZXR1cCBhbnl3YXkuXG4gIGlmICghZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLm1ldHJpY3NNZXRhZGF0YSkge1xuICAgIGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5sb2FkTWV0cmljc01ldGFkYXRhKCk7XG4gIH1cblxuICBsZXQgbWV0cmljcztcbiAgaWYgKHF1ZXJ5LmxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZXhwciA9IHByb21RdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyhxdWVyeS5sYWJlbHMpO1xuICAgIG1ldHJpY3MgPSAoYXdhaXQgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmdldFNlcmllcyhleHByLCB0cnVlKSlbJ19fbmFtZV9fJ10gPz8gW107XG4gIH0gZWxzZSB7XG4gICAgbWV0cmljcyA9IChhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZ2V0TGFiZWxWYWx1ZXMoJ19fbmFtZV9fJykpID8/IFtdO1xuICB9XG5cbiAgcmV0dXJuIG1ldHJpY3MubWFwKChtKSA9PiAoe1xuICAgIHZhbHVlOiBtLFxuICAgIGRlc2NyaXB0aW9uOiBnZXRNZXRhZGF0YVN0cmluZyhtLCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIubWV0cmljc01ldGFkYXRhISksXG4gIH0pKTtcbn1cblxuUHJvbVF1ZXJ5QnVpbGRlci5kaXNwbGF5TmFtZSA9ICdQcm9tUXVlcnlCdWlsZGVyJztcbiIsImltcG9ydCB7IGNyZWF0ZVNsaWNlLCBQYXlsb2FkQWN0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWR1Y2VyIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBQYW5lbERhdGEgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuLi8uLi9kYXRhc291cmNlJztcbmltcG9ydCB7IFByb21RdWVyeSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IHByb21RdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vUHJvbVF1ZXJ5TW9kZWxsZXInO1xuaW1wb3J0IHsgYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcgfSBmcm9tICcuLi9wYXJzaW5nJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgUHJvbVF1ZXJ5QnVpbGRlciB9IGZyb20gJy4vUHJvbVF1ZXJ5QnVpbGRlcic7XG5pbXBvcnQgeyBRdWVyeVByZXZpZXcgfSBmcm9tICcuL1F1ZXJ5UHJldmlldyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogUHJvbVF1ZXJ5O1xuICBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZTtcbiAgb25DaGFuZ2U6ICh1cGRhdGU6IFByb21RdWVyeSkgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbiAgZGF0YT86IFBhbmVsRGF0YTtcbiAgc2hvd1Jhd1F1ZXJ5PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZSB7XG4gIHZpc1F1ZXJ5PzogUHJvbVZpc3VhbFF1ZXJ5O1xuICBleHByOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaXMgaGVyZSBqdXN0IHRvIGNvbnRhaW4gdGhlIHRyYW5zbGF0aW9uIGxvZ2ljIGJldHdlZW4gc3RyaW5nIHF1ZXJ5IGFuZCB0aGUgdmlzdWFsIHF1ZXJ5IGJ1aWxkZXIgbW9kZWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQcm9tUXVlcnlCdWlsZGVyQ29udGFpbmVyKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IHF1ZXJ5LCBvbkNoYW5nZSwgb25SdW5RdWVyeSwgZGF0YXNvdXJjZSwgZGF0YSwgc2hvd1Jhd1F1ZXJ5IH0gPSBwcm9wcztcbiAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSB1c2VSZWR1Y2VyKHN0YXRlU2xpY2UucmVkdWNlciwgeyBleHByOiBxdWVyeS5leHByIH0pO1xuXG4gIC8vIE9ubHkgcmVidWlsZCB2aXN1YWwgcXVlcnkgaWYgZXhwciBjaGFuZ2VzIGZyb20gb3V0c2lkZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGRpc3BhdGNoKGV4cHJDaGFuZ2VkKHF1ZXJ5LmV4cHIpKTtcbiAgfSwgW3F1ZXJ5LmV4cHJdKTtcblxuICBjb25zdCBvblZpc1F1ZXJ5Q2hhbmdlID0gKHZpc1F1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkpID0+IHtcbiAgICBjb25zdCBleHByID0gcHJvbVF1ZXJ5TW9kZWxsZXIucmVuZGVyUXVlcnkodmlzUXVlcnkpO1xuICAgIGRpc3BhdGNoKHZpc3VhbFF1ZXJ5Q2hhbmdlKHsgdmlzUXVlcnksIGV4cHIgfSkpO1xuICAgIG9uQ2hhbmdlKHsgLi4ucHJvcHMucXVlcnksIGV4cHI6IGV4cHIgfSk7XG4gIH07XG5cbiAgaWYgKCFzdGF0ZS52aXNRdWVyeSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPFByb21RdWVyeUJ1aWxkZXJcbiAgICAgICAgcXVlcnk9e3N0YXRlLnZpc1F1ZXJ5fVxuICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICBvbkNoYW5nZT17b25WaXNRdWVyeUNoYW5nZX1cbiAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgIC8+XG4gICAgICB7c2hvd1Jhd1F1ZXJ5ICYmIDxRdWVyeVByZXZpZXcgcXVlcnk9e3F1ZXJ5LmV4cHJ9IC8+fVxuICAgIDwvPlxuICApO1xufVxuXG5jb25zdCBzdGF0ZVNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICBuYW1lOiAncHJvbS1idWlsZGVyLWNvbnRhaW5lcicsXG4gIGluaXRpYWxTdGF0ZTogeyBleHByOiAnJyB9IGFzIFN0YXRlLFxuICByZWR1Y2Vyczoge1xuICAgIHZpc3VhbFF1ZXJ5Q2hhbmdlOiAoc3RhdGUsIGFjdGlvbjogUGF5bG9hZEFjdGlvbjx7IHZpc1F1ZXJ5OiBQcm9tVmlzdWFsUXVlcnk7IGV4cHI6IHN0cmluZyB9PikgPT4ge1xuICAgICAgc3RhdGUuZXhwciA9IGFjdGlvbi5wYXlsb2FkLmV4cHI7XG4gICAgICBzdGF0ZS52aXNRdWVyeSA9IGFjdGlvbi5wYXlsb2FkLnZpc1F1ZXJ5O1xuICAgIH0sXG4gICAgZXhwckNoYW5nZWQ6IChzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPHN0cmluZz4pID0+IHtcbiAgICAgIGlmICghc3RhdGUudmlzUXVlcnkgfHwgc3RhdGUuZXhwciAhPT0gYWN0aW9uLnBheWxvYWQpIHtcbiAgICAgICAgc3RhdGUuZXhwciA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgc3RhdGUudmlzUXVlcnkgPSBwYXJzZVJlc3VsdC5xdWVyeTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxufSk7XG5cbmNvbnN0IHsgdmlzdWFsUXVlcnlDaGFuZ2UsIGV4cHJDaGFuZ2VkIH0gPSBzdGF0ZVNsaWNlLmFjdGlvbnM7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5cbmltcG9ydCBwcm9tcWxHcmFtbWFyIGZyb20gJy4uLy4uL3Byb21xbCc7XG5pbXBvcnQgeyBwcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi4vcGFyc2luZyc7XG5pbXBvcnQgeyBPcGVyYXRpb25FeHBsYWluZWRCb3ggfSBmcm9tICcuLi9zaGFyZWQvT3BlcmF0aW9uRXhwbGFpbmVkQm94JztcbmltcG9ydCB7IE9wZXJhdGlvbkxpc3RFeHBsYWluZWQgfSBmcm9tICcuLi9zaGFyZWQvT3BlcmF0aW9uTGlzdEV4cGxhaW5lZCc7XG5pbXBvcnQgeyBSYXdRdWVyeSB9IGZyb20gJy4uL3NoYXJlZC9SYXdRdWVyeSc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgUHJvbVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IHF1ZXJ5IH0pID0+IHtcbiAgY29uc3QgdmlzUXVlcnkgPSBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyhxdWVyeSB8fCAnJykucXVlcnk7XG4gIGNvbnN0IGxhbmcgPSB7IGdyYW1tYXI6IHByb21xbEdyYW1tYXIsIG5hbWU6ICdwcm9tcWwnIH07XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZ2FwPXswLjV9IGRpcmVjdGlvbj1cImNvbHVtblwiPlxuICAgICAgPE9wZXJhdGlvbkV4cGxhaW5lZEJveD5cbiAgICAgICAgPFJhd1F1ZXJ5IHF1ZXJ5PXtxdWVyeX0gbGFuZz17bGFuZ30gLz5cbiAgICAgIDwvT3BlcmF0aW9uRXhwbGFpbmVkQm94PlxuICAgICAgPE9wZXJhdGlvbkV4cGxhaW5lZEJveFxuICAgICAgICBzdGVwTnVtYmVyPXsxfVxuICAgICAgICB0aXRsZT17PFJhd1F1ZXJ5IHF1ZXJ5PXtgJHt2aXNRdWVyeS5tZXRyaWN9ICR7cHJvbVF1ZXJ5TW9kZWxsZXIucmVuZGVyTGFiZWxzKHZpc1F1ZXJ5LmxhYmVscyl9YH0gbGFuZz17bGFuZ30gLz59XG4gICAgICA+XG4gICAgICAgIEZldGNoIGFsbCBzZXJpZXMgbWF0Y2hpbmcgbWV0cmljIG5hbWUgYW5kIGxhYmVsIGZpbHRlcnMuXG4gICAgICA8L09wZXJhdGlvbkV4cGxhaW5lZEJveD5cbiAgICAgIDxPcGVyYXRpb25MaXN0RXhwbGFpbmVkPFByb21WaXN1YWxRdWVyeT5cbiAgICAgICAgc3RlcE51bWJlcj17Mn1cbiAgICAgICAgcXVlcnlNb2RlbGxlcj17cHJvbVF1ZXJ5TW9kZWxsZXJ9XG4gICAgICAgIHF1ZXJ5PXt2aXNRdWVyeX1cbiAgICAgICAgbGFuZz17bGFuZ31cbiAgICAgIC8+XG4gICAgPC9TdGFjaz5cbiAgKTtcbn0pO1xuXG5Qcm9tUXVlcnlCdWlsZGVyRXhwbGFpbmVkLmRpc3BsYXlOYW1lID0gJ1Byb21RdWVyeUJ1aWxkZXJFeHBsYWluZWQnO1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyLCBQYW5lbERhdGEsIFF1ZXJ5SGludCB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgQnV0dG9uLCBUb29sdGlwLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgcHJvbVF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9Qcm9tUXVlcnlNb2RlbGxlcic7XG5pbXBvcnQgeyBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyB9IGZyb20gJy4uL3BhcnNpbmcnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IFByb21WaXN1YWxRdWVyeTtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG4gIG9uQ2hhbmdlOiAodXBkYXRlOiBQcm9tVmlzdWFsUXVlcnkpID0+IHZvaWQ7XG4gIGRhdGE/OiBQYW5lbERhdGE7XG59XG5cbmV4cG9ydCBjb25zdCBQcm9tUXVlcnlCdWlsZGVySGludHMgPSBSZWFjdC5tZW1vPFByb3BzPigoeyBkYXRhc291cmNlLCBxdWVyeSwgb25DaGFuZ2UsIGRhdGEgfSkgPT4ge1xuICBjb25zdCBbaGludHMsIHNldEhpbnRzXSA9IHVzZVN0YXRlPFF1ZXJ5SGludFtdPihbXSk7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHByb21RdWVyeSA9IHsgZXhwcjogcHJvbVF1ZXJ5TW9kZWxsZXIucmVuZGVyUXVlcnkocXVlcnkpLCByZWZJZDogJycgfTtcbiAgICAvLyBGb3Igbm93IHNob3cgb25seSBhY3Rpb25hYmxlIGhpbnRzXG4gICAgY29uc3QgaGludHMgPSBkYXRhc291cmNlLmdldFF1ZXJ5SGludHMocHJvbVF1ZXJ5LCBkYXRhPy5zZXJpZXMgfHwgW10pLmZpbHRlcigoaGludCkgPT4gaGludC5maXg/LmFjdGlvbik7XG4gICAgc2V0SGludHMoaGludHMpO1xuICB9LCBbZGF0YXNvdXJjZSwgcXVlcnksIG9uQ2hhbmdlLCBkYXRhLCBzdHlsZXMuaGludF0pO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHtoaW50cy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb250YWluZXJ9PlxuICAgICAgICAgIHtoaW50cy5tYXAoKGhpbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIDxUb29sdGlwIGNvbnRlbnQ9e2Ake2hpbnQubGFiZWx9ICR7aGludC5maXg/LmxhYmVsfWB9IGtleT17aGludC50eXBlfT5cbiAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21RdWVyeSA9IHsgZXhwcjogcHJvbVF1ZXJ5TW9kZWxsZXIucmVuZGVyUXVlcnkocXVlcnkpLCByZWZJZDogJycgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UHJvbVF1ZXJ5ID0gZGF0YXNvdXJjZS5tb2RpZnlRdWVyeShwcm9tUXVlcnksIGhpbnQhLmZpeCEuYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlzdWFsUXVlcnkgPSBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyhuZXdQcm9tUXVlcnkuZXhwcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbkNoYW5nZSh2aXN1YWxRdWVyeS5xdWVyeSk7XG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgZmlsbD1cIm91dGxpbmVcIlxuICAgICAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmhpbnR9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgeydoaW50OiAnICsgaGludC5maXg/LmFjdGlvbj8udHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnICcpICsgJygpJ31cbiAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgPC9Ub29sdGlwPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvPlxuICApO1xufSk7XG5cblByb21RdWVyeUJ1aWxkZXJIaW50cy5kaXNwbGF5TmFtZSA9ICdQcm9tUXVlcnlCdWlsZGVySGludHMnO1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjb250YWluZXI6IGNzc2BcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBtYXJnaW4tYm90dG9tOiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBgLFxuICAgIGhpbnQ6IGNzc2BcbiAgICAgIG1hcmdpbi1yaWdodDogJHt0aGVtZS5zcGFjaW5nKDEpfTtcbiAgICBgLFxuICB9O1xufTtcbiIsImltcG9ydCBSZWFjdCwgeyBTeW50aGV0aWNFdmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgQ29yZUFwcCwgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JSb3csIEVkaXRvckZpZWxkLCBFZGl0b3JTd2l0Y2ggfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgQXV0b1NpemVJbnB1dCwgUmFkaW9CdXR0b25Hcm91cCwgU2VsZWN0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBnZXRRdWVyeVR5cGVDaGFuZ2VIYW5kbGVyLCBnZXRRdWVyeVR5cGVPcHRpb25zIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9Qcm9tRXhwbG9yZUV4dHJhRmllbGQnO1xuaW1wb3J0IHsgRk9STUFUX09QVElPTlMsIElOVEVSVkFMX0ZBQ1RPUl9PUFRJT05TIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9Qcm9tUXVlcnlFZGl0b3InO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5IH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgUXVlcnlPcHRpb25Hcm91cCB9IGZyb20gJy4uL3NoYXJlZC9RdWVyeU9wdGlvbkdyb3VwJztcblxuaW1wb3J0IHsgZ2V0TGVnZW5kTW9kZUxhYmVsLCBQcm9tUXVlcnlMZWdlbmRFZGl0b3IgfSBmcm9tICcuL1Byb21RdWVyeUxlZ2VuZEVkaXRvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVUlPcHRpb25zIHtcbiAgZXhlbXBsYXJzOiBib29sZWFuO1xuICB0eXBlOiBib29sZWFuO1xuICBmb3JtYXQ6IGJvb2xlYW47XG4gIG1pblN0ZXA6IGJvb2xlYW47XG4gIGxlZ2VuZDogYm9vbGVhbjtcbiAgcmVzb2x1dGlvbjogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBQcm9tUXVlcnk7XG4gIGFwcD86IENvcmVBcHA7XG4gIG9uQ2hhbmdlOiAodXBkYXRlOiBQcm9tUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBQcm9tUXVlcnlCdWlsZGVyT3B0aW9ucyA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IHF1ZXJ5LCBhcHAsIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0pID0+IHtcbiAgY29uc3Qgb25DaGFuZ2VGb3JtYXQgPSAodmFsdWU6IFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+KSA9PiB7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgZm9ybWF0OiB2YWx1ZS52YWx1ZSB9KTtcbiAgICBvblJ1blF1ZXJ5KCk7XG4gIH07XG5cbiAgY29uc3Qgb25DaGFuZ2VTdGVwID0gKGV2dDogUmVhY3QuRm9ybUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgaW50ZXJ2YWw6IGV2dC5jdXJyZW50VGFyZ2V0LnZhbHVlIH0pO1xuICAgIG9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICBjb25zdCBxdWVyeVR5cGVPcHRpb25zID0gZ2V0UXVlcnlUeXBlT3B0aW9ucyhhcHAgPT09IENvcmVBcHAuRXhwbG9yZSk7XG4gIGNvbnN0IG9uUXVlcnlUeXBlQ2hhbmdlID0gZ2V0UXVlcnlUeXBlQ2hhbmdlSGFuZGxlcihxdWVyeSwgb25DaGFuZ2UpO1xuXG4gIGNvbnN0IG9uRXhlbXBsYXJDaGFuZ2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgaXNFbmFibGVkID0gZXZlbnQuY3VycmVudFRhcmdldC5jaGVja2VkO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGV4ZW1wbGFyOiBpc0VuYWJsZWQgfSk7XG4gICAgb25SdW5RdWVyeSgpO1xuICB9O1xuXG4gIGNvbnN0IG9uSW50ZXJ2YWxGYWN0b3JDaGFuZ2UgPSAodmFsdWU6IFNlbGVjdGFibGVWYWx1ZTxudW1iZXI+KSA9PiB7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgaW50ZXJ2YWxGYWN0b3I6IHZhbHVlLnZhbHVlIH0pO1xuICAgIG9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICBjb25zdCBmb3JtYXRPcHRpb24gPSBGT1JNQVRfT1BUSU9OUy5maW5kKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSA9PT0gcXVlcnkuZm9ybWF0KSB8fCBGT1JNQVRfT1BUSU9OU1swXTtcbiAgY29uc3QgcXVlcnlUeXBlVmFsdWUgPSBnZXRRdWVyeVR5cGVWYWx1ZShxdWVyeSk7XG4gIGNvbnN0IHF1ZXJ5VHlwZUxhYmVsID0gcXVlcnlUeXBlT3B0aW9ucy5maW5kKCh4KSA9PiB4LnZhbHVlID09PSBxdWVyeVR5cGVWYWx1ZSkhLmxhYmVsO1xuXG4gIHJldHVybiAoXG4gICAgPEVkaXRvclJvdz5cbiAgICAgIDxRdWVyeU9wdGlvbkdyb3VwIHRpdGxlPVwiT3B0aW9uc1wiIGNvbGxhcHNlZEluZm89e2dldENvbGxhcHNlZEluZm8ocXVlcnksIGZvcm1hdE9wdGlvbi5sYWJlbCEsIHF1ZXJ5VHlwZUxhYmVsKX0+XG4gICAgICAgIDxQcm9tUXVlcnlMZWdlbmRFZGl0b3JcbiAgICAgICAgICBsZWdlbmRGb3JtYXQ9e3F1ZXJ5LmxlZ2VuZEZvcm1hdH1cbiAgICAgICAgICBvbkNoYW5nZT17KGxlZ2VuZEZvcm1hdCkgPT4gb25DaGFuZ2UoeyAuLi5xdWVyeSwgbGVnZW5kRm9ybWF0IH0pfVxuICAgICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgIC8+XG4gICAgICAgIDxFZGl0b3JGaWVsZFxuICAgICAgICAgIGxhYmVsPVwiTWluIHN0ZXBcIlxuICAgICAgICAgIHRvb2x0aXA9e1xuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgQW4gYWRkaXRpb25hbCBsb3dlciBsaW1pdCBmb3IgdGhlIHN0ZXAgcGFyYW1ldGVyIG9mIHRoZSBQcm9tZXRoZXVzIHF1ZXJ5IGFuZCBmb3IgdGhleycgJ31cbiAgICAgICAgICAgICAgPGNvZGU+JF9faW50ZXJ2YWw8L2NvZGU+IGFuZCA8Y29kZT4kX19yYXRlX2ludGVydmFsPC9jb2RlPiB2YXJpYWJsZXMuXG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgICB9XG4gICAgICAgID5cbiAgICAgICAgICA8QXV0b1NpemVJbnB1dFxuICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlNldCBsb3dlciBsaW1pdCBmb3IgdGhlIHN0ZXAgcGFyYW1ldGVyXCJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPXsnYXV0byd9XG4gICAgICAgICAgICBtaW5XaWR0aD17MTB9XG4gICAgICAgICAgICBvbkNvbW1pdENoYW5nZT17b25DaGFuZ2VTdGVwfVxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtxdWVyeS5pbnRlcnZhbH1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgICA8RWRpdG9yRmllbGQgbGFiZWw9XCJGb3JtYXRcIj5cbiAgICAgICAgICA8U2VsZWN0IHZhbHVlPXtmb3JtYXRPcHRpb259IGFsbG93Q3VzdG9tVmFsdWUgb25DaGFuZ2U9e29uQ2hhbmdlRm9ybWF0fSBvcHRpb25zPXtGT1JNQVRfT1BUSU9OU30gLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiVHlwZVwiPlxuICAgICAgICAgIDxSYWRpb0J1dHRvbkdyb3VwIG9wdGlvbnM9e3F1ZXJ5VHlwZU9wdGlvbnN9IHZhbHVlPXtxdWVyeVR5cGVWYWx1ZX0gb25DaGFuZ2U9e29uUXVlcnlUeXBlQ2hhbmdlfSAvPlxuICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgICB7c2hvdWxkU2hvd0V4ZW1wbGFyU3dpdGNoKHF1ZXJ5LCBhcHApICYmIChcbiAgICAgICAgICA8RWRpdG9yRmllbGQgbGFiZWw9XCJFeGVtcGxhcnNcIj5cbiAgICAgICAgICAgIDxFZGl0b3JTd2l0Y2ggdmFsdWU9e3F1ZXJ5LmV4ZW1wbGFyfSBvbkNoYW5nZT17b25FeGVtcGxhckNoYW5nZX0gLz5cbiAgICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgICApfVxuICAgICAgICB7cXVlcnkuaW50ZXJ2YWxGYWN0b3IgJiYgcXVlcnkuaW50ZXJ2YWxGYWN0b3IgPiAxICYmIChcbiAgICAgICAgICA8RWRpdG9yRmllbGQgbGFiZWw9XCJSZXNvbHV0aW9uXCI+XG4gICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJTZWxlY3QgcmVzb2x1dGlvblwiXG4gICAgICAgICAgICAgIGlzU2VhcmNoYWJsZT17ZmFsc2V9XG4gICAgICAgICAgICAgIG9wdGlvbnM9e0lOVEVSVkFMX0ZBQ1RPUl9PUFRJT05TfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17b25JbnRlcnZhbEZhY3RvckNoYW5nZX1cbiAgICAgICAgICAgICAgdmFsdWU9e0lOVEVSVkFMX0ZBQ1RPUl9PUFRJT05TLmZpbmQoKG9wdGlvbikgPT4gb3B0aW9uLnZhbHVlID09PSBxdWVyeS5pbnRlcnZhbEZhY3Rvcil9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgICAgICl9XG4gICAgICA8L1F1ZXJ5T3B0aW9uR3JvdXA+XG4gICAgPC9FZGl0b3JSb3c+XG4gICk7XG59KTtcblxuZnVuY3Rpb24gc2hvdWxkU2hvd0V4ZW1wbGFyU3dpdGNoKHF1ZXJ5OiBQcm9tUXVlcnksIGFwcD86IENvcmVBcHApIHtcbiAgaWYgKGFwcCA9PT0gQ29yZUFwcC5VbmlmaWVkQWxlcnRpbmcgfHwgIXF1ZXJ5LnJhbmdlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldFF1ZXJ5VHlwZVZhbHVlKHF1ZXJ5OiBQcm9tUXVlcnkpIHtcbiAgcmV0dXJuIHF1ZXJ5LnJhbmdlICYmIHF1ZXJ5Lmluc3RhbnQgPyAnYm90aCcgOiBxdWVyeS5pbnN0YW50ID8gJ2luc3RhbnQnIDogJ3JhbmdlJztcbn1cblxuZnVuY3Rpb24gZ2V0Q29sbGFwc2VkSW5mbyhxdWVyeTogUHJvbVF1ZXJ5LCBmb3JtYXRPcHRpb246IHN0cmluZywgcXVlcnlUeXBlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGl0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGl0ZW1zLnB1c2goYExlZ2VuZDogJHtnZXRMZWdlbmRNb2RlTGFiZWwocXVlcnkubGVnZW5kRm9ybWF0KX1gKTtcbiAgaXRlbXMucHVzaChgRm9ybWF0OiAke2Zvcm1hdE9wdGlvbn1gKTtcbiAgaXRlbXMucHVzaChgU3RlcDogJHtxdWVyeS5pbnRlcnZhbCA/PyAnYXV0byd9YCk7XG4gIGl0ZW1zLnB1c2goYFR5cGU6ICR7cXVlcnlUeXBlfWApO1xuXG4gIGlmIChxdWVyeS5leGVtcGxhcikge1xuICAgIGl0ZW1zLnB1c2goYEV4ZW1wbGFyczogdHJ1ZWApO1xuICB9XG5cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5Qcm9tUXVlcnlCdWlsZGVyT3B0aW9ucy5kaXNwbGF5TmFtZSA9ICdQcm9tUXVlcnlCdWlsZGVyT3B0aW9ucyc7XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgdGVzdElkcyB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvUHJvbVF1ZXJ5RWRpdG9yJztcbmltcG9ydCBQcm9tUXVlcnlGaWVsZCBmcm9tICcuLi8uLi9jb21wb25lbnRzL1Byb21RdWVyeUZpZWxkJztcbmltcG9ydCB7IFByb21RdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm9tUXVlcnlDb2RlRWRpdG9yKHtcbiAgcXVlcnksXG4gIGRhdGFzb3VyY2UsXG4gIHJhbmdlLFxuICBvblJ1blF1ZXJ5LFxuICBvbkNoYW5nZSxcbiAgZGF0YSxcbiAgYXBwLFxufTogUHJvbVF1ZXJ5RWRpdG9yUHJvcHMpIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgIDxQcm9tUXVlcnlGaWVsZFxuICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgIHJhbmdlPXtyYW5nZX1cbiAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICBoaXN0b3J5PXtbXX1cbiAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMuZWRpdG9yfVxuICAgICAgICBhcHA9e2FwcH1cbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgd3JhcHBlciBzdHlsaW5nIGNhbiBiZSByZW1vdmVkIGFmdGVyIHRoZSBvbGQgUHJvbVF1ZXJ5RWRpdG9yIGlzIHJlbW92ZWQuXG4gICAgLy8gVGhpcyBpcyByZW1vdmluZyBtYXJnaW4gYm90dG9tIG9uIHRoZSBvbGQgbGVnYWN5IGlubGluZSBmb3JtIHN0eWxlc1xuICAgIHdyYXBwZXI6IGNzc2BcbiAgICAgIC5nZi1mb3JtIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgIH1cbiAgICBgLFxuICB9O1xufTtcbiIsImltcG9ydCBSZWFjdCwgeyBTeW50aGV0aWNFdmVudCwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IENvcmVBcHAsIExvYWRpbmdTdGF0ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9ySGVhZGVyLCBFZGl0b3JSb3dzLCBGbGV4SXRlbSwgSW5saW5lU2VsZWN0LCBTcGFjZSB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyByZXBvcnRJbnRlcmFjdGlvbiB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgQnV0dG9uLCBDb25maXJtTW9kYWwgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFByb21RdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy90eXBlcyc7XG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBwcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi4vcGFyc2luZyc7XG5pbXBvcnQgeyBGZWVkYmFja0xpbmsgfSBmcm9tICcuLi9zaGFyZWQvRmVlZGJhY2tMaW5rJztcbmltcG9ydCB7IFF1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSB9IGZyb20gJy4uL3NoYXJlZC9RdWVyeUVkaXRvck1vZGVUb2dnbGUnO1xuaW1wb3J0IHsgUXVlcnlIZWFkZXJTd2l0Y2ggfSBmcm9tICcuLi9zaGFyZWQvUXVlcnlIZWFkZXJTd2l0Y2gnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IGNoYW5nZUVkaXRvck1vZGUsIGdldFF1ZXJ5V2l0aERlZmF1bHRzLCB1c2VSYXdRdWVyeSB9IGZyb20gJy4uL3N0YXRlJztcblxuaW1wb3J0IHsgUHJvbVF1ZXJ5QnVpbGRlckNvbnRhaW5lciB9IGZyb20gJy4vUHJvbVF1ZXJ5QnVpbGRlckNvbnRhaW5lcic7XG5pbXBvcnQgeyBQcm9tUXVlcnlCdWlsZGVyRXhwbGFpbmVkIH0gZnJvbSAnLi9Qcm9tUXVlcnlCdWlsZGVyRXhwbGFpbmVkJztcbmltcG9ydCB7IFByb21RdWVyeUJ1aWxkZXJPcHRpb25zIH0gZnJvbSAnLi9Qcm9tUXVlcnlCdWlsZGVyT3B0aW9ucyc7XG5pbXBvcnQgeyBQcm9tUXVlcnlDb2RlRWRpdG9yIH0gZnJvbSAnLi9Qcm9tUXVlcnlDb2RlRWRpdG9yJztcblxudHlwZSBQcm9wcyA9IFByb21RdWVyeUVkaXRvclByb3BzO1xuXG5leHBvcnQgY29uc3QgUHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3IgPSBSZWFjdC5tZW1vPFByb3BzPigocHJvcHMpID0+IHtcbiAgY29uc3QgeyBvbkNoYW5nZSwgb25SdW5RdWVyeSwgZGF0YSwgYXBwIH0gPSBwcm9wcztcbiAgY29uc3QgW3BhcnNlTW9kYWxPcGVuLCBzZXRQYXJzZU1vZGFsT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtkYXRhSXNTdGFsZSwgc2V0RGF0YUlzU3RhbGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IHF1ZXJ5ID0gZ2V0UXVlcnlXaXRoRGVmYXVsdHMocHJvcHMucXVlcnksIGFwcCk7XG4gIGNvbnN0IFtyYXdRdWVyeSwgc2V0UmF3UXVlcnldID0gdXNlUmF3UXVlcnkoKTtcbiAgLy8gVGhpcyBzaG91bGQgYmUgZmlsbGVkIGluIGZyb20gdGhlIGRlZmF1bHRzIGJ5IG5vdy5cbiAgY29uc3QgZWRpdG9yTW9kZSA9IHF1ZXJ5LmVkaXRvck1vZGUhO1xuXG4gIGNvbnN0IG9uRWRpdG9yTW9kZUNoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIChuZXdNZXRyaWNFZGl0b3JNb2RlOiBRdWVyeUVkaXRvck1vZGUpID0+IHtcbiAgICAgIHJlcG9ydEludGVyYWN0aW9uKCd1c2VyX2dyYWZhbmFfcHJvbWV0aGV1c19lZGl0b3JfbW9kZV9jbGlja2VkJywge1xuICAgICAgICBuZXdFZGl0b3I6IG5ld01ldHJpY0VkaXRvck1vZGUsXG4gICAgICAgIHByZXZpb3VzRWRpdG9yOiBxdWVyeS5lZGl0b3JNb2RlID8/ICcnLFxuICAgICAgICBuZXdRdWVyeTogIXF1ZXJ5LmV4cHIsXG4gICAgICAgIGFwcDogYXBwID8/ICcnLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZXdNZXRyaWNFZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyhxdWVyeS5leHByIHx8ICcnKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGVycm9ycywgZ2l2ZSB1c2VyIGEgY2hhbmNlIHRvIGRlY2lkZSBpZiB0aGV5IHdhbnQgdG8gZ28gdG8gYnVpbGRlciBhcyB0aGF0IGNhbiBsb29zZSBzb21lIGRhdGEuXG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIHNldFBhcnNlTW9kYWxPcGVuKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hhbmdlRWRpdG9yTW9kZShxdWVyeSwgbmV3TWV0cmljRWRpdG9yTW9kZSwgb25DaGFuZ2UpO1xuICAgIH0sXG4gICAgW29uQ2hhbmdlLCBxdWVyeSwgYXBwXVxuICApO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0RGF0YUlzU3RhbGUoZmFsc2UpO1xuICB9LCBbZGF0YV0pO1xuXG4gIGNvbnN0IG9uUXVlcnlQcmV2aWV3Q2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGlzRW5hYmxlZCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuY2hlY2tlZDtcbiAgICBzZXRSYXdRdWVyeShpc0VuYWJsZWQpO1xuICB9O1xuXG4gIGNvbnN0IG9uQ2hhbmdlSW50ZXJuYWwgPSAocXVlcnk6IFByb21RdWVyeSkgPT4ge1xuICAgIHNldERhdGFJc1N0YWxlKHRydWUpO1xuICAgIG9uQ2hhbmdlKHF1ZXJ5KTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8Q29uZmlybU1vZGFsXG4gICAgICAgIGlzT3Blbj17cGFyc2VNb2RhbE9wZW59XG4gICAgICAgIHRpdGxlPVwiUXVlcnkgcGFyc2luZ1wiXG4gICAgICAgIGJvZHk9XCJUaGVyZSB3ZXJlIGVycm9ycyB3aGlsZSB0cnlpbmcgdG8gcGFyc2UgdGhlIHF1ZXJ5LiBDb250aW51aW5nIHRvIHZpc3VhbCBidWlsZGVyIG1heSBsb29zZSBzb21lIHBhcnRzIG9mIHRoZSBxdWVyeS5cIlxuICAgICAgICBjb25maXJtVGV4dD1cIkNvbnRpbnVlXCJcbiAgICAgICAgb25Db25maXJtPXsoKSA9PiB7XG4gICAgICAgICAgY2hhbmdlRWRpdG9yTW9kZShxdWVyeSwgUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIsIG9uQ2hhbmdlKTtcbiAgICAgICAgICBzZXRQYXJzZU1vZGFsT3BlbihmYWxzZSk7XG4gICAgICAgIH19XG4gICAgICAgIG9uRGlzbWlzcz17KCkgPT4gc2V0UGFyc2VNb2RhbE9wZW4oZmFsc2UpfVxuICAgICAgLz5cbiAgICAgIDxFZGl0b3JIZWFkZXI+XG4gICAgICAgIDxJbmxpbmVTZWxlY3RcbiAgICAgICAgICB2YWx1ZT17bnVsbH1cbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIlF1ZXJ5IHBhdHRlcm5zXCJcbiAgICAgICAgICBhbGxvd0N1c3RvbVZhbHVlXG4gICAgICAgICAgb25DaGFuZ2U9eyh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE86IEJpdCBjb252b2x1dGVkIGFzIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHZpc3VhbFF1ZXJ5IG1vZGVsIGhlcmUuIE1heWJlIHdvdWxkIG1ha2Ugc2Vuc2UgdG9cbiAgICAgICAgICAgIC8vICBtb3ZlIGl0IGluc2lkZSB0aGUgZWRpdG9yP1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcocXVlcnkuZXhwciB8fCAnJyk7XG4gICAgICAgICAgICByZXN1bHQucXVlcnkub3BlcmF0aW9ucyA9IHZhbHVlPy5vcGVyYXRpb25zITtcbiAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgIGV4cHI6IHByb21RdWVyeU1vZGVsbGVyLnJlbmRlclF1ZXJ5KHJlc3VsdC5xdWVyeSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIG9wdGlvbnM9e3Byb21RdWVyeU1vZGVsbGVyLmdldFF1ZXJ5UGF0dGVybnMoKS5tYXAoKHgpID0+ICh7IGxhYmVsOiB4Lm5hbWUsIHZhbHVlOiB4IH0pKX1cbiAgICAgICAgLz5cblxuICAgICAgICB7ZWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIgJiYgKFxuICAgICAgICAgIDw+XG4gICAgICAgICAgICA8UXVlcnlIZWFkZXJTd2l0Y2ggbGFiZWw9XCJSYXcgcXVlcnlcIiB2YWx1ZT17cmF3UXVlcnl9IG9uQ2hhbmdlPXtvblF1ZXJ5UHJldmlld0NoYW5nZX0gLz5cbiAgICAgICAgICAgIDxGZWVkYmFja0xpbmsgZmVlZGJhY2tVcmw9XCJodHRwczovL2dpdGh1Yi5jb20vZ3JhZmFuYS9ncmFmYW5hL2Rpc2N1c3Npb25zLzQ3NjkzXCIgLz5cbiAgICAgICAgICA8Lz5cbiAgICAgICAgKX1cbiAgICAgICAgPEZsZXhJdGVtIGdyb3c9ezF9IC8+XG4gICAgICAgIHthcHAgIT09IENvcmVBcHAuRXhwbG9yZSAmJiAoXG4gICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgdmFyaWFudD17ZGF0YUlzU3RhbGUgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5J31cbiAgICAgICAgICAgIHNpemU9XCJzbVwiXG4gICAgICAgICAgICBvbkNsaWNrPXtvblJ1blF1ZXJ5fVxuICAgICAgICAgICAgaWNvbj17ZGF0YT8uc3RhdGUgPT09IExvYWRpbmdTdGF0ZS5Mb2FkaW5nID8gJ2ZhIGZhLXNwaW5uZXInIDogdW5kZWZpbmVkfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2RhdGE/LnN0YXRlID09PSBMb2FkaW5nU3RhdGUuTG9hZGluZ31cbiAgICAgICAgICA+XG4gICAgICAgICAgICBSdW4gcXVlcmllc1xuICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICApfVxuICAgICAgICA8UXVlcnlFZGl0b3JNb2RlVG9nZ2xlIG1vZGU9e2VkaXRvck1vZGV9IG9uQ2hhbmdlPXtvbkVkaXRvck1vZGVDaGFuZ2V9IC8+XG4gICAgICA8L0VkaXRvckhlYWRlcj5cbiAgICAgIDxTcGFjZSB2PXswLjV9IC8+XG4gICAgICA8RWRpdG9yUm93cz5cbiAgICAgICAge2VkaXRvck1vZGUgPT09IFF1ZXJ5RWRpdG9yTW9kZS5Db2RlICYmIDxQcm9tUXVlcnlDb2RlRWRpdG9yIHsuLi5wcm9wc30gLz59XG4gICAgICAgIHtlZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuQnVpbGRlciAmJiAoXG4gICAgICAgICAgPFByb21RdWVyeUJ1aWxkZXJDb250YWluZXJcbiAgICAgICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgICAgIGRhdGFzb3VyY2U9e3Byb3BzLmRhdGFzb3VyY2V9XG4gICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VJbnRlcm5hbH1cbiAgICAgICAgICAgIG9uUnVuUXVlcnk9e3Byb3BzLm9uUnVuUXVlcnl9XG4gICAgICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgICAgICAgc2hvd1Jhd1F1ZXJ5PXtyYXdRdWVyeX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgICB7ZWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW4gJiYgPFByb21RdWVyeUJ1aWxkZXJFeHBsYWluZWQgcXVlcnk9e3F1ZXJ5LmV4cHJ9IC8+fVxuICAgICAgICB7ZWRpdG9yTW9kZSAhPT0gUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW4gJiYgKFxuICAgICAgICAgIDxQcm9tUXVlcnlCdWlsZGVyT3B0aW9ucyBxdWVyeT17cXVlcnl9IGFwcD17cHJvcHMuYXBwfSBvbkNoYW5nZT17b25DaGFuZ2V9IG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9IC8+XG4gICAgICAgICl9XG4gICAgICA8L0VkaXRvclJvd3M+XG4gICAgPC8+XG4gICk7XG59KTtcblxuUHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3IuZGlzcGxheU5hbWUgPSAnUHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3InO1xuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JGaWVsZCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBTZWxlY3QsIEF1dG9TaXplSW5wdXQgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IExlZ2VuZEZvcm1hdE1vZGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBsZWdlbmRGb3JtYXQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgb25DaGFuZ2U6IChsZWdlbmRGb3JtYXQ6IHN0cmluZykgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbn1cblxuY29uc3QgbGVnZW5kTW9kZU9wdGlvbnMgPSBbXG4gIHtcbiAgICBsYWJlbDogJ0F1dG8nLFxuICAgIHZhbHVlOiBMZWdlbmRGb3JtYXRNb2RlLkF1dG8sXG4gICAgZGVzY3JpcHRpb246ICdPbmx5IGluY2x1ZGVzIHVuaXF1ZSBsYWJlbHMnLFxuICB9LFxuICB7IGxhYmVsOiAnVmVyYm9zZScsIHZhbHVlOiBMZWdlbmRGb3JtYXRNb2RlLlZlcmJvc2UsIGRlc2NyaXB0aW9uOiAnQWxsIGxhYmVsIG5hbWVzIGFuZCB2YWx1ZXMnIH0sXG4gIHsgbGFiZWw6ICdDdXN0b20nLCB2YWx1ZTogTGVnZW5kRm9ybWF0TW9kZS5DdXN0b20sIGRlc2NyaXB0aW9uOiAnUHJvdmlkZSBhIG5hbWluZyB0ZW1wbGF0ZScgfSxcbl07XG5cbi8qKlxuICogVGVzdHMgZm9yIHRoaXMgY29tcG9uZW50IGFyZSBvbiB0aGUgcGFyZW50IGxldmVsIChQcm9tUXVlcnlCdWlsZGVyT3B0aW9ucykuXG4gKi9cbmV4cG9ydCBjb25zdCBQcm9tUXVlcnlMZWdlbmRFZGl0b3IgPSBSZWFjdC5tZW1vPFByb3BzPigoeyBsZWdlbmRGb3JtYXQsIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0pID0+IHtcbiAgY29uc3QgbW9kZSA9IGdldExlZ2VuZE1vZGUobGVnZW5kRm9ybWF0KTtcbiAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWY8SFRNTElucHV0RWxlbWVudCB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IG9uTGVnZW5kRm9ybWF0Q2hhbmdlZCA9IChldnQ6IFJlYWN0LkZvcm1FdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGxldCBuZXdGb3JtYXQgPSBldnQuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICBpZiAobmV3Rm9ybWF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgbmV3Rm9ybWF0ID0gTGVnZW5kRm9ybWF0TW9kZS5BdXRvO1xuICAgIH1cblxuICAgIGlmIChuZXdGb3JtYXQgIT09IGxlZ2VuZEZvcm1hdCkge1xuICAgICAgb25DaGFuZ2UobmV3Rm9ybWF0KTtcbiAgICAgIG9uUnVuUXVlcnkoKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25MZWdlbmRNb2RlQ2hhbmdlZCA9ICh2YWx1ZTogU2VsZWN0YWJsZVZhbHVlPExlZ2VuZEZvcm1hdE1vZGU+KSA9PiB7XG4gICAgc3dpdGNoICh2YWx1ZS52YWx1ZSEpIHtcbiAgICAgIGNhc2UgTGVnZW5kRm9ybWF0TW9kZS5BdXRvOlxuICAgICAgICBvbkNoYW5nZShMZWdlbmRGb3JtYXRNb2RlLkF1dG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGVnZW5kRm9ybWF0TW9kZS5DdXN0b206XG4gICAgICAgIG9uQ2hhbmdlKCd7e2xhYmVsX25hbWV9fScpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpbnB1dFJlZi5jdXJyZW50Py5mb2N1cygpO1xuICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQ/LnNldFNlbGVjdGlvblJhbmdlKDIsIDEyLCAnZm9yd2FyZCcpO1xuICAgICAgICB9LCAxMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZWdlbmRGb3JtYXRNb2RlLlZlcmJvc2U6XG4gICAgICAgIG9uQ2hhbmdlKCcnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxFZGl0b3JGaWVsZFxuICAgICAgbGFiZWw9XCJMZWdlbmRcIlxuICAgICAgdG9vbHRpcD1cIlNlcmllcyBuYW1lIG92ZXJyaWRlIG9yIHRlbXBsYXRlLiBFeC4ge3tob3N0bmFtZX19IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBsYWJlbCB2YWx1ZSBmb3IgaG9zdG5hbWUuXCJcbiAgICA+XG4gICAgICA8PlxuICAgICAgICB7bW9kZSA9PT0gTGVnZW5kRm9ybWF0TW9kZS5DdXN0b20gJiYgKFxuICAgICAgICAgIDxBdXRvU2l6ZUlucHV0XG4gICAgICAgICAgICBpZD1cImxlZ2VuZEZvcm1hdFwiXG4gICAgICAgICAgICBtaW5XaWR0aD17MjJ9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cImF1dG9cIlxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtsZWdlbmRGb3JtYXR9XG4gICAgICAgICAgICBvbkNvbW1pdENoYW5nZT17b25MZWdlbmRGb3JtYXRDaGFuZ2VkfVxuICAgICAgICAgICAgcmVmPXtpbnB1dFJlZn1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgICB7bW9kZSAhPT0gTGVnZW5kRm9ybWF0TW9kZS5DdXN0b20gJiYgKFxuICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgIGlucHV0SWQ9XCJsZWdlbmQubW9kZVwiXG4gICAgICAgICAgICBpc1NlYXJjaGFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJTZWxlY3QgbGVnZW5kIG1vZGVcIlxuICAgICAgICAgICAgb3B0aW9ucz17bGVnZW5kTW9kZU9wdGlvbnN9XG4gICAgICAgICAgICB3aWR0aD17MjJ9XG4gICAgICAgICAgICBvbkNoYW5nZT17b25MZWdlbmRNb2RlQ2hhbmdlZH1cbiAgICAgICAgICAgIHZhbHVlPXtsZWdlbmRNb2RlT3B0aW9ucy5maW5kKCh4KSA9PiB4LnZhbHVlID09PSBtb2RlKX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC8+XG4gICAgPC9FZGl0b3JGaWVsZD5cbiAgKTtcbn0pO1xuXG5Qcm9tUXVlcnlMZWdlbmRFZGl0b3IuZGlzcGxheU5hbWUgPSAnUHJvbVF1ZXJ5TGVnZW5kRWRpdG9yJztcblxuZnVuY3Rpb24gZ2V0TGVnZW5kTW9kZShsZWdlbmRGb3JtYXQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAvLyBUaGlzIHNwZWNpYWwgdmFsdWUgbWVhbnMgdGhlIG5ldyBzbWFydCBtaW5pbWFsIHNlcmllcyBuYW1pbmdcbiAgaWYgKGxlZ2VuZEZvcm1hdCA9PT0gTGVnZW5kRm9ybWF0TW9kZS5BdXRvKSB7XG4gICAgcmV0dXJuIExlZ2VuZEZvcm1hdE1vZGUuQXV0bztcbiAgfVxuXG4gIC8vIE1pc3Npbmcgb3IgZW1wdHkgbGVnZW5kIGZvcm1hdCBpcyB0aGUgb2xkIHZlcmJvc2UgYmVoYXZpb3JcbiAgaWYgKGxlZ2VuZEZvcm1hdCA9PSBudWxsIHx8IGxlZ2VuZEZvcm1hdCA9PT0gJycpIHtcbiAgICByZXR1cm4gTGVnZW5kRm9ybWF0TW9kZS5WZXJib3NlO1xuICB9XG5cbiAgcmV0dXJuIExlZ2VuZEZvcm1hdE1vZGUuQ3VzdG9tO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVnZW5kTW9kZUxhYmVsKGxlZ2VuZEZvcm1hdDogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gIGNvbnN0IG1vZGUgPSBnZXRMZWdlbmRNb2RlKGxlZ2VuZEZvcm1hdCk7XG4gIGlmIChtb2RlICE9PSBMZWdlbmRGb3JtYXRNb2RlLkN1c3RvbSkge1xuICAgIHJldHVybiBsZWdlbmRNb2RlT3B0aW9ucy5maW5kKCh4KSA9PiB4LnZhbHVlID09PSBtb2RlKT8ubGFiZWw7XG4gIH1cbiAgcmV0dXJuIGxlZ2VuZEZvcm1hdDtcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEVkaXRvckZpZWxkLCBFZGl0b3JGaWVsZEdyb3VwLCBFZGl0b3JSb3cgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuXG5pbXBvcnQgcHJvbXFsR3JhbW1hciBmcm9tICcuLi8uLi9wcm9tcWwnO1xuaW1wb3J0IHsgUmF3UXVlcnkgfSBmcm9tICcuLi9zaGFyZWQvUmF3UXVlcnknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFF1ZXJ5UHJldmlldyh7IHF1ZXJ5IH06IFByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPEVkaXRvclJvdz5cbiAgICAgIDxFZGl0b3JGaWVsZEdyb3VwPlxuICAgICAgICA8RWRpdG9yRmllbGQgbGFiZWw9XCJSYXcgcXVlcnlcIj5cbiAgICAgICAgICA8UmF3UXVlcnkgcXVlcnk9e3F1ZXJ5fSBsYW5nPXt7IGdyYW1tYXI6IHByb21xbEdyYW1tYXIsIG5hbWU6ICdwcm9tcWwnIH19IC8+XG4gICAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgICA8L0VkaXRvckZpZWxkR3JvdXA+XG4gICAgPC9FZGl0b3JSb3c+XG4gICk7XG59XG4iLCJpbXBvcnQgeyBiaW5hcnlTY2FsYXJPcGVyYXRpb25zIH0gZnJvbSAnLi9iaW5hcnlTY2FsYXJPcGVyYXRpb25zJztcbmltcG9ydCB7IExhYmVsUGFyYW1FZGl0b3IgfSBmcm9tICcuL2NvbXBvbmVudHMvTGFiZWxQYXJhbUVkaXRvcic7XG5pbXBvcnQge1xuICBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gIGZ1bmN0aW9uUmVuZGVyZXJSaWdodCxcbiAgZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZSxcbiAgZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZixcbiAgcmFuZ2VSZW5kZXJlckxlZnRXaXRoUGFyYW1zLFxuICByYW5nZVJlbmRlcmVyUmlnaHRXaXRoUGFyYW1zLFxufSBmcm9tICcuL3NoYXJlZC9vcGVyYXRpb25VdGlscyc7XG5pbXBvcnQge1xuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgUXVlcnlXaXRoT3BlcmF0aW9ucyxcbiAgVmlzdWFsUXVlcnlNb2RlbGxlcixcbn0gZnJvbSAnLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbU9wZXJhdGlvbklkLCBQcm9tVmlzdWFsUXVlcnksIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25EZWZpbml0aW9ucygpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIGNvbnN0IGxpc3Q6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdID0gW1xuICAgIHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuSGlzdG9ncmFtUXVhbnRpbGUsXG4gICAgICBuYW1lOiAnSGlzdG9ncmFtIHF1YW50aWxlJyxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ1F1YW50aWxlJywgdHlwZTogJ251bWJlcicsIG9wdGlvbnM6IFswLjk5LCAwLjk1LCAwLjksIDAuNzUsIDAuNSwgMC4yNV0gfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMC45XSxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTGFiZWxSZXBsYWNlLFxuICAgICAgbmFtZTogJ0xhYmVsIHJlcGxhY2UnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHsgbmFtZTogJ0Rlc3RpbmF0aW9uIGxhYmVsJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBuYW1lOiAnUmVwbGFjZW1lbnQnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdTb3VyY2UgbGFiZWwnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdSZWdleCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICBdLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJywgJyQxJywgJycsICcoLiopJ10sXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlclJpZ2h0LFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkxuLFxuICAgICAgbmFtZTogJ0xuJyxcbiAgICAgIHBhcmFtczogW10sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbXSxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICB9LFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLkNoYW5nZXMpLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLlJhdGUsIHRydWUpLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLklyYXRlKSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5JbmNyZWFzZSwgdHJ1ZSksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuSWRlbHRhKSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5EZWx0YSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5Ib2x0V2ludGVycyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICBnZXRSYW5nZVZlY3RvclBhcmFtRGVmKCksXG4gICAgICAgIHsgbmFtZTogJ1Ntb290aGluZyBGYWN0b3InLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IG5hbWU6ICdUcmVuZCBGYWN0b3InLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJF9faW50ZXJ2YWwnLCAwLjUsIDAuNV0sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdyYW5nZSBmdW5jdGlvbicsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogcmFuZ2VSZW5kZXJlclJpZ2h0V2l0aFBhcmFtcyxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcixcbiAgICAgIGNoYW5nZVR5cGVIYW5kbGVyOiBvcGVyYXRpb25UeXBlQ2hhbmdlZEhhbmRsZXJGb3JSYW5nZUZ1bmN0aW9uLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUHJlZGljdExpbmVhcixcbiAgICAgIHBhcmFtczogW2dldFJhbmdlVmVjdG9yUGFyYW1EZWYoKSwgeyBuYW1lOiAnU2Vjb25kcyBmcm9tIG5vdycsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWyckX19pbnRlcnZhbCcsIDYwXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ3JhbmdlIGZ1bmN0aW9uJyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICAgIHJlbmRlcmVyOiByYW5nZVJlbmRlcmVyUmlnaHRXaXRoUGFyYW1zLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yLFxuICAgICAgY2hhbmdlVHlwZUhhbmRsZXI6IG9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24sXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5RdWFudGlsZU92ZXJUaW1lLFxuICAgICAgcGFyYW1zOiBbZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZigpLCB7IG5hbWU6ICdRdWFudGlsZScsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWyckX19pbnRlcnZhbCcsIDAuNV0sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdvdmVydGltZSBmdW5jdGlvbicsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogcmFuZ2VSZW5kZXJlckxlZnRXaXRoUGFyYW1zLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yLFxuICAgICAgY2hhbmdlVHlwZUhhbmRsZXI6IG9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24sXG4gICAgfSksXG4gICAgLi4uYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyxcbiAgICB7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLk5lc3RlZFF1ZXJ5LFxuICAgICAgbmFtZTogJ0JpbmFyeSBvcGVyYXRpb24gd2l0aCBxdWVyeScsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQmluYXJ5T3BzLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCwgZGVmLCBpbm5lckV4cHIpID0+IGlubmVyRXhwcixcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE5lc3RlZFF1ZXJ5SGFuZGxlcixcbiAgICB9LFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5BYnNlbnQgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5BY29zLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5BY29zaCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQXNpbixcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQXNpbmgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkF0YW4sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkF0YW5oLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkNlaWwgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5DbGFtcCxcbiAgICAgIG5hbWU6ICdDbGFtcCcsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAgeyBuYW1lOiAnTWluaW11bSBTY2FsYXInLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IG5hbWU6ICdNYXhpbXVtIFNjYWxhcicsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzEsIDFdLFxuICAgIH0pLFxuXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5DbGFtcE1heCxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ01heGltdW0gU2NhbGFyJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5DbGFtcE1pbixcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ01pbmltdW0gU2NhbGFyJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5Db3MsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkNvc2gsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRheU9mTW9udGgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVGltZSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRheU9mV2VlayxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5UaW1lLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuRGF5c0luTW9udGgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVGltZSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuRGVnIH0pLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLkRlcml2KSxcbiAgICAvL1xuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5FeHAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkZsb29yIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Hcm91cCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuSG91ciB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkxhYmVsSm9pbixcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ0Rlc3RpbmF0aW9uIExhYmVsJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlZGl0b3I6IExhYmVsUGFyYW1FZGl0b3IsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnU2VwYXJhdG9yJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdTb3VyY2UgTGFiZWwnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIHJlc3RQYXJhbTogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICBlZGl0b3I6IExhYmVsUGFyYW1FZGl0b3IsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnLCAnLCcsICcnXSxcbiAgICAgIHJlbmRlcmVyOiBsYWJlbEpvaW5SZW5kZXJlcixcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGxhYmVsSm9pbkFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkxvZzEwIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Mb2cyIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5NaW51dGUgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLk1vbnRoIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUGksXG4gICAgICByZW5kZXJlcjogKG1vZGVsKSA9PiBgJHttb2RlbC5pZH0oKWAsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5RdWFudGlsZSxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ1ZhbHVlJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlJhZCB9KSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5SZXNldHMpLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUm91bmQsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zLFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnVG8gTmVhcmVzdCcsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzFdLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5TY2FsYXIgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNnbiB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU2luLCBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlNpbmgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU29ydCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU29ydERlc2MgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNxcnQgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlN0ZGRldiB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlRhbixcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuVGFuaCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuVGltZSxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwpID0+IGAke21vZGVsLmlkfSgpYCxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuVGltZXN0YW1wIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuVmVjdG9yLFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnVmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsxXSxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwpID0+IGAke21vZGVsLmlkfSgke21vZGVsLnBhcmFtc1swXX0pYCxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuWWVhciB9KSxcbiAgXTtcblxuICByZXR1cm4gbGlzdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uKGRlZmluaXRpb246IFBhcnRpYWw8UXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPik6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB7XG4gIHJldHVybiB7XG4gICAgLi4uZGVmaW5pdGlvbixcbiAgICBpZDogZGVmaW5pdGlvbi5pZCEsXG4gICAgbmFtZTogZGVmaW5pdGlvbi5uYW1lID8/IGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUoZGVmaW5pdGlvbi5pZCEpLFxuICAgIHBhcmFtczogZGVmaW5pdGlvbi5wYXJhbXMgPz8gW10sXG4gICAgZGVmYXVsdFBhcmFtczogZGVmaW5pdGlvbi5kZWZhdWx0UGFyYW1zID8/IFtdLFxuICAgIGNhdGVnb3J5OiBkZWZpbml0aW9uLmNhdGVnb3J5ID8/IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICByZW5kZXJlcjogZGVmaW5pdGlvbi5yZW5kZXJlciA/PyAoZGVmaW5pdGlvbi5wYXJhbXMgPyBmdW5jdGlvblJlbmRlcmVyUmlnaHQgOiBmdW5jdGlvblJlbmRlcmVyTGVmdCksXG4gICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmaW5pdGlvbi5hZGRPcGVyYXRpb25IYW5kbGVyID8/IGRlZmF1bHRBZGRPcGVyYXRpb25IYW5kbGVyLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmFuZ2VGdW5jdGlvbihuYW1lOiBzdHJpbmcsIHdpdGhSYXRlSW50ZXJ2YWwgPSBmYWxzZSk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB7XG4gIHJldHVybiB7XG4gICAgaWQ6IG5hbWUsXG4gICAgbmFtZTogZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKSxcbiAgICBwYXJhbXM6IFtnZXRSYW5nZVZlY3RvclBhcmFtRGVmKHdpdGhSYXRlSW50ZXJ2YWwpXSxcbiAgICBkZWZhdWx0UGFyYW1zOiBbd2l0aFJhdGVJbnRlcnZhbCA/ICckX19yYXRlX2ludGVydmFsJyA6ICckX19pbnRlcnZhbCddLFxuICAgIGFsdGVybmF0aXZlc0tleTogJ3JhbmdlIGZ1bmN0aW9uJyxcbiAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgcmVuZGVyZXI6IG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyLFxuICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcixcbiAgICBjaGFuZ2VUeXBlSGFuZGxlcjogb3BlcmF0aW9uVHlwZUNoYW5nZWRIYW5kbGVyRm9yUmFuZ2VGdW5jdGlvbixcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3BlcmF0aW9uVHlwZUNoYW5nZWRIYW5kbGVyRm9yUmFuZ2VGdW5jdGlvbihcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIG5ld0RlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmXG4pIHtcbiAgLy8gdmFsaWRhdGUgY3VycmVudCBwYXJhbWV0ZXJcbiAgaWYgKG9wZXJhdGlvbi5wYXJhbXNbMF0gPT09ICckX19yYXRlX2ludGVydmFsJyAmJiBuZXdEZWYuZGVmYXVsdFBhcmFtc1swXSAhPT0gJyRfX3JhdGVfaW50ZXJ2YWwnKSB7XG4gICAgb3BlcmF0aW9uLnBhcmFtcyA9IG5ld0RlZi5kZWZhdWx0UGFyYW1zO1xuICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5wYXJhbXNbMF0gPT09ICckX19pbnRlcnZhbCcgJiYgbmV3RGVmLmRlZmF1bHRQYXJhbXNbMF0gIT09ICckX19pbnRlcnZhbCcpIHtcbiAgICBvcGVyYXRpb24ucGFyYW1zID0gbmV3RGVmLmRlZmF1bHRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gb3BlcmF0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yUmVuZGVyZXIoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIGxldCByYW5nZVZlY3RvciA9IChtb2RlbC5wYXJhbXMgPz8gW10pWzBdID8/ICc1bSc7XG4gIHJldHVybiBgJHtkZWYuaWR9KCR7aW5uZXJFeHByfVske3JhbmdlVmVjdG9yfV0pYDtcbn1cblxuLyoqXG4gKiBTaW5jZSB0aGVyZSBjYW4gb25seSBiZSBvbmUgb3BlcmF0aW9uIHdpdGggcmFuZ2UgdmVjdG9yIHRoaXMgd2lsbCByZXBsYWNlIHRoZSBjdXJyZW50IG9uZSAoaWYgb25lIHdhcyBhZGRlZCApXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IoXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5LFxuICBtb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlclxuKSB7XG4gIGNvbnN0IG5ld09wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgcGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcyxcbiAgfTtcblxuICBpZiAocXVlcnkub3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgLy8gSWYgb3BlcmF0aW9uIGV4aXN0cyBpdCBoYXMgdG8gYmUgaW4gdGhlIHJlZ2lzdHJ5IHNvIG5vIHBvaW50IHRvIGNoZWNrIGlmIGl0IHdhcyBmb3VuZFxuICAgIGNvbnN0IGZpcnN0T3AgPSBtb2RlbGxlci5nZXRPcGVyYXRpb25EZWYocXVlcnkub3BlcmF0aW9uc1swXS5pZCkhO1xuXG4gICAgaWYgKGZpcnN0T3AuYWRkT3BlcmF0aW9uSGFuZGxlciA9PT0gYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgb3BlcmF0aW9uczogW25ld09wZXJhdGlvbiwgLi4ucXVlcnkub3BlcmF0aW9ucy5zbGljZSgxKV0sXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucXVlcnksXG4gICAgb3BlcmF0aW9uczogW25ld09wZXJhdGlvbiwgLi4ucXVlcnkub3BlcmF0aW9uc10sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZE5lc3RlZFF1ZXJ5SGFuZGxlcihkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgcXVlcnk6IFByb21WaXN1YWxRdWVyeSk6IFByb21WaXN1YWxRdWVyeSB7XG4gIHJldHVybiB7XG4gICAgLi4ucXVlcnksXG4gICAgYmluYXJ5UXVlcmllczogW1xuICAgICAgLi4uKHF1ZXJ5LmJpbmFyeVF1ZXJpZXMgPz8gW10pLFxuICAgICAge1xuICAgICAgICBvcGVyYXRvcjogJy8nLFxuICAgICAgICBxdWVyeSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbGFiZWxKb2luUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwucGFyYW1zWzFdICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93ICdUaGUgc2VwYXJhdG9yIG11c3QgYmUgYSBzdHJpbmcnO1xuICB9XG4gIGNvbnN0IHNlcGFyYXRvciA9IGBcIiR7bW9kZWwucGFyYW1zWzFdfVwiYDtcbiAgcmV0dXJuIGAke21vZGVsLmlkfSgke2lubmVyRXhwcn0sIFwiJHttb2RlbC5wYXJhbXNbMF19XCIsICR7c2VwYXJhdG9yfSwgXCIke21vZGVsLnBhcmFtcy5zbGljZSgyKS5qb2luKHNlcGFyYXRvcil9XCIpYDtcbn1cblxuZnVuY3Rpb24gbGFiZWxKb2luQWRkT3BlcmF0aW9uSGFuZGxlcjxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4oZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIHF1ZXJ5OiBUKSB7XG4gIGNvbnN0IG5ld09wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgcGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcyxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIG9wZXJhdGlvbnM6IFsuLi5xdWVyeS5vcGVyYXRpb25zLCBuZXdPcGVyYXRpb25dLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgU3ludGF4Tm9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnbGV6ZXItcHJvbXFsJztcblxuaW1wb3J0IHsgYmluYXJ5U2NhbGFyT3BlcmF0b3JUb09wZXJhdG9yTmFtZSB9IGZyb20gJy4vYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyc7XG5pbXBvcnQge1xuICBFcnJvck5hbWUsXG4gIGdldEFsbEJ5VHlwZSxcbiAgZ2V0TGVmdE1vc3RDaGlsZCxcbiAgZ2V0U3RyaW5nLFxuICBtYWtlQmluT3AsXG4gIG1ha2VFcnJvcixcbiAgcmVwbGFjZVZhcmlhYmxlcyxcbn0gZnJvbSAnLi9zaGFyZWQvcGFyc2luZ1V0aWxzJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gfSBmcm9tICcuL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnksIFByb21WaXN1YWxRdWVyeUJpbmFyeSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFBhcnNlcyBhIFByb21RTCBxdWVyeSBpbnRvIGEgdmlzdWFsIHF1ZXJ5IG1vZGVsLlxuICpcbiAqIEl0IHRyYXZlcnNlcyB0aGUgdHJlZSBhbmQgdXNlcyBzb3J0IG9mIHN0YXRlIG1hY2hpbmUgdG8gdXBkYXRlIHRoZSBxdWVyeSBtb2RlbC4gVGhlIHF1ZXJ5IG1vZGVsIGlzIG1vZGlmaWVkXG4gKiBkdXJpbmcgdGhlIHRyYXZlcnNhbCBhbmQgc2VudCB0byBlYWNoIGhhbmRsZXIgYXMgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gZXhwclxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcoZXhwcjogc3RyaW5nKTogQ29udGV4dCB7XG4gIGNvbnN0IHJlcGxhY2VkRXhwciA9IHJlcGxhY2VWYXJpYWJsZXMoZXhwcik7XG4gIGNvbnN0IHRyZWUgPSBwYXJzZXIucGFyc2UocmVwbGFjZWRFeHByKTtcbiAgY29uc3Qgbm9kZSA9IHRyZWUudG9wTm9kZTtcblxuICAvLyBUaGlzIHdpbGwgYmUgbW9kaWZpZWQgaW4gdGhlIGhhbmRsZXJzLlxuICBjb25zdCB2aXNRdWVyeTogUHJvbVZpc3VhbFF1ZXJ5ID0ge1xuICAgIG1ldHJpYzogJycsXG4gICAgbGFiZWxzOiBbXSxcbiAgICBvcGVyYXRpb25zOiBbXSxcbiAgfTtcbiAgY29uc3QgY29udGV4dDogQ29udGV4dCA9IHtcbiAgICBxdWVyeTogdmlzUXVlcnksXG4gICAgZXJyb3JzOiBbXSxcbiAgfTtcblxuICB0cnkge1xuICAgIGhhbmRsZUV4cHJlc3Npb24ocmVwbGFjZWRFeHByLCBub2RlLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gTm90IGlkZWFsIHRvIGxvZyBpdCBoZXJlLCBidXQgb3RoZXJ3aXNlIHdlIHdvdWxkIGxvc2UgdGhlIHN0YWNrIHRyYWNlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goe1xuICAgICAgICB0ZXh0OiBlcnIubWVzc2FnZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgZW1wdHkgcXVlcnksIHdlIHdhbnQgdG8gcmVzZXQgZXJyb3JzXG4gIGlmIChpc0VtcHR5UXVlcnkoY29udGV4dC5xdWVyeSkpIHtcbiAgICBjb250ZXh0LmVycm9ycyA9IFtdO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5pbnRlcmZhY2UgUGFyc2luZ0Vycm9yIHtcbiAgdGV4dDogc3RyaW5nO1xuICBmcm9tPzogbnVtYmVyO1xuICB0bz86IG51bWJlcjtcbiAgcGFyZW50VHlwZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIENvbnRleHQge1xuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5O1xuICBlcnJvcnM6IFBhcnNpbmdFcnJvcltdO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGRlZmF1bHQgc3RhdGUuIEl0IHdpbGwgdHJhdmVyc2UgdGhlIHRyZWUgYW5kIGNhbGwgdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXIgZm9yIGVhY2ggbm9kZS4gVGhlIG5vZGVcbiAqIGhhbmRsZWQgaGVyZSBkb2VzIG5vdCBuZWNlc3NhcmlseSBuZWVkIHRvIGJlIG9mIHR5cGUgPT0gRXhwci5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUV4cHJlc3Npb24oZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgc3dpdGNoIChub2RlLm5hbWUpIHtcbiAgICBjYXNlICdNZXRyaWNJZGVudGlmaWVyJzoge1xuICAgICAgLy8gRXhwZWN0YXRpb24gaXMgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBvZiB0aG9zZSBwZXIgcXVlcnkuXG4gICAgICB2aXNRdWVyeS5tZXRyaWMgPSBnZXRTdHJpbmcoZXhwciwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMYWJlbE1hdGNoZXInOiB7XG4gICAgICAvLyBTYW1lIGFzIE1ldHJpY0lkZW50aWZpZXIgc2hvdWxkIGJlIGp1c3Qgb25lIHBlciBxdWVyeS5cbiAgICAgIHZpc1F1ZXJ5LmxhYmVscy5wdXNoKGdldExhYmVsKGV4cHIsIG5vZGUpKTtcbiAgICAgIGNvbnN0IGVyciA9IG5vZGUuZ2V0Q2hpbGQoRXJyb3JOYW1lKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgZXJyKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdGdW5jdGlvbkNhbGwnOiB7XG4gICAgICBoYW5kbGVGdW5jdGlvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0FnZ3JlZ2F0ZUV4cHInOiB7XG4gICAgICBoYW5kbGVBZ2dyZWdhdGlvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0JpbmFyeUV4cHInOiB7XG4gICAgICBoYW5kbGVCaW5hcnkoZXhwciwgbm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIEVycm9yTmFtZToge1xuICAgICAgaWYgKGlzSW50ZXJ2YWxWYXJpYWJsZUVycm9yKG5vZGUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgbm9kZSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKG5vZGUubmFtZSA9PT0gJ1BhcmVuRXhwcicpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBwYXJlbnRoZXNpcyBpbiB0aGUgcXVlcnkgdG8gZ3JvdXAgZXhwcmVzc2lvbnMuIFdlIGp1c3QgcmVwb3J0IGVycm9yIGJ1dCBnbyBvbiB3aXRoIHRoZVxuICAgICAgICAvLyBwYXJzaW5nLlxuICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG1ha2VFcnJvcihleHByLCBub2RlKSk7XG4gICAgICB9XG4gICAgICAvLyBBbnkgb3RoZXIgbm9kZXMgd2UganVzdCBpZ25vcmUgYW5kIGdvIHRvIGl0J3MgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIGZpbmUgYXMgdGhlcmUgYXJlIGxvdCdzIG9mIHdyYXBwZXJcbiAgICAgIC8vIG5vZGVzIHRoYXQgY2FuIGJlIHNraXBwZWQuXG4gICAgICAvLyBUT0RPOiB0aGVyZSBhcmUgcHJvYmFibHkgY2FzZXMgd2hlcmUgd2Ugd2lsbCBqdXN0IHNraXAgbm9kZXMgd2UgZG9uJ3Qgc3VwcG9ydCBhbmQgd2Ugc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgIC8vICBkZXRlY3QgdGhvc2UgYW5kIHJlcG9ydCBiYWNrLlxuICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVydmFsVmFyaWFibGVFcnJvcihub2RlOiBTeW50YXhOb2RlKSB7XG4gIHJldHVybiBub2RlLnByZXZTaWJsaW5nPy5uYW1lID09PSAnRXhwcicgJiYgbm9kZS5wcmV2U2libGluZz8uZmlyc3RDaGlsZD8ubmFtZSA9PT0gJ1ZlY3RvclNlbGVjdG9yJztcbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWwoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICBjb25zdCBsYWJlbCA9IGdldFN0cmluZyhleHByLCBub2RlLmdldENoaWxkKCdMYWJlbE5hbWUnKSk7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ01hdGNoT3AnKSk7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ1N0cmluZ0xpdGVyYWwnKSkucmVwbGFjZSgvXCIvZywgJycpO1xuICByZXR1cm4ge1xuICAgIGxhYmVsLFxuICAgIG9wLFxuICAgIHZhbHVlLFxuICB9O1xufVxuXG5jb25zdCByYW5nZUZ1bmN0aW9ucyA9IFsnY2hhbmdlcycsICdyYXRlJywgJ2lyYXRlJywgJ2luY3JlYXNlJywgJ2RlbHRhJ107XG4vKipcbiAqIEhhbmRsZSBmdW5jdGlvbiBjYWxsIHdoaWNoIGlzIHVzdWFsbHkgYW5kIGlkZW50aWZpZXIgYW5kIGl0cyBib2R5ID4gYXJndW1lbnRzLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBoYW5kbGVGdW5jdGlvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgdmlzUXVlcnkgPSBjb250ZXh0LnF1ZXJ5O1xuICBjb25zdCBuYW1lTm9kZSA9IG5vZGUuZ2V0Q2hpbGQoJ0Z1bmN0aW9uSWRlbnRpZmllcicpO1xuICBjb25zdCBmdW5jTmFtZSA9IGdldFN0cmluZyhleHByLCBuYW1lTm9kZSk7XG5cbiAgY29uc3QgYm9keSA9IG5vZGUuZ2V0Q2hpbGQoJ0Z1bmN0aW9uQ2FsbEJvZHknKTtcbiAgY29uc3QgY2FsbEFyZ3MgPSBib2R5IS5nZXRDaGlsZCgnRnVuY3Rpb25DYWxsQXJncycpO1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgbGV0IGludGVydmFsID0gJyc7XG5cbiAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIHNob3J0Y3V0IHRvIGdldCB0aGUgaW50ZXJ2YWwgYXJndW1lbnQuIFJlYXNvbnMgYXJlXG4gIC8vIC0gaW50ZXJ2YWwgaXMgbm90IHBhcnQgb2YgdGhlIGZ1bmN0aW9uIGFyZ3MgcGVyIHByb21RTCBncmFtbWFyIGJ1dCB3ZSBtb2RlbCBpdCBhcyBhcmd1bWVudCBmb3IgdGhlIGZ1bmN0aW9uIGluXG4gIC8vICAgdGhlIHF1ZXJ5IG1vZGVsLlxuICAvLyAtIGl0IGlzIGVhc2llciB0byBoYW5kbGUgdGVtcGxhdGUgdmFyaWFibGVzIHRoaXMgd2F5IGFzIHRlbXBsYXRlIHZhcmlhYmxlIGlzIGFuIGVycm9yIGZvciB0aGUgcGFyc2VyXG4gIGlmIChyYW5nZUZ1bmN0aW9ucy5pbmNsdWRlcyhmdW5jTmFtZSkgfHwgZnVuY05hbWUuZW5kc1dpdGgoJ19vdmVyX3RpbWUnKSkge1xuICAgIGxldCBtYXRjaCA9IGdldFN0cmluZyhleHByLCBub2RlKS5tYXRjaCgvXFxbKC4rKVxcXS8pO1xuICAgIGlmIChtYXRjaD8uWzFdKSB7XG4gICAgICBpbnRlcnZhbCA9IG1hdGNoWzFdO1xuICAgICAgcGFyYW1zLnB1c2gobWF0Y2hbMV0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9wID0geyBpZDogZnVuY05hbWUsIHBhcmFtcyB9O1xuICAvLyBXZSB1bnNoaWZ0IG9wZXJhdGlvbnMgdG8ga2VlcCB0aGUgbW9yZSBuYXR1cmFsIG9yZGVyIHRoYXQgd2Ugd2FudCB0byBoYXZlIGluIHRoZSB2aXN1YWwgcXVlcnkgZWRpdG9yLlxuICB2aXNRdWVyeS5vcGVyYXRpb25zLnVuc2hpZnQob3ApO1xuXG4gIGlmIChjYWxsQXJncykge1xuICAgIGlmIChnZXRTdHJpbmcoZXhwciwgY2FsbEFyZ3MpID09PSBpbnRlcnZhbCArICddJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBoYXZlIGEgZnVuY3Rpb24gd2l0aCBhIHNpbmdsZSBhcmd1bWVudCBhbmQgaXQgaXMgdGhlIGludGVydmFsLlxuICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4geW91IHN0YXJ0IGFkZGluZyBvcGVyYXRpb25zIGluIHF1ZXJ5IGJ1aWxkZXIgYW5kIGRpZCBub3Qgc2V0IGEgbWV0cmljIHlldC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHIsIGNhbGxBcmdzLCBjb250ZXh0LCBvcCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgYWdncmVnYXRpb24gYXMgdGhleSBhcmUgZGlzdGluY3QgdHlwZSBmcm9tIG90aGVyIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQWdncmVnYXRpb24oZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgY29uc3QgbmFtZU5vZGUgPSBub2RlLmdldENoaWxkKCdBZ2dyZWdhdGVPcCcpO1xuICBsZXQgZnVuY05hbWUgPSBnZXRTdHJpbmcoZXhwciwgbmFtZU5vZGUpO1xuXG4gIGNvbnN0IG1vZGlmaWVyID0gbm9kZS5nZXRDaGlsZCgnQWdncmVnYXRlTW9kaWZpZXInKTtcbiAgY29uc3QgbGFiZWxzID0gW107XG5cbiAgaWYgKG1vZGlmaWVyKSB7XG4gICAgY29uc3QgYnlNb2RpZmllciA9IG1vZGlmaWVyLmdldENoaWxkKGBCeWApO1xuICAgIGlmIChieU1vZGlmaWVyICYmIGZ1bmNOYW1lKSB7XG4gICAgICBmdW5jTmFtZSA9IGBfXyR7ZnVuY05hbWV9X2J5YDtcbiAgICB9XG5cbiAgICBjb25zdCB3aXRob3V0TW9kaWZpZXIgPSBtb2RpZmllci5nZXRDaGlsZChgV2l0aG91dGApO1xuICAgIGlmICh3aXRob3V0TW9kaWZpZXIpIHtcbiAgICAgIGZ1bmNOYW1lID0gYF9fJHtmdW5jTmFtZX1fd2l0aG91dGA7XG4gICAgfVxuXG4gICAgbGFiZWxzLnB1c2goLi4uZ2V0QWxsQnlUeXBlKGV4cHIsIG1vZGlmaWVyLCAnR3JvdXBpbmdMYWJlbCcpKTtcbiAgfVxuXG4gIGNvbnN0IGJvZHkgPSBub2RlLmdldENoaWxkKCdGdW5jdGlvbkNhbGxCb2R5Jyk7XG4gIGNvbnN0IGNhbGxBcmdzID0gYm9keSEuZ2V0Q2hpbGQoJ0Z1bmN0aW9uQ2FsbEFyZ3MnKTtcblxuICBjb25zdCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyBpZDogZnVuY05hbWUsIHBhcmFtczogW10gfTtcbiAgdmlzUXVlcnkub3BlcmF0aW9ucy51bnNoaWZ0KG9wKTtcbiAgdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHIsIGNhbGxBcmdzLCBjb250ZXh0LCBvcCk7XG4gIC8vIFdlIGFkZCBsYWJlbHMgYWZ0ZXIgcGFyYW1zIGluIHRoZSB2aXN1YWwgcXVlcnkgZWRpdG9yLlxuICBvcC5wYXJhbXMucHVzaCguLi5sYWJlbHMpO1xufVxuXG4vKipcbiAqIEhhbmRsZSAocHJvYmFibHkpIGFsbCB0eXBlcyBvZiBhcmd1bWVudHMgdGhhdCBmdW5jdGlvbiBvciBhZ2dyZWdhdGlvbiBjYW4gaGF2ZS5cbiAqXG4gKiAgRnVuY3Rpb25DYWxsQXJncyBhcmUgbmVzdGVkIGJpdCB3ZWlyZGx5IGJhc2ljYWxseSBpdHMgW2ZpcnN0QXJnLCAuLi5yZXN0XSB3aGVyZSByZXN0IGlzIGFnYWluIEZ1bmN0aW9uQ2FsbEFyZ3Mgc29cbiAqICB3ZSBjYW5ub3QganVzdCBnZXQgYWxsIHRoZSBjaGlsZHJlbiBhbmQgaXRlcmF0ZSB0aGVtIGFzIGFyZ3VtZW50cyB3ZSBoYXZlIHRvIGFnYWluIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRocm91Z2hcbiAqICB0aGVtLlxuICpcbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqIEBwYXJhbSBvcCAtIFdlIG5lZWQgdGhlIG9wZXJhdGlvbiB0byBhZGQgdGhlIHBhcmFtcyB0byBhcyBhbiBhZGRpdGlvbmFsIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQXJncyhleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUgfCBudWxsLCBjb250ZXh0OiBDb250ZXh0LCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzd2l0Y2ggKG5vZGUubmFtZSkge1xuICAgIC8vIEluIGNhc2Ugd2UgaGF2ZSBhbiBleHByZXNzaW9uIHdlIGRvbid0IGtub3cgd2hhdCBraW5kIHNvIHdlIGhhdmUgdG8gbG9vayBhdCB0aGUgY2hpbGQgYXMgaXQgY2FuIGJlIGFueXRoaW5nLlxuICAgIGNhc2UgJ0V4cHInOlxuICAgIC8vIEZ1bmN0aW9uQ2FsbEFyZ3MgYXJlIG5lc3RlZCBiaXQgd2VpcmRseSBhcyBtZW50aW9uZWQgc28gd2UgaGF2ZSB0byBnbyBvbmUgZGVlcGVyIGluIHRoaXMgY2FzZS5cbiAgICBjYXNlICdGdW5jdGlvbkNhbGxBcmdzJzoge1xuICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHVwZGF0ZUZ1bmN0aW9uQXJncyhleHByLCBjaGlsZCwgY29udGV4dCwgb3ApO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTnVtYmVyTGl0ZXJhbCc6IHtcbiAgICAgIG9wLnBhcmFtcy5wdXNoKHBhcnNlRmxvYXQoZ2V0U3RyaW5nKGV4cHIsIG5vZGUpKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzoge1xuICAgICAgb3AucGFyYW1zLnB1c2goZ2V0U3RyaW5nKGV4cHIsIG5vZGUpLnJlcGxhY2UoL1wiL2csICcnKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICAvLyBNZWFucyB3ZSBnZXQgdG8gc29tZXRoaW5nIHRoYXQgZG9lcyBub3Qgc2VlbSBsaWtlIHNpbXBsZSBmdW5jdGlvbiBhcmcgYW5kIGlzIHByb2JhYmx5IG5lc3RlZCBxdWVyeSBzbyBqdW1wXG4gICAgICAvLyBiYWNrIHRvIG1haW4gY29udGV4dFxuICAgICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSaWdodCBub3cgYmluYXJ5IGV4cHJlc3Npb25zIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheSBpbiB2aXN1YWwgcXVlcnkuIEFzIGFkZGl0aW9uYWwgb3BlcmF0aW9uIGluIGNhc2UgaXQgaXNcbiAqIGp1c3Qgb3BlcmF0aW9uIHdpdGggc2NhbGFyIG9yIGl0IGNyZWF0ZXMgYSBiaW5hcnlRdWVyeSB3aGVuIGl0J3MgMiBxdWVyaWVzLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBoYW5kbGVCaW5hcnkoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgY29uc3QgbGVmdCA9IG5vZGUuZmlyc3RDaGlsZCE7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIGxlZnQubmV4dFNpYmxpbmcpO1xuICBjb25zdCBiaW5Nb2RpZmllciA9IGdldEJpbmFyeU1vZGlmaWVyKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ0Jpbk1vZGlmaWVycycpKTtcblxuICBjb25zdCByaWdodCA9IG5vZGUubGFzdENoaWxkITtcblxuICBjb25zdCBvcERlZiA9IGJpbmFyeVNjYWxhck9wZXJhdG9yVG9PcGVyYXRvck5hbWVbb3BdO1xuXG4gIGNvbnN0IGxlZnROdW1iZXIgPSBsZWZ0LmdldENoaWxkKCdOdW1iZXJMaXRlcmFsJyk7XG4gIGNvbnN0IHJpZ2h0TnVtYmVyID0gcmlnaHQuZ2V0Q2hpbGQoJ051bWJlckxpdGVyYWwnKTtcblxuICBjb25zdCByaWdodEJpbmFyeSA9IHJpZ2h0LmdldENoaWxkKCdCaW5hcnlFeHByJyk7XG5cbiAgaWYgKGxlZnROdW1iZXIpIHtcbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhbHJlYWR5IGhhbmRsZWQgaW4gY2FzZSBwYXJlbnQgaXMgYmluYXJ5IGV4cHJlc3Npb24gYXMgaXQgaGFzIHRvIGJlIGFkZGVkIHRvIHBhcmVudFxuICAgIC8vICBpZiBxdWVyeSBzdGFydHMgd2l0aCBhIG51bWJlciB0aGF0IGlzbid0IGhhbmRsZWQgbm93LlxuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoaXMgaXMgYmluYXJ5IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIHRoZXJlIGlzIGEgcXVlcnkgb3IganVzdCBjaGFpbmVkIHNjYWxhcnMuIFNvXG4gICAgLy8gd2UgaGF2ZSB0byB0cmF2ZXJzZSBhIGJpdCBkZWVwZXIgdG8ga25vd1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgbGVmdCwgY29udGV4dCk7XG4gIH1cblxuICBpZiAocmlnaHROdW1iZXIpIHtcbiAgICB2aXNRdWVyeS5vcGVyYXRpb25zLnB1c2gobWFrZUJpbk9wKG9wRGVmLCBleHByLCByaWdodCwgISFiaW5Nb2RpZmllcj8uaXNCb29sKSk7XG4gIH0gZWxzZSBpZiAocmlnaHRCaW5hcnkpIHtcbiAgICAvLyBEdWUgdG8gdGhlIHdheSBiaW5hcnkgb3BzIGFyZSBwYXJzZWQgd2UgY2FuIGdldCBhIGJpbmFyeSBvcGVyYXRpb24gb24gdGhlIHJpZ2h0IHRoYXQgc3RhcnRzIHdpdGggYSBudW1iZXIgd2hpY2hcbiAgICAvLyBpcyBhIGZhY3RvciBmb3IgYSBjdXJyZW50IGJpbmFyeSBvcGVyYXRpb24uIFNvIHdlIGhhdmUgdG8gYWRkIGl0IGFzIGFuIG9wZXJhdGlvbiBub3cuXG4gICAgY29uc3QgbGVmdE1vc3RDaGlsZCA9IGdldExlZnRNb3N0Q2hpbGQocmlnaHQpO1xuICAgIGlmIChsZWZ0TW9zdENoaWxkPy5uYW1lID09PSAnTnVtYmVyTGl0ZXJhbCcpIHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChtYWtlQmluT3Aob3BEZWYsIGV4cHIsIGxlZnRNb3N0Q2hpbGQsICEhYmluTW9kaWZpZXI/LmlzQm9vbCkpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFkZGVkIHRoZSBmaXJzdCBudW1iZXIgbGl0ZXJhbCBhcyBvcGVyYXRpb24gaGVyZSB3ZSBzdGlsbCBjYW4gY29udGludWUgYW5kIGhhbmRsZSB0aGUgcmVzdCBhcyB0aGUgZmlyc3RcbiAgICAvLyBudW1iZXIgd2lsbCBiZSBqdXN0IHNraXBwZWQuXG4gICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCByaWdodCwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmlzUXVlcnkuYmluYXJ5UXVlcmllcyA9IHZpc1F1ZXJ5LmJpbmFyeVF1ZXJpZXMgfHwgW107XG4gICAgY29uc3QgYmluUXVlcnk6IFByb21WaXN1YWxRdWVyeUJpbmFyeSA9IHtcbiAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIG1ldHJpYzogJycsXG4gICAgICAgIGxhYmVsczogW10sXG4gICAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChiaW5Nb2RpZmllcj8uaXNNYXRjaGVyKSB7XG4gICAgICBiaW5RdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSA9IGJpbk1vZGlmaWVyLm1hdGNoVHlwZTtcbiAgICAgIGJpblF1ZXJ5LnZlY3Rvck1hdGNoZXMgPSBiaW5Nb2RpZmllci5tYXRjaGVzO1xuICAgIH1cbiAgICB2aXNRdWVyeS5iaW5hcnlRdWVyaWVzLnB1c2goYmluUXVlcnkpO1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgcmlnaHQsIHtcbiAgICAgIHF1ZXJ5OiBiaW5RdWVyeS5xdWVyeSxcbiAgICAgIGVycm9yczogY29udGV4dC5lcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5TW9kaWZpZXIoXG4gIGV4cHI6IHN0cmluZyxcbiAgbm9kZTogU3ludGF4Tm9kZSB8IG51bGxcbik6XG4gIHwgeyBpc0Jvb2w6IHRydWU7IGlzTWF0Y2hlcjogZmFsc2UgfVxuICB8IHsgaXNCb29sOiBmYWxzZTsgaXNNYXRjaGVyOiB0cnVlOyBtYXRjaGVzOiBzdHJpbmc7IG1hdGNoVHlwZTogJ2lnbm9yaW5nJyB8ICdvbicgfVxuICB8IHVuZGVmaW5lZCB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG5vZGUuZ2V0Q2hpbGQoJ0Jvb2wnKSkge1xuICAgIHJldHVybiB7IGlzQm9vbDogdHJ1ZSwgaXNNYXRjaGVyOiBmYWxzZSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1hdGNoZXIgPSBub2RlLmdldENoaWxkKCdPbk9ySWdub3JpbmcnKTtcbiAgICBpZiAoIW1hdGNoZXIpIHtcbiAgICAgIC8vIE5vdCBzdXJlIHdoYXQgdGhpcyBjb3VsZCBiZSwgbWF5YmUgc2hvdWxkIGJlIGFuIGVycm9yLlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gZ2V0U3RyaW5nKGV4cHIsIG1hdGNoZXIuZ2V0Q2hpbGQoJ0dyb3VwaW5nTGFiZWxzJyk/LmdldENoaWxkKCdHcm91cGluZ0xhYmVsTGlzdCcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaGVyOiB0cnVlLFxuICAgICAgaXNCb29sOiBmYWxzZSxcbiAgICAgIG1hdGNoZXM6IGxhYmVscyxcbiAgICAgIG1hdGNoVHlwZTogbWF0Y2hlci5nZXRDaGlsZCgnT24nKSA/ICdvbicgOiAnaWdub3JpbmcnLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFbXB0eVF1ZXJ5KHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkpIHtcbiAgaWYgKHF1ZXJ5LmxhYmVscy5sZW5ndGggPT09IDAgJiYgcXVlcnkub3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgIXF1ZXJ5Lm1ldHJpYykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBjb25maWcsIHJlcG9ydEludGVyYWN0aW9uIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBJY29uLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgZmVlZGJhY2tVcmw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGZWVkYmFja0xpbmsoeyBmZWVkYmFja1VybCB9OiBQcm9wcykge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgaWYgKCFjb25maWcuZmVlZGJhY2tMaW5rc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFN0YWNrIGdhcD17MX0+XG4gICAgICA8YVxuICAgICAgICBocmVmPXtmZWVkYmFja1VybH1cbiAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubGlua31cbiAgICAgICAgdGl0bGU9XCJUaGlzIHF1ZXJ5IGJ1aWxkZXIgaXMgbmV3LCBwbGVhc2UgbGV0IHVzIGtub3cgaG93IHdlIGNhbiBpbXByb3ZlIGl0XCJcbiAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgcmVsPVwibm9yZWZlcnJlciBub29wZW5lclwiXG4gICAgICAgIG9uQ2xpY2s9eygpID0+XG4gICAgICAgICAgcmVwb3J0SW50ZXJhY3Rpb24oJ2dyYWZhbmFfZmVlZGJhY2tfbGlua19jbGlja2VkJywge1xuICAgICAgICAgICAgbGluazogZmVlZGJhY2tVcmwsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgPlxuICAgICAgICA8SWNvbiBuYW1lPVwiY29tbWVudC1hbHQtbWVzc2FnZVwiIC8+IEdpdmUgZmVlZGJhY2tcbiAgICAgIDwvYT5cbiAgICA8L1N0YWNrPlxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRTdHlsZXModGhlbWU6IEdyYWZhbmFUaGVtZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBsaW5rOiBjc3Moe1xuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgICc6aG92ZXInOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5saW5rLFxuICAgICAgfSxcbiAgICB9KSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IHVuaXFCeSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSwgdG9PcHRpb24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEFjY2Vzc29yeUJ1dHRvbiwgSW5wdXRHcm91cCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBkZWZhdWx0T3A6IHN0cmluZztcbiAgaXRlbTogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj47XG4gIG9uQ2hhbmdlOiAodmFsdWU6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyKSA9PiB2b2lkO1xuICBvbkdldExhYmVsTmFtZXM6IChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+O1xuICBvbkdldExhYmVsVmFsdWVzOiAoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PiBQcm9taXNlPFNlbGVjdGFibGVWYWx1ZVtdPjtcbiAgb25EZWxldGU6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBMYWJlbEZpbHRlckl0ZW0oeyBpdGVtLCBkZWZhdWx0T3AsIG9uQ2hhbmdlLCBvbkRlbGV0ZSwgb25HZXRMYWJlbE5hbWVzLCBvbkdldExhYmVsVmFsdWVzIH06IFByb3BzKSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8e1xuICAgIGxhYmVsTmFtZXM/OiBTZWxlY3RhYmxlVmFsdWVbXTtcbiAgICBsYWJlbFZhbHVlcz86IFNlbGVjdGFibGVWYWx1ZVtdO1xuICAgIGlzTG9hZGluZ0xhYmVsTmFtZXM/OiBib29sZWFuO1xuICAgIGlzTG9hZGluZ0xhYmVsVmFsdWVzPzogYm9vbGVhbjtcbiAgfT4oe30pO1xuXG4gIGNvbnN0IGlzTXVsdGlTZWxlY3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGl0ZW0ub3AgPT09IG9wZXJhdG9yc1swXS5sYWJlbDtcbiAgfTtcblxuICBjb25zdCBnZXRTZWxlY3RPcHRpb25zRnJvbVN0cmluZyA9IChpdGVtPzogc3RyaW5nKTogc3RyaW5nW10gPT4ge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbS5pbmRleE9mKCd8JykgPiAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnNwbGl0KCd8Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2l0ZW1dO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgY29uc3QgZ2V0T3B0aW9ucyA9ICgpOiBTZWxlY3RhYmxlVmFsdWVbXSA9PiB7XG4gICAgY29uc3QgbGFiZWxWYWx1ZXMgPSBzdGF0ZS5sYWJlbFZhbHVlcyA/IFsuLi5zdGF0ZS5sYWJlbFZhbHVlc10gOiBbXTtcbiAgICBjb25zdCBzZWxlY3RlZE9wdGlvbnMgPSBnZXRTZWxlY3RPcHRpb25zRnJvbVN0cmluZyhpdGVtPy52YWx1ZSkubWFwKHRvT3B0aW9uKTtcblxuICAgIC8vIFJlbW92ZSBwb3NzaWJsZSBkdXBsaWNhdGVkIHZhbHVlc1xuICAgIHJldHVybiB1bmlxQnkoWy4uLnNlbGVjdGVkT3B0aW9ucywgLi4ubGFiZWxWYWx1ZXNdLCAndmFsdWUnKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJwcm9tZXRoZXVzLWRpbWVuc2lvbnMtZmlsdGVyLWl0ZW1cIj5cbiAgICAgIDxJbnB1dEdyb3VwPlxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgaW5wdXRJZD1cInByb21ldGhldXMtZGltZW5zaW9ucy1maWx0ZXItaXRlbS1rZXlcIlxuICAgICAgICAgIHdpZHRoPVwiYXV0b1wiXG4gICAgICAgICAgdmFsdWU9e2l0ZW0ubGFiZWwgPyB0b09wdGlvbihpdGVtLmxhYmVsKSA6IG51bGx9XG4gICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgIG9uT3Blbk1lbnU9e2FzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgaXNMb2FkaW5nTGFiZWxOYW1lczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsTmFtZXMgPSBhd2FpdCBvbkdldExhYmVsTmFtZXMoaXRlbSk7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGxhYmVsTmFtZXMsIGlzTG9hZGluZ0xhYmVsTmFtZXM6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGlzTG9hZGluZz17c3RhdGUuaXNMb2FkaW5nTGFiZWxOYW1lc31cbiAgICAgICAgICBvcHRpb25zPXtzdGF0ZS5sYWJlbE5hbWVzfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLmxhYmVsKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgIG9wOiBpdGVtLm9wID8/IGRlZmF1bHRPcCxcbiAgICAgICAgICAgICAgICBsYWJlbDogY2hhbmdlLmxhYmVsLFxuICAgICAgICAgICAgICB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cblxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgdmFsdWU9e3RvT3B0aW9uKGl0ZW0ub3AgPz8gZGVmYXVsdE9wKX1cbiAgICAgICAgICBvcHRpb25zPXtvcGVyYXRvcnN9XG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICBvbkNoYW5nZT17KGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHsgLi4uaXRlbSwgb3A6IGNoYW5nZS52YWx1ZSB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cblxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgaW5wdXRJZD1cInByb21ldGhldXMtZGltZW5zaW9ucy1maWx0ZXItaXRlbS12YWx1ZVwiXG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICB2YWx1ZT17XG4gICAgICAgICAgICBpc011bHRpU2VsZWN0KClcbiAgICAgICAgICAgICAgPyBnZXRTZWxlY3RPcHRpb25zRnJvbVN0cmluZyhpdGVtPy52YWx1ZSkubWFwKHRvT3B0aW9uKVxuICAgICAgICAgICAgICA6IGdldFNlbGVjdE9wdGlvbnNGcm9tU3RyaW5nKGl0ZW0/LnZhbHVlKS5tYXAodG9PcHRpb24pWzBdXG4gICAgICAgICAgfVxuICAgICAgICAgIGFsbG93Q3VzdG9tVmFsdWVcbiAgICAgICAgICBvbk9wZW5NZW51PXthc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGlzTG9hZGluZ0xhYmVsVmFsdWVzOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxWYWx1ZXMgPSBhd2FpdCBvbkdldExhYmVsVmFsdWVzKGl0ZW0pO1xuICAgICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgbGFiZWxWYWx1ZXMsXG4gICAgICAgICAgICAgIGlzTG9hZGluZ0xhYmVsVmFsdWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGlzTXVsdGk9e2lzTXVsdGlTZWxlY3QoKX1cbiAgICAgICAgICBpc0xvYWRpbmc9e3N0YXRlLmlzTG9hZGluZ0xhYmVsVmFsdWVzfVxuICAgICAgICAgIG9wdGlvbnM9e2dldE9wdGlvbnMoKX1cbiAgICAgICAgICBvbkNoYW5nZT17KGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS52YWx1ZSkge1xuICAgICAgICAgICAgICBvbkNoYW5nZSh7IC4uLml0ZW0sIHZhbHVlOiBjaGFuZ2UudmFsdWUsIG9wOiBpdGVtLm9wID8/IGRlZmF1bHRPcCB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gY2hhbmdlXG4gICAgICAgICAgICAgICAgLm1hcCgoY2hhbmdlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2UubGFiZWw7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignfCcpO1xuICAgICAgICAgICAgICBvbkNoYW5nZSh7IC4uLml0ZW0sIHZhbHVlOiBjaGFuZ2VzLCBvcDogaXRlbS5vcCA/PyBkZWZhdWx0T3AgfSBhcyBhbnkgYXMgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICAgIDxBY2Nlc3NvcnlCdXR0b24gYXJpYS1sYWJlbD1cInJlbW92ZVwiIGljb249XCJ0aW1lc1wiIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiBvbkNsaWNrPXtvbkRlbGV0ZX0gLz5cbiAgICAgIDwvSW5wdXRHcm91cD5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuY29uc3Qgb3BlcmF0b3JzID0gW1xuICB7IGxhYmVsOiAnPX4nLCB2YWx1ZTogJz1+JyB9LFxuICB7IGxhYmVsOiAnPScsIHZhbHVlOiAnPScgfSxcbiAgeyBsYWJlbDogJyE9JywgdmFsdWU6ICchPScgfSxcbiAgeyBsYWJlbDogJyF+JywgdmFsdWU6ICchficgfSxcbl07XG4iLCJpbXBvcnQgeyBpc0VxdWFsIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEVkaXRvckZpZWxkR3JvdXAsIEVkaXRvckxpc3QsIEVkaXRvckZpZWxkIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcblxuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBMYWJlbEZpbHRlckl0ZW0gfSBmcm9tICcuL0xhYmVsRmlsdGVySXRlbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBsYWJlbHNGaWx0ZXJzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdO1xuICBvbkNoYW5nZTogKGxhYmVsRmlsdGVyczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSkgPT4gdm9pZDtcbiAgb25HZXRMYWJlbE5hbWVzOiAoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PiBQcm9taXNlPFNlbGVjdGFibGVWYWx1ZVtdPjtcbiAgb25HZXRMYWJlbFZhbHVlczogKGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPikgPT4gUHJvbWlzZTxTZWxlY3RhYmxlVmFsdWVbXT47XG4gIGVycm9yPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTGFiZWxGaWx0ZXJzKHsgbGFiZWxzRmlsdGVycywgb25DaGFuZ2UsIG9uR2V0TGFiZWxOYW1lcywgb25HZXRMYWJlbFZhbHVlcywgZXJyb3IgfTogUHJvcHMpIHtcbiAgY29uc3QgZGVmYXVsdE9wID0gJz0nO1xuICBjb25zdCBbaXRlbXMsIHNldEl0ZW1zXSA9IHVzZVN0YXRlPEFycmF5PFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+Pj4oW3sgb3A6IGRlZmF1bHRPcCB9XSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobGFiZWxzRmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBzZXRJdGVtcyhsYWJlbHNGaWx0ZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SXRlbXMoW3sgb3A6IGRlZmF1bHRPcCB9XSk7XG4gICAgfVxuICB9LCBbbGFiZWxzRmlsdGVyc10pO1xuXG4gIGNvbnN0IG9uTGFiZWxzQ2hhbmdlID0gKG5ld0l0ZW1zOiBBcnJheTxQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPj4pID0+IHtcbiAgICBzZXRJdGVtcyhuZXdJdGVtcyk7XG5cbiAgICAvLyBFeHRyYWN0IGZ1bGwgbGFiZWwgZmlsdGVycyB3aXRoIGJvdGggbGFiZWwgJiB2YWx1ZVxuICAgIGNvbnN0IG5ld0xhYmVscyA9IG5ld0l0ZW1zLmZpbHRlcigoeCkgPT4geC5sYWJlbCAhPSBudWxsICYmIHgudmFsdWUgIT0gbnVsbCk7XG4gICAgaWYgKCFpc0VxdWFsKG5ld0xhYmVscywgbGFiZWxzRmlsdGVycykpIHtcbiAgICAgIG9uQ2hhbmdlKG5ld0xhYmVscyBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8RWRpdG9yRmllbGRHcm91cD5cbiAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIkxhYmVsc1wiIGVycm9yPXtlcnJvcn0gaW52YWxpZD17ISFlcnJvcn0+XG4gICAgICAgIDxFZGl0b3JMaXN0XG4gICAgICAgICAgaXRlbXM9e2l0ZW1zfVxuICAgICAgICAgIG9uQ2hhbmdlPXtvbkxhYmVsc0NoYW5nZX1cbiAgICAgICAgICByZW5kZXJJdGVtPXsoaXRlbSwgb25DaGFuZ2VJdGVtLCBvbkRlbGV0ZSkgPT4gKFxuICAgICAgICAgICAgPExhYmVsRmlsdGVySXRlbVxuICAgICAgICAgICAgICBpdGVtPXtpdGVtfVxuICAgICAgICAgICAgICBkZWZhdWx0T3A9e2RlZmF1bHRPcH1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlSXRlbX1cbiAgICAgICAgICAgICAgb25EZWxldGU9e29uRGVsZXRlfVxuICAgICAgICAgICAgICBvbkdldExhYmVsTmFtZXM9e29uR2V0TGFiZWxOYW1lc31cbiAgICAgICAgICAgICAgb25HZXRMYWJlbFZhbHVlcz17b25HZXRMYWJlbFZhbHVlc31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgLz5cbiAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgPC9FZGl0b3JGaWVsZEdyb3VwPlxuICApO1xufVxuIiwiaW1wb3J0IHsgUmVnaXN0cnkgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgVmlzdWFsUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZpc3VhbFF1ZXJ5QmluYXJ5PFQ+IHtcbiAgb3BlcmF0b3I6IHN0cmluZztcbiAgdmVjdG9yTWF0Y2hlc1R5cGU/OiAnb24nIHwgJ2lnbm9yaW5nJztcbiAgdmVjdG9yTWF0Y2hlcz86IHN0cmluZztcbiAgcXVlcnk6IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbUxva2lWaXN1YWxRdWVyeSB7XG4gIG1ldHJpYz86IHN0cmluZztcbiAgbGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdO1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbiAgYmluYXJ5UXVlcmllcz86IEFycmF5PFZpc3VhbFF1ZXJ5QmluYXJ5PFByb21Mb2tpVmlzdWFsUXVlcnk+Pjtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UgaW1wbGVtZW50cyBWaXN1YWxRdWVyeU1vZGVsbGVyIHtcbiAgcHJvdGVjdGVkIG9wZXJhdGlvbnNSZWdpc3R5OiBSZWdpc3RyeTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+O1xuICBwcml2YXRlIGNhdGVnb3JpZXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZ2V0T3BlcmF0aW9uczogKCkgPT4gUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10pIHtcbiAgICB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5ID0gbmV3IFJlZ2lzdHJ5PFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj4oZ2V0T3BlcmF0aW9ucyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0T3BlcmF0aW9uQ2F0ZWdvcmllcyhjYXRlZ29yaWVzOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XG4gIH1cblxuICBnZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkoY2F0ZWdvcnk6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5Lmxpc3QoKS5maWx0ZXIoKG9wKSA9PiBvcC5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkgJiYgIW9wLmhpZGVGcm9tTGlzdCk7XG4gIH1cblxuICBnZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMoa2V5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zUmVnaXN0eS5saXN0KCkuZmlsdGVyKChvcCkgPT4gb3AuYWx0ZXJuYXRpdmVzS2V5ID09PSBrZXkpO1xuICB9XG5cbiAgZ2V0Q2F0ZWdvcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5jYXRlZ29yaWVzO1xuICB9XG5cbiAgZ2V0T3BlcmF0aW9uRGVmKGlkOiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5LmdldElmRXhpc3RzKGlkKTtcbiAgfVxuXG4gIHJlbmRlck9wZXJhdGlvbnMocXVlcnlTdHJpbmc6IHN0cmluZywgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW10pIHtcbiAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBvcGVyYXRpb25zKSB7XG4gICAgICBjb25zdCBkZWYgPSB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5LmdldElmRXhpc3RzKG9wZXJhdGlvbi5pZCk7XG4gICAgICBpZiAoIWRlZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIG9wZXJhdGlvbiAke29wZXJhdGlvbi5pZH0gaW4gdGhlIHJlZ2lzdHJ5YCk7XG4gICAgICB9XG4gICAgICBxdWVyeVN0cmluZyA9IGRlZi5yZW5kZXJlcihvcGVyYXRpb24sIGRlZiwgcXVlcnlTdHJpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeVN0cmluZztcbiAgfVxuXG4gIHJlbmRlckJpbmFyeVF1ZXJpZXMocXVlcnlTdHJpbmc6IHN0cmluZywgYmluYXJ5UXVlcmllcz86IEFycmF5PFZpc3VhbFF1ZXJ5QmluYXJ5PFByb21Mb2tpVmlzdWFsUXVlcnk+Pikge1xuICAgIGlmIChiaW5hcnlRdWVyaWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGJpblF1ZXJ5IG9mIGJpbmFyeVF1ZXJpZXMpIHtcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBgJHt0aGlzLnJlbmRlckJpbmFyeVF1ZXJ5KHF1ZXJ5U3RyaW5nLCBiaW5RdWVyeSl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5U3RyaW5nO1xuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJCaW5hcnlRdWVyeShsZWZ0T3BlcmFuZDogc3RyaW5nLCBiaW5hcnlRdWVyeTogVmlzdWFsUXVlcnlCaW5hcnk8UHJvbUxva2lWaXN1YWxRdWVyeT4pIHtcbiAgICBsZXQgcmVzdWx0ID0gbGVmdE9wZXJhbmQgKyBgICR7YmluYXJ5UXVlcnkub3BlcmF0b3J9IGA7XG5cbiAgICBpZiAoYmluYXJ5UXVlcnkudmVjdG9yTWF0Y2hlcykge1xuICAgICAgcmVzdWx0ICs9IGAke2JpbmFyeVF1ZXJ5LnZlY3Rvck1hdGNoZXNUeXBlfSgke2JpbmFyeVF1ZXJ5LnZlY3Rvck1hdGNoZXN9KSBgO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgKyB0aGlzLnJlbmRlclF1ZXJ5KGJpbmFyeVF1ZXJ5LnF1ZXJ5LCB0cnVlKTtcbiAgfVxuXG4gIHJlbmRlckxhYmVscyhsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10pIHtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGxldCBleHByID0gJ3snO1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGxhYmVscykge1xuICAgICAgaWYgKGV4cHIgIT09ICd7Jykge1xuICAgICAgICBleHByICs9ICcsICc7XG4gICAgICB9XG5cbiAgICAgIGV4cHIgKz0gYCR7ZmlsdGVyLmxhYmVsfSR7ZmlsdGVyLm9wfVwiJHtmaWx0ZXIudmFsdWV9XCJgO1xuICAgIH1cblxuICAgIHJldHVybiBleHByICsgYH1gO1xuICB9XG5cbiAgcmVuZGVyUXVlcnkocXVlcnk6IFByb21Mb2tpVmlzdWFsUXVlcnksIG5lc3RlZD86IGJvb2xlYW4pIHtcbiAgICBsZXQgcXVlcnlTdHJpbmcgPSBgJHtxdWVyeS5tZXRyaWMgPz8gJyd9JHt0aGlzLnJlbmRlckxhYmVscyhxdWVyeS5sYWJlbHMpfWA7XG4gICAgcXVlcnlTdHJpbmcgPSB0aGlzLnJlbmRlck9wZXJhdGlvbnMocXVlcnlTdHJpbmcsIHF1ZXJ5Lm9wZXJhdGlvbnMpO1xuXG4gICAgaWYgKCFuZXN0ZWQgJiYgdGhpcy5oYXNCaW5hcnlPcChxdWVyeSkgJiYgQm9vbGVhbihxdWVyeS5iaW5hcnlRdWVyaWVzPy5sZW5ndGgpKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IGAoJHtxdWVyeVN0cmluZ30pYDtcbiAgICB9XG5cbiAgICBxdWVyeVN0cmluZyA9IHRoaXMucmVuZGVyQmluYXJ5UXVlcmllcyhxdWVyeVN0cmluZywgcXVlcnkuYmluYXJ5UXVlcmllcyk7XG5cbiAgICBpZiAobmVzdGVkICYmICh0aGlzLmhhc0JpbmFyeU9wKHF1ZXJ5KSB8fCBCb29sZWFuKHF1ZXJ5LmJpbmFyeVF1ZXJpZXM/Lmxlbmd0aCkpKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IGAoJHtxdWVyeVN0cmluZ30pYDtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnlTdHJpbmc7XG4gIH1cblxuICBoYXNCaW5hcnlPcChxdWVyeTogUHJvbUxva2lWaXN1YWxRdWVyeSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICBxdWVyeS5vcGVyYXRpb25zLmZpbmQoKG9wKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuZ2V0T3BlcmF0aW9uRGVmKG9wLmlkKTtcbiAgICAgICAgcmV0dXJuIGRlZj8uY2F0ZWdvcnkgPT09IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcztcbiAgICAgIH0pICE9PSB1bmRlZmluZWRcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlIH0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XG5cbmltcG9ydCB7IERhdGFTb3VyY2VBcGksIEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEJ1dHRvbiwgSWNvbiwgVG9vbHRpcCwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHtcbiAgVmlzdWFsUXVlcnlNb2RlbGxlcixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLFxufSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBPcGVyYXRpb25IZWFkZXIgfSBmcm9tICcuL09wZXJhdGlvbkhlYWRlcic7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25QYXJhbUVkaXRvciB9IGZyb20gJy4vT3BlcmF0aW9uUGFyYW1FZGl0b3InO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uUGFyYW1JZCB9IGZyb20gJy4vb3BlcmF0aW9uVXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247XG4gIGluZGV4OiBudW1iZXI7XG4gIHF1ZXJ5OiBhbnk7XG4gIGRhdGFzb3VyY2U6IERhdGFTb3VyY2VBcGk7XG4gIHF1ZXJ5TW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXI7XG4gIG9uQ2hhbmdlOiAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pID0+IHZvaWQ7XG4gIG9uUmVtb3ZlOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbiAgaGlnaGxpZ2h0PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbkVkaXRvcih7XG4gIG9wZXJhdGlvbixcbiAgaW5kZXgsXG4gIG9uUmVtb3ZlLFxuICBvbkNoYW5nZSxcbiAgb25SdW5RdWVyeSxcbiAgcXVlcnlNb2RlbGxlcixcbiAgcXVlcnksXG4gIGRhdGFzb3VyY2UsXG4gIGhpZ2hsaWdodCxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgY29uc3QgZGVmID0gcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25EZWYob3BlcmF0aW9uLmlkKTtcbiAgY29uc3Qgc2hvdWxkSGlnaGxpZ2h0ID0gdXNlSGlnaGxpZ2h0KGhpZ2hsaWdodCk7XG5cbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm4gPHNwYW4+T3BlcmF0aW9uIHtvcGVyYXRpb24uaWR9IG5vdCBmb3VuZDwvc3Bhbj47XG4gIH1cblxuICBjb25zdCBvblBhcmFtVmFsdWVDaGFuZ2VkID0gKHBhcmFtSWR4OiBudW1iZXIsIHZhbHVlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7IC4uLm9wZXJhdGlvbiwgcGFyYW1zOiBbLi4ub3BlcmF0aW9uLnBhcmFtc10gfTtcbiAgICB1cGRhdGUucGFyYW1zW3BhcmFtSWR4XSA9IHZhbHVlO1xuICAgIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoZGVmLCB1cGRhdGUsIGluZGV4LCBwYXJhbUlkeCwgb25DaGFuZ2UpO1xuICB9O1xuXG4gIGNvbnN0IG9uQWRkUmVzdFBhcmFtID0gKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyAuLi5vcGVyYXRpb24sIHBhcmFtczogWy4uLm9wZXJhdGlvbi5wYXJhbXMsICcnXSB9O1xuICAgIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoZGVmLCB1cGRhdGUsIGluZGV4LCBvcGVyYXRpb24ucGFyYW1zLmxlbmd0aCwgb25DaGFuZ2UpO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVtb3ZlUmVzdFBhcmFtID0gKHBhcmFtSWR4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiA9IHtcbiAgICAgIC4uLm9wZXJhdGlvbixcbiAgICAgIHBhcmFtczogWy4uLm9wZXJhdGlvbi5wYXJhbXMuc2xpY2UoMCwgcGFyYW1JZHgpLCAuLi5vcGVyYXRpb24ucGFyYW1zLnNsaWNlKHBhcmFtSWR4ICsgMSldLFxuICAgIH07XG4gICAgY2FsbFBhcmFtQ2hhbmdlZFRoZW5PbkNoYW5nZShkZWYsIHVwZGF0ZSwgaW5kZXgsIHBhcmFtSWR4LCBvbkNoYW5nZSk7XG4gIH07XG5cbiAgY29uc3Qgb3BlcmF0aW9uRWxlbWVudHM6IFJlYWN0LlJlYWN0Tm9kZVtdID0gW107XG5cbiAgZm9yIChsZXQgcGFyYW1JbmRleCA9IDA7IHBhcmFtSW5kZXggPCBvcGVyYXRpb24ucGFyYW1zLmxlbmd0aDsgcGFyYW1JbmRleCsrKSB7XG4gICAgY29uc3QgcGFyYW1EZWYgPSBkZWYucGFyYW1zW01hdGgubWluKGRlZi5wYXJhbXMubGVuZ3RoIC0gMSwgcGFyYW1JbmRleCldO1xuICAgIGNvbnN0IEVkaXRvciA9IGdldE9wZXJhdGlvblBhcmFtRWRpdG9yKHBhcmFtRGVmKTtcblxuICAgIG9wZXJhdGlvbkVsZW1lbnRzLnB1c2goXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBhcmFtUm93fSBrZXk9e2Ake3BhcmFtSW5kZXh9LTFgfT5cbiAgICAgICAgeyFwYXJhbURlZi5oaWRlTmFtZSAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5wYXJhbU5hbWV9PlxuICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e2dldE9wZXJhdGlvblBhcmFtSWQoaW5kZXgsIHBhcmFtSW5kZXgpfT57cGFyYW1EZWYubmFtZX08L2xhYmVsPlxuICAgICAgICAgICAge3BhcmFtRGVmLmRlc2NyaXB0aW9uICYmIChcbiAgICAgICAgICAgICAgPFRvb2x0aXAgcGxhY2VtZW50PVwidG9wXCIgY29udGVudD17cGFyYW1EZWYuZGVzY3JpcHRpb259IHRoZW1lPVwiaW5mb1wiPlxuICAgICAgICAgICAgICAgIDxJY29uIG5hbWU9XCJpbmZvLWNpcmNsZVwiIHNpemU9XCJzbVwiIGNsYXNzTmFtZT17c3R5bGVzLmluZm9JY29ufSAvPlxuICAgICAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBhcmFtVmFsdWV9PlxuICAgICAgICAgIDxTdGFjayBnYXA9ezAuNX0gZGlyZWN0aW9uPVwicm93XCIgYWxpZ25JdGVtcz1cImNlbnRlclwiIHdyYXA9e2ZhbHNlfT5cbiAgICAgICAgICAgIDxFZGl0b3JcbiAgICAgICAgICAgICAgaW5kZXg9e3BhcmFtSW5kZXh9XG4gICAgICAgICAgICAgIHBhcmFtRGVmPXtwYXJhbURlZn1cbiAgICAgICAgICAgICAgdmFsdWU9e29wZXJhdGlvbi5wYXJhbXNbcGFyYW1JbmRleF19XG4gICAgICAgICAgICAgIG9wZXJhdGlvbj17b3BlcmF0aW9ufVxuICAgICAgICAgICAgICBvcGVyYXRpb25JbmRleD17aW5kZXh9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvblBhcmFtVmFsdWVDaGFuZ2VkfVxuICAgICAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge3BhcmFtRGVmLnJlc3RQYXJhbSAmJiAob3BlcmF0aW9uLnBhcmFtcy5sZW5ndGggPiBkZWYucGFyYW1zLmxlbmd0aCB8fCBwYXJhbURlZi5vcHRpb25hbCkgJiYgKFxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9e2BvcGVyYXRpb25zLiR7aW5kZXh9LnJlbW92ZS1yZXN0LXBhcmFtYH1cbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIGZpbGw9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBpY29uPVwidGltZXNcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIHRpdGxlPXtgUmVtb3ZlICR7cGFyYW1EZWYubmFtZX1gfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUmVtb3ZlUmVzdFBhcmFtKHBhcmFtSW5kZXgpfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L1N0YWNrPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICAvLyBIYW5kbGUgYWRkaW5nIGJ1dHRvbiBmb3IgcmVzdCBwYXJhbXNcbiAgbGV0IHJlc3RQYXJhbTogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkO1xuICBpZiAoZGVmLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbGFzdFBhcmFtRGVmID0gZGVmLnBhcmFtc1tkZWYucGFyYW1zLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0UGFyYW1EZWYucmVzdFBhcmFtKSB7XG4gICAgICByZXN0UGFyYW0gPSByZW5kZXJBZGRSZXN0UGFyYW1CdXR0b24obGFzdFBhcmFtRGVmLCBvbkFkZFJlc3RQYXJhbSwgaW5kZXgsIG9wZXJhdGlvbi5wYXJhbXMubGVuZ3RoLCBzdHlsZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPERyYWdnYWJsZSBkcmFnZ2FibGVJZD17YG9wZXJhdGlvbi0ke2luZGV4fWB9IGluZGV4PXtpbmRleH0+XG4gICAgICB7KHByb3ZpZGVkKSA9PiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9e2N4KHN0eWxlcy5jYXJkLCBzaG91bGRIaWdobGlnaHQgJiYgc3R5bGVzLmNhcmRIaWdobGlnaHQpfVxuICAgICAgICAgIHJlZj17cHJvdmlkZWQuaW5uZXJSZWZ9XG4gICAgICAgICAgey4uLnByb3ZpZGVkLmRyYWdnYWJsZVByb3BzfVxuICAgICAgICAgIGRhdGEtdGVzdGlkPXtgb3BlcmF0aW9ucy4ke2luZGV4fS53cmFwcGVyYH1cbiAgICAgICAgPlxuICAgICAgICAgIDxPcGVyYXRpb25IZWFkZXJcbiAgICAgICAgICAgIG9wZXJhdGlvbj17b3BlcmF0aW9ufVxuICAgICAgICAgICAgZHJhZ0hhbmRsZVByb3BzPXtwcm92aWRlZC5kcmFnSGFuZGxlUHJvcHN9XG4gICAgICAgICAgICBkZWY9e2RlZn1cbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgIG9uUmVtb3ZlPXtvblJlbW92ZX1cbiAgICAgICAgICAgIHF1ZXJ5TW9kZWxsZXI9e3F1ZXJ5TW9kZWxsZXJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PntvcGVyYXRpb25FbGVtZW50c308L2Rpdj5cbiAgICAgICAgICB7cmVzdFBhcmFtfVxuICAgICAgICAgIHtpbmRleCA8IHF1ZXJ5Lm9wZXJhdGlvbnMubGVuZ3RoIC0gMSAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmFycm93fT5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5hcnJvd0xpbmV9IC8+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYXJyb3dBcnJvd30gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L0RyYWdnYWJsZT5cbiAgKTtcbn1cblxuLyoqXG4gKiBXaGVuIGhpZ2hsaWdodCBpcyBzd2l0Y2hlZCBvbiBtYWtlcyBzdXJlIGl0IGlzIHN3aXRjaGVkIG9mIHJpZ2h0IGF3YXksIHNvIHdlIGp1c3QgZmxhc2ggdGhlIGhpZ2hsaWdodCBhbmQgdGhlbiBmYWRlXG4gKiBvdXQuXG4gKiBAcGFyYW0gaGlnaGxpZ2h0XG4gKi9cbmZ1bmN0aW9uIHVzZUhpZ2hsaWdodChoaWdobGlnaHQ/OiBib29sZWFuKSB7XG4gIGNvbnN0IFtrZWVwSGlnaGxpZ2h0LCBzZXRLZWVwSGlnaGxpZ2h0XSA9IHVzZVN0YXRlKHRydWUpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB0OiBhbnk7XG4gICAgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRLZWVwSGlnaGxpZ2h0KGZhbHNlKTtcbiAgICAgIH0sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRLZWVwSGlnaGxpZ2h0KHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodCk7XG4gIH0sIFtoaWdobGlnaHRdKTtcblxuICByZXR1cm4ga2VlcEhpZ2hsaWdodCAmJiBoaWdobGlnaHQ7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFkZFJlc3RQYXJhbUJ1dHRvbihcbiAgcGFyYW1EZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLFxuICBvbkFkZFJlc3RQYXJhbTogKCkgPT4gdm9pZCxcbiAgb3BlcmF0aW9uSW5kZXg6IG51bWJlcixcbiAgcGFyYW1JbmRleDogbnVtYmVyLFxuICBzdHlsZXM6IE9wZXJhdGlvbkVkaXRvclN0eWxlc1xuKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5yZXN0UGFyYW19IGtleT17YCR7cGFyYW1JbmRleH0tMmB9PlxuICAgICAgPEJ1dHRvblxuICAgICAgICBzaXplPVwic21cIlxuICAgICAgICBpY29uPVwicGx1c1wiXG4gICAgICAgIHRpdGxlPXtgQWRkICR7cGFyYW1EZWYubmFtZX1gfVxuICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgb25DbGljaz17b25BZGRSZXN0UGFyYW19XG4gICAgICAgIGRhdGEtdGVzdGlkPXtgb3BlcmF0aW9ucy4ke29wZXJhdGlvbkluZGV4fS5hZGQtcmVzdC1wYXJhbWB9XG4gICAgICA+XG4gICAgICAgIHtwYXJhbURlZi5uYW1lfVxuICAgICAgPC9CdXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgb3BlcmF0aW9uSW5kZXg6IG51bWJlcixcbiAgcGFyYW1JbmRleDogbnVtYmVyLFxuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB2b2lkXG4pIHtcbiAgaWYgKGRlZi5wYXJhbUNoYW5nZWRIYW5kbGVyKSB7XG4gICAgb25DaGFuZ2Uob3BlcmF0aW9uSW5kZXgsIGRlZi5wYXJhbUNoYW5nZWRIYW5kbGVyKHBhcmFtSW5kZXgsIG9wZXJhdGlvbiwgZGVmKSk7XG4gIH0gZWxzZSB7XG4gICAgb25DaGFuZ2Uob3BlcmF0aW9uSW5kZXgsIG9wZXJhdGlvbik7XG4gIH1cbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY2FyZDogY3NzKHtcbiAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnksXG4gICAgICBib3JkZXI6IGAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuYm9yZGVyLm1lZGl1bX1gLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICBjdXJzb3I6ICdncmFiJyxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKDEpLFxuICAgICAgbWFyZ2luQm90dG9tOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDFzIGVhc2UtaW4gMHMnLFxuICAgIH0pLFxuICAgIGNhcmRIaWdobGlnaHQ6IGNzcyh7XG4gICAgICBib3hTaGFkb3c6IGAwcHggMHB4IDRweCAwcHggJHt0aGVtZS5jb2xvcnMucHJpbWFyeS5ib3JkZXJ9YCxcbiAgICAgIGJvcmRlcjogYDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5wcmltYXJ5LmJvcmRlcn1gLFxuICAgIH0pLFxuICAgIGluZm9JY29uOiBjc3Moe1xuICAgICAgbWFyZ2luTGVmdDogdGhlbWUuc3BhY2luZygwLjUpLFxuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgICc6aG92ZXInOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5LFxuICAgICAgfSxcbiAgICB9KSxcbiAgICBib2R5OiBjc3Moe1xuICAgICAgbWFyZ2luOiB0aGVtZS5zcGFjaW5nKDEsIDEsIDAuNSwgMSksXG4gICAgICBkaXNwbGF5OiAndGFibGUnLFxuICAgIH0pLFxuICAgIHBhcmFtUm93OiBjc3Moe1xuICAgICAgbGFiZWw6ICdwYXJhbVJvdycsXG4gICAgICBkaXNwbGF5OiAndGFibGUtcm93JyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgIH0pLFxuICAgIHBhcmFtTmFtZTogY3NzKHtcbiAgICAgIGRpc3BsYXk6ICd0YWJsZS1jZWxsJyxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMCwgMSwgMCwgMCksXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgIGhlaWdodDogJzMycHgnLFxuICAgIH0pLFxuICAgIHBhcmFtVmFsdWU6IGNzcyh7XG4gICAgICBsYWJlbDogJ3BhcmFtVmFsdWUnLFxuICAgICAgZGlzcGxheTogJ3RhYmxlLWNlbGwnLFxuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgfSksXG4gICAgcmVzdFBhcmFtOiBjc3Moe1xuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZygwLCAxLCAxLCAxKSxcbiAgICB9KSxcbiAgICBhcnJvdzogY3NzKHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICByaWdodDogJy0xOHB4JyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICB9KSxcbiAgICBhcnJvd0xpbmU6IGNzcyh7XG4gICAgICBoZWlnaHQ6ICcycHgnLFxuICAgICAgd2lkdGg6ICc4cHgnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5jb2xvcnMuYm9yZGVyLnN0cm9uZyxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgdG9wOiAnMTRweCcsXG4gICAgfSksXG4gICAgYXJyb3dBcnJvdzogY3NzKHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgYm9yZGVyVG9wOiBgNXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgIGJvcmRlckJvdHRvbTogYDVweCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICBib3JkZXJMZWZ0OiBgN3B4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5zdHJvbmd9YCxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgdG9wOiAnMTBweCcsXG4gICAgfSksXG4gIH07XG59O1xuXG50eXBlIE9wZXJhdGlvbkVkaXRvclN0eWxlcyA9IFJldHVyblR5cGU8dHlwZW9mIGdldFN0eWxlcz47XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgcmVuZGVyTWFya2Rvd24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICB0aXRsZT86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIG1hcmtkb3duPzogc3RyaW5nO1xuICBzdGVwTnVtYmVyPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlcmF0aW9uRXhwbGFpbmVkQm94KHsgdGl0bGUsIHN0ZXBOdW1iZXIsIG1hcmtkb3duLCBjaGlsZHJlbiB9OiBQcm9wcykge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJveH0+XG4gICAgICB7c3RlcE51bWJlciAhPT0gdW5kZWZpbmVkICYmIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3RlcE51bWJlcn0+e3N0ZXBOdW1iZXJ9PC9kaXY+fVxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ib3hJbm5lcn0+XG4gICAgICAgIHt0aXRsZSAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5oZWFkZXJ9PlxuICAgICAgICAgICAgPHNwYW4+e3RpdGxlfTwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ib2R5fT5cbiAgICAgICAgICB7bWFya2Rvd24gJiYgPGRpdiBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IHJlbmRlck1hcmtkb3duKG1hcmtkb3duKSB9fT48L2Rpdj59XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBib3g6IGNzcyh7XG4gICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWNvbmRhcnksXG4gICAgICBwYWRkaW5nOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5zaGFwZS5ib3JkZXJSYWRpdXMoKSxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIH0pLFxuICAgIGJveElubmVyOiBjc3Moe1xuICAgICAgbWFyZ2luTGVmdDogdGhlbWUuc3BhY2luZyg0KSxcbiAgICB9KSxcbiAgICBzdGVwTnVtYmVyOiBjc3Moe1xuICAgICAgZm9udFdlaWdodDogdGhlbWUudHlwb2dyYXBoeS5mb250V2VpZ2h0TWVkaXVtLFxuICAgICAgYmFja2dyb3VuZDogdGhlbWUuY29sb3JzLnNlY29uZGFyeS5tYWluLFxuICAgICAgd2lkdGg6ICcyMHB4JyxcbiAgICAgIGhlaWdodDogJzIwcHgnLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3A6ICcxMHB4JyxcbiAgICAgIGxlZnQ6ICcxMXB4JyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICB9KSxcbiAgICBoZWFkZXI6IGNzcyh7XG4gICAgICBwYWRkaW5nQm90dG9tOiB0aGVtZS5zcGFjaW5nKDAuNSksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseU1vbm9zcGFjZSxcbiAgICB9KSxcbiAgICBib2R5OiBjc3Moe1xuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgICdwOmxhc3QtY2hpbGQnOiB7XG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgIH0sXG4gICAgICBhOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5saW5rLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ3VuZGVybGluZScsXG4gICAgICB9LFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIsIFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRmxleEl0ZW0gfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgQnV0dG9uLCBTZWxlY3QsIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IE9wZXJhdGlvbkluZm9CdXR0b24gfSBmcm9tICcuL09wZXJhdGlvbkluZm9CdXR0b24nO1xuaW1wb3J0IHsgVmlzdWFsUXVlcnlNb2RlbGxlciwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgZHJhZ0hhbmRsZVByb3BzOiBhbnk7XG4gIG9uQ2hhbmdlOiAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pID0+IHZvaWQ7XG4gIG9uUmVtb3ZlOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFN0YXRlIHtcbiAgaXNPcGVuPzogYm9vbGVhbjtcbiAgYWx0ZXJuYXRpdmVzPzogQXJyYXk8U2VsZWN0YWJsZVZhbHVlPFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj4+O1xufVxuXG5leHBvcnQgY29uc3QgT3BlcmF0aW9uSGVhZGVyID0gUmVhY3QubWVtbzxQcm9wcz4oXG4gICh7IG9wZXJhdGlvbiwgZGVmLCBpbmRleCwgb25DaGFuZ2UsIG9uUmVtb3ZlLCBxdWVyeU1vZGVsbGVyLCBkcmFnSGFuZGxlUHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPFN0YXRlPih7fSk7XG5cbiAgICBjb25zdCBvblRvZ2dsZVN3aXRjaGVyID0gKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlLmlzT3Blbikge1xuICAgICAgICBzZXRTdGF0ZSh7IC4uLnN0YXRlLCBpc09wZW46IGZhbHNlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWx0ZXJuYXRpdmVzID0gcXVlcnlNb2RlbGxlclxuICAgICAgICAgIC5nZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMoZGVmLmFsdGVybmF0aXZlc0tleSEpXG4gICAgICAgICAgLm1hcCgoYWx0KSA9PiAoeyBsYWJlbDogYWx0Lm5hbWUsIHZhbHVlOiBhbHQgfSkpO1xuICAgICAgICBzZXRTdGF0ZSh7IGlzT3BlbjogdHJ1ZSwgYWx0ZXJuYXRpdmVzIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5oZWFkZXJ9PlxuICAgICAgICB7IXN0YXRlLmlzT3BlbiAmJiAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDxkaXYgey4uLmRyYWdIYW5kbGVQcm9wc30+e2RlZi5uYW1lID8/IGRlZi5pZH08L2Rpdj5cbiAgICAgICAgICAgIDxGbGV4SXRlbSBncm93PXsxfSAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3N0eWxlcy5vcGVyYXRpb25IZWFkZXJCdXR0b25zfSBvcGVyYXRpb24taGVhZGVyLXNob3ctb24taG92ZXJgfT5cbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIGljb249XCJhbmdsZS1kb3duXCJcbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uVG9nZ2xlU3dpdGNoZXJ9XG4gICAgICAgICAgICAgICAgZmlsbD1cInRleHRcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIHRpdGxlPVwiQ2xpY2sgdG8gdmlldyBhbHRlcm5hdGl2ZSBvcGVyYXRpb25zXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPE9wZXJhdGlvbkluZm9CdXR0b24gZGVmPXtkZWZ9IG9wZXJhdGlvbj17b3BlcmF0aW9ufSAvPlxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgaWNvbj1cInRpbWVzXCJcbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUmVtb3ZlKGluZGV4KX1cbiAgICAgICAgICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJSZW1vdmUgb3BlcmF0aW9uXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgICB7c3RhdGUuaXNPcGVuICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNlbGVjdFdyYXBwZXJ9PlxuICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICBhdXRvRm9jdXNcbiAgICAgICAgICAgICAgb3Blbk1lbnVPbkZvY3VzXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiUmVwbGFjZSB3aXRoXCJcbiAgICAgICAgICAgICAgb3B0aW9ucz17c3RhdGUuYWx0ZXJuYXRpdmVzfVxuICAgICAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgICAgIG9uQ2xvc2VNZW51PXtvblRvZ2dsZVN3aXRjaGVyfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBPcGVyYXRpb24gc2hvdWxkIGV4aXN0IGlmIGl0IGlzIHNlbGVjdGFibGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RlZiA9IHF1ZXJ5TW9kZWxsZXIuZ2V0T3BlcmF0aW9uRGVmKHZhbHVlLnZhbHVlLmlkKSE7XG4gICAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZE9wID0geyAuLi5vcGVyYXRpb24sIGlkOiB2YWx1ZS52YWx1ZS5pZCB9O1xuICAgICAgICAgICAgICAgICAgb25DaGFuZ2UoaW5kZXgsIGRlZi5jaGFuZ2VUeXBlSGFuZGxlciA/IGRlZi5jaGFuZ2VUeXBlSGFuZGxlcihjaGFuZ2VkT3AsIG5ld0RlZikgOiBjaGFuZ2VkT3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG4pO1xuXG5PcGVyYXRpb25IZWFkZXIuZGlzcGxheU5hbWUgPSAnT3BlcmF0aW9uSGVhZGVyJztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgaGVhZGVyOiBjc3Moe1xuICAgICAgYm9yZGVyQm90dG9tOiBgMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5tZWRpdW19YCxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMC41LCAwLjUsIDAuNSwgMSksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICcmOmhvdmVyIC5vcGVyYXRpb24taGVhZGVyLXNob3ctb24taG92ZXInOiBjc3Moe1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgfSksXG4gICAgfSksXG4gICAgb3BlcmF0aW9uSGVhZGVyQnV0dG9uczogY3NzKHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoWydvcGFjaXR5J10sIHtcbiAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0LFxuICAgICAgfSksXG4gICAgfSksXG4gICAgc2VsZWN0V3JhcHBlcjogY3NzKHtcbiAgICAgIHBhZGRpbmdSaWdodDogdGhlbWUuc3BhY2luZygyKSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUG9wcGVyVG9vbHRpcCB9IGZyb20gJ3JlYWN0LXBvcHBlci10b29sdGlwJztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgcmVuZGVyTWFya2Rvd24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEZsZXhJdGVtIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEJ1dHRvbiwgUG9ydGFsLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247XG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmO1xufVxuXG5leHBvcnQgY29uc3QgT3BlcmF0aW9uSW5mb0J1dHRvbiA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IGRlZiwgb3BlcmF0aW9uIH0pID0+IHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuICBjb25zdCBbc2hvdywgc2V0U2hvd10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHsgZ2V0VG9vbHRpcFByb3BzLCBzZXRUb29sdGlwUmVmLCBzZXRUcmlnZ2VyUmVmLCB2aXNpYmxlIH0gPSB1c2VQb3BwZXJUb29sdGlwKHtcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHZpc2libGU6IHNob3csXG4gICAgb2Zmc2V0OiBbMCwgMTZdLFxuICAgIG9uVmlzaWJsZUNoYW5nZTogc2V0U2hvdyxcbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICB0cmlnZ2VyOiBbJ2NsaWNrJ10sXG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxCdXR0b25cbiAgICAgICAgdGl0bGU9XCJDbGljayB0byBzaG93IGRlc2NyaXB0aW9uXCJcbiAgICAgICAgcmVmPXtzZXRUcmlnZ2VyUmVmfVxuICAgICAgICBpY29uPVwiaW5mby1jaXJjbGVcIlxuICAgICAgICBzaXplPVwic21cIlxuICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgZmlsbD1cInRleHRcIlxuICAgICAgLz5cbiAgICAgIHt2aXNpYmxlICYmIChcbiAgICAgICAgPFBvcnRhbD5cbiAgICAgICAgICA8ZGl2IHJlZj17c2V0VG9vbHRpcFJlZn0gey4uLmdldFRvb2x0aXBQcm9wcygpfSBjbGFzc05hbWU9e3N0eWxlcy5kb2NCb3h9PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kb2NCb3hIZWFkZXJ9PlxuICAgICAgICAgICAgICA8c3Bhbj57ZGVmLnJlbmRlcmVyKG9wZXJhdGlvbiwgZGVmLCAnPGV4cHI+Jyl9PC9zcGFuPlxuICAgICAgICAgICAgICA8RmxleEl0ZW0gZ3Jvdz17MX0gLz5cbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIGljb249XCJ0aW1lc1wiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2hvdyhmYWxzZSl9XG4gICAgICAgICAgICAgICAgZmlsbD1cInRleHRcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIHRpdGxlPVwiUmVtb3ZlIG9wZXJhdGlvblwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuZG9jQm94Qm9keX1cbiAgICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBnZXRPcGVyYXRpb25Eb2NzKGRlZiwgb3BlcmF0aW9uKSB9fVxuICAgICAgICAgICAgPjwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L1BvcnRhbD5cbiAgICAgICl9XG4gICAgPC8+XG4gICk7XG59KTtcblxuT3BlcmF0aW9uSW5mb0J1dHRvbi5kaXNwbGF5TmFtZSA9ICdPcGVyYXRpb25Eb2NzJztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZG9jQm94OiBjc3Moe1xuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgYmFja2dyb3VuZDogdGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeSxcbiAgICAgIGJvcmRlcjogYDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ib3JkZXIuc3Ryb25nfWAsXG4gICAgICBib3hTaGFkb3c6IHRoZW1lLnNoYWRvd3MuejMsXG4gICAgICBtYXhXaWR0aDogJzYwMHB4JyxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgICBib3JkZXJSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cygpLFxuICAgICAgekluZGV4OiB0aGVtZS56SW5kZXgudG9vbHRpcCxcbiAgICB9KSxcbiAgICBkb2NCb3hIZWFkZXI6IGNzcyh7XG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5oNS5mb250U2l6ZSxcbiAgICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseU1vbm9zcGFjZSxcbiAgICAgIHBhZGRpbmdCb3R0b206IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICB9KSxcbiAgICBkb2NCb3hCb2R5OiBjc3Moe1xuICAgICAgLy8gVGhlIG1hcmtkb3duIHBhcmFncmFwaCBoYXMgYSBtYXJnaW5Cb3R0b20gdGhpcyByZW1vdmVzIGl0XG4gICAgICBtYXJnaW5Cb3R0b206IHRoZW1lLnNwYWNpbmcoLTEpLFxuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICB9KSxcbiAgICBzaWduYXR1cmU6IGNzcyh7XG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBmb250RmFtaWx5OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHlNb25vc3BhY2UsXG4gICAgfSksXG4gICAgZHJvcGRvd246IGNzcyh7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICB9KSxcbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25Eb2NzKGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKTogc3RyaW5nIHtcbiAgcmV0dXJuIHJlbmRlck1hcmtkb3duKGRlZi5leHBsYWluSGFuZGxlciA/IGRlZi5leHBsYWluSGFuZGxlcihvcCwgZGVmKSA6IGRlZi5kb2N1bWVudGF0aW9uID8/ICdubyBkb2NzJyk7XG59XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRHJhZ0Ryb3BDb250ZXh0LCBEcm9wcGFibGUsIERyb3BSZXN1bHQgfSBmcm9tICdyZWFjdC1iZWF1dGlmdWwtZG5kJztcbmltcG9ydCB7IHVzZU1vdW50ZWRTdGF0ZSwgdXNlUHJldmlvdXMgfSBmcm9tICdyZWFjdC11c2UnO1xuXG5pbXBvcnQgeyBEYXRhU291cmNlQXBpLCBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBCdXR0b24sIENhc2NhZGVyLCBDYXNjYWRlck9wdGlvbiwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBRdWVyeVdpdGhPcGVyYXRpb25zLCBWaXN1YWxRdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuaW1wb3J0IHsgT3BlcmF0aW9uRWRpdG9yIH0gZnJvbSAnLi9PcGVyYXRpb25FZGl0b3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzPFQgZXh0ZW5kcyBRdWVyeVdpdGhPcGVyYXRpb25zPiB7XG4gIHF1ZXJ5OiBUO1xuICBkYXRhc291cmNlOiBEYXRhU291cmNlQXBpO1xuICBvbkNoYW5nZTogKHF1ZXJ5OiBUKSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xuICBxdWVyeU1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyO1xuICBleHBsYWluTW9kZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBPcGVyYXRpb25MaXN0PFQgZXh0ZW5kcyBRdWVyeVdpdGhPcGVyYXRpb25zPih7XG4gIHF1ZXJ5LFxuICBkYXRhc291cmNlLFxuICBxdWVyeU1vZGVsbGVyLFxuICBvbkNoYW5nZSxcbiAgb25SdW5RdWVyeSxcbn06IFByb3BzPFQ+KSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgY29uc3QgeyBvcGVyYXRpb25zIH0gPSBxdWVyeTtcblxuICBjb25zdCBvcHNUb0hpZ2hsaWdodCA9IHVzZU9wZXJhdGlvbnNIaWdobGlnaHQob3BlcmF0aW9ucyk7XG5cbiAgY29uc3QgW2Nhc2NhZGVyT3Blbiwgc2V0Q2FzY2FkZXJPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICBjb25zdCBvbk9wZXJhdGlvbkNoYW5nZSA9IChpbmRleDogbnVtYmVyLCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWRMaXN0ID0gWy4uLm9wZXJhdGlvbnNdO1xuICAgIHVwZGF0ZWRMaXN0LnNwbGljZShpbmRleCwgMSwgdXBkYXRlKTtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBvcGVyYXRpb25zOiB1cGRhdGVkTGlzdCB9KTtcbiAgfTtcblxuICBjb25zdCBvblJlbW92ZSA9IChpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZExpc3QgPSBbLi4ub3BlcmF0aW9ucy5zbGljZSgwLCBpbmRleCksIC4uLm9wZXJhdGlvbnMuc2xpY2UoaW5kZXggKyAxKV07XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgb3BlcmF0aW9uczogdXBkYXRlZExpc3QgfSk7XG4gIH07XG5cbiAgY29uc3QgYWRkT3B0aW9uczogQ2FzY2FkZXJPcHRpb25bXSA9IHF1ZXJ5TW9kZWxsZXIuZ2V0Q2F0ZWdvcmllcygpLm1hcCgoY2F0ZWdvcnkpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGNhdGVnb3J5LFxuICAgICAgbGFiZWw6IGNhdGVnb3J5LFxuICAgICAgaXRlbXM6IHF1ZXJ5TW9kZWxsZXIuZ2V0T3BlcmF0aW9uc0ZvckNhdGVnb3J5KGNhdGVnb3J5KS5tYXAoKG9wZXJhdGlvbikgPT4gKHtcbiAgICAgICAgdmFsdWU6IG9wZXJhdGlvbi5pZCxcbiAgICAgICAgbGFiZWw6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICBpc0xlYWY6IHRydWUsXG4gICAgICB9KSksXG4gICAgfTtcbiAgfSk7XG5cbiAgY29uc3Qgb25BZGRPcGVyYXRpb24gPSAodmFsdWU6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IG9wZXJhdGlvbkRlZiA9IHF1ZXJ5TW9kZWxsZXIuZ2V0T3BlcmF0aW9uRGVmKHZhbHVlKTtcbiAgICBpZiAoIW9wZXJhdGlvbkRlZikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvbkNoYW5nZShvcGVyYXRpb25EZWYuYWRkT3BlcmF0aW9uSGFuZGxlcihvcGVyYXRpb25EZWYsIHF1ZXJ5LCBxdWVyeU1vZGVsbGVyKSk7XG4gICAgc2V0Q2FzY2FkZXJPcGVuKGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBvbkRyYWdFbmQgPSAocmVzdWx0OiBEcm9wUmVzdWx0KSA9PiB7XG4gICAgaWYgKCFyZXN1bHQuZGVzdGluYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVkTGlzdCA9IFsuLi5vcGVyYXRpb25zXTtcbiAgICBjb25zdCBlbGVtZW50ID0gdXBkYXRlZExpc3RbcmVzdWx0LnNvdXJjZS5pbmRleF07XG4gICAgdXBkYXRlZExpc3Quc3BsaWNlKHJlc3VsdC5zb3VyY2UuaW5kZXgsIDEpO1xuICAgIHVwZGF0ZWRMaXN0LnNwbGljZShyZXN1bHQuZGVzdGluYXRpb24uaW5kZXgsIDAsIGVsZW1lbnQpO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIG9wZXJhdGlvbnM6IHVwZGF0ZWRMaXN0IH0pO1xuICB9O1xuXG4gIGNvbnN0IG9uQ2FzY2FkZXJCbHVyID0gKCkgPT4ge1xuICAgIHNldENhc2NhZGVyT3BlbihmYWxzZSk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZ2FwPXsxfSBkaXJlY3Rpb249XCJjb2x1bW5cIj5cbiAgICAgIDxTdGFjayBnYXA9ezF9PlxuICAgICAgICB7b3BlcmF0aW9ucy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICA8RHJhZ0Ryb3BDb250ZXh0IG9uRHJhZ0VuZD17b25EcmFnRW5kfT5cbiAgICAgICAgICAgIDxEcm9wcGFibGUgZHJvcHBhYmxlSWQ9XCJzb3J0YWJsZS1maWVsZC1tYXBwaW5nc1wiIGRpcmVjdGlvbj1cImhvcml6b250YWxcIj5cbiAgICAgICAgICAgICAgeyhwcm92aWRlZCkgPT4gKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMub3BlcmF0aW9uTGlzdH0gcmVmPXtwcm92aWRlZC5pbm5lclJlZn0gey4uLnByb3ZpZGVkLmRyb3BwYWJsZVByb3BzfT5cbiAgICAgICAgICAgICAgICAgIHtvcGVyYXRpb25zLm1hcCgob3AsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxPcGVyYXRpb25FZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgICBrZXk9e29wLmlkICsgaW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgcXVlcnlNb2RlbGxlcj17cXVlcnlNb2RlbGxlcn1cbiAgICAgICAgICAgICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uPXtvcH1cbiAgICAgICAgICAgICAgICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25PcGVyYXRpb25DaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgb25SZW1vdmU9e29uUmVtb3ZlfVxuICAgICAgICAgICAgICAgICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0PXtvcHNUb0hpZ2hsaWdodFtpbmRleF19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICAgIHtwcm92aWRlZC5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvRHJvcHBhYmxlPlxuICAgICAgICAgIDwvRHJhZ0Ryb3BDb250ZXh0PlxuICAgICAgICApfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmFkZEJ1dHRvbn0+XG4gICAgICAgICAge2Nhc2NhZGVyT3BlbiA/IChcbiAgICAgICAgICAgIDxDYXNjYWRlclxuICAgICAgICAgICAgICBvcHRpb25zPXthZGRPcHRpb25zfVxuICAgICAgICAgICAgICBvblNlbGVjdD17b25BZGRPcGVyYXRpb259XG4gICAgICAgICAgICAgIG9uQmx1cj17b25DYXNjYWRlckJsdXJ9XG4gICAgICAgICAgICAgIGF1dG9Gb2N1cz17dHJ1ZX1cbiAgICAgICAgICAgICAgYWx3YXlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICAgICAgaGlkZUFjdGl2ZUxldmVsTGFiZWw9e3RydWV9XG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXsnU2VhcmNoJ31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxCdXR0b24gaWNvbj17J3BsdXMnfSB2YXJpYW50PXsnc2Vjb25kYXJ5J30gb25DbGljaz17KCkgPT4gc2V0Q2FzY2FkZXJPcGVuKHRydWUpfSB0aXRsZT17J0FkZCBvcGVyYXRpb24nfT5cbiAgICAgICAgICAgICAgT3BlcmF0aW9uc1xuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L1N0YWNrPlxuICAgIDwvU3RhY2s+XG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyBpbmRleGVzIG9mIG9wZXJhdGlvbnMgdGhhdCBzaG91bGQgYmUgaGlnaGxpZ2h0ZWQuIFdlIGNoZWNrIHRoZSBkaWZmIG9mIG9wZXJhdGlvbnMgYWRkZWQgYnV0IGF0IHRoZSBzYW1lIHRpbWVcbiAqIHdlIHdhbnQgdG8gaGlnaGxpZ2h0IG9wZXJhdGlvbnMgb25seSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXIsIHNvIHdlIGNoZWNrIGZvciBtb3VudGVkIHN0YXRlIGFuZCBjYWxjdWxhdGUgdGhlIGRpZmZcbiAqIG9ubHkgYWZ0ZXIuXG4gKiBAcGFyYW0gb3BlcmF0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VPcGVyYXRpb25zSGlnaGxpZ2h0KG9wZXJhdGlvbnM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbltdKSB7XG4gIGNvbnN0IGlzTW91bnRlZCA9IHVzZU1vdW50ZWRTdGF0ZSgpO1xuICBjb25zdCBwcmV2T3BlcmF0aW9ucyA9IHVzZVByZXZpb3VzKG9wZXJhdGlvbnMpO1xuXG4gIGlmICghaXNNb3VudGVkKCkpIHtcbiAgICByZXR1cm4gb3BlcmF0aW9ucy5tYXAoKCkgPT4gZmFsc2UpO1xuICB9XG5cbiAgaWYgKCFwcmV2T3BlcmF0aW9ucykge1xuICAgIHJldHVybiBvcGVyYXRpb25zLm1hcCgoKSA9PiB0cnVlKTtcbiAgfVxuXG4gIGxldCBuZXdPcHM6IGJvb2xlYW5bXSA9IFtdO1xuXG4gIGlmIChwcmV2T3BlcmF0aW9ucy5sZW5ndGggLSAxID09PSBvcGVyYXRpb25zLmxlbmd0aCAmJiBvcGVyYXRpb25zLmV2ZXJ5KChvcCkgPT4gcHJldk9wZXJhdGlvbnMuaW5jbHVkZXMob3ApKSkge1xuICAgIC8vIEluIGNhc2Ugd2UgcmVtb3ZlIG9uZSBvcCBhbmQgZG9lcyBub3QgY2hhbmdlIGFueSBvcHMgdGhlbiBkb24ndCBoaWdobGlnaHQgYW55dGhpbmcuXG4gICAgcmV0dXJuIG9wZXJhdGlvbnMubWFwKCgpID0+IGZhbHNlKTtcbiAgfVxuICBpZiAocHJldk9wZXJhdGlvbnMubGVuZ3RoICsgMSA9PT0gb3BlcmF0aW9ucy5sZW5ndGggJiYgcHJldk9wZXJhdGlvbnMuZXZlcnkoKG9wKSA9PiBvcGVyYXRpb25zLmluY2x1ZGVzKG9wKSkpIHtcbiAgICAvLyBJZiB3ZSBhZGQgYSBzaW5nbGUgb3AganVzdCBmaW5kIGl0IGFuZCBoaWdobGlnaHQganVzdCB0aGF0LlxuICAgIGNvbnN0IG5ld09wID0gb3BlcmF0aW9ucy5maW5kKChvcCkgPT4gIXByZXZPcGVyYXRpb25zLmluY2x1ZGVzKG9wKSk7XG4gICAgbmV3T3BzID0gb3BlcmF0aW9ucy5tYXAoKG9wKSA9PiB7XG4gICAgICByZXR1cm4gb3AgPT09IG5ld09wO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIERlZmF1bHQgZGlmZiBvZiBhbGwgb3BzLlxuICAgIG5ld09wcyA9IG9wZXJhdGlvbnMubWFwKChvcCwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiAhaXNTYW1lT3Aob3AuaWQsIHByZXZPcGVyYXRpb25zW2luZGV4XT8uaWQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXdPcHM7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9wKG9wMT86IHN0cmluZywgb3AyPzogc3RyaW5nKSB7XG4gIHJldHVybiBvcDEgPT09IG9wMiB8fCBgX18ke29wMX1fYnlgID09PSBvcDIgfHwgb3AxID09PSBgX18ke29wMn1fYnlgO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBoZWFkaW5nOiBjc3Moe1xuICAgICAgbGFiZWw6ICdoZWFkaW5nJyxcbiAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgIGZvbnRXZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIG1hcmdpbkJvdHRvbTogMCxcbiAgICB9KSxcbiAgICBvcGVyYXRpb25MaXN0OiBjc3Moe1xuICAgICAgbGFiZWw6ICdvcGVyYXRpb25MaXN0JyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXhXcmFwOiAnd3JhcCcsXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgfSksXG4gICAgYWRkQnV0dG9uOiBjc3Moe1xuICAgICAgbGFiZWw6ICdhZGRCdXR0b24nLFxuICAgICAgd2lkdGg6IDEyNixcbiAgICAgIHBhZGRpbmdCb3R0b206IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgR3JhbW1hciB9IGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgT3BlcmF0aW9uRXhwbGFpbmVkQm94IH0gZnJvbSAnLi9PcGVyYXRpb25FeHBsYWluZWRCb3gnO1xuaW1wb3J0IHsgUmF3UXVlcnkgfSBmcm9tICcuL1Jhd1F1ZXJ5JztcbmltcG9ydCB7IFF1ZXJ5V2l0aE9wZXJhdGlvbnMsIFZpc3VhbFF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wczxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4ge1xuICBxdWVyeTogVDtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgZXhwbGFpbk1vZGU/OiBib29sZWFuO1xuICBzdGVwTnVtYmVyOiBudW1iZXI7XG4gIGxhbmc6IHtcbiAgICBncmFtbWFyOiBHcmFtbWFyO1xuICAgIG5hbWU6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbkxpc3RFeHBsYWluZWQ8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KHtcbiAgcXVlcnksXG4gIHF1ZXJ5TW9kZWxsZXIsXG4gIHN0ZXBOdW1iZXIsXG4gIGxhbmcsXG59OiBQcm9wczxUPikge1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7cXVlcnkub3BlcmF0aW9ucy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBkZWYgPSBxdWVyeU1vZGVsbGVyLmdldE9wZXJhdGlvbkRlZihvcC5pZCk7XG4gICAgICAgIGlmICghZGVmKSB7XG4gICAgICAgICAgcmV0dXJuIGBPcGVyYXRpb24gJHtvcC5pZH0gbm90IGZvdW5kYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aXRsZSA9IGRlZi5yZW5kZXJlcihvcCwgZGVmLCAnPGV4cHI+Jyk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBkZWYuZXhwbGFpbkhhbmRsZXIgPyBkZWYuZXhwbGFpbkhhbmRsZXIob3AsIGRlZikgOiBkZWYuZG9jdW1lbnRhdGlvbiA/PyAnbm8gZG9jcyc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8T3BlcmF0aW9uRXhwbGFpbmVkQm94XG4gICAgICAgICAgICBzdGVwTnVtYmVyPXtpbmRleCArIHN0ZXBOdW1iZXJ9XG4gICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgdGl0bGU9ezxSYXdRdWVyeSBxdWVyeT17dGl0bGV9IGxhbmc9e2xhbmd9IC8+fVxuICAgICAgICAgICAgbWFya2Rvd249e2JvZHl9XG4gICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSwgdG9PcHRpb24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEF1dG9TaXplSW5wdXQsIENoZWNrYm94LCBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uUGFyYW1JZCB9IGZyb20gJy4vb3BlcmF0aW9uVXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlcmF0aW9uUGFyYW1FZGl0b3IoXG4gIHBhcmFtRGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZlxuKTogQ29tcG9uZW50VHlwZTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzPiB7XG4gIGlmIChwYXJhbURlZi5lZGl0b3IpIHtcbiAgICByZXR1cm4gcGFyYW1EZWYuZWRpdG9yO1xuICB9XG5cbiAgaWYgKHBhcmFtRGVmLm9wdGlvbnMpIHtcbiAgICByZXR1cm4gU2VsZWN0SW5wdXRQYXJhbUVkaXRvcjtcbiAgfVxuXG4gIHN3aXRjaCAocGFyYW1EZWYudHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIEJvb2xJbnB1dFBhcmFtRWRpdG9yO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFNpbXBsZUlucHV0UGFyYW1FZGl0b3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gU2ltcGxlSW5wdXRQYXJhbUVkaXRvcihwcm9wczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxBdXRvU2l6ZUlucHV0XG4gICAgICBpZD17Z2V0T3BlcmF0aW9uUGFyYW1JZChwcm9wcy5vcGVyYXRpb25JbmRleCwgcHJvcHMuaW5kZXgpfVxuICAgICAgZGVmYXVsdFZhbHVlPXtwcm9wcy52YWx1ZT8udG9TdHJpbmcoKX1cbiAgICAgIG1pbldpZHRoPXtwcm9wcy5wYXJhbURlZi5taW5XaWR0aH1cbiAgICAgIHBsYWNlaG9sZGVyPXtwcm9wcy5wYXJhbURlZi5wbGFjZWhvbGRlcn1cbiAgICAgIHRpdGxlPXtwcm9wcy5wYXJhbURlZi5kZXNjcmlwdGlvbn1cbiAgICAgIG9uQ29tbWl0Q2hhbmdlPXsoZXZ0KSA9PiB7XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlKHByb3BzLmluZGV4LCBldnQuY3VycmVudFRhcmdldC52YWx1ZSk7XG4gICAgICAgIGlmIChwcm9wcy5wYXJhbURlZi5ydW5RdWVyeU9uRW50ZXIgJiYgZXZ0LnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgIHByb3BzLm9uUnVuUXVlcnkoKTtcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAvPlxuICApO1xufVxuXG5mdW5jdGlvbiBCb29sSW5wdXRQYXJhbUVkaXRvcihwcm9wczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxDaGVja2JveFxuICAgICAgaWQ9e2dldE9wZXJhdGlvblBhcmFtSWQocHJvcHMub3BlcmF0aW9uSW5kZXgsIHByb3BzLmluZGV4KX1cbiAgICAgIHZhbHVlPXtwcm9wcy52YWx1ZSBhcyBib29sZWFufVxuICAgICAgb25DaGFuZ2U9eyhldnQpID0+IHByb3BzLm9uQ2hhbmdlKHByb3BzLmluZGV4LCBldnQuY3VycmVudFRhcmdldC5jaGVja2VkKX1cbiAgICAvPlxuICApO1xufVxuXG5mdW5jdGlvbiBTZWxlY3RJbnB1dFBhcmFtRWRpdG9yKHtcbiAgcGFyYW1EZWYsXG4gIHZhbHVlLFxuICBpbmRleCxcbiAgb3BlcmF0aW9uSW5kZXgsXG4gIG9uQ2hhbmdlLFxufTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcykge1xuICBsZXQgc2VsZWN0T3B0aW9ucyA9IHBhcmFtRGVmLm9wdGlvbnMgYXMgQXJyYXk8U2VsZWN0YWJsZVZhbHVlPGFueT4+O1xuXG4gIGlmICghc2VsZWN0T3B0aW9uc1swXT8ubGFiZWwpIHtcbiAgICBzZWxlY3RPcHRpb25zID0gcGFyYW1EZWYub3B0aW9ucyEubWFwKChvcHRpb24pID0+ICh7XG4gICAgICBsYWJlbDogb3B0aW9uLnRvU3RyaW5nKCksXG4gICAgICB2YWx1ZTogb3B0aW9uIGFzIHN0cmluZyxcbiAgICB9KSk7XG4gIH1cblxuICBsZXQgdmFsdWVPcHRpb24gPSBzZWxlY3RPcHRpb25zLmZpbmQoKHgpID0+IHgudmFsdWUgPT09IHZhbHVlKSA/PyB0b09wdGlvbih2YWx1ZSBhcyBzdHJpbmcpO1xuXG4gIHJldHVybiAoXG4gICAgPFNlbGVjdFxuICAgICAgaWQ9e2dldE9wZXJhdGlvblBhcmFtSWQob3BlcmF0aW9uSW5kZXgsIGluZGV4KX1cbiAgICAgIHZhbHVlPXt2YWx1ZU9wdGlvbn1cbiAgICAgIG9wdGlvbnM9e3NlbGVjdE9wdGlvbnN9XG4gICAgICBwbGFjZWhvbGRlcj17cGFyYW1EZWYucGxhY2Vob2xkZXJ9XG4gICAgICBhbGxvd0N1c3RvbVZhbHVlPXt0cnVlfVxuICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4gb25DaGFuZ2UoaW5kZXgsIHZhbHVlLnZhbHVlISl9XG4gICAgLz5cbiAgKTtcbn1cbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlcmF0aW9uc0VkaXRvclJvdyh7IGNoaWxkcmVuIH06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucm9vdH0+XG4gICAgICA8U3RhY2sgZ2FwPXsxfT57Y2hpbGRyZW59PC9TdGFjaz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgcm9vdDogY3NzKHtcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMSwgMSwgMCwgMSksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlY29uZGFyeSxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKDEpLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBSYWRpb0J1dHRvbkdyb3VwLCBUYWcgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFF1ZXJ5RWRpdG9yTW9kZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgbW9kZTogUXVlcnlFZGl0b3JNb2RlO1xuICBvbkNoYW5nZTogKG1vZGU6IFF1ZXJ5RWRpdG9yTW9kZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgZWRpdG9yTW9kZXMgPSBbXG4gIHsgbGFiZWw6ICdFeHBsYWluJywgdmFsdWU6IFF1ZXJ5RWRpdG9yTW9kZS5FeHBsYWluIH0sXG4gIHtcbiAgICBsYWJlbDogJ0J1aWxkZXInLFxuICAgIHZhbHVlOiBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcixcbiAgICBjb21wb25lbnQ6ICgpID0+IChcbiAgICAgIDxUYWdcbiAgICAgICAgY2xhc3NOYW1lPXtjc3Moe1xuICAgICAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgICAgICBwYWRkaW5nOiAnMXB4IDVweCcsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogJ3RleHQtYm90dG9tJyxcbiAgICAgICAgfSl9XG4gICAgICAgIG5hbWU9eydCZXRhJ31cbiAgICAgICAgY29sb3JJbmRleD17MX1cbiAgICAgIC8+XG4gICAgKSxcbiAgfSxcbiAgeyBsYWJlbDogJ0NvZGUnLCB2YWx1ZTogUXVlcnlFZGl0b3JNb2RlLkNvZGUgfSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeUVkaXRvck1vZGVUb2dnbGUoeyBtb2RlLCBvbkNoYW5nZSB9OiBQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXYgZGF0YS10ZXN0aWQ9eydRdWVyeUVkaXRvck1vZGVUb2dnbGUnfT5cbiAgICAgIDxSYWRpb0J1dHRvbkdyb3VwIG9wdGlvbnM9e2VkaXRvck1vZGVzfSBzaXplPVwic21cIiB2YWx1ZT17bW9kZX0gb25DaGFuZ2U9e29uQ2hhbmdlfSAvPlxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IHVuaXF1ZUlkIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCwgeyBIVE1MUHJvcHMsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgU3dpdGNoLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIGV4dGVuZHMgT21pdDxIVE1MUHJvcHM8SFRNTElucHV0RWxlbWVudD4sICd2YWx1ZScgfCAncmVmJz4ge1xuICB2YWx1ZT86IGJvb2xlYW47XG4gIGxhYmVsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeUhlYWRlclN3aXRjaCh7IGxhYmVsLCAuLi5pbnB1dFByb3BzIH06IFByb3BzKSB7XG4gIGNvbnN0IGRhc2hlZExhYmVsID0gbGFiZWwucmVwbGFjZSgnICcsICctJyk7XG4gIGNvbnN0IHN3aXRjaElkUmVmID0gdXNlUmVmKHVuaXF1ZUlkKGBzd2l0Y2gtJHtkYXNoZWRMYWJlbH1gKSk7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxTdGFjayBnYXA9ezF9PlxuICAgICAgPGxhYmVsIGh0bWxGb3I9e3N3aXRjaElkUmVmLmN1cnJlbnR9IGNsYXNzTmFtZT17c3R5bGVzLnN3aXRjaExhYmVsfT5cbiAgICAgICAge2xhYmVsfVxuICAgICAgPC9sYWJlbD5cbiAgICAgIDxTd2l0Y2ggey4uLmlucHV0UHJvcHN9IGlkPXtzd2l0Y2hJZFJlZi5jdXJyZW50fSAvPlxuICAgIDwvU3RhY2s+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIHN3aXRjaExhYmVsOiBjc3Moe1xuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5LFxuICAgICAgfSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVRvZ2dsZSB9IGZyb20gJ3JlYWN0LXVzZSc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEljb24sIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICB0aXRsZTogc3RyaW5nO1xuICBjb2xsYXBzZWRJbmZvOiBzdHJpbmdbXTtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFF1ZXJ5T3B0aW9uR3JvdXAoeyB0aXRsZSwgY2hpbGRyZW4sIGNvbGxhcHNlZEluZm8gfTogUHJvcHMpIHtcbiAgY29uc3QgW2lzT3BlbiwgdG9nZ2xlT3Blbl0gPSB1c2VUb2dnbGUoZmFsc2UpO1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZ2FwPXswfSBkaXJlY3Rpb249XCJjb2x1bW5cIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyfSBvbkNsaWNrPXt0b2dnbGVPcGVufSB0aXRsZT1cIkNsaWNrIHRvIGVkaXQgb3B0aW9uc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnRvZ2dsZX0+XG4gICAgICAgICAgPEljb24gbmFtZT17aXNPcGVuID8gJ2FuZ2xlLWRvd24nIDogJ2FuZ2xlLXJpZ2h0J30gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxoNiBjbGFzc05hbWU9e3N0eWxlcy50aXRsZX0+e3RpdGxlfTwvaDY+XG4gICAgICAgIHshaXNPcGVuICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRlc2NyaXB0aW9ufT5cbiAgICAgICAgICAgIHtjb2xsYXBzZWRJbmZvLm1hcCgoeCwgaSkgPT4gKFxuICAgICAgICAgICAgICA8c3BhbiBrZXk9e2l9Pnt4fTwvc3Bhbj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgICB7aXNPcGVuICYmIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm9keX0+e2NoaWxkcmVufTwvZGl2Pn1cbiAgICA8L1N0YWNrPlxuICApO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzd2l0Y2hMYWJlbDogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQucHJpbWFyeSxcbiAgICAgIH0sXG4gICAgfSksXG4gICAgaGVhZGVyOiBjc3Moe1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICBhbGlnbkl0ZW1zOiAnYmFzZWxpbmUnLFxuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnksXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZDogdGhlbWUuY29sb3JzLmVtcGhhc2l6ZSh0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5wcmltYXJ5LCAwLjAzKSxcbiAgICAgIH0sXG4gICAgfSksXG4gICAgdGl0bGU6IGNzcyh7XG4gICAgICBmbGV4R3JvdzogMSxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIG1hcmdpbjogMCxcbiAgICB9KSxcbiAgICBkZXNjcmlwdGlvbjogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBwYWRkaW5nTGVmdDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICB9KSxcbiAgICBib2R5OiBjc3Moe1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgcGFkZGluZ1RvcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGZsZXhXcmFwOiAnd3JhcCcsXG4gICAgfSksXG4gICAgdG9nZ2xlOiBjc3Moe1xuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgIG1hcmdpblJpZ2h0OiBgJHt0aGVtZS5zcGFjaW5nKDEpfWAsXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgY3NzLCBjeCB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUHJpc20sIHsgR3JhbW1hciB9IGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEvc3JjJztcbmltcG9ydCB7IHVzZVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL3VpL3NyYyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogc3RyaW5nO1xuICBsYW5nOiB7XG4gICAgZ3JhbW1hcjogR3JhbW1hcjtcbiAgICBuYW1lOiBzdHJpbmc7XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gUmF3UXVlcnkoeyBxdWVyeSwgbGFuZyB9OiBQcm9wcykge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lMigpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZXModGhlbWUpO1xuICBjb25zdCBoaWdobGlnaHRlZCA9IFByaXNtLmhpZ2hsaWdodChxdWVyeSwgbGFuZy5ncmFtbWFyLCBsYW5nLm5hbWUpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPXtjeChzdHlsZXMuZWRpdG9yRmllbGQsICdwcmlzbS1zeW50YXgtaGlnaGxpZ2h0Jyl9XG4gICAgICBhcmlhLWxhYmVsPVwic2VsZWN0b3JcIlxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBoaWdobGlnaHRlZCB9fVxuICAgIC8+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGVkaXRvckZpZWxkOiBjc3Moe1xuICAgICAgZm9udEZhbWlseTogdGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5TW9ub3NwYWNlLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNhcGl0YWxpemUgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHBsdXJhbGl6ZSBmcm9tICdwbHVyYWxpemUnO1xuXG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhL3NyYyc7XG5cbmltcG9ydCB7IExhYmVsUGFyYW1FZGl0b3IgfSBmcm9tICcuLi9jb21wb25lbnRzL0xhYmVsUGFyYW1FZGl0b3InO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSxcbiAgUXVlcnlXaXRoT3BlcmF0aW9ucyxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvblJlbmRlcmVyTGVmdChtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgY29uc3QgcGFyYW1zID0gcmVuZGVyUGFyYW1zKG1vZGVsLCBkZWYsIGlubmVyRXhwcik7XG4gIGNvbnN0IHN0ciA9IG1vZGVsLmlkICsgJygnO1xuXG4gIGlmIChpbm5lckV4cHIpIHtcbiAgICBwYXJhbXMucHVzaChpbm5lckV4cHIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ciArIHBhcmFtcy5qb2luKCcsICcpICsgJyknO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVuY3Rpb25SZW5kZXJlclJpZ2h0KG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICBjb25zdCBwYXJhbXMgPSByZW5kZXJQYXJhbXMobW9kZWwsIGRlZiwgaW5uZXJFeHByKTtcbiAgY29uc3Qgc3RyID0gbW9kZWwuaWQgKyAnKCc7XG5cbiAgaWYgKGlubmVyRXhwcikge1xuICAgIHBhcmFtcy51bnNoaWZ0KGlubmVyRXhwcik7XG4gIH1cblxuICByZXR1cm4gc3RyICsgcGFyYW1zLmpvaW4oJywgJykgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmcsXG4gIHJlbmRlckxlZnQ6IGJvb2xlYW5cbikge1xuICBpZiAoZGVmLnBhcmFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgYENhbm5vdCByZW5kZXIgYSBmdW5jdGlvbiB3aXRoIHBhcmFtcyBvZiBsZW5ndGggWyR7ZGVmLnBhcmFtcy5sZW5ndGh9XWA7XG4gIH1cblxuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnNW0nO1xuXG4gIC8vIE5leHQgZnJhbWUgdGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzLCBidXQgZ2V0IHJpZCBvZiB0aGUgZmlyc3Qgb25lIGJlY2F1c2UgaXQncyB1c2VkIHRvIG1vdmUgdGhlXG4gIC8vIGluc3RhbnQgdmVjdG9yIGludG8gYSByYW5nZSB2ZWN0b3IuXG4gIGNvbnN0IHBhcmFtcyA9IHJlbmRlclBhcmFtcyhcbiAgICB7XG4gICAgICAuLi5tb2RlbCxcbiAgICAgIHBhcmFtczogbW9kZWwucGFyYW1zLnNsaWNlKDEpLFxuICAgIH0sXG4gICAge1xuICAgICAgLi4uZGVmLFxuICAgICAgcGFyYW1zOiBkZWYucGFyYW1zLnNsaWNlKDEpLFxuICAgICAgZGVmYXVsdFBhcmFtczogZGVmLmRlZmF1bHRQYXJhbXMuc2xpY2UoMSksXG4gICAgfSxcbiAgICBpbm5lckV4cHJcbiAgKTtcblxuICBjb25zdCBzdHIgPSBtb2RlbC5pZCArICcoJztcblxuICAvLyBEZXBlbmRpbmcgb24gdGhlIHJlbmRlckxlZnQgdmFyaWFibGUsIHJlbmRlciBwYXJhbWV0ZXJzIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gIC8vIHJlbmRlckxlZnQgPT09IHRydWUgKHJlbmRlckxlZnQpID0+IChwYXJhbTEsIHBhcmFtMiwgcmFuZ2VWZWN0b3JbLi4uXSlcbiAgLy8gcmVuZGVyTGVmdCA9PT0gZmFsc2UgKHJlbmRlclJpZ2h0KSA9PiAocmFuZ2VWZWN0b3JbLi4uXSwgcGFyYW0xLCBwYXJhbTIpXG4gIGlmIChpbm5lckV4cHIpIHtcbiAgICByZW5kZXJMZWZ0ID8gcGFyYW1zLnB1c2goYCR7aW5uZXJFeHByfVske3JhbmdlVmVjdG9yfV1gKSA6IHBhcmFtcy51bnNoaWZ0KGAke2lubmVyRXhwcn1bJHtyYW5nZVZlY3Rvcn1dYCk7XG4gIH1cblxuICAvLyBzdGljayBldmVyeXRoaW5nIHRvZ2V0aGVyXG4gIHJldHVybiBzdHIgKyBwYXJhbXMuam9pbignLCAnKSArICcpJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJSaWdodFdpdGhQYXJhbXMoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIHJldHVybiByYW5nZVJlbmRlcmVyV2l0aFBhcmFtcyhtb2RlbCwgZGVmLCBpbm5lckV4cHIsIGZhbHNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJMZWZ0V2l0aFBhcmFtcyhcbiAgbW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIGlubmVyRXhwcjogc3RyaW5nXG4pIHtcbiAgcmV0dXJuIHJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zKG1vZGVsLCBkZWYsIGlubmVyRXhwciwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBhcmFtcyhtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChtb2RlbC5wYXJhbXMgPz8gW10pLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFyYW1EZWYgPSBkZWYucGFyYW1zW2luZGV4XTtcbiAgICBpZiAocGFyYW1EZWYudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcjxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4oZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIHF1ZXJ5OiBUKSB7XG4gIGNvbnN0IG5ld09wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgcGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcyxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIG9wZXJhdGlvbnM6IFsuLi5xdWVyeS5vcGVyYXRpb25zLCBuZXdPcGVyYXRpb25dLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShmdW5jTmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBjYXBpdGFsaXplKGZ1bmNOYW1lLnJlcGxhY2UoL18vZywgJyAnKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbUlkKG9wZXJhdGlvbkluZGV4OiBudW1iZXIsIHBhcmFtSW5kZXg6IG51bWJlcikge1xuICByZXR1cm4gYG9wZXJhdGlvbnMuJHtvcGVyYXRpb25JbmRleH0ucGFyYW0uJHtwYXJhbUluZGV4fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5nZVZlY3RvclBhcmFtRGVmKHdpdGhSYXRlSW50ZXJ2YWwgPSBmYWxzZSk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmIHtcbiAgY29uc3QgcGFyYW06IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmID0ge1xuICAgIG5hbWU6ICdSYW5nZScsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uczogW1xuICAgICAge1xuICAgICAgICBsYWJlbDogJyRfX2ludGVydmFsJyxcbiAgICAgICAgdmFsdWU6ICckX19pbnRlcnZhbCcsXG4gICAgICAgIC8vIHRvb2x0aXA6ICdEeW5hbWljIGludGVydmFsIGJhc2VkIG9uIG1heCBkYXRhIHBvaW50cywgc2NyYXBlIGFuZCBtaW4gaW50ZXJ2YWwnLFxuICAgICAgfSxcbiAgICAgIHsgbGFiZWw6ICcxbScsIHZhbHVlOiAnMW0nIH0sXG4gICAgICB7IGxhYmVsOiAnNW0nLCB2YWx1ZTogJzVtJyB9LFxuICAgICAgeyBsYWJlbDogJzEwbScsIHZhbHVlOiAnMTBtJyB9LFxuICAgICAgeyBsYWJlbDogJzFoJywgdmFsdWU6ICcxaCcgfSxcbiAgICAgIHsgbGFiZWw6ICcyNGgnLCB2YWx1ZTogJzI0aCcgfSxcbiAgICBdLFxuICB9O1xuXG4gIGlmICh3aXRoUmF0ZUludGVydmFsKSB7XG4gICAgKHBhcmFtLm9wdGlvbnMgYXMgQXJyYXk8U2VsZWN0YWJsZVZhbHVlPHN0cmluZz4+KS51bnNoaWZ0KHtcbiAgICAgIGxhYmVsOiAnJF9fcmF0ZV9pbnRlcnZhbCcsXG4gICAgICB2YWx1ZTogJyRfX3JhdGVfaW50ZXJ2YWwnLFxuICAgICAgLy8gdG9vbHRpcDogJ0Fsd2F5cyBhYm92ZSA0eCBzY3JhcGUgaW50ZXJ2YWwnLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgc2hhcmVkIGJldHdlZW4gUHJvbWV0aGV1cyBhbmQgTG9raSB2YXJpYW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb248VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KFxuICBuYW1lOiBzdHJpbmcsXG4gIG92ZXJyaWRlczogUGFydGlhbDxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+ID0ge31cbik6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdIHtcbiAgY29uc3Qgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10gPSBbXG4gICAge1xuICAgICAgaWQ6IG5hbWUsXG4gICAgICBuYW1lOiBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnQnkgbGFiZWwnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIHJlc3RQYXJhbTogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ3BsYWluIGFnZ3JlZ2F0aW9ucycsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQWdncmVnYXRpb25zLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICAgICAgcGFyYW1DaGFuZ2VkSGFuZGxlcjogZ2V0T25MYWJlbEFkZGVkSGFuZGxlcihgX18ke25hbWV9X2J5YCksXG4gICAgICBleHBsYWluSGFuZGxlcjogZ2V0QWdncmVnYXRpb25FeHBsYWluZXIobmFtZSwgJycpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogYF9fJHtuYW1lfV9ieWAsXG4gICAgICBuYW1lOiBgJHtnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpfSBieWAsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnYWdncmVnYXRpb25zIGJ5JyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICByZW5kZXJlcjogZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyKG5hbWUpLFxuICAgICAgcGFyYW1DaGFuZ2VkSGFuZGxlcjogZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIobmFtZSksXG4gICAgICBleHBsYWluSGFuZGxlcjogZ2V0QWdncmVnYXRpb25FeHBsYWluZXIobmFtZSwgJ2J5JyksXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICAgIGhpZGVGcm9tTGlzdDogdHJ1ZSxcbiAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBgX18ke25hbWV9X3dpdGhvdXRgLFxuICAgICAgbmFtZTogYCR7Z2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKX0gd2l0aG91dGAsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnYWdncmVnYXRpb25zIGJ5JyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICByZW5kZXJlcjogZ2V0QWdncmVnYXRpb25XaXRob3V0UmVuZGVyZXIobmFtZSksXG4gICAgICBwYXJhbUNoYW5nZWRIYW5kbGVyOiBnZXRMYXN0TGFiZWxSZW1vdmVkSGFuZGxlcihuYW1lKSxcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiBnZXRBZ2dyZWdhdGlvbkV4cGxhaW5lcihuYW1lLCAnd2l0aG91dCcpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgICBoaWRlRnJvbUxpc3Q6IHRydWUsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfSxcbiAgXTtcblxuICByZXR1cm4gb3BlcmF0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtKFxuICBuYW1lOiBzdHJpbmcsXG4gIHBhcmFtc0RlZjogeyBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW107IGRlZmF1bHRQYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWVbXSB9LFxuICBvdmVycmlkZXM6IFBhcnRpYWw8UXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPiA9IHt9XG4pOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbihuYW1lLCBvdmVycmlkZXMpO1xuICBvcGVyYXRpb25zWzBdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzFdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzJdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzBdLmRlZmF1bHRQYXJhbXMgPSBwYXJhbXNEZWYuZGVmYXVsdFBhcmFtcztcbiAgb3BlcmF0aW9uc1sxXS5kZWZhdWx0UGFyYW1zID0gWy4uLnBhcmFtc0RlZi5kZWZhdWx0UGFyYW1zLCAnJ107XG4gIG9wZXJhdGlvbnNbMl0uZGVmYXVsdFBhcmFtcyA9IFsuLi5wYXJhbXNEZWYuZGVmYXVsdFBhcmFtcywgJyddO1xuICBvcGVyYXRpb25zWzFdLnJlbmRlcmVyID0gZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyV2l0aFBhcmFtZXRlcihuYW1lKTtcbiAgb3BlcmF0aW9uc1syXS5yZW5kZXJlciA9IGdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlcldpdGhQYXJhbWV0ZXIobmFtZSk7XG4gIHJldHVybiBvcGVyYXRpb25zO1xufVxuXG5mdW5jdGlvbiBnZXRBZ2dyZWdhdGlvbkJ5UmVuZGVyZXIoYWdncmVnYXRpb246IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gYWdncmVnYXRpb25SZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7YWdncmVnYXRpb259IGJ5KCR7bW9kZWwucGFyYW1zLmpvaW4oJywgJyl9KSAoJHtpbm5lckV4cHJ9KWA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFnZ3JlZ2F0aW9uV2l0aG91dFJlbmRlcmVyKGFnZ3JlZ2F0aW9uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFnZ3JlZ2F0aW9uUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke2FnZ3JlZ2F0aW9ufSB3aXRob3V0KCR7bW9kZWwucGFyYW1zLmpvaW4oJywgJyl9KSAoJHtpbm5lckV4cHJ9KWA7XG4gIH07XG59XG5cbi8qKlxuICogVmVyeSBzaW1wbGUgcG9jIGltcGxlbWVudGF0aW9uLCBuZWVkcyB0byBiZSBtb2RpZmllZCB0byBzdXBwb3J0IGFsbCBhZ2dyZWdhdGlvbiBvcGVyYXRvcnNcbiAqL1xuZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25FeHBsYWluZXIoYWdncmVnYXRpb25OYW1lOiBzdHJpbmcsIG1vZGU6ICdieScgfCAnd2l0aG91dCcgfCAnJykge1xuICByZXR1cm4gZnVuY3Rpb24gYWdncmVnYXRpb25FeHBsYWluZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikge1xuICAgIGNvbnN0IGxhYmVscyA9IG1vZGVsLnBhcmFtcy5tYXAoKGxhYmVsKSA9PiBgXFxgJHtsYWJlbH1cXGBgKS5qb2luKCcgYW5kICcpO1xuICAgIGNvbnN0IGxhYmVsV29yZCA9IHBsdXJhbGl6ZSgnbGFiZWwnLCBtb2RlbC5wYXJhbXMubGVuZ3RoKTtcblxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSAnYnknOlxuICAgICAgICByZXR1cm4gYENhbGN1bGF0ZXMgJHthZ2dyZWdhdGlvbk5hbWV9IG92ZXIgZGltZW5zaW9ucyB3aGlsZSBwcmVzZXJ2aW5nICR7bGFiZWxXb3JkfSAke2xhYmVsc30uYDtcbiAgICAgIGNhc2UgJ3dpdGhvdXQnOlxuICAgICAgICByZXR1cm4gYENhbGN1bGF0ZXMgJHthZ2dyZWdhdGlvbk5hbWV9IG92ZXIgdGhlIGRpbWVuc2lvbnMgJHtsYWJlbHN9LiBBbGwgb3RoZXIgbGFiZWxzIGFyZSBwcmVzZXJ2ZWQuYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgQ2FsY3VsYXRlcyAke2FnZ3JlZ2F0aW9uTmFtZX0gb3ZlciB0aGUgZGltZW5zaW9ucy5gO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyV2l0aFBhcmFtZXRlcihhZ2dyZWdhdGlvbjogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhZ2dyZWdhdGlvblJlbmRlcmVyKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICAgIGZ1bmN0aW9uIG1hcFR5cGUocDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYFxcXCIke3B9XFxcImA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gbW9kZWwucGFyYW1zLnNsaWNlKDAsIC0xKTtcbiAgICBjb25zdCByZXN0UGFyYW1zID0gbW9kZWwucGFyYW1zLnNsaWNlKDEpO1xuICAgIHJldHVybiBgJHthZ2dyZWdhdGlvbn0gYnkoJHtyZXN0UGFyYW1zLmpvaW4oJywgJyl9KSAoJHtwYXJhbXMubWFwKG1hcFR5cGUpLmpvaW4oJywgJyl9LCAke2lubmVyRXhwcn0pYDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdHJhbnNmb3JtIG9wZXJhdGlvbnMgd2l0aG91dCBsYWJlbHMgdG8gdGhlaXIgcGxhbiBhZ2dyZWdhdGlvbiBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIoY2hhbmdlVG9PcGVyYXRpb25JZDogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvblBhcmFtQ2hhbmdlZChpbmRleDogbnVtYmVyLCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZikge1xuICAgIC8vIElmIGRlZmluaXRpb24gaGFzIG1vcmUgcGFyYW1zIHRoZW4gaXMgZGVmaW5lZCB0aGVyZSBhcmUgbm8gb3B0aW9uYWwgcmVzdCBwYXJhbXMgYW55bW9yZS5cbiAgICAvLyBXZSB0aGVuIHRyYW5zZm9ybSB0aGlzIG9wZXJhdGlvbiBpbnRvIGEgZGlmZmVyZW50IG9uZVxuICAgIGlmIChvcC5wYXJhbXMubGVuZ3RoIDwgZGVmLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wLFxuICAgICAgICBpZDogY2hhbmdlVG9PcGVyYXRpb25JZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPbkxhYmVsQWRkZWRIYW5kbGVyKGNoYW5nZVRvT3BlcmF0aW9uSWQ6IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gb25QYXJhbUNoYW5nZWQoaW5kZXg6IG51bWJlciwgb3A6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYpIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBhY3R1YWxseSBoYXZlIHRoZSBsYWJlbCBwYXJhbS4gQXMgaXQncyBvcHRpb25hbCB0aGUgYWdncmVnYXRpb24gY2FuIGhhdmUgb25lIGxlc3MsIHdoaWNoIGlzIHRoZVxuICAgIC8vIGNhc2Ugb2YganVzdCBzaW1wbGUgYWdncmVnYXRpb24gd2l0aG91dCBsYWJlbC4gV2hlbiB1c2VyIGFkZHMgdGhlIGxhYmVsIGl0IG5vdyBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIHBhcmFtc1xuICAgIC8vIGFzIGl0J3MgZGVmaW5pdGlvbiwgYW5kIG5vdyB3ZSBjYW4gY2hhbmdlIGl0IHRvIGl0J3MgYF9ieWAgdmFyaWFudC5cbiAgICBpZiAob3AucGFyYW1zLmxlbmd0aCA9PT0gZGVmLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wLFxuICAgICAgICBpZDogY2hhbmdlVG9PcGVyYXRpb25JZCxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcDtcbiAgfTtcbn1cbiIsImltcG9ydCB7IFN5bnRheE5vZGUsIFRyZWVDdXJzb3IgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuaW1wb3J0IHsgUXVlcnlCdWlsZGVyT3BlcmF0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIFRoaXMgaXMgdXNlZCBmb3IgZXJyb3IgdHlwZSBmb3Igc29tZSByZWFzb25cbmV4cG9ydCBjb25zdCBFcnJvck5hbWUgPSAn4pqgJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldExlZnRNb3N0Q2hpbGQoY3VyOiBTeW50YXhOb2RlKTogU3ludGF4Tm9kZSB7XG4gIHJldHVybiBjdXIuZmlyc3RDaGlsZCA/IGdldExlZnRNb3N0Q2hpbGQoY3VyLmZpcnN0Q2hpbGQpIDogY3VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVycm9yKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSkge1xuICByZXR1cm4ge1xuICAgIHRleHQ6IGdldFN0cmluZyhleHByLCBub2RlKSxcbiAgICAvLyBUT0RPOiB0aGlzIGFyZSBwb3NpdGlvbnMgaW4gdGhlIHN0cmluZyB3aXRoIHRoZSByZXBsYWNlZCB2YXJpYWJsZXMuIE1lYW5zIGl0IGNhbm5vdCBiZSB1c2VkIHRvIHNob3cgZXhhY3RcbiAgICAvLyAgcGxhY2VtZW50IG9mIHRoZSBlcnJvciBmb3IgdGhlIHVzZXIuIFdlIG5lZWQgc29tZSB0cmFuc2xhdGlvbiB0YWJsZSB0byBwb3NpdGlvbnMgYmVmb3JlIHRoZSB2YXJpYWJsZVxuICAgIC8vICByZXBsYWNlLlxuICAgIGZyb206IG5vZGUuZnJvbSxcbiAgICB0bzogbm9kZS50byxcbiAgICBwYXJlbnRUeXBlOiBub2RlLnBhcmVudD8ubmFtZSxcbiAgfTtcbn1cblxuLy8gVGFrZW4gZnJvbSB0ZW1wbGF0ZV9zcnYsIGJ1dCBjb3BpZWQgc28gdG8gbm90IG1lc3Mgd2l0aCB0aGUgcmVnZXguaW5kZXggd2hpY2ggaXMgbWFuaXB1bGF0ZWQgaW4gdGhlIHNlcnZpY2Vcbi8qXG4gKiBUaGlzIHJlZ2V4IG1hdGNoZXMgMyB0eXBlcyBvZiB2YXJpYWJsZSByZWZlcmVuY2Ugd2l0aCBhbiBvcHRpb25hbCBmb3JtYXQgc3BlY2lmaWVyXG4gKiBcXCQoXFx3KykgICAgICAgICAgICAgICAgICAgICAgICAgICR2YXIxXG4gKiBcXFtcXFsoW1xcc1xcU10rPykoPzo6KFxcdyspKT9cXF1cXF0gICAgW1t2YXIyXV0gb3IgW1t2YXIyOmZtdDJdXVxuICogXFwkeyhcXHcrKSg/OjooXFx3KykpP30gICAgICAgICAgICAgJHt2YXIzfSBvciAke3ZhcjM6Zm10M31cbiAqL1xuY29uc3QgdmFyaWFibGVSZWdleCA9IC9cXCQoXFx3Kyl8XFxbXFxbKFtcXHNcXFNdKz8pKD86OihcXHcrKSk/XFxdXFxdfFxcJHsoXFx3KykoPzpcXC4oW146XlxcfV0rKSk/KD86OihbXlxcfV0rKSk/fS9nO1xuXG4vKipcbiAqIEFzIHZhcmlhYmxlcyB3aXRoICQgYXJlIGNyZWF0aW5nIHBhcnNpbmcgZXJyb3JzLCB3ZSBmaXJzdCByZXBsYWNlIHRoZW0gd2l0aCBtYWdpYyBzdHJpbmcgdGhhdCBpcyBwYXJzYWJsZSBhbmQgYXRcbiAqIHRoZSBzYW1lIHRpbWUgd2UgY2FuIGdldCB0aGUgdmFyaWFibGUgYW5kIGl0J3MgZm9ybWF0IGJhY2sgZnJvbSBpdC5cbiAqIEBwYXJhbSBleHByXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlVmFyaWFibGVzKGV4cHI6IHN0cmluZykge1xuICByZXR1cm4gZXhwci5yZXBsYWNlKHZhcmlhYmxlUmVnZXgsIChtYXRjaCwgdmFyMSwgdmFyMiwgZm10MiwgdmFyMywgZmllbGRQYXRoLCBmbXQzKSA9PiB7XG4gICAgY29uc3QgZm10ID0gZm10MiB8fCBmbXQzO1xuICAgIGxldCB2YXJpYWJsZSA9IHZhcjE7XG4gICAgbGV0IHZhclR5cGUgPSAnMCc7XG5cbiAgICBpZiAodmFyMikge1xuICAgICAgdmFyaWFibGUgPSB2YXIyO1xuICAgICAgdmFyVHlwZSA9ICcxJztcbiAgICB9XG5cbiAgICBpZiAodmFyMykge1xuICAgICAgdmFyaWFibGUgPSB2YXIzO1xuICAgICAgdmFyVHlwZSA9ICcyJztcbiAgICB9XG5cbiAgICByZXR1cm4gYF9fVl8ke3ZhclR5cGV9X19gICsgdmFyaWFibGUgKyAnX19WX18nICsgKGZtdCA/ICdfX0ZfXycgKyBmbXQgKyAnX19GX18nIDogJycpO1xuICB9KTtcbn1cblxuY29uc3QgdmFyVHlwZUZ1bmMgPSBbXG4gICh2OiBzdHJpbmcsIGY/OiBzdHJpbmcpID0+IGBcXCQke3Z9YCxcbiAgKHY6IHN0cmluZywgZj86IHN0cmluZykgPT4gYFtbJHt2fSR7ZiA/IGA6JHtmfWAgOiAnJ31dXWAsXG4gICh2OiBzdHJpbmcsIGY/OiBzdHJpbmcpID0+IGBcXCRcXHske3Z9JHtmID8gYDoke2Z9YCA6ICcnfVxcfWAsXG5dO1xuXG4vKipcbiAqIEdldCBiYWNrIHRoZSB0ZXh0IHdpdGggdmFyaWFibGVzIGluIHRoZWlyIG9yaWdpbmFsIGZvcm1hdC5cbiAqIEBwYXJhbSBleHByXG4gKi9cbmZ1bmN0aW9uIHJldHVyblZhcmlhYmxlcyhleHByOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGV4cHIucmVwbGFjZSgvX19WXyhcXGQpX18oLis/KV9fVl9fKD86X19GX18oXFx3KylfX0ZfXyk/L2csIChtYXRjaCwgdHlwZSwgdiwgZikgPT4ge1xuICAgIHJldHVybiB2YXJUeXBlRnVuY1twYXJzZUludCh0eXBlLCAxMCldKHYsIGYpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFjdHVhbCBzdHJpbmcgb2YgdGhlIGV4cHJlc3Npb24uIFRoYXQgaXMgbm90IHN0b3JlZCBpbiB0aGUgdHJlZSBzbyB3ZSBoYXZlIHRvIGdldCB0aGUgaW5kZXhlcyBmcm9tIHRoZSBub2RlXG4gKiBhbmQgdGhlbiBiYXNlZCBvbiB0aGF0IGdldCBpdCBmcm9tIHRoZSBleHByZXNzaW9uLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHJpbmcoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlIHwgVHJlZUN1cnNvciB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiByZXR1cm5WYXJpYWJsZXMoZXhwci5zdWJzdHJpbmcobm9kZS5mcm9tLCBub2RlLnRvKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHNpbXBsZSBzY2FsYXIgYmluYXJ5IG9wIG9iamVjdC5cbiAqIEBwYXJhbSBvcERlZiAtIGRlZmluaXRpb24gb2YgdGhlIG9wIHRvIGJlIGNyZWF0ZWRcbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbnVtYmVyTm9kZSAtIHRoZSBub2RlIGZvciB0aGUgc2NhbGFyXG4gKiBAcGFyYW0gaGFzQm9vbCAtIHdoZXRoZXIgb3BlcmF0aW9uIGhhcyBhIGJvb2wgbW9kaWZpZXIuIElzIHVzZWQgb25seSBmb3Igb3BzIGZvciB3aGljaCBpdCBtYWtlcyBzZW5zZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VCaW5PcChcbiAgb3BEZWY6IHsgaWQ6IHN0cmluZzsgY29tcGFyaXNvbj86IGJvb2xlYW4gfSxcbiAgZXhwcjogc3RyaW5nLFxuICBudW1iZXJOb2RlOiBTeW50YXhOb2RlLFxuICBoYXNCb29sOiBib29sZWFuXG4pOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24ge1xuICBjb25zdCBwYXJhbXM6IGFueVtdID0gW3BhcnNlRmxvYXQoZ2V0U3RyaW5nKGV4cHIsIG51bWJlck5vZGUpKV07XG4gIGlmIChvcERlZi5jb21wYXJpc29uKSB7XG4gICAgcGFyYW1zLnB1c2goaGFzQm9vbCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZDogb3BEZWYuaWQsXG4gICAgcGFyYW1zLFxuICB9O1xufVxuXG4vKipcbiAqIEdldCBhbGwgbm9kZXMgd2l0aCB0eXBlIGluIHRoZSB0cmVlLiBUaGlzIHRyYXZlcnNlcyB0aGUgdHJlZSBzbyBpdCBpcyBzYWZlIG9ubHkgd2hlbiB5b3Uga25vdyB0aGVyZSBzaG91bGRuJ3QgYmVcbiAqIHRvbyBtdWNoIG5lc3RpbmcgYnV0IHlvdSBqdXN0IHdhbnQgdG8gc2tpcCBzb21lIG9mIHRoZSB3cmFwcGVycy4gRm9yIGV4YW1wbGUgZ2V0dGluZyBmdW5jdGlvbiBhcmdzIHRoaXMgd2F5IHdvdWxkXG4gKiBub3QgYmUgc2FmZSBpcyBpdCB3b3VsZCBhbHNvIGZpbmQgYXJndW1lbnRzIG9mIG5lc3RlZCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIGN1clxuICogQHBhcmFtIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbEJ5VHlwZShleHByOiBzdHJpbmcsIGN1cjogU3ludGF4Tm9kZSwgdHlwZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICBpZiAoY3VyLm5hbWUgPT09IHR5cGUpIHtcbiAgICByZXR1cm4gW2dldFN0cmluZyhleHByLCBjdXIpXTtcbiAgfVxuICBjb25zdCB2YWx1ZXM6IHN0cmluZ1tdID0gW107XG4gIGxldCBwb3MgPSAwO1xuICBsZXQgY2hpbGQgPSBjdXIuY2hpbGRBZnRlcihwb3MpO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICB2YWx1ZXMucHVzaCguLi5nZXRBbGxCeVR5cGUoZXhwciwgY2hpbGQsIHR5cGUpKTtcbiAgICBwb3MgPSBjaGlsZC50bztcbiAgICBjaGlsZCA9IGN1ci5jaGlsZEFmdGVyKHBvcyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gRGVidWdnaW5nIGZ1bmN0aW9uIGZvciBjb252ZW5pZW5jZS4gR2l2ZXMgeW91IG5pY2Ugb3V0cHV0IHNpbWlsYXIgdG8gbGludXggdHJlZSB1dGlsLlxuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGZ1bmN0aW9uIGxvZyhleHByOiBzdHJpbmcsIGN1cj86IFN5bnRheE5vZGUpIHtcbiAgaWYgKCFjdXIpIHtcbiAgICBjb25zb2xlLmxvZygnPGVtcHR5PicpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBqc29uID0gdG9Kc29uKGV4cHIsIGN1cik7XG4gIGNvbnN0IHRleHQgPSBqc29uVG9UZXh0KGpzb24pO1xuXG4gIGlmICghdGV4dCkge1xuICAgIGNvbnNvbGUubG9nKCc8ZW1wdHk+Jyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUubG9nKHRleHQpO1xufVxuXG5mdW5jdGlvbiB0b0pzb24oZXhwcjogc3RyaW5nLCBjdXI6IFN5bnRheE5vZGUpIHtcbiAgY29uc3QgdHJlZUpzb246IGFueSA9IHt9O1xuICBjb25zdCBuYW1lID0gbm9kZVRvU3RyaW5nKGV4cHIsIGN1cik7XG4gIGNvbnN0IGNoaWxkcmVuID0gW107XG5cbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBjaGlsZCA9IGN1ci5jaGlsZEFmdGVyKHBvcyk7XG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGNoaWxkcmVuLnB1c2godG9Kc29uKGV4cHIsIGNoaWxkKSk7XG4gICAgcG9zID0gY2hpbGQudG87XG4gICAgY2hpbGQgPSBjdXIuY2hpbGRBZnRlcihwb3MpO1xuICB9XG5cbiAgdHJlZUpzb24ubmFtZSA9IG5hbWU7XG4gIHRyZWVKc29uLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHJldHVybiB0cmVlSnNvbjtcbn1cblxudHlwZSBKc29uTm9kZSA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICBjaGlsZHJlbjogSnNvbk5vZGVbXTtcbn07XG5cbmZ1bmN0aW9uIGpzb25Ub1RleHQoXG4gIG5vZGU6IEpzb25Ob2RlLFxuICBjb250ZXh0OiB7IGxhc3RDaGlsZDogYm9vbGVhbjsgaW5kZW50OiBzdHJpbmcgfSA9IHtcbiAgICBsYXN0Q2hpbGQ6IHRydWUsXG4gICAgaW5kZW50OiAnJyxcbiAgfVxuKSB7XG4gIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gIGNvbnN0IHsgbGFzdENoaWxkLCBpbmRlbnQgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IG5ld0luZGVudCA9IGluZGVudCAhPT0gJycgPyBpbmRlbnQgKyAobGFzdENoaWxkID8gJ+KUlOKUgCcgOiAn4pSc4pSAJykgOiAnJztcbiAgbGV0IHRleHQgPSBuZXdJbmRlbnQgKyBuYW1lO1xuXG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQ6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGlzTGFzdENoaWxkID0gaW5kZXggPT09IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgdGV4dCArPVxuICAgICAgJ1xcbicgK1xuICAgICAganNvblRvVGV4dChjaGlsZCwge1xuICAgICAgICBsYXN0Q2hpbGQ6IGlzTGFzdENoaWxkLFxuICAgICAgICBpbmRlbnQ6IGluZGVudCArIChsYXN0Q2hpbGQgPyAnICAnIDogJ+KUgiAnKSxcbiAgICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGV4dDtcbn1cblxuZnVuY3Rpb24gbm9kZVRvU3RyaW5nKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSkge1xuICByZXR1cm4gbm9kZS5uYW1lICsgJzogJyArIGdldFN0cmluZyhleHByLCBub2RlKTtcbn1cbiIsIi8qKlxuICogU2hhcmVkIHR5cGVzIHRoYXQgY2FuIGJlIHJldXNlZCBieSBMb2tpIGFuZCBvdGhlciBkYXRhIHNvdXJjZXNcbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBEYXRhU291cmNlQXBpLCBSZWdpc3RyeUl0ZW0sIFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIHtcbiAgbGFiZWw6IHN0cmluZztcbiAgb3A6IHN0cmluZztcbiAgdmFsdWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb24ge1xuICBpZDogc3RyaW5nO1xuICBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeVdpdGhPcGVyYXRpb25zIHtcbiAgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPFQgPSBhbnk+IGV4dGVuZHMgUmVnaXN0cnlJdGVtIHtcbiAgZG9jdW1lbnRhdGlvbj86IHN0cmluZztcbiAgcGFyYW1zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZltdO1xuICBkZWZhdWx0UGFyYW1zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlW107XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIGhpZGVGcm9tTGlzdD86IGJvb2xlYW47XG4gIGFsdGVybmF0aXZlc0tleT86IHN0cmluZztcbiAgLyoqIENhbiBiZSB1c2VkIHRvIGNvbnRyb2wgb3BlcmF0aW9uIHBsYWNlbWVudCB3aGVuIGFkZGluZyBhIG5ldyBvcGVyYXRpb25zLCBsb3dlciBhcmUgcGxhY2VkIGZpcnN0ICovXG4gIG9yZGVyUmFuaz86IG51bWJlcjtcbiAgcmVuZGVyZXI6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblJlbmRlcmVyO1xuICBhZGRPcGVyYXRpb25IYW5kbGVyOiBRdWVyeUJ1aWxkZXJBZGRPcGVyYXRpb25IYW5kbGVyPFQ+O1xuICBwYXJhbUNoYW5nZWRIYW5kbGVyPzogUXVlcnlCdWlsZGVyT25QYXJhbUNoYW5nZWRIYW5kbGVyO1xuICBleHBsYWluSGFuZGxlcj86IFF1ZXJ5QnVpbGRlckV4cGxhaW5PcGVyYXRpb25IYW5kbGVyO1xuICBjaGFuZ2VUeXBlSGFuZGxlcj86IChvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBuZXdEZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZjxUPikgPT4gUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xufVxuXG5leHBvcnQgdHlwZSBRdWVyeUJ1aWxkZXJBZGRPcGVyYXRpb25IYW5kbGVyPFQ+ID0gKFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgcXVlcnk6IFQsXG4gIG1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyXG4pID0+IFQ7XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlckV4cGxhaW5PcGVyYXRpb25IYW5kbGVyID0gKG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmKSA9PiBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlck9uUGFyYW1DaGFuZ2VkSGFuZGxlciA9IChcbiAgaW5kZXg6IG51bWJlcixcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIG9wZXJhdGlvbkRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmXG4pID0+IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUmVuZGVyZXIgPSAoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSA9PiBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWUgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuO1xuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmIHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiAnc3RyaW5nJyB8ICdudW1iZXInIHwgJ2Jvb2xlYW4nO1xuICBvcHRpb25zPzogc3RyaW5nW10gfCBudW1iZXJbXSB8IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+PjtcbiAgaGlkZU5hbWU/OiBib29sZWFuO1xuICByZXN0UGFyYW0/OiBib29sZWFuO1xuICBvcHRpb25hbD86IGJvb2xlYW47XG4gIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgbWluV2lkdGg/OiBudW1iZXI7XG4gIGVkaXRvcj86IENvbXBvbmVudFR5cGU8UXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcz47XG4gIHJ1blF1ZXJ5T25FbnRlcj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRWRpdG9yUHJvcHMge1xuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgcXVlcnk6IGFueTtcbiAgZGF0YXNvdXJjZTogRGF0YVNvdXJjZUFwaTtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikgPT4gdm9pZDtcbiAgb25SZW1vdmU6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMge1xuICB2YWx1ZT86IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWU7XG4gIHBhcmFtRGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZjtcbiAgLyoqIFBhcmFtZXRlciBpbmRleCAqL1xuICBpbmRleDogbnVtYmVyO1xuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcbiAgb3BlcmF0aW9uSW5kZXg6IG51bWJlcjtcbiAgcXVlcnk6IGFueTtcbiAgZGF0YXNvdXJjZTogRGF0YVNvdXJjZUFwaTtcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCB2YWx1ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSkgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGVudW0gUXVlcnlFZGl0b3JNb2RlIHtcbiAgQ29kZSA9ICdjb2RlJyxcbiAgQnVpbGRlciA9ICdidWlsZGVyJyxcbiAgRXhwbGFpbiA9ICdleHBsYWluJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaXN1YWxRdWVyeU1vZGVsbGVyIHtcbiAgZ2V0T3BlcmF0aW9uc0ZvckNhdGVnb3J5KGNhdGVnb3J5OiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXTtcbiAgZ2V0QWx0ZXJuYXRpdmVPcGVyYXRpb25zKGtleTogc3RyaW5nKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW107XG4gIGdldENhdGVnb3JpZXMoKTogc3RyaW5nW107XG4gIGdldE9wZXJhdGlvbkRlZihpZDogc3RyaW5nKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIHwgdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBDb3JlQXBwIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgc3RvcmUgZnJvbSAnYXBwL2NvcmUvc3RvcmUnO1xuXG5pbXBvcnQgeyBMZWdlbmRGb3JtYXRNb2RlLCBQcm9tUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFF1ZXJ5RWRpdG9yTW9kZSB9IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcblxuY29uc3QgcXVlcnlFZGl0b3JNb2RlRGVmYXVsdExvY2FsU3RvcmFnZUtleSA9ICdQcm9tZXRoZXVzUXVlcnlFZGl0b3JNb2RlRGVmYXVsdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VFZGl0b3JNb2RlKHF1ZXJ5OiBQcm9tUXVlcnksIGVkaXRvck1vZGU6IFF1ZXJ5RWRpdG9yTW9kZSwgb25DaGFuZ2U6IChxdWVyeTogUHJvbVF1ZXJ5KSA9PiB2b2lkKSB7XG4gIC8vIElmIGVtcHR5IHF1ZXJ5IHN0b3JlIG5ldyBtb2RlIGFzIGRlZmF1bHRcbiAgaWYgKHF1ZXJ5LmV4cHIgPT09ICcnKSB7XG4gICAgc3RvcmUuc2V0KHF1ZXJ5RWRpdG9yTW9kZURlZmF1bHRMb2NhbFN0b3JhZ2VLZXksIGVkaXRvck1vZGUpO1xuICB9XG5cbiAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgZWRpdG9yTW9kZSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEVkaXRvck1vZGUoZXhwcjogc3RyaW5nKSB7XG4gIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhbiBleHByZXNzaW9uIGRlZmF1bHQgdG8gY29kZSB2aWV3XG4gIGlmIChleHByICE9IG51bGwgJiYgZXhwciAhPT0gJycpIHtcbiAgICByZXR1cm4gUXVlcnlFZGl0b3JNb2RlLkNvZGU7XG4gIH1cblxuICBjb25zdCB2YWx1ZSA9IHN0b3JlLmdldChxdWVyeUVkaXRvck1vZGVEZWZhdWx0TG9jYWxTdG9yYWdlS2V5KSBhcyBRdWVyeUVkaXRvck1vZGU7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIFF1ZXJ5RWRpdG9yTW9kZS5CdWlsZGVyOlxuICAgIGNhc2UgUXVlcnlFZGl0b3JNb2RlLkNvZGU6XG4gICAgY2FzZSBRdWVyeUVkaXRvck1vZGUuRXhwbGFpbjpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFF1ZXJ5RWRpdG9yTW9kZS5CdWlsZGVyO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBxdWVyeSB3aXRoIGRlZmF1bHRzLCBhbmQgYm9vbGVhbiB0cnVlL2ZhbHNlIGRlcGVuZGluZyBvbiBjaGFuZ2Ugd2FzIHJlcXVpcmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWVyeVdpdGhEZWZhdWx0cyhxdWVyeTogUHJvbVF1ZXJ5LCBhcHA6IENvcmVBcHAgfCB1bmRlZmluZWQpOiBQcm9tUXVlcnkge1xuICBsZXQgcmVzdWx0ID0gcXVlcnk7XG5cbiAgaWYgKCFxdWVyeS5lZGl0b3JNb2RlKSB7XG4gICAgcmVzdWx0ID0geyAuLi5xdWVyeSwgZWRpdG9yTW9kZTogZ2V0RGVmYXVsdEVkaXRvck1vZGUocXVlcnkuZXhwcikgfTtcbiAgfVxuXG4gIGlmIChxdWVyeS5leHByID09IG51bGwpIHtcbiAgICByZXN1bHQgPSB7IC4uLnJlc3VsdCwgZXhwcjogJycsIGxlZ2VuZEZvcm1hdDogTGVnZW5kRm9ybWF0TW9kZS5BdXRvIH07XG4gIH1cblxuICBpZiAocXVlcnkucmFuZ2UgPT0gbnVsbCAmJiBxdWVyeS5pbnN0YW50ID09IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHRvIHJhbmdlIHF1ZXJ5XG4gICAgcmVzdWx0ID0geyAuLi5yZXN1bHQsIHJhbmdlOiB0cnVlIH07XG5cbiAgICAvLyBJbiBleHBsb3JlIHdlIGRlZmF1bHQgdG8gYm90aCBpbnN0YW50ICYgcmFuZ2VcbiAgICBpZiAoYXBwID09PSBDb3JlQXBwLkV4cGxvcmUpIHtcbiAgICAgIHJlc3VsdC5pbnN0YW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBxdWVyeUVkaXRvclJhd1F1ZXJ5TG9jYWxTdG9yYWdlS2V5ID0gJ1Byb21ldGhldXNRdWVyeUVkaXRvclJhd1F1ZXJ5RGVmYXVsdCc7XG5cbmZ1bmN0aW9uIGdldFJhd1F1ZXJ5VmlzaWJpbGl0eSgpOiBib29sZWFuIHtcbiAgY29uc3QgdmFsID0gc3RvcmUuZ2V0KHF1ZXJ5RWRpdG9yUmF3UXVlcnlMb2NhbFN0b3JhZ2VLZXkpO1xuICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyB0cnVlIDogQm9vbGVhbihwYXJzZUludCh2YWwsIDEwKSk7XG59XG5cbmZ1bmN0aW9uIHNldFJhd1F1ZXJ5VmlzaWJpbGl0eSh2YWx1ZTogYm9vbGVhbikge1xuICBzdG9yZS5zZXQocXVlcnlFZGl0b3JSYXdRdWVyeUxvY2FsU3RvcmFnZUtleSwgdmFsdWUgPyAnMScgOiAnMCcpO1xufVxuXG4vKipcbiAqIFVzZSBhbmQgc3RvcmUgdmFsdWUgb2YgcmF3IHF1ZXJ5IHN3aXRjaCBpbiBsb2NhbCBzdG9yYWdlLlxuICogTmVlZHMgdG8gYmUgYSBob29rIHdpdGggbG9jYWwgc3RhdGUgdG8gdHJpZ2dlciByZXJlbmRlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSYXdRdWVyeSgpOiBbYm9vbGVhbiwgKHZhbDogYm9vbGVhbikgPT4gdm9pZF0ge1xuICBjb25zdCBbcmF3UXVlcnksIHNldFJhd1F1ZXJ5XSA9IHVzZVN0YXRlKGdldFJhd1F1ZXJ5VmlzaWJpbGl0eSgpKTtcbiAgY29uc3Qgc2V0dGVyID0gdXNlQ2FsbGJhY2soKHZhbHVlOiBib29sZWFuKSA9PiB7XG4gICAgc2V0UmF3UXVlcnlWaXNpYmlsaXR5KHZhbHVlKTtcbiAgICBzZXRSYXdRdWVyeSh2YWx1ZSk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gW3Jhd1F1ZXJ5LCBzZXR0ZXJdO1xufVxuIiwiaW1wb3J0IHsgVmlzdWFsUXVlcnlCaW5hcnkgfSBmcm9tICcuL3NoYXJlZC9Mb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gfSBmcm9tICcuL3NoYXJlZC90eXBlcyc7XG5cbi8qKlxuICogVmlzdWFsIHF1ZXJ5IG1vZGVsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVZpc3VhbFF1ZXJ5IHtcbiAgbWV0cmljOiBzdHJpbmc7XG4gIGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXTtcbiAgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW107XG4gIGJpbmFyeVF1ZXJpZXM/OiBQcm9tVmlzdWFsUXVlcnlCaW5hcnlbXTtcbn1cblxuZXhwb3J0IHR5cGUgUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5ID0gVmlzdWFsUXVlcnlCaW5hcnk8UHJvbVZpc3VhbFF1ZXJ5PjtcblxuZXhwb3J0IGVudW0gUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkge1xuICBBZ2dyZWdhdGlvbnMgPSAnQWdncmVnYXRpb25zJyxcbiAgUmFuZ2VGdW5jdGlvbnMgPSAnUmFuZ2UgZnVuY3Rpb25zJyxcbiAgRnVuY3Rpb25zID0gJ0Z1bmN0aW9ucycsXG4gIEJpbmFyeU9wcyA9ICdCaW5hcnkgb3BlcmF0aW9ucycsXG4gIFRyaWdvbm9tZXRyaWMgPSAnVHJpZ29ub21ldHJpYycsXG4gIFRpbWUgPSAnVGltZSBGdW5jdGlvbnMnLFxufVxuXG5leHBvcnQgZW51bSBQcm9tT3BlcmF0aW9uSWQge1xuICBBYnMgPSAnYWJzJyxcbiAgQWJzZW50ID0gJ2Fic2VudCcsXG4gIEFic2VudE92ZXJUaW1lID0gJ2Fic2VudF9vdmVyX3RpbWUnLFxuICBBY29zID0gJ2Fjb3MnLFxuICBBY29zaCA9ICdhY29zaCcsXG4gIEFzaW4gPSAnYXNpbicsXG4gIEFzaW5oID0gJ2FzaW5oJyxcbiAgQXRhbiA9ICdhdGFuJyxcbiAgQXRhbmggPSAnYXRhbmgnLFxuICBBdmcgPSAnYXZnJyxcbiAgQXZnT3ZlclRpbWUgPSAnYXZnX292ZXJfdGltZScsXG4gIEJvdHRvbUsgPSAnYm90dG9taycsXG4gIENlaWwgPSAnY2VpbCcsXG4gIENoYW5nZXMgPSAnY2hhbmdlcycsXG4gIENsYW1wID0gJ2NsYW1wJyxcbiAgQ2xhbXBNYXggPSAnY2xhbXBfbWF4JyxcbiAgQ2xhbXBNaW4gPSAnY2xhbXBfbWluJyxcbiAgQ29zID0gJ2NvcycsXG4gIENvc2ggPSAnY29zaCcsXG4gIENvdW50ID0gJ2NvdW50JyxcbiAgQ291bnRPdmVyVGltZSA9ICdjb3VudF9vdmVyX3RpbWUnLFxuICBDb3VudFNjYWxhciA9ICdjb3VudF9zY2FsYXInLFxuICBDb3VudFZhbHVlcyA9ICdjb3VudF92YWx1ZXMnLFxuICBEYXlPZk1vbnRoID0gJ2RheV9vZl9tb250aCcsXG4gIERheU9mV2VlayA9ICdkYXlfb2Zfd2VlaycsXG4gIERheXNJbk1vbnRoID0gJ2RheXNfaW5fbW9udGgnLFxuICBEZWcgPSAnZGVnJyxcbiAgRGVsdGEgPSAnZGVsdGEnLFxuICBEZXJpdiA9ICdkZXJpdicsXG4gIERyb3BDb21tb25MYWJlbHMgPSAnZHJvcF9jb21tb25fbGFiZWxzJyxcbiAgRXhwID0gJ2V4cCcsXG4gIEZsb29yID0gJ2Zsb29yJyxcbiAgR3JvdXAgPSAnZ3JvdXAnLFxuICBIaXN0b2dyYW1RdWFudGlsZSA9ICdoaXN0b2dyYW1fcXVhbnRpbGUnLFxuICBIb2x0V2ludGVycyA9ICdob2x0X3dpbnRlcnMnLFxuICBIb3VyID0gJ2hvdXInLFxuICBJZGVsdGEgPSAnaWRlbHRhJyxcbiAgSW5jcmVhc2UgPSAnaW5jcmVhc2UnLFxuICBJcmF0ZSA9ICdpcmF0ZScsXG4gIExhYmVsSm9pbiA9ICdsYWJlbF9qb2luJyxcbiAgTGFiZWxSZXBsYWNlID0gJ2xhYmVsX3JlcGxhY2UnLFxuICBMYXN0ID0gJ2xhc3QnLFxuICBMYXN0T3ZlclRpbWUgPSAnbGFzdF9vdmVyX3RpbWUnLFxuICBMbiA9ICdsbicsXG4gIExvZzEwID0gJ2xvZzEwJyxcbiAgTG9nMiA9ICdsb2cyJyxcbiAgTWF4ID0gJ21heCcsXG4gIE1heE92ZXJUaW1lID0gJ21heF9vdmVyX3RpbWUnLFxuICBNaW4gPSAnbWluJyxcbiAgTWluT3ZlclRpbWUgPSAnbWluX292ZXJfdGltZScsXG4gIE1pbnV0ZSA9ICdtaW51dGUnLFxuICBNb250aCA9ICdtb250aCcsXG4gIFBpID0gJ3BpJyxcbiAgUHJlZGljdExpbmVhciA9ICdwcmVkaWN0X2xpbmVhcicsXG4gIFByZXNlbnQgPSAncHJlc2VudCcsXG4gIFByZXNlbnRPdmVyVGltZSA9ICdwcmVzZW50X292ZXJfdGltZScsXG4gIFF1YW50aWxlID0gJ3F1YW50aWxlJyxcbiAgUXVhbnRpbGVPdmVyVGltZSA9ICdxdWFudGlsZV9vdmVyX3RpbWUnLFxuICBSYWQgPSAncmFkJyxcbiAgUmF0ZSA9ICdyYXRlJyxcbiAgUmVzZXRzID0gJ3Jlc2V0cycsXG4gIFJvdW5kID0gJ3JvdW5kJyxcbiAgU2NhbGFyID0gJ3NjYWxhcicsXG4gIFNnbiA9ICdzZ24nLFxuICBTaW4gPSAnc2luJyxcbiAgU2luaCA9ICdzaW5oJyxcbiAgU29ydCA9ICdzb3J0JyxcbiAgU29ydERlc2MgPSAnc29ydF9kZXNjJyxcbiAgU3FydCA9ICdzcXJ0JyxcbiAgU3RkZGV2ID0gJ3N0ZGRldicsXG4gIFN0ZGRldk92ZXJUaW1lID0gJ3N0ZGRldl9vdmVyX3RpbWUnLFxuICBTdW0gPSAnc3VtJyxcbiAgU3VtT3ZlclRpbWUgPSAnc3VtX292ZXJfdGltZScsXG4gIFRhbiA9ICd0YW4nLFxuICBUYW5oID0gJ3RhbmgnLFxuICBUaW1lID0gJ3RpbWUnLFxuICBUaW1lc3RhbXAgPSAndGltZXN0YW1wJyxcbiAgVG9wSyA9ICd0b3BrJyxcbiAgVmVjdG9yID0gJ3ZlY3RvcicsXG4gIFllYXIgPSAneWVhcicsXG4gIC8vIEJpbmFyeSBvcHNcbiAgQWRkaXRpb24gPSAnX19hZGRpdGlvbicsXG4gIFN1YnRyYWN0aW9uID0gJ19fc3VidHJhY3Rpb24nLFxuICBNdWx0aXBseUJ5ID0gJ19fbXVsdGlwbHlfYnknLFxuICBEaXZpZGVCeSA9ICdfX2RpdmlkZV9ieScsXG4gIE1vZHVsbyA9ICdfX21vZHVsbycsXG4gIEV4cG9uZW50ID0gJ19fZXhwb25lbnQnLFxuICBOZXN0ZWRRdWVyeSA9ICdfX25lc3RlZF9xdWVyeScsXG4gIEVxdWFsVG8gPSAnX19lcXVhbF90bycsXG4gIE5vdEVxdWFsVG8gPSAnX19ub3RfZXF1YWxfdG8nLFxuICBHcmVhdGVyVGhhbiA9ICdfX2dyZWF0ZXJfdGhhbicsXG4gIExlc3NUaGFuID0gJ19fbGVzc190aGFuJyxcbiAgR3JlYXRlck9yRXF1YWwgPSAnX19ncmVhdGVyX29yX2VxdWFsJyxcbiAgTGVzc09yRXF1YWwgPSAnX19sZXNzX29yX2VxdWFsJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tUXVlcnlQYXR0ZXJuIHtcbiAgbmFtZTogc3RyaW5nO1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbn1cbiIsImltcG9ydCB7IGRlc2NlbmRpbmcsIGRldmlhdGlvbiB9IGZyb20gJ2QzJztcbmltcG9ydCB7IGdyb3VwQnksIHBhcnRpdGlvbiB9IGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCB7XG4gIEFycmF5RGF0YUZyYW1lLFxuICBBcnJheVZlY3RvcixcbiAgQ29yZUFwcCxcbiAgRGF0YUZyYW1lLFxuICBEYXRhRnJhbWVUeXBlLFxuICBEYXRhTGluayxcbiAgRGF0YVF1ZXJ5UmVxdWVzdCxcbiAgRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIERhdGFUb3BpYyxcbiAgRmllbGQsXG4gIEZpZWxkVHlwZSxcbiAgZm9ybWF0TGFiZWxzLFxuICBnZXREaXNwbGF5UHJvY2Vzc29yLFxuICBMYWJlbHMsXG4gIE11dGFibGVGaWVsZCxcbiAgUHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGUsXG4gIFNjb3BlZFZhcnMsXG4gIFRJTUVfU0VSSUVTX1RJTUVfRklFTERfTkFNRSxcbiAgVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRSxcbn0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBGZXRjaFJlc3BvbnNlLCBnZXREYXRhU291cmNlU3J2LCBnZXRUZW1wbGF0ZVNydiB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuXG5pbXBvcnQgeyByZW5kZXJMZWdlbmRGb3JtYXQgfSBmcm9tICcuL2xlZ2VuZCc7XG5pbXBvcnQge1xuICBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbixcbiAgaXNFeGVtcGxhckRhdGEsXG4gIGlzTWF0cml4RGF0YSxcbiAgTWF0cml4T3JWZWN0b3JSZXN1bHQsXG4gIFByb21EYXRhU3VjY2Vzc1Jlc3BvbnNlLFxuICBQcm9tTWV0cmljLFxuICBQcm9tUXVlcnksXG4gIFByb21RdWVyeVJlcXVlc3QsXG4gIFByb21WYWx1ZSxcbiAgVHJhbnNmb3JtT3B0aW9ucyxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIGhhbmRsZXMgY2FzZS1pbnNlbnNpdGl2ZSBJbmYsICtJbmYsIC1JbmYgKHdpdGggb3B0aW9uYWwgXCJpbml0eVwiIHN1ZmZpeClcbmNvbnN0IElORklOSVRZX1NBTVBMRV9SRUdFWCA9IC9eWystXT9pbmYoPzppbml0eSk/JC9pO1xuXG5pbnRlcmZhY2UgVGltZUFuZFZhbHVlIHtcbiAgW1RJTUVfU0VSSUVTX1RJTUVfRklFTERfTkFNRV06IG51bWJlcjtcbiAgW1RJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUVdOiBudW1iZXI7XG59XG5cbmNvbnN0IGlzVGFibGVSZXN1bHQgPSAoZGF0YUZyYW1lOiBEYXRhRnJhbWUsIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pik6IGJvb2xlYW4gPT4ge1xuICAvLyBXZSB3YW50IHRvIHByb2Nlc3MgdmVjdG9yIGFuZCBzY2FsYXIgcmVzdWx0cyBpbiBFeHBsb3JlIGFzIHRhYmxlXG4gIGlmIChcbiAgICBvcHRpb25zLmFwcCA9PT0gQ29yZUFwcC5FeHBsb3JlICYmXG4gICAgKGRhdGFGcmFtZS5tZXRhPy5jdXN0b20/LnJlc3VsdFR5cGUgPT09ICd2ZWN0b3InIHx8IGRhdGFGcmFtZS5tZXRhPy5jdXN0b20/LnJlc3VsdFR5cGUgPT09ICdzY2FsYXInKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFdlIHdhbnQgdG8gcHJvY2VzcyBhbGwgZGF0YUZyYW1lcyB3aXRoIHRhcmdldC5mb3JtYXQgPT09ICd0YWJsZScgYXMgdGFibGVcbiAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXRzLmZpbmQoKHRhcmdldCkgPT4gdGFyZ2V0LnJlZklkID09PSBkYXRhRnJhbWUucmVmSWQpO1xuICByZXR1cm4gdGFyZ2V0Py5mb3JtYXQgPT09ICd0YWJsZSc7XG59O1xuXG5jb25zdCBpc0hlYXRtYXBSZXN1bHQgPSAoZGF0YUZyYW1lOiBEYXRhRnJhbWUsIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pik6IGJvb2xlYW4gPT4ge1xuICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldHMuZmluZCgodGFyZ2V0KSA9PiB0YXJnZXQucmVmSWQgPT09IGRhdGFGcmFtZS5yZWZJZCk7XG4gIHJldHVybiB0YXJnZXQ/LmZvcm1hdCA9PT0gJ2hlYXRtYXAnO1xufTtcblxuLy8gVjIgcmVzdWx0IHRyYXNuZm9ybWVyIHVzZWQgdG8gdHJhbnNmb3JtIHF1ZXJ5IHJlc3VsdHMgZnJvbSBxdWVyaWVzIHRoYXQgd2VyZSBydW4gdHJvdWdoIHByb21ldGhldXMgYmFja2VuZFxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVYyKFxuICByZXNwb25zZTogRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5PixcbiAgb3B0aW9uczogeyBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM/OiBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbltdIH1cbikge1xuICBjb25zdCBbdGFibGVGcmFtZXMsIGZyYW1lc1dpdGhvdXRUYWJsZV0gPSBwYXJ0aXRpb248RGF0YUZyYW1lPihyZXNwb25zZS5kYXRhLCAoZGYpID0+IGlzVGFibGVSZXN1bHQoZGYsIHJlcXVlc3QpKTtcbiAgY29uc3QgcHJvY2Vzc2VkVGFibGVGcmFtZXMgPSB0cmFuc2Zvcm1ERlRvVGFibGUodGFibGVGcmFtZXMpO1xuXG4gIGNvbnN0IFtleGVtcGxhckZyYW1lcywgZnJhbWVzV2l0aG91dFRhYmxlQW5kRXhlbXBsYXJzXSA9IHBhcnRpdGlvbjxEYXRhRnJhbWU+KFxuICAgIGZyYW1lc1dpdGhvdXRUYWJsZSxcbiAgICAoZGYpID0+IGRmLm1ldGE/LmN1c3RvbT8ucmVzdWx0VHlwZSA9PT0gJ2V4ZW1wbGFyJ1xuICApO1xuXG4gIC8vIEVYRU1QTEFSIEZSQU1FUzogV2UgZW5yaWNoIGV4ZW1wbGFyIGZyYW1lcyB3aXRoIGRhdGEgbGlua3MgYW5kIGFkZCBkYXRhVG9waWMgbWV0YSBpbmZvXG4gIGNvbnN0IHsgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zOiBkZXN0aW5hdGlvbnMgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHByb2Nlc3NlZEV4ZW1wbGFyRnJhbWVzID0gZXhlbXBsYXJGcmFtZXMubWFwKChkYXRhRnJhbWUpID0+IHtcbiAgICBpZiAoZGVzdGluYXRpb25zPy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24gb2YgZGVzdGluYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRyYWNlSURGaWVsZCA9IGRhdGFGcmFtZS5maWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uLm5hbWUpO1xuICAgICAgICBpZiAodHJhY2VJREZpZWxkKSB7XG4gICAgICAgICAgY29uc3QgbGlua3MgPSBnZXREYXRhTGlua3MoZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24pO1xuICAgICAgICAgIHRyYWNlSURGaWVsZC5jb25maWcubGlua3MgPSB0cmFjZUlERmllbGQuY29uZmlnLmxpbmtzPy5sZW5ndGhcbiAgICAgICAgICAgID8gWy4uLnRyYWNlSURGaWVsZC5jb25maWcubGlua3MsIC4uLmxpbmtzXVxuICAgICAgICAgICAgOiBsaW5rcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IC4uLmRhdGFGcmFtZSwgbWV0YTogeyAuLi5kYXRhRnJhbWUubWV0YSwgZGF0YVRvcGljOiBEYXRhVG9waWMuQW5ub3RhdGlvbnMgfSB9O1xuICB9KTtcblxuICBjb25zdCBbaGVhdG1hcFJlc3VsdHMsIGZyYW1lc1dpdGhvdXRUYWJsZUhlYXRtYXBzQW5kRXhlbXBsYXJzXSA9IHBhcnRpdGlvbjxEYXRhRnJhbWU+KFxuICAgIGZyYW1lc1dpdGhvdXRUYWJsZUFuZEV4ZW1wbGFycyxcbiAgICAoZGYpID0+IGlzSGVhdG1hcFJlc3VsdChkZiwgcmVxdWVzdClcbiAgKTtcblxuICBjb25zdCBwcm9jZXNzZWRIZWF0bWFwRnJhbWVzID0gbWVyZ2VIZWF0bWFwRnJhbWVzKFxuICAgIHRyYW5zZm9ybVRvSGlzdG9ncmFtT3ZlclRpbWUoaGVhdG1hcFJlc3VsdHMuc29ydChzb3J0U2VyaWVzQnlMYWJlbCkpXG4gICk7XG5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIHByb2Nlc3NlZCBhcyB0aW1lX3NlcmllcyByZXN1bHQgYW5kIGdyYXBoIHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlXG4gIGNvbnN0IG90aGVyRnJhbWVzID0gZnJhbWVzV2l0aG91dFRhYmxlSGVhdG1hcHNBbmRFeGVtcGxhcnMubWFwKChkYXRhRnJhbWUpID0+IHtcbiAgICBjb25zdCBkZiA9IHtcbiAgICAgIC4uLmRhdGFGcmFtZSxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4uZGF0YUZyYW1lLm1ldGEsXG4gICAgICAgIHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAnZ3JhcGgnLFxuICAgICAgfSxcbiAgICB9IGFzIERhdGFGcmFtZTtcbiAgICByZXR1cm4gZGY7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgLi4ucmVzcG9uc2UsXG4gICAgZGF0YTogWy4uLm90aGVyRnJhbWVzLCAuLi5wcm9jZXNzZWRUYWJsZUZyYW1lcywgLi4ucHJvY2Vzc2VkSGVhdG1hcEZyYW1lcywgLi4ucHJvY2Vzc2VkRXhlbXBsYXJGcmFtZXNdLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtREZUb1RhYmxlKGRmczogRGF0YUZyYW1lW10pOiBEYXRhRnJhbWVbXSB7XG4gIC8vIElmIG5vIGRhdGFGcmFtZXMgb3IgaWYgMSBkYXRhRnJhbWVzIHdpdGggbm8gdmFsdWVzLCByZXR1cm4gb3JpZ2luYWwgZGF0YUZyYW1lXG4gIGlmIChkZnMubGVuZ3RoID09PSAwIHx8IChkZnMubGVuZ3RoID09PSAxICYmIGRmc1swXS5sZW5ndGggPT09IDApKSB7XG4gICAgcmV0dXJuIGRmcztcbiAgfVxuXG4gIC8vIEdyb3VwIHJlc3VsdHMgYnkgcmVmSWQgYW5kIHByb2Nlc3MgZGF0YUZyYW1lcyB3aXRoIHRoZSBzYW1lIHJlZklkIGFzIDEgZGF0YUZyYW1lXG4gIGNvbnN0IGRhdGFGcmFtZXNCeVJlZklkID0gZ3JvdXBCeShkZnMsICdyZWZJZCcpO1xuICBjb25zdCByZWZJZHMgPSBPYmplY3Qua2V5cyhkYXRhRnJhbWVzQnlSZWZJZCk7XG5cbiAgY29uc3QgZnJhbWVzID0gcmVmSWRzLm1hcCgocmVmSWQpID0+IHtcbiAgICAvLyBDcmVhdGUgdGltZUZpZWxkLCB2YWx1ZUZpZWxkIGFuZCBsYWJlbEZpZWxkc1xuICAgIGNvbnN0IHZhbHVlVGV4dCA9IGdldFZhbHVlVGV4dChyZWZJZHMubGVuZ3RoLCByZWZJZCk7XG4gICAgY29uc3QgdmFsdWVGaWVsZCA9IGdldFZhbHVlRmllbGQoeyBkYXRhOiBbXSwgdmFsdWVOYW1lOiB2YWx1ZVRleHQgfSk7XG4gICAgY29uc3QgdGltZUZpZWxkID0gZ2V0VGltZUZpZWxkKFtdKTtcbiAgICBjb25zdCBsYWJlbEZpZWxkczogTXV0YWJsZUZpZWxkW10gPSBbXTtcblxuICAgIC8vIEZpbGwgbGFiZWxzRmllbGRzIHdpdGggbGFiZWxzIGZyb20gZGF0YUZyYW1lc1xuICAgIGRhdGFGcmFtZXNCeVJlZklkW3JlZklkXS5mb3JFYWNoKChkZikgPT4ge1xuICAgICAgY29uc3QgZnJhbWVWYWx1ZUZpZWxkID0gZGYuZmllbGRzWzFdO1xuICAgICAgY29uc3QgcHJvbUxhYmVscyA9IGZyYW1lVmFsdWVGaWVsZC5sYWJlbHMgPz8ge307XG5cbiAgICAgIE9iamVjdC5rZXlzKHByb21MYWJlbHMpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBsYWJlbCBpbiBsYWJlbEZpZWxkcywgYWRkIGl0XG4gICAgICAgICAgaWYgKCFsYWJlbEZpZWxkcy5zb21lKChsKSA9PiBsLm5hbWUgPT09IGxhYmVsKSkge1xuICAgICAgICAgICAgY29uc3QgbnVtYmVyRmllbGQgPSBsYWJlbCA9PT0gJ2xlJztcbiAgICAgICAgICAgIGxhYmVsRmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgICAgICAgY29uZmlnOiB7IGZpbHRlcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgICAgdHlwZTogbnVtYmVyRmllbGQgPyBGaWVsZFR5cGUubnVtYmVyIDogRmllbGRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3IoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBGaWxsIHZhbHVlRmllbGQsIHRpbWVGaWVsZCBhbmQgbGFiZWxGaWVsZHMgd2l0aCB2YWx1ZXNcbiAgICBkYXRhRnJhbWVzQnlSZWZJZFtyZWZJZF0uZm9yRWFjaCgoZGYpID0+IHtcbiAgICAgIGRmLmZpZWxkc1swXS52YWx1ZXMudG9BcnJheSgpLmZvckVhY2goKHZhbHVlKSA9PiB0aW1lRmllbGQudmFsdWVzLmFkZCh2YWx1ZSkpO1xuICAgICAgZGYuZmllbGRzWzFdLnZhbHVlcy50b0FycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgdmFsdWVGaWVsZC52YWx1ZXMuYWRkKHBhcnNlU2FtcGxlVmFsdWUodmFsdWUpKTtcbiAgICAgICAgY29uc3QgbGFiZWxzRm9yRmllbGQgPSBkZi5maWVsZHNbMV0ubGFiZWxzID8/IHt9O1xuICAgICAgICBsYWJlbEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4gZmllbGQudmFsdWVzLmFkZChnZXRMYWJlbFZhbHVlKGxhYmVsc0ZvckZpZWxkLCBmaWVsZC5uYW1lKSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBmaWVsZHMgPSBbdGltZUZpZWxkLCAuLi5sYWJlbEZpZWxkcywgdmFsdWVGaWVsZF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZklkLFxuICAgICAgZmllbGRzLFxuICAgICAgbWV0YTogeyAuLi5kZnNbMF0ubWV0YSwgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6ICd0YWJsZScgYXMgUHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGUgfSxcbiAgICAgIGxlbmd0aDogdGltZUZpZWxkLnZhbHVlcy5sZW5ndGgsXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBmcmFtZXM7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlVGV4dChyZXNwb25zZUxlbmd0aDogbnVtYmVyLCByZWZJZCA9ICcnKSB7XG4gIHJldHVybiByZXNwb25zZUxlbmd0aCA+IDEgPyBgVmFsdWUgIyR7cmVmSWR9YCA6ICdWYWx1ZSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0oXG4gIHJlc3BvbnNlOiBGZXRjaFJlc3BvbnNlPFByb21EYXRhU3VjY2Vzc1Jlc3BvbnNlPixcbiAgdHJhbnNmb3JtT3B0aW9uczoge1xuICAgIHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0O1xuICAgIGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucz86IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uW107XG4gICAgdGFyZ2V0OiBQcm9tUXVlcnk7XG4gICAgcmVzcG9uc2VMaXN0TGVuZ3RoOiBudW1iZXI7XG4gICAgc2NvcGVkVmFycz86IFNjb3BlZFZhcnM7XG4gIH1cbikge1xuICAvLyBDcmVhdGUgb3B0aW9ucyBvYmplY3QgZnJvbSB0cmFuc2Zvcm1PcHRpb25zXG4gIGNvbnN0IG9wdGlvbnM6IFRyYW5zZm9ybU9wdGlvbnMgPSB7XG4gICAgZm9ybWF0OiB0cmFuc2Zvcm1PcHRpb25zLnRhcmdldC5mb3JtYXQsXG4gICAgc3RlcDogdHJhbnNmb3JtT3B0aW9ucy5xdWVyeS5zdGVwLFxuICAgIGxlZ2VuZEZvcm1hdDogdHJhbnNmb3JtT3B0aW9ucy50YXJnZXQubGVnZW5kRm9ybWF0LFxuICAgIHN0YXJ0OiB0cmFuc2Zvcm1PcHRpb25zLnF1ZXJ5LnN0YXJ0LFxuICAgIGVuZDogdHJhbnNmb3JtT3B0aW9ucy5xdWVyeS5lbmQsXG4gICAgcXVlcnk6IHRyYW5zZm9ybU9wdGlvbnMucXVlcnkuZXhwcixcbiAgICByZXNwb25zZUxpc3RMZW5ndGg6IHRyYW5zZm9ybU9wdGlvbnMucmVzcG9uc2VMaXN0TGVuZ3RoLFxuICAgIHNjb3BlZFZhcnM6IHRyYW5zZm9ybU9wdGlvbnMuc2NvcGVkVmFycyxcbiAgICByZWZJZDogdHJhbnNmb3JtT3B0aW9ucy50YXJnZXQucmVmSWQsXG4gICAgdmFsdWVXaXRoUmVmSWQ6IHRyYW5zZm9ybU9wdGlvbnMudGFyZ2V0LnZhbHVlV2l0aFJlZklkLFxuICAgIG1ldGE6IHtcbiAgICAgIC8vIEZpeCBmb3Igc2hvd2luZyBvZiBQcm9tZXRoZXVzIHJlc3VsdHMgaW4gRXhwbG9yZSB0YWJsZVxuICAgICAgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6IHRyYW5zZm9ybU9wdGlvbnMucXVlcnkuaW5zdGFudCA/ICd0YWJsZScgOiAnZ3JhcGgnLFxuICAgIH0sXG4gIH07XG4gIGNvbnN0IHByb21ldGhldXNSZXN1bHQgPSByZXNwb25zZS5kYXRhLmRhdGE7XG5cbiAgaWYgKGlzRXhlbXBsYXJEYXRhKHByb21ldGhldXNSZXN1bHQpKSB7XG4gICAgY29uc3QgZXZlbnRzOiBUaW1lQW5kVmFsdWVbXSA9IFtdO1xuICAgIHByb21ldGhldXNSZXN1bHQuZm9yRWFjaCgoZXhlbXBsYXJEYXRhKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gZXhlbXBsYXJEYXRhLmV4ZW1wbGFycy5tYXAoKGV4ZW1wbGFyKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW1RJTUVfU0VSSUVTX1RJTUVfRklFTERfTkFNRV06IGV4ZW1wbGFyLnRpbWVzdGFtcCAqIDEwMDAsXG4gICAgICAgICAgW1RJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUVdOiBleGVtcGxhci52YWx1ZSxcbiAgICAgICAgICAuLi5leGVtcGxhci5sYWJlbHMsXG4gICAgICAgICAgLi4uZXhlbXBsYXJEYXRhLnNlcmllc0xhYmVscyxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgZXZlbnRzLnB1c2goLi4uZGF0YSk7XG4gICAgfSk7XG5cbiAgICAvLyBHcm91cGluZyBleGVtcGxhcnMgYnkgc3RlcFxuICAgIGNvbnN0IHNhbXBsZWRFeGVtcGxhcnMgPSBzYW1wbGVFeGVtcGxhcnMoZXZlbnRzLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGRhdGFGcmFtZSA9IG5ldyBBcnJheURhdGFGcmFtZShzYW1wbGVkRXhlbXBsYXJzKTtcbiAgICBkYXRhRnJhbWUubWV0YSA9IHsgZGF0YVRvcGljOiBEYXRhVG9waWMuQW5ub3RhdGlvbnMgfTtcblxuICAgIC8vIEFkZCBkYXRhIGxpbmtzIGlmIGNvbmZpZ3VyZWRcbiAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy5leGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbiBvZiB0cmFuc2Zvcm1PcHRpb25zLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucykge1xuICAgICAgICBjb25zdCB0cmFjZUlERmllbGQgPSBkYXRhRnJhbWUuZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5uYW1lID09PSBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbi5uYW1lKTtcbiAgICAgICAgaWYgKHRyYWNlSURGaWVsZCkge1xuICAgICAgICAgIGNvbnN0IGxpbmtzID0gZ2V0RGF0YUxpbmtzKGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uKTtcbiAgICAgICAgICB0cmFjZUlERmllbGQuY29uZmlnLmxpbmtzID0gdHJhY2VJREZpZWxkLmNvbmZpZy5saW5rcz8ubGVuZ3RoXG4gICAgICAgICAgICA/IFsuLi50cmFjZUlERmllbGQuY29uZmlnLmxpbmtzLCAuLi5saW5rc11cbiAgICAgICAgICAgIDogbGlua3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtkYXRhRnJhbWVdO1xuICB9XG5cbiAgaWYgKCFwcm9tZXRoZXVzUmVzdWx0Py5yZXN1bHQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyBSZXR1cm4gZWFybHkgaWYgcmVzdWx0IHR5cGUgaXMgc2NhbGFyXG4gIGlmIChwcm9tZXRoZXVzUmVzdWx0LnJlc3VsdFR5cGUgPT09ICdzY2FsYXInKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbWV0YTogb3B0aW9ucy5tZXRhLFxuICAgICAgICByZWZJZDogb3B0aW9ucy5yZWZJZCxcbiAgICAgICAgbGVuZ3RoOiAxLFxuICAgICAgICBmaWVsZHM6IFtnZXRUaW1lRmllbGQoW3Byb21ldGhldXNSZXN1bHQucmVzdWx0XSksIGdldFZhbHVlRmllbGQoeyBkYXRhOiBbcHJvbWV0aGV1c1Jlc3VsdC5yZXN1bHRdIH0pXSxcbiAgICAgIH0sXG4gICAgXTtcbiAgfVxuXG4gIC8vIFJldHVybiBlYXJseSBhZ2FpbiBpZiB0aGUgZm9ybWF0IGlzIHRhYmxlLCB0aGlzIG5lZWRzIHNwZWNpYWwgdHJhbnNmb3JtYXRpb24uXG4gIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJ3RhYmxlJykge1xuICAgIGNvbnN0IHRhYmxlRGF0YSA9IHRyYW5zZm9ybU1ldHJpY0RhdGFUb1RhYmxlKHByb21ldGhldXNSZXN1bHQucmVzdWx0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gW3RhYmxlRGF0YV07XG4gIH1cblxuICAvLyBQcm9jZXNzIG1hdHJpeCBhbmQgdmVjdG9yIHJlc3VsdHMgdG8gRGF0YUZyYW1lXG4gIGNvbnN0IGRhdGFGcmFtZTogRGF0YUZyYW1lW10gPSBbXTtcbiAgcHJvbWV0aGV1c1Jlc3VsdC5yZXN1bHQuZm9yRWFjaCgoZGF0YTogTWF0cml4T3JWZWN0b3JSZXN1bHQpID0+IGRhdGFGcmFtZS5wdXNoKHRyYW5zZm9ybVRvRGF0YUZyYW1lKGRhdGEsIG9wdGlvbnMpKSk7XG5cbiAgLy8gV2hlbiBmb3JtYXQgaXMgaGVhdG1hcCB1c2UgdGhlIGFscmVhZHkgY3JlYXRlZCBkYXRhIGZyYW1lcyBhbmQgdHJhbnNmb3JtIGl0IG1vcmVcbiAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAnaGVhdG1hcCcpIHtcbiAgICByZXR1cm4gbWVyZ2VIZWF0bWFwRnJhbWVzKHRyYW5zZm9ybVRvSGlzdG9ncmFtT3ZlclRpbWUoZGF0YUZyYW1lLnNvcnQoc29ydFNlcmllc0J5TGFiZWwpKSk7XG4gIH1cblxuICAvLyBSZXR1cm4gbWF0cml4IG9yIHZlY3RvciByZXN1bHQgYXMgRGF0YUZyYW1lW11cbiAgcmV0dXJuIGRhdGFGcmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YUxpbmtzKG9wdGlvbnM6IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uKTogRGF0YUxpbmtbXSB7XG4gIGNvbnN0IGRhdGFMaW5rczogRGF0YUxpbmtbXSA9IFtdO1xuXG4gIGlmIChvcHRpb25zLmRhdGFzb3VyY2VVaWQpIHtcbiAgICBjb25zdCBkYXRhU291cmNlU3J2ID0gZ2V0RGF0YVNvdXJjZVNydigpO1xuICAgIGNvbnN0IGRzU2V0dGluZ3MgPSBkYXRhU291cmNlU3J2LmdldEluc3RhbmNlU2V0dGluZ3Mob3B0aW9ucy5kYXRhc291cmNlVWlkKTtcblxuICAgIC8vIGRzU2V0dGluZ3MgaXMgdW5kZWZpbmVkIGJlY2F1c2Ugb2YgdGhlIHJlYXNvbnMgYmVsb3c6XG4gICAgLy8gLSBwZXJtaXNzaW9ucyBpc3N1ZXMgKHByb2JhYmx5IG1vc3QgbGlrZWx5KVxuICAgIC8vIC0gZGVsZXRlZCBkYXRhc291cmNlXG4gICAgLy8gLSBtaXNjb25maWd1cmF0aW9uXG4gICAgaWYgKGRzU2V0dGluZ3MpIHtcbiAgICAgIGRhdGFMaW5rcy5wdXNoKHtcbiAgICAgICAgdGl0bGU6IG9wdGlvbnMudXJsRGlzcGxheUxhYmVsIHx8IGBRdWVyeSB3aXRoICR7ZHNTZXR0aW5ncz8ubmFtZX1gLFxuICAgICAgICB1cmw6ICcnLFxuICAgICAgICBpbnRlcm5hbDoge1xuICAgICAgICAgIHF1ZXJ5OiB7IHF1ZXJ5OiAnJHtfX3ZhbHVlLnJhd30nLCBxdWVyeVR5cGU6ICd0cmFjZUlkJyB9LFxuICAgICAgICAgIGRhdGFzb3VyY2VVaWQ6IG9wdGlvbnMuZGF0YXNvdXJjZVVpZCxcbiAgICAgICAgICBkYXRhc291cmNlTmFtZTogZHNTZXR0aW5ncz8ubmFtZSA/PyAnRGF0YSBzb3VyY2Ugbm90IGZvdW5kJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnVybCkge1xuICAgIGRhdGFMaW5rcy5wdXNoKHtcbiAgICAgIHRpdGxlOiBvcHRpb25zLnVybERpc3BsYXlMYWJlbCB8fCBgR28gdG8gJHtvcHRpb25zLnVybH1gLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIHRhcmdldEJsYW5rOiB0cnVlLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkYXRhTGlua3M7XG59XG5cbi8qKlxuICogUmVkdWNlIHRoZSBkZW5zaXR5IG9mIHRoZSBleGVtcGxhcnMgYnkgbWFraW5nIHN1cmUgdGhhdCB0aGUgaGlnaGVzdCB2YWx1ZSBleGVtcGxhciBpcyBpbmNsdWRlZFxuICogYW5kIHRoZW4gb25seSB0aGUgb25lcyB0aGF0IGFyZSAyIHRpbWVzIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIGFsbCB0aGUgdmFsdWVzLlxuICogVGhpcyBtYWtlcyBzdXJlIG5vdCB0byBzaG93IHRvbyBtYW55IGRvdHMgbmVhciBlYWNoIG90aGVyLlxuICovXG5mdW5jdGlvbiBzYW1wbGVFeGVtcGxhcnMoZXZlbnRzOiBUaW1lQW5kVmFsdWVbXSwgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucykge1xuICBjb25zdCBzdGVwID0gb3B0aW9ucy5zdGVwIHx8IDE1O1xuICBjb25zdCBidWNrZXRlZEV4ZW1wbGFyczogeyBbdHM6IHN0cmluZ106IFRpbWVBbmRWYWx1ZVtdIH0gPSB7fTtcbiAgY29uc3QgdmFsdWVzOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGV4ZW1wbGFyIG9mIGV2ZW50cykge1xuICAgIC8vIEFsaWduIGV4ZW1wbGFyIHRpbWVzdGFtcCB0byBuZWFyZXN0IHN0ZXAgc2Vjb25kXG4gICAgY29uc3QgYWxpZ25lZFRzID0gU3RyaW5nKE1hdGguZmxvb3IoZXhlbXBsYXJbVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FXSAvIDEwMDAgLyBzdGVwKSAqIHN0ZXAgKiAxMDAwKTtcbiAgICBpZiAoIWJ1Y2tldGVkRXhlbXBsYXJzW2FsaWduZWRUc10pIHtcbiAgICAgIC8vIE5ldyBidWNrZXQgZm91bmRcbiAgICAgIGJ1Y2tldGVkRXhlbXBsYXJzW2FsaWduZWRUc10gPSBbXTtcbiAgICB9XG4gICAgYnVja2V0ZWRFeGVtcGxhcnNbYWxpZ25lZFRzXS5wdXNoKGV4ZW1wbGFyKTtcbiAgICB2YWx1ZXMucHVzaChleGVtcGxhcltUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FXSk7XG4gIH1cblxuICAvLyBHZXR0aW5nIGV4ZW1wbGFycyBmcm9tIGVhY2ggYnVja2V0XG4gIGNvbnN0IHN0YW5kYXJkRGV2aWF0aW9uID0gZGV2aWF0aW9uKHZhbHVlcyk7XG4gIGNvbnN0IHNhbXBsZWRCdWNrZXRzID0gT2JqZWN0LmtleXMoYnVja2V0ZWRFeGVtcGxhcnMpLnNvcnQoKTtcbiAgY29uc3Qgc2FtcGxlZEV4ZW1wbGFycyA9IFtdO1xuICBmb3IgKGNvbnN0IHRzIG9mIHNhbXBsZWRCdWNrZXRzKSB7XG4gICAgY29uc3QgZXhlbXBsYXJzSW5CdWNrZXQgPSBidWNrZXRlZEV4ZW1wbGFyc1t0c107XG4gICAgaWYgKGV4ZW1wbGFyc0luQnVja2V0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgc2FtcGxlZEV4ZW1wbGFycy5wdXNoKGV4ZW1wbGFyc0luQnVja2V0WzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hvb3NlIHdoaWNoIHZhbHVlcyB0byBzYW1wbGVcbiAgICAgIGNvbnN0IGJ1Y2tldFZhbHVlcyA9IGV4ZW1wbGFyc0luQnVja2V0Lm1hcCgoZXgpID0+IGV4W1RJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUVdKS5zb3J0KGRlc2NlbmRpbmcpO1xuICAgICAgY29uc3Qgc2FtcGxlZEJ1Y2tldFZhbHVlcyA9IGJ1Y2tldFZhbHVlcy5yZWR1Y2UoKGFjYzogbnVtYmVyW10sIGN1cnIpID0+IHtcbiAgICAgICAgaWYgKGFjYy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBGaXJzdCB2YWx1ZSBpcyBtYXggYW5kIGlzIGFsd2F5cyBhZGRlZFxuICAgICAgICAgIGFjYy5wdXNoKGN1cnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZW4gdGFrZSB2YWx1ZXMgb25seSB3aGVuIGF0IGxlYXN0IDIgc3RhbmRhcmQgZGV2aWF0aW9uIGRpc3RhbmNlIHRvIHByZXZpb3VzbHkgdGFrZW4gdmFsdWVcbiAgICAgICAgICBjb25zdCBwcmV2ID0gYWNjW2FjYy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAoc3RhbmRhcmREZXZpYXRpb24gJiYgcHJldiAtIGN1cnIgPj0gMiAqIHN0YW5kYXJkRGV2aWF0aW9uKSB7XG4gICAgICAgICAgICBhY2MucHVzaChjdXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIFtdKTtcbiAgICAgIC8vIEZpbmQgdGhlIGV4ZW1wbGFycyBmb3IgdGhlIHNhbXBsZWQgdmFsdWVzXG4gICAgICBzYW1wbGVkRXhlbXBsYXJzLnB1c2goXG4gICAgICAgIC4uLnNhbXBsZWRCdWNrZXRWYWx1ZXMubWFwKFxuICAgICAgICAgICh2YWx1ZSkgPT4gZXhlbXBsYXJzSW5CdWNrZXQuZmluZCgoZXgpID0+IGV4W1RJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUVdID09PSB2YWx1ZSkhXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzYW1wbGVkRXhlbXBsYXJzO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgbWF0cml4IGFuZCB2ZWN0b3IgcmVzdWx0IGZyb20gUHJvbWV0aGV1cyByZXN1bHQgdG8gRGF0YUZyYW1lXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVRvRGF0YUZyYW1lKGRhdGE6IE1hdHJpeE9yVmVjdG9yUmVzdWx0LCBvcHRpb25zOiBUcmFuc2Zvcm1PcHRpb25zKTogRGF0YUZyYW1lIHtcbiAgY29uc3QgeyBuYW1lLCBsYWJlbHMgfSA9IGNyZWF0ZUxhYmVsSW5mbyhkYXRhLm1ldHJpYywgb3B0aW9ucyk7XG5cbiAgY29uc3QgZmllbGRzOiBGaWVsZFtdID0gW107XG5cbiAgaWYgKGlzTWF0cml4RGF0YShkYXRhKSkge1xuICAgIGNvbnN0IHN0ZXBNcyA9IG9wdGlvbnMuc3RlcCA/IG9wdGlvbnMuc3RlcCAqIDEwMDAgOiBOYU47XG4gICAgbGV0IGJhc2VUaW1lc3RhbXAgPSBvcHRpb25zLnN0YXJ0ICogMTAwMDtcbiAgICBjb25zdCBkcHM6IFByb21WYWx1ZVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRhdGEudmFsdWVzKSB7XG4gICAgICBsZXQgZHBWYWx1ZTogbnVtYmVyIHwgbnVsbCA9IHBhcnNlU2FtcGxlVmFsdWUodmFsdWVbMV0pO1xuXG4gICAgICBpZiAoaXNOYU4oZHBWYWx1ZSkpIHtcbiAgICAgICAgZHBWYWx1ZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHZhbHVlWzBdICogMTAwMDtcbiAgICAgIGZvciAobGV0IHQgPSBiYXNlVGltZXN0YW1wOyB0IDwgdGltZXN0YW1wOyB0ICs9IHN0ZXBNcykge1xuICAgICAgICBkcHMucHVzaChbdCwgbnVsbF0pO1xuICAgICAgfVxuICAgICAgYmFzZVRpbWVzdGFtcCA9IHRpbWVzdGFtcCArIHN0ZXBNcztcbiAgICAgIGRwcy5wdXNoKFt0aW1lc3RhbXAsIGRwVmFsdWVdKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmRUaW1lc3RhbXAgPSBvcHRpb25zLmVuZCAqIDEwMDA7XG4gICAgZm9yIChsZXQgdCA9IGJhc2VUaW1lc3RhbXA7IHQgPD0gZW5kVGltZXN0YW1wOyB0ICs9IHN0ZXBNcykge1xuICAgICAgZHBzLnB1c2goW3QsIG51bGxdKTtcbiAgICB9XG4gICAgZmllbGRzLnB1c2goZ2V0VGltZUZpZWxkKGRwcywgdHJ1ZSkpO1xuICAgIGZpZWxkcy5wdXNoKGdldFZhbHVlRmllbGQoeyBkYXRhOiBkcHMsIHBhcnNlVmFsdWU6IGZhbHNlLCBsYWJlbHMsIGRpc3BsYXlOYW1lRnJvbURTOiBuYW1lIH0pKTtcbiAgfSBlbHNlIHtcbiAgICBmaWVsZHMucHVzaChnZXRUaW1lRmllbGQoW2RhdGEudmFsdWVdKSk7XG4gICAgZmllbGRzLnB1c2goZ2V0VmFsdWVGaWVsZCh7IGRhdGE6IFtkYXRhLnZhbHVlXSwgbGFiZWxzLCBkaXNwbGF5TmFtZUZyb21EUzogbmFtZSB9KSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1ldGE6IG9wdGlvbnMubWV0YSxcbiAgICByZWZJZDogb3B0aW9ucy5yZWZJZCxcbiAgICBsZW5ndGg6IGZpZWxkc1swXS52YWx1ZXMubGVuZ3RoLFxuICAgIGZpZWxkcyxcbiAgICBuYW1lLFxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NZXRyaWNEYXRhVG9UYWJsZShtZDogTWF0cml4T3JWZWN0b3JSZXN1bHRbXSwgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucyk6IERhdGFGcmFtZSB7XG4gIGlmICghbWQgfHwgbWQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGE6IG9wdGlvbnMubWV0YSxcbiAgICAgIHJlZklkOiBvcHRpb25zLnJlZklkLFxuICAgICAgbGVuZ3RoOiAwLFxuICAgICAgZmllbGRzOiBbXSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgdmFsdWVUZXh0ID0gb3B0aW9ucy5yZXNwb25zZUxpc3RMZW5ndGggPiAxIHx8IG9wdGlvbnMudmFsdWVXaXRoUmVmSWQgPyBgVmFsdWUgIyR7b3B0aW9ucy5yZWZJZH1gIDogJ1ZhbHVlJztcblxuICBjb25zdCB0aW1lRmllbGQgPSBnZXRUaW1lRmllbGQoW10pO1xuICBjb25zdCBtZXRyaWNGaWVsZHMgPSBPYmplY3Qua2V5cyhtZC5yZWR1Y2UoKGFjYywgc2VyaWVzKSA9PiAoeyAuLi5hY2MsIC4uLnNlcmllcy5tZXRyaWMgfSksIHt9KSlcbiAgICAuc29ydCgpXG4gICAgLm1hcCgobGFiZWwpID0+IHtcbiAgICAgIC8vIExhYmVscyBoYXZlIHN0cmluZyBmaWVsZCB0eXBlLCBvdGhlcndpc2UgdGFibGUgdHJpZXMgdG8gZmlndXJlIG91dCB0aGUgdHlwZSB3aGljaCBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgcmVzdWx0c1xuICAgICAgLy8gT25seSBcImxlXCIgbGFiZWwgaGFzIGEgbnVtYmVyIGZpZWxkIHR5cGVcbiAgICAgIGNvbnN0IG51bWJlckZpZWxkID0gbGFiZWwgPT09ICdsZSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgY29uZmlnOiB7IGZpbHRlcmFibGU6IHRydWUgfSxcbiAgICAgICAgdHlwZTogbnVtYmVyRmllbGQgPyBGaWVsZFR5cGUubnVtYmVyIDogRmllbGRUeXBlLnN0cmluZyxcbiAgICAgICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3IoKSxcbiAgICAgIH07XG4gICAgfSk7XG4gIGNvbnN0IHZhbHVlRmllbGQgPSBnZXRWYWx1ZUZpZWxkKHsgZGF0YTogW10sIHZhbHVlTmFtZTogdmFsdWVUZXh0IH0pO1xuXG4gIG1kLmZvckVhY2goKGQpID0+IHtcbiAgICBpZiAoaXNNYXRyaXhEYXRhKGQpKSB7XG4gICAgICBkLnZhbHVlcy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgdGltZUZpZWxkLnZhbHVlcy5hZGQodmFsWzBdICogMTAwMCk7XG4gICAgICAgIG1ldHJpY0ZpZWxkcy5mb3JFYWNoKChtZXRyaWNGaWVsZCkgPT4gbWV0cmljRmllbGQudmFsdWVzLmFkZChnZXRMYWJlbFZhbHVlKGQubWV0cmljLCBtZXRyaWNGaWVsZC5uYW1lKSkpO1xuICAgICAgICB2YWx1ZUZpZWxkLnZhbHVlcy5hZGQocGFyc2VTYW1wbGVWYWx1ZSh2YWxbMV0pKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lRmllbGQudmFsdWVzLmFkZChkLnZhbHVlWzBdICogMTAwMCk7XG4gICAgICBtZXRyaWNGaWVsZHMuZm9yRWFjaCgobWV0cmljRmllbGQpID0+IG1ldHJpY0ZpZWxkLnZhbHVlcy5hZGQoZ2V0TGFiZWxWYWx1ZShkLm1ldHJpYywgbWV0cmljRmllbGQubmFtZSkpKTtcbiAgICAgIHZhbHVlRmllbGQudmFsdWVzLmFkZChwYXJzZVNhbXBsZVZhbHVlKGQudmFsdWVbMV0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbWV0YTogb3B0aW9ucy5tZXRhLFxuICAgIHJlZklkOiBvcHRpb25zLnJlZklkLFxuICAgIGxlbmd0aDogdGltZUZpZWxkLnZhbHVlcy5sZW5ndGgsXG4gICAgZmllbGRzOiBbdGltZUZpZWxkLCAuLi5tZXRyaWNGaWVsZHMsIHZhbHVlRmllbGRdLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRMYWJlbFZhbHVlKG1ldHJpYzogUHJvbU1ldHJpYywgbGFiZWw6IHN0cmluZyk6IHN0cmluZyB8IG51bWJlciB7XG4gIGlmIChtZXRyaWMuaGFzT3duUHJvcGVydHkobGFiZWwpKSB7XG4gICAgaWYgKGxhYmVsID09PSAnbGUnKSB7XG4gICAgICByZXR1cm4gcGFyc2VTYW1wbGVWYWx1ZShtZXRyaWNbbGFiZWxdKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldHJpY1tsYWJlbF07XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lRmllbGQoZGF0YTogUHJvbVZhbHVlW10sIGlzTXMgPSBmYWxzZSk6IE11dGFibGVGaWVsZCB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FLFxuICAgIHR5cGU6IEZpZWxkVHlwZS50aW1lLFxuICAgIGNvbmZpZzoge30sXG4gICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3I8bnVtYmVyPihkYXRhLm1hcCgodmFsKSA9PiAoaXNNcyA/IHZhbFswXSA6IHZhbFswXSAqIDEwMDApKSksXG4gIH07XG59XG5cbnR5cGUgVmFsdWVGaWVsZE9wdGlvbnMgPSB7XG4gIGRhdGE6IFByb21WYWx1ZVtdO1xuICB2YWx1ZU5hbWU/OiBzdHJpbmc7XG4gIHBhcnNlVmFsdWU/OiBib29sZWFuO1xuICBsYWJlbHM/OiBMYWJlbHM7XG4gIGRpc3BsYXlOYW1lRnJvbURTPzogc3RyaW5nO1xufTtcblxuZnVuY3Rpb24gZ2V0VmFsdWVGaWVsZCh7XG4gIGRhdGEsXG4gIHZhbHVlTmFtZSA9IFRJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUUsXG4gIHBhcnNlVmFsdWUgPSB0cnVlLFxuICBsYWJlbHMsXG4gIGRpc3BsYXlOYW1lRnJvbURTLFxufTogVmFsdWVGaWVsZE9wdGlvbnMpOiBNdXRhYmxlRmllbGQge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IHZhbHVlTmFtZSxcbiAgICB0eXBlOiBGaWVsZFR5cGUubnVtYmVyLFxuICAgIGRpc3BsYXk6IGdldERpc3BsYXlQcm9jZXNzb3IoKSxcbiAgICBjb25maWc6IHtcbiAgICAgIGRpc3BsYXlOYW1lRnJvbURTLFxuICAgIH0sXG4gICAgbGFiZWxzLFxuICAgIHZhbHVlczogbmV3IEFycmF5VmVjdG9yPG51bWJlciB8IG51bGw+KGRhdGEubWFwKCh2YWwpID0+IChwYXJzZVZhbHVlID8gcGFyc2VTYW1wbGVWYWx1ZSh2YWxbMV0pIDogdmFsWzFdKSkpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMYWJlbEluZm8obGFiZWxzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LCBvcHRpb25zOiBUcmFuc2Zvcm1PcHRpb25zKSB7XG4gIGlmIChvcHRpb25zPy5sZWdlbmRGb3JtYXQpIHtcbiAgICBjb25zdCB0aXRsZSA9IHJlbmRlckxlZ2VuZEZvcm1hdChnZXRUZW1wbGF0ZVNydigpLnJlcGxhY2Uob3B0aW9ucy5sZWdlbmRGb3JtYXQsIG9wdGlvbnM/LnNjb3BlZFZhcnMpLCBsYWJlbHMpO1xuICAgIHJldHVybiB7IG5hbWU6IHRpdGxlLCBsYWJlbHMgfTtcbiAgfVxuXG4gIGNvbnN0IHsgX19uYW1lX18sIC4uLmxhYmVsc1dpdGhvdXROYW1lIH0gPSBsYWJlbHM7XG4gIGNvbnN0IGxhYmVsUGFydCA9IGZvcm1hdExhYmVscyhsYWJlbHNXaXRob3V0TmFtZSk7XG4gIGxldCB0aXRsZSA9IGAke19fbmFtZV9fID8/ICcnfSR7bGFiZWxQYXJ0fWA7XG5cbiAgaWYgKCF0aXRsZSkge1xuICAgIHRpdGxlID0gb3B0aW9ucy5xdWVyeTtcbiAgfVxuXG4gIHJldHVybiB7IG5hbWU6IHRpdGxlLCBsYWJlbHM6IGxhYmVsc1dpdGhvdXROYW1lIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmlnaW5hbE1ldHJpY05hbWUobGFiZWxEYXRhOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSB7XG4gIGNvbnN0IG1ldHJpY05hbWUgPSBsYWJlbERhdGEuX19uYW1lX18gfHwgJyc7XG4gIGRlbGV0ZSBsYWJlbERhdGEuX19uYW1lX187XG4gIGNvbnN0IGxhYmVsUGFydCA9IE9iamVjdC5lbnRyaWVzKGxhYmVsRGF0YSlcbiAgICAubWFwKChsYWJlbCkgPT4gYCR7bGFiZWxbMF19PVwiJHtsYWJlbFsxXX1cImApXG4gICAgLmpvaW4oJywnKTtcbiAgcmV0dXJuIGAke21ldHJpY05hbWV9eyR7bGFiZWxQYXJ0fX1gO1xufVxuXG5mdW5jdGlvbiBtZXJnZUhlYXRtYXBGcmFtZXMoZnJhbWVzOiBEYXRhRnJhbWVbXSk6IERhdGFGcmFtZVtdIHtcbiAgaWYgKGZyYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCB0aW1lRmllbGQgPSBmcmFtZXNbMF0uZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC50eXBlID09PSBGaWVsZFR5cGUudGltZSkhO1xuICBjb25zdCBjb3VudEZpZWxkcyA9IGZyYW1lcy5tYXAoKGZyYW1lKSA9PiB7XG4gICAgbGV0IGZpZWxkID0gZnJhbWUuZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC50eXBlID09PSBGaWVsZFR5cGUubnVtYmVyKSE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmllbGQsXG4gICAgICBuYW1lOiBmaWVsZC5jb25maWcuZGlzcGxheU5hbWVGcm9tRFMhLFxuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBbXG4gICAge1xuICAgICAgLi4uZnJhbWVzWzBdLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5mcmFtZXNbMF0ubWV0YSxcbiAgICAgICAgdHlwZTogRGF0YUZyYW1lVHlwZS5IZWF0bWFwUm93cyxcbiAgICAgIH0sXG4gICAgICBmaWVsZHM6IFt0aW1lRmllbGQhLCAuLi5jb3VudEZpZWxkc10sXG4gICAgfSxcbiAgXTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtVG9IaXN0b2dyYW1PdmVyVGltZShzZXJpZXNMaXN0OiBEYXRhRnJhbWVbXSkge1xuICAvKiAgICAgIHQxID0gdGltZXN0YW1wMSwgdDIgPSB0aW1lc3RhbXAyIGV0Yy5cbiAgICAgICAgICAgIHQxICB0MiAgdDMgICAgICAgICAgdDEgIHQyICB0M1xuICAgIGxlMTAgICAgMTAgIDEwICAwICAgICA9PiAgICAxMCAgMTAgIDBcbiAgICBsZTIwICAgIDIwICAxMCAgMzAgICAgPT4gICAgMTAgIDAgICAzMFxuICAgIGxlMzAgICAgMzAgIDEwICAzNSAgICA9PiAgICAxMCAgMCAgIDVcbiAgICAqL1xuICBmb3IgKGxldCBpID0gc2VyaWVzTGlzdC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgY29uc3QgdG9wU2VyaWVzID0gc2VyaWVzTGlzdFtpXS5maWVsZHMuZmluZCgocykgPT4gcy5uYW1lID09PSBUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FKTtcbiAgICBjb25zdCBib3R0b21TZXJpZXMgPSBzZXJpZXNMaXN0W2kgLSAxXS5maWVsZHMuZmluZCgocykgPT4gcy5uYW1lID09PSBUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FKTtcbiAgICBpZiAoIXRvcFNlcmllcyB8fCAhYm90dG9tU2VyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb21ldGhldXMgaGVhdG1hcCB0cmFuc2Zvcm0gZXJyb3I6IGRhdGEgc2hvdWxkIGJlIGEgdGltZSBzZXJpZXMnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRvcFNlcmllcy52YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGJvdHRvbVBvaW50ID0gYm90dG9tU2VyaWVzLnZhbHVlcy5nZXQoaikgfHwgWzBdO1xuICAgICAgdG9wU2VyaWVzLnZhbHVlcy50b0FycmF5KClbal0gLT0gYm90dG9tUG9pbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlcmllc0xpc3Q7XG59XG5cbmZ1bmN0aW9uIHNvcnRTZXJpZXNCeUxhYmVsKHMxOiBEYXRhRnJhbWUsIHMyOiBEYXRhRnJhbWUpOiBudW1iZXIge1xuICBsZXQgbGUxLCBsZTI7XG5cbiAgdHJ5IHtcbiAgICAvLyBmYWlsIGlmIG5vdCBpbnRlZ2VyLiBtaWdodCBoYXBwZW4gd2l0aCBiYWQgcXVlcmllc1xuICAgIGxlMSA9IHBhcnNlU2FtcGxlVmFsdWUoczEubmFtZSA/PyAnJyk7XG4gICAgbGUyID0gcGFyc2VTYW1wbGVWYWx1ZShzMi5uYW1lID8/ICcnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGxlMSA+IGxlMikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKGxlMSA8IGxlMikge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTYW1wbGVWYWx1ZSh2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgaWYgKElORklOSVRZX1NBTVBMRV9SRUdFWC50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZVswXSA9PT0gJy0nID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG4gIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbn1cbiIsImltcG9ydCB7IERhdGFRdWVyeSwgRGF0YVNvdXJjZUpzb25EYXRhLCBRdWVyeVJlc3VsdE1ldGEsIFNjb3BlZFZhcnMgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9tUXVlcnkgZXh0ZW5kcyBEYXRhUXVlcnkge1xuICBleHByOiBzdHJpbmc7XG4gIGZvcm1hdD86IHN0cmluZztcbiAgaW5zdGFudD86IGJvb2xlYW47XG4gIHJhbmdlPzogYm9vbGVhbjtcbiAgZXhlbXBsYXI/OiBib29sZWFuO1xuICBoaW50aW5nPzogYm9vbGVhbjtcbiAgaW50ZXJ2YWw/OiBzdHJpbmc7XG4gIGludGVydmFsRmFjdG9yPzogbnVtYmVyO1xuICAvLyBUaW1lem9uZSBvZmZzZXQgdG8gYWxpZ24gc3RhcnQgJiBlbmQgdGltZSBvbiBiYWNrZW5kXG4gIHV0Y09mZnNldFNlYz86IG51bWJlcjtcbiAgbGVnZW5kRm9ybWF0Pzogc3RyaW5nO1xuICB2YWx1ZVdpdGhSZWZJZD86IGJvb2xlYW47XG4gIHJlcXVlc3RJZD86IHN0cmluZztcbiAgc2hvd2luZ0dyYXBoPzogYm9vbGVhbjtcbiAgc2hvd2luZ1RhYmxlPzogYm9vbGVhbjtcbiAgLyoqIENvZGUsIEJ1aWxkZXIgb3IgRXhwbGFpbiAqL1xuICBlZGl0b3JNb2RlPzogUXVlcnlFZGl0b3JNb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21PcHRpb25zIGV4dGVuZHMgRGF0YVNvdXJjZUpzb25EYXRhIHtcbiAgdGltZUludGVydmFsPzogc3RyaW5nO1xuICBxdWVyeVRpbWVvdXQ/OiBzdHJpbmc7XG4gIGh0dHBNZXRob2Q/OiBzdHJpbmc7XG4gIGRpcmVjdFVybD86IHN0cmluZztcbiAgY3VzdG9tUXVlcnlQYXJhbWV0ZXJzPzogc3RyaW5nO1xuICBkaXNhYmxlTWV0cmljc0xvb2t1cD86IGJvb2xlYW47XG4gIGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucz86IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uW107XG59XG5cbmV4cG9ydCBlbnVtIFByb21RdWVyeVR5cGUge1xuICB0aW1lU2VyaWVzUXVlcnkgPSAndGltZVNlcmllc1F1ZXJ5Jyxcbn1cblxuZXhwb3J0IHR5cGUgRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24gPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgdXJsPzogc3RyaW5nO1xuICB1cmxEaXNwbGF5TGFiZWw/OiBzdHJpbmc7XG4gIGRhdGFzb3VyY2VVaWQ/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb21RdWVyeVJlcXVlc3QgZXh0ZW5kcyBQcm9tUXVlcnkge1xuICBzdGVwPzogbnVtYmVyO1xuICByZXF1ZXN0SWQ/OiBzdHJpbmc7XG4gIHN0YXJ0OiBudW1iZXI7XG4gIGVuZDogbnVtYmVyO1xuICBoZWFkZXJzPzogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21NZXRyaWNzTWV0YWRhdGFJdGVtIHtcbiAgdHlwZTogc3RyaW5nO1xuICBoZWxwOiBzdHJpbmc7XG4gIHVuaXQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbU1ldHJpY3NNZXRhZGF0YSB7XG4gIFttZXRyaWM6IHN0cmluZ106IFByb21NZXRyaWNzTWV0YWRhdGFJdGVtO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21EYXRhU3VjY2Vzc1Jlc3BvbnNlPFQgPSBQcm9tRGF0YT4ge1xuICBzdGF0dXM6ICdzdWNjZXNzJztcbiAgZGF0YTogVDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tRGF0YUVycm9yUmVzcG9uc2U8VCA9IFByb21EYXRhPiB7XG4gIHN0YXR1czogJ2Vycm9yJztcbiAgZXJyb3JUeXBlOiBzdHJpbmc7XG4gIGVycm9yOiBzdHJpbmc7XG4gIGRhdGE6IFQ7XG59XG5cbmV4cG9ydCB0eXBlIFByb21EYXRhID0gUHJvbU1hdHJpeERhdGEgfCBQcm9tVmVjdG9yRGF0YSB8IFByb21TY2FsYXJEYXRhIHwgUHJvbUV4ZW1wbGFyRGF0YVtdO1xuXG5leHBvcnQgaW50ZXJmYWNlIExhYmVscyB7XG4gIFtpbmRleDogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4ZW1wbGFyIHtcbiAgbGFiZWxzOiBMYWJlbHM7XG4gIHZhbHVlOiBudW1iZXI7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21FeGVtcGxhckRhdGEge1xuICBzZXJpZXNMYWJlbHM6IFByb21NZXRyaWM7XG4gIGV4ZW1wbGFyczogRXhlbXBsYXJbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tVmVjdG9yRGF0YSB7XG4gIHJlc3VsdFR5cGU6ICd2ZWN0b3InO1xuICByZXN1bHQ6IEFycmF5PHtcbiAgICBtZXRyaWM6IFByb21NZXRyaWM7XG4gICAgdmFsdWU6IFByb21WYWx1ZTtcbiAgfT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbU1hdHJpeERhdGEge1xuICByZXN1bHRUeXBlOiAnbWF0cml4JztcbiAgcmVzdWx0OiBBcnJheTx7XG4gICAgbWV0cmljOiBQcm9tTWV0cmljO1xuICAgIHZhbHVlczogUHJvbVZhbHVlW107XG4gIH0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21TY2FsYXJEYXRhIHtcbiAgcmVzdWx0VHlwZTogJ3NjYWxhcic7XG4gIHJlc3VsdDogUHJvbVZhbHVlO1xufVxuXG5leHBvcnQgdHlwZSBQcm9tVmFsdWUgPSBbbnVtYmVyLCBhbnldO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb21NZXRyaWMge1xuICBfX25hbWVfXz86IHN0cmluZztcbiAgW2luZGV4OiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc01hdHJpeERhdGEocmVzdWx0OiBNYXRyaXhPclZlY3RvclJlc3VsdCk6IHJlc3VsdCBpcyBQcm9tTWF0cml4RGF0YVsncmVzdWx0J11bMF0ge1xuICByZXR1cm4gJ3ZhbHVlcycgaW4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFeGVtcGxhckRhdGEocmVzdWx0OiBQcm9tRGF0YSk6IHJlc3VsdCBpcyBQcm9tRXhlbXBsYXJEYXRhW10ge1xuICBpZiAocmVzdWx0ID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA/ICdleGVtcGxhcnMnIGluIHJlc3VsdFswXSA6IGZhbHNlO1xufVxuXG5leHBvcnQgdHlwZSBNYXRyaXhPclZlY3RvclJlc3VsdCA9IFByb21NYXRyaXhEYXRhWydyZXN1bHQnXVswXSB8IFByb21WZWN0b3JEYXRhWydyZXN1bHQnXVswXTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1PcHRpb25zIHtcbiAgZm9ybWF0Pzogc3RyaW5nO1xuICBzdGVwPzogbnVtYmVyO1xuICBsZWdlbmRGb3JtYXQ/OiBzdHJpbmc7XG4gIHN0YXJ0OiBudW1iZXI7XG4gIGVuZDogbnVtYmVyO1xuICBxdWVyeTogc3RyaW5nO1xuICByZXNwb25zZUxpc3RMZW5ndGg6IG51bWJlcjtcbiAgc2NvcGVkVmFycz86IFNjb3BlZFZhcnM7XG4gIHJlZklkOiBzdHJpbmc7XG4gIHZhbHVlV2l0aFJlZklkPzogYm9vbGVhbjtcbiAgbWV0YTogUXVlcnlSZXN1bHRNZXRhO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21MYWJlbFF1ZXJ5UmVzcG9uc2Uge1xuICBkYXRhOiB7XG4gICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgZGF0YTogc3RyaW5nW107XG4gIH07XG4gIGNhbmNlbGxlZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQXV0byA9IHF1ZXJ5LmxlZ2VuZEZvcm1hdCA9PSAnX19hdXRvJ1xuICogVmVyYm9zZSA9IHF1ZXJ5LmxlZ2VuZEZvcm1hdCA9PSBudWxsL3VuZGVmaW5lZC8nJ1xuICogQ3VzdG9tIHF1ZXJ5LmxlZ2VuZEZvcm1hdC5sZW5ndGggPiAwICYmIHF1ZXJ5LmxlZ2VuZEZvcm1hdCAhPT0gJ19fYXV0bydcbiAqL1xuZXhwb3J0IGVudW0gTGVnZW5kRm9ybWF0TW9kZSB7XG4gIEF1dG8gPSAnX19hdXRvJyxcbiAgVmVyYm9zZSA9ICdfX3ZlcmJvc2UnLFxuICBDdXN0b20gPSAnX19jdXN0b20nLFxufVxuIiwiaW1wb3J0IHsgZnJvbSwgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHtcbiAgRGF0YVF1ZXJ5UmVxdWVzdCxcbiAgRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIHJhbmdlVXRpbCxcbiAgU3RhbmRhcmRWYXJpYWJsZVF1ZXJ5LFxuICBTdGFuZGFyZFZhcmlhYmxlU3VwcG9ydCxcbn0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBnZXRUZW1wbGF0ZVNydiwgVGVtcGxhdGVTcnYgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcblxuaW1wb3J0IHsgZ2V0VGltZVNydiwgVGltZVNydiB9IGZyb20gJy4uLy4uLy4uL2ZlYXR1cmVzL2Rhc2hib2FyZC9zZXJ2aWNlcy9UaW1lU3J2JztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuL2RhdGFzb3VyY2UnO1xuaW1wb3J0IFByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkgZnJvbSAnLi9tZXRyaWNfZmluZF9xdWVyeSc7XG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFByb21ldGhldXNWYXJpYWJsZVN1cHBvcnQgZXh0ZW5kcyBTdGFuZGFyZFZhcmlhYmxlU3VwcG9ydDxQcm9tZXRoZXVzRGF0YXNvdXJjZT4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGVTcnY6IFRlbXBsYXRlU3J2ID0gZ2V0VGVtcGxhdGVTcnYoKSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRpbWVTcnY6IFRpbWVTcnYgPSBnZXRUaW1lU3J2KClcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcXVlcnkocmVxdWVzdDogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+KTogT2JzZXJ2YWJsZTxEYXRhUXVlcnlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHF1ZXJ5ID0gcmVxdWVzdC50YXJnZXRzWzBdLmV4cHI7XG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIG9mKHsgZGF0YTogW10gfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGVkVmFycyA9IHtcbiAgICAgIC4uLnJlcXVlc3Quc2NvcGVkVmFycyxcbiAgICAgIF9faW50ZXJ2YWw6IHsgdGV4dDogdGhpcy5kYXRhc291cmNlLmludGVydmFsLCB2YWx1ZTogdGhpcy5kYXRhc291cmNlLmludGVydmFsIH0sXG4gICAgICBfX2ludGVydmFsX21zOiB7XG4gICAgICAgIHRleHQ6IHJhbmdlVXRpbC5pbnRlcnZhbFRvTXModGhpcy5kYXRhc291cmNlLmludGVydmFsKSxcbiAgICAgICAgdmFsdWU6IHJhbmdlVXRpbC5pbnRlcnZhbFRvTXModGhpcy5kYXRhc291cmNlLmludGVydmFsKSxcbiAgICAgIH0sXG4gICAgICAuLi50aGlzLmRhdGFzb3VyY2UuZ2V0UmFuZ2VTY29wZWRWYXJzKHRoaXMudGltZVNydi50aW1lUmFuZ2UoKSksXG4gICAgfTtcblxuICAgIGNvbnN0IGludGVycG9sYXRlZCA9IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShxdWVyeSwgc2NvcGVkVmFycywgdGhpcy5kYXRhc291cmNlLmludGVycG9sYXRlUXVlcnlFeHByKTtcbiAgICBjb25zdCBtZXRyaWNGaW5kUXVlcnkgPSBuZXcgUHJvbWV0aGV1c01ldHJpY0ZpbmRRdWVyeSh0aGlzLmRhdGFzb3VyY2UsIGludGVycG9sYXRlZCk7XG4gICAgY29uc3QgbWV0cmljRmluZFN0cmVhbSA9IGZyb20obWV0cmljRmluZFF1ZXJ5LnByb2Nlc3MoKSk7XG5cbiAgICByZXR1cm4gbWV0cmljRmluZFN0cmVhbS5waXBlKG1hcCgocmVzdWx0cykgPT4gKHsgZGF0YTogcmVzdWx0cyB9KSkpO1xuICB9XG5cbiAgdG9EYXRhUXVlcnkocXVlcnk6IFN0YW5kYXJkVmFyaWFibGVRdWVyeSk6IFByb21RdWVyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZklkOiAnUHJvbWV0aGV1c0RhdGFzb3VyY2UtVmFyaWFibGVRdWVyeScsXG4gICAgICBleHByOiBxdWVyeS5xdWVyeSxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VQb3BwZXIgfSBmcm9tICdyZWFjdC1wb3BwZXInO1xuXG5mdW5jdGlvbiB1c2VHZXRMYXRlc3QodmFsKSB7XG4gIHZhciByZWYgPSBSZWFjdC51c2VSZWYodmFsKTtcbiAgcmVmLmN1cnJlbnQgPSB2YWw7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG59XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHsvLyBkbyBub3RoaW5nXG59O1xuXG5mdW5jdGlvbiB1c2VDb250cm9sbGVkU3RhdGUoX3JlZikge1xuICB2YXIgaW5pdGlhbCA9IF9yZWYuaW5pdGlhbCxcbiAgICAgIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgIF9yZWYkb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlLFxuICAgICAgb25DaGFuZ2UgPSBfcmVmJG9uQ2hhbmdlID09PSB2b2lkIDAgPyBub29wIDogX3JlZiRvbkNoYW5nZTtcblxuICBpZiAoaW5pdGlhbCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFaXRoZXIgXCJ2YWx1ZVwiIG9yIFwiaW5pdGlhbFwiIHZhcmlhYmxlIG11c3QgYmUgc2V0LiBOb3cgYm90aCBhcmUgdW5kZWZpbmVkJyk7XG4gIH1cblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbCksXG4gICAgICBzdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldFN0YXRlID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBnZXRMYXRlc3QgPSB1c2VHZXRMYXRlc3Qoc3RhdGUpO1xuICB2YXIgc2V0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHVwZGF0ZXIpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRMYXRlc3QoKTtcbiAgICB2YXIgdXBkYXRlZFN0YXRlID0gdHlwZW9mIHVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyB1cGRhdGVyKHN0YXRlKSA6IHVwZGF0ZXI7XG4gICAgaWYgKHR5cGVvZiB1cGRhdGVkU3RhdGUucGVyc2lzdCA9PT0gJ2Z1bmN0aW9uJykgdXBkYXRlZFN0YXRlLnBlcnNpc3QoKTtcbiAgICBzZXRTdGF0ZSh1cGRhdGVkU3RhdGUpO1xuICAgIGlmICh0eXBlb2Ygb25DaGFuZ2UgPT09ICdmdW5jdGlvbicpIG9uQ2hhbmdlKHVwZGF0ZWRTdGF0ZSk7XG4gIH0sIFtnZXRMYXRlc3QsIG9uQ2hhbmdlXSk7XG4gIHZhciBpc0NvbnRyb2xsZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICByZXR1cm4gW2lzQ29udHJvbGxlZCA/IHZhbHVlIDogc3RhdGUsIGlzQ29udHJvbGxlZCA/IG9uQ2hhbmdlIDogc2V0XTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQm91bmRpbmdDbGllbnRSZWN0KHgsIHkpIHtcbiAgaWYgKHggPT09IHZvaWQgMCkge1xuICAgIHggPSAwO1xuICB9XG5cbiAgaWYgKHkgPT09IHZvaWQgMCkge1xuICAgIHkgPSAwO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICB0b3A6IHksXG4gICAgICByaWdodDogeCxcbiAgICAgIGJvdHRvbTogeSxcbiAgICAgIGxlZnQ6IHgsXG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wic3R5bGVzXCIsIFwiYXR0cmlidXRlc1wiXTtcbnZhciB2aXJ0dWFsRWxlbWVudCA9IHtcbiAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBnZW5lcmF0ZUJvdW5kaW5nQ2xpZW50UmVjdCgpXG59O1xudmFyIGRlZmF1bHRDb25maWcgPSB7XG4gIGNsb3NlT25PdXRzaWRlQ2xpY2s6IHRydWUsXG4gIGNsb3NlT25UcmlnZ2VySGlkZGVuOiBmYWxzZSxcbiAgZGVmYXVsdFZpc2libGU6IGZhbHNlLFxuICBkZWxheUhpZGU6IDAsXG4gIGRlbGF5U2hvdzogMCxcbiAgZm9sbG93Q3Vyc29yOiBmYWxzZSxcbiAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICBtdXRhdGlvbk9ic2VydmVyT3B0aW9uczoge1xuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbiAgfSxcbiAgb2Zmc2V0OiBbMCwgNl0sXG4gIHRyaWdnZXI6ICdob3Zlcidcbn07XG5mdW5jdGlvbiB1c2VQb3BwZXJUb29sdGlwKGNvbmZpZywgcG9wcGVyT3B0aW9ucykge1xuICB2YXIgX3BvcHBlclByb3BzJHN0YXRlLCBfcG9wcGVyUHJvcHMkc3RhdGUkbW8sIF9wb3BwZXJQcm9wcyRzdGF0ZSRtbzI7XG5cbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICBpZiAocG9wcGVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgcG9wcGVyT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLy8gTWVyZ2luZyBvcHRpb25zIHdpdGggZGVmYXVsdCBvcHRpb25zLlxuICAvLyBLZXlzIHdpdGggdW5kZWZpbmVkIHZhbHVlcyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgZGVmYXVsdCBvbmVzIGlmIGFueS5cbiAgLy8gS2V5cyB3aXRoIG90aGVyIHZhbHVlcyBwYXNzIHRocm91Z2guXG4gIHZhciBmaW5hbENvbmZpZyA9IE9iamVjdC5rZXlzKGRlZmF1bHRDb25maWcpLnJlZHVjZShmdW5jdGlvbiAoY29uZmlnLCBrZXkpIHtcbiAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBjb25maWcsIChfZXh0ZW5kczIgPSB7fSwgX2V4dGVuZHMyW2tleV0gPSBjb25maWdba2V5XSAhPT0gdW5kZWZpbmVkID8gY29uZmlnW2tleV0gOiBkZWZhdWx0Q29uZmlnW2tleV0sIF9leHRlbmRzMikpO1xuICB9LCBjb25maWcpO1xuICB2YXIgZGVmYXVsdE1vZGlmaWVycyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbe1xuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIG9mZnNldDogZmluYWxDb25maWcub2Zmc2V0XG4gICAgICB9XG4gICAgfV07XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgQXJyYXkuaXNBcnJheShmaW5hbENvbmZpZy5vZmZzZXQpID8gZmluYWxDb25maWcub2Zmc2V0IDogW10pO1xuXG4gIHZhciBmaW5hbFBvcHBlck9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyT3B0aW9ucywge1xuICAgIHBsYWNlbWVudDogcG9wcGVyT3B0aW9ucy5wbGFjZW1lbnQgfHwgZmluYWxDb25maWcucGxhY2VtZW50LFxuICAgIG1vZGlmaWVyczogcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMgfHwgZGVmYXVsdE1vZGlmaWVyc1xuICB9KTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICB0cmlnZ2VyUmVmID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0VHJpZ2dlclJlZiA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMiA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgdG9vbHRpcFJlZiA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRUb29sdGlwUmVmID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICB2YXIgX3VzZUNvbnRyb2xsZWRTdGF0ZSA9IHVzZUNvbnRyb2xsZWRTdGF0ZSh7XG4gICAgaW5pdGlhbDogZmluYWxDb25maWcuZGVmYXVsdFZpc2libGUsXG4gICAgdmFsdWU6IGZpbmFsQ29uZmlnLnZpc2libGUsXG4gICAgb25DaGFuZ2U6IGZpbmFsQ29uZmlnLm9uVmlzaWJsZUNoYW5nZVxuICB9KSxcbiAgICAgIHZpc2libGUgPSBfdXNlQ29udHJvbGxlZFN0YXRlWzBdLFxuICAgICAgc2V0VmlzaWJsZSA9IF91c2VDb250cm9sbGVkU3RhdGVbMV07XG5cbiAgdmFyIHRpbWVyID0gUmVhY3QudXNlUmVmKCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjbGVhclRpbWVvdXQodGltZXIuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHZhciBfdXNlUG9wcGVyID0gdXNlUG9wcGVyKGZpbmFsQ29uZmlnLmZvbGxvd0N1cnNvciA/IHZpcnR1YWxFbGVtZW50IDogdHJpZ2dlclJlZiwgdG9vbHRpcFJlZiwgZmluYWxQb3BwZXJPcHRpb25zKSxcbiAgICAgIHN0eWxlcyA9IF91c2VQb3BwZXIuc3R5bGVzLFxuICAgICAgYXR0cmlidXRlcyA9IF91c2VQb3BwZXIuYXR0cmlidXRlcyxcbiAgICAgIHBvcHBlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3VzZVBvcHBlciwgX2V4Y2x1ZGVkKTtcblxuICB2YXIgdXBkYXRlID0gcG9wcGVyUHJvcHMudXBkYXRlO1xuICB2YXIgZ2V0TGF0ZXN0ID0gdXNlR2V0TGF0ZXN0KHtcbiAgICB2aXNpYmxlOiB2aXNpYmxlLFxuICAgIHRyaWdnZXJSZWY6IHRyaWdnZXJSZWYsXG4gICAgdG9vbHRpcFJlZjogdG9vbHRpcFJlZixcbiAgICBmaW5hbENvbmZpZzogZmluYWxDb25maWdcbiAgfSk7XG4gIHZhciBpc1RyaWdnZXJlZEJ5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShmaW5hbENvbmZpZy50cmlnZ2VyKSA/IGZpbmFsQ29uZmlnLnRyaWdnZXIuaW5jbHVkZXModHJpZ2dlcikgOiBmaW5hbENvbmZpZy50cmlnZ2VyID09PSB0cmlnZ2VyO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIEFycmF5LmlzQXJyYXkoZmluYWxDb25maWcudHJpZ2dlcikgPyBmaW5hbENvbmZpZy50cmlnZ2VyIDogW2ZpbmFsQ29uZmlnLnRyaWdnZXJdKTtcbiAgdmFyIGhpZGVUb29sdGlwID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lci5jdXJyZW50KTtcbiAgICB0aW1lci5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNldFZpc2libGUoZmFsc2UpO1xuICAgIH0sIGZpbmFsQ29uZmlnLmRlbGF5SGlkZSk7XG4gIH0sIFtmaW5hbENvbmZpZy5kZWxheUhpZGUsIHNldFZpc2libGVdKTtcbiAgdmFyIHNob3dUb29sdGlwID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lci5jdXJyZW50KTtcbiAgICB0aW1lci5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNldFZpc2libGUodHJ1ZSk7XG4gICAgfSwgZmluYWxDb25maWcuZGVsYXlTaG93KTtcbiAgfSwgW2ZpbmFsQ29uZmlnLmRlbGF5U2hvdywgc2V0VmlzaWJsZV0pO1xuICB2YXIgdG9nZ2xlVG9vbHRpcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZ2V0TGF0ZXN0KCkudmlzaWJsZSkge1xuICAgICAgaGlkZVRvb2x0aXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICB9XG4gIH0sIFtnZXRMYXRlc3QsIGhpZGVUb29sdGlwLCBzaG93VG9vbHRpcF0pOyAvLyBIYW5kbGUgY2xpY2sgb3V0c2lkZVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFnZXRMYXRlc3QoKS5maW5hbENvbmZpZy5jbG9zZU9uT3V0c2lkZUNsaWNrKSByZXR1cm47XG5cbiAgICB2YXIgaGFuZGxlQ2xpY2tPdXRzaWRlID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgICB2YXIgX2V2ZW50JGNvbXBvc2VkUGF0aDtcblxuICAgICAgdmFyIF9nZXRMYXRlc3QgPSBnZXRMYXRlc3QoKSxcbiAgICAgICAgICB0b29sdGlwUmVmID0gX2dldExhdGVzdC50b29sdGlwUmVmLFxuICAgICAgICAgIHRyaWdnZXJSZWYgPSBfZ2V0TGF0ZXN0LnRyaWdnZXJSZWY7XG5cbiAgICAgIHZhciB0YXJnZXQgPSAoZXZlbnQuY29tcG9zZWRQYXRoID09IG51bGwgPyB2b2lkIDAgOiAoX2V2ZW50JGNvbXBvc2VkUGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2V2ZW50JGNvbXBvc2VkUGF0aFswXSkgfHwgZXZlbnQudGFyZ2V0O1xuXG4gICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICBpZiAodG9vbHRpcFJlZiAhPSBudWxsICYmIHRyaWdnZXJSZWYgIT0gbnVsbCAmJiAhdG9vbHRpcFJlZi5jb250YWlucyh0YXJnZXQpICYmICF0cmlnZ2VyUmVmLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICBoaWRlVG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVDbGlja091dHNpZGUpO1xuICAgIH07XG4gIH0sIFtnZXRMYXRlc3QsIGhpZGVUb29sdGlwXSk7IC8vIFRyaWdnZXI6IGNsaWNrXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHJpZ2dlclJlZiA9PSBudWxsIHx8ICFpc1RyaWdnZXJlZEJ5KCdjbGljaycpKSByZXR1cm47XG4gICAgdHJpZ2dlclJlZi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRvZ2dsZVRvb2x0aXApO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJpZ2dlclJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRvZ2dsZVRvb2x0aXApO1xuICAgIH07XG4gIH0sIFt0cmlnZ2VyUmVmLCBpc1RyaWdnZXJlZEJ5LCB0b2dnbGVUb29sdGlwXSk7IC8vIFRyaWdnZXI6IGRvdWJsZS1jbGlja1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRyaWdnZXJSZWYgPT0gbnVsbCB8fCAhaXNUcmlnZ2VyZWRCeSgnZG91YmxlLWNsaWNrJykpIHJldHVybjtcbiAgICB0cmlnZ2VyUmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdG9nZ2xlVG9vbHRpcCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdG9nZ2xlVG9vbHRpcCk7XG4gICAgfTtcbiAgfSwgW3RyaWdnZXJSZWYsIGlzVHJpZ2dlcmVkQnksIHRvZ2dsZVRvb2x0aXBdKTsgLy8gVHJpZ2dlcjogcmlnaHQtY2xpY2tcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0cmlnZ2VyUmVmID09IG51bGwgfHwgIWlzVHJpZ2dlcmVkQnkoJ3JpZ2h0LWNsaWNrJykpIHJldHVybjtcblxuICAgIHZhciBwcmV2ZW50RGVmYXVsdEFuZFRvZ2dsZSA9IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0QW5kVG9nZ2xlKGV2ZW50KSB7XG4gICAgICAvLyBEb24ndCBzaG93IHRoZSBjb250ZXh0IG1lbnVcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0b2dnbGVUb29sdGlwKCk7XG4gICAgfTtcblxuICAgIHRyaWdnZXJSZWYuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdEFuZFRvZ2dsZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHRBbmRUb2dnbGUpO1xuICAgIH07XG4gIH0sIFt0cmlnZ2VyUmVmLCBpc1RyaWdnZXJlZEJ5LCB0b2dnbGVUb29sdGlwXSk7IC8vIFRyaWdnZXI6IGZvY3VzXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHJpZ2dlclJlZiA9PSBudWxsIHx8ICFpc1RyaWdnZXJlZEJ5KCdmb2N1cycpKSByZXR1cm47XG4gICAgdHJpZ2dlclJlZi5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHNob3dUb29sdGlwKTtcbiAgICB0cmlnZ2VyUmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoaWRlVG9vbHRpcCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyaWdnZXJSZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBzaG93VG9vbHRpcCk7XG4gICAgICB0cmlnZ2VyUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoaWRlVG9vbHRpcCk7XG4gICAgfTtcbiAgfSwgW3RyaWdnZXJSZWYsIGlzVHJpZ2dlcmVkQnksIHNob3dUb29sdGlwLCBoaWRlVG9vbHRpcF0pOyAvLyBUcmlnZ2VyOiBob3ZlciBvbiB0cmlnZ2VyXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHJpZ2dlclJlZiA9PSBudWxsIHx8ICFpc1RyaWdnZXJlZEJ5KCdob3ZlcicpKSByZXR1cm47XG4gICAgdHJpZ2dlclJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgc2hvd1Rvb2x0aXApO1xuICAgIHRyaWdnZXJSZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGhpZGVUb29sdGlwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdHJpZ2dlclJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgc2hvd1Rvb2x0aXApO1xuICAgICAgdHJpZ2dlclJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgaGlkZVRvb2x0aXApO1xuICAgIH07XG4gIH0sIFt0cmlnZ2VyUmVmLCBpc1RyaWdnZXJlZEJ5LCBzaG93VG9vbHRpcCwgaGlkZVRvb2x0aXBdKTsgLy8gVHJpZ2dlcjogaG92ZXIgb24gdG9vbHRpcCwga2VlcCBpdCBvcGVuIGlmIGhvdmVyZWRcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0b29sdGlwUmVmID09IG51bGwgfHwgIWdldExhdGVzdCgpLmZpbmFsQ29uZmlnLmludGVyYWN0aXZlKSByZXR1cm47XG4gICAgdG9vbHRpcFJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgc2hvd1Rvb2x0aXApO1xuICAgIHRvb2x0aXBSZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGhpZGVUb29sdGlwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdG9vbHRpcFJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgc2hvd1Rvb2x0aXApO1xuICAgICAgdG9vbHRpcFJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgaGlkZVRvb2x0aXApO1xuICAgIH07XG4gIH0sIFt0b29sdGlwUmVmLCBzaG93VG9vbHRpcCwgaGlkZVRvb2x0aXAsIGdldExhdGVzdF0pOyAvLyBIYW5kbGUgY2xvc2luZyB0b29sdGlwIGlmIHRyaWdnZXIgaGlkZGVuXG5cbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gcG9wcGVyUHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IChfcG9wcGVyUHJvcHMkc3RhdGUgPSBwb3BwZXJQcm9wcy5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IChfcG9wcGVyUHJvcHMkc3RhdGUkbW8gPSBfcG9wcGVyUHJvcHMkc3RhdGUubW9kaWZpZXJzRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IChfcG9wcGVyUHJvcHMkc3RhdGUkbW8yID0gX3BvcHBlclByb3BzJHN0YXRlJG1vLmhpZGUpID09IG51bGwgPyB2b2lkIDAgOiBfcG9wcGVyUHJvcHMkc3RhdGUkbW8yLmlzUmVmZXJlbmNlSGlkZGVuO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChmaW5hbENvbmZpZy5jbG9zZU9uVHJpZ2dlckhpZGRlbiAmJiBpc1JlZmVyZW5jZUhpZGRlbikgaGlkZVRvb2x0aXAoKTtcbiAgfSwgW2ZpbmFsQ29uZmlnLmNsb3NlT25UcmlnZ2VySGlkZGVuLCBoaWRlVG9vbHRpcCwgaXNSZWZlcmVuY2VIaWRkZW5dKTsgLy8gSGFuZGxlIGZvbGxvdyBjdXJzb3JcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghZmluYWxDb25maWcuZm9sbG93Q3Vyc29yIHx8IHRyaWdnZXJSZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgZnVuY3Rpb24gc2V0TW91c2VQb3NpdGlvbihfcmVmKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IF9yZWYuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZi5jbGllbnRZO1xuICAgICAgdmlydHVhbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZ2VuZXJhdGVCb3VuZGluZ0NsaWVudFJlY3QoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICB1cGRhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHRyaWdnZXJSZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc2V0TW91c2VQb3NpdGlvbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHNldE1vdXNlUG9zaXRpb24pO1xuICAgIH07XG4gIH0sIFtmaW5hbENvbmZpZy5mb2xsb3dDdXJzb3IsIHRyaWdnZXJSZWYsIHVwZGF0ZV0pOyAvLyBIYW5kbGUgdG9vbHRpcCBET00gbXV0YXRpb24gY2hhbmdlcyAoYWthIG11dGF0aW9uIG9ic2VydmVyKVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRvb2x0aXBSZWYgPT0gbnVsbCB8fCB1cGRhdGUgPT0gbnVsbCB8fCBmaW5hbENvbmZpZy5tdXRhdGlvbk9ic2VydmVyT3B0aW9ucyA9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodXBkYXRlKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRvb2x0aXBSZWYsIGZpbmFsQ29uZmlnLm11dGF0aW9uT2JzZXJ2ZXJPcHRpb25zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbZmluYWxDb25maWcubXV0YXRpb25PYnNlcnZlck9wdGlvbnMsIHRvb2x0aXBSZWYsIHVwZGF0ZV0pOyAvLyBUb29sdGlwIHByb3BzIGdldHRlclxuXG4gIHZhciBnZXRUb29sdGlwUHJvcHMgPSBmdW5jdGlvbiBnZXRUb29sdGlwUHJvcHMoYXJncykge1xuICAgIGlmIChhcmdzID09PSB2b2lkIDApIHtcbiAgICAgIGFyZ3MgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFyZ3MsIHtcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgYXJncy5zdHlsZSwgc3R5bGVzLnBvcHBlcilcbiAgICB9LCBhdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICAgJ2RhdGEtcG9wcGVyLWludGVyYWN0aXZlJzogZmluYWxDb25maWcuaW50ZXJhY3RpdmVcbiAgICB9KTtcbiAgfTsgLy8gQXJyb3cgcHJvcHMgZ2V0dGVyXG5cblxuICB2YXIgZ2V0QXJyb3dQcm9wcyA9IGZ1bmN0aW9uIGdldEFycm93UHJvcHMoYXJncykge1xuICAgIGlmIChhcmdzID09PSB2b2lkIDApIHtcbiAgICAgIGFyZ3MgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFyZ3MsIGF0dHJpYnV0ZXMuYXJyb3csIHtcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgYXJncy5zdHlsZSwgc3R5bGVzLmFycm93KSxcbiAgICAgICdkYXRhLXBvcHBlci1hcnJvdyc6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIGdldEFycm93UHJvcHM6IGdldEFycm93UHJvcHMsXG4gICAgZ2V0VG9vbHRpcFByb3BzOiBnZXRUb29sdGlwUHJvcHMsXG4gICAgc2V0VG9vbHRpcFJlZjogc2V0VG9vbHRpcFJlZixcbiAgICBzZXRUcmlnZ2VyUmVmOiBzZXRUcmlnZ2VyUmVmLFxuICAgIHRvb2x0aXBSZWY6IHRvb2x0aXBSZWYsXG4gICAgdHJpZ2dlclJlZjogdHJpZ2dlclJlZixcbiAgICB2aXNpYmxlOiB2aXNpYmxlXG4gIH0sIHBvcHBlclByb3BzKTtcbn1cblxuZXhwb3J0IHsgdXNlUG9wcGVyVG9vbHRpcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtcG9wcGVyLXRvb2x0aXAuanMubWFwXG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVByZXZpb3VzKHN0YXRlKSB7XG4gICAgdmFyIHJlZiA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gc3RhdGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RfX2RlZmF1bHQgPSBfaW50ZXJvcERlZmF1bHQoUmVhY3QpO1xudmFyIHVpID0gcmVxdWlyZSgnQGdyYWZhbmEvdWknKTtcbnZhciBkYXRhID0gcmVxdWlyZSgnQGdyYWZhbmEvZGF0YScpO1xudmFyIGxvZGFzaCA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XG5cbnZhciBzdGFuZGFyZFJlZ2lvbnMgPSBbXHJcbiAgICAnYWYtc291dGgtMScsXHJcbiAgICAnYXAtZWFzdC0xJyxcclxuICAgICdhcC1ub3J0aGVhc3QtMScsXHJcbiAgICAnYXAtbm9ydGhlYXN0LTInLFxyXG4gICAgJ2FwLW5vcnRoZWFzdC0zJyxcclxuICAgICdhcC1zb3V0aC0xJyxcclxuICAgICdhcC1zb3V0aGVhc3QtMScsXHJcbiAgICAnYXAtc291dGhlYXN0LTInLFxyXG4gICAgJ2NhLWNlbnRyYWwtMScsXHJcbiAgICAnY24tbm9ydGgtMScsXHJcbiAgICAnY24tbm9ydGh3ZXN0LTEnLFxyXG4gICAgJ2V1LWNlbnRyYWwtMScsXHJcbiAgICAnZXUtbm9ydGgtMScsXHJcbiAgICAnZXUtd2VzdC0xJyxcclxuICAgICdldS13ZXN0LTInLFxyXG4gICAgJ2V1LXdlc3QtMycsXHJcbiAgICAnbWUtc291dGgtMScsXHJcbiAgICAnc2EtZWFzdC0xJyxcclxuICAgICd1cy1lYXN0LTEnLFxyXG4gICAgJ3VzLWVhc3QtMicsXHJcbiAgICAndXMtZ292LWVhc3QtMScsXHJcbiAgICAndXMtZ292LXdlc3QtMScsXHJcbiAgICAndXMtaXNvLWVhc3QtMScsXHJcbiAgICAndXMtaXNvYi1lYXN0LTEnLFxyXG4gICAgJ3VzLXdlc3QtMScsXHJcbiAgICAndXMtd2VzdC0yJyxcclxuXTtcblxuKGZ1bmN0aW9uIChBd3NBdXRoVHlwZSkge1xyXG4gICAgQXdzQXV0aFR5cGVbXCJLZXlzXCJdID0gXCJrZXlzXCI7XHJcbiAgICBBd3NBdXRoVHlwZVtcIkNyZWRlbnRpYWxzXCJdID0gXCJjcmVkZW50aWFsc1wiO1xyXG4gICAgQXdzQXV0aFR5cGVbXCJEZWZhdWx0XCJdID0gXCJkZWZhdWx0XCI7XHJcbiAgICBBd3NBdXRoVHlwZVtcIkVDMklBTVJvbGVcIl0gPSBcImVjMl9pYW1fcm9sZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgZGVmYXVsdFxyXG4gICAgICovXHJcbiAgICBBd3NBdXRoVHlwZVtcIkFSTlwiXSA9IFwiYXJuXCI7XHJcbn0pKGV4cG9ydHMuQXdzQXV0aFR5cGUgfHwgKGV4cG9ydHMuQXdzQXV0aFR5cGUgPSB7fSkpO1xuXG52YXIgYXdzQXV0aFByb3ZpZGVyT3B0aW9ucyA9IFtcclxuICAgIHtcclxuICAgICAgICBsYWJlbDogJ1dvcmtzcGFjZSBJQU0gUm9sZScsXHJcbiAgICAgICAgdmFsdWU6IGV4cG9ydHMuQXdzQXV0aFR5cGUuRUMySUFNUm9sZSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbGFiZWw6ICdBV1MgU0RLIERlZmF1bHQnLFxyXG4gICAgICAgIHZhbHVlOiBleHBvcnRzLkF3c0F1dGhUeXBlLkRlZmF1bHQsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGxhYmVsOiAnQWNjZXNzICYgc2VjcmV0IGtleScsXHJcbiAgICAgICAgdmFsdWU6IGV4cG9ydHMuQXdzQXV0aFR5cGUuS2V5cyxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbGFiZWw6ICdDcmVkZW50aWFscyBmaWxlJyxcclxuICAgICAgICB2YWx1ZTogZXhwb3J0cy5Bd3NBdXRoVHlwZS5DcmVkZW50aWFscyxcclxuICAgIH0sXHJcbl07XG5cbnZhciB0b09wdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKHsgdmFsdWU6IHZhbHVlLCBsYWJlbDogdmFsdWUgfSk7IH07XHJcbnZhciBDb25uZWN0aW9uQ29uZmlnID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcclxuICAgIHZhciBfayA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZSgocHJvcHMuc3RhbmRhcmRSZWdpb25zIHx8IHN0YW5kYXJkUmVnaW9ucykubWFwKHRvT3B0aW9uKSksIDIpLCByZWdpb25zID0gX2tbMF0sIHNldFJlZ2lvbnMgPSBfa1sxXTtcclxuICAgIHZhciBsb2FkUmVnaW9ucyA9IHByb3BzLmxvYWRSZWdpb25zLCBvbk9wdGlvbnNDaGFuZ2UgPSBwcm9wcy5vbk9wdGlvbnNDaGFuZ2UsIF9sID0gcHJvcHMuc2tpcEhlYWRlciwgc2tpcEhlYWRlciA9IF9sID09PSB2b2lkIDAgPyBmYWxzZSA6IF9sLCBfbSA9IHByb3BzLnNraXBFbmRwb2ludCwgc2tpcEVuZHBvaW50ID0gX20gPT09IHZvaWQgMCA/IGZhbHNlIDogX207XHJcbiAgICB2YXIgb3B0aW9ucyA9IHByb3BzLm9wdGlvbnM7XHJcbiAgICB2YXIgcHJvZmlsZSA9IG9wdGlvbnMuanNvbkRhdGEucHJvZmlsZTtcclxuICAgIGlmIChwcm9maWxlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBwcm9maWxlID0gb3B0aW9ucy5kYXRhYmFzZTtcclxuICAgIH1cclxuICAgIHZhciBzZXR0aW5ncyA9IHdpbmRvdy5ncmFmYW5hQm9vdERhdGEuc2V0dGluZ3M7XHJcbiAgICB2YXIgYXdzQWxsb3dlZEF1dGhQcm92aWRlcnMgPSAoX2EgPSBzZXR0aW5ncy5hd3NBbGxvd2VkQXV0aFByb3ZpZGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW1xyXG4gICAgICAgIGV4cG9ydHMuQXdzQXV0aFR5cGUuRGVmYXVsdCxcclxuICAgICAgICBleHBvcnRzLkF3c0F1dGhUeXBlLktleXMsXHJcbiAgICAgICAgZXhwb3J0cy5Bd3NBdXRoVHlwZS5DcmVkZW50aWFscyxcclxuICAgIF07XHJcbiAgICB2YXIgYXdzQXNzdW1lUm9sZUVuYWJsZWQgPSAoX2IgPSBzZXR0aW5ncy5hd3NBc3N1bWVSb2xlRW5hYmxlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcclxuICAgIHZhciBjdXJyZW50UHJvdmlkZXIgPSBhd3NBdXRoUHJvdmlkZXJPcHRpb25zLmZpbmQoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudmFsdWUgPT09IG9wdGlvbnMuanNvbkRhdGEuYXV0aFR5cGU7IH0pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgYSBhdXRoVHlwZSBleGlzdHMgaW4gdGhlIGN1cnJlbnQgbW9kZWxcclxuICAgICAgICBpZiAoIWN1cnJlbnRQcm92aWRlciAmJiBhd3NBbGxvd2VkQXV0aFByb3ZpZGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgb25PcHRpb25zQ2hhbmdlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBqc29uRGF0YTogX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMuanNvbkRhdGEpLCB7IGF1dGhUeXBlOiBhd3NBbGxvd2VkQXV0aFByb3ZpZGVyc1swXSB9KSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2N1cnJlbnRQcm92aWRlciwgb3B0aW9ucywgb25PcHRpb25zQ2hhbmdlXSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghbG9hZFJlZ2lvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2FkUmVnaW9ucygpLnRoZW4oZnVuY3Rpb24gKHJlZ2lvbnMpIHsgcmV0dXJuIHNldFJlZ2lvbnMocmVnaW9ucy5tYXAodG9PcHRpb24pKTsgfSk7XHJcbiAgICB9LCBbbG9hZFJlZ2lvbnNdKTtcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5GaWVsZFNldCwgeyBsYWJlbDogc2tpcEhlYWRlciA/ICcnIDogJ0Nvbm5lY3Rpb24gRGV0YWlscycsIFwiZGF0YS10ZXN0aWRcIjogXCJjb25uZWN0aW9uLWNvbmZpZ1wiIH0sXHJcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5JbmxpbmVGaWVsZCwgeyBsYWJlbDogXCJBdXRoZW50aWNhdGlvbiBQcm92aWRlclwiLCBsYWJlbFdpZHRoOiAyOCwgdG9vbHRpcDogXCJTcGVjaWZ5IHdoaWNoIEFXUyBjcmVkZW50aWFscyBjaGFpbiB0byB1c2UuXCIgfSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5TZWxlY3QsIHsgXCJhcmlhLWxhYmVsXCI6IFwiQXV0aGVudGljYXRpb24gUHJvdmlkZXJcIiwgY2xhc3NOYW1lOiBcIndpZHRoLTMwXCIsIHZhbHVlOiBjdXJyZW50UHJvdmlkZXIsIG9wdGlvbnM6IGF3c0F1dGhQcm92aWRlck9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChvcHQpIHsgcmV0dXJuIGF3c0FsbG93ZWRBdXRoUHJvdmlkZXJzLmluY2x1ZGVzKG9wdC52YWx1ZSk7IH0pLCBkZWZhdWx0VmFsdWU6IG9wdGlvbnMuanNvbkRhdGEuYXV0aFR5cGUsIG9uQ2hhbmdlOiBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5vblVwZGF0ZURhdGFzb3VyY2VKc29uRGF0YU9wdGlvblNlbGVjdChwcm9wcywgJ2F1dGhUeXBlJykob3B0aW9uKTtcclxuICAgICAgICAgICAgICAgIH0sIG1lbnVTaG91bGRQb3J0YWw6IHRydWUgfSkpLFxyXG4gICAgICAgIG9wdGlvbnMuanNvbkRhdGEuYXV0aFR5cGUgPT09ICdjcmVkZW50aWFscycgJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodWkuSW5saW5lRmllbGQsIHsgbGFiZWw6IFwiQ3JlZGVudGlhbHMgUHJvZmlsZSBOYW1lXCIsIGxhYmVsV2lkdGg6IDI4LCB0b29sdGlwOiBcIkNyZWRlbnRpYWxzIHByb2ZpbGUgbmFtZSwgYXMgc3BlY2lmaWVkIGluIH4vLmF3cy9jcmVkZW50aWFscywgbGVhdmUgYmxhbmsgZm9yIGRlZmF1bHQuXCIgfSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5JbnB1dCwgeyBcImFyaWEtbGFiZWxcIjogXCJDcmVkZW50aWFscyBQcm9maWxlIE5hbWVcIiwgY2xhc3NOYW1lOiBcIndpZHRoLTMwXCIsIHBsYWNlaG9sZGVyOiBcImRlZmF1bHRcIiwgdmFsdWU6IHByb2ZpbGUsIG9uQ2hhbmdlOiBkYXRhLm9uVXBkYXRlRGF0YXNvdXJjZUpzb25EYXRhT3B0aW9uKHByb3BzLCAncHJvZmlsZScpIH0pKSksXHJcbiAgICAgICAgb3B0aW9ucy5qc29uRGF0YS5hdXRoVHlwZSA9PT0gJ2tleXMnICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHVpLklubGluZUZpZWxkLCB7IGxhYmVsOiBcIkFjY2VzcyBLZXkgSURcIiwgbGFiZWxXaWR0aDogMjggfSwgKChfYyA9IHByb3BzLm9wdGlvbnMuc2VjdXJlSnNvbkZpZWxkcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjY2Vzc0tleSkgPyAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5CdXR0b25Hcm91cCwgeyBjbGFzc05hbWU6IFwid2lkdGgtMzBcIiB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5JbnB1dCwgeyBkaXNhYmxlZDogdHJ1ZSwgcGxhY2Vob2xkZXI6IFwiQ29uZmlndXJlZFwiIH0pLFxyXG4gICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5Ub29sYmFyQnV0dG9uLCB7IGljb246IFwiZWRpdFwiLCB0b29sdGlwOiBcIkVkaXQgQWNjZXNzIEtleSBJRFwiLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiBkYXRhLm9uVXBkYXRlRGF0YXNvdXJjZVJlc2V0T3B0aW9uKHByb3BzLCAnYWNjZXNzS2V5JykgfSkpKSA6IChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHVpLklucHV0LCB7IFwiYXJpYS1sYWJlbFwiOiBcIkFjY2VzcyBLZXkgSURcIiwgY2xhc3NOYW1lOiBcIndpZHRoLTMwXCIsIHZhbHVlOiAoX2UgPSAoX2QgPSBvcHRpb25zLnNlY3VyZUpzb25EYXRhKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWNjZXNzS2V5KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAnJywgb25DaGFuZ2U6IGRhdGEub25VcGRhdGVEYXRhc291cmNlU2VjdXJlSnNvbkRhdGFPcHRpb24ocHJvcHMsICdhY2Nlc3NLZXknKSB9KSkpLFxyXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHVpLklubGluZUZpZWxkLCB7IGxhYmVsOiBcIlNlY3JldCBBY2Nlc3MgS2V5XCIsIGxhYmVsV2lkdGg6IDI4IH0sICgoX2YgPSBwcm9wcy5vcHRpb25zLnNlY3VyZUpzb25GaWVsZHMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zZWNyZXRLZXkpID8gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodWkuQnV0dG9uR3JvdXAsIHsgY2xhc3NOYW1lOiBcIndpZHRoLTMwXCIgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodWkuSW5wdXQsIHsgZGlzYWJsZWQ6IHRydWUsIHBsYWNlaG9sZGVyOiBcIkNvbmZpZ3VyZWRcIiB9KSxcclxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodWkuVG9vbGJhckJ1dHRvbiwgeyBpY29uOiBcImVkaXRcIiwgdHlwZTogXCJidXR0b25cIiwgdG9vbHRpcDogXCJFZGl0IFNlY3JldCBBY2Nlc3MgS2V5XCIsIG9uQ2xpY2s6IGRhdGEub25VcGRhdGVEYXRhc291cmNlUmVzZXRPcHRpb24ocHJvcHMsICdzZWNyZXRLZXknKSB9KSkpIDogKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodWkuSW5wdXQsIHsgXCJhcmlhLWxhYmVsXCI6IFwiU2VjcmV0IEFjY2VzcyBLZXlcIiwgY2xhc3NOYW1lOiBcIndpZHRoLTMwXCIsIHZhbHVlOiAoX2ggPSAoX2cgPSBvcHRpb25zLnNlY3VyZUpzb25EYXRhKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuc2VjcmV0S2V5KSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAnJywgb25DaGFuZ2U6IGRhdGEub25VcGRhdGVEYXRhc291cmNlU2VjdXJlSnNvbkRhdGFPcHRpb24ocHJvcHMsICdzZWNyZXRLZXknKSB9KSkpKSksXHJcbiAgICAgICAgYXdzQXNzdW1lUm9sZUVuYWJsZWQgJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3RfX2RlZmF1bHQuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodWkuSW5saW5lRmllbGQsIHsgbGFiZWw6IFwiQXNzdW1lIFJvbGUgQVJOXCIsIGxhYmVsV2lkdGg6IDI4LCB0b29sdGlwOiBcIk9wdGlvbmFsbHksIHNwZWNpZnkgdGhlIEFSTiBvZiBhIHJvbGUgdG8gYXNzdW1lLiBTcGVjaWZ5aW5nIGEgcm9sZSBoZXJlIHdpbGwgZW5zdXJlIHRoYXQgdGhlIHNlbGVjdGVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIGlzIHVzZWQgdG8gYXNzdW1lIHRoZSBzcGVjaWZpZWQgcm9sZSByYXRoZXIgdGhhbiB1c2luZyB0aGUgY3JlZGVudGlhbHMgZGlyZWN0bHkuIExlYXZlIGJsYW5rIGlmIHlvdSBkb24ndCBuZWVkIHRvIGFzc3VtZSBhIHJvbGUgYXQgYWxsXCIgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodWkuSW5wdXQsIHsgXCJhcmlhLWxhYmVsXCI6IFwiQXNzdW1lIFJvbGUgQVJOXCIsIGNsYXNzTmFtZTogXCJ3aWR0aC0zMFwiLCBwbGFjZWhvbGRlcjogXCJhcm46YXdzOmlhbToqXCIsIHZhbHVlOiBvcHRpb25zLmpzb25EYXRhLmFzc3VtZVJvbGVBcm4gfHwgJycsIG9uQ2hhbmdlOiBkYXRhLm9uVXBkYXRlRGF0YXNvdXJjZUpzb25EYXRhT3B0aW9uKHByb3BzLCAnYXNzdW1lUm9sZUFybicpIH0pKSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5JbmxpbmVGaWVsZCwgeyBsYWJlbDogXCJFeHRlcm5hbCBJRFwiLCBsYWJlbFdpZHRoOiAyOCwgdG9vbHRpcDogXCJJZiB5b3UgYXJlIGFzc3VtaW5nIGEgcm9sZSBpbiBhbm90aGVyIGFjY291bnQsIHRoYXQgaGFzIGJlZW4gY3JlYXRlZCB3aXRoIGFuIGV4dGVybmFsIElELCBzcGVjaWZ5IHRoZSBleHRlcm5hbCBJRCBoZXJlLlwiIH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHVpLklucHV0LCB7IFwiYXJpYS1sYWJlbFwiOiBcIkV4dGVybmFsIElEXCIsIGNsYXNzTmFtZTogXCJ3aWR0aC0zMFwiLCBwbGFjZWhvbGRlcjogXCJFeHRlcm5hbCBJRFwiLCB2YWx1ZTogb3B0aW9ucy5qc29uRGF0YS5leHRlcm5hbElkIHx8ICcnLCBvbkNoYW5nZTogZGF0YS5vblVwZGF0ZURhdGFzb3VyY2VKc29uRGF0YU9wdGlvbihwcm9wcywgJ2V4dGVybmFsSWQnKSB9KSkpKSxcclxuICAgICAgICAhc2tpcEVuZHBvaW50ICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHVpLklubGluZUZpZWxkLCB7IGxhYmVsOiBcIkVuZHBvaW50XCIsIGxhYmVsV2lkdGg6IDI4LCB0b29sdGlwOiBcIk9wdGlvbmFsbHksIHNwZWNpZnkgYSBjdXN0b20gZW5kcG9pbnQgZm9yIHRoZSBzZXJ2aWNlXCIgfSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5JbnB1dCwgeyBcImFyaWEtbGFiZWxcIjogXCJFbmRwb2ludFwiLCBjbGFzc05hbWU6IFwid2lkdGgtMzBcIiwgcGxhY2Vob2xkZXI6IChfaiA9IHByb3BzLmRlZmF1bHRFbmRwb2ludCkgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogJ2h0dHBzOi8ve3NlcnZpY2V9LntyZWdpb259LmFtYXpvbmF3cy5jb20nLCB2YWx1ZTogb3B0aW9ucy5qc29uRGF0YS5lbmRwb2ludCB8fCAnJywgb25DaGFuZ2U6IGRhdGEub25VcGRhdGVEYXRhc291cmNlSnNvbkRhdGFPcHRpb24ocHJvcHMsICdlbmRwb2ludCcpIH0pKSksXHJcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5JbmxpbmVGaWVsZCwgeyBsYWJlbDogXCJEZWZhdWx0IFJlZ2lvblwiLCBsYWJlbFdpZHRoOiAyOCwgdG9vbHRpcDogXCJTcGVjaWZ5IHRoZSByZWdpb24sIHN1Y2ggYXMgZm9yIFVTIFdlc3QgKE9yZWdvbikgdXNlIGAgdXMtd2VzdC0yIGAgYXMgdGhlIHJlZ2lvbi5cIiB9LFxyXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHVpLlNlbGVjdCwgeyBcImFyaWEtbGFiZWxcIjogXCJEZWZhdWx0IFJlZ2lvblwiLCBjbGFzc05hbWU6IFwid2lkdGgtMzBcIiwgdmFsdWU6IHJlZ2lvbnMuZmluZChmdW5jdGlvbiAocmVnaW9uKSB7IHJldHVybiByZWdpb24udmFsdWUgPT09IG9wdGlvbnMuanNvbkRhdGEuZGVmYXVsdFJlZ2lvbjsgfSksIG9wdGlvbnM6IHJlZ2lvbnMsIGRlZmF1bHRWYWx1ZTogb3B0aW9ucy5qc29uRGF0YS5kZWZhdWx0UmVnaW9uLCBhbGxvd0N1c3RvbVZhbHVlOiB0cnVlLCBvbkNoYW5nZTogZGF0YS5vblVwZGF0ZURhdGFzb3VyY2VKc29uRGF0YU9wdGlvblNlbGVjdChwcm9wcywgJ2RlZmF1bHRSZWdpb24nKSwgZm9ybWF0Q3JlYXRlTGFiZWw6IGZ1bmN0aW9uIChyKSB7IHJldHVybiBcIlVzZSByZWdpb246IFwiICsgcjsgfSwgbWVudVNob3VsZFBvcnRhbDogdHJ1ZSB9KSksXHJcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4pKTtcclxufTtcblxudmFyIFNJR1Y0Q29ubmVjdGlvbkNvbmZpZyA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgdmFyIG9uT3B0aW9uc0NoYW5nZSA9IHByb3BzLm9uT3B0aW9uc0NoYW5nZSwgb3B0aW9ucyA9IHByb3BzLm9wdGlvbnM7XHJcbiAgICAvLyBNYXAgSHR0cFNldHRpbmdzIHByb3BzIHRvIENvbm5lY3Rpb25Db25maWdQcm9wc1xyXG4gICAgdmFyIGNvbm5lY3Rpb25Db25maWdQcm9wcyA9IHtcclxuICAgICAgICBvbk9wdGlvbnNDaGFuZ2U6IGZ1bmN0aW9uIChhd3NEYXRhU291cmNlU2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgICAgICB2YXIgZGF0YVNvdXJjZVNldHRpbmdzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGpzb25EYXRhOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucy5qc29uRGF0YSksIHsgc2lnVjRBdXRoVHlwZTogYXdzRGF0YVNvdXJjZVNldHRpbmdzLmpzb25EYXRhLmF1dGhUeXBlLCBzaWdWNFByb2ZpbGU6IGF3c0RhdGFTb3VyY2VTZXR0aW5ncy5qc29uRGF0YS5wcm9maWxlLCBzaWdWNEFzc3VtZVJvbGVBcm46IGF3c0RhdGFTb3VyY2VTZXR0aW5ncy5qc29uRGF0YS5hc3N1bWVSb2xlQXJuLCBzaWdWNEV4dGVybmFsSWQ6IGF3c0RhdGFTb3VyY2VTZXR0aW5ncy5qc29uRGF0YS5leHRlcm5hbElkLCBzaWdWNFJlZ2lvbjogYXdzRGF0YVNvdXJjZVNldHRpbmdzLmpzb25EYXRhLmRlZmF1bHRSZWdpb24sIHNpZ1Y0RW5kcG9pbnQ6IGF3c0RhdGFTb3VyY2VTZXR0aW5ncy5qc29uRGF0YS5lbmRwb2ludCB9KSwgc2VjdXJlSnNvbkZpZWxkczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZ1Y0QWNjZXNzS2V5OiAoX2EgPSBhd3NEYXRhU291cmNlU2V0dGluZ3Muc2VjdXJlSnNvbkZpZWxkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc0tleSxcclxuICAgICAgICAgICAgICAgICAgICBzaWdWNFNlY3JldEtleTogKF9iID0gYXdzRGF0YVNvdXJjZVNldHRpbmdzLnNlY3VyZUpzb25GaWVsZHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZWNyZXRLZXksXHJcbiAgICAgICAgICAgICAgICB9LCBzZWN1cmVKc29uRGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZ1Y0QWNjZXNzS2V5OiAoX2MgPSBhd3NEYXRhU291cmNlU2V0dGluZ3Muc2VjdXJlSnNvbkRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hY2Nlc3NLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgc2lnVjRTZWNyZXRLZXk6IChfZCA9IGF3c0RhdGFTb3VyY2VTZXR0aW5ncy5zZWN1cmVKc29uRGF0YSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNlY3JldEtleSxcclxuICAgICAgICAgICAgICAgIH0gfSk7XHJcbiAgICAgICAgICAgIG9uT3B0aW9uc0NoYW5nZShkYXRhU291cmNlU2V0dGluZ3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3B0aW9uczogX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGpzb25EYXRhOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucy5qc29uRGF0YSksIHsgYXV0aFR5cGU6IG9wdGlvbnMuanNvbkRhdGEuc2lnVjRBdXRoVHlwZSwgcHJvZmlsZTogb3B0aW9ucy5qc29uRGF0YS5zaWdWNFByb2ZpbGUsIGFzc3VtZVJvbGVBcm46IG9wdGlvbnMuanNvbkRhdGEuc2lnVjRBc3N1bWVSb2xlQXJuLCBleHRlcm5hbElkOiBvcHRpb25zLmpzb25EYXRhLnNpZ1Y0RXh0ZXJuYWxJZCwgZGVmYXVsdFJlZ2lvbjogb3B0aW9ucy5qc29uRGF0YS5zaWdWNFJlZ2lvbiwgZW5kcG9pbnQ6IG9wdGlvbnMuanNvbkRhdGEuc2lnVjRFbmRwb2ludCB9KSwgc2VjdXJlSnNvbkZpZWxkczoge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzS2V5OiAoX2EgPSBvcHRpb25zLnNlY3VyZUpzb25GaWVsZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWdWNEFjY2Vzc0tleSxcclxuICAgICAgICAgICAgICAgIHNlY3JldEtleTogKF9iID0gb3B0aW9ucy5zZWN1cmVKc29uRmllbGRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2lnVjRTZWNyZXRLZXksXHJcbiAgICAgICAgICAgIH0sIHNlY3VyZUpzb25EYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NLZXk6IChfYyA9IG9wdGlvbnMuc2VjdXJlSnNvbkRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zaWdWNEFjY2Vzc0tleSxcclxuICAgICAgICAgICAgICAgIHNlY3JldEtleTogKF9kID0gb3B0aW9ucy5zZWN1cmVKc29uRGF0YSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNpZ1Y0U2VjcmV0S2V5LFxyXG4gICAgICAgICAgICB9IH0pLFxyXG4gICAgfTtcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdF9fZGVmYXVsdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImdmLWZvcm1cIiB9LFxyXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDZcIiwgbnVsbCwgXCJTaWdWNCBBdXRoIERldGFpbHNcIikpLFxyXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdGlvbkNvbmZpZywgX19hc3NpZ24oe30sIGNvbm5lY3Rpb25Db25maWdQcm9wcywgeyBza2lwSGVhZGVyOiB0cnVlLCBza2lwRW5kcG9pbnQ6IHRydWUgfSkpKSk7XHJcbn07XG5cbnZhciBkZWZhdWx0S2V5ID0gJ19fZGVmYXVsdCc7XG5cbmZ1bmN0aW9uIFJlc291cmNlU2VsZWN0b3IocHJvcHMpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICB2YXIgX2EgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUocHJvcHMudmFsdWUgfHwgcHJvcHMuZGVmYXVsdCB8fCBudWxsKSwgMiksIHJlc291cmNlID0gX2FbMF0sIHNldFJlc291cmNlID0gX2FbMV07XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUocmVzb3VyY2UgPyBbcmVzb3VyY2VdIDogW10pLCAyKSwgcmVzb3VyY2VzID0gX2JbMF0sIHNldFJlc291cmNlcyA9IF9iWzFdO1xyXG4gICAgdmFyIF9jID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKHByb3BzLmRlcGVuZGVuY2llcyksIDIpLCBkZXBlbmRlbmNpZXMgPSBfY1swXSwgc2V0RGVwZW5kZW5jaWVzID0gX2NbMV07XHJcbiAgICB2YXIgX2QgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUoZmFsc2UpLCAyKSwgaXNMb2FkaW5nID0gX2RbMF0sIHNldElzTG9hZGluZyA9IF9kWzFdO1xyXG4gICAgdmFyIF9lID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKGZhbHNlKSwgMiksIGZldGNoZWQgPSBfZVswXSwgc2V0RmV0Y2hlZCA9IF9lWzFdO1xyXG4gICAgdmFyIGRlZmF1bHRPcHRzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBcImRlZmF1bHQgKFwiICsgcHJvcHMuZGVmYXVsdCArIFwiKVwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlZmF1bHRLZXksXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJEZWZhdWx0IHZhbHVlIHNldCBpbiB0aGUgZGF0YSBzb3VyY2VcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAmJiBwcm9wcy52YWx1ZSAhPT0gZGVmYXVsdEtleSkge1xyXG4gICAgICAgICAgICBvcHRzLnB1c2goeyBsYWJlbDogcHJvcHMudmFsdWUsIHZhbHVlOiBwcm9wcy52YWx1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdHM7XHJcbiAgICB9LCBbcHJvcHMuZGVmYXVsdCwgcHJvcHMudmFsdWVdKTtcclxuICAgIHZhciBfZiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZShwcm9wcy5kZWZhdWx0ID8gZGVmYXVsdE9wdHMgOiBbXSksIDIpLCBvcHRpb25zID0gX2ZbMF0sIHNldE9wdGlvbnMgPSBfZlsxXTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHByb3BzLnJlc291cmNlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHNldFJlc291cmNlcyhwcm9wcy5yZXNvdXJjZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtwcm9wcy5yZXNvdXJjZXNdKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBwcm9wcy5kZWZhdWx0ID8gZGVmYXVsdE9wdHMgOiBbXTtcclxuICAgICAgICBpZiAocmVzb3VyY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdHlwZW9mIHIgPT09ICdzdHJpbmcnID8gciA6IHIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5ld09wdGlvbnMuZmluZChmdW5jdGlvbiAobykgeyByZXR1cm4gby52YWx1ZSA9PT0gdmFsdWU7IH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHIgPT09ICdzdHJpbmcnID8gbmV3T3B0aW9ucy5wdXNoKHsgbGFiZWw6IHIsIHZhbHVlOiByIH0pIDogbmV3T3B0aW9ucy5wdXNoKHIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0T3B0aW9ucyhuZXdPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldE9wdGlvbnMoW10pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtyZXNvdXJjZXMsIGRlZmF1bHRPcHRzLCBwcm9wcy5kZWZhdWx0XSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIEEgY2hhbmdlIGluIHRoZSBkZXBlbmRlbmNpZXMgY2F1c2UgYSBzdGF0ZSBjbGVhbi11cFxyXG4gICAgICAgIGlmICghbG9kYXNoLmlzRXF1YWwocHJvcHMuZGVwZW5kZW5jaWVzLCBkZXBlbmRlbmNpZXMpKSB7XHJcbiAgICAgICAgICAgIHNldEZldGNoZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRSZXNvdXJjZShudWxsKTtcclxuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UobnVsbCk7XHJcbiAgICAgICAgICAgIHNldERlcGVuZGVuY2llcyhwcm9wcy5kZXBlbmRlbmNpZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtwcm9wcywgZGVwZW5kZW5jaWVzXSk7XHJcbiAgICB2YXIgZmV0Y2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc291cmNlc18xO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5zYXZlT3B0aW9ucykgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcHJvcHMuc2F2ZU9wdGlvbnMoKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzIsICwgNCwgNV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHByb3BzLmZldGNoKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlc18xID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFJlc291cmNlcyhyZXNvdXJjZXNfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RmV0Y2hlZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pOyB9O1xyXG4gICAgdmFyIG9uQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBwcm9wcy5vbkNoYW5nZShlKTtcclxuICAgICAgICBpZiAoZS52YWx1ZSkge1xyXG4gICAgICAgICAgICBzZXRSZXNvdXJjZShlLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIG9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsICwgMywgNF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodWkuSW5saW5lRmllbGQsIHsgbGFiZWw6IHByb3BzLmxhYmVsLCBsYWJlbFdpZHRoOiBwcm9wcy5sYWJlbFdpZHRoLCB0b29sdGlwOiBwcm9wcy50b29sdGlwLCBoaWRkZW46IHByb3BzLmhpZGRlbiB9LFxyXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtdGVzdGlkXCI6IHByb3BzWydkYXRhLXRlc3RpZCddLCB0aXRsZTogcHJvcHMudGl0bGUgfSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5TZWxlY3QsIF9fYXNzaWduKHt9LCBwcm9wcywgeyBcImFyaWEtbGFiZWxcIjogcHJvcHMubGFiZWwsIG9wdGlvbnM6IG9wdGlvbnMsIG9uQ2hhbmdlOiBvbkNoYW5nZSwgaXNMb2FkaW5nOiBpc0xvYWRpbmcsIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lIHx8ICdtaW4td2lkdGgtNicsIG9uT3Blbk1lbnU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3BzLmZldGNoICYmIG9uQ2xpY2soKTsgfSwgbWVudVNob3VsZFBvcnRhbDogdHJ1ZSB9KSkpKSk7XHJcbn1cblxuZnVuY3Rpb24gQ29uZmlnU2VsZWN0KHByb3BzKSB7XHJcbiAgICB2YXIganNvbkRhdGEgPSBwcm9wcy5vcHRpb25zLmpzb25EYXRhO1xyXG4gICAgdmFyIGNvbW1vblByb3BzID0ge1xyXG4gICAgICAgIHRpdGxlOiBqc29uRGF0YS5kZWZhdWx0UmVnaW9uID8gJycgOiAnc2VsZWN0IGEgZGVmYXVsdCByZWdpb24nLFxyXG4gICAgICAgIGxhYmVsV2lkdGg6IDI4LFxyXG4gICAgICAgIGNsYXNzTmFtZTogJ3dpZHRoLTMwJyxcclxuICAgIH07XHJcbiAgICAvLyBBbnkgY2hhbmdlIGluIHRoZSBBV1MgY29ubmVjdGlvbiBkZXRhaWxzIHdpbGwgYWZmZWN0IHNlbGVjdG9yc1xyXG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IFtcclxuICAgICAgICBwcm9wcy5vcHRpb25zLmpzb25EYXRhLmFzc3VtZVJvbGVBcm4sXHJcbiAgICAgICAgcHJvcHMub3B0aW9ucy5qc29uRGF0YS5hdXRoVHlwZSxcclxuICAgICAgICBwcm9wcy5vcHRpb25zLmpzb25EYXRhLmRlZmF1bHRSZWdpb24sXHJcbiAgICAgICAgcHJvcHMub3B0aW9ucy5qc29uRGF0YS5lbmRwb2ludCxcclxuICAgICAgICBwcm9wcy5vcHRpb25zLmpzb25EYXRhLmV4dGVybmFsSWQsXHJcbiAgICAgICAgcHJvcHMub3B0aW9ucy5qc29uRGF0YS5wcm9maWxlLFxyXG4gICAgXS5jb25jYXQocHJvcHMuZGVwZW5kZW5jaWVzKTtcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZXNvdXJjZVNlbGVjdG9yLCBfX2Fzc2lnbih7IGxhYmVsOiBwcm9wcy5sYWJlbCwgXCJkYXRhLXRlc3RpZFwiOiBwcm9wc1snZGF0YS10ZXN0aWQnXSwgb25DaGFuZ2U6IHByb3BzLm9uQ2hhbmdlLCBmZXRjaDogcHJvcHMuZmV0Y2gsIHZhbHVlOiBwcm9wcy52YWx1ZSwgc2F2ZU9wdGlvbnM6IHByb3BzLnNhdmVPcHRpb25zLCBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcywgaGlkZGVuOiBwcm9wcy5oaWRkZW4sIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCB8fCAhanNvbkRhdGEuZGVmYXVsdFJlZ2lvbiwgYWxsb3dDdXN0b21WYWx1ZTogcHJvcHMuYWxsb3dDdXN0b21WYWx1ZSwgYXV0b0ZvY3VzOiBwcm9wcy5hdXRvRm9jdXMsIGJhY2tzcGFjZVJlbW92ZXNWYWx1ZTogcHJvcHMuYmFja3NwYWNlUmVtb3Zlc1ZhbHVlLCBjbGFzc05hbWU6IHByb3BzLmNsYXNzTmFtZSwgaW52YWxpZDogcHJvcHMuaW52YWxpZCwgaXNDbGVhcmFibGU6IHByb3BzLmlzQ2xlYXJhYmxlLCBpc011bHRpOiBwcm9wcy5pc011bHRpLCBpbnB1dElkOiBwcm9wcy5pbnB1dElkLCBzaG93QWxsU2VsZWN0ZWRXaGVuT3BlbjogcHJvcHMuc2hvd0FsbFNlbGVjdGVkV2hlbk9wZW4sIG1heE1lbnVIZWlnaHQ6IHByb3BzLm1heE1lbnVIZWlnaHQsIG1pbk1lbnVIZWlnaHQ6IHByb3BzLm1pbk1lbnVIZWlnaHQsIG1heFZpc2libGVWYWx1ZXM6IHByb3BzLm1heFZpc2libGVWYWx1ZXMsIG1lbnVQbGFjZW1lbnQ6IHByb3BzLm1lbnVQbGFjZW1lbnQsIG1lbnVQb3NpdGlvbjogcHJvcHMubWVudVBvc2l0aW9uLCBub09wdGlvbnNNZXNzYWdlOiBwcm9wcy5ub09wdGlvbnNNZXNzYWdlLCBvbkJsdXI6IHByb3BzLm9uQmx1ciwgb25DcmVhdGVPcHRpb246IHByb3BzLm9uQ3JlYXRlT3B0aW9uLCBvbklucHV0Q2hhbmdlOiBwcm9wcy5vbklucHV0Q2hhbmdlLCBwbGFjZWhvbGRlcjogcHJvcHMucGxhY2Vob2xkZXIsIHdpZHRoOiBwcm9wcy53aWR0aCwgaXNPcHRpb25EaXNhYmxlZDogcHJvcHMuaXNPcHRpb25EaXNhYmxlZCB9LCBjb21tb25Qcm9wcykpKTtcclxufVxuXG5mdW5jdGlvbiBJbmxpbmVJbnB1dChwcm9wcykge1xyXG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHVpLklubGluZUZpZWxkLCB7IGxhYmVsOiBwcm9wcy5sYWJlbCwgbGFiZWxXaWR0aDogMjgsIHRvb2x0aXA6IHByb3BzLnRvb2x0aXAsIGhpZGRlbjogcHJvcHMuaGlkZGVuLCBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfSxcclxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHVpLklucHV0LCB7IFwiZGF0YS10ZXN0aWRcIjogcHJvcHNbJ2RhdGEtdGVzdGlkJ10sIGNsYXNzTmFtZTogXCJ3aWR0aC0zMFwiLCB2YWx1ZTogcHJvcHMudmFsdWUsIG9uQ2hhbmdlOiBwcm9wcy5vbkNoYW5nZSwgcGxhY2Vob2xkZXI6IHByb3BzLnBsYWNlaG9sZGVyLCBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfSkpKTtcclxufVxuXG5mdW5jdGlvbiBRdWVyeUNvZGVFZGl0b3IocHJvcHMpIHtcclxuICAgIHZhciBnZXRTdWdnZXN0aW9ucyA9IHByb3BzLmdldFN1Z2dlc3Rpb25zLCBxdWVyeSA9IHByb3BzLnF1ZXJ5O1xyXG4gICAgdmFyIHJhd1NRTCA9IGxvZGFzaC5kZWZhdWx0cyhwcm9wcy5xdWVyeSwgeyByYXdTUUw6ICcnIH0pLnJhd1NRTDtcclxuICAgIHZhciBvblJhd1NxbENoYW5nZSA9IGZ1bmN0aW9uIChyYXdTUUwpIHtcclxuICAgICAgICB2YXIgcXVlcnkgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJvcHMucXVlcnkpLCB7IHJhd1NRTDogcmF3U1FMIH0pO1xyXG4gICAgICAgIHByb3BzLm9uQ2hhbmdlKHF1ZXJ5KTtcclxuICAgICAgICBwcm9wcy5vblJ1blF1ZXJ5KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gVXNlIGEgcmVmZXJlbmNlIGZvciBzdWdnZXN0aW9ucyBiZWNhdXNlIGEgYnVnIGluIENvZGVFZGl0b3IgZ2V0U3VnZ2VzdGlvbnNcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFmYW5hL2dyYWZhbmEvaXNzdWVzLzQwMTIxXHJcbiAgICAvLyBJdCB3YXMgYmVlbiBmaXhlZCBpbiA4LjMgYnV0IGtlZXBpbmcgdGhlIHdvcmthcm91bmQgaGVyZSB0byBzdXBwb3J0IG9sZGVyXHJcbiAgICAvLyB2ZXJzaW9ucy5cclxuICAgIHZhciBzdWdnZXN0aW9uc1JlZiA9IFJlYWN0LnVzZVJlZihbXSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHN1Z2dlc3Rpb25zUmVmLmN1cnJlbnQgPSBnZXRTdWdnZXN0aW9ucyhxdWVyeSk7XHJcbiAgICB9LCBbZ2V0U3VnZ2VzdGlvbnMsIHF1ZXJ5XSk7XHJcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodWkuQ29kZUVkaXRvciwgX19hc3NpZ24oeyBsYW5ndWFnZTogcHJvcHMubGFuZ3VhZ2UsIHZhbHVlOiByYXdTUUwsIG9uQmx1cjogb25SYXdTcWxDaGFuZ2UsIHNob3dNaW5pTWFwOiBmYWxzZSwgc2hvd0xpbmVOdW1iZXJzOiB0cnVlLCBnZXRTdWdnZXN0aW9uczogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3VnZ2VzdGlvbnNSZWYuY3VycmVudDsgfSwgaGVpZ2h0OiBcIjI0MHB4XCIgfSwgcHJvcHMuZWRpdG9yUHJvcHMpKSk7XHJcbn1cblxuZnVuY3Rpb24gRm9ybWF0U2VsZWN0KHByb3BzKSB7XHJcbiAgICB2YXIgb25DaGFuZ2VGb3JtYXQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHByb3BzLm9uQ2hhbmdlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcm9wcy5xdWVyeSksIHsgZm9ybWF0OiBlLnZhbHVlIHx8IDAgfSkpO1xyXG4gICAgICAgIHByb3BzLm9uUnVuUXVlcnkoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodWkuSW5saW5lRmllbGQsIHsgbGFiZWw6IFwiRm9ybWF0IGFzXCIsIGxhYmVsV2lkdGg6IDExIH0sXHJcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5TZWxlY3QsIHsgXCJhcmlhLWxhYmVsXCI6IFwiRm9ybWF0IGFzXCIsIG9wdGlvbnM6IHByb3BzLm9wdGlvbnMsIHZhbHVlOiBwcm9wcy5xdWVyeS5mb3JtYXQsIG9uQ2hhbmdlOiBvbkNoYW5nZUZvcm1hdCwgY2xhc3NOYW1lOiBcIndpZHRoLTEyXCIsIG1lbnVTaG91bGRQb3J0YWw6IHRydWUgfSkpKTtcclxufVxuXG4oZnVuY3Rpb24gKEZpbGxWYWx1ZU9wdGlvbnMpIHtcclxuICAgIEZpbGxWYWx1ZU9wdGlvbnNbRmlsbFZhbHVlT3B0aW9uc1tcIlByZXZpb3VzXCJdID0gMF0gPSBcIlByZXZpb3VzXCI7XHJcbiAgICBGaWxsVmFsdWVPcHRpb25zW0ZpbGxWYWx1ZU9wdGlvbnNbXCJOdWxsXCJdID0gMV0gPSBcIk51bGxcIjtcclxuICAgIEZpbGxWYWx1ZU9wdGlvbnNbRmlsbFZhbHVlT3B0aW9uc1tcIlZhbHVlXCJdID0gMl0gPSBcIlZhbHVlXCI7XHJcbn0pKGV4cG9ydHMuRmlsbFZhbHVlT3B0aW9ucyB8fCAoZXhwb3J0cy5GaWxsVmFsdWVPcHRpb25zID0ge30pKTtcclxudmFyIFNlbGVjdGFibGVGaWxsVmFsdWVPcHRpb25zID0gW1xyXG4gICAge1xyXG4gICAgICAgIGxhYmVsOiAnUHJldmlvdXMgVmFsdWUnLFxyXG4gICAgICAgIHZhbHVlOiBleHBvcnRzLkZpbGxWYWx1ZU9wdGlvbnMuUHJldmlvdXMsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGxhYmVsOiAnTlVMTCcsXHJcbiAgICAgICAgdmFsdWU6IGV4cG9ydHMuRmlsbFZhbHVlT3B0aW9ucy5OdWxsLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBsYWJlbDogJ1ZhbHVlJyxcclxuICAgICAgICB2YWx1ZTogZXhwb3J0cy5GaWxsVmFsdWVPcHRpb25zLlZhbHVlLFxyXG4gICAgfSxcclxuXTtcclxuZnVuY3Rpb24gRmlsbFZhbHVlU2VsZWN0KHByb3BzKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdF9fZGVmYXVsdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHVpLklubGluZUZpZWxkLCB7IGxhYmVsOiBcIkZpbGwgdmFsdWVcIiwgdG9vbHRpcDogXCJ2YWx1ZSB0byBmaWxsIG1pc3NpbmcgcG9pbnRzXCIgfSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5TZWxlY3QsIHsgXCJhcmlhLWxhYmVsXCI6IFwiRmlsbCB2YWx1ZVwiLCBvcHRpb25zOiBTZWxlY3RhYmxlRmlsbFZhbHVlT3B0aW9ucywgdmFsdWU6IChfYiA9IChfYSA9IHByb3BzLnF1ZXJ5LmZpbGxNb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXhwb3J0cy5GaWxsVmFsdWVPcHRpb25zLlByZXZpb3VzLCBvbkNoYW5nZTogZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UoX19hc3NpZ24oX19hc3NpZ24oe30sIHByb3BzLnF1ZXJ5KSwgeyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgZmlsbE1vZGUudmFsdWUgaW4gY2FzZSBGaWxsVmFsdWVPcHRpb25zLlZhbHVlIG1vZGUgaXMgc2VsZWN0ZWQgYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsTW9kZTogX19hc3NpZ24oX19hc3NpZ24oe30sIHByb3BzLnF1ZXJ5LmZpbGxNb2RlKSwgeyBtb2RlOiB2YWx1ZSB9KSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMub25SdW5RdWVyeSgpO1xyXG4gICAgICAgICAgICAgICAgfSwgY2xhc3NOYW1lOiBcIndpZHRoLTEyXCIsIG1lbnVTaG91bGRQb3J0YWw6IHRydWUgfSkpLFxyXG4gICAgICAgICgoX2MgPSBwcm9wcy5xdWVyeS5maWxsTW9kZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1vZGUpID09PSBleHBvcnRzLkZpbGxWYWx1ZU9wdGlvbnMuVmFsdWUgJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodWkuSW5saW5lRmllbGQsIHsgbGFiZWw6IFwiVmFsdWVcIiwgbGFiZWxXaWR0aDogMTEgfSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh1aS5JbnB1dCwgeyB0eXBlOiBcIm51bWJlclwiLCBcImFyaWEtbGFiZWxcIjogXCJWYWx1ZVwiLCB2YWx1ZTogcHJvcHMucXVlcnkuZmlsbE1vZGUudmFsdWUsIG9uQ2hhbmdlOiBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRhcmdldCA9IF9hLmN1cnJlbnRUYXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLm9uQ2hhbmdlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcm9wcy5xdWVyeSksIHsgZmlsbE1vZGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IGV4cG9ydHMuRmlsbFZhbHVlT3B0aW9ucy5WYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkpO1xyXG4gICAgICAgICAgICAgICAgfSwgb25CbHVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wcy5vblJ1blF1ZXJ5KCk7IH0gfSkpKSkpO1xyXG59XG5cbi8qKlxyXG4gKiBEbyBub3QgZXhlY3V0ZSBxdWVyaWVzIHRoYXQgZG8gbm90IGV4aXN0IHlldFxyXG4gKi9cclxuZnVuY3Rpb24gZmlsdGVyU1FMUXVlcnkocXVlcnkpIHtcclxuICAgIHJldHVybiAhIXF1ZXJ5LnJhd1NRTDtcclxufVxyXG5mdW5jdGlvbiBhcHBseVNRTFRlbXBsYXRlVmFyaWFibGVzKHF1ZXJ5LCBzY29wZWRWYXJzLCBnZXRUZW1wbGF0ZVNydikge1xyXG4gICAgdmFyIHRlbXBsYXRlU3J2ID0gZ2V0VGVtcGxhdGVTcnYoKTtcclxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcXVlcnkpLCB7IHJhd1NRTDogdGVtcGxhdGVTcnYucmVwbGFjZShxdWVyeS5yYXdTUUwsIHNjb3BlZFZhcnMsIGludGVycG9sYXRlVmFyaWFibGUpIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGludGVycG9sYXRlVmFyaWFibGUodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgdmFyIHF1b3RlZFZhbHVlcyA9IHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBxdW90ZUxpdGVyYWwodik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBxdW90ZWRWYWx1ZXMuam9pbignLCcpO1xyXG59XHJcbmZ1bmN0aW9uIHF1b3RlTGl0ZXJhbCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIFwiJ1wiICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKC8nL2csIFwiJydcIikgKyBcIidcIjtcclxufVxyXG52YXIgYXBwZW5kVGVtcGxhdGVWYXJpYWJsZXNBc1N1Z2dlc3Rpb25zID0gZnVuY3Rpb24gKGdldFRlbXBsYXRlU3J2LCBzdWdzKSB7XHJcbiAgICB2YXIgdGVtcGxhdGVTcnYgPSBnZXRUZW1wbGF0ZVNydigpO1xyXG4gICAgdmFyIHRlbXBsYXRlU3VncyA9IFtdO1xyXG4gICAgdGVtcGxhdGVTcnYuZ2V0VmFyaWFibGVzKCkuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGUpIHtcclxuICAgICAgICB2YXIgbGFiZWwgPSAnJCcgKyB2YXJpYWJsZS5uYW1lO1xyXG4gICAgICAgIHZhciB2YWwgPSB0ZW1wbGF0ZVNydi5yZXBsYWNlKGxhYmVsKTtcclxuICAgICAgICBpZiAodmFsID09PSBsYWJlbCkge1xyXG4gICAgICAgICAgICB2YWwgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGVtcGxhdGVTdWdzLnB1c2goe1xyXG4gICAgICAgICAgICBsYWJlbDogbGFiZWwsXHJcbiAgICAgICAgICAgIGtpbmQ6IHVpLkNvZGVFZGl0b3JTdWdnZXN0aW9uSXRlbUtpbmQuVGV4dCxcclxuICAgICAgICAgICAgZGV0YWlsOiBcIihUZW1wbGF0ZSBWYXJpYWJsZSkgXCIgKyB2YWwsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzdWdzLmNvbmNhdCh0ZW1wbGF0ZVN1Z3MpO1xyXG59O1xuXG5leHBvcnRzLkNvbmZpZ1NlbGVjdCA9IENvbmZpZ1NlbGVjdDtcbmV4cG9ydHMuQ29ubmVjdGlvbkNvbmZpZyA9IENvbm5lY3Rpb25Db25maWc7XG5leHBvcnRzLkZpbGxWYWx1ZVNlbGVjdCA9IEZpbGxWYWx1ZVNlbGVjdDtcbmV4cG9ydHMuRm9ybWF0U2VsZWN0ID0gRm9ybWF0U2VsZWN0O1xuZXhwb3J0cy5JbmxpbmVJbnB1dCA9IElubGluZUlucHV0O1xuZXhwb3J0cy5RdWVyeUNvZGVFZGl0b3IgPSBRdWVyeUNvZGVFZGl0b3I7XG5leHBvcnRzLlJlc291cmNlU2VsZWN0b3IgPSBSZXNvdXJjZVNlbGVjdG9yO1xuZXhwb3J0cy5TSUdWNENvbm5lY3Rpb25Db25maWcgPSBTSUdWNENvbm5lY3Rpb25Db25maWc7XG5leHBvcnRzLmFwcGVuZFRlbXBsYXRlVmFyaWFibGVzQXNTdWdnZXN0aW9ucyA9IGFwcGVuZFRlbXBsYXRlVmFyaWFibGVzQXNTdWdnZXN0aW9ucztcbmV4cG9ydHMuYXBwbHlTUUxUZW1wbGF0ZVZhcmlhYmxlcyA9IGFwcGx5U1FMVGVtcGxhdGVWYXJpYWJsZXM7XG5leHBvcnRzLmF3c0F1dGhQcm92aWRlck9wdGlvbnMgPSBhd3NBdXRoUHJvdmlkZXJPcHRpb25zO1xuZXhwb3J0cy5maWx0ZXJTUUxRdWVyeSA9IGZpbHRlclNRTFF1ZXJ5O1xuZXhwb3J0cy5zdGFuZGFyZFJlZ2lvbnMgPSBzdGFuZGFyZFJlZ2lvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5kZXZlbG9wbWVudC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvaW5kZXgucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvaW5kZXguZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsImNvbnN0IHBlcmYgPVxuICB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmXG4gIHBlcmZvcm1hbmNlICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbidcbiAgICA/IHBlcmZvcm1hbmNlXG4gICAgOiBEYXRlXG5cbmNvbnN0IGhhc0Fib3J0Q29udHJvbGxlciA9IHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgPT09ICdmdW5jdGlvbidcblxuLy8gbWluaW1hbCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBwb2x5ZmlsbFxuLy8gdGhpcyBkb2Vzbid0IGhhdmUgbmVhcmx5IGFsbCB0aGUgY2hlY2tzIGFuZCB3aGF0bm90IHRoYXRcbi8vIGFjdHVhbCBBYm9ydENvbnRyb2xsZXIvU2lnbmFsIGhhcywgYnV0IGl0J3MgZW5vdWdoIGZvclxuLy8gb3VyIHB1cnBvc2VzLCBhbmQgaWYgdXNlZCBwcm9wZXJseSwgYmVoYXZlcyB0aGUgc2FtZS5cbmNvbnN0IEFDID0gaGFzQWJvcnRDb250cm9sbGVyXG4gID8gQWJvcnRDb250cm9sbGVyXG4gIDogY2xhc3MgQWJvcnRDb250cm9sbGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNpZ25hbCA9IG5ldyBBUygpXG4gICAgICB9XG4gICAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5zaWduYWwuZGlzcGF0Y2hFdmVudCgnYWJvcnQnKVxuICAgICAgfVxuICAgIH1cblxuY29uc3QgQVMgPSBoYXNBYm9ydENvbnRyb2xsZXJcbiAgPyBBYm9ydFNpZ25hbFxuICA6IGNsYXNzIEFib3J0U2lnbmFsIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZVxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXVxuICAgICAgfVxuICAgICAgZGlzcGF0Y2hFdmVudCh0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnYWJvcnQnKSB7XG4gICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuICAgICAgICAgIGNvbnN0IGUgPSB7IHR5cGUsIHRhcmdldDogdGhpcyB9XG4gICAgICAgICAgdGhpcy5vbmFib3J0KGUpXG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZiA9PiBmKGUpLCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbmFib3J0KCkge31cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZXYsIGZuKSB7XG4gICAgICAgIGlmIChldiA9PT0gJ2Fib3J0Jykge1xuICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGZuKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKGV2LCBmbikge1xuICAgICAgICBpZiAoZXYgPT09ICdhYm9ydCcpIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZmlsdGVyKGYgPT4gZiAhPT0gZm4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbmNvbnN0IHdhcm5lZCA9IG5ldyBTZXQoKVxuY29uc3QgZGVwcmVjYXRlZE9wdGlvbiA9IChvcHQsIGluc3RlYWQpID0+IHtcbiAgY29uc3QgY29kZSA9IGBMUlVfQ0FDSEVfT1BUSU9OXyR7b3B0fWBcbiAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICB3YXJuKGNvZGUsIGAke29wdH0gb3B0aW9uYCwgYG9wdGlvbnMuJHtpbnN0ZWFkfWAsIExSVUNhY2hlKVxuICB9XG59XG5jb25zdCBkZXByZWNhdGVkTWV0aG9kID0gKG1ldGhvZCwgaW5zdGVhZCkgPT4ge1xuICBjb25zdCBjb2RlID0gYExSVV9DQUNIRV9NRVRIT0RfJHttZXRob2R9YFxuICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgIGNvbnN0IHsgcHJvdG90eXBlIH0gPSBMUlVDYWNoZVxuICAgIGNvbnN0IHsgZ2V0IH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgbWV0aG9kKVxuICAgIHdhcm4oY29kZSwgYCR7bWV0aG9kfSBtZXRob2RgLCBgY2FjaGUuJHtpbnN0ZWFkfSgpYCwgZ2V0KVxuICB9XG59XG5jb25zdCBkZXByZWNhdGVkUHJvcGVydHkgPSAoZmllbGQsIGluc3RlYWQpID0+IHtcbiAgY29uc3QgY29kZSA9IGBMUlVfQ0FDSEVfUFJPUEVSVFlfJHtmaWVsZH1gXG4gIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgY29uc3QgeyBwcm90b3R5cGUgfSA9IExSVUNhY2hlXG4gICAgY29uc3QgeyBnZXQgfSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBmaWVsZClcbiAgICB3YXJuKGNvZGUsIGAke2ZpZWxkfSBwcm9wZXJ0eWAsIGBjYWNoZS4ke2luc3RlYWR9YCwgZ2V0KVxuICB9XG59XG5cbmNvbnN0IGVtaXRXYXJuaW5nID0gKC4uLmEpID0+IHtcbiAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gIHByb2Nlc3MgJiZcbiAgdHlwZW9mIHByb2Nlc3MuZW1pdFdhcm5pbmcgPT09ICdmdW5jdGlvbidcbiAgICA/IHByb2Nlc3MuZW1pdFdhcm5pbmcoLi4uYSlcbiAgICA6IGNvbnNvbGUuZXJyb3IoLi4uYSlcbn1cblxuY29uc3Qgc2hvdWxkV2FybiA9IGNvZGUgPT4gIXdhcm5lZC5oYXMoY29kZSlcblxuY29uc3Qgd2FybiA9IChjb2RlLCB3aGF0LCBpbnN0ZWFkLCBmbikgPT4ge1xuICB3YXJuZWQuYWRkKGNvZGUpXG4gIGNvbnN0IG1zZyA9IGBUaGUgJHt3aGF0fSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICR7aW5zdGVhZH0gaW5zdGVhZC5gXG4gIGVtaXRXYXJuaW5nKG1zZywgJ0RlcHJlY2F0aW9uV2FybmluZycsIGNvZGUsIGZuKVxufVxuXG5jb25zdCBpc1Bvc0ludCA9IG4gPT4gbiAmJiBuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPiAwICYmIGlzRmluaXRlKG4pXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gVGhpcyBpcyBhIGxpdHRsZSBiaXQgcmlkaWN1bG91cywgdGJoLlxuICogVGhlIG1heGltdW0gYXJyYXkgbGVuZ3RoIGlzIDJeMzItMSBvciB0aGVyZWFib3V0cyBvbiBtb3N0IEpTIGltcGxzLlxuICogQW5kIHdlbGwgYmVmb3JlIHRoYXQgcG9pbnQsIHlvdSdyZSBjYWNoaW5nIHRoZSBlbnRpcmUgd29ybGQsIEkgbWVhbixcbiAqIHRoYXQncyB+MzJHQiBvZiBqdXN0IGludGVnZXJzIGZvciB0aGUgbmV4dC9wcmV2IGxpbmtzLCBwbHVzIHdoYXRldmVyXG4gKiBlbHNlIHRvIGhvbGQgdGhhdCBtYW55IGtleXMgYW5kIHZhbHVlcy4gIEp1c3QgZmlsbGluZyB0aGUgbWVtb3J5IHdpdGhcbiAqIHplcm9lcyBhdCBpbml0IHRpbWUgaXMgYnJ1dGFsIHdoZW4geW91IGdldCB0aGF0IGJpZy5cbiAqIEJ1dCB3aHkgbm90IGJlIGNvbXBsZXRlP1xuICogTWF5YmUgaW4gdGhlIGZ1dHVyZSwgdGhlc2UgbGltaXRzIHdpbGwgaGF2ZSBleHBhbmRlZC4gKi9cbmNvbnN0IGdldFVpbnRBcnJheSA9IG1heCA9PlxuICAhaXNQb3NJbnQobWF4KVxuICAgID8gbnVsbFxuICAgIDogbWF4IDw9IE1hdGgucG93KDIsIDgpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBtYXggPD0gTWF0aC5wb3coMiwgMTYpXG4gICAgPyBVaW50MTZBcnJheVxuICAgIDogbWF4IDw9IE1hdGgucG93KDIsIDMyKVxuICAgID8gVWludDMyQXJyYXlcbiAgICA6IG1heCA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgID8gWmVyb0FycmF5XG4gICAgOiBudWxsXG5cbmNsYXNzIFplcm9BcnJheSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgIHN1cGVyKHNpemUpXG4gICAgdGhpcy5maWxsKDApXG4gIH1cbn1cblxuY2xhc3MgU3RhY2sge1xuICBjb25zdHJ1Y3RvcihtYXgpIHtcbiAgICBpZiAobWF4ID09PSAwKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgY29uc3QgVWludEFycmF5ID0gZ2V0VWludEFycmF5KG1heClcbiAgICB0aGlzLmhlYXAgPSBuZXcgVWludEFycmF5KG1heClcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgfVxuICBwdXNoKG4pIHtcbiAgICB0aGlzLmhlYXBbdGhpcy5sZW5ndGgrK10gPSBuXG4gIH1cbiAgcG9wKCkge1xuICAgIHJldHVybiB0aGlzLmhlYXBbLS10aGlzLmxlbmd0aF1cbiAgfVxufVxuXG5jbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1heCA9IDAsXG4gICAgICB0dGwsXG4gICAgICB0dGxSZXNvbHV0aW9uID0gMSxcbiAgICAgIHR0bEF1dG9wdXJnZSxcbiAgICAgIHVwZGF0ZUFnZU9uR2V0LFxuICAgICAgdXBkYXRlQWdlT25IYXMsXG4gICAgICBhbGxvd1N0YWxlLFxuICAgICAgZGlzcG9zZSxcbiAgICAgIGRpc3Bvc2VBZnRlcixcbiAgICAgIG5vRGlzcG9zZU9uU2V0LFxuICAgICAgbm9VcGRhdGVUVEwsXG4gICAgICBtYXhTaXplID0gMCxcbiAgICAgIHNpemVDYWxjdWxhdGlvbixcbiAgICAgIGZldGNoTWV0aG9kLFxuICAgICAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLFxuICAgIH0gPSBvcHRpb25zXG5cbiAgICAvLyBkZXByZWNhdGVkIG9wdGlvbnMsIGRvbid0IHRyaWdnZXIgYSB3YXJuaW5nIGZvciBnZXR0aW5nIHRoZW0gaWZcbiAgICAvLyB0aGUgdGhpbmcgYmVpbmcgcGFzc2VkIGluIGlzIGFub3RoZXIgTFJVQ2FjaGUgd2UncmUgY29weWluZy5cbiAgICBjb25zdCB7IGxlbmd0aCwgbWF4QWdlLCBzdGFsZSB9ID1cbiAgICAgIG9wdGlvbnMgaW5zdGFuY2VvZiBMUlVDYWNoZSA/IHt9IDogb3B0aW9uc1xuXG4gICAgaWYgKG1heCAhPT0gMCAmJiAhaXNQb3NJbnQobWF4KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG9wdGlvbiBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlcicpXG4gICAgfVxuXG4gICAgY29uc3QgVWludEFycmF5ID0gbWF4ID8gZ2V0VWludEFycmF5KG1heCkgOiBBcnJheVxuICAgIGlmICghVWludEFycmF5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWF4IHZhbHVlOiAnICsgbWF4KVxuICAgIH1cblxuICAgIHRoaXMubWF4ID0gbWF4XG4gICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZVxuICAgIHRoaXMuc2l6ZUNhbGN1bGF0aW9uID0gc2l6ZUNhbGN1bGF0aW9uIHx8IGxlbmd0aFxuICAgIGlmICh0aGlzLnNpemVDYWxjdWxhdGlvbikge1xuICAgICAgaWYgKCF0aGlzLm1heFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnY2Fubm90IHNldCBzaXplQ2FsY3VsYXRpb24gd2l0aG91dCBzZXR0aW5nIG1heFNpemUnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zaXplQ2FsY3VsYXRpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIHNldCB0byBub24tZnVuY3Rpb24nKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZmV0Y2hNZXRob2QgPSBmZXRjaE1ldGhvZCB8fCBudWxsXG4gICAgaWYgKHRoaXMuZmV0Y2hNZXRob2QgJiYgdHlwZW9mIHRoaXMuZmV0Y2hNZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdmZXRjaE1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgc3BlY2lmaWVkJ1xuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpXG4gICAgdGhpcy5rZXlMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbChudWxsKVxuICAgIHRoaXMudmFsTGlzdCA9IG5ldyBBcnJheShtYXgpLmZpbGwobnVsbClcbiAgICB0aGlzLm5leHQgPSBuZXcgVWludEFycmF5KG1heClcbiAgICB0aGlzLnByZXYgPSBuZXcgVWludEFycmF5KG1heClcbiAgICB0aGlzLmhlYWQgPSAwXG4gICAgdGhpcy50YWlsID0gMFxuICAgIHRoaXMuZnJlZSA9IG5ldyBTdGFjayhtYXgpXG4gICAgdGhpcy5pbml0aWFsRmlsbCA9IDFcbiAgICB0aGlzLnNpemUgPSAwXG5cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSA9IGRpc3Bvc2VcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlQWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuZGlzcG9zZUFmdGVyID0gZGlzcG9zZUFmdGVyXG4gICAgICB0aGlzLmRpc3Bvc2VkID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIgPSBudWxsXG4gICAgICB0aGlzLmRpc3Bvc2VkID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLm5vRGlzcG9zZU9uU2V0ID0gISFub0Rpc3Bvc2VPblNldFxuICAgIHRoaXMubm9VcGRhdGVUVEwgPSAhIW5vVXBkYXRlVFRMXG4gICAgdGhpcy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gPSAhIW5vRGVsZXRlT25GZXRjaFJlamVjdGlvblxuXG4gICAgaWYgKHRoaXMubWF4U2l6ZSAhPT0gMCkge1xuICAgICAgaWYgKCFpc1Bvc0ludCh0aGlzLm1heFNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ21heFNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgICB0aGlzLmluaXRpYWxpemVTaXplVHJhY2tpbmcoKVxuICAgIH1cblxuICAgIHRoaXMuYWxsb3dTdGFsZSA9ICEhYWxsb3dTdGFsZSB8fCAhIXN0YWxlXG4gICAgdGhpcy51cGRhdGVBZ2VPbkdldCA9ICEhdXBkYXRlQWdlT25HZXRcbiAgICB0aGlzLnVwZGF0ZUFnZU9uSGFzID0gISF1cGRhdGVBZ2VPbkhhc1xuICAgIHRoaXMudHRsUmVzb2x1dGlvbiA9XG4gICAgICBpc1Bvc0ludCh0dGxSZXNvbHV0aW9uKSB8fCB0dGxSZXNvbHV0aW9uID09PSAwXG4gICAgICAgID8gdHRsUmVzb2x1dGlvblxuICAgICAgICA6IDFcbiAgICB0aGlzLnR0bEF1dG9wdXJnZSA9ICEhdHRsQXV0b3B1cmdlXG4gICAgdGhpcy50dGwgPSB0dGwgfHwgbWF4QWdlIHx8IDBcbiAgICBpZiAodGhpcy50dGwpIHtcbiAgICAgIGlmICghaXNQb3NJbnQodGhpcy50dGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ3R0bCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVRUTFRyYWNraW5nKClcbiAgICB9XG5cbiAgICAvLyBkbyBub3QgYWxsb3cgY29tcGxldGVseSB1bmJvdW5kZWQgY2FjaGVzXG4gICAgaWYgKHRoaXMubWF4ID09PSAwICYmIHRoaXMudHRsID09PSAwICYmIHRoaXMubWF4U2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0F0IGxlYXN0IG9uZSBvZiBtYXgsIG1heFNpemUsIG9yIHR0bCBpcyByZXF1aXJlZCdcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCF0aGlzLnR0bEF1dG9wdXJnZSAmJiAhdGhpcy5tYXggJiYgIXRoaXMubWF4U2l6ZSkge1xuICAgICAgY29uc3QgY29kZSA9ICdMUlVfQ0FDSEVfVU5CT1VOREVEJ1xuICAgICAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICAgICAgd2FybmVkLmFkZChjb2RlKVxuICAgICAgICBjb25zdCBtc2cgPVxuICAgICAgICAgICdUVEwgY2FjaGluZyB3aXRob3V0IHR0bEF1dG9wdXJnZSwgbWF4LCBvciBtYXhTaXplIGNhbiAnICtcbiAgICAgICAgICAncmVzdWx0IGluIHVuYm91bmRlZCBtZW1vcnkgY29uc3VtcHRpb24uJ1xuICAgICAgICBlbWl0V2FybmluZyhtc2csICdVbmJvdW5kZWRDYWNoZVdhcm5pbmcnLCBjb2RlLCBMUlVDYWNoZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhbGUpIHtcbiAgICAgIGRlcHJlY2F0ZWRPcHRpb24oJ3N0YWxlJywgJ2FsbG93U3RhbGUnKVxuICAgIH1cbiAgICBpZiAobWF4QWdlKSB7XG4gICAgICBkZXByZWNhdGVkT3B0aW9uKCdtYXhBZ2UnLCAndHRsJylcbiAgICB9XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgZGVwcmVjYXRlZE9wdGlvbignbGVuZ3RoJywgJ3NpemVDYWxjdWxhdGlvbicpXG4gICAgfVxuICB9XG5cbiAgZ2V0UmVtYWluaW5nVFRMKGtleSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhrZXksIHsgdXBkYXRlQWdlT25IYXM6IGZhbHNlIH0pID8gSW5maW5pdHkgOiAwXG4gIH1cblxuICBpbml0aWFsaXplVFRMVHJhY2tpbmcoKSB7XG4gICAgdGhpcy50dGxzID0gbmV3IFplcm9BcnJheSh0aGlzLm1heClcbiAgICB0aGlzLnN0YXJ0cyA9IG5ldyBaZXJvQXJyYXkodGhpcy5tYXgpXG5cbiAgICB0aGlzLnNldEl0ZW1UVEwgPSAoaW5kZXgsIHR0bCkgPT4ge1xuICAgICAgdGhpcy5zdGFydHNbaW5kZXhdID0gdHRsICE9PSAwID8gcGVyZi5ub3coKSA6IDBcbiAgICAgIHRoaXMudHRsc1tpbmRleF0gPSB0dGxcbiAgICAgIGlmICh0dGwgIT09IDAgJiYgdGhpcy50dGxBdXRvcHVyZ2UpIHtcbiAgICAgICAgY29uc3QgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZSh0aGlzLmtleUxpc3RbaW5kZXhdKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdHRsICsgMSlcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSB1bnJlZigpIG5vdCBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcyAqL1xuICAgICAgICBpZiAodC51bnJlZikge1xuICAgICAgICAgIHQudW5yZWYoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVJdGVtQWdlID0gaW5kZXggPT4ge1xuICAgICAgdGhpcy5zdGFydHNbaW5kZXhdID0gdGhpcy50dGxzW2luZGV4XSAhPT0gMCA/IHBlcmYubm93KCkgOiAwXG4gICAgfVxuXG4gICAgLy8gZGVib3VuY2UgY2FsbHMgdG8gcGVyZi5ub3coKSB0byAxcyBzbyB3ZSdyZSBub3QgaGl0dGluZ1xuICAgIC8vIHRoYXQgY29zdGx5IGNhbGwgcmVwZWF0ZWRseS5cbiAgICBsZXQgY2FjaGVkTm93ID0gMFxuICAgIGNvbnN0IGdldE5vdyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBwZXJmLm5vdygpXG4gICAgICBpZiAodGhpcy50dGxSZXNvbHV0aW9uID4gMCkge1xuICAgICAgICBjYWNoZWROb3cgPSBuXG4gICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICgpID0+IChjYWNoZWROb3cgPSAwKSxcbiAgICAgICAgICB0aGlzLnR0bFJlc29sdXRpb25cbiAgICAgICAgKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIG5vdCBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3JtcyAqL1xuICAgICAgICBpZiAodC51bnJlZikge1xuICAgICAgICAgIHQudW5yZWYoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gblxuICAgIH1cblxuICAgIHRoaXMuZ2V0UmVtYWluaW5nVFRMID0ga2V5ID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGtleSlcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50dGxzW2luZGV4XSA9PT0gMCB8fCB0aGlzLnN0YXJ0c1tpbmRleF0gPT09IDBcbiAgICAgICAgPyBJbmZpbml0eVxuICAgICAgICA6IHRoaXMuc3RhcnRzW2luZGV4XSArXG4gICAgICAgICAgICB0aGlzLnR0bHNbaW5kZXhdIC1cbiAgICAgICAgICAgIChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpXG4gICAgfVxuXG4gICAgdGhpcy5pc1N0YWxlID0gaW5kZXggPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy50dGxzW2luZGV4XSAhPT0gMCAmJlxuICAgICAgICB0aGlzLnN0YXJ0c1tpbmRleF0gIT09IDAgJiZcbiAgICAgICAgKGNhY2hlZE5vdyB8fCBnZXROb3coKSkgLSB0aGlzLnN0YXJ0c1tpbmRleF0gPlxuICAgICAgICAgIHRoaXMudHRsc1tpbmRleF1cbiAgICAgIClcbiAgICB9XG4gIH1cbiAgdXBkYXRlSXRlbUFnZShpbmRleCkge31cbiAgc2V0SXRlbVRUTChpbmRleCwgdHRsKSB7fVxuICBpc1N0YWxlKGluZGV4KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpbml0aWFsaXplU2l6ZVRyYWNraW5nKCkge1xuICAgIHRoaXMuY2FsY3VsYXRlZFNpemUgPSAwXG4gICAgdGhpcy5zaXplcyA9IG5ldyBaZXJvQXJyYXkodGhpcy5tYXgpXG4gICAgdGhpcy5yZW1vdmVJdGVtU2l6ZSA9IGluZGV4ID0+XG4gICAgICAodGhpcy5jYWxjdWxhdGVkU2l6ZSAtPSB0aGlzLnNpemVzW2luZGV4XSlcbiAgICB0aGlzLnJlcXVpcmVTaXplID0gKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbikgPT4ge1xuICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICBpZiAoc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzaXplQ2FsY3VsYXRpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgICAgICAgIH1cbiAgICAgICAgICBzaXplID0gc2l6ZUNhbGN1bGF0aW9uKHYsIGspXG4gICAgICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgJ3NpemVDYWxjdWxhdGlvbiByZXR1cm4gaW52YWxpZCAoZXhwZWN0IHBvc2l0aXZlIGludGVnZXIpJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ2ludmFsaWQgc2l6ZSB2YWx1ZSAobXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyKSdcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzaXplXG4gICAgfVxuICAgIHRoaXMuYWRkSXRlbVNpemUgPSAoaW5kZXgsIHYsIGssIHNpemUpID0+IHtcbiAgICAgIHRoaXMuc2l6ZXNbaW5kZXhdID0gc2l6ZVxuICAgICAgY29uc3QgbWF4U2l6ZSA9IHRoaXMubWF4U2l6ZSAtIHRoaXMuc2l6ZXNbaW5kZXhdXG4gICAgICB3aGlsZSAodGhpcy5jYWxjdWxhdGVkU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgdGhpcy5ldmljdCh0cnVlKVxuICAgICAgfVxuICAgICAgdGhpcy5jYWxjdWxhdGVkU2l6ZSArPSB0aGlzLnNpemVzW2luZGV4XVxuICAgIH1cbiAgfVxuICByZW1vdmVJdGVtU2l6ZShpbmRleCkge31cbiAgYWRkSXRlbVNpemUoaW5kZXgsIHYsIGssIHNpemUpIHt9XG4gIHJlcXVpcmVTaXplKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbikge1xuICAgIGlmIChzaXplIHx8IHNpemVDYWxjdWxhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ2Nhbm5vdCBzZXQgc2l6ZSB3aXRob3V0IHNldHRpbmcgbWF4U2l6ZSBvbiBjYWNoZSdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAqaW5kZXhlcyh7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMudGFpbDsgdHJ1ZTsgKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd1N0YWxlIHx8ICF0aGlzLmlzU3RhbGUoaSkpIHtcbiAgICAgICAgICB5aWVsZCBpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IHRoaXMuaGVhZCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSA9IHRoaXMucHJldltpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgKnJpbmRleGVzKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFkOyB0cnVlOyApIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93U3RhbGUgfHwgIXRoaXMuaXNTdGFsZShpKSkge1xuICAgICAgICAgIHlpZWxkIGlcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gdGhpcy50YWlsKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0gdGhpcy5uZXh0W2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc1ZhbGlkSW5kZXgoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KHRoaXMua2V5TGlzdFtpbmRleF0pID09PSBpbmRleFxuICB9XG5cbiAgKmVudHJpZXMoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCBbdGhpcy5rZXlMaXN0W2ldLCB0aGlzLnZhbExpc3RbaV1dXG4gICAgfVxuICB9XG4gICpyZW50cmllcygpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5yaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCBbdGhpcy5rZXlMaXN0W2ldLCB0aGlzLnZhbExpc3RbaV1dXG4gICAgfVxuICB9XG5cbiAgKmtleXMoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCB0aGlzLmtleUxpc3RbaV1cbiAgICB9XG4gIH1cbiAgKnJrZXlzKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKCkpIHtcbiAgICAgIHlpZWxkIHRoaXMua2V5TGlzdFtpXVxuICAgIH1cbiAgfVxuXG4gICp2YWx1ZXMoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCB0aGlzLnZhbExpc3RbaV1cbiAgICB9XG4gIH1cbiAgKnJ2YWx1ZXMoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgdGhpcy52YWxMaXN0W2ldXG4gICAgfVxuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpXG4gIH1cblxuICBmaW5kKGZuLCBnZXRPcHRpb25zID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIGlmIChmbih0aGlzLnZhbExpc3RbaV0sIHRoaXMua2V5TGlzdFtpXSwgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMua2V5TGlzdFtpXSwgZ2V0T3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3JFYWNoKGZuLCB0aGlzcCA9IHRoaXMpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIGZuLmNhbGwodGhpc3AsIHRoaXMudmFsTGlzdFtpXSwgdGhpcy5rZXlMaXN0W2ldLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHJmb3JFYWNoKGZuLCB0aGlzcCA9IHRoaXMpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5yaW5kZXhlcygpKSB7XG4gICAgICBmbi5jYWxsKHRoaXNwLCB0aGlzLnZhbExpc3RbaV0sIHRoaXMua2V5TGlzdFtpXSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBnZXQgcHJ1bmUoKSB7XG4gICAgZGVwcmVjYXRlZE1ldGhvZCgncHJ1bmUnLCAncHVyZ2VTdGFsZScpXG4gICAgcmV0dXJuIHRoaXMucHVyZ2VTdGFsZVxuICB9XG5cbiAgcHVyZ2VTdGFsZSgpIHtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlXG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICBpZiAodGhpcy5pc1N0YWxlKGkpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlKHRoaXMua2V5TGlzdFtpXSlcbiAgICAgICAgZGVsZXRlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlbGV0ZWRcbiAgfVxuXG4gIGR1bXAoKSB7XG4gICAgY29uc3QgYXJyID0gW11cbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5TGlzdFtpXVxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbExpc3RbaV1cbiAgICAgIGNvbnN0IGVudHJ5ID0geyB2YWx1ZSB9XG4gICAgICBpZiAodGhpcy50dGxzKSB7XG4gICAgICAgIGVudHJ5LnR0bCA9IHRoaXMudHRsc1tpXVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2l6ZXMpIHtcbiAgICAgICAgZW50cnkuc2l6ZSA9IHRoaXMuc2l6ZXNbaV1cbiAgICAgIH1cbiAgICAgIGFyci51bnNoaWZ0KFtrZXksIGVudHJ5XSlcbiAgICB9XG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgbG9hZChhcnIpIHtcbiAgICB0aGlzLmNsZWFyKClcbiAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiBhcnIpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZW50cnkudmFsdWUsIGVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UodiwgaywgcmVhc29uKSB7fVxuXG4gIHNldChcbiAgICBrLFxuICAgIHYsXG4gICAge1xuICAgICAgdHRsID0gdGhpcy50dGwsXG4gICAgICBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsXG4gICAgICBzaXplID0gMCxcbiAgICAgIHNpemVDYWxjdWxhdGlvbiA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLFxuICAgICAgbm9VcGRhdGVUVEwgPSB0aGlzLm5vVXBkYXRlVFRMLFxuICAgIH0gPSB7fVxuICApIHtcbiAgICBzaXplID0gdGhpcy5yZXF1aXJlU2l6ZShrLCB2LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pXG4gICAgbGV0IGluZGV4ID0gdGhpcy5zaXplID09PSAwID8gdW5kZWZpbmVkIDogdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGFkZGl0aW9uXG4gICAgICBpbmRleCA9IHRoaXMubmV3SW5kZXgoKVxuICAgICAgdGhpcy5rZXlMaXN0W2luZGV4XSA9IGtcbiAgICAgIHRoaXMudmFsTGlzdFtpbmRleF0gPSB2XG4gICAgICB0aGlzLmtleU1hcC5zZXQoaywgaW5kZXgpXG4gICAgICB0aGlzLm5leHRbdGhpcy50YWlsXSA9IGluZGV4XG4gICAgICB0aGlzLnByZXZbaW5kZXhdID0gdGhpcy50YWlsXG4gICAgICB0aGlzLnRhaWwgPSBpbmRleFxuICAgICAgdGhpcy5zaXplKytcbiAgICAgIHRoaXMuYWRkSXRlbVNpemUoaW5kZXgsIHYsIGssIHNpemUpXG4gICAgICBub1VwZGF0ZVRUTCA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZVxuICAgICAgY29uc3Qgb2xkVmFsID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgaWYgKHYgIT09IG9sZFZhbCkge1xuICAgICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaChvbGRWYWwpKSB7XG4gICAgICAgICAgb2xkVmFsLl9fYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW5vRGlzcG9zZU9uU2V0KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2Uob2xkVmFsLCBrLCAnc2V0JylcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW29sZFZhbCwgaywgJ3NldCddKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUl0ZW1TaXplKGluZGV4KVxuICAgICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gdlxuICAgICAgICB0aGlzLmFkZEl0ZW1TaXplKGluZGV4LCB2LCBrLCBzaXplKVxuICAgICAgfVxuICAgICAgdGhpcy5tb3ZlVG9UYWlsKGluZGV4KVxuICAgIH1cbiAgICBpZiAodHRsICE9PSAwICYmIHRoaXMudHRsID09PSAwICYmICF0aGlzLnR0bHMpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVRUTFRyYWNraW5nKClcbiAgICB9XG4gICAgaWYgKCFub1VwZGF0ZVRUTCkge1xuICAgICAgdGhpcy5zZXRJdGVtVFRMKGluZGV4LCB0dGwpXG4gICAgfVxuICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgd2hpbGUgKHRoaXMuZGlzcG9zZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFmdGVyKC4uLnRoaXMuZGlzcG9zZWQuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG5ld0luZGV4KCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnRhaWxcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5tYXggJiYgdGhpcy5tYXggIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmV2aWN0KGZhbHNlKVxuICAgIH1cbiAgICBpZiAodGhpcy5mcmVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJlZS5wb3AoKVxuICAgIH1cbiAgICAvLyBpbml0aWFsIGZpbGwsIGp1c3Qga2VlcCB3cml0aW5nIGRvd24gdGhlIGxpc3RcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsRmlsbCsrXG4gIH1cblxuICBwb3AoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy52YWxMaXN0W3RoaXMuaGVhZF1cbiAgICAgIHRoaXMuZXZpY3QodHJ1ZSlcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gIH1cblxuICBldmljdChmcmVlKSB7XG4gICAgY29uc3QgaGVhZCA9IHRoaXMuaGVhZFxuICAgIGNvbnN0IGsgPSB0aGlzLmtleUxpc3RbaGVhZF1cbiAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2hlYWRdXG4gICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3Bvc2UodiwgaywgJ2V2aWN0JylcbiAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW3YsIGssICdldmljdCddKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbW92ZUl0ZW1TaXplKGhlYWQpXG4gICAgLy8gaWYgd2UgYXJlbid0IGFib3V0IHRvIHVzZSB0aGUgaW5kZXgsIHRoZW4gbnVsbCB0aGVzZSBvdXRcbiAgICBpZiAoZnJlZSkge1xuICAgICAgdGhpcy5rZXlMaXN0W2hlYWRdID0gbnVsbFxuICAgICAgdGhpcy52YWxMaXN0W2hlYWRdID0gbnVsbFxuICAgICAgdGhpcy5mcmVlLnB1c2goaGVhZClcbiAgICB9XG4gICAgdGhpcy5oZWFkID0gdGhpcy5uZXh0W2hlYWRdXG4gICAgdGhpcy5rZXlNYXAuZGVsZXRlKGspXG4gICAgdGhpcy5zaXplLS1cbiAgICByZXR1cm4gaGVhZFxuICB9XG5cbiAgaGFzKGssIHsgdXBkYXRlQWdlT25IYXMgPSB0aGlzLnVwZGF0ZUFnZU9uSGFzIH0gPSB7fSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghdGhpcy5pc1N0YWxlKGluZGV4KSkge1xuICAgICAgICBpZiAodXBkYXRlQWdlT25IYXMpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1BZ2UoaW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBsaWtlIGdldCgpLCBidXQgd2l0aG91dCBhbnkgTFJVIHVwZGF0aW5nIG9yIFRUTCBleHBpcmF0aW9uXG4gIHBlZWsoaywgeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgKGFsbG93U3RhbGUgfHwgIXRoaXMuaXNTdGFsZShpbmRleCkpKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgIH1cbiAgfVxuXG4gIGJhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHYgPSBpbmRleCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdGhpcy52YWxMaXN0W2luZGV4XVxuICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICByZXR1cm4gdlxuICAgIH1cbiAgICBjb25zdCBhYyA9IG5ldyBBQygpXG4gICAgY29uc3QgZmV0Y2hPcHRzID0ge1xuICAgICAgc2lnbmFsOiBhYy5zaWduYWwsXG4gICAgICBvcHRpb25zLFxuICAgIH1cbiAgICBjb25zdCBjYiA9IHYgPT4ge1xuICAgICAgaWYgKCFhYy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB0aGlzLnNldChrLCB2LCBmZXRjaE9wdHMub3B0aW9ucylcbiAgICAgIH1cbiAgICAgIHJldHVybiB2XG4gICAgfVxuICAgIGNvbnN0IGViID0gZXIgPT4ge1xuICAgICAgaWYgKHRoaXMudmFsTGlzdFtpbmRleF0gPT09IHApIHtcbiAgICAgICAgY29uc3QgZGVsID1cbiAgICAgICAgICAhb3B0aW9ucy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gfHxcbiAgICAgICAgICBwLl9fc3RhbGVXaGlsZUZldGNoaW5nID09PSB1bmRlZmluZWRcbiAgICAgICAgaWYgKGRlbCkge1xuICAgICAgICAgIHRoaXMuZGVsZXRlKGspXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc3RpbGwgcmVwbGFjZSB0aGUgKnByb21pc2UqIHdpdGggdGhlIHN0YWxlIHZhbHVlLFxuICAgICAgICAgIC8vIHNpbmNlIHdlIGFyZSBkb25lIHdpdGggdGhlIHByb21pc2UgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gcC5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocC5fX3JldHVybmVkID09PSBwKSB7XG4gICAgICAgIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBjYWxsID0gcmVzID0+IHJlcyh0aGlzLmZldGNoTWV0aG9kKGssIHYsIGZldGNoT3B0cykpXG4gICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKHBjYWxsKS50aGVuKGNiLCBlYilcbiAgICBwLl9fYWJvcnRDb250cm9sbGVyID0gYWNcbiAgICBwLl9fc3RhbGVXaGlsZUZldGNoaW5nID0gdlxuICAgIHAuX19yZXR1cm5lZCA9IG51bGxcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXQoaywgcCwgZmV0Y2hPcHRzLm9wdGlvbnMpXG4gICAgICBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gcFxuICAgIH1cbiAgICByZXR1cm4gcFxuICB9XG5cbiAgaXNCYWNrZ3JvdW5kRmV0Y2gocCkge1xuICAgIHJldHVybiAoXG4gICAgICBwICYmXG4gICAgICB0eXBlb2YgcCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBwLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgICAgcCxcbiAgICAgICAgJ19fc3RhbGVXaGlsZUZldGNoaW5nJ1xuICAgICAgKSAmJlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHAsICdfX3JldHVybmVkJykgJiZcbiAgICAgIChwLl9fcmV0dXJuZWQgPT09IHAgfHwgcC5fX3JldHVybmVkID09PSBudWxsKVxuICAgIClcbiAgfVxuXG4gIC8vIHRoaXMgdGFrZXMgdGhlIHVuaW9uIG9mIGdldCgpIGFuZCBzZXQoKSBvcHRzLCBiZWNhdXNlIGl0IGRvZXMgYm90aFxuICBhc3luYyBmZXRjaChcbiAgICBrLFxuICAgIHtcbiAgICAgIC8vIGdldCBvcHRpb25zXG4gICAgICBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLFxuICAgICAgdXBkYXRlQWdlT25HZXQgPSB0aGlzLnVwZGF0ZUFnZU9uR2V0LFxuICAgICAgLy8gc2V0IG9wdGlvbnNcbiAgICAgIHR0bCA9IHRoaXMudHRsLFxuICAgICAgbm9EaXNwb3NlT25TZXQgPSB0aGlzLm5vRGlzcG9zZU9uU2V0LFxuICAgICAgc2l6ZSA9IDAsXG4gICAgICBzaXplQ2FsY3VsYXRpb24gPSB0aGlzLnNpemVDYWxjdWxhdGlvbixcbiAgICAgIG5vVXBkYXRlVFRMID0gdGhpcy5ub1VwZGF0ZVRUTCxcbiAgICAgIC8vIGZldGNoIGV4Y2x1c2l2ZSBvcHRpb25zXG4gICAgICBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gPSB0aGlzLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbixcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgaWYgKCF0aGlzLmZldGNoTWV0aG9kKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoaywgeyBhbGxvd1N0YWxlLCB1cGRhdGVBZ2VPbkdldCB9KVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBhbGxvd1N0YWxlLFxuICAgICAgdXBkYXRlQWdlT25HZXQsXG4gICAgICB0dGwsXG4gICAgICBub0Rpc3Bvc2VPblNldCxcbiAgICAgIHNpemUsXG4gICAgICBzaXplQ2FsY3VsYXRpb24sXG4gICAgICBub1VwZGF0ZVRUTCxcbiAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbixcbiAgICB9XG5cbiAgICBsZXQgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgcCA9IHRoaXMuYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zKVxuICAgICAgcmV0dXJuIChwLl9fcmV0dXJuZWQgPSBwKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiBjYWNoZSwgbWF5YmUgYWxyZWFkeSBmZXRjaGluZ1xuICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgIHJldHVybiBhbGxvd1N0YWxlICYmIHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgIDogKHYuX19yZXR1cm5lZCA9IHYpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pc1N0YWxlKGluZGV4KSkge1xuICAgICAgICB0aGlzLm1vdmVUb1RhaWwoaW5kZXgpXG4gICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlSXRlbUFnZShpbmRleClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdlxuICAgICAgfVxuXG4gICAgICAvLyBvaywgaXQgaXMgc3RhbGUsIGFuZCBub3QgYWxyZWFkeSBmZXRjaGluZ1xuICAgICAgLy8gcmVmcmVzaCB0aGUgY2FjaGUuXG4gICAgICBjb25zdCBwID0gdGhpcy5iYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMpXG4gICAgICByZXR1cm4gYWxsb3dTdGFsZSAmJiBwLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBwLl9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgIDogKHAuX19yZXR1cm5lZCA9IHApXG4gICAgfVxuICB9XG5cbiAgZ2V0KFxuICAgIGssXG4gICAge1xuICAgICAgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSxcbiAgICAgIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCxcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICBjb25zdCBmZXRjaGluZyA9IHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godmFsdWUpXG4gICAgICBpZiAodGhpcy5pc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAvLyBkZWxldGUgb25seSBpZiBub3QgYW4gaW4tZmxpZ2h0IGJhY2tncm91bmQgZmV0Y2hcbiAgICAgICAgaWYgKCFmZXRjaGluZykge1xuICAgICAgICAgIHRoaXMuZGVsZXRlKGspXG4gICAgICAgICAgcmV0dXJuIGFsbG93U3RhbGUgPyB2YWx1ZSA6IHVuZGVmaW5lZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgd2UncmUgY3VycmVudGx5IGZldGNoaW5nIGl0LCB3ZSBkb24ndCBhY3R1YWxseSBoYXZlIGl0IHlldFxuICAgICAgICAvLyBpdCdzIG5vdCBzdGFsZSwgd2hpY2ggbWVhbnMgdGhpcyBpc24ndCBhIHN0YWxlV2hpbGVSZWZldGNoaW5nLFxuICAgICAgICAvLyBzbyB3ZSBqdXN0IHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYgKGZldGNoaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZVRvVGFpbChpbmRleClcbiAgICAgICAgaWYgKHVwZGF0ZUFnZU9uR2V0KSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVJdGVtQWdlKGluZGV4KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3QocCwgbikge1xuICAgIHRoaXMucHJldltuXSA9IHBcbiAgICB0aGlzLm5leHRbcF0gPSBuXG4gIH1cblxuICBtb3ZlVG9UYWlsKGluZGV4KSB7XG4gICAgLy8gaWYgdGFpbCBhbHJlYWR5LCBub3RoaW5nIHRvIGRvXG4gICAgLy8gaWYgaGVhZCwgbW92ZSBoZWFkIHRvIG5leHRbaW5kZXhdXG4gICAgLy8gZWxzZVxuICAgIC8vICAgbW92ZSBuZXh0W3ByZXZbaW5kZXhdXSB0byBuZXh0W2luZGV4XSAoaGVhZCBoYXMgbm8gcHJldilcbiAgICAvLyAgIG1vdmUgcHJldltuZXh0W2luZGV4XV0gdG8gcHJldltpbmRleF1cbiAgICAvLyBwcmV2W2luZGV4XSA9IHRhaWxcbiAgICAvLyBuZXh0W3RhaWxdID0gaW5kZXhcbiAgICAvLyB0YWlsID0gaW5kZXhcbiAgICBpZiAoaW5kZXggIT09IHRoaXMudGFpbCkge1xuICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5uZXh0W2luZGV4XVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMucHJldltpbmRleF0sIHRoaXMubmV4dFtpbmRleF0pXG4gICAgICB9XG4gICAgICB0aGlzLmNvbm5lY3QodGhpcy50YWlsLCBpbmRleClcbiAgICAgIHRoaXMudGFpbCA9IGluZGV4XG4gICAgfVxuICB9XG5cbiAgZ2V0IGRlbCgpIHtcbiAgICBkZXByZWNhdGVkTWV0aG9kKCdkZWwnLCAnZGVsZXRlJylcbiAgICByZXR1cm4gdGhpcy5kZWxldGVcbiAgfVxuXG4gIGRlbGV0ZShrKSB7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZVxuICAgIGlmICh0aGlzLnNpemUgIT09IDApIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGVkID0gdHJ1ZVxuICAgICAgICBpZiAodGhpcy5zaXplID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5jbGVhcigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVJdGVtU2l6ZShpbmRleClcbiAgICAgICAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKHYsIGssICdkZWxldGUnKVxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlzcG9zZWQucHVzaChbdiwgaywgJ2RlbGV0ZSddKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmtleU1hcC5kZWxldGUoaylcbiAgICAgICAgICB0aGlzLmtleUxpc3RbaW5kZXhdID0gbnVsbFxuICAgICAgICAgIHRoaXMudmFsTGlzdFtpbmRleF0gPSBudWxsXG4gICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMucHJldltpbmRleF1cbiAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMubmV4dFtpbmRleF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0W3RoaXMucHJldltpbmRleF1dID0gdGhpcy5uZXh0W2luZGV4XVxuICAgICAgICAgICAgdGhpcy5wcmV2W3RoaXMubmV4dFtpbmRleF1dID0gdGhpcy5wcmV2W2luZGV4XVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNpemUtLVxuICAgICAgICAgIHRoaXMuZnJlZS5wdXNoKGluZGV4KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICB3aGlsZSAodGhpcy5kaXNwb3NlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIoLi4udGhpcy5kaXNwb3NlZC5zaGlmdCgpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVsZXRlZFxuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiB0aGlzLnJpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgayA9IHRoaXMua2V5TGlzdFtpbmRleF1cbiAgICAgICAgdGhpcy5kaXNwb3NlKHYsIGssICdkZWxldGUnKVxuICAgICAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW3YsIGssICdkZWxldGUnXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMua2V5TWFwLmNsZWFyKClcbiAgICB0aGlzLnZhbExpc3QuZmlsbChudWxsKVxuICAgIHRoaXMua2V5TGlzdC5maWxsKG51bGwpXG4gICAgaWYgKHRoaXMudHRscykge1xuICAgICAgdGhpcy50dGxzLmZpbGwoMClcbiAgICAgIHRoaXMuc3RhcnRzLmZpbGwoMClcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZXMpIHtcbiAgICAgIHRoaXMuc2l6ZXMuZmlsbCgwKVxuICAgIH1cbiAgICB0aGlzLmhlYWQgPSAwXG4gICAgdGhpcy50YWlsID0gMFxuICAgIHRoaXMuaW5pdGlhbEZpbGwgPSAxXG4gICAgdGhpcy5mcmVlLmxlbmd0aCA9IDBcbiAgICB0aGlzLmNhbGN1bGF0ZWRTaXplID0gMFxuICAgIHRoaXMuc2l6ZSA9IDBcbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgd2hpbGUgKHRoaXMuZGlzcG9zZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFmdGVyKC4uLnRoaXMuZGlzcG9zZWQuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgcmVzZXQoKSB7XG4gICAgZGVwcmVjYXRlZE1ldGhvZCgncmVzZXQnLCAnY2xlYXInKVxuICAgIHJldHVybiB0aGlzLmNsZWFyXG4gIH1cblxuICBnZXQgbGVuZ3RoKCkge1xuICAgIGRlcHJlY2F0ZWRQcm9wZXJ0eSgnbGVuZ3RoJywgJ3NpemUnKVxuICAgIHJldHVybiB0aGlzLnNpemVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgQWJvcnRDb250cm9sbGVyKCkge1xuICAgIHJldHVybiBBQ1xuICB9XG4gIHN0YXRpYyBnZXQgQWJvcnRTaWduYWwoKSB7XG4gICAgcmV0dXJuIEFTXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxuIiwiaW1wb3J0IHsgTFJQYXJzZXIgfSBmcm9tICdAbGV6ZXIvbHInO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IFxuICBpbmYgPSAxNDYsXG4gIG5hbiA9IDE0NyxcbiAgQm9vbCA9IDEsXG4gIElnbm9yaW5nID0gMixcbiAgT24gPSAzLFxuICBHcm91cExlZnQgPSA0LFxuICBHcm91cFJpZ2h0ID0gNSxcbiAgT2Zmc2V0ID0gNixcbiAgQXRhbjIgPSA3LFxuICBBdmcgPSA4LFxuICBCb3R0b21rID0gOSxcbiAgQ291bnQgPSAxMCxcbiAgQ291bnRWYWx1ZXMgPSAxMSxcbiAgR3JvdXAgPSAxMixcbiAgTWF4ID0gMTMsXG4gIE1pbiA9IDE0LFxuICBRdWFudGlsZSA9IDE1LFxuICBTdGRkZXYgPSAxNixcbiAgU3RkdmFyID0gMTcsXG4gIFN1bSA9IDE4LFxuICBUb3BrID0gMTksXG4gIEJ5ID0gMjAsXG4gIFdpdGhvdXQgPSAyMSxcbiAgQW5kID0gMjIsXG4gIE9yID0gMjMsXG4gIFVubGVzcyA9IDI0LFxuICBTdGFydCA9IDI1LFxuICBFbmQgPSAyNjtcblxuLy8gQ29weXJpZ2h0IDIwMjEgVGhlIFByb21ldGhldXMgQXV0aG9yc1xuXG5jb25zdCBrZXl3b3JkVG9rZW5zID0ge1xuICAgIGluZjogaW5mLFxuICAgIG5hbjogbmFuLFxuICAgIGJvb2w6IEJvb2wsXG4gICAgaWdub3Jpbmc6IElnbm9yaW5nLFxuICAgIG9uOiBPbixcbiAgICBncm91cF9sZWZ0OiBHcm91cExlZnQsXG4gICAgZ3JvdXBfcmlnaHQ6IEdyb3VwUmlnaHQsXG4gICAgb2Zmc2V0OiBPZmZzZXQsXG59O1xuXG5jb25zdCBzcGVjaWFsaXplSWRlbnRpZmllciA9ICh2YWx1ZSwgc3RhY2spID0+IHtcbiAgICByZXR1cm4ga2V5d29yZFRva2Vuc1t2YWx1ZS50b0xvd2VyQ2FzZSgpXSB8fCAtMTtcbn07XG5cbmNvbnN0IGNvbnRleHR1YWxLZXl3b3JkVG9rZW5zID0ge1xuICAgIGF2ZzogQXZnLFxuICAgIGF0YW4yOiBBdGFuMixcbiAgICBib3R0b21rOiBCb3R0b21rLFxuICAgIGNvdW50OiBDb3VudCxcbiAgICBjb3VudF92YWx1ZXM6IENvdW50VmFsdWVzLFxuICAgIGdyb3VwOiBHcm91cCxcbiAgICBtYXg6IE1heCxcbiAgICBtaW46IE1pbixcbiAgICBxdWFudGlsZTogUXVhbnRpbGUsXG4gICAgc3RkZGV2OiBTdGRkZXYsXG4gICAgc3RkdmFyOiBTdGR2YXIsXG4gICAgc3VtOiBTdW0sXG4gICAgdG9wazogVG9wayxcbiAgICBieTogQnksXG4gICAgd2l0aG91dDogV2l0aG91dCxcbiAgICBhbmQ6IEFuZCxcbiAgICBvcjogT3IsXG4gICAgdW5sZXNzOiBVbmxlc3MsXG4gICAgc3RhcnQ6IFN0YXJ0LFxuICAgIGVuZDogRW5kLFxufTtcblxuY29uc3QgZXh0ZW5kSWRlbnRpZmllciA9ICh2YWx1ZSwgc3RhY2spID0+IHtcbiAgICByZXR1cm4gY29udGV4dHVhbEtleXdvcmRUb2tlbnNbdmFsdWUudG9Mb3dlckNhc2UoKV0gfHwgLTE7XG59O1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNwZWNfSWRlbnRpZmllciA9IHtfX3Byb3RvX186bnVsbCxhYnNlbnRfb3Zlcl90aW1lOjMwNywgYWJzZW50OjMwOSwgYWJzOjMxMSwgYWNvczozMTMsIGFjb3NoOjMxNSwgYXNpbjozMTcsIGFzaW5oOjMxOSwgYXRhbjozMjEsIGF0YW5oOjMyMywgYXZnX292ZXJfdGltZTozMjUsIGNlaWw6MzI3LCBjaGFuZ2VzOjMyOSwgY2xhbXA6MzMxLCBjbGFtcF9tYXg6MzMzLCBjbGFtcF9taW46MzM1LCBjb3M6MzM3LCBjb3NoOjMzOSwgY291bnRfb3Zlcl90aW1lOjM0MSwgZGF5c19pbl9tb250aDozNDMsIGRheV9vZl9tb250aDozNDUsIGRheV9vZl93ZWVrOjM0NywgZGVnOjM0OSwgZGVsdGE6MzUxLCBkZXJpdjozNTMsIGV4cDozNTUsIGZsb29yOjM1NywgaGlzdG9ncmFtX3F1YW50aWxlOjM1OSwgaG9sdF93aW50ZXJzOjM2MSwgaG91cjozNjMsIGlkZWx0YTozNjUsIGluY3JlYXNlOjM2NywgaXJhdGU6MzY5LCBsYWJlbF9yZXBsYWNlOjM3MSwgbGFiZWxfam9pbjozNzMsIGxhc3Rfb3Zlcl90aW1lOjM3NSwgbG46Mzc3LCBsb2cxMDozNzksIGxvZzI6MzgxLCBtYXhfb3Zlcl90aW1lOjM4MywgbWluX292ZXJfdGltZTozODUsIG1pbnV0ZTozODcsIG1vbnRoOjM4OSwgcGk6MzkxLCBwcmVkaWN0X2xpbmVhcjozOTMsIHByZXNlbnRfb3Zlcl90aW1lOjM5NSwgcXVhbnRpbGVfb3Zlcl90aW1lOjM5NywgcmFkOjM5OSwgcmF0ZTo0MDEsIHJlc2V0czo0MDMsIHJvdW5kOjQwNSwgc2NhbGFyOjQwNywgc2duOjQwOSwgc2luOjQxMSwgc2luaDo0MTMsIHNvcnQ6NDE1LCBzb3J0X2Rlc2M6NDE3LCBzcXJ0OjQxOSwgc3RkZGV2X292ZXJfdGltZTo0MjEsIHN0ZHZhcl9vdmVyX3RpbWU6NDIzLCBzdW1fb3Zlcl90aW1lOjQyNSwgdGFuOjQyNywgdGFuaDo0MjksIHRpbWVzdGFtcDo0MzEsIHRpbWU6NDMzLCB2ZWN0b3I6NDM1LCB5ZWFyOjQzN307XG5jb25zdCBwYXJzZXIgPSBMUlBhcnNlci5kZXNlcmlhbGl6ZSh7XG4gIHZlcnNpb246IDEzLFxuICBzdGF0ZXM6IFwiNltPWVFQT09PJntRUE9PT09RTycjQ3snI0N7TydRUVBPJyNDelEnXVFRT09PT1FPJyNEZScjRGVPJ1dRUE8nI0RkT09RTycjRX0nI0V9TyhqUVBPJyNGVE9ZUVBPJyNGUE9ZUVBPJyNGU09PUU8nI0ZWJyNGVk8uZlFTTycjRldPLm5RUU8nI0ZVT09RTycjRlUnI0ZVT09RTycjQ3knI0N5T09RTycjRGYnI0RmT09RTycjRGgnI0RoT09RTycjRGknI0RpT09RTycjRGonI0RqT09RTycjRGsnI0RrT09RTycjRGwnI0RsT09RTycjRG0nI0RtT09RTycjRG4nI0RuT09RTycjRG8nI0RvT09RTycjRHAnI0RwT09RTycjRHEnI0RxT09RTycjRHInI0RyT09RTycjRHMnI0RzT09RTycjRHQnI0R0T09RTycjRHUnI0R1T09RTycjRHYnI0R2T09RTycjRHcnI0R3T09RTycjRHgnI0R4T09RTycjRHknI0R5T09RTycjRHonI0R6T09RTycjRHsnI0R7T09RTycjRHwnI0R8T09RTycjRH0nI0R9T09RTycjRU8nI0VPT09RTycjRVAnI0VQT09RTycjRVEnI0VRT09RTycjRVInI0VST09RTycjRVMnI0VTT09RTycjRVQnI0VUT09RTycjRVUnI0VVT09RTycjRVYnI0VWT09RTycjRVcnI0VXT09RTycjRVgnI0VYT09RTycjRVknI0VZT09RTycjRVonI0VaT09RTycjRVsnI0VbT09RTycjRV0nI0VdT09RTycjRV4nI0VeT09RTycjRV8nI0VfT09RTycjRWAnI0VgT09RTycjRWEnI0VhT09RTycjRWInI0ViT09RTycjRWMnI0VjT09RTycjRWQnI0VkT09RTycjRWUnI0VlT09RTycjRWYnI0VmT09RTycjRWcnI0VnT09RTycjRWgnI0VoT09RTycjRWknI0VpT09RTycjRWonI0VqT09RTycjRWsnI0VrT09RTycjRWwnI0VsT09RTycjRW0nI0VtT09RTycjRW4nI0VuT09RTycjRW8nI0VvT09RTycjRXAnI0VwT09RTycjRXEnI0VxT09RTycjRXInI0VyT09RTycjRXMnI0VzT09RTycjRXQnI0V0T09RTycjRXUnI0V1T09RTycjRXYnI0V2T09RTycjRXcnI0V3T09RTycjRXgnI0V4T09RTycjRXknI0V5T09RTycjRXonI0V6UU9RUE9PTzBYUVBPJyNDfE8wXlFQTycjRFJPJ1dRUE8sNTlmTzBlUVFPLDU5Zk8yUlFQTyw1OW9PMlJRUE8sNTlvTzJSUVBPLDU5b08yUlFQTyw1OW9PMlJRUE8sNTlvTzd9UVFPLDU7Z084U1FRTyw1O2pPOFtRUE8sNTt5T09RTyw1Ok8sNTpPT09RTyw1O2ksNTtpTzhzUVFPLDU7a084elFRTyw1O25POmJRUE8nI0ZZTzpwUVBPLDU7ck9PUU8nI0ZYJyNGWE9PUU8sNTtyLDU7ck9PUU8sNTtwLDU7cE86eFFTTycjQ31PT1FPLDU5aCw1OWhPO1FRUE8sNTltTztZUVFPJyNEU09PUU8sNTltLDU5bU9PUU8xRy9RMUcvUU8wWFFQTycjRFdPQVZRUE8nI0RWT0FhUVBPJyNEVk9ZUVBPMUcvWk9ZUVBPMUcvWk9ZUVBPMUcvWk9ZUVBPMUcvWk9ZUVBPMUcvWk9Ba1FTTzFHMVJPT1FPMUcxVTFHMVVPQXNRUU8xRzFVT0F4UVBPJyNFfU9PUU8nI0ZhJyNGYU9PUU8xRzFlMUcxZU9CVFFQTzFHMWVPT1FPMUcxVjFHMVZPT1FPJyNGWicjRlpPQllRUE8sNTt0T0JfUVNPMUcxXk9PUU8xRzFeMUcxXk9PUU8nI0RQJyNEUE9CZ1FQTyw1OWlPT1FPJyNETycjRE9PT1FPLDU5aSw1OWlPWVFQTyw1OW5PT1FPMUcvWDFHL1hPT1FPLDU5ciw1OXJPSF9RUE8sNTlxT0hmUVBPLDU5cU9JfVFRTzcrJHVPSl9RUU83KyR1T0tzUVFPNyskdU9MWlFRTzcrJHVPTXJRUU83KyR1T09RTzcrJm03KyZtT05dUVFPNysmc09PUU83KyZwNysmcE9OZVFQTzcrJ1BPT1FPMUcxYDFHMWBPT1FPMUcxXzFHMV9PT1FPNysmeDcrJnhPTmpRU08xRy9UT09RTzFHL1QxRy9UT05yUVFPMUcvWU9PUU8xRy9dMUcvXU9OfFFQTzFHL11PT1FPPDxKXzw8Sl9PISZvUVBPPDxKX09PUU88PEprPDxKa09PUU8xRy9VMUcvVU9PUU83KyRvNyskb09PUU83KyR3Nyskd09PUU9BTj95QU4/eVwiLFxuICBzdGF0ZURhdGE6IFwiISZ0fk8kWk9Ta09Tfk9XUU9YUU9ZUU9aUU9bUU9dUU9eUU9fUU9gUU9hUU9iUU9jUU8hWlpPI3RfTyRXVk8kWFZPJFtYTyRfYE8kYGFPJGFiTyRiY08kY2RPJGRlTyRlZk8kZmdPJGdoTyRoaU8kaWpPJGprTyRrbE8kbG1PJG1uTyRub08kb3BPJHBxTyRxck8kcnNPJHN0TyR0dU8kdXZPJHZ3TyR3eE8keHlPJHl6TyR6e08ke3xPJHx9TyR9IU9PJU8hUE8lUCFRTyVRIVJPJVIhU08lUyFUTyVUIVVPJVUhVk8lViFXTyVXIVhPJVghWU8lWSFaTyVaIVtPJVshXU8lXSFeTyVeIV9PJV8hYE8lYCFhTyVhIWJPJWIhY08lYyFkTyVkIWVPJWUhZk8lZiFnTyVnIWhPJWghaU8laSFqTyVqIWtPJWshbE8lbCFtTyVtIW5PJW4hb08lbyFwTyVwIXFPJXEhck8lciFzTyV1V08ldldPJXdWTyV5W09+TyFaWk9+T2QhdU9lIXVPJFshdk9+T1UjUE9WIXlPZiF8T2chfU9oIXxPeCF5T3sheU98IXlPfSF5TyFPIXpPIVAhek8hUSF7TyFSIXtPIVMhe08hVCF7TyFVIXtPIVYhe08kUyNRTyVzI09Pfk8kVyNTTyRYI1NPJXcjU09XI3dYWCN3WFkjd1haI3dYWyN3WF0jd1heI3dYXyN3WGAjd1hhI3dYYiN3WGMjd1ghWiN3WCN0I3dYJFcjd1gkWCN3WCRbI3dYJF8jd1gkYCN3WCRhI3dYJGIjd1gkYyN3WCRkI3dYJGUjd1gkZiN3WCRnI3dYJGgjd1gkaSN3WCRqI3dYJGsjd1gkbCN3WCRtI3dYJG4jd1gkbyN3WCRwI3dYJHEjd1gkciN3WCRzI3dYJHQjd1gkdSN3WCR2I3dYJHcjd1gkeCN3WCR5I3dYJHojd1gkeyN3WCR8I3dYJH0jd1glTyN3WCVQI3dYJVEjd1glUiN3WCVTI3dYJVQjd1glVSN3WCVWI3dYJVcjd1glWCN3WCVZI3dYJVojd1glWyN3WCVdI3dYJV4jd1glXyN3WCVgI3dYJWEjd1glYiN3WCVjI3dYJWQjd1glZSN3WCVmI3dYJWcjd1glaCN3WCVpI3dYJWojd1glayN3WCVsI3dYJW0jd1glbiN3WCVvI3dYJXAjd1glcSN3WCVyI3dYJXUjd1gldiN3WCV3I3dYJXkjd1h+T3QjVk8leiNZT35PJXlbT1UjeFhWI3hYZiN4WGcjeFhoI3hYeCN4WHsjeFh8I3hYfSN4WCFPI3hYIVAjeFghUSN4WCFSI3hYIVMjeFghVCN4WCFVI3hYIVYjeFgkUyN4WCRWI3hYJXMjeFgkXiN4WCRdI3hYfk8kWyNbT35PJF4jYE9+UFlPZCF1T2UhdU9VbmFWbmFmbmFnbmFobmF4bmF7bmF8bmF9bmEhT25hIVBuYSFRbmEhUm5hIVNuYSFUbmEhVW5hIVZuYSRTbmEkVm5hJXNuYSRebmEkXW5hfk9QI2RPUSNiT1IjYk9XeVBYeVBZeVBaeVBbeVBdeVBeeVBfeVBgeVBheVBieVBjeVAhWnlQI3R5UCRXeVAkWHlQJFt5UCRfeVAkYHlQJGF5UCRieVAkY3lQJGR5UCRleVAkZnlQJGd5UCRoeVAkaXlQJGp5UCRreVAkbHlQJG15UCRueVAkb3lQJHB5UCRxeVAkcnlQJHN5UCR0eVAkdXlQJHZ5UCR3eVAkeHlQJHl5UCR6eVAke3lQJHx5UCR9eVAlT3lQJVB5UCVReVAlUnlQJVN5UCVUeVAlVXlQJVZ5UCVXeVAlWHlQJVl5UCVaeVAlW3lQJV15UCVeeVAlX3lQJWB5UCVheVAlYnlQJWN5UCVkeVAlZXlQJWZ5UCVneVAlaHlQJWl5UCVqeVAla3lQJWx5UCVteVAlbnlQJW95UCVweVAlcXlQJXJ5UCV1eVAldnlQJXd5UCV5eVB+TyNwI2pPfk8hUCNsTyNwI2tPfk9pI25PaiNuTyRXVk8kWFZPJXUjbU8ldiNtTyV3Vk9+TyReI3FPflAnXU94IXlPVSN2YVYjdmFmI3ZhZyN2YWgjdmF7I3ZhfCN2YX0jdmEhTyN2YSFQI3ZhIVEjdmEhUiN2YSFTI3ZhIVQjdmEhVSN2YSFWI3ZhJFMjdmEkViN2YSVzI3ZhJF4jdmEkXSN2YX5PIVYjck8kTyNyTyRQI3JPJFEjck9+TyRdI3RPJXojdU9+T3Qjdk8kXiN5T35PJF0jek8kXiN7T35PJF12WCRedlh+UCddT1d5WFh5WFl5WFp5WFt5WF15WF55WF95WGB5WGF5WGJ5WGN5WCFaeVgjdHlYJFd5WCRYeVgkW3lYJF95WCRgeVgkYXlYJGJ5WCRjeVgkZHlYJGV5WCRmeVgkZ3lYJGh5WCRpeVgkanlYJGt5WCRseVgkbXlYJG55WCRveVgkcHlYJHF5WCRyeVgkc3lYJHR5WCR1eVgkdnlYJHd5WCR4eVgkeXlYJHp5WCR7eVgkfHlYJH15WCVPeVglUHlYJVF5WCVSeVglU3lYJVR5WCVVeVglVnlYJVd5WCVYeVglWXlYJVp5WCVbeVglXXlYJV55WCVfeVglYHlYJWF5WCVieVglY3lYJWR5WCVleVglZnlYJWd5WCVoeVglaXlYJWp5WCVreVglbHlYJW15WCVueVglb3lYJXB5WCVxeVglcnlYJXV5WCV2eVgld3lYJXl5WH5PUyN9T1QjfU9+UDtkT1EjYk9SI2JPflA7ZE8ldCRVTyV4JFZPfk8jcCRXT35PJFcjU08kWCNTTyV3I1NPfk8kWyRYT35PI3QkWU9+T3QjVk8leiRbT35PJF0kXU8kXiReT35PV3lhWHlhWXlhWnlhW3lhXXlhXnlhX3lhYHlhYXlhYnlhY3lhIVp5YSN0eWEkV3lhJFh5YSRfeWEkYHlhJGF5YSRieWEkY3lhJGR5YSRleWEkZnlhJGd5YSRoeWEkaXlhJGp5YSRreWEkbHlhJG15YSRueWEkb3lhJHB5YSRxeWEkcnlhJHN5YSR0eWEkdXlhJHZ5YSR3eWEkeHlhJHl5YSR6eWEke3lhJHx5YSR9eWElT3lhJVB5YSVReWElUnlhJVN5YSVUeWElVXlhJVZ5YSVXeWElWHlhJVl5YSVaeWElW3lhJV15YSVeeWElX3lhJWB5YSVheWElYnlhJWN5YSVkeWElZXlhJWZ5YSVneWElaHlhJWl5YSVqeWEla3lhJWx5YSVteWElbnlhJW95YSVweWElcXlhJXJ5YSV1eWEldnlhJXd5YSV5eWF+TyRbI1tPflBCb09TJGFPVCRhTyRbeWF+UEJvT3gheU9Vd3Fmd3Fnd3Fod3EhT3dxIVB3cSFRd3EhUndxIVN3cSFUd3EhVXdxIVZ3cSRTd3EkVndxJXN3cSRed3EkXXdxfk9Wd3F7d3F8d3F9d3F+UEhzT1YheU97IXlPfCF5T30heU9+UEhzT1YheU94IXlPeyF5T3wheU99IXlPIU8hek8hUCF6T1V3cWZ3cWd3cWh3cSRTd3EkVndxJXN3cSRed3EkXXdxfk8hUXdxIVJ3cSFTd3EhVHdxIVV3cSFWd3F+UEpvTyFRIXtPIVIhe08hUyF7TyFUIXtPIVUhe08hViF7T35QSm9PViF5T2YhfE9oIXxPeCF5T3sheU98IXlPfSF5TyFPIXpPIVAhek8hUSF7TyFSIXtPIVMhe08hVCF7TyFVIXtPIVYhe09+T1V3cWd3cSRTd3EkVndxJXN3cSRed3EkXXdxflBMcU8jcCRjTyV0JGJPfk8kXiRkT35PdCN2TyReJGZPfk8kXXZpJF52aX5QJ11PJFsjW09XeWlYeWlZeWlaeWlbeWldeWleeWlfeWlgeWlheWlieWljeWkhWnlpI3R5aSRXeWkkWHlpJF95aSRgeWkkYXlpJGJ5aSRjeWkkZHlpJGV5aSRmeWkkZ3lpJGh5aSRpeWkkanlpJGt5aSRseWkkbXlpJG55aSRveWkkcHlpJHF5aSRyeWkkc3lpJHR5aSR1eWkkdnlpJHd5aSR4eWkkeXlpJHp5aSR7eWkkfHlpJH15aSVPeWklUHlpJVF5aSVSeWklU3lpJVR5aSVVeWklVnlpJVd5aSVYeWklWXlpJVp5aSVbeWklXXlpJV55aSVfeWklYHlpJWF5aSVieWklY3lpJWR5aSVleWklZnlpJWd5aSVoeWklaXlpJWp5aSVreWklbHlpJW15aSVueWklb3lpJXB5aSVxeWklcnlpJXV5aSV2eWkld3lpJXl5aX5PJXQkaE9+T1wiLFxuICBnb3RvOiBcIih1JFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUCRWJHUlUiVfJWUlcSV0UCV6JlQkdVAmVyZnUFBQUFBQUFBQUFAkdSZxJn1QJn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSR1UCdaJHUkdVAkdSR1J2okdSd2KFYoZihpKG9QUFAkdVAoclFTT1EjVFhRI1VZUSNfIXZRJFAjZVEkUSNmUSRSI2dRJFMjaFEkVCNpUiRfI3plX09YWSF2I2UjZiNnI2gjaSN6ZVJPWFkhdiNlI2YjZyNoI2kjelEhd1JSI2EheFEjXSF1USN8I2JRJGAjfVIkZyRhUiN3I1tRI3gjW1IkZSRdUSF4UlEjUlVSI2Ehd1IjXiF2USNlIXlRI2YhelEjZyF7USNoIXxSI2khfVkjYyF5IXoheyF8IX1SJE8jZGVVT1hZIXYjZSNmI2cjaCNpI3plVE9YWSF2I2UjZiNnI2gjaSN6ZF9PWFkhdiNlI2YjZyNoI2kjelIjbyNRZVlPWFkhdiNlI2YjZyNoI2kjemRdT1hZIXYjZSNmI2cjaCNpI3pSIXRQZF5PWFkhdiNlI2YjZyNoI2kjelIjWl1SI1dbUSNYW1IkWiN0UiNzI1ZSI3AjUVwiLFxuICBub2RlTmFtZXM6IFwi4pqgIEJvb2wgSWdub3JpbmcgT24gR3JvdXBMZWZ0IEdyb3VwUmlnaHQgT2Zmc2V0IEF0YW4yIEF2ZyBCb3R0b21rIENvdW50IENvdW50VmFsdWVzIEdyb3VwIE1heCBNaW4gUXVhbnRpbGUgU3RkZGV2IFN0ZHZhciBTdW0gVG9wayBCeSBXaXRob3V0IEFuZCBPciBVbmxlc3MgU3RhcnQgRW5kIExpbmVDb21tZW50IFByb21RTCBFeHByIEFnZ3JlZ2F0ZUV4cHIgQWdncmVnYXRlT3AgQWdncmVnYXRlTW9kaWZpZXIgR3JvdXBpbmdMYWJlbHMgR3JvdXBpbmdMYWJlbExpc3QgR3JvdXBpbmdMYWJlbCBMYWJlbE5hbWUgRnVuY3Rpb25DYWxsQm9keSBGdW5jdGlvbkNhbGxBcmdzIEJpbmFyeUV4cHIgUG93IEJpbk1vZGlmaWVycyBPbk9ySWdub3JpbmcgTXVsIERpdiBNb2QgQWRkIFN1YiBFcWwgR3RlIEd0ciBMdGUgTHNzIE5lcSBGdW5jdGlvbkNhbGwgRnVuY3Rpb25JZGVudGlmaWVyIEFic2VudE92ZXJUaW1lIElkZW50aWZpZXIgQWJzZW50IEFicyBBY29zIEFjb3NoIEFzaW4gQXNpbmggQXRhbiBBdGFuaCBBdmdPdmVyVGltZSBDZWlsIENoYW5nZXMgQ2xhbXAgQ2xhbXBNYXggQ2xhbXBNaW4gQ29zIENvc2ggQ291bnRPdmVyVGltZSBEYXlzSW5Nb250aCBEYXlPZk1vbnRoIERheU9mV2VlayBEZWcgRGVsdGEgRGVyaXYgRXhwIEZsb29yIEhpc3RvZ3JhbVF1YW50aWxlIEhvbHRXaW50ZXJzIEhvdXIgSWRlbHRhIEluY3JlYXNlIElyYXRlIExhYmVsUmVwbGFjZSBMYWJlbEpvaW4gTGFzdE92ZXJUaW1lIExuIExvZzEwIExvZzIgTWF4T3ZlclRpbWUgTWluT3ZlclRpbWUgTWludXRlIE1vbnRoIFBpIFByZWRpY3RMaW5lYXIgUHJlc2VudE92ZXJUaW1lIFF1YW50aWxlT3ZlclRpbWUgUmFkIFJhdGUgUmVzZXRzIFJvdW5kIFNjYWxhciBTZ24gU2luIFNpbmggU29ydCBTb3J0RGVzYyBTcXJ0IFN0ZGRldk92ZXJUaW1lIFN0ZHZhck92ZXJUaW1lIFN1bU92ZXJUaW1lIFRhbiBUYW5oIFRpbWVzdGFtcCBUaW1lIFZlY3RvciBZZWFyIE1hdHJpeFNlbGVjdG9yIER1cmF0aW9uIE51bWJlckxpdGVyYWwgT2Zmc2V0RXhwciBQYXJlbkV4cHIgU3RyaW5nTGl0ZXJhbCBTdWJxdWVyeUV4cHIgVW5hcnlFeHByIFVuYXJ5T3AgVmVjdG9yU2VsZWN0b3IgTWV0cmljSWRlbnRpZmllciBMYWJlbE1hdGNoZXJzIExhYmVsTWF0Y2hMaXN0IExhYmVsTWF0Y2hlciBNYXRjaE9wIEVxbFNpbmdsZSBFcWxSZWdleCBOZXFSZWdleCBTdGVwSW52YXJpYW50RXhwciBBdCBBdE1vZGlmaWVyUHJlcHJvY2Vzc29ycyBNZXRyaWNOYW1lXCIsXG4gIG1heFRlcm06IDIyNixcbiAgc2tpcHBlZE5vZGVzOiBbMCwyN10sXG4gIHJlcGVhdE5vZGVDb3VudDogMCxcbiAgdG9rZW5EYXRhOiBcIjFSflJ3WF4jbHBxI2xxciRhcnMkdHN0JWh1diVzd3gleHh5Jmd5eiZsensmcXt8JnZ8fSZ9fSFPJ1MhTyFQJ1ohUCFRKFohUSFSKGAhUiFbKVchWyFdLXIhXiFfLm4hXyFgLnshYCFhL2IhYiFjL28hYyF9L3QhfSNPMFsjUCNRMGEjUSNSMGYjUiNTL3QjUyNUMGsjVCNvL3QjbyNwMHcjcSNyMHwjeSN6I2wkZiRnI2wjQlkjQlojbCRJUyRJXyNsJEl8JEpPI2wkSlQkSlUjbCRLViRLVyNsJkZVJkZWI2x+I3FZJFp+WF4jbHBxI2wjeSN6I2wkZiRnI2wjQlkjQlojbCRJUyRJXyNsJEl8JEpPI2wkSlQkSlUjbCRLViRLVyNsJkZVJkZWI2x+JGRRIV8hYCRqI3IjcyRvfiRvTyFWfn4kdE8kUX5+JHlVI3R+T1kkdFpyJHRycyVdcyNPJHQjTyNQJWIjUH4kdH4lYk8jdH5+JWVQT34kdH4lbVFrfk9ZJWhafiVofiV4T31+fiV9VSN0fk9ZJXhadyV4d3glXXgjTyV4I08jUCZhI1B+JXh+JmRQT34leH4mbE8kW35+JnFPJF5+fiZ2T3t+UiZ9TyV2UCFPUX4nU08kXX5SJ1pPJXVQIVBRUCdeUCFRIVsnYVAnZlIld1AhUSFbJ2EhZyFoJ28jWCNZJ29QJ3JSe3wne30hTyd7IVEhWyhSUChPUCFRIVsoUlAoV1Ald1AhUSFbKFJ+KGBPfH5SKGVaJXdQIU8hUCdhIVEhWylXIWchaCdvI1cjWCl7I1gjWSdvI1sjXSpkI2EjYip4I2cjaCtsI2sjbCt9I2wjbS1XI20jbixpUildWSV3UCFPIVAnYSFRIVspVyFnIWgnbyNXI1gpeyNYI1knbyNbI10qZCNhI2IqeCNnI2grbCNrI2wrfSNtI24saVEqUVAjcFEhUSFbKlRRKldTIVEhWypUI1sjXSpkI2EjYip4I2cjaCtsUSppUCNwUSFRIVsqbFEqb1IhUSFbKmwjYSNiKngjZyNoK2xRKn1RI3BRIVEhWytUI2cjaCtnUStXUiFRIVsrVCNhI2IrYSNnI2grbFErZFAjZyNoK2dRK2xPI3BRUStxUCNwUSFRIVsrdFErd1EhUSFbK3QjYSNiK2FRLFNQI3BRIVEhWyxWUSxZVCFRIVssViNXI1gpeyNbI10qZCNhI2IqeCNnI2grbFEsblAjcFEhUSFbLHFRLHRVIVEhWyxxI1cjWCl7I1sjXSpkI2EjYip4I2cjaCtsI2sjbCt9UC1aUiFRIVstZCFjIWktZCNUI1otZFAtaVIld1AhUSFbLWQhYyFpLWQjVCNaLWRWLXlUJXhTIVpSIVEhWy5ZIVshXS5ZIWMhfS5ZI1IjUy5ZI1Qjby5ZUi5fVCFaUiFRIVsuWSFbIV0uWSFjIX0uWSNSI1MuWSNUI28uWX4uc1AhVX4hXyFgLnZ+LntPIVR+fi9RUSRPUCFfIWAvVyNyI3MvXVEvXU8hUVF+L2JPJFB+fi9nUCFTfiFfIWAvan4vb08hUn5+L3RPJFN+Vi97VCFaUnRTIVEhWy90IVshXS5ZIWMhfS90I1IjUy90I1Qjby90fjBhTyVzfn4wZk8ldH5+MGtPeH5+MG5STyNTMGsjUyNUJV0jVH4wa34wfE8leX5+MVJPJXp+XCIsXG4gIHRva2VuaXplcnM6IFswLCAxLCAyXSxcbiAgdG9wUnVsZXM6IHtcIlByb21RTFwiOlswLDI4XSxcIk1ldHJpY05hbWVcIjpbMSwxNDRdfSxcbiAgc3BlY2lhbGl6ZWQ6IFt7dGVybTogNTcsIGdldDogKHZhbHVlLCBzdGFjaykgPT4gKHNwZWNpYWxpemVJZGVudGlmaWVyKHZhbHVlKSA8PCAxKX0se3Rlcm06IDU3LCBnZXQ6ICh2YWx1ZSwgc3RhY2spID0+IChleHRlbmRJZGVudGlmaWVyKHZhbHVlKSA8PCAxKSB8IDF9LHt0ZXJtOiA1NywgZ2V0OiB2YWx1ZSA9PiBzcGVjX0lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogMFxufSk7XG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IFxuICBpbmYkMSA9IDE0NixcbiAgbmFuJDEgPSAxNDcsXG4gIEJvb2wkMSA9IDEsXG4gIElnbm9yaW5nJDEgPSAyLFxuICBPbiQxID0gMyxcbiAgR3JvdXBMZWZ0JDEgPSA0LFxuICBHcm91cFJpZ2h0JDEgPSA1LFxuICBPZmZzZXQkMSA9IDYsXG4gIEF0YW4yJDEgPSA3LFxuICBBdmckMSA9IDgsXG4gIEJvdHRvbWskMSA9IDksXG4gIENvdW50JDEgPSAxMCxcbiAgQ291bnRWYWx1ZXMkMSA9IDExLFxuICBHcm91cCQxID0gMTIsXG4gIE1heCQxID0gMTMsXG4gIE1pbiQxID0gMTQsXG4gIFF1YW50aWxlJDEgPSAxNSxcbiAgU3RkZGV2JDEgPSAxNixcbiAgU3RkdmFyJDEgPSAxNyxcbiAgU3VtJDEgPSAxOCxcbiAgVG9wayQxID0gMTksXG4gIEJ5JDEgPSAyMCxcbiAgV2l0aG91dCQxID0gMjEsXG4gIEFuZCQxID0gMjIsXG4gIE9yJDEgPSAyMyxcbiAgVW5sZXNzJDEgPSAyNCxcbiAgU3RhcnQkMSA9IDI1LFxuICBFbmQkMSA9IDI2LFxuICBMaW5lQ29tbWVudCA9IDI3LFxuICBQcm9tUUwgPSAyOCxcbiAgRXhwciA9IDI5LFxuICBBZ2dyZWdhdGVFeHByID0gMzAsXG4gIEFnZ3JlZ2F0ZU9wID0gMzEsXG4gIEFnZ3JlZ2F0ZU1vZGlmaWVyID0gMzIsXG4gIEdyb3VwaW5nTGFiZWxzID0gMzMsXG4gIEdyb3VwaW5nTGFiZWxMaXN0ID0gMzQsXG4gIEdyb3VwaW5nTGFiZWwgPSAzNSxcbiAgTGFiZWxOYW1lID0gMzYsXG4gIEZ1bmN0aW9uQ2FsbEJvZHkgPSAzNyxcbiAgRnVuY3Rpb25DYWxsQXJncyA9IDM4LFxuICBCaW5hcnlFeHByID0gMzksXG4gIFBvdyA9IDQwLFxuICBCaW5Nb2RpZmllcnMgPSA0MSxcbiAgT25Pcklnbm9yaW5nID0gNDIsXG4gIE11bCA9IDQzLFxuICBEaXYgPSA0NCxcbiAgTW9kID0gNDUsXG4gIEFkZCA9IDQ2LFxuICBTdWIgPSA0NyxcbiAgRXFsID0gNDgsXG4gIEd0ZSA9IDQ5LFxuICBHdHIgPSA1MCxcbiAgTHRlID0gNTEsXG4gIExzcyA9IDUyLFxuICBOZXEgPSA1MyxcbiAgRnVuY3Rpb25DYWxsID0gNTQsXG4gIEZ1bmN0aW9uSWRlbnRpZmllciA9IDU1LFxuICBBYnNlbnRPdmVyVGltZSA9IDU2LFxuICBJZGVudGlmaWVyID0gNTcsXG4gIEFic2VudCA9IDU4LFxuICBBYnMgPSA1OSxcbiAgQWNvcyA9IDYwLFxuICBBY29zaCA9IDYxLFxuICBBc2luID0gNjIsXG4gIEFzaW5oID0gNjMsXG4gIEF0YW4gPSA2NCxcbiAgQXRhbmggPSA2NSxcbiAgQXZnT3ZlclRpbWUgPSA2NixcbiAgQ2VpbCA9IDY3LFxuICBDaGFuZ2VzID0gNjgsXG4gIENsYW1wID0gNjksXG4gIENsYW1wTWF4ID0gNzAsXG4gIENsYW1wTWluID0gNzEsXG4gIENvcyA9IDcyLFxuICBDb3NoID0gNzMsXG4gIENvdW50T3ZlclRpbWUgPSA3NCxcbiAgRGF5c0luTW9udGggPSA3NSxcbiAgRGF5T2ZNb250aCA9IDc2LFxuICBEYXlPZldlZWsgPSA3NyxcbiAgRGVnID0gNzgsXG4gIERlbHRhID0gNzksXG4gIERlcml2ID0gODAsXG4gIEV4cCA9IDgxLFxuICBGbG9vciA9IDgyLFxuICBIaXN0b2dyYW1RdWFudGlsZSA9IDgzLFxuICBIb2x0V2ludGVycyA9IDg0LFxuICBIb3VyID0gODUsXG4gIElkZWx0YSA9IDg2LFxuICBJbmNyZWFzZSA9IDg3LFxuICBJcmF0ZSA9IDg4LFxuICBMYWJlbFJlcGxhY2UgPSA4OSxcbiAgTGFiZWxKb2luID0gOTAsXG4gIExhc3RPdmVyVGltZSA9IDkxLFxuICBMbiA9IDkyLFxuICBMb2cxMCA9IDkzLFxuICBMb2cyID0gOTQsXG4gIE1heE92ZXJUaW1lID0gOTUsXG4gIE1pbk92ZXJUaW1lID0gOTYsXG4gIE1pbnV0ZSA9IDk3LFxuICBNb250aCA9IDk4LFxuICBQaSA9IDk5LFxuICBQcmVkaWN0TGluZWFyID0gMTAwLFxuICBQcmVzZW50T3ZlclRpbWUgPSAxMDEsXG4gIFF1YW50aWxlT3ZlclRpbWUgPSAxMDIsXG4gIFJhZCA9IDEwMyxcbiAgUmF0ZSA9IDEwNCxcbiAgUmVzZXRzID0gMTA1LFxuICBSb3VuZCA9IDEwNixcbiAgU2NhbGFyID0gMTA3LFxuICBTZ24gPSAxMDgsXG4gIFNpbiA9IDEwOSxcbiAgU2luaCA9IDExMCxcbiAgU29ydCA9IDExMSxcbiAgU29ydERlc2MgPSAxMTIsXG4gIFNxcnQgPSAxMTMsXG4gIFN0ZGRldk92ZXJUaW1lID0gMTE0LFxuICBTdGR2YXJPdmVyVGltZSA9IDExNSxcbiAgU3VtT3ZlclRpbWUgPSAxMTYsXG4gIFRhbiA9IDExNyxcbiAgVGFuaCA9IDExOCxcbiAgVGltZXN0YW1wID0gMTE5LFxuICBUaW1lID0gMTIwLFxuICBWZWN0b3IgPSAxMjEsXG4gIFllYXIgPSAxMjIsXG4gIE1hdHJpeFNlbGVjdG9yID0gMTIzLFxuICBEdXJhdGlvbiA9IDEyNCxcbiAgTnVtYmVyTGl0ZXJhbCA9IDEyNSxcbiAgT2Zmc2V0RXhwciA9IDEyNixcbiAgUGFyZW5FeHByID0gMTI3LFxuICBTdHJpbmdMaXRlcmFsID0gMTI4LFxuICBTdWJxdWVyeUV4cHIgPSAxMjksXG4gIFVuYXJ5RXhwciA9IDEzMCxcbiAgVW5hcnlPcCA9IDEzMSxcbiAgVmVjdG9yU2VsZWN0b3IgPSAxMzIsXG4gIE1ldHJpY0lkZW50aWZpZXIgPSAxMzMsXG4gIExhYmVsTWF0Y2hlcnMgPSAxMzQsXG4gIExhYmVsTWF0Y2hMaXN0ID0gMTM1LFxuICBMYWJlbE1hdGNoZXIgPSAxMzYsXG4gIE1hdGNoT3AgPSAxMzcsXG4gIEVxbFNpbmdsZSA9IDEzOCxcbiAgRXFsUmVnZXggPSAxMzksXG4gIE5lcVJlZ2V4ID0gMTQwLFxuICBTdGVwSW52YXJpYW50RXhwciA9IDE0MSxcbiAgQXQgPSAxNDIsXG4gIEF0TW9kaWZpZXJQcmVwcm9jZXNzb3JzID0gMTQzLFxuICBNZXRyaWNOYW1lID0gMTQ0O1xuXG5leHBvcnQgeyBBYnMsIEFic2VudCwgQWJzZW50T3ZlclRpbWUsIEFjb3MsIEFjb3NoLCBBZGQsIEFnZ3JlZ2F0ZUV4cHIsIEFnZ3JlZ2F0ZU1vZGlmaWVyLCBBZ2dyZWdhdGVPcCwgQW5kJDEgYXMgQW5kLCBBc2luLCBBc2luaCwgQXQsIEF0TW9kaWZpZXJQcmVwcm9jZXNzb3JzLCBBdGFuLCBBdGFuMiQxIGFzIEF0YW4yLCBBdGFuaCwgQXZnJDEgYXMgQXZnLCBBdmdPdmVyVGltZSwgQmluTW9kaWZpZXJzLCBCaW5hcnlFeHByLCBCb29sJDEgYXMgQm9vbCwgQm90dG9tayQxIGFzIEJvdHRvbWssIEJ5JDEgYXMgQnksIENlaWwsIENoYW5nZXMsIENsYW1wLCBDbGFtcE1heCwgQ2xhbXBNaW4sIENvcywgQ29zaCwgQ291bnQkMSBhcyBDb3VudCwgQ291bnRPdmVyVGltZSwgQ291bnRWYWx1ZXMkMSBhcyBDb3VudFZhbHVlcywgRGF5T2ZNb250aCwgRGF5T2ZXZWVrLCBEYXlzSW5Nb250aCwgRGVnLCBEZWx0YSwgRGVyaXYsIERpdiwgRHVyYXRpb24sIEVuZCQxIGFzIEVuZCwgRXFsLCBFcWxSZWdleCwgRXFsU2luZ2xlLCBFeHAsIEV4cHIsIEZsb29yLCBGdW5jdGlvbkNhbGwsIEZ1bmN0aW9uQ2FsbEFyZ3MsIEZ1bmN0aW9uQ2FsbEJvZHksIEZ1bmN0aW9uSWRlbnRpZmllciwgR3JvdXAkMSBhcyBHcm91cCwgR3JvdXBMZWZ0JDEgYXMgR3JvdXBMZWZ0LCBHcm91cFJpZ2h0JDEgYXMgR3JvdXBSaWdodCwgR3JvdXBpbmdMYWJlbCwgR3JvdXBpbmdMYWJlbExpc3QsIEdyb3VwaW5nTGFiZWxzLCBHdGUsIEd0ciwgSGlzdG9ncmFtUXVhbnRpbGUsIEhvbHRXaW50ZXJzLCBIb3VyLCBJZGVsdGEsIElkZW50aWZpZXIsIElnbm9yaW5nJDEgYXMgSWdub3JpbmcsIEluY3JlYXNlLCBJcmF0ZSwgTGFiZWxKb2luLCBMYWJlbE1hdGNoTGlzdCwgTGFiZWxNYXRjaGVyLCBMYWJlbE1hdGNoZXJzLCBMYWJlbE5hbWUsIExhYmVsUmVwbGFjZSwgTGFzdE92ZXJUaW1lLCBMaW5lQ29tbWVudCwgTG4sIExvZzEwLCBMb2cyLCBMc3MsIEx0ZSwgTWF0Y2hPcCwgTWF0cml4U2VsZWN0b3IsIE1heCQxIGFzIE1heCwgTWF4T3ZlclRpbWUsIE1ldHJpY0lkZW50aWZpZXIsIE1ldHJpY05hbWUsIE1pbiQxIGFzIE1pbiwgTWluT3ZlclRpbWUsIE1pbnV0ZSwgTW9kLCBNb250aCwgTXVsLCBOZXEsIE5lcVJlZ2V4LCBOdW1iZXJMaXRlcmFsLCBPZmZzZXQkMSBhcyBPZmZzZXQsIE9mZnNldEV4cHIsIE9uJDEgYXMgT24sIE9uT3JJZ25vcmluZywgT3IkMSBhcyBPciwgUGFyZW5FeHByLCBQaSwgUG93LCBQcmVkaWN0TGluZWFyLCBQcmVzZW50T3ZlclRpbWUsIFByb21RTCwgUXVhbnRpbGUkMSBhcyBRdWFudGlsZSwgUXVhbnRpbGVPdmVyVGltZSwgUmFkLCBSYXRlLCBSZXNldHMsIFJvdW5kLCBTY2FsYXIsIFNnbiwgU2luLCBTaW5oLCBTb3J0LCBTb3J0RGVzYywgU3FydCwgU3RhcnQkMSBhcyBTdGFydCwgU3RkZGV2JDEgYXMgU3RkZGV2LCBTdGRkZXZPdmVyVGltZSwgU3RkdmFyJDEgYXMgU3RkdmFyLCBTdGR2YXJPdmVyVGltZSwgU3RlcEludmFyaWFudEV4cHIsIFN0cmluZ0xpdGVyYWwsIFN1YiwgU3VicXVlcnlFeHByLCBTdW0kMSBhcyBTdW0sIFN1bU92ZXJUaW1lLCBUYW4sIFRhbmgsIFRpbWUsIFRpbWVzdGFtcCwgVG9wayQxIGFzIFRvcGssIFVuYXJ5RXhwciwgVW5hcnlPcCwgVW5sZXNzJDEgYXMgVW5sZXNzLCBWZWN0b3IsIFZlY3RvclNlbGVjdG9yLCBXaXRob3V0JDEgYXMgV2l0aG91dCwgWWVhciwgaW5mJDEgYXMgaW5mLCBuYW4kMSBhcyBuYW4sIHBhcnNlciB9O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsIi8vIEZJWE1FIHByb2ZpbGUgYWRkaW5nIGEgcGVyLVRyZWUgVHJlZU5vZGUgY2FjaGUsIHZhbGlkYXRpbmcgaXQgYnlcbi8vIHBhcmVudCBwb2ludGVyXG4vLy8gVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZSAoMTAyNCkuXG5jb25zdCBEZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTAyNDtcbmxldCBuZXh0UHJvcElEID0gMDtcbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuLy8vIEVhY2ggW25vZGUgdHlwZV0oI2NvbW1vbi5Ob2RlVHlwZSkgb3IgW2luZGl2aWR1YWwgdHJlZV0oI2NvbW1vbi5UcmVlKVxuLy8vIGNhbiBoYXZlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBpdCBpbiBwcm9wcy4gSW5zdGFuY2VzIG9mIHRoaXNcbi8vLyBjbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbmNsYXNzIE5vZGVQcm9wIHtcbiAgICAvLy8gQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0UHJvcElEKys7XG4gICAgICAgIHRoaXMucGVyTm9kZSA9ICEhY29uZmlnLnBlck5vZGU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBjb25maWcuZGVzZXJpYWxpemUgfHwgKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgZGVmaW5lIGEgZGVzZXJpYWxpemUgZnVuY3Rpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy8gVGhpcyBpcyBtZWFudCB0byBiZSB1c2VkIHdpdGhcbiAgICAvLy8gW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgLy8vIFtgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLlBhcnNlckNvbmZpZy5wcm9wcykgdG8gY29tcHV0ZVxuICAgIC8vLyBwcm9wIHZhbHVlcyBmb3IgZWFjaCBub2RlIHR5cGUgaW4gdGhlIHNldC4gVGFrZXMgYSBbbWF0Y2hcbiAgICAvLy8gb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgLy8vIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICAgIC8vLyBpdCBkb2VzLlxuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIFByb3AgdGhhdCBpcyB1c2VkIHRvIGRlc2NyaWJlIG1hdGNoaW5nIGRlbGltaXRlcnMuIEZvciBvcGVuaW5nXG4vLy8gZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbi8vLyBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nIHdoZW4gZGVjbGFyaW5nIHRoaXMgcHJvcCBpbiBhIGdyYW1tYXIpXG4vLy8gZm9yIHRoZSBub2RlIHR5cGVzIG9mIGNsb3NpbmcgZGVsaW1pdGVycyB0aGF0IG1hdGNoIGl0LlxuTm9kZVByb3AuY2xvc2VkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vLy8gVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG4vLy8gYXR0YWNoZWQgdG8gY2xvc2luZyBkZWxpbWl0ZXJzLCBob2xkaW5nIGFuIGFycmF5IG9mIG5vZGUgbmFtZXNcbi8vLyBvZiB0eXBlcyBvZiBtYXRjaGluZyBvcGVuaW5nIGRlbGltaXRlcnMuXG5Ob2RlUHJvcC5vcGVuZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBVc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG4vLy8gdHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxuLy8vIGBcIkV4cHJlc3Npb25cImAgZ3JvdXApLlxuTm9kZVByb3AuZ3JvdXAgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vLy8gVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG4vLy8gdGhhdCB0aGUgbm9kZSB3YXMgcGFyc2VkIGluLCBpZiBhbnkuIFVzZWQgdG8gbGltaXQgcmV1c2Ugb2Zcbi8vLyBjb250ZXh0dWFsIG5vZGVzLlxuTm9kZVByb3AuY29udGV4dEhhc2ggPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIFRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbi8vLyBsb29rZWQgYWhlYWQgZm9yIGFueSBvZiB0aGUgdG9rZW5zIGluc2lkZSB0aGUgbm9kZS4gKFRoZSBMUlxuLy8vIHBhcnNlciBvbmx5IHN0b3JlcyB0aGlzIHdoZW4gaXQgaXMgbGFyZ2VyIHRoYW4gMjUsIGZvclxuLy8vIGVmZmljaWVuY3kgcmVhc29ucy4pXG5Ob2RlUHJvcC5sb29rQWhlYWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIFRoaXMgcGVyLW5vZGUgcHJvcCBpcyB1c2VkIHRvIHJlcGxhY2UgYSBnaXZlbiBub2RlLCBvciBwYXJ0IG9mIGFcbi8vLyBub2RlLCB3aXRoIGFub3RoZXIgdHJlZS4gVGhpcyBpcyB1c2VmdWwgdG8gaW5jbHVkZSB0cmVlcyBmcm9tXG4vLy8gZGlmZmVyZW50IGxhbmd1YWdlcy5cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIEEgbW91bnRlZCB0cmVlLCB3aGljaCBjYW4gYmUgW3N0b3JlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBvblxuLy8vIGEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG4vLy8gcmVwcmVzZW50ZWQgYnkgYW5vdGhlciB0cmVlLlxuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgaW5uZXIgdHJlZS5cbiAgICB0cmVlLCBcbiAgICAvLy8gSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgLy8vIGJlIGluY2x1ZGVkIGluIHRoZSByZWd1bGFyIGl0ZXJhdGlvbiBpbnN0ZWFkIG9mIGl0cyBob3N0XG4gICAgLy8vIG5vZGUpLiBJZiBub3QsIG9ubHkgdGhlIGdpdmVuIHJhbmdlcyBhcmUgY29uc2lkZXJlZCB0byBiZVxuICAgIC8vLyBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIC8vLyBhIHdheSB0aGF0IGlzbid0IHN0cmljdGx5IGhpZXJhcmNoaWNhbC4gU3VjaCBtb3VudGVkIHRyZWVzIGFyZVxuICAgIC8vLyBvbmx5IGVudGVyZWQgYnkgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKVxuICAgIC8vLyBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgb3ZlcmxheSwgXG4gICAgLy8vIFRoZSBwYXJzZXIgdXNlZCB0byBjcmVhdGUgdGhpcyBzdWJ0cmVlLlxuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG59XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vLyBFYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZS4gTm90IG5lY2Vzc2FyaWx5IHVuaXF1ZSwgYnV0IGlmIHRoZVxuICAgIC8vLyBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIC8vLyBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICAvLy8gcm9sZS5cbiAgICBuYW1lLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcHJvcHMsIFxuICAgIC8vLyBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIC8vLyB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgaWQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBUb3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIFNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZXMgYSBub2RlIHByb3AgZm9yIHRoaXMgdHlwZS4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWZcbiAgICAvLy8gdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIGlzIHRoZSB0b3Agbm9kZSBvZiBhIGdyYW1tYXIuXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFRvcCAqLykgPiAwOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgZ2V0IGlzU2tpcHBlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBTa2lwcGVkICovKSA+IDA7IH1cbiAgICAvLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIEVycm9yICovKSA+IDA7IH1cbiAgICAvLy8gV2hlbiB0cnVlLCB0aGlzIG5vZGUgdHlwZSBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gYSB1c2VyLWRlY2xhcmVkXG4gICAgLy8vIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBBbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8vLyBSZXR1cm5zIHRydWUgd2hlbiB0aGlzIG5vZGUncyBuYW1lIG9yIG9uZSBvZiBpdHNcbiAgICAvLy8gW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLiBZb3UgY2FuIHB1dCBtdWx0aXBsZVxuICAgIC8vLyBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICAvLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICBzdGF0aWMgbWF0Y2gobWFwKSB7XG4gICAgICAgIGxldCBkaXJlY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgZGlyZWN0W25hbWVdID0gbWFwW3Byb3BdO1xuICAgICAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwcyA9IG5vZGUucHJvcChOb2RlUHJvcC5ncm91cCksIGkgPSAtMTsgaSA8IChncm91cHMgPyBncm91cHMubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpcmVjdFtpIDwgMCA/IG5vZGUubmFtZSA6IGdyb3Vwc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIEFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogQW5vbnltb3VzICovKTtcbi8vLyBBIG5vZGUgc2V0IGhvbGRzIGEgY29sbGVjdGlvbiBvZiBub2RlIHR5cGVzLiBJdCBpcyB1c2VkIHRvXG4vLy8gY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG4vLy8gZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuLy8vIFtoYXNdKCNsci5MUlBhcnNlci5ub2RlU2V0KSBhIG5vZGUgc2V0LCBhbmQgW3RyZWVcbi8vLyBidWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbi8vLyB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheSBzbG90cy5cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8vLyBDcmVhdGUgYSBzZXQgd2l0aCB0aGUgZ2l2ZW4gdHlwZXMuIFRoZSBgaWRgIHByb3BlcnR5IG9mIGVhY2hcbiAgICAvLy8gdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5vZGUgdHlwZXMgaW4gdGhpcyBzZXQsIGJ5IGlkLlxuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICAvLy8gYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBjcmVhdGVkIHdpdGhcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG4vLy8gdHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuLy8vIGNvbnZlbmllbnQgd2F5LlxuLy8vXG4vLy8gU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG4vLy8gb2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG4vLy9cbi8vLyBIb3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xuLy8vIHVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuLy8vIFtgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG4vLy8gYSB2aWV3IG9uIHNvbWUgcGFydCBvZiB0aGlzIGRhdGEgc3RydWN0dXJlLCBhbmQgY2FuIGJlIHVzZWQgdG9cbi8vLyBtb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWUge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHR5cGUgb2YgdGhlIHRvcCBub2RlLlxuICAgIHR5cGUsIFxuICAgIC8vLyBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICBjaGlsZHJlbiwgXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICAvLy8gdGhlIGNoaWxkcmVuLlxuICAgIHBvc2l0aW9ucywgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gUGVyLW5vZGUgW25vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3ApIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgbm9kZS5cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSB0aGlzLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gbW91bnRlZC50cmVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBjaC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gXCIsXCI7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcm9vdGVkIGF0IHRoaXMgdHJlZS4gV2hlblxuICAgIC8vLyBgcG9zYCBpcyBnaXZlbiwgdGhlIGN1cnNvciBpcyBbbW92ZWRdKCNjb21tb24uVHJlZUN1cnNvci5tb3ZlVG8pXG4gICAgLy8vIHRvIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS5cbiAgICBjdXJzb3IocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSAocG9zICE9IG51bGwgJiYgQ2FjaGVkTm9kZS5nZXQodGhpcykpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdXJzb3IubW92ZVRvKHBvcywgc2lkZSk7XG4gICAgICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgdGhhdCwgdW5saWtlIHJlZ3VsYXJcbiAgICAvLy8gY3Vyc29ycywgZG9lc24ndCBza2lwIHRocm91Z2hcbiAgICAvLy8gW2Fub255bW91c10oI2NvbW1vbi5Ob2RlVHlwZS5pc0Fub255bW91cykgbm9kZXMgYW5kIGRvZXNuJ3RcbiAgICAvLy8gYXV0b21hdGljYWxseSBlbnRlciBtb3VudGVkIG5vZGVzLlxuICAgIGZ1bGxDdXJzb3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIDEgLyogRnVsbCAqLyk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIC8vLyB0cmVlLlxuICAgIGdldCB0b3BOb2RlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIC8vLyBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXG4gICAgLy8vIHBvc2l0aW9uLiBJZiAxLCBpdCdsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBzdGFydCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIC8vLyBmcm9tIGJvdGggc2lkZXMuXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gICAgLy8vIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSBub2RlcywgcHJvZHVjaW5nIGEgc3ludGF4IG5vZGVcbiAgICAvLy8gcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgLy8vICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgICAvLy8gdGhlIGhvc3QgdHJlZXMpLlxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgLy8vIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICAvLy8gcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIC8vLyBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIC8vLyBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IoKSwgZ2V0ID0gKCkgPT4gYy5ub2RlOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjLmZyb20gPD0gdG8gJiYgYy50byA+PSBmcm9tICYmIChjLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIoYy50eXBlLCBjLmZyb20sIGMudG8sIGdldCkgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RMZWF2ZSAmJiBsZWF2ZSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoYy50eXBlLCBjLmZyb20sIGMudG8sIGdldCk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gYy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghYy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIFtub2RlIHByb3BdKCNjb21tb24uTm9kZVByb3ApIGZvciB0aGlzXG4gICAgLy8vIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgcHJvcChwcm9wKSB7XG4gICAgICAgIHJldHVybiAhcHJvcC5wZXJOb2RlID8gdGhpcy50eXBlLnByb3AocHJvcCkgOiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1twcm9wLmlkXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5vZGUncyBbcGVyLW5vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3AucGVyTm9kZSkgaW4gYVxuICAgIC8vLyBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgLy8vIGNvbnN0cnVjdG9yLlxuICAgIGdldCBwcm9wVmFsdWVzKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5wcm9wcylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbK2lkLCB0aGlzLnByb3BzW2lkXV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIC8vLyB3aGljaCBtYXkgaGF2ZSBjaGlsZHJlbiBncm91cGVkIGludG8gc3VidHJlZXMgd2l0aCB0eXBlXG4gICAgLy8vIFtgTm9kZVR5cGUubm9uZWBdKCNjb21tb24uTm9kZVR5cGVebm9uZSkuXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCcmFuY2hGYWN0b3IgKi8gPyB0aGlzIDpcbiAgICAgICAgICAgIGJhbGFuY2VSYW5nZShOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIHRoaXMubGVuZ3RoLCAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgdGhpcy5wcm9wVmFsdWVzKSwgY29uZmlnLm1ha2VUcmVlIHx8ICgoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vLyBCdWlsZCBhIHRyZWUgZnJvbSBhIHBvc3RmaXgtb3JkZXJlZCBidWZmZXIgb2Ygbm9kZSBpbmZvcm1hdGlvbixcbiAgICAvLy8gb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8vLyBUaGUgZW1wdHkgdHJlZVxuVHJlZS5lbXB0eSA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgMCk7XG5jbGFzcyBGbGF0QnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIGdldCBwb3MoKSB7IHJldHVybiB0aGlzLmluZGV4OyB9XG4gICAgbmV4dCgpIHsgdGhpcy5pbmRleCAtPSA0OyB9XG4gICAgZm9yaygpIHsgcmV0dXJuIG5ldyBGbGF0QnVmZmVyQ3Vyc29yKHRoaXMuYnVmZmVyLCB0aGlzLmluZGV4KTsgfVxufVxuLy8vIFRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbi8vLyBub2RlLiBJbiBzdWNoIGEgYnVmZmVyLCBub2RlcyBhcmUgc3RvcmVkIGluIHByZWZpeCBvcmRlciAocGFyZW50c1xuLy8vIGJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG4vLy8gY2hpbGRyZW4gYmVsb25nIHRvIGl0KVxuY2xhc3MgVHJlZUJ1ZmZlciB7XG4gICAgLy8vIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgYnVmZmVyJ3MgY29udGVudC5cbiAgICBidWZmZXIsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBncm91cCBvZiBub2RlcyBpbiB0aGUgYnVmZmVyLlxuICAgIGxlbmd0aCwgXG4gICAgLy8vIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgIHNldCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGg7KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNoaWxkU3RyaW5nKGluZGV4KSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuYnVmZmVyW2luZGV4XSwgZW5kSW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xuICAgICAgICBpZiAoL1xcVy8udGVzdChyZXN1bHQpICYmICF0eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAoZW5kSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBcIihcIiArIGNoaWxkcmVuLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCB0byAtIGZyb20sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIEJlZm9yZSAqLzogcmV0dXJuIGZyb20gPCBwb3M7XG4gICAgICAgIGNhc2UgLTEgLyogQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIEF0T3JBZnRlciAqLzogcmV0dXJuIGZyb20gPD0gcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDIgLyogQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIERvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShub2RlLCBwb3MpIHtcbiAgICBsZXQgc2NhbiA9IG5vZGUuY2hpbGRCZWZvcmUocG9zKTtcbiAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xuICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUobm9kZSwgcG9zLCBzaWRlLCBvdmVybGF5cykge1xuICAgIHZhciBfYTtcbiAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICB3aGlsZSAobm9kZS5mcm9tID09IG5vZGUudG8gfHxcbiAgICAgICAgKHNpZGUgPCAxID8gbm9kZS5mcm9tID49IHBvcyA6IG5vZGUuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgKHNpZGUgPiAtMSA/IG5vZGUudG8gPD0gcG9zIDogbm9kZS50byA8IHBvcykpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICFvdmVybGF5cyAmJiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgbm9kZS5pbmRleCA8IDAgPyBudWxsIDogbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8vIE11c3QgZ28gdXAgb3V0IG9mIG92ZXJsYXlzIHdoZW4gdGhvc2UgZG8gbm90IG92ZXJsYXAgd2l0aCBwb3NcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBwYXJlbnQgPSBzY2FuLnBhcmVudDsgcGFyZW50OyBzY2FuID0gcGFyZW50LCBwYXJlbnQgPSBzY2FuLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHNjYW4gaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBzY2FuLmluZGV4IDwgMCAmJiAoKF9hID0gcGFyZW50LmVudGVyKHBvcywgc2lkZSwgdHJ1ZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAhPSBzY2FuLmZyb20pXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIF9mcm9tLCBcbiAgICAvLyBJbmRleCBpbiBwYXJlbnQgbm9kZSwgc2V0IHRvIC0xIGlmIHRoZSBub2RlIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBfcGFyZW50Lm5vZGUgKG92ZXJsYXkpXG4gICAgaW5kZXgsIF9wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5fZnJvbSA9IF9mcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5ub2RlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMubm9kZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuX2Zyb207IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLl9mcm9tICsgdGhpcy5ub2RlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5ub2RlLCBlID0gZGlyID4gMCA/IGNoaWxkcmVuLmxlbmd0aCA6IC0xOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltpXSwgc3RhcnQgPSBwb3NpdGlvbnNbaV0gKyBwYXJlbnQuX2Zyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIDIgLyogTm9FbnRlckJ1ZmZlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgcG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobW9kZSAmIDEgLyogRnVsbCAqLykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgMSAvKiBGdWxsICovKSAmJiBuZXh0LnByb3BzICYmIChtb3VudGVkID0gbmV4dC5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobW9kZSAmIDEgLyogRnVsbCAqLykgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgMiAvKiBBZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cyA9IHRydWUsIGJ1ZmZlcnMgPSB0cnVlKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAob3ZlcmxheXMgJiYgKG1vdW50ZWQgPSB0aGlzLm5vZGUucHJvcChOb2RlUHJvcC5tb3VudGVkKSkgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgclBvcyA9IHBvcyAtIHRoaXMuZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPiAwID8gZnJvbSA8PSByUG9zIDogZnJvbSA8IHJQb3MpICYmXG4gICAgICAgICAgICAgICAgICAgIChzaWRlIDwgMCA/IHRvID49IHJQb3MgOiB0byA+IHJQb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgbW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyB0aGlzLmZyb20sIC0xLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCBzaWRlLCBidWZmZXJzID8gMCA6IDIgLyogTm9FbnRlckJ1ZmZlciAqLyk7XG4gICAgfVxuICAgIG5leHRTaWduaWZpY2FudFBhcmVudCgpIHtcbiAgICAgICAgbGV0IHZhbCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh2YWwudHlwZS5pc0Fub255bW91cyAmJiB2YWwuX3BhcmVudClcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fcGFyZW50O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCArIDEsIDEsIDAsIDQgLyogRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBjdXJzb3IoKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzKTsgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5ub2RlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5ub2RlOyB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcykgeyByZXR1cm4gZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUodGhpcywgcG9zKTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5ub2RlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IsIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIHdoaWxlICghY3VyLnR5cGUuaXMoYmVmb3JlKSlcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cywgYnVmZmVycyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFidWZmZXJzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgc2lkZSA+IDAgPyAxIDogLTEsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICB9XG4gICAgZXh0ZXJuYWxTaWJsaW5nKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gbnVsbCA6IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dENoaWxkKHRoaXMuY29udGV4dC5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIERvbnRDYXJlICovKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXSwgdG8gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG59XG4vLy8gQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG4vLy8gYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGUuY29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSBub2RlLl9wYXJlbnQ7IG47IG4gPSBuLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG4uaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSwgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuYnVmZmVyLnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihpbmRleCk7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgLy8vIGZhbHNlLCB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIGFuZCB0aGUgY3Vyc29yIGhhcyBub3QgYmVlbiBtb3ZlZC5cbiAgICBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgIGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdCBjaGlsZCB0aGF0IGVuZHMgYWZ0ZXIgYHBvc2AuXG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIDIgLyogQWZ0ZXIgKi8pOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIGxhc3QgY2hpbGQgdGhhdCBzdGFydHMgYmVmb3JlIGBwb3NgLlxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCBwb3MsIC0yIC8qIEJlZm9yZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gICAgLy8vIGNoaWxkIG1heSBlbmQgYXQgdGhhdCBwb3NpdGlvbiwgd2hlbiAxIGl0IG1heSBzdGFydCB0aGVyZS4gVGhpc1xuICAgIC8vLyB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgLy8vIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gICAgLy8vIHNldCB0byBmYWxzZS5cbiAgICBlbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzID0gdHJ1ZSwgYnVmZmVycyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cyAmJiAhKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLyksIGJ1ZmZlcnMpKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnMgPyB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUoKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLykgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaWJsaW5nKGRpcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl90cmVlLl9wYXJlbnQgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLmluZGV4IDwgMCA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBwcmV2aW91cyBzaWJsaW5nLCBpZiBhbnkuXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQubm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLm1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogRG9udENhcmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgLy8vIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcl8oTkxSKSlcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIC8vLyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgLy8vIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICAvLy8gaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIC8vLyBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgLy8vIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUubm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUuY2hpbGRyZW4uc29tZShjaCA9PiBjaCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgIWNoLnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQoY2gpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGJ1ZmZlciwgbm9kZVNldCwgbWF4QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aCwgcmV1c2VkID0gW10sIG1pblJlcGVhdFR5cGUgPSBub2RlU2V0LnR5cGVzLmxlbmd0aCB9ID0gZGF0YTtcbiAgICBsZXQgY3Vyc29yID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gbmV3IEZsYXRCdWZmZXJDdXJzb3IoYnVmZmVyLCBidWZmZXIubGVuZ3RoKSA6IGJ1ZmZlcjtcbiAgICBsZXQgdHlwZXMgPSBub2RlU2V0LnR5cGVzO1xuICAgIGxldCBjb250ZXh0SGFzaCA9IDAsIGxvb2tBaGVhZCA9IDA7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgbGV0IGxvb2tBaGVhZEF0U3RhcnQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHdoaWxlIChzaXplIDwgMCkge1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChzaXplID09IC0xIC8qIFJldXNlICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXVzZWRbaWRdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIExvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnJlY29nbml6ZWQgcmVjb3JkIHNpemU6ICR7c2l6ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2lkXSwgbm9kZSwgYnVmZmVyO1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBzdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPD0gbWF4QnVmZmVyTGVuZ3RoICYmIChidWZmZXIgPSBmaW5kQnVmZmVyU2l6ZShjdXJzb3IucG9zIC0gbWluUG9zLCBpblJlcGVhdCkpKSB7XG4gICAgICAgICAgICAvLyBTbWFsbCBlbm91Z2ggZm9yIGEgYnVmZmVyLCBhbmQgbm8gcmV1c2VkIG5vZGVzIGluc2lkZVxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNpemUgLSBidWZmZXIuc2tpcCk7XG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIGJ1ZmZlci5zaXplLCBpbmRleCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyLnN0YXJ0LCBkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICBub2RlID0gbmV3IFRyZWVCdWZmZXIoZGF0YSwgZW5kIC0gYnVmZmVyLnN0YXJ0LCBub2RlU2V0KTtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gYnVmZmVyLnN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE1ha2UgaXQgYSBub2RlXG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIHNpemU7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBsb2NhbEluUmVwZWF0ID0gaWQgPj0gbWluUmVwZWF0VHlwZSA/IGlkIDogLTE7XG4gICAgICAgICAgICBsZXQgbGFzdEdyb3VwID0gMCwgbGFzdEVuZCA9IGVuZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBjdXJzb3IuaWQgPT0gbG9jYWxJblJlcGVhdCAmJiBjdXJzb3Iuc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZW5kIDw9IGxhc3RFbmQgLSBtYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBjdXJzb3IuZW5kLCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHcm91cCA9IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVuZCA9IGN1cnNvci5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VOb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsb2NhbEluUmVwZWF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGxhc3RHcm91cCA+IDAgJiYgbGFzdEdyb3VwIDwgbG9jYWxDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2UgPSBtYWtlQmFsYW5jZWQodHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUJhbGFuY2VkKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSAwLCBsYXN0SSA9IGNoaWxkcmVuLmxlbmd0aCAtIDEsIGxhc3QsIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICBpZiAobGFzdEkgPj0gMCAmJiAobGFzdCA9IGNoaWxkcmVuW2xhc3RJXSkgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0SSAmJiBsYXN0LnR5cGUgPT0gdHlwZSAmJiBsYXN0Lmxlbmd0aCA9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsb29rQWhlYWRQcm9wID0gbGFzdC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCkpXG4gICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IHBvc2l0aW9uc1tsYXN0SV0gKyBsYXN0Lmxlbmd0aCArIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUmVwZWF0TGVhZihjaGlsZHJlbiwgcG9zaXRpb25zLCBiYXNlLCBpLCBmcm9tLCB0bywgdHlwZSwgbG9va0FoZWFkKSB7XG4gICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggPiBpKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW4ucG9wKCkpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnMucG9wKCkgKyBiYXNlIC0gZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVHJlZShub2RlU2V0LnR5cGVzW3R5cGVdLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgdG8gLSBmcm9tLCBsb29rQWhlYWQgLSB0bykpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gYmFzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkID0gMCwgcHJvcHMpIHtcbiAgICAgICAgaWYgKGNvbnRleHRIYXNoKSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5jb250ZXh0SGFzaCwgY29udGV4dEhhc2hdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiAyNSkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AubG9va0FoZWFkLCBsb29rQWhlYWRdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHByb3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEJ1ZmZlclNpemUobWF4U2l6ZSwgaW5SZXBlYXQpIHtcbiAgICAgICAgLy8gU2NhbiB0aHJvdWdoIHRoZSBidWZmZXIgdG8gZmluZCBwcmV2aW91cyBzaWJsaW5ncyB0aGF0IGZpdFxuICAgICAgICAvLyB0b2dldGhlciBpbiBhIFRyZWVCdWZmZXIsIGFuZCBkb24ndCBjb250YWluIGFueSByZXVzZWQgbm9kZXNcbiAgICAgICAgLy8gKHdoaWNoIGNhbid0IGJlIHN0b3JlZCBpbiBhIGJ1ZmZlcikuXG4gICAgICAgIC8vIElmIGBpblJlcGVhdGAgaXMgPiAtMSwgaWdub3JlIG5vZGUgYm91bmRhcmllcyBvZiB0aGF0IHR5cGUgZm9yXG4gICAgICAgIC8vIG5lc3RpbmcsIGJ1dCBtYWtlIHN1cmUgdGhlIGVuZCBmYWxscyBlaXRoZXIgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIChgbWF4U2l6ZWApIG9yIGJlZm9yZSBzdWNoIGEgbm9kZS5cbiAgICAgICAgbGV0IGZvcmsgPSBjdXJzb3IuZm9yaygpO1xuICAgICAgICBsZXQgc2l6ZSA9IDAsIHN0YXJ0ID0gMCwgc2tpcCA9IDAsIG1pblN0YXJ0ID0gZm9yay5lbmQgLSBtYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHNpemU6IDAsIHN0YXJ0OiAwLCBza2lwOiAwIH07XG4gICAgICAgIHNjYW46IGZvciAobGV0IG1pblBvcyA9IGZvcmsucG9zIC0gbWF4U2l6ZTsgZm9yay5wb3MgPiBtaW5Qb3M7KSB7XG4gICAgICAgICAgICBsZXQgbm9kZVNpemUgPSBmb3JrLnNpemU7XG4gICAgICAgICAgICAvLyBQcmV0ZW5kIG5lc3RlZCByZXBlYXQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBkb24ndCBleGlzdFxuICAgICAgICAgICAgaWYgKGZvcmsuaWQgPT0gaW5SZXBlYXQgJiYgbm9kZVNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgICAgICAgICBza2lwICs9IDQ7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0UG9zID0gZm9yay5wb3MgLSBub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChub2RlU2l6ZSA8IDAgfHwgc3RhcnRQb3MgPCBtaW5Qb3MgfHwgZm9yay5zdGFydCA8IG1pblN0YXJ0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGxvY2FsU2tpcHBlZCA9IGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSA/IDQgOiAwO1xuICAgICAgICAgICAgbGV0IG5vZGVTdGFydCA9IGZvcmsuc3RhcnQ7XG4gICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlIChmb3JrLnBvcyA+IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChzaXplID49IDAgJiYgaWQgPCBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgZGF0YS5idWZmZXJTdGFydCB8fCAwLCBjaGlsZHJlbiwgcG9zaXRpb25zLCAtMSk7XG4gICAgbGV0IGxlbmd0aCA9IChfYSA9IGRhdGEubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoY2hpbGRyZW4ubGVuZ3RoID8gcG9zaXRpb25zWzBdICsgY2hpbGRyZW5bMF0ubGVuZ3RoIDogMCk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKHR5cGVzW2RhdGEudG9wSURdLCBjaGlsZHJlbi5yZXZlcnNlKCksIHBvc2l0aW9ucy5yZXZlcnNlKCksIGxlbmd0aCk7XG59XG5jb25zdCBub2RlU2l6ZUNhY2hlID0gbmV3IFdlYWtNYXA7XG5mdW5jdGlvbiBub2RlU2l6ZShiYWxhbmNlVHlwZSwgbm9kZSkge1xuICAgIGlmICghYmFsYW5jZVR5cGUuaXNBbm9ueW1vdXMgfHwgbm9kZSBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgbm9kZS50eXBlICE9IGJhbGFuY2VUeXBlKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgc2l6ZSA9IG5vZGVTaXplQ2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9IGJhbGFuY2VUeXBlIHx8ICEoY2hpbGQgaW5zdGFuY2VvZiBUcmVlKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVTaXplQ2FjaGUuc2V0KG5vZGUsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VSYW5nZShcbi8vIFRoZSB0eXBlIHRoZSBiYWxhbmNlZCB0cmVlJ3MgaW5uZXIgbm9kZXMuXG5iYWxhbmNlVHlwZSwgXG4vLyBUaGUgZGlyZWN0IGNoaWxkcmVuIGFuZCB0aGVpciBwb3NpdGlvbnNcbmNoaWxkcmVuLCBwb3NpdGlvbnMsIFxuLy8gVGhlIGluZGV4IHJhbmdlIGluIGNoaWxkcmVuL3Bvc2l0aW9ucyB0byB1c2VcbmZyb20sIHRvLCBcbi8vIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgbm9kZXMsIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudC5cbnN0YXJ0LCBcbi8vIExlbmd0aCBvZiB0aGUgb3V0ZXIgbm9kZVxubGVuZ3RoLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIHRoZSB0b3Agbm9kZSBvZiB0aGUgYmFsYW5jZWQgdHJlZVxubWtUb3AsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgaW50ZXJuYWwgbm9kZXMgZm9yIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RyZWUpIHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgICAgdG90YWwgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICBsZXQgbWF4Q2hpbGQgPSBNYXRoLmNlaWwoKHRvdGFsICogMS41KSAvIDggLyogQnJhbmNoRmFjdG9yICovKTtcbiAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBGcm9tID0gaSwgZ3JvdXBTdGFydCA9IHBvc2l0aW9uc1tpXSwgZ3JvdXBTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0U2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSArIG5leHRTaXplID49IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBncm91cFNpemUgKz0gbmV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSA+IG1heENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTsgLy8gT25seSB0cmVlcyBjYW4gaGF2ZSBhIHNpemUgPiAxXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZShvbmx5LmNoaWxkcmVuLCBvbmx5LnBvc2l0aW9ucywgMCwgb25seS5jaGlsZHJlbi5sZW5ndGgsIHBvc2l0aW9uc1tncm91cEZyb21dICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQ7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGJhbGFuY2VSYW5nZShiYWxhbmNlVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZ3JvdXBGcm9tLCBpLCBncm91cFN0YXJ0LCBsZW5ndGgsIG51bGwsIG1rVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0ICsgb2Zmc2V0IC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgMCk7XG4gICAgcmV0dXJuIChta1RvcCB8fCBta1RyZWUpKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsZW5ndGgpO1xufVxuXG4vLy8gVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxuLy8vIHBhcnNpbmddKCNjb21tb24uUGFyc2VyLnN0YXJ0UGFyc2UpIHRvIHRyYWNrIHBhcnRzIG9mIG9sZCB0cmVlc1xuLy8vIHRoYXQgY2FuIGJlIHJldXNlZCBpbiBhIG5ldyBwYXJzZS4gQW4gYXJyYXkgb2YgZnJhZ21lbnRzIGlzIHVzZWRcbi8vLyB0byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbi8vLyBwYXJzZXMuIFVzZSB0aGUgc3RhdGljXG4vLy8gW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0b1xuLy8vIHVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgLy8vIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgLy8vIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICBmcm9tLCBcbiAgICAvLy8gVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgIHRvLCBcbiAgICAvLy8gVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgIHRyZWUsIFxuICAgIC8vLyBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICAvLy8gdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICAvLy8gZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIC8vLyBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgb2Zmc2V0LCBvcGVuU3RhcnQgPSBmYWxzZSwgb3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IChvcGVuU3RhcnQgPyAxIC8qIFN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogRW5kICovIDogMCk7XG4gICAgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgYVxuICAgIC8vLyBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIC8vLyBiZSBzYWZlIHRvIHJldXNlIHNvbWUgbm9kZXMgYXQgdGhlIHN0YXJ0LCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8vIHBhcnNpbmcgYWxnb3JpdGhtLilcbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogU3RhcnQgKi8pID4gMDsgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhXG4gICAgLy8vIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIEVuZCAqLykgPiAwOyB9XG4gICAgLy8vIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIC8vLyBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICAvLy8gd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIC8vLyB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIC8vLyBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgLy8vIHRydWUuXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICAvLy8gc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIC8vLyBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICAvLy8gb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgLy8vIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIC8vL1xuICAgIC8vLyBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIC8vLyB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICAvLy8gcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIC8vLyBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLy8vIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vLy8gQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuLy8vIHNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuLy8vIGZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG4vLy8gYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG4vLy8gdHJlZS5cbi8vL1xuLy8vIFRoZSBuZXN0aW5nIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGN1cnNvciB0byBwcm92aWRlIGNvbnRleHQgZm9yIGFcbi8vLyBub2RlLCBidXQgX3Nob3VsZCBub3RfIG1vdmUgdGhhdCBjdXJzb3IsIG9ubHkgaW5zcGVjdCBpdHNcbi8vLyBwcm9wZXJ0aWVzIGFuZCBvcHRpb25hbGx5IGFjY2VzcyBpdHNcbi8vLyBbbm9kZSBvYmplY3RdKCNjb21tb24uVHJlZUN1cnNvci5ub2RlKS5cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLnJhbmdlc1swXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCAxIC8qIEZ1bGwgKi8pO1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBuZXN0LCBpc0NvdmVyZWQ7IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgfHwgY3Vyc29yLmZyb20gPCB0aGlzLnN0b3BwZWRBdDspIHtcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50Q3Vyc29yLmhhc05vZGUoY3Vyc29yKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IG92ZXJsYXkubW91bnRzLmZpbmQobSA9PiBtLmZyYWcuZnJvbSA8PSBjdXJzb3IuZnJvbSAmJiBtLmZyYWcudG8gPj0gY3Vyc29yLnRvICYmIG0ubW91bnQub3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgbWF0Y2gubW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gci5mcm9tICsgbWF0Y2gucG9zLCB0byA9IHIudG8gKyBtYXRjaC5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPj0gY3Vyc29yLmZyb20gJiYgdG8gPD0gY3Vyc29yLnRvICYmICFvdmVybGF5LnJhbmdlcy5zb21lKHIgPT4gci5mcm9tIDwgdG8gJiYgci50byA+IGZyb20pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3ZlcmVkICYmIChpc0NvdmVyZWQgPSBjaGVja0NvdmVyKGNvdmVyZWQucmFuZ2VzLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKSkpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGlzQ292ZXJlZCAhPSAyIC8qIEZ1bGwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLnR5cGUuaXNBbm9ueW1vdXMgJiYgY3Vyc29yLmZyb20gPCBjdXJzb3IudG8gJiYgKG5lc3QgPSB0aGlzLm5lc3QoY3Vyc29yLCB0aGlzLmlucHV0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbGl6ZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGxldCBvbGRNb3VudHMgPSBmcmFnbWVudEN1cnNvci5maW5kTW91bnRzKGN1cnNvci5mcm9tLCBuZXN0LnBhcnNlcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXN0Lm92ZXJsYXkgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBuZXcgQWN0aXZlT3ZlcmxheShuZXN0LnBhcnNlciwgbmVzdC5vdmVybGF5LCBvbGRNb3VudHMsIHRoaXMuaW5uZXIubGVuZ3RoLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRyZWUsIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBuZXN0Lm92ZXJsYXkgfHwgW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIucHVzaChuZXcgSW5uZXJQYXJzZShuZXN0LnBhcnNlciwgbmVzdC5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvbGRNb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG5lc3Qub3ZlcmxheSA/IG5lc3Qub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gY3Vyc29yLmZyb20sIHIudG8gLSBjdXJzb3IuZnJvbSkpIDogbnVsbCwgY3Vyc29yLnRyZWUsIHJhbmdlcykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5lc3Qub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0geyByYW5nZXMsIGRlcHRoOiAwLCBwcmV2OiBjb3ZlcmVkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAmJiAocmFuZ2UgPSBvdmVybGF5LnByZWRpY2F0ZShjdXJzb3IpKSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPCByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50ZXIgJiYgY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmRlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgJiYgIS0tb3ZlcmxheS5kZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBvdmVybGF5LnJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnNwbGljZShvdmVybGF5LmluZGV4LCAwLCBuZXcgSW5uZXJQYXJzZShvdmVybGF5LnBhcnNlciwgb3ZlcmxheS5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvdmVybGF5Lm1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgb3ZlcmxheS5yYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIG92ZXJsYXkuc3RhcnQsIHIudG8gLSBvdmVybGF5LnN0YXJ0KSksIG92ZXJsYXkudGFyZ2V0LCByYW5nZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSBjb3ZlcmVkLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tDb3Zlcihjb3ZlcmVkLCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIGNvdmVyZWQpIHtcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZnJvbSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIEZ1bGwgKi8gOiAxIC8qIFBhcnRpYWwgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59XG4vLyBUYWtlIGEgcGllY2Ugb2YgYnVmZmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYSBzdGFuZC1hbG9uZVxuLy8gVHJlZUJ1ZmZlci5cbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcbiAgICBpZiAoc3RhcnRJIDwgZW5kSSkge1xuICAgICAgICBsZXQgZnJvbSA9IGJ1Zi5idWZmZXJbc3RhcnRJICsgMV0sIHRvID0gYnVmLmJ1ZmZlcltlbmRJIC0gMl07XG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBkZXB0aCA9IDA7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xuICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgIG9mZiA9IGJhc2UucG9zaXRpb25zW2ldICsgY3Vyc29yLmZyb207XG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBsZXQgaSA9IHN0YXJ0STtcbiAgICAgICAgd2hpbGUgKGJbaSArIDJdICsgb2ZmIDw9IG5vZGUuZnJvbSlcbiAgICAgICAgICAgIGkgPSBiW2kgKyAzXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgaSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbaSArIDFdLCB0byA9IGJbaSArIDJdO1xuICAgICAgICBsZXQgaXNUYXJnZXQgPSBmcm9tICsgb2ZmID09IG5vZGUuZnJvbSAmJiB0byArIG9mZiA9PSBub2RlLnRvICYmIGJbaV0gPT0gbm9kZS50eXBlLmlkO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGlzVGFyZ2V0ID8gbm9kZS50b1RyZWUoKSA6IHNwbGl0KGkgKyA0LCBiW2kgKyAzXSwgYnVmLnNldC50eXBlc1tiW2ldXSwgZnJvbSwgdG8gLSBmcm9tKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XG4gICAgICAgIHNsaWNlQnVmKGJ1ZiwgYltpICsgM10sIGVuZEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIGJhc2UuY2hpbGRyZW5baV0gPSBzcGxpdCgwLCBiLmxlbmd0aCwgTm9kZVR5cGUubm9uZSwgMCwgYnVmLmxlbmd0aCk7XG4gICAgLy8gTW92ZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPD0gZGVwdGg7IGQrKylcbiAgICAgICAgY3Vyc29yLmNoaWxkQWZ0ZXIobm9kZS5mcm9tKTtcbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmZ1bGxDdXJzb3IoKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBmYWxzZSwgZmFsc2UpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLm5leHQoZmFsc2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oY3Vyc29yLmZyb20pO1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSAmJiB0aGlzLmN1cnNvci5mcm9tICsgdGhpcy5vZmZzZXQgPT0gY3Vyc29yLmZyb20gJiYgdGhpcy5jdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSA9IHRoaXMuY3Vyc29yLnRyZWU7Oykge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlID09IGN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJlZS5jaGlsZHJlbi5sZW5ndGggJiYgdHJlZS5wb3NpdGlvbnNbMF0gPT0gMCAmJiB0cmVlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmN1clRvID0gMDtcbiAgICAgICAgdGhpcy5mcmFnSSA9IDA7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmN1ckZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZmlyc3QudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpcnN0LnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZmlyc3QudHJlZSwgLWZpcnN0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VyRnJhZyAmJiBub2RlLmZyb20gPj0gdGhpcy5jdXJUbylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyRnJhZyAmJiB0aGlzLmN1ckZyYWcuZnJvbSA8PSBub2RlLmZyb20gJiYgdGhpcy5jdXJUbyA+PSBub2RlLnRvICYmIHRoaXMuaW5uZXIuaGFzTm9kZShub2RlKTtcbiAgICB9XG4gICAgbmV4dEZyYWcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xuICAgICAgICBpZiAodGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1ckZyYWcgPSB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdJXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmcmFnLnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmcmFnLnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZnJhZy50cmVlLCAtZnJhZy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRNb3VudHMocG9zLCBwYXJzZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyLmN1cnNvci5tb3ZlVG8ocG9zLCAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBtb3VudCA9IChfYSA9IHBvcy50cmVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQucGFyc2VyID09IHBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFnSTsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZnJvbSA+PSBwb3MudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy50cmVlID09IHRoaXMuY3VyRnJhZy50cmVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3MuZnJvbSAtIGZyYWcub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVuY2hSYW5nZXMob3V0ZXIsIHJhbmdlcykge1xuICAgIGxldCBjb3B5ID0gbnVsbCwgY3VycmVudCA9IHJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG91dGVyW2kgLSAxXS50bywgZ2FwVG8gPSBvdXRlcltpXS5mcm9tO1xuICAgICAgICBmb3IgKDsgaiA8IGN1cnJlbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByID0gY3VycmVudFtqXTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gZ2FwVG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA8PSBnYXBGcm9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb3B5ID0gcmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoci5mcm9tIDwgZ2FwRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvcHlbal0gPSBuZXcgUmFuZ2Uoci5mcm9tLCBnYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoci50byA+IGdhcFRvKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqICsgMSwgMCwgbmV3IFJhbmdlKGdhcFRvLCByLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyLnRvID4gZ2FwVG8pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2otLV0gPSBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGZpbmRDb3ZlckNoYW5nZXMoYSwgYiwgZnJvbSwgdG8pIHtcbiAgICBsZXQgaUEgPSAwLCBpQiA9IDAsIGluQSA9IGZhbHNlLCBpbkIgPSBmYWxzZSwgcG9zID0gLTFlOTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbmV4dEEgPSBpQSA9PSBhLmxlbmd0aCA/IDFlOSA6IGluQSA/IGFbaUFdLnRvIDogYVtpQV0uZnJvbTtcbiAgICAgICAgbGV0IG5leHRCID0gaUIgPT0gYi5sZW5ndGggPyAxZTkgOiBpbkIgPyBiW2lCXS50byA6IGJbaUJdLmZyb207XG4gICAgICAgIGlmIChpbkEgIT0gaW5CKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIsIHRvKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IE1hdGgubWluKG5leHRBLCBuZXh0Qik7XG4gICAgICAgIGlmIChwb3MgPT0gMWU5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0QSA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5BKVxuICAgICAgICAgICAgICAgIGluQSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0QiA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5CKVxuICAgICAgICAgICAgICAgIGluQiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBHaXZlbiBhIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoZSBvdXRlciB0cmVlLCBhbmQgYSBzZXQgb2YgcmFuZ2VzXG4vLyB0byBwYXJzZSwgZmluZCBmcmFnbWVudHMgZm9yIGlubmVyIHRyZWVzIG1vdW50ZWQgYXJvdW5kIHRob3NlXG4vLyByYW5nZXMsIGlmIGFueS5cbmZ1bmN0aW9uIGVudGVyRnJhZ21lbnRzKG1vdW50cywgcmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgcG9zLCBtb3VudCwgZnJhZyB9IG9mIG1vdW50cykge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBwb3MgKyAobW91bnQub3ZlcmxheSA/IG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA6IDApLCBlbmRQb3MgPSBzdGFydFBvcyArIG1vdW50LnRyZWUubGVuZ3RoO1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KGZyYWcuZnJvbSwgc3RhcnRQb3MpLCB0byA9IE1hdGgubWluKGZyYWcudG8sIGVuZFBvcyk7XG4gICAgICAgIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxheSA9IG1vdW50Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSArIHBvcywgci50byArIHBvcykpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBmaW5kQ292ZXJDaGFuZ2VzKHJhbmdlcywgb3ZlcmxheSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IGZyb207OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gY2hhbmdlcy5sZW5ndGgsIGVuZCA9IGxhc3QgPyB0byA6IGNoYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KHBvcywgZW5kLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBwb3MsIGZyYWcudG8gPD0gZW5kKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IGNoYW5nZXNbaV0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KGZyb20sIHRvLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBzdGFydFBvcywgZnJhZy50byA8PSBlbmRQb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBNb3VudGVkVHJlZSwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBQYXJzZXIsIFRyZWUsIFRyZWVCdWZmZXIsIFRyZWVDdXJzb3IsIFRyZWVGcmFnbWVudCwgcGFyc2VNaXhlZCB9O1xuIiwiaW1wb3J0IHsgUGFyc2VyLCBOb2RlU2V0LCBOb2RlVHlwZSwgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgTm9kZVByb3AsIFRyZWUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLy8vIEEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xuLy8vIHBhcnNpbmcgcHJvZ3Jlc3MuIFRoZXkgYWxzbyBwcm92aWRlIHNvbWUgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xuLy8vIHRoYXQgZXh0ZXJuYWwgY29kZSBzdWNoIGFzIGEgdG9rZW5pemVyIGNhbiB1c2UgdG8gZ2V0IGluZm9ybWF0aW9uXG4vLy8gYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuY2xhc3MgU3RhY2sge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHBhcnNlIHRoYXQgdGhpcyBzdGFjayBpcyBwYXJ0IG9mIEBpbnRlcm5hbFxuICAgIHAsIFxuICAgIC8vLyBIb2xkcyBzdGF0ZSwgaW5wdXQgcG9zLCBidWZmZXIgaW5kZXggdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSBAaW50ZXJuYWxcbiAgICBzdGFjaywgXG4gICAgLy8vIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgIHN0YXRlLCBcbiAgICAvLyBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIG5leHQgcmVkdWNlIHNob3VsZCB0YWtlIHBsYWNlLiBUaGlzXG4gICAgLy8gY2FuIGJlIGxlc3MgdGhhbiBgdGhpcy5wb3NgIHdoZW4gc2tpcHBlZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgc3RhY2sgKHdoaWNoIHNob3VsZCBiZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBuZXh0XG4gICAgLy8gcmVkdWN0aW9uKVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2VQb3MsIFxuICAgIC8vLyBUaGUgaW5wdXQgcG9zaXRpb24gdXAgdG8gd2hpY2ggdGhpcyBzdGFjayBoYXMgcGFyc2VkLlxuICAgIHBvcywgXG4gICAgLy8vIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIC8vLyBhbmQgZXJyb3ItcmVjb3ZlcnkgcGVuYWx0aWVzXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyQmFzZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGN1ckNvbnRleHQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBsb29rQWhlYWQgPSAwLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcmVudCkge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSByZWR1Y2VQb3M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlckJhc2UgPSBidWZmZXJCYXNlO1xuICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBjdXJDb250ZXh0O1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YWNrLmZpbHRlcigoXywgaSkgPT4gaSAlIDMgPT0gMCkuY29uY2F0KHRoaXMuc3RhdGUpfV1AJHt0aGlzLnBvc30ke3RoaXMuc2NvcmUgPyBcIiFcIiArIHRoaXMuc2NvcmUgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRpYyBzdGFydChwLCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICBsZXQgY3ggPSBwLnBhcnNlci5jb250ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHAsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBjeCA/IG5ldyBTdGFja0NvbnRleHQoY3gsIGN4LnN0YXJ0KSA6IG51bGwsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gVGhlIHN0YWNrJ3MgY3VycmVudCBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyKSB2YWx1ZSwgaWZcbiAgICAvLy8gYW55LiBJdHMgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgY29udGV4dCB0cmFja2VyJ3MgdHlwZVxuICAgIC8vLyBwYXJhbWV0ZXIsIG9yIGl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGNvbnRleHRcbiAgICAvLy8gdHJhY2tlci5cbiAgICBnZXQgY29udGV4dCgpIHsgcmV0dXJuIHRoaXMuY3VyQ29udGV4dCA/IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0IDogbnVsbDsgfVxuICAgIC8vIFB1c2ggYSBzdGF0ZSBvbnRvIHRoZSBzdGFjaywgdHJhY2tpbmcgaXRzIHN0YXJ0IHBvc2l0aW9uIGFzIHdlbGxcbiAgICAvLyBhcyB0aGUgYnVmZmVyIGJhc2UgYXQgdGhhdCBwb2ludC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBsZXQgZFByZWMgPSBwYXJzZXIuZHluYW1pY1ByZWNlZGVuY2UodHlwZSk7XG4gICAgICAgIGlmIChkUHJlYylcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gZFByZWM7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwYXJzZXIuZ2V0R290byh0aGlzLnN0YXRlLCB0eXBlLCB0cnVlKSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLyA/IDYgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFja1tiYXNlIC0gMl07XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gdGhpcy5zdGFja1tiYXNlIC0gMV0sIGNvdW50ID0gdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoIC0gYnVmZmVyQmFzZTtcbiAgICAgICAgLy8gU3RvcmUgbm9ybWFsIHRlcm1zIG9yIGBSIC0+IFIgUmAgcmVwZWF0IHJlZHVjdGlvbnNcbiAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSB8fCAoYWN0aW9uICYgMTMxMDcyIC8qIFJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmFzZVN0YXRlSUQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAzXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJzZXIuZ2V0R290byhiYXNlU3RhdGVJRCwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gYmFzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgfVxuICAgIC8vIFNoaWZ0IGEgdmFsdWUgaW50byB0aGUgYnVmZmVyXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0b3JlTm9kZSh0ZXJtLCBzdGFydCwgZW5kLCBzaXplID0gNCwgaXNSZWR1Y2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGVybSA9PSAwIC8qIEVyciAqLykgeyAvLyBUcnkgdG8gb21pdC9tZXJnZSBhZGphY2VudCBlcnJvciBub2Rlc1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMsIHRvcCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3AgPT0gMCAmJiBjdXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gY3VyLmJ1ZmZlckJhc2UgLSBjdXIucGFyZW50LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgPiAwICYmIGN1ci5idWZmZXJbdG9wIC0gNF0gPT0gMCAvKiBFcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZHVjZSB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSAyXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoaXMgcmVjb3JkIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGhpcy5idWZmZXJbaW5kZXggLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gM107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gdGhpcy5idWZmZXJbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSAtPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRlcm07XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYSBzaGlmdCBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBpZiAoYWN0aW9uICYgMTMxMDcyIC8qIEdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovKSA9PSAwKSB7IC8vIFJlZ3VsYXIgc2hpZnRcbiAgICAgICAgICAgIGxldCBuZXh0U3RhdGUgPSBhY3Rpb24sIHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgICAgICBpZiAobmV4dEVuZCA+IHRoaXMucG9zIHx8IG5leHQgPD0gcGFyc2VyLm1heE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuc3RhdGVGbGFnKG5leHRTdGF0ZSwgMSAvKiBTa2lwcGVkICovKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHN0YXJ0LCBuZXh0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCBzdGFydCwgbmV4dEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGFwcGx5KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLylcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgKHJldXNlZCkgbm9kZSBpbnRvIHRoZSBidWZmZXIuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHVzZU5vZGUodmFsdWUsIG5leHQpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5wLnJldXNlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMucC5yZXVzZWRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnAucmV1c2VkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcyA9IHN0YXJ0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0LCBzdGFydCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5kZXgsIHN0YXJ0LCB0aGlzLnJlZHVjZVBvcywgLTEgLyogc2l6ZSA9PSAtMSBtZWFucyB0aGlzIGlzIGEgcmV1c2VkIHZhbHVlICovKTtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZXVzZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdmFsdWUsIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQodGhpcy5wb3MgLSB2YWx1ZS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IHRoZSBzdGFjay4gRHVlIHRvIHRoZSBidWZmZXIgc2hhcmluZyBhbmQgdGhlIGZhY3RcbiAgICAvLyB0aGF0IGB0aGlzLnN0YWNrYCB0ZW5kcyB0byBzdGF5IHF1aXRlIHNoYWxsb3csIHRoaXMgaXNuJ3QgdmVyeVxuICAgIC8vIGV4cGVuc2l2ZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgb2ZmID0gcGFyZW50LmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHRvcCBvZiB0aGUgYnVmZmVyIChhZnRlciB0aGlzLnBvcykgbWF5IGJlIG11dGF0ZWRcbiAgICAgICAgLy8gdG8gcmVvcmRlciByZWR1Y3Rpb25zIGFuZCBza2lwcGVkIHRva2VucywgYW5kIHNoYXJlZCBidWZmZXJzXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbW11dGFibGUsIHRoaXMgY29waWVzIGFueSBvdXRzdGFuZGluZyBza2lwcGVkIHRva2Vuc1xuICAgICAgICAvLyB0byB0aGUgbmV3IGJ1ZmZlciwgYW5kIHB1dHMgdGhlIGJhc2UgcG9pbnRlciBiZWZvcmUgdGhlbS5cbiAgICAgICAgd2hpbGUgKG9mZiA+IDAgJiYgcGFyZW50LmJ1ZmZlcltvZmYgLSAyXSA+IHBhcmVudC5yZWR1Y2VQb3MpXG4gICAgICAgICAgICBvZmYgLT0gNDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHBhcmVudC5idWZmZXIuc2xpY2Uob2ZmKSwgYmFzZSA9IHBhcmVudC5idWZmZXJCYXNlICsgb2ZmO1xuICAgICAgICAvLyBNYWtlIHN1cmUgcGFyZW50IHBvaW50cyB0byBhbiBhY3R1YWwgcGFyZW50IHdpdGggY29udGVudCwgaWYgdGhlcmUgaXMgc3VjaCBhIHBhcmVudC5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBiYXNlID09IHBhcmVudC5idWZmZXJCYXNlKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayh0aGlzLnAsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHRoaXMuY3VyQ29udGV4dCwgdGhpcy5sb29rQWhlYWQsIHBhcmVudCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5RGVsZXRlKG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IGlzTm9kZSA9IG5leHQgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlO1xuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQsIDQpO1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMTkwIC8qIERlbGV0ZSAqLztcbiAgICB9XG4gICAgLy8vIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICAgIC8vLyBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICAvLy8gZXh0ZXJuYWwgdG9rZW5pemVycyB0aGF0IHdhbnQgdG8gbWFrZSBzdXJlIHRoZXkgb25seSBwcm92aWRlIGFcbiAgICAvLy8gZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAgIGNhblNoaWZ0KHRlcm0pIHtcbiAgICAgICAgZm9yIChsZXQgc2ltID0gbmV3IFNpbXVsYXRlZFN0YWNrKHRoaXMpOzspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdChzaW0uc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLykgfHwgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24oc2ltLnN0YXRlLCB0ZXJtKTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdXAgdG8gUmVjb3Zlci5NYXhOZXh0IHJlY292ZXJ5IGFjdGlvbnMgdGhhdCBjb25jZXB0dWFsbHlcbiAgICAvLyBpbnNlcnRzIHNvbWUgbWlzc2luZyB0b2tlbiBvciBydWxlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlJbnNlcnQobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwIC8qIE1heEluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBuZXh0U3RhdGVzID0gdGhpcy5wLnBhcnNlci5uZXh0U3RhdGVzKHRoaXMuc3RhdGUpO1xuICAgICAgICBpZiAobmV4dFN0YXRlcy5sZW5ndGggPiA0IC8qIE1heE5leHQgKi8gPDwgMSB8fCB0aGlzLnN0YWNrLmxlbmd0aCA+PSAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLykge1xuICAgICAgICAgICAgbGV0IGJlc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICgocyA9IG5leHRTdGF0ZXNbaSArIDFdKSAhPSB0aGlzLnN0YXRlICYmIHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHMsIG5leHQpKVxuICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgYmVzdC5sZW5ndGggPCA0IC8qIE1heE5leHQgKi8gPDwgMSAmJiBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3Quc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICBpZiAocyA9PSB0aGlzLnN0YXRlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgc3RhY2suc3RvcmVOb2RlKDAgLyogRXJyICovLCBzdGFjay5wb3MsIHN0YWNrLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFjay5wdXNoU3RhdGUocywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc2hpZnRDb250ZXh0KG5leHRTdGF0ZXNbaV0sIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnNjb3JlIC09IDIwMCAvKiBJbnNlcnQgKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlUmVkdWNlKCkge1xuICAgICAgICBsZXQgcmVkdWNlID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNSAvKiBGb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBpZiAoIXBhcnNlci52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCByZWR1Y2UpKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSByZWR1Y2UgPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLywgdGVybSA9IHJlZHVjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLztcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIGRlcHRoICogMztcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPCAwIHx8IHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgLT0gMTAwIC8qIFJlZHVjZSAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZShyZWR1Y2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlQWxsKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMucC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogQWNjZXB0aW5nICovKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcmNlUmVkdWNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBoYXMgbm8gZnVydGhlciBhY3Rpb25zIChhc3N1bWVkIHRvIGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSwgc2luY2UgYW55IG90aGVyIHN0YXRlcyBtdXN0IGJlIGFibGUgdG8gY29udGludWVcbiAgICAvLy8gc29tZWhvdykuIEBpbnRlcm5hbFxuICAgIGdldCBkZWFkRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGF0YVtwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDEgLyogQWN0aW9ucyAqLyldID09IDY1NTM1IC8qIEVuZCAqLyAmJlxuICAgICAgICAgICAgIXBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKTtcbiAgICB9XG4gICAgLy8vIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICAvLy8gd2hlbiB0aGlzLnN0YWNrLmxlbmd0aCA9PSAzIChzdGF0ZSBpcyBkaXJlY3RseSBiZWxvdyB0aGUgdG9wXG4gICAgLy8vIHN0YXRlKS4gQGludGVybmFsXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNhbWVTdGF0ZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPSBvdGhlci5zdGF0ZSB8fCB0aGlzLnN0YWNrLmxlbmd0aCAhPSBvdGhlci5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrW2ldICE9IG90aGVyLnN0YWNrW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgZ2V0IHBhcnNlcigpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXI7IH1cbiAgICAvLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gZGlhbGVjdCAoYnkgbnVtZXJpYyBJRCwgYXMgZXhwb3J0ZWQgZnJvbVxuICAgIC8vLyB0aGUgdGVybXMgZmlsZSkgaXMgZW5hYmxlZC5cbiAgICBkaWFsZWN0RW5hYmxlZChkaWFsZWN0SUQpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXIuZGlhbGVjdC5mbGFnc1tkaWFsZWN0SURdOyB9XG4gICAgc2hpZnRDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc2hpZnQodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIHJlZHVjZUNvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZWR1Y2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbWl0Q29udGV4dCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTMpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VyQ29udGV4dC5oYXNoLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIC0zKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGVtaXRMb29rQWhlYWQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC00KVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmxvb2tBaGVhZCwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCAtNCk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCAhPSB0aGlzLmN1ckNvbnRleHQuY29udGV4dCkge1xuICAgICAgICAgICAgbGV0IG5ld0N4ID0gbmV3IFN0YWNrQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlciwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAobmV3Q3guaGFzaCAhPSB0aGlzLmN1ckNvbnRleHQuaGFzaClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBuZXdDeDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2V0TG9va0FoZWFkKGxvb2tBaGVhZCkge1xuICAgICAgICBpZiAobG9va0FoZWFkID4gdGhpcy5sb29rQWhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgICAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdClcbiAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9va0FoZWFkID4gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0cmFja2VyLnN0cmljdCA/IHRyYWNrZXIuaGFzaChjb250ZXh0KSA6IDA7XG4gICAgfVxufVxudmFyIFJlY292ZXI7XG4oZnVuY3Rpb24gKFJlY292ZXIpIHtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJJbnNlcnRcIl0gPSAyMDBdID0gXCJJbnNlcnRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJEZWxldGVcIl0gPSAxOTBdID0gXCJEZWxldGVcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJSZWR1Y2VcIl0gPSAxMDBdID0gXCJSZWR1Y2VcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhOZXh0XCJdID0gNF0gPSBcIk1heE5leHRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhJbnNlcnRTdGFja0RlcHRoXCJdID0gMzAwXSA9IFwiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIl0gPSAxMjBdID0gXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCI7XG59KShSZWNvdmVyIHx8IChSZWNvdmVyID0ge30pKTtcbi8vIFVzZWQgdG8gY2hlYXBseSBydW4gc29tZSByZWR1Y3Rpb25zIHRvIHNjYW4gYWhlYWQgd2l0aG91dCBtdXRhdGluZ1xuLy8gYW4gZW50aXJlIHN0YWNrXG5jbGFzcyBTaW11bGF0ZWRTdGFjayB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFydC5zdGFjaztcbiAgICAgICAgdGhpcy5iYXNlID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgfVxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IHRlcm0gPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi87XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjayA9PSB0aGlzLnN0YXJ0LnN0YWNrKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSAtPSAoZGVwdGggLSAxKSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvdG8gPSB0aGlzLnN0YXJ0LnAucGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0aGlzLmJhc2UgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBnb3RvO1xuICAgIH1cbn1cbi8vIFRoaXMgaXMgZ2l2ZW4gdG8gYFRyZWUuYnVpbGRgIHRvIGJ1aWxkIGEgYnVmZmVyLCBhbmQgZW5jYXBzdWxhdGVzXG4vLyB0aGUgcGFyZW50LXN0YWNrLXdhbGtpbmcgbmVjZXNzYXJ5IHRvIHJlYWQgdGhlIG5vZGVzLlxuY2xhc3MgU3RhY2tCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrLCBwb3MsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBzdGFjay5idWZmZXI7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHN0YWNrLCBwb3MgPSBzdGFjay5idWZmZXJCYXNlICsgc3RhY2suYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHN0YWNrLCBwb3MsIHBvcyAtIHN0YWNrLmJ1ZmZlckJhc2UpO1xuICAgIH1cbiAgICBtYXliZU5leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5zdGFjay5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLmJ1ZmZlckJhc2UgLSBuZXh0LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV4dDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV4dC5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5pbmRleCAtPSA0O1xuICAgICAgICB0aGlzLnBvcyAtPSA0O1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgZm9yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcih0aGlzLnN0YWNrLCB0aGlzLnBvcywgdGhpcy5pbmRleCk7XG4gICAgfVxufVxuXG5jbGFzcyBDYWNoZWRUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IC0xO1xuICAgICAgICB0aGlzLmVuZCA9IC0xO1xuICAgICAgICB0aGlzLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gMDtcbiAgICAgICAgdGhpcy5tYXNrID0gMDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gMDtcbiAgICB9XG59XG5jb25zdCBudWxsVG9rZW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4vLy8gW1Rva2VuaXplcnNdKCNsci5FeHRlcm5hbFRva2VuaXplcikgaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXRcbi8vLyB0aHJvdWdoIHRoaXMgaW50ZXJmYWNlLiBJdCBwcmVzZW50cyB0aGUgaW5wdXQgYXMgYSBzdHJlYW0gb2Zcbi8vLyBjaGFyYWN0ZXJzLCB0cmFja2luZyBsb29rYWhlYWQgYW5kIGhpZGluZyB0aGUgY29tcGxleGl0eSBvZlxuLy8vIFtyYW5nZXNdKCNjb21tb24uUGFyc2VyLnBhcnNlXnJhbmdlcykgZnJvbSB0b2tlbml6ZXIgY29kZS5cbmNsYXNzIElucHV0U3RyZWFtIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGlucHV0LCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIC8vLyBCYWNrdXAgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVuazIgPSBcIlwiO1xuICAgICAgICB0aGlzLmNodW5rMlBvcyA9IDA7XG4gICAgICAgIC8vLyBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIG5leHQgY29kZSB1bml0IGluIHRoZSBpbnB1dCwgb3IgLTFcbiAgICAgICAgLy8vIHdoZW4gdGhlIHN0cmVhbSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuZW5kID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICByZXNvbHZlT2Zmc2V0KG9mZnNldCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yYW5nZSwgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghaW5kZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWy0taW5kZXhdO1xuICAgICAgICAgICAgcG9zIC09IHJhbmdlLmZyb20gLSBuZXh0LnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhc3NvYyA8IDAgPyBwb3MgPiByYW5nZS50byA6IHBvcyA+PSByYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWysraW5kZXhdO1xuICAgICAgICAgICAgcG9zICs9IG5leHQuZnJvbSAtIHJhbmdlLnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8vLyBMb29rIGF0IGEgY29kZSB1bml0IG5lYXIgdGhlIHN0cmVhbSBwb3NpdGlvbi4gYC5wZWVrKDApYCBlcXVhbHNcbiAgICAvLy8gYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICAgIC8vLyBvbi5cbiAgICAvLy9cbiAgICAvLy8gTm90ZSB0aGF0IGxvb2tpbmcgYXJvdW5kIGR1cmluZyB0b2tlbml6aW5nIGNyZWF0ZXMgZGVwZW5kZW5jaWVzXG4gICAgLy8vIG9uIHBvdGVudGlhbGx5IGZhci1hd2F5IGNvbnRlbnQsIHdoaWNoIG1heSByZWR1Y2UgdGhlXG4gICAgLy8vIGVmZmVjdGl2ZW5lc3MgaW5jcmVtZW50YWwgcGFyc2luZ+KAlHdoZW4gbG9va2luZyBmb3J3YXJk4oCUb3IgZXZlblxuICAgIC8vLyBjYXVzZSBpbnZhbGlkIHJlcGFyc2VzIHdoZW4gbG9va2luZyBiYWNrd2FyZCBtb3JlIHRoYW4gMjUgY29kZVxuICAgIC8vLyB1bml0cywgc2luY2UgdGhlIGxpYnJhcnkgZG9lcyBub3QgdHJhY2sgbG9va2JlaGluZC5cbiAgICBwZWVrKG9mZnNldCkge1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5jaHVua09mZiArIG9mZnNldCwgcG9zLCByZXN1bHQ7XG4gICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPCB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQoaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZU9mZnNldChvZmZzZXQsIDEpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcG9zID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdChwb3MgLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHRoaXMucmFuZ2VJbmRleCwgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZS50byA8PSBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5yYW5nZXNbKytpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5jaHVuazJQb3MgPSBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgKyB0aGlzLmNodW5rMi5sZW5ndGggPiByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rMi5zbGljZSgwLCByYW5nZS50byAtIHBvcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQWNjZXB0IGEgdG9rZW4uIEJ5IGRlZmF1bHQsIHRoZSBlbmQgb2YgdGhlIHRva2VuIGlzIHNldCB0byB0aGVcbiAgICAvLy8gY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICAgIC8vLyB0aGUgc3RyZWFtIHBvc2l0aW9uKSB0byBjaGFuZ2UgdGhhdC5cbiAgICBhY2NlcHRUb2tlbih0b2tlbiwgZW5kT2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZW5kID0gZW5kT2Zmc2V0ID8gdGhpcy5yZXNvbHZlT2Zmc2V0KGVuZE9mZnNldCwgLTEpIDogdGhpcy5wb3M7XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCB8fCBlbmQgPCB0aGlzLnRva2VuLnN0YXJ0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUb2tlbiBlbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgdGhpcy50b2tlbi52YWx1ZSA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgZ2V0Q2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiB0aGlzLnBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBjaHVuaywgY2h1bmtQb3MgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gdGhpcy5jaHVuazI7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5jaHVuazJQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSBjaHVua1BvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSB0aGlzLnBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICBsZXQgbmV4dENodW5rID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLnBvcyk7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgKyBuZXh0Q2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IGVuZCA+IHRoaXMucmFuZ2UudG8gPyBuZXh0Q2h1bmsuc2xpY2UoMCwgdGhpcy5yYW5nZS50byAtIHRoaXMucG9zKSA6IG5leHRDaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5jaHVua09mZiA+PSB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5nZXRDaHVuaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPT0gdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQodGhpcy5jaHVua09mZik7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRoZSBzdHJlYW0gZm9yd2FyZCBOIChkZWZhdWx0cyB0byAxKSBjb2RlIHVuaXRzLiBSZXR1cm5zXG4gICAgLy8vIHRoZSBuZXcgdmFsdWUgb2YgW2BuZXh0YF0oI2xyLklucHV0U3RyZWFtLm5leHQpLlxuICAgIGFkdmFuY2UobiA9IDEpIHtcbiAgICAgICAgdGhpcy5jaHVua09mZiArPSBuO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgKyBuID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlSW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICBuIC09IHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmFuZ2UuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBuO1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgc2V0RG9uZSgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gdGhpcy5lbmQ7XG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXggPSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlc2V0KHBvcywgdG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICB0b2tlbi5zdGFydCA9IHBvcztcbiAgICAgICAgICAgIHRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHRva2VuLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSB0aGlzLmVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMucmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbLS10aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA+PSB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmtQb3MgJiYgcG9zIDwgdGhpcy5jaHVua1BvcyArIHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVua1BvcyAmJiB0byA8PSB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuay5zbGljZShmcm9tIC0gdGhpcy5jaHVua1BvcywgdG8gLSB0aGlzLmNodW5rUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVuazJQb3MgJiYgdG8gPD0gdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuazIuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmsyUG9zLCB0byAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5yYW5nZS5mcm9tICYmIHRvIDw9IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yZWFkKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuaW5wdXQucmVhZChNYXRoLm1heChyLmZyb20sIGZyb20pLCBNYXRoLm1pbihyLnRvLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEBpbnRlcm5hbFxuY2xhc3MgVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgc3RhY2spIHsgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHN0YWNrLCB0aGlzLmlkKTsgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vLy8gYEBleHRlcm5hbCB0b2tlbnNgIGRlY2xhcmF0aW9ucyBpbiB0aGUgZ3JhbW1hciBzaG91bGQgcmVzb2x2ZSB0b1xuLy8vIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG5jbGFzcyBFeHRlcm5hbFRva2VuaXplciB7XG4gICAgLy8vIENyZWF0ZSBhIHRva2VuaXplci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBmdW5jdGlvbiB0aGF0LFxuICAgIC8vLyBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gICAgLy8vIHJlY29nbml6ZXMgYXQgdGhlIHN0cmVhbSdzIHBvc2l0aW9uLCBhbmQgY2FsbHNcbiAgICAvLy8gW2BhY2NlcHRUb2tlbmBdKCNsci5JbnB1dFN0cmVhbS5hY2NlcHRUb2tlbikgd2hlbiBpdCBmaW5kc1xuICAgIC8vLyBvbmUuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGB0b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHN0YWNrLCBncm91cCkge1xuICAgIGxldCBzdGF0ZSA9IDAsIGdyb3VwTWFzayA9IDEgPDwgZ3JvdXAsIHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IGRpYWxlY3QgfSA9IHBhcnNlcjtcbiAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5wdXQudG9rZW4udmFsdWUgPT0gLTEgfHwgaW5wdXQudG9rZW4udmFsdWUgPT0gdGVybSB8fCBwYXJzZXIub3ZlcnJpZGVzKHRlcm0sIGlucHV0LnRva2VuLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGVybSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAobGV0IG5leHQgPSBpbnB1dC5uZXh0LCBsb3cgPSAwLCBoaWdoID0gZGF0YVtzdGF0ZSArIDJdOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49IHRvKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8vIFNlZSBsZXplci1nZW5lcmF0b3Ivc3JjL2VuY29kZS50cyBmb3IgY29tbWVudHMgYWJvdXQgdGhlIGVuY29kaW5nXG4vLyB1c2VkIGhlcmVcbmZ1bmN0aW9uIGRlY29kZUFycmF5KGlucHV0LCBUeXBlID0gVWludDE2QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICBsZXQgYXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIG91dCA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKSwgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gMTI2IC8qIEJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEdhcDIgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgaWYgKG5leHQgPj0gMzQgLyogR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogQmFzZSAqLykge1xuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDQ2IC8qIEJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLy8gRklYTUUgZmluZCBzb21lIHdheSB0byByZWR1Y2UgcmVjb3Zlcnkgd29yayBkb25lIHdoZW4gdGhlIGlucHV0XG4vLyBkb2Vzbid0IG1hdGNoIHRoZSBncmFtbWFyIGF0IGFsbC5cbi8vIEVudmlyb25tZW50IHZhcmlhYmxlIHVzZWQgdG8gY29udHJvbCBjb25zb2xlIG91dHB1dFxuY29uc3QgdmVyYm9zZSA9IHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgL1xcYnBhcnNlXFxiLy50ZXN0KHByb2Nlc3MuZW52LkxPRyk7XG5sZXQgc3RhY2tJRHMgPSBudWxsO1xudmFyIFNhZmV0eTtcbihmdW5jdGlvbiAoU2FmZXR5KSB7XG4gICAgU2FmZXR5W1NhZmV0eVtcIk1hcmdpblwiXSA9IDI1XSA9IFwiTWFyZ2luXCI7XG59KShTYWZldHkgfHwgKFNhZmV0eSA9IHt9KSk7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5mdWxsQ3Vyc29yKCk7XG4gICAgY3Vyc29yLm1vdmVUbyhwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPCBwb3MgOiBjdXJzb3IuZnJvbSA+IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnNvci50byAtIDEsIHBvcyAtIDI1IC8qIE1hcmdpbiAqLykpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKHRyZWUubGVuZ3RoLCBNYXRoLm1heChjdXJzb3IuZnJvbSArIDEsIHBvcyArIDI1IC8qIE1hcmdpbiAqLykpO1xuICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyAwIDogdHJlZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cywgbm9kZVNldCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbm9kZVNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FmZUZyb20gPSAtMTtcbiAgICAgICAgdGhpcy5zYWZlVG8gPSAtMTtcbiAgICAgICAgdGhpcy50cmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICBsZXQgZnIgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5pID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IG51bGwgOiB0aGlzLmZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgICAgIGlmIChmcikge1xuICAgICAgICAgICAgdGhpcy5zYWZlRnJvbSA9IGZyLm9wZW5TdGFydCA/IGN1dEF0KGZyLnRyZWUsIGZyLmZyb20gKyBmci5vZmZzZXQsIDEpIC0gZnIub2Zmc2V0IDogZnIuZnJvbTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvID0gZnIub3BlbkVuZCA/IGN1dEF0KGZyLnRyZWUsIGZyLnRvICsgZnIub2Zmc2V0LCAtMSkgLSBmci5vZmZzZXQgOiBmci50bztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRyZWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKGZyLnRyZWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKC1mci5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLm5leHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLnNhZmVUbyA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnRyZWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHsgLy8gRW5kIG9mIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudHJlZXNbbGFzdF0sIGluZGV4ID0gdGhpcy5pbmRleFtsYXN0XTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0b3AuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YXJ0W2xhc3RdICsgdG9wLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCB0aGlzLnNhZmVGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kIDw9IHRoaXMuc2FmZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gbmV4dC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb2tBaGVhZCB8fCBlbmQgKyBsb29rQWhlYWQgPCB0aGlzLmZyYWdtZW50LnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgKyBuZXh0Lmxlbmd0aCA+PSBNYXRoLm1heCh0aGlzLnNhZmVGcm9tLCBwb3MpKSB7IC8vIEVudGVyIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgVG9rZW5DYWNoZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zID0gcGFyc2VyLnRva2VuaXplcnMubWFwKF8gPT4gbmV3IENhY2hlZFRva2VuKTtcbiAgICB9XG4gICAgZ2V0QWN0aW9ucyhzdGFjaykge1xuICAgICAgICBsZXQgYWN0aW9uSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWFpbiA9IG51bGw7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyB0b2tlbml6ZXJzIH0gPSBwYXJzZXI7XG4gICAgICAgIGxldCBtYXNrID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgMyAvKiBUb2tlbml6ZXJNYXNrICovKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzdGFjay5jdXJDb250ZXh0ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgoMSA8PCBpKSAmIG1hc2spID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdG9rZW5pemVyID0gdG9rZW5pemVyc1tpXSwgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmIChtYWluICYmICF0b2tlbml6ZXIuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodG9rZW5pemVyLmNvbnRleHR1YWwgfHwgdG9rZW4uc3RhcnQgIT0gc3RhY2sucG9zIHx8IHRva2VuLm1hc2sgIT0gbWFzayB8fCB0b2tlbi5jb250ZXh0ICE9IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZFRva2VuKHRva2VuLCB0b2tlbml6ZXIsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXNrID0gbWFzaztcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi5sb29rQWhlYWQgPiB0b2tlbi5lbmQgKyAyNSAvKiBNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gTWF0aC5tYXgodG9rZW4ubG9va0FoZWFkLCBsb29rQWhlYWQpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlICE9IDAgLyogRXJyICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZXh0ZW5kZWQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLmV4dGVuZGVkLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4udmFsdWUsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5pemVyLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25JbmRleCA+IHN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuYWN0aW9ucy5sZW5ndGggPiBhY3Rpb25JbmRleClcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcbiAgICAgICAgaWYgKGxvb2tBaGVhZClcbiAgICAgICAgICAgIHN0YWNrLnNldExvb2tBaGVhZChsb29rQWhlYWQpO1xuICAgICAgICBpZiAoIW1haW4gJiYgc3RhY2sucG9zID09IHRoaXMuc3RyZWFtLmVuZCkge1xuICAgICAgICAgICAgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbjtcbiAgICAgICAgICAgIG1haW4udmFsdWUgPSBzdGFjay5wLnBhcnNlci5lb2ZUZXJtO1xuICAgICAgICAgICAgbWFpbi5zdGFydCA9IG1haW4uZW5kID0gc3RhY2sucG9zO1xuICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIG1haW4udmFsdWUsIG1haW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBtYWluO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zO1xuICAgIH1cbiAgICBnZXRNYWluVG9rZW4oc3RhY2spIHtcbiAgICAgICAgaWYgKHRoaXMubWFpblRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpblRva2VuO1xuICAgICAgICBsZXQgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbiwgeyBwb3MsIHAgfSA9IHN0YWNrO1xuICAgICAgICBtYWluLnN0YXJ0ID0gcG9zO1xuICAgICAgICBtYWluLmVuZCA9IE1hdGgubWluKHBvcyArIDEsIHAuc3RyZWFtLmVuZCk7XG4gICAgICAgIG1haW4udmFsdWUgPSBwb3MgPT0gcC5zdHJlYW0uZW5kID8gcC5wYXJzZXIuZW9mVGVybSA6IDAgLyogRXJyICovO1xuICAgICAgICByZXR1cm4gbWFpbjtcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spIHtcbiAgICAgICAgdG9rZW5pemVyLnRva2VuKHRoaXMuc3RyZWFtLnJlc2V0KHN0YWNrLnBvcywgdG9rZW4pLCBzdGFjayk7XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlci5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNwZWNpYWxpemVkW2ldID09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZXIuc3BlY2lhbGl6ZXJzW2ldKHRoaXMuc3RyZWFtLnJlYWQodG9rZW4uc3RhcnQsIHRva2VuLmVuZCksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwICYmIHN0YWNrLnAucGFyc2VyLmRpYWxlY3QuYWxsb3dzKHJlc3VsdCA+PiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgJiAxKSA9PSAwIC8qIFNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogRXJyICovO1xuICAgICAgICAgICAgdG9rZW4uZW5kID0gTWF0aC5taW4oc3RhY2sucC5zdHJlYW0uZW5kLCBzdGFjay5wb3MgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXRBY3Rpb24oYWN0aW9uLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICAvLyBEb24ndCBhZGQgZHVwbGljYXRlIGFjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpXSA9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBhY3Rpb247XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IHRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBlbmQ7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHN0YWNrLCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyBkYXRhIH0gPSBwYXJzZXI7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VyLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBTa2lwICovIDogMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gMCAmJiBkYXRhW2kgKyAxXSA9PSAyIC8qIE90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMiksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDEpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbnZhciBSZWM7XG4oZnVuY3Rpb24gKFJlYykge1xuICAgIFJlY1tSZWNbXCJEaXN0YW5jZVwiXSA9IDVdID0gXCJEaXN0YW5jZVwiO1xuICAgIFJlY1tSZWNbXCJNYXhSZW1haW5pbmdQZXJTdGVwXCJdID0gM10gPSBcIk1heFJlbWFpbmluZ1BlclN0ZXBcIjtcbiAgICAvLyBXaGVuIHR3byBzdGFja3MgaGF2ZSBiZWVuIHJ1bm5pbmcgaW5kZXBlbmRlbnRseSBsb25nIGVub3VnaCB0b1xuICAgIC8vIGFkZCB0aGlzIG1hbnkgZWxlbWVudHMgdG8gdGhlaXIgYnVmZmVycywgcHJ1bmUgb25lLlxuICAgIFJlY1tSZWNbXCJNaW5CdWZmZXJMZW5ndGhQcnVuZVwiXSA9IDUwMF0gPSBcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCI7XG4gICAgUmVjW1JlY1tcIkZvcmNlUmVkdWNlTGltaXRcIl0gPSAxMF0gPSBcIkZvcmNlUmVkdWNlTGltaXRcIjtcbiAgICAvLyBPbmNlIGEgc3RhY2sgcmVhY2hlcyB0aGlzIGRlcHRoIChpbiAuc3RhY2subGVuZ3RoKSBmb3JjZS1yZWR1Y2VcbiAgICAvLyBpdCBiYWNrIHRvIEN1dFRvIHRvIGF2b2lkIGNyZWF0aW5nIHRyZWVzIHRoYXQgb3ZlcmZsb3cgdGhlIHN0YWNrXG4gICAgLy8gb24gcmVjdXJzaXZlIHRyYXZlcnNhbC5cbiAgICBSZWNbUmVjW1wiQ3V0RGVwdGhcIl0gPSAxNTAwMF0gPSBcIkN1dERlcHRoXCI7XG4gICAgUmVjW1JlY1tcIkN1dFRvXCJdID0gOTAwMF0gPSBcIkN1dFRvXCI7XG59KShSZWMgfHwgKFJlYyA9IHt9KSk7XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFN0YWNrSUQgPSAweDI2NTQ7IC8vIOKZlCwg4pmVLCDimZYsIOKZlywg4pmYLCDimZksIOKZoCwg4pmhLCDimaIsIOKZoywg4pmkLCDimaUsIOKZpiwg4pmnXG4gICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSAwO1xuICAgICAgICB0aGlzLnJldXNlZCA9IFtdO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IElucHV0U3RyZWFtKGlucHV0LCByYW5nZXMpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlciwgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICBsZXQgeyBmcm9tIH0gPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIGZyb20pXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoICYmIHRoaXMuc3RyZWFtLmVuZCAtIGZyb20gPiBwYXJzZXIuYnVmZmVyTGVuZ3RoICogNFxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzLCBwYXJzZXIubm9kZVNldCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5TdGFja1BvcztcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5taW5TdGFja1BvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICAvLyBLZWVwIGFkdmFuY2luZyBhbnkgc3RhY2tzIGF0IGBwb3NgIHVudGlsIHRoZXkgZWl0aGVyIG1vdmVcbiAgICAgICAgLy8gZm9yd2FyZCBvciBjYW4ndCBiZSBhZHZhbmNlZC4gR2F0aGVyIHN0YWNrcyB0aGF0IGNhbid0IGJlXG4gICAgICAgIC8vIGFkdmFuY2VkIGZ1cnRoZXIgaW4gYHN0b3BwZWRgLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBuZXdTdGFja3MsIHN0YWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9rID0gdGhpcy50b2tlbnMuZ2V0TWFpblRva2VuKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2Vucy5wdXNoKHRvay52YWx1ZSwgdG9rLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbmV3U3RhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gc3RvcHBlZCAmJiBmaW5kRmluaXNoZWQoc3RvcHBlZCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VyLnN0cmljdCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlICYmIHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3R1Y2sgd2l0aCB0b2tlbiBcIiArICh0aGlzLnRva2Vucy5tYWluVG9rZW4gPyB0aGlzLnBhcnNlci5nZXROYW1lKHRoaXMudG9rZW5zLm1haW5Ub2tlbi52YWx1ZSkgOiBcIm5vbmVcIikpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk5vIHBhcnNlIGF0IFwiICsgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvdmVyaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDUgLyogRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0b3BwZWRbMF0ucG9zID4gdGhpcy5zdG9wcGVkQXQgPyBzdG9wcGVkWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQuZm9yY2VBbGwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZykge1xuICAgICAgICAgICAgbGV0IG1heFJlbWFpbmluZyA9IHRoaXMucmVjb3ZlcmluZyA9PSAxID8gMSA6IHRoaXMucmVjb3ZlcmluZyAqIDMgLyogTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBNaW5CdWZmZXJMZW5ndGhQcnVuZSAqLyAmJiBvdGhlci5idWZmZXIubGVuZ3RoID4gNTAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChzdGFjay5zY29yZSAtIG90aGVyLnNjb3JlKSB8fCAoc3RhY2suYnVmZmVyLmxlbmd0aCAtIG90aGVyLmJ1ZmZlci5sZW5ndGgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1swXS5wb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5wb3MgPCB0aGlzLm1pblN0YWNrUG9zKVxuICAgICAgICAgICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbaV0ucG9zO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiB0aGlzLnN0b3BwZWRBdCA8IHBvcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgbW92ZSBzdG9wcGVkQXQgZm9yd2FyZFwiKTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYW4gdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBzdGFjaywgb3IgbnVsbCBpZiB0aGVcbiAgICAvLyBzdGFjayBjYW4ndCBhZHZhbmNlIG5vcm1hbGx5LiBXaGVuIGBzcGxpdGAgYW5kIGBzdGFja3NgIGFyZVxuICAgIC8vIGdpdmVuLCBzdGFja3Mgc3BsaXQgb2ZmIGJ5IGFtYmlndW91cyBvcGVyYXRpb25zIHdpbGwgYmUgcHVzaGVkIHRvXG4gICAgLy8gYHNwbGl0YCwgb3IgYWRkZWQgdG8gYHN0YWNrc2AgaWYgdGhleSBtb3ZlIGBwb3NgIGZvcndhcmQuXG4gICAgYWR2YW5jZVN0YWNrKHN0YWNrLCBzdGFja3MsIHNwbGl0KSB7XG4gICAgICAgIGxldCBzdGFydCA9IHN0YWNrLnBvcywgeyBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0YXJ0ID4gdGhpcy5zdG9wcGVkQXQpXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suZm9yY2VSZWR1Y2UoKSA/IHN0YWNrIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICBsZXQgc3RyaWN0Q3ggPSBzdGFjay5jdXJDb250ZXh0ICYmIHN0YWNrLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QsIGN4SGFzaCA9IHN0cmljdEN4ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNhY2hlZCA9IHRoaXMuZnJhZ21lbnRzLm5vZGVBdChzdGFydCk7IGNhY2hlZDspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW2NhY2hlZC50eXBlLmlkXSA9PSBjYWNoZWQudHlwZSA/IHBhcnNlci5nZXRHb3RvKHN0YWNrLnN0YXRlLCBjYWNoZWQudHlwZS5pZCkgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPiAtMSAmJiBjYWNoZWQubGVuZ3RoICYmICghc3RyaWN0Q3ggfHwgKGNhY2hlZC5wcm9wKE5vZGVQcm9wLmNvbnRleHRIYXNoKSB8fCAwKSA9PSBjeEhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVzZU5vZGUoY2FjaGVkLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmV1c2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShjYWNoZWQudHlwZS5pZCl9KWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVkIGluc3RhbmNlb2YgVHJlZSkgfHwgY2FjaGVkLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IGNhY2hlZC5wb3NpdGlvbnNbMF0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjYWNoZWQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyIGluc3RhbmNlb2YgVHJlZSAmJiBjYWNoZWQucG9zaXRpb25zWzBdID09IDApXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoZGVmYXVsdFJlZHVjZSA+IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZShkZWZhdWx0UmVkdWNlKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIGFsd2F5cy1yZWR1Y2UgJHtwYXJzZXIuZ2V0TmFtZShkZWZhdWx0UmVkdWNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovKX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suc3RhY2subGVuZ3RoID49IDE1MDAwIC8qIEN1dERlcHRoICovKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2suc3RhY2subGVuZ3RoID4gOTAwMCAvKiBDdXRUbyAqLyAmJiBzdGFjay5mb3JjZVJlZHVjZSgpKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMudG9rZW5zLmdldEFjdGlvbnMoc3RhY2spO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNbaSsrXSwgdGVybSA9IGFjdGlvbnNbaSsrXSwgZW5kID0gYWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGFjdGlvbnMubGVuZ3RoIHx8ICFzcGxpdDtcbiAgICAgICAgICAgIGxldCBsb2NhbFN0YWNrID0gbGFzdCA/IHN0YWNrIDogc3RhY2suc3BsaXQoKTtcbiAgICAgICAgICAgIGxvY2FsU3RhY2suYXBwbHkoYWN0aW9uLCB0ZXJtLCBlbmQpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChsb2NhbFN0YWNrKSArIGAgKHZpYSAkeyhhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwID8gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgIDogYHJlZHVjZSBvZiAke3BhcnNlci5nZXROYW1lKGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLyl9YH0gZm9yICR7cGFyc2VyLmdldE5hbWUodGVybSl9IEAgJHtzdGFydH0ke2xvY2FsU3RhY2sgPT0gc3RhY2sgPyBcIlwiIDogXCIsIHNwbGl0XCJ9KWApO1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChsb2NhbFN0YWNrLnBvcyA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNwbGl0LnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZHZhbmNlIGEgZ2l2ZW4gc3RhY2sgZm9yd2FyZCBhcyBmYXIgYXMgaXQgd2lsbCBnby4gUmV0dXJucyB0aGVcbiAgICAvLyAocG9zc2libHkgdXBkYXRlZCkgc3RhY2sgaWYgaXQgZ290IHN0dWNrLCBvciBudWxsIGlmIGl0IG1vdmVkXG4gICAgLy8gZm9yd2FyZCBhbmQgd2FzIGdpdmVuIHRvIGBwdXNoU3RhY2tEZWR1cGAuXG4gICAgYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IHBvcyA9IHN0YWNrLnBvcztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbnVsbCwgbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJ1blJlY292ZXJ5KHN0YWNrcywgdG9rZW5zLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IGZpbmlzaGVkID0gbnVsbCwgcmVzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV0sIHRva2VuID0gdG9rZW5zW2kgPDwgMV0sIHRva2VuRW5kID0gdG9rZW5zWyhpIDw8IDEpICsgMV07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHN0YWNrLmRlYWRFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAocmVzdGFydGVkKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHN0YWNrLnNwbGl0KCksIGZvcmNlQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgZm9yY2UuZm9yY2VSZWR1Y2UoKSAmJiBqIDwgMTAgLyogRm9yY2VSZWR1Y2VMaW1pdCAqLzsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZvcmNlQmFzZSArIHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAodmlhIGZvcmNlLXJlZHVjZSlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShmb3JjZSwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQmFzZSA9IHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAtPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGluc2VydCBvZiBzdGFjay5yZWNvdmVyQnlJbnNlcnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoaW5zZXJ0KSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUZ1bGx5KGluc2VydCwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbS5lbmQgPiBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5FbmQgPT0gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kKys7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gMCAvKiBFcnIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrLnJlY292ZXJCeURlbGV0ZSh0b2tlbiwgdG9rZW5FbmQpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZWNvdmVyLWRlbGV0ZSAke3RoaXMucGFyc2VyLmdldE5hbWUodG9rZW4pfSlgKTtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaW5pc2hlZCB8fCBmaW5pc2hlZC5zY29yZSA8IHN0YWNrLnNjb3JlKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHN0YWNrJ3MgYnVmZmVyIHRvIGEgc3ludGF4IHRyZWUuXG4gICAgc3RhY2tUb1RyZWUoc3RhY2spIHtcbiAgICAgICAgc3RhY2suY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIFRyZWUuYnVpbGQoeyBidWZmZXI6IFN0YWNrQnVmZmVyQ3Vyc29yLmNyZWF0ZShzdGFjayksXG4gICAgICAgICAgICBub2RlU2V0OiB0aGlzLnBhcnNlci5ub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IHRoaXMudG9wVGVybSxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogdGhpcy5wYXJzZXIuYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLnJldXNlZCxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBzdGFjay5wb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbWluUmVwZWF0VHlwZTogdGhpcy5wYXJzZXIubWluUmVwZWF0VGVybSB9KTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG5jb25zdCBpZCA9IHggPT4geDtcbi8vLyBDb250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbi8vLyBpbmRlbnRhdGlvbiBpbiB0aGUgUHl0aG9uIGdyYW1tYXIsIG9yIHBhcmVudCBlbGVtZW50cyBpbiB0aGUgWE1MXG4vLy8gZ3JhbW1hcikgbmVlZGVkIGJ5IGV4dGVybmFsIHRva2VuaXplcnMuIFlvdSBkZWNsYXJlIHRoZW0gaW4gYVxuLy8vIGdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuLy8vXG4vLy8gQ29udGV4dCB2YWx1ZXMgc2hvdWxkIGJlIGltbXV0YWJsZSwgYW5kIGNhbiBiZSB1cGRhdGVkIChyZXBsYWNlZClcbi8vLyBvbiBzaGlmdCBvciByZWR1Y2UgYWN0aW9ucy5cbi8vL1xuLy8vIFRoZSBleHBvcnQgdXNlZCBpbiBhIGBAY29udGV4dGAgZGVjbGFyYXRpb24gc2hvdWxkIGJlIG9mIHRoaXNcbi8vLyB0eXBlLlxuY2xhc3MgQ29udGV4dFRyYWNrZXIge1xuICAgIC8vLyBEZWZpbmUgYSBjb250ZXh0IHRyYWNrZXIuXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3BlYy5zdGFydDtcbiAgICAgICAgdGhpcy5zaGlmdCA9IHNwZWMuc2hpZnQgfHwgaWQ7XG4gICAgICAgIHRoaXMucmVkdWNlID0gc3BlYy5yZWR1Y2UgfHwgaWQ7XG4gICAgICAgIHRoaXMucmV1c2UgPSBzcGVjLnJldXNlIHx8IGlkO1xuICAgICAgICB0aGlzLmhhc2ggPSBzcGVjLmhhc2ggfHwgKCgpID0+IDApO1xuICAgICAgICB0aGlzLnN0cmljdCA9IHNwZWMuc3RyaWN0ICE9PSBmYWxzZTtcbiAgICB9XG59XG4vLy8gQSBwYXJzZXIgaG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWRcbi8vLyBieSBgbGV6ZXItZ2VuZXJhdG9yYC5cbmNsYXNzIExSUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMud3JhcHBlcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxMyAvKiBWZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezEzIC8qIFZlcnNpb24gKi99KWApO1xuICAgICAgICBsZXQgbm9kZU5hbWVzID0gc3BlYy5ub2RlTmFtZXMuc3BsaXQoXCIgXCIpO1xuICAgICAgICB0aGlzLm1pblJlcGVhdFRlcm0gPSBub2RlTmFtZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMucmVwZWF0Tm9kZUNvdW50OyBpKyspXG4gICAgICAgICAgICBub2RlTmFtZXMucHVzaChcIlwiKTtcbiAgICAgICAgbGV0IHRvcFRlcm1zID0gT2JqZWN0LmtleXMoc3BlYy50b3BSdWxlcykubWFwKHIgPT4gc3BlYy50b3BSdWxlc1tyXVsxXSk7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IE5vZGVTZXQobm9kZU5hbWVzLm1hcCgobmFtZSwgaSkgPT4gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCB0b2tlbkFycmF5ID0gZGVjb2RlQXJyYXkoc3BlYy50b2tlbkRhdGEpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBzcGVjLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkoc3BlYy5zcGVjaWFsaXplZCA/IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoIDogMCk7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnNwZWNpYWxpemVkKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0udGVybTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVyc1tpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0uZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgdGhpcy5tYXhUZXJtID0gc3BlYy5tYXhUZXJtO1xuICAgICAgICB0aGlzLnRva2VuaXplcnMgPSBzcGVjLnRva2VuaXplcnMubWFwKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gbmV3IFRva2VuR3JvdXAodG9rZW5BcnJheSwgdmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB0aGlzLnRvcFJ1bGVzID0gc3BlYy50b3BSdWxlcztcbiAgICAgICAgdGhpcy5kaWFsZWN0cyA9IHNwZWMuZGlhbGVjdHMgfHwge307XG4gICAgICAgIHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzID0gc3BlYy5keW5hbWljUHJlY2VkZW5jZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50b2tlblByZWNUYWJsZSA9IHNwZWMudG9rZW5QcmVjO1xuICAgICAgICB0aGlzLnRlcm1OYW1lcyA9IHNwZWMudGVybU5hbWVzIHx8IG51bGw7XG4gICAgICAgIHRoaXMubWF4Tm9kZSA9IHRoaXMubm9kZVNldC50eXBlcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdCgpO1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wUnVsZXNbT2JqZWN0LmtleXModGhpcy50b3BSdWxlcylbMF1dO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHcgb2YgdGhpcy53cmFwcGVycylcbiAgICAgICAgICAgIHBhcnNlID0gdyhwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyksIG5leHQ7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPSBkYXRhW2ldKSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSB0ZXJtaW5hbCB8fCBuZXh0ID09IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlRmxhZyhzdGF0ZSwgZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIEZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHZhbGlkQWN0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gcGFpcih0aGlzLmRhdGEsIGkgKyAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIC8vLyBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICBuZXh0U3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5kYXRhW2kgKyAyXSAmICg2NTUzNiAvKiBSZWR1Y2VGbGFnICovID4+IDE2KSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIG92ZXJyaWRlcyh0b2tlbiwgcHJldikge1xuICAgICAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRoaXMuZGF0YSwgdGhpcy50b2tlblByZWNUYWJsZSwgcHJldik7XG4gICAgICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHRva2VuKSA8IGlQcmV2O1xuICAgIH1cbiAgICAvLy8gQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIC8vLyBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIC8vLyBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKExSUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0VHJhY2tlcilcbiAgICAgICAgICAgIGNvcHkuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0VHJhY2tlcjtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICBjb3B5LndyYXBwZXJzID0gY29weS53cmFwcGVycy5jb25jYXQoY29uZmlnLndyYXApO1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVybS4gVGhpcyB3aWxsIG9ubHlcbiAgICAvLy8gd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gICAgLy8vIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgICAvLy8gc3RvcmVkLlxuICAgIGdldE5hbWUodGVybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1t0ZXJtXSA6IFN0cmluZyh0ZXJtIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbdGVybV0ubmFtZSB8fCB0ZXJtKTtcbiAgICB9XG4gICAgLy8vIFRoZSBlb2YgdGVybSBpZCBpcyBhbHdheXMgYWxsb2NhdGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBub2RlXG4gICAgLy8vIHR5cGVzLiBAaW50ZXJuYWxcbiAgICBnZXQgZW9mVGVybSgpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSArIDE7IH1cbiAgICAvLy8gVGhlIHR5cGUgb2YgdG9wIG5vZGUgcHJvZHVjZWQgYnkgdGhlIHBhcnNlci5cbiAgICBnZXQgdG9wTm9kZSgpIHsgcmV0dXJuIHRoaXMubm9kZVNldC50eXBlc1t0aGlzLnRvcFsxXV07IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZHluYW1pY1ByZWNlZGVuY2UodGVybSkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzO1xuICAgICAgICByZXR1cm4gcHJlYyA9PSBudWxsID8gMCA6IHByZWNbdGVybV0gfHwgMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcnNlRGlhbGVjdChkaWFsZWN0KSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgZmxhZ3MgPSB2YWx1ZXMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKGRpYWxlY3QpXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIGRpYWxlY3Quc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdmFsdWVzLmluZGV4T2YocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkID49IDApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFmbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpYWxlY3RzW3ZhbHVlc1tpXV0sIGlkOyAoaWQgPSB0aGlzLmRhdGFbaisrXSkgIT0gNjU1MzUgLyogRW5kICovOylcbiAgICAgICAgICAgICAgICAgICAgKGRpc2FibGVkIHx8IChkaXNhYmxlZCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEaWFsZWN0KGRpYWxlY3QsIGZsYWdzLCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIC8vLyAodXNlZCBieSB0aGUgb3V0cHV0IG9mIHRoZSBwYXJzZXIgZ2VuZXJhdG9yKSBAaW50ZXJuYWxcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IExSUGFyc2VyKHNwZWMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhaXIoZGF0YSwgb2ZmKSB7IHJldHVybiBkYXRhW29mZl0gfCAoZGF0YVtvZmYgKyAxXSA8PCAxNik7IH1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogRW5kICovOyBpKyspXG4gICAgICAgIGlmIChuZXh0ID09IHRlcm0pXG4gICAgICAgICAgICByZXR1cm4gaSAtIHN0YXJ0O1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGZpbmRGaW5pc2hlZChzdGFja3MpIHtcbiAgICBsZXQgYmVzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGxldCBzdG9wcGVkID0gc3RhY2sucC5zdG9wcGVkQXQ7XG4gICAgICAgIGlmICgoc3RhY2sucG9zID09IHN0YWNrLnAuc3RyZWFtLmVuZCB8fCBzdG9wcGVkICE9IG51bGwgJiYgc3RhY2sucG9zID4gc3RvcHBlZCkgJiZcbiAgICAgICAgICAgIHN0YWNrLnAucGFyc2VyLnN0YXRlRmxhZyhzdGFjay5zdGF0ZSwgMiAvKiBBY2NlcHRpbmcgKi8pICYmXG4gICAgICAgICAgICAoIWJlc3QgfHwgYmVzdC5zY29yZSA8IHN0YWNrLnNjb3JlKSlcbiAgICAgICAgICAgIGJlc3QgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG59XG5cbmV4cG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgSW5wdXRTdHJlYW0sIExSUGFyc2VyLCBTdGFjayB9O1xuIl0sIm5hbWVzIjpbImlzQ2FuY2VsYWJsZVByb21pc2VSZWplY3Rpb24iLCJwcm9taXNlIiwibWFrZVByb21pc2VDYW5jZWxhYmxlIiwiaGFzQ2FuY2VsZWRfIiwid3JhcHBlZFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbmNlbGVkUHJvbWlzZVJlamVjdGlvbiIsImlzQ2FuY2VsZWQiLCJ0aGVuIiwidmFsIiwiY2F0Y2giLCJlcnJvciIsImNhbmNlbCIsInBhcnNlciIsIlByb21RdWVyeU1vZGVsbGVyIiwiYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmciLCJhZGRMYWJlbFRvUXVlcnkiLCJxdWVyeSIsImtleSIsInZhbHVlIiwib3BlcmF0b3IiLCJFcnJvciIsInZlY3RvclNlbGVjdG9yUG9zaXRpb25zIiwiZ2V0VmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMiLCJsZW5ndGgiLCJmaWx0ZXIiLCJ0b0xhYmVsRmlsdGVyIiwiYWRkRmlsdGVyIiwidHJlZSIsInBhcnNlIiwicG9zaXRpb25zIiwiaXRlcmF0ZSIsImVudGVyIiwidHlwZSIsImZyb20iLCJ0byIsImdldCIsIm5hbWUiLCJ2aXNRdWVyeSIsInN1YnN0cmluZyIsInB1c2giLCJ0cmFuc2Zvcm1lZFZhbHVlIiwiSW5maW5pdHkiLCJ0b1N0cmluZyIsImxhYmVsIiwib3AiLCJtb2RlbGxlciIsIm5ld1F1ZXJ5IiwicHJldiIsImkiLCJtYXRjaCIsImlzTGFzdCIsInN0YXJ0IiwiZW5kIiwibGFiZWxFeGlzdHMiLCJsYWJlbHMiLCJuZXdMYWJlbHMiLCJyZW5kZXJRdWVyeSIsImZpbmQiLCJSZWFjdCIsIkVkaXRvclJvdyIsIkVkaXRvckZpZWxkIiwiRWRpdG9yU3dpdGNoIiwiU3BhY2UiLCJFZGl0b3JSb3dzIiwiSW5wdXQiLCJBdXRvU2l6ZUlucHV0IiwiUHJvbVF1ZXJ5Q29kZUVkaXRvciIsIkFubm90YXRpb25RdWVyeUVkaXRvciIsInByb3BzIiwiYW5ub3RhdGlvbiIsIm9uQW5ub3RhdGlvbkNoYW5nZSIsImV4cHIiLCJyZWZJZCIsImludGVydmFsIiwic3RlcCIsImV2IiwiY3VycmVudFRhcmdldCIsInRpdGxlRm9ybWF0IiwiZXZlbnQiLCJ0YWdLZXlzIiwidGV4dEZvcm1hdCIsInVzZVZhbHVlRm9yVGltZSIsIkNIRUFUX1NIRUVUX0lURU1TIiwidGl0bGUiLCJleHByZXNzaW9uIiwiUHJvbUNoZWF0U2hlZXQiLCJtYXAiLCJpdGVtIiwiaW5kZXgiLCJlIiwib25DbGlja0V4YW1wbGUiLCJjc3MiLCJjeCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUHJldmlvdXMiLCJJY29uQnV0dG9uIiwiSW5saW5lTGFiZWwiLCJUb29sdGlwIiwidXNlU3R5bGVzMiIsIlByb21FeGVtcGxhckZpZWxkIiwiZGF0YXNvdXJjZSIsIm9uQ2hhbmdlIiwicmVzdCIsInNldEVycm9yIiwic3R5bGVzIiwiZ2V0U3R5bGVzIiwicHJldkVycm9yIiwiZXhlbXBsYXJzQXZhaWxhYmxlIiwiaW5zdGFudCIsInJhbmdlIiwiaWNvbkJ1dHRvblN0eWxlcyIsImFjdGl2ZUljb24iLCJleGVtcGxhciIsImV5ZUljb24iLCJpY29uV3JhcHBlciIsInRoZW1lIiwic3BhY2luZyIsImNvbG9ycyIsInByaW1hcnkiLCJtYWluIiwiaXNFcXVhbCIsIm1lbW8iLCJ1c2VDYWxsYmFjayIsIklubGluZUZvcm1MYWJlbCIsIlJhZGlvQnV0dG9uR3JvdXAiLCJQcm9tRXhwbG9yZUV4dHJhRmllbGQiLCJvblJ1blF1ZXJ5IiwicmFuZ2VPcHRpb25zIiwiZ2V0UXVlcnlUeXBlT3B0aW9ucyIsInByZXZRdWVyeSIsIm9uRXhlbXBsYXJDaGFuZ2UiLCJvbkNoYW5nZVF1ZXJ5U3RlcCIsIm9uU3RlcENoYW5nZSIsIm9uUmV0dXJuS2V5RG93biIsInNoaWZ0S2V5Iiwib25RdWVyeVR5cGVDaGFuZ2UiLCJnZXRRdWVyeVR5cGVDaGFuZ2VIYW5kbGVyIiwidGVzdElkcyIsImV4dHJhRmllbGRFZGl0b3IiLCJxdWVyeVR5cGVGaWVsZCIsInN0ZXBGaWVsZCIsImRpc3BsYXlOYW1lIiwiaW5jbHVkZUJvdGgiLCJkZXNjcmlwdGlvbiIsInF1ZXJ5VHlwZSIsIkNvcmVBcHAiLCJQcm9tUXVlcnlGaWVsZCIsIlByb21FeHBsb3JlUXVlcnlFZGl0b3IiLCJkYXRhIiwiaGlzdG9yeSIsInVuZGVmaW5lZCIsIkV4cGxvcmUiLCJlZGl0b3IiLCJ0ZXh0VXRpbCIsInJhbmdlVXRpbCIsIlByb21MaW5rIiwicGFuZWxEYXRhIiwiaHJlZiIsInNldEhyZWYiLCJnZXRFeHRlcm5hbExpbmsiLCJyZXF1ZXN0Iiwic2NvcGVkVmFycyIsImdldFByb21ldGhldXNUaW1lIiwicmFuZ2VEaWZmIiwiTWF0aCIsImNlaWwiLCJlbmRUaW1lIiwidXRjIiwiZm9ybWF0IiwiZW5yaWNoZWRTY29wZWRWYXJzIiwiZ2V0UmF0ZUludGVydmFsU2NvcGVkVmFyaWFibGUiLCJpbnRlcnZhbFRvU2Vjb25kcyIsIm9wdGlvbnMiLCJjdXN0b21RdWVyeVBhcmFtZXRlcnMiLCJrIiwidiIsInF1ZXJ5T3B0aW9ucyIsImNyZWF0ZVF1ZXJ5IiwiYXJncyIsImVuY29kZVVSSUNvbXBvbmVudCIsImpvaW4iLCJkaXJlY3RVcmwiLCJzYW5pdGl6ZVVybCIsIlB1cmVDb21wb25lbnQiLCJMZWdhY3lGb3JtcyIsIlNlbGVjdCIsIlN3aXRjaCIsIkZPUk1BVF9PUFRJT05TIiwiSU5URVJWQUxfRkFDVE9SX09QVElPTlMiLCJQcm9tUXVlcnlFZGl0b3IiLCJjb25zdHJ1Y3RvciIsIm92ZXJyaWRlIiwib3B0aW9uIiwic2V0U3RhdGUiLCJmb3JtYXRPcHRpb24iLCJ0YXJnZXQiLCJjaGVja2VkIiwiaW50ZXJ2YWxGYWN0b3IiLCJpbnRlcnZhbEZhY3Rvck9wdGlvbiIsImxlZ2VuZEZvcm1hdCIsImlzRW5hYmxlZCIsImhpZGUiLCJkZWZhdWx0UXVlcnkiLCJhcHAiLCJVbmlmaWVkQWxlcnRpbmciLCJPYmplY3QiLCJhc3NpZ24iLCJzdGF0ZSIsIkJvb2xlYW4iLCJyZW5kZXIiLCJzaG93RXhlbXBsYXJGaWVsZCIsIm9uRmllbGRDaGFuZ2UiLCJvbkxlZ2VuZENoYW5nZSIsIm9uSW50ZXJ2YWxDaGFuZ2UiLCJvbkludGVydmFsRmFjdG9yQ2hhbmdlIiwib25Gb3JtYXRDaGFuZ2UiLCJvbkluc3RhbnRDaGFuZ2UiLCJjb25maWciLCJQcm9tUXVlcnlFZGl0b3JTZWxlY3RvciIsIlByb21RdWVyeUVkaXRvckZvckFsZXJ0aW5nIiwiUHJvbVF1ZXJ5RWRpdG9yQnlBcHAiLCJDbG91ZEFsZXJ0aW5nIiwiZmVhdHVyZVRvZ2dsZXMiLCJwcm9tUXVlcnlCdWlsZGVyIiwibGFuZ3VhZ2VzIiwicHJpc21MYW5ndWFnZXMiLCJpc0RhdGFGcmFtZSIsInRvTGVnYWN5UmVzcG9uc2VEYXRhIiwiU2xhdGVQcmlzbSIsIkJyYWNlc1BsdWdpbiIsIkRPTVV0aWwiLCJJY29uIiwiTG9jYWxTdG9yYWdlVmFsdWVQcm92aWRlciIsInJvdW5kTXNUb01pbiIsIlByb21ldGhldXNNZXRyaWNzQnJvd3NlciIsIk1vbmFjb1F1ZXJ5RmllbGRXcmFwcGVyIiwiUkVDT1JESU5HX1JVTEVTX0dST1VQIiwiTEFTVF9VU0VEX0xBQkVMU19LRVkiLCJnZXRDaG9vc2VyVGV4dCIsIm1ldHJpY3NMb29rdXBEaXNhYmxlZCIsImhhc1N5bnRheCIsImhhc01ldHJpY3MiLCJ3aWxsQXBwbHlTdWdnZXN0aW9uIiwic3VnZ2VzdGlvbiIsInR5cGVhaGVhZENvbnRleHQiLCJ0eXBlYWhlYWRUZXh0IiwibmV4dENoYXIiLCJnZXROZXh0Q2hhcmFjdGVyIiwiY29udGV4dCIsImluaXRIaW50cyIsImdldEluaXRIaW50cyIsImluaXRIaW50Iiwic2VyaWVzIiwiaGludCIsInJlc3VsdCIsInF1ZXJ5SGludHMiLCJnZXRRdWVyeUhpbnRzIiwicXVlcnlIaW50IiwibGFuZ3VhZ2VQcm92aWRlciIsImxhbmd1YWdlUHJvdmlkZXJJbml0aWFsaXphdGlvblByb21pc2UiLCJyZW1haW5pbmdUYXNrcyIsImFsbCIsIm9uVXBkYXRlTGFuZ3VhZ2UiLCJlcnIiLCJzZWxlY3RvciIsIm9uQ2hhbmdlUXVlcnkiLCJsYWJlbEJyb3dzZXJWaXNpYmxlIiwibmV4dFF1ZXJ5IiwibW9kaWZ5UXVlcnkiLCJmaXgiLCJhY3Rpb24iLCJtZXRyaWNzIiwic3ludGF4TG9hZGVkIiwidHlwZWFoZWFkIiwic3VnZ2VzdGlvbnMiLCJwcmVmaXgiLCJ0ZXh0Iiwid3JhcHBlckNsYXNzZXMiLCJsYWJlbEtleSIsInByb3ZpZGVDb21wbGV0aW9uSXRlbXMiLCJwbHVnaW5zIiwib25seUluIiwibm9kZSIsImdldFN5bnRheCIsInByb21xbCIsInN5bnRheCIsImNvbXBvbmVudERpZE1vdW50IiwicmVmcmVzaE1ldHJpY3MiLCJyZWZyZXNoSGludCIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwiY2hhbmdlZFJhbmdlVG9SZWZyZXNoIiwicmFuZ2VDaGFuZ2VkVG9SZWZyZXNoIiwicHJldlJhbmdlIiwic2FtZU1pbnV0ZUZyb20iLCJ2YWx1ZU9mIiwic2FtZU1pbnV0ZVRvIiwiRXh0cmFGaWVsZEVsZW1lbnQiLCJjaG9vc2VyVGV4dCIsImxvb2t1cHNEaXNhYmxlZCIsImJ1dHRvbkRpc2FibGVkIiwibGFzdFVzZWRMYWJlbHMiLCJvbkxhc3RVc2VkTGFiZWxzU2F2ZSIsIm9uTGFzdFVzZWRMYWJlbHNEZWxldGUiLCJvbkNsaWNrQ2hvb3NlckJ1dHRvbiIsIm9uQ2hhbmdlTGFiZWxCcm93c2VyIiwib25DbGlja0hpbnRGaXgiLCJGaXhlZFNpemVMaXN0IiwiQnV0dG9uIiwiSG9yaXpvbnRhbEdyb3VwIiwiTGFiZWwiLCJMb2FkaW5nUGxhY2Vob2xkZXIiLCJzdHlsZXNGYWN0b3J5Iiwid2l0aFRoZW1lIiwiQnJvd3NlckxhYmVsIiwiUHJvbUxhYmVsIiwiZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3RvciIsImVzY2FwZUxhYmVsVmFsdWVJblJlZ2V4U2VsZWN0b3IiLCJFTVBUWV9TRUxFQ1RPUiIsIk1FVFJJQ19MQUJFTCIsIkxJU1RfSVRFTV9TSVpFIiwiYnVpbGRTZWxlY3RvciIsInNpbmdsZU1ldHJpYyIsInNlbGVjdGVkTGFiZWxzIiwic2VsZWN0ZWQiLCJ2YWx1ZXMiLCJzZWxlY3RlZFZhbHVlcyIsImZhY2V0TGFiZWxzIiwicG9zc2libGVMYWJlbHMiLCJsYXN0RmFjZXR0ZWQiLCJwb3NzaWJsZVZhbHVlcyIsImV4aXN0aW5nVmFsdWVzIiwiU2V0IiwiaGFzIiwibG9hZGluZyIsImhpZGRlbiIsImZhY2V0cyIsIndyYXBwZXIiLCJiZzIiLCJzbSIsImxpc3QiLCJzZWN0aW9uIiwibWQiLCJ0eXBvZ3JhcGh5IiwiZm9udEZhbWlseSIsIm1vbm9zcGFjZSIsInN0YXR1cyIsInhzIiwidGV4dFNlbWlXZWFrIiwic3RhdHVzU2hvd2luZyIsInBhbGV0dGUiLCJicmFuZERhbmdlciIsInZhbHVlTGlzdCIsInZhbHVlTGlzdFdyYXBwZXIiLCJib3JkZXIyIiwidmFsdWVMaXN0QXJlYSIsInZhbHVlVGl0bGUiLCJ2YWxpZGF0aW9uU3RhdHVzIiwidGV4dFN0cm9uZyIsIlVudGhlbWVkUHJvbWV0aGV1c01ldHJpY3NCcm93c2VyIiwiQ29tcG9uZW50IiwiY3JlYXRlUmVmIiwibGFiZWxTZWFyY2hUZXJtIiwibWV0cmljU2VhcmNoVGVybSIsInZhbHVlU2VhcmNoVGVybSIsImRlbGV0ZUxhc3RVc2VkTGFiZWxzIiwiZmV0Y2hWYWx1ZXMiLCJsIiwibmV4dFZhbHVlIiwidXBkYXRlTGFiZWxTdGF0ZSIsImRvRmFjZXR0aW5nRm9yTGFiZWwiLCJkb0ZhY2V0dGluZyIsInNvbWUiLCJ2YWxpZGF0ZVNlbGVjdG9yIiwiZm9yRWFjaCIsImZldGNoU2VyaWVzIiwidXBkYXRlZEZpZWxkcyIsImNiIiwicmF3TGFiZWxzIiwiZ2V0TGFiZWxLZXlzIiwiYXJyIiwiaW5jbHVkZXMiLCJzdG9yZUxhc3RVc2VkTGFiZWxzIiwicmF3VmFsdWVzIiwiZ2V0TGFiZWxWYWx1ZXMiLCJtZXRyaWNzTWV0YWRhdGEiLCJsYWJlbFZhbHVlIiwibWV0YSIsImRldGFpbHMiLCJoZWxwIiwiY29uc29sZSIsImZldGNoU2VyaWVzTGFiZWxzIiwia2V5cyIsInN0cmVhbXMiLCJub25NZXRyaWNMYWJlbHMiLCJlbXB0eSIsIm1ldHJpY0NvdW50Iiwib25DaGFuZ2VNZXRyaWNTZWFyY2giLCJtaW4iLCJzdHlsZSIsIm9uQ2xpY2tNZXRyaWMiLCJvbkNoYW5nZUxhYmVsU2VhcmNoIiwiaGVpZ2h0Iiwib25DbGlja0xhYmVsIiwib25DaGFuZ2VWYWx1ZVNlYXJjaCIsInZhbHVlTGlzdHNSZWYiLCJvbkNsaWNrVmFsdWUiLCJvbkNsaWNrUnVuUXVlcnkiLCJvbkNsaWNrUnVuUmF0ZVF1ZXJ5Iiwib25DbGlja1ZhbGlkYXRlIiwib25DbGlja0NsZWFyIiwiU3VzcGVuc2UiLCJGaWVsZCIsImxhenkiLCJNb25hY29RdWVyeUZpZWxkTGF6eSIsInVzZVJlZiIsImxhc3RSdW5WYWx1ZVJlZiIsInJ1blF1ZXJ5T25CbHVyIiwiaGFuZGxlUnVuUXVlcnkiLCJjdXJyZW50IiwiaGFuZGxlQmx1ciIsInVzZU1lbW8iLCJJbmxpbmVGaWVsZCIsIklubGluZUZpZWxkUm93IiwiSW5saW5lU3dpdGNoIiwiS25vd25BenVyZUNsb3VkcyIsImdldENyZWRlbnRpYWxzIiwidXBkYXRlQ3JlZGVudGlhbHMiLCJBenVyZUNyZWRlbnRpYWxzRm9ybSIsIkF6dXJlQXV0aFNldHRpbmdzIiwiZGF0YVNvdXJjZUNvbmZpZyIsIm92ZXJyaWRlQXVkaWVuY2VBbGxvd2VkIiwicHJvbWV0aGV1c0F6dXJlT3ZlcnJpZGVBdWRpZW5jZSIsImpzb25EYXRhIiwiYXp1cmVFbmRwb2ludFJlc291cmNlSWQiLCJvdmVycmlkZUF1ZGllbmNlQ2hlY2tlZCIsInNldE92ZXJyaWRlQXVkaWVuY2VDaGVja2VkIiwiY3JlZGVudGlhbHMiLCJvbkNyZWRlbnRpYWxzQ2hhbmdlIiwib25PdmVycmlkZUF1ZGllbmNlQ2hhbmdlIiwib25SZXNvdXJjZUlkQ2hhbmdlIiwiYXp1cmUiLCJtYW5hZ2VkSWRlbnRpdHlFbmFibGVkIiwiQXp1cmVDbG91ZCIsIlB1YmxpYyIsIkNoaW5hIiwiVVNHb3Zlcm5tZW50IiwiR2VybWFueSIsImlzQ3JlZGVudGlhbHNDb21wbGV0ZSIsImF1dGhUeXBlIiwiYXp1cmVDbG91ZCIsInRlbmFudElkIiwiY2xpZW50SWQiLCJjbGllbnRTZWNyZXQiLCJjb25jZWFsZWQiLCJTeW1ib2wiLCJnZXREZWZhdWx0QXp1cmVDbG91ZCIsImNsb3VkIiwiZ2V0U2VjcmV0Iiwic2VjdXJlSnNvbkZpZWxkcyIsImF6dXJlQ2xpZW50U2VjcmV0Iiwic2VjcmV0Iiwic2VjdXJlSnNvbkRhdGEiLCJoYXNDcmVkZW50aWFscyIsImF6dXJlQ3JlZGVudGlhbHMiLCJnZXREZWZhdWx0Q3JlZGVudGlhbHMiLCJzZXREZWZhdWx0Q3JlZGVudGlhbHMiLCJyZXNldENyZWRlbnRpYWxzIiwiYXp1cmVBdXRoIiwidXNlUmVkdWNlciIsImF1dGhUeXBlT3B0aW9ucyIsImF6dXJlQ2xvdWRPcHRpb25zIiwiZ2V0U3Vic2NyaXB0aW9ucyIsImhhc1JlcXVpcmVkRmllbGRzIiwic3Vic2NyaXB0aW9ucyIsInNldFN1YnNjcmlwdGlvbnMiLCJsb2FkU3Vic2NyaXB0aW9uc0NsaWNrZWQiLCJvbkxvYWRTdWJzY3JpcHRpb25zIiwidXBkYXRlU3Vic2NyaXB0aW9ucyIsImNhbmNlbGVkIiwicmVjZWl2ZWQiLCJhdXRvU2VsZWN0IiwiZGVmYXVsdFN1YnNjcmlwdGlvbklkIiwib25TdWJzY3JpcHRpb25DaGFuZ2UiLCJmb3VuZCIsIm9wdCIsIm9uQXV0aFR5cGVDaGFuZ2UiLCJ1cGRhdGVkIiwib25BenVyZUNsb3VkQ2hhbmdlIiwib25UZW5hbnRJZENoYW5nZSIsIm9uQ2xpZW50SWRDaGFuZ2UiLCJvbkNsaWVudFNlY3JldENoYW5nZSIsIm9uQ2xpZW50U2VjcmV0UmVzZXQiLCJTSUdWNENvbm5lY3Rpb25Db25maWciLCJBbGVydGluZ1NldHRpbmdzIiwiRGF0YVNvdXJjZUh0dHBTZXR0aW5ncyIsIkFsZXJ0IiwiZ2V0QWxsQWxlcnRtYW5hZ2VyRGF0YVNvdXJjZXMiLCJQcm9tU2V0dGluZ3MiLCJDb25maWdFZGl0b3IiLCJvbk9wdGlvbnNDaGFuZ2UiLCJhbGVydG1hbmFnZXJzIiwiYXp1cmVBdXRoU2V0dGluZ3MiLCJhenVyZUF1dGhTdXBwb3J0ZWQiLCJwcm9tZXRoZXVzX2F6dXJlX2F1dGgiLCJnZXRBenVyZUF1dGhFbmFibGVkIiwic2V0QXp1cmVBdXRoRW5hYmxlZCIsImVuYWJsZWQiLCJhenVyZVNldHRpbmdzVUkiLCJhY2Nlc3MiLCJzaWdWNEF1dGhFbmFibGVkIiwic2VsZWN0b3JzIiwiRGF0YVNvdXJjZVBpY2tlciIsIkV4ZW1wbGFyU2V0dGluZyIsIm9uRGVsZXRlIiwiaXNJbnRlcm5hbExpbmsiLCJzZXRJc0ludGVybmFsTGluayIsImRhdGFzb3VyY2VVaWQiLCJjb21wb25lbnRzIiwiRGF0YVNvdXJjZSIsIlByb21ldGhldXMiLCJjb25maWdQYWdlIiwiaW50ZXJuYWxMaW5rU3dpdGNoIiwicHJldmVudERlZmF1bHQiLCJkcyIsInVpZCIsInVybCIsInVybERpc3BsYXlMYWJlbCIsIkV4ZW1wbGFyc1NldHRpbmdzIiwibmV3RmllbGQiLCJuZXdPcHRpb25zIiwic3BsaWNlIiwiZXhlbXBsYXJzQWRkQnV0dG9uIiwib25VcGRhdGVEYXRhc291cmNlSnNvbkRhdGFPcHRpb25DaGVja2VkIiwidXBkYXRlRGF0YXNvdXJjZVBsdWdpbkpzb25EYXRhT3B0aW9uIiwiRXZlbnRzV2l0aFZhbGlkYXRpb24iLCJyZWdleFZhbGlkYXRpb24iLCJGb3JtRmllbGQiLCJodHRwT3B0aW9ucyIsImh0dHBNZXRob2QiLCJ0aW1lSW50ZXJ2YWwiLCJvbkNoYW5nZUhhbmRsZXIiLCJwcm9tU2V0dGluZ3NWYWxpZGF0aW9uRXZlbnRzIiwicXVlcnlUaW1lb3V0IiwibyIsImRpc2FibGVNZXRyaWNzTG9va3VwIiwiZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zIiwiZXhlbXBsYXJPcHRpb25zIiwib25CbHVyIiwiZ2V0VmFsdWVGcm9tRXZlbnRJdGVtIiwiZXZlbnRJdGVtIiwiaGFzT3duUHJvcGVydHkiLCJjbG9uZURlZXAiLCJkZWZhdWx0cyIsIkxSVSIsImZvcmtKb2luIiwibGFzdFZhbHVlRnJvbSIsIm1lcmdlIiwib2YiLCJwaXBlIiwidGhyb3dFcnJvciIsImNhdGNoRXJyb3IiLCJ0YXAiLCJkYXRlTWF0aCIsIkxvYWRpbmdTdGF0ZSIsImRhdGVUaW1lIiwiZ2V0QmFja2VuZFNydiIsIkRhdGFTb3VyY2VXaXRoQmFja2VuZCIsInRvRGF0YVF1ZXJ5UmVzcG9uc2UiLCJpc0ZldGNoRXJyb3IiLCJCYWRnZSIsInNhZmVTdHJpbmdpZnlWYWx1ZSIsImRpc2NvdmVyRGF0YVNvdXJjZUZlYXR1cmVzIiwiZ2V0VGltZVNydiIsImdldFRlbXBsYXRlU3J2IiwiUHJvbUFwcGxpY2F0aW9uIiwiUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXIiLCJleHBhbmRSZWNvcmRpbmdSdWxlcyIsInJlbmRlckxlZ2VuZEZvcm1hdCIsIlByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkiLCJnZXRPcmlnaW5hbE1ldHJpY05hbWUiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2Zvcm1WMiIsIlByb21RdWVyeVR5cGUiLCJQcm9tZXRoZXVzVmFyaWFibGVTdXBwb3J0IiwiQU5OT1RBVElPTl9RVUVSWV9TVEVQX0RFRkFVTFQiLCJHRVRfQU5EX1BPU1RfTUVUQURBVEFfRU5EUE9JTlRTIiwiUHJvbWV0aGV1c0RhdGFzb3VyY2UiLCJpbnN0YW5jZVNldHRpbmdzIiwidGVtcGxhdGVTcnYiLCJ0aW1lU3J2IiwibWF4IiwibG9hZFJ1bGVzIiwiYXJlRXhlbXBsYXJzQXZhaWxhYmxlIiwicXVlcmllcyIsImFjdGl2ZVRhcmdldHMiLCJjbG9uZWRUYXJnZXRzIiwidGFyZ2V0cyIsInJlcXVlc3RJZCIsInBhbmVsSWQiLCJtZXRyaWNOYW1lIiwiaGlzdG9ncmFtTWV0cmljcyIsIm0iLCJpbnN0YW50VGFyZ2V0IiwidmFsdWVXaXRoUmVmSWQiLCJtYXhEYXRhUG9pbnRzIiwicmFuZ2VUYXJnZXQiLCJhY3RpdmVUYXJnZXQiLCJleGVtcGxhclRhcmdldCIsIm1lc3NhZ2UiLCJzdGF0dXNUZXh0IiwiZnJhbWVzIiwidGFnS2V5c0FycmF5Iiwic3BsaXQiLCJldmVudExpc3QiLCJmcmFtZSIsInRpbWVGaWVsZCIsImZpZWxkcyIsInZhbHVlRmllbGQiLCJ0YWdzIiwidGltZVZhbHVlVHVwbGUiLCJpZHgiLCJ0b0FycmF5IiwidGltZVN0YW1wVmFsdWUiLCJ2YWx1ZVZhbHVlIiwidGltZSIsImZsb29yIiwicGFyc2VGbG9hdCIsImFjdGl2ZVZhbHVlcyIsImFjdGl2ZVZhbHVlc1RpbWVzdGFtcHMiLCJsYXRlc3RFdmVudCIsInRpbWVzdGFtcCIsInRpbWVFbmQiLCJzdWJUeXBlIiwicnVsZXJFbmFibGVkIiwiZWRpdG9yU3JjIiwiaWQiLCJiYXNpY0F1dGgiLCJ3aXRoQ3JlZGVudGlhbHMiLCJydWxlTWFwcGluZ3MiLCJVUkxTZWFyY2hQYXJhbXMiLCJ2YXJpYWJsZXMiLCJhbm5vdGF0aW9ucyIsIlF1ZXJ5RWRpdG9yIiwiZ2V0UXVlcnlEaXNwbGF5VGV4dCIsIl9hZGRUcmFjaW5nSGVhZGVycyIsImhlYWRlcnMiLCJwcm94eU1vZGUiLCJkYXNoYm9hcmRJZCIsIl9yZXF1ZXN0Iiwib3ZlcnJpZGVzIiwicXVlcnlVcmwiLCJzdGFydHNXaXRoIiwibWV0aG9kIiwic2VhcmNoIiwiZW50cmllcyIsIkF1dGhvcml6YXRpb24iLCJmZXRjaCIsImltcG9ydEZyb21BYnN0cmFjdFF1ZXJpZXMiLCJhYnN0cmFjdFF1ZXJpZXMiLCJhYnN0cmFjdFF1ZXJ5IiwiaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkiLCJleHBvcnRUb0Fic3RyYWN0UXVlcmllcyIsImV4cG9ydFRvQWJzdHJhY3RRdWVyeSIsIm1ldGFkYXRhUmVxdWVzdCIsInBhcmFtcyIsImVuZHBvaW50IiwiaGlkZUZyb21JbnNwZWN0b3IiLCJzaG93RXJyb3JBbGVydCIsIndhcm4iLCJpbnRlcnBvbGF0ZVF1ZXJ5RXhwciIsInZhcmlhYmxlIiwibXVsdGkiLCJpbmNsdWRlQWxsIiwicHJvbWV0aGV1c1JlZ3VsYXJFc2NhcGUiLCJwcm9tZXRoZXVzU3BlY2lhbFJlZ2V4RXNjYXBlIiwiZXNjYXBlZFZhbHVlcyIsInRhcmdldENvbnRhaW5zVGVtcGxhdGUiLCJjb250YWluc1RlbXBsYXRlIiwic2hvdWxkUnVuRXhlbXBsYXJRdWVyeSIsImN1cnJlbnRUYXJnZXRJZHgiLCJmaW5kSW5kZXgiLCJ0Iiwic2xpY2UiLCJwcm9jZXNzVGFyZ2V0VjIiLCJwcm9jZXNzZWRUYXJnZXQiLCJ0aW1lU2VyaWVzUXVlcnkiLCJ1dGNPZmZzZXRTZWMiLCJ0aW1lUmFuZ2UiLCJ1dGNPZmZzZXQiLCJyZXNwb25zZSIsInByZXBhcmVUYXJnZXRzIiwiRG9uZSIsImV4cGxvcmVRdWVyeSIsInBhbmVsc1F1ZXJ5IiwicnVubmluZ1F1ZXJpZXNDb3VudCIsInN1YlF1ZXJpZXMiLCJmaWx0ZXJBbmRNYXBSZXNwb25zZSIsImNhbmNlbGxlZCIsInJlc3BvbnNlTGlzdExlbmd0aCIsIkxvYWRpbmciLCJydW5RdWVyeSIsIm9ic2VydmFibGVzIiwicmVzdWx0cyIsInJlZHVjZSIsInBlcmZvcm1JbnN0YW50UXVlcnkiLCJnZXRFeGVtcGxhcnMiLCJwZXJmb3JtVGltZVNlcmllc1F1ZXJ5IiwiaGludGluZyIsIm1pbkludGVydmFsIiwicmVwbGFjZSIsInNjcmFwZUludGVydmFsIiwiYWRqdXN0ZWRJbnRlcnZhbCIsImFkanVzdEludGVydmFsIiwiZ2V0UmFuZ2VTY29wZWRWYXJzIiwiX19pbnRlcnZhbCIsIl9faW50ZXJ2YWxfbXMiLCJlbmhhbmNlRXhwcldpdGhBZEhvY0ZpbHRlcnMiLCJhZGp1c3RlZCIsImFsaWduUmFuZ2UiLCJyYXRlSW50ZXJ2YWwiLCJfX3JhdGVfaW50ZXJ2YWwiLCJzYWZlSW50ZXJ2YWwiLCJoYW5kbGVFcnJvcnMiLCJtZXRyaWNGaW5kUXVlcnkiLCJpbnRlcnZhbFRvTXMiLCJpbnRlcnBvbGF0ZWQiLCJwcm9jZXNzIiwibXNSYW5nZSIsImRpZmYiLCJzUmFuZ2UiLCJyb3VuZCIsIl9fcmFuZ2VfbXMiLCJfX3JhbmdlX3MiLCJfX3JhbmdlIiwiYW5ub3RhdGlvblF1ZXJ5IiwicXVlcnlNb2RlbCIsImdldFJlZiIsImFwcGx5VGVtcGxhdGVWYXJpYWJsZXMiLCJyc3AiLCJwcm9jZXNzQW5ub3RhdGlvblJlc3BvbnNlIiwiZ2V0U3VidGl0bGUiLCJidWlsZEluZm8iLCJnZXRCdWlsZEluZm8iLCJnZXRCdWlsZEluZm9NZXNzYWdlIiwiZ2V0VGFnS2V5cyIsInNlcmllc0xhYmVscyIsImNvbmNhdCIsInVuaXF1ZUxhYmVscyIsImdldFRhZ1ZhbHVlcyIsImRpc2FibGVkIiwidW5zdXBwb3J0ZWQiLCJMT0dPUyIsIkxvdGV4IiwiTWltaXIiLCJDT0xPUlMiLCJBcHBEaXNwbGF5TmFtZXMiLCJhcHBsaWNhdGlvblN1YlR5cGUiLCJ3aWR0aCIsInZlcnRpY2FsQWxpZ24iLCJhcHBsaWNhdGlvbiIsImRpc3BsYXkiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwicm93R2FwIiwiY29sdW1uR2FwIiwibWFyZ2luVG9wIiwiZmVhdHVyZXMiLCJydWxlckFwaUVuYWJsZWQiLCJ0ZXN0RGF0YXNvdXJjZSIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwiaW50ZXJ2YWxNcyIsInJlcyIsInZlcmJvc2VNZXNzYWdlIiwiaW50ZXJwb2xhdGVWYXJpYWJsZXNJblF1ZXJpZXMiLCJleHBhbmRlZFF1ZXJpZXMiLCJleHBhbmRlZFF1ZXJ5IiwiZ3JvdXBzIiwiZXh0cmFjdFJ1bGVNYXBwaW5nRnJvbUdyb3VwcyIsImxvZyIsImdldFJlc291cmNlIiwic3VidHJhY3QiLCJ0cmltIiwibWFwcGluZyIsImRhdGUiLCJyb3VuZFVwIiwiZ2V0VGltZVJhbmdlUGFyYW1zIiwibGFiZWxEYXRhIiwiYWRob2NGaWx0ZXJzIiwiZ2V0QWRob2NGaWx0ZXJzIiwiZmluYWxRdWVyeSIsImFjYyIsImZpbHRlclF1ZXJ5IiwiZ2V0VmFyaWFibGVzIiwiaW50ZXJwb2xhdGVTdHJpbmciLCJzdHJpbmciLCJhbGlnbmVkRW5kIiwiYWxpZ25lZFN0YXJ0IiwiZ3JvdXAiLCJydWxlcyIsInJ1bGUiLCJvbmNlIiwiY2hhaW4iLCJkaWZmZXJlbmNlIiwiUHJpc20iLCJBYnN0cmFjdExhYmVsT3BlcmF0b3IiLCJMYW5ndWFnZVByb3ZpZGVyIiwiU2VhcmNoRnVuY3Rpb25UeXBlIiwiYWRkTGltaXRJbmZvIiwiZXh0cmFjdExhYmVsTWF0Y2hlcnMiLCJmaXhTdW1tYXJpZXNNZXRhZGF0YSIsInBhcnNlU2VsZWN0b3IiLCJwcm9jZXNzSGlzdG9ncmFtTWV0cmljcyIsInByb2Nlc3NMYWJlbHMiLCJyb3VuZFNlY1RvTWluIiwidG9Qcm9tTGlrZVF1ZXJ5IiwiUHJvbXFsU3ludGF4IiwiRlVOQ1RJT05TIiwiUkFURV9SQU5HRVMiLCJERUZBVUxUX0tFWVMiLCJISVNUT1JZX0lURU1fQ09VTlQiLCJISVNUT1JZX0NPVU5UX0NVVE9GRiIsIlNVR0dFU1RJT05TX0xJTUlUIiwid3JhcExhYmVsIiwic2V0RnVuY3Rpb25LaW5kIiwia2luZCIsImFkZEhpc3RvcnlNZXRhZGF0YSIsImN1dG9mZlRzIiwiaGlzdG9yeUZvckl0ZW0iLCJoIiwidHMiLCJjb3VudCIsInJlY2VudCIsImxhc3RRdWVyaWVkIiwiZnJvbU5vdyIsImRvY3VtZW50YXRpb24iLCJhZGRNZXRyaWNzTWV0YWRhdGEiLCJtZXRyaWMiLCJtZXRhZGF0YSIsImdldE1ldGFkYXRhU3RyaW5nIiwidG9VcHBlckNhc2UiLCJQUkVGSVhfREVMSU1JVEVSX1JFR0VYIiwiUHJvbVFsTGFuZ3VhZ2VQcm92aWRlciIsImluaXRpYWxWYWx1ZXMiLCJkZWZhdWx0VmFsdWUiLCJmZXRjaExhYmVscyIsImZldGNoTGFiZWxWYWx1ZXMiLCJsb2FkTWV0cmljc01ldGFkYXRhIiwic29ydCIsImVtcHR5UmVzdWx0IiwiZG9jdW1lbnQiLCJzZWxlY3RlZExpbmVzIiwiZ2V0VGV4dHNBdFJhbmdlIiwic2VsZWN0aW9uIiwiY3VycmVudExpbmUiLCJzaXplIiwiZmlyc3QiLCJnZXRUZXh0IiwibmV4dENoYXJhY3RlciIsImFuY2hvciIsIm9mZnNldCIsInRva2VuUmVjb2duaXplZCIsInByZWZpeFVucmVjb2duaXplZCIsIm5vU3VmZml4Iiwic2FmZVByZWZpeCIsIm9wZXJhdG9yc1BhdHRlcm4iLCJpc05leHRPcGVyYW5kIiwiZ2V0UmFuZ2VDb21wbGV0aW9uSXRlbXMiLCJnZXRMYWJlbENvbXBsZXRpb25JdGVtcyIsImdldEFnZ3JlZ2F0aW9uQ29tcGxldGlvbkl0ZW1zIiwiZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXMiLCJnZXRCZWdpbm5pbmdDb21wbGV0aW9uSXRlbXMiLCJnZXRUZXJtQ29tcGxldGlvbkl0ZW1zIiwiaGlzdG9yeUl0ZW1zIiwidW5pcSIsInRha2UiLCJzZWFyY2hGdW5jdGlvblR5cGUiLCJQcmVmaXgiLCJza2lwU29ydCIsIml0ZW1zIiwiRnV6enkiLCJxdWVyeU9mZnNldCIsInF1ZXJ5VGV4dCIsImdldEJsb2NrcyIsImJsb2NrIiwiYmxvY2tUZXh0IiwiYW5jaG9yQmxvY2siLCJvcGVuUGFyZW5zQWdncmVnYXRpb25JbmRleCIsImxhc3RJbmRleE9mIiwib3BlblBhcmVuc1NlbGVjdG9ySW5kZXgiLCJjbG9zZVBhcmVuc1NlbGVjdG9ySW5kZXgiLCJpbmRleE9mIiwiY2xvc2VQYXJlbnNBZ2dyZWdhdGlvbkluZGV4Iiwic2VsZWN0b3JTdHJpbmciLCJnZXRTZXJpZXMiLCJsYWJlbEtleXMiLCJsaW1pdEluZm8iLCJsaW5lIiwiY3Vyc29yT2Zmc2V0Iiwic3VmZml4Iiwic3Vic3RyIiwiaXNWYWx1ZVN0YXJ0IiwiaXNWYWx1ZUVuZCIsImlzUHJlVmFsdWUiLCJpc1ZhbHVlRW1wdHkiLCJoYXNWYWx1ZVByZWZpeCIsInBhcnNlZFNlbGVjdG9yIiwiY29udGFpbnNNZXRyaWMiLCJleGlzdGluZ0tleXMiLCJwb3NzaWJsZUtleXMiLCJuZXdJdGVtcyIsIm5ld1N1Z2dlc3Rpb24iLCJ3aXRoTmFtZSIsImludGVycG9sYXRlZE5hbWUiLCJ1cmxQYXJhbXMiLCJjYWNoZVBhcmFtcyIsInBhcnNlSW50IiwiY2FjaGVLZXkiLCJsYWJlbHNDYWNoZSIsInNldCIsImNsZWFuVGV4dCIsInMiLCJwYXJ0cyIsImxhc3QiLCJwb3AiLCJ0cmltTGVmdCIsImxhYmVsQmFzZWRRdWVyeSIsInByb21RdWVyeSIsImxhYmVsTWF0Y2hlcnMiLCJ0b2tlbnMiLCJ0b2tlbml6ZSIsIm5hbWVMYWJlbFZhbHVlIiwiZ2V0TmFtZUxhYmVsVmFsdWUiLCJFcXVhbCIsImZldGNoRGVmYXVsdFNlcmllcyIsImxhYmVsRmV0Y2hUcyIsIkFycmF5IiwiaXNBcnJheSIsInByb3AiLCJpbnZlcnQiLCJUb2tlbiIsInJlc3VsdFNldCIsInJlZ2V4cCIsIlJlZ0V4cCIsImlzSGlzdG9ncmFtVmFsdWUiLCJ0ZXN0IiwiYWRkIiwidmFsdWVTZXQiLCJfX25hbWVfXyIsInZhbHVlQXJyYXkiLCJsaW1pdFN1Z2dlc3Rpb25zIiwic2VsZWN0b3JSZWdleHAiLCJsYWJlbFJlZ2V4cCIsInByZWZpeE9wZW4iLCJwcmVmaXhDbG9zZSIsInN1ZmZpeENsb3NlSW5kZXgiLCJzdWZmaXhDbG9zZSIsInN1ZmZpeE9wZW5JbmRleCIsInN1ZmZpeE9wZW4iLCJsYWJlbE9mZnNldCIsInZhbHVlU3RhcnQiLCJ2YWx1ZUVuZCIsIm1ldHJpY1ByZWZpeCIsIm1ldHJpY01hdGNoIiwiY2xlYW5TZWxlY3RvciIsInJ1bGVOYW1lcyIsInJ1bGVzUmVnZXgiLCJwcmUiLCJwb3N0IiwicXVlcnlBcnJheSIsImludmFsaWRMYWJlbHNSZWdleCIsImNvcnJlY3RseUV4cGFuZGVkUXVlcnlBcnJheSIsImFkZExhYmVsc1RvRXhwcmVzc2lvbiIsImludmFsaWRMYWJlbHNSZWdleHAiLCJpbmRleE9mUmVnZXhNYXRjaCIsImV4cHJCZWZvcmVSZWdleE1hdGNoIiwiZXhwckFmdGVyUmVnZXhNYXRjaCIsImFycmF5T2ZMYWJlbE9iamVjdHMiLCJvYmoiLCJiYXNlTWV0YWRhdGEiLCJzdW1tYXJ5TWV0YWRhdGEiLCJzeW50aGV0aWNNZXRhZGF0YSIsIm1pbGxpc2Vjb25kcyIsInNlY29uZHMiLCJSRTJfTUVUQUNIQVJBQ1RFUlMiLCJlc2NhcGVQcm9tZXRoZXVzUmVnZXhwIiwiRnJvbVByb21MaWtlTWFwIiwiTm90RXF1YWwiLCJFcXVhbFJlZ0V4IiwiTm90RXF1YWxSZWdFeCIsIlRvUHJvbUxpa2VNYXAiLCJ0b1Byb21MaWtlRXhwciIsInRva2VuIiwibGFiZWxPcGVyYXRvciIsImNvbnRlbnRUb2tlbnMiLCJjb250ZW50IiwiY3VycmVudFRva2VuIiwiY3VycmVudFN0ciIsImxhYmVsQ29tcGFyYXRvciIsIl9tYXAiLCJsYWJlbE5hbWVzUmVnZXgiLCJsYWJlbFZhbHVlc1JlZ2V4IiwibWV0cmljTmFtZXNSZWdleCIsInF1ZXJ5UmVzdWx0UmVnZXgiLCJsYWJlbE5hbWVzUXVlcnkiLCJsYWJlbFZhbHVlc1F1ZXJ5IiwibWV0cmljTmFtZXNRdWVyeSIsIm1ldHJpY05hbWVRdWVyeSIsInF1ZXJ5UmVzdWx0UXVlcnkiLCJtZXRyaWNOYW1lQW5kTGFiZWxzUXVlcnkiLCJfbGFiZWxzIiwiZXhwYW5kYWJsZSIsIm1ldHJpY0ZpbHRlclBhdHRlcm4iLCJyIiwibWF0Y2hlZE1ldHJpY05hbWUiLCJpbnN0YW50UXVlcnkiLCJtZXRyaWNEYXRhIiwic2VsZiIsIkRhdGFTb3VyY2VQbHVnaW4iLCJwbHVnaW4iLCJzZXRRdWVyeUVkaXRvciIsInNldENvbmZpZ0VkaXRvciIsInNldFF1ZXJ5RWRpdG9ySGVscCIsInNvcnRWYWx1ZSIsIk9QRVJBVE9SUyIsIkxPR0lDQUxfT1BFUkFUT1JTIiwiVFJJR09OT01FVFJJQ19GVU5DVElPTlMiLCJpbnNlcnRUZXh0IiwiZGV0YWlsIiwiQUdHUkVHQVRJT05fT1BFUkFUT1JTIiwiUFJPTV9LRVlXT1JEUyIsImtleXdvcmQiLCJwcm9tcWxHcmFtbWFyIiwiY29tbWVudCIsInBhdHRlcm4iLCJsb29rYmVoaW5kIiwiaW5zaWRlIiwiYWxpYXMiLCJwdW5jdHVhdGlvbiIsImdyZWVkeSIsImZ1bmN0aW9uIiwiZiIsImlkTGlzdCIsIm51bWJlciIsIlNVTV9ISU5UX1RIUkVTSE9MRF9DT1VOVCIsImhpbnRzIiwiaGlzdG9ncmFtTWV0cmljIiwibmFtZU1hdGNoIiwiY291bnRlck5hbWVNZXRyaWMiLCJtZXRyaWNNZXRhZGF0YUtleXMiLCJjZXJ0YWluIiwidG9Mb3dlckNhc2UiLCJtZXRyaWNSZWdleCIsImZpeGFibGVRdWVyeSIsInZlcmIiLCJtYXBwaW5nRm9yUXVlcnkiLCJydWxlTmFtZSIsInNpbXBsZU1ldHJpYyIsInByZXZlbnRTdWJtaXQiLCJnZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMiLCJnZXRPcGVyYXRpb25EZWZpbml0aW9ucyIsIkxva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UiLCJQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSIsImFsbE9wZXJhdGlvbnMiLCJmdW5jIiwieCIsInNldE9wZXJhdGlvbkNhdGVnb3JpZXMiLCJBZ2dyZWdhdGlvbnMiLCJSYW5nZUZ1bmN0aW9ucyIsIkZ1bmN0aW9ucyIsIkJpbmFyeU9wcyIsIlRyaWdvbm9tZXRyaWMiLCJUaW1lIiwiZ2V0UXVlcnlQYXR0ZXJucyIsIm9wZXJhdGlvbnMiLCJwcm9tUXVlcnlNb2RlbGxlciIsImFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvciIsImNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uIiwiY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0iLCJnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lIiwiZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZiIsIlByb21PcGVyYXRpb25JZCIsIlN1bSIsIkF2ZyIsIk1pbiIsIk1heCIsIkNvdW50IiwiVG9wSyIsImRlZmF1bHRQYXJhbXMiLCJCb3R0b21LIiwiQ291bnRWYWx1ZXMiLCJjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lIiwiU3VtT3ZlclRpbWUiLCJBdmdPdmVyVGltZSIsIk1pbk92ZXJUaW1lIiwiTWF4T3ZlclRpbWUiLCJDb3VudE92ZXJUaW1lIiwiTGFzdE92ZXJUaW1lIiwiUHJlc2VudE92ZXJUaW1lIiwiQWJzZW50T3ZlclRpbWUiLCJTdGRkZXZPdmVyVGltZSIsImFsdGVybmF0aXZlc0tleSIsImNhdGVnb3J5IiwicmVuZGVyZXIiLCJvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlciIsImFkZE9wZXJhdGlvbkhhbmRsZXIiLCJtb2RlbCIsImRlZiIsImlubmVyRXhwciIsInJhbmdlVmVjdG9yIiwiZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIiLCJiaW5hcnlTY2FsYXJEZWZzIiwiQWRkaXRpb24iLCJzaWduIiwiU3VidHJhY3Rpb24iLCJNdWx0aXBseUJ5IiwiRGl2aWRlQnkiLCJNb2R1bG8iLCJFeHBvbmVudCIsIkVxdWFsVG8iLCJjb21wYXJpc29uIiwiTm90RXF1YWxUbyIsIkdyZWF0ZXJUaGFuIiwiTGVzc1RoYW4iLCJHcmVhdGVyT3JFcXVhbCIsIkxlc3NPckVxdWFsIiwiYmluYXJ5U2NhbGFyT3BlcmF0b3JUb09wZXJhdG9yTmFtZSIsImJpbmFyeVNjYWxhck9wZXJhdGlvbnMiLCJvcERlZiIsImdldFNpbXBsZUJpbmFyeVJlbmRlcmVyIiwiYmluYXJ5UmVuZGVyZXIiLCJwYXJhbSIsImJvb2wiLCJ0b09wdGlvbiIsImdldE9wZXJhdGlvblBhcmFtSWQiLCJMYWJlbFBhcmFtRWRpdG9yIiwib3BlcmF0aW9uSW5kZXgiLCJpc0xvYWRpbmciLCJsb2FkR3JvdXBCeUxhYmVscyIsInJlbmRlckxhYmVscyIsIkhpZ2hsaWdodGVyIiwiRWRpdG9yRmllbGRHcm91cCIsInNwbGl0U2VwYXJhdG9yIiwiTWV0cmljU2VsZWN0Iiwib25HZXRNZXRyaWNzIiwiY3VzdG9tRmlsdGVyT3B0aW9uIiwic2VhcmNoUXVlcnkiLCJzZWFyY2hXb3JkcyIsImN1ciIsImZvcm1hdE9wdGlvbkxhYmVsIiwiaW5wdXRWYWx1ZSIsImhpZ2hsaWdodCIsInNlbGVjdCIsIndhcm5pbmciLCJjb250cmFzdFRleHQiLCJGbGV4SXRlbSIsIlByb21RdWVyeUJ1aWxkZXIiLCJOZXN0ZWRRdWVyeSIsIm5lc3RlZFF1ZXJ5Iiwib25SZW1vdmUiLCJjYXJkIiwiaGVhZGVyIiwib3BlcmF0b3JzIiwidmVjdG9yTWF0Y2hXcmFwcGVyIiwidmVjdG9yTWF0Y2hlc1R5cGUiLCJ2ZWN0b3JNYXRjaElucHV0IiwidmVjdG9yTWF0Y2hlcyIsImV2dCIsImJvZHkiLCJ1cGRhdGUiLCJmbGV4RGlyZWN0aW9uIiwiZ2FwIiwicGFkZGluZyIsImFsaWduSXRlbXMiLCJ3aGl0ZVNwYWNlIiwicGFkZGluZ0xlZnQiLCJtYXJnaW5MZWZ0IiwiU3RhY2siLCJOZXN0ZWRRdWVyeUxpc3QiLCJuZXN0ZWRRdWVyaWVzIiwiYmluYXJ5UXVlcmllcyIsIm9uTmVzdGVkUXVlcnlVcGRhdGUiLCJ1cGRhdGVkTGlzdCIsIkxhYmVsRmlsdGVycyIsIk9wZXJhdGlvbkxpc3QiLCJPcGVyYXRpb25zRWRpdG9yUm93IiwiUHJvbVF1ZXJ5QnVpbGRlckhpbnRzIiwib25DaGFuZ2VMYWJlbHMiLCJ3aXRoVGVtcGxhdGVWYXJpYWJsZU9wdGlvbnMiLCJvcHRpb25zUHJvbWlzZSIsIm9uR2V0TGFiZWxOYW1lcyIsImZvckxhYmVsIiwibGFiZWxzVG9Db25zaWRlciIsImxhYmVsc0luZGV4IiwibGFiZWxOYW1lIiwib25HZXRMYWJlbFZhbHVlcyIsImZvckxhYmVsSW50ZXJwb2xhdGVkIiwiZ2V0TWV0cmljcyIsImNyZWF0ZVNsaWNlIiwiUXVlcnlQcmV2aWV3IiwiUHJvbVF1ZXJ5QnVpbGRlckNvbnRhaW5lciIsInNob3dSYXdRdWVyeSIsImRpc3BhdGNoIiwic3RhdGVTbGljZSIsInJlZHVjZXIiLCJleHByQ2hhbmdlZCIsIm9uVmlzUXVlcnlDaGFuZ2UiLCJ2aXN1YWxRdWVyeUNoYW5nZSIsImluaXRpYWxTdGF0ZSIsInJlZHVjZXJzIiwicGF5bG9hZCIsInBhcnNlUmVzdWx0IiwiYWN0aW9ucyIsIk9wZXJhdGlvbkV4cGxhaW5lZEJveCIsIk9wZXJhdGlvbkxpc3RFeHBsYWluZWQiLCJSYXdRdWVyeSIsIlByb21RdWVyeUJ1aWxkZXJFeHBsYWluZWQiLCJsYW5nIiwiZ3JhbW1hciIsInNldEhpbnRzIiwiY29udGFpbmVyIiwibmV3UHJvbVF1ZXJ5IiwidmlzdWFsUXVlcnkiLCJRdWVyeU9wdGlvbkdyb3VwIiwiZ2V0TGVnZW5kTW9kZUxhYmVsIiwiUHJvbVF1ZXJ5TGVnZW5kRWRpdG9yIiwiUHJvbVF1ZXJ5QnVpbGRlck9wdGlvbnMiLCJvbkNoYW5nZUZvcm1hdCIsIm9uQ2hhbmdlU3RlcCIsInF1ZXJ5VHlwZU9wdGlvbnMiLCJxdWVyeVR5cGVWYWx1ZSIsImdldFF1ZXJ5VHlwZVZhbHVlIiwicXVlcnlUeXBlTGFiZWwiLCJnZXRDb2xsYXBzZWRJbmZvIiwic2hvdWxkU2hvd0V4ZW1wbGFyU3dpdGNoIiwiRWRpdG9ySGVhZGVyIiwiSW5saW5lU2VsZWN0IiwicmVwb3J0SW50ZXJhY3Rpb24iLCJDb25maXJtTW9kYWwiLCJGZWVkYmFja0xpbmsiLCJRdWVyeUVkaXRvck1vZGVUb2dnbGUiLCJRdWVyeUhlYWRlclN3aXRjaCIsIlF1ZXJ5RWRpdG9yTW9kZSIsImNoYW5nZUVkaXRvck1vZGUiLCJnZXRRdWVyeVdpdGhEZWZhdWx0cyIsInVzZVJhd1F1ZXJ5IiwicGFyc2VNb2RhbE9wZW4iLCJzZXRQYXJzZU1vZGFsT3BlbiIsImRhdGFJc1N0YWxlIiwic2V0RGF0YUlzU3RhbGUiLCJyYXdRdWVyeSIsInNldFJhd1F1ZXJ5IiwiZWRpdG9yTW9kZSIsIm9uRWRpdG9yTW9kZUNoYW5nZSIsIm5ld01ldHJpY0VkaXRvck1vZGUiLCJuZXdFZGl0b3IiLCJwcmV2aW91c0VkaXRvciIsIkJ1aWxkZXIiLCJlcnJvcnMiLCJvblF1ZXJ5UHJldmlld0NoYW5nZSIsIm9uQ2hhbmdlSW50ZXJuYWwiLCJDb2RlIiwiRXhwbGFpbiIsIkxlZ2VuZEZvcm1hdE1vZGUiLCJsZWdlbmRNb2RlT3B0aW9ucyIsIkF1dG8iLCJWZXJib3NlIiwiQ3VzdG9tIiwibW9kZSIsImdldExlZ2VuZE1vZGUiLCJpbnB1dFJlZiIsIm9uTGVnZW5kRm9ybWF0Q2hhbmdlZCIsIm5ld0Zvcm1hdCIsIm9uTGVnZW5kTW9kZUNoYW5nZWQiLCJzZXRUaW1lb3V0IiwiZm9jdXMiLCJzZXRTZWxlY3Rpb25SYW5nZSIsImZ1bmN0aW9uUmVuZGVyZXJMZWZ0IiwiZnVuY3Rpb25SZW5kZXJlclJpZ2h0IiwicmFuZ2VSZW5kZXJlckxlZnRXaXRoUGFyYW1zIiwicmFuZ2VSZW5kZXJlclJpZ2h0V2l0aFBhcmFtcyIsIkhpc3RvZ3JhbVF1YW50aWxlIiwiTGFiZWxSZXBsYWNlIiwiTG4iLCJjcmVhdGVSYW5nZUZ1bmN0aW9uIiwiQ2hhbmdlcyIsIlJhdGUiLCJJcmF0ZSIsIkluY3JlYXNlIiwiSWRlbHRhIiwiRGVsdGEiLCJjcmVhdGVGdW5jdGlvbiIsIkhvbHRXaW50ZXJzIiwiY2hhbmdlVHlwZUhhbmRsZXIiLCJvcGVyYXRpb25UeXBlQ2hhbmdlZEhhbmRsZXJGb3JSYW5nZUZ1bmN0aW9uIiwiUHJlZGljdExpbmVhciIsIlF1YW50aWxlT3ZlclRpbWUiLCJhZGROZXN0ZWRRdWVyeUhhbmRsZXIiLCJBYnNlbnQiLCJBY29zIiwiQWNvc2giLCJBc2luIiwiQXNpbmgiLCJBdGFuIiwiQXRhbmgiLCJDZWlsIiwiQ2xhbXAiLCJDbGFtcE1heCIsIkNsYW1wTWluIiwiQ29zIiwiQ29zaCIsIkRheU9mTW9udGgiLCJEYXlPZldlZWsiLCJEYXlzSW5Nb250aCIsIkRlZyIsIkRlcml2IiwiRXhwIiwiRmxvb3IiLCJHcm91cCIsIkhvdXIiLCJMYWJlbEpvaW4iLCJyZXN0UGFyYW0iLCJvcHRpb25hbCIsImxhYmVsSm9pblJlbmRlcmVyIiwibGFiZWxKb2luQWRkT3BlcmF0aW9uSGFuZGxlciIsIkxvZzEwIiwiTG9nMiIsIk1pbnV0ZSIsIk1vbnRoIiwiUGkiLCJRdWFudGlsZSIsIlJhZCIsIlJlc2V0cyIsIlJvdW5kIiwiU2NhbGFyIiwiU2duIiwiU2luIiwiU2luaCIsIlNvcnQiLCJTb3J0RGVzYyIsIlNxcnQiLCJTdGRkZXYiLCJUYW4iLCJUYW5oIiwiVGltZXN0YW1wIiwiVmVjdG9yIiwiWWVhciIsImRlZmluaXRpb24iLCJ3aXRoUmF0ZUludGVydmFsIiwib3BlcmF0aW9uIiwibmV3RGVmIiwibmV3T3BlcmF0aW9uIiwiZmlyc3RPcCIsImdldE9wZXJhdGlvbkRlZiIsInNlcGFyYXRvciIsIkVycm9yTmFtZSIsImdldEFsbEJ5VHlwZSIsImdldExlZnRNb3N0Q2hpbGQiLCJnZXRTdHJpbmciLCJtYWtlQmluT3AiLCJtYWtlRXJyb3IiLCJyZXBsYWNlVmFyaWFibGVzIiwicmVwbGFjZWRFeHByIiwidG9wTm9kZSIsImhhbmRsZUV4cHJlc3Npb24iLCJpc0VtcHR5UXVlcnkiLCJnZXRMYWJlbCIsImdldENoaWxkIiwiaGFuZGxlRnVuY3Rpb24iLCJoYW5kbGVBZ2dyZWdhdGlvbiIsImhhbmRsZUJpbmFyeSIsImlzSW50ZXJ2YWxWYXJpYWJsZUVycm9yIiwiY2hpbGQiLCJmaXJzdENoaWxkIiwibmV4dFNpYmxpbmciLCJwcmV2U2libGluZyIsInJhbmdlRnVuY3Rpb25zIiwibmFtZU5vZGUiLCJmdW5jTmFtZSIsImNhbGxBcmdzIiwiZW5kc1dpdGgiLCJ1bnNoaWZ0IiwidXBkYXRlRnVuY3Rpb25BcmdzIiwibW9kaWZpZXIiLCJieU1vZGlmaWVyIiwid2l0aG91dE1vZGlmaWVyIiwibGVmdCIsImJpbk1vZGlmaWVyIiwiZ2V0QmluYXJ5TW9kaWZpZXIiLCJyaWdodCIsImxhc3RDaGlsZCIsImxlZnROdW1iZXIiLCJyaWdodE51bWJlciIsInJpZ2h0QmluYXJ5IiwiaXNCb29sIiwibGVmdE1vc3RDaGlsZCIsImJpblF1ZXJ5IiwiaXNNYXRjaGVyIiwibWF0Y2hUeXBlIiwibWF0Y2hlcyIsIm1hdGNoZXIiLCJmZWVkYmFja1VybCIsImZlZWRiYWNrTGlua3NFbmFibGVkIiwibGluayIsImNvbG9yIiwic2Vjb25kYXJ5IiwiZm9udFNpemUiLCJib2R5U21hbGwiLCJ1bmlxQnkiLCJBY2Nlc3NvcnlCdXR0b24iLCJJbnB1dEdyb3VwIiwiTGFiZWxGaWx0ZXJJdGVtIiwiZGVmYXVsdE9wIiwiaXNNdWx0aVNlbGVjdCIsImdldFNlbGVjdE9wdGlvbnNGcm9tU3RyaW5nIiwiZ2V0T3B0aW9ucyIsImxhYmVsVmFsdWVzIiwic2VsZWN0ZWRPcHRpb25zIiwiaXNMb2FkaW5nTGFiZWxOYW1lcyIsImxhYmVsTmFtZXMiLCJjaGFuZ2UiLCJpc0xvYWRpbmdMYWJlbFZhbHVlcyIsImNoYW5nZXMiLCJFZGl0b3JMaXN0IiwibGFiZWxzRmlsdGVycyIsInNldEl0ZW1zIiwib25MYWJlbHNDaGFuZ2UiLCJvbkNoYW5nZUl0ZW0iLCJSZWdpc3RyeSIsImdldE9wZXJhdGlvbnMiLCJvcGVyYXRpb25zUmVnaXN0eSIsImNhdGVnb3JpZXMiLCJnZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkiLCJoaWRlRnJvbUxpc3QiLCJnZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMiLCJnZXRDYXRlZ29yaWVzIiwiZ2V0SWZFeGlzdHMiLCJyZW5kZXJPcGVyYXRpb25zIiwicXVlcnlTdHJpbmciLCJyZW5kZXJCaW5hcnlRdWVyaWVzIiwicmVuZGVyQmluYXJ5UXVlcnkiLCJsZWZ0T3BlcmFuZCIsImJpbmFyeVF1ZXJ5IiwibmVzdGVkIiwiaGFzQmluYXJ5T3AiLCJEcmFnZ2FibGUiLCJPcGVyYXRpb25IZWFkZXIiLCJnZXRPcGVyYXRpb25QYXJhbUVkaXRvciIsIk9wZXJhdGlvbkVkaXRvciIsInF1ZXJ5TW9kZWxsZXIiLCJzaG91bGRIaWdobGlnaHQiLCJ1c2VIaWdobGlnaHQiLCJvblBhcmFtVmFsdWVDaGFuZ2VkIiwicGFyYW1JZHgiLCJjYWxsUGFyYW1DaGFuZ2VkVGhlbk9uQ2hhbmdlIiwib25BZGRSZXN0UGFyYW0iLCJvblJlbW92ZVJlc3RQYXJhbSIsIm9wZXJhdGlvbkVsZW1lbnRzIiwicGFyYW1JbmRleCIsInBhcmFtRGVmIiwiRWRpdG9yIiwicGFyYW1Sb3ciLCJoaWRlTmFtZSIsInBhcmFtTmFtZSIsImluZm9JY29uIiwicGFyYW1WYWx1ZSIsImxhc3RQYXJhbURlZiIsInJlbmRlckFkZFJlc3RQYXJhbUJ1dHRvbiIsInByb3ZpZGVkIiwiY2FyZEhpZ2hsaWdodCIsImlubmVyUmVmIiwiZHJhZ2dhYmxlUHJvcHMiLCJkcmFnSGFuZGxlUHJvcHMiLCJhcnJvdyIsImFycm93TGluZSIsImFycm93QXJyb3ciLCJrZWVwSGlnaGxpZ2h0Iiwic2V0S2VlcEhpZ2hsaWdodCIsImNsZWFyVGltZW91dCIsInBhcmFtQ2hhbmdlZEhhbmRsZXIiLCJiYWNrZ3JvdW5kIiwiYm9yZGVyIiwibWVkaXVtIiwiY3Vyc29yIiwiYm9yZGVyUmFkaXVzIiwic2hhcGUiLCJtYXJnaW5Cb3R0b20iLCJwb3NpdGlvbiIsInRyYW5zaXRpb24iLCJib3hTaGFkb3ciLCJtYXJnaW4iLCJmb250V2VpZ2h0IiwiZm9udFdlaWdodE1lZGl1bSIsInRvcCIsImJhY2tncm91bmRDb2xvciIsInN0cm9uZyIsImJvcmRlclRvcCIsImJvcmRlckJvdHRvbSIsImJvcmRlckxlZnQiLCJyZW5kZXJNYXJrZG93biIsInN0ZXBOdW1iZXIiLCJtYXJrZG93biIsImNoaWxkcmVuIiwiYm94IiwiYm94SW5uZXIiLCJfX2h0bWwiLCJqdXN0aWZ5Q29udGVudCIsInBhZGRpbmdCb3R0b20iLCJmb250RmFtaWx5TW9ub3NwYWNlIiwiYSIsInRleHREZWNvcmF0aW9uIiwiT3BlcmF0aW9uSW5mb0J1dHRvbiIsIm9uVG9nZ2xlU3dpdGNoZXIiLCJpc09wZW4iLCJhbHRlcm5hdGl2ZXMiLCJhbHQiLCJvcGVyYXRpb25IZWFkZXJCdXR0b25zIiwic2VsZWN0V3JhcHBlciIsImNoYW5nZWRPcCIsIm9wYWNpdHkiLCJ0cmFuc2l0aW9ucyIsImNyZWF0ZSIsImR1cmF0aW9uIiwic2hvcnQiLCJwYWRkaW5nUmlnaHQiLCJ1c2VQb3BwZXJUb29sdGlwIiwiUG9ydGFsIiwic2hvdyIsInNldFNob3ciLCJnZXRUb29sdGlwUHJvcHMiLCJzZXRUb29sdGlwUmVmIiwic2V0VHJpZ2dlclJlZiIsInZpc2libGUiLCJwbGFjZW1lbnQiLCJvblZpc2libGVDaGFuZ2UiLCJpbnRlcmFjdGl2ZSIsInRyaWdnZXIiLCJkb2NCb3giLCJkb2NCb3hIZWFkZXIiLCJkb2NCb3hCb2R5IiwiZ2V0T3BlcmF0aW9uRG9jcyIsIm92ZXJmbG93Iiwic2hhZG93cyIsInozIiwibWF4V2lkdGgiLCJ6SW5kZXgiLCJ0b29sdGlwIiwiaDUiLCJzaWduYXR1cmUiLCJkcm9wZG93biIsImV4cGxhaW5IYW5kbGVyIiwiRHJhZ0Ryb3BDb250ZXh0IiwiRHJvcHBhYmxlIiwidXNlTW91bnRlZFN0YXRlIiwiQ2FzY2FkZXIiLCJvcHNUb0hpZ2hsaWdodCIsInVzZU9wZXJhdGlvbnNIaWdobGlnaHQiLCJjYXNjYWRlck9wZW4iLCJzZXRDYXNjYWRlck9wZW4iLCJvbk9wZXJhdGlvbkNoYW5nZSIsImFkZE9wdGlvbnMiLCJpc0xlYWYiLCJvbkFkZE9wZXJhdGlvbiIsIm9wZXJhdGlvbkRlZiIsIm9uRHJhZ0VuZCIsImRlc3RpbmF0aW9uIiwiZWxlbWVudCIsInNvdXJjZSIsIm9uQ2FzY2FkZXJCbHVyIiwib3BlcmF0aW9uTGlzdCIsImRyb3BwYWJsZVByb3BzIiwicGxhY2Vob2xkZXIiLCJhZGRCdXR0b24iLCJpc01vdW50ZWQiLCJwcmV2T3BlcmF0aW9ucyIsIm5ld09wcyIsImV2ZXJ5IiwibmV3T3AiLCJpc1NhbWVPcCIsIm9wMSIsIm9wMiIsImhlYWRpbmciLCJmbGV4V3JhcCIsIkNoZWNrYm94IiwiU2VsZWN0SW5wdXRQYXJhbUVkaXRvciIsIkJvb2xJbnB1dFBhcmFtRWRpdG9yIiwiU2ltcGxlSW5wdXRQYXJhbUVkaXRvciIsIm1pbldpZHRoIiwicnVuUXVlcnlPbkVudGVyIiwic2VsZWN0T3B0aW9ucyIsInZhbHVlT3B0aW9uIiwicm9vdCIsIlRhZyIsImVkaXRvck1vZGVzIiwiY29tcG9uZW50IiwidW5pcXVlSWQiLCJpbnB1dFByb3BzIiwiZGFzaGVkTGFiZWwiLCJzd2l0Y2hJZFJlZiIsInN3aXRjaExhYmVsIiwidXNlVG9nZ2xlIiwiY29sbGFwc2VkSW5mbyIsInRvZ2dsZU9wZW4iLCJ0b2dnbGUiLCJlbXBoYXNpemUiLCJmbGV4R3JvdyIsInBhZGRpbmdUb3AiLCJtYXJnaW5SaWdodCIsInVzZVRoZW1lMiIsImhpZ2hsaWdodGVkIiwiZWRpdG9yRmllbGQiLCJjYXBpdGFsaXplIiwicGx1cmFsaXplIiwicmVuZGVyUGFyYW1zIiwic3RyIiwicmFuZ2VSZW5kZXJlcldpdGhQYXJhbXMiLCJyZW5kZXJMZWZ0IiwiZ2V0T25MYWJlbEFkZGVkSGFuZGxlciIsImdldEFnZ3JlZ2F0aW9uRXhwbGFpbmVyIiwiZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyIiwiZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIiLCJnZXRBZ2dyZWdhdGlvbldpdGhvdXRSZW5kZXJlciIsInBhcmFtc0RlZiIsImdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlcldpdGhQYXJhbWV0ZXIiLCJhZ2dyZWdhdGlvbiIsImFnZ3JlZ2F0aW9uUmVuZGVyZXIiLCJhZ2dyZWdhdGlvbk5hbWUiLCJhZ2dyZWdhdGlvbkV4cGxhaW5lciIsImxhYmVsV29yZCIsIm1hcFR5cGUiLCJwIiwicmVzdFBhcmFtcyIsImNoYW5nZVRvT3BlcmF0aW9uSWQiLCJvblBhcmFtQ2hhbmdlZCIsInBhcmVudFR5cGUiLCJwYXJlbnQiLCJ2YXJpYWJsZVJlZ2V4IiwidmFyMSIsInZhcjIiLCJmbXQyIiwidmFyMyIsImZpZWxkUGF0aCIsImZtdDMiLCJmbXQiLCJ2YXJUeXBlIiwidmFyVHlwZUZ1bmMiLCJyZXR1cm5WYXJpYWJsZXMiLCJudW1iZXJOb2RlIiwiaGFzQm9vbCIsInBvcyIsImNoaWxkQWZ0ZXIiLCJqc29uIiwidG9Kc29uIiwianNvblRvVGV4dCIsInRyZWVKc29uIiwibm9kZVRvU3RyaW5nIiwiaW5kZW50IiwibmV3SW5kZW50IiwiaXNMYXN0Q2hpbGQiLCJzdG9yZSIsInF1ZXJ5RWRpdG9yTW9kZURlZmF1bHRMb2NhbFN0b3JhZ2VLZXkiLCJnZXREZWZhdWx0RWRpdG9yTW9kZSIsInF1ZXJ5RWRpdG9yUmF3UXVlcnlMb2NhbFN0b3JhZ2VLZXkiLCJnZXRSYXdRdWVyeVZpc2liaWxpdHkiLCJzZXRSYXdRdWVyeVZpc2liaWxpdHkiLCJzZXR0ZXIiLCJkZXNjZW5kaW5nIiwiZGV2aWF0aW9uIiwiZ3JvdXBCeSIsInBhcnRpdGlvbiIsIkFycmF5RGF0YUZyYW1lIiwiQXJyYXlWZWN0b3IiLCJEYXRhRnJhbWVUeXBlIiwiRGF0YVRvcGljIiwiRmllbGRUeXBlIiwiZm9ybWF0TGFiZWxzIiwiZ2V0RGlzcGxheVByb2Nlc3NvciIsIlRJTUVfU0VSSUVTX1RJTUVfRklFTERfTkFNRSIsIlRJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUUiLCJnZXREYXRhU291cmNlU3J2IiwiaXNFeGVtcGxhckRhdGEiLCJpc01hdHJpeERhdGEiLCJJTkZJTklUWV9TQU1QTEVfUkVHRVgiLCJpc1RhYmxlUmVzdWx0IiwiZGF0YUZyYW1lIiwiY3VzdG9tIiwicmVzdWx0VHlwZSIsImlzSGVhdG1hcFJlc3VsdCIsInRhYmxlRnJhbWVzIiwiZnJhbWVzV2l0aG91dFRhYmxlIiwiZGYiLCJwcm9jZXNzZWRUYWJsZUZyYW1lcyIsInRyYW5zZm9ybURGVG9UYWJsZSIsImV4ZW1wbGFyRnJhbWVzIiwiZnJhbWVzV2l0aG91dFRhYmxlQW5kRXhlbXBsYXJzIiwiZGVzdGluYXRpb25zIiwicHJvY2Vzc2VkRXhlbXBsYXJGcmFtZXMiLCJleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbiIsInRyYWNlSURGaWVsZCIsImZpZWxkIiwibGlua3MiLCJnZXREYXRhTGlua3MiLCJkYXRhVG9waWMiLCJBbm5vdGF0aW9ucyIsImhlYXRtYXBSZXN1bHRzIiwiZnJhbWVzV2l0aG91dFRhYmxlSGVhdG1hcHNBbmRFeGVtcGxhcnMiLCJwcm9jZXNzZWRIZWF0bWFwRnJhbWVzIiwibWVyZ2VIZWF0bWFwRnJhbWVzIiwidHJhbnNmb3JtVG9IaXN0b2dyYW1PdmVyVGltZSIsInNvcnRTZXJpZXNCeUxhYmVsIiwib3RoZXJGcmFtZXMiLCJwcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZSIsImRmcyIsImRhdGFGcmFtZXNCeVJlZklkIiwicmVmSWRzIiwidmFsdWVUZXh0IiwiZ2V0VmFsdWVUZXh0IiwiZ2V0VmFsdWVGaWVsZCIsInZhbHVlTmFtZSIsImdldFRpbWVGaWVsZCIsImxhYmVsRmllbGRzIiwiZnJhbWVWYWx1ZUZpZWxkIiwicHJvbUxhYmVscyIsIm51bWJlckZpZWxkIiwiZmlsdGVyYWJsZSIsInBhcnNlU2FtcGxlVmFsdWUiLCJsYWJlbHNGb3JGaWVsZCIsImdldExhYmVsVmFsdWUiLCJyZXNwb25zZUxlbmd0aCIsInRyYW5zZm9ybU9wdGlvbnMiLCJwcm9tZXRoZXVzUmVzdWx0IiwiZXZlbnRzIiwiZXhlbXBsYXJEYXRhIiwiZXhlbXBsYXJzIiwic2FtcGxlZEV4ZW1wbGFycyIsInNhbXBsZUV4ZW1wbGFycyIsInRhYmxlRGF0YSIsInRyYW5zZm9ybU1ldHJpY0RhdGFUb1RhYmxlIiwidHJhbnNmb3JtVG9EYXRhRnJhbWUiLCJkYXRhTGlua3MiLCJkYXRhU291cmNlU3J2IiwiZHNTZXR0aW5ncyIsImdldEluc3RhbmNlU2V0dGluZ3MiLCJpbnRlcm5hbCIsImRhdGFzb3VyY2VOYW1lIiwidGFyZ2V0QmxhbmsiLCJidWNrZXRlZEV4ZW1wbGFycyIsImFsaWduZWRUcyIsIlN0cmluZyIsInN0YW5kYXJkRGV2aWF0aW9uIiwic2FtcGxlZEJ1Y2tldHMiLCJleGVtcGxhcnNJbkJ1Y2tldCIsImJ1Y2tldFZhbHVlcyIsImV4Iiwic2FtcGxlZEJ1Y2tldFZhbHVlcyIsImN1cnIiLCJjcmVhdGVMYWJlbEluZm8iLCJzdGVwTXMiLCJOYU4iLCJiYXNlVGltZXN0YW1wIiwiZHBzIiwiZHBWYWx1ZSIsImlzTmFOIiwiZW5kVGltZXN0YW1wIiwicGFyc2VWYWx1ZSIsImRpc3BsYXlOYW1lRnJvbURTIiwibWV0cmljRmllbGRzIiwiZCIsIm1ldHJpY0ZpZWxkIiwiaXNNcyIsImxhYmVsc1dpdGhvdXROYW1lIiwibGFiZWxQYXJ0IiwiY291bnRGaWVsZHMiLCJIZWF0bWFwUm93cyIsInNlcmllc0xpc3QiLCJ0b3BTZXJpZXMiLCJib3R0b21TZXJpZXMiLCJqIiwiYm90dG9tUG9pbnQiLCJzMSIsInMyIiwibGUxIiwibGUyIiwiTnVtYmVyIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJQT1NJVElWRV9JTkZJTklUWSIsIlN0YW5kYXJkVmFyaWFibGVTdXBwb3J0IiwiYmluZCIsIm1ldHJpY0ZpbmRTdHJlYW0iLCJ0b0RhdGFRdWVyeSJdLCJzb3VyY2VSb290IjoiIn0=