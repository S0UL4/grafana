"use strict";
(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["canvasPanel"],{

/***/ "./public/app/core/components/Layers/AddLayerButton.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddLayerButton": () => (/* binding */ AddLayerButton)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");



const AddLayerButton = ({
  onChange,
  options,
  label
}) => {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.ValuePicker, {
    icon: "plus",
    label: label,
    variant: "secondary",
    options: options,
    onChange: onChange,
    isFullWidth: true
  });
};

/***/ }),

/***/ "./public/app/core/components/Layers/LayerDragDropList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerDragDropList": () => (/* binding */ LayerDragDropList)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _LayerName__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/components/Layers/LayerName.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









const LayerDragDropList = ({
  layers,
  getLayerInfo,
  onDragEnd,
  onSelect,
  onDelete,
  onDuplicate,
  showActions,
  selection,
  excludeBaseLayer,
  onNameChange,
  verifyLayerNameUniqueness
}) => {
  const style = styles(_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.theme);

  const getRowStyle = isSelected => {
    return isSelected ? `${style.row} ${style.sel}` : style.row;
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.DragDropContext, {
    onDragEnd: onDragEnd,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Droppable, {
      droppableId: "droppable",
      children: (provided, snapshot) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({}, provided.droppableProps, {
        ref: provided.innerRef,
        children: [(() => {
          // reverse order
          const rows = [];
          const lastLayerIndex = excludeBaseLayer ? 1 : 0;
          const shouldRenderDragIconLengthThreshold = excludeBaseLayer ? 2 : 1;

          for (let i = layers.length - 1; i >= lastLayerIndex; i--) {
            const element = layers[i];
            const uid = element.getName();
            const isSelected = Boolean(selection === null || selection === void 0 ? void 0 : selection.includes(uid));
            rows.push( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Draggable, {
              draggableId: uid,
              index: rows.length,
              children: (provided, snapshot) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
                className: getRowStyle(isSelected),
                ref: provided.innerRef
              }, provided.draggableProps, provided.dragHandleProps, {
                onMouseDown: () => onSelect(element),
                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_LayerName__WEBPACK_IMPORTED_MODULE_4__.LayerName, {
                  name: uid,
                  onChange: v => onNameChange(element, v),
                  verifyLayerNameUniqueness: verifyLayerNameUniqueness !== null && verifyLayerNameUniqueness !== void 0 ? verifyLayerNameUniqueness : undefined
                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
                  className: style.textWrapper,
                  children: ["\xA0 ", getLayerInfo(element)]
                }), showActions(element) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
                  children: [onDuplicate ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.IconButton, {
                    name: "copy",
                    title: 'Duplicate',
                    className: style.actionIcon,
                    onClick: () => onDuplicate(element)
                  }) : null, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.IconButton, {
                    name: "trash-alt",
                    title: 'remove',
                    className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(style.actionIcon, style.dragIcon),
                    onClick: () => onDelete(element)
                  })]
                }), layers.length > shouldRenderDragIconLengthThreshold && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
                  title: "Drag and drop to reorder",
                  name: "draggabledots",
                  size: "lg",
                  className: style.dragIcon
                })]
              }))
            }, uid));
          }

          return rows;
        })(), provided.placeholder]
      }))
    })
  });
};
LayerDragDropList.defaultProps = {
  isGroup: () => false
};
const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.stylesFactory)(theme => ({
  wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-bottom: ${theme.spacing.md};
  `,
  row: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding: ${theme.spacing.xs} ${theme.spacing.sm};
    border-radius: ${theme.border.radius.sm};
    background: ${theme.colors.bg2};
    min-height: ${theme.spacing.formInputHeight}px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 3px;
    cursor: pointer;

    border: 1px solid ${theme.colors.formInputBorder};
    &:hover {
      border: 1px solid ${theme.colors.formInputBorderHover};
    }
  `,
  sel: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    border: 1px solid ${theme.colors.formInputBorderActive};
    &:hover {
      border: 1px solid ${theme.colors.formInputBorderActive};
    }
  `,
  dragIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    cursor: drag;
  `,
  actionIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    color: ${theme.colors.textWeak};
    &:hover {
      color: ${theme.colors.text};
    }
  `,
  typeWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    color: ${theme.colors.textBlue};
    margin-right: 5px;
  `,
  textWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    align-items: center;
    flex-grow: 1;
    overflow: hidden;
    margin-right: ${theme.spacing.sm};
  `
}));

/***/ }),

/***/ "./public/app/core/components/Layers/LayerName.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerName": () => (/* binding */ LayerName)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






const LayerName = ({
  name,
  onChange,
  verifyLayerNameUniqueness
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles)(getStyles);
  const [isEditing, setIsEditing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const [validationError, setValidationError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);

  const onEditLayer = event => {
    setIsEditing(true);
  };

  const onEndEditName = newName => {
    setIsEditing(false);

    if (validationError) {
      setValidationError(null);
      return;
    }

    if (name !== newName) {
      onChange(newName);
    }
  };

  const onInputChange = event => {
    const newName = event.currentTarget.value.trim();

    if (newName.length === 0) {
      setValidationError('An empty layer name is not allowed');
      return;
    }

    if (verifyLayerNameUniqueness && !verifyLayerNameUniqueness(newName) && newName !== name) {
      setValidationError('Layer name already exists');
      return;
    }

    if (validationError) {
      setValidationError(null);
    }
  };

  const onEditLayerBlur = event => {
    onEndEditName(event.currentTarget.value.trim());
  };

  const onKeyDown = event => {
    if (event.key === 'Enter') {
      onEndEditName(event.target.value);
    }
  };

  const onFocus = event => {
    event.target.select();
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
      className: styles.wrapper,
      children: [!isEditing && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("button", {
        className: styles.layerNameWrapper,
        title: "Edit layer name",
        onClick: onEditLayer,
        "data-testid": "layer-name-div",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("span", {
          className: styles.layerName,
          children: name
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, {
          name: "pen",
          className: styles.layerEditIcon,
          size: "sm"
        })]
      }), isEditing && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
          type: "text",
          defaultValue: name,
          onBlur: onEditLayerBlur,
          autoFocus: true,
          onKeyDown: onKeyDown,
          onFocus: onFocus,
          invalid: validationError !== null,
          onChange: onInputChange,
          className: styles.layerNameInput,
          "data-testid": "layer-name-input"
        }), validationError && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.FieldValidationMessage, {
          horizontal: true,
          children: validationError
        })]
      })]
    })
  });
};

const getStyles = theme => {
  return {
    wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      label: Wrapper;
      display: flex;
      align-items: center;
      margin-left: ${theme.spacing.xs};
    `,
    layerNameWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      display: flex;
      cursor: pointer;
      border: 1px solid transparent;
      border-radius: ${theme.border.radius.md};
      align-items: center;
      padding: 0 0 0 ${theme.spacing.xs};
      margin: 0;
      background: transparent;

      &:hover {
        background: ${theme.colors.bg3};
        border: 1px dashed ${theme.colors.border3};
      }

      &:focus {
        border: 2px solid ${theme.colors.formInputBorderActive};
      }

      &:hover,
      &:focus {
        .query-name-edit-icon {
          visibility: visible;
        }
      }
    `,
    layerName: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      font-weight: ${theme.typography.weight.semibold};
      color: ${theme.colors.textBlue};
      cursor: pointer;
      overflow: hidden;
      margin-left: ${theme.spacing.xs};
    `,
    layerEditIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
        margin-left: ${theme.spacing.md};
        visibility: hidden;
      `, 'query-name-edit-icon'),
    layerNameInput: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      max-width: 300px;
      margin: -4px 0;
    `
  };
};

/***/ }),

/***/ "./public/app/features/canvas/element.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);


/***/ }),

/***/ "./public/app/features/canvas/elements/button.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buttonItem": () => (/* binding */ buttonItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dimensions/editors/TextDimensionEditor.tsx");
/* harmony import */ var app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/APIEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






class ButtonDisplay extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  render() {
    const {
      data
    } = this.props;

    const onClick = () => {
      if (data !== null && data !== void 0 && data.api) {
        (0,app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_3__.callApi)(data.api);
      }
    };

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
      type: "submit",
      onClick: onClick,
      children: data === null || data === void 0 ? void 0 : data.text
    });
  }

}

const buttonItem = {
  id: 'button',
  name: 'Button',
  description: 'Button',
  display: ButtonDisplay,
  defaultSize: {
    width: 200,
    height: 50
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    var _cfg$api;

    const data = {
      text: cfg !== null && cfg !== void 0 && cfg.text ? ctx.getText(cfg.text).value() : '',
      api: (_cfg$api = cfg === null || cfg === void 0 ? void 0 : cfg.api) !== null && _cfg$api !== void 0 ? _cfg$api : undefined
    };
    return data;
  },
  // Heatmap overlay options
  registerOptionsUI: builder => {
    const category = ['Button'];
    builder.addCustomEditor({
      category,
      id: 'textSelector',
      path: 'config.text',
      name: 'Text',
      editor: app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_2__.TextDimensionEditor
    }).addCustomEditor({
      category,
      id: 'apiSelector',
      path: 'config.api',
      name: 'API',
      editor: app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_3__.APIEditor
    });
  }
};

/***/ }),

/***/ "./public/app/features/canvas/elements/droneFront.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "droneFrontItem": () => (/* binding */ droneFrontItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _g, _g2, _g3, _g4;








const DroneFrontDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const droneFrontTransformStyle = `rotate(${data !== null && data !== void 0 && data.rollAngle ? data.rollAngle : 0}deg)`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    className: styles.droneFront,
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 1300 290",
    style: {
      transform: droneFrontTransformStyle
    },
    children: [_g || (_g = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "arms",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "100",
        y2: "150"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "100",
        y2: "150"
      })]
    })), _g2 || (_g2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "body",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "none",
        d: " M 510 130 C 510 124 510 110 510 100 C 510 90 530 71 540 70 C 640 61 670 60 760 70 C 770 71 790 90 790 100 Q 790 120 790 130 L 790 130 Q 790 177 790 196 C 790 207 770 225 760 226 C 670 236 640 236 540 226 C 530 226 510 206 510 196 Q 510 177 510 130 Q 510 133 510 130 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("circle", {
        cx: "650",
        cy: "160",
        r: "40",
        fill: "none"
      })]
    })), _g3 || (_g3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "motors",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 320 60 L 250 60 L 250 230 L 260 290 L 310 290 L 320 230 L 320 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 1050 60 L 980 60 L 980 230 L 990 290 L 1040 290 L 1050 230 L 1050 60 Z "
      })]
    })), _g4 || (_g4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "propellers",
      fill: "black",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 270 60 L 300 60 L 300 20 Q 311 30 330 30 Q 349 30 570 10 L 300 10 Q 300 0 290 0 C 286 0 284 0 280 0 Q 270 0 270 10 L 0 10 Q 220 30 240 30 Q 260 30 270 20 L 270 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 1000 60 L 1030 60 L 1030 20 Q 1041 30 1060 30 Q 1079 30 1300 10 L 1030 10 Q 1030 0 1020 0 C 1016 0 1014 0 1010 0 Q 1000 0 1000 10 L 730 10 Q 950 30 970 30 Q 990 30 1000 20 L 1000 60 Z "
      })]
    }))]
  });
};

const droneFrontItem = {
  id: 'droneFront',
  name: 'Drone Front',
  description: 'Drone front',
  display: DroneFrontDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      rollAngle: cfg !== null && cfg !== void 0 && cfg.rollAngle ? ctx.getScalar(cfg.rollAngle).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Drone Front'];
    builder.addCustomEditor({
      category,
      id: 'rollAngle',
      path: 'config.rollAngle',
      name: 'Roll Angle',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  droneFront: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    transition: transform 0.4s;
  `
});

/***/ }),

/***/ "./public/app/features/canvas/elements/droneSide.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "droneSideItem": () => (/* binding */ droneSideItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _g, _g2, _g3, _g4;








const DroneSideDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const droneSidePitchTransformStyle = `rotate(${data !== null && data !== void 0 && data.pitchAngle ? data.pitchAngle : 0}deg)`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    className: styles.droneSide,
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 1300 290",
    style: {
      transform: droneSidePitchTransformStyle
    },
    children: [_g || (_g = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "arms",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "100",
        y2: "150"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "100",
        y2: "150"
      })]
    })), _g2 || (_g2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("g", {
      className: "body",
      stroke: "black",
      strokeWidth: "28px",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "none",
        d: " M 510 130 C 510 124 510 110 510 100 C 510 90 530 71 540 70 C 640 61 670 60 760 70 C 770 71 790 90 790 100 Q 790 120 790 130 L 790 130 Q 790 177 790 196 C 790 207 770 225 760 226 C 670 236 640 236 540 226 C 530 226 510 206 510 196 Q 510 177 510 130 Q 510 133 510 130 Z "
      })
    })), _g3 || (_g3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "motors",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 320 60 L 250 60 L 250 230 L 260 290 L 310 290 L 320 230 L 320 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 1050 60 L 980 60 L 980 230 L 990 290 L 1040 290 L 1050 230 L 1050 60 Z "
      })]
    })), _g4 || (_g4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "propellers",
      fill: "black",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 270 60 L 300 60 L 300 20 Q 311 30 330 30 Q 349 30 570 10 L 300 10 Q 300 0 290 0 C 286 0 284 0 280 0 Q 270 0 270 10 L 0 10 Q 220 30 240 30 Q 260 30 270 20 L 270 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 1000 60 L 1030 60 L 1030 20 Q 1041 30 1060 30 Q 1079 30 1300 10 L 1030 10 Q 1030 0 1020 0 C 1016 0 1014 0 1010 0 Q 1000 0 1000 10 L 730 10 Q 950 30 970 30 Q 990 30 1000 20 L 1000 60 Z "
      })]
    }))]
  });
};

const droneSideItem = {
  id: 'droneSide',
  name: 'Drone Side',
  description: 'Drone Side',
  display: DroneSideDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      pitchAngle: cfg !== null && cfg !== void 0 && cfg.pitchAngle ? ctx.getScalar(cfg.pitchAngle).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Drone Side'];
    builder.addCustomEditor({
      category,
      id: 'pitchAngle',
      path: 'config.pitchAngle',
      name: 'Pitch Angle',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  droneSide: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    transition: transform 0.4s;
  `
});

/***/ }),

/***/ "./public/app/features/canvas/elements/droneTop.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "droneTopItem": () => (/* binding */ droneTopItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _path, _path2;








const DroneTopDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const fRightRotorAnimation = `spin ${data !== null && data !== void 0 && data.fRightRotorRPM ? 60 / Math.abs(data.fRightRotorRPM) : 0}s linear infinite`;
  const fLeftRotorAnimation = `spin ${data !== null && data !== void 0 && data.fLeftRotorRPM ? 60 / Math.abs(data.fLeftRotorRPM) : 0}s linear infinite`;
  const bRightRotorAnimation = `spin ${data !== null && data !== void 0 && data.bRightRotorRPM ? 60 / Math.abs(data.bRightRotorRPM) : 0}s linear infinite`;
  const bLeftRotorAnimation = `spin ${data !== null && data !== void 0 && data.bLeftRotorRPM ? 60 / Math.abs(data.bLeftRotorRPM) : 0}s linear infinite`;
  const droneTopTransformStyle = `rotate(${data !== null && data !== void 0 && data.yawAngle ? data.yawAngle : 0}deg)`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "-43 -43 640 640",
    xmlSpace: "preserve",
    style: {
      transform: droneTopTransformStyle
    },
    children: [_path || (_path = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
      fillRule: "evenodd",
      d: " M 137.95 127.967 C 137.14 127.157 136.189 126.58 135.178 126.218 C 138.173 121.545 139.967 116.036 140.125 110.123 L 217.64 151.862 C 214.049 157.411 211.8 163.922 211.386 170.95 L 209.694 199.712 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 Z  M 134.268 426.981 C 130.211 421.314 124.328 417.045 117.482 415.041 L 201.999 330.523 L 201.385 340.955 C 200.67 353.107 202.829 364.914 207.563 375.673 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 Z  M 324.765 373.673 L 228.527 373.673 Q 215.374 358.611 216.361 341.835 L 226.361 171.832 C 226.825 163.94 231.012 157.096 237.146 152.957 L 316.146 152.957 C 322.28 157.096 326.466 163.94 326.931 171.832 L 336.931 341.835 Q 337.918 358.611 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 Z  M 435.81 415.041 C 428.964 417.045 423.081 421.314 419.024 426.981 L 345.727 375.673 C 350.461 364.914 352.62 353.107 351.905 340.955 L 351.291 330.523 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 Z  M 343.596 199.713 L 341.904 170.951 C 341.49 163.923 339.242 157.411 335.651 151.863 L 413.167 110.124 C 413.325 116.037 415.119 121.546 418.114 126.219 C 417.103 126.581 416.152 127.158 415.342 127.968 L 343.596 199.713 L 343.596 199.713 L 343.596 199.713 L 343.596 199.713 L 343.596 199.713 Z  M 444.646 92.771 C 453.744 92.771 461.146 100.172 461.146 109.271 C 461.146 118.369 453.744 125.771 444.646 125.771 C 435.548 125.771 428.146 118.369 428.146 109.271 C 428.146 100.172 435.548 92.771 444.646 92.771 L 444.646 92.771 L 444.646 92.771 L 444.646 92.771 Z  M 108.647 92.771 C 117.745 92.771 125.147 100.172 125.147 109.271 C 125.147 118.369 117.745 125.771 108.647 125.771 C 99.549 125.771 92.147 118.369 92.147 109.271 C 92.147 100.172 99.549 92.771 108.647 92.771 L 108.647 92.771 L 108.647 92.771 Z  M 108.647 461.771 C 99.549 461.771 92.147 454.369 92.147 445.271 C 92.147 436.172 99.549 428.771 108.647 428.771 C 117.745 428.771 125.147 436.172 125.147 445.271 C 125.147 454.369 117.745 461.771 108.647 461.771 L 108.647 461.771 Z  M 92.322 136.202 C 97.086 139.1 102.675 140.771 108.647 140.771 C 114.883 140.771 120.697 138.941 125.594 135.802 C 125.956 136.813 126.534 137.764 127.343 138.573 L 207.342 218.573 C 207.711 218.942 208.109 219.264 208.528 219.54 L 203.212 309.908 C 201.794 310.182 200.44 310.869 199.342 311.967 L 95.343 415.967 C 94.954 416.356 94.62 416.779 94.335 417.224 C 93.651 417.575 92.976 417.942 92.322 418.34 Q 84.615 424.182 81.716 428.946 C 78.817 433.71 77.147 439.299 77.147 445.271 C 77.147 462.64 91.278 476.771 108.647 476.771 C 114.619 476.771 120.208 475.1 124.972 472.202 C 129.736 469.304 132.678 466.36 135.577 461.596 C 138.476 456.832 140.147 451.243 140.147 445.271 C 140.147 443.943 140.055 442.637 139.895 441.352 L 214.997 388.78 C 217.05 391.677 336.242 391.678 338.295 388.78 L 413.398 441.352 C 413.238 442.637 413.146 443.943 413.146 445.271 C 413.146 451.243 414.817 456.832 417.715 461.596 C 420.613 466.36 423.557 469.304 428.321 472.202 C 433.085 475.1 438.674 476.771 444.646 476.771 C 462.015 476.771 476.146 462.64 476.146 445.271 C 476.146 439.299 474.475 433.71 471.577 428.946 C 468.679 424.182 459.642 417.575 458.958 417.224 C 458.672 416.779 458.339 416.356 457.95 415.967 L 353.95 311.967 C 352.852 310.869 351.498 310.182 350.08 309.908 L 344.764 219.54 C 345.183 219.264 345.581 218.942 345.95 218.573 L 425.95 138.573 C 426.76 137.763 427.337 136.812 427.699 135.802 C 432.596 138.941 438.409 140.771 444.646 140.771 C 450.618 140.771 456.207 139.1 460.971 136.202 C 465.735 133.304 468.679 130.36 471.577 125.596 C 474.475 120.832 476.146 115.243 476.146 109.271 C 476.146 91.903 462.015 77.772 444.646 77.772 C 438.674 77.772 433.085 79.442 428.321 82.34 L 416.215 91.446 L 324.765 140.688 C 318.402 136.324 310.718 133.771 302.473 133.771 L 250.819 133.771 C 242.574 133.771 234.89 136.324 228.527 140.688 L 137.078 91.446 L 124.972 82.34 C 120.208 79.442 114.619 77.772 108.647 77.772 C 91.278 77.772 77.147 91.903 77.147 109.271 C 77.147 115.243 78.818 120.832 81.716 125.595 C 84.614 130.358 87.558 133.304 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 Z  M 444.646 461.771 C 435.548 461.771 428.146 454.369 428.146 445.271 C 428.146 436.172 435.548 428.771 444.646 428.771 C 453.744 428.771 461.146 436.172 461.146 445.271 C 461.146 454.369 453.744 461.771 444.646 461.771 Z "
    })), _path2 || (_path2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
      fillRule: "evenodd",
      d: " M 259.458 334.235 L 259.458 337.211 L 254.514 337.211 L 254.514 350.795 L 250.842 350.795 L 250.842 337.211 L 245.898 337.211 L 245.898 334.235 L 259.458 334.235 Z  M 266.226 347.939 L 272.586 347.939 L 272.754 350.627 L 272.754 350.627 Q 270.498 350.867 265.074 350.867 L 265.074 350.867 L 265.074 350.867 Q 263.418 350.867 262.434 349.967 L 262.434 349.967 L 262.434 349.967 Q 261.45 349.067 261.426 347.531 L 261.426 347.531 L 261.426 337.499 L 261.426 337.499 Q 261.45 335.963 262.434 335.063 L 262.434 335.063 L 262.434 335.063 Q 263.418 334.163 265.074 334.163 L 265.074 334.163 L 265.074 334.163 Q 270.498 334.163 272.754 334.403 L 272.754 334.403 L 272.586 337.115 L 266.226 337.115 L 266.226 337.115 Q 265.626 337.115 265.362 337.403 L 265.362 337.403 L 265.362 337.403 Q 265.098 337.691 265.098 338.339 L 265.098 338.339 L 265.098 340.859 L 271.698 340.859 L 271.698 343.499 L 265.098 343.499 L 265.098 346.691 L 265.098 346.691 Q 265.098 347.363 265.362 347.651 L 265.362 347.651 L 265.362 347.651 Q 265.626 347.939 266.226 347.939 L 266.226 347.939 Z  M 275.202 333.995 L 278.73 333.995 L 278.73 346.931 L 278.73 346.931 Q 278.73 348.131 280.074 348.131 L 280.074 348.131 L 281.034 348.131 L 281.442 350.603 L 281.442 350.603 Q 280.53 351.083 278.61 351.083 L 278.61 351.083 L 278.61 351.083 Q 277.026 351.083 276.114 350.231 L 276.114 350.231 L 276.114 350.231 Q 275.202 349.379 275.202 347.819 L 275.202 347.819 L 275.202 333.995 Z  M 283.05 333.995 L 286.578 333.995 L 286.578 346.931 L 286.578 346.931 Q 286.578 348.131 287.922 348.131 L 287.922 348.131 L 288.882 348.131 L 289.29 350.603 L 289.29 350.603 Q 288.378 351.083 286.458 351.083 L 286.458 351.083 L 286.458 351.083 Q 284.874 351.083 283.962 350.231 L 283.962 350.231 L 283.962 350.231 Q 283.05 349.379 283.05 347.819 L 283.05 347.819 L 283.05 333.995 Z  M 292.086 335.759 L 292.086 335.759 L 292.086 335.759 Q 293.634 333.923 297.618 333.923 L 297.618 333.923 L 297.618 333.923 Q 301.602 333.923 303.162 335.759 L 303.162 335.759 L 303.162 335.759 Q 304.722 337.595 304.722 342.515 L 304.722 342.515 L 304.722 342.515 Q 304.722 347.435 303.162 349.271 L 303.162 349.271 L 303.162 349.271 Q 301.602 351.107 297.618 351.107 L 297.618 351.107 L 297.618 351.107 Q 293.634 351.107 292.086 349.271 L 292.086 349.271 L 292.086 349.271 Q 290.538 347.435 290.538 342.515 L 290.538 342.515 L 290.538 342.515 Q 290.538 337.595 292.086 335.759 Z  M 300.174 338.051 L 300.174 338.051 L 300.174 338.051 Q 299.49 336.875 297.618 336.875 L 297.618 336.875 L 297.618 336.875 Q 295.746 336.875 295.062 338.051 L 295.062 338.051 L 295.062 338.051 Q 294.378 339.227 294.378 342.515 L 294.378 342.515 L 294.378 342.515 Q 294.378 345.803 295.062 346.979 L 295.062 346.979 L 295.062 346.979 Q 295.746 348.155 297.618 348.155 L 297.618 348.155 L 297.618 348.155 Q 299.49 348.155 300.174 346.979 L 300.174 346.979 L 300.174 346.979 Q 300.858 345.803 300.858 342.515 L 300.858 342.515 L 300.858 342.515 Q 300.858 339.227 300.174 338.051 Z "
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "propeller-group",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCW}`,
        style: {
          animation: bRightRotorAnimation
        },
        d: " M 461.563 418.77 L 463.992 416.34 Q 465.495 407.116 466.461 400.395 C 467.426 393.675 469.363 388.087 474.731 383.284 Q 533.862 341.514 538.196 338.859 C 542.529 336.203 548.345 334.299 551.492 338.29 C 554.639 342.282 553.481 346.02 549.419 350.082 L 471.147 428.354 L 461.563 418.77 Z  M 427.729 471.772 L 425.299 474.202 Q 423.797 483.426 422.831 490.146 C 421.866 496.867 419.929 502.454 414.561 507.257 Q 355.43 549.028 351.096 551.683 C 346.763 554.338 340.947 556.243 337.8 552.251 C 334.653 548.26 335.811 544.522 339.873 540.46 L 418.145 462.187 L 427.729 471.772 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCCW}`,
        style: {
          animation: fRightRotorAnimation
        },
        d: " M 461.563 135.773 L 463.992 138.203 Q 465.495 147.426 466.461 154.147 C 467.426 160.868 469.363 166.455 474.731 171.258 Q 533.862 213.028 538.196 215.684 C 542.529 218.339 548.345 220.244 551.492 216.252 C 554.639 212.26 553.481 208.523 549.419 204.46 L 471.147 126.188 L 461.563 135.773 Z  M 427.729 82.77 L 425.299 80.34 Q 423.797 71.117 422.831 64.396 C 421.866 57.675 419.929 52.088 414.561 47.285 Q 355.43 5.515 351.096 2.859 C 346.763 0.204 340.947 -1.701 337.8 2.291 C 334.653 6.282 335.811 10.02 339.873 14.082 L 418.145 92.355 L 427.729 82.77 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCCW}`,
        style: {
          animation: bLeftRotorAnimation
        },
        d: " M 125.563 471.772 L 127.993 474.202 Q 129.496 483.426 130.461 490.146 C 131.427 496.867 133.363 502.454 138.731 507.257 Q 197.863 549.028 202.196 551.683 C 206.53 554.338 212.345 556.243 215.492 552.251 C 218.639 548.26 217.482 544.522 213.419 540.46 L 135.148 462.187 L 125.563 471.772 Z  M 91.73 418.77 L 89.3 416.34 Q 87.797 407.116 86.832 400.395 C 85.866 393.675 83.93 388.087 78.562 383.284 Q 19.431 341.514 15.097 338.859 C 10.763 336.203 4.948 334.299 1.801 338.29 C -1.346 342.282 -0.189 346.02 3.874 350.082 L 82.146 428.354 L 91.73 418.77 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCW}`,
        style: {
          animation: fLeftRotorAnimation
        },
        d: " M 125.563 82.77 L 127.993 80.34 Q 129.496 71.117 130.461 64.396 C 131.427 57.675 133.363 52.088 138.731 47.285 Q 197.863 5.515 202.196 2.859 C 206.53 0.204 212.345 -1.701 215.492 2.291 C 218.639 6.282 217.482 10.02 213.419 14.083 L 135.147 92.355 L 125.563 82.77 Z  M 91.73 135.773 L 89.3 138.203 Q 87.797 147.426 86.832 154.147 C 85.866 160.868 83.93 166.455 78.562 171.258 Q 19.431 213.028 15.097 215.684 C 10.763 218.339 4.948 220.243 1.801 216.252 C -1.346 212.26 -0.189 208.523 3.874 204.46 L 82.146 126.188 L 91.73 135.773 Z "
      })]
    })]
  });
};

const droneTopItem = {
  id: 'droneTop',
  name: 'Drone Top',
  description: 'Drone top',
  display: DroneTopDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      bRightRotorRPM: cfg !== null && cfg !== void 0 && cfg.bRightRotorRPM ? ctx.getScalar(cfg.bRightRotorRPM).value() : 0,
      bLeftRotorRPM: cfg !== null && cfg !== void 0 && cfg.bLeftRotorRPM ? ctx.getScalar(cfg.bLeftRotorRPM).value() : 0,
      fRightRotorRPM: cfg !== null && cfg !== void 0 && cfg.fRightRotorRPM ? ctx.getScalar(cfg.fRightRotorRPM).value() : 0,
      fLeftRotorRPM: cfg !== null && cfg !== void 0 && cfg.fLeftRotorRPM ? ctx.getScalar(cfg.fLeftRotorRPM).value() : 0,
      yawAngle: cfg !== null && cfg !== void 0 && cfg.yawAngle ? ctx.getScalar(cfg.yawAngle).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Drone Top'];
    builder.addCustomEditor({
      category,
      id: 'yawAngle',
      path: 'config.yawAngle',
      name: 'Yaw Angle',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'fRightRotorRPM',
      path: 'config.fRightRotorRPM',
      name: 'Front Right Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'fLeftRotorRPM',
      path: 'config.fLeftRotorRPM',
      name: 'Front Left Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'bRightRotorRPM',
      path: 'config.bRightRotorRPM',
      name: 'Back Right Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'bLeftRotorRPM',
      path: 'config.bLeftRotorRPM',
      name: 'Back Left Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  propeller: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    transform-origin: 50% 50%;
    transform-box: fill-box;
    display: block;
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
  `,
  propellerCW: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    animation-direction: normal;
  `,
  propellerCCW: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    animation-direction: reverse;
  `
});

/***/ }),

/***/ "./public/app/features/canvas/elements/icon.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IconDisplay": () => (/* binding */ IconDisplay),
/* harmony export */   "iconItem": () => (/* binding */ iconItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_inlinesvg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/__virtual__/react-inlinesvg-virtual-941c793559/0/cache/react-inlinesvg-npm-3.0.0-57872fc8cc-ceb34c4c54.zip/node_modules/react-inlinesvg/esm/index.js");
/* harmony import */ var app_features_dimensions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/APIEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








// When a stoke is defined, we want the path to be in page units
const svgStrokePathClass = _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
  path {
    vector-effect: non-scaling-stroke;
  }
`;
function IconDisplay(props) {
  const {
    data
  } = props;

  if (!(data !== null && data !== void 0 && data.path)) {
    return null;
  }

  const onClick = () => {
    if (data !== null && data !== void 0 && data.api) {
      (0,app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_5__.callApi)(data.api);
    }
  };

  const svgStyle = {
    fill: data === null || data === void 0 ? void 0 : data.fill,
    stroke: data === null || data === void 0 ? void 0 : data.strokeColor,
    strokeWidth: data === null || data === void 0 ? void 0 : data.stroke
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(react_inlinesvg__WEBPACK_IMPORTED_MODULE_7__["default"], {
    onClick: onClick,
    src: data.path,
    style: svgStyle,
    className: svgStyle.strokeWidth ? svgStrokePathClass : undefined
  });
}
const iconItem = {
  id: 'icon',
  name: 'Icon',
  description: 'SVG Icon display',
  display: IconDisplay,
  getNewOptions: options => Object.assign({
    placement: {
      width: 50,
      height: 50,
      top: 0,
      left: 0
    }
  }, options, {
    config: {
      path: {
        mode: app_features_dimensions__WEBPACK_IMPORTED_MODULE_3__.ResourceDimensionMode.Fixed,
        fixed: 'img/icons/unicons/question-circle.svg'
      },
      fill: {
        fixed: '#FFF899'
      }
    }
  }),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    var _cfg$api, _cfg$stroke;

    let path = undefined;

    if (cfg.path) {
      path = ctx.getResource(cfg.path).value();
    }

    if (!path || !(0,lodash__WEBPACK_IMPORTED_MODULE_1__.isString)(path)) {
      path = (0,app_features_dimensions__WEBPACK_IMPORTED_MODULE_3__.getPublicOrAbsoluteUrl)('img/icons/unicons/question-circle.svg');
    }

    const data = {
      path,
      fill: cfg.fill ? ctx.getColor(cfg.fill).value() : '#CCC',
      api: (_cfg$api = cfg === null || cfg === void 0 ? void 0 : cfg.api) !== null && _cfg$api !== void 0 ? _cfg$api : undefined
    };

    if ((_cfg$stroke = cfg.stroke) !== null && _cfg$stroke !== void 0 && _cfg$stroke.width && cfg.stroke.color) {
      if (cfg.stroke.width > 0) {
        var _cfg$stroke2;

        data.stroke = (_cfg$stroke2 = cfg.stroke) === null || _cfg$stroke2 === void 0 ? void 0 : _cfg$stroke2.width;
        data.strokeColor = ctx.getColor(cfg.stroke.color).value();
      }
    }

    return data;
  },
  // Heatmap overlay options
  registerOptionsUI: builder => {
    const category = ['Icon'];
    builder.addCustomEditor({
      category,
      id: 'iconSelector',
      path: 'config.path',
      name: 'SVG Path',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ResourceDimensionEditor,
      settings: {
        resourceType: 'icon'
      }
    }).addCustomEditor({
      category,
      id: 'config.fill',
      path: 'config.fill',
      name: 'Fill color',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ColorDimensionEditor,
      settings: {},
      defaultValue: {
        // Configured values
        fixed: 'grey'
      }
    }).addSliderInput({
      category,
      path: 'config.stroke.width',
      name: 'Stroke',
      defaultValue: 0,
      settings: {
        min: 0,
        max: 10
      }
    }).addCustomEditor({
      category,
      id: 'config.stroke.color',
      path: 'config.stroke.color',
      name: 'Stroke color',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ColorDimensionEditor,
      settings: {},
      defaultValue: {
        // Configured values
        fixed: 'grey'
      },
      showIf: cfg => {
        var _cfg$config, _cfg$config$stroke;

        return Boolean(cfg === null || cfg === void 0 ? void 0 : (_cfg$config = cfg.config) === null || _cfg$config === void 0 ? void 0 : (_cfg$config$stroke = _cfg$config.stroke) === null || _cfg$config$stroke === void 0 ? void 0 : _cfg$config$stroke.width);
      }
    }).addCustomEditor({
      category,
      id: 'apiSelector',
      path: 'config.api',
      name: 'API',
      editor: app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_5__.APIEditor
    });
  }
};

/***/ }),

/***/ "./public/app/features/canvas/elements/notFound.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "notFoundItem": () => (/* binding */ notFoundItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;





class NotFoundDisplay extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  render() {
    const {
      config
    } = this.props;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
      children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("h3", {
        children: "NOT FOUND:"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("pre", {
        children: JSON.stringify(config, null, 2)
      })]
    });
  }

}

const notFoundItem = {
  id: 'not-found',
  name: 'Not found',
  description: 'Display when element type is not found in the registry',
  display: NotFoundDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: () => ({
    config: {}
  })
};

/***/ }),

/***/ "./public/app/features/canvas/elements/textBox.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Align": () => (/* binding */ Align),
/* harmony export */   "VAlign": () => (/* binding */ VAlign),
/* harmony export */   "textBoxItem": () => (/* binding */ textBoxItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/core/config.ts");
/* harmony import */ var app_features_dimensions_editors_ColorDimensionEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/dimensions/editors/ColorDimensionEditor.tsx");
/* harmony import */ var app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/dimensions/editors/TextDimensionEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







let Align;

(function (Align) {
  Align["Left"] = "left";
  Align["Center"] = "center";
  Align["Right"] = "right";
})(Align || (Align = {}));

let VAlign;

(function (VAlign) {
  VAlign["Top"] = "top";
  VAlign["Middle"] = "middle";
  VAlign["Bottom"] = "bottom";
})(VAlign || (VAlign = {}));

class TextBoxDisplay extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {
  render() {
    const {
      data
    } = this.props;
    const styles = getStyles(app_core_config__WEBPACK_IMPORTED_MODULE_3__.config.theme2, data);
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: styles.container,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("span", {
        className: styles.span,
        children: data === null || data === void 0 ? void 0 : data.text
      })
    });
  }

}

const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.stylesFactory)((theme, data) => ({
  container: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    position: absolute;
    height: 100%;
    width: 100%;
    display: table;
  `,
  span: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: table-cell;
    vertical-align: ${data.valign};
    text-align: ${data.align};
    font-size: ${data === null || data === void 0 ? void 0 : data.size}px;
    color: ${data === null || data === void 0 ? void 0 : data.color};
  `
}));
const textBoxItem = {
  id: 'text-box',
  name: 'Text',
  description: 'Text box',
  display: TextBoxDisplay,
  defaultSize: {
    width: 240,
    height: 160
  },
  getNewOptions: options => Object.assign({
    background: {
      color: {
        fixed: 'grey'
      }
    }
  }, options, {
    config: {
      align: Align.Left,
      valign: VAlign.Middle
    }
  }),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    var _cfg$align, _cfg$valign;

    const data = {
      text: cfg.text ? ctx.getText(cfg.text).value() : '',
      align: (_cfg$align = cfg.align) !== null && _cfg$align !== void 0 ? _cfg$align : Align.Center,
      valign: (_cfg$valign = cfg.valign) !== null && _cfg$valign !== void 0 ? _cfg$valign : VAlign.Middle,
      size: cfg.size
    };

    if (cfg.color) {
      data.color = ctx.getColor(cfg.color).value();
    }

    return data;
  },
  // Heatmap overlay options
  registerOptionsUI: builder => {
    const category = ['Text box'];
    builder.addCustomEditor({
      category,
      id: 'textSelector',
      path: 'config.text',
      name: 'Text',
      editor: app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_5__.TextDimensionEditor
    }).addCustomEditor({
      category,
      id: 'config.color',
      path: 'config.color',
      name: 'Text color',
      editor: app_features_dimensions_editors_ColorDimensionEditor__WEBPACK_IMPORTED_MODULE_4__.ColorDimensionEditor,
      settings: {},
      defaultValue: {}
    }).addRadio({
      category,
      path: 'config.align',
      name: 'Align text',
      settings: {
        options: [{
          value: Align.Left,
          label: 'Left'
        }, {
          value: Align.Center,
          label: 'Center'
        }, {
          value: Align.Right,
          label: 'Right'
        }]
      },
      defaultValue: Align.Left
    }).addRadio({
      category,
      path: 'config.valign',
      name: 'Vertical align',
      settings: {
        options: [{
          value: VAlign.Top,
          label: 'Top'
        }, {
          value: VAlign.Middle,
          label: 'Middle'
        }, {
          value: VAlign.Bottom,
          label: 'Bottom'
        }]
      },
      defaultValue: VAlign.Middle
    }).addNumberInput({
      category,
      path: 'config.size',
      name: 'Text size',
      settings: {
        placeholder: 'Auto'
      }
    });
  }
};

/***/ }),

/***/ "./public/app/features/canvas/elements/windTurbine.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "windTurbineItem": () => (/* binding */ windTurbineItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _symbol, _g, _use, _use2, _use3;








const WindTurbineDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const windTurbineAnimation = `spin ${data !== null && data !== void 0 && data.rpm ? 60 / Math.abs(data.rpm) : 0}s linear infinite`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    viewBox: "0 0 189.326 283.989",
    preserveAspectRatio: "xMidYMid meet",
    children: [_symbol || (_symbol = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("symbol", {
      id: "blade",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "#e6e6e6",
        id: "blade-front",
        d: "M14.6491879,1.85011601 C14.2684455,-0.0535962877 10.7150812,-0.815081206 9.06473318,3.37308585 L0.434338747,70.7658933 L8.93805104,91.9607889 L15.4106729,90.437819 L17.5684455,78.3807425 L14.5218097,1.97679814 L14.6491879,1.85011601 Z"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "#d0d6d7",
        id: "blade-side",
        d: "M11.0951276,0.581206497 C10.3336427,0.961948956 9.57215777,1.85011601 8.93735499,3.24640371 L0.306960557,70.6392111 L8.81067285,91.8341067 L3.35359629,70.0044084 L11.0951276,0.581206497 Z"
      })]
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      children: [_g || (_g = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
        id: "structure",
        transform: "translate(58.123, 82.664)",
        fillRule: "nonzero",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("polygon", {
          id: "tower",
          fill: "#e6e6e6",
          points: "33.111,10.984 39.965,10.984 44.28,196.176 28.796,196.176"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
          id: "yaw",
          fill: "rgba(0,0,0,0.25)",
          d: "M40.3454756,23.2948956 L40.7262181,34.8445476 C38.8225058,35.0986079 35.7765661,35.0986079 32.349884,34.337123 L32.7306265,23.2955916 L40.3454756,23.2955916 L40.3454756,23.2948956 Z"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
          id: "base",
          fill: "#d0d6d7",
          transform: "translate(0 42)",
          d: "M26.3846868,150.591647 L46.5640371,150.591647 C48.8484919,150.591647 50.7522042,152.49536 50.7522042,154.779814 L50.7522042,158.967981 L22.0691415,158.967981 L22.0691415,154.779814 C22.0691415,152.49536 23.9728538,150.591647 26.2573086,150.591647 L26.3846868,150.591647 Z"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("circle", {
          id: "nacelle",
          fill: "#e6e6e6",
          cx: "36.54",
          cy: "12",
          r: "11.93"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("circle", {
          id: "gearbox",
          fill: "none",
          stroke: "#d0d6d7",
          strokeWidth: "2.75",
          cx: "36.538",
          cy: "11.999",
          r: "5.8"
        })]
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
        className: styles.blade,
        style: {
          animation: windTurbineAnimation
        },
        children: [_use || (_use = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("use", {
          id: "blade1",
          href: "#blade",
          x: "83.24",
          y: "0"
        })), _use2 || (_use2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("use", {
          id: "blade2",
          href: "#blade",
          x: "83.24",
          y: "0",
          transform: "rotate(120 94.663 94.663)"
        })), _use3 || (_use3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("use", {
          id: "blade3",
          href: "#blade",
          x: "83.24",
          y: "0",
          transform: "rotate(-120 94.663 94.663)"
        }))]
      })]
    })]
  });
};

const windTurbineItem = {
  id: 'windTurbine',
  name: 'Wind Turbine',
  description: 'Spinny spinny',
  display: WindTurbineDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      rpm: cfg !== null && cfg !== void 0 && cfg.rpm ? ctx.getScalar(cfg.rpm).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Wind Turbine'];
    builder.addCustomEditor({
      category,
      id: 'rpm',
      path: 'config.rpm',
      name: 'RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  blade: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }

    transform-origin: 94.663px 94.663px;
    transform: rotate(15deg);
  `
});

/***/ }),

/***/ "./public/app/features/canvas/frame.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);


/***/ }),

/***/ "./public/app/features/canvas/index.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundImageSize": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize),
/* harmony export */   "CanvasFrameOptions": () => (/* reexport safe */ _frame__WEBPACK_IMPORTED_MODULE_2__.CanvasFrameOptions),
/* harmony export */   "DEFAULT_CANVAS_ELEMENT_CONFIG": () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_CANVAS_ELEMENT_CONFIG),
/* harmony export */   "HorizontalConstraint": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.HorizontalConstraint),
/* harmony export */   "QuickPlacement": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.QuickPlacement),
/* harmony export */   "VerticalConstraint": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.VerticalConstraint),
/* harmony export */   "canvasElementRegistry": () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_3__.canvasElementRegistry)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/canvas/types.ts");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/element.ts");
/* harmony import */ var _frame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/frame.ts");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/registry.ts");





/***/ }),

/***/ "./public/app/features/canvas/registry.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_CANVAS_ELEMENT_CONFIG": () => (/* binding */ DEFAULT_CANVAS_ELEMENT_CONFIG),
/* harmony export */   "canvasElementRegistry": () => (/* binding */ canvasElementRegistry)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _elements_button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/elements/button.tsx");
/* harmony import */ var _elements_droneFront__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/elements/droneFront.tsx");
/* harmony import */ var _elements_droneSide__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/elements/droneSide.tsx");
/* harmony import */ var _elements_droneTop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/canvas/elements/droneTop.tsx");
/* harmony import */ var _elements_icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/canvas/elements/icon.tsx");
/* harmony import */ var _elements_textBox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/canvas/elements/textBox.tsx");
/* harmony import */ var _elements_windTurbine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/canvas/elements/windTurbine.tsx");








const DEFAULT_CANVAS_ELEMENT_CONFIG = Object.assign({}, _elements_icon__WEBPACK_IMPORTED_MODULE_5__.iconItem.getNewOptions(), {
  type: _elements_icon__WEBPACK_IMPORTED_MODULE_5__.iconItem.id,
  name: `Element 1`
});
const canvasElementRegistry = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.Registry(() => [_elements_icon__WEBPACK_IMPORTED_MODULE_5__.iconItem, // default for now
_elements_textBox__WEBPACK_IMPORTED_MODULE_6__.textBoxItem, _elements_button__WEBPACK_IMPORTED_MODULE_1__.buttonItem, _elements_droneTop__WEBPACK_IMPORTED_MODULE_4__.droneTopItem, _elements_droneFront__WEBPACK_IMPORTED_MODULE_2__.droneFrontItem, _elements_droneSide__WEBPACK_IMPORTED_MODULE_3__.droneSideItem, _elements_windTurbine__WEBPACK_IMPORTED_MODULE_7__.windTurbineItem]);

/***/ }),

/***/ "./public/app/features/canvas/runtime/ables.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "constraintViewable": () => (/* binding */ constraintViewable),
/* harmony export */   "dimensionViewable": () => (/* binding */ dimensionViewable)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/canvas/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");


const dimensionViewable = {
  name: 'dimensionViewable',
  props: {},
  events: {},

  render(moveable, React) {
    const rect = moveable.getRect();
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
      className: 'moveable-dimension',
      style: {
        position: 'absolute',
        left: `${rect.width / 2}px`,
        top: `${rect.height + 20}px`,
        background: '#4af',
        borderRadius: '2px',
        padding: '2px 4px',
        color: 'white',
        fontSize: '13px',
        whiteSpace: 'nowrap',
        fontWeight: 'bold',
        willChange: 'transform',
        transform: 'translate(-50%, 0px)',
        zIndex: 100
      },
      children: [Math.round(rect.offsetWidth), " x ", Math.round(rect.offsetHeight)]
    }, 'dimension-viewable');
  }

};
const constraintViewable = scene => ({
  name: 'constraintViewable',
  props: {},
  events: {},

  render(moveable, React) {
    var _scene$selecto, _scene$selecto2, _ref, _targetElement$tempCo;

    const rect = moveable.getRect();
    const targetElement = scene.findElementByTarget(moveable.state.target); // If target is currently in motion or selection is more than 1 element don't display constraint visualizations

    if (targetElement !== null && targetElement !== void 0 && targetElement.isMoving || (_scene$selecto = scene.selecto) !== null && _scene$selecto !== void 0 && _scene$selecto.getSelectedTargets() && ((_scene$selecto2 = scene.selecto) === null || _scene$selecto2 === void 0 ? void 0 : _scene$selecto2.getSelectedTargets().length) > 1) {
      return;
    }

    let verticalConstraintVisualization = null;
    let horizontalConstraintVisualization = null;
    const constraint = (_ref = (_targetElement$tempCo = targetElement === null || targetElement === void 0 ? void 0 : targetElement.tempConstraint) !== null && _targetElement$tempCo !== void 0 ? _targetElement$tempCo : targetElement === null || targetElement === void 0 ? void 0 : targetElement.options.constraint) !== null && _ref !== void 0 ? _ref : {};
    const borderStyle = '1px dashed #4af';
    const centerIndicatorLineOne = React.createElement('div', {
      style: {
        position: 'absolute',
        left: `${rect.width / 2}px`,
        top: `${rect.height / 2 - rect.height / 16}px`,
        borderLeft: borderStyle,
        height: `${rect.height / 8}px`,
        transform: 'rotate(45deg)'
      }
    });
    const centerIndicatorLineTwo = React.createElement('div', {
      style: {
        position: 'absolute',
        left: `${rect.width / 2}px`,
        top: `${rect.height / 2 - rect.height / 16}px`,
        borderLeft: borderStyle,
        height: `${rect.height / 8}px`,
        transform: 'rotate(-45deg)'
      }
    });
    const centerIndicator = React.createElement('div', {}, [centerIndicatorLineOne, centerIndicatorLineTwo]);
    const verticalConstraintTop = React.createElement('div', {
      style: {
        position: 'absolute',
        left: `${rect.width / 2}px`,
        bottom: '0px',
        borderLeft: borderStyle,
        height: '100vh'
      }
    });
    const verticalConstraintBottom = React.createElement('div', {
      style: {
        position: 'absolute',
        left: `${rect.width / 2}px`,
        top: `${rect.height}px`,
        borderLeft: borderStyle,
        height: '100vh'
      }
    });
    const verticalConstraintTopBottom = React.createElement('div', {}, [verticalConstraintTop, verticalConstraintBottom]);
    const verticalConstraintCenterLine = React.createElement('div', {
      style: {
        position: 'absolute',
        left: `${rect.width / 2}px`,
        top: `${rect.height / 4}px`,
        borderLeft: borderStyle,
        height: `${rect.height / 2}px`
      }
    });
    const verticalConstraintCenter = React.createElement('div', {}, [verticalConstraintCenterLine, centerIndicator]);

    switch (constraint.vertical) {
      case _types__WEBPACK_IMPORTED_MODULE_0__.VerticalConstraint.Top:
        verticalConstraintVisualization = verticalConstraintTop;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_0__.VerticalConstraint.Bottom:
        verticalConstraintVisualization = verticalConstraintBottom;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_0__.VerticalConstraint.TopBottom:
        verticalConstraintVisualization = verticalConstraintTopBottom;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_0__.VerticalConstraint.Center:
        verticalConstraintVisualization = verticalConstraintCenter;
        break;
    }

    const horizontalConstraintLeft = React.createElement('div', {
      style: {
        position: 'absolute',
        right: '0px',
        top: `${rect.height / 2}px`,
        borderTop: borderStyle,
        width: '100vw'
      }
    });
    const horizontalConstraintRight = React.createElement('div', {
      style: {
        position: 'absolute',
        left: `${rect.width}px`,
        top: `${rect.height / 2}px`,
        borderTop: borderStyle,
        width: '100vw'
      }
    });
    const horizontalConstraintLeftRight = React.createElement('div', {}, [horizontalConstraintLeft, horizontalConstraintRight]);
    const horizontalConstraintCenterLine = React.createElement('div', {
      style: {
        position: 'absolute',
        left: `${rect.width / 4}px`,
        top: `${rect.height / 2}px`,
        borderTop: borderStyle,
        width: `${rect.width / 2}px`
      }
    });
    const horizontalConstraintCenter = React.createElement('div', {}, [horizontalConstraintCenterLine, centerIndicator]);

    switch (constraint.horizontal) {
      case _types__WEBPACK_IMPORTED_MODULE_0__.HorizontalConstraint.Left:
        horizontalConstraintVisualization = horizontalConstraintLeft;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_0__.HorizontalConstraint.Right:
        horizontalConstraintVisualization = horizontalConstraintRight;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_0__.HorizontalConstraint.LeftRight:
        horizontalConstraintVisualization = horizontalConstraintLeftRight;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_0__.HorizontalConstraint.Center:
        horizontalConstraintVisualization = horizontalConstraintCenter;
        break;
    }

    const constraintVisualization = React.createElement('div', {}, [verticalConstraintVisualization, horizontalConstraintVisualization]);
    return constraintVisualization;
  }

});

/***/ }),

/***/ "./public/app/features/canvas/runtime/element.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ElementState": () => (/* binding */ ElementState)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/elements/notFound.tsx");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






let counter = 0;
class ElementState {
  // UID necessary for moveable to work (for now)
  // Determine whether or not element is in motion or not (via moveable)
  // Temp stored constraint for visualization purposes (switch to top / left constraint to simplify some functionality)
  // Filled in by ref
  // Calculated
  // depends on the type
  constructor(item, options, parent) {
    var _options$constraint, _options$placement;

    _defineProperty(this, "UID", counter++);

    _defineProperty(this, "revId", 0);

    _defineProperty(this, "sizeStyle", {});

    _defineProperty(this, "dataStyle", {});

    _defineProperty(this, "isMoving", false);

    _defineProperty(this, "tempConstraint", void 0);

    _defineProperty(this, "div", void 0);

    _defineProperty(this, "data", void 0);

    _defineProperty(this, "initElement", target => {
      this.div = target;
      this.applyLayoutStylesToDiv();
    });

    _defineProperty(this, "applyDrag", event => {
      var _this$options$constra, _this$options$constra2;

      const hasHorizontalCenterConstraint = ((_this$options$constra = this.options.constraint) === null || _this$options$constra === void 0 ? void 0 : _this$options$constra.horizontal) === _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Center;
      const hasVerticalCenterConstraint = ((_this$options$constra2 = this.options.constraint) === null || _this$options$constra2 === void 0 ? void 0 : _this$options$constra2.vertical) === _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Center;

      if (hasHorizontalCenterConstraint || hasVerticalCenterConstraint) {
        var _this$getScene$select, _this$getScene, _this$getScene$select2;

        const numberOfTargets = (_this$getScene$select = (_this$getScene = this.getScene()) === null || _this$getScene === void 0 ? void 0 : (_this$getScene$select2 = _this$getScene.selecto) === null || _this$getScene$select2 === void 0 ? void 0 : _this$getScene$select2.getSelectedTargets().length) !== null && _this$getScene$select !== void 0 ? _this$getScene$select : 0;
        const isMultiSelection = numberOfTargets > 1;

        if (!isMultiSelection) {
          var _this$div, _elementContainer$hei;

          const elementContainer = (_this$div = this.div) === null || _this$div === void 0 ? void 0 : _this$div.getBoundingClientRect();
          const height = (_elementContainer$hei = elementContainer === null || elementContainer === void 0 ? void 0 : elementContainer.height) !== null && _elementContainer$hei !== void 0 ? _elementContainer$hei : 100;
          const yOffset = hasVerticalCenterConstraint ? height / 4 : 0;
          event.target.style.transform = `translate(${event.translate[0]}px, ${event.translate[1] - yOffset}px)`;
          return;
        }
      }

      event.target.style.transform = event.transform;
    });

    _defineProperty(this, "applyResize", event => {
      const placement = this.options.placement;
      const style = event.target.style;
      const deltaX = event.delta[0];
      const deltaY = event.delta[1];
      const dirLR = event.direction[0];
      const dirTB = event.direction[1];

      if (dirLR === 1) {
        placement.width = event.width;
        style.width = `${placement.width}px`;
      } else if (dirLR === -1) {
        placement.left -= deltaX;
        placement.width = event.width;
        style.left = `${placement.left}px`;
        style.width = `${placement.width}px`;
      }

      if (dirTB === -1) {
        placement.top -= deltaY;
        placement.height = event.height;
        style.top = `${placement.top}px`;
        style.height = `${placement.height}px`;
      } else if (dirTB === 1) {
        placement.height = event.height;
        style.height = `${placement.height}px`;
      }
    });

    this.item = item;
    this.options = options;
    this.parent = parent;
    const fallbackName = `Element ${Date.now()}`;

    if (!options) {
      this.options = {
        type: item.id,
        name: fallbackName
      };
    }

    options.constraint = (_options$constraint = options.constraint) !== null && _options$constraint !== void 0 ? _options$constraint : {
      vertical: _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Top,
      horizontal: _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Left
    };
    options.placement = (_options$placement = options.placement) !== null && _options$placement !== void 0 ? _options$placement : {
      width: 100,
      height: 100,
      top: 0,
      left: 0
    };
    const scene = this.getScene();

    if (!options.name) {
      const newName = scene === null || scene === void 0 ? void 0 : scene.getNextElementName();
      options.name = newName !== null && newName !== void 0 ? newName : fallbackName;
    }

    scene === null || scene === void 0 ? void 0 : scene.byName.set(options.name, this);
  }

  getScene() {
    let trav = this.parent;

    while (trav) {
      if (trav.isRoot()) {
        return trav.scene;
      }

      trav = trav.parent;
    }

    return undefined;
  }

  getName() {
    return this.options.name;
  }
  /** Use the configured options to update CSS style properties directly on the wrapper div **/


  applyLayoutStylesToDiv() {
    var _this$options$placeme, _placement$top, _placement$height, _placement$bottom, _placement$height2, _placement$top2, _placement$bottom2, _placement$top3, _placement$height3, _placement$top4, _placement$bottom3, _placement$left, _placement$width, _placement$right, _placement$width2, _placement$left2, _placement$right2, _placement$left3, _placement$width3, _placement$left4, _placement$right3;

    if (this.isRoot()) {
      // Root supersedes layout engine and is always 100% width + height of panel
      return;
    }

    const {
      constraint
    } = this.options;
    const {
      vertical,
      horizontal
    } = constraint !== null && constraint !== void 0 ? constraint : {};
    const placement = (_this$options$placeme = this.options.placement) !== null && _this$options$placeme !== void 0 ? _this$options$placeme : {};
    const style = {
      position: 'absolute',
      // Minimum element size is 10x10
      minWidth: '10px',
      minHeight: '10px'
    };
    const translate = ['0px', '0px'];

    switch (vertical) {
      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Top:
        placement.top = (_placement$top = placement.top) !== null && _placement$top !== void 0 ? _placement$top : 0;
        placement.height = (_placement$height = placement.height) !== null && _placement$height !== void 0 ? _placement$height : 100;
        style.top = `${placement.top}px`;
        style.height = `${placement.height}px`;
        delete placement.bottom;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Bottom:
        placement.bottom = (_placement$bottom = placement.bottom) !== null && _placement$bottom !== void 0 ? _placement$bottom : 0;
        placement.height = (_placement$height2 = placement.height) !== null && _placement$height2 !== void 0 ? _placement$height2 : 100;
        style.bottom = `${placement.bottom}px`;
        style.height = `${placement.height}px`;
        delete placement.top;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.TopBottom:
        placement.top = (_placement$top2 = placement.top) !== null && _placement$top2 !== void 0 ? _placement$top2 : 0;
        placement.bottom = (_placement$bottom2 = placement.bottom) !== null && _placement$bottom2 !== void 0 ? _placement$bottom2 : 0;
        style.top = `${placement.top}px`;
        style.bottom = `${placement.bottom}px`;
        delete placement.height;
        style.height = '';
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Center:
        placement.top = (_placement$top3 = placement.top) !== null && _placement$top3 !== void 0 ? _placement$top3 : 0;
        placement.height = (_placement$height3 = placement.height) !== null && _placement$height3 !== void 0 ? _placement$height3 : 100;
        translate[1] = '-50%';
        style.top = `calc(50% - ${placement.top}px)`;
        style.height = `${placement.height}px`;
        delete placement.bottom;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Scale:
        placement.top = (_placement$top4 = placement.top) !== null && _placement$top4 !== void 0 ? _placement$top4 : 0;
        placement.bottom = (_placement$bottom3 = placement.bottom) !== null && _placement$bottom3 !== void 0 ? _placement$bottom3 : 0;
        style.top = `${placement.top}%`;
        style.bottom = `${placement.bottom}%`;
        delete placement.height;
        style.height = '';
        break;
    }

    switch (horizontal) {
      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Left:
        placement.left = (_placement$left = placement.left) !== null && _placement$left !== void 0 ? _placement$left : 0;
        placement.width = (_placement$width = placement.width) !== null && _placement$width !== void 0 ? _placement$width : 100;
        style.left = `${placement.left}px`;
        style.width = `${placement.width}px`;
        delete placement.right;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Right:
        placement.right = (_placement$right = placement.right) !== null && _placement$right !== void 0 ? _placement$right : 0;
        placement.width = (_placement$width2 = placement.width) !== null && _placement$width2 !== void 0 ? _placement$width2 : 100;
        style.right = `${placement.right}px`;
        style.width = `${placement.width}px`;
        delete placement.left;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.LeftRight:
        placement.left = (_placement$left2 = placement.left) !== null && _placement$left2 !== void 0 ? _placement$left2 : 0;
        placement.right = (_placement$right2 = placement.right) !== null && _placement$right2 !== void 0 ? _placement$right2 : 0;
        style.left = `${placement.left}px`;
        style.right = `${placement.right}px`;
        delete placement.width;
        style.width = '';
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Center:
        placement.left = (_placement$left3 = placement.left) !== null && _placement$left3 !== void 0 ? _placement$left3 : 0;
        placement.width = (_placement$width3 = placement.width) !== null && _placement$width3 !== void 0 ? _placement$width3 : 100;
        translate[0] = '-50%';
        style.left = `calc(50% - ${placement.left}px)`;
        style.width = `${placement.width}px`;
        delete placement.right;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Scale:
        placement.left = (_placement$left4 = placement.left) !== null && _placement$left4 !== void 0 ? _placement$left4 : 0;
        placement.right = (_placement$right3 = placement.right) !== null && _placement$right3 !== void 0 ? _placement$right3 : 0;
        style.left = `${placement.left}%`;
        style.right = `${placement.right}%`;
        delete placement.width;
        style.width = '';
        break;
    }

    style.transform = `translate(${translate[0]}, ${translate[1]})`;
    this.options.placement = placement;
    this.sizeStyle = style;

    if (this.div) {
      for (const key in this.sizeStyle) {
        this.div.style[key] = this.sizeStyle[key];
      }

      for (const key in this.dataStyle) {
        this.div.style[key] = this.dataStyle[key];
      }
    }
  }

  setPlacementFromConstraint(elementContainer, parentContainer) {
    var _elementContainer$wid, _elementContainer, _elementContainer$hei2, _elementContainer2, _parentContainer$heig, _parentContainer, _parentContainer$heig2, _parentContainer2, _parentContainer$widt, _parentContainer3, _parentContainer$widt2, _parentContainer4;

    const {
      constraint
    } = this.options;
    const {
      vertical,
      horizontal
    } = constraint !== null && constraint !== void 0 ? constraint : {};

    if (!elementContainer) {
      elementContainer = this.div && this.div.getBoundingClientRect();
    }

    if (!parentContainer) {
      var _this$div$parentEleme;

      parentContainer = this.div && ((_this$div$parentEleme = this.div.parentElement) === null || _this$div$parentEleme === void 0 ? void 0 : _this$div$parentEleme.getBoundingClientRect());
    }

    const relativeTop = elementContainer && parentContainer ? Math.round(elementContainer.top - parentContainer.top) : 0;
    const relativeBottom = elementContainer && parentContainer ? Math.round(parentContainer.bottom - elementContainer.bottom) : 0;
    const relativeLeft = elementContainer && parentContainer ? Math.round(elementContainer.left - parentContainer.left) : 0;
    const relativeRight = elementContainer && parentContainer ? Math.round(parentContainer.right - elementContainer.right) : 0;
    const placement = {};
    const width = (_elementContainer$wid = (_elementContainer = elementContainer) === null || _elementContainer === void 0 ? void 0 : _elementContainer.width) !== null && _elementContainer$wid !== void 0 ? _elementContainer$wid : 100;
    const height = (_elementContainer$hei2 = (_elementContainer2 = elementContainer) === null || _elementContainer2 === void 0 ? void 0 : _elementContainer2.height) !== null && _elementContainer$hei2 !== void 0 ? _elementContainer$hei2 : 100;

    switch (vertical) {
      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Top:
        placement.top = relativeTop;
        placement.height = height;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Bottom:
        placement.bottom = relativeBottom;
        placement.height = height;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.TopBottom:
        placement.top = relativeTop;
        placement.bottom = relativeBottom;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Center:
        const elementCenter = elementContainer ? relativeTop + height / 2 : 0;
        const parentCenter = parentContainer ? parentContainer.height / 2 : 0;
        const distanceFromCenter = parentCenter - elementCenter;
        placement.top = distanceFromCenter;
        placement.height = height;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Scale:
        placement.top = relativeTop / ((_parentContainer$heig = (_parentContainer = parentContainer) === null || _parentContainer === void 0 ? void 0 : _parentContainer.height) !== null && _parentContainer$heig !== void 0 ? _parentContainer$heig : height) * 100;
        placement.bottom = relativeBottom / ((_parentContainer$heig2 = (_parentContainer2 = parentContainer) === null || _parentContainer2 === void 0 ? void 0 : _parentContainer2.height) !== null && _parentContainer$heig2 !== void 0 ? _parentContainer$heig2 : height) * 100;
        break;
    }

    switch (horizontal) {
      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Left:
        placement.left = relativeLeft;
        placement.width = width;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Right:
        placement.right = relativeRight;
        placement.width = width;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.LeftRight:
        placement.left = relativeLeft;
        placement.right = relativeRight;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Center:
        const elementCenter = elementContainer ? relativeLeft + width / 2 : 0;
        const parentCenter = parentContainer ? parentContainer.width / 2 : 0;
        const distanceFromCenter = parentCenter - elementCenter;
        placement.left = distanceFromCenter;
        placement.width = width;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Scale:
        placement.left = relativeLeft / ((_parentContainer$widt = (_parentContainer3 = parentContainer) === null || _parentContainer3 === void 0 ? void 0 : _parentContainer3.width) !== null && _parentContainer$widt !== void 0 ? _parentContainer$widt : width) * 100;
        placement.right = relativeRight / ((_parentContainer$widt2 = (_parentContainer4 = parentContainer) === null || _parentContainer4 === void 0 ? void 0 : _parentContainer4.width) !== null && _parentContainer$widt2 !== void 0 ? _parentContainer$widt2 : width) * 100;
        break;
    }

    this.options.placement = placement;
    this.applyLayoutStylesToDiv();
    this.revId++;
  }

  updateData(ctx) {
    var _background$size;

    if (this.item.prepareData) {
      this.data = this.item.prepareData(ctx, this.options.config);
      this.revId++; // rerender
    }

    const {
      background,
      border
    } = this.options;
    const css = {};

    if (background) {
      if (background.color) {
        const color = ctx.getColor(background.color);
        css.backgroundColor = color.value();
      }

      if (background.image) {
        const image = ctx.getResource(background.image);

        if (image) {
          const v = image.value();

          if (v) {
            css.backgroundImage = `url("${v}")`;

            switch ((_background$size = background.size) !== null && _background$size !== void 0 ? _background$size : app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Contain) {
              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Contain:
                css.backgroundSize = 'contain';
                css.backgroundRepeat = 'no-repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Cover:
                css.backgroundSize = 'cover';
                css.backgroundRepeat = 'no-repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Original:
                css.backgroundRepeat = 'no-repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Tile:
                css.backgroundRepeat = 'repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Fill:
                css.backgroundSize = '100% 100%';
                break;
            }
          }
        }
      }
    }

    if (border && border.color && border.width) {
      const color = ctx.getColor(border.color);
      css.borderWidth = border.width;
      css.borderStyle = 'solid';
      css.borderColor = color.value(); // Move the image to inside the border

      if (css.backgroundImage) {
        css.backgroundOrigin = 'padding-box';
      }
    }

    this.dataStyle = css;
    this.applyLayoutStylesToDiv();
  }

  isRoot() {
    return false;
  }
  /** Recursively visit all nodes */


  visit(visitor) {
    visitor(this);
  }

  onChange(options) {
    if (this.item.id !== options.type) {
      var _canvasElementRegistr;

      this.item = (_canvasElementRegistr = app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.canvasElementRegistry.getIfExists(options.type)) !== null && _canvasElementRegistr !== void 0 ? _canvasElementRegistr : app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_2__.notFoundItem;
    } // rename handling


    const oldName = this.options.name;
    const newName = options.name;
    this.revId++;
    this.options = Object.assign({}, options);
    let trav = this.parent;

    while (trav) {
      if (trav.isRoot()) {
        trav.scene.save();
        break;
      }

      trav.revId++;
      trav = trav.parent;
    }

    const scene = this.getScene();

    if (oldName !== newName && scene) {
      scene.byName.delete(oldName);
      scene.byName.set(newName, this);
    }
  }

  getSaveModel() {
    return Object.assign({}, this.options);
  }

  render() {
    const {
      item
    } = this;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      ref: this.initElement,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(item.display, {
        config: this.options.config,
        data: this.data
      }, `${this.UID}/${this.revId}`)
    }, this.UID);
  }

}

/***/ }),

/***/ "./public/app/features/canvas/runtime/frame.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FrameState": () => (/* binding */ FrameState),
/* harmony export */   "frameItemDummy": () => (/* binding */ frameItemDummy)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/elements/notFound.tsx");
/* harmony import */ var app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/canvas/types.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/canvas/types.ts");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/canvas/runtime/element.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _div;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









const frameItemDummy = {
  id: 'frame',
  name: 'Frame',
  description: 'Frame',
  getNewOptions: () => ({
    config: {}
  }),
  // eslint-disable-next-line react/display-name
  display: () => {
    return _div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
      children: "FRAME!"
    }));
  }
};
class FrameState extends _element__WEBPACK_IMPORTED_MODULE_6__.ElementState {
  constructor(options, scene, parent) {
    super(frameItemDummy, options, parent);

    _defineProperty(this, "elements", []);

    _defineProperty(this, "scene", void 0);

    _defineProperty(this, "doAction", (action, element, updateName = true, shiftItemsOnDuplicate = true) => {
      var _element$parent;

      switch (action) {
        case app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__.LayerActionID.Delete:
          this.elements = this.elements.filter(e => e !== element);
          this.scene.byName.delete(element.options.name);
          this.scene.save();
          this.reinitializeMoveable();
          break;

        case app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__.LayerActionID.Duplicate:
          if (element.item.id === 'frame') {
            console.log('Can not duplicate frames (yet)', action, element);
            return;
          }

          const opts = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(element.options);

          if (shiftItemsOnDuplicate) {
            const {
              constraint,
              placement: oldPlacement
            } = element.options;
            const {
              vertical,
              horizontal
            } = constraint !== null && constraint !== void 0 ? constraint : {};
            const placement = oldPlacement !== null && oldPlacement !== void 0 ? oldPlacement : {};

            switch (vertical) {
              case _types__WEBPACK_IMPORTED_MODULE_5__.VerticalConstraint.Top:
              case _types__WEBPACK_IMPORTED_MODULE_5__.VerticalConstraint.TopBottom:
                if (placement.top == null) {
                  placement.top = 25;
                } else {
                  placement.top += 10;
                }

                break;

              case _types__WEBPACK_IMPORTED_MODULE_5__.VerticalConstraint.Bottom:
                if (placement.bottom == null) {
                  placement.bottom = 100;
                } else {
                  placement.bottom -= 10;
                }

                break;
            }

            switch (horizontal) {
              case _types__WEBPACK_IMPORTED_MODULE_5__.HorizontalConstraint.Left:
              case _types__WEBPACK_IMPORTED_MODULE_5__.HorizontalConstraint.LeftRight:
                if (placement.left == null) {
                  placement.left = 50;
                } else {
                  placement.left += 10;
                }

                break;

              case _types__WEBPACK_IMPORTED_MODULE_5__.HorizontalConstraint.Right:
                if (placement.right == null) {
                  placement.right = 50;
                } else {
                  placement.right -= 10;
                }

                break;
            }

            opts.placement = placement;
          }

          const copy = new _element__WEBPACK_IMPORTED_MODULE_6__.ElementState(element.item, opts, this);
          copy.updateData(this.scene.context);

          if (updateName) {
            copy.options.name = this.scene.getNextElementName();
          }

          this.elements.push(copy);
          this.scene.byName.set(copy.options.name, copy);
          this.scene.save();
          this.reinitializeMoveable();
          break;

        case app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__.LayerActionID.MoveTop:
        case app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__.LayerActionID.MoveBottom:
          (_element$parent = element.parent) === null || _element$parent === void 0 ? void 0 : _element$parent.doMove(element, action);
          break;

        default:
          console.log('DO action', action, element);
          return;
      }
    });

    this.options = options;
    this.parent = parent;
    this.scene = scene; // mutate options object

    let {
      elements
    } = this.options;

    if (!elements) {
      this.options.elements = elements = [];
    }

    for (const c of elements) {
      if (c.type === 'frame') {
        this.elements.push(new FrameState(c, scene, this));
      } else {
        var _canvasElementRegistr;

        const item = (_canvasElementRegistr = app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.canvasElementRegistry.getIfExists(c.type)) !== null && _canvasElementRegistr !== void 0 ? _canvasElementRegistr : app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_3__.notFoundItem;
        this.elements.push(new _element__WEBPACK_IMPORTED_MODULE_6__.ElementState(item, c, this));
      }
    }
  }

  isRoot() {
    return false;
  }

  updateData(ctx) {
    super.updateData(ctx);

    for (const elem of this.elements) {
      elem.updateData(ctx);
    }
  } // used in the layer editor


  reorder(startIndex, endIndex) {
    const result = Array.from(this.elements);
    const [removed] = result.splice(startIndex, 1);
    result.splice(endIndex, 0, removed);
    this.elements = result;
    this.reinitializeMoveable();
  }

  doMove(child, action) {
    const vals = this.elements.filter(v => v !== child);

    if (action === app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__.LayerActionID.MoveBottom) {
      vals.unshift(child);
    } else {
      vals.push(child);
    }

    this.elements = vals;
    this.scene.save();
    this.reinitializeMoveable();
  }

  reinitializeMoveable() {
    // Need to first clear current selection and then re-init moveable with slight delay
    this.scene.clearCurrentSelection();
    setTimeout(() => this.scene.initMoveable(true, this.scene.isEditingEnabled));
  } // ??? or should this be on the element directly?
  // are actions scoped to layers?


  render() {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
      ref: this.initElement,
      style: {
        overflow: 'hidden'
      },
      children: this.elements.map(v => v.render())
    }, this.UID);
  }
  /** Recursively visit all nodes */


  visit(visitor) {
    super.visit(visitor);

    for (const e of this.elements) {
      visitor(e);
    }
  }

  getSaveModel() {
    return Object.assign({}, this.options, {
      elements: this.elements.map(v => v.getSaveModel())
    });
  }

}

/***/ }),

/***/ "./public/app/features/canvas/runtime/root.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RootElement": () => (/* binding */ RootElement)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _frame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["placement", "constraint"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




class RootElement extends _frame__WEBPACK_IMPORTED_MODULE_1__.FrameState {
  constructor(options, scene, changeCallback) {
    super(options, scene);

    _defineProperty(this, "setRootRef", target => {
      this.div = target;
    });

    this.options = options;
    this.scene = scene;
    this.changeCallback = changeCallback;
    this.sizeStyle = {
      height: '100%',
      width: '100%'
    };
  }

  isRoot() {
    return true;
  } // root type can not change


  onChange(options) {
    this.revId++;
    this.options = Object.assign({}, options);
    this.changeCallback();
  }

  getSaveModel() {
    const _this$options = this.options,
          rest = _objectWithoutPropertiesLoose(_this$options, _excluded);

    return Object.assign({}, rest, {
      // everything except placement & constraint
      elements: this.elements.map(v => v.getSaveModel())
    });
  }

  render() {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
      onContextMenu: event => event.preventDefault(),
      ref: this.setRootRef,
      style: Object.assign({}, this.sizeStyle, this.dataStyle),
      children: this.elements.map(v => v.render())
    }, this.UID);
  }

}

/***/ }),

/***/ "./public/app/features/canvas/runtime/scene.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Scene": () => (/* binding */ Scene)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var moveable__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./.yarn/cache/moveable-npm-0.30.0-4e08a73dff-de79554307.zip/node_modules/moveable/dist/moveable.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/first.js");
/* harmony import */ var selecto__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./.yarn/cache/selecto-npm-1.16.2-b4fff537b7-a838944964.zip/node_modules/selecto/dist/selecto.esm.js");
/* harmony import */ var _grafana_runtime_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/config.ts");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/dimensions/utils.ts");
/* harmony import */ var app_plugins_panel_canvas_CanvasContextMenu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/canvas/CanvasContextMenu.tsx");
/* harmony import */ var app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/panel/canvas/types.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/features/canvas/types.ts");
/* harmony import */ var _ables__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/features/canvas/runtime/ables.tsx");
/* harmony import */ var _frame__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/features/canvas/runtime/root.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




















class Scene {
  // called after resize/drag for editor updates
  constructor(cfg, enableEditing, onSave) {
    _defineProperty(this, "styles", getStyles(app_core_config__WEBPACK_IMPORTED_MODULE_4__.config.theme2));

    _defineProperty(this, "selection", new rxjs__WEBPACK_IMPORTED_MODULE_14__.ReplaySubject(1));

    _defineProperty(this, "moved", new rxjs__WEBPACK_IMPORTED_MODULE_15__.Subject());

    _defineProperty(this, "byName", new Map());

    _defineProperty(this, "root", void 0);

    _defineProperty(this, "revId", 0);

    _defineProperty(this, "width", 0);

    _defineProperty(this, "height", 0);

    _defineProperty(this, "style", {});

    _defineProperty(this, "data", void 0);

    _defineProperty(this, "selecto", void 0);

    _defineProperty(this, "moveable", void 0);

    _defineProperty(this, "div", void 0);

    _defineProperty(this, "currentLayer", void 0);

    _defineProperty(this, "isEditingEnabled", void 0);

    _defineProperty(this, "skipNextSelectionBroadcast", false);

    _defineProperty(this, "isPanelEditing", _grafana_runtime_src__WEBPACK_IMPORTED_MODULE_2__.locationService.getSearchObject().editPanel !== undefined);

    _defineProperty(this, "getNextElementName", (isFrame = false) => {
      const label = isFrame ? 'Frame' : 'Element';
      let idx = this.byName.size + 1;
      const max = idx + 100;

      while ( true && idx < max) {
        const name = `${label} ${idx++}`;

        if (!this.byName.has(name)) {
          return name;
        }
      }

      return `${label} ${Date.now()}`;
    });

    _defineProperty(this, "canRename", v => {
      return !this.byName.has(v);
    });

    _defineProperty(this, "context", {
      getColor: color => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_6__.getColorDimensionFromData)(this.data, color),
      getScale: scale => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_6__.getScaleDimensionFromData)(this.data, scale),
      getScalar: scalar => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_6__.getScalarDimensionFromData)(this.data, scalar),
      getText: text => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_6__.getTextDimensionFromData)(this.data, text),
      getResource: res => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_6__.getResourceDimensionFromData)(this.data, res)
    });

    _defineProperty(this, "generateFrameContainer", elements => {
      let minTop = Infinity;
      let minLeft = Infinity;
      let maxRight = 0;
      let maxBottom = 0;
      elements.forEach(element => {
        var _element$div;

        const elementContainer = (_element$div = element.div) === null || _element$div === void 0 ? void 0 : _element$div.getBoundingClientRect();

        if (!elementContainer) {
          return;
        }

        if (minTop > elementContainer.top) {
          minTop = elementContainer.top;
        }

        if (minLeft > elementContainer.left) {
          minLeft = elementContainer.left;
        }

        if (maxRight < elementContainer.right) {
          maxRight = elementContainer.right;
        }

        if (maxBottom < elementContainer.bottom) {
          maxBottom = elementContainer.bottom;
        }
      });
      return {
        top: minTop,
        left: minLeft,
        width: maxRight - minLeft,
        height: maxBottom - minTop
      };
    });

    _defineProperty(this, "save", (updateMoveable = false) => {
      this.onSave(this.root.getSaveModel());

      if (updateMoveable) {
        setTimeout(() => {
          if (this.div) {
            this.initMoveable(true, this.isEditingEnabled);
          }
        });
      }
    });

    _defineProperty(this, "findElementByTarget", target => {
      // We will probably want to add memoization to this as we are calling on drag / resize
      const stack = [...this.root.elements];

      while (stack.length > 0) {
        const currentElement = stack.shift();

        if (currentElement && currentElement.div && currentElement.div === target) {
          return currentElement;
        }

        const nestedElements = currentElement instanceof _frame__WEBPACK_IMPORTED_MODULE_11__.FrameState ? currentElement.elements : [];

        for (const nestedElement of nestedElements) {
          stack.unshift(nestedElement);
        }
      }

      return undefined;
    });

    _defineProperty(this, "setRef", sceneContainer => {
      this.div = sceneContainer;
    });

    _defineProperty(this, "select", selection => {
      if (this.selecto) {
        this.selecto.setSelectedTargets(selection.targets);
        this.updateSelection(selection);
      }
    });

    _defineProperty(this, "updateSelection", selection => {
      this.moveable.target = selection.targets;

      if (this.skipNextSelectionBroadcast) {
        this.skipNextSelectionBroadcast = false;
        return;
      }

      if (selection.frame) {
        this.selection.next([selection.frame]);
      } else {
        const s = selection.targets.map(t => this.findElementByTarget(t));
        this.selection.next(s);
      }
    });

    _defineProperty(this, "generateTargetElements", rootElements => {
      let targetElements = [];
      const stack = [...rootElements];

      while (stack.length > 0) {
        const currentElement = stack.shift();

        if (currentElement && currentElement.div) {
          targetElements.push(currentElement.div);
        }

        const nestedElements = currentElement instanceof _frame__WEBPACK_IMPORTED_MODULE_11__.FrameState ? currentElement.elements : [];

        for (const nestedElement of nestedElements) {
          stack.unshift(nestedElement);
        }
      }

      return targetElements;
    });

    _defineProperty(this, "initMoveable", (destroySelecto = false, allowChanges = true) => {
      const targetElements = this.generateTargetElements(this.root.elements);

      if (destroySelecto && this.selecto) {
        this.selecto.destroy();
      }

      this.selecto = new selecto__WEBPACK_IMPORTED_MODULE_16__["default"]({
        container: this.div,
        selectableTargets: targetElements,
        selectByClick: true
      });
      this.moveable = new moveable__WEBPACK_IMPORTED_MODULE_17__["default"](this.div, {
        draggable: allowChanges,
        resizable: allowChanges,
        ables: [_ables__WEBPACK_IMPORTED_MODULE_10__.dimensionViewable, (0,_ables__WEBPACK_IMPORTED_MODULE_10__.constraintViewable)(this)],
        props: {
          dimensionViewable: allowChanges,
          constraintViewable: allowChanges
        },
        origin: false,
        className: this.styles.selected
      }).on('clickGroup', event => {
        this.selecto.clickTarget(event.inputEvent, event.inputTarget);
      }).on('dragStart', event => {
        const targetedElement = this.findElementByTarget(event.target);

        if (targetedElement) {
          targetedElement.isMoving = true;
        }
      }).on('drag', event => {
        const targetedElement = this.findElementByTarget(event.target);
        targetedElement.applyDrag(event);
      }).on('dragGroup', e => {
        e.events.forEach(event => {
          const targetedElement = this.findElementByTarget(event.target);
          targetedElement.applyDrag(event);
        });
      }).on('dragEnd', event => {
        const targetedElement = this.findElementByTarget(event.target);

        if (targetedElement) {
          targetedElement.setPlacementFromConstraint();
          targetedElement.isMoving = false;
        }

        this.moved.next(Date.now());
      }).on('resizeStart', event => {
        const targetedElement = this.findElementByTarget(event.target);

        if (targetedElement) {
          targetedElement.tempConstraint = Object.assign({}, targetedElement.options.constraint);
          targetedElement.options.constraint = {
            vertical: _types__WEBPACK_IMPORTED_MODULE_9__.VerticalConstraint.Top,
            horizontal: _types__WEBPACK_IMPORTED_MODULE_9__.HorizontalConstraint.Left
          };
          targetedElement.setPlacementFromConstraint();
        }
      }).on('resize', event => {
        const targetedElement = this.findElementByTarget(event.target);
        targetedElement.applyResize(event);
        this.moved.next(Date.now()); // TODO only on end
      }).on('resizeGroup', e => {
        e.events.forEach(event => {
          const targetedElement = this.findElementByTarget(event.target);
          targetedElement.applyResize(event);
        });
        this.moved.next(Date.now()); // TODO only on end
      }).on('resizeEnd', event => {
        const targetedElement = this.findElementByTarget(event.target);

        if (targetedElement) {
          if (targetedElement.tempConstraint) {
            targetedElement.options.constraint = targetedElement.tempConstraint;
            targetedElement.tempConstraint = undefined;
          }

          targetedElement.setPlacementFromConstraint();
        }
      });
      let targets = [];
      this.selecto.on('dragStart', event => {
        const selectedTarget = event.inputEvent.target;
        const isTargetMoveableElement = this.moveable.isMoveableElement(selectedTarget) || targets.some(target => target === selectedTarget || target.contains(selectedTarget));

        if (isTargetMoveableElement) {
          // Prevent drawing selection box when selected target is a moveable element
          event.stop();
        }
      }).on('selectEnd', event => {
        targets = event.selected;
        this.updateSelection({
          targets
        });

        if (event.isDragStart) {
          event.inputEvent.preventDefault();
          setTimeout(() => {
            this.moveable.dragStart(event.inputEvent);
          });
        }
      });
    });

    this.onSave = onSave;
    this.root = this.load(cfg, enableEditing);
  }

  load(cfg, enableEditing) {
    this.root = new _root__WEBPACK_IMPORTED_MODULE_12__.RootElement(cfg !== null && cfg !== void 0 ? cfg : {
      type: 'frame',
      elements: [app_features_canvas__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CANVAS_ELEMENT_CONFIG]
    }, this, this.save // callback when changes are made
    );
    this.isEditingEnabled = enableEditing;
    setTimeout(() => {
      if (this.div) {
        // If editing is enabled, clear selecto instance
        const destroySelecto = enableEditing;
        this.initMoveable(destroySelecto, enableEditing);
        this.currentLayer = this.root;
        this.selection.next([]);
      }
    });
    return this.root;
  }

  updateData(data) {
    this.data = data;
    this.root.updateData(this.context);
  }

  updateSize(width, height) {
    var _this$selecto;

    this.width = width;
    this.height = height;
    this.style = {
      width,
      height
    };

    if ((_this$selecto = this.selecto) !== null && _this$selecto !== void 0 && _this$selecto.getSelectedTargets().length) {
      this.clearCurrentSelection();
    }
  }

  frameSelection() {
    this.selection.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_18__.first)()).subscribe(currentSelectedElements => {
      var _currentLayer$div;

      const currentLayer = currentSelectedElements[0].parent;
      const newLayer = new _frame__WEBPACK_IMPORTED_MODULE_11__.FrameState({
        type: 'frame',
        name: this.getNextElementName(true),
        elements: []
      }, this, currentSelectedElements[0].parent);
      const framePlacement = this.generateFrameContainer(currentSelectedElements);
      newLayer.options.placement = framePlacement;
      currentSelectedElements.forEach(element => {
        var _element$div2;

        const elementContainer = (_element$div2 = element.div) === null || _element$div2 === void 0 ? void 0 : _element$div2.getBoundingClientRect();
        element.setPlacementFromConstraint(elementContainer, framePlacement);
        currentLayer.doAction(app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_8__.LayerActionID.Delete, element);
        newLayer.doAction(app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_8__.LayerActionID.Duplicate, element, false, false);
      });
      newLayer.setPlacementFromConstraint(framePlacement, (_currentLayer$div = currentLayer.div) === null || _currentLayer$div === void 0 ? void 0 : _currentLayer$div.getBoundingClientRect());
      currentLayer.elements.push(newLayer);
      this.byName.set(newLayer.getName(), newLayer);
      this.save();
    });
  }

  clearCurrentSelection(skipNextSelectionBroadcast = false) {
    var _this$selecto2;

    this.skipNextSelectionBroadcast = skipNextSelectionBroadcast;
    let event = new MouseEvent('click');
    (_this$selecto2 = this.selecto) === null || _this$selecto2 === void 0 ? void 0 : _this$selecto2.clickTarget(event, this.div);
  }

  updateCurrentLayer(newLayer) {
    this.currentLayer = newLayer;
    this.clearCurrentSelection();
    this.save();
  }

  render() {
    const canShowContextMenu = this.isPanelEditing || !this.isPanelEditing && this.isEditingEnabled;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsxs)("div", {
      className: this.styles.wrap,
      style: this.style,
      ref: this.setRef,
      children: [this.root.render(), canShowContextMenu && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Portal, {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)(app_plugins_panel_canvas_CanvasContextMenu__WEBPACK_IMPORTED_MODULE_7__.CanvasContextMenu, {
          scene: this
        })
      })]
    }, this.revId);
  }

}
const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.stylesFactory)(theme => ({
  wrap: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    overflow: hidden;
    position: relative;
  `,
  selected: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    z-index: 999 !important;
  `
}));

/***/ }),

/***/ "./public/app/features/canvas/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundImageSize": () => (/* binding */ BackgroundImageSize),
/* harmony export */   "HorizontalConstraint": () => (/* binding */ HorizontalConstraint),
/* harmony export */   "QuickPlacement": () => (/* binding */ QuickPlacement),
/* harmony export */   "VerticalConstraint": () => (/* binding */ VerticalConstraint)
/* harmony export */ });
let HorizontalConstraint;

(function (HorizontalConstraint) {
  HorizontalConstraint["Left"] = "left";
  HorizontalConstraint["Right"] = "right";
  HorizontalConstraint["LeftRight"] = "leftright";
  HorizontalConstraint["Center"] = "center";
  HorizontalConstraint["Scale"] = "scale";
})(HorizontalConstraint || (HorizontalConstraint = {}));

let VerticalConstraint;

(function (VerticalConstraint) {
  VerticalConstraint["Top"] = "top";
  VerticalConstraint["Bottom"] = "bottom";
  VerticalConstraint["TopBottom"] = "topbottom";
  VerticalConstraint["Center"] = "center";
  VerticalConstraint["Scale"] = "scale";
})(VerticalConstraint || (VerticalConstraint = {}));

let BackgroundImageSize;

(function (BackgroundImageSize) {
  BackgroundImageSize["Original"] = "original";
  BackgroundImageSize["Contain"] = "contain";
  BackgroundImageSize["Cover"] = "cover";
  BackgroundImageSize["Fill"] = "fill";
  BackgroundImageSize["Tile"] = "tile";
})(BackgroundImageSize || (BackgroundImageSize = {}));

let QuickPlacement;

(function (QuickPlacement) {
  QuickPlacement["Top"] = "top";
  QuickPlacement["Bottom"] = "bottom";
  QuickPlacement["Left"] = "left";
  QuickPlacement["Right"] = "right";
  QuickPlacement["HorizontalCenter"] = "hcenter";
  QuickPlacement["VerticalCenter"] = "vcenter";
})(QuickPlacement || (QuickPlacement = {}));

/***/ }),

/***/ "./public/app/plugins/panel/canvas/CanvasContextMenu.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasContextMenu": () => (/* binding */ CanvasContextMenu)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/first.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








const CanvasContextMenu = ({
  scene
}) => {
  var _scene$selecto;

  const [isMenuVisible, setIsMenuVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const [anchorPoint, setAnchorPoint] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
    x: 0,
    y: 0
  });
  const styles = getStyles();
  const selectedElements = (_scene$selecto = scene.selecto) === null || _scene$selecto === void 0 ? void 0 : _scene$selecto.getSelectedTargets();
  const handleContextMenu = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(event => {
    event.preventDefault();

    if (event.currentTarget) {
      scene.select({
        targets: [event.currentTarget]
      });
    }

    setAnchorPoint({
      x: event.pageX,
      y: event.pageY
    });
    setIsMenuVisible(true);
  }, [scene]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (selectedElements && selectedElements.length === 1) {
      const element = selectedElements[0];
      element.addEventListener('contextmenu', handleContextMenu);
    }
  }, [selectedElements, handleContextMenu]);

  if (!selectedElements) {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {});
  }

  const closeContextMenu = () => {
    setIsMenuVisible(false);
  };

  const renderMenuItems = () => {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.MenuItem, {
        label: "Delete",
        onClick: () => {
          contextMenuAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.Delete);
          closeContextMenu();
        },
        className: styles.menuItem
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.MenuItem, {
        label: "Duplicate",
        onClick: () => {
          contextMenuAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.Duplicate);
          closeContextMenu();
        },
        className: styles.menuItem
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.MenuItem, {
        label: "Bring to front",
        onClick: () => {
          contextMenuAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.MoveTop);
          closeContextMenu();
        },
        className: styles.menuItem
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.MenuItem, {
        label: "Send to back",
        onClick: () => {
          contextMenuAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.MoveBottom);
          closeContextMenu();
        },
        className: styles.menuItem
      })]
    });
  };

  const contextMenuAction = actionType => {
    scene.selection.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.first)()).subscribe(currentSelectedElements => {
      const currentSelectedElement = currentSelectedElements[0];
      const currentLayer = currentSelectedElement.parent;

      switch (actionType) {
        case _types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.Delete:
          currentLayer.doAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.Delete, currentSelectedElement);
          break;

        case _types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.Duplicate:
          currentLayer.doAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.Duplicate, currentSelectedElement);
          break;

        case _types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.MoveTop:
          currentLayer.doAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.MoveTop, currentSelectedElement);
          break;

        case _types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.MoveBottom:
          currentLayer.doAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.MoveBottom, currentSelectedElement);
          break;
      }
    });
  };

  if (isMenuVisible) {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      onContextMenu: event => {
        event.preventDefault();
        closeContextMenu();
      },
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.ContextMenu, {
        x: anchorPoint.x,
        y: anchorPoint.y,
        onClose: closeContextMenu,
        renderMenuItems: renderMenuItems,
        focusOnOpen: false
      })
    });
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {});
};

const getStyles = () => ({
  menuItem: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    max-width: 60ch;
    overflow: hidden;
  `
});

/***/ }),

/***/ "./public/app/plugins/panel/canvas/CanvasPanel.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasPanel": () => (/* binding */ CanvasPanel),
/* harmony export */   "activePanelSubject": () => (/* binding */ activePanelSubject)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _grafana_runtime_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_canvas_runtime_scene__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/canvas/runtime/scene.tsx");
/* harmony import */ var app_types_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/types/events.ts");
/* harmony import */ var _InlineEdit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/canvas/InlineEdit.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












let canvasInstances = [];
let activeCanvasPanel = undefined;
let isInlineEditOpen = false;
const activePanelSubject = new rxjs__WEBPACK_IMPORTED_MODULE_8__.ReplaySubject(1);
class CanvasPanel extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "panelContext", {});

    _defineProperty(this, "scene", void 0);

    _defineProperty(this, "subs", new rxjs__WEBPACK_IMPORTED_MODULE_9__.Subscription());

    _defineProperty(this, "needsReload", false);

    _defineProperty(this, "styles", getStyles(_grafana_runtime_src__WEBPACK_IMPORTED_MODULE_2__.config.theme));

    _defineProperty(this, "isEditing", _grafana_runtime_src__WEBPACK_IMPORTED_MODULE_2__.locationService.getSearchObject().editPanel !== undefined);

    _defineProperty(this, "onUpdateScene", root => {
      const {
        onOptionsChange,
        options
      } = this.props;
      onOptionsChange(Object.assign({}, options, {
        root
      }));
      this.setState({
        refresh: this.state.refresh + 1
      }); // console.log('send changes', root);
    });

    _defineProperty(this, "inlineEditButtonClick", () => {
      if (isInlineEditOpen) {
        this.forceUpdate();
        this.setActivePanel();
        return;
      }

      this.setActivePanel();
      this.setState({
        openInlineEdit: true
      });
      isInlineEditOpen = true;
    });

    _defineProperty(this, "inlineEditButtonClose", () => {
      this.setState({
        openInlineEdit: false
      });
      isInlineEditOpen = false;
    });

    _defineProperty(this, "setActivePanel", () => {
      activeCanvasPanel = this;
      activePanelSubject.next({
        panel: this
      });
    });

    _defineProperty(this, "renderInlineEdit", () => {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_InlineEdit__WEBPACK_IMPORTED_MODULE_6__.InlineEdit, {
        onClose: () => this.inlineEditButtonClose()
      });
    });

    this.state = {
      refresh: 0,
      openInlineEdit: false
    }; // Only the initial options are ever used.
    // later changes are all controlled by the scene

    this.scene = new app_features_canvas_runtime_scene__WEBPACK_IMPORTED_MODULE_4__.Scene(this.props.options.root, this.props.options.inlineEditing, this.onUpdateScene);
    this.scene.updateSize(props.width, props.height);
    this.scene.updateData(props.data);
    this.subs.add(this.props.eventBus.subscribe(app_types_events__WEBPACK_IMPORTED_MODULE_5__.PanelEditEnteredEvent, evt => {
      // Remove current selection when entering edit mode for any panel in dashboard
      this.scene.clearCurrentSelection();
      this.inlineEditButtonClose();
    }));
    this.subs.add(this.props.eventBus.subscribe(app_types_events__WEBPACK_IMPORTED_MODULE_5__.PanelEditExitedEvent, evt => {
      if (this.props.id === evt.payload) {
        this.needsReload = true;
      }
    }));
  }

  componentDidMount() {
    activeCanvasPanel = this;
    activePanelSubject.next({
      panel: this
    });
    this.panelContext = this.context;

    if (this.panelContext.onInstanceStateChange) {
      this.panelContext.onInstanceStateChange({
        scene: this.scene,
        layer: this.scene.root
      });
      this.subs.add(this.scene.selection.subscribe({
        next: v => {
          this.panelContext.onInstanceStateChange({
            scene: this.scene,
            selected: v,
            layer: this.scene.root
          });
          activeCanvasPanel = this;
          activePanelSubject.next({
            panel: this
          });
          canvasInstances.forEach(canvasInstance => {
            if (canvasInstance !== activeCanvasPanel) {
              canvasInstance.scene.clearCurrentSelection(true);
            }
          });
        }
      }));
    }

    canvasInstances.push(this);
  }

  componentWillUnmount() {
    this.subs.unsubscribe();
    isInlineEditOpen = false;
    canvasInstances = canvasInstances.filter(ci => {
      var _activeCanvasPanel;

      return ci.props.id !== ((_activeCanvasPanel = activeCanvasPanel) === null || _activeCanvasPanel === void 0 ? void 0 : _activeCanvasPanel.props.id);
    });
  } // NOTE, all changes to the scene flow through this function
  // even the editor gets current state from the same scene instance!


  shouldComponentUpdate(nextProps, nextState) {
    const {
      width,
      height,
      data
    } = this.props;
    let changed = false;

    if (width !== nextProps.width || height !== nextProps.height) {
      this.scene.updateSize(nextProps.width, nextProps.height);
      changed = true;
    }

    if (data !== nextProps.data) {
      this.scene.updateData(nextProps.data);
      changed = true;
    }

    if (this.state.refresh !== nextState.refresh) {
      changed = true;
    }

    if (this.state.openInlineEdit !== nextState.openInlineEdit) {
      changed = true;
    } // After editing, the options are valid, but the scene was in a different panel or inline editing mode has changed


    const shouldUpdateSceneAndPanel = this.needsReload && this.props.options !== nextProps.options;
    const inlineEditingSwitched = this.props.options.inlineEditing !== nextProps.options.inlineEditing;

    if (shouldUpdateSceneAndPanel || inlineEditingSwitched) {
      this.needsReload = false;
      this.scene.load(nextProps.options.root, nextProps.options.inlineEditing);
      this.scene.updateSize(nextProps.width, nextProps.height);
      this.scene.updateData(nextProps.data);
      changed = true;

      if (inlineEditingSwitched && this.props.options.inlineEditing) {
        var _this$scene$selecto;

        (_this$scene$selecto = this.scene.selecto) === null || _this$scene$selecto === void 0 ? void 0 : _this$scene$selecto.destroy();
      }
    }

    return changed;
  }

  render() {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.Fragment, {
      children: [this.scene.render(), this.props.options.inlineEditing && !this.isEditing && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: this.styles.inlineEditButton,
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            size: "lg",
            variant: "secondary",
            icon: "edit",
            "data-btninlineedit": this.props.id,
            onClick: this.inlineEditButtonClick
          })
        }), this.state.openInlineEdit && this.renderInlineEdit()]
      })]
    });
  }

}

_defineProperty(CanvasPanel, "contextType", _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.PanelContextRoot);

const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.stylesFactory)(theme => ({
  inlineEditButton: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    position: absolute;
    bottom: 8px;
    left: 8px;
    z-index: 999;
  `
}));

/***/ }),

/***/ "./public/app/plugins/panel/canvas/InlineEdit.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InlineEdit": () => (/* binding */ InlineEdit)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_draggable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-b1b9cefa4c/0/cache/react-draggable-npm-4.4.5-f5c4c58302-21c3775db0.zip/node_modules/react-draggable/build/cjs/cjs.js");
/* harmony import */ var react_draggable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_draggable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_resizable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/index.js");
/* harmony import */ var react_resizable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_resizable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/store.ts");
/* harmony import */ var _InlineEditBody__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/canvas/InlineEditBody.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _div, _InlineEditBody;










const OFFSET_X = 70;
const InlineEdit = ({
  onClose
}) => {
  const btnInlineEdit = document.querySelector('[data-btninlineedit]').getBoundingClientRect();
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  const inlineEditKey = 'inlineEditPanel';
  const defaultMeasurements = {
    width: 350,
    height: 400
  };
  const defaultX = btnInlineEdit.x + OFFSET_X;
  const defaultY = btnInlineEdit.y - defaultMeasurements.height;
  const savedPlacement = app_core_store__WEBPACK_IMPORTED_MODULE_5__["default"].getObject(inlineEditKey, {
    x: defaultX,
    y: defaultY,
    w: defaultMeasurements.width,
    h: defaultMeasurements.height
  });
  const [measurements, setMeasurements] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
    width: savedPlacement.w,
    height: savedPlacement.h
  });
  const [placement, setPlacement] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
    x: savedPlacement.x,
    y: savedPlacement.y
  });

  const onDragStop = (event, dragElement) => {
    let x = dragElement.x < 0 ? 0 : dragElement.x;
    let y = dragElement.y < 0 ? 0 : dragElement.y;
    setPlacement({
      x: x,
      y: y
    });
    saveToStore(x, y, measurements.width, measurements.height);
  };

  const onResizeStop = (event, data) => {
    const {
      size
    } = data;
    setMeasurements({
      width: size.width,
      height: size.height
    });
    saveToStore(placement.x, placement.y, size.width, size.height);
  };

  const saveToStore = (x, y, width, height) => {
    app_core_store__WEBPACK_IMPORTED_MODULE_5__["default"].setObject(inlineEditKey, {
      x: x,
      y: y,
      w: width,
      h: height
    });
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Portal, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
      className: styles.draggableWrapper,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)((react_draggable__WEBPACK_IMPORTED_MODULE_2___default()), {
        handle: "strong",
        onStop: onDragStop,
        position: {
          x: placement.x,
          y: placement.y
        },
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(react_resizable__WEBPACK_IMPORTED_MODULE_3__.Resizable, {
          height: measurements.height,
          width: measurements.width,
          onResize: onResizeStop,
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
            className: styles.inlineEditorContainer,
            style: {
              height: `${measurements.height}px`,
              width: `${measurements.width}px`
            },
            ref: ref,
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("strong", {
              className: styles.inlineEditorHeader,
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
                className: styles.placeholder
              }), _div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
                children: "Canvas Inline Editor"
              })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.IconButton, {
                name: "times",
                size: "xl",
                className: styles.inlineEditorClose,
                onClick: onClose
              })]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
              className: styles.inlineEditorContentWrapper,
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
                className: styles.inlineEditorContent,
                children: _InlineEditBody || (_InlineEditBody = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_InlineEditBody__WEBPACK_IMPORTED_MODULE_6__.InlineEditBody, {}))
              })
            })]
          })
        })
      })
    })
  });
};

const getStyles = theme => ({
  inlineEditorContainer: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    flex-direction: column;
    background: ${theme.v1.colors.panelBg};
    box-shadow: 5px 5px 20px -5px #000000;
    z-index: 1000;
    opacity: 1;
  `,
  draggableWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    width: 0;
    height: 0;
  `,
  inlineEditorHeader: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    align-items: center;
    justify-content: center;
    background: ${theme.colors.background.canvas};
    border: 1px solid ${theme.colors.border.weak};
    height: 40px;
    cursor: move;
  `,
  inlineEditorContent: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    white-space: pre-wrap;
    padding: 10px;
  `,
  inlineEditorClose: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-left: auto;
  `,
  placeholder: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    width: 24px;
    height: 24px;
    visibility: hidden;
    margin-right: auto;
  `,
  inlineEditorContentWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    overflow: scroll;
  `
});

/***/ }),

/***/ "./public/app/plugins/panel/canvas/InlineEditBody.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InlineEditBody": () => (/* binding */ InlineEditBody)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useObservable.js");
/* harmony import */ var app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var app_features_dashboard_components_PanelEditor_OptionsPaneCategoryDescriptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/OptionsPaneCategoryDescriptor.tsx");
/* harmony import */ var app_features_dashboard_components_PanelEditor_getVisualizationOptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/getVisualizationOptions.tsx");
/* harmony import */ var app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/utils.ts");
/* harmony import */ var _CanvasPanel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/canvas/CanvasPanel.tsx");
/* harmony import */ var _editor_elementEditor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/elementEditor.tsx");
/* harmony import */ var _editor_layerEditor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/layerEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");












const InlineEditBody = () => {
  var _activePanel$panel$co;

  const activePanel = (0,react_use__WEBPACK_IMPORTED_MODULE_10__["default"])(_CanvasPanel__WEBPACK_IMPORTED_MODULE_6__.activePanelSubject);
  const instanceState = activePanel === null || activePanel === void 0 ? void 0 : (_activePanel$panel$co = activePanel.panel.context) === null || _activePanel$panel$co === void 0 ? void 0 : _activePanel$panel$co.instanceState;
  const pane = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    const state = instanceState;

    if (!state) {
      return new app_features_dashboard_components_PanelEditor_OptionsPaneCategoryDescriptor__WEBPACK_IMPORTED_MODULE_3__.OptionsPaneCategoryDescriptor({
        id: 'root',
        title: 'root'
      });
    }

    const supplier = (builder, context) => {
      builder.addNestedOptions((0,_editor_layerEditor__WEBPACK_IMPORTED_MODULE_8__.getLayerEditor)(instanceState));
      const selection = state.selected;

      if ((selection === null || selection === void 0 ? void 0 : selection.length) === 1) {
        const element = selection[0];

        if (!(element instanceof app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_2__.FrameState)) {
          builder.addNestedOptions((0,_editor_elementEditor__WEBPACK_IMPORTED_MODULE_7__.getElementEditor)({
            category: [`Selected element (${element.options.name})`],
            element,
            scene: state.scene
          }));
        }
      }
    };

    return getOptionsPaneCategoryDescriptor({}, supplier);
  }, [instanceState]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
      children: pane.items.map(v => v.render())
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
      children: pane.categories.map(c => {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("h5", {
            children: c.props.title
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            children: c.items.map(s => s.render())
          })]
        }, c.props.id);
      })
    })]
  });
}; //  this oddly does not actually do anything, but structure is required.  I'll try to clean it up...

function getOptionsPaneCategoryDescriptor(props, supplier) {
  const context = {
    data: props.input,
    options: props.options
  };
  const root = new app_features_dashboard_components_PanelEditor_OptionsPaneCategoryDescriptor__WEBPACK_IMPORTED_MODULE_3__.OptionsPaneCategoryDescriptor({
    id: 'root',
    title: 'root'
  });

  const getOptionsPaneCategory = categoryNames => {
    if (categoryNames !== null && categoryNames !== void 0 && categoryNames.length) {
      const key = categoryNames[0];
      let sub = root.categories.find(v => v.props.id === key);

      if (!sub) {
        sub = new app_features_dashboard_components_PanelEditor_OptionsPaneCategoryDescriptor__WEBPACK_IMPORTED_MODULE_3__.OptionsPaneCategoryDescriptor({
          id: key,
          title: key
        });
        root.categories.push(sub);
      }

      return sub;
    }

    return root;
  };

  const access = {
    getValue: path => (0,lodash__WEBPACK_IMPORTED_MODULE_0__.get)(props.options, path),
    onChange: (path, value) => {
      props.onChange((0,app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_5__.setOptionImmutably)(props.options, path, value));
    }
  }; // Use the panel options loader

  (0,app_features_dashboard_components_PanelEditor_getVisualizationOptions__WEBPACK_IMPORTED_MODULE_4__.fillOptionsPaneItems)(supplier, access, getOptionsPaneCategory, context);
  return root;
}

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/APIEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "APIEditor": () => (/* binding */ APIEditor),
/* harmony export */   "callApi": () => (/* binding */ callApi)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_components_OptionsUI_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/components/OptionsUI/string.tsx");
/* harmony import */ var app_core_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/core.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _br;










const dummyStringSettings = {
  settings: {}
};
const callApi = (api, isTest = false) => {
  if (api) {
    var _api$data;

    (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.getBackendSrv)().fetch({
      url: api.endpoint,
      method: 'POST',
      data: (_api$data = api.data) !== null && _api$data !== void 0 ? _api$data : {}
    }).subscribe({
      error: error => {
        if (isTest) {
          app_core_core__WEBPACK_IMPORTED_MODULE_5__.appEvents.emit(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.AppEvents.alertError, ['Error has occurred: ', JSON.stringify(error)]);
          console.error(error);
        }
      },
      complete: () => {
        if (isTest) {
          app_core_core__WEBPACK_IMPORTED_MODULE_5__.appEvents.emit(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.AppEvents.alertSuccess, ['Test successful']);
        }
      }
    });
  }
};
const APIEditor = props => {
  var _value$data, _value$data2;

  const {
    value,
    context,
    onChange
  } = props;
  const labelWidth = 9;
  const onEndpointChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(endpoint => {
    onChange(Object.assign({}, value, {
      endpoint
    }));
  }, [onChange, value]);
  const onDataChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(data => {
    onChange(Object.assign({}, value, {
      data
    }));
  }, [onChange, value]);

  const renderJSON = data => {
    try {
      const json = JSON.parse(data);
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.JSONFormatter, {
        json: json
      });
    } catch (error) {
      if (error instanceof Error) {
        return `Invalid JSON provided: ${error.message}`;
      } else {
        return 'Invalid JSON provided';
      }
    }
  };

  const renderTestAPIButton = api => {
    if (api && api.endpoint) {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
        onClick: () => callApi(api, true),
        title: 'Test API',
        children: "Test API"
      });
    }

    return;
  };

  return _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.disableSanitizeHtml ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFieldRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, {
        label: 'Endpoint',
        labelWidth: labelWidth,
        grow: true,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(app_core_components_OptionsUI_string__WEBPACK_IMPORTED_MODULE_4__.StringValueEditor, {
          context: context,
          value: value === null || value === void 0 ? void 0 : value.endpoint,
          onChange: onEndpointChange,
          item: dummyStringSettings
        })
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFieldRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, {
        label: 'Data',
        labelWidth: labelWidth,
        grow: true,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(app_core_components_OptionsUI_string__WEBPACK_IMPORTED_MODULE_4__.StringValueEditor, {
          context: context,
          value: (_value$data = value === null || value === void 0 ? void 0 : value.data) !== null && _value$data !== void 0 ? _value$data : '{}',
          onChange: onDataChange,
          item: dummyStringSettings
        })
      })
    }), renderTestAPIButton(value), _br || (_br = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("br", {})), renderJSON((_value$data2 = value === null || value === void 0 ? void 0 : value.data) !== null && _value$data2 !== void 0 ? _value$data2 : '{}')]
  }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
    children: "Must enable disableSanitizeHtml feature flag to access"
  });
};

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/ConstraintSelectionBox.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstraintSelectionBox": () => (/* binding */ ConstraintSelectionBox)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _path;







const ConstraintSelectionBox = ({
  onVerticalConstraintChange,
  onHorizontalConstraintChange,
  currentConstraints
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles(currentConstraints));

  const onClickTopConstraint = () => {
    onVerticalConstraintChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Top);
  };

  const onClickBottomConstraint = () => {
    onVerticalConstraintChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Bottom);
  };

  const onClickVerticalCenterConstraint = () => {
    onVerticalConstraintChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Center);
  };

  const onClickLeftConstraint = () => {
    onHorizontalConstraintChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Left);
  };

  const onClickRightConstraint = () => {
    onHorizontalConstraintChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Right);
  };

  const onClickHorizontalCenterConstraint = () => {
    onHorizontalConstraintChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Center);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("svg", {
    version: "1.0",
    xmlns: "http://www.w3.org/2000/svg",
    width: "75.000000pt",
    height: "75.000000pt",
    viewBox: "0 0 228.000000 228.000000",
    preserveAspectRatio: "xMidYMid meet",
    style: {
      marginBottom: '4.8px'
    },
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      transform: "translate(0.000000,228.000000) scale(0.100000,-0.100000)",
      fill: "#000000",
      stroke: "none",
      children: [_path || (_path = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "#e5e5e5",
        d: "M198 2028 l-28 -32 0 -912 0 -912 31 -31 31 -31 915 0 915 0 29 29\n29 29 0 917 0 917 -27 29 -28 29 -920 0 -920 0 -27 -32z m1876 -17 c15 -16 16\n-98 16 -927 0 -860 -1 -909 -18 -926 -17 -17 -66 -18 -927 -18 -862 0 -910 1\n-927 18 -17 17 -18 65 -18 926 0 832 1 911 16 927 16 18 45 19 468 21 248 2\n659 2 912 0 431 -2 462 -4 478 -21z"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.topConstraint,
        height: "228",
        width: "46",
        y: "1735",
        x: "1123"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.constraintHover,
        onClick: onClickTopConstraint,
        height: "350",
        width: "300",
        y: "1680",
        x: "995",
        fill: "transparent"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.bottomConstraint,
        height: "228",
        width: "46",
        y: "210",
        x: "1123"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.constraintHover,
        onClick: onClickBottomConstraint,
        height: "350",
        width: "300",
        y: "135",
        x: "995",
        fill: "transparent"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.leftConstraint,
        height: "46",
        width: "228",
        y: "1060",
        x: "265"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.constraintHover,
        onClick: onClickLeftConstraint,
        height: "300",
        width: "350",
        y: "925",
        x: "200",
        fill: "transparent"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.rightConstraint,
        height: "46",
        width: "228",
        y: "1060",
        x: "1795"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.constraintHover,
        onClick: onClickRightConstraint,
        height: "300",
        width: "350",
        y: "925",
        x: "1730",
        fill: "transparent"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: styles.box,
        d: "M568 1669 c-17 -9 -18 -48 -18 -584 0 -558 1 -575 19 -585 27 -14\n1125 -14 1152 0 18 10 19 27 19 580 0 504 -2 570 -16 584 -14 14 -80 16 -577\n16 -363 -1 -568 -4 -579 -11z m1119 -42 c4 -5 4 -1079 0 -1084 -5 -4 -1079 -4\n-1084 0 -5 6 -4 1077 1 1085 4 7 1076 6 1083 -1z"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.verticalCenterConstraint,
        height: "456",
        width: "46",
        y: "855",
        x: "1123"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.constraintHover,
        onClick: onClickVerticalCenterConstraint,
        height: "660",
        width: "300",
        y: "750",
        x: "995",
        fill: "transparent"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.horizontalCenterConstraint,
        height: "46",
        width: "456",
        y: "1060",
        x: "918"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("rect", {
        className: styles.constraintHover,
        onClick: onClickHorizontalCenterConstraint,
        height: "300",
        width: "660",
        y: "925",
        x: "815",
        fill: "transparent"
      })]
    })
  });
};

const getStyles = currentConstraints => theme => {
  const HOVER_COLOR = '#daebf7';
  const HOVER_OPACITY = '0.6';
  const SELECTED_COLOR = '#0d99ff';
  const selectionBoxColor = theme.isDark ? '#ffffff' : '#000000';
  return {
    constraintHover: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      &:hover {
        fill: ${HOVER_COLOR};
        fill-opacity: ${HOVER_OPACITY};
      }
    `,
    topConstraint: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      ${currentConstraints.vertical === app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Top || currentConstraints.vertical === app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.TopBottom ? `width: 92pt; x: 1085; fill: ${SELECTED_COLOR};` : `fill: ${selectionBoxColor};`}
    `,
    bottomConstraint: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      ${currentConstraints.vertical === app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Bottom || currentConstraints.vertical === app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.TopBottom ? `width: 92pt; x: 1085; fill: ${SELECTED_COLOR};` : `fill: ${selectionBoxColor};`}
    `,
    leftConstraint: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      ${currentConstraints.horizontal === app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Left || currentConstraints.horizontal === app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.LeftRight ? `height: 92pt; y: 1014; fill: ${SELECTED_COLOR};` : `fill: ${selectionBoxColor};`}
    `,
    rightConstraint: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      ${currentConstraints.horizontal === app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Right || currentConstraints.horizontal === app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.LeftRight ? `height: 92pt; y: 1014; fill: ${SELECTED_COLOR};` : `fill: ${selectionBoxColor};`}
    `,
    horizontalCenterConstraint: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      ${currentConstraints.horizontal === app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Center ? `height: 92pt; y: 1014; fill: ${SELECTED_COLOR};` : `fill: ${selectionBoxColor};`}
    `,
    verticalCenterConstraint: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      ${currentConstraints.vertical === app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Center ? `width: 92pt; x: 1085; fill: ${SELECTED_COLOR};` : `fill: ${selectionBoxColor};`}
    `,
    box: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      fill: ${selectionBoxColor};
    `
  };
};

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/LayerElementListEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerElementListEditor": () => (/* binding */ LayerElementListEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_app_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/app_events.ts");
/* harmony import */ var app_core_components_Layers_AddLayerButton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/components/Layers/AddLayerButton.tsx");
/* harmony import */ var app_core_components_Layers_LayerDragDropList__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/core/components/Layers/LayerDragDropList.tsx");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/features/canvas/elements/notFound.tsx");
/* harmony import */ var app_features_canvas_runtime_element__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/features/canvas/runtime/element.tsx");
/* harmony import */ var app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var app_types_events__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/types/events.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/panel/canvas/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _div, _div2, _br;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

















class LayerElementListEditor extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "getScene", () => {
      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      return settings.layer.scene;
    });

    _defineProperty(this, "onAddItem", sel => {
      var _canvasElementRegistr;

      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      const item = (_canvasElementRegistr = app_features_canvas__WEBPACK_IMPORTED_MODULE_7__.canvasElementRegistry.getIfExists(sel.value)) !== null && _canvasElementRegistr !== void 0 ? _canvasElementRegistr : app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_8__.notFoundItem;
      const newElementOptions = item.getNewOptions();
      newElementOptions.type = item.id;
      const newElement = new app_features_canvas_runtime_element__WEBPACK_IMPORTED_MODULE_9__.ElementState(item, newElementOptions, layer);
      newElement.updateData(layer.scene.context);
      layer.elements.push(newElement);
      layer.scene.save();
      layer.reinitializeMoveable();
    });

    _defineProperty(this, "onSelect", item => {
      const {
        settings
      } = this.props.item;

      if (settings !== null && settings !== void 0 && settings.scene) {
        try {
          let selection = {
            targets: []
          };

          if (item instanceof app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_10__.FrameState) {
            const targetElements = [];
            targetElements.push(item === null || item === void 0 ? void 0 : item.div);
            selection.targets = targetElements;
            selection.frame = item;
            settings.scene.select(selection);
          } else if (item instanceof app_features_canvas_runtime_element__WEBPACK_IMPORTED_MODULE_9__.ElementState) {
            const targetElement = [item === null || item === void 0 ? void 0 : item.div];
            selection.targets = targetElement;
            settings.scene.select(selection);
          }
        } catch (error) {
          app_core_app_events__WEBPACK_IMPORTED_MODULE_4__["default"].emit(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.AppEvents.alertError, ['Unable to select element, try selecting element in panel instead']);
        }
      }
    });

    _defineProperty(this, "onClearSelection", () => {
      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      layer.scene.clearCurrentSelection();
    });

    _defineProperty(this, "onDragEnd", result => {
      if (!result.destination) {
        return;
      }

      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      const count = layer.elements.length - 1;
      const src = (result.source.index - count) * -1;
      const dst = (result.destination.index - count) * -1;
      layer.reorder(src, dst);
    });

    _defineProperty(this, "goUpLayer", () => {
      const settings = this.props.item.settings;

      if (!(settings !== null && settings !== void 0 && settings.layer) || !(settings !== null && settings !== void 0 && settings.scene)) {
        return;
      }

      const {
        scene,
        layer
      } = settings;

      if (layer.parent) {
        scene.updateCurrentLayer(layer.parent);
      }
    });

    _defineProperty(this, "decoupleFrame", () => {
      const settings = this.props.item.settings;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      this.deleteFrame();
      layer.elements.forEach(element => {
        var _element$div, _layer$parent, _layer$parent$div, _layer$parent2;

        const elementContainer = (_element$div = element.div) === null || _element$div === void 0 ? void 0 : _element$div.getBoundingClientRect();
        element.setPlacementFromConstraint(elementContainer, (_layer$parent = layer.parent) === null || _layer$parent === void 0 ? void 0 : (_layer$parent$div = _layer$parent.div) === null || _layer$parent$div === void 0 ? void 0 : _layer$parent$div.getBoundingClientRect());
        (_layer$parent2 = layer.parent) === null || _layer$parent2 === void 0 ? void 0 : _layer$parent2.doAction(_types__WEBPACK_IMPORTED_MODULE_12__.LayerActionID.Duplicate, element, false, false);
      });
    });

    _defineProperty(this, "onDecoupleFrame", () => {
      app_core_app_events__WEBPACK_IMPORTED_MODULE_4__["default"].publish(new app_types_events__WEBPACK_IMPORTED_MODULE_11__.ShowConfirmModalEvent({
        title: 'Decouple frame',
        text: `Are you sure you want to decouple this frame?`,
        text2: 'This will remove the frame and push nested elements in the next level up.',
        confirmText: 'Yes',
        yesText: 'Decouple',
        onConfirm: async () => {
          this.decoupleFrame();
        }
      }));
    });

    _defineProperty(this, "deleteFrame", () => {
      var _layer$parent3;

      const settings = this.props.item.settings;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      const scene = this.getScene();
      scene === null || scene === void 0 ? void 0 : scene.byName.delete(layer.getName());
      layer.elements.forEach(element => scene === null || scene === void 0 ? void 0 : scene.byName.delete(element.getName()));
      (_layer$parent3 = layer.parent) === null || _layer$parent3 === void 0 ? void 0 : _layer$parent3.doAction(_types__WEBPACK_IMPORTED_MODULE_12__.LayerActionID.Delete, layer);
      this.goUpLayer();
    });

    _defineProperty(this, "onFrameSelection", () => {
      const scene = this.getScene();

      if (scene) {
        scene.frameSelection();
      } else {
        console.warn('no scene!');
      }
    });

    _defineProperty(this, "onDeleteFrame", () => {
      app_core_app_events__WEBPACK_IMPORTED_MODULE_4__["default"].publish(new app_types_events__WEBPACK_IMPORTED_MODULE_11__.ShowConfirmModalEvent({
        title: 'Delete frame',
        text: `Are you sure you want to delete this frame?`,
        text2: 'This will delete the frame and all nested elements.',
        icon: 'trash-alt',
        confirmText: 'Delete',
        yesText: 'Delete',
        onConfirm: async () => {
          this.deleteFrame();
        }
      }));
    });
  }

  render() {
    const settings = this.props.item.settings;

    if (!settings) {
      return _div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)("div", {
        children: "No settings"
      }));
    }

    const layer = settings.layer;

    if (!layer) {
      return _div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)("div", {
        children: "Missing layer?"
      }));
    }

    const onDelete = element => {
      layer.doAction(_types__WEBPACK_IMPORTED_MODULE_12__.LayerActionID.Delete, element);
    };

    const onDuplicate = element => {
      layer.doAction(_types__WEBPACK_IMPORTED_MODULE_12__.LayerActionID.Duplicate, element);
    };

    const getLayerInfo = element => {
      return element.options.type;
    };

    const onNameChange = (element, name) => {
      element.onChange(Object.assign({}, element.options, {
        name
      }));
    };

    const showActions = element => {
      return !(element instanceof app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_10__.FrameState);
    };

    const verifyLayerNameUniqueness = nameToVerify => {
      const scene = this.getScene();
      return Boolean(scene === null || scene === void 0 ? void 0 : scene.canRename(nameToVerify));
    };

    const selection = settings.selected ? settings.selected.map(v => v.getName()) : [];
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.Fragment, {
      children: [!layer.isRoot() && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: "angle-up",
          size: "sm",
          variant: "secondary",
          onClick: this.goUpLayer,
          children: "Go up level"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: () => this.onSelect(layer),
          children: "Select frame"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: () => this.onDecoupleFrame(),
          children: "Decouple frame"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: () => this.onDeleteFrame(),
          children: "Delete frame"
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)(app_core_components_Layers_LayerDragDropList__WEBPACK_IMPORTED_MODULE_6__.LayerDragDropList, {
        onDragEnd: this.onDragEnd,
        onSelect: this.onSelect,
        onDelete: onDelete,
        onDuplicate: onDuplicate,
        getLayerInfo: getLayerInfo,
        onNameChange: onNameChange,
        verifyLayerNameUniqueness: verifyLayerNameUniqueness,
        showActions: showActions,
        layers: layer.elements,
        selection: selection
      }), _br || (_br = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)("br", {})), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.HorizontalGroup, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)(app_core_components_Layers_AddLayerButton__WEBPACK_IMPORTED_MODULE_5__.AddLayerButton, {
          onChange: this.onAddItem,
          options: app_features_canvas__WEBPACK_IMPORTED_MODULE_7__.canvasElementRegistry.selectOptions().options,
          label: 'Add item'
        }), selection.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: this.onClearSelection,
          children: "Clear selection"
        }), selection.length > 1 && _grafana_runtime_src__WEBPACK_IMPORTED_MODULE_2__.config.featureToggles.canvasPanelNesting && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_13__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: this.onFrameSelection,
          children: "Frame selection"
        })]
      })]
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/PlacementEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PlacementEditor": () => (/* binding */ PlacementEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useObservable.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/components/OptionsUI/NumberInput.tsx");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var _ConstraintSelectionBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/ConstraintSelectionBox.tsx");
/* harmony import */ var _QuickPositioning__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/QuickPositioning.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _div, _div2, _br, _br2;












const places = ['top', 'left', 'bottom', 'right', 'width', 'height'];
const horizontalOptions = [{
  label: 'Left',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Left
}, {
  label: 'Right',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Right
}, {
  label: 'Left and right',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.LeftRight
}, {
  label: 'Center',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Center
}, {
  label: 'Scale',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Scale
}];
const verticalOptions = [{
  label: 'Top',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Top
}, {
  label: 'Bottom',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Bottom
}, {
  label: 'Top and bottom',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.TopBottom
}, {
  label: 'Center',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Center
}, {
  label: 'Scale',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Scale
}];
const PlacementEditor = ({
  item
}) => {
  var _ref, _element$tempConstrai;

  const settings = item.settings; // Will force a rerender whenever the subject changes

  (0,react_use__WEBPACK_IMPORTED_MODULE_7__["default"])(settings !== null && settings !== void 0 && settings.scene ? settings.scene.moved : new rxjs__WEBPACK_IMPORTED_MODULE_8__.Subject());

  if (!settings) {
    return _div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      children: "Loading..."
    }));
  }

  const element = settings.element;

  if (!element) {
    return _div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      children: "???"
    }));
  }

  const {
    options
  } = element;
  const {
    placement,
    constraint: layout
  } = options;

  const reselectElementAfterChange = () => {
    setTimeout(() => {
      settings.scene.select({
        targets: [element.div]
      });
    });
  };

  const onHorizontalConstraintSelect = h => {
    onHorizontalConstraintChange(h.value);
  };

  const onHorizontalConstraintChange = h => {
    element.options.constraint.horizontal = h;
    element.setPlacementFromConstraint();
    settings.scene.revId++;
    settings.scene.save(true);
    reselectElementAfterChange();
  };

  const onVerticalConstraintSelect = v => {
    onVerticalConstraintChange(v.value);
  };

  const onVerticalConstraintChange = v => {
    element.options.constraint.vertical = v;
    element.setPlacementFromConstraint();
    settings.scene.revId++;
    settings.scene.save(true);
    reselectElementAfterChange();
  };

  const onPositionChange = (value, placement) => {
    element.options.placement[placement] = value !== null && value !== void 0 ? value : element.options.placement[placement];
    element.applyLayoutStylesToDiv();
    settings.scene.clearCurrentSelection(true);
    reselectElementAfterChange();
  };

  const constraint = (_ref = (_element$tempConstrai = element.tempConstraint) !== null && _element$tempConstrai !== void 0 ? _element$tempConstrai : layout) !== null && _ref !== void 0 ? _ref : {};
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_QuickPositioning__WEBPACK_IMPORTED_MODULE_5__.QuickPositioning, {
      onPositionChange: onPositionChange,
      settings: settings,
      element: element
    }), _br || (_br = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("br", {})), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Field, {
      label: "Constraints",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.HorizontalGroup, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_ConstraintSelectionBox__WEBPACK_IMPORTED_MODULE_4__.ConstraintSelectionBox, {
          onVerticalConstraintChange: onVerticalConstraintChange,
          onHorizontalConstraintChange: onHorizontalConstraintChange,
          currentConstraints: constraint
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.VerticalGroup, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
            options: verticalOptions,
            onChange: onVerticalConstraintSelect,
            value: constraint.vertical
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
            options: horizontalOptions,
            onChange: onHorizontalConstraintSelect,
            value: constraint.horizontal
          })]
        })]
      })
    }), _br2 || (_br2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("br", {})), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Field, {
      label: "Position",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
        children: places.map(p => {
          const v = placement[p];

          if (v == null) {
            return null;
          }

          return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineFieldRow, {
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineField, {
              label: p,
              labelWidth: 8,
              grow: true,
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(app_core_components_OptionsUI_NumberInput__WEBPACK_IMPORTED_MODULE_2__.NumberInput, {
                value: v,
                onChange: v => onPositionChange(v, p)
              })
            })
          }, p);
        })
      })
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/QuickPositioning.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QuickPositioning": () => (/* binding */ QuickPositioning)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-5255b58730/0/cache/@emotion-css-npm-11.9.0-e415e285ad-bd83d9af5c.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






const QuickPositioning = ({
  onPositionChange,
  element,
  settings
}) => {
  const styles = (0,_grafana_ui_src__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);

  const onQuickPositioningChange = position => {
    var _element$options$plac, _element$options$plac2, _element$options$plac3, _element$options$plac4, _element$options$plac5, _element$options$plac6, _element$options$plac7, _element$options$plac8;

    const defaultConstraint = {
      vertical: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Top,
      horizontal: app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Left
    };
    const originalConstraint = Object.assign({}, element.options.constraint);
    element.options.constraint = defaultConstraint;
    element.setPlacementFromConstraint();

    switch (position) {
      case app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.Top:
        onPositionChange(0, 'top');
        break;

      case app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.Bottom:
        onPositionChange(getRightBottomPosition((_element$options$plac = (_element$options$plac2 = element.options.placement) === null || _element$options$plac2 === void 0 ? void 0 : _element$options$plac2.height) !== null && _element$options$plac !== void 0 ? _element$options$plac : 0, 'bottom'), 'top');
        break;

      case app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.VerticalCenter:
        onPositionChange(getCenterPosition((_element$options$plac3 = (_element$options$plac4 = element.options.placement) === null || _element$options$plac4 === void 0 ? void 0 : _element$options$plac4.height) !== null && _element$options$plac3 !== void 0 ? _element$options$plac3 : 0, 'v'), 'top');
        break;

      case app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.Left:
        onPositionChange(0, 'left');
        break;

      case app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.Right:
        onPositionChange(getRightBottomPosition((_element$options$plac5 = (_element$options$plac6 = element.options.placement) === null || _element$options$plac6 === void 0 ? void 0 : _element$options$plac6.width) !== null && _element$options$plac5 !== void 0 ? _element$options$plac5 : 0, 'right'), 'left');
        break;

      case app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.HorizontalCenter:
        onPositionChange(getCenterPosition((_element$options$plac7 = (_element$options$plac8 = element.options.placement) === null || _element$options$plac8 === void 0 ? void 0 : _element$options$plac8.width) !== null && _element$options$plac7 !== void 0 ? _element$options$plac7 : 0, 'h'), 'left');
        break;
    }

    element.options.constraint = originalConstraint;
    element.setPlacementFromConstraint();
  }; // Basing this on scene will mean that center is based on root for the time being


  const getCenterPosition = (elementSize, align) => {
    const sceneSize = align === 'h' ? settings.scene.width : settings.scene.height;
    return (sceneSize - elementSize) / 2;
  };

  const getRightBottomPosition = (elementSize, align) => {
    const sceneSize = align === 'right' ? settings.scene.width : settings.scene.height;
    return sceneSize - elementSize;
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
    className: styles.buttonGroup,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui_src__WEBPACK_IMPORTED_MODULE_2__.IconButton, {
      name: 'horizontal-align-left',
      onClick: () => onQuickPositioningChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.Left),
      className: styles.button,
      size: 'lg',
      tooltip: 'Align left'
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui_src__WEBPACK_IMPORTED_MODULE_2__.IconButton, {
      name: 'horizontal-align-center',
      onClick: () => onQuickPositioningChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.HorizontalCenter),
      className: styles.button,
      size: 'lg',
      tooltip: 'Align horizontal centers'
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui_src__WEBPACK_IMPORTED_MODULE_2__.IconButton, {
      name: 'horizontal-align-right',
      onClick: () => onQuickPositioningChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.Right),
      className: styles.button,
      size: 'lg',
      tooltip: 'Align right'
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui_src__WEBPACK_IMPORTED_MODULE_2__.IconButton, {
      name: 'vertical-align-top',
      onClick: () => onQuickPositioningChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.Top),
      size: 'lg',
      tooltip: 'Align top'
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui_src__WEBPACK_IMPORTED_MODULE_2__.IconButton, {
      name: 'vertical-align-center',
      onClick: () => onQuickPositioningChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.VerticalCenter),
      className: styles.button,
      size: 'lg',
      tooltip: 'Align vertical centers'
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui_src__WEBPACK_IMPORTED_MODULE_2__.IconButton, {
      name: 'vertical-align-bottom',
      onClick: () => onQuickPositioningChange(app_features_canvas__WEBPACK_IMPORTED_MODULE_3__.QuickPlacement.Bottom),
      className: styles.button,
      size: 'lg',
      tooltip: 'Align bottom'
    })]
  });
};

const getStyles = theme => ({
  buttonGroup: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    flex-wrap: wrap;
    padding: 12px 0 12px 0;
  `,
  button: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-left: 5px;
    margin-right: 5px;
  `
});

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/elementEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getElementEditor": () => (/* binding */ getElementEditor)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/utils.ts");
/* harmony import */ var _PlacementEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/PlacementEditor.tsx");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/options.ts");





function getElementEditor(opts) {
  return {
    category: opts.category,
    path: '--',
    // not used!
    // Note that canvas editor writes things to the scene!
    values: parent => ({
      getValue: path => {
        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.get)(opts.element.options, path);
      },
      onChange: (path, value) => {
        let options = opts.element.options;

        if (path === 'type' && value) {
          const layer = app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.canvasElementRegistry.getIfExists(value);

          if (!layer) {
            console.warn('layer does not exist', value);
            return;
          }

          options = Object.assign({}, options, layer.getNewOptions(options), {
            type: layer.id
          });
        } else {
          options = (0,app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_2__.setOptionImmutably)(options, path, value);
        }

        opts.element.onChange(options);
        opts.element.updateData(opts.scene.context);
      }
    }),
    // Dynamically fill the selected element
    build: (builder, context) => {
      var _options$type;

      const {
        options
      } = opts.element;
      const layerTypes = app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.canvasElementRegistry.selectOptions(options !== null && options !== void 0 && options.type // the selected value
      ? [options.type] // as an array
      : [app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CANVAS_ELEMENT_CONFIG.type]);
      builder.addSelect({
        path: 'type',
        name: undefined,
        // required, but hide space
        settings: {
          options: layerTypes.options
        }
      }); // force clean layer configuration

      const layer = app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.canvasElementRegistry.getIfExists((_options$type = options === null || options === void 0 ? void 0 : options.type) !== null && _options$type !== void 0 ? _options$type : app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CANVAS_ELEMENT_CONFIG.type);
      let currentOptions = options;

      if (!currentOptions) {
        currentOptions = Object.assign({}, layer.getNewOptions(options), {
          type: layer.id,
          name: `Element ${Date.now()}.${Math.floor(Math.random() * 100)}`
        });
      }

      const ctx = Object.assign({}, context, {
        options: currentOptions
      });

      if (layer !== null && layer !== void 0 && layer.registerOptionsUI) {
        layer.registerOptionsUI(builder, ctx);
      }

      _options__WEBPACK_IMPORTED_MODULE_4__.optionBuilder.addBackground(builder, ctx);
      _options__WEBPACK_IMPORTED_MODULE_4__.optionBuilder.addBorder(builder, ctx);
      builder.addCustomEditor({
        category: ['Layout'],
        id: 'content',
        path: '__',
        // not used
        name: 'Quick placement',
        editor: _PlacementEditor__WEBPACK_IMPORTED_MODULE_3__.PlacementEditor,
        settings: opts
      });
    }
  };
}

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/layerEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLayerEditor": () => (/* binding */ getLayerEditor)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/utils.ts");
/* harmony import */ var _LayerElementListEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/LayerElementListEditor.tsx");
/* harmony import */ var _PlacementEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/PlacementEditor.tsx");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/options.ts");






function getLayerEditor(opts) {
  const {
    selected,
    scene
  } = opts;

  if (!scene.currentLayer) {
    scene.currentLayer = scene.root;
  }

  if (selected) {
    for (const element of selected) {
      if (element instanceof app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_1__.FrameState) {
        scene.currentLayer = element;
        break;
      }

      if (element.parent) {
        scene.currentLayer = element.parent;
        break;
      }
    }
  }

  const options = scene.currentLayer.options || {
    elements: []
  };
  return {
    category: ['Layer'],
    path: '--',
    // not used!
    // Note that canvas editor writes things to the scene!
    values: parent => ({
      getValue: path => {
        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.get)(options, path);
      },
      onChange: (path, value) => {
        var _scene$currentLayer, _scene$currentLayer2;

        if (path === 'type' && value) {
          console.warn('unable to change layer type');
          return;
        }

        const c = (0,app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_2__.setOptionImmutably)(options, path, value);
        (_scene$currentLayer = scene.currentLayer) === null || _scene$currentLayer === void 0 ? void 0 : _scene$currentLayer.onChange(c);
        (_scene$currentLayer2 = scene.currentLayer) === null || _scene$currentLayer2 === void 0 ? void 0 : _scene$currentLayer2.updateData(scene.context);
      }
    }),
    // Dynamically fill the selected element
    build: (builder, context) => {
      const currentLayer = scene.currentLayer;

      if (currentLayer && !currentLayer.isRoot()) {// TODO: the non-root nav option
      }

      builder.addCustomEditor({
        id: 'content',
        path: 'root',
        name: 'Elements',
        editor: _LayerElementListEditor__WEBPACK_IMPORTED_MODULE_3__.LayerElementListEditor,
        settings: {
          scene,
          layer: scene.currentLayer,
          selected
        }
      });
      const ctx = Object.assign({}, context, {
        options
      });
      _options__WEBPACK_IMPORTED_MODULE_5__.optionBuilder.addBackground(builder, ctx);
      _options__WEBPACK_IMPORTED_MODULE_5__.optionBuilder.addBorder(builder, ctx);

      if (currentLayer && !currentLayer.isRoot()) {
        builder.addCustomEditor({
          category: ['Layout'],
          id: 'content',
          path: '__',
          // not used
          name: 'Constraints',
          editor: _PlacementEditor__WEBPACK_IMPORTED_MODULE_4__.PlacementEditor,
          settings: {
            scene: opts.scene,
            element: currentLayer
          }
        });
      }
    }
  };
}

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/options.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "optionBuilder": () => (/* binding */ optionBuilder)
/* harmony export */ });
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");


const optionBuilder = {
  addBackground: (builder, context) => {
    const category = ['Background'];
    builder.addCustomEditor({
      category,
      id: 'background.color',
      path: 'background.color',
      name: 'Color',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__.ColorDimensionEditor,
      settings: {},
      defaultValue: {
        // Configured values
        fixed: ''
      }
    }).addCustomEditor({
      category,
      id: 'background.image',
      path: 'background.image',
      name: 'Image',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__.ResourceDimensionEditor,
      settings: {
        resourceType: 'image'
      }
    }).addRadio({
      category,
      path: 'background.size',
      name: 'Image size',
      settings: {
        options: [{
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Original,
          label: 'Original'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Contain,
          label: 'Contain'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Cover,
          label: 'Cover'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Fill,
          label: 'Fill'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Tile,
          label: 'Tile'
        }]
      },
      defaultValue: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Cover
    });
  },
  addBorder: (builder, context) => {
    var _context$options, _context$options$bord;

    const category = ['Border'];
    builder.addSliderInput({
      category,
      path: 'border.width',
      name: 'Width',
      defaultValue: 2,
      settings: {
        min: 0,
        max: 20
      }
    });

    if ((_context$options = context.options) !== null && _context$options !== void 0 && (_context$options$bord = _context$options.border) !== null && _context$options$bord !== void 0 && _context$options$bord.width) {
      builder.addCustomEditor({
        category,
        id: 'border.color',
        path: 'border.color',
        name: 'Color',
        editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__.ColorDimensionEditor,
        settings: {},
        defaultValue: {
          // Configured values
          fixed: ''
        }
      });
    }
  }
};

/***/ }),

/***/ "./public/app/plugins/panel/canvas/module.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "plugin": () => (/* binding */ plugin)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var _CanvasPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/canvas/CanvasPanel.tsx");
/* harmony import */ var _editor_elementEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/elementEditor.tsx");
/* harmony import */ var _editor_layerEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/layerEditor.tsx");





const plugin = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.PanelPlugin(_CanvasPanel__WEBPACK_IMPORTED_MODULE_2__.CanvasPanel).setNoPadding() // extend to panel edges
.useFieldConfig().setPanelOptions((builder, context) => {
  const state = context.instanceState;
  builder.addBooleanSwitch({
    path: 'inlineEditing',
    name: 'Inline editing',
    description: 'Enable editing the panel directly',
    defaultValue: true
  });

  if (state) {
    builder.addNestedOptions((0,_editor_layerEditor__WEBPACK_IMPORTED_MODULE_4__.getLayerEditor)(state));
    const selection = state.selected;

    if ((selection === null || selection === void 0 ? void 0 : selection.length) === 1) {
      const element = selection[0];

      if (!(element instanceof app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_1__.FrameState)) {
        builder.addNestedOptions((0,_editor_elementEditor__WEBPACK_IMPORTED_MODULE_3__.getElementEditor)({
          category: [`Selected element (${element.options.name})`],
          element,
          scene: state.scene
        }));
      }
    }
  }
});

/***/ }),

/***/ "./public/app/plugins/panel/canvas/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerActionID": () => (/* binding */ LayerActionID)
/* harmony export */ });
let LayerActionID;

(function (LayerActionID) {
  LayerActionID["Delete"] = "delete";
  LayerActionID["Duplicate"] = "duplicate";
  LayerActionID["MoveTop"] = "move-top";
  LayerActionID["MoveBottom"] = "move-bottom";
})(LayerActionID || (LayerActionID = {}));

/***/ }),

/***/ "./.yarn/__virtual__/css-styled-virtual-9ef8f05de2/0/cache/css-styled-npm-1.0.0-5104a882d5-3f2f995938.zip/node_modules/css-styled/dist/styled.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: css-styled
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-styled.git
version: 1.0.0
*/


function hash(str) {
  var hash = 5381,
      i    = str.length;

  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */
  return hash >>> 0;
}

var stringHash = hash;

function getHash(str) {
  return stringHash(str).toString(36);
}
function getShadowRoot(parentElement) {
  if (parentElement && parentElement.getRootNode) {
    var rootNode = parentElement.getRootNode();

    if (rootNode.nodeType === 11) {
      return rootNode;
    }
  }

  return;
}
function replaceStyle(className, css, options) {
  if (options.original) {
    return css;
  }

  return css.replace(/([^};{\s}][^};{]*|^\s*){/mg, function (_, selector) {
    var trimmedSelector = selector.trim();
    return (trimmedSelector ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitComma)(trimmedSelector) : [""]).map(function (subSelector) {
      var trimmedSubSelector = subSelector.trim();

      if (trimmedSubSelector.indexOf("@") === 0) {
        return trimmedSubSelector;
      } else if (trimmedSubSelector.indexOf(":global") > -1) {
        return trimmedSubSelector.replace(/\:global/g, "");
      } else if (trimmedSubSelector.indexOf(":host") > -1) {
        return "" + trimmedSubSelector.replace(/\:host/g, "." + className);
      } else if (trimmedSubSelector) {
        return "." + className + " " + trimmedSubSelector;
      } else {
        return "." + className;
      }
    }).join(", ") + " {";
  });
}
function injectStyle(className, css, options, shadowRoot) {
  var style = document.createElement("style");
  style.setAttribute("type", "text/css");
  style.setAttribute("data-styled-id", className);

  if (options.nonce) {
    style.setAttribute("nonce", options.nonce);
  }

  style.innerHTML = replaceStyle(className, css, options);
  (shadowRoot || document.head || document.body).appendChild(style);
  return style;
}

/**
 * Create an styled object that can be defined and inserted into the css.
 * @param - css styles
 */

function styled(css) {
  var injectClassName = "rCS" + getHash(css);
  var injectCount = 0;
  var injectElement;
  return {
    className: injectClassName,
    inject: function (el, options) {
      if (options === void 0) {
        options = {};
      }

      var shadowRoot = getShadowRoot(el);
      var firstMount = injectCount === 0;
      var styleElement;

      if (shadowRoot || firstMount) {
        styleElement = injectStyle(injectClassName, css, options, shadowRoot);
      }

      if (firstMount) {
        injectElement = styleElement;
      }

      if (!shadowRoot) {
        ++injectCount;
      }

      return {
        destroy: function () {
          if (shadowRoot) {
            el.removeChild(styleElement);
            styleElement = null;
          } else {
            if (injectCount > 0) {
              --injectCount;
            }

            if (injectCount === 0 && injectElement) {
              injectElement.parentNode.removeChild(injectElement);
              injectElement = null;
            }
          }
        }
      };
    }
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (styled);
//# sourceMappingURL=styled.esm.js.map


/***/ }),

/***/ "./.yarn/__virtual__/react-compat-moveable-virtual-8c7ca97ab7/0/cache/react-compat-moveable-npm-0.18.0-a400e205d6-f63b5cb9b8.zip/node_modules/react-compat-moveable/dist/moveable.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Clippable": () => (/* binding */ Clippable),
/* harmony export */   "Draggable": () => (/* binding */ Draggable),
/* harmony export */   "EdgeDraggable": () => (/* binding */ edgeDraggable),
/* harmony export */   "InitialMoveable": () => (/* binding */ InitialMoveable),
/* harmony export */   "MOVEABLE_ABLES": () => (/* binding */ MOVEABLE_ABLES),
/* harmony export */   "MOVEABLE_EVENTS": () => (/* binding */ MOVEABLE_EVENTS),
/* harmony export */   "MOVEABLE_EVENTS_MAP": () => (/* binding */ MOVEABLE_EVENTS_MAP),
/* harmony export */   "MOVEABLE_EVENTS_PROPS_MAP": () => (/* binding */ MOVEABLE_EVENTS_PROPS_MAP),
/* harmony export */   "MOVEABLE_METHODS": () => (/* binding */ MOVEABLE_METHODS),
/* harmony export */   "MOVEABLE_PROPS": () => (/* binding */ MOVEABLE_PROPS),
/* harmony export */   "MOVEABLE_PROPS_MAP": () => (/* binding */ MOVEABLE_PROPS_MAP),
/* harmony export */   "Pinchable": () => (/* binding */ Pinchable),
/* harmony export */   "Resizable": () => (/* binding */ Resizable),
/* harmony export */   "Rotatable": () => (/* binding */ Rotatable),
/* harmony export */   "Roundable": () => (/* binding */ Roundable),
/* harmony export */   "Scalable": () => (/* binding */ Scalable),
/* harmony export */   "Snappable": () => (/* binding */ Snappable),
/* harmony export */   "Warpable": () => (/* binding */ Warpable),
/* harmony export */   "default": () => (/* binding */ Moveable),
/* harmony export */   "getElementInfo": () => (/* binding */ getElementInfo),
/* harmony export */   "makeAble": () => (/* binding */ makeAble),
/* harmony export */   "makeMoveable": () => (/* binding */ makeMoveable)
/* harmony export */ });
/* harmony import */ var _egjs_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@egjs-agent-npm-2.3.0-e88ca0eec2-2506e8feff.zip/node_modules/@egjs/agent/dist/agent.esm.js");
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.7.0-2985f74485-5ffaae9194.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/* harmony import */ var _scena_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/@scena-matrix-npm-1.1.1-da964f6b3a-e96aeab712.zip/node_modules/@scena/matrix/dist/matrix.esm.js");
/* harmony import */ var css_to_mat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/css-to-mat-npm-1.0.3-8a69ed71de-a3fc98bfad.zip/node_modules/css-to-mat/dist/css-to-mat.esm.js");
/* harmony import */ var _egjs_children_differ__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/@egjs-children-differ-npm-1.0.1-37f45ddf97-087f286822.zip/node_modules/@egjs/children-differ/dist/children-differ.esm.js");
/* harmony import */ var overlap_area__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/overlap-area-npm-1.0.0-ece5a4fc6a-37d82ea4ea.zip/node_modules/overlap-area/dist/overlap-area.esm.js");
/* harmony import */ var _scena_dragscroll__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/@scena-dragscroll-npm-1.1.1-8fe60775f9-aacb335870.zip/node_modules/@scena/dragscroll/dist/dragscroll.esm.js");
/* harmony import */ var react_simple_compat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-simple-compat-npm-1.2.2-3585e7b9b0-a594292328.zip/node_modules/react-simple-compat/dist/compat.esm.js");
/* harmony import */ var gesto__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/gesto-npm-1.9.0-c7de46fb4c-4ee8631c4b.zip/node_modules/gesto/dist/gesto.esm.js");
/* harmony import */ var react_compat_css_styled__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./.yarn/cache/react-compat-css-styled-npm-1.0.8-52211d26f8-7a8e51849e.zip/node_modules/react-compat-css-styled/dist/styled.esm.js");
/*
Copyright (c) 2019 Daybrush
name: react-compat-moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/react-compat-moveable
version: 0.18.0
*/













/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.5
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$1 = function () {
  __assign$1 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$1.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign$1({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

var EventEmitter$1 = EventEmitter;

/*
Copyright (c) 2019 Daybrush
name: react-moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/react-moveable
version: 0.33.0
*/
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function makeAble(name, able) {
  var _a;

  return __assign({
    events: {},
    props: (_a = {}, _a[name] = Boolean, _a),
    name: name
  }, able);
}

function getSVGCursor(scale, degree) {
  return "data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"".concat(32 * scale, "px\" height=\"").concat(32 * scale, "px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(").concat(degree, "deg);transform-origin: 16px 16px\"></path></svg>");
}

function getCursorCSS(degree) {
  var x1 = getSVGCursor(1, degree); // const x2 = getSVGCursor(2, degree);

  var degree45 = Math.round(degree / 45) * 45 % 180;
  var defaultCursor = "ns-resize";

  if (degree45 === 135) {
    defaultCursor = "nwse-resize";
  } else if (degree45 === 45) {
    defaultCursor = "nesw-resize";
  } else if (degree45 === 90) {
    defaultCursor = "ew-resize";
  } // tslint:disable-next-line: max-line-length


  return "cursor:".concat(defaultCursor, ";cursor: url('").concat(x1, "') 16 16, ").concat(defaultCursor, ";");
}

var agent = (0,_egjs_agent__WEBPACK_IMPORTED_MODULE_1__["default"])();
var IS_WEBKIT = agent.browser.webkit;

var IS_WEBKIT605 = IS_WEBKIT && function () {
  var navi = typeof window === "undefined" ? {
    userAgent: ""
  } : window.navigator;
  var res = /applewebkit\/([^\s]+)/g.exec(navi.userAgent.toLowerCase());
  return res ? parseFloat(res[1]) < 605 : false;
}();

var PREFIX = "moveable-";
var MOVEABLE_CSS = "\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n".concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function (degree) {
  return "\n.direction[data-rotation=\"".concat(degree, "\"] {\n\t").concat(getCursorCSS(degree), "\n}\n");
}).join("\n"), "\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n").concat(IS_WEBKIT605 ? ":global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}" : "", "\n");
var NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]];
var FLOAT_POINT_NUM = 0.0001;
var TINY_NUM = 0.0000001;
var MIN_SCALE = 0.000000001;
var MAX_NUM = Math.pow(10, 10);
var MIN_NUM = -MAX_NUM;
var DIRECTIONS = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
var DIRECTION_INDEXES = {
  n: [0, 1],
  s: [2, 3],
  w: [2, 0],
  e: [1, 3],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
};
var DIRECTION_ROTATIONS = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
};
var MOVEABLE_METHODS = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate"];

function setCustomDrag(e, state, delta, isPinch, isConvert) {
  var result = state.gesto.move(delta, e.inputEvent);
  var datas = result.originalDatas || result.datas;
  var draggableDatas = datas.draggable || (datas.draggable = {});
  return __assign(__assign({}, isConvert ? convertDragDist(state, result) : result), {
    isPinch: !!isPinch,
    parentEvent: true,
    datas: draggableDatas,
    originalDatas: e.originalDatas
  });
}

var CustomGesto = /*#__PURE__*/function () {
  function CustomGesto() {
    this.prevX = 0;
    this.prevY = 0;
    this.startX = 0;
    this.startY = 0;
    this.isDrag = false;
    this.isFlag = false;
    this.datas = {
      draggable: {}
    };
  }

  var __proto = CustomGesto.prototype;

  __proto.dragStart = function (client, e) {
    this.isDrag = false;
    this.isFlag = false;
    var originalDatas = e.originalDatas;
    this.datas = originalDatas;

    if (!originalDatas.draggable) {
      originalDatas.draggable = {};
    }

    return __assign(__assign({}, this.move(client, e.inputEvent)), {
      type: "dragstart"
    });
  };

  __proto.drag = function (client, inputEvent) {
    return this.move([client[0] - this.prevX, client[1] - this.prevY], inputEvent);
  };

  __proto.move = function (delta, inputEvent) {
    var clientX;
    var clientY;

    if (!this.isFlag) {
      this.prevX = delta[0];
      this.prevY = delta[1];
      this.startX = delta[0];
      this.startY = delta[1];
      clientX = delta[0];
      clientY = delta[1];
      this.isFlag = true;
    } else {
      clientX = this.prevX + delta[0];
      clientY = this.prevY + delta[1];

      if (delta[0] || delta[1]) {
        this.isDrag = true;
      }
    }

    this.prevX = clientX;
    this.prevY = clientY;
    return {
      type: "drag",
      clientX: clientX,
      clientY: clientY,
      inputEvent: inputEvent,
      isDrag: this.isDrag,
      distX: clientX - this.startX,
      distY: clientY - this.startY,
      deltaX: delta[0],
      deltaY: delta[1],
      datas: this.datas.draggable,
      originalDatas: this.datas,
      parentEvent: true,
      parentGesto: this
    };
  };

  return CustomGesto;
}();

function fillChildEvents(moveable, name, e) {
  var datas = e.originalDatas;
  datas.groupable = datas.groupable || {};
  var groupableDatas = datas.groupable;
  groupableDatas.childDatas = groupableDatas.childDatas || [];
  var childDatas = groupableDatas.childDatas;
  return moveable.moveables.map(function (_, i) {
    childDatas[i] = childDatas[i] || {};
    childDatas[i][name] = childDatas[i][name] || {};
    return __assign(__assign({}, e), {
      datas: childDatas[i][name],
      originalDatas: childDatas[i]
    });
  });
}

function triggerChildGesto(moveable, able, type, delta, e, isConvert) {
  var isStart = !!type.match(/Start$/g);
  var isEnd = !!type.match(/End$/g);
  var isPinch = e.isPinch;
  var datas = e.datas;
  var events = fillChildEvents(moveable, able.name, e);
  var moveables = moveable.moveables;
  var childs = events.map(function (ev, i) {
    var childMoveable = moveables[i];
    var state = childMoveable.state;
    var childEvent = ev;

    if (isStart) {
      childEvent = new CustomGesto().dragStart(delta, ev);
    } else {
      if (!state.gesto) {
        state.gesto = datas.childGestos[i];
      }

      if (!state.gesto) {
        return;
      }

      childEvent = setCustomDrag(ev, state, delta, isPinch, isConvert);
    }

    var result = able[type](childMoveable, __assign(__assign({}, childEvent), {
      parentFlag: true
    }));

    if (isEnd) {
      state.gesto = null;
    }

    return result;
  });

  if (isStart) {
    datas.childGestos = moveables.map(function (child) {
      return child.state.gesto;
    });
  }

  return childs;
}

function triggerChildAbles(moveable, able, type, e, eachEvent, callback) {
  if (eachEvent === void 0) {
    eachEvent = function (_, ev) {
      return ev;
    };
  }

  var isEnd = !!type.match(/End$/g);
  var events = fillChildEvents(moveable, able.name, e);
  var moveables = moveable.moveables;
  var childs = events.map(function (ev, i) {
    var childMoveable = moveables[i];
    var childEvent = ev;
    childEvent = eachEvent(childMoveable, ev);
    var result = able[type](childMoveable, __assign(__assign({}, childEvent), {
      parentFlag: true
    }));
    result && callback && callback(childMoveable, ev, result, i);

    if (isEnd) {
      childMoveable.state.gesto = null;
    }

    return result;
  });
  return childs;
}

function renderDirectionControls(moveable, defaultDirections, React, additionalClassName) {
  if (additionalClassName === void 0) {
    additionalClassName = "";
  }

  var _a = moveable.state,
      renderPoses = _a.renderPoses,
      rotationRad = _a.rotation,
      direction = _a.direction;
  var _b = moveable.props,
      _c = _b.renderDirections,
      directions = _c === void 0 ? defaultDirections : _c,
      zoom = _b.zoom;
  var directionMap = {};

  if (!directions) {
    return [];
  }

  var sign = direction > 0 ? 1 : -1;
  var renderDirections = directions === true ? DIRECTIONS : directions;
  var degRotation = rotationRad / Math.PI * 180;
  renderDirections.forEach(function (dir) {
    directionMap[dir] = true;
  });
  return renderDirections.map(function (dir) {
    var indexes = DIRECTION_INDEXES[dir];

    if (!indexes || !directionMap[dir]) {
      return null;
    }

    var directionRotation = ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;
    return React.createElement("div", {
      className: prefix("control", "direction", dir, additionalClassName),
      "data-rotation": directionRotation,
      "data-direction": dir,
      key: "direction-".concat(dir),
      style: getControlTransform.apply(void 0, __spreadArray([rotationRad, zoom], indexes.map(function (index) {
        return renderPoses[index];
      }), false))
    });
  });
}

function renderLine(React, direction, pos1, pos2, zoom, key) {
  var classNames = [];

  for (var _i = 6; _i < arguments.length; _i++) {
    classNames[_i - 6] = arguments[_i];
  }

  var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(pos1, pos2);
  var rotation = direction ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(rad / Math.PI * 180, 15) % 180 : -1;
  return React.createElement("div", {
    key: "line".concat(key),
    className: prefix.apply(void 0, __spreadArray(["line", "direction", direction], classNames, false)),
    "data-rotation": rotation,
    "data-line-index": key,
    "data-direction": direction,
    style: getLineStyle(pos1, pos2, zoom, rad)
  });
}

function renderAllDirections(moveable, React) {
  return renderDirectionControls(moveable, DIRECTIONS, React);
}

function renderDiagonalDirections(moveable, React) {
  return renderDirectionControls(moveable, ["nw", "ne", "sw", "se"], React);
}
/**
 * @namespace Rotatable
 * @memberof Moveable
 * @description Rotatable indicates whether the target can be rotated.
 */


function setRotateStartInfo(moveable, datas, clientX, clientY, origin, rect) {
  var n = moveable.state.is3d ? 4 : 3;
  var nextOrigin = calculatePosition(moveable.state.rootMatrix, origin, n);
  var startAbsoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)([rect.left, rect.top], nextOrigin);
  datas.startAbsoluteOrigin = startAbsoluteOrigin;
  datas.prevDeg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;
  datas.defaultDeg = datas.prevDeg;
  datas.prevSnapDeg = 0;
  datas.loop = 0;
}

function getAbsoluteDist(deg, direction, datas) {
  var defaultDeg = datas.defaultDeg,
      prevDeg = datas.prevDeg;
  var normalizedPrevDeg = prevDeg % 360;
  var loop = Math.floor(prevDeg / 360);

  if (normalizedPrevDeg < 0) {
    normalizedPrevDeg += 360;
  }

  if (normalizedPrevDeg > deg && normalizedPrevDeg > 270 && deg < 90) {
    // 360 => 0
    ++loop;
  } else if (normalizedPrevDeg < deg && normalizedPrevDeg < 90 && deg > 270) {
    // 0 => 360
    --loop;
  }

  var dist = direction * (loop * 360 + deg - defaultDeg);
  datas.prevDeg = defaultDeg + dist;
  return dist;
}

function getAbsoluteDistByClient(clientX, clientY, direction, datas) {
  return getAbsoluteDist((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction, datas);
}

function getRotateInfo(moveable, moveableRect, datas, dist, startValue, isSnap) {
  var _a = moveable.props.throttleRotate,
      throttleRotate = _a === void 0 ? 0 : _a;
  var nextDist = dist;
  var prevSnapDeg = datas.prevSnapDeg;

  if (isSnap) {
    nextDist = checkSnapRotate(moveable, moveableRect, datas.origin, nextDist);
  }

  var snapRotation = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(startValue + nextDist, throttleRotate);
  var snapDeg = snapRotation - startValue;
  datas.prevSnapDeg = snapDeg;
  return [snapDeg - prevSnapDeg, nextDist, snapRotation];
}

function getRotationPositions(rotationPosition, _a, direction) {
  var pos1 = _a[0],
      pos2 = _a[1],
      pos3 = _a[2],
      pos4 = _a[3];

  if (rotationPosition === "none") {
    return;
  }

  var _b = (rotationPosition || "top").split("-"),
      dir1 = _b[0],
      dir2 = _b[1];

  var radPoses = [pos1, pos2]; // if (scale[0] < 0) {
  //     dir1 = getReversePositionX(dir1);
  //     dir2 = getReversePositionX(dir2);
  // }
  // if (scale[1] < 0) {
  //     dir1 = getReversePositionY(dir1);
  //     dir2 = getReversePositionY(dir2);
  // }

  if (dir1 === "left") {
    radPoses = [pos3, pos1];
  } else if (dir1 === "right") {
    radPoses = [pos2, pos4];
  } else if (dir1 === "bottom") {
    radPoses = [pos4, pos3];
  }

  var pos = [(radPoses[0][0] + radPoses[1][0]) / 2, (radPoses[0][1] + radPoses[1][1]) / 2];
  var rad = getRotationRad(radPoses, direction);

  if (dir2) {
    var isStart = dir2 === "top" || dir2 === "left";
    var isReverse = dir1 === "bottom" || dir1 === "left";
    pos = radPoses[isStart && !isReverse || !isStart && isReverse ? 0 : 1];
  }

  return [pos, rad];
}

function dragControlCondition(moveable, e) {
  if (e.isRequest) {
    return e.requestAble === "rotatable";
  }

  var target = e.inputEvent.target;

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(target, prefix("rotation-control"))) {
    return true;
  }

  var rotationTarget = moveable.props.rotationTarget;

  if (rotationTarget) {
    return getRefTargets(rotationTarget, true).some(function (element) {
      if (!element) {
        return false;
      }

      return target === element || target.contains(element);
    });
  }

  return false;
}

var Rotatable = {
  name: "rotatable",
  canPinch: true,
  props: {
    rotatable: Boolean,
    rotationPosition: String,
    throttleRotate: Number,
    renderDirections: Object,
    rotationTarget: Object
  },
  events: {
    onRotateStart: "rotateStart",
    onBeforeRotate: "beforeRotate",
    onRotate: "rotate",
    onRotateEnd: "rotateEnd",
    onRotateGroupStart: "rotateGroupStart",
    onBeforeRotateGroup: "beforeRotateGroup",
    onRotateGroup: "rotateGroup",
    onRotateGroupEnd: "rotateGroupEnd"
  },
  css: [".rotation {\n            position: absolute;\n            height: 40px;\n            width: 1px;\n            transform-origin: 50% 100%;\n            height: calc(40px * var(--zoom));\n            top: auto;\n            left: 0;\n            bottom: 100%;\n            will-change: transform;\n        }\n        .rotation .rotation-line {\n            display: block;\n            width: 100%;\n            height: 100%;\n            transform-origin: 50% 50%;\n        }\n        .rotation .rotation-control {\n            border-color: #4af;\n            border-color: var(--moveable-color);\n            background:#fff;\n            cursor: alias;\n        }"],
  render: function (moveable, React) {
    var _a = moveable.props,
        rotatable = _a.rotatable,
        rotationPosition = _a.rotationPosition,
        zoom = _a.zoom,
        renderDirections = _a.renderDirections;
    var _b = moveable.state,
        renderPoses = _b.renderPoses,
        direction = _b.direction;

    if (!rotatable) {
      return null;
    }

    var positions = getRotationPositions(rotationPosition, renderPoses, direction);
    var jsxs = [];

    if (positions) {
      var pos = positions[0],
          rad = positions[1];
      jsxs.push(React.createElement("div", {
        key: "rotation",
        className: prefix("rotation"),
        style: {
          // tslint:disable-next-line: max-line-length
          transform: "translate(-50%) translate(".concat(pos[0], "px, ").concat(pos[1], "px) rotate(").concat(rad, "rad)")
        }
      }, React.createElement("div", {
        className: prefix("line rotation-line"),
        style: {
          transform: "scaleX(".concat(zoom, ")")
        }
      }), React.createElement("div", {
        className: prefix("control rotation-control"),
        style: {
          transform: "translate(0.5px) scale(".concat(zoom, ")")
        }
      })));
    }

    if (renderDirections) {
      jsxs.push.apply(jsxs, renderDirectionControls(moveable, [], React));
    }

    return jsxs;
  },
  dragControlCondition: dragControlCondition,
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        parentRotate = e.parentRotate,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        isRequest = e.isRequest;
    var _a = moveable.state,
        target = _a.target,
        left = _a.left,
        top = _a.top,
        origin = _a.origin,
        beforeOrigin = _a.beforeOrigin,
        direction = _a.direction,
        beforeDirection = _a.beforeDirection,
        targetTransform = _a.targetTransform,
        moveableClientRect = _a.moveableClientRect;

    if (!isRequest && !target) {
      return false;
    }

    var rect = moveable.getRect();
    datas.rect = rect;
    datas.transform = targetTransform;
    datas.left = left;
    datas.top = top;
    datas.fixedPosition = getDirectionOffset(moveable, getOriginDirection(moveable));

    if (isRequest || isPinch || parentFlag) {
      var externalRotate = parentRotate || 0;
      datas.beforeInfo = {
        origin: rect.beforeOrigin,
        prevDeg: externalRotate,
        defaultDeg: externalRotate,
        prevSnapDeg: 0
      };
      datas.afterInfo = __assign(__assign({}, datas.beforeInfo), {
        origin: rect.origin
      });
      datas.absoluteInfo = __assign(__assign({}, datas.beforeInfo), {
        origin: rect.origin,
        startValue: externalRotate
      });
    } else {
      datas.beforeInfo = {
        origin: rect.beforeOrigin
      };
      datas.afterInfo = {
        origin: rect.origin
      };
      datas.absoluteInfo = {
        origin: rect.origin,
        startValue: rect.rotation
      };
      setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, moveableClientRect);
      setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, moveableClientRect);
      setRotateStartInfo(moveable, datas.absoluteInfo, clientX, clientY, origin, moveableClientRect);
    }

    datas.direction = direction;
    datas.beforeDirection = beforeDirection;
    datas.startValue = 0;
    datas.datas = {};
    setDefaultTransformIndex(e, "rotate");
    var params = fillParams(moveable, e, __assign(__assign({
      set: function (rotatation) {
        datas.startValue = rotatation * Math.PI / 180;
      }
    }, fillTransformStartEvent(e)), {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    }));
    var result = triggerEvent(moveable, "onRotateStart", params);
    datas.isRotate = result !== false;
    moveable.state.snapRenderInfo = {
      request: e.isRequest
    };
    return datas.isRotate ? params : false;
  },
  dragControl: function (moveable, e) {
    var _a, _b, _c;

    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        parentRotate = e.parentRotate,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        groupDelta = e.groupDelta;
    var beforeDirection = datas.beforeDirection,
        beforeInfo = datas.beforeInfo,
        afterInfo = datas.afterInfo,
        absoluteInfo = datas.absoluteInfo,
        isRotate = datas.isRotate,
        startValue = datas.startValue,
        rect = datas.rect;

    if (!isRotate) {
      return;
    }

    resolveTransformEvent(e, "rotate");
    var targetDirection = getTransformDirection(e);
    var direction = beforeDirection * targetDirection;
    var parentMoveable = moveable.props.parentMoveable;
    var beforeDelta = 0;
    var beforeDist;
    var beforeRotation;
    var delta = 0;
    var dist;
    var rotation;
    var absoluteDelta = 0;
    var absoluteDist;
    var absoluteRotation;
    var startRotation = 180 / Math.PI * startValue;
    var absoluteStartRotation = absoluteInfo.startValue;
    var isSnap = false;

    if (!parentFlag && "parentDist" in e) {
      var parentDist = e.parentDist;
      beforeDist = parentDist;
      dist = parentDist;
      absoluteDist = parentDist;
    } else if (isPinch || parentFlag) {
      beforeDist = getAbsoluteDist(parentRotate, beforeDirection, beforeInfo);
      dist = getAbsoluteDist(parentRotate, direction, afterInfo);
      absoluteDist = getAbsoluteDist(parentRotate, direction, absoluteInfo);
    } else {
      beforeDist = getAbsoluteDistByClient(clientX, clientY, beforeDirection, beforeInfo);
      dist = getAbsoluteDistByClient(clientX, clientY, direction, afterInfo);
      absoluteDist = getAbsoluteDistByClient(clientX, clientY, direction, absoluteInfo);
      isSnap = true;
    }

    beforeRotation = startRotation + beforeDist;
    rotation = startRotation + dist;
    absoluteRotation = absoluteStartRotation + absoluteDist;
    triggerEvent(moveable, "onBeforeRotate", fillParams(moveable, e, {
      beforeRotation: beforeRotation,
      rotation: rotation,
      absoluteRotation: absoluteRotation,
      setRotation: function (nextRotation) {
        dist = nextRotation - startRotation;
        beforeDist = dist;
        absoluteDist = dist;
      }
    }, true));
    _a = getRotateInfo(moveable, rect, beforeInfo, beforeDist, startRotation, isSnap), beforeDelta = _a[0], beforeDist = _a[1], beforeRotation = _a[2];
    _b = getRotateInfo(moveable, rect, afterInfo, dist, startRotation, isSnap), delta = _b[0], dist = _b[1], rotation = _b[2];
    _c = getRotateInfo(moveable, rect, absoluteInfo, absoluteDist, absoluteStartRotation, isSnap), absoluteDelta = _c[0], absoluteDist = _c[1], absoluteRotation = _c[2];

    if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {
      return;
    }

    var nextTransform = convertTransformFormat(datas, "rotate(".concat(rotation, "deg)"), "rotate(".concat(dist, "deg)"));
    var inverseDist = getRotateDist(moveable, dist, datas.fixedPosition, datas);
    var inverseDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(groupDelta || [0, 0], inverseDist), datas.prevInverseDist || [0, 0]);
    datas.prevInverseDist = inverseDist;
    datas.requestValue = null;
    var params = fillParams(moveable, e, __assign({
      delta: delta,
      dist: dist,
      rotate: rotation,
      rotation: rotation,
      beforeDist: beforeDist,
      beforeDelta: beforeDelta,
      beforeRotate: beforeRotation,
      beforeRotation: beforeRotation,
      absoluteDist: absoluteDist,
      absoluteDelta: absoluteDelta,
      absoluteRotate: absoluteRotation,
      absoluteRotation: absoluteRotation,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));
    triggerEvent(moveable, "onRotate", params);
    return params;
  },
  dragControlAfter: function (moveable, e) {
    e.datas.requestValue;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    datas.isRotate = false;
    var params = fillEndParams(moveable, e, {});
    triggerEvent(moveable, "onRotateEnd", params);
    return params;
  },
  dragGroupControlCondition: dragControlCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var _a = moveable.state,
        parentLeft = _a.left,
        parentTop = _a.top,
        parentBeforeOrigin = _a.beforeOrigin;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    params.set(datas.beforeDirection * moveable.rotation);
    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      var _a = child.state,
          left = _a.left,
          top = _a.top,
          beforeOrigin = _a.beforeOrigin;
      var childClient = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([left, top], [parentLeft, parentTop]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(beforeOrigin, parentBeforeOrigin));
      ev.datas.groupClient = childClient;
      return __assign(__assign({}, ev), {
        parentRotate: 0
      });
    });

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onRotateGroupStart", nextParams);
    datas.isRotate = result !== false;
    return datas.isRotate ? params : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    catchEvent(moveable, "onBeforeRotate", function (parentEvent) {
      triggerEvent(moveable, "onBeforeRotateGroup", fillParams(moveable, e, __assign(__assign({}, parentEvent), {
        targets: moveable.props.targets
      }), true));
    });
    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var direction = datas.beforeDirection;
    var parentRotate = params.beforeDist;
    var deg = params.beforeDelta;
    var rad = deg / 180 * Math.PI;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = ev.datas.groupClient,
          prevX = _a[0],
          prevY = _a[1];

      var _b = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)([prevX, prevY], rad * direction),
          clientX = _b[0],
          clientY = _b[1];

      var delta = [clientX - prevX, clientY - prevY];
      ev.datas.groupClient = [clientX, clientY];
      return __assign(__assign({}, ev), {
        parentRotate: parentRotate,
        groupDelta: delta
      });
    });
    moveable.rotation = direction * params.beforeRotation;

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events,
      set: function (rotation) {
        moveable.rotation = rotation;
      },
      setGroupRotation: function (rotation) {
        moveable.rotation = rotation;
      }
    }, params);

    triggerEvent(moveable, "onRotateGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onRotateGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Rotatable#request
   * @param {object} [e] - the Resizable's request parameter
   * @param {number} [e.deltaRotate=0] -  delta number of rotation
   * @param {number} [e.rotate=0] - absolute number of moveable's rotation
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("rotatable", { deltaRotate: 10 }, true);
   *
   * * moveable.request("rotatable", { rotate: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("rotatable");
   *
   * // request
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   *
   * requester.request({ rotate: 10 });
   * requester.request({ rotate: 20 });
   * requester.request({ rotate: 30 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var distRotate = 0;
    var startRotation = moveable.getRotation();
    return {
      isControl: true,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("deltaRotate" in e) {
          distRotate += e.deltaRotate;
        } else if ("rotate" in e) {
          distRotate = e.rotate - startRotation;
        }

        return {
          datas: datas,
          parentDist: distRotate
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can be rotated. (default: false)
 * @name Moveable.Rotatable#rotatable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.rotatable = true;
 */

/**
 * You can specify the position of the rotation. (default: "top")
 * @name Moveable.Rotatable#rotationPosition
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   rotationPosition: "top",
 * });
 *
 * moveable.rotationPosition = "bottom"
 */

/**
 * throttle of angle(degree) when rotate.
 * @name Moveable.Rotatable#throttleRotate
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleRotate = 1;
 */

/**
 * When the rotate starts, the rotateStart event is called.
 * @memberof Moveable.Rotatable
 * @event rotateStart
 * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { rotatable: true });
 * moveable.on("rotateStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
* When rotating, the rotate event is called.
* @memberof Moveable.Rotatable
* @event rotate
* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, { rotatable: true });
* moveable.on("rotate", ({ target, transform, dist }) => {
*     target.style.transform = transform;
* });
*/

/**
 * When the rotate finishes, the rotateEnd event is called.
 * @memberof Moveable.Rotatable
 * @event rotateEnd
 * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { rotatable: true });
 * moveable.on("rotateEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
 * When the group rotate starts, the `rotateGroupStart` event is called.
 * @memberof Moveable.Rotatable
 * @event rotateGroupStart
 * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     rotatable: true
 * });
 * moveable.on("rotateGroupStart", ({ targets }) => {
 *     console.log("onRotateGroupStart", targets);
 * });
 */

/**
* When the group rotate, the `rotateGroup` event is called.
* @memberof Moveable.Rotatable
* @event rotateGroup
* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     rotatable: true
* });
* moveable.on("rotateGroup", ({ targets, events }) => {
*     console.log("onRotateGroup", targets);
*     events.forEach(ev => {
*         const target = ev.target;
*         // ev.drag is a drag event that occurs when the group rotate.
*         const left = ev.drag.beforeDist[0];
*         const top = ev.drag.beforeDist[1];
*         const deg = ev.beforeDist;
*     });
* });
*/

/**
 * When the group rotate finishes, the `rotateGroupEnd` event is called.
 * @memberof Moveable.Rotatable
 * @event rotateGroupEnd
 * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     rotatable: true
 * });
 * moveable.on("rotateGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onRotateGroupEnd", targets, isDrag);
 * });
 */

var VERTICAL_NAMES = ["left", "right", "center"];
var HORIZONTAL_NAMES = ["top", "bottom", "middle"];
var VERTICAL_NAMES_MAP = {
  start: "left",
  end: "right",
  center: "center"
};
var HORIZONTAL_NAMES_MAP = {
  start: "top",
  end: "bottom",
  center: "middle"
};

function hasGuidelines(moveable, ableName) {
  var _a = moveable.props,
      snappable = _a.snappable,
      bounds = _a.bounds,
      innerBounds = _a.innerBounds,
      verticalGuidelines = _a.verticalGuidelines,
      horizontalGuidelines = _a.horizontalGuidelines,
      snapGridWidth = _a.snapGridWidth,
      snapGridHeight = _a.snapGridHeight,
      _b = moveable.state,
      guidelines = _b.guidelines,
      enableSnap = _b.enableSnap;

  if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) < 0) {
    return false;
  }

  if (snapGridWidth || snapGridHeight || bounds || innerBounds || guidelines && guidelines.length || verticalGuidelines && verticalGuidelines.length || horizontalGuidelines && horizontalGuidelines.length) {
    return true;
  }

  return false;
}

function getSnapDirections(snapDirections) {
  if (snapDirections === false) {
    return {};
  } else if (snapDirections === true || !snapDirections) {
    return {
      left: true,
      right: true,
      top: true,
      bottom: true
    };
  }

  return snapDirections;
}

function mapSnapDirectionPoses(snapDirections, snapPoses) {
  var nextSnapDirections = getSnapDirections(snapDirections);
  var nextSnapPoses = {};

  for (var name in nextSnapDirections) {
    if (name in snapPoses && nextSnapDirections[name]) {
      nextSnapPoses[name] = snapPoses[name];
    }
  }

  return nextSnapPoses;
}

function splitSnapDirectionPoses(snapDirections, snapPoses) {
  var nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);
  var horizontalNames = HORIZONTAL_NAMES.filter(function (name) {
    return name in nextSnapPoses;
  });
  var verticalNames = VERTICAL_NAMES.filter(function (name) {
    return name in nextSnapPoses;
  });
  return {
    horizontal: horizontalNames.map(function (name) {
      return nextSnapPoses[name];
    }),
    vertical: verticalNames.map(function (name) {
      return nextSnapPoses[name];
    })
  };
}

function getGapGuidelines(moveable, targetRect, snapThreshold) {
  var elementRects = moveable.state.elementRects;
  var gapGuidelines = [];
  [["vertical", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], ["horizontal", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function (_a) {
    var type = _a[0],
        mainNames = _a[1],
        sideNames = _a[2];
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    var targetCenter = targetRect[mainNames.center];
    var targetStart2 = targetRect[sideNames.start];
    var targetEnd2 = targetRect[sideNames.end]; // element : moveable

    function getDist(elementRect) {
      var rect = elementRect.rect;

      if (rect[mainNames.end] < targetStart + snapThreshold) {
        return targetStart - rect[mainNames.end];
      } else if (targetEnd - snapThreshold < rect[mainNames.start]) {
        return rect[mainNames.start] - targetEnd;
      } else {
        return -1;
      }
    }

    var nextElementRects = elementRects.filter(function (elementRect) {
      var rect = elementRect.rect;

      if (rect[sideNames.start] > targetEnd2 || rect[sideNames.end] < targetStart2) {
        return false;
      }

      return getDist(elementRect) > 0;
    }).sort(function (a, b) {
      return getDist(a) - getDist(b);
    });
    var groups = [];
    nextElementRects.forEach(function (snapRect1) {
      nextElementRects.forEach(function (snapRect2) {
        if (snapRect1 === snapRect2) {
          return;
        }

        var rect1 = snapRect1.rect;
        var rect2 = snapRect2.rect;
        var rect1Start = rect1[sideNames.start];
        var rect1End = rect1[sideNames.end];
        var rect2Start = rect2[sideNames.start];
        var rect2End = rect2[sideNames.end];

        if (rect1Start > rect2End || rect2Start > rect1End) {
          return;
        }

        groups.push([snapRect1, snapRect2]);
      });
    });
    groups.forEach(function (_a) {
      var snapRect1 = _a[0],
          snapRect2 = _a[1];
      var rect1 = snapRect1.rect;
      var rect2 = snapRect2.rect;
      var rect1Start = rect1[mainNames.start];
      var rect1End = rect1[mainNames.end];
      var rect2Start = rect2[mainNames.start];
      var rect2End = rect2[mainNames.end];
      var gap = 0;
      var pos = 0;
      var isStart = false;
      var isCenter = false;
      var isEnd = false;

      if (rect1End <= targetStart && targetEnd <= rect2Start) {
        // (l)element1(r) : (l)target(r) : (l)element2(r)
        isCenter = true;
        gap = (rect2Start - rect1End - (targetEnd - targetStart)) / 2;
        pos = rect1End + gap + (targetEnd - targetStart) / 2;

        if (Math.abs(pos - targetCenter) > snapThreshold) {
          return;
        }
      } else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {
        // (l)element1(r) : (l)element2(r) : (l)target
        isStart = true;
        gap = rect2Start - rect1End;
        pos = rect2End + gap;

        if (Math.abs(pos - targetStart) > snapThreshold) {
          return;
        }
      } else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {
        // target(r) : (l)element1(r) : (l)element2(r)
        isEnd = true;
        gap = rect2Start - rect1End;
        pos = rect1Start - gap;

        if (Math.abs(pos - targetEnd) > snapThreshold) {
          return;
        }
      } else {
        return;
      }

      if (!gap) {
        return;
      }

      gapGuidelines.push({
        type: type,
        pos: type === "vertical" ? [pos, 0] : [0, pos],
        element: snapRect2.element,
        size: 0,
        className: snapRect2.className,
        isStart: isStart,
        isCenter: isCenter,
        isEnd: isEnd,
        gap: gap,
        hide: true,
        gapRects: [snapRect1, snapRect2]
      });
    });
  });
  return gapGuidelines;
}

function getDefaultGuidelines(horizontalGuidelines, verticalGuidelines, width, height, clientLeft, clientTop, snapOffset) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }

  if (clientTop === void 0) {
    clientTop = 0;
  }

  if (snapOffset === void 0) {
    snapOffset = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }

  var guidelines = [];
  var snapOffsetLeft = snapOffset.left,
      snapOffsetTop = snapOffset.top,
      snapOffsetBottom = snapOffset.bottom,
      snapOffsetRight = snapOffset.right;
  var snapWidth = width + snapOffsetRight - snapOffsetLeft;
  var snapHeight = height + snapOffsetBottom - snapOffsetTop;
  horizontalGuidelines && horizontalGuidelines.forEach(function (pos) {
    guidelines.push({
      type: "horizontal",
      pos: [snapOffsetLeft, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(pos - clientTop + snapOffsetTop, 0.1)],
      size: snapWidth
    });
  });
  verticalGuidelines && verticalGuidelines.forEach(function (pos) {
    guidelines.push({
      type: "vertical",
      pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(pos - clientLeft + snapOffsetLeft, 0.1), snapOffsetTop],
      size: snapHeight
    });
  });
  return guidelines;
}

function calculateContainerPos(rootMatrix, containerRect, n) {
  var clientPos = calculatePosition(rootMatrix, [containerRect.clientLeft, containerRect.clientTop], n);
  return [containerRect.left + clientPos[0], containerRect.top + clientPos[1]];
}

function getSnapElementRects(moveable, values) {
  if (!values.length) {
    return [];
  }

  var state = moveable.state;
  var containerClientRect = state.containerClientRect,
      _a = state.targetClientRect,
      clientTop = _a.top,
      clientLeft = _a.left,
      rootMatrix = state.rootMatrix,
      is3d = state.is3d;
  var n = is3d ? 4 : 3;

  var _b = calculateContainerPos(rootMatrix, containerClientRect, n),
      containerLeft = _b[0],
      containerTop = _b[1];

  var poses = getAbsolutePosesByState(state);

  var _c = (0,overlap_area__WEBPACK_IMPORTED_MODULE_3__.getMinMaxs)(poses),
      targetLeft = _c.minX,
      targetTop = _c.minY;

  var _d = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([targetLeft, targetTop], calculateInversePosition(rootMatrix, [clientLeft - containerLeft, clientTop - containerTop], n)).map(function (pos) {
    return roundSign(pos);
  }),
      distLeft = _d[0],
      distTop = _d[1];

  return values.map(function (value) {
    var rect = value.element.getBoundingClientRect();
    var left = rect.left - containerLeft;
    var top = rect.top - containerTop;
    var bottom = top + rect.height;
    var right = left + rect.width;

    var _a = calculateInversePosition(rootMatrix, [left, top], n),
        elementLeft = _a[0],
        elementTop = _a[1];

    var _b = calculateInversePosition(rootMatrix, [right, bottom], n),
        elementRight = _b[0],
        elementBottom = _b[1];

    return __assign(__assign({}, value), {
      rect: {
        left: elementLeft + distLeft,
        right: elementRight + distLeft,
        top: elementTop + distTop,
        bottom: elementBottom + distTop,
        center: (elementLeft + elementRight) / 2 + distLeft,
        middle: (elementTop + elementBottom) / 2 + distTop
      }
    });
  });
}

function getElementGuidelines(moveable) {
  var state = moveable.state;
  var _a = moveable.props.elementGuidelines,
      elementGuidelines = _a === void 0 ? [] : _a;

  if (!elementGuidelines.length) {
    state.elementRects = [];
    return [];
  }

  var prevValues = (state.elementRects || []).filter(function (snapRect) {
    return !snapRect.refresh;
  });
  var nextElementGuidelines = elementGuidelines.map(function (el) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(el) && "element" in el) {
      return el;
    }

    return {
      element: getRefTarget(el, true)
    };
  }).filter(function (value) {
    return value.element;
  });

  var _b = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_4__.diff)(prevValues.map(function (v) {
    return v.element;
  }), nextElementGuidelines.map(function (v) {
    return v.element;
  })),
      maintained = _b.maintained,
      added = _b.added;

  var nextValues = [];
  maintained.forEach(function (_a) {
    var prevIndex = _a[0],
        nextIndex = _a[1];
    nextValues[nextIndex] = prevValues[prevIndex];
  });
  getSnapElementRects(moveable, added.map(function (index) {
    return nextElementGuidelines[index];
  })).map(function (rect, i) {
    nextValues[added[i]] = rect;
  });
  state.elementRects = nextValues;
  var elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);
  var nextGuidelines = [];
  nextValues.forEach(function (snapRect) {
    var element = snapRect.element,
        _a = snapRect.top,
        topValue = _a === void 0 ? elementSnapDirections.top : _a,
        _b = snapRect.left,
        leftValue = _b === void 0 ? elementSnapDirections.left : _b,
        _c = snapRect.right,
        rightValue = _c === void 0 ? elementSnapDirections.right : _c,
        _d = snapRect.bottom,
        bottomValue = _d === void 0 ? elementSnapDirections.bottom : _d,
        _e = snapRect.center,
        centerValue = _e === void 0 ? elementSnapDirections.center : _e,
        _f = snapRect.middle,
        middleValue = _f === void 0 ? elementSnapDirections.middle : _f,
        className = snapRect.className,
        rect = snapRect.rect;

    var _g = splitSnapDirectionPoses({
      top: topValue,
      right: rightValue,
      left: leftValue,
      bottom: bottomValue,
      center: centerValue,
      middle: middleValue
    }, rect),
        horizontal = _g.horizontal,
        vertical = _g.vertical;

    var rectTop = rect.top;
    var rectLeft = rect.left;
    var width = rect.right - rectLeft;
    var height = rect.bottom - rectTop;
    var sizes = [width, height];
    vertical.forEach(function (pos) {
      nextGuidelines.push({
        type: "vertical",
        element: element,
        pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(pos, 0.1), rectTop],
        size: height,
        sizes: sizes,
        className: className,
        elementRect: snapRect
      });
    });
    horizontal.forEach(function (pos) {
      nextGuidelines.push({
        type: "horizontal",
        element: element,
        pos: [rectLeft, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(pos, 0.1)],
        size: width,
        sizes: sizes,
        className: className,
        elementRect: snapRect
      });
    });
  });
  return nextGuidelines;
}

function getTotalGuidelines(moveable) {
  var _a = moveable.state,
      snapOffset = _a.snapOffset,
      _b = _a.containerClientRect,
      overflow = _b.overflow,
      containerHeight = _b.scrollHeight,
      containerWidth = _b.scrollWidth,
      containerClientHeight = _b.clientHeight,
      containerClientWidth = _b.clientWidth,
      clientLeft = _b.clientLeft,
      clientTop = _b.clientTop;
  var _c = moveable.props,
      _d = _c.snapGap,
      snapGap = _d === void 0 ? true : _d,
      verticalGuidelines = _c.verticalGuidelines,
      horizontalGuidelines = _c.horizontalGuidelines,
      _e = _c.snapThreshold,
      snapThreshold = _e === void 0 ? 5 : _e,
      _f = _c.snapGridWidth,
      snapGridWidth = _f === void 0 ? 0 : _f,
      _g = _c.snapGridHeight,
      snapGridHeight = _g === void 0 ? 0 : _g;
  var elementGuidelines = getElementGuidelines(moveable);

  var totalGuidelines = __spreadArray([], elementGuidelines, true);

  if (snapGap) {
    var _h = getRect(getAbsolutePosesByState(moveable.state)),
        top = _h.top,
        left = _h.left,
        bottom = _h.bottom,
        right = _h.right;

    totalGuidelines.push.apply(totalGuidelines, getGapGuidelines(moveable, {
      top: top,
      left: left,
      bottom: bottom,
      right: right,
      center: (left + right) / 2,
      middle: (top + bottom) / 2
    }, snapThreshold));
  }

  totalGuidelines.push.apply(totalGuidelines, getGridGuidelines(snapGridWidth, snapGridHeight, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop));
  totalGuidelines.push.apply(totalGuidelines, getDefaultGuidelines(horizontalGuidelines || false, verticalGuidelines || false, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset));
  return totalGuidelines;
}

function getGridGuidelines(snapGridWidth, snapGridHeight, containerWidth, containerHeight, clientLeft, clientTop) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }

  if (clientTop === void 0) {
    clientTop = 0;
  }

  var guidelines = [];

  if (snapGridHeight) {
    for (var pos = 0; pos <= containerHeight; pos += snapGridHeight) {
      guidelines.push({
        type: "horizontal",
        pos: [0, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(pos - clientTop, 0.1)],
        size: containerWidth,
        hide: true
      });
    }
  }

  if (snapGridWidth) {
    for (var pos = 0; pos <= containerWidth; pos += snapGridWidth) {
      guidelines.push({
        type: "vertical",
        pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(pos - clientLeft, 0.1), 0],
        size: containerHeight,
        hide: true
      });
    }
  }

  return guidelines;
}

function solveLineConstants(_a) {
  var point1 = _a[0],
      point2 = _a[1];
  var dx = point2[0] - point1[0];
  var dy = point2[1] - point1[1];

  if (Math.abs(dx) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM) {
    dy = 0;
  } // b > 0
  // ax + by + c = 0


  var a = 0;
  var b = 0;
  var c = 0;

  if (!dx) {
    // -x + 1 = 0
    a = -1;
    c = point1[0];
  } else if (!dy) {
    // y - 1 = 0
    b = 1;
    c = -point1[1];
  } else {
    // y = -a(x - x1) + y1
    // ax + y + a * x1 - y1 = 0
    a = -dy / dx;
    b = 1;
    c = a * point1[0] - point1[1];
  }

  return [a, b, c].map(function (v) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(v, _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM);
  });
}

function checkMoveableSnapPoses(moveable, posesX, posesY, customSnapThreshold) {
  var props = moveable.props;
  var snapThreshold = selectValue(customSnapThreshold, props.snapThreshold, 5);
  return checkSnapPoses(moveable.state.guidelines, posesX, posesY, snapThreshold);
}

function checkSnapPoses(guidelines, posesX, posesY, snapThreshold) {
  return {
    vertical: checkSnap(guidelines, "vertical", posesX, snapThreshold),
    horizontal: checkSnap(guidelines, "horizontal", posesY, snapThreshold)
  };
}

function checkSnapKeepRatio(moveable, startPos, endPos) {
  var endX = endPos[0],
      endY = endPos[1];
  var startX = startPos[0],
      startY = startPos[1];

  var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(endPos, startPos),
      dx = _a[0],
      dy = _a[1];

  var isBottom = dy > 0;
  var isRight = dx > 0;
  dx = getTinyDist(dx);
  dy = getTinyDist(dy);
  var verticalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };

  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  }

  var _b = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []),
      verticalSnapInfo = _b.vertical,
      horizontalSnapInfo = _b.horizontal;

  verticalSnapInfo.posInfos.filter(function (_a) {
    var pos = _a.pos;
    return isRight ? pos >= startX : pos <= startX;
  });
  horizontalSnapInfo.posInfos.filter(function (_a) {
    var pos = _a.pos;
    return isBottom ? pos >= startY : pos <= startY;
  });
  verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;
  horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;

  var _c = getNearestSnapGuidelineInfo(verticalSnapInfo),
      isVerticalSnap = _c.isSnap,
      verticalGuideline = _c.guideline;

  var _d = getNearestSnapGuidelineInfo(horizontalSnapInfo),
      isHorizontalSnap = _d.isSnap,
      horizontalGuideline = _d.guideline;

  var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;
  var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;

  if (dx === 0) {
    if (isHorizontalSnap) {
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = horizontalGuideline.pos[1];
      horizontalInfo.offset = endY - horizontalInfo.pos;
    }
  } else if (dy === 0) {
    if (isVerticalSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = verticalPos;
      verticalInfo.offset = endX - verticalPos;
    }
  } else {
    // y - y1 = a * (x - x1)
    var a = dy / dx;
    var b = endPos[1] - a * endX;
    var y = 0;
    var x = 0;
    var isSnap = false;

    if (isVerticalSnap) {
      x = verticalPos;
      y = a * x + b;
      isSnap = true;
    } else if (isHorizontalSnap) {
      y = horizontalPos;
      x = (y - b) / a;
      isSnap = true;
    }

    if (isSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = x;
      verticalInfo.offset = endX - x;
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = y;
      horizontalInfo.offset = endY - y;
    }
  }

  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}

function checkSnaps(moveable, rect, customSnapThreshold) {
  var poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);
  return checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal, customSnapThreshold);
}

function getNearestSnapGuidelineInfo(snapInfo) {
  var isSnap = snapInfo.isSnap;

  if (!isSnap) {
    return {
      isSnap: false,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  }

  var posInfo = snapInfo.posInfos[0];
  var guidelineInfo = posInfo.guidelineInfos[0];
  var offset = guidelineInfo.offset;
  var dist = guidelineInfo.dist;
  var guideline = guidelineInfo.guideline;
  return {
    isSnap: isSnap,
    offset: offset,
    dist: dist,
    pos: posInfo.pos,
    guideline: guideline
  };
}

function checkSnap(guidelines, targetType, targetPoses, snapThreshold) {
  if (!guidelines || !guidelines.length) {
    return {
      isSnap: false,
      index: -1,
      posInfos: []
    };
  }

  var isVertical = targetType === "vertical";
  var posType = isVertical ? 0 : 1;
  var snapPosInfos = targetPoses.map(function (targetPos, index) {
    var guidelineInfos = guidelines.map(function (guideline) {
      var pos = guideline.pos;
      var offset = targetPos - pos[posType];
      return {
        offset: offset,
        dist: Math.abs(offset),
        guideline: guideline
      };
    }).filter(function (_a) {
      var guideline = _a.guideline,
          dist = _a.dist;
      var type = guideline.type;

      if (type !== targetType || dist > snapThreshold) {
        return false;
      }

      return true;
    }).sort(function (a, b) {
      return a.dist - b.dist;
    });
    return {
      pos: targetPos,
      index: index,
      guidelineInfos: guidelineInfos
    };
  }).filter(function (snapPosInfo) {
    return snapPosInfo.guidelineInfos.length > 0;
  }).sort(function (a, b) {
    return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;
  });
  var isSnap = snapPosInfos.length > 0;
  return {
    isSnap: isSnap,
    index: isSnap ? snapPosInfos[0].index : -1,
    posInfos: snapPosInfos
  };
}

function getSnapInfosByDirection(moveable, poses, snapDirection) {
  var nextPoses = [];

  if (snapDirection[0] && snapDirection[1]) {
    nextPoses = [snapDirection, [-snapDirection[0], snapDirection[1]], [snapDirection[0], -snapDirection[1]]].map(function (direction) {
      return getPosByDirection(poses, direction);
    });
  } else if (!snapDirection[0] && !snapDirection[1]) {
    var alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];

    for (var i = 0; i < 4; ++i) {
      nextPoses.push(alignPoses[i]);
      nextPoses.push([(alignPoses[i][0] + alignPoses[i + 1][0]) / 2, (alignPoses[i][1] + alignPoses[i + 1][1]) / 2]);
    }
  } else {
    if (moveable.props.keepRatio) {
      nextPoses = [[-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection].map(function (dir) {
        return getPosByDirection(poses, dir);
      });
    } else {
      nextPoses = getPosesByDirection(poses, snapDirection);

      if (nextPoses.length > 1) {
        nextPoses.push([(nextPoses[0][0] + nextPoses[1][0]) / 2, (nextPoses[0][1] + nextPoses[1][1]) / 2]);
      }
    }
  }

  return checkMoveableSnapPoses(moveable, nextPoses.map(function (pos) {
    return pos[0];
  }), nextPoses.map(function (pos) {
    return pos[1];
  }), 1);
}

function checkSnapBoundPriority(a, b) {
  var aDist = Math.abs(a.offset);
  var bDist = Math.abs(b.offset);

  if (a.isBound && b.isBound) {
    return bDist - aDist;
  } else if (a.isBound) {
    return -1;
  } else if (b.isBound) {
    return 1;
  } else if (a.isSnap && b.isSnap) {
    return bDist - aDist;
  } else if (a.isSnap) {
    return -1;
  } else if (b.isSnap) {
    return 1;
  } else if (aDist < TINY_NUM) {
    return 1;
  } else if (bDist < TINY_NUM) {
    return -1;
  }

  return aDist - bDist;
}

function getNearOffsetInfo(offsets, index) {
  return offsets.slice().sort(function (a, b) {
    var aSign = a.sign[index];
    var bSign = b.sign[index];
    var aOffset = a.offset[index];
    var bOffset = b.offset[index]; // -1 The positions of a and b do not change.
    // 1 The positions of a and b are reversed.

    if (!aSign) {
      return 1;
    } else if (!bSign) {
      return -1;
    }

    return checkSnapBoundPriority({
      isBound: a.isBound,
      isSnap: a.isSnap,
      offset: aOffset
    }, {
      isBound: b.isBound,
      isSnap: b.isSnap,
      offset: bOffset
    });
  })[0];
}

function getCheckSnapDirections(direction, fixedDirection, keepRatio) {
  var directions = []; // const fixedDirection = [-direction[0], -direction[1]];

  if (keepRatio) {
    if (Math.abs(fixedDirection[0]) !== 1 || Math.abs(fixedDirection[1]) !== 1) {
      directions.push([fixedDirection, [-1, -1]], [fixedDirection, [-1, 1]], [fixedDirection, [1, -1]], [fixedDirection, [1, 1]]);
    } else {
      directions.push([fixedDirection, [direction[0], -direction[1]]], [fixedDirection, [-direction[0], direction[1]]]);
    }

    directions.push([fixedDirection, direction]);
  } else {
    if (direction[0] && direction[1] || !direction[0] && !direction[1]) {
      var endDirection_1 = direction[0] ? direction : [1, 1];
      [1, -1].forEach(function (signX) {
        [1, -1].forEach(function (signY) {
          var nextDirection = [signX * endDirection_1[0], signY * endDirection_1[1]];

          if (fixedDirection[0] === nextDirection[0] && fixedDirection[1] === nextDirection[1]) {
            return;
          }

          directions.push([fixedDirection, nextDirection]);
        });
      });
    } else if (direction[0]) {
      var signs = Math.abs(fixedDirection[0]) === 1 ? [1] : [1, -1];
      signs.forEach(function (sign) {
        directions.push([[fixedDirection[0], -1], [sign * direction[0], -1]], [[fixedDirection[0], 0], [sign * direction[0], 0]], [[fixedDirection[0], 1], [sign * direction[0], 1]]);
      });
    } else if (direction[1]) {
      var signs = Math.abs(fixedDirection[1]) === 1 ? [1] : [1, -1];
      signs.forEach(function (sign) {
        directions.push([[-1, fixedDirection[1]], [-1, sign * direction[1]]], [[0, fixedDirection[1]], [0, sign * direction[1]]], [[1, fixedDirection[1]], [1, sign * direction[1]]]);
      });
    }
  }

  return directions;
}

function isStartLine(dot, line) {
  // l    o     => true
  // o    l    => false
  var cx = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.average)([line[0][0], line[1][0]]);
  var cy = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.average)([line[0][1], line[1][1]]);
  return {
    vertical: cx <= dot[0],
    horizontal: cy <= dot[1]
  };
}

function hitTestLine(dot, _a) {
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }

  var test1;
  var test2;

  if (!dx) {
    test1 = pos1[0];
    test2 = dot[0];
  } else if (!dy) {
    test1 = pos1[1];
    test2 = dot[1];
  } else {
    var a = dy / dx; // y = a * (x - pos1) + pos1

    test1 = a * (dot[0] - pos1[0]) + pos1[1];
    test2 = dot[1];
  }

  return test1 - test2;
}

function isSameStartLine(dots, line, centerSign, error) {
  if (error === void 0) {
    error = TINY_NUM;
  }

  return dots.every(function (dot) {
    var value = hitTestLine(dot, line);
    var sign = value <= 0;
    return sign === centerSign || Math.abs(value) <= error;
  });
}

function checkInnerBoundDot(pos, start, end, isStart, threshold) {
  if (threshold === void 0) {
    threshold = 0;
  }

  if (isStart && start - threshold <= pos || !isStart && pos <= end + threshold) {
    // false 402 565 602 => 37 ([0, 37])
    // true 400 524.9712603540036 600 => 124 ([124, 0])
    // true 400 410 600 => 10 ([10, 0])
    return {
      isBound: true,
      offset: isStart ? start - pos : end - pos
    };
  }

  return {
    isBound: false,
    offset: 0
  };
}

function checkInnerBound(moveable, _a) {
  var line = _a.line,
      centerSign = _a.centerSign,
      verticalSign = _a.verticalSign,
      horizontalSign = _a.horizontalSign,
      lineConstants = _a.lineConstants;
  var bounds = moveable.props.innerBounds;

  if (!bounds) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  }

  var left = bounds.left,
      top = bounds.top,
      width = bounds.width,
      height = bounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];

  if (isSameStartLine([[left, top], [left + width, top], [left, top + height], [left + width, top + height]], line, centerSign)) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  } // test vertical


  var topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, verticalSign);
  var bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, verticalSign); // test horizontal

  var leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, horizontalSign);
  var rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, horizontalSign);
  var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;
  var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;
  var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;
  var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;
  var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);
  var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);
  var offset = [0, 0];
  var isBound = false;
  var isAllBound = false;

  if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {
    offset = [verticalOffset, 0];
    isBound = isVerticalBound;
    isAllBound = isAllVerticalBound;
  } else {
    offset = [0, horizontalOffset];
    isBound = isHorizontalBound;
    isAllBound = isAllHorizontalBound;
  }

  return {
    isAllBound: isAllBound,
    isVerticalBound: isVerticalBound,
    isHorizontalBound: isHorizontalBound,
    isBound: isBound,
    offset: offset
  };
}

function checkLineBoundCollision(line, _a, boundLine, isStart, threshold, isRender) {
  var a = _a[0],
      b = _a[1];
  var dot1 = line[0]; // const dot2 = line[1];

  var boundDot1 = boundLine[0];
  var boundDot2 = boundLine[1]; // const dy1 = getTinyDist(dot2[1] - dot1[1]);
  // const dx1 = getTinyDist(dot2[0] - dot1[0]);

  var dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);
  var dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);
  var hasDx = b;
  var hasDy = a;
  var slope = -a / b; // lineConstants
  // ax + by + c = 0
  // dx2 or dy2 is zero

  if (!dx2) {
    // vertical
    // by + c = 0
    if (isRender && !hasDy) {
      // 90deg
      return {
        isBound: false,
        offset: 0
      };
    } else if (hasDx) {
      // ax + by + c = 0
      // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];
      var y = slope * (boundDot1[0] - dot1[0]) + dot1[1]; // boundDot1[1] <= y  <= boundDot2[1]

      return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);
    } else {
      // ax + c = 0
      var offset = boundDot1[0] - dot1[0];
      var isBound = Math.abs(offset) <= (threshold || 0);
      return {
        isBound: isBound,
        offset: isBound ? offset : 0
      };
    }
  } else if (!dy2) {
    // horizontal
    if (isRender && !hasDx) {
      // 90deg
      return {
        isBound: false,
        offset: 0
      };
    } else if (hasDy) {
      // y = a * (x - x1) + y1
      // x = (y - y1) / a + x1
      // const a = dy1 / dx1;
      // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];
      var x = (boundDot1[1] - dot1[1]) / slope + dot1[0]; // boundDot1[0] <= x && x <= boundDot2[0]

      return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);
    } else {
      var offset = boundDot1[1] - dot1[1];
      var isBound = Math.abs(offset) <= (threshold || 0);
      return {
        isBound: isBound,
        offset: isBound ? offset : 0
      };
    }
  }

  return {
    isBound: false,
    offset: 0
  };
}

function getInnerBoundInfo(moveable, lineInfos, datas) {
  return lineInfos.map(function (info) {
    var _a = checkInnerBound(moveable, info),
        isBound = _a.isBound,
        offset = _a.offset,
        isVerticalBound = _a.isVerticalBound,
        isHorizontalBound = _a.isHorizontalBound;

    var multiple = info.multiple;
    var sizeOffset = getDragDist({
      datas: datas,
      distX: offset[0],
      distY: offset[1]
    }).map(function (size, i) {
      return size * (multiple[i] ? 2 / multiple[i] : 0);
    });
    return {
      sign: multiple,
      isBound: isBound,
      isVerticalBound: isVerticalBound,
      isHorizontalBound: isHorizontalBound,
      isSnap: false,
      offset: sizeOffset
    };
  });
}

function getInnerBoundDragInfo(moveable, poses, datas) {
  var _a;

  var lines = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false).map(function (info) {
    return __assign(__assign({}, info), {
      multiple: info.multiple.map(function (dir) {
        return Math.abs(dir) * 2;
      })
    });
  });
  var innerBoundInfo = getInnerBoundInfo(moveable, lines, datas);
  var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);
  var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);
  var verticalOffset = 0;
  var horizontalOffset = 0;
  var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;
  var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;

  if (isVerticalBound || isHorizontalBound) {
    _a = getInverseDragDist({
      datas: datas,
      distX: -widthOffsetInfo.offset[0],
      distY: -heightOffsetInfo.offset[1]
    }), verticalOffset = _a[0], horizontalOffset = _a[1];
  }

  return {
    vertical: {
      isBound: isVerticalBound,
      offset: verticalOffset
    },
    horizontal: {
      isBound: isHorizontalBound,
      offset: horizontalOffset
    }
  };
}

function getCheckSnapLineDirections(direction, keepRatio) {
  var lineDirections = [];
  var x = direction[0];
  var y = direction[1];

  if (x && y) {
    lineDirections.push([[0, y * 2], direction, [-x, y]], [[x * 2, 0], direction, [x, -y]]);
  } else if (x) {
    // vertcal
    lineDirections.push([[x * 2, 0], [x, 1], [x, -1]]);

    if (keepRatio) {
      lineDirections.push([[0, -1], [x, -1], [-x, -1]], [[0, 1], [x, 1], [-x, 1]]);
    }
  } else if (y) {
    // horizontal
    lineDirections.push([[0, y * 2], [1, y], [-1, y]]);

    if (keepRatio) {
      lineDirections.push([[-1, 0], [-1, y], [-1, -y]], [[1, 0], [1, y], [1, -y]]);
    }
  } else {
    // [0, 0] to all direction
    lineDirections.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]);
  }

  return lineDirections;
}

function getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio) {
  var _a = moveable.state,
      allMatrix = _a.allMatrix,
      is3d = _a.is3d;
  var virtualPoses = calculatePoses(allMatrix, 100, 100, is3d ? 4 : 3);
  var center = getPosByDirection(virtualPoses, [0, 0]);
  return getCheckSnapLineDirections(direction, keepRatio).map(function (_a) {
    var multiple = _a[0],
        dir1 = _a[1],
        dir2 = _a[2];
    var virtualLine = [getPosByDirection(virtualPoses, dir1), getPosByDirection(virtualPoses, dir2)];
    var lineConstants = solveLineConstants(virtualLine);

    var _b = isStartLine(center, virtualLine),
        verticalSign = _b.vertical,
        horizontalSign = _b.horizontal;

    var centerSign = hitTestLine(center, virtualLine) <= 0;
    return {
      multiple: multiple,
      centerSign: centerSign,
      verticalSign: verticalSign,
      horizontalSign: horizontalSign,
      lineConstants: lineConstants,
      line: [getPosByDirection(poses, dir1), getPosByDirection(poses, dir2)]
    };
  });
}

function isBoundRotate$1(relativePoses, boundDots, center, rad) {
  var nextPoses = rad ? relativePoses.map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos, rad);
  }) : relativePoses;
  return [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].some(function (line) {
    var centerSign = hitTestLine(center, line) <= 0;
    return !isSameStartLine(boundDots, line, centerSign);
  });
}

function getDistPointLine(_a) {
  // x = 0, y = 0
  // d = (ax + by + c) / root(a2 + b2)
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (!dx) {
    return Math.abs(pos1[0]);
  }

  if (!dy) {
    return Math.abs(pos1[1]);
  } // y - y1 = a(x - x1)
  // 0 = ax -y + -a * x1 + y1


  var a = dy / dx;
  return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));
}

function solveReverseLine(_a) {
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (!dx) {
    return [pos1[0], 0];
  }

  if (!dy) {
    return [0, pos1[1]];
  }

  var a = dy / dx; // y - y1 = a (x  - x1)
  // y = ax - a * x1 + y1

  var b = -a * pos1[0] + pos1[1]; // y = ax + b = -1/a x
  // x = -b / (a + 1 / a)
  // y = b / (1 + 1 / a^2)

  return [-b / (a + 1 / a), b / (a * a + 1)];
}

function checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  var bounds = moveable.props.innerBounds;
  var rad = rotation * Math.PI / 180;

  if (!bounds) {
    return [];
  }

  var left = bounds.left,
      top = bounds.top,
      width = bounds.width,
      height = bounds.height;
  var relativeLeft = left - origin[0];
  var relativeRight = left + width - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = top + height - origin[1];
  var dots = [[relativeLeft, relativeTop], [relativeRight, relativeTop], [relativeLeft, relativeBottom], [relativeRight, relativeBottom]];
  var center = getPosByDirection(nextPoses, [0, 0]);

  if (!isBoundRotate$1(nextPoses, dots, center, 0)) {
    return [];
  }

  var result = [];
  var dotInfos = dots.map(function (dot) {
    return [getDistSize(dot), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)([0, 0], dot)];
  });
  [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].forEach(function (line) {
    var lineRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)([0, 0], solveReverseLine(line));
    var lineDist = getDistPointLine(line);
    result.push.apply(result, dotInfos.filter(function (_a) {
      var dotDist = _a[0];
      return dotDist && lineDist <= dotDist;
    }).map(function (_a) {
      var dotDist = _a[0],
          dotRad = _a[1];
      var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);
      var nextRad1 = dotRad + distRad;
      var nextRad2 = dotRad - distRad;
      return [rad + nextRad1 - lineRad, rad + nextRad2 - lineRad];
    }).reduce(function (prev, cur) {
      prev.push.apply(prev, cur);
      return prev;
    }, []).filter(function (nextRad) {
      return !isBoundRotate$1(prevPoses, dots, center, nextRad);
    }).map(function (nextRad) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(nextRad * 180 / Math.PI, TINY_NUM);
    }));
  });
  return result;
}

function checkInnerBoundPoses(moveable) {
  var innerBounds = moveable.props.innerBounds;

  if (!innerBounds) {
    return {
      vertical: [],
      horizontal: []
    };
  }

  var _a = moveable.getRect(),
      pos1 = _a.pos1,
      pos2 = _a.pos2,
      pos3 = _a.pos3,
      pos4 = _a.pos4;

  var poses = [pos1, pos2, pos3, pos4];
  var center = getPosByDirection(poses, [0, 0]);
  var left = innerBounds.left,
      top = innerBounds.top,
      width = innerBounds.width,
      height = innerBounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];
  var lineInfos = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false);
  var horizontalPoses = [];
  var verticalPoses = [];
  var boundMap = {
    top: false,
    bottom: false,
    left: false,
    right: false
  };
  lineInfos.forEach(function (lineInfo) {
    var line = lineInfo.line,
        lineConstants = lineInfo.lineConstants;

    var _a = isStartLine(center, line),
        isHorizontalStart = _a.horizontal,
        isVerticalStart = _a.vertical; // test vertical


    var topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, isVerticalStart, 1, true);
    var bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, isVerticalStart, 1, true); // test horizontal

    var leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, isHorizontalStart, 1, true);
    var rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, isHorizontalStart, 1, true);

    if (topBoundInfo.isBound && !boundMap.top) {
      horizontalPoses.push(top);
      boundMap.top = true;
    }

    if (bottomBoundInfo.isBound && !boundMap.bottom) {
      horizontalPoses.push(top + height);
      boundMap.bottom = true;
    }

    if (leftBoundInfo.isBound && !boundMap.left) {
      verticalPoses.push(left);
      boundMap.left = true;
    }

    if (rightBoundInfo.isBound && !boundMap.right) {
      verticalPoses.push(left + width);
      boundMap.right = true;
    }
  });
  return {
    horizontal: horizontalPoses,
    vertical: verticalPoses
  };
}

function checkBoundPoses(bounds, verticalPoses, horizontalPoses) {
  var _a = bounds || {},
      _b = _a.position,
      position = _b === void 0 ? "client" : _b,
      _c = _a.left,
      left = _c === void 0 ? -Infinity : _c,
      _d = _a.top,
      top = _d === void 0 ? -Infinity : _d,
      _e = _a.right,
      right = _e === void 0 ? Infinity : _e,
      _f = _a.bottom,
      bottom = _f === void 0 ? Infinity : _f;

  var nextBounds = {
    position: position,
    left: left,
    top: top,
    right: right,
    bottom: bottom
  };
  return {
    vertical: checkBounds(nextBounds, verticalPoses, true),
    horizontal: checkBounds(nextBounds, horizontalPoses, false)
  };
}

function getBounds(moveable, externalBounds) {
  var _a = moveable.state,
      _b = _a.containerClientRect,
      containerHeight = _b.clientHeight,
      containerWidth = _b.clientWidth,
      clientLeft = _b.clientLeft,
      clientTop = _b.clientTop,
      _c = _a.snapOffset,
      snapOffsetLeft = _c.left,
      snapOffsetTop = _c.top,
      snapOffsetRight = _c.right,
      snapOffsetBottom = _c.bottom;
  var bounds = externalBounds || moveable.props.bounds || {};
  var position = bounds.position || "client";
  var isCSS = position === "css";
  var _d = bounds.left,
      left = _d === void 0 ? -Infinity : _d,
      _e = bounds.top,
      top = _e === void 0 ? -Infinity : _e;
  var _f = bounds.right,
      right = _f === void 0 ? isCSS ? -Infinity : Infinity : _f,
      _g = bounds.bottom,
      bottom = _g === void 0 ? isCSS ? -Infinity : Infinity : _g;

  if (isCSS) {
    right = containerWidth + snapOffsetRight - snapOffsetLeft - right;
    bottom = containerHeight + snapOffsetBottom - snapOffsetTop - bottom;
  }

  return {
    left: left + snapOffsetLeft - clientLeft,
    right: right + snapOffsetLeft - clientLeft,
    top: top + snapOffsetTop - clientTop,
    bottom: bottom + snapOffsetTop - clientTop
  };
}

function checkBoundKeepRatio(moveable, startPos, endPos) {
  var _a = getBounds(moveable),
      left = _a.left,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom;

  var endX = endPos[0],
      endY = endPos[1];

  var _b = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(endPos, startPos),
      dx = _b[0],
      dy = _b[1];

  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }

  var isBottom = dy > 0;
  var isRight = dx > 0;
  var verticalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };

  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  } else if (dx === 0) {
    if (isBottom) {
      if (bottom < endY) {
        horizontalInfo.pos = bottom;
        horizontalInfo.offset = endY - bottom;
      }
    } else {
      if (top > endY) {
        horizontalInfo.pos = top;
        horizontalInfo.offset = endY - top;
      }
    }
  } else if (dy === 0) {
    if (isRight) {
      if (right < endX) {
        verticalInfo.pos = right;
        verticalInfo.offset = endX - right;
      }
    } else {
      if (left > endX) {
        verticalInfo.pos = left;
        verticalInfo.offset = endX - left;
      }
    }
  } else {
    // y - y1 = a * (x - x1)
    var a = dy / dx;
    var b = endPos[1] - a * endX;
    var y = 0;
    var x = 0;
    var isBound = false;

    if (isRight && right <= endX) {
      y = a * right + b;
      x = right;
      isBound = true;
    } else if (!isRight && endX <= left) {
      y = a * left + b;
      x = left;
      isBound = true;
    }

    if (isBound) {
      if (y < top || y > bottom) {
        isBound = false;
      }
    }

    if (!isBound) {
      if (isBottom && bottom <= endY) {
        y = bottom;
        x = (y - b) / a;
        isBound = true;
      } else if (!isBottom && endY <= top) {
        y = top;
        x = (y - b) / a;
        isBound = true;
      }
    }

    if (isBound) {
      verticalInfo.isBound = true;
      verticalInfo.pos = x;
      verticalInfo.offset = endX - x;
      horizontalInfo.isBound = true;
      horizontalInfo.pos = y;
      horizontalInfo.offset = endY - y;
    }
  }

  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}

function checkBounds(bounds, poses, isVertical) {
  // 0   [100 - 200]  300
  var startBoundPos = bounds[isVertical ? "left" : "top"];
  var endBoundPos = bounds[isVertical ? "right" : "bottom"]; // 450

  var minPos = Math.min.apply(Math, poses);
  var maxPos = Math.max.apply(Math, poses);
  var boundInfos = [];

  if (startBoundPos + 1 > minPos) {
    boundInfos.push({
      isBound: true,
      offset: minPos - startBoundPos,
      pos: startBoundPos
    });
  }

  if (endBoundPos - 1 < maxPos) {
    boundInfos.push({
      isBound: true,
      offset: maxPos - endBoundPos,
      pos: endBoundPos
    });
  }

  if (!boundInfos.length) {
    boundInfos.push({
      isBound: false,
      offset: 0,
      pos: 0
    });
  }

  return boundInfos.sort(function (a, b) {
    return Math.abs(b.offset) - Math.abs(a.offset);
  });
}

function isBoundRotate(relativePoses, boundRect, rad) {
  var nextPoses = rad ? relativePoses.map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos, rad);
  }) : relativePoses;
  return nextPoses.some(function (pos) {
    return pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1 || pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1 || pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1 || pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1;
  });
}

function boundRotate(vec, boundPos, index) {
  var r = getDistSize(vec);
  var nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;
  return [nextPos, -nextPos].sort(function (a, b) {
    return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);
  }).map(function (pos) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)([0, 0], index ? [pos, boundPos] : [boundPos, pos]);
  });
}

function checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  if (!moveable.props.bounds) {
    return [];
  }

  var rad = rotation * Math.PI / 180;

  var _a = getBounds(moveable),
      left = _a.left,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom;

  var relativeLeft = left - origin[0];
  var relativeRight = right - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = bottom - origin[1];
  var boundRect = {
    left: relativeLeft,
    top: relativeTop,
    right: relativeRight,
    bottom: relativeBottom
  };

  if (!isBoundRotate(nextPoses, boundRect, 0)) {
    return [];
  }

  var result = [];
  [[relativeLeft, 0], [relativeRight, 0], [relativeTop, 1], [relativeBottom, 1]].forEach(function (_a) {
    var boundPos = _a[0],
        index = _a[1];
    nextPoses.forEach(function (nextPos) {
      var relativeRad1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)([0, 0], nextPos);
      result.push.apply(result, boundRotate(nextPos, boundPos, index).map(function (relativeRad2) {
        return rad + relativeRad2 - relativeRad1;
      }).filter(function (nextRad) {
        return !isBoundRotate(prevPoses, boundRect, nextRad);
      }).map(function (nextRad) {
        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(nextRad * 180 / Math.PI, TINY_NUM);
      }));
    });
  });
  return result;
}

function renderGuideline(info, React) {
  var _a;

  var direction = info.direction,
      classNames = info.classNames,
      size = info.size,
      pos = info.pos,
      zoom = info.zoom,
      key = info.key;
  var isHorizontal = direction === "horizontal";
  var scaleType = isHorizontal ? "Y" : "X"; // const scaleType2 = isHorizontal ? "Y" : "X";

  return React.createElement("div", {
    key: key,
    className: classNames.join(" "),
    style: (_a = {}, _a[isHorizontal ? "width" : "height"] = "".concat(size), _a.transform = "translate(".concat(pos[0], ", ").concat(pos[1], ") translate").concat(scaleType, "(-50%) scale").concat(scaleType, "(").concat(zoom, ")"), _a)
  });
}

function renderInnerGuideline(info, React) {
  return renderGuideline(__assign(__assign({}, info), {
    classNames: __spreadArray([prefix("line", "guideline", info.direction)], info.classNames, true).filter(function (className) {
      return className;
    }),
    size: info.size || "".concat(info.sizeValue, "px"),
    pos: info.pos || info.posValue.map(function (v) {
      return "".concat((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(v, 0.1), "px");
    })
  }), React);
}

function renderSnapPoses(moveable, direction, snapPoses, minPos, targetPos, size, index, React) {
  var zoom = moveable.props.zoom;
  return snapPoses.map(function (_a, i) {
    var type = _a.type,
        pos = _a.pos;
    var renderPos = [0, 0];
    renderPos[index] = minPos;
    renderPos[index ? 0 : 1] = -targetPos + pos;
    return renderInnerGuideline({
      key: "".concat(direction, "TargetGuideline").concat(i),
      classNames: [prefix("target", "bold", type)],
      posValue: renderPos,
      sizeValue: size,
      zoom: zoom,
      direction: direction
    }, React);
  });
}

function renderGuidelines(moveable, type, guidelines, targetPos, targetRect, React) {
  var _a = moveable.props,
      zoom = _a.zoom,
      isDisplayInnerSnapDigit = _a.isDisplayInnerSnapDigit;
  var mainNames = type === "horizontal" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
  var targetStart = targetRect[mainNames.start];
  var targetEnd = targetRect[mainNames.end];
  return guidelines.filter(function (_a) {
    var hide = _a.hide,
        elementRect = _a.elementRect;

    if (hide) {
      return false;
    }

    if (isDisplayInnerSnapDigit && elementRect) {
      // inner
      var rect = elementRect.rect;

      if (rect[mainNames.start] <= targetStart && targetEnd <= rect[mainNames.end]) {
        return false;
      }
    }

    return true;
  }).map(function (guideline, i) {
    var pos = guideline.pos,
        size = guideline.size,
        element = guideline.element;
    var renderPos = [-targetPos[0] + pos[0], -targetPos[1] + pos[1]];
    return renderInnerGuideline({
      key: "".concat(type, "-default-guideline-").concat(i),
      classNames: element ? [prefix("bold")] : [],
      direction: type,
      posValue: renderPos,
      sizeValue: size,
      zoom: zoom
    }, React);
  });
}

function renderDigitLine(moveable, type, lineType, index, gap, renderPos, className, React) {
  var _a;

  var _b = moveable.props,
      _c = _b.snapDigit,
      snapDigit = _c === void 0 ? 0 : _c,
      _d = _b.isDisplaySnapDigit,
      isDisplaySnapDigit = _d === void 0 ? true : _d,
      _e = _b.snapDistFormat,
      snapDistFormat = _e === void 0 ? function (v, type) {
    // Type can be used render different values.
    if (type === 'vertical') {
      return v;
    }

    return v;
  } : _e,
      zoom = _b.zoom;
  var scaleType = type === "horizontal" ? "X" : "Y";
  var sizeName = type === "vertical" ? "height" : "width";
  var absGap = Math.abs(gap);
  var snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;
  return React.createElement("div", {
    key: "".concat(type, "-").concat(lineType, "-guideline-").concat(index),
    className: prefix("guideline-group", type),
    style: (_a = {
      left: "".concat(renderPos[0], "px"),
      top: "".concat(renderPos[1], "px")
    }, _a[sizeName] = "".concat(absGap, "px"), _a)
  }, renderInnerGuideline({
    direction: type,
    classNames: [prefix(lineType), className],
    size: "100%",
    posValue: [0, 0],
    sizeValue: absGap,
    zoom: zoom
  }, React), React.createElement("div", {
    className: prefix("size-value", "gap"),
    style: {
      transform: "translate".concat(scaleType, "(-50%) scale(").concat(zoom, ")")
    }
  }, snapSize > 0 ? snapDistFormat(snapSize, type) : ""));
}

function groupByElementGuidelines(type, guidelines, targetRect, isDisplayInnerSnapDigit) {
  var index = type === "vertical" ? 0 : 1;
  var otherIndex = type === "vertical" ? 1 : 0;
  var names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
  var targetStart = targetRect[names.start];
  var targetEnd = targetRect[names.end];
  return groupBy(guidelines, function (guideline) {
    return guideline.pos[index];
  }).map(function (nextGuidelines) {
    var start = [];
    var end = [];
    var inner = [];
    nextGuidelines.forEach(function (guideline) {
      var _a, _b;

      var element = guideline.element;
      var rect = guideline.elementRect.rect;

      if (rect[names.end] < targetStart) {
        start.push(guideline);
      } else if (targetEnd < rect[names.start]) {
        end.push(guideline);
      } else if (rect[names.start] <= targetStart && targetEnd <= rect[names.end] && isDisplayInnerSnapDigit) {
        var pos = guideline.pos;
        var elementRect1 = {
          element: element,
          rect: __assign(__assign({}, rect), (_a = {}, _a[names.end] = rect[names.start], _a))
        };
        var elementRect2 = {
          element: element,
          rect: __assign(__assign({}, rect), (_b = {}, _b[names.start] = rect[names.end], _b))
        };
        var nextPos1 = [0, 0];
        var nextPos2 = [0, 0];
        nextPos1[index] = pos[index];
        nextPos1[otherIndex] = pos[otherIndex];
        nextPos2[index] = pos[index];
        nextPos2[otherIndex] = pos[otherIndex] + guideline.size;
        start.push({
          type: type,
          pos: nextPos1,
          size: 0,
          elementRect: elementRect1
        });
        end.push({
          type: type,
          pos: nextPos2,
          size: 0,
          elementRect: elementRect2
        }); // inner.push(guideline);
      }
    });
    start.sort(function (a, b) {
      return b.pos[otherIndex] - a.pos[otherIndex];
    });
    end.sort(function (a, b) {
      return a.pos[otherIndex] - b.pos[otherIndex];
    });
    return {
      total: nextGuidelines,
      start: start,
      end: end,
      inner: inner
    };
  });
}

function renderDashedGuidelines(moveable, guidelines, targetPos, targetRect, React) {
  var isDisplayInnerSnapDigit = moveable.props.isDisplayInnerSnapDigit;
  var rendered = [];
  ["vertical", "horizontal"].forEach(function (type) {
    var nextGuidelines = guidelines.filter(function (guideline) {
      return guideline.type === type;
    });
    var index = type === "vertical" ? 1 : 0;
    var otherIndex = index ? 0 : 1;
    var groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit);
    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;
    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    groups.forEach(function (_a) {
      var total = _a.total,
          start = _a.start,
          end = _a.end,
          inner = _a.inner;
      var sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start];
      var prevRect = targetRect;
      start.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size = prevRect[mainNames.start] - nextRect[mainNames.end];

        if (size > 0) {
          var renderPos = [0, 0];
          renderPos[index] = targetPos[index] + prevRect[mainNames.start] - targetStart - size;
          renderPos[otherIndex] = sidePos;
          rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size, renderPos, guideline.className, React));
        }

        prevRect = nextRect;
      });
      prevRect = targetRect;
      end.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size = nextRect[mainNames.start] - prevRect[mainNames.end];

        if (size > 0) {
          var renderPos = [0, 0];
          renderPos[index] = targetPos[index] + prevRect[mainNames.end] - targetStart;
          renderPos[otherIndex] = sidePos;
          rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size, renderPos, guideline.className, React));
        }

        prevRect = nextRect;
      });
      inner.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size1 = targetStart - nextRect[mainNames.start];
        var size2 = nextRect[mainNames.end] - targetEnd;
        var renderPos1 = [0, 0];
        var renderPos2 = [0, 0];
        renderPos1[index] = targetPos[index] - size1;
        renderPos1[otherIndex] = sidePos;
        renderPos2[index] = targetPos[index] + targetEnd - targetStart;
        renderPos2[otherIndex] = sidePos;
        rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size1, renderPos1, guideline.className, React));
        rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size2, renderPos2, guideline.className, React));
      });
    });
  });
  return rendered;
}

function renderGapGuidelines(moveable, guidelines, targetPos, targetRect, React) {
  var rendered = [];
  ["horizontal", "vertical"].forEach(function (type) {
    var nextGuidelines = guidelines.filter(function (guideline) {
      return guideline.type === type;
    });
    var index = type === "vertical" ? 0 : 1;
    var otherIndex = index ? 0 : 1;
    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;
    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    var targetSideStart = targetRect[sideNames.start];
    var targetSideEnd = targetRect[sideNames.end];
    nextGuidelines.forEach(function (_a) {
      var gap = _a.gap,
          gapRects = _a.gapRects,
          className = _a.className;
      var sideStartPos = Math.max.apply(Math, __spreadArray([targetSideStart], gapRects.map(function (_a) {
        var rect = _a.rect;
        return rect[sideNames.start];
      }), false));
      var sideEndPos = Math.min.apply(Math, __spreadArray([targetSideEnd], gapRects.map(function (_a) {
        var rect = _a.rect;
        return rect[sideNames.end];
      }), false));
      var sideCenterPos = (sideStartPos + sideEndPos) / 2;

      if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd) / 2) {
        return;
      }

      gapRects.forEach(function (_a) {
        var rect = _a.rect;
        var renderPos = [targetPos[0], targetPos[1]];

        if (rect[mainNames.end] < targetStart) {
          renderPos[index] += rect[mainNames.end] - targetStart;
        } else if (targetEnd < rect[mainNames.start]) {
          renderPos[index] += rect[mainNames.start] - targetStart - gap;
        } else {
          return;
        }

        renderPos[otherIndex] += sideCenterPos - targetSideStart;
        rendered.push(renderDigitLine(moveable, index ? "vertical" : "horizontal", "gap", rendered.length, gap, renderPos, className, React));
      });
    });
  });
  return rendered;
}

function solveEquation(pos1, pos2, snapOffset, isVertical) {
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (Math.abs(dx) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM) {
    dy = 0;
  }

  if (!dx) {
    // y = 0 * x + b
    // only horizontal
    if (!isVertical) {
      return [0, snapOffset];
    }

    return [0, 0];
  }

  if (!dy) {
    // only vertical
    if (isVertical) {
      return [snapOffset, 0];
    }

    return [0, 0];
  } // y = ax + b


  var a = dy / dx;
  var b = pos1[1] - a * pos1[0];

  if (isVertical) {
    // y = a * x + b
    var y = a * (pos2[0] + snapOffset) + b;
    return [snapOffset, y - pos2[1]];
  } else {
    // x = (y - b) / a
    var x = (pos2[1] + snapOffset - b) / a;
    return [x - pos2[0], snapOffset];
  }
}

function solveNextOffset(pos1, pos2, offset, isVertical, datas) {
  var sizeOffset = solveEquation(pos1, pos2, offset, isVertical);

  if (!sizeOffset) {
    return {
      isOutside: false,
      offset: [0, 0]
    };
  }

  var size = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(pos1, pos2);
  var dist1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(sizeOffset, pos1);
  var dist2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(sizeOffset, pos2);
  var isOutside = dist1 > size || dist2 > size;

  var _a = getDragDist({
    datas: datas,
    distX: sizeOffset[0],
    distY: sizeOffset[1]
  }),
      widthOffset = _a[0],
      heightOffset = _a[1];

  return {
    offset: [widthOffset, heightOffset],
    isOutside: isOutside
  };
}

function getSnapBound(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return getNearestSnapGuidelineInfo(snapInfo).offset;
  }

  return 0;
}

function checkThrottleDragRotate(throttleDragRotate, _a, _b, _c, _d) {
  var distX = _a[0],
      distY = _a[1];
  var isVerticalBound = _b[0],
      isHorizontalBound = _b[1];
  var isVerticalSnap = _c[0],
      isHorizontalSnap = _c[1];
  var verticalOffset = _d[0],
      horizontalOffset = _d[1];
  var offsetX = -verticalOffset;
  var offsetY = -horizontalOffset;

  if (throttleDragRotate && distX && distY) {
    offsetX = 0;
    offsetY = 0;
    var adjustPoses = [];

    if (isVerticalBound && isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalBound) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset]);
    } else if (isVerticalSnap && isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalSnap) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset]);
    }

    if (adjustPoses.length) {
      adjustPoses.sort(function (a, b) {
        return getDistSize((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([distX, distY], a)) - getDistSize((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([distX, distY], b));
      });
      var adjustPos = adjustPoses[0];

      if (adjustPos[0] && Math.abs(distX) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM) {
        offsetX = -adjustPos[0];
        offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;
      } else if (adjustPos[1] && Math.abs(distY) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM) {
        var prevDistY = distY;
        offsetY = -adjustPos[1];
        offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;
      }

      if (throttleDragRotate && isHorizontalBound && isVerticalBound) {
        if (Math.abs(offsetX) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM && Math.abs(offsetX) < Math.abs(verticalOffset)) {
          var scale = Math.abs(verticalOffset) / Math.abs(offsetX);
          offsetX *= scale;
          offsetY *= scale;
        } else if (Math.abs(offsetY) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM && Math.abs(offsetY) < Math.abs(horizontalOffset)) {
          var scale = Math.abs(horizontalOffset) / Math.abs(offsetY);
          offsetX *= scale;
          offsetY *= scale;
        } else {
          offsetX = maxOffset(-verticalOffset, offsetX);
          offsetY = maxOffset(-horizontalOffset, offsetY);
        }
      }
    }
  } else {
    offsetX = distX || isVerticalBound ? -verticalOffset : 0;
    offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;
  }

  return [offsetX, offsetY];
}

function checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas) {
  if (!hasGuidelines(moveable, "draggable")) {
    return [{
      isSnap: false,
      isBound: false,
      offset: 0
    }, {
      isSnap: false,
      isBound: false,
      offset: 0
    }];
  }

  var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);

  var _a = getRect(poses),
      left = _a.left,
      right = _a.right,
      top = _a.top,
      bottom = _a.bottom;

  var boundPoses = {
    horizontal: poses.map(function (pos) {
      return pos[1];
    }),
    vertical: poses.map(function (pos) {
      return pos[0];
    })
  };
  var snapDirections = getSnapDirections(moveable.props.snapDirections);
  var snapPoses = splitSnapDirectionPoses(snapDirections, {
    left: left,
    right: right,
    top: top,
    bottom: bottom,
    center: (left + right) / 2,
    middle: (top + bottom) / 2
  });

  var _b = checkMoveableSnapBounds(moveable, isRequest, snapPoses, boundPoses),
      verticalSnapBoundInfo = _b.vertical,
      horizontalSnapBoundInfo = _b.horizontal;

  var _c = getInnerBoundDragInfo(moveable, poses, datas),
      verticalInnerBoundInfo = _c.vertical,
      horizontalInnerBoundInfo = _c.horizontal;

  var isVerticalSnap = verticalSnapBoundInfo.isSnap;
  var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;
  var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;
  var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;
  var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);
  var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);

  var _d = checkThrottleDragRotate(throttleDragRotate, [distX, distY], [isVerticalBound, isHorizontalBound], [isVerticalSnap, isHorizontalSnap], [verticalOffset, horizontalOffset]),
      offsetX = _d[0],
      offsetY = _d[1];

  return [{
    isBound: isVerticalBound,
    isSnap: isVerticalSnap,
    offset: offsetX
  }, {
    isBound: isHorizontalBound,
    isSnap: isHorizontalSnap,
    offset: offsetY
  }];
}

function checkMoveableSnapBounds(moveable, isRequest, poses, boundPoses) {
  if (boundPoses === void 0) {
    boundPoses = poses;
  }

  var _a = checkBoundPoses(getBounds(moveable), boundPoses.vertical, boundPoses.horizontal),
      horizontalBoundInfos = _a.horizontal,
      verticalBoundInfos = _a.vertical;

  var _b = isRequest ? {
    horizontal: {
      isSnap: false,
      index: -1
    },
    vertical: {
      isSnap: false,
      index: -1
    }
  } : checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}

function checkSnapBounds(guideines, bounds, posesX, posesY, snapThreshold) {
  var _a = checkBoundPoses(bounds, posesX, posesY),
      horizontalBoundInfos = _a.horizontal,
      verticalBoundInfos = _a.vertical; // options.isRequest ? {
  //     horizontal: { isSnap: false, index: -1 } as SnapInfo,
  //     vertical: { isSnap: false, index: -1 } as SnapInfo,
  // } :


  var _b = checkSnapPoses(guideines, posesX, posesY, snapThreshold),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}

function checkSnapRightLine(startPos, endPos, snapBoundInfo, keepRatio) {
  var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(startPos, endPos) / Math.PI * 180;
  var _a = snapBoundInfo.vertical,
      isVerticalBound = _a.isBound,
      isVerticalSnap = _a.isSnap,
      verticalDist = _a.dist,
      _b = snapBoundInfo.horizontal,
      isHorizontalBound = _b.isBound,
      isHorizontalSnap = _b.isSnap,
      horizontalDist = _b.dist;
  var rad180 = rad % 180;
  var isHorizontalLine = rad180 < 3 || rad180 > 177;
  var isVerticalLine = rad180 > 87 && rad180 < 93;

  if (horizontalDist < verticalDist) {
    if (isVerticalBound || isVerticalSnap && !isVerticalLine && (!keepRatio || !isHorizontalLine)) {
      return "vertical";
    }
  }

  if (isHorizontalBound || isHorizontalSnap && !isHorizontalLine && (!keepRatio || !isVerticalLine)) {
    return "horizontal";
  }

  return "";
}

function getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas) {
  return directions.map(function (_a) {
    var startDirection = _a[0],
        endDirection = _a[1];
    var otherStartPos = getPosByDirection(poses, startDirection);
    var otherEndPos = getPosByDirection(poses, endDirection);
    var snapBoundInfo = keepRatio ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest) : checkMoveableSnapBounds(moveable, isRequest, {
      vertical: [otherEndPos[0]],
      horizontal: [otherEndPos[1]]
    });
    var _b = snapBoundInfo.horizontal,
        // dist: otherHorizontalDist,
    otherHorizontalOffset = _b.offset,
        isOtherHorizontalBound = _b.isBound,
        isOtherHorizontalSnap = _b.isSnap,
        _c = snapBoundInfo.vertical,
        // dist: otherVerticalDist,
    otherVerticalOffset = _c.offset,
        isOtherVerticalBound = _c.isBound,
        isOtherVerticalSnap = _c.isSnap;
    var multiple = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(endDirection, startDirection);

    if (!otherVerticalOffset && !otherHorizontalOffset) {
      return {
        isBound: isOtherVerticalBound || isOtherHorizontalBound,
        isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,
        sign: multiple,
        offset: [0, 0]
      };
    }

    var snapLine = checkSnapRightLine(otherStartPos, otherEndPos, snapBoundInfo, keepRatio);

    if (!snapLine) {
      return {
        sign: multiple,
        isBound: false,
        isSnap: false,
        offset: [0, 0]
      };
    }

    var isVertical = snapLine === "vertical";
    var sizeOffset = [0, 0];

    if (!keepRatio && Math.abs(endDirection[0]) === 1 && Math.abs(endDirection[1]) === 1 && startDirection[0] !== endDirection[0] && startDirection[1] !== endDirection[1]) {
      sizeOffset = getDragDist({
        datas: datas,
        distX: -otherVerticalOffset,
        distY: -otherHorizontalOffset
      });
    } else {
      sizeOffset = solveNextOffset(otherStartPos, otherEndPos, -(isVertical ? otherVerticalOffset : otherHorizontalOffset), isVertical, datas).offset;
    }

    sizeOffset = sizeOffset.map(function (size, i) {
      return size * (multiple[i] ? 2 / multiple[i] : 0);
    });
    return {
      sign: multiple,
      isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,
      isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,
      offset: sizeOffset
    };
  });
}

function getSnapBoundOffset(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return snapInfo.offset;
  }

  return 0;
}

function checkSnapBoundsKeepRatio(moveable, startPos, endPos, isRequest) {
  var _a = checkBoundKeepRatio(moveable, startPos, endPos),
      horizontalBoundInfo = _a.horizontal,
      verticalBoundInfo = _a.vertical;

  var _b = isRequest ? {
    horizontal: {
      isSnap: false
    },
    vertical: {
      isSnap: false
    }
  } : checkSnapKeepRatio(moveable, startPos, endPos),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);
  var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfo.isBound,
      isSnap: horizontalSnapInfo.isSnap,
      offset: horizontalOffset,
      dist: horizontalDist
    },
    vertical: {
      isBound: verticalBoundInfo.isBound,
      isSnap: verticalSnapInfo.isSnap,
      offset: verticalOffset,
      dist: verticalDist
    }
  };
}

function checkMaxBounds(moveable, poses, direction, fixedPosition, datas) {
  var fixedDirection = [-direction[0], -direction[1]];
  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  var bounds = moveable.props.bounds;
  var maxWidth = Infinity;
  var maxHeight = Infinity;

  if (bounds) {
    var directions = [[direction[0], -direction[1]], [-direction[0], direction[1]]];
    var _b = bounds.left,
        left_1 = _b === void 0 ? -Infinity : _b,
        _c = bounds.top,
        top_1 = _c === void 0 ? -Infinity : _c,
        _d = bounds.right,
        right_1 = _d === void 0 ? Infinity : _d,
        _e = bounds.bottom,
        bottom_1 = _e === void 0 ? Infinity : _e;
    directions.forEach(function (otherDirection) {
      var isCheckVertical = otherDirection[0] !== fixedDirection[0];
      var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];
      var otherPos = getPosByDirection(poses, otherDirection);
      var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(fixedPosition, otherPos) * 360 / Math.PI;

      if (isCheckHorizontal) {
        var nextOtherPos = otherPos.slice();

        if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {
          nextOtherPos[1] = fixedPosition[1];
        }

        var _a = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[1] < otherPos[1] ? bottom_1 : top_1) - otherPos[1], false, datas),
            _b = _a.offset,
            heightOffset = _b[1],
            isHeightOutside = _a.isOutside;

        if (!isNaN(heightOffset)) {
          maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);
        }
      }

      if (isCheckVertical) {
        var nextOtherPos = otherPos.slice();

        if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {
          nextOtherPos[0] = fixedPosition[0];
        }

        var _c = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas),
            widthOffset = _c.offset[0],
            isWidthOutside = _c.isOutside;

        if (!isNaN(widthOffset)) {
          maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);
        }
      }
    });
  }

  return {
    maxWidth: maxWidth,
    maxHeight: maxHeight
  };
}

function snapStart(moveable) {
  var state = moveable.state;

  if (state.guidelines && state.guidelines.length) {
    return;
  }

  var container = moveable.state.container;
  var snapContainer = moveable.props.snapContainer || container;
  var containerClientRect = state.containerClientRect;
  var snapOffset = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };

  if (container !== snapContainer) {
    var snapContainerTarget = getRefTarget(snapContainer, true);

    if (snapContainerTarget) {
      var snapContainerRect = getClientRect(snapContainerTarget);
      var offset1 = getDragDistByState(state, [snapContainerRect.left - containerClientRect.left, snapContainerRect.top - containerClientRect.top]);
      var offset2 = getDragDistByState(state, [snapContainerRect.right - containerClientRect.right, snapContainerRect.bottom - containerClientRect.bottom]);
      snapOffset.left = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(offset1[0], 0.1);
      snapOffset.top = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(offset1[1], 0.1);
      snapOffset.right = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(offset2[0], 0.1);
      snapOffset.bottom = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(offset2[1], 0.1);
    }
  }

  state.snapOffset = snapOffset;
  state.guidelines = getTotalGuidelines(moveable);
  state.enableSnap = true;
}

function getNextFixedPoses(matrix, width, height, fixedDirection, fixedPos, is3d) {
  var nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);
  var nextFixedPos = getPosByDirection(nextPoses, fixedDirection);
  return getAbsolutePoses(nextPoses, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedPos, nextFixedPos));
}

function getSizeOffsetInfo(moveable, poses, direction, keepRatio, isRequest, datas) {
  var fixedDirection = datas.fixedDirection;
  var directions = getCheckSnapDirections(direction, fixedDirection, keepRatio);
  var innerBoundLineInfos = getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio);

  var offsets = __spreadArray(__spreadArray([], getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas), true), getInnerBoundInfo(moveable, innerBoundLineInfos, datas), true);

  var widthOffsetInfo = getNearOffsetInfo(offsets, 0);
  var heightOffsetInfo = getNearOffsetInfo(offsets, 1);
  return {
    width: {
      isBound: widthOffsetInfo.isBound,
      offset: widthOffsetInfo.offset[0]
    },
    height: {
      isBound: heightOffsetInfo.isBound,
      offset: heightOffsetInfo.offset[1]
    }
  };
}

function recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction, isRequest, datas) {
  var snapPos = getPosByDirection(poses, direction);

  var _a = checkMoveableSnapBounds(moveable, isRequest, {
    vertical: [snapPos[0]],
    horizontal: [snapPos[1]]
  }),
      horizontalOffset = _a.horizontal.offset,
      verticalOffset = _a.vertical.offset;

  if (verticalOffset || horizontalOffset) {
    var _b = getDragDist({
      datas: datas,
      distX: -verticalOffset,
      distY: -horizontalOffset
    }),
        nextWidthOffset = _b[0],
        nextHeightOffset = _b[1];

    var nextWidth = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);
    var nextHeight = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);
    return [nextWidth - width, nextHeight - height];
  }

  return [0, 0];
}

function checkSizeDist(moveable, getNextPoses, width, height, direction, fixedPosition, isRequest, datas) {
  var poses = getAbsolutePosesByState(moveable.state);
  var keepRatio = moveable.props.keepRatio;
  var widthOffset = 0;
  var heightOffset = 0;

  for (var i = 0; i < 2; ++i) {
    var nextPoses = getNextPoses(widthOffset, heightOffset);

    var _a = getSizeOffsetInfo(moveable, nextPoses, direction, keepRatio, isRequest, datas),
        widthOffsetInfo = _a.width,
        heightOffsetInfo = _a.height;

    var isWidthBound = widthOffsetInfo.isBound;
    var isHeightBound = heightOffsetInfo.isBound;
    var nextWidthOffset = widthOffsetInfo.offset;
    var nextHeightOffset = heightOffsetInfo.offset;

    if (i === 1) {
      if (!isWidthBound) {
        nextWidthOffset = 0;
      }

      if (!isHeightBound) {
        nextHeightOffset = 0;
      }
    }

    if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {
      return [0, 0];
    }

    if (keepRatio) {
      var widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);
      var heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);
      var isGetWidthOffset = isWidthBound && isHeightBound ? widthDist < heightDist : isHeightBound || !isWidthBound && widthDist < heightDist;

      if (isGetWidthOffset) {
        // width : height = ? : heightOffset
        nextWidthOffset = width * nextHeightOffset / height;
      } else {
        // width : height = widthOffset : ?
        nextHeightOffset = height * nextWidthOffset / width;
      }
    }

    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }

  if (direction[0] && direction[1]) {
    var _b = checkMaxBounds(moveable, poses, direction, fixedPosition, datas),
        maxWidth = _b.maxWidth,
        maxHeight = _b.maxHeight;

    var _c = recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset).map(function (pos) {
      return pos.map(function (p) {
        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(p, FLOAT_POINT_NUM);
      });
    }), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction, isRequest, datas),
        nextWidthOffset = _c[0],
        nextHeightOffset = _c[1];

    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }

  return [widthOffset, heightOffset];
}

function checkSnapRotate(moveable, rect, origin, rotation) {
  if (!hasGuidelines(moveable, "rotatable")) {
    return rotation;
  }

  var pos1 = rect.pos1,
      pos2 = rect.pos2,
      pos3 = rect.pos3,
      pos4 = rect.pos4;
  var rad = rotation * Math.PI / 180;
  var prevPoses = [pos1, pos2, pos3, pos4].map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos, origin);
  });
  var nextPoses = prevPoses.map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos, rad);
  });

  var result = __spreadArray(__spreadArray([], checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation), true), checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation), true);

  result.sort(function (a, b) {
    return Math.abs(a - rotation) - Math.abs(b - rotation);
  });

  if (result.length) {
    return result[0];
  } else {
    return rotation;
  }
}

function checkSnapResize(moveable, width, height, direction, fixedPosition, isRequest, datas) {
  if (!hasGuidelines(moveable, "resizable")) {
    return [0, 0];
  }

  var fixedDirection = datas.fixedDirection;
  var _a = moveable.state,
      allMatrix = _a.allMatrix,
      is3d = _a.is3d;
  return checkSizeDist(moveable, function (widthOffset, heightOffset) {
    return getNextFixedPoses(allMatrix, width + widthOffset, height + heightOffset, fixedDirection, fixedPosition, is3d);
  }, width, height, direction, fixedPosition, isRequest, datas);
}

function checkSnapScale(moveable, scale, direction, isRequest, datas) {
  if (!hasGuidelines(moveable, "scalable")) {
    return [0, 0];
  }

  var startOffsetWidth = datas.startOffsetWidth,
      startOffsetHeight = datas.startOffsetHeight,
      fixedPosition = datas.fixedPosition,
      fixedDirection = datas.fixedDirection,
      is3d = datas.is3d;
  var sizeDist = checkSizeDist(moveable, function (widthOffset, heightOffset) {
    return getNextFixedPoses(scaleMatrix(datas, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(scale, [widthOffset / startOffsetWidth, heightOffset / startOffsetHeight])), startOffsetWidth, startOffsetHeight, fixedDirection, fixedPosition, is3d);
  }, startOffsetWidth, startOffsetHeight, direction, fixedPosition, isRequest, datas);
  return [sizeDist[0] / startOffsetWidth, sizeDist[1] / startOffsetHeight];
}

function startCheckSnapDrag(moveable, datas) {
  datas.absolutePoses = getAbsolutePosesByState(moveable.state);
}

function getSnapGuidelines(posInfos) {
  var guidelines = [];
  posInfos.forEach(function (posInfo) {
    posInfo.guidelineInfos.forEach(function (_a) {
      var guideline = _a.guideline;

      if (guidelines.indexOf(guideline) > -1) {
        return;
      }

      guidelines.push(guideline);
    });
  });
  return guidelines;
}

function addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses, externalBounds) {
  var _a = checkBoundPoses(getBounds(moveable, externalBounds), verticalPoses, horizontalPoses),
      verticalBoundInfos = _a.vertical,
      horizontalBoundInfos = _a.horizontal;

  verticalBoundInfos.forEach(function (info) {
    if (info.isBound) {
      verticalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });
  horizontalBoundInfos.forEach(function (info) {
    if (info.isBound) {
      horizontalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });

  var _b = checkInnerBoundPoses(moveable),
      verticalInnerBoundPoses = _b.vertical,
      horizontalInnerBoundPoses = _b.horizontal;

  verticalInnerBoundPoses.forEach(function (innerPos) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(verticalSnapPoses, function (_a) {
      var type = _a.type,
          pos = _a.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }

    verticalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
  horizontalInnerBoundPoses.forEach(function (innerPos) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(horizontalSnapPoses, function (_a) {
      var type = _a.type,
          pos = _a.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }

    horizontalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
}
/**
 * @namespace Moveable.Snappable
 * @description Whether or not target can be snapped to the guideline. (default: false)
 * @sort 2
 */


var Snappable = {
  name: "snappable",
  dragRelation: "strong",
  props: {
    snappable: [Boolean, Array],
    snapContainer: Object,
    snapDirections: [Boolean, Object],
    elementSnapDirections: [Boolean, Object],
    snapGap: Boolean,
    snapGridWidth: Number,
    snapGridHeight: Number,
    isDisplaySnapDigit: Boolean,
    isDisplayInnerSnapDigit: Boolean,
    snapDigit: Number,
    snapThreshold: Number,
    horizontalGuidelines: Array,
    verticalGuidelines: Array,
    elementGuidelines: Array,
    bounds: Object,
    innerBounds: Object,
    snapDistFormat: Function
  },
  events: {
    onSnap: "snap"
  },
  css: [":host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n"],
  render: function (moveable, React) {
    var state = moveable.state;
    var targetTop = state.top,
        targetLeft = state.left,
        pos1 = state.pos1,
        pos2 = state.pos2,
        pos3 = state.pos3,
        pos4 = state.pos4,
        snapRenderInfo = state.snapRenderInfo;

    if (!snapRenderInfo || !hasGuidelines(moveable, "")) {
      return [];
    }

    state.guidelines = getTotalGuidelines(moveable);
    var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);
    var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);
    var externalPoses = snapRenderInfo.externalPoses || [];
    var poses = getAbsolutePosesByState(moveable.state);
    var verticalSnapPoses = [];
    var horizontalSnapPoses = [];
    var verticalGuidelines = [];
    var horizontalGuidelines = [];
    var snapInfos = [];

    var _a = getRect(poses),
        width = _a.width,
        height = _a.height,
        top = _a.top,
        left = _a.left,
        bottom = _a.bottom,
        right = _a.right;

    var targetRect = {
      left: left,
      right: right,
      top: top,
      bottom: bottom,
      center: (left + right) / 2,
      middle: (top + bottom) / 2
    };
    var hasExternalPoses = externalPoses.length > 0;
    var externalRect = hasExternalPoses ? getRect(externalPoses) : {};

    if (!snapRenderInfo.request) {
      if (snapRenderInfo.direction) {
        snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));
      }

      if (snapRenderInfo.snap) {
        var rect = getRect(poses);

        if (snapRenderInfo.center) {
          rect.middle = (rect.top + rect.bottom) / 2;
          rect.center = (rect.left + rect.right) / 2;
        }

        snapInfos.push(checkSnaps(moveable, rect, 1));
      }

      if (hasExternalPoses) {
        if (snapRenderInfo.center) {
          externalRect.middle = (externalRect.top + externalRect.bottom) / 2;
          externalRect.center = (externalRect.left + externalRect.right) / 2;
        }

        snapInfos.push(checkSnaps(moveable, externalRect, 1));
      }

      snapInfos.forEach(function (snapInfo) {
        var verticalPosInfos = snapInfo.vertical.posInfos,
            horizontalPosInfos = snapInfo.horizontal.posInfos;
        verticalSnapPoses.push.apply(verticalSnapPoses, verticalPosInfos.filter(function (_a) {
          var guidelineInfos = _a.guidelineInfos;
          return guidelineInfos.some(function (_a) {
            var guideline = _a.guideline;
            return !guideline.hide;
          });
        }).map(function (posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        horizontalSnapPoses.push.apply(horizontalSnapPoses, horizontalPosInfos.filter(function (_a) {
          var guidelineInfos = _a.guidelineInfos;
          return guidelineInfos.some(function (_a) {
            var guideline = _a.guideline;
            return !guideline.hide;
          });
        }).map(function (posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        verticalGuidelines.push.apply(verticalGuidelines, getSnapGuidelines(verticalPosInfos));
        horizontalGuidelines.push.apply(horizontalGuidelines, getSnapGuidelines(horizontalPosInfos));
      });
    }

    addBoundGuidelines(moveable, [left, right], [top, bottom], verticalSnapPoses, horizontalSnapPoses);

    if (hasExternalPoses) {
      addBoundGuidelines(moveable, [externalRect.left, externalRect.right], [externalRect.top, externalRect.bottom], verticalSnapPoses, horizontalSnapPoses, snapRenderInfo.externalBounds);
    }

    var allGuidelines = __spreadArray(__spreadArray([], verticalGuidelines, true), horizontalGuidelines, true);

    var elementGuidelines = allGuidelines.filter(function (guideline) {
      return guideline.element && !guideline.gapRects;
    });
    var gapGuidelines = allGuidelines.filter(function (guideline) {
      return guideline.gapRects;
    });
    triggerEvent(moveable, "onSnap", {
      guidelines: allGuidelines.filter(function (_a) {
        var element = _a.element;
        return !element;
      }),
      elements: elementGuidelines,
      gaps: gapGuidelines
    }, true);
    return __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(moveable, elementGuidelines, [minLeft, minTop], targetRect, React), true), renderGapGuidelines(moveable, gapGuidelines, [minLeft, minTop], targetRect, React), true), renderGuidelines(moveable, "horizontal", horizontalGuidelines, [targetLeft, targetTop], targetRect, React), true), renderGuidelines(moveable, "vertical", verticalGuidelines, [targetLeft, targetTop], targetRect, React), true), renderSnapPoses(moveable, "horizontal", horizontalSnapPoses, minLeft, targetTop, width, 0, React), true), renderSnapPoses(moveable, "vertical", verticalSnapPoses, minTop, targetLeft, height, 1, React), true);
  },
  dragStart: function (moveable, e) {
    moveable.state.snapRenderInfo = {
      request: e.isRequest,
      snap: true,
      center: true
    };
    snapStart(moveable);
  },
  drag: function (moveable) {
    var state = moveable.state;
    state.guidelines = getTotalGuidelines(moveable);
  },
  pinchStart: function (moveable) {
    this.unset(moveable);
  },
  dragEnd: function (moveable) {
    this.unset(moveable);
  },
  dragControlCondition: function (moveable, e) {
    if (directionCondition(moveable, e) || dragControlCondition(moveable, e)) {
      return true;
    }

    if (!e.isRequest && e.inputEvent) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(e.inputEvent.target, prefix("snap-control"));
    }
  },
  dragControlStart: function (moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragControl: function (moveable) {
    this.drag(moveable);
  },
  dragControlEnd: function (moveable) {
    this.unset(moveable);
  },
  dragGroupStart: function (moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroup: function (moveable) {
    this.drag(moveable);
  },
  dragGroupEnd: function (moveable) {
    this.unset(moveable);
  },
  dragGroupControlStart: function (moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragGroupControl: function (moveable) {
    this.drag(moveable);
  },
  dragGroupControlEnd: function (moveable) {
    this.unset(moveable);
  },
  unset: function (moveable) {
    var state = moveable.state;
    state.enableSnap = false;
    state.guidelines = [];
    state.snapRenderInfo = null;
    state.elementRects = [];
  }
};
/**
 * Whether or not target can be snapped to the guideline. (default: false)
 * @name Moveable.Snappable#snappable
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snappable = true;
 */

/**
 *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)
 * @name Moveable.Snappable#snapContainer
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.querySelector(".container"));
 *
 * moveable.snapContainer = document.body;
 */

/**
 * You can specify the directions to snap to the target. (default: { left: true, top: true, right: true, bottom: true })
 * @name Moveable.Snappable#snapDirections
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   snapDirections: true,
 * });
 * // snap center
 * moveable.snapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };
 */

/**
 * You can specify the snap directions of elements. (default: { left: true, top: true, right: true, bottom: true })
 * @name Moveable.Snappable#elementSnapDirections
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   elementSnapDirections: true,
 * });
 * // snap center
 * moveable.elementSnapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };
 */

/**
 * When you drag, make the gap snap in the element guidelines. (default: true)
 * @name Moveable.Snappable#snapGap
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   snapElement: true,
 *   snapGap: true,
 * });
 *
 * moveable.snapGap = false;
 */

/**
 * Distance value that can snap to guidelines. (default: 5)
 * @name Moveable.Snappable#snapThreshold
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapThreshold = 5;
 */

/**
 * Add guidelines in the horizontal direction. (default: [])
 * @name Moveable.Snappable#horizontalGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.horizontalGuidelines = [100, 200, 500];
 */

/**
 * Add guidelines in the vertical direction. (default: [])
 * @name Moveable.Snappable#verticalGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.verticalGuidelines = [100, 200, 500];
 */

/**
 * Add guidelines for the element. (default: [])
 * @name Moveable.Snappable#elementGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.elementGuidelines = [
 *   document.querySelector(".element"),
 * ];
 */

/**
 * You can set up boundaries.
 * @name Moveable.Snappable#bounds
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @default null
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};
 */

/**
 * You can set up inner boundaries.
 * @name Moveable.Snappable#innerBounds
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @default null
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};
 */

/**
 * snap distance digits (default: 0)
 * @name Moveable.Snappable#snapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapDigit = 0
 */

/**
 * If width size is greater than 0, you can vertical snap to the grid. (default: 0)
 * @name Moveable.Snappable#snapGridWidth
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapGridWidth = 5;
 */

/**
 * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)
 * @name Moveable.Snappable#snapGridHeight
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapGridHeight = 5;
 */

/**
 * Whether to show snap distance (default: true)
 * @name Moveable.Snappable#isDisplaySnapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.isDisplaySnapDigit = true;
 */

/**
 * Whether to show element inner snap distance (default: false)
 * @name Moveable.Snappable#isDisplayInnerSnapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.isDisplayInnerSnapDigit = true;
 */

/**
 * You can set the text format of the distance shown in the guidelines. (default: self)
 * @name Moveable.Snappable#snapDistFormat
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  snappable: true,
 *  snapDistFormat: (v, type) => v,
 * });
 * moveable.snapDistFormat = (v, type) => `${v}px`;
 */

/**
 * When you drag or dragControl, the `snap` event is called.
 * @memberof Moveable.Snappable
 * @event snap
 * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     snappable: true
 * });
 * moveable.on("snap", e => {
 *     console.log("onSnap", e);
 * });
 */

/**
 * @namespace Draggable
 * @memberof Moveable
 * @description Draggable refers to the ability to drag and move targets.
 */

var Draggable = {
  name: "draggable",
  props: {
    draggable: Boolean,
    throttleDrag: Number,
    throttleDragRotate: Number,
    startDragRotate: Number,
    edgeDraggable: Boolean
  },
  events: {
    onDragStart: "dragStart",
    onDrag: "drag",
    onDragEnd: "dragEnd",
    onDragGroupStart: "dragGroupStart",
    onDragGroup: "dragGroup",
    onDragGroupEnd: "dragGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        throttleDragRotate = _a.throttleDragRotate,
        zoom = _a.zoom;
    var _b = moveable.state,
        dragInfo = _b.dragInfo,
        beforeOrigin = _b.beforeOrigin;

    if (!throttleDragRotate || !dragInfo) {
      return [];
    }

    var dist = dragInfo.dist;

    if (!dist[0] && !dist[1]) {
      return [];
    }

    var width = getDistSize(dist);
    var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(dist, [0, 0]);
    return [React.createElement("div", {
      className: prefix("line", "horizontal", "dragline", "dashed"),
      key: "dragRotateGuideline",
      style: {
        width: "".concat(width, "px"),
        transform: "translate(".concat(beforeOrigin[0], "px, ").concat(beforeOrigin[1], "px) rotate(").concat(rad, "rad) scaleY(").concat(zoom, ")")
      }
    })];
  },
  dragStart: function (moveable, e) {
    var datas = e.datas,
        parentEvent = e.parentEvent,
        parentGesto = e.parentGesto;
    var state = moveable.state;
    var target = state.target,
        gesto = state.gesto;

    if (gesto) {
      return false;
    }

    state.gesto = parentGesto || moveable.targetGesto;
    var style = getComputedStyle(target);
    datas.datas = {};
    datas.left = parseFloat(style.left || "") || 0;
    datas.top = parseFloat(style.top || "") || 0;
    datas.bottom = parseFloat(style.bottom || "") || 0;
    datas.right = parseFloat(style.right || "") || 0;
    datas.startValue = [0, 0];
    setDragStart(moveable, e);
    setDefaultTransformIndex(e, "translate");
    startCheckSnapDrag(moveable, datas);
    datas.prevDist = [0, 0];
    datas.prevBeforeDist = [0, 0];
    datas.isDrag = false;
    datas.deltaOffset = [0, 0];
    var params = fillParams(moveable, e, __assign({
      set: function (translate) {
        datas.startValue = translate;
      }
    }, fillTransformStartEvent(e)));
    var result = parentEvent || triggerEvent(moveable, "onDragStart", params);

    if (result !== false) {
      datas.isDrag = true;
      moveable.state.dragInfo = {
        startRect: moveable.getRect(),
        dist: [0, 0]
      };
    } else {
      state.gesto = null;
      datas.isPinch = false;
    }

    return datas.isDrag ? params : false;
  },
  drag: function (moveable, e) {
    if (!e) {
      return;
    }

    resolveTransformEvent(e, "translate");
    var datas = e.datas,
        parentEvent = e.parentEvent,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        isRequest = e.isRequest,
        deltaOffset = e.deltaOffset;
    var distX = e.distX,
        distY = e.distY;
    var isDrag = datas.isDrag,
        prevDist = datas.prevDist,
        prevBeforeDist = datas.prevBeforeDist,
        startValue = datas.startValue;

    if (!isDrag) {
      return;
    }

    if (deltaOffset) {
      distX += deltaOffset[0];
      distY += deltaOffset[1];
    }

    var props = moveable.props;
    var parentMoveable = props.parentMoveable;
    var throttleDrag = parentEvent ? 0 : props.throttleDrag || 0;
    var throttleDragRotate = parentEvent ? 0 : props.throttleDragRotate || 0;
    var isSnap = false;
    var dragRotateRad = 0;

    if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {
      var startDragRotate = props.startDragRotate || 0;
      var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(startDragRotate + (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate) - startDragRotate;
      var ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));
      var rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));
      var r = getDistSize([rx, ry]);
      dragRotateRad = deg * Math.PI / 180;
      distX = r * Math.cos(dragRotateRad);
      distY = r * Math.sin(dragRotateRad);
    }

    if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {
      var _a = checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest || deltaOffset, datas),
          verticalInfo = _a[0],
          horizontalInfo = _a[1];

      var isVerticalSnap = verticalInfo.isSnap,
          isVerticalBound = verticalInfo.isBound,
          verticalOffset = verticalInfo.offset;
      var isHorizontalSnap = horizontalInfo.isSnap,
          isHorizontalBound = horizontalInfo.isBound,
          horizontalOffset = horizontalInfo.offset;
      isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;
      distX += verticalOffset;
      distY += horizontalOffset;
    }

    var beforeTranslate = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(getBeforeDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    }), startValue);
    var translate = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(getTransformDist({
      datas: datas,
      distX: distX,
      distY: distY
    }), startValue);

    if (!throttleDragRotate && !isSnap) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttleArray)(translate, throttleDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttleArray)(beforeTranslate, throttleDrag);
    }

    var beforeDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(beforeTranslate, startValue);
    var dist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(translate, startValue);
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, prevDist);
    var beforeDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(beforeDist, prevBeforeDist);
    datas.prevDist = dist;
    datas.prevBeforeDist = beforeDist;
    datas.passDelta = delta; //distX - (datas.passDistX || 0);
    // datas.passDeltaY = distY - (datas.passDistY || 0);

    datas.passDist = dist; //distX;
    // datas.passDistY = distY;

    var left = datas.left + beforeDist[0];
    var top = datas.top + beforeDist[1];
    var right = datas.right - beforeDist[0];
    var bottom = datas.bottom - beforeDist[1];
    var nextTransform = convertTransformFormat(datas, "translate(".concat(translate[0], "px, ").concat(translate[1], "px)"), "translate(".concat(dist[0], "px, ").concat(dist[1], "px)"));
    fillOriginalTransform(e, nextTransform);
    moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;

    if (!parentEvent && !parentMoveable && delta.every(function (num) {
      return !num;
    }) && beforeDelta.some(function (num) {
      return !num;
    })) {
      return;
    }

    var _b = moveable.state,
        width = _b.width,
        height = _b.height;
    var params = fillParams(moveable, e, {
      transform: nextTransform,
      dist: dist,
      delta: delta,
      translate: translate,
      beforeDist: beforeDist,
      beforeDelta: beforeDelta,
      beforeTranslate: beforeTranslate,
      left: left,
      top: top,
      right: right,
      bottom: bottom,
      width: width,
      height: height,
      isPinch: isPinch
    });
    !parentEvent && triggerEvent(moveable, "onDrag", params);
    return params;
  },
  dragAfter: function (moveable, e) {
    var datas = e.datas;
    var deltaOffset = datas.deltaOffset;

    if (deltaOffset[0] || deltaOffset[1]) {
      datas.deltaOffset = [0, 0];
      return this.drag(moveable, __assign(__assign({}, e), {
        deltaOffset: deltaOffset
      }));
    }

    return false;
  },
  dragEnd: function (moveable, e) {
    var parentEvent = e.parentEvent,
        datas = e.datas;
    moveable.state.gesto = null;
    moveable.state.dragInfo = null;

    if (!datas.isDrag) {
      return;
    }

    datas.isDrag = false;
    var param = fillEndParams(moveable, e, {});
    !parentEvent && triggerEvent(moveable, "onDragEnd", param);
    return param;
  },
  dragGroupStart: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY;
    var params = this.dragStart(moveable, e);

    if (!params) {
      return false;
    }

    var events = triggerChildGesto(moveable, this, "dragStart", [clientX || 0, clientY || 0], e, false);

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onDragGroupStart", nextParams);
    datas.isDrag = result !== false;
    return datas.isDrag ? params : false;
  },
  dragGroup: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isDrag) {
      return;
    }

    var params = this.drag(moveable, e);
    var passDelta = e.datas.passDelta;
    var events = triggerChildGesto(moveable, this, "drag", passDelta, e, false);

    if (!params) {
      return;
    }

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onDragGroup", nextParams);
    return nextParams;
  },
  dragGroupEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isDrag) {
      return;
    }

    this.dragEnd(moveable, e);
    var events = triggerChildGesto(moveable, this, "dragEnd", [0, 0], e, false);
    triggerEvent(moveable, "onDragGroupEnd", fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    }));
    return isDrag;
  },

  /**
   * @method Moveable.Draggable#request
   * @param {object} [e] - the draggable's request parameter
   * @param {number} [e.x] - x position
   * @param {number} [e.y] - y position
   * @param {number} [e.deltaX] - X number to move
   * @param {number} [e.deltaY] - Y number to move
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("draggable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 });
   * moveable.request("draggable", { x: 220, y: 100 });
   * moveable.request("draggable", { x: 240, y: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    return {
      isControl: false,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("x" in e) {
          distX = e.x - rect.left;
        } else if ("deltaX" in e) {
          distX += e.deltaX;
        }

        if ("y" in e) {
          distY = e.y - rect.top;
        } else if ("deltaY" in e) {
          distY += e.deltaY;
        }

        return {
          datas: datas,
          distX: distX,
          distY: distY
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  },
  unset: function (moveable) {
    moveable.state.dragInfo = null;
  }
};
/**
 * Whether or not target can be dragged. (default: false)
 * @name Moveable.Draggable#draggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.draggable = true;
 */

/**
 * throttle of x, y when drag.
 * @name Moveable.Draggable#throttleDrag
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleDrag = 1;
 */

/**
* throttle of angle of x, y when drag.
* @name Moveable.Draggable#throttleDragRotate
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body);
*
* moveable.throttleDragRotate = 45;
*/

/**
* start angle of throttleDragRotate of x, y when drag.
* @name Moveable.Draggable#startDragRotate
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body);
*
* // 45, 135, 225, 315
* moveable.throttleDragRotate = 90;
* moveable.startDragRotate = 45;
*/

/**
 * When the drag starts, the dragStart event is called.
 * @memberof Moveable.Draggable
 * @event dragStart
 * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("dragStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When dragging, the drag event is called.
 * @memberof Moveable.Draggable
 * @event drag
 * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("drag", ({ target, transform }) => {
 *     target.style.transform = transform;
 * });
 */

/**
 * When the drag finishes, the dragEnd event is called.
 * @memberof Moveable.Draggable
 * @event dragEnd
 * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("dragEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group drag starts, the `dragGroupStart` event is called.
* @memberof Moveable.Draggable
* @event dragGroupStart
* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     draggable: true
* });
* moveable.on("dragGroupStart", ({ targets }) => {
*     console.log("onDragGroupStart", targets);
* });
*/

/**
* When the group drag, the `dragGroup` event is called.
* @memberof Moveable.Draggable
* @event dragGroup
* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     draggable: true
* });
* moveable.on("dragGroup", ({ targets, events }) => {
*     console.log("onDragGroup", targets);
*     events.forEach(ev => {
*          // drag event
*          console.log("onDrag left, top", ev.left, ev.top);
*          // ev.target!.style.left = `${ev.left}px`;
*          // ev.target!.style.top = `${ev.top}px`;
*          console.log("onDrag translate", ev.dist);
*          ev.target!.style.transform = ev.transform;)
*     });
* });
*/

/**
 * When the group drag finishes, the `dragGroupEnd` event is called.
 * @memberof Moveable.Draggable
 * @event dragGroupEnd
 * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     draggable: true
 * });
 * moveable.on("dragGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onDragGroupEnd", targets, isDrag);
 * });
 */

function calculatePointerDist(moveable, e) {
  var clientX = e.clientX,
      clientY = e.clientY,
      datas = e.datas;
  var _a = moveable.state,
      moveableClientRect = _a.moveableClientRect,
      rootMatrix = _a.rootMatrix,
      is3d = _a.is3d,
      pos1 = _a.pos1;
  var left = moveableClientRect.left,
      top = moveableClientRect.top;
  var n = is3d ? 4 : 3;

  var _b = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1),
      posX = _b[0],
      posY = _b[1];

  var _c = getDragDist({
    datas: datas,
    distX: posX,
    distY: posY
  }),
      distX = _c[0],
      distY = _c[1];

  return [distX, distY];
}

function setDragStart(moveable, _a) {
  var datas = _a.datas;
  var _b = moveable.state,
      allMatrix = _b.allMatrix,
      beforeMatrix = _b.beforeMatrix,
      is3d = _b.is3d,
      left = _b.left,
      top = _b.top,
      origin = _b.origin,
      offsetMatrix = _b.offsetMatrix,
      targetMatrix = _b.targetMatrix,
      transformOrigin = _b.transformOrigin;
  var n = is3d ? 4 : 3;
  datas.is3d = is3d;
  datas.matrix = allMatrix;
  datas.targetMatrix = targetMatrix;
  datas.beforeMatrix = beforeMatrix;
  datas.offsetMatrix = offsetMatrix;
  datas.transformOrigin = transformOrigin;
  datas.inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(allMatrix, n);
  datas.inverseBeforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(beforeMatrix, n);
  datas.absoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)([left, top], origin), n);
  datas.startDragBeforeDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);
  datas.startDragDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(datas.inverseMatrix, datas.absoluteOrigin, n);
}

function getTransformDirection(e) {
  return calculateMoveablePosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;
}

function resolveTransformEvent(event, functionName) {
  var datas = event.datas,
      originalDatas = event.originalDatas.beforeRenderable;
  var index = datas.transformIndex;
  var nextTransforms = originalDatas.nextTransforms;
  var nextTransformAppendedIndexes = originalDatas.nextTransformAppendedIndexes;
  var nextIndex = 0;

  if (index === -1) {
    nextIndex = nextTransforms.length;
    datas.transformIndex = nextIndex;
  } else {
    nextIndex = index + nextTransformAppendedIndexes.filter(function (i) {
      return i < index;
    }).length;
  }

  var result = convertTransformInfo(nextTransforms, nextIndex);
  var targetFunction = result.targetFunction;
  var matFunctionName = functionName === "rotate" ? "rotateZ" : functionName;
  datas.beforeFunctionTexts = result.beforeFunctionTexts;
  datas.afterFunctionTexts = result.afterFunctionTexts;
  datas.beforeTransform = result.beforeFunctionMatrix;
  datas.beforeTransform2 = result.beforeFunctionMatrix2;
  datas.targetTansform = result.targetFunctionMatrix;
  datas.afterTransform = result.afterFunctionMatrix;
  datas.afterTransform2 = result.afterFunctionMatrix2;
  datas.targetAllTransform = result.allFunctionMatrix;

  if (targetFunction.functionName === matFunctionName) {
    datas.afterFunctionTexts.splice(0, 1);
    datas.isAppendTransform = false;
  } else {
    datas.isAppendTransform = true;
    originalDatas.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], nextTransformAppendedIndexes, true), [nextIndex], false);
  }
}

function convertTransformFormat(datas, value, dist) {
  return "".concat(datas.beforeFunctionTexts.join(" "), " ").concat(datas.isAppendTransform ? dist : value, " ").concat(datas.afterFunctionTexts.join(" "));
}

function getTransformDist(_a) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;

  var _b = getBeforeDragDist({
    datas: datas,
    distX: distX,
    distY: distY
  }),
      bx = _b[0],
      by = _b[1]; // B * [tx, ty] * A = [bx, by] * targetMatrix;
  // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];


  var res = getTransfromMatrix(datas, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.fromTranslation)([bx, by], 4));
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(res, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)([0, 0, 0], 4), 4);
}

function getTransfromMatrix(datas, targetMatrix, isAfter) {
  var beforeTransform = datas.beforeTransform,
      afterTransform = datas.afterTransform,
      beforeTransform2 = datas.beforeTransform2,
      afterTransform2 = datas.afterTransform2,
      targetAllTransform = datas.targetAllTransform; // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)
  // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1
  // nextTargetMatrix = (targetMatrix * targetAllTransform)

  var nextTargetMatrix = isAfter ? (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetAllTransform, targetMatrix, 4) : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetMatrix, targetAllTransform, 4); // res1 = B-1 * nextTargetMatrix

  var res1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4); // res3 = res2 * A-1

  var afterTargetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(res1, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(isAfter ? afterTransform2 : afterTransform, 4), 4);
  return afterTargetMatrix;
}

function getBeforeDragDist(_a) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY; // TT = BT

  var inverseBeforeMatrix = datas.inverseBeforeMatrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3; // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])
  // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]

  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(inverseBeforeMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(absoluteOrigin, [distX, distY]), n), startDragBeforeDist);
}

function getDragDist(_a, isBefore) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;
  var inverseBeforeMatrix = datas.inverseBeforeMatrix,
      inverseMatrix = datas.inverseMatrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      startDragDist = datas.startDragDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(isBefore ? inverseBeforeMatrix : inverseMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);
}

function getInverseDragDist(_a, isBefore) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;
  var beforeMatrix = datas.beforeMatrix,
      matrix = datas.matrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      startDragDist = datas.startDragDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(isBefore ? beforeMatrix : matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]), n), absoluteOrigin);
}

function calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {
  if (prevWidth === void 0) {
    prevWidth = width;
  }

  if (prevHeight === void 0) {
    prevHeight = height;
  }

  if (prevOrigin === void 0) {
    prevOrigin = [0, 0];
  }

  if (!transformOrigin) {
    return prevOrigin;
  }

  return transformOrigin.map(function (pos, i) {
    var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitUnit)(pos),
        value = _a.value,
        unit = _a.unit;

    var prevSize = i ? prevHeight : prevWidth;
    var size = i ? height : width;

    if (pos === "%" || isNaN(value)) {
      // no value but %
      var measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;
      return size * measureRatio;
    } else if (unit !== "%") {
      return value;
    }

    return size * value / 100;
  });
}

function getPosIndexesByDirection(direction) {
  var indexes = [];

  if (direction[1] >= 0) {
    if (direction[0] >= 0) {
      indexes.push(3);
    }

    if (direction[0] <= 0) {
      indexes.push(2);
    }
  }

  if (direction[1] <= 0) {
    if (direction[0] >= 0) {
      indexes.push(1);
    }

    if (direction[0] <= 0) {
      indexes.push(0);
    }
  }

  return indexes;
}

function getPosesByDirection(poses, direction) {
  /*
  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)
  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)
  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)
  */
  return getPosIndexesByDirection(direction).map(function (index) {
    return poses[index];
  });
}

function getPosByDirection(poses, direction) {
  /*
  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)
  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)
  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)
  */
  var nextPoses = getPosesByDirection(poses, direction);
  return [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.average)(nextPoses.map(function (pos) {
    return pos[0];
  })), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.average)(nextPoses.map(function (pos) {
    return pos[1];
  }))];
}

function getDist(startPos, matrix, width, height, n, fixedDirection) {
  var poses = calculatePoses(matrix, width, height, n);
  var fixedPos = getPosByDirection(poses, fixedDirection);
  var distX = startPos[0] - fixedPos[0];
  var distY = startPos[1] - fixedPos[1];
  return [distX, distY];
}

function getNextMatrix(offsetMatrix, targetMatrix, origin, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);
}

function getNextTransformMatrix(state, datas, transform) {
  var transformOrigin = state.transformOrigin,
      offsetMatrix = state.offsetMatrix,
      is3d = state.is3d;
  var beforeTransform = datas.beforeTransform,
      afterTransform = datas.afterTransform;
  var n = is3d ? 4 : 3;
  var targetTransform = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.parseMat)([transform]);
  return getNextMatrix(offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(beforeTransform, targetTransform, 4), afterTransform, 4), 4, n), transformOrigin, n);
}

function scaleMatrix(state, scale) {
  var transformOrigin = state.transformOrigin,
      offsetMatrix = state.offsetMatrix,
      is3d = state.is3d,
      targetMatrix = state.targetMatrix;
  var n = is3d ? 4 : 3;
  return getNextMatrix(offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createScaleMatrix)(scale, n), n), transformOrigin, n);
}

function fillTransformStartEvent(e) {
  var originalDatas = e.originalDatas.beforeRenderable;
  return {
    setTransform: function (transform, index) {
      if (index === void 0) {
        index = -1;
      }

      originalDatas.startTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitSpace)(transform);
      setTransformIndex(e, index);
    },
    setTransformIndex: function (index) {
      setTransformIndex(e, index);
    }
  };
}

function setDefaultTransformIndex(e, property) {
  var originalDatas = e.originalDatas.beforeRenderable;
  var startTransforms = originalDatas.startTransforms;
  setTransformIndex(e, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(startTransforms, function (func) {
    return func.indexOf("".concat(property, "(")) === 0;
  }));
}

function setTransformIndex(e, index) {
  var originalDatas = e.originalDatas.beforeRenderable;
  var datas = e.datas;
  datas.transformIndex = index;

  if (index === -1) {
    return;
  }

  var transform = originalDatas.startTransforms[index];

  if (!transform) {
    return;
  }

  var info = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.parse)([transform]);
  datas.startValue = info[0].functionValue;
}

function fillOriginalTransform(e, transform) {
  var originalDatas = e.originalDatas.beforeRenderable;
  originalDatas.nextTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitSpace)(transform);
}

function getNextTransformText(e) {
  var originalDatas = e.originalDatas.beforeRenderable;
  return originalDatas.nextTransforms.join(" ");
}

function fillTransformEvent(moveable, nextTransform, delta, isPinch, e) {
  fillOriginalTransform(e, nextTransform);
  return {
    transform: nextTransform,
    drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, delta, isPinch, false))
  };
}

function getTranslateDist(moveable, transform, fixedDirection, fixedPosition, datas) {
  var state = moveable.state;
  var left = state.left,
      top = state.top;
  var groupable = moveable.props.groupable;
  var nextMatrix = getNextTransformMatrix(moveable.state, datas, transform);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);
  var dist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedPosition, nextFixedPosition);
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, [groupLeft, groupTop]);
}

function getScaleDist(moveable, scaleDist, fixedDirection, fixedPosition, datas) {
  var dist = getTranslateDist(moveable, "scale(".concat(scaleDist.join(", "), ")"), fixedDirection, fixedPosition, datas);
  return dist;
}

function getOriginDirection(moveable) {
  var _a = moveable.state,
      width = _a.width,
      height = _a.height,
      transformOrigin = _a.transformOrigin;
  return [-1 + transformOrigin[0] / (width / 2), -1 + transformOrigin[1] / (height / 2)];
}

function getDirectionOffset(moveable, direction, nextMatrix) {
  if (nextMatrix === void 0) {
    nextMatrix = moveable.state.allMatrix;
  }

  var _a = moveable.state,
      width = _a.width,
      height = _a.height,
      is3d = _a.is3d;
  var n = is3d ? 4 : 3;
  var nextFixedOffset = [width / 2 * (1 + direction[0]), height / 2 * (1 + direction[1])];
  return calculatePosition(nextMatrix, nextFixedOffset, n);
}

function getRotateDist(moveable, rotateDist, fixedPosition, datas) {
  var fixedDirection = getOriginDirection(moveable);
  return getTranslateDist(moveable, "rotate(".concat(rotateDist, "deg)"), fixedDirection, fixedPosition, datas);
}

function getResizeDist(moveable, width, height, fixedDirection, fixedPosition, transformOrigin) {
  var groupable = moveable.props.groupable;
  var _a = moveable.state,
      prevOrigin = _a.transformOrigin,
      targetMatrix = _a.targetMatrix,
      offsetMatrix = _a.offsetMatrix,
      is3d = _a.is3d,
      prevWidth = _a.width,
      prevHeight = _a.height,
      left = _a.left,
      top = _a.top;
  var n = is3d ? 4 : 3;
  var nextOrigin = calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);
  var dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, [groupLeft, groupTop]);
}

function getAbsolutePosition(moveable, direction) {
  return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);
}

function multiply2(pos1, pos2) {
  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];
}

function prefix() {
  var classNames = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    classNames[_i] = arguments[_i];
  }

  return framework_utils__WEBPACK_IMPORTED_MODULE_6__.prefixNames.apply(void 0, __spreadArray([PREFIX], classNames, false));
}

function defaultSync(fn) {
  fn();
}

function getTransformMatrix(transform) {
  if (!transform || transform === "none") {
    return [1, 0, 0, 1, 0, 0];
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(transform)) {
    return transform;
  }

  return (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.parseMat)(transform);
}

function getAbsoluteMatrix(matrix, n, origin) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplies)(n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(origin, n), matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(origin.map(function (a) {
    return -a;
  }), n));
}

function measureSVGSize(el, unit, isHorizontal) {
  if (unit === "%") {
    var viewBox = getSVGViewBox(el.ownerSVGElement);
    return viewBox[isHorizontal ? "width" : "height"] / 100;
  }

  return 1;
}

function getBeforeTransformOrigin(el) {
  var relativeOrigin = getTransformOrigin(getComputedStyle(el, ":before"));
  return relativeOrigin.map(function (o, i) {
    var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitUnit)(o),
        value = _a.value,
        unit = _a.unit;

    return value * measureSVGSize(el, unit, i === 0);
  });
}

function getTransformOrigin(style) {
  var transformOrigin = style.transformOrigin;
  return transformOrigin ? transformOrigin.split(" ") : ["0", "0"];
}

function getElementTransform(target, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getComputedStyle(target);
  }

  var computedTransform = computedStyle.transform;

  if (computedTransform && computedTransform !== "none") {
    return computedStyle.transform;
  }

  if ("transform" in target) {
    var list = target.transform;
    var baseVal = list.baseVal;

    if (!baseVal) {
      return "";
    }

    var length = baseVal.length;

    if (!length) {
      return "";
    }

    var matrixes = [];

    var _loop_1 = function (i) {
      var matrix = baseVal[i].matrix;
      matrixes.push("matrix(".concat(["a", "b", "c", "d", "e", "f"].map(function (chr) {
        return matrix[chr];
      }).join(", "), ")"));
    };

    for (var i = 0; i < length; ++i) {
      _loop_1(i);
    }

    return matrixes.join(" ");
  }

  return "";
}

function getOffsetInfo(el, lastParent, isParent) {
  var body = document.body;
  var target = !el || isParent ? el : el.parentElement;
  var isEnd = el === lastParent || target === lastParent;
  var position = "relative";

  while (target && target !== body) {
    if (lastParent === target) {
      isEnd = true;
    }

    var style = getComputedStyle(target);
    var tagName = target.tagName.toLowerCase();
    var transform = getElementTransform(target, style);
    position = style.position;

    if (tagName === "svg" || position !== "static" || transform && transform !== "none") {
      break;
    }

    target = target.parentElement;
    position = "relative";
  }

  return {
    isStatic: position === "static",
    isEnd: isEnd || !target || target === body,
    offsetParent: target || body
  };
}

function getOffsetPosInfo(el, style) {
  var _a;

  var tagName = el.tagName.toLowerCase();
  var offsetLeft = el.offsetLeft;
  var offsetTop = el.offsetTop; // svg

  var isSVG = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(offsetLeft);
  var hasOffset = !isSVG;
  var origin;
  var targetOrigin; // inner svg element

  if (!hasOffset && tagName !== "svg") {
    origin = IS_WEBKIT605 ? getBeforeTransformOrigin(el) : getTransformOrigin(style).map(function (pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
    hasOffset = true;
    _a = getSVGGraphicsOffset(el, origin), offsetLeft = _a[0], offsetTop = _a[1], origin[0] = _a[2], origin[1] = _a[3];
  } else {
    origin = getTransformOrigin(style).map(function (pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
  }

  return {
    tagName: tagName,
    isSVG: isSVG,
    hasOffset: hasOffset,
    offset: [offsetLeft || 0, offsetTop || 0],
    origin: origin,
    targetOrigin: targetOrigin
  };
}

function getBodyOffset(el, isSVG, style) {
  if (style === void 0) {
    style = getComputedStyle(el);
  }

  var bodyStyle = getComputedStyle(document.body);
  var bodyPosition = bodyStyle.position;

  if (!isSVG && (!bodyPosition || bodyPosition === "static")) {
    return [0, 0];
  }

  var marginLeft = parseInt(bodyStyle.marginLeft, 10);
  var marginTop = parseInt(bodyStyle.marginTop, 10);

  if (style.position === "absolute") {
    if (style.top !== "auto" || style.bottom !== "auto") {
      marginTop = 0;
    }

    if (style.left !== "auto" || style.right !== "auto") {
      marginLeft = 0;
    }
  }

  return [marginLeft, marginTop];
}

function convert3DMatrixes(matrixes) {
  matrixes.forEach(function (info) {
    var matrix = info.matrix;

    if (matrix) {
      info.matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(matrix, 3, 4);
    }
  });
}

function getBodyScrollPos() {
  return [document.documentElement.scrollLeft || document.body.scrollLeft, document.documentElement.scrollTop || document.body.scrollTop];
}

function getPositionFixedInfo(el) {
  var fixedContainer = el.parentElement;
  var hasTransform = false;

  while (fixedContainer) {
    var transform = getComputedStyle(fixedContainer).transform;

    if (transform && transform !== "none") {
      hasTransform = true;
      break;
    }

    if (fixedContainer === document.body) {
      break;
    }

    fixedContainer = fixedContainer.parentElement;
  }

  return {
    fixedContainer: fixedContainer || document.body,
    hasTransform: hasTransform
  };
}

function getMatrixStackInfo(target, container, checkContainer) {
  var el = target;
  var matrixes = [];
  var requestEnd = !checkContainer && target === container || target === document.body;
  var isEnd = requestEnd;
  var is3d = false;
  var n = 3;
  var transformOrigin;
  var targetTransformOrigin;
  var targetMatrix;
  var hasFixed = false;
  var offsetContainer = getOffsetInfo(container, container, true).offsetParent;

  while (el && !isEnd) {
    isEnd = requestEnd;
    var style = getComputedStyle(el);
    var position = style.position;
    var transform = getElementTransform(el, style);
    var matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertCSStoMatrix)(getTransformMatrix(transform));
    var isFixed = position === "fixed";
    var fixedInfo = {
      hasTransform: false,
      fixedContainer: null
    };

    if (isFixed) {
      hasFixed = true;
      fixedInfo = getPositionFixedInfo(el);
      offsetContainer = fixedInfo.fixedContainer;
    } // convert 3 to 4


    var length = matrix.length;

    if (!is3d && length === 16) {
      is3d = true;
      n = 4;
      convert3DMatrixes(matrixes);

      if (targetMatrix) {
        targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 3, 4);
      }
    }

    if (is3d && length === 9) {
      matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(matrix, 3, 4);
    }

    var _a = getOffsetPosInfo(el, style),
        tagName = _a.tagName,
        hasOffset = _a.hasOffset,
        isSVG = _a.isSVG,
        origin = _a.origin,
        targetOrigin = _a.targetOrigin,
        offsetPos = _a.offset;

    var offsetLeft = offsetPos[0],
        offsetTop = offsetPos[1];

    if (tagName === "svg" && targetMatrix) {
      // scale matrix for svg's SVGElements.
      matrixes.push({
        type: "target",
        target: el,
        matrix: getSVGMatrix(el, n)
      });
      matrixes.push({
        type: "offset",
        target: el,
        matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n)
      });
    } else if (tagName === "g" && target !== el) {
      offsetLeft = 0;
      offsetTop = 0;
    }

    var offsetParent = void 0;
    var isOffsetEnd = false;
    var isStatic = false;

    if (isFixed) {
      offsetParent = fixedInfo.fixedContainer;
      isOffsetEnd = true;
    } else {
      var offsetInfo = getOffsetInfo(el, container);
      offsetParent = offsetInfo.offsetParent;
      isOffsetEnd = offsetInfo.isEnd;
      isStatic = offsetInfo.isStatic;
    }

    if (IS_WEBKIT && hasOffset && !isSVG && isStatic && (position === "relative" || position === "static")) {
      offsetLeft -= offsetParent.offsetLeft;
      offsetTop -= offsetParent.offsetTop;
      requestEnd = requestEnd || isOffsetEnd;
    }

    var parentClientLeft = 0;
    var parentClientTop = 0;
    var fixedClientLeft = 0;
    var fixedClientTop = 0;

    if (isFixed) {
      if (hasOffset && fixedInfo.hasTransform) {
        // border
        fixedClientLeft = offsetParent.clientLeft;
        fixedClientTop = offsetParent.clientTop;
      }
    } else {
      if (hasOffset && offsetContainer !== offsetParent) {
        // border
        parentClientLeft = offsetParent.clientLeft;
        parentClientTop = offsetParent.clientTop;
      }

      if (hasOffset && offsetParent === document.body) {
        var margin = getBodyOffset(el, false, style);
        offsetLeft += margin[0];
        offsetTop += margin[1];
      }
    }

    matrixes.push({
      type: "target",
      target: el,
      matrix: getAbsoluteMatrix(matrix, n, origin)
    });

    if (hasOffset) {
      matrixes.push({
        type: "offset",
        target: el,
        matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)([offsetLeft - el.scrollLeft + parentClientLeft - fixedClientLeft, offsetTop - el.scrollTop + parentClientTop - fixedClientTop], n)
      });
    } else {
      // svg
      matrixes.push({
        type: "offset",
        target: el,
        origin: origin
      });
    }

    if (!targetMatrix) {
      targetMatrix = matrix;
    }

    if (!transformOrigin) {
      transformOrigin = origin;
    }

    if (!targetTransformOrigin) {
      targetTransformOrigin = targetOrigin;
    }

    if (isEnd || isFixed) {
      break;
    } else {
      el = offsetParent;
      requestEnd = isOffsetEnd;
    }

    if (!checkContainer || el === document.body) {
      isEnd = requestEnd;
    }
  }

  if (!targetMatrix) {
    targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);
  }

  if (!transformOrigin) {
    transformOrigin = [0, 0];
  }

  if (!targetTransformOrigin) {
    targetTransformOrigin = [0, 0];
  }

  return {
    offsetContainer: offsetContainer,
    matrixes: matrixes,
    targetMatrix: targetMatrix,
    transformOrigin: transformOrigin,
    targetOrigin: targetTransformOrigin,
    is3d: is3d,
    hasFixed: hasFixed
  };
}

function calculateElementInfo(target, container, rootContainer, isAbsolute3d) {
  if (rootContainer === void 0) {
    rootContainer = container;
  }

  var width = 0;
  var height = 0;
  var rotation = 0;
  var allResult = {};

  if (target) {
    var _a = getSize(target),
        offsetWidth = _a.offsetWidth,
        offsetHeight = _a.offsetHeight;

    width = offsetWidth;
    height = offsetHeight;
  }

  if (target) {
    var result = calculateMatrixStack(target, container, rootContainer, isAbsolute3d);
    var position = calculateMoveablePosition(result.allMatrix, result.transformOrigin, width, height);
    allResult = __assign(__assign({}, result), position);
    var rotationPosition = calculateMoveablePosition(result.allMatrix, [50, 50], 100, 100);
    rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);
  }

  var n = isAbsolute3d ? 4 : 3;
  return __assign({
    width: width,
    height: height,
    rotation: rotation,
    rootMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),
    beforeMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),
    offsetMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),
    allMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),
    targetMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),
    targetTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!isAbsolute3d,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1,
    hasFixed: false
  }, allResult);
}

function getElementInfo(target, container, rootContainer) {
  if (rootContainer === void 0) {
    rootContainer = container;
  }

  return calculateElementInfo(target, container, rootContainer, true);
}

function calculateMatrixStack(target, container, rootContainer, isAbsolute3d) {
  var _a;

  if (rootContainer === void 0) {
    rootContainer = container;
  }

  var _b = getMatrixStackInfo(target, container),
      matrixes = _b.matrixes,
      is3d = _b.is3d,
      prevTargetMatrix = _b.targetMatrix,
      transformOrigin = _b.transformOrigin,
      targetOrigin = _b.targetOrigin,
      offsetContainer = _b.offsetContainer,
      hasFixed = _b.hasFixed; // prevMatrix


  var _c = getMatrixStackInfo(offsetContainer, rootContainer, true),
      rootMatrixes = _c.matrixes,
      isRoot3d = _c.is3d; // prevRootMatrix
  // if (rootContainer === document.body) {
  //     console.log(offsetContainer, rootContainer, rootMatrixes);
  // }


  var isNext3d = isAbsolute3d || isRoot3d || is3d;
  var n = isNext3d ? 4 : 3;
  var isSVGGraphicElement = target.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in target;
  var targetMatrix = prevTargetMatrix; // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);
  // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);
  // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);

  var allMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);
  var rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);
  var beforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);
  var offsetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);
  var length = matrixes.length;
  rootMatrixes.reverse();
  matrixes.reverse();

  if (!is3d && isNext3d) {
    targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 3, 4);
    convert3DMatrixes(matrixes);
  }

  if (!isRoot3d && isNext3d) {
    convert3DMatrixes(rootMatrixes);
  } // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)
  // rootMatrixBeforeOffset = lastOffsetMatrix -> (...) -> container
  // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)
  // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)


  rootMatrixes.forEach(function (info) {
    rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(rootMatrix, info.matrix, n);
  });
  var originalRootContainer = rootContainer || document.body;
  var endContainer = ((_a = rootMatrixes[0]) === null || _a === void 0 ? void 0 : _a.target) || getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;
  var rootMatrixBeforeOffset = rootMatrixes.slice(1).reduce(function (matrix, info) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(matrix, info.matrix, n);
  }, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n));
  matrixes.forEach(function (info, i) {
    if (length - 2 === i) {
      // length - 3
      beforeMatrix = allMatrix.slice();
    }

    if (length - 1 === i) {
      // length - 2
      offsetMatrix = allMatrix.slice();
    } // calculate for SVGElement


    if (!info.matrix) {
      var nextInfo = matrixes[i + 1];
      var offset = getSVGOffset(info, nextInfo, endContainer, n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(rootMatrixBeforeOffset, allMatrix, n));
      info.matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(offset, n);
    }

    allMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(allMatrix, info.matrix, n);
  });
  var isMatrix3d = !isSVGGraphicElement && is3d;

  if (!targetMatrix) {
    targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(isMatrix3d ? 4 : 3);
  }

  var targetTransform = makeMatrixCSS(isSVGGraphicElement && targetMatrix.length === 16 ? (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 4, 3) : targetMatrix, isMatrix3d);
  rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.ignoreDimension)(rootMatrix, n, n);
  return {
    hasFixed: hasFixed,
    rootMatrix: rootMatrix,
    beforeMatrix: beforeMatrix,
    offsetMatrix: offsetMatrix,
    allMatrix: allMatrix,
    targetMatrix: targetMatrix,
    targetTransform: targetTransform,
    transformOrigin: transformOrigin,
    targetOrigin: targetOrigin,
    is3d: isNext3d
  };
}

function makeMatrixCSS(matrix, is3d) {
  if (is3d === void 0) {
    is3d = matrix.length > 9;
  }

  return "".concat(is3d ? "matrix3d" : "matrix", "(").concat((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertMatrixtoCSS)(matrix, !is3d).join(","), ")");
}

function getSVGViewBox(el) {
  var clientWidth = el.clientWidth;
  var clientHeight = el.clientHeight;

  if (!el) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      clientWidth: clientWidth,
      clientHeight: clientHeight
    };
  }

  var viewBox = el.viewBox;
  var baseVal = viewBox && viewBox.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: baseVal.x,
    y: baseVal.y,
    width: baseVal.width || clientWidth,
    height: baseVal.height || clientHeight,
    clientWidth: clientWidth,
    clientHeight: clientHeight
  };
}

function getSVGMatrix(el, n) {
  var _a = getSVGViewBox(el),
      viewBoxWidth = _a.width,
      viewBoxHeight = _a.height,
      clientWidth = _a.clientWidth,
      clientHeight = _a.clientHeight;

  var scaleX = clientWidth / viewBoxWidth;
  var scaleY = clientHeight / viewBoxHeight;
  var preserveAspectRatio = el.preserveAspectRatio.baseVal; // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio

  var align = preserveAspectRatio.align; // 1 : meet 2: slice

  var meetOrSlice = preserveAspectRatio.meetOrSlice;
  var svgOrigin = [0, 0];
  var scale = [scaleX, scaleY];
  var translate = [0, 0];

  if (align !== 1) {
    var xAlign = (align - 2) % 3;
    var yAlign = Math.floor((align - 2) / 3);
    svgOrigin[0] = viewBoxWidth * xAlign / 2;
    svgOrigin[1] = viewBoxHeight * yAlign / 2;
    var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);
    scale[0] = scaleDimension;
    scale[1] = scaleDimension;
    translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;
    translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;
  }

  var scaleMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createScaleMatrix)(scale, n);
  scaleMatrix[n * (n - 1)] = translate[0], scaleMatrix[n * (n - 1) + 1] = translate[1];
  return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);
}

function getSVGGraphicsOffset(el, origin) {
  if (!el.getBBox || el.tagName.toLowerCase() === "g") {
    return [0, 0, 0, 0];
  }

  var bbox = el.getBBox();
  var viewBox = getSVGViewBox(el.ownerSVGElement);
  var left = bbox.x - viewBox.x;
  var top = bbox.y - viewBox.y;
  return [left, top, origin[0] - left, origin[1] - top];
}

function calculatePosition(matrix, pos, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)(pos, n), n);
}

function calculatePoses(matrix, width, height, n) {
  return [[0, 0], [width, 0], [0, height], [width, height]].map(function (pos) {
    return calculatePosition(matrix, pos, n);
  });
}

function getRect(poses) {
  var posesX = poses.map(function (pos) {
    return pos[0];
  });
  var posesY = poses.map(function (pos) {
    return pos[1];
  });
  var left = Math.min.apply(Math, posesX);
  var top = Math.min.apply(Math, posesY);
  var right = Math.max.apply(Math, posesX);
  var bottom = Math.max.apply(Math, posesY);
  var rectWidth = right - left;
  var rectHeight = bottom - top;
  return {
    left: left,
    top: top,
    right: right,
    bottom: bottom,
    width: rectWidth,
    height: rectHeight
  };
}

function calculateRect(matrix, width, height, n) {
  var poses = calculatePoses(matrix, width, height, n);
  return getRect(poses);
}

function getSVGOffset(offsetInfo, targetInfo, container, n, beforeMatrix) {
  var _a;

  var target = offsetInfo.target;
  var origin = offsetInfo.origin;
  var targetMatrix = targetInfo.matrix;

  var _b = getSize(target),
      width = _b.offsetWidth,
      height = _b.offsetHeight;

  var containerClientRect = container.getBoundingClientRect();
  var margin = [0, 0];

  if (container === document.body) {
    margin = getBodyOffset(target, true);
  }

  var rect = target.getBoundingClientRect();
  var rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0) + margin[0];
  var rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0) + margin[1];
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  var mat = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplies)(n, beforeMatrix, targetMatrix);

  var _c = calculateRect(mat, width, height, n),
      prevLeft = _c.left,
      prevTop = _c.top,
      prevWidth = _c.width,
      prevHeight = _c.height;

  var posOrigin = calculatePosition(mat, origin, n);
  var prevOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(posOrigin, [prevLeft, prevTop]);
  var rectOrigin = [rectLeft + prevOrigin[0] * rectWidth / prevWidth, rectTop + prevOrigin[1] * rectHeight / prevHeight];
  var offset = [0, 0];
  var count = 0;

  while (++count < 10) {
    var inverseBeforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(beforeMatrix, n);
    _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(inverseBeforeMatrix, rectOrigin, n), calculatePosition(inverseBeforeMatrix, posOrigin, n)), offset[0] = _a[0], offset[1] = _a[1];
    var mat2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplies)(n, beforeMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(offset, n), targetMatrix);

    var _d = calculateRect(mat2, width, height, n),
        nextLeft = _d.left,
        nextTop = _d.top;

    var distLeft = nextLeft - rectLeft;
    var distTop = nextTop - rectTop;

    if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {
      break;
    }

    rectOrigin[0] -= distLeft;
    rectOrigin[1] -= distTop;
  }

  return offset.map(function (p) {
    return Math.round(p);
  });
}

function calculateMoveablePosition(matrix, origin, width, height) {
  var is3d = matrix.length === 16;
  var n = is3d ? 4 : 3;
  var poses = calculatePoses(matrix, width, height, n);
  var _a = poses[0],
      x1 = _a[0],
      y1 = _a[1],
      _b = poses[1],
      x2 = _b[0],
      y2 = _b[1],
      _c = poses[2],
      x3 = _c[0],
      y3 = _c[1],
      _d = poses[3],
      x4 = _d[0],
      y4 = _d[1];

  var _e = calculatePosition(matrix, origin, n),
      originX = _e[0],
      originY = _e[1];

  var left = Math.min(x1, x2, x3, x4);
  var top = Math.min(y1, y2, y3, y4);
  var right = Math.max(x1, x2, x3, x4);
  var bottom = Math.max(y1, y2, y3, y4);
  x1 = x1 - left || 0;
  x2 = x2 - left || 0;
  x3 = x3 - left || 0;
  x4 = x4 - left || 0;
  y1 = y1 - top || 0;
  y2 = y2 - top || 0;
  y3 = y3 - top || 0;
  y4 = y4 - top || 0;
  originX = originX - left || 0;
  originY = originY - top || 0;
  var direction = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getShapeDirection)(poses);
  return {
    left: left,
    top: top,
    right: right,
    bottom: bottom,
    origin: [originX, originY],
    pos1: [x1, y1],
    pos2: [x2, y2],
    pos3: [x3, y3],
    pos4: [x4, y4],
    direction: direction
  };
}

function getDistSize(vec) {
  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
}

function getDiagonalSize(pos1, pos2) {
  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);
}

function getLineStyle(pos1, pos2, zoom, rad) {
  if (zoom === void 0) {
    zoom = 1;
  }

  if (rad === void 0) {
    rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(pos1, pos2);
  }

  var width = getDiagonalSize(pos1, pos2);
  return {
    transform: "translateY(-50%) translate(".concat(pos1[0], "px, ").concat(pos1[1], "px) rotate(").concat(rad, "rad) scaleY(").concat(zoom, ")"),
    width: "".concat(width, "px")
  };
}

function getControlTransform(rotation, zoom) {
  var poses = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    poses[_i - 2] = arguments[_i];
  }

  var length = poses.length;
  var x = poses.reduce(function (prev, pos) {
    return prev + pos[0];
  }, 0) / length;
  var y = poses.reduce(function (prev, pos) {
    return prev + pos[1];
  }, 0) / length;
  return {
    transform: "translateZ(0px) translate(".concat(x, "px, ").concat(y, "px) rotate(").concat(rotation, "rad) scale(").concat(zoom, ")")
  };
}

function getCSSSize(target) {
  var style = getComputedStyle(target);
  return [parseFloat(style.width), parseFloat(style.height)];
}

function getSize(target, style) {
  if (style === void 0) {
    style = getComputedStyle(target);
  }

  var hasOffset = !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(target.offsetWidth);

  if (!hasOffset && target.tagName.toLowerCase() !== "svg") {
    var bbox = target.getBBox();
    var offsetWidth = bbox.width;
    var offsetHeight = bbox.height;
    return {
      svg: true,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight,
      clientWidth: offsetWidth,
      clientHeight: offsetHeight,
      cssWidth: offsetWidth,
      cssHeight: offsetHeight
    };
  } else {
    var boxSizing = style.boxSizing === "border-box";
    var borderLeft = parseFloat(style.borderLeftWidth) || 0;
    var borderRight = parseFloat(style.borderRightWidth) || 0;
    var borderTop = parseFloat(style.borderTopWidth) || 0;
    var borderBottom = parseFloat(style.borderBottomWidth) || 0;
    var paddingLeft = parseFloat(style.paddingLeft) || 0;
    var paddingRight = parseFloat(style.paddingRight) || 0;
    var paddingTop = parseFloat(style.paddingTop) || 0;
    var paddingBottom = parseFloat(style.paddingBottom) || 0;
    var cssWidth = parseFloat(style.width);
    var cssHeight = parseFloat(style.height);
    var offsetWidth = cssWidth;
    var offsetHeight = cssHeight;
    var clientWidth = cssWidth;
    var clientHeight = cssHeight;
    var horizontalPadding = paddingLeft + paddingRight;
    var verticalPadding = paddingTop + paddingBottom;
    var horizontalBorder = borderLeft + borderRight;
    var verticalBorder = borderTop + borderBottom;
    var horizontalOffset = horizontalPadding + horizontalBorder;
    var verticalOffset = verticalPadding + verticalBorder;

    if (boxSizing) {
      cssWidth = offsetWidth - horizontalOffset;
      cssHeight = offsetHeight - verticalOffset;
    } else {
      offsetWidth = cssWidth + horizontalOffset;
      offsetHeight = cssHeight + verticalOffset;
    }

    clientWidth = cssWidth + horizontalPadding;
    clientHeight = cssHeight + verticalPadding;
    return {
      svg: false,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight,
      clientWidth: clientWidth,
      clientHeight: clientHeight,
      cssWidth: cssWidth,
      cssHeight: cssHeight
    };
  }
}

function getRotationRad(poses, direction) {
  return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);
}

function getTargetInfo(moveableElement, target, container, parentContainer, rootContainer) {
  var beforeDirection = 1;
  var beforeOrigin = [0, 0];
  var targetClientRect = resetClientRect();
  var containerClientRect = resetClientRect();
  var moveableClientRect = resetClientRect();
  var result = calculateElementInfo(target, container, rootContainer, false);

  if (target) {
    var n = result.is3d ? 4 : 3;
    var beforePosition = calculateMoveablePosition(result.offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(result.transformOrigin, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.getOrigin)(result.targetMatrix, n)), result.width, result.height);
    beforeDirection = beforePosition.direction;
    beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(beforePosition.origin, [beforePosition.left - result.left, beforePosition.top - result.top]);
    targetClientRect = getClientRect(target);
    containerClientRect = getClientRect(getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body, true);

    if (moveableElement) {
      moveableClientRect = getClientRect(moveableElement);
    }
  }

  return __assign({
    targetClientRect: targetClientRect,
    containerClientRect: containerClientRect,
    moveableClientRect: moveableClientRect,
    beforeDirection: beforeDirection,
    beforeOrigin: beforeOrigin,
    originalBeforeOrigin: beforeOrigin,
    target: target
  }, result);
}

function resetClientRect() {
  return {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    width: 0,
    height: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}

function getClientRect(el, isExtends) {
  var _a;

  var left = 0;
  var top = 0;
  var width = 0;
  var height = 0;

  if (el === document.body || el === document.documentElement) {
    width = window.innerWidth;
    height = window.innerHeight;
    var scrollPos = getBodyScrollPos();
    _a = [-scrollPos[0], -scrollPos[1]], left = _a[0], top = _a[1];
  } else {
    var clientRect = el.getBoundingClientRect();
    left = clientRect.left;
    top = clientRect.top;
    width = clientRect.width;
    height = clientRect.height;
  }

  var rect = {
    left: left,
    right: left + width,
    top: top,
    bottom: top + height,
    width: width,
    height: height
  };

  if (isExtends) {
    rect.clientLeft = el.clientLeft;
    rect.clientTop = el.clientTop;
    rect.clientWidth = el.clientWidth;
    rect.clientHeight = el.clientHeight;
    rect.scrollWidth = el.scrollWidth;
    rect.scrollHeight = el.scrollHeight;
    rect.overflow = getComputedStyle(el).overflow !== "visible";
  }

  return rect;
}

function getDirection(target) {
  if (!target) {
    return;
  }

  var direciton = target.getAttribute("data-direction");

  if (!direciton) {
    return;
  }

  var dir = [0, 0];
  direciton.indexOf("w") > -1 && (dir[0] = -1);
  direciton.indexOf("e") > -1 && (dir[0] = 1);
  direciton.indexOf("n") > -1 && (dir[1] = -1);
  direciton.indexOf("s") > -1 && (dir[1] = 1);
  return dir;
}

function getAbsolutePoses(poses, dist) {
  return [(0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[0]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[1]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[2]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[3])];
}

function getAbsolutePosesByState(_a) {
  var left = _a.left,
      top = _a.top,
      pos1 = _a.pos1,
      pos2 = _a.pos2,
      pos3 = _a.pos3,
      pos4 = _a.pos4;
  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);
}

function roundSign(num) {
  return Math.round(num % 1 === -0.5 ? num - 1 : num);
}

function unset(self, name) {
  var _a;

  (_a = self[name]) === null || _a === void 0 ? void 0 : _a.unset();
  self[name] = null;
}

function fillParams(moveable, e, params, isBeforeEvent) {
  var datas = e.datas;

  if (!datas.datas) {
    datas.datas = {};
  }

  var nextParams = __assign(__assign({}, params), {
    target: moveable.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: moveable,
    moveable: moveable,
    datas: datas.datas
  });

  if (!datas.isStartEvent) {
    datas.isStartEvent = true;
  } else if (!isBeforeEvent) {
    datas.lastEvent = nextParams;
  }

  return nextParams;
}

function fillEndParams(moveable, e, params) {
  var datas = e.datas;
  var isDrag = "isDrag" in params ? params.isDrag : e.isDrag;

  if (!datas.datas) {
    datas.datas = {};
  }

  return __assign(__assign({
    isDrag: isDrag
  }, params), {
    moveable: moveable,
    target: moveable.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: moveable,
    lastEvent: datas.lastEvent,
    isDouble: e.isDouble,
    datas: datas.datas
  });
}

function catchEvent(moveable, name, callback) {
  moveable._emitter.on(name, callback);
}

function triggerEvent(moveable, name, params, isManager) {
  return moveable.triggerEvent(name, params, isManager);
}

function getComputedStyle(el, pseudoElt) {
  return window.getComputedStyle(el, pseudoElt);
}

function filterAbles(ables, methods, triggerAblesSimultaneously) {
  var enabledAbles = {};
  var ableGroups = {};
  return ables.filter(function (able) {
    var name = able.name;

    if (enabledAbles[name] || !methods.some(function (method) {
      return able[method];
    })) {
      return false;
    }

    if (!triggerAblesSimultaneously && able.ableGroup) {
      if (ableGroups[able.ableGroup]) {
        return false;
      }

      ableGroups[able.ableGroup] = true;
    }

    enabledAbles[name] = true;
    return true;
  });
}

function equals(a1, a2) {
  return a1 === a2 || a1 == null && a2 == null;
}

function selectValue() {
  var values = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }

  var length = values.length - 1;

  for (var i = 0; i < length; ++i) {
    var value = values[i];

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(value)) {
      return value;
    }
  }

  return values[length];
}

function groupBy(arr, func) {
  var groups = [];
  var groupKeys = [];
  arr.forEach(function (el, index) {
    var groupKey = func(el, index, arr);
    var keyIndex = groupKeys.indexOf(groupKey);
    var group = groups[keyIndex] || [];

    if (keyIndex === -1) {
      groupKeys.push(groupKey);
      groups.push(group);
    }

    group.push(el);
  });
  return groups;
}

function groupByMap(arr, func) {
  var groups = [];
  var groupKeys = {};
  arr.forEach(function (el, index) {
    var groupKey = func(el, index, arr);
    var group = groupKeys[groupKey];

    if (!group) {
      group = [];
      groupKeys[groupKey] = group;
      groups.push(group);
    }

    group.push(el);
  });
  return groups;
}

function flat(arr) {
  return arr.reduce(function (prev, cur) {
    return prev.concat(cur);
  }, []);
}

function maxOffset() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  args.sort(function (a, b) {
    return Math.abs(b) - Math.abs(a);
  });
  return args[0];
}

function calculateInversePosition(matrix, pos, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(matrix, n), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)(pos, n), n);
}

function convertDragDist(state, e) {
  var _a;

  var is3d = state.is3d,
      rootMatrix = state.rootMatrix;
  var n = is3d ? 4 : 3;
  _a = calculateInversePosition(rootMatrix, [e.distX, e.distY], n), e.distX = _a[0], e.distY = _a[1];
  return e;
}

function calculatePadding(matrix, pos, transformOrigin, origin, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(transformOrigin, pos), n), origin);
}

function convertCSSSize(value, size, isRelative) {
  return isRelative ? "".concat(value / size * 100, "%") : "".concat(value, "px");
}

function getTinyDist(v) {
  return Math.abs(v) <= TINY_NUM ? 0 : v;
}

function directionCondition(moveable, e) {
  if (e.isRequest) {
    if (e.requestAble === "resizable" || e.requestAble === "scalable") {
      return e.parentDirection;
    } else {
      return false;
    }
  }

  return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(e.inputEvent.target, prefix("direction"));
}

function invertObject(obj) {
  var nextObj = {};

  for (var name in obj) {
    nextObj[obj[name]] = name;
  }

  return nextObj;
}

function convertTransformInfo(transforms, index) {
  var beforeFunctionTexts = transforms.slice(0, index < 0 ? undefined : index);
  var beforeFunctionTexts2 = transforms.slice(0, index < 0 ? undefined : index + 1);
  var targetFunctionText = transforms[index] || "";
  var afterFunctionTexts = index < 0 ? [] : transforms.slice(index);
  var afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);
  var beforeFunctions = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.parse)(beforeFunctionTexts);
  var beforeFunctions2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.parse)(beforeFunctionTexts2);
  var targetFunctions = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.parse)([targetFunctionText]);
  var afterFunctions = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.parse)(afterFunctionTexts);
  var afterFunctions2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.parse)(afterFunctionTexts2);
  var beforeFunctionMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.toMat)(beforeFunctions);
  var beforeFunctionMatrix2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.toMat)(beforeFunctions2);
  var afterFunctionMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.toMat)(afterFunctions);
  var afterFunctionMatrix2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.toMat)(afterFunctions2);
  var allFunctionMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(beforeFunctionMatrix, afterFunctionMatrix, 4);
  return {
    transforms: transforms,
    beforeFunctionMatrix: beforeFunctionMatrix,
    beforeFunctionMatrix2: beforeFunctionMatrix2,
    targetFunctionMatrix: (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.toMat)(targetFunctions),
    afterFunctionMatrix: afterFunctionMatrix,
    afterFunctionMatrix2: afterFunctionMatrix2,
    allFunctionMatrix: allFunctionMatrix,
    beforeFunctions: beforeFunctions,
    beforeFunctions2: beforeFunctions2,
    targetFunction: targetFunctions[0],
    afterFunctions: afterFunctions,
    afterFunctions2: afterFunctions2,
    beforeFunctionTexts: beforeFunctionTexts,
    beforeFunctionTexts2: beforeFunctionTexts2,
    targetFunctionText: targetFunctionText,
    afterFunctionTexts: afterFunctionTexts,
    afterFunctionTexts2: afterFunctionTexts2
  };
}

function isArrayFormat(arr) {
  if (!arr || !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(arr)) {
    return false;
  }

  if (arr instanceof Element) {
    return false;
  }

  return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(arr) || "length" in arr;
}

function getRefTarget(target, isSelector) {
  if (!target) {
    return null;
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(target)) {
    if (isSelector) {
      return document.querySelector(target);
    }

    return target;
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target)) {
    return target();
  }

  if ("current" in target) {
    return target.current;
  }

  return target;
}

function getRefTargets(targets, isSelector) {
  if (!targets) {
    return [];
  }

  var userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];
  return userTargets.reduce(function (prev, target) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(target) && isSelector) {
      return __spreadArray(__spreadArray([], prev, true), [].slice.call(document.querySelectorAll(target)), true);
    }

    prev.push(getRefTarget(target, isSelector));
    return prev;
  }, []);
}

function getElementTargets(targets, selectorMap) {
  var elementTargets = [];
  targets.forEach(function (target) {
    if (!target) {
      return;
    }

    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(target)) {
      if (selectorMap[target]) {
        elementTargets.push.apply(elementTargets, selectorMap[target]);
      }

      return;
    }

    elementTargets.push(target);
  });
  return elementTargets;
}

function getAbsoluteRotation(pos1, pos2, direction) {
  var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(pos1, pos2) / Math.PI * 180;
  deg = direction >= 0 ? deg : 180 - deg;
  deg = deg >= 0 ? deg : 360 + deg;
  return deg;
}

function getDragDistByState(state, dist) {
  var rootMatrix = state.rootMatrix,
      is3d = state.is3d;
  var n = is3d ? 4 : 3;
  var inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(rootMatrix, n);

  if (!is3d) {
    inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(inverseMatrix, 3, 4);
  }

  inverseMatrix[12] = 0;
  inverseMatrix[13] = 0;
  inverseMatrix[14] = 0;
  return (0,css_to_mat__WEBPACK_IMPORTED_MODULE_5__.calculateMatrixDist)(inverseMatrix, dist);
}

function getSizeDistByDist(startSize, dist, ratio, direction, keepRatio) {
  var startOffsetWidth = startSize[0],
      startOffsetHeight = startSize[1];
  var distWidth = 0;
  var distHeight = 0;

  if (keepRatio && startOffsetWidth && startOffsetHeight) {
    var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)([0, 0], dist);
    var standardRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)([0, 0], direction);
    var size = getDistSize(dist);
    var signSize = Math.cos(rad - standardRad) * size;

    if (!direction[0]) {
      // top, bottom
      distHeight = signSize;
      distWidth = distHeight * ratio;
    } else if (!direction[1]) {
      // left, right
      distWidth = signSize;
      distHeight = distWidth / ratio;
    } else {
      // two-way
      var startWidthSize = direction[0] * 2 * startOffsetWidth;
      var startHeightSize = direction[1] * 2 * startOffsetHeight;
      var distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]]) - getDistSize([startWidthSize, startHeightSize]);
      var ratioRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)([0, 0], [ratio, 1]);
      distWidth = Math.cos(ratioRad) * distSize;
      distHeight = Math.sin(ratioRad) * distSize;
    }
  } else {
    distWidth = direction[0] * dist[0];
    distHeight = direction[1] * dist[1];
  }

  return [distWidth, distHeight];
}

function getOffsetSizeDist(sizeDirection, keepRatio, datas, e) {
  var _a;

  var ratio = datas.ratio,
      startOffsetWidth = datas.startOffsetWidth,
      startOffsetHeight = datas.startOffsetHeight;
  var distWidth = 0;
  var distHeight = 0;
  var distX = e.distX,
      distY = e.distY,
      parentDistance = e.parentDistance,
      parentDist = e.parentDist,
      parentScale = e.parentScale,
      isPinch = e.isPinch;
  var startFixedDirection = datas.fixedDirection;

  if (parentDist) {
    distWidth = parentDist[0];
    distHeight = parentDist[1];

    if (keepRatio) {
      if (!distWidth) {
        distWidth = distHeight * ratio;
      } else if (!distHeight) {
        distHeight = distWidth / ratio;
      }
    }
  } else if (parentScale) {
    distWidth = (parentScale[0] - 1) * startOffsetWidth;
    distHeight = (parentScale[1] - 1) * startOffsetHeight;
  } else if (isPinch) {
    if (parentDistance) {
      distWidth = parentDistance;
      distHeight = parentDistance * startOffsetHeight / startOffsetWidth;
    }
  } else {
    var dist_1 = getDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    });
    dist_1 = [0, 1].map(function (index) {
      var directionRatio = Math.abs(sizeDirection[index] - startFixedDirection[index]);

      if (directionRatio !== 0) {
        directionRatio = 2 / directionRatio;
      }

      return dist_1[index] * directionRatio;
    });
    _a = getSizeDistByDist([startOffsetWidth, startOffsetHeight], dist_1, ratio, sizeDirection, keepRatio), distWidth = _a[0], distHeight = _a[1];
  }

  return {
    // direction,
    // sizeDirection,
    distWidth: distWidth,
    distHeight: distHeight
  };
}
/**
 * @namespace Moveable.Pinchable
 * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)
 */


var Pinchable = makeAble("pinchable", {
  events: {
    onPinchStart: "pinchStart",
    onPinch: "pinch",
    onPinchEnd: "pinchEnd",
    onPinchGroupStart: "pinchGroupStart",
    onPinchGroup: "pinchGroup",
    onPinchGroupEnd: "pinchGroupEnd"
  },
  dragStart: function () {
    return true;
  },
  pinchStart: function (moveable, e) {
    var datas = e.datas,
        targets = e.targets,
        angle = e.angle,
        originalDatas = e.originalDatas;
    var _a = moveable.props,
        pinchable = _a.pinchable,
        ables = _a.ables;

    if (!pinchable) {
      return false;
    }

    var eventName = "onPinch".concat(targets ? "Group" : "", "Start");
    var controlEventName = "drag".concat(targets ? "Group" : "", "ControlStart");
    var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function (able) {
      return pinchable.indexOf(able.name) > -1;
    })).filter(function (able) {
      return able.canPinch && able[controlEventName];
    });
    var params = fillParams(moveable, e, {});

    if (targets) {
      params.targets = targets;
    }

    var result = triggerEvent(moveable, eventName, params);
    datas.isPinch = result !== false;
    datas.ables = pinchAbles;
    var isPinch = datas.isPinch;

    if (!isPinch) {
      return false;
    }

    pinchAbles.forEach(function (able) {
      originalDatas[able.name] = originalDatas[able.name] || {};

      if (!able[controlEventName]) {
        return;
      }

      var ableEvent = __assign(__assign({}, e), {
        datas: originalDatas[able.name],
        parentRotate: angle,
        isPinch: true
      });

      able[controlEventName](moveable, ableEvent);
    });
    moveable.state.snapRenderInfo = {
      request: e.isRequest,
      direction: [0, 0]
    };
    return isPinch;
  },
  pinch: function (moveable, e) {
    var datas = e.datas,
        pinchScale = e.scale,
        distance = e.distance,
        originalDatas = e.originalDatas,
        inputEvent = e.inputEvent,
        targets = e.targets,
        angle = e.angle;

    if (!datas.isPinch) {
      return;
    }

    var parentDistance = distance * (1 - 1 / pinchScale);
    var params = fillParams(moveable, e, {});

    if (targets) {
      params.targets = targets;
    }

    var eventName = "onPinch".concat(targets ? "Group" : "");
    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag".concat(targets ? "Group" : "", "Control");
    ables.forEach(function (able) {
      if (!able[controlEventName]) {
        return;
      }

      able[controlEventName](moveable, __assign(__assign({}, e), {
        datas: originalDatas[able.name],
        inputEvent: inputEvent,
        parentDistance: parentDistance,
        parentRotate: angle,
        isPinch: true
      }));
    });
    return params;
  },
  pinchEnd: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        inputEvent = e.inputEvent,
        targets = e.targets,
        originalDatas = e.originalDatas;

    if (!datas.isPinch) {
      return;
    }

    var eventName = "onPinch".concat(targets ? "Group" : "", "End");
    var params = fillEndParams(moveable, e, {
      isDrag: isPinch
    });

    if (targets) {
      params.targets = targets;
    }

    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag".concat(targets ? "Group" : "", "ControlEnd");
    ables.forEach(function (able) {
      if (!able[controlEventName]) {
        return;
      }

      able[controlEventName](moveable, __assign(__assign({}, e), {
        isDrag: isPinch,
        datas: originalDatas[able.name],
        inputEvent: inputEvent,
        isPinch: true
      }));
    });
    return isPinch;
  },
  pinchGroupStart: function (moveable, e) {
    return this.pinchStart(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  pinchGroup: function (moveable, e) {
    return this.pinch(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  pinchGroupEnd: function (moveable, e) {
    return this.pinchEnd(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  }
});
/**
 * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)
 * @name Moveable.Pinchable#pinchable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.pinchable = true;
 */

/**
 * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart
 * @memberof Moveable.Pinchable
 * @event pinchStart
 * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinchStart", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotateStart", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scaleStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When pinching, the pinch event is called with part of scale, rotate, resize
 * @memberof Moveable.Pinchable
 * @event pinch
 * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinch", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotate", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scale", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When the pinch finishes, the pinchEnd event is called.
 * @memberof Moveable.Pinchable
 * @event pinchEnd
 * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinchEnd", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotateEnd", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scaleEnd", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When the group pinch starts, the `pinchGroupStart` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroupStart
 * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroupStart", ({ targets }) => {
 *     console.log("onPinchGroupStart", targets);
 * });
 */

/**
 * When the group pinch, the `pinchGroup` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroup
 * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroup", ({ targets, events }) => {
 *     console.log("onPinchGroup", targets);
 * });
 */

/**
 * When the group pinch finishes, the `pinchGroupEnd` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroupEnd
 * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onPinchGroupEnd", targets, isDrag);
 * });
 */

/**
 * @namespace Resizable
 * @memberof Moveable
 * @description Resizable indicates whether the target's width and height can be increased or decreased.
 */

var Resizable = {
  name: "resizable",
  ableGroup: "size",
  canPinch: true,
  props: {
    resizable: Boolean,
    throttleResize: Number,
    renderDirections: Array,
    keepRatio: Boolean,
    resizeFormat: Function
  },
  events: {
    onResizeStart: "resizeStart",
    onBeforeResize: "beforeResize",
    onResize: "resize",
    onResizeEnd: "resizeEnd",
    onResizeGroupStart: "resizeGroupStart",
    onBeforeResizeGroup: "beforeResizeGroup",
    onResizeGroup: "resizeGroup",
    onResizeGroupEnd: "resizeGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        edge = _a.edge;

    if (resizable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }

      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function (moveable, e) {
    var _a;

    var inputEvent = e.inputEvent,
        isPinch = e.isPinch,
        isGroup = e.isGroup,
        parentDirection = e.parentDirection,
        datas = e.datas;
    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _b = moveable.state,
        target = _b.target,
        width = _b.width,
        height = _b.height;

    if (!direction || !target) {
      return false;
    }

    !isPinch && setDragStart(moveable, e);
    datas.datas = {};
    datas.direction = direction;
    datas.startOffsetWidth = width;
    datas.startOffsetHeight = height;
    datas.prevWidth = 0;
    datas.prevHeight = 0;
    _a = getCSSSize(target), datas.startWidth = _a[0], datas.startHeight = _a[1];
    var padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];
    datas.minSize = padding;
    datas.maxSize = [Infinity, Infinity];

    if (!isGroup) {
      var style = getComputedStyle(target);
      var position = style.position,
          minWidth = style.minWidth,
          minHeight = style.minHeight,
          maxWidth = style.maxWidth,
          maxHeight = style.maxHeight;
      var isParentElement = position === "static" || position === "relative";
      var container = isParentElement ? target.parentElement : target.offsetParent;
      var containerWidth = width;
      var containerHeight = height;

      if (container) {
        containerWidth = container.clientWidth;
        containerHeight = container.clientHeight;

        if (isParentElement) {
          var containerStyle = getComputedStyle(container);
          containerWidth -= parseFloat(containerStyle.paddingLeft) || 0;
          containerHeight -= parseFloat(containerStyle.paddingTop) || 0;
        }
      }

      datas.minSize = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)([(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(minWidth, containerWidth) || 0, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(minHeight, containerHeight) || 0], padding);
      datas.maxSize = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)([(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(maxWidth, containerWidth) || Infinity, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(maxHeight, containerHeight) || Infinity], padding);
    }

    var transformOrigin = moveable.props.transformOrigin || "% %";
    datas.transformOrigin = transformOrigin && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(transformOrigin) ? transformOrigin.split(" ") : transformOrigin;
    datas.isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];

    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }

    datas.startPositions = getAbsolutePosesByState(moveable.state);

    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);
    }

    function setMin(minSize) {
      datas.minSize = [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)("".concat(minSize[0]), 0) || 0, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)("".concat(minSize[1]), 0) || 0];
    }

    function setMax(maxSize) {
      var nextMaxSize = [maxSize[0] || Infinity, maxSize[1] || Infinity];

      if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(nextMaxSize[0]) || isFinite(nextMaxSize[0])) {
        nextMaxSize[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)("".concat(nextMaxSize[0]), 0) || Infinity;
      }

      if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(nextMaxSize[1]) || isFinite(nextMaxSize[1])) {
        nextMaxSize[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)("".concat(nextMaxSize[1]), 0) || Infinity;
      }

      datas.maxSize = nextMaxSize;
    }

    setRatio(width / height);
    setFixedDirection([-direction[0], -direction[1]]);
    datas.setFixedDirection = setFixedDirection;
    datas.setMin = setMin;
    datas.setMax = setMax;
    var params = fillParams(moveable, e, {
      direction: direction,
      set: function (_a) {
        var startWidth = _a[0],
            startHeight = _a[1];
        datas.startWidth = startWidth;
        datas.startHeight = startHeight;
      },
      setMin: setMin,
      setMax: setMax,
      setRatio: setRatio,
      setFixedDirection: setFixedDirection,
      setOrigin: function (origin) {
        datas.transformOrigin = origin;
      },
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    });
    var result = triggerEvent(moveable, "onResizeStart", params);

    if (result !== false) {
      datas.isResize = true;
      moveable.state.snapRenderInfo = {
        request: e.isRequest,
        direction: direction
      };
    }

    return datas.isResize ? params : false;
  },
  dragControl: function (moveable, e) {
    var _a;

    var datas = e.datas,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        parentKeepRatio = e.parentKeepRatio,
        dragClient = e.dragClient,
        parentDist = e.parentDist,
        isRequest = e.isRequest;
    var isResize = datas.isResize,
        transformOrigin = datas.transformOrigin,
        startWidth = datas.startWidth,
        startHeight = datas.startHeight,
        prevWidth = datas.prevWidth,
        prevHeight = datas.prevHeight,
        minSize = datas.minSize,
        maxSize = datas.maxSize,
        ratio = datas.ratio,
        isWidth = datas.isWidth,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight;

    if (!isResize) {
      return;
    }

    var props = moveable.props;
    var resizeFormat = props.resizeFormat,
        _b = props.throttleResize,
        throttleResize = _b === void 0 ? 1 : _b,
        parentMoveable = props.parentMoveable;
    var direction = datas.direction;
    var sizeDirection = direction;
    var distWidth = 0;
    var distHeight = 0;

    if (!direction[0] && !direction[1]) {
      sizeDirection = [1, 1];
    }

    var keepRatio = ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio) || false;

    function getNextBoundingSize() {
      var nextSize = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);
      distWidth = nextSize.distWidth;
      distHeight = nextSize.distHeight;
      var nextWidth = sizeDirection[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;
      var nextHeight = sizeDirection[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;

      if (keepRatio && startOffsetWidth && startOffsetHeight) {
        // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight
        if (isWidth) {
          nextHeight = nextWidth / ratio;
        } else {
          nextWidth = nextHeight * ratio;
        }
      }

      return [nextWidth, nextHeight];
    }

    var _c = getNextBoundingSize(),
        boundingWidth = _c[0],
        boundingHeight = _c[1];

    datas.setFixedDirection(datas.fixedDirection);
    triggerEvent(moveable, "onBeforeResize", fillParams(moveable, e, {
      setFixedDirection: function (nextFixedDirection) {
        var _a;

        datas.setFixedDirection(nextFixedDirection);
        _a = getNextBoundingSize(), boundingWidth = _a[0], boundingHeight = _a[1];
        return [boundingWidth, boundingHeight];
      },
      boundingWidth: boundingWidth,
      boundingHeight: boundingHeight,
      setSize: function (size) {
        boundingWidth = size[0], boundingHeight = size[1];
      }
    }, true));
    var fixedPosition = dragClient;

    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }

    var snapDist = [0, 0];

    if (!isPinch) {
      snapDist = checkSnapResize(moveable, boundingWidth, boundingHeight, direction, fixedPosition, isRequest, datas);
    }

    if (parentDist) {
      !parentDist[0] && (snapDist[0] = 0);
      !parentDist[1] && (snapDist[1] = 0);
    }

    function computeSize() {
      var _a;

      if (resizeFormat) {
        _a = resizeFormat([boundingWidth, boundingHeight]), boundingWidth = _a[0], boundingHeight = _a[1];
      }

      boundingWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(boundingWidth, throttleResize);
      boundingHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(boundingHeight, throttleResize);
    }

    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }

      var isNoSnap = !snapDist[0] && !snapDist[1];

      if (isNoSnap) {
        // pre-compute before maintaining the ratio
        computeSize();
      }

      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        boundingWidth += snapDist[0];
        boundingHeight = boundingWidth / ratio;
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        boundingHeight += snapDist[1];
        boundingWidth = boundingHeight * ratio;
      }
    } else {
      boundingWidth += snapDist[0];
      boundingHeight += snapDist[1];
      boundingWidth = Math.max(0, boundingWidth);
      boundingHeight = Math.max(0, boundingHeight);
    }

    _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.calculateBoundSize)([boundingWidth, boundingHeight], minSize, maxSize, keepRatio ? ratio : false), boundingWidth = _a[0], boundingHeight = _a[1];
    computeSize();
    distWidth = boundingWidth - startOffsetWidth;
    distHeight = boundingHeight - startOffsetHeight;
    var delta = [distWidth - prevWidth, distHeight - prevHeight];
    datas.prevWidth = distWidth;
    datas.prevHeight = distHeight;
    var inverseDelta = getResizeDist(moveable, boundingWidth, boundingHeight, datas.fixedDirection, fixedPosition, transformOrigin);

    if (!parentMoveable && delta.every(function (num) {
      return !num;
    }) && inverseDelta.every(function (num) {
      return !num;
    })) {
      return;
    }

    var params = fillParams(moveable, e, {
      width: startWidth + distWidth,
      height: startHeight + distHeight,
      offsetWidth: Math.round(boundingWidth),
      offsetHeight: Math.round(boundingHeight),
      boundingWidth: boundingWidth,
      boundingHeight: boundingHeight,
      direction: direction,
      dist: [distWidth, distHeight],
      delta: delta,
      isPinch: !!isPinch,
      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onResize", params);
    return params;
  },
  dragControlAfter: function (moveable, e) {
    var datas = e.datas;
    var isResize = datas.isResize,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight,
        prevWidth = datas.prevWidth,
        prevHeight = datas.prevHeight;

    if (!isResize) {
      return;
    }

    var _a = moveable.state,
        width = _a.width,
        height = _a.height;
    var errorWidth = width - (startOffsetWidth + prevWidth);
    var errorHeight = height - (startOffsetHeight + prevHeight);
    var isErrorWidth = Math.abs(errorWidth) > 3;
    var isErrorHeight = Math.abs(errorHeight) > 3;

    if (isErrorWidth) {
      datas.startWidth += errorWidth;
      datas.startOffsetWidth += errorWidth;
      datas.prevWidth += errorWidth;
    }

    if (isErrorHeight) {
      datas.startHeight += errorHeight;
      datas.startOffsetHeight += errorHeight;
      datas.prevHeight += errorHeight;
    }

    if (isErrorWidth || isErrorHeight) {
      return this.dragControl(moveable, e);
    }
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    datas.isResize = false;
    var params = fillEndParams(moveable, e, {});
    triggerEvent(moveable, "onResizeEnd", params);
    return params;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, __assign(__assign({}, e), {
      isGroup: true
    }));

    if (!params) {
      return false;
    }

    var originalEvents = fillChildEvents(moveable, "resizable", e);

    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);
      var pos = getPosByDirection(startPositions, fixedDirection);

      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createRotateMatrix)(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),
          originalX = _a[0],
          originalY = _a[1];

      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }

    var parentStartOffsetWidth = datas.startOffsetWidth,
        parentStartOffsetHeight = datas.startOffsetHeight;

    function updateGroupMin() {
      var originalMinSize = datas.minSize;
      originalEvents.forEach(function (ev) {
        var _a = ev.datas,
            childMinSize = _a.minSize,
            childStartOffsetWidth = _a.startOffsetWidth,
            childStartOffsetHeight = _a.startOffsetHeight;
        var parentMinWidth = parentStartOffsetWidth * (childStartOffsetWidth ? childMinSize[0] / childStartOffsetWidth : 0);
        var parentMinHeight = parentStartOffsetHeight * (childStartOffsetHeight ? childMinSize[1] / childStartOffsetHeight : 0);
        originalMinSize[0] = Math.max(originalMinSize[0], parentMinWidth);
        originalMinSize[1] = Math.max(originalMinSize[1], parentMinHeight);
      });
    }

    function updateGroupMax() {
      var originalMaxSize = datas.maxSize;
      originalEvents.forEach(function (ev) {
        var _a = ev.datas,
            childMaxSize = _a.maxSize,
            childStartOffsetWidth = _a.startOffsetWidth,
            childStartOffsetHeight = _a.startOffsetHeight;
        var parentMaxWidth = parentStartOffsetWidth * (childStartOffsetWidth ? childMaxSize[0] / childStartOffsetWidth : 0);
        var parentMaxHeight = parentStartOffsetHeight * (childStartOffsetHeight ? childMaxSize[1] / childStartOffsetHeight : 0);
        originalMaxSize[0] = Math.min(originalMaxSize[0], parentMaxWidth);
        originalMaxSize[1] = Math.min(originalMaxSize[1], parentMaxHeight);
      });
    }

    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      return setDist(child, ev);
    });
    updateGroupMin();
    updateGroupMax();

    var setFixedDirection = function (fixedDirection) {
      params.setFixedDirection(fixedDirection);
      events.forEach(function (ev, i) {
        ev.setFixedDirection(fixedDirection);
        setDist(ev.moveable, originalEvents[i]);
      });
    };

    datas.setFixedDirection = setFixedDirection;

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events.map(function (ev) {
        return __assign(__assign({}, ev), {
          setMin: function (minSize) {
            ev.setMin(minSize);
            updateGroupMin();
          },
          setMax: function (maxSize) {
            ev.setMax(maxSize);
            updateGroupMax();
          }
        });
      }),
      setFixedDirection: setFixedDirection,
      setMin: function (minSize) {
        params.setMin(minSize);
        updateGroupMin();
      },
      setMax: function (maxSize) {
        params.setMax(maxSize);
        updateGroupMax();
      }
    });

    var result = triggerEvent(moveable, "onResizeGroupStart", nextParams);
    datas.isResize = result !== false;
    return datas.isResize ? params : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    catchEvent(moveable, "onBeforeResize", function (parentEvent) {
      triggerEvent(moveable, "onBeforeResizeGroup", fillParams(moveable, e, __assign(__assign({}, parentEvent), {
        targets: moveable.props.targets
      }), true));
    });
    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var boundingWidth = params.boundingWidth,
        boundingHeight = params.boundingHeight,
        dist = params.dist;
    var keepRatio = moveable.props.keepRatio;
    var parentScale = [boundingWidth / (boundingWidth - dist[0]), boundingHeight / (boundingHeight - dist[1])];
    var fixedPosition = datas.fixedPosition;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createRotateMatrix)(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * parentScale[0], ev.datas.originalY * parentScale[1], 1], 3),
          clientX = _a[0],
          clientY = _a[1];

      return __assign(__assign({}, ev), {
        parentDist: null,
        parentScale: parentScale,
        dragClient: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(fixedPosition, [clientX, clientY]),
        parentKeepRatio: keepRatio
      });
    });

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onResizeGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onResizeGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Resizable#request
   * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("resizable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    var rect = moveable.getRect();
    return {
      isControl: true,
      requestStart: function (e) {
        return {
          datas: datas,
          parentDirection: e.direction || [1, 1]
        };
      },
      request: function (e) {
        if ("offsetWidth" in e) {
          distWidth = e.offsetWidth - rect.offsetWidth;
        } else if ("deltaWidth" in e) {
          distWidth += e.deltaWidth;
        }

        if ("offsetHeight" in e) {
          distHeight = e.offsetHeight - rect.offsetHeight;
        } else if ("deltaHeight" in e) {
          distHeight += e.deltaHeight;
        }

        return {
          datas: datas,
          parentDist: [distWidth, distHeight],
          parentKeepRatio: e.keepRatio
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can be resized.
 * @name Moveable.Resizable#resizable
 * @default false
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     resizable: false,
 * });
 *
 * moveable.resizable = true;
 */

/**
 * throttle of width, height when resize. If throttleResize is set to less than 1, the target may shake.
 * @name Moveable.Resizable#throttleResize
 * @default 1
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 *   throttleResize: 1,
 * });
 *
 * moveable.throttleResize = 0;
 */

/**
 * When resize or scale, keeps a ratio of the width, height.
 * @name Moveable.Resizable#keepRatio
 * @default false
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 * });
 *
 * moveable.keepRatio = true;
 */

/**
 * Set directions to show the control box.
 * @name Moveable.Resizable#renderDirections
 * @default ["n", "nw", "ne", "s", "se", "sw", "e", "w"]
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 *   renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
 * });
 *
 * moveable.renderDirections = ["nw", "ne", "sw", "se"];
 */

/**
 * Function to convert size for resize
 * @name Moveable.Resizable#resizeFormat
 * @default oneself
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 *   resizeFormat: v => v,
 * });
 *
 * moveable.resizeFormat = (size: number[]) => ([Math.trunc(size[0]), Math.trunc(size[1])];
 */

/**
 * When the resize starts, the resizeStart event is called.
 * @memberof Moveable.Resizable
 * @event resizeStart
 * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resizeStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When resizing, `beforeResize` is called before `resize` occurs. In `beforeResize`, you can get and set the pre-value before resizing.
 * @memberof Moveable.Resizable
 * @event beforeResize
 * @param {Moveable.Resizable.OnBeforeResize} - Parameters for the `beforeResize` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("beforeResize", ({ setFixedDirection }) => {
 *     if (shiftKey) {
 *        setFixedDirection([0, 0]);
 *     }
 * });
 * moveable.on("resize", ({ target, width, height, drag }) => {
 *     target.style.width = `${width}px`;
 *     target.style.height = `${height}px`;
 *     target.style.transform = drag.transform;
 * });
 */

/**
 * When resizing, the resize event is called.
 * @memberof Moveable.Resizable
 * @event resize
 * @param {Moveable.Resizable.OnResize} - Parameters for the resize event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resize", ({ target, width, height }) => {
 *     target.style.width = `${e.width}px`;
 *     target.style.height = `${e.height}px`;
 * });
 */

/**
 * When the resize finishes, the resizeEnd event is called.
 * @memberof Moveable.Resizable
 * @event resizeEnd
 * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resizeEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group resize starts, the `resizeGroupStart` event is called.
* @memberof Moveable.Resizable
* @event resizeGroupStart
* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     resizable: true
* });
* moveable.on("resizeGroupStart", ({ targets }) => {
*     console.log("onResizeGroupStart", targets);
* });
*/

/**
* When the group resize, the `resizeGroup` event is called.
* @memberof Moveable.Resizable
* @event resizeGroup
* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     resizable: true
* });
* moveable.on("resizeGroup", ({ targets, events }) => {
*     console.log("onResizeGroup", targets);
*     events.forEach(ev => {
*         const offset = [
*             direction[0] < 0 ? -ev.delta[0] : 0,
*             direction[1] < 0 ? -ev.delta[1] : 0,
*         ];
*         // ev.drag is a drag event that occurs when the group resize.
*         const left = offset[0] + ev.drag.beforeDist[0];
*         const top = offset[1] + ev.drag.beforeDist[1];
*         const width = ev.width;
*         const top = ev.top;
*     });
* });
*/

/**
 * When the group resize finishes, the `resizeGroupEnd` event is called.
 * @memberof Moveable.Resizable
 * @event resizeGroupEnd
 * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     resizable: true
 * });
 * moveable.on("resizeGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onResizeGroupEnd", targets, isDrag);
 * });
 */

/**
 * @namespace Scalable
 * @memberof Moveable
 * @description Scalable indicates whether the target's x and y can be scale of transform.
 */

var Scalable = {
  name: "scalable",
  ableGroup: "size",
  canPinch: true,
  props: {
    scalable: Boolean,
    throttleScale: Number,
    renderDirections: String,
    keepRatio: Boolean
  },
  events: {
    onScaleStart: "scaleStart",
    onBeforeScale: "beforeScale",
    onScale: "scale",
    onScaleEnd: "scaleEnd",
    onScaleGroupStart: "scaleGroupStart",
    onBeforeScaleGroup: "beforeScaleGroup",
    onScaleGroup: "scaleGroup",
    onScaleGroupEnd: "scaleGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        scalable = _a.scalable,
        edge = _a.edge;

    if (!resizable && scalable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }

      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        inputEvent = e.inputEvent,
        parentDirection = e.parentDirection;
    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _a = moveable.state,
        width = _a.width,
        height = _a.height,
        targetTransform = _a.targetTransform,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos4 = _a.pos4;

    if (!direction || !target) {
      return false;
    }

    if (!isPinch) {
      setDragStart(moveable, e);
    }

    datas.datas = {};
    datas.transform = targetTransform;
    datas.prevDist = [1, 1];
    datas.direction = direction;
    datas.startOffsetWidth = width;
    datas.startOffsetHeight = height;
    datas.startValue = [1, 1];
    var scaleWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(pos1, pos2);
    var scaleHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(pos2, pos4);
    var isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];
    datas.scaleWidth = scaleWidth;
    datas.scaleHeight = scaleHeight;
    datas.scaleXRatio = scaleWidth / width;
    datas.scaleYRatio = scaleHeight / height;
    setDefaultTransformIndex(e, "scale");
    datas.isWidth = isWidth;

    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }

    datas.startPositions = getAbsolutePosesByState(moveable.state);

    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);
    }

    datas.setFixedDirection = setFixedDirection;
    setRatio((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(pos1, pos2) / (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(pos2, pos4));
    setFixedDirection([-direction[0], -direction[1]]);
    var params = fillParams(moveable, e, __assign(__assign({
      direction: direction,
      set: function (scale) {
        datas.startValue = scale;
      },
      setRatio: setRatio,
      setFixedDirection: setFixedDirection
    }, fillTransformStartEvent(e)), {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    }));
    var result = triggerEvent(moveable, "onScaleStart", params);

    if (result !== false) {
      datas.isScale = true;
      moveable.state.snapRenderInfo = {
        request: e.isRequest,
        direction: direction
      };
    }

    return datas.isScale ? params : false;
  },
  dragControl: function (moveable, e) {
    resolveTransformEvent(e, "scale");
    var datas = e.datas,
        parentKeepRatio = e.parentKeepRatio,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        dragClient = e.dragClient,
        isRequest = e.isRequest;
    var prevDist = datas.prevDist,
        direction = datas.direction,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight,
        isScale = datas.isScale,
        startValue = datas.startValue,
        isWidth = datas.isWidth,
        ratio = datas.ratio;

    if (!isScale) {
      return false;
    }

    var props = moveable.props;
    var throttleScale = props.throttleScale,
        parentMoveable = props.parentMoveable;
    var sizeDirection = direction;

    if (!direction[0] && !direction[1]) {
      sizeDirection = [1, 1];
    }

    var keepRatio = ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio) || false;
    var state = moveable.state;

    function getNextScale() {
      var _a = getOffsetSizeDist(sizeDirection, keepRatio, datas, e),
          distWidth = _a.distWidth,
          distHeight = _a.distHeight;

      var scaleX = (startOffsetWidth + distWidth) / startOffsetWidth;
      var scaleY = (startOffsetHeight + distHeight) / startOffsetHeight;
      scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];
      scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];

      if (scaleX === 0) {
        scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
      }

      if (scaleY === 0) {
        scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
      }

      return [scaleX, scaleY];
    }

    var scale = getNextScale();

    if (!isPinch && moveable.props.groupable) {
      var snapRenderInfo = state.snapRenderInfo || {};
      var stateDirection = snapRenderInfo.direction;

      if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(stateDirection) && (stateDirection[0] || stateDirection[1])) {
        state.snapRenderInfo = {
          direction: direction,
          request: e.isRequest
        };
      }
    }

    triggerEvent(moveable, "onBeforeScale", fillParams(moveable, e, {
      scale: scale,
      setFixedDirection: function (nextFixedDirection) {
        datas.setFixedDirection(nextFixedDirection);
        scale = getNextScale();
        return scale;
      },
      setScale: function (nextScale) {
        scale = nextScale;
      }
    }, true));
    var dist = [scale[0] / startValue[0], scale[1] / startValue[1]];
    var fixedPosition = dragClient;
    var snapDist = [0, 0];

    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }

    if (!isPinch) {
      snapDist = checkSnapScale(moveable, dist, direction, isRequest, datas);
    }

    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0] * startOffsetWidth) > Math.abs(snapDist[1] * startOffsetHeight)) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }

      var isNoSnap = !snapDist[0] && !snapDist[1];

      if (isNoSnap) {
        if (isWidth) {
          dist[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(dist[0] * startValue[0], throttleScale) / startValue[0];
        } else {
          dist[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(dist[1] * startValue[1], throttleScale) / startValue[1];
        }
      }

      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        dist[0] += snapDist[0];
        var snapHeight = startOffsetWidth * dist[0] * startValue[0] / ratio;
        dist[1] = snapHeight / startOffsetHeight / startValue[1];
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        dist[1] += snapDist[1];
        var snapWidth = startOffsetHeight * dist[1] * startValue[1] * ratio;
        dist[0] = snapWidth / startOffsetWidth / startValue[0];
      }
    } else {
      dist[0] += snapDist[0];
      dist[1] += snapDist[1];

      if (!snapDist[0]) {
        dist[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(dist[0] * startValue[0], throttleScale) / startValue[0];
      }

      if (!snapDist[1]) {
        dist[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(dist[1] * startValue[1], throttleScale) / startValue[1];
      }
    }

    if (dist[0] === 0) {
      dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }

    if (dist[1] === 0) {
      dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }

    var delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];
    scale = multiply2(dist, startValue);
    var inverseDist = getScaleDist(moveable, dist, datas.fixedDirection, fixedPosition, datas);
    var inverseDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(inverseDist, datas.prevInverseDist || [0, 0]);
    datas.prevDist = dist;
    datas.prevInverseDist = inverseDist;

    if (scale[0] === prevDist[0] && scale[1] === prevDist[1] && inverseDelta.every(function (num) {
      return !num;
    }) && !parentMoveable) {
      return false;
    }

    var nextTransform = convertTransformFormat(datas, "scale(".concat(scale.join(", "), ")"), "scale(".concat(dist.join(", "), ")"));
    var params = fillParams(moveable, e, __assign({
      offsetWidth: startOffsetWidth,
      offsetHeight: startOffsetHeight,
      direction: direction,
      scale: scale,
      dist: dist,
      delta: delta,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));
    triggerEvent(moveable, "onScale", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isScale) {
      return false;
    }

    datas.isScale = false;
    triggerEvent(moveable, "onScaleEnd", fillEndParams(moveable, e, {}));
    return isDrag;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    var originalEvents = fillChildEvents(moveable, "resizable", e);

    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);
      var pos = getPosByDirection(startPositions, fixedDirection);

      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createRotateMatrix)(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),
          originalX = _a[0],
          originalY = _a[1];

      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }

    datas.moveableScale = moveable.scale;
    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      return setDist(child, ev);
    });

    var setFixedDirection = function (fixedDirection) {
      params.setFixedDirection(fixedDirection);
      events.forEach(function (ev, i) {
        ev.setFixedDirection(fixedDirection);
        setDist(ev.moveable, originalEvents[i]);
      });
    };

    datas.setFixedDirection = setFixedDirection;

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events,
      setFixedDirection: setFixedDirection
    });

    var result = triggerEvent(moveable, "onScaleGroupStart", nextParams);
    datas.isScale = result !== false;
    return datas.isScale ? nextParams : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isScale) {
      return;
    }

    catchEvent(moveable, "onBeforeScale", function (parentEvent) {
      triggerEvent(moveable, "onBeforeScaleGroup", fillParams(moveable, e, __assign(__assign({}, parentEvent), {
        targets: moveable.props.targets
      }), true));
    });
    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var moveableScale = datas.moveableScale;
    moveable.scale = [params.scale[0] * moveableScale[0], params.scale[1] * moveableScale[1]];
    var keepRatio = moveable.props.keepRatio;
    var dist = params.dist,
        scale = params.scale;
    var fixedPosition = datas.fixedPosition;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createRotateMatrix)(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * dist[0], ev.datas.originalY * dist[1], 1], 3),
          clientX = _a[0],
          clientY = _a[1];

      return __assign(__assign({}, ev), {
        parentDist: null,
        parentScale: scale,
        parentKeepRatio: keepRatio,
        dragClient: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(fixedPosition, [clientX, clientY])
      });
    });

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onScaleGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isScale) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onScaleGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Scalable#request
   * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("scalable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("scalable");
   *
   * // request
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function () {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    return {
      isControl: true,
      requestStart: function (e) {
        return {
          datas: datas,
          parentDirection: e.direction || [1, 1]
        };
      },
      request: function (e) {
        distWidth += e.deltaWidth;
        distHeight += e.deltaHeight;
        return {
          datas: datas,
          parentDist: [distWidth, distHeight],
          parentKeepRatio: e.keepRatio
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can scaled.
 *
 * @name Moveable.Scalable#scalable
 * @default false
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.scalable = true;
 */

/**
 * throttle of scaleX, scaleY when scale.
 * @name Moveable.Scalable#throttleScale
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleScale = 0.1;
 */

/**
 * Set directions to show the control box. (default: ["n", "nw", "ne", "s", "se", "sw", "e", "w"])
 * @name Moveable.Scalable#renderDirections
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     scalable: true,
 *   renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
 * });
 *
 * moveable.renderDirections = ["nw", "ne", "sw", "se"];
 */

/**
 * When resize or scale, keeps a ratio of the width, height. (default: false)
 * @name Moveable.Scalable#keepRatio
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     scalable: true,
 * });
 *
 * moveable.keepRatio = true;
 */

/**
 * When the scale starts, the scaleStart event is called.
 * @memberof Moveable.Scalable
 * @event scaleStart
 * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scaleStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When scaling, `beforeScale` is called before `scale` occurs. In `beforeScale`, you can get and set the pre-value before scaling.
 * @memberof Moveable.Scalable
 * @event beforeScale
 * @param {Moveable.Scalable.OnBeforeScale} - Parameters for the `beforeScale` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("beforeScale", ({ setFixedDirection }) => {
 *     if (shiftKey) {
 *        setFixedDirection([0, 0]);
 *     }
 * });
 * moveable.on("scale", ({ target, transform, dist }) => {
 *     target.style.transform = transform;
 * });
 */

/**
 * When scaling, the `scale` event is called.
 * @memberof Moveable.Scalable
 * @event scale
 * @param {Moveable.Scalable.OnScale} - Parameters for the `scale` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scale", ({ target, transform, dist }) => {
 *     target.style.transform = transform;
 * });
 */

/**
 * When the scale finishes, the `scaleEnd` event is called.
 * @memberof Moveable.Scalable
 * @event scaleEnd
 * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the `scaleEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scaleEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group scale starts, the `scaleGroupStart` event is called.
* @memberof Moveable.Scalable
* @event scaleGroupStart
* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     scalable: true
* });
* moveable.on("scaleGroupStart", ({ targets }) => {
*     console.log("onScaleGroupStart", targets);
* });
*/

/**
* When the group scale, the `scaleGroup` event is called.
* @memberof Moveable.Scalable
* @event scaleGroup
* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     scalable: true
* });
* moveable.on("scaleGroup", ({ targets, events }) => {
*     console.log("onScaleGroup", targets);
*     events.forEach(ev => {
*         const target = ev.target;
*         // ev.drag is a drag event that occurs when the group scale.
*         const left = ev.drag.beforeDist[0];
*         const top = ev.drag.beforeDist[1];
*         const scaleX = ev.scale[0];
*         const scaleY = ev.scale[1];
*     });
* });
*/

/**
 * When the group scale finishes, the `scaleGroupEnd` event is called.
 * @memberof Moveable.Scalable
 * @event scaleGroupEnd
 * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     scalable: true
 * });
 * moveable.on("scaleGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onScaleGroupEnd", targets, isDrag);
 * });
 */

function getMiddleLinePos(pos1, pos2) {
  return pos1.map(function (pos, i) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.dot)(pos, pos2[i], 1, 2);
  });
}

function getTriangleRad(pos1, pos2, pos3) {
  // pos1 Rad
  var rad1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(pos1, pos2);
  var rad2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(pos1, pos3);
  var rad = rad2 - rad1;
  return rad >= 0 ? rad : rad + 2 * Math.PI;
}

function isValidPos(poses1, poses2) {
  var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);
  var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);
  var pi = Math.PI;

  if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {
    return false;
  }

  return true;
}
/**
 * @namespace Moveable.Warpable
 * @description Warpable indicates whether the target can be warped(distorted, bented).
 */


var Warpable = {
  name: "warpable",
  ableGroup: "size",
  props: {
    warpable: Boolean,
    renderDirections: Array
  },
  events: {
    onWarpStart: "warpStart",
    onWarp: "warp",
    onWarpEnd: "warpEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        scalable = _a.scalable,
        warpable = _a.warpable,
        zoom = _a.zoom;

    if (resizable || scalable || !warpable) {
      return [];
    }

    var _b = moveable.state,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4;
    var linePosFrom1 = getMiddleLinePos(pos1, pos2);
    var linePosFrom2 = getMiddleLinePos(pos2, pos1);
    var linePosFrom3 = getMiddleLinePos(pos1, pos3);
    var linePosFrom4 = getMiddleLinePos(pos3, pos1);
    var linePosTo1 = getMiddleLinePos(pos3, pos4);
    var linePosTo2 = getMiddleLinePos(pos4, pos3);
    var linePosTo3 = getMiddleLinePos(pos2, pos4);
    var linePosTo4 = getMiddleLinePos(pos4, pos2);
    return __spreadArray([React.createElement("div", {
      className: prefix("line"),
      key: "middeLine1",
      style: getLineStyle(linePosFrom1, linePosTo1, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine2",
      style: getLineStyle(linePosFrom2, linePosTo2, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine3",
      style: getLineStyle(linePosFrom3, linePosTo3, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine4",
      style: getLineStyle(linePosFrom4, linePosTo4, zoom)
    })], renderAllDirections(moveable, React), true);
  },
  dragControlCondition: function (moveable, e) {
    if (e.isRequest) {
      return false;
    }

    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(e.inputEvent.target, prefix("direction"));
  },
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        inputEvent = e.inputEvent;
    var target = moveable.props.target;
    var inputTarget = inputEvent.target;
    var direction = getDirection(inputTarget);

    if (!direction || !target) {
      return false;
    }

    var state = moveable.state;
    var transformOrigin = state.transformOrigin,
        is3d = state.is3d,
        targetTransform = state.targetTransform,
        targetMatrix = state.targetMatrix,
        width = state.width,
        height = state.height,
        left = state.left,
        top = state.top;
    datas.datas = {};
    datas.targetTransform = targetTransform;
    datas.warpTargetMatrix = is3d ? targetMatrix : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 3, 4);
    datas.targetInverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.ignoreDimension)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(datas.warpTargetMatrix, 4), 3, 4);
    datas.direction = direction;
    datas.left = left;
    datas.top = top;
    datas.poses = [[0, 0], [width, 0], [0, height], [width, height]].map(function (p) {
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(p, transformOrigin);
    });
    datas.nextPoses = datas.poses.map(function (_a) {
      var x = _a[0],
          y = _a[1];
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(datas.warpTargetMatrix, [x, y, 0, 1], 4);
    });
    datas.startValue = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(4);
    datas.prevMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(4);
    datas.absolutePoses = getAbsolutePosesByState(state);
    datas.posIndexes = getPosIndexesByDirection(direction);
    setDragStart(moveable, e);
    setDefaultTransformIndex(e, "matrix3d");
    state.snapRenderInfo = {
      request: e.isRequest,
      direction: direction
    };
    var params = fillParams(moveable, e, __assign({
      set: function (matrix) {
        datas.startValue = matrix;
      }
    }, fillTransformStartEvent(e)));
    var result = triggerEvent(moveable, "onWarpStart", params);

    if (result !== false) {
      datas.isWarp = true;
    }

    return datas.isWarp;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas,
        isRequest = e.isRequest;
    var distX = e.distX,
        distY = e.distY;
    var targetInverseMatrix = datas.targetInverseMatrix,
        prevMatrix = datas.prevMatrix,
        isWarp = datas.isWarp,
        startValue = datas.startValue,
        poses = datas.poses,
        posIndexes = datas.posIndexes,
        absolutePoses = datas.absolutePoses;

    if (!isWarp) {
      return false;
    }

    resolveTransformEvent(e, "matrix3d");

    if (hasGuidelines(moveable, "warpable")) {
      var selectedPoses = posIndexes.map(function (index) {
        return absolutePoses[index];
      });

      if (selectedPoses.length > 1) {
        selectedPoses.push([(selectedPoses[0][0] + selectedPoses[1][0]) / 2, (selectedPoses[0][1] + selectedPoses[1][1]) / 2]);
      }

      var _a = checkMoveableSnapBounds(moveable, isRequest, {
        horizontal: selectedPoses.map(function (pos) {
          return pos[1] + distY;
        }),
        vertical: selectedPoses.map(function (pos) {
          return pos[0] + distX;
        })
      }),
          horizontalSnapInfo = _a.horizontal,
          verticalSnapInfo = _a.vertical;

      distY -= horizontalSnapInfo.offset;
      distX -= verticalSnapInfo.offset;
    }

    var dist = getDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    }, true);
    var nextPoses = datas.nextPoses.slice();
    posIndexes.forEach(function (index) {
      nextPoses[index] = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(nextPoses[index], dist);
    });

    if (!NEARBY_POS.every(function (nearByPoses) {
      return isValidPos(nearByPoses.map(function (i) {
        return poses[i];
      }), nearByPoses.map(function (i) {
        return nextPoses[i];
      }));
    })) {
      return false;
    }

    var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createWarpMatrix)(poses[0], poses[2], poses[1], poses[3], nextPoses[0], nextPoses[2], nextPoses[1], nextPoses[3]);

    if (!h.length) {
      return false;
    } // B * A * M


    var afterMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetInverseMatrix, h, 4); // B * M * A

    var matrix = getTransfromMatrix(datas, afterMatrix, true);
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(prevMatrix, 4), matrix, 4);
    datas.prevMatrix = matrix;
    var totalMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(startValue, matrix, 4);
    var nextTransform = convertTransformFormat(datas, "matrix3d(".concat(totalMatrix.join(", "), ")"), "matrix3d(".concat(matrix.join(", "), ")"));
    fillOriginalTransform(e, nextTransform);
    triggerEvent(moveable, "onWarp", fillParams(moveable, e, {
      delta: delta,
      matrix: totalMatrix,
      dist: matrix,
      multiply: _scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply,
      transform: nextTransform
    }));
    return true;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isWarp) {
      return false;
    }

    datas.isWarp = false;
    triggerEvent(moveable, "onWarpEnd", fillEndParams(moveable, e, {}));
    return isDrag;
  }
};
/**
 * Whether or not target can be warped. (default: false)
 * @name Moveable.Warpable#warpable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.warpable = true;
 */

/**
* Set directions to show the control box. (default: ["n", "nw", "ne", "s", "se", "sw", "e", "w"])
* @name Moveable.Warpable#renderDirections
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     warpable: true,
*     renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
* });
*
* moveable.renderDirections = ["nw", "ne", "sw", "se"];
*/

/**
* When the warp starts, the warpStart event is called.
* @memberof Moveable.Warpable
* @event warpStart
* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, { warpable: true });
* moveable.on("warpStart", ({ target }) => {
*     console.log(target);
* });
*/

/**
 * When warping, the warp event is called.
 * @memberof Moveable.Warpable
 * @event warp
 * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event
 * @example
 * import Moveable from "moveable";
 * let matrix = [
 *  1, 0, 0, 0,
 *  0, 1, 0, 0,
 *  0, 0, 1, 0,
 *  0, 0, 0, 1,
 * ];
 * const moveable = new Moveable(document.body, { warpable: true });
 * moveable.on("warp", ({ target, transform, delta, multiply }) => {
 *    // target.style.transform = transform;
 *    matrix = multiply(matrix, delta);
 *    target.style.transform = `matrix3d(${matrix.join(",")})`;
 * });
 */

/**
 * When the warp finishes, the warpEnd event is called.
 * @memberof Moveable.Warpable
 * @event warpEnd
 * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { warpable: true });
 * moveable.on("warpEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

var AREA_PIECES = /*#__PURE__*/prefix("area-pieces");
var AREA_PIECE = /*#__PURE__*/prefix("area-piece");
var AVOID = /*#__PURE__*/prefix("avoid");

function restoreStyle(moveable) {
  var el = moveable.areaElement;

  if (!el) {
    return;
  }

  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeClass)(el, AVOID);
  el.style.cssText += "left: 0px; top: 0px; width: ".concat(width, "px; height: ").concat(height, "px");
}

function renderPieces(React) {
  return React.createElement("div", {
    key: "area_pieces",
    className: AREA_PIECES
  }, React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }));
}

var DragArea = {
  name: "dragArea",
  props: {
    dragArea: Boolean,
    passDragArea: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        target = _a.target,
        dragArea = _a.dragArea,
        groupable = _a.groupable,
        passDragArea = _a.passDragArea;
    var _b = moveable.state,
        width = _b.width,
        height = _b.height,
        renderPoses = _b.renderPoses;
    var className = passDragArea ? prefix("area", "pass") : prefix("area");

    if (groupable) {
      return [React.createElement("div", {
        key: "area",
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(moveable, "areaElement"),
        className: className
      }), renderPieces(React)];
    }

    if (!target || !dragArea) {
      return [];
    }

    var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createWarpMatrix)([0, 0], [width, 0], [0, height], [width, height], renderPoses[0], renderPoses[1], renderPoses[2], renderPoses[3]);
    var transform = h.length ? makeMatrixCSS(h, true) : "none";
    return [React.createElement("div", {
      key: "area",
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(moveable, "areaElement"),
      className: className,
      style: {
        top: "0px",
        left: "0px",
        width: "".concat(width, "px"),
        height: "".concat(height, "px"),
        transformOrigin: "0 0",
        transform: transform
      }
    }), renderPieces(React)];
  },
  dragStart: function (moveable, _a) {
    var datas = _a.datas,
        clientX = _a.clientX,
        clientY = _a.clientY,
        inputEvent = _a.inputEvent;

    if (!inputEvent) {
      return false;
    }

    datas.isDragArea = false;
    var areaElement = moveable.areaElement;
    var state = moveable.state;
    var moveableClientRect = state.moveableClientRect,
        renderPoses = state.renderPoses,
        rootMatrix = state.rootMatrix,
        is3d = state.is3d;
    var left = moveableClientRect.left,
        top = moveableClientRect.top;

    var _b = getRect(renderPoses),
        relativeLeft = _b.left,
        relativeTop = _b.top,
        width = _b.width,
        height = _b.height;

    var n = is3d ? 4 : 3;

    var _c = calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n),
        posX = _c[0],
        posY = _c[1];

    posX -= relativeLeft;
    posY -= relativeTop;
    var rects = [{
      left: relativeLeft,
      top: relativeTop,
      width: width,
      height: posY - 10
    }, {
      left: relativeLeft,
      top: relativeTop,
      width: posX - 10,
      height: height
    }, {
      left: relativeLeft,
      top: relativeTop + posY + 10,
      width: width,
      height: height - posY - 10
    }, {
      left: relativeLeft + posX + 10,
      top: relativeTop,
      width: width - posX - 10,
      height: height
    }];
    var children = [].slice.call(areaElement.nextElementSibling.children);
    rects.forEach(function (rect, i) {
      children[i].style.cssText = "left: ".concat(rect.left, "px;top: ").concat(rect.top, "px; width: ").concat(rect.width, "px; height: ").concat(rect.height, "px;");
    });
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addClass)(areaElement, AVOID);
    state.disableNativeEvent = true;
    return;
  },
  drag: function (moveable, _a) {
    var datas = _a.datas,
        inputEvent = _a.inputEvent;
    this.enableNativeEvent(moveable);

    if (!inputEvent) {
      return false;
    }

    if (!datas.isDragArea) {
      datas.isDragArea = true;
      restoreStyle(moveable);
    }
  },
  dragEnd: function (moveable, e) {
    this.enableNativeEvent(moveable);
    var inputEvent = e.inputEvent,
        datas = e.datas;

    if (!inputEvent) {
      return false;
    }

    if (!datas.isDragArea) {
      restoreStyle(moveable);
    }
  },
  dragGroupStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragGroup: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragGroupEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  unset: function (moveable) {
    restoreStyle(moveable);
    moveable.state.disableNativeEvent = false;
  },
  enableNativeEvent: function (moveable) {
    var state = moveable.state;

    if (state.disableNativeEvent) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.requestAnimationFrame)(function () {
        state.disableNativeEvent = false;
      });
    }
  }
};
/**
 * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)
 * @name Moveable#dragArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  dragArea: false,
 * });
 */

/**
 * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)
 * @name Moveable#passDragArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  dragArea: false,
 * });
 */

var Origin = makeAble("origin", {
  render: function (moveable, React) {
    var zoom = moveable.props.zoom;
    var _a = moveable.state,
        beforeOrigin = _a.beforeOrigin,
        rotation = _a.rotation;
    return [React.createElement("div", {
      className: prefix("control", "origin"),
      style: getControlTransform(rotation, zoom, beforeOrigin),
      key: "beforeOrigin"
    })];
  }
});
/**
 * Whether or not the origin controlbox will be visible or not (default: true)
 * @name Moveable#origin
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.origin = true;
 */

function getDefaultScrollPosition(e) {
  var scrollContainer = e.scrollContainer;
  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];
}
/**
 * @namespace Moveable.Scrollable
 * @description Whether or not target can be scrolled to the scroll container (default: false)
 */


var Scrollable = {
  name: "scrollable",
  canPinch: true,
  props: {
    scrollable: Boolean,
    scrollContainer: Object,
    scrollThreshold: Number,
    getScrollPosition: Function
  },
  events: {
    onScroll: "scroll",
    onScrollGroup: "scrollGroup"
  },
  dragRelation: "strong",
  dragStart: function (moveable, e) {
    var props = moveable.props;
    var _a = props.scrollContainer,
        scrollContainer = _a === void 0 ? moveable.getContainer() : _a;
    var dragScroll = new _scena_dragscroll__WEBPACK_IMPORTED_MODULE_7__["default"]();
    var scrollContainerElement = getRefTarget(scrollContainer, true);
    e.datas.dragScroll = dragScroll;
    var gestoName = e.isControl ? "controlGesto" : "targetGesto";
    var targets = e.targets;
    dragScroll.on("scroll", function (_a) {
      var container = _a.container,
          direction = _a.direction;
      var params = fillParams(moveable, e, {
        scrollContainer: container,
        direction: direction
      });
      var eventName = targets ? "onScrollGroup" : "onScroll";

      if (targets) {
        params.targets = targets;
      }

      triggerEvent(moveable, eventName, params);
    }).on("move", function (_a) {
      var offsetX = _a.offsetX,
          offsetY = _a.offsetY;
      moveable[gestoName].scrollBy(offsetX, offsetY, e.inputEvent, false);
    });
    dragScroll.dragStart(e, {
      container: scrollContainerElement
    });
  },
  checkScroll: function (moveable, e) {
    var dragScroll = e.datas.dragScroll;

    if (!dragScroll) {
      return;
    }

    var _a = moveable.props,
        _b = _a.scrollContainer,
        scrollContainer = _b === void 0 ? moveable.getContainer() : _b,
        _c = _a.scrollThreshold,
        scrollThreshold = _c === void 0 ? 0 : _c,
        _d = _a.getScrollPosition,
        getScrollPosition = _d === void 0 ? getDefaultScrollPosition : _d;
    dragScroll.drag(e, {
      container: scrollContainer,
      threshold: scrollThreshold,
      getScrollPosition: function (ev) {
        return getScrollPosition({
          scrollContainer: ev.container,
          direction: ev.direction
        });
      }
    });
    return true;
  },
  drag: function (moveable, e) {
    return this.checkScroll(moveable, e);
  },
  dragEnd: function (moveable, e) {
    e.datas.dragScroll.dragEnd();
    e.datas.dragScroll = null;
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, __assign(__assign({}, e), {
      isControl: true
    }));
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupStart: function (moveable, e) {
    return this.dragStart(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroup: function (moveable, e) {
    return this.drag(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupEnd: function (moveable, e) {
    return this.dragEnd(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragStart(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets,
      isControl: true
    }));
  },
  dragGroupContro: function (moveable, e) {
    return this.drag(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControEnd: function (moveable, e) {
    return this.dragEnd(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  }
};
/**
 * Whether or not target can be scrolled to the scroll container (default: false)
 * @name Moveable.Scrollable#scrollable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 *
 * moveable.scrollable = true;
 */

/**
 * The container to which scroll is applied (default: container)
 * @name Moveable.Scrollable#scrollContainer
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 */

/**
 * Expand the range of the scroll check area. (default: 0)
 * @name Moveable.Scrollable#scrollThreshold
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 */

/**
 * Sets a function to get the scroll position. (default: Function)
 * @name Moveable.Scrollable#getScrollPosition
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 *
 */

/**
 * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.
 * @memberof Moveable.Scrollable
 * @event scroll
 * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("scroll", ({ scrollContainer, direction }) => {
 *   scrollContainer.scrollLeft += direction[0] * 10;
 *   scrollContainer.scrollTop += direction[1] * 10;
 * });
 */

/**
 * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.
 * @memberof Moveable.Scrollable
 * @event scrollGroup
 * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("scroll", ({ scrollContainer, direction }) => {
 *   scrollContainer.scrollLeft += direction[0] * 10;
 *   scrollContainer.scrollTop += direction[1] * 10;
 * });
 */

var Default = {
  name: "",
  props: {
    target: Object,
    dragTarget: Object,
    container: Object,
    portalContainer: Object,
    rootContainer: Object,
    useResizeObserver: Boolean,
    zoom: Number,
    transformOrigin: Array,
    edge: Boolean,
    ables: Array,
    className: String,
    pinchThreshold: Number,
    pinchOutside: Boolean,
    triggerAblesSimultaneously: Boolean,
    checkInput: Boolean,
    cspNonce: String,
    translateZ: Number,
    hideDefaultLines: Boolean,
    props: Object,
    flushSync: Function
  },
  events: {}
};
var Padding = makeAble("padding", {
  render: function (moveable, React) {
    var props = moveable.props;

    if (props.dragArea) {
      return [];
    }

    var padding = props.padding || {};
    var _a = padding.left,
        left = _a === void 0 ? 0 : _a,
        _b = padding.top,
        top = _b === void 0 ? 0 : _b,
        _c = padding.right,
        right = _c === void 0 ? 0 : _c,
        _d = padding.bottom,
        bottom = _d === void 0 ? 0 : _d;
    var _e = moveable.state,
        renderPoses = _e.renderPoses,
        pos1 = _e.pos1,
        pos2 = _e.pos2,
        pos3 = _e.pos3,
        pos4 = _e.pos4;
    var poses = [pos1, pos2, pos3, pos4];
    var paddingDirections = [];

    if (left > 0) {
      paddingDirections.push([0, 2]);
    }

    if (top > 0) {
      paddingDirections.push([0, 1]);
    }

    if (right > 0) {
      paddingDirections.push([1, 3]);
    }

    if (bottom > 0) {
      paddingDirections.push([2, 3]);
    }

    return paddingDirections.map(function (_a, i) {
      var dir1 = _a[0],
          dir2 = _a[1];
      var paddingPos1 = poses[dir1];
      var paddingPos2 = poses[dir2];
      var paddingPos3 = renderPoses[dir1];
      var paddingPos4 = renderPoses[dir2];
      var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createWarpMatrix)([0, 0], [100, 0], [0, 100], [100, 100], paddingPos1, paddingPos2, paddingPos3, paddingPos4);

      if (!h.length) {
        return undefined;
      }

      return React.createElement("div", {
        key: "padding".concat(i),
        className: prefix("padding"),
        style: {
          transform: makeMatrixCSS(h, true)
        }
      });
    });
  }
});
/**
 * Add padding around the target to increase the drag area.
 * @name Moveable#padding
 * @default null
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  target: document.querySelector(".target"),
 *  padding: { left: 0, top: 0, right: 0, bottom: 0 },
 * });
 * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },
 * moveable.updateRect();
 */

var RADIUS_DIRECTIONS = ["nw", "ne", "se", "sw"];

function calculateRatio(values, size) {
  var sumSize = values[0] + values[1];
  var sumRatio = sumSize > size ? size / sumSize : 1;
  values[0] *= sumRatio;
  values[1] = size - values[1] * sumRatio;
  return values;
}

var HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];
var VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];
var HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1];
var VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];

function getRadiusStyles(poses, controlPoses, isRelative, width, height, left, top, right, bottom) {
  if (left === void 0) {
    left = 0;
  }

  if (top === void 0) {
    top = 0;
  }

  if (right === void 0) {
    right = width;
  }

  if (bottom === void 0) {
    bottom = height;
  }

  var clipStyles = [];
  var isVertical = false;
  var raws = poses.map(function (pos, i) {
    var _a = controlPoses[i],
        horizontal = _a.horizontal,
        vertical = _a.vertical;

    if (vertical && !isVertical) {
      isVertical = true;
      clipStyles.push("/");
    }

    if (isVertical) {
      var rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);
      clipStyles.push(convertCSSSize(rawPos, height, isRelative));
      return rawPos;
    } else {
      var rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);
      clipStyles.push(convertCSSSize(rawPos, width, isRelative));
      return rawPos;
    }
  });
  return {
    styles: clipStyles,
    raws: raws
  };
}

function getRadiusRange(controlPoses) {
  // [start, length]
  var horizontalRange = [0, 0];
  var verticalRange = [0, 0];
  var length = controlPoses.length;

  for (var i = 0; i < length; ++i) {
    var clipPose = controlPoses[i];

    if (!clipPose.sub) {
      continue;
    }

    if (clipPose.horizontal) {
      if (horizontalRange[1] === 0) {
        horizontalRange[0] = i;
      }

      horizontalRange[1] = i - horizontalRange[0] + 1;
      verticalRange[0] = i + 1;
    }

    if (clipPose.vertical) {
      if (verticalRange[1] === 0) {
        verticalRange[0] = i;
      }

      verticalRange[1] = i - verticalRange[0] + 1;
    }
  }

  return {
    horizontalRange: horizontalRange,
    verticalRange: verticalRange
  };
}

function getRadiusValues(values, width, height, left, top, minCounts) {
  var _a, _b, _c, _d;

  if (minCounts === void 0) {
    minCounts = [0, 0];
  }

  var splitIndex = values.indexOf("/");
  var splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;
  var horizontalValues = values.slice(0, splitLength);
  var verticalValues = values.slice(splitLength + 1);
  var _e = horizontalValues[0],
      nwValue = _e === void 0 ? "0px" : _e,
      _f = horizontalValues[1],
      neValue = _f === void 0 ? nwValue : _f,
      _g = horizontalValues[2],
      seValue = _g === void 0 ? nwValue : _g,
      _h = horizontalValues[3],
      swValue = _h === void 0 ? neValue : _h;
  var _j = verticalValues[0],
      wnValue = _j === void 0 ? nwValue : _j,
      _k = verticalValues[1],
      enValue = _k === void 0 ? wnValue : _k,
      _l = verticalValues[2],
      esValue = _l === void 0 ? wnValue : _l,
      _m = verticalValues[3],
      wsValue = _m === void 0 ? enValue : _m;
  var horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(function (pos) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(pos, width);
  });
  var verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(function (pos) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(pos, height);
  });
  var horizontalPoses = horizontalRawPoses.slice();
  var verticalPoses = verticalRawPoses.slice();
  _a = calculateRatio([horizontalPoses[0], horizontalPoses[1]], width), horizontalPoses[0] = _a[0], horizontalPoses[1] = _a[1];
  _b = calculateRatio([horizontalPoses[3], horizontalPoses[2]], width), horizontalPoses[3] = _b[0], horizontalPoses[2] = _b[1];
  _c = calculateRatio([verticalPoses[0], verticalPoses[3]], height), verticalPoses[0] = _c[0], verticalPoses[3] = _c[1];
  _d = calculateRatio([verticalPoses[1], verticalPoses[2]], height), verticalPoses[1] = _d[0], verticalPoses[2] = _d[1];
  var nextHorizontalPoses = horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValues.length));
  var nextVerticalPoses = verticalPoses.slice(0, Math.max(minCounts[1], verticalValues.length));
  return __spreadArray(__spreadArray([], nextHorizontalPoses.map(function (pos, i) {
    var direction = RADIUS_DIRECTIONS[i];
    return {
      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],
      vertical: 0,
      pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],
      sub: true,
      raw: horizontalRawPoses[i],
      direction: direction
    };
  }), true), nextVerticalPoses.map(function (pos, i) {
    var direction = RADIUS_DIRECTIONS[i];
    return {
      horizontal: 0,
      vertical: VERTICAL_RADIUS_DIRECTIONS[i],
      pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],
      sub: true,
      raw: verticalRawPoses[i],
      direction: direction
    };
  }), true);
}

function removeRadiusPos(controlPoses, poses, index, startIndex, length) {
  if (length === void 0) {
    length = poses.length;
  }

  var _a = getRadiusRange(controlPoses.slice(startIndex)),
      horizontalRange = _a.horizontalRange,
      verticalRange = _a.verticalRange;

  var radiuslIndex = index - startIndex;
  var deleteCount = 0;

  if (radiuslIndex === 0) {
    deleteCount = length;
  } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {
    deleteCount = horizontalRange[1] - radiuslIndex;
  } else if (radiuslIndex >= verticalRange[0]) {
    deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;
  } else {
    return;
  }

  controlPoses.splice(index, deleteCount);
  poses.splice(index, deleteCount);
}

function addRadiusPos(controlPoses, poses, startIndex, horizontalIndex, verticalIndex, distX, distY, right, bottom, left, top) {
  if (left === void 0) {
    left = 0;
  }

  if (top === void 0) {
    top = 0;
  }

  var _a = getRadiusRange(controlPoses.slice(startIndex)),
      horizontalRange = _a.horizontalRange,
      verticalRange = _a.verticalRange;

  if (horizontalIndex > -1) {
    var radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1 ? distX - left : right - distX;

    for (var i = horizontalRange[1]; i <= horizontalIndex; ++i) {
      var y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;
      var x = 0;

      if (horizontalIndex === i) {
        x = distX;
      } else if (i === 0) {
        x = left + radiusX;
      } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {
        x = right - (poses[startIndex][0] - left);
      }

      controlPoses.splice(startIndex + i, 0, {
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],
        vertical: 0,
        pos: [x, y]
      });
      poses.splice(startIndex + i, 0, [x, y]);

      if (i === 0) {
        break;
      }
    }
  } else if (verticalIndex > -1) {
    var radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1 ? distY - top : bottom - distY;

    if (horizontalRange[1] === 0 && verticalRange[1] === 0) {
      var pos = [left + radiusY, top];
      controlPoses.push({
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],
        vertical: 0,
        pos: pos
      });
      poses.push(pos);
    }

    var startVerticalIndex = verticalRange[0];

    for (var i = verticalRange[1]; i <= verticalIndex; ++i) {
      var x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;
      var y = 0;

      if (verticalIndex === i) {
        y = distY;
      } else if (i === 0) {
        y = top + radiusY;
      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {
        y = poses[startIndex + startVerticalIndex][1];
      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {
        y = bottom - (poses[startIndex + startVerticalIndex][1] - top);
      }

      controlPoses.push({
        horizontal: 0,
        vertical: VERTICAL_RADIUS_DIRECTIONS[i],
        pos: [x, y]
      });
      poses.push([x, y]);

      if (i === 0) {
        break;
      }
    }
  }
}

function splitRadiusPoses(controlPoses, raws) {
  if (raws === void 0) {
    raws = controlPoses.map(function (pos) {
      return pos.raw;
    });
  }

  var horizontals = controlPoses.map(function (pos, i) {
    return pos.horizontal ? raws[i] : null;
  }).filter(function (pos) {
    return pos != null;
  });
  var verticals = controlPoses.map(function (pos, i) {
    return pos.vertical ? raws[i] : null;
  }).filter(function (pos) {
    return pos != null;
  });
  return {
    horizontals: horizontals,
    verticals: verticals
  };
}

var CLIP_DIRECTIONS = [[0, -1, "n"], [1, 0, "e"]];
var CLIP_RECT_DIRECTIONS = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]]; // 1 2 5 6 0 3 4 7
// 0 1 2 3 4 5 6 7

function getClipStyles(moveable, clipPath, poses) {
  var clipRelative = moveable.props.clipRelative;
  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  var _b = clipPath,
      clipType = _b.type,
      clipPoses = _b.poses;
  var isRect = clipType === "rect";
  var isCircle = clipType === "circle";

  if (clipType === "polygon") {
    return poses.map(function (pos) {
      return "".concat(convertCSSSize(pos[0], width, clipRelative), " ").concat(convertCSSSize(pos[1], height, clipRelative));
    });
  } else if (isRect || clipType === "inset") {
    var top = poses[1][1];
    var right = poses[3][0];
    var left = poses[7][0];
    var bottom = poses[5][1];

    if (isRect) {
      return [top, right, bottom, left].map(function (pos) {
        return "".concat(pos, "px");
      });
    }

    var clipStyles = [top, width - right, height - bottom, left].map(function (pos, i) {
      return convertCSSSize(pos, i % 2 ? width : height, clipRelative);
    });

    if (poses.length > 8) {
      var _c = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(poses[4], poses[0]),
          subWidth = _c[0],
          subHeight = _c[1];

      clipStyles.push.apply(clipStyles, __spreadArray(["round"], getRadiusStyles(poses.slice(8), clipPoses.slice(8), clipRelative, subWidth, subHeight, left, top, right, bottom).styles, false));
    }

    return clipStyles;
  } else if (isCircle || clipType === "ellipse") {
    var center = poses[0];
    var ry = convertCSSSize(Math.abs(poses[1][1] - center[1]), isCircle ? Math.sqrt((width * width + height * height) / 2) : height, clipRelative);
    var clipStyles = isCircle ? [ry] : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];
    clipStyles.push("at", convertCSSSize(center[0], width, clipRelative), convertCSSSize(center[1], height, clipRelative));
    return clipStyles;
  }
}

function getRectPoses(top, right, bottom, left) {
  var xs = [left, (left + right) / 2, right];
  var ys = [top, (top + bottom) / 2, bottom];
  return CLIP_RECT_DIRECTIONS.map(function (_a) {
    var dirx = _a[0],
        diry = _a[1],
        dir = _a[2];
    var x = xs[dirx + 1];
    var y = ys[diry + 1];
    return {
      vertical: Math.abs(diry),
      horizontal: Math.abs(dirx),
      direction: dir,
      pos: [x, y]
    };
  });
}

function getControlSize(controlPoses) {
  var xRange = [Infinity, -Infinity];
  var yRange = [Infinity, -Infinity];
  controlPoses.forEach(function (_a) {
    var pos = _a.pos;
    xRange[0] = Math.min(xRange[0], pos[0]);
    xRange[1] = Math.max(xRange[1], pos[0]);
    yRange[0] = Math.min(yRange[0], pos[1]);
    yRange[1] = Math.max(yRange[1], pos[1]);
  });
  return [Math.abs(xRange[1] - xRange[0]), Math.abs(yRange[1] - yRange[0])];
}

function moveControlPos(controlPoses, index, dist, isRect, keepRatio) {
  var _a = controlPoses[index],
      direction = _a.direction,
      sub = _a.sub;
  var dists = controlPoses.map(function () {
    return [0, 0];
  });
  var directions = direction ? direction.split("") : [];

  if (isRect && index < 8) {
    var verticalDirections = directions.filter(function (dir) {
      return dir === "w" || dir === "e";
    });
    var horizontalDirections = directions.filter(function (dir) {
      return dir === "n" || dir === "s";
    });
    var verticalDirection_1 = verticalDirections[0];
    var horizontalDirection_1 = horizontalDirections[0];
    dists[index] = dist;

    var _b = getControlSize(controlPoses),
        width = _b[0],
        height = _b[1];

    var ratio = width && height ? width / height : 0;

    if (ratio && keepRatio) {
      // 0 1 2
      // 7   3
      // 6 5 4
      var fixedIndex = (index + 4) % 8;
      var fixedPosition = controlPoses[fixedIndex].pos;
      var sizeDirection = [0, 0];

      if (direction.indexOf("w") > -1) {
        sizeDirection[0] = -1;
      } else if (direction.indexOf("e") > -1) {
        sizeDirection[0] = 1;
      }

      if (direction.indexOf("n") > -1) {
        sizeDirection[1] = -1;
      } else if (direction.indexOf("s") > -1) {
        sizeDirection[1] = 1;
      }

      var nextDist = getSizeDistByDist([width, height], dist, ratio, sizeDirection, true);
      var nextWidth = width + nextDist[0];
      var nextHeight = height + nextDist[1];
      var top = fixedPosition[1];
      var bottom = fixedPosition[1];
      var left = fixedPosition[0];
      var right = fixedPosition[0];

      if (sizeDirection[0] === -1) {
        left = right - nextWidth;
      } else if (sizeDirection[0] === 1) {
        right = left + nextWidth;
      } else {
        left = left - nextWidth / 2;
        right = right + nextWidth / 2;
      }

      if (sizeDirection[1] === -1) {
        top = bottom - nextHeight;
      } else if (sizeDirection[1] === 1) {
        bottom = top + nextHeight;
      } else {
        top = bottom - nextHeight / 2;
        bottom = top + nextHeight;
      }

      var nextControlPoses_1 = getRectPoses(top, right, bottom, left);
      controlPoses.forEach(function (controlPose, i) {
        dists[i][0] = nextControlPoses_1[i].pos[0] - controlPose.pos[0];
        dists[i][1] = nextControlPoses_1[i].pos[1] - controlPose.pos[1];
      });
    } else {
      controlPoses.forEach(function (controlPose, i) {
        var controlDir = controlPose.direction;

        if (!controlDir) {
          return;
        }

        if (controlDir.indexOf(verticalDirection_1) > -1) {
          dists[i][0] = dist[0];
        }

        if (controlDir.indexOf(horizontalDirection_1) > -1) {
          dists[i][1] = dist[1];
        }
      });

      if (verticalDirection_1) {
        dists[1][0] = dist[0] / 2;
        dists[5][0] = dist[0] / 2;
      }

      if (horizontalDirection_1) {
        dists[3][1] = dist[1] / 2;
        dists[7][1] = dist[1] / 2;
      }
    }
  } else if (direction && !sub) {
    directions.forEach(function (dir) {
      var isVertical = dir === "n" || dir === "s";
      controlPoses.forEach(function (controlPose, i) {
        var dirDir = controlPose.direction,
            dirHorizontal = controlPose.horizontal,
            dirVertical = controlPose.vertical;

        if (!dirDir || dirDir.indexOf(dir) === -1) {
          return;
        }

        dists[i] = [isVertical || !dirHorizontal ? 0 : dist[0], !isVertical || !dirVertical ? 0 : dist[1]];
      });
    });
  } else {
    dists[index] = dist;
  }

  return dists;
}

function getClipPath(target, width, height, defaultClip, customClip) {
  var _a, _b, _c, _d, _e, _f, _g;

  var clipText = customClip;

  if (!clipText) {
    var style = getComputedStyle(target);
    var clipPath = style.clipPath;
    clipText = clipPath !== "none" ? clipPath : style.clip;
  }

  if (!clipText || clipText === "none" || clipText === "auto") {
    clipText = defaultClip;

    if (!clipText) {
      return;
    }
  }

  var _h = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitBracket)(clipText),
      _j = _h.prefix,
      clipPrefix = _j === void 0 ? clipText : _j,
      _k = _h.value,
      value = _k === void 0 ? "" : _k;

  var isCircle = clipPrefix === "circle";
  var splitter = " ";

  if (clipPrefix === "polygon") {
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitComma)(value || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
    splitter = ",";
    var poses = values.map(function (pos) {
      var _a = pos.split(" "),
          xPos = _a[0],
          yPos = _a[1];

      return {
        vertical: 1,
        horizontal: 1,
        pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(xPos, width), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(yPos, height)]
      };
    });
    return {
      type: clipPrefix,
      clipText: clipText,
      poses: poses,
      splitter: splitter
    };
  } else if (isCircle || clipPrefix === "ellipse") {
    var xPos = "";
    var yPos = "";
    var radiusX_1 = 0;
    var radiusY_1 = 0;
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitSpace)(value);

    if (isCircle) {
      var radius = "";
      _a = values[0], radius = _a === void 0 ? "50%" : _a, _b = values[2], xPos = _b === void 0 ? "50%" : _b, _c = values[3], yPos = _c === void 0 ? "50%" : _c;
      radiusX_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(radius, Math.sqrt((width * width + height * height) / 2));
      radiusY_1 = radiusX_1;
    } else {
      var xRadius = "";
      var yRadius = "";
      _d = values[0], xRadius = _d === void 0 ? "50%" : _d, _e = values[1], yRadius = _e === void 0 ? "50%" : _e, _f = values[3], xPos = _f === void 0 ? "50%" : _f, _g = values[4], yPos = _g === void 0 ? "50%" : _g;
      radiusX_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(xRadius, width);
      radiusY_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(yRadius, height);
    }

    var centerPos_1 = [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(xPos, width), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(yPos, height)];

    var poses = __spreadArray([{
      vertical: 1,
      horizontal: 1,
      pos: centerPos_1,
      direction: "nesw"
    }], CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(function (dir) {
      return {
        vertical: Math.abs(dir[1]),
        horizontal: dir[0],
        direction: dir[2],
        sub: true,
        pos: [centerPos_1[0] + dir[0] * radiusX_1, centerPos_1[1] + dir[1] * radiusY_1]
      };
    }), true);

    return {
      type: clipPrefix,
      clipText: clipText,
      radiusX: radiusX_1,
      radiusY: radiusY_1,
      left: centerPos_1[0] - radiusX_1,
      top: centerPos_1[1] - radiusY_1,
      poses: poses,
      splitter: splitter
    };
  } else if (clipPrefix === "inset") {
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitSpace)(value || "0 0 0 0");
    var roundIndex = values.indexOf("round");
    var rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;
    var radiusValues = values.slice(rectLength + 1);

    var _l = values.slice(0, rectLength),
        topValue = _l[0],
        _m = _l[1],
        rightValue = _m === void 0 ? topValue : _m,
        _o = _l[2],
        bottomValue = _o === void 0 ? topValue : _o,
        _p = _l[3],
        leftValue = _p === void 0 ? rightValue : _p;

    var _q = [topValue, bottomValue].map(function (pos) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(pos, height);
    }),
        top = _q[0],
        bottom = _q[1];

    var _r = [leftValue, rightValue].map(function (pos) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)(pos, width);
    }),
        left = _r[0],
        right = _r[1];

    var nextRight = width - right;
    var nextBottom = height - bottom;
    var radiusPoses = getRadiusValues(radiusValues, nextRight - left, nextBottom - top, left, top);

    var poses = __spreadArray(__spreadArray([], getRectPoses(top, nextRight, nextBottom, left), true), radiusPoses, true);

    return {
      type: "inset",
      clipText: clipText,
      poses: poses,
      top: top,
      left: left,
      right: nextRight,
      bottom: nextBottom,
      radius: radiusValues,
      splitter: splitter
    };
  } else if (clipPrefix === "rect") {
    // top right bottom left
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitComma)(value || "0px, ".concat(width, "px, ").concat(height, "px, 0px"));
    splitter = ",";

    var _s = values.map(function (pos) {
      var posValue = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitUnit)(pos).value;
      return posValue;
    }),
        top = _s[0],
        right = _s[1],
        bottom = _s[2],
        left = _s[3];

    var poses = getRectPoses(top, right, bottom, left);
    return {
      type: "rect",
      clipText: clipText,
      poses: poses,
      top: top,
      right: right,
      bottom: bottom,
      left: left,
      values: values,
      splitter: splitter
    };
  }

  return;
}

function addClipPath(moveable, e) {
  var _a = calculatePointerDist(moveable, e),
      distX = _a[0],
      distY = _a[1];

  var _b = e.datas,
      clipPath = _b.clipPath,
      clipIndex = _b.clipIndex;
  var _c = clipPath,
      clipType = _c.type,
      clipPoses = _c.poses,
      splitter = _c.splitter;
  var poses = clipPoses.map(function (pos) {
    return pos.pos;
  });

  if (clipType === "polygon") {
    poses.splice(clipIndex, 0, [distX, distY]);
  } else if (clipType === "inset") {
    var horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(clipIndex);
    var verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(clipIndex);
    var length = clipPoses.length;
    addRadiusPos(clipPoses, poses, 8, horizontalIndex, verticalIndex, distX, distY, poses[4][0], poses[4][1], poses[0][0], poses[0][1]);

    if (length === clipPoses.length) {
      return;
    }
  } else {
    return;
  }

  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e, {
    clipEventType: "added",
    clipType: clipType,
    poses: poses,
    clipStyles: clipStyles,
    clipStyle: "".concat(clipType, "(").concat(clipStyles.join(splitter), ")"),
    distX: 0,
    distY: 0
  }));
}

function removeClipPath(moveable, e) {
  var _a = e.datas,
      clipPath = _a.clipPath,
      clipIndex = _a.clipIndex;
  var _b = clipPath,
      clipType = _b.type,
      clipPoses = _b.poses,
      splitter = _b.splitter;
  var poses = clipPoses.map(function (pos) {
    return pos.pos;
  });
  var length = poses.length;

  if (clipType === "polygon") {
    clipPoses.splice(clipIndex, 1);
    poses.splice(clipIndex, 1);
  } else if (clipType === "inset") {
    if (clipIndex < 8) {
      return;
    }

    removeRadiusPos(clipPoses, poses, clipIndex, 8, length);

    if (length === clipPoses.length) {
      return;
    }
  } else {
    return;
  }

  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e, {
    clipEventType: "removed",
    clipType: clipType,
    poses: poses,
    clipStyles: clipStyles,
    clipStyle: "".concat(clipType, "(").concat(clipStyles.join(splitter), ")"),
    distX: 0,
    distY: 0
  }));
}
/**
 * @namespace Moveable.Clippable
 * @description Whether to clip the target.
 */


var Clippable = {
  name: "clippable",
  props: {
    clippable: Boolean,
    defaultClipPath: String,
    customClipPath: String,
    keepRatio: Boolean,
    clipRelative: Boolean,
    clipArea: Boolean,
    dragWithClip: Boolean,
    clipTargetBounds: Boolean,
    clipVerticalGuidelines: Array,
    clipHorizontalGuidelines: Array,
    clipSnapThreshold: Boolean
  },
  events: {
    onClipStart: "clipStart",
    onClip: "clip",
    onClipEnd: "clipEnd"
  },
  css: [".control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}", ":host {\n    --bounds-color: #d66;\n}", ".guideline {\n    pointer-events: none;\n    z-index: 2;\n}", ".line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}"],
  render: function (moveable, React) {
    var _a = moveable.props,
        customClipPath = _a.customClipPath,
        defaultClipPath = _a.defaultClipPath,
        clipArea = _a.clipArea,
        zoom = _a.zoom;
    var _b = moveable.state,
        target = _b.target,
        width = _b.width,
        height = _b.height,
        allMatrix = _b.allMatrix,
        is3d = _b.is3d,
        left = _b.left,
        top = _b.top,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4,
        clipPathState = _b.clipPathState,
        snapBoundInfos = _b.snapBoundInfos,
        rotationRad = _b.rotation;

    if (!target) {
      return [];
    }

    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", clipPathState || customClipPath);

    if (!clipPath) {
      return [];
    }

    var n = is3d ? 4 : 3;
    var type = clipPath.type;
    var clipPoses = clipPath.poses;
    var poses = clipPoses.map(function (pos) {
      // return [x, y];
      var calculatedPos = calculatePosition(allMatrix, pos.pos, n);
      return [calculatedPos[0] - left, calculatedPos[1] - top];
    });
    var controls = [];
    var lines = [];
    var isRect = type === "rect";
    var isInset = type === "inset";
    var isPolygon = type === "polygon";

    if (isRect || isInset || isPolygon) {
      var linePoses_1 = isInset ? poses.slice(0, 8) : poses;
      lines = linePoses_1.map(function (to, i) {
        var from = i === 0 ? linePoses_1[linePoses_1.length - 1] : linePoses_1[i - 1];
        var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getRad)(from, to);
        var dist = getDiagonalSize(from, to);
        return React.createElement("div", {
          key: "clipLine".concat(i),
          className: prefix("line", "clip-line", "snap-control"),
          "data-clip-index": i,
          style: {
            width: "".concat(dist, "px"),
            transform: "translate(".concat(from[0], "px, ").concat(from[1], "px) rotate(").concat(rad, "rad) scaleY(").concat(zoom, ")")
          }
        });
      });
    }

    controls = poses.map(function (pos, i) {
      return React.createElement("div", {
        key: "clipControl".concat(i),
        className: prefix("control", "clip-control", "snap-control"),
        "data-clip-index": i,
        style: {
          transform: "translate(".concat(pos[0], "px, ").concat(pos[1], "px) rotate(").concat(rotationRad, "rad) scale(").concat(zoom, ")")
        }
      });
    });

    if (isInset) {
      controls.push.apply(controls, poses.slice(8).map(function (pos, i) {
        return React.createElement("div", {
          key: "clipRadiusControl".concat(i),
          className: prefix("control", "clip-control", "clip-radius", "snap-control"),
          "data-clip-index": 8 + i,
          style: {
            transform: "translate(".concat(pos[0], "px, ").concat(pos[1], "px) rotate(").concat(rotationRad, "rad) scale(").concat(zoom, ")")
          }
        });
      }));
    }

    if (type === "circle" || type === "ellipse") {
      var clipLeft = clipPath.left,
          clipTop = clipPath.top,
          radiusX = clipPath.radiusX,
          radiusY = clipPath.radiusY;

      var _c = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, [clipLeft, clipTop], n), calculatePosition(allMatrix, [0, 0], n)),
          distLeft = _c[0],
          distTop = _c[1];

      var ellipseClipPath = "none";

      if (!clipArea) {
        var piece = Math.max(10, radiusX / 5, radiusY / 5);
        var areaPoses = [];

        for (var i = 0; i <= piece; ++i) {
          var rad = Math.PI * 2 / piece * i;
          areaPoses.push([radiusX + (radiusX - zoom) * Math.cos(rad), radiusY + (radiusY - zoom) * Math.sin(rad)]);
        }

        areaPoses.push([radiusX, -2]);
        areaPoses.push([-2, -2]);
        areaPoses.push([-2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, -2]);
        areaPoses.push([radiusX, -2]);
        ellipseClipPath = "polygon(".concat(areaPoses.map(function (pos) {
          return "".concat(pos[0], "px ").concat(pos[1], "px");
        }).join(", "), ")");
      }

      controls.push(React.createElement("div", {
        key: "clipEllipse",
        className: prefix("clip-ellipse", "snap-control"),
        style: {
          width: "".concat(radiusX * 2, "px"),
          height: "".concat(radiusY * 2, "px"),
          clipPath: ellipseClipPath,
          transform: "translate(".concat(-left + distLeft, "px, ").concat(-top + distTop, "px) ").concat(makeMatrixCSS(allMatrix))
        }
      }));
    }

    if (clipArea) {
      var _d = getRect(__spreadArray([pos1, pos2, pos3, pos4], poses, true)),
          allWidth = _d.width,
          allHeight = _d.height,
          allLeft_1 = _d.left,
          allTop_1 = _d.top;

      if (isPolygon || isRect || isInset) {
        var areaPoses = isInset ? poses.slice(0, 8) : poses;
        controls.push(React.createElement("div", {
          key: "clipArea",
          className: prefix("clip-area", "snap-control"),
          style: {
            width: "".concat(allWidth, "px"),
            height: "".concat(allHeight, "px"),
            transform: "translate(".concat(allLeft_1, "px, ").concat(allTop_1, "px)"),
            clipPath: "polygon(".concat(areaPoses.map(function (pos) {
              return "".concat(pos[0] - allLeft_1, "px ").concat(pos[1] - allTop_1, "px");
            }).join(", "), ")")
          }
        }));
      }
    }

    if (snapBoundInfos) {
      ["vertical", "horizontal"].forEach(function (directionType) {
        var info = snapBoundInfos[directionType];
        var isHorizontal = directionType === "horizontal";

        if (info.isSnap) {
          lines.push.apply(lines, info.snap.posInfos.map(function (_a, i) {
            var pos = _a.pos;
            var snapPos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip".concat(directionType, "snap").concat(i), "guideline");
          }));
        }

        if (info.isBound) {
          lines.push.apply(lines, info.bounds.map(function (_a, i) {
            var pos = _a.pos;
            var snapPos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip".concat(directionType, "bounds").concat(i), "guideline", "bounds", "bold");
          }));
        }
      });
    }

    return __spreadArray(__spreadArray([], controls, true), lines, true);
  },
  dragControlCondition: function (moveable, e) {
    return e.inputEvent && (e.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function (moveable, e) {
    var props = moveable.props;
    var _a = props.dragWithClip,
        dragWithClip = _a === void 0 ? true : _a;

    if (dragWithClip) {
      return false;
    }

    return this.dragControlStart(moveable, e);
  },
  drag: function (moveable, e) {
    return this.dragControl(moveable, __assign(__assign({}, e), {
      isDragTarget: true
    }));
  },
  dragEnd: function (moveable, e) {
    return this.dragControlEnd(moveable, e);
  },
  dragControlStart: function (moveable, e) {
    var state = moveable.state;
    var _a = moveable.props,
        defaultClipPath = _a.defaultClipPath,
        customClipPath = _a.customClipPath;
    var target = state.target,
        width = state.width,
        height = state.height;
    var inputTarget = e.inputEvent ? e.inputEvent.target : null;
    var className = inputTarget && inputTarget.getAttribute("class") || "";
    var datas = e.datas;
    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", customClipPath);

    if (!clipPath) {
      return false;
    }

    var clipText = clipPath.clipText,
        type = clipPath.type,
        poses = clipPath.poses;
    var result = triggerEvent(moveable, "onClipStart", fillParams(moveable, e, {
      clipType: type,
      clipStyle: clipText,
      poses: poses.map(function (pos) {
        return pos.pos;
      })
    }));

    if (result === false) {
      datas.isClipStart = false;
      return false;
    }

    datas.isControl = className && className.indexOf("clip-control") > -1;
    datas.isLine = className.indexOf("clip-line") > -1;
    datas.isArea = className.indexOf("clip-area") > -1 || className.indexOf("clip-ellipse") > -1;
    datas.clipIndex = inputTarget ? parseInt(inputTarget.getAttribute("data-clip-index"), 10) : -1;
    datas.clipPath = clipPath;
    datas.isClipStart = true;
    state.clipPathState = clipText;
    setDragStart(moveable, e);
    return true;
  },
  dragControl: function (moveable, e) {
    var _a;

    var datas = e.datas,
        originalDatas = e.originalDatas,
        isDragTarget = e.isDragTarget;

    if (!datas.isClipStart) {
      return false;
    }

    var _b = datas,
        isControl = _b.isControl,
        isLine = _b.isLine,
        isArea = _b.isArea,
        clipIndex = _b.clipIndex,
        clipPath = _b.clipPath;

    if (!clipPath) {
      return false;
    }

    var keepRatio = moveable.props.keepRatio;
    var distX = 0;
    var distY = 0;
    var originalDraggable = originalDatas.draggable;
    var originalDist = getDragDist(e);

    if (isDragTarget && originalDraggable) {
      _a = originalDraggable.prevBeforeDist, distX = _a[0], distY = _a[1];
    } else {
      distX = originalDist[0], distY = originalDist[1];
    }

    var firstDist = [distX, distY];
    var props = moveable.props;
    var state = moveable.state;
    var width = state.width,
        height = state.height;
    var isDragWithTarget = !isArea && !isControl && !isLine;
    var clipType = clipPath.type,
        clipPoses = clipPath.poses,
        splitter = clipPath.splitter;
    var poses = clipPoses.map(function (pos) {
      return pos.pos;
    });

    if (isDragWithTarget) {
      distX = -distX;
      distY = -distY;
    }

    var isAll = !isControl || clipPoses[clipIndex].direction === "nesw";
    var isRect = clipType === "inset" || clipType === "rect";
    var dists = clipPoses.map(function () {
      return [0, 0];
    });

    if (isControl && !isAll) {
      var _c = clipPoses[clipIndex],
          horizontal = _c.horizontal,
          vertical = _c.vertical;
      var dist = [distX * Math.abs(horizontal), distY * Math.abs(vertical)];
      dists = moveControlPos(clipPoses, clipIndex, dist, isRect, keepRatio);
    } else if (isAll) {
      dists = poses.map(function () {
        return [distX, distY];
      });
    }

    var nextPoses = poses.map(function (pos, i) {
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, dists[i]);
    });

    var guidePoses = __spreadArray([], nextPoses, true);

    state.snapBoundInfos = null;
    var isCircle = clipPath.type === "circle";
    var isEllipse = clipPath.type === "ellipse";

    if (isCircle || isEllipse) {
      var guideRect = getRect(nextPoses);
      var ry = Math.abs(guideRect.bottom - guideRect.top);
      var rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);
      var bottom = nextPoses[0][1] + ry;
      var left = nextPoses[0][0] - rx;
      var right = nextPoses[0][0] + rx; // right

      if (isCircle) {
        guidePoses.push([right, guideRect.bottom]);
        dists.push([1, 0]);
      } // bottom


      guidePoses.push([guideRect.left, bottom]);
      dists.push([0, 1]); // left

      guidePoses.push([left, guideRect.bottom]);
      dists.push([1, 0]);
    }

    var guidelines = getDefaultGuidelines((props.clipHorizontalGuidelines || []).map(function (v) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)("".concat(v), height);
    }), (props.clipVerticalGuidelines || []).map(function (v) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.convertUnitSize)("".concat(v), width);
    }), width, height);
    var guideXPoses = [];
    var guideYPoses = [];

    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      var rectDists_1 = [dists[0], dists[2], dists[4], dists[6]];
      guideXPoses = rectPoses.filter(function (_, i) {
        return rectDists_1[i][0];
      }).map(function (pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.filter(function (_, i) {
        return rectDists_1[i][1];
      }).map(function (pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.filter(function (_, i) {
        return dists[i][0];
      }).map(function (pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.filter(function (_, i) {
        return dists[i][1];
      }).map(function (pos) {
        return pos[1];
      });
    }

    var boundDelta = [0, 0];

    var _d = checkSnapBounds(guidelines, props.clipTargetBounds && {
      left: 0,
      top: 0,
      right: width,
      bottom: height
    }, guideXPoses, guideYPoses, 5),
        horizontalSnapInfo = _d.horizontal,
        verticalSnapInfo = _d.vertical;

    var snapOffsetY = horizontalSnapInfo.offset;
    var snapOffsetX = verticalSnapInfo.offset;

    if (horizontalSnapInfo.isBound) {
      boundDelta[1] += snapOffsetY;
    }

    if (verticalSnapInfo.isBound) {
      boundDelta[0] += snapOffsetX;
    }

    if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {
      var guideRect = getRect(nextPoses);
      var cy = guideRect.bottom - guideRect.top;
      var cx = isEllipse ? guideRect.right - guideRect.left : cy;
      var distSnapX = verticalSnapInfo.isBound ? Math.abs(snapOffsetX) : verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX;
      var distSnapY = horizontalSnapInfo.isBound ? Math.abs(snapOffsetY) : horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY;
      cx -= distSnapX;
      cy -= distSnapY;

      if (isCircle) {
        cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;
        cx = cy;
      }

      var center = guidePoses[0];
      guidePoses[1][1] = center[1] - cy;
      guidePoses[2][0] = center[0] + cx;
      guidePoses[3][1] = center[1] + cy;
      guidePoses[4][0] = center[0] - cx;
    } else if (isRect && keepRatio && isControl) {
      var _e = getControlSize(clipPoses),
          width_1 = _e[0],
          height_1 = _e[1];

      var ratio = width_1 && height_1 ? width_1 / height_1 : 0;
      var clipPose = clipPoses[clipIndex];
      var direction = clipPose.direction || "";
      var top = guidePoses[1][1];
      var bottom = guidePoses[5][1];
      var left = guidePoses[7][0];
      var right = guidePoses[3][0];

      if (snapOffsetY <= snapOffsetX) {
        snapOffsetY = snapOffsetX / ratio;
      } else {
        snapOffsetX = snapOffsetY * ratio;
      }

      if (direction.indexOf("w") > -1) {
        left -= snapOffsetX;
      } else if (direction.indexOf("e") > -1) {
        right -= snapOffsetX;
      } else {
        left += snapOffsetX / 2;
        right -= snapOffsetX / 2;
      }

      if (direction.indexOf("n") > -1) {
        top -= snapOffsetY;
      } else if (direction.indexOf("s") > -1) {
        bottom -= snapOffsetY;
      } else {
        top += snapOffsetY / 2;
        bottom -= snapOffsetY / 2;
      }

      var nextControlPoses_2 = getRectPoses(top, right, bottom, left);
      guidePoses.forEach(function (pos, i) {
        var _a;

        _a = nextControlPoses_2[i].pos, pos[0] = _a[0], pos[1] = _a[1];
      });
    } else {
      guidePoses.forEach(function (pos, j) {
        var dist = dists[j];

        if (dist[0]) {
          pos[0] -= snapOffsetX;
        }

        if (dist[1]) {
          pos[1] -= snapOffsetY;
        }
      });
    }

    var nextClipStyles = getClipStyles(moveable, clipPath, nextPoses);
    var clipStyle = "".concat(clipType, "(").concat(nextClipStyles.join(splitter), ")");
    state.clipPathState = clipStyle;

    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      guideXPoses = rectPoses.map(function (pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.map(function (pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.map(function (pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.map(function (pos) {
        return pos[1];
      });
    }

    state.snapBoundInfos = checkSnapBounds(guidelines, props.clipTargetBounds && {
      left: 0,
      top: 0,
      right: width,
      bottom: height
    }, guideXPoses, guideYPoses, 1);

    if (originalDraggable) {
      var is3d = state.is3d,
          allMatrix = state.allMatrix;
      var n = is3d ? 4 : 3;
      var dragDist = boundDelta;

      if (isDragTarget) {
        dragDist = [firstDist[0] + boundDelta[0] - originalDist[0], firstDist[1] + boundDelta[1] - originalDist[1]];
      }

      originalDraggable.deltaOffset = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(allMatrix, [dragDist[0], dragDist[1], 0, 0], n);
    }

    triggerEvent(moveable, "onClip", fillParams(moveable, e, {
      clipEventType: "changed",
      clipType: clipType,
      poses: nextPoses,
      clipStyle: clipStyle,
      clipStyles: nextClipStyles,
      distX: distX,
      distY: distY
    }));
    return true;
  },
  dragControlEnd: function (moveable, e) {
    this.unset(moveable);
    var isDrag = e.isDrag,
        datas = e.datas,
        isDouble = e.isDouble;
    var isLine = datas.isLine,
        isClipStart = datas.isClipStart,
        isControl = datas.isControl;

    if (!isClipStart) {
      return false;
    }

    triggerEvent(moveable, "onClipEnd", fillEndParams(moveable, e, {}));

    if (isDouble) {
      if (isControl) {
        removeClipPath(moveable, e);
      } else if (isLine) {
        // add
        addClipPath(moveable, e);
      }
    }

    return isDouble || isDrag;
  },
  unset: function (moveable) {
    moveable.state.clipPathState = "";
    moveable.state.snapBoundInfos = null;
  }
};
/**
 * Whether to clip the target. (default: false)
 * @name Moveable.Clippable#clippable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)
 * @name Moveable.Clippable#defaultClipPath
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px (`rect` not possible) (default: false)
 * @name Moveable.Clippable#clipRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)
 * @name Moveable.Clippable#customClipPath
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When dragging the target, the clip also moves. (default: true)
 * @name Moveable.Clippable#dragWithClip
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * You can drag the clip by setting clipArea. (default: false)
 * @name Moveable.Clippable#clipArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
* Whether the clip is bound to the target. (default: false)
* @name Moveable.Clippable#clipTargetBounds
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipTargetBounds: true,
* });
* moveable.on("clipStart", e => {
*     console.log(e);
* }).on("clip", e => {
*     if (e.clipType === "rect") {
*         e.target.style.clip = e.clipStyle;
*     } else {
*         e.target.style.clipPath = e.clipStyle;
*     }
* }).on("clipEnd", e => {
*     console.log(e);
* });
*/

/**
* Add clip guidelines in the vertical direction. (default: [])
* @name Moveable.Clippable#clipVerticalGuidelines
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
* Add clip guidelines in the horizontal direction. (default: [])
* @name Moveable.Clippable#clipHorizontalGuidelines
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
* istance value that can snap to clip guidelines. (default: 5)
* @name Moveable.Clippable#clipSnapThreshold
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
 * When drag start the clip area or controls, the `clipStart` event is called.
 * @memberof Moveable.Clippable
 * @event clipStart
 * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag the clip area or controls, the `clip` event is called.
 * @memberof Moveable.Clippable
 * @event clip
 * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag end the clip area or controls, the `clipEnd` event is called.
 * @memberof Moveable.Clippable
 * @event clipEnd
 * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * @namespace OriginDraggable
 * @memberof Moveable
 * @description Whether to drag origin (default: false)
 */

var OriginDraggable = {
  name: "originDraggable",
  props: {
    originDraggable: Boolean,
    originRelative: Boolean
  },
  events: {
    onDragOriginStart: "dragOriginStart",
    onDragOrigin: "dragOrigin",
    onDragOriginEnd: "dragOriginEnd"
  },
  css: [":host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}"],
  dragControlCondition: function (_, e) {
    if (e.isRequest) {
      return e.requestAble === "originDraggable";
    }

    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(e.inputEvent.target, prefix("origin"));
  },
  dragControlStart: function (moveable, e) {
    var datas = e.datas;
    setDragStart(moveable, e);
    var params = fillParams(moveable, e, {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    });
    var result = triggerEvent(moveable, "onDragOriginStart", params);
    datas.startOrigin = moveable.state.transformOrigin;
    datas.startTargetOrigin = moveable.state.targetOrigin;
    datas.prevOrigin = [0, 0];
    datas.isDragOrigin = true;

    if (result === false) {
      datas.isDragOrigin = false;
      return false;
    }

    return params;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        isRequest = e.isRequest;

    if (!datas.isDragOrigin) {
      return false;
    }

    var _a = getDragDist(e),
        distX = _a[0],
        distY = _a[1];

    var state = moveable.state;
    var width = state.width,
        height = state.height,
        offsetMatrix = state.offsetMatrix,
        targetMatrix = state.targetMatrix,
        is3d = state.is3d;
    var _b = moveable.props.originRelative,
        originRelative = _b === void 0 ? true : _b;
    var n = is3d ? 4 : 3;
    var dist = [distX, distY];

    if (isRequest) {
      var distOrigin = e.distOrigin;

      if (distOrigin[0] || distOrigin[1]) {
        dist = distOrigin;
      }
    }

    var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(datas.startOrigin, dist);
    var targetOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(datas.startTargetOrigin, dist);
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, datas.prevOrigin);
    var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);
    var rect = moveable.getRect();
    var nextRect = getRect(calculatePoses(nextMatrix, width, height, n));
    var dragDelta = [rect.left - nextRect.left, rect.top - nextRect.top];
    datas.prevOrigin = dist;
    var transformOrigin = [convertCSSSize(targetOrigin[0], width, originRelative), convertCSSSize(targetOrigin[1], height, originRelative)].join(" ");
    var params = fillParams(moveable, e, {
      width: width,
      height: height,
      origin: origin,
      dist: dist,
      delta: delta,
      transformOrigin: transformOrigin,
      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onDragOrigin", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isDragOrigin) {
      return false;
    }

    triggerEvent(moveable, "onDragOriginEnd", fillEndParams(moveable, e, {}));
    return true;
  },
  dragGroupControlCondition: function (moveable, e) {
    return this.dragControlCondition(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    return true;
  },
  dragGroupControl: function (moveable, e) {
    var params = this.dragControl(moveable, e);

    if (!params) {
      return false;
    }

    moveable.transformOrigin = params.transformOrigin;
    return true;
  },

  /**
  * @method Moveable.OriginDraggable#request
  * @param {object} e - the OriginDraggable's request parameter
  * @param {number} [e.x] - x position
  * @param {number} [e.y] - y position
  * @param {number} [e.deltaX] - x number to move
  * @param {number} [e.deltaY] - y number to move
  * @param {array} [e.deltaOrigin] - left, top number to move transform-origin
  * @param {array} [e.origin] - transform-origin position
  * @param {number} [e.isInstant] - Whether to execute the request instantly
  * @return {Moveable.Requester} Moveable Requester
  * @example
   * // Instantly Request (requestStart - request - requestEnd)
  * // Use Relative Value
  * moveable.request("originDraggable", { deltaX: 10, deltaY: 10 }, true);
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 }, true);
  * // Use Transform Value
  * moveable.request("originDraggable", { deltaOrigin: [10, 0] }, true);
  * moveable.request("originDraggable", { origin: [100, 0] }, true);
  * // requestStart
  * const requester = moveable.request("originDraggable");
  *
  * // request
  * // Use Relative Value
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 });
  * moveable.request("originDraggable", { x: 220, y: 100 });
  * moveable.request("originDraggable", { x: 240, y: 100 });
  *
  * // requestEnd
  * requester.requestEnd();
  */
  request: function (moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    var transformOrigin = rect.transformOrigin;
    var distOrigin = [0, 0];
    return {
      isControl: true,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("deltaOrigin" in e) {
          distOrigin[0] += e.deltaOrigin[0];
          distOrigin[1] += e.deltaOrigin[1];
        } else if ("origin" in e) {
          distOrigin[0] = e.origin[0] - transformOrigin[0];
          distOrigin[1] = e.origin[1] - transformOrigin[1];
        } else {
          if ("x" in e) {
            distX = e.x - rect.left;
          } else if ("deltaX" in e) {
            distX += e.deltaX;
          }

          if ("y" in e) {
            distY = e.y - rect.top;
          } else if ("deltaY" in e) {
            distY += e.deltaY;
          }
        }

        return {
          datas: datas,
          distX: distX,
          distY: distY,
          distOrigin: distOrigin
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether to drag origin (default: false)
 * @name Moveable.OriginDraggable#originDraggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     originDraggable: true,
 * });
 * let translate = [0, 0];
 * moveable.on("dragOriginStart", e => {
 *     e.dragStart && e.dragStart.set(translate);
 * }).on("dragOrigin", e => {
 *     translate = e.drag.beforeTranslate;
 *     e.target.style.cssText
 *         = `transform-origin: ${e.transformOrigin};`
 *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
 * }).on("dragOriginEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px (default: true)
 * @name Moveable.OriginDraggable#originRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     originDraggable: true,
 *     originRelative: false,
 * });
 * moveable.originRelative = true;
 */

/**
* When drag start the origin, the `dragOriginStart` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOriginStart
* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

/**
* When drag the origin, the `dragOrigin` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOrigin
* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

/**
* When drag end the origin, the `dragOriginEnd` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOriginEnd
* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

function addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height) {
  var _a = splitRadiusPoses(controlPoses),
      horizontals = _a.horizontals,
      verticals = _a.verticals;

  var horizontalsLength = horizontals.length;
  var verticalsLength = verticals.length; // lineIndex
  // 0 top
  // 1 right
  // 2 left
  // 3 bottom
  // 0 top - left
  // 1 top - right
  // 2 bottom - right
  // 3 bottom - left
  // 0 left - top
  // 1 right - top
  // 2 right - bottom
  // 3 left - bottom

  var horizontalIndex = -1;
  var verticalIndex = -1;

  if (lineIndex === 0) {
    if (horizontalsLength === 0) {
      horizontalIndex = 0;
    } else if (horizontalsLength === 1) {
      horizontalIndex = 1;
    }
  } else if (lineIndex === 3) {
    if (horizontalsLength <= 2) {
      horizontalIndex = 2;
    } else if (horizontalsLength <= 3) {
      horizontalIndex = 3;
    }
  }

  if (lineIndex === 2) {
    if (verticalsLength === 0) {
      verticalIndex = 0;
    } else if (verticalsLength < 4) {
      verticalIndex = 3;
    }
  } else if (lineIndex === 1) {
    if (verticalsLength <= 1) {
      verticalIndex = 1;
    } else if (verticalsLength <= 2) {
      verticalIndex = 2;
    }
  }

  addRadiusPos(controlPoses, poses, 0, horizontalIndex, verticalIndex, distX, distY, width, height);
}

function getBorderRadius(target, width, height, minCounts, state) {
  if (minCounts === void 0) {
    minCounts = [0, 0];
  }

  var borderRadius;
  var values = [];

  if (!state) {
    var style = getComputedStyle(target);
    borderRadius = style && style.borderRadius || "";
  } else {
    borderRadius = state;
  }

  if (!borderRadius || !state && borderRadius === "0px") {
    values = [];
  } else {
    values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitSpace)(borderRadius);
  }

  return getRadiusValues(values, width, height, 0, 0, minCounts);
}

function triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses) {
  var state = moveable.state;
  var width = state.width,
      height = state.height;

  var _a = getRadiusStyles(nextPoses, controlPoses, moveable.props.roundRelative, width, height),
      raws = _a.raws,
      styles = _a.styles;

  var _b = splitRadiusPoses(controlPoses, raws),
      horizontals = _b.horizontals,
      verticals = _b.verticals;

  var borderRadius = styles.join(" ");
  state.borderRadiusState = borderRadius;
  triggerEvent(moveable, "onRound", fillParams(moveable, e, {
    horizontals: horizontals,
    verticals: verticals,
    borderRadius: borderRadius,
    width: width,
    height: height,
    delta: delta,
    dist: dist
  }));
}
/**
 * @namespace Moveable.Roundable
 * @description Whether to show and drag or double click border-radius
 */


var Roundable = {
  name: "roundable",
  props: {
    roundable: Boolean,
    roundRelative: Boolean,
    minRoundControls: Array,
    maxRoundControls: Array,
    roundClickable: Boolean
  },
  events: {
    onRoundStart: "roundStart",
    onRound: "round",
    onRoundEnd: "roundEnd"
  },
  css: [".control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}", ":host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}"],
  render: function (moveable, React) {
    var _a = moveable.state,
        target = _a.target,
        width = _a.width,
        height = _a.height,
        allMatrix = _a.allMatrix,
        is3d = _a.is3d,
        left = _a.left,
        top = _a.top,
        borderRadiusState = _a.borderRadiusState;
    var _b = moveable.props,
        _c = _b.minRoundControls,
        minRoundControls = _c === void 0 ? [0, 0] : _c,
        _d = _b.maxRoundControls,
        maxRoundControls = _d === void 0 ? [4, 4] : _d,
        zoom = _b.zoom;

    if (!target) {
      return null;
    }

    var n = is3d ? 4 : 3;
    var radiusValues = getBorderRadius(target, width, height, minRoundControls, borderRadiusState);

    if (!radiusValues) {
      return null;
    }

    var verticalCount = 0;
    var horizontalCount = 0;
    return radiusValues.map(function (v, i) {
      horizontalCount += Math.abs(v.horizontal);
      verticalCount += Math.abs(v.vertical);
      var pos = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, v.pos, n), [left, top]);
      var isDisplay = v.vertical ? verticalCount <= maxRoundControls[1] : horizontalCount <= maxRoundControls[0];
      return React.createElement("div", {
        key: "borderRadiusControl".concat(i),
        className: prefix("control", "border-radius"),
        "data-radius-index": i,
        style: {
          display: isDisplay ? "block" : "none",
          transform: "translate(".concat(pos[0], "px, ").concat(pos[1], "px) scale(").concat(zoom, ")")
        }
      });
    });
  },
  dragControlCondition: function (moveable, e) {
    if (!e.inputEvent || e.isRequest) {
      return false;
    }

    var className = e.inputEvent.target.getAttribute("class") || "";
    return className.indexOf("border-radius") > -1 || className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
  },
  dragControlStart: function (moveable, e) {
    var inputEvent = e.inputEvent,
        datas = e.datas;
    var inputTarget = inputEvent.target;
    var className = inputTarget.getAttribute("class") || "";
    var isControl = className.indexOf("border-radius") > -1;
    var isLine = className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
    var controlIndex = isControl ? parseInt(inputTarget.getAttribute("data-radius-index"), 10) : -1;
    var lineIndex = isLine ? parseInt(inputTarget.getAttribute("data-line-index"), 10) : -1;

    if (!isControl && !isLine) {
      return false;
    }

    var result = triggerEvent(moveable, "onRoundStart", fillParams(moveable, e, {}));

    if (result === false) {
      return false;
    }

    datas.lineIndex = lineIndex;
    datas.controlIndex = controlIndex;
    datas.isControl = isControl;
    datas.isLine = isLine;
    setDragStart(moveable, e);
    var _a = moveable.props,
        roundRelative = _a.roundRelative,
        _b = _a.minRoundControls,
        minRoundControls = _b === void 0 ? [0, 0] : _b;
    var state = moveable.state;
    var target = state.target,
        width = state.width,
        height = state.height;
    datas.isRound = true;
    datas.prevDist = [0, 0];
    var controlPoses = getBorderRadius(target, width, height, minRoundControls) || [];
    datas.controlPoses = controlPoses;
    state.borderRadiusState = getRadiusStyles(controlPoses.map(function (pos) {
      return pos.pos;
    }), controlPoses, roundRelative, width, height).styles.join(" ");
    return true;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {
      return false;
    }

    var index = datas.controlIndex;
    var controlPoses = datas.controlPoses;

    var _a = getDragDist(e),
        distX = _a[0],
        distY = _a[1];

    var dist = [distX, distY];
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, datas.prevDist);
    var _b = moveable.props.maxRoundControls,
        maxRoundControls = _b === void 0 ? [4, 4] : _b;
    var _c = moveable.state,
        width = _c.width,
        height = _c.height;
    var selectedControlPose = controlPoses[index];
    var selectedVertical = selectedControlPose.vertical;
    var selectedHorizontal = selectedControlPose.horizontal; // 0: [0, 1, 2, 3] maxCount === 1
    // 0: [0, 2] maxCount === 2
    // 1: [1, 3] maxCount === 2
    // 0: [0] maxCount === 3
    // 1: [1, 3] maxCount === 3

    var dists = controlPoses.map(function (pose) {
      var horizontal = pose.horizontal,
          vertical = pose.vertical;
      var poseDist = [horizontal * selectedHorizontal * dist[0], vertical * selectedVertical * dist[1]];

      if (horizontal) {
        if (maxRoundControls[0] === 1) {
          return poseDist;
        } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {
          return poseDist;
        }
      } else if (maxRoundControls[1] === 0) {
        poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;
        return poseDist;
      } else if (selectedVertical) {
        if (maxRoundControls[1] === 1) {
          return poseDist;
        } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {
          return poseDist;
        }
      }

      return [0, 0];
    });
    dists[index] = dist;
    var nextPoses = controlPoses.map(function (pos, i) {
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos.pos, dists[i]);
    });
    datas.prevDist = [distX, distY];
    triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses);
    return true;
  },
  dragControlEnd: function (moveable, e) {
    var state = moveable.state;
    state.borderRadiusState = "";
    var datas = e.datas,
        isDouble = e.isDouble;

    if (!datas.isRound) {
      return false;
    }

    var width = state.width,
        height = state.height;
    var isControl = datas.isControl,
        controlIndex = datas.controlIndex,
        isLine = datas.isLine,
        lineIndex = datas.lineIndex;
    var controlPoses = datas.controlPoses;
    var poses = controlPoses.map(function (pos) {
      return pos.pos;
    });
    var length = poses.length;
    var _a = moveable.props.roundClickable,
        roundClickable = _a === void 0 ? true : _a;

    if (isDouble && roundClickable) {
      if (isControl) {
        removeRadiusPos(controlPoses, poses, controlIndex, 0);
      } else if (isLine) {
        var _b = calculatePointerDist(moveable, e),
            distX = _b[0],
            distY = _b[1];

        addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);
      }

      if (length !== controlPoses.length) {
        triggerRoundEvent(moveable, e, [0, 0], [0, 0], controlPoses, poses);
      }
    }

    triggerEvent(moveable, "onRoundEnd", fillEndParams(moveable, e, {}));
    state.borderRadiusState = "";
    return true;
  },
  unset: function (moveable) {
    moveable.state.borderRadiusState = "";
  }
};
/**
 * Whether to show and drag or double click border-radius, (default: false)
 * @name Moveable.Roundable#roundable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px
 * @name Moveable.Roundable#roundRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])
 * @name Moveable.Roundable#minRoundControls
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     minRoundControls: [0, 0],
 * });
 * moveable.maxRoundControls = [1, 0];
 */

/**
 * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])
 * @name Moveable.Roundable#maxRoundControls
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     maxRoundControls: [4, 4],
 * });
 * moveable.maxRoundControls = [1, 0];
 */

/**
 * @property - Whether you can add/delete round controls by double-clicking a line or control. (default: true)
 * @name Moveable.Roundable#roundClickable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     roundClickable: true,
 * });
 * moveable.roundClickable = false;
 */

/**
 * When drag start the clip area or controls, the `roundStart` event is called.
 * @memberof Moveable.Roundable
 * @event roundStart
 * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag or double click the border area or controls, the `round` event is called.
 * @memberof Moveable.Roundable
 * @event round
 * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event
 * @example
  * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag end the border area or controls, the `roundEnd` event is called.
 * @memberof Moveable.Roundable
 * @event roundEnd
 * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event
 * @example
  * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

function isIdentityMatrix(matrix, is3d) {
  var value = is3d ? "matrix3d(".concat((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(4)) : "matrix(".concat((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(3), ")");
  return matrix === value || matrix === "matrix(1,0,0,1,0,0)";
}

var BeforeRenderable = {
  isPinch: true,
  name: "beforeRenderable",
  props: {},
  events: {
    onBeforeRenderStart: "beforeRenderStart",
    onBeforeRender: "beforeRender",
    onBeforeRenderEnd: "beforeRenderEnd",
    onBeforeRenderGroupStart: "beforeRenderGroupStart",
    onBeforeRenderGroup: "beforeRenderGroup",
    onBeforeRenderGroupEnd: "beforeRenderGroupEnd"
  },
  dragRelation: "weak",
  setTransform: function (moveable, e) {
    var _a = moveable.state,
        is3d = _a.is3d,
        target = _a.target,
        targetMatrix = _a.targetMatrix;
    var transform = target === null || target === void 0 ? void 0 : target.style.transform;
    var cssMatrix = is3d ? "matrix3d(".concat(targetMatrix.join(","), ")") : "matrix(".concat((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertMatrixtoCSS)(targetMatrix, true), ")");
    var startTransform = !transform || transform === "none" ? cssMatrix : transform;
    e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitSpace)(startTransform);
  },
  resetTransform: function (e) {
    e.datas.nextTransforms = e.datas.startTransforms;
    e.datas.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function (moveable, e) {
    return fillParams(moveable, e, {
      setTransform: function (transform) {
        e.datas.startTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitSpace)(transform);
      },
      isPinch: !!e.isPinch
    });
  },
  fillDragParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch
    });
  },
  dragStart: function (moveable, e) {
    this.setTransform(moveable, e);
    triggerEvent(moveable, "onBeforeRenderStart", this.fillDragStartParams(moveable, e));
  },
  drag: function (moveable, e) {
    this.resetTransform(e);
    triggerEvent(moveable, "onBeforeRender", fillParams(moveable, e, {
      isPinch: !!e.isPinch
    }));
  },
  dragEnd: function (moveable, e) {
    triggerEvent(moveable, "onBeforeRenderEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    }));
  },
  dragGroupStart: function (moveable, e) {
    var _this = this;

    this.dragStart(moveable, e);
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];

      _this.setTransform(childMoveable, childEvent);

      return _this.fillDragStartParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroupStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      setTransform: function () {},
      events: params
    }));
  },
  dragGroup: function (moveable, e) {
    var _this = this;

    this.drag(moveable, e);
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];

      _this.resetTransform(childEvent);

      return _this.fillDragParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroup", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      events: params
    }));
  },
  dragGroupEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
    triggerEvent(moveable, "onBeforeRenderGroupEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: moveable.props.targets
    }));
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragGroupStart(moveable, e);
  },
  dragGroupControl: function (moveable, e) {
    return this.dragGroup(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    return this.dragGroupEnd(moveable, e);
  }
};
var Renderable = {
  name: "renderable",
  props: {},
  events: {
    onRenderStart: "renderStart",
    onRender: "render",
    onRenderEnd: "renderEnd",
    onRenderGroupStart: "renderGroupStart",
    onRenderGroup: "renderGroup",
    onRenderGroupEnd: "renderGroupEnd"
  },
  dragRelation: "weak",
  dragStart: function (moveable, e) {
    triggerEvent(moveable, "onRenderStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch
    }));
  },
  drag: function (moveable, e) {
    triggerEvent(moveable, "onRender", this.fillDragParams(moveable, e));
  },
  dragAfter: function (moveable, e) {
    if (e.resultCount) {
      return this.drag(moveable, e);
    }
  },
  dragEnd: function (moveable, e) {
    triggerEvent(moveable, "onRenderEnd", this.fillDragEndParams(moveable, e));
  },
  dragGroupStart: function (moveable, e) {
    triggerEvent(moveable, "onRenderGroupStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets
    }));
  },
  dragGroup: function (moveable, e) {
    var _this = this;

    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];
      return _this.fillDragParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onRenderGroup", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      transform: getNextTransformText(e),
      events: params
    }));
  },
  dragGroupEnd: function (moveable, e) {
    var _this = this;

    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];
      return _this.fillDragEndParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onRenderGroupEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: moveable.props.targets,
      events: params
    }));
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlAfter: function (moveable, e) {
    return this.dragAfter(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragGroupStart(moveable, e);
  },
  dragGroupControl: function (moveable, e) {
    return this.dragGroup(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    return this.dragGroupEnd(moveable, e);
  },
  fillDragParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      transform: getNextTransformText(e)
    });
  },
  fillDragEndParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    });
  }
};

function triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e, requestInstant) {
  var isStart = eventType === "Start";
  var target = moveable.state.target;
  var isRequest = e.isRequest;

  if (!target || isStart && eventAffix.indexOf("Control") > -1 && !isRequest && moveable.areaElement === e.inputEvent.target) {
    return false;
  } // "drag" "Control" "After"


  var eventName = "".concat(eventOperation).concat(eventAffix).concat(eventType);
  var conditionName = "".concat(eventOperation).concat(eventAffix, "Condition");
  var isEnd = eventType === "End";
  var isAfter = eventType === "After";
  var isFirstStart = isStart && (!moveable.targetGesto || !moveable.controlGesto || !moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag());

  if (isFirstStart) {
    moveable.updateRect(eventType, true, false);
  }

  if (eventType === "" && !isRequest) {
    convertDragDist(moveable.state, e);
  } // const isGroup = eventAffix.indexOf("Group") > -1;


  var ables = __spreadArray([], moveable[ableType], true);

  if (isRequest) {
    var requestAble_1 = e.requestAble;

    if (!ables.some(function (able) {
      return able.name === requestAble_1;
    })) {
      ables.push.apply(ables, moveable.props.ables.filter(function (able) {
        return able.name === requestAble_1;
      }));
    }
  }

  if (!ables.length) {
    return false;
  }

  var eventAbles = __spreadArray(__spreadArray([BeforeRenderable], ables, true), [Renderable], false).filter(function (able) {
    return able[eventName];
  });

  var datas = e.datas;

  if (isFirstStart) {
    eventAbles.forEach(function (able) {
      able.unset && able.unset(moveable);
    });
  }

  var inputEvent = e.inputEvent;
  var inputTarget;

  if (isEnd && inputEvent) {
    inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;
  }

  var resultCount = 0;
  var results = eventAbles.filter(function (able) {
    var ableName = able.name;
    var nextDatas = datas[ableName] || (datas[ableName] = {});

    if (isStart) {
      nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e);
    }

    if (nextDatas.isEventStart) {
      var result = able[eventName](moveable, __assign(__assign({}, e), {
        resultCount: resultCount,
        datas: nextDatas,
        originalDatas: datas,
        inputTarget: inputTarget
      }));

      moveable._emitter.off();

      if (isStart && result === false) {
        nextDatas.isEventStart = false;
      }

      resultCount += result ? 1 : 0;
      return result;
    }

    return false;
  });
  var isUpdate = results.length;
  var isForceEnd = false; // end ables

  if (isStart && eventAbles.length && !isUpdate) {
    isForceEnd = eventAbles.filter(function (able) {
      var ableName = able.name;
      var nextDatas = datas[ableName];

      if (nextDatas.isEventStart) {
        if (able.dragRelation === "strong") {
          // cancel drag
          nextDatas.isEventStart = false;
          return false;
        } // start drag


        return true;
      } // cancel event


      return false;
    }).length === 0;
  }

  if (isEnd || isForceEnd) {
    moveable.state.gesto = null;

    if (moveable.moveables) {
      moveable.moveables.forEach(function (childMoveable) {
        childMoveable.state.gesto = null;
      });
    }
  }

  if (isFirstStart && isForceEnd) {
    eventAbles.forEach(function (able) {
      able.unset && able.unset(moveable);
    });
  }

  if (isStart && !isRequest && isUpdate) {
    e === null || e === void 0 ? void 0 : e.preventDefault();
  }

  if (moveable.isUnmounted || isForceEnd) {
    return false;
  }

  if (!isStart && isUpdate && !requestInstant || isEnd) {
    var flushSync = moveable.props.flushSync || defaultSync;
    flushSync(function () {
      moveable.updateRect(isEnd ? eventType : "", true, false);
      moveable.forceUpdate();
    });
  }

  if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {
    triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + "After", e);
  }

  return true;
}

function getTargetAbleGesto(moveable, moveableTarget, eventAffix) {
  var controlBox = moveable.controlBox.getElement();
  var targets = [];
  targets.push(controlBox);

  if (!moveable.props.dragArea || moveable.props.dragTarget) {
    targets.push(moveableTarget);
  }

  var startFunc = function (e) {
    var eventTarget = e.inputEvent.target;
    var areaElement = moveable.areaElement;
    return eventTarget === areaElement || !moveable.isMoveableElement(eventTarget) && !moveable.controlBox.getElement().contains(eventTarget) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(eventTarget, "moveable-area") || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(eventTarget, "moveable-padding");
  };

  return getAbleGesto(moveable, targets, "targetAbles", eventAffix, {
    dragStart: startFunc,
    pinchStart: startFunc
  });
}

function getAbleGesto(moveable, target, ableType, eventAffix, conditionFunctions) {
  if (conditionFunctions === void 0) {
    conditionFunctions = {};
  }

  var _a = moveable.props,
      pinchOutside = _a.pinchOutside,
      pinchThreshold = _a.pinchThreshold;
  var options = {
    preventDefault: false,
    preventRightClick: true,
    preventWheelClick: true,
    container: window,
    pinchThreshold: pinchThreshold,
    pinchOutside: pinchOutside
  };
  var gesto = new gesto__WEBPACK_IMPORTED_MODULE_8__["default"](target, options);
  ["drag", "pinch"].forEach(function (eventOperation) {
    ["Start", "", "End"].forEach(function (eventType) {
      gesto.on("".concat(eventOperation).concat(eventType), function (e) {
        var eventName = e.eventType;

        if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {
          e.stop();
          return;
        }

        var result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);

        if (!result) {
          e.stop();
        }
      });
    });
  });
  return gesto;
}

var EventManager = /*#__PURE__*/function () {
  function EventManager(target, moveable, eventName) {
    var _this = this;

    this.target = target;
    this.moveable = moveable;
    this.eventName = eventName;
    this.ables = [];

    this._onEvent = function (e) {
      var eventName = _this.eventName;
      var moveable = _this.moveable;

      if (moveable.state.disableNativeEvent) {
        return;
      }

      _this.ables.forEach(function (able) {
        able[eventName](moveable, {
          inputEvent: e
        });
      });
    };

    target.addEventListener(eventName.toLowerCase(), this._onEvent);
  }

  var __proto = EventManager.prototype;

  __proto.setAbles = function (ables) {
    this.ables = ables;
  };

  __proto.destroy = function () {
    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent);
    this.target = null;
    this.moveable = null;
  };

  return EventManager;
}();

var MoveableManager = /*#__PURE__*/function (_super) {
  __extends(MoveableManager, _super);

  function MoveableManager() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = __assign({
      container: null,
      gesto: null,
      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],
      disableNativeEvent: false
    }, getTargetInfo(null));
    _this.enabledAbles = [];
    _this.targetAbles = [];
    _this.controlAbles = [];
    _this.rotation = 0;
    _this.scale = [1, 1];
    _this.isUnmounted = false;
    _this.events = {
      "mouseEnter": null,
      "mouseLeave": null
    };
    _this._emitter = new EventEmitter$1();
    _this._prevTarget = null;
    _this._prevDragArea = false;
    _this._observer = null;
    _this._observerId = 0;

    _this.onPreventClick = function (e) {
      e.stopPropagation();
      e.preventDefault();
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(window, "click", _this.onPreventClick, true);
    };

    _this.checkUpdateRect = function () {
      if (_this.isDragging()) {
        return;
      }

      var parentMoveable = _this.props.parentMoveable;

      if (parentMoveable) {
        parentMoveable.checkUpdateRect();
        return;
      }

      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.cancelAnimationFrame)(_this._observerId);
      _this._observerId = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.requestAnimationFrame)(function () {
        if (_this.isDragging()) {
          return;
        }

        _this.updateRect();
      });
    };

    return _this;
  }

  var __proto = MoveableManager.prototype;

  __proto.render = function () {
    var props = this.props;
    var state = this.state;
    var parentPosition = props.parentPosition,
        className = props.className,
        propsTarget = props.target,
        zoom = props.zoom,
        cspNonce = props.cspNonce,
        translateZ = props.translateZ,
        ControlBoxElement = props.cssStyled,
        portalContainer = props.portalContainer;
    this.checkUpdate();
    this.updateRenderPoses();

    var _a = parentPosition || {
      left: 0,
      top: 0
    },
        parentLeft = _a.left,
        parentTop = _a.top;

    var left = state.left,
        top = state.top,
        stateTarget = state.target,
        direction = state.direction,
        hasFixed = state.hasFixed;
    var groupTargets = props.targets;
    var isDisplay = (groupTargets && groupTargets.length || propsTarget) && stateTarget;
    var isDragging = this.isDragging();
    var ableAttributes = {};
    this.getEnabledAbles().forEach(function (able) {
      ableAttributes["data-able-".concat(able.name.toLowerCase())] = true;
    });
    return react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement(ControlBoxElement, __assign({
      cspNonce: cspNonce,
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, "controlBox"),
      className: "".concat(prefix("control-box", direction === -1 ? "reverse" : "", isDragging ? "dragging" : ""), " ").concat(className)
    }, ableAttributes, {
      onClick: this.onPreventClick,
      portalContainer: portalContainer,
      style: {
        "position": hasFixed ? "fixed" : "absolute",
        "display": isDisplay ? "block" : "none",
        "transform": "translate3d(".concat(left - parentLeft, "px, ").concat(top - parentTop, "px, ").concat(translateZ, ")"),
        "--zoom": zoom,
        "--zoompx": "".concat(zoom, "px")
      }
    }), this.renderAbles(), this._renderLines());
  };

  __proto.componentDidMount = function () {
    this.isUnmounted = false;
    this.controlBox.getElement();
    var props = this.props;
    var parentMoveable = props.parentMoveable,
        container = props.container,
        wrapperMoveable = props.wrapperMoveable;

    this._updateTargets();

    this._updateNativeEvents();

    this._updateEvents();

    if (!container && !parentMoveable && !wrapperMoveable) {
      this.updateRect("", false, true);
    }

    this.updateCheckInput();

    this._updateObserver(this.props);
  };

  __proto.componentDidUpdate = function (prevProps) {
    this._updateNativeEvents();

    this._updateEvents();

    this._updateTargets();

    this.updateCheckInput();

    this._updateObserver(prevProps);
  };

  __proto.componentWillUnmount = function () {
    this.isUnmounted = true;

    this._emitter.off();

    unset(this, "targetGesto");
    unset(this, "controlGesto");
    var events = this.events;

    for (var name in events) {
      var manager = events[name];
      manager && manager.destroy();
    }
  };

  __proto.getContainer = function () {
    var _a = this.props,
        parentMoveable = _a.parentMoveable,
        wrapperMoveable = _a.wrapperMoveable,
        container = _a.container;
    return container || wrapperMoveable && wrapperMoveable.getContainer() || parentMoveable && parentMoveable.getContainer() || this.controlBox.getElement().parentElement;
  };
  /**
   * Check if the target is an element included in the moveable.
   * @method Moveable#isMoveableElement
   * @param - the target
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("click", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *         moveable.target = e.target;
   *     }
   * });
   */


  __proto.isMoveableElement = function (target) {
    return target && (target.getAttribute("class") || "").indexOf(PREFIX) > -1;
  };
  /**
   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)
   * @method Moveable#dragStart
   * @param - external `MouseEvent`or `TouchEvent`
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *          moveable.dragStart(e);
   *     }
   * });
   */


  __proto.dragStart = function (e) {
    var targetGesto = this.targetGesto;

    if (targetGesto && !targetGesto.isFlag()) {
      targetGesto.triggerDragStart(e);
    }

    return this;
  };
  /**
   * Hit test an element or rect on a moveable target.
   * @method Moveable#hitTest
   * @param - element or rect to test
   * @return - Get hit test rate (rate > 0 is hitted)
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.hitTest(e.target) > 0) {
   *          console.log("hiited");
   *     }
   * });
   */


  __proto.hitTest = function (el) {
    var _a = this.state,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos3 = _a.pos3,
        pos4 = _a.pos4,
        targetClientRect = _a.targetClientRect;

    if (!target) {
      return 0;
    }

    var rect;

    if (el instanceof Element) {
      var clientRect = el.getBoundingClientRect();
      rect = {
        left: clientRect.left,
        top: clientRect.top,
        width: clientRect.width,
        height: clientRect.height
      };
    } else {
      rect = __assign({
        width: 0,
        height: 0
      }, el);
    }

    var rectLeft = rect.left,
        rectTop = rect.top,
        rectWidth = rect.width,
        rectHeight = rect.height;
    var points = (0,overlap_area__WEBPACK_IMPORTED_MODULE_3__.fitPoints)([pos1, pos2, pos4, pos3], targetClientRect);
    var size = (0,overlap_area__WEBPACK_IMPORTED_MODULE_3__.getOverlapSize)(points, [[rectLeft, rectTop], [rectLeft + rectWidth, rectTop], [rectLeft + rectWidth, rectTop + rectHeight], [rectLeft, rectTop + rectHeight]]);
    var totalSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_3__.getAreaSize)(points);

    if (!size || !totalSize) {
      return 0;
    }

    return Math.min(100, size / totalSize * 100);
  };
  /**
   * Whether the coordinates are inside Moveable
   * @method Moveable#isInside
   * @param - x coordinate
   * @param - y coordinate
   * @return - True if the coordinate is in moveable or false
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.isInside(e.clientX, e.clientY)) {
   *          console.log("inside");
   *     }
   * });
   */


  __proto.isInside = function (clientX, clientY) {
    var _a = this.state,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos3 = _a.pos3,
        pos4 = _a.pos4,
        targetClientRect = _a.targetClientRect;

    if (!target) {
      return false;
    }

    return (0,overlap_area__WEBPACK_IMPORTED_MODULE_3__.isInside)([clientX, clientY], (0,overlap_area__WEBPACK_IMPORTED_MODULE_3__.fitPoints)([pos1, pos2, pos4, pos3], targetClientRect));
  };
  /**
   * If the width, height, left, and top of all elements change, update the shape of the moveable.
   * @method Moveable#updateRect
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("resize", e => {
   *     moveable.updateRect();
   * });
   */


  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    var props = this.props;
    var parentMoveable = props.parentMoveable;
    var state = this.state;
    var target = state.target || this.props.target;
    var container = this.getContainer();
    var rootContainer = parentMoveable ? parentMoveable.props.rootContainer : props.rootContainer;
    this.updateState(getTargetInfo(this.controlBox && this.controlBox.getElement(), target, container, container, rootContainer || container), parentMoveable ? false : isSetState);
  };
  /**
   * Check if the moveable state is being dragged.
   * @method Moveable#isDragging
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // false
   * console.log(moveable.isDragging());
   *
   * moveable.on("drag", () => {
   *   // true
   *   console.log(moveable.isDragging());
   * });
   */


  __proto.isDragging = function () {
    return (this.targetGesto ? this.targetGesto.isFlag() : false) || (this.controlGesto ? this.controlGesto.isFlag() : false);
  };
  /**
   * If the width, height, left, and top of the only target change, update the shape of the moveable.
   * @method Moveable#updateTarget
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.updateTarget();
   */


  __proto.updateTarget = function (type) {
    this.updateRect(type, true);
  };
  /**
   * You can get the vertex information, position and offset size information of the target based on the container.
   * @method Moveable#getRect
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const rectInfo = moveable.getRect();
   */


  __proto.getRect = function () {
    var state = this.state;
    var poses = getAbsolutePosesByState(this.state);
    var pos1 = poses[0],
        pos2 = poses[1],
        pos3 = poses[2],
        pos4 = poses[3];
    var rect = getRect(poses);
    var offsetWidth = state.width,
        offsetHeight = state.height;
    var width = rect.width,
        height = rect.height,
        left = rect.left,
        top = rect.top;
    var statePos = [state.left, state.top];
    var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(statePos, state.origin);
    var beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(statePos, state.beforeOrigin);
    var transformOrigin = state.transformOrigin;
    return {
      width: width,
      height: height,
      left: left,
      top: top,
      pos1: pos1,
      pos2: pos2,
      pos3: pos3,
      pos4: pos4,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight,
      beforeOrigin: beforeOrigin,
      origin: origin,
      transformOrigin: transformOrigin,
      rotation: this.getRotation()
    };
  };
  /**
   * Get a manager that manages the moveable's state and props.
   * @method Moveable#getManager
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const manager = moveable.getManager(); // real moveable class instance
   */


  __proto.getManager = function () {
    return this;
  };

  __proto.getRotation = function () {
    var _a = this.state,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        direction = _a.direction;
    return getAbsoluteRotation(pos1, pos2, direction);
  };
  /**
   * Request able through a method rather than an event.
   * At the moment of execution, requestStart is executed,
   * and then request and requestEnd can be executed through Requester.
   * @method Moveable#request
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}
   * @param - ableName
   * @param - request to be able params.
   * @param - If isInstant is true, request and requestEnd are executed immediately.
   * @return - Able Requester. If there is no request in able, nothing will work.
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   *
   * // Start move
   * const requester = moveable.request("draggable");
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.requestEnd();
   */


  __proto.request = function (ableName, param, isInstant) {
    if (param === void 0) {
      param = {};
    }

    var _a = this.props,
        ables = _a.ables,
        groupable = _a.groupable;
    var requsetAble = ables.filter(function (able) {
      return able.name === ableName;
    })[0];

    if (this.isDragging() || !requsetAble || !requsetAble.request) {
      return {
        request: function () {
          return this;
        },
        requestEnd: function () {
          return this;
        }
      };
    }

    var self = this;
    var ableRequester = requsetAble.request(this);
    var requestInstant = isInstant || param.isInstant;
    var ableType = ableRequester.isControl ? "controlAbles" : "targetAbles";
    var eventAffix = "".concat(groupable ? "Group" : "").concat(ableRequester.isControl ? "Control" : "");
    var requester = {
      request: function (ableParam) {
        triggerAble(self, ableType, "drag", eventAffix, "", __assign(__assign({}, ableRequester.request(ableParam)), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      },
      requestEnd: function () {
        triggerAble(self, ableType, "drag", eventAffix, "End", __assign(__assign({}, ableRequester.requestEnd()), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      }
    };
    triggerAble(self, ableType, "drag", eventAffix, "Start", __assign(__assign({}, ableRequester.requestStart(param)), {
      requestAble: ableName,
      isRequest: true
    }), requestInstant);
    return requestInstant ? requester.request(param).requestEnd() : requester;
  };
  /**
   * Remove the Moveable object and the events.
   * @method Moveable#destroy
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.destroy();
   */


  __proto.destroy = function () {
    this.componentWillUnmount();
  };

  __proto.updateRenderPoses = function () {
    var state = this.state;
    var props = this.props;
    var originalBeforeOrigin = state.originalBeforeOrigin,
        transformOrigin = state.transformOrigin,
        allMatrix = state.allMatrix,
        is3d = state.is3d,
        pos1 = state.pos1,
        pos2 = state.pos2,
        pos3 = state.pos3,
        pos4 = state.pos4,
        stateLeft = state.left,
        stateTop = state.top;

    var _a = props.padding || {},
        _b = _a.left,
        left = _b === void 0 ? 0 : _b,
        _c = _a.top,
        top = _c === void 0 ? 0 : _c,
        _d = _a.bottom,
        bottom = _d === void 0 ? 0 : _d,
        _e = _a.right,
        right = _e === void 0 ? 0 : _e;

    var n = is3d ? 4 : 3;
    var absoluteOrigin = props.groupable ? originalBeforeOrigin : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(originalBeforeOrigin, [stateLeft, stateTop]);
    state.renderPoses = [(0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos1, calculatePadding(allMatrix, [-left, -top], transformOrigin, absoluteOrigin, n)), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos2, calculatePadding(allMatrix, [right, -top], transformOrigin, absoluteOrigin, n)), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos3, calculatePadding(allMatrix, [-left, bottom], transformOrigin, absoluteOrigin, n)), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos4, calculatePadding(allMatrix, [right, bottom], transformOrigin, absoluteOrigin, n))];
  };

  __proto.checkUpdate = function () {
    var _a = this.props,
        target = _a.target,
        container = _a.container,
        parentMoveable = _a.parentMoveable;
    var _b = this.state,
        stateTarget = _b.target,
        stateContainer = _b.container;

    if (!stateTarget && !target) {
      return;
    }

    this.updateAbles();
    var isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);

    if (!isChanged) {
      return;
    }

    var moveableContainer = container || this.controlBox;

    if (moveableContainer) {
      this.unsetAbles();
    }

    this.updateState({
      target: target,
      container: container
    });

    if (!parentMoveable && moveableContainer) {
      this.updateRect("End", false, false);
    }
  };

  __proto.triggerEvent = function (name, e) {
    this._emitter.trigger(name, e);

    var callback = this.props[name];
    return callback && callback(e);
  };

  __proto.useCSS = function (tag, css) {
    var customStyleMap = this.props.customStyledMap;
    var key = tag + css;

    if (!customStyleMap[key]) {
      customStyleMap[key] = (0,react_compat_css_styled__WEBPACK_IMPORTED_MODULE_10__["default"])(tag, css);
    }

    return customStyleMap[key];
  };

  __proto.unsetAbles = function () {
    var _this = this;

    this.targetAbles.forEach(function (able) {
      if (able.unset) {
        able.unset(_this);
      }
    });
  };

  __proto.updateAbles = function (ables, eventAffix) {
    if (ables === void 0) {
      ables = this.props.ables;
    }

    if (eventAffix === void 0) {
      eventAffix = "";
    }

    var props = this.props;
    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;
    var enabledAbles = ables.filter(function (able) {
      return able && (able.always && props[able.name] !== false || props[able.name]);
    });
    var dragStart = "drag".concat(eventAffix, "Start");
    var pinchStart = "pinch".concat(eventAffix, "Start");
    var dragControlStart = "drag".concat(eventAffix, "ControlStart");
    var targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);
    var controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);
    this.enabledAbles = enabledAbles;
    this.targetAbles = targetAbles;
    this.controlAbles = controlAbles;
  };

  __proto.updateState = function (nextState, isSetState) {
    if (isSetState) {
      if (this.isUnmounted) {
        return;
      }

      this.setState(nextState);
    } else {
      var state = this.state;

      for (var name in nextState) {
        state[name] = nextState[name];
      }
    }
  };

  __proto.getEnabledAbles = function () {
    var props = this.props;
    var ables = props.ables;
    return ables.filter(function (able) {
      return able && props[able.name];
    });
  };

  __proto.renderAbles = function () {
    var _this = this;

    var props = this.props;
    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;
    var Renderer = {
      createElement: react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement
    };
    return groupByMap(flat(filterAbles(this.getEnabledAbles(), ["render"], triggerAblesSimultaneously).map(function (_a) {
      var render = _a.render;
      return render(_this, Renderer) || [];
    })).filter(function (el) {
      return el;
    }), function (_a) {
      var key = _a.key;
      return key;
    }).map(function (group) {
      return group[0];
    });
  };

  __proto.updateCheckInput = function () {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  };

  __proto._updateObserver = function (prevProps) {
    var _a;

    var props = this.props;
    var target = props.target;

    if (!window.ResizeObserver || !target || !props.useResizeObserver) {
      (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();
      return;
    }

    if (prevProps.target === target && this._observer) {
      return;
    }

    var observer = new ResizeObserver(this.checkUpdateRect);
    observer.observe(target, {
      box: "border-box"
    });
    this._observer = observer;
    return;
  };

  __proto._updateEvents = function () {
    var controlBoxElement = this.controlBox.getElement();
    var hasTargetAble = this.targetAbles.length;
    var hasControlAble = this.controlAbles.length;
    var props = this.props;
    var target = props.dragTarget || props.target;

    var isUnset = !hasTargetAble && this.targetGesto || this._isTargetChanged(true);

    if (isUnset) {
      unset(this, "targetGesto");
      this.updateState({
        gesto: null
      });
    }

    if (!hasControlAble) {
      unset(this, "controlGesto");
    }

    if (target && hasTargetAble && !this.targetGesto) {
      this.targetGesto = getTargetAbleGesto(this, target, "");
    }

    if (!this.controlGesto && hasControlAble) {
      this.controlGesto = getAbleGesto(this, controlBoxElement, "controlAbles", "Control");
    }
  };

  __proto._updateTargets = function () {
    var props = this.props;
    this._prevTarget = props.dragTarget || props.target;
    this._prevDragArea = props.dragArea;
  };

  __proto._renderLines = function () {
    var props = this.props;
    var edge = props.edge,
        zoom = props.zoom,
        hideDefaultLines = props.hideDefaultLines;

    if (hideDefaultLines) {
      return [];
    }

    var renderPoses = this.state.renderPoses;
    var Renderer = {
      createElement: react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement
    };
    return [renderLine(Renderer, edge ? "n" : "", renderPoses[0], renderPoses[1], zoom, 0), renderLine(Renderer, edge ? "e" : "", renderPoses[1], renderPoses[3], zoom, 1), renderLine(Renderer, edge ? "w" : "", renderPoses[0], renderPoses[2], zoom, 2), renderLine(Renderer, edge ? "s" : "", renderPoses[2], renderPoses[3], zoom, 3)];
  };

  __proto._isTargetChanged = function (useDragArea) {
    var props = this.props;
    var target = props.dragTarget || props.target;
    var prevTarget = this._prevTarget;
    var prevDragArea = this._prevDragArea;
    var dragArea = props.dragArea; // check target without dragArea

    var isTargetChanged = !dragArea && prevTarget !== target;
    var isDragAreaChanged = (useDragArea || dragArea) && prevDragArea !== dragArea;
    return isTargetChanged || isDragAreaChanged;
  };

  __proto._updateNativeEvents = function () {
    var _this = this;

    var props = this.props;
    var target = props.dragArea ? this.areaElement : this.state.target;
    var events = this.events;
    var eventKeys = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getKeys)(events);

    if (this._isTargetChanged()) {
      for (var eventName in events) {
        var manager = events[eventName];
        manager && manager.destroy();
        events[eventName] = null;
      }
    }

    if (!target) {
      return;
    }

    var enabledAbles = this.enabledAbles;
    eventKeys.forEach(function (eventName) {
      var ables = filterAbles(enabledAbles, [eventName]);
      var hasAbles = ables.length > 0;
      var manager = events[eventName];

      if (!hasAbles) {
        if (manager) {
          manager.destroy();
          events[eventName] = null;
        }

        return;
      }

      if (!manager) {
        manager = new EventManager(target, _this, eventName);
        events[eventName] = manager;
      }

      manager.setAbles(ables);
    });
  };

  MoveableManager.defaultProps = {
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: true,
    edge: false,
    parentMoveable: null,
    wrapperMoveable: null,
    parentPosition: null,
    portalContainer: null,
    useResizeObserver: false,
    ables: [],
    pinchThreshold: 20,
    dragArea: false,
    passDragArea: false,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: false,
    padding: {},
    pinchOutside: true,
    checkInput: false,
    groupable: false,
    hideDefaultLines: false,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {},
    flushSync: defaultSync
  };
  return MoveableManager;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.PureComponent);
/**
 * The target to indicate Moveable Control Box.
 * @name Moveable#target
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.target = document.querySelector(".target");
 */

/**
 * Zooms in the elements of a moveable.
 * @name Moveable#zoom
 * @default 1
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.zoom = 2;
 */

/**
 * Whether the target size is detected and updated whenever it changes.
 * @name Moveable#zoom
 * @default false
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.useResizeObserver = true;
 */

/**
 * Resize, Scale Events at edges
 * @name Moveable#edge
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.edge = true;
 */

/**
 * You can specify the className of the moveable controlbox.
 * @name Moveable#className
 * @default ""
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   className: "",
 * });
 *
 * moveable.className = "moveable1";
 */

/**
 * The target(s) to drag Moveable target(s)
 * @name Moveable#dragTarget
 * @default target
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.target = document.querySelector(".target");
 * moveable.dragTarget = document.querySelector(".dragTarget");
 */

/**
 * `renderStart` event occurs at the first start of all events.
 * @memberof Moveable
 * @event renderStart
 * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("renderStart", ({ target }) => {
 *     console.log("onRenderStart", target);
 * });
 */

/**
 * `render` event occurs before the target is drawn on the screen.
 * @memberof Moveable
 * @event render
 * @param {Moveable.OnRender} - Parameters for the `render` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("render", ({ target }) => {
 *     console.log("onRender", target);
 * });
 */

/**
 * `renderEnd` event occurs at the end of all events.
 * @memberof Moveable
 * @event renderEnd
 * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("renderEnd", ({ target }) => {
 *     console.log("onRenderEnd", target);
 * });
 */

/**
 * `renderGroupStart` event occurs at the first start of all events in group.
 * @memberof Moveable
 * @event renderGroupStart
 * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroupStart", ({ targets }) => {
 *     console.log("onRenderGroupStart", targets);
 * });
 */

/**
 * `renderGroup` event occurs before the target is drawn on the screen in group.
 * @memberof Moveable
 * @event renderGroup
 * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroup", ({ targets }) => {
 *     console.log("onRenderGroup", targets);
 * });
 */

/**
 * `renderGroupEnd` event occurs at the end of all events in group.
 * @memberof Moveable
 * @event renderGroupEnd
 * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroupEnd", ({ targets }) => {
 *     console.log("onRenderGroupEnd", targets);
 * });
 */


var Groupable = {
  name: "groupable",
  props: {
    defaultGroupRotate: Number,
    defaultGroupOrigin: String,
    groupable: Boolean
  },
  events: {},
  render: function (moveable, React) {
    var targets = moveable.props.targets || [];
    moveable.moveables = [];
    var _a = moveable.state,
        left = _a.left,
        top = _a.top;
    var position = {
      left: left,
      top: top
    };
    var props = moveable.props;
    return targets.map(function (target, i) {
      return React.createElement(MoveableManager, {
        key: "moveable" + i,
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.refs)(moveable, "moveables", i),
        target: target,
        origin: false,
        cssStyled: props.cssStyled,
        customStyledMap: props.customStyledMap,
        useResizeObserver: props.useResizeObserver,
        parentMoveable: moveable,
        parentPosition: position
      });
    });
  }
};
var Clickable = makeAble("clickable", {
  props: {
    clickable: Boolean,
    preventClickDefault: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  always: true,
  dragRelation: "weak",
  dragStart: function (moveable, e) {
    if (!e.isRequest) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(window, "click", moveable.onPreventClick, true);
    }
  },
  dragControlStart: function (moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroupStart: function (moveable, e) {
    this.dragStart(moveable, e);
    e.datas.inputTarget = e.inputEvent && e.inputEvent.target;
  },
  dragEnd: function (moveable, e) {
    this.endEvent(moveable);
    var target = moveable.state.target;
    var inputEvent = e.inputEvent;
    var inputTarget = e.inputTarget;
    var isMoveableElement = moveable.isMoveableElement(inputTarget);
    var containsElement = !isMoveableElement && moveable.controlBox.getElement().contains(inputTarget);

    if (!moveable.props.preventClickDefault && !e.isDrag || containsElement) {
      this.unset(moveable);
    }

    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) || containsElement // External event duplicate target or dragAreaElement
    ) {
      return;
    }

    var containsTarget = target.contains(inputTarget);
    triggerEvent(moveable, "onClick", fillParams(moveable, e, {
      isDouble: e.isDouble,
      inputTarget: inputTarget,
      isTarget: target === inputTarget,
      containsTarget: containsTarget
    }));
  },
  dragGroupEnd: function (moveable, e) {
    this.endEvent(moveable);
    var inputEvent = e.inputEvent;
    var inputTarget = e.inputTarget;

    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) // External event duplicate target or dragAreaElement
    || e.datas.inputTarget === inputTarget) {
      return;
    }

    var targets = moveable.props.targets;
    var targetIndex = targets.indexOf(inputTarget);
    var isTarget = targetIndex > -1;
    var containsTarget = false;

    if (targetIndex === -1) {
      targetIndex = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(targets, function (parentTarget) {
        return parentTarget.contains(inputTarget);
      });
      containsTarget = targetIndex > -1;
    }

    triggerEvent(moveable, "onClickGroup", fillParams(moveable, e, {
      isDouble: e.isDouble,
      targets: targets,
      inputTarget: inputTarget,
      targetIndex: targetIndex,
      isTarget: isTarget,
      containsTarget: containsTarget
    }));
  },
  dragControlEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
  },
  endEvent: function (moveable) {
    var _this = this;

    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.requestAnimationFrame)(function () {
      _this.unset(moveable);
    });
  },
  unset: function (moveable) {
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(window, "click", moveable.onPreventClick, true);
  }
});
/**
 * When you click on the element, the `click` event is called.
 * @memberof Moveable
 * @event click
 * @param {Moveable.OnClick} - Parameters for the `click` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("click", ({ hasTarget, containsTarget, targetIndex }) => {
 *     // If you click on an element other than the target and not included in the target, index is -1.
 *     console.log("onClickGroup", target, hasTarget, containsTarget, targetIndex);
 * });
 */

/**
 * When you click on the element inside the group, the `clickGroup` event is called.
 * @memberof Moveable
 * @event clickGroup
 * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("clickGroup", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {
 *     // If you click on an element other than the target and not included in the target, index is -1.
 *     console.log("onClickGroup", inputTarget, isTarget, containsTarget, targetIndex);
 * });
 */

function getDraggableEvent(e) {
  var datas = e.originalDatas.draggable;

  if (!datas) {
    e.originalDatas.draggable = {};
    datas = e.originalDatas.draggable;
  }

  return __assign(__assign({}, e), {
    datas: datas
  });
}

var edgeDraggable = makeAble("edgeDraggable", {
  dragControlCondition: function (moveable, e) {
    if (!moveable.props.edgeDraggable || !e.inputEvent) {
      return false;
    }

    var target = e.inputEvent.target;
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(target, prefix("direction")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(target, prefix("line"));
  },
  dragControlStart: function (moveable, e) {
    return Draggable.dragStart(moveable, getDraggableEvent(e));
  },
  dragControl: function (moveable, e) {
    return Draggable.drag(moveable, getDraggableEvent(e));
  },
  dragControlEnd: function (moveable, e) {
    return Draggable.dragEnd(moveable, getDraggableEvent(e));
  },
  dragGroupControlCondition: function (moveable, e) {
    if (!moveable.props.edgeDraggable || !e.inputEvent) {
      return false;
    }

    var target = e.inputEvent.target;
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(target, prefix("direction")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(target, prefix("line"));
  },
  dragGroupControlStart: function (moveable, e) {
    return Draggable.dragGroupStart(moveable, getDraggableEvent(e));
  },
  dragGroupControl: function (moveable, e) {
    return Draggable.dragGroup(moveable, getDraggableEvent(e));
  },
  dragGroupControlEnd: function (moveable, e) {
    return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));
  },
  unset: function (moveable) {
    return Draggable.unset(moveable);
  }
});
/**
 * Whether to move by dragging the edge line (default: false)
 * @name Moveable.Draggable#edgeDraggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  draggable: true,
 *  edgeDraggable: false,
 * });
 *
 * moveable.edgeDraggable = true;
 */

var IndividualGroupable = {
  name: "individualGroupable",
  props: {
    individualGroupable: Boolean
  },
  events: {}
};
var MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable];
var MOVEABLE_EVENTS_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce(function (current, able) {
  return __assign(__assign({}, current), "events" in able ? able.events : {});
}, {});
var MOVEABLE_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce(function (current, able) {
  return __assign(__assign({}, current), able.props);
}, {});
var MOVEABLE_EVENTS_MAP = /*#__PURE__*/invertObject(MOVEABLE_EVENTS_PROPS_MAP);
var MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP);
var MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);

function getMaxPos(poses, index) {
  return Math.max.apply(Math, poses.map(function (_a) {
    var pos1 = _a[0],
        pos2 = _a[1],
        pos3 = _a[2],
        pos4 = _a[3];
    return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}

function getMinPos(poses, index) {
  return Math.min.apply(Math, poses.map(function (_a) {
    var pos1 = _a[0],
        pos2 = _a[1],
        pos3 = _a[2],
        pos4 = _a[3];
    return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}

function getGroupRect(moveables, rotation) {
  if (!moveables.length) {
    return [0, 0, 0, 0];
  }

  var moveablePoses = moveables.map(function (_a) {
    var state = _a.state;
    return getAbsolutePosesByState(state);
  });
  var minX = MAX_NUM;
  var minY = MAX_NUM;
  var groupWidth = 0;
  var groupHeight = 0;
  var fixedRotation = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(rotation, TINY_NUM);

  if (fixedRotation % 90) {
    var rad_1 = fixedRotation / 180 * Math.PI;
    var a1_1 = Math.tan(rad_1);
    var a2_1 = -1 / a1_1;
    var b1MinMax_1 = [MIN_NUM, MAX_NUM];
    var b2MinMax_1 = [MIN_NUM, MAX_NUM];
    moveablePoses.forEach(function (poses) {
      poses.forEach(function (pos) {
        // ax + b = y
        // b = y - ax
        var b1 = pos[1] - a1_1 * pos[0];
        var b2 = pos[1] - a2_1 * pos[0];
        b1MinMax_1[0] = Math.max(b1MinMax_1[0], b1);
        b1MinMax_1[1] = Math.min(b1MinMax_1[1], b1);
        b2MinMax_1[0] = Math.max(b2MinMax_1[0], b2);
        b2MinMax_1[1] = Math.min(b2MinMax_1[1], b2);
      });
    });
    b1MinMax_1.forEach(function (b1) {
      // a1x + b1 = a2x + b2
      b2MinMax_1.forEach(function (b2) {
        // (a1 - a2)x = b2 - b1
        var x = (b2 - b1) / (a1_1 - a2_1);
        var y = a1_1 * x + b1;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
      });
    });
    var rotatePoses = moveablePoses.map(function (_a) {
      var pos1 = _a[0],
          pos2 = _a[1],
          pos3 = _a[2],
          pos4 = _a[3];
      return [(0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos1, -rad_1), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos2, -rad_1), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos3, -rad_1), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos4, -rad_1)];
    });
    groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);
    groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);
  } else {
    minX = getMinPos(moveablePoses, 0);
    minY = getMinPos(moveablePoses, 1);
    groupWidth = getMaxPos(moveablePoses, 0) - minX;
    groupHeight = getMaxPos(moveablePoses, 1) - minY;

    if (fixedRotation % 180) {
      var changedWidth = groupWidth;
      groupWidth = groupHeight;
      groupHeight = changedWidth;
    }
  }

  return [minX, minY, groupWidth, groupHeight];
}
/**
 * @namespace Moveable.Group
 * @description You can make targets moveable.
 */


var MoveableGroup = /*#__PURE__*/function (_super) {
  __extends(MoveableGroup, _super);

  function MoveableGroup() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.differ = new _egjs_children_differ__WEBPACK_IMPORTED_MODULE_4__["default"]();
    _this.moveables = [];
    _this.transformOrigin = "50% 50%";
    return _this;
  }

  var __proto = MoveableGroup.prototype;

  __proto.checkUpdate = function () {
    this.updateAbles();
  };

  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    if (!this.controlBox) {
      return;
    }

    this.moveables.forEach(function (moveable) {
      moveable.updateRect(type, false, false);
    });
    var state = this.state;
    var props = this.props;
    var target = state.target || props.target;

    if (!isTarget || type !== "" && props.updateGroup) {
      // reset rotataion
      this.rotation = props.defaultGroupRotate;
      this.transformOrigin = props.defaultGroupOrigin || "50% 50%";
      this.scale = [1, 1];
    }

    var rotation = this.rotation;
    var scale = this.scale;

    var _a = getGroupRect(this.moveables, rotation),
        left = _a[0],
        top = _a[1],
        width = _a[2],
        height = _a[3]; // tslint:disable-next-line: max-line-length


    var transform = "rotate(".concat(rotation, "deg) scale(").concat(scale[0] >= 0 ? 1 : -1, ", ").concat(scale[1] >= 0 ? 1 : -1, ")");
    target.style.cssText += "left:0px;top:0px; transform-origin: ".concat(this.transformOrigin, "; width:").concat(width, "px; height:").concat(height, "px;") + "transform:".concat(transform);
    state.width = width;
    state.height = height;
    var container = this.getContainer();
    var info = getTargetInfo(this.controlBox.getElement(), target, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || container);
    var pos = [info.left, info.top];

    var _b = getAbsolutePosesByState(info),
        pos1 = _b[0],
        pos2 = _b[1],
        pos3 = _b[2],
        pos4 = _b[3]; // info.left + info.pos(1 ~ 4)


    var minPos = (0,overlap_area__WEBPACK_IMPORTED_MODULE_3__.getMinMaxs)([pos1, pos2, pos3, pos4]);
    var delta = [minPos.minX, minPos.minY];
    info.pos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos1, delta);
    info.pos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos2, delta);
    info.pos3 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos3, delta);
    info.pos4 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos4, delta);
    info.left = left - info.left + delta[0];
    info.top = top - info.top + delta[1];
    info.origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, info.origin), delta);
    info.beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, info.beforeOrigin), delta);
    info.originalBeforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, info.originalBeforeOrigin); // info.transformOrigin = minus(plus(pos, info.transformOrigin!), delta);

    var clientRect = info.targetClientRect;
    var direction = scale[0] * scale[1] > 0 ? 1 : -1;
    clientRect.top += info.top - state.top;
    clientRect.left += info.left - state.left;
    target.style.transform = "translate(".concat(-delta[0], "px, ").concat(-delta[1], "px) ").concat(transform);
    this.updateState(__assign(__assign({}, info), {
      direction: direction,
      beforeDirection: direction
    }), isSetState);
  };

  __proto.getRect = function () {
    return __assign(__assign({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function (child) {
        return child.getRect();
      })
    });
  };

  __proto.triggerEvent = function (name, e, isManager) {
    if (isManager || name.indexOf("Group") > -1) {
      return _super.prototype.triggerEvent.call(this, name, e);
    } else {
      this._emitter.trigger(name, e);
    }
  };

  __proto.updateAbles = function () {
    _super.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables, true), [Groupable], false), "Group");
  };

  __proto._updateTargets = function () {
    _super.prototype._updateTargets.call(this);

    this._prevTarget = this.props.dragTarget || this.areaElement;
  };

  __proto._updateEvents = function () {
    var state = this.state;
    var props = this.props;
    var prevTarget = this._prevTarget;
    var nextTarget = props.dragTarget || this.areaElement;

    if (prevTarget !== nextTarget) {
      unset(this, "targetGesto");
      unset(this, "controlGesto");
      state.target = null;
    }

    if (!state.target) {
      state.target = this.areaElement;
      this.controlBox.getElement().style.display = "block";
    }

    if (state.target) {
      if (!this.targetGesto) {
        this.targetGesto = getTargetAbleGesto(this, nextTarget, "Group");
      }

      if (!this.controlGesto) {
        this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), "controlAbles", "GroupControl");
      }
    }

    var isContainerChanged = !equals(state.container, props.container);

    if (isContainerChanged) {
      state.container = props.container;
    }

    var _a = this.differ.update(props.targets),
        added = _a.added,
        changed = _a.changed,
        removed = _a.removed;

    if (isContainerChanged || added.length || changed.length || removed.length) {
      this.updateRect();
    }
  };

  __proto._updateObserver = function () {};

  MoveableGroup.defaultProps = __assign(__assign({}, MoveableManager.defaultProps), {
    transformOrigin: ["50%", "50%"],
    groupable: true,
    dragArea: true,
    keepRatio: true,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  });
  return MoveableGroup;
}(MoveableManager);
/**
 * @namespace Moveable.IndividualGroup
 * @description Create targets individually, not as a group.Create targets individually, not as a group.
 */


var MoveableIndividualGroup = /*#__PURE__*/function (_super) {
  __extends(MoveableIndividualGroup, _super);

  function MoveableIndividualGroup() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.moveables = [];
    return _this;
  }

  var __proto = MoveableIndividualGroup.prototype;

  __proto.render = function () {
    var _this = this;

    var _a = this.props,
        cspNonce = _a.cspNonce,
        ControlBoxElement = _a.cssStyled,
        targets = _a.targets;
    return react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement(ControlBoxElement, {
      cspNonce: cspNonce,
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, "controlBox"),
      className: prefix("control-box")
    }, targets.map(function (target, i) {
      return react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement(MoveableManager, __assign({
        key: "moveable" + i,
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.refs)(_this, "moveables", i)
      }, _this.props, {
        target: target,
        wrapperMoveable: _this
      }));
    }));
  };

  __proto.componentDidUpdate = function () {};

  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    this.moveables.forEach(function (moveable) {
      moveable.updateRect(type, isTarget, isSetState);
    });
  };

  __proto.getRect = function () {
    return __assign(__assign({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function (child) {
        return child.getRect();
      })
    });
  };

  __proto.request = function () {
    return {
      request: function () {
        return this;
      },
      requestEnd: function () {
        return this;
      }
    };
  };

  __proto.dragStart = function () {
    return this;
  };

  __proto.hitTest = function () {
    return 0;
  };

  __proto.isInside = function () {
    return false;
  };

  __proto.isDragging = function () {
    return false;
  };

  __proto.updateRenderPoses = function () {};

  __proto.checkUpdate = function () {};

  __proto.triggerEvent = function () {};

  __proto.updateAbles = function () {};

  __proto._updateEvents = function () {};

  __proto._updateObserver = function () {};

  return MoveableIndividualGroup;
}(MoveableManager);

var InitialMoveable = /*#__PURE__*/function (_super) {
  __extends(InitialMoveable, _super);

  function InitialMoveable() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.refTargets = [];
    _this.selectorMap = {};
    return _this;
  }

  var __proto = InitialMoveable.prototype;

  InitialMoveable.makeStyled = function () {
    var cssMap = {};
    var ables = this.getTotalAbles();
    ables.forEach(function (_a) {
      var css = _a.css;

      if (!css) {
        return;
      }

      css.forEach(function (text) {
        cssMap[text] = true;
      });
    });
    var style = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getKeys)(cssMap).join("\n");
    this.defaultStyled = (0,react_compat_css_styled__WEBPACK_IMPORTED_MODULE_10__["default"])("div", (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.prefixCSS)(PREFIX, MOVEABLE_CSS + style));
  };

  InitialMoveable.getTotalAbles = function () {
    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles, true);
  };

  __proto.render = function () {
    var moveableContructor = this.constructor;

    if (!moveableContructor.defaultStyled) {
      moveableContructor.makeStyled();
    }

    var _a = this.props,
        userAbles = _a.ables,
        userProps = _a.props,
        props = __rest(_a, ["ables", "props"]);

    var refTargets = this._updateRefs(true);

    var elementTargets = getElementTargets(refTargets, this.selectorMap);
    var isGroup = elementTargets.length > 1;
    var totalAbles = moveableContructor.getTotalAbles();

    var ables = __spreadArray(__spreadArray([], totalAbles, true), userAbles || [], true);

    var nextProps = __assign(__assign(__assign({}, props), userProps || {}), {
      ables: ables,
      cssStyled: moveableContructor.defaultStyled,
      customStyledMap: moveableContructor.customStyledMap
    });

    if (isGroup) {
      if (props.individualGroupable) {
        return react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement(MoveableIndividualGroup, __assign({
          key: "individual-group",
          ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, "moveable")
        }, nextProps, {
          target: null,
          targets: elementTargets
        }));
      }

      return react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement(MoveableGroup, __assign({
        key: "group",
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, "moveable")
      }, nextProps, {
        target: null,
        targets: elementTargets
      }));
    } else {
      return react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement(MoveableManager, __assign({
        key: "single",
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, "moveable")
      }, nextProps, {
        target: elementTargets[0]
      }));
    }
  };

  __proto.componentDidMount = function () {
    this._updateRefs();
  };

  __proto.componentDidUpdate = function () {
    this._updateRefs();
  };

  __proto.componentWillUnmount = function () {
    this.selectorMap = {};
    this.refTargets = [];
  };

  __proto.getManager = function () {
    return this.moveable;
  };

  __proto._updateRefs = function (isRender) {
    var prevRefTargets = this.refTargets;
    var nextRefTargets = getRefTargets(this.props.target || this.props.targets);
    var isBrowser = typeof document !== "undefined";
    var isUpdate = prevRefTargets.length !== nextRefTargets.length || prevRefTargets.some(function (target, i) {
      var nextTarget = nextRefTargets[i];

      if (!target && !nextTarget) {
        return false;
      } else if (target !== nextTarget) {
        return true;
      }

      return false;
    });
    var selectorMap = this.selectorMap;
    var nextSelectorMap = {};
    this.refTargets.forEach(function (target) {
      if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(target)) {
        var selectorTarget = selectorMap[target];

        if (selectorTarget) {
          nextSelectorMap[target] = selectorMap[target];
        } else if (isBrowser) {
          isUpdate = true;
          nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));
        }
      }
    });
    this.refTargets = nextRefTargets;
    this.selectorMap = nextSelectorMap;

    if (!isRender && isUpdate) {
      this.forceUpdate();
    }

    return nextRefTargets;
  };

  InitialMoveable.defaultAbles = [];
  InitialMoveable.customStyledMap = {};
  InitialMoveable.defaultStyled = null;

  __decorate([(0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.withMethods)(MOVEABLE_METHODS)], InitialMoveable.prototype, "moveable", void 0);

  return InitialMoveable;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.PureComponent);

var Moveable$1 = /*#__PURE__*/function (_super) {
  __extends(Moveable, _super);

  function Moveable() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Moveable.defaultAbles = MOVEABLE_ABLES;
  return Moveable;
}(InitialMoveable);

function makeMoveable(ables) {
  var _a;

  return _a = /*#__PURE__*/function (_super) {
    __extends(Moveable, _super);

    function Moveable() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    return Moveable;
  }(InitialMoveable), _a.defaultAbles = ables, _a;
}

var Moveable = Moveable$1;




/***/ }),

/***/ "./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/Draggable.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "DraggableCore", ({
  enumerable: true,
  get: function get() {
    return _DraggableCore.default;
  }
}));
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./.yarn/cache/prop-types-npm-15.7.2-d7a04f2274-5eef82fdda.zip/node_modules/prop-types/index.js"));

var _reactDom = _interopRequireDefault(__webpack_require__("./.yarn/__virtual__/react-dom-virtual-93e2c4839c/0/cache/react-dom-npm-17.0.2-f551215af1-1c1eaa3bca.zip/node_modules/react-dom/index.js"));

var _clsx2 = _interopRequireDefault(__webpack_require__("./.yarn/cache/clsx-npm-1.1.1-362bec0598-ff05265032.zip/node_modules/clsx/dist/clsx.m.js"));

var _domFns = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/domFns.js");

var _positionFns = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/positionFns.js");

var _shims = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/shims.js");

var _DraggableCore = _interopRequireDefault(__webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/DraggableCore.js"));

var _log = _interopRequireDefault(__webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/log.js"));

var _excluded = ["axis", "bounds", "children", "defaultPosition", "defaultClassName", "defaultClassNameDragging", "defaultClassNameDragged", "position", "positionOffset", "scale"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
// Define <Draggable>
//
var Draggable = /*#__PURE__*/function (_React$Component) {
  _inherits(Draggable, _React$Component);

  var _super = _createSuper(Draggable);

  function Draggable(props
  /*: DraggableProps*/
  ) {
    var _this;

    _classCallCheck(this, Draggable);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "onDragStart", function (e, coreData) {
      (0, _log.default)('Draggable: onDragStart: %j', coreData); // Short-circuit if user's callback killed it.

      var shouldStart = _this.props.onStart(e, (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData)); // Kills start event on core as well, so move handlers are never bound.


      if (shouldStart === false) return false;

      _this.setState({
        dragging: true,
        dragged: true
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onDrag", function (e, coreData) {
      if (!_this.state.dragging) return false;
      (0, _log.default)('Draggable: onDrag: %j', coreData);
      var uiData = (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData);
      var newState
      /*: $Shape<DraggableState>*/
      = {
        x: uiData.x,
        y: uiData.y
      }; // Keep within bounds.

      if (_this.props.bounds) {
        // Save original x and y.
        var x = newState.x,
            y = newState.y; // Add slack to the values used to calculate bound position. This will ensure that if
        // we start removing slack, the element won't react to it right away until it's been
        // completely removed.

        newState.x += _this.state.slackX;
        newState.y += _this.state.slackY; // Get bound position. This will ceil/floor the x and y within the boundaries.

        var _getBoundPosition = (0, _positionFns.getBoundPosition)(_assertThisInitialized(_this), newState.x, newState.y),
            _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2),
            newStateX = _getBoundPosition2[0],
            newStateY = _getBoundPosition2[1];

        newState.x = newStateX;
        newState.y = newStateY; // Recalculate slack by noting how much was shaved by the boundPosition handler.

        newState.slackX = _this.state.slackX + (x - newState.x);
        newState.slackY = _this.state.slackY + (y - newState.y); // Update the event we fire to reflect what really happened after bounds took effect.

        uiData.x = newState.x;
        uiData.y = newState.y;
        uiData.deltaX = newState.x - _this.state.x;
        uiData.deltaY = newState.y - _this.state.y;
      } // Short-circuit if user's callback killed it.


      var shouldUpdate = _this.props.onDrag(e, uiData);

      if (shouldUpdate === false) return false;

      _this.setState(newState);
    });

    _defineProperty(_assertThisInitialized(_this), "onDragStop", function (e, coreData) {
      if (!_this.state.dragging) return false; // Short-circuit if user's callback killed it.

      var shouldContinue = _this.props.onStop(e, (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData));

      if (shouldContinue === false) return false;
      (0, _log.default)('Draggable: onDragStop: %j', coreData);
      var newState
      /*: $Shape<DraggableState>*/
      = {
        dragging: false,
        slackX: 0,
        slackY: 0
      }; // If this is a controlled component, the result of this operation will be to
      // revert back to the old position. We expect a handler on `onDragStop`, at the least.

      var controlled = Boolean(_this.props.position);

      if (controlled) {
        var _this$props$position = _this.props.position,
            x = _this$props$position.x,
            y = _this$props$position.y;
        newState.x = x;
        newState.y = y;
      }

      _this.setState(newState);
    });

    _this.state = {
      // Whether or not we are currently dragging.
      dragging: false,
      // Whether or not we have been dragged before.
      dragged: false,
      // Current transform x and y.
      x: props.position ? props.position.x : props.defaultPosition.x,
      y: props.position ? props.position.y : props.defaultPosition.y,
      prevPropsPosition: _objectSpread({}, props.position),
      // Used for compensating for out-of-bounds drags
      slackX: 0,
      slackY: 0,
      // Can only determine if SVG after mounting
      isElementSVG: false
    };

    if (props.position && !(props.onDrag || props.onStop)) {
      // eslint-disable-next-line no-console
      console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');
    }

    return _this;
  }

  _createClass(Draggable, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Check to see if the element passed is an instanceof SVGElement
      if (typeof window.SVGElement !== 'undefined' && this.findDOMNode() instanceof window.SVGElement) {
        this.setState({
          isElementSVG: true
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.setState({
        dragging: false
      }); // prevents invariant if unmounted while dragging
    } // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.

  }, {
    key: "findDOMNode",
    value: function findDOMNode()
    /*: ?HTMLElement*/
    {
      var _this$props$nodeRef$c, _this$props, _this$props$nodeRef;

      return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 ? void 0 : (_this$props$nodeRef = _this$props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);
    }
  }, {
    key: "render",
    value: function render()
    /*: ReactElement<any>*/
    {
      var _clsx;

      var _this$props2 = this.props,
          axis = _this$props2.axis,
          bounds = _this$props2.bounds,
          children = _this$props2.children,
          defaultPosition = _this$props2.defaultPosition,
          defaultClassName = _this$props2.defaultClassName,
          defaultClassNameDragging = _this$props2.defaultClassNameDragging,
          defaultClassNameDragged = _this$props2.defaultClassNameDragged,
          position = _this$props2.position,
          positionOffset = _this$props2.positionOffset,
          scale = _this$props2.scale,
          draggableCoreProps = _objectWithoutProperties(_this$props2, _excluded);

      var style = {};
      var svgTransform = null; // If this is controlled, we don't want to move it - unless it's dragging.

      var controlled = Boolean(position);
      var draggable = !controlled || this.state.dragging;
      var validPosition = position || defaultPosition;
      var transformOpts = {
        // Set left if horizontal drag is enabled
        x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,
        // Set top if vertical drag is enabled
        y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y
      }; // If this element was SVG, we use the `transform` attribute.

      if (this.state.isElementSVG) {
        svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);
      } else {
        // Add a CSS transform to move the element around. This allows us to move the element around
        // without worrying about whether or not it is relatively or absolutely positioned.
        // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
        // has a clean slate.
        style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);
      } // Mark with class while dragging


      var className = (0, _clsx2.default)(children.props.className || '', defaultClassName, (_clsx = {}, _defineProperty(_clsx, defaultClassNameDragging, this.state.dragging), _defineProperty(_clsx, defaultClassNameDragged, this.state.dragged), _clsx)); // Reuse the child provided
      // This makes it flexible to use whatever element is wanted (div, ul, etc)

      return /*#__PURE__*/React.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {
        onStart: this.onDragStart,
        onDrag: this.onDrag,
        onStop: this.onDragStop
      }), /*#__PURE__*/React.cloneElement(React.Children.only(children), {
        className: className,
        style: _objectSpread(_objectSpread({}, children.props.style), style),
        transform: svgTransform
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: // React 16.3+
    // Arity (props, state)
    function getDerivedStateFromProps(_ref, _ref2)
    /*: ?$Shape<DraggableState>*/
    {
      var position = _ref.position;
      var prevPropsPosition = _ref2.prevPropsPosition;

      // Set x/y if a new position is provided in props that is different than the previous.
      if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {
        (0, _log.default)('Draggable: getDerivedStateFromProps %j', {
          position: position,
          prevPropsPosition: prevPropsPosition
        });
        return {
          x: position.x,
          y: position.y,
          prevPropsPosition: _objectSpread({}, position)
        };
      }

      return null;
    }
  }]);

  return Draggable;
}(React.Component);

exports["default"] = Draggable;

_defineProperty(Draggable, "displayName", 'Draggable');

_defineProperty(Draggable, "propTypes", _objectSpread(_objectSpread({}, _DraggableCore.default.propTypes), {}, {
  /**
   * `axis` determines which axis the draggable can move.
   *
   *  Note that all callbacks will still return data as normal. This only
   *  controls flushing to the DOM.
   *
   * 'both' allows movement horizontally and vertically.
   * 'x' limits movement to horizontal axis.
   * 'y' limits movement to vertical axis.
   * 'none' limits all movement.
   *
   * Defaults to 'both'.
   */
  axis: _propTypes.default.oneOf(['both', 'x', 'y', 'none']),

  /**
   * `bounds` determines the range of movement available to the element.
   * Available values are:
   *
   * 'parent' restricts movement within the Draggable's parent node.
   *
   * Alternatively, pass an object with the following properties, all of which are optional:
   *
   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
   *
   * All values are in px.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable bounds={{right: 300, bottom: 300}}>
   *              <div>Content</div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  bounds: _propTypes.default.oneOfType([_propTypes.default.shape({
    left: _propTypes.default.number,
    right: _propTypes.default.number,
    top: _propTypes.default.number,
    bottom: _propTypes.default.number
  }), _propTypes.default.string, _propTypes.default.oneOf([false])]),
  defaultClassName: _propTypes.default.string,
  defaultClassNameDragging: _propTypes.default.string,
  defaultClassNameDragged: _propTypes.default.string,

  /**
   * `defaultPosition` specifies the x and y that the dragged item should start at
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */
  defaultPosition: _propTypes.default.shape({
    x: _propTypes.default.number,
    y: _propTypes.default.number
  }),
  positionOffset: _propTypes.default.shape({
    x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
    y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
  }),

  /**
   * `position`, if present, defines the current position of the element.
   *
   *  This is similar to how form elements in React work - if no `position` is supplied, the component
   *  is uncontrolled.
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable position={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */
  position: _propTypes.default.shape({
    x: _propTypes.default.number,
    y: _propTypes.default.number
  }),

  /**
   * These properties should be defined on the child, not here.
   */
  className: _shims.dontSetMe,
  style: _shims.dontSetMe,
  transform: _shims.dontSetMe
}));

_defineProperty(Draggable, "defaultProps", _objectSpread(_objectSpread({}, _DraggableCore.default.defaultProps), {}, {
  axis: 'both',
  bounds: false,
  defaultClassName: 'react-draggable',
  defaultClassNameDragging: 'react-draggable-dragging',
  defaultClassNameDragged: 'react-draggable-dragged',
  defaultPosition: {
    x: 0,
    y: 0
  },
  scale: 1
}));

/***/ }),

/***/ "./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/DraggableCore.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./.yarn/cache/prop-types-npm-15.7.2-d7a04f2274-5eef82fdda.zip/node_modules/prop-types/index.js"));

var _reactDom = _interopRequireDefault(__webpack_require__("./.yarn/__virtual__/react-dom-virtual-93e2c4839c/0/cache/react-dom-npm-17.0.2-f551215af1-1c1eaa3bca.zip/node_modules/react-dom/index.js"));

var _domFns = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/domFns.js");

var _positionFns = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/positionFns.js");

var _shims = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/shims.js");

var _log = _interopRequireDefault(__webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/log.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Simple abstraction for dragging events names.
var eventsFor = {
  touch: {
    start: 'touchstart',
    move: 'touchmove',
    stop: 'touchend'
  },
  mouse: {
    start: 'mousedown',
    move: 'mousemove',
    stop: 'mouseup'
  }
}; // Default to mouse events.

var dragEventFor = eventsFor.mouse;
/*:: type DraggableCoreState = {
  dragging: boolean,
  lastX: number,
  lastY: number,
  touchIdentifier: ?number
};*/

/*:: export type DraggableData = {
  node: HTMLElement,
  x: number, y: number,
  deltaX: number, deltaY: number,
  lastX: number, lastY: number,
};*/

/*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/

/*:: export type ControlPosition = {x: number, y: number};*/

/*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/

/*:: export type DraggableCoreDefaultProps = {
  allowAnyClick: boolean,
  disabled: boolean,
  enableUserSelectHack: boolean,
  onStart: DraggableEventHandler,
  onDrag: DraggableEventHandler,
  onStop: DraggableEventHandler,
  onMouseDown: (e: MouseEvent) => void,
  scale: number,
};*/

/*:: export type DraggableCoreProps = {
  ...DraggableCoreDefaultProps,
  cancel: string,
  children: ReactElement<any>,
  offsetParent: HTMLElement,
  grid: [number, number],
  handle: string,
  nodeRef?: ?React.ElementRef<any>,
};*/

//
// Define <DraggableCore>.
//
// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
// work well with libraries that require more control over the element.
//
var DraggableCore = /*#__PURE__*/function (_React$Component) {
  _inherits(DraggableCore, _React$Component);

  var _super = _createSuper(DraggableCore);

  function DraggableCore() {
    var _this;

    _classCallCheck(this, DraggableCore);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      dragging: false,
      // Used while dragging to determine deltas.
      lastX: NaN,
      lastY: NaN,
      touchIdentifier: null
    });

    _defineProperty(_assertThisInitialized(_this), "mounted", false);

    _defineProperty(_assertThisInitialized(_this), "handleDragStart", function (e) {
      // Make it possible to attach event handlers on top of this one.
      _this.props.onMouseDown(e); // Only accept left-clicks.


      if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false; // Get nodes. Be sure to grab relative document (could be iframed)

      var thisNode = _this.findDOMNode();

      if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
        throw new Error('<DraggableCore> not mounted on DragStart!');
      }

      var ownerDocument = thisNode.ownerDocument; // Short circuit if handle or cancel prop was provided and selector doesn't match.

      if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.handle, thisNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.cancel, thisNode)) {
        return;
      } // Prevent scrolling on mobile devices, like ipad/iphone.
      // Important that this is after handle/cancel.


      if (e.type === 'touchstart') e.preventDefault(); // Set touch identifier in component state if this is a touch event. This allows us to
      // distinguish between individual touches on multitouch screens by identifying which
      // touchpoint was set to this element.

      var touchIdentifier = (0, _domFns.getTouchIdentifier)(e);

      _this.setState({
        touchIdentifier: touchIdentifier
      }); // Get the current drag point from the event. This is used as the offset.


      var position = (0, _positionFns.getControlPosition)(e, touchIdentifier, _assertThisInitialized(_this));
      if (position == null) return; // not possible but satisfies flow

      var x = position.x,
          y = position.y; // Create an event object with all the data parents need to make a decision here.

      var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y);
      (0, _log.default)('DraggableCore: handleDragStart: %j', coreEvent); // Call event handler. If it returns explicit false, cancel.

      (0, _log.default)('calling', _this.props.onStart);

      var shouldUpdate = _this.props.onStart(e, coreEvent);

      if (shouldUpdate === false || _this.mounted === false) return; // Add a style to the body to disable user-select. This prevents text from
      // being selected all over the page.

      if (_this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument); // Initiate dragging. Set the current x and y as offsets
      // so we know how much we've moved during the drag. This allows us
      // to drag elements around even if they have been moved, without issue.

      _this.setState({
        dragging: true,
        lastX: x,
        lastY: y
      }); // Add events to the document directly so we catch when the user's mouse/touch moves outside of
      // this element. We use different events depending on whether or not we have detected that this
      // is a touch-capable device.


      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
    });

    _defineProperty(_assertThisInitialized(_this), "handleDrag", function (e) {
      // Get the current drag point from the event. This is used as the offset.
      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _assertThisInitialized(_this));
      if (position == null) return;
      var x = position.x,
          y = position.y; // Snap to grid if prop has been provided

      if (Array.isArray(_this.props.grid)) {
        var deltaX = x - _this.state.lastX,
            deltaY = y - _this.state.lastY;

        var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);

        var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);

        deltaX = _snapToGrid2[0];
        deltaY = _snapToGrid2[1];
        if (!deltaX && !deltaY) return; // skip useless drag

        x = _this.state.lastX + deltaX, y = _this.state.lastY + deltaY;
      }

      var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y);
      (0, _log.default)('DraggableCore: handleDrag: %j', coreEvent); // Call event handler. If it returns explicit false, trigger end.

      var shouldUpdate = _this.props.onDrag(e, coreEvent);

      if (shouldUpdate === false || _this.mounted === false) {
        try {
          // $FlowIgnore
          _this.handleDragStop(new MouseEvent('mouseup'));
        } catch (err) {
          // Old browsers
          var event = ((document.createEvent('MouseEvents')
          /*: any*/
          )
          /*: MouseTouchEvent*/
          ); // I see why this insanity was deprecated
          // $FlowIgnore

          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);

          _this.handleDragStop(event);
        }

        return;
      }

      _this.setState({
        lastX: x,
        lastY: y
      });
    });

    _defineProperty(_assertThisInitialized(_this), "handleDragStop", function (e) {
      if (!_this.state.dragging) return;
      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _assertThisInitialized(_this));
      if (position == null) return;
      var x = position.x,
          y = position.y;
      var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y); // Call event handler

      var shouldContinue = _this.props.onStop(e, coreEvent);

      if (shouldContinue === false || _this.mounted === false) return false;

      var thisNode = _this.findDOMNode();

      if (thisNode) {
        // Remove user-select hack
        if (_this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
      }

      (0, _log.default)('DraggableCore: handleDragStop: %j', coreEvent); // Reset the el.

      _this.setState({
        dragging: false,
        lastX: NaN,
        lastY: NaN
      });

      if (thisNode) {
        // Remove event handlers
        (0, _log.default)('DraggableCore: Removing handlers');
        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, _this.handleDrag);
        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseDown", function (e) {
      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse

      return _this.handleDragStart(e);
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseUp", function (e) {
      dragEventFor = eventsFor.mouse;
      return _this.handleDragStop(e);
    });

    _defineProperty(_assertThisInitialized(_this), "onTouchStart", function (e) {
      // We're on a touch device now, so change the event handlers
      dragEventFor = eventsFor.touch;
      return _this.handleDragStart(e);
    });

    _defineProperty(_assertThisInitialized(_this), "onTouchEnd", function (e) {
      // We're on a touch device now, so change the event handlers
      dragEventFor = eventsFor.touch;
      return _this.handleDragStop(e);
    });

    return _this;
  }

  _createClass(DraggableCore, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.mounted = true; // Touch handlers must be added with {passive: false} to be cancelable.
      // https://developers.google.com/web/updates/2017/01/scrolling-intervention

      var thisNode = this.findDOMNode();

      if (thisNode) {
        (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.mounted = false; // Remove any leftover event handlers. Remove both touch and mouse handlers in case
      // some browser quirk caused a touch event to fire during a mouse move, or vice versa.

      var thisNode = this.findDOMNode();

      if (thisNode) {
        var ownerDocument = thisNode.ownerDocument;
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
        if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);
      }
    } // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.

  }, {
    key: "findDOMNode",
    value: function findDOMNode()
    /*: ?HTMLElement*/
    {
      var _this$props$nodeRef$c, _this$props, _this$props$nodeRef;

      return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 ? void 0 : (_this$props$nodeRef = _this$props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);
    }
  }, {
    key: "render",
    value: function render()
    /*: React.Element<any>*/
    {
      // Reuse the child provided
      // This makes it flexible to use whatever element is wanted (div, ul, etc)
      return /*#__PURE__*/React.cloneElement(React.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  }]);

  return DraggableCore;
}(React.Component);

exports["default"] = DraggableCore;

_defineProperty(DraggableCore, "displayName", 'DraggableCore');

_defineProperty(DraggableCore, "propTypes", {
  /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */
  allowAnyClick: _propTypes.default.bool,

  /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */
  disabled: _propTypes.default.bool,

  /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */
  enableUserSelectHack: _propTypes.default.bool,

  /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */
  offsetParent: function offsetParent(props
  /*: DraggableCoreProps*/
  , propName
  /*: $Keys<DraggableCoreProps>*/
  ) {
    if (props[propName] && props[propName].nodeType !== 1) {
      throw new Error('Draggable\'s offsetParent must be a DOM Node.');
    }
  },

  /**
   * `grid` specifies the x and y that dragging should snap to.
   */
  grid: _propTypes.default.arrayOf(_propTypes.default.number),

  /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  handle: _propTypes.default.string,

  /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */
  cancel: _propTypes.default.string,

  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */
  nodeRef: _propTypes.default.object,

  /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onStart: _propTypes.default.func,

  /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onDrag: _propTypes.default.func,

  /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */
  onStop: _propTypes.default.func,

  /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */
  onMouseDown: _propTypes.default.func,

  /**
   * `scale`, if set, applies scaling while dragging an element
   */
  scale: _propTypes.default.number,

  /**
   * These properties should be defined on the child, not here.
   */
  className: _shims.dontSetMe,
  style: _shims.dontSetMe,
  transform: _shims.dontSetMe
});

_defineProperty(DraggableCore, "defaultProps", {
  allowAnyClick: false,
  // by default only accept left click
  disabled: false,
  enableUserSelectHack: true,
  onStart: function onStart() {},
  onDrag: function onDrag() {},
  onStop: function onStop() {},
  onMouseDown: function onMouseDown() {},
  scale: 1
});

/***/ }),

/***/ "./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/cjs.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var _require = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/Draggable.js"),
    Draggable = _require.default,
    DraggableCore = _require.DraggableCore; // Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.
// See https://github.com/mzabriskie/react-draggable/pull/254
// and https://github.com/mzabriskie/react-draggable/issues/266


module.exports = Draggable;
module.exports["default"] = Draggable;
module.exports.DraggableCore = DraggableCore;

/***/ }),

/***/ "./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/domFns.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.matchesSelector = matchesSelector;
exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
exports.addEvent = addEvent;
exports.removeEvent = removeEvent;
exports.outerHeight = outerHeight;
exports.outerWidth = outerWidth;
exports.innerHeight = innerHeight;
exports.innerWidth = innerWidth;
exports.offsetXYFromParent = offsetXYFromParent;
exports.createCSSTransform = createCSSTransform;
exports.createSVGTransform = createSVGTransform;
exports.getTranslation = getTranslation;
exports.getTouch = getTouch;
exports.getTouchIdentifier = getTouchIdentifier;
exports.addUserSelectStyles = addUserSelectStyles;
exports.removeUserSelectStyles = removeUserSelectStyles;
exports.addClassName = addClassName;
exports.removeClassName = removeClassName;

var _shims = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/shims.js");

var _getPrefix = _interopRequireWildcard(__webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/getPrefix.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var matchesSelectorFunc = '';

function matchesSelector(el
/*: Node*/
, selector
/*: string*/
)
/*: boolean*/
{
  if (!matchesSelectorFunc) {
    matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
      // $FlowIgnore: Doesn't think elements are indexable
      return (0, _shims.isFunction)(el[method]);
    });
  } // Might not be found entirely (not an Element?) - in that case, bail
  // $FlowIgnore: Doesn't think elements are indexable


  if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false; // $FlowIgnore: Doesn't think elements are indexable

  return el[matchesSelectorFunc](selector);
} // Works up the tree to the draggable itself attempting to match selector.


function matchesSelectorAndParentsTo(el
/*: Node*/
, selector
/*: string*/
, baseNode
/*: Node*/
)
/*: boolean*/
{
  var node = el;

  do {
    if (matchesSelector(node, selector)) return true;
    if (node === baseNode) return false;
    node = node.parentNode;
  } while (node);

  return false;
}

function addEvent(el
/*: ?Node*/
, event
/*: string*/
, handler
/*: Function*/
, inputOptions
/*: Object*/
)
/*: void*/
{
  if (!el) return;

  var options = _objectSpread({
    capture: true
  }, inputOptions); // $FlowIgnore[method-unbinding]


  if (el.addEventListener) {
    el.addEventListener(event, handler, options);
  } else if (el.attachEvent) {
    el.attachEvent('on' + event, handler);
  } else {
    // $FlowIgnore: Doesn't think elements are indexable
    el['on' + event] = handler;
  }
}

function removeEvent(el
/*: ?Node*/
, event
/*: string*/
, handler
/*: Function*/
, inputOptions
/*: Object*/
)
/*: void*/
{
  if (!el) return;

  var options = _objectSpread({
    capture: true
  }, inputOptions); // $FlowIgnore[method-unbinding]


  if (el.removeEventListener) {
    el.removeEventListener(event, handler, options);
  } else if (el.detachEvent) {
    el.detachEvent('on' + event, handler);
  } else {
    // $FlowIgnore: Doesn't think elements are indexable
    el['on' + event] = null;
  }
}

function outerHeight(node
/*: HTMLElement*/
)
/*: number*/
{
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetTop which is including margin. See getBoundPosition
  var height = node.clientHeight;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  height += (0, _shims.int)(computedStyle.borderTopWidth);
  height += (0, _shims.int)(computedStyle.borderBottomWidth);
  return height;
}

function outerWidth(node
/*: HTMLElement*/
)
/*: number*/
{
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetLeft which is including margin. See getBoundPosition
  var width = node.clientWidth;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  width += (0, _shims.int)(computedStyle.borderLeftWidth);
  width += (0, _shims.int)(computedStyle.borderRightWidth);
  return width;
}

function innerHeight(node
/*: HTMLElement*/
)
/*: number*/
{
  var height = node.clientHeight;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  height -= (0, _shims.int)(computedStyle.paddingTop);
  height -= (0, _shims.int)(computedStyle.paddingBottom);
  return height;
}

function innerWidth(node
/*: HTMLElement*/
)
/*: number*/
{
  var width = node.clientWidth;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  width -= (0, _shims.int)(computedStyle.paddingLeft);
  width -= (0, _shims.int)(computedStyle.paddingRight);
  return width;
}
/*:: interface EventWithOffset {
  clientX: number, clientY: number
}*/


// Get from offsetParent
function offsetXYFromParent(evt
/*: EventWithOffset*/
, offsetParent
/*: HTMLElement*/
, scale
/*: number*/
)
/*: ControlPosition*/
{
  var isBody = offsetParent === offsetParent.ownerDocument.body;
  var offsetParentRect = isBody ? {
    left: 0,
    top: 0
  } : offsetParent.getBoundingClientRect();
  var x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
  var y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
  return {
    x: x,
    y: y
  };
}

function createCSSTransform(controlPos
/*: ControlPosition*/
, positionOffset
/*: PositionOffsetControlPosition*/
)
/*: Object*/
{
  var translation = getTranslation(controlPos, positionOffset, 'px');
  return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)('transform', _getPrefix.default), translation);
}

function createSVGTransform(controlPos
/*: ControlPosition*/
, positionOffset
/*: PositionOffsetControlPosition*/
)
/*: string*/
{
  var translation = getTranslation(controlPos, positionOffset, '');
  return translation;
}

function getTranslation(_ref2, positionOffset
/*: PositionOffsetControlPosition*/
, unitSuffix
/*: string*/
)
/*: string*/
{
  var x = _ref2.x,
      y = _ref2.y;
  var translation = "translate(".concat(x).concat(unitSuffix, ",").concat(y).concat(unitSuffix, ")");

  if (positionOffset) {
    var defaultX = "".concat(typeof positionOffset.x === 'string' ? positionOffset.x : positionOffset.x + unitSuffix);
    var defaultY = "".concat(typeof positionOffset.y === 'string' ? positionOffset.y : positionOffset.y + unitSuffix);
    translation = "translate(".concat(defaultX, ", ").concat(defaultY, ")") + translation;
  }

  return translation;
}

function getTouch(e
/*: MouseTouchEvent*/
, identifier
/*: number*/
)
/*: ?{clientX: number, clientY: number}*/
{
  return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, function (t) {
    return identifier === t.identifier;
  }) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, function (t) {
    return identifier === t.identifier;
  });
}

function getTouchIdentifier(e
/*: MouseTouchEvent*/
)
/*: ?number*/
{
  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
} // User-select Hacks:
//
// Useful for preventing blue highlights all over everything when dragging.
// Note we're passing `document` b/c we could be iframed


function addUserSelectStyles(doc
/*: ?Document*/
) {
  if (!doc) return;
  var styleEl = doc.getElementById('react-draggable-style-el');

  if (!styleEl) {
    styleEl = doc.createElement('style');
    styleEl.type = 'text/css';
    styleEl.id = 'react-draggable-style-el';
    styleEl.innerHTML = '.react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n';
    styleEl.innerHTML += '.react-draggable-transparent-selection *::selection {all: inherit;}\n';
    doc.getElementsByTagName('head')[0].appendChild(styleEl);
  }

  if (doc.body) addClassName(doc.body, 'react-draggable-transparent-selection');
}

function removeUserSelectStyles(doc
/*: ?Document*/
) {
  if (!doc) return;

  try {
    if (doc.body) removeClassName(doc.body, 'react-draggable-transparent-selection'); // $FlowIgnore: IE

    if (doc.selection) {
      // $FlowIgnore: IE
      doc.selection.empty();
    } else {
      // Remove selection caused by scroll, unless it's a focused input
      // (we use doc.defaultView in case we're in an iframe)
      var selection = (doc.defaultView || window).getSelection();

      if (selection && selection.type !== 'Caret') {
        selection.removeAllRanges();
      }
    }
  } catch (e) {// probably IE
  }
}

function addClassName(el
/*: HTMLElement*/
, className
/*: string*/
) {
  if (el.classList) {
    el.classList.add(className);
  } else {
    if (!el.className.match(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)")))) {
      el.className += " ".concat(className);
    }
  }
}

function removeClassName(el
/*: HTMLElement*/
, className
/*: string*/
) {
  if (el.classList) {
    el.classList.remove(className);
  } else {
    el.className = el.className.replace(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)"), 'g'), '');
  }
}

/***/ }),

/***/ "./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/getPrefix.js":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getPrefix = getPrefix;
exports.browserPrefixToKey = browserPrefixToKey;
exports.browserPrefixToStyle = browserPrefixToStyle;
exports["default"] = void 0;
var prefixes = ['Moz', 'Webkit', 'O', 'ms'];

function getPrefix()
/*: string*/
{
  var _window$document, _window$document$docu;

  var prop
  /*: string*/
  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';
  // Ensure we're running in an environment where there is actually a global
  // `window` obj
  if (typeof window === 'undefined') return ''; // If we're in a pseudo-browser server-side environment, this access
  // path may not exist, so bail out if it doesn't.

  var style = (_window$document = window.document) === null || _window$document === void 0 ? void 0 : (_window$document$docu = _window$document.documentElement) === null || _window$document$docu === void 0 ? void 0 : _window$document$docu.style;
  if (!style) return '';
  if (prop in style) return '';

  for (var i = 0; i < prefixes.length; i++) {
    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
  }

  return '';
}

function browserPrefixToKey(prop
/*: string*/
, prefix
/*: string*/
)
/*: string*/
{
  return prefix ? "".concat(prefix).concat(kebabToTitleCase(prop)) : prop;
}

function browserPrefixToStyle(prop
/*: string*/
, prefix
/*: string*/
)
/*: string*/
{
  return prefix ? "-".concat(prefix.toLowerCase(), "-").concat(prop) : prop;
}

function kebabToTitleCase(str
/*: string*/
)
/*: string*/
{
  var out = '';
  var shouldCapitalize = true;

  for (var i = 0; i < str.length; i++) {
    if (shouldCapitalize) {
      out += str[i].toUpperCase();
      shouldCapitalize = false;
    } else if (str[i] === '-') {
      shouldCapitalize = true;
    } else {
      out += str[i];
    }
  }

  return out;
} // Default export is the prefix itself, like 'Moz', 'Webkit', etc
// Note that you may have to re-test for certain things; for instance, Chrome 50
// can handle unprefixed `transform`, but not unprefixed `user-select`


var _default = (getPrefix()
/*: string*/
);

exports["default"] = _default;

/***/ }),

/***/ "./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/log.js":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = log;

/*eslint no-console:0*/
function log() {
  var _console;

  if (false) {}
}

/***/ }),

/***/ "./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/positionFns.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getBoundPosition = getBoundPosition;
exports.snapToGrid = snapToGrid;
exports.canDragX = canDragX;
exports.canDragY = canDragY;
exports.getControlPosition = getControlPosition;
exports.createCoreData = createCoreData;
exports.createDraggableData = createDraggableData;

var _shims = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/shims.js");

var _domFns = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/domFns.js");

function getBoundPosition(draggable
/*: Draggable*/
, x
/*: number*/
, y
/*: number*/
)
/*: [number, number]*/
{
  // If no bounds, short-circuit and move on
  if (!draggable.props.bounds) return [x, y]; // Clone new bounds

  var bounds = draggable.props.bounds;
  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
  var node = findDOMNode(draggable);

  if (typeof bounds === 'string') {
    var ownerDocument = node.ownerDocument;
    var ownerWindow = ownerDocument.defaultView;
    var boundNode;

    if (bounds === 'parent') {
      boundNode = node.parentNode;
    } else {
      boundNode = ownerDocument.querySelector(bounds);
    }

    if (!(boundNode instanceof ownerWindow.HTMLElement)) {
      throw new Error('Bounds selector "' + bounds + '" could not find an element.');
    }

    var boundNodeEl
    /*: HTMLElement*/
    = boundNode; // for Flow, can't seem to refine correctly

    var nodeStyle = ownerWindow.getComputedStyle(node);
    var boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl); // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.

    bounds = {
      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
      right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
      bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
    };
  } // Keep x and y below right and bottom limits...


  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom); // But above left and top limits.

  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
  return [x, y];
}

function snapToGrid(grid
/*: [number, number]*/
, pendingX
/*: number*/
, pendingY
/*: number*/
)
/*: [number, number]*/
{
  var x = Math.round(pendingX / grid[0]) * grid[0];
  var y = Math.round(pendingY / grid[1]) * grid[1];
  return [x, y];
}

function canDragX(draggable
/*: Draggable*/
)
/*: boolean*/
{
  return draggable.props.axis === 'both' || draggable.props.axis === 'x';
}

function canDragY(draggable
/*: Draggable*/
)
/*: boolean*/
{
  return draggable.props.axis === 'both' || draggable.props.axis === 'y';
} // Get {x, y} positions from event.


function getControlPosition(e
/*: MouseTouchEvent*/
, touchIdentifier
/*: ?number*/
, draggableCore
/*: DraggableCore*/
)
/*: ?ControlPosition*/
{
  var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch

  var node = findDOMNode(draggableCore); // User can provide an offsetParent if desired.

  var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);
} // Create an data object exposed by <DraggableCore>'s events


function createCoreData(draggable
/*: DraggableCore*/
, x
/*: number*/
, y
/*: number*/
)
/*: DraggableData*/
{
  var state = draggable.state;
  var isStart = !(0, _shims.isNum)(state.lastX);
  var node = findDOMNode(draggable);

  if (isStart) {
    // If this is our first move, use the x and y as last coords.
    return {
      node: node,
      deltaX: 0,
      deltaY: 0,
      lastX: x,
      lastY: y,
      x: x,
      y: y
    };
  } else {
    // Otherwise calculate proper values.
    return {
      node: node,
      deltaX: x - state.lastX,
      deltaY: y - state.lastY,
      lastX: state.lastX,
      lastY: state.lastY,
      x: x,
      y: y
    };
  }
} // Create an data exposed by <Draggable>'s events


function createDraggableData(draggable
/*: Draggable*/
, coreData
/*: DraggableData*/
)
/*: DraggableData*/
{
  var scale = draggable.props.scale;
  return {
    node: coreData.node,
    x: draggable.state.x + coreData.deltaX / scale,
    y: draggable.state.y + coreData.deltaY / scale,
    deltaX: coreData.deltaX / scale,
    deltaY: coreData.deltaY / scale,
    lastX: draggable.state.x,
    lastY: draggable.state.y
  };
} // A lot faster than stringify/parse


function cloneBounds(bounds
/*: Bounds*/
)
/*: Bounds*/
{
  return {
    left: bounds.left,
    top: bounds.top,
    right: bounds.right,
    bottom: bounds.bottom
  };
}

function findDOMNode(draggable
/*: Draggable | DraggableCore*/
)
/*: HTMLElement*/
{
  var node = draggable.findDOMNode();

  if (!node) {
    throw new Error('<DraggableCore>: Unmounted during event!');
  } // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME


  return node;
}

/***/ }),

/***/ "./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/utils/shims.js":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.findInArray = findInArray;
exports.isFunction = isFunction;
exports.isNum = isNum;
exports.int = int;
exports.dontSetMe = dontSetMe;

// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
function findInArray(array
/*: Array<any> | TouchList*/
, callback
/*: Function*/
)
/*: any*/
{
  for (var i = 0, length = array.length; i < length; i++) {
    if (callback.apply(callback, [array[i], i, array])) return array[i];
  }
}

function isFunction(func
/*: any*/
)
/*: boolean %checks*/
{
  // $FlowIgnore[method-unbinding]
  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
}

function isNum(num
/*: any*/
)
/*: boolean %checks*/
{
  return typeof num === 'number' && !isNaN(num);
}

function int(a
/*: string*/
)
/*: number*/
{
  return parseInt(a, 10);
}

function dontSetMe(props
/*: Object*/
, propName
/*: string*/
, componentName
/*: string*/
)
/*: ?Error*/
{
  if (props[propName]) {
    return new Error("Invalid prop ".concat(propName, " passed to ").concat(componentName, " - do not set this, set it on the child."));
  }
}

/***/ }),

/***/ "./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/Resizable.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

var _reactDraggable = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/cjs.js");

var _utils = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/utils.js");

var _propTypes = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/propTypes.js");

var _excluded = ["children", "className", "draggableOpts", "width", "height", "handle", "handleSize", "lockAspectRatio", "axis", "minConstraints", "maxConstraints", "onResize", "onResizeStop", "onResizeStart", "resizeHandles", "transformScale"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// The base <Resizable> component.
// This component does not have state and relies on the parent to set its props based on callback data.
var Resizable = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Resizable, _React$Component);

  function Resizable() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handleRefs = {};
    _this.lastHandleRect = null;
    _this.slack = null;
    return _this;
  }

  var _proto = Resizable.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.resetData();
  };

  _proto.resetData = function resetData() {
    this.lastHandleRect = this.slack = null;
  } // Clamp width and height within provided constraints
  ;

  _proto.runConstraints = function runConstraints(width, height) {
    var _this$props = this.props,
        minConstraints = _this$props.minConstraints,
        maxConstraints = _this$props.maxConstraints,
        lockAspectRatio = _this$props.lockAspectRatio; // short circuit

    if (!minConstraints && !maxConstraints && !lockAspectRatio) return [width, height]; // If constraining to min and max, we need to also fit width and height to aspect ratio.

    if (lockAspectRatio) {
      var ratio = this.props.width / this.props.height;
      var deltaW = width - this.props.width;
      var deltaH = height - this.props.height; // Find which coordinate was greater and should push the other toward it.
      // E.g.:
      // ratio = 1, deltaW = 10, deltaH = 5, deltaH should become 10.
      // ratio = 2, deltaW = 10, deltaH = 6, deltaW should become 12.

      if (Math.abs(deltaW) > Math.abs(deltaH * ratio)) {
        height = width / ratio;
      } else {
        width = height * ratio;
      }
    }

    var oldW = width,
        oldH = height; // Add slack to the values used to calculate bound position. This will ensure that if
    // we start removing slack, the element won't react to it right away until it's been
    // completely removed.

    var _ref = this.slack || [0, 0],
        slackW = _ref[0],
        slackH = _ref[1];

    width += slackW;
    height += slackH;

    if (minConstraints) {
      width = Math.max(minConstraints[0], width);
      height = Math.max(minConstraints[1], height);
    }

    if (maxConstraints) {
      width = Math.min(maxConstraints[0], width);
      height = Math.min(maxConstraints[1], height);
    } // If the width or height changed, we must have introduced some slack. Record it for the next iteration.


    this.slack = [slackW + (oldW - width), slackH + (oldH - height)];
    return [width, height];
  }
  /**
   * Wrapper around drag events to provide more useful data.
   *
   * @param  {String} handlerName Handler name to wrap.
   * @return {Function}           Handler function.
   */
  ;

  _proto.resizeHandler = function resizeHandler(handlerName, axis) {
    var _this2 = this;

    return function (e, _ref2) {
      var node = _ref2.node,
          deltaX = _ref2.deltaX,
          deltaY = _ref2.deltaY;
      // Reset data in case it was left over somehow (should not be possible)
      if (handlerName === 'onResizeStart') _this2.resetData(); // Axis restrictions

      var canDragX = (_this2.props.axis === 'both' || _this2.props.axis === 'x') && axis !== 'n' && axis !== 's';
      var canDragY = (_this2.props.axis === 'both' || _this2.props.axis === 'y') && axis !== 'e' && axis !== 'w'; // No dragging possible.

      if (!canDragX && !canDragY) return; // Decompose axis for later use

      var axisV = axis[0];
      var axisH = axis[axis.length - 1]; // intentionally not axis[1], so that this catches axis === 'w' for example
      // Track the element being dragged to account for changes in position.
      // If a handle's position is changed between callbacks, we need to factor this in to the next callback.
      // Failure to do so will cause the element to "skip" when resized upwards or leftwards.

      var handleRect = node.getBoundingClientRect();

      if (_this2.lastHandleRect != null) {
        // If the handle has repositioned on either axis since last render,
        // we need to increase our callback values by this much.
        // Only checking 'n', 'w' since resizing by 's', 'w' won't affect the overall position on page,
        if (axisH === 'w') {
          var deltaLeftSinceLast = handleRect.left - _this2.lastHandleRect.left;
          deltaX += deltaLeftSinceLast;
        }

        if (axisV === 'n') {
          var deltaTopSinceLast = handleRect.top - _this2.lastHandleRect.top;
          deltaY += deltaTopSinceLast;
        }
      } // Storage of last rect so we know how much it has really moved.


      _this2.lastHandleRect = handleRect; // Reverse delta if using top or left drag handles.

      if (axisH === 'w') deltaX = -deltaX;
      if (axisV === 'n') deltaY = -deltaY; // Update w/h by the deltas. Also factor in transformScale.

      var width = _this2.props.width + (canDragX ? deltaX / _this2.props.transformScale : 0);
      var height = _this2.props.height + (canDragY ? deltaY / _this2.props.transformScale : 0); // Run user-provided constraints.

      var _this2$runConstraints = _this2.runConstraints(width, height);

      width = _this2$runConstraints[0];
      height = _this2$runConstraints[1];
      var dimensionsChanged = width !== _this2.props.width || height !== _this2.props.height; // Call user-supplied callback if present.

      var cb = typeof _this2.props[handlerName] === 'function' ? _this2.props[handlerName] : null; // Don't call 'onResize' if dimensions haven't changed.

      var shouldSkipCb = handlerName === 'onResize' && !dimensionsChanged;

      if (cb && !shouldSkipCb) {
        e.persist == null ? void 0 : e.persist();
        cb(e, {
          node: node,
          size: {
            width: width,
            height: height
          },
          handle: axis
        });
      } // Reset internal data


      if (handlerName === 'onResizeStop') _this2.resetData();
    };
  } // Render a resize handle given an axis & DOM ref. Ref *must* be attached for
  // the underlying draggable library to work properly.
  ;

  _proto.renderResizeHandle = function renderResizeHandle(handleAxis, ref) {
    var handle = this.props.handle; // No handle provided, make the default

    if (!handle) {
      return /*#__PURE__*/React.createElement("span", {
        className: "react-resizable-handle react-resizable-handle-" + handleAxis,
        ref: ref
      });
    } // Handle is a function, such as:
    // `handle={(handleAxis) => <span className={...} />}`


    if (typeof handle === 'function') {
      return handle(handleAxis, ref);
    } // Handle is a React component (composite or DOM).


    var isDOMElement = typeof handle.type === 'string';

    var props = _objectSpread({
      ref: ref
    }, isDOMElement ? {} : {
      handleAxis: handleAxis
    });

    return /*#__PURE__*/React.cloneElement(handle, props);
  };

  _proto.render = function render() {
    var _this3 = this;

    // Pass along only props not meant for the `<Resizable>`.`
    // eslint-disable-next-line no-unused-vars
    var _this$props2 = this.props,
        children = _this$props2.children,
        className = _this$props2.className,
        draggableOpts = _this$props2.draggableOpts,
        width = _this$props2.width,
        height = _this$props2.height,
        handle = _this$props2.handle,
        handleSize = _this$props2.handleSize,
        lockAspectRatio = _this$props2.lockAspectRatio,
        axis = _this$props2.axis,
        minConstraints = _this$props2.minConstraints,
        maxConstraints = _this$props2.maxConstraints,
        onResize = _this$props2.onResize,
        onResizeStop = _this$props2.onResizeStop,
        onResizeStart = _this$props2.onResizeStart,
        resizeHandles = _this$props2.resizeHandles,
        transformScale = _this$props2.transformScale,
        p = _objectWithoutPropertiesLoose(_this$props2, _excluded); // What we're doing here is getting the child of this element, and cloning it with this element's props.
    // We are then defining its children as:
    // 1. Its original children (resizable's child's children), and
    // 2. One or more draggable handles.


    return (0, _utils.cloneElement)(children, _objectSpread(_objectSpread({}, p), {}, {
      className: (className ? className + " " : '') + "react-resizable",
      children: [].concat(children.props.children, resizeHandles.map(function (handleAxis) {
        var _this3$handleRefs$han;

        // Create a ref to the handle so that `<DraggableCore>` doesn't have to use ReactDOM.findDOMNode().
        var ref = (_this3$handleRefs$han = _this3.handleRefs[handleAxis]) != null ? _this3$handleRefs$han : _this3.handleRefs[handleAxis] = /*#__PURE__*/React.createRef();
        return /*#__PURE__*/React.createElement(_reactDraggable.DraggableCore, _extends({}, draggableOpts, {
          nodeRef: ref,
          key: "resizableHandle-" + handleAxis,
          onStop: _this3.resizeHandler('onResizeStop', handleAxis),
          onStart: _this3.resizeHandler('onResizeStart', handleAxis),
          onDrag: _this3.resizeHandler('onResize', handleAxis)
        }), _this3.renderResizeHandle(handleAxis, ref));
      }))
    }));
  };

  return Resizable;
}(React.Component);

exports["default"] = Resizable;
Resizable.propTypes = _propTypes.resizableProps;
Resizable.defaultProps = {
  axis: 'both',
  handleSize: [20, 20],
  lockAspectRatio: false,
  minConstraints: [20, 20],
  maxConstraints: [Infinity, Infinity],
  resizeHandles: ['se'],
  transformScale: 1
};

/***/ }),

/***/ "./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/ResizableBox.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./.yarn/cache/prop-types-npm-15.7.2-d7a04f2274-5eef82fdda.zip/node_modules/prop-types/index.js"));

var _Resizable = _interopRequireDefault(__webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/Resizable.js"));

var _propTypes2 = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/propTypes.js");

var _excluded = ["handle", "handleSize", "onResize", "onResizeStart", "onResizeStop", "draggableOpts", "minConstraints", "maxConstraints", "lockAspectRatio", "axis", "width", "height", "resizeHandles", "style", "transformScale"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ResizableBox = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ResizableBox, _React$Component);

  function ResizableBox() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      width: _this.props.width,
      height: _this.props.height,
      propsWidth: _this.props.width,
      propsHeight: _this.props.height
    };

    _this.onResize = function (e, data) {
      var size = data.size;

      if (_this.props.onResize) {
        e.persist == null ? void 0 : e.persist();

        _this.setState(size, function () {
          return _this.props.onResize && _this.props.onResize(e, data);
        });
      } else {
        _this.setState(size);
      }
    };

    return _this;
  }

  ResizableBox.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    // If parent changes height/width, set that in our state.
    if (state.propsWidth !== props.width || state.propsHeight !== props.height) {
      return {
        width: props.width,
        height: props.height,
        propsWidth: props.width,
        propsHeight: props.height
      };
    }

    return null;
  };

  var _proto = ResizableBox.prototype;

  _proto.render = function render() {
    // Basic wrapper around a Resizable instance.
    // If you use Resizable directly, you are responsible for updating the child component
    // with a new width and height.
    var _this$props = this.props,
        handle = _this$props.handle,
        handleSize = _this$props.handleSize,
        onResize = _this$props.onResize,
        onResizeStart = _this$props.onResizeStart,
        onResizeStop = _this$props.onResizeStop,
        draggableOpts = _this$props.draggableOpts,
        minConstraints = _this$props.minConstraints,
        maxConstraints = _this$props.maxConstraints,
        lockAspectRatio = _this$props.lockAspectRatio,
        axis = _this$props.axis,
        width = _this$props.width,
        height = _this$props.height,
        resizeHandles = _this$props.resizeHandles,
        style = _this$props.style,
        transformScale = _this$props.transformScale,
        props = _objectWithoutPropertiesLoose(_this$props, _excluded);

    return /*#__PURE__*/React.createElement(_Resizable.default, {
      axis: axis,
      draggableOpts: draggableOpts,
      handle: handle,
      handleSize: handleSize,
      height: this.state.height,
      lockAspectRatio: lockAspectRatio,
      maxConstraints: maxConstraints,
      minConstraints: minConstraints,
      onResizeStart: onResizeStart,
      onResize: this.onResize,
      onResizeStop: onResizeStop,
      resizeHandles: resizeHandles,
      transformScale: transformScale,
      width: this.state.width
    }, /*#__PURE__*/React.createElement("div", _extends({}, props, {
      style: _objectSpread(_objectSpread({}, style), {}, {
        width: this.state.width + 'px',
        height: this.state.height + 'px'
      })
    })));
  };

  return ResizableBox;
}(React.Component);

exports["default"] = ResizableBox;
ResizableBox.propTypes = _objectSpread(_objectSpread({}, _propTypes2.resizableProps), {}, {
  children: _propTypes.default.element
});

/***/ }),

/***/ "./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/propTypes.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.__esModule = true;
exports.resizableProps = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__("./.yarn/cache/prop-types-npm-15.7.2-d7a04f2274-5eef82fdda.zip/node_modules/prop-types/index.js"));

var _reactDraggable = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/cjs.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var resizableProps = {
  /*
  * Restricts resizing to a particular axis (default: 'both')
  * 'both' - allows resizing by width or height
  * 'x' - only allows the width to be changed
  * 'y' - only allows the height to be changed
  * 'none' - disables resizing altogether
  * */
  axis: _propTypes.default.oneOf(['both', 'x', 'y', 'none']),
  className: _propTypes.default.string,

  /*
  * Require that one and only one child be present.
  * */
  children: _propTypes.default.element.isRequired,

  /*
  * These will be passed wholesale to react-draggable's DraggableCore
  * */
  draggableOpts: _propTypes.default.shape({
    allowAnyClick: _propTypes.default.bool,
    cancel: _propTypes.default.string,
    children: _propTypes.default.node,
    disabled: _propTypes.default.bool,
    enableUserSelectHack: _propTypes.default.bool,
    offsetParent: _propTypes.default.node,
    grid: _propTypes.default.arrayOf(_propTypes.default.number),
    handle: _propTypes.default.string,
    nodeRef: _propTypes.default.object,
    onStart: _propTypes.default.func,
    onDrag: _propTypes.default.func,
    onStop: _propTypes.default.func,
    onMouseDown: _propTypes.default.func,
    scale: _propTypes.default.number
  }),

  /*
  * Initial height
  * */
  height: _propTypes.default.number.isRequired,

  /*
  * Customize cursor resize handle
  * */
  handle: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),

  /*
  * If you change this, be sure to update your css
  * */
  handleSize: _propTypes.default.arrayOf(_propTypes.default.number),
  lockAspectRatio: _propTypes.default.bool,

  /*
  * Max X & Y measure
  * */
  maxConstraints: _propTypes.default.arrayOf(_propTypes.default.number),

  /*
  * Min X & Y measure
  * */
  minConstraints: _propTypes.default.arrayOf(_propTypes.default.number),

  /*
  * Called on stop resize event
  * */
  onResizeStop: _propTypes.default.func,

  /*
  * Called on start resize event
  * */
  onResizeStart: _propTypes.default.func,

  /*
  * Called on resize event
  * */
  onResize: _propTypes.default.func,

  /*
  * Defines which resize handles should be rendered (default: 'se')
  * 's' - South handle (bottom-center)
  * 'w' - West handle (left-center)
  * 'e' - East handle (right-center)
  * 'n' - North handle (top-center)
  * 'sw' - Southwest handle (bottom-left)
  * 'nw' - Northwest handle (top-left)
  * 'se' - Southeast handle (bottom-right)
  * 'ne' - Northeast handle (top-center)
  * */
  resizeHandles: _propTypes.default.arrayOf(_propTypes.default.oneOf(['s', 'w', 'e', 'n', 'sw', 'nw', 'se', 'ne'])),

  /*
  * If `transform: scale(n)` is set on the parent, this should be set to `n`.
  * */
  transformScale: _propTypes.default.number,

  /*
   * Initial width
   */
  width: _propTypes.default.number.isRequired
};
exports.resizableProps = resizableProps;

/***/ }),

/***/ "./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/utils.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.__esModule = true;
exports.cloneElement = cloneElement;

var _react = _interopRequireDefault(__webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// React.addons.cloneWithProps look-alike that merges style & className.
function cloneElement(element, props) {
  if (props.style && element.props.style) {
    props.style = _objectSpread(_objectSpread({}, element.props.style), props.style);
  }

  if (props.className && element.props.className) {
    props.className = element.props.className + " " + props.className;
  }

  return /*#__PURE__*/_react.default.cloneElement(element, props);
}

/***/ }),

/***/ "./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


module.exports = function() {
  throw new Error("Don't instantiate Resizable directly! Use require('react-resizable').Resizable");
};

module.exports.Resizable = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/Resizable.js")["default"];
module.exports.ResizableBox = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/ResizableBox.js")["default"];


/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useObservable.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-cea8e826dc/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useIsomorphicLayoutEffect.js");


function useObservable(observable$, initialValue) {
    var _a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialValue), value = _a[0], update = _a[1];
    (0,_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_1__["default"])(function () {
        var s = observable$.subscribe(update);
        return function () { return s.unsubscribe(); };
    }, [observable$]);
    return value;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useObservable);


/***/ }),

/***/ "./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": () => (/* binding */ $),
/* harmony export */   "ANIMATION": () => (/* binding */ ANIMATION),
/* harmony export */   "ARRAY": () => (/* binding */ ARRAY),
/* harmony export */   "COLOR_MODELS": () => (/* binding */ COLOR_MODELS),
/* harmony export */   "DEFAULT_UNIT_PRESETS": () => (/* binding */ DEFAULT_UNIT_PRESETS),
/* harmony export */   "FILTER": () => (/* binding */ FILTER),
/* harmony export */   "FUNCTION": () => (/* binding */ FUNCTION),
/* harmony export */   "HSL": () => (/* binding */ HSL),
/* harmony export */   "HSLA": () => (/* binding */ HSLA),
/* harmony export */   "IS_WINDOW": () => (/* binding */ IS_WINDOW),
/* harmony export */   "KEYFRAMES": () => (/* binding */ KEYFRAMES),
/* harmony export */   "NUMBER": () => (/* binding */ NUMBER),
/* harmony export */   "OBJECT": () => (/* binding */ OBJECT),
/* harmony export */   "OPEN_CLOSED_CHARACTERS": () => (/* binding */ OPEN_CLOSED_CHARACTERS),
/* harmony export */   "PROPERTY": () => (/* binding */ PROPERTY),
/* harmony export */   "RGB": () => (/* binding */ RGB),
/* harmony export */   "RGBA": () => (/* binding */ RGBA),
/* harmony export */   "STRING": () => (/* binding */ STRING),
/* harmony export */   "TINY_NUM": () => (/* binding */ TINY_NUM),
/* harmony export */   "TRANSFORM": () => (/* binding */ TRANSFORM),
/* harmony export */   "UNDEFINED": () => (/* binding */ UNDEFINED),
/* harmony export */   "addClass": () => (/* binding */ addClass),
/* harmony export */   "addEvent": () => (/* binding */ addEvent),
/* harmony export */   "average": () => (/* binding */ average),
/* harmony export */   "between": () => (/* binding */ between),
/* harmony export */   "calculateBoundSize": () => (/* binding */ calculateBoundSize),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "cancelAnimationFrame": () => (/* binding */ cancelAnimationFrame),
/* harmony export */   "checkBoundSize": () => (/* binding */ checkBoundSize),
/* harmony export */   "convertUnitSize": () => (/* binding */ convertUnitSize),
/* harmony export */   "counter": () => (/* binding */ counter),
/* harmony export */   "cutHex": () => (/* binding */ cutHex),
/* harmony export */   "decamelize": () => (/* binding */ decamelize),
/* harmony export */   "document": () => (/* binding */ doc),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "findIndex": () => (/* binding */ findIndex),
/* harmony export */   "findLast": () => (/* binding */ findLast),
/* harmony export */   "findLastIndex": () => (/* binding */ findLastIndex),
/* harmony export */   "fromCSS": () => (/* binding */ fromCSS),
/* harmony export */   "getCenterPoint": () => (/* binding */ getCenterPoint),
/* harmony export */   "getCrossBrowserProperty": () => (/* binding */ getCrossBrowserProperty),
/* harmony export */   "getDist": () => (/* binding */ getDist),
/* harmony export */   "getKeys": () => (/* binding */ getKeys),
/* harmony export */   "getRad": () => (/* binding */ getRad),
/* harmony export */   "getShapeDirection": () => (/* binding */ getShapeDirection),
/* harmony export */   "hasClass": () => (/* binding */ hasClass),
/* harmony export */   "hexToRGBA": () => (/* binding */ hexToRGBA),
/* harmony export */   "hslToRGBA": () => (/* binding */ hslToRGBA),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined),
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "removeClass": () => (/* binding */ removeClass),
/* harmony export */   "removeEvent": () => (/* binding */ removeEvent),
/* harmony export */   "replaceOnce": () => (/* binding */ replaceOnce),
/* harmony export */   "requestAnimationFrame": () => (/* binding */ requestAnimationFrame),
/* harmony export */   "sortOrders": () => (/* binding */ sortOrders),
/* harmony export */   "splitBracket": () => (/* binding */ splitBracket),
/* harmony export */   "splitComma": () => (/* binding */ splitComma),
/* harmony export */   "splitSpace": () => (/* binding */ splitSpace),
/* harmony export */   "splitText": () => (/* binding */ splitText),
/* harmony export */   "splitUnit": () => (/* binding */ splitUnit),
/* harmony export */   "stringToRGBA": () => (/* binding */ stringToRGBA),
/* harmony export */   "sum": () => (/* binding */ sum),
/* harmony export */   "throttle": () => (/* binding */ throttle),
/* harmony export */   "throttleArray": () => (/* binding */ throttleArray),
/* harmony export */   "toArray": () => (/* binding */ toArray),
/* harmony export */   "toFullHex": () => (/* binding */ toFullHex)
/* harmony export */ });
/*
Copyright (c) 2018 Daybrush
@name: @daybrush/utils
license: MIT
author: Daybrush
repository: https://github.com/daybrush/utils
@version 1.6.0
*/
/**
* @namespace
* @name Consts
*/

/**
* get string "rgb"
* @memberof Color
* @example
import {RGB} from "@daybrush/utils";

console.log(RGB); // "rgb"
*/
var RGB = "rgb";
/**
* get string "rgba"
* @memberof Color
* @example
import {RGBA} from "@daybrush/utils";

console.log(RGBA); // "rgba"
*/

var RGBA = "rgba";
/**
* get string "hsl"
* @memberof Color
* @example
import {HSL} from "@daybrush/utils";

console.log(HSL); // "hsl"
*/

var HSL = "hsl";
/**
* get string "hsla"
* @memberof Color
* @example
import {HSLA} from "@daybrush/utils";

console.log(HSLA); // "hsla"
*/

var HSLA = "hsla";
/**
* gets an array of color models.
* @memberof Color
* @example
import {COLOR_MODELS} from "@daybrush/utils";

console.log(COLOR_MODELS); // ["rgb", "rgba", "hsl", "hsla"];
*/

var COLOR_MODELS = [RGB, RGBA, HSL, HSLA];
/**
* get string "function"
* @memberof Consts
* @example
import {FUNCTION} from "@daybrush/utils";

console.log(FUNCTION); // "function"
*/

var FUNCTION = "function";
/**
* get string "property"
* @memberof Consts
* @example
import {PROPERTY} from "@daybrush/utils";

console.log(PROPERTY); // "property"
*/

var PROPERTY = "property";
/**
* get string "array"
* @memberof Consts
* @example
import {ARRAY} from "@daybrush/utils";

console.log(ARRAY); // "array"
*/

var ARRAY = "array";
/**
* get string "object"
* @memberof Consts
* @example
import {OBJECT} from "@daybrush/utils";

console.log(OBJECT); // "object"
*/

var OBJECT = "object";
/**
* get string "string"
* @memberof Consts
* @example
import {STRING} from "@daybrush/utils";

console.log(STRING); // "string"
*/

var STRING = "string";
/**
* get string "number"
* @memberof Consts
* @example
import {NUMBER} from "@daybrush/utils";

console.log(NUMBER); // "number"
*/

var NUMBER = "number";
/**
* get string "undefined"
* @memberof Consts
* @example
import {UNDEFINED} from "@daybrush/utils";

console.log(UNDEFINED); // "undefined"
*/

var UNDEFINED = "undefined";
/**
* Check whether the environment is window or node.js.
* @memberof Consts
* @example
import {IS_WINDOW} from "@daybrush/utils";

console.log(IS_WINDOW); // false in node.js
console.log(IS_WINDOW); // true in browser
*/

var IS_WINDOW = typeof window !== UNDEFINED;
/**
* Check whether the environment is window or node.js.
* @memberof Consts
* @name document
* @example
import {IS_WINDOW} from "@daybrush/utils";

console.log(IS_WINDOW); // false in node.js
console.log(IS_WINDOW); // true in browser
*/

var doc = typeof document !== UNDEFINED && document; // FIXME: this type maybe false
var prefixes = ["webkit", "ms", "moz", "o"];
/**
 * @namespace CrossBrowser
 */

/**
* Get a CSS property with a vendor prefix that supports cross browser.
* @function
* @param {string} property - A CSS property
* @return {string} CSS property with cross-browser vendor prefix
* @memberof CrossBrowser
* @example
import {getCrossBrowserProperty} from "@daybrush/utils";

console.log(getCrossBrowserProperty("transform")); // "transform", "-ms-transform", "-webkit-transform"
console.log(getCrossBrowserProperty("filter")); // "filter", "-webkit-filter"
*/

var getCrossBrowserProperty = /*#__PURE__*/function (property) {
  if (!doc) {
    return "";
  }

  var styles = (doc.body || doc.documentElement).style;
  var length = prefixes.length;

  if (typeof styles[property] !== UNDEFINED) {
    return property;
  }

  for (var i = 0; i < length; ++i) {
    var name = "-" + prefixes[i] + "-" + property;

    if (typeof styles[name] !== UNDEFINED) {
      return name;
    }
  }

  return "";
};
/**
* get string "transfrom" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {TRANSFORM} from "@daybrush/utils";

console.log(TRANSFORM); // "transform", "-ms-transform", "-webkit-transform"
*/

var TRANSFORM = /*#__PURE__*/getCrossBrowserProperty("transform");
/**
* get string "filter" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {FILTER} from "@daybrush/utils";

console.log(FILTER); // "filter", "-ms-filter", "-webkit-filter"
*/

var FILTER = /*#__PURE__*/getCrossBrowserProperty("filter");
/**
* get string "animation" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {ANIMATION} from "@daybrush/utils";

console.log(ANIMATION); // "animation", "-ms-animation", "-webkit-animation"
*/

var ANIMATION = /*#__PURE__*/getCrossBrowserProperty("animation");
/**
* get string "keyframes" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {KEYFRAMES} from "@daybrush/utils";

console.log(KEYFRAMES); // "keyframes", "-ms-keyframes", "-webkit-keyframes"
*/

var KEYFRAMES = /*#__PURE__*/ANIMATION.replace("animation", "keyframes");
var OPEN_CLOSED_CHARACTERS = [{
  open: "(",
  close: ")"
}, {
  open: "\"",
  close: "\""
}, {
  open: "'",
  close: "'"
}, {
  open: "\\\"",
  close: "\\\""
}, {
  open: "\\'",
  close: "\\'"
}];
var TINY_NUM = 0.0000001;
var DEFAULT_UNIT_PRESETS = {
  "cm": function (pos) {
    return pos * 96 / 2.54;
  },
  "mm": function (pos) {
    return pos * 96 / 254;
  },
  "in": function (pos) {
    return pos * 96;
  },
  "pt": function (pos) {
    return pos * 96 / 72;
  },
  "pc": function (pos) {
    return pos * 96 / 6;
  },
  "%": function (pos, size) {
    return pos * size / 100;
  },
  "vw": function (pos, size) {
    if (size === void 0) {
      size = window.innerWidth;
    }

    return pos / 100 * size;
  },
  "vh": function (pos, size) {
    if (size === void 0) {
      size = window.innerHeight;
    }

    return pos / 100 * size;
  },
  "vmax": function (pos, size) {
    if (size === void 0) {
      size = Math.max(window.innerWidth, window.innerHeight);
    }

    return pos / 100 * size;
  },
  "vmin": function (pos, size) {
    if (size === void 0) {
      size = Math.min(window.innerWidth, window.innerHeight);
    }

    return pos / 100 * size;
  }
};

/**
* @namespace
* @name Utils
*/

/**
 * Returns the inner product of two numbers(`a1`, `a2`) by two criteria(`b1`, `b2`).
 * @memberof Utils
 * @param - The first number
 * @param - The second number
 * @param - The first number to base on the inner product
 * @param - The second number to base on the inner product
 * @return - Returns the inner product
import { dot } from "@daybrush/utils";

console.log(dot(0, 15, 2, 3)); // 6
console.log(dot(5, 15, 2, 3)); // 9
console.log(dot(5, 15, 1, 1)); // 10
 */

function dot(a1, a2, b1, b2) {
  return (a1 * b2 + a2 * b1) / (b1 + b2);
}
/**
* Check the type that the value is undefined.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {boolean} true if the type is correct, false otherwise
* @example
import {isUndefined} from "@daybrush/utils";

console.log(isUndefined(undefined)); // true
console.log(isUndefined("")); // false
console.log(isUndefined(1)); // false
console.log(isUndefined(null)); // false
*/

function isUndefined(value) {
  return typeof value === UNDEFINED;
}
/**
* Check the type that the value is object.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isObject} from "@daybrush/utils";

console.log(isObject({})); // true
console.log(isObject(undefined)); // false
console.log(isObject("")); // false
console.log(isObject(null)); // false
*/

function isObject(value) {
  return value && typeof value === OBJECT;
}
/**
* Check the type that the value is isArray.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isArray} from "@daybrush/utils";

console.log(isArray([])); // true
console.log(isArray({})); // false
console.log(isArray(undefined)); // false
console.log(isArray(null)); // false
*/

function isArray(value) {
  return Array.isArray(value);
}
/**
* Check the type that the value is string.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isString} from "@daybrush/utils";

console.log(isString("1234")); // true
console.log(isString(undefined)); // false
console.log(isString(1)); // false
console.log(isString(null)); // false
*/

function isString(value) {
  return typeof value === STRING;
}
function isNumber(value) {
  return typeof value === NUMBER;
}
/**
* Check the type that the value is function.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isFunction} from "@daybrush/utils";

console.log(isFunction(function a() {})); // true
console.log(isFunction(() => {})); // true
console.log(isFunction("1234")); // false
console.log(isFunction(1)); // false
console.log(isFunction(null)); // false
*/

function isFunction(value) {
  return typeof value === FUNCTION;
}

function isEqualSeparator(character, separator) {
  var isCharacterSpace = character === "" || character == " ";
  var isSeparatorSpace = separator === "" || separator == " ";
  return isSeparatorSpace && isCharacterSpace || character === separator;
}

function findOpen(openCharacter, texts, index, length, openCloseCharacters) {
  var isIgnore = findIgnore(openCharacter, texts, index);

  if (!isIgnore) {
    return findClose(openCharacter, texts, index + 1, length, openCloseCharacters);
  }

  return index;
}

function findIgnore(character, texts, index) {
  if (!character.ignore) {
    return null;
  }

  var otherText = texts.slice(Math.max(index - 3, 0), index + 3).join("");
  return new RegExp(character.ignore).exec(otherText);
}

function findClose(closeCharacter, texts, index, length, openCloseCharacters) {
  var _loop_1 = function (i) {
    var character = texts[i].trim();

    if (character === closeCharacter.close && !findIgnore(closeCharacter, texts, i)) {
      return {
        value: i
      };
    }

    var nextIndex = i; // re open

    var openCharacter = find(openCloseCharacters, function (_a) {
      var open = _a.open;
      return open === character;
    });

    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);
    }

    if (nextIndex === -1) {
      return out_i_1 = i, "break";
    }

    i = nextIndex;
    out_i_1 = i;
  };

  var out_i_1;

  for (var i = index; i < length; ++i) {
    var state_1 = _loop_1(i);

    i = out_i_1;
    if (typeof state_1 === "object") return state_1.value;
    if (state_1 === "break") break;
  }

  return -1;
}

function splitText(text, splitOptions) {
  var _a = isString(splitOptions) ? {
    separator: splitOptions
  } : splitOptions,
      _b = _a.separator,
      separator = _b === void 0 ? "," : _b,
      isSeparateFirst = _a.isSeparateFirst,
      isSeparateOnlyOpenClose = _a.isSeparateOnlyOpenClose,
      _c = _a.isSeparateOpenClose,
      isSeparateOpenClose = _c === void 0 ? isSeparateOnlyOpenClose : _c,
      _d = _a.openCloseCharacters,
      openCloseCharacters = _d === void 0 ? OPEN_CLOSED_CHARACTERS : _d;

  var openClosedText = openCloseCharacters.map(function (_a) {
    var open = _a.open,
        close = _a.close;

    if (open === close) {
      return open;
    }

    return open + "|" + close;
  }).join("|");
  var regexText = "(\\s*" + separator + "\\s*|" + openClosedText + "|\\s+)";
  var regex = new RegExp(regexText, "g");
  var texts = text.split(regex).filter(Boolean);
  var length = texts.length;
  var values = [];
  var tempValues = [];

  function resetTemp() {
    if (tempValues.length) {
      values.push(tempValues.join(""));
      tempValues = [];
      return true;
    }

    return false;
  }

  var _loop_2 = function (i) {
    var character = texts[i].trim();
    var nextIndex = i;
    var openCharacter = find(openCloseCharacters, function (_a) {
      var open = _a.open;
      return open === character;
    });
    var closeCharacter = find(openCloseCharacters, function (_a) {
      var close = _a.close;
      return close === character;
    });

    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);

      if (nextIndex !== -1 && isSeparateOpenClose) {
        if (resetTemp() && isSeparateFirst) {
          return out_i_2 = i, "break";
        }

        values.push(texts.slice(i, nextIndex + 1).join(""));
        i = nextIndex;

        if (isSeparateFirst) {
          return out_i_2 = i, "break";
        }

        return out_i_2 = i, "continue";
      }
    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i)) {
      throw new Error("invalid format: " + closeCharacter.close);
    } else if (isEqualSeparator(character, separator) && !isSeparateOnlyOpenClose) {
      resetTemp();

      if (isSeparateFirst) {
        return out_i_2 = i, "break";
      }

      return out_i_2 = i, "continue";
    }

    if (nextIndex === -1) {
      nextIndex = length - 1;
    }

    tempValues.push(texts.slice(i, nextIndex + 1).join(""));
    i = nextIndex;
    out_i_2 = i;
  };

  var out_i_2;

  for (var i = 0; i < length; ++i) {
    var state_2 = _loop_2(i);

    i = out_i_2;
    if (state_2 === "break") break;
  }

  if (tempValues.length) {
    values.push(tempValues.join(""));
  }

  return values;
}
/**
* divide text by space.
* @memberof Utils
* @param {string} text - text to divide
* @return {Array} divided texts
* @example
import {spliceSpace} from "@daybrush/utils";

console.log(splitSpace("a b c d e f g"));
// ["a", "b", "c", "d", "e", "f", "g"]
console.log(splitSpace("'a,b' c 'd,e' f g"));
// ["'a,b'", "c", "'d,e'", "f", "g"]
*/

function splitSpace(text) {
  // divide comma(space)
  return splitText(text, "");
}
/**
* divide text by comma.
* @memberof Utils
* @param {string} text - text to divide
* @return {Array} divided texts
* @example
import {splitComma} from "@daybrush/utils";

console.log(splitComma("a,b,c,d,e,f,g"));
// ["a", "b", "c", "d", "e", "f", "g"]
console.log(splitComma("'a,b',c,'d,e',f,g"));
// ["'a,b'", "c", "'d,e'", "f", "g"]
*/

function splitComma(text) {
  // divide comma(,)
  // "[^"]*"|'[^']*'
  return splitText(text, ",");
}
/**
* divide text by bracket "(", ")".
* @memberof Utils
* @param {string} text - text to divide
* @return {object} divided texts
* @example
import {splitBracket} from "@daybrush/utils";

console.log(splitBracket("a(1, 2)"));
// {prefix: "a", value: "1, 2", suffix: ""}
console.log(splitBracket("a(1, 2)b"));
// {prefix: "a", value: "1, 2", suffix: "b"}
*/

function splitBracket(text) {
  var matches = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(text);

  if (!matches || matches.length < 4) {
    return {};
  } else {
    return {
      prefix: matches[1],
      value: matches[2],
      suffix: matches[3]
    };
  }
}
/**
* divide text by number and unit.
* @memberof Utils
* @param {string} text - text to divide
* @return {} divided texts
* @example
import {splitUnit} from "@daybrush/utils";

console.log(splitUnit("10px"));
// {prefix: "", value: 10, unit: "px"}
console.log(splitUnit("-10px"));
// {prefix: "", value: -10, unit: "px"}
console.log(splitUnit("a10%"));
// {prefix: "a", value: 10, unit: "%"}
*/

function splitUnit(text) {
  var matches = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(text);

  if (!matches) {
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  }

  var prefix = matches[1];
  var value = matches[2];
  var unit = matches[3];
  return {
    prefix: prefix,
    unit: unit,
    value: parseFloat(value)
  };
}
/**
* transform strings to camel-case
* @memberof Utils
* @param {String} text - string
* @return {String} camel-case string
* @example
import {camelize} from "@daybrush/utils";

console.log(camelize("transform-origin")); // transformOrigin
console.log(camelize("abcd_efg")); // abcdEfg
console.log(camelize("abcd efg")); // abcdEfg
*/

function camelize(str) {
  return str.replace(/[\s-_]([a-z])/g, function (all, letter) {
    return letter.toUpperCase();
  });
}
/**
* transform a camelized string into a lowercased string.
* @memberof Utils
* @param {string} text - a camel-cased string
* @param {string} [separator="-"] - a separator
* @return {string}  a lowercased string
* @example
import {decamelize} from "@daybrush/utils";

console.log(decamelize("transformOrigin")); // transform-origin
console.log(decamelize("abcdEfg", "_")); // abcd_efg
*/

function decamelize(str, separator) {
  if (separator === void 0) {
    separator = "-";
  }

  return str.replace(/([a-z])([A-Z])/g, function (all, letter, letter2) {
    return "" + letter + separator + letter2.toLowerCase();
  });
}
/**
* transforms something in an array into an array.
* @memberof Utils
* @param - Array form
* @return an array
* @example
import {toArray} from "@daybrush/utils";

const arr1 = toArray(document.querySelectorAll(".a")); // Element[]
const arr2 = toArray(document.querySelectorAll<HTMLElement>(".a")); // HTMLElement[]
*/

function toArray(value) {
  return [].slice.call(value);
}
/**
* Date.now() method
* @memberof CrossBrowser
* @return {number} milliseconds
* @example
import {now} from "@daybrush/utils";

console.log(now()); // 12121324241(milliseconds)
*/

function now() {
  return Date.now ? Date.now() : new Date().getTime();
}
/**
* Returns the index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findIndex } from "@daybrush/utils";

findIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Returns the reverse direction index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findLastIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findLastIndex } from "@daybrush/utils";

findLastIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findLastIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = length - 1; i >= 0; --i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Returns the value of the reverse direction element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findLast` was called upon.
* @param - A function to execute on each value in the array,
* @param - Returns defalutValue if not found by the function.
* @example
import { find } from "@daybrush/utils";

find([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}
*/

function findLast(arr, callback, defalutValue) {
  var index = findLastIndex(arr, callback);
  return index > -1 ? arr[index] : defalutValue;
}
/**
* Returns the value of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `find` was called upon.
* @param - A function to execute on each value in the array,
* @param - Returns defalutValue if not found by the function.
* @example
import { find } from "@daybrush/utils";

find([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}
*/

function find(arr, callback, defalutValue) {
  var index = findIndex(arr, callback);
  return index > -1 ? arr[index] : defalutValue;
}
/**
* window.requestAnimationFrame() method with cross browser.
* @function
* @memberof CrossBrowser
* @param {FrameRequestCallback} callback - The function to call when it's time to update your animation for the next repaint.
* @return {number} id
* @example
import {requestAnimationFrame} from "@daybrush/utils";

requestAnimationFrame((timestamp) => {
  console.log(timestamp);
});
*/

var requestAnimationFrame = /*#__PURE__*/function () {
  var firstTime = now();
  var raf = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return raf ? raf.bind(window) : function (callback) {
    var currTime = now();
    var id = window.setTimeout(function () {
      callback(currTime - firstTime);
    }, 1000 / 60);
    return id;
  };
}();
/**
* window.cancelAnimationFrame() method with cross browser.
* @function
* @memberof CrossBrowser
* @param {number} handle - the id obtained through requestAnimationFrame method
* @return {void}
* @example
import { requestAnimationFrame, cancelAnimationFrame } from "@daybrush/utils";

const id = requestAnimationFrame((timestamp) => {
  console.log(timestamp);
});

cancelAnimationFrame(id);
*/

var cancelAnimationFrame = /*#__PURE__*/function () {
  var caf = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return caf ? caf.bind(window) : function (handle) {
    clearTimeout(handle);
  };
}();
/**
* @function
* @memberof Utils
*/

function getKeys(obj) {
  if (Object.keys) {
    return Object.keys(obj);
  }

  var keys = [];

  for (var name in keys) {
    keys.push(name);
  }

  return keys;
}
/**
* @function
* @memberof Utils
*/

function sortOrders(keys, orders) {
  if (orders === void 0) {
    orders = [];
  }

  keys.sort(function (a, b) {
    var index1 = orders.indexOf(a);
    var index2 = orders.indexOf(b);

    if (index2 === -1 && index1 === -1) {
      return 0;
    }

    if (index1 === -1) {
      return 1;
    }

    if (index2 === -1) {
      return -1;
    }

    return index1 - index2;
  });
}
/**
* convert unit size to px size
* @function
* @memberof Utils
*/

function convertUnitSize(pos, size) {
  var _a = splitUnit(pos),
      value = _a.value,
      unit = _a.unit;

  if (isObject(size)) {
    var sizeFunction = size[unit];

    if (sizeFunction) {
      if (isFunction(sizeFunction)) {
        return sizeFunction(value);
      } else if (DEFAULT_UNIT_PRESETS[unit]) {
        return DEFAULT_UNIT_PRESETS[unit](value, sizeFunction);
      }
    }
  } else if (unit === "%") {
    return value * size / 100;
  }

  if (DEFAULT_UNIT_PRESETS[unit]) {
    return DEFAULT_UNIT_PRESETS[unit](value);
  }

  return value;
}
/**
* calculate between min, max
* @function
* @memberof Utils
*/

function between(value, min, max) {
  return Math.max(min, Math.min(value, max));
}
function checkBoundSize(targetSize, compareSize, isMax) {
  return [[throttle(compareSize[0], TINY_NUM), throttle(compareSize[0] * targetSize[1] / targetSize[0], TINY_NUM)], [throttle(compareSize[1] * targetSize[0] / targetSize[1], TINY_NUM), throttle(compareSize[1], TINY_NUM)]].filter(function (size) {
    return size.every(function (value, i) {
      return isMax ? value <= compareSize[i] : value >= compareSize[i];
    });
  })[0] || targetSize;
}
/**
* calculate bound size
* @function
* @memberof Utils
*/

function calculateBoundSize(size, minSize, maxSize, keepRatio) {
  if (!keepRatio) {
    return size.map(function (value, i) {
      return between(value, minSize[i], maxSize[i]);
    });
  }

  var width = size[0],
      height = size[1]; // width : height = minWidth : minHeight;

  var _a = checkBoundSize(size, minSize, false),
      minWidth = _a[0],
      minHeight = _a[1];

  var _b = checkBoundSize(size, maxSize, true),
      maxWidth = _b[0],
      maxHeight = _b[1];

  if (width < minWidth || height < minHeight) {
    width = minWidth;
    height = minHeight;
  } else if (width > maxWidth || height > maxHeight) {
    width = maxWidth;
    height = maxHeight;
  }

  return [width, height];
}
/**
* Add all the numbers.
* @function
* @memberof Utils
*/

function sum(nums) {
  var length = nums.length;
  var total = 0;

  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }

  return total;
}
/**
* Average all numbers.
* @function
* @memberof Utils
*/

function average(nums) {
  var length = nums.length;
  var total = 0;

  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }

  return length ? total / length : 0;
}
/**
* Get the angle of two points. (0 <= rad < 359)
* @function
* @memberof Utils
*/

function getRad(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
/**
* Get the average point of all points.
* @function
* @memberof Utils
*/

function getCenterPoint(points) {
  return [0, 1].map(function (i) {
    return average(points.map(function (pos) {
      return pos[i];
    }));
  });
}
/**
* Gets the direction of the shape.
* @function
* @memberof Utils
*/

function getShapeDirection(points) {
  var center = getCenterPoint(points);
  var pos1Rad = getRad(center, points[0]);
  var pos2Rad = getRad(center, points[1]);
  return pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;
}
/**
* Get the distance between two points.
* @function
* @memberof Utils
*/

function getDist(a, b) {
  return Math.sqrt(Math.pow((b ? b[0] : 0) - a[0], 2) + Math.pow((b ? b[1] : 0) - a[1], 2));
}
/**
* throttle number depending on the unit.
* @function
* @memberof Utils
*/

function throttle(num, unit) {
  if (!unit) {
    return num;
  }

  return Math.round(num / unit) * unit;
}
/**
* throttle number array depending on the unit.
* @function
* @memberof Utils
*/

function throttleArray(nums, unit) {
  nums.forEach(function (_, i) {
    nums[i] = throttle(nums[i], unit);
  });
  return nums;
}
/**
* @function
* @memberof Utils
*/

function counter(num) {
  var nums = [];

  for (var i = 0; i < num; ++i) {
    nums.push(i);
  }

  return nums;
}
/**
* @function
* @memberof Utils
*/

function replaceOnce(text, fromText, toText) {
  var isOnce = false;
  return text.replace(fromText, function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    if (isOnce) {
      return args[0];
    }

    isOnce = true;
    return isString(toText) ? toText : toText.apply(void 0, args);
  });
}

/**
* @namespace
* @name Color
*/

/**
* Remove the # from the hex color.
* @memberof Color
* @param {} hex - hex color
* @return {} hex color
* @example
import {cutHex} from "@daybrush/utils";

console.log(cutHex("#000000")) // "000000"
*/

function cutHex(hex) {
  return hex.replace("#", "");
}
/**
* convert hex color to rgb color.
* @memberof Color
* @param {} hex - hex color
* @return {} rgb color
* @example
import {hexToRGBA} from "@daybrush/utils";

console.log(hexToRGBA("#00000005"));
// [0, 0, 0, 1]
console.log(hexToRGBA("#201045"));
// [32, 16, 69, 1]
*/

function hexToRGBA(hex) {
  var h = cutHex(hex);
  var r = parseInt(h.substring(0, 2), 16);
  var g = parseInt(h.substring(2, 4), 16);
  var b = parseInt(h.substring(4, 6), 16);
  var a = parseInt(h.substring(6, 8), 16) / 255;

  if (isNaN(a)) {
    a = 1;
  }

  return [r, g, b, a];
}
/**
* convert 3(or 4)-digit hex color to 6(or 8)-digit hex color.
* @memberof Color
* @param {} hex - 3(or 4)-digit hex color
* @return {} 6(or 8)-digit hex color
* @example
import {toFullHex} from "@daybrush/utils";

console.log(toFullHex("#123")); // "#112233"
console.log(toFullHex("#123a")); // "#112233aa"
*/

function toFullHex(h) {
  var r = h.charAt(1);
  var g = h.charAt(2);
  var b = h.charAt(3);
  var a = h.charAt(4);
  var arr = ["#", r, r, g, g, b, b, a, a];
  return arr.join("");
}
/**
* convert hsl color to rgba color.
* @memberof Color
* @param {} hsl - hsl color(hue: 0 ~ 360, saturation: 0 ~ 1, lightness: 0 ~ 1, alpha: 0 ~ 1)
* @return {} rgba color
* @example
import {hslToRGBA} from "@daybrush/utils";

console.log(hslToRGBA([150, 0.5, 0.4]));
// [51, 153, 102, 1]
*/

function hslToRGBA(hsl) {
  var _a;

  var h = hsl[0];
  var s = hsl[1];
  var l = hsl[2];

  if (h < 0) {
    h += Math.floor((Math.abs(h) + 360) / 360) * 360;
  }

  h %= 360;
  var c = (1 - Math.abs(2 * l - 1)) * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = l - c / 2;
  var rgb;

  if (h < 60) {
    rgb = [c, x, 0];
  } else if (h < 120) {
    rgb = [x, c, 0];
  } else if (h < 180) {
    rgb = [0, c, x];
  } else if (h < 240) {
    rgb = [0, x, c];
  } else if (h < 300) {
    rgb = [x, 0, c];
  } else if (h < 360) {
    rgb = [c, 0, x];
  } else {
    rgb = [0, 0, 0];
  }

  return [Math.round((rgb[0] + m) * 255), Math.round((rgb[1] + m) * 255), Math.round((rgb[2] + m) * 255), (_a = hsl[3]) !== null && _a !== void 0 ? _a : 1];
}
/**
* convert string to rgba color.
* @memberof Color
* @param {} - 3-hex(#000), 4-hex(#0000) 6-hex(#000000), 8-hex(#00000000) or RGB(A), or HSL(A)
* @return {} rgba color
* @example
import {stringToRGBA} from "@daybrush/utils";

console.log(stringToRGBA("#000000")); // [0, 0, 0, 1]
console.log(stringToRGBA("rgb(100, 100, 100)")); // [100, 100, 100, 1]
console.log(stringToRGBA("hsl(150, 0.5, 0.4)")); // [51, 153, 102, 1]
*/

function stringToRGBA(color) {
  if (color.charAt(0) === "#") {
    if (color.length === 4 || color.length === 5) {
      return hexToRGBA(toFullHex(color));
    } else {
      return hexToRGBA(color);
    }
  } else if (color.indexOf("(") !== -1) {
    // in bracket.
    var _a = splitBracket(color),
        prefix = _a.prefix,
        value = _a.value;

    if (!prefix || !value) {
      return undefined;
    }

    var arr = splitComma(value);
    var colorArr = [0, 0, 0, 1];
    var length = arr.length;

    switch (prefix) {
      case RGB:
      case RGBA:
        for (var i = 0; i < length; ++i) {
          colorArr[i] = parseFloat(arr[i]);
        }

        return colorArr;

      case HSL:
      case HSLA:
        for (var i = 0; i < length; ++i) {
          if (arr[i].indexOf("%") !== -1) {
            colorArr[i] = parseFloat(arr[i]) / 100;
          } else {
            colorArr[i] = parseFloat(arr[i]);
          }
        } // hsl, hsla to rgba


        return hslToRGBA(colorArr);
    }
  }

  return undefined;
}

/**
 * Returns all element descendants of node that
 * match selectors.
 */

/**
 * Checks if the specified class value exists in the element's class attribute.
 * @memberof DOM
 * @param - A DOMString containing one or more selectors to match
 * @param - If multi is true, a DOMString containing one or more selectors to match against.
 * @example
import {$} from "@daybrush/utils";

console.log($("div")); // div element
console.log($("div", true)); // [div, div] elements
*/

function $(selectors, multi) {
  return multi ? doc.querySelectorAll(selectors) : doc.querySelector(selectors);
}
/**
* Checks if the specified class value exists in the element's class attribute.
* @memberof DOM
* @param element - target
* @param className - the class name to search
* @return {boolean} return false if the class is not found.
* @example
import {hasClass} from "@daybrush/utils";

console.log(hasClass(element, "start")); // true or false
*/

function hasClass(element, className) {
  if (element.classList) {
    return element.classList.contains(className);
  }

  return !!element.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
}
/**
* Add the specified class value. If these classe already exist in the element's class attribute they are ignored.
* @memberof DOM
* @param element - target
* @param className - the class name to add
* @example
import {addClass} from "@daybrush/utils";

addClass(element, "start");
*/

function addClass(element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    element.className += " " + className;
  }
}
/**
* Removes the specified class value.
* @memberof DOM
* @param element - target
* @param className - the class name to remove
* @example
import {removeClass} from "@daybrush/utils";

removeClass(element, "start");
*/

function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
    element.className = element.className.replace(reg, " ");
  }
}
/**
* Gets the CSS properties from the element.
* @memberof DOM
* @param elements - elements
* @param properites - the CSS properties
* @return returns CSS properties and values.
* @example
import {fromCSS} from "@daybrush/utils";

console.log(fromCSS(element, ["left", "opacity", "top"])); // {"left": "10px", "opacity": 1, "top": "10px"}
*/

function fromCSS(elements, properties) {
  if (!elements || !properties || !properties.length) {
    return {};
  }

  var element;

  if (elements instanceof Element) {
    element = elements;
  } else if (elements.length) {
    element = elements[0];
  } else {
    return {};
  }

  var cssObject = {};
  var styles = window.getComputedStyle(element);
  var length = properties.length;

  for (var i = 0; i < length; ++i) {
    cssObject[properties[i]] = styles[properties[i]];
  }

  return cssObject;
}
/**
* Sets up a function that will be called whenever the specified event is delivered to the target
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs
* @param - An options object that specifies characteristics about the event listener.
* @example
import {addEvent} from "@daybrush/utils";

addEvent(el, "click", e => {
  console.log(e);
});
*/

function addEvent(el, type, listener, options) {
  el.addEventListener(type, listener, options);
}
/**
* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The EventListener function of the event handler to remove from the event target.
* @param - An options object that specifies characteristics about the event listener.
* @example
import {addEvent, removeEvent} from "@daybrush/utils";
const listener = e => {
  console.log(e);
};
addEvent(el, "click", listener);
removeEvent(el, "click", listener);
*/

function removeEvent(el, type, listener, options) {
  el.removeEventListener(type, listener, options);
}


//# sourceMappingURL=utils.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@daybrush-utils-npm-1.7.0-2985f74485-5ffaae9194.zip/node_modules/@daybrush/utils/dist/utils.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": () => (/* binding */ $),
/* harmony export */   "ANIMATION": () => (/* binding */ ANIMATION),
/* harmony export */   "ARRAY": () => (/* binding */ ARRAY),
/* harmony export */   "COLOR_MODELS": () => (/* binding */ COLOR_MODELS),
/* harmony export */   "DEFAULT_UNIT_PRESETS": () => (/* binding */ DEFAULT_UNIT_PRESETS),
/* harmony export */   "FILTER": () => (/* binding */ FILTER),
/* harmony export */   "FUNCTION": () => (/* binding */ FUNCTION),
/* harmony export */   "HSL": () => (/* binding */ HSL),
/* harmony export */   "HSLA": () => (/* binding */ HSLA),
/* harmony export */   "IS_WINDOW": () => (/* binding */ IS_WINDOW),
/* harmony export */   "KEYFRAMES": () => (/* binding */ KEYFRAMES),
/* harmony export */   "NUMBER": () => (/* binding */ NUMBER),
/* harmony export */   "OBJECT": () => (/* binding */ OBJECT),
/* harmony export */   "OPEN_CLOSED_CHARACTERS": () => (/* binding */ OPEN_CLOSED_CHARACTERS),
/* harmony export */   "PROPERTY": () => (/* binding */ PROPERTY),
/* harmony export */   "RGB": () => (/* binding */ RGB),
/* harmony export */   "RGBA": () => (/* binding */ RGBA),
/* harmony export */   "STRING": () => (/* binding */ STRING),
/* harmony export */   "TINY_NUM": () => (/* binding */ TINY_NUM),
/* harmony export */   "TRANSFORM": () => (/* binding */ TRANSFORM),
/* harmony export */   "UNDEFINED": () => (/* binding */ UNDEFINED),
/* harmony export */   "addClass": () => (/* binding */ addClass),
/* harmony export */   "addEvent": () => (/* binding */ addEvent),
/* harmony export */   "average": () => (/* binding */ average),
/* harmony export */   "between": () => (/* binding */ between),
/* harmony export */   "calculateBoundSize": () => (/* binding */ calculateBoundSize),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "cancelAnimationFrame": () => (/* binding */ cancelAnimationFrame),
/* harmony export */   "checkBoundSize": () => (/* binding */ checkBoundSize),
/* harmony export */   "convertUnitSize": () => (/* binding */ convertUnitSize),
/* harmony export */   "counter": () => (/* binding */ counter),
/* harmony export */   "cutHex": () => (/* binding */ cutHex),
/* harmony export */   "decamelize": () => (/* binding */ decamelize),
/* harmony export */   "document": () => (/* binding */ doc),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "findIndex": () => (/* binding */ findIndex),
/* harmony export */   "findLast": () => (/* binding */ findLast),
/* harmony export */   "findLastIndex": () => (/* binding */ findLastIndex),
/* harmony export */   "fromCSS": () => (/* binding */ fromCSS),
/* harmony export */   "getCenterPoint": () => (/* binding */ getCenterPoint),
/* harmony export */   "getCrossBrowserProperty": () => (/* binding */ getCrossBrowserProperty),
/* harmony export */   "getDist": () => (/* binding */ getDist),
/* harmony export */   "getKeys": () => (/* binding */ getKeys),
/* harmony export */   "getRad": () => (/* binding */ getRad),
/* harmony export */   "getShapeDirection": () => (/* binding */ getShapeDirection),
/* harmony export */   "hasClass": () => (/* binding */ hasClass),
/* harmony export */   "hexToRGBA": () => (/* binding */ hexToRGBA),
/* harmony export */   "hslToRGBA": () => (/* binding */ hslToRGBA),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined),
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "removeClass": () => (/* binding */ removeClass),
/* harmony export */   "removeEvent": () => (/* binding */ removeEvent),
/* harmony export */   "replaceOnce": () => (/* binding */ replaceOnce),
/* harmony export */   "requestAnimationFrame": () => (/* binding */ requestAnimationFrame),
/* harmony export */   "sortOrders": () => (/* binding */ sortOrders),
/* harmony export */   "splitBracket": () => (/* binding */ splitBracket),
/* harmony export */   "splitComma": () => (/* binding */ splitComma),
/* harmony export */   "splitSpace": () => (/* binding */ splitSpace),
/* harmony export */   "splitText": () => (/* binding */ splitText),
/* harmony export */   "splitUnit": () => (/* binding */ splitUnit),
/* harmony export */   "stringToRGBA": () => (/* binding */ stringToRGBA),
/* harmony export */   "sum": () => (/* binding */ sum),
/* harmony export */   "throttle": () => (/* binding */ throttle),
/* harmony export */   "throttleArray": () => (/* binding */ throttleArray),
/* harmony export */   "toArray": () => (/* binding */ toArray),
/* harmony export */   "toFullHex": () => (/* binding */ toFullHex)
/* harmony export */ });
/*
Copyright (c) 2018 Daybrush
@name: @daybrush/utils
license: MIT
author: Daybrush
repository: https://github.com/daybrush/utils
@version 1.7.0
*/
/**
* @namespace
* @name Consts
*/

/**
* get string "rgb"
* @memberof Color
* @example
import {RGB} from "@daybrush/utils";

console.log(RGB); // "rgb"
*/
var RGB = "rgb";
/**
* get string "rgba"
* @memberof Color
* @example
import {RGBA} from "@daybrush/utils";

console.log(RGBA); // "rgba"
*/

var RGBA = "rgba";
/**
* get string "hsl"
* @memberof Color
* @example
import {HSL} from "@daybrush/utils";

console.log(HSL); // "hsl"
*/

var HSL = "hsl";
/**
* get string "hsla"
* @memberof Color
* @example
import {HSLA} from "@daybrush/utils";

console.log(HSLA); // "hsla"
*/

var HSLA = "hsla";
/**
* gets an array of color models.
* @memberof Color
* @example
import {COLOR_MODELS} from "@daybrush/utils";

console.log(COLOR_MODELS); // ["rgb", "rgba", "hsl", "hsla"];
*/

var COLOR_MODELS = [RGB, RGBA, HSL, HSLA];
/**
* get string "function"
* @memberof Consts
* @example
import {FUNCTION} from "@daybrush/utils";

console.log(FUNCTION); // "function"
*/

var FUNCTION = "function";
/**
* get string "property"
* @memberof Consts
* @example
import {PROPERTY} from "@daybrush/utils";

console.log(PROPERTY); // "property"
*/

var PROPERTY = "property";
/**
* get string "array"
* @memberof Consts
* @example
import {ARRAY} from "@daybrush/utils";

console.log(ARRAY); // "array"
*/

var ARRAY = "array";
/**
* get string "object"
* @memberof Consts
* @example
import {OBJECT} from "@daybrush/utils";

console.log(OBJECT); // "object"
*/

var OBJECT = "object";
/**
* get string "string"
* @memberof Consts
* @example
import {STRING} from "@daybrush/utils";

console.log(STRING); // "string"
*/

var STRING = "string";
/**
* get string "number"
* @memberof Consts
* @example
import {NUMBER} from "@daybrush/utils";

console.log(NUMBER); // "number"
*/

var NUMBER = "number";
/**
* get string "undefined"
* @memberof Consts
* @example
import {UNDEFINED} from "@daybrush/utils";

console.log(UNDEFINED); // "undefined"
*/

var UNDEFINED = "undefined";
/**
* Check whether the environment is window or node.js.
* @memberof Consts
* @example
import {IS_WINDOW} from "@daybrush/utils";

console.log(IS_WINDOW); // false in node.js
console.log(IS_WINDOW); // true in browser
*/

var IS_WINDOW = typeof window !== UNDEFINED;
/**
* Check whether the environment is window or node.js.
* @memberof Consts
* @name document
* @example
import {IS_WINDOW} from "@daybrush/utils";

console.log(IS_WINDOW); // false in node.js
console.log(IS_WINDOW); // true in browser
*/

var doc = typeof document !== UNDEFINED && document; // FIXME: this type maybe false
var prefixes = ["webkit", "ms", "moz", "o"];
/**
 * @namespace CrossBrowser
 */

/**
* Get a CSS property with a vendor prefix that supports cross browser.
* @function
* @param {string} property - A CSS property
* @return {string} CSS property with cross-browser vendor prefix
* @memberof CrossBrowser
* @example
import {getCrossBrowserProperty} from "@daybrush/utils";

console.log(getCrossBrowserProperty("transform")); // "transform", "-ms-transform", "-webkit-transform"
console.log(getCrossBrowserProperty("filter")); // "filter", "-webkit-filter"
*/

var getCrossBrowserProperty = /*#__PURE__*/function (property) {
  if (!doc) {
    return "";
  }

  var styles = (doc.body || doc.documentElement).style;
  var length = prefixes.length;

  if (typeof styles[property] !== UNDEFINED) {
    return property;
  }

  for (var i = 0; i < length; ++i) {
    var name = "-" + prefixes[i] + "-" + property;

    if (typeof styles[name] !== UNDEFINED) {
      return name;
    }
  }

  return "";
};
/**
* get string "transfrom" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {TRANSFORM} from "@daybrush/utils";

console.log(TRANSFORM); // "transform", "-ms-transform", "-webkit-transform"
*/

var TRANSFORM = /*#__PURE__*/getCrossBrowserProperty("transform");
/**
* get string "filter" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {FILTER} from "@daybrush/utils";

console.log(FILTER); // "filter", "-ms-filter", "-webkit-filter"
*/

var FILTER = /*#__PURE__*/getCrossBrowserProperty("filter");
/**
* get string "animation" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {ANIMATION} from "@daybrush/utils";

console.log(ANIMATION); // "animation", "-ms-animation", "-webkit-animation"
*/

var ANIMATION = /*#__PURE__*/getCrossBrowserProperty("animation");
/**
* get string "keyframes" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {KEYFRAMES} from "@daybrush/utils";

console.log(KEYFRAMES); // "keyframes", "-ms-keyframes", "-webkit-keyframes"
*/

var KEYFRAMES = /*#__PURE__*/ANIMATION.replace("animation", "keyframes");
var OPEN_CLOSED_CHARACTERS = [{
  open: "(",
  close: ")"
}, {
  open: "\"",
  close: "\""
}, {
  open: "'",
  close: "'"
}, {
  open: "\\\"",
  close: "\\\""
}, {
  open: "\\'",
  close: "\\'"
}];
var TINY_NUM = 0.0000001;
var DEFAULT_UNIT_PRESETS = {
  "cm": function (pos) {
    return pos * 96 / 2.54;
  },
  "mm": function (pos) {
    return pos * 96 / 254;
  },
  "in": function (pos) {
    return pos * 96;
  },
  "pt": function (pos) {
    return pos * 96 / 72;
  },
  "pc": function (pos) {
    return pos * 96 / 6;
  },
  "%": function (pos, size) {
    return pos * size / 100;
  },
  "vw": function (pos, size) {
    if (size === void 0) {
      size = window.innerWidth;
    }

    return pos / 100 * size;
  },
  "vh": function (pos, size) {
    if (size === void 0) {
      size = window.innerHeight;
    }

    return pos / 100 * size;
  },
  "vmax": function (pos, size) {
    if (size === void 0) {
      size = Math.max(window.innerWidth, window.innerHeight);
    }

    return pos / 100 * size;
  },
  "vmin": function (pos, size) {
    if (size === void 0) {
      size = Math.min(window.innerWidth, window.innerHeight);
    }

    return pos / 100 * size;
  }
};

/**
* @namespace
* @name Utils
*/

/**
 * Returns the inner product of two numbers(`a1`, `a2`) by two criteria(`b1`, `b2`).
 * @memberof Utils
 * @param - The first number
 * @param - The second number
 * @param - The first number to base on the inner product
 * @param - The second number to base on the inner product
 * @return - Returns the inner product
import { dot } from "@daybrush/utils";

console.log(dot(0, 15, 2, 3)); // 6
console.log(dot(5, 15, 2, 3)); // 9
console.log(dot(5, 15, 1, 1)); // 10
 */

function dot(a1, a2, b1, b2) {
  return (a1 * b2 + a2 * b1) / (b1 + b2);
}
/**
* Check the type that the value is undefined.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {boolean} true if the type is correct, false otherwise
* @example
import {isUndefined} from "@daybrush/utils";

console.log(isUndefined(undefined)); // true
console.log(isUndefined("")); // false
console.log(isUndefined(1)); // false
console.log(isUndefined(null)); // false
*/

function isUndefined(value) {
  return typeof value === UNDEFINED;
}
/**
* Check the type that the value is object.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isObject} from "@daybrush/utils";

console.log(isObject({})); // true
console.log(isObject(undefined)); // false
console.log(isObject("")); // false
console.log(isObject(null)); // false
*/

function isObject(value) {
  return value && typeof value === OBJECT;
}
/**
* Check the type that the value is isArray.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isArray} from "@daybrush/utils";

console.log(isArray([])); // true
console.log(isArray({})); // false
console.log(isArray(undefined)); // false
console.log(isArray(null)); // false
*/

function isArray(value) {
  return Array.isArray(value);
}
/**
* Check the type that the value is string.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isString} from "@daybrush/utils";

console.log(isString("1234")); // true
console.log(isString(undefined)); // false
console.log(isString(1)); // false
console.log(isString(null)); // false
*/

function isString(value) {
  return typeof value === STRING;
}
function isNumber(value) {
  return typeof value === NUMBER;
}
/**
* Check the type that the value is function.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isFunction} from "@daybrush/utils";

console.log(isFunction(function a() {})); // true
console.log(isFunction(() => {})); // true
console.log(isFunction("1234")); // false
console.log(isFunction(1)); // false
console.log(isFunction(null)); // false
*/

function isFunction(value) {
  return typeof value === FUNCTION;
}

function isEqualSeparator(character, separator) {
  var isCharacterSpace = character === "" || character == " ";
  var isSeparatorSpace = separator === "" || separator == " ";
  return isSeparatorSpace && isCharacterSpace || character === separator;
}

function findOpen(openCharacter, texts, index, length, openCloseCharacters) {
  var isIgnore = findIgnore(openCharacter, texts, index);

  if (!isIgnore) {
    return findClose(openCharacter, texts, index + 1, length, openCloseCharacters);
  }

  return index;
}

function findIgnore(character, texts, index) {
  if (!character.ignore) {
    return null;
  }

  var otherText = texts.slice(Math.max(index - 3, 0), index + 3).join("");
  return new RegExp(character.ignore).exec(otherText);
}

function findClose(closeCharacter, texts, index, length, openCloseCharacters) {
  var _loop_1 = function (i) {
    var character = texts[i].trim();

    if (character === closeCharacter.close && !findIgnore(closeCharacter, texts, i)) {
      return {
        value: i
      };
    }

    var nextIndex = i; // re open

    var openCharacter = find(openCloseCharacters, function (_a) {
      var open = _a.open;
      return open === character;
    });

    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);
    }

    if (nextIndex === -1) {
      return out_i_1 = i, "break";
    }

    i = nextIndex;
    out_i_1 = i;
  };

  var out_i_1;

  for (var i = index; i < length; ++i) {
    var state_1 = _loop_1(i);

    i = out_i_1;
    if (typeof state_1 === "object") return state_1.value;
    if (state_1 === "break") break;
  }

  return -1;
}

function splitText(text, splitOptions) {
  var _a = isString(splitOptions) ? {
    separator: splitOptions
  } : splitOptions,
      _b = _a.separator,
      separator = _b === void 0 ? "," : _b,
      isSeparateFirst = _a.isSeparateFirst,
      isSeparateOnlyOpenClose = _a.isSeparateOnlyOpenClose,
      _c = _a.isSeparateOpenClose,
      isSeparateOpenClose = _c === void 0 ? isSeparateOnlyOpenClose : _c,
      _d = _a.openCloseCharacters,
      openCloseCharacters = _d === void 0 ? OPEN_CLOSED_CHARACTERS : _d;

  var openClosedText = openCloseCharacters.map(function (_a) {
    var open = _a.open,
        close = _a.close;

    if (open === close) {
      return open;
    }

    return open + "|" + close;
  }).join("|");
  var regexText = "(\\s*" + separator + "\\s*|" + openClosedText + "|\\s+)";
  var regex = new RegExp(regexText, "g");
  var texts = text.split(regex).filter(Boolean);
  var length = texts.length;
  var values = [];
  var tempValues = [];

  function resetTemp() {
    if (tempValues.length) {
      values.push(tempValues.join(""));
      tempValues = [];
      return true;
    }

    return false;
  }

  var _loop_2 = function (i) {
    var character = texts[i].trim();
    var nextIndex = i;
    var openCharacter = find(openCloseCharacters, function (_a) {
      var open = _a.open;
      return open === character;
    });
    var closeCharacter = find(openCloseCharacters, function (_a) {
      var close = _a.close;
      return close === character;
    });

    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);

      if (nextIndex !== -1 && isSeparateOpenClose) {
        if (resetTemp() && isSeparateFirst) {
          return out_i_2 = i, "break";
        }

        values.push(texts.slice(i, nextIndex + 1).join(""));
        i = nextIndex;

        if (isSeparateFirst) {
          return out_i_2 = i, "break";
        }

        return out_i_2 = i, "continue";
      }
    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i)) {
      throw new Error("invalid format: " + closeCharacter.close);
    } else if (isEqualSeparator(character, separator) && !isSeparateOnlyOpenClose) {
      resetTemp();

      if (isSeparateFirst) {
        return out_i_2 = i, "break";
      }

      return out_i_2 = i, "continue";
    }

    if (nextIndex === -1) {
      nextIndex = length - 1;
    }

    tempValues.push(texts.slice(i, nextIndex + 1).join(""));
    i = nextIndex;
    out_i_2 = i;
  };

  var out_i_2;

  for (var i = 0; i < length; ++i) {
    var state_2 = _loop_2(i);

    i = out_i_2;
    if (state_2 === "break") break;
  }

  if (tempValues.length) {
    values.push(tempValues.join(""));
  }

  return values;
}
/**
* divide text by space.
* @memberof Utils
* @param {string} text - text to divide
* @return {Array} divided texts
* @example
import {spliceSpace} from "@daybrush/utils";

console.log(splitSpace("a b c d e f g"));
// ["a", "b", "c", "d", "e", "f", "g"]
console.log(splitSpace("'a,b' c 'd,e' f g"));
// ["'a,b'", "c", "'d,e'", "f", "g"]
*/

function splitSpace(text) {
  // divide comma(space)
  return splitText(text, "");
}
/**
* divide text by comma.
* @memberof Utils
* @param {string} text - text to divide
* @return {Array} divided texts
* @example
import {splitComma} from "@daybrush/utils";

console.log(splitComma("a,b,c,d,e,f,g"));
// ["a", "b", "c", "d", "e", "f", "g"]
console.log(splitComma("'a,b',c,'d,e',f,g"));
// ["'a,b'", "c", "'d,e'", "f", "g"]
*/

function splitComma(text) {
  // divide comma(,)
  // "[^"]*"|'[^']*'
  return splitText(text, ",");
}
/**
* divide text by bracket "(", ")".
* @memberof Utils
* @param {string} text - text to divide
* @return {object} divided texts
* @example
import {splitBracket} from "@daybrush/utils";

console.log(splitBracket("a(1, 2)"));
// {prefix: "a", value: "1, 2", suffix: ""}
console.log(splitBracket("a(1, 2)b"));
// {prefix: "a", value: "1, 2", suffix: "b"}
*/

function splitBracket(text) {
  var matches = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(text);

  if (!matches || matches.length < 4) {
    return {};
  } else {
    return {
      prefix: matches[1],
      value: matches[2],
      suffix: matches[3]
    };
  }
}
/**
* divide text by number and unit.
* @memberof Utils
* @param {string} text - text to divide
* @return {} divided texts
* @example
import {splitUnit} from "@daybrush/utils";

console.log(splitUnit("10px"));
// {prefix: "", value: 10, unit: "px"}
console.log(splitUnit("-10px"));
// {prefix: "", value: -10, unit: "px"}
console.log(splitUnit("a10%"));
// {prefix: "a", value: 10, unit: "%"}
*/

function splitUnit(text) {
  var matches = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(text);

  if (!matches) {
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  }

  var prefix = matches[1];
  var value = matches[2];
  var unit = matches[3];
  return {
    prefix: prefix,
    unit: unit,
    value: parseFloat(value)
  };
}
/**
* transform strings to camel-case
* @memberof Utils
* @param {String} text - string
* @return {String} camel-case string
* @example
import {camelize} from "@daybrush/utils";

console.log(camelize("transform-origin")); // transformOrigin
console.log(camelize("abcd_efg")); // abcdEfg
console.log(camelize("abcd efg")); // abcdEfg
*/

function camelize(str) {
  return str.replace(/[\s-_]([a-z])/g, function (all, letter) {
    return letter.toUpperCase();
  });
}
/**
* transform a camelized string into a lowercased string.
* @memberof Utils
* @param {string} text - a camel-cased string
* @param {string} [separator="-"] - a separator
* @return {string}  a lowercased string
* @example
import {decamelize} from "@daybrush/utils";

console.log(decamelize("transformOrigin")); // transform-origin
console.log(decamelize("abcdEfg", "_")); // abcd_efg
*/

function decamelize(str, separator) {
  if (separator === void 0) {
    separator = "-";
  }

  return str.replace(/([a-z])([A-Z])/g, function (all, letter, letter2) {
    return "" + letter + separator + letter2.toLowerCase();
  });
}
/**
* transforms something in an array into an array.
* @memberof Utils
* @param - Array form
* @return an array
* @example
import {toArray} from "@daybrush/utils";

const arr1 = toArray(document.querySelectorAll(".a")); // Element[]
const arr2 = toArray(document.querySelectorAll<HTMLElement>(".a")); // HTMLElement[]
*/

function toArray(value) {
  return [].slice.call(value);
}
/**
* Date.now() method
* @memberof CrossBrowser
* @return {number} milliseconds
* @example
import {now} from "@daybrush/utils";

console.log(now()); // 12121324241(milliseconds)
*/

function now() {
  return Date.now ? Date.now() : new Date().getTime();
}
/**
* Returns the index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findIndex } from "@daybrush/utils";

findIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Returns the reverse direction index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findLastIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findLastIndex } from "@daybrush/utils";

findLastIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findLastIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = length - 1; i >= 0; --i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Returns the value of the reverse direction element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findLast` was called upon.
* @param - A function to execute on each value in the array,
* @param - Returns defalutValue if not found by the function.
* @example
import { find } from "@daybrush/utils";

find([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}
*/

function findLast(arr, callback, defalutValue) {
  var index = findLastIndex(arr, callback);
  return index > -1 ? arr[index] : defalutValue;
}
/**
* Returns the value of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `find` was called upon.
* @param - A function to execute on each value in the array,
* @param - Returns defalutValue if not found by the function.
* @example
import { find } from "@daybrush/utils";

find([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}
*/

function find(arr, callback, defalutValue) {
  var index = findIndex(arr, callback);
  return index > -1 ? arr[index] : defalutValue;
}
/**
* window.requestAnimationFrame() method with cross browser.
* @function
* @memberof CrossBrowser
* @param {FrameRequestCallback} callback - The function to call when it's time to update your animation for the next repaint.
* @return {number} id
* @example
import {requestAnimationFrame} from "@daybrush/utils";

requestAnimationFrame((timestamp) => {
  console.log(timestamp);
});
*/

var requestAnimationFrame = /*#__PURE__*/function () {
  var firstTime = now();
  var raf = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return raf ? raf.bind(window) : function (callback) {
    var currTime = now();
    var id = window.setTimeout(function () {
      callback(currTime - firstTime);
    }, 1000 / 60);
    return id;
  };
}();
/**
* window.cancelAnimationFrame() method with cross browser.
* @function
* @memberof CrossBrowser
* @param {number} handle - the id obtained through requestAnimationFrame method
* @return {void}
* @example
import { requestAnimationFrame, cancelAnimationFrame } from "@daybrush/utils";

const id = requestAnimationFrame((timestamp) => {
  console.log(timestamp);
});

cancelAnimationFrame(id);
*/

var cancelAnimationFrame = /*#__PURE__*/function () {
  var caf = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return caf ? caf.bind(window) : function (handle) {
    clearTimeout(handle);
  };
}();
/**
* @function
* @memberof Utils
*/

function getKeys(obj) {
  if (Object.keys) {
    return Object.keys(obj);
  }

  var keys = [];

  for (var name in keys) {
    keys.push(name);
  }

  return keys;
}
/**
* @function
* @memberof Utils
*/

function sortOrders(keys, orders) {
  if (orders === void 0) {
    orders = [];
  }

  keys.sort(function (a, b) {
    var index1 = orders.indexOf(a);
    var index2 = orders.indexOf(b);

    if (index2 === -1 && index1 === -1) {
      return 0;
    }

    if (index1 === -1) {
      return 1;
    }

    if (index2 === -1) {
      return -1;
    }

    return index1 - index2;
  });
}
/**
* convert unit size to px size
* @function
* @memberof Utils
*/

function convertUnitSize(pos, size) {
  var _a = splitUnit(pos),
      value = _a.value,
      unit = _a.unit;

  if (isObject(size)) {
    var sizeFunction = size[unit];

    if (sizeFunction) {
      if (isFunction(sizeFunction)) {
        return sizeFunction(value);
      } else if (DEFAULT_UNIT_PRESETS[unit]) {
        return DEFAULT_UNIT_PRESETS[unit](value, sizeFunction);
      }
    }
  } else if (unit === "%") {
    return value * size / 100;
  }

  if (DEFAULT_UNIT_PRESETS[unit]) {
    return DEFAULT_UNIT_PRESETS[unit](value);
  }

  return value;
}
/**
* calculate between min, max
* @function
* @memberof Utils
*/

function between(value, min, max) {
  return Math.max(min, Math.min(value, max));
}
function checkBoundSize(targetSize, compareSize, isMax, ratio) {
  if (ratio === void 0) {
    ratio = targetSize[0] / targetSize[1];
  }

  return [[throttle(compareSize[0], TINY_NUM), throttle(compareSize[0] / ratio, TINY_NUM)], [throttle(compareSize[1] * ratio, TINY_NUM), throttle(compareSize[1], TINY_NUM)]].filter(function (size) {
    return size.every(function (value, i) {
      return isMax ? value <= compareSize[i] : value >= compareSize[i];
    });
  })[0] || targetSize;
}
/**
* calculate bound size
* @function
* @memberof Utils
*/

function calculateBoundSize(size, minSize, maxSize, keepRatio) {
  if (!keepRatio) {
    return size.map(function (value, i) {
      return between(value, minSize[i], maxSize[i]);
    });
  }

  var width = size[0],
      height = size[1];
  var ratio = keepRatio === true ? width / height : keepRatio; // width : height = minWidth : minHeight;

  var _a = checkBoundSize(size, minSize, false, ratio),
      minWidth = _a[0],
      minHeight = _a[1];

  var _b = checkBoundSize(size, maxSize, true, ratio),
      maxWidth = _b[0],
      maxHeight = _b[1];

  if (width < minWidth || height < minHeight) {
    width = minWidth;
    height = minHeight;
  } else if (width > maxWidth || height > maxHeight) {
    width = maxWidth;
    height = maxHeight;
  }

  return [width, height];
}
/**
* Add all the numbers.
* @function
* @memberof Utils
*/

function sum(nums) {
  var length = nums.length;
  var total = 0;

  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }

  return total;
}
/**
* Average all numbers.
* @function
* @memberof Utils
*/

function average(nums) {
  var length = nums.length;
  var total = 0;

  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }

  return length ? total / length : 0;
}
/**
* Get the angle of two points. (0 <= rad < 359)
* @function
* @memberof Utils
*/

function getRad(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
/**
* Get the average point of all points.
* @function
* @memberof Utils
*/

function getCenterPoint(points) {
  return [0, 1].map(function (i) {
    return average(points.map(function (pos) {
      return pos[i];
    }));
  });
}
/**
* Gets the direction of the shape.
* @function
* @memberof Utils
*/

function getShapeDirection(points) {
  var center = getCenterPoint(points);
  var pos1Rad = getRad(center, points[0]);
  var pos2Rad = getRad(center, points[1]);
  return pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;
}
/**
* Get the distance between two points.
* @function
* @memberof Utils
*/

function getDist(a, b) {
  return Math.sqrt(Math.pow((b ? b[0] : 0) - a[0], 2) + Math.pow((b ? b[1] : 0) - a[1], 2));
}
/**
* throttle number depending on the unit.
* @function
* @memberof Utils
*/

function throttle(num, unit) {
  if (!unit) {
    return num;
  }

  return Math.round(num / unit) * unit;
}
/**
* throttle number array depending on the unit.
* @function
* @memberof Utils
*/

function throttleArray(nums, unit) {
  nums.forEach(function (_, i) {
    nums[i] = throttle(nums[i], unit);
  });
  return nums;
}
/**
* @function
* @memberof Utils
*/

function counter(num) {
  var nums = [];

  for (var i = 0; i < num; ++i) {
    nums.push(i);
  }

  return nums;
}
/**
* @function
* @memberof Utils
*/

function replaceOnce(text, fromText, toText) {
  var isOnce = false;
  return text.replace(fromText, function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    if (isOnce) {
      return args[0];
    }

    isOnce = true;
    return isString(toText) ? toText : toText.apply(void 0, args);
  });
}

/**
* @namespace
* @name Color
*/

/**
* Remove the # from the hex color.
* @memberof Color
* @param {} hex - hex color
* @return {} hex color
* @example
import {cutHex} from "@daybrush/utils";

console.log(cutHex("#000000")) // "000000"
*/

function cutHex(hex) {
  return hex.replace("#", "");
}
/**
* convert hex color to rgb color.
* @memberof Color
* @param {} hex - hex color
* @return {} rgb color
* @example
import {hexToRGBA} from "@daybrush/utils";

console.log(hexToRGBA("#00000005"));
// [0, 0, 0, 1]
console.log(hexToRGBA("#201045"));
// [32, 16, 69, 1]
*/

function hexToRGBA(hex) {
  var h = cutHex(hex);
  var r = parseInt(h.substring(0, 2), 16);
  var g = parseInt(h.substring(2, 4), 16);
  var b = parseInt(h.substring(4, 6), 16);
  var a = parseInt(h.substring(6, 8), 16) / 255;

  if (isNaN(a)) {
    a = 1;
  }

  return [r, g, b, a];
}
/**
* convert 3(or 4)-digit hex color to 6(or 8)-digit hex color.
* @memberof Color
* @param {} hex - 3(or 4)-digit hex color
* @return {} 6(or 8)-digit hex color
* @example
import {toFullHex} from "@daybrush/utils";

console.log(toFullHex("#123")); // "#112233"
console.log(toFullHex("#123a")); // "#112233aa"
*/

function toFullHex(h) {
  var r = h.charAt(1);
  var g = h.charAt(2);
  var b = h.charAt(3);
  var a = h.charAt(4);
  var arr = ["#", r, r, g, g, b, b, a, a];
  return arr.join("");
}
/**
* convert hsl color to rgba color.
* @memberof Color
* @param {} hsl - hsl color(hue: 0 ~ 360, saturation: 0 ~ 1, lightness: 0 ~ 1, alpha: 0 ~ 1)
* @return {} rgba color
* @example
import {hslToRGBA} from "@daybrush/utils";

console.log(hslToRGBA([150, 0.5, 0.4]));
// [51, 153, 102, 1]
*/

function hslToRGBA(hsl) {
  var _a;

  var h = hsl[0];
  var s = hsl[1];
  var l = hsl[2];

  if (h < 0) {
    h += Math.floor((Math.abs(h) + 360) / 360) * 360;
  }

  h %= 360;
  var c = (1 - Math.abs(2 * l - 1)) * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = l - c / 2;
  var rgb;

  if (h < 60) {
    rgb = [c, x, 0];
  } else if (h < 120) {
    rgb = [x, c, 0];
  } else if (h < 180) {
    rgb = [0, c, x];
  } else if (h < 240) {
    rgb = [0, x, c];
  } else if (h < 300) {
    rgb = [x, 0, c];
  } else if (h < 360) {
    rgb = [c, 0, x];
  } else {
    rgb = [0, 0, 0];
  }

  return [Math.round((rgb[0] + m) * 255), Math.round((rgb[1] + m) * 255), Math.round((rgb[2] + m) * 255), (_a = hsl[3]) !== null && _a !== void 0 ? _a : 1];
}
/**
* convert string to rgba color.
* @memberof Color
* @param {} - 3-hex(#000), 4-hex(#0000) 6-hex(#000000), 8-hex(#00000000) or RGB(A), or HSL(A)
* @return {} rgba color
* @example
import {stringToRGBA} from "@daybrush/utils";

console.log(stringToRGBA("#000000")); // [0, 0, 0, 1]
console.log(stringToRGBA("rgb(100, 100, 100)")); // [100, 100, 100, 1]
console.log(stringToRGBA("hsl(150, 0.5, 0.4)")); // [51, 153, 102, 1]
*/

function stringToRGBA(color) {
  if (color.charAt(0) === "#") {
    if (color.length === 4 || color.length === 5) {
      return hexToRGBA(toFullHex(color));
    } else {
      return hexToRGBA(color);
    }
  } else if (color.indexOf("(") !== -1) {
    // in bracket.
    var _a = splitBracket(color),
        prefix = _a.prefix,
        value = _a.value;

    if (!prefix || !value) {
      return undefined;
    }

    var arr = splitComma(value);
    var colorArr = [0, 0, 0, 1];
    var length = arr.length;

    switch (prefix) {
      case RGB:
      case RGBA:
        for (var i = 0; i < length; ++i) {
          colorArr[i] = parseFloat(arr[i]);
        }

        return colorArr;

      case HSL:
      case HSLA:
        for (var i = 0; i < length; ++i) {
          if (arr[i].indexOf("%") !== -1) {
            colorArr[i] = parseFloat(arr[i]) / 100;
          } else {
            colorArr[i] = parseFloat(arr[i]);
          }
        } // hsl, hsla to rgba


        return hslToRGBA(colorArr);
    }
  }

  return undefined;
}

/**
 * Returns all element descendants of node that
 * match selectors.
 */

/**
 * Checks if the specified class value exists in the element's class attribute.
 * @memberof DOM
 * @param - A DOMString containing one or more selectors to match
 * @param - If multi is true, a DOMString containing one or more selectors to match against.
 * @example
import {$} from "@daybrush/utils";

console.log($("div")); // div element
console.log($("div", true)); // [div, div] elements
*/

function $(selectors, multi) {
  return multi ? doc.querySelectorAll(selectors) : doc.querySelector(selectors);
}
/**
* Checks if the specified class value exists in the element's class attribute.
* @memberof DOM
* @param element - target
* @param className - the class name to search
* @return {boolean} return false if the class is not found.
* @example
import {hasClass} from "@daybrush/utils";

console.log(hasClass(element, "start")); // true or false
*/

function hasClass(element, className) {
  if (element.classList) {
    return element.classList.contains(className);
  }

  return !!element.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
}
/**
* Add the specified class value. If these classe already exist in the element's class attribute they are ignored.
* @memberof DOM
* @param element - target
* @param className - the class name to add
* @example
import {addClass} from "@daybrush/utils";

addClass(element, "start");
*/

function addClass(element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    element.className += " " + className;
  }
}
/**
* Removes the specified class value.
* @memberof DOM
* @param element - target
* @param className - the class name to remove
* @example
import {removeClass} from "@daybrush/utils";

removeClass(element, "start");
*/

function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
    element.className = element.className.replace(reg, " ");
  }
}
/**
* Gets the CSS properties from the element.
* @memberof DOM
* @param elements - elements
* @param properites - the CSS properties
* @return returns CSS properties and values.
* @example
import {fromCSS} from "@daybrush/utils";

console.log(fromCSS(element, ["left", "opacity", "top"])); // {"left": "10px", "opacity": 1, "top": "10px"}
*/

function fromCSS(elements, properties) {
  if (!elements || !properties || !properties.length) {
    return {};
  }

  var element;

  if (elements instanceof Element) {
    element = elements;
  } else if (elements.length) {
    element = elements[0];
  } else {
    return {};
  }

  var cssObject = {};
  var styles = window.getComputedStyle(element);
  var length = properties.length;

  for (var i = 0; i < length; ++i) {
    cssObject[properties[i]] = styles[properties[i]];
  }

  return cssObject;
}
/**
* Sets up a function that will be called whenever the specified event is delivered to the target
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs
* @param - An options object that specifies characteristics about the event listener.
* @example
import {addEvent} from "@daybrush/utils";

addEvent(el, "click", e => {
  console.log(e);
});
*/

function addEvent(el, type, listener, options) {
  el.addEventListener(type, listener, options);
}
/**
* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The EventListener function of the event handler to remove from the event target.
* @param - An options object that specifies characteristics about the event listener.
* @example
import {addEvent, removeEvent} from "@daybrush/utils";
const listener = e => {
  console.log(e);
};
addEvent(el, "click", listener);
removeEvent(el, "click", listener);
*/

function removeEvent(el, type, listener, options) {
  el.removeEventListener(type, listener, options);
}


//# sourceMappingURL=utils.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@egjs-agent-npm-2.3.0-e88ca0eec2-2506e8feff.zip/node_modules/@egjs/agent/dist/agent.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getAccurateAgent": () => (/* binding */ getAccurateAgent)
/* harmony export */ });
/*
Copyright (c) 2015 NAVER Corp.
name: @egjs/agent
license: MIT
author: NAVER Corp.
repository: git+https://github.com/naver/agent.git
version: 2.3.0
*/
function some(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return true;
    }
  }

  return false;
}
function find(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return arr[i];
    }
  }

  return null;
}
function getUserAgent(agent) {
  var userAgent = agent;

  if (typeof userAgent === "undefined") {
    if (typeof navigator === "undefined" || !navigator) {
      return "";
    }

    userAgent = navigator.userAgent || "";
  }

  return userAgent.toLowerCase();
}
function execRegExp(pattern, text) {
  try {
    return new RegExp(pattern, "g").exec(text);
  } catch (e) {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator === "undefined" || !navigator || !navigator.userAgentData) {
    return false;
  }

  var userAgentData = navigator.userAgentData;
  var brands = userAgentData.brands || userAgentData.uaList;
  return !!(brands && brands.length);
}
function findVersion(versionTest, userAgent) {
  var result = execRegExp("(" + versionTest + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", userAgent);
  return result ? result[3] : "";
}
function convertVersion(text) {
  return text.replace(/_/g, ".");
}
function findPreset(presets, userAgent) {
  var userPreset = null;
  var version = "-1";
  some(presets, function (preset) {
    var result = execRegExp("(" + preset.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", userAgent);

    if (!result || preset.brand) {
      return false;
    }

    userPreset = preset;
    version = result[3] || "-1";

    if (preset.versionAlias) {
      version = preset.versionAlias;
    } else if (preset.versionTest) {
      version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;
    }

    version = convertVersion(version);
    return true;
  });
  return {
    preset: userPreset,
    version: version
  };
}
function findPresetBrand(presets, brands) {
  var brandInfo = {
    brand: "",
    version: "-1"
  };
  some(presets, function (preset) {
    var result = findBrand(brands, preset);

    if (!result) {
      return false;
    }

    brandInfo.brand = preset.id;
    brandInfo.version = preset.versionAlias || result.version;
    return brandInfo.version !== "-1";
  });
  return brandInfo;
}
function findBrand(brands, preset) {
  return find(brands, function (_a) {
    var brand = _a.brand;
    return execRegExp("" + preset.test, brand.toLowerCase());
  });
}

var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}]; // chromium's engine(blink) is based on applewebkit 537.36.

var CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: true
}];
var WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}];
var WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}];
var OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "mac os x",
  id: "mac"
}, {
  test: "android",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];

function parseUserAgentData(osData) {
  var userAgentData = navigator.userAgentData;
  var brands = (userAgentData.uaList || userAgentData.brands).slice();
  var isMobile = userAgentData.mobile || false;
  var firstBrand = brands[0];
  var browser = {
    name: firstBrand.brand,
    version: firstBrand.version,
    majorVersion: -1,
    webkit: false,
    webkitVersion: "-1",
    chromium: false,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function (preset) {
    return findBrand(brands, preset);
  });
  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);
  browser.chromium = !!chromiumBrand.brand;
  browser.chromiumVersion = chromiumBrand.version;

  if (!browser.chromium) {
    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);
    browser.webkit = !!webkitBrand.brand;
    browser.webkitVersion = webkitBrand.version;
  }

  if (osData) {
    var platform_1 = osData.platform.toLowerCase();
    var result = find(OS_PRESETS, function (preset) {
      return new RegExp("" + preset.test, "g").exec(platform_1);
    });
    os.name = result ? result.id : platform_1;
    os.version = osData.platformVersion;
  }

  var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);

  if (browserBrand.brand) {
    browser.name = browserBrand.brand;
    browser.version = osData ? osData.uaFullVersion : browserBrand.version;
  }

  if (navigator.platform === "Linux armv8l") {
    os.name = "android";
  } else if (browser.webkit) {
    os.name = isMobile ? "ios" : "mac";
  }

  if (os.name === "ios" && browser.webview) {
    browser.version = "-1";
  }

  os.version = convertVersion(os.version);
  browser.version = convertVersion(browser.version);
  os.majorVersion = parseInt(os.version, 10);
  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: true
  };
}

function parseUserAgent(userAgent) {
  var nextAgent = getUserAgent(userAgent);
  var isMobile = !!/mobi/g.exec(nextAgent);
  var browser = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: !!findPreset(WEBVIEW_PRESETS, nextAgent).preset,
    chromium: false,
    chromiumVersion: "-1",
    webkit: false,
    webkitVersion: "-1"
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };

  var _a = findPreset(BROWSER_PRESETS, nextAgent),
      browserPreset = _a.preset,
      browserVersion = _a.version;

  var _b = findPreset(OS_PRESETS, nextAgent),
      osPreset = _b.preset,
      osVersion = _b.version;

  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);
  browser.chromium = !!chromiumPreset.preset;
  browser.chromiumVersion = chromiumPreset.version;

  if (!browser.chromium) {
    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);
    browser.webkit = !!webkitPreset.preset;
    browser.webkitVersion = webkitPreset.version;
  }

  if (osPreset) {
    os.name = osPreset.id;
    os.version = osVersion;
    os.majorVersion = parseInt(osVersion, 10);
  }

  if (browserPreset) {
    browser.name = browserPreset.id;
    browser.version = browserVersion;

    if (browser.webview && os.name === "ios" && browser.name !== "safari") {
      browser.webview = false;
    }
  }

  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: false
  };
}

/**
 * @namespace eg.agent
 */

/**
* Extracts accuate browser and operating system information from the user agent string or client hints.
* @ko     client hints     .
* @function eg.agent#getAccurateAgent
* @param - Callback function to get the accuate agent <ko>    callback </ko>
* @return - get the accuate agent promise. If Promise are not supported, null is returned. <ko>   promise . Promise    , null . </ko>
* @example
import { getAccurateAgent } from "@egjs/agent";
// eg.agent.getAccurateAgent()
getAccurateAgent().then(agent => {
   const { os, browser, isMobile } = agent;
});
getAccurateAgent(agent => {
    const { os, browser, isMobile } = agent;
});
*/

function getAccurateAgent(callback) {
  if (hasUserAgentData()) {
    return navigator.userAgentData.getHighEntropyValues(["architecture", "model", "platform", "platformVersion", "uaFullVersion"]).then(function (info) {
      var agentInfo = parseUserAgentData(info);
      callback && callback(agentInfo);
      return agentInfo;
    });
  }

  callback && callback(agent());

  if (typeof Promise === "undefined" || !Promise) {
    return null;
  }

  return Promise.resolve(agent());
}
/**
 * Extracts browser and operating system information from the user agent string.
 * @ko       .
 * @function eg.agent#agent
 * @param - user agent string to parse <ko>  </ko>
 * @return - agent Info <ko>   </ko>
 * @example
import agent from "@egjs/agent";
// eg.agent();
const { os, browser, isMobile } = agent();
 */

function agent(userAgent) {
  if (typeof userAgent === "undefined" && hasUserAgentData()) {
    return parseUserAgentData();
  } else {
    return parseUserAgent(userAgent);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (agent);

//# sourceMappingURL=agent.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@egjs-children-differ-npm-1.0.1-37f45ddf97-087f286822.zip/node_modules/@egjs/children-differ/dist/children-differ.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "diff": () => (/* binding */ diff)
/* harmony export */ });
/* harmony import */ var _egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@egjs-list-differ-npm-1.0.0-f4b91781db-d1827d134d.zip/node_modules/@egjs/list-differ/dist/list-differ.esm.js");
/*
Copyright (c) 2019-present NAVER Corp.
name: @egjs/children-differ
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-children-differ
version: 1.0.1
*/


/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var findKeyCallback = typeof Map === "function" ? undefined : function () {
  var childrenCount = 0;
  return function (el) {
    return el.__DIFF_KEY__ || (el.__DIFF_KEY__ = ++childrenCount);
  };
}();

/**
 * A module that checks diff when child are added, removed, or changed .
 * @ko           .
 * @memberof eg
 * @extends eg.ListDiffer
 */

var ChildrenDiffer =
/*#__PURE__*/
function (_super) {
  __extends(ChildrenDiffer, _super);
  /**
   * @param - Initializing Children <ko>    </ko>
   */


  function ChildrenDiffer(list) {
    if (list === void 0) {
      list = [];
    }

    return _super.call(this, list, findKeyCallback) || this;
  }

  return ChildrenDiffer;
}(_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__["default"]);

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
/**
 *
 * @memberof eg.ChildrenDiffer
 * @static
 * @function
 * @param - Previous List <ko>   </ko>
 * @param - List to Update <ko>    </ko>
 * @return - Returns the diff between `prevList` and `list` <ko> `prevList` `list`   .</ko>
 * @example
 * import { diff } from "@egjs/children-differ";
 * // script => eg.ChildrenDiffer.diff
 * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1]);
 * // List before update
 * // [1, 2, 3, 4, 5]
 * console.log(result.prevList);
 * // Updated list
 * // [4, 3, 6, 2, 1]
 * console.log(result.list);
 * // Index array of values added to `list`
 * // [0, 1, 5]
 * console.log(result.added);
 * // Index array of values removed in `prevList`
 * // [5]
 * console.log(result.removed);
 * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.changed);
 * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
 * // [[4, 3], [3, 4], [2, 6]]
 * console.log(result.pureChanged);
 * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
 * // [[4, 1], [4, 2], [4, 3]]
 * console.log(result.ordered);
 * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.maintained);
 */

function diff(prevList, list) {
  return (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__.diff)(prevList, list, findKeyCallback);
}

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChildrenDiffer);

//# sourceMappingURL=children-differ.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@egjs-list-differ-npm-1.0.0-f4b91781db-d1827d134d.zip/node_modules/@egjs/list-differ/dist/list-differ.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "diff": () => (/* binding */ diff)
/* harmony export */ });
/*
Copyright (c) 2019-present NAVER Corp.
name: @egjs/list-differ
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-list-differ
version: 1.0.0
*/
/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var PolyMap =
/*#__PURE__*/
function () {
  function PolyMap() {
    this.keys = [];
    this.values = [];
  }

  var __proto = PolyMap.prototype;

  __proto.get = function (key) {
    return this.values[this.keys.indexOf(key)];
  };

  __proto.set = function (key, value) {
    var keys = this.keys;
    var values = this.values;
    var prevIndex = keys.indexOf(key);
    var index = prevIndex === -1 ? keys.length : prevIndex;
    keys[index] = key;
    values[index] = value;
  };

  return PolyMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var HashMap =
/*#__PURE__*/
function () {
  function HashMap() {
    this.object = {};
  }

  var __proto = HashMap.prototype;

  __proto.get = function (key) {
    return this.object[key];
  };

  __proto.set = function (key, value) {
    this.object[key] = value;
  };

  return HashMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var SUPPORT_MAP = typeof Map === "function";

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var Link =
/*#__PURE__*/
function () {
  function Link() {}

  var __proto = Link.prototype;

  __proto.connect = function (prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };

  __proto.disconnect = function () {
    // In double linked list, diconnect the interconnected relationship.
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };

  __proto.getIndex = function () {
    var link = this;
    var index = -1;

    while (link) {
      link = link.prev;
      ++index;
    }

    return index;
  };

  return Link;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

function orderChanged(changed, fixed) {
  // It is roughly in the order of these examples.
  // 4, 6, 0, 2, 1, 3, 5, 7
  var fromLinks = []; // 0, 1, 2, 3, 4, 5, 6, 7

  var toLinks = [];
  changed.forEach(function (_a) {
    var from = _a[0],
        to = _a[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  }); // `fromLinks` are connected to each other by double linked list.

  fromLinks.forEach(function (link, i) {
    link.connect(fromLinks[i - 1]);
  });
  return changed.filter(function (_, i) {
    return !fixed[i];
  }).map(function (_a, i) {
    var from = _a[0],
        to = _a[1];

    if (from === to) {
      return [0, 0];
    }

    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex(); // Disconnect the link connected to `fromLink`.

    fromLink.disconnect(); // Connect `fromLink` to the right of `toLink`.

    if (!toLink) {
      fromLink.connect(undefined, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }

    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}

var Result =
/*#__PURE__*/
function () {
  function Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed;
  }

  var __proto = Result.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function () {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }

      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function () {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }

      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });

  __proto.caculateOrdered = function () {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function (_a, i) {
      var from = _a[0],
          to = _a[1];
      var _b = changed[i],
          fromBefore = _b[0],
          toBefore = _b[1];

      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };

  return Result;
}();

/**
 *
 * @memberof eg.ListDiffer
 * @static
 * @function
 * @param - Previous List <ko>   </ko>
 * @param - List to Update <ko>    </ko>
 * @param - This callback function returns the key of the item. <ko>     .</ko>
 * @return - Returns the diff between `prevList` and `list` <ko> `prevList` `list`   .</ko>
 * @example
 * import { diff } from "@egjs/list-differ";
 * // script => eg.ListDiffer.diff
 * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);
 * // List before update
 * // [1, 2, 3, 4, 5]
 * console.log(result.prevList);
 * // Updated list
 * // [4, 3, 6, 2, 1]
 * console.log(result.list);
 * // Index array of values added to `list`
 * // [0, 1, 5]
 * console.log(result.added);
 * // Index array of values removed in `prevList`
 * // [5]
 * console.log(result.removed);
 * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.changed);
 * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
 * // [[4, 3], [3, 4], [2, 6]]
 * console.log(result.pureChanged);
 * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
 * // [[4, 1], [4, 2], [4, 3]]
 * console.log(result.ordered);
 * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.maintained);
 */

function diff(prevList, list, findKeyCallback) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;

  var callback = findKeyCallback || function (e) {
    return e;
  };

  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0; // Add prevKeys and keys to the hashmap.

  prevKeys.forEach(function (key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys.forEach(function (key, listIndex) {
    keyMap.set(key, listIndex);
  }); // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.

  prevKeys.forEach(function (key, prevListIndex) {
    var listIndex = keyMap.get(key); // In prevList, but not in list, it is removed.

    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  }); // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.

  keys.forEach(function (key, listIndex) {
    var prevListIndex = prevKeyMap.get(key); // In list, but not in prevList, it is added.

    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed.push(listIndex === prevListIndex);

      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  }); // Sort by ascending order of 'to(list's index).

  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);
}

/**
 * A module that checks diff when values are added, removed, or changed in an array.
 * @ko          .
 * @memberof eg
 */

var ListDiffer =
/*#__PURE__*/
function () {
  /**
   * @param - Initializing Data Array. <ko>    .</ko>
   * @param - This callback function returns the key of the item. <ko>     .</ko>
   * @example
   * import ListDiffer from "@egjs/list-differ";
   * // script => eg.ListDiffer
   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);
   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);
   * // List before update
   * // [1, 2, 3, 4, 5]
   * console.log(result.prevList);
   * // Updated list
   * // [4, 3, 6, 2, 1]
   * console.log(result.list);
   * // Index array of values added to `list`.
   * // [0, 1, 5]
   * console.log(result.added);
   * // Index array of values removed in `prevList`.
   * // [5]
   * console.log(result.removed);
   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.changed);
   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
   * // [[4, 3], [3, 4], [2, 6]]
   * console.log(result.pureChanged);
   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
   * // [[4, 1], [4, 2], [4, 3]]
   * console.log(result.ordered);
   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.maintained);
   */
  function ListDiffer(list, findKeyCallback) {
    if (list === void 0) {
      list = [];
    }

    this.findKeyCallback = findKeyCallback;
    this.list = [].slice.call(list);
  }
  /**
   * Update list.
   * @ko   .
   * @param - List to update <ko>   </ko>
   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList` `list`   . </ko>
   */


  var __proto = ListDiffer.prototype;

  __proto.update = function (list) {
    var newData = [].slice.call(list);
    var result = diff(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };

  return ListDiffer;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListDiffer);

//# sourceMappingURL=list-differ.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@scena-dragscroll-npm-1.1.1-8fe60775f9-aacb335870.zip/node_modules/@scena/dragscroll/dist/dragscroll.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: @scena/dragscroll
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/dragscroll.git
version: 1.1.1
*/



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function getDefaultScrollPosition(e) {
  var container = e.container;

  if (container === document.body) {
    return [container.scrollLeft || document.documentElement.scrollLeft, container.scrollTop || document.documentElement.scrollTop];
  }

  return [container.scrollLeft, container.scrollTop];
}

var DragScroll =
/*#__PURE__*/
function (_super) {
  __extends(DragScroll, _super);

  function DragScroll() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this._startRect = null;
    _this._startPos = [];
    _this._prevTime = 0;
    _this._timer = 0;
    _this._prevScrollPos = [0, 0];
    _this._isWait = false;
    return _this;
  }

  var __proto = DragScroll.prototype;

  __proto.dragStart = function (e, options) {
    var container = options.container;
    var top = 0;
    var left = 0;
    var width = 0;
    var height = 0;

    if (container === document.body) {
      width = window.innerWidth;
      height = window.innerHeight;
    } else {
      var rect = container.getBoundingClientRect();
      top = rect.top;
      left = rect.left;
      width = rect.width;
      height = rect.height;
    }

    this._startPos = [e.clientX, e.clientY];
    this._startRect = {
      top: top,
      left: left,
      width: width,
      height: height
    };
    this._prevScrollPos = this._getScrollPosition([0, 0], options);
  };

  __proto.drag = function (e, options) {
    var clientX = e.clientX,
        clientY = e.clientY;
    var _a = options.threshold,
        threshold = _a === void 0 ? 0 : _a;

    var _b = this,
        _startRect = _b._startRect,
        _startPos = _b._startPos;

    var direction = [0, 0];

    if (_startRect.top > clientY - threshold) {
      if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {
        direction[1] = -1;
      }
    } else if (_startRect.top + _startRect.height < clientY + threshold) {
      if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {
        direction[1] = 1;
      }
    }

    if (_startRect.left > clientX - threshold) {
      if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {
        direction[0] = -1;
      }
    } else if (_startRect.left + _startRect.width < clientX + threshold) {
      if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {
        direction[0] = 1;
      }
    }

    clearTimeout(this._timer);

    if (!direction[0] && !direction[1]) {
      return false;
    }

    return this._continueDrag(__assign(__assign({}, options), {
      direction: direction,
      inputEvent: e,
      isDrag: true
    }));
  };

  __proto.checkScroll = function (options) {
    var _this = this;

    if (this._isWait) {
      return false;
    }

    var _a = options.prevScrollPos,
        prevScrollPos = _a === void 0 ? this._prevScrollPos : _a,
        direction = options.direction,
        _b = options.throttleTime,
        throttleTime = _b === void 0 ? 0 : _b,
        inputEvent = options.inputEvent,
        isDrag = options.isDrag;

    var nextScrollPos = this._getScrollPosition(direction || [0, 0], options);

    var offsetX = nextScrollPos[0] - prevScrollPos[0];
    var offsetY = nextScrollPos[1] - prevScrollPos[1];
    var nextDirection = direction || [offsetX ? Math.abs(offsetX) / offsetX : 0, offsetY ? Math.abs(offsetY) / offsetY : 0];
    this._prevScrollPos = nextScrollPos;

    if (!offsetX && !offsetY) {
      return false;
    }

    this.trigger("move", {
      offsetX: nextDirection[0] ? offsetX : 0,
      offsetY: nextDirection[1] ? offsetY : 0,
      inputEvent: inputEvent
    });

    if (throttleTime && isDrag) {
      this._timer = window.setTimeout(function () {
        _this._continueDrag(options);
      }, throttleTime);
    }

    return true;
  };

  __proto.dragEnd = function () {
    clearTimeout(this._timer);
  };

  __proto._getScrollPosition = function (direction, options) {
    var container = options.container,
        _a = options.getScrollPosition,
        getScrollPosition = _a === void 0 ? getDefaultScrollPosition : _a;
    return getScrollPosition({
      container: container,
      direction: direction
    });
  };

  __proto._continueDrag = function (options) {
    var _this = this;

    var container = options.container,
        direction = options.direction,
        throttleTime = options.throttleTime,
        useScroll = options.useScroll,
        isDrag = options.isDrag,
        inputEvent = options.inputEvent;

    if (isDrag && this._isWait) {
      return;
    }

    var nowTime = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)();
    var distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);

    if (distTime > 0) {
      this._timer = window.setTimeout(function () {
        _this._continueDrag(options);
      }, distTime);
      return false;
    }

    this._prevTime = nowTime;

    var prevScrollPos = this._getScrollPosition(direction, options);

    this._prevScrollPos = prevScrollPos;

    if (isDrag) {
      this._isWait = true;
    }

    this.trigger("scroll", {
      container: container,
      direction: direction,
      inputEvent: inputEvent
    });
    this._isWait = false;
    return useScroll || this.checkScroll(__assign(__assign({}, options), {
      prevScrollPos: prevScrollPos,
      direction: direction,
      inputEvent: inputEvent
    }));
  };

  return DragScroll;
}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragScroll);
//# sourceMappingURL=dragscroll.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.5
*/


/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventEmitter);
//# sourceMappingURL=event-emitter.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@scena-matrix-npm-1.1.1-da964f6b3a-e96aeab712.zip/node_modules/@scena/matrix/dist/matrix.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculate": () => (/* binding */ calculate),
/* harmony export */   "convertCSStoMatrix": () => (/* binding */ convertCSStoMatrix),
/* harmony export */   "convertDimension": () => (/* binding */ convertDimension),
/* harmony export */   "convertMatrixtoCSS": () => (/* binding */ convertMatrixtoCSS),
/* harmony export */   "convertPositionMatrix": () => (/* binding */ convertPositionMatrix),
/* harmony export */   "createIdentityMatrix": () => (/* binding */ createIdentityMatrix),
/* harmony export */   "createOriginMatrix": () => (/* binding */ createOriginMatrix),
/* harmony export */   "createRotateMatrix": () => (/* binding */ createRotateMatrix),
/* harmony export */   "createScaleMatrix": () => (/* binding */ createScaleMatrix),
/* harmony export */   "createWarpMatrix": () => (/* binding */ createWarpMatrix),
/* harmony export */   "fromTranslation": () => (/* binding */ fromTranslation),
/* harmony export */   "getCenter": () => (/* binding */ getCenter),
/* harmony export */   "getOrigin": () => (/* binding */ getOrigin),
/* harmony export */   "ignoreDimension": () => (/* binding */ ignoreDimension),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "matrix3d": () => (/* binding */ matrix3d),
/* harmony export */   "minus": () => (/* binding */ minus),
/* harmony export */   "multiplies": () => (/* binding */ multiplies),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "plus": () => (/* binding */ plus),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "rotateX3d": () => (/* binding */ rotateX3d),
/* harmony export */   "rotateY3d": () => (/* binding */ rotateY3d),
/* harmony export */   "rotateZ3d": () => (/* binding */ rotateZ3d),
/* harmony export */   "scale3d": () => (/* binding */ scale3d),
/* harmony export */   "translate3d": () => (/* binding */ translate3d),
/* harmony export */   "transpose": () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2020 Daybrush
name: @scena/matrix
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/matrix
version: 1.1.1
*/


function add(matrix, inverseMatrix, startIndex, fromIndex, n, k) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    var fromX = fromIndex + i * n;
    matrix[x] += matrix[fromX] * k;
    inverseMatrix[x] += inverseMatrix[fromX] * k;
  }
}

function swap(matrix, inverseMatrix, startIndex, fromIndex, n) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    var fromX = fromIndex + i * n;
    var v = matrix[x];
    var iv = inverseMatrix[x];
    matrix[x] = matrix[fromX];
    matrix[fromX] = v;
    inverseMatrix[x] = inverseMatrix[fromX];
    inverseMatrix[fromX] = iv;
  }
}

function divide(matrix, inverseMatrix, startIndex, n, k) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    matrix[x] /= k;
    inverseMatrix[x] /= k;
  }
}
/**
 *
 * @namespace Matrix
 */

/**
 * @memberof Matrix
 */


function ignoreDimension(matrix, m, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = matrix.slice();

  for (var i = 0; i < n; ++i) {
    newMatrix[i * n + m - 1] = 0;
    newMatrix[(m - 1) * n + i] = 0;
  }

  newMatrix[(m - 1) * (n + 1)] = 1;
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function invert(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = matrix.slice();
  var inverseMatrix = createIdentityMatrix(n);

  for (var i = 0; i < n; ++i) {
    // diagonal
    var identityIndex = n * i + i;

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(newMatrix[identityIndex], _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM)) {
      // newMatrix[identityIndex] = 0;
      for (var j = i + 1; j < n; ++j) {
        if (newMatrix[n * i + j]) {
          swap(newMatrix, inverseMatrix, i, j, n);
          break;
        }
      }
    }

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(newMatrix[identityIndex], _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM)) {
      // no inverse matrix
      return [];
    }

    divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);

    for (var j = 0; j < n; ++j) {
      var targetStartIndex = j;
      var targetIndex = j + i * n;
      var target = newMatrix[targetIndex];

      if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(target, _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM) || i === j) {
        continue;
      }

      add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);
    }
  }

  return inverseMatrix;
}
/**
 * @memberof Matrix
 */

function transpose(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = [];

  for (var i = 0; i < n; ++i) {
    for (var j = 0; j < n; ++j) {
      newMatrix[j * n + i] = matrix[n * i + j];
    }
  }

  return newMatrix;
}
/**
 * @memberof Matrix
 */

function getOrigin(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var originMatrix = [];
  var w = matrix[n * n - 1];

  for (var i = 0; i < n - 1; ++i) {
    originMatrix[i] = matrix[n * (n - 1) + i] / w;
  }

  originMatrix[n - 1] = 0;
  return originMatrix;
}
/**
 * @memberof Matrix
 */

function fromTranslation(pos, n) {
  var newMatrix = createIdentityMatrix(n);

  for (var i = 0; i < n - 1; ++i) {
    newMatrix[n * (n - 1) + i] = pos[i] || 0;
  }

  return newMatrix;
}
/**
 * @memberof Matrix
 */

function convertPositionMatrix(matrix, n) {
  var newMatrix = matrix.slice();

  for (var i = matrix.length; i < n - 1; ++i) {
    newMatrix[i] = 0;
  }

  newMatrix[n - 1] = 1;
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function convertDimension(matrix, n, m) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  } // n < m


  if (n === m) {
    return matrix;
  }

  var newMatrix = createIdentityMatrix(m);
  var length = Math.min(n, m);

  for (var i = 0; i < length - 1; ++i) {
    for (var j = 0; j < length - 1; ++j) {
      newMatrix[i * m + j] = matrix[i * n + j];
    }

    newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];
    newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];
  }

  newMatrix[m * m - 1] = matrix[n * n - 1];
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function multiplies(n) {
  var matrixes = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    matrixes[_i - 1] = arguments[_i];
  }

  var m = createIdentityMatrix(n);
  matrixes.forEach(function (matrix) {
    m = multiply(m, matrix, n);
  });
  return m;
}
/**
 * @memberof Matrix
 */

function multiply(matrix, matrix2, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = []; // 1 y: n
  // 1 x: m
  // 2 x: m
  // 2 y: k
  // n * m X m * k

  var m = matrix.length / n;
  var k = matrix2.length / m;

  if (!m) {
    return matrix2;
  } else if (!k) {
    return matrix;
  }

  for (var i = 0; i < n; ++i) {
    for (var j = 0; j < k; ++j) {
      newMatrix[j * n + i] = 0;

      for (var l = 0; l < m; ++l) {
        // m1 x: m(l), y: n(i)
        // m2 x: k(j):  y: m(l)
        // nw x: n(i), y: k(j)
        newMatrix[j * n + i] += matrix[l * n + i] * matrix2[j * m + l];
      }
    }
  } // n * k


  return newMatrix;
}
/**
 * @memberof Matrix
 */

function plus(pos1, pos2) {
  var length = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();

  for (var i = 0; i < length; ++i) {
    nextPos[i] = nextPos[i] + pos2[i];
  }

  return nextPos;
}
/**
 * @memberof Matrix
 */

function minus(pos1, pos2) {
  var length = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();

  for (var i = 0; i < length; ++i) {
    nextPos[i] = nextPos[i] - pos2[i];
  }

  return nextPos;
}
/**
 * @memberof Matrix
 */

function convertCSStoMatrix(a, is2d) {
  if (is2d === void 0) {
    is2d = a.length === 6;
  }

  if (is2d) {
    return [a[0], a[1], 0, a[2], a[3], 0, a[4], a[5], 1];
  }

  return a;
}
/**
 * @memberof Matrix
 */

function convertMatrixtoCSS(a, is2d) {
  if (is2d === void 0) {
    is2d = a.length === 9;
  }

  if (is2d) {
    return [a[0], a[1], a[3], a[4], a[6], a[7]];
  }

  return a;
}
/**
 * @memberof Matrix
 */

function calculate(matrix, matrix2, n) {
  if (n === void 0) {
    n = matrix2.length;
  }

  var result = multiply(matrix, matrix2, n);
  var k = result[n - 1];
  return result.map(function (v) {
    return v / k;
  });
}
/**
 * @memberof Matrix
 */

function rotateX3d(matrix, rad) {
  return multiply(matrix, [1, 0, 0, 0, 0, Math.cos(rad), Math.sin(rad), 0, 0, -Math.sin(rad), Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotateY3d(matrix, rad) {
  return multiply(matrix, [Math.cos(rad), 0, -Math.sin(rad), 0, 0, 1, 0, 0, Math.sin(rad), 0, Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotateZ3d(matrix, rad) {
  return multiply(matrix, createRotateMatrix(rad, 4));
}
/**
 * @memberof Matrix
 */

function scale3d(matrix, _a) {
  var _b = _a[0],
      sx = _b === void 0 ? 1 : _b,
      _c = _a[1],
      sy = _c === void 0 ? 1 : _c,
      _d = _a[2],
      sz = _d === void 0 ? 1 : _d;
  return multiply(matrix, [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotate(pos, rad) {
  return calculate(createRotateMatrix(rad, 3), convertPositionMatrix(pos, 3));
}
/**
 * @memberof Matrix
 */

function translate3d(matrix, _a) {
  var _b = _a[0],
      tx = _b === void 0 ? 0 : _b,
      _c = _a[1],
      ty = _c === void 0 ? 0 : _c,
      _d = _a[2],
      tz = _d === void 0 ? 0 : _d;
  return multiply(matrix, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1], 4);
}
/**
 * @memberof Matrix
 */

function matrix3d(matrix1, matrix2) {
  return multiply(matrix1, matrix2, 4);
}
/**
 * @memberof Matrix
 */

function createRotateMatrix(rad, n) {
  var cos = Math.cos(rad);
  var sin = Math.sin(rad);
  var m = createIdentityMatrix(n); // cos -sin
  // sin cos

  m[0] = cos;
  m[1] = sin;
  m[n] = -sin;
  m[n + 1] = cos;
  return m;
}
/**
 * @memberof Matrix
 */

function createIdentityMatrix(n) {
  var length = n * n;
  var matrix = [];

  for (var i = 0; i < length; ++i) {
    matrix[i] = i % (n + 1) ? 0 : 1;
  }

  return matrix;
}
/**
 * @memberof Matrix
 */

function createScaleMatrix(scale, n) {
  var m = createIdentityMatrix(n);
  var length = Math.min(scale.length, n - 1);

  for (var i = 0; i < length; ++i) {
    m[(n + 1) * i] = scale[i];
  }

  return m;
}
/**
 * @memberof Matrix
 */

function createOriginMatrix(origin, n) {
  var m = createIdentityMatrix(n);
  var length = Math.min(origin.length, n - 1);

  for (var i = 0; i < length; ++i) {
    m[n * (n - 1) + i] = origin[i];
  }

  return m;
}
/**
 * @memberof Matrix
 */

function createWarpMatrix(pos0, pos1, pos2, pos3, nextPos0, nextPos1, nextPos2, nextPos3) {
  var x0 = pos0[0],
      y0 = pos0[1];
  var x1 = pos1[0],
      y1 = pos1[1];
  var x2 = pos2[0],
      y2 = pos2[1];
  var x3 = pos3[0],
      y3 = pos3[1];
  var u0 = nextPos0[0],
      v0 = nextPos0[1];
  var u1 = nextPos1[0],
      v1 = nextPos1[1];
  var u2 = nextPos2[0],
      v2 = nextPos2[1];
  var u3 = nextPos3[0],
      v3 = nextPos3[1];
  var matrix = [x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3, -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3];
  var inverseMatrix = invert(matrix, 8);

  if (!inverseMatrix.length) {
    return [];
  }

  var h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);
  h[8] = 1;
  return convertDimension(transpose(h), 3, 4);
}
/**
 * @memberof Matrix
 */

function getCenter(points) {
  return [0, 1].map(function (i) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.average)(points.map(function (pos) {
      return pos[i];
    }));
  });
}


//# sourceMappingURL=matrix.esm.js.map


/***/ }),

/***/ "./.yarn/cache/css-to-mat-npm-1.0.3-8a69ed71de-a3fc98bfad.zip/node_modules/css-to-mat/dist/css-to-mat.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculateMatrixDist": () => (/* binding */ calculateMatrixDist),
/* harmony export */   "createMatrix": () => (/* binding */ createMatrix),
/* harmony export */   "getDistElementMatrix": () => (/* binding */ getDistElementMatrix),
/* harmony export */   "getElementMatrix": () => (/* binding */ getElementMatrix),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parseMat": () => (/* binding */ parseMat),
/* harmony export */   "toMat": () => (/* binding */ toMat)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/* harmony import */ var _scena_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@scena-matrix-npm-1.1.1-da964f6b3a-e96aeab712.zip/node_modules/@scena/matrix/dist/matrix.esm.js");
/*
Copyright (c) 2019 Daybrush
name: css-to-mat
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-to-mat.git
version: 1.0.3
*/



function createMatrix() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function parseMat(transform) {
  return toMat(parse(transform));
}
function getElementMatrix(el) {
  return parseMat(getComputedStyle(el).transform);
}
function calculateMatrixDist(matrix, pos) {
  var res = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_0__.calculate)(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);
  var w = res[3] || 1;
  return [res[0] / w, res[1] / w, res[2] / w];
}
function getDistElementMatrix(el, container) {
  if (container === void 0) {
    container = document.body;
  }

  var target = el;
  var matrix = createMatrix();

  while (target) {
    var transform = getComputedStyle(target).transform;
    matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_0__.matrix3d)(parseMat(transform), matrix);

    if (target === container) {
      break;
    }

    target = target.parentElement;
  }

  matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_0__.invert)(matrix, 4);
  matrix[12] = 0;
  matrix[13] = 0;
  matrix[14] = 0;
  return matrix;
}
function toMat(matrixInfos) {
  var target = createMatrix();
  matrixInfos.forEach(function (info) {
    var matrixFunction = info.matrixFunction,
        functionValue = info.functionValue;

    if (!matrixFunction) {
      return;
    }

    target = matrixFunction(target, functionValue);
  });
  return target;
}
function parse(transform) {
  var transforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitSpace)(transform);
  return transforms.map(function (t) {
    var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitBracket)(t),
        name = _a.prefix,
        value = _a.value;

    var matrixFunction = null;
    var functionName = name;
    var functionValue = "";

    if (name === "translate" || name === "translateX" || name === "translate3d") {
      var _b = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      }),
          posX = _b[0],
          _c = _b[1],
          posY = _c === void 0 ? 0 : _c,
          _d = _b[2],
          posZ = _d === void 0 ? 0 : _d;

      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.translate3d;
      functionValue = [posX, posY, posZ];
    } else if (name === "translateY") {
      var posY = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.translate3d;
      functionValue = [0, posY, 0];
    } else if (name === "translateZ") {
      var posZ = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.translate3d;
      functionValue = [0, 0, posZ];
    } else if (name === "scale" || name === "scale3d") {
      var _e = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      }),
          sx = _e[0],
          _f = _e[1],
          sy = _f === void 0 ? sx : _f,
          _g = _e[2],
          sz = _g === void 0 ? 1 : _g;

      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [sx, sy, sz];
    } else if (name === "scaleX") {
      var sx = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [sx, 1, 1];
    } else if (name === "scaleY") {
      var sy = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [1, sy, 1];
    } else if (name === "scaleZ") {
      var sz = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [1, 1, sz];
    } else if (name === "rotate" || name === "rotateZ" || name === "rotateX" || name === "rotateY") {
      var _h = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitUnit)(value),
          unit = _h.unit,
          unitValue = _h.value;

      var rad = unit === "rad" ? unitValue : unitValue * Math.PI / 180;

      if (name === "rotate" || name === "rotateZ") {
        functionName = "rotateZ";
        matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.rotateZ3d;
      } else if (name === "rotateX") {
        matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.rotateX3d;
      } else if (name === "rotateY") {
        matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.rotateY3d;
      }

      functionValue = rad;
    } else if (name === "matrix3d") {
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.matrix3d;
      functionValue = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      });
    } else if (name === "matrix") {
      var m = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      });
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.matrix3d;
      functionValue = [m[0], m[1], 0, 0, m[2], m[3], 0, 0, 0, 0, 1, 0, m[4], m[5], 0, 1];
    } else {
      functionName = "";
    }

    return {
      name: name,
      functionName: functionName,
      value: value,
      matrixFunction: matrixFunction,
      functionValue: functionValue
    };
  });
}


//# sourceMappingURL=css-to-mat.esm.js.map


/***/ }),

/***/ "./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Properties": () => (/* binding */ Properties),
/* harmony export */   "prefixCSS": () => (/* binding */ prefixCSS),
/* harmony export */   "prefixNames": () => (/* binding */ prefixNames),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "refs": () => (/* binding */ refs),
/* harmony export */   "withMethods": () => (/* binding */ withMethods)
/* harmony export */ });
/*
Copyright (c) 2019 Daybrush
name: framework-utils
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/framework-utils.git
version: 1.1.0
*/
function prefixNames(prefix) {
  var classNames = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    classNames[_i - 1] = arguments[_i];
  }

  return classNames.map(function (className) {
    return className.split(" ").map(function (name) {
      return name ? "" + prefix + name : "";
    }).join(" ");
  }).join(" ");
}
function prefixCSS(prefix, css) {
  return css.replace(/([^}{]*){/gm, function (_, selector) {
    return selector.replace(/\.([^{,\s\d.]+)/g, "." + prefix + "$1") + "{";
  });
}
/* react */

function ref(target, name) {
  return function (e) {
    e && (target[name] = e);
  };
}
function refs(target, name, i) {
  return function (e) {
    e && (target[name][i] = e);
  };
}
/* Class Decorator */

function Properties(properties, action) {
  return function (component) {
    var prototype = component.prototype;
    properties.forEach(function (property) {
      action(prototype, property);
    });
  };
}
/* Property Decorator */

function withMethods(methods, duplicate) {
  if (duplicate === void 0) {
    duplicate = {};
  }

  return function (prototype, propertyName) {
    methods.forEach(function (name) {
      var methodName = duplicate[name] || name;

      if (methodName in prototype) {
        return;
      }

      prototype[methodName] = function () {
        var _a;

        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        var result = (_a = this[propertyName])[name].apply(_a, args);

        if (result === this[propertyName]) {
          return this;
        } else {
          return result;
        }
      };
    });
  };
}


//# sourceMappingURL=utils.esm.js.map


/***/ }),

/***/ "./.yarn/cache/gesto-npm-1.7.0-7d5440000b-f2a66bcf0f.zip/node_modules/gesto/dist/gesto.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: gesto
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesto.git
version: 1.7.0
*/



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function getRad(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
function getRotatiion(touches) {
  return getRad([touches[0].clientX, touches[0].clientY], [touches[1].clientX, touches[1].clientY]) / Math.PI * 180;
}
function isMultiTouch(e) {
  return e.touches && e.touches.length >= 2;
}
function getEventClients(e) {
  if (e.touches) {
    return getClients(e.touches);
  } else {
    return [getClient(e)];
  }
}
function getPosition(clients, prevClients, startClients) {
  var length = startClients.length;

  var _a = getAverageClient(clients, length),
      clientX = _a.clientX,
      clientY = _a.clientY,
      originalClientX = _a.originalClientX,
      originalClientY = _a.originalClientY;

  var _b = getAverageClient(prevClients, length),
      prevX = _b.clientX,
      prevY = _b.clientY;

  var _c = getAverageClient(startClients, length),
      startX = _c.clientX,
      startY = _c.clientY;

  var deltaX = clientX - prevX;
  var deltaY = clientY - prevY;
  var distX = clientX - startX;
  var distY = clientY - startY;
  return {
    clientX: originalClientX,
    clientY: originalClientY,
    deltaX: deltaX,
    deltaY: deltaY,
    distX: distX,
    distY: distY
  };
}
function getDist(clients) {
  return Math.sqrt(Math.pow(clients[0].clientX - clients[1].clientX, 2) + Math.pow(clients[0].clientY - clients[1].clientY, 2));
}
function getClients(touches) {
  var length = Math.min(touches.length, 2);
  var clients = [];

  for (var i = 0; i < length; ++i) {
    clients.push(getClient(touches[i]));
  }

  return clients;
}
function getClient(e) {
  return {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function getAverageClient(clients, length) {
  if (length === void 0) {
    length = clients.length;
  }

  var sumClient = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  };

  for (var i = 0; i < length; ++i) {
    var client = clients[i];
    sumClient.originalClientX += "originalClientX" in client ? client.originalClientX : client.clientX;
    sumClient.originalClientY += "originalClientY" in client ? client.originalClientY : client.clientY;
    sumClient.clientX += client.clientX;
    sumClient.clientY += client.clientY;
  }

  if (!length) {
    return sumClient;
  }

  return {
    clientX: sumClient.clientX / length,
    clientY: sumClient.clientY / length,
    originalClientX: sumClient.originalClientX / length,
    originalClientY: sumClient.originalClientY / length
  };
}

var ClientStore =
/*#__PURE__*/
function () {
  function ClientStore(clients) {
    this.prevClients = [];
    this.startClients = [];
    this.movement = 0;
    this.length = 0;
    this.startClients = clients;
    this.prevClients = clients;
    this.length = clients.length;
  }

  var __proto = ClientStore.prototype;

  __proto.getAngle = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getRotatiion(clients);
  };

  __proto.getRotation = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getRotatiion(clients) - getRotatiion(this.startClients);
  };

  __proto.getPosition = function (clients, isAdd) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    var position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);
    var deltaX = position.deltaX,
        deltaY = position.deltaY;
    this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    this.prevClients = clients;
    return position;
  };

  __proto.getPositions = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    var prevClients = this.prevClients;
    return this.startClients.map(function (startClient, i) {
      return getPosition([clients[i]], [prevClients[i]], [startClient]);
    });
  };

  __proto.getMovement = function (clients) {
    var movement = this.movement;

    if (!clients) {
      return movement;
    }

    var currentClient = getAverageClient(clients, this.length);
    var prevClient = getAverageClient(this.prevClients, this.length);
    var deltaX = currentClient.clientX - prevClient.clientX;
    var deltaY = currentClient.clientY - prevClient.clientY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;
  };

  __proto.getDistance = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getDist(clients);
  };

  __proto.getScale = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getDist(clients) / getDist(this.startClients);
  };

  __proto.move = function (deltaX, deltaY) {
    this.startClients.forEach(function (client) {
      client.clientX -= deltaX;
      client.clientY -= deltaY;
    });
  };

  return ClientStore;
}();

var INPUT_TAGNAMES = ["textarea", "input"];
/**
 * You can set up drag, pinch events in any browser.
 */

var Gesto =
/*#__PURE__*/
function (_super) {
  __extends(Gesto, _super);
  /**
   *
   */


  function Gesto(targets, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.options = {};
    _this.flag = false;
    _this.pinchFlag = false;
    _this.datas = {};
    _this.isDrag = false;
    _this.isPinch = false;
    _this.isMouse = false;
    _this.isTouch = false;
    _this.clientStores = [];
    _this.targets = [];
    _this.prevTime = 0;
    _this.doubleFlag = false;
    _this._dragFlag = false;

    _this.onDragStart = function (e, isTrusted) {
      if (isTrusted === void 0) {
        isTrusted = true;
      }

      if (!_this.flag && e.cancelable === false) {
        return;
      }

      var _a = _this.options,
          container = _a.container,
          pinchOutside = _a.pinchOutside,
          preventRightClick = _a.preventRightClick,
          preventDefault = _a.preventDefault,
          checkInput = _a.checkInput;
      var isTouch = _this.isTouch;
      var isDragStart = !_this.flag;

      if (isDragStart) {
        var activeElement = document.activeElement;
        var target = e.target;
        var tagName = target.tagName.toLowerCase();
        var hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;
        var hasContentEditable = target.isContentEditable;

        if (hasInput || hasContentEditable) {
          if (checkInput || activeElement === target) {
            // force false or already focused.
            return false;
          } // no focus


          if (activeElement && hasContentEditable && activeElement.isContentEditable && activeElement.contains(target)) {
            return false;
          }
        } else if ((preventDefault || e.type === "touchstart") && activeElement) {
          var activeTagName = activeElement.tagName;

          if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {
            activeElement.blur();
          }
        }

        _this.clientStores = [new ClientStore(getEventClients(e))];
        _this.flag = true;
        _this.isDrag = false;
        _this._dragFlag = true;
        _this.datas = {};

        if (preventRightClick && (e.which === 3 || e.button === 2)) {
          _this.initDrag();

          return false;
        }

        _this.doubleFlag = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)() - _this.prevTime < 200;

        var result = _this.emit("dragStart", __assign({
          datas: _this.datas,
          inputEvent: e,
          isTrusted: isTrusted,
          isDouble: _this.doubleFlag
        }, _this.getCurrentStore().getPosition(), {
          preventDefault: function () {
            e.preventDefault();
          },
          preventDrag: function () {
            _this._dragFlag = false;
          }
        }));

        if (result === false) {
          _this.initDrag();
        }

        _this.flag && preventDefault && e.preventDefault();
      }

      if (!_this.flag) {
        return false;
      }

      var timer = 0;

      if (isDragStart && isTouch && pinchOutside) {
        timer = setTimeout(function () {
          (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchstart", _this.onDragStart, {
            passive: false
          });
        });
      }

      if (!isDragStart && isTouch && pinchOutside) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", _this.onDragStart);
      }

      if (_this.flag && isMultiTouch(e)) {
        clearTimeout(timer);

        if (isDragStart && e.touches.length !== e.changedTouches.length) {
          return;
        }

        if (!_this.pinchFlag) {
          _this.onPinchStart(e);
        }
      }
    };

    _this.onDrag = function (e, isScroll) {
      if (!_this.flag) {
        return;
      }

      var clients = getEventClients(e);

      var result = _this.moveClients(clients, e, false);

      if (_this._dragFlag) {
        if (_this.pinchFlag || result.deltaX || result.deltaY) {
          var dragResult = _this.emit("drag", __assign({}, result, {
            isScroll: !!isScroll,
            inputEvent: e
          }));

          if (dragResult === false) {
            _this.stop();

            return;
          }
        }

        if (_this.pinchFlag) {
          _this.onPinch(e, clients);
        }
      }

      _this.getCurrentStore().getPosition(clients, true);
    };

    _this.onDragEnd = function (e) {
      if (!_this.flag) {
        return;
      }

      var _a = _this.options,
          pinchOutside = _a.pinchOutside,
          container = _a.container;

      if (_this.isTouch && pinchOutside) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", _this.onDragStart);
      }

      _this.flag = false;

      var position = _this._getPosition();

      var currentTime = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)();
      var isDouble = !_this.isDrag && _this.doubleFlag;
      _this.prevTime = _this.isDrag || isDouble ? 0 : currentTime;

      _this.emit("dragEnd", __assign({
        datas: _this.datas,
        isDouble: isDouble,
        isDrag: _this.isDrag,
        isClick: !_this.isDrag,
        inputEvent: e
      }, position));

      if (_this.pinchFlag) {
        _this.onPinchEnd(e);
      }

      _this.clientStores = [];
    };

    _this.onBlur = function () {
      _this.onDragEnd();
    };

    var elements = [].concat(targets);
    _this.options = __assign({
      checkInput: false,
      container: elements.length > 1 ? window : elements[0],
      preventRightClick: true,
      preventDefault: true,
      checkWindowBlur: false,
      pinchThreshold: 0,
      events: ["touch", "mouse"]
    }, options);
    var _a = _this.options,
        container = _a.container,
        events = _a.events,
        checkWindowBlur = _a.checkWindowBlur;
    _this.isTouch = events.indexOf("touch") > -1;
    _this.isMouse = events.indexOf("mouse") > -1;
    _this.targets = elements;

    if (_this.isMouse) {
      elements.forEach(function (el) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(el, "mousedown", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "mousemove", _this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "mouseup", _this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "contextmenu", _this.onDragEnd);
    }

    if (checkWindowBlur) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(window, "blur", _this.onBlur);
    }

    if (_this.isTouch) {
      var passive_1 = {
        passive: false
      };
      elements.forEach(function (el) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(el, "touchstart", _this.onDragStart, passive_1);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchmove", _this.onDrag, passive_1);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchend", _this.onDragEnd, passive_1);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchcancel", _this.onDragEnd, passive_1);
    }

    return _this;
  }
  /**
   * Stop Gesto's drag events.
   */


  var __proto = Gesto.prototype;

  __proto.stop = function () {
    this.isDrag = false;
    this.flag = false;
    this.clientStores = [];
    this.datas = {};
  };
  /**
   * The total moved distance
   */


  __proto.getMovement = function (clients) {
    return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce(function (prev, cur) {
      return prev + cur.movement;
    }, 0);
  };
  /**
   * Whether to drag
   */


  __proto.isDragging = function () {
    return this.isDrag;
  };
  /**
   * Whether to start drag
   */


  __proto.isFlag = function () {
    return this.flag;
  };
  /**
   * Whether to start pinch
   */


  __proto.isPinchFlag = function () {
    return this.pinchFlag;
  };
  /**
  * Whether to start double click
  */


  __proto.isDoubleFlag = function () {
    return this.doubleFlag;
  };
  /**
   * Whether to pinch
   */


  __proto.isPinching = function () {
    return this.isPinch;
  };
  /**
   * If a scroll event occurs, it is corrected by the scroll distance.
   */


  __proto.scrollBy = function (deltaX, deltaY, e, isCallDrag) {
    if (isCallDrag === void 0) {
      isCallDrag = true;
    }

    if (!this.flag) {
      return;
    }

    this.clientStores[0].move(deltaX, deltaY);
    isCallDrag && this.onDrag(e, true);
  };
  /**
   * Create a virtual drag event.
   */


  __proto.move = function (_a, inputEvent) {
    var deltaX = _a[0],
        deltaY = _a[1];
    var store = this.getCurrentStore();
    var nextClients = store.prevClients;
    return this.moveClients(nextClients.map(function (_a) {
      var clientX = _a.clientX,
          clientY = _a.clientY;
      return {
        clientX: clientX + deltaX,
        clientY: clientY + deltaY,
        originalClientX: clientX,
        originalClientY: clientY
      };
    }), inputEvent, true);
  };
  /**
   * The dragStart event is triggered by an external event.
   */


  __proto.triggerDragStart = function (e) {
    this.onDragStart(e, false);
  };
  /**
   * Set the event data while dragging.
   */


  __proto.setEventDatas = function (datas) {
    var currentDatas = this.datas;

    for (var name in datas) {
      currentDatas[name] = datas[name];
    }

    return this;
  };
  /**
   * Get the current event state while dragging.
   */


  __proto.getCurrentEvent = function (inputEvent) {
    return __assign({
      datas: this.datas
    }, this._getPosition(), {
      movement: this.getMovement(),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent: inputEvent
    });
  };
  /**
   * Get & Set the event data while dragging.
   */


  __proto.getEventDatas = function () {
    return this.datas;
  };
  /**
   * Unset Gesto
   */


  __proto.unset = function () {
    var _this = this;

    var targets = this.targets;
    var container = this.options.container;
    this.off();
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(window, "blur", this.onBlur);

    if (this.isMouse) {
      targets.forEach(function (target) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(target, "mousedown", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "mousemove", this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "mouseup", this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "contextmenu", this.onDragEnd);
    }

    if (this.isTouch) {
      targets.forEach(function (target) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(target, "touchstart", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", this.onDragStart);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchmove", this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchend", this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchcancel", this.onDragEnd);
    }
  };

  __proto.onPinchStart = function (e) {
    var pinchThreshold = this.options.pinchThreshold;

    if (this.isDrag && this.getMovement() > pinchThreshold) {
      return;
    }

    var store = new ClientStore(getEventClients(e));
    this.pinchFlag = true;
    this.clientStores.splice(0, 0, store);
    var result = this.emit("pinchStart", __assign({
      datas: this.datas,
      angle: store.getAngle(),
      touches: this.getCurrentStore().getPositions()
    }, store.getPosition(), {
      inputEvent: e
    }));

    if (result === false) {
      this.pinchFlag = false;
    }
  };

  __proto.onPinch = function (e, clients) {
    if (!this.flag || !this.pinchFlag || clients.length < 2) {
      return;
    }

    var store = this.getCurrentStore();
    this.isPinch = true;
    this.emit("pinch", __assign({
      datas: this.datas,
      movement: this.getMovement(clients),
      angle: store.getAngle(clients),
      rotation: store.getRotation(clients),
      touches: store.getPositions(clients),
      scale: store.getScale(clients),
      distance: store.getDistance(clients)
    }, store.getPosition(clients), {
      inputEvent: e
    }));
  };

  __proto.onPinchEnd = function (e) {
    if (!this.pinchFlag) {
      return;
    }

    var isPinch = this.isPinch;
    this.isPinch = false;
    this.pinchFlag = false;
    var store = this.getCurrentStore();
    this.emit("pinchEnd", __assign({
      datas: this.datas,
      isPinch: isPinch,
      touches: store.getPositions()
    }, store.getPosition(), {
      inputEvent: e
    }));
    this.isPinch = false;
    this.pinchFlag = false;
  };

  __proto.initDrag = function () {
    this.clientStores = [];
    this.pinchFlag = false;
    this.doubleFlag = false;
    this.prevTime = 0;
    this.flag = false;
  };

  __proto.getCurrentStore = function () {
    return this.clientStores[0];
  };

  __proto.moveClients = function (clients, inputEvent, isAdd) {
    var position = this._getPosition(clients, isAdd);

    if (position.deltaX || position.deltaY) {
      this.isDrag = true;
    }

    return __assign({
      datas: this.datas
    }, position, {
      movement: this.getMovement(clients),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent: inputEvent
    });
  };

  __proto._getPosition = function (clients, isAdd) {
    var store = this.getCurrentStore();
    var position = store.getPosition(clients, isAdd);

    var _a = this.clientStores.slice(1).reduce(function (prev, cur) {
      var storePosition = cur.getPosition();
      prev.distX += storePosition.distX;
      prev.distY += storePosition.distY;
      return prev;
    }, position),
        distX = _a.distX,
        distY = _a.distY;

    return __assign({}, position, {
      distX: distX,
      distY: distY
    });
  };

  return Gesto;
}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Gesto);
//# sourceMappingURL=gesto.esm.js.map


/***/ }),

/***/ "./.yarn/cache/gesto-npm-1.9.0-c7de46fb4c-4ee8631c4b.zip/node_modules/gesto/dist/gesto.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js");
/*
Copyright (c) 2019 Daybrush
name: gesto
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesto.git
version: 1.9.0
*/



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function getRad(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
function getRotatiion(touches) {
  return getRad([touches[0].clientX, touches[0].clientY], [touches[1].clientX, touches[1].clientY]) / Math.PI * 180;
}
function isMultiTouch(e) {
  return e.touches && e.touches.length >= 2;
}
function getEventClients(e) {
  if (!e) {
    return [];
  }

  if (e.touches) {
    return getClients(e.touches);
  } else {
    return [getClient(e)];
  }
}
function getPosition(clients, prevClients, startClients) {
  var length = startClients.length;

  var _a = getAverageClient(clients, length),
      clientX = _a.clientX,
      clientY = _a.clientY,
      originalClientX = _a.originalClientX,
      originalClientY = _a.originalClientY;

  var _b = getAverageClient(prevClients, length),
      prevX = _b.clientX,
      prevY = _b.clientY;

  var _c = getAverageClient(startClients, length),
      startX = _c.clientX,
      startY = _c.clientY;

  var deltaX = clientX - prevX;
  var deltaY = clientY - prevY;
  var distX = clientX - startX;
  var distY = clientY - startY;
  return {
    clientX: originalClientX,
    clientY: originalClientY,
    deltaX: deltaX,
    deltaY: deltaY,
    distX: distX,
    distY: distY
  };
}
function getDist(clients) {
  return Math.sqrt(Math.pow(clients[0].clientX - clients[1].clientX, 2) + Math.pow(clients[0].clientY - clients[1].clientY, 2));
}
function getClients(touches) {
  var length = Math.min(touches.length, 2);
  var clients = [];

  for (var i = 0; i < length; ++i) {
    clients.push(getClient(touches[i]));
  }

  return clients;
}
function getClient(e) {
  return {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function getAverageClient(clients, length) {
  if (length === void 0) {
    length = clients.length;
  }

  var sumClient = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  };

  for (var i = 0; i < length; ++i) {
    var client = clients[i];
    sumClient.originalClientX += "originalClientX" in client ? client.originalClientX : client.clientX;
    sumClient.originalClientY += "originalClientY" in client ? client.originalClientY : client.clientY;
    sumClient.clientX += client.clientX;
    sumClient.clientY += client.clientY;
  }

  if (!length) {
    return sumClient;
  }

  return {
    clientX: sumClient.clientX / length,
    clientY: sumClient.clientY / length,
    originalClientX: sumClient.originalClientX / length,
    originalClientY: sumClient.originalClientY / length
  };
}

var ClientStore =
/*#__PURE__*/
function () {
  function ClientStore(clients) {
    this.prevClients = [];
    this.startClients = [];
    this.movement = 0;
    this.length = 0;
    this.startClients = clients;
    this.prevClients = clients;
    this.length = clients.length;
  }

  var __proto = ClientStore.prototype;

  __proto.getAngle = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getRotatiion(clients);
  };

  __proto.getRotation = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getRotatiion(clients) - getRotatiion(this.startClients);
  };

  __proto.getPosition = function (clients, isAdd) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    var position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);
    var deltaX = position.deltaX,
        deltaY = position.deltaY;
    this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    this.prevClients = clients;
    return position;
  };

  __proto.getPositions = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    var prevClients = this.prevClients;
    return this.startClients.map(function (startClient, i) {
      return getPosition([clients[i]], [prevClients[i]], [startClient]);
    });
  };

  __proto.getMovement = function (clients) {
    var movement = this.movement;

    if (!clients) {
      return movement;
    }

    var currentClient = getAverageClient(clients, this.length);
    var prevClient = getAverageClient(this.prevClients, this.length);
    var deltaX = currentClient.clientX - prevClient.clientX;
    var deltaY = currentClient.clientY - prevClient.clientY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;
  };

  __proto.getDistance = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getDist(clients);
  };

  __proto.getScale = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getDist(clients) / getDist(this.startClients);
  };

  __proto.move = function (deltaX, deltaY) {
    this.startClients.forEach(function (client) {
      client.clientX -= deltaX;
      client.clientY -= deltaY;
    });
  };

  return ClientStore;
}();

var INPUT_TAGNAMES = ["textarea", "input"];
/**
 * You can set up drag, pinch events in any browser.
 */

var Gesto =
/*#__PURE__*/
function (_super) {
  __extends(Gesto, _super);
  /**
   *
   */


  function Gesto(targets, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.options = {};
    _this.flag = false;
    _this.pinchFlag = false;
    _this.datas = {};
    _this.isDrag = false;
    _this.isPinch = false;
    _this.isMouse = false;
    _this.isTouch = false;
    _this.clientStores = [];
    _this.targets = [];
    _this.prevTime = 0;
    _this.doubleFlag = false;
    _this._dragFlag = false;

    _this.onDragStart = function (e, isTrusted) {
      if (isTrusted === void 0) {
        isTrusted = true;
      }

      if (!_this.flag && e.cancelable === false) {
        return;
      }

      var _a = _this.options,
          container = _a.container,
          pinchOutside = _a.pinchOutside,
          preventWheelClick = _a.preventWheelClick,
          preventRightClick = _a.preventRightClick,
          preventDefault = _a.preventDefault,
          checkInput = _a.checkInput;
      var isTouch = _this.isTouch;
      var isDragStart = !_this.flag;

      if (preventWheelClick && (e.which === 2 || e.button === 1) || preventRightClick && (e.which === 3 || e.button === 2)) {
        _this.initDrag();

        return false;
      }

      if (isDragStart) {
        var activeElement = document.activeElement;
        var target = e.target;
        var tagName = target.tagName.toLowerCase();
        var hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;
        var hasContentEditable = target.isContentEditable;

        if (hasInput || hasContentEditable) {
          if (checkInput || activeElement === target) {
            // force false or already focused.
            return false;
          } // no focus


          if (activeElement && hasContentEditable && activeElement.isContentEditable && activeElement.contains(target)) {
            return false;
          }
        } else if ((preventDefault || e.type === "touchstart") && activeElement) {
          var activeTagName = activeElement.tagName;

          if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {
            activeElement.blur();
          }
        }

        _this.clientStores = [new ClientStore(getEventClients(e))];
        _this.flag = true;
        _this.isDrag = false;
        _this._dragFlag = true;
        _this.datas = {};
        _this.doubleFlag = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)() - _this.prevTime < 200;

        var result = _this.emit("dragStart", __assign(__assign({
          datas: _this.datas,
          inputEvent: e,
          isTrusted: isTrusted,
          isDouble: _this.doubleFlag
        }, _this.getCurrentStore().getPosition()), {
          preventDefault: function () {
            e.preventDefault();
          },
          preventDrag: function () {
            _this._dragFlag = false;
          }
        }));

        if (result === false) {
          _this.initDrag();
        }

        _this.flag && preventDefault && e.preventDefault();
      }

      if (!_this.flag) {
        return false;
      }

      var timer = 0;

      if (isDragStart && isTouch && pinchOutside) {
        timer = setTimeout(function () {
          (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchstart", _this.onDragStart, {
            passive: false
          });
        });
      }

      if (!isDragStart && isTouch && pinchOutside) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", _this.onDragStart);
      }

      if (_this.flag && isMultiTouch(e)) {
        clearTimeout(timer);

        if (isDragStart && e.touches.length !== e.changedTouches.length) {
          return;
        }

        if (!_this.pinchFlag) {
          _this.onPinchStart(e);
        }
      }
    };

    _this.onDrag = function (e, isScroll) {
      if (!_this.flag) {
        return;
      }

      var clients = getEventClients(e);

      var result = _this.moveClients(clients, e, false);

      if (_this._dragFlag) {
        if (_this.pinchFlag || result.deltaX || result.deltaY) {
          var dragResult = _this.emit("drag", __assign(__assign({}, result), {
            isScroll: !!isScroll,
            inputEvent: e
          }));

          if (dragResult === false) {
            _this.stop();

            return;
          }
        }

        if (_this.pinchFlag) {
          _this.onPinch(e, clients);
        }
      }

      _this.getCurrentStore().getPosition(clients, true);
    };

    _this.onDragEnd = function (e) {
      if (!_this.flag) {
        return;
      }

      var _a = _this.options,
          pinchOutside = _a.pinchOutside,
          container = _a.container;

      if (_this.isTouch && pinchOutside) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", _this.onDragStart);
      }

      if (_this.pinchFlag) {
        _this.onPinchEnd(e);
      }

      var clients = (e === null || e === void 0 ? void 0 : e.touches) ? getEventClients(e) : [];
      var clientsLength = clients.length;

      if (clientsLength === 0 || !_this.options.keepDragging) {
        _this.flag = false;
      } else {
        _this._addStore(new ClientStore(clients));
      }

      var position = _this._getPosition();

      var currentTime = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)();
      var isDouble = !_this.isDrag && _this.doubleFlag;
      _this.prevTime = _this.isDrag || isDouble ? 0 : currentTime;

      if (!_this.flag) {
        _this.emit("dragEnd", __assign({
          datas: _this.datas,
          isDouble: isDouble,
          isDrag: _this.isDrag,
          isClick: !_this.isDrag,
          inputEvent: e
        }, position));

        _this.clientStores = [];
      }
    };

    _this.onBlur = function () {
      _this.onDragEnd();
    };

    var elements = [].concat(targets);
    _this.options = __assign({
      checkInput: false,
      container: elements.length > 1 ? window : elements[0],
      preventRightClick: true,
      preventWheelClick: true,
      preventDefault: true,
      checkWindowBlur: false,
      keepDragging: false,
      pinchThreshold: 0,
      events: ["touch", "mouse"]
    }, options);
    var _a = _this.options,
        container = _a.container,
        events = _a.events,
        checkWindowBlur = _a.checkWindowBlur;
    _this.isTouch = events.indexOf("touch") > -1;
    _this.isMouse = events.indexOf("mouse") > -1;
    _this.targets = elements;

    if (_this.isMouse) {
      elements.forEach(function (el) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(el, "mousedown", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "mousemove", _this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "mouseup", _this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "contextmenu", _this.onDragEnd);
    }

    if (checkWindowBlur) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(window, "blur", _this.onBlur);
    }

    if (_this.isTouch) {
      var passive_1 = {
        passive: false
      };
      elements.forEach(function (el) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(el, "touchstart", _this.onDragStart, passive_1);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchmove", _this.onDrag, passive_1);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchend", _this.onDragEnd, passive_1);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchcancel", _this.onDragEnd, passive_1);
    }

    return _this;
  }
  /**
   * Stop Gesto's drag events.
   */


  var __proto = Gesto.prototype;

  __proto.stop = function () {
    this.isDrag = false;
    this.flag = false;
    this.clientStores = [];
    this.datas = {};
  };
  /**
   * The total moved distance
   */


  __proto.getMovement = function (clients) {
    return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce(function (prev, cur) {
      return prev + cur.movement;
    }, 0);
  };
  /**
   * Whether to drag
   */


  __proto.isDragging = function () {
    return this.isDrag;
  };
  /**
   * Whether to start drag
   */


  __proto.isFlag = function () {
    return this.flag;
  };
  /**
   * Whether to start pinch
   */


  __proto.isPinchFlag = function () {
    return this.pinchFlag;
  };
  /**
  * Whether to start double click
  */


  __proto.isDoubleFlag = function () {
    return this.doubleFlag;
  };
  /**
   * Whether to pinch
   */


  __proto.isPinching = function () {
    return this.isPinch;
  };
  /**
   * If a scroll event occurs, it is corrected by the scroll distance.
   */


  __proto.scrollBy = function (deltaX, deltaY, e, isCallDrag) {
    if (isCallDrag === void 0) {
      isCallDrag = true;
    }

    if (!this.flag) {
      return;
    }

    this.clientStores[0].move(deltaX, deltaY);
    isCallDrag && this.onDrag(e, true);
  };
  /**
   * Create a virtual drag event.
   */


  __proto.move = function (_a, inputEvent) {
    var deltaX = _a[0],
        deltaY = _a[1];
    var store = this.getCurrentStore();
    var nextClients = store.prevClients;
    return this.moveClients(nextClients.map(function (_a) {
      var clientX = _a.clientX,
          clientY = _a.clientY;
      return {
        clientX: clientX + deltaX,
        clientY: clientY + deltaY,
        originalClientX: clientX,
        originalClientY: clientY
      };
    }), inputEvent, true);
  };
  /**
   * The dragStart event is triggered by an external event.
   */


  __proto.triggerDragStart = function (e) {
    this.onDragStart(e, false);
  };
  /**
   * Set the event data while dragging.
   */


  __proto.setEventDatas = function (datas) {
    var currentDatas = this.datas;

    for (var name in datas) {
      currentDatas[name] = datas[name];
    }

    return this;
  };
  /**
   * Get the current event state while dragging.
   */


  __proto.getCurrentEvent = function (inputEvent) {
    return __assign(__assign({
      datas: this.datas
    }, this._getPosition()), {
      movement: this.getMovement(),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent: inputEvent
    });
  };
  /**
   * Get & Set the event data while dragging.
   */


  __proto.getEventDatas = function () {
    return this.datas;
  };
  /**
   * Unset Gesto
   */


  __proto.unset = function () {
    var _this = this;

    var targets = this.targets;
    var container = this.options.container;
    this.off();
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(window, "blur", this.onBlur);

    if (this.isMouse) {
      targets.forEach(function (target) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(target, "mousedown", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "mousemove", this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "mouseup", this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "contextmenu", this.onDragEnd);
    }

    if (this.isTouch) {
      targets.forEach(function (target) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(target, "touchstart", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", this.onDragStart);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchmove", this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchend", this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchcancel", this.onDragEnd);
    }
  };

  __proto.onPinchStart = function (e) {
    var pinchThreshold = this.options.pinchThreshold;

    if (this.isDrag && this.getMovement() > pinchThreshold) {
      return;
    }

    var store = new ClientStore(getEventClients(e));
    this.pinchFlag = true;

    this._addStore(store);

    var result = this.emit("pinchStart", __assign(__assign({
      datas: this.datas,
      angle: store.getAngle(),
      touches: this.getCurrentStore().getPositions()
    }, store.getPosition()), {
      inputEvent: e
    }));

    if (result === false) {
      this.pinchFlag = false;
    }
  };

  __proto.onPinch = function (e, clients) {
    if (!this.flag || !this.pinchFlag || clients.length < 2) {
      return;
    }

    var store = this.getCurrentStore();
    this.isPinch = true;
    this.emit("pinch", __assign(__assign({
      datas: this.datas,
      movement: this.getMovement(clients),
      angle: store.getAngle(clients),
      rotation: store.getRotation(clients),
      touches: store.getPositions(clients),
      scale: store.getScale(clients),
      distance: store.getDistance(clients)
    }, store.getPosition(clients)), {
      inputEvent: e
    }));
  };

  __proto.onPinchEnd = function (e) {
    if (!this.pinchFlag) {
      return;
    }

    var isPinch = this.isPinch;
    this.isPinch = false;
    this.pinchFlag = false;
    var store = this.getCurrentStore();
    this.emit("pinchEnd", __assign(__assign({
      datas: this.datas,
      isPinch: isPinch,
      touches: store.getPositions()
    }, store.getPosition()), {
      inputEvent: e
    }));
  };

  __proto.initDrag = function () {
    this.clientStores = [];
    this.pinchFlag = false;
    this.doubleFlag = false;
    this.prevTime = 0;
    this.flag = false;
  };

  __proto.getCurrentStore = function () {
    return this.clientStores[0];
  };

  __proto.moveClients = function (clients, inputEvent, isAdd) {
    var position = this._getPosition(clients, isAdd);

    if (position.deltaX || position.deltaY) {
      this.isDrag = true;
    }

    return __assign(__assign({
      datas: this.datas
    }, position), {
      movement: this.getMovement(clients),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent: inputEvent
    });
  };

  __proto._addStore = function (store) {
    this.clientStores.splice(0, 0, store);
  };

  __proto._getPosition = function (clients, isAdd) {
    var store = this.getCurrentStore();
    var position = store.getPosition(clients, isAdd);

    var _a = this.clientStores.slice(1).reduce(function (prev, cur) {
      var storePosition = cur.getPosition();
      prev.distX += storePosition.distX;
      prev.distY += storePosition.distY;
      return prev;
    }, position),
        distX = _a.distX,
        distY = _a.distY;

    return __assign(__assign({}, position), {
      distX: distX,
      distY: distY
    });
  };

  return Gesto;
}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Gesto);
//# sourceMappingURL=gesto.esm.js.map


/***/ }),

/***/ "./.yarn/cache/keycon-npm-1.1.2-47bb5048df-7be74aaf83.zip/node_modules/keycon/dist/keycon.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getCombi": () => (/* binding */ getCombi),
/* harmony export */   "getKey": () => (/* binding */ getKey),
/* harmony export */   "getModifierCombi": () => (/* binding */ getModifierCombi)
/* harmony export */ });
/*
Copyright (c) Daybrush
name: keycon
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/keycon.git
version: 1.1.2
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/*
Copyright (c) 2018 Daybrush
@name: @daybrush/utils
license: MIT
author: Daybrush
repository: https://github.com/daybrush/utils
@version 1.0.0
*/
/**
* get string "object"
* @memberof Consts
* @example
import {OBJECT} from "@daybrush/utils";

console.log(OBJECT); // "object"
*/

var OBJECT = "object";
/**
* get string "string"
* @memberof Consts
* @example
import {STRING} from "@daybrush/utils";

console.log(STRING); // "string"
*/

var STRING = "string";
/**
* Check the type that the value is object.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isObject} from "@daybrush/utils";

console.log(isObject({})); // true
console.log(isObject(undefined)); // false
console.log(isObject("")); // false
console.log(isObject(null)); // false
*/

function isObject(value) {
  return value && typeof value === OBJECT;
}
/**
* Check the type that the value is isArray.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isArray} from "@daybrush/utils";

console.log(isArray([])); // true
console.log(isArray({})); // false
console.log(isArray(undefined)); // false
console.log(isArray(null)); // false
*/

function isArray(value) {
  return Array.isArray(value);
}
/**
* Check the type that the value is string.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isString} from "@daybrush/utils";

console.log(isString("1234")); // true
console.log(isString(undefined)); // false
console.log(isString(1)); // false
console.log(isString(null)); // false
*/

function isString(value) {
  return typeof value === STRING;
}
/**
* Returns the index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findIndex } from "@daybrush/utils";

findIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Sets up a function that will be called whenever the specified event is delivered to the target
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs
* @param - An options object that specifies characteristics about the event listener. The available options are:
* @example
import {addEvent} from "@daybrush/utils";

addEvent(el, "click", e => {
  console.log(e);
});
*/

function addEvent(el, type, listener, options) {
  el.addEventListener(type, listener, options);
}
/**
* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The EventListener function of the event handler to remove from the event target.
* @example
import {addEvent, removeEvent} from "@daybrush/utils";
const listener = e => {
  console.log(e);
};
addEvent(el, "click", listener);
removeEvent(el, "click", listener);
*/

function removeEvent(el, type, listener) {
  el.removeEventListener(type, listener);
}

/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.2
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if (isObject(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if (isObject(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = findIndex(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var keycode = createCommonjsModule(function (module, exports) {
// Source: http://jsfiddle.net/vWx8V/
// http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes

/**
 * Conenience method returns corresponding value for given keyName or keyCode.
 *
 * @param {Mixed} keyCode {Number} or keyName {String}
 * @return {Mixed}
 * @api public
 */

function keyCode(searchInput) {
  // Keyboard Events
  if (searchInput && 'object' === typeof searchInput) {
    var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
    if (hasKeyCode) searchInput = hasKeyCode;
  }

  // Numbers
  if ('number' === typeof searchInput) return names[searchInput]

  // Everything else (cast to string)
  var search = String(searchInput);

  // check codes
  var foundNamedKey = codes[search.toLowerCase()];
  if (foundNamedKey) return foundNamedKey

  // check aliases
  var foundNamedKey = aliases[search.toLowerCase()];
  if (foundNamedKey) return foundNamedKey

  // weird character?
  if (search.length === 1) return search.charCodeAt(0)

  return undefined
}

/**
 * Compares a keyboard event with a given keyCode or keyName.
 *
 * @param {Event} event Keyboard event that should be tested
 * @param {Mixed} keyCode {Number} or keyName {String}
 * @return {Boolean}
 * @api public
 */
keyCode.isEventKey = function isEventKey(event, nameOrCode) {
  if (event && 'object' === typeof event) {
    var keyCode = event.which || event.keyCode || event.charCode;
    if (keyCode === null || keyCode === undefined) { return false; }
    if (typeof nameOrCode === 'string') {
      // check codes
      var foundNamedKey = codes[nameOrCode.toLowerCase()];
      if (foundNamedKey) { return foundNamedKey === keyCode; }
    
      // check aliases
      var foundNamedKey = aliases[nameOrCode.toLowerCase()];
      if (foundNamedKey) { return foundNamedKey === keyCode; }
    } else if (typeof nameOrCode === 'number') {
      return nameOrCode === keyCode;
    }
    return false;
  }
};

exports = module.exports = keyCode;

/**
 * Get by name
 *
 *   exports.code['enter'] // => 13
 */

var codes = exports.code = exports.codes = {
  'backspace': 8,
  'tab': 9,
  'enter': 13,
  'shift': 16,
  'ctrl': 17,
  'alt': 18,
  'pause/break': 19,
  'caps lock': 20,
  'esc': 27,
  'space': 32,
  'page up': 33,
  'page down': 34,
  'end': 35,
  'home': 36,
  'left': 37,
  'up': 38,
  'right': 39,
  'down': 40,
  'insert': 45,
  'delete': 46,
  'command': 91,
  'left command': 91,
  'right command': 93,
  'numpad *': 106,
  'numpad +': 107,
  'numpad -': 109,
  'numpad .': 110,
  'numpad /': 111,
  'num lock': 144,
  'scroll lock': 145,
  'my computer': 182,
  'my calculator': 183,
  ';': 186,
  '=': 187,
  ',': 188,
  '-': 189,
  '.': 190,
  '/': 191,
  '`': 192,
  '[': 219,
  '\\': 220,
  ']': 221,
  "'": 222
};

// Helper aliases

var aliases = exports.aliases = {
  'windows': 91,
  '': 16,
  '': 18,
  '': 17,
  '': 91,
  'ctl': 17,
  'control': 17,
  'option': 18,
  'pause': 19,
  'break': 19,
  'caps': 20,
  'return': 13,
  'escape': 27,
  'spc': 32,
  'spacebar': 32,
  'pgup': 33,
  'pgdn': 34,
  'ins': 45,
  'del': 46,
  'cmd': 91
};

/*!
 * Programatically add the following
 */

// lower case chars
for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32;

// numbers
for (var i = 48; i < 58; i++) codes[i - 48] = i;

// function keys
for (i = 1; i < 13; i++) codes['f'+i] = i + 111;

// numpad keys
for (i = 0; i < 10; i++) codes['numpad '+i] = i + 96;

/**
 * Get by code
 *
 *   exports.name[13] // => 'Enter'
 */

var names = exports.names = exports.title = {}; // title for backward compat

// Create reverse mapping
for (i in codes) names[codes[i]] = i;

// Add aliases
for (var alias in aliases) {
  codes[alias] = aliases[alias];
}
});
var keycode_1 = keycode.code;
var keycode_2 = keycode.codes;
var keycode_3 = keycode.aliases;
var keycode_4 = keycode.names;
var keycode_5 = keycode.title;

var codeData = {
  "+": "plus",
  "left command": "meta",
  "right command": "meta"
};
var keysSort = {
  shift: 1,
  ctrl: 2,
  alt: 3,
  meta: 4
};
/**
 * @memberof KeyController
 */

function getKey(keyCode) {
  var key = keycode_4[keyCode] || "";

  for (var name in codeData) {
    key = key.replace(name, codeData[name]);
  }

  return key.replace(/\s/g, "");
}
/**
 * @memberof KeyController
 */

function getCombi(e, key) {
  if (key === void 0) {
    key = getKey(e.keyCode);
  }

  var keys = getModifierCombi(e);
  keys.indexOf(key) === -1 && keys.push(key);
  return keys.filter(Boolean);
}
/**
 * @memberof KeyController
 */

function getModifierCombi(e) {
  var keys = [e.shiftKey && "shift", e.ctrlKey && "ctrl", e.altKey && "alt", e.metaKey && "meta"];
  return keys.filter(Boolean);
}

function getArrangeCombi(keys) {
  var arrangeKeys = keys.slice();
  arrangeKeys.sort(function (prev, next) {
    var prevScore = keysSort[prev] || 5;
    var nextScore = keysSort[next] || 5;
    return prevScore - nextScore;
  });
  return arrangeKeys;
}

var globalKeyController;
/**
 */

var KeyController =
/*#__PURE__*/
function (_super) {
  __extends(KeyController, _super);
  /**
   *
   */


  function KeyController(container) {
    if (container === void 0) {
      container = window;
    }

    var _this = _super.call(this) || this;

    _this.container = container;
    /**
     */

    _this.ctrlKey = false;
    /**
     */

    _this.altKey = false;
    /**
     *
     */

    _this.shiftKey = false;
    /**
     *
     */

    _this.metaKey = false;

    _this.clear = function () {
      _this.ctrlKey = false;
      _this.altKey = false;
      _this.shiftKey = false;
      _this.metaKey = false;
      return _this;
    };

    _this.keydownEvent = function (e) {
      _this.triggerEvent("keydown", e);
    };

    _this.keyupEvent = function (e) {
      _this.triggerEvent("keyup", e);
    };

    _this.blur = function () {
      _this.clear();

      _this.trigger("blur");
    };

    addEvent(container, "blur", _this.blur);
    addEvent(container, "keydown", _this.keydownEvent);
    addEvent(container, "keyup", _this.keyupEvent);
    return _this;
  }

  var __proto = KeyController.prototype;
  Object.defineProperty(KeyController, "global", {
    /**
     */
    get: function () {
      return globalKeyController || (globalKeyController = new KeyController());
    },
    enumerable: false,
    configurable: true
  });

  KeyController.setGlobal = function () {
    return this.global;
  };
  /**
   *
   */


  __proto.destroy = function () {
    var container = this.container;
    this.clear();
    this.off();
    removeEvent(container, "blur", this.blur);
    removeEvent(container, "keydown", this.keydownEvent);
    removeEvent(container, "keyup", this.keyupEvent);
  };
  /**
   *
   */


  __proto.keydown = function (comb, callback) {
    return this.addEvent("keydown", comb, callback);
  };
  /**
   *
   */


  __proto.offKeydown = function (comb, callback) {
    return this.removeEvent("keydown", comb, callback);
  };
  /**
   *
   */


  __proto.offKeyup = function (comb, callback) {
    return this.removeEvent("keyup", comb, callback);
  };
  /**
   *
   */


  __proto.keyup = function (comb, callback) {
    return this.addEvent("keyup", comb, callback);
  };

  __proto.addEvent = function (type, comb, callback) {
    if (isArray(comb)) {
      this.on(type + "." + getArrangeCombi(comb).join("."), callback);
    } else if (isString(comb)) {
      this.on(type + "." + comb, callback);
    } else {
      this.on(type, comb);
    }

    return this;
  };

  __proto.removeEvent = function (type, comb, callback) {
    if (isArray(comb)) {
      this.off(type + "." + getArrangeCombi(comb).join("."), callback);
    } else if (isString(comb)) {
      this.off(type + "." + comb, callback);
    } else {
      this.off(type, comb);
    }

    return this;
  };

  __proto.triggerEvent = function (type, e) {
    this.ctrlKey = e.ctrlKey;
    this.shiftKey = e.shiftKey;
    this.altKey = e.altKey;
    this.metaKey = e.metaKey;
    var key = getKey(e.keyCode);
    var isToggle = key === "ctrl" || key === "shift" || key === "meta" || key === "alt";
    var param = {
      key: key,
      isToggle: isToggle,
      inputEvent: e,
      keyCode: e.keyCode,
      ctrlKey: e.ctrlKey,
      altKey: e.altKey,
      shiftKey: e.shiftKey,
      metaKey: e.metaKey
    };
    this.trigger(type, param);
    this.trigger(type + "." + key, param);
    var combi = getCombi(e, key);
    combi.length > 1 && this.trigger(type + "." + combi.join("."), param);
  };

  return KeyController;
}(EventEmitter);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyController);

//# sourceMappingURL=keycon.esm.js.map


/***/ }),

/***/ "./.yarn/cache/moveable-npm-0.30.0-4e08a73dff-de79554307.zip/node_modules/moveable/dist/moveable.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EVENTS": () => (/* binding */ EVENTS),
/* harmony export */   "METHODS": () => (/* binding */ METHODS),
/* harmony export */   "PROPERTIES": () => (/* binding */ PROPERTIES),
/* harmony export */   "PROPS_MAP": () => (/* binding */ PROPS_MAP),
/* harmony export */   "default": () => (/* binding */ Moveable),
/* harmony export */   "getElementInfo": () => (/* binding */ getElementInfo),
/* harmony export */   "makeAble": () => (/* binding */ makeAble)
/* harmony export */ });
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/* harmony import */ var react_simple_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-simple-compat-npm-1.2.2-3585e7b9b0-a594292328.zip/node_modules/react-simple-compat/dist/compat.esm.js");
/* harmony import */ var react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/react-compat-moveable-virtual-8c7ca97ab7/0/cache/react-compat-moveable-npm-0.18.0-a400e205d6-f63b5cb9b8.zip/node_modules/react-compat-moveable/dist/moveable.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.7.0-2985f74485-5ffaae9194.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/moveable
version: 0.30.0
*/






/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

var InnerMoveable =
/*#__PURE__*/
function (_super) {
  __extends(InnerMoveable, _super);

  function InnerMoveable(props) {
    var _this = _super.call(this, props) || this;

    _this.state = {};
    _this.state = _this.props;
    return _this;
  }

  var __proto = InnerMoveable.prototype;

  __proto.render = function () {
    return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createPortal)(react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createElement(react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__["default"], __assign$1({
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.ref)(this, "moveable")
    }, this.state)), this.state.parentElement);
  };

  return InnerMoveable;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.Component);

var PROPERTIES = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_PROPS;
var METHODS = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_METHODS;
var EVENTS = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_EVENTS;
var PROPS_MAP = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_PROPS_MAP;

/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.5
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

var EventEmitter$1 = EventEmitter;

/**
 * Moveable is Draggable! Resizable! Scalable! Rotatable!
 * @sort 1
 * @alias Moveable
 * @extends EventEmitter
 */

var MoveableManager =
/*#__PURE__*/
function (_super) {
  __extends(MoveableManager, _super);
  /**
   *
   */


  function MoveableManager(parentElement, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.tempElement = document.createElement("div");

    var nextOptions = __assign$1({}, options);

    var events = {};
    EVENTS.forEach(function (name) {
      events[(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.camelize)("on ".concat(name))] = function (e) {
        return _this.trigger(name, e);
      };
    });
    (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.render)(react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerMoveable, __assign$1({
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.ref)(_this, "innerMoveable"),
      parentElement: parentElement
    }, nextOptions, events)), _this.tempElement);
    var target = nextOptions.target;

    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target) && target.length > 1) {
      _this.updateRect();
    }

    return _this;
  }

  var __proto = MoveableManager.prototype;

  __proto.setState = function (state, callback) {
    this.innerMoveable.setState(state, callback);
  };

  __proto.forceUpdate = function (callback) {
    this.innerMoveable.forceUpdate(callback);
  };

  __proto.dragStart = function (e) {
    var innerMoveable = this.innerMoveable;

    if (innerMoveable.$_timer) {
      this.forceUpdate();
    }

    this.getMoveable().dragStart(e);
  };

  __proto.destroy = function () {
    (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.render)(null, this.tempElement);
    this.off();
    this.tempElement = null;
    this.innerMoveable = null;
  };

  __proto.getMoveable = function () {
    return this.innerMoveable.moveable;
  };

  MoveableManager = __decorate([(0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.Properties)(METHODS, function (prototype, property) {
    if (prototype[property]) {
      return;
    }

    prototype[property] = function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var self = this.getMoveable();

      if (!self || !self[property]) {
        return;
      }

      return self[property].apply(self, args);
    };
  }), (0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.Properties)(PROPERTIES, function (prototype, property) {
    Object.defineProperty(prototype, property, {
      get: function () {
        return this.getMoveable().props[property];
      },
      set: function (value) {
        var _a;

        this.setState((_a = {}, _a[property] = value, _a));
      },
      enumerable: true,
      configurable: true
    });
  })], MoveableManager);
  return MoveableManager;
}(EventEmitter$1);

var Moveable =
/*#__PURE__*/
function (_super) {
  __extends(Moveable, _super);

  function Moveable() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return Moveable;
}(MoveableManager);

function getElementInfo(target, container, rootContainer) {
  return (0,react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.getElementInfo)(target, container, rootContainer);
}
function makeAble(name, able) {
  return (0,react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.makeAble)(name, able);
}


//# sourceMappingURL=moveable.esm.js.map


/***/ }),

/***/ "./.yarn/cache/overlap-area-npm-1.0.0-ece5a4fc6a-37d82ea4ea.zip/node_modules/overlap-area/dist/overlap-area.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertLines": () => (/* binding */ convertLines),
/* harmony export */   "fitPoints": () => (/* binding */ fitPoints),
/* harmony export */   "getAreaSize": () => (/* binding */ getAreaSize),
/* harmony export */   "getIntersectionPoints": () => (/* binding */ getIntersectionPoints),
/* harmony export */   "getIntersectionPointsByConstants": () => (/* binding */ getIntersectionPointsByConstants),
/* harmony export */   "getLinearConstants": () => (/* binding */ getLinearConstants),
/* harmony export */   "getMinMaxs": () => (/* binding */ getMinMaxs),
/* harmony export */   "getOverlapPoints": () => (/* binding */ getOverlapPoints),
/* harmony export */   "getOverlapSize": () => (/* binding */ getOverlapSize),
/* harmony export */   "getPointsOnLines": () => (/* binding */ getPointsOnLines),
/* harmony export */   "isInside": () => (/* binding */ isInside)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2020 Daybrush
name: overlap-area
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/overlap-area.git
version: 1.0.0
*/


/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * @namespace OverlapArea
 */

/**
 * Gets the size of a shape (polygon) made of points.
 * @memberof OverlapArea
 */

function getAreaSize(points) {
  if (points.length < 3) {
    return 0;
  }

  return Math.abs((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.sum)(points.map(function (point, i) {
    var nextPoint = points[i + 1] || points[0];
    return point[0] * nextPoint[1] - nextPoint[0] * point[1];
  }))) / 2;
}
/**
 * Get points that fit the rect,
 * @memberof OverlapArea
 */

function fitPoints(points, rect) {
  var width = rect.width,
      height = rect.height,
      left = rect.left,
      top = rect.top;

  var _a = getMinMaxs(points),
      minX = _a.minX,
      minY = _a.minY,
      maxX = _a.maxX,
      maxY = _a.maxY;

  var ratioX = width / (maxX - minX);
  var ratioY = height / (maxY - minY);
  return points.map(function (point) {
    return [left + (point[0] - minX) * ratioX, top + (point[1] - minY) * ratioY];
  });
}
/**
 * Get the minimum and maximum points of the points.
 * @memberof OverlapArea
 */

function getMinMaxs(points) {
  var xs = points.map(function (point) {
    return point[0];
  });
  var ys = points.map(function (point) {
    return point[1];
  });
  return {
    minX: Math.min.apply(Math, xs),
    minY: Math.min.apply(Math, ys),
    maxX: Math.max.apply(Math, xs),
    maxY: Math.max.apply(Math, ys)
  };
}
/**
 * Whether the point is in shape
 * @param - point pos
 * @param - shape points
 * @param - whether to check except line
 * @memberof OverlapArea
 */

function isInside(pos, points, excludeLine) {
  var x = pos[0],
      y = pos[1];

  var _a = getMinMaxs(points),
      minX = _a.minX,
      minY = _a.minY,
      maxX = _a.maxX,
      maxY = _a.maxY;

  var xLine = [[minX, y], [maxX, y]];
  var yLine = [[x, minY], [x, maxY]];
  var xLinearConstants = getLinearConstants(xLine[0], xLine[1]);
  var yLinearConstants = getLinearConstants(yLine[0], yLine[1]);
  var lines = convertLines(points);
  var intersectionXPoints = [];
  var intersectionYPoints = [];
  lines.forEach(function (line) {
    var linearConstants = getLinearConstants(line[0], line[1]);
    var xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);
    var yPoints = getPointsOnLines(getIntersectionPointsByConstants(yLinearConstants, linearConstants), [yLine, line]);

    if (xPoints.length === 1 ? line[0][1] !== y : true) {
      intersectionXPoints.push.apply(intersectionXPoints, xPoints);
    }

    if (yPoints.length === 1 ? line[0][0] !== x : true) {
      intersectionYPoints.push.apply(intersectionYPoints, yPoints);
    }

    if (!linearConstants[0]) {
      intersectionXPoints.push.apply(intersectionXPoints, xPoints);
    }

    if (!linearConstants[1]) {
      intersectionYPoints.push.apply(intersectionYPoints, yPoints);
    }
  });

  if (!excludeLine) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(intersectionXPoints, function (p) {
      return p[0] === x;
    }) > -1 || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(intersectionYPoints, function (p) {
      return p[1] === y;
    }) > -1) {
      return true;
    }
  }

  if (intersectionXPoints.filter(function (p) {
    return p[0] > x;
  }).length % 2 && intersectionYPoints.filter(function (p) {
    return p[1] > y;
  }).length % 2) {
    return true;
  }

  return false;
}
/**
 * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)
 * @return [a, b, c]
 * @memberof OverlapArea
 */

function getLinearConstants(point1, point2) {
  var x1 = point1[0],
      y1 = point1[1];
  var x2 = point2[0],
      y2 = point2[1]; // ax + by + c = 0

  if (x1 === x2 && y1 === y2) {
    return [0, 0, 0];
  }

  if (x1 === x2) {
    // x = x1
    return [1, 0, -x1];
  } else if (y1 === y2) {
    // y = y1
    return [0, 1, -y1];
  } else {
    // x1 + a * y1 + b = 0
    // x2 + a * y2 + b = 0
    // (x1 -x2) + (y1 - y2) * a = 0
    // a = (x2 - x1) / (y1 - y2)
    // x1 + (x2 - x1) / (y1 - y2)
    var a_1 = (x2 - x1) / (y1 - y2);
    var b_1 = -x1 - a_1 * y1;
    return [1, a_1, b_1];
  }
}
/**
 * Get intersection points with linear functions.
 * @memberof OverlapArea
 */

function getIntersectionPointsByConstants(linearConstants1, linearConstants2) {
  var a1 = linearConstants1[0],
      b1 = linearConstants1[1],
      c1 = linearConstants1[2];
  var a2 = linearConstants2[0],
      b2 = linearConstants2[1],
      c2 = linearConstants2[2];
  var isZeroA = a1 === 0 && a2 === 0;
  var isZeroB = b1 === 0 && b2 === 0;

  if (isZeroA && isZeroB) {
    return [];
  } else if (isZeroA) {
    // b1 * y + c1 = 0
    // b2 * y + c2 = 0
    var y1 = -c1 / b1;
    var y2 = -c2 / b2;

    if (y1 !== y2) {
      return [];
    } else {
      return [[-Infinity, y1], [Infinity, y1]];
    }
  } else if (isZeroB) {
    // a1 * x + c1 = 0
    // a2 * x + c2 = 0
    var x1 = -c1 / a1;
    var x2 = -c2 / a2;

    if (x1 !== x2) {
      return [];
    } else {
      return [[x1, -Infinity], [x1, Infinity]];
    }
  } else if (a1 === 0) {
    // b1 * y + c1 = 0
    // y = - c1 / b1;
    // a2 * x + b2 * y + c2 = 0
    var y = -c1 / b1;
    var x = -(b2 * y + c2) / a2;
    return [[x, y]];
  } else if (a2 === 0) {
    // b2 * y + c2 = 0
    // y = - c2 / b2;
    // a1 * x + b1 * y + c1 = 0
    var y = -c2 / b2;
    var x = -(b1 * y + c1) / a1;
    return [[x, y]];
  } else if (b1 === 0) {
    // a1 * x + c1 = 0
    // x = - c1 / a1;
    // a2 * x + b2 * y + c2 = 0
    var x = -c1 / a1;
    var y = -(a2 * x + c2) / b2;
    return [[x, y]];
  } else if (b2 === 0) {
    // a2 * x + c2 = 0
    // x = - c2 / a2;
    // a1 * x + b1 * y + c1 = 0
    var x = -c2 / a2;
    var y = -(a1 * x + c1) / b1;
    return [[x, y]];
  } else {
    // a1 * x + b1 * y + c1 = 0
    // a2 * x + b2 * y + c2 = 0
    // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0
    // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0
    // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)
    var x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);
    var y = -(a1 * x + c1) / b1;
    return [[x, y]];
  }
}
/**
 * Get intersection points to the two lines.
 * @memberof OverlapArea
 */

function getIntersectionPoints(line1, line2, isLimit) {
  var points = getIntersectionPointsByConstants(getLinearConstants(line1[0], line1[1]), getLinearConstants(line2[0], line2[1]));

  if (isLimit) {
    return getPointsOnLines(points, [line1, line2]);
  }

  return points;
}
/**
 * Get the points on the lines (between two points).
 * @memberof OverlapArea
 */

function getPointsOnLines(points, lines) {
  var minMaxs = lines.map(function (line) {
    return [0, 1].map(function (order) {
      return [Math.min(line[0][order], line[1][order]), Math.max(line[0][order], line[1][order])];
    });
  });

  if (points.length === 2) {
    var _a = points[0],
        x = _a[0],
        y = _a[1];

    if (x === points[1][0]) {
      /// Math.max(minY1, minY2)
      var top = Math.max.apply(Math, minMaxs.map(function (minMax) {
        return minMax[1][0];
      })); /// Math.min(maxY1, miax2)

      var bottom = Math.min.apply(Math, minMaxs.map(function (minMax) {
        return minMax[1][1];
      }));

      if (top > bottom) {
        return [];
      }

      return [[x, top], [x, bottom]];
    } else if (y === points[1][1]) {
      /// Math.max(minY1, minY2)
      var left = Math.max.apply(Math, minMaxs.map(function (minMax) {
        return minMax[0][0];
      })); /// Math.min(maxY1, miax2)

      var right = Math.min.apply(Math, minMaxs.map(function (minMax) {
        return minMax[0][1];
      }));

      if (left > right) {
        return [];
      }

      return [[left, y], [right, y]];
    }
  }

  return points.filter(function (point) {
    return minMaxs.every(function (minMax) {
      return minMax[0][0] <= point[0] && point[0] <= minMax[0][1] && minMax[1][0] <= point[1] && point[1] <= minMax[1][1];
    });
  });
}
/**
* Convert two points into lines.
* @function
* @memberof OverlapArea
*/

function convertLines(points) {
  return __spreadArrays(points.slice(1), [points[0]]).map(function (point, i) {
    return [points[i], point];
  });
}
/**
* Get the points of the overlapped part of two shapes.
* @function
* @memberof OverlapArea
*/

function getOverlapPoints(points1, points2) {
  var targetPoints1 = points1.slice();
  var targetPoints2 = points2.slice();

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getShapeDirection)(targetPoints1) === -1) {
    targetPoints1.reverse();
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getShapeDirection)(targetPoints2) === -1) {
    targetPoints2.reverse();
  }

  var lines1 = convertLines(targetPoints1);
  var lines2 = convertLines(targetPoints2);
  var linearConstantss1 = lines1.map(function (line1) {
    return getLinearConstants(line1[0], line1[1]);
  });
  var linearConstantss2 = lines2.map(function (line2) {
    return getLinearConstants(line2[0], line2[1]);
  });
  var overlapInfos = [];
  linearConstantss1.forEach(function (linearConstants1, i) {
    var line1 = lines1[i];
    var linePointInfos = [];
    linearConstantss2.forEach(function (linearConstants2, j) {
      var intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);
      var points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);
      linePointInfos.push.apply(linePointInfos, points.map(function (pos) {
        return {
          index1: i,
          index2: j,
          pos: pos
        };
      }));
    });
    linePointInfos.sort(function (a, b) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(line1[0], a.pos) - (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(line1[0], b.pos);
    });
    overlapInfos.push.apply(overlapInfos, linePointInfos);

    if (isInside(line1[1], targetPoints2)) {
      overlapInfos.push({
        index1: i,
        index2: -1,
        pos: line1[1]
      });
    }
  });
  lines2.forEach(function (line2, i) {
    if (isInside(line2[1], targetPoints1)) {
      var isNext_1 = false;
      var index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(overlapInfos, function (_a) {
        var index2 = _a.index2;

        if (index2 === i) {
          isNext_1 = true;
          return false;
        }

        if (isNext_1) {
          return true;
        }

        return false;
      });

      if (index === -1) {
        isNext_1 = false;
        index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(overlapInfos, function (_a) {
          var index1 = _a.index1,
              index2 = _a.index2;

          if (index1 === -1 && index2 + 1 === i) {
            isNext_1 = true;
            return false;
          }

          if (isNext_1) {
            return true;
          }

          return false;
        });
      }

      if (index === -1) {
        overlapInfos.push({
          index1: -1,
          index2: i,
          pos: line2[1]
        });
      } else {
        overlapInfos.splice(index, 0, {
          index1: -1,
          index2: i,
          pos: line2[1]
        });
      }
    }
  }); // console.log(overlapInfos);

  var overlapPoints = overlapInfos.map(function (_a) {
    var pos = _a.pos;
    return pos;
  });
  var pointMap = {};
  return overlapPoints.filter(function (point) {
    var key = point[0] + "x" + point[1];

    if (pointMap[key]) {
      return false;
    }

    pointMap[key] = true;
    return true;
  });
}
/**
* Gets the size of the overlapped part of two shapes.
* @function
* @memberof OverlapArea
*/

function getOverlapSize(points1, points2) {
  var points = getOverlapPoints(points1, points2);
  return getAreaSize(points);
}


//# sourceMappingURL=overlap-area.esm.js.map


/***/ }),

/***/ "./.yarn/cache/react-compat-css-styled-npm-1.0.8-52211d26f8-7a8e51849e.zip/node_modules/react-compat-css-styled/dist/styled.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyledElement": () => (/* binding */ StyledElement),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var css_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/css-styled-virtual-9ef8f05de2/0/cache/css-styled-npm-1.0.0-5104a882d5-3f2f995938.zip/node_modules/css-styled/dist/styled.esm.js");
/* harmony import */ var react_simple_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-simple-compat-npm-1.2.2-3585e7b9b0-a594292328.zip/node_modules/react-simple-compat/dist/compat.esm.js");
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/*
Copyright (c) Daybrush
name: react-compat-css-styled
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-styled.git
version: 1.0.8
*/




/*
Copyright (c) 2019 Daybrush
name: react-css-styled
license: MIT
author: Daybrush
repository: https://github.com/daybrush/css-styled/tree/master/packages/react-css-styled
version: 1.0.3
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

var StyledElement =
/*#__PURE__*/
function (_super) {
  __extends(StyledElement, _super);

  function StyledElement() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.injectResult = null;
    _this.tag = "div";
    return _this;
  }

  var __proto = StyledElement.prototype;

  __proto.render = function () {
    var _a = this.props,
        _b = _a.className,
        className = _b === void 0 ? "" : _b,
        cspNonce = _a.cspNonce,
        portalContainer = _a.portalContainer,
        attributes = __rest(_a, ["className", "cspNonce", "portalContainer"]);

    var cssId = this.injector.className;
    var Tag = this.tag;
    var portalAttributes = {};

    if ((react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.version || "").indexOf("simple") > -1 && portalContainer) {
      portalAttributes = {
        portalContainer: portalContainer
      };
    }

    return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createElement)(Tag, __assign({
      "ref": (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "element"),
      "data-styled-id": cssId,
      "className": className + " " + cssId
    }, portalAttributes, attributes));
  };

  __proto.componentDidMount = function () {
    this.injectResult = this.injector.inject(this.element, {
      nonce: this.props.cspNonce
    });
  };

  __proto.componentWillUnmount = function () {
    this.injectResult.destroy();
    this.injectResult = null;
  };

  __proto.getElement = function () {
    return this.element;
  };

  return StyledElement;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.Component);

function styled(tag, css) {
  var injector = (0,css_styled__WEBPACK_IMPORTED_MODULE_2__["default"])(css);
  return (
    /*#__PURE__*/
    function (_super) {
      __extends(Styled, _super);

      function Styled() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.injector = injector;
        _this.tag = tag;
        return _this;
      }

      return Styled;
    }(StyledElement)
  );
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (styled);



/***/ }),

/***/ "./.yarn/cache/react-simple-compat-npm-1.2.2-3585e7b9b0-a594292328.zip/node_modules/react-simple-compat/dist/compat.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Component": () => (/* binding */ Component),
/* harmony export */   "PureComponent": () => (/* binding */ PureComponent),
/* harmony export */   "createElement": () => (/* binding */ createElement),
/* harmony export */   "createPortal": () => (/* binding */ createPortal),
/* harmony export */   "findDOMNode": () => (/* binding */ findDOMNode),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var _egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@egjs-list-differ-npm-1.0.0-f4b91781db-d1827d134d.zip/node_modules/@egjs/list-differ/dist/list-differ.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) Daybrush
name: react-simple-compat
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/react-simple-compat.git
version: 1.2.2
*/



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

function isDiff(a, b) {
  if (a === b) {
    return false;
  }

  for (var i in a) {
    if (!(i in b)) {
      return true;
    }
  }

  for (var i in b) {
    if (a[i] !== b[i]) {
      return true;
    }
  }

  return false;
}

function diffObject(a, b) {
  var keys1 = Object.keys(a);
  var keys2 = Object.keys(b);
  var result = (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__.diff)(keys1, keys2, function (key) {
    return key;
  });
  var added = {};
  var removed = {};
  var changed = {};
  result.added.forEach(function (index) {
    var name = keys2[index];
    added[name] = b[name];
  });
  result.removed.forEach(function (index) {
    var name = keys1[index];
    removed[name] = a[name];
  });
  result.maintained.forEach(function (_a) {
    var index = _a[0];
    var name = keys1[index];
    var values = [a[name], b[name]];

    if (a[name] !== b[name]) {
      changed[name] = values;
    }
  });
  return {
    added: added,
    removed: removed,
    changed: changed
  };
}

function executeHooks(hooks) {
  hooks.forEach(function (hook) {
    hook();
  });
}

function fillKeys(keys) {
  var index = 0;
  return keys.map(function (key) {
    return key == null ? "$compat" + ++index : "" + key;
  });
}

function createProvider(el, key, index, container) {
  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(el) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(el)) {
    return new TextProvider("text_" + el, key, index, container, null, {});
  }

  var providerClass = typeof el.type === "string" ? ElementProvider : el.type.prototype.render ? ComponentProvider : FunctionProvider;
  return new providerClass(el.type, key, index, container, el.ref, el.props);
}

function flat(arr) {
  var arr2 = [];
  arr.forEach(function (el) {
    arr2 = arr2.concat((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(el) ? flat(el) : el);
  });
  return arr2;
}

function getAttributes(props) {
  var className = props.className,
      otherProps = __rest(props, ["className"]);

  if (className != null) {
    otherProps.class = className;
  }

  delete otherProps.style;
  delete otherProps.children;
  return otherProps;
}

function fillProps(props, defaultProps) {
  if (!defaultProps) {
    return props;
  }

  for (var name in defaultProps) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(props[name])) {
      props[name] = defaultProps[name];
    }
  }

  return props;
}

function createElement(type, props) {
  var children = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }

  var _a = props || {},
      key = _a.key,
      ref = _a.ref,
      otherProps = __rest(_a, ["key", "ref"]);

  return {
    type: type,
    key: key,
    ref: ref,
    props: __assign(__assign({}, otherProps), {
      children: flat(children).filter(function (child) {
        return child != null && child !== false;
      })
    })
  };
}

var Provider =
/*#__PURE__*/
function () {
  function Provider(type, key, index, container, ref, props) {
    if (props === void 0) {
      props = {};
    }

    this.type = type;
    this.key = key;
    this.index = index;
    this.container = container;
    this.ref = ref;
    this.props = props;
    this._providers = [];
  }

  var __proto = Provider.prototype;

  __proto._should = function (nextProps, nextState) {
    return true;
  };

  __proto._update = function (hooks, nextElement, nextState, isForceUpdate) {
    if (this.base && !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(nextElement) && !isForceUpdate && !this._should(nextElement.props, nextState)) {
      return false;
    }

    this.original = nextElement;

    this._setState(nextState); // render


    var prevProps = this.props;

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(nextElement)) {
      this.props = nextElement.props;
      this.ref = nextElement.ref;
    }

    this._render(hooks, this.base ? prevProps : {}, nextState);

    return true;
  };

  __proto._mounted = function () {
    var ref = this.ref;
    ref && ref(this.base);
  };

  __proto._setState = function (nextstate) {
    return;
  };

  __proto._updated = function () {
    var ref = this.ref;
    ref && ref(this.base);
  };

  __proto._destroy = function () {
    var ref = this.ref;
    ref && ref(null);
  };

  return Provider;
}();

function diffAttributes(attrs1, attrs2, el) {
  var _a = diffObject(attrs1, attrs2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var name in added) {
    el.setAttribute(name, added[name]);
  }

  for (var name in changed) {
    el.setAttribute(name, changed[name][1]);
  }

  for (var name in removed) {
    el.removeAttribute(name);
  }
}

function diffEvents(events1, events2, provier) {
  var _a = diffObject(events1, events2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var name in removed) {
    provier.removeEventListener(name);
  }

  for (var name in added) {
    provier.addEventListener(name, added[name]);
  }

  for (var name in changed) {
    provier.removeEventListener(name);
    provier.addEventListener(name, changed[name][1]);
  }

  for (var name in removed) {
    provier.removeEventListener(name);
  }
}

function diffStyle(style1, style2, el) {
  var style = el.style;

  var _a = diffObject(style1, style2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var beforeName in added) {
    var name = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.decamelize)(beforeName, "-");

    if (style.setProperty) {
      style.setProperty(name, added[beforeName]);
    } else {
      style[name] = added[beforeName];
    }
  }

  for (var beforeName in changed) {
    var name = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.decamelize)(beforeName, "-");

    if (style.setProperty) {
      style.setProperty(name, changed[beforeName][1]);
    } else {
      style[name] = changed[beforeName][1];
    }
  }

  for (var beforeName in removed) {
    var name = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.decamelize)(beforeName, "-");

    if (style.removeProperty) {
      style.removeProperty(name);
    } else {
      style[name] = "";
    }
  }
}

function splitProps(props) {
  var attributes = {};
  var events = {};

  for (var name in props) {
    if (name.indexOf("on") === 0) {
      events[name.replace("on", "").toLowerCase()] = props[name];
    } else {
      attributes[name] = props[name];
    }
  }

  return {
    attributes: attributes,
    events: events
  };
}

var TextProvider =
/*#__PURE__*/
function (_super) {
  __extends(TextProvider, _super);

  function TextProvider() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = TextProvider.prototype;

  __proto._render = function (hooks) {
    var _this = this;

    var isMount = !this.base;

    if (isMount) {
      this.base = document.createTextNode(this.type.replace("text_", ""));
    }

    hooks.push(function () {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };

  __proto._unmount = function () {
    this.base.parentNode.removeChild(this.base);
  };

  return TextProvider;
}(Provider);

var ElementProvider =
/*#__PURE__*/
function (_super) {
  __extends(ElementProvider, _super);

  function ElementProvider() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.events = {};
    _this._isSVG = false;
    return _this;
  }

  var __proto = ElementProvider.prototype;

  __proto.addEventListener = function (name, callback) {
    var events = this.events;

    events[name] = function (e) {
      e.nativeEvent = e;
      callback(e);
    };

    this.base.addEventListener(name, events[name]);
  };

  __proto.removeEventListener = function (name) {
    var events = this.events;
    this.base.removeEventListener(name, events[name]);
    delete events[name];
  };

  __proto._should = function (nextProps) {
    return isDiff(this.props, nextProps);
  };

  __proto._render = function (hooks, prevProps) {
    var _this = this;

    var isMount = !this.base;

    if (isMount) {
      var isSVG = this._hasSVG();

      this._isSVG = isSVG;
      var element = this.props.portalContainer;

      if (!element) {
        var type = this.type;

        if (isSVG) {
          element = document.createElementNS("http://www.w3.org/2000/svg", type);
        } else {
          element = document.createElement(type);
        }
      }

      this.base = element;
    }

    renderProviders(this, this._providers, this.props.children, hooks, null);
    var base = this.base;

    var _a = splitProps(prevProps),
        prevAttributes = _a.attributes,
        prevEvents = _a.events;

    var _b = splitProps(this.props),
        nextAttributes = _b.attributes,
        nextEvents = _b.events;

    diffAttributes(getAttributes(prevAttributes), getAttributes(nextAttributes), base);
    diffEvents(prevEvents, nextEvents, this);
    diffStyle(prevProps.style || {}, this.props.style || {}, base);
    hooks.push(function () {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };

  __proto._unmount = function () {
    var events = this.events;
    var base = this.base;

    for (var name in events) {
      base.removeEventListener(name, events[name]);
    }

    this._providers.forEach(function (provider) {
      provider._unmount();
    });

    this.events = {};

    if (!this.props.portalContainer) {
      base.parentNode.removeChild(base);
    }
  };

  __proto._hasSVG = function () {
    if (this._isSVG || this.type === "svg") {
      return true;
    }

    var containerNode = findContainerNode(this.container);
    return containerNode && "ownerSVGElement" in containerNode;
  };

  return ElementProvider;
}(Provider);

function findContainerNode(provider) {
  if (!provider) {
    return null;
  }

  var base = provider.base;

  if (base instanceof Node) {
    return base;
  }

  return findContainerNode(provider.container);
}

function findDOMNode(comp) {
  if (!comp) {
    return null;
  }

  if (comp instanceof Node) {
    return comp;
  }

  var providers = comp.$_provider._providers;

  if (!providers.length) {
    return null;
  }

  return findDOMNode(providers[0].base);
}

var FunctionProvider =
/*#__PURE__*/
function (_super) {
  __extends(FunctionProvider, _super);

  function FunctionProvider() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = FunctionProvider.prototype;

  __proto._render = function (hooks) {
    var template = this.type(this.props);
    renderProviders(this, this._providers, template ? [template] : [], hooks);
    return true;
  };

  __proto._unmount = function () {
    this._providers.forEach(function (provider) {
      provider._unmount();
    });
  };

  return FunctionProvider;
}(Provider);

var ContainerProvider =
/*#__PURE__*/
function (_super) {
  __extends(ContainerProvider, _super);

  function ContainerProvider(base) {
    var _this = _super.call(this, "container", "container", 0, null) || this;

    _this.base = base;
    return _this;
  }

  var __proto = ContainerProvider.prototype;

  __proto._render = function () {
    return true;
  };

  __proto._unmount = function () {
    return;
  };

  return ContainerProvider;
}(Provider);

var ComponentProvider =
/*#__PURE__*/
function (_super) {
  __extends(ComponentProvider, _super);

  function ComponentProvider(type, key, index, container, ref, props) {
    if (props === void 0) {
      props = {};
    }

    return _super.call(this, type, key, index, container, ref, fillProps(props, type.defaultProps)) || this;
  }

  var __proto = ComponentProvider.prototype;

  __proto._should = function (nextProps, nextState) {
    return this.base.shouldComponentUpdate(fillProps(nextProps, this.type.defaultProps), nextState || this.base.state);
  };

  __proto._render = function (hooks, prevProps, nextState) {
    var _this = this;

    this.props = fillProps(this.props, this.type.defaultProps);
    var isMount = !this.base;

    if (isMount) {
      this.base = new this.type(this.props);
      this.base.$_provider = this;
    } else {
      this.base.props = this.props;
    }

    var base = this.base;
    var prevState = base.state;
    var template = base.render();

    if (template && template.props && !template.props.children.length) {
      template.props.children = this.props.children;
    }

    renderProviders(this, this._providers, template ? [template] : [], hooks, nextState, null);
    hooks.push(function () {
      if (isMount) {
        _this._mounted();

        base.componentDidMount();
      } else {
        _this._updated();

        base.componentDidUpdate(prevProps, prevState);
      }
    });
  };

  __proto._setState = function (nextState) {
    var base = this.base;

    if (!base || !nextState) {
      return;
    }

    base.state = nextState;
  };

  __proto._unmount = function () {
    this._providers.forEach(function (provider) {
      provider._unmount();
    });

    clearTimeout(this.base.$_timer);
    this.base.componentWillUnmount();
  };

  return ComponentProvider;
}(Provider);

var Component =
/*#__PURE__*/
function () {
  function Component(props) {
    if (props === void 0) {
      props = {};
    }

    this.props = props;
    this.state = {};
    this.$_timer = 0;
    this.$_state = {};
  }

  var __proto = Component.prototype;

  __proto.shouldComponentUpdate = function (props, state) {
    return true;
  };

  __proto.render = function () {
    return null;
  };

  __proto.setState = function (state, callback, isForceUpdate) {
    var _this = this;

    if (!this.$_timer) {
      this.$_state = {};
    }

    clearTimeout(this.$_timer);
    this.$_timer = 0;
    this.$_state = __assign(__assign({}, this.$_state), state);

    if (!isForceUpdate) {
      this.$_timer = setTimeout(function () {
        _this.$_timer = 0;

        _this.$_setState(callback, isForceUpdate);
      });
    } else {
      this.$_setState(callback, isForceUpdate);
    }

    return;
  };

  __proto.forceUpdate = function (callback) {
    this.setState({}, callback, true);
  };

  __proto.componentDidMount = function () {};

  __proto.componentDidUpdate = function (prevProps, prevState) {};

  __proto.componentWillUnmount = function () {};

  __proto.$_setState = function (callback, isForceUpdate) {
    var hooks = [];
    var provider = this.$_provider;
    var isUpdate = renderProviders(provider.container, [provider], [provider.original], hooks, __assign(__assign({}, this.state), this.$_state), isForceUpdate);

    if (isUpdate) {
      if (callback) {
        hooks.push(callback);
      }

      executeHooks(hooks);
    }
  };

  return Component;
}();

var PureComponent =
/*#__PURE__*/
function (_super) {
  __extends(PureComponent, _super);

  function PureComponent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = PureComponent.prototype;

  __proto.shouldComponentUpdate = function (props, state) {
    return isDiff(this.props, props) || isDiff(this.state, state);
  };

  return PureComponent;
}(Component);

var _Portal =
/*#__PURE__*/
function (_super) {
  __extends(_Portal, _super);

  function _Portal() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = _Portal.prototype;

  __proto.componentDidMount = function () {
    var _a = this.props,
        element = _a.element,
        container = _a.container;
    this._portalProvider = new ContainerProvider(container);
    renderProvider(element, container, this._portalProvider);
  };

  __proto.componentDidUpdate = function () {
    var _a = this.props,
        element = _a.element,
        container = _a.container;
    renderProvider(element, container, this._portalProvider);
  };

  __proto.componentWillUnmount = function () {
    var container = this.props.container;
    renderProvider(null, container, this._portalProvider);
    this._portalProvider = null;
  };

  return _Portal;
}(PureComponent);

function updateProvider(provider, children, nextState) {
  var hooks = [];
  renderProviders(provider, provider._providers, children, hooks, nextState);
  executeHooks(hooks);
}

function getNextSibiling(provider, childProvider) {
  var childProviders = provider._providers;
  var length = childProviders.length;

  for (var i = childProvider.index + 1; i < length; ++i) {
    var el = findDOMNode(childProviders[i].base);

    if (el) {
      return el;
    }
  }

  return null;
}

function diffProviders(containerProvider, providers, children) {
  var childrenKeys = children.map(function (p) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(p) ? null : p.key;
  });
  var keys1 = fillKeys(providers.map(function (p) {
    return p.key;
  }));
  var keys2 = fillKeys(childrenKeys);
  var result = (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__.diff)(keys1, keys2, function (key) {
    return key;
  });
  result.removed.forEach(function (index) {
    providers.splice(index, 1)[0]._unmount();
  });
  result.ordered.forEach(function (_a) {
    var from = _a[0],
        to = _a[1];
    var childrenProvider = providers.splice(from, 1)[0];
    providers.splice(to, 0, childrenProvider);
    var el = findDOMNode(childrenProvider.base);
    var next = findDOMNode(providers[to + 1] && providers[to + 1].base);

    if (el) {
      el.parentNode.insertBefore(el, next);
    }
  });
  result.added.forEach(function (index) {
    providers.splice(index, 0, createProvider(children[index], childrenKeys[index], index, containerProvider));
  });
  var changed = result.maintained.filter(function (_a) {
    var _ = _a[0],
        to = _a[1];
    var el = children[to];
    var childProvider = providers[to];
    var type = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(el) ? "text_" + el : el.type;

    if (type !== childProvider.type) {
      childProvider._unmount();

      providers.splice(to, 1, createProvider(el, childrenKeys[to], to, containerProvider));
      return true;
    }

    childProvider.index = to;
    return false;
  });
  return __spreadArrays(result.added, changed.map(function (_a) {
    var _ = _a[0],
        to = _a[1];
    return to;
  }));
}

function renderProviders(containerProvider, providers, children, updatedHooks, nextState, isForceUpdate) {
  var result = diffProviders(containerProvider, providers, children);
  var updated = providers.filter(function (childProvider, i) {
    return childProvider._update(updatedHooks, children[i], nextState, isForceUpdate);
  });
  var containerNode = findContainerNode(containerProvider);

  if (containerNode) {
    result.reverse().forEach(function (index) {
      var childProvider = providers[index];
      var el = findDOMNode(childProvider.base);

      if (!el) {
        return;
      }

      if (containerNode !== el && !el.parentNode) {
        var nextElement = getNextSibiling(containerProvider, childProvider);
        containerNode.insertBefore(el, nextElement);
      }
    });
  }

  return updated.length > 0;
}

function renderProvider(element, container, provider) {
  if (provider === void 0) {
    provider = container.__REACT_COMPAT__;
  }

  var isProvider = !!provider;

  if (!provider) {
    provider = new ContainerProvider(container);
  }

  updateProvider(provider, element ? [element] : []);

  if (!isProvider) {
    container.__REACT_COMPAT__ = provider;
  }

  return provider;
}

function render(element, container, callback) {
  var provider = container.__REACT_COMPAT__;

  if (element && !provider) {
    container.innerHTML = "";
  }

  renderProvider(element, container, provider);
  callback && callback();
}
function createPortal(el, container) {
  return createElement(_Portal, {
    element: el,
    container: container
  });
}
var version = "simple-1.1.0";


//# sourceMappingURL=compat.esm.js.map


/***/ }),

/***/ "./.yarn/cache/selecto-npm-1.16.2-b4fff537b7-a838944964.zip/node_modules/selecto/dist/selecto.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CLASS_NAME": () => (/* binding */ CLASS_NAME),
/* harmony export */   "EVENTS": () => (/* binding */ EVENTS),
/* harmony export */   "METHODS": () => (/* binding */ METHODS),
/* harmony export */   "OPTIONS": () => (/* binding */ OPTIONS),
/* harmony export */   "OPTION_TYPES": () => (/* binding */ OPTION_TYPES),
/* harmony export */   "PROPERTIES": () => (/* binding */ PROPERTIES),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js");
/* harmony import */ var gesto__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/gesto-npm-1.7.0-7d5440000b-f2a66bcf0f.zip/node_modules/gesto/dist/gesto.esm.js");
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/* harmony import */ var _egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@egjs-children-differ-npm-1.0.1-37f45ddf97-087f286822.zip/node_modules/@egjs/children-differ/dist/children-differ.esm.js");
/* harmony import */ var _scena_dragscroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/@scena-dragscroll-npm-1.1.1-8fe60775f9-aacb335870.zip/node_modules/@scena/dragscroll/dist/dragscroll.esm.js");
/* harmony import */ var keycon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/keycon-npm-1.1.2-47bb5048df-7be74aaf83.zip/node_modules/keycon/dist/keycon.esm.js");
/* harmony import */ var overlap_area__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/overlap-area-npm-1.0.0-ece5a4fc6a-37d82ea4ea.zip/node_modules/overlap-area/dist/overlap-area.esm.js");
/* harmony import */ var css_to_mat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/css-to-mat-npm-1.0.3-8a69ed71de-a3fc98bfad.zip/node_modules/css-to-mat/dist/css-to-mat.esm.js");
/* harmony import */ var css_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/css-styled-virtual-9ef8f05de2/0/cache/css-styled-npm-1.0.0-5104a882d5-3f2f995938.zip/node_modules/css-styled/dist/styled.esm.js");
/*
Copyright (c) 2020 Daybrush
name: selecto
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/selecto.git
version: 1.16.2
*/











/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

function getClient(e) {
  if ("touches" in e) {
    var touch = e.touches[0] || e.changedTouches[0];
    return {
      clientX: touch.clientX,
      clientY: touch.clientY
    };
  } else {
    return {
      clientX: e.clientX,
      clientY: e.clientY
    };
  }
}
function createElement(jsx, prevTarget, container) {
  var tag = jsx.tag,
      children = jsx.children,
      attributes = jsx.attributes,
      className = jsx.className,
      style = jsx.style;
  var el = prevTarget || document.createElement(tag);

  for (var name in attributes) {
    el.setAttribute(name, attributes[name]);
  }

  var elChildren = el.children;
  children.forEach(function (child, i) {
    createElement(child, elChildren[i], el);
  });

  if (className) {
    className.split(" ").forEach(function (name) {
      if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(el, name)) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addClass)(el, name);
      }
    });
  }

  if (style) {
    var elStyle = el.style;

    for (var name in style) {
      elStyle[name] = style[name];
    }
  }

  if (!prevTarget && container) {
    container.appendChild(el);
  }

  return el;
}
function h(tag, attrs) {
  var children = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }

  var _a = attrs || {},
      _b = _a.className,
      className = _b === void 0 ? "" : _b,
      _c = _a.style,
      style = _c === void 0 ? {} : _c,
      attributes = __rest(_a, ["className", "style"]);

  return {
    tag: tag,
    className: className,
    style: style,
    attributes: attributes,
    children: children
  };
}
function diffValue(prev, cur, func) {
  if (prev !== cur) {
    func(prev, cur);
  }
}
function getRect(e, ratio, boundArea) {
  var _a;

  if (boundArea === void 0) {
    boundArea = e.datas.boundArea;
  }

  var _b = e.distX,
      distX = _b === void 0 ? 0 : _b,
      _c = e.distY,
      distY = _c === void 0 ? 0 : _c;
  var _d = e.datas,
      startX = _d.startX,
      startY = _d.startY;

  if (ratio > 0) {
    var nextHeight = Math.sqrt((distX * distX + distY * distY) / (1 + ratio * ratio));
    var nextWidth = ratio * nextHeight;
    distX = (distX >= 0 ? 1 : -1) * nextWidth;
    distY = (distY >= 0 ? 1 : -1) * nextHeight;
  }

  var width = Math.abs(distX);
  var height = Math.abs(distY);
  var maxWidth = distX < 0 ? startX - boundArea.left : boundArea.right - startX;
  var maxHeight = distY < 0 ? startY - boundArea.top : boundArea.bottom - startY;
  _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.calculateBoundSize)([width, height], [0, 0], [maxWidth, maxHeight], !!ratio), width = _a[0], height = _a[1];
  distX = (distX >= 0 ? 1 : -1) * width;
  distY = (distY >= 0 ? 1 : -1) * height;
  var tx = Math.min(0, distX);
  var ty = Math.min(0, distY);
  var left = startX + tx;
  var top = startY + ty;
  return {
    left: left,
    top: top,
    right: left + width,
    bottom: top + height,
    width: width,
    height: height
  };
}
function getDefaultElementRect(el) {
  var rect = el.getBoundingClientRect();
  var left = rect.left,
      top = rect.top,
      width = rect.width,
      height = rect.height;
  return {
    pos1: [left, top],
    pos2: [left + width, top],
    pos3: [left, top + height],
    pos4: [left + width, top + height]
  };
}
function passTargets(beforeTargets, afterTargets, continueSelectWithoutDeselect) {
  var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(beforeTargets, afterTargets),
      list = _a.list,
      prevList = _a.prevList,
      added = _a.added,
      removed = _a.removed,
      maintained = _a.maintained;

  return __spreadArrays(added.map(function (index) {
    return list[index];
  }), removed.map(function (index) {
    return prevList[index];
  }), continueSelectWithoutDeselect ? maintained.map(function (_a) {
    var nextIndex = _a[1];
    return list[nextIndex];
  }) : []);
}

var injector = (0,css_styled__WEBPACK_IMPORTED_MODULE_2__["default"])("\n:host {\n    position: fixed;\n    display: none;\n    border: 1px solid #4af;\n    background: rgba(68, 170, 255, 0.5);\n    pointer-events: none;\n    will-change: transform;\n    z-index: 100;\n}\n");
/**
 * @memberof Selecto
 */

var CLASS_NAME = "selecto-selection " + injector.className;
var PROPERTIES = ["boundContainer", "selectableTargets", "selectByClick", "selectFromInside", "continueSelect", "toggleContinueSelect", "keyContainer", "hitRate", "scrollOptions", "checkInput", "preventDefault", "ratio", "getElementRect", "preventDragFromInside", "rootContainer", "dragCondition", "clickBySelectEnd"];
/**
 * @memberof Selecto
 */

var OPTIONS = __spreadArrays([// ignore target, container,
"dragContainer", "cspNonce", "continueSelectWithoutDeselect"], PROPERTIES);
var OPTION_TYPES = {
  boundContainer: null,
  portalContainer: null,
  container: null,
  dragContainer: null,
  selectableTargets: Array,
  selectByClick: Boolean,
  selectFromInside: Boolean,
  continueSelect: Boolean,
  toggleContinueSelect: Array,
  keyContainer: null,
  hitRate: Number,
  scrollOptions: Object,
  checkInput: Boolean,
  preventDefault: Boolean,
  cspNonce: String,
  ratio: Number,
  getElementRect: Function,
  preventDragFromInside: Boolean,
  rootContainer: Object,
  dragCondition: Function,
  clickBySelectEnd: Boolean,
  continueSelectWithoutDeselect: Boolean
};
/**
 * @memberof Selecto
 */

var EVENTS = ["dragStart", "drag", "dragEnd", "selectStart", "select", "selectEnd", "keydown", "keyup", "scroll"];
/**
 * @memberof Selecto
 */

var METHODS = ["clickTarget", "getSelectableElements", "setSelectedTargets", "getElementPoints", "getSelectedTargets", "findSelectableTargets", "triggerDragStart", "checkScroll"];

/**
 * Selecto.js is a component that allows you to select elements in the drag area using the mouse or touch.
 * @sort 1
 * @extends EventEmitter
 */

var Selecto =
/*#__PURE__*/
function (_super) {
  __extends(Selecto, _super);
  /**
   *
   */


  function Selecto(options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.selectedTargets = [];
    _this.dragScroll = new _scena_dragscroll__WEBPACK_IMPORTED_MODULE_3__["default"]();

    _this._onDragStart = function (e, clickedTarget) {
      var datas = e.datas,
          clientX = e.clientX,
          clientY = e.clientY,
          inputEvent = e.inputEvent;
      var _a = _this.options,
          continueSelect = _a.continueSelect,
          continueSelectWithoutDeselect = _a.continueSelectWithoutDeselect,
          selectFromInside = _a.selectFromInside,
          selectByClick = _a.selectByClick,
          rootContainer = _a.rootContainer,
          boundContainer = _a.boundContainer,
          _b = _a.preventDragFromInside,
          preventDragFromInside = _b === void 0 ? true : _b,
          clickBySelectEnd = _a.clickBySelectEnd,
          dragCondition = _a.dragCondition;

      if (dragCondition && !dragCondition(e)) {
        e.stop();
        return;
      }

      _this.findSelectableTargets(datas);

      datas.startSelectedTargets = _this.selectedTargets;
      datas.scaleMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.createMatrix)();
      datas.containerX = 0;
      datas.containerY = 0;
      var boundArea = {
        left: -Infinity,
        top: -Infinity,
        right: Infinity,
        bottom: Infinity
      };

      if (rootContainer) {
        var containerRect = _this.container.getBoundingClientRect();

        datas.containerX = containerRect.left;
        datas.containerY = containerRect.top;
        datas.scaleMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.getDistElementMatrix)(_this.container, rootContainer);
      }

      if (boundContainer) {
        var boundInfo = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(boundContainer) && "element" in boundContainer ? __assign({
          left: true,
          top: true,
          bottom: true,
          right: true
        }, boundContainer) : {
          element: boundContainer,
          left: true,
          top: true,
          bottom: true,
          right: true
        };
        var boundElement = boundInfo.element;
        var rectElement = void 0;

        if (boundElement) {
          if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(boundElement)) {
            rectElement = document.querySelector(boundElement);
          } else if (boundElement === true) {
            rectElement = _this.container;
          } else {
            rectElement = boundElement;
          }

          var rect = rectElement.getBoundingClientRect();

          if (boundInfo.left) {
            boundArea.left = rect.left;
          }

          if (boundInfo.top) {
            boundArea.top = rect.top;
          }

          if (boundInfo.right) {
            boundArea.right = rect.right;
          }

          if (boundInfo.bottom) {
            boundArea.bottom = rect.bottom;
          }
        }
      }

      datas.boundArea = boundArea;
      var hitRect = {
        left: clientX,
        top: clientY,
        right: clientX,
        bottom: clientY,
        width: 0,
        height: 0
      };
      var firstPassedTargets = [];

      if (!selectFromInside || selectByClick && !clickBySelectEnd) {
        var pointTarget = _this._findElement(clickedTarget || document.elementFromPoint(clientX, clientY), datas.selectableTargets);

        firstPassedTargets = pointTarget ? [pointTarget] : [];
      }

      var hasInsideTargets = firstPassedTargets.length > 0;
      var isPreventSelect = !selectFromInside && hasInsideTargets; // prevent drag from inside when selectByClick is false

      if (isPreventSelect && !selectByClick) {
        e.stop();
        return false;
      }

      var type = inputEvent.type;
      var isTrusted = type === "mousedown" || type === "touchstart";
      /**
       * When the drag starts (triggers on mousedown or touchstart), the dragStart event is called.
       * Call the stop () function if you have a specific element or don't want to raise a select
       * @memberof Selecto
       * @event dragStart
       * @param {OnDragStart} - Parameters for the dragStart event
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   selectByClick: true,
       *   selectFromInside: false,
       * });
       *
       * selecto.on("dragStart", e => {
       *   if (e.inputEvent.target.tagName === "SPAN") {
       *     e.stop();
       *   }
       * }).on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */

      var result = !e.isClick && isTrusted ? _this.emit("dragStart", __assign({}, e)) : true;

      if (!result) {
        e.stop();
        return false;
      }

      if (continueSelect) {
        firstPassedTargets = passTargets(_this.selectedTargets, firstPassedTargets, continueSelectWithoutDeselect);
        datas.startPassedTargets = _this.selectedTargets;
      } else {
        datas.startPassedTargets = [];
      }

      _this._select(_this.selectedTargets, firstPassedTargets, hitRect, inputEvent, true);

      datas.startX = clientX;
      datas.startY = clientY;
      datas.selectFlag = false;
      datas.preventDragFromInside = false;
      var offsetPos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(datas.scaleMatrix, [clientX - datas.containerX, clientY - datas.containerY]);
      datas.boundsArea = _this.target.style.cssText += "position: " + (rootContainer ? "absolute" : "fixed") + ";" + "left:0px;top:0px;" + ("transform: translate(" + offsetPos[0] + "px, " + offsetPos[1] + "px)");

      if (isPreventSelect && selectByClick && !clickBySelectEnd) {
        inputEvent.preventDefault(); // prevent drag from inside when selectByClick is true and force call `selectEnd`

        if (preventDragFromInside) {
          _this._selectEnd(datas.startSelectedTargets, datas.startPassedTargets, hitRect, e);

          datas.preventDragFromInside = true;
        }
      } else {
        datas.selectFlag = true;

        if (type === "touchstart") {
          inputEvent.preventDefault();
        }

        var scrollOptions = _this.options.scrollOptions;

        if (scrollOptions && scrollOptions.container) {
          _this.dragScroll.dragStart(e, scrollOptions);
        }

        if (clickBySelectEnd) {
          datas.selectFlag = false;
          e.preventDrag();
        }
      }

      return true;
    };

    _this._onDrag = function (e) {
      var _a;

      if (e.datas.selectFlag) {
        var scrollOptions = _this.scrollOptions; // If it is a scrolling position, pass drag

        if (((_a = scrollOptions) === null || _a === void 0 ? void 0 : _a.container) && _this.dragScroll.drag(e, scrollOptions)) {
          return;
        }
      }

      _this._checkSelected(e);
    };

    _this._onDragEnd = function (e) {
      var datas = e.datas,
          inputEvent = e.inputEvent;
      var rect = getRect(e, _this.options.ratio);
      var selectFlag = datas.selectFlag;
      /**
       * When the drag ends (triggers on mouseup or touchend after drag), the dragEnd event is called.
       * @memberof Selecto
       * @event dragEnd
       * @param {OnDragEnd} - Parameters for the dragEnd event
       */

      if (inputEvent && !e.isClick) {
        _this.emit("dragEnd", __assign(__assign({
          isDouble: !!e.isDouble,
          isDrag: false,
          isSelect: selectFlag
        }, e), {
          isClick: !!e.isClick,
          rect: rect
        }));
      }

      _this.target.style.cssText += "display: none;";

      if (selectFlag) {
        datas.selectFlag = false;

        _this.dragScroll.dragEnd();
      } else if (_this.selectByClick && _this.clickBySelectEnd) {
        // only clickBySelectEnd
        var pointTarget = _this._findElement(document.elementFromPoint(e.clientX, e.clientY), datas.selectableTargets);

        _this._select(_this.selectedTargets, pointTarget ? [pointTarget] : [], rect, inputEvent);
      }

      if (!datas.preventDragFromInside) {
        _this._selectEnd(datas.startSelectedTargets, datas.startPassedTargets, rect, e);
      }
    };

    _this._onKeyDown = function (e) {
      if (!_this._sameCombiKey(e)) {
        return;
      }

      _this.continueSelect = true;
      /**
       * When you keydown the key you specified in toggleContinueSelect, the keydown event is called.
       * @memberof Selecto
       * @event keydown
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   toggleContinueSelect: "shift";
       *   keyContainer: window,
       * });
       *
       * selecto.on("keydown", () => {
       *   document.querySelector(".button").classList.add("selected");
       * }).on("keyup", () => {
       *   document.querySelector(".button").classList.remove("selected");
       * }).on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */

      _this.emit("keydown", {});
    };

    _this._onKeyUp = function (e) {
      if (!_this._sameCombiKey(e, true)) {
        return;
      }

      _this.continueSelect = false;
      /**
       * When you keyup the key you specified in toggleContinueSelect, the keyup event is called.
       * @memberof Selecto
       * @event keyup
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   toggleContinueSelect: "shift";
       *   keyContainer: window,
       * });
       *
       * selecto.on("keydown", () => {
       *   document.querySelector(".button").classList.add("selected");
       * }).on("keyup", () => {
       *   document.querySelector(".button").classList.remove("selected");
       * }).on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */

      _this.emit("keyup", {});
    };

    _this._onBlur = function () {
      if (_this.toggleContinueSelect && _this.continueSelect) {
        _this.continueSelect = false;

        _this.emit("keyup", {});
      }
    };

    _this._onDocumentSelectStart = function (e) {
      if (!_this.gesto.isFlag()) {
        return;
      }

      var dragContainer = _this.dragContainer;

      if (dragContainer === window) {
        dragContainer = document.documentElement;
      }

      var containers = dragContainer instanceof Element ? [dragContainer] : [].slice.call(dragContainer);
      var target = e.target;
      containers.some(function (container) {
        if (container === target || container.contains(target)) {
          e.preventDefault();
          return true;
        }
      });
    };

    _this.target = options.portalContainer;
    _this.container = options.container || document.body;
    _this.options = __assign({
      portalContainer: null,
      container: null,
      dragContainer: null,
      selectableTargets: [],
      selectByClick: true,
      selectFromInside: true,
      clickBySelectEnd: false,
      hitRate: 100,
      continueSelect: false,
      continueSelectWithoutDeselect: false,
      toggleContinueSelect: null,
      keyContainer: null,
      scrollOptions: undefined,
      checkInput: false,
      preventDefault: false,
      boundContainer: false,
      preventDragFromInside: true,
      dragCondition: null,
      rootContainer: null,
      getElementRect: getDefaultElementRect,
      cspNonce: "",
      ratio: 0
    }, options);

    _this.initElement();

    _this.initDragScroll();

    _this.setKeyController();

    return _this;
  }
  /**
   * You can set the currently selected targets.
   *
   */


  var __proto = Selecto.prototype;

  __proto.setSelectedTargets = function (selectedTargets) {
    this.selectedTargets = selectedTargets;
    return this;
  };
  /**
   * You can get the currently selected targets.
   */


  __proto.getSelectedTargets = function () {
    return this.selectedTargets;
  };

  __proto.setKeyContainer = function (keyContainer) {
    var _this = this;

    var options = this.options;
    diffValue(options.keyContainer, keyContainer, function () {
      options.keyContainer = keyContainer;

      _this.setKeyController();
    });
  };

  __proto.setToggleContinueSelect = function (toggleContinueSelect) {
    var _this = this;

    var options = this.options;
    diffValue(options.toggleContinueSelect, toggleContinueSelect, function () {
      options.toggleContinueSelect = toggleContinueSelect;

      _this.setKeyEvent();
    });
  };

  __proto.setPreventDefault = function (value) {
    this.gesto.options.preventDefault = value;
  };

  __proto.setCheckInput = function (value) {
    this.gesto.options.checkInput = value;
  };
  /**
   * `OnDragStart` is triggered by an external event.
   * @param - external event
   * @example
   * import Selecto from "selecto";
   *
   * const selecto = new Selecto();
   *
   * window.addEventListener("mousedown", e => {
   *   selecto.triggerDragStart(e);
   * });
   */


  __proto.triggerDragStart = function (e) {
    this.gesto.triggerDragStart(e);
    return this;
  };
  /**
   * Destroy elements, properties, and events.
   */


  __proto.destroy = function () {
    this.off();
    this.keycon && this.keycon.destroy();
    this.gesto.unset();
    this.injectResult.destroy();
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(document, "selectstart", this._onDocumentSelectStart);
    this.keycon = null;
    this.gesto = null;
    this.injectResult = null;
    this.target = null;
    this.container = null;
    this.options = null;
  };

  __proto.getElementPoints = function (target) {
    var getElementRect = this.getElementRect || getDefaultElementRect;
    var info = getElementRect(target);
    var points = [info.pos1, info.pos2, info.pos4, info.pos3];

    if (getElementRect !== getDefaultElementRect) {
      var rect = target.getBoundingClientRect();
      return (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.fitPoints)(points, rect);
    }

    return points;
  };
  /**
   * Get all elements set in `selectableTargets`.
   */


  __proto.getSelectableElements = function () {
    var selectableElements = [];
    this.options.selectableTargets.forEach(function (target) {
      if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
        selectableElements.push(target);
      } else {
        var elements = [].slice.call(document.querySelectorAll(target));
        elements.forEach(function (el) {
          selectableElements.push(el);
        });
      }
    });
    return selectableElements;
  };
  /**
   * If scroll occurs during dragging, you can manually call this method to check the position again.
   */


  __proto.checkScroll = function () {
    var _a;

    if (!this.gesto.isFlag()) {
      return;
    }

    var scrollOptions = this.scrollOptions; // If it is a scrolling position, pass drag

    ((_a = scrollOptions) === null || _a === void 0 ? void 0 : _a.container) && this.dragScroll.checkScroll(__assign({
      inputEvent: this.gesto.getCurrentEvent()
    }, scrollOptions));
  };
  /**
   * Find for selectableTargets again during drag event
   */


  __proto.findSelectableTargets = function (datas) {
    var _this = this;

    if (datas === void 0) {
      datas = this.gesto.getEventDatas();
    }

    var selectableTargets = this.getSelectableElements();
    var selectablePoints = selectableTargets.map(function (target) {
      return _this.getElementPoints(target);
    });
    datas.selectableTargets = selectableTargets;
    datas.selectablePoints = selectablePoints;
  };
  /**
   * External click or mouse events can be applied to the selecto.
   * @params - Extenal click or mouse event
   * @params - Specify the clicked target directly.
   */


  __proto.clickTarget = function (e, clickedTarget) {
    var _a = getClient(e),
        clientX = _a.clientX,
        clientY = _a.clientY;

    var dragEvent = {
      datas: {
        selectFlag: false
      },
      clientX: clientX,
      clientY: clientY,
      inputEvent: e,
      isClick: true,
      stop: function () {
        return false;
      }
    };

    if (this._onDragStart(dragEvent, clickedTarget)) {
      this._onDragEnd(dragEvent);
    }

    return this;
  };

  __proto.setKeyController = function () {
    var _a = this.options,
        keyContainer = _a.keyContainer,
        toggleContinueSelect = _a.toggleContinueSelect;

    if (this.keycon) {
      this.keycon.destroy();
      this.keycon = null;
    }

    if (toggleContinueSelect) {
      this.keycon = new keycon__WEBPACK_IMPORTED_MODULE_6__["default"](keyContainer || window);
      this.keycon.keydown(this._onKeyDown).keyup(this._onKeyUp).on("blur", this._onBlur);
    }
  };

  __proto.setKeyEvent = function () {
    var toggleContinueSelect = this.options.toggleContinueSelect;

    if (!toggleContinueSelect || this.keycon) {
      return;
    }

    this.setKeyController();
  };

  __proto.initElement = function () {
    this.target = createElement(h("div", {
      className: CLASS_NAME
    }), this.target, this.container);
    var target = this.target;
    var _a = this.options,
        dragContainer = _a.dragContainer,
        checkInput = _a.checkInput,
        preventDefault = _a.preventDefault;
    this.dragContainer = typeof dragContainer === "string" ? [].slice.call(document.querySelectorAll(dragContainer)) : dragContainer || this.target.parentNode;
    this.gesto = new gesto__WEBPACK_IMPORTED_MODULE_7__["default"](this.dragContainer, {
      checkWindowBlur: true,
      container: window,
      checkInput: checkInput,
      preventDefault: preventDefault
    }).on({
      dragStart: this._onDragStart,
      drag: this._onDrag,
      dragEnd: this._onDragEnd
    });
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(document, "selectstart", this._onDocumentSelectStart);
    this.injectResult = injector.inject(target, {
      nonce: this.options.cspNonce
    });
  };

  __proto.hitTest = function (selectRect, clientX, clientY, targets, selectablePoints) {
    var _a = this.options,
        hitRate = _a.hitRate,
        selectByClick = _a.selectByClick;
    var left = selectRect.left,
        top = selectRect.top,
        right = selectRect.right,
        bottom = selectRect.bottom;
    var rectPoints = [[left, top], [right, top], [right, bottom], [left, bottom]];
    return targets.filter(function (_, i) {
      var points = selectablePoints[i];
      var inArea = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.isInside)([clientX, clientY], points);

      if (selectByClick && inArea) {
        return true;
      }

      var overlapPoints = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getOverlapPoints)(rectPoints, points);

      if (!overlapPoints.length) {
        return false;
      }

      var overlapSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(overlapPoints);
      var targetSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(points);
      var hitRateValue = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitUnit)("" + hitRate);

      if (hitRateValue.unit === "px") {
        return overlapSize >= hitRateValue.value;
      } else {
        var rate = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.between)(Math.round(overlapSize / targetSize * 100), 0, 100);
        return rate >= Math.min(100, hitRateValue.value);
      }
    });
  };

  __proto.initDragScroll = function () {
    var _this = this;

    this.dragScroll.on("scroll", function (_a) {
      var container = _a.container,
          direction = _a.direction;

      _this.emit("scroll", {
        container: container,
        direction: direction
      });
    }).on("move", function (_a) {
      var offsetX = _a.offsetX,
          offsetY = _a.offsetY,
          inputEvent = _a.inputEvent;
      var gesto = _this.gesto;

      if (!gesto || !gesto.isFlag()) {
        return;
      }

      var datas = _this.gesto.getEventDatas();

      var boundArea = datas.boundArea;
      datas.startX -= offsetX;
      datas.startY -= offsetY;
      datas.selectablePoints.forEach(function (points) {
        points.forEach(function (pos) {
          pos[0] -= offsetX;
          pos[1] -= offsetY;
        });
      });
      boundArea.left -= offsetX;
      boundArea.right -= offsetX;
      boundArea.top -= offsetY;
      boundArea.bottom -= offsetY;

      _this.gesto.scrollBy(offsetX, offsetY, inputEvent.inputEvent, false);

      _this._checkSelected(_this.gesto.getCurrentEvent());
    });
  };

  __proto._select = function (prevSelectedTargets, selectedTargets, rect, inputEvent, isStart) {
    var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(prevSelectedTargets, selectedTargets),
        added = _a.added,
        removed = _a.removed,
        prevList = _a.prevList,
        list = _a.list;

    this.selectedTargets = selectedTargets;

    if (isStart) {
      /**
       * When the select(drag) starts, the selectStart event is called.
       * @memberof Selecto
       * @event selectStart
       * @param {Selecto.OnSelect} - Parameters for the selectStart event
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   selectByClick: true,
       *   selectFromInside: false,
       * });
       *
       * selecto.on("selectStart", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * }).on("selectEnd", e => {
       *   e.afterAdded.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.afterRemoved.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */
      this.emit("selectStart", {
        selected: selectedTargets,
        added: added.map(function (index) {
          return list[index];
        }),
        removed: removed.map(function (index) {
          return prevList[index];
        }),
        rect: rect,
        inputEvent: inputEvent
      });
    }

    if (added.length || removed.length) {
      /**
       * When the select in real time, the select event is called.
       * @memberof Selecto
       * @event select
       * @param {Selecto.OnSelect} - Parameters for the select event
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   selectByClick: true,
       *   selectFromInside: false,
       * });
       *
       * selecto.on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */
      this.emit("select", {
        selected: selectedTargets,
        added: added.map(function (index) {
          return list[index];
        }),
        removed: removed.map(function (index) {
          return prevList[index];
        }),
        rect: rect,
        inputEvent: inputEvent
      });
    }
  };

  __proto._selectEnd = function (startSelectedTargets, startPassedTargets, rect, e) {
    var inputEvent = e.inputEvent,
        isDouble = e.isDouble;

    var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(startSelectedTargets, this.selectedTargets),
        added = _a.added,
        removed = _a.removed,
        prevList = _a.prevList,
        list = _a.list;

    var _b = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(startPassedTargets, this.selectedTargets),
        afterAdded = _b.added,
        afterRemoved = _b.removed,
        afterPrevList = _b.prevList,
        afterList = _b.list;

    var type = inputEvent && inputEvent.type;
    var isDragStart = type === "mousedown" || type === "touchstart";
    /**
     * When the select(dragEnd or click) ends, the selectEnd event is called.
     * @memberof Selecto
     * @event selectEnd
     * @param {Selecto.OnSelectEnd} - Parameters for the selectEnd event
     * @example
     * import Selecto from "selecto";
     *
     * const selecto = new Selecto({
     *   container: document.body,
     *   selectByClick: true,
     *   selectFromInside: false,
     * });
     *
     * selecto.on("selectStart", e => {
     *   e.added.forEach(el => {
     *     el.classList.add("selected");
     *   });
     *   e.removed.forEach(el => {
     *     el.classList.remove("selected");
     *   });
     * }).on("selectEnd", e => {
     *   e.afterAdded.forEach(el => {
     *     el.classList.add("selected");
     *   });
     *   e.afterRemoved.forEach(el => {
     *     el.classList.remove("selected");
     *   });
     * });
     */

    this.emit("selectEnd", {
      selected: this.selectedTargets,
      added: added.map(function (index) {
        return list[index];
      }),
      removed: removed.map(function (index) {
        return prevList[index];
      }),
      afterAdded: afterAdded.map(function (index) {
        return afterList[index];
      }),
      afterRemoved: afterRemoved.map(function (index) {
        return afterPrevList[index];
      }),
      isDragStart: isDragStart,
      isClick: !!e.isClick,
      isDouble: !!isDouble,
      rect: rect,
      inputEvent: inputEvent
    });
  };

  __proto._checkSelected = function (e, rect) {
    if (rect === void 0) {
      rect = getRect(e, this.options.ratio);
    }

    var datas = e.datas,
        inputEvent = e.inputEvent;
    var top = rect.top,
        left = rect.left,
        width = rect.width,
        height = rect.height;
    var selectFlag = datas.selectFlag;
    var options = this.options;
    var containerX = datas.containerX,
        containerY = datas.containerY,
        scaleMatrix = datas.scaleMatrix;
    var offsetPos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(scaleMatrix, [left - containerX, top - containerY]);
    var offsetSize = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(scaleMatrix, [width, height]);
    var prevSelectedTargets = [];
    var selectedTargets = [];

    if (selectFlag) {
      this.target.style.cssText += "display: block;" + "left:0px;top:0px;" + ("transform: translate(" + offsetPos[0] + "px, " + offsetPos[1] + "px);") + ("width:" + offsetSize[0] + "px;height:" + offsetSize[1] + "px;");
      var passedTargets = this.hitTest(rect, datas.startX, datas.startY, datas.selectableTargets, datas.selectablePoints);
      prevSelectedTargets = this.selectedTargets;
      selectedTargets = passTargets(datas.startPassedTargets, passedTargets, options.continueSelect && options.continueSelectWithoutDeselect);
      this.selectedTargets = selectedTargets;
    }
    /**
     * When the drag, the drag event is called.
     * Call the stop () function if you have a specific element or don't want to raise a select
     * @memberof Selecto
     * @event drag
     * @param {OnDrag} - Parameters for the drag event
     * @example
     * import Selecto from "selecto";
     *
     * const selecto = new Selecto({
     *   container: document.body,
     *   selectByClick: true,
     *   selectFromInside: false,
     * });
     *
     * selecto.on("drag", e => {
     *   e.stop();
     * }).on("select", e => {
     *   e.added.forEach(el => {
     *     el.classList.add("selected");
     *   });
     *   e.removed.forEach(el => {
     *     el.classList.remove("selected");
     *   });
     * });
     */


    var result = this.emit("drag", __assign(__assign({}, e), {
      isSelect: selectFlag,
      rect: rect
    }));

    if (result === false) {
      this.target.style.cssText += "display: none;";
      e.stop();
      return;
    }

    if (selectFlag) {
      this._select(prevSelectedTargets, selectedTargets, rect, inputEvent);
    }
  };

  __proto._sameCombiKey = function (e, isKeyup) {
    var toggleContinueSelect = [].concat(this.options.toggleContinueSelect);
    var combi = (0,keycon__WEBPACK_IMPORTED_MODULE_6__.getCombi)(e.inputEvent, e.key);
    var toggleKeys = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(toggleContinueSelect[0]) ? toggleContinueSelect : [toggleContinueSelect];

    if (isKeyup) {
      var singleKey_1 = e.key;
      return toggleKeys.some(function (keys) {
        return keys.some(function (key) {
          return key === singleKey_1;
        });
      });
    }

    return toggleKeys.some(function (keys) {
      return keys.every(function (key) {
        return combi.indexOf(key) > -1;
      });
    });
  };

  __proto._findElement = function (clickedTarget, selectableTargets) {
    var pointTarget = clickedTarget;

    while (pointTarget) {
      if (selectableTargets.indexOf(pointTarget) > -1) {
        break;
      }

      pointTarget = pointTarget.parentElement;
    }

    return pointTarget;
  };

  Selecto = __decorate([(0,framework_utils__WEBPACK_IMPORTED_MODULE_8__.Properties)(PROPERTIES, function (prototype, property) {
    var attributes = {
      enumerable: true,
      configurable: true,
      get: function () {
        return this.options[property];
      }
    };
    var setter = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.camelize)("set " + property);

    if (prototype[setter]) {
      attributes.set = function set(value) {
        this[setter](value);
      };
    } else {
      attributes.set = function set(value) {
        this.options[property] = value;
      };
    }

    Object.defineProperty(prototype, property, attributes);
  })], Selecto);
  return Selecto;
}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_9__["default"]);

var Selecto$1 =
/*#__PURE__*/
function (_super) {
  __extends(Selecto, _super);

  function Selecto() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return Selecto;
}(Selecto);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Selecto$1);

//# sourceMappingURL=selecto.esm.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FudmFzUGFuZWwuMjMwMWI2MGVmZmQ0YWFiNjQwMjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBR0E7O0FBUU8sTUFBTUUsY0FBYyxHQUFHLENBQUM7RUFBRUMsUUFBRjtFQUFZQyxPQUFaO0VBQXFCQztBQUFyQixDQUFELEtBQXVEO0VBQ25GLG9CQUNFLHVEQUFDLG9EQUFEO0lBQ0UsSUFBSSxFQUFDLE1BRFA7SUFFRSxLQUFLLEVBQUVBLEtBRlQ7SUFHRSxPQUFPLEVBQUMsV0FIVjtJQUlFLE9BQU8sRUFBRUQsT0FKWDtJQUtFLFFBQVEsRUFBRUQsUUFMWjtJQU1FLFdBQVcsRUFBRTtFQU5mLEVBREY7QUFVRCxDQVhNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNYUDtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7Ozs7QUFpQk8sTUFBTWEsaUJBQWlCLEdBQUcsQ0FBeUI7RUFDeERDLE1BRHdEO0VBRXhEQyxZQUZ3RDtFQUd4REMsU0FId0Q7RUFJeERDLFFBSndEO0VBS3hEQyxRQUx3RDtFQU14REMsV0FOd0Q7RUFPeERDLFdBUHdEO0VBUXhEQyxTQVJ3RDtFQVN4REMsZ0JBVHdEO0VBVXhEQyxZQVZ3RDtFQVd4REM7QUFYd0QsQ0FBekIsS0FZQTtFQUMvQixNQUFNQyxLQUFLLEdBQUdDLE1BQU0sQ0FBQ2xCLDBEQUFELENBQXBCOztFQUVBLE1BQU1vQixXQUFXLEdBQUlDLFVBQUQsSUFBeUI7SUFDM0MsT0FBT0EsVUFBVSxHQUFJLEdBQUVKLEtBQUssQ0FBQ0ssR0FBSSxJQUFHTCxLQUFLLENBQUNNLEdBQUksRUFBN0IsR0FBaUNOLEtBQUssQ0FBQ0ssR0FBeEQ7RUFDRCxDQUZEOztFQUlBLG9CQUNFLHVEQUFDLGdFQUFEO0lBQWlCLFNBQVMsRUFBRWQsU0FBNUI7SUFBQSx1QkFDRSx1REFBQywwREFBRDtNQUFXLFdBQVcsRUFBQyxXQUF2QjtNQUFBLFVBQ0csQ0FBQ2dCLFFBQUQsRUFBV0MsUUFBWCxrQkFDQyxpRkFBU0QsUUFBUSxDQUFDRSxjQUFsQjtRQUFrQyxHQUFHLEVBQUVGLFFBQVEsQ0FBQ0csUUFBaEQ7UUFBQSxXQUNHLENBQUMsTUFBTTtVQUNOO1VBQ0EsTUFBTUMsSUFBUyxHQUFHLEVBQWxCO1VBQ0EsTUFBTUMsY0FBYyxHQUFHZixnQkFBZ0IsR0FBRyxDQUFILEdBQU8sQ0FBOUM7VUFDQSxNQUFNZ0IsbUNBQW1DLEdBQUdoQixnQkFBZ0IsR0FBRyxDQUFILEdBQU8sQ0FBbkU7O1VBQ0EsS0FBSyxJQUFJaUIsQ0FBQyxHQUFHekIsTUFBTSxDQUFDMEIsTUFBUCxHQUFnQixDQUE3QixFQUFnQ0QsQ0FBQyxJQUFJRixjQUFyQyxFQUFxREUsQ0FBQyxFQUF0RCxFQUEwRDtZQUN4RCxNQUFNRSxPQUFPLEdBQUczQixNQUFNLENBQUN5QixDQUFELENBQXRCO1lBQ0EsTUFBTUcsR0FBRyxHQUFHRCxPQUFPLENBQUNFLE9BQVIsRUFBWjtZQUVBLE1BQU1kLFVBQVUsR0FBR2UsT0FBTyxDQUFDdkIsU0FBRCxhQUFDQSxTQUFELHVCQUFDQSxTQUFTLENBQUV3QixRQUFYLENBQW9CSCxHQUFwQixDQUFELENBQTFCO1lBQ0FOLElBQUksQ0FBQ1UsSUFBTCxlQUNFLHVEQUFDLDBEQUFEO2NBQXFCLFdBQVcsRUFBRUosR0FBbEM7Y0FBdUMsS0FBSyxFQUFFTixJQUFJLENBQUNJLE1BQW5EO2NBQUEsVUFDRyxDQUFDUixRQUFELEVBQVdDLFFBQVgsa0JBQ0M7Z0JBQ0UsU0FBUyxFQUFFTCxXQUFXLENBQUNDLFVBQUQsQ0FEeEI7Z0JBRUUsR0FBRyxFQUFFRyxRQUFRLENBQUNHO2NBRmhCLEdBR01ILFFBQVEsQ0FBQ2UsY0FIZixFQUlNZixRQUFRLENBQUNnQixlQUpmO2dCQUtFLFdBQVcsRUFBRSxNQUFNL0IsUUFBUSxDQUFDd0IsT0FBRCxDQUw3QjtnQkFBQSx3QkFPRSx1REFBQyxpREFBRDtrQkFDRSxJQUFJLEVBQUVDLEdBRFI7a0JBRUUsUUFBUSxFQUFHTyxDQUFELElBQU8xQixZQUFZLENBQUNrQixPQUFELEVBQVVRLENBQVYsQ0FGL0I7a0JBR0UseUJBQXlCLEVBQUV6Qix5QkFBRixhQUFFQSx5QkFBRixjQUFFQSx5QkFBRixHQUErQjBCO2dCQUgxRCxFQVBGLGVBWUU7a0JBQUssU0FBUyxFQUFFekIsS0FBSyxDQUFDMEIsV0FBdEI7a0JBQUEsb0JBQTJDcEMsWUFBWSxDQUFDMEIsT0FBRCxDQUF2RDtnQkFBQSxFQVpGLEVBY0dyQixXQUFXLENBQUNxQixPQUFELENBQVgsaUJBQ0M7a0JBQUEsV0FDR3RCLFdBQVcsZ0JBQ1YsdURBQUMsbURBQUQ7b0JBQ0UsSUFBSSxFQUFDLE1BRFA7b0JBRUUsS0FBSyxFQUFFLFdBRlQ7b0JBR0UsU0FBUyxFQUFFTSxLQUFLLENBQUMyQixVQUhuQjtvQkFJRSxPQUFPLEVBQUUsTUFBTWpDLFdBQVcsQ0FBQ3NCLE9BQUQ7a0JBSjVCLEVBRFUsR0FPUixJQVJOLGVBVUUsdURBQUMsbURBQUQ7b0JBQ0UsSUFBSSxFQUFDLFdBRFA7b0JBRUUsS0FBSyxFQUFFLFFBRlQ7b0JBR0UsU0FBUyxFQUFFckMsZ0RBQUUsQ0FBQ3FCLEtBQUssQ0FBQzJCLFVBQVAsRUFBbUIzQixLQUFLLENBQUM0QixRQUF6QixDQUhmO29CQUlFLE9BQU8sRUFBRSxNQUFNbkMsUUFBUSxDQUFDdUIsT0FBRDtrQkFKekIsRUFWRjtnQkFBQSxFQWZKLEVBaUNHM0IsTUFBTSxDQUFDMEIsTUFBUCxHQUFnQkYsbUNBQWhCLGlCQUNDLHVEQUFDLDZDQUFEO2tCQUNFLEtBQUssRUFBQywwQkFEUjtrQkFFRSxJQUFJLEVBQUMsZUFGUDtrQkFHRSxJQUFJLEVBQUMsSUFIUDtrQkFJRSxTQUFTLEVBQUViLEtBQUssQ0FBQzRCO2dCQUpuQixFQWxDSjtjQUFBO1lBRkosR0FBZ0JYLEdBQWhCLENBREY7VUFnREQ7O1VBRUQsT0FBT04sSUFBUDtRQUNELENBN0RBLEdBREgsRUFnRUdKLFFBQVEsQ0FBQ3NCLFdBaEVaO01BQUE7SUFGSjtFQURGLEVBREY7QUEwRUQsQ0E3Rk07QUErRlB6QyxpQkFBaUIsQ0FBQzBDLFlBQWxCLEdBQWlDO0VBQy9CQyxPQUFPLEVBQUUsTUFBTTtBQURnQixDQUFqQztBQUlBLE1BQU05QixNQUFNLEdBQUdmLDBEQUFhLENBQUVnQixLQUFELEtBQTBCO0VBQ3JEOEIsT0FBTyxFQUFFdEQsNkNBQUk7QUFDZixxQkFBcUJ3QixLQUFLLENBQUMrQixPQUFOLENBQWNDLEVBQUc7QUFDdEMsR0FIdUQ7RUFJckQ3QixHQUFHLEVBQUUzQiw2Q0FBSTtBQUNYLGVBQWV3QixLQUFLLENBQUMrQixPQUFOLENBQWNFLEVBQUcsSUFBR2pDLEtBQUssQ0FBQytCLE9BQU4sQ0FBY0csRUFBRztBQUNwRCxxQkFBcUJsQyxLQUFLLENBQUNtQyxNQUFOLENBQWFDLE1BQWIsQ0FBb0JGLEVBQUc7QUFDNUMsa0JBQWtCbEMsS0FBSyxDQUFDcUMsTUFBTixDQUFhQyxHQUFJO0FBQ25DLGtCQUFrQnRDLEtBQUssQ0FBQytCLE9BQU4sQ0FBY1EsZUFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCdkMsS0FBSyxDQUFDcUMsTUFBTixDQUFhRyxlQUFnQjtBQUNyRDtBQUNBLDBCQUEwQnhDLEtBQUssQ0FBQ3FDLE1BQU4sQ0FBYUksb0JBQXFCO0FBQzVEO0FBQ0EsR0FuQnVEO0VBb0JyRHJDLEdBQUcsRUFBRTVCLDZDQUFJO0FBQ1gsd0JBQXdCd0IsS0FBSyxDQUFDcUMsTUFBTixDQUFhSyxxQkFBc0I7QUFDM0Q7QUFDQSwwQkFBMEIxQyxLQUFLLENBQUNxQyxNQUFOLENBQWFLLHFCQUFzQjtBQUM3RDtBQUNBLEdBekJ1RDtFQTBCckRoQixRQUFRLEVBQUVsRCw2Q0FBSTtBQUNoQjtBQUNBLEdBNUJ1RDtFQTZCckRpRCxVQUFVLEVBQUVqRCw2Q0FBSTtBQUNsQixhQUFhd0IsS0FBSyxDQUFDcUMsTUFBTixDQUFhTSxRQUFTO0FBQ25DO0FBQ0EsZUFBZTNDLEtBQUssQ0FBQ3FDLE1BQU4sQ0FBYU8sSUFBSztBQUNqQztBQUNBLEdBbEN1RDtFQW1DckRDLFdBQVcsRUFBRXJFLDZDQUFJO0FBQ25CLGFBQWF3QixLQUFLLENBQUNxQyxNQUFOLENBQWFTLFFBQVM7QUFDbkM7QUFDQSxHQXRDdUQ7RUF1Q3JEdEIsV0FBVyxFQUFFaEQsNkNBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0J3QixLQUFLLENBQUMrQixPQUFOLENBQWNHLEVBQUc7QUFDckM7QUE3Q3VELENBQTFCLENBQUQsQ0FBNUI7Ozs7Ozs7Ozs7Ozs7OztBQzVIQTtBQUNBO0FBR0E7Ozs7QUFRTyxNQUFNakQsU0FBUyxHQUFHLENBQUM7RUFBRWtFLElBQUY7RUFBUTlFLFFBQVI7RUFBa0J3QjtBQUFsQixDQUFELEtBQW1FO0VBQzFGLE1BQU1FLE1BQU0sR0FBR21ELHNEQUFTLENBQUNFLFNBQUQsQ0FBeEI7RUFFQSxNQUFNLENBQUNDLFNBQUQsRUFBWUMsWUFBWixJQUE0QlAsK0NBQVEsQ0FBVSxLQUFWLENBQTFDO0VBQ0EsTUFBTSxDQUFDUSxlQUFELEVBQWtCQyxrQkFBbEIsSUFBd0NULCtDQUFRLENBQWdCLElBQWhCLENBQXREOztFQUVBLE1BQU1VLFdBQVcsR0FBSUMsS0FBRCxJQUFpQztJQUNuREosWUFBWSxDQUFDLElBQUQsQ0FBWjtFQUNELENBRkQ7O0VBSUEsTUFBTUssYUFBYSxHQUFJQyxPQUFELElBQXFCO0lBQ3pDTixZQUFZLENBQUMsS0FBRCxDQUFaOztJQUVBLElBQUlDLGVBQUosRUFBcUI7TUFDbkJDLGtCQUFrQixDQUFDLElBQUQsQ0FBbEI7TUFDQTtJQUNEOztJQUVELElBQUlMLElBQUksS0FBS1MsT0FBYixFQUFzQjtNQUNwQnZGLFFBQVEsQ0FBQ3VGLE9BQUQsQ0FBUjtJQUNEO0VBQ0YsQ0FYRDs7RUFhQSxNQUFNQyxhQUFhLEdBQUlILEtBQUQsSUFBbUQ7SUFDdkUsTUFBTUUsT0FBTyxHQUFHRixLQUFLLENBQUNJLGFBQU4sQ0FBb0JDLEtBQXBCLENBQTBCQyxJQUExQixFQUFoQjs7SUFFQSxJQUFJSixPQUFPLENBQUMvQyxNQUFSLEtBQW1CLENBQXZCLEVBQTBCO01BQ3hCMkMsa0JBQWtCLENBQUMsb0NBQUQsQ0FBbEI7TUFDQTtJQUNEOztJQUVELElBQUkzRCx5QkFBeUIsSUFBSSxDQUFDQSx5QkFBeUIsQ0FBQytELE9BQUQsQ0FBdkQsSUFBb0VBLE9BQU8sS0FBS1QsSUFBcEYsRUFBMEY7TUFDeEZLLGtCQUFrQixDQUFDLDJCQUFELENBQWxCO01BQ0E7SUFDRDs7SUFFRCxJQUFJRCxlQUFKLEVBQXFCO01BQ25CQyxrQkFBa0IsQ0FBQyxJQUFELENBQWxCO0lBQ0Q7RUFDRixDQWhCRDs7RUFrQkEsTUFBTVMsZUFBZSxHQUFJUCxLQUFELElBQW1EO0lBQ3pFQyxhQUFhLENBQUNELEtBQUssQ0FBQ0ksYUFBTixDQUFvQkMsS0FBcEIsQ0FBMEJDLElBQTFCLEVBQUQsQ0FBYjtFQUNELENBRkQ7O0VBSUEsTUFBTUUsU0FBUyxHQUFJUixLQUFELElBQWdDO0lBQ2hELElBQUlBLEtBQUssQ0FBQ1MsR0FBTixLQUFjLE9BQWxCLEVBQTJCO01BQ3pCUixhQUFhLENBQUVELEtBQUssQ0FBQ1UsTUFBUCxDQUFzQkwsS0FBdkIsQ0FBYjtJQUNEO0VBQ0YsQ0FKRDs7RUFNQSxNQUFNTSxPQUFPLEdBQUlYLEtBQUQsSUFBK0M7SUFDN0RBLEtBQUssQ0FBQ1UsTUFBTixDQUFhRSxNQUFiO0VBQ0QsQ0FGRDs7RUFJQSxvQkFDRTtJQUFBLHVCQUNFO01BQUssU0FBUyxFQUFFdkUsTUFBTSxDQUFDK0IsT0FBdkI7TUFBQSxXQUNHLENBQUN1QixTQUFELGlCQUNDO1FBQ0UsU0FBUyxFQUFFdEQsTUFBTSxDQUFDd0UsZ0JBRHBCO1FBRUUsS0FBSyxFQUFDLGlCQUZSO1FBR0UsT0FBTyxFQUFFZCxXQUhYO1FBSUUsZUFBWSxnQkFKZDtRQUFBLHdCQU1FO1VBQU0sU0FBUyxFQUFFMUQsTUFBTSxDQUFDeUUsU0FBeEI7VUFBQSxVQUFvQ3JCO1FBQXBDLEVBTkYsZUFPRSx1REFBQyw2Q0FBRDtVQUFNLElBQUksRUFBQyxLQUFYO1VBQWlCLFNBQVMsRUFBRXBELE1BQU0sQ0FBQzBFLGFBQW5DO1VBQWtELElBQUksRUFBQztRQUF2RCxFQVBGO01BQUEsRUFGSixFQWFHcEIsU0FBUyxpQkFDUjtRQUFBLHdCQUNFLHVEQUFDLDhDQUFEO1VBQ0UsSUFBSSxFQUFDLE1BRFA7VUFFRSxZQUFZLEVBQUVGLElBRmhCO1VBR0UsTUFBTSxFQUFFYyxlQUhWO1VBSUUsU0FBUyxNQUpYO1VBS0UsU0FBUyxFQUFFQyxTQUxiO1VBTUUsT0FBTyxFQUFFRyxPQU5YO1VBT0UsT0FBTyxFQUFFZCxlQUFlLEtBQUssSUFQL0I7VUFRRSxRQUFRLEVBQUVNLGFBUlo7VUFTRSxTQUFTLEVBQUU5RCxNQUFNLENBQUMyRSxjQVRwQjtVQVVFLGVBQVk7UUFWZCxFQURGLEVBYUduQixlQUFlLGlCQUFJLHVEQUFDLCtEQUFEO1VBQXdCLFVBQVUsTUFBbEM7VUFBQSxVQUFvQ0E7UUFBcEMsRUFidEI7TUFBQSxFQWRKO0lBQUE7RUFERixFQURGO0FBbUNELENBMUZNOztBQTRGUCxNQUFNSCxTQUFTLEdBQUlwRCxLQUFELElBQXlCO0VBQ3pDLE9BQU87SUFDTDhCLE9BQU8sRUFBRXRELDZDQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQndCLEtBQUssQ0FBQytCLE9BQU4sQ0FBY0UsRUFBRztBQUN0QyxLQU5TO0lBT0xzQyxnQkFBZ0IsRUFBRS9GLDZDQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QndCLEtBQUssQ0FBQ21DLE1BQU4sQ0FBYUMsTUFBYixDQUFvQkosRUFBRztBQUM5QztBQUNBLHVCQUF1QmhDLEtBQUssQ0FBQytCLE9BQU4sQ0FBY0UsRUFBRztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQmpDLEtBQUssQ0FBQ3FDLE1BQU4sQ0FBYXNDLEdBQUk7QUFDdkMsNkJBQTZCM0UsS0FBSyxDQUFDcUMsTUFBTixDQUFhdUMsT0FBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI1RSxLQUFLLENBQUNxQyxNQUFOLENBQWFLLHFCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FoQ1M7SUFpQ0w4QixTQUFTLEVBQUVoRyw2Q0FBSTtBQUNuQixxQkFBcUJ3QixLQUFLLENBQUM2RSxVQUFOLENBQWlCQyxNQUFqQixDQUF3QkMsUUFBUztBQUN0RCxlQUFlL0UsS0FBSyxDQUFDcUMsTUFBTixDQUFhUyxRQUFTO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUI5QyxLQUFLLENBQUMrQixPQUFOLENBQWNFLEVBQUc7QUFDdEMsS0F2Q1M7SUF3Q0x3QyxhQUFhLEVBQUVoRyxnREFBRSxDQUNmRCw2Q0FBSTtBQUNWLHVCQUF1QndCLEtBQUssQ0FBQytCLE9BQU4sQ0FBY0MsRUFBRztBQUN4QztBQUNBLE9BSnFCLEVBS2Ysc0JBTGUsQ0F4Q1o7SUErQ0wwQyxjQUFjLEVBQUVsRyw2Q0FBSTtBQUN4QjtBQUNBO0FBQ0E7RUFsRFMsQ0FBUDtBQW9ERCxDQXJERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FFeEdBO0FBRUE7QUFFQTtBQUVBOzs7QUFjQSxNQUFNNkcsYUFBTixTQUE0QkwsZ0RBQTVCLENBQXdGO0VBQ3RGTSxNQUFNLEdBQUc7SUFDUCxNQUFNO01BQUVDO0lBQUYsSUFBVyxLQUFLQyxLQUF0Qjs7SUFDQSxNQUFNQyxPQUFPLEdBQUcsTUFBTTtNQUNwQixJQUFJRixJQUFKLGFBQUlBLElBQUosZUFBSUEsSUFBSSxDQUFFRyxHQUFWLEVBQWU7UUFDYk4sa0ZBQU8sQ0FBQ0csSUFBSSxDQUFDRyxHQUFOLENBQVA7TUFDRDtJQUNGLENBSkQ7O0lBTUEsb0JBQ0UsdURBQUMsK0NBQUQ7TUFBUSxJQUFJLEVBQUMsUUFBYjtNQUFzQixPQUFPLEVBQUVELE9BQS9CO01BQUEsVUFDR0YsSUFESCxhQUNHQSxJQURILHVCQUNHQSxJQUFJLENBQUUzQztJQURULEVBREY7RUFLRDs7QUFkcUY7O0FBaUJqRixNQUFNK0MsVUFBdUQsR0FBRztFQUNyRUMsRUFBRSxFQUFFLFFBRGlFO0VBRXJFekMsSUFBSSxFQUFFLFFBRitEO0VBR3JFMEMsV0FBVyxFQUFFLFFBSHdEO0VBS3JFQyxPQUFPLEVBQUVULGFBTDREO0VBT3JFVSxXQUFXLEVBQUU7SUFDWEMsS0FBSyxFQUFFLEdBREk7SUFFWEMsTUFBTSxFQUFFO0VBRkcsQ0FQd0Q7RUFZckVDLGFBQWEsRUFBRzVILE9BQUQsc0JBQ1ZBLE9BRFUsQ0Fac0Q7RUFnQnJFO0VBQ0E2SCxXQUFXLEVBQUUsQ0FBQ0MsR0FBRCxFQUF3QkMsR0FBeEIsS0FBOEM7SUFBQTs7SUFDekQsTUFBTWQsSUFBZ0IsR0FBRztNQUN2QjNDLElBQUksRUFBRXlELEdBQUcsU0FBSCxJQUFBQSxHQUFHLFdBQUgsSUFBQUEsR0FBRyxDQUFFekQsSUFBTCxHQUFZd0QsR0FBRyxDQUFDRSxPQUFKLENBQVlELEdBQUcsQ0FBQ3pELElBQWhCLEVBQXNCbUIsS0FBdEIsRUFBWixHQUE0QyxFQUQzQjtNQUV2QjJCLEdBQUcsY0FBRVcsR0FBRixhQUFFQSxHQUFGLHVCQUFFQSxHQUFHLENBQUVYLEdBQVAsK0NBQWNuRTtJQUZNLENBQXpCO0lBS0EsT0FBT2dFLElBQVA7RUFDRCxDQXhCb0U7RUEwQnJFO0VBQ0FnQixpQkFBaUIsRUFBR0MsT0FBRCxJQUFhO0lBQzlCLE1BQU1DLFFBQVEsR0FBRyxDQUFDLFFBQUQsQ0FBakI7SUFDQUQsT0FBTyxDQUNKRSxlQURILENBQ21CO01BQ2ZELFFBRGU7TUFFZmIsRUFBRSxFQUFFLGNBRlc7TUFHZmUsSUFBSSxFQUFFLGFBSFM7TUFJZnhELElBQUksRUFBRSxNQUpTO01BS2Z5RCxNQUFNLEVBQUUxQixvR0FBbUJBO0lBTFosQ0FEbkIsRUFRR3dCLGVBUkgsQ0FRbUI7TUFDZkQsUUFEZTtNQUVmYixFQUFFLEVBQUUsYUFGVztNQUdmZSxJQUFJLEVBQUUsWUFIUztNQUlmeEQsSUFBSSxFQUFFLEtBSlM7TUFLZnlELE1BQU0sRUFBRXpCLGdGQUFTQTtJQUxGLENBUm5CO0VBZUQ7QUE1Q29FLENBQWhFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQ1A7QUFDQTtBQUdBO0FBRUE7Ozs7QUFZQSxNQUFNNEIsaUJBQTJFLEdBQUl2QixLQUFELElBQVc7RUFDN0YsTUFBTXpGLE1BQU0sR0FBRzhHLHVEQUFVLENBQUN6RCxTQUFELENBQXpCO0VBRUEsTUFBTTtJQUFFbUM7RUFBRixJQUFXQyxLQUFqQjtFQUVBLE1BQU13Qix3QkFBd0IsR0FBSSxVQUFTekIsSUFBSSxTQUFKLElBQUFBLElBQUksV0FBSixJQUFBQSxJQUFJLENBQUUwQixTQUFOLEdBQWtCMUIsSUFBSSxDQUFDMEIsU0FBdkIsR0FBbUMsQ0FBRSxNQUFoRjtFQUVBLG9CQUNFO0lBQ0UsU0FBUyxFQUFFbEgsTUFBTSxDQUFDbUgsVUFEcEI7SUFFRSxLQUFLLEVBQUMsNEJBRlI7SUFHRSxVQUFVLEVBQUMsOEJBSGI7SUFJRSxPQUFPLEVBQUMsY0FKVjtJQUtFLEtBQUssRUFBRTtNQUFFQyxTQUFTLEVBQUVIO0lBQWIsQ0FMVDtJQUFBLG9DQU9FO01BQUcsU0FBUyxFQUFDLE1BQWI7TUFBb0IsTUFBTSxFQUFDLE9BQTNCO01BQW1DLFdBQVcsRUFBQyxNQUEvQztNQUFBLHdCQUNFO1FBQU0sRUFBRSxFQUFDLEtBQVQ7UUFBZSxFQUFFLEVBQUMsS0FBbEI7UUFBd0IsRUFBRSxFQUFDLEtBQTNCO1FBQWlDLEVBQUUsRUFBQztNQUFwQyxFQURGLGVBRUU7UUFBTSxFQUFFLEVBQUMsS0FBVDtRQUFlLEVBQUUsRUFBQyxLQUFsQjtRQUF3QixFQUFFLEVBQUMsS0FBM0I7UUFBaUMsRUFBRSxFQUFDO01BQXBDLEVBRkYsZUFHRTtRQUFNLEVBQUUsRUFBQyxLQUFUO1FBQWUsRUFBRSxFQUFDLEtBQWxCO1FBQXdCLEVBQUUsRUFBQyxLQUEzQjtRQUFpQyxFQUFFLEVBQUM7TUFBcEMsRUFIRixlQUlFO1FBQU0sRUFBRSxFQUFDLEtBQVQ7UUFBZSxFQUFFLEVBQUMsS0FBbEI7UUFBd0IsRUFBRSxFQUFDLEtBQTNCO1FBQWlDLEVBQUUsRUFBQztNQUFwQyxFQUpGO0lBQUEsRUFQRiw4QkFhRTtNQUFHLFNBQVMsRUFBQyxNQUFiO01BQW9CLE1BQU0sRUFBQyxPQUEzQjtNQUFtQyxXQUFXLEVBQUMsTUFBL0M7TUFBQSx3QkFDRTtRQUNFLElBQUksRUFBQyxNQURQO1FBRUUsQ0FBQyxFQUFDO01BRkosRUFERixlQUtFO1FBQVEsRUFBRSxFQUFDLEtBQVg7UUFBaUIsRUFBRSxFQUFDLEtBQXBCO1FBQTBCLENBQUMsRUFBQyxJQUE1QjtRQUFpQyxJQUFJLEVBQUM7TUFBdEMsRUFMRjtJQUFBLEVBYkYsOEJBb0JFO01BQUcsU0FBUyxFQUFDLFFBQWI7TUFBc0IsTUFBTSxFQUFDLE9BQTdCO01BQXFDLFdBQVcsRUFBQyxNQUFqRDtNQUFBLHdCQUNFO1FBQ0UsU0FBUyxFQUFDLE9BRFo7UUFFRSxJQUFJLEVBQUMsTUFGUDtRQUdFLENBQUMsRUFBQztNQUhKLEVBREYsZUFNRTtRQUNFLFNBQVMsRUFBQyxPQURaO1FBRUUsSUFBSSxFQUFDLE1BRlA7UUFHRSxDQUFDLEVBQUM7TUFISixFQU5GO0lBQUEsRUFwQkYsOEJBZ0NFO01BQUcsU0FBUyxFQUFDLFlBQWI7TUFBMEIsSUFBSSxFQUFDLE9BQS9CO01BQUEsd0JBQ0U7UUFDRSxTQUFTLEVBQUMsTUFEWjtRQUVFLENBQUMsRUFBQztNQUZKLEVBREYsZUFLRTtRQUNFLFNBQVMsRUFBQyxNQURaO1FBRUUsQ0FBQyxFQUFDO01BRkosRUFMRjtJQUFBLEVBaENGO0VBQUEsRUFERjtBQTZDRCxDQXBERDs7QUFzRE8sTUFBTUksY0FBMkMsR0FBRztFQUN6RHhCLEVBQUUsRUFBRSxZQURxRDtFQUV6RHpDLElBQUksRUFBRSxhQUZtRDtFQUd6RDBDLFdBQVcsRUFBRSxhQUg0QztFQUt6REMsT0FBTyxFQUFFaUIsaUJBTGdEO0VBT3pEaEIsV0FBVyxFQUFFO0lBQ1hDLEtBQUssRUFBRSxHQURJO0lBRVhDLE1BQU0sRUFBRTtFQUZHLENBUDRDO0VBWXpEQyxhQUFhLEVBQUc1SCxPQUFELHNCQUNWQSxPQURVLENBWjBDO0VBZ0J6RDtFQUNBNkgsV0FBVyxFQUFFLENBQUNDLEdBQUQsRUFBd0JDLEdBQXhCLEtBQWtEO0lBQzdELE1BQU1kLElBQW9CLEdBQUc7TUFDM0IwQixTQUFTLEVBQUVaLEdBQUcsU0FBSCxJQUFBQSxHQUFHLFdBQUgsSUFBQUEsR0FBRyxDQUFFWSxTQUFMLEdBQWlCYixHQUFHLENBQUNpQixTQUFKLENBQWNoQixHQUFHLENBQUNZLFNBQWxCLEVBQTZCbEQsS0FBN0IsRUFBakIsR0FBd0Q7SUFEeEMsQ0FBN0I7SUFJQSxPQUFPd0IsSUFBUDtFQUNELENBdkJ3RDtFQXlCekRnQixpQkFBaUIsRUFBR0MsT0FBRCxJQUFhO0lBQzlCLE1BQU1DLFFBQVEsR0FBRyxDQUFDLGFBQUQsQ0FBakI7SUFDQUQsT0FBTyxDQUFDRSxlQUFSLENBQXdCO01BQ3RCRCxRQURzQjtNQUV0QmIsRUFBRSxFQUFFLFdBRmtCO01BR3RCZSxJQUFJLEVBQUUsa0JBSGdCO01BSXRCeEQsSUFBSSxFQUFFLFlBSmdCO01BS3RCeUQsTUFBTSxFQUFFRSxrRkFBcUJBO0lBTFAsQ0FBeEI7RUFPRDtBQWxDd0QsQ0FBcEQ7O0FBcUNQLE1BQU0xRCxTQUFTLEdBQUlwRCxLQUFELEtBQTJCO0VBQzNDa0gsVUFBVSxFQUFFMUksNkNBQUk7QUFDbEI7QUFDQTtBQUg2QyxDQUEzQixDQUFsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0dBO0FBQ0E7QUFHQTtBQUVBOzs7O0FBWUEsTUFBTThJLGdCQUF3RSxHQUFJOUIsS0FBRCxJQUFXO0VBQzFGLE1BQU16RixNQUFNLEdBQUc4Ryx1REFBVSxDQUFDekQsU0FBRCxDQUF6QjtFQUVBLE1BQU07SUFBRW1DO0VBQUYsSUFBV0MsS0FBakI7RUFFQSxNQUFNK0IsNEJBQTRCLEdBQUksVUFBU2hDLElBQUksU0FBSixJQUFBQSxJQUFJLFdBQUosSUFBQUEsSUFBSSxDQUFFaUMsVUFBTixHQUFtQmpDLElBQUksQ0FBQ2lDLFVBQXhCLEdBQXFDLENBQUUsTUFBdEY7RUFFQSxvQkFDRTtJQUNFLFNBQVMsRUFBRXpILE1BQU0sQ0FBQzBILFNBRHBCO0lBRUUsS0FBSyxFQUFDLDRCQUZSO0lBR0UsVUFBVSxFQUFDLDhCQUhiO0lBSUUsT0FBTyxFQUFDLGNBSlY7SUFLRSxLQUFLLEVBQUU7TUFBRU4sU0FBUyxFQUFFSTtJQUFiLENBTFQ7SUFBQSxvQ0FPRTtNQUFHLFNBQVMsRUFBQyxNQUFiO01BQW9CLE1BQU0sRUFBQyxPQUEzQjtNQUFtQyxXQUFXLEVBQUMsTUFBL0M7TUFBQSx3QkFDRTtRQUFNLEVBQUUsRUFBQyxLQUFUO1FBQWUsRUFBRSxFQUFDLEtBQWxCO1FBQXdCLEVBQUUsRUFBQyxLQUEzQjtRQUFpQyxFQUFFLEVBQUM7TUFBcEMsRUFERixlQUVFO1FBQU0sRUFBRSxFQUFDLEtBQVQ7UUFBZSxFQUFFLEVBQUMsS0FBbEI7UUFBd0IsRUFBRSxFQUFDLEtBQTNCO1FBQWlDLEVBQUUsRUFBQztNQUFwQyxFQUZGLGVBR0U7UUFBTSxFQUFFLEVBQUMsS0FBVDtRQUFlLEVBQUUsRUFBQyxLQUFsQjtRQUF3QixFQUFFLEVBQUMsS0FBM0I7UUFBaUMsRUFBRSxFQUFDO01BQXBDLEVBSEYsZUFJRTtRQUFNLEVBQUUsRUFBQyxLQUFUO1FBQWUsRUFBRSxFQUFDLEtBQWxCO1FBQXdCLEVBQUUsRUFBQyxLQUEzQjtRQUFpQyxFQUFFLEVBQUM7TUFBcEMsRUFKRjtJQUFBLEVBUEYsOEJBYUU7TUFBRyxTQUFTLEVBQUMsTUFBYjtNQUFvQixNQUFNLEVBQUMsT0FBM0I7TUFBbUMsV0FBVyxFQUFDLE1BQS9DO01BQUEsdUJBQ0U7UUFDRSxJQUFJLEVBQUMsTUFEUDtRQUVFLENBQUMsRUFBQztNQUZKO0lBREYsRUFiRiw4QkFtQkU7TUFBRyxTQUFTLEVBQUMsUUFBYjtNQUFzQixNQUFNLEVBQUMsT0FBN0I7TUFBcUMsV0FBVyxFQUFDLE1BQWpEO01BQUEsd0JBQ0U7UUFDRSxTQUFTLEVBQUMsT0FEWjtRQUVFLElBQUksRUFBQyxNQUZQO1FBR0UsQ0FBQyxFQUFDO01BSEosRUFERixlQU1FO1FBQ0UsU0FBUyxFQUFDLE9BRFo7UUFFRSxJQUFJLEVBQUMsTUFGUDtRQUdFLENBQUMsRUFBQztNQUhKLEVBTkY7SUFBQSxFQW5CRiw4QkErQkU7TUFBRyxTQUFTLEVBQUMsWUFBYjtNQUEwQixJQUFJLEVBQUMsT0FBL0I7TUFBQSx3QkFDRTtRQUNFLFNBQVMsRUFBQyxNQURaO1FBRUUsQ0FBQyxFQUFDO01BRkosRUFERixlQUtFO1FBQ0UsU0FBUyxFQUFDLE1BRFo7UUFFRSxDQUFDLEVBQUM7TUFGSixFQUxGO0lBQUEsRUEvQkY7RUFBQSxFQURGO0FBNENELENBbkREOztBQXFETyxNQUFNRyxhQUEwQyxHQUFHO0VBQ3hEOUIsRUFBRSxFQUFFLFdBRG9EO0VBRXhEekMsSUFBSSxFQUFFLFlBRmtEO0VBR3hEMEMsV0FBVyxFQUFFLFlBSDJDO0VBS3hEQyxPQUFPLEVBQUV3QixnQkFMK0M7RUFPeER2QixXQUFXLEVBQUU7SUFDWEMsS0FBSyxFQUFFLEdBREk7SUFFWEMsTUFBTSxFQUFFO0VBRkcsQ0FQMkM7RUFZeERDLGFBQWEsRUFBRzVILE9BQUQsc0JBQ1ZBLE9BRFUsQ0FaeUM7RUFnQnhEO0VBQ0E2SCxXQUFXLEVBQUUsQ0FBQ0MsR0FBRCxFQUF3QkMsR0FBeEIsS0FBaUQ7SUFDNUQsTUFBTWQsSUFBbUIsR0FBRztNQUMxQmlDLFVBQVUsRUFBRW5CLEdBQUcsU0FBSCxJQUFBQSxHQUFHLFdBQUgsSUFBQUEsR0FBRyxDQUFFbUIsVUFBTCxHQUFrQnBCLEdBQUcsQ0FBQ2lCLFNBQUosQ0FBY2hCLEdBQUcsQ0FBQ21CLFVBQWxCLEVBQThCekQsS0FBOUIsRUFBbEIsR0FBMEQ7SUFENUMsQ0FBNUI7SUFJQSxPQUFPd0IsSUFBUDtFQUNELENBdkJ1RDtFQXlCeERnQixpQkFBaUIsRUFBR0MsT0FBRCxJQUFhO0lBQzlCLE1BQU1DLFFBQVEsR0FBRyxDQUFDLFlBQUQsQ0FBakI7SUFDQUQsT0FBTyxDQUFDRSxlQUFSLENBQXdCO01BQ3RCRCxRQURzQjtNQUV0QmIsRUFBRSxFQUFFLFlBRmtCO01BR3RCZSxJQUFJLEVBQUUsbUJBSGdCO01BSXRCeEQsSUFBSSxFQUFFLGFBSmdCO01BS3RCeUQsTUFBTSxFQUFFRSxrRkFBcUJBO0lBTFAsQ0FBeEI7RUFPRDtBQWxDdUQsQ0FBbkQ7O0FBcUNQLE1BQU0xRCxTQUFTLEdBQUlwRCxLQUFELEtBQTJCO0VBQzNDeUgsU0FBUyxFQUFFakosNkNBQUk7QUFDakI7QUFDQTtBQUg2QyxDQUEzQixDQUFsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFHQTtBQUVBOzs7O0FBb0JBLE1BQU1tSixlQUFxRSxHQUFJbkMsS0FBRCxJQUFXO0VBQ3ZGLE1BQU16RixNQUFNLEdBQUc4Ryx1REFBVSxDQUFDekQsU0FBRCxDQUF6QjtFQUVBLE1BQU07SUFBRW1DO0VBQUYsSUFBV0MsS0FBakI7RUFFQSxNQUFNb0Msb0JBQW9CLEdBQUksUUFBT3JDLElBQUksU0FBSixJQUFBQSxJQUFJLFdBQUosSUFBQUEsSUFBSSxDQUFFc0MsY0FBTixHQUF1QixLQUFLQyxJQUFJLENBQUNDLEdBQUwsQ0FBU3hDLElBQUksQ0FBQ3NDLGNBQWQsQ0FBNUIsR0FBNEQsQ0FBRSxtQkFBbkc7RUFFQSxNQUFNRyxtQkFBbUIsR0FBSSxRQUFPekMsSUFBSSxTQUFKLElBQUFBLElBQUksV0FBSixJQUFBQSxJQUFJLENBQUUwQyxhQUFOLEdBQXNCLEtBQUtILElBQUksQ0FBQ0MsR0FBTCxDQUFTeEMsSUFBSSxDQUFDMEMsYUFBZCxDQUEzQixHQUEwRCxDQUFFLG1CQUFoRztFQUVBLE1BQU1DLG9CQUFvQixHQUFJLFFBQU8zQyxJQUFJLFNBQUosSUFBQUEsSUFBSSxXQUFKLElBQUFBLElBQUksQ0FBRTRDLGNBQU4sR0FBdUIsS0FBS0wsSUFBSSxDQUFDQyxHQUFMLENBQVN4QyxJQUFJLENBQUM0QyxjQUFkLENBQTVCLEdBQTRELENBQUUsbUJBQW5HO0VBRUEsTUFBTUMsbUJBQW1CLEdBQUksUUFBTzdDLElBQUksU0FBSixJQUFBQSxJQUFJLFdBQUosSUFBQUEsSUFBSSxDQUFFOEMsYUFBTixHQUFzQixLQUFLUCxJQUFJLENBQUNDLEdBQUwsQ0FBU3hDLElBQUksQ0FBQzhDLGFBQWQsQ0FBM0IsR0FBMEQsQ0FBRSxtQkFBaEc7RUFFQSxNQUFNQyxzQkFBc0IsR0FBSSxVQUFTL0MsSUFBSSxTQUFKLElBQUFBLElBQUksV0FBSixJQUFBQSxJQUFJLENBQUVnRCxRQUFOLEdBQWlCaEQsSUFBSSxDQUFDZ0QsUUFBdEIsR0FBaUMsQ0FBRSxNQUE1RTtFQUVBLG9CQUNFO0lBQ0UsS0FBSyxFQUFDLDRCQURSO0lBRUUsVUFBVSxFQUFDLDhCQUZiO0lBR0UsT0FBTyxFQUFDLGlCQUhWO0lBSUUsUUFBUSxFQUFDLFVBSlg7SUFLRSxLQUFLLEVBQUU7TUFBRXBCLFNBQVMsRUFBRW1CO0lBQWIsQ0FMVDtJQUFBLDBDQU9FO01BQ0UsUUFBUSxFQUFDLFNBRFg7TUFFRSxDQUFDLEVBQUM7SUFGSixFQVBGLG9DQVdFO01BQ0UsUUFBUSxFQUFDLFNBRFg7TUFFRSxDQUFDLEVBQUM7SUFGSixFQVhGLGdCQWVFO01BQUcsU0FBUyxFQUFDLGlCQUFiO01BQUEsd0JBQ0U7UUFDRSxTQUFTLEVBQUcsR0FBRXZJLE1BQU0sQ0FBQ3lJLFNBQVUsSUFBR3pJLE1BQU0sQ0FBQzBJLFdBQVksRUFEdkQ7UUFFRSxLQUFLLEVBQUU7VUFBRUMsU0FBUyxFQUFFUjtRQUFiLENBRlQ7UUFHRSxDQUFDLEVBQUM7TUFISixFQURGLGVBTUU7UUFDRSxTQUFTLEVBQUcsR0FBRW5JLE1BQU0sQ0FBQ3lJLFNBQVUsSUFBR3pJLE1BQU0sQ0FBQzRJLFlBQWEsRUFEeEQ7UUFFRSxLQUFLLEVBQUU7VUFBRUQsU0FBUyxFQUFFZDtRQUFiLENBRlQ7UUFHRSxDQUFDLEVBQUM7TUFISixFQU5GLGVBV0U7UUFDRSxTQUFTLEVBQUcsR0FBRTdILE1BQU0sQ0FBQ3lJLFNBQVUsSUFBR3pJLE1BQU0sQ0FBQzRJLFlBQWEsRUFEeEQ7UUFFRSxLQUFLLEVBQUU7VUFBRUQsU0FBUyxFQUFFTjtRQUFiLENBRlQ7UUFHRSxDQUFDLEVBQUM7TUFISixFQVhGLGVBZ0JFO1FBQ0UsU0FBUyxFQUFHLEdBQUVySSxNQUFNLENBQUN5SSxTQUFVLElBQUd6SSxNQUFNLENBQUMwSSxXQUFZLEVBRHZEO1FBRUUsS0FBSyxFQUFFO1VBQUVDLFNBQVMsRUFBRVY7UUFBYixDQUZUO1FBR0UsQ0FBQyxFQUFDO01BSEosRUFoQkY7SUFBQSxFQWZGO0VBQUEsRUFERjtBQXdDRCxDQXZERDs7QUF5RE8sTUFBTVksWUFBeUMsR0FBRztFQUN2RGhELEVBQUUsRUFBRSxVQURtRDtFQUV2RHpDLElBQUksRUFBRSxXQUZpRDtFQUd2RDBDLFdBQVcsRUFBRSxXQUgwQztFQUt2REMsT0FBTyxFQUFFNkIsZUFMOEM7RUFPdkQ1QixXQUFXLEVBQUU7SUFDWEMsS0FBSyxFQUFFLEdBREk7SUFFWEMsTUFBTSxFQUFFO0VBRkcsQ0FQMEM7RUFZdkRDLGFBQWEsRUFBRzVILE9BQUQsc0JBQ1ZBLE9BRFUsQ0Fad0M7RUFnQnZEO0VBQ0E2SCxXQUFXLEVBQUUsQ0FBQ0MsR0FBRCxFQUF3QkMsR0FBeEIsS0FBZ0Q7SUFDM0QsTUFBTWQsSUFBa0IsR0FBRztNQUN6QjRDLGNBQWMsRUFBRTlCLEdBQUcsU0FBSCxJQUFBQSxHQUFHLFdBQUgsSUFBQUEsR0FBRyxDQUFFOEIsY0FBTCxHQUFzQi9CLEdBQUcsQ0FBQ2lCLFNBQUosQ0FBY2hCLEdBQUcsQ0FBQzhCLGNBQWxCLEVBQWtDcEUsS0FBbEMsRUFBdEIsR0FBa0UsQ0FEekQ7TUFFekJzRSxhQUFhLEVBQUVoQyxHQUFHLFNBQUgsSUFBQUEsR0FBRyxXQUFILElBQUFBLEdBQUcsQ0FBRWdDLGFBQUwsR0FBcUJqQyxHQUFHLENBQUNpQixTQUFKLENBQWNoQixHQUFHLENBQUNnQyxhQUFsQixFQUFpQ3RFLEtBQWpDLEVBQXJCLEdBQWdFLENBRnREO01BR3pCOEQsY0FBYyxFQUFFeEIsR0FBRyxTQUFILElBQUFBLEdBQUcsV0FBSCxJQUFBQSxHQUFHLENBQUV3QixjQUFMLEdBQXNCekIsR0FBRyxDQUFDaUIsU0FBSixDQUFjaEIsR0FBRyxDQUFDd0IsY0FBbEIsRUFBa0M5RCxLQUFsQyxFQUF0QixHQUFrRSxDQUh6RDtNQUl6QmtFLGFBQWEsRUFBRTVCLEdBQUcsU0FBSCxJQUFBQSxHQUFHLFdBQUgsSUFBQUEsR0FBRyxDQUFFNEIsYUFBTCxHQUFxQjdCLEdBQUcsQ0FBQ2lCLFNBQUosQ0FBY2hCLEdBQUcsQ0FBQzRCLGFBQWxCLEVBQWlDbEUsS0FBakMsRUFBckIsR0FBZ0UsQ0FKdEQ7TUFLekJ3RSxRQUFRLEVBQUVsQyxHQUFHLFNBQUgsSUFBQUEsR0FBRyxXQUFILElBQUFBLEdBQUcsQ0FBRWtDLFFBQUwsR0FBZ0JuQyxHQUFHLENBQUNpQixTQUFKLENBQWNoQixHQUFHLENBQUNrQyxRQUFsQixFQUE0QnhFLEtBQTVCLEVBQWhCLEdBQXNEO0lBTHZDLENBQTNCO0lBUUEsT0FBT3dCLElBQVA7RUFDRCxDQTNCc0Q7RUE2QnZEZ0IsaUJBQWlCLEVBQUdDLE9BQUQsSUFBYTtJQUM5QixNQUFNQyxRQUFRLEdBQUcsQ0FBQyxXQUFELENBQWpCO0lBQ0FELE9BQU8sQ0FDSkUsZUFESCxDQUNtQjtNQUNmRCxRQURlO01BRWZiLEVBQUUsRUFBRSxVQUZXO01BR2ZlLElBQUksRUFBRSxpQkFIUztNQUlmeEQsSUFBSSxFQUFFLFdBSlM7TUFLZnlELE1BQU0sRUFBRUUsa0ZBQXFCQTtJQUxkLENBRG5CLEVBUUdKLGVBUkgsQ0FRbUI7TUFDZkQsUUFEZTtNQUVmYixFQUFFLEVBQUUsZ0JBRlc7TUFHZmUsSUFBSSxFQUFFLHVCQUhTO01BSWZ4RCxJQUFJLEVBQUUsdUJBSlM7TUFLZnlELE1BQU0sRUFBRUUsa0ZBQXFCQTtJQUxkLENBUm5CLEVBZUdKLGVBZkgsQ0FlbUI7TUFDZkQsUUFEZTtNQUVmYixFQUFFLEVBQUUsZUFGVztNQUdmZSxJQUFJLEVBQUUsc0JBSFM7TUFJZnhELElBQUksRUFBRSxzQkFKUztNQUtmeUQsTUFBTSxFQUFFRSxrRkFBcUJBO0lBTGQsQ0FmbkIsRUFzQkdKLGVBdEJILENBc0JtQjtNQUNmRCxRQURlO01BRWZiLEVBQUUsRUFBRSxnQkFGVztNQUdmZSxJQUFJLEVBQUUsdUJBSFM7TUFJZnhELElBQUksRUFBRSxzQkFKUztNQUtmeUQsTUFBTSxFQUFFRSxrRkFBcUJBO0lBTGQsQ0F0Qm5CLEVBNkJHSixlQTdCSCxDQTZCbUI7TUFDZkQsUUFEZTtNQUVmYixFQUFFLEVBQUUsZUFGVztNQUdmZSxJQUFJLEVBQUUsc0JBSFM7TUFJZnhELElBQUksRUFBRSxxQkFKUztNQUtmeUQsTUFBTSxFQUFFRSxrRkFBcUJBO0lBTGQsQ0E3Qm5CO0VBb0NEO0FBbkVzRCxDQUFsRDs7QUFzRVAsTUFBTTFELFNBQVMsR0FBSXBELEtBQUQsS0FBMkI7RUFDM0N3SSxTQUFTLEVBQUVoSyw2Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FiNkM7RUFjM0NpSyxXQUFXLEVBQUVqSyw2Q0FBSTtBQUNuQjtBQUNBLEdBaEI2QztFQWlCM0NtSyxZQUFZLEVBQUVuSyw2Q0FBSTtBQUNwQjtBQUNBO0FBbkI2QyxDQUEzQixDQUFsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUNBOztBQW9CQTtBQUNBLE1BQU0ySyxrQkFBa0IsR0FBRzNLLDZDQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLENBSkE7QUFNTyxTQUFTNEssV0FBVCxDQUFxQjVELEtBQXJCLEVBQWdEO0VBQ3JELE1BQU07SUFBRUQ7RUFBRixJQUFXQyxLQUFqQjs7RUFDQSxJQUFJLEVBQUNELElBQUQsYUFBQ0EsSUFBRCxlQUFDQSxJQUFJLENBQUVvQixJQUFQLENBQUosRUFBaUI7SUFDZixPQUFPLElBQVA7RUFDRDs7RUFFRCxNQUFNbEIsT0FBTyxHQUFHLE1BQU07SUFDcEIsSUFBSUYsSUFBSixhQUFJQSxJQUFKLGVBQUlBLElBQUksQ0FBRUcsR0FBVixFQUFlO01BQ2JOLGtGQUFPLENBQUNHLElBQUksQ0FBQ0csR0FBTixDQUFQO0lBQ0Q7RUFDRixDQUpEOztFQU1BLE1BQU0yRCxRQUF1QixHQUFHO0lBQzlCQyxJQUFJLEVBQUUvRCxJQUFGLGFBQUVBLElBQUYsdUJBQUVBLElBQUksQ0FBRStELElBRGtCO0lBRTlCQyxNQUFNLEVBQUVoRSxJQUFGLGFBQUVBLElBQUYsdUJBQUVBLElBQUksQ0FBRWlFLFdBRmdCO0lBRzlCQyxXQUFXLEVBQUVsRSxJQUFGLGFBQUVBLElBQUYsdUJBQUVBLElBQUksQ0FBRWdFO0VBSFcsQ0FBaEM7RUFNQSxvQkFDRSx1REFBQyx1REFBRDtJQUNFLE9BQU8sRUFBRTlELE9BRFg7SUFFRSxHQUFHLEVBQUVGLElBQUksQ0FBQ29CLElBRlo7SUFHRSxLQUFLLEVBQUUwQyxRQUhUO0lBSUUsU0FBUyxFQUFFQSxRQUFRLENBQUNJLFdBQVQsR0FBdUJOLGtCQUF2QixHQUE0QzVIO0VBSnpELEVBREY7QUFRRDtBQUVNLE1BQU1tSSxRQUFpRCxHQUFHO0VBQy9EOUQsRUFBRSxFQUFFLE1BRDJEO0VBRS9EekMsSUFBSSxFQUFFLE1BRnlEO0VBRy9EMEMsV0FBVyxFQUFFLGtCQUhrRDtFQUsvREMsT0FBTyxFQUFFc0QsV0FMc0Q7RUFPL0RsRCxhQUFhLEVBQUc1SCxPQUFEO0lBQ2JxTCxTQUFTLEVBQUU7TUFDVDNELEtBQUssRUFBRSxFQURFO01BRVRDLE1BQU0sRUFBRSxFQUZDO01BR1QyRCxHQUFHLEVBQUUsQ0FISTtNQUlUQyxJQUFJLEVBQUU7SUFKRztFQURFLEdBT1Z2TCxPQVBVO0lBUWJPLE1BQU0sRUFBRTtNQUNOOEgsSUFBSSxFQUFFO1FBQ0ptRCxJQUFJLEVBQUVmLGdGQURGO1FBRUppQixLQUFLLEVBQUU7TUFGSCxDQURBO01BS05WLElBQUksRUFBRTtRQUFFVSxLQUFLLEVBQUU7TUFBVDtJQUxBO0VBUkssRUFQZ0Q7RUF3Qi9EO0VBQ0E3RCxXQUFXLEVBQUUsQ0FBQ0MsR0FBRCxFQUF3QkMsR0FBeEIsS0FBNEM7SUFBQTs7SUFDdkQsSUFBSU0sSUFBd0IsR0FBR3BGLFNBQS9COztJQUNBLElBQUk4RSxHQUFHLENBQUNNLElBQVIsRUFBYztNQUNaQSxJQUFJLEdBQUdQLEdBQUcsQ0FBQzZELFdBQUosQ0FBZ0I1RCxHQUFHLENBQUNNLElBQXBCLEVBQTBCNUMsS0FBMUIsRUFBUDtJQUNEOztJQUNELElBQUksQ0FBQzRDLElBQUQsSUFBUyxDQUFDa0MsZ0RBQVEsQ0FBQ2xDLElBQUQsQ0FBdEIsRUFBOEI7TUFDNUJBLElBQUksR0FBR3FDLCtFQUFzQixDQUFDLHVDQUFELENBQTdCO0lBQ0Q7O0lBRUQsTUFBTXpELElBQWMsR0FBRztNQUNyQm9CLElBRHFCO01BRXJCMkMsSUFBSSxFQUFFakQsR0FBRyxDQUFDaUQsSUFBSixHQUFXbEQsR0FBRyxDQUFDOEQsUUFBSixDQUFhN0QsR0FBRyxDQUFDaUQsSUFBakIsRUFBdUJ2RixLQUF2QixFQUFYLEdBQTRDLE1BRjdCO01BR3JCMkIsR0FBRyxjQUFFVyxHQUFGLGFBQUVBLEdBQUYsdUJBQUVBLEdBQUcsQ0FBRVgsR0FBUCwrQ0FBY25FO0lBSEksQ0FBdkI7O0lBTUEsSUFBSSxlQUFBOEUsR0FBRyxDQUFDa0QsTUFBSixvREFBWXZELEtBQVosSUFBcUJLLEdBQUcsQ0FBQ2tELE1BQUosQ0FBV1ksS0FBcEMsRUFBMkM7TUFDekMsSUFBSTlELEdBQUcsQ0FBQ2tELE1BQUosQ0FBV3ZELEtBQVgsR0FBbUIsQ0FBdkIsRUFBMEI7UUFBQTs7UUFDeEJULElBQUksQ0FBQ2dFLE1BQUwsbUJBQWNsRCxHQUFHLENBQUNrRCxNQUFsQixpREFBYyxhQUFZdkQsS0FBMUI7UUFDQVQsSUFBSSxDQUFDaUUsV0FBTCxHQUFtQnBELEdBQUcsQ0FBQzhELFFBQUosQ0FBYTdELEdBQUcsQ0FBQ2tELE1BQUosQ0FBV1ksS0FBeEIsRUFBK0JwRyxLQUEvQixFQUFuQjtNQUNEO0lBQ0Y7O0lBQ0QsT0FBT3dCLElBQVA7RUFDRCxDQS9DOEQ7RUFpRC9EO0VBQ0FnQixpQkFBaUIsRUFBR0MsT0FBRCxJQUFhO0lBQzlCLE1BQU1DLFFBQVEsR0FBRyxDQUFDLE1BQUQsQ0FBakI7SUFDQUQsT0FBTyxDQUNKRSxlQURILENBQ21CO01BQ2ZELFFBRGU7TUFFZmIsRUFBRSxFQUFFLGNBRlc7TUFHZmUsSUFBSSxFQUFFLGFBSFM7TUFJZnhELElBQUksRUFBRSxVQUpTO01BS2Z5RCxNQUFNLEVBQUVzQyxvRkFMTztNQU1ma0IsUUFBUSxFQUFFO1FBQ1JDLFlBQVksRUFBRTtNQUROO0lBTkssQ0FEbkIsRUFXRzNELGVBWEgsQ0FXbUI7TUFDZkQsUUFEZTtNQUVmYixFQUFFLEVBQUUsYUFGVztNQUdmZSxJQUFJLEVBQUUsYUFIUztNQUlmeEQsSUFBSSxFQUFFLFlBSlM7TUFLZnlELE1BQU0sRUFBRXFDLGlGQUxPO01BTWZtQixRQUFRLEVBQUUsRUFOSztNQU9mRSxZQUFZLEVBQUU7UUFDWjtRQUNBTixLQUFLLEVBQUU7TUFGSztJQVBDLENBWG5CLEVBdUJHTyxjQXZCSCxDQXVCa0I7TUFDZDlELFFBRGM7TUFFZEUsSUFBSSxFQUFFLHFCQUZRO01BR2R4RCxJQUFJLEVBQUUsUUFIUTtNQUlkbUgsWUFBWSxFQUFFLENBSkE7TUFLZEYsUUFBUSxFQUFFO1FBQ1JJLEdBQUcsRUFBRSxDQURHO1FBRVJDLEdBQUcsRUFBRTtNQUZHO0lBTEksQ0F2QmxCLEVBaUNHL0QsZUFqQ0gsQ0FpQ21CO01BQ2ZELFFBRGU7TUFFZmIsRUFBRSxFQUFFLHFCQUZXO01BR2ZlLElBQUksRUFBRSxxQkFIUztNQUlmeEQsSUFBSSxFQUFFLGNBSlM7TUFLZnlELE1BQU0sRUFBRXFDLGlGQUxPO01BTWZtQixRQUFRLEVBQUUsRUFOSztNQU9mRSxZQUFZLEVBQUU7UUFDWjtRQUNBTixLQUFLLEVBQUU7TUFGSyxDQVBDO01BV2ZVLE1BQU0sRUFBR3JFLEdBQUQ7UUFBQTs7UUFBQSxPQUFTcEYsT0FBTyxDQUFDb0YsR0FBRCxhQUFDQSxHQUFELHNDQUFDQSxHQUFHLENBQUV4SCxNQUFOLHNFQUFDLFlBQWEwSyxNQUFkLHVEQUFDLG1CQUFxQnZELEtBQXRCLENBQWhCO01BQUE7SUFYTyxDQWpDbkIsRUE4Q0dVLGVBOUNILENBOENtQjtNQUNmRCxRQURlO01BRWZiLEVBQUUsRUFBRSxhQUZXO01BR2ZlLElBQUksRUFBRSxZQUhTO01BSWZ4RCxJQUFJLEVBQUUsS0FKUztNQUtmeUQsTUFBTSxFQUFFekIsZ0ZBQVNBO0lBTEYsQ0E5Q25CO0VBcUREO0FBekc4RCxDQUExRDs7Ozs7Ozs7Ozs7Ozs7O0FDcEVQOzs7O0FBUUEsTUFBTXdGLGVBQU4sU0FBOEIzRixnREFBOUIsQ0FBZ0Y7RUFDOUVNLE1BQU0sR0FBRztJQUNQLE1BQU07TUFBRXpHO0lBQUYsSUFBYSxLQUFLMkcsS0FBeEI7SUFDQSxvQkFDRTtNQUFBLG9DQUNFO1FBQUE7TUFBQSxFQURGLGdCQUVFO1FBQUEsVUFBTW9GLElBQUksQ0FBQ0MsU0FBTCxDQUFlaE0sTUFBZixFQUF1QixJQUF2QixFQUE2QixDQUE3QjtNQUFOLEVBRkY7SUFBQSxFQURGO0VBTUQ7O0FBVDZFOztBQVl6RSxNQUFNaU0sWUFBK0MsR0FBRztFQUM3RGxGLEVBQUUsRUFBRSxXQUR5RDtFQUU3RHpDLElBQUksRUFBRSxXQUZ1RDtFQUc3RDBDLFdBQVcsRUFBRSx3REFIZ0Q7RUFLN0RDLE9BQU8sRUFBRTZFLGVBTG9EO0VBTzdENUUsV0FBVyxFQUFFO0lBQ1hDLEtBQUssRUFBRSxHQURJO0lBRVhDLE1BQU0sRUFBRTtFQUZHLENBUGdEO0VBWTdEQyxhQUFhLEVBQUUsT0FBTztJQUNwQnJILE1BQU0sRUFBRTtFQURZLENBQVA7QUFaOEMsQ0FBeEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEJQO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTs7QUFLTyxJQUFLa00sS0FBWjs7V0FBWUE7RUFBQUE7RUFBQUE7RUFBQUE7R0FBQUEsVUFBQUE7O0FBTUwsSUFBS0MsTUFBWjs7V0FBWUE7RUFBQUE7RUFBQUE7RUFBQUE7R0FBQUEsV0FBQUE7O0FBc0JaLE1BQU1DLGNBQU4sU0FBNkJqRyxnREFBN0IsQ0FBMkY7RUFDekZNLE1BQU0sR0FBRztJQUNQLE1BQU07TUFBRUM7SUFBRixJQUFXLEtBQUtDLEtBQXRCO0lBQ0EsTUFBTXpGLE1BQU0sR0FBR3FELFNBQVMsQ0FBQ3ZFLDBEQUFELEVBQWdCMEcsSUFBaEIsQ0FBeEI7SUFDQSxvQkFDRTtNQUFLLFNBQVMsRUFBRXhGLE1BQU0sQ0FBQ29MLFNBQXZCO01BQUEsdUJBQ0U7UUFBTSxTQUFTLEVBQUVwTCxNQUFNLENBQUNxTCxJQUF4QjtRQUFBLFVBQStCN0YsSUFBL0IsYUFBK0JBLElBQS9CLHVCQUErQkEsSUFBSSxDQUFFM0M7TUFBckM7SUFERixFQURGO0VBS0Q7O0FBVHdGOztBQVczRixNQUFNUSxTQUFTLEdBQUdwRSwwREFBYSxDQUFDLENBQUNnQixLQUFELEVBQXVCdUYsSUFBdkIsTUFBaUM7RUFDL0Q0RixTQUFTLEVBQUUzTSw2Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBTmlFO0VBTy9ENE0sSUFBSSxFQUFFNU0sNkNBQUk7QUFDWjtBQUNBLHNCQUFzQitHLElBQUksQ0FBQzhGLE1BQU87QUFDbEMsa0JBQWtCOUYsSUFBSSxDQUFDK0YsS0FBTTtBQUM3QixpQkFBaUIvRixJQUpOLGFBSU1BLElBSk4sdUJBSU1BLElBQUksQ0FBRWdHLElBQUs7QUFDNUIsYUFBYWhHLElBTEYsYUFLRUEsSUFMRix1QkFLRUEsSUFBSSxDQUFFNEUsS0FBTTtBQUN6QjtBQWJpRSxDQUFqQyxDQUFELENBQS9CO0FBZU8sTUFBTXFCLFdBQTBELEdBQUc7RUFDeEU1RixFQUFFLEVBQUUsVUFEb0U7RUFFeEV6QyxJQUFJLEVBQUUsTUFGa0U7RUFHeEUwQyxXQUFXLEVBQUUsVUFIMkQ7RUFLeEVDLE9BQU8sRUFBRW1GLGNBTCtEO0VBT3hFbEYsV0FBVyxFQUFFO0lBQ1hDLEtBQUssRUFBRSxHQURJO0lBRVhDLE1BQU0sRUFBRTtFQUZHLENBUDJEO0VBWXhFQyxhQUFhLEVBQUc1SCxPQUFEO0lBQ2JtTixVQUFVLEVBQUU7TUFDVnRCLEtBQUssRUFBRTtRQUNMSCxLQUFLLEVBQUU7TUFERjtJQURHO0VBREMsR0FNVjFMLE9BTlU7SUFPYk8sTUFBTSxFQUFFO01BQ055TSxLQUFLLEVBQUVQLEtBQUssQ0FBQ1csSUFEUDtNQUVOTCxNQUFNLEVBQUVMLE1BQU0sQ0FBQ1c7SUFGVDtFQVBLLEVBWnlEO0VBeUJ4RTtFQUNBeEYsV0FBVyxFQUFFLENBQUNDLEdBQUQsRUFBd0JDLEdBQXhCLEtBQStDO0lBQUE7O0lBQzFELE1BQU1kLElBQWlCLEdBQUc7TUFDeEIzQyxJQUFJLEVBQUV5RCxHQUFHLENBQUN6RCxJQUFKLEdBQVd3RCxHQUFHLENBQUNFLE9BQUosQ0FBWUQsR0FBRyxDQUFDekQsSUFBaEIsRUFBc0JtQixLQUF0QixFQUFYLEdBQTJDLEVBRHpCO01BRXhCdUgsS0FBSyxnQkFBRWpGLEdBQUcsQ0FBQ2lGLEtBQU4sbURBQWVQLEtBQUssQ0FBQ2EsTUFGRjtNQUd4QlAsTUFBTSxpQkFBRWhGLEdBQUcsQ0FBQ2dGLE1BQU4scURBQWdCTCxNQUFNLENBQUNXLE1BSEw7TUFJeEJKLElBQUksRUFBRWxGLEdBQUcsQ0FBQ2tGO0lBSmMsQ0FBMUI7O0lBT0EsSUFBSWxGLEdBQUcsQ0FBQzhELEtBQVIsRUFBZTtNQUNiNUUsSUFBSSxDQUFDNEUsS0FBTCxHQUFhL0QsR0FBRyxDQUFDOEQsUUFBSixDQUFhN0QsR0FBRyxDQUFDOEQsS0FBakIsRUFBd0JwRyxLQUF4QixFQUFiO0lBQ0Q7O0lBRUQsT0FBT3dCLElBQVA7RUFDRCxDQXZDdUU7RUF5Q3hFO0VBQ0FnQixpQkFBaUIsRUFBR0MsT0FBRCxJQUFhO0lBQzlCLE1BQU1DLFFBQVEsR0FBRyxDQUFDLFVBQUQsQ0FBakI7SUFDQUQsT0FBTyxDQUNKRSxlQURILENBQ21CO01BQ2ZELFFBRGU7TUFFZmIsRUFBRSxFQUFFLGNBRlc7TUFHZmUsSUFBSSxFQUFFLGFBSFM7TUFJZnhELElBQUksRUFBRSxNQUpTO01BS2Z5RCxNQUFNLEVBQUUxQixvR0FBbUJBO0lBTFosQ0FEbkIsRUFRR3dCLGVBUkgsQ0FRbUI7TUFDZkQsUUFEZTtNQUVmYixFQUFFLEVBQUUsY0FGVztNQUdmZSxJQUFJLEVBQUUsY0FIUztNQUlmeEQsSUFBSSxFQUFFLFlBSlM7TUFLZnlELE1BQU0sRUFBRXFDLHNHQUxPO01BTWZtQixRQUFRLEVBQUUsRUFOSztNQU9mRSxZQUFZLEVBQUU7SUFQQyxDQVJuQixFQWlCR3VCLFFBakJILENBaUJZO01BQ1JwRixRQURRO01BRVJFLElBQUksRUFBRSxjQUZFO01BR1J4RCxJQUFJLEVBQUUsWUFIRTtNQUlSaUgsUUFBUSxFQUFFO1FBQ1I5TCxPQUFPLEVBQUUsQ0FDUDtVQUFFeUYsS0FBSyxFQUFFZ0gsS0FBSyxDQUFDVyxJQUFmO1VBQXFCbk4sS0FBSyxFQUFFO1FBQTVCLENBRE8sRUFFUDtVQUFFd0YsS0FBSyxFQUFFZ0gsS0FBSyxDQUFDYSxNQUFmO1VBQXVCck4sS0FBSyxFQUFFO1FBQTlCLENBRk8sRUFHUDtVQUFFd0YsS0FBSyxFQUFFZ0gsS0FBSyxDQUFDZSxLQUFmO1VBQXNCdk4sS0FBSyxFQUFFO1FBQTdCLENBSE87TUFERCxDQUpGO01BV1IrTCxZQUFZLEVBQUVTLEtBQUssQ0FBQ1c7SUFYWixDQWpCWixFQThCR0csUUE5QkgsQ0E4Qlk7TUFDUnBGLFFBRFE7TUFFUkUsSUFBSSxFQUFFLGVBRkU7TUFHUnhELElBQUksRUFBRSxnQkFIRTtNQUlSaUgsUUFBUSxFQUFFO1FBQ1I5TCxPQUFPLEVBQUUsQ0FDUDtVQUFFeUYsS0FBSyxFQUFFaUgsTUFBTSxDQUFDZSxHQUFoQjtVQUFxQnhOLEtBQUssRUFBRTtRQUE1QixDQURPLEVBRVA7VUFBRXdGLEtBQUssRUFBRWlILE1BQU0sQ0FBQ1csTUFBaEI7VUFBd0JwTixLQUFLLEVBQUU7UUFBL0IsQ0FGTyxFQUdQO1VBQUV3RixLQUFLLEVBQUVpSCxNQUFNLENBQUNnQixNQUFoQjtVQUF3QnpOLEtBQUssRUFBRTtRQUEvQixDQUhPO01BREQsQ0FKRjtNQVdSK0wsWUFBWSxFQUFFVSxNQUFNLENBQUNXO0lBWGIsQ0E5QlosRUEyQ0dNLGNBM0NILENBMkNrQjtNQUNkeEYsUUFEYztNQUVkRSxJQUFJLEVBQUUsYUFGUTtNQUdkeEQsSUFBSSxFQUFFLFdBSFE7TUFJZGlILFFBQVEsRUFBRTtRQUNSekksV0FBVyxFQUFFO01BREw7SUFKSSxDQTNDbEI7RUFtREQ7QUEvRnVFLENBQW5FOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRVA7QUFDQTtBQUdBO0FBRUE7Ozs7QUFZQSxNQUFNdUssa0JBQThFLEdBQUkxRyxLQUFELElBQVc7RUFDaEcsTUFBTXpGLE1BQU0sR0FBRzhHLHVEQUFVLENBQUN6RCxTQUFELENBQXpCO0VBRUEsTUFBTTtJQUFFbUM7RUFBRixJQUFXQyxLQUFqQjtFQUVBLE1BQU0yRyxvQkFBb0IsR0FBSSxRQUFPNUcsSUFBSSxTQUFKLElBQUFBLElBQUksV0FBSixJQUFBQSxJQUFJLENBQUU2RyxHQUFOLEdBQVksS0FBS3RFLElBQUksQ0FBQ0MsR0FBTCxDQUFTeEMsSUFBSSxDQUFDNkcsR0FBZCxDQUFqQixHQUFzQyxDQUFFLG1CQUE3RTtFQUVBLG9CQUNFO0lBQUssT0FBTyxFQUFDLHFCQUFiO0lBQW1DLG1CQUFtQixFQUFDLGVBQXZEO0lBQUEsOENBQ0U7TUFBUSxFQUFFLEVBQUMsT0FBWDtNQUFBLHdCQUNFO1FBQ0UsSUFBSSxFQUFDLFNBRFA7UUFFRSxFQUFFLEVBQUMsYUFGTDtRQUdFLENBQUMsRUFBQztNQUhKLEVBREYsZUFNRTtRQUNFLElBQUksRUFBQyxTQURQO1FBRUUsRUFBRSxFQUFDLFlBRkw7UUFHRSxDQUFDLEVBQUM7TUFISixFQU5GO0lBQUEsRUFERixnQkFjRTtNQUFBLG9DQUNFO1FBQUcsRUFBRSxFQUFDLFdBQU47UUFBa0IsU0FBUyxFQUFDLDJCQUE1QjtRQUF3RCxRQUFRLEVBQUMsU0FBakU7UUFBQSx3QkFDRTtVQUFTLEVBQUUsRUFBQyxPQUFaO1VBQW9CLElBQUksRUFBQyxTQUF6QjtVQUFtQyxNQUFNLEVBQUM7UUFBMUMsRUFERixlQUVFO1VBQ0UsRUFBRSxFQUFDLEtBREw7VUFFRSxJQUFJLEVBQUMsa0JBRlA7VUFHRSxDQUFDLEVBQUM7UUFISixFQUZGLGVBT0U7VUFDRSxFQUFFLEVBQUMsTUFETDtVQUVFLElBQUksRUFBQyxTQUZQO1VBR0UsU0FBUyxFQUFDLGlCQUhaO1VBSUUsQ0FBQyxFQUFDO1FBSkosRUFQRixlQWFFO1VBQVEsRUFBRSxFQUFDLFNBQVg7VUFBcUIsSUFBSSxFQUFDLFNBQTFCO1VBQW9DLEVBQUUsRUFBQyxPQUF2QztVQUErQyxFQUFFLEVBQUMsSUFBbEQ7VUFBdUQsQ0FBQyxFQUFDO1FBQXpELEVBYkYsZUFjRTtVQUFRLEVBQUUsRUFBQyxTQUFYO1VBQXFCLElBQUksRUFBQyxNQUExQjtVQUFpQyxNQUFNLEVBQUMsU0FBeEM7VUFBa0QsV0FBVyxFQUFDLE1BQTlEO1VBQXFFLEVBQUUsRUFBQyxRQUF4RTtVQUFpRixFQUFFLEVBQUMsUUFBcEY7VUFBNkYsQ0FBQyxFQUFDO1FBQS9GLEVBZEY7TUFBQSxFQURGLGdCQWlCRTtRQUFHLFNBQVMsRUFBRXJNLE1BQU0sQ0FBQ3NNLEtBQXJCO1FBQTRCLEtBQUssRUFBRTtVQUFFM0QsU0FBUyxFQUFFeUQ7UUFBYixDQUFuQztRQUFBLHdDQUNFO1VBQUssRUFBRSxFQUFDLFFBQVI7VUFBaUIsSUFBSSxFQUFDLFFBQXRCO1VBQStCLENBQUMsRUFBQyxPQUFqQztVQUF5QyxDQUFDLEVBQUM7UUFBM0MsRUFERixrQ0FFRTtVQUFLLEVBQUUsRUFBQyxRQUFSO1VBQWlCLElBQUksRUFBQyxRQUF0QjtVQUErQixDQUFDLEVBQUMsT0FBakM7VUFBeUMsQ0FBQyxFQUFDLEdBQTNDO1VBQStDLFNBQVMsRUFBQztRQUF6RCxFQUZGLGtDQUdFO1VBQUssRUFBRSxFQUFDLFFBQVI7VUFBaUIsSUFBSSxFQUFDLFFBQXRCO1VBQStCLENBQUMsRUFBQyxPQUFqQztVQUF5QyxDQUFDLEVBQUMsR0FBM0M7VUFBK0MsU0FBUyxFQUFDO1FBQXpELEVBSEY7TUFBQSxFQWpCRjtJQUFBLEVBZEY7RUFBQSxFQURGO0FBd0NELENBL0NEOztBQWlETyxNQUFNRyxlQUE0QyxHQUFHO0VBQzFEMUcsRUFBRSxFQUFFLGFBRHNEO0VBRTFEekMsSUFBSSxFQUFFLGNBRm9EO0VBRzFEMEMsV0FBVyxFQUFFLGVBSDZDO0VBSzFEQyxPQUFPLEVBQUVvRyxrQkFMaUQ7RUFPMURuRyxXQUFXLEVBQUU7SUFDWEMsS0FBSyxFQUFFLEdBREk7SUFFWEMsTUFBTSxFQUFFO0VBRkcsQ0FQNkM7RUFZMURDLGFBQWEsRUFBRzVILE9BQUQsc0JBQ1ZBLE9BRFUsQ0FaMkM7RUFnQjFEO0VBQ0E2SCxXQUFXLEVBQUUsQ0FBQ0MsR0FBRCxFQUF3QkMsR0FBeEIsS0FBbUQ7SUFDOUQsTUFBTWQsSUFBcUIsR0FBRztNQUM1QjZHLEdBQUcsRUFBRS9GLEdBQUcsU0FBSCxJQUFBQSxHQUFHLFdBQUgsSUFBQUEsR0FBRyxDQUFFK0YsR0FBTCxHQUFXaEcsR0FBRyxDQUFDaUIsU0FBSixDQUFjaEIsR0FBRyxDQUFDK0YsR0FBbEIsRUFBdUJySSxLQUF2QixFQUFYLEdBQTRDO0lBRHJCLENBQTlCO0lBSUEsT0FBT3dCLElBQVA7RUFDRCxDQXZCeUQ7RUF5QjFEZ0IsaUJBQWlCLEVBQUdDLE9BQUQsSUFBYTtJQUM5QixNQUFNQyxRQUFRLEdBQUcsQ0FBQyxjQUFELENBQWpCO0lBQ0FELE9BQU8sQ0FBQ0UsZUFBUixDQUF3QjtNQUN0QkQsUUFEc0I7TUFFdEJiLEVBQUUsRUFBRSxLQUZrQjtNQUd0QmUsSUFBSSxFQUFFLFlBSGdCO01BSXRCeEQsSUFBSSxFQUFFLEtBSmdCO01BS3RCeUQsTUFBTSxFQUFFRSxrRkFBcUJBO0lBTFAsQ0FBeEI7RUFPRDtBQWxDeUQsQ0FBckQ7O0FBcUNQLE1BQU0xRCxTQUFTLEdBQUlwRCxLQUFELEtBQTJCO0VBQzNDcU0sS0FBSyxFQUFFN04sNkNBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiNkMsQ0FBM0IsQ0FBbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FFeEdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVPLE1BQU1pTyw2QkFBbUQscUJBQzNEL0Msa0VBQUEsRUFEMkQ7RUFFOURnRCxJQUFJLEVBQUVoRCx1REFGd0Q7RUFHOUR2RyxJQUFJLEVBQUc7QUFIdUQsRUFBekQ7QUFNQSxNQUFNd0oscUJBQXFCLEdBQUcsSUFBSUgsbURBQUosQ0FBZ0MsTUFBTSxDQUN6RTlDLG9EQUR5RSxFQUMvRDtBQUNWOEIsMERBRnlFLEVBR3pFN0Ysd0RBSHlFLEVBSXpFaUQsNERBSnlFLEVBS3pFeEIsZ0VBTHlFLEVBTXpFTSw4REFOeUUsRUFPekU0RSxrRUFQeUUsQ0FBdEMsQ0FBOUI7Ozs7Ozs7Ozs7Ozs7O0FDZlA7O0FBSU8sTUFBTVEsaUJBQWlCLEdBQUc7RUFDL0IzSixJQUFJLEVBQUUsbUJBRHlCO0VBRS9CcUMsS0FBSyxFQUFFLEVBRndCO0VBRy9CdUgsTUFBTSxFQUFFLEVBSHVCOztFQUkvQnpILE1BQU0sQ0FBQzBILFFBQUQsRUFBK0M5TyxLQUEvQyxFQUFnRTtJQUNwRSxNQUFNK08sSUFBSSxHQUFHRCxRQUFRLENBQUNFLE9BQVQsRUFBYjtJQUNBLG9CQUNFO01BRUUsU0FBUyxFQUFFLG9CQUZiO01BR0UsS0FBSyxFQUFFO1FBQ0xDLFFBQVEsRUFBRSxVQURMO1FBRUx0RCxJQUFJLEVBQUcsR0FBRW9ELElBQUksQ0FBQ2pILEtBQUwsR0FBYSxDQUFFLElBRm5CO1FBR0w0RCxHQUFHLEVBQUcsR0FBRXFELElBQUksQ0FBQ2hILE1BQUwsR0FBYyxFQUFHLElBSHBCO1FBSUx3RixVQUFVLEVBQUUsTUFKUDtRQUtMMkIsWUFBWSxFQUFFLEtBTFQ7UUFNTEMsT0FBTyxFQUFFLFNBTko7UUFPTGxELEtBQUssRUFBRSxPQVBGO1FBUUxtRCxRQUFRLEVBQUUsTUFSTDtRQVNMQyxVQUFVLEVBQUUsUUFUUDtRQVVMQyxVQUFVLEVBQUUsTUFWUDtRQVdMQyxVQUFVLEVBQUUsV0FYUDtRQVlMdEcsU0FBUyxFQUFFLHNCQVpOO1FBYUx1RyxNQUFNLEVBQUU7TUFiSCxDQUhUO01BQUEsV0FtQkc1RixJQUFJLENBQUM2RixLQUFMLENBQVdWLElBQUksQ0FBQ1csV0FBaEIsQ0FuQkgsU0FtQm9DOUYsSUFBSSxDQUFDNkYsS0FBTCxDQUFXVixJQUFJLENBQUNZLFlBQWhCLENBbkJwQztJQUFBLEdBQ08sb0JBRFAsQ0FERjtFQXVCRDs7QUE3QjhCLENBQTFCO0FBZ0NBLE1BQU1DLGtCQUFrQixHQUFJQyxLQUFELEtBQW1CO0VBQ25ENUssSUFBSSxFQUFFLG9CQUQ2QztFQUVuRHFDLEtBQUssRUFBRSxFQUY0QztFQUduRHVILE1BQU0sRUFBRSxFQUgyQzs7RUFJbkR6SCxNQUFNLENBQUMwSCxRQUFELEVBQStDOU8sS0FBL0MsRUFBZ0U7SUFBQTs7SUFDcEUsTUFBTStPLElBQUksR0FBR0QsUUFBUSxDQUFDRSxPQUFULEVBQWI7SUFDQSxNQUFNYyxhQUFhLEdBQUdELEtBQUssQ0FBQ0UsbUJBQU4sQ0FBMEJqQixRQUFRLENBQUNrQixLQUFULENBQWU5SixNQUF6QyxDQUF0QixDQUZvRSxDQUlwRTs7SUFDQSxJQUNFNEosYUFBYSxTQUFiLElBQUFBLGFBQWEsV0FBYixJQUFBQSxhQUFhLENBQUVHLFFBQWYsSUFDQyxrQkFBQUosS0FBSyxDQUFDSyxPQUFOLDBEQUFlQyxrQkFBZixNQUF1QyxvQkFBQU4sS0FBSyxDQUFDSyxPQUFOLG9FQUFlQyxrQkFBZixHQUFvQ3hOLE1BQXBDLElBQTZDLENBRnZGLEVBR0U7TUFDQTtJQUNEOztJQUVELElBQUl5TiwrQkFBK0IsR0FBRyxJQUF0QztJQUNBLElBQUlDLGlDQUFpQyxHQUFHLElBQXhDO0lBRUEsTUFBTUMsVUFBVSxvQ0FBR1IsYUFBSCxhQUFHQSxhQUFILHVCQUFHQSxhQUFhLENBQUVTLGNBQWxCLHlFQUFvQ1QsYUFBcEMsYUFBb0NBLGFBQXBDLHVCQUFvQ0EsYUFBYSxDQUFFMVAsT0FBZixDQUF1QmtRLFVBQTNELHVDQUF5RSxFQUF6RjtJQUVBLE1BQU1FLFdBQVcsR0FBRyxpQkFBcEI7SUFFQSxNQUFNQyxzQkFBc0IsR0FBR3pRLEtBQUssQ0FBQzBRLGFBQU4sQ0FBb0IsS0FBcEIsRUFBMkI7TUFDeEQ5TyxLQUFLLEVBQUU7UUFDTHFOLFFBQVEsRUFBRSxVQURMO1FBRUx0RCxJQUFJLEVBQUcsR0FBRW9ELElBQUksQ0FBQ2pILEtBQUwsR0FBYSxDQUFFLElBRm5CO1FBR0w0RCxHQUFHLEVBQUcsR0FBRXFELElBQUksQ0FBQ2hILE1BQUwsR0FBYyxDQUFkLEdBQWtCZ0gsSUFBSSxDQUFDaEgsTUFBTCxHQUFjLEVBQUcsSUFIdEM7UUFJTDRJLFVBQVUsRUFBRUgsV0FKUDtRQUtMekksTUFBTSxFQUFHLEdBQUVnSCxJQUFJLENBQUNoSCxNQUFMLEdBQWMsQ0FBRSxJQUx0QjtRQU1Ma0IsU0FBUyxFQUFFO01BTk47SUFEaUQsQ0FBM0IsQ0FBL0I7SUFXQSxNQUFNMkgsc0JBQXNCLEdBQUc1USxLQUFLLENBQUMwUSxhQUFOLENBQW9CLEtBQXBCLEVBQTJCO01BQ3hEOU8sS0FBSyxFQUFFO1FBQ0xxTixRQUFRLEVBQUUsVUFETDtRQUVMdEQsSUFBSSxFQUFHLEdBQUVvRCxJQUFJLENBQUNqSCxLQUFMLEdBQWEsQ0FBRSxJQUZuQjtRQUdMNEQsR0FBRyxFQUFHLEdBQUVxRCxJQUFJLENBQUNoSCxNQUFMLEdBQWMsQ0FBZCxHQUFrQmdILElBQUksQ0FBQ2hILE1BQUwsR0FBYyxFQUFHLElBSHRDO1FBSUw0SSxVQUFVLEVBQUVILFdBSlA7UUFLTHpJLE1BQU0sRUFBRyxHQUFFZ0gsSUFBSSxDQUFDaEgsTUFBTCxHQUFjLENBQUUsSUFMdEI7UUFNTGtCLFNBQVMsRUFBRTtNQU5OO0lBRGlELENBQTNCLENBQS9CO0lBV0EsTUFBTTRILGVBQWUsR0FBRzdRLEtBQUssQ0FBQzBRLGFBQU4sQ0FBb0IsS0FBcEIsRUFBMkIsRUFBM0IsRUFBK0IsQ0FBQ0Qsc0JBQUQsRUFBeUJHLHNCQUF6QixDQUEvQixDQUF4QjtJQUVBLE1BQU1FLHFCQUFxQixHQUFHOVEsS0FBSyxDQUFDMFEsYUFBTixDQUFvQixLQUFwQixFQUEyQjtNQUN2RDlPLEtBQUssRUFBRTtRQUNMcU4sUUFBUSxFQUFFLFVBREw7UUFFTHRELElBQUksRUFBRyxHQUFFb0QsSUFBSSxDQUFDakgsS0FBTCxHQUFhLENBQUUsSUFGbkI7UUFHTGlKLE1BQU0sRUFBRSxLQUhIO1FBSUxKLFVBQVUsRUFBRUgsV0FKUDtRQUtMekksTUFBTSxFQUFFO01BTEg7SUFEZ0QsQ0FBM0IsQ0FBOUI7SUFVQSxNQUFNaUosd0JBQXdCLEdBQUdoUixLQUFLLENBQUMwUSxhQUFOLENBQW9CLEtBQXBCLEVBQTJCO01BQzFEOU8sS0FBSyxFQUFFO1FBQ0xxTixRQUFRLEVBQUUsVUFETDtRQUVMdEQsSUFBSSxFQUFHLEdBQUVvRCxJQUFJLENBQUNqSCxLQUFMLEdBQWEsQ0FBRSxJQUZuQjtRQUdMNEQsR0FBRyxFQUFHLEdBQUVxRCxJQUFJLENBQUNoSCxNQUFPLElBSGY7UUFJTDRJLFVBQVUsRUFBRUgsV0FKUDtRQUtMekksTUFBTSxFQUFFO01BTEg7SUFEbUQsQ0FBM0IsQ0FBakM7SUFVQSxNQUFNa0osMkJBQTJCLEdBQUdqUixLQUFLLENBQUMwUSxhQUFOLENBQW9CLEtBQXBCLEVBQTJCLEVBQTNCLEVBQStCLENBQ2pFSSxxQkFEaUUsRUFFakVFLHdCQUZpRSxDQUEvQixDQUFwQztJQUtBLE1BQU1FLDRCQUE0QixHQUFHbFIsS0FBSyxDQUFDMFEsYUFBTixDQUFvQixLQUFwQixFQUEyQjtNQUM5RDlPLEtBQUssRUFBRTtRQUNMcU4sUUFBUSxFQUFFLFVBREw7UUFFTHRELElBQUksRUFBRyxHQUFFb0QsSUFBSSxDQUFDakgsS0FBTCxHQUFhLENBQUUsSUFGbkI7UUFHTDRELEdBQUcsRUFBRyxHQUFFcUQsSUFBSSxDQUFDaEgsTUFBTCxHQUFjLENBQUUsSUFIbkI7UUFJTDRJLFVBQVUsRUFBRUgsV0FKUDtRQUtMekksTUFBTSxFQUFHLEdBQUVnSCxJQUFJLENBQUNoSCxNQUFMLEdBQWMsQ0FBRTtNQUx0QjtJQUR1RCxDQUEzQixDQUFyQztJQVVBLE1BQU1vSix3QkFBd0IsR0FBR25SLEtBQUssQ0FBQzBRLGFBQU4sQ0FBb0IsS0FBcEIsRUFBMkIsRUFBM0IsRUFBK0IsQ0FBQ1EsNEJBQUQsRUFBK0JMLGVBQS9CLENBQS9CLENBQWpDOztJQUVBLFFBQVFQLFVBQVUsQ0FBQ2MsUUFBbkI7TUFDRSxLQUFLekMsMERBQUw7UUFDRXlCLCtCQUErQixHQUFHVSxxQkFBbEM7UUFDQTs7TUFDRixLQUFLbkMsNkRBQUw7UUFDRXlCLCtCQUErQixHQUFHWSx3QkFBbEM7UUFDQTs7TUFDRixLQUFLckMsZ0VBQUw7UUFDRXlCLCtCQUErQixHQUFHYSwyQkFBbEM7UUFDQTs7TUFDRixLQUFLdEMsNkRBQUw7UUFDRXlCLCtCQUErQixHQUFHZSx3QkFBbEM7UUFDQTtJQVpKOztJQWVBLE1BQU1HLHdCQUF3QixHQUFHdFIsS0FBSyxDQUFDMFEsYUFBTixDQUFvQixLQUFwQixFQUEyQjtNQUMxRDlPLEtBQUssRUFBRTtRQUNMcU4sUUFBUSxFQUFFLFVBREw7UUFFTHNDLEtBQUssRUFBRSxLQUZGO1FBR0w3RixHQUFHLEVBQUcsR0FBRXFELElBQUksQ0FBQ2hILE1BQUwsR0FBYyxDQUFFLElBSG5CO1FBSUx5SixTQUFTLEVBQUVoQixXQUpOO1FBS0wxSSxLQUFLLEVBQUU7TUFMRjtJQURtRCxDQUEzQixDQUFqQztJQVVBLE1BQU0ySix5QkFBeUIsR0FBR3pSLEtBQUssQ0FBQzBRLGFBQU4sQ0FBb0IsS0FBcEIsRUFBMkI7TUFDM0Q5TyxLQUFLLEVBQUU7UUFDTHFOLFFBQVEsRUFBRSxVQURMO1FBRUx0RCxJQUFJLEVBQUcsR0FBRW9ELElBQUksQ0FBQ2pILEtBQU0sSUFGZjtRQUdMNEQsR0FBRyxFQUFHLEdBQUVxRCxJQUFJLENBQUNoSCxNQUFMLEdBQWMsQ0FBRSxJQUhuQjtRQUlMeUosU0FBUyxFQUFFaEIsV0FKTjtRQUtMMUksS0FBSyxFQUFFO01BTEY7SUFEb0QsQ0FBM0IsQ0FBbEM7SUFVQSxNQUFNNEosNkJBQTZCLEdBQUcxUixLQUFLLENBQUMwUSxhQUFOLENBQW9CLEtBQXBCLEVBQTJCLEVBQTNCLEVBQStCLENBQ25FWSx3QkFEbUUsRUFFbkVHLHlCQUZtRSxDQUEvQixDQUF0QztJQUtBLE1BQU1FLDhCQUE4QixHQUFHM1IsS0FBSyxDQUFDMFEsYUFBTixDQUFvQixLQUFwQixFQUEyQjtNQUNoRTlPLEtBQUssRUFBRTtRQUNMcU4sUUFBUSxFQUFFLFVBREw7UUFFTHRELElBQUksRUFBRyxHQUFFb0QsSUFBSSxDQUFDakgsS0FBTCxHQUFhLENBQUUsSUFGbkI7UUFHTDRELEdBQUcsRUFBRyxHQUFFcUQsSUFBSSxDQUFDaEgsTUFBTCxHQUFjLENBQUUsSUFIbkI7UUFJTHlKLFNBQVMsRUFBRWhCLFdBSk47UUFLTDFJLEtBQUssRUFBRyxHQUFFaUgsSUFBSSxDQUFDakgsS0FBTCxHQUFhLENBQUU7TUFMcEI7SUFEeUQsQ0FBM0IsQ0FBdkM7SUFVQSxNQUFNOEosMEJBQTBCLEdBQUc1UixLQUFLLENBQUMwUSxhQUFOLENBQW9CLEtBQXBCLEVBQTJCLEVBQTNCLEVBQStCLENBQ2hFaUIsOEJBRGdFLEVBRWhFZCxlQUZnRSxDQUEvQixDQUFuQzs7SUFLQSxRQUFRUCxVQUFVLENBQUN1QixVQUFuQjtNQUNFLEtBQUtuRCw2REFBTDtRQUNFMkIsaUNBQWlDLEdBQUdpQix3QkFBcEM7UUFDQTs7TUFDRixLQUFLNUMsOERBQUw7UUFDRTJCLGlDQUFpQyxHQUFHb0IseUJBQXBDO1FBQ0E7O01BQ0YsS0FBSy9DLGtFQUFMO1FBQ0UyQixpQ0FBaUMsR0FBR3FCLDZCQUFwQztRQUNBOztNQUNGLEtBQUtoRCwrREFBTDtRQUNFMkIsaUNBQWlDLEdBQUd1QiwwQkFBcEM7UUFDQTtJQVpKOztJQWVBLE1BQU1HLHVCQUF1QixHQUFHL1IsS0FBSyxDQUFDMFEsYUFBTixDQUFvQixLQUFwQixFQUEyQixFQUEzQixFQUErQixDQUM3RE4sK0JBRDZELEVBRTdEQyxpQ0FGNkQsQ0FBL0IsQ0FBaEM7SUFLQSxPQUFPMEIsdUJBQVA7RUFDRDs7QUFoS2tELENBQW5CLENBQTNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q1A7QUFJQTtBQU1BO0FBR0E7O0FBTUEsSUFBSUUsT0FBTyxHQUFHLENBQWQ7QUFFTyxNQUFNQyxZQUFOLENBQTJDO0VBQ2hEO0VBTUE7RUFHQTtFQUdBO0VBR0E7RUFDWTtFQUVaQyxXQUFXLENBQVFDLElBQVIsRUFBd0NoUyxPQUF4QyxFQUE4RWlTLE1BQTlFLEVBQW1HO0lBQUE7O0lBQUEsNkJBakIvRkosT0FBTyxFQWlCd0Y7O0lBQUEsK0JBaEJ0RyxDQWdCc0c7O0lBQUEsbUNBZm5GLEVBZW1GOztJQUFBLG1DQWRuRixFQWNtRjs7SUFBQSxrQ0FYbkcsS0FXbUc7O0lBQUE7O0lBQUE7O0lBQUE7O0lBQUEscUNBOFUvRi9MLE1BQUQsSUFBNEI7TUFDeEMsS0FBS29NLEdBQUwsR0FBV3BNLE1BQVg7TUFDQSxLQUFLcU0sc0JBQUw7SUFDRCxDQWpWNkc7O0lBQUEsbUNBbVZqRy9NLEtBQUQsSUFBbUI7TUFBQTs7TUFDN0IsTUFBTWdOLDZCQUE2QixHQUFHLCtCQUFLcFMsT0FBTCxDQUFha1EsVUFBYixnRkFBeUJ1QixVQUF6QixNQUF3Q25ELCtEQUE5RTtNQUNBLE1BQU0rRCwyQkFBMkIsR0FBRyxnQ0FBS3JTLE9BQUwsQ0FBYWtRLFVBQWIsa0ZBQXlCYyxRQUF6QixNQUFzQ3pDLDZEQUExRTs7TUFDQSxJQUFJNkQsNkJBQTZCLElBQUlDLDJCQUFyQyxFQUFrRTtRQUFBOztRQUNoRSxNQUFNQyxlQUFlLDhDQUFHLEtBQUtDLFFBQUwsRUFBSCw2RUFBRyxlQUFpQnpDLE9BQXBCLDJEQUFHLHVCQUEwQkMsa0JBQTFCLEdBQStDeE4sTUFBbEQseUVBQTRELENBQWpGO1FBQ0EsTUFBTWlRLGdCQUFnQixHQUFHRixlQUFlLEdBQUcsQ0FBM0M7O1FBQ0EsSUFBSSxDQUFDRSxnQkFBTCxFQUF1QjtVQUFBOztVQUNyQixNQUFNQyxnQkFBZ0IsZ0JBQUcsS0FBS1AsR0FBUiw4Q0FBRyxVQUFVUSxxQkFBVixFQUF6QjtVQUNBLE1BQU0vSyxNQUFNLDRCQUFHOEssZ0JBQUgsYUFBR0EsZ0JBQUgsdUJBQUdBLGdCQUFnQixDQUFFOUssTUFBckIseUVBQStCLEdBQTNDO1VBQ0EsTUFBTWdMLE9BQU8sR0FBR04sMkJBQTJCLEdBQUcxSyxNQUFNLEdBQUcsQ0FBWixHQUFnQixDQUEzRDtVQUNBdkMsS0FBSyxDQUFDVSxNQUFOLENBQWF0RSxLQUFiLENBQW1CcUgsU0FBbkIsR0FBZ0MsYUFBWXpELEtBQUssQ0FBQ3dOLFNBQU4sQ0FBZ0IsQ0FBaEIsQ0FBbUIsT0FBTXhOLEtBQUssQ0FBQ3dOLFNBQU4sQ0FBZ0IsQ0FBaEIsSUFBcUJELE9BQVEsS0FBbEc7VUFDQTtRQUNEO01BQ0Y7O01BRUR2TixLQUFLLENBQUNVLE1BQU4sQ0FBYXRFLEtBQWIsQ0FBbUJxSCxTQUFuQixHQUErQnpELEtBQUssQ0FBQ3lELFNBQXJDO0lBQ0QsQ0FuVzZHOztJQUFBLHFDQXVXL0Z6RCxLQUFELElBQXFCO01BQ2pDLE1BQU1pRyxTQUFTLEdBQUcsS0FBS3JMLE9BQUwsQ0FBYXFMLFNBQS9CO01BRUEsTUFBTTdKLEtBQUssR0FBRzRELEtBQUssQ0FBQ1UsTUFBTixDQUFhdEUsS0FBM0I7TUFDQSxNQUFNcVIsTUFBTSxHQUFHek4sS0FBSyxDQUFDME4sS0FBTixDQUFZLENBQVosQ0FBZjtNQUNBLE1BQU1DLE1BQU0sR0FBRzNOLEtBQUssQ0FBQzBOLEtBQU4sQ0FBWSxDQUFaLENBQWY7TUFDQSxNQUFNRSxLQUFLLEdBQUc1TixLQUFLLENBQUM2TixTQUFOLENBQWdCLENBQWhCLENBQWQ7TUFDQSxNQUFNQyxLQUFLLEdBQUc5TixLQUFLLENBQUM2TixTQUFOLENBQWdCLENBQWhCLENBQWQ7O01BRUEsSUFBSUQsS0FBSyxLQUFLLENBQWQsRUFBaUI7UUFDZjNILFNBQVMsQ0FBQzNELEtBQVYsR0FBa0J0QyxLQUFLLENBQUNzQyxLQUF4QjtRQUNBbEcsS0FBSyxDQUFDa0csS0FBTixHQUFlLEdBQUUyRCxTQUFTLENBQUMzRCxLQUFNLElBQWpDO01BQ0QsQ0FIRCxNQUdPLElBQUlzTCxLQUFLLEtBQUssQ0FBQyxDQUFmLEVBQWtCO1FBQ3ZCM0gsU0FBUyxDQUFDRSxJQUFWLElBQW1Cc0gsTUFBbkI7UUFDQXhILFNBQVMsQ0FBQzNELEtBQVYsR0FBa0J0QyxLQUFLLENBQUNzQyxLQUF4QjtRQUNBbEcsS0FBSyxDQUFDK0osSUFBTixHQUFjLEdBQUVGLFNBQVMsQ0FBQ0UsSUFBSyxJQUEvQjtRQUNBL0osS0FBSyxDQUFDa0csS0FBTixHQUFlLEdBQUUyRCxTQUFTLENBQUMzRCxLQUFNLElBQWpDO01BQ0Q7O01BRUQsSUFBSXdMLEtBQUssS0FBSyxDQUFDLENBQWYsRUFBa0I7UUFDaEI3SCxTQUFTLENBQUNDLEdBQVYsSUFBa0J5SCxNQUFsQjtRQUNBMUgsU0FBUyxDQUFDMUQsTUFBVixHQUFtQnZDLEtBQUssQ0FBQ3VDLE1BQXpCO1FBQ0FuRyxLQUFLLENBQUM4SixHQUFOLEdBQWEsR0FBRUQsU0FBUyxDQUFDQyxHQUFJLElBQTdCO1FBQ0E5SixLQUFLLENBQUNtRyxNQUFOLEdBQWdCLEdBQUUwRCxTQUFTLENBQUMxRCxNQUFPLElBQW5DO01BQ0QsQ0FMRCxNQUtPLElBQUl1TCxLQUFLLEtBQUssQ0FBZCxFQUFpQjtRQUN0QjdILFNBQVMsQ0FBQzFELE1BQVYsR0FBbUJ2QyxLQUFLLENBQUN1QyxNQUF6QjtRQUNBbkcsS0FBSyxDQUFDbUcsTUFBTixHQUFnQixHQUFFMEQsU0FBUyxDQUFDMUQsTUFBTyxJQUFuQztNQUNEO0lBQ0YsQ0FuWTZHOztJQUFBLEtBQTNGcUssSUFBMkYsR0FBM0ZBLElBQTJGO0lBQUEsS0FBM0RoUyxPQUEyRCxHQUEzREEsT0FBMkQ7SUFBQSxLQUFyQmlTLE1BQXFCLEdBQXJCQSxNQUFxQjtJQUM1RyxNQUFNa0IsWUFBWSxHQUFJLFdBQVVDLElBQUksQ0FBQ0MsR0FBTCxFQUFXLEVBQTNDOztJQUNBLElBQUksQ0FBQ3JULE9BQUwsRUFBYztNQUNaLEtBQUtBLE9BQUwsR0FBZTtRQUFFb08sSUFBSSxFQUFFNEQsSUFBSSxDQUFDMUssRUFBYjtRQUFpQnpDLElBQUksRUFBRXNPO01BQXZCLENBQWY7SUFDRDs7SUFFRG5ULE9BQU8sQ0FBQ2tRLFVBQVIsMEJBQXFCbFEsT0FBTyxDQUFDa1EsVUFBN0IscUVBQTJDO01BQ3pDYyxRQUFRLEVBQUV6QywwREFEK0I7TUFFekNrRCxVQUFVLEVBQUVuRCw2REFBeUJsQjtJQUZJLENBQTNDO0lBSUFwTixPQUFPLENBQUNxTCxTQUFSLHlCQUFvQnJMLE9BQU8sQ0FBQ3FMLFNBQTVCLG1FQUF5QztNQUFFM0QsS0FBSyxFQUFFLEdBQVQ7TUFBY0MsTUFBTSxFQUFFLEdBQXRCO01BQTJCMkQsR0FBRyxFQUFFLENBQWhDO01BQW1DQyxJQUFJLEVBQUU7SUFBekMsQ0FBekM7SUFDQSxNQUFNa0UsS0FBSyxHQUFHLEtBQUs4QyxRQUFMLEVBQWQ7O0lBQ0EsSUFBSSxDQUFDdlMsT0FBTyxDQUFDNkUsSUFBYixFQUFtQjtNQUNqQixNQUFNUyxPQUFPLEdBQUdtSyxLQUFILGFBQUdBLEtBQUgsdUJBQUdBLEtBQUssQ0FBRTZELGtCQUFQLEVBQWhCO01BQ0F0VCxPQUFPLENBQUM2RSxJQUFSLEdBQWVTLE9BQWYsYUFBZUEsT0FBZixjQUFlQSxPQUFmLEdBQTBCNk4sWUFBMUI7SUFDRDs7SUFDRDFELEtBQUssU0FBTCxJQUFBQSxLQUFLLFdBQUwsWUFBQUEsS0FBSyxDQUFFOEQsTUFBUCxDQUFjQyxHQUFkLENBQWtCeFQsT0FBTyxDQUFDNkUsSUFBMUIsRUFBZ0MsSUFBaEM7RUFDRDs7RUFFTzBOLFFBQVEsR0FBc0I7SUFDcEMsSUFBSWtCLElBQUksR0FBRyxLQUFLeEIsTUFBaEI7O0lBQ0EsT0FBT3dCLElBQVAsRUFBYTtNQUNYLElBQUlBLElBQUksQ0FBQ0MsTUFBTCxFQUFKLEVBQW1CO1FBQ2pCLE9BQU9ELElBQUksQ0FBQ2hFLEtBQVo7TUFDRDs7TUFDRGdFLElBQUksR0FBR0EsSUFBSSxDQUFDeEIsTUFBWjtJQUNEOztJQUVELE9BQU9oUCxTQUFQO0VBQ0Q7O0VBRURQLE9BQU8sR0FBRztJQUNSLE9BQU8sS0FBSzFDLE9BQUwsQ0FBYTZFLElBQXBCO0VBQ0Q7RUFFRDs7O0VBQ0FzTixzQkFBc0IsR0FBRztJQUFBOztJQUN2QixJQUFJLEtBQUt1QixNQUFMLEVBQUosRUFBbUI7TUFDakI7TUFDQTtJQUNEOztJQUVELE1BQU07TUFBRXhEO0lBQUYsSUFBaUIsS0FBS2xRLE9BQTVCO0lBQ0EsTUFBTTtNQUFFZ1IsUUFBRjtNQUFZUztJQUFaLElBQTJCdkIsVUFBM0IsYUFBMkJBLFVBQTNCLGNBQTJCQSxVQUEzQixHQUF5QyxFQUEvQztJQUNBLE1BQU03RSxTQUFTLDRCQUFHLEtBQUtyTCxPQUFMLENBQWFxTCxTQUFoQix5RUFBOEIsRUFBN0M7SUFFQSxNQUFNN0osS0FBMEIsR0FBRztNQUNqQ3FOLFFBQVEsRUFBRSxVQUR1QjtNQUVqQztNQUNBOEUsUUFBUSxFQUFFLE1BSHVCO01BSWpDQyxTQUFTLEVBQUU7SUFKc0IsQ0FBbkM7SUFPQSxNQUFNaEIsU0FBUyxHQUFHLENBQUMsS0FBRCxFQUFRLEtBQVIsQ0FBbEI7O0lBRUEsUUFBUTVCLFFBQVI7TUFDRSxLQUFLekMsMERBQUw7UUFDRWxELFNBQVMsQ0FBQ0MsR0FBVixxQkFBZ0JELFNBQVMsQ0FBQ0MsR0FBMUIsMkRBQWlDLENBQWpDO1FBQ0FELFNBQVMsQ0FBQzFELE1BQVYsd0JBQW1CMEQsU0FBUyxDQUFDMUQsTUFBN0IsaUVBQXVDLEdBQXZDO1FBQ0FuRyxLQUFLLENBQUM4SixHQUFOLEdBQWEsR0FBRUQsU0FBUyxDQUFDQyxHQUFJLElBQTdCO1FBQ0E5SixLQUFLLENBQUNtRyxNQUFOLEdBQWdCLEdBQUUwRCxTQUFTLENBQUMxRCxNQUFPLElBQW5DO1FBQ0EsT0FBTzBELFNBQVMsQ0FBQ3NGLE1BQWpCO1FBQ0E7O01BQ0YsS0FBS3BDLDZEQUFMO1FBQ0VsRCxTQUFTLENBQUNzRixNQUFWLHdCQUFtQnRGLFNBQVMsQ0FBQ3NGLE1BQTdCLGlFQUF1QyxDQUF2QztRQUNBdEYsU0FBUyxDQUFDMUQsTUFBVix5QkFBbUIwRCxTQUFTLENBQUMxRCxNQUE3QixtRUFBdUMsR0FBdkM7UUFDQW5HLEtBQUssQ0FBQ21QLE1BQU4sR0FBZ0IsR0FBRXRGLFNBQVMsQ0FBQ3NGLE1BQU8sSUFBbkM7UUFDQW5QLEtBQUssQ0FBQ21HLE1BQU4sR0FBZ0IsR0FBRTBELFNBQVMsQ0FBQzFELE1BQU8sSUFBbkM7UUFDQSxPQUFPMEQsU0FBUyxDQUFDQyxHQUFqQjtRQUNBOztNQUNGLEtBQUtpRCxnRUFBTDtRQUNFbEQsU0FBUyxDQUFDQyxHQUFWLHNCQUFnQkQsU0FBUyxDQUFDQyxHQUExQiw2REFBaUMsQ0FBakM7UUFDQUQsU0FBUyxDQUFDc0YsTUFBVix5QkFBbUJ0RixTQUFTLENBQUNzRixNQUE3QixtRUFBdUMsQ0FBdkM7UUFDQW5QLEtBQUssQ0FBQzhKLEdBQU4sR0FBYSxHQUFFRCxTQUFTLENBQUNDLEdBQUksSUFBN0I7UUFDQTlKLEtBQUssQ0FBQ21QLE1BQU4sR0FBZ0IsR0FBRXRGLFNBQVMsQ0FBQ3NGLE1BQU8sSUFBbkM7UUFDQSxPQUFPdEYsU0FBUyxDQUFDMUQsTUFBakI7UUFDQW5HLEtBQUssQ0FBQ21HLE1BQU4sR0FBZSxFQUFmO1FBQ0E7O01BQ0YsS0FBSzRHLDZEQUFMO1FBQ0VsRCxTQUFTLENBQUNDLEdBQVYsc0JBQWdCRCxTQUFTLENBQUNDLEdBQTFCLDZEQUFpQyxDQUFqQztRQUNBRCxTQUFTLENBQUMxRCxNQUFWLHlCQUFtQjBELFNBQVMsQ0FBQzFELE1BQTdCLG1FQUF1QyxHQUF2QztRQUNBaUwsU0FBUyxDQUFDLENBQUQsQ0FBVCxHQUFlLE1BQWY7UUFDQXBSLEtBQUssQ0FBQzhKLEdBQU4sR0FBYSxjQUFhRCxTQUFTLENBQUNDLEdBQUksS0FBeEM7UUFDQTlKLEtBQUssQ0FBQ21HLE1BQU4sR0FBZ0IsR0FBRTBELFNBQVMsQ0FBQzFELE1BQU8sSUFBbkM7UUFDQSxPQUFPMEQsU0FBUyxDQUFDc0YsTUFBakI7UUFDQTs7TUFDRixLQUFLcEMsNERBQUw7UUFDRWxELFNBQVMsQ0FBQ0MsR0FBVixzQkFBZ0JELFNBQVMsQ0FBQ0MsR0FBMUIsNkRBQWlDLENBQWpDO1FBQ0FELFNBQVMsQ0FBQ3NGLE1BQVYseUJBQW1CdEYsU0FBUyxDQUFDc0YsTUFBN0IsbUVBQXVDLENBQXZDO1FBQ0FuUCxLQUFLLENBQUM4SixHQUFOLEdBQWEsR0FBRUQsU0FBUyxDQUFDQyxHQUFJLEdBQTdCO1FBQ0E5SixLQUFLLENBQUNtUCxNQUFOLEdBQWdCLEdBQUV0RixTQUFTLENBQUNzRixNQUFPLEdBQW5DO1FBQ0EsT0FBT3RGLFNBQVMsQ0FBQzFELE1BQWpCO1FBQ0FuRyxLQUFLLENBQUNtRyxNQUFOLEdBQWUsRUFBZjtRQUNBO0lBdENKOztJQXlDQSxRQUFROEosVUFBUjtNQUNFLEtBQUtuRCw2REFBTDtRQUNFakQsU0FBUyxDQUFDRSxJQUFWLHNCQUFpQkYsU0FBUyxDQUFDRSxJQUEzQiw2REFBbUMsQ0FBbkM7UUFDQUYsU0FBUyxDQUFDM0QsS0FBVix1QkFBa0IyRCxTQUFTLENBQUMzRCxLQUE1QiwrREFBcUMsR0FBckM7UUFDQWxHLEtBQUssQ0FBQytKLElBQU4sR0FBYyxHQUFFRixTQUFTLENBQUNFLElBQUssSUFBL0I7UUFDQS9KLEtBQUssQ0FBQ2tHLEtBQU4sR0FBZSxHQUFFMkQsU0FBUyxDQUFDM0QsS0FBTSxJQUFqQztRQUNBLE9BQU8yRCxTQUFTLENBQUM4RixLQUFqQjtRQUNBOztNQUNGLEtBQUs3Qyw4REFBTDtRQUNFakQsU0FBUyxDQUFDOEYsS0FBVix1QkFBa0I5RixTQUFTLENBQUM4RixLQUE1QiwrREFBcUMsQ0FBckM7UUFDQTlGLFNBQVMsQ0FBQzNELEtBQVYsd0JBQWtCMkQsU0FBUyxDQUFDM0QsS0FBNUIsaUVBQXFDLEdBQXJDO1FBQ0FsRyxLQUFLLENBQUMyUCxLQUFOLEdBQWUsR0FBRTlGLFNBQVMsQ0FBQzhGLEtBQU0sSUFBakM7UUFDQTNQLEtBQUssQ0FBQ2tHLEtBQU4sR0FBZSxHQUFFMkQsU0FBUyxDQUFDM0QsS0FBTSxJQUFqQztRQUNBLE9BQU8yRCxTQUFTLENBQUNFLElBQWpCO1FBQ0E7O01BQ0YsS0FBSytDLGtFQUFMO1FBQ0VqRCxTQUFTLENBQUNFLElBQVYsdUJBQWlCRixTQUFTLENBQUNFLElBQTNCLCtEQUFtQyxDQUFuQztRQUNBRixTQUFTLENBQUM4RixLQUFWLHdCQUFrQjlGLFNBQVMsQ0FBQzhGLEtBQTVCLGlFQUFxQyxDQUFyQztRQUNBM1AsS0FBSyxDQUFDK0osSUFBTixHQUFjLEdBQUVGLFNBQVMsQ0FBQ0UsSUFBSyxJQUEvQjtRQUNBL0osS0FBSyxDQUFDMlAsS0FBTixHQUFlLEdBQUU5RixTQUFTLENBQUM4RixLQUFNLElBQWpDO1FBQ0EsT0FBTzlGLFNBQVMsQ0FBQzNELEtBQWpCO1FBQ0FsRyxLQUFLLENBQUNrRyxLQUFOLEdBQWMsRUFBZDtRQUNBOztNQUNGLEtBQUs0RywrREFBTDtRQUNFakQsU0FBUyxDQUFDRSxJQUFWLHVCQUFpQkYsU0FBUyxDQUFDRSxJQUEzQiwrREFBbUMsQ0FBbkM7UUFDQUYsU0FBUyxDQUFDM0QsS0FBVix3QkFBa0IyRCxTQUFTLENBQUMzRCxLQUE1QixpRUFBcUMsR0FBckM7UUFDQWtMLFNBQVMsQ0FBQyxDQUFELENBQVQsR0FBZSxNQUFmO1FBQ0FwUixLQUFLLENBQUMrSixJQUFOLEdBQWMsY0FBYUYsU0FBUyxDQUFDRSxJQUFLLEtBQTFDO1FBQ0EvSixLQUFLLENBQUNrRyxLQUFOLEdBQWUsR0FBRTJELFNBQVMsQ0FBQzNELEtBQU0sSUFBakM7UUFDQSxPQUFPMkQsU0FBUyxDQUFDOEYsS0FBakI7UUFDQTs7TUFDRixLQUFLN0MsOERBQUw7UUFDRWpELFNBQVMsQ0FBQ0UsSUFBVix1QkFBaUJGLFNBQVMsQ0FBQ0UsSUFBM0IsK0RBQW1DLENBQW5DO1FBQ0FGLFNBQVMsQ0FBQzhGLEtBQVYsd0JBQWtCOUYsU0FBUyxDQUFDOEYsS0FBNUIsaUVBQXFDLENBQXJDO1FBQ0EzUCxLQUFLLENBQUMrSixJQUFOLEdBQWMsR0FBRUYsU0FBUyxDQUFDRSxJQUFLLEdBQS9CO1FBQ0EvSixLQUFLLENBQUMyUCxLQUFOLEdBQWUsR0FBRTlGLFNBQVMsQ0FBQzhGLEtBQU0sR0FBakM7UUFDQSxPQUFPOUYsU0FBUyxDQUFDM0QsS0FBakI7UUFDQWxHLEtBQUssQ0FBQ2tHLEtBQU4sR0FBYyxFQUFkO1FBQ0E7SUF0Q0o7O0lBeUNBbEcsS0FBSyxDQUFDcUgsU0FBTixHQUFtQixhQUFZK0osU0FBUyxDQUFDLENBQUQsQ0FBSSxLQUFJQSxTQUFTLENBQUMsQ0FBRCxDQUFJLEdBQTdEO0lBQ0EsS0FBSzVTLE9BQUwsQ0FBYXFMLFNBQWIsR0FBeUJBLFNBQXpCO0lBQ0EsS0FBS3lJLFNBQUwsR0FBaUJ0UyxLQUFqQjs7SUFDQSxJQUFJLEtBQUswUSxHQUFULEVBQWM7TUFDWixLQUFLLE1BQU1yTSxHQUFYLElBQWtCLEtBQUtpTyxTQUF2QixFQUFrQztRQUNoQyxLQUFLNUIsR0FBTCxDQUFTMVEsS0FBVCxDQUFlcUUsR0FBZixJQUE4QixLQUFLaU8sU0FBTixDQUF3QmpPLEdBQXhCLENBQTdCO01BQ0Q7O01BRUQsS0FBSyxNQUFNQSxHQUFYLElBQWtCLEtBQUtrTyxTQUF2QixFQUFrQztRQUNoQyxLQUFLN0IsR0FBTCxDQUFTMVEsS0FBVCxDQUFlcUUsR0FBZixJQUE4QixLQUFLa08sU0FBTixDQUF3QmxPLEdBQXhCLENBQTdCO01BQ0Q7SUFDRjtFQUNGOztFQUVEbU8sMEJBQTBCLENBQUN2QixnQkFBRCxFQUE2QndCLGVBQTdCLEVBQXdEO0lBQUE7O0lBQ2hGLE1BQU07TUFBRS9EO0lBQUYsSUFBaUIsS0FBS2xRLE9BQTVCO0lBQ0EsTUFBTTtNQUFFZ1IsUUFBRjtNQUFZUztJQUFaLElBQTJCdkIsVUFBM0IsYUFBMkJBLFVBQTNCLGNBQTJCQSxVQUEzQixHQUF5QyxFQUEvQzs7SUFFQSxJQUFJLENBQUN1QyxnQkFBTCxFQUF1QjtNQUNyQkEsZ0JBQWdCLEdBQUcsS0FBS1AsR0FBTCxJQUFZLEtBQUtBLEdBQUwsQ0FBU1EscUJBQVQsRUFBL0I7SUFDRDs7SUFDRCxJQUFJLENBQUN1QixlQUFMLEVBQXNCO01BQUE7O01BQ3BCQSxlQUFlLEdBQUcsS0FBSy9CLEdBQUwsOEJBQVksS0FBS0EsR0FBTCxDQUFTZ0MsYUFBckIsMERBQVksc0JBQXdCeEIscUJBQXhCLEVBQVosQ0FBbEI7SUFDRDs7SUFFRCxNQUFNeUIsV0FBVyxHQUNmMUIsZ0JBQWdCLElBQUl3QixlQUFwQixHQUFzQ3pLLElBQUksQ0FBQzZGLEtBQUwsQ0FBV29ELGdCQUFnQixDQUFDbkgsR0FBakIsR0FBdUIySSxlQUFlLENBQUMzSSxHQUFsRCxDQUF0QyxHQUErRixDQURqRztJQUVBLE1BQU04SSxjQUFjLEdBQ2xCM0IsZ0JBQWdCLElBQUl3QixlQUFwQixHQUFzQ3pLLElBQUksQ0FBQzZGLEtBQUwsQ0FBVzRFLGVBQWUsQ0FBQ3RELE1BQWhCLEdBQXlCOEIsZ0JBQWdCLENBQUM5QixNQUFyRCxDQUF0QyxHQUFxRyxDQUR2RztJQUVBLE1BQU0wRCxZQUFZLEdBQ2hCNUIsZ0JBQWdCLElBQUl3QixlQUFwQixHQUFzQ3pLLElBQUksQ0FBQzZGLEtBQUwsQ0FBV29ELGdCQUFnQixDQUFDbEgsSUFBakIsR0FBd0IwSSxlQUFlLENBQUMxSSxJQUFuRCxDQUF0QyxHQUFpRyxDQURuRztJQUVBLE1BQU0rSSxhQUFhLEdBQ2pCN0IsZ0JBQWdCLElBQUl3QixlQUFwQixHQUFzQ3pLLElBQUksQ0FBQzZGLEtBQUwsQ0FBVzRFLGVBQWUsQ0FBQzlDLEtBQWhCLEdBQXdCc0IsZ0JBQWdCLENBQUN0QixLQUFwRCxDQUF0QyxHQUFtRyxDQURyRztJQUdBLE1BQU05RixTQUFTLEdBQUcsRUFBbEI7SUFFQSxNQUFNM0QsS0FBSyxpREFBRytLLGdCQUFILHNEQUFHLGtCQUFrQi9LLEtBQXJCLHlFQUE4QixHQUF6QztJQUNBLE1BQU1DLE1BQU0sbURBQUc4SyxnQkFBSCx1REFBRyxtQkFBa0I5SyxNQUFyQiwyRUFBK0IsR0FBM0M7O0lBRUEsUUFBUXFKLFFBQVI7TUFDRSxLQUFLekMsMERBQUw7UUFDRWxELFNBQVMsQ0FBQ0MsR0FBVixHQUFnQjZJLFdBQWhCO1FBQ0E5SSxTQUFTLENBQUMxRCxNQUFWLEdBQW1CQSxNQUFuQjtRQUNBOztNQUNGLEtBQUs0Ryw2REFBTDtRQUNFbEQsU0FBUyxDQUFDc0YsTUFBVixHQUFtQnlELGNBQW5CO1FBQ0EvSSxTQUFTLENBQUMxRCxNQUFWLEdBQW1CQSxNQUFuQjtRQUNBOztNQUNGLEtBQUs0RyxnRUFBTDtRQUNFbEQsU0FBUyxDQUFDQyxHQUFWLEdBQWdCNkksV0FBaEI7UUFDQTlJLFNBQVMsQ0FBQ3NGLE1BQVYsR0FBbUJ5RCxjQUFuQjtRQUNBOztNQUNGLEtBQUs3Riw2REFBTDtRQUNFLE1BQU1nRyxhQUFhLEdBQUc5QixnQkFBZ0IsR0FBRzBCLFdBQVcsR0FBR3hNLE1BQU0sR0FBRyxDQUExQixHQUE4QixDQUFwRTtRQUNBLE1BQU02TSxZQUFZLEdBQUdQLGVBQWUsR0FBR0EsZUFBZSxDQUFDdE0sTUFBaEIsR0FBeUIsQ0FBNUIsR0FBZ0MsQ0FBcEU7UUFDQSxNQUFNOE0sa0JBQWtCLEdBQUdELFlBQVksR0FBR0QsYUFBMUM7UUFDQWxKLFNBQVMsQ0FBQ0MsR0FBVixHQUFnQm1KLGtCQUFoQjtRQUNBcEosU0FBUyxDQUFDMUQsTUFBVixHQUFtQkEsTUFBbkI7UUFDQTs7TUFDRixLQUFLNEcsNERBQUw7UUFDRWxELFNBQVMsQ0FBQ0MsR0FBVixHQUFpQjZJLFdBQVcsaURBQUlGLGVBQUoscURBQUksaUJBQWlCdE0sTUFBckIseUVBQStCQSxNQUEvQixDQUFaLEdBQXNELEdBQXRFO1FBQ0EwRCxTQUFTLENBQUNzRixNQUFWLEdBQW9CeUQsY0FBYyxtREFBSUgsZUFBSixzREFBSSxrQkFBaUJ0TSxNQUFyQiwyRUFBK0JBLE1BQS9CLENBQWYsR0FBeUQsR0FBNUU7UUFDQTtJQXZCSjs7SUEwQkEsUUFBUThKLFVBQVI7TUFDRSxLQUFLbkQsNkRBQUw7UUFDRWpELFNBQVMsQ0FBQ0UsSUFBVixHQUFpQjhJLFlBQWpCO1FBQ0FoSixTQUFTLENBQUMzRCxLQUFWLEdBQWtCQSxLQUFsQjtRQUNBOztNQUNGLEtBQUs0Ryw4REFBTDtRQUNFakQsU0FBUyxDQUFDOEYsS0FBVixHQUFrQm1ELGFBQWxCO1FBQ0FqSixTQUFTLENBQUMzRCxLQUFWLEdBQWtCQSxLQUFsQjtRQUNBOztNQUNGLEtBQUs0RyxrRUFBTDtRQUNFakQsU0FBUyxDQUFDRSxJQUFWLEdBQWlCOEksWUFBakI7UUFDQWhKLFNBQVMsQ0FBQzhGLEtBQVYsR0FBa0JtRCxhQUFsQjtRQUNBOztNQUNGLEtBQUtoRywrREFBTDtRQUNFLE1BQU1pRyxhQUFhLEdBQUc5QixnQkFBZ0IsR0FBRzRCLFlBQVksR0FBRzNNLEtBQUssR0FBRyxDQUExQixHQUE4QixDQUFwRTtRQUNBLE1BQU04TSxZQUFZLEdBQUdQLGVBQWUsR0FBR0EsZUFBZSxDQUFDdk0sS0FBaEIsR0FBd0IsQ0FBM0IsR0FBK0IsQ0FBbkU7UUFDQSxNQUFNK00sa0JBQWtCLEdBQUdELFlBQVksR0FBR0QsYUFBMUM7UUFDQWxKLFNBQVMsQ0FBQ0UsSUFBVixHQUFpQmtKLGtCQUFqQjtRQUNBcEosU0FBUyxDQUFDM0QsS0FBVixHQUFrQkEsS0FBbEI7UUFDQTs7TUFDRixLQUFLNEcsOERBQUw7UUFDRWpELFNBQVMsQ0FBQ0UsSUFBVixHQUFrQjhJLFlBQVksa0RBQUlKLGVBQUosc0RBQUksa0JBQWlCdk0sS0FBckIseUVBQThCQSxLQUE5QixDQUFiLEdBQXFELEdBQXRFO1FBQ0EyRCxTQUFTLENBQUM4RixLQUFWLEdBQW1CbUQsYUFBYSxtREFBSUwsZUFBSixzREFBSSxrQkFBaUJ2TSxLQUFyQiwyRUFBOEJBLEtBQTlCLENBQWQsR0FBc0QsR0FBeEU7UUFDQTtJQXZCSjs7SUEwQkEsS0FBSzFILE9BQUwsQ0FBYXFMLFNBQWIsR0FBeUJBLFNBQXpCO0lBRUEsS0FBSzhHLHNCQUFMO0lBQ0EsS0FBS3VDLEtBQUw7RUFDRDs7RUFFREMsVUFBVSxDQUFDN00sR0FBRCxFQUF3QjtJQUFBOztJQUNoQyxJQUFJLEtBQUtrSyxJQUFMLENBQVVuSyxXQUFkLEVBQTJCO01BQ3pCLEtBQUtaLElBQUwsR0FBWSxLQUFLK0ssSUFBTCxDQUFVbkssV0FBVixDQUFzQkMsR0FBdEIsRUFBMkIsS0FBSzlILE9BQUwsQ0FBYU8sTUFBeEMsQ0FBWjtNQUNBLEtBQUttVSxLQUFMLEdBRnlCLENBRVg7SUFDZjs7SUFFRCxNQUFNO01BQUV2SCxVQUFGO01BQWN0SjtJQUFkLElBQXlCLEtBQUs3RCxPQUFwQztJQUNBLE1BQU1FLEdBQWtCLEdBQUcsRUFBM0I7O0lBQ0EsSUFBSWlOLFVBQUosRUFBZ0I7TUFDZCxJQUFJQSxVQUFVLENBQUN0QixLQUFmLEVBQXNCO1FBQ3BCLE1BQU1BLEtBQUssR0FBRy9ELEdBQUcsQ0FBQzhELFFBQUosQ0FBYXVCLFVBQVUsQ0FBQ3RCLEtBQXhCLENBQWQ7UUFDQTNMLEdBQUcsQ0FBQzBVLGVBQUosR0FBc0IvSSxLQUFLLENBQUNwRyxLQUFOLEVBQXRCO01BQ0Q7O01BQ0QsSUFBSTBILFVBQVUsQ0FBQzBILEtBQWYsRUFBc0I7UUFDcEIsTUFBTUEsS0FBSyxHQUFHL00sR0FBRyxDQUFDNkQsV0FBSixDQUFnQndCLFVBQVUsQ0FBQzBILEtBQTNCLENBQWQ7O1FBQ0EsSUFBSUEsS0FBSixFQUFXO1VBQ1QsTUFBTTdSLENBQUMsR0FBRzZSLEtBQUssQ0FBQ3BQLEtBQU4sRUFBVjs7VUFDQSxJQUFJekMsQ0FBSixFQUFPO1lBQ0w5QyxHQUFHLENBQUM0VSxlQUFKLEdBQXVCLFFBQU85UixDQUFFLElBQWhDOztZQUNBLDRCQUFRbUssVUFBVSxDQUFDRixJQUFuQiwrREFBMkIyRSw0RUFBM0I7Y0FDRSxLQUFLQSw0RUFBTDtnQkFDRTFSLEdBQUcsQ0FBQzhVLGNBQUosR0FBcUIsU0FBckI7Z0JBQ0E5VSxHQUFHLENBQUMrVSxnQkFBSixHQUF1QixXQUF2QjtnQkFDQTs7Y0FDRixLQUFLckQsMEVBQUw7Z0JBQ0UxUixHQUFHLENBQUM4VSxjQUFKLEdBQXFCLE9BQXJCO2dCQUNBOVUsR0FBRyxDQUFDK1UsZ0JBQUosR0FBdUIsV0FBdkI7Z0JBQ0E7O2NBQ0YsS0FBS3JELDZFQUFMO2dCQUNFMVIsR0FBRyxDQUFDK1UsZ0JBQUosR0FBdUIsV0FBdkI7Z0JBQ0E7O2NBQ0YsS0FBS3JELHlFQUFMO2dCQUNFMVIsR0FBRyxDQUFDK1UsZ0JBQUosR0FBdUIsUUFBdkI7Z0JBQ0E7O2NBQ0YsS0FBS3JELHlFQUFMO2dCQUNFMVIsR0FBRyxDQUFDOFUsY0FBSixHQUFxQixXQUFyQjtnQkFDQTtZQWpCSjtVQW1CRDtRQUNGO01BQ0Y7SUFDRjs7SUFFRCxJQUFJblIsTUFBTSxJQUFJQSxNQUFNLENBQUNnSSxLQUFqQixJQUEwQmhJLE1BQU0sQ0FBQzZELEtBQXJDLEVBQTRDO01BQzFDLE1BQU1tRSxLQUFLLEdBQUcvRCxHQUFHLENBQUM4RCxRQUFKLENBQWEvSCxNQUFNLENBQUNnSSxLQUFwQixDQUFkO01BQ0EzTCxHQUFHLENBQUNvVixXQUFKLEdBQWtCelIsTUFBTSxDQUFDNkQsS0FBekI7TUFDQXhILEdBQUcsQ0FBQ2tRLFdBQUosR0FBa0IsT0FBbEI7TUFDQWxRLEdBQUcsQ0FBQ3FWLFdBQUosR0FBa0IxSixLQUFLLENBQUNwRyxLQUFOLEVBQWxCLENBSjBDLENBTTFDOztNQUNBLElBQUl2RixHQUFHLENBQUM0VSxlQUFSLEVBQXlCO1FBQ3ZCNVUsR0FBRyxDQUFDc1YsZ0JBQUosR0FBdUIsYUFBdkI7TUFDRDtJQUNGOztJQUVELEtBQUt6QixTQUFMLEdBQWlCN1QsR0FBakI7SUFDQSxLQUFLaVMsc0JBQUw7RUFDRDs7RUFFRHVCLE1BQU0sR0FBd0I7SUFDNUIsT0FBTyxLQUFQO0VBQ0Q7RUFFRDs7O0VBQ0ErQixLQUFLLENBQUNDLE9BQUQsRUFBcUM7SUFDeENBLE9BQU8sQ0FBQyxJQUFELENBQVA7RUFDRDs7RUFFRDNWLFFBQVEsQ0FBQ0MsT0FBRCxFQUFnQztJQUN0QyxJQUFJLEtBQUtnUyxJQUFMLENBQVUxSyxFQUFWLEtBQWlCdEgsT0FBTyxDQUFDb08sSUFBN0IsRUFBbUM7TUFBQTs7TUFDakMsS0FBSzRELElBQUwsNEJBQVkzRCxrRkFBQSxDQUFrQ3JPLE9BQU8sQ0FBQ29PLElBQTFDLENBQVoseUVBQStENUIsK0VBQS9EO0lBQ0QsQ0FIcUMsQ0FLdEM7OztJQUNBLE1BQU1vSixPQUFPLEdBQUcsS0FBSzVWLE9BQUwsQ0FBYTZFLElBQTdCO0lBQ0EsTUFBTVMsT0FBTyxHQUFHdEYsT0FBTyxDQUFDNkUsSUFBeEI7SUFFQSxLQUFLNlAsS0FBTDtJQUNBLEtBQUsxVSxPQUFMLHFCQUFvQkEsT0FBcEI7SUFDQSxJQUFJeVQsSUFBSSxHQUFHLEtBQUt4QixNQUFoQjs7SUFDQSxPQUFPd0IsSUFBUCxFQUFhO01BQ1gsSUFBSUEsSUFBSSxDQUFDQyxNQUFMLEVBQUosRUFBbUI7UUFDakJELElBQUksQ0FBQ2hFLEtBQUwsQ0FBV29HLElBQVg7UUFDQTtNQUNEOztNQUNEcEMsSUFBSSxDQUFDaUIsS0FBTDtNQUNBakIsSUFBSSxHQUFHQSxJQUFJLENBQUN4QixNQUFaO0lBQ0Q7O0lBRUQsTUFBTXhDLEtBQUssR0FBRyxLQUFLOEMsUUFBTCxFQUFkOztJQUNBLElBQUlxRCxPQUFPLEtBQUt0USxPQUFaLElBQXVCbUssS0FBM0IsRUFBa0M7TUFDaENBLEtBQUssQ0FBQzhELE1BQU4sQ0FBYXVDLE1BQWIsQ0FBb0JGLE9BQXBCO01BQ0FuRyxLQUFLLENBQUM4RCxNQUFOLENBQWFDLEdBQWIsQ0FBaUJsTyxPQUFqQixFQUEwQixJQUExQjtJQUNEO0VBQ0Y7O0VBRUR5USxZQUFZLEdBQUc7SUFDYix5QkFBWSxLQUFLL1YsT0FBakI7RUFDRDs7RUF5RERnSCxNQUFNLEdBQUc7SUFDUCxNQUFNO01BQUVnTDtJQUFGLElBQVcsSUFBakI7SUFDQSxvQkFDRTtNQUFvQixHQUFHLEVBQUUsS0FBS2dFLFdBQTlCO01BQUEsdUJBQ0UsdURBQUMsSUFBRCxDQUFNLE9BQU47UUFBZ0QsTUFBTSxFQUFFLEtBQUtoVyxPQUFMLENBQWFPLE1BQXJFO1FBQTZFLElBQUksRUFBRSxLQUFLMEc7TUFBeEYsR0FBb0IsR0FBRSxLQUFLZ1AsR0FBSSxJQUFHLEtBQUt2QixLQUFNLEVBQTdDO0lBREYsR0FBVSxLQUFLdUIsR0FBZixDQURGO0VBS0Q7O0FBL1orQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCbEQ7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBRUE7O0FBSU8sTUFBTUcsY0FBaUMsR0FBRztFQUMvQzlPLEVBQUUsRUFBRSxPQUQyQztFQUUvQ3pDLElBQUksRUFBRSxPQUZ5QztFQUcvQzBDLFdBQVcsRUFBRSxPQUhrQztFQUsvQ0ssYUFBYSxFQUFFLE9BQU87SUFDcEJySCxNQUFNLEVBQUU7RUFEWSxDQUFQLENBTGdDO0VBUy9DO0VBQ0FpSCxPQUFPLEVBQUUsTUFBTTtJQUNiLG9DQUFPO01BQUE7SUFBQSxFQUFQO0VBQ0Q7QUFaOEMsQ0FBMUM7QUFlQSxNQUFNNk8sVUFBTixTQUF5QnZFLGtEQUF6QixDQUFzQztFQUkzQ0MsV0FBVyxDQUFRL1IsT0FBUixFQUFxQ3lQLEtBQXJDLEVBQTBEd0MsTUFBMUQsRUFBK0U7SUFDeEYsTUFBTW1FLGNBQU4sRUFBc0JwVyxPQUF0QixFQUErQmlTLE1BQS9COztJQUR3RixrQ0FIL0QsRUFHK0Q7O0lBQUE7O0lBQUEsa0NBOEQvRSxDQUFDcUUsTUFBRCxFQUF3QjlULE9BQXhCLEVBQStDK1QsVUFBVSxHQUFHLElBQTVELEVBQWtFQyxxQkFBcUIsR0FBRyxJQUExRixLQUFtRztNQUFBOztNQUM1RyxRQUFRRixNQUFSO1FBQ0UsS0FBS0gsZ0ZBQUw7VUFDRSxLQUFLTyxRQUFMLEdBQWdCLEtBQUtBLFFBQUwsQ0FBY0MsTUFBZCxDQUFzQkMsQ0FBRCxJQUFPQSxDQUFDLEtBQUtwVSxPQUFsQyxDQUFoQjtVQUNBLEtBQUtpTixLQUFMLENBQVc4RCxNQUFYLENBQWtCdUMsTUFBbEIsQ0FBeUJ0VCxPQUFPLENBQUN4QyxPQUFSLENBQWdCNkUsSUFBekM7VUFDQSxLQUFLNEssS0FBTCxDQUFXb0csSUFBWDtVQUNBLEtBQUtnQixvQkFBTDtVQUNBOztRQUNGLEtBQUtWLG1GQUFMO1VBQ0UsSUFBSTNULE9BQU8sQ0FBQ3dQLElBQVIsQ0FBYTFLLEVBQWIsS0FBb0IsT0FBeEIsRUFBaUM7WUFDL0J5UCxPQUFPLENBQUNDLEdBQVIsQ0FBWSxnQ0FBWixFQUE4Q1YsTUFBOUMsRUFBc0Q5VCxPQUF0RDtZQUNBO1VBQ0Q7O1VBQ0QsTUFBTXlVLElBQUksR0FBR2YsaURBQVMsQ0FBQzFULE9BQU8sQ0FBQ3hDLE9BQVQsQ0FBdEI7O1VBRUEsSUFBSXdXLHFCQUFKLEVBQTJCO1lBQ3pCLE1BQU07Y0FBRXRHLFVBQUY7Y0FBYzdFLFNBQVMsRUFBRTZMO1lBQXpCLElBQTBDMVUsT0FBTyxDQUFDeEMsT0FBeEQ7WUFDQSxNQUFNO2NBQUVnUixRQUFGO2NBQVlTO1lBQVosSUFBMkJ2QixVQUEzQixhQUEyQkEsVUFBM0IsY0FBMkJBLFVBQTNCLEdBQXlDLEVBQS9DO1lBQ0EsTUFBTTdFLFNBQVMsR0FBRzZMLFlBQUgsYUFBR0EsWUFBSCxjQUFHQSxZQUFILEdBQW9CLEVBQW5DOztZQUVBLFFBQVFsRyxRQUFSO2NBQ0UsS0FBS3pDLDBEQUFMO2NBQ0EsS0FBS0EsZ0VBQUw7Z0JBQ0UsSUFBSWxELFNBQVMsQ0FBQ0MsR0FBVixJQUFpQixJQUFyQixFQUEyQjtrQkFDekJELFNBQVMsQ0FBQ0MsR0FBVixHQUFnQixFQUFoQjtnQkFDRCxDQUZELE1BRU87a0JBQ0xELFNBQVMsQ0FBQ0MsR0FBVixJQUFpQixFQUFqQjtnQkFDRDs7Z0JBQ0Q7O2NBQ0YsS0FBS2lELDZEQUFMO2dCQUNFLElBQUlsRCxTQUFTLENBQUNzRixNQUFWLElBQW9CLElBQXhCLEVBQThCO2tCQUM1QnRGLFNBQVMsQ0FBQ3NGLE1BQVYsR0FBbUIsR0FBbkI7Z0JBQ0QsQ0FGRCxNQUVPO2tCQUNMdEYsU0FBUyxDQUFDc0YsTUFBVixJQUFvQixFQUFwQjtnQkFDRDs7Z0JBQ0Q7WUFmSjs7WUFrQkEsUUFBUWMsVUFBUjtjQUNFLEtBQUtuRCw2REFBTDtjQUNBLEtBQUtBLGtFQUFMO2dCQUNFLElBQUlqRCxTQUFTLENBQUNFLElBQVYsSUFBa0IsSUFBdEIsRUFBNEI7a0JBQzFCRixTQUFTLENBQUNFLElBQVYsR0FBaUIsRUFBakI7Z0JBQ0QsQ0FGRCxNQUVPO2tCQUNMRixTQUFTLENBQUNFLElBQVYsSUFBa0IsRUFBbEI7Z0JBQ0Q7O2dCQUNEOztjQUNGLEtBQUsrQyw4REFBTDtnQkFDRSxJQUFJakQsU0FBUyxDQUFDOEYsS0FBVixJQUFtQixJQUF2QixFQUE2QjtrQkFDM0I5RixTQUFTLENBQUM4RixLQUFWLEdBQWtCLEVBQWxCO2dCQUNELENBRkQsTUFFTztrQkFDTDlGLFNBQVMsQ0FBQzhGLEtBQVYsSUFBbUIsRUFBbkI7Z0JBQ0Q7O2dCQUNEO1lBZko7O1lBa0JBOEYsSUFBSSxDQUFDNUwsU0FBTCxHQUFpQkEsU0FBakI7VUFDRDs7VUFFRCxNQUFNOEwsSUFBSSxHQUFHLElBQUlyRixrREFBSixDQUFpQnRQLE9BQU8sQ0FBQ3dQLElBQXpCLEVBQStCaUYsSUFBL0IsRUFBcUMsSUFBckMsQ0FBYjtVQUNBRSxJQUFJLENBQUN4QyxVQUFMLENBQWdCLEtBQUtsRixLQUFMLENBQVcySCxPQUEzQjs7VUFDQSxJQUFJYixVQUFKLEVBQWdCO1lBQ2RZLElBQUksQ0FBQ25YLE9BQUwsQ0FBYTZFLElBQWIsR0FBb0IsS0FBSzRLLEtBQUwsQ0FBVzZELGtCQUFYLEVBQXBCO1VBQ0Q7O1VBQ0QsS0FBS29ELFFBQUwsQ0FBYzdULElBQWQsQ0FBbUJzVSxJQUFuQjtVQUNBLEtBQUsxSCxLQUFMLENBQVc4RCxNQUFYLENBQWtCQyxHQUFsQixDQUFzQjJELElBQUksQ0FBQ25YLE9BQUwsQ0FBYTZFLElBQW5DLEVBQXlDc1MsSUFBekM7VUFDQSxLQUFLMUgsS0FBTCxDQUFXb0csSUFBWDtVQUNBLEtBQUtnQixvQkFBTDtVQUNBOztRQUNGLEtBQUtWLGlGQUFMO1FBQ0EsS0FBS0Esb0ZBQUw7VUFDRSxtQkFBQTNULE9BQU8sQ0FBQ3lQLE1BQVIsb0VBQWdCc0YsTUFBaEIsQ0FBdUIvVSxPQUF2QixFQUFnQzhULE1BQWhDO1VBQ0E7O1FBRUY7VUFDRVMsT0FBTyxDQUFDQyxHQUFSLENBQVksV0FBWixFQUF5QlYsTUFBekIsRUFBaUM5VCxPQUFqQztVQUNBO01BM0VKO0lBNkVELENBNUl5Rjs7SUFBQSxLQUF2RXhDLE9BQXVFLEdBQXZFQSxPQUF1RTtJQUFBLEtBQXJCaVMsTUFBcUIsR0FBckJBLE1BQXFCO0lBR3hGLEtBQUt4QyxLQUFMLEdBQWFBLEtBQWIsQ0FId0YsQ0FLeEY7O0lBQ0EsSUFBSTtNQUFFaUg7SUFBRixJQUFlLEtBQUsxVyxPQUF4Qjs7SUFDQSxJQUFJLENBQUMwVyxRQUFMLEVBQWU7TUFDYixLQUFLMVcsT0FBTCxDQUFhMFcsUUFBYixHQUF3QkEsUUFBUSxHQUFHLEVBQW5DO0lBQ0Q7O0lBRUQsS0FBSyxNQUFNYyxDQUFYLElBQWdCZCxRQUFoQixFQUEwQjtNQUN4QixJQUFJYyxDQUFDLENBQUNwSixJQUFGLEtBQVcsT0FBZixFQUF3QjtRQUN0QixLQUFLc0ksUUFBTCxDQUFjN1QsSUFBZCxDQUFtQixJQUFJd1QsVUFBSixDQUFlbUIsQ0FBZixFQUF3Qy9ILEtBQXhDLEVBQStDLElBQS9DLENBQW5CO01BQ0QsQ0FGRCxNQUVPO1FBQUE7O1FBQ0wsTUFBTXVDLElBQUksNEJBQUczRCxrRkFBQSxDQUFrQ21KLENBQUMsQ0FBQ3BKLElBQXBDLENBQUgseUVBQWdENUIsK0VBQTFEO1FBQ0EsS0FBS2tLLFFBQUwsQ0FBYzdULElBQWQsQ0FBbUIsSUFBSWlQLGtEQUFKLENBQWlCRSxJQUFqQixFQUF1QndGLENBQXZCLEVBQTBCLElBQTFCLENBQW5CO01BQ0Q7SUFDRjtFQUNGOztFQUVEOUQsTUFBTSxHQUF3QjtJQUM1QixPQUFPLEtBQVA7RUFDRDs7RUFFRGlCLFVBQVUsQ0FBQzdNLEdBQUQsRUFBd0I7SUFDaEMsTUFBTTZNLFVBQU4sQ0FBaUI3TSxHQUFqQjs7SUFDQSxLQUFLLE1BQU0yUCxJQUFYLElBQW1CLEtBQUtmLFFBQXhCLEVBQWtDO01BQ2hDZSxJQUFJLENBQUM5QyxVQUFMLENBQWdCN00sR0FBaEI7SUFDRDtFQUNGLENBbEMwQyxDQW9DM0M7OztFQUNBNFAsT0FBTyxDQUFDQyxVQUFELEVBQXFCQyxRQUFyQixFQUF1QztJQUM1QyxNQUFNQyxNQUFNLEdBQUdDLEtBQUssQ0FBQ0MsSUFBTixDQUFXLEtBQUtyQixRQUFoQixDQUFmO0lBQ0EsTUFBTSxDQUFDc0IsT0FBRCxJQUFZSCxNQUFNLENBQUNJLE1BQVAsQ0FBY04sVUFBZCxFQUEwQixDQUExQixDQUFsQjtJQUNBRSxNQUFNLENBQUNJLE1BQVAsQ0FBY0wsUUFBZCxFQUF3QixDQUF4QixFQUEyQkksT0FBM0I7SUFDQSxLQUFLdEIsUUFBTCxHQUFnQm1CLE1BQWhCO0lBRUEsS0FBS2hCLG9CQUFMO0VBQ0Q7O0VBRURVLE1BQU0sQ0FBQ1csS0FBRCxFQUFzQjVCLE1BQXRCLEVBQTZDO0lBQ2pELE1BQU02QixJQUFJLEdBQUcsS0FBS3pCLFFBQUwsQ0FBY0MsTUFBZCxDQUFzQjNULENBQUQsSUFBT0EsQ0FBQyxLQUFLa1YsS0FBbEMsQ0FBYjs7SUFDQSxJQUFJNUIsTUFBTSxLQUFLSCxvRkFBZixFQUF5QztNQUN2Q2dDLElBQUksQ0FBQ0MsT0FBTCxDQUFhRixLQUFiO0lBQ0QsQ0FGRCxNQUVPO01BQ0xDLElBQUksQ0FBQ3RWLElBQUwsQ0FBVXFWLEtBQVY7SUFDRDs7SUFDRCxLQUFLeEIsUUFBTCxHQUFnQnlCLElBQWhCO0lBQ0EsS0FBSzFJLEtBQUwsQ0FBV29HLElBQVg7SUFDQSxLQUFLZ0Isb0JBQUw7RUFDRDs7RUFFREEsb0JBQW9CLEdBQUc7SUFDckI7SUFDQSxLQUFLcEgsS0FBTCxDQUFXNEkscUJBQVg7SUFDQUMsVUFBVSxDQUFDLE1BQU0sS0FBSzdJLEtBQUwsQ0FBVzhJLFlBQVgsQ0FBd0IsSUFBeEIsRUFBOEIsS0FBSzlJLEtBQUwsQ0FBVytJLGdCQUF6QyxDQUFQLENBQVY7RUFDRCxDQTlEMEMsQ0FnRTNDO0VBQ0E7OztFQWlGQXhSLE1BQU0sR0FBRztJQUNQLG9CQUNFO01BQW9CLEdBQUcsRUFBRSxLQUFLZ1AsV0FBOUI7TUFBMkMsS0FBSyxFQUFFO1FBQUV5QyxRQUFRLEVBQUU7TUFBWixDQUFsRDtNQUFBLFVBQ0csS0FBSy9CLFFBQUwsQ0FBY2dDLEdBQWQsQ0FBbUIxVixDQUFELElBQU9BLENBQUMsQ0FBQ2dFLE1BQUYsRUFBekI7SUFESCxHQUFVLEtBQUtpUCxHQUFmLENBREY7RUFLRDtFQUVEOzs7RUFDQVIsS0FBSyxDQUFDQyxPQUFELEVBQXFDO0lBQ3hDLE1BQU1ELEtBQU4sQ0FBWUMsT0FBWjs7SUFDQSxLQUFLLE1BQU1rQixDQUFYLElBQWdCLEtBQUtGLFFBQXJCLEVBQStCO01BQzdCaEIsT0FBTyxDQUFDa0IsQ0FBRCxDQUFQO0lBQ0Q7RUFDRjs7RUFFRGIsWUFBWSxHQUFHO0lBQ2IseUJBQ0ssS0FBSy9WLE9BRFY7TUFFRTBXLFFBQVEsRUFBRSxLQUFLQSxRQUFMLENBQWNnQyxHQUFkLENBQW1CMVYsQ0FBRCxJQUFPQSxDQUFDLENBQUMrUyxZQUFGLEVBQXpCO0lBRlo7RUFJRDs7QUF2SzBDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlCN0M7QUFJQTs7QUFHTyxNQUFNNEMsV0FBTixTQUEwQnRDLDhDQUExQixDQUFxQztFQUMxQ3RFLFdBQVcsQ0FBUS9SLE9BQVIsRUFBNEN5UCxLQUE1QyxFQUFrRW1KLGNBQWxFLEVBQThGO0lBQ3ZHLE1BQU01WSxPQUFOLEVBQWV5UCxLQUFmOztJQUR1RyxvQ0E2QjNGM0osTUFBRCxJQUE0QjtNQUN2QyxLQUFLb00sR0FBTCxHQUFXcE0sTUFBWDtJQUNELENBL0J3Rzs7SUFBQSxLQUF0RjlGLE9BQXNGLEdBQXRGQSxPQUFzRjtJQUFBLEtBQWxEeVAsS0FBa0QsR0FBbERBLEtBQWtEO0lBQUEsS0FBNUJtSixjQUE0QixHQUE1QkEsY0FBNEI7SUFHdkcsS0FBSzlFLFNBQUwsR0FBaUI7TUFDZm5NLE1BQU0sRUFBRSxNQURPO01BRWZELEtBQUssRUFBRTtJQUZRLENBQWpCO0VBSUQ7O0VBRURnTSxNQUFNLEdBQXdCO0lBQzVCLE9BQU8sSUFBUDtFQUNELENBWnlDLENBYzFDOzs7RUFDQTNULFFBQVEsQ0FBQ0MsT0FBRCxFQUFnQztJQUN0QyxLQUFLMFUsS0FBTDtJQUNBLEtBQUsxVSxPQUFMLHFCQUFvQkEsT0FBcEI7SUFDQSxLQUFLNFksY0FBTDtFQUNEOztFQUVEN0MsWUFBWSxHQUF1QjtJQUNqQyxzQkFBMkMsS0FBSy9WLE9BQWhEO0lBQUEsTUFBa0M2WSxJQUFsQzs7SUFFQSx5QkFDS0EsSUFETDtNQUNXO01BQ1RuQyxRQUFRLEVBQUUsS0FBS0EsUUFBTCxDQUFjZ0MsR0FBZCxDQUFtQjFWLENBQUQsSUFBT0EsQ0FBQyxDQUFDK1MsWUFBRixFQUF6QjtJQUZaO0VBSUQ7O0VBTUQvTyxNQUFNLEdBQUc7SUFDUCxvQkFDRTtNQUNFLGFBQWEsRUFBRzVCLEtBQUQsSUFBV0EsS0FBSyxDQUFDMFQsY0FBTixFQUQ1QjtNQUdFLEdBQUcsRUFBRSxLQUFLQyxVQUhaO01BSUUsS0FBSyxvQkFBTyxLQUFLakYsU0FBWixFQUEwQixLQUFLQyxTQUEvQixDQUpQO01BQUEsVUFNRyxLQUFLMkMsUUFBTCxDQUFjZ0MsR0FBZCxDQUFtQjFWLENBQUQsSUFBT0EsQ0FBQyxDQUFDZ0UsTUFBRixFQUF6QjtJQU5ILEdBRU8sS0FBS2lQLEdBRlosQ0FERjtFQVVEOztBQTdDeUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUDVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFPQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7OztBQU9PLE1BQU00RCxLQUFOLENBQVk7RUFHdUI7RUFvQnhDOUgsV0FBVyxDQUFDaEssR0FBRCxFQUEwQitSLGFBQTFCLEVBQXlEQyxNQUF6RCxFQUFvRztJQUFBLGdDQXRCdEdqVixTQUFTLENBQUN2RSwwREFBRCxDQXNCNkY7O0lBQUEsbUNBckIxRixJQUFJMFksZ0RBQUosQ0FBa0MsQ0FBbEMsQ0FxQjBGOztJQUFBLCtCQXBCOUYsSUFBSUMsMENBQUosRUFvQjhGOztJQUFBLGdDQW5CN0YsSUFBSWMsR0FBSixFQW1CNkY7O0lBQUE7O0lBQUEsK0JBZnZHLENBZXVHOztJQUFBLCtCQWJ2RyxDQWF1Rzs7SUFBQSxnQ0FadEcsQ0FZc0c7O0lBQUEsK0JBWHhGLEVBV3dGOztJQUFBOztJQUFBOztJQUFBOztJQUFBOztJQUFBOztJQUFBOztJQUFBLG9EQUpsRixLQUlrRjs7SUFBQSx3Q0FGOUZYLGlGQUFBLEdBQWtDYSxTQUFsQyxLQUFnRGpYLFNBRThDOztJQUFBLDRDQUkxRixDQUFDa1gsT0FBTyxHQUFHLEtBQVgsS0FBcUI7TUFDeEMsTUFBTWxhLEtBQUssR0FBR2thLE9BQU8sR0FBRyxPQUFILEdBQWEsU0FBbEM7TUFDQSxJQUFJQyxHQUFHLEdBQUcsS0FBSzdHLE1BQUwsQ0FBWXRHLElBQVosR0FBbUIsQ0FBN0I7TUFFQSxNQUFNZCxHQUFHLEdBQUdpTyxHQUFHLEdBQUcsR0FBbEI7O01BQ0EsT0FBTyxLQUFJLElBQUlBLEdBQUcsR0FBR2pPLEdBQXJCLEVBQTBCO1FBQ3hCLE1BQU10SCxJQUFJLEdBQUksR0FBRTVFLEtBQU0sSUFBR21hLEdBQUcsRUFBRyxFQUEvQjs7UUFDQSxJQUFJLENBQUMsS0FBSzdHLE1BQUwsQ0FBWThHLEdBQVosQ0FBZ0J4VixJQUFoQixDQUFMLEVBQTRCO1VBQzFCLE9BQU9BLElBQVA7UUFDRDtNQUNGOztNQUVELE9BQVEsR0FBRTVFLEtBQU0sSUFBR21ULElBQUksQ0FBQ0MsR0FBTCxFQUFXLEVBQTlCO0lBQ0QsQ0FqQjhHOztJQUFBLG1DQW1CbEdyUSxDQUFELElBQWU7TUFDekIsT0FBTyxDQUFDLEtBQUt1USxNQUFMLENBQVk4RyxHQUFaLENBQWdCclgsQ0FBaEIsQ0FBUjtJQUNELENBckI4Rzs7SUFBQSxpQ0ErQ25GO01BQzFCNEksUUFBUSxFQUFHQyxLQUFELElBQWlDME4sd0ZBQXlCLENBQUMsS0FBS3RTLElBQU4sRUFBWTRFLEtBQVosQ0FEMUM7TUFFMUJ5TyxRQUFRLEVBQUdDLEtBQUQsSUFBaUNiLHdGQUF5QixDQUFDLEtBQUt6UyxJQUFOLEVBQVlzVCxLQUFaLENBRjFDO01BRzFCeFIsU0FBUyxFQUFHeVIsTUFBRCxJQUFtQ2YseUZBQTBCLENBQUMsS0FBS3hTLElBQU4sRUFBWXVULE1BQVosQ0FIOUM7TUFJMUJ4UyxPQUFPLEVBQUcxRCxJQUFELElBQStCcVYsdUZBQXdCLENBQUMsS0FBSzFTLElBQU4sRUFBWTNDLElBQVosQ0FKdEM7TUFLMUJxSCxXQUFXLEVBQUc4TyxHQUFELElBQWtDakIsMkZBQTRCLENBQUMsS0FBS3ZTLElBQU4sRUFBWXdULEdBQVo7SUFMakQsQ0EvQ21GOztJQUFBLGdEQXlHN0UvRCxRQUFELElBQXlDO01BQ3hFLElBQUlnRSxNQUFNLEdBQUdDLFFBQWI7TUFDQSxJQUFJQyxPQUFPLEdBQUdELFFBQWQ7TUFDQSxJQUFJRSxRQUFRLEdBQUcsQ0FBZjtNQUNBLElBQUlDLFNBQVMsR0FBRyxDQUFoQjtNQUVBcEUsUUFBUSxDQUFDcUUsT0FBVCxDQUFrQnZZLE9BQUQsSUFBMkI7UUFBQTs7UUFDMUMsTUFBTWlRLGdCQUFnQixtQkFBR2pRLE9BQU8sQ0FBQzBQLEdBQVgsaURBQUcsYUFBYVEscUJBQWIsRUFBekI7O1FBRUEsSUFBSSxDQUFDRCxnQkFBTCxFQUF1QjtVQUNyQjtRQUNEOztRQUVELElBQUlpSSxNQUFNLEdBQUdqSSxnQkFBZ0IsQ0FBQ25ILEdBQTlCLEVBQW1DO1VBQ2pDb1AsTUFBTSxHQUFHakksZ0JBQWdCLENBQUNuSCxHQUExQjtRQUNEOztRQUVELElBQUlzUCxPQUFPLEdBQUduSSxnQkFBZ0IsQ0FBQ2xILElBQS9CLEVBQXFDO1VBQ25DcVAsT0FBTyxHQUFHbkksZ0JBQWdCLENBQUNsSCxJQUEzQjtRQUNEOztRQUVELElBQUlzUCxRQUFRLEdBQUdwSSxnQkFBZ0IsQ0FBQ3RCLEtBQWhDLEVBQXVDO1VBQ3JDMEosUUFBUSxHQUFHcEksZ0JBQWdCLENBQUN0QixLQUE1QjtRQUNEOztRQUVELElBQUkySixTQUFTLEdBQUdySSxnQkFBZ0IsQ0FBQzlCLE1BQWpDLEVBQXlDO1VBQ3ZDbUssU0FBUyxHQUFHckksZ0JBQWdCLENBQUM5QixNQUE3QjtRQUNEO01BQ0YsQ0F0QkQ7TUF3QkEsT0FBTztRQUNMckYsR0FBRyxFQUFFb1AsTUFEQTtRQUVMblAsSUFBSSxFQUFFcVAsT0FGRDtRQUdMbFQsS0FBSyxFQUFFbVQsUUFBUSxHQUFHRCxPQUhiO1FBSUxqVCxNQUFNLEVBQUVtVCxTQUFTLEdBQUdKO01BSmYsQ0FBUDtJQU1ELENBN0k4Rzs7SUFBQSw4QkEySnhHLENBQUNNLGNBQWMsR0FBRyxLQUFsQixLQUE0QjtNQUNqQyxLQUFLakIsTUFBTCxDQUFZLEtBQUtrQixJQUFMLENBQVVsRixZQUFWLEVBQVo7O01BRUEsSUFBSWlGLGNBQUosRUFBb0I7UUFDbEIxQyxVQUFVLENBQUMsTUFBTTtVQUNmLElBQUksS0FBS3BHLEdBQVQsRUFBYztZQUNaLEtBQUtxRyxZQUFMLENBQWtCLElBQWxCLEVBQXdCLEtBQUtDLGdCQUE3QjtVQUNEO1FBQ0YsQ0FKUyxDQUFWO01BS0Q7SUFDRixDQXJLOEc7O0lBQUEsNkNBdUt4RjFTLE1BQUQsSUFBZ0U7TUFDcEY7TUFFQSxNQUFNb1YsS0FBSyxHQUFHLENBQUMsR0FBRyxLQUFLRCxJQUFMLENBQVV2RSxRQUFkLENBQWQ7O01BQ0EsT0FBT3dFLEtBQUssQ0FBQzNZLE1BQU4sR0FBZSxDQUF0QixFQUF5QjtRQUN2QixNQUFNNFksY0FBYyxHQUFHRCxLQUFLLENBQUNFLEtBQU4sRUFBdkI7O1FBRUEsSUFBSUQsY0FBYyxJQUFJQSxjQUFjLENBQUNqSixHQUFqQyxJQUF3Q2lKLGNBQWMsQ0FBQ2pKLEdBQWYsS0FBdUJwTSxNQUFuRSxFQUEyRTtVQUN6RSxPQUFPcVYsY0FBUDtRQUNEOztRQUVELE1BQU1FLGNBQWMsR0FBR0YsY0FBYyxZQUFZOUUsK0NBQTFCLEdBQXVDOEUsY0FBYyxDQUFDekUsUUFBdEQsR0FBaUUsRUFBeEY7O1FBQ0EsS0FBSyxNQUFNNEUsYUFBWCxJQUE0QkQsY0FBNUIsRUFBNEM7VUFDMUNILEtBQUssQ0FBQzlDLE9BQU4sQ0FBY2tELGFBQWQ7UUFDRDtNQUNGOztNQUVELE9BQU9yWSxTQUFQO0lBQ0QsQ0F6TDhHOztJQUFBLGdDQTJMckdzWSxjQUFELElBQW9DO01BQzNDLEtBQUtySixHQUFMLEdBQVdxSixjQUFYO0lBQ0QsQ0E3TDhHOztJQUFBLGdDQStMckduYSxTQUFELElBQWdDO01BQ3ZDLElBQUksS0FBSzBPLE9BQVQsRUFBa0I7UUFDaEIsS0FBS0EsT0FBTCxDQUFhMEwsa0JBQWIsQ0FBZ0NwYSxTQUFTLENBQUNxYSxPQUExQztRQUNBLEtBQUtDLGVBQUwsQ0FBcUJ0YSxTQUFyQjtNQUNEO0lBQ0YsQ0FwTThHOztJQUFBLHlDQXNNcEZBLFNBQUQsSUFBZ0M7TUFDeEQsS0FBS3NOLFFBQUwsQ0FBZTVJLE1BQWYsR0FBd0IxRSxTQUFTLENBQUNxYSxPQUFsQzs7TUFFQSxJQUFJLEtBQUtFLDBCQUFULEVBQXFDO1FBQ25DLEtBQUtBLDBCQUFMLEdBQWtDLEtBQWxDO1FBQ0E7TUFDRDs7TUFFRCxJQUFJdmEsU0FBUyxDQUFDd2EsS0FBZCxFQUFxQjtRQUNuQixLQUFLeGEsU0FBTCxDQUFleWEsSUFBZixDQUFvQixDQUFDemEsU0FBUyxDQUFDd2EsS0FBWCxDQUFwQjtNQUNELENBRkQsTUFFTztRQUNMLE1BQU1FLENBQUMsR0FBRzFhLFNBQVMsQ0FBQ3FhLE9BQVYsQ0FBa0IvQyxHQUFsQixDQUF1QnFELENBQUQsSUFBTyxLQUFLcE0sbUJBQUwsQ0FBeUJvTSxDQUF6QixDQUE3QixDQUFWO1FBQ0EsS0FBSzNhLFNBQUwsQ0FBZXlhLElBQWYsQ0FBb0JDLENBQXBCO01BQ0Q7SUFDRixDQXBOOEc7O0lBQUEsZ0RBc043RUUsWUFBRCxJQUFvRDtNQUNuRixJQUFJQyxjQUFnQyxHQUFHLEVBQXZDO01BRUEsTUFBTWYsS0FBSyxHQUFHLENBQUMsR0FBR2MsWUFBSixDQUFkOztNQUNBLE9BQU9kLEtBQUssQ0FBQzNZLE1BQU4sR0FBZSxDQUF0QixFQUF5QjtRQUN2QixNQUFNNFksY0FBYyxHQUFHRCxLQUFLLENBQUNFLEtBQU4sRUFBdkI7O1FBRUEsSUFBSUQsY0FBYyxJQUFJQSxjQUFjLENBQUNqSixHQUFyQyxFQUEwQztVQUN4QytKLGNBQWMsQ0FBQ3BaLElBQWYsQ0FBb0JzWSxjQUFjLENBQUNqSixHQUFuQztRQUNEOztRQUVELE1BQU1tSixjQUFjLEdBQUdGLGNBQWMsWUFBWTlFLCtDQUExQixHQUF1QzhFLGNBQWMsQ0FBQ3pFLFFBQXRELEdBQWlFLEVBQXhGOztRQUNBLEtBQUssTUFBTTRFLGFBQVgsSUFBNEJELGNBQTVCLEVBQTRDO1VBQzFDSCxLQUFLLENBQUM5QyxPQUFOLENBQWNrRCxhQUFkO1FBQ0Q7TUFDRjs7TUFFRCxPQUFPVyxjQUFQO0lBQ0QsQ0F4TzhHOztJQUFBLHNDQTBPaEcsQ0FBQ0MsY0FBYyxHQUFHLEtBQWxCLEVBQXlCQyxZQUFZLEdBQUcsSUFBeEMsS0FBaUQ7TUFDOUQsTUFBTUYsY0FBYyxHQUFHLEtBQUtHLHNCQUFMLENBQTRCLEtBQUtuQixJQUFMLENBQVV2RSxRQUF0QyxDQUF2Qjs7TUFFQSxJQUFJd0YsY0FBYyxJQUFJLEtBQUtwTSxPQUEzQixFQUFvQztRQUNsQyxLQUFLQSxPQUFMLENBQWF1TSxPQUFiO01BQ0Q7O01BRUQsS0FBS3ZNLE9BQUwsR0FBZSxJQUFJc0osZ0RBQUosQ0FBWTtRQUN6QnZNLFNBQVMsRUFBRSxLQUFLcUYsR0FEUztRQUV6Qm9LLGlCQUFpQixFQUFFTCxjQUZNO1FBR3pCTSxhQUFhLEVBQUU7TUFIVSxDQUFaLENBQWY7TUFNQSxLQUFLN04sUUFBTCxHQUFnQixJQUFJc0ssaURBQUosQ0FBYSxLQUFLOUcsR0FBbEIsRUFBd0I7UUFDdENzSyxTQUFTLEVBQUVMLFlBRDJCO1FBRXRDTSxTQUFTLEVBQUVOLFlBRjJCO1FBR3RDTyxLQUFLLEVBQUUsQ0FBQ2xPLHNEQUFELEVBQW9CZ0IsMkRBQWtCLENBQUMsSUFBRCxDQUF0QyxDQUgrQjtRQUl0Q3RJLEtBQUssRUFBRTtVQUNMc0gsaUJBQWlCLEVBQUUyTixZQURkO1VBRUwzTSxrQkFBa0IsRUFBRTJNO1FBRmYsQ0FKK0I7UUFRdENRLE1BQU0sRUFBRSxLQVI4QjtRQVN0Q0MsU0FBUyxFQUFFLEtBQUtuYixNQUFMLENBQVlvYjtNQVRlLENBQXhCLEVBV2JDLEVBWGEsQ0FXVixZQVhVLEVBV0sxWCxLQUFELElBQVc7UUFDM0IsS0FBSzBLLE9BQUwsQ0FBY2lOLFdBQWQsQ0FBMEIzWCxLQUFLLENBQUM0WCxVQUFoQyxFQUE0QzVYLEtBQUssQ0FBQzZYLFdBQWxEO01BQ0QsQ0FiYSxFQWNiSCxFQWRhLENBY1YsV0FkVSxFQWNJMVgsS0FBRCxJQUFXO1FBQzFCLE1BQU04WCxlQUFlLEdBQUcsS0FBS3ZOLG1CQUFMLENBQXlCdkssS0FBSyxDQUFDVSxNQUEvQixDQUF4Qjs7UUFDQSxJQUFJb1gsZUFBSixFQUFxQjtVQUNuQkEsZUFBZSxDQUFDck4sUUFBaEIsR0FBMkIsSUFBM0I7UUFDRDtNQUNGLENBbkJhLEVBb0JiaU4sRUFwQmEsQ0FvQlYsTUFwQlUsRUFvQkQxWCxLQUFELElBQVc7UUFDckIsTUFBTThYLGVBQWUsR0FBRyxLQUFLdk4sbUJBQUwsQ0FBeUJ2SyxLQUFLLENBQUNVLE1BQS9CLENBQXhCO1FBQ0FvWCxlQUFlLENBQUVDLFNBQWpCLENBQTJCL1gsS0FBM0I7TUFDRCxDQXZCYSxFQXdCYjBYLEVBeEJhLENBd0JWLFdBeEJVLEVBd0JJbEcsQ0FBRCxJQUFPO1FBQ3RCQSxDQUFDLENBQUNuSSxNQUFGLENBQVNzTSxPQUFULENBQWtCM1YsS0FBRCxJQUFXO1VBQzFCLE1BQU04WCxlQUFlLEdBQUcsS0FBS3ZOLG1CQUFMLENBQXlCdkssS0FBSyxDQUFDVSxNQUEvQixDQUF4QjtVQUNBb1gsZUFBZSxDQUFFQyxTQUFqQixDQUEyQi9YLEtBQTNCO1FBQ0QsQ0FIRDtNQUlELENBN0JhLEVBOEJiMFgsRUE5QmEsQ0E4QlYsU0E5QlUsRUE4QkUxWCxLQUFELElBQVc7UUFDeEIsTUFBTThYLGVBQWUsR0FBRyxLQUFLdk4sbUJBQUwsQ0FBeUJ2SyxLQUFLLENBQUNVLE1BQS9CLENBQXhCOztRQUNBLElBQUlvWCxlQUFKLEVBQXFCO1VBQ25CQSxlQUFlLENBQUNsSiwwQkFBaEI7VUFDQWtKLGVBQWUsQ0FBQ3JOLFFBQWhCLEdBQTJCLEtBQTNCO1FBQ0Q7O1FBRUQsS0FBS3VOLEtBQUwsQ0FBV3ZCLElBQVgsQ0FBZ0J6SSxJQUFJLENBQUNDLEdBQUwsRUFBaEI7TUFDRCxDQXRDYSxFQXVDYnlKLEVBdkNhLENBdUNWLGFBdkNVLEVBdUNNMVgsS0FBRCxJQUFXO1FBQzVCLE1BQU04WCxlQUFlLEdBQUcsS0FBS3ZOLG1CQUFMLENBQXlCdkssS0FBSyxDQUFDVSxNQUEvQixDQUF4Qjs7UUFFQSxJQUFJb1gsZUFBSixFQUFxQjtVQUNuQkEsZUFBZSxDQUFDL00sY0FBaEIscUJBQXNDK00sZUFBZSxDQUFDbGQsT0FBaEIsQ0FBd0JrUSxVQUE5RDtVQUNBZ04sZUFBZSxDQUFDbGQsT0FBaEIsQ0FBd0JrUSxVQUF4QixHQUFxQztZQUNuQ2MsUUFBUSxFQUFFekMsMERBRHlCO1lBRW5Da0QsVUFBVSxFQUFFbkQsNkRBQXlCbEI7VUFGRixDQUFyQztVQUlBOFAsZUFBZSxDQUFDbEosMEJBQWhCO1FBQ0Q7TUFDRixDQWxEYSxFQW1EYjhJLEVBbkRhLENBbURWLFFBbkRVLEVBbURDMVgsS0FBRCxJQUFXO1FBQ3ZCLE1BQU04WCxlQUFlLEdBQUcsS0FBS3ZOLG1CQUFMLENBQXlCdkssS0FBSyxDQUFDVSxNQUEvQixDQUF4QjtRQUNBb1gsZUFBZSxDQUFFRyxXQUFqQixDQUE2QmpZLEtBQTdCO1FBQ0EsS0FBS2dZLEtBQUwsQ0FBV3ZCLElBQVgsQ0FBZ0J6SSxJQUFJLENBQUNDLEdBQUwsRUFBaEIsRUFIdUIsQ0FHTTtNQUM5QixDQXZEYSxFQXdEYnlKLEVBeERhLENBd0RWLGFBeERVLEVBd0RNbEcsQ0FBRCxJQUFPO1FBQ3hCQSxDQUFDLENBQUNuSSxNQUFGLENBQVNzTSxPQUFULENBQWtCM1YsS0FBRCxJQUFXO1VBQzFCLE1BQU04WCxlQUFlLEdBQUcsS0FBS3ZOLG1CQUFMLENBQXlCdkssS0FBSyxDQUFDVSxNQUEvQixDQUF4QjtVQUNBb1gsZUFBZSxDQUFFRyxXQUFqQixDQUE2QmpZLEtBQTdCO1FBQ0QsQ0FIRDtRQUlBLEtBQUtnWSxLQUFMLENBQVd2QixJQUFYLENBQWdCekksSUFBSSxDQUFDQyxHQUFMLEVBQWhCLEVBTHdCLENBS0s7TUFDOUIsQ0E5RGEsRUErRGJ5SixFQS9EYSxDQStEVixXQS9EVSxFQStESTFYLEtBQUQsSUFBVztRQUMxQixNQUFNOFgsZUFBZSxHQUFHLEtBQUt2TixtQkFBTCxDQUF5QnZLLEtBQUssQ0FBQ1UsTUFBL0IsQ0FBeEI7O1FBRUEsSUFBSW9YLGVBQUosRUFBcUI7VUFDbkIsSUFBSUEsZUFBZSxDQUFDL00sY0FBcEIsRUFBb0M7WUFDbEMrTSxlQUFlLENBQUNsZCxPQUFoQixDQUF3QmtRLFVBQXhCLEdBQXFDZ04sZUFBZSxDQUFDL00sY0FBckQ7WUFDQStNLGVBQWUsQ0FBQy9NLGNBQWhCLEdBQWlDbE4sU0FBakM7VUFDRDs7VUFFRGlhLGVBQWUsQ0FBQ2xKLDBCQUFoQjtRQUNEO01BQ0YsQ0ExRWEsQ0FBaEI7TUE0RUEsSUFBSXlILE9BQXdDLEdBQUcsRUFBL0M7TUFDQSxLQUFLM0wsT0FBTCxDQUFjZ04sRUFBZCxDQUFpQixXQUFqQixFQUErQjFYLEtBQUQsSUFBVztRQUN2QyxNQUFNa1ksY0FBYyxHQUFHbFksS0FBSyxDQUFDNFgsVUFBTixDQUFpQmxYLE1BQXhDO1FBRUEsTUFBTXlYLHVCQUF1QixHQUMzQixLQUFLN08sUUFBTCxDQUFlOE8saUJBQWYsQ0FBaUNGLGNBQWpDLEtBQ0E3QixPQUFPLENBQUNnQyxJQUFSLENBQWMzWCxNQUFELElBQVlBLE1BQU0sS0FBS3dYLGNBQVgsSUFBNkJ4WCxNQUFNLENBQUM0WCxRQUFQLENBQWdCSixjQUFoQixDQUF0RCxDQUZGOztRQUlBLElBQUlDLHVCQUFKLEVBQTZCO1VBQzNCO1VBQ0FuWSxLQUFLLENBQUN1WSxJQUFOO1FBQ0Q7TUFDRixDQVhELEVBV0diLEVBWEgsQ0FXTSxXQVhOLEVBV29CMVgsS0FBRCxJQUFXO1FBQzVCcVcsT0FBTyxHQUFHclcsS0FBSyxDQUFDeVgsUUFBaEI7UUFDQSxLQUFLbkIsZUFBTCxDQUFxQjtVQUFFRDtRQUFGLENBQXJCOztRQUVBLElBQUlyVyxLQUFLLENBQUN3WSxXQUFWLEVBQXVCO1VBQ3JCeFksS0FBSyxDQUFDNFgsVUFBTixDQUFpQmxFLGNBQWpCO1VBQ0FSLFVBQVUsQ0FBQyxNQUFNO1lBQ2YsS0FBSzVKLFFBQUwsQ0FBZW1QLFNBQWYsQ0FBeUJ6WSxLQUFLLENBQUM0WCxVQUEvQjtVQUNELENBRlMsQ0FBVjtRQUdEO01BQ0YsQ0FyQkQ7SUFzQkQsQ0ExVjhHOztJQUFBLEtBQTNDakQsTUFBMkMsR0FBM0NBLE1BQTJDO0lBQzdHLEtBQUtrQixJQUFMLEdBQVksS0FBSzZDLElBQUwsQ0FBVS9WLEdBQVYsRUFBZStSLGFBQWYsQ0FBWjtFQUNEOztFQXFCRGdFLElBQUksQ0FBQy9WLEdBQUQsRUFBMEIrUixhQUExQixFQUFrRDtJQUNwRCxLQUFLbUIsSUFBTCxHQUFZLElBQUl0QywrQ0FBSixDQUNWNVEsR0FEVSxhQUNWQSxHQURVLGNBQ1ZBLEdBRFUsR0FDSDtNQUNMcUcsSUFBSSxFQUFFLE9BREQ7TUFFTHNJLFFBQVEsRUFBRSxDQUFDdkksOEVBQUQ7SUFGTCxDQURHLEVBS1YsSUFMVSxFQU1WLEtBQUswSCxJQU5LLENBTUE7SUFOQSxDQUFaO0lBU0EsS0FBSzJDLGdCQUFMLEdBQXdCc0IsYUFBeEI7SUFFQXhCLFVBQVUsQ0FBQyxNQUFNO01BQ2YsSUFBSSxLQUFLcEcsR0FBVCxFQUFjO1FBQ1o7UUFDQSxNQUFNZ0ssY0FBYyxHQUFHcEMsYUFBdkI7UUFDQSxLQUFLdkIsWUFBTCxDQUFrQjJELGNBQWxCLEVBQWtDcEMsYUFBbEM7UUFDQSxLQUFLaUUsWUFBTCxHQUFvQixLQUFLOUMsSUFBekI7UUFDQSxLQUFLN1osU0FBTCxDQUFleWEsSUFBZixDQUFvQixFQUFwQjtNQUNEO0lBQ0YsQ0FSUyxDQUFWO0lBU0EsT0FBTyxLQUFLWixJQUFaO0VBQ0Q7O0VBVUR0RyxVQUFVLENBQUMxTixJQUFELEVBQWtCO0lBQzFCLEtBQUtBLElBQUwsR0FBWUEsSUFBWjtJQUNBLEtBQUtnVSxJQUFMLENBQVV0RyxVQUFWLENBQXFCLEtBQUt5QyxPQUExQjtFQUNEOztFQUVENEcsVUFBVSxDQUFDdFcsS0FBRCxFQUFnQkMsTUFBaEIsRUFBZ0M7SUFBQTs7SUFDeEMsS0FBS0QsS0FBTCxHQUFhQSxLQUFiO0lBQ0EsS0FBS0MsTUFBTCxHQUFjQSxNQUFkO0lBQ0EsS0FBS25HLEtBQUwsR0FBYTtNQUFFa0csS0FBRjtNQUFTQztJQUFULENBQWI7O0lBRUEscUJBQUksS0FBS21JLE9BQVQsMENBQUksY0FBY0Msa0JBQWQsR0FBbUN4TixNQUF2QyxFQUErQztNQUM3QyxLQUFLOFYscUJBQUw7SUFDRDtFQUNGOztFQUVENEYsY0FBYyxHQUFHO0lBQ2YsS0FBSzdjLFNBQUwsQ0FBZThjLElBQWYsQ0FBb0IvRSxzREFBSyxFQUF6QixFQUE2QmdGLFNBQTdCLENBQXdDQyx1QkFBRCxJQUE2QjtNQUFBOztNQUNsRSxNQUFNTCxZQUFZLEdBQUdLLHVCQUF1QixDQUFDLENBQUQsQ0FBdkIsQ0FBMkJuTSxNQUFoRDtNQUVBLE1BQU1vTSxRQUFRLEdBQUcsSUFBSWhJLCtDQUFKLENBQ2Y7UUFDRWpJLElBQUksRUFBRSxPQURSO1FBRUV2SixJQUFJLEVBQUUsS0FBS3lPLGtCQUFMLENBQXdCLElBQXhCLENBRlI7UUFHRW9ELFFBQVEsRUFBRTtNQUhaLENBRGUsRUFNZixJQU5lLEVBT2YwSCx1QkFBdUIsQ0FBQyxDQUFELENBQXZCLENBQTJCbk0sTUFQWixDQUFqQjtNQVVBLE1BQU1xTSxjQUFjLEdBQUcsS0FBS0Msc0JBQUwsQ0FBNEJILHVCQUE1QixDQUF2QjtNQUVBQyxRQUFRLENBQUNyZSxPQUFULENBQWlCcUwsU0FBakIsR0FBNkJpVCxjQUE3QjtNQUVBRix1QkFBdUIsQ0FBQ3JELE9BQXhCLENBQWlDdlksT0FBRCxJQUEyQjtRQUFBOztRQUN6RCxNQUFNaVEsZ0JBQWdCLG9CQUFHalEsT0FBTyxDQUFDMFAsR0FBWCxrREFBRyxjQUFhUSxxQkFBYixFQUF6QjtRQUNBbFEsT0FBTyxDQUFDd1IsMEJBQVIsQ0FBbUN2QixnQkFBbkMsRUFBcUQ2TCxjQUFyRDtRQUNBUCxZQUFZLENBQUNTLFFBQWIsQ0FBc0JySSxnRkFBdEIsRUFBNEMzVCxPQUE1QztRQUNBNmIsUUFBUSxDQUFDRyxRQUFULENBQWtCckksbUZBQWxCLEVBQTJDM1QsT0FBM0MsRUFBb0QsS0FBcEQsRUFBMkQsS0FBM0Q7TUFDRCxDQUxEO01BT0E2YixRQUFRLENBQUNySywwQkFBVCxDQUFvQ3NLLGNBQXBDLHVCQUErRFAsWUFBWSxDQUFDN0wsR0FBNUUsc0RBQStELGtCQUFrQlEscUJBQWxCLEVBQS9EO01BRUFxTCxZQUFZLENBQUNySCxRQUFiLENBQXNCN1QsSUFBdEIsQ0FBMkJ3YixRQUEzQjtNQUVBLEtBQUs5SyxNQUFMLENBQVlDLEdBQVosQ0FBZ0I2SyxRQUFRLENBQUMzYixPQUFULEVBQWhCLEVBQW9DMmIsUUFBcEM7TUFFQSxLQUFLeEksSUFBTDtJQUNELENBL0JEO0VBZ0NEOztFQXdDRHdDLHFCQUFxQixDQUFDc0QsMEJBQTBCLEdBQUcsS0FBOUIsRUFBcUM7SUFBQTs7SUFDeEQsS0FBS0EsMEJBQUwsR0FBa0NBLDBCQUFsQztJQUNBLElBQUl2VyxLQUFpQixHQUFHLElBQUlxWixVQUFKLENBQWUsT0FBZixDQUF4QjtJQUNBLHVCQUFLM08sT0FBTCxrRUFBY2lOLFdBQWQsQ0FBMEIzWCxLQUExQixFQUFpQyxLQUFLOE0sR0FBdEM7RUFDRDs7RUFFRHdNLGtCQUFrQixDQUFDTCxRQUFELEVBQXVCO0lBQ3ZDLEtBQUtOLFlBQUwsR0FBb0JNLFFBQXBCO0lBQ0EsS0FBS2hHLHFCQUFMO0lBQ0EsS0FBS3hDLElBQUw7RUFDRDs7RUFtTUQ3TyxNQUFNLEdBQUc7SUFDUCxNQUFNMlgsa0JBQWtCLEdBQUcsS0FBS0MsY0FBTCxJQUF3QixDQUFDLEtBQUtBLGNBQU4sSUFBd0IsS0FBS3BHLGdCQUFoRjtJQUVBLG9CQUNFO01BQXNCLFNBQVMsRUFBRSxLQUFLL1csTUFBTCxDQUFZb2QsSUFBN0M7TUFBbUQsS0FBSyxFQUFFLEtBQUtyZCxLQUEvRDtNQUFzRSxHQUFHLEVBQUUsS0FBS3NkLE1BQWhGO01BQUEsV0FDRyxLQUFLN0QsSUFBTCxDQUFValUsTUFBVixFQURILEVBRUcyWCxrQkFBa0IsaUJBQ2pCLHdEQUFDLCtDQUFEO1FBQUEsdUJBQ0Usd0RBQUMseUZBQUQ7VUFBbUIsS0FBSyxFQUFFO1FBQTFCO01BREYsRUFISjtJQUFBLEdBQVUsS0FBS2pLLEtBQWYsQ0FERjtFQVVEOztBQWhZZ0I7QUFtWW5CLE1BQU01UCxTQUFTLEdBQUdwRSwwREFBYSxDQUFFZ0IsS0FBRCxLQUEyQjtFQUN6RG1kLElBQUksRUFBRTNlLDZDQUFJO0FBQ1o7QUFDQTtBQUNBLEdBSjJEO0VBS3pEMmMsUUFBUSxFQUFFM2MsNkNBQUk7QUFDaEI7QUFDQTtBQVAyRCxDQUEzQixDQUFELENBQS9COzs7Ozs7Ozs7Ozs7OztBQzVaTyxJQUFLb08sb0JBQVo7O1dBQVlBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0dBQUFBLHlCQUFBQTs7QUFRTCxJQUFLQyxrQkFBWjs7V0FBWUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7R0FBQUEsdUJBQUFBOztBQVFMLElBQUtxRCxtQkFBWjs7V0FBWUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7R0FBQUEsd0JBQUFBOztBQW1CTCxJQUFLbU4sY0FBWjs7V0FBWUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7R0FBQUEsbUJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BEWjtBQUNBO0FBQ0E7QUFFQTtBQUlBOzs7O0FBV08sTUFBTW5GLGlCQUFpQixHQUFHLENBQUM7RUFBRW5LO0FBQUYsQ0FBRCxLQUFzQjtFQUFBOztFQUNyRCxNQUFNLENBQUMyUCxhQUFELEVBQWdCQyxnQkFBaEIsSUFBb0M1YSwrQ0FBUSxDQUFVLEtBQVYsQ0FBbEQ7RUFDQSxNQUFNLENBQUM2YSxXQUFELEVBQWNDLGNBQWQsSUFBZ0M5YSwrQ0FBUSxDQUFjO0lBQUUrYSxDQUFDLEVBQUUsQ0FBTDtJQUFRQyxDQUFDLEVBQUU7RUFBWCxDQUFkLENBQTlDO0VBRUEsTUFBTWhlLE1BQU0sR0FBR3FELFNBQVMsRUFBeEI7RUFFQSxNQUFNNGEsZ0JBQWdCLHFCQUFHalEsS0FBSyxDQUFDSyxPQUFULG1EQUFHLGVBQWVDLGtCQUFmLEVBQXpCO0VBRUEsTUFBTTRQLGlCQUFpQixHQUFHWCxrREFBVyxDQUNsQzVaLEtBQUQsSUFBVztJQUNUQSxLQUFLLENBQUMwVCxjQUFOOztJQUNBLElBQUkxVCxLQUFLLENBQUNJLGFBQVYsRUFBeUI7TUFDdkJpSyxLQUFLLENBQUN6SixNQUFOLENBQWE7UUFBRXlWLE9BQU8sRUFBRSxDQUFDclcsS0FBSyxDQUFDSSxhQUFQO01BQVgsQ0FBYjtJQUNEOztJQUNEK1osY0FBYyxDQUFDO01BQUVDLENBQUMsRUFBRXBhLEtBQUssQ0FBQ3dhLEtBQVg7TUFBa0JILENBQUMsRUFBRXJhLEtBQUssQ0FBQ3lhO0lBQTNCLENBQUQsQ0FBZDtJQUNBUixnQkFBZ0IsQ0FBQyxJQUFELENBQWhCO0VBQ0QsQ0FSa0MsRUFTbkMsQ0FBQzVQLEtBQUQsQ0FUbUMsQ0FBckM7RUFZQXdQLGdEQUFTLENBQUMsTUFBTTtJQUNkLElBQUlTLGdCQUFnQixJQUFJQSxnQkFBZ0IsQ0FBQ25kLE1BQWpCLEtBQTRCLENBQXBELEVBQXVEO01BQ3JELE1BQU1DLE9BQU8sR0FBR2tkLGdCQUFnQixDQUFDLENBQUQsQ0FBaEM7TUFDQWxkLE9BQU8sQ0FBQ3NkLGdCQUFSLENBQXlCLGFBQXpCLEVBQXdDSCxpQkFBeEM7SUFDRDtFQUNGLENBTFEsRUFLTixDQUFDRCxnQkFBRCxFQUFtQkMsaUJBQW5CLENBTE0sQ0FBVDs7RUFPQSxJQUFJLENBQUNELGdCQUFMLEVBQXVCO0lBQ3JCLG9CQUFPLG1IQUFQO0VBQ0Q7O0VBRUQsTUFBTUssZ0JBQWdCLEdBQUcsTUFBTTtJQUM3QlYsZ0JBQWdCLENBQUMsS0FBRCxDQUFoQjtFQUNELENBRkQ7O0VBSUEsTUFBTVcsZUFBZSxHQUFHLE1BQU07SUFDNUIsb0JBQ0U7TUFBQSx3QkFDRSx1REFBQyxpREFBRDtRQUNFLEtBQUssRUFBQyxRQURSO1FBRUUsT0FBTyxFQUFFLE1BQU07VUFDYkMsaUJBQWlCLENBQUM5Six3REFBRCxDQUFqQjtVQUNBNEosZ0JBQWdCO1FBQ2pCLENBTEg7UUFNRSxTQUFTLEVBQUV0ZSxNQUFNLENBQUN5ZTtNQU5wQixFQURGLGVBU0UsdURBQUMsaURBQUQ7UUFDRSxLQUFLLEVBQUMsV0FEUjtRQUVFLE9BQU8sRUFBRSxNQUFNO1VBQ2JELGlCQUFpQixDQUFDOUosMkRBQUQsQ0FBakI7VUFDQTRKLGdCQUFnQjtRQUNqQixDQUxIO1FBTUUsU0FBUyxFQUFFdGUsTUFBTSxDQUFDeWU7TUFOcEIsRUFURixlQWlCRSx1REFBQyxpREFBRDtRQUNFLEtBQUssRUFBQyxnQkFEUjtRQUVFLE9BQU8sRUFBRSxNQUFNO1VBQ2JELGlCQUFpQixDQUFDOUoseURBQUQsQ0FBakI7VUFDQTRKLGdCQUFnQjtRQUNqQixDQUxIO1FBTUUsU0FBUyxFQUFFdGUsTUFBTSxDQUFDeWU7TUFOcEIsRUFqQkYsZUF5QkUsdURBQUMsaURBQUQ7UUFDRSxLQUFLLEVBQUMsY0FEUjtRQUVFLE9BQU8sRUFBRSxNQUFNO1VBQ2JELGlCQUFpQixDQUFDOUosNERBQUQsQ0FBakI7VUFDQTRKLGdCQUFnQjtRQUNqQixDQUxIO1FBTUUsU0FBUyxFQUFFdGUsTUFBTSxDQUFDeWU7TUFOcEIsRUF6QkY7SUFBQSxFQURGO0VBb0NELENBckNEOztFQXVDQSxNQUFNRCxpQkFBaUIsR0FBSUUsVUFBRCxJQUF3QjtJQUNoRDFRLEtBQUssQ0FBQ3JPLFNBQU4sQ0FBZ0I4YyxJQUFoQixDQUFxQi9FLHFEQUFLLEVBQTFCLEVBQThCZ0YsU0FBOUIsQ0FBeUNDLHVCQUFELElBQTZCO01BQ25FLE1BQU1nQyxzQkFBc0IsR0FBR2hDLHVCQUF1QixDQUFDLENBQUQsQ0FBdEQ7TUFDQSxNQUFNTCxZQUFZLEdBQUdxQyxzQkFBc0IsQ0FBQ25PLE1BQTVDOztNQUVBLFFBQVFrTyxVQUFSO1FBQ0UsS0FBS2hLLHdEQUFMO1VBQ0U0SCxZQUFZLENBQUNTLFFBQWIsQ0FBc0JySSx3REFBdEIsRUFBNENpSyxzQkFBNUM7VUFDQTs7UUFDRixLQUFLakssMkRBQUw7VUFDRTRILFlBQVksQ0FBQ1MsUUFBYixDQUFzQnJJLDJEQUF0QixFQUErQ2lLLHNCQUEvQztVQUNBOztRQUNGLEtBQUtqSyx5REFBTDtVQUNFNEgsWUFBWSxDQUFDUyxRQUFiLENBQXNCckkseURBQXRCLEVBQTZDaUssc0JBQTdDO1VBQ0E7O1FBQ0YsS0FBS2pLLDREQUFMO1VBQ0U0SCxZQUFZLENBQUNTLFFBQWIsQ0FBc0JySSw0REFBdEIsRUFBZ0RpSyxzQkFBaEQ7VUFDQTtNQVpKO0lBY0QsQ0FsQkQ7RUFtQkQsQ0FwQkQ7O0VBc0JBLElBQUloQixhQUFKLEVBQW1CO0lBQ2pCLG9CQUNFO01BQ0UsYUFBYSxFQUFHaGEsS0FBRCxJQUFXO1FBQ3hCQSxLQUFLLENBQUMwVCxjQUFOO1FBQ0FpSCxnQkFBZ0I7TUFDakIsQ0FKSDtNQUFBLHVCQU1FLHVEQUFDLG9EQUFEO1FBQ0UsQ0FBQyxFQUFFVCxXQUFXLENBQUNFLENBRGpCO1FBRUUsQ0FBQyxFQUFFRixXQUFXLENBQUNHLENBRmpCO1FBR0UsT0FBTyxFQUFFTSxnQkFIWDtRQUlFLGVBQWUsRUFBRUMsZUFKbkI7UUFLRSxXQUFXLEVBQUU7TUFMZjtJQU5GLEVBREY7RUFnQkQ7O0VBRUQsb0JBQU8sbUhBQVA7QUFDRCxDQXBITTs7QUFzSFAsTUFBTWxiLFNBQVMsR0FBRyxPQUFPO0VBQ3ZCb2IsUUFBUSxFQUFFaGdCLDZDQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUp5QixDQUFQLENBQWxCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6SUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTs7OztBQW1CQSxJQUFJeWdCLGVBQThCLEdBQUcsRUFBckM7QUFDQSxJQUFJQyxpQkFBMEMsR0FBRzNkLFNBQWpEO0FBQ0EsSUFBSTRkLGdCQUFnQixHQUFHLEtBQXZCO0FBRU8sTUFBTUMsa0JBQWtCLEdBQUcsSUFBSTdILCtDQUFKLENBQW1DLENBQW5DLENBQTNCO0FBRUEsTUFBTThILFdBQU4sU0FBMEJWLDRDQUExQixDQUFrRDtFQVV2RHRPLFdBQVcsQ0FBQzdLLEtBQUQsRUFBZTtJQUN4QixNQUFNQSxLQUFOOztJQUR3QixzQ0FSRyxFQVFIOztJQUFBOztJQUFBLDhCQUxYLElBQUlvWiw4Q0FBSixFQUtXOztJQUFBLHFDQUpaLEtBSVk7O0lBQUEsZ0NBSGpCeGIsU0FBUyxDQUFDdkUsOERBQUQsQ0FHUTs7SUFBQSxtQ0FGZDhZLGlGQUFBLEdBQWtDYSxTQUFsQyxLQUFnRGpYLFNBRWxDOztJQUFBLHVDQTBFVGdZLElBQUQsSUFBOEI7TUFDNUMsTUFBTTtRQUFFK0YsZUFBRjtRQUFtQmhoQjtNQUFuQixJQUErQixLQUFLa0gsS0FBMUM7TUFDQThaLGVBQWUsbUJBQ1ZoaEIsT0FEVTtRQUViaWI7TUFGYSxHQUFmO01BS0EsS0FBS2dHLFFBQUwsQ0FBYztRQUFFQyxPQUFPLEVBQUUsS0FBS3RSLEtBQUwsQ0FBV3NSLE9BQVgsR0FBcUI7TUFBaEMsQ0FBZCxFQVA0QyxDQVE1QztJQUNELENBbkZ5Qjs7SUFBQSwrQ0E0SEYsTUFBTTtNQUM1QixJQUFJTCxnQkFBSixFQUFzQjtRQUNwQixLQUFLTSxXQUFMO1FBQ0EsS0FBS0MsY0FBTDtRQUNBO01BQ0Q7O01BRUQsS0FBS0EsY0FBTDtNQUNBLEtBQUtILFFBQUwsQ0FBYztRQUFFSSxjQUFjLEVBQUU7TUFBbEIsQ0FBZDtNQUNBUixnQkFBZ0IsR0FBRyxJQUFuQjtJQUNELENBdEl5Qjs7SUFBQSwrQ0F3SUYsTUFBTTtNQUM1QixLQUFLSSxRQUFMLENBQWM7UUFBRUksY0FBYyxFQUFFO01BQWxCLENBQWQ7TUFDQVIsZ0JBQWdCLEdBQUcsS0FBbkI7SUFDRCxDQTNJeUI7O0lBQUEsd0NBNklULE1BQU07TUFDckJELGlCQUFpQixHQUFHLElBQXBCO01BQ0FFLGtCQUFrQixDQUFDakYsSUFBbkIsQ0FBd0I7UUFBRXlGLEtBQUssRUFBRTtNQUFULENBQXhCO0lBQ0QsQ0FoSnlCOztJQUFBLDBDQWtKUCxNQUFNO01BQ3ZCLG9CQUFPLHVEQUFDLG1EQUFEO1FBQVksT0FBTyxFQUFFLE1BQU0sS0FBS0MscUJBQUw7TUFBM0IsRUFBUDtJQUNELENBcEp5Qjs7SUFFeEIsS0FBSzNSLEtBQUwsR0FBYTtNQUNYc1IsT0FBTyxFQUFFLENBREU7TUFFWEcsY0FBYyxFQUFFO0lBRkwsQ0FBYixDQUZ3QixDQU94QjtJQUNBOztJQUNBLEtBQUs1UixLQUFMLEdBQWEsSUFBSW9LLG9FQUFKLENBQVUsS0FBSzNTLEtBQUwsQ0FBV2xILE9BQVgsQ0FBbUJpYixJQUE3QixFQUFtQyxLQUFLL1QsS0FBTCxDQUFXbEgsT0FBWCxDQUFtQndoQixhQUF0RCxFQUFxRSxLQUFLQyxhQUExRSxDQUFiO0lBQ0EsS0FBS2hTLEtBQUwsQ0FBV3VPLFVBQVgsQ0FBc0I5VyxLQUFLLENBQUNRLEtBQTVCLEVBQW1DUixLQUFLLENBQUNTLE1BQXpDO0lBQ0EsS0FBSzhILEtBQUwsQ0FBV2tGLFVBQVgsQ0FBc0J6TixLQUFLLENBQUNELElBQTVCO0lBRUEsS0FBS3lhLElBQUwsQ0FBVUMsR0FBVixDQUNFLEtBQUt6YSxLQUFMLENBQVcwYSxRQUFYLENBQW9CekQsU0FBcEIsQ0FBOEJxQyxtRUFBOUIsRUFBc0RxQixHQUFELElBQVM7TUFDNUQ7TUFDQSxLQUFLcFMsS0FBTCxDQUFXNEkscUJBQVg7TUFDQSxLQUFLa0oscUJBQUw7SUFDRCxDQUpELENBREY7SUFRQSxLQUFLRyxJQUFMLENBQVVDLEdBQVYsQ0FDRSxLQUFLemEsS0FBTCxDQUFXMGEsUUFBWCxDQUFvQnpELFNBQXBCLENBQThCc0Msa0VBQTlCLEVBQXFEb0IsR0FBRCxJQUFTO01BQzNELElBQUksS0FBSzNhLEtBQUwsQ0FBV0ksRUFBWCxLQUFrQnVhLEdBQUcsQ0FBQ0MsT0FBMUIsRUFBbUM7UUFDakMsS0FBS0MsV0FBTCxHQUFtQixJQUFuQjtNQUNEO0lBQ0YsQ0FKRCxDQURGO0VBT0Q7O0VBRURDLGlCQUFpQixHQUFHO0lBQ2xCcEIsaUJBQWlCLEdBQUcsSUFBcEI7SUFDQUUsa0JBQWtCLENBQUNqRixJQUFuQixDQUF3QjtNQUFFeUYsS0FBSyxFQUFFO0lBQVQsQ0FBeEI7SUFFQSxLQUFLVyxZQUFMLEdBQW9CLEtBQUs3SyxPQUF6Qjs7SUFDQSxJQUFJLEtBQUs2SyxZQUFMLENBQWtCQyxxQkFBdEIsRUFBNkM7TUFDM0MsS0FBS0QsWUFBTCxDQUFrQkMscUJBQWxCLENBQXdDO1FBQ3RDelMsS0FBSyxFQUFFLEtBQUtBLEtBRDBCO1FBRXRDMFMsS0FBSyxFQUFFLEtBQUsxUyxLQUFMLENBQVd3TDtNQUZvQixDQUF4QztNQUtBLEtBQUt5RyxJQUFMLENBQVVDLEdBQVYsQ0FDRSxLQUFLbFMsS0FBTCxDQUFXck8sU0FBWCxDQUFxQitjLFNBQXJCLENBQStCO1FBQzdCdEMsSUFBSSxFQUFHN1ksQ0FBRCxJQUFPO1VBQ1gsS0FBS2lmLFlBQUwsQ0FBa0JDLHFCQUFsQixDQUF5QztZQUN2Q3pTLEtBQUssRUFBRSxLQUFLQSxLQUQyQjtZQUV2Q29OLFFBQVEsRUFBRTdaLENBRjZCO1lBR3ZDbWYsS0FBSyxFQUFFLEtBQUsxUyxLQUFMLENBQVd3TDtVQUhxQixDQUF6QztVQU1BMkYsaUJBQWlCLEdBQUcsSUFBcEI7VUFDQUUsa0JBQWtCLENBQUNqRixJQUFuQixDQUF3QjtZQUFFeUYsS0FBSyxFQUFFO1VBQVQsQ0FBeEI7VUFFQVgsZUFBZSxDQUFDNUYsT0FBaEIsQ0FBeUJxSCxjQUFELElBQW9CO1lBQzFDLElBQUlBLGNBQWMsS0FBS3hCLGlCQUF2QixFQUEwQztjQUN4Q3dCLGNBQWMsQ0FBQzNTLEtBQWYsQ0FBcUI0SSxxQkFBckIsQ0FBMkMsSUFBM0M7WUFDRDtVQUNGLENBSkQ7UUFLRDtNQWhCNEIsQ0FBL0IsQ0FERjtJQW9CRDs7SUFFRHNJLGVBQWUsQ0FBQzlkLElBQWhCLENBQXFCLElBQXJCO0VBQ0Q7O0VBRUR3ZixvQkFBb0IsR0FBRztJQUNyQixLQUFLWCxJQUFMLENBQVVZLFdBQVY7SUFDQXpCLGdCQUFnQixHQUFHLEtBQW5CO0lBQ0FGLGVBQWUsR0FBR0EsZUFBZSxDQUFDaEssTUFBaEIsQ0FBd0I0TCxFQUFEO01BQUE7O01BQUEsT0FBUUEsRUFBRSxDQUFDcmIsS0FBSCxDQUFTSSxFQUFULDRCQUFnQnNaLGlCQUFoQix1REFBZ0IsbUJBQW1CMVosS0FBbkIsQ0FBeUJJLEVBQXpDLENBQVI7SUFBQSxDQUF2QixDQUFsQjtFQUNELENBaEZzRCxDQWtGdkQ7RUFDQTs7O0VBWUFrYixxQkFBcUIsQ0FBQ0MsU0FBRCxFQUFtQkMsU0FBbkIsRUFBcUM7SUFDeEQsTUFBTTtNQUFFaGIsS0FBRjtNQUFTQyxNQUFUO01BQWlCVjtJQUFqQixJQUEwQixLQUFLQyxLQUFyQztJQUNBLElBQUl5YixPQUFPLEdBQUcsS0FBZDs7SUFFQSxJQUFJamIsS0FBSyxLQUFLK2EsU0FBUyxDQUFDL2EsS0FBcEIsSUFBNkJDLE1BQU0sS0FBSzhhLFNBQVMsQ0FBQzlhLE1BQXRELEVBQThEO01BQzVELEtBQUs4SCxLQUFMLENBQVd1TyxVQUFYLENBQXNCeUUsU0FBUyxDQUFDL2EsS0FBaEMsRUFBdUMrYSxTQUFTLENBQUM5YSxNQUFqRDtNQUNBZ2IsT0FBTyxHQUFHLElBQVY7SUFDRDs7SUFDRCxJQUFJMWIsSUFBSSxLQUFLd2IsU0FBUyxDQUFDeGIsSUFBdkIsRUFBNkI7TUFDM0IsS0FBS3dJLEtBQUwsQ0FBV2tGLFVBQVgsQ0FBc0I4TixTQUFTLENBQUN4YixJQUFoQztNQUNBMGIsT0FBTyxHQUFHLElBQVY7SUFDRDs7SUFFRCxJQUFJLEtBQUsvUyxLQUFMLENBQVdzUixPQUFYLEtBQXVCd0IsU0FBUyxDQUFDeEIsT0FBckMsRUFBOEM7TUFDNUN5QixPQUFPLEdBQUcsSUFBVjtJQUNEOztJQUVELElBQUksS0FBSy9TLEtBQUwsQ0FBV3lSLGNBQVgsS0FBOEJxQixTQUFTLENBQUNyQixjQUE1QyxFQUE0RDtNQUMxRHNCLE9BQU8sR0FBRyxJQUFWO0lBQ0QsQ0FuQnVELENBcUJ4RDs7O0lBQ0EsTUFBTUMseUJBQXlCLEdBQUcsS0FBS2IsV0FBTCxJQUFvQixLQUFLN2EsS0FBTCxDQUFXbEgsT0FBWCxLQUF1QnlpQixTQUFTLENBQUN6aUIsT0FBdkY7SUFDQSxNQUFNNmlCLHFCQUFxQixHQUFHLEtBQUszYixLQUFMLENBQVdsSCxPQUFYLENBQW1Cd2hCLGFBQW5CLEtBQXFDaUIsU0FBUyxDQUFDemlCLE9BQVYsQ0FBa0J3aEIsYUFBckY7O0lBQ0EsSUFBSW9CLHlCQUF5QixJQUFJQyxxQkFBakMsRUFBd0Q7TUFDdEQsS0FBS2QsV0FBTCxHQUFtQixLQUFuQjtNQUNBLEtBQUt0UyxLQUFMLENBQVdxTyxJQUFYLENBQWdCMkUsU0FBUyxDQUFDemlCLE9BQVYsQ0FBa0JpYixJQUFsQyxFQUF3Q3dILFNBQVMsQ0FBQ3ppQixPQUFWLENBQWtCd2hCLGFBQTFEO01BQ0EsS0FBSy9SLEtBQUwsQ0FBV3VPLFVBQVgsQ0FBc0J5RSxTQUFTLENBQUMvYSxLQUFoQyxFQUF1QythLFNBQVMsQ0FBQzlhLE1BQWpEO01BQ0EsS0FBSzhILEtBQUwsQ0FBV2tGLFVBQVgsQ0FBc0I4TixTQUFTLENBQUN4YixJQUFoQztNQUNBMGIsT0FBTyxHQUFHLElBQVY7O01BRUEsSUFBSUUscUJBQXFCLElBQUksS0FBSzNiLEtBQUwsQ0FBV2xILE9BQVgsQ0FBbUJ3aEIsYUFBaEQsRUFBK0Q7UUFBQTs7UUFDN0QsNEJBQUsvUixLQUFMLENBQVdLLE9BQVgsNEVBQW9CdU0sT0FBcEI7TUFDRDtJQUNGOztJQUVELE9BQU9zRyxPQUFQO0VBQ0Q7O0VBNEJEM2IsTUFBTSxHQUFHO0lBQ1Asb0JBQ0U7TUFBQSxXQUNHLEtBQUt5SSxLQUFMLENBQVd6SSxNQUFYLEVBREgsRUFFRyxLQUFLRSxLQUFMLENBQVdsSCxPQUFYLENBQW1Cd2hCLGFBQW5CLElBQW9DLENBQUMsS0FBS3pjLFNBQTFDLGlCQUNDO1FBQUEsd0JBQ0U7VUFBSyxTQUFTLEVBQUUsS0FBS3RELE1BQUwsQ0FBWXFoQixnQkFBNUI7VUFBQSx1QkFDRSx1REFBQywrQ0FBRDtZQUNFLElBQUksRUFBQyxJQURQO1lBRUUsT0FBTyxFQUFDLFdBRlY7WUFHRSxJQUFJLEVBQUMsTUFIUDtZQUlFLHNCQUFvQixLQUFLNWIsS0FBTCxDQUFXSSxFQUpqQztZQUtFLE9BQU8sRUFBRSxLQUFLeWI7VUFMaEI7UUFERixFQURGLEVBVUcsS0FBS25ULEtBQUwsQ0FBV3lSLGNBQVgsSUFBNkIsS0FBSzJCLGdCQUFMLEVBVmhDO01BQUEsRUFISjtJQUFBLEVBREY7RUFtQkQ7O0FBcExzRDs7Z0JBQTVDakMsNEJBQ1VSOztBQXNMdkIsTUFBTXpiLFNBQVMsR0FBR3BFLDBEQUFhLENBQUVnQixLQUFELEtBQTBCO0VBQ3hEb2hCLGdCQUFnQixFQUFFNWlCLDZDQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOMEQsQ0FBMUIsQ0FBRCxDQUEvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7OztBQU1BLE1BQU1takIsUUFBUSxHQUFHLEVBQWpCO0FBRU8sTUFBTTNDLFVBQVUsR0FBRyxDQUFDO0VBQUU0QztBQUFGLENBQUQsS0FBd0I7RUFDaEQsTUFBTUMsYUFBYSxHQUFHQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsc0JBQXZCLEVBQWdEL1EscUJBQWhELEVBQXRCO0VBQ0EsTUFBTWdSLEdBQUcsR0FBR1QsNkNBQU0sQ0FBaUIsSUFBakIsQ0FBbEI7RUFDQSxNQUFNeGhCLE1BQU0sR0FBRzhHLHVEQUFVLENBQUN6RCxTQUFELENBQXpCO0VBQ0EsTUFBTTZlLGFBQWEsR0FBRyxpQkFBdEI7RUFFQSxNQUFNQyxtQkFBbUIsR0FBRztJQUFFbGMsS0FBSyxFQUFFLEdBQVQ7SUFBY0MsTUFBTSxFQUFFO0VBQXRCLENBQTVCO0VBQ0EsTUFBTWtjLFFBQVEsR0FBR04sYUFBYSxDQUFDL0QsQ0FBZCxHQUFrQjZELFFBQW5DO0VBQ0EsTUFBTVMsUUFBUSxHQUFHUCxhQUFhLENBQUM5RCxDQUFkLEdBQWtCbUUsbUJBQW1CLENBQUNqYyxNQUF2RDtFQUVBLE1BQU1vYyxjQUFjLEdBQUdaLGdFQUFBLENBQWdCUSxhQUFoQixFQUErQjtJQUNwRG5FLENBQUMsRUFBRXFFLFFBRGlEO0lBRXBEcEUsQ0FBQyxFQUFFcUUsUUFGaUQ7SUFHcERHLENBQUMsRUFBRUwsbUJBQW1CLENBQUNsYyxLQUg2QjtJQUlwRHdjLENBQUMsRUFBRU4sbUJBQW1CLENBQUNqYztFQUo2QixDQUEvQixDQUF2QjtFQU1BLE1BQU0sQ0FBQ3djLFlBQUQsRUFBZUMsZUFBZixJQUFrQzNmLCtDQUFRLENBQWU7SUFBRWlELEtBQUssRUFBRXFjLGNBQWMsQ0FBQ0UsQ0FBeEI7SUFBMkJ0YyxNQUFNLEVBQUVvYyxjQUFjLENBQUNHO0VBQWxELENBQWYsQ0FBaEQ7RUFDQSxNQUFNLENBQUM3WSxTQUFELEVBQVlnWixZQUFaLElBQTRCNWYsK0NBQVEsQ0FBQztJQUFFK2EsQ0FBQyxFQUFFdUUsY0FBYyxDQUFDdkUsQ0FBcEI7SUFBdUJDLENBQUMsRUFBRXNFLGNBQWMsQ0FBQ3RFO0VBQXpDLENBQUQsQ0FBMUM7O0VBRUEsTUFBTTZFLFVBQVUsR0FBRyxDQUFDbGYsS0FBRCxFQUFhbWYsV0FBYixLQUFrQztJQUNuRCxJQUFJL0UsQ0FBQyxHQUFHK0UsV0FBVyxDQUFDL0UsQ0FBWixHQUFnQixDQUFoQixHQUFvQixDQUFwQixHQUF3QitFLFdBQVcsQ0FBQy9FLENBQTVDO0lBQ0EsSUFBSUMsQ0FBQyxHQUFHOEUsV0FBVyxDQUFDOUUsQ0FBWixHQUFnQixDQUFoQixHQUFvQixDQUFwQixHQUF3QjhFLFdBQVcsQ0FBQzlFLENBQTVDO0lBRUE0RSxZQUFZLENBQUM7TUFBRTdFLENBQUMsRUFBRUEsQ0FBTDtNQUFRQyxDQUFDLEVBQUVBO0lBQVgsQ0FBRCxDQUFaO0lBQ0ErRSxXQUFXLENBQUNoRixDQUFELEVBQUlDLENBQUosRUFBTzBFLFlBQVksQ0FBQ3pjLEtBQXBCLEVBQTJCeWMsWUFBWSxDQUFDeGMsTUFBeEMsQ0FBWDtFQUNELENBTkQ7O0VBUUEsTUFBTThjLFlBQVksR0FBRyxDQUFDcmYsS0FBRCxFQUF3QzZCLElBQXhDLEtBQXFFO0lBQ3hGLE1BQU07TUFBRWdHO0lBQUYsSUFBV2hHLElBQWpCO0lBQ0FtZCxlQUFlLENBQUM7TUFBRTFjLEtBQUssRUFBRXVGLElBQUksQ0FBQ3ZGLEtBQWQ7TUFBcUJDLE1BQU0sRUFBRXNGLElBQUksQ0FBQ3RGO0lBQWxDLENBQUQsQ0FBZjtJQUNBNmMsV0FBVyxDQUFDblosU0FBUyxDQUFDbVUsQ0FBWCxFQUFjblUsU0FBUyxDQUFDb1UsQ0FBeEIsRUFBMkJ4UyxJQUFJLENBQUN2RixLQUFoQyxFQUF1Q3VGLElBQUksQ0FBQ3RGLE1BQTVDLENBQVg7RUFDRCxDQUpEOztFQU1BLE1BQU02YyxXQUFXLEdBQUcsQ0FBQ2hGLENBQUQsRUFBWUMsQ0FBWixFQUF1Qi9YLEtBQXZCLEVBQXNDQyxNQUF0QyxLQUF5RDtJQUMzRXdiLGdFQUFBLENBQWdCUSxhQUFoQixFQUErQjtNQUFFbkUsQ0FBQyxFQUFFQSxDQUFMO01BQVFDLENBQUMsRUFBRUEsQ0FBWDtNQUFjd0UsQ0FBQyxFQUFFdmMsS0FBakI7TUFBd0J3YyxDQUFDLEVBQUV2YztJQUEzQixDQUEvQjtFQUNELENBRkQ7O0VBSUEsb0JBQ0UsdURBQUMsK0NBQUQ7SUFBQSx1QkFDRTtNQUFLLFNBQVMsRUFBRWxHLE1BQU0sQ0FBQ2tqQixnQkFBdkI7TUFBQSx1QkFDRSx1REFBQyx3REFBRDtRQUFXLE1BQU0sRUFBQyxRQUFsQjtRQUEyQixNQUFNLEVBQUVMLFVBQW5DO1FBQStDLFFBQVEsRUFBRTtVQUFFOUUsQ0FBQyxFQUFFblUsU0FBUyxDQUFDbVUsQ0FBZjtVQUFrQkMsQ0FBQyxFQUFFcFUsU0FBUyxDQUFDb1U7UUFBL0IsQ0FBekQ7UUFBQSx1QkFDRSx1REFBQyxzREFBRDtVQUFXLE1BQU0sRUFBRTBFLFlBQVksQ0FBQ3hjLE1BQWhDO1VBQXdDLEtBQUssRUFBRXdjLFlBQVksQ0FBQ3pjLEtBQTVEO1VBQW1FLFFBQVEsRUFBRStjLFlBQTdFO1VBQUEsdUJBQ0U7WUFDRSxTQUFTLEVBQUVoakIsTUFBTSxDQUFDbWpCLHFCQURwQjtZQUVFLEtBQUssRUFBRTtjQUFFamQsTUFBTSxFQUFHLEdBQUV3YyxZQUFZLENBQUN4YyxNQUFPLElBQWpDO2NBQXNDRCxLQUFLLEVBQUcsR0FBRXljLFlBQVksQ0FBQ3pjLEtBQU07WUFBbkUsQ0FGVDtZQUdFLEdBQUcsRUFBRWdjLEdBSFA7WUFBQSx3QkFLRTtjQUFRLFNBQVMsRUFBRWppQixNQUFNLENBQUNvakIsa0JBQTFCO2NBQUEsd0JBQ0U7Z0JBQUssU0FBUyxFQUFFcGpCLE1BQU0sQ0FBQzRCO2NBQXZCLEVBREYsK0JBRUU7Z0JBQUE7Y0FBQSxFQUZGLGdCQUdFLHVEQUFDLG1EQUFEO2dCQUFZLElBQUksRUFBQyxPQUFqQjtnQkFBeUIsSUFBSSxFQUFDLElBQTlCO2dCQUFtQyxTQUFTLEVBQUU1QixNQUFNLENBQUNxakIsaUJBQXJEO2dCQUF3RSxPQUFPLEVBQUV4QjtjQUFqRixFQUhGO1lBQUEsRUFMRixlQVVFO2NBQUssU0FBUyxFQUFFN2hCLE1BQU0sQ0FBQ3NqQiwwQkFBdkI7Y0FBQSx1QkFDRTtnQkFBSyxTQUFTLEVBQUV0akIsTUFBTSxDQUFDdWpCLG1CQUF2QjtnQkFBQSw2REFDRSx1REFBQywyREFBRCxLQURGO2NBQUE7WUFERixFQVZGO1VBQUE7UUFERjtNQURGO0lBREY7RUFERixFQURGO0FBMEJELENBL0RNOztBQWlFUCxNQUFNbGdCLFNBQVMsR0FBSXBELEtBQUQsS0FBMkI7RUFDM0NrakIscUJBQXFCLEVBQUUxa0IsNkNBQUk7QUFDN0I7QUFDQTtBQUNBLGtCQUFrQndCLEtBQUssQ0FBQ3VqQixFQUFOLENBQVNsaEIsTUFBVCxDQUFnQm1oQixPQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEdBUjZDO0VBUzNDUCxnQkFBZ0IsRUFBRXprQiw2Q0FBSTtBQUN4QjtBQUNBO0FBQ0EsR0FaNkM7RUFhM0Mya0Isa0JBQWtCLEVBQUUza0IsNkNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCd0IsS0FBSyxDQUFDcUMsTUFBTixDQUFhb0osVUFBYixDQUF3QmdZLE1BQU87QUFDakQsd0JBQXdCempCLEtBQUssQ0FBQ3FDLE1BQU4sQ0FBYUYsTUFBYixDQUFvQnVoQixJQUFLO0FBQ2pEO0FBQ0E7QUFDQSxHQXJCNkM7RUFzQjNDSixtQkFBbUIsRUFBRTlrQiw2Q0FBSTtBQUMzQjtBQUNBO0FBQ0EsR0F6QjZDO0VBMEIzQzRrQixpQkFBaUIsRUFBRTVrQiw2Q0FBSTtBQUN6QjtBQUNBLEdBNUI2QztFQTZCM0NtRCxXQUFXLEVBQUVuRCw2Q0FBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBbEM2QztFQW1DM0M2a0IsMEJBQTBCLEVBQUU3a0IsNkNBQUk7QUFDbEM7QUFDQTtBQXJDNkMsQ0FBM0IsQ0FBbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFTyxNQUFNa2pCLGNBQWMsR0FBRyxNQUFNO0VBQUE7O0VBQ2xDLE1BQU0wQyxXQUFXLEdBQUdOLHNEQUFhLENBQUMxRSw0REFBRCxDQUFqQztFQUNBLE1BQU1pRixhQUFhLEdBQUdELFdBQUgsYUFBR0EsV0FBSCxnREFBR0EsV0FBVyxDQUFFeEUsS0FBYixDQUFtQmxLLE9BQXRCLDBEQUFHLHNCQUE0QjJPLGFBQWxEO0VBRUEsTUFBTUMsSUFBSSxHQUFHVCw4Q0FBTyxDQUFDLE1BQU07SUFDekIsTUFBTTNWLEtBQW9CLEdBQUdtVyxhQUE3Qjs7SUFDQSxJQUFJLENBQUNuVyxLQUFMLEVBQVk7TUFDVixPQUFPLElBQUk2VixzSUFBSixDQUFrQztRQUFFbmUsRUFBRSxFQUFFLE1BQU47UUFBYzJlLEtBQUssRUFBRTtNQUFyQixDQUFsQyxDQUFQO0lBQ0Q7O0lBRUQsTUFBTUMsUUFBUSxHQUFHLENBQUNoZSxPQUFELEVBQTBDa1AsT0FBMUMsS0FBa0Y7TUFDakdsUCxPQUFPLENBQUNpZSxnQkFBUixDQUF5Qk4sbUVBQWMsQ0FBQ0UsYUFBRCxDQUF2QztNQUVBLE1BQU0za0IsU0FBUyxHQUFHd08sS0FBSyxDQUFDaU4sUUFBeEI7O01BQ0EsSUFBSSxDQUFBemIsU0FBUyxTQUFULElBQUFBLFNBQVMsV0FBVCxZQUFBQSxTQUFTLENBQUVtQixNQUFYLE1BQXNCLENBQTFCLEVBQTZCO1FBQzNCLE1BQU1DLE9BQU8sR0FBR3BCLFNBQVMsQ0FBQyxDQUFELENBQXpCOztRQUNBLElBQUksRUFBRW9CLE9BQU8sWUFBWTZULHlFQUFyQixDQUFKLEVBQXNDO1VBQ3BDbk8sT0FBTyxDQUFDaWUsZ0JBQVIsQ0FDRVAsdUVBQWdCLENBQUM7WUFDZnpkLFFBQVEsRUFBRSxDQUFFLHFCQUFvQjNGLE9BQU8sQ0FBQ3hDLE9BQVIsQ0FBZ0I2RSxJQUFLLEdBQTNDLENBREs7WUFFZnJDLE9BRmU7WUFHZmlOLEtBQUssRUFBRUcsS0FBSyxDQUFDSDtVQUhFLENBQUQsQ0FEbEI7UUFPRDtNQUNGO0lBQ0YsQ0FoQkQ7O0lBa0JBLE9BQU8yVyxnQ0FBZ0MsQ0FBQyxFQUFELEVBQUtGLFFBQUwsQ0FBdkM7RUFDRCxDQXpCbUIsRUF5QmpCLENBQUNILGFBQUQsQ0F6QmlCLENBQXBCO0VBMkJBLG9CQUNFO0lBQUEsd0JBQ0U7TUFBQSxVQUFNQyxJQUFJLENBQUNLLEtBQUwsQ0FBVzNOLEdBQVgsQ0FBZ0IxVixDQUFELElBQU9BLENBQUMsQ0FBQ2dFLE1BQUYsRUFBdEI7SUFBTixFQURGLGVBRUU7TUFBQSxVQUNHZ2YsSUFBSSxDQUFDTSxVQUFMLENBQWdCNU4sR0FBaEIsQ0FBcUJsQixDQUFELElBQU87UUFDMUIsb0JBQ0U7VUFBQSx3QkFDRTtZQUFBLFVBQUtBLENBQUMsQ0FBQ3RRLEtBQUYsQ0FBUStlO1VBQWIsRUFERixlQUVFO1lBQUEsVUFBTXpPLENBQUMsQ0FBQzZPLEtBQUYsQ0FBUTNOLEdBQVIsQ0FBYW9ELENBQUQsSUFBT0EsQ0FBQyxDQUFDOVUsTUFBRixFQUFuQjtVQUFOLEVBRkY7UUFBQSxHQUFVd1EsQ0FBQyxDQUFDdFEsS0FBRixDQUFRSSxFQUFsQixDQURGO01BTUQsQ0FQQTtJQURILEVBRkY7RUFBQSxFQURGO0FBZUQsQ0E5Q00sRUFnRFA7O0FBQ0EsU0FBUzhlLGdDQUFULENBQ0VsZixLQURGLEVBRUVnZixRQUZGLEVBR2lDO0VBQy9CLE1BQU05TyxPQUFnRCxHQUFHO0lBQ3ZEblEsSUFBSSxFQUFFQyxLQUFLLENBQUNxZixLQUQyQztJQUV2RHZtQixPQUFPLEVBQUVrSCxLQUFLLENBQUNsSDtFQUZ3QyxDQUF6RDtFQUtBLE1BQU1pYixJQUFJLEdBQUcsSUFBSXdLLHNJQUFKLENBQWtDO0lBQUVuZSxFQUFFLEVBQUUsTUFBTjtJQUFjMmUsS0FBSyxFQUFFO0VBQXJCLENBQWxDLENBQWI7O0VBQ0EsTUFBTU8sc0JBQXNCLEdBQUlDLGFBQUQsSUFBNkQ7SUFDMUYsSUFBSUEsYUFBSixhQUFJQSxhQUFKLGVBQUlBLGFBQWEsQ0FBRWxrQixNQUFuQixFQUEyQjtNQUN6QixNQUFNc0QsR0FBRyxHQUFHNGdCLGFBQWEsQ0FBQyxDQUFELENBQXpCO01BQ0EsSUFBSUMsR0FBRyxHQUFHekwsSUFBSSxDQUFDcUwsVUFBTCxDQUFnQkssSUFBaEIsQ0FBc0IzakIsQ0FBRCxJQUFPQSxDQUFDLENBQUNrRSxLQUFGLENBQVFJLEVBQVIsS0FBZXpCLEdBQTNDLENBQVY7O01BQ0EsSUFBSSxDQUFDNmdCLEdBQUwsRUFBVTtRQUNSQSxHQUFHLEdBQUcsSUFBSWpCLHNJQUFKLENBQWtDO1VBQUVuZSxFQUFFLEVBQUV6QixHQUFOO1VBQVdvZ0IsS0FBSyxFQUFFcGdCO1FBQWxCLENBQWxDLENBQU47UUFDQW9WLElBQUksQ0FBQ3FMLFVBQUwsQ0FBZ0J6akIsSUFBaEIsQ0FBcUI2akIsR0FBckI7TUFDRDs7TUFDRCxPQUFPQSxHQUFQO0lBQ0Q7O0lBQ0QsT0FBT3pMLElBQVA7RUFDRCxDQVhEOztFQWFBLE1BQU0yTCxNQUF5QixHQUFHO0lBQ2hDQyxRQUFRLEVBQUd4ZSxJQUFELElBQWtCaWQsMkNBQVMsQ0FBQ3BlLEtBQUssQ0FBQ2xILE9BQVAsRUFBZ0JxSSxJQUFoQixDQURMO0lBRWhDdEksUUFBUSxFQUFFLENBQUNzSSxJQUFELEVBQWU1QyxLQUFmLEtBQThCO01BQ3RDeUIsS0FBSyxDQUFDbkgsUUFBTixDQUFlNGxCLHVHQUFrQixDQUFDemUsS0FBSyxDQUFDbEgsT0FBUCxFQUF1QnFJLElBQXZCLEVBQTZCNUMsS0FBN0IsQ0FBakM7SUFDRDtFQUorQixDQUFsQyxDQXBCK0IsQ0EyQi9COztFQUNBaWdCLDJIQUFvQixDQUFDUSxRQUFELEVBQVdVLE1BQVgsRUFBbUJKLHNCQUFuQixFQUEyQ3BQLE9BQTNDLENBQXBCO0VBQ0EsT0FBTzZELElBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEdEO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQU9BLE1BQU1vTSxtQkFBbUYsR0FBRztFQUMxRnZiLFFBQVEsRUFBRTtBQURnRixDQUE1RjtBQUlPLE1BQU1oRixPQUFPLEdBQUcsQ0FBQ00sR0FBRCxFQUF1QmtnQixNQUFNLEdBQUcsS0FBaEMsS0FBMEM7RUFDL0QsSUFBSWxnQixHQUFKLEVBQVM7SUFBQTs7SUFDUDJmLCtEQUFhLEdBQ1ZRLEtBREgsQ0FDUztNQUNMQyxHQUFHLEVBQUVwZ0IsR0FBRyxDQUFDcWdCLFFBREo7TUFFTEMsTUFBTSxFQUFFLE1BRkg7TUFHTHpnQixJQUFJLGVBQUVHLEdBQUcsQ0FBQ0gsSUFBTixpREFBYztJQUhiLENBRFQsRUFNR2tYLFNBTkgsQ0FNYTtNQUNUd0osS0FBSyxFQUFHQSxLQUFELElBQWdCO1FBQ3JCLElBQUlMLE1BQUosRUFBWTtVQUNWRix5REFBQSxDQUFlTiwrREFBZixFQUFxQyxDQUFDLHNCQUFELEVBQXlCeGEsSUFBSSxDQUFDQyxTQUFMLENBQWVvYixLQUFmLENBQXpCLENBQXJDO1VBQ0E1USxPQUFPLENBQUM0USxLQUFSLENBQWNBLEtBQWQ7UUFDRDtNQUNGLENBTlE7TUFPVEcsUUFBUSxFQUFFLE1BQU07UUFDZCxJQUFJUixNQUFKLEVBQVk7VUFDVkYseURBQUEsQ0FBZU4saUVBQWYsRUFBdUMsQ0FBQyxpQkFBRCxDQUF2QztRQUNEO01BQ0Y7SUFYUSxDQU5iO0VBbUJEO0FBQ0YsQ0F0Qk07QUF3QkEsTUFBTWpnQixTQUE2RCxHQUFJSyxLQUFELElBQVc7RUFBQTs7RUFDdEYsTUFBTTtJQUFFekIsS0FBRjtJQUFTMlIsT0FBVDtJQUFrQnJYO0VBQWxCLElBQStCbUgsS0FBckM7RUFDQSxNQUFNOGdCLFVBQVUsR0FBRyxDQUFuQjtFQUVBLE1BQU1DLGdCQUFnQixHQUFHakosa0RBQVcsQ0FDakN5SSxRQUFELElBQWM7SUFDWjFuQixRQUFRLG1CQUNIMEYsS0FERztNQUVOZ2lCO0lBRk0sR0FBUjtFQUlELENBTmlDLEVBT2xDLENBQUMxbkIsUUFBRCxFQUFXMEYsS0FBWCxDQVBrQyxDQUFwQztFQVVBLE1BQU15aUIsWUFBWSxHQUFHbEosa0RBQVcsQ0FDN0IvWCxJQUFELElBQVU7SUFDUmxILFFBQVEsbUJBQ0gwRixLQURHO01BRU53QjtJQUZNLEdBQVI7RUFJRCxDQU42QixFQU85QixDQUFDbEgsUUFBRCxFQUFXMEYsS0FBWCxDQVA4QixDQUFoQzs7RUFVQSxNQUFNMGlCLFVBQVUsR0FBSWxoQixJQUFELElBQWtCO0lBQ25DLElBQUk7TUFDRixNQUFNbWhCLElBQUksR0FBRzliLElBQUksQ0FBQytiLEtBQUwsQ0FBV3BoQixJQUFYLENBQWI7TUFDQSxvQkFBTyx1REFBQyxzREFBRDtRQUFlLElBQUksRUFBRW1oQjtNQUFyQixFQUFQO0lBQ0QsQ0FIRCxDQUdFLE9BQU9ULEtBQVAsRUFBYztNQUNkLElBQUlBLEtBQUssWUFBWVcsS0FBckIsRUFBNEI7UUFDMUIsT0FBUSwwQkFBeUJYLEtBQUssQ0FBQ1ksT0FBUSxFQUEvQztNQUNELENBRkQsTUFFTztRQUNMLE9BQU8sdUJBQVA7TUFDRDtJQUNGO0VBQ0YsQ0FYRDs7RUFhQSxNQUFNQyxtQkFBbUIsR0FBSXBoQixHQUFELElBQTBCO0lBQ3BELElBQUlBLEdBQUcsSUFBSUEsR0FBRyxDQUFDcWdCLFFBQWYsRUFBeUI7TUFDdkIsb0JBQ0UsdURBQUMsK0NBQUQ7UUFBUSxPQUFPLEVBQUUsTUFBTTNnQixPQUFPLENBQUNNLEdBQUQsRUFBTSxJQUFOLENBQTlCO1FBQTJDLEtBQUssRUFBRSxVQUFsRDtRQUFBO01BQUEsRUFERjtJQUtEOztJQUVEO0VBQ0QsQ0FWRDs7RUFZQSxPQUFPN0csd0VBQUEsZ0JBQ0w7SUFBQSx3QkFDRSx1REFBQyx1REFBRDtNQUFBLHVCQUNFLHVEQUFDLG9EQUFEO1FBQWEsS0FBSyxFQUFFLFVBQXBCO1FBQWdDLFVBQVUsRUFBRXluQixVQUE1QztRQUF3RCxJQUFJLEVBQUUsSUFBOUQ7UUFBQSx1QkFDRSx1REFBQyxtRkFBRDtVQUNFLE9BQU8sRUFBRTVRLE9BRFg7VUFFRSxLQUFLLEVBQUUzUixLQUFGLGFBQUVBLEtBQUYsdUJBQUVBLEtBQUssQ0FBRWdpQixRQUZoQjtVQUdFLFFBQVEsRUFBRVEsZ0JBSFo7VUFJRSxJQUFJLEVBQUVaO1FBSlI7TUFERjtJQURGLEVBREYsZUFXRSx1REFBQyx1REFBRDtNQUFBLHVCQUNFLHVEQUFDLG9EQUFEO1FBQWEsS0FBSyxFQUFFLE1BQXBCO1FBQTRCLFVBQVUsRUFBRVcsVUFBeEM7UUFBb0QsSUFBSSxFQUFFLElBQTFEO1FBQUEsdUJBQ0UsdURBQUMsbUZBQUQ7VUFDRSxPQUFPLEVBQUU1USxPQURYO1VBRUUsS0FBSyxpQkFBRTNSLEtBQUYsYUFBRUEsS0FBRix1QkFBRUEsS0FBSyxDQUFFd0IsSUFBVCxxREFBaUIsSUFGeEI7VUFHRSxRQUFRLEVBQUVpaEIsWUFIWjtVQUlFLElBQUksRUFBRWI7UUFKUjtNQURGO0lBREYsRUFYRixFQXFCR21CLG1CQUFtQixDQUFDL2lCLEtBQUQsQ0FyQnRCLDZCQXNCRSxnRUF0QkYsR0F1QkcwaUIsVUFBVSxpQkFBQzFpQixLQUFELGFBQUNBLEtBQUQsdUJBQUNBLEtBQUssQ0FBRXdCLElBQVIsdURBQWdCLElBQWhCLENBdkJiO0VBQUEsRUFESyxnQkEyQkw7SUFBQTtFQUFBLEVBM0JGO0FBNkJELENBOUVNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6Q1A7QUFDQTtBQUdBO0FBQ0E7OztBQVFPLE1BQU15aEIsc0JBQXNCLEdBQUcsQ0FBQztFQUNyQ0MsMEJBRHFDO0VBRXJDQyw0QkFGcUM7RUFHckNDO0FBSHFDLENBQUQsS0FJekI7RUFDWCxNQUFNcG5CLE1BQU0sR0FBRzhHLHVEQUFVLENBQUN6RCxTQUFTLENBQUMrakIsa0JBQUQsQ0FBVixDQUF6Qjs7RUFFQSxNQUFNQyxvQkFBb0IsR0FBRyxNQUFNO0lBQ2pDSCwwQkFBMEIsQ0FBQ3BhLHVFQUFELENBQTFCO0VBQ0QsQ0FGRDs7RUFJQSxNQUFNd2EsdUJBQXVCLEdBQUcsTUFBTTtJQUNwQ0osMEJBQTBCLENBQUNwYSwwRUFBRCxDQUExQjtFQUNELENBRkQ7O0VBSUEsTUFBTXlhLCtCQUErQixHQUFHLE1BQU07SUFDNUNMLDBCQUEwQixDQUFDcGEsMEVBQUQsQ0FBMUI7RUFDRCxDQUZEOztFQUlBLE1BQU0wYSxxQkFBcUIsR0FBRyxNQUFNO0lBQ2xDTCw0QkFBNEIsQ0FBQ3RhLDBFQUFELENBQTVCO0VBQ0QsQ0FGRDs7RUFJQSxNQUFNNGEsc0JBQXNCLEdBQUcsTUFBTTtJQUNuQ04sNEJBQTRCLENBQUN0YSwyRUFBRCxDQUE1QjtFQUNELENBRkQ7O0VBSUEsTUFBTTZhLGlDQUFpQyxHQUFHLE1BQU07SUFDOUNQLDRCQUE0QixDQUFDdGEsNEVBQUQsQ0FBNUI7RUFDRCxDQUZEOztFQUlBLG9CQUNFO0lBQ0UsT0FBTyxFQUFDLEtBRFY7SUFFRSxLQUFLLEVBQUMsNEJBRlI7SUFHRSxLQUFLLEVBQUMsYUFIUjtJQUlFLE1BQU0sRUFBQyxhQUpUO0lBS0UsT0FBTyxFQUFDLDJCQUxWO0lBTUUsbUJBQW1CLEVBQUMsZUFOdEI7SUFPRSxLQUFLLEVBQUU7TUFBRThhLFlBQVksRUFBRTtJQUFoQixDQVBUO0lBQUEsdUJBU0U7TUFBRyxTQUFTLEVBQUMsMERBQWI7TUFBd0UsSUFBSSxFQUFDLFNBQTdFO01BQXVGLE1BQU0sRUFBQyxNQUE5RjtNQUFBLDBDQUNFO1FBQ0UsSUFBSSxFQUFDLFNBRFA7UUFFRSxDQUFDLEVBQUM7TUFGSixFQURGLGdCQVNFO1FBQU0sU0FBUyxFQUFFM25CLE1BQU0sQ0FBQzRuQixhQUF4QjtRQUF1QyxNQUFNLEVBQUMsS0FBOUM7UUFBb0QsS0FBSyxFQUFDLElBQTFEO1FBQStELENBQUMsRUFBQyxNQUFqRTtRQUF3RSxDQUFDLEVBQUM7TUFBMUUsRUFURixlQVVFO1FBQ0UsU0FBUyxFQUFFNW5CLE1BQU0sQ0FBQzZuQixlQURwQjtRQUVFLE9BQU8sRUFBRVIsb0JBRlg7UUFHRSxNQUFNLEVBQUMsS0FIVDtRQUlFLEtBQUssRUFBQyxLQUpSO1FBS0UsQ0FBQyxFQUFDLE1BTEo7UUFNRSxDQUFDLEVBQUMsS0FOSjtRQU9FLElBQUksRUFBQztNQVBQLEVBVkYsZUFtQkU7UUFBTSxTQUFTLEVBQUVybkIsTUFBTSxDQUFDOG5CLGdCQUF4QjtRQUEwQyxNQUFNLEVBQUMsS0FBakQ7UUFBdUQsS0FBSyxFQUFDLElBQTdEO1FBQWtFLENBQUMsRUFBQyxLQUFwRTtRQUEwRSxDQUFDLEVBQUM7TUFBNUUsRUFuQkYsZUFvQkU7UUFDRSxTQUFTLEVBQUU5bkIsTUFBTSxDQUFDNm5CLGVBRHBCO1FBRUUsT0FBTyxFQUFFUCx1QkFGWDtRQUdFLE1BQU0sRUFBQyxLQUhUO1FBSUUsS0FBSyxFQUFDLEtBSlI7UUFLRSxDQUFDLEVBQUMsS0FMSjtRQU1FLENBQUMsRUFBQyxLQU5KO1FBT0UsSUFBSSxFQUFDO01BUFAsRUFwQkYsZUE2QkU7UUFBTSxTQUFTLEVBQUV0bkIsTUFBTSxDQUFDK25CLGNBQXhCO1FBQXdDLE1BQU0sRUFBQyxJQUEvQztRQUFvRCxLQUFLLEVBQUMsS0FBMUQ7UUFBZ0UsQ0FBQyxFQUFDLE1BQWxFO1FBQXlFLENBQUMsRUFBQztNQUEzRSxFQTdCRixlQThCRTtRQUNFLFNBQVMsRUFBRS9uQixNQUFNLENBQUM2bkIsZUFEcEI7UUFFRSxPQUFPLEVBQUVMLHFCQUZYO1FBR0UsTUFBTSxFQUFDLEtBSFQ7UUFJRSxLQUFLLEVBQUMsS0FKUjtRQUtFLENBQUMsRUFBQyxLQUxKO1FBTUUsQ0FBQyxFQUFDLEtBTko7UUFPRSxJQUFJLEVBQUM7TUFQUCxFQTlCRixlQXVDRTtRQUFNLFNBQVMsRUFBRXhuQixNQUFNLENBQUNnb0IsZUFBeEI7UUFBeUMsTUFBTSxFQUFDLElBQWhEO1FBQXFELEtBQUssRUFBQyxLQUEzRDtRQUFpRSxDQUFDLEVBQUMsTUFBbkU7UUFBMEUsQ0FBQyxFQUFDO01BQTVFLEVBdkNGLGVBd0NFO1FBQ0UsU0FBUyxFQUFFaG9CLE1BQU0sQ0FBQzZuQixlQURwQjtRQUVFLE9BQU8sRUFBRUosc0JBRlg7UUFHRSxNQUFNLEVBQUMsS0FIVDtRQUlFLEtBQUssRUFBQyxLQUpSO1FBS0UsQ0FBQyxFQUFDLEtBTEo7UUFNRSxDQUFDLEVBQUMsTUFOSjtRQU9FLElBQUksRUFBQztNQVBQLEVBeENGLGVBaURFO1FBQ0UsU0FBUyxFQUFFem5CLE1BQU0sQ0FBQ2lvQixHQURwQjtRQUVFLENBQUMsRUFBQztNQUZKLEVBakRGLGVBd0RFO1FBQU0sU0FBUyxFQUFFam9CLE1BQU0sQ0FBQ2tvQix3QkFBeEI7UUFBa0QsTUFBTSxFQUFDLEtBQXpEO1FBQStELEtBQUssRUFBQyxJQUFyRTtRQUEwRSxDQUFDLEVBQUMsS0FBNUU7UUFBa0YsQ0FBQyxFQUFDO01BQXBGLEVBeERGLGVBeURFO1FBQ0UsU0FBUyxFQUFFbG9CLE1BQU0sQ0FBQzZuQixlQURwQjtRQUVFLE9BQU8sRUFBRU4sK0JBRlg7UUFHRSxNQUFNLEVBQUMsS0FIVDtRQUlFLEtBQUssRUFBQyxLQUpSO1FBS0UsQ0FBQyxFQUFDLEtBTEo7UUFNRSxDQUFDLEVBQUMsS0FOSjtRQU9FLElBQUksRUFBQztNQVBQLEVBekRGLGVBa0VFO1FBQU0sU0FBUyxFQUFFdm5CLE1BQU0sQ0FBQ21vQiwwQkFBeEI7UUFBb0QsTUFBTSxFQUFDLElBQTNEO1FBQWdFLEtBQUssRUFBQyxLQUF0RTtRQUE0RSxDQUFDLEVBQUMsTUFBOUU7UUFBcUYsQ0FBQyxFQUFDO01BQXZGLEVBbEVGLGVBbUVFO1FBQ0UsU0FBUyxFQUFFbm9CLE1BQU0sQ0FBQzZuQixlQURwQjtRQUVFLE9BQU8sRUFBRUgsaUNBRlg7UUFHRSxNQUFNLEVBQUMsS0FIVDtRQUlFLEtBQUssRUFBQyxLQUpSO1FBS0UsQ0FBQyxFQUFDLEtBTEo7UUFNRSxDQUFDLEVBQUMsS0FOSjtRQU9FLElBQUksRUFBQztNQVBQLEVBbkVGO0lBQUE7RUFURixFQURGO0FBeUZELENBeEhNOztBQTBIUCxNQUFNcmtCLFNBQVMsR0FBSStqQixrQkFBRCxJQUFxQ25uQixLQUFELElBQTBCO0VBQzlFLE1BQU1tb0IsV0FBVyxHQUFHLFNBQXBCO0VBQ0EsTUFBTUMsYUFBYSxHQUFHLEtBQXRCO0VBQ0EsTUFBTUMsY0FBYyxHQUFHLFNBQXZCO0VBRUEsTUFBTUMsaUJBQWlCLEdBQUd0b0IsS0FBSyxDQUFDdW9CLE1BQU4sR0FBZSxTQUFmLEdBQTJCLFNBQXJEO0VBRUEsT0FBTztJQUNMWCxlQUFlLEVBQUVwcEIsNkNBQUk7QUFDekI7QUFDQSxnQkFBZ0IycEIsV0FBWTtBQUM1Qix3QkFBd0JDLGFBQWM7QUFDdEM7QUFDQSxLQU5TO0lBT0xULGFBQWEsRUFBRW5wQiw2Q0FBSTtBQUN2QixRQUFRMm9CLGtCQUFrQixDQUFDN1gsUUFBbkIsS0FBZ0N6Qyx1RUFBaEMsSUFDRnNhLGtCQUFrQixDQUFDN1gsUUFBbkIsS0FBZ0N6Qyw2RUFEOUIsR0FFRywrQkFBOEJ3YixjQUFlLEdBRmhELEdBR0csU0FBUUMsaUJBQWtCLEdBQUc7QUFDeEMsS0FaUztJQWFMVCxnQkFBZ0IsRUFBRXJwQiw2Q0FBSTtBQUMxQixRQUFRMm9CLGtCQUFrQixDQUFDN1gsUUFBbkIsS0FBZ0N6QywwRUFBaEMsSUFDRnNhLGtCQUFrQixDQUFDN1gsUUFBbkIsS0FBZ0N6Qyw2RUFEOUIsR0FFRywrQkFBOEJ3YixjQUFlLEdBRmhELEdBR0csU0FBUUMsaUJBQWtCLEdBQUc7QUFDeEMsS0FsQlM7SUFtQkxSLGNBQWMsRUFBRXRwQiw2Q0FBSTtBQUN4QixRQUFRMm9CLGtCQUFrQixDQUFDcFgsVUFBbkIsS0FBa0NuRCwwRUFBbEMsSUFDRnVhLGtCQUFrQixDQUFDcFgsVUFBbkIsS0FBa0NuRCwrRUFEaEMsR0FFRyxnQ0FBK0J5YixjQUFlLEdBRmpELEdBR0csU0FBUUMsaUJBQWtCLEdBQUc7QUFDeEMsS0F4QlM7SUF5QkxQLGVBQWUsRUFBRXZwQiw2Q0FBSTtBQUN6QixRQUFRMm9CLGtCQUFrQixDQUFDcFgsVUFBbkIsS0FBa0NuRCwyRUFBbEMsSUFDRnVhLGtCQUFrQixDQUFDcFgsVUFBbkIsS0FBa0NuRCwrRUFEaEMsR0FFRyxnQ0FBK0J5YixjQUFlLEdBRmpELEdBR0csU0FBUUMsaUJBQWtCLEdBQUc7QUFDeEMsS0E5QlM7SUErQkxKLDBCQUEwQixFQUFFMXBCLDZDQUFJO0FBQ3BDLFFBQVEyb0Isa0JBQWtCLENBQUNwWCxVQUFuQixLQUFrQ25ELDRFQUFsQyxHQUNHLGdDQUErQnliLGNBQWUsR0FEakQsR0FFRyxTQUFRQyxpQkFBa0IsR0FBRztBQUN4QyxLQW5DUztJQW9DTEwsd0JBQXdCLEVBQUV6cEIsNkNBQUk7QUFDbEMsUUFBUTJvQixrQkFBa0IsQ0FBQzdYLFFBQW5CLEtBQWdDekMsMEVBQWhDLEdBQ0csK0JBQThCd2IsY0FBZSxHQURoRCxHQUVHLFNBQVFDLGlCQUFrQixHQUFHO0FBQ3hDLEtBeENTO0lBeUNMTixHQUFHLEVBQUV4cEIsNkNBQUk7QUFDYixjQUFjOHBCLGlCQUFrQjtBQUNoQztFQTNDUyxDQUFQO0FBNkNELENBcEREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTs7OztBQU1PLE1BQU1JLHNCQUFOLFNBQXFDMWpCLGdEQUFyQyxDQUEwRDtFQUFBO0lBQUE7O0lBQUEsa0NBQ3BELE1BQU07TUFDZixNQUFNO1FBQUVvRjtNQUFGLElBQWUsS0FBSzVFLEtBQUwsQ0FBVzhLLElBQWhDOztNQUNBLElBQUksRUFBQ2xHLFFBQUQsYUFBQ0EsUUFBRCxlQUFDQSxRQUFRLENBQUVxVyxLQUFYLENBQUosRUFBc0I7UUFDcEI7TUFDRDs7TUFDRCxPQUFPclcsUUFBUSxDQUFDcVcsS0FBVCxDQUFlMVMsS0FBdEI7SUFDRCxDQVA4RDs7SUFBQSxtQ0FTbEQzTixHQUFELElBQWtDO01BQUE7O01BQzVDLE1BQU07UUFBRWdLO01BQUYsSUFBZSxLQUFLNUUsS0FBTCxDQUFXOEssSUFBaEM7O01BQ0EsSUFBSSxFQUFDbEcsUUFBRCxhQUFDQSxRQUFELGVBQUNBLFFBQVEsQ0FBRXFXLEtBQVgsQ0FBSixFQUFzQjtRQUNwQjtNQUNEOztNQUNELE1BQU07UUFBRUE7TUFBRixJQUFZclcsUUFBbEI7TUFFQSxNQUFNa0csSUFBSSw0QkFBRzNELGtGQUFBLENBQWtDdk0sR0FBRyxDQUFDMkQsS0FBdEMsQ0FBSCx5RUFBbUQrRywrRUFBN0Q7TUFDQSxNQUFNNmQsaUJBQWlCLEdBQUdyWSxJQUFJLENBQUNwSyxhQUFMLEVBQTFCO01BQ0F5aUIsaUJBQWlCLENBQUNqYyxJQUFsQixHQUF5QjRELElBQUksQ0FBQzFLLEVBQTlCO01BQ0EsTUFBTWdqQixVQUFVLEdBQUcsSUFBSXhZLDZFQUFKLENBQWlCRSxJQUFqQixFQUF1QnFZLGlCQUF2QixFQUEwQ2xJLEtBQTFDLENBQW5CO01BQ0FtSSxVQUFVLENBQUMzVixVQUFYLENBQXNCd04sS0FBSyxDQUFDMVMsS0FBTixDQUFZMkgsT0FBbEM7TUFDQStLLEtBQUssQ0FBQ3pMLFFBQU4sQ0FBZTdULElBQWYsQ0FBb0J5bkIsVUFBcEI7TUFDQW5JLEtBQUssQ0FBQzFTLEtBQU4sQ0FBWW9HLElBQVo7TUFFQXNNLEtBQUssQ0FBQ3RMLG9CQUFOO0lBQ0QsQ0F6QjhEOztJQUFBLGtDQTJCbkQ3RSxJQUFELElBQWU7TUFDeEIsTUFBTTtRQUFFbEc7TUFBRixJQUFlLEtBQUs1RSxLQUFMLENBQVc4SyxJQUFoQzs7TUFFQSxJQUFJbEcsUUFBSixhQUFJQSxRQUFKLGVBQUlBLFFBQVEsQ0FBRTJELEtBQWQsRUFBcUI7UUFDbkIsSUFBSTtVQUNGLElBQUlyTyxTQUEwQixHQUFHO1lBQUVxYSxPQUFPLEVBQUU7VUFBWCxDQUFqQzs7VUFDQSxJQUFJekosSUFBSSxZQUFZcUUsMEVBQXBCLEVBQWdDO1lBQzlCLE1BQU00RixjQUFnQyxHQUFHLEVBQXpDO1lBQ0FBLGNBQWMsQ0FBQ3BaLElBQWYsQ0FBb0JtUCxJQUFwQixhQUFvQkEsSUFBcEIsdUJBQW9CQSxJQUFJLENBQUVFLEdBQTFCO1lBQ0E5USxTQUFTLENBQUNxYSxPQUFWLEdBQW9CUSxjQUFwQjtZQUNBN2EsU0FBUyxDQUFDd2EsS0FBVixHQUFrQjVKLElBQWxCO1lBQ0FsRyxRQUFRLENBQUMyRCxLQUFULENBQWV6SixNQUFmLENBQXNCNUUsU0FBdEI7VUFDRCxDQU5ELE1BTU8sSUFBSTRRLElBQUksWUFBWUYsNkVBQXBCLEVBQWtDO1lBQ3ZDLE1BQU1wQyxhQUFhLEdBQUcsQ0FBQ3NDLElBQUQsYUFBQ0EsSUFBRCx1QkFBQ0EsSUFBSSxDQUFFRSxHQUFQLENBQXRCO1lBQ0E5USxTQUFTLENBQUNxYSxPQUFWLEdBQW9CL0wsYUFBcEI7WUFDQTVELFFBQVEsQ0FBQzJELEtBQVQsQ0FBZXpKLE1BQWYsQ0FBc0I1RSxTQUF0QjtVQUNEO1FBQ0YsQ0FiRCxDQWFFLE9BQU91bUIsS0FBUCxFQUFjO1VBQ2RQLGdFQUFBLENBQWVOLCtEQUFmLEVBQXFDLENBQUMsa0VBQUQsQ0FBckM7UUFDRDtNQUNGO0lBQ0YsQ0FoRDhEOztJQUFBLDBDQWtENUMsTUFBTTtNQUN2QixNQUFNO1FBQUVoYjtNQUFGLElBQWUsS0FBSzVFLEtBQUwsQ0FBVzhLLElBQWhDOztNQUVBLElBQUksRUFBQ2xHLFFBQUQsYUFBQ0EsUUFBRCxlQUFDQSxRQUFRLENBQUVxVyxLQUFYLENBQUosRUFBc0I7UUFDcEI7TUFDRDs7TUFFRCxNQUFNO1FBQUVBO01BQUYsSUFBWXJXLFFBQWxCO01BRUFxVyxLQUFLLENBQUMxUyxLQUFOLENBQVk0SSxxQkFBWjtJQUNELENBNUQ4RDs7SUFBQSxtQ0E4RGxEUixNQUFELElBQXdCO01BQ2xDLElBQUksQ0FBQ0EsTUFBTSxDQUFDMFMsV0FBWixFQUF5QjtRQUN2QjtNQUNEOztNQUVELE1BQU07UUFBRXplO01BQUYsSUFBZSxLQUFLNUUsS0FBTCxDQUFXOEssSUFBaEM7O01BQ0EsSUFBSSxFQUFDbEcsUUFBRCxhQUFDQSxRQUFELGVBQUNBLFFBQVEsQ0FBRXFXLEtBQVgsQ0FBSixFQUFzQjtRQUNwQjtNQUNEOztNQUVELE1BQU07UUFBRUE7TUFBRixJQUFZclcsUUFBbEI7TUFFQSxNQUFNMGUsS0FBSyxHQUFHckksS0FBSyxDQUFDekwsUUFBTixDQUFlblUsTUFBZixHQUF3QixDQUF0QztNQUNBLE1BQU1rb0IsR0FBRyxHQUFHLENBQUM1UyxNQUFNLENBQUM2UyxNQUFQLENBQWNDLEtBQWQsR0FBc0JILEtBQXZCLElBQWdDLENBQUMsQ0FBN0M7TUFDQSxNQUFNSSxHQUFHLEdBQUcsQ0FBQy9TLE1BQU0sQ0FBQzBTLFdBQVAsQ0FBbUJJLEtBQW5CLEdBQTJCSCxLQUE1QixJQUFxQyxDQUFDLENBQWxEO01BRUFySSxLQUFLLENBQUN6SyxPQUFOLENBQWMrUyxHQUFkLEVBQW1CRyxHQUFuQjtJQUNELENBL0U4RDs7SUFBQSxtQ0FpRm5ELE1BQU07TUFDaEIsTUFBTTllLFFBQVEsR0FBRyxLQUFLNUUsS0FBTCxDQUFXOEssSUFBWCxDQUFnQmxHLFFBQWpDOztNQUVBLElBQUksRUFBQ0EsUUFBRCxhQUFDQSxRQUFELGVBQUNBLFFBQVEsQ0FBRXFXLEtBQVgsS0FBb0IsRUFBQ3JXLFFBQUQsYUFBQ0EsUUFBRCxlQUFDQSxRQUFRLENBQUUyRCxLQUFYLENBQXhCLEVBQTBDO1FBQ3hDO01BQ0Q7O01BRUQsTUFBTTtRQUFFQSxLQUFGO1FBQVMwUztNQUFULElBQW1CclcsUUFBekI7O01BRUEsSUFBSXFXLEtBQUssQ0FBQ2xRLE1BQVYsRUFBa0I7UUFDaEJ4QyxLQUFLLENBQUNpUCxrQkFBTixDQUF5QnlELEtBQUssQ0FBQ2xRLE1BQS9CO01BQ0Q7SUFDRixDQTdGOEQ7O0lBQUEsdUNBK0Z2QyxNQUFNO01BQzVCLE1BQU1uRyxRQUFRLEdBQUcsS0FBSzVFLEtBQUwsQ0FBVzhLLElBQVgsQ0FBZ0JsRyxRQUFqQzs7TUFFQSxJQUFJLEVBQUNBLFFBQUQsYUFBQ0EsUUFBRCxlQUFDQSxRQUFRLENBQUVxVyxLQUFYLENBQUosRUFBc0I7UUFDcEI7TUFDRDs7TUFFRCxNQUFNO1FBQUVBO01BQUYsSUFBWXJXLFFBQWxCO01BRUEsS0FBSytlLFdBQUw7TUFDQTFJLEtBQUssQ0FBQ3pMLFFBQU4sQ0FBZXFFLE9BQWYsQ0FBd0J2WSxPQUFELElBQTJCO1FBQUE7O1FBQ2hELE1BQU1pUSxnQkFBZ0IsbUJBQUdqUSxPQUFPLENBQUMwUCxHQUFYLGlEQUFHLGFBQWFRLHFCQUFiLEVBQXpCO1FBQ0FsUSxPQUFPLENBQUN3UiwwQkFBUixDQUFtQ3ZCLGdCQUFuQyxtQkFBcUQwUCxLQUFLLENBQUNsUSxNQUEzRCx1RUFBcUQsY0FBY0MsR0FBbkUsc0RBQXFELGtCQUFtQlEscUJBQW5CLEVBQXJEO1FBQ0Esa0JBQUF5UCxLQUFLLENBQUNsUSxNQUFOLGtFQUFjdU0sUUFBZCxDQUF1QnJJLDREQUF2QixFQUFnRDNULE9BQWhELEVBQXlELEtBQXpELEVBQWdFLEtBQWhFO01BQ0QsQ0FKRDtJQUtELENBOUc4RDs7SUFBQSx5Q0FnSHJDLE1BQU07TUFDOUI0a0IsbUVBQUEsQ0FDRSxJQUFJK0Msb0VBQUosQ0FBMEI7UUFDeEJsRSxLQUFLLEVBQUUsZ0JBRGlCO1FBRXhCM2hCLElBQUksRUFBRywrQ0FGaUI7UUFHeEJ5bUIsS0FBSyxFQUFFLDJFQUhpQjtRQUl4QkMsV0FBVyxFQUFFLEtBSlc7UUFLeEJDLE9BQU8sRUFBRSxVQUxlO1FBTXhCQyxTQUFTLEVBQUUsWUFBWTtVQUNyQixLQUFLQyxhQUFMO1FBQ0Q7TUFSdUIsQ0FBMUIsQ0FERjtJQVlELENBN0g4RDs7SUFBQSxxQ0ErSHpDLE1BQU07TUFBQTs7TUFDMUIsTUFBTXJmLFFBQVEsR0FBRyxLQUFLNUUsS0FBTCxDQUFXOEssSUFBWCxDQUFnQmxHLFFBQWpDOztNQUVBLElBQUksRUFBQ0EsUUFBRCxhQUFDQSxRQUFELGVBQUNBLFFBQVEsQ0FBRXFXLEtBQVgsQ0FBSixFQUFzQjtRQUNwQjtNQUNEOztNQUVELE1BQU07UUFBRUE7TUFBRixJQUFZclcsUUFBbEI7TUFFQSxNQUFNMkQsS0FBSyxHQUFHLEtBQUs4QyxRQUFMLEVBQWQ7TUFDQTlDLEtBQUssU0FBTCxJQUFBQSxLQUFLLFdBQUwsWUFBQUEsS0FBSyxDQUFFOEQsTUFBUCxDQUFjdUMsTUFBZCxDQUFxQnFNLEtBQUssQ0FBQ3pmLE9BQU4sRUFBckI7TUFDQXlmLEtBQUssQ0FBQ3pMLFFBQU4sQ0FBZXFFLE9BQWYsQ0FBd0J2WSxPQUFELElBQWFpTixLQUFiLGFBQWFBLEtBQWIsdUJBQWFBLEtBQUssQ0FBRThELE1BQVAsQ0FBY3VDLE1BQWQsQ0FBcUJ0VCxPQUFPLENBQUNFLE9BQVIsRUFBckIsQ0FBcEM7TUFDQSxrQkFBQXlmLEtBQUssQ0FBQ2xRLE1BQU4sa0VBQWN1TSxRQUFkLENBQXVCckkseURBQXZCLEVBQTZDZ00sS0FBN0M7TUFFQSxLQUFLaUosU0FBTDtJQUNELENBOUk4RDs7SUFBQSwwQ0FnSnBDLE1BQU07TUFDL0IsTUFBTTNiLEtBQUssR0FBRyxLQUFLOEMsUUFBTCxFQUFkOztNQUNBLElBQUk5QyxLQUFKLEVBQVc7UUFDVEEsS0FBSyxDQUFDd08sY0FBTjtNQUNELENBRkQsTUFFTztRQUNMbEgsT0FBTyxDQUFDc1UsSUFBUixDQUFhLFdBQWI7TUFDRDtJQUNGLENBdko4RDs7SUFBQSx1Q0F5SnZDLE1BQU07TUFDNUJqRSxtRUFBQSxDQUNFLElBQUkrQyxvRUFBSixDQUEwQjtRQUN4QmxFLEtBQUssRUFBRSxjQURpQjtRQUV4QjNoQixJQUFJLEVBQUcsNkNBRmlCO1FBR3hCeW1CLEtBQUssRUFBRSxxREFIaUI7UUFJeEJPLElBQUksRUFBRSxXQUprQjtRQUt4Qk4sV0FBVyxFQUFFLFFBTFc7UUFNeEJDLE9BQU8sRUFBRSxRQU5lO1FBT3hCQyxTQUFTLEVBQUUsWUFBWTtVQUNyQixLQUFLTCxXQUFMO1FBQ0Q7TUFUdUIsQ0FBMUIsQ0FERjtJQWFELENBdks4RDtFQUFBOztFQXlLL0Q3akIsTUFBTSxHQUFHO0lBQ1AsTUFBTThFLFFBQVEsR0FBRyxLQUFLNUUsS0FBTCxDQUFXOEssSUFBWCxDQUFnQmxHLFFBQWpDOztJQUNBLElBQUksQ0FBQ0EsUUFBTCxFQUFlO01BQ2Isb0NBQU87UUFBQTtNQUFBLEVBQVA7SUFDRDs7SUFDRCxNQUFNcVcsS0FBSyxHQUFHclcsUUFBUSxDQUFDcVcsS0FBdkI7O0lBQ0EsSUFBSSxDQUFDQSxLQUFMLEVBQVk7TUFDVixzQ0FBTztRQUFBO01BQUEsRUFBUDtJQUNEOztJQUVELE1BQU1saEIsUUFBUSxHQUFJdUIsT0FBRCxJQUEyQjtNQUMxQzJmLEtBQUssQ0FBQzNELFFBQU4sQ0FBZXJJLHlEQUFmLEVBQXFDM1QsT0FBckM7SUFDRCxDQUZEOztJQUlBLE1BQU10QixXQUFXLEdBQUlzQixPQUFELElBQTJCO01BQzdDMmYsS0FBSyxDQUFDM0QsUUFBTixDQUFlckksNERBQWYsRUFBd0MzVCxPQUF4QztJQUNELENBRkQ7O0lBSUEsTUFBTTFCLFlBQVksR0FBSTBCLE9BQUQsSUFBMkI7TUFDOUMsT0FBT0EsT0FBTyxDQUFDeEMsT0FBUixDQUFnQm9PLElBQXZCO0lBQ0QsQ0FGRDs7SUFJQSxNQUFNOU0sWUFBWSxHQUFHLENBQUNrQixPQUFELEVBQXdCcUMsSUFBeEIsS0FBeUM7TUFDNURyQyxPQUFPLENBQUN6QyxRQUFSLG1CQUFzQnlDLE9BQU8sQ0FBQ3hDLE9BQTlCO1FBQXVDNkU7TUFBdkM7SUFDRCxDQUZEOztJQUlBLE1BQU0xRCxXQUFXLEdBQUlxQixPQUFELElBQTJCO01BQzdDLE9BQU8sRUFBRUEsT0FBTyxZQUFZNlQsMEVBQXJCLENBQVA7SUFDRCxDQUZEOztJQUlBLE1BQU05VSx5QkFBeUIsR0FBSWdxQixZQUFELElBQTBCO01BQzFELE1BQU05YixLQUFLLEdBQUcsS0FBSzhDLFFBQUwsRUFBZDtNQUVBLE9BQU81UCxPQUFPLENBQUM4TSxLQUFELGFBQUNBLEtBQUQsdUJBQUNBLEtBQUssQ0FBRStiLFNBQVAsQ0FBaUJELFlBQWpCLENBQUQsQ0FBZDtJQUNELENBSkQ7O0lBTUEsTUFBTW5xQixTQUFtQixHQUFHMEssUUFBUSxDQUFDK1EsUUFBVCxHQUFvQi9RLFFBQVEsQ0FBQytRLFFBQVQsQ0FBa0JuRSxHQUFsQixDQUF1QjFWLENBQUQsSUFBT0EsQ0FBQyxDQUFDTixPQUFGLEVBQTdCLENBQXBCLEdBQWdFLEVBQTVGO0lBQ0Esb0JBQ0U7TUFBQSxXQUNHLENBQUN5ZixLQUFLLENBQUN6TyxNQUFOLEVBQUQsaUJBQ0M7UUFBQSx3QkFDRSx3REFBQywrQ0FBRDtVQUFRLElBQUksRUFBQyxVQUFiO1VBQXdCLElBQUksRUFBQyxJQUE3QjtVQUFrQyxPQUFPLEVBQUMsV0FBMUM7VUFBc0QsT0FBTyxFQUFFLEtBQUswWCxTQUFwRTtVQUFBO1FBQUEsRUFERixlQUlFLHdEQUFDLCtDQUFEO1VBQVEsSUFBSSxFQUFDLElBQWI7VUFBa0IsT0FBTyxFQUFDLFdBQTFCO1VBQXNDLE9BQU8sRUFBRSxNQUFNLEtBQUtwcUIsUUFBTCxDQUFjbWhCLEtBQWQsQ0FBckQ7VUFBQTtRQUFBLEVBSkYsZUFPRSx3REFBQywrQ0FBRDtVQUFRLElBQUksRUFBQyxJQUFiO1VBQWtCLE9BQU8sRUFBQyxXQUExQjtVQUFzQyxPQUFPLEVBQUUsTUFBTSxLQUFLc0osZUFBTCxFQUFyRDtVQUFBO1FBQUEsRUFQRixlQVVFLHdEQUFDLCtDQUFEO1VBQVEsSUFBSSxFQUFDLElBQWI7VUFBa0IsT0FBTyxFQUFDLFdBQTFCO1VBQXNDLE9BQU8sRUFBRSxNQUFNLEtBQUtDLGFBQUwsRUFBckQ7VUFBQTtRQUFBLEVBVkY7TUFBQSxFQUZKLGVBaUJFLHdEQUFDLDJGQUFEO1FBQ0UsU0FBUyxFQUFFLEtBQUszcUIsU0FEbEI7UUFFRSxRQUFRLEVBQUUsS0FBS0MsUUFGakI7UUFHRSxRQUFRLEVBQUVDLFFBSFo7UUFJRSxXQUFXLEVBQUVDLFdBSmY7UUFLRSxZQUFZLEVBQUVKLFlBTGhCO1FBTUUsWUFBWSxFQUFFUSxZQU5oQjtRQU9FLHlCQUF5QixFQUFFQyx5QkFQN0I7UUFRRSxXQUFXLEVBQUVKLFdBUmY7UUFTRSxNQUFNLEVBQUVnaEIsS0FBSyxDQUFDekwsUUFUaEI7UUFVRSxTQUFTLEVBQUV0VjtNQVZiLEVBakJGLDZCQTZCRSxpRUE3QkYsZ0JBK0JFLHlEQUFDLHdEQUFEO1FBQUEsd0JBQ0Usd0RBQUMscUZBQUQ7VUFDRSxRQUFRLEVBQUUsS0FBS3VxQixTQURqQjtVQUVFLE9BQU8sRUFBRXRkLG9GQUFBLEdBQXNDck8sT0FGakQ7VUFHRSxLQUFLLEVBQUU7UUFIVCxFQURGLEVBTUdvQixTQUFTLENBQUNtQixNQUFWLEdBQW1CLENBQW5CLGlCQUNDLHdEQUFDLCtDQUFEO1VBQVEsSUFBSSxFQUFDLElBQWI7VUFBa0IsT0FBTyxFQUFDLFdBQTFCO1VBQXNDLE9BQU8sRUFBRSxLQUFLc3BCLGdCQUFwRDtVQUFBO1FBQUEsRUFQSixFQVdHenFCLFNBQVMsQ0FBQ21CLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JoQywwRkFBeEIsaUJBQ0Msd0RBQUMsK0NBQUQ7VUFBUSxJQUFJLEVBQUMsSUFBYjtVQUFrQixPQUFPLEVBQUMsV0FBMUI7VUFBc0MsT0FBTyxFQUFFLEtBQUt5ckIsZ0JBQXBEO1VBQUE7UUFBQSxFQVpKO01BQUEsRUEvQkY7SUFBQSxFQURGO0VBbUREOztBQWpROEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2QmpFO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7Ozs7QUFHQSxNQUFNTSxNQUE4QixHQUFHLENBQUMsS0FBRCxFQUFRLE1BQVIsRUFBZ0IsUUFBaEIsRUFBMEIsT0FBMUIsRUFBbUMsT0FBbkMsRUFBNEMsUUFBNUMsQ0FBdkM7QUFFQSxNQUFNQyxpQkFBK0QsR0FBRyxDQUN0RTtFQUFFdHNCLEtBQUssRUFBRSxNQUFUO0VBQWlCd0YsS0FBSyxFQUFFNkksMEVBQXlCbEI7QUFBakQsQ0FEc0UsRUFFdEU7RUFBRW5OLEtBQUssRUFBRSxPQUFUO0VBQWtCd0YsS0FBSyxFQUFFNkksMkVBQTBCZDtBQUFuRCxDQUZzRSxFQUd0RTtFQUFFdk4sS0FBSyxFQUFFLGdCQUFUO0VBQTJCd0YsS0FBSyxFQUFFNkksK0VBQThCb0Q7QUFBaEUsQ0FIc0UsRUFJdEU7RUFBRXpSLEtBQUssRUFBRSxRQUFUO0VBQW1Cd0YsS0FBSyxFQUFFNkksNEVBQTJCaEI7QUFBckQsQ0FKc0UsRUFLdEU7RUFBRXJOLEtBQUssRUFBRSxPQUFUO0VBQWtCd0YsS0FBSyxFQUFFNkksMkVBQTBCdUY7QUFBbkQsQ0FMc0UsQ0FBeEU7QUFRQSxNQUFNMlksZUFBMkQsR0FBRyxDQUNsRTtFQUFFdnNCLEtBQUssRUFBRSxLQUFUO0VBQWdCd0YsS0FBSyxFQUFFOEksdUVBQXNCZDtBQUE3QyxDQURrRSxFQUVsRTtFQUFFeE4sS0FBSyxFQUFFLFFBQVQ7RUFBbUJ3RixLQUFLLEVBQUU4SSwwRUFBeUJiO0FBQW5ELENBRmtFLEVBR2xFO0VBQUV6TixLQUFLLEVBQUUsZ0JBQVQ7RUFBMkJ3RixLQUFLLEVBQUU4SSw2RUFBNEIwQztBQUE5RCxDQUhrRSxFQUlsRTtFQUFFaFIsS0FBSyxFQUFFLFFBQVQ7RUFBbUJ3RixLQUFLLEVBQUU4SSwwRUFBeUJqQjtBQUFuRCxDQUprRSxFQUtsRTtFQUFFck4sS0FBSyxFQUFFLE9BQVQ7RUFBa0J3RixLQUFLLEVBQUU4SSx5RUFBd0JzRjtBQUFqRCxDQUxrRSxDQUFwRTtBQVFPLE1BQU00WSxlQUFnRixHQUFHLENBQUM7RUFBRXphO0FBQUYsQ0FBRCxLQUFjO0VBQUE7O0VBQzVHLE1BQU1sRyxRQUFRLEdBQUdrRyxJQUFJLENBQUNsRyxRQUF0QixDQUQ0RyxDQUc1Rzs7RUFDQTBaLHFEQUFhLENBQUMxWixRQUFRLFNBQVIsSUFBQUEsUUFBUSxXQUFSLElBQUFBLFFBQVEsQ0FBRTJELEtBQVYsR0FBa0IzRCxRQUFRLENBQUMyRCxLQUFULENBQWUyTixLQUFqQyxHQUF5QyxJQUFJbEUseUNBQUosRUFBMUMsQ0FBYjs7RUFFQSxJQUFJLENBQUNwTixRQUFMLEVBQWU7SUFDYixvQ0FBTztNQUFBO0lBQUEsRUFBUDtFQUNEOztFQUVELE1BQU10SixPQUFPLEdBQUdzSixRQUFRLENBQUN0SixPQUF6Qjs7RUFDQSxJQUFJLENBQUNBLE9BQUwsRUFBYztJQUNaLHNDQUFPO01BQUE7SUFBQSxFQUFQO0VBQ0Q7O0VBQ0QsTUFBTTtJQUFFeEM7RUFBRixJQUFjd0MsT0FBcEI7RUFDQSxNQUFNO0lBQUU2SSxTQUFGO0lBQWE2RSxVQUFVLEVBQUV3YztFQUF6QixJQUFvQzFzQixPQUExQzs7RUFFQSxNQUFNMnNCLDBCQUEwQixHQUFHLE1BQU07SUFDdkNyVSxVQUFVLENBQUMsTUFBTTtNQUNmeE0sUUFBUSxDQUFDMkQsS0FBVCxDQUFlekosTUFBZixDQUFzQjtRQUFFeVYsT0FBTyxFQUFFLENBQUNqWixPQUFPLENBQUMwUCxHQUFUO01BQVgsQ0FBdEI7SUFDRCxDQUZTLENBQVY7RUFHRCxDQUpEOztFQU1BLE1BQU0wYSw0QkFBNEIsR0FBSTFJLENBQUQsSUFBOEM7SUFDakYwRSw0QkFBNEIsQ0FBQzFFLENBQUMsQ0FBQ3plLEtBQUgsQ0FBNUI7RUFDRCxDQUZEOztFQUlBLE1BQU1takIsNEJBQTRCLEdBQUkxRSxDQUFELElBQTZCO0lBQ2hFMWhCLE9BQU8sQ0FBQ3hDLE9BQVIsQ0FBZ0JrUSxVQUFoQixDQUE0QnVCLFVBQTVCLEdBQXlDeVMsQ0FBekM7SUFDQTFoQixPQUFPLENBQUN3UiwwQkFBUjtJQUNBbEksUUFBUSxDQUFDMkQsS0FBVCxDQUFlaUYsS0FBZjtJQUNBNUksUUFBUSxDQUFDMkQsS0FBVCxDQUFlb0csSUFBZixDQUFvQixJQUFwQjtJQUNBOFcsMEJBQTBCO0VBQzNCLENBTkQ7O0VBUUEsTUFBTUUsMEJBQTBCLEdBQUk3cEIsQ0FBRCxJQUE0QztJQUM3RTJsQiwwQkFBMEIsQ0FBQzNsQixDQUFDLENBQUN5QyxLQUFILENBQTFCO0VBQ0QsQ0FGRDs7RUFJQSxNQUFNa2pCLDBCQUEwQixHQUFJM2xCLENBQUQsSUFBMkI7SUFDNURSLE9BQU8sQ0FBQ3hDLE9BQVIsQ0FBZ0JrUSxVQUFoQixDQUE0QmMsUUFBNUIsR0FBdUNoTyxDQUF2QztJQUNBUixPQUFPLENBQUN3UiwwQkFBUjtJQUNBbEksUUFBUSxDQUFDMkQsS0FBVCxDQUFlaUYsS0FBZjtJQUNBNUksUUFBUSxDQUFDMkQsS0FBVCxDQUFlb0csSUFBZixDQUFvQixJQUFwQjtJQUNBOFcsMEJBQTBCO0VBQzNCLENBTkQ7O0VBUUEsTUFBTUcsZ0JBQWdCLEdBQUcsQ0FBQ3JuQixLQUFELEVBQTRCNEYsU0FBNUIsS0FBMkQ7SUFDbEY3SSxPQUFPLENBQUN4QyxPQUFSLENBQWdCcUwsU0FBaEIsQ0FBMkJBLFNBQTNCLElBQXdDNUYsS0FBeEMsYUFBd0NBLEtBQXhDLGNBQXdDQSxLQUF4QyxHQUFpRGpELE9BQU8sQ0FBQ3hDLE9BQVIsQ0FBZ0JxTCxTQUFoQixDQUEyQkEsU0FBM0IsQ0FBakQ7SUFDQTdJLE9BQU8sQ0FBQzJQLHNCQUFSO0lBQ0FyRyxRQUFRLENBQUMyRCxLQUFULENBQWU0SSxxQkFBZixDQUFxQyxJQUFyQztJQUNBc1UsMEJBQTBCO0VBQzNCLENBTEQ7O0VBT0EsTUFBTXpjLFVBQVUsb0NBQUcxTixPQUFPLENBQUMyTixjQUFYLHlFQUE2QnVjLE1BQTdCLHVDQUF1QyxFQUF2RDtFQUVBLG9CQUNFO0lBQUEsd0JBQ0UsdURBQUMsK0RBQUQ7TUFBa0IsZ0JBQWdCLEVBQUVJLGdCQUFwQztNQUFzRCxRQUFRLEVBQUVoaEIsUUFBaEU7TUFBMEUsT0FBTyxFQUFFdEo7SUFBbkYsRUFERiw2QkFFRSxnRUFGRixnQkFHRSx1REFBQyw4Q0FBRDtNQUFPLEtBQUssRUFBQyxhQUFiO01BQUEsdUJBQ0Usd0RBQUMsd0RBQUQ7UUFBQSx3QkFDRSx1REFBQywyRUFBRDtVQUNFLDBCQUEwQixFQUFFbW1CLDBCQUQ5QjtVQUVFLDRCQUE0QixFQUFFQyw0QkFGaEM7VUFHRSxrQkFBa0IsRUFBRTFZO1FBSHRCLEVBREYsZUFNRSx3REFBQyxzREFBRDtVQUFBLHdCQUNFLHVEQUFDLCtDQUFEO1lBQVEsT0FBTyxFQUFFc2MsZUFBakI7WUFBa0MsUUFBUSxFQUFFSywwQkFBNUM7WUFBd0UsS0FBSyxFQUFFM2MsVUFBVSxDQUFDYztVQUExRixFQURGLGVBRUUsdURBQUMsK0NBQUQ7WUFBUSxPQUFPLEVBQUV1YixpQkFBakI7WUFBb0MsUUFBUSxFQUFFSyw0QkFBOUM7WUFBNEUsS0FBSyxFQUFFMWMsVUFBVSxDQUFDdUI7VUFBOUYsRUFGRjtRQUFBLEVBTkY7TUFBQTtJQURGLEVBSEYsK0JBaUJFLGdFQWpCRixnQkFtQkUsdURBQUMsOENBQUQ7TUFBTyxLQUFLLEVBQUMsVUFBYjtNQUFBLHVCQUNFO1FBQUEsVUFDRzZhLE1BQU0sQ0FBQzVULEdBQVAsQ0FBWXFVLENBQUQsSUFBTztVQUNqQixNQUFNL3BCLENBQUMsR0FBR3FJLFNBQVMsQ0FBRTBoQixDQUFGLENBQW5COztVQUNBLElBQUkvcEIsQ0FBQyxJQUFJLElBQVQsRUFBZTtZQUNiLE9BQU8sSUFBUDtVQUNEOztVQUNELG9CQUNFLHVEQUFDLHVEQUFEO1lBQUEsdUJBQ0UsdURBQUMsb0RBQUQ7Y0FBYSxLQUFLLEVBQUUrcEIsQ0FBcEI7Y0FBdUIsVUFBVSxFQUFFLENBQW5DO2NBQXNDLElBQUksRUFBRSxJQUE1QztjQUFBLHVCQUNFLHVEQUFDLGtGQUFEO2dCQUFhLEtBQUssRUFBRS9wQixDQUFwQjtnQkFBdUIsUUFBUSxFQUFHQSxDQUFELElBQU84cEIsZ0JBQWdCLENBQUM5cEIsQ0FBRCxFQUFJK3BCLENBQUo7Y0FBeEQ7WUFERjtVQURGLEdBQXFCQSxDQUFyQixDQURGO1FBT0QsQ0FaQTtNQURIO0lBREYsRUFuQkY7RUFBQSxFQURGO0FBdUNELENBL0ZNOzs7Ozs7Ozs7Ozs7Ozs7O0FDakNQO0FBQ0E7QUFHQTtBQUNBOzs7QUFXTyxNQUFNVixnQkFBZ0IsR0FBRyxDQUFDO0VBQUVTLGdCQUFGO0VBQW9CdHFCLE9BQXBCO0VBQTZCc0o7QUFBN0IsQ0FBRCxLQUFvRDtFQUNsRixNQUFNckssTUFBTSxHQUFHOEcsMkRBQVUsQ0FBQ3pELFNBQUQsQ0FBekI7O0VBRUEsTUFBTWtvQix3QkFBd0IsR0FBSW5lLFFBQUQsSUFBOEI7SUFBQTs7SUFDN0QsTUFBTW9lLGlCQUFpQixHQUFHO01BQUVqYyxRQUFRLEVBQUV6Qyx1RUFBWjtNQUFvQ2tELFVBQVUsRUFBRW5ELDBFQUF5QmxCO0lBQXpFLENBQTFCO0lBQ0EsTUFBTThmLGtCQUFrQixxQkFBUTFxQixPQUFPLENBQUN4QyxPQUFSLENBQWdCa1EsVUFBeEIsQ0FBeEI7SUFFQTFOLE9BQU8sQ0FBQ3hDLE9BQVIsQ0FBZ0JrUSxVQUFoQixHQUE2QitjLGlCQUE3QjtJQUNBenFCLE9BQU8sQ0FBQ3dSLDBCQUFSOztJQUVBLFFBQVFuRixRQUFSO01BQ0UsS0FBS2tRLG1FQUFMO1FBQ0UrTixnQkFBZ0IsQ0FBQyxDQUFELEVBQUksS0FBSixDQUFoQjtRQUNBOztNQUNGLEtBQUsvTixzRUFBTDtRQUNFK04sZ0JBQWdCLENBQUNLLHNCQUFzQixvREFBQzNxQixPQUFPLENBQUN4QyxPQUFSLENBQWdCcUwsU0FBakIsMkRBQUMsdUJBQTJCMUQsTUFBNUIseUVBQXNDLENBQXRDLEVBQXlDLFFBQXpDLENBQXZCLEVBQTJFLEtBQTNFLENBQWhCO1FBQ0E7O01BQ0YsS0FBS29YLDhFQUFMO1FBQ0UrTixnQkFBZ0IsQ0FBQ08saUJBQWlCLHFEQUFDN3FCLE9BQU8sQ0FBQ3hDLE9BQVIsQ0FBZ0JxTCxTQUFqQiwyREFBQyx1QkFBMkIxRCxNQUE1QiwyRUFBc0MsQ0FBdEMsRUFBeUMsR0FBekMsQ0FBbEIsRUFBaUUsS0FBakUsQ0FBaEI7UUFDQTs7TUFDRixLQUFLb1gsb0VBQUw7UUFDRStOLGdCQUFnQixDQUFDLENBQUQsRUFBSSxNQUFKLENBQWhCO1FBQ0E7O01BQ0YsS0FBSy9OLHFFQUFMO1FBQ0UrTixnQkFBZ0IsQ0FBQ0ssc0JBQXNCLHFEQUFDM3FCLE9BQU8sQ0FBQ3hDLE9BQVIsQ0FBZ0JxTCxTQUFqQiwyREFBQyx1QkFBMkIzRCxLQUE1QiwyRUFBcUMsQ0FBckMsRUFBd0MsT0FBeEMsQ0FBdkIsRUFBeUUsTUFBekUsQ0FBaEI7UUFDQTs7TUFDRixLQUFLcVgsZ0ZBQUw7UUFDRStOLGdCQUFnQixDQUFDTyxpQkFBaUIscURBQUM3cUIsT0FBTyxDQUFDeEMsT0FBUixDQUFnQnFMLFNBQWpCLDJEQUFDLHVCQUEyQjNELEtBQTVCLDJFQUFxQyxDQUFyQyxFQUF3QyxHQUF4QyxDQUFsQixFQUFnRSxNQUFoRSxDQUFoQjtRQUNBO0lBbEJKOztJQXFCQWxGLE9BQU8sQ0FBQ3hDLE9BQVIsQ0FBZ0JrUSxVQUFoQixHQUE2QmdkLGtCQUE3QjtJQUNBMXFCLE9BQU8sQ0FBQ3dSLDBCQUFSO0VBQ0QsQ0E5QkQsQ0FIa0YsQ0FtQ2xGOzs7RUFDQSxNQUFNcVosaUJBQWlCLEdBQUcsQ0FBQ0UsV0FBRCxFQUFzQnZnQixLQUF0QixLQUEyQztJQUNuRSxNQUFNd2dCLFNBQVMsR0FBR3hnQixLQUFLLEtBQUssR0FBVixHQUFnQmxCLFFBQVEsQ0FBQzJELEtBQVQsQ0FBZS9ILEtBQS9CLEdBQXVDb0UsUUFBUSxDQUFDMkQsS0FBVCxDQUFlOUgsTUFBeEU7SUFFQSxPQUFPLENBQUM2bEIsU0FBUyxHQUFHRCxXQUFiLElBQTRCLENBQW5DO0VBQ0QsQ0FKRDs7RUFNQSxNQUFNSixzQkFBc0IsR0FBRyxDQUFDSSxXQUFELEVBQXNCdmdCLEtBQXRCLEtBQW9EO0lBQ2pGLE1BQU13Z0IsU0FBUyxHQUFHeGdCLEtBQUssS0FBSyxPQUFWLEdBQW9CbEIsUUFBUSxDQUFDMkQsS0FBVCxDQUFlL0gsS0FBbkMsR0FBMkNvRSxRQUFRLENBQUMyRCxLQUFULENBQWU5SCxNQUE1RTtJQUVBLE9BQU82bEIsU0FBUyxHQUFHRCxXQUFuQjtFQUNELENBSkQ7O0VBTUEsb0JBQ0U7SUFBSyxTQUFTLEVBQUU5ckIsTUFBTSxDQUFDZ3NCLFdBQXZCO0lBQUEsd0JBQ0UsdURBQUMsdURBQUQ7TUFDRSxJQUFJLEVBQUUsdUJBRFI7TUFFRSxPQUFPLEVBQUUsTUFBTVQsd0JBQXdCLENBQUNqTyxvRUFBRCxDQUZ6QztNQUdFLFNBQVMsRUFBRXRkLE1BQU0sQ0FBQ2lzQixNQUhwQjtNQUlFLElBQUksRUFBRSxJQUpSO01BS0UsT0FBTyxFQUFFO0lBTFgsRUFERixlQVFFLHVEQUFDLHVEQUFEO01BQ0UsSUFBSSxFQUFFLHlCQURSO01BRUUsT0FBTyxFQUFFLE1BQU1WLHdCQUF3QixDQUFDak8sZ0ZBQUQsQ0FGekM7TUFHRSxTQUFTLEVBQUV0ZCxNQUFNLENBQUNpc0IsTUFIcEI7TUFJRSxJQUFJLEVBQUUsSUFKUjtNQUtFLE9BQU8sRUFBRTtJQUxYLEVBUkYsZUFlRSx1REFBQyx1REFBRDtNQUNFLElBQUksRUFBRSx3QkFEUjtNQUVFLE9BQU8sRUFBRSxNQUFNVix3QkFBd0IsQ0FBQ2pPLHFFQUFELENBRnpDO01BR0UsU0FBUyxFQUFFdGQsTUFBTSxDQUFDaXNCLE1BSHBCO01BSUUsSUFBSSxFQUFFLElBSlI7TUFLRSxPQUFPLEVBQUU7SUFMWCxFQWZGLGVBc0JFLHVEQUFDLHVEQUFEO01BQ0UsSUFBSSxFQUFFLG9CQURSO01BRUUsT0FBTyxFQUFFLE1BQU1WLHdCQUF3QixDQUFDak8sbUVBQUQsQ0FGekM7TUFHRSxJQUFJLEVBQUUsSUFIUjtNQUlFLE9BQU8sRUFBRTtJQUpYLEVBdEJGLGVBNEJFLHVEQUFDLHVEQUFEO01BQ0UsSUFBSSxFQUFFLHVCQURSO01BRUUsT0FBTyxFQUFFLE1BQU1pTyx3QkFBd0IsQ0FBQ2pPLDhFQUFELENBRnpDO01BR0UsU0FBUyxFQUFFdGQsTUFBTSxDQUFDaXNCLE1BSHBCO01BSUUsSUFBSSxFQUFFLElBSlI7TUFLRSxPQUFPLEVBQUU7SUFMWCxFQTVCRixlQW1DRSx1REFBQyx1REFBRDtNQUNFLElBQUksRUFBRSx1QkFEUjtNQUVFLE9BQU8sRUFBRSxNQUFNVix3QkFBd0IsQ0FBQ2pPLHNFQUFELENBRnpDO01BR0UsU0FBUyxFQUFFdGQsTUFBTSxDQUFDaXNCLE1BSHBCO01BSUUsSUFBSSxFQUFFLElBSlI7TUFLRSxPQUFPLEVBQUU7SUFMWCxFQW5DRjtFQUFBLEVBREY7QUE2Q0QsQ0E3Rk07O0FBK0ZQLE1BQU01b0IsU0FBUyxHQUFJcEQsS0FBRCxLQUEyQjtFQUMzQytyQixXQUFXLEVBQUV2dEIsNkNBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsR0FMNkM7RUFNM0N3dEIsTUFBTSxFQUFFeHRCLDZDQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBVDZDLENBQTNCLENBQWxCOzs7Ozs7Ozs7Ozs7Ozs7OztBQy9HQTtBQUdBO0FBR0E7QUFFQTtBQUNBO0FBUU8sU0FBUzBsQixnQkFBVCxDQUEwQjNPLElBQTFCLEVBQStGO0VBQ3BHLE9BQU87SUFDTDlPLFFBQVEsRUFBRThPLElBQUksQ0FBQzlPLFFBRFY7SUFFTEUsSUFBSSxFQUFFLElBRkQ7SUFFTztJQUVaO0lBQ0F1bEIsTUFBTSxFQUFHM2IsTUFBRCxLQUFnQztNQUN0QzRVLFFBQVEsRUFBR3hlLElBQUQsSUFBa0I7UUFDMUIsT0FBT2lkLDJDQUFTLENBQUNyTyxJQUFJLENBQUN6VSxPQUFMLENBQWF4QyxPQUFkLEVBQXVCcUksSUFBdkIsQ0FBaEI7TUFDRCxDQUhxQztNQUl0Q3RJLFFBQVEsRUFBRSxDQUFDc0ksSUFBRCxFQUFlNUMsS0FBZixLQUE4QjtRQUN0QyxJQUFJekYsT0FBTyxHQUFHaVgsSUFBSSxDQUFDelUsT0FBTCxDQUFheEMsT0FBM0I7O1FBQ0EsSUFBSXFJLElBQUksS0FBSyxNQUFULElBQW1CNUMsS0FBdkIsRUFBOEI7VUFDNUIsTUFBTTBjLEtBQUssR0FBRzlULGtGQUFBLENBQWtDNUksS0FBbEMsQ0FBZDs7VUFDQSxJQUFJLENBQUMwYyxLQUFMLEVBQVk7WUFDVnBMLE9BQU8sQ0FBQ3NVLElBQVIsQ0FBYSxzQkFBYixFQUFxQzVsQixLQUFyQztZQUNBO1VBQ0Q7O1VBQ0R6RixPQUFPLHFCQUNGQSxPQURFLEVBRUZtaUIsS0FBSyxDQUFDdmEsYUFBTixDQUFvQjVILE9BQXBCLENBRkU7WUFHTG9PLElBQUksRUFBRStULEtBQUssQ0FBQzdhO1VBSFAsRUFBUDtRQUtELENBWEQsTUFXTztVQUNMdEgsT0FBTyxHQUFHMmxCLHVHQUFrQixDQUFDM2xCLE9BQUQsRUFBVXFJLElBQVYsRUFBZ0I1QyxLQUFoQixDQUE1QjtRQUNEOztRQUNEd1IsSUFBSSxDQUFDelUsT0FBTCxDQUFhekMsUUFBYixDQUFzQkMsT0FBdEI7UUFDQWlYLElBQUksQ0FBQ3pVLE9BQUwsQ0FBYW1TLFVBQWIsQ0FBd0JzQyxJQUFJLENBQUN4SCxLQUFMLENBQVcySCxPQUFuQztNQUNEO0lBdEJxQyxDQUFoQyxDQUxIO0lBOEJMO0lBQ0F5VyxLQUFLLEVBQUUsQ0FBQzNsQixPQUFELEVBQVVrUCxPQUFWLEtBQXNCO01BQUE7O01BQzNCLE1BQU07UUFBRXBYO01BQUYsSUFBY2lYLElBQUksQ0FBQ3pVLE9BQXpCO01BQ0EsTUFBTXNyQixVQUFVLEdBQUd6ZixvRkFBQSxDQUNqQnJPLE9BQU8sU0FBUCxJQUFBQSxPQUFPLFdBQVAsSUFBQUEsT0FBTyxDQUFFb08sSUFBVCxDQUFjO01BQWQsRUFDSSxDQUFDcE8sT0FBTyxDQUFDb08sSUFBVCxDQURKLENBQ21CO01BRG5CLEVBRUksQ0FBQ0QsbUZBQUQsQ0FIYSxDQUFuQjtNQU1BakcsT0FBTyxDQUFDNmxCLFNBQVIsQ0FBa0I7UUFDaEIxbEIsSUFBSSxFQUFFLE1BRFU7UUFFaEJ4RCxJQUFJLEVBQUU1QixTQUZVO1FBRVE7UUFDeEI2SSxRQUFRLEVBQUU7VUFDUjlMLE9BQU8sRUFBRTh0QixVQUFVLENBQUM5dEI7UUFEWjtNQUhNLENBQWxCLEVBUjJCLENBZ0IzQjs7TUFDQSxNQUFNbWlCLEtBQUssR0FBRzlULGtGQUFBLGtCQUFrQ3JPLE9BQWxDLGFBQWtDQSxPQUFsQyx1QkFBa0NBLE9BQU8sQ0FBRW9PLElBQTNDLHlEQUFtREQsbUZBQW5ELENBQWQ7TUFDQSxJQUFJNmYsY0FBYyxHQUFHaHVCLE9BQXJCOztNQUNBLElBQUksQ0FBQ2d1QixjQUFMLEVBQXFCO1FBQ25CQSxjQUFjLHFCQUNUN0wsS0FBSyxDQUFDdmEsYUFBTixDQUFvQjVILE9BQXBCLENBRFM7VUFFWm9PLElBQUksRUFBRStULEtBQUssQ0FBQzdhLEVBRkE7VUFHWnpDLElBQUksRUFBRyxXQUFVdU8sSUFBSSxDQUFDQyxHQUFMLEVBQVcsSUFBRzdKLElBQUksQ0FBQ3lrQixLQUFMLENBQVd6a0IsSUFBSSxDQUFDMGtCLE1BQUwsS0FBZ0IsR0FBM0IsQ0FBZ0M7UUFIbkQsRUFBZDtNQUtEOztNQUNELE1BQU1wbUIsR0FBRyxxQkFBUXNQLE9BQVI7UUFBaUJwWCxPQUFPLEVBQUVndUI7TUFBMUIsRUFBVDs7TUFFQSxJQUFJN0wsS0FBSixhQUFJQSxLQUFKLGVBQUlBLEtBQUssQ0FBRWxhLGlCQUFYLEVBQThCO1FBQzVCa2EsS0FBSyxDQUFDbGEsaUJBQU4sQ0FBd0JDLE9BQXhCLEVBQWlDSixHQUFqQztNQUNEOztNQUVENmxCLGlFQUFBLENBQTRCemxCLE9BQTVCLEVBQXFDSixHQUFyQztNQUNBNmxCLDZEQUFBLENBQXdCemxCLE9BQXhCLEVBQWlDSixHQUFqQztNQUVBSSxPQUFPLENBQUNFLGVBQVIsQ0FBd0I7UUFDdEJELFFBQVEsRUFBRSxDQUFDLFFBQUQsQ0FEWTtRQUV0QmIsRUFBRSxFQUFFLFNBRmtCO1FBR3RCZSxJQUFJLEVBQUUsSUFIZ0I7UUFHVjtRQUNaeEQsSUFBSSxFQUFFLGlCQUpnQjtRQUt0QnlELE1BQU0sRUFBRW1rQiw2REFMYztRQU10QjNnQixRQUFRLEVBQUVtTDtNQU5ZLENBQXhCO0lBUUQ7RUExRUksQ0FBUDtBQTRFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUZEO0FBSUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQVFPLFNBQVM0TyxjQUFULENBQXdCNU8sSUFBeEIsRUFBbUY7RUFDeEYsTUFBTTtJQUFFNEYsUUFBRjtJQUFZcE47RUFBWixJQUFzQndILElBQTVCOztFQUVBLElBQUksQ0FBQ3hILEtBQUssQ0FBQ3NPLFlBQVgsRUFBeUI7SUFDdkJ0TyxLQUFLLENBQUNzTyxZQUFOLEdBQXFCdE8sS0FBSyxDQUFDd0wsSUFBM0I7RUFDRDs7RUFFRCxJQUFJNEIsUUFBSixFQUFjO0lBQ1osS0FBSyxNQUFNcmEsT0FBWCxJQUFzQnFhLFFBQXRCLEVBQWdDO01BQzlCLElBQUlyYSxPQUFPLFlBQVk2VCx5RUFBdkIsRUFBbUM7UUFDakM1RyxLQUFLLENBQUNzTyxZQUFOLEdBQXFCdmIsT0FBckI7UUFDQTtNQUNEOztNQUVELElBQUlBLE9BQU8sQ0FBQ3lQLE1BQVosRUFBb0I7UUFDbEJ4QyxLQUFLLENBQUNzTyxZQUFOLEdBQXFCdmIsT0FBTyxDQUFDeVAsTUFBN0I7UUFDQTtNQUNEO0lBQ0Y7RUFDRjs7RUFFRCxNQUFNalMsT0FBTyxHQUFHeVAsS0FBSyxDQUFDc08sWUFBTixDQUFtQi9kLE9BQW5CLElBQThCO0lBQUUwVyxRQUFRLEVBQUU7RUFBWixDQUE5QztFQUVBLE9BQU87SUFDTHZPLFFBQVEsRUFBRSxDQUFDLE9BQUQsQ0FETDtJQUVMRSxJQUFJLEVBQUUsSUFGRDtJQUVPO0lBRVo7SUFDQXVsQixNQUFNLEVBQUczYixNQUFELEtBQWdDO01BQ3RDNFUsUUFBUSxFQUFHeGUsSUFBRCxJQUFrQjtRQUMxQixPQUFPaWQsMkNBQVMsQ0FBQ3RsQixPQUFELEVBQVVxSSxJQUFWLENBQWhCO01BQ0QsQ0FIcUM7TUFJdEN0SSxRQUFRLEVBQUUsQ0FBQ3NJLElBQUQsRUFBZTVDLEtBQWYsS0FBOEI7UUFBQTs7UUFDdEMsSUFBSTRDLElBQUksS0FBSyxNQUFULElBQW1CNUMsS0FBdkIsRUFBOEI7VUFDNUJzUixPQUFPLENBQUNzVSxJQUFSLENBQWEsNkJBQWI7VUFDQTtRQUNEOztRQUNELE1BQU03VCxDQUFDLEdBQUdtTyx1R0FBa0IsQ0FBQzNsQixPQUFELEVBQVVxSSxJQUFWLEVBQWdCNUMsS0FBaEIsQ0FBNUI7UUFDQSx1QkFBQWdLLEtBQUssQ0FBQ3NPLFlBQU4sNEVBQW9CaGUsUUFBcEIsQ0FBNkJ5WCxDQUE3QjtRQUNBLHdCQUFBL0gsS0FBSyxDQUFDc08sWUFBTiw4RUFBb0JwSixVQUFwQixDQUErQmxGLEtBQUssQ0FBQzJILE9BQXJDO01BQ0Q7SUFacUMsQ0FBaEMsQ0FMSDtJQW9CTDtJQUNBeVcsS0FBSyxFQUFFLENBQUMzbEIsT0FBRCxFQUFVa1AsT0FBVixLQUFzQjtNQUMzQixNQUFNMkcsWUFBWSxHQUFHdE8sS0FBSyxDQUFDc08sWUFBM0I7O01BQ0EsSUFBSUEsWUFBWSxJQUFJLENBQUNBLFlBQVksQ0FBQ3JLLE1BQWIsRUFBckIsRUFBNEMsQ0FDMUM7TUFDRDs7TUFFRHhMLE9BQU8sQ0FBQ0UsZUFBUixDQUF3QjtRQUN0QmQsRUFBRSxFQUFFLFNBRGtCO1FBRXRCZSxJQUFJLEVBQUUsTUFGZ0I7UUFHdEJ4RCxJQUFJLEVBQUUsVUFIZ0I7UUFJdEJ5RCxNQUFNLEVBQUU4aEIsMkVBSmM7UUFLdEJ0ZSxRQUFRLEVBQUU7VUFBRTJELEtBQUY7VUFBUzBTLEtBQUssRUFBRTFTLEtBQUssQ0FBQ3NPLFlBQXRCO1VBQW9DbEI7UUFBcEM7TUFMWSxDQUF4QjtNQVFBLE1BQU0vVSxHQUFHLHFCQUFRc1AsT0FBUjtRQUFpQnBYO01BQWpCLEVBQVQ7TUFDQTJ0QixpRUFBQSxDQUE0QnpsQixPQUE1QixFQUE0Q0osR0FBNUM7TUFDQTZsQiw2REFBQSxDQUF3QnpsQixPQUF4QixFQUF3Q0osR0FBeEM7O01BRUEsSUFBSWlXLFlBQVksSUFBSSxDQUFDQSxZQUFZLENBQUNySyxNQUFiLEVBQXJCLEVBQTRDO1FBQzFDeEwsT0FBTyxDQUFDRSxlQUFSLENBQXdCO1VBQ3RCRCxRQUFRLEVBQUUsQ0FBQyxRQUFELENBRFk7VUFFdEJiLEVBQUUsRUFBRSxTQUZrQjtVQUd0QmUsSUFBSSxFQUFFLElBSGdCO1VBR1Y7VUFDWnhELElBQUksRUFBRSxhQUpnQjtVQUt0QnlELE1BQU0sRUFBRW1rQiw2REFMYztVQU10QjNnQixRQUFRLEVBQUU7WUFDUjJELEtBQUssRUFBRXdILElBQUksQ0FBQ3hILEtBREo7WUFFUmpOLE9BQU8sRUFBRXViO1VBRkQ7UUFOWSxDQUF4QjtNQVdEO0lBQ0Y7RUFwREksQ0FBUDtBQXNERDs7Ozs7Ozs7Ozs7OztBQ2hHRDtBQUNBO0FBT08sTUFBTTRQLGFBQThCLEdBQUc7RUFDNUNRLGFBQWEsRUFBRSxDQUFDam1CLE9BQUQsRUFBVWtQLE9BQVYsS0FBc0I7SUFDbkMsTUFBTWpQLFFBQVEsR0FBRyxDQUFDLFlBQUQsQ0FBakI7SUFDQUQsT0FBTyxDQUNKRSxlQURILENBQ21CO01BQ2ZELFFBRGU7TUFFZmIsRUFBRSxFQUFFLGtCQUZXO01BR2ZlLElBQUksRUFBRSxrQkFIUztNQUlmeEQsSUFBSSxFQUFFLE9BSlM7TUFLZnlELE1BQU0sRUFBRXFDLGlGQUxPO01BTWZtQixRQUFRLEVBQUUsRUFOSztNQU9mRSxZQUFZLEVBQUU7UUFDWjtRQUNBTixLQUFLLEVBQUU7TUFGSztJQVBDLENBRG5CLEVBYUd0RCxlQWJILENBYW1CO01BQ2ZELFFBRGU7TUFFZmIsRUFBRSxFQUFFLGtCQUZXO01BR2ZlLElBQUksRUFBRSxrQkFIUztNQUlmeEQsSUFBSSxFQUFFLE9BSlM7TUFLZnlELE1BQU0sRUFBRXNDLG9GQUxPO01BTWZrQixRQUFRLEVBQUU7UUFDUkMsWUFBWSxFQUFFO01BRE47SUFOSyxDQWJuQixFQXVCR3dCLFFBdkJILENBdUJZO01BQ1JwRixRQURRO01BRVJFLElBQUksRUFBRSxpQkFGRTtNQUdSeEQsSUFBSSxFQUFFLFlBSEU7TUFJUmlILFFBQVEsRUFBRTtRQUNSOUwsT0FBTyxFQUFFLENBQ1A7VUFBRXlGLEtBQUssRUFBRW1NLDZFQUFUO1VBQXVDM1IsS0FBSyxFQUFFO1FBQTlDLENBRE8sRUFFUDtVQUFFd0YsS0FBSyxFQUFFbU0sNEVBQVQ7VUFBc0MzUixLQUFLLEVBQUU7UUFBN0MsQ0FGTyxFQUdQO1VBQUV3RixLQUFLLEVBQUVtTSwwRUFBVDtVQUFvQzNSLEtBQUssRUFBRTtRQUEzQyxDQUhPLEVBSVA7VUFBRXdGLEtBQUssRUFBRW1NLHlFQUFUO1VBQW1DM1IsS0FBSyxFQUFFO1FBQTFDLENBSk8sRUFLUDtVQUFFd0YsS0FBSyxFQUFFbU0seUVBQVQ7VUFBbUMzUixLQUFLLEVBQUU7UUFBMUMsQ0FMTztNQURELENBSkY7TUFhUitMLFlBQVksRUFBRTRGLDBFQUF5QnNEO0lBYi9CLENBdkJaO0VBc0NELENBekMyQztFQTJDNUNrWixTQUFTLEVBQUUsQ0FBQ2xtQixPQUFELEVBQVVrUCxPQUFWLEtBQXNCO0lBQUE7O0lBQy9CLE1BQU1qUCxRQUFRLEdBQUcsQ0FBQyxRQUFELENBQWpCO0lBQ0FELE9BQU8sQ0FBQytELGNBQVIsQ0FBdUI7TUFDckI5RCxRQURxQjtNQUVyQkUsSUFBSSxFQUFFLGNBRmU7TUFHckJ4RCxJQUFJLEVBQUUsT0FIZTtNQUlyQm1ILFlBQVksRUFBRSxDQUpPO01BS3JCRixRQUFRLEVBQUU7UUFDUkksR0FBRyxFQUFFLENBREc7UUFFUkMsR0FBRyxFQUFFO01BRkc7SUFMVyxDQUF2Qjs7SUFXQSx3QkFBSWlMLE9BQU8sQ0FBQ3BYLE9BQVosc0VBQUksaUJBQWlCNkQsTUFBckIsa0RBQUksc0JBQXlCNkQsS0FBN0IsRUFBb0M7TUFDbENRLE9BQU8sQ0FBQ0UsZUFBUixDQUF3QjtRQUN0QkQsUUFEc0I7UUFFdEJiLEVBQUUsRUFBRSxjQUZrQjtRQUd0QmUsSUFBSSxFQUFFLGNBSGdCO1FBSXRCeEQsSUFBSSxFQUFFLE9BSmdCO1FBS3RCeUQsTUFBTSxFQUFFcUMsaUZBTGM7UUFNdEJtQixRQUFRLEVBQUUsRUFOWTtRQU90QkUsWUFBWSxFQUFFO1VBQ1o7VUFDQU4sS0FBSyxFQUFFO1FBRks7TUFQUSxDQUF4QjtJQVlEO0VBQ0Y7QUF0RTJDLENBQXZDOzs7Ozs7Ozs7Ozs7Ozs7O0FDVFA7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdPLE1BQU00aUIsTUFBTSxHQUFHLElBQUlELHNEQUFKLENBQThCdE4scURBQTlCLEVBQ25Cd04sWUFEbUIsR0FDSjtBQURJLENBRW5CQyxjQUZtQixHQUduQkMsZUFIbUIsQ0FHSCxDQUFDdm1CLE9BQUQsRUFBVWtQLE9BQVYsS0FBc0I7RUFDckMsTUFBTXhILEtBQW9CLEdBQUd3SCxPQUFPLENBQUMyTyxhQUFyQztFQUVBN2QsT0FBTyxDQUFDd21CLGdCQUFSLENBQXlCO0lBQ3ZCcm1CLElBQUksRUFBRSxlQURpQjtJQUV2QnhELElBQUksRUFBRSxnQkFGaUI7SUFHdkIwQyxXQUFXLEVBQUUsbUNBSFU7SUFJdkJ5RSxZQUFZLEVBQUU7RUFKUyxDQUF6Qjs7RUFPQSxJQUFJNEQsS0FBSixFQUFXO0lBQ1QxSCxPQUFPLENBQUNpZSxnQkFBUixDQUF5Qk4sbUVBQWMsQ0FBQ2pXLEtBQUQsQ0FBdkM7SUFFQSxNQUFNeE8sU0FBUyxHQUFHd08sS0FBSyxDQUFDaU4sUUFBeEI7O0lBQ0EsSUFBSSxDQUFBemIsU0FBUyxTQUFULElBQUFBLFNBQVMsV0FBVCxZQUFBQSxTQUFTLENBQUVtQixNQUFYLE1BQXNCLENBQTFCLEVBQTZCO01BQzNCLE1BQU1DLE9BQU8sR0FBR3BCLFNBQVMsQ0FBQyxDQUFELENBQXpCOztNQUNBLElBQUksRUFBRW9CLE9BQU8sWUFBWTZULHlFQUFyQixDQUFKLEVBQXNDO1FBQ3BDbk8sT0FBTyxDQUFDaWUsZ0JBQVIsQ0FDRVAsdUVBQWdCLENBQUM7VUFDZnpkLFFBQVEsRUFBRSxDQUFFLHFCQUFvQjNGLE9BQU8sQ0FBQ3hDLE9BQVIsQ0FBZ0I2RSxJQUFLLEdBQTNDLENBREs7VUFFZnJDLE9BRmU7VUFHZmlOLEtBQUssRUFBRUcsS0FBSyxDQUFDSDtRQUhFLENBQUQsQ0FEbEI7TUFPRDtJQUNGO0VBQ0Y7QUFDRixDQTlCbUIsQ0FBZjs7Ozs7Ozs7Ozs7QUNSQSxJQUFLMEcsYUFBWjs7V0FBWUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7R0FBQUEsa0JBQUFBOzs7Ozs7Ozs7Ozs7QUNBWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsR0FBRyxNQUFNLFNBQVM7QUFDOUM7QUFDQSw4QkFBOEIsMkRBQVU7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSyxrQkFBa0I7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxNQUFNLEVBQUM7QUFDdEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUM7QUFDOEM7QUFDK1U7QUFDbEc7QUFDclA7QUFDWjtBQUMrQjtBQUNqRDtBQUNFO0FBQ087QUFDMUI7QUFDbUI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7O0FBRXhELHVDQUF1QyxRQUFRLHNEQUFzRCxRQUFROztBQUU3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixNQUFNO0FBQ047OztBQUdBOztBQUVBO0FBQ0EsUUFBUSx5REFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyx5REFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxvQkFBb0IsMERBQVM7QUFDN0I7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRIQUE0SCxjQUFjO0FBQzFJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJLHlDQUF5QyxRQUFRO0FBQ2xMO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkLG1CQUFtQjtBQUNuQjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDZCQUE2QiwyWEFBMlg7QUFDeFo7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7OztBQUdKLDJDQUEyQyxpRUFBaUU7QUFDNUc7O0FBRUEsWUFBWSx1REFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSx1QkFBdUIsdUJBQXVCLGVBQWUsZ0JBQWdCLFlBQVksV0FBVyxvQkFBb0IsNkJBQTZCLGdCQUFnQixvQkFBb0IsNkJBQTZCLEdBQUcsZ0JBQWdCLGlCQUFpQixHQUFHLG1CQUFtQix5QkFBeUIsWUFBWSxhQUFhLDZCQUE2QixHQUFHLFlBQVksZ0JBQWdCLGlCQUFpQix1QkFBdUIsMkJBQTJCLDJCQUEyQix1QkFBdUIsd0NBQXdDLHFCQUFxQix3QkFBd0IsNkJBQTZCLGtCQUFrQixHQUFHLFlBQVkseUJBQXlCLGVBQWUsZ0JBQWdCLG1CQUFtQixvQkFBb0IsNEJBQTRCLEdBQUcsU0FBUyxlQUFlLGtCQUFrQix1QkFBdUIsd0NBQXdDLDhCQUE4QixHQUFHLGdCQUFnQiw2QkFBNkIsOEJBQThCLEdBQUcsMkJBQTJCLGtDQUFrQyw2QkFBNkIsOENBQThDLEdBQUcseUJBQXlCLG1DQUFtQyw4QkFBOEIsK0NBQStDLEdBQUcsa0JBQWtCLGtDQUFrQyxHQUFHLG9CQUFvQixrQ0FBa0MsR0FBRyx1QkFBdUIsaUJBQWlCLEdBQUcseUJBQXlCLGtCQUFrQixHQUFHLHFCQUFxQix1QkFBdUIscUJBQXFCLGdCQUFnQixpQkFBaUIscUJBQXFCLHdCQUF3Qix5QkFBeUIsR0FBRztBQUN2bUQsOERBQThELHdDQUF3QztBQUN0RyxDQUFDLHlCQUF5QixrQkFBa0IsR0FBRyxTQUFTLHlCQUF5QixHQUFHLGdCQUFnQix5QkFBeUIsYUFBYSxjQUFjLG9CQUFvQixHQUFHLDJCQUEyQiwyQkFBMkIsR0FBRyw0QkFBNEIscUJBQXFCLEdBQUcsZUFBZSx5QkFBeUIsR0FBRyxvREFBb0QsaUJBQWlCLDhCQUE4QixHQUFHO0FBQzdhO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qix5REFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBOztBQUVBLFlBQVksdURBQU07QUFDbEIsNkJBQTZCLHlEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQUk7QUFDaEM7QUFDQSxrQkFBa0IsdURBQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix1REFBTTtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIseURBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSx5REFBUTtBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsb0JBQW9CLGlDQUFpQywyQkFBMkIseUJBQXlCLHlDQUF5QywrQ0FBK0Msd0JBQXdCLHNCQUFzQiwyQkFBMkIscUNBQXFDLFdBQVcsb0NBQW9DLDZCQUE2QiwwQkFBMEIsMkJBQTJCLHdDQUF3QyxXQUFXLHVDQUF1QyxpQ0FBaUMsa0RBQWtELDhCQUE4Qiw0QkFBNEIsV0FBVztBQUNscUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxPQUFPO0FBQ1AsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixvREFBSyxDQUFDLG1EQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFRO0FBQ3BDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFRO0FBQ3BCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVcsd0RBQVU7QUFDckI7QUFDQTs7QUFFQSxXQUFXLG9EQUFLO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtB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O0FBQ0EsT0FBTztBQUNQLGVBQWUseURBQVE7QUFDdkIsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsR0FBRztBQUNIOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1Qix5REFBUTtBQUMvQixLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFLOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFNOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxL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QUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNkNBQTZDLEVBQUU7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdURBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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R0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQVM7QUFDOUIsc0JBQXNCLHdEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsd0RBQVMsZUFBZSx3REFBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx3REFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFD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MENBQTBDO0FBQ2xFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0VBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0EsV0FBVyxnRUFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0lBQStJO0FBQy9JOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxvREFBSztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDZEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFB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TTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsdURBQVE7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isb0RBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSxtREFBSTtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSx3Q0FBd0MsbUVBQW9CLHdCQUF3QixtRUFBb0I7QUFDeEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsaUVBQWtCO0FBQ2hIO0FBQ0EsNEVBQTRFLDJEQUFVO0FBQ3RGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdEQUFPLDBCQUEwQiwyREFBVTtBQUM3RSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FB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Q0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLDhEQUFtQjtBQUM5QjtBQUNBLFdBQVcsb0RBQUc7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7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LEdBQUcsaUJBQWlCOzs7QUFHcEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixjQUFjO0FBQ2pHLCtFQUErRSxjQUFjO0FBQzdGO0FBQ0E7O0FBRUE7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O0FBRXZEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFEQUFxRDtBQUNyRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBbUI7QUFDNUI7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLENBQUM7QUFDRDtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUssRUFBQztBQUNPO0FBQzVCOzs7Ozs7Ozs7Ozs7OztBQ3RaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytEOztBQUUvRDtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUMsQ0FBQyx5REFBVTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsdURBQU07QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGNBQWMsRUFBQztBQUNkO0FBQ2hCOzs7Ozs7Ozs7Ozs7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekMsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxVQUFVLEVBQUM7QUFDVjtBQUNoQjs7Ozs7Ozs7Ozs7Ozs7QUNqWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUNWOztBQUV0QztBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0RBQUc7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUMsQ0FBQyw0REFBWTs7QUFFZCxpRUFBZSxVQUFVLEVBQUM7QUFDMUI7Ozs7Ozs7Ozs7Ozs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7O0FBRXhELHVDQUF1QyxRQUFRLHNEQUFzRCxRQUFROztBQUU3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixNQUFNO0FBQ047OztBQUdBOztBQUVBO0FBQ0EsUUFBUSx5REFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyx5REFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxvQkFBb0IsMERBQVM7QUFDN0I7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVELGlFQUFlLFlBQVksRUFBQztBQUM1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsb0RBQUc7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx5REFBUTtBQUNsQjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxRQUFRLDREQUFXO0FBQ25COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsNERBQVc7QUFDbkI7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLG9EQUFHO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLHlEQUFRO0FBQ2hCLE9BQU87QUFDUCxNQUFNLHlEQUFRO0FBQ2QsTUFBTSx5REFBUTtBQUNkLE1BQU0seURBQVE7QUFDZDs7QUFFQTtBQUNBLE1BQU0seURBQVE7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBUTtBQUNoQixPQUFPO0FBQ1AsTUFBTSx5REFBUTtBQUNkLE1BQU0seURBQVE7QUFDZCxNQUFNLHlEQUFRO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBVzs7QUFFZjtBQUNBO0FBQ0EsUUFBUSw0REFBVztBQUNuQixPQUFPO0FBQ1AsTUFBTSw0REFBVztBQUNqQixNQUFNLDREQUFXO0FBQ2pCLE1BQU0sNERBQVc7QUFDakI7O0FBRUE7QUFDQTtBQUNBLFFBQVEsNERBQVc7QUFDbkIsT0FBTztBQUNQLE1BQU0sNERBQVc7QUFDakIsTUFBTSw0REFBVztBQUNqQixNQUFNLDREQUFXO0FBQ2pCLE1BQU0sNERBQVc7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLDREQUFZOztBQUVkLGlFQUFlLEtBQUssRUFBQztBQUNyQjs7Ozs7Ozs7Ozs7Ozs7QUM3eUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkQ7QUFDYjs7QUFFaEQ7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyxTQUFTLFFBQVEsWUFBWTtBQUMvQyxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU8sU0FBUyxRQUFRLFlBQVk7QUFDL0MsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUzs7QUFFdEI7QUFDQSxpQkFBaUIsUUFBUTs7QUFFekI7QUFDQSxZQUFZLFFBQVE7O0FBRXBCO0FBQ0EsWUFBWSxRQUFROztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFFBQVEsMERBQVM7QUFDakI7QUFDQSxLQUFLLFVBQVUsMERBQVM7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNB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QUNBOztBQUVBO0FBQ0EsZUFBZSwyREFBVTs7QUFFekI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDJEQUFVOztBQUV6QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsMkRBQVU7O0FBRXpCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLE1BQU07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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsMkRBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseURBQVE7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxDQUFDLDREQUFZOztBQUVkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsaUVBQWUsU0FBUyxFQUFDO0FBQ2lEO0FBQzFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvY29yZS9jb21wb25lbnRzL0xheWVycy9BZGRMYXllckJ1dHRvbi50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvY29yZS9jb21wb25lbnRzL0xheWVycy9MYXllckRyYWdEcm9wTGlzdC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvY29yZS9jb21wb25lbnRzL0xheWVycy9MYXllck5hbWUudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9lbGVtZW50LnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9lbGVtZW50cy9idXR0b24udHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9lbGVtZW50cy9kcm9uZUZyb250LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvZWxlbWVudHMvZHJvbmVTaWRlLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvZWxlbWVudHMvZHJvbmVUb3AudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9lbGVtZW50cy9pY29uLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvZWxlbWVudHMvbm90Rm91bmQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9lbGVtZW50cy90ZXh0Qm94LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvZWxlbWVudHMvd2luZFR1cmJpbmUudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9mcmFtZS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL3JlZ2lzdHJ5LnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL2FibGVzLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9lbGVtZW50LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9mcmFtZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvcm9vdC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvc2NlbmUudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy90eXBlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9DYW52YXNDb250ZXh0TWVudS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvQ2FudmFzUGFuZWwudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL0lubGluZUVkaXQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL0lubGluZUVkaXRCb2R5LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9lZGl0b3IvQVBJRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9lZGl0b3IvQ29uc3RyYWludFNlbGVjdGlvbkJveC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvZWRpdG9yL0xheWVyRWxlbWVudExpc3RFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL2VkaXRvci9QbGFjZW1lbnRFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL2VkaXRvci9RdWlja1Bvc2l0aW9uaW5nLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9lZGl0b3IvZWxlbWVudEVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvZWRpdG9yL2xheWVyRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9lZGl0b3Ivb3B0aW9ucy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9tb2R1bGUudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL3R5cGVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9jc3Mtc3R5bGVkLXZpcnR1YWwtOWVmOGYwNWRlMi8wL2NhY2hlL2Nzcy1zdHlsZWQtbnBtLTEuMC4wLTUxMDRhODgyZDUtM2YyZjk5NTkzOC56aXAvbm9kZV9tb2R1bGVzL2Nzcy1zdHlsZWQvZGlzdC9zdHlsZWQuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1jb21wYXQtbW92ZWFibGUtdmlydHVhbC04YzdjYTk3YWI3LzAvY2FjaGUvcmVhY3QtY29tcGF0LW1vdmVhYmxlLW5wbS0wLjE4LjAtYTQwMGUyMDVkNi1mNjNiNWNiOWI4LnppcC9ub2RlX21vZHVsZXMvcmVhY3QtY29tcGF0LW1vdmVhYmxlL2Rpc3QvbW92ZWFibGUuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1kcmFnZ2FibGUtdmlydHVhbC1lYjIwMWZhNTQwLzAvY2FjaGUvcmVhY3QtZHJhZ2dhYmxlLW5wbS00LjQuNC1mMGI3YTVjNTQ2LWI4MjU4YTU4OTMuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL0RyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtZHJhZ2dhYmxlLXZpcnR1YWwtZWIyMDFmYTU0MC8wL2NhY2hlL3JlYWN0LWRyYWdnYWJsZS1ucG0tNC40LjQtZjBiN2E1YzU0Ni1iODI1OGE1ODkzLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGVDb3JlLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1kcmFnZ2FibGUtdmlydHVhbC1lYjIwMWZhNTQwLzAvY2FjaGUvcmVhY3QtZHJhZ2dhYmxlLW5wbS00LjQuNC1mMGI3YTVjNTQ2LWI4MjU4YTU4OTMuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL2Nqcy5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtZHJhZ2dhYmxlLXZpcnR1YWwtZWIyMDFmYTU0MC8wL2NhY2hlL3JlYWN0LWRyYWdnYWJsZS1ucG0tNC40LjQtZjBiN2E1YzU0Ni1iODI1OGE1ODkzLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9kb21GbnMuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL19fdmlydHVhbF9fL3JlYWN0LWRyYWdnYWJsZS12aXJ0dWFsLWViMjAxZmE1NDAvMC9jYWNoZS9yZWFjdC1kcmFnZ2FibGUtbnBtLTQuNC40LWYwYjdhNWM1NDYtYjgyNThhNTg5My56aXAvbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvdXRpbHMvZ2V0UHJlZml4LmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1kcmFnZ2FibGUtdmlydHVhbC1lYjIwMWZhNTQwLzAvY2FjaGUvcmVhY3QtZHJhZ2dhYmxlLW5wbS00LjQuNC1mMGI3YTVjNTQ2LWI4MjU4YTU4OTMuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2xvZy5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtZHJhZ2dhYmxlLXZpcnR1YWwtZWIyMDFmYTU0MC8wL2NhY2hlL3JlYWN0LWRyYWdnYWJsZS1ucG0tNC40LjQtZjBiN2E1YzU0Ni1iODI1OGE1ODkzLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9wb3NpdGlvbkZucy5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtZHJhZ2dhYmxlLXZpcnR1YWwtZWIyMDFmYTU0MC8wL2NhY2hlL3JlYWN0LWRyYWdnYWJsZS1ucG0tNC40LjQtZjBiN2E1YzU0Ni1iODI1OGE1ODkzLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9zaGltcy5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtcmVzaXphYmxlLXZpcnR1YWwtMTM0MTIxMzdjZC8wL2NhY2hlL3JlYWN0LXJlc2l6YWJsZS1ucG0tMy4wLjQtYWEzOWY5ZGIyYi1jYmY4NmFkMDRiLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlL2J1aWxkL1Jlc2l6YWJsZS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtcmVzaXphYmxlLXZpcnR1YWwtMTM0MTIxMzdjZC8wL2NhY2hlL3JlYWN0LXJlc2l6YWJsZS1ucG0tMy4wLjQtYWEzOWY5ZGIyYi1jYmY4NmFkMDRiLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlL2J1aWxkL1Jlc2l6YWJsZUJveC5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtcmVzaXphYmxlLXZpcnR1YWwtMTM0MTIxMzdjZC8wL2NhY2hlL3JlYWN0LXJlc2l6YWJsZS1ucG0tMy4wLjQtYWEzOWY5ZGIyYi1jYmY4NmFkMDRiLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlL2J1aWxkL3Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtcmVzaXphYmxlLXZpcnR1YWwtMTM0MTIxMzdjZC8wL2NhY2hlL3JlYWN0LXJlc2l6YWJsZS1ucG0tMy4wLjQtYWEzOWY5ZGIyYi1jYmY4NmFkMDRiLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlL2J1aWxkL3V0aWxzLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1yZXNpemFibGUtdmlydHVhbC0xMzQxMjEzN2NkLzAvY2FjaGUvcmVhY3QtcmVzaXphYmxlLW5wbS0zLjAuNC1hYTM5ZjlkYjJiLWNiZjg2YWQwNGIuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL19fdmlydHVhbF9fL3JlYWN0LXVzZS12aXJ0dWFsLWNlYThlODI2ZGMvMC9jYWNoZS9yZWFjdC11c2UtbnBtLTE3LjQuMC0wZWY0NTIxNTQ0LTA4ODlkYTkxOWIuemlwL25vZGVfbW9kdWxlcy9yZWFjdC11c2UvZXNtL3VzZU9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BkYXlicnVzaC11dGlscy1ucG0tMS42LjAtNTQ3NDg2YmY3OS0yNTc5YmMxN2UwLnppcC9ub2RlX21vZHVsZXMvQGRheWJydXNoL3V0aWxzL2Rpc3QvdXRpbHMuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9AZGF5YnJ1c2gtdXRpbHMtbnBtLTEuNy4wLTI5ODVmNzQ0ODUtNWZmYWFlOTE5NC56aXAvbm9kZV9tb2R1bGVzL0BkYXlicnVzaC91dGlscy9kaXN0L3V0aWxzLmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGVnanMtYWdlbnQtbnBtLTIuMy4wLWU4OGNhMGVlYzItMjUwNmU4ZmVmZi56aXAvbm9kZV9tb2R1bGVzL0BlZ2pzL2FnZW50L2Rpc3QvYWdlbnQuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9AZWdqcy1jaGlsZHJlbi1kaWZmZXItbnBtLTEuMC4xLTM3ZjQ1ZGRmOTctMDg3ZjI4NjgyMi56aXAvbm9kZV9tb2R1bGVzL0BlZ2pzL2NoaWxkcmVuLWRpZmZlci9kaXN0L2NoaWxkcmVuLWRpZmZlci5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BlZ2pzLWxpc3QtZGlmZmVyLW5wbS0xLjAuMC1mNGI5MTc4MWRiLWQxODI3ZDEzNGQuemlwL25vZGVfbW9kdWxlcy9AZWdqcy9saXN0LWRpZmZlci9kaXN0L2xpc3QtZGlmZmVyLmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQHNjZW5hLWRyYWdzY3JvbGwtbnBtLTEuMS4xLThmZTYwNzc1ZjktYWFjYjMzNTg3MC56aXAvbm9kZV9tb2R1bGVzL0BzY2VuYS9kcmFnc2Nyb2xsL2Rpc3QvZHJhZ3Njcm9sbC5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BzY2VuYS1ldmVudC1lbWl0dGVyLW5wbS0xLjAuNS03ZWJmMzYxZDE3LTQwMGUwZjZhYjguemlwL25vZGVfbW9kdWxlcy9Ac2NlbmEvZXZlbnQtZW1pdHRlci9kaXN0L2V2ZW50LWVtaXR0ZXIuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9Ac2NlbmEtbWF0cml4LW5wbS0xLjEuMS1kYTk2NGY2YjNhLWU5NmFlYWI3MTIuemlwL25vZGVfbW9kdWxlcy9Ac2NlbmEvbWF0cml4L2Rpc3QvbWF0cml4LmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvY3NzLXRvLW1hdC1ucG0tMS4wLjMtOGE2OWVkNzFkZS1hM2ZjOThiZmFkLnppcC9ub2RlX21vZHVsZXMvY3NzLXRvLW1hdC9kaXN0L2Nzcy10by1tYXQuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9mcmFtZXdvcmstdXRpbHMtbnBtLTEuMS4wLTM3YTU0YTA2OWMtMDFiNjFlYWQxNy56aXAvbm9kZV9tb2R1bGVzL2ZyYW1ld29yay11dGlscy9kaXN0L3V0aWxzLmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvZ2VzdG8tbnBtLTEuNy4wLTdkNTQ0MDAwMGItZjJhNjZiY2YwZi56aXAvbm9kZV9tb2R1bGVzL2dlc3RvL2Rpc3QvZ2VzdG8uZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9nZXN0by1ucG0tMS45LjAtYzdkZTQ2ZmI0Yy00ZWU4NjMxYzRiLnppcC9ub2RlX21vZHVsZXMvZ2VzdG8vZGlzdC9nZXN0by5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL2tleWNvbi1ucG0tMS4xLjItNDdiYjUwNDhkZi03YmU3NGFhZjgzLnppcC9ub2RlX21vZHVsZXMva2V5Y29uL2Rpc3Qva2V5Y29uLmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvbW92ZWFibGUtbnBtLTAuMzAuMC00ZTA4YTczZGZmLWRlNzk1NTQzMDcuemlwL25vZGVfbW9kdWxlcy9tb3ZlYWJsZS9kaXN0L21vdmVhYmxlLmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvb3ZlcmxhcC1hcmVhLW5wbS0xLjAuMC1lY2U1YTRmYzZhLTM3ZDgyZWE0ZWEuemlwL25vZGVfbW9kdWxlcy9vdmVybGFwLWFyZWEvZGlzdC9vdmVybGFwLWFyZWEuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9yZWFjdC1jb21wYXQtY3NzLXN0eWxlZC1ucG0tMS4wLjgtNTIyMTFkMjZmOC03YThlNTE4NDllLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtY29tcGF0LWNzcy1zdHlsZWQvZGlzdC9zdHlsZWQuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9yZWFjdC1zaW1wbGUtY29tcGF0LW5wbS0xLjIuMi0zNTg1ZTdiOWIwLWE1OTQyOTIzMjguemlwL25vZGVfbW9kdWxlcy9yZWFjdC1zaW1wbGUtY29tcGF0L2Rpc3QvY29tcGF0LmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvc2VsZWN0by1ucG0tMS4xNi4yLWI0ZmZmNTM3YjctYTgzODk0NDk2NC56aXAvbm9kZV9tb2R1bGVzL3NlbGVjdG8vZGlzdC9zZWxlY3RvLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFZhbHVlUGlja2VyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG50eXBlIEFkZExheWVyQnV0dG9uUHJvcHMgPSB7XG4gIG9uQ2hhbmdlOiAoc2VsOiBTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPikgPT4gdm9pZDtcbiAgb3B0aW9uczogQXJyYXk8U2VsZWN0YWJsZVZhbHVlPHN0cmluZz4+O1xuICBsYWJlbDogc3RyaW5nO1xufTtcblxuZXhwb3J0IGNvbnN0IEFkZExheWVyQnV0dG9uID0gKHsgb25DaGFuZ2UsIG9wdGlvbnMsIGxhYmVsIH06IEFkZExheWVyQnV0dG9uUHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8VmFsdWVQaWNrZXJcbiAgICAgIGljb249XCJwbHVzXCJcbiAgICAgIGxhYmVsPXtsYWJlbH1cbiAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgb3B0aW9ucz17b3B0aW9uc31cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIGlzRnVsbFdpZHRoPXt0cnVlfVxuICAgIC8+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgY3NzLCBjeCB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRHJhZ0Ryb3BDb250ZXh0LCBEcmFnZ2FibGUsIERyb3BwYWJsZSwgRHJvcFJlc3VsdCB9IGZyb20gJ3JlYWN0LWJlYXV0aWZ1bC1kbmQnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiwgSWNvbkJ1dHRvbiwgc3R5bGVzRmFjdG9yeSB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgTGF5ZXJOYW1lIH0gZnJvbSAnLi9MYXllck5hbWUnO1xuaW1wb3J0IHsgTGF5ZXJFbGVtZW50IH0gZnJvbSAnLi90eXBlcyc7XG5cbnR5cGUgTGF5ZXJEcmFnRHJvcExpc3RQcm9wczxUIGV4dGVuZHMgTGF5ZXJFbGVtZW50PiA9IHtcbiAgbGF5ZXJzOiBUW107XG4gIGdldExheWVySW5mbzogKGVsZW1lbnQ6IFQpID0+IHN0cmluZztcbiAgb25EcmFnRW5kOiAocmVzdWx0OiBEcm9wUmVzdWx0KSA9PiB2b2lkO1xuICBvblNlbGVjdDogKGVsZW1lbnQ6IFQpID0+IGFueTtcbiAgb25EZWxldGU6IChlbGVtZW50OiBUKSA9PiBhbnk7XG4gIG9uRHVwbGljYXRlPzogKGVsZW1lbnQ6IFQpID0+IGFueTtcbiAgc2hvd0FjdGlvbnM6IChlbGVtZW50OiBUKSA9PiBib29sZWFuO1xuICBzZWxlY3Rpb24/OiBzdHJpbmdbXTsgLy8gbGlzdCBvZiB1bmlxdWUgaWRzIChuYW1lcylcbiAgZXhjbHVkZUJhc2VMYXllcj86IGJvb2xlYW47XG4gIG9uTmFtZUNoYW5nZTogKGVsZW1lbnQ6IFQsIG5ld05hbWU6IHN0cmluZykgPT4gYW55O1xuICB2ZXJpZnlMYXllck5hbWVVbmlxdWVuZXNzPzogKG5hbWVUb0NoZWNrOiBzdHJpbmcpID0+IGJvb2xlYW47XG59O1xuXG5leHBvcnQgY29uc3QgTGF5ZXJEcmFnRHJvcExpc3QgPSA8VCBleHRlbmRzIExheWVyRWxlbWVudD4oe1xuICBsYXllcnMsXG4gIGdldExheWVySW5mbyxcbiAgb25EcmFnRW5kLFxuICBvblNlbGVjdCxcbiAgb25EZWxldGUsXG4gIG9uRHVwbGljYXRlLFxuICBzaG93QWN0aW9ucyxcbiAgc2VsZWN0aW9uLFxuICBleGNsdWRlQmFzZUxheWVyLFxuICBvbk5hbWVDaGFuZ2UsXG4gIHZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3MsXG59OiBMYXllckRyYWdEcm9wTGlzdFByb3BzPFQ+KSA9PiB7XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVzKGNvbmZpZy50aGVtZSk7XG5cbiAgY29uc3QgZ2V0Um93U3R5bGUgPSAoaXNTZWxlY3RlZDogYm9vbGVhbikgPT4ge1xuICAgIHJldHVybiBpc1NlbGVjdGVkID8gYCR7c3R5bGUucm93fSAke3N0eWxlLnNlbH1gIDogc3R5bGUucm93O1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPERyYWdEcm9wQ29udGV4dCBvbkRyYWdFbmQ9e29uRHJhZ0VuZH0+XG4gICAgICA8RHJvcHBhYmxlIGRyb3BwYWJsZUlkPVwiZHJvcHBhYmxlXCI+XG4gICAgICAgIHsocHJvdmlkZWQsIHNuYXBzaG90KSA9PiAoXG4gICAgICAgICAgPGRpdiB7Li4ucHJvdmlkZWQuZHJvcHBhYmxlUHJvcHN9IHJlZj17cHJvdmlkZWQuaW5uZXJSZWZ9PlxuICAgICAgICAgICAgeygoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIHJldmVyc2Ugb3JkZXJcbiAgICAgICAgICAgICAgY29uc3Qgcm93czogYW55ID0gW107XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RMYXllckluZGV4ID0gZXhjbHVkZUJhc2VMYXllciA/IDEgOiAwO1xuICAgICAgICAgICAgICBjb25zdCBzaG91bGRSZW5kZXJEcmFnSWNvbkxlbmd0aFRocmVzaG9sZCA9IGV4Y2x1ZGVCYXNlTGF5ZXIgPyAyIDogMTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxheWVycy5sZW5ndGggLSAxOyBpID49IGxhc3RMYXllckluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbGF5ZXJzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVpZCA9IGVsZW1lbnQuZ2V0TmFtZSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IEJvb2xlYW4oc2VsZWN0aW9uPy5pbmNsdWRlcyh1aWQpKTtcbiAgICAgICAgICAgICAgICByb3dzLnB1c2goXG4gICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIGtleT17dWlkfSBkcmFnZ2FibGVJZD17dWlkfSBpbmRleD17cm93cy5sZW5ndGh9PlxuICAgICAgICAgICAgICAgICAgICB7KHByb3ZpZGVkLCBzbmFwc2hvdCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Z2V0Um93U3R5bGUoaXNTZWxlY3RlZCl9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWY9e3Byb3ZpZGVkLmlubmVyUmVmfVxuICAgICAgICAgICAgICAgICAgICAgICAgey4uLnByb3ZpZGVkLmRyYWdnYWJsZVByb3BzfVxuICAgICAgICAgICAgICAgICAgICAgICAgey4uLnByb3ZpZGVkLmRyYWdIYW5kbGVQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXsoKSA9PiBvblNlbGVjdChlbGVtZW50KX1cbiAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TGF5ZXJOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e3VpZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyh2KSA9PiBvbk5hbWVDaGFuZ2UoZWxlbWVudCwgdil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3M9e3ZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3MgPz8gdW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZS50ZXh0V3JhcHBlcn0+Jm5ic3A7IHtnZXRMYXllckluZm8oZWxlbWVudCl9PC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtzaG93QWN0aW9ucyhlbGVtZW50KSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge29uRHVwbGljYXRlID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImNvcHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17J0R1cGxpY2F0ZSd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGUuYWN0aW9uSWNvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gb25EdXBsaWNhdGUoZWxlbWVudCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgOiBudWxsfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJ0cmFzaC1hbHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9eydyZW1vdmUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjeChzdHlsZS5hY3Rpb25JY29uLCBzdHlsZS5kcmFnSWNvbil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBvbkRlbGV0ZShlbGVtZW50KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICB7bGF5ZXJzLmxlbmd0aCA+IHNob3VsZFJlbmRlckRyYWdJY29uTGVuZ3RoVGhyZXNob2xkICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkRyYWcgYW5kIGRyb3AgdG8gcmVvcmRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImRyYWdnYWJsZWRvdHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU9XCJsZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZS5kcmFnSWNvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgICAgICAgICB9KSgpfVxuXG4gICAgICAgICAgICB7cHJvdmlkZWQucGxhY2Vob2xkZXJ9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L0Ryb3BwYWJsZT5cbiAgICA8L0RyYWdEcm9wQ29udGV4dD5cbiAgKTtcbn07XG5cbkxheWVyRHJhZ0Ryb3BMaXN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgaXNHcm91cDogKCkgPT4gZmFsc2UsXG59O1xuXG5jb25zdCBzdHlsZXMgPSBzdHlsZXNGYWN0b3J5KCh0aGVtZTogR3JhZmFuYVRoZW1lKSA9PiAoe1xuICB3cmFwcGVyOiBjc3NgXG4gICAgbWFyZ2luLWJvdHRvbTogJHt0aGVtZS5zcGFjaW5nLm1kfTtcbiAgYCxcbiAgcm93OiBjc3NgXG4gICAgcGFkZGluZzogJHt0aGVtZS5zcGFjaW5nLnhzfSAke3RoZW1lLnNwYWNpbmcuc219O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7dGhlbWUuYm9yZGVyLnJhZGl1cy5zbX07XG4gICAgYmFja2dyb3VuZDogJHt0aGVtZS5jb2xvcnMuYmcyfTtcbiAgICBtaW4taGVpZ2h0OiAke3RoZW1lLnNwYWNpbmcuZm9ybUlucHV0SGVpZ2h0fXB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgbWFyZ2luLWJvdHRvbTogM3B4O1xuICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgIGJvcmRlcjogMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmZvcm1JbnB1dEJvcmRlcn07XG4gICAgJjpob3ZlciB7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5mb3JtSW5wdXRCb3JkZXJIb3Zlcn07XG4gICAgfVxuICBgLFxuICBzZWw6IGNzc2BcbiAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5mb3JtSW5wdXRCb3JkZXJBY3RpdmV9O1xuICAgICY6aG92ZXIge1xuICAgICAgYm9yZGVyOiAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuZm9ybUlucHV0Qm9yZGVyQWN0aXZlfTtcbiAgICB9XG4gIGAsXG4gIGRyYWdJY29uOiBjc3NgXG4gICAgY3Vyc29yOiBkcmFnO1xuICBgLFxuICBhY3Rpb25JY29uOiBjc3NgXG4gICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnRleHRXZWFrfTtcbiAgICAmOmhvdmVyIHtcbiAgICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy50ZXh0fTtcbiAgICB9XG4gIGAsXG4gIHR5cGVXcmFwcGVyOiBjc3NgXG4gICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnRleHRCbHVlfTtcbiAgICBtYXJnaW4tcmlnaHQ6IDVweDtcbiAgYCxcbiAgdGV4dFdyYXBwZXI6IGNzc2BcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1ncm93OiAxO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgbWFyZ2luLXJpZ2h0OiAke3RoZW1lLnNwYWNpbmcuc219O1xuICBgLFxufSkpO1xuIiwiaW1wb3J0IHsgY3NzLCBjeCB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgSWNvbiwgSW5wdXQsIEZpZWxkVmFsaWRhdGlvbk1lc3NhZ2UsIHVzZVN0eWxlcyB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuZXhwb3J0IGludGVyZmFjZSBMYXllck5hbWVQcm9wcyB7XG4gIG5hbWU6IHN0cmluZztcbiAgb25DaGFuZ2U6ICh2OiBzdHJpbmcpID0+IHZvaWQ7XG4gIHZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3M/OiAobmFtZVRvQ2hlY2s6IHN0cmluZykgPT4gYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IExheWVyTmFtZSA9ICh7IG5hbWUsIG9uQ2hhbmdlLCB2ZXJpZnlMYXllck5hbWVVbmlxdWVuZXNzIH06IExheWVyTmFtZVByb3BzKSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlcyhnZXRTdHlsZXMpO1xuXG4gIGNvbnN0IFtpc0VkaXRpbmcsIHNldElzRWRpdGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFt2YWxpZGF0aW9uRXJyb3IsIHNldFZhbGlkYXRpb25FcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBvbkVkaXRMYXllciA9IChldmVudDogUmVhY3QuU3ludGhldGljRXZlbnQpID0+IHtcbiAgICBzZXRJc0VkaXRpbmcodHJ1ZSk7XG4gIH07XG5cbiAgY29uc3Qgb25FbmRFZGl0TmFtZSA9IChuZXdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICBzZXRJc0VkaXRpbmcoZmFsc2UpO1xuXG4gICAgaWYgKHZhbGlkYXRpb25FcnJvcikge1xuICAgICAgc2V0VmFsaWRhdGlvbkVycm9yKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuYW1lICE9PSBuZXdOYW1lKSB7XG4gICAgICBvbkNoYW5nZShuZXdOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25JbnB1dENoYW5nZSA9IChldmVudDogUmVhY3QuU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCBuZXdOYW1lID0gZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZS50cmltKCk7XG5cbiAgICBpZiAobmV3TmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHNldFZhbGlkYXRpb25FcnJvcignQW4gZW1wdHkgbGF5ZXIgbmFtZSBpcyBub3QgYWxsb3dlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2ZXJpZnlMYXllck5hbWVVbmlxdWVuZXNzICYmICF2ZXJpZnlMYXllck5hbWVVbmlxdWVuZXNzKG5ld05hbWUpICYmIG5ld05hbWUgIT09IG5hbWUpIHtcbiAgICAgIHNldFZhbGlkYXRpb25FcnJvcignTGF5ZXIgbmFtZSBhbHJlYWR5IGV4aXN0cycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgIHNldFZhbGlkYXRpb25FcnJvcihudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25FZGl0TGF5ZXJCbHVyID0gKGV2ZW50OiBSZWFjdC5TeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIG9uRW5kRWRpdE5hbWUoZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZS50cmltKCkpO1xuICB9O1xuXG4gIGNvbnN0IG9uS2V5RG93biA9IChldmVudDogUmVhY3QuS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgIG9uRW5kRWRpdE5hbWUoKGV2ZW50LnRhcmdldCBhcyBhbnkpLnZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25Gb2N1cyA9IChldmVudDogUmVhY3QuRm9jdXNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGV2ZW50LnRhcmdldC5zZWxlY3QoKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLndyYXBwZXJ9PlxuICAgICAgICB7IWlzRWRpdGluZyAmJiAoXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubGF5ZXJOYW1lV3JhcHBlcn1cbiAgICAgICAgICAgIHRpdGxlPVwiRWRpdCBsYXllciBuYW1lXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9e29uRWRpdExheWVyfVxuICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJsYXllci1uYW1lLWRpdlwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMubGF5ZXJOYW1lfT57bmFtZX08L3NwYW4+XG4gICAgICAgICAgICA8SWNvbiBuYW1lPVwicGVuXCIgY2xhc3NOYW1lPXtzdHlsZXMubGF5ZXJFZGl0SWNvbn0gc2l6ZT1cInNtXCIgLz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKX1cblxuICAgICAgICB7aXNFZGl0aW5nICYmIChcbiAgICAgICAgICA8PlxuICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtuYW1lfVxuICAgICAgICAgICAgICBvbkJsdXI9e29uRWRpdExheWVyQmx1cn1cbiAgICAgICAgICAgICAgYXV0b0ZvY3VzXG4gICAgICAgICAgICAgIG9uS2V5RG93bj17b25LZXlEb3dufVxuICAgICAgICAgICAgICBvbkZvY3VzPXtvbkZvY3VzfVxuICAgICAgICAgICAgICBpbnZhbGlkPXt2YWxpZGF0aW9uRXJyb3IgIT09IG51bGx9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbklucHV0Q2hhbmdlfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5sYXllck5hbWVJbnB1dH1cbiAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJsYXllci1uYW1lLWlucHV0XCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7dmFsaWRhdGlvbkVycm9yICYmIDxGaWVsZFZhbGlkYXRpb25NZXNzYWdlIGhvcml6b250YWw+e3ZhbGlkYXRpb25FcnJvcn08L0ZpZWxkVmFsaWRhdGlvbk1lc3NhZ2U+fVxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgPC8+XG4gICk7XG59O1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZSkgPT4ge1xuICByZXR1cm4ge1xuICAgIHdyYXBwZXI6IGNzc2BcbiAgICAgIGxhYmVsOiBXcmFwcGVyO1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBtYXJnaW4tbGVmdDogJHt0aGVtZS5zcGFjaW5nLnhzfTtcbiAgICBgLFxuICAgIGxheWVyTmFtZVdyYXBwZXI6IGNzc2BcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgICAgIGJvcmRlci1yYWRpdXM6ICR7dGhlbWUuYm9yZGVyLnJhZGl1cy5tZH07XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgcGFkZGluZzogMCAwIDAgJHt0aGVtZS5zcGFjaW5nLnhzfTtcbiAgICAgIG1hcmdpbjogMDtcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXG4gICAgICAmOmhvdmVyIHtcbiAgICAgICAgYmFja2dyb3VuZDogJHt0aGVtZS5jb2xvcnMuYmczfTtcbiAgICAgICAgYm9yZGVyOiAxcHggZGFzaGVkICR7dGhlbWUuY29sb3JzLmJvcmRlcjN9O1xuICAgICAgfVxuXG4gICAgICAmOmZvY3VzIHtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgJHt0aGVtZS5jb2xvcnMuZm9ybUlucHV0Qm9yZGVyQWN0aXZlfTtcbiAgICAgIH1cblxuICAgICAgJjpob3ZlcixcbiAgICAgICY6Zm9jdXMge1xuICAgICAgICAucXVlcnktbmFtZS1lZGl0LWljb24ge1xuICAgICAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBgLFxuICAgIGxheWVyTmFtZTogY3NzYFxuICAgICAgZm9udC13ZWlnaHQ6ICR7dGhlbWUudHlwb2dyYXBoeS53ZWlnaHQuc2VtaWJvbGR9O1xuICAgICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnRleHRCbHVlfTtcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICBtYXJnaW4tbGVmdDogJHt0aGVtZS5zcGFjaW5nLnhzfTtcbiAgICBgLFxuICAgIGxheWVyRWRpdEljb246IGN4KFxuICAgICAgY3NzYFxuICAgICAgICBtYXJnaW4tbGVmdDogJHt0aGVtZS5zcGFjaW5nLm1kfTtcbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgICAgYCxcbiAgICAgICdxdWVyeS1uYW1lLWVkaXQtaWNvbidcbiAgICApLFxuICAgIGxheWVyTmFtZUlucHV0OiBjc3NgXG4gICAgICBtYXgtd2lkdGg6IDMwMHB4O1xuICAgICAgbWFyZ2luOiAtNHB4IDA7XG4gICAgYCxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBSZWdpc3RyeUl0ZW0gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFBhbmVsT3B0aW9uc1N1cHBsaWVyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YS9zcmMvcGFuZWwvUGFuZWxQbHVnaW4nO1xuXG5pbXBvcnQgeyBEaW1lbnNpb25Db250ZXh0IH0gZnJvbSAnLi4vZGltZW5zaW9ucy9jb250ZXh0JztcblxuaW1wb3J0IHsgQmFja2dyb3VuZENvbmZpZywgQ29uc3RyYWludCwgTGluZUNvbmZpZywgUGxhY2VtZW50IH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogVGhpcyBnZXRzIHNhdmVkIGluIHBhbmVsIGpzb25cbiAqXG4gKiBkZXBlbmRpbmcgb24gdGhlIHR5cGUsIGl0IG1heSBoYXZlIGFkZGl0aW9uYWwgY29uZmlnXG4gKlxuICogQGFscGhhXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FudmFzRWxlbWVudE9wdGlvbnM8VENvbmZpZyA9IGFueT4ge1xuICBuYW1lOiBzdHJpbmc7IC8vIGNvbmZpZ3VyZWQgdW5pcXVlIGRpc3BsYXkgbmFtZVxuICB0eXBlOiBzdHJpbmc7XG5cbiAgLy8gQ3VzdG9tIG9wdGlvbnMgZGVwZW5kaW5nIG9uIHRoZSB0eXBlXG4gIGNvbmZpZz86IFRDb25maWc7XG5cbiAgLy8gU3RhbmRhcmQgb3B0aW9ucyBhdmFpbGFibGUgZm9yIGFsbCBlbGVtZW50c1xuICBjb25zdHJhaW50PzogQ29uc3RyYWludDsgLy8gZGVmYXVsdHMgdmVydGljYWwgLSB0b3AsIGhvcml6b250YWwgLSBsZWZ0XG4gIHBsYWNlbWVudD86IFBsYWNlbWVudDtcbiAgYmFja2dyb3VuZD86IEJhY2tncm91bmRDb25maWc7XG4gIGJvcmRlcj86IExpbmVDb25maWc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FudmFzRWxlbWVudFByb3BzPFRDb25maWcgPSBhbnksIFREYXRhID0gYW55PiB7XG4gIC8vIFNhdmVkIGNvbmZpZ1xuICBjb25maWc6IFRDb25maWc7XG5cbiAgLy8gUmF3IGRhdGFcbiAgZGF0YT86IFREYXRhO1xufVxuXG4vKipcbiAqIENhbnZhcyBpdGVtIGJ1aWxkZXJcbiAqXG4gKiBAYWxwaGFcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYW52YXNFbGVtZW50SXRlbTxUQ29uZmlnID0gYW55LCBURGF0YSA9IGFueT4gZXh0ZW5kcyBSZWdpc3RyeUl0ZW0ge1xuICAvKiogVGhlIGRlZmF1bHQgd2lkdGgvaGVpZ2h0IHRvIHVzZSB3aGVuIGFkZGluZyAgKi9cbiAgZGVmYXVsdFNpemU/OiBQbGFjZW1lbnQ7XG5cbiAgcHJlcGFyZURhdGE/OiAoY3R4OiBEaW1lbnNpb25Db250ZXh0LCBjZmc6IFRDb25maWcpID0+IFREYXRhO1xuXG4gIC8qKiBDb21wb25lbnQgdXNlZCB0byBkcmF3ICovXG4gIGRpc3BsYXk6IENvbXBvbmVudFR5cGU8Q2FudmFzRWxlbWVudFByb3BzPFRDb25maWcsIFREYXRhPj47XG5cbiAgZ2V0TmV3T3B0aW9uczogKG9wdGlvbnM/OiBDYW52YXNFbGVtZW50T3B0aW9ucykgPT4gT21pdDxDYW52YXNFbGVtZW50T3B0aW9uczxUQ29uZmlnPiwgJ3R5cGUnIHwgJ25hbWUnPjtcblxuICAvKiogQnVpbGQgdGhlIGNvbmZpZ3VyYXRpb24gVUkgKi9cbiAgcmVnaXN0ZXJPcHRpb25zVUk/OiBQYW5lbE9wdGlvbnNTdXBwbGllcjxDYW52YXNFbGVtZW50T3B0aW9uczxUQ29uZmlnPj47XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgRGltZW5zaW9uQ29udGV4dCB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2NvbnRleHQnO1xuaW1wb3J0IHsgVGV4dERpbWVuc2lvbkVkaXRvciB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2VkaXRvcnMvVGV4dERpbWVuc2lvbkVkaXRvcic7XG5pbXBvcnQgeyBUZXh0RGltZW5zaW9uQ29uZmlnIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvdHlwZXMnO1xuaW1wb3J0IHsgQVBJRWRpdG9yLCBBUElFZGl0b3JDb25maWcsIGNhbGxBcGkgfSBmcm9tICdhcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvZWRpdG9yL0FQSUVkaXRvcic7XG5cbmltcG9ydCB7IENhbnZhc0VsZW1lbnRJdGVtLCBDYW52YXNFbGVtZW50UHJvcHMgfSBmcm9tICcuLi9lbGVtZW50JztcblxuaW50ZXJmYWNlIEJ1dHRvbkRhdGEge1xuICB0ZXh0Pzogc3RyaW5nO1xuICBhcGk/OiBBUElFZGl0b3JDb25maWc7XG59XG5cbmludGVyZmFjZSBCdXR0b25Db25maWcge1xuICB0ZXh0PzogVGV4dERpbWVuc2lvbkNvbmZpZztcbiAgYXBpPzogQVBJRWRpdG9yQ29uZmlnO1xufVxuXG5jbGFzcyBCdXR0b25EaXNwbGF5IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxDYW52YXNFbGVtZW50UHJvcHM8QnV0dG9uQ29uZmlnLCBCdXR0b25EYXRhPj4ge1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICBpZiAoZGF0YT8uYXBpKSB7XG4gICAgICAgIGNhbGxBcGkoZGF0YS5hcGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEJ1dHRvbiB0eXBlPVwic3VibWl0XCIgb25DbGljaz17b25DbGlja30+XG4gICAgICAgIHtkYXRhPy50ZXh0fVxuICAgICAgPC9CdXR0b24+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYnV0dG9uSXRlbTogQ2FudmFzRWxlbWVudEl0ZW08QnV0dG9uQ29uZmlnLCBCdXR0b25EYXRhPiA9IHtcbiAgaWQ6ICdidXR0b24nLFxuICBuYW1lOiAnQnV0dG9uJyxcbiAgZGVzY3JpcHRpb246ICdCdXR0b24nLFxuXG4gIGRpc3BsYXk6IEJ1dHRvbkRpc3BsYXksXG5cbiAgZGVmYXVsdFNpemU6IHtcbiAgICB3aWR0aDogMjAwLFxuICAgIGhlaWdodDogNTAsXG4gIH0sXG5cbiAgZ2V0TmV3T3B0aW9uczogKG9wdGlvbnMpID0+ICh7XG4gICAgLi4ub3B0aW9ucyxcbiAgfSksXG5cbiAgLy8gQ2FsbGVkIHdoZW4gZGF0YSBjaGFuZ2VzXG4gIHByZXBhcmVEYXRhOiAoY3R4OiBEaW1lbnNpb25Db250ZXh0LCBjZmc6IEJ1dHRvbkNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGRhdGE6IEJ1dHRvbkRhdGEgPSB7XG4gICAgICB0ZXh0OiBjZmc/LnRleHQgPyBjdHguZ2V0VGV4dChjZmcudGV4dCkudmFsdWUoKSA6ICcnLFxuICAgICAgYXBpOiBjZmc/LmFwaSA/PyB1bmRlZmluZWQsXG4gICAgfTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIC8vIEhlYXRtYXAgb3ZlcmxheSBvcHRpb25zXG4gIHJlZ2lzdGVyT3B0aW9uc1VJOiAoYnVpbGRlcikgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWydCdXR0b24nXTtcbiAgICBidWlsZGVyXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAndGV4dFNlbGVjdG9yJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy50ZXh0JyxcbiAgICAgICAgbmFtZTogJ1RleHQnLFxuICAgICAgICBlZGl0b3I6IFRleHREaW1lbnNpb25FZGl0b3IsXG4gICAgICB9KVxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2FwaVNlbGVjdG9yJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5hcGknLFxuICAgICAgICBuYW1lOiAnQVBJJyxcbiAgICAgICAgZWRpdG9yOiBBUElFZGl0b3IsXG4gICAgICB9KTtcbiAgfSxcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IEZDIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgRGltZW5zaW9uQ29udGV4dCwgU2NhbGFyRGltZW5zaW9uQ29uZmlnIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMnO1xuaW1wb3J0IHsgU2NhbGFyRGltZW5zaW9uRWRpdG9yIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvZWRpdG9ycyc7XG5cbmltcG9ydCB7IENhbnZhc0VsZW1lbnRJdGVtLCBDYW52YXNFbGVtZW50UHJvcHMgfSBmcm9tICcuLi9lbGVtZW50JztcblxuaW50ZXJmYWNlIERyb25lRnJvbnREYXRhIHtcbiAgcm9sbEFuZ2xlPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgRHJvbmVGcm9udENvbmZpZyB7XG4gIHJvbGxBbmdsZT86IFNjYWxhckRpbWVuc2lvbkNvbmZpZztcbn1cblxuY29uc3QgRHJvbmVGcm9udERpc3BsYXk6IEZDPENhbnZhc0VsZW1lbnRQcm9wczxEcm9uZUZyb250Q29uZmlnLCBEcm9uZUZyb250RGF0YT4+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICBjb25zdCB7IGRhdGEgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGRyb25lRnJvbnRUcmFuc2Zvcm1TdHlsZSA9IGByb3RhdGUoJHtkYXRhPy5yb2xsQW5nbGUgPyBkYXRhLnJvbGxBbmdsZSA6IDB9ZGVnKWA7XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICBjbGFzc05hbWU9e3N0eWxlcy5kcm9uZUZyb250fVxuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICB4bWxuc1hsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiXG4gICAgICB2aWV3Qm94PVwiMCAwIDEzMDAgMjkwXCJcbiAgICAgIHN0eWxlPXt7IHRyYW5zZm9ybTogZHJvbmVGcm9udFRyYW5zZm9ybVN0eWxlIH19XG4gICAgPlxuICAgICAgPGcgY2xhc3NOYW1lPVwiYXJtc1wiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlV2lkdGg9XCIyOHB4XCI+XG4gICAgICAgIDxsaW5lIHgxPVwiNTEwXCIgeDI9XCIzMjBcIiB5MT1cIjEwMFwiIHkyPVwiMTUwXCIgLz5cbiAgICAgICAgPGxpbmUgeDE9XCI1MTBcIiB4Mj1cIjMyMFwiIHkxPVwiMTkwXCIgeTI9XCIyMTBcIiAvPlxuICAgICAgICA8bGluZSB4MT1cIjc5MFwiIHgyPVwiOTgwXCIgeTE9XCIxOTBcIiB5Mj1cIjIxMFwiIC8+XG4gICAgICAgIDxsaW5lIHgxPVwiNzkwXCIgeDI9XCI5ODBcIiB5MT1cIjEwMFwiIHkyPVwiMTUwXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGNsYXNzTmFtZT1cImJvZHlcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZVdpZHRoPVwiMjhweFwiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICBkPVwiIE0gNTEwIDEzMCBDIDUxMCAxMjQgNTEwIDExMCA1MTAgMTAwIEMgNTEwIDkwIDUzMCA3MSA1NDAgNzAgQyA2NDAgNjEgNjcwIDYwIDc2MCA3MCBDIDc3MCA3MSA3OTAgOTAgNzkwIDEwMCBRIDc5MCAxMjAgNzkwIDEzMCBMIDc5MCAxMzAgUSA3OTAgMTc3IDc5MCAxOTYgQyA3OTAgMjA3IDc3MCAyMjUgNzYwIDIyNiBDIDY3MCAyMzYgNjQwIDIzNiA1NDAgMjI2IEMgNTMwIDIyNiA1MTAgMjA2IDUxMCAxOTYgUSA1MTAgMTc3IDUxMCAxMzAgUSA1MTAgMTMzIDUxMCAxMzAgWiBcIlxuICAgICAgICAvPlxuICAgICAgICA8Y2lyY2xlIGN4PVwiNjUwXCIgY3k9XCIxNjBcIiByPVwiNDBcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBjbGFzc05hbWU9XCJtb3RvcnNcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZVdpZHRoPVwiMjhweFwiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT1cIm1vdG9yXCJcbiAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgZD1cIiBNIDMyMCA2MCBMIDI1MCA2MCBMIDI1MCAyMzAgTCAyNjAgMjkwIEwgMzEwIDI5MCBMIDMyMCAyMzAgTCAzMjAgNjAgWiBcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT1cIm1vdG9yXCJcbiAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgZD1cIiBNIDEwNTAgNjAgTCA5ODAgNjAgTCA5ODAgMjMwIEwgOTkwIDI5MCBMIDEwNDAgMjkwIEwgMTA1MCAyMzAgTCAxMDUwIDYwIFogXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGNsYXNzTmFtZT1cInByb3BlbGxlcnNcIiBmaWxsPVwiYmxhY2tcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9XCJwcm9wXCJcbiAgICAgICAgICBkPVwiIE0gMjcwIDYwIEwgMzAwIDYwIEwgMzAwIDIwIFEgMzExIDMwIDMzMCAzMCBRIDM0OSAzMCA1NzAgMTAgTCAzMDAgMTAgUSAzMDAgMCAyOTAgMCBDIDI4NiAwIDI4NCAwIDI4MCAwIFEgMjcwIDAgMjcwIDEwIEwgMCAxMCBRIDIyMCAzMCAyNDAgMzAgUSAyNjAgMzAgMjcwIDIwIEwgMjcwIDYwIFogXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9XCJwcm9wXCJcbiAgICAgICAgICBkPVwiIE0gMTAwMCA2MCBMIDEwMzAgNjAgTCAxMDMwIDIwIFEgMTA0MSAzMCAxMDYwIDMwIFEgMTA3OSAzMCAxMzAwIDEwIEwgMTAzMCAxMCBRIDEwMzAgMCAxMDIwIDAgQyAxMDE2IDAgMTAxNCAwIDEwMTAgMCBRIDEwMDAgMCAxMDAwIDEwIEwgNzMwIDEwIFEgOTUwIDMwIDk3MCAzMCBRIDk5MCAzMCAxMDAwIDIwIEwgMTAwMCA2MCBaIFwiXG4gICAgICAgIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZHJvbmVGcm9udEl0ZW06IENhbnZhc0VsZW1lbnRJdGVtPGFueSwgYW55PiA9IHtcbiAgaWQ6ICdkcm9uZUZyb250JyxcbiAgbmFtZTogJ0Ryb25lIEZyb250JyxcbiAgZGVzY3JpcHRpb246ICdEcm9uZSBmcm9udCcsXG5cbiAgZGlzcGxheTogRHJvbmVGcm9udERpc3BsYXksXG5cbiAgZGVmYXVsdFNpemU6IHtcbiAgICB3aWR0aDogMTAwLFxuICAgIGhlaWdodDogMTAwLFxuICB9LFxuXG4gIGdldE5ld09wdGlvbnM6IChvcHRpb25zKSA9PiAoe1xuICAgIC4uLm9wdGlvbnMsXG4gIH0pLFxuXG4gIC8vIENhbGxlZCB3aGVuIGRhdGEgY2hhbmdlc1xuICBwcmVwYXJlRGF0YTogKGN0eDogRGltZW5zaW9uQ29udGV4dCwgY2ZnOiBEcm9uZUZyb250Q29uZmlnKSA9PiB7XG4gICAgY29uc3QgZGF0YTogRHJvbmVGcm9udERhdGEgPSB7XG4gICAgICByb2xsQW5nbGU6IGNmZz8ucm9sbEFuZ2xlID8gY3R4LmdldFNjYWxhcihjZmcucm9sbEFuZ2xlKS52YWx1ZSgpIDogMCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cbiAgcmVnaXN0ZXJPcHRpb25zVUk6IChidWlsZGVyKSA9PiB7XG4gICAgY29uc3QgY2F0ZWdvcnkgPSBbJ0Ryb25lIEZyb250J107XG4gICAgYnVpbGRlci5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgY2F0ZWdvcnksXG4gICAgICBpZDogJ3JvbGxBbmdsZScsXG4gICAgICBwYXRoOiAnY29uZmlnLnJvbGxBbmdsZScsXG4gICAgICBuYW1lOiAnUm9sbCBBbmdsZScsXG4gICAgICBlZGl0b3I6IFNjYWxhckRpbWVuc2lvbkVkaXRvcixcbiAgICB9KTtcbiAgfSxcbn07XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgZHJvbmVGcm9udDogY3NzYFxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjRzO1xuICBgLFxufSk7XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IEZDIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgRGltZW5zaW9uQ29udGV4dCwgU2NhbGFyRGltZW5zaW9uQ29uZmlnIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMnO1xuaW1wb3J0IHsgU2NhbGFyRGltZW5zaW9uRWRpdG9yIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvZWRpdG9ycyc7XG5cbmltcG9ydCB7IENhbnZhc0VsZW1lbnRJdGVtLCBDYW52YXNFbGVtZW50UHJvcHMgfSBmcm9tICcuLi9lbGVtZW50JztcblxuaW50ZXJmYWNlIERyb25lU2lkZURhdGEge1xuICBwaXRjaEFuZ2xlPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgRHJvbmVTaWRlQ29uZmlnIHtcbiAgcGl0Y2hBbmdsZT86IFNjYWxhckRpbWVuc2lvbkNvbmZpZztcbn1cblxuY29uc3QgRHJvbmVTaWRlRGlzcGxheTogRkM8Q2FudmFzRWxlbWVudFByb3BzPERyb25lU2lkZUNvbmZpZywgRHJvbmVTaWRlRGF0YT4+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICBjb25zdCB7IGRhdGEgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGRyb25lU2lkZVBpdGNoVHJhbnNmb3JtU3R5bGUgPSBgcm90YXRlKCR7ZGF0YT8ucGl0Y2hBbmdsZSA/IGRhdGEucGl0Y2hBbmdsZSA6IDB9ZGVnKWA7XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICBjbGFzc05hbWU9e3N0eWxlcy5kcm9uZVNpZGV9XG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgIHhtbG5zWGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMTMwMCAyOTBcIlxuICAgICAgc3R5bGU9e3sgdHJhbnNmb3JtOiBkcm9uZVNpZGVQaXRjaFRyYW5zZm9ybVN0eWxlIH19XG4gICAgPlxuICAgICAgPGcgY2xhc3NOYW1lPVwiYXJtc1wiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlV2lkdGg9XCIyOHB4XCI+XG4gICAgICAgIDxsaW5lIHgxPVwiNTEwXCIgeDI9XCIzMjBcIiB5MT1cIjEwMFwiIHkyPVwiMTUwXCIgLz5cbiAgICAgICAgPGxpbmUgeDE9XCI1MTBcIiB4Mj1cIjMyMFwiIHkxPVwiMTkwXCIgeTI9XCIyMTBcIiAvPlxuICAgICAgICA8bGluZSB4MT1cIjc5MFwiIHgyPVwiOTgwXCIgeTE9XCIxOTBcIiB5Mj1cIjIxMFwiIC8+XG4gICAgICAgIDxsaW5lIHgxPVwiNzkwXCIgeDI9XCI5ODBcIiB5MT1cIjEwMFwiIHkyPVwiMTUwXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGNsYXNzTmFtZT1cImJvZHlcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZVdpZHRoPVwiMjhweFwiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICBkPVwiIE0gNTEwIDEzMCBDIDUxMCAxMjQgNTEwIDExMCA1MTAgMTAwIEMgNTEwIDkwIDUzMCA3MSA1NDAgNzAgQyA2NDAgNjEgNjcwIDYwIDc2MCA3MCBDIDc3MCA3MSA3OTAgOTAgNzkwIDEwMCBRIDc5MCAxMjAgNzkwIDEzMCBMIDc5MCAxMzAgUSA3OTAgMTc3IDc5MCAxOTYgQyA3OTAgMjA3IDc3MCAyMjUgNzYwIDIyNiBDIDY3MCAyMzYgNjQwIDIzNiA1NDAgMjI2IEMgNTMwIDIyNiA1MTAgMjA2IDUxMCAxOTYgUSA1MTAgMTc3IDUxMCAxMzAgUSA1MTAgMTMzIDUxMCAxMzAgWiBcIlxuICAgICAgICAvPlxuICAgICAgPC9nPlxuICAgICAgPGcgY2xhc3NOYW1lPVwibW90b3JzXCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2VXaWR0aD1cIjI4cHhcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9XCJtb3RvclwiXG4gICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgIGQ9XCIgTSAzMjAgNjAgTCAyNTAgNjAgTCAyNTAgMjMwIEwgMjYwIDI5MCBMIDMxMCAyOTAgTCAzMjAgMjMwIEwgMzIwIDYwIFogXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9XCJtb3RvclwiXG4gICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgIGQ9XCIgTSAxMDUwIDYwIEwgOTgwIDYwIEwgOTgwIDIzMCBMIDk5MCAyOTAgTCAxMDQwIDI5MCBMIDEwNTAgMjMwIEwgMTA1MCA2MCBaIFwiXG4gICAgICAgIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBjbGFzc05hbWU9XCJwcm9wZWxsZXJzXCIgZmlsbD1cImJsYWNrXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPVwicHJvcFwiXG4gICAgICAgICAgZD1cIiBNIDI3MCA2MCBMIDMwMCA2MCBMIDMwMCAyMCBRIDMxMSAzMCAzMzAgMzAgUSAzNDkgMzAgNTcwIDEwIEwgMzAwIDEwIFEgMzAwIDAgMjkwIDAgQyAyODYgMCAyODQgMCAyODAgMCBRIDI3MCAwIDI3MCAxMCBMIDAgMTAgUSAyMjAgMzAgMjQwIDMwIFEgMjYwIDMwIDI3MCAyMCBMIDI3MCA2MCBaIFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPVwicHJvcFwiXG4gICAgICAgICAgZD1cIiBNIDEwMDAgNjAgTCAxMDMwIDYwIEwgMTAzMCAyMCBRIDEwNDEgMzAgMTA2MCAzMCBRIDEwNzkgMzAgMTMwMCAxMCBMIDEwMzAgMTAgUSAxMDMwIDAgMTAyMCAwIEMgMTAxNiAwIDEwMTQgMCAxMDEwIDAgUSAxMDAwIDAgMTAwMCAxMCBMIDczMCAxMCBRIDk1MCAzMCA5NzAgMzAgUSA5OTAgMzAgMTAwMCAyMCBMIDEwMDAgNjAgWiBcIlxuICAgICAgICAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGRyb25lU2lkZUl0ZW06IENhbnZhc0VsZW1lbnRJdGVtPGFueSwgYW55PiA9IHtcbiAgaWQ6ICdkcm9uZVNpZGUnLFxuICBuYW1lOiAnRHJvbmUgU2lkZScsXG4gIGRlc2NyaXB0aW9uOiAnRHJvbmUgU2lkZScsXG5cbiAgZGlzcGxheTogRHJvbmVTaWRlRGlzcGxheSxcblxuICBkZWZhdWx0U2l6ZToge1xuICAgIHdpZHRoOiAxMDAsXG4gICAgaGVpZ2h0OiAxMDAsXG4gIH0sXG5cbiAgZ2V0TmV3T3B0aW9uczogKG9wdGlvbnMpID0+ICh7XG4gICAgLi4ub3B0aW9ucyxcbiAgfSksXG5cbiAgLy8gQ2FsbGVkIHdoZW4gZGF0YSBjaGFuZ2VzXG4gIHByZXBhcmVEYXRhOiAoY3R4OiBEaW1lbnNpb25Db250ZXh0LCBjZmc6IERyb25lU2lkZUNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGRhdGE6IERyb25lU2lkZURhdGEgPSB7XG4gICAgICBwaXRjaEFuZ2xlOiBjZmc/LnBpdGNoQW5nbGUgPyBjdHguZ2V0U2NhbGFyKGNmZy5waXRjaEFuZ2xlKS52YWx1ZSgpIDogMCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cbiAgcmVnaXN0ZXJPcHRpb25zVUk6IChidWlsZGVyKSA9PiB7XG4gICAgY29uc3QgY2F0ZWdvcnkgPSBbJ0Ryb25lIFNpZGUnXTtcbiAgICBidWlsZGVyLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICBjYXRlZ29yeSxcbiAgICAgIGlkOiAncGl0Y2hBbmdsZScsXG4gICAgICBwYXRoOiAnY29uZmlnLnBpdGNoQW5nbGUnLFxuICAgICAgbmFtZTogJ1BpdGNoIEFuZ2xlJyxcbiAgICAgIGVkaXRvcjogU2NhbGFyRGltZW5zaW9uRWRpdG9yLFxuICAgIH0pO1xuICB9LFxufTtcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiAoe1xuICBkcm9uZVNpZGU6IGNzc2BcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC40cztcbiAgYCxcbn0pO1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyBGQyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IERpbWVuc2lvbkNvbnRleHQsIFNjYWxhckRpbWVuc2lvbkNvbmZpZyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zJztcbmltcG9ydCB7IFNjYWxhckRpbWVuc2lvbkVkaXRvciB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2VkaXRvcnMnO1xuXG5pbXBvcnQgeyBDYW52YXNFbGVtZW50SXRlbSwgQ2FudmFzRWxlbWVudFByb3BzIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5cbmludGVyZmFjZSBEcm9uZVRvcERhdGEge1xuICBiUmlnaHRSb3RvclJQTT86IG51bWJlcjtcbiAgYkxlZnRSb3RvclJQTT86IG51bWJlcjtcbiAgZlJpZ2h0Um90b3JSUE0/OiBudW1iZXI7XG4gIGZMZWZ0Um90b3JSUE0/OiBudW1iZXI7XG4gIHlhd0FuZ2xlPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgRHJvbmVUb3BDb25maWcge1xuICBiUmlnaHRSb3RvclJQTT86IFNjYWxhckRpbWVuc2lvbkNvbmZpZztcbiAgYkxlZnRSb3RvclJQTT86IFNjYWxhckRpbWVuc2lvbkNvbmZpZztcbiAgZlJpZ2h0Um90b3JSUE0/OiBTY2FsYXJEaW1lbnNpb25Db25maWc7XG4gIGZMZWZ0Um90b3JSUE0/OiBTY2FsYXJEaW1lbnNpb25Db25maWc7XG4gIHlhd0FuZ2xlPzogU2NhbGFyRGltZW5zaW9uQ29uZmlnO1xufVxuXG5jb25zdCBEcm9uZVRvcERpc3BsYXk6IEZDPENhbnZhc0VsZW1lbnRQcm9wczxEcm9uZVRvcENvbmZpZywgRHJvbmVUb3BEYXRhPj4gPSAocHJvcHMpID0+IHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIGNvbnN0IHsgZGF0YSB9ID0gcHJvcHM7XG5cbiAgY29uc3QgZlJpZ2h0Um90b3JBbmltYXRpb24gPSBgc3BpbiAke2RhdGE/LmZSaWdodFJvdG9yUlBNID8gNjAgLyBNYXRoLmFicyhkYXRhLmZSaWdodFJvdG9yUlBNKSA6IDB9cyBsaW5lYXIgaW5maW5pdGVgO1xuXG4gIGNvbnN0IGZMZWZ0Um90b3JBbmltYXRpb24gPSBgc3BpbiAke2RhdGE/LmZMZWZ0Um90b3JSUE0gPyA2MCAvIE1hdGguYWJzKGRhdGEuZkxlZnRSb3RvclJQTSkgOiAwfXMgbGluZWFyIGluZmluaXRlYDtcblxuICBjb25zdCBiUmlnaHRSb3RvckFuaW1hdGlvbiA9IGBzcGluICR7ZGF0YT8uYlJpZ2h0Um90b3JSUE0gPyA2MCAvIE1hdGguYWJzKGRhdGEuYlJpZ2h0Um90b3JSUE0pIDogMH1zIGxpbmVhciBpbmZpbml0ZWA7XG5cbiAgY29uc3QgYkxlZnRSb3RvckFuaW1hdGlvbiA9IGBzcGluICR7ZGF0YT8uYkxlZnRSb3RvclJQTSA/IDYwIC8gTWF0aC5hYnMoZGF0YS5iTGVmdFJvdG9yUlBNKSA6IDB9cyBsaW5lYXIgaW5maW5pdGVgO1xuXG4gIGNvbnN0IGRyb25lVG9wVHJhbnNmb3JtU3R5bGUgPSBgcm90YXRlKCR7ZGF0YT8ueWF3QW5nbGUgPyBkYXRhLnlhd0FuZ2xlIDogMH1kZWcpYDtcblxuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgeG1sbnNYbGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIlxuICAgICAgdmlld0JveD1cIi00MyAtNDMgNjQwIDY0MFwiXG4gICAgICB4bWxTcGFjZT1cInByZXNlcnZlXCJcbiAgICAgIHN0eWxlPXt7IHRyYW5zZm9ybTogZHJvbmVUb3BUcmFuc2Zvcm1TdHlsZSB9fVxuICAgID5cbiAgICAgIDxwYXRoXG4gICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiXG4gICAgICAgIGQ9XCIgTSAxMzcuOTUgMTI3Ljk2NyBDIDEzNy4xNCAxMjcuMTU3IDEzNi4xODkgMTI2LjU4IDEzNS4xNzggMTI2LjIxOCBDIDEzOC4xNzMgMTIxLjU0NSAxMzkuOTY3IDExNi4wMzYgMTQwLjEyNSAxMTAuMTIzIEwgMjE3LjY0IDE1MS44NjIgQyAyMTQuMDQ5IDE1Ny40MTEgMjExLjggMTYzLjkyMiAyMTEuMzg2IDE3MC45NSBMIDIwOS42OTQgMTk5LjcxMiBMIDEzNy45NSAxMjcuOTY3IEwgMTM3Ljk1IDEyNy45NjcgTCAxMzcuOTUgMTI3Ljk2NyBMIDEzNy45NSAxMjcuOTY3IEwgMTM3Ljk1IDEyNy45NjcgTCAxMzcuOTUgMTI3Ljk2NyBMIDEzNy45NSAxMjcuOTY3IEwgMTM3Ljk1IDEyNy45NjcgTCAxMzcuOTUgMTI3Ljk2NyBaICBNIDEzNC4yNjggNDI2Ljk4MSBDIDEzMC4yMTEgNDIxLjMxNCAxMjQuMzI4IDQxNy4wNDUgMTE3LjQ4MiA0MTUuMDQxIEwgMjAxLjk5OSAzMzAuNTIzIEwgMjAxLjM4NSAzNDAuOTU1IEMgMjAwLjY3IDM1My4xMDcgMjAyLjgyOSAzNjQuOTE0IDIwNy41NjMgMzc1LjY3MyBMIDEzNC4yNjggNDI2Ljk4MSBMIDEzNC4yNjggNDI2Ljk4MSBMIDEzNC4yNjggNDI2Ljk4MSBMIDEzNC4yNjggNDI2Ljk4MSBMIDEzNC4yNjggNDI2Ljk4MSBMIDEzNC4yNjggNDI2Ljk4MSBMIDEzNC4yNjggNDI2Ljk4MSBMIDEzNC4yNjggNDI2Ljk4MSBaICBNIDMyNC43NjUgMzczLjY3MyBMIDIyOC41MjcgMzczLjY3MyBRIDIxNS4zNzQgMzU4LjYxMSAyMTYuMzYxIDM0MS44MzUgTCAyMjYuMzYxIDE3MS44MzIgQyAyMjYuODI1IDE2My45NCAyMzEuMDEyIDE1Ny4wOTYgMjM3LjE0NiAxNTIuOTU3IEwgMzE2LjE0NiAxNTIuOTU3IEMgMzIyLjI4IDE1Ny4wOTYgMzI2LjQ2NiAxNjMuOTQgMzI2LjkzMSAxNzEuODMyIEwgMzM2LjkzMSAzNDEuODM1IFEgMzM3LjkxOCAzNTguNjExIDMyNC43NjUgMzczLjY3MyBMIDMyNC43NjUgMzczLjY3MyBMIDMyNC43NjUgMzczLjY3MyBMIDMyNC43NjUgMzczLjY3MyBMIDMyNC43NjUgMzczLjY3MyBMIDMyNC43NjUgMzczLjY3MyBMIDMyNC43NjUgMzczLjY3MyBaICBNIDQzNS44MSA0MTUuMDQxIEMgNDI4Ljk2NCA0MTcuMDQ1IDQyMy4wODEgNDIxLjMxNCA0MTkuMDI0IDQyNi45ODEgTCAzNDUuNzI3IDM3NS42NzMgQyAzNTAuNDYxIDM2NC45MTQgMzUyLjYyIDM1My4xMDcgMzUxLjkwNSAzNDAuOTU1IEwgMzUxLjI5MSAzMzAuNTIzIEwgNDM1LjgxIDQxNS4wNDEgTCA0MzUuODEgNDE1LjA0MSBMIDQzNS44MSA0MTUuMDQxIEwgNDM1LjgxIDQxNS4wNDEgTCA0MzUuODEgNDE1LjA0MSBMIDQzNS44MSA0MTUuMDQxIFogIE0gMzQzLjU5NiAxOTkuNzEzIEwgMzQxLjkwNCAxNzAuOTUxIEMgMzQxLjQ5IDE2My45MjMgMzM5LjI0MiAxNTcuNDExIDMzNS42NTEgMTUxLjg2MyBMIDQxMy4xNjcgMTEwLjEyNCBDIDQxMy4zMjUgMTE2LjAzNyA0MTUuMTE5IDEyMS41NDYgNDE4LjExNCAxMjYuMjE5IEMgNDE3LjEwMyAxMjYuNTgxIDQxNi4xNTIgMTI3LjE1OCA0MTUuMzQyIDEyNy45NjggTCAzNDMuNTk2IDE5OS43MTMgTCAzNDMuNTk2IDE5OS43MTMgTCAzNDMuNTk2IDE5OS43MTMgTCAzNDMuNTk2IDE5OS43MTMgTCAzNDMuNTk2IDE5OS43MTMgWiAgTSA0NDQuNjQ2IDkyLjc3MSBDIDQ1My43NDQgOTIuNzcxIDQ2MS4xNDYgMTAwLjE3MiA0NjEuMTQ2IDEwOS4yNzEgQyA0NjEuMTQ2IDExOC4zNjkgNDUzLjc0NCAxMjUuNzcxIDQ0NC42NDYgMTI1Ljc3MSBDIDQzNS41NDggMTI1Ljc3MSA0MjguMTQ2IDExOC4zNjkgNDI4LjE0NiAxMDkuMjcxIEMgNDI4LjE0NiAxMDAuMTcyIDQzNS41NDggOTIuNzcxIDQ0NC42NDYgOTIuNzcxIEwgNDQ0LjY0NiA5Mi43NzEgTCA0NDQuNjQ2IDkyLjc3MSBMIDQ0NC42NDYgOTIuNzcxIFogIE0gMTA4LjY0NyA5Mi43NzEgQyAxMTcuNzQ1IDkyLjc3MSAxMjUuMTQ3IDEwMC4xNzIgMTI1LjE0NyAxMDkuMjcxIEMgMTI1LjE0NyAxMTguMzY5IDExNy43NDUgMTI1Ljc3MSAxMDguNjQ3IDEyNS43NzEgQyA5OS41NDkgMTI1Ljc3MSA5Mi4xNDcgMTE4LjM2OSA5Mi4xNDcgMTA5LjI3MSBDIDkyLjE0NyAxMDAuMTcyIDk5LjU0OSA5Mi43NzEgMTA4LjY0NyA5Mi43NzEgTCAxMDguNjQ3IDkyLjc3MSBMIDEwOC42NDcgOTIuNzcxIFogIE0gMTA4LjY0NyA0NjEuNzcxIEMgOTkuNTQ5IDQ2MS43NzEgOTIuMTQ3IDQ1NC4zNjkgOTIuMTQ3IDQ0NS4yNzEgQyA5Mi4xNDcgNDM2LjE3MiA5OS41NDkgNDI4Ljc3MSAxMDguNjQ3IDQyOC43NzEgQyAxMTcuNzQ1IDQyOC43NzEgMTI1LjE0NyA0MzYuMTcyIDEyNS4xNDcgNDQ1LjI3MSBDIDEyNS4xNDcgNDU0LjM2OSAxMTcuNzQ1IDQ2MS43NzEgMTA4LjY0NyA0NjEuNzcxIEwgMTA4LjY0NyA0NjEuNzcxIFogIE0gOTIuMzIyIDEzNi4yMDIgQyA5Ny4wODYgMTM5LjEgMTAyLjY3NSAxNDAuNzcxIDEwOC42NDcgMTQwLjc3MSBDIDExNC44ODMgMTQwLjc3MSAxMjAuNjk3IDEzOC45NDEgMTI1LjU5NCAxMzUuODAyIEMgMTI1Ljk1NiAxMzYuODEzIDEyNi41MzQgMTM3Ljc2NCAxMjcuMzQzIDEzOC41NzMgTCAyMDcuMzQyIDIxOC41NzMgQyAyMDcuNzExIDIxOC45NDIgMjA4LjEwOSAyMTkuMjY0IDIwOC41MjggMjE5LjU0IEwgMjAzLjIxMiAzMDkuOTA4IEMgMjAxLjc5NCAzMTAuMTgyIDIwMC40NCAzMTAuODY5IDE5OS4zNDIgMzExLjk2NyBMIDk1LjM0MyA0MTUuOTY3IEMgOTQuOTU0IDQxNi4zNTYgOTQuNjIgNDE2Ljc3OSA5NC4zMzUgNDE3LjIyNCBDIDkzLjY1MSA0MTcuNTc1IDkyLjk3NiA0MTcuOTQyIDkyLjMyMiA0MTguMzQgUSA4NC42MTUgNDI0LjE4MiA4MS43MTYgNDI4Ljk0NiBDIDc4LjgxNyA0MzMuNzEgNzcuMTQ3IDQzOS4yOTkgNzcuMTQ3IDQ0NS4yNzEgQyA3Ny4xNDcgNDYyLjY0IDkxLjI3OCA0NzYuNzcxIDEwOC42NDcgNDc2Ljc3MSBDIDExNC42MTkgNDc2Ljc3MSAxMjAuMjA4IDQ3NS4xIDEyNC45NzIgNDcyLjIwMiBDIDEyOS43MzYgNDY5LjMwNCAxMzIuNjc4IDQ2Ni4zNiAxMzUuNTc3IDQ2MS41OTYgQyAxMzguNDc2IDQ1Ni44MzIgMTQwLjE0NyA0NTEuMjQzIDE0MC4xNDcgNDQ1LjI3MSBDIDE0MC4xNDcgNDQzLjk0MyAxNDAuMDU1IDQ0Mi42MzcgMTM5Ljg5NSA0NDEuMzUyIEwgMjE0Ljk5NyAzODguNzggQyAyMTcuMDUgMzkxLjY3NyAzMzYuMjQyIDM5MS42NzggMzM4LjI5NSAzODguNzggTCA0MTMuMzk4IDQ0MS4zNTIgQyA0MTMuMjM4IDQ0Mi42MzcgNDEzLjE0NiA0NDMuOTQzIDQxMy4xNDYgNDQ1LjI3MSBDIDQxMy4xNDYgNDUxLjI0MyA0MTQuODE3IDQ1Ni44MzIgNDE3LjcxNSA0NjEuNTk2IEMgNDIwLjYxMyA0NjYuMzYgNDIzLjU1NyA0NjkuMzA0IDQyOC4zMjEgNDcyLjIwMiBDIDQzMy4wODUgNDc1LjEgNDM4LjY3NCA0NzYuNzcxIDQ0NC42NDYgNDc2Ljc3MSBDIDQ2Mi4wMTUgNDc2Ljc3MSA0NzYuMTQ2IDQ2Mi42NCA0NzYuMTQ2IDQ0NS4yNzEgQyA0NzYuMTQ2IDQzOS4yOTkgNDc0LjQ3NSA0MzMuNzEgNDcxLjU3NyA0MjguOTQ2IEMgNDY4LjY3OSA0MjQuMTgyIDQ1OS42NDIgNDE3LjU3NSA0NTguOTU4IDQxNy4yMjQgQyA0NTguNjcyIDQxNi43NzkgNDU4LjMzOSA0MTYuMzU2IDQ1Ny45NSA0MTUuOTY3IEwgMzUzLjk1IDMxMS45NjcgQyAzNTIuODUyIDMxMC44NjkgMzUxLjQ5OCAzMTAuMTgyIDM1MC4wOCAzMDkuOTA4IEwgMzQ0Ljc2NCAyMTkuNTQgQyAzNDUuMTgzIDIxOS4yNjQgMzQ1LjU4MSAyMTguOTQyIDM0NS45NSAyMTguNTczIEwgNDI1Ljk1IDEzOC41NzMgQyA0MjYuNzYgMTM3Ljc2MyA0MjcuMzM3IDEzNi44MTIgNDI3LjY5OSAxMzUuODAyIEMgNDMyLjU5NiAxMzguOTQxIDQzOC40MDkgMTQwLjc3MSA0NDQuNjQ2IDE0MC43NzEgQyA0NTAuNjE4IDE0MC43NzEgNDU2LjIwNyAxMzkuMSA0NjAuOTcxIDEzNi4yMDIgQyA0NjUuNzM1IDEzMy4zMDQgNDY4LjY3OSAxMzAuMzYgNDcxLjU3NyAxMjUuNTk2IEMgNDc0LjQ3NSAxMjAuODMyIDQ3Ni4xNDYgMTE1LjI0MyA0NzYuMTQ2IDEwOS4yNzEgQyA0NzYuMTQ2IDkxLjkwMyA0NjIuMDE1IDc3Ljc3MiA0NDQuNjQ2IDc3Ljc3MiBDIDQzOC42NzQgNzcuNzcyIDQzMy4wODUgNzkuNDQyIDQyOC4zMjEgODIuMzQgTCA0MTYuMjE1IDkxLjQ0NiBMIDMyNC43NjUgMTQwLjY4OCBDIDMxOC40MDIgMTM2LjMyNCAzMTAuNzE4IDEzMy43NzEgMzAyLjQ3MyAxMzMuNzcxIEwgMjUwLjgxOSAxMzMuNzcxIEMgMjQyLjU3NCAxMzMuNzcxIDIzNC44OSAxMzYuMzI0IDIyOC41MjcgMTQwLjY4OCBMIDEzNy4wNzggOTEuNDQ2IEwgMTI0Ljk3MiA4Mi4zNCBDIDEyMC4yMDggNzkuNDQyIDExNC42MTkgNzcuNzcyIDEwOC42NDcgNzcuNzcyIEMgOTEuMjc4IDc3Ljc3MiA3Ny4xNDcgOTEuOTAzIDc3LjE0NyAxMDkuMjcxIEMgNzcuMTQ3IDExNS4yNDMgNzguODE4IDEyMC44MzIgODEuNzE2IDEyNS41OTUgQyA4NC42MTQgMTMwLjM1OCA4Ny41NTggMTMzLjMwNCA5Mi4zMjIgMTM2LjIwMiBMIDkyLjMyMiAxMzYuMjAyIEwgOTIuMzIyIDEzNi4yMDIgTCA5Mi4zMjIgMTM2LjIwMiBMIDkyLjMyMiAxMzYuMjAyIEwgOTIuMzIyIDEzNi4yMDIgTCA5Mi4zMjIgMTM2LjIwMiBMIDkyLjMyMiAxMzYuMjAyIEwgOTIuMzIyIDEzNi4yMDIgWiAgTSA0NDQuNjQ2IDQ2MS43NzEgQyA0MzUuNTQ4IDQ2MS43NzEgNDI4LjE0NiA0NTQuMzY5IDQyOC4xNDYgNDQ1LjI3MSBDIDQyOC4xNDYgNDM2LjE3MiA0MzUuNTQ4IDQyOC43NzEgNDQ0LjY0NiA0MjguNzcxIEMgNDUzLjc0NCA0MjguNzcxIDQ2MS4xNDYgNDM2LjE3MiA0NjEuMTQ2IDQ0NS4yNzEgQyA0NjEuMTQ2IDQ1NC4zNjkgNDUzLjc0NCA0NjEuNzcxIDQ0NC42NDYgNDYxLjc3MSBaIFwiXG4gICAgICAvPlxuICAgICAgPHBhdGhcbiAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCJcbiAgICAgICAgZD1cIiBNIDI1OS40NTggMzM0LjIzNSBMIDI1OS40NTggMzM3LjIxMSBMIDI1NC41MTQgMzM3LjIxMSBMIDI1NC41MTQgMzUwLjc5NSBMIDI1MC44NDIgMzUwLjc5NSBMIDI1MC44NDIgMzM3LjIxMSBMIDI0NS44OTggMzM3LjIxMSBMIDI0NS44OTggMzM0LjIzNSBMIDI1OS40NTggMzM0LjIzNSBaICBNIDI2Ni4yMjYgMzQ3LjkzOSBMIDI3Mi41ODYgMzQ3LjkzOSBMIDI3Mi43NTQgMzUwLjYyNyBMIDI3Mi43NTQgMzUwLjYyNyBRIDI3MC40OTggMzUwLjg2NyAyNjUuMDc0IDM1MC44NjcgTCAyNjUuMDc0IDM1MC44NjcgTCAyNjUuMDc0IDM1MC44NjcgUSAyNjMuNDE4IDM1MC44NjcgMjYyLjQzNCAzNDkuOTY3IEwgMjYyLjQzNCAzNDkuOTY3IEwgMjYyLjQzNCAzNDkuOTY3IFEgMjYxLjQ1IDM0OS4wNjcgMjYxLjQyNiAzNDcuNTMxIEwgMjYxLjQyNiAzNDcuNTMxIEwgMjYxLjQyNiAzMzcuNDk5IEwgMjYxLjQyNiAzMzcuNDk5IFEgMjYxLjQ1IDMzNS45NjMgMjYyLjQzNCAzMzUuMDYzIEwgMjYyLjQzNCAzMzUuMDYzIEwgMjYyLjQzNCAzMzUuMDYzIFEgMjYzLjQxOCAzMzQuMTYzIDI2NS4wNzQgMzM0LjE2MyBMIDI2NS4wNzQgMzM0LjE2MyBMIDI2NS4wNzQgMzM0LjE2MyBRIDI3MC40OTggMzM0LjE2MyAyNzIuNzU0IDMzNC40MDMgTCAyNzIuNzU0IDMzNC40MDMgTCAyNzIuNTg2IDMzNy4xMTUgTCAyNjYuMjI2IDMzNy4xMTUgTCAyNjYuMjI2IDMzNy4xMTUgUSAyNjUuNjI2IDMzNy4xMTUgMjY1LjM2MiAzMzcuNDAzIEwgMjY1LjM2MiAzMzcuNDAzIEwgMjY1LjM2MiAzMzcuNDAzIFEgMjY1LjA5OCAzMzcuNjkxIDI2NS4wOTggMzM4LjMzOSBMIDI2NS4wOTggMzM4LjMzOSBMIDI2NS4wOTggMzQwLjg1OSBMIDI3MS42OTggMzQwLjg1OSBMIDI3MS42OTggMzQzLjQ5OSBMIDI2NS4wOTggMzQzLjQ5OSBMIDI2NS4wOTggMzQ2LjY5MSBMIDI2NS4wOTggMzQ2LjY5MSBRIDI2NS4wOTggMzQ3LjM2MyAyNjUuMzYyIDM0Ny42NTEgTCAyNjUuMzYyIDM0Ny42NTEgTCAyNjUuMzYyIDM0Ny42NTEgUSAyNjUuNjI2IDM0Ny45MzkgMjY2LjIyNiAzNDcuOTM5IEwgMjY2LjIyNiAzNDcuOTM5IFogIE0gMjc1LjIwMiAzMzMuOTk1IEwgMjc4LjczIDMzMy45OTUgTCAyNzguNzMgMzQ2LjkzMSBMIDI3OC43MyAzNDYuOTMxIFEgMjc4LjczIDM0OC4xMzEgMjgwLjA3NCAzNDguMTMxIEwgMjgwLjA3NCAzNDguMTMxIEwgMjgxLjAzNCAzNDguMTMxIEwgMjgxLjQ0MiAzNTAuNjAzIEwgMjgxLjQ0MiAzNTAuNjAzIFEgMjgwLjUzIDM1MS4wODMgMjc4LjYxIDM1MS4wODMgTCAyNzguNjEgMzUxLjA4MyBMIDI3OC42MSAzNTEuMDgzIFEgMjc3LjAyNiAzNTEuMDgzIDI3Ni4xMTQgMzUwLjIzMSBMIDI3Ni4xMTQgMzUwLjIzMSBMIDI3Ni4xMTQgMzUwLjIzMSBRIDI3NS4yMDIgMzQ5LjM3OSAyNzUuMjAyIDM0Ny44MTkgTCAyNzUuMjAyIDM0Ny44MTkgTCAyNzUuMjAyIDMzMy45OTUgWiAgTSAyODMuMDUgMzMzLjk5NSBMIDI4Ni41NzggMzMzLjk5NSBMIDI4Ni41NzggMzQ2LjkzMSBMIDI4Ni41NzggMzQ2LjkzMSBRIDI4Ni41NzggMzQ4LjEzMSAyODcuOTIyIDM0OC4xMzEgTCAyODcuOTIyIDM0OC4xMzEgTCAyODguODgyIDM0OC4xMzEgTCAyODkuMjkgMzUwLjYwMyBMIDI4OS4yOSAzNTAuNjAzIFEgMjg4LjM3OCAzNTEuMDgzIDI4Ni40NTggMzUxLjA4MyBMIDI4Ni40NTggMzUxLjA4MyBMIDI4Ni40NTggMzUxLjA4MyBRIDI4NC44NzQgMzUxLjA4MyAyODMuOTYyIDM1MC4yMzEgTCAyODMuOTYyIDM1MC4yMzEgTCAyODMuOTYyIDM1MC4yMzEgUSAyODMuMDUgMzQ5LjM3OSAyODMuMDUgMzQ3LjgxOSBMIDI4My4wNSAzNDcuODE5IEwgMjgzLjA1IDMzMy45OTUgWiAgTSAyOTIuMDg2IDMzNS43NTkgTCAyOTIuMDg2IDMzNS43NTkgTCAyOTIuMDg2IDMzNS43NTkgUSAyOTMuNjM0IDMzMy45MjMgMjk3LjYxOCAzMzMuOTIzIEwgMjk3LjYxOCAzMzMuOTIzIEwgMjk3LjYxOCAzMzMuOTIzIFEgMzAxLjYwMiAzMzMuOTIzIDMwMy4xNjIgMzM1Ljc1OSBMIDMwMy4xNjIgMzM1Ljc1OSBMIDMwMy4xNjIgMzM1Ljc1OSBRIDMwNC43MjIgMzM3LjU5NSAzMDQuNzIyIDM0Mi41MTUgTCAzMDQuNzIyIDM0Mi41MTUgTCAzMDQuNzIyIDM0Mi41MTUgUSAzMDQuNzIyIDM0Ny40MzUgMzAzLjE2MiAzNDkuMjcxIEwgMzAzLjE2MiAzNDkuMjcxIEwgMzAzLjE2MiAzNDkuMjcxIFEgMzAxLjYwMiAzNTEuMTA3IDI5Ny42MTggMzUxLjEwNyBMIDI5Ny42MTggMzUxLjEwNyBMIDI5Ny42MTggMzUxLjEwNyBRIDI5My42MzQgMzUxLjEwNyAyOTIuMDg2IDM0OS4yNzEgTCAyOTIuMDg2IDM0OS4yNzEgTCAyOTIuMDg2IDM0OS4yNzEgUSAyOTAuNTM4IDM0Ny40MzUgMjkwLjUzOCAzNDIuNTE1IEwgMjkwLjUzOCAzNDIuNTE1IEwgMjkwLjUzOCAzNDIuNTE1IFEgMjkwLjUzOCAzMzcuNTk1IDI5Mi4wODYgMzM1Ljc1OSBaICBNIDMwMC4xNzQgMzM4LjA1MSBMIDMwMC4xNzQgMzM4LjA1MSBMIDMwMC4xNzQgMzM4LjA1MSBRIDI5OS40OSAzMzYuODc1IDI5Ny42MTggMzM2Ljg3NSBMIDI5Ny42MTggMzM2Ljg3NSBMIDI5Ny42MTggMzM2Ljg3NSBRIDI5NS43NDYgMzM2Ljg3NSAyOTUuMDYyIDMzOC4wNTEgTCAyOTUuMDYyIDMzOC4wNTEgTCAyOTUuMDYyIDMzOC4wNTEgUSAyOTQuMzc4IDMzOS4yMjcgMjk0LjM3OCAzNDIuNTE1IEwgMjk0LjM3OCAzNDIuNTE1IEwgMjk0LjM3OCAzNDIuNTE1IFEgMjk0LjM3OCAzNDUuODAzIDI5NS4wNjIgMzQ2Ljk3OSBMIDI5NS4wNjIgMzQ2Ljk3OSBMIDI5NS4wNjIgMzQ2Ljk3OSBRIDI5NS43NDYgMzQ4LjE1NSAyOTcuNjE4IDM0OC4xNTUgTCAyOTcuNjE4IDM0OC4xNTUgTCAyOTcuNjE4IDM0OC4xNTUgUSAyOTkuNDkgMzQ4LjE1NSAzMDAuMTc0IDM0Ni45NzkgTCAzMDAuMTc0IDM0Ni45NzkgTCAzMDAuMTc0IDM0Ni45NzkgUSAzMDAuODU4IDM0NS44MDMgMzAwLjg1OCAzNDIuNTE1IEwgMzAwLjg1OCAzNDIuNTE1IEwgMzAwLjg1OCAzNDIuNTE1IFEgMzAwLjg1OCAzMzkuMjI3IDMwMC4xNzQgMzM4LjA1MSBaIFwiXG4gICAgICAvPlxuICAgICAgPGcgY2xhc3NOYW1lPVwicHJvcGVsbGVyLWdyb3VwXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPXtgJHtzdHlsZXMucHJvcGVsbGVyfSAke3N0eWxlcy5wcm9wZWxsZXJDV31gfVxuICAgICAgICAgIHN0eWxlPXt7IGFuaW1hdGlvbjogYlJpZ2h0Um90b3JBbmltYXRpb24gfX1cbiAgICAgICAgICBkPVwiIE0gNDYxLjU2MyA0MTguNzcgTCA0NjMuOTkyIDQxNi4zNCBRIDQ2NS40OTUgNDA3LjExNiA0NjYuNDYxIDQwMC4zOTUgQyA0NjcuNDI2IDM5My42NzUgNDY5LjM2MyAzODguMDg3IDQ3NC43MzEgMzgzLjI4NCBRIDUzMy44NjIgMzQxLjUxNCA1MzguMTk2IDMzOC44NTkgQyA1NDIuNTI5IDMzNi4yMDMgNTQ4LjM0NSAzMzQuMjk5IDU1MS40OTIgMzM4LjI5IEMgNTU0LjYzOSAzNDIuMjgyIDU1My40ODEgMzQ2LjAyIDU0OS40MTkgMzUwLjA4MiBMIDQ3MS4xNDcgNDI4LjM1NCBMIDQ2MS41NjMgNDE4Ljc3IFogIE0gNDI3LjcyOSA0NzEuNzcyIEwgNDI1LjI5OSA0NzQuMjAyIFEgNDIzLjc5NyA0ODMuNDI2IDQyMi44MzEgNDkwLjE0NiBDIDQyMS44NjYgNDk2Ljg2NyA0MTkuOTI5IDUwMi40NTQgNDE0LjU2MSA1MDcuMjU3IFEgMzU1LjQzIDU0OS4wMjggMzUxLjA5NiA1NTEuNjgzIEMgMzQ2Ljc2MyA1NTQuMzM4IDM0MC45NDcgNTU2LjI0MyAzMzcuOCA1NTIuMjUxIEMgMzM0LjY1MyA1NDguMjYgMzM1LjgxMSA1NDQuNTIyIDMzOS44NzMgNTQwLjQ2IEwgNDE4LjE0NSA0NjIuMTg3IEwgNDI3LjcyOSA0NzEuNzcyIFogXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9e2Ake3N0eWxlcy5wcm9wZWxsZXJ9ICR7c3R5bGVzLnByb3BlbGxlckNDV31gfVxuICAgICAgICAgIHN0eWxlPXt7IGFuaW1hdGlvbjogZlJpZ2h0Um90b3JBbmltYXRpb24gfX1cbiAgICAgICAgICBkPVwiIE0gNDYxLjU2MyAxMzUuNzczIEwgNDYzLjk5MiAxMzguMjAzIFEgNDY1LjQ5NSAxNDcuNDI2IDQ2Ni40NjEgMTU0LjE0NyBDIDQ2Ny40MjYgMTYwLjg2OCA0NjkuMzYzIDE2Ni40NTUgNDc0LjczMSAxNzEuMjU4IFEgNTMzLjg2MiAyMTMuMDI4IDUzOC4xOTYgMjE1LjY4NCBDIDU0Mi41MjkgMjE4LjMzOSA1NDguMzQ1IDIyMC4yNDQgNTUxLjQ5MiAyMTYuMjUyIEMgNTU0LjYzOSAyMTIuMjYgNTUzLjQ4MSAyMDguNTIzIDU0OS40MTkgMjA0LjQ2IEwgNDcxLjE0NyAxMjYuMTg4IEwgNDYxLjU2MyAxMzUuNzczIFogIE0gNDI3LjcyOSA4Mi43NyBMIDQyNS4yOTkgODAuMzQgUSA0MjMuNzk3IDcxLjExNyA0MjIuODMxIDY0LjM5NiBDIDQyMS44NjYgNTcuNjc1IDQxOS45MjkgNTIuMDg4IDQxNC41NjEgNDcuMjg1IFEgMzU1LjQzIDUuNTE1IDM1MS4wOTYgMi44NTkgQyAzNDYuNzYzIDAuMjA0IDM0MC45NDcgLTEuNzAxIDMzNy44IDIuMjkxIEMgMzM0LjY1MyA2LjI4MiAzMzUuODExIDEwLjAyIDMzOS44NzMgMTQuMDgyIEwgNDE4LjE0NSA5Mi4zNTUgTCA0MjcuNzI5IDgyLjc3IFogXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9e2Ake3N0eWxlcy5wcm9wZWxsZXJ9ICR7c3R5bGVzLnByb3BlbGxlckNDV31gfVxuICAgICAgICAgIHN0eWxlPXt7IGFuaW1hdGlvbjogYkxlZnRSb3RvckFuaW1hdGlvbiB9fVxuICAgICAgICAgIGQ9XCIgTSAxMjUuNTYzIDQ3MS43NzIgTCAxMjcuOTkzIDQ3NC4yMDIgUSAxMjkuNDk2IDQ4My40MjYgMTMwLjQ2MSA0OTAuMTQ2IEMgMTMxLjQyNyA0OTYuODY3IDEzMy4zNjMgNTAyLjQ1NCAxMzguNzMxIDUwNy4yNTcgUSAxOTcuODYzIDU0OS4wMjggMjAyLjE5NiA1NTEuNjgzIEMgMjA2LjUzIDU1NC4zMzggMjEyLjM0NSA1NTYuMjQzIDIxNS40OTIgNTUyLjI1MSBDIDIxOC42MzkgNTQ4LjI2IDIxNy40ODIgNTQ0LjUyMiAyMTMuNDE5IDU0MC40NiBMIDEzNS4xNDggNDYyLjE4NyBMIDEyNS41NjMgNDcxLjc3MiBaICBNIDkxLjczIDQxOC43NyBMIDg5LjMgNDE2LjM0IFEgODcuNzk3IDQwNy4xMTYgODYuODMyIDQwMC4zOTUgQyA4NS44NjYgMzkzLjY3NSA4My45MyAzODguMDg3IDc4LjU2MiAzODMuMjg0IFEgMTkuNDMxIDM0MS41MTQgMTUuMDk3IDMzOC44NTkgQyAxMC43NjMgMzM2LjIwMyA0Ljk0OCAzMzQuMjk5IDEuODAxIDMzOC4yOSBDIC0xLjM0NiAzNDIuMjgyIC0wLjE4OSAzNDYuMDIgMy44NzQgMzUwLjA4MiBMIDgyLjE0NiA0MjguMzU0IEwgOTEuNzMgNDE4Ljc3IFogXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9e2Ake3N0eWxlcy5wcm9wZWxsZXJ9ICR7c3R5bGVzLnByb3BlbGxlckNXfWB9XG4gICAgICAgICAgc3R5bGU9e3sgYW5pbWF0aW9uOiBmTGVmdFJvdG9yQW5pbWF0aW9uIH19XG4gICAgICAgICAgZD1cIiBNIDEyNS41NjMgODIuNzcgTCAxMjcuOTkzIDgwLjM0IFEgMTI5LjQ5NiA3MS4xMTcgMTMwLjQ2MSA2NC4zOTYgQyAxMzEuNDI3IDU3LjY3NSAxMzMuMzYzIDUyLjA4OCAxMzguNzMxIDQ3LjI4NSBRIDE5Ny44NjMgNS41MTUgMjAyLjE5NiAyLjg1OSBDIDIwNi41MyAwLjIwNCAyMTIuMzQ1IC0xLjcwMSAyMTUuNDkyIDIuMjkxIEMgMjE4LjYzOSA2LjI4MiAyMTcuNDgyIDEwLjAyIDIxMy40MTkgMTQuMDgzIEwgMTM1LjE0NyA5Mi4zNTUgTCAxMjUuNTYzIDgyLjc3IFogIE0gOTEuNzMgMTM1Ljc3MyBMIDg5LjMgMTM4LjIwMyBRIDg3Ljc5NyAxNDcuNDI2IDg2LjgzMiAxNTQuMTQ3IEMgODUuODY2IDE2MC44NjggODMuOTMgMTY2LjQ1NSA3OC41NjIgMTcxLjI1OCBRIDE5LjQzMSAyMTMuMDI4IDE1LjA5NyAyMTUuNjg0IEMgMTAuNzYzIDIxOC4zMzkgNC45NDggMjIwLjI0MyAxLjgwMSAyMTYuMjUyIEMgLTEuMzQ2IDIxMi4yNiAtMC4xODkgMjA4LjUyMyAzLjg3NCAyMDQuNDYgTCA4Mi4xNDYgMTI2LjE4OCBMIDkxLjczIDEzNS43NzMgWiBcIlxuICAgICAgICAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGRyb25lVG9wSXRlbTogQ2FudmFzRWxlbWVudEl0ZW08YW55LCBhbnk+ID0ge1xuICBpZDogJ2Ryb25lVG9wJyxcbiAgbmFtZTogJ0Ryb25lIFRvcCcsXG4gIGRlc2NyaXB0aW9uOiAnRHJvbmUgdG9wJyxcblxuICBkaXNwbGF5OiBEcm9uZVRvcERpc3BsYXksXG5cbiAgZGVmYXVsdFNpemU6IHtcbiAgICB3aWR0aDogMTAwLFxuICAgIGhlaWdodDogMTAwLFxuICB9LFxuXG4gIGdldE5ld09wdGlvbnM6IChvcHRpb25zKSA9PiAoe1xuICAgIC4uLm9wdGlvbnMsXG4gIH0pLFxuXG4gIC8vIENhbGxlZCB3aGVuIGRhdGEgY2hhbmdlc1xuICBwcmVwYXJlRGF0YTogKGN0eDogRGltZW5zaW9uQ29udGV4dCwgY2ZnOiBEcm9uZVRvcENvbmZpZykgPT4ge1xuICAgIGNvbnN0IGRhdGE6IERyb25lVG9wRGF0YSA9IHtcbiAgICAgIGJSaWdodFJvdG9yUlBNOiBjZmc/LmJSaWdodFJvdG9yUlBNID8gY3R4LmdldFNjYWxhcihjZmcuYlJpZ2h0Um90b3JSUE0pLnZhbHVlKCkgOiAwLFxuICAgICAgYkxlZnRSb3RvclJQTTogY2ZnPy5iTGVmdFJvdG9yUlBNID8gY3R4LmdldFNjYWxhcihjZmcuYkxlZnRSb3RvclJQTSkudmFsdWUoKSA6IDAsXG4gICAgICBmUmlnaHRSb3RvclJQTTogY2ZnPy5mUmlnaHRSb3RvclJQTSA/IGN0eC5nZXRTY2FsYXIoY2ZnLmZSaWdodFJvdG9yUlBNKS52YWx1ZSgpIDogMCxcbiAgICAgIGZMZWZ0Um90b3JSUE06IGNmZz8uZkxlZnRSb3RvclJQTSA/IGN0eC5nZXRTY2FsYXIoY2ZnLmZMZWZ0Um90b3JSUE0pLnZhbHVlKCkgOiAwLFxuICAgICAgeWF3QW5nbGU6IGNmZz8ueWF3QW5nbGUgPyBjdHguZ2V0U2NhbGFyKGNmZy55YXdBbmdsZSkudmFsdWUoKSA6IDAsXG4gICAgfTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIHJlZ2lzdGVyT3B0aW9uc1VJOiAoYnVpbGRlcikgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWydEcm9uZSBUb3AnXTtcbiAgICBidWlsZGVyXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAneWF3QW5nbGUnLFxuICAgICAgICBwYXRoOiAnY29uZmlnLnlhd0FuZ2xlJyxcbiAgICAgICAgbmFtZTogJ1lhdyBBbmdsZScsXG4gICAgICAgIGVkaXRvcjogU2NhbGFyRGltZW5zaW9uRWRpdG9yLFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdmUmlnaHRSb3RvclJQTScsXG4gICAgICAgIHBhdGg6ICdjb25maWcuZlJpZ2h0Um90b3JSUE0nLFxuICAgICAgICBuYW1lOiAnRnJvbnQgUmlnaHQgUm90b3IgUlBNJyxcbiAgICAgICAgZWRpdG9yOiBTY2FsYXJEaW1lbnNpb25FZGl0b3IsXG4gICAgICB9KVxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2ZMZWZ0Um90b3JSUE0nLFxuICAgICAgICBwYXRoOiAnY29uZmlnLmZMZWZ0Um90b3JSUE0nLFxuICAgICAgICBuYW1lOiAnRnJvbnQgTGVmdCBSb3RvciBSUE0nLFxuICAgICAgICBlZGl0b3I6IFNjYWxhckRpbWVuc2lvbkVkaXRvcixcbiAgICAgIH0pXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAnYlJpZ2h0Um90b3JSUE0nLFxuICAgICAgICBwYXRoOiAnY29uZmlnLmJSaWdodFJvdG9yUlBNJyxcbiAgICAgICAgbmFtZTogJ0JhY2sgUmlnaHQgUm90b3IgUlBNJyxcbiAgICAgICAgZWRpdG9yOiBTY2FsYXJEaW1lbnNpb25FZGl0b3IsXG4gICAgICB9KVxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2JMZWZ0Um90b3JSUE0nLFxuICAgICAgICBwYXRoOiAnY29uZmlnLmJMZWZ0Um90b3JSUE0nLFxuICAgICAgICBuYW1lOiAnQmFjayBMZWZ0IFJvdG9yIFJQTScsXG4gICAgICAgIGVkaXRvcjogU2NhbGFyRGltZW5zaW9uRWRpdG9yLFxuICAgICAgfSk7XG4gIH0sXG59O1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+ICh7XG4gIHByb3BlbGxlcjogY3NzYFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XG4gICAgdHJhbnNmb3JtLWJveDogZmlsbC1ib3g7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgQGtleWZyYW1lcyBzcGluIHtcbiAgICAgIGZyb20ge1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgICAgIH1cbiAgICAgIHRvIHtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgICAgIH1cbiAgICB9XG4gIGAsXG4gIHByb3BlbGxlckNXOiBjc3NgXG4gICAgYW5pbWF0aW9uLWRpcmVjdGlvbjogbm9ybWFsO1xuICBgLFxuICBwcm9wZWxsZXJDQ1c6IGNzc2BcbiAgICBhbmltYXRpb24tZGlyZWN0aW9uOiByZXZlcnNlO1xuICBgLFxufSk7XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU1ZHIGZyb20gJ3JlYWN0LWlubGluZXN2Zyc7XG5cbmltcG9ydCB7XG4gIENvbG9yRGltZW5zaW9uQ29uZmlnLFxuICBSZXNvdXJjZURpbWVuc2lvbkNvbmZpZyxcbiAgUmVzb3VyY2VEaW1lbnNpb25Nb2RlLFxuICBnZXRQdWJsaWNPckFic29sdXRlVXJsLFxufSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucyc7XG5pbXBvcnQgeyBEaW1lbnNpb25Db250ZXh0IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvY29udGV4dCc7XG5pbXBvcnQgeyBDb2xvckRpbWVuc2lvbkVkaXRvciwgUmVzb3VyY2VEaW1lbnNpb25FZGl0b3IgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9lZGl0b3JzJztcbmltcG9ydCB7IEFQSUVkaXRvciwgQVBJRWRpdG9yQ29uZmlnLCBjYWxsQXBpIH0gZnJvbSAnYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL2VkaXRvci9BUElFZGl0b3InO1xuXG5pbXBvcnQgeyBDYW52YXNFbGVtZW50SXRlbSwgQ2FudmFzRWxlbWVudFByb3BzIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5pbXBvcnQgeyBMaW5lQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEljb25Db25maWcge1xuICBwYXRoPzogUmVzb3VyY2VEaW1lbnNpb25Db25maWc7XG4gIGZpbGw/OiBDb2xvckRpbWVuc2lvbkNvbmZpZztcbiAgc3Ryb2tlPzogTGluZUNvbmZpZztcbiAgYXBpPzogQVBJRWRpdG9yQ29uZmlnO1xufVxuXG5pbnRlcmZhY2UgSWNvbkRhdGEge1xuICBwYXRoOiBzdHJpbmc7XG4gIGZpbGw6IHN0cmluZztcbiAgc3Ryb2tlQ29sb3I/OiBzdHJpbmc7XG4gIHN0cm9rZT86IG51bWJlcjtcbiAgYXBpPzogQVBJRWRpdG9yQ29uZmlnO1xufVxuXG4vLyBXaGVuIGEgc3Rva2UgaXMgZGVmaW5lZCwgd2Ugd2FudCB0aGUgcGF0aCB0byBiZSBpbiBwYWdlIHVuaXRzXG5jb25zdCBzdmdTdHJva2VQYXRoQ2xhc3MgPSBjc3NgXG4gIHBhdGgge1xuICAgIHZlY3Rvci1lZmZlY3Q6IG5vbi1zY2FsaW5nLXN0cm9rZTtcbiAgfVxuYDtcblxuZXhwb3J0IGZ1bmN0aW9uIEljb25EaXNwbGF5KHByb3BzOiBDYW52YXNFbGVtZW50UHJvcHMpIHtcbiAgY29uc3QgeyBkYXRhIH0gPSBwcm9wcztcbiAgaWYgKCFkYXRhPy5wYXRoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBvbkNsaWNrID0gKCkgPT4ge1xuICAgIGlmIChkYXRhPy5hcGkpIHtcbiAgICAgIGNhbGxBcGkoZGF0YS5hcGkpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzdmdTdHlsZTogQ1NTUHJvcGVydGllcyA9IHtcbiAgICBmaWxsOiBkYXRhPy5maWxsLFxuICAgIHN0cm9rZTogZGF0YT8uc3Ryb2tlQ29sb3IsXG4gICAgc3Ryb2tlV2lkdGg6IGRhdGE/LnN0cm9rZSxcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxTVkdcbiAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICBzcmM9e2RhdGEucGF0aH1cbiAgICAgIHN0eWxlPXtzdmdTdHlsZX1cbiAgICAgIGNsYXNzTmFtZT17c3ZnU3R5bGUuc3Ryb2tlV2lkdGggPyBzdmdTdHJva2VQYXRoQ2xhc3MgOiB1bmRlZmluZWR9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IGljb25JdGVtOiBDYW52YXNFbGVtZW50SXRlbTxJY29uQ29uZmlnLCBJY29uRGF0YT4gPSB7XG4gIGlkOiAnaWNvbicsXG4gIG5hbWU6ICdJY29uJyxcbiAgZGVzY3JpcHRpb246ICdTVkcgSWNvbiBkaXNwbGF5JyxcblxuICBkaXNwbGF5OiBJY29uRGlzcGxheSxcblxuICBnZXROZXdPcHRpb25zOiAob3B0aW9ucykgPT4gKHtcbiAgICBwbGFjZW1lbnQ6IHtcbiAgICAgIHdpZHRoOiA1MCxcbiAgICAgIGhlaWdodDogNTAsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgIH0sXG4gICAgLi4ub3B0aW9ucyxcbiAgICBjb25maWc6IHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgbW9kZTogUmVzb3VyY2VEaW1lbnNpb25Nb2RlLkZpeGVkLFxuICAgICAgICBmaXhlZDogJ2ltZy9pY29ucy91bmljb25zL3F1ZXN0aW9uLWNpcmNsZS5zdmcnLFxuICAgICAgfSxcbiAgICAgIGZpbGw6IHsgZml4ZWQ6ICcjRkZGODk5JyB9LFxuICAgIH0sXG4gIH0pLFxuXG4gIC8vIENhbGxlZCB3aGVuIGRhdGEgY2hhbmdlc1xuICBwcmVwYXJlRGF0YTogKGN0eDogRGltZW5zaW9uQ29udGV4dCwgY2ZnOiBJY29uQ29uZmlnKSA9PiB7XG4gICAgbGV0IHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnLnBhdGgpIHtcbiAgICAgIHBhdGggPSBjdHguZ2V0UmVzb3VyY2UoY2ZnLnBhdGgpLnZhbHVlKCk7XG4gICAgfVxuICAgIGlmICghcGF0aCB8fCAhaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgIHBhdGggPSBnZXRQdWJsaWNPckFic29sdXRlVXJsKCdpbWcvaWNvbnMvdW5pY29ucy9xdWVzdGlvbi1jaXJjbGUuc3ZnJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YTogSWNvbkRhdGEgPSB7XG4gICAgICBwYXRoLFxuICAgICAgZmlsbDogY2ZnLmZpbGwgPyBjdHguZ2V0Q29sb3IoY2ZnLmZpbGwpLnZhbHVlKCkgOiAnI0NDQycsXG4gICAgICBhcGk6IGNmZz8uYXBpID8/IHVuZGVmaW5lZCxcbiAgICB9O1xuXG4gICAgaWYgKGNmZy5zdHJva2U/LndpZHRoICYmIGNmZy5zdHJva2UuY29sb3IpIHtcbiAgICAgIGlmIChjZmcuc3Ryb2tlLndpZHRoID4gMCkge1xuICAgICAgICBkYXRhLnN0cm9rZSA9IGNmZy5zdHJva2U/LndpZHRoO1xuICAgICAgICBkYXRhLnN0cm9rZUNvbG9yID0gY3R4LmdldENvbG9yKGNmZy5zdHJva2UuY29sb3IpLnZhbHVlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIC8vIEhlYXRtYXAgb3ZlcmxheSBvcHRpb25zXG4gIHJlZ2lzdGVyT3B0aW9uc1VJOiAoYnVpbGRlcikgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWydJY29uJ107XG4gICAgYnVpbGRlclxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2ljb25TZWxlY3RvcicsXG4gICAgICAgIHBhdGg6ICdjb25maWcucGF0aCcsXG4gICAgICAgIG5hbWU6ICdTVkcgUGF0aCcsXG4gICAgICAgIGVkaXRvcjogUmVzb3VyY2VEaW1lbnNpb25FZGl0b3IsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgcmVzb3VyY2VUeXBlOiAnaWNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2NvbmZpZy5maWxsJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5maWxsJyxcbiAgICAgICAgbmFtZTogJ0ZpbGwgY29sb3InLFxuICAgICAgICBlZGl0b3I6IENvbG9yRGltZW5zaW9uRWRpdG9yLFxuICAgICAgICBzZXR0aW5nczoge30sXG4gICAgICAgIGRlZmF1bHRWYWx1ZToge1xuICAgICAgICAgIC8vIENvbmZpZ3VyZWQgdmFsdWVzXG4gICAgICAgICAgZml4ZWQ6ICdncmV5JyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICAuYWRkU2xpZGVySW5wdXQoe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5zdHJva2Uud2lkdGgnLFxuICAgICAgICBuYW1lOiAnU3Ryb2tlJyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAwLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICBtYXg6IDEwLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdjb25maWcuc3Ryb2tlLmNvbG9yJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5zdHJva2UuY29sb3InLFxuICAgICAgICBuYW1lOiAnU3Ryb2tlIGNvbG9yJyxcbiAgICAgICAgZWRpdG9yOiBDb2xvckRpbWVuc2lvbkVkaXRvcixcbiAgICAgICAgc2V0dGluZ3M6IHt9LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHtcbiAgICAgICAgICAvLyBDb25maWd1cmVkIHZhbHVlc1xuICAgICAgICAgIGZpeGVkOiAnZ3JleScsXG4gICAgICAgIH0sXG4gICAgICAgIHNob3dJZjogKGNmZykgPT4gQm9vbGVhbihjZmc/LmNvbmZpZz8uc3Ryb2tlPy53aWR0aCksXG4gICAgICB9KVxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2FwaVNlbGVjdG9yJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5hcGknLFxuICAgICAgICBuYW1lOiAnQVBJJyxcbiAgICAgICAgZWRpdG9yOiBBUElFZGl0b3IsXG4gICAgICB9KTtcbiAgfSxcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgQ2FudmFzRWxlbWVudEl0ZW0sIENhbnZhc0VsZW1lbnRQcm9wcyB9IGZyb20gJy4uL2VsZW1lbnQnO1xuXG5pbnRlcmZhY2UgTm90Rm91bmRDb25maWcge1xuICBvcmlnPzogYW55O1xufVxuXG5jbGFzcyBOb3RGb3VuZERpc3BsYXkgZXh0ZW5kcyBQdXJlQ29tcG9uZW50PENhbnZhc0VsZW1lbnRQcm9wczxOb3RGb3VuZENvbmZpZz4+IHtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY29uZmlnIH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2PlxuICAgICAgICA8aDM+Tk9UIEZPVU5EOjwvaDM+XG4gICAgICAgIDxwcmU+e0pTT04uc3RyaW5naWZ5KGNvbmZpZywgbnVsbCwgMil9PC9wcmU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBub3RGb3VuZEl0ZW06IENhbnZhc0VsZW1lbnRJdGVtPE5vdEZvdW5kQ29uZmlnPiA9IHtcbiAgaWQ6ICdub3QtZm91bmQnLFxuICBuYW1lOiAnTm90IGZvdW5kJyxcbiAgZGVzY3JpcHRpb246ICdEaXNwbGF5IHdoZW4gZWxlbWVudCB0eXBlIGlzIG5vdCBmb3VuZCBpbiB0aGUgcmVnaXN0cnknLFxuXG4gIGRpc3BsYXk6IE5vdEZvdW5kRGlzcGxheSxcblxuICBkZWZhdWx0U2l6ZToge1xuICAgIHdpZHRoOiAxMDAsXG4gICAgaGVpZ2h0OiAxMDAsXG4gIH0sXG5cbiAgZ2V0TmV3T3B0aW9uczogKCkgPT4gKHtcbiAgICBjb25maWc6IHt9LFxuICB9KSxcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IHN0eWxlc0ZhY3RvcnkgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdhcHAvY29yZS9jb25maWcnO1xuaW1wb3J0IHsgRGltZW5zaW9uQ29udGV4dCB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2NvbnRleHQnO1xuaW1wb3J0IHsgQ29sb3JEaW1lbnNpb25FZGl0b3IgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9lZGl0b3JzL0NvbG9yRGltZW5zaW9uRWRpdG9yJztcbmltcG9ydCB7IFRleHREaW1lbnNpb25FZGl0b3IgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9lZGl0b3JzL1RleHREaW1lbnNpb25FZGl0b3InO1xuaW1wb3J0IHsgQ29sb3JEaW1lbnNpb25Db25maWcsIFRleHREaW1lbnNpb25Db25maWcgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy90eXBlcyc7XG5cbmltcG9ydCB7IENhbnZhc0VsZW1lbnRJdGVtLCBDYW52YXNFbGVtZW50UHJvcHMgfSBmcm9tICcuLi9lbGVtZW50JztcblxuZXhwb3J0IGVudW0gQWxpZ24ge1xuICBMZWZ0ID0gJ2xlZnQnLFxuICBDZW50ZXIgPSAnY2VudGVyJyxcbiAgUmlnaHQgPSAncmlnaHQnLFxufVxuXG5leHBvcnQgZW51bSBWQWxpZ24ge1xuICBUb3AgPSAndG9wJyxcbiAgTWlkZGxlID0gJ21pZGRsZScsXG4gIEJvdHRvbSA9ICdib3R0b20nLFxufVxuXG5pbnRlcmZhY2UgVGV4dEJveERhdGEge1xuICB0ZXh0Pzogc3RyaW5nO1xuICBjb2xvcj86IHN0cmluZztcbiAgc2l6ZT86IG51bWJlcjsgLy8gMCBvciBtaXNzaW5nIHdpbGwgXCJhdXRvIHNpemVcIlxuICBhbGlnbjogQWxpZ247XG4gIHZhbGlnbjogVkFsaWduO1xufVxuXG5pbnRlcmZhY2UgVGV4dEJveENvbmZpZyB7XG4gIHRleHQ/OiBUZXh0RGltZW5zaW9uQ29uZmlnO1xuICBjb2xvcj86IENvbG9yRGltZW5zaW9uQ29uZmlnO1xuICBzaXplPzogbnVtYmVyOyAvLyAwIG9yIG1pc3Npbmcgd2lsbCBcImF1dG8gc2l6ZVwiXG4gIGFsaWduOiBBbGlnbjtcbiAgdmFsaWduOiBWQWxpZ247XG59XG5cbmNsYXNzIFRleHRCb3hEaXNwbGF5IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxDYW52YXNFbGVtZW50UHJvcHM8VGV4dEJveENvbmZpZywgVGV4dEJveERhdGE+PiB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVzKGNvbmZpZy50aGVtZTIsIGRhdGEpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn0+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLnNwYW59PntkYXRhPy50ZXh0fTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbmNvbnN0IGdldFN0eWxlcyA9IHN0eWxlc0ZhY3RvcnkoKHRoZW1lOiBHcmFmYW5hVGhlbWUyLCBkYXRhKSA9PiAoe1xuICBjb250YWluZXI6IGNzc2BcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IHRhYmxlO1xuICBgLFxuICBzcGFuOiBjc3NgXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogJHtkYXRhLnZhbGlnbn07XG4gICAgdGV4dC1hbGlnbjogJHtkYXRhLmFsaWdufTtcbiAgICBmb250LXNpemU6ICR7ZGF0YT8uc2l6ZX1weDtcbiAgICBjb2xvcjogJHtkYXRhPy5jb2xvcn07XG4gIGAsXG59KSk7XG5leHBvcnQgY29uc3QgdGV4dEJveEl0ZW06IENhbnZhc0VsZW1lbnRJdGVtPFRleHRCb3hDb25maWcsIFRleHRCb3hEYXRhPiA9IHtcbiAgaWQ6ICd0ZXh0LWJveCcsXG4gIG5hbWU6ICdUZXh0JyxcbiAgZGVzY3JpcHRpb246ICdUZXh0IGJveCcsXG5cbiAgZGlzcGxheTogVGV4dEJveERpc3BsYXksXG5cbiAgZGVmYXVsdFNpemU6IHtcbiAgICB3aWR0aDogMjQwLFxuICAgIGhlaWdodDogMTYwLFxuICB9LFxuXG4gIGdldE5ld09wdGlvbnM6IChvcHRpb25zKSA9PiAoe1xuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGZpeGVkOiAnZ3JleScsXG4gICAgICB9LFxuICAgIH0sXG4gICAgLi4ub3B0aW9ucyxcbiAgICBjb25maWc6IHtcbiAgICAgIGFsaWduOiBBbGlnbi5MZWZ0LFxuICAgICAgdmFsaWduOiBWQWxpZ24uTWlkZGxlLFxuICAgIH0sXG4gIH0pLFxuXG4gIC8vIENhbGxlZCB3aGVuIGRhdGEgY2hhbmdlc1xuICBwcmVwYXJlRGF0YTogKGN0eDogRGltZW5zaW9uQ29udGV4dCwgY2ZnOiBUZXh0Qm94Q29uZmlnKSA9PiB7XG4gICAgY29uc3QgZGF0YTogVGV4dEJveERhdGEgPSB7XG4gICAgICB0ZXh0OiBjZmcudGV4dCA/IGN0eC5nZXRUZXh0KGNmZy50ZXh0KS52YWx1ZSgpIDogJycsXG4gICAgICBhbGlnbjogY2ZnLmFsaWduID8/IEFsaWduLkNlbnRlcixcbiAgICAgIHZhbGlnbjogY2ZnLnZhbGlnbiA/PyBWQWxpZ24uTWlkZGxlLFxuICAgICAgc2l6ZTogY2ZnLnNpemUsXG4gICAgfTtcblxuICAgIGlmIChjZmcuY29sb3IpIHtcbiAgICAgIGRhdGEuY29sb3IgPSBjdHguZ2V0Q29sb3IoY2ZnLmNvbG9yKS52YWx1ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIC8vIEhlYXRtYXAgb3ZlcmxheSBvcHRpb25zXG4gIHJlZ2lzdGVyT3B0aW9uc1VJOiAoYnVpbGRlcikgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWydUZXh0IGJveCddO1xuICAgIGJ1aWxkZXJcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICd0ZXh0U2VsZWN0b3InLFxuICAgICAgICBwYXRoOiAnY29uZmlnLnRleHQnLFxuICAgICAgICBuYW1lOiAnVGV4dCcsXG4gICAgICAgIGVkaXRvcjogVGV4dERpbWVuc2lvbkVkaXRvcixcbiAgICAgIH0pXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAnY29uZmlnLmNvbG9yJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5jb2xvcicsXG4gICAgICAgIG5hbWU6ICdUZXh0IGNvbG9yJyxcbiAgICAgICAgZWRpdG9yOiBDb2xvckRpbWVuc2lvbkVkaXRvcixcbiAgICAgICAgc2V0dGluZ3M6IHt9LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHt9LFxuICAgICAgfSlcbiAgICAgIC5hZGRSYWRpbyh7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBwYXRoOiAnY29uZmlnLmFsaWduJyxcbiAgICAgICAgbmFtZTogJ0FsaWduIHRleHQnLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgIHsgdmFsdWU6IEFsaWduLkxlZnQsIGxhYmVsOiAnTGVmdCcgfSxcbiAgICAgICAgICAgIHsgdmFsdWU6IEFsaWduLkNlbnRlciwgbGFiZWw6ICdDZW50ZXInIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiBBbGlnbi5SaWdodCwgbGFiZWw6ICdSaWdodCcgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IEFsaWduLkxlZnQsXG4gICAgICB9KVxuICAgICAgLmFkZFJhZGlvKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIHBhdGg6ICdjb25maWcudmFsaWduJyxcbiAgICAgICAgbmFtZTogJ1ZlcnRpY2FsIGFsaWduJyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICB7IHZhbHVlOiBWQWxpZ24uVG9wLCBsYWJlbDogJ1RvcCcgfSxcbiAgICAgICAgICAgIHsgdmFsdWU6IFZBbGlnbi5NaWRkbGUsIGxhYmVsOiAnTWlkZGxlJyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogVkFsaWduLkJvdHRvbSwgbGFiZWw6ICdCb3R0b20nIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBWQWxpZ24uTWlkZGxlLFxuICAgICAgfSlcbiAgICAgIC5hZGROdW1iZXJJbnB1dCh7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBwYXRoOiAnY29uZmlnLnNpemUnLFxuICAgICAgICBuYW1lOiAnVGV4dCBzaXplJyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJ0F1dG8nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gIH0sXG59O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyBGQyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IERpbWVuc2lvbkNvbnRleHQsIFNjYWxhckRpbWVuc2lvbkNvbmZpZyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zJztcbmltcG9ydCB7IFNjYWxhckRpbWVuc2lvbkVkaXRvciB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2VkaXRvcnMnO1xuXG5pbXBvcnQgeyBDYW52YXNFbGVtZW50SXRlbSwgQ2FudmFzRWxlbWVudFByb3BzIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5cbmludGVyZmFjZSBXaW5kVHVyYmluZURhdGEge1xuICBycG0/OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBXaW5kVHVyYmluZUNvbmZpZyB7XG4gIHJwbT86IFNjYWxhckRpbWVuc2lvbkNvbmZpZztcbn1cblxuY29uc3QgV2luZFR1cmJpbmVEaXNwbGF5OiBGQzxDYW52YXNFbGVtZW50UHJvcHM8V2luZFR1cmJpbmVDb25maWcsIFdpbmRUdXJiaW5lRGF0YT4+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICBjb25zdCB7IGRhdGEgfSA9IHByb3BzO1xuXG4gIGNvbnN0IHdpbmRUdXJiaW5lQW5pbWF0aW9uID0gYHNwaW4gJHtkYXRhPy5ycG0gPyA2MCAvIE1hdGguYWJzKGRhdGEucnBtKSA6IDB9cyBsaW5lYXIgaW5maW5pdGVgO1xuXG4gIHJldHVybiAoXG4gICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDE4OS4zMjYgMjgzLjk4OVwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCI+XG4gICAgICA8c3ltYm9sIGlkPVwiYmxhZGVcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBmaWxsPVwiI2U2ZTZlNlwiXG4gICAgICAgICAgaWQ9XCJibGFkZS1mcm9udFwiXG4gICAgICAgICAgZD1cIk0xNC42NDkxODc5LDEuODUwMTE2MDEgQzE0LjI2ODQ0NTUsLTAuMDUzNTk2Mjg3NyAxMC43MTUwODEyLC0wLjgxNTA4MTIwNiA5LjA2NDczMzE4LDMuMzczMDg1ODUgTDAuNDM0MzM4NzQ3LDcwLjc2NTg5MzMgTDguOTM4MDUxMDQsOTEuOTYwNzg4OSBMMTUuNDEwNjcyOSw5MC40Mzc4MTkgTDE3LjU2ODQ0NTUsNzguMzgwNzQyNSBMMTQuNTIxODA5NywxLjk3Njc5ODE0IEwxNC42NDkxODc5LDEuODUwMTE2MDEgWlwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZmlsbD1cIiNkMGQ2ZDdcIlxuICAgICAgICAgIGlkPVwiYmxhZGUtc2lkZVwiXG4gICAgICAgICAgZD1cIk0xMS4wOTUxMjc2LDAuNTgxMjA2NDk3IEMxMC4zMzM2NDI3LDAuOTYxOTQ4OTU2IDkuNTcyMTU3NzcsMS44NTAxMTYwMSA4LjkzNzM1NDk5LDMuMjQ2NDAzNzEgTDAuMzA2OTYwNTU3LDcwLjYzOTIxMTEgTDguODEwNjcyODUsOTEuODM0MTA2NyBMMy4zNTM1OTYyOSw3MC4wMDQ0MDg0IEwxMS4wOTUxMjc2LDAuNTgxMjA2NDk3IFpcIlxuICAgICAgICAvPlxuICAgICAgPC9zeW1ib2w+XG5cbiAgICAgIDxnPlxuICAgICAgICA8ZyBpZD1cInN0cnVjdHVyZVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg1OC4xMjMsIDgyLjY2NClcIiBmaWxsUnVsZT1cIm5vbnplcm9cIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cInRvd2VyXCIgZmlsbD1cIiNlNmU2ZTZcIiBwb2ludHM9XCIzMy4xMTEsMTAuOTg0IDM5Ljk2NSwxMC45ODQgNDQuMjgsMTk2LjE3NiAyOC43OTYsMTk2LjE3NlwiIC8+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGlkPVwieWF3XCJcbiAgICAgICAgICAgIGZpbGw9XCJyZ2JhKDAsMCwwLDAuMjUpXCJcbiAgICAgICAgICAgIGQ9XCJNNDAuMzQ1NDc1NiwyMy4yOTQ4OTU2IEw0MC43MjYyMTgxLDM0Ljg0NDU0NzYgQzM4LjgyMjUwNTgsMzUuMDk4NjA3OSAzNS43NzY1NjYxLDM1LjA5ODYwNzkgMzIuMzQ5ODg0LDM0LjMzNzEyMyBMMzIuNzMwNjI2NSwyMy4yOTU1OTE2IEw0MC4zNDU0NzU2LDIzLjI5NTU5MTYgTDQwLjM0NTQ3NTYsMjMuMjk0ODk1NiBaXCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICBpZD1cImJhc2VcIlxuICAgICAgICAgICAgZmlsbD1cIiNkMGQ2ZDdcIlxuICAgICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAgNDIpXCJcbiAgICAgICAgICAgIGQ9XCJNMjYuMzg0Njg2OCwxNTAuNTkxNjQ3IEw0Ni41NjQwMzcxLDE1MC41OTE2NDcgQzQ4Ljg0ODQ5MTksMTUwLjU5MTY0NyA1MC43NTIyMDQyLDE1Mi40OTUzNiA1MC43NTIyMDQyLDE1NC43Nzk4MTQgTDUwLjc1MjIwNDIsMTU4Ljk2Nzk4MSBMMjIuMDY5MTQxNSwxNTguOTY3OTgxIEwyMi4wNjkxNDE1LDE1NC43Nzk4MTQgQzIyLjA2OTE0MTUsMTUyLjQ5NTM2IDIzLjk3Mjg1MzgsMTUwLjU5MTY0NyAyNi4yNTczMDg2LDE1MC41OTE2NDcgTDI2LjM4NDY4NjgsMTUwLjU5MTY0NyBaXCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxjaXJjbGUgaWQ9XCJuYWNlbGxlXCIgZmlsbD1cIiNlNmU2ZTZcIiBjeD1cIjM2LjU0XCIgY3k9XCIxMlwiIHI9XCIxMS45M1wiIC8+XG4gICAgICAgICAgPGNpcmNsZSBpZD1cImdlYXJib3hcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cIiNkMGQ2ZDdcIiBzdHJva2VXaWR0aD1cIjIuNzVcIiBjeD1cIjM2LjUzOFwiIGN5PVwiMTEuOTk5XCIgcj1cIjUuOFwiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgY2xhc3NOYW1lPXtzdHlsZXMuYmxhZGV9IHN0eWxlPXt7IGFuaW1hdGlvbjogd2luZFR1cmJpbmVBbmltYXRpb24gfX0+XG4gICAgICAgICAgPHVzZSBpZD1cImJsYWRlMVwiIGhyZWY9XCIjYmxhZGVcIiB4PVwiODMuMjRcIiB5PVwiMFwiIC8+XG4gICAgICAgICAgPHVzZSBpZD1cImJsYWRlMlwiIGhyZWY9XCIjYmxhZGVcIiB4PVwiODMuMjRcIiB5PVwiMFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgxMjAgOTQuNjYzIDk0LjY2MylcIiAvPlxuICAgICAgICAgIDx1c2UgaWQ9XCJibGFkZTNcIiBocmVmPVwiI2JsYWRlXCIgeD1cIjgzLjI0XCIgeT1cIjBcIiB0cmFuc2Zvcm09XCJyb3RhdGUoLTEyMCA5NC42NjMgOTQuNjYzKVwiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvZz5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCB3aW5kVHVyYmluZUl0ZW06IENhbnZhc0VsZW1lbnRJdGVtPGFueSwgYW55PiA9IHtcbiAgaWQ6ICd3aW5kVHVyYmluZScsXG4gIG5hbWU6ICdXaW5kIFR1cmJpbmUnLFxuICBkZXNjcmlwdGlvbjogJ1NwaW5ueSBzcGlubnknLFxuXG4gIGRpc3BsYXk6IFdpbmRUdXJiaW5lRGlzcGxheSxcblxuICBkZWZhdWx0U2l6ZToge1xuICAgIHdpZHRoOiAxMDAsXG4gICAgaGVpZ2h0OiAxMDAsXG4gIH0sXG5cbiAgZ2V0TmV3T3B0aW9uczogKG9wdGlvbnMpID0+ICh7XG4gICAgLi4ub3B0aW9ucyxcbiAgfSksXG5cbiAgLy8gQ2FsbGVkIHdoZW4gZGF0YSBjaGFuZ2VzXG4gIHByZXBhcmVEYXRhOiAoY3R4OiBEaW1lbnNpb25Db250ZXh0LCBjZmc6IFdpbmRUdXJiaW5lQ29uZmlnKSA9PiB7XG4gICAgY29uc3QgZGF0YTogV2luZFR1cmJpbmVEYXRhID0ge1xuICAgICAgcnBtOiBjZmc/LnJwbSA/IGN0eC5nZXRTY2FsYXIoY2ZnLnJwbSkudmFsdWUoKSA6IDAsXG4gICAgfTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIHJlZ2lzdGVyT3B0aW9uc1VJOiAoYnVpbGRlcikgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWydXaW5kIFR1cmJpbmUnXTtcbiAgICBidWlsZGVyLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICBjYXRlZ29yeSxcbiAgICAgIGlkOiAncnBtJyxcbiAgICAgIHBhdGg6ICdjb25maWcucnBtJyxcbiAgICAgIG5hbWU6ICdSUE0nLFxuICAgICAgZWRpdG9yOiBTY2FsYXJEaW1lbnNpb25FZGl0b3IsXG4gICAgfSk7XG4gIH0sXG59O1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+ICh7XG4gIGJsYWRlOiBjc3NgXG4gICAgQGtleWZyYW1lcyBzcGluIHtcbiAgICAgIGZyb20ge1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgICAgIH1cbiAgICAgIHRvIHtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiA5NC42NjNweCA5NC42NjNweDtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxNWRlZyk7XG4gIGAsXG59KTtcbiIsImltcG9ydCB7IENhbnZhc0VsZW1lbnRPcHRpb25zIH0gZnJvbSAnLi9lbGVtZW50JztcblxuZXhwb3J0IGludGVyZmFjZSBDYW52YXNGcmFtZU9wdGlvbnMgZXh0ZW5kcyBDYW52YXNFbGVtZW50T3B0aW9ucyB7XG4gIHR5cGU6ICdmcmFtZSc7XG4gIGVsZW1lbnRzOiBDYW52YXNFbGVtZW50T3B0aW9uc1tdO1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2VsZW1lbnQnO1xuZXhwb3J0IHsgQ2FudmFzRnJhbWVPcHRpb25zIH0gZnJvbSAnLi9mcmFtZSc7XG5leHBvcnQgKiBmcm9tICcuL3JlZ2lzdHJ5JztcbiIsImltcG9ydCB7IFJlZ2lzdHJ5IH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IENhbnZhc0VsZW1lbnRJdGVtLCBDYW52YXNFbGVtZW50T3B0aW9ucyB9IGZyb20gJy4vZWxlbWVudCc7XG5pbXBvcnQgeyBidXR0b25JdGVtIH0gZnJvbSAnLi9lbGVtZW50cy9idXR0b24nO1xuaW1wb3J0IHsgZHJvbmVGcm9udEl0ZW0gfSBmcm9tICcuL2VsZW1lbnRzL2Ryb25lRnJvbnQnO1xuaW1wb3J0IHsgZHJvbmVTaWRlSXRlbSB9IGZyb20gJy4vZWxlbWVudHMvZHJvbmVTaWRlJztcbmltcG9ydCB7IGRyb25lVG9wSXRlbSB9IGZyb20gJy4vZWxlbWVudHMvZHJvbmVUb3AnO1xuaW1wb3J0IHsgaWNvbkl0ZW0gfSBmcm9tICcuL2VsZW1lbnRzL2ljb24nO1xuaW1wb3J0IHsgdGV4dEJveEl0ZW0gfSBmcm9tICcuL2VsZW1lbnRzL3RleHRCb3gnO1xuaW1wb3J0IHsgd2luZFR1cmJpbmVJdGVtIH0gZnJvbSAnLi9lbGVtZW50cy93aW5kVHVyYmluZSc7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0NBTlZBU19FTEVNRU5UX0NPTkZJRzogQ2FudmFzRWxlbWVudE9wdGlvbnMgPSB7XG4gIC4uLmljb25JdGVtLmdldE5ld09wdGlvbnMoKSxcbiAgdHlwZTogaWNvbkl0ZW0uaWQsXG4gIG5hbWU6IGBFbGVtZW50IDFgLFxufTtcblxuZXhwb3J0IGNvbnN0IGNhbnZhc0VsZW1lbnRSZWdpc3RyeSA9IG5ldyBSZWdpc3RyeTxDYW52YXNFbGVtZW50SXRlbT4oKCkgPT4gW1xuICBpY29uSXRlbSwgLy8gZGVmYXVsdCBmb3Igbm93XG4gIHRleHRCb3hJdGVtLFxuICBidXR0b25JdGVtLFxuICBkcm9uZVRvcEl0ZW0sXG4gIGRyb25lRnJvbnRJdGVtLFxuICBkcm9uZVNpZGVJdGVtLFxuICB3aW5kVHVyYmluZUl0ZW0sXG5dKTtcbiIsImltcG9ydCB7IE1vdmVhYmxlTWFuYWdlckludGVyZmFjZSwgUmVuZGVyZXIgfSBmcm9tICdtb3ZlYWJsZSc7XG5cbmltcG9ydCB7IEhvcml6b250YWxDb25zdHJhaW50LCBWZXJ0aWNhbENvbnN0cmFpbnQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFNjZW5lIH0gZnJvbSAnLi9zY2VuZSc7XG5cbmV4cG9ydCBjb25zdCBkaW1lbnNpb25WaWV3YWJsZSA9IHtcbiAgbmFtZTogJ2RpbWVuc2lvblZpZXdhYmxlJyxcbiAgcHJvcHM6IHt9LFxuICBldmVudHM6IHt9LFxuICByZW5kZXIobW92ZWFibGU6IE1vdmVhYmxlTWFuYWdlckludGVyZmFjZTxhbnksIGFueT4sIFJlYWN0OiBSZW5kZXJlcikge1xuICAgIGNvbnN0IHJlY3QgPSBtb3ZlYWJsZS5nZXRSZWN0KCk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAga2V5PXsnZGltZW5zaW9uLXZpZXdhYmxlJ31cbiAgICAgICAgY2xhc3NOYW1lPXsnbW92ZWFibGUtZGltZW5zaW9uJ31cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBsZWZ0OiBgJHtyZWN0LndpZHRoIC8gMn1weGAsXG4gICAgICAgICAgdG9wOiBgJHtyZWN0LmhlaWdodCArIDIwfXB4YCxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnIzRhZicsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMnB4JyxcbiAgICAgICAgICBwYWRkaW5nOiAnMnB4IDRweCcsXG4gICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgZm9udFNpemU6ICcxM3B4JyxcbiAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgd2lsbENoYW5nZTogJ3RyYW5zZm9ybScsXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIDBweCknLFxuICAgICAgICAgIHpJbmRleDogMTAwLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7TWF0aC5yb3VuZChyZWN0Lm9mZnNldFdpZHRoKX0geCB7TWF0aC5yb3VuZChyZWN0Lm9mZnNldEhlaWdodCl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IGNvbnN0cmFpbnRWaWV3YWJsZSA9IChzY2VuZTogU2NlbmUpID0+ICh7XG4gIG5hbWU6ICdjb25zdHJhaW50Vmlld2FibGUnLFxuICBwcm9wczoge30sXG4gIGV2ZW50czoge30sXG4gIHJlbmRlcihtb3ZlYWJsZTogTW92ZWFibGVNYW5hZ2VySW50ZXJmYWNlPGFueSwgYW55PiwgUmVhY3Q6IFJlbmRlcmVyKSB7XG4gICAgY29uc3QgcmVjdCA9IG1vdmVhYmxlLmdldFJlY3QoKTtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gc2NlbmUuZmluZEVsZW1lbnRCeVRhcmdldChtb3ZlYWJsZS5zdGF0ZS50YXJnZXQpO1xuXG4gICAgLy8gSWYgdGFyZ2V0IGlzIGN1cnJlbnRseSBpbiBtb3Rpb24gb3Igc2VsZWN0aW9uIGlzIG1vcmUgdGhhbiAxIGVsZW1lbnQgZG9uJ3QgZGlzcGxheSBjb25zdHJhaW50IHZpc3VhbGl6YXRpb25zXG4gICAgaWYgKFxuICAgICAgdGFyZ2V0RWxlbWVudD8uaXNNb3ZpbmcgfHxcbiAgICAgIChzY2VuZS5zZWxlY3RvPy5nZXRTZWxlY3RlZFRhcmdldHMoKSAmJiBzY2VuZS5zZWxlY3RvPy5nZXRTZWxlY3RlZFRhcmdldHMoKS5sZW5ndGggPiAxKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB2ZXJ0aWNhbENvbnN0cmFpbnRWaXN1YWxpemF0aW9uID0gbnVsbDtcbiAgICBsZXQgaG9yaXpvbnRhbENvbnN0cmFpbnRWaXN1YWxpemF0aW9uID0gbnVsbDtcblxuICAgIGNvbnN0IGNvbnN0cmFpbnQgPSB0YXJnZXRFbGVtZW50Py50ZW1wQ29uc3RyYWludCA/PyB0YXJnZXRFbGVtZW50Py5vcHRpb25zLmNvbnN0cmFpbnQgPz8ge307XG5cbiAgICBjb25zdCBib3JkZXJTdHlsZSA9ICcxcHggZGFzaGVkICM0YWYnO1xuXG4gICAgY29uc3QgY2VudGVySW5kaWNhdG9yTGluZU9uZSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBsZWZ0OiBgJHtyZWN0LndpZHRoIC8gMn1weGAsXG4gICAgICAgIHRvcDogYCR7cmVjdC5oZWlnaHQgLyAyIC0gcmVjdC5oZWlnaHQgLyAxNn1weGAsXG4gICAgICAgIGJvcmRlckxlZnQ6IGJvcmRlclN0eWxlLFxuICAgICAgICBoZWlnaHQ6IGAke3JlY3QuaGVpZ2h0IC8gOH1weGAsXG4gICAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSg0NWRlZyknLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNlbnRlckluZGljYXRvckxpbmVUd28gPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgbGVmdDogYCR7cmVjdC53aWR0aCAvIDJ9cHhgLFxuICAgICAgICB0b3A6IGAke3JlY3QuaGVpZ2h0IC8gMiAtIHJlY3QuaGVpZ2h0IC8gMTZ9cHhgLFxuICAgICAgICBib3JkZXJMZWZ0OiBib3JkZXJTdHlsZSxcbiAgICAgICAgaGVpZ2h0OiBgJHtyZWN0LmhlaWdodCAvIDh9cHhgLFxuICAgICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoLTQ1ZGVnKScsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgY2VudGVySW5kaWNhdG9yID0gUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge30sIFtjZW50ZXJJbmRpY2F0b3JMaW5lT25lLCBjZW50ZXJJbmRpY2F0b3JMaW5lVHdvXSk7XG5cbiAgICBjb25zdCB2ZXJ0aWNhbENvbnN0cmFpbnRUb3AgPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgbGVmdDogYCR7cmVjdC53aWR0aCAvIDJ9cHhgLFxuICAgICAgICBib3R0b206ICcwcHgnLFxuICAgICAgICBib3JkZXJMZWZ0OiBib3JkZXJTdHlsZSxcbiAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHZlcnRpY2FsQ29uc3RyYWludEJvdHRvbSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBsZWZ0OiBgJHtyZWN0LndpZHRoIC8gMn1weGAsXG4gICAgICAgIHRvcDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICBib3JkZXJMZWZ0OiBib3JkZXJTdHlsZSxcbiAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHZlcnRpY2FsQ29uc3RyYWludFRvcEJvdHRvbSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHt9LCBbXG4gICAgICB2ZXJ0aWNhbENvbnN0cmFpbnRUb3AsXG4gICAgICB2ZXJ0aWNhbENvbnN0cmFpbnRCb3R0b20sXG4gICAgXSk7XG5cbiAgICBjb25zdCB2ZXJ0aWNhbENvbnN0cmFpbnRDZW50ZXJMaW5lID0gUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIGxlZnQ6IGAke3JlY3Qud2lkdGggLyAyfXB4YCxcbiAgICAgICAgdG9wOiBgJHtyZWN0LmhlaWdodCAvIDR9cHhgLFxuICAgICAgICBib3JkZXJMZWZ0OiBib3JkZXJTdHlsZSxcbiAgICAgICAgaGVpZ2h0OiBgJHtyZWN0LmhlaWdodCAvIDJ9cHhgLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHZlcnRpY2FsQ29uc3RyYWludENlbnRlciA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHt9LCBbdmVydGljYWxDb25zdHJhaW50Q2VudGVyTGluZSwgY2VudGVySW5kaWNhdG9yXSk7XG5cbiAgICBzd2l0Y2ggKGNvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgIGNhc2UgVmVydGljYWxDb25zdHJhaW50LlRvcDpcbiAgICAgICAgdmVydGljYWxDb25zdHJhaW50VmlzdWFsaXphdGlvbiA9IHZlcnRpY2FsQ29uc3RyYWludFRvcDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFZlcnRpY2FsQ29uc3RyYWludC5Cb3R0b206XG4gICAgICAgIHZlcnRpY2FsQ29uc3RyYWludFZpc3VhbGl6YXRpb24gPSB2ZXJ0aWNhbENvbnN0cmFpbnRCb3R0b207XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wQm90dG9tOlxuICAgICAgICB2ZXJ0aWNhbENvbnN0cmFpbnRWaXN1YWxpemF0aW9uID0gdmVydGljYWxDb25zdHJhaW50VG9wQm90dG9tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVmVydGljYWxDb25zdHJhaW50LkNlbnRlcjpcbiAgICAgICAgdmVydGljYWxDb25zdHJhaW50VmlzdWFsaXphdGlvbiA9IHZlcnRpY2FsQ29uc3RyYWludENlbnRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3QgaG9yaXpvbnRhbENvbnN0cmFpbnRMZWZ0ID0gUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHJpZ2h0OiAnMHB4JyxcbiAgICAgICAgdG9wOiBgJHtyZWN0LmhlaWdodCAvIDJ9cHhgLFxuICAgICAgICBib3JkZXJUb3A6IGJvcmRlclN0eWxlLFxuICAgICAgICB3aWR0aDogJzEwMHZ3JyxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBob3Jpem9udGFsQ29uc3RyYWludFJpZ2h0ID0gUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIGxlZnQ6IGAke3JlY3Qud2lkdGh9cHhgLFxuICAgICAgICB0b3A6IGAke3JlY3QuaGVpZ2h0IC8gMn1weGAsXG4gICAgICAgIGJvcmRlclRvcDogYm9yZGVyU3R5bGUsXG4gICAgICAgIHdpZHRoOiAnMTAwdncnLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGhvcml6b250YWxDb25zdHJhaW50TGVmdFJpZ2h0ID0gUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge30sIFtcbiAgICAgIGhvcml6b250YWxDb25zdHJhaW50TGVmdCxcbiAgICAgIGhvcml6b250YWxDb25zdHJhaW50UmlnaHQsXG4gICAgXSk7XG5cbiAgICBjb25zdCBob3Jpem9udGFsQ29uc3RyYWludENlbnRlckxpbmUgPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgbGVmdDogYCR7cmVjdC53aWR0aCAvIDR9cHhgLFxuICAgICAgICB0b3A6IGAke3JlY3QuaGVpZ2h0IC8gMn1weGAsXG4gICAgICAgIGJvcmRlclRvcDogYm9yZGVyU3R5bGUsXG4gICAgICAgIHdpZHRoOiBgJHtyZWN0LndpZHRoIC8gMn1weGAsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgaG9yaXpvbnRhbENvbnN0cmFpbnRDZW50ZXIgPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7fSwgW1xuICAgICAgaG9yaXpvbnRhbENvbnN0cmFpbnRDZW50ZXJMaW5lLFxuICAgICAgY2VudGVySW5kaWNhdG9yLFxuICAgIF0pO1xuXG4gICAgc3dpdGNoIChjb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgIGNhc2UgSG9yaXpvbnRhbENvbnN0cmFpbnQuTGVmdDpcbiAgICAgICAgaG9yaXpvbnRhbENvbnN0cmFpbnRWaXN1YWxpemF0aW9uID0gaG9yaXpvbnRhbENvbnN0cmFpbnRMZWZ0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9yaXpvbnRhbENvbnN0cmFpbnQuUmlnaHQ6XG4gICAgICAgIGhvcml6b250YWxDb25zdHJhaW50VmlzdWFsaXphdGlvbiA9IGhvcml6b250YWxDb25zdHJhaW50UmlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0UmlnaHQ6XG4gICAgICAgIGhvcml6b250YWxDb25zdHJhaW50VmlzdWFsaXphdGlvbiA9IGhvcml6b250YWxDb25zdHJhaW50TGVmdFJpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9yaXpvbnRhbENvbnN0cmFpbnQuQ2VudGVyOlxuICAgICAgICBob3Jpem9udGFsQ29uc3RyYWludFZpc3VhbGl6YXRpb24gPSBob3Jpem9udGFsQ29uc3RyYWludENlbnRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3QgY29uc3RyYWludFZpc3VhbGl6YXRpb24gPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7fSwgW1xuICAgICAgdmVydGljYWxDb25zdHJhaW50VmlzdWFsaXphdGlvbixcbiAgICAgIGhvcml6b250YWxDb25zdHJhaW50VmlzdWFsaXphdGlvbixcbiAgICBdKTtcblxuICAgIHJldHVybiBjb25zdHJhaW50VmlzdWFsaXphdGlvbjtcbiAgfSxcbn0pO1xuIiwiaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBPbkRyYWcsIE9uUmVzaXplIH0gZnJvbSAncmVhY3QtbW92ZWFibGUvZGVjbGFyYXRpb24vdHlwZXMnO1xuXG5pbXBvcnQgeyBMYXllckVsZW1lbnQgfSBmcm9tICdhcHAvY29yZS9jb21wb25lbnRzL0xheWVycy90eXBlcyc7XG5pbXBvcnQge1xuICBCYWNrZ3JvdW5kSW1hZ2VTaXplLFxuICBDYW52YXNFbGVtZW50SXRlbSxcbiAgQ2FudmFzRWxlbWVudE9wdGlvbnMsXG4gIGNhbnZhc0VsZW1lbnRSZWdpc3RyeSxcbn0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcyc7XG5pbXBvcnQgeyBub3RGb3VuZEl0ZW0gfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL25vdEZvdW5kJztcbmltcG9ydCB7IERpbWVuc2lvbkNvbnRleHQgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucyc7XG5cbmltcG9ydCB7IENvbnN0cmFpbnQsIEhvcml6b250YWxDb25zdHJhaW50LCBQbGFjZW1lbnQsIFZlcnRpY2FsQ29uc3RyYWludCB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgRnJhbWVTdGF0ZSB9IGZyb20gJy4vZnJhbWUnO1xuaW1wb3J0IHsgUm9vdEVsZW1lbnQgfSBmcm9tICcuL3Jvb3QnO1xuaW1wb3J0IHsgU2NlbmUgfSBmcm9tICcuL3NjZW5lJztcblxubGV0IGNvdW50ZXIgPSAwO1xuXG5leHBvcnQgY2xhc3MgRWxlbWVudFN0YXRlIGltcGxlbWVudHMgTGF5ZXJFbGVtZW50IHtcbiAgLy8gVUlEIG5lY2Vzc2FyeSBmb3IgbW92ZWFibGUgdG8gd29yayAoZm9yIG5vdylcbiAgcmVhZG9ubHkgVUlEID0gY291bnRlcisrO1xuICByZXZJZCA9IDA7XG4gIHNpemVTdHlsZTogQ1NTUHJvcGVydGllcyA9IHt9O1xuICBkYXRhU3R5bGU6IENTU1Byb3BlcnRpZXMgPSB7fTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgZWxlbWVudCBpcyBpbiBtb3Rpb24gb3Igbm90ICh2aWEgbW92ZWFibGUpXG4gIGlzTW92aW5nID0gZmFsc2U7XG5cbiAgLy8gVGVtcCBzdG9yZWQgY29uc3RyYWludCBmb3IgdmlzdWFsaXphdGlvbiBwdXJwb3NlcyAoc3dpdGNoIHRvIHRvcCAvIGxlZnQgY29uc3RyYWludCB0byBzaW1wbGlmeSBzb21lIGZ1bmN0aW9uYWxpdHkpXG4gIHRlbXBDb25zdHJhaW50OiBDb25zdHJhaW50IHwgdW5kZWZpbmVkO1xuXG4gIC8vIEZpbGxlZCBpbiBieSByZWZcbiAgZGl2PzogSFRNTERpdkVsZW1lbnQ7XG5cbiAgLy8gQ2FsY3VsYXRlZFxuICBkYXRhPzogYW55OyAvLyBkZXBlbmRzIG9uIHRoZSB0eXBlXG5cbiAgY29uc3RydWN0b3IocHVibGljIGl0ZW06IENhbnZhc0VsZW1lbnRJdGVtLCBwdWJsaWMgb3B0aW9uczogQ2FudmFzRWxlbWVudE9wdGlvbnMsIHB1YmxpYyBwYXJlbnQ/OiBGcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgZmFsbGJhY2tOYW1lID0gYEVsZW1lbnQgJHtEYXRlLm5vdygpfWA7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7IHR5cGU6IGl0ZW0uaWQsIG5hbWU6IGZhbGxiYWNrTmFtZSB9O1xuICAgIH1cblxuICAgIG9wdGlvbnMuY29uc3RyYWludCA9IG9wdGlvbnMuY29uc3RyYWludCA/PyB7XG4gICAgICB2ZXJ0aWNhbDogVmVydGljYWxDb25zdHJhaW50LlRvcCxcbiAgICAgIGhvcml6b250YWw6IEhvcml6b250YWxDb25zdHJhaW50LkxlZnQsXG4gICAgfTtcbiAgICBvcHRpb25zLnBsYWNlbWVudCA9IG9wdGlvbnMucGxhY2VtZW50ID8/IHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAsIHRvcDogMCwgbGVmdDogMCB9O1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5nZXRTY2VuZSgpO1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICBjb25zdCBuZXdOYW1lID0gc2NlbmU/LmdldE5leHRFbGVtZW50TmFtZSgpO1xuICAgICAgb3B0aW9ucy5uYW1lID0gbmV3TmFtZSA/PyBmYWxsYmFja05hbWU7XG4gICAgfVxuICAgIHNjZW5lPy5ieU5hbWUuc2V0KG9wdGlvbnMubmFtZSwgdGhpcyk7XG4gIH1cblxuICBwcml2YXRlIGdldFNjZW5lKCk6IFNjZW5lIHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgdHJhdiA9IHRoaXMucGFyZW50O1xuICAgIHdoaWxlICh0cmF2KSB7XG4gICAgICBpZiAodHJhdi5pc1Jvb3QoKSkge1xuICAgICAgICByZXR1cm4gdHJhdi5zY2VuZTtcbiAgICAgIH1cbiAgICAgIHRyYXYgPSB0cmF2LnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm5hbWU7XG4gIH1cblxuICAvKiogVXNlIHRoZSBjb25maWd1cmVkIG9wdGlvbnMgdG8gdXBkYXRlIENTUyBzdHlsZSBwcm9wZXJ0aWVzIGRpcmVjdGx5IG9uIHRoZSB3cmFwcGVyIGRpdiAqKi9cbiAgYXBwbHlMYXlvdXRTdHlsZXNUb0RpdigpIHtcbiAgICBpZiAodGhpcy5pc1Jvb3QoKSkge1xuICAgICAgLy8gUm9vdCBzdXBlcnNlZGVzIGxheW91dCBlbmdpbmUgYW5kIGlzIGFsd2F5cyAxMDAlIHdpZHRoICsgaGVpZ2h0IG9mIHBhbmVsXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBjb25zdHJhaW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgeyB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCB9ID0gY29uc3RyYWludCA/PyB7fTtcbiAgICBjb25zdCBwbGFjZW1lbnQgPSB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID8/ICh7fSBhcyBQbGFjZW1lbnQpO1xuXG4gICAgY29uc3Qgc3R5bGU6IFJlYWN0LkNTU1Byb3BlcnRpZXMgPSB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIC8vIE1pbmltdW0gZWxlbWVudCBzaXplIGlzIDEweDEwXG4gICAgICBtaW5XaWR0aDogJzEwcHgnLFxuICAgICAgbWluSGVpZ2h0OiAnMTBweCcsXG4gICAgfTtcblxuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IFsnMHB4JywgJzBweCddO1xuXG4gICAgc3dpdGNoICh2ZXJ0aWNhbCkge1xuICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wOlxuICAgICAgICBwbGFjZW1lbnQudG9wID0gcGxhY2VtZW50LnRvcCA/PyAwO1xuICAgICAgICBwbGFjZW1lbnQuaGVpZ2h0ID0gcGxhY2VtZW50LmhlaWdodCA/PyAxMDA7XG4gICAgICAgIHN0eWxlLnRvcCA9IGAke3BsYWNlbWVudC50b3B9cHhgO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtwbGFjZW1lbnQuaGVpZ2h0fXB4YDtcbiAgICAgICAgZGVsZXRlIHBsYWNlbWVudC5ib3R0b207XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuQm90dG9tOlxuICAgICAgICBwbGFjZW1lbnQuYm90dG9tID0gcGxhY2VtZW50LmJvdHRvbSA/PyAwO1xuICAgICAgICBwbGFjZW1lbnQuaGVpZ2h0ID0gcGxhY2VtZW50LmhlaWdodCA/PyAxMDA7XG4gICAgICAgIHN0eWxlLmJvdHRvbSA9IGAke3BsYWNlbWVudC5ib3R0b219cHhgO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtwbGFjZW1lbnQuaGVpZ2h0fXB4YDtcbiAgICAgICAgZGVsZXRlIHBsYWNlbWVudC50b3A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wQm90dG9tOlxuICAgICAgICBwbGFjZW1lbnQudG9wID0gcGxhY2VtZW50LnRvcCA/PyAwO1xuICAgICAgICBwbGFjZW1lbnQuYm90dG9tID0gcGxhY2VtZW50LmJvdHRvbSA/PyAwO1xuICAgICAgICBzdHlsZS50b3AgPSBgJHtwbGFjZW1lbnQudG9wfXB4YDtcbiAgICAgICAgc3R5bGUuYm90dG9tID0gYCR7cGxhY2VtZW50LmJvdHRvbX1weGA7XG4gICAgICAgIGRlbGV0ZSBwbGFjZW1lbnQuaGVpZ2h0O1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFZlcnRpY2FsQ29uc3RyYWludC5DZW50ZXI6XG4gICAgICAgIHBsYWNlbWVudC50b3AgPSBwbGFjZW1lbnQudG9wID8/IDA7XG4gICAgICAgIHBsYWNlbWVudC5oZWlnaHQgPSBwbGFjZW1lbnQuaGVpZ2h0ID8/IDEwMDtcbiAgICAgICAgdHJhbnNsYXRlWzFdID0gJy01MCUnO1xuICAgICAgICBzdHlsZS50b3AgPSBgY2FsYyg1MCUgLSAke3BsYWNlbWVudC50b3B9cHgpYDtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7cGxhY2VtZW50LmhlaWdodH1weGA7XG4gICAgICAgIGRlbGV0ZSBwbGFjZW1lbnQuYm90dG9tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVmVydGljYWxDb25zdHJhaW50LlNjYWxlOlxuICAgICAgICBwbGFjZW1lbnQudG9wID0gcGxhY2VtZW50LnRvcCA/PyAwO1xuICAgICAgICBwbGFjZW1lbnQuYm90dG9tID0gcGxhY2VtZW50LmJvdHRvbSA/PyAwO1xuICAgICAgICBzdHlsZS50b3AgPSBgJHtwbGFjZW1lbnQudG9wfSVgO1xuICAgICAgICBzdHlsZS5ib3R0b20gPSBgJHtwbGFjZW1lbnQuYm90dG9tfSVgO1xuICAgICAgICBkZWxldGUgcGxhY2VtZW50LmhlaWdodDtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHN3aXRjaCAoaG9yaXpvbnRhbCkge1xuICAgICAgY2FzZSBIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0OlxuICAgICAgICBwbGFjZW1lbnQubGVmdCA9IHBsYWNlbWVudC5sZWZ0ID8/IDA7XG4gICAgICAgIHBsYWNlbWVudC53aWR0aCA9IHBsYWNlbWVudC53aWR0aCA/PyAxMDA7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBgJHtwbGFjZW1lbnQubGVmdH1weGA7XG4gICAgICAgIHN0eWxlLndpZHRoID0gYCR7cGxhY2VtZW50LndpZHRofXB4YDtcbiAgICAgICAgZGVsZXRlIHBsYWNlbWVudC5yaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvcml6b250YWxDb25zdHJhaW50LlJpZ2h0OlxuICAgICAgICBwbGFjZW1lbnQucmlnaHQgPSBwbGFjZW1lbnQucmlnaHQgPz8gMDtcbiAgICAgICAgcGxhY2VtZW50LndpZHRoID0gcGxhY2VtZW50LndpZHRoID8/IDEwMDtcbiAgICAgICAgc3R5bGUucmlnaHQgPSBgJHtwbGFjZW1lbnQucmlnaHR9cHhgO1xuICAgICAgICBzdHlsZS53aWR0aCA9IGAke3BsYWNlbWVudC53aWR0aH1weGA7XG4gICAgICAgIGRlbGV0ZSBwbGFjZW1lbnQubGVmdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvcml6b250YWxDb25zdHJhaW50LkxlZnRSaWdodDpcbiAgICAgICAgcGxhY2VtZW50LmxlZnQgPSBwbGFjZW1lbnQubGVmdCA/PyAwO1xuICAgICAgICBwbGFjZW1lbnQucmlnaHQgPSBwbGFjZW1lbnQucmlnaHQgPz8gMDtcbiAgICAgICAgc3R5bGUubGVmdCA9IGAke3BsYWNlbWVudC5sZWZ0fXB4YDtcbiAgICAgICAgc3R5bGUucmlnaHQgPSBgJHtwbGFjZW1lbnQucmlnaHR9cHhgO1xuICAgICAgICBkZWxldGUgcGxhY2VtZW50LndpZHRoO1xuICAgICAgICBzdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9yaXpvbnRhbENvbnN0cmFpbnQuQ2VudGVyOlxuICAgICAgICBwbGFjZW1lbnQubGVmdCA9IHBsYWNlbWVudC5sZWZ0ID8/IDA7XG4gICAgICAgIHBsYWNlbWVudC53aWR0aCA9IHBsYWNlbWVudC53aWR0aCA/PyAxMDA7XG4gICAgICAgIHRyYW5zbGF0ZVswXSA9ICctNTAlJztcbiAgICAgICAgc3R5bGUubGVmdCA9IGBjYWxjKDUwJSAtICR7cGxhY2VtZW50LmxlZnR9cHgpYDtcbiAgICAgICAgc3R5bGUud2lkdGggPSBgJHtwbGFjZW1lbnQud2lkdGh9cHhgO1xuICAgICAgICBkZWxldGUgcGxhY2VtZW50LnJpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9yaXpvbnRhbENvbnN0cmFpbnQuU2NhbGU6XG4gICAgICAgIHBsYWNlbWVudC5sZWZ0ID0gcGxhY2VtZW50LmxlZnQgPz8gMDtcbiAgICAgICAgcGxhY2VtZW50LnJpZ2h0ID0gcGxhY2VtZW50LnJpZ2h0ID8/IDA7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBgJHtwbGFjZW1lbnQubGVmdH0lYDtcbiAgICAgICAgc3R5bGUucmlnaHQgPSBgJHtwbGFjZW1lbnQucmlnaHR9JWA7XG4gICAgICAgIGRlbGV0ZSBwbGFjZW1lbnQud2lkdGg7XG4gICAgICAgIHN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt0cmFuc2xhdGVbMF19LCAke3RyYW5zbGF0ZVsxXX0pYDtcbiAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgIHRoaXMuc2l6ZVN0eWxlID0gc3R5bGU7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnNpemVTdHlsZSkge1xuICAgICAgICB0aGlzLmRpdi5zdHlsZVtrZXkgYXMgYW55XSA9ICh0aGlzLnNpemVTdHlsZSBhcyBhbnkpW2tleV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZGF0YVN0eWxlKSB7XG4gICAgICAgIHRoaXMuZGl2LnN0eWxlW2tleSBhcyBhbnldID0gKHRoaXMuZGF0YVN0eWxlIGFzIGFueSlba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRQbGFjZW1lbnRGcm9tQ29uc3RyYWludChlbGVtZW50Q29udGFpbmVyPzogRE9NUmVjdCwgcGFyZW50Q29udGFpbmVyPzogRE9NUmVjdCkge1xuICAgIGNvbnN0IHsgY29uc3RyYWludCB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHsgdmVydGljYWwsIGhvcml6b250YWwgfSA9IGNvbnN0cmFpbnQgPz8ge307XG5cbiAgICBpZiAoIWVsZW1lbnRDb250YWluZXIpIHtcbiAgICAgIGVsZW1lbnRDb250YWluZXIgPSB0aGlzLmRpdiAmJiB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRDb250YWluZXIpIHtcbiAgICAgIHBhcmVudENvbnRhaW5lciA9IHRoaXMuZGl2ICYmIHRoaXMuZGl2LnBhcmVudEVsZW1lbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbGF0aXZlVG9wID1cbiAgICAgIGVsZW1lbnRDb250YWluZXIgJiYgcGFyZW50Q29udGFpbmVyID8gTWF0aC5yb3VuZChlbGVtZW50Q29udGFpbmVyLnRvcCAtIHBhcmVudENvbnRhaW5lci50b3ApIDogMDtcbiAgICBjb25zdCByZWxhdGl2ZUJvdHRvbSA9XG4gICAgICBlbGVtZW50Q29udGFpbmVyICYmIHBhcmVudENvbnRhaW5lciA/IE1hdGgucm91bmQocGFyZW50Q29udGFpbmVyLmJvdHRvbSAtIGVsZW1lbnRDb250YWluZXIuYm90dG9tKSA6IDA7XG4gICAgY29uc3QgcmVsYXRpdmVMZWZ0ID1cbiAgICAgIGVsZW1lbnRDb250YWluZXIgJiYgcGFyZW50Q29udGFpbmVyID8gTWF0aC5yb3VuZChlbGVtZW50Q29udGFpbmVyLmxlZnQgLSBwYXJlbnRDb250YWluZXIubGVmdCkgOiAwO1xuICAgIGNvbnN0IHJlbGF0aXZlUmlnaHQgPVxuICAgICAgZWxlbWVudENvbnRhaW5lciAmJiBwYXJlbnRDb250YWluZXIgPyBNYXRoLnJvdW5kKHBhcmVudENvbnRhaW5lci5yaWdodCAtIGVsZW1lbnRDb250YWluZXIucmlnaHQpIDogMDtcblxuICAgIGNvbnN0IHBsYWNlbWVudCA9IHt9IGFzIFBsYWNlbWVudDtcblxuICAgIGNvbnN0IHdpZHRoID0gZWxlbWVudENvbnRhaW5lcj8ud2lkdGggPz8gMTAwO1xuICAgIGNvbnN0IGhlaWdodCA9IGVsZW1lbnRDb250YWluZXI/LmhlaWdodCA/PyAxMDA7XG5cbiAgICBzd2l0Y2ggKHZlcnRpY2FsKSB7XG4gICAgICBjYXNlIFZlcnRpY2FsQ29uc3RyYWludC5Ub3A6XG4gICAgICAgIHBsYWNlbWVudC50b3AgPSByZWxhdGl2ZVRvcDtcbiAgICAgICAgcGxhY2VtZW50LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFZlcnRpY2FsQ29uc3RyYWludC5Cb3R0b206XG4gICAgICAgIHBsYWNlbWVudC5ib3R0b20gPSByZWxhdGl2ZUJvdHRvbTtcbiAgICAgICAgcGxhY2VtZW50LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFZlcnRpY2FsQ29uc3RyYWludC5Ub3BCb3R0b206XG4gICAgICAgIHBsYWNlbWVudC50b3AgPSByZWxhdGl2ZVRvcDtcbiAgICAgICAgcGxhY2VtZW50LmJvdHRvbSA9IHJlbGF0aXZlQm90dG9tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVmVydGljYWxDb25zdHJhaW50LkNlbnRlcjpcbiAgICAgICAgY29uc3QgZWxlbWVudENlbnRlciA9IGVsZW1lbnRDb250YWluZXIgPyByZWxhdGl2ZVRvcCArIGhlaWdodCAvIDIgOiAwO1xuICAgICAgICBjb25zdCBwYXJlbnRDZW50ZXIgPSBwYXJlbnRDb250YWluZXIgPyBwYXJlbnRDb250YWluZXIuaGVpZ2h0IC8gMiA6IDA7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbUNlbnRlciA9IHBhcmVudENlbnRlciAtIGVsZW1lbnRDZW50ZXI7XG4gICAgICAgIHBsYWNlbWVudC50b3AgPSBkaXN0YW5jZUZyb21DZW50ZXI7XG4gICAgICAgIHBsYWNlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuU2NhbGU6XG4gICAgICAgIHBsYWNlbWVudC50b3AgPSAocmVsYXRpdmVUb3AgLyAocGFyZW50Q29udGFpbmVyPy5oZWlnaHQgPz8gaGVpZ2h0KSkgKiAxMDA7XG4gICAgICAgIHBsYWNlbWVudC5ib3R0b20gPSAocmVsYXRpdmVCb3R0b20gLyAocGFyZW50Q29udGFpbmVyPy5oZWlnaHQgPz8gaGVpZ2h0KSkgKiAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHN3aXRjaCAoaG9yaXpvbnRhbCkge1xuICAgICAgY2FzZSBIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0OlxuICAgICAgICBwbGFjZW1lbnQubGVmdCA9IHJlbGF0aXZlTGVmdDtcbiAgICAgICAgcGxhY2VtZW50LndpZHRoID0gd2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3Jpem9udGFsQ29uc3RyYWludC5SaWdodDpcbiAgICAgICAgcGxhY2VtZW50LnJpZ2h0ID0gcmVsYXRpdmVSaWdodDtcbiAgICAgICAgcGxhY2VtZW50LndpZHRoID0gd2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0UmlnaHQ6XG4gICAgICAgIHBsYWNlbWVudC5sZWZ0ID0gcmVsYXRpdmVMZWZ0O1xuICAgICAgICBwbGFjZW1lbnQucmlnaHQgPSByZWxhdGl2ZVJpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9yaXpvbnRhbENvbnN0cmFpbnQuQ2VudGVyOlxuICAgICAgICBjb25zdCBlbGVtZW50Q2VudGVyID0gZWxlbWVudENvbnRhaW5lciA/IHJlbGF0aXZlTGVmdCArIHdpZHRoIC8gMiA6IDA7XG4gICAgICAgIGNvbnN0IHBhcmVudENlbnRlciA9IHBhcmVudENvbnRhaW5lciA/IHBhcmVudENvbnRhaW5lci53aWR0aCAvIDIgOiAwO1xuICAgICAgICBjb25zdCBkaXN0YW5jZUZyb21DZW50ZXIgPSBwYXJlbnRDZW50ZXIgLSBlbGVtZW50Q2VudGVyO1xuICAgICAgICBwbGFjZW1lbnQubGVmdCA9IGRpc3RhbmNlRnJvbUNlbnRlcjtcbiAgICAgICAgcGxhY2VtZW50LndpZHRoID0gd2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3Jpem9udGFsQ29uc3RyYWludC5TY2FsZTpcbiAgICAgICAgcGxhY2VtZW50LmxlZnQgPSAocmVsYXRpdmVMZWZ0IC8gKHBhcmVudENvbnRhaW5lcj8ud2lkdGggPz8gd2lkdGgpKSAqIDEwMDtcbiAgICAgICAgcGxhY2VtZW50LnJpZ2h0ID0gKHJlbGF0aXZlUmlnaHQgLyAocGFyZW50Q29udGFpbmVyPy53aWR0aCA/PyB3aWR0aCkpICogMTAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID0gcGxhY2VtZW50O1xuXG4gICAgdGhpcy5hcHBseUxheW91dFN0eWxlc1RvRGl2KCk7XG4gICAgdGhpcy5yZXZJZCsrO1xuICB9XG5cbiAgdXBkYXRlRGF0YShjdHg6IERpbWVuc2lvbkNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5pdGVtLnByZXBhcmVEYXRhKSB7XG4gICAgICB0aGlzLmRhdGEgPSB0aGlzLml0ZW0ucHJlcGFyZURhdGEoY3R4LCB0aGlzLm9wdGlvbnMuY29uZmlnKTtcbiAgICAgIHRoaXMucmV2SWQrKzsgLy8gcmVyZW5kZXJcbiAgICB9XG5cbiAgICBjb25zdCB7IGJhY2tncm91bmQsIGJvcmRlciB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGNzczogQ1NTUHJvcGVydGllcyA9IHt9O1xuICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICBpZiAoYmFja2dyb3VuZC5jb2xvcikge1xuICAgICAgICBjb25zdCBjb2xvciA9IGN0eC5nZXRDb2xvcihiYWNrZ3JvdW5kLmNvbG9yKTtcbiAgICAgICAgY3NzLmJhY2tncm91bmRDb2xvciA9IGNvbG9yLnZhbHVlKCk7XG4gICAgICB9XG4gICAgICBpZiAoYmFja2dyb3VuZC5pbWFnZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGN0eC5nZXRSZXNvdXJjZShiYWNrZ3JvdW5kLmltYWdlKTtcbiAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgY29uc3QgdiA9IGltYWdlLnZhbHVlKCk7XG4gICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIGNzcy5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKFwiJHt2fVwiKWA7XG4gICAgICAgICAgICBzd2l0Y2ggKGJhY2tncm91bmQuc2l6ZSA/PyBCYWNrZ3JvdW5kSW1hZ2VTaXplLkNvbnRhaW4pIHtcbiAgICAgICAgICAgICAgY2FzZSBCYWNrZ3JvdW5kSW1hZ2VTaXplLkNvbnRhaW46XG4gICAgICAgICAgICAgICAgY3NzLmJhY2tncm91bmRTaXplID0gJ2NvbnRhaW4nO1xuICAgICAgICAgICAgICAgIGNzcy5iYWNrZ3JvdW5kUmVwZWF0ID0gJ25vLXJlcGVhdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmFja2dyb3VuZEltYWdlU2l6ZS5Db3ZlcjpcbiAgICAgICAgICAgICAgICBjc3MuYmFja2dyb3VuZFNpemUgPSAnY292ZXInO1xuICAgICAgICAgICAgICAgIGNzcy5iYWNrZ3JvdW5kUmVwZWF0ID0gJ25vLXJlcGVhdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmFja2dyb3VuZEltYWdlU2l6ZS5PcmlnaW5hbDpcbiAgICAgICAgICAgICAgICBjc3MuYmFja2dyb3VuZFJlcGVhdCA9ICduby1yZXBlYXQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJhY2tncm91bmRJbWFnZVNpemUuVGlsZTpcbiAgICAgICAgICAgICAgICBjc3MuYmFja2dyb3VuZFJlcGVhdCA9ICdyZXBlYXQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJhY2tncm91bmRJbWFnZVNpemUuRmlsbDpcbiAgICAgICAgICAgICAgICBjc3MuYmFja2dyb3VuZFNpemUgPSAnMTAwJSAxMDAlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm9yZGVyICYmIGJvcmRlci5jb2xvciAmJiBib3JkZXIud2lkdGgpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gY3R4LmdldENvbG9yKGJvcmRlci5jb2xvcik7XG4gICAgICBjc3MuYm9yZGVyV2lkdGggPSBib3JkZXIud2lkdGg7XG4gICAgICBjc3MuYm9yZGVyU3R5bGUgPSAnc29saWQnO1xuICAgICAgY3NzLmJvcmRlckNvbG9yID0gY29sb3IudmFsdWUoKTtcblxuICAgICAgLy8gTW92ZSB0aGUgaW1hZ2UgdG8gaW5zaWRlIHRoZSBib3JkZXJcbiAgICAgIGlmIChjc3MuYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICAgIGNzcy5iYWNrZ3JvdW5kT3JpZ2luID0gJ3BhZGRpbmctYm94JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRhdGFTdHlsZSA9IGNzcztcbiAgICB0aGlzLmFwcGx5TGF5b3V0U3R5bGVzVG9EaXYoKTtcbiAgfVxuXG4gIGlzUm9vdCgpOiB0aGlzIGlzIFJvb3RFbGVtZW50IHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogUmVjdXJzaXZlbHkgdmlzaXQgYWxsIG5vZGVzICovXG4gIHZpc2l0KHZpc2l0b3I6ICh2OiBFbGVtZW50U3RhdGUpID0+IHZvaWQpIHtcbiAgICB2aXNpdG9yKHRoaXMpO1xuICB9XG5cbiAgb25DaGFuZ2Uob3B0aW9uczogQ2FudmFzRWxlbWVudE9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5pdGVtLmlkICE9PSBvcHRpb25zLnR5cGUpIHtcbiAgICAgIHRoaXMuaXRlbSA9IGNhbnZhc0VsZW1lbnRSZWdpc3RyeS5nZXRJZkV4aXN0cyhvcHRpb25zLnR5cGUpID8/IG5vdEZvdW5kSXRlbTtcbiAgICB9XG5cbiAgICAvLyByZW5hbWUgaGFuZGxpbmdcbiAgICBjb25zdCBvbGROYW1lID0gdGhpcy5vcHRpb25zLm5hbWU7XG4gICAgY29uc3QgbmV3TmFtZSA9IG9wdGlvbnMubmFtZTtcblxuICAgIHRoaXMucmV2SWQrKztcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICBsZXQgdHJhdiA9IHRoaXMucGFyZW50O1xuICAgIHdoaWxlICh0cmF2KSB7XG4gICAgICBpZiAodHJhdi5pc1Jvb3QoKSkge1xuICAgICAgICB0cmF2LnNjZW5lLnNhdmUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cmF2LnJldklkKys7XG4gICAgICB0cmF2ID0gdHJhdi5wYXJlbnQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLmdldFNjZW5lKCk7XG4gICAgaWYgKG9sZE5hbWUgIT09IG5ld05hbWUgJiYgc2NlbmUpIHtcbiAgICAgIHNjZW5lLmJ5TmFtZS5kZWxldGUob2xkTmFtZSk7XG4gICAgICBzY2VuZS5ieU5hbWUuc2V0KG5ld05hbWUsIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGdldFNhdmVNb2RlbCgpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLm9wdGlvbnMgfTtcbiAgfVxuXG4gIGluaXRFbGVtZW50ID0gKHRhcmdldDogSFRNTERpdkVsZW1lbnQpID0+IHtcbiAgICB0aGlzLmRpdiA9IHRhcmdldDtcbiAgICB0aGlzLmFwcGx5TGF5b3V0U3R5bGVzVG9EaXYoKTtcbiAgfTtcblxuICBhcHBseURyYWcgPSAoZXZlbnQ6IE9uRHJhZykgPT4ge1xuICAgIGNvbnN0IGhhc0hvcml6b250YWxDZW50ZXJDb25zdHJhaW50ID0gdGhpcy5vcHRpb25zLmNvbnN0cmFpbnQ/Lmhvcml6b250YWwgPT09IEhvcml6b250YWxDb25zdHJhaW50LkNlbnRlcjtcbiAgICBjb25zdCBoYXNWZXJ0aWNhbENlbnRlckNvbnN0cmFpbnQgPSB0aGlzLm9wdGlvbnMuY29uc3RyYWludD8udmVydGljYWwgPT09IFZlcnRpY2FsQ29uc3RyYWludC5DZW50ZXI7XG4gICAgaWYgKGhhc0hvcml6b250YWxDZW50ZXJDb25zdHJhaW50IHx8IGhhc1ZlcnRpY2FsQ2VudGVyQ29uc3RyYWludCkge1xuICAgICAgY29uc3QgbnVtYmVyT2ZUYXJnZXRzID0gdGhpcy5nZXRTY2VuZSgpPy5zZWxlY3RvPy5nZXRTZWxlY3RlZFRhcmdldHMoKS5sZW5ndGggPz8gMDtcbiAgICAgIGNvbnN0IGlzTXVsdGlTZWxlY3Rpb24gPSBudW1iZXJPZlRhcmdldHMgPiAxO1xuICAgICAgaWYgKCFpc011bHRpU2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRDb250YWluZXIgPSB0aGlzLmRpdj8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGVsZW1lbnRDb250YWluZXI/LmhlaWdodCA/PyAxMDA7XG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSBoYXNWZXJ0aWNhbENlbnRlckNvbnN0cmFpbnQgPyBoZWlnaHQgLyA0IDogMDtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtldmVudC50cmFuc2xhdGVbMF19cHgsICR7ZXZlbnQudHJhbnNsYXRlWzFdIC0geU9mZnNldH1weClgO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXZlbnQudGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IGV2ZW50LnRyYW5zZm9ybTtcbiAgfTtcblxuICAvLyBraW5kYSBsaWtlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ3JhZmFuYS9ncmFmYW5hLWVkZ2UtYXBwL2Jsb2IvbWFpbi9zcmMvcGFuZWxzL2RyYXcvV3JhcEl0ZW0udHN4I0w0NFxuICBhcHBseVJlc2l6ZSA9IChldmVudDogT25SZXNpemUpID0+IHtcbiAgICBjb25zdCBwbGFjZW1lbnQgPSB0aGlzLm9wdGlvbnMucGxhY2VtZW50ITtcblxuICAgIGNvbnN0IHN0eWxlID0gZXZlbnQudGFyZ2V0LnN0eWxlO1xuICAgIGNvbnN0IGRlbHRhWCA9IGV2ZW50LmRlbHRhWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IGV2ZW50LmRlbHRhWzFdO1xuICAgIGNvbnN0IGRpckxSID0gZXZlbnQuZGlyZWN0aW9uWzBdO1xuICAgIGNvbnN0IGRpclRCID0gZXZlbnQuZGlyZWN0aW9uWzFdO1xuXG4gICAgaWYgKGRpckxSID09PSAxKSB7XG4gICAgICBwbGFjZW1lbnQud2lkdGggPSBldmVudC53aWR0aDtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7cGxhY2VtZW50LndpZHRofXB4YDtcbiAgICB9IGVsc2UgaWYgKGRpckxSID09PSAtMSkge1xuICAgICAgcGxhY2VtZW50LmxlZnQhIC09IGRlbHRhWDtcbiAgICAgIHBsYWNlbWVudC53aWR0aCA9IGV2ZW50LndpZHRoO1xuICAgICAgc3R5bGUubGVmdCA9IGAke3BsYWNlbWVudC5sZWZ0fXB4YDtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7cGxhY2VtZW50LndpZHRofXB4YDtcbiAgICB9XG5cbiAgICBpZiAoZGlyVEIgPT09IC0xKSB7XG4gICAgICBwbGFjZW1lbnQudG9wISAtPSBkZWx0YVk7XG4gICAgICBwbGFjZW1lbnQuaGVpZ2h0ID0gZXZlbnQuaGVpZ2h0O1xuICAgICAgc3R5bGUudG9wID0gYCR7cGxhY2VtZW50LnRvcH1weGA7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHtwbGFjZW1lbnQuaGVpZ2h0fXB4YDtcbiAgICB9IGVsc2UgaWYgKGRpclRCID09PSAxKSB7XG4gICAgICBwbGFjZW1lbnQuaGVpZ2h0ID0gZXZlbnQuaGVpZ2h0O1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7cGxhY2VtZW50LmhlaWdodH1weGA7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGl0ZW0gfSA9IHRoaXM7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYga2V5PXt0aGlzLlVJRH0gcmVmPXt0aGlzLmluaXRFbGVtZW50fT5cbiAgICAgICAgPGl0ZW0uZGlzcGxheSBrZXk9e2Ake3RoaXMuVUlEfS8ke3RoaXMucmV2SWR9YH0gY29uZmlnPXt0aGlzLm9wdGlvbnMuY29uZmlnfSBkYXRhPXt0aGlzLmRhdGF9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgY2FudmFzRWxlbWVudFJlZ2lzdHJ5LCBDYW52YXNGcmFtZU9wdGlvbnMgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzJztcbmltcG9ydCB7IG5vdEZvdW5kSXRlbSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvZWxlbWVudHMvbm90Rm91bmQnO1xuaW1wb3J0IHsgRGltZW5zaW9uQ29udGV4dCB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zJztcbmltcG9ydCB7IExheWVyQWN0aW9uSUQgfSBmcm9tICdhcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvdHlwZXMnO1xuXG5pbXBvcnQgeyBDYW52YXNFbGVtZW50SXRlbSB9IGZyb20gJy4uL2VsZW1lbnQnO1xuaW1wb3J0IHsgSG9yaXpvbnRhbENvbnN0cmFpbnQsIFBsYWNlbWVudCwgVmVydGljYWxDb25zdHJhaW50IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBFbGVtZW50U3RhdGUgfSBmcm9tICcuL2VsZW1lbnQnO1xuaW1wb3J0IHsgUm9vdEVsZW1lbnQgfSBmcm9tICcuL3Jvb3QnO1xuaW1wb3J0IHsgU2NlbmUgfSBmcm9tICcuL3NjZW5lJztcblxuZXhwb3J0IGNvbnN0IGZyYW1lSXRlbUR1bW15OiBDYW52YXNFbGVtZW50SXRlbSA9IHtcbiAgaWQ6ICdmcmFtZScsXG4gIG5hbWU6ICdGcmFtZScsXG4gIGRlc2NyaXB0aW9uOiAnRnJhbWUnLFxuXG4gIGdldE5ld09wdGlvbnM6ICgpID0+ICh7XG4gICAgY29uZmlnOiB7fSxcbiAgfSksXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICBkaXNwbGF5OiAoKSA9PiB7XG4gICAgcmV0dXJuIDxkaXY+RlJBTUUhPC9kaXY+O1xuICB9LFxufTtcblxuZXhwb3J0IGNsYXNzIEZyYW1lU3RhdGUgZXh0ZW5kcyBFbGVtZW50U3RhdGUge1xuICBlbGVtZW50czogRWxlbWVudFN0YXRlW10gPSBbXTtcbiAgc2NlbmU6IFNjZW5lO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBvcHRpb25zOiBDYW52YXNGcmFtZU9wdGlvbnMsIHNjZW5lOiBTY2VuZSwgcHVibGljIHBhcmVudD86IEZyYW1lU3RhdGUpIHtcbiAgICBzdXBlcihmcmFtZUl0ZW1EdW1teSwgb3B0aW9ucywgcGFyZW50KTtcblxuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcblxuICAgIC8vIG11dGF0ZSBvcHRpb25zIG9iamVjdFxuICAgIGxldCB7IGVsZW1lbnRzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgdGhpcy5vcHRpb25zLmVsZW1lbnRzID0gZWxlbWVudHMgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgZWxlbWVudHMpIHtcbiAgICAgIGlmIChjLnR5cGUgPT09ICdmcmFtZScpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKG5ldyBGcmFtZVN0YXRlKGMgYXMgQ2FudmFzRnJhbWVPcHRpb25zLCBzY2VuZSwgdGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGNhbnZhc0VsZW1lbnRSZWdpc3RyeS5nZXRJZkV4aXN0cyhjLnR5cGUpID8/IG5vdEZvdW5kSXRlbTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKG5ldyBFbGVtZW50U3RhdGUoaXRlbSwgYywgdGhpcykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzUm9vdCgpOiB0aGlzIGlzIFJvb3RFbGVtZW50IHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB1cGRhdGVEYXRhKGN0eDogRGltZW5zaW9uQ29udGV4dCkge1xuICAgIHN1cGVyLnVwZGF0ZURhdGEoY3R4KTtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgZWxlbS51cGRhdGVEYXRhKGN0eCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdXNlZCBpbiB0aGUgbGF5ZXIgZWRpdG9yXG4gIHJlb3JkZXIoc3RhcnRJbmRleDogbnVtYmVyLCBlbmRJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gQXJyYXkuZnJvbSh0aGlzLmVsZW1lbnRzKTtcbiAgICBjb25zdCBbcmVtb3ZlZF0gPSByZXN1bHQuc3BsaWNlKHN0YXJ0SW5kZXgsIDEpO1xuICAgIHJlc3VsdC5zcGxpY2UoZW5kSW5kZXgsIDAsIHJlbW92ZWQpO1xuICAgIHRoaXMuZWxlbWVudHMgPSByZXN1bHQ7XG5cbiAgICB0aGlzLnJlaW5pdGlhbGl6ZU1vdmVhYmxlKCk7XG4gIH1cblxuICBkb01vdmUoY2hpbGQ6IEVsZW1lbnRTdGF0ZSwgYWN0aW9uOiBMYXllckFjdGlvbklEKSB7XG4gICAgY29uc3QgdmFscyA9IHRoaXMuZWxlbWVudHMuZmlsdGVyKCh2KSA9PiB2ICE9PSBjaGlsZCk7XG4gICAgaWYgKGFjdGlvbiA9PT0gTGF5ZXJBY3Rpb25JRC5Nb3ZlQm90dG9tKSB7XG4gICAgICB2YWxzLnVuc2hpZnQoY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxzLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRzID0gdmFscztcbiAgICB0aGlzLnNjZW5lLnNhdmUoKTtcbiAgICB0aGlzLnJlaW5pdGlhbGl6ZU1vdmVhYmxlKCk7XG4gIH1cblxuICByZWluaXRpYWxpemVNb3ZlYWJsZSgpIHtcbiAgICAvLyBOZWVkIHRvIGZpcnN0IGNsZWFyIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCB0aGVuIHJlLWluaXQgbW92ZWFibGUgd2l0aCBzbGlnaHQgZGVsYXlcbiAgICB0aGlzLnNjZW5lLmNsZWFyQ3VycmVudFNlbGVjdGlvbigpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zY2VuZS5pbml0TW92ZWFibGUodHJ1ZSwgdGhpcy5zY2VuZS5pc0VkaXRpbmdFbmFibGVkKSk7XG4gIH1cblxuICAvLyA/Pz8gb3Igc2hvdWxkIHRoaXMgYmUgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHk/XG4gIC8vIGFyZSBhY3Rpb25zIHNjb3BlZCB0byBsYXllcnM/XG4gIGRvQWN0aW9uID0gKGFjdGlvbjogTGF5ZXJBY3Rpb25JRCwgZWxlbWVudDogRWxlbWVudFN0YXRlLCB1cGRhdGVOYW1lID0gdHJ1ZSwgc2hpZnRJdGVtc09uRHVwbGljYXRlID0gdHJ1ZSkgPT4ge1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIExheWVyQWN0aW9uSUQuRGVsZXRlOlxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5maWx0ZXIoKGUpID0+IGUgIT09IGVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNjZW5lLmJ5TmFtZS5kZWxldGUoZWxlbWVudC5vcHRpb25zLm5hbWUpO1xuICAgICAgICB0aGlzLnNjZW5lLnNhdmUoKTtcbiAgICAgICAgdGhpcy5yZWluaXRpYWxpemVNb3ZlYWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGF5ZXJBY3Rpb25JRC5EdXBsaWNhdGU6XG4gICAgICAgIGlmIChlbGVtZW50Lml0ZW0uaWQgPT09ICdmcmFtZScpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2FuIG5vdCBkdXBsaWNhdGUgZnJhbWVzICh5ZXQpJywgYWN0aW9uLCBlbGVtZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9IGNsb25lRGVlcChlbGVtZW50Lm9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChzaGlmdEl0ZW1zT25EdXBsaWNhdGUpIHtcbiAgICAgICAgICBjb25zdCB7IGNvbnN0cmFpbnQsIHBsYWNlbWVudDogb2xkUGxhY2VtZW50IH0gPSBlbGVtZW50Lm9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgeyB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCB9ID0gY29uc3RyYWludCA/PyB7fTtcbiAgICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSBvbGRQbGFjZW1lbnQgPz8gKHt9IGFzIFBsYWNlbWVudCk7XG5cbiAgICAgICAgICBzd2l0Y2ggKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICBjYXNlIFZlcnRpY2FsQ29uc3RyYWludC5Ub3A6XG4gICAgICAgICAgICBjYXNlIFZlcnRpY2FsQ29uc3RyYWludC5Ub3BCb3R0b206XG4gICAgICAgICAgICAgIGlmIChwbGFjZW1lbnQudG9wID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQudG9wID0gMjU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50LnRvcCArPSAxMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVmVydGljYWxDb25zdHJhaW50LkJvdHRvbTpcbiAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudC5ib3R0b20gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudC5ib3R0b20gPSAxMDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50LmJvdHRvbSAtPSAxMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGNhc2UgSG9yaXpvbnRhbENvbnN0cmFpbnQuTGVmdDpcbiAgICAgICAgICAgIGNhc2UgSG9yaXpvbnRhbENvbnN0cmFpbnQuTGVmdFJpZ2h0OlxuICAgICAgICAgICAgICBpZiAocGxhY2VtZW50LmxlZnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudC5sZWZ0ID0gNTA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50LmxlZnQgKz0gMTA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxDb25zdHJhaW50LlJpZ2h0OlxuICAgICAgICAgICAgICBpZiAocGxhY2VtZW50LnJpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQucmlnaHQgPSA1MDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQucmlnaHQgLT0gMTA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3B0cy5wbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IEVsZW1lbnRTdGF0ZShlbGVtZW50Lml0ZW0sIG9wdHMsIHRoaXMpO1xuICAgICAgICBjb3B5LnVwZGF0ZURhdGEodGhpcy5zY2VuZS5jb250ZXh0KTtcbiAgICAgICAgaWYgKHVwZGF0ZU5hbWUpIHtcbiAgICAgICAgICBjb3B5Lm9wdGlvbnMubmFtZSA9IHRoaXMuc2NlbmUuZ2V0TmV4dEVsZW1lbnROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKGNvcHkpO1xuICAgICAgICB0aGlzLnNjZW5lLmJ5TmFtZS5zZXQoY29weS5vcHRpb25zLm5hbWUsIGNvcHkpO1xuICAgICAgICB0aGlzLnNjZW5lLnNhdmUoKTtcbiAgICAgICAgdGhpcy5yZWluaXRpYWxpemVNb3ZlYWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGF5ZXJBY3Rpb25JRC5Nb3ZlVG9wOlxuICAgICAgY2FzZSBMYXllckFjdGlvbklELk1vdmVCb3R0b206XG4gICAgICAgIGVsZW1lbnQucGFyZW50Py5kb01vdmUoZWxlbWVudCwgYWN0aW9uKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUubG9nKCdETyBhY3Rpb24nLCBhY3Rpb24sIGVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBrZXk9e3RoaXMuVUlEfSByZWY9e3RoaXMuaW5pdEVsZW1lbnR9IHN0eWxlPXt7IG92ZXJmbG93OiAnaGlkZGVuJyB9fT5cbiAgICAgICAge3RoaXMuZWxlbWVudHMubWFwKCh2KSA9PiB2LnJlbmRlcigpKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICAvKiogUmVjdXJzaXZlbHkgdmlzaXQgYWxsIG5vZGVzICovXG4gIHZpc2l0KHZpc2l0b3I6ICh2OiBFbGVtZW50U3RhdGUpID0+IHZvaWQpIHtcbiAgICBzdXBlci52aXNpdCh2aXNpdG9yKTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgdmlzaXRvcihlKTtcbiAgICB9XG4gIH1cblxuICBnZXRTYXZlTW9kZWwoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIGVsZW1lbnRzOiB0aGlzLmVsZW1lbnRzLm1hcCgodikgPT4gdi5nZXRTYXZlTW9kZWwoKSksXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgQ2FudmFzRWxlbWVudE9wdGlvbnMsIENhbnZhc0ZyYW1lT3B0aW9ucyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMnO1xuXG5pbXBvcnQgeyBGcmFtZVN0YXRlIH0gZnJvbSAnLi9mcmFtZSc7XG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gJy4vc2NlbmUnO1xuXG5leHBvcnQgY2xhc3MgUm9vdEVsZW1lbnQgZXh0ZW5kcyBGcmFtZVN0YXRlIHtcbiAgY29uc3RydWN0b3IocHVibGljIG9wdGlvbnM6IENhbnZhc0ZyYW1lT3B0aW9ucywgcHVibGljIHNjZW5lOiBTY2VuZSwgcHJpdmF0ZSBjaGFuZ2VDYWxsYmFjazogKCkgPT4gdm9pZCkge1xuICAgIHN1cGVyKG9wdGlvbnMsIHNjZW5lKTtcblxuICAgIHRoaXMuc2l6ZVN0eWxlID0ge1xuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH07XG4gIH1cblxuICBpc1Jvb3QoKTogdGhpcyBpcyBSb290RWxlbWVudCB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyByb290IHR5cGUgY2FuIG5vdCBjaGFuZ2VcbiAgb25DaGFuZ2Uob3B0aW9uczogQ2FudmFzRWxlbWVudE9wdGlvbnMpIHtcbiAgICB0aGlzLnJldklkKys7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5vcHRpb25zIH0gYXMgQ2FudmFzRnJhbWVPcHRpb25zO1xuICAgIHRoaXMuY2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuXG4gIGdldFNhdmVNb2RlbCgpOiBDYW52YXNGcmFtZU9wdGlvbnMge1xuICAgIGNvbnN0IHsgcGxhY2VtZW50LCBjb25zdHJhaW50LCAuLi5yZXN0IH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdCwgLy8gZXZlcnl0aGluZyBleGNlcHQgcGxhY2VtZW50ICYgY29uc3RyYWludFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMubWFwKCh2KSA9PiB2LmdldFNhdmVNb2RlbCgpKSxcbiAgICB9O1xuICB9XG5cbiAgc2V0Um9vdFJlZiA9ICh0YXJnZXQ6IEhUTUxEaXZFbGVtZW50KSA9PiB7XG4gICAgdGhpcy5kaXYgPSB0YXJnZXQ7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIG9uQ29udGV4dE1lbnU9eyhldmVudCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKX1cbiAgICAgICAga2V5PXt0aGlzLlVJRH1cbiAgICAgICAgcmVmPXt0aGlzLnNldFJvb3RSZWZ9XG4gICAgICAgIHN0eWxlPXt7IC4uLnRoaXMuc2l6ZVN0eWxlLCAuLi50aGlzLmRhdGFTdHlsZSB9fVxuICAgICAgPlxuICAgICAgICB7dGhpcy5lbGVtZW50cy5tYXAoKHYpID0+IHYucmVuZGVyKCkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBNb3ZlYWJsZSBmcm9tICdtb3ZlYWJsZSc7XG5pbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlcGxheVN1YmplY3QsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IFNlbGVjdG8gZnJvbSAnc2VsZWN0byc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIsIFBhbmVsRGF0YSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgbG9jYXRpb25TZXJ2aWNlIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZS9zcmMnO1xuaW1wb3J0IHsgUG9ydGFsLCBzdHlsZXNGYWN0b3J5IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnYXBwL2NvcmUvY29uZmlnJztcbmltcG9ydCB7IENhbnZhc0ZyYW1lT3B0aW9ucywgREVGQVVMVF9DQU5WQVNfRUxFTUVOVF9DT05GSUcgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzJztcbmltcG9ydCB7XG4gIENvbG9yRGltZW5zaW9uQ29uZmlnLFxuICBEaW1lbnNpb25Db250ZXh0LFxuICBSZXNvdXJjZURpbWVuc2lvbkNvbmZpZyxcbiAgU2NhbGFyRGltZW5zaW9uQ29uZmlnLFxuICBTY2FsZURpbWVuc2lvbkNvbmZpZyxcbiAgVGV4dERpbWVuc2lvbkNvbmZpZyxcbn0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMnO1xuaW1wb3J0IHtcbiAgZ2V0Q29sb3JEaW1lbnNpb25Gcm9tRGF0YSxcbiAgZ2V0UmVzb3VyY2VEaW1lbnNpb25Gcm9tRGF0YSxcbiAgZ2V0U2NhbGFyRGltZW5zaW9uRnJvbURhdGEsXG4gIGdldFNjYWxlRGltZW5zaW9uRnJvbURhdGEsXG4gIGdldFRleHREaW1lbnNpb25Gcm9tRGF0YSxcbn0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvdXRpbHMnO1xuaW1wb3J0IHsgQ2FudmFzQ29udGV4dE1lbnUgfSBmcm9tICdhcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvQ2FudmFzQ29udGV4dE1lbnUnO1xuaW1wb3J0IHsgTGF5ZXJBY3Rpb25JRCB9IGZyb20gJ2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy90eXBlcyc7XG5cbmltcG9ydCB7IEhvcml6b250YWxDb25zdHJhaW50LCBQbGFjZW1lbnQsIFZlcnRpY2FsQ29uc3RyYWludCB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY29uc3RyYWludFZpZXdhYmxlLCBkaW1lbnNpb25WaWV3YWJsZSB9IGZyb20gJy4vYWJsZXMnO1xuaW1wb3J0IHsgRWxlbWVudFN0YXRlIH0gZnJvbSAnLi9lbGVtZW50JztcbmltcG9ydCB7IEZyYW1lU3RhdGUgfSBmcm9tICcuL2ZyYW1lJztcbmltcG9ydCB7IFJvb3RFbGVtZW50IH0gZnJvbSAnLi9yb290JztcblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3Rpb25QYXJhbXMge1xuICB0YXJnZXRzOiBBcnJheTxIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQ+O1xuICBmcmFtZT86IEZyYW1lU3RhdGU7XG59XG5cbmV4cG9ydCBjbGFzcyBTY2VuZSB7XG4gIHN0eWxlcyA9IGdldFN0eWxlcyhjb25maWcudGhlbWUyKTtcbiAgcmVhZG9ubHkgc2VsZWN0aW9uID0gbmV3IFJlcGxheVN1YmplY3Q8RWxlbWVudFN0YXRlW10+KDEpO1xuICByZWFkb25seSBtb3ZlZCA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTsgLy8gY2FsbGVkIGFmdGVyIHJlc2l6ZS9kcmFnIGZvciBlZGl0b3IgdXBkYXRlc1xuICByZWFkb25seSBieU5hbWUgPSBuZXcgTWFwPHN0cmluZywgRWxlbWVudFN0YXRlPigpO1xuXG4gIHJvb3Q6IFJvb3RFbGVtZW50O1xuXG4gIHJldklkID0gMDtcblxuICB3aWR0aCA9IDA7XG4gIGhlaWdodCA9IDA7XG4gIHN0eWxlOiBDU1NQcm9wZXJ0aWVzID0ge307XG4gIGRhdGE/OiBQYW5lbERhdGE7XG4gIHNlbGVjdG8/OiBTZWxlY3RvO1xuICBtb3ZlYWJsZT86IE1vdmVhYmxlO1xuICBkaXY/OiBIVE1MRGl2RWxlbWVudDtcbiAgY3VycmVudExheWVyPzogRnJhbWVTdGF0ZTtcbiAgaXNFZGl0aW5nRW5hYmxlZD86IGJvb2xlYW47XG4gIHNraXBOZXh0U2VsZWN0aW9uQnJvYWRjYXN0ID0gZmFsc2U7XG5cbiAgaXNQYW5lbEVkaXRpbmcgPSBsb2NhdGlvblNlcnZpY2UuZ2V0U2VhcmNoT2JqZWN0KCkuZWRpdFBhbmVsICE9PSB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoY2ZnOiBDYW52YXNGcmFtZU9wdGlvbnMsIGVuYWJsZUVkaXRpbmc6IGJvb2xlYW4sIHB1YmxpYyBvblNhdmU6IChjZmc6IENhbnZhc0ZyYW1lT3B0aW9ucykgPT4gdm9pZCkge1xuICAgIHRoaXMucm9vdCA9IHRoaXMubG9hZChjZmcsIGVuYWJsZUVkaXRpbmcpO1xuICB9XG5cbiAgZ2V0TmV4dEVsZW1lbnROYW1lID0gKGlzRnJhbWUgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGxhYmVsID0gaXNGcmFtZSA/ICdGcmFtZScgOiAnRWxlbWVudCc7XG4gICAgbGV0IGlkeCA9IHRoaXMuYnlOYW1lLnNpemUgKyAxO1xuXG4gICAgY29uc3QgbWF4ID0gaWR4ICsgMTAwO1xuICAgIHdoaWxlICh0cnVlICYmIGlkeCA8IG1heCkge1xuICAgICAgY29uc3QgbmFtZSA9IGAke2xhYmVsfSAke2lkeCsrfWA7XG4gICAgICBpZiAoIXRoaXMuYnlOYW1lLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYCR7bGFiZWx9ICR7RGF0ZS5ub3coKX1gO1xuICB9O1xuXG4gIGNhblJlbmFtZSA9ICh2OiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gIXRoaXMuYnlOYW1lLmhhcyh2KTtcbiAgfTtcblxuICBsb2FkKGNmZzogQ2FudmFzRnJhbWVPcHRpb25zLCBlbmFibGVFZGl0aW5nOiBib29sZWFuKSB7XG4gICAgdGhpcy5yb290ID0gbmV3IFJvb3RFbGVtZW50KFxuICAgICAgY2ZnID8/IHtcbiAgICAgICAgdHlwZTogJ2ZyYW1lJyxcbiAgICAgICAgZWxlbWVudHM6IFtERUZBVUxUX0NBTlZBU19FTEVNRU5UX0NPTkZJR10sXG4gICAgICB9LFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMuc2F2ZSAvLyBjYWxsYmFjayB3aGVuIGNoYW5nZXMgYXJlIG1hZGVcbiAgICApO1xuXG4gICAgdGhpcy5pc0VkaXRpbmdFbmFibGVkID0gZW5hYmxlRWRpdGluZztcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAgIC8vIElmIGVkaXRpbmcgaXMgZW5hYmxlZCwgY2xlYXIgc2VsZWN0byBpbnN0YW5jZVxuICAgICAgICBjb25zdCBkZXN0cm95U2VsZWN0byA9IGVuYWJsZUVkaXRpbmc7XG4gICAgICAgIHRoaXMuaW5pdE1vdmVhYmxlKGRlc3Ryb3lTZWxlY3RvLCBlbmFibGVFZGl0aW5nKTtcbiAgICAgICAgdGhpcy5jdXJyZW50TGF5ZXIgPSB0aGlzLnJvb3Q7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLm5leHQoW10pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gIH1cblxuICBjb250ZXh0OiBEaW1lbnNpb25Db250ZXh0ID0ge1xuICAgIGdldENvbG9yOiAoY29sb3I6IENvbG9yRGltZW5zaW9uQ29uZmlnKSA9PiBnZXRDb2xvckRpbWVuc2lvbkZyb21EYXRhKHRoaXMuZGF0YSwgY29sb3IpLFxuICAgIGdldFNjYWxlOiAoc2NhbGU6IFNjYWxlRGltZW5zaW9uQ29uZmlnKSA9PiBnZXRTY2FsZURpbWVuc2lvbkZyb21EYXRhKHRoaXMuZGF0YSwgc2NhbGUpLFxuICAgIGdldFNjYWxhcjogKHNjYWxhcjogU2NhbGFyRGltZW5zaW9uQ29uZmlnKSA9PiBnZXRTY2FsYXJEaW1lbnNpb25Gcm9tRGF0YSh0aGlzLmRhdGEsIHNjYWxhciksXG4gICAgZ2V0VGV4dDogKHRleHQ6IFRleHREaW1lbnNpb25Db25maWcpID0+IGdldFRleHREaW1lbnNpb25Gcm9tRGF0YSh0aGlzLmRhdGEsIHRleHQpLFxuICAgIGdldFJlc291cmNlOiAocmVzOiBSZXNvdXJjZURpbWVuc2lvbkNvbmZpZykgPT4gZ2V0UmVzb3VyY2VEaW1lbnNpb25Gcm9tRGF0YSh0aGlzLmRhdGEsIHJlcyksXG4gIH07XG5cbiAgdXBkYXRlRGF0YShkYXRhOiBQYW5lbERhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMucm9vdC51cGRhdGVEYXRhKHRoaXMuY29udGV4dCk7XG4gIH1cblxuICB1cGRhdGVTaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuc3R5bGUgPSB7IHdpZHRoLCBoZWlnaHQgfTtcblxuICAgIGlmICh0aGlzLnNlbGVjdG8/LmdldFNlbGVjdGVkVGFyZ2V0cygpLmxlbmd0aCkge1xuICAgICAgdGhpcy5jbGVhckN1cnJlbnRTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICBmcmFtZVNlbGVjdGlvbigpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSgoY3VycmVudFNlbGVjdGVkRWxlbWVudHMpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRMYXllciA9IGN1cnJlbnRTZWxlY3RlZEVsZW1lbnRzWzBdLnBhcmVudCE7XG5cbiAgICAgIGNvbnN0IG5ld0xheWVyID0gbmV3IEZyYW1lU3RhdGUoXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnZnJhbWUnLFxuICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0TmV4dEVsZW1lbnROYW1lKHRydWUpLFxuICAgICAgICAgIGVsZW1lbnRzOiBbXSxcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgY3VycmVudFNlbGVjdGVkRWxlbWVudHNbMF0ucGFyZW50XG4gICAgICApO1xuXG4gICAgICBjb25zdCBmcmFtZVBsYWNlbWVudCA9IHRoaXMuZ2VuZXJhdGVGcmFtZUNvbnRhaW5lcihjdXJyZW50U2VsZWN0ZWRFbGVtZW50cyk7XG5cbiAgICAgIG5ld0xheWVyLm9wdGlvbnMucGxhY2VtZW50ID0gZnJhbWVQbGFjZW1lbnQ7XG5cbiAgICAgIGN1cnJlbnRTZWxlY3RlZEVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQ6IEVsZW1lbnRTdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50Q29udGFpbmVyID0gZWxlbWVudC5kaXY/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBlbGVtZW50LnNldFBsYWNlbWVudEZyb21Db25zdHJhaW50KGVsZW1lbnRDb250YWluZXIsIGZyYW1lUGxhY2VtZW50IGFzIERPTVJlY3QpO1xuICAgICAgICBjdXJyZW50TGF5ZXIuZG9BY3Rpb24oTGF5ZXJBY3Rpb25JRC5EZWxldGUsIGVsZW1lbnQpO1xuICAgICAgICBuZXdMYXllci5kb0FjdGlvbihMYXllckFjdGlvbklELkR1cGxpY2F0ZSwgZWxlbWVudCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH0pO1xuXG4gICAgICBuZXdMYXllci5zZXRQbGFjZW1lbnRGcm9tQ29uc3RyYWludChmcmFtZVBsYWNlbWVudCBhcyBET01SZWN0LCBjdXJyZW50TGF5ZXIuZGl2Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG5cbiAgICAgIGN1cnJlbnRMYXllci5lbGVtZW50cy5wdXNoKG5ld0xheWVyKTtcblxuICAgICAgdGhpcy5ieU5hbWUuc2V0KG5ld0xheWVyLmdldE5hbWUoKSwgbmV3TGF5ZXIpO1xuXG4gICAgICB0aGlzLnNhdmUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVGcmFtZUNvbnRhaW5lciA9IChlbGVtZW50czogRWxlbWVudFN0YXRlW10pOiBQbGFjZW1lbnQgPT4ge1xuICAgIGxldCBtaW5Ub3AgPSBJbmZpbml0eTtcbiAgICBsZXQgbWluTGVmdCA9IEluZmluaXR5O1xuICAgIGxldCBtYXhSaWdodCA9IDA7XG4gICAgbGV0IG1heEJvdHRvbSA9IDA7XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50OiBFbGVtZW50U3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRDb250YWluZXIgPSBlbGVtZW50LmRpdj8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGlmICghZWxlbWVudENvbnRhaW5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW5Ub3AgPiBlbGVtZW50Q29udGFpbmVyLnRvcCkge1xuICAgICAgICBtaW5Ub3AgPSBlbGVtZW50Q29udGFpbmVyLnRvcDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbkxlZnQgPiBlbGVtZW50Q29udGFpbmVyLmxlZnQpIHtcbiAgICAgICAgbWluTGVmdCA9IGVsZW1lbnRDb250YWluZXIubGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heFJpZ2h0IDwgZWxlbWVudENvbnRhaW5lci5yaWdodCkge1xuICAgICAgICBtYXhSaWdodCA9IGVsZW1lbnRDb250YWluZXIucmlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhCb3R0b20gPCBlbGVtZW50Q29udGFpbmVyLmJvdHRvbSkge1xuICAgICAgICBtYXhCb3R0b20gPSBlbGVtZW50Q29udGFpbmVyLmJvdHRvbTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IG1pblRvcCxcbiAgICAgIGxlZnQ6IG1pbkxlZnQsXG4gICAgICB3aWR0aDogbWF4UmlnaHQgLSBtaW5MZWZ0LFxuICAgICAgaGVpZ2h0OiBtYXhCb3R0b20gLSBtaW5Ub3AsXG4gICAgfTtcbiAgfTtcblxuICBjbGVhckN1cnJlbnRTZWxlY3Rpb24oc2tpcE5leHRTZWxlY3Rpb25Ccm9hZGNhc3QgPSBmYWxzZSkge1xuICAgIHRoaXMuc2tpcE5leHRTZWxlY3Rpb25Ccm9hZGNhc3QgPSBza2lwTmV4dFNlbGVjdGlvbkJyb2FkY2FzdDtcbiAgICBsZXQgZXZlbnQ6IE1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCgnY2xpY2snKTtcbiAgICB0aGlzLnNlbGVjdG8/LmNsaWNrVGFyZ2V0KGV2ZW50LCB0aGlzLmRpdik7XG4gIH1cblxuICB1cGRhdGVDdXJyZW50TGF5ZXIobmV3TGF5ZXI6IEZyYW1lU3RhdGUpIHtcbiAgICB0aGlzLmN1cnJlbnRMYXllciA9IG5ld0xheWVyO1xuICAgIHRoaXMuY2xlYXJDdXJyZW50U2VsZWN0aW9uKCk7XG4gICAgdGhpcy5zYXZlKCk7XG4gIH1cblxuICBzYXZlID0gKHVwZGF0ZU1vdmVhYmxlID0gZmFsc2UpID0+IHtcbiAgICB0aGlzLm9uU2F2ZSh0aGlzLnJvb3QuZ2V0U2F2ZU1vZGVsKCkpO1xuXG4gICAgaWYgKHVwZGF0ZU1vdmVhYmxlKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAgICAgdGhpcy5pbml0TW92ZWFibGUodHJ1ZSwgdGhpcy5pc0VkaXRpbmdFbmFibGVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGZpbmRFbGVtZW50QnlUYXJnZXQgPSAodGFyZ2V0OiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQpOiBFbGVtZW50U3RhdGUgfCB1bmRlZmluZWQgPT4ge1xuICAgIC8vIFdlIHdpbGwgcHJvYmFibHkgd2FudCB0byBhZGQgbWVtb2l6YXRpb24gdG8gdGhpcyBhcyB3ZSBhcmUgY2FsbGluZyBvbiBkcmFnIC8gcmVzaXplXG5cbiAgICBjb25zdCBzdGFjayA9IFsuLi50aGlzLnJvb3QuZWxlbWVudHNdO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IHN0YWNrLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChjdXJyZW50RWxlbWVudCAmJiBjdXJyZW50RWxlbWVudC5kaXYgJiYgY3VycmVudEVsZW1lbnQuZGl2ID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXN0ZWRFbGVtZW50cyA9IGN1cnJlbnRFbGVtZW50IGluc3RhbmNlb2YgRnJhbWVTdGF0ZSA/IGN1cnJlbnRFbGVtZW50LmVsZW1lbnRzIDogW107XG4gICAgICBmb3IgKGNvbnN0IG5lc3RlZEVsZW1lbnQgb2YgbmVzdGVkRWxlbWVudHMpIHtcbiAgICAgICAgc3RhY2sudW5zaGlmdChuZXN0ZWRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHNldFJlZiA9IChzY2VuZUNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQpID0+IHtcbiAgICB0aGlzLmRpdiA9IHNjZW5lQ29udGFpbmVyO1xuICB9O1xuXG4gIHNlbGVjdCA9IChzZWxlY3Rpb246IFNlbGVjdGlvblBhcmFtcykgPT4ge1xuICAgIGlmICh0aGlzLnNlbGVjdG8pIHtcbiAgICAgIHRoaXMuc2VsZWN0by5zZXRTZWxlY3RlZFRhcmdldHMoc2VsZWN0aW9uLnRhcmdldHMpO1xuICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSB1cGRhdGVTZWxlY3Rpb24gPSAoc2VsZWN0aW9uOiBTZWxlY3Rpb25QYXJhbXMpID0+IHtcbiAgICB0aGlzLm1vdmVhYmxlIS50YXJnZXQgPSBzZWxlY3Rpb24udGFyZ2V0cztcblxuICAgIGlmICh0aGlzLnNraXBOZXh0U2VsZWN0aW9uQnJvYWRjYXN0KSB7XG4gICAgICB0aGlzLnNraXBOZXh0U2VsZWN0aW9uQnJvYWRjYXN0ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGlvbi5mcmFtZSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24ubmV4dChbc2VsZWN0aW9uLmZyYW1lXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMgPSBzZWxlY3Rpb24udGFyZ2V0cy5tYXAoKHQpID0+IHRoaXMuZmluZEVsZW1lbnRCeVRhcmdldCh0KSEpO1xuICAgICAgdGhpcy5zZWxlY3Rpb24ubmV4dChzKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZVRhcmdldEVsZW1lbnRzID0gKHJvb3RFbGVtZW50czogRWxlbWVudFN0YXRlW10pOiBIVE1MRGl2RWxlbWVudFtdID0+IHtcbiAgICBsZXQgdGFyZ2V0RWxlbWVudHM6IEhUTUxEaXZFbGVtZW50W10gPSBbXTtcblxuICAgIGNvbnN0IHN0YWNrID0gWy4uLnJvb3RFbGVtZW50c107XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gc3RhY2suc2hpZnQoKTtcblxuICAgICAgaWYgKGN1cnJlbnRFbGVtZW50ICYmIGN1cnJlbnRFbGVtZW50LmRpdikge1xuICAgICAgICB0YXJnZXRFbGVtZW50cy5wdXNoKGN1cnJlbnRFbGVtZW50LmRpdik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5lc3RlZEVsZW1lbnRzID0gY3VycmVudEVsZW1lbnQgaW5zdGFuY2VvZiBGcmFtZVN0YXRlID8gY3VycmVudEVsZW1lbnQuZWxlbWVudHMgOiBbXTtcbiAgICAgIGZvciAoY29uc3QgbmVzdGVkRWxlbWVudCBvZiBuZXN0ZWRFbGVtZW50cykge1xuICAgICAgICBzdGFjay51bnNoaWZ0KG5lc3RlZEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRFbGVtZW50cztcbiAgfTtcblxuICBpbml0TW92ZWFibGUgPSAoZGVzdHJveVNlbGVjdG8gPSBmYWxzZSwgYWxsb3dDaGFuZ2VzID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldEVsZW1lbnRzID0gdGhpcy5nZW5lcmF0ZVRhcmdldEVsZW1lbnRzKHRoaXMucm9vdC5lbGVtZW50cyk7XG5cbiAgICBpZiAoZGVzdHJveVNlbGVjdG8gJiYgdGhpcy5zZWxlY3RvKSB7XG4gICAgICB0aGlzLnNlbGVjdG8uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuc2VsZWN0byA9IG5ldyBTZWxlY3RvKHtcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5kaXYsXG4gICAgICBzZWxlY3RhYmxlVGFyZ2V0czogdGFyZ2V0RWxlbWVudHMsXG4gICAgICBzZWxlY3RCeUNsaWNrOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgdGhpcy5tb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZSh0aGlzLmRpdiEsIHtcbiAgICAgIGRyYWdnYWJsZTogYWxsb3dDaGFuZ2VzLFxuICAgICAgcmVzaXphYmxlOiBhbGxvd0NoYW5nZXMsXG4gICAgICBhYmxlczogW2RpbWVuc2lvblZpZXdhYmxlLCBjb25zdHJhaW50Vmlld2FibGUodGhpcyldLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZGltZW5zaW9uVmlld2FibGU6IGFsbG93Q2hhbmdlcyxcbiAgICAgICAgY29uc3RyYWludFZpZXdhYmxlOiBhbGxvd0NoYW5nZXMsXG4gICAgICB9LFxuICAgICAgb3JpZ2luOiBmYWxzZSxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5zdHlsZXMuc2VsZWN0ZWQsXG4gICAgfSlcbiAgICAgIC5vbignY2xpY2tHcm91cCcsIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdG8hLmNsaWNrVGFyZ2V0KGV2ZW50LmlucHV0RXZlbnQsIGV2ZW50LmlucHV0VGFyZ2V0KTtcbiAgICAgIH0pXG4gICAgICAub24oJ2RyYWdTdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRlZEVsZW1lbnQgPSB0aGlzLmZpbmRFbGVtZW50QnlUYXJnZXQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRhcmdldGVkRWxlbWVudCkge1xuICAgICAgICAgIHRhcmdldGVkRWxlbWVudC5pc01vdmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ2RyYWcnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ZWRFbGVtZW50ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHRhcmdldGVkRWxlbWVudCEuYXBwbHlEcmFnKGV2ZW50KTtcbiAgICAgIH0pXG4gICAgICAub24oJ2RyYWdHcm91cCcsIChlKSA9PiB7XG4gICAgICAgIGUuZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ZWRFbGVtZW50ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgdGFyZ2V0ZWRFbGVtZW50IS5hcHBseURyYWcoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAub24oJ2RyYWdFbmQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ZWRFbGVtZW50ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGlmICh0YXJnZXRlZEVsZW1lbnQpIHtcbiAgICAgICAgICB0YXJnZXRlZEVsZW1lbnQuc2V0UGxhY2VtZW50RnJvbUNvbnN0cmFpbnQoKTtcbiAgICAgICAgICB0YXJnZXRlZEVsZW1lbnQuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW92ZWQubmV4dChEYXRlLm5vdygpKTtcbiAgICAgIH0pXG4gICAgICAub24oJ3Jlc2l6ZVN0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldGVkRWxlbWVudCA9IHRoaXMuZmluZEVsZW1lbnRCeVRhcmdldChldmVudC50YXJnZXQpO1xuXG4gICAgICAgIGlmICh0YXJnZXRlZEVsZW1lbnQpIHtcbiAgICAgICAgICB0YXJnZXRlZEVsZW1lbnQudGVtcENvbnN0cmFpbnQgPSB7IC4uLnRhcmdldGVkRWxlbWVudC5vcHRpb25zLmNvbnN0cmFpbnQgfTtcbiAgICAgICAgICB0YXJnZXRlZEVsZW1lbnQub3B0aW9ucy5jb25zdHJhaW50ID0ge1xuICAgICAgICAgICAgdmVydGljYWw6IFZlcnRpY2FsQ29uc3RyYWludC5Ub3AsXG4gICAgICAgICAgICBob3Jpem9udGFsOiBIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0LFxuICAgICAgICAgIH07XG4gICAgICAgICAgdGFyZ2V0ZWRFbGVtZW50LnNldFBsYWNlbWVudEZyb21Db25zdHJhaW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ3Jlc2l6ZScsIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRlZEVsZW1lbnQgPSB0aGlzLmZpbmRFbGVtZW50QnlUYXJnZXQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdGFyZ2V0ZWRFbGVtZW50IS5hcHBseVJlc2l6ZShldmVudCk7XG4gICAgICAgIHRoaXMubW92ZWQubmV4dChEYXRlLm5vdygpKTsgLy8gVE9ETyBvbmx5IG9uIGVuZFxuICAgICAgfSlcbiAgICAgIC5vbigncmVzaXplR3JvdXAnLCAoZSkgPT4ge1xuICAgICAgICBlLmV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldGVkRWxlbWVudCA9IHRoaXMuZmluZEVsZW1lbnRCeVRhcmdldChldmVudC50YXJnZXQpO1xuICAgICAgICAgIHRhcmdldGVkRWxlbWVudCEuYXBwbHlSZXNpemUoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb3ZlZC5uZXh0KERhdGUubm93KCkpOyAvLyBUT0RPIG9ubHkgb24gZW5kXG4gICAgICB9KVxuICAgICAgLm9uKCdyZXNpemVFbmQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ZWRFbGVtZW50ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG5cbiAgICAgICAgaWYgKHRhcmdldGVkRWxlbWVudCkge1xuICAgICAgICAgIGlmICh0YXJnZXRlZEVsZW1lbnQudGVtcENvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIHRhcmdldGVkRWxlbWVudC5vcHRpb25zLmNvbnN0cmFpbnQgPSB0YXJnZXRlZEVsZW1lbnQudGVtcENvbnN0cmFpbnQ7XG4gICAgICAgICAgICB0YXJnZXRlZEVsZW1lbnQudGVtcENvbnN0cmFpbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFyZ2V0ZWRFbGVtZW50LnNldFBsYWNlbWVudEZyb21Db25zdHJhaW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgbGV0IHRhcmdldHM6IEFycmF5PEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudD4gPSBbXTtcbiAgICB0aGlzLnNlbGVjdG8hLm9uKCdkcmFnU3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVGFyZ2V0ID0gZXZlbnQuaW5wdXRFdmVudC50YXJnZXQ7XG5cbiAgICAgIGNvbnN0IGlzVGFyZ2V0TW92ZWFibGVFbGVtZW50ID1cbiAgICAgICAgdGhpcy5tb3ZlYWJsZSEuaXNNb3ZlYWJsZUVsZW1lbnQoc2VsZWN0ZWRUYXJnZXQpIHx8XG4gICAgICAgIHRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0YXJnZXQgPT09IHNlbGVjdGVkVGFyZ2V0IHx8IHRhcmdldC5jb250YWlucyhzZWxlY3RlZFRhcmdldCkpO1xuXG4gICAgICBpZiAoaXNUYXJnZXRNb3ZlYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgLy8gUHJldmVudCBkcmF3aW5nIHNlbGVjdGlvbiBib3ggd2hlbiBzZWxlY3RlZCB0YXJnZXQgaXMgYSBtb3ZlYWJsZSBlbGVtZW50XG4gICAgICAgIGV2ZW50LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9KS5vbignc2VsZWN0RW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICB0YXJnZXRzID0gZXZlbnQuc2VsZWN0ZWQ7XG4gICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbih7IHRhcmdldHMgfSk7XG5cbiAgICAgIGlmIChldmVudC5pc0RyYWdTdGFydCkge1xuICAgICAgICBldmVudC5pbnB1dEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubW92ZWFibGUhLmRyYWdTdGFydChldmVudC5pbnB1dEV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGNhblNob3dDb250ZXh0TWVudSA9IHRoaXMuaXNQYW5lbEVkaXRpbmcgfHwgKCF0aGlzLmlzUGFuZWxFZGl0aW5nICYmIHRoaXMuaXNFZGl0aW5nRW5hYmxlZCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBrZXk9e3RoaXMucmV2SWR9IGNsYXNzTmFtZT17dGhpcy5zdHlsZXMud3JhcH0gc3R5bGU9e3RoaXMuc3R5bGV9IHJlZj17dGhpcy5zZXRSZWZ9PlxuICAgICAgICB7dGhpcy5yb290LnJlbmRlcigpfVxuICAgICAgICB7Y2FuU2hvd0NvbnRleHRNZW51ICYmIChcbiAgICAgICAgICA8UG9ydGFsPlxuICAgICAgICAgICAgPENhbnZhc0NvbnRleHRNZW51IHNjZW5lPXt0aGlzfSAvPlxuICAgICAgICAgIDwvUG9ydGFsPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBnZXRTdHlsZXMgPSBzdHlsZXNGYWN0b3J5KCh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgd3JhcDogY3NzYFxuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBgLFxuICBzZWxlY3RlZDogY3NzYFxuICAgIHotaW5kZXg6IDk5OSAhaW1wb3J0YW50O1xuICBgLFxufSkpO1xuIiwiaW1wb3J0IHsgQ29sb3JEaW1lbnNpb25Db25maWcsIFJlc291cmNlRGltZW5zaW9uQ29uZmlnIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYWNlbWVudCB7XG4gIHRvcD86IG51bWJlcjtcbiAgbGVmdD86IG51bWJlcjtcbiAgcmlnaHQ/OiBudW1iZXI7XG4gIGJvdHRvbT86IG51bWJlcjtcblxuICB3aWR0aD86IG51bWJlcjtcbiAgaGVpZ2h0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnN0cmFpbnQge1xuICBob3Jpem9udGFsPzogSG9yaXpvbnRhbENvbnN0cmFpbnQ7XG4gIHZlcnRpY2FsPzogVmVydGljYWxDb25zdHJhaW50O1xufVxuXG5leHBvcnQgZW51bSBIb3Jpem9udGFsQ29uc3RyYWludCB7XG4gIExlZnQgPSAnbGVmdCcsXG4gIFJpZ2h0ID0gJ3JpZ2h0JyxcbiAgTGVmdFJpZ2h0ID0gJ2xlZnRyaWdodCcsXG4gIENlbnRlciA9ICdjZW50ZXInLFxuICBTY2FsZSA9ICdzY2FsZScsXG59XG5cbmV4cG9ydCBlbnVtIFZlcnRpY2FsQ29uc3RyYWludCB7XG4gIFRvcCA9ICd0b3AnLFxuICBCb3R0b20gPSAnYm90dG9tJyxcbiAgVG9wQm90dG9tID0gJ3RvcGJvdHRvbScsXG4gIENlbnRlciA9ICdjZW50ZXInLFxuICBTY2FsZSA9ICdzY2FsZScsXG59XG5cbmV4cG9ydCBlbnVtIEJhY2tncm91bmRJbWFnZVNpemUge1xuICBPcmlnaW5hbCA9ICdvcmlnaW5hbCcsXG4gIENvbnRhaW4gPSAnY29udGFpbicsXG4gIENvdmVyID0gJ2NvdmVyJyxcbiAgRmlsbCA9ICdmaWxsJyxcbiAgVGlsZSA9ICd0aWxlJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYWNrZ3JvdW5kQ29uZmlnIHtcbiAgY29sb3I/OiBDb2xvckRpbWVuc2lvbkNvbmZpZztcbiAgaW1hZ2U/OiBSZXNvdXJjZURpbWVuc2lvbkNvbmZpZztcbiAgc2l6ZT86IEJhY2tncm91bmRJbWFnZVNpemU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZUNvbmZpZyB7XG4gIGNvbG9yPzogQ29sb3JEaW1lbnNpb25Db25maWc7XG4gIHdpZHRoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBRdWlja1BsYWNlbWVudCB7XG4gIFRvcCA9ICd0b3AnLFxuICBCb3R0b20gPSAnYm90dG9tJyxcbiAgTGVmdCA9ICdsZWZ0JyxcbiAgUmlnaHQgPSAncmlnaHQnLFxuICBIb3Jpem9udGFsQ2VudGVyID0gJ2hjZW50ZXInLFxuICBWZXJ0aWNhbENlbnRlciA9ICd2Y2VudGVyJyxcbn1cbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgQ29udGV4dE1lbnUsIE1lbnVJdGVtIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gJy4uLy4uLy4uL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL3NjZW5lJztcblxuaW1wb3J0IHsgTGF5ZXJBY3Rpb25JRCB9IGZyb20gJy4vdHlwZXMnO1xuXG50eXBlIFByb3BzID0ge1xuICBzY2VuZTogU2NlbmU7XG59O1xuXG50eXBlIEFuY2hvclBvaW50ID0ge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBjb25zdCBDYW52YXNDb250ZXh0TWVudSA9ICh7IHNjZW5lIH06IFByb3BzKSA9PiB7XG4gIGNvbnN0IFtpc01lbnVWaXNpYmxlLCBzZXRJc01lbnVWaXNpYmxlXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2FuY2hvclBvaW50LCBzZXRBbmNob3JQb2ludF0gPSB1c2VTdGF0ZTxBbmNob3JQb2ludD4oeyB4OiAwLCB5OiAwIH0pO1xuXG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlcygpO1xuXG4gIGNvbnN0IHNlbGVjdGVkRWxlbWVudHMgPSBzY2VuZS5zZWxlY3RvPy5nZXRTZWxlY3RlZFRhcmdldHMoKTtcblxuICBjb25zdCBoYW5kbGVDb250ZXh0TWVudSA9IHVzZUNhbGxiYWNrKFxuICAgIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIHNjZW5lLnNlbGVjdCh7IHRhcmdldHM6IFtldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudF0gfSk7XG4gICAgICB9XG4gICAgICBzZXRBbmNob3JQb2ludCh7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9KTtcbiAgICAgIHNldElzTWVudVZpc2libGUodHJ1ZSk7XG4gICAgfSxcbiAgICBbc2NlbmVdXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2VsZWN0ZWRFbGVtZW50cyAmJiBzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdGVkRWxlbWVudHNbMF07XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgaGFuZGxlQ29udGV4dE1lbnUpO1xuICAgIH1cbiAgfSwgW3NlbGVjdGVkRWxlbWVudHMsIGhhbmRsZUNvbnRleHRNZW51XSk7XG5cbiAgaWYgKCFzZWxlY3RlZEVsZW1lbnRzKSB7XG4gICAgcmV0dXJuIDw+PC8+O1xuICB9XG5cbiAgY29uc3QgY2xvc2VDb250ZXh0TWVudSA9ICgpID0+IHtcbiAgICBzZXRJc01lbnVWaXNpYmxlKGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCByZW5kZXJNZW51SXRlbXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDw+XG4gICAgICAgIDxNZW51SXRlbVxuICAgICAgICAgIGxhYmVsPVwiRGVsZXRlXCJcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0TWVudUFjdGlvbihMYXllckFjdGlvbklELkRlbGV0ZSk7XG4gICAgICAgICAgICBjbG9zZUNvbnRleHRNZW51KCk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5tZW51SXRlbX1cbiAgICAgICAgLz5cbiAgICAgICAgPE1lbnVJdGVtXG4gICAgICAgICAgbGFiZWw9XCJEdXBsaWNhdGVcIlxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgIGNvbnRleHRNZW51QWN0aW9uKExheWVyQWN0aW9uSUQuRHVwbGljYXRlKTtcbiAgICAgICAgICAgIGNsb3NlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLm1lbnVJdGVtfVxuICAgICAgICAvPlxuICAgICAgICA8TWVudUl0ZW1cbiAgICAgICAgICBsYWJlbD1cIkJyaW5nIHRvIGZyb250XCJcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0TWVudUFjdGlvbihMYXllckFjdGlvbklELk1vdmVUb3ApO1xuICAgICAgICAgICAgY2xvc2VDb250ZXh0TWVudSgpO1xuICAgICAgICAgIH19XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubWVudUl0ZW19XG4gICAgICAgIC8+XG4gICAgICAgIDxNZW51SXRlbVxuICAgICAgICAgIGxhYmVsPVwiU2VuZCB0byBiYWNrXCJcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0TWVudUFjdGlvbihMYXllckFjdGlvbklELk1vdmVCb3R0b20pO1xuICAgICAgICAgICAgY2xvc2VDb250ZXh0TWVudSgpO1xuICAgICAgICAgIH19XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubWVudUl0ZW19XG4gICAgICAgIC8+XG4gICAgICA8Lz5cbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IGNvbnRleHRNZW51QWN0aW9uID0gKGFjdGlvblR5cGU6IHN0cmluZykgPT4ge1xuICAgIHNjZW5lLnNlbGVjdGlvbi5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSgoY3VycmVudFNlbGVjdGVkRWxlbWVudHMpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3RlZEVsZW1lbnQgPSBjdXJyZW50U2VsZWN0ZWRFbGVtZW50c1swXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMYXllciA9IGN1cnJlbnRTZWxlY3RlZEVsZW1lbnQucGFyZW50ITtcblxuICAgICAgc3dpdGNoIChhY3Rpb25UeXBlKSB7XG4gICAgICAgIGNhc2UgTGF5ZXJBY3Rpb25JRC5EZWxldGU6XG4gICAgICAgICAgY3VycmVudExheWVyLmRvQWN0aW9uKExheWVyQWN0aW9uSUQuRGVsZXRlLCBjdXJyZW50U2VsZWN0ZWRFbGVtZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMYXllckFjdGlvbklELkR1cGxpY2F0ZTpcbiAgICAgICAgICBjdXJyZW50TGF5ZXIuZG9BY3Rpb24oTGF5ZXJBY3Rpb25JRC5EdXBsaWNhdGUsIGN1cnJlbnRTZWxlY3RlZEVsZW1lbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExheWVyQWN0aW9uSUQuTW92ZVRvcDpcbiAgICAgICAgICBjdXJyZW50TGF5ZXIuZG9BY3Rpb24oTGF5ZXJBY3Rpb25JRC5Nb3ZlVG9wLCBjdXJyZW50U2VsZWN0ZWRFbGVtZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMYXllckFjdGlvbklELk1vdmVCb3R0b206XG4gICAgICAgICAgY3VycmVudExheWVyLmRvQWN0aW9uKExheWVyQWN0aW9uSUQuTW92ZUJvdHRvbSwgY3VycmVudFNlbGVjdGVkRWxlbWVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGlzTWVudVZpc2libGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBvbkNvbnRleHRNZW51PXsoZXZlbnQpID0+IHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNsb3NlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPENvbnRleHRNZW51XG4gICAgICAgICAgeD17YW5jaG9yUG9pbnQueH1cbiAgICAgICAgICB5PXthbmNob3JQb2ludC55fVxuICAgICAgICAgIG9uQ2xvc2U9e2Nsb3NlQ29udGV4dE1lbnV9XG4gICAgICAgICAgcmVuZGVyTWVudUl0ZW1zPXtyZW5kZXJNZW51SXRlbXN9XG4gICAgICAgICAgZm9jdXNPbk9wZW49e2ZhbHNlfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiA8PjwvPjtcbn07XG5cbmNvbnN0IGdldFN0eWxlcyA9ICgpID0+ICh7XG4gIG1lbnVJdGVtOiBjc3NgXG4gICAgbWF4LXdpZHRoOiA2MGNoO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gIGAsXG59KTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZSwgUGFuZWxQcm9wcyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgY29uZmlnLCBsb2NhdGlvblNlcnZpY2UgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lL3NyYyc7XG5pbXBvcnQgeyBCdXR0b24sIFBhbmVsQ29udGV4dCwgUGFuZWxDb250ZXh0Um9vdCwgc3R5bGVzRmFjdG9yeSB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IENhbnZhc0ZyYW1lT3B0aW9ucyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMnO1xuaW1wb3J0IHsgRWxlbWVudFN0YXRlIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL2VsZW1lbnQnO1xuaW1wb3J0IHsgU2NlbmUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvc2NlbmUnO1xuaW1wb3J0IHsgUGFuZWxFZGl0RW50ZXJlZEV2ZW50LCBQYW5lbEVkaXRFeGl0ZWRFdmVudCB9IGZyb20gJ2FwcC90eXBlcy9ldmVudHMnO1xuXG5pbXBvcnQgeyBJbmxpbmVFZGl0IH0gZnJvbSAnLi9JbmxpbmVFZGl0JztcbmltcG9ydCB7IFBhbmVsT3B0aW9ucyB9IGZyb20gJy4vbW9kZWxzLmdlbic7XG5cbmludGVyZmFjZSBQcm9wcyBleHRlbmRzIFBhbmVsUHJvcHM8UGFuZWxPcHRpb25zPiB7fVxuXG5pbnRlcmZhY2UgU3RhdGUge1xuICByZWZyZXNoOiBudW1iZXI7XG4gIG9wZW5JbmxpbmVFZGl0OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluc3RhbmNlU3RhdGUge1xuICBzY2VuZTogU2NlbmU7XG4gIHNlbGVjdGVkOiBFbGVtZW50U3RhdGVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3Rpb25BY3Rpb24ge1xuICBwYW5lbDogQ2FudmFzUGFuZWw7XG59XG5cbmxldCBjYW52YXNJbnN0YW5jZXM6IENhbnZhc1BhbmVsW10gPSBbXTtcbmxldCBhY3RpdmVDYW52YXNQYW5lbDogQ2FudmFzUGFuZWwgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5sZXQgaXNJbmxpbmVFZGl0T3BlbiA9IGZhbHNlO1xuXG5leHBvcnQgY29uc3QgYWN0aXZlUGFuZWxTdWJqZWN0ID0gbmV3IFJlcGxheVN1YmplY3Q8U2VsZWN0aW9uQWN0aW9uPigxKTtcblxuZXhwb3J0IGNsYXNzIENhbnZhc1BhbmVsIGV4dGVuZHMgQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgY29udGV4dFR5cGUgPSBQYW5lbENvbnRleHRSb290O1xuICBwYW5lbENvbnRleHQ6IFBhbmVsQ29udGV4dCA9IHt9IGFzIFBhbmVsQ29udGV4dDtcblxuICByZWFkb25seSBzY2VuZTogU2NlbmU7XG4gIHByaXZhdGUgc3VicyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgbmVlZHNSZWxvYWQgPSBmYWxzZTtcbiAgc3R5bGVzID0gZ2V0U3R5bGVzKGNvbmZpZy50aGVtZSk7XG4gIGlzRWRpdGluZyA9IGxvY2F0aW9uU2VydmljZS5nZXRTZWFyY2hPYmplY3QoKS5lZGl0UGFuZWwgIT09IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHJlZnJlc2g6IDAsXG4gICAgICBvcGVuSW5saW5lRWRpdDogZmFsc2UsXG4gICAgfTtcblxuICAgIC8vIE9ubHkgdGhlIGluaXRpYWwgb3B0aW9ucyBhcmUgZXZlciB1c2VkLlxuICAgIC8vIGxhdGVyIGNoYW5nZXMgYXJlIGFsbCBjb250cm9sbGVkIGJ5IHRoZSBzY2VuZVxuICAgIHRoaXMuc2NlbmUgPSBuZXcgU2NlbmUodGhpcy5wcm9wcy5vcHRpb25zLnJvb3QsIHRoaXMucHJvcHMub3B0aW9ucy5pbmxpbmVFZGl0aW5nLCB0aGlzLm9uVXBkYXRlU2NlbmUpO1xuICAgIHRoaXMuc2NlbmUudXBkYXRlU2l6ZShwcm9wcy53aWR0aCwgcHJvcHMuaGVpZ2h0KTtcbiAgICB0aGlzLnNjZW5lLnVwZGF0ZURhdGEocHJvcHMuZGF0YSk7XG5cbiAgICB0aGlzLnN1YnMuYWRkKFxuICAgICAgdGhpcy5wcm9wcy5ldmVudEJ1cy5zdWJzY3JpYmUoUGFuZWxFZGl0RW50ZXJlZEV2ZW50LCAoZXZ0KSA9PiB7XG4gICAgICAgIC8vIFJlbW92ZSBjdXJyZW50IHNlbGVjdGlvbiB3aGVuIGVudGVyaW5nIGVkaXQgbW9kZSBmb3IgYW55IHBhbmVsIGluIGRhc2hib2FyZFxuICAgICAgICB0aGlzLnNjZW5lLmNsZWFyQ3VycmVudFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmlubGluZUVkaXRCdXR0b25DbG9zZSgpO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5zdWJzLmFkZChcbiAgICAgIHRoaXMucHJvcHMuZXZlbnRCdXMuc3Vic2NyaWJlKFBhbmVsRWRpdEV4aXRlZEV2ZW50LCAoZXZ0KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmlkID09PSBldnQucGF5bG9hZCkge1xuICAgICAgICAgIHRoaXMubmVlZHNSZWxvYWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBhY3RpdmVDYW52YXNQYW5lbCA9IHRoaXM7XG4gICAgYWN0aXZlUGFuZWxTdWJqZWN0Lm5leHQoeyBwYW5lbDogdGhpcyB9KTtcblxuICAgIHRoaXMucGFuZWxDb250ZXh0ID0gdGhpcy5jb250ZXh0IGFzIFBhbmVsQ29udGV4dDtcbiAgICBpZiAodGhpcy5wYW5lbENvbnRleHQub25JbnN0YW5jZVN0YXRlQ2hhbmdlKSB7XG4gICAgICB0aGlzLnBhbmVsQ29udGV4dC5vbkluc3RhbmNlU3RhdGVDaGFuZ2Uoe1xuICAgICAgICBzY2VuZTogdGhpcy5zY2VuZSxcbiAgICAgICAgbGF5ZXI6IHRoaXMuc2NlbmUucm9vdCxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnN1YnMuYWRkKFxuICAgICAgICB0aGlzLnNjZW5lLnNlbGVjdGlvbi5zdWJzY3JpYmUoe1xuICAgICAgICAgIG5leHQ6ICh2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhbmVsQ29udGV4dC5vbkluc3RhbmNlU3RhdGVDaGFuZ2UhKHtcbiAgICAgICAgICAgICAgc2NlbmU6IHRoaXMuc2NlbmUsXG4gICAgICAgICAgICAgIHNlbGVjdGVkOiB2LFxuICAgICAgICAgICAgICBsYXllcjogdGhpcy5zY2VuZS5yb290LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFjdGl2ZUNhbnZhc1BhbmVsID0gdGhpcztcbiAgICAgICAgICAgIGFjdGl2ZVBhbmVsU3ViamVjdC5uZXh0KHsgcGFuZWw6IHRoaXMgfSk7XG5cbiAgICAgICAgICAgIGNhbnZhc0luc3RhbmNlcy5mb3JFYWNoKChjYW52YXNJbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoY2FudmFzSW5zdGFuY2UgIT09IGFjdGl2ZUNhbnZhc1BhbmVsKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzSW5zdGFuY2Uuc2NlbmUuY2xlYXJDdXJyZW50U2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjYW52YXNJbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuc3Vicy51bnN1YnNjcmliZSgpO1xuICAgIGlzSW5saW5lRWRpdE9wZW4gPSBmYWxzZTtcbiAgICBjYW52YXNJbnN0YW5jZXMgPSBjYW52YXNJbnN0YW5jZXMuZmlsdGVyKChjaSkgPT4gY2kucHJvcHMuaWQgIT09IGFjdGl2ZUNhbnZhc1BhbmVsPy5wcm9wcy5pZCk7XG4gIH1cblxuICAvLyBOT1RFLCBhbGwgY2hhbmdlcyB0byB0aGUgc2NlbmUgZmxvdyB0aHJvdWdoIHRoaXMgZnVuY3Rpb25cbiAgLy8gZXZlbiB0aGUgZWRpdG9yIGdldHMgY3VycmVudCBzdGF0ZSBmcm9tIHRoZSBzYW1lIHNjZW5lIGluc3RhbmNlIVxuICBvblVwZGF0ZVNjZW5lID0gKHJvb3Q6IENhbnZhc0ZyYW1lT3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgb25PcHRpb25zQ2hhbmdlLCBvcHRpb25zIH0gPSB0aGlzLnByb3BzO1xuICAgIG9uT3B0aW9uc0NoYW5nZSh7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcm9vdCxcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0U3RhdGUoeyByZWZyZXNoOiB0aGlzLnN0YXRlLnJlZnJlc2ggKyAxIH0pO1xuICAgIC8vIGNvbnNvbGUubG9nKCdzZW5kIGNoYW5nZXMnLCByb290KTtcbiAgfTtcblxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzOiBQcm9wcywgbmV4dFN0YXRlOiBTdGF0ZSkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgZGF0YSB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHdpZHRoICE9PSBuZXh0UHJvcHMud2lkdGggfHwgaGVpZ2h0ICE9PSBuZXh0UHJvcHMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLnNjZW5lLnVwZGF0ZVNpemUobmV4dFByb3BzLndpZHRoLCBuZXh0UHJvcHMuaGVpZ2h0KTtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGF0YSAhPT0gbmV4dFByb3BzLmRhdGEpIHtcbiAgICAgIHRoaXMuc2NlbmUudXBkYXRlRGF0YShuZXh0UHJvcHMuZGF0YSk7XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5yZWZyZXNoICE9PSBuZXh0U3RhdGUucmVmcmVzaCkge1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUub3BlbklubGluZUVkaXQgIT09IG5leHRTdGF0ZS5vcGVuSW5saW5lRWRpdCkge1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWZ0ZXIgZWRpdGluZywgdGhlIG9wdGlvbnMgYXJlIHZhbGlkLCBidXQgdGhlIHNjZW5lIHdhcyBpbiBhIGRpZmZlcmVudCBwYW5lbCBvciBpbmxpbmUgZWRpdGluZyBtb2RlIGhhcyBjaGFuZ2VkXG4gICAgY29uc3Qgc2hvdWxkVXBkYXRlU2NlbmVBbmRQYW5lbCA9IHRoaXMubmVlZHNSZWxvYWQgJiYgdGhpcy5wcm9wcy5vcHRpb25zICE9PSBuZXh0UHJvcHMub3B0aW9ucztcbiAgICBjb25zdCBpbmxpbmVFZGl0aW5nU3dpdGNoZWQgPSB0aGlzLnByb3BzLm9wdGlvbnMuaW5saW5lRWRpdGluZyAhPT0gbmV4dFByb3BzLm9wdGlvbnMuaW5saW5lRWRpdGluZztcbiAgICBpZiAoc2hvdWxkVXBkYXRlU2NlbmVBbmRQYW5lbCB8fCBpbmxpbmVFZGl0aW5nU3dpdGNoZWQpIHtcbiAgICAgIHRoaXMubmVlZHNSZWxvYWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2NlbmUubG9hZChuZXh0UHJvcHMub3B0aW9ucy5yb290LCBuZXh0UHJvcHMub3B0aW9ucy5pbmxpbmVFZGl0aW5nKTtcbiAgICAgIHRoaXMuc2NlbmUudXBkYXRlU2l6ZShuZXh0UHJvcHMud2lkdGgsIG5leHRQcm9wcy5oZWlnaHQpO1xuICAgICAgdGhpcy5zY2VuZS51cGRhdGVEYXRhKG5leHRQcm9wcy5kYXRhKTtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoaW5saW5lRWRpdGluZ1N3aXRjaGVkICYmIHRoaXMucHJvcHMub3B0aW9ucy5pbmxpbmVFZGl0aW5nKSB7XG4gICAgICAgIHRoaXMuc2NlbmUuc2VsZWN0bz8uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgaW5saW5lRWRpdEJ1dHRvbkNsaWNrID0gKCkgPT4ge1xuICAgIGlmIChpc0lubGluZUVkaXRPcGVuKSB7XG4gICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICB0aGlzLnNldEFjdGl2ZVBhbmVsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBY3RpdmVQYW5lbCgpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBvcGVuSW5saW5lRWRpdDogdHJ1ZSB9KTtcbiAgICBpc0lubGluZUVkaXRPcGVuID0gdHJ1ZTtcbiAgfTtcblxuICBpbmxpbmVFZGl0QnV0dG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IG9wZW5JbmxpbmVFZGl0OiBmYWxzZSB9KTtcbiAgICBpc0lubGluZUVkaXRPcGVuID0gZmFsc2U7XG4gIH07XG5cbiAgc2V0QWN0aXZlUGFuZWwgPSAoKSA9PiB7XG4gICAgYWN0aXZlQ2FudmFzUGFuZWwgPSB0aGlzO1xuICAgIGFjdGl2ZVBhbmVsU3ViamVjdC5uZXh0KHsgcGFuZWw6IHRoaXMgfSk7XG4gIH07XG5cbiAgcmVuZGVySW5saW5lRWRpdCA9ICgpID0+IHtcbiAgICByZXR1cm4gPElubGluZUVkaXQgb25DbG9zZT17KCkgPT4gdGhpcy5pbmxpbmVFZGl0QnV0dG9uQ2xvc2UoKX0gLz47XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICB7dGhpcy5zY2VuZS5yZW5kZXIoKX1cbiAgICAgICAge3RoaXMucHJvcHMub3B0aW9ucy5pbmxpbmVFZGl0aW5nICYmICF0aGlzLmlzRWRpdGluZyAmJiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXt0aGlzLnN0eWxlcy5pbmxpbmVFZGl0QnV0dG9ufT5cbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIHNpemU9XCJsZ1wiXG4gICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgaWNvbj1cImVkaXRcIlxuICAgICAgICAgICAgICAgIGRhdGEtYnRuaW5saW5lZWRpdD17dGhpcy5wcm9wcy5pZH1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmlubGluZUVkaXRCdXR0b25DbGlja31cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge3RoaXMuc3RhdGUub3BlbklubGluZUVkaXQgJiYgdGhpcy5yZW5kZXJJbmxpbmVFZGl0KCl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8Lz5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9IHN0eWxlc0ZhY3RvcnkoKHRoZW1lOiBHcmFmYW5hVGhlbWUpID0+ICh7XG4gIGlubGluZUVkaXRCdXR0b246IGNzc2BcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiA4cHg7XG4gICAgbGVmdDogOHB4O1xuICAgIHotaW5kZXg6IDk5OTtcbiAgYCxcbn0pKTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgU3ludGhldGljRXZlbnQsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRHJhZ2dhYmxlIGZyb20gJ3JlYWN0LWRyYWdnYWJsZSc7XG5pbXBvcnQgeyBSZXNpemFibGUsIFJlc2l6ZUNhbGxiYWNrRGF0YSB9IGZyb20gJ3JlYWN0LXJlc2l6YWJsZSc7XG5cbmltcG9ydCB7IERpbWVuc2lvbnMyRCwgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgSWNvbkJ1dHRvbiwgUG9ydGFsLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHN0b3JlIGZyb20gJ2FwcC9jb3JlL3N0b3JlJztcblxuaW1wb3J0IHsgSW5saW5lRWRpdEJvZHkgfSBmcm9tICcuL0lubGluZUVkaXRCb2R5JztcblxudHlwZSBQcm9wcyA9IHtcbiAgb25DbG9zZT86ICgpID0+IHZvaWQ7XG59O1xuXG5jb25zdCBPRkZTRVRfWCA9IDcwO1xuXG5leHBvcnQgY29uc3QgSW5saW5lRWRpdCA9ICh7IG9uQ2xvc2UgfTogUHJvcHMpID0+IHtcbiAgY29uc3QgYnRuSW5saW5lRWRpdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWJ0bmlubGluZWVkaXRdJykhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCByZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG4gIGNvbnN0IGlubGluZUVkaXRLZXkgPSAnaW5saW5lRWRpdFBhbmVsJztcblxuICBjb25zdCBkZWZhdWx0TWVhc3VyZW1lbnRzID0geyB3aWR0aDogMzUwLCBoZWlnaHQ6IDQwMCB9O1xuICBjb25zdCBkZWZhdWx0WCA9IGJ0bklubGluZUVkaXQueCArIE9GRlNFVF9YO1xuICBjb25zdCBkZWZhdWx0WSA9IGJ0bklubGluZUVkaXQueSAtIGRlZmF1bHRNZWFzdXJlbWVudHMuaGVpZ2h0O1xuXG4gIGNvbnN0IHNhdmVkUGxhY2VtZW50ID0gc3RvcmUuZ2V0T2JqZWN0KGlubGluZUVkaXRLZXksIHtcbiAgICB4OiBkZWZhdWx0WCxcbiAgICB5OiBkZWZhdWx0WSxcbiAgICB3OiBkZWZhdWx0TWVhc3VyZW1lbnRzLndpZHRoLFxuICAgIGg6IGRlZmF1bHRNZWFzdXJlbWVudHMuaGVpZ2h0LFxuICB9KTtcbiAgY29uc3QgW21lYXN1cmVtZW50cywgc2V0TWVhc3VyZW1lbnRzXSA9IHVzZVN0YXRlPERpbWVuc2lvbnMyRD4oeyB3aWR0aDogc2F2ZWRQbGFjZW1lbnQudywgaGVpZ2h0OiBzYXZlZFBsYWNlbWVudC5oIH0pO1xuICBjb25zdCBbcGxhY2VtZW50LCBzZXRQbGFjZW1lbnRdID0gdXNlU3RhdGUoeyB4OiBzYXZlZFBsYWNlbWVudC54LCB5OiBzYXZlZFBsYWNlbWVudC55IH0pO1xuXG4gIGNvbnN0IG9uRHJhZ1N0b3AgPSAoZXZlbnQ6IGFueSwgZHJhZ0VsZW1lbnQ6IGFueSkgPT4ge1xuICAgIGxldCB4ID0gZHJhZ0VsZW1lbnQueCA8IDAgPyAwIDogZHJhZ0VsZW1lbnQueDtcbiAgICBsZXQgeSA9IGRyYWdFbGVtZW50LnkgPCAwID8gMCA6IGRyYWdFbGVtZW50Lnk7XG5cbiAgICBzZXRQbGFjZW1lbnQoeyB4OiB4LCB5OiB5IH0pO1xuICAgIHNhdmVUb1N0b3JlKHgsIHksIG1lYXN1cmVtZW50cy53aWR0aCwgbWVhc3VyZW1lbnRzLmhlaWdodCk7XG4gIH07XG5cbiAgY29uc3Qgb25SZXNpemVTdG9wID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxFbGVtZW50LCBFdmVudD4sIGRhdGE6IFJlc2l6ZUNhbGxiYWNrRGF0YSkgPT4ge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gZGF0YTtcbiAgICBzZXRNZWFzdXJlbWVudHMoeyB3aWR0aDogc2l6ZS53aWR0aCwgaGVpZ2h0OiBzaXplLmhlaWdodCB9KTtcbiAgICBzYXZlVG9TdG9yZShwbGFjZW1lbnQueCwgcGxhY2VtZW50LnksIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgfTtcblxuICBjb25zdCBzYXZlVG9TdG9yZSA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpID0+IHtcbiAgICBzdG9yZS5zZXRPYmplY3QoaW5saW5lRWRpdEtleSwgeyB4OiB4LCB5OiB5LCB3OiB3aWR0aCwgaDogaGVpZ2h0IH0pO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPFBvcnRhbD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZHJhZ2dhYmxlV3JhcHBlcn0+XG4gICAgICAgIDxEcmFnZ2FibGUgaGFuZGxlPVwic3Ryb25nXCIgb25TdG9wPXtvbkRyYWdTdG9wfSBwb3NpdGlvbj17eyB4OiBwbGFjZW1lbnQueCwgeTogcGxhY2VtZW50LnkgfX0+XG4gICAgICAgICAgPFJlc2l6YWJsZSBoZWlnaHQ9e21lYXN1cmVtZW50cy5oZWlnaHR9IHdpZHRoPXttZWFzdXJlbWVudHMud2lkdGh9IG9uUmVzaXplPXtvblJlc2l6ZVN0b3B9PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5pbmxpbmVFZGl0b3JDb250YWluZXJ9XG4gICAgICAgICAgICAgIHN0eWxlPXt7IGhlaWdodDogYCR7bWVhc3VyZW1lbnRzLmhlaWdodH1weGAsIHdpZHRoOiBgJHttZWFzdXJlbWVudHMud2lkdGh9cHhgIH19XG4gICAgICAgICAgICAgIHJlZj17cmVmfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8c3Ryb25nIGNsYXNzTmFtZT17c3R5bGVzLmlubGluZUVkaXRvckhlYWRlcn0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5wbGFjZWhvbGRlcn0gLz5cbiAgICAgICAgICAgICAgICA8ZGl2PkNhbnZhcyBJbmxpbmUgRWRpdG9yPC9kaXY+XG4gICAgICAgICAgICAgICAgPEljb25CdXR0b24gbmFtZT1cInRpbWVzXCIgc2l6ZT1cInhsXCIgY2xhc3NOYW1lPXtzdHlsZXMuaW5saW5lRWRpdG9yQ2xvc2V9IG9uQ2xpY2s9e29uQ2xvc2V9IC8+XG4gICAgICAgICAgICAgIDwvc3Ryb25nPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmlubGluZUVkaXRvckNvbnRlbnRXcmFwcGVyfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmlubGluZUVkaXRvckNvbnRlbnR9PlxuICAgICAgICAgICAgICAgICAgPElubGluZUVkaXRCb2R5IC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9SZXNpemFibGU+XG4gICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgICAgPC9kaXY+XG4gICAgPC9Qb3J0YWw+XG4gICk7XG59O1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+ICh7XG4gIGlubGluZUVkaXRvckNvbnRhaW5lcjogY3NzYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBiYWNrZ3JvdW5kOiAke3RoZW1lLnYxLmNvbG9ycy5wYW5lbEJnfTtcbiAgICBib3gtc2hhZG93OiA1cHggNXB4IDIwcHggLTVweCAjMDAwMDAwO1xuICAgIHotaW5kZXg6IDEwMDA7XG4gICAgb3BhY2l0eTogMTtcbiAgYCxcbiAgZHJhZ2dhYmxlV3JhcHBlcjogY3NzYFxuICAgIHdpZHRoOiAwO1xuICAgIGhlaWdodDogMDtcbiAgYCxcbiAgaW5saW5lRWRpdG9ySGVhZGVyOiBjc3NgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGJhY2tncm91bmQ6ICR7dGhlbWUuY29sb3JzLmJhY2tncm91bmQuY2FudmFzfTtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ib3JkZXIud2Vha307XG4gICAgaGVpZ2h0OiA0MHB4O1xuICAgIGN1cnNvcjogbW92ZTtcbiAgYCxcbiAgaW5saW5lRWRpdG9yQ29udGVudDogY3NzYFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICBwYWRkaW5nOiAxMHB4O1xuICBgLFxuICBpbmxpbmVFZGl0b3JDbG9zZTogY3NzYFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICBgLFxuICBwbGFjZWhvbGRlcjogY3NzYFxuICAgIHdpZHRoOiAyNHB4O1xuICAgIGhlaWdodDogMjRweDtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xuICBgLFxuICBpbmxpbmVFZGl0b3JDb250ZW50V3JhcHBlcjogY3NzYFxuICAgIG92ZXJmbG93OiBzY3JvbGw7XG4gIGAsXG59KTtcbiIsImltcG9ydCB7IGdldCBhcyBsb2Rhc2hHZXQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VPYnNlcnZhYmxlIH0gZnJvbSAncmVhY3QtdXNlJztcblxuaW1wb3J0IHsgUGFuZWxPcHRpb25zRWRpdG9yQnVpbGRlciwgU3RhbmRhcmRFZGl0b3JDb250ZXh0IH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBQYW5lbE9wdGlvbnNTdXBwbGllciB9IGZyb20gJ0BncmFmYW5hL2RhdGEvc3JjL3BhbmVsL1BhbmVsUGx1Z2luJztcbmltcG9ydCB7IE5lc3RlZFZhbHVlQWNjZXNzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YS9zcmMvdXRpbHMvT3B0aW9uc1VJQnVpbGRlcnMnO1xuaW1wb3J0IHsgRnJhbWVTdGF0ZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9mcmFtZSc7XG5pbXBvcnQgeyBPcHRpb25zUGFuZUNhdGVnb3J5RGVzY3JpcHRvciB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kYXNoYm9hcmQvY29tcG9uZW50cy9QYW5lbEVkaXRvci9PcHRpb25zUGFuZUNhdGVnb3J5RGVzY3JpcHRvcic7XG5pbXBvcnQgeyBmaWxsT3B0aW9uc1BhbmVJdGVtcyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kYXNoYm9hcmQvY29tcG9uZW50cy9QYW5lbEVkaXRvci9nZXRWaXN1YWxpemF0aW9uT3B0aW9ucyc7XG5pbXBvcnQgeyBzZXRPcHRpb25JbW11dGFibHkgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGFzaGJvYXJkL2NvbXBvbmVudHMvUGFuZWxFZGl0b3IvdXRpbHMnO1xuXG5pbXBvcnQgeyBhY3RpdmVQYW5lbFN1YmplY3QsIEluc3RhbmNlU3RhdGUgfSBmcm9tICcuL0NhbnZhc1BhbmVsJztcbmltcG9ydCB7IGdldEVsZW1lbnRFZGl0b3IgfSBmcm9tICcuL2VkaXRvci9lbGVtZW50RWRpdG9yJztcbmltcG9ydCB7IGdldExheWVyRWRpdG9yIH0gZnJvbSAnLi9lZGl0b3IvbGF5ZXJFZGl0b3InO1xuXG5leHBvcnQgY29uc3QgSW5saW5lRWRpdEJvZHkgPSAoKSA9PiB7XG4gIGNvbnN0IGFjdGl2ZVBhbmVsID0gdXNlT2JzZXJ2YWJsZShhY3RpdmVQYW5lbFN1YmplY3QpO1xuICBjb25zdCBpbnN0YW5jZVN0YXRlID0gYWN0aXZlUGFuZWw/LnBhbmVsLmNvbnRleHQ/Lmluc3RhbmNlU3RhdGU7XG5cbiAgY29uc3QgcGFuZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlOiBJbnN0YW5jZVN0YXRlID0gaW5zdGFuY2VTdGF0ZTtcbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICByZXR1cm4gbmV3IE9wdGlvbnNQYW5lQ2F0ZWdvcnlEZXNjcmlwdG9yKHsgaWQ6ICdyb290JywgdGl0bGU6ICdyb290JyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBzdXBwbGllciA9IChidWlsZGVyOiBQYW5lbE9wdGlvbnNFZGl0b3JCdWlsZGVyPGFueT4sIGNvbnRleHQ6IFN0YW5kYXJkRWRpdG9yQ29udGV4dDxhbnk+KSA9PiB7XG4gICAgICBidWlsZGVyLmFkZE5lc3RlZE9wdGlvbnMoZ2V0TGF5ZXJFZGl0b3IoaW5zdGFuY2VTdGF0ZSkpO1xuXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3RlZDtcbiAgICAgIGlmIChzZWxlY3Rpb24/Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gc2VsZWN0aW9uWzBdO1xuICAgICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRnJhbWVTdGF0ZSkpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE5lc3RlZE9wdGlvbnMoXG4gICAgICAgICAgICBnZXRFbGVtZW50RWRpdG9yKHtcbiAgICAgICAgICAgICAgY2F0ZWdvcnk6IFtgU2VsZWN0ZWQgZWxlbWVudCAoJHtlbGVtZW50Lm9wdGlvbnMubmFtZX0pYF0sXG4gICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgIHNjZW5lOiBzdGF0ZS5zY2VuZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZ2V0T3B0aW9uc1BhbmVDYXRlZ29yeURlc2NyaXB0b3Ioe30sIHN1cHBsaWVyKTtcbiAgfSwgW2luc3RhbmNlU3RhdGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8ZGl2PntwYW5lLml0ZW1zLm1hcCgodikgPT4gdi5yZW5kZXIoKSl9PC9kaXY+XG4gICAgICA8ZGl2PlxuICAgICAgICB7cGFuZS5jYXRlZ29yaWVzLm1hcCgoYykgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGtleT17Yy5wcm9wcy5pZH0+XG4gICAgICAgICAgICAgIDxoNT57Yy5wcm9wcy50aXRsZX08L2g1PlxuICAgICAgICAgICAgICA8ZGl2PntjLml0ZW1zLm1hcCgocykgPT4gcy5yZW5kZXIoKSl9PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8g8J+krvCfpK7wn6Su8J+kriB0aGlzIG9kZGx5IGRvZXMgbm90IGFjdHVhbGx5IGRvIGFueXRoaW5nLCBidXQgc3RydWN0dXJlIGlzIHJlcXVpcmVkLiAgSSdsbCB0cnkgdG8gY2xlYW4gaXQgdXAuLi5cbmZ1bmN0aW9uIGdldE9wdGlvbnNQYW5lQ2F0ZWdvcnlEZXNjcmlwdG9yPFQgPSBhbnk+KFxuICBwcm9wczogYW55LFxuICBzdXBwbGllcjogUGFuZWxPcHRpb25zU3VwcGxpZXI8VD5cbik6IE9wdGlvbnNQYW5lQ2F0ZWdvcnlEZXNjcmlwdG9yIHtcbiAgY29uc3QgY29udGV4dDogU3RhbmRhcmRFZGl0b3JDb250ZXh0PHVua25vd24sIHVua25vd24+ID0ge1xuICAgIGRhdGE6IHByb3BzLmlucHV0LFxuICAgIG9wdGlvbnM6IHByb3BzLm9wdGlvbnMsXG4gIH07XG5cbiAgY29uc3Qgcm9vdCA9IG5ldyBPcHRpb25zUGFuZUNhdGVnb3J5RGVzY3JpcHRvcih7IGlkOiAncm9vdCcsIHRpdGxlOiAncm9vdCcgfSk7XG4gIGNvbnN0IGdldE9wdGlvbnNQYW5lQ2F0ZWdvcnkgPSAoY2F0ZWdvcnlOYW1lcz86IHN0cmluZ1tdKTogT3B0aW9uc1BhbmVDYXRlZ29yeURlc2NyaXB0b3IgPT4ge1xuICAgIGlmIChjYXRlZ29yeU5hbWVzPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGtleSA9IGNhdGVnb3J5TmFtZXNbMF07XG4gICAgICBsZXQgc3ViID0gcm9vdC5jYXRlZ29yaWVzLmZpbmQoKHYpID0+IHYucHJvcHMuaWQgPT09IGtleSk7XG4gICAgICBpZiAoIXN1Yikge1xuICAgICAgICBzdWIgPSBuZXcgT3B0aW9uc1BhbmVDYXRlZ29yeURlc2NyaXB0b3IoeyBpZDoga2V5LCB0aXRsZToga2V5IH0pO1xuICAgICAgICByb290LmNhdGVnb3JpZXMucHVzaChzdWIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH07XG5cbiAgY29uc3QgYWNjZXNzOiBOZXN0ZWRWYWx1ZUFjY2VzcyA9IHtcbiAgICBnZXRWYWx1ZTogKHBhdGg6IHN0cmluZykgPT4gbG9kYXNoR2V0KHByb3BzLm9wdGlvbnMsIHBhdGgpLFxuICAgIG9uQ2hhbmdlOiAocGF0aDogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB7XG4gICAgICBwcm9wcy5vbkNoYW5nZShzZXRPcHRpb25JbW11dGFibHkocHJvcHMub3B0aW9ucyBhcyBhbnksIHBhdGgsIHZhbHVlKSk7XG4gICAgfSxcbiAgfTtcblxuICAvLyBVc2UgdGhlIHBhbmVsIG9wdGlvbnMgbG9hZGVyXG4gIGZpbGxPcHRpb25zUGFuZUl0ZW1zKHN1cHBsaWVyLCBhY2Nlc3MsIGdldE9wdGlvbnNQYW5lQ2F0ZWdvcnksIGNvbnRleHQpO1xuICByZXR1cm4gcm9vdDtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBGQywgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEFwcEV2ZW50cywgU3RhbmRhcmRFZGl0b3JQcm9wcywgU3RhbmRhcmRFZGl0b3JzUmVnaXN0cnlJdGVtLCBTdHJpbmdGaWVsZENvbmZpZ1NldHRpbmdzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBjb25maWcsIGdldEJhY2tlbmRTcnYgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCB7IEJ1dHRvbiwgSW5saW5lRmllbGQsIElubGluZUZpZWxkUm93LCBKU09ORm9ybWF0dGVyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgU3RyaW5nVmFsdWVFZGl0b3IgfSBmcm9tICdhcHAvY29yZS9jb21wb25lbnRzL09wdGlvbnNVSS9zdHJpbmcnO1xuaW1wb3J0IHsgYXBwRXZlbnRzIH0gZnJvbSAnYXBwL2NvcmUvY29yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQVBJRWRpdG9yQ29uZmlnIHtcbiAgZW5kcG9pbnQ6IHN0cmluZztcbiAgZGF0YT86IHN0cmluZztcbn1cblxuY29uc3QgZHVtbXlTdHJpbmdTZXR0aW5nczogU3RhbmRhcmRFZGl0b3JzUmVnaXN0cnlJdGVtPHN0cmluZywgU3RyaW5nRmllbGRDb25maWdTZXR0aW5ncz4gPSB7XG4gIHNldHRpbmdzOiB7fSxcbn0gYXMgYW55O1xuXG5leHBvcnQgY29uc3QgY2FsbEFwaSA9IChhcGk6IEFQSUVkaXRvckNvbmZpZywgaXNUZXN0ID0gZmFsc2UpID0+IHtcbiAgaWYgKGFwaSkge1xuICAgIGdldEJhY2tlbmRTcnYoKVxuICAgICAgLmZldGNoKHtcbiAgICAgICAgdXJsOiBhcGkuZW5kcG9pbnQhLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgZGF0YTogYXBpLmRhdGEgPz8ge30sXG4gICAgICB9KVxuICAgICAgLnN1YnNjcmliZSh7XG4gICAgICAgIGVycm9yOiAoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgICAgIGlmIChpc1Rlc3QpIHtcbiAgICAgICAgICAgIGFwcEV2ZW50cy5lbWl0KEFwcEV2ZW50cy5hbGVydEVycm9yLCBbJ0Vycm9yIGhhcyBvY2N1cnJlZDogJywgSlNPTi5zdHJpbmdpZnkoZXJyb3IpXSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzVGVzdCkge1xuICAgICAgICAgICAgYXBwRXZlbnRzLmVtaXQoQXBwRXZlbnRzLmFsZXJ0U3VjY2VzcywgWydUZXN0IHN1Y2Nlc3NmdWwnXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBBUElFZGl0b3I6IEZDPFN0YW5kYXJkRWRpdG9yUHJvcHM8QVBJRWRpdG9yQ29uZmlnLCBhbnksIGFueT4+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgdmFsdWUsIGNvbnRleHQsIG9uQ2hhbmdlIH0gPSBwcm9wcztcbiAgY29uc3QgbGFiZWxXaWR0aCA9IDk7XG5cbiAgY29uc3Qgb25FbmRwb2ludENoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIChlbmRwb2ludCkgPT4ge1xuICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgZW5kcG9pbnQsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtvbkNoYW5nZSwgdmFsdWVdXG4gICk7XG5cbiAgY29uc3Qgb25EYXRhQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgKGRhdGEpID0+IHtcbiAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIGRhdGEsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtvbkNoYW5nZSwgdmFsdWVdXG4gICk7XG5cbiAgY29uc3QgcmVuZGVySlNPTiA9IChkYXRhOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICByZXR1cm4gPEpTT05Gb3JtYXR0ZXIganNvbj17anNvbn0gLz47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBgSW52YWxpZCBKU09OIHByb3ZpZGVkOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnSW52YWxpZCBKU09OIHByb3ZpZGVkJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVuZGVyVGVzdEFQSUJ1dHRvbiA9IChhcGk6IEFQSUVkaXRvckNvbmZpZykgPT4ge1xuICAgIGlmIChhcGkgJiYgYXBpLmVuZHBvaW50KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9eygpID0+IGNhbGxBcGkoYXBpLCB0cnVlKX0gdGl0bGU9eydUZXN0IEFQSSd9PlxuICAgICAgICAgIFRlc3QgQVBJXG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgcmV0dXJuIGNvbmZpZy5kaXNhYmxlU2FuaXRpemVIdG1sID8gKFxuICAgIDw+XG4gICAgICA8SW5saW5lRmllbGRSb3c+XG4gICAgICAgIDxJbmxpbmVGaWVsZCBsYWJlbD17J0VuZHBvaW50J30gbGFiZWxXaWR0aD17bGFiZWxXaWR0aH0gZ3Jvdz17dHJ1ZX0+XG4gICAgICAgICAgPFN0cmluZ1ZhbHVlRWRpdG9yXG4gICAgICAgICAgICBjb250ZXh0PXtjb250ZXh0fVxuICAgICAgICAgICAgdmFsdWU9e3ZhbHVlPy5lbmRwb2ludH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkVuZHBvaW50Q2hhbmdlfVxuICAgICAgICAgICAgaXRlbT17ZHVtbXlTdHJpbmdTZXR0aW5nc31cbiAgICAgICAgICAvPlxuICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgPC9JbmxpbmVGaWVsZFJvdz5cbiAgICAgIDxJbmxpbmVGaWVsZFJvdz5cbiAgICAgICAgPElubGluZUZpZWxkIGxhYmVsPXsnRGF0YSd9IGxhYmVsV2lkdGg9e2xhYmVsV2lkdGh9IGdyb3c9e3RydWV9PlxuICAgICAgICAgIDxTdHJpbmdWYWx1ZUVkaXRvclxuICAgICAgICAgICAgY29udGV4dD17Y29udGV4dH1cbiAgICAgICAgICAgIHZhbHVlPXt2YWx1ZT8uZGF0YSA/PyAne30nfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uRGF0YUNoYW5nZX1cbiAgICAgICAgICAgIGl0ZW09e2R1bW15U3RyaW5nU2V0dGluZ3N9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9JbmxpbmVGaWVsZD5cbiAgICAgIDwvSW5saW5lRmllbGRSb3c+XG4gICAgICB7cmVuZGVyVGVzdEFQSUJ1dHRvbih2YWx1ZSl9XG4gICAgICA8YnIgLz5cbiAgICAgIHtyZW5kZXJKU09OKHZhbHVlPy5kYXRhID8/ICd7fScpfVxuICAgIDwvPlxuICApIDogKFxuICAgIDw+TXVzdCBlbmFibGUgZGlzYWJsZVNhbml0aXplSHRtbCBmZWF0dXJlIGZsYWcgdG8gYWNjZXNzPC8+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBDb25zdHJhaW50LCBIb3Jpem9udGFsQ29uc3RyYWludCwgVmVydGljYWxDb25zdHJhaW50IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcyc7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gIG9uVmVydGljYWxDb25zdHJhaW50Q2hhbmdlOiAodjogVmVydGljYWxDb25zdHJhaW50KSA9PiB2b2lkO1xuICBvbkhvcml6b250YWxDb25zdHJhaW50Q2hhbmdlOiAoaDogSG9yaXpvbnRhbENvbnN0cmFpbnQpID0+IHZvaWQ7XG4gIGN1cnJlbnRDb25zdHJhaW50czogQ29uc3RyYWludDtcbn1cblxuZXhwb3J0IGNvbnN0IENvbnN0cmFpbnRTZWxlY3Rpb25Cb3ggPSAoe1xuICBvblZlcnRpY2FsQ29uc3RyYWludENoYW5nZSxcbiAgb25Ib3Jpem9udGFsQ29uc3RyYWludENoYW5nZSxcbiAgY3VycmVudENvbnN0cmFpbnRzLFxufTogUHJvcHMpID0+IHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMoY3VycmVudENvbnN0cmFpbnRzKSk7XG5cbiAgY29uc3Qgb25DbGlja1RvcENvbnN0cmFpbnQgPSAoKSA9PiB7XG4gICAgb25WZXJ0aWNhbENvbnN0cmFpbnRDaGFuZ2UoVmVydGljYWxDb25zdHJhaW50LlRvcCk7XG4gIH07XG5cbiAgY29uc3Qgb25DbGlja0JvdHRvbUNvbnN0cmFpbnQgPSAoKSA9PiB7XG4gICAgb25WZXJ0aWNhbENvbnN0cmFpbnRDaGFuZ2UoVmVydGljYWxDb25zdHJhaW50LkJvdHRvbSk7XG4gIH07XG5cbiAgY29uc3Qgb25DbGlja1ZlcnRpY2FsQ2VudGVyQ29uc3RyYWludCA9ICgpID0+IHtcbiAgICBvblZlcnRpY2FsQ29uc3RyYWludENoYW5nZShWZXJ0aWNhbENvbnN0cmFpbnQuQ2VudGVyKTtcbiAgfTtcblxuICBjb25zdCBvbkNsaWNrTGVmdENvbnN0cmFpbnQgPSAoKSA9PiB7XG4gICAgb25Ib3Jpem9udGFsQ29uc3RyYWludENoYW5nZShIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0KTtcbiAgfTtcblxuICBjb25zdCBvbkNsaWNrUmlnaHRDb25zdHJhaW50ID0gKCkgPT4ge1xuICAgIG9uSG9yaXpvbnRhbENvbnN0cmFpbnRDaGFuZ2UoSG9yaXpvbnRhbENvbnN0cmFpbnQuUmlnaHQpO1xuICB9O1xuXG4gIGNvbnN0IG9uQ2xpY2tIb3Jpem9udGFsQ2VudGVyQ29uc3RyYWludCA9ICgpID0+IHtcbiAgICBvbkhvcml6b250YWxDb25zdHJhaW50Q2hhbmdlKEhvcml6b250YWxDb25zdHJhaW50LkNlbnRlcik7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICB2ZXJzaW9uPVwiMS4wXCJcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgd2lkdGg9XCI3NS4wMDAwMDBwdFwiXG4gICAgICBoZWlnaHQ9XCI3NS4wMDAwMDBwdFwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDIyOC4wMDAwMDAgMjI4LjAwMDAwMFwiXG4gICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiXG4gICAgICBzdHlsZT17eyBtYXJnaW5Cb3R0b206ICc0LjhweCcgfX1cbiAgICA+XG4gICAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMC4wMDAwMDAsMjI4LjAwMDAwMCkgc2NhbGUoMC4xMDAwMDAsLTAuMTAwMDAwKVwiIGZpbGw9XCIjMDAwMDAwXCIgc3Ryb2tlPVwibm9uZVwiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGZpbGw9XCIjZTVlNWU1XCJcbiAgICAgICAgICBkPVwiTTE5OCAyMDI4IGwtMjggLTMyIDAgLTkxMiAwIC05MTIgMzEgLTMxIDMxIC0zMSA5MTUgMCA5MTUgMCAyOSAyOVxuMjkgMjkgMCA5MTcgMCA5MTcgLTI3IDI5IC0yOCAyOSAtOTIwIDAgLTkyMCAwIC0yNyAtMzJ6IG0xODc2IC0xNyBjMTUgLTE2IDE2XG4tOTggMTYgLTkyNyAwIC04NjAgLTEgLTkwOSAtMTggLTkyNiAtMTcgLTE3IC02NiAtMTggLTkyNyAtMTggLTg2MiAwIC05MTAgMVxuLTkyNyAxOCAtMTcgMTcgLTE4IDY1IC0xOCA5MjYgMCA4MzIgMSA5MTEgMTYgOTI3IDE2IDE4IDQ1IDE5IDQ2OCAyMSAyNDggMlxuNjU5IDIgOTEyIDAgNDMxIC0yIDQ2MiAtNCA0NzggLTIxelwiXG4gICAgICAgIC8+XG4gICAgICAgIDxyZWN0IGNsYXNzTmFtZT17c3R5bGVzLnRvcENvbnN0cmFpbnR9IGhlaWdodD1cIjIyOFwiIHdpZHRoPVwiNDZcIiB5PVwiMTczNVwiIHg9XCIxMTIzXCIgLz5cbiAgICAgICAgPHJlY3RcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5jb25zdHJhaW50SG92ZXJ9XG4gICAgICAgICAgb25DbGljaz17b25DbGlja1RvcENvbnN0cmFpbnR9XG4gICAgICAgICAgaGVpZ2h0PVwiMzUwXCJcbiAgICAgICAgICB3aWR0aD1cIjMwMFwiXG4gICAgICAgICAgeT1cIjE2ODBcIlxuICAgICAgICAgIHg9XCI5OTVcIlxuICAgICAgICAgIGZpbGw9XCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxyZWN0IGNsYXNzTmFtZT17c3R5bGVzLmJvdHRvbUNvbnN0cmFpbnR9IGhlaWdodD1cIjIyOFwiIHdpZHRoPVwiNDZcIiB5PVwiMjEwXCIgeD1cIjExMjNcIiAvPlxuICAgICAgICA8cmVjdFxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNvbnN0cmFpbnRIb3Zlcn1cbiAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrQm90dG9tQ29uc3RyYWludH1cbiAgICAgICAgICBoZWlnaHQ9XCIzNTBcIlxuICAgICAgICAgIHdpZHRoPVwiMzAwXCJcbiAgICAgICAgICB5PVwiMTM1XCJcbiAgICAgICAgICB4PVwiOTk1XCJcbiAgICAgICAgICBmaWxsPVwidHJhbnNwYXJlbnRcIlxuICAgICAgICAvPlxuICAgICAgICA8cmVjdCBjbGFzc05hbWU9e3N0eWxlcy5sZWZ0Q29uc3RyYWludH0gaGVpZ2h0PVwiNDZcIiB3aWR0aD1cIjIyOFwiIHk9XCIxMDYwXCIgeD1cIjI2NVwiIC8+XG4gICAgICAgIDxyZWN0XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuY29uc3RyYWludEhvdmVyfVxuICAgICAgICAgIG9uQ2xpY2s9e29uQ2xpY2tMZWZ0Q29uc3RyYWludH1cbiAgICAgICAgICBoZWlnaHQ9XCIzMDBcIlxuICAgICAgICAgIHdpZHRoPVwiMzUwXCJcbiAgICAgICAgICB5PVwiOTI1XCJcbiAgICAgICAgICB4PVwiMjAwXCJcbiAgICAgICAgICBmaWxsPVwidHJhbnNwYXJlbnRcIlxuICAgICAgICAvPlxuICAgICAgICA8cmVjdCBjbGFzc05hbWU9e3N0eWxlcy5yaWdodENvbnN0cmFpbnR9IGhlaWdodD1cIjQ2XCIgd2lkdGg9XCIyMjhcIiB5PVwiMTA2MFwiIHg9XCIxNzk1XCIgLz5cbiAgICAgICAgPHJlY3RcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5jb25zdHJhaW50SG92ZXJ9XG4gICAgICAgICAgb25DbGljaz17b25DbGlja1JpZ2h0Q29uc3RyYWludH1cbiAgICAgICAgICBoZWlnaHQ9XCIzMDBcIlxuICAgICAgICAgIHdpZHRoPVwiMzUwXCJcbiAgICAgICAgICB5PVwiOTI1XCJcbiAgICAgICAgICB4PVwiMTczMFwiXG4gICAgICAgICAgZmlsbD1cInRyYW5zcGFyZW50XCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5ib3h9XG4gICAgICAgICAgZD1cIk01NjggMTY2OSBjLTE3IC05IC0xOCAtNDggLTE4IC01ODQgMCAtNTU4IDEgLTU3NSAxOSAtNTg1IDI3IC0xNFxuMTEyNSAtMTQgMTE1MiAwIDE4IDEwIDE5IDI3IDE5IDU4MCAwIDUwNCAtMiA1NzAgLTE2IDU4NCAtMTQgMTQgLTgwIDE2IC01NzdcbjE2IC0zNjMgLTEgLTU2OCAtNCAtNTc5IC0xMXogbTExMTkgLTQyIGM0IC01IDQgLTEwNzkgMCAtMTA4NCAtNSAtNCAtMTA3OSAtNFxuLTEwODQgMCAtNSA2IC00IDEwNzcgMSAxMDg1IDQgNyAxMDc2IDYgMTA4MyAtMXpcIlxuICAgICAgICAvPlxuICAgICAgICA8cmVjdCBjbGFzc05hbWU9e3N0eWxlcy52ZXJ0aWNhbENlbnRlckNvbnN0cmFpbnR9IGhlaWdodD1cIjQ1NlwiIHdpZHRoPVwiNDZcIiB5PVwiODU1XCIgeD1cIjExMjNcIiAvPlxuICAgICAgICA8cmVjdFxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNvbnN0cmFpbnRIb3Zlcn1cbiAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrVmVydGljYWxDZW50ZXJDb25zdHJhaW50fVxuICAgICAgICAgIGhlaWdodD1cIjY2MFwiXG4gICAgICAgICAgd2lkdGg9XCIzMDBcIlxuICAgICAgICAgIHk9XCI3NTBcIlxuICAgICAgICAgIHg9XCI5OTVcIlxuICAgICAgICAgIGZpbGw9XCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxyZWN0IGNsYXNzTmFtZT17c3R5bGVzLmhvcml6b250YWxDZW50ZXJDb25zdHJhaW50fSBoZWlnaHQ9XCI0NlwiIHdpZHRoPVwiNDU2XCIgeT1cIjEwNjBcIiB4PVwiOTE4XCIgLz5cbiAgICAgICAgPHJlY3RcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5jb25zdHJhaW50SG92ZXJ9XG4gICAgICAgICAgb25DbGljaz17b25DbGlja0hvcml6b250YWxDZW50ZXJDb25zdHJhaW50fVxuICAgICAgICAgIGhlaWdodD1cIjMwMFwiXG4gICAgICAgICAgd2lkdGg9XCI2NjBcIlxuICAgICAgICAgIHk9XCI5MjVcIlxuICAgICAgICAgIHg9XCI4MTVcIlxuICAgICAgICAgIGZpbGw9XCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuXG5jb25zdCBnZXRTdHlsZXMgPSAoY3VycmVudENvbnN0cmFpbnRzOiBDb25zdHJhaW50KSA9PiAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgY29uc3QgSE9WRVJfQ09MT1IgPSAnI2RhZWJmNyc7XG4gIGNvbnN0IEhPVkVSX09QQUNJVFkgPSAnMC42JztcbiAgY29uc3QgU0VMRUNURURfQ09MT1IgPSAnIzBkOTlmZic7XG5cbiAgY29uc3Qgc2VsZWN0aW9uQm94Q29sb3IgPSB0aGVtZS5pc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCc7XG5cbiAgcmV0dXJuIHtcbiAgICBjb25zdHJhaW50SG92ZXI6IGNzc2BcbiAgICAgICY6aG92ZXIge1xuICAgICAgICBmaWxsOiAke0hPVkVSX0NPTE9SfTtcbiAgICAgICAgZmlsbC1vcGFjaXR5OiAke0hPVkVSX09QQUNJVFl9O1xuICAgICAgfVxuICAgIGAsXG4gICAgdG9wQ29uc3RyYWludDogY3NzYFxuICAgICAgJHtjdXJyZW50Q29uc3RyYWludHMudmVydGljYWwgPT09IFZlcnRpY2FsQ29uc3RyYWludC5Ub3AgfHxcbiAgICAgIGN1cnJlbnRDb25zdHJhaW50cy52ZXJ0aWNhbCA9PT0gVmVydGljYWxDb25zdHJhaW50LlRvcEJvdHRvbVxuICAgICAgICA/IGB3aWR0aDogOTJwdDsgeDogMTA4NTsgZmlsbDogJHtTRUxFQ1RFRF9DT0xPUn07YFxuICAgICAgICA6IGBmaWxsOiAke3NlbGVjdGlvbkJveENvbG9yfTtgfVxuICAgIGAsXG4gICAgYm90dG9tQ29uc3RyYWludDogY3NzYFxuICAgICAgJHtjdXJyZW50Q29uc3RyYWludHMudmVydGljYWwgPT09IFZlcnRpY2FsQ29uc3RyYWludC5Cb3R0b20gfHxcbiAgICAgIGN1cnJlbnRDb25zdHJhaW50cy52ZXJ0aWNhbCA9PT0gVmVydGljYWxDb25zdHJhaW50LlRvcEJvdHRvbVxuICAgICAgICA/IGB3aWR0aDogOTJwdDsgeDogMTA4NTsgZmlsbDogJHtTRUxFQ1RFRF9DT0xPUn07YFxuICAgICAgICA6IGBmaWxsOiAke3NlbGVjdGlvbkJveENvbG9yfTtgfVxuICAgIGAsXG4gICAgbGVmdENvbnN0cmFpbnQ6IGNzc2BcbiAgICAgICR7Y3VycmVudENvbnN0cmFpbnRzLmhvcml6b250YWwgPT09IEhvcml6b250YWxDb25zdHJhaW50LkxlZnQgfHxcbiAgICAgIGN1cnJlbnRDb25zdHJhaW50cy5ob3Jpem9udGFsID09PSBIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0UmlnaHRcbiAgICAgICAgPyBgaGVpZ2h0OiA5MnB0OyB5OiAxMDE0OyBmaWxsOiAke1NFTEVDVEVEX0NPTE9SfTtgXG4gICAgICAgIDogYGZpbGw6ICR7c2VsZWN0aW9uQm94Q29sb3J9O2B9XG4gICAgYCxcbiAgICByaWdodENvbnN0cmFpbnQ6IGNzc2BcbiAgICAgICR7Y3VycmVudENvbnN0cmFpbnRzLmhvcml6b250YWwgPT09IEhvcml6b250YWxDb25zdHJhaW50LlJpZ2h0IHx8XG4gICAgICBjdXJyZW50Q29uc3RyYWludHMuaG9yaXpvbnRhbCA9PT0gSG9yaXpvbnRhbENvbnN0cmFpbnQuTGVmdFJpZ2h0XG4gICAgICAgID8gYGhlaWdodDogOTJwdDsgeTogMTAxNDsgZmlsbDogJHtTRUxFQ1RFRF9DT0xPUn07YFxuICAgICAgICA6IGBmaWxsOiAke3NlbGVjdGlvbkJveENvbG9yfTtgfVxuICAgIGAsXG4gICAgaG9yaXpvbnRhbENlbnRlckNvbnN0cmFpbnQ6IGNzc2BcbiAgICAgICR7Y3VycmVudENvbnN0cmFpbnRzLmhvcml6b250YWwgPT09IEhvcml6b250YWxDb25zdHJhaW50LkNlbnRlclxuICAgICAgICA/IGBoZWlnaHQ6IDkycHQ7IHk6IDEwMTQ7IGZpbGw6ICR7U0VMRUNURURfQ09MT1J9O2BcbiAgICAgICAgOiBgZmlsbDogJHtzZWxlY3Rpb25Cb3hDb2xvcn07YH1cbiAgICBgLFxuICAgIHZlcnRpY2FsQ2VudGVyQ29uc3RyYWludDogY3NzYFxuICAgICAgJHtjdXJyZW50Q29uc3RyYWludHMudmVydGljYWwgPT09IFZlcnRpY2FsQ29uc3RyYWludC5DZW50ZXJcbiAgICAgICAgPyBgd2lkdGg6IDkycHQ7IHg6IDEwODU7IGZpbGw6ICR7U0VMRUNURURfQ09MT1J9O2BcbiAgICAgICAgOiBgZmlsbDogJHtzZWxlY3Rpb25Cb3hDb2xvcn07YH1cbiAgICBgLFxuICAgIGJveDogY3NzYFxuICAgICAgZmlsbDogJHtzZWxlY3Rpb25Cb3hDb2xvcn07XG4gICAgYCxcbiAgfTtcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERyb3BSZXN1bHQgfSBmcm9tICdyZWFjdC1iZWF1dGlmdWwtZG5kJztcblxuaW1wb3J0IHsgQXBwRXZlbnRzLCBTZWxlY3RhYmxlVmFsdWUsIFN0YW5kYXJkRWRpdG9yUHJvcHMgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUvc3JjJztcbmltcG9ydCB7IEJ1dHRvbiwgSG9yaXpvbnRhbEdyb3VwIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IGFwcEV2ZW50cyBmcm9tICdhcHAvY29yZS9hcHBfZXZlbnRzJztcbmltcG9ydCB7IEFkZExheWVyQnV0dG9uIH0gZnJvbSAnYXBwL2NvcmUvY29tcG9uZW50cy9MYXllcnMvQWRkTGF5ZXJCdXR0b24nO1xuaW1wb3J0IHsgTGF5ZXJEcmFnRHJvcExpc3QgfSBmcm9tICdhcHAvY29yZS9jb21wb25lbnRzL0xheWVycy9MYXllckRyYWdEcm9wTGlzdCc7XG5pbXBvcnQgeyBDYW52YXNFbGVtZW50T3B0aW9ucywgY2FudmFzRWxlbWVudFJlZ2lzdHJ5IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcyc7XG5pbXBvcnQgeyBub3RGb3VuZEl0ZW0gfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL25vdEZvdW5kJztcbmltcG9ydCB7IEVsZW1lbnRTdGF0ZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9lbGVtZW50JztcbmltcG9ydCB7IEZyYW1lU3RhdGUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvZnJhbWUnO1xuaW1wb3J0IHsgU2VsZWN0aW9uUGFyYW1zIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL3NjZW5lJztcbmltcG9ydCB7IFNob3dDb25maXJtTW9kYWxFdmVudCB9IGZyb20gJ2FwcC90eXBlcy9ldmVudHMnO1xuXG5pbXBvcnQgeyBQYW5lbE9wdGlvbnMgfSBmcm9tICcuLi9tb2RlbHMuZ2VuJztcbmltcG9ydCB7IExheWVyQWN0aW9uSUQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IExheWVyRWRpdG9yUHJvcHMgfSBmcm9tICcuL2xheWVyRWRpdG9yJztcblxudHlwZSBQcm9wcyA9IFN0YW5kYXJkRWRpdG9yUHJvcHM8YW55LCBMYXllckVkaXRvclByb3BzLCBQYW5lbE9wdGlvbnM+O1xuXG5leHBvcnQgY2xhc3MgTGF5ZXJFbGVtZW50TGlzdEVkaXRvciBleHRlbmRzIFB1cmVDb21wb25lbnQ8UHJvcHM+IHtcbiAgZ2V0U2NlbmUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdGhpcy5wcm9wcy5pdGVtO1xuICAgIGlmICghc2V0dGluZ3M/LmxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBzZXR0aW5ncy5sYXllci5zY2VuZTtcbiAgfTtcblxuICBvbkFkZEl0ZW0gPSAoc2VsOiBTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPikgPT4ge1xuICAgIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHRoaXMucHJvcHMuaXRlbTtcbiAgICBpZiAoIXNldHRpbmdzPy5sYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGxheWVyIH0gPSBzZXR0aW5ncztcblxuICAgIGNvbnN0IGl0ZW0gPSBjYW52YXNFbGVtZW50UmVnaXN0cnkuZ2V0SWZFeGlzdHMoc2VsLnZhbHVlKSA/PyBub3RGb3VuZEl0ZW07XG4gICAgY29uc3QgbmV3RWxlbWVudE9wdGlvbnMgPSBpdGVtLmdldE5ld09wdGlvbnMoKSBhcyBDYW52YXNFbGVtZW50T3B0aW9ucztcbiAgICBuZXdFbGVtZW50T3B0aW9ucy50eXBlID0gaXRlbS5pZDtcbiAgICBjb25zdCBuZXdFbGVtZW50ID0gbmV3IEVsZW1lbnRTdGF0ZShpdGVtLCBuZXdFbGVtZW50T3B0aW9ucywgbGF5ZXIpO1xuICAgIG5ld0VsZW1lbnQudXBkYXRlRGF0YShsYXllci5zY2VuZS5jb250ZXh0KTtcbiAgICBsYXllci5lbGVtZW50cy5wdXNoKG5ld0VsZW1lbnQpO1xuICAgIGxheWVyLnNjZW5lLnNhdmUoKTtcblxuICAgIGxheWVyLnJlaW5pdGlhbGl6ZU1vdmVhYmxlKCk7XG4gIH07XG5cbiAgb25TZWxlY3QgPSAoaXRlbTogYW55KSA9PiB7XG4gICAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdGhpcy5wcm9wcy5pdGVtO1xuXG4gICAgaWYgKHNldHRpbmdzPy5zY2VuZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbjogU2VsZWN0aW9uUGFyYW1zID0geyB0YXJnZXRzOiBbXSB9O1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEZyYW1lU3RhdGUpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50czogSFRNTERpdkVsZW1lbnRbXSA9IFtdO1xuICAgICAgICAgIHRhcmdldEVsZW1lbnRzLnB1c2goaXRlbT8uZGl2ISk7XG4gICAgICAgICAgc2VsZWN0aW9uLnRhcmdldHMgPSB0YXJnZXRFbGVtZW50cztcbiAgICAgICAgICBzZWxlY3Rpb24uZnJhbWUgPSBpdGVtO1xuICAgICAgICAgIHNldHRpbmdzLnNjZW5lLnNlbGVjdChzZWxlY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFbGVtZW50U3RhdGUpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gW2l0ZW0/LmRpdiFdO1xuICAgICAgICAgIHNlbGVjdGlvbi50YXJnZXRzID0gdGFyZ2V0RWxlbWVudDtcbiAgICAgICAgICBzZXR0aW5ncy5zY2VuZS5zZWxlY3Qoc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXBwRXZlbnRzLmVtaXQoQXBwRXZlbnRzLmFsZXJ0RXJyb3IsIFsnVW5hYmxlIHRvIHNlbGVjdCBlbGVtZW50LCB0cnkgc2VsZWN0aW5nIGVsZW1lbnQgaW4gcGFuZWwgaW5zdGVhZCddKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgb25DbGVhclNlbGVjdGlvbiA9ICgpID0+IHtcbiAgICBjb25zdCB7IHNldHRpbmdzIH0gPSB0aGlzLnByb3BzLml0ZW07XG5cbiAgICBpZiAoIXNldHRpbmdzPy5sYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNldHRpbmdzO1xuXG4gICAgbGF5ZXIuc2NlbmUuY2xlYXJDdXJyZW50U2VsZWN0aW9uKCk7XG4gIH07XG5cbiAgb25EcmFnRW5kID0gKHJlc3VsdDogRHJvcFJlc3VsdCkgPT4ge1xuICAgIGlmICghcmVzdWx0LmRlc3RpbmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdGhpcy5wcm9wcy5pdGVtO1xuICAgIGlmICghc2V0dGluZ3M/LmxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBsYXllciB9ID0gc2V0dGluZ3M7XG5cbiAgICBjb25zdCBjb3VudCA9IGxheWVyLmVsZW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgY29uc3Qgc3JjID0gKHJlc3VsdC5zb3VyY2UuaW5kZXggLSBjb3VudCkgKiAtMTtcbiAgICBjb25zdCBkc3QgPSAocmVzdWx0LmRlc3RpbmF0aW9uLmluZGV4IC0gY291bnQpICogLTE7XG5cbiAgICBsYXllci5yZW9yZGVyKHNyYywgZHN0KTtcbiAgfTtcblxuICBnb1VwTGF5ZXIgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnByb3BzLml0ZW0uc2V0dGluZ3M7XG5cbiAgICBpZiAoIXNldHRpbmdzPy5sYXllciB8fCAhc2V0dGluZ3M/LnNjZW5lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBzY2VuZSwgbGF5ZXIgfSA9IHNldHRpbmdzO1xuXG4gICAgaWYgKGxheWVyLnBhcmVudCkge1xuICAgICAgc2NlbmUudXBkYXRlQ3VycmVudExheWVyKGxheWVyLnBhcmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgZGVjb3VwbGVGcmFtZSA9ICgpID0+IHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMucHJvcHMuaXRlbS5zZXR0aW5ncztcblxuICAgIGlmICghc2V0dGluZ3M/LmxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBsYXllciB9ID0gc2V0dGluZ3M7XG5cbiAgICB0aGlzLmRlbGV0ZUZyYW1lKCk7XG4gICAgbGF5ZXIuZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudDogRWxlbWVudFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50Q29udGFpbmVyID0gZWxlbWVudC5kaXY/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZWxlbWVudC5zZXRQbGFjZW1lbnRGcm9tQ29uc3RyYWludChlbGVtZW50Q29udGFpbmVyLCBsYXllci5wYXJlbnQ/LmRpdj8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgbGF5ZXIucGFyZW50Py5kb0FjdGlvbihMYXllckFjdGlvbklELkR1cGxpY2F0ZSwgZWxlbWVudCwgZmFsc2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgfTtcblxuICBwcml2YXRlIG9uRGVjb3VwbGVGcmFtZSA9ICgpID0+IHtcbiAgICBhcHBFdmVudHMucHVibGlzaChcbiAgICAgIG5ldyBTaG93Q29uZmlybU1vZGFsRXZlbnQoe1xuICAgICAgICB0aXRsZTogJ0RlY291cGxlIGZyYW1lJyxcbiAgICAgICAgdGV4dDogYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWNvdXBsZSB0aGlzIGZyYW1lP2AsXG4gICAgICAgIHRleHQyOiAnVGhpcyB3aWxsIHJlbW92ZSB0aGUgZnJhbWUgYW5kIHB1c2ggbmVzdGVkIGVsZW1lbnRzIGluIHRoZSBuZXh0IGxldmVsIHVwLicsXG4gICAgICAgIGNvbmZpcm1UZXh0OiAnWWVzJyxcbiAgICAgICAgeWVzVGV4dDogJ0RlY291cGxlJyxcbiAgICAgICAgb25Db25maXJtOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kZWNvdXBsZUZyYW1lKCk7XG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICk7XG4gIH07XG5cbiAgcHJpdmF0ZSBkZWxldGVGcmFtZSA9ICgpID0+IHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMucHJvcHMuaXRlbS5zZXR0aW5ncztcblxuICAgIGlmICghc2V0dGluZ3M/LmxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBsYXllciB9ID0gc2V0dGluZ3M7XG5cbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoKTtcbiAgICBzY2VuZT8uYnlOYW1lLmRlbGV0ZShsYXllci5nZXROYW1lKCkpO1xuICAgIGxheWVyLmVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHNjZW5lPy5ieU5hbWUuZGVsZXRlKGVsZW1lbnQuZ2V0TmFtZSgpKSk7XG4gICAgbGF5ZXIucGFyZW50Py5kb0FjdGlvbihMYXllckFjdGlvbklELkRlbGV0ZSwgbGF5ZXIpO1xuXG4gICAgdGhpcy5nb1VwTGF5ZXIoKTtcbiAgfTtcblxuICBwcml2YXRlIG9uRnJhbWVTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLmdldFNjZW5lKCk7XG4gICAgaWYgKHNjZW5lKSB7XG4gICAgICBzY2VuZS5mcmFtZVNlbGVjdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ25vIHNjZW5lIScpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIG9uRGVsZXRlRnJhbWUgPSAoKSA9PiB7XG4gICAgYXBwRXZlbnRzLnB1Ymxpc2goXG4gICAgICBuZXcgU2hvd0NvbmZpcm1Nb2RhbEV2ZW50KHtcbiAgICAgICAgdGl0bGU6ICdEZWxldGUgZnJhbWUnLFxuICAgICAgICB0ZXh0OiBgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB0aGlzIGZyYW1lP2AsXG4gICAgICAgIHRleHQyOiAnVGhpcyB3aWxsIGRlbGV0ZSB0aGUgZnJhbWUgYW5kIGFsbCBuZXN0ZWQgZWxlbWVudHMuJyxcbiAgICAgICAgaWNvbjogJ3RyYXNoLWFsdCcsXG4gICAgICAgIGNvbmZpcm1UZXh0OiAnRGVsZXRlJyxcbiAgICAgICAgeWVzVGV4dDogJ0RlbGV0ZScsXG4gICAgICAgIG9uQ29uZmlybTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGVsZXRlRnJhbWUoKTtcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnByb3BzLml0ZW0uc2V0dGluZ3M7XG4gICAgaWYgKCFzZXR0aW5ncykge1xuICAgICAgcmV0dXJuIDxkaXY+Tm8gc2V0dGluZ3M8L2Rpdj47XG4gICAgfVxuICAgIGNvbnN0IGxheWVyID0gc2V0dGluZ3MubGF5ZXI7XG4gICAgaWYgKCFsYXllcikge1xuICAgICAgcmV0dXJuIDxkaXY+TWlzc2luZyBsYXllcj88L2Rpdj47XG4gICAgfVxuXG4gICAgY29uc3Qgb25EZWxldGUgPSAoZWxlbWVudDogRWxlbWVudFN0YXRlKSA9PiB7XG4gICAgICBsYXllci5kb0FjdGlvbihMYXllckFjdGlvbklELkRlbGV0ZSwgZWxlbWVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uRHVwbGljYXRlID0gKGVsZW1lbnQ6IEVsZW1lbnRTdGF0ZSkgPT4ge1xuICAgICAgbGF5ZXIuZG9BY3Rpb24oTGF5ZXJBY3Rpb25JRC5EdXBsaWNhdGUsIGVsZW1lbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRMYXllckluZm8gPSAoZWxlbWVudDogRWxlbWVudFN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gZWxlbWVudC5vcHRpb25zLnR5cGU7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTmFtZUNoYW5nZSA9IChlbGVtZW50OiBFbGVtZW50U3RhdGUsIG5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgZWxlbWVudC5vbkNoYW5nZSh7IC4uLmVsZW1lbnQub3B0aW9ucywgbmFtZSB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2hvd0FjdGlvbnMgPSAoZWxlbWVudDogRWxlbWVudFN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gIShlbGVtZW50IGluc3RhbmNlb2YgRnJhbWVTdGF0ZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3MgPSAobmFtZVRvVmVyaWZ5OiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5nZXRTY2VuZSgpO1xuXG4gICAgICByZXR1cm4gQm9vbGVhbihzY2VuZT8uY2FuUmVuYW1lKG5hbWVUb1ZlcmlmeSkpO1xuICAgIH07XG5cbiAgICBjb25zdCBzZWxlY3Rpb246IHN0cmluZ1tdID0gc2V0dGluZ3Muc2VsZWN0ZWQgPyBzZXR0aW5ncy5zZWxlY3RlZC5tYXAoKHYpID0+IHYuZ2V0TmFtZSgpKSA6IFtdO1xuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICB7IWxheWVyLmlzUm9vdCgpICYmIChcbiAgICAgICAgICA8PlxuICAgICAgICAgICAgPEJ1dHRvbiBpY29uPVwiYW5nbGUtdXBcIiBzaXplPVwic21cIiB2YXJpYW50PVwic2Vjb25kYXJ5XCIgb25DbGljaz17dGhpcy5nb1VwTGF5ZXJ9PlxuICAgICAgICAgICAgICBHbyB1cCBsZXZlbFxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uIHNpemU9XCJzbVwiIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiBvbkNsaWNrPXsoKSA9PiB0aGlzLm9uU2VsZWN0KGxheWVyKX0+XG4gICAgICAgICAgICAgIFNlbGVjdCBmcmFtZVxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uIHNpemU9XCJzbVwiIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiBvbkNsaWNrPXsoKSA9PiB0aGlzLm9uRGVjb3VwbGVGcmFtZSgpfT5cbiAgICAgICAgICAgICAgRGVjb3VwbGUgZnJhbWVcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPEJ1dHRvbiBzaXplPVwic21cIiB2YXJpYW50PVwic2Vjb25kYXJ5XCIgb25DbGljaz17KCkgPT4gdGhpcy5vbkRlbGV0ZUZyYW1lKCl9PlxuICAgICAgICAgICAgICBEZWxldGUgZnJhbWVcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgICA8TGF5ZXJEcmFnRHJvcExpc3RcbiAgICAgICAgICBvbkRyYWdFbmQ9e3RoaXMub25EcmFnRW5kfVxuICAgICAgICAgIG9uU2VsZWN0PXt0aGlzLm9uU2VsZWN0fVxuICAgICAgICAgIG9uRGVsZXRlPXtvbkRlbGV0ZX1cbiAgICAgICAgICBvbkR1cGxpY2F0ZT17b25EdXBsaWNhdGV9XG4gICAgICAgICAgZ2V0TGF5ZXJJbmZvPXtnZXRMYXllckluZm99XG4gICAgICAgICAgb25OYW1lQ2hhbmdlPXtvbk5hbWVDaGFuZ2V9XG4gICAgICAgICAgdmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzcz17dmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzc31cbiAgICAgICAgICBzaG93QWN0aW9ucz17c2hvd0FjdGlvbnN9XG4gICAgICAgICAgbGF5ZXJzPXtsYXllci5lbGVtZW50c31cbiAgICAgICAgICBzZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgICAgLz5cbiAgICAgICAgPGJyIC8+XG5cbiAgICAgICAgPEhvcml6b250YWxHcm91cD5cbiAgICAgICAgICA8QWRkTGF5ZXJCdXR0b25cbiAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQWRkSXRlbX1cbiAgICAgICAgICAgIG9wdGlvbnM9e2NhbnZhc0VsZW1lbnRSZWdpc3RyeS5zZWxlY3RPcHRpb25zKCkub3B0aW9uc31cbiAgICAgICAgICAgIGxhYmVsPXsnQWRkIGl0ZW0nfVxuICAgICAgICAgIC8+XG4gICAgICAgICAge3NlbGVjdGlvbi5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgIDxCdXR0b24gc2l6ZT1cInNtXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9e3RoaXMub25DbGVhclNlbGVjdGlvbn0+XG4gICAgICAgICAgICAgIENsZWFyIHNlbGVjdGlvblxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgICB7c2VsZWN0aW9uLmxlbmd0aCA+IDEgJiYgY29uZmlnLmZlYXR1cmVUb2dnbGVzLmNhbnZhc1BhbmVsTmVzdGluZyAmJiAoXG4gICAgICAgICAgICA8QnV0dG9uIHNpemU9XCJzbVwiIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiBvbkNsaWNrPXt0aGlzLm9uRnJhbWVTZWxlY3Rpb259PlxuICAgICAgICAgICAgICBGcmFtZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvSG9yaXpvbnRhbEdyb3VwPlxuICAgICAgPC8+XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0LCB7IEZDIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlT2JzZXJ2YWJsZSB9IGZyb20gJ3JlYWN0LXVzZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSwgU3RhbmRhcmRFZGl0b3JQcm9wcyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRmllbGQsIEhvcml6b250YWxHcm91cCwgSW5saW5lRmllbGQsIElubGluZUZpZWxkUm93LCBTZWxlY3QsIFZlcnRpY2FsR3JvdXAgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBOdW1iZXJJbnB1dCB9IGZyb20gJ2FwcC9jb3JlL2NvbXBvbmVudHMvT3B0aW9uc1VJL051bWJlcklucHV0JztcbmltcG9ydCB7IEhvcml6b250YWxDb25zdHJhaW50LCBQbGFjZW1lbnQsIFZlcnRpY2FsQ29uc3RyYWludCB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMnO1xuXG5pbXBvcnQgeyBQYW5lbE9wdGlvbnMgfSBmcm9tICcuLi9tb2RlbHMuZ2VuJztcblxuaW1wb3J0IHsgQ29uc3RyYWludFNlbGVjdGlvbkJveCB9IGZyb20gJy4vQ29uc3RyYWludFNlbGVjdGlvbkJveCc7XG5pbXBvcnQgeyBRdWlja1Bvc2l0aW9uaW5nIH0gZnJvbSAnLi9RdWlja1Bvc2l0aW9uaW5nJztcbmltcG9ydCB7IENhbnZhc0VkaXRvck9wdGlvbnMgfSBmcm9tICcuL2VsZW1lbnRFZGl0b3InO1xuXG5jb25zdCBwbGFjZXM6IEFycmF5PGtleW9mIFBsYWNlbWVudD4gPSBbJ3RvcCcsICdsZWZ0JywgJ2JvdHRvbScsICdyaWdodCcsICd3aWR0aCcsICdoZWlnaHQnXTtcblxuY29uc3QgaG9yaXpvbnRhbE9wdGlvbnM6IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxIb3Jpem9udGFsQ29uc3RyYWludD4+ID0gW1xuICB7IGxhYmVsOiAnTGVmdCcsIHZhbHVlOiBIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0IH0sXG4gIHsgbGFiZWw6ICdSaWdodCcsIHZhbHVlOiBIb3Jpem9udGFsQ29uc3RyYWludC5SaWdodCB9LFxuICB7IGxhYmVsOiAnTGVmdCBhbmQgcmlnaHQnLCB2YWx1ZTogSG9yaXpvbnRhbENvbnN0cmFpbnQuTGVmdFJpZ2h0IH0sXG4gIHsgbGFiZWw6ICdDZW50ZXInLCB2YWx1ZTogSG9yaXpvbnRhbENvbnN0cmFpbnQuQ2VudGVyIH0sXG4gIHsgbGFiZWw6ICdTY2FsZScsIHZhbHVlOiBIb3Jpem9udGFsQ29uc3RyYWludC5TY2FsZSB9LFxuXTtcblxuY29uc3QgdmVydGljYWxPcHRpb25zOiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8VmVydGljYWxDb25zdHJhaW50Pj4gPSBbXG4gIHsgbGFiZWw6ICdUb3AnLCB2YWx1ZTogVmVydGljYWxDb25zdHJhaW50LlRvcCB9LFxuICB7IGxhYmVsOiAnQm90dG9tJywgdmFsdWU6IFZlcnRpY2FsQ29uc3RyYWludC5Cb3R0b20gfSxcbiAgeyBsYWJlbDogJ1RvcCBhbmQgYm90dG9tJywgdmFsdWU6IFZlcnRpY2FsQ29uc3RyYWludC5Ub3BCb3R0b20gfSxcbiAgeyBsYWJlbDogJ0NlbnRlcicsIHZhbHVlOiBWZXJ0aWNhbENvbnN0cmFpbnQuQ2VudGVyIH0sXG4gIHsgbGFiZWw6ICdTY2FsZScsIHZhbHVlOiBWZXJ0aWNhbENvbnN0cmFpbnQuU2NhbGUgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBQbGFjZW1lbnRFZGl0b3I6IEZDPFN0YW5kYXJkRWRpdG9yUHJvcHM8YW55LCBDYW52YXNFZGl0b3JPcHRpb25zLCBQYW5lbE9wdGlvbnM+PiA9ICh7IGl0ZW0gfSkgPT4ge1xuICBjb25zdCBzZXR0aW5ncyA9IGl0ZW0uc2V0dGluZ3M7XG5cbiAgLy8gV2lsbCBmb3JjZSBhIHJlcmVuZGVyIHdoZW5ldmVyIHRoZSBzdWJqZWN0IGNoYW5nZXNcbiAgdXNlT2JzZXJ2YWJsZShzZXR0aW5ncz8uc2NlbmUgPyBzZXR0aW5ncy5zY2VuZS5tb3ZlZCA6IG5ldyBTdWJqZWN0KCkpO1xuXG4gIGlmICghc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gPGRpdj5Mb2FkaW5nLi4uPC9kaXY+O1xuICB9XG5cbiAgY29uc3QgZWxlbWVudCA9IHNldHRpbmdzLmVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiA8ZGl2Pj8/PzwvZGl2PjtcbiAgfVxuICBjb25zdCB7IG9wdGlvbnMgfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IHsgcGxhY2VtZW50LCBjb25zdHJhaW50OiBsYXlvdXQgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgcmVzZWxlY3RFbGVtZW50QWZ0ZXJDaGFuZ2UgPSAoKSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXR0aW5ncy5zY2VuZS5zZWxlY3QoeyB0YXJnZXRzOiBbZWxlbWVudC5kaXYhXSB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBvbkhvcml6b250YWxDb25zdHJhaW50U2VsZWN0ID0gKGg6IFNlbGVjdGFibGVWYWx1ZTxIb3Jpem9udGFsQ29uc3RyYWludD4pID0+IHtcbiAgICBvbkhvcml6b250YWxDb25zdHJhaW50Q2hhbmdlKGgudmFsdWUhKTtcbiAgfTtcblxuICBjb25zdCBvbkhvcml6b250YWxDb25zdHJhaW50Q2hhbmdlID0gKGg6IEhvcml6b250YWxDb25zdHJhaW50KSA9PiB7XG4gICAgZWxlbWVudC5vcHRpb25zLmNvbnN0cmFpbnQhLmhvcml6b250YWwgPSBoO1xuICAgIGVsZW1lbnQuc2V0UGxhY2VtZW50RnJvbUNvbnN0cmFpbnQoKTtcbiAgICBzZXR0aW5ncy5zY2VuZS5yZXZJZCsrO1xuICAgIHNldHRpbmdzLnNjZW5lLnNhdmUodHJ1ZSk7XG4gICAgcmVzZWxlY3RFbGVtZW50QWZ0ZXJDaGFuZ2UoKTtcbiAgfTtcblxuICBjb25zdCBvblZlcnRpY2FsQ29uc3RyYWludFNlbGVjdCA9ICh2OiBTZWxlY3RhYmxlVmFsdWU8VmVydGljYWxDb25zdHJhaW50PikgPT4ge1xuICAgIG9uVmVydGljYWxDb25zdHJhaW50Q2hhbmdlKHYudmFsdWUhKTtcbiAgfTtcblxuICBjb25zdCBvblZlcnRpY2FsQ29uc3RyYWludENoYW5nZSA9ICh2OiBWZXJ0aWNhbENvbnN0cmFpbnQpID0+IHtcbiAgICBlbGVtZW50Lm9wdGlvbnMuY29uc3RyYWludCEudmVydGljYWwgPSB2O1xuICAgIGVsZW1lbnQuc2V0UGxhY2VtZW50RnJvbUNvbnN0cmFpbnQoKTtcbiAgICBzZXR0aW5ncy5zY2VuZS5yZXZJZCsrO1xuICAgIHNldHRpbmdzLnNjZW5lLnNhdmUodHJ1ZSk7XG4gICAgcmVzZWxlY3RFbGVtZW50QWZ0ZXJDaGFuZ2UoKTtcbiAgfTtcblxuICBjb25zdCBvblBvc2l0aW9uQ2hhbmdlID0gKHZhbHVlOiBudW1iZXIgfCB1bmRlZmluZWQsIHBsYWNlbWVudDoga2V5b2YgUGxhY2VtZW50KSA9PiB7XG4gICAgZWxlbWVudC5vcHRpb25zLnBsYWNlbWVudCFbcGxhY2VtZW50XSA9IHZhbHVlID8/IGVsZW1lbnQub3B0aW9ucy5wbGFjZW1lbnQhW3BsYWNlbWVudF07XG4gICAgZWxlbWVudC5hcHBseUxheW91dFN0eWxlc1RvRGl2KCk7XG4gICAgc2V0dGluZ3Muc2NlbmUuY2xlYXJDdXJyZW50U2VsZWN0aW9uKHRydWUpO1xuICAgIHJlc2VsZWN0RWxlbWVudEFmdGVyQ2hhbmdlKCk7XG4gIH07XG5cbiAgY29uc3QgY29uc3RyYWludCA9IGVsZW1lbnQudGVtcENvbnN0cmFpbnQgPz8gbGF5b3V0ID8/IHt9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxRdWlja1Bvc2l0aW9uaW5nIG9uUG9zaXRpb25DaGFuZ2U9e29uUG9zaXRpb25DaGFuZ2V9IHNldHRpbmdzPXtzZXR0aW5nc30gZWxlbWVudD17ZWxlbWVudH0gLz5cbiAgICAgIDxiciAvPlxuICAgICAgPEZpZWxkIGxhYmVsPVwiQ29uc3RyYWludHNcIj5cbiAgICAgICAgPEhvcml6b250YWxHcm91cD5cbiAgICAgICAgICA8Q29uc3RyYWludFNlbGVjdGlvbkJveFxuICAgICAgICAgICAgb25WZXJ0aWNhbENvbnN0cmFpbnRDaGFuZ2U9e29uVmVydGljYWxDb25zdHJhaW50Q2hhbmdlfVxuICAgICAgICAgICAgb25Ib3Jpem9udGFsQ29uc3RyYWludENoYW5nZT17b25Ib3Jpem9udGFsQ29uc3RyYWludENoYW5nZX1cbiAgICAgICAgICAgIGN1cnJlbnRDb25zdHJhaW50cz17Y29uc3RyYWludH1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxWZXJ0aWNhbEdyb3VwPlxuICAgICAgICAgICAgPFNlbGVjdCBvcHRpb25zPXt2ZXJ0aWNhbE9wdGlvbnN9IG9uQ2hhbmdlPXtvblZlcnRpY2FsQ29uc3RyYWludFNlbGVjdH0gdmFsdWU9e2NvbnN0cmFpbnQudmVydGljYWx9IC8+XG4gICAgICAgICAgICA8U2VsZWN0IG9wdGlvbnM9e2hvcml6b250YWxPcHRpb25zfSBvbkNoYW5nZT17b25Ib3Jpem9udGFsQ29uc3RyYWludFNlbGVjdH0gdmFsdWU9e2NvbnN0cmFpbnQuaG9yaXpvbnRhbH0gLz5cbiAgICAgICAgICA8L1ZlcnRpY2FsR3JvdXA+XG4gICAgICAgIDwvSG9yaXpvbnRhbEdyb3VwPlxuICAgICAgPC9GaWVsZD5cblxuICAgICAgPGJyIC8+XG5cbiAgICAgIDxGaWVsZCBsYWJlbD1cIlBvc2l0aW9uXCI+XG4gICAgICAgIDw+XG4gICAgICAgICAge3BsYWNlcy5tYXAoKHApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBwbGFjZW1lbnQhW3BdO1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIDxJbmxpbmVGaWVsZFJvdyBrZXk9e3B9PlxuICAgICAgICAgICAgICAgIDxJbmxpbmVGaWVsZCBsYWJlbD17cH0gbGFiZWxXaWR0aD17OH0gZ3Jvdz17dHJ1ZX0+XG4gICAgICAgICAgICAgICAgICA8TnVtYmVySW5wdXQgdmFsdWU9e3Z9IG9uQ2hhbmdlPXsodikgPT4gb25Qb3NpdGlvbkNoYW5nZSh2LCBwKX0gLz5cbiAgICAgICAgICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgICAgICAgICA8L0lubGluZUZpZWxkUm93PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KX1cbiAgICAgICAgPC8+XG4gICAgICA8L0ZpZWxkPlxuICAgIDwvZGl2PlxuICApO1xufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YS9zcmMnO1xuaW1wb3J0IHsgSWNvbkJ1dHRvbiwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpL3NyYyc7XG5pbXBvcnQgeyBIb3Jpem9udGFsQ29uc3RyYWludCwgUGxhY2VtZW50LCBRdWlja1BsYWNlbWVudCwgVmVydGljYWxDb25zdHJhaW50IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcyc7XG5pbXBvcnQgeyBFbGVtZW50U3RhdGUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvZWxlbWVudCc7XG5cbmltcG9ydCB7IENhbnZhc0VkaXRvck9wdGlvbnMgfSBmcm9tICcuL2VsZW1lbnRFZGl0b3InO1xuXG50eXBlIFByb3BzID0ge1xuICBvblBvc2l0aW9uQ2hhbmdlOiAodmFsdWU6IG51bWJlciB8IHVuZGVmaW5lZCwgcGxhY2VtZW50OiBrZXlvZiBQbGFjZW1lbnQpID0+IHZvaWQ7XG4gIGVsZW1lbnQ6IEVsZW1lbnRTdGF0ZTtcbiAgc2V0dGluZ3M6IENhbnZhc0VkaXRvck9wdGlvbnM7XG59O1xuXG5leHBvcnQgY29uc3QgUXVpY2tQb3NpdGlvbmluZyA9ICh7IG9uUG9zaXRpb25DaGFuZ2UsIGVsZW1lbnQsIHNldHRpbmdzIH06IFByb3BzKSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICBjb25zdCBvblF1aWNrUG9zaXRpb25pbmdDaGFuZ2UgPSAocG9zaXRpb246IFF1aWNrUGxhY2VtZW50KSA9PiB7XG4gICAgY29uc3QgZGVmYXVsdENvbnN0cmFpbnQgPSB7IHZlcnRpY2FsOiBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wLCBob3Jpem9udGFsOiBIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0IH07XG4gICAgY29uc3Qgb3JpZ2luYWxDb25zdHJhaW50ID0geyAuLi5lbGVtZW50Lm9wdGlvbnMuY29uc3RyYWludCB9O1xuXG4gICAgZWxlbWVudC5vcHRpb25zLmNvbnN0cmFpbnQgPSBkZWZhdWx0Q29uc3RyYWludDtcbiAgICBlbGVtZW50LnNldFBsYWNlbWVudEZyb21Db25zdHJhaW50KCk7XG5cbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFF1aWNrUGxhY2VtZW50LlRvcDpcbiAgICAgICAgb25Qb3NpdGlvbkNoYW5nZSgwLCAndG9wJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBRdWlja1BsYWNlbWVudC5Cb3R0b206XG4gICAgICAgIG9uUG9zaXRpb25DaGFuZ2UoZ2V0UmlnaHRCb3R0b21Qb3NpdGlvbihlbGVtZW50Lm9wdGlvbnMucGxhY2VtZW50Py5oZWlnaHQgPz8gMCwgJ2JvdHRvbScpLCAndG9wJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBRdWlja1BsYWNlbWVudC5WZXJ0aWNhbENlbnRlcjpcbiAgICAgICAgb25Qb3NpdGlvbkNoYW5nZShnZXRDZW50ZXJQb3NpdGlvbihlbGVtZW50Lm9wdGlvbnMucGxhY2VtZW50Py5oZWlnaHQgPz8gMCwgJ3YnKSwgJ3RvcCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUXVpY2tQbGFjZW1lbnQuTGVmdDpcbiAgICAgICAgb25Qb3NpdGlvbkNoYW5nZSgwLCAnbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUXVpY2tQbGFjZW1lbnQuUmlnaHQ6XG4gICAgICAgIG9uUG9zaXRpb25DaGFuZ2UoZ2V0UmlnaHRCb3R0b21Qb3NpdGlvbihlbGVtZW50Lm9wdGlvbnMucGxhY2VtZW50Py53aWR0aCA/PyAwLCAncmlnaHQnKSwgJ2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFF1aWNrUGxhY2VtZW50Lkhvcml6b250YWxDZW50ZXI6XG4gICAgICAgIG9uUG9zaXRpb25DaGFuZ2UoZ2V0Q2VudGVyUG9zaXRpb24oZWxlbWVudC5vcHRpb25zLnBsYWNlbWVudD8ud2lkdGggPz8gMCwgJ2gnKSwgJ2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZWxlbWVudC5vcHRpb25zLmNvbnN0cmFpbnQgPSBvcmlnaW5hbENvbnN0cmFpbnQ7XG4gICAgZWxlbWVudC5zZXRQbGFjZW1lbnRGcm9tQ29uc3RyYWludCgpO1xuICB9O1xuXG4gIC8vIEJhc2luZyB0aGlzIG9uIHNjZW5lIHdpbGwgbWVhbiB0aGF0IGNlbnRlciBpcyBiYXNlZCBvbiByb290IGZvciB0aGUgdGltZSBiZWluZ1xuICBjb25zdCBnZXRDZW50ZXJQb3NpdGlvbiA9IChlbGVtZW50U2l6ZTogbnVtYmVyLCBhbGlnbjogJ2gnIHwgJ3YnKSA9PiB7XG4gICAgY29uc3Qgc2NlbmVTaXplID0gYWxpZ24gPT09ICdoJyA/IHNldHRpbmdzLnNjZW5lLndpZHRoIDogc2V0dGluZ3Muc2NlbmUuaGVpZ2h0O1xuXG4gICAgcmV0dXJuIChzY2VuZVNpemUgLSBlbGVtZW50U2l6ZSkgLyAyO1xuICB9O1xuXG4gIGNvbnN0IGdldFJpZ2h0Qm90dG9tUG9zaXRpb24gPSAoZWxlbWVudFNpemU6IG51bWJlciwgYWxpZ246ICdyaWdodCcgfCAnYm90dG9tJykgPT4ge1xuICAgIGNvbnN0IHNjZW5lU2l6ZSA9IGFsaWduID09PSAncmlnaHQnID8gc2V0dGluZ3Muc2NlbmUud2lkdGggOiBzZXR0aW5ncy5zY2VuZS5oZWlnaHQ7XG5cbiAgICByZXR1cm4gc2NlbmVTaXplIC0gZWxlbWVudFNpemU7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJ1dHRvbkdyb3VwfT5cbiAgICAgIDxJY29uQnV0dG9uXG4gICAgICAgIG5hbWU9eydob3Jpem9udGFsLWFsaWduLWxlZnQnfVxuICAgICAgICBvbkNsaWNrPXsoKSA9PiBvblF1aWNrUG9zaXRpb25pbmdDaGFuZ2UoUXVpY2tQbGFjZW1lbnQuTGVmdCl9XG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmJ1dHRvbn1cbiAgICAgICAgc2l6ZT17J2xnJ31cbiAgICAgICAgdG9vbHRpcD17J0FsaWduIGxlZnQnfVxuICAgICAgLz5cbiAgICAgIDxJY29uQnV0dG9uXG4gICAgICAgIG5hbWU9eydob3Jpem9udGFsLWFsaWduLWNlbnRlcid9XG4gICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUXVpY2tQb3NpdGlvbmluZ0NoYW5nZShRdWlja1BsYWNlbWVudC5Ib3Jpem9udGFsQ2VudGVyKX1cbiAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuYnV0dG9ufVxuICAgICAgICBzaXplPXsnbGcnfVxuICAgICAgICB0b29sdGlwPXsnQWxpZ24gaG9yaXpvbnRhbCBjZW50ZXJzJ31cbiAgICAgIC8+XG4gICAgICA8SWNvbkJ1dHRvblxuICAgICAgICBuYW1lPXsnaG9yaXpvbnRhbC1hbGlnbi1yaWdodCd9XG4gICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUXVpY2tQb3NpdGlvbmluZ0NoYW5nZShRdWlja1BsYWNlbWVudC5SaWdodCl9XG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmJ1dHRvbn1cbiAgICAgICAgc2l6ZT17J2xnJ31cbiAgICAgICAgdG9vbHRpcD17J0FsaWduIHJpZ2h0J31cbiAgICAgIC8+XG4gICAgICA8SWNvbkJ1dHRvblxuICAgICAgICBuYW1lPXsndmVydGljYWwtYWxpZ24tdG9wJ31cbiAgICAgICAgb25DbGljaz17KCkgPT4gb25RdWlja1Bvc2l0aW9uaW5nQ2hhbmdlKFF1aWNrUGxhY2VtZW50LlRvcCl9XG4gICAgICAgIHNpemU9eydsZyd9XG4gICAgICAgIHRvb2x0aXA9eydBbGlnbiB0b3AnfVxuICAgICAgLz5cbiAgICAgIDxJY29uQnV0dG9uXG4gICAgICAgIG5hbWU9eyd2ZXJ0aWNhbC1hbGlnbi1jZW50ZXInfVxuICAgICAgICBvbkNsaWNrPXsoKSA9PiBvblF1aWNrUG9zaXRpb25pbmdDaGFuZ2UoUXVpY2tQbGFjZW1lbnQuVmVydGljYWxDZW50ZXIpfVxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5idXR0b259XG4gICAgICAgIHNpemU9eydsZyd9XG4gICAgICAgIHRvb2x0aXA9eydBbGlnbiB2ZXJ0aWNhbCBjZW50ZXJzJ31cbiAgICAgIC8+XG4gICAgICA8SWNvbkJ1dHRvblxuICAgICAgICBuYW1lPXsndmVydGljYWwtYWxpZ24tYm90dG9tJ31cbiAgICAgICAgb25DbGljaz17KCkgPT4gb25RdWlja1Bvc2l0aW9uaW5nQ2hhbmdlKFF1aWNrUGxhY2VtZW50LkJvdHRvbSl9XG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmJ1dHRvbn1cbiAgICAgICAgc2l6ZT17J2xnJ31cbiAgICAgICAgdG9vbHRpcD17J0FsaWduIGJvdHRvbSd9XG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiAoe1xuICBidXR0b25Hcm91cDogY3NzYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIHBhZGRpbmc6IDEycHggMCAxMnB4IDA7XG4gIGAsXG4gIGJ1dHRvbjogY3NzYFxuICAgIG1hcmdpbi1sZWZ0OiA1cHg7XG4gICAgbWFyZ2luLXJpZ2h0OiA1cHg7XG4gIGAsXG59KTtcbiIsImltcG9ydCB7IGdldCBhcyBsb2Rhc2hHZXQgfSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBOZXN0ZWRQYW5lbE9wdGlvbnMsIE5lc3RlZFZhbHVlQWNjZXNzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YS9zcmMvdXRpbHMvT3B0aW9uc1VJQnVpbGRlcnMnO1xuaW1wb3J0IHsgQ2FudmFzRWxlbWVudE9wdGlvbnMsIGNhbnZhc0VsZW1lbnRSZWdpc3RyeSwgREVGQVVMVF9DQU5WQVNfRUxFTUVOVF9DT05GSUcgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzJztcbmltcG9ydCB7IEVsZW1lbnRTdGF0ZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9lbGVtZW50JztcbmltcG9ydCB7IFNjZW5lIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL3NjZW5lJztcbmltcG9ydCB7IHNldE9wdGlvbkltbXV0YWJseSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kYXNoYm9hcmQvY29tcG9uZW50cy9QYW5lbEVkaXRvci91dGlscyc7XG5cbmltcG9ydCB7IFBsYWNlbWVudEVkaXRvciB9IGZyb20gJy4vUGxhY2VtZW50RWRpdG9yJztcbmltcG9ydCB7IG9wdGlvbkJ1aWxkZXIgfSBmcm9tICcuL29wdGlvbnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbnZhc0VkaXRvck9wdGlvbnMge1xuICBlbGVtZW50OiBFbGVtZW50U3RhdGU7XG4gIHNjZW5lOiBTY2VuZTtcbiAgY2F0ZWdvcnk/OiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRFZGl0b3Iob3B0czogQ2FudmFzRWRpdG9yT3B0aW9ucyk6IE5lc3RlZFBhbmVsT3B0aW9uczxDYW52YXNFbGVtZW50T3B0aW9ucz4ge1xuICByZXR1cm4ge1xuICAgIGNhdGVnb3J5OiBvcHRzLmNhdGVnb3J5LFxuICAgIHBhdGg6ICctLScsIC8vIG5vdCB1c2VkIVxuXG4gICAgLy8gTm90ZSB0aGF0IGNhbnZhcyBlZGl0b3Igd3JpdGVzIHRoaW5ncyB0byB0aGUgc2NlbmUhXG4gICAgdmFsdWVzOiAocGFyZW50OiBOZXN0ZWRWYWx1ZUFjY2VzcykgPT4gKHtcbiAgICAgIGdldFZhbHVlOiAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2Rhc2hHZXQob3B0cy5lbGVtZW50Lm9wdGlvbnMsIHBhdGgpO1xuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiAocGF0aDogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgIGxldCBvcHRpb25zID0gb3B0cy5lbGVtZW50Lm9wdGlvbnM7XG4gICAgICAgIGlmIChwYXRoID09PSAndHlwZScgJiYgdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBsYXllciA9IGNhbnZhc0VsZW1lbnRSZWdpc3RyeS5nZXRJZkV4aXN0cyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdsYXllciBkb2VzIG5vdCBleGlzdCcsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi5sYXllci5nZXROZXdPcHRpb25zKG9wdGlvbnMpLFxuICAgICAgICAgICAgdHlwZTogbGF5ZXIuaWQsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gc2V0T3B0aW9uSW1tdXRhYmx5KG9wdGlvbnMsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLmVsZW1lbnQub25DaGFuZ2Uob3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZWxlbWVudC51cGRhdGVEYXRhKG9wdHMuc2NlbmUuY29udGV4dCk7XG4gICAgICB9LFxuICAgIH0pLFxuXG4gICAgLy8gRHluYW1pY2FsbHkgZmlsbCB0aGUgc2VsZWN0ZWQgZWxlbWVudFxuICAgIGJ1aWxkOiAoYnVpbGRlciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBvcHRzLmVsZW1lbnQ7XG4gICAgICBjb25zdCBsYXllclR5cGVzID0gY2FudmFzRWxlbWVudFJlZ2lzdHJ5LnNlbGVjdE9wdGlvbnMoXG4gICAgICAgIG9wdGlvbnM/LnR5cGUgLy8gdGhlIHNlbGVjdGVkIHZhbHVlXG4gICAgICAgICAgPyBbb3B0aW9ucy50eXBlXSAvLyBhcyBhbiBhcnJheVxuICAgICAgICAgIDogW0RFRkFVTFRfQ0FOVkFTX0VMRU1FTlRfQ09ORklHLnR5cGVdXG4gICAgICApO1xuXG4gICAgICBidWlsZGVyLmFkZFNlbGVjdCh7XG4gICAgICAgIHBhdGg6ICd0eXBlJyxcbiAgICAgICAgbmFtZTogdW5kZWZpbmVkIGFzIGFueSwgLy8gcmVxdWlyZWQsIGJ1dCBoaWRlIHNwYWNlXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgb3B0aW9uczogbGF5ZXJUeXBlcy5vcHRpb25zLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIGZvcmNlIGNsZWFuIGxheWVyIGNvbmZpZ3VyYXRpb25cbiAgICAgIGNvbnN0IGxheWVyID0gY2FudmFzRWxlbWVudFJlZ2lzdHJ5LmdldElmRXhpc3RzKG9wdGlvbnM/LnR5cGUgPz8gREVGQVVMVF9DQU5WQVNfRUxFTUVOVF9DT05GSUcudHlwZSkhO1xuICAgICAgbGV0IGN1cnJlbnRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICghY3VycmVudE9wdGlvbnMpIHtcbiAgICAgICAgY3VycmVudE9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4ubGF5ZXIuZ2V0TmV3T3B0aW9ucyhvcHRpb25zKSxcbiAgICAgICAgICB0eXBlOiBsYXllci5pZCxcbiAgICAgICAgICBuYW1lOiBgRWxlbWVudCAke0RhdGUubm93KCl9LiR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKX1gLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3R4ID0geyAuLi5jb250ZXh0LCBvcHRpb25zOiBjdXJyZW50T3B0aW9ucyB9O1xuXG4gICAgICBpZiAobGF5ZXI/LnJlZ2lzdGVyT3B0aW9uc1VJKSB7XG4gICAgICAgIGxheWVyLnJlZ2lzdGVyT3B0aW9uc1VJKGJ1aWxkZXIsIGN0eCk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbkJ1aWxkZXIuYWRkQmFja2dyb3VuZChidWlsZGVyLCBjdHgpO1xuICAgICAgb3B0aW9uQnVpbGRlci5hZGRCb3JkZXIoYnVpbGRlciwgY3R4KTtcblxuICAgICAgYnVpbGRlci5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeTogWydMYXlvdXQnXSxcbiAgICAgICAgaWQ6ICdjb250ZW50JyxcbiAgICAgICAgcGF0aDogJ19fJywgLy8gbm90IHVzZWRcbiAgICAgICAgbmFtZTogJ1F1aWNrIHBsYWNlbWVudCcsXG4gICAgICAgIGVkaXRvcjogUGxhY2VtZW50RWRpdG9yLFxuICAgICAgICBzZXR0aW5nczogb3B0cyxcbiAgICAgIH0pO1xuICAgIH0sXG4gIH07XG59XG4iLCJpbXBvcnQgeyBnZXQgYXMgbG9kYXNoR2V0IH0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHsgTmVzdGVkUGFuZWxPcHRpb25zLCBOZXN0ZWRWYWx1ZUFjY2VzcyB9IGZyb20gJ0BncmFmYW5hL2RhdGEvc3JjL3V0aWxzL09wdGlvbnNVSUJ1aWxkZXJzJztcbmltcG9ydCB7IEVsZW1lbnRTdGF0ZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9lbGVtZW50JztcbmltcG9ydCB7IEZyYW1lU3RhdGUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvZnJhbWUnO1xuaW1wb3J0IHsgU2NlbmUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvc2NlbmUnO1xuaW1wb3J0IHsgc2V0T3B0aW9uSW1tdXRhYmx5IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2Rhc2hib2FyZC9jb21wb25lbnRzL1BhbmVsRWRpdG9yL3V0aWxzJztcblxuaW1wb3J0IHsgSW5zdGFuY2VTdGF0ZSB9IGZyb20gJy4uL0NhbnZhc1BhbmVsJztcblxuaW1wb3J0IHsgTGF5ZXJFbGVtZW50TGlzdEVkaXRvciB9IGZyb20gJy4vTGF5ZXJFbGVtZW50TGlzdEVkaXRvcic7XG5pbXBvcnQgeyBQbGFjZW1lbnRFZGl0b3IgfSBmcm9tICcuL1BsYWNlbWVudEVkaXRvcic7XG5pbXBvcnQgeyBvcHRpb25CdWlsZGVyIH0gZnJvbSAnLi9vcHRpb25zJztcblxuZXhwb3J0IGludGVyZmFjZSBMYXllckVkaXRvclByb3BzIHtcbiAgc2NlbmU6IFNjZW5lO1xuICBsYXllcjogRnJhbWVTdGF0ZTtcbiAgc2VsZWN0ZWQ6IEVsZW1lbnRTdGF0ZVtdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF5ZXJFZGl0b3Iob3B0czogSW5zdGFuY2VTdGF0ZSk6IE5lc3RlZFBhbmVsT3B0aW9uczxMYXllckVkaXRvclByb3BzPiB7XG4gIGNvbnN0IHsgc2VsZWN0ZWQsIHNjZW5lIH0gPSBvcHRzO1xuXG4gIGlmICghc2NlbmUuY3VycmVudExheWVyKSB7XG4gICAgc2NlbmUuY3VycmVudExheWVyID0gc2NlbmUucm9vdCBhcyBGcmFtZVN0YXRlO1xuICB9XG5cbiAgaWYgKHNlbGVjdGVkKSB7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHNlbGVjdGVkKSB7XG4gICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEZyYW1lU3RhdGUpIHtcbiAgICAgICAgc2NlbmUuY3VycmVudExheWVyID0gZWxlbWVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LnBhcmVudCkge1xuICAgICAgICBzY2VuZS5jdXJyZW50TGF5ZXIgPSBlbGVtZW50LnBhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHNjZW5lLmN1cnJlbnRMYXllci5vcHRpb25zIHx8IHsgZWxlbWVudHM6IFtdIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjYXRlZ29yeTogWydMYXllciddLFxuICAgIHBhdGg6ICctLScsIC8vIG5vdCB1c2VkIVxuXG4gICAgLy8gTm90ZSB0aGF0IGNhbnZhcyBlZGl0b3Igd3JpdGVzIHRoaW5ncyB0byB0aGUgc2NlbmUhXG4gICAgdmFsdWVzOiAocGFyZW50OiBOZXN0ZWRWYWx1ZUFjY2VzcykgPT4gKHtcbiAgICAgIGdldFZhbHVlOiAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2Rhc2hHZXQob3B0aW9ucywgcGF0aCk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IChwYXRoOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKHBhdGggPT09ICd0eXBlJyAmJiB2YWx1ZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybigndW5hYmxlIHRvIGNoYW5nZSBsYXllciB0eXBlJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGMgPSBzZXRPcHRpb25JbW11dGFibHkob3B0aW9ucywgcGF0aCwgdmFsdWUpO1xuICAgICAgICBzY2VuZS5jdXJyZW50TGF5ZXI/Lm9uQ2hhbmdlKGMpO1xuICAgICAgICBzY2VuZS5jdXJyZW50TGF5ZXI/LnVwZGF0ZURhdGEoc2NlbmUuY29udGV4dCk7XG4gICAgICB9LFxuICAgIH0pLFxuXG4gICAgLy8gRHluYW1pY2FsbHkgZmlsbCB0aGUgc2VsZWN0ZWQgZWxlbWVudFxuICAgIGJ1aWxkOiAoYnVpbGRlciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudExheWVyID0gc2NlbmUuY3VycmVudExheWVyO1xuICAgICAgaWYgKGN1cnJlbnRMYXllciAmJiAhY3VycmVudExheWVyLmlzUm9vdCgpKSB7XG4gICAgICAgIC8vIFRPRE86IHRoZSBub24tcm9vdCBuYXYgb3B0aW9uXG4gICAgICB9XG5cbiAgICAgIGJ1aWxkZXIuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgaWQ6ICdjb250ZW50JyxcbiAgICAgICAgcGF0aDogJ3Jvb3QnLFxuICAgICAgICBuYW1lOiAnRWxlbWVudHMnLFxuICAgICAgICBlZGl0b3I6IExheWVyRWxlbWVudExpc3RFZGl0b3IsXG4gICAgICAgIHNldHRpbmdzOiB7IHNjZW5lLCBsYXllcjogc2NlbmUuY3VycmVudExheWVyLCBzZWxlY3RlZCB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGN0eCA9IHsgLi4uY29udGV4dCwgb3B0aW9ucyB9O1xuICAgICAgb3B0aW9uQnVpbGRlci5hZGRCYWNrZ3JvdW5kKGJ1aWxkZXIgYXMgYW55LCBjdHgpO1xuICAgICAgb3B0aW9uQnVpbGRlci5hZGRCb3JkZXIoYnVpbGRlciBhcyBhbnksIGN0eCk7XG5cbiAgICAgIGlmIChjdXJyZW50TGF5ZXIgJiYgIWN1cnJlbnRMYXllci5pc1Jvb3QoKSkge1xuICAgICAgICBidWlsZGVyLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgICAgY2F0ZWdvcnk6IFsnTGF5b3V0J10sXG4gICAgICAgICAgaWQ6ICdjb250ZW50JyxcbiAgICAgICAgICBwYXRoOiAnX18nLCAvLyBub3QgdXNlZFxuICAgICAgICAgIG5hbWU6ICdDb25zdHJhaW50cycsXG4gICAgICAgICAgZWRpdG9yOiBQbGFjZW1lbnRFZGl0b3IsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIHNjZW5lOiBvcHRzLnNjZW5lLFxuICAgICAgICAgICAgZWxlbWVudDogY3VycmVudExheWVyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG59XG4iLCJpbXBvcnQgeyBQYW5lbE9wdGlvbnNTdXBwbGllciB9IGZyb20gJ0BncmFmYW5hL2RhdGEvc3JjL3BhbmVsL1BhbmVsUGx1Z2luJztcbmltcG9ydCB7IEJhY2tncm91bmRJbWFnZVNpemUsIENhbnZhc0VsZW1lbnRPcHRpb25zIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcyc7XG5pbXBvcnQgeyBDb2xvckRpbWVuc2lvbkVkaXRvciwgUmVzb3VyY2VEaW1lbnNpb25FZGl0b3IgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9lZGl0b3JzJztcblxuaW50ZXJmYWNlIE9wdGlvblN1cHBsaWVycyB7XG4gIGFkZEJhY2tncm91bmQ6IFBhbmVsT3B0aW9uc1N1cHBsaWVyPENhbnZhc0VsZW1lbnRPcHRpb25zPjtcbiAgYWRkQm9yZGVyOiBQYW5lbE9wdGlvbnNTdXBwbGllcjxDYW52YXNFbGVtZW50T3B0aW9ucz47XG59XG5cbmV4cG9ydCBjb25zdCBvcHRpb25CdWlsZGVyOiBPcHRpb25TdXBwbGllcnMgPSB7XG4gIGFkZEJhY2tncm91bmQ6IChidWlsZGVyLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgY2F0ZWdvcnkgPSBbJ0JhY2tncm91bmQnXTtcbiAgICBidWlsZGVyXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAnYmFja2dyb3VuZC5jb2xvcicsXG4gICAgICAgIHBhdGg6ICdiYWNrZ3JvdW5kLmNvbG9yJyxcbiAgICAgICAgbmFtZTogJ0NvbG9yJyxcbiAgICAgICAgZWRpdG9yOiBDb2xvckRpbWVuc2lvbkVkaXRvcixcbiAgICAgICAgc2V0dGluZ3M6IHt9LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHtcbiAgICAgICAgICAvLyBDb25maWd1cmVkIHZhbHVlc1xuICAgICAgICAgIGZpeGVkOiAnJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAnYmFja2dyb3VuZC5pbWFnZScsXG4gICAgICAgIHBhdGg6ICdiYWNrZ3JvdW5kLmltYWdlJyxcbiAgICAgICAgbmFtZTogJ0ltYWdlJyxcbiAgICAgICAgZWRpdG9yOiBSZXNvdXJjZURpbWVuc2lvbkVkaXRvcixcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICByZXNvdXJjZVR5cGU6ICdpbWFnZScsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgLmFkZFJhZGlvKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIHBhdGg6ICdiYWNrZ3JvdW5kLnNpemUnLFxuICAgICAgICBuYW1lOiAnSW1hZ2Ugc2l6ZScsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgeyB2YWx1ZTogQmFja2dyb3VuZEltYWdlU2l6ZS5PcmlnaW5hbCwgbGFiZWw6ICdPcmlnaW5hbCcgfSxcbiAgICAgICAgICAgIHsgdmFsdWU6IEJhY2tncm91bmRJbWFnZVNpemUuQ29udGFpbiwgbGFiZWw6ICdDb250YWluJyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogQmFja2dyb3VuZEltYWdlU2l6ZS5Db3ZlciwgbGFiZWw6ICdDb3ZlcicgfSxcbiAgICAgICAgICAgIHsgdmFsdWU6IEJhY2tncm91bmRJbWFnZVNpemUuRmlsbCwgbGFiZWw6ICdGaWxsJyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogQmFja2dyb3VuZEltYWdlU2l6ZS5UaWxlLCBsYWJlbDogJ1RpbGUnIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBCYWNrZ3JvdW5kSW1hZ2VTaXplLkNvdmVyLFxuICAgICAgfSk7XG4gIH0sXG5cbiAgYWRkQm9yZGVyOiAoYnVpbGRlciwgY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWydCb3JkZXInXTtcbiAgICBidWlsZGVyLmFkZFNsaWRlcklucHV0KHtcbiAgICAgIGNhdGVnb3J5LFxuICAgICAgcGF0aDogJ2JvcmRlci53aWR0aCcsXG4gICAgICBuYW1lOiAnV2lkdGgnLFxuICAgICAgZGVmYXVsdFZhbHVlOiAyLFxuICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDIwLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnM/LmJvcmRlcj8ud2lkdGgpIHtcbiAgICAgIGJ1aWxkZXIuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAnYm9yZGVyLmNvbG9yJyxcbiAgICAgICAgcGF0aDogJ2JvcmRlci5jb2xvcicsXG4gICAgICAgIG5hbWU6ICdDb2xvcicsXG4gICAgICAgIGVkaXRvcjogQ29sb3JEaW1lbnNpb25FZGl0b3IsXG4gICAgICAgIHNldHRpbmdzOiB7fSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICAgICAgLy8gQ29uZmlndXJlZCB2YWx1ZXNcbiAgICAgICAgICBmaXhlZDogJycsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG59O1xuIiwiaW1wb3J0IHsgUGFuZWxQbHVnaW4gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEZyYW1lU3RhdGUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvZnJhbWUnO1xuXG5pbXBvcnQgeyBDYW52YXNQYW5lbCwgSW5zdGFuY2VTdGF0ZSB9IGZyb20gJy4vQ2FudmFzUGFuZWwnO1xuaW1wb3J0IHsgZ2V0RWxlbWVudEVkaXRvciB9IGZyb20gJy4vZWRpdG9yL2VsZW1lbnRFZGl0b3InO1xuaW1wb3J0IHsgZ2V0TGF5ZXJFZGl0b3IgfSBmcm9tICcuL2VkaXRvci9sYXllckVkaXRvcic7XG5pbXBvcnQgeyBQYW5lbE9wdGlvbnMgfSBmcm9tICcuL21vZGVscy5nZW4nO1xuXG5leHBvcnQgY29uc3QgcGx1Z2luID0gbmV3IFBhbmVsUGx1Z2luPFBhbmVsT3B0aW9ucz4oQ2FudmFzUGFuZWwpXG4gIC5zZXROb1BhZGRpbmcoKSAvLyBleHRlbmQgdG8gcGFuZWwgZWRnZXNcbiAgLnVzZUZpZWxkQ29uZmlnKClcbiAgLnNldFBhbmVsT3B0aW9ucygoYnVpbGRlciwgY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlOiBJbnN0YW5jZVN0YXRlID0gY29udGV4dC5pbnN0YW5jZVN0YXRlO1xuXG4gICAgYnVpbGRlci5hZGRCb29sZWFuU3dpdGNoKHtcbiAgICAgIHBhdGg6ICdpbmxpbmVFZGl0aW5nJyxcbiAgICAgIG5hbWU6ICdJbmxpbmUgZWRpdGluZycsXG4gICAgICBkZXNjcmlwdGlvbjogJ0VuYWJsZSBlZGl0aW5nIHRoZSBwYW5lbCBkaXJlY3RseScsXG4gICAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgfSk7XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkTmVzdGVkT3B0aW9ucyhnZXRMYXllckVkaXRvcihzdGF0ZSkpO1xuXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3RlZDtcbiAgICAgIGlmIChzZWxlY3Rpb24/Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gc2VsZWN0aW9uWzBdO1xuICAgICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRnJhbWVTdGF0ZSkpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE5lc3RlZE9wdGlvbnMoXG4gICAgICAgICAgICBnZXRFbGVtZW50RWRpdG9yKHtcbiAgICAgICAgICAgICAgY2F0ZWdvcnk6IFtgU2VsZWN0ZWQgZWxlbWVudCAoJHtlbGVtZW50Lm9wdGlvbnMubmFtZX0pYF0sXG4gICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgIHNjZW5lOiBzdGF0ZS5zY2VuZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4iLCJleHBvcnQgZW51bSBMYXllckFjdGlvbklEIHtcbiAgRGVsZXRlID0gJ2RlbGV0ZScsXG4gIER1cGxpY2F0ZSA9ICdkdXBsaWNhdGUnLFxuICBNb3ZlVG9wID0gJ21vdmUtdG9wJyxcbiAgTW92ZUJvdHRvbSA9ICdtb3ZlLWJvdHRvbScsXG59XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBjc3Mtc3R5bGVkXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvY3NzLXN0eWxlZC5naXRcbnZlcnNpb246IDEuMC4wXG4qL1xuaW1wb3J0IHsgc3BsaXRDb21tYSB9IGZyb20gJ0BkYXlicnVzaC91dGlscyc7XG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gIHZhciBoYXNoID0gNTM4MSxcbiAgICAgIGkgICAgPSBzdHIubGVuZ3RoO1xuXG4gIHdoaWxlKGkpIHtcbiAgICBoYXNoID0gKGhhc2ggKiAzMykgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICB9XG5cbiAgLyogSmF2YVNjcmlwdCBkb2VzIGJpdHdpc2Ugb3BlcmF0aW9ucyAobGlrZSBYT1IsIGFib3ZlKSBvbiAzMi1iaXQgc2lnbmVkXG4gICAqIGludGVnZXJzLiBTaW5jZSB3ZSB3YW50IHRoZSByZXN1bHRzIHRvIGJlIGFsd2F5cyBwb3NpdGl2ZSwgY29udmVydCB0aGVcbiAgICogc2lnbmVkIGludCB0byBhbiB1bnNpZ25lZCBieSBkb2luZyBhbiB1bnNpZ25lZCBiaXRzaGlmdC4gKi9cbiAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5cbnZhciBzdHJpbmdIYXNoID0gaGFzaDtcblxuZnVuY3Rpb24gZ2V0SGFzaChzdHIpIHtcbiAgcmV0dXJuIHN0cmluZ0hhc2goc3RyKS50b1N0cmluZygzNik7XG59XG5mdW5jdGlvbiBnZXRTaGFkb3dSb290KHBhcmVudEVsZW1lbnQpIHtcbiAgaWYgKHBhcmVudEVsZW1lbnQgJiYgcGFyZW50RWxlbWVudC5nZXRSb290Tm9kZSkge1xuICAgIHZhciByb290Tm9kZSA9IHBhcmVudEVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcblxuICAgIGlmIChyb290Tm9kZS5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgIHJldHVybiByb290Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm47XG59XG5mdW5jdGlvbiByZXBsYWNlU3R5bGUoY2xhc3NOYW1lLCBjc3MsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMub3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgcmV0dXJuIGNzcy5yZXBsYWNlKC8oW159O3tcXHN9XVtefTt7XSp8Xlxccyopey9tZywgZnVuY3Rpb24gKF8sIHNlbGVjdG9yKSB7XG4gICAgdmFyIHRyaW1tZWRTZWxlY3RvciA9IHNlbGVjdG9yLnRyaW0oKTtcbiAgICByZXR1cm4gKHRyaW1tZWRTZWxlY3RvciA/IHNwbGl0Q29tbWEodHJpbW1lZFNlbGVjdG9yKSA6IFtcIlwiXSkubWFwKGZ1bmN0aW9uIChzdWJTZWxlY3Rvcikge1xuICAgICAgdmFyIHRyaW1tZWRTdWJTZWxlY3RvciA9IHN1YlNlbGVjdG9yLnRyaW0oKTtcblxuICAgICAgaWYgKHRyaW1tZWRTdWJTZWxlY3Rvci5pbmRleE9mKFwiQFwiKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJpbW1lZFN1YlNlbGVjdG9yO1xuICAgICAgfSBlbHNlIGlmICh0cmltbWVkU3ViU2VsZWN0b3IuaW5kZXhPZihcIjpnbG9iYWxcIikgPiAtMSkge1xuICAgICAgICByZXR1cm4gdHJpbW1lZFN1YlNlbGVjdG9yLnJlcGxhY2UoL1xcOmdsb2JhbC9nLCBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodHJpbW1lZFN1YlNlbGVjdG9yLmluZGV4T2YoXCI6aG9zdFwiKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgdHJpbW1lZFN1YlNlbGVjdG9yLnJlcGxhY2UoL1xcOmhvc3QvZywgXCIuXCIgKyBjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIGlmICh0cmltbWVkU3ViU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIFwiLlwiICsgY2xhc3NOYW1lICsgXCIgXCIgKyB0cmltbWVkU3ViU2VsZWN0b3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCIuXCIgKyBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfSkuam9pbihcIiwgXCIpICsgXCIge1wiO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluamVjdFN0eWxlKGNsYXNzTmFtZSwgY3NzLCBvcHRpb25zLCBzaGFkb3dSb290KSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHQvY3NzXCIpO1xuICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlZC1pZFwiLCBjbGFzc05hbWUpO1xuXG4gIGlmIChvcHRpb25zLm5vbmNlKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgb3B0aW9ucy5ub25jZSk7XG4gIH1cblxuICBzdHlsZS5pbm5lckhUTUwgPSByZXBsYWNlU3R5bGUoY2xhc3NOYW1lLCBjc3MsIG9wdGlvbnMpO1xuICAoc2hhZG93Um9vdCB8fCBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBzdHlsZWQgb2JqZWN0IHRoYXQgY2FuIGJlIGRlZmluZWQgYW5kIGluc2VydGVkIGludG8gdGhlIGNzcy5cbiAqIEBwYXJhbSAtIGNzcyBzdHlsZXNcbiAqL1xuXG5mdW5jdGlvbiBzdHlsZWQoY3NzKSB7XG4gIHZhciBpbmplY3RDbGFzc05hbWUgPSBcInJDU1wiICsgZ2V0SGFzaChjc3MpO1xuICB2YXIgaW5qZWN0Q291bnQgPSAwO1xuICB2YXIgaW5qZWN0RWxlbWVudDtcbiAgcmV0dXJuIHtcbiAgICBjbGFzc05hbWU6IGluamVjdENsYXNzTmFtZSxcbiAgICBpbmplY3Q6IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBzaGFkb3dSb290ID0gZ2V0U2hhZG93Um9vdChlbCk7XG4gICAgICB2YXIgZmlyc3RNb3VudCA9IGluamVjdENvdW50ID09PSAwO1xuICAgICAgdmFyIHN0eWxlRWxlbWVudDtcblxuICAgICAgaWYgKHNoYWRvd1Jvb3QgfHwgZmlyc3RNb3VudCkge1xuICAgICAgICBzdHlsZUVsZW1lbnQgPSBpbmplY3RTdHlsZShpbmplY3RDbGFzc05hbWUsIGNzcywgb3B0aW9ucywgc2hhZG93Um9vdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdE1vdW50KSB7XG4gICAgICAgIGluamVjdEVsZW1lbnQgPSBzdHlsZUVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICArK2luamVjdENvdW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG4gICAgICAgICAgICBzdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW5qZWN0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIC0taW5qZWN0Q291bnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmplY3RDb3VudCA9PT0gMCAmJiBpbmplY3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGluamVjdEVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbmplY3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgaW5qZWN0RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R5bGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVkLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IHJlYWN0LWNvbXBhdC1tb3ZlYWJsZVxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvbW92ZWFibGUvYmxvYi9tYXN0ZXIvcGFja2FnZXMvcmVhY3QtY29tcGF0LW1vdmVhYmxlXG52ZXJzaW9uOiAwLjE4LjBcbiovXG5pbXBvcnQgZ2V0QWdlbnQgZnJvbSAnQGVnanMvYWdlbnQnO1xuaW1wb3J0IHsgcHJlZml4TmFtZXMsIHByZWZpeENTUywgcmVmLCB3aXRoTWV0aG9kcywgcmVmcyB9IGZyb20gJ2ZyYW1ld29yay11dGlscyc7XG5pbXBvcnQgeyBpc09iamVjdCwgZmluZEluZGV4LCBpc0FycmF5LCBzcGxpdFNwYWNlLCBnZXRSYWQsIHRocm90dGxlLCBoYXNDbGFzcywgdGhyb3R0bGVBcnJheSwgZ2V0U2hhcGVEaXJlY3Rpb24sIGNvbnZlcnRVbml0U2l6ZSwgaXNTdHJpbmcsIGF2ZXJhZ2UsIGNhbGN1bGF0ZUJvdW5kU2l6ZSwgZ2V0RGlzdCBhcyBnZXREaXN0JDEsIGRvdCwgZ2V0S2V5cywgaXNVbmRlZmluZWQsIGlzRnVuY3Rpb24sIGlzTnVtYmVyLCBhZGRDbGFzcywgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBzcGxpdEJyYWNrZXQsIHNwbGl0Q29tbWEsIHNwbGl0VW5pdCwgcmVtb3ZlRXZlbnQsIGNhbmNlbEFuaW1hdGlvbkZyYW1lLCBhZGRFdmVudCwgVElOWV9OVU0gYXMgVElOWV9OVU0kMSwgcmVtb3ZlQ2xhc3MgfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlLCBjb252ZXJ0UG9zaXRpb25NYXRyaXgsIG1pbnVzLCBwbHVzLCBpbnZlcnQsIGZyb21UcmFuc2xhdGlvbiwgbXVsdGlwbHksIGNvbnZlcnREaW1lbnNpb24sIG11bHRpcGxpZXMsIGNyZWF0ZU9yaWdpbk1hdHJpeCwgY3JlYXRlSWRlbnRpdHlNYXRyaXgsIGlnbm9yZURpbWVuc2lvbiwgY3JlYXRlV2FycE1hdHJpeCwgY29udmVydE1hdHJpeHRvQ1NTLCByb3RhdGUsIGNyZWF0ZVJvdGF0ZU1hdHJpeCwgY3JlYXRlU2NhbGVNYXRyaXgsIGNvbnZlcnRDU1N0b01hdHJpeCwgZ2V0T3JpZ2luIH0gZnJvbSAnQHNjZW5hL21hdHJpeCc7XG5pbXBvcnQgeyB0b01hdCwgcGFyc2UsIGNhbGN1bGF0ZU1hdHJpeERpc3QsIHBhcnNlTWF0IH0gZnJvbSAnY3NzLXRvLW1hdCc7XG5pbXBvcnQgQ2hpbGRyZW5EaWZmZXIsIHsgZGlmZiB9IGZyb20gJ0BlZ2pzL2NoaWxkcmVuLWRpZmZlcic7XG5pbXBvcnQgeyBmaXRQb2ludHMsIGdldE92ZXJsYXBTaXplLCBnZXRBcmVhU2l6ZSwgaXNJbnNpZGUsIGdldE1pbk1heHMgfSBmcm9tICdvdmVybGFwLWFyZWEnO1xuaW1wb3J0IERyYWdTY3JvbGwgZnJvbSAnQHNjZW5hL2RyYWdzY3JvbGwnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3Qtc2ltcGxlLWNvbXBhdCc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3Qtc2ltcGxlLWNvbXBhdCc7XG5pbXBvcnQgR2VzdG8gZnJvbSAnZ2VzdG8nO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdyZWFjdC1jb21wYXQtY3NzLXN0eWxlZCc7XG5cbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IEBzY2VuYS9ldmVudC1lbWl0dGVyXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvZ2VzdHVyZS5naXRcbnZlcnNpb246IDEuMC41XG4qL1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xudmFyIF9fYXNzaWduJDEgPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduJDEgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9fYXNzaWduJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKSBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKykgcltrXSA9IGFbal07XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogSW1wbGVtZW50IEV2ZW50RW1pdHRlciBvbiBvYmplY3Qgb3IgY29tcG9uZW50LlxuICovXG5cbnZhciBFdmVudEVtaXR0ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIHRoZSByZWdpc3RlcmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gLSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0gLSBsaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICogY29zbnQgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogLy8gQWRkIGxpc3RlbmVyIGluIFwiYVwiIGV2ZW50XG4gICAqIGVtaXR0ZXIub24oXCJhXCIsICgpID0+IHtcbiAgICogfSk7XG4gICAqIC8vIEFkZCBsaXN0ZW5lcnNcbiAgICogZW1pdHRlci5vbih7XG4gICAqICBhOiAoKSA9PiB7fSxcbiAgICogIGI6ICgpID0+IHt9LFxuICAgKiB9KTtcbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzT2JqZWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMub24obmFtZSwgZXZlbnROYW1lW25hbWVdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkRXZlbnQoZXZlbnROYW1lLCBsaXN0ZW5lciwge30pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmVtb3ZlIGxpc3RlbmVycyByZWdpc3RlcmVkIGluIHRoZSBldmVudCB0YXJnZXQuXG4gICAqIEBwYXJhbSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIHJlbW92ZWRcbiAgICogQHBhcmFtIC0gbGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIHJlbW92ZWRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICogY29zbnQgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMuXG4gICAqIGVtaXR0ZXIub2ZmKCk7XG4gICAqXG4gICAqIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGluIFwiQVwiIGV2ZW50LlxuICAgKiBlbWl0dGVyLm9mZihcImFcIik7XG4gICAqXG4gICAqXG4gICAqIC8vIFJlbW92ZSBcImxpc3RlbmVyXCIgbGlzdGVuZXIgaW4gXCJhXCIgZXZlbnQuXG4gICAqIGVtaXR0ZXIub2ZmKFwiYVwiLCBsaXN0ZW5lcik7XG4gICAqL1xuXG5cbiAgX19wcm90by5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMub2ZmKG5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV07XG5cbiAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4KGV2ZW50cywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5saXN0ZW5lciA9PT0gbGlzdGVuZXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgZXZlbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEFkZCBhIGRpc3Bvc2FibGUgbGlzdGVuZXIgYW5kIFVzZSBwcm9taXNlIHRvIHRoZSByZWdpc3RlcmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gLSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0gLSBkaXNwb3NhYmxlIGxpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKiBjb3NudCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiAvLyBBZGQgYSBkaXNwb3NhYmxlIGxpc3RlbmVyIGluIFwiYVwiIGV2ZW50XG4gICAqIGVtaXR0ZXIub25jZShcImFcIiwgKCkgPT4ge1xuICAgKiB9KTtcbiAgICpcbiAgICogLy8gVXNlIFByb21pc2VcbiAgICogZW1pdHRlci5vbmNlKFwiYVwiKS50aGVuKGUgPT4ge1xuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50KGV2ZW50TmFtZSwgbGlzdGVuZXIsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfdGhpcy5fYWRkRXZlbnQoZXZlbnROYW1lLCByZXNvbHZlLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogRmlyZXMgYW4gZXZlbnQgdG8gY2FsbCBsaXN0ZW5lcnMuXG4gICAqIEBwYXJhbSAtIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIC0gRXZlbnQgcGFyYW1ldGVyXG4gICAqIEByZXR1cm4gSWYgZmFsc2UsIHN0b3AgdGhlIGV2ZW50LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKlxuICAgKlxuICAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiBlbWl0dGVyLm9uKFwiYVwiLCBlID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIGVtaXR0ZXIuZW1pdChcImFcIiwge1xuICAgKiAgIGE6IDEsXG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHBhcmFtKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChwYXJhbSA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbSA9IHt9O1xuICAgIH1cblxuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcblxuICAgIGlmICghZXZlbnROYW1lIHx8ICFldmVudHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1N0b3AgPSBmYWxzZTtcbiAgICBwYXJhbS5ldmVudFR5cGUgPSBldmVudE5hbWU7XG5cbiAgICBwYXJhbS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgaXNTdG9wID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcGFyYW0uY3VycmVudFRhcmdldCA9IHRoaXM7XG5cbiAgICBfX3NwcmVhZEFycmF5cyhldmVudHMpLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIGluZm8ubGlzdGVuZXIocGFyYW0pO1xuXG4gICAgICBpZiAoaW5mby5vbmNlKSB7XG4gICAgICAgIF90aGlzLm9mZihldmVudE5hbWUsIGluZm8ubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuICFpc1N0b3A7XG4gIH07XG4gIC8qKlxuICAgKiBGaXJlcyBhbiBldmVudCB0byBjYWxsIGxpc3RlbmVycy5cbiAgICogQHBhcmFtIC0gRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gLSBFdmVudCBwYXJhbWV0ZXJcbiAgICogQHJldHVybiBJZiBmYWxzZSwgc3RvcCB0aGUgZXZlbnQuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqXG4gICAqXG4gICAqIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIGVtaXR0ZXIub24oXCJhXCIsIGUgPT4ge1xuICAgKiB9KTtcbiAgICpcbiAgICpcbiAgICogZW1pdHRlci5lbWl0KFwiYVwiLCB7XG4gICAqICAgYTogMSxcbiAgICogfSk7XG4gICAqL1xuXG4gIC8qKlxuICAqIEZpcmVzIGFuIGV2ZW50IHRvIGNhbGwgbGlzdGVuZXJzLlxuICAqIEBwYXJhbSAtIEV2ZW50IG5hbWVcbiAgKiBAcGFyYW0gLSBFdmVudCBwYXJhbWV0ZXJcbiAgKiBAcmV0dXJuIElmIGZhbHNlLCBzdG9wIHRoZSBldmVudC5cbiAgKiBAZXhhbXBsZVxuICAqXG4gICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgKlxuICAqXG4gICogY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgKlxuICAqIGVtaXR0ZXIub24oXCJhXCIsIGUgPT4ge1xuICAqIH0pO1xuICAqXG4gICogLy8gZW1pdFxuICAqIGVtaXR0ZXIudHJpZ2dlcihcImFcIiwge1xuICAqICAgYTogMSxcbiAgKiB9KTtcbiAgKi9cblxuXG4gIF9fcHJvdG8udHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHBhcmFtKSB7XG4gICAgaWYgKHBhcmFtID09PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZW1pdChldmVudE5hbWUsIHBhcmFtKTtcbiAgfTtcblxuICBfX3Byb3RvLl9hZGRFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBldmVudHNbZXZlbnROYW1lXSA9IGV2ZW50c1tldmVudE5hbWVdIHx8IFtdO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBldmVudHNbZXZlbnROYW1lXTtcbiAgICBsaXN0ZW5lcnMucHVzaChfX2Fzc2lnbiQxKHtcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICByZXR1cm4gRXZlbnRFbWl0dGVyO1xufSgpO1xuXG52YXIgRXZlbnRFbWl0dGVyJDEgPSBFdmVudEVtaXR0ZXI7XG5cbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IHJlYWN0LW1vdmVhYmxlXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9tb3ZlYWJsZS9ibG9iL21hc3Rlci9wYWNrYWdlcy9yZWFjdC1tb3ZlYWJsZVxudmVyc2lvbjogMC4zMy4wXG4qL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcblxuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMCkgdFtwXSA9IHNbcF07XG5cbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYyxcbiAgICAgIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cblxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICBhcltpXSA9IGZyb21baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5mdW5jdGlvbiBtYWtlQWJsZShuYW1lLCBhYmxlKSB7XG4gIHZhciBfYTtcblxuICByZXR1cm4gX19hc3NpZ24oe1xuICAgIGV2ZW50czoge30sXG4gICAgcHJvcHM6IChfYSA9IHt9LCBfYVtuYW1lXSA9IEJvb2xlYW4sIF9hKSxcbiAgICBuYW1lOiBuYW1lXG4gIH0sIGFibGUpO1xufVxuXG5mdW5jdGlvbiBnZXRTVkdDdXJzb3Ioc2NhbGUsIGRlZ3JlZSkge1xuICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIlwiLmNvbmNhdCgzMiAqIHNjYWxlLCBcInB4XFxcIiBoZWlnaHQ9XFxcIlwiKS5jb25jYXQoMzIgKiBzY2FsZSwgXCJweFxcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIiA+PHBhdGggZD1cXFwiTSAxNiw1IEwgMTIsMTAgTCAxNC41LDEwIEwgMTQuNSwyMiBMIDEyLDIyIEwgMTYsMjcgTCAyMCwyMiBMIDE3LjUsMjIgTCAxNy41LDEwIEwgMjAsIDEwIEwgMTYsNSBaXFxcIiBzdHJva2UtbGluZWpvaW49XFxcInJvdW5kXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgZmlsbD1cXFwiYmxhY2tcXFwiIHN0cm9rZT1cXFwid2hpdGVcXFwiIHN0eWxlPVxcXCJ0cmFuc2Zvcm06cm90YXRlKFwiKS5jb25jYXQoZGVncmVlLCBcImRlZyk7dHJhbnNmb3JtLW9yaWdpbjogMTZweCAxNnB4XFxcIj48L3BhdGg+PC9zdmc+XCIpO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJzb3JDU1MoZGVncmVlKSB7XG4gIHZhciB4MSA9IGdldFNWR0N1cnNvcigxLCBkZWdyZWUpOyAvLyBjb25zdCB4MiA9IGdldFNWR0N1cnNvcigyLCBkZWdyZWUpO1xuXG4gIHZhciBkZWdyZWU0NSA9IE1hdGgucm91bmQoZGVncmVlIC8gNDUpICogNDUgJSAxODA7XG4gIHZhciBkZWZhdWx0Q3Vyc29yID0gXCJucy1yZXNpemVcIjtcblxuICBpZiAoZGVncmVlNDUgPT09IDEzNSkge1xuICAgIGRlZmF1bHRDdXJzb3IgPSBcIm53c2UtcmVzaXplXCI7XG4gIH0gZWxzZSBpZiAoZGVncmVlNDUgPT09IDQ1KSB7XG4gICAgZGVmYXVsdEN1cnNvciA9IFwibmVzdy1yZXNpemVcIjtcbiAgfSBlbHNlIGlmIChkZWdyZWU0NSA9PT0gOTApIHtcbiAgICBkZWZhdWx0Q3Vyc29yID0gXCJldy1yZXNpemVcIjtcbiAgfSAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG1heC1saW5lLWxlbmd0aFxuXG5cbiAgcmV0dXJuIFwiY3Vyc29yOlwiLmNvbmNhdChkZWZhdWx0Q3Vyc29yLCBcIjtjdXJzb3I6IHVybCgnXCIpLmNvbmNhdCh4MSwgXCInKSAxNiAxNiwgXCIpLmNvbmNhdChkZWZhdWx0Q3Vyc29yLCBcIjtcIik7XG59XG5cbnZhciBhZ2VudCA9IGdldEFnZW50KCk7XG52YXIgSVNfV0VCS0lUID0gYWdlbnQuYnJvd3Nlci53ZWJraXQ7XG5cbnZhciBJU19XRUJLSVQ2MDUgPSBJU19XRUJLSVQgJiYgZnVuY3Rpb24gKCkge1xuICB2YXIgbmF2aSA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyB7XG4gICAgdXNlckFnZW50OiBcIlwiXG4gIH0gOiB3aW5kb3cubmF2aWdhdG9yO1xuICB2YXIgcmVzID0gL2FwcGxld2Via2l0XFwvKFteXFxzXSspL2cuZXhlYyhuYXZpLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcbiAgcmV0dXJuIHJlcyA/IHBhcnNlRmxvYXQocmVzWzFdKSA8IDYwNSA6IGZhbHNlO1xufSgpO1xuXG52YXIgUFJFRklYID0gXCJtb3ZlYWJsZS1cIjtcbnZhciBNT1ZFQUJMRV9DU1MgPSBcIlxcbntcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0d2lkdGg6IDFweDtcXG5cXHRoZWlnaHQ6IDFweDtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG4gICAgei1pbmRleDogMzAwMDtcXG4gICAgLS1tb3ZlYWJsZS1jb2xvcjogIzRhZjtcXG4gICAgLS16b29tOiAxO1xcbiAgICAtLXpvb21weDogMXB4O1xcbiAgICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbn1cXG4uY29udHJvbC1ib3gge1xcbiAgICB6LWluZGV4OiAwO1xcbn1cXG4ubGluZSwgLmNvbnRyb2wge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0bGVmdDogMDtcXG4gICAgdG9wOiAwO1xcbiAgICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbn1cXG4uY29udHJvbCB7XFxuXFx0d2lkdGg6IDE0cHg7XFxuXFx0aGVpZ2h0OiAxNHB4O1xcblxcdGJvcmRlci1yYWRpdXM6IDUwJTtcXG5cXHRib3JkZXI6IDJweCBzb2xpZCAjZmZmO1xcblxcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIGJhY2tncm91bmQ6ICM0YWY7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLW1vdmVhYmxlLWNvbG9yKTtcXG5cXHRtYXJnaW4tdG9wOiAtN3B4O1xcbiAgICBtYXJnaW4tbGVmdDogLTdweDtcXG4gICAgYm9yZGVyOiAycHggc29saWQgI2ZmZjtcXG4gICAgei1pbmRleDogMTA7XFxufVxcbi5wYWRkaW5nIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDBweDtcXG4gICAgbGVmdDogMHB4O1xcbiAgICB3aWR0aDogMTAwcHg7XFxuICAgIGhlaWdodDogMTAwcHg7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXG59XFxuLmxpbmUge1xcblxcdHdpZHRoOiAxcHg7XFxuICAgIGhlaWdodDogMXB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjNGFmO1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XFxuXFx0dHJhbnNmb3JtLW9yaWdpbjogMHB4IDUwJTtcXG59XFxuLmxpbmUuZGFzaGVkIHtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxufVxcbi5saW5lLmRhc2hlZC5ob3Jpem9udGFsIHtcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjNGFmO1xcbiAgICBib3JkZXItdG9wLWNvbG9yOiAjNGFmO1xcbiAgICBib3JkZXItdG9wLWNvbG9yOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XFxufVxcbi5saW5lLmRhc2hlZC52ZXJ0aWNhbCB7XFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM0YWY7XFxuICAgIGJvcmRlci1sZWZ0LWNvbG9yOiAjNGFmO1xcbiAgICBib3JkZXItbGVmdC1jb2xvcjogdmFyKC0tbW92ZWFibGUtY29sb3IpO1xcbn1cXG4ubGluZS52ZXJ0aWNhbCB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXG59XFxuLmxpbmUuaG9yaXpvbnRhbCB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG59XFxuLmxpbmUudmVydGljYWwuYm9sZCB7XFxuICAgIHdpZHRoOiAycHg7XFxufVxcbi5saW5lLmhvcml6b250YWwuYm9sZCB7XFxuICAgIGhlaWdodDogMnB4O1xcbn1cXG5cXG4uY29udHJvbC5vcmlnaW4ge1xcblxcdGJvcmRlci1jb2xvcjogI2Y1NTtcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcblxcdHdpZHRoOiAxMnB4O1xcblxcdGhlaWdodDogMTJweDtcXG5cXHRtYXJnaW4tdG9wOiAtNnB4O1xcbiAgICBtYXJnaW4tbGVmdDogLTZweDtcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXCIuY29uY2F0KFswLCAxNSwgMzAsIDQ1LCA2MCwgNzUsIDkwLCAxMDUsIDEyMCwgMTM1LCAxNTAsIDE2NV0ubWFwKGZ1bmN0aW9uIChkZWdyZWUpIHtcbiAgcmV0dXJuIFwiXFxuLmRpcmVjdGlvbltkYXRhLXJvdGF0aW9uPVxcXCJcIi5jb25jYXQoZGVncmVlLCBcIlxcXCJdIHtcXG5cXHRcIikuY29uY2F0KGdldEN1cnNvckNTUyhkZWdyZWUpLCBcIlxcbn1cXG5cIik7XG59KS5qb2luKFwiXFxuXCIpLCBcIlxcbi5ncm91cCB7XFxuICAgIHotaW5kZXg6IC0xO1xcbn1cXG4uYXJlYSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLmFyZWEtcGllY2VzIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5hcmVhLmF2b2lkLCAuYXJlYS5wYXNzIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcbi5hcmVhLmF2b2lkKy5hcmVhLXBpZWNlcyB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uYXJlYS1waWVjZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuXCIpLmNvbmNhdChJU19XRUJLSVQ2MDUgPyBcIjpnbG9iYWwgc3ZnICo6YmVmb3JlIHtcXG5cXHRjb250ZW50OlxcXCJcXFwiO1xcblxcdHRyYW5zZm9ybS1vcmlnaW46IGluaGVyaXQ7XFxufVwiIDogXCJcIiwgXCJcXG5cIik7XG52YXIgTkVBUkJZX1BPUyA9IFtbMCwgMSwgMl0sIFsxLCAwLCAzXSwgWzIsIDAsIDNdLCBbMywgMSwgMl1dO1xudmFyIEZMT0FUX1BPSU5UX05VTSA9IDAuMDAwMTtcbnZhciBUSU5ZX05VTSA9IDAuMDAwMDAwMTtcbnZhciBNSU5fU0NBTEUgPSAwLjAwMDAwMDAwMTtcbnZhciBNQVhfTlVNID0gTWF0aC5wb3coMTAsIDEwKTtcbnZhciBNSU5fTlVNID0gLU1BWF9OVU07XG52YXIgRElSRUNUSU9OUyA9IFtcIm5cIiwgXCJ3XCIsIFwic1wiLCBcImVcIiwgXCJud1wiLCBcIm5lXCIsIFwic3dcIiwgXCJzZVwiXTtcbnZhciBESVJFQ1RJT05fSU5ERVhFUyA9IHtcbiAgbjogWzAsIDFdLFxuICBzOiBbMiwgM10sXG4gIHc6IFsyLCAwXSxcbiAgZTogWzEsIDNdLFxuICBudzogWzBdLFxuICBuZTogWzFdLFxuICBzdzogWzJdLFxuICBzZTogWzNdXG59O1xudmFyIERJUkVDVElPTl9ST1RBVElPTlMgPSB7XG4gIG46IDAsXG4gIHM6IDE4MCxcbiAgdzogMjcwLFxuICBlOiA5MCxcbiAgbnc6IDMxNSxcbiAgbmU6IDQ1LFxuICBzdzogMjI1LFxuICBzZTogMTM1XG59O1xudmFyIE1PVkVBQkxFX01FVEhPRFMgPSBbXCJpc01vdmVhYmxlRWxlbWVudFwiLCBcInVwZGF0ZVJlY3RcIiwgXCJ1cGRhdGVUYXJnZXRcIiwgXCJkZXN0cm95XCIsIFwiZHJhZ1N0YXJ0XCIsIFwiaXNJbnNpZGVcIiwgXCJoaXRUZXN0XCIsIFwic2V0U3RhdGVcIiwgXCJnZXRSZWN0XCIsIFwicmVxdWVzdFwiLCBcImlzRHJhZ2dpbmdcIiwgXCJnZXRNYW5hZ2VyXCIsIFwiZm9yY2VVcGRhdGVcIl07XG5cbmZ1bmN0aW9uIHNldEN1c3RvbURyYWcoZSwgc3RhdGUsIGRlbHRhLCBpc1BpbmNoLCBpc0NvbnZlcnQpIHtcbiAgdmFyIHJlc3VsdCA9IHN0YXRlLmdlc3RvLm1vdmUoZGVsdGEsIGUuaW5wdXRFdmVudCk7XG4gIHZhciBkYXRhcyA9IHJlc3VsdC5vcmlnaW5hbERhdGFzIHx8IHJlc3VsdC5kYXRhcztcbiAgdmFyIGRyYWdnYWJsZURhdGFzID0gZGF0YXMuZHJhZ2dhYmxlIHx8IChkYXRhcy5kcmFnZ2FibGUgPSB7fSk7XG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaXNDb252ZXJ0ID8gY29udmVydERyYWdEaXN0KHN0YXRlLCByZXN1bHQpIDogcmVzdWx0KSwge1xuICAgIGlzUGluY2g6ICEhaXNQaW5jaCxcbiAgICBwYXJlbnRFdmVudDogdHJ1ZSxcbiAgICBkYXRhczogZHJhZ2dhYmxlRGF0YXMsXG4gICAgb3JpZ2luYWxEYXRhczogZS5vcmlnaW5hbERhdGFzXG4gIH0pO1xufVxuXG52YXIgQ3VzdG9tR2VzdG8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDdXN0b21HZXN0bygpIHtcbiAgICB0aGlzLnByZXZYID0gMDtcbiAgICB0aGlzLnByZXZZID0gMDtcbiAgICB0aGlzLnN0YXJ0WCA9IDA7XG4gICAgdGhpcy5zdGFydFkgPSAwO1xuICAgIHRoaXMuaXNEcmFnID0gZmFsc2U7XG4gICAgdGhpcy5pc0ZsYWcgPSBmYWxzZTtcbiAgICB0aGlzLmRhdGFzID0ge1xuICAgICAgZHJhZ2dhYmxlOiB7fVxuICAgIH07XG4gIH1cblxuICB2YXIgX19wcm90byA9IEN1c3RvbUdlc3RvLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmRyYWdTdGFydCA9IGZ1bmN0aW9uIChjbGllbnQsIGUpIHtcbiAgICB0aGlzLmlzRHJhZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNGbGFnID0gZmFsc2U7XG4gICAgdmFyIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXM7XG4gICAgdGhpcy5kYXRhcyA9IG9yaWdpbmFsRGF0YXM7XG5cbiAgICBpZiAoIW9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlKSB7XG4gICAgICBvcmlnaW5hbERhdGFzLmRyYWdnYWJsZSA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5tb3ZlKGNsaWVudCwgZS5pbnB1dEV2ZW50KSksIHtcbiAgICAgIHR5cGU6IFwiZHJhZ3N0YXJ0XCJcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLmRyYWcgPSBmdW5jdGlvbiAoY2xpZW50LCBpbnB1dEV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubW92ZShbY2xpZW50WzBdIC0gdGhpcy5wcmV2WCwgY2xpZW50WzFdIC0gdGhpcy5wcmV2WV0sIGlucHV0RXZlbnQpO1xuICB9O1xuXG4gIF9fcHJvdG8ubW92ZSA9IGZ1bmN0aW9uIChkZWx0YSwgaW5wdXRFdmVudCkge1xuICAgIHZhciBjbGllbnRYO1xuICAgIHZhciBjbGllbnRZO1xuXG4gICAgaWYgKCF0aGlzLmlzRmxhZykge1xuICAgICAgdGhpcy5wcmV2WCA9IGRlbHRhWzBdO1xuICAgICAgdGhpcy5wcmV2WSA9IGRlbHRhWzFdO1xuICAgICAgdGhpcy5zdGFydFggPSBkZWx0YVswXTtcbiAgICAgIHRoaXMuc3RhcnRZID0gZGVsdGFbMV07XG4gICAgICBjbGllbnRYID0gZGVsdGFbMF07XG4gICAgICBjbGllbnRZID0gZGVsdGFbMV07XG4gICAgICB0aGlzLmlzRmxhZyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsaWVudFggPSB0aGlzLnByZXZYICsgZGVsdGFbMF07XG4gICAgICBjbGllbnRZID0gdGhpcy5wcmV2WSArIGRlbHRhWzFdO1xuXG4gICAgICBpZiAoZGVsdGFbMF0gfHwgZGVsdGFbMV0pIHtcbiAgICAgICAgdGhpcy5pc0RyYWcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHJldlggPSBjbGllbnRYO1xuICAgIHRoaXMucHJldlkgPSBjbGllbnRZO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRyYWdcIixcbiAgICAgIGNsaWVudFg6IGNsaWVudFgsXG4gICAgICBjbGllbnRZOiBjbGllbnRZLFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudCxcbiAgICAgIGlzRHJhZzogdGhpcy5pc0RyYWcsXG4gICAgICBkaXN0WDogY2xpZW50WCAtIHRoaXMuc3RhcnRYLFxuICAgICAgZGlzdFk6IGNsaWVudFkgLSB0aGlzLnN0YXJ0WSxcbiAgICAgIGRlbHRhWDogZGVsdGFbMF0sXG4gICAgICBkZWx0YVk6IGRlbHRhWzFdLFxuICAgICAgZGF0YXM6IHRoaXMuZGF0YXMuZHJhZ2dhYmxlLFxuICAgICAgb3JpZ2luYWxEYXRhczogdGhpcy5kYXRhcyxcbiAgICAgIHBhcmVudEV2ZW50OiB0cnVlLFxuICAgICAgcGFyZW50R2VzdG86IHRoaXNcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBDdXN0b21HZXN0bztcbn0oKTtcblxuZnVuY3Rpb24gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBuYW1lLCBlKSB7XG4gIHZhciBkYXRhcyA9IGUub3JpZ2luYWxEYXRhcztcbiAgZGF0YXMuZ3JvdXBhYmxlID0gZGF0YXMuZ3JvdXBhYmxlIHx8IHt9O1xuICB2YXIgZ3JvdXBhYmxlRGF0YXMgPSBkYXRhcy5ncm91cGFibGU7XG4gIGdyb3VwYWJsZURhdGFzLmNoaWxkRGF0YXMgPSBncm91cGFibGVEYXRhcy5jaGlsZERhdGFzIHx8IFtdO1xuICB2YXIgY2hpbGREYXRhcyA9IGdyb3VwYWJsZURhdGFzLmNoaWxkRGF0YXM7XG4gIHJldHVybiBtb3ZlYWJsZS5tb3ZlYWJsZXMubWFwKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgY2hpbGREYXRhc1tpXSA9IGNoaWxkRGF0YXNbaV0gfHwge307XG4gICAgY2hpbGREYXRhc1tpXVtuYW1lXSA9IGNoaWxkRGF0YXNbaV1bbmFtZV0gfHwge307XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgZGF0YXM6IGNoaWxkRGF0YXNbaV1bbmFtZV0sXG4gICAgICBvcmlnaW5hbERhdGFzOiBjaGlsZERhdGFzW2ldXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyQ2hpbGRHZXN0byhtb3ZlYWJsZSwgYWJsZSwgdHlwZSwgZGVsdGEsIGUsIGlzQ29udmVydCkge1xuICB2YXIgaXNTdGFydCA9ICEhdHlwZS5tYXRjaCgvU3RhcnQkL2cpO1xuICB2YXIgaXNFbmQgPSAhIXR5cGUubWF0Y2goL0VuZCQvZyk7XG4gIHZhciBpc1BpbmNoID0gZS5pc1BpbmNoO1xuICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBhYmxlLm5hbWUsIGUpO1xuICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xuICB2YXIgY2hpbGRzID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoZXYsIGkpIHtcbiAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IG1vdmVhYmxlc1tpXTtcbiAgICB2YXIgc3RhdGUgPSBjaGlsZE1vdmVhYmxlLnN0YXRlO1xuICAgIHZhciBjaGlsZEV2ZW50ID0gZXY7XG5cbiAgICBpZiAoaXNTdGFydCkge1xuICAgICAgY2hpbGRFdmVudCA9IG5ldyBDdXN0b21HZXN0bygpLmRyYWdTdGFydChkZWx0YSwgZXYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXN0YXRlLmdlc3RvKSB7XG4gICAgICAgIHN0YXRlLmdlc3RvID0gZGF0YXMuY2hpbGRHZXN0b3NbaV07XG4gICAgICB9XG5cbiAgICAgIGlmICghc3RhdGUuZ2VzdG8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjaGlsZEV2ZW50ID0gc2V0Q3VzdG9tRHJhZyhldiwgc3RhdGUsIGRlbHRhLCBpc1BpbmNoLCBpc0NvbnZlcnQpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBhYmxlW3R5cGVdKGNoaWxkTW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGlsZEV2ZW50KSwge1xuICAgICAgcGFyZW50RmxhZzogdHJ1ZVxuICAgIH0pKTtcblxuICAgIGlmIChpc0VuZCkge1xuICAgICAgc3RhdGUuZ2VzdG8gPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuXG4gIGlmIChpc1N0YXJ0KSB7XG4gICAgZGF0YXMuY2hpbGRHZXN0b3MgPSBtb3ZlYWJsZXMubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnN0YXRlLmdlc3RvO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcztcbn1cblxuZnVuY3Rpb24gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIGFibGUsIHR5cGUsIGUsIGVhY2hFdmVudCwgY2FsbGJhY2spIHtcbiAgaWYgKGVhY2hFdmVudCA9PT0gdm9pZCAwKSB7XG4gICAgZWFjaEV2ZW50ID0gZnVuY3Rpb24gKF8sIGV2KSB7XG4gICAgICByZXR1cm4gZXY7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpc0VuZCA9ICEhdHlwZS5tYXRjaCgvRW5kJC9nKTtcbiAgdmFyIGV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgYWJsZS5uYW1lLCBlKTtcbiAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcbiAgdmFyIGNoaWxkcyA9IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGV2LCBpKSB7XG4gICAgdmFyIGNoaWxkTW92ZWFibGUgPSBtb3ZlYWJsZXNbaV07XG4gICAgdmFyIGNoaWxkRXZlbnQgPSBldjtcbiAgICBjaGlsZEV2ZW50ID0gZWFjaEV2ZW50KGNoaWxkTW92ZWFibGUsIGV2KTtcbiAgICB2YXIgcmVzdWx0ID0gYWJsZVt0eXBlXShjaGlsZE1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY2hpbGRFdmVudCksIHtcbiAgICAgIHBhcmVudEZsYWc6IHRydWVcbiAgICB9KSk7XG4gICAgcmVzdWx0ICYmIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNoaWxkTW92ZWFibGUsIGV2LCByZXN1bHQsIGkpO1xuXG4gICAgaWYgKGlzRW5kKSB7XG4gICAgICBjaGlsZE1vdmVhYmxlLnN0YXRlLmdlc3RvID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIGNoaWxkcztcbn1cblxuZnVuY3Rpb24gcmVuZGVyRGlyZWN0aW9uQ29udHJvbHMobW92ZWFibGUsIGRlZmF1bHREaXJlY3Rpb25zLCBSZWFjdCwgYWRkaXRpb25hbENsYXNzTmFtZSkge1xuICBpZiAoYWRkaXRpb25hbENsYXNzTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgYWRkaXRpb25hbENsYXNzTmFtZSA9IFwiXCI7XG4gIH1cblxuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIHJlbmRlclBvc2VzID0gX2EucmVuZGVyUG9zZXMsXG4gICAgICByb3RhdGlvblJhZCA9IF9hLnJvdGF0aW9uLFxuICAgICAgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uO1xuICB2YXIgX2IgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgIF9jID0gX2IucmVuZGVyRGlyZWN0aW9ucyxcbiAgICAgIGRpcmVjdGlvbnMgPSBfYyA9PT0gdm9pZCAwID8gZGVmYXVsdERpcmVjdGlvbnMgOiBfYyxcbiAgICAgIHpvb20gPSBfYi56b29tO1xuICB2YXIgZGlyZWN0aW9uTWFwID0ge307XG5cbiAgaWYgKCFkaXJlY3Rpb25zKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHNpZ24gPSBkaXJlY3Rpb24gPiAwID8gMSA6IC0xO1xuICB2YXIgcmVuZGVyRGlyZWN0aW9ucyA9IGRpcmVjdGlvbnMgPT09IHRydWUgPyBESVJFQ1RJT05TIDogZGlyZWN0aW9ucztcbiAgdmFyIGRlZ1JvdGF0aW9uID0gcm90YXRpb25SYWQgLyBNYXRoLlBJICogMTgwO1xuICByZW5kZXJEaXJlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xuICAgIGRpcmVjdGlvbk1hcFtkaXJdID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZW5kZXJEaXJlY3Rpb25zLm1hcChmdW5jdGlvbiAoZGlyKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBESVJFQ1RJT05fSU5ERVhFU1tkaXJdO1xuXG4gICAgaWYgKCFpbmRleGVzIHx8ICFkaXJlY3Rpb25NYXBbZGlyXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGRpcmVjdGlvblJvdGF0aW9uID0gKHRocm90dGxlKGRlZ1JvdGF0aW9uLCAxNSkgKyBzaWduICogRElSRUNUSU9OX1JPVEFUSU9OU1tkaXJdICsgNzIwKSAlIDE4MDtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2xcIiwgXCJkaXJlY3Rpb25cIiwgZGlyLCBhZGRpdGlvbmFsQ2xhc3NOYW1lKSxcbiAgICAgIFwiZGF0YS1yb3RhdGlvblwiOiBkaXJlY3Rpb25Sb3RhdGlvbixcbiAgICAgIFwiZGF0YS1kaXJlY3Rpb25cIjogZGlyLFxuICAgICAga2V5OiBcImRpcmVjdGlvbi1cIi5jb25jYXQoZGlyKSxcbiAgICAgIHN0eWxlOiBnZXRDb250cm9sVHJhbnNmb3JtLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbcm90YXRpb25SYWQsIHpvb21dLCBpbmRleGVzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclBvc2VzW2luZGV4XTtcbiAgICAgIH0pLCBmYWxzZSkpXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJMaW5lKFJlYWN0LCBkaXJlY3Rpb24sIHBvczEsIHBvczIsIHpvb20sIGtleSkge1xuICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xuXG4gIGZvciAodmFyIF9pID0gNjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgY2xhc3NOYW1lc1tfaSAtIDZdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciByYWQgPSBnZXRSYWQocG9zMSwgcG9zMik7XG4gIHZhciByb3RhdGlvbiA9IGRpcmVjdGlvbiA/IHRocm90dGxlKHJhZCAvIE1hdGguUEkgKiAxODAsIDE1KSAlIDE4MCA6IC0xO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcImxpbmVcIi5jb25jYXQoa2V5KSxcbiAgICBjbGFzc05hbWU6IHByZWZpeC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW1wibGluZVwiLCBcImRpcmVjdGlvblwiLCBkaXJlY3Rpb25dLCBjbGFzc05hbWVzLCBmYWxzZSkpLFxuICAgIFwiZGF0YS1yb3RhdGlvblwiOiByb3RhdGlvbixcbiAgICBcImRhdGEtbGluZS1pbmRleFwiOiBrZXksXG4gICAgXCJkYXRhLWRpcmVjdGlvblwiOiBkaXJlY3Rpb24sXG4gICAgc3R5bGU6IGdldExpbmVTdHlsZShwb3MxLCBwb3MyLCB6b29tLCByYWQpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJBbGxEaXJlY3Rpb25zKG1vdmVhYmxlLCBSZWFjdCkge1xuICByZXR1cm4gcmVuZGVyRGlyZWN0aW9uQ29udHJvbHMobW92ZWFibGUsIERJUkVDVElPTlMsIFJlYWN0KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyRGlhZ29uYWxEaXJlY3Rpb25zKG1vdmVhYmxlLCBSZWFjdCkge1xuICByZXR1cm4gcmVuZGVyRGlyZWN0aW9uQ29udHJvbHMobW92ZWFibGUsIFtcIm53XCIsIFwibmVcIiwgXCJzd1wiLCBcInNlXCJdLCBSZWFjdCk7XG59XG4vKipcbiAqIEBuYW1lc3BhY2UgUm90YXRhYmxlXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBkZXNjcmlwdGlvbiBSb3RhdGFibGUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRhcmdldCBjYW4gYmUgcm90YXRlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFJvdGF0ZVN0YXJ0SW5mbyhtb3ZlYWJsZSwgZGF0YXMsIGNsaWVudFgsIGNsaWVudFksIG9yaWdpbiwgcmVjdCkge1xuICB2YXIgbiA9IG1vdmVhYmxlLnN0YXRlLmlzM2QgPyA0IDogMztcbiAgdmFyIG5leHRPcmlnaW4gPSBjYWxjdWxhdGVQb3NpdGlvbihtb3ZlYWJsZS5zdGF0ZS5yb290TWF0cml4LCBvcmlnaW4sIG4pO1xuICB2YXIgc3RhcnRBYnNvbHV0ZU9yaWdpbiA9IHBsdXMoW3JlY3QubGVmdCwgcmVjdC50b3BdLCBuZXh0T3JpZ2luKTtcbiAgZGF0YXMuc3RhcnRBYnNvbHV0ZU9yaWdpbiA9IHN0YXJ0QWJzb2x1dGVPcmlnaW47XG4gIGRhdGFzLnByZXZEZWcgPSBnZXRSYWQoc3RhcnRBYnNvbHV0ZU9yaWdpbiwgW2NsaWVudFgsIGNsaWVudFldKSAvIE1hdGguUEkgKiAxODA7XG4gIGRhdGFzLmRlZmF1bHREZWcgPSBkYXRhcy5wcmV2RGVnO1xuICBkYXRhcy5wcmV2U25hcERlZyA9IDA7XG4gIGRhdGFzLmxvb3AgPSAwO1xufVxuXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZURpc3QoZGVnLCBkaXJlY3Rpb24sIGRhdGFzKSB7XG4gIHZhciBkZWZhdWx0RGVnID0gZGF0YXMuZGVmYXVsdERlZyxcbiAgICAgIHByZXZEZWcgPSBkYXRhcy5wcmV2RGVnO1xuICB2YXIgbm9ybWFsaXplZFByZXZEZWcgPSBwcmV2RGVnICUgMzYwO1xuICB2YXIgbG9vcCA9IE1hdGguZmxvb3IocHJldkRlZyAvIDM2MCk7XG5cbiAgaWYgKG5vcm1hbGl6ZWRQcmV2RGVnIDwgMCkge1xuICAgIG5vcm1hbGl6ZWRQcmV2RGVnICs9IDM2MDtcbiAgfVxuXG4gIGlmIChub3JtYWxpemVkUHJldkRlZyA+IGRlZyAmJiBub3JtYWxpemVkUHJldkRlZyA+IDI3MCAmJiBkZWcgPCA5MCkge1xuICAgIC8vIDM2MCA9PiAwXG4gICAgKytsb29wO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRQcmV2RGVnIDwgZGVnICYmIG5vcm1hbGl6ZWRQcmV2RGVnIDwgOTAgJiYgZGVnID4gMjcwKSB7XG4gICAgLy8gMCA9PiAzNjBcbiAgICAtLWxvb3A7XG4gIH1cblxuICB2YXIgZGlzdCA9IGRpcmVjdGlvbiAqIChsb29wICogMzYwICsgZGVnIC0gZGVmYXVsdERlZyk7XG4gIGRhdGFzLnByZXZEZWcgPSBkZWZhdWx0RGVnICsgZGlzdDtcbiAgcmV0dXJuIGRpc3Q7XG59XG5cbmZ1bmN0aW9uIGdldEFic29sdXRlRGlzdEJ5Q2xpZW50KGNsaWVudFgsIGNsaWVudFksIGRpcmVjdGlvbiwgZGF0YXMpIHtcbiAgcmV0dXJuIGdldEFic29sdXRlRGlzdChnZXRSYWQoZGF0YXMuc3RhcnRBYnNvbHV0ZU9yaWdpbiwgW2NsaWVudFgsIGNsaWVudFldKSAvIE1hdGguUEkgKiAxODAsIGRpcmVjdGlvbiwgZGF0YXMpO1xufVxuXG5mdW5jdGlvbiBnZXRSb3RhdGVJbmZvKG1vdmVhYmxlLCBtb3ZlYWJsZVJlY3QsIGRhdGFzLCBkaXN0LCBzdGFydFZhbHVlLCBpc1NuYXApIHtcbiAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMudGhyb3R0bGVSb3RhdGUsXG4gICAgICB0aHJvdHRsZVJvdGF0ZSA9IF9hID09PSB2b2lkIDAgPyAwIDogX2E7XG4gIHZhciBuZXh0RGlzdCA9IGRpc3Q7XG4gIHZhciBwcmV2U25hcERlZyA9IGRhdGFzLnByZXZTbmFwRGVnO1xuXG4gIGlmIChpc1NuYXApIHtcbiAgICBuZXh0RGlzdCA9IGNoZWNrU25hcFJvdGF0ZShtb3ZlYWJsZSwgbW92ZWFibGVSZWN0LCBkYXRhcy5vcmlnaW4sIG5leHREaXN0KTtcbiAgfVxuXG4gIHZhciBzbmFwUm90YXRpb24gPSB0aHJvdHRsZShzdGFydFZhbHVlICsgbmV4dERpc3QsIHRocm90dGxlUm90YXRlKTtcbiAgdmFyIHNuYXBEZWcgPSBzbmFwUm90YXRpb24gLSBzdGFydFZhbHVlO1xuICBkYXRhcy5wcmV2U25hcERlZyA9IHNuYXBEZWc7XG4gIHJldHVybiBbc25hcERlZyAtIHByZXZTbmFwRGVnLCBuZXh0RGlzdCwgc25hcFJvdGF0aW9uXTtcbn1cblxuZnVuY3Rpb24gZ2V0Um90YXRpb25Qb3NpdGlvbnMocm90YXRpb25Qb3NpdGlvbiwgX2EsIGRpcmVjdGlvbikge1xuICB2YXIgcG9zMSA9IF9hWzBdLFxuICAgICAgcG9zMiA9IF9hWzFdLFxuICAgICAgcG9zMyA9IF9hWzJdLFxuICAgICAgcG9zNCA9IF9hWzNdO1xuXG4gIGlmIChyb3RhdGlvblBvc2l0aW9uID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfYiA9IChyb3RhdGlvblBvc2l0aW9uIHx8IFwidG9wXCIpLnNwbGl0KFwiLVwiKSxcbiAgICAgIGRpcjEgPSBfYlswXSxcbiAgICAgIGRpcjIgPSBfYlsxXTtcblxuICB2YXIgcmFkUG9zZXMgPSBbcG9zMSwgcG9zMl07IC8vIGlmIChzY2FsZVswXSA8IDApIHtcbiAgLy8gICAgIGRpcjEgPSBnZXRSZXZlcnNlUG9zaXRpb25YKGRpcjEpO1xuICAvLyAgICAgZGlyMiA9IGdldFJldmVyc2VQb3NpdGlvblgoZGlyMik7XG4gIC8vIH1cbiAgLy8gaWYgKHNjYWxlWzFdIDwgMCkge1xuICAvLyAgICAgZGlyMSA9IGdldFJldmVyc2VQb3NpdGlvblkoZGlyMSk7XG4gIC8vICAgICBkaXIyID0gZ2V0UmV2ZXJzZVBvc2l0aW9uWShkaXIyKTtcbiAgLy8gfVxuXG4gIGlmIChkaXIxID09PSBcImxlZnRcIikge1xuICAgIHJhZFBvc2VzID0gW3BvczMsIHBvczFdO1xuICB9IGVsc2UgaWYgKGRpcjEgPT09IFwicmlnaHRcIikge1xuICAgIHJhZFBvc2VzID0gW3BvczIsIHBvczRdO1xuICB9IGVsc2UgaWYgKGRpcjEgPT09IFwiYm90dG9tXCIpIHtcbiAgICByYWRQb3NlcyA9IFtwb3M0LCBwb3MzXTtcbiAgfVxuXG4gIHZhciBwb3MgPSBbKHJhZFBvc2VzWzBdWzBdICsgcmFkUG9zZXNbMV1bMF0pIC8gMiwgKHJhZFBvc2VzWzBdWzFdICsgcmFkUG9zZXNbMV1bMV0pIC8gMl07XG4gIHZhciByYWQgPSBnZXRSb3RhdGlvblJhZChyYWRQb3NlcywgZGlyZWN0aW9uKTtcblxuICBpZiAoZGlyMikge1xuICAgIHZhciBpc1N0YXJ0ID0gZGlyMiA9PT0gXCJ0b3BcIiB8fCBkaXIyID09PSBcImxlZnRcIjtcbiAgICB2YXIgaXNSZXZlcnNlID0gZGlyMSA9PT0gXCJib3R0b21cIiB8fCBkaXIxID09PSBcImxlZnRcIjtcbiAgICBwb3MgPSByYWRQb3Nlc1tpc1N0YXJ0ICYmICFpc1JldmVyc2UgfHwgIWlzU3RhcnQgJiYgaXNSZXZlcnNlID8gMCA6IDFdO1xuICB9XG5cbiAgcmV0dXJuIFtwb3MsIHJhZF07XG59XG5cbmZ1bmN0aW9uIGRyYWdDb250cm9sQ29uZGl0aW9uKG1vdmVhYmxlLCBlKSB7XG4gIGlmIChlLmlzUmVxdWVzdCkge1xuICAgIHJldHVybiBlLnJlcXVlc3RBYmxlID09PSBcInJvdGF0YWJsZVwiO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IGUuaW5wdXRFdmVudC50YXJnZXQ7XG5cbiAgaWYgKGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwicm90YXRpb24tY29udHJvbFwiKSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciByb3RhdGlvblRhcmdldCA9IG1vdmVhYmxlLnByb3BzLnJvdGF0aW9uVGFyZ2V0O1xuXG4gIGlmIChyb3RhdGlvblRhcmdldCkge1xuICAgIHJldHVybiBnZXRSZWZUYXJnZXRzKHJvdGF0aW9uVGFyZ2V0LCB0cnVlKS5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0ID09PSBlbGVtZW50IHx8IHRhcmdldC5jb250YWlucyhlbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFJvdGF0YWJsZSA9IHtcbiAgbmFtZTogXCJyb3RhdGFibGVcIixcbiAgY2FuUGluY2g6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgcm90YXRhYmxlOiBCb29sZWFuLFxuICAgIHJvdGF0aW9uUG9zaXRpb246IFN0cmluZyxcbiAgICB0aHJvdHRsZVJvdGF0ZTogTnVtYmVyLFxuICAgIHJlbmRlckRpcmVjdGlvbnM6IE9iamVjdCxcbiAgICByb3RhdGlvblRhcmdldDogT2JqZWN0XG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uUm90YXRlU3RhcnQ6IFwicm90YXRlU3RhcnRcIixcbiAgICBvbkJlZm9yZVJvdGF0ZTogXCJiZWZvcmVSb3RhdGVcIixcbiAgICBvblJvdGF0ZTogXCJyb3RhdGVcIixcbiAgICBvblJvdGF0ZUVuZDogXCJyb3RhdGVFbmRcIixcbiAgICBvblJvdGF0ZUdyb3VwU3RhcnQ6IFwicm90YXRlR3JvdXBTdGFydFwiLFxuICAgIG9uQmVmb3JlUm90YXRlR3JvdXA6IFwiYmVmb3JlUm90YXRlR3JvdXBcIixcbiAgICBvblJvdGF0ZUdyb3VwOiBcInJvdGF0ZUdyb3VwXCIsXG4gICAgb25Sb3RhdGVHcm91cEVuZDogXCJyb3RhdGVHcm91cEVuZFwiXG4gIH0sXG4gIGNzczogW1wiLnJvdGF0aW9uIHtcXG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgICAgaGVpZ2h0OiA0MHB4O1xcbiAgICAgICAgICAgIHdpZHRoOiAxcHg7XFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxuICAgICAgICAgICAgaGVpZ2h0OiBjYWxjKDQwcHggKiB2YXIoLS16b29tKSk7XFxuICAgICAgICAgICAgdG9wOiBhdXRvO1xcbiAgICAgICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICAgICAgYm90dG9tOiAxMDAlO1xcbiAgICAgICAgICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxuICAgICAgICB9XFxuICAgICAgICAucm90YXRpb24gLnJvdGF0aW9uLWxpbmUge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAgICAgfVxcbiAgICAgICAgLnJvdGF0aW9uIC5yb3RhdGlvbi1jb250cm9sIHtcXG4gICAgICAgICAgICBib3JkZXItY29sb3I6ICM0YWY7XFxuICAgICAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XFxuICAgICAgICAgICAgYmFja2dyb3VuZDojZmZmO1xcbiAgICAgICAgICAgIGN1cnNvcjogYWxpYXM7XFxuICAgICAgICB9XCJdLFxuICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgcm90YXRhYmxlID0gX2Eucm90YXRhYmxlLFxuICAgICAgICByb3RhdGlvblBvc2l0aW9uID0gX2Eucm90YXRpb25Qb3NpdGlvbixcbiAgICAgICAgem9vbSA9IF9hLnpvb20sXG4gICAgICAgIHJlbmRlckRpcmVjdGlvbnMgPSBfYS5yZW5kZXJEaXJlY3Rpb25zO1xuICAgIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICByZW5kZXJQb3NlcyA9IF9iLnJlbmRlclBvc2VzLFxuICAgICAgICBkaXJlY3Rpb24gPSBfYi5kaXJlY3Rpb247XG5cbiAgICBpZiAoIXJvdGF0YWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBvc2l0aW9ucyA9IGdldFJvdGF0aW9uUG9zaXRpb25zKHJvdGF0aW9uUG9zaXRpb24sIHJlbmRlclBvc2VzLCBkaXJlY3Rpb24pO1xuICAgIHZhciBqc3hzID0gW107XG5cbiAgICBpZiAocG9zaXRpb25zKSB7XG4gICAgICB2YXIgcG9zID0gcG9zaXRpb25zWzBdLFxuICAgICAgICAgIHJhZCA9IHBvc2l0aW9uc1sxXTtcbiAgICAgIGpzeHMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAga2V5OiBcInJvdGF0aW9uXCIsXG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwicm90YXRpb25cIiksXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUpIHRyYW5zbGF0ZShcIi5jb25jYXQocG9zWzBdLCBcInB4LCBcIikuY29uY2F0KHBvc1sxXSwgXCJweCkgcm90YXRlKFwiKS5jb25jYXQocmFkLCBcInJhZClcIilcbiAgICAgICAgfVxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwibGluZSByb3RhdGlvbi1saW5lXCIpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZVgoXCIuY29uY2F0KHpvb20sIFwiKVwiKVxuICAgICAgICB9XG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbCByb3RhdGlvbi1jb250cm9sXCIpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoMC41cHgpIHNjYWxlKFwiLmNvbmNhdCh6b29tLCBcIilcIilcbiAgICAgICAgfVxuICAgICAgfSkpKTtcbiAgICB9XG5cbiAgICBpZiAocmVuZGVyRGlyZWN0aW9ucykge1xuICAgICAganN4cy5wdXNoLmFwcGx5KGpzeHMsIHJlbmRlckRpcmVjdGlvbkNvbnRyb2xzKG1vdmVhYmxlLCBbXSwgUmVhY3QpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ganN4cztcbiAgfSxcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGRyYWdDb250cm9sQ29uZGl0aW9uLFxuICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBjbGllbnRYID0gZS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZID0gZS5jbGllbnRZLFxuICAgICAgICBwYXJlbnRSb3RhdGUgPSBlLnBhcmVudFJvdGF0ZSxcbiAgICAgICAgcGFyZW50RmxhZyA9IGUucGFyZW50RmxhZyxcbiAgICAgICAgaXNQaW5jaCA9IGUuaXNQaW5jaCxcbiAgICAgICAgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3Q7XG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHRhcmdldCA9IF9hLnRhcmdldCxcbiAgICAgICAgbGVmdCA9IF9hLmxlZnQsXG4gICAgICAgIHRvcCA9IF9hLnRvcCxcbiAgICAgICAgb3JpZ2luID0gX2Eub3JpZ2luLFxuICAgICAgICBiZWZvcmVPcmlnaW4gPSBfYS5iZWZvcmVPcmlnaW4sXG4gICAgICAgIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbixcbiAgICAgICAgYmVmb3JlRGlyZWN0aW9uID0gX2EuYmVmb3JlRGlyZWN0aW9uLFxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm0gPSBfYS50YXJnZXRUcmFuc2Zvcm0sXG4gICAgICAgIG1vdmVhYmxlQ2xpZW50UmVjdCA9IF9hLm1vdmVhYmxlQ2xpZW50UmVjdDtcblxuICAgIGlmICghaXNSZXF1ZXN0ICYmICF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IG1vdmVhYmxlLmdldFJlY3QoKTtcbiAgICBkYXRhcy5yZWN0ID0gcmVjdDtcbiAgICBkYXRhcy50cmFuc2Zvcm0gPSB0YXJnZXRUcmFuc2Zvcm07XG4gICAgZGF0YXMubGVmdCA9IGxlZnQ7XG4gICAgZGF0YXMudG9wID0gdG9wO1xuICAgIGRhdGFzLmZpeGVkUG9zaXRpb24gPSBnZXREaXJlY3Rpb25PZmZzZXQobW92ZWFibGUsIGdldE9yaWdpbkRpcmVjdGlvbihtb3ZlYWJsZSkpO1xuXG4gICAgaWYgKGlzUmVxdWVzdCB8fCBpc1BpbmNoIHx8IHBhcmVudEZsYWcpIHtcbiAgICAgIHZhciBleHRlcm5hbFJvdGF0ZSA9IHBhcmVudFJvdGF0ZSB8fCAwO1xuICAgICAgZGF0YXMuYmVmb3JlSW5mbyA9IHtcbiAgICAgICAgb3JpZ2luOiByZWN0LmJlZm9yZU9yaWdpbixcbiAgICAgICAgcHJldkRlZzogZXh0ZXJuYWxSb3RhdGUsXG4gICAgICAgIGRlZmF1bHREZWc6IGV4dGVybmFsUm90YXRlLFxuICAgICAgICBwcmV2U25hcERlZzogMFxuICAgICAgfTtcbiAgICAgIGRhdGFzLmFmdGVySW5mbyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhcy5iZWZvcmVJbmZvKSwge1xuICAgICAgICBvcmlnaW46IHJlY3Qub3JpZ2luXG4gICAgICB9KTtcbiAgICAgIGRhdGFzLmFic29sdXRlSW5mbyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhcy5iZWZvcmVJbmZvKSwge1xuICAgICAgICBvcmlnaW46IHJlY3Qub3JpZ2luLFxuICAgICAgICBzdGFydFZhbHVlOiBleHRlcm5hbFJvdGF0ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFzLmJlZm9yZUluZm8gPSB7XG4gICAgICAgIG9yaWdpbjogcmVjdC5iZWZvcmVPcmlnaW5cbiAgICAgIH07XG4gICAgICBkYXRhcy5hZnRlckluZm8gPSB7XG4gICAgICAgIG9yaWdpbjogcmVjdC5vcmlnaW5cbiAgICAgIH07XG4gICAgICBkYXRhcy5hYnNvbHV0ZUluZm8gPSB7XG4gICAgICAgIG9yaWdpbjogcmVjdC5vcmlnaW4sXG4gICAgICAgIHN0YXJ0VmFsdWU6IHJlY3Qucm90YXRpb25cbiAgICAgIH07XG4gICAgICBzZXRSb3RhdGVTdGFydEluZm8obW92ZWFibGUsIGRhdGFzLmJlZm9yZUluZm8sIGNsaWVudFgsIGNsaWVudFksIGJlZm9yZU9yaWdpbiwgbW92ZWFibGVDbGllbnRSZWN0KTtcbiAgICAgIHNldFJvdGF0ZVN0YXJ0SW5mbyhtb3ZlYWJsZSwgZGF0YXMuYWZ0ZXJJbmZvLCBjbGllbnRYLCBjbGllbnRZLCBvcmlnaW4sIG1vdmVhYmxlQ2xpZW50UmVjdCk7XG4gICAgICBzZXRSb3RhdGVTdGFydEluZm8obW92ZWFibGUsIGRhdGFzLmFic29sdXRlSW5mbywgY2xpZW50WCwgY2xpZW50WSwgb3JpZ2luLCBtb3ZlYWJsZUNsaWVudFJlY3QpO1xuICAgIH1cblxuICAgIGRhdGFzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICBkYXRhcy5iZWZvcmVEaXJlY3Rpb24gPSBiZWZvcmVEaXJlY3Rpb247XG4gICAgZGF0YXMuc3RhcnRWYWx1ZSA9IDA7XG4gICAgZGF0YXMuZGF0YXMgPSB7fTtcbiAgICBzZXREZWZhdWx0VHJhbnNmb3JtSW5kZXgoZSwgXCJyb3RhdGVcIik7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgIHNldDogZnVuY3Rpb24gKHJvdGF0YXRpb24pIHtcbiAgICAgICAgZGF0YXMuc3RhcnRWYWx1ZSA9IHJvdGF0YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgfVxuICAgIH0sIGZpbGxUcmFuc2Zvcm1TdGFydEV2ZW50KGUpKSwge1xuICAgICAgZHJhZ1N0YXJ0OiBEcmFnZ2FibGUuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBuZXcgQ3VzdG9tR2VzdG8oKS5kcmFnU3RhcnQoWzAsIDBdLCBlKSlcbiAgICB9KSk7XG4gICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdGF0ZVN0YXJ0XCIsIHBhcmFtcyk7XG4gICAgZGF0YXMuaXNSb3RhdGUgPSByZXN1bHQgIT09IGZhbHNlO1xuICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBSZW5kZXJJbmZvID0ge1xuICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3RcbiAgICB9O1xuICAgIHJldHVybiBkYXRhcy5pc1JvdGF0ZSA/IHBhcmFtcyA6IGZhbHNlO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG5cbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBjbGllbnRYID0gZS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZID0gZS5jbGllbnRZLFxuICAgICAgICBwYXJlbnRSb3RhdGUgPSBlLnBhcmVudFJvdGF0ZSxcbiAgICAgICAgcGFyZW50RmxhZyA9IGUucGFyZW50RmxhZyxcbiAgICAgICAgaXNQaW5jaCA9IGUuaXNQaW5jaCxcbiAgICAgICAgZ3JvdXBEZWx0YSA9IGUuZ3JvdXBEZWx0YTtcbiAgICB2YXIgYmVmb3JlRGlyZWN0aW9uID0gZGF0YXMuYmVmb3JlRGlyZWN0aW9uLFxuICAgICAgICBiZWZvcmVJbmZvID0gZGF0YXMuYmVmb3JlSW5mbyxcbiAgICAgICAgYWZ0ZXJJbmZvID0gZGF0YXMuYWZ0ZXJJbmZvLFxuICAgICAgICBhYnNvbHV0ZUluZm8gPSBkYXRhcy5hYnNvbHV0ZUluZm8sXG4gICAgICAgIGlzUm90YXRlID0gZGF0YXMuaXNSb3RhdGUsXG4gICAgICAgIHN0YXJ0VmFsdWUgPSBkYXRhcy5zdGFydFZhbHVlLFxuICAgICAgICByZWN0ID0gZGF0YXMucmVjdDtcblxuICAgIGlmICghaXNSb3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXNvbHZlVHJhbnNmb3JtRXZlbnQoZSwgXCJyb3RhdGVcIik7XG4gICAgdmFyIHRhcmdldERpcmVjdGlvbiA9IGdldFRyYW5zZm9ybURpcmVjdGlvbihlKTtcbiAgICB2YXIgZGlyZWN0aW9uID0gYmVmb3JlRGlyZWN0aW9uICogdGFyZ2V0RGlyZWN0aW9uO1xuICAgIHZhciBwYXJlbnRNb3ZlYWJsZSA9IG1vdmVhYmxlLnByb3BzLnBhcmVudE1vdmVhYmxlO1xuICAgIHZhciBiZWZvcmVEZWx0YSA9IDA7XG4gICAgdmFyIGJlZm9yZURpc3Q7XG4gICAgdmFyIGJlZm9yZVJvdGF0aW9uO1xuICAgIHZhciBkZWx0YSA9IDA7XG4gICAgdmFyIGRpc3Q7XG4gICAgdmFyIHJvdGF0aW9uO1xuICAgIHZhciBhYnNvbHV0ZURlbHRhID0gMDtcbiAgICB2YXIgYWJzb2x1dGVEaXN0O1xuICAgIHZhciBhYnNvbHV0ZVJvdGF0aW9uO1xuICAgIHZhciBzdGFydFJvdGF0aW9uID0gMTgwIC8gTWF0aC5QSSAqIHN0YXJ0VmFsdWU7XG4gICAgdmFyIGFic29sdXRlU3RhcnRSb3RhdGlvbiA9IGFic29sdXRlSW5mby5zdGFydFZhbHVlO1xuICAgIHZhciBpc1NuYXAgPSBmYWxzZTtcblxuICAgIGlmICghcGFyZW50RmxhZyAmJiBcInBhcmVudERpc3RcIiBpbiBlKSB7XG4gICAgICB2YXIgcGFyZW50RGlzdCA9IGUucGFyZW50RGlzdDtcbiAgICAgIGJlZm9yZURpc3QgPSBwYXJlbnREaXN0O1xuICAgICAgZGlzdCA9IHBhcmVudERpc3Q7XG4gICAgICBhYnNvbHV0ZURpc3QgPSBwYXJlbnREaXN0O1xuICAgIH0gZWxzZSBpZiAoaXNQaW5jaCB8fCBwYXJlbnRGbGFnKSB7XG4gICAgICBiZWZvcmVEaXN0ID0gZ2V0QWJzb2x1dGVEaXN0KHBhcmVudFJvdGF0ZSwgYmVmb3JlRGlyZWN0aW9uLCBiZWZvcmVJbmZvKTtcbiAgICAgIGRpc3QgPSBnZXRBYnNvbHV0ZURpc3QocGFyZW50Um90YXRlLCBkaXJlY3Rpb24sIGFmdGVySW5mbyk7XG4gICAgICBhYnNvbHV0ZURpc3QgPSBnZXRBYnNvbHV0ZURpc3QocGFyZW50Um90YXRlLCBkaXJlY3Rpb24sIGFic29sdXRlSW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJlZm9yZURpc3QgPSBnZXRBYnNvbHV0ZURpc3RCeUNsaWVudChjbGllbnRYLCBjbGllbnRZLCBiZWZvcmVEaXJlY3Rpb24sIGJlZm9yZUluZm8pO1xuICAgICAgZGlzdCA9IGdldEFic29sdXRlRGlzdEJ5Q2xpZW50KGNsaWVudFgsIGNsaWVudFksIGRpcmVjdGlvbiwgYWZ0ZXJJbmZvKTtcbiAgICAgIGFic29sdXRlRGlzdCA9IGdldEFic29sdXRlRGlzdEJ5Q2xpZW50KGNsaWVudFgsIGNsaWVudFksIGRpcmVjdGlvbiwgYWJzb2x1dGVJbmZvKTtcbiAgICAgIGlzU25hcCA9IHRydWU7XG4gICAgfVxuXG4gICAgYmVmb3JlUm90YXRpb24gPSBzdGFydFJvdGF0aW9uICsgYmVmb3JlRGlzdDtcbiAgICByb3RhdGlvbiA9IHN0YXJ0Um90YXRpb24gKyBkaXN0O1xuICAgIGFic29sdXRlUm90YXRpb24gPSBhYnNvbHV0ZVN0YXJ0Um90YXRpb24gKyBhYnNvbHV0ZURpc3Q7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUm90YXRlXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGJlZm9yZVJvdGF0aW9uOiBiZWZvcmVSb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgIGFic29sdXRlUm90YXRpb246IGFic29sdXRlUm90YXRpb24sXG4gICAgICBzZXRSb3RhdGlvbjogZnVuY3Rpb24gKG5leHRSb3RhdGlvbikge1xuICAgICAgICBkaXN0ID0gbmV4dFJvdGF0aW9uIC0gc3RhcnRSb3RhdGlvbjtcbiAgICAgICAgYmVmb3JlRGlzdCA9IGRpc3Q7XG4gICAgICAgIGFic29sdXRlRGlzdCA9IGRpc3Q7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSkpO1xuICAgIF9hID0gZ2V0Um90YXRlSW5mbyhtb3ZlYWJsZSwgcmVjdCwgYmVmb3JlSW5mbywgYmVmb3JlRGlzdCwgc3RhcnRSb3RhdGlvbiwgaXNTbmFwKSwgYmVmb3JlRGVsdGEgPSBfYVswXSwgYmVmb3JlRGlzdCA9IF9hWzFdLCBiZWZvcmVSb3RhdGlvbiA9IF9hWzJdO1xuICAgIF9iID0gZ2V0Um90YXRlSW5mbyhtb3ZlYWJsZSwgcmVjdCwgYWZ0ZXJJbmZvLCBkaXN0LCBzdGFydFJvdGF0aW9uLCBpc1NuYXApLCBkZWx0YSA9IF9iWzBdLCBkaXN0ID0gX2JbMV0sIHJvdGF0aW9uID0gX2JbMl07XG4gICAgX2MgPSBnZXRSb3RhdGVJbmZvKG1vdmVhYmxlLCByZWN0LCBhYnNvbHV0ZUluZm8sIGFic29sdXRlRGlzdCwgYWJzb2x1dGVTdGFydFJvdGF0aW9uLCBpc1NuYXApLCBhYnNvbHV0ZURlbHRhID0gX2NbMF0sIGFic29sdXRlRGlzdCA9IF9jWzFdLCBhYnNvbHV0ZVJvdGF0aW9uID0gX2NbMl07XG5cbiAgICBpZiAoIWFic29sdXRlRGVsdGEgJiYgIWRlbHRhICYmICFiZWZvcmVEZWx0YSAmJiAhcGFyZW50TW92ZWFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFRyYW5zZm9ybSA9IGNvbnZlcnRUcmFuc2Zvcm1Gb3JtYXQoZGF0YXMsIFwicm90YXRlKFwiLmNvbmNhdChyb3RhdGlvbiwgXCJkZWcpXCIpLCBcInJvdGF0ZShcIi5jb25jYXQoZGlzdCwgXCJkZWcpXCIpKTtcbiAgICB2YXIgaW52ZXJzZURpc3QgPSBnZXRSb3RhdGVEaXN0KG1vdmVhYmxlLCBkaXN0LCBkYXRhcy5maXhlZFBvc2l0aW9uLCBkYXRhcyk7XG4gICAgdmFyIGludmVyc2VEZWx0YSA9IG1pbnVzKHBsdXMoZ3JvdXBEZWx0YSB8fCBbMCwgMF0sIGludmVyc2VEaXN0KSwgZGF0YXMucHJldkludmVyc2VEaXN0IHx8IFswLCAwXSk7XG4gICAgZGF0YXMucHJldkludmVyc2VEaXN0ID0gaW52ZXJzZURpc3Q7XG4gICAgZGF0YXMucmVxdWVzdFZhbHVlID0gbnVsbDtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oe1xuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgZGlzdDogZGlzdCxcbiAgICAgIHJvdGF0ZTogcm90YXRpb24sXG4gICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICBiZWZvcmVEaXN0OiBiZWZvcmVEaXN0LFxuICAgICAgYmVmb3JlRGVsdGE6IGJlZm9yZURlbHRhLFxuICAgICAgYmVmb3JlUm90YXRlOiBiZWZvcmVSb3RhdGlvbixcbiAgICAgIGJlZm9yZVJvdGF0aW9uOiBiZWZvcmVSb3RhdGlvbixcbiAgICAgIGFic29sdXRlRGlzdDogYWJzb2x1dGVEaXN0LFxuICAgICAgYWJzb2x1dGVEZWx0YTogYWJzb2x1dGVEZWx0YSxcbiAgICAgIGFic29sdXRlUm90YXRlOiBhYnNvbHV0ZVJvdGF0aW9uLFxuICAgICAgYWJzb2x1dGVSb3RhdGlvbjogYWJzb2x1dGVSb3RhdGlvbixcbiAgICAgIGlzUGluY2g6ICEhaXNQaW5jaFxuICAgIH0sIGZpbGxUcmFuc2Zvcm1FdmVudChtb3ZlYWJsZSwgbmV4dFRyYW5zZm9ybSwgaW52ZXJzZURlbHRhLCBpc1BpbmNoLCBlKSkpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdGF0ZVwiLCBwYXJhbXMpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG4gIGRyYWdDb250cm9sQWZ0ZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIGUuZGF0YXMucmVxdWVzdFZhbHVlO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNSb3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhcy5pc1JvdGF0ZSA9IGZhbHNlO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm90YXRlRW5kXCIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbjogZHJhZ0NvbnRyb2xDb25kaXRpb24sXG4gIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgcGFyZW50TGVmdCA9IF9hLmxlZnQsXG4gICAgICAgIHBhcmVudFRvcCA9IF9hLnRvcCxcbiAgICAgICAgcGFyZW50QmVmb3JlT3JpZ2luID0gX2EuYmVmb3JlT3JpZ2luO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIGUpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXJhbXMuc2V0KGRhdGFzLmJlZm9yZURpcmVjdGlvbiAqIG1vdmVhYmxlLnJvdGF0aW9uKTtcbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xTdGFydFwiLCBlLCBmdW5jdGlvbiAoY2hpbGQsIGV2KSB7XG4gICAgICB2YXIgX2EgPSBjaGlsZC5zdGF0ZSxcbiAgICAgICAgICBsZWZ0ID0gX2EubGVmdCxcbiAgICAgICAgICB0b3AgPSBfYS50b3AsXG4gICAgICAgICAgYmVmb3JlT3JpZ2luID0gX2EuYmVmb3JlT3JpZ2luO1xuICAgICAgdmFyIGNoaWxkQ2xpZW50ID0gcGx1cyhtaW51cyhbbGVmdCwgdG9wXSwgW3BhcmVudExlZnQsIHBhcmVudFRvcF0pLCBtaW51cyhiZWZvcmVPcmlnaW4sIHBhcmVudEJlZm9yZU9yaWdpbikpO1xuICAgICAgZXYuZGF0YXMuZ3JvdXBDbGllbnQgPSBjaGlsZENsaWVudDtcbiAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7XG4gICAgICAgIHBhcmVudFJvdGF0ZTogMFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHNcbiAgICB9KTtcblxuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVHcm91cFN0YXJ0XCIsIG5leHRQYXJhbXMpO1xuICAgIGRhdGFzLmlzUm90YXRlID0gcmVzdWx0ICE9PSBmYWxzZTtcbiAgICByZXR1cm4gZGF0YXMuaXNSb3RhdGUgPyBwYXJhbXMgOiBmYWxzZTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNSb3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYXRjaEV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUm90YXRlXCIsIGZ1bmN0aW9uIChwYXJlbnRFdmVudCkge1xuICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUm90YXRlR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmVudEV2ZW50KSwge1xuICAgICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgICB9KSwgdHJ1ZSkpO1xuICAgIH0pO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sKG1vdmVhYmxlLCBlKTtcblxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRpcmVjdGlvbiA9IGRhdGFzLmJlZm9yZURpcmVjdGlvbjtcbiAgICB2YXIgcGFyZW50Um90YXRlID0gcGFyYW1zLmJlZm9yZURpc3Q7XG4gICAgdmFyIGRlZyA9IHBhcmFtcy5iZWZvcmVEZWx0YTtcbiAgICB2YXIgcmFkID0gZGVnIC8gMTgwICogTWF0aC5QSTtcbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xcIiwgZSwgZnVuY3Rpb24gKF8sIGV2KSB7XG4gICAgICB2YXIgX2EgPSBldi5kYXRhcy5ncm91cENsaWVudCxcbiAgICAgICAgICBwcmV2WCA9IF9hWzBdLFxuICAgICAgICAgIHByZXZZID0gX2FbMV07XG5cbiAgICAgIHZhciBfYiA9IHJvdGF0ZShbcHJldlgsIHByZXZZXSwgcmFkICogZGlyZWN0aW9uKSxcbiAgICAgICAgICBjbGllbnRYID0gX2JbMF0sXG4gICAgICAgICAgY2xpZW50WSA9IF9iWzFdO1xuXG4gICAgICB2YXIgZGVsdGEgPSBbY2xpZW50WCAtIHByZXZYLCBjbGllbnRZIC0gcHJldlldO1xuICAgICAgZXYuZGF0YXMuZ3JvdXBDbGllbnQgPSBbY2xpZW50WCwgY2xpZW50WV07XG4gICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV2KSwge1xuICAgICAgICBwYXJlbnRSb3RhdGU6IHBhcmVudFJvdGF0ZSxcbiAgICAgICAgZ3JvdXBEZWx0YTogZGVsdGFcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG1vdmVhYmxlLnJvdGF0aW9uID0gZGlyZWN0aW9uICogcGFyYW1zLmJlZm9yZVJvdGF0aW9uO1xuXG4gICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbih7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChyb3RhdGlvbikge1xuICAgICAgICBtb3ZlYWJsZS5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldEdyb3VwUm90YXRpb246IGZ1bmN0aW9uIChyb3RhdGlvbikge1xuICAgICAgICBtb3ZlYWJsZS5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgfVxuICAgIH0sIHBhcmFtcyk7XG5cbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVHcm91cFwiLCBuZXh0UGFyYW1zKTtcbiAgICByZXR1cm4gbmV4dFBhcmFtcztcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGlzRHJhZyA9IGUuaXNEcmFnLFxuICAgICAgICBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzUm90YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnQ29udHJvbEVuZChtb3ZlYWJsZSwgZSk7XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sRW5kXCIsIGUpO1xuICAgIHZhciBuZXh0UGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm90YXRlR3JvdXBFbmRcIiwgbmV4dFBhcmFtcyk7XG4gICAgcmV0dXJuIGlzRHJhZztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBNb3ZlYWJsZS5Sb3RhdGFibGUjcmVxdWVzdFxuICAgKiBAcGFyYW0ge29iamVjdH0gW2VdIC0gdGhlIFJlc2l6YWJsZSdzIHJlcXVlc3QgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVJvdGF0ZT0wXSAtICBkZWx0YSBudW1iZXIgb2Ygcm90YXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLnJvdGF0ZT0wXSAtIGFic29sdXRlIG51bWJlciBvZiBtb3ZlYWJsZSdzIHJvdGF0aW9uXG4gICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXG4gICAqIEBleGFtcGxlXG4gICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyb3RhdGFibGVcIiwgeyBkZWx0YVJvdGF0ZTogMTAgfSwgdHJ1ZSk7XG4gICAqXG4gICAqICogbW92ZWFibGUucmVxdWVzdChcInJvdGF0YWJsZVwiLCB7IHJvdGF0ZTogMTAgfSwgdHJ1ZSk7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RTdGFydFxuICAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwicm90YXRhYmxlXCIpO1xuICAgKlxuICAgKiAvLyByZXF1ZXN0XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFSb3RhdGU6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhUm90YXRlOiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVJvdGF0ZTogMTAgfSk7XG4gICAqXG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgcm90YXRlOiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyByb3RhdGU6IDIwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IHJvdGF0ZTogMzAgfSk7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RFbmRcbiAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgICovXG4gIHJlcXVlc3Q6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBkYXRhcyA9IHt9O1xuICAgIHZhciBkaXN0Um90YXRlID0gMDtcbiAgICB2YXIgc3RhcnRSb3RhdGlvbiA9IG1vdmVhYmxlLmdldFJvdGF0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQ29udHJvbDogdHJ1ZSxcbiAgICAgIHJlcXVlc3RTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhc1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChcImRlbHRhUm90YXRlXCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RSb3RhdGUgKz0gZS5kZWx0YVJvdGF0ZTtcbiAgICAgICAgfSBlbHNlIGlmIChcInJvdGF0ZVwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0Um90YXRlID0gZS5yb3RhdGUgLSBzdGFydFJvdGF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgcGFyZW50RGlzdDogZGlzdFJvdGF0ZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgaXNEcmFnOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSByb3RhdGVkLiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5Sb3RhdGFibGUjcm90YXRhYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnJvdGF0YWJsZSA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBZb3UgY2FuIHNwZWNpZnkgdGhlIHBvc2l0aW9uIG9mIHRoZSByb3RhdGlvbi4gKGRlZmF1bHQ6IFwidG9wXCIpXG4gKiBAbmFtZSBNb3ZlYWJsZS5Sb3RhdGFibGUjcm90YXRpb25Qb3NpdGlvblxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHJvdGF0aW9uUG9zaXRpb246IFwidG9wXCIsXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS5yb3RhdGlvblBvc2l0aW9uID0gXCJib3R0b21cIlxuICovXG5cbi8qKlxuICogdGhyb3R0bGUgb2YgYW5nbGUoZGVncmVlKSB3aGVuIHJvdGF0ZS5cbiAqIEBuYW1lIE1vdmVhYmxlLlJvdGF0YWJsZSN0aHJvdHRsZVJvdGF0ZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS50aHJvdHRsZVJvdGF0ZSA9IDE7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSByb3RhdGUgc3RhcnRzLCB0aGUgcm90YXRlU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdGF0YWJsZVxuICogQGV2ZW50IHJvdGF0ZVN0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdGF0YWJsZS5PblJvdGF0ZVN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByb3RhdGVTdGFydCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJvdGF0YWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKi9cblxuLyoqXG4qIFdoZW4gcm90YXRpbmcsIHRoZSByb3RhdGUgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUm90YXRhYmxlXG4qIEBldmVudCByb3RhdGVcbiogQHBhcmFtIHtNb3ZlYWJsZS5Sb3RhdGFibGUuT25Sb3RhdGV9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHJvdGF0ZSBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgcm90YXRhYmxlOiB0cnVlIH0pO1xuKiBtb3ZlYWJsZS5vbihcInJvdGF0ZVwiLCAoeyB0YXJnZXQsIHRyYW5zZm9ybSwgZGlzdCB9KSA9PiB7XG4qICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuKiB9KTtcbiovXG5cbi8qKlxuICogV2hlbiB0aGUgcm90YXRlIGZpbmlzaGVzLCB0aGUgcm90YXRlRW5kIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcbiAqIEBldmVudCByb3RhdGVFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm90YXRhYmxlLk9uUm90YXRlRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByb3RhdGVFbmQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByb3RhdGFibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJvdGF0ZUVuZFwiLCAoeyB0YXJnZXQsIGlzRHJhZyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0LCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBncm91cCByb3RhdGUgc3RhcnRzLCB0aGUgYHJvdGF0ZUdyb3VwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcbiAqIEBldmVudCByb3RhdGVHcm91cFN0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdGF0YWJsZS5PblJvdGF0ZUdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3RhdGVHcm91cFN0YXJ0YCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqICAgICByb3RhdGFibGU6IHRydWVcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3RhdGVHcm91cFN0YXJ0XCIsICh7IHRhcmdldHMgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25Sb3RhdGVHcm91cFN0YXJ0XCIsIHRhcmdldHMpO1xuICogfSk7XG4gKi9cblxuLyoqXG4qIFdoZW4gdGhlIGdyb3VwIHJvdGF0ZSwgdGhlIGByb3RhdGVHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUm90YXRhYmxlXG4qIEBldmVudCByb3RhdGVHcm91cFxuKiBAcGFyYW0ge01vdmVhYmxlLlJvdGF0YWJsZS5PblJvdGF0ZUdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcm90YXRlR3JvdXBgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiogICAgIHJvdGF0YWJsZTogdHJ1ZVxuKiB9KTtcbiogbW92ZWFibGUub24oXCJyb3RhdGVHcm91cFwiLCAoeyB0YXJnZXRzLCBldmVudHMgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2coXCJvblJvdGF0ZUdyb3VwXCIsIHRhcmdldHMpO1xuKiAgICAgZXZlbnRzLmZvckVhY2goZXYgPT4ge1xuKiAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldDtcbiogICAgICAgICAvLyBldi5kcmFnIGlzIGEgZHJhZyBldmVudCB0aGF0IG9jY3VycyB3aGVuIHRoZSBncm91cCByb3RhdGUuXG4qICAgICAgICAgY29uc3QgbGVmdCA9IGV2LmRyYWcuYmVmb3JlRGlzdFswXTtcbiogICAgICAgICBjb25zdCB0b3AgPSBldi5kcmFnLmJlZm9yZURpc3RbMV07XG4qICAgICAgICAgY29uc3QgZGVnID0gZXYuYmVmb3JlRGlzdDtcbiogICAgIH0pO1xuKiB9KTtcbiovXG5cbi8qKlxuICogV2hlbiB0aGUgZ3JvdXAgcm90YXRlIGZpbmlzaGVzLCB0aGUgYHJvdGF0ZUdyb3VwRW5kYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUm90YXRhYmxlXG4gKiBAZXZlbnQgcm90YXRlR3JvdXBFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm90YXRhYmxlLk9uUm90YXRlR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3RhdGVHcm91cEVuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiAgICAgcm90YXRhYmxlOiB0cnVlXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlR3JvdXBFbmRcIiwgKHsgdGFyZ2V0cywgaXNEcmFnIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUm90YXRlR3JvdXBFbmRcIiwgdGFyZ2V0cywgaXNEcmFnKTtcbiAqIH0pO1xuICovXG5cbnZhciBWRVJUSUNBTF9OQU1FUyA9IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImNlbnRlclwiXTtcbnZhciBIT1JJWk9OVEFMX05BTUVTID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibWlkZGxlXCJdO1xudmFyIFZFUlRJQ0FMX05BTUVTX01BUCA9IHtcbiAgc3RhcnQ6IFwibGVmdFwiLFxuICBlbmQ6IFwicmlnaHRcIixcbiAgY2VudGVyOiBcImNlbnRlclwiXG59O1xudmFyIEhPUklaT05UQUxfTkFNRVNfTUFQID0ge1xuICBzdGFydDogXCJ0b3BcIixcbiAgZW5kOiBcImJvdHRvbVwiLFxuICBjZW50ZXI6IFwibWlkZGxlXCJcbn07XG5cbmZ1bmN0aW9uIGhhc0d1aWRlbGluZXMobW92ZWFibGUsIGFibGVOYW1lKSB7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgc25hcHBhYmxlID0gX2Euc25hcHBhYmxlLFxuICAgICAgYm91bmRzID0gX2EuYm91bmRzLFxuICAgICAgaW5uZXJCb3VuZHMgPSBfYS5pbm5lckJvdW5kcyxcbiAgICAgIHZlcnRpY2FsR3VpZGVsaW5lcyA9IF9hLnZlcnRpY2FsR3VpZGVsaW5lcyxcbiAgICAgIGhvcml6b250YWxHdWlkZWxpbmVzID0gX2EuaG9yaXpvbnRhbEd1aWRlbGluZXMsXG4gICAgICBzbmFwR3JpZFdpZHRoID0gX2Euc25hcEdyaWRXaWR0aCxcbiAgICAgIHNuYXBHcmlkSGVpZ2h0ID0gX2Euc25hcEdyaWRIZWlnaHQsXG4gICAgICBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgZ3VpZGVsaW5lcyA9IF9iLmd1aWRlbGluZXMsXG4gICAgICBlbmFibGVTbmFwID0gX2IuZW5hYmxlU25hcDtcblxuICBpZiAoIXNuYXBwYWJsZSB8fCAhZW5hYmxlU25hcCB8fCBhYmxlTmFtZSAmJiBzbmFwcGFibGUgIT09IHRydWUgJiYgc25hcHBhYmxlLmluZGV4T2YoYWJsZU5hbWUpIDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzbmFwR3JpZFdpZHRoIHx8IHNuYXBHcmlkSGVpZ2h0IHx8IGJvdW5kcyB8fCBpbm5lckJvdW5kcyB8fCBndWlkZWxpbmVzICYmIGd1aWRlbGluZXMubGVuZ3RoIHx8IHZlcnRpY2FsR3VpZGVsaW5lcyAmJiB2ZXJ0aWNhbEd1aWRlbGluZXMubGVuZ3RoIHx8IGhvcml6b250YWxHdWlkZWxpbmVzICYmIGhvcml6b250YWxHdWlkZWxpbmVzLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRTbmFwRGlyZWN0aW9ucyhzbmFwRGlyZWN0aW9ucykge1xuICBpZiAoc25hcERpcmVjdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9IGVsc2UgaWYgKHNuYXBEaXJlY3Rpb25zID09PSB0cnVlIHx8ICFzbmFwRGlyZWN0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0cnVlLFxuICAgICAgcmlnaHQ6IHRydWUsXG4gICAgICB0b3A6IHRydWUsXG4gICAgICBib3R0b206IHRydWVcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHNuYXBEaXJlY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBtYXBTbmFwRGlyZWN0aW9uUG9zZXMoc25hcERpcmVjdGlvbnMsIHNuYXBQb3Nlcykge1xuICB2YXIgbmV4dFNuYXBEaXJlY3Rpb25zID0gZ2V0U25hcERpcmVjdGlvbnMoc25hcERpcmVjdGlvbnMpO1xuICB2YXIgbmV4dFNuYXBQb3NlcyA9IHt9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gbmV4dFNuYXBEaXJlY3Rpb25zKSB7XG4gICAgaWYgKG5hbWUgaW4gc25hcFBvc2VzICYmIG5leHRTbmFwRGlyZWN0aW9uc1tuYW1lXSkge1xuICAgICAgbmV4dFNuYXBQb3Nlc1tuYW1lXSA9IHNuYXBQb3Nlc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFNuYXBQb3Nlcztcbn1cblxuZnVuY3Rpb24gc3BsaXRTbmFwRGlyZWN0aW9uUG9zZXMoc25hcERpcmVjdGlvbnMsIHNuYXBQb3Nlcykge1xuICB2YXIgbmV4dFNuYXBQb3NlcyA9IG1hcFNuYXBEaXJlY3Rpb25Qb3NlcyhzbmFwRGlyZWN0aW9ucywgc25hcFBvc2VzKTtcbiAgdmFyIGhvcml6b250YWxOYW1lcyA9IEhPUklaT05UQUxfTkFNRVMuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gbmV4dFNuYXBQb3NlcztcbiAgfSk7XG4gIHZhciB2ZXJ0aWNhbE5hbWVzID0gVkVSVElDQUxfTkFNRVMuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gbmV4dFNuYXBQb3NlcztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbE5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5leHRTbmFwUG9zZXNbbmFtZV07XG4gICAgfSksXG4gICAgdmVydGljYWw6IHZlcnRpY2FsTmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmV4dFNuYXBQb3Nlc1tuYW1lXTtcbiAgICB9KVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRHYXBHdWlkZWxpbmVzKG1vdmVhYmxlLCB0YXJnZXRSZWN0LCBzbmFwVGhyZXNob2xkKSB7XG4gIHZhciBlbGVtZW50UmVjdHMgPSBtb3ZlYWJsZS5zdGF0ZS5lbGVtZW50UmVjdHM7XG4gIHZhciBnYXBHdWlkZWxpbmVzID0gW107XG4gIFtbXCJ2ZXJ0aWNhbFwiLCBWRVJUSUNBTF9OQU1FU19NQVAsIEhPUklaT05UQUxfTkFNRVNfTUFQXSwgW1wiaG9yaXpvbnRhbFwiLCBIT1JJWk9OVEFMX05BTUVTX01BUCwgVkVSVElDQUxfTkFNRVNfTUFQXV0uZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdHlwZSA9IF9hWzBdLFxuICAgICAgICBtYWluTmFtZXMgPSBfYVsxXSxcbiAgICAgICAgc2lkZU5hbWVzID0gX2FbMl07XG4gICAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuc3RhcnRdO1xuICAgIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5lbmRdO1xuICAgIHZhciB0YXJnZXRDZW50ZXIgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5jZW50ZXJdO1xuICAgIHZhciB0YXJnZXRTdGFydDIgPSB0YXJnZXRSZWN0W3NpZGVOYW1lcy5zdGFydF07XG4gICAgdmFyIHRhcmdldEVuZDIgPSB0YXJnZXRSZWN0W3NpZGVOYW1lcy5lbmRdOyAvLyBlbGVtZW50IDogbW92ZWFibGVcblxuICAgIGZ1bmN0aW9uIGdldERpc3QoZWxlbWVudFJlY3QpIHtcbiAgICAgIHZhciByZWN0ID0gZWxlbWVudFJlY3QucmVjdDtcblxuICAgICAgaWYgKHJlY3RbbWFpbk5hbWVzLmVuZF0gPCB0YXJnZXRTdGFydCArIHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXJ0IC0gcmVjdFttYWluTmFtZXMuZW5kXTtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0RW5kIC0gc25hcFRocmVzaG9sZCA8IHJlY3RbbWFpbk5hbWVzLnN0YXJ0XSkge1xuICAgICAgICByZXR1cm4gcmVjdFttYWluTmFtZXMuc3RhcnRdIC0gdGFyZ2V0RW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0RWxlbWVudFJlY3RzID0gZWxlbWVudFJlY3RzLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudFJlY3QpIHtcbiAgICAgIHZhciByZWN0ID0gZWxlbWVudFJlY3QucmVjdDtcblxuICAgICAgaWYgKHJlY3Rbc2lkZU5hbWVzLnN0YXJ0XSA+IHRhcmdldEVuZDIgfHwgcmVjdFtzaWRlTmFtZXMuZW5kXSA8IHRhcmdldFN0YXJ0Mikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXREaXN0KGVsZW1lbnRSZWN0KSA+IDA7XG4gICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGdldERpc3QoYSkgLSBnZXREaXN0KGIpO1xuICAgIH0pO1xuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICBuZXh0RWxlbWVudFJlY3RzLmZvckVhY2goZnVuY3Rpb24gKHNuYXBSZWN0MSkge1xuICAgICAgbmV4dEVsZW1lbnRSZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChzbmFwUmVjdDIpIHtcbiAgICAgICAgaWYgKHNuYXBSZWN0MSA9PT0gc25hcFJlY3QyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3QxID0gc25hcFJlY3QxLnJlY3Q7XG4gICAgICAgIHZhciByZWN0MiA9IHNuYXBSZWN0Mi5yZWN0O1xuICAgICAgICB2YXIgcmVjdDFTdGFydCA9IHJlY3QxW3NpZGVOYW1lcy5zdGFydF07XG4gICAgICAgIHZhciByZWN0MUVuZCA9IHJlY3QxW3NpZGVOYW1lcy5lbmRdO1xuICAgICAgICB2YXIgcmVjdDJTdGFydCA9IHJlY3QyW3NpZGVOYW1lcy5zdGFydF07XG4gICAgICAgIHZhciByZWN0MkVuZCA9IHJlY3QyW3NpZGVOYW1lcy5lbmRdO1xuXG4gICAgICAgIGlmIChyZWN0MVN0YXJ0ID4gcmVjdDJFbmQgfHwgcmVjdDJTdGFydCA+IHJlY3QxRW5kKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdXBzLnB1c2goW3NuYXBSZWN0MSwgc25hcFJlY3QyXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBzbmFwUmVjdDEgPSBfYVswXSxcbiAgICAgICAgICBzbmFwUmVjdDIgPSBfYVsxXTtcbiAgICAgIHZhciByZWN0MSA9IHNuYXBSZWN0MS5yZWN0O1xuICAgICAgdmFyIHJlY3QyID0gc25hcFJlY3QyLnJlY3Q7XG4gICAgICB2YXIgcmVjdDFTdGFydCA9IHJlY3QxW21haW5OYW1lcy5zdGFydF07XG4gICAgICB2YXIgcmVjdDFFbmQgPSByZWN0MVttYWluTmFtZXMuZW5kXTtcbiAgICAgIHZhciByZWN0MlN0YXJ0ID0gcmVjdDJbbWFpbk5hbWVzLnN0YXJ0XTtcbiAgICAgIHZhciByZWN0MkVuZCA9IHJlY3QyW21haW5OYW1lcy5lbmRdO1xuICAgICAgdmFyIGdhcCA9IDA7XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHZhciBpc1N0YXJ0ID0gZmFsc2U7XG4gICAgICB2YXIgaXNDZW50ZXIgPSBmYWxzZTtcbiAgICAgIHZhciBpc0VuZCA9IGZhbHNlO1xuXG4gICAgICBpZiAocmVjdDFFbmQgPD0gdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0RW5kIDw9IHJlY3QyU3RhcnQpIHtcbiAgICAgICAgLy8gKGwpZWxlbWVudDEocikgOiAobCl0YXJnZXQocikgOiAobCllbGVtZW50MihyKVxuICAgICAgICBpc0NlbnRlciA9IHRydWU7XG4gICAgICAgIGdhcCA9IChyZWN0MlN0YXJ0IC0gcmVjdDFFbmQgLSAodGFyZ2V0RW5kIC0gdGFyZ2V0U3RhcnQpKSAvIDI7XG4gICAgICAgIHBvcyA9IHJlY3QxRW5kICsgZ2FwICsgKHRhcmdldEVuZCAtIHRhcmdldFN0YXJ0KSAvIDI7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHBvcyAtIHRhcmdldENlbnRlcikgPiBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlY3QxRW5kIDwgcmVjdDJTdGFydCAmJiByZWN0MkVuZCA8IHRhcmdldFN0YXJ0ICsgc25hcFRocmVzaG9sZCkge1xuICAgICAgICAvLyAobCllbGVtZW50MShyKSA6IChsKWVsZW1lbnQyKHIpIDogKGwpdGFyZ2V0XG4gICAgICAgIGlzU3RhcnQgPSB0cnVlO1xuICAgICAgICBnYXAgPSByZWN0MlN0YXJ0IC0gcmVjdDFFbmQ7XG4gICAgICAgIHBvcyA9IHJlY3QyRW5kICsgZ2FwO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhwb3MgLSB0YXJnZXRTdGFydCkgPiBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlY3QxRW5kIDwgcmVjdDJTdGFydCAmJiB0YXJnZXRFbmQgLSBzbmFwVGhyZXNob2xkIDwgcmVjdDFTdGFydCkge1xuICAgICAgICAvLyB0YXJnZXQocikgOiAobCllbGVtZW50MShyKSA6IChsKWVsZW1lbnQyKHIpXG4gICAgICAgIGlzRW5kID0gdHJ1ZTtcbiAgICAgICAgZ2FwID0gcmVjdDJTdGFydCAtIHJlY3QxRW5kO1xuICAgICAgICBwb3MgPSByZWN0MVN0YXJ0IC0gZ2FwO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhwb3MgLSB0YXJnZXRFbmQpID4gc25hcFRocmVzaG9sZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdhcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGdhcEd1aWRlbGluZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHBvczogdHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gW3BvcywgMF0gOiBbMCwgcG9zXSxcbiAgICAgICAgZWxlbWVudDogc25hcFJlY3QyLmVsZW1lbnQsXG4gICAgICAgIHNpemU6IDAsXG4gICAgICAgIGNsYXNzTmFtZTogc25hcFJlY3QyLmNsYXNzTmFtZSxcbiAgICAgICAgaXNTdGFydDogaXNTdGFydCxcbiAgICAgICAgaXNDZW50ZXI6IGlzQ2VudGVyLFxuICAgICAgICBpc0VuZDogaXNFbmQsXG4gICAgICAgIGdhcDogZ2FwLFxuICAgICAgICBoaWRlOiB0cnVlLFxuICAgICAgICBnYXBSZWN0czogW3NuYXBSZWN0MSwgc25hcFJlY3QyXVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZ2FwR3VpZGVsaW5lcztcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEd1aWRlbGluZXMoaG9yaXpvbnRhbEd1aWRlbGluZXMsIHZlcnRpY2FsR3VpZGVsaW5lcywgd2lkdGgsIGhlaWdodCwgY2xpZW50TGVmdCwgY2xpZW50VG9wLCBzbmFwT2Zmc2V0KSB7XG4gIGlmIChjbGllbnRMZWZ0ID09PSB2b2lkIDApIHtcbiAgICBjbGllbnRMZWZ0ID0gMDtcbiAgfVxuXG4gIGlmIChjbGllbnRUb3AgPT09IHZvaWQgMCkge1xuICAgIGNsaWVudFRvcCA9IDA7XG4gIH1cblxuICBpZiAoc25hcE9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgc25hcE9mZnNldCA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gIH1cblxuICB2YXIgZ3VpZGVsaW5lcyA9IFtdO1xuICB2YXIgc25hcE9mZnNldExlZnQgPSBzbmFwT2Zmc2V0LmxlZnQsXG4gICAgICBzbmFwT2Zmc2V0VG9wID0gc25hcE9mZnNldC50b3AsXG4gICAgICBzbmFwT2Zmc2V0Qm90dG9tID0gc25hcE9mZnNldC5ib3R0b20sXG4gICAgICBzbmFwT2Zmc2V0UmlnaHQgPSBzbmFwT2Zmc2V0LnJpZ2h0O1xuICB2YXIgc25hcFdpZHRoID0gd2lkdGggKyBzbmFwT2Zmc2V0UmlnaHQgLSBzbmFwT2Zmc2V0TGVmdDtcbiAgdmFyIHNuYXBIZWlnaHQgPSBoZWlnaHQgKyBzbmFwT2Zmc2V0Qm90dG9tIC0gc25hcE9mZnNldFRvcDtcbiAgaG9yaXpvbnRhbEd1aWRlbGluZXMgJiYgaG9yaXpvbnRhbEd1aWRlbGluZXMuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgZ3VpZGVsaW5lcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgcG9zOiBbc25hcE9mZnNldExlZnQsIHRocm90dGxlKHBvcyAtIGNsaWVudFRvcCArIHNuYXBPZmZzZXRUb3AsIDAuMSldLFxuICAgICAgc2l6ZTogc25hcFdpZHRoXG4gICAgfSk7XG4gIH0pO1xuICB2ZXJ0aWNhbEd1aWRlbGluZXMgJiYgdmVydGljYWxHdWlkZWxpbmVzLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgIGd1aWRlbGluZXMucHVzaCh7XG4gICAgICB0eXBlOiBcInZlcnRpY2FsXCIsXG4gICAgICBwb3M6IFt0aHJvdHRsZShwb3MgLSBjbGllbnRMZWZ0ICsgc25hcE9mZnNldExlZnQsIDAuMSksIHNuYXBPZmZzZXRUb3BdLFxuICAgICAgc2l6ZTogc25hcEhlaWdodFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGd1aWRlbGluZXM7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRhaW5lclBvcyhyb290TWF0cml4LCBjb250YWluZXJSZWN0LCBuKSB7XG4gIHZhciBjbGllbnRQb3MgPSBjYWxjdWxhdGVQb3NpdGlvbihyb290TWF0cml4LCBbY29udGFpbmVyUmVjdC5jbGllbnRMZWZ0LCBjb250YWluZXJSZWN0LmNsaWVudFRvcF0sIG4pO1xuICByZXR1cm4gW2NvbnRhaW5lclJlY3QubGVmdCArIGNsaWVudFBvc1swXSwgY29udGFpbmVyUmVjdC50b3AgKyBjbGllbnRQb3NbMV1dO1xufVxuXG5mdW5jdGlvbiBnZXRTbmFwRWxlbWVudFJlY3RzKG1vdmVhYmxlLCB2YWx1ZXMpIHtcbiAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gIHZhciBjb250YWluZXJDbGllbnRSZWN0ID0gc3RhdGUuY29udGFpbmVyQ2xpZW50UmVjdCxcbiAgICAgIF9hID0gc3RhdGUudGFyZ2V0Q2xpZW50UmVjdCxcbiAgICAgIGNsaWVudFRvcCA9IF9hLnRvcCxcbiAgICAgIGNsaWVudExlZnQgPSBfYS5sZWZ0LFxuICAgICAgcm9vdE1hdHJpeCA9IHN0YXRlLnJvb3RNYXRyaXgsXG4gICAgICBpczNkID0gc3RhdGUuaXMzZDtcbiAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG5cbiAgdmFyIF9iID0gY2FsY3VsYXRlQ29udGFpbmVyUG9zKHJvb3RNYXRyaXgsIGNvbnRhaW5lckNsaWVudFJlY3QsIG4pLFxuICAgICAgY29udGFpbmVyTGVmdCA9IF9iWzBdLFxuICAgICAgY29udGFpbmVyVG9wID0gX2JbMV07XG5cbiAgdmFyIHBvc2VzID0gZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUoc3RhdGUpO1xuXG4gIHZhciBfYyA9IGdldE1pbk1heHMocG9zZXMpLFxuICAgICAgdGFyZ2V0TGVmdCA9IF9jLm1pblgsXG4gICAgICB0YXJnZXRUb3AgPSBfYy5taW5ZO1xuXG4gIHZhciBfZCA9IG1pbnVzKFt0YXJnZXRMZWZ0LCB0YXJnZXRUb3BdLCBjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW2NsaWVudExlZnQgLSBjb250YWluZXJMZWZ0LCBjbGllbnRUb3AgLSBjb250YWluZXJUb3BdLCBuKSkubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcm91bmRTaWduKHBvcyk7XG4gIH0pLFxuICAgICAgZGlzdExlZnQgPSBfZFswXSxcbiAgICAgIGRpc3RUb3AgPSBfZFsxXTtcblxuICByZXR1cm4gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVjdCA9IHZhbHVlLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGxlZnQgPSByZWN0LmxlZnQgLSBjb250YWluZXJMZWZ0O1xuICAgIHZhciB0b3AgPSByZWN0LnRvcCAtIGNvbnRhaW5lclRvcDtcbiAgICB2YXIgYm90dG9tID0gdG9wICsgcmVjdC5oZWlnaHQ7XG4gICAgdmFyIHJpZ2h0ID0gbGVmdCArIHJlY3Qud2lkdGg7XG5cbiAgICB2YXIgX2EgPSBjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW2xlZnQsIHRvcF0sIG4pLFxuICAgICAgICBlbGVtZW50TGVmdCA9IF9hWzBdLFxuICAgICAgICBlbGVtZW50VG9wID0gX2FbMV07XG5cbiAgICB2YXIgX2IgPSBjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW3JpZ2h0LCBib3R0b21dLCBuKSxcbiAgICAgICAgZWxlbWVudFJpZ2h0ID0gX2JbMF0sXG4gICAgICAgIGVsZW1lbnRCb3R0b20gPSBfYlsxXTtcblxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdmFsdWUpLCB7XG4gICAgICByZWN0OiB7XG4gICAgICAgIGxlZnQ6IGVsZW1lbnRMZWZ0ICsgZGlzdExlZnQsXG4gICAgICAgIHJpZ2h0OiBlbGVtZW50UmlnaHQgKyBkaXN0TGVmdCxcbiAgICAgICAgdG9wOiBlbGVtZW50VG9wICsgZGlzdFRvcCxcbiAgICAgICAgYm90dG9tOiBlbGVtZW50Qm90dG9tICsgZGlzdFRvcCxcbiAgICAgICAgY2VudGVyOiAoZWxlbWVudExlZnQgKyBlbGVtZW50UmlnaHQpIC8gMiArIGRpc3RMZWZ0LFxuICAgICAgICBtaWRkbGU6IChlbGVtZW50VG9wICsgZWxlbWVudEJvdHRvbSkgLyAyICsgZGlzdFRvcFxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEd1aWRlbGluZXMobW92ZWFibGUpIHtcbiAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLmVsZW1lbnRHdWlkZWxpbmVzLFxuICAgICAgZWxlbWVudEd1aWRlbGluZXMgPSBfYSA9PT0gdm9pZCAwID8gW10gOiBfYTtcblxuICBpZiAoIWVsZW1lbnRHdWlkZWxpbmVzLmxlbmd0aCkge1xuICAgIHN0YXRlLmVsZW1lbnRSZWN0cyA9IFtdO1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBwcmV2VmFsdWVzID0gKHN0YXRlLmVsZW1lbnRSZWN0cyB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChzbmFwUmVjdCkge1xuICAgIHJldHVybiAhc25hcFJlY3QucmVmcmVzaDtcbiAgfSk7XG4gIHZhciBuZXh0RWxlbWVudEd1aWRlbGluZXMgPSBlbGVtZW50R3VpZGVsaW5lcy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGlzT2JqZWN0KGVsKSAmJiBcImVsZW1lbnRcIiBpbiBlbCkge1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBnZXRSZWZUYXJnZXQoZWwsIHRydWUpXG4gICAgfTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5lbGVtZW50O1xuICB9KTtcblxuICB2YXIgX2IgPSBkaWZmKHByZXZWYWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYuZWxlbWVudDtcbiAgfSksIG5leHRFbGVtZW50R3VpZGVsaW5lcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdi5lbGVtZW50O1xuICB9KSksXG4gICAgICBtYWludGFpbmVkID0gX2IubWFpbnRhaW5lZCxcbiAgICAgIGFkZGVkID0gX2IuYWRkZWQ7XG5cbiAgdmFyIG5leHRWYWx1ZXMgPSBbXTtcbiAgbWFpbnRhaW5lZC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwcmV2SW5kZXggPSBfYVswXSxcbiAgICAgICAgbmV4dEluZGV4ID0gX2FbMV07XG4gICAgbmV4dFZhbHVlc1tuZXh0SW5kZXhdID0gcHJldlZhbHVlc1twcmV2SW5kZXhdO1xuICB9KTtcbiAgZ2V0U25hcEVsZW1lbnRSZWN0cyhtb3ZlYWJsZSwgYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBuZXh0RWxlbWVudEd1aWRlbGluZXNbaW5kZXhdO1xuICB9KSkubWFwKGZ1bmN0aW9uIChyZWN0LCBpKSB7XG4gICAgbmV4dFZhbHVlc1thZGRlZFtpXV0gPSByZWN0O1xuICB9KTtcbiAgc3RhdGUuZWxlbWVudFJlY3RzID0gbmV4dFZhbHVlcztcbiAgdmFyIGVsZW1lbnRTbmFwRGlyZWN0aW9ucyA9IGdldFNuYXBEaXJlY3Rpb25zKG1vdmVhYmxlLnByb3BzLmVsZW1lbnRTbmFwRGlyZWN0aW9ucyk7XG4gIHZhciBuZXh0R3VpZGVsaW5lcyA9IFtdO1xuICBuZXh0VmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHNuYXBSZWN0KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBzbmFwUmVjdC5lbGVtZW50LFxuICAgICAgICBfYSA9IHNuYXBSZWN0LnRvcCxcbiAgICAgICAgdG9wVmFsdWUgPSBfYSA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLnRvcCA6IF9hLFxuICAgICAgICBfYiA9IHNuYXBSZWN0LmxlZnQsXG4gICAgICAgIGxlZnRWYWx1ZSA9IF9iID09PSB2b2lkIDAgPyBlbGVtZW50U25hcERpcmVjdGlvbnMubGVmdCA6IF9iLFxuICAgICAgICBfYyA9IHNuYXBSZWN0LnJpZ2h0LFxuICAgICAgICByaWdodFZhbHVlID0gX2MgPT09IHZvaWQgMCA/IGVsZW1lbnRTbmFwRGlyZWN0aW9ucy5yaWdodCA6IF9jLFxuICAgICAgICBfZCA9IHNuYXBSZWN0LmJvdHRvbSxcbiAgICAgICAgYm90dG9tVmFsdWUgPSBfZCA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLmJvdHRvbSA6IF9kLFxuICAgICAgICBfZSA9IHNuYXBSZWN0LmNlbnRlcixcbiAgICAgICAgY2VudGVyVmFsdWUgPSBfZSA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLmNlbnRlciA6IF9lLFxuICAgICAgICBfZiA9IHNuYXBSZWN0Lm1pZGRsZSxcbiAgICAgICAgbWlkZGxlVmFsdWUgPSBfZiA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLm1pZGRsZSA6IF9mLFxuICAgICAgICBjbGFzc05hbWUgPSBzbmFwUmVjdC5jbGFzc05hbWUsXG4gICAgICAgIHJlY3QgPSBzbmFwUmVjdC5yZWN0O1xuXG4gICAgdmFyIF9nID0gc3BsaXRTbmFwRGlyZWN0aW9uUG9zZXMoe1xuICAgICAgdG9wOiB0b3BWYWx1ZSxcbiAgICAgIHJpZ2h0OiByaWdodFZhbHVlLFxuICAgICAgbGVmdDogbGVmdFZhbHVlLFxuICAgICAgYm90dG9tOiBib3R0b21WYWx1ZSxcbiAgICAgIGNlbnRlcjogY2VudGVyVmFsdWUsXG4gICAgICBtaWRkbGU6IG1pZGRsZVZhbHVlXG4gICAgfSwgcmVjdCksXG4gICAgICAgIGhvcml6b250YWwgPSBfZy5ob3Jpem9udGFsLFxuICAgICAgICB2ZXJ0aWNhbCA9IF9nLnZlcnRpY2FsO1xuXG4gICAgdmFyIHJlY3RUb3AgPSByZWN0LnRvcDtcbiAgICB2YXIgcmVjdExlZnQgPSByZWN0LmxlZnQ7XG4gICAgdmFyIHdpZHRoID0gcmVjdC5yaWdodCAtIHJlY3RMZWZ0O1xuICAgIHZhciBoZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3RUb3A7XG4gICAgdmFyIHNpemVzID0gW3dpZHRoLCBoZWlnaHRdO1xuICAgIHZlcnRpY2FsLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgICAgbmV4dEd1aWRlbGluZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidmVydGljYWxcIixcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgcG9zOiBbdGhyb3R0bGUocG9zLCAwLjEpLCByZWN0VG9wXSxcbiAgICAgICAgc2l6ZTogaGVpZ2h0LFxuICAgICAgICBzaXplczogc2l6ZXMsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBlbGVtZW50UmVjdDogc25hcFJlY3RcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGhvcml6b250YWwuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICBuZXh0R3VpZGVsaW5lcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJob3Jpem9udGFsXCIsXG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIHBvczogW3JlY3RMZWZ0LCB0aHJvdHRsZShwb3MsIDAuMSldLFxuICAgICAgICBzaXplOiB3aWR0aCxcbiAgICAgICAgc2l6ZXM6IHNpemVzLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgZWxlbWVudFJlY3Q6IHNuYXBSZWN0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBuZXh0R3VpZGVsaW5lcztcbn1cblxuZnVuY3Rpb24gZ2V0VG90YWxHdWlkZWxpbmVzKG1vdmVhYmxlKSB7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgc25hcE9mZnNldCA9IF9hLnNuYXBPZmZzZXQsXG4gICAgICBfYiA9IF9hLmNvbnRhaW5lckNsaWVudFJlY3QsXG4gICAgICBvdmVyZmxvdyA9IF9iLm92ZXJmbG93LFxuICAgICAgY29udGFpbmVySGVpZ2h0ID0gX2Iuc2Nyb2xsSGVpZ2h0LFxuICAgICAgY29udGFpbmVyV2lkdGggPSBfYi5zY3JvbGxXaWR0aCxcbiAgICAgIGNvbnRhaW5lckNsaWVudEhlaWdodCA9IF9iLmNsaWVudEhlaWdodCxcbiAgICAgIGNvbnRhaW5lckNsaWVudFdpZHRoID0gX2IuY2xpZW50V2lkdGgsXG4gICAgICBjbGllbnRMZWZ0ID0gX2IuY2xpZW50TGVmdCxcbiAgICAgIGNsaWVudFRvcCA9IF9iLmNsaWVudFRvcDtcbiAgdmFyIF9jID0gbW92ZWFibGUucHJvcHMsXG4gICAgICBfZCA9IF9jLnNuYXBHYXAsXG4gICAgICBzbmFwR2FwID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCxcbiAgICAgIHZlcnRpY2FsR3VpZGVsaW5lcyA9IF9jLnZlcnRpY2FsR3VpZGVsaW5lcyxcbiAgICAgIGhvcml6b250YWxHdWlkZWxpbmVzID0gX2MuaG9yaXpvbnRhbEd1aWRlbGluZXMsXG4gICAgICBfZSA9IF9jLnNuYXBUaHJlc2hvbGQsXG4gICAgICBzbmFwVGhyZXNob2xkID0gX2UgPT09IHZvaWQgMCA/IDUgOiBfZSxcbiAgICAgIF9mID0gX2Muc25hcEdyaWRXaWR0aCxcbiAgICAgIHNuYXBHcmlkV2lkdGggPSBfZiA9PT0gdm9pZCAwID8gMCA6IF9mLFxuICAgICAgX2cgPSBfYy5zbmFwR3JpZEhlaWdodCxcbiAgICAgIHNuYXBHcmlkSGVpZ2h0ID0gX2cgPT09IHZvaWQgMCA/IDAgOiBfZztcbiAgdmFyIGVsZW1lbnRHdWlkZWxpbmVzID0gZ2V0RWxlbWVudEd1aWRlbGluZXMobW92ZWFibGUpO1xuXG4gIHZhciB0b3RhbEd1aWRlbGluZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBlbGVtZW50R3VpZGVsaW5lcywgdHJ1ZSk7XG5cbiAgaWYgKHNuYXBHYXApIHtcbiAgICB2YXIgX2ggPSBnZXRSZWN0KGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKSksXG4gICAgICAgIHRvcCA9IF9oLnRvcCxcbiAgICAgICAgbGVmdCA9IF9oLmxlZnQsXG4gICAgICAgIGJvdHRvbSA9IF9oLmJvdHRvbSxcbiAgICAgICAgcmlnaHQgPSBfaC5yaWdodDtcblxuICAgIHRvdGFsR3VpZGVsaW5lcy5wdXNoLmFwcGx5KHRvdGFsR3VpZGVsaW5lcywgZ2V0R2FwR3VpZGVsaW5lcyhtb3ZlYWJsZSwge1xuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICByaWdodDogcmlnaHQsXG4gICAgICBjZW50ZXI6IChsZWZ0ICsgcmlnaHQpIC8gMixcbiAgICAgIG1pZGRsZTogKHRvcCArIGJvdHRvbSkgLyAyXG4gICAgfSwgc25hcFRocmVzaG9sZCkpO1xuICB9XG5cbiAgdG90YWxHdWlkZWxpbmVzLnB1c2guYXBwbHkodG90YWxHdWlkZWxpbmVzLCBnZXRHcmlkR3VpZGVsaW5lcyhzbmFwR3JpZFdpZHRoLCBzbmFwR3JpZEhlaWdodCwgb3ZlcmZsb3cgPyBjb250YWluZXJXaWR0aCA6IGNvbnRhaW5lckNsaWVudFdpZHRoLCBvdmVyZmxvdyA/IGNvbnRhaW5lckhlaWdodCA6IGNvbnRhaW5lckNsaWVudEhlaWdodCwgY2xpZW50TGVmdCwgY2xpZW50VG9wKSk7XG4gIHRvdGFsR3VpZGVsaW5lcy5wdXNoLmFwcGx5KHRvdGFsR3VpZGVsaW5lcywgZ2V0RGVmYXVsdEd1aWRlbGluZXMoaG9yaXpvbnRhbEd1aWRlbGluZXMgfHwgZmFsc2UsIHZlcnRpY2FsR3VpZGVsaW5lcyB8fCBmYWxzZSwgb3ZlcmZsb3cgPyBjb250YWluZXJXaWR0aCA6IGNvbnRhaW5lckNsaWVudFdpZHRoLCBvdmVyZmxvdyA/IGNvbnRhaW5lckhlaWdodCA6IGNvbnRhaW5lckNsaWVudEhlaWdodCwgY2xpZW50TGVmdCwgY2xpZW50VG9wLCBzbmFwT2Zmc2V0KSk7XG4gIHJldHVybiB0b3RhbEd1aWRlbGluZXM7XG59XG5cbmZ1bmN0aW9uIGdldEdyaWRHdWlkZWxpbmVzKHNuYXBHcmlkV2lkdGgsIHNuYXBHcmlkSGVpZ2h0LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0LCBjbGllbnRMZWZ0LCBjbGllbnRUb3ApIHtcbiAgaWYgKGNsaWVudExlZnQgPT09IHZvaWQgMCkge1xuICAgIGNsaWVudExlZnQgPSAwO1xuICB9XG5cbiAgaWYgKGNsaWVudFRvcCA9PT0gdm9pZCAwKSB7XG4gICAgY2xpZW50VG9wID0gMDtcbiAgfVxuXG4gIHZhciBndWlkZWxpbmVzID0gW107XG5cbiAgaWYgKHNuYXBHcmlkSGVpZ2h0KSB7XG4gICAgZm9yICh2YXIgcG9zID0gMDsgcG9zIDw9IGNvbnRhaW5lckhlaWdodDsgcG9zICs9IHNuYXBHcmlkSGVpZ2h0KSB7XG4gICAgICBndWlkZWxpbmVzLnB1c2goe1xuICAgICAgICB0eXBlOiBcImhvcml6b250YWxcIixcbiAgICAgICAgcG9zOiBbMCwgdGhyb3R0bGUocG9zIC0gY2xpZW50VG9wLCAwLjEpXSxcbiAgICAgICAgc2l6ZTogY29udGFpbmVyV2lkdGgsXG4gICAgICAgIGhpZGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzbmFwR3JpZFdpZHRoKSB7XG4gICAgZm9yICh2YXIgcG9zID0gMDsgcG9zIDw9IGNvbnRhaW5lcldpZHRoOyBwb3MgKz0gc25hcEdyaWRXaWR0aCkge1xuICAgICAgZ3VpZGVsaW5lcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgICBwb3M6IFt0aHJvdHRsZShwb3MgLSBjbGllbnRMZWZ0LCAwLjEpLCAwXSxcbiAgICAgICAgc2l6ZTogY29udGFpbmVySGVpZ2h0LFxuICAgICAgICBoaWRlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ3VpZGVsaW5lcztcbn1cblxuZnVuY3Rpb24gc29sdmVMaW5lQ29uc3RhbnRzKF9hKSB7XG4gIHZhciBwb2ludDEgPSBfYVswXSxcbiAgICAgIHBvaW50MiA9IF9hWzFdO1xuICB2YXIgZHggPSBwb2ludDJbMF0gLSBwb2ludDFbMF07XG4gIHZhciBkeSA9IHBvaW50MlsxXSAtIHBvaW50MVsxXTtcblxuICBpZiAoTWF0aC5hYnMoZHgpIDwgVElOWV9OVU0kMSkge1xuICAgIGR4ID0gMDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhkeSkgPCBUSU5ZX05VTSQxKSB7XG4gICAgZHkgPSAwO1xuICB9IC8vIGIgPiAwXG4gIC8vIGF4ICsgYnkgKyBjID0gMFxuXG5cbiAgdmFyIGEgPSAwO1xuICB2YXIgYiA9IDA7XG4gIHZhciBjID0gMDtcblxuICBpZiAoIWR4KSB7XG4gICAgLy8gLXggKyAxID0gMFxuICAgIGEgPSAtMTtcbiAgICBjID0gcG9pbnQxWzBdO1xuICB9IGVsc2UgaWYgKCFkeSkge1xuICAgIC8vIHkgLSAxID0gMFxuICAgIGIgPSAxO1xuICAgIGMgPSAtcG9pbnQxWzFdO1xuICB9IGVsc2Uge1xuICAgIC8vIHkgPSAtYSh4IC0geDEpICsgeTFcbiAgICAvLyBheCArIHkgKyBhICogeDEgLSB5MSA9IDBcbiAgICBhID0gLWR5IC8gZHg7XG4gICAgYiA9IDE7XG4gICAgYyA9IGEgKiBwb2ludDFbMF0gLSBwb2ludDFbMV07XG4gIH1cblxuICByZXR1cm4gW2EsIGIsIGNdLm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB0aHJvdHRsZSh2LCBUSU5ZX05VTSQxKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrTW92ZWFibGVTbmFwUG9zZXMobW92ZWFibGUsIHBvc2VzWCwgcG9zZXNZLCBjdXN0b21TbmFwVGhyZXNob2xkKSB7XG4gIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xuICB2YXIgc25hcFRocmVzaG9sZCA9IHNlbGVjdFZhbHVlKGN1c3RvbVNuYXBUaHJlc2hvbGQsIHByb3BzLnNuYXBUaHJlc2hvbGQsIDUpO1xuICByZXR1cm4gY2hlY2tTbmFwUG9zZXMobW92ZWFibGUuc3RhdGUuZ3VpZGVsaW5lcywgcG9zZXNYLCBwb3Nlc1ksIHNuYXBUaHJlc2hvbGQpO1xufVxuXG5mdW5jdGlvbiBjaGVja1NuYXBQb3NlcyhndWlkZWxpbmVzLCBwb3Nlc1gsIHBvc2VzWSwgc25hcFRocmVzaG9sZCkge1xuICByZXR1cm4ge1xuICAgIHZlcnRpY2FsOiBjaGVja1NuYXAoZ3VpZGVsaW5lcywgXCJ2ZXJ0aWNhbFwiLCBwb3Nlc1gsIHNuYXBUaHJlc2hvbGQpLFxuICAgIGhvcml6b250YWw6IGNoZWNrU25hcChndWlkZWxpbmVzLCBcImhvcml6b250YWxcIiwgcG9zZXNZLCBzbmFwVGhyZXNob2xkKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja1NuYXBLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgdmFyIGVuZFggPSBlbmRQb3NbMF0sXG4gICAgICBlbmRZID0gZW5kUG9zWzFdO1xuICB2YXIgc3RhcnRYID0gc3RhcnRQb3NbMF0sXG4gICAgICBzdGFydFkgPSBzdGFydFBvc1sxXTtcblxuICB2YXIgX2EgPSBtaW51cyhlbmRQb3MsIHN0YXJ0UG9zKSxcbiAgICAgIGR4ID0gX2FbMF0sXG4gICAgICBkeSA9IF9hWzFdO1xuXG4gIHZhciBpc0JvdHRvbSA9IGR5ID4gMDtcbiAgdmFyIGlzUmlnaHQgPSBkeCA+IDA7XG4gIGR4ID0gZ2V0VGlueURpc3QoZHgpO1xuICBkeSA9IGdldFRpbnlEaXN0KGR5KTtcbiAgdmFyIHZlcnRpY2FsSW5mbyA9IHtcbiAgICBpc1NuYXA6IGZhbHNlLFxuICAgIG9mZnNldDogMCxcbiAgICBwb3M6IDBcbiAgfTtcbiAgdmFyIGhvcml6b250YWxJbmZvID0ge1xuICAgIGlzU25hcDogZmFsc2UsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHBvczogMFxuICB9O1xuXG4gIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0aWNhbDogdmVydGljYWxJbmZvLFxuICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEluZm9cbiAgICB9O1xuICB9XG5cbiAgdmFyIF9iID0gY2hlY2tNb3ZlYWJsZVNuYXBQb3Nlcyhtb3ZlYWJsZSwgZHggPyBbZW5kWF0gOiBbXSwgZHkgPyBbZW5kWV0gOiBbXSksXG4gICAgICB2ZXJ0aWNhbFNuYXBJbmZvID0gX2IudmVydGljYWwsXG4gICAgICBob3Jpem9udGFsU25hcEluZm8gPSBfYi5ob3Jpem9udGFsO1xuXG4gIHZlcnRpY2FsU25hcEluZm8ucG9zSW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwb3MgPSBfYS5wb3M7XG4gICAgcmV0dXJuIGlzUmlnaHQgPyBwb3MgPj0gc3RhcnRYIDogcG9zIDw9IHN0YXJ0WDtcbiAgfSk7XG4gIGhvcml6b250YWxTbmFwSW5mby5wb3NJbmZvcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHBvcyA9IF9hLnBvcztcbiAgICByZXR1cm4gaXNCb3R0b20gPyBwb3MgPj0gc3RhcnRZIDogcG9zIDw9IHN0YXJ0WTtcbiAgfSk7XG4gIHZlcnRpY2FsU25hcEluZm8uaXNTbmFwID0gdmVydGljYWxTbmFwSW5mby5wb3NJbmZvcy5sZW5ndGggPiAwO1xuICBob3Jpem9udGFsU25hcEluZm8uaXNTbmFwID0gaG9yaXpvbnRhbFNuYXBJbmZvLnBvc0luZm9zLmxlbmd0aCA+IDA7XG5cbiAgdmFyIF9jID0gZ2V0TmVhcmVzdFNuYXBHdWlkZWxpbmVJbmZvKHZlcnRpY2FsU25hcEluZm8pLFxuICAgICAgaXNWZXJ0aWNhbFNuYXAgPSBfYy5pc1NuYXAsXG4gICAgICB2ZXJ0aWNhbEd1aWRlbGluZSA9IF9jLmd1aWRlbGluZTtcblxuICB2YXIgX2QgPSBnZXROZWFyZXN0U25hcEd1aWRlbGluZUluZm8oaG9yaXpvbnRhbFNuYXBJbmZvKSxcbiAgICAgIGlzSG9yaXpvbnRhbFNuYXAgPSBfZC5pc1NuYXAsXG4gICAgICBob3Jpem9udGFsR3VpZGVsaW5lID0gX2QuZ3VpZGVsaW5lO1xuXG4gIHZhciBob3Jpem9udGFsUG9zID0gaXNIb3Jpem9udGFsU25hcCA/IGhvcml6b250YWxHdWlkZWxpbmUucG9zWzFdIDogMDtcbiAgdmFyIHZlcnRpY2FsUG9zID0gaXNWZXJ0aWNhbFNuYXAgPyB2ZXJ0aWNhbEd1aWRlbGluZS5wb3NbMF0gOiAwO1xuXG4gIGlmIChkeCA9PT0gMCkge1xuICAgIGlmIChpc0hvcml6b250YWxTbmFwKSB7XG4gICAgICBob3Jpem9udGFsSW5mby5pc1NuYXAgPSB0cnVlO1xuICAgICAgaG9yaXpvbnRhbEluZm8ucG9zID0gaG9yaXpvbnRhbEd1aWRlbGluZS5wb3NbMV07XG4gICAgICBob3Jpem9udGFsSW5mby5vZmZzZXQgPSBlbmRZIC0gaG9yaXpvbnRhbEluZm8ucG9zO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkeSA9PT0gMCkge1xuICAgIGlmIChpc1ZlcnRpY2FsU25hcCkge1xuICAgICAgdmVydGljYWxJbmZvLmlzU25hcCA9IHRydWU7XG4gICAgICB2ZXJ0aWNhbEluZm8ucG9zID0gdmVydGljYWxQb3M7XG4gICAgICB2ZXJ0aWNhbEluZm8ub2Zmc2V0ID0gZW5kWCAtIHZlcnRpY2FsUG9zO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB5IC0geTEgPSBhICogKHggLSB4MSlcbiAgICB2YXIgYSA9IGR5IC8gZHg7XG4gICAgdmFyIGIgPSBlbmRQb3NbMV0gLSBhICogZW5kWDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciBpc1NuYXAgPSBmYWxzZTtcblxuICAgIGlmIChpc1ZlcnRpY2FsU25hcCkge1xuICAgICAgeCA9IHZlcnRpY2FsUG9zO1xuICAgICAgeSA9IGEgKiB4ICsgYjtcbiAgICAgIGlzU25hcCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChpc0hvcml6b250YWxTbmFwKSB7XG4gICAgICB5ID0gaG9yaXpvbnRhbFBvcztcbiAgICAgIHggPSAoeSAtIGIpIC8gYTtcbiAgICAgIGlzU25hcCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzU25hcCkge1xuICAgICAgdmVydGljYWxJbmZvLmlzU25hcCA9IHRydWU7XG4gICAgICB2ZXJ0aWNhbEluZm8ucG9zID0geDtcbiAgICAgIHZlcnRpY2FsSW5mby5vZmZzZXQgPSBlbmRYIC0geDtcbiAgICAgIGhvcml6b250YWxJbmZvLmlzU25hcCA9IHRydWU7XG4gICAgICBob3Jpem9udGFsSW5mby5wb3MgPSB5O1xuICAgICAgaG9yaXpvbnRhbEluZm8ub2Zmc2V0ID0gZW5kWSAtIHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNhbDogdmVydGljYWxJbmZvLFxuICAgIGhvcml6b250YWw6IGhvcml6b250YWxJbmZvXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoZWNrU25hcHMobW92ZWFibGUsIHJlY3QsIGN1c3RvbVNuYXBUaHJlc2hvbGQpIHtcbiAgdmFyIHBvc2VzID0gc3BsaXRTbmFwRGlyZWN0aW9uUG9zZXMobW92ZWFibGUucHJvcHMuc25hcERpcmVjdGlvbnMsIHJlY3QpO1xuICByZXR1cm4gY2hlY2tNb3ZlYWJsZVNuYXBQb3Nlcyhtb3ZlYWJsZSwgcG9zZXMudmVydGljYWwsIHBvc2VzLmhvcml6b250YWwsIGN1c3RvbVNuYXBUaHJlc2hvbGQpO1xufVxuXG5mdW5jdGlvbiBnZXROZWFyZXN0U25hcEd1aWRlbGluZUluZm8oc25hcEluZm8pIHtcbiAgdmFyIGlzU25hcCA9IHNuYXBJbmZvLmlzU25hcDtcblxuICBpZiAoIWlzU25hcCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc1NuYXA6IGZhbHNlLFxuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgZGlzdDogLTEsXG4gICAgICBwb3M6IDAsXG4gICAgICBndWlkZWxpbmU6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgdmFyIHBvc0luZm8gPSBzbmFwSW5mby5wb3NJbmZvc1swXTtcbiAgdmFyIGd1aWRlbGluZUluZm8gPSBwb3NJbmZvLmd1aWRlbGluZUluZm9zWzBdO1xuICB2YXIgb2Zmc2V0ID0gZ3VpZGVsaW5lSW5mby5vZmZzZXQ7XG4gIHZhciBkaXN0ID0gZ3VpZGVsaW5lSW5mby5kaXN0O1xuICB2YXIgZ3VpZGVsaW5lID0gZ3VpZGVsaW5lSW5mby5ndWlkZWxpbmU7XG4gIHJldHVybiB7XG4gICAgaXNTbmFwOiBpc1NuYXAsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgZGlzdDogZGlzdCxcbiAgICBwb3M6IHBvc0luZm8ucG9zLFxuICAgIGd1aWRlbGluZTogZ3VpZGVsaW5lXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoZWNrU25hcChndWlkZWxpbmVzLCB0YXJnZXRUeXBlLCB0YXJnZXRQb3Nlcywgc25hcFRocmVzaG9sZCkge1xuICBpZiAoIWd1aWRlbGluZXMgfHwgIWd1aWRlbGluZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzU25hcDogZmFsc2UsXG4gICAgICBpbmRleDogLTEsXG4gICAgICBwb3NJbmZvczogW11cbiAgICB9O1xuICB9XG5cbiAgdmFyIGlzVmVydGljYWwgPSB0YXJnZXRUeXBlID09PSBcInZlcnRpY2FsXCI7XG4gIHZhciBwb3NUeXBlID0gaXNWZXJ0aWNhbCA/IDAgOiAxO1xuICB2YXIgc25hcFBvc0luZm9zID0gdGFyZ2V0UG9zZXMubWFwKGZ1bmN0aW9uICh0YXJnZXRQb3MsIGluZGV4KSB7XG4gICAgdmFyIGd1aWRlbGluZUluZm9zID0gZ3VpZGVsaW5lcy5tYXAoZnVuY3Rpb24gKGd1aWRlbGluZSkge1xuICAgICAgdmFyIHBvcyA9IGd1aWRlbGluZS5wb3M7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGFyZ2V0UG9zIC0gcG9zW3Bvc1R5cGVdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIGRpc3Q6IE1hdGguYWJzKG9mZnNldCksXG4gICAgICAgIGd1aWRlbGluZTogZ3VpZGVsaW5lXG4gICAgICB9O1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBndWlkZWxpbmUgPSBfYS5ndWlkZWxpbmUsXG4gICAgICAgICAgZGlzdCA9IF9hLmRpc3Q7XG4gICAgICB2YXIgdHlwZSA9IGd1aWRlbGluZS50eXBlO1xuXG4gICAgICBpZiAodHlwZSAhPT0gdGFyZ2V0VHlwZSB8fCBkaXN0ID4gc25hcFRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmRpc3QgLSBiLmRpc3Q7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvczogdGFyZ2V0UG9zLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgZ3VpZGVsaW5lSW5mb3M6IGd1aWRlbGluZUluZm9zXG4gICAgfTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChzbmFwUG9zSW5mbykge1xuICAgIHJldHVybiBzbmFwUG9zSW5mby5ndWlkZWxpbmVJbmZvcy5sZW5ndGggPiAwO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZ3VpZGVsaW5lSW5mb3NbMF0uZGlzdCAtIGIuZ3VpZGVsaW5lSW5mb3NbMF0uZGlzdDtcbiAgfSk7XG4gIHZhciBpc1NuYXAgPSBzbmFwUG9zSW5mb3MubGVuZ3RoID4gMDtcbiAgcmV0dXJuIHtcbiAgICBpc1NuYXA6IGlzU25hcCxcbiAgICBpbmRleDogaXNTbmFwID8gc25hcFBvc0luZm9zWzBdLmluZGV4IDogLTEsXG4gICAgcG9zSW5mb3M6IHNuYXBQb3NJbmZvc1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTbmFwSW5mb3NCeURpcmVjdGlvbihtb3ZlYWJsZSwgcG9zZXMsIHNuYXBEaXJlY3Rpb24pIHtcbiAgdmFyIG5leHRQb3NlcyA9IFtdO1xuXG4gIGlmIChzbmFwRGlyZWN0aW9uWzBdICYmIHNuYXBEaXJlY3Rpb25bMV0pIHtcbiAgICBuZXh0UG9zZXMgPSBbc25hcERpcmVjdGlvbiwgWy1zbmFwRGlyZWN0aW9uWzBdLCBzbmFwRGlyZWN0aW9uWzFdXSwgW3NuYXBEaXJlY3Rpb25bMF0sIC1zbmFwRGlyZWN0aW9uWzFdXV0ubWFwKGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgIHJldHVybiBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgZGlyZWN0aW9uKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICghc25hcERpcmVjdGlvblswXSAmJiAhc25hcERpcmVjdGlvblsxXSkge1xuICAgIHZhciBhbGlnblBvc2VzID0gW3Bvc2VzWzBdLCBwb3Nlc1sxXSwgcG9zZXNbM10sIHBvc2VzWzJdLCBwb3Nlc1swXV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgbmV4dFBvc2VzLnB1c2goYWxpZ25Qb3Nlc1tpXSk7XG4gICAgICBuZXh0UG9zZXMucHVzaChbKGFsaWduUG9zZXNbaV1bMF0gKyBhbGlnblBvc2VzW2kgKyAxXVswXSkgLyAyLCAoYWxpZ25Qb3Nlc1tpXVsxXSArIGFsaWduUG9zZXNbaSArIDFdWzFdKSAvIDJdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG1vdmVhYmxlLnByb3BzLmtlZXBSYXRpbykge1xuICAgICAgbmV4dFBvc2VzID0gW1stMSwgLTFdLCBbLTEsIDFdLCBbMSwgLTFdLCBbMSwgMV0sIHNuYXBEaXJlY3Rpb25dLm1hcChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgZGlyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0UG9zZXMgPSBnZXRQb3Nlc0J5RGlyZWN0aW9uKHBvc2VzLCBzbmFwRGlyZWN0aW9uKTtcblxuICAgICAgaWYgKG5leHRQb3Nlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG5leHRQb3Nlcy5wdXNoKFsobmV4dFBvc2VzWzBdWzBdICsgbmV4dFBvc2VzWzFdWzBdKSAvIDIsIChuZXh0UG9zZXNbMF1bMV0gKyBuZXh0UG9zZXNbMV1bMV0pIC8gMl0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGVja01vdmVhYmxlU25hcFBvc2VzKG1vdmVhYmxlLCBuZXh0UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zWzBdO1xuICB9KSwgbmV4dFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvc1sxXTtcbiAgfSksIDEpO1xufVxuXG5mdW5jdGlvbiBjaGVja1NuYXBCb3VuZFByaW9yaXR5KGEsIGIpIHtcbiAgdmFyIGFEaXN0ID0gTWF0aC5hYnMoYS5vZmZzZXQpO1xuICB2YXIgYkRpc3QgPSBNYXRoLmFicyhiLm9mZnNldCk7XG5cbiAgaWYgKGEuaXNCb3VuZCAmJiBiLmlzQm91bmQpIHtcbiAgICByZXR1cm4gYkRpc3QgLSBhRGlzdDtcbiAgfSBlbHNlIGlmIChhLmlzQm91bmQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYi5pc0JvdW5kKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoYS5pc1NuYXAgJiYgYi5pc1NuYXApIHtcbiAgICByZXR1cm4gYkRpc3QgLSBhRGlzdDtcbiAgfSBlbHNlIGlmIChhLmlzU25hcCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiLmlzU25hcCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGFEaXN0IDwgVElOWV9OVU0pIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChiRGlzdCA8IFRJTllfTlVNKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIGFEaXN0IC0gYkRpc3Q7XG59XG5cbmZ1bmN0aW9uIGdldE5lYXJPZmZzZXRJbmZvKG9mZnNldHMsIGluZGV4KSB7XG4gIHJldHVybiBvZmZzZXRzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhU2lnbiA9IGEuc2lnbltpbmRleF07XG4gICAgdmFyIGJTaWduID0gYi5zaWduW2luZGV4XTtcbiAgICB2YXIgYU9mZnNldCA9IGEub2Zmc2V0W2luZGV4XTtcbiAgICB2YXIgYk9mZnNldCA9IGIub2Zmc2V0W2luZGV4XTsgLy8gLTEgVGhlIHBvc2l0aW9ucyBvZiBhIGFuZCBiIGRvIG5vdCBjaGFuZ2UuXG4gICAgLy8gMSBUaGUgcG9zaXRpb25zIG9mIGEgYW5kIGIgYXJlIHJldmVyc2VkLlxuXG4gICAgaWYgKCFhU2lnbikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICghYlNpZ24pIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hlY2tTbmFwQm91bmRQcmlvcml0eSh7XG4gICAgICBpc0JvdW5kOiBhLmlzQm91bmQsXG4gICAgICBpc1NuYXA6IGEuaXNTbmFwLFxuICAgICAgb2Zmc2V0OiBhT2Zmc2V0XG4gICAgfSwge1xuICAgICAgaXNCb3VuZDogYi5pc0JvdW5kLFxuICAgICAgaXNTbmFwOiBiLmlzU25hcCxcbiAgICAgIG9mZnNldDogYk9mZnNldFxuICAgIH0pO1xuICB9KVswXTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hlY2tTbmFwRGlyZWN0aW9ucyhkaXJlY3Rpb24sIGZpeGVkRGlyZWN0aW9uLCBrZWVwUmF0aW8pIHtcbiAgdmFyIGRpcmVjdGlvbnMgPSBbXTsgLy8gY29uc3QgZml4ZWREaXJlY3Rpb24gPSBbLWRpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV07XG5cbiAgaWYgKGtlZXBSYXRpbykge1xuICAgIGlmIChNYXRoLmFicyhmaXhlZERpcmVjdGlvblswXSkgIT09IDEgfHwgTWF0aC5hYnMoZml4ZWREaXJlY3Rpb25bMV0pICE9PSAxKSB7XG4gICAgICBkaXJlY3Rpb25zLnB1c2goW2ZpeGVkRGlyZWN0aW9uLCBbLTEsIC0xXV0sIFtmaXhlZERpcmVjdGlvbiwgWy0xLCAxXV0sIFtmaXhlZERpcmVjdGlvbiwgWzEsIC0xXV0sIFtmaXhlZERpcmVjdGlvbiwgWzEsIDFdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcmVjdGlvbnMucHVzaChbZml4ZWREaXJlY3Rpb24sIFtkaXJlY3Rpb25bMF0sIC1kaXJlY3Rpb25bMV1dXSwgW2ZpeGVkRGlyZWN0aW9uLCBbLWRpcmVjdGlvblswXSwgZGlyZWN0aW9uWzFdXV0pO1xuICAgIH1cblxuICAgIGRpcmVjdGlvbnMucHVzaChbZml4ZWREaXJlY3Rpb24sIGRpcmVjdGlvbl0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChkaXJlY3Rpb25bMF0gJiYgZGlyZWN0aW9uWzFdIHx8ICFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSkge1xuICAgICAgdmFyIGVuZERpcmVjdGlvbl8xID0gZGlyZWN0aW9uWzBdID8gZGlyZWN0aW9uIDogWzEsIDFdO1xuICAgICAgWzEsIC0xXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWduWCkge1xuICAgICAgICBbMSwgLTFdLmZvckVhY2goZnVuY3Rpb24gKHNpZ25ZKSB7XG4gICAgICAgICAgdmFyIG5leHREaXJlY3Rpb24gPSBbc2lnblggKiBlbmREaXJlY3Rpb25fMVswXSwgc2lnblkgKiBlbmREaXJlY3Rpb25fMVsxXV07XG5cbiAgICAgICAgICBpZiAoZml4ZWREaXJlY3Rpb25bMF0gPT09IG5leHREaXJlY3Rpb25bMF0gJiYgZml4ZWREaXJlY3Rpb25bMV0gPT09IG5leHREaXJlY3Rpb25bMV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJlY3Rpb25zLnB1c2goW2ZpeGVkRGlyZWN0aW9uLCBuZXh0RGlyZWN0aW9uXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb25bMF0pIHtcbiAgICAgIHZhciBzaWducyA9IE1hdGguYWJzKGZpeGVkRGlyZWN0aW9uWzBdKSA9PT0gMSA/IFsxXSA6IFsxLCAtMV07XG4gICAgICBzaWducy5mb3JFYWNoKGZ1bmN0aW9uIChzaWduKSB7XG4gICAgICAgIGRpcmVjdGlvbnMucHVzaChbW2ZpeGVkRGlyZWN0aW9uWzBdLCAtMV0sIFtzaWduICogZGlyZWN0aW9uWzBdLCAtMV1dLCBbW2ZpeGVkRGlyZWN0aW9uWzBdLCAwXSwgW3NpZ24gKiBkaXJlY3Rpb25bMF0sIDBdXSwgW1tmaXhlZERpcmVjdGlvblswXSwgMV0sIFtzaWduICogZGlyZWN0aW9uWzBdLCAxXV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb25bMV0pIHtcbiAgICAgIHZhciBzaWducyA9IE1hdGguYWJzKGZpeGVkRGlyZWN0aW9uWzFdKSA9PT0gMSA/IFsxXSA6IFsxLCAtMV07XG4gICAgICBzaWducy5mb3JFYWNoKGZ1bmN0aW9uIChzaWduKSB7XG4gICAgICAgIGRpcmVjdGlvbnMucHVzaChbWy0xLCBmaXhlZERpcmVjdGlvblsxXV0sIFstMSwgc2lnbiAqIGRpcmVjdGlvblsxXV1dLCBbWzAsIGZpeGVkRGlyZWN0aW9uWzFdXSwgWzAsIHNpZ24gKiBkaXJlY3Rpb25bMV1dXSwgW1sxLCBmaXhlZERpcmVjdGlvblsxXV0sIFsxLCBzaWduICogZGlyZWN0aW9uWzFdXV0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGlzU3RhcnRMaW5lKGRvdCwgbGluZSkge1xuICAvLyBsICAgIG8gICAgID0+IHRydWVcbiAgLy8gbyAgICBsICAgID0+IGZhbHNlXG4gIHZhciBjeCA9IGF2ZXJhZ2UoW2xpbmVbMF1bMF0sIGxpbmVbMV1bMF1dKTtcbiAgdmFyIGN5ID0gYXZlcmFnZShbbGluZVswXVsxXSwgbGluZVsxXVsxXV0pO1xuICByZXR1cm4ge1xuICAgIHZlcnRpY2FsOiBjeCA8PSBkb3RbMF0sXG4gICAgaG9yaXpvbnRhbDogY3kgPD0gZG90WzFdXG4gIH07XG59XG5cbmZ1bmN0aW9uIGhpdFRlc3RMaW5lKGRvdCwgX2EpIHtcbiAgdmFyIHBvczEgPSBfYVswXSxcbiAgICAgIHBvczIgPSBfYVsxXTtcbiAgdmFyIGR4ID0gcG9zMlswXSAtIHBvczFbMF07XG4gIHZhciBkeSA9IHBvczJbMV0gLSBwb3MxWzFdO1xuXG4gIGlmIChNYXRoLmFicyhkeCkgPCBUSU5ZX05VTSkge1xuICAgIGR4ID0gMDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhkeSkgPCBUSU5ZX05VTSkge1xuICAgIGR5ID0gMDtcbiAgfVxuXG4gIHZhciB0ZXN0MTtcbiAgdmFyIHRlc3QyO1xuXG4gIGlmICghZHgpIHtcbiAgICB0ZXN0MSA9IHBvczFbMF07XG4gICAgdGVzdDIgPSBkb3RbMF07XG4gIH0gZWxzZSBpZiAoIWR5KSB7XG4gICAgdGVzdDEgPSBwb3MxWzFdO1xuICAgIHRlc3QyID0gZG90WzFdO1xuICB9IGVsc2Uge1xuICAgIHZhciBhID0gZHkgLyBkeDsgLy8geSA9IGEgKiAoeCAtIHBvczEpICsgcG9zMVxuXG4gICAgdGVzdDEgPSBhICogKGRvdFswXSAtIHBvczFbMF0pICsgcG9zMVsxXTtcbiAgICB0ZXN0MiA9IGRvdFsxXTtcbiAgfVxuXG4gIHJldHVybiB0ZXN0MSAtIHRlc3QyO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVTdGFydExpbmUoZG90cywgbGluZSwgY2VudGVyU2lnbiwgZXJyb3IpIHtcbiAgaWYgKGVycm9yID09PSB2b2lkIDApIHtcbiAgICBlcnJvciA9IFRJTllfTlVNO1xuICB9XG5cbiAgcmV0dXJuIGRvdHMuZXZlcnkoZnVuY3Rpb24gKGRvdCkge1xuICAgIHZhciB2YWx1ZSA9IGhpdFRlc3RMaW5lKGRvdCwgbGluZSk7XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8PSAwO1xuICAgIHJldHVybiBzaWduID09PSBjZW50ZXJTaWduIHx8IE1hdGguYWJzKHZhbHVlKSA8PSBlcnJvcjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5uZXJCb3VuZERvdChwb3MsIHN0YXJ0LCBlbmQsIGlzU3RhcnQsIHRocmVzaG9sZCkge1xuICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICB0aHJlc2hvbGQgPSAwO1xuICB9XG5cbiAgaWYgKGlzU3RhcnQgJiYgc3RhcnQgLSB0aHJlc2hvbGQgPD0gcG9zIHx8ICFpc1N0YXJ0ICYmIHBvcyA8PSBlbmQgKyB0aHJlc2hvbGQpIHtcbiAgICAvLyBmYWxzZSA0MDIgNTY1IDYwMiA9PiAzNyAoWzAsIDM3XSlcbiAgICAvLyB0cnVlIDQwMCA1MjQuOTcxMjYwMzU0MDAzNiA2MDAgPT4gMTI0IChbMTI0LCAwXSlcbiAgICAvLyB0cnVlIDQwMCA0MTAgNjAwID0+IDEwIChbMTAsIDBdKVxuICAgIHJldHVybiB7XG4gICAgICBpc0JvdW5kOiB0cnVlLFxuICAgICAgb2Zmc2V0OiBpc1N0YXJ0ID8gc3RhcnQgLSBwb3MgOiBlbmQgLSBwb3NcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICBvZmZzZXQ6IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJbm5lckJvdW5kKG1vdmVhYmxlLCBfYSkge1xuICB2YXIgbGluZSA9IF9hLmxpbmUsXG4gICAgICBjZW50ZXJTaWduID0gX2EuY2VudGVyU2lnbixcbiAgICAgIHZlcnRpY2FsU2lnbiA9IF9hLnZlcnRpY2FsU2lnbixcbiAgICAgIGhvcml6b250YWxTaWduID0gX2EuaG9yaXpvbnRhbFNpZ24sXG4gICAgICBsaW5lQ29uc3RhbnRzID0gX2EubGluZUNvbnN0YW50cztcbiAgdmFyIGJvdW5kcyA9IG1vdmVhYmxlLnByb3BzLmlubmVyQm91bmRzO1xuXG4gIGlmICghYm91bmRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWxsQm91bmQ6IGZhbHNlLFxuICAgICAgaXNCb3VuZDogZmFsc2UsXG4gICAgICBpc1ZlcnRpY2FsQm91bmQ6IGZhbHNlLFxuICAgICAgaXNIb3Jpem9udGFsQm91bmQ6IGZhbHNlLFxuICAgICAgb2Zmc2V0OiBbMCwgMF1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGxlZnQgPSBib3VuZHMubGVmdCxcbiAgICAgIHRvcCA9IGJvdW5kcy50b3AsXG4gICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG4gIHZhciBsZWZ0TGluZSA9IFtbbGVmdCwgdG9wXSwgW2xlZnQsIHRvcCArIGhlaWdodF1dO1xuICB2YXIgdG9wTGluZSA9IFtbbGVmdCwgdG9wXSwgW2xlZnQgKyB3aWR0aCwgdG9wXV07XG4gIHZhciByaWdodExpbmUgPSBbW2xlZnQgKyB3aWR0aCwgdG9wXSwgW2xlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0XV07XG4gIHZhciBib3R0b21MaW5lID0gW1tsZWZ0LCB0b3AgKyBoZWlnaHRdLCBbbGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHRdXTtcblxuICBpZiAoaXNTYW1lU3RhcnRMaW5lKFtbbGVmdCwgdG9wXSwgW2xlZnQgKyB3aWR0aCwgdG9wXSwgW2xlZnQsIHRvcCArIGhlaWdodF0sIFtsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodF1dLCBsaW5lLCBjZW50ZXJTaWduKSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0FsbEJvdW5kOiBmYWxzZSxcbiAgICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgICAgaXNWZXJ0aWNhbEJvdW5kOiBmYWxzZSxcbiAgICAgIGlzSG9yaXpvbnRhbEJvdW5kOiBmYWxzZSxcbiAgICAgIG9mZnNldDogWzAsIDBdXG4gICAgfTtcbiAgfSAvLyB0ZXN0IHZlcnRpY2FsXG5cblxuICB2YXIgdG9wQm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgbGluZUNvbnN0YW50cywgdG9wTGluZSwgdmVydGljYWxTaWduKTtcbiAgdmFyIGJvdHRvbUJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIGxpbmVDb25zdGFudHMsIGJvdHRvbUxpbmUsIHZlcnRpY2FsU2lnbik7IC8vIHRlc3QgaG9yaXpvbnRhbFxuXG4gIHZhciBsZWZ0Qm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgbGluZUNvbnN0YW50cywgbGVmdExpbmUsIGhvcml6b250YWxTaWduKTtcbiAgdmFyIHJpZ2h0Qm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgbGluZUNvbnN0YW50cywgcmlnaHRMaW5lLCBob3Jpem9udGFsU2lnbik7XG4gIHZhciBpc0FsbFZlcnRpY2FsQm91bmQgPSB0b3BCb3VuZEluZm8uaXNCb3VuZCAmJiBib3R0b21Cb3VuZEluZm8uaXNCb3VuZDtcbiAgdmFyIGlzVmVydGljYWxCb3VuZCA9IHRvcEJvdW5kSW5mby5pc0JvdW5kIHx8IGJvdHRvbUJvdW5kSW5mby5pc0JvdW5kO1xuICB2YXIgaXNBbGxIb3Jpem9udGFsQm91bmQgPSBsZWZ0Qm91bmRJbmZvLmlzQm91bmQgJiYgcmlnaHRCb3VuZEluZm8uaXNCb3VuZDtcbiAgdmFyIGlzSG9yaXpvbnRhbEJvdW5kID0gbGVmdEJvdW5kSW5mby5pc0JvdW5kIHx8IHJpZ2h0Qm91bmRJbmZvLmlzQm91bmQ7XG4gIHZhciB2ZXJ0aWNhbE9mZnNldCA9IG1heE9mZnNldCh0b3BCb3VuZEluZm8ub2Zmc2V0LCBib3R0b21Cb3VuZEluZm8ub2Zmc2V0KTtcbiAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBtYXhPZmZzZXQobGVmdEJvdW5kSW5mby5vZmZzZXQsIHJpZ2h0Qm91bmRJbmZvLm9mZnNldCk7XG4gIHZhciBvZmZzZXQgPSBbMCwgMF07XG4gIHZhciBpc0JvdW5kID0gZmFsc2U7XG4gIHZhciBpc0FsbEJvdW5kID0gZmFsc2U7XG5cbiAgaWYgKE1hdGguYWJzKGhvcml6b250YWxPZmZzZXQpIDwgTWF0aC5hYnModmVydGljYWxPZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gW3ZlcnRpY2FsT2Zmc2V0LCAwXTtcbiAgICBpc0JvdW5kID0gaXNWZXJ0aWNhbEJvdW5kO1xuICAgIGlzQWxsQm91bmQgPSBpc0FsbFZlcnRpY2FsQm91bmQ7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gWzAsIGhvcml6b250YWxPZmZzZXRdO1xuICAgIGlzQm91bmQgPSBpc0hvcml6b250YWxCb3VuZDtcbiAgICBpc0FsbEJvdW5kID0gaXNBbGxIb3Jpem9udGFsQm91bmQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzQWxsQm91bmQ6IGlzQWxsQm91bmQsXG4gICAgaXNWZXJ0aWNhbEJvdW5kOiBpc1ZlcnRpY2FsQm91bmQsXG4gICAgaXNIb3Jpem9udGFsQm91bmQ6IGlzSG9yaXpvbnRhbEJvdW5kLFxuICAgIGlzQm91bmQ6IGlzQm91bmQsXG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgX2EsIGJvdW5kTGluZSwgaXNTdGFydCwgdGhyZXNob2xkLCBpc1JlbmRlcikge1xuICB2YXIgYSA9IF9hWzBdLFxuICAgICAgYiA9IF9hWzFdO1xuICB2YXIgZG90MSA9IGxpbmVbMF07IC8vIGNvbnN0IGRvdDIgPSBsaW5lWzFdO1xuXG4gIHZhciBib3VuZERvdDEgPSBib3VuZExpbmVbMF07XG4gIHZhciBib3VuZERvdDIgPSBib3VuZExpbmVbMV07IC8vIGNvbnN0IGR5MSA9IGdldFRpbnlEaXN0KGRvdDJbMV0gLSBkb3QxWzFdKTtcbiAgLy8gY29uc3QgZHgxID0gZ2V0VGlueURpc3QoZG90MlswXSAtIGRvdDFbMF0pO1xuXG4gIHZhciBkeTIgPSBnZXRUaW55RGlzdChib3VuZERvdDJbMV0gLSBib3VuZERvdDFbMV0pO1xuICB2YXIgZHgyID0gZ2V0VGlueURpc3QoYm91bmREb3QyWzBdIC0gYm91bmREb3QxWzBdKTtcbiAgdmFyIGhhc0R4ID0gYjtcbiAgdmFyIGhhc0R5ID0gYTtcbiAgdmFyIHNsb3BlID0gLWEgLyBiOyAvLyBsaW5lQ29uc3RhbnRzXG4gIC8vIGF4ICsgYnkgKyBjID0gMFxuICAvLyBkeDIgb3IgZHkyIGlzIHplcm9cblxuICBpZiAoIWR4Mikge1xuICAgIC8vIHZlcnRpY2FsXG4gICAgLy8gYnkgKyBjID0gMFxuICAgIGlmIChpc1JlbmRlciAmJiAhaGFzRHkpIHtcbiAgICAgIC8vIDkwZGVnXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaGFzRHgpIHtcbiAgICAgIC8vIGF4ICsgYnkgKyBjID0gMFxuICAgICAgLy8gY29uc3QgeSA9IGR5MSA/IGR5MSAvIGR4MSAqIChib3VuZERvdDFbMF0gLSBkb3QxWzBdKSArIGRvdDFbMV0gOiBkb3QxWzFdO1xuICAgICAgdmFyIHkgPSBzbG9wZSAqIChib3VuZERvdDFbMF0gLSBkb3QxWzBdKSArIGRvdDFbMV07IC8vIGJvdW5kRG90MVsxXSA8PSB5ICA8PSBib3VuZERvdDJbMV1cblxuICAgICAgcmV0dXJuIGNoZWNrSW5uZXJCb3VuZERvdCh5LCBib3VuZERvdDFbMV0sIGJvdW5kRG90MlsxXSwgaXNTdGFydCwgdGhyZXNob2xkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXggKyBjID0gMFxuICAgICAgdmFyIG9mZnNldCA9IGJvdW5kRG90MVswXSAtIGRvdDFbMF07XG4gICAgICB2YXIgaXNCb3VuZCA9IE1hdGguYWJzKG9mZnNldCkgPD0gKHRocmVzaG9sZCB8fCAwKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQm91bmQ6IGlzQm91bmQsXG4gICAgICAgIG9mZnNldDogaXNCb3VuZCA/IG9mZnNldCA6IDBcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFkeTIpIHtcbiAgICAvLyBob3Jpem9udGFsXG4gICAgaWYgKGlzUmVuZGVyICYmICFoYXNEeCkge1xuICAgICAgLy8gOTBkZWdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChoYXNEeSkge1xuICAgICAgLy8geSA9IGEgKiAoeCAtIHgxKSArIHkxXG4gICAgICAvLyB4ID0gKHkgLSB5MSkgLyBhICsgeDFcbiAgICAgIC8vIGNvbnN0IGEgPSBkeTEgLyBkeDE7XG4gICAgICAvLyBjb25zdCB4ID0gZHgxID8gKGJvdW5kRG90MVsxXSAtIGRvdDFbMV0pIC8gYSArIGRvdDFbMF0gOiBkb3QxWzBdO1xuICAgICAgdmFyIHggPSAoYm91bmREb3QxWzFdIC0gZG90MVsxXSkgLyBzbG9wZSArIGRvdDFbMF07IC8vIGJvdW5kRG90MVswXSA8PSB4ICYmIHggPD0gYm91bmREb3QyWzBdXG5cbiAgICAgIHJldHVybiBjaGVja0lubmVyQm91bmREb3QoeCwgYm91bmREb3QxWzBdLCBib3VuZERvdDJbMF0sIGlzU3RhcnQsIHRocmVzaG9sZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvZmZzZXQgPSBib3VuZERvdDFbMV0gLSBkb3QxWzFdO1xuICAgICAgdmFyIGlzQm91bmQgPSBNYXRoLmFicyhvZmZzZXQpIDw9ICh0aHJlc2hvbGQgfHwgMCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0JvdW5kOiBpc0JvdW5kLFxuICAgICAgICBvZmZzZXQ6IGlzQm91bmQgPyBvZmZzZXQgOiAwXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNCb3VuZDogZmFsc2UsXG4gICAgb2Zmc2V0OiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRJbmZvKG1vdmVhYmxlLCBsaW5lSW5mb3MsIGRhdGFzKSB7XG4gIHJldHVybiBsaW5lSW5mb3MubWFwKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgdmFyIF9hID0gY2hlY2tJbm5lckJvdW5kKG1vdmVhYmxlLCBpbmZvKSxcbiAgICAgICAgaXNCb3VuZCA9IF9hLmlzQm91bmQsXG4gICAgICAgIG9mZnNldCA9IF9hLm9mZnNldCxcbiAgICAgICAgaXNWZXJ0aWNhbEJvdW5kID0gX2EuaXNWZXJ0aWNhbEJvdW5kLFxuICAgICAgICBpc0hvcml6b250YWxCb3VuZCA9IF9hLmlzSG9yaXpvbnRhbEJvdW5kO1xuXG4gICAgdmFyIG11bHRpcGxlID0gaW5mby5tdWx0aXBsZTtcbiAgICB2YXIgc2l6ZU9mZnNldCA9IGdldERyYWdEaXN0KHtcbiAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgIGRpc3RYOiBvZmZzZXRbMF0sXG4gICAgICBkaXN0WTogb2Zmc2V0WzFdXG4gICAgfSkubWFwKGZ1bmN0aW9uIChzaXplLCBpKSB7XG4gICAgICByZXR1cm4gc2l6ZSAqIChtdWx0aXBsZVtpXSA/IDIgLyBtdWx0aXBsZVtpXSA6IDApO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzaWduOiBtdWx0aXBsZSxcbiAgICAgIGlzQm91bmQ6IGlzQm91bmQsXG4gICAgICBpc1ZlcnRpY2FsQm91bmQ6IGlzVmVydGljYWxCb3VuZCxcbiAgICAgIGlzSG9yaXpvbnRhbEJvdW5kOiBpc0hvcml6b250YWxCb3VuZCxcbiAgICAgIGlzU25hcDogZmFsc2UsXG4gICAgICBvZmZzZXQ6IHNpemVPZmZzZXRcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZERyYWdJbmZvKG1vdmVhYmxlLCBwb3NlcywgZGF0YXMpIHtcbiAgdmFyIF9hO1xuXG4gIHZhciBsaW5lcyA9IGdldENoZWNrSW5uZXJCb3VuZExpbmVJbmZvcyhtb3ZlYWJsZSwgcG9zZXMsIFswLCAwXSwgZmFsc2UpLm1hcChmdW5jdGlvbiAoaW5mbykge1xuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5mbyksIHtcbiAgICAgIG11bHRpcGxlOiBpbmZvLm11bHRpcGxlLm1hcChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhkaXIpICogMjtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0pO1xuICB2YXIgaW5uZXJCb3VuZEluZm8gPSBnZXRJbm5lckJvdW5kSW5mbyhtb3ZlYWJsZSwgbGluZXMsIGRhdGFzKTtcbiAgdmFyIHdpZHRoT2Zmc2V0SW5mbyA9IGdldE5lYXJPZmZzZXRJbmZvKGlubmVyQm91bmRJbmZvLCAwKTtcbiAgdmFyIGhlaWdodE9mZnNldEluZm8gPSBnZXROZWFyT2Zmc2V0SW5mbyhpbm5lckJvdW5kSW5mbywgMSk7XG4gIHZhciB2ZXJ0aWNhbE9mZnNldCA9IDA7XG4gIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gMDtcbiAgdmFyIGlzVmVydGljYWxCb3VuZCA9IHdpZHRoT2Zmc2V0SW5mby5pc1ZlcnRpY2FsQm91bmQgfHwgaGVpZ2h0T2Zmc2V0SW5mby5pc1ZlcnRpY2FsQm91bmQ7XG4gIHZhciBpc0hvcml6b250YWxCb3VuZCA9IHdpZHRoT2Zmc2V0SW5mby5pc0hvcml6b250YWxCb3VuZCB8fCBoZWlnaHRPZmZzZXRJbmZvLmlzSG9yaXpvbnRhbEJvdW5kO1xuXG4gIGlmIChpc1ZlcnRpY2FsQm91bmQgfHwgaXNIb3Jpem9udGFsQm91bmQpIHtcbiAgICBfYSA9IGdldEludmVyc2VEcmFnRGlzdCh7XG4gICAgICBkYXRhczogZGF0YXMsXG4gICAgICBkaXN0WDogLXdpZHRoT2Zmc2V0SW5mby5vZmZzZXRbMF0sXG4gICAgICBkaXN0WTogLWhlaWdodE9mZnNldEluZm8ub2Zmc2V0WzFdXG4gICAgfSksIHZlcnRpY2FsT2Zmc2V0ID0gX2FbMF0sIGhvcml6b250YWxPZmZzZXQgPSBfYVsxXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmVydGljYWw6IHtcbiAgICAgIGlzQm91bmQ6IGlzVmVydGljYWxCb3VuZCxcbiAgICAgIG9mZnNldDogdmVydGljYWxPZmZzZXRcbiAgICB9LFxuICAgIGhvcml6b250YWw6IHtcbiAgICAgIGlzQm91bmQ6IGlzSG9yaXpvbnRhbEJvdW5kLFxuICAgICAgb2Zmc2V0OiBob3Jpem9udGFsT2Zmc2V0XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDaGVja1NuYXBMaW5lRGlyZWN0aW9ucyhkaXJlY3Rpb24sIGtlZXBSYXRpbykge1xuICB2YXIgbGluZURpcmVjdGlvbnMgPSBbXTtcbiAgdmFyIHggPSBkaXJlY3Rpb25bMF07XG4gIHZhciB5ID0gZGlyZWN0aW9uWzFdO1xuXG4gIGlmICh4ICYmIHkpIHtcbiAgICBsaW5lRGlyZWN0aW9ucy5wdXNoKFtbMCwgeSAqIDJdLCBkaXJlY3Rpb24sIFsteCwgeV1dLCBbW3ggKiAyLCAwXSwgZGlyZWN0aW9uLCBbeCwgLXldXSk7XG4gIH0gZWxzZSBpZiAoeCkge1xuICAgIC8vIHZlcnRjYWxcbiAgICBsaW5lRGlyZWN0aW9ucy5wdXNoKFtbeCAqIDIsIDBdLCBbeCwgMV0sIFt4LCAtMV1dKTtcblxuICAgIGlmIChrZWVwUmF0aW8pIHtcbiAgICAgIGxpbmVEaXJlY3Rpb25zLnB1c2goW1swLCAtMV0sIFt4LCAtMV0sIFsteCwgLTFdXSwgW1swLCAxXSwgW3gsIDFdLCBbLXgsIDFdXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHkpIHtcbiAgICAvLyBob3Jpem9udGFsXG4gICAgbGluZURpcmVjdGlvbnMucHVzaChbWzAsIHkgKiAyXSwgWzEsIHldLCBbLTEsIHldXSk7XG5cbiAgICBpZiAoa2VlcFJhdGlvKSB7XG4gICAgICBsaW5lRGlyZWN0aW9ucy5wdXNoKFtbLTEsIDBdLCBbLTEsIHldLCBbLTEsIC15XV0sIFtbMSwgMF0sIFsxLCB5XSwgWzEsIC15XV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBbMCwgMF0gdG8gYWxsIGRpcmVjdGlvblxuICAgIGxpbmVEaXJlY3Rpb25zLnB1c2goW1stMSwgMF0sIFstMSwgLTFdLCBbLTEsIDFdXSwgW1sxLCAwXSwgWzEsIC0xXSwgWzEsIDFdXSwgW1swLCAtMV0sIFstMSwgLTFdLCBbMSwgLTFdXSwgW1swLCAxXSwgWy0xLCAxXSwgWzEsIDFdXSk7XG4gIH1cblxuICByZXR1cm4gbGluZURpcmVjdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGdldENoZWNrSW5uZXJCb3VuZExpbmVJbmZvcyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbiwga2VlcFJhdGlvKSB7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgYWxsTWF0cml4ID0gX2EuYWxsTWF0cml4LFxuICAgICAgaXMzZCA9IF9hLmlzM2Q7XG4gIHZhciB2aXJ0dWFsUG9zZXMgPSBjYWxjdWxhdGVQb3NlcyhhbGxNYXRyaXgsIDEwMCwgMTAwLCBpczNkID8gNCA6IDMpO1xuICB2YXIgY2VudGVyID0gZ2V0UG9zQnlEaXJlY3Rpb24odmlydHVhbFBvc2VzLCBbMCwgMF0pO1xuICByZXR1cm4gZ2V0Q2hlY2tTbmFwTGluZURpcmVjdGlvbnMoZGlyZWN0aW9uLCBrZWVwUmF0aW8pLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbXVsdGlwbGUgPSBfYVswXSxcbiAgICAgICAgZGlyMSA9IF9hWzFdLFxuICAgICAgICBkaXIyID0gX2FbMl07XG4gICAgdmFyIHZpcnR1YWxMaW5lID0gW2dldFBvc0J5RGlyZWN0aW9uKHZpcnR1YWxQb3NlcywgZGlyMSksIGdldFBvc0J5RGlyZWN0aW9uKHZpcnR1YWxQb3NlcywgZGlyMildO1xuICAgIHZhciBsaW5lQ29uc3RhbnRzID0gc29sdmVMaW5lQ29uc3RhbnRzKHZpcnR1YWxMaW5lKTtcblxuICAgIHZhciBfYiA9IGlzU3RhcnRMaW5lKGNlbnRlciwgdmlydHVhbExpbmUpLFxuICAgICAgICB2ZXJ0aWNhbFNpZ24gPSBfYi52ZXJ0aWNhbCxcbiAgICAgICAgaG9yaXpvbnRhbFNpZ24gPSBfYi5ob3Jpem9udGFsO1xuXG4gICAgdmFyIGNlbnRlclNpZ24gPSBoaXRUZXN0TGluZShjZW50ZXIsIHZpcnR1YWxMaW5lKSA8PSAwO1xuICAgIHJldHVybiB7XG4gICAgICBtdWx0aXBsZTogbXVsdGlwbGUsXG4gICAgICBjZW50ZXJTaWduOiBjZW50ZXJTaWduLFxuICAgICAgdmVydGljYWxTaWduOiB2ZXJ0aWNhbFNpZ24sXG4gICAgICBob3Jpem9udGFsU2lnbjogaG9yaXpvbnRhbFNpZ24sXG4gICAgICBsaW5lQ29uc3RhbnRzOiBsaW5lQ29uc3RhbnRzLFxuICAgICAgbGluZTogW2dldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXIxKSwgZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGRpcjIpXVxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0JvdW5kUm90YXRlJDEocmVsYXRpdmVQb3NlcywgYm91bmREb3RzLCBjZW50ZXIsIHJhZCkge1xuICB2YXIgbmV4dFBvc2VzID0gcmFkID8gcmVsYXRpdmVQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiByb3RhdGUocG9zLCByYWQpO1xuICB9KSA6IHJlbGF0aXZlUG9zZXM7XG4gIHJldHVybiBbW25leHRQb3Nlc1swXSwgbmV4dFBvc2VzWzFdXSwgW25leHRQb3Nlc1sxXSwgbmV4dFBvc2VzWzNdXSwgW25leHRQb3Nlc1szXSwgbmV4dFBvc2VzWzJdXSwgW25leHRQb3Nlc1syXSwgbmV4dFBvc2VzWzBdXV0uc29tZShmdW5jdGlvbiAobGluZSkge1xuICAgIHZhciBjZW50ZXJTaWduID0gaGl0VGVzdExpbmUoY2VudGVyLCBsaW5lKSA8PSAwO1xuICAgIHJldHVybiAhaXNTYW1lU3RhcnRMaW5lKGJvdW5kRG90cywgbGluZSwgY2VudGVyU2lnbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXREaXN0UG9pbnRMaW5lKF9hKSB7XG4gIC8vIHggPSAwLCB5ID0gMFxuICAvLyBkID0gKGF4ICsgYnkgKyBjKSAvIHJvb3QoYTIgKyBiMilcbiAgdmFyIHBvczEgPSBfYVswXSxcbiAgICAgIHBvczIgPSBfYVsxXTtcbiAgdmFyIGR4ID0gcG9zMlswXSAtIHBvczFbMF07XG4gIHZhciBkeSA9IHBvczJbMV0gLSBwb3MxWzFdO1xuXG4gIGlmICghZHgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMocG9zMVswXSk7XG4gIH1cblxuICBpZiAoIWR5KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHBvczFbMV0pO1xuICB9IC8vIHkgLSB5MSA9IGEoeCAtIHgxKVxuICAvLyAwID0gYXggLXkgKyAtYSAqIHgxICsgeTFcblxuXG4gIHZhciBhID0gZHkgLyBkeDtcbiAgcmV0dXJuIE1hdGguYWJzKCgtYSAqIHBvczFbMF0gKyBwb3MxWzFdKSAvIE1hdGguc3FydChNYXRoLnBvdyhhLCAyKSArIDEpKTtcbn1cblxuZnVuY3Rpb24gc29sdmVSZXZlcnNlTGluZShfYSkge1xuICB2YXIgcG9zMSA9IF9hWzBdLFxuICAgICAgcG9zMiA9IF9hWzFdO1xuICB2YXIgZHggPSBwb3MyWzBdIC0gcG9zMVswXTtcbiAgdmFyIGR5ID0gcG9zMlsxXSAtIHBvczFbMV07XG5cbiAgaWYgKCFkeCkge1xuICAgIHJldHVybiBbcG9zMVswXSwgMF07XG4gIH1cblxuICBpZiAoIWR5KSB7XG4gICAgcmV0dXJuIFswLCBwb3MxWzFdXTtcbiAgfVxuXG4gIHZhciBhID0gZHkgLyBkeDsgLy8geSAtIHkxID0gYSAoeCAgLSB4MSlcbiAgLy8geSA9IGF4IC0gYSAqIHgxICsgeTFcblxuICB2YXIgYiA9IC1hICogcG9zMVswXSArIHBvczFbMV07IC8vIHkgPSBheCArIGIgPSAtMS9hIHhcbiAgLy8geCA9IC1iIC8gKGEgKyAxIC8gYSlcbiAgLy8geSA9IGIgLyAoMSArIDEgLyBhXjIpXG5cbiAgcmV0dXJuIFstYiAvIChhICsgMSAvIGEpLCBiIC8gKGEgKiBhICsgMSldO1xufVxuXG5mdW5jdGlvbiBjaGVja1JvdGF0ZUlubmVyQm91bmRzKG1vdmVhYmxlLCBwcmV2UG9zZXMsIG5leHRQb3Nlcywgb3JpZ2luLCByb3RhdGlvbikge1xuICB2YXIgYm91bmRzID0gbW92ZWFibGUucHJvcHMuaW5uZXJCb3VuZHM7XG4gIHZhciByYWQgPSByb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XG5cbiAgaWYgKCFib3VuZHMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbGVmdCA9IGJvdW5kcy5sZWZ0LFxuICAgICAgdG9wID0gYm91bmRzLnRvcCxcbiAgICAgIHdpZHRoID0gYm91bmRzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgdmFyIHJlbGF0aXZlTGVmdCA9IGxlZnQgLSBvcmlnaW5bMF07XG4gIHZhciByZWxhdGl2ZVJpZ2h0ID0gbGVmdCArIHdpZHRoIC0gb3JpZ2luWzBdO1xuICB2YXIgcmVsYXRpdmVUb3AgPSB0b3AgLSBvcmlnaW5bMV07XG4gIHZhciByZWxhdGl2ZUJvdHRvbSA9IHRvcCArIGhlaWdodCAtIG9yaWdpblsxXTtcbiAgdmFyIGRvdHMgPSBbW3JlbGF0aXZlTGVmdCwgcmVsYXRpdmVUb3BdLCBbcmVsYXRpdmVSaWdodCwgcmVsYXRpdmVUb3BdLCBbcmVsYXRpdmVMZWZ0LCByZWxhdGl2ZUJvdHRvbV0sIFtyZWxhdGl2ZVJpZ2h0LCByZWxhdGl2ZUJvdHRvbV1dO1xuICB2YXIgY2VudGVyID0gZ2V0UG9zQnlEaXJlY3Rpb24obmV4dFBvc2VzLCBbMCwgMF0pO1xuXG4gIGlmICghaXNCb3VuZFJvdGF0ZSQxKG5leHRQb3NlcywgZG90cywgY2VudGVyLCAwKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGRvdEluZm9zID0gZG90cy5tYXAoZnVuY3Rpb24gKGRvdCkge1xuICAgIHJldHVybiBbZ2V0RGlzdFNpemUoZG90KSwgZ2V0UmFkKFswLCAwXSwgZG90KV07XG4gIH0pO1xuICBbW25leHRQb3Nlc1swXSwgbmV4dFBvc2VzWzFdXSwgW25leHRQb3Nlc1sxXSwgbmV4dFBvc2VzWzNdXSwgW25leHRQb3Nlc1szXSwgbmV4dFBvc2VzWzJdXSwgW25leHRQb3Nlc1syXSwgbmV4dFBvc2VzWzBdXV0uZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIHZhciBsaW5lUmFkID0gZ2V0UmFkKFswLCAwXSwgc29sdmVSZXZlcnNlTGluZShsaW5lKSk7XG4gICAgdmFyIGxpbmVEaXN0ID0gZ2V0RGlzdFBvaW50TGluZShsaW5lKTtcbiAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGRvdEluZm9zLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBkb3REaXN0ID0gX2FbMF07XG4gICAgICByZXR1cm4gZG90RGlzdCAmJiBsaW5lRGlzdCA8PSBkb3REaXN0O1xuICAgIH0pLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBkb3REaXN0ID0gX2FbMF0sXG4gICAgICAgICAgZG90UmFkID0gX2FbMV07XG4gICAgICB2YXIgZGlzdFJhZCA9IE1hdGguYWNvcyhkb3REaXN0ID8gbGluZURpc3QgLyBkb3REaXN0IDogMCk7XG4gICAgICB2YXIgbmV4dFJhZDEgPSBkb3RSYWQgKyBkaXN0UmFkO1xuICAgICAgdmFyIG5leHRSYWQyID0gZG90UmFkIC0gZGlzdFJhZDtcbiAgICAgIHJldHVybiBbcmFkICsgbmV4dFJhZDEgLSBsaW5lUmFkLCByYWQgKyBuZXh0UmFkMiAtIGxpbmVSYWRdO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgICBwcmV2LnB1c2guYXBwbHkocHJldiwgY3VyKTtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIFtdKS5maWx0ZXIoZnVuY3Rpb24gKG5leHRSYWQpIHtcbiAgICAgIHJldHVybiAhaXNCb3VuZFJvdGF0ZSQxKHByZXZQb3NlcywgZG90cywgY2VudGVyLCBuZXh0UmFkKTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKG5leHRSYWQpIHtcbiAgICAgIHJldHVybiB0aHJvdHRsZShuZXh0UmFkICogMTgwIC8gTWF0aC5QSSwgVElOWV9OVU0pO1xuICAgIH0pKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5uZXJCb3VuZFBvc2VzKG1vdmVhYmxlKSB7XG4gIHZhciBpbm5lckJvdW5kcyA9IG1vdmVhYmxlLnByb3BzLmlubmVyQm91bmRzO1xuXG4gIGlmICghaW5uZXJCb3VuZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVydGljYWw6IFtdLFxuICAgICAgaG9yaXpvbnRhbDogW11cbiAgICB9O1xuICB9XG5cbiAgdmFyIF9hID0gbW92ZWFibGUuZ2V0UmVjdCgpLFxuICAgICAgcG9zMSA9IF9hLnBvczEsXG4gICAgICBwb3MyID0gX2EucG9zMixcbiAgICAgIHBvczMgPSBfYS5wb3MzLFxuICAgICAgcG9zNCA9IF9hLnBvczQ7XG5cbiAgdmFyIHBvc2VzID0gW3BvczEsIHBvczIsIHBvczMsIHBvczRdO1xuICB2YXIgY2VudGVyID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIFswLCAwXSk7XG4gIHZhciBsZWZ0ID0gaW5uZXJCb3VuZHMubGVmdCxcbiAgICAgIHRvcCA9IGlubmVyQm91bmRzLnRvcCxcbiAgICAgIHdpZHRoID0gaW5uZXJCb3VuZHMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBpbm5lckJvdW5kcy5oZWlnaHQ7XG4gIHZhciBsZWZ0TGluZSA9IFtbbGVmdCwgdG9wXSwgW2xlZnQsIHRvcCArIGhlaWdodF1dO1xuICB2YXIgdG9wTGluZSA9IFtbbGVmdCwgdG9wXSwgW2xlZnQgKyB3aWR0aCwgdG9wXV07XG4gIHZhciByaWdodExpbmUgPSBbW2xlZnQgKyB3aWR0aCwgdG9wXSwgW2xlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0XV07XG4gIHZhciBib3R0b21MaW5lID0gW1tsZWZ0LCB0b3AgKyBoZWlnaHRdLCBbbGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHRdXTtcbiAgdmFyIGxpbmVJbmZvcyA9IGdldENoZWNrSW5uZXJCb3VuZExpbmVJbmZvcyhtb3ZlYWJsZSwgcG9zZXMsIFswLCAwXSwgZmFsc2UpO1xuICB2YXIgaG9yaXpvbnRhbFBvc2VzID0gW107XG4gIHZhciB2ZXJ0aWNhbFBvc2VzID0gW107XG4gIHZhciBib3VuZE1hcCA9IHtcbiAgICB0b3A6IGZhbHNlLFxuICAgIGJvdHRvbTogZmFsc2UsXG4gICAgbGVmdDogZmFsc2UsXG4gICAgcmlnaHQ6IGZhbHNlXG4gIH07XG4gIGxpbmVJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lSW5mbykge1xuICAgIHZhciBsaW5lID0gbGluZUluZm8ubGluZSxcbiAgICAgICAgbGluZUNvbnN0YW50cyA9IGxpbmVJbmZvLmxpbmVDb25zdGFudHM7XG5cbiAgICB2YXIgX2EgPSBpc1N0YXJ0TGluZShjZW50ZXIsIGxpbmUpLFxuICAgICAgICBpc0hvcml6b250YWxTdGFydCA9IF9hLmhvcml6b250YWwsXG4gICAgICAgIGlzVmVydGljYWxTdGFydCA9IF9hLnZlcnRpY2FsOyAvLyB0ZXN0IHZlcnRpY2FsXG5cblxuICAgIHZhciB0b3BCb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBsaW5lQ29uc3RhbnRzLCB0b3BMaW5lLCBpc1ZlcnRpY2FsU3RhcnQsIDEsIHRydWUpO1xuICAgIHZhciBib3R0b21Cb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBsaW5lQ29uc3RhbnRzLCBib3R0b21MaW5lLCBpc1ZlcnRpY2FsU3RhcnQsIDEsIHRydWUpOyAvLyB0ZXN0IGhvcml6b250YWxcblxuICAgIHZhciBsZWZ0Qm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgbGluZUNvbnN0YW50cywgbGVmdExpbmUsIGlzSG9yaXpvbnRhbFN0YXJ0LCAxLCB0cnVlKTtcbiAgICB2YXIgcmlnaHRCb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBsaW5lQ29uc3RhbnRzLCByaWdodExpbmUsIGlzSG9yaXpvbnRhbFN0YXJ0LCAxLCB0cnVlKTtcblxuICAgIGlmICh0b3BCb3VuZEluZm8uaXNCb3VuZCAmJiAhYm91bmRNYXAudG9wKSB7XG4gICAgICBob3Jpem9udGFsUG9zZXMucHVzaCh0b3ApO1xuICAgICAgYm91bmRNYXAudG9wID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYm90dG9tQm91bmRJbmZvLmlzQm91bmQgJiYgIWJvdW5kTWFwLmJvdHRvbSkge1xuICAgICAgaG9yaXpvbnRhbFBvc2VzLnB1c2godG9wICsgaGVpZ2h0KTtcbiAgICAgIGJvdW5kTWFwLmJvdHRvbSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxlZnRCb3VuZEluZm8uaXNCb3VuZCAmJiAhYm91bmRNYXAubGVmdCkge1xuICAgICAgdmVydGljYWxQb3Nlcy5wdXNoKGxlZnQpO1xuICAgICAgYm91bmRNYXAubGVmdCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0Qm91bmRJbmZvLmlzQm91bmQgJiYgIWJvdW5kTWFwLnJpZ2h0KSB7XG4gICAgICB2ZXJ0aWNhbFBvc2VzLnB1c2gobGVmdCArIHdpZHRoKTtcbiAgICAgIGJvdW5kTWFwLnJpZ2h0ID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGhvcml6b250YWw6IGhvcml6b250YWxQb3NlcyxcbiAgICB2ZXJ0aWNhbDogdmVydGljYWxQb3Nlc1xuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kUG9zZXMoYm91bmRzLCB2ZXJ0aWNhbFBvc2VzLCBob3Jpem9udGFsUG9zZXMpIHtcbiAgdmFyIF9hID0gYm91bmRzIHx8IHt9LFxuICAgICAgX2IgPSBfYS5wb3NpdGlvbixcbiAgICAgIHBvc2l0aW9uID0gX2IgPT09IHZvaWQgMCA/IFwiY2xpZW50XCIgOiBfYixcbiAgICAgIF9jID0gX2EubGVmdCxcbiAgICAgIGxlZnQgPSBfYyA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2MsXG4gICAgICBfZCA9IF9hLnRvcCxcbiAgICAgIHRvcCA9IF9kID09PSB2b2lkIDAgPyAtSW5maW5pdHkgOiBfZCxcbiAgICAgIF9lID0gX2EucmlnaHQsXG4gICAgICByaWdodCA9IF9lID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9lLFxuICAgICAgX2YgPSBfYS5ib3R0b20sXG4gICAgICBib3R0b20gPSBfZiA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfZjtcblxuICB2YXIgbmV4dEJvdW5kcyA9IHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgbGVmdDogbGVmdCxcbiAgICB0b3A6IHRvcCxcbiAgICByaWdodDogcmlnaHQsXG4gICAgYm90dG9tOiBib3R0b21cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNhbDogY2hlY2tCb3VuZHMobmV4dEJvdW5kcywgdmVydGljYWxQb3NlcywgdHJ1ZSksXG4gICAgaG9yaXpvbnRhbDogY2hlY2tCb3VuZHMobmV4dEJvdW5kcywgaG9yaXpvbnRhbFBvc2VzLCBmYWxzZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRzKG1vdmVhYmxlLCBleHRlcm5hbEJvdW5kcykge1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIF9iID0gX2EuY29udGFpbmVyQ2xpZW50UmVjdCxcbiAgICAgIGNvbnRhaW5lckhlaWdodCA9IF9iLmNsaWVudEhlaWdodCxcbiAgICAgIGNvbnRhaW5lcldpZHRoID0gX2IuY2xpZW50V2lkdGgsXG4gICAgICBjbGllbnRMZWZ0ID0gX2IuY2xpZW50TGVmdCxcbiAgICAgIGNsaWVudFRvcCA9IF9iLmNsaWVudFRvcCxcbiAgICAgIF9jID0gX2Euc25hcE9mZnNldCxcbiAgICAgIHNuYXBPZmZzZXRMZWZ0ID0gX2MubGVmdCxcbiAgICAgIHNuYXBPZmZzZXRUb3AgPSBfYy50b3AsXG4gICAgICBzbmFwT2Zmc2V0UmlnaHQgPSBfYy5yaWdodCxcbiAgICAgIHNuYXBPZmZzZXRCb3R0b20gPSBfYy5ib3R0b207XG4gIHZhciBib3VuZHMgPSBleHRlcm5hbEJvdW5kcyB8fCBtb3ZlYWJsZS5wcm9wcy5ib3VuZHMgfHwge307XG4gIHZhciBwb3NpdGlvbiA9IGJvdW5kcy5wb3NpdGlvbiB8fCBcImNsaWVudFwiO1xuICB2YXIgaXNDU1MgPSBwb3NpdGlvbiA9PT0gXCJjc3NcIjtcbiAgdmFyIF9kID0gYm91bmRzLmxlZnQsXG4gICAgICBsZWZ0ID0gX2QgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF9kLFxuICAgICAgX2UgPSBib3VuZHMudG9wLFxuICAgICAgdG9wID0gX2UgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF9lO1xuICB2YXIgX2YgPSBib3VuZHMucmlnaHQsXG4gICAgICByaWdodCA9IF9mID09PSB2b2lkIDAgPyBpc0NTUyA/IC1JbmZpbml0eSA6IEluZmluaXR5IDogX2YsXG4gICAgICBfZyA9IGJvdW5kcy5ib3R0b20sXG4gICAgICBib3R0b20gPSBfZyA9PT0gdm9pZCAwID8gaXNDU1MgPyAtSW5maW5pdHkgOiBJbmZpbml0eSA6IF9nO1xuXG4gIGlmIChpc0NTUykge1xuICAgIHJpZ2h0ID0gY29udGFpbmVyV2lkdGggKyBzbmFwT2Zmc2V0UmlnaHQgLSBzbmFwT2Zmc2V0TGVmdCAtIHJpZ2h0O1xuICAgIGJvdHRvbSA9IGNvbnRhaW5lckhlaWdodCArIHNuYXBPZmZzZXRCb3R0b20gLSBzbmFwT2Zmc2V0VG9wIC0gYm90dG9tO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0ICsgc25hcE9mZnNldExlZnQgLSBjbGllbnRMZWZ0LFxuICAgIHJpZ2h0OiByaWdodCArIHNuYXBPZmZzZXRMZWZ0IC0gY2xpZW50TGVmdCxcbiAgICB0b3A6IHRvcCArIHNuYXBPZmZzZXRUb3AgLSBjbGllbnRUb3AsXG4gICAgYm90dG9tOiBib3R0b20gKyBzbmFwT2Zmc2V0VG9wIC0gY2xpZW50VG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgdmFyIF9hID0gZ2V0Qm91bmRzKG1vdmVhYmxlKSxcbiAgICAgIGxlZnQgPSBfYS5sZWZ0LFxuICAgICAgdG9wID0gX2EudG9wLFxuICAgICAgcmlnaHQgPSBfYS5yaWdodCxcbiAgICAgIGJvdHRvbSA9IF9hLmJvdHRvbTtcblxuICB2YXIgZW5kWCA9IGVuZFBvc1swXSxcbiAgICAgIGVuZFkgPSBlbmRQb3NbMV07XG5cbiAgdmFyIF9iID0gbWludXMoZW5kUG9zLCBzdGFydFBvcyksXG4gICAgICBkeCA9IF9iWzBdLFxuICAgICAgZHkgPSBfYlsxXTtcblxuICBpZiAoTWF0aC5hYnMoZHgpIDwgVElOWV9OVU0pIHtcbiAgICBkeCA9IDA7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoZHkpIDwgVElOWV9OVU0pIHtcbiAgICBkeSA9IDA7XG4gIH1cblxuICB2YXIgaXNCb3R0b20gPSBkeSA+IDA7XG4gIHZhciBpc1JpZ2h0ID0gZHggPiAwO1xuICB2YXIgdmVydGljYWxJbmZvID0ge1xuICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgIG9mZnNldDogMCxcbiAgICBwb3M6IDBcbiAgfTtcbiAgdmFyIGhvcml6b250YWxJbmZvID0ge1xuICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgIG9mZnNldDogMCxcbiAgICBwb3M6IDBcbiAgfTtcblxuICBpZiAoZHggPT09IDAgJiYgZHkgPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVydGljYWw6IHZlcnRpY2FsSW5mbyxcbiAgICAgIGhvcml6b250YWw6IGhvcml6b250YWxJbmZvXG4gICAgfTtcbiAgfSBlbHNlIGlmIChkeCA9PT0gMCkge1xuICAgIGlmIChpc0JvdHRvbSkge1xuICAgICAgaWYgKGJvdHRvbSA8IGVuZFkpIHtcbiAgICAgICAgaG9yaXpvbnRhbEluZm8ucG9zID0gYm90dG9tO1xuICAgICAgICBob3Jpem9udGFsSW5mby5vZmZzZXQgPSBlbmRZIC0gYm90dG9tO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9wID4gZW5kWSkge1xuICAgICAgICBob3Jpem9udGFsSW5mby5wb3MgPSB0b3A7XG4gICAgICAgIGhvcml6b250YWxJbmZvLm9mZnNldCA9IGVuZFkgLSB0b3A7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGR5ID09PSAwKSB7XG4gICAgaWYgKGlzUmlnaHQpIHtcbiAgICAgIGlmIChyaWdodCA8IGVuZFgpIHtcbiAgICAgICAgdmVydGljYWxJbmZvLnBvcyA9IHJpZ2h0O1xuICAgICAgICB2ZXJ0aWNhbEluZm8ub2Zmc2V0ID0gZW5kWCAtIHJpZ2h0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGVmdCA+IGVuZFgpIHtcbiAgICAgICAgdmVydGljYWxJbmZvLnBvcyA9IGxlZnQ7XG4gICAgICAgIHZlcnRpY2FsSW5mby5vZmZzZXQgPSBlbmRYIC0gbGVmdDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8geSAtIHkxID0gYSAqICh4IC0geDEpXG4gICAgdmFyIGEgPSBkeSAvIGR4O1xuICAgIHZhciBiID0gZW5kUG9zWzFdIC0gYSAqIGVuZFg7XG4gICAgdmFyIHkgPSAwO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgaXNCb3VuZCA9IGZhbHNlO1xuXG4gICAgaWYgKGlzUmlnaHQgJiYgcmlnaHQgPD0gZW5kWCkge1xuICAgICAgeSA9IGEgKiByaWdodCArIGI7XG4gICAgICB4ID0gcmlnaHQ7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFpc1JpZ2h0ICYmIGVuZFggPD0gbGVmdCkge1xuICAgICAgeSA9IGEgKiBsZWZ0ICsgYjtcbiAgICAgIHggPSBsZWZ0O1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQm91bmQpIHtcbiAgICAgIGlmICh5IDwgdG9wIHx8IHkgPiBib3R0b20pIHtcbiAgICAgICAgaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNCb3VuZCkge1xuICAgICAgaWYgKGlzQm90dG9tICYmIGJvdHRvbSA8PSBlbmRZKSB7XG4gICAgICAgIHkgPSBib3R0b207XG4gICAgICAgIHggPSAoeSAtIGIpIC8gYTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCFpc0JvdHRvbSAmJiBlbmRZIDw9IHRvcCkge1xuICAgICAgICB5ID0gdG9wO1xuICAgICAgICB4ID0gKHkgLSBiKSAvIGE7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0JvdW5kKSB7XG4gICAgICB2ZXJ0aWNhbEluZm8uaXNCb3VuZCA9IHRydWU7XG4gICAgICB2ZXJ0aWNhbEluZm8ucG9zID0geDtcbiAgICAgIHZlcnRpY2FsSW5mby5vZmZzZXQgPSBlbmRYIC0geDtcbiAgICAgIGhvcml6b250YWxJbmZvLmlzQm91bmQgPSB0cnVlO1xuICAgICAgaG9yaXpvbnRhbEluZm8ucG9zID0geTtcbiAgICAgIGhvcml6b250YWxJbmZvLm9mZnNldCA9IGVuZFkgLSB5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmVydGljYWw6IHZlcnRpY2FsSW5mbyxcbiAgICBob3Jpem9udGFsOiBob3Jpem9udGFsSW5mb1xuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyhib3VuZHMsIHBvc2VzLCBpc1ZlcnRpY2FsKSB7XG4gIC8vIDAgICBbMTAwIC0gMjAwXSAgMzAwXG4gIHZhciBzdGFydEJvdW5kUG9zID0gYm91bmRzW2lzVmVydGljYWwgPyBcImxlZnRcIiA6IFwidG9wXCJdO1xuICB2YXIgZW5kQm91bmRQb3MgPSBib3VuZHNbaXNWZXJ0aWNhbCA/IFwicmlnaHRcIiA6IFwiYm90dG9tXCJdOyAvLyA0NTBcblxuICB2YXIgbWluUG9zID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgcG9zZXMpO1xuICB2YXIgbWF4UG9zID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgcG9zZXMpO1xuICB2YXIgYm91bmRJbmZvcyA9IFtdO1xuXG4gIGlmIChzdGFydEJvdW5kUG9zICsgMSA+IG1pblBvcykge1xuICAgIGJvdW5kSW5mb3MucHVzaCh7XG4gICAgICBpc0JvdW5kOiB0cnVlLFxuICAgICAgb2Zmc2V0OiBtaW5Qb3MgLSBzdGFydEJvdW5kUG9zLFxuICAgICAgcG9zOiBzdGFydEJvdW5kUG9zXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZW5kQm91bmRQb3MgLSAxIDwgbWF4UG9zKSB7XG4gICAgYm91bmRJbmZvcy5wdXNoKHtcbiAgICAgIGlzQm91bmQ6IHRydWUsXG4gICAgICBvZmZzZXQ6IG1heFBvcyAtIGVuZEJvdW5kUG9zLFxuICAgICAgcG9zOiBlbmRCb3VuZFBvc1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFib3VuZEluZm9zLmxlbmd0aCkge1xuICAgIGJvdW5kSW5mb3MucHVzaCh7XG4gICAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIHBvczogMFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGJvdW5kSW5mb3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBNYXRoLmFicyhiLm9mZnNldCkgLSBNYXRoLmFicyhhLm9mZnNldCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0JvdW5kUm90YXRlKHJlbGF0aXZlUG9zZXMsIGJvdW5kUmVjdCwgcmFkKSB7XG4gIHZhciBuZXh0UG9zZXMgPSByYWQgPyByZWxhdGl2ZVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHJvdGF0ZShwb3MsIHJhZCk7XG4gIH0pIDogcmVsYXRpdmVQb3NlcztcbiAgcmV0dXJuIG5leHRQb3Nlcy5zb21lKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zWzBdIDwgYm91bmRSZWN0LmxlZnQgJiYgTWF0aC5hYnMocG9zWzBdIC0gYm91bmRSZWN0LmxlZnQpID4gMC4xIHx8IHBvc1swXSA+IGJvdW5kUmVjdC5yaWdodCAmJiBNYXRoLmFicyhwb3NbMF0gLSBib3VuZFJlY3QucmlnaHQpID4gMC4xIHx8IHBvc1sxXSA8IGJvdW5kUmVjdC50b3AgJiYgTWF0aC5hYnMocG9zWzFdIC0gYm91bmRSZWN0LnRvcCkgPiAwLjEgfHwgcG9zWzFdID4gYm91bmRSZWN0LmJvdHRvbSAmJiBNYXRoLmFicyhwb3NbMV0gLSBib3VuZFJlY3QuYm90dG9tKSA+IDAuMTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kUm90YXRlKHZlYywgYm91bmRQb3MsIGluZGV4KSB7XG4gIHZhciByID0gZ2V0RGlzdFNpemUodmVjKTtcbiAgdmFyIG5leHRQb3MgPSBNYXRoLnNxcnQociAqIHIgLSBib3VuZFBvcyAqIGJvdW5kUG9zKSB8fCAwO1xuICByZXR1cm4gW25leHRQb3MsIC1uZXh0UG9zXS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSB2ZWNbaW5kZXggPyAwIDogMV0pIC0gTWF0aC5hYnMoYiAtIHZlY1tpbmRleCA/IDAgOiAxXSk7XG4gIH0pLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIGdldFJhZChbMCwgMF0sIGluZGV4ID8gW3BvcywgYm91bmRQb3NdIDogW2JvdW5kUG9zLCBwb3NdKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUm90YXRlQm91bmRzKG1vdmVhYmxlLCBwcmV2UG9zZXMsIG5leHRQb3Nlcywgb3JpZ2luLCByb3RhdGlvbikge1xuICBpZiAoIW1vdmVhYmxlLnByb3BzLmJvdW5kcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciByYWQgPSByb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XG5cbiAgdmFyIF9hID0gZ2V0Qm91bmRzKG1vdmVhYmxlKSxcbiAgICAgIGxlZnQgPSBfYS5sZWZ0LFxuICAgICAgdG9wID0gX2EudG9wLFxuICAgICAgcmlnaHQgPSBfYS5yaWdodCxcbiAgICAgIGJvdHRvbSA9IF9hLmJvdHRvbTtcblxuICB2YXIgcmVsYXRpdmVMZWZ0ID0gbGVmdCAtIG9yaWdpblswXTtcbiAgdmFyIHJlbGF0aXZlUmlnaHQgPSByaWdodCAtIG9yaWdpblswXTtcbiAgdmFyIHJlbGF0aXZlVG9wID0gdG9wIC0gb3JpZ2luWzFdO1xuICB2YXIgcmVsYXRpdmVCb3R0b20gPSBib3R0b20gLSBvcmlnaW5bMV07XG4gIHZhciBib3VuZFJlY3QgPSB7XG4gICAgbGVmdDogcmVsYXRpdmVMZWZ0LFxuICAgIHRvcDogcmVsYXRpdmVUb3AsXG4gICAgcmlnaHQ6IHJlbGF0aXZlUmlnaHQsXG4gICAgYm90dG9tOiByZWxhdGl2ZUJvdHRvbVxuICB9O1xuXG4gIGlmICghaXNCb3VuZFJvdGF0ZShuZXh0UG9zZXMsIGJvdW5kUmVjdCwgMCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIFtbcmVsYXRpdmVMZWZ0LCAwXSwgW3JlbGF0aXZlUmlnaHQsIDBdLCBbcmVsYXRpdmVUb3AsIDFdLCBbcmVsYXRpdmVCb3R0b20sIDFdXS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBib3VuZFBvcyA9IF9hWzBdLFxuICAgICAgICBpbmRleCA9IF9hWzFdO1xuICAgIG5leHRQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXh0UG9zKSB7XG4gICAgICB2YXIgcmVsYXRpdmVSYWQxID0gZ2V0UmFkKFswLCAwXSwgbmV4dFBvcyk7XG4gICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGJvdW5kUm90YXRlKG5leHRQb3MsIGJvdW5kUG9zLCBpbmRleCkubWFwKGZ1bmN0aW9uIChyZWxhdGl2ZVJhZDIpIHtcbiAgICAgICAgcmV0dXJuIHJhZCArIHJlbGF0aXZlUmFkMiAtIHJlbGF0aXZlUmFkMTtcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAobmV4dFJhZCkge1xuICAgICAgICByZXR1cm4gIWlzQm91bmRSb3RhdGUocHJldlBvc2VzLCBib3VuZFJlY3QsIG5leHRSYWQpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChuZXh0UmFkKSB7XG4gICAgICAgIHJldHVybiB0aHJvdHRsZShuZXh0UmFkICogMTgwIC8gTWF0aC5QSSwgVElOWV9OVU0pO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyR3VpZGVsaW5lKGluZm8sIFJlYWN0KSB7XG4gIHZhciBfYTtcblxuICB2YXIgZGlyZWN0aW9uID0gaW5mby5kaXJlY3Rpb24sXG4gICAgICBjbGFzc05hbWVzID0gaW5mby5jbGFzc05hbWVzLFxuICAgICAgc2l6ZSA9IGluZm8uc2l6ZSxcbiAgICAgIHBvcyA9IGluZm8ucG9zLFxuICAgICAgem9vbSA9IGluZm8uem9vbSxcbiAgICAgIGtleSA9IGluZm8ua2V5O1xuICB2YXIgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgdmFyIHNjYWxlVHlwZSA9IGlzSG9yaXpvbnRhbCA/IFwiWVwiIDogXCJYXCI7IC8vIGNvbnN0IHNjYWxlVHlwZTIgPSBpc0hvcml6b250YWwgPyBcIllcIiA6IFwiWFwiO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IGtleSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbihcIiBcIiksXG4gICAgc3R5bGU6IChfYSA9IHt9LCBfYVtpc0hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA9IFwiXCIuY29uY2F0KHNpemUpLCBfYS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQocG9zWzBdLCBcIiwgXCIpLmNvbmNhdChwb3NbMV0sIFwiKSB0cmFuc2xhdGVcIikuY29uY2F0KHNjYWxlVHlwZSwgXCIoLTUwJSkgc2NhbGVcIikuY29uY2F0KHNjYWxlVHlwZSwgXCIoXCIpLmNvbmNhdCh6b29tLCBcIilcIiksIF9hKVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySW5uZXJHdWlkZWxpbmUoaW5mbywgUmVhY3QpIHtcbiAgcmV0dXJuIHJlbmRlckd1aWRlbGluZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5mbyksIHtcbiAgICBjbGFzc05hbWVzOiBfX3NwcmVhZEFycmF5KFtwcmVmaXgoXCJsaW5lXCIsIFwiZ3VpZGVsaW5lXCIsIGluZm8uZGlyZWN0aW9uKV0sIGluZm8uY2xhc3NOYW1lcywgdHJ1ZSkuZmlsdGVyKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfSksXG4gICAgc2l6ZTogaW5mby5zaXplIHx8IFwiXCIuY29uY2F0KGluZm8uc2l6ZVZhbHVlLCBcInB4XCIpLFxuICAgIHBvczogaW5mby5wb3MgfHwgaW5mby5wb3NWYWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aHJvdHRsZSh2LCAwLjEpLCBcInB4XCIpO1xuICAgIH0pXG4gIH0pLCBSZWFjdCk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNuYXBQb3Nlcyhtb3ZlYWJsZSwgZGlyZWN0aW9uLCBzbmFwUG9zZXMsIG1pblBvcywgdGFyZ2V0UG9zLCBzaXplLCBpbmRleCwgUmVhY3QpIHtcbiAgdmFyIHpvb20gPSBtb3ZlYWJsZS5wcm9wcy56b29tO1xuICByZXR1cm4gc25hcFBvc2VzLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcbiAgICB2YXIgdHlwZSA9IF9hLnR5cGUsXG4gICAgICAgIHBvcyA9IF9hLnBvcztcbiAgICB2YXIgcmVuZGVyUG9zID0gWzAsIDBdO1xuICAgIHJlbmRlclBvc1tpbmRleF0gPSBtaW5Qb3M7XG4gICAgcmVuZGVyUG9zW2luZGV4ID8gMCA6IDFdID0gLXRhcmdldFBvcyArIHBvcztcbiAgICByZXR1cm4gcmVuZGVySW5uZXJHdWlkZWxpbmUoe1xuICAgICAga2V5OiBcIlwiLmNvbmNhdChkaXJlY3Rpb24sIFwiVGFyZ2V0R3VpZGVsaW5lXCIpLmNvbmNhdChpKSxcbiAgICAgIGNsYXNzTmFtZXM6IFtwcmVmaXgoXCJ0YXJnZXRcIiwgXCJib2xkXCIsIHR5cGUpXSxcbiAgICAgIHBvc1ZhbHVlOiByZW5kZXJQb3MsXG4gICAgICBzaXplVmFsdWU6IHNpemUsXG4gICAgICB6b29tOiB6b29tLFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICB9LCBSZWFjdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJHdWlkZWxpbmVzKG1vdmVhYmxlLCB0eXBlLCBndWlkZWxpbmVzLCB0YXJnZXRQb3MsIHRhcmdldFJlY3QsIFJlYWN0KSB7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgem9vbSA9IF9hLnpvb20sXG4gICAgICBpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCA9IF9hLmlzRGlzcGxheUlubmVyU25hcERpZ2l0O1xuICB2YXIgbWFpbk5hbWVzID0gdHlwZSA9PT0gXCJob3Jpem9udGFsXCIgPyBWRVJUSUNBTF9OQU1FU19NQVAgOiBIT1JJWk9OVEFMX05BTUVTX01BUDtcbiAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuc3RhcnRdO1xuICB2YXIgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuZW5kXTtcbiAgcmV0dXJuIGd1aWRlbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBoaWRlID0gX2EuaGlkZSxcbiAgICAgICAgZWxlbWVudFJlY3QgPSBfYS5lbGVtZW50UmVjdDtcblxuICAgIGlmIChoaWRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGxheUlubmVyU25hcERpZ2l0ICYmIGVsZW1lbnRSZWN0KSB7XG4gICAgICAvLyBpbm5lclxuICAgICAgdmFyIHJlY3QgPSBlbGVtZW50UmVjdC5yZWN0O1xuXG4gICAgICBpZiAocmVjdFttYWluTmFtZXMuc3RhcnRdIDw9IHRhcmdldFN0YXJ0ICYmIHRhcmdldEVuZCA8PSByZWN0W21haW5OYW1lcy5lbmRdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkubWFwKGZ1bmN0aW9uIChndWlkZWxpbmUsIGkpIHtcbiAgICB2YXIgcG9zID0gZ3VpZGVsaW5lLnBvcyxcbiAgICAgICAgc2l6ZSA9IGd1aWRlbGluZS5zaXplLFxuICAgICAgICBlbGVtZW50ID0gZ3VpZGVsaW5lLmVsZW1lbnQ7XG4gICAgdmFyIHJlbmRlclBvcyA9IFstdGFyZ2V0UG9zWzBdICsgcG9zWzBdLCAtdGFyZ2V0UG9zWzFdICsgcG9zWzFdXTtcbiAgICByZXR1cm4gcmVuZGVySW5uZXJHdWlkZWxpbmUoe1xuICAgICAga2V5OiBcIlwiLmNvbmNhdCh0eXBlLCBcIi1kZWZhdWx0LWd1aWRlbGluZS1cIikuY29uY2F0KGkpLFxuICAgICAgY2xhc3NOYW1lczogZWxlbWVudCA/IFtwcmVmaXgoXCJib2xkXCIpXSA6IFtdLFxuICAgICAgZGlyZWN0aW9uOiB0eXBlLFxuICAgICAgcG9zVmFsdWU6IHJlbmRlclBvcyxcbiAgICAgIHNpemVWYWx1ZTogc2l6ZSxcbiAgICAgIHpvb206IHpvb21cbiAgICB9LCBSZWFjdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJEaWdpdExpbmUobW92ZWFibGUsIHR5cGUsIGxpbmVUeXBlLCBpbmRleCwgZ2FwLCByZW5kZXJQb3MsIGNsYXNzTmFtZSwgUmVhY3QpIHtcbiAgdmFyIF9hO1xuXG4gIHZhciBfYiA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgX2MgPSBfYi5zbmFwRGlnaXQsXG4gICAgICBzbmFwRGlnaXQgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLFxuICAgICAgX2QgPSBfYi5pc0Rpc3BsYXlTbmFwRGlnaXQsXG4gICAgICBpc0Rpc3BsYXlTbmFwRGlnaXQgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLFxuICAgICAgX2UgPSBfYi5zbmFwRGlzdEZvcm1hdCxcbiAgICAgIHNuYXBEaXN0Rm9ybWF0ID0gX2UgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh2LCB0eXBlKSB7XG4gICAgLy8gVHlwZSBjYW4gYmUgdXNlZCByZW5kZXIgZGlmZmVyZW50IHZhbHVlcy5cbiAgICBpZiAodHlwZSA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG4gIH0gOiBfZSxcbiAgICAgIHpvb20gPSBfYi56b29tO1xuICB2YXIgc2NhbGVUeXBlID0gdHlwZSA9PT0gXCJob3Jpem9udGFsXCIgPyBcIlhcIiA6IFwiWVwiO1xuICB2YXIgc2l6ZU5hbWUgPSB0eXBlID09PSBcInZlcnRpY2FsXCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICB2YXIgYWJzR2FwID0gTWF0aC5hYnMoZ2FwKTtcbiAgdmFyIHNuYXBTaXplID0gaXNEaXNwbGF5U25hcERpZ2l0ID8gcGFyc2VGbG9hdChhYnNHYXAudG9GaXhlZChzbmFwRGlnaXQpKSA6IDA7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwiXCIuY29uY2F0KHR5cGUsIFwiLVwiKS5jb25jYXQobGluZVR5cGUsIFwiLWd1aWRlbGluZS1cIikuY29uY2F0KGluZGV4KSxcbiAgICBjbGFzc05hbWU6IHByZWZpeChcImd1aWRlbGluZS1ncm91cFwiLCB0eXBlKSxcbiAgICBzdHlsZTogKF9hID0ge1xuICAgICAgbGVmdDogXCJcIi5jb25jYXQocmVuZGVyUG9zWzBdLCBcInB4XCIpLFxuICAgICAgdG9wOiBcIlwiLmNvbmNhdChyZW5kZXJQb3NbMV0sIFwicHhcIilcbiAgICB9LCBfYVtzaXplTmFtZV0gPSBcIlwiLmNvbmNhdChhYnNHYXAsIFwicHhcIiksIF9hKVxuICB9LCByZW5kZXJJbm5lckd1aWRlbGluZSh7XG4gICAgZGlyZWN0aW9uOiB0eXBlLFxuICAgIGNsYXNzTmFtZXM6IFtwcmVmaXgobGluZVR5cGUpLCBjbGFzc05hbWVdLFxuICAgIHNpemU6IFwiMTAwJVwiLFxuICAgIHBvc1ZhbHVlOiBbMCwgMF0sXG4gICAgc2l6ZVZhbHVlOiBhYnNHYXAsXG4gICAgem9vbTogem9vbVxuICB9LCBSZWFjdCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogcHJlZml4KFwic2l6ZS12YWx1ZVwiLCBcImdhcFwiKSxcbiAgICBzdHlsZToge1xuICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVwiLmNvbmNhdChzY2FsZVR5cGUsIFwiKC01MCUpIHNjYWxlKFwiKS5jb25jYXQoem9vbSwgXCIpXCIpXG4gICAgfVxuICB9LCBzbmFwU2l6ZSA+IDAgPyBzbmFwRGlzdEZvcm1hdChzbmFwU2l6ZSwgdHlwZSkgOiBcIlwiKSk7XG59XG5cbmZ1bmN0aW9uIGdyb3VwQnlFbGVtZW50R3VpZGVsaW5lcyh0eXBlLCBndWlkZWxpbmVzLCB0YXJnZXRSZWN0LCBpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCkge1xuICB2YXIgaW5kZXggPSB0eXBlID09PSBcInZlcnRpY2FsXCIgPyAwIDogMTtcbiAgdmFyIG90aGVySW5kZXggPSB0eXBlID09PSBcInZlcnRpY2FsXCIgPyAxIDogMDtcbiAgdmFyIG5hbWVzID0gaW5kZXggPyBWRVJUSUNBTF9OQU1FU19NQVAgOiBIT1JJWk9OVEFMX05BTUVTX01BUDtcbiAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFtuYW1lcy5zdGFydF07XG4gIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W25hbWVzLmVuZF07XG4gIHJldHVybiBncm91cEJ5KGd1aWRlbGluZXMsIGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcbiAgICByZXR1cm4gZ3VpZGVsaW5lLnBvc1tpbmRleF07XG4gIH0pLm1hcChmdW5jdGlvbiAobmV4dEd1aWRlbGluZXMpIHtcbiAgICB2YXIgc3RhcnQgPSBbXTtcbiAgICB2YXIgZW5kID0gW107XG4gICAgdmFyIGlubmVyID0gW107XG4gICAgbmV4dEd1aWRlbGluZXMuZm9yRWFjaChmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuXG4gICAgICB2YXIgZWxlbWVudCA9IGd1aWRlbGluZS5lbGVtZW50O1xuICAgICAgdmFyIHJlY3QgPSBndWlkZWxpbmUuZWxlbWVudFJlY3QucmVjdDtcblxuICAgICAgaWYgKHJlY3RbbmFtZXMuZW5kXSA8IHRhcmdldFN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0LnB1c2goZ3VpZGVsaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0RW5kIDwgcmVjdFtuYW1lcy5zdGFydF0pIHtcbiAgICAgICAgZW5kLnB1c2goZ3VpZGVsaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAocmVjdFtuYW1lcy5zdGFydF0gPD0gdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0RW5kIDw9IHJlY3RbbmFtZXMuZW5kXSAmJiBpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCkge1xuICAgICAgICB2YXIgcG9zID0gZ3VpZGVsaW5lLnBvcztcbiAgICAgICAgdmFyIGVsZW1lbnRSZWN0MSA9IHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIHJlY3Q6IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZWN0KSwgKF9hID0ge30sIF9hW25hbWVzLmVuZF0gPSByZWN0W25hbWVzLnN0YXJ0XSwgX2EpKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZWxlbWVudFJlY3QyID0ge1xuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgcmVjdDogX19hc3NpZ24oX19hc3NpZ24oe30sIHJlY3QpLCAoX2IgPSB7fSwgX2JbbmFtZXMuc3RhcnRdID0gcmVjdFtuYW1lcy5lbmRdLCBfYikpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBuZXh0UG9zMSA9IFswLCAwXTtcbiAgICAgICAgdmFyIG5leHRQb3MyID0gWzAsIDBdO1xuICAgICAgICBuZXh0UG9zMVtpbmRleF0gPSBwb3NbaW5kZXhdO1xuICAgICAgICBuZXh0UG9zMVtvdGhlckluZGV4XSA9IHBvc1tvdGhlckluZGV4XTtcbiAgICAgICAgbmV4dFBvczJbaW5kZXhdID0gcG9zW2luZGV4XTtcbiAgICAgICAgbmV4dFBvczJbb3RoZXJJbmRleF0gPSBwb3Nbb3RoZXJJbmRleF0gKyBndWlkZWxpbmUuc2l6ZTtcbiAgICAgICAgc3RhcnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBwb3M6IG5leHRQb3MxLFxuICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgZWxlbWVudFJlY3Q6IGVsZW1lbnRSZWN0MVxuICAgICAgICB9KTtcbiAgICAgICAgZW5kLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgcG9zOiBuZXh0UG9zMixcbiAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgIGVsZW1lbnRSZWN0OiBlbGVtZW50UmVjdDJcbiAgICAgICAgfSk7IC8vIGlubmVyLnB1c2goZ3VpZGVsaW5lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdGFydC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5wb3Nbb3RoZXJJbmRleF0gLSBhLnBvc1tvdGhlckluZGV4XTtcbiAgICB9KTtcbiAgICBlbmQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEucG9zW290aGVySW5kZXhdIC0gYi5wb3Nbb3RoZXJJbmRleF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsOiBuZXh0R3VpZGVsaW5lcyxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kLFxuICAgICAgaW5uZXI6IGlubmVyXG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckRhc2hlZEd1aWRlbGluZXMobW92ZWFibGUsIGd1aWRlbGluZXMsIHRhcmdldFBvcywgdGFyZ2V0UmVjdCwgUmVhY3QpIHtcbiAgdmFyIGlzRGlzcGxheUlubmVyU25hcERpZ2l0ID0gbW92ZWFibGUucHJvcHMuaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQ7XG4gIHZhciByZW5kZXJlZCA9IFtdO1xuICBbXCJ2ZXJ0aWNhbFwiLCBcImhvcml6b250YWxcIl0uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBuZXh0R3VpZGVsaW5lcyA9IGd1aWRlbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcbiAgICAgIHJldHVybiBndWlkZWxpbmUudHlwZSA9PT0gdHlwZTtcbiAgICB9KTtcbiAgICB2YXIgaW5kZXggPSB0eXBlID09PSBcInZlcnRpY2FsXCIgPyAxIDogMDtcbiAgICB2YXIgb3RoZXJJbmRleCA9IGluZGV4ID8gMCA6IDE7XG4gICAgdmFyIGdyb3VwcyA9IGdyb3VwQnlFbGVtZW50R3VpZGVsaW5lcyh0eXBlLCBuZXh0R3VpZGVsaW5lcywgdGFyZ2V0UmVjdCwgaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQpO1xuICAgIHZhciBtYWluTmFtZXMgPSBpbmRleCA/IEhPUklaT05UQUxfTkFNRVNfTUFQIDogVkVSVElDQUxfTkFNRVNfTUFQO1xuICAgIHZhciBzaWRlTmFtZXMgPSBpbmRleCA/IFZFUlRJQ0FMX05BTUVTX01BUCA6IEhPUklaT05UQUxfTkFNRVNfTUFQO1xuICAgIHZhciB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLnN0YXJ0XTtcbiAgICB2YXIgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuZW5kXTtcbiAgICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciB0b3RhbCA9IF9hLnRvdGFsLFxuICAgICAgICAgIHN0YXJ0ID0gX2Euc3RhcnQsXG4gICAgICAgICAgZW5kID0gX2EuZW5kLFxuICAgICAgICAgIGlubmVyID0gX2EuaW5uZXI7XG4gICAgICB2YXIgc2lkZVBvcyA9IHRhcmdldFBvc1tvdGhlckluZGV4XSArIHRvdGFsWzBdLnBvc1tvdGhlckluZGV4XSAtIHRhcmdldFJlY3Rbc2lkZU5hbWVzLnN0YXJ0XTtcbiAgICAgIHZhciBwcmV2UmVjdCA9IHRhcmdldFJlY3Q7XG4gICAgICBzdGFydC5mb3JFYWNoKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcbiAgICAgICAgdmFyIG5leHRSZWN0ID0gZ3VpZGVsaW5lLmVsZW1lbnRSZWN0LnJlY3Q7XG4gICAgICAgIHZhciBzaXplID0gcHJldlJlY3RbbWFpbk5hbWVzLnN0YXJ0XSAtIG5leHRSZWN0W21haW5OYW1lcy5lbmRdO1xuXG4gICAgICAgIGlmIChzaXplID4gMCkge1xuICAgICAgICAgIHZhciByZW5kZXJQb3MgPSBbMCwgMF07XG4gICAgICAgICAgcmVuZGVyUG9zW2luZGV4XSA9IHRhcmdldFBvc1tpbmRleF0gKyBwcmV2UmVjdFttYWluTmFtZXMuc3RhcnRdIC0gdGFyZ2V0U3RhcnQgLSBzaXplO1xuICAgICAgICAgIHJlbmRlclBvc1tvdGhlckluZGV4XSA9IHNpZGVQb3M7XG4gICAgICAgICAgcmVuZGVyZWQucHVzaChyZW5kZXJEaWdpdExpbmUobW92ZWFibGUsIHR5cGUsIFwiZGFzaGVkXCIsIHJlbmRlcmVkLmxlbmd0aCwgc2l6ZSwgcmVuZGVyUG9zLCBndWlkZWxpbmUuY2xhc3NOYW1lLCBSZWFjdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldlJlY3QgPSBuZXh0UmVjdDtcbiAgICAgIH0pO1xuICAgICAgcHJldlJlY3QgPSB0YXJnZXRSZWN0O1xuICAgICAgZW5kLmZvckVhY2goZnVuY3Rpb24gKGd1aWRlbGluZSkge1xuICAgICAgICB2YXIgbmV4dFJlY3QgPSBndWlkZWxpbmUuZWxlbWVudFJlY3QucmVjdDtcbiAgICAgICAgdmFyIHNpemUgPSBuZXh0UmVjdFttYWluTmFtZXMuc3RhcnRdIC0gcHJldlJlY3RbbWFpbk5hbWVzLmVuZF07XG5cbiAgICAgICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICAgICAgdmFyIHJlbmRlclBvcyA9IFswLCAwXTtcbiAgICAgICAgICByZW5kZXJQb3NbaW5kZXhdID0gdGFyZ2V0UG9zW2luZGV4XSArIHByZXZSZWN0W21haW5OYW1lcy5lbmRdIC0gdGFyZ2V0U3RhcnQ7XG4gICAgICAgICAgcmVuZGVyUG9zW290aGVySW5kZXhdID0gc2lkZVBvcztcbiAgICAgICAgICByZW5kZXJlZC5wdXNoKHJlbmRlckRpZ2l0TGluZShtb3ZlYWJsZSwgdHlwZSwgXCJkYXNoZWRcIiwgcmVuZGVyZWQubGVuZ3RoLCBzaXplLCByZW5kZXJQb3MsIGd1aWRlbGluZS5jbGFzc05hbWUsIFJlYWN0KSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2UmVjdCA9IG5leHRSZWN0O1xuICAgICAgfSk7XG4gICAgICBpbm5lci5mb3JFYWNoKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcbiAgICAgICAgdmFyIG5leHRSZWN0ID0gZ3VpZGVsaW5lLmVsZW1lbnRSZWN0LnJlY3Q7XG4gICAgICAgIHZhciBzaXplMSA9IHRhcmdldFN0YXJ0IC0gbmV4dFJlY3RbbWFpbk5hbWVzLnN0YXJ0XTtcbiAgICAgICAgdmFyIHNpemUyID0gbmV4dFJlY3RbbWFpbk5hbWVzLmVuZF0gLSB0YXJnZXRFbmQ7XG4gICAgICAgIHZhciByZW5kZXJQb3MxID0gWzAsIDBdO1xuICAgICAgICB2YXIgcmVuZGVyUG9zMiA9IFswLCAwXTtcbiAgICAgICAgcmVuZGVyUG9zMVtpbmRleF0gPSB0YXJnZXRQb3NbaW5kZXhdIC0gc2l6ZTE7XG4gICAgICAgIHJlbmRlclBvczFbb3RoZXJJbmRleF0gPSBzaWRlUG9zO1xuICAgICAgICByZW5kZXJQb3MyW2luZGV4XSA9IHRhcmdldFBvc1tpbmRleF0gKyB0YXJnZXRFbmQgLSB0YXJnZXRTdGFydDtcbiAgICAgICAgcmVuZGVyUG9zMltvdGhlckluZGV4XSA9IHNpZGVQb3M7XG4gICAgICAgIHJlbmRlcmVkLnB1c2gocmVuZGVyRGlnaXRMaW5lKG1vdmVhYmxlLCB0eXBlLCBcImRhc2hlZFwiLCByZW5kZXJlZC5sZW5ndGgsIHNpemUxLCByZW5kZXJQb3MxLCBndWlkZWxpbmUuY2xhc3NOYW1lLCBSZWFjdCkpO1xuICAgICAgICByZW5kZXJlZC5wdXNoKHJlbmRlckRpZ2l0TGluZShtb3ZlYWJsZSwgdHlwZSwgXCJkYXNoZWRcIiwgcmVuZGVyZWQubGVuZ3RoLCBzaXplMiwgcmVuZGVyUG9zMiwgZ3VpZGVsaW5lLmNsYXNzTmFtZSwgUmVhY3QpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlbmRlcmVkO1xufVxuXG5mdW5jdGlvbiByZW5kZXJHYXBHdWlkZWxpbmVzKG1vdmVhYmxlLCBndWlkZWxpbmVzLCB0YXJnZXRQb3MsIHRhcmdldFJlY3QsIFJlYWN0KSB7XG4gIHZhciByZW5kZXJlZCA9IFtdO1xuICBbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIl0uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBuZXh0R3VpZGVsaW5lcyA9IGd1aWRlbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcbiAgICAgIHJldHVybiBndWlkZWxpbmUudHlwZSA9PT0gdHlwZTtcbiAgICB9KTtcbiAgICB2YXIgaW5kZXggPSB0eXBlID09PSBcInZlcnRpY2FsXCIgPyAwIDogMTtcbiAgICB2YXIgb3RoZXJJbmRleCA9IGluZGV4ID8gMCA6IDE7XG4gICAgdmFyIG1haW5OYW1lcyA9IGluZGV4ID8gSE9SSVpPTlRBTF9OQU1FU19NQVAgOiBWRVJUSUNBTF9OQU1FU19NQVA7XG4gICAgdmFyIHNpZGVOYW1lcyA9IGluZGV4ID8gVkVSVElDQUxfTkFNRVNfTUFQIDogSE9SSVpPTlRBTF9OQU1FU19NQVA7XG4gICAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuc3RhcnRdO1xuICAgIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5lbmRdO1xuICAgIHZhciB0YXJnZXRTaWRlU3RhcnQgPSB0YXJnZXRSZWN0W3NpZGVOYW1lcy5zdGFydF07XG4gICAgdmFyIHRhcmdldFNpZGVFbmQgPSB0YXJnZXRSZWN0W3NpZGVOYW1lcy5lbmRdO1xuICAgIG5leHRHdWlkZWxpbmVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgZ2FwID0gX2EuZ2FwLFxuICAgICAgICAgIGdhcFJlY3RzID0gX2EuZ2FwUmVjdHMsXG4gICAgICAgICAgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lO1xuICAgICAgdmFyIHNpZGVTdGFydFBvcyA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW3RhcmdldFNpZGVTdGFydF0sIGdhcFJlY3RzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBfYS5yZWN0O1xuICAgICAgICByZXR1cm4gcmVjdFtzaWRlTmFtZXMuc3RhcnRdO1xuICAgICAgfSksIGZhbHNlKSk7XG4gICAgICB2YXIgc2lkZUVuZFBvcyA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW3RhcmdldFNpZGVFbmRdLCBnYXBSZWN0cy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciByZWN0ID0gX2EucmVjdDtcbiAgICAgICAgcmV0dXJuIHJlY3Rbc2lkZU5hbWVzLmVuZF07XG4gICAgICB9KSwgZmFsc2UpKTtcbiAgICAgIHZhciBzaWRlQ2VudGVyUG9zID0gKHNpZGVTdGFydFBvcyArIHNpZGVFbmRQb3MpIC8gMjtcblxuICAgICAgaWYgKHNpZGVTdGFydFBvcyA9PT0gc2lkZUVuZFBvcyB8fCBzaWRlQ2VudGVyUG9zID09PSAodGFyZ2V0U2lkZVN0YXJ0ICsgdGFyZ2V0U2lkZUVuZCkgLyAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZ2FwUmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBfYS5yZWN0O1xuICAgICAgICB2YXIgcmVuZGVyUG9zID0gW3RhcmdldFBvc1swXSwgdGFyZ2V0UG9zWzFdXTtcblxuICAgICAgICBpZiAocmVjdFttYWluTmFtZXMuZW5kXSA8IHRhcmdldFN0YXJ0KSB7XG4gICAgICAgICAgcmVuZGVyUG9zW2luZGV4XSArPSByZWN0W21haW5OYW1lcy5lbmRdIC0gdGFyZ2V0U3RhcnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0RW5kIDwgcmVjdFttYWluTmFtZXMuc3RhcnRdKSB7XG4gICAgICAgICAgcmVuZGVyUG9zW2luZGV4XSArPSByZWN0W21haW5OYW1lcy5zdGFydF0gLSB0YXJnZXRTdGFydCAtIGdhcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJQb3Nbb3RoZXJJbmRleF0gKz0gc2lkZUNlbnRlclBvcyAtIHRhcmdldFNpZGVTdGFydDtcbiAgICAgICAgcmVuZGVyZWQucHVzaChyZW5kZXJEaWdpdExpbmUobW92ZWFibGUsIGluZGV4ID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIsIFwiZ2FwXCIsIHJlbmRlcmVkLmxlbmd0aCwgZ2FwLCByZW5kZXJQb3MsIGNsYXNzTmFtZSwgUmVhY3QpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlbmRlcmVkO1xufVxuXG5mdW5jdGlvbiBzb2x2ZUVxdWF0aW9uKHBvczEsIHBvczIsIHNuYXBPZmZzZXQsIGlzVmVydGljYWwpIHtcbiAgdmFyIGR4ID0gcG9zMlswXSAtIHBvczFbMF07XG4gIHZhciBkeSA9IHBvczJbMV0gLSBwb3MxWzFdO1xuXG4gIGlmIChNYXRoLmFicyhkeCkgPCBUSU5ZX05VTSQxKSB7XG4gICAgZHggPSAwO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGR5KSA8IFRJTllfTlVNJDEpIHtcbiAgICBkeSA9IDA7XG4gIH1cblxuICBpZiAoIWR4KSB7XG4gICAgLy8geSA9IDAgKiB4ICsgYlxuICAgIC8vIG9ubHkgaG9yaXpvbnRhbFxuICAgIGlmICghaXNWZXJ0aWNhbCkge1xuICAgICAgcmV0dXJuIFswLCBzbmFwT2Zmc2V0XTtcbiAgICB9XG5cbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG5cbiAgaWYgKCFkeSkge1xuICAgIC8vIG9ubHkgdmVydGljYWxcbiAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgcmV0dXJuIFtzbmFwT2Zmc2V0LCAwXTtcbiAgICB9XG5cbiAgICByZXR1cm4gWzAsIDBdO1xuICB9IC8vIHkgPSBheCArIGJcblxuXG4gIHZhciBhID0gZHkgLyBkeDtcbiAgdmFyIGIgPSBwb3MxWzFdIC0gYSAqIHBvczFbMF07XG5cbiAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAvLyB5ID0gYSAqIHggKyBiXG4gICAgdmFyIHkgPSBhICogKHBvczJbMF0gKyBzbmFwT2Zmc2V0KSArIGI7XG4gICAgcmV0dXJuIFtzbmFwT2Zmc2V0LCB5IC0gcG9zMlsxXV07XG4gIH0gZWxzZSB7XG4gICAgLy8geCA9ICh5IC0gYikgLyBhXG4gICAgdmFyIHggPSAocG9zMlsxXSArIHNuYXBPZmZzZXQgLSBiKSAvIGE7XG4gICAgcmV0dXJuIFt4IC0gcG9zMlswXSwgc25hcE9mZnNldF07XG4gIH1cbn1cblxuZnVuY3Rpb24gc29sdmVOZXh0T2Zmc2V0KHBvczEsIHBvczIsIG9mZnNldCwgaXNWZXJ0aWNhbCwgZGF0YXMpIHtcbiAgdmFyIHNpemVPZmZzZXQgPSBzb2x2ZUVxdWF0aW9uKHBvczEsIHBvczIsIG9mZnNldCwgaXNWZXJ0aWNhbCk7XG5cbiAgaWYgKCFzaXplT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzT3V0c2lkZTogZmFsc2UsXG4gICAgICBvZmZzZXQ6IFswLCAwXVxuICAgIH07XG4gIH1cblxuICB2YXIgc2l6ZSA9IGdldERpc3QkMShwb3MxLCBwb3MyKTtcbiAgdmFyIGRpc3QxID0gZ2V0RGlzdCQxKHNpemVPZmZzZXQsIHBvczEpO1xuICB2YXIgZGlzdDIgPSBnZXREaXN0JDEoc2l6ZU9mZnNldCwgcG9zMik7XG4gIHZhciBpc091dHNpZGUgPSBkaXN0MSA+IHNpemUgfHwgZGlzdDIgPiBzaXplO1xuXG4gIHZhciBfYSA9IGdldERyYWdEaXN0KHtcbiAgICBkYXRhczogZGF0YXMsXG4gICAgZGlzdFg6IHNpemVPZmZzZXRbMF0sXG4gICAgZGlzdFk6IHNpemVPZmZzZXRbMV1cbiAgfSksXG4gICAgICB3aWR0aE9mZnNldCA9IF9hWzBdLFxuICAgICAgaGVpZ2h0T2Zmc2V0ID0gX2FbMV07XG5cbiAgcmV0dXJuIHtcbiAgICBvZmZzZXQ6IFt3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0XSxcbiAgICBpc091dHNpZGU6IGlzT3V0c2lkZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTbmFwQm91bmQoYm91bmRJbmZvLCBzbmFwSW5mbykge1xuICBpZiAoYm91bmRJbmZvLmlzQm91bmQpIHtcbiAgICByZXR1cm4gYm91bmRJbmZvLm9mZnNldDtcbiAgfSBlbHNlIGlmIChzbmFwSW5mby5pc1NuYXApIHtcbiAgICByZXR1cm4gZ2V0TmVhcmVzdFNuYXBHdWlkZWxpbmVJbmZvKHNuYXBJbmZvKS5vZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY2hlY2tUaHJvdHRsZURyYWdSb3RhdGUodGhyb3R0bGVEcmFnUm90YXRlLCBfYSwgX2IsIF9jLCBfZCkge1xuICB2YXIgZGlzdFggPSBfYVswXSxcbiAgICAgIGRpc3RZID0gX2FbMV07XG4gIHZhciBpc1ZlcnRpY2FsQm91bmQgPSBfYlswXSxcbiAgICAgIGlzSG9yaXpvbnRhbEJvdW5kID0gX2JbMV07XG4gIHZhciBpc1ZlcnRpY2FsU25hcCA9IF9jWzBdLFxuICAgICAgaXNIb3Jpem9udGFsU25hcCA9IF9jWzFdO1xuICB2YXIgdmVydGljYWxPZmZzZXQgPSBfZFswXSxcbiAgICAgIGhvcml6b250YWxPZmZzZXQgPSBfZFsxXTtcbiAgdmFyIG9mZnNldFggPSAtdmVydGljYWxPZmZzZXQ7XG4gIHZhciBvZmZzZXRZID0gLWhvcml6b250YWxPZmZzZXQ7XG5cbiAgaWYgKHRocm90dGxlRHJhZ1JvdGF0ZSAmJiBkaXN0WCAmJiBkaXN0WSkge1xuICAgIG9mZnNldFggPSAwO1xuICAgIG9mZnNldFkgPSAwO1xuICAgIHZhciBhZGp1c3RQb3NlcyA9IFtdO1xuXG4gICAgaWYgKGlzVmVydGljYWxCb3VuZCAmJiBpc0hvcml6b250YWxCb3VuZCkge1xuICAgICAgYWRqdXN0UG9zZXMucHVzaChbMCwgaG9yaXpvbnRhbE9mZnNldF0sIFt2ZXJ0aWNhbE9mZnNldCwgMF0pO1xuICAgIH0gZWxzZSBpZiAoaXNWZXJ0aWNhbEJvdW5kKSB7XG4gICAgICBhZGp1c3RQb3Nlcy5wdXNoKFt2ZXJ0aWNhbE9mZnNldCwgMF0pO1xuICAgIH0gZWxzZSBpZiAoaXNIb3Jpem9udGFsQm91bmQpIHtcbiAgICAgIGFkanVzdFBvc2VzLnB1c2goWzAsIGhvcml6b250YWxPZmZzZXRdKTtcbiAgICB9IGVsc2UgaWYgKGlzVmVydGljYWxTbmFwICYmIGlzSG9yaXpvbnRhbFNuYXApIHtcbiAgICAgIGFkanVzdFBvc2VzLnB1c2goWzAsIGhvcml6b250YWxPZmZzZXRdLCBbdmVydGljYWxPZmZzZXQsIDBdKTtcbiAgICB9IGVsc2UgaWYgKGlzVmVydGljYWxTbmFwKSB7XG4gICAgICBhZGp1c3RQb3Nlcy5wdXNoKFt2ZXJ0aWNhbE9mZnNldCwgMF0pO1xuICAgIH0gZWxzZSBpZiAoaXNIb3Jpem9udGFsU25hcCkge1xuICAgICAgYWRqdXN0UG9zZXMucHVzaChbMCwgaG9yaXpvbnRhbE9mZnNldF0pO1xuICAgIH1cblxuICAgIGlmIChhZGp1c3RQb3Nlcy5sZW5ndGgpIHtcbiAgICAgIGFkanVzdFBvc2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc3RTaXplKG1pbnVzKFtkaXN0WCwgZGlzdFldLCBhKSkgLSBnZXREaXN0U2l6ZShtaW51cyhbZGlzdFgsIGRpc3RZXSwgYikpO1xuICAgICAgfSk7XG4gICAgICB2YXIgYWRqdXN0UG9zID0gYWRqdXN0UG9zZXNbMF07XG5cbiAgICAgIGlmIChhZGp1c3RQb3NbMF0gJiYgTWF0aC5hYnMoZGlzdFgpID4gVElOWV9OVU0kMSkge1xuICAgICAgICBvZmZzZXRYID0gLWFkanVzdFBvc1swXTtcbiAgICAgICAgb2Zmc2V0WSA9IGRpc3RZICogTWF0aC5hYnMoZGlzdFggKyBvZmZzZXRYKSAvIE1hdGguYWJzKGRpc3RYKSAtIGRpc3RZO1xuICAgICAgfSBlbHNlIGlmIChhZGp1c3RQb3NbMV0gJiYgTWF0aC5hYnMoZGlzdFkpID4gVElOWV9OVU0kMSkge1xuICAgICAgICB2YXIgcHJldkRpc3RZID0gZGlzdFk7XG4gICAgICAgIG9mZnNldFkgPSAtYWRqdXN0UG9zWzFdO1xuICAgICAgICBvZmZzZXRYID0gZGlzdFggKiBNYXRoLmFicyhkaXN0WSArIG9mZnNldFkpIC8gTWF0aC5hYnMocHJldkRpc3RZKSAtIGRpc3RYO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhyb3R0bGVEcmFnUm90YXRlICYmIGlzSG9yaXpvbnRhbEJvdW5kICYmIGlzVmVydGljYWxCb3VuZCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMob2Zmc2V0WCkgPiBUSU5ZX05VTSQxICYmIE1hdGguYWJzKG9mZnNldFgpIDwgTWF0aC5hYnModmVydGljYWxPZmZzZXQpKSB7XG4gICAgICAgICAgdmFyIHNjYWxlID0gTWF0aC5hYnModmVydGljYWxPZmZzZXQpIC8gTWF0aC5hYnMob2Zmc2V0WCk7XG4gICAgICAgICAgb2Zmc2V0WCAqPSBzY2FsZTtcbiAgICAgICAgICBvZmZzZXRZICo9IHNjYWxlO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKG9mZnNldFkpID4gVElOWV9OVU0kMSAmJiBNYXRoLmFicyhvZmZzZXRZKSA8IE1hdGguYWJzKGhvcml6b250YWxPZmZzZXQpKSB7XG4gICAgICAgICAgdmFyIHNjYWxlID0gTWF0aC5hYnMoaG9yaXpvbnRhbE9mZnNldCkgLyBNYXRoLmFicyhvZmZzZXRZKTtcbiAgICAgICAgICBvZmZzZXRYICo9IHNjYWxlO1xuICAgICAgICAgIG9mZnNldFkgKj0gc2NhbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0WCA9IG1heE9mZnNldCgtdmVydGljYWxPZmZzZXQsIG9mZnNldFgpO1xuICAgICAgICAgIG9mZnNldFkgPSBtYXhPZmZzZXQoLWhvcml6b250YWxPZmZzZXQsIG9mZnNldFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9mZnNldFggPSBkaXN0WCB8fCBpc1ZlcnRpY2FsQm91bmQgPyAtdmVydGljYWxPZmZzZXQgOiAwO1xuICAgIG9mZnNldFkgPSBkaXN0WSB8fCBpc0hvcml6b250YWxCb3VuZCA/IC1ob3Jpem9udGFsT2Zmc2V0IDogMDtcbiAgfVxuXG4gIHJldHVybiBbb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5cbmZ1bmN0aW9uIGNoZWNrU25hcEJvdW5kc0RyYWcobW92ZWFibGUsIGRpc3RYLCBkaXN0WSwgdGhyb3R0bGVEcmFnUm90YXRlLCBpc1JlcXVlc3QsIGRhdGFzKSB7XG4gIGlmICghaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJkcmFnZ2FibGVcIikpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIGlzU25hcDogZmFsc2UsXG4gICAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIHtcbiAgICAgIGlzU25hcDogZmFsc2UsXG4gICAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICAgIG9mZnNldDogMFxuICAgIH1dO1xuICB9XG5cbiAgdmFyIHBvc2VzID0gZ2V0QWJzb2x1dGVQb3NlcyhkYXRhcy5hYnNvbHV0ZVBvc2VzLCBbZGlzdFgsIGRpc3RZXSk7XG5cbiAgdmFyIF9hID0gZ2V0UmVjdChwb3NlcyksXG4gICAgICBsZWZ0ID0gX2EubGVmdCxcbiAgICAgIHJpZ2h0ID0gX2EucmlnaHQsXG4gICAgICB0b3AgPSBfYS50b3AsXG4gICAgICBib3R0b20gPSBfYS5ib3R0b207XG5cbiAgdmFyIGJvdW5kUG9zZXMgPSB7XG4gICAgaG9yaXpvbnRhbDogcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwb3NbMV07XG4gICAgfSksXG4gICAgdmVydGljYWw6IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gcG9zWzBdO1xuICAgIH0pXG4gIH07XG4gIHZhciBzbmFwRGlyZWN0aW9ucyA9IGdldFNuYXBEaXJlY3Rpb25zKG1vdmVhYmxlLnByb3BzLnNuYXBEaXJlY3Rpb25zKTtcbiAgdmFyIHNuYXBQb3NlcyA9IHNwbGl0U25hcERpcmVjdGlvblBvc2VzKHNuYXBEaXJlY3Rpb25zLCB7XG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogcmlnaHQsXG4gICAgdG9wOiB0b3AsXG4gICAgYm90dG9tOiBib3R0b20sXG4gICAgY2VudGVyOiAobGVmdCArIHJpZ2h0KSAvIDIsXG4gICAgbWlkZGxlOiAodG9wICsgYm90dG9tKSAvIDJcbiAgfSk7XG5cbiAgdmFyIF9iID0gY2hlY2tNb3ZlYWJsZVNuYXBCb3VuZHMobW92ZWFibGUsIGlzUmVxdWVzdCwgc25hcFBvc2VzLCBib3VuZFBvc2VzKSxcbiAgICAgIHZlcnRpY2FsU25hcEJvdW5kSW5mbyA9IF9iLnZlcnRpY2FsLFxuICAgICAgaG9yaXpvbnRhbFNuYXBCb3VuZEluZm8gPSBfYi5ob3Jpem9udGFsO1xuXG4gIHZhciBfYyA9IGdldElubmVyQm91bmREcmFnSW5mbyhtb3ZlYWJsZSwgcG9zZXMsIGRhdGFzKSxcbiAgICAgIHZlcnRpY2FsSW5uZXJCb3VuZEluZm8gPSBfYy52ZXJ0aWNhbCxcbiAgICAgIGhvcml6b250YWxJbm5lckJvdW5kSW5mbyA9IF9jLmhvcml6b250YWw7XG5cbiAgdmFyIGlzVmVydGljYWxTbmFwID0gdmVydGljYWxTbmFwQm91bmRJbmZvLmlzU25hcDtcbiAgdmFyIGlzSG9yaXpvbnRhbFNuYXAgPSBob3Jpem9udGFsU25hcEJvdW5kSW5mby5pc1NuYXA7XG4gIHZhciBpc1ZlcnRpY2FsQm91bmQgPSB2ZXJ0aWNhbFNuYXBCb3VuZEluZm8uaXNCb3VuZCB8fCB2ZXJ0aWNhbElubmVyQm91bmRJbmZvLmlzQm91bmQ7XG4gIHZhciBpc0hvcml6b250YWxCb3VuZCA9IGhvcml6b250YWxTbmFwQm91bmRJbmZvLmlzQm91bmQgfHwgaG9yaXpvbnRhbElubmVyQm91bmRJbmZvLmlzQm91bmQ7XG4gIHZhciB2ZXJ0aWNhbE9mZnNldCA9IG1heE9mZnNldCh2ZXJ0aWNhbFNuYXBCb3VuZEluZm8ub2Zmc2V0LCB2ZXJ0aWNhbElubmVyQm91bmRJbmZvLm9mZnNldCk7XG4gIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gbWF4T2Zmc2V0KGhvcml6b250YWxTbmFwQm91bmRJbmZvLm9mZnNldCwgaG9yaXpvbnRhbElubmVyQm91bmRJbmZvLm9mZnNldCk7XG5cbiAgdmFyIF9kID0gY2hlY2tUaHJvdHRsZURyYWdSb3RhdGUodGhyb3R0bGVEcmFnUm90YXRlLCBbZGlzdFgsIGRpc3RZXSwgW2lzVmVydGljYWxCb3VuZCwgaXNIb3Jpem9udGFsQm91bmRdLCBbaXNWZXJ0aWNhbFNuYXAsIGlzSG9yaXpvbnRhbFNuYXBdLCBbdmVydGljYWxPZmZzZXQsIGhvcml6b250YWxPZmZzZXRdKSxcbiAgICAgIG9mZnNldFggPSBfZFswXSxcbiAgICAgIG9mZnNldFkgPSBfZFsxXTtcblxuICByZXR1cm4gW3tcbiAgICBpc0JvdW5kOiBpc1ZlcnRpY2FsQm91bmQsXG4gICAgaXNTbmFwOiBpc1ZlcnRpY2FsU25hcCxcbiAgICBvZmZzZXQ6IG9mZnNldFhcbiAgfSwge1xuICAgIGlzQm91bmQ6IGlzSG9yaXpvbnRhbEJvdW5kLFxuICAgIGlzU25hcDogaXNIb3Jpem9udGFsU25hcCxcbiAgICBvZmZzZXQ6IG9mZnNldFlcbiAgfV07XG59XG5cbmZ1bmN0aW9uIGNoZWNrTW92ZWFibGVTbmFwQm91bmRzKG1vdmVhYmxlLCBpc1JlcXVlc3QsIHBvc2VzLCBib3VuZFBvc2VzKSB7XG4gIGlmIChib3VuZFBvc2VzID09PSB2b2lkIDApIHtcbiAgICBib3VuZFBvc2VzID0gcG9zZXM7XG4gIH1cblxuICB2YXIgX2EgPSBjaGVja0JvdW5kUG9zZXMoZ2V0Qm91bmRzKG1vdmVhYmxlKSwgYm91bmRQb3Nlcy52ZXJ0aWNhbCwgYm91bmRQb3Nlcy5ob3Jpem9udGFsKSxcbiAgICAgIGhvcml6b250YWxCb3VuZEluZm9zID0gX2EuaG9yaXpvbnRhbCxcbiAgICAgIHZlcnRpY2FsQm91bmRJbmZvcyA9IF9hLnZlcnRpY2FsO1xuXG4gIHZhciBfYiA9IGlzUmVxdWVzdCA/IHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc1NuYXA6IGZhbHNlLFxuICAgICAgaW5kZXg6IC0xXG4gICAgfSxcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgaXNTbmFwOiBmYWxzZSxcbiAgICAgIGluZGV4OiAtMVxuICAgIH1cbiAgfSA6IGNoZWNrTW92ZWFibGVTbmFwUG9zZXMobW92ZWFibGUsIHBvc2VzLnZlcnRpY2FsLCBwb3Nlcy5ob3Jpem9udGFsKSxcbiAgICAgIGhvcml6b250YWxTbmFwSW5mbyA9IF9iLmhvcml6b250YWwsXG4gICAgICB2ZXJ0aWNhbFNuYXBJbmZvID0gX2IudmVydGljYWw7XG5cbiAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBnZXRTbmFwQm91bmQoaG9yaXpvbnRhbEJvdW5kSW5mb3NbMF0sIGhvcml6b250YWxTbmFwSW5mbyk7XG4gIHZhciB2ZXJ0aWNhbE9mZnNldCA9IGdldFNuYXBCb3VuZCh2ZXJ0aWNhbEJvdW5kSW5mb3NbMF0sIHZlcnRpY2FsU25hcEluZm8pO1xuICB2YXIgaG9yaXpvbnRhbERpc3QgPSBNYXRoLmFicyhob3Jpem9udGFsT2Zmc2V0KTtcbiAgdmFyIHZlcnRpY2FsRGlzdCA9IE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0KTtcbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc0JvdW5kOiBob3Jpem9udGFsQm91bmRJbmZvc1swXS5pc0JvdW5kLFxuICAgICAgaXNTbmFwOiBob3Jpem9udGFsU25hcEluZm8uaXNTbmFwLFxuICAgICAgc25hcEluZGV4OiBob3Jpem9udGFsU25hcEluZm8uaW5kZXgsXG4gICAgICBvZmZzZXQ6IGhvcml6b250YWxPZmZzZXQsXG4gICAgICBkaXN0OiBob3Jpem9udGFsRGlzdCxcbiAgICAgIGJvdW5kczogaG9yaXpvbnRhbEJvdW5kSW5mb3MsXG4gICAgICBzbmFwOiBob3Jpem9udGFsU25hcEluZm9cbiAgICB9LFxuICAgIHZlcnRpY2FsOiB7XG4gICAgICBpc0JvdW5kOiB2ZXJ0aWNhbEJvdW5kSW5mb3NbMF0uaXNCb3VuZCxcbiAgICAgIGlzU25hcDogdmVydGljYWxTbmFwSW5mby5pc1NuYXAsXG4gICAgICBzbmFwSW5kZXg6IHZlcnRpY2FsU25hcEluZm8uaW5kZXgsXG4gICAgICBvZmZzZXQ6IHZlcnRpY2FsT2Zmc2V0LFxuICAgICAgZGlzdDogdmVydGljYWxEaXN0LFxuICAgICAgYm91bmRzOiB2ZXJ0aWNhbEJvdW5kSW5mb3MsXG4gICAgICBzbmFwOiB2ZXJ0aWNhbFNuYXBJbmZvXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja1NuYXBCb3VuZHMoZ3VpZGVpbmVzLCBib3VuZHMsIHBvc2VzWCwgcG9zZXNZLCBzbmFwVGhyZXNob2xkKSB7XG4gIHZhciBfYSA9IGNoZWNrQm91bmRQb3Nlcyhib3VuZHMsIHBvc2VzWCwgcG9zZXNZKSxcbiAgICAgIGhvcml6b250YWxCb3VuZEluZm9zID0gX2EuaG9yaXpvbnRhbCxcbiAgICAgIHZlcnRpY2FsQm91bmRJbmZvcyA9IF9hLnZlcnRpY2FsOyAvLyBvcHRpb25zLmlzUmVxdWVzdCA/IHtcbiAgLy8gICAgIGhvcml6b250YWw6IHsgaXNTbmFwOiBmYWxzZSwgaW5kZXg6IC0xIH0gYXMgU25hcEluZm8sXG4gIC8vICAgICB2ZXJ0aWNhbDogeyBpc1NuYXA6IGZhbHNlLCBpbmRleDogLTEgfSBhcyBTbmFwSW5mbyxcbiAgLy8gfSA6XG5cblxuICB2YXIgX2IgPSBjaGVja1NuYXBQb3NlcyhndWlkZWluZXMsIHBvc2VzWCwgcG9zZXNZLCBzbmFwVGhyZXNob2xkKSxcbiAgICAgIGhvcml6b250YWxTbmFwSW5mbyA9IF9iLmhvcml6b250YWwsXG4gICAgICB2ZXJ0aWNhbFNuYXBJbmZvID0gX2IudmVydGljYWw7XG5cbiAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBnZXRTbmFwQm91bmQoaG9yaXpvbnRhbEJvdW5kSW5mb3NbMF0sIGhvcml6b250YWxTbmFwSW5mbyk7XG4gIHZhciB2ZXJ0aWNhbE9mZnNldCA9IGdldFNuYXBCb3VuZCh2ZXJ0aWNhbEJvdW5kSW5mb3NbMF0sIHZlcnRpY2FsU25hcEluZm8pO1xuICB2YXIgaG9yaXpvbnRhbERpc3QgPSBNYXRoLmFicyhob3Jpem9udGFsT2Zmc2V0KTtcbiAgdmFyIHZlcnRpY2FsRGlzdCA9IE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0KTtcbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc0JvdW5kOiBob3Jpem9udGFsQm91bmRJbmZvc1swXS5pc0JvdW5kLFxuICAgICAgaXNTbmFwOiBob3Jpem9udGFsU25hcEluZm8uaXNTbmFwLFxuICAgICAgc25hcEluZGV4OiBob3Jpem9udGFsU25hcEluZm8uaW5kZXgsXG4gICAgICBvZmZzZXQ6IGhvcml6b250YWxPZmZzZXQsXG4gICAgICBkaXN0OiBob3Jpem9udGFsRGlzdCxcbiAgICAgIGJvdW5kczogaG9yaXpvbnRhbEJvdW5kSW5mb3MsXG4gICAgICBzbmFwOiBob3Jpem9udGFsU25hcEluZm9cbiAgICB9LFxuICAgIHZlcnRpY2FsOiB7XG4gICAgICBpc0JvdW5kOiB2ZXJ0aWNhbEJvdW5kSW5mb3NbMF0uaXNCb3VuZCxcbiAgICAgIGlzU25hcDogdmVydGljYWxTbmFwSW5mby5pc1NuYXAsXG4gICAgICBzbmFwSW5kZXg6IHZlcnRpY2FsU25hcEluZm8uaW5kZXgsXG4gICAgICBvZmZzZXQ6IHZlcnRpY2FsT2Zmc2V0LFxuICAgICAgZGlzdDogdmVydGljYWxEaXN0LFxuICAgICAgYm91bmRzOiB2ZXJ0aWNhbEJvdW5kSW5mb3MsXG4gICAgICBzbmFwOiB2ZXJ0aWNhbFNuYXBJbmZvXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja1NuYXBSaWdodExpbmUoc3RhcnRQb3MsIGVuZFBvcywgc25hcEJvdW5kSW5mbywga2VlcFJhdGlvKSB7XG4gIHZhciByYWQgPSBnZXRSYWQoc3RhcnRQb3MsIGVuZFBvcykgLyBNYXRoLlBJICogMTgwO1xuICB2YXIgX2EgPSBzbmFwQm91bmRJbmZvLnZlcnRpY2FsLFxuICAgICAgaXNWZXJ0aWNhbEJvdW5kID0gX2EuaXNCb3VuZCxcbiAgICAgIGlzVmVydGljYWxTbmFwID0gX2EuaXNTbmFwLFxuICAgICAgdmVydGljYWxEaXN0ID0gX2EuZGlzdCxcbiAgICAgIF9iID0gc25hcEJvdW5kSW5mby5ob3Jpem9udGFsLFxuICAgICAgaXNIb3Jpem9udGFsQm91bmQgPSBfYi5pc0JvdW5kLFxuICAgICAgaXNIb3Jpem9udGFsU25hcCA9IF9iLmlzU25hcCxcbiAgICAgIGhvcml6b250YWxEaXN0ID0gX2IuZGlzdDtcbiAgdmFyIHJhZDE4MCA9IHJhZCAlIDE4MDtcbiAgdmFyIGlzSG9yaXpvbnRhbExpbmUgPSByYWQxODAgPCAzIHx8IHJhZDE4MCA+IDE3NztcbiAgdmFyIGlzVmVydGljYWxMaW5lID0gcmFkMTgwID4gODcgJiYgcmFkMTgwIDwgOTM7XG5cbiAgaWYgKGhvcml6b250YWxEaXN0IDwgdmVydGljYWxEaXN0KSB7XG4gICAgaWYgKGlzVmVydGljYWxCb3VuZCB8fCBpc1ZlcnRpY2FsU25hcCAmJiAhaXNWZXJ0aWNhbExpbmUgJiYgKCFrZWVwUmF0aW8gfHwgIWlzSG9yaXpvbnRhbExpbmUpKSB7XG4gICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0hvcml6b250YWxCb3VuZCB8fCBpc0hvcml6b250YWxTbmFwICYmICFpc0hvcml6b250YWxMaW5lICYmICgha2VlcFJhdGlvIHx8ICFpc1ZlcnRpY2FsTGluZSkpIHtcbiAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gIH1cblxuICByZXR1cm4gXCJcIjtcbn1cblxuZnVuY3Rpb24gZ2V0U25hcEJvdW5kSW5mbyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbnMsIGtlZXBSYXRpbywgaXNSZXF1ZXN0LCBkYXRhcykge1xuICByZXR1cm4gZGlyZWN0aW9ucy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHN0YXJ0RGlyZWN0aW9uID0gX2FbMF0sXG4gICAgICAgIGVuZERpcmVjdGlvbiA9IF9hWzFdO1xuICAgIHZhciBvdGhlclN0YXJ0UG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIHN0YXJ0RGlyZWN0aW9uKTtcbiAgICB2YXIgb3RoZXJFbmRQb3MgPSBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgZW5kRGlyZWN0aW9uKTtcbiAgICB2YXIgc25hcEJvdW5kSW5mbyA9IGtlZXBSYXRpbyA/IGNoZWNrU25hcEJvdW5kc0tlZXBSYXRpbyhtb3ZlYWJsZSwgb3RoZXJTdGFydFBvcywgb3RoZXJFbmRQb3MsIGlzUmVxdWVzdCkgOiBjaGVja01vdmVhYmxlU25hcEJvdW5kcyhtb3ZlYWJsZSwgaXNSZXF1ZXN0LCB7XG4gICAgICB2ZXJ0aWNhbDogW290aGVyRW5kUG9zWzBdXSxcbiAgICAgIGhvcml6b250YWw6IFtvdGhlckVuZFBvc1sxXV1cbiAgICB9KTtcbiAgICB2YXIgX2IgPSBzbmFwQm91bmRJbmZvLmhvcml6b250YWwsXG4gICAgICAgIC8vIGRpc3Q6IG90aGVySG9yaXpvbnRhbERpc3QsXG4gICAgb3RoZXJIb3Jpem9udGFsT2Zmc2V0ID0gX2Iub2Zmc2V0LFxuICAgICAgICBpc090aGVySG9yaXpvbnRhbEJvdW5kID0gX2IuaXNCb3VuZCxcbiAgICAgICAgaXNPdGhlckhvcml6b250YWxTbmFwID0gX2IuaXNTbmFwLFxuICAgICAgICBfYyA9IHNuYXBCb3VuZEluZm8udmVydGljYWwsXG4gICAgICAgIC8vIGRpc3Q6IG90aGVyVmVydGljYWxEaXN0LFxuICAgIG90aGVyVmVydGljYWxPZmZzZXQgPSBfYy5vZmZzZXQsXG4gICAgICAgIGlzT3RoZXJWZXJ0aWNhbEJvdW5kID0gX2MuaXNCb3VuZCxcbiAgICAgICAgaXNPdGhlclZlcnRpY2FsU25hcCA9IF9jLmlzU25hcDtcbiAgICB2YXIgbXVsdGlwbGUgPSBtaW51cyhlbmREaXJlY3Rpb24sIHN0YXJ0RGlyZWN0aW9uKTtcblxuICAgIGlmICghb3RoZXJWZXJ0aWNhbE9mZnNldCAmJiAhb3RoZXJIb3Jpem9udGFsT2Zmc2V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0JvdW5kOiBpc090aGVyVmVydGljYWxCb3VuZCB8fCBpc090aGVySG9yaXpvbnRhbEJvdW5kLFxuICAgICAgICBpc1NuYXA6IGlzT3RoZXJWZXJ0aWNhbFNuYXAgfHwgaXNPdGhlckhvcml6b250YWxTbmFwLFxuICAgICAgICBzaWduOiBtdWx0aXBsZSxcbiAgICAgICAgb2Zmc2V0OiBbMCwgMF1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHNuYXBMaW5lID0gY2hlY2tTbmFwUmlnaHRMaW5lKG90aGVyU3RhcnRQb3MsIG90aGVyRW5kUG9zLCBzbmFwQm91bmRJbmZvLCBrZWVwUmF0aW8pO1xuXG4gICAgaWYgKCFzbmFwTGluZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2lnbjogbXVsdGlwbGUsXG4gICAgICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgICAgICBpc1NuYXA6IGZhbHNlLFxuICAgICAgICBvZmZzZXQ6IFswLCAwXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IHNuYXBMaW5lID09PSBcInZlcnRpY2FsXCI7XG4gICAgdmFyIHNpemVPZmZzZXQgPSBbMCwgMF07XG5cbiAgICBpZiAoIWtlZXBSYXRpbyAmJiBNYXRoLmFicyhlbmREaXJlY3Rpb25bMF0pID09PSAxICYmIE1hdGguYWJzKGVuZERpcmVjdGlvblsxXSkgPT09IDEgJiYgc3RhcnREaXJlY3Rpb25bMF0gIT09IGVuZERpcmVjdGlvblswXSAmJiBzdGFydERpcmVjdGlvblsxXSAhPT0gZW5kRGlyZWN0aW9uWzFdKSB7XG4gICAgICBzaXplT2Zmc2V0ID0gZ2V0RHJhZ0Rpc3Qoe1xuICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgIGRpc3RYOiAtb3RoZXJWZXJ0aWNhbE9mZnNldCxcbiAgICAgICAgZGlzdFk6IC1vdGhlckhvcml6b250YWxPZmZzZXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplT2Zmc2V0ID0gc29sdmVOZXh0T2Zmc2V0KG90aGVyU3RhcnRQb3MsIG90aGVyRW5kUG9zLCAtKGlzVmVydGljYWwgPyBvdGhlclZlcnRpY2FsT2Zmc2V0IDogb3RoZXJIb3Jpem9udGFsT2Zmc2V0KSwgaXNWZXJ0aWNhbCwgZGF0YXMpLm9mZnNldDtcbiAgICB9XG5cbiAgICBzaXplT2Zmc2V0ID0gc2l6ZU9mZnNldC5tYXAoZnVuY3Rpb24gKHNpemUsIGkpIHtcbiAgICAgIHJldHVybiBzaXplICogKG11bHRpcGxlW2ldID8gMiAvIG11bHRpcGxlW2ldIDogMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ246IG11bHRpcGxlLFxuICAgICAgaXNCb3VuZDogaXNWZXJ0aWNhbCA/IGlzT3RoZXJWZXJ0aWNhbEJvdW5kIDogaXNPdGhlckhvcml6b250YWxCb3VuZCxcbiAgICAgIGlzU25hcDogaXNWZXJ0aWNhbCA/IGlzT3RoZXJWZXJ0aWNhbFNuYXAgOiBpc090aGVySG9yaXpvbnRhbFNuYXAsXG4gICAgICBvZmZzZXQ6IHNpemVPZmZzZXRcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U25hcEJvdW5kT2Zmc2V0KGJvdW5kSW5mbywgc25hcEluZm8pIHtcbiAgaWYgKGJvdW5kSW5mby5pc0JvdW5kKSB7XG4gICAgcmV0dXJuIGJvdW5kSW5mby5vZmZzZXQ7XG4gIH0gZWxzZSBpZiAoc25hcEluZm8uaXNTbmFwKSB7XG4gICAgcmV0dXJuIHNuYXBJbmZvLm9mZnNldDtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjaGVja1NuYXBCb3VuZHNLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MsIGlzUmVxdWVzdCkge1xuICB2YXIgX2EgPSBjaGVja0JvdW5kS2VlcFJhdGlvKG1vdmVhYmxlLCBzdGFydFBvcywgZW5kUG9zKSxcbiAgICAgIGhvcml6b250YWxCb3VuZEluZm8gPSBfYS5ob3Jpem9udGFsLFxuICAgICAgdmVydGljYWxCb3VuZEluZm8gPSBfYS52ZXJ0aWNhbDtcblxuICB2YXIgX2IgPSBpc1JlcXVlc3QgPyB7XG4gICAgaG9yaXpvbnRhbDoge1xuICAgICAgaXNTbmFwOiBmYWxzZVxuICAgIH0sXG4gICAgdmVydGljYWw6IHtcbiAgICAgIGlzU25hcDogZmFsc2VcbiAgICB9XG4gIH0gOiBjaGVja1NuYXBLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpLFxuICAgICAgaG9yaXpvbnRhbFNuYXBJbmZvID0gX2IuaG9yaXpvbnRhbCxcbiAgICAgIHZlcnRpY2FsU25hcEluZm8gPSBfYi52ZXJ0aWNhbDtcblxuICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IGdldFNuYXBCb3VuZE9mZnNldChob3Jpem9udGFsQm91bmRJbmZvLCBob3Jpem9udGFsU25hcEluZm8pO1xuICB2YXIgdmVydGljYWxPZmZzZXQgPSBnZXRTbmFwQm91bmRPZmZzZXQodmVydGljYWxCb3VuZEluZm8sIHZlcnRpY2FsU25hcEluZm8pO1xuICB2YXIgaG9yaXpvbnRhbERpc3QgPSBNYXRoLmFicyhob3Jpem9udGFsT2Zmc2V0KTtcbiAgdmFyIHZlcnRpY2FsRGlzdCA9IE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0KTtcbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc0JvdW5kOiBob3Jpem9udGFsQm91bmRJbmZvLmlzQm91bmQsXG4gICAgICBpc1NuYXA6IGhvcml6b250YWxTbmFwSW5mby5pc1NuYXAsXG4gICAgICBvZmZzZXQ6IGhvcml6b250YWxPZmZzZXQsXG4gICAgICBkaXN0OiBob3Jpem9udGFsRGlzdFxuICAgIH0sXG4gICAgdmVydGljYWw6IHtcbiAgICAgIGlzQm91bmQ6IHZlcnRpY2FsQm91bmRJbmZvLmlzQm91bmQsXG4gICAgICBpc1NuYXA6IHZlcnRpY2FsU25hcEluZm8uaXNTbmFwLFxuICAgICAgb2Zmc2V0OiB2ZXJ0aWNhbE9mZnNldCxcbiAgICAgIGRpc3Q6IHZlcnRpY2FsRGlzdFxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tNYXhCb3VuZHMobW92ZWFibGUsIHBvc2VzLCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGRhdGFzKSB7XG4gIHZhciBmaXhlZERpcmVjdGlvbiA9IFstZGlyZWN0aW9uWzBdLCAtZGlyZWN0aW9uWzFdXTtcbiAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICB2YXIgYm91bmRzID0gbW92ZWFibGUucHJvcHMuYm91bmRzO1xuICB2YXIgbWF4V2lkdGggPSBJbmZpbml0eTtcbiAgdmFyIG1heEhlaWdodCA9IEluZmluaXR5O1xuXG4gIGlmIChib3VuZHMpIHtcbiAgICB2YXIgZGlyZWN0aW9ucyA9IFtbZGlyZWN0aW9uWzBdLCAtZGlyZWN0aW9uWzFdXSwgWy1kaXJlY3Rpb25bMF0sIGRpcmVjdGlvblsxXV1dO1xuICAgIHZhciBfYiA9IGJvdW5kcy5sZWZ0LFxuICAgICAgICBsZWZ0XzEgPSBfYiA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2IsXG4gICAgICAgIF9jID0gYm91bmRzLnRvcCxcbiAgICAgICAgdG9wXzEgPSBfYyA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2MsXG4gICAgICAgIF9kID0gYm91bmRzLnJpZ2h0LFxuICAgICAgICByaWdodF8xID0gX2QgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2QsXG4gICAgICAgIF9lID0gYm91bmRzLmJvdHRvbSxcbiAgICAgICAgYm90dG9tXzEgPSBfZSA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfZTtcbiAgICBkaXJlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKG90aGVyRGlyZWN0aW9uKSB7XG4gICAgICB2YXIgaXNDaGVja1ZlcnRpY2FsID0gb3RoZXJEaXJlY3Rpb25bMF0gIT09IGZpeGVkRGlyZWN0aW9uWzBdO1xuICAgICAgdmFyIGlzQ2hlY2tIb3Jpem9udGFsID0gb3RoZXJEaXJlY3Rpb25bMV0gIT09IGZpeGVkRGlyZWN0aW9uWzFdO1xuICAgICAgdmFyIG90aGVyUG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIG90aGVyRGlyZWN0aW9uKTtcbiAgICAgIHZhciBkZWcgPSBnZXRSYWQoZml4ZWRQb3NpdGlvbiwgb3RoZXJQb3MpICogMzYwIC8gTWF0aC5QSTtcblxuICAgICAgaWYgKGlzQ2hlY2tIb3Jpem9udGFsKSB7XG4gICAgICAgIHZhciBuZXh0T3RoZXJQb3MgPSBvdGhlclBvcy5zbGljZSgpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhkZWcgLSAzNjApIDwgMiB8fCBNYXRoLmFicyhkZWcgLSAxODApIDwgMikge1xuICAgICAgICAgIG5leHRPdGhlclBvc1sxXSA9IGZpeGVkUG9zaXRpb25bMV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2EgPSBzb2x2ZU5leHRPZmZzZXQoZml4ZWRQb3NpdGlvbiwgbmV4dE90aGVyUG9zLCAoZml4ZWRQb3NpdGlvblsxXSA8IG90aGVyUG9zWzFdID8gYm90dG9tXzEgOiB0b3BfMSkgLSBvdGhlclBvc1sxXSwgZmFsc2UsIGRhdGFzKSxcbiAgICAgICAgICAgIF9iID0gX2Eub2Zmc2V0LFxuICAgICAgICAgICAgaGVpZ2h0T2Zmc2V0ID0gX2JbMV0sXG4gICAgICAgICAgICBpc0hlaWdodE91dHNpZGUgPSBfYS5pc091dHNpZGU7XG5cbiAgICAgICAgaWYgKCFpc05hTihoZWlnaHRPZmZzZXQpKSB7XG4gICAgICAgICAgbWF4SGVpZ2h0ID0gaGVpZ2h0ICsgKGlzSGVpZ2h0T3V0c2lkZSA/IDEgOiAtMSkgKiBNYXRoLmFicyhoZWlnaHRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0NoZWNrVmVydGljYWwpIHtcbiAgICAgICAgdmFyIG5leHRPdGhlclBvcyA9IG90aGVyUG9zLnNsaWNlKCk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGRlZyAtIDkwKSA8IDIgfHwgTWF0aC5hYnMoZGVnIC0gMjcwKSA8IDIpIHtcbiAgICAgICAgICBuZXh0T3RoZXJQb3NbMF0gPSBmaXhlZFBvc2l0aW9uWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9jID0gc29sdmVOZXh0T2Zmc2V0KGZpeGVkUG9zaXRpb24sIG5leHRPdGhlclBvcywgKGZpeGVkUG9zaXRpb25bMF0gPCBvdGhlclBvc1swXSA/IHJpZ2h0XzEgOiBsZWZ0XzEpIC0gb3RoZXJQb3NbMF0sIHRydWUsIGRhdGFzKSxcbiAgICAgICAgICAgIHdpZHRoT2Zmc2V0ID0gX2Mub2Zmc2V0WzBdLFxuICAgICAgICAgICAgaXNXaWR0aE91dHNpZGUgPSBfYy5pc091dHNpZGU7XG5cbiAgICAgICAgaWYgKCFpc05hTih3aWR0aE9mZnNldCkpIHtcbiAgICAgICAgICBtYXhXaWR0aCA9IHdpZHRoICsgKGlzV2lkdGhPdXRzaWRlID8gMSA6IC0xKSAqIE1hdGguYWJzKHdpZHRoT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXhXaWR0aDogbWF4V2lkdGgsXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gc25hcFN0YXJ0KG1vdmVhYmxlKSB7XG4gIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS5ndWlkZWxpbmVzICYmIHN0YXRlLmd1aWRlbGluZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5lciA9IG1vdmVhYmxlLnN0YXRlLmNvbnRhaW5lcjtcbiAgdmFyIHNuYXBDb250YWluZXIgPSBtb3ZlYWJsZS5wcm9wcy5zbmFwQ29udGFpbmVyIHx8IGNvbnRhaW5lcjtcbiAgdmFyIGNvbnRhaW5lckNsaWVudFJlY3QgPSBzdGF0ZS5jb250YWluZXJDbGllbnRSZWN0O1xuICB2YXIgc25hcE9mZnNldCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDAsXG4gICAgcmlnaHQ6IDBcbiAgfTtcblxuICBpZiAoY29udGFpbmVyICE9PSBzbmFwQ29udGFpbmVyKSB7XG4gICAgdmFyIHNuYXBDb250YWluZXJUYXJnZXQgPSBnZXRSZWZUYXJnZXQoc25hcENvbnRhaW5lciwgdHJ1ZSk7XG5cbiAgICBpZiAoc25hcENvbnRhaW5lclRhcmdldCkge1xuICAgICAgdmFyIHNuYXBDb250YWluZXJSZWN0ID0gZ2V0Q2xpZW50UmVjdChzbmFwQ29udGFpbmVyVGFyZ2V0KTtcbiAgICAgIHZhciBvZmZzZXQxID0gZ2V0RHJhZ0Rpc3RCeVN0YXRlKHN0YXRlLCBbc25hcENvbnRhaW5lclJlY3QubGVmdCAtIGNvbnRhaW5lckNsaWVudFJlY3QubGVmdCwgc25hcENvbnRhaW5lclJlY3QudG9wIC0gY29udGFpbmVyQ2xpZW50UmVjdC50b3BdKTtcbiAgICAgIHZhciBvZmZzZXQyID0gZ2V0RHJhZ0Rpc3RCeVN0YXRlKHN0YXRlLCBbc25hcENvbnRhaW5lclJlY3QucmlnaHQgLSBjb250YWluZXJDbGllbnRSZWN0LnJpZ2h0LCBzbmFwQ29udGFpbmVyUmVjdC5ib3R0b20gLSBjb250YWluZXJDbGllbnRSZWN0LmJvdHRvbV0pO1xuICAgICAgc25hcE9mZnNldC5sZWZ0ID0gdGhyb3R0bGUob2Zmc2V0MVswXSwgMC4xKTtcbiAgICAgIHNuYXBPZmZzZXQudG9wID0gdGhyb3R0bGUob2Zmc2V0MVsxXSwgMC4xKTtcbiAgICAgIHNuYXBPZmZzZXQucmlnaHQgPSB0aHJvdHRsZShvZmZzZXQyWzBdLCAwLjEpO1xuICAgICAgc25hcE9mZnNldC5ib3R0b20gPSB0aHJvdHRsZShvZmZzZXQyWzFdLCAwLjEpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnNuYXBPZmZzZXQgPSBzbmFwT2Zmc2V0O1xuICBzdGF0ZS5ndWlkZWxpbmVzID0gZ2V0VG90YWxHdWlkZWxpbmVzKG1vdmVhYmxlKTtcbiAgc3RhdGUuZW5hYmxlU25hcCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRGaXhlZFBvc2VzKG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zLCBpczNkKSB7XG4gIHZhciBuZXh0UG9zZXMgPSBjYWxjdWxhdGVQb3NlcyhtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIGlzM2QgPyA0IDogMyk7XG4gIHZhciBuZXh0Rml4ZWRQb3MgPSBnZXRQb3NCeURpcmVjdGlvbihuZXh0UG9zZXMsIGZpeGVkRGlyZWN0aW9uKTtcbiAgcmV0dXJuIGdldEFic29sdXRlUG9zZXMobmV4dFBvc2VzLCBtaW51cyhmaXhlZFBvcywgbmV4dEZpeGVkUG9zKSk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemVPZmZzZXRJbmZvKG1vdmVhYmxlLCBwb3NlcywgZGlyZWN0aW9uLCBrZWVwUmF0aW8sIGlzUmVxdWVzdCwgZGF0YXMpIHtcbiAgdmFyIGZpeGVkRGlyZWN0aW9uID0gZGF0YXMuZml4ZWREaXJlY3Rpb247XG4gIHZhciBkaXJlY3Rpb25zID0gZ2V0Q2hlY2tTbmFwRGlyZWN0aW9ucyhkaXJlY3Rpb24sIGZpeGVkRGlyZWN0aW9uLCBrZWVwUmF0aW8pO1xuICB2YXIgaW5uZXJCb3VuZExpbmVJbmZvcyA9IGdldENoZWNrSW5uZXJCb3VuZExpbmVJbmZvcyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbiwga2VlcFJhdGlvKTtcblxuICB2YXIgb2Zmc2V0cyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgZ2V0U25hcEJvdW5kSW5mbyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbnMsIGtlZXBSYXRpbywgaXNSZXF1ZXN0LCBkYXRhcyksIHRydWUpLCBnZXRJbm5lckJvdW5kSW5mbyhtb3ZlYWJsZSwgaW5uZXJCb3VuZExpbmVJbmZvcywgZGF0YXMpLCB0cnVlKTtcblxuICB2YXIgd2lkdGhPZmZzZXRJbmZvID0gZ2V0TmVhck9mZnNldEluZm8ob2Zmc2V0cywgMCk7XG4gIHZhciBoZWlnaHRPZmZzZXRJbmZvID0gZ2V0TmVhck9mZnNldEluZm8ob2Zmc2V0cywgMSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHtcbiAgICAgIGlzQm91bmQ6IHdpZHRoT2Zmc2V0SW5mby5pc0JvdW5kLFxuICAgICAgb2Zmc2V0OiB3aWR0aE9mZnNldEluZm8ub2Zmc2V0WzBdXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIGlzQm91bmQ6IGhlaWdodE9mZnNldEluZm8uaXNCb3VuZCxcbiAgICAgIG9mZnNldDogaGVpZ2h0T2Zmc2V0SW5mby5vZmZzZXRbMV1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlY2hlY2tTaXplQnlUd29EaXJlY3Rpb24obW92ZWFibGUsIHBvc2VzLCB3aWR0aCwgaGVpZ2h0LCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBkaXJlY3Rpb24sIGlzUmVxdWVzdCwgZGF0YXMpIHtcbiAgdmFyIHNuYXBQb3MgPSBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgZGlyZWN0aW9uKTtcblxuICB2YXIgX2EgPSBjaGVja01vdmVhYmxlU25hcEJvdW5kcyhtb3ZlYWJsZSwgaXNSZXF1ZXN0LCB7XG4gICAgdmVydGljYWw6IFtzbmFwUG9zWzBdXSxcbiAgICBob3Jpem9udGFsOiBbc25hcFBvc1sxXV1cbiAgfSksXG4gICAgICBob3Jpem9udGFsT2Zmc2V0ID0gX2EuaG9yaXpvbnRhbC5vZmZzZXQsXG4gICAgICB2ZXJ0aWNhbE9mZnNldCA9IF9hLnZlcnRpY2FsLm9mZnNldDtcblxuICBpZiAodmVydGljYWxPZmZzZXQgfHwgaG9yaXpvbnRhbE9mZnNldCkge1xuICAgIHZhciBfYiA9IGdldERyYWdEaXN0KHtcbiAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgIGRpc3RYOiAtdmVydGljYWxPZmZzZXQsXG4gICAgICBkaXN0WTogLWhvcml6b250YWxPZmZzZXRcbiAgICB9KSxcbiAgICAgICAgbmV4dFdpZHRoT2Zmc2V0ID0gX2JbMF0sXG4gICAgICAgIG5leHRIZWlnaHRPZmZzZXQgPSBfYlsxXTtcblxuICAgIHZhciBuZXh0V2lkdGggPSBNYXRoLm1pbihtYXhXaWR0aCB8fCBJbmZpbml0eSwgd2lkdGggKyBkaXJlY3Rpb25bMF0gKiBuZXh0V2lkdGhPZmZzZXQpO1xuICAgIHZhciBuZXh0SGVpZ2h0ID0gTWF0aC5taW4obWF4SGVpZ2h0IHx8IEluZmluaXR5LCBoZWlnaHQgKyBkaXJlY3Rpb25bMV0gKiBuZXh0SGVpZ2h0T2Zmc2V0KTtcbiAgICByZXR1cm4gW25leHRXaWR0aCAtIHdpZHRoLCBuZXh0SGVpZ2h0IC0gaGVpZ2h0XTtcbiAgfVxuXG4gIHJldHVybiBbMCwgMF07XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2l6ZURpc3QobW92ZWFibGUsIGdldE5leHRQb3Nlcywgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKSB7XG4gIHZhciBwb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKTtcbiAgdmFyIGtlZXBSYXRpbyA9IG1vdmVhYmxlLnByb3BzLmtlZXBSYXRpbztcbiAgdmFyIHdpZHRoT2Zmc2V0ID0gMDtcbiAgdmFyIGhlaWdodE9mZnNldCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICB2YXIgbmV4dFBvc2VzID0gZ2V0TmV4dFBvc2VzKHdpZHRoT2Zmc2V0LCBoZWlnaHRPZmZzZXQpO1xuXG4gICAgdmFyIF9hID0gZ2V0U2l6ZU9mZnNldEluZm8obW92ZWFibGUsIG5leHRQb3NlcywgZGlyZWN0aW9uLCBrZWVwUmF0aW8sIGlzUmVxdWVzdCwgZGF0YXMpLFxuICAgICAgICB3aWR0aE9mZnNldEluZm8gPSBfYS53aWR0aCxcbiAgICAgICAgaGVpZ2h0T2Zmc2V0SW5mbyA9IF9hLmhlaWdodDtcblxuICAgIHZhciBpc1dpZHRoQm91bmQgPSB3aWR0aE9mZnNldEluZm8uaXNCb3VuZDtcbiAgICB2YXIgaXNIZWlnaHRCb3VuZCA9IGhlaWdodE9mZnNldEluZm8uaXNCb3VuZDtcbiAgICB2YXIgbmV4dFdpZHRoT2Zmc2V0ID0gd2lkdGhPZmZzZXRJbmZvLm9mZnNldDtcbiAgICB2YXIgbmV4dEhlaWdodE9mZnNldCA9IGhlaWdodE9mZnNldEluZm8ub2Zmc2V0O1xuXG4gICAgaWYgKGkgPT09IDEpIHtcbiAgICAgIGlmICghaXNXaWR0aEJvdW5kKSB7XG4gICAgICAgIG5leHRXaWR0aE9mZnNldCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNIZWlnaHRCb3VuZCkge1xuICAgICAgICBuZXh0SGVpZ2h0T2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCAmJiBpc1JlcXVlc3QgJiYgIWlzV2lkdGhCb3VuZCAmJiAhaXNIZWlnaHRCb3VuZCkge1xuICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG5cbiAgICBpZiAoa2VlcFJhdGlvKSB7XG4gICAgICB2YXIgd2lkdGhEaXN0ID0gTWF0aC5hYnMobmV4dFdpZHRoT2Zmc2V0KSAqICh3aWR0aCA/IDEgLyB3aWR0aCA6IDEpO1xuICAgICAgdmFyIGhlaWdodERpc3QgPSBNYXRoLmFicyhuZXh0SGVpZ2h0T2Zmc2V0KSAqIChoZWlnaHQgPyAxIC8gaGVpZ2h0IDogMSk7XG4gICAgICB2YXIgaXNHZXRXaWR0aE9mZnNldCA9IGlzV2lkdGhCb3VuZCAmJiBpc0hlaWdodEJvdW5kID8gd2lkdGhEaXN0IDwgaGVpZ2h0RGlzdCA6IGlzSGVpZ2h0Qm91bmQgfHwgIWlzV2lkdGhCb3VuZCAmJiB3aWR0aERpc3QgPCBoZWlnaHREaXN0O1xuXG4gICAgICBpZiAoaXNHZXRXaWR0aE9mZnNldCkge1xuICAgICAgICAvLyB3aWR0aCA6IGhlaWdodCA9ID8gOiBoZWlnaHRPZmZzZXRcbiAgICAgICAgbmV4dFdpZHRoT2Zmc2V0ID0gd2lkdGggKiBuZXh0SGVpZ2h0T2Zmc2V0IC8gaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2lkdGggOiBoZWlnaHQgPSB3aWR0aE9mZnNldCA6ID9cbiAgICAgICAgbmV4dEhlaWdodE9mZnNldCA9IGhlaWdodCAqIG5leHRXaWR0aE9mZnNldCAvIHdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdpZHRoT2Zmc2V0ICs9IG5leHRXaWR0aE9mZnNldDtcbiAgICBoZWlnaHRPZmZzZXQgKz0gbmV4dEhlaWdodE9mZnNldDtcbiAgfVxuXG4gIGlmIChkaXJlY3Rpb25bMF0gJiYgZGlyZWN0aW9uWzFdKSB7XG4gICAgdmFyIF9iID0gY2hlY2tNYXhCb3VuZHMobW92ZWFibGUsIHBvc2VzLCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGRhdGFzKSxcbiAgICAgICAgbWF4V2lkdGggPSBfYi5tYXhXaWR0aCxcbiAgICAgICAgbWF4SGVpZ2h0ID0gX2IubWF4SGVpZ2h0O1xuXG4gICAgdmFyIF9jID0gcmVjaGVja1NpemVCeVR3b0RpcmVjdGlvbihtb3ZlYWJsZSwgZ2V0TmV4dFBvc2VzKHdpZHRoT2Zmc2V0LCBoZWlnaHRPZmZzZXQpLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gcG9zLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gdGhyb3R0bGUocCwgRkxPQVRfUE9JTlRfTlVNKTtcbiAgICAgIH0pO1xuICAgIH0pLCB3aWR0aCArIHdpZHRoT2Zmc2V0LCBoZWlnaHQgKyBoZWlnaHRPZmZzZXQsIG1heFdpZHRoLCBtYXhIZWlnaHQsIGRpcmVjdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcyksXG4gICAgICAgIG5leHRXaWR0aE9mZnNldCA9IF9jWzBdLFxuICAgICAgICBuZXh0SGVpZ2h0T2Zmc2V0ID0gX2NbMV07XG5cbiAgICB3aWR0aE9mZnNldCArPSBuZXh0V2lkdGhPZmZzZXQ7XG4gICAgaGVpZ2h0T2Zmc2V0ICs9IG5leHRIZWlnaHRPZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gW3dpZHRoT2Zmc2V0LCBoZWlnaHRPZmZzZXRdO1xufVxuXG5mdW5jdGlvbiBjaGVja1NuYXBSb3RhdGUobW92ZWFibGUsIHJlY3QsIG9yaWdpbiwgcm90YXRpb24pIHtcbiAgaWYgKCFoYXNHdWlkZWxpbmVzKG1vdmVhYmxlLCBcInJvdGF0YWJsZVwiKSkge1xuICAgIHJldHVybiByb3RhdGlvbjtcbiAgfVxuXG4gIHZhciBwb3MxID0gcmVjdC5wb3MxLFxuICAgICAgcG9zMiA9IHJlY3QucG9zMixcbiAgICAgIHBvczMgPSByZWN0LnBvczMsXG4gICAgICBwb3M0ID0gcmVjdC5wb3M0O1xuICB2YXIgcmFkID0gcm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICB2YXIgcHJldlBvc2VzID0gW3BvczEsIHBvczIsIHBvczMsIHBvczRdLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIG1pbnVzKHBvcywgb3JpZ2luKTtcbiAgfSk7XG4gIHZhciBuZXh0UG9zZXMgPSBwcmV2UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcm90YXRlKHBvcywgcmFkKTtcbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgY2hlY2tSb3RhdGVCb3VuZHMobW92ZWFibGUsIHByZXZQb3NlcywgbmV4dFBvc2VzLCBvcmlnaW4sIHJvdGF0aW9uKSwgdHJ1ZSksIGNoZWNrUm90YXRlSW5uZXJCb3VuZHMobW92ZWFibGUsIHByZXZQb3NlcywgbmV4dFBvc2VzLCBvcmlnaW4sIHJvdGF0aW9uKSwgdHJ1ZSk7XG5cbiAgcmVzdWx0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIHJvdGF0aW9uKSAtIE1hdGguYWJzKGIgLSByb3RhdGlvbik7XG4gIH0pO1xuXG4gIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm90YXRpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tTbmFwUmVzaXplKG1vdmVhYmxlLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzUmVxdWVzdCwgZGF0YXMpIHtcbiAgaWYgKCFoYXNHdWlkZWxpbmVzKG1vdmVhYmxlLCBcInJlc2l6YWJsZVwiKSkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cblxuICB2YXIgZml4ZWREaXJlY3Rpb24gPSBkYXRhcy5maXhlZERpcmVjdGlvbjtcbiAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICBhbGxNYXRyaXggPSBfYS5hbGxNYXRyaXgsXG4gICAgICBpczNkID0gX2EuaXMzZDtcbiAgcmV0dXJuIGNoZWNrU2l6ZURpc3QobW92ZWFibGUsIGZ1bmN0aW9uICh3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0KSB7XG4gICAgcmV0dXJuIGdldE5leHRGaXhlZFBvc2VzKGFsbE1hdHJpeCwgd2lkdGggKyB3aWR0aE9mZnNldCwgaGVpZ2h0ICsgaGVpZ2h0T2Zmc2V0LCBmaXhlZERpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgaXMzZCk7XG4gIH0sIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrU25hcFNjYWxlKG1vdmVhYmxlLCBzY2FsZSwgZGlyZWN0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKSB7XG4gIGlmICghaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJzY2FsYWJsZVwiKSkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cblxuICB2YXIgc3RhcnRPZmZzZXRXaWR0aCA9IGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGgsXG4gICAgICBzdGFydE9mZnNldEhlaWdodCA9IGRhdGFzLnN0YXJ0T2Zmc2V0SGVpZ2h0LFxuICAgICAgZml4ZWRQb3NpdGlvbiA9IGRhdGFzLmZpeGVkUG9zaXRpb24sXG4gICAgICBmaXhlZERpcmVjdGlvbiA9IGRhdGFzLmZpeGVkRGlyZWN0aW9uLFxuICAgICAgaXMzZCA9IGRhdGFzLmlzM2Q7XG4gIHZhciBzaXplRGlzdCA9IGNoZWNrU2l6ZURpc3QobW92ZWFibGUsIGZ1bmN0aW9uICh3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0KSB7XG4gICAgcmV0dXJuIGdldE5leHRGaXhlZFBvc2VzKHNjYWxlTWF0cml4KGRhdGFzLCBwbHVzKHNjYWxlLCBbd2lkdGhPZmZzZXQgLyBzdGFydE9mZnNldFdpZHRoLCBoZWlnaHRPZmZzZXQgLyBzdGFydE9mZnNldEhlaWdodF0pKSwgc3RhcnRPZmZzZXRXaWR0aCwgc3RhcnRPZmZzZXRIZWlnaHQsIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBpczNkKTtcbiAgfSwgc3RhcnRPZmZzZXRXaWR0aCwgc3RhcnRPZmZzZXRIZWlnaHQsIGRpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcyk7XG4gIHJldHVybiBbc2l6ZURpc3RbMF0gLyBzdGFydE9mZnNldFdpZHRoLCBzaXplRGlzdFsxXSAvIHN0YXJ0T2Zmc2V0SGVpZ2h0XTtcbn1cblxuZnVuY3Rpb24gc3RhcnRDaGVja1NuYXBEcmFnKG1vdmVhYmxlLCBkYXRhcykge1xuICBkYXRhcy5hYnNvbHV0ZVBvc2VzID0gZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUobW92ZWFibGUuc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBnZXRTbmFwR3VpZGVsaW5lcyhwb3NJbmZvcykge1xuICB2YXIgZ3VpZGVsaW5lcyA9IFtdO1xuICBwb3NJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChwb3NJbmZvKSB7XG4gICAgcG9zSW5mby5ndWlkZWxpbmVJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIGd1aWRlbGluZSA9IF9hLmd1aWRlbGluZTtcblxuICAgICAgaWYgKGd1aWRlbGluZXMuaW5kZXhPZihndWlkZWxpbmUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBndWlkZWxpbmVzLnB1c2goZ3VpZGVsaW5lKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBndWlkZWxpbmVzO1xufVxuXG5mdW5jdGlvbiBhZGRCb3VuZEd1aWRlbGluZXMobW92ZWFibGUsIHZlcnRpY2FsUG9zZXMsIGhvcml6b250YWxQb3NlcywgdmVydGljYWxTbmFwUG9zZXMsIGhvcml6b250YWxTbmFwUG9zZXMsIGV4dGVybmFsQm91bmRzKSB7XG4gIHZhciBfYSA9IGNoZWNrQm91bmRQb3NlcyhnZXRCb3VuZHMobW92ZWFibGUsIGV4dGVybmFsQm91bmRzKSwgdmVydGljYWxQb3NlcywgaG9yaXpvbnRhbFBvc2VzKSxcbiAgICAgIHZlcnRpY2FsQm91bmRJbmZvcyA9IF9hLnZlcnRpY2FsLFxuICAgICAgaG9yaXpvbnRhbEJvdW5kSW5mb3MgPSBfYS5ob3Jpem9udGFsO1xuXG4gIHZlcnRpY2FsQm91bmRJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgaWYgKGluZm8uaXNCb3VuZCkge1xuICAgICAgdmVydGljYWxTbmFwUG9zZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiYm91bmRzXCIsXG4gICAgICAgIHBvczogaW5mby5wb3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGhvcml6b250YWxCb3VuZEluZm9zLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcbiAgICBpZiAoaW5mby5pc0JvdW5kKSB7XG4gICAgICBob3Jpem9udGFsU25hcFBvc2VzLnB1c2goe1xuICAgICAgICB0eXBlOiBcImJvdW5kc1wiLFxuICAgICAgICBwb3M6IGluZm8ucG9zXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBfYiA9IGNoZWNrSW5uZXJCb3VuZFBvc2VzKG1vdmVhYmxlKSxcbiAgICAgIHZlcnRpY2FsSW5uZXJCb3VuZFBvc2VzID0gX2IudmVydGljYWwsXG4gICAgICBob3Jpem9udGFsSW5uZXJCb3VuZFBvc2VzID0gX2IuaG9yaXpvbnRhbDtcblxuICB2ZXJ0aWNhbElubmVyQm91bmRQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbm5lclBvcykge1xuICAgIGlmIChmaW5kSW5kZXgodmVydGljYWxTbmFwUG9zZXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLFxuICAgICAgICAgIHBvcyA9IF9hLnBvcztcbiAgICAgIHJldHVybiB0eXBlID09PSBcImJvdW5kc1wiICYmIHBvcyA9PT0gaW5uZXJQb3M7XG4gICAgfSkgPj0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZlcnRpY2FsU25hcFBvc2VzLnB1c2goe1xuICAgICAgdHlwZTogXCJib3VuZHNcIixcbiAgICAgIHBvczogaW5uZXJQb3NcbiAgICB9KTtcbiAgfSk7XG4gIGhvcml6b250YWxJbm5lckJvdW5kUG9zZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5uZXJQb3MpIHtcbiAgICBpZiAoZmluZEluZGV4KGhvcml6b250YWxTbmFwUG9zZXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLFxuICAgICAgICAgIHBvcyA9IF9hLnBvcztcbiAgICAgIHJldHVybiB0eXBlID09PSBcImJvdW5kc1wiICYmIHBvcyA9PT0gaW5uZXJQb3M7XG4gICAgfSkgPj0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhvcml6b250YWxTbmFwUG9zZXMucHVzaCh7XG4gICAgICB0eXBlOiBcImJvdW5kc1wiLFxuICAgICAgcG9zOiBpbm5lclBvc1xuICAgIH0pO1xuICB9KTtcbn1cbi8qKlxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5TbmFwcGFibGVcbiAqIEBkZXNjcmlwdGlvbiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHNuYXBwZWQgdG8gdGhlIGd1aWRlbGluZS4gKGRlZmF1bHQ6IGZhbHNlKVxuICogQHNvcnQgMlxuICovXG5cblxudmFyIFNuYXBwYWJsZSA9IHtcbiAgbmFtZTogXCJzbmFwcGFibGVcIixcbiAgZHJhZ1JlbGF0aW9uOiBcInN0cm9uZ1wiLFxuICBwcm9wczoge1xuICAgIHNuYXBwYWJsZTogW0Jvb2xlYW4sIEFycmF5XSxcbiAgICBzbmFwQ29udGFpbmVyOiBPYmplY3QsXG4gICAgc25hcERpcmVjdGlvbnM6IFtCb29sZWFuLCBPYmplY3RdLFxuICAgIGVsZW1lbnRTbmFwRGlyZWN0aW9uczogW0Jvb2xlYW4sIE9iamVjdF0sXG4gICAgc25hcEdhcDogQm9vbGVhbixcbiAgICBzbmFwR3JpZFdpZHRoOiBOdW1iZXIsXG4gICAgc25hcEdyaWRIZWlnaHQ6IE51bWJlcixcbiAgICBpc0Rpc3BsYXlTbmFwRGlnaXQ6IEJvb2xlYW4sXG4gICAgaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQ6IEJvb2xlYW4sXG4gICAgc25hcERpZ2l0OiBOdW1iZXIsXG4gICAgc25hcFRocmVzaG9sZDogTnVtYmVyLFxuICAgIGhvcml6b250YWxHdWlkZWxpbmVzOiBBcnJheSxcbiAgICB2ZXJ0aWNhbEd1aWRlbGluZXM6IEFycmF5LFxuICAgIGVsZW1lbnRHdWlkZWxpbmVzOiBBcnJheSxcbiAgICBib3VuZHM6IE9iamVjdCxcbiAgICBpbm5lckJvdW5kczogT2JqZWN0LFxuICAgIHNuYXBEaXN0Rm9ybWF0OiBGdW5jdGlvblxuICB9LFxuICBldmVudHM6IHtcbiAgICBvblNuYXA6IFwic25hcFwiXG4gIH0sXG4gIGNzczogW1wiOmhvc3Qge1xcbiAgICAtLWJvdW5kcy1jb2xvcjogI2Q2NjtcXG59XFxuLmd1aWRlbGluZSB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICB6LWluZGV4OiAyO1xcbn1cXG4uZ3VpZGVsaW5lLmJvdW5kcyB7XFxuICAgIGJhY2tncm91bmQ6ICNkNjY7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLWJvdW5kcy1jb2xvcik7XFxufVxcbi5ndWlkZWxpbmUtZ3JvdXAge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG59XFxuLmd1aWRlbGluZS1ncm91cCAuc2l6ZS12YWx1ZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgY29sb3I6ICNmNTU7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbi5ndWlkZWxpbmUtZ3JvdXAuaG9yaXpvbnRhbCAuc2l6ZS12YWx1ZSB7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSAxMDAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgYm90dG9tOiA1cHg7XFxufVxcbi5ndWlkZWxpbmUtZ3JvdXAudmVydGljYWwgLnNpemUtdmFsdWUge1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiAwJSA1MCU7XFxuICAgIHRvcDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxuICAgIGxlZnQ6IDVweDtcXG59XFxuLmd1aWRlbGluZS5nYXAge1xcbiAgICBiYWNrZ3JvdW5kOiAjZjU1O1xcbn1cXG4uc2l6ZS12YWx1ZS5nYXAge1xcbiAgICBjb2xvcjogI2Y1NTtcXG59XFxuXCJdLFxuICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICB2YXIgdGFyZ2V0VG9wID0gc3RhdGUudG9wLFxuICAgICAgICB0YXJnZXRMZWZ0ID0gc3RhdGUubGVmdCxcbiAgICAgICAgcG9zMSA9IHN0YXRlLnBvczEsXG4gICAgICAgIHBvczIgPSBzdGF0ZS5wb3MyLFxuICAgICAgICBwb3MzID0gc3RhdGUucG9zMyxcbiAgICAgICAgcG9zNCA9IHN0YXRlLnBvczQsXG4gICAgICAgIHNuYXBSZW5kZXJJbmZvID0gc3RhdGUuc25hcFJlbmRlckluZm87XG5cbiAgICBpZiAoIXNuYXBSZW5kZXJJbmZvIHx8ICFoYXNHdWlkZWxpbmVzKG1vdmVhYmxlLCBcIlwiKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHN0YXRlLmd1aWRlbGluZXMgPSBnZXRUb3RhbEd1aWRlbGluZXMobW92ZWFibGUpO1xuICAgIHZhciBtaW5MZWZ0ID0gTWF0aC5taW4ocG9zMVswXSwgcG9zMlswXSwgcG9zM1swXSwgcG9zNFswXSk7XG4gICAgdmFyIG1pblRvcCA9IE1hdGgubWluKHBvczFbMV0sIHBvczJbMV0sIHBvczNbMV0sIHBvczRbMV0pO1xuICAgIHZhciBleHRlcm5hbFBvc2VzID0gc25hcFJlbmRlckluZm8uZXh0ZXJuYWxQb3NlcyB8fCBbXTtcbiAgICB2YXIgcG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSk7XG4gICAgdmFyIHZlcnRpY2FsU25hcFBvc2VzID0gW107XG4gICAgdmFyIGhvcml6b250YWxTbmFwUG9zZXMgPSBbXTtcbiAgICB2YXIgdmVydGljYWxHdWlkZWxpbmVzID0gW107XG4gICAgdmFyIGhvcml6b250YWxHdWlkZWxpbmVzID0gW107XG4gICAgdmFyIHNuYXBJbmZvcyA9IFtdO1xuXG4gICAgdmFyIF9hID0gZ2V0UmVjdChwb3NlcyksXG4gICAgICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9hLmhlaWdodCxcbiAgICAgICAgdG9wID0gX2EudG9wLFxuICAgICAgICBsZWZ0ID0gX2EubGVmdCxcbiAgICAgICAgYm90dG9tID0gX2EuYm90dG9tLFxuICAgICAgICByaWdodCA9IF9hLnJpZ2h0O1xuXG4gICAgdmFyIHRhcmdldFJlY3QgPSB7XG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgdG9wOiB0b3AsXG4gICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgIGNlbnRlcjogKGxlZnQgKyByaWdodCkgLyAyLFxuICAgICAgbWlkZGxlOiAodG9wICsgYm90dG9tKSAvIDJcbiAgICB9O1xuICAgIHZhciBoYXNFeHRlcm5hbFBvc2VzID0gZXh0ZXJuYWxQb3Nlcy5sZW5ndGggPiAwO1xuICAgIHZhciBleHRlcm5hbFJlY3QgPSBoYXNFeHRlcm5hbFBvc2VzID8gZ2V0UmVjdChleHRlcm5hbFBvc2VzKSA6IHt9O1xuXG4gICAgaWYgKCFzbmFwUmVuZGVySW5mby5yZXF1ZXN0KSB7XG4gICAgICBpZiAoc25hcFJlbmRlckluZm8uZGlyZWN0aW9uKSB7XG4gICAgICAgIHNuYXBJbmZvcy5wdXNoKGdldFNuYXBJbmZvc0J5RGlyZWN0aW9uKG1vdmVhYmxlLCBwb3Nlcywgc25hcFJlbmRlckluZm8uZGlyZWN0aW9uKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzbmFwUmVuZGVySW5mby5zbmFwKSB7XG4gICAgICAgIHZhciByZWN0ID0gZ2V0UmVjdChwb3Nlcyk7XG5cbiAgICAgICAgaWYgKHNuYXBSZW5kZXJJbmZvLmNlbnRlcikge1xuICAgICAgICAgIHJlY3QubWlkZGxlID0gKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMjtcbiAgICAgICAgICByZWN0LmNlbnRlciA9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBzbmFwSW5mb3MucHVzaChjaGVja1NuYXBzKG1vdmVhYmxlLCByZWN0LCAxKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNFeHRlcm5hbFBvc2VzKSB7XG4gICAgICAgIGlmIChzbmFwUmVuZGVySW5mby5jZW50ZXIpIHtcbiAgICAgICAgICBleHRlcm5hbFJlY3QubWlkZGxlID0gKGV4dGVybmFsUmVjdC50b3AgKyBleHRlcm5hbFJlY3QuYm90dG9tKSAvIDI7XG4gICAgICAgICAgZXh0ZXJuYWxSZWN0LmNlbnRlciA9IChleHRlcm5hbFJlY3QubGVmdCArIGV4dGVybmFsUmVjdC5yaWdodCkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgc25hcEluZm9zLnB1c2goY2hlY2tTbmFwcyhtb3ZlYWJsZSwgZXh0ZXJuYWxSZWN0LCAxKSk7XG4gICAgICB9XG5cbiAgICAgIHNuYXBJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChzbmFwSW5mbykge1xuICAgICAgICB2YXIgdmVydGljYWxQb3NJbmZvcyA9IHNuYXBJbmZvLnZlcnRpY2FsLnBvc0luZm9zLFxuICAgICAgICAgICAgaG9yaXpvbnRhbFBvc0luZm9zID0gc25hcEluZm8uaG9yaXpvbnRhbC5wb3NJbmZvcztcbiAgICAgICAgdmVydGljYWxTbmFwUG9zZXMucHVzaC5hcHBseSh2ZXJ0aWNhbFNuYXBQb3NlcywgdmVydGljYWxQb3NJbmZvcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgdmFyIGd1aWRlbGluZUluZm9zID0gX2EuZ3VpZGVsaW5lSW5mb3M7XG4gICAgICAgICAgcmV0dXJuIGd1aWRlbGluZUluZm9zLnNvbWUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgZ3VpZGVsaW5lID0gX2EuZ3VpZGVsaW5lO1xuICAgICAgICAgICAgcmV0dXJuICFndWlkZWxpbmUuaGlkZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChwb3NJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwic25hcFwiLFxuICAgICAgICAgICAgcG9zOiBwb3NJbmZvLnBvc1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICAgICAgaG9yaXpvbnRhbFNuYXBQb3Nlcy5wdXNoLmFwcGx5KGhvcml6b250YWxTbmFwUG9zZXMsIGhvcml6b250YWxQb3NJbmZvcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgdmFyIGd1aWRlbGluZUluZm9zID0gX2EuZ3VpZGVsaW5lSW5mb3M7XG4gICAgICAgICAgcmV0dXJuIGd1aWRlbGluZUluZm9zLnNvbWUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgZ3VpZGVsaW5lID0gX2EuZ3VpZGVsaW5lO1xuICAgICAgICAgICAgcmV0dXJuICFndWlkZWxpbmUuaGlkZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChwb3NJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwic25hcFwiLFxuICAgICAgICAgICAgcG9zOiBwb3NJbmZvLnBvc1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICAgICAgdmVydGljYWxHdWlkZWxpbmVzLnB1c2guYXBwbHkodmVydGljYWxHdWlkZWxpbmVzLCBnZXRTbmFwR3VpZGVsaW5lcyh2ZXJ0aWNhbFBvc0luZm9zKSk7XG4gICAgICAgIGhvcml6b250YWxHdWlkZWxpbmVzLnB1c2guYXBwbHkoaG9yaXpvbnRhbEd1aWRlbGluZXMsIGdldFNuYXBHdWlkZWxpbmVzKGhvcml6b250YWxQb3NJbmZvcykpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWRkQm91bmRHdWlkZWxpbmVzKG1vdmVhYmxlLCBbbGVmdCwgcmlnaHRdLCBbdG9wLCBib3R0b21dLCB2ZXJ0aWNhbFNuYXBQb3NlcywgaG9yaXpvbnRhbFNuYXBQb3Nlcyk7XG5cbiAgICBpZiAoaGFzRXh0ZXJuYWxQb3Nlcykge1xuICAgICAgYWRkQm91bmRHdWlkZWxpbmVzKG1vdmVhYmxlLCBbZXh0ZXJuYWxSZWN0LmxlZnQsIGV4dGVybmFsUmVjdC5yaWdodF0sIFtleHRlcm5hbFJlY3QudG9wLCBleHRlcm5hbFJlY3QuYm90dG9tXSwgdmVydGljYWxTbmFwUG9zZXMsIGhvcml6b250YWxTbmFwUG9zZXMsIHNuYXBSZW5kZXJJbmZvLmV4dGVybmFsQm91bmRzKTtcbiAgICB9XG5cbiAgICB2YXIgYWxsR3VpZGVsaW5lcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgdmVydGljYWxHdWlkZWxpbmVzLCB0cnVlKSwgaG9yaXpvbnRhbEd1aWRlbGluZXMsIHRydWUpO1xuXG4gICAgdmFyIGVsZW1lbnRHdWlkZWxpbmVzID0gYWxsR3VpZGVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGd1aWRlbGluZSkge1xuICAgICAgcmV0dXJuIGd1aWRlbGluZS5lbGVtZW50ICYmICFndWlkZWxpbmUuZ2FwUmVjdHM7XG4gICAgfSk7XG4gICAgdmFyIGdhcEd1aWRlbGluZXMgPSBhbGxHdWlkZWxpbmVzLmZpbHRlcihmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XG4gICAgICByZXR1cm4gZ3VpZGVsaW5lLmdhcFJlY3RzO1xuICAgIH0pO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNuYXBcIiwge1xuICAgICAgZ3VpZGVsaW5lczogYWxsR3VpZGVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gX2EuZWxlbWVudDtcbiAgICAgICAgcmV0dXJuICFlbGVtZW50O1xuICAgICAgfSksXG4gICAgICBlbGVtZW50czogZWxlbWVudEd1aWRlbGluZXMsXG4gICAgICBnYXBzOiBnYXBHdWlkZWxpbmVzXG4gICAgfSwgdHJ1ZSk7XG4gICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCByZW5kZXJEYXNoZWRHdWlkZWxpbmVzKG1vdmVhYmxlLCBlbGVtZW50R3VpZGVsaW5lcywgW21pbkxlZnQsIG1pblRvcF0sIHRhcmdldFJlY3QsIFJlYWN0KSwgdHJ1ZSksIHJlbmRlckdhcEd1aWRlbGluZXMobW92ZWFibGUsIGdhcEd1aWRlbGluZXMsIFttaW5MZWZ0LCBtaW5Ub3BdLCB0YXJnZXRSZWN0LCBSZWFjdCksIHRydWUpLCByZW5kZXJHdWlkZWxpbmVzKG1vdmVhYmxlLCBcImhvcml6b250YWxcIiwgaG9yaXpvbnRhbEd1aWRlbGluZXMsIFt0YXJnZXRMZWZ0LCB0YXJnZXRUb3BdLCB0YXJnZXRSZWN0LCBSZWFjdCksIHRydWUpLCByZW5kZXJHdWlkZWxpbmVzKG1vdmVhYmxlLCBcInZlcnRpY2FsXCIsIHZlcnRpY2FsR3VpZGVsaW5lcywgW3RhcmdldExlZnQsIHRhcmdldFRvcF0sIHRhcmdldFJlY3QsIFJlYWN0KSwgdHJ1ZSksIHJlbmRlclNuYXBQb3Nlcyhtb3ZlYWJsZSwgXCJob3Jpem9udGFsXCIsIGhvcml6b250YWxTbmFwUG9zZXMsIG1pbkxlZnQsIHRhcmdldFRvcCwgd2lkdGgsIDAsIFJlYWN0KSwgdHJ1ZSksIHJlbmRlclNuYXBQb3Nlcyhtb3ZlYWJsZSwgXCJ2ZXJ0aWNhbFwiLCB2ZXJ0aWNhbFNuYXBQb3NlcywgbWluVG9wLCB0YXJnZXRMZWZ0LCBoZWlnaHQsIDEsIFJlYWN0KSwgdHJ1ZSk7XG4gIH0sXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgbW92ZWFibGUuc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XG4gICAgICByZXF1ZXN0OiBlLmlzUmVxdWVzdCxcbiAgICAgIHNuYXA6IHRydWUsXG4gICAgICBjZW50ZXI6IHRydWVcbiAgICB9O1xuICAgIHNuYXBTdGFydChtb3ZlYWJsZSk7XG4gIH0sXG4gIGRyYWc6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHN0YXRlLmd1aWRlbGluZXMgPSBnZXRUb3RhbEd1aWRlbGluZXMobW92ZWFibGUpO1xuICB9LFxuICBwaW5jaFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB0aGlzLnVuc2V0KG1vdmVhYmxlKTtcbiAgfSxcbiAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICBpZiAoZGlyZWN0aW9uQ29uZGl0aW9uKG1vdmVhYmxlLCBlKSB8fCBkcmFnQ29udHJvbENvbmRpdGlvbihtb3ZlYWJsZSwgZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghZS5pc1JlcXVlc3QgJiYgZS5pbnB1dEV2ZW50KSB7XG4gICAgICByZXR1cm4gaGFzQ2xhc3MoZS5pbnB1dEV2ZW50LnRhcmdldCwgcHJlZml4KFwic25hcC1jb250cm9sXCIpKTtcbiAgICB9XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBSZW5kZXJJbmZvID0gbnVsbDtcbiAgICBzbmFwU3RhcnQobW92ZWFibGUpO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdGhpcy5kcmFnKG1vdmVhYmxlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xuICB9LFxuICBkcmFnR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHRoaXMuZHJhZyhtb3ZlYWJsZSk7XG4gIH0sXG4gIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgbW92ZWFibGUuc3RhdGUuc25hcFJlbmRlckluZm8gPSBudWxsO1xuICAgIHNuYXBTdGFydChtb3ZlYWJsZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHRoaXMuZHJhZyhtb3ZlYWJsZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xuICB9LFxuICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gICAgc3RhdGUuZW5hYmxlU25hcCA9IGZhbHNlO1xuICAgIHN0YXRlLmd1aWRlbGluZXMgPSBbXTtcbiAgICBzdGF0ZS5zbmFwUmVuZGVySW5mbyA9IG51bGw7XG4gICAgc3RhdGUuZWxlbWVudFJlY3RzID0gW107XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgc25hcHBlZCB0byB0aGUgZ3VpZGVsaW5lLiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcHBhYmxlXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnNuYXBwYWJsZSA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiAgQSBzbmFwIGNvbnRhaW5lciB0aGF0IGlzIHRoZSBiYXNpcyBmb3Igc25hcCwgYm91bmRzLCBhbmQgaW5uZXJCb3VuZHMuIChkZWZhdWx0OiBudWxsID0gY29udGFpbmVyKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3NuYXBDb250YWluZXJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5jb250YWluZXJcIikpO1xuICpcbiAqIG1vdmVhYmxlLnNuYXBDb250YWluZXIgPSBkb2N1bWVudC5ib2R5O1xuICovXG5cbi8qKlxuICogWW91IGNhbiBzcGVjaWZ5IHRoZSBkaXJlY3Rpb25zIHRvIHNuYXAgdG8gdGhlIHRhcmdldC4gKGRlZmF1bHQ6IHsgbGVmdDogdHJ1ZSwgdG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlIH0pXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcERpcmVjdGlvbnNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICBzbmFwcGFibGU6IHRydWUsXG4gKiAgIHNuYXBEaXJlY3Rpb25zOiB0cnVlLFxuICogfSk7XG4gKiAvLyBzbmFwIGNlbnRlclxuICogbW92ZWFibGUuc25hcERpcmVjdGlvbnMgPSB7IGxlZnQ6IHRydWUsIHRvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSwgY2VudGVyOiB0cnVlLCBtaWRkbGU6IHRydWUgfTtcbiAqL1xuXG4vKipcbiAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgc25hcCBkaXJlY3Rpb25zIG9mIGVsZW1lbnRzLiAoZGVmYXVsdDogeyBsZWZ0OiB0cnVlLCB0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUgfSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNlbGVtZW50U25hcERpcmVjdGlvbnNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICBzbmFwcGFibGU6IHRydWUsXG4gKiAgIGVsZW1lbnRTbmFwRGlyZWN0aW9uczogdHJ1ZSxcbiAqIH0pO1xuICogLy8gc25hcCBjZW50ZXJcbiAqIG1vdmVhYmxlLmVsZW1lbnRTbmFwRGlyZWN0aW9ucyA9IHsgbGVmdDogdHJ1ZSwgdG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlLCBjZW50ZXI6IHRydWUsIG1pZGRsZTogdHJ1ZSB9O1xuICovXG5cbi8qKlxuICogV2hlbiB5b3UgZHJhZywgbWFrZSB0aGUgZ2FwIHNuYXAgaW4gdGhlIGVsZW1lbnQgZ3VpZGVsaW5lcy4gKGRlZmF1bHQ6IHRydWUpXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcEdhcFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHNuYXBwYWJsZTogdHJ1ZSxcbiAqICAgc25hcEVsZW1lbnQ6IHRydWUsXG4gKiAgIHNuYXBHYXA6IHRydWUsXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS5zbmFwR2FwID0gZmFsc2U7XG4gKi9cblxuLyoqXG4gKiBEaXN0YW5jZSB2YWx1ZSB0aGF0IGNhbiBzbmFwIHRvIGd1aWRlbGluZXMuIChkZWZhdWx0OiA1KVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3NuYXBUaHJlc2hvbGRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUuc25hcFRocmVzaG9sZCA9IDU7XG4gKi9cblxuLyoqXG4gKiBBZGQgZ3VpZGVsaW5lcyBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24uIChkZWZhdWx0OiBbXSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNob3Jpem9udGFsR3VpZGVsaW5lc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5ob3Jpem9udGFsR3VpZGVsaW5lcyA9IFsxMDAsIDIwMCwgNTAwXTtcbiAqL1xuXG4vKipcbiAqIEFkZCBndWlkZWxpbmVzIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24uIChkZWZhdWx0OiBbXSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSN2ZXJ0aWNhbEd1aWRlbGluZXNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUudmVydGljYWxHdWlkZWxpbmVzID0gWzEwMCwgMjAwLCA1MDBdO1xuICovXG5cbi8qKlxuICogQWRkIGd1aWRlbGluZXMgZm9yIHRoZSBlbGVtZW50LiAoZGVmYXVsdDogW10pXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjZWxlbWVudEd1aWRlbGluZXNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUuZWxlbWVudEd1aWRlbGluZXMgPSBbXG4gKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZWxlbWVudFwiKSxcbiAqIF07XG4gKi9cblxuLyoqXG4gKiBZb3UgY2FuIHNldCB1cCBib3VuZGFyaWVzLlxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2JvdW5kc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGRlZmF1bHQgbnVsbFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5ib3VuZHMgPSB7IGxlZnQ6IDAsIHJpZ2h0OiAxMDAwLCB0b3A6IDAsIGJvdHRvbTogMTAwMH07XG4gKi9cblxuLyoqXG4gKiBZb3UgY2FuIHNldCB1cCBpbm5lciBib3VuZGFyaWVzLlxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2lubmVyQm91bmRzXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZGVmYXVsdCBudWxsXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLmlubmVyQm91bmRzID0geyBsZWZ0OiA1MDAsIHRvcDogNTAwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMH07XG4gKi9cblxuLyoqXG4gKiBzbmFwIGRpc3RhbmNlIGRpZ2l0cyAoZGVmYXVsdDogMClcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwRGlnaXRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUuc25hcERpZ2l0ID0gMFxuICovXG5cbi8qKlxuICogSWYgd2lkdGggc2l6ZSBpcyBncmVhdGVyIHRoYW4gMCwgeW91IGNhbiB2ZXJ0aWNhbCBzbmFwIHRvIHRoZSBncmlkLiAoZGVmYXVsdDogMClcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwR3JpZFdpZHRoXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnNuYXBHcmlkV2lkdGggPSA1O1xuICovXG5cbi8qKlxuICogSWYgaGVpZ2h0IHNpemUgaXMgZ3JlYXRlciB0aGFuIDAsIHlvdSBjYW4gaG9yaXpvbnRhbCBzbmFwIHRvIHRoZSBncmlkLiAoZGVmYXVsdDogMClcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwR3JpZEhlaWdodFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5zbmFwR3JpZEhlaWdodCA9IDU7XG4gKi9cblxuLyoqXG4gKiBXaGV0aGVyIHRvIHNob3cgc25hcCBkaXN0YW5jZSAoZGVmYXVsdDogdHJ1ZSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNpc0Rpc3BsYXlTbmFwRGlnaXRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUuaXNEaXNwbGF5U25hcERpZ2l0ID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFdoZXRoZXIgdG8gc2hvdyBlbGVtZW50IGlubmVyIHNuYXAgZGlzdGFuY2UgKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2lzRGlzcGxheUlubmVyU25hcERpZ2l0XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLmlzRGlzcGxheUlubmVyU25hcERpZ2l0ID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFlvdSBjYW4gc2V0IHRoZSB0ZXh0IGZvcm1hdCBvZiB0aGUgZGlzdGFuY2Ugc2hvd24gaW4gdGhlIGd1aWRlbGluZXMuIChkZWZhdWx0OiBzZWxmKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3NuYXBEaXN0Rm9ybWF0XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICBzbmFwcGFibGU6IHRydWUsXG4gKiAgc25hcERpc3RGb3JtYXQ6ICh2LCB0eXBlKSA9PiB2LFxuICogfSk7XG4gKiBtb3ZlYWJsZS5zbmFwRGlzdEZvcm1hdCA9ICh2LCB0eXBlKSA9PiBgJHt2fXB4YDtcbiAqL1xuXG4vKipcbiAqIFdoZW4geW91IGRyYWcgb3IgZHJhZ0NvbnRyb2wsIHRoZSBgc25hcGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNuYXBwYWJsZVxuICogQGV2ZW50IHNuYXBcbiAqIEBwYXJhbSB7TW92ZWFibGUuU25hcHBhYmxlLk9uU25hcH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNuYXBgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBzbmFwcGFibGU6IHRydWVcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJzbmFwXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25TbmFwXCIsIGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIERyYWdnYWJsZVxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZGVzY3JpcHRpb24gRHJhZ2dhYmxlIHJlZmVycyB0byB0aGUgYWJpbGl0eSB0byBkcmFnIGFuZCBtb3ZlIHRhcmdldHMuXG4gKi9cblxudmFyIERyYWdnYWJsZSA9IHtcbiAgbmFtZTogXCJkcmFnZ2FibGVcIixcbiAgcHJvcHM6IHtcbiAgICBkcmFnZ2FibGU6IEJvb2xlYW4sXG4gICAgdGhyb3R0bGVEcmFnOiBOdW1iZXIsXG4gICAgdGhyb3R0bGVEcmFnUm90YXRlOiBOdW1iZXIsXG4gICAgc3RhcnREcmFnUm90YXRlOiBOdW1iZXIsXG4gICAgZWRnZURyYWdnYWJsZTogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHtcbiAgICBvbkRyYWdTdGFydDogXCJkcmFnU3RhcnRcIixcbiAgICBvbkRyYWc6IFwiZHJhZ1wiLFxuICAgIG9uRHJhZ0VuZDogXCJkcmFnRW5kXCIsXG4gICAgb25EcmFnR3JvdXBTdGFydDogXCJkcmFnR3JvdXBTdGFydFwiLFxuICAgIG9uRHJhZ0dyb3VwOiBcImRyYWdHcm91cFwiLFxuICAgIG9uRHJhZ0dyb3VwRW5kOiBcImRyYWdHcm91cEVuZFwiXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICB0aHJvdHRsZURyYWdSb3RhdGUgPSBfYS50aHJvdHRsZURyYWdSb3RhdGUsXG4gICAgICAgIHpvb20gPSBfYS56b29tO1xuICAgIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICBkcmFnSW5mbyA9IF9iLmRyYWdJbmZvLFxuICAgICAgICBiZWZvcmVPcmlnaW4gPSBfYi5iZWZvcmVPcmlnaW47XG5cbiAgICBpZiAoIXRocm90dGxlRHJhZ1JvdGF0ZSB8fCAhZHJhZ0luZm8pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgZGlzdCA9IGRyYWdJbmZvLmRpc3Q7XG5cbiAgICBpZiAoIWRpc3RbMF0gJiYgIWRpc3RbMV0pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBnZXREaXN0U2l6ZShkaXN0KTtcbiAgICB2YXIgcmFkID0gZ2V0UmFkKGRpc3QsIFswLCAwXSk7XG4gICAgcmV0dXJuIFtSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwibGluZVwiLCBcImhvcml6b250YWxcIiwgXCJkcmFnbGluZVwiLCBcImRhc2hlZFwiKSxcbiAgICAgIGtleTogXCJkcmFnUm90YXRlR3VpZGVsaW5lXCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIiksXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGJlZm9yZU9yaWdpblswXSwgXCJweCwgXCIpLmNvbmNhdChiZWZvcmVPcmlnaW5bMV0sIFwicHgpIHJvdGF0ZShcIikuY29uY2F0KHJhZCwgXCJyYWQpIHNjYWxlWShcIikuY29uY2F0KHpvb20sIFwiKVwiKVxuICAgICAgfVxuICAgIH0pXTtcbiAgfSxcbiAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBwYXJlbnRFdmVudCA9IGUucGFyZW50RXZlbnQsXG4gICAgICAgIHBhcmVudEdlc3RvID0gZS5wYXJlbnRHZXN0bztcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LFxuICAgICAgICBnZXN0byA9IHN0YXRlLmdlc3RvO1xuXG4gICAgaWYgKGdlc3RvKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGUuZ2VzdG8gPSBwYXJlbnRHZXN0byB8fCBtb3ZlYWJsZS50YXJnZXRHZXN0bztcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gICAgZGF0YXMuZGF0YXMgPSB7fTtcbiAgICBkYXRhcy5sZWZ0ID0gcGFyc2VGbG9hdChzdHlsZS5sZWZ0IHx8IFwiXCIpIHx8IDA7XG4gICAgZGF0YXMudG9wID0gcGFyc2VGbG9hdChzdHlsZS50b3AgfHwgXCJcIikgfHwgMDtcbiAgICBkYXRhcy5ib3R0b20gPSBwYXJzZUZsb2F0KHN0eWxlLmJvdHRvbSB8fCBcIlwiKSB8fCAwO1xuICAgIGRhdGFzLnJpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5yaWdodCB8fCBcIlwiKSB8fCAwO1xuICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSBbMCwgMF07XG4gICAgc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgICBzZXREZWZhdWx0VHJhbnNmb3JtSW5kZXgoZSwgXCJ0cmFuc2xhdGVcIik7XG4gICAgc3RhcnRDaGVja1NuYXBEcmFnKG1vdmVhYmxlLCBkYXRhcyk7XG4gICAgZGF0YXMucHJldkRpc3QgPSBbMCwgMF07XG4gICAgZGF0YXMucHJldkJlZm9yZURpc3QgPSBbMCwgMF07XG4gICAgZGF0YXMuaXNEcmFnID0gZmFsc2U7XG4gICAgZGF0YXMuZGVsdGFPZmZzZXQgPSBbMCwgMF07XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHtcbiAgICAgIHNldDogZnVuY3Rpb24gKHRyYW5zbGF0ZSkge1xuICAgICAgICBkYXRhcy5zdGFydFZhbHVlID0gdHJhbnNsYXRlO1xuICAgICAgfVxuICAgIH0sIGZpbGxUcmFuc2Zvcm1TdGFydEV2ZW50KGUpKSk7XG4gICAgdmFyIHJlc3VsdCA9IHBhcmVudEV2ZW50IHx8IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdTdGFydFwiLCBwYXJhbXMpO1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgIGRhdGFzLmlzRHJhZyA9IHRydWU7XG4gICAgICBtb3ZlYWJsZS5zdGF0ZS5kcmFnSW5mbyA9IHtcbiAgICAgICAgc3RhcnRSZWN0OiBtb3ZlYWJsZS5nZXRSZWN0KCksXG4gICAgICAgIGRpc3Q6IFswLCAwXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuZ2VzdG8gPSBudWxsO1xuICAgICAgZGF0YXMuaXNQaW5jaCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhcy5pc0RyYWcgPyBwYXJhbXMgOiBmYWxzZTtcbiAgfSxcbiAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgaWYgKCFlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzb2x2ZVRyYW5zZm9ybUV2ZW50KGUsIFwidHJhbnNsYXRlXCIpO1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIHBhcmVudEV2ZW50ID0gZS5wYXJlbnRFdmVudCxcbiAgICAgICAgcGFyZW50RmxhZyA9IGUucGFyZW50RmxhZyxcbiAgICAgICAgaXNQaW5jaCA9IGUuaXNQaW5jaCxcbiAgICAgICAgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3QsXG4gICAgICAgIGRlbHRhT2Zmc2V0ID0gZS5kZWx0YU9mZnNldDtcbiAgICB2YXIgZGlzdFggPSBlLmRpc3RYLFxuICAgICAgICBkaXN0WSA9IGUuZGlzdFk7XG4gICAgdmFyIGlzRHJhZyA9IGRhdGFzLmlzRHJhZyxcbiAgICAgICAgcHJldkRpc3QgPSBkYXRhcy5wcmV2RGlzdCxcbiAgICAgICAgcHJldkJlZm9yZURpc3QgPSBkYXRhcy5wcmV2QmVmb3JlRGlzdCxcbiAgICAgICAgc3RhcnRWYWx1ZSA9IGRhdGFzLnN0YXJ0VmFsdWU7XG5cbiAgICBpZiAoIWlzRHJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkZWx0YU9mZnNldCkge1xuICAgICAgZGlzdFggKz0gZGVsdGFPZmZzZXRbMF07XG4gICAgICBkaXN0WSArPSBkZWx0YU9mZnNldFsxXTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcbiAgICB2YXIgcGFyZW50TW92ZWFibGUgPSBwcm9wcy5wYXJlbnRNb3ZlYWJsZTtcbiAgICB2YXIgdGhyb3R0bGVEcmFnID0gcGFyZW50RXZlbnQgPyAwIDogcHJvcHMudGhyb3R0bGVEcmFnIHx8IDA7XG4gICAgdmFyIHRocm90dGxlRHJhZ1JvdGF0ZSA9IHBhcmVudEV2ZW50ID8gMCA6IHByb3BzLnRocm90dGxlRHJhZ1JvdGF0ZSB8fCAwO1xuICAgIHZhciBpc1NuYXAgPSBmYWxzZTtcbiAgICB2YXIgZHJhZ1JvdGF0ZVJhZCA9IDA7XG5cbiAgICBpZiAoIXBhcmVudEV2ZW50ICYmIHRocm90dGxlRHJhZ1JvdGF0ZSA+IDAgJiYgKGRpc3RYIHx8IGRpc3RZKSkge1xuICAgICAgdmFyIHN0YXJ0RHJhZ1JvdGF0ZSA9IHByb3BzLnN0YXJ0RHJhZ1JvdGF0ZSB8fCAwO1xuICAgICAgdmFyIGRlZyA9IHRocm90dGxlKHN0YXJ0RHJhZ1JvdGF0ZSArIGdldFJhZChbMCwgMF0sIFtkaXN0WCwgZGlzdFldKSAqIDE4MCAvIE1hdGguUEksIHRocm90dGxlRHJhZ1JvdGF0ZSkgLSBzdGFydERyYWdSb3RhdGU7XG4gICAgICB2YXIgcnkgPSBkaXN0WSAqIE1hdGguYWJzKE1hdGguY29zKChkZWcgLSA5MCkgLyAxODAgKiBNYXRoLlBJKSk7XG4gICAgICB2YXIgcnggPSBkaXN0WCAqIE1hdGguYWJzKE1hdGguY29zKGRlZyAvIDE4MCAqIE1hdGguUEkpKTtcbiAgICAgIHZhciByID0gZ2V0RGlzdFNpemUoW3J4LCByeV0pO1xuICAgICAgZHJhZ1JvdGF0ZVJhZCA9IGRlZyAqIE1hdGguUEkgLyAxODA7XG4gICAgICBkaXN0WCA9IHIgKiBNYXRoLmNvcyhkcmFnUm90YXRlUmFkKTtcbiAgICAgIGRpc3RZID0gciAqIE1hdGguc2luKGRyYWdSb3RhdGVSYWQpO1xuICAgIH1cblxuICAgIGlmICghaXNQaW5jaCAmJiAhcGFyZW50RXZlbnQgJiYgIXBhcmVudEZsYWcgJiYgKCF0aHJvdHRsZURyYWdSb3RhdGUgfHwgZGlzdFggfHwgZGlzdFkpKSB7XG4gICAgICB2YXIgX2EgPSBjaGVja1NuYXBCb3VuZHNEcmFnKG1vdmVhYmxlLCBkaXN0WCwgZGlzdFksIHRocm90dGxlRHJhZ1JvdGF0ZSwgaXNSZXF1ZXN0IHx8IGRlbHRhT2Zmc2V0LCBkYXRhcyksXG4gICAgICAgICAgdmVydGljYWxJbmZvID0gX2FbMF0sXG4gICAgICAgICAgaG9yaXpvbnRhbEluZm8gPSBfYVsxXTtcblxuICAgICAgdmFyIGlzVmVydGljYWxTbmFwID0gdmVydGljYWxJbmZvLmlzU25hcCxcbiAgICAgICAgICBpc1ZlcnRpY2FsQm91bmQgPSB2ZXJ0aWNhbEluZm8uaXNCb3VuZCxcbiAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9IHZlcnRpY2FsSW5mby5vZmZzZXQ7XG4gICAgICB2YXIgaXNIb3Jpem9udGFsU25hcCA9IGhvcml6b250YWxJbmZvLmlzU25hcCxcbiAgICAgICAgICBpc0hvcml6b250YWxCb3VuZCA9IGhvcml6b250YWxJbmZvLmlzQm91bmQsXG4gICAgICAgICAgaG9yaXpvbnRhbE9mZnNldCA9IGhvcml6b250YWxJbmZvLm9mZnNldDtcbiAgICAgIGlzU25hcCA9IGlzVmVydGljYWxTbmFwIHx8IGlzSG9yaXpvbnRhbFNuYXAgfHwgaXNWZXJ0aWNhbEJvdW5kIHx8IGlzSG9yaXpvbnRhbEJvdW5kO1xuICAgICAgZGlzdFggKz0gdmVydGljYWxPZmZzZXQ7XG4gICAgICBkaXN0WSArPSBob3Jpem9udGFsT2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciBiZWZvcmVUcmFuc2xhdGUgPSBwbHVzKGdldEJlZm9yZURyYWdEaXN0KHtcbiAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgIGRpc3RYOiBkaXN0WCxcbiAgICAgIGRpc3RZOiBkaXN0WVxuICAgIH0pLCBzdGFydFZhbHVlKTtcbiAgICB2YXIgdHJhbnNsYXRlID0gcGx1cyhnZXRUcmFuc2Zvcm1EaXN0KHtcbiAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgIGRpc3RYOiBkaXN0WCxcbiAgICAgIGRpc3RZOiBkaXN0WVxuICAgIH0pLCBzdGFydFZhbHVlKTtcblxuICAgIGlmICghdGhyb3R0bGVEcmFnUm90YXRlICYmICFpc1NuYXApIHtcbiAgICAgIHRocm90dGxlQXJyYXkodHJhbnNsYXRlLCB0aHJvdHRsZURyYWcpO1xuICAgICAgdGhyb3R0bGVBcnJheShiZWZvcmVUcmFuc2xhdGUsIHRocm90dGxlRHJhZyk7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZURpc3QgPSBtaW51cyhiZWZvcmVUcmFuc2xhdGUsIHN0YXJ0VmFsdWUpO1xuICAgIHZhciBkaXN0ID0gbWludXModHJhbnNsYXRlLCBzdGFydFZhbHVlKTtcbiAgICB2YXIgZGVsdGEgPSBtaW51cyhkaXN0LCBwcmV2RGlzdCk7XG4gICAgdmFyIGJlZm9yZURlbHRhID0gbWludXMoYmVmb3JlRGlzdCwgcHJldkJlZm9yZURpc3QpO1xuICAgIGRhdGFzLnByZXZEaXN0ID0gZGlzdDtcbiAgICBkYXRhcy5wcmV2QmVmb3JlRGlzdCA9IGJlZm9yZURpc3Q7XG4gICAgZGF0YXMucGFzc0RlbHRhID0gZGVsdGE7IC8vZGlzdFggLSAoZGF0YXMucGFzc0Rpc3RYIHx8IDApO1xuICAgIC8vIGRhdGFzLnBhc3NEZWx0YVkgPSBkaXN0WSAtIChkYXRhcy5wYXNzRGlzdFkgfHwgMCk7XG5cbiAgICBkYXRhcy5wYXNzRGlzdCA9IGRpc3Q7IC8vZGlzdFg7XG4gICAgLy8gZGF0YXMucGFzc0Rpc3RZID0gZGlzdFk7XG5cbiAgICB2YXIgbGVmdCA9IGRhdGFzLmxlZnQgKyBiZWZvcmVEaXN0WzBdO1xuICAgIHZhciB0b3AgPSBkYXRhcy50b3AgKyBiZWZvcmVEaXN0WzFdO1xuICAgIHZhciByaWdodCA9IGRhdGFzLnJpZ2h0IC0gYmVmb3JlRGlzdFswXTtcbiAgICB2YXIgYm90dG9tID0gZGF0YXMuYm90dG9tIC0gYmVmb3JlRGlzdFsxXTtcbiAgICB2YXIgbmV4dFRyYW5zZm9ybSA9IGNvbnZlcnRUcmFuc2Zvcm1Gb3JtYXQoZGF0YXMsIFwidHJhbnNsYXRlKFwiLmNvbmNhdCh0cmFuc2xhdGVbMF0sIFwicHgsIFwiKS5jb25jYXQodHJhbnNsYXRlWzFdLCBcInB4KVwiKSwgXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGRpc3RbMF0sIFwicHgsIFwiKS5jb25jYXQoZGlzdFsxXSwgXCJweClcIikpO1xuICAgIGZpbGxPcmlnaW5hbFRyYW5zZm9ybShlLCBuZXh0VHJhbnNmb3JtKTtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5kcmFnSW5mby5kaXN0ID0gcGFyZW50RXZlbnQgPyBbMCwgMF0gOiBkaXN0O1xuXG4gICAgaWYgKCFwYXJlbnRFdmVudCAmJiAhcGFyZW50TW92ZWFibGUgJiYgZGVsdGEuZXZlcnkoZnVuY3Rpb24gKG51bSkge1xuICAgICAgcmV0dXJuICFudW07XG4gICAgfSkgJiYgYmVmb3JlRGVsdGEuc29tZShmdW5jdGlvbiAobnVtKSB7XG4gICAgICByZXR1cm4gIW51bTtcbiAgICB9KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICB3aWR0aCA9IF9iLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYi5oZWlnaHQ7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIHRyYW5zZm9ybTogbmV4dFRyYW5zZm9ybSxcbiAgICAgIGRpc3Q6IGRpc3QsXG4gICAgICBkZWx0YTogZGVsdGEsXG4gICAgICB0cmFuc2xhdGU6IHRyYW5zbGF0ZSxcbiAgICAgIGJlZm9yZURpc3Q6IGJlZm9yZURpc3QsXG4gICAgICBiZWZvcmVEZWx0YTogYmVmb3JlRGVsdGEsXG4gICAgICBiZWZvcmVUcmFuc2xhdGU6IGJlZm9yZVRyYW5zbGF0ZSxcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBpc1BpbmNoOiBpc1BpbmNoXG4gICAgfSk7XG4gICAgIXBhcmVudEV2ZW50ICYmIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdcIiwgcGFyYW1zKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9LFxuICBkcmFnQWZ0ZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG4gICAgdmFyIGRlbHRhT2Zmc2V0ID0gZGF0YXMuZGVsdGFPZmZzZXQ7XG5cbiAgICBpZiAoZGVsdGFPZmZzZXRbMF0gfHwgZGVsdGFPZmZzZXRbMV0pIHtcbiAgICAgIGRhdGFzLmRlbHRhT2Zmc2V0ID0gWzAsIDBdO1xuICAgICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICAgIGRlbHRhT2Zmc2V0OiBkZWx0YU9mZnNldFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIHBhcmVudEV2ZW50ID0gZS5wYXJlbnRFdmVudCxcbiAgICAgICAgZGF0YXMgPSBlLmRhdGFzO1xuICAgIG1vdmVhYmxlLnN0YXRlLmdlc3RvID0gbnVsbDtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5kcmFnSW5mbyA9IG51bGw7XG5cbiAgICBpZiAoIWRhdGFzLmlzRHJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRhdGFzLmlzRHJhZyA9IGZhbHNlO1xuICAgIHZhciBwYXJhbSA9IGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KTtcbiAgICAhcGFyZW50RXZlbnQgJiYgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ0VuZFwiLCBwYXJhbSk7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9LFxuICBkcmFnR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgY2xpZW50WCA9IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WSA9IGUuY2xpZW50WTtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkR2VzdG8obW92ZWFibGUsIHRoaXMsIFwiZHJhZ1N0YXJ0XCIsIFtjbGllbnRYIHx8IDAsIGNsaWVudFkgfHwgMF0sIGUsIGZhbHNlKTtcblxuICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtcyksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IGV2ZW50c1xuICAgIH0pO1xuXG4gICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdHcm91cFN0YXJ0XCIsIG5leHRQYXJhbXMpO1xuICAgIGRhdGFzLmlzRHJhZyA9IHJlc3VsdCAhPT0gZmFsc2U7XG4gICAgcmV0dXJuIGRhdGFzLmlzRHJhZyA/IHBhcmFtcyA6IGZhbHNlO1xuICB9LFxuICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzRHJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xuICAgIHZhciBwYXNzRGVsdGEgPSBlLmRhdGFzLnBhc3NEZWx0YTtcbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkR2VzdG8obW92ZWFibGUsIHRoaXMsIFwiZHJhZ1wiLCBwYXNzRGVsdGEsIGUsIGZhbHNlKTtcblxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbih7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHNcbiAgICB9LCBwYXJhbXMpO1xuXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ0dyb3VwXCIsIG5leHRQYXJhbXMpO1xuICAgIHJldHVybiBuZXh0UGFyYW1zO1xuICB9LFxuICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBpc0RyYWcgPSBlLmlzRHJhZyxcbiAgICAgICAgZGF0YXMgPSBlLmRhdGFzO1xuXG4gICAgaWYgKCFkYXRhcy5pc0RyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xuICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRHZXN0byhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnRW5kXCIsIFswLCAwXSwgZSwgZmFsc2UpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdHcm91cEVuZFwiLCBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHNcbiAgICB9KSk7XG4gICAgcmV0dXJuIGlzRHJhZztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBNb3ZlYWJsZS5EcmFnZ2FibGUjcmVxdWVzdFxuICAgKiBAcGFyYW0ge29iamVjdH0gW2VdIC0gdGhlIGRyYWdnYWJsZSdzIHJlcXVlc3QgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS54XSAtIHggcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLnldIC0geSBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gW2UuZGVsdGFYXSAtIFggbnVtYmVyIHRvIG1vdmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhWV0gLSBZIG51bWJlciB0byBtb3ZlXG4gICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXG4gICAqIEBleGFtcGxlXG4gICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXG4gICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxuICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwiZHJhZ2dhYmxlXCIsIHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9LCB0cnVlKTtcbiAgICogLy8gVXNlIEFic29sdXRlIFZhbHVlXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9LCB0cnVlKTtcbiAgICpcbiAgICogLy8gcmVxdWVzdFN0YXJ0XG4gICAqIGNvbnN0IHJlcXVlc3RlciA9IG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIik7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RcbiAgICogLy8gVXNlIFJlbGF0aXZlIFZhbHVlXG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICAqIC8vIFVzZSBBYnNvbHV0ZSBWYWx1ZVxuICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwiZHJhZ2dhYmxlXCIsIHsgeDogMjAwLCB5OiAxMDAgfSk7XG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyMjAsIHk6IDEwMCB9KTtcbiAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IHg6IDI0MCwgeTogMTAwIH0pO1xuICAgKlxuICAgKiAvLyByZXF1ZXN0RW5kXG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0RW5kKCk7XG4gICAqL1xuICByZXF1ZXN0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB2YXIgZGF0YXMgPSB7fTtcbiAgICB2YXIgcmVjdCA9IG1vdmVhYmxlLmdldFJlY3QoKTtcbiAgICB2YXIgZGlzdFggPSAwO1xuICAgIHZhciBkaXN0WSA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQ29udHJvbDogZmFsc2UsXG4gICAgICByZXF1ZXN0U3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoXCJ4XCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RYID0gZS54IC0gcmVjdC5sZWZ0O1xuICAgICAgICB9IGVsc2UgaWYgKFwiZGVsdGFYXCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RYICs9IGUuZGVsdGFYO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwieVwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0WSA9IGUueSAtIHJlY3QudG9wO1xuICAgICAgICB9IGVsc2UgaWYgKFwiZGVsdGFZXCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RZICs9IGUuZGVsdGFZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgZGlzdFg6IGRpc3RYLFxuICAgICAgICAgIGRpc3RZOiBkaXN0WVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgaXNEcmFnOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgdW5zZXQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIG1vdmVhYmxlLnN0YXRlLmRyYWdJbmZvID0gbnVsbDtcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBkcmFnZ2VkLiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5EcmFnZ2FibGUjZHJhZ2dhYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLmRyYWdnYWJsZSA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiB0aHJvdHRsZSBvZiB4LCB5IHdoZW4gZHJhZy5cbiAqIEBuYW1lIE1vdmVhYmxlLkRyYWdnYWJsZSN0aHJvdHRsZURyYWdcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUudGhyb3R0bGVEcmFnID0gMTtcbiAqL1xuXG4vKipcbiogdGhyb3R0bGUgb2YgYW5nbGUgb2YgeCwgeSB3aGVuIGRyYWcuXG4qIEBuYW1lIE1vdmVhYmxlLkRyYWdnYWJsZSN0aHJvdHRsZURyYWdSb3RhdGVcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbipcbiogbW92ZWFibGUudGhyb3R0bGVEcmFnUm90YXRlID0gNDU7XG4qL1xuXG4vKipcbiogc3RhcnQgYW5nbGUgb2YgdGhyb3R0bGVEcmFnUm90YXRlIG9mIHgsIHkgd2hlbiBkcmFnLlxuKiBAbmFtZSBNb3ZlYWJsZS5EcmFnZ2FibGUjc3RhcnREcmFnUm90YXRlXG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4qXG4qIC8vIDQ1LCAxMzUsIDIyNSwgMzE1XG4qIG1vdmVhYmxlLnRocm90dGxlRHJhZ1JvdGF0ZSA9IDkwO1xuKiBtb3ZlYWJsZS5zdGFydERyYWdSb3RhdGUgPSA0NTtcbiovXG5cbi8qKlxuICogV2hlbiB0aGUgZHJhZyBzdGFydHMsIHRoZSBkcmFnU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkRyYWdnYWJsZVxuICogQGV2ZW50IGRyYWdTdGFydFxuICogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGRyYWdTdGFydCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IGRyYWdnYWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiZHJhZ1N0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiBkcmFnZ2luZywgdGhlIGRyYWcgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkRyYWdnYWJsZVxuICogQGV2ZW50IGRyYWdcbiAqIEBwYXJhbSB7TW92ZWFibGUuRHJhZ2dhYmxlLk9uRHJhZ30gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZyBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IGRyYWdnYWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiZHJhZ1wiLCAoeyB0YXJnZXQsIHRyYW5zZm9ybSB9KSA9PiB7XG4gKiAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgZHJhZyBmaW5pc2hlcywgdGhlIGRyYWdFbmQgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkRyYWdnYWJsZVxuICogQGV2ZW50IGRyYWdFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuRHJhZ2dhYmxlLk9uRHJhZ0VuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZ0VuZCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IGRyYWdnYWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiZHJhZ0VuZFwiLCAoeyB0YXJnZXQsIGlzRHJhZyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0LCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxuLyoqXG4qIFdoZW4gdGhlIGdyb3VwIGRyYWcgc3RhcnRzLCB0aGUgYGRyYWdHcm91cFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5EcmFnZ2FibGVcbiogQGV2ZW50IGRyYWdHcm91cFN0YXJ0XG4qIEBwYXJhbSB7TW92ZWFibGUuRHJhZ2dhYmxlLk9uRHJhZ0dyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBkcmFnR3JvdXBTdGFydGAgZXZlbnRcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuKiAgICAgZHJhZ2dhYmxlOiB0cnVlXG4qIH0pO1xuKiBtb3ZlYWJsZS5vbihcImRyYWdHcm91cFN0YXJ0XCIsICh7IHRhcmdldHMgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2coXCJvbkRyYWdHcm91cFN0YXJ0XCIsIHRhcmdldHMpO1xuKiB9KTtcbiovXG5cbi8qKlxuKiBXaGVuIHRoZSBncm91cCBkcmFnLCB0aGUgYGRyYWdHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuRHJhZ2dhYmxlXG4qIEBldmVudCBkcmFnR3JvdXBcbiogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnR3JvdXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBkcmFnR3JvdXBgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiogICAgIGRyYWdnYWJsZTogdHJ1ZVxuKiB9KTtcbiogbW92ZWFibGUub24oXCJkcmFnR3JvdXBcIiwgKHsgdGFyZ2V0cywgZXZlbnRzIH0pID0+IHtcbiogICAgIGNvbnNvbGUubG9nKFwib25EcmFnR3JvdXBcIiwgdGFyZ2V0cyk7XG4qICAgICBldmVudHMuZm9yRWFjaChldiA9PiB7XG4qICAgICAgICAgIC8vIGRyYWcgZXZlbnRcbiogICAgICAgICAgY29uc29sZS5sb2coXCJvbkRyYWcgbGVmdCwgdG9wXCIsIGV2LmxlZnQsIGV2LnRvcCk7XG4qICAgICAgICAgIC8vIGV2LnRhcmdldCEuc3R5bGUubGVmdCA9IGAke2V2LmxlZnR9cHhgO1xuKiAgICAgICAgICAvLyBldi50YXJnZXQhLnN0eWxlLnRvcCA9IGAke2V2LnRvcH1weGA7XG4qICAgICAgICAgIGNvbnNvbGUubG9nKFwib25EcmFnIHRyYW5zbGF0ZVwiLCBldi5kaXN0KTtcbiogICAgICAgICAgZXYudGFyZ2V0IS5zdHlsZS50cmFuc2Zvcm0gPSBldi50cmFuc2Zvcm07KVxuKiAgICAgfSk7XG4qIH0pO1xuKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBncm91cCBkcmFnIGZpbmlzaGVzLCB0aGUgYGRyYWdHcm91cEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkRyYWdnYWJsZVxuICogQGV2ZW50IGRyYWdHcm91cEVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBkcmFnR3JvdXBFbmRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuICogICAgIGRyYWdnYWJsZTogdHJ1ZVxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImRyYWdHcm91cEVuZFwiLCAoeyB0YXJnZXRzLCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25EcmFnR3JvdXBFbmRcIiwgdGFyZ2V0cywgaXNEcmFnKTtcbiAqIH0pO1xuICovXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvaW50ZXJEaXN0KG1vdmVhYmxlLCBlKSB7XG4gIHZhciBjbGllbnRYID0gZS5jbGllbnRYLFxuICAgICAgY2xpZW50WSA9IGUuY2xpZW50WSxcbiAgICAgIGRhdGFzID0gZS5kYXRhcztcbiAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICBtb3ZlYWJsZUNsaWVudFJlY3QgPSBfYS5tb3ZlYWJsZUNsaWVudFJlY3QsXG4gICAgICByb290TWF0cml4ID0gX2Eucm9vdE1hdHJpeCxcbiAgICAgIGlzM2QgPSBfYS5pczNkLFxuICAgICAgcG9zMSA9IF9hLnBvczE7XG4gIHZhciBsZWZ0ID0gbW92ZWFibGVDbGllbnRSZWN0LmxlZnQsXG4gICAgICB0b3AgPSBtb3ZlYWJsZUNsaWVudFJlY3QudG9wO1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcblxuICB2YXIgX2IgPSBtaW51cyhjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW2NsaWVudFggLSBsZWZ0LCBjbGllbnRZIC0gdG9wXSwgbiksIHBvczEpLFxuICAgICAgcG9zWCA9IF9iWzBdLFxuICAgICAgcG9zWSA9IF9iWzFdO1xuXG4gIHZhciBfYyA9IGdldERyYWdEaXN0KHtcbiAgICBkYXRhczogZGF0YXMsXG4gICAgZGlzdFg6IHBvc1gsXG4gICAgZGlzdFk6IHBvc1lcbiAgfSksXG4gICAgICBkaXN0WCA9IF9jWzBdLFxuICAgICAgZGlzdFkgPSBfY1sxXTtcblxuICByZXR1cm4gW2Rpc3RYLCBkaXN0WV07XG59XG5cbmZ1bmN0aW9uIHNldERyYWdTdGFydChtb3ZlYWJsZSwgX2EpIHtcbiAgdmFyIGRhdGFzID0gX2EuZGF0YXM7XG4gIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgYWxsTWF0cml4ID0gX2IuYWxsTWF0cml4LFxuICAgICAgYmVmb3JlTWF0cml4ID0gX2IuYmVmb3JlTWF0cml4LFxuICAgICAgaXMzZCA9IF9iLmlzM2QsXG4gICAgICBsZWZ0ID0gX2IubGVmdCxcbiAgICAgIHRvcCA9IF9iLnRvcCxcbiAgICAgIG9yaWdpbiA9IF9iLm9yaWdpbixcbiAgICAgIG9mZnNldE1hdHJpeCA9IF9iLm9mZnNldE1hdHJpeCxcbiAgICAgIHRhcmdldE1hdHJpeCA9IF9iLnRhcmdldE1hdHJpeCxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IF9iLnRyYW5zZm9ybU9yaWdpbjtcbiAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gIGRhdGFzLmlzM2QgPSBpczNkO1xuICBkYXRhcy5tYXRyaXggPSBhbGxNYXRyaXg7XG4gIGRhdGFzLnRhcmdldE1hdHJpeCA9IHRhcmdldE1hdHJpeDtcbiAgZGF0YXMuYmVmb3JlTWF0cml4ID0gYmVmb3JlTWF0cml4O1xuICBkYXRhcy5vZmZzZXRNYXRyaXggPSBvZmZzZXRNYXRyaXg7XG4gIGRhdGFzLnRyYW5zZm9ybU9yaWdpbiA9IHRyYW5zZm9ybU9yaWdpbjtcbiAgZGF0YXMuaW52ZXJzZU1hdHJpeCA9IGludmVydChhbGxNYXRyaXgsIG4pO1xuICBkYXRhcy5pbnZlcnNlQmVmb3JlTWF0cml4ID0gaW52ZXJ0KGJlZm9yZU1hdHJpeCwgbik7XG4gIGRhdGFzLmFic29sdXRlT3JpZ2luID0gY29udmVydFBvc2l0aW9uTWF0cml4KHBsdXMoW2xlZnQsIHRvcF0sIG9yaWdpbiksIG4pO1xuICBkYXRhcy5zdGFydERyYWdCZWZvcmVEaXN0ID0gY2FsY3VsYXRlKGRhdGFzLmludmVyc2VCZWZvcmVNYXRyaXgsIGRhdGFzLmFic29sdXRlT3JpZ2luLCBuKTtcbiAgZGF0YXMuc3RhcnREcmFnRGlzdCA9IGNhbGN1bGF0ZShkYXRhcy5pbnZlcnNlTWF0cml4LCBkYXRhcy5hYnNvbHV0ZU9yaWdpbiwgbik7XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybURpcmVjdGlvbihlKSB7XG4gIHJldHVybiBjYWxjdWxhdGVNb3ZlYWJsZVBvc2l0aW9uKGUuZGF0YXMuYmVmb3JlVHJhbnNmb3JtLCBbNTAsIDUwXSwgMTAwLCAxMDApLmRpcmVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zZm9ybUV2ZW50KGV2ZW50LCBmdW5jdGlvbk5hbWUpIHtcbiAgdmFyIGRhdGFzID0gZXZlbnQuZGF0YXMsXG4gICAgICBvcmlnaW5hbERhdGFzID0gZXZlbnQub3JpZ2luYWxEYXRhcy5iZWZvcmVSZW5kZXJhYmxlO1xuICB2YXIgaW5kZXggPSBkYXRhcy50cmFuc2Zvcm1JbmRleDtcbiAgdmFyIG5leHRUcmFuc2Zvcm1zID0gb3JpZ2luYWxEYXRhcy5uZXh0VHJhbnNmb3JtcztcbiAgdmFyIG5leHRUcmFuc2Zvcm1BcHBlbmRlZEluZGV4ZXMgPSBvcmlnaW5hbERhdGFzLm5leHRUcmFuc2Zvcm1BcHBlbmRlZEluZGV4ZXM7XG4gIHZhciBuZXh0SW5kZXggPSAwO1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICBuZXh0SW5kZXggPSBuZXh0VHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgZGF0YXMudHJhbnNmb3JtSW5kZXggPSBuZXh0SW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgbmV4dEluZGV4ID0gaW5kZXggKyBuZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGkgPCBpbmRleDtcbiAgICB9KS5sZW5ndGg7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gY29udmVydFRyYW5zZm9ybUluZm8obmV4dFRyYW5zZm9ybXMsIG5leHRJbmRleCk7XG4gIHZhciB0YXJnZXRGdW5jdGlvbiA9IHJlc3VsdC50YXJnZXRGdW5jdGlvbjtcbiAgdmFyIG1hdEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZSA9PT0gXCJyb3RhdGVcIiA/IFwicm90YXRlWlwiIDogZnVuY3Rpb25OYW1lO1xuICBkYXRhcy5iZWZvcmVGdW5jdGlvblRleHRzID0gcmVzdWx0LmJlZm9yZUZ1bmN0aW9uVGV4dHM7XG4gIGRhdGFzLmFmdGVyRnVuY3Rpb25UZXh0cyA9IHJlc3VsdC5hZnRlckZ1bmN0aW9uVGV4dHM7XG4gIGRhdGFzLmJlZm9yZVRyYW5zZm9ybSA9IHJlc3VsdC5iZWZvcmVGdW5jdGlvbk1hdHJpeDtcbiAgZGF0YXMuYmVmb3JlVHJhbnNmb3JtMiA9IHJlc3VsdC5iZWZvcmVGdW5jdGlvbk1hdHJpeDI7XG4gIGRhdGFzLnRhcmdldFRhbnNmb3JtID0gcmVzdWx0LnRhcmdldEZ1bmN0aW9uTWF0cml4O1xuICBkYXRhcy5hZnRlclRyYW5zZm9ybSA9IHJlc3VsdC5hZnRlckZ1bmN0aW9uTWF0cml4O1xuICBkYXRhcy5hZnRlclRyYW5zZm9ybTIgPSByZXN1bHQuYWZ0ZXJGdW5jdGlvbk1hdHJpeDI7XG4gIGRhdGFzLnRhcmdldEFsbFRyYW5zZm9ybSA9IHJlc3VsdC5hbGxGdW5jdGlvbk1hdHJpeDtcblxuICBpZiAodGFyZ2V0RnVuY3Rpb24uZnVuY3Rpb25OYW1lID09PSBtYXRGdW5jdGlvbk5hbWUpIHtcbiAgICBkYXRhcy5hZnRlckZ1bmN0aW9uVGV4dHMuc3BsaWNlKDAsIDEpO1xuICAgIGRhdGFzLmlzQXBwZW5kVHJhbnNmb3JtID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgZGF0YXMuaXNBcHBlbmRUcmFuc2Zvcm0gPSB0cnVlO1xuICAgIG9yaWdpbmFsRGF0YXMubmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgbmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcywgdHJ1ZSksIFtuZXh0SW5kZXhdLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybUZvcm1hdChkYXRhcywgdmFsdWUsIGRpc3QpIHtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGRhdGFzLmJlZm9yZUZ1bmN0aW9uVGV4dHMuam9pbihcIiBcIiksIFwiIFwiKS5jb25jYXQoZGF0YXMuaXNBcHBlbmRUcmFuc2Zvcm0gPyBkaXN0IDogdmFsdWUsIFwiIFwiKS5jb25jYXQoZGF0YXMuYWZ0ZXJGdW5jdGlvblRleHRzLmpvaW4oXCIgXCIpKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRGlzdChfYSkge1xuICB2YXIgZGF0YXMgPSBfYS5kYXRhcyxcbiAgICAgIGRpc3RYID0gX2EuZGlzdFgsXG4gICAgICBkaXN0WSA9IF9hLmRpc3RZO1xuXG4gIHZhciBfYiA9IGdldEJlZm9yZURyYWdEaXN0KHtcbiAgICBkYXRhczogZGF0YXMsXG4gICAgZGlzdFg6IGRpc3RYLFxuICAgIGRpc3RZOiBkaXN0WVxuICB9KSxcbiAgICAgIGJ4ID0gX2JbMF0sXG4gICAgICBieSA9IF9iWzFdOyAvLyBCICogW3R4LCB0eV0gKiBBID0gW2J4LCBieV0gKiB0YXJnZXRNYXRyaXg7XG4gIC8vIFt0eCwgdHldID0gQi0xICogW2J4LCBieV0gKiB0YXJnZXRNYXRyaXggKiBBLTEgKiBbMCwgMF07XG5cblxuICB2YXIgcmVzID0gZ2V0VHJhbnNmcm9tTWF0cml4KGRhdGFzLCBmcm9tVHJhbnNsYXRpb24oW2J4LCBieV0sIDQpKTtcbiAgcmV0dXJuIGNhbGN1bGF0ZShyZXMsIGNvbnZlcnRQb3NpdGlvbk1hdHJpeChbMCwgMCwgMF0sIDQpLCA0KTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmcm9tTWF0cml4KGRhdGFzLCB0YXJnZXRNYXRyaXgsIGlzQWZ0ZXIpIHtcbiAgdmFyIGJlZm9yZVRyYW5zZm9ybSA9IGRhdGFzLmJlZm9yZVRyYW5zZm9ybSxcbiAgICAgIGFmdGVyVHJhbnNmb3JtID0gZGF0YXMuYWZ0ZXJUcmFuc2Zvcm0sXG4gICAgICBiZWZvcmVUcmFuc2Zvcm0yID0gZGF0YXMuYmVmb3JlVHJhbnNmb3JtMixcbiAgICAgIGFmdGVyVHJhbnNmb3JtMiA9IGRhdGFzLmFmdGVyVHJhbnNmb3JtMixcbiAgICAgIHRhcmdldEFsbFRyYW5zZm9ybSA9IGRhdGFzLnRhcmdldEFsbFRyYW5zZm9ybTsgLy8gQiAqIGFmdGVyVGFyZ2V0TWF0cml4ICogQSA9ICh0YXJnZXRNYXRyaXggKiB0YXJnZXRBbGxUcmFuc2Zvcm0pXG4gIC8vIGFmdGVyVGFyZ2V0TWF0cml4ID0gQi0xICogdGFyZ2V0TWF0cml4ICogdGFyZ2V0QWxsVHJhbnNmb3JtICogQS0xXG4gIC8vIG5leHRUYXJnZXRNYXRyaXggPSAodGFyZ2V0TWF0cml4ICogdGFyZ2V0QWxsVHJhbnNmb3JtKVxuXG4gIHZhciBuZXh0VGFyZ2V0TWF0cml4ID0gaXNBZnRlciA/IG11bHRpcGx5KHRhcmdldEFsbFRyYW5zZm9ybSwgdGFyZ2V0TWF0cml4LCA0KSA6IG11bHRpcGx5KHRhcmdldE1hdHJpeCwgdGFyZ2V0QWxsVHJhbnNmb3JtLCA0KTsgLy8gcmVzMSA9IEItMSAqIG5leHRUYXJnZXRNYXRyaXhcblxuICB2YXIgcmVzMSA9IG11bHRpcGx5KGludmVydChpc0FmdGVyID8gYmVmb3JlVHJhbnNmb3JtMiA6IGJlZm9yZVRyYW5zZm9ybSwgNCksIG5leHRUYXJnZXRNYXRyaXgsIDQpOyAvLyByZXMzID0gcmVzMiAqIEEtMVxuXG4gIHZhciBhZnRlclRhcmdldE1hdHJpeCA9IG11bHRpcGx5KHJlczEsIGludmVydChpc0FmdGVyID8gYWZ0ZXJUcmFuc2Zvcm0yIDogYWZ0ZXJUcmFuc2Zvcm0sIDQpLCA0KTtcbiAgcmV0dXJuIGFmdGVyVGFyZ2V0TWF0cml4O1xufVxuXG5mdW5jdGlvbiBnZXRCZWZvcmVEcmFnRGlzdChfYSkge1xuICB2YXIgZGF0YXMgPSBfYS5kYXRhcyxcbiAgICAgIGRpc3RYID0gX2EuZGlzdFgsXG4gICAgICBkaXN0WSA9IF9hLmRpc3RZOyAvLyBUVCA9IEJUXG5cbiAgdmFyIGludmVyc2VCZWZvcmVNYXRyaXggPSBkYXRhcy5pbnZlcnNlQmVmb3JlTWF0cml4LFxuICAgICAgaXMzZCA9IGRhdGFzLmlzM2QsXG4gICAgICBzdGFydERyYWdCZWZvcmVEaXN0ID0gZGF0YXMuc3RhcnREcmFnQmVmb3JlRGlzdCxcbiAgICAgIGFic29sdXRlT3JpZ2luID0gZGF0YXMuYWJzb2x1dGVPcmlnaW47XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzOyAvLyBBQlNfT1JJR0lOICogW2Rpc3RYLCBkaXN0WV0gPSBCTSAqIChPUklHSU4gKyBbdHgsIHR5XSlcbiAgLy8gQk0gLTEgKiBBQlNfT1JJR0lOICogW2Rpc3RYLCBkaXN0WV0gLSBPUklHSU4gPSBbdHgsIHR5XVxuXG4gIHJldHVybiBtaW51cyhjYWxjdWxhdGUoaW52ZXJzZUJlZm9yZU1hdHJpeCwgcGx1cyhhYnNvbHV0ZU9yaWdpbiwgW2Rpc3RYLCBkaXN0WV0pLCBuKSwgc3RhcnREcmFnQmVmb3JlRGlzdCk7XG59XG5cbmZ1bmN0aW9uIGdldERyYWdEaXN0KF9hLCBpc0JlZm9yZSkge1xuICB2YXIgZGF0YXMgPSBfYS5kYXRhcyxcbiAgICAgIGRpc3RYID0gX2EuZGlzdFgsXG4gICAgICBkaXN0WSA9IF9hLmRpc3RZO1xuICB2YXIgaW52ZXJzZUJlZm9yZU1hdHJpeCA9IGRhdGFzLmludmVyc2VCZWZvcmVNYXRyaXgsXG4gICAgICBpbnZlcnNlTWF0cml4ID0gZGF0YXMuaW52ZXJzZU1hdHJpeCxcbiAgICAgIGlzM2QgPSBkYXRhcy5pczNkLFxuICAgICAgc3RhcnREcmFnQmVmb3JlRGlzdCA9IGRhdGFzLnN0YXJ0RHJhZ0JlZm9yZURpc3QsXG4gICAgICBzdGFydERyYWdEaXN0ID0gZGF0YXMuc3RhcnREcmFnRGlzdCxcbiAgICAgIGFic29sdXRlT3JpZ2luID0gZGF0YXMuYWJzb2x1dGVPcmlnaW47XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICByZXR1cm4gbWludXMoY2FsY3VsYXRlKGlzQmVmb3JlID8gaW52ZXJzZUJlZm9yZU1hdHJpeCA6IGludmVyc2VNYXRyaXgsIHBsdXMoYWJzb2x1dGVPcmlnaW4sIFtkaXN0WCwgZGlzdFldKSwgbiksIGlzQmVmb3JlID8gc3RhcnREcmFnQmVmb3JlRGlzdCA6IHN0YXJ0RHJhZ0Rpc3QpO1xufVxuXG5mdW5jdGlvbiBnZXRJbnZlcnNlRHJhZ0Rpc3QoX2EsIGlzQmVmb3JlKSB7XG4gIHZhciBkYXRhcyA9IF9hLmRhdGFzLFxuICAgICAgZGlzdFggPSBfYS5kaXN0WCxcbiAgICAgIGRpc3RZID0gX2EuZGlzdFk7XG4gIHZhciBiZWZvcmVNYXRyaXggPSBkYXRhcy5iZWZvcmVNYXRyaXgsXG4gICAgICBtYXRyaXggPSBkYXRhcy5tYXRyaXgsXG4gICAgICBpczNkID0gZGF0YXMuaXMzZCxcbiAgICAgIHN0YXJ0RHJhZ0JlZm9yZURpc3QgPSBkYXRhcy5zdGFydERyYWdCZWZvcmVEaXN0LFxuICAgICAgc3RhcnREcmFnRGlzdCA9IGRhdGFzLnN0YXJ0RHJhZ0Rpc3QsXG4gICAgICBhYnNvbHV0ZU9yaWdpbiA9IGRhdGFzLmFic29sdXRlT3JpZ2luO1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgcmV0dXJuIG1pbnVzKGNhbGN1bGF0ZShpc0JlZm9yZSA/IGJlZm9yZU1hdHJpeCA6IG1hdHJpeCwgcGx1cyhpc0JlZm9yZSA/IHN0YXJ0RHJhZ0JlZm9yZURpc3QgOiBzdGFydERyYWdEaXN0LCBbZGlzdFgsIGRpc3RZXSksIG4pLCBhYnNvbHV0ZU9yaWdpbik7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zZm9ybU9yaWdpbih0cmFuc2Zvcm1PcmlnaW4sIHdpZHRoLCBoZWlnaHQsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgcHJldk9yaWdpbikge1xuICBpZiAocHJldldpZHRoID09PSB2b2lkIDApIHtcbiAgICBwcmV2V2lkdGggPSB3aWR0aDtcbiAgfVxuXG4gIGlmIChwcmV2SGVpZ2h0ID09PSB2b2lkIDApIHtcbiAgICBwcmV2SGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgaWYgKHByZXZPcmlnaW4gPT09IHZvaWQgMCkge1xuICAgIHByZXZPcmlnaW4gPSBbMCwgMF07XG4gIH1cblxuICBpZiAoIXRyYW5zZm9ybU9yaWdpbikge1xuICAgIHJldHVybiBwcmV2T3JpZ2luO1xuICB9XG5cbiAgcmV0dXJuIHRyYW5zZm9ybU9yaWdpbi5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgIHZhciBfYSA9IHNwbGl0VW5pdChwb3MpLFxuICAgICAgICB2YWx1ZSA9IF9hLnZhbHVlLFxuICAgICAgICB1bml0ID0gX2EudW5pdDtcblxuICAgIHZhciBwcmV2U2l6ZSA9IGkgPyBwcmV2SGVpZ2h0IDogcHJldldpZHRoO1xuICAgIHZhciBzaXplID0gaSA/IGhlaWdodCA6IHdpZHRoO1xuXG4gICAgaWYgKHBvcyA9PT0gXCIlXCIgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICAvLyBubyB2YWx1ZSBidXQgJVxuICAgICAgdmFyIG1lYXN1cmVSYXRpbyA9IHByZXZTaXplID8gcHJldk9yaWdpbltpXSAvIHByZXZTaXplIDogMDtcbiAgICAgIHJldHVybiBzaXplICogbWVhc3VyZVJhdGlvO1xuICAgIH0gZWxzZSBpZiAodW5pdCAhPT0gXCIlXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZSAqIHZhbHVlIC8gMTAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9zSW5kZXhlc0J5RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gIGlmIChkaXJlY3Rpb25bMV0gPj0gMCkge1xuICAgIGlmIChkaXJlY3Rpb25bMF0gPj0gMCkge1xuICAgICAgaW5kZXhlcy5wdXNoKDMpO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb25bMF0gPD0gMCkge1xuICAgICAgaW5kZXhlcy5wdXNoKDIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJlY3Rpb25bMV0gPD0gMCkge1xuICAgIGlmIChkaXJlY3Rpb25bMF0gPj0gMCkge1xuICAgICAgaW5kZXhlcy5wdXNoKDEpO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb25bMF0gPD0gMCkge1xuICAgICAgaW5kZXhlcy5wdXNoKDApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleGVzO1xufVxuXG5mdW5jdGlvbiBnZXRQb3Nlc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXJlY3Rpb24pIHtcbiAgLypcbiAgWy0xLCAtMV0ocG9zMSkgICAgICAgWzAsIC0xXShwb3MxLHBvczIpICAgICAgIFsxLCAtMV0ocG9zMilcbiAgWy0xLCAwXShwb3MxLCBwb3MzKSAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxLCAwXShwb3MyLCBwb3M0KVxuICBbLTEsIDFdKHBvczMpICAgICAgICBbMCwgMV0ocG9zMywgcG9zNCkgICAgICAgWzEsIDFdKHBvczQpXG4gICovXG4gIHJldHVybiBnZXRQb3NJbmRleGVzQnlEaXJlY3Rpb24oZGlyZWN0aW9uKS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHBvc2VzW2luZGV4XTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXJlY3Rpb24pIHtcbiAgLypcbiAgWy0xLCAtMV0ocG9zMSkgICAgICAgWzAsIC0xXShwb3MxLHBvczIpICAgICAgIFsxLCAtMV0ocG9zMilcbiAgWy0xLCAwXShwb3MxLCBwb3MzKSAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxLCAwXShwb3MyLCBwb3M0KVxuICBbLTEsIDFdKHBvczMpICAgICAgICBbMCwgMV0ocG9zMywgcG9zNCkgICAgICAgWzEsIDFdKHBvczQpXG4gICovXG4gIHZhciBuZXh0UG9zZXMgPSBnZXRQb3Nlc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXJlY3Rpb24pO1xuICByZXR1cm4gW2F2ZXJhZ2UobmV4dFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvc1swXTtcbiAgfSkpLCBhdmVyYWdlKG5leHRQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3NbMV07XG4gIH0pKV07XG59XG5cbmZ1bmN0aW9uIGdldERpc3Qoc3RhcnRQb3MsIG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgbiwgZml4ZWREaXJlY3Rpb24pIHtcbiAgdmFyIHBvc2VzID0gY2FsY3VsYXRlUG9zZXMobWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuKTtcbiAgdmFyIGZpeGVkUG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGZpeGVkRGlyZWN0aW9uKTtcbiAgdmFyIGRpc3RYID0gc3RhcnRQb3NbMF0gLSBmaXhlZFBvc1swXTtcbiAgdmFyIGRpc3RZID0gc3RhcnRQb3NbMV0gLSBmaXhlZFBvc1sxXTtcbiAgcmV0dXJuIFtkaXN0WCwgZGlzdFldO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0TWF0cml4KG9mZnNldE1hdHJpeCwgdGFyZ2V0TWF0cml4LCBvcmlnaW4sIG4pIHtcbiAgcmV0dXJuIG11bHRpcGx5KG9mZnNldE1hdHJpeCwgZ2V0QWJzb2x1dGVNYXRyaXgodGFyZ2V0TWF0cml4LCBuLCBvcmlnaW4pLCBuKTtcbn1cblxuZnVuY3Rpb24gZ2V0TmV4dFRyYW5zZm9ybU1hdHJpeChzdGF0ZSwgZGF0YXMsIHRyYW5zZm9ybSkge1xuICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luLFxuICAgICAgb2Zmc2V0TWF0cml4ID0gc3RhdGUub2Zmc2V0TWF0cml4LFxuICAgICAgaXMzZCA9IHN0YXRlLmlzM2Q7XG4gIHZhciBiZWZvcmVUcmFuc2Zvcm0gPSBkYXRhcy5iZWZvcmVUcmFuc2Zvcm0sXG4gICAgICBhZnRlclRyYW5zZm9ybSA9IGRhdGFzLmFmdGVyVHJhbnNmb3JtO1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgdmFyIHRhcmdldFRyYW5zZm9ybSA9IHBhcnNlTWF0KFt0cmFuc2Zvcm1dKTtcbiAgcmV0dXJuIGdldE5leHRNYXRyaXgob2Zmc2V0TWF0cml4LCBjb252ZXJ0RGltZW5zaW9uKG11bHRpcGx5KG11bHRpcGx5KGJlZm9yZVRyYW5zZm9ybSwgdGFyZ2V0VHJhbnNmb3JtLCA0KSwgYWZ0ZXJUcmFuc2Zvcm0sIDQpLCA0LCBuKSwgdHJhbnNmb3JtT3JpZ2luLCBuKTtcbn1cblxuZnVuY3Rpb24gc2NhbGVNYXRyaXgoc3RhdGUsIHNjYWxlKSB7XG4gIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICBvZmZzZXRNYXRyaXggPSBzdGF0ZS5vZmZzZXRNYXRyaXgsXG4gICAgICBpczNkID0gc3RhdGUuaXMzZCxcbiAgICAgIHRhcmdldE1hdHJpeCA9IHN0YXRlLnRhcmdldE1hdHJpeDtcbiAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gIHJldHVybiBnZXROZXh0TWF0cml4KG9mZnNldE1hdHJpeCwgbXVsdGlwbHkodGFyZ2V0TWF0cml4LCBjcmVhdGVTY2FsZU1hdHJpeChzY2FsZSwgbiksIG4pLCB0cmFuc2Zvcm1PcmlnaW4sIG4pO1xufVxuXG5mdW5jdGlvbiBmaWxsVHJhbnNmb3JtU3RhcnRFdmVudChlKSB7XG4gIHZhciBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzLmJlZm9yZVJlbmRlcmFibGU7XG4gIHJldHVybiB7XG4gICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAodHJhbnNmb3JtLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luYWxEYXRhcy5zdGFydFRyYW5zZm9ybXMgPSBpc0FycmF5KHRyYW5zZm9ybSkgPyB0cmFuc2Zvcm0gOiBzcGxpdFNwYWNlKHRyYW5zZm9ybSk7XG4gICAgICBzZXRUcmFuc2Zvcm1JbmRleChlLCBpbmRleCk7XG4gICAgfSxcbiAgICBzZXRUcmFuc2Zvcm1JbmRleDogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBzZXRUcmFuc2Zvcm1JbmRleChlLCBpbmRleCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzZXREZWZhdWx0VHJhbnNmb3JtSW5kZXgoZSwgcHJvcGVydHkpIHtcbiAgdmFyIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXMuYmVmb3JlUmVuZGVyYWJsZTtcbiAgdmFyIHN0YXJ0VHJhbnNmb3JtcyA9IG9yaWdpbmFsRGF0YXMuc3RhcnRUcmFuc2Zvcm1zO1xuICBzZXRUcmFuc2Zvcm1JbmRleChlLCBmaW5kSW5kZXgoc3RhcnRUcmFuc2Zvcm1zLCBmdW5jdGlvbiAoZnVuYykge1xuICAgIHJldHVybiBmdW5jLmluZGV4T2YoXCJcIi5jb25jYXQocHJvcGVydHksIFwiKFwiKSkgPT09IDA7XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtSW5kZXgoZSwgaW5kZXgpIHtcbiAgdmFyIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXMuYmVmb3JlUmVuZGVyYWJsZTtcbiAgdmFyIGRhdGFzID0gZS5kYXRhcztcbiAgZGF0YXMudHJhbnNmb3JtSW5kZXggPSBpbmRleDtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRyYW5zZm9ybSA9IG9yaWdpbmFsRGF0YXMuc3RhcnRUcmFuc2Zvcm1zW2luZGV4XTtcblxuICBpZiAoIXRyYW5zZm9ybSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbmZvID0gcGFyc2UoW3RyYW5zZm9ybV0pO1xuICBkYXRhcy5zdGFydFZhbHVlID0gaW5mb1swXS5mdW5jdGlvblZhbHVlO1xufVxuXG5mdW5jdGlvbiBmaWxsT3JpZ2luYWxUcmFuc2Zvcm0oZSwgdHJhbnNmb3JtKSB7XG4gIHZhciBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzLmJlZm9yZVJlbmRlcmFibGU7XG4gIG9yaWdpbmFsRGF0YXMubmV4dFRyYW5zZm9ybXMgPSBzcGxpdFNwYWNlKHRyYW5zZm9ybSk7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRUcmFuc2Zvcm1UZXh0KGUpIHtcbiAgdmFyIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXMuYmVmb3JlUmVuZGVyYWJsZTtcbiAgcmV0dXJuIG9yaWdpbmFsRGF0YXMubmV4dFRyYW5zZm9ybXMuam9pbihcIiBcIik7XG59XG5cbmZ1bmN0aW9uIGZpbGxUcmFuc2Zvcm1FdmVudChtb3ZlYWJsZSwgbmV4dFRyYW5zZm9ybSwgZGVsdGEsIGlzUGluY2gsIGUpIHtcbiAgZmlsbE9yaWdpbmFsVHJhbnNmb3JtKGUsIG5leHRUcmFuc2Zvcm0pO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogbmV4dFRyYW5zZm9ybSxcbiAgICBkcmFnOiBEcmFnZ2FibGUuZHJhZyhtb3ZlYWJsZSwgc2V0Q3VzdG9tRHJhZyhlLCBtb3ZlYWJsZS5zdGF0ZSwgZGVsdGEsIGlzUGluY2gsIGZhbHNlKSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlRGlzdChtb3ZlYWJsZSwgdHJhbnNmb3JtLCBmaXhlZERpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgZGF0YXMpIHtcbiAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gIHZhciBsZWZ0ID0gc3RhdGUubGVmdCxcbiAgICAgIHRvcCA9IHN0YXRlLnRvcDtcbiAgdmFyIGdyb3VwYWJsZSA9IG1vdmVhYmxlLnByb3BzLmdyb3VwYWJsZTtcbiAgdmFyIG5leHRNYXRyaXggPSBnZXROZXh0VHJhbnNmb3JtTWF0cml4KG1vdmVhYmxlLnN0YXRlLCBkYXRhcywgdHJhbnNmb3JtKTtcbiAgdmFyIGdyb3VwTGVmdCA9IGdyb3VwYWJsZSA/IGxlZnQgOiAwO1xuICB2YXIgZ3JvdXBUb3AgPSBncm91cGFibGUgPyB0b3AgOiAwO1xuICB2YXIgbmV4dEZpeGVkUG9zaXRpb24gPSBnZXREaXJlY3Rpb25PZmZzZXQobW92ZWFibGUsIGZpeGVkRGlyZWN0aW9uLCBuZXh0TWF0cml4KTtcbiAgdmFyIGRpc3QgPSBtaW51cyhmaXhlZFBvc2l0aW9uLCBuZXh0Rml4ZWRQb3NpdGlvbik7XG4gIHJldHVybiBtaW51cyhkaXN0LCBbZ3JvdXBMZWZ0LCBncm91cFRvcF0pO1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZURpc3QobW92ZWFibGUsIHNjYWxlRGlzdCwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGRhdGFzKSB7XG4gIHZhciBkaXN0ID0gZ2V0VHJhbnNsYXRlRGlzdChtb3ZlYWJsZSwgXCJzY2FsZShcIi5jb25jYXQoc2NhbGVEaXN0LmpvaW4oXCIsIFwiKSwgXCIpXCIpLCBmaXhlZERpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgZGF0YXMpO1xuICByZXR1cm4gZGlzdDtcbn1cblxuZnVuY3Rpb24gZ2V0T3JpZ2luRGlyZWN0aW9uKG1vdmVhYmxlKSB7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgd2lkdGggPSBfYS53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9hLmhlaWdodCxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IF9hLnRyYW5zZm9ybU9yaWdpbjtcbiAgcmV0dXJuIFstMSArIHRyYW5zZm9ybU9yaWdpblswXSAvICh3aWR0aCAvIDIpLCAtMSArIHRyYW5zZm9ybU9yaWdpblsxXSAvIChoZWlnaHQgLyAyKV07XG59XG5cbmZ1bmN0aW9uIGdldERpcmVjdGlvbk9mZnNldChtb3ZlYWJsZSwgZGlyZWN0aW9uLCBuZXh0TWF0cml4KSB7XG4gIGlmIChuZXh0TWF0cml4ID09PSB2b2lkIDApIHtcbiAgICBuZXh0TWF0cml4ID0gbW92ZWFibGUuc3RhdGUuYWxsTWF0cml4O1xuICB9XG5cbiAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0LFxuICAgICAgaXMzZCA9IF9hLmlzM2Q7XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICB2YXIgbmV4dEZpeGVkT2Zmc2V0ID0gW3dpZHRoIC8gMiAqICgxICsgZGlyZWN0aW9uWzBdKSwgaGVpZ2h0IC8gMiAqICgxICsgZGlyZWN0aW9uWzFdKV07XG4gIHJldHVybiBjYWxjdWxhdGVQb3NpdGlvbihuZXh0TWF0cml4LCBuZXh0Rml4ZWRPZmZzZXQsIG4pO1xufVxuXG5mdW5jdGlvbiBnZXRSb3RhdGVEaXN0KG1vdmVhYmxlLCByb3RhdGVEaXN0LCBmaXhlZFBvc2l0aW9uLCBkYXRhcykge1xuICB2YXIgZml4ZWREaXJlY3Rpb24gPSBnZXRPcmlnaW5EaXJlY3Rpb24obW92ZWFibGUpO1xuICByZXR1cm4gZ2V0VHJhbnNsYXRlRGlzdChtb3ZlYWJsZSwgXCJyb3RhdGUoXCIuY29uY2F0KHJvdGF0ZURpc3QsIFwiZGVnKVwiKSwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGRhdGFzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplRGlzdChtb3ZlYWJsZSwgd2lkdGgsIGhlaWdodCwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIHRyYW5zZm9ybU9yaWdpbikge1xuICB2YXIgZ3JvdXBhYmxlID0gbW92ZWFibGUucHJvcHMuZ3JvdXBhYmxlO1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIHByZXZPcmlnaW4gPSBfYS50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICB0YXJnZXRNYXRyaXggPSBfYS50YXJnZXRNYXRyaXgsXG4gICAgICBvZmZzZXRNYXRyaXggPSBfYS5vZmZzZXRNYXRyaXgsXG4gICAgICBpczNkID0gX2EuaXMzZCxcbiAgICAgIHByZXZXaWR0aCA9IF9hLndpZHRoLFxuICAgICAgcHJldkhlaWdodCA9IF9hLmhlaWdodCxcbiAgICAgIGxlZnQgPSBfYS5sZWZ0LFxuICAgICAgdG9wID0gX2EudG9wO1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgdmFyIG5leHRPcmlnaW4gPSBjYWxjdWxhdGVUcmFuc2Zvcm1PcmlnaW4odHJhbnNmb3JtT3JpZ2luLCB3aWR0aCwgaGVpZ2h0LCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIHByZXZPcmlnaW4pO1xuICB2YXIgZ3JvdXBMZWZ0ID0gZ3JvdXBhYmxlID8gbGVmdCA6IDA7XG4gIHZhciBncm91cFRvcCA9IGdyb3VwYWJsZSA/IHRvcCA6IDA7XG4gIHZhciBuZXh0TWF0cml4ID0gZ2V0TmV4dE1hdHJpeChvZmZzZXRNYXRyaXgsIHRhcmdldE1hdHJpeCwgbmV4dE9yaWdpbiwgbik7XG4gIHZhciBkaXN0ID0gZ2V0RGlzdChmaXhlZFBvc2l0aW9uLCBuZXh0TWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuLCBmaXhlZERpcmVjdGlvbik7XG4gIHJldHVybiBtaW51cyhkaXN0LCBbZ3JvdXBMZWZ0LCBncm91cFRvcF0pO1xufVxuXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVBvc2l0aW9uKG1vdmVhYmxlLCBkaXJlY3Rpb24pIHtcbiAgcmV0dXJuIGdldFBvc0J5RGlyZWN0aW9uKGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKSwgZGlyZWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbHkyKHBvczEsIHBvczIpIHtcbiAgcmV0dXJuIFtwb3MxWzBdICogcG9zMlswXSwgcG9zMVsxXSAqIHBvczJbMV1dO1xufVxuXG5mdW5jdGlvbiBwcmVmaXgoKSB7XG4gIHZhciBjbGFzc05hbWVzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBjbGFzc05hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICByZXR1cm4gcHJlZml4TmFtZXMuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtQUkVGSVhdLCBjbGFzc05hbWVzLCBmYWxzZSkpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U3luYyhmbikge1xuICBmbigpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1NYXRyaXgodHJhbnNmb3JtKSB7XG4gIGlmICghdHJhbnNmb3JtIHx8IHRyYW5zZm9ybSA9PT0gXCJub25lXCIpIHtcbiAgICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KHRyYW5zZm9ybSkpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlTWF0KHRyYW5zZm9ybSk7XG59XG5cbmZ1bmN0aW9uIGdldEFic29sdXRlTWF0cml4KG1hdHJpeCwgbiwgb3JpZ2luKSB7XG4gIHJldHVybiBtdWx0aXBsaWVzKG4sIGNyZWF0ZU9yaWdpbk1hdHJpeChvcmlnaW4sIG4pLCBtYXRyaXgsIGNyZWF0ZU9yaWdpbk1hdHJpeChvcmlnaW4ubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIC1hO1xuICB9KSwgbikpO1xufVxuXG5mdW5jdGlvbiBtZWFzdXJlU1ZHU2l6ZShlbCwgdW5pdCwgaXNIb3Jpem9udGFsKSB7XG4gIGlmICh1bml0ID09PSBcIiVcIikge1xuICAgIHZhciB2aWV3Qm94ID0gZ2V0U1ZHVmlld0JveChlbC5vd25lclNWR0VsZW1lbnQpO1xuICAgIHJldHVybiB2aWV3Qm94W2lzSG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdIC8gMTAwO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbmZ1bmN0aW9uIGdldEJlZm9yZVRyYW5zZm9ybU9yaWdpbihlbCkge1xuICB2YXIgcmVsYXRpdmVPcmlnaW4gPSBnZXRUcmFuc2Zvcm1PcmlnaW4oZ2V0Q29tcHV0ZWRTdHlsZShlbCwgXCI6YmVmb3JlXCIpKTtcbiAgcmV0dXJuIHJlbGF0aXZlT3JpZ2luLm1hcChmdW5jdGlvbiAobywgaSkge1xuICAgIHZhciBfYSA9IHNwbGl0VW5pdChvKSxcbiAgICAgICAgdmFsdWUgPSBfYS52YWx1ZSxcbiAgICAgICAgdW5pdCA9IF9hLnVuaXQ7XG5cbiAgICByZXR1cm4gdmFsdWUgKiBtZWFzdXJlU1ZHU2l6ZShlbCwgdW5pdCwgaSA9PT0gMCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1PcmlnaW4oc3R5bGUpIHtcbiAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLnRyYW5zZm9ybU9yaWdpbjtcbiAgcmV0dXJuIHRyYW5zZm9ybU9yaWdpbiA/IHRyYW5zZm9ybU9yaWdpbi5zcGxpdChcIiBcIikgOiBbXCIwXCIsIFwiMFwiXTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFRyYW5zZm9ybSh0YXJnZXQsIGNvbXB1dGVkU3R5bGUpIHtcbiAgaWYgKGNvbXB1dGVkU3R5bGUgPT09IHZvaWQgMCkge1xuICAgIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gIH1cblxuICB2YXIgY29tcHV0ZWRUcmFuc2Zvcm0gPSBjb21wdXRlZFN0eWxlLnRyYW5zZm9ybTtcblxuICBpZiAoY29tcHV0ZWRUcmFuc2Zvcm0gJiYgY29tcHV0ZWRUcmFuc2Zvcm0gIT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkU3R5bGUudHJhbnNmb3JtO1xuICB9XG5cbiAgaWYgKFwidHJhbnNmb3JtXCIgaW4gdGFyZ2V0KSB7XG4gICAgdmFyIGxpc3QgPSB0YXJnZXQudHJhbnNmb3JtO1xuICAgIHZhciBiYXNlVmFsID0gbGlzdC5iYXNlVmFsO1xuXG4gICAgaWYgKCFiYXNlVmFsKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gYmFzZVZhbC5sZW5ndGg7XG5cbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgdmFyIG1hdHJpeGVzID0gW107XG5cbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YXIgbWF0cml4ID0gYmFzZVZhbFtpXS5tYXRyaXg7XG4gICAgICBtYXRyaXhlcy5wdXNoKFwibWF0cml4KFwiLmNvbmNhdChbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIl0ubWFwKGZ1bmN0aW9uIChjaHIpIHtcbiAgICAgICAgcmV0dXJuIG1hdHJpeFtjaHJdO1xuICAgICAgfSkuam9pbihcIiwgXCIpLCBcIilcIikpO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBfbG9vcF8xKGkpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRyaXhlcy5qb2luKFwiIFwiKTtcbiAgfVxuXG4gIHJldHVybiBcIlwiO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRJbmZvKGVsLCBsYXN0UGFyZW50LCBpc1BhcmVudCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIHZhciB0YXJnZXQgPSAhZWwgfHwgaXNQYXJlbnQgPyBlbCA6IGVsLnBhcmVudEVsZW1lbnQ7XG4gIHZhciBpc0VuZCA9IGVsID09PSBsYXN0UGFyZW50IHx8IHRhcmdldCA9PT0gbGFzdFBhcmVudDtcbiAgdmFyIHBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXG4gIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBib2R5KSB7XG4gICAgaWYgKGxhc3RQYXJlbnQgPT09IHRhcmdldCkge1xuICAgICAgaXNFbmQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgICB2YXIgdGFnTmFtZSA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHRyYW5zZm9ybSA9IGdldEVsZW1lbnRUcmFuc2Zvcm0odGFyZ2V0LCBzdHlsZSk7XG4gICAgcG9zaXRpb24gPSBzdHlsZS5wb3NpdGlvbjtcblxuICAgIGlmICh0YWdOYW1lID09PSBcInN2Z1wiIHx8IHBvc2l0aW9uICE9PSBcInN0YXRpY1wiIHx8IHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0gIT09IFwibm9uZVwiKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICBwb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNTdGF0aWM6IHBvc2l0aW9uID09PSBcInN0YXRpY1wiLFxuICAgIGlzRW5kOiBpc0VuZCB8fCAhdGFyZ2V0IHx8IHRhcmdldCA9PT0gYm9keSxcbiAgICBvZmZzZXRQYXJlbnQ6IHRhcmdldCB8fCBib2R5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldFBvc0luZm8oZWwsIHN0eWxlKSB7XG4gIHZhciBfYTtcblxuICB2YXIgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIG9mZnNldExlZnQgPSBlbC5vZmZzZXRMZWZ0O1xuICB2YXIgb2Zmc2V0VG9wID0gZWwub2Zmc2V0VG9wOyAvLyBzdmdcblxuICB2YXIgaXNTVkcgPSBpc1VuZGVmaW5lZChvZmZzZXRMZWZ0KTtcbiAgdmFyIGhhc09mZnNldCA9ICFpc1NWRztcbiAgdmFyIG9yaWdpbjtcbiAgdmFyIHRhcmdldE9yaWdpbjsgLy8gaW5uZXIgc3ZnIGVsZW1lbnRcblxuICBpZiAoIWhhc09mZnNldCAmJiB0YWdOYW1lICE9PSBcInN2Z1wiKSB7XG4gICAgb3JpZ2luID0gSVNfV0VCS0lUNjA1ID8gZ2V0QmVmb3JlVHJhbnNmb3JtT3JpZ2luKGVsKSA6IGdldFRyYW5zZm9ybU9yaWdpbihzdHlsZSkubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBvcyk7XG4gICAgfSk7XG4gICAgdGFyZ2V0T3JpZ2luID0gb3JpZ2luLnNsaWNlKCk7XG4gICAgaGFzT2Zmc2V0ID0gdHJ1ZTtcbiAgICBfYSA9IGdldFNWR0dyYXBoaWNzT2Zmc2V0KGVsLCBvcmlnaW4pLCBvZmZzZXRMZWZ0ID0gX2FbMF0sIG9mZnNldFRvcCA9IF9hWzFdLCBvcmlnaW5bMF0gPSBfYVsyXSwgb3JpZ2luWzFdID0gX2FbM107XG4gIH0gZWxzZSB7XG4gICAgb3JpZ2luID0gZ2V0VHJhbnNmb3JtT3JpZ2luKHN0eWxlKS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocG9zKTtcbiAgICB9KTtcbiAgICB0YXJnZXRPcmlnaW4gPSBvcmlnaW4uc2xpY2UoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICBpc1NWRzogaXNTVkcsXG4gICAgaGFzT2Zmc2V0OiBoYXNPZmZzZXQsXG4gICAgb2Zmc2V0OiBbb2Zmc2V0TGVmdCB8fCAwLCBvZmZzZXRUb3AgfHwgMF0sXG4gICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgdGFyZ2V0T3JpZ2luOiB0YXJnZXRPcmlnaW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm9keU9mZnNldChlbCwgaXNTVkcsIHN0eWxlKSB7XG4gIGlmIChzdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgfVxuXG4gIHZhciBib2R5U3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpO1xuICB2YXIgYm9keVBvc2l0aW9uID0gYm9keVN0eWxlLnBvc2l0aW9uO1xuXG4gIGlmICghaXNTVkcgJiYgKCFib2R5UG9zaXRpb24gfHwgYm9keVBvc2l0aW9uID09PSBcInN0YXRpY1wiKSkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cblxuICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlSW50KGJvZHlTdHlsZS5tYXJnaW5MZWZ0LCAxMCk7XG4gIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUludChib2R5U3R5bGUubWFyZ2luVG9wLCAxMCk7XG5cbiAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIpIHtcbiAgICBpZiAoc3R5bGUudG9wICE9PSBcImF1dG9cIiB8fCBzdHlsZS5ib3R0b20gIT09IFwiYXV0b1wiKSB7XG4gICAgICBtYXJnaW5Ub3AgPSAwO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS5sZWZ0ICE9PSBcImF1dG9cIiB8fCBzdHlsZS5yaWdodCAhPT0gXCJhdXRvXCIpIHtcbiAgICAgIG1hcmdpbkxlZnQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbWFyZ2luTGVmdCwgbWFyZ2luVG9wXTtcbn1cblxuZnVuY3Rpb24gY29udmVydDNETWF0cml4ZXMobWF0cml4ZXMpIHtcbiAgbWF0cml4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgIHZhciBtYXRyaXggPSBpbmZvLm1hdHJpeDtcblxuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIGluZm8ubWF0cml4ID0gY29udmVydERpbWVuc2lvbihtYXRyaXgsIDMsIDQpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEJvZHlTY3JvbGxQb3MoKSB7XG4gIHJldHVybiBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wXTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25GaXhlZEluZm8oZWwpIHtcbiAgdmFyIGZpeGVkQ29udGFpbmVyID0gZWwucGFyZW50RWxlbWVudDtcbiAgdmFyIGhhc1RyYW5zZm9ybSA9IGZhbHNlO1xuXG4gIHdoaWxlIChmaXhlZENvbnRhaW5lcikge1xuICAgIHZhciB0cmFuc2Zvcm0gPSBnZXRDb21wdXRlZFN0eWxlKGZpeGVkQ29udGFpbmVyKS50cmFuc2Zvcm07XG5cbiAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gXCJub25lXCIpIHtcbiAgICAgIGhhc1RyYW5zZm9ybSA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoZml4ZWRDb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZpeGVkQ29udGFpbmVyID0gZml4ZWRDb250YWluZXIucGFyZW50RWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZml4ZWRDb250YWluZXI6IGZpeGVkQ29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHksXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TWF0cml4U3RhY2tJbmZvKHRhcmdldCwgY29udGFpbmVyLCBjaGVja0NvbnRhaW5lcikge1xuICB2YXIgZWwgPSB0YXJnZXQ7XG4gIHZhciBtYXRyaXhlcyA9IFtdO1xuICB2YXIgcmVxdWVzdEVuZCA9ICFjaGVja0NvbnRhaW5lciAmJiB0YXJnZXQgPT09IGNvbnRhaW5lciB8fCB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHk7XG4gIHZhciBpc0VuZCA9IHJlcXVlc3RFbmQ7XG4gIHZhciBpczNkID0gZmFsc2U7XG4gIHZhciBuID0gMztcbiAgdmFyIHRyYW5zZm9ybU9yaWdpbjtcbiAgdmFyIHRhcmdldFRyYW5zZm9ybU9yaWdpbjtcbiAgdmFyIHRhcmdldE1hdHJpeDtcbiAgdmFyIGhhc0ZpeGVkID0gZmFsc2U7XG4gIHZhciBvZmZzZXRDb250YWluZXIgPSBnZXRPZmZzZXRJbmZvKGNvbnRhaW5lciwgY29udGFpbmVyLCB0cnVlKS5vZmZzZXRQYXJlbnQ7XG5cbiAgd2hpbGUgKGVsICYmICFpc0VuZCkge1xuICAgIGlzRW5kID0gcmVxdWVzdEVuZDtcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICB2YXIgcG9zaXRpb24gPSBzdHlsZS5wb3NpdGlvbjtcbiAgICB2YXIgdHJhbnNmb3JtID0gZ2V0RWxlbWVudFRyYW5zZm9ybShlbCwgc3R5bGUpO1xuICAgIHZhciBtYXRyaXggPSBjb252ZXJ0Q1NTdG9NYXRyaXgoZ2V0VHJhbnNmb3JtTWF0cml4KHRyYW5zZm9ybSkpO1xuICAgIHZhciBpc0ZpeGVkID0gcG9zaXRpb24gPT09IFwiZml4ZWRcIjtcbiAgICB2YXIgZml4ZWRJbmZvID0ge1xuICAgICAgaGFzVHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgIGZpeGVkQ29udGFpbmVyOiBudWxsXG4gICAgfTtcblxuICAgIGlmIChpc0ZpeGVkKSB7XG4gICAgICBoYXNGaXhlZCA9IHRydWU7XG4gICAgICBmaXhlZEluZm8gPSBnZXRQb3NpdGlvbkZpeGVkSW5mbyhlbCk7XG4gICAgICBvZmZzZXRDb250YWluZXIgPSBmaXhlZEluZm8uZml4ZWRDb250YWluZXI7XG4gICAgfSAvLyBjb252ZXJ0IDMgdG8gNFxuXG5cbiAgICB2YXIgbGVuZ3RoID0gbWF0cml4Lmxlbmd0aDtcblxuICAgIGlmICghaXMzZCAmJiBsZW5ndGggPT09IDE2KSB7XG4gICAgICBpczNkID0gdHJ1ZTtcbiAgICAgIG4gPSA0O1xuICAgICAgY29udmVydDNETWF0cml4ZXMobWF0cml4ZXMpO1xuXG4gICAgICBpZiAodGFyZ2V0TWF0cml4KSB7XG4gICAgICAgIHRhcmdldE1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24odGFyZ2V0TWF0cml4LCAzLCA0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXMzZCAmJiBsZW5ndGggPT09IDkpIHtcbiAgICAgIG1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24obWF0cml4LCAzLCA0KTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSBnZXRPZmZzZXRQb3NJbmZvKGVsLCBzdHlsZSksXG4gICAgICAgIHRhZ05hbWUgPSBfYS50YWdOYW1lLFxuICAgICAgICBoYXNPZmZzZXQgPSBfYS5oYXNPZmZzZXQsXG4gICAgICAgIGlzU1ZHID0gX2EuaXNTVkcsXG4gICAgICAgIG9yaWdpbiA9IF9hLm9yaWdpbixcbiAgICAgICAgdGFyZ2V0T3JpZ2luID0gX2EudGFyZ2V0T3JpZ2luLFxuICAgICAgICBvZmZzZXRQb3MgPSBfYS5vZmZzZXQ7XG5cbiAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldFBvc1swXSxcbiAgICAgICAgb2Zmc2V0VG9wID0gb2Zmc2V0UG9zWzFdO1xuXG4gICAgaWYgKHRhZ05hbWUgPT09IFwic3ZnXCIgJiYgdGFyZ2V0TWF0cml4KSB7XG4gICAgICAvLyBzY2FsZSBtYXRyaXggZm9yIHN2ZydzIFNWR0VsZW1lbnRzLlxuICAgICAgbWF0cml4ZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidGFyZ2V0XCIsXG4gICAgICAgIHRhcmdldDogZWwsXG4gICAgICAgIG1hdHJpeDogZ2V0U1ZHTWF0cml4KGVsLCBuKVxuICAgICAgfSk7XG4gICAgICBtYXRyaXhlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJvZmZzZXRcIixcbiAgICAgICAgdGFyZ2V0OiBlbCxcbiAgICAgICAgbWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSBcImdcIiAmJiB0YXJnZXQgIT09IGVsKSB7XG4gICAgICBvZmZzZXRMZWZ0ID0gMDtcbiAgICAgIG9mZnNldFRvcCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldFBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgaXNPZmZzZXRFbmQgPSBmYWxzZTtcbiAgICB2YXIgaXNTdGF0aWMgPSBmYWxzZTtcblxuICAgIGlmIChpc0ZpeGVkKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBmaXhlZEluZm8uZml4ZWRDb250YWluZXI7XG4gICAgICBpc09mZnNldEVuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvZmZzZXRJbmZvID0gZ2V0T2Zmc2V0SW5mbyhlbCwgY29udGFpbmVyKTtcbiAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldEluZm8ub2Zmc2V0UGFyZW50O1xuICAgICAgaXNPZmZzZXRFbmQgPSBvZmZzZXRJbmZvLmlzRW5kO1xuICAgICAgaXNTdGF0aWMgPSBvZmZzZXRJbmZvLmlzU3RhdGljO1xuICAgIH1cblxuICAgIGlmIChJU19XRUJLSVQgJiYgaGFzT2Zmc2V0ICYmICFpc1NWRyAmJiBpc1N0YXRpYyAmJiAocG9zaXRpb24gPT09IFwicmVsYXRpdmVcIiB8fCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikpIHtcbiAgICAgIG9mZnNldExlZnQgLT0gb2Zmc2V0UGFyZW50Lm9mZnNldExlZnQ7XG4gICAgICBvZmZzZXRUb3AgLT0gb2Zmc2V0UGFyZW50Lm9mZnNldFRvcDtcbiAgICAgIHJlcXVlc3RFbmQgPSByZXF1ZXN0RW5kIHx8IGlzT2Zmc2V0RW5kO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRDbGllbnRMZWZ0ID0gMDtcbiAgICB2YXIgcGFyZW50Q2xpZW50VG9wID0gMDtcbiAgICB2YXIgZml4ZWRDbGllbnRMZWZ0ID0gMDtcbiAgICB2YXIgZml4ZWRDbGllbnRUb3AgPSAwO1xuXG4gICAgaWYgKGlzRml4ZWQpIHtcbiAgICAgIGlmIChoYXNPZmZzZXQgJiYgZml4ZWRJbmZvLmhhc1RyYW5zZm9ybSkge1xuICAgICAgICAvLyBib3JkZXJcbiAgICAgICAgZml4ZWRDbGllbnRMZWZ0ID0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICAgIGZpeGVkQ2xpZW50VG9wID0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc09mZnNldCAmJiBvZmZzZXRDb250YWluZXIgIT09IG9mZnNldFBhcmVudCkge1xuICAgICAgICAvLyBib3JkZXJcbiAgICAgICAgcGFyZW50Q2xpZW50TGVmdCA9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgICBwYXJlbnRDbGllbnRUb3AgPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzT2Zmc2V0ICYmIG9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB2YXIgbWFyZ2luID0gZ2V0Qm9keU9mZnNldChlbCwgZmFsc2UsIHN0eWxlKTtcbiAgICAgICAgb2Zmc2V0TGVmdCArPSBtYXJnaW5bMF07XG4gICAgICAgIG9mZnNldFRvcCArPSBtYXJnaW5bMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWF0cml4ZXMucHVzaCh7XG4gICAgICB0eXBlOiBcInRhcmdldFwiLFxuICAgICAgdGFyZ2V0OiBlbCxcbiAgICAgIG1hdHJpeDogZ2V0QWJzb2x1dGVNYXRyaXgobWF0cml4LCBuLCBvcmlnaW4pXG4gICAgfSk7XG5cbiAgICBpZiAoaGFzT2Zmc2V0KSB7XG4gICAgICBtYXRyaXhlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJvZmZzZXRcIixcbiAgICAgICAgdGFyZ2V0OiBlbCxcbiAgICAgICAgbWF0cml4OiBjcmVhdGVPcmlnaW5NYXRyaXgoW29mZnNldExlZnQgLSBlbC5zY3JvbGxMZWZ0ICsgcGFyZW50Q2xpZW50TGVmdCAtIGZpeGVkQ2xpZW50TGVmdCwgb2Zmc2V0VG9wIC0gZWwuc2Nyb2xsVG9wICsgcGFyZW50Q2xpZW50VG9wIC0gZml4ZWRDbGllbnRUb3BdLCBuKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN2Z1xuICAgICAgbWF0cml4ZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwib2Zmc2V0XCIsXG4gICAgICAgIHRhcmdldDogZWwsXG4gICAgICAgIG9yaWdpbjogb3JpZ2luXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldE1hdHJpeCkge1xuICAgICAgdGFyZ2V0TWF0cml4ID0gbWF0cml4O1xuICAgIH1cblxuICAgIGlmICghdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm1PcmlnaW4pIHtcbiAgICAgIHRhcmdldFRyYW5zZm9ybU9yaWdpbiA9IHRhcmdldE9yaWdpbjtcbiAgICB9XG5cbiAgICBpZiAoaXNFbmQgfHwgaXNGaXhlZCkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsID0gb2Zmc2V0UGFyZW50O1xuICAgICAgcmVxdWVzdEVuZCA9IGlzT2Zmc2V0RW5kO1xuICAgIH1cblxuICAgIGlmICghY2hlY2tDb250YWluZXIgfHwgZWwgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGlzRW5kID0gcmVxdWVzdEVuZDtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRhcmdldE1hdHJpeCkge1xuICAgIHRhcmdldE1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuICB9XG5cbiAgaWYgKCF0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICB0cmFuc2Zvcm1PcmlnaW4gPSBbMCwgMF07XG4gIH1cblxuICBpZiAoIXRhcmdldFRyYW5zZm9ybU9yaWdpbikge1xuICAgIHRhcmdldFRyYW5zZm9ybU9yaWdpbiA9IFswLCAwXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb2Zmc2V0Q29udGFpbmVyOiBvZmZzZXRDb250YWluZXIsXG4gICAgbWF0cml4ZXM6IG1hdHJpeGVzLFxuICAgIHRhcmdldE1hdHJpeDogdGFyZ2V0TWF0cml4LFxuICAgIHRyYW5zZm9ybU9yaWdpbjogdHJhbnNmb3JtT3JpZ2luLFxuICAgIHRhcmdldE9yaWdpbjogdGFyZ2V0VHJhbnNmb3JtT3JpZ2luLFxuICAgIGlzM2Q6IGlzM2QsXG4gICAgaGFzRml4ZWQ6IGhhc0ZpeGVkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUVsZW1lbnRJbmZvKHRhcmdldCwgY29udGFpbmVyLCByb290Q29udGFpbmVyLCBpc0Fic29sdXRlM2QpIHtcbiAgaWYgKHJvb3RDb250YWluZXIgPT09IHZvaWQgMCkge1xuICAgIHJvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gIH1cblxuICB2YXIgd2lkdGggPSAwO1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgdmFyIHJvdGF0aW9uID0gMDtcbiAgdmFyIGFsbFJlc3VsdCA9IHt9O1xuXG4gIGlmICh0YXJnZXQpIHtcbiAgICB2YXIgX2EgPSBnZXRTaXplKHRhcmdldCksXG4gICAgICAgIG9mZnNldFdpZHRoID0gX2Eub2Zmc2V0V2lkdGgsXG4gICAgICAgIG9mZnNldEhlaWdodCA9IF9hLm9mZnNldEhlaWdodDtcblxuICAgIHdpZHRoID0gb2Zmc2V0V2lkdGg7XG4gICAgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xuICB9XG5cbiAgaWYgKHRhcmdldCkge1xuICAgIHZhciByZXN1bHQgPSBjYWxjdWxhdGVNYXRyaXhTdGFjayh0YXJnZXQsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgaXNBYnNvbHV0ZTNkKTtcbiAgICB2YXIgcG9zaXRpb24gPSBjYWxjdWxhdGVNb3ZlYWJsZVBvc2l0aW9uKHJlc3VsdC5hbGxNYXRyaXgsIHJlc3VsdC50cmFuc2Zvcm1PcmlnaW4sIHdpZHRoLCBoZWlnaHQpO1xuICAgIGFsbFJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCBwb3NpdGlvbik7XG4gICAgdmFyIHJvdGF0aW9uUG9zaXRpb24gPSBjYWxjdWxhdGVNb3ZlYWJsZVBvc2l0aW9uKHJlc3VsdC5hbGxNYXRyaXgsIFs1MCwgNTBdLCAxMDAsIDEwMCk7XG4gICAgcm90YXRpb24gPSBnZXRSb3RhdGlvblJhZChbcm90YXRpb25Qb3NpdGlvbi5wb3MxLCByb3RhdGlvblBvc2l0aW9uLnBvczJdLCByb3RhdGlvblBvc2l0aW9uLmRpcmVjdGlvbik7XG4gIH1cblxuICB2YXIgbiA9IGlzQWJzb2x1dGUzZCA/IDQgOiAzO1xuICByZXR1cm4gX19hc3NpZ24oe1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgcm9vdE1hdHJpeDogY3JlYXRlSWRlbnRpdHlNYXRyaXgobiksXG4gICAgYmVmb3JlTWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSxcbiAgICBvZmZzZXRNYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLFxuICAgIGFsbE1hdHJpeDogY3JlYXRlSWRlbnRpdHlNYXRyaXgobiksXG4gICAgdGFyZ2V0TWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSxcbiAgICB0YXJnZXRUcmFuc2Zvcm06IFwiXCIsXG4gICAgdHJhbnNmb3JtT3JpZ2luOiBbMCwgMF0sXG4gICAgdGFyZ2V0T3JpZ2luOiBbMCwgMF0sXG4gICAgaXMzZDogISFpc0Fic29sdXRlM2QsXG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIG9yaWdpbjogWzAsIDBdLFxuICAgIHBvczE6IFswLCAwXSxcbiAgICBwb3MyOiBbMCwgMF0sXG4gICAgcG9zMzogWzAsIDBdLFxuICAgIHBvczQ6IFswLCAwXSxcbiAgICBkaXJlY3Rpb246IDEsXG4gICAgaGFzRml4ZWQ6IGZhbHNlXG4gIH0sIGFsbFJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRJbmZvKHRhcmdldCwgY29udGFpbmVyLCByb290Q29udGFpbmVyKSB7XG4gIGlmIChyb290Q29udGFpbmVyID09PSB2b2lkIDApIHtcbiAgICByb290Q29udGFpbmVyID0gY29udGFpbmVyO1xuICB9XG5cbiAgcmV0dXJuIGNhbGN1bGF0ZUVsZW1lbnRJbmZvKHRhcmdldCwgY29udGFpbmVyLCByb290Q29udGFpbmVyLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4U3RhY2sodGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIsIGlzQWJzb2x1dGUzZCkge1xuICB2YXIgX2E7XG5cbiAgaWYgKHJvb3RDb250YWluZXIgPT09IHZvaWQgMCkge1xuICAgIHJvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gIH1cblxuICB2YXIgX2IgPSBnZXRNYXRyaXhTdGFja0luZm8odGFyZ2V0LCBjb250YWluZXIpLFxuICAgICAgbWF0cml4ZXMgPSBfYi5tYXRyaXhlcyxcbiAgICAgIGlzM2QgPSBfYi5pczNkLFxuICAgICAgcHJldlRhcmdldE1hdHJpeCA9IF9iLnRhcmdldE1hdHJpeCxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IF9iLnRyYW5zZm9ybU9yaWdpbixcbiAgICAgIHRhcmdldE9yaWdpbiA9IF9iLnRhcmdldE9yaWdpbixcbiAgICAgIG9mZnNldENvbnRhaW5lciA9IF9iLm9mZnNldENvbnRhaW5lcixcbiAgICAgIGhhc0ZpeGVkID0gX2IuaGFzRml4ZWQ7IC8vIHByZXZNYXRyaXhcblxuXG4gIHZhciBfYyA9IGdldE1hdHJpeFN0YWNrSW5mbyhvZmZzZXRDb250YWluZXIsIHJvb3RDb250YWluZXIsIHRydWUpLFxuICAgICAgcm9vdE1hdHJpeGVzID0gX2MubWF0cml4ZXMsXG4gICAgICBpc1Jvb3QzZCA9IF9jLmlzM2Q7IC8vIHByZXZSb290TWF0cml4XG4gIC8vIGlmIChyb290Q29udGFpbmVyID09PSBkb2N1bWVudC5ib2R5KSB7XG4gIC8vICAgICBjb25zb2xlLmxvZyhvZmZzZXRDb250YWluZXIsIHJvb3RDb250YWluZXIsIHJvb3RNYXRyaXhlcyk7XG4gIC8vIH1cblxuXG4gIHZhciBpc05leHQzZCA9IGlzQWJzb2x1dGUzZCB8fCBpc1Jvb3QzZCB8fCBpczNkO1xuICB2YXIgbiA9IGlzTmV4dDNkID8gNCA6IDM7XG4gIHZhciBpc1NWR0dyYXBoaWNFbGVtZW50ID0gdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJzdmdcIiAmJiBcIm93bmVyU1ZHRWxlbWVudFwiIGluIHRhcmdldDtcbiAgdmFyIHRhcmdldE1hdHJpeCA9IHByZXZUYXJnZXRNYXRyaXg7IC8vIGxldCBhbGxNYXRyaXggPSBwcmV2TWF0cml4ID8gY29udmVydERpbWVuc2lvbihwcmV2TWF0cml4LCBwcmV2TiEsIG4pIDogY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIC8vIGxldCByb290TWF0cml4ID0gcHJldlJvb3RNYXRyaXggPyBjb252ZXJ0RGltZW5zaW9uKHByZXZSb290TWF0cml4LCBwcmV2TiEsIG4pIDogY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIC8vIGxldCBiZWZvcmVNYXRyaXggPSBwcmV2TWF0cml4ID8gY29udmVydERpbWVuc2lvbihwcmV2TWF0cml4LCBwcmV2TiEsIG4pIDogY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG5cbiAgdmFyIGFsbE1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuICB2YXIgcm9vdE1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuICB2YXIgYmVmb3JlTWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIHZhciBvZmZzZXRNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcbiAgdmFyIGxlbmd0aCA9IG1hdHJpeGVzLmxlbmd0aDtcbiAgcm9vdE1hdHJpeGVzLnJldmVyc2UoKTtcbiAgbWF0cml4ZXMucmV2ZXJzZSgpO1xuXG4gIGlmICghaXMzZCAmJiBpc05leHQzZCkge1xuICAgIHRhcmdldE1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24odGFyZ2V0TWF0cml4LCAzLCA0KTtcbiAgICBjb252ZXJ0M0RNYXRyaXhlcyhtYXRyaXhlcyk7XG4gIH1cblxuICBpZiAoIWlzUm9vdDNkICYmIGlzTmV4dDNkKSB7XG4gICAgY29udmVydDNETWF0cml4ZXMocm9vdE1hdHJpeGVzKTtcbiAgfSAvLyByb290TWF0cml4ID0gKC4uLikgLT4gY29udGFpbmVyIC0+IG9mZnNldCAtPiBhYnNvbHV0ZSAtPiBvZmZzZXQgLT4gYWJzb2x1dGUodGFyZ2V0TWF0cml4KVxuICAvLyByb290TWF0cml4QmVmb3JlT2Zmc2V0ID0gbGFzdE9mZnNldE1hdHJpeCAtPiAoLi4uKSAtPiBjb250YWluZXJcbiAgLy8gYmVmb3JlTWF0cml4ID0gKC4uLiAtPiBjb250YWluZXIgLT4gb2Zmc2V0IC0+IGFic29sdXRlKSAtPiBvZmZzZXQgLT4gYWJzb2x1dGUodGFyZ2V0TWF0cml4KVxuICAvLyBvZmZzZXRNYXRyaXggPSAoLi4uIC0+IGNvbnRhaW5lciAtPiBvZmZzZXQgLT4gYWJzb2x1dGUgLT4gb2Zmc2V0KSAtPiBhYnNvbHV0ZSh0YXJnZXRNYXRyaXgpXG5cblxuICByb290TWF0cml4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgIHJvb3RNYXRyaXggPSBtdWx0aXBseShyb290TWF0cml4LCBpbmZvLm1hdHJpeCwgbik7XG4gIH0pO1xuICB2YXIgb3JpZ2luYWxSb290Q29udGFpbmVyID0gcm9vdENvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICB2YXIgZW5kQ29udGFpbmVyID0gKChfYSA9IHJvb3RNYXRyaXhlc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhcmdldCkgfHwgZ2V0T2Zmc2V0SW5mbyhvcmlnaW5hbFJvb3RDb250YWluZXIsIG9yaWdpbmFsUm9vdENvbnRhaW5lciwgdHJ1ZSkub2Zmc2V0UGFyZW50O1xuICB2YXIgcm9vdE1hdHJpeEJlZm9yZU9mZnNldCA9IHJvb3RNYXRyaXhlcy5zbGljZSgxKS5yZWR1Y2UoZnVuY3Rpb24gKG1hdHJpeCwgaW5mbykge1xuICAgIHJldHVybiBtdWx0aXBseShtYXRyaXgsIGluZm8ubWF0cml4LCBuKTtcbiAgfSwgY3JlYXRlSWRlbnRpdHlNYXRyaXgobikpO1xuICBtYXRyaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvLCBpKSB7XG4gICAgaWYgKGxlbmd0aCAtIDIgPT09IGkpIHtcbiAgICAgIC8vIGxlbmd0aCAtIDNcbiAgICAgIGJlZm9yZU1hdHJpeCA9IGFsbE1hdHJpeC5zbGljZSgpO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGggLSAxID09PSBpKSB7XG4gICAgICAvLyBsZW5ndGggLSAyXG4gICAgICBvZmZzZXRNYXRyaXggPSBhbGxNYXRyaXguc2xpY2UoKTtcbiAgICB9IC8vIGNhbGN1bGF0ZSBmb3IgU1ZHRWxlbWVudFxuXG5cbiAgICBpZiAoIWluZm8ubWF0cml4KSB7XG4gICAgICB2YXIgbmV4dEluZm8gPSBtYXRyaXhlc1tpICsgMV07XG4gICAgICB2YXIgb2Zmc2V0ID0gZ2V0U1ZHT2Zmc2V0KGluZm8sIG5leHRJbmZvLCBlbmRDb250YWluZXIsIG4sIG11bHRpcGx5KHJvb3RNYXRyaXhCZWZvcmVPZmZzZXQsIGFsbE1hdHJpeCwgbikpO1xuICAgICAgaW5mby5tYXRyaXggPSBjcmVhdGVPcmlnaW5NYXRyaXgob2Zmc2V0LCBuKTtcbiAgICB9XG5cbiAgICBhbGxNYXRyaXggPSBtdWx0aXBseShhbGxNYXRyaXgsIGluZm8ubWF0cml4LCBuKTtcbiAgfSk7XG4gIHZhciBpc01hdHJpeDNkID0gIWlzU1ZHR3JhcGhpY0VsZW1lbnQgJiYgaXMzZDtcblxuICBpZiAoIXRhcmdldE1hdHJpeCkge1xuICAgIHRhcmdldE1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KGlzTWF0cml4M2QgPyA0IDogMyk7XG4gIH1cblxuICB2YXIgdGFyZ2V0VHJhbnNmb3JtID0gbWFrZU1hdHJpeENTUyhpc1NWR0dyYXBoaWNFbGVtZW50ICYmIHRhcmdldE1hdHJpeC5sZW5ndGggPT09IDE2ID8gY29udmVydERpbWVuc2lvbih0YXJnZXRNYXRyaXgsIDQsIDMpIDogdGFyZ2V0TWF0cml4LCBpc01hdHJpeDNkKTtcbiAgcm9vdE1hdHJpeCA9IGlnbm9yZURpbWVuc2lvbihyb290TWF0cml4LCBuLCBuKTtcbiAgcmV0dXJuIHtcbiAgICBoYXNGaXhlZDogaGFzRml4ZWQsXG4gICAgcm9vdE1hdHJpeDogcm9vdE1hdHJpeCxcbiAgICBiZWZvcmVNYXRyaXg6IGJlZm9yZU1hdHJpeCxcbiAgICBvZmZzZXRNYXRyaXg6IG9mZnNldE1hdHJpeCxcbiAgICBhbGxNYXRyaXg6IGFsbE1hdHJpeCxcbiAgICB0YXJnZXRNYXRyaXg6IHRhcmdldE1hdHJpeCxcbiAgICB0YXJnZXRUcmFuc2Zvcm06IHRhcmdldFRyYW5zZm9ybSxcbiAgICB0cmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpbixcbiAgICB0YXJnZXRPcmlnaW46IHRhcmdldE9yaWdpbixcbiAgICBpczNkOiBpc05leHQzZFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlTWF0cml4Q1NTKG1hdHJpeCwgaXMzZCkge1xuICBpZiAoaXMzZCA9PT0gdm9pZCAwKSB7XG4gICAgaXMzZCA9IG1hdHJpeC5sZW5ndGggPiA5O1xuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KGlzM2QgPyBcIm1hdHJpeDNkXCIgOiBcIm1hdHJpeFwiLCBcIihcIikuY29uY2F0KGNvbnZlcnRNYXRyaXh0b0NTUyhtYXRyaXgsICFpczNkKS5qb2luKFwiLFwiKSwgXCIpXCIpO1xufVxuXG5mdW5jdGlvbiBnZXRTVkdWaWV3Qm94KGVsKSB7XG4gIHZhciBjbGllbnRXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICB2YXIgY2xpZW50SGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuXG4gIGlmICghZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGNsaWVudFdpZHRoOiBjbGllbnRXaWR0aCxcbiAgICAgIGNsaWVudEhlaWdodDogY2xpZW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHZhciB2aWV3Qm94ID0gZWwudmlld0JveDtcbiAgdmFyIGJhc2VWYWwgPSB2aWV3Qm94ICYmIHZpZXdCb3guYmFzZVZhbCB8fCB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICByZXR1cm4ge1xuICAgIHg6IGJhc2VWYWwueCxcbiAgICB5OiBiYXNlVmFsLnksXG4gICAgd2lkdGg6IGJhc2VWYWwud2lkdGggfHwgY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0OiBiYXNlVmFsLmhlaWdodCB8fCBjbGllbnRIZWlnaHQsXG4gICAgY2xpZW50V2lkdGg6IGNsaWVudFdpZHRoLFxuICAgIGNsaWVudEhlaWdodDogY2xpZW50SGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNWR01hdHJpeChlbCwgbikge1xuICB2YXIgX2EgPSBnZXRTVkdWaWV3Qm94KGVsKSxcbiAgICAgIHZpZXdCb3hXaWR0aCA9IF9hLndpZHRoLFxuICAgICAgdmlld0JveEhlaWdodCA9IF9hLmhlaWdodCxcbiAgICAgIGNsaWVudFdpZHRoID0gX2EuY2xpZW50V2lkdGgsXG4gICAgICBjbGllbnRIZWlnaHQgPSBfYS5jbGllbnRIZWlnaHQ7XG5cbiAgdmFyIHNjYWxlWCA9IGNsaWVudFdpZHRoIC8gdmlld0JveFdpZHRoO1xuICB2YXIgc2NhbGVZID0gY2xpZW50SGVpZ2h0IC8gdmlld0JveEhlaWdodDtcbiAgdmFyIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBlbC5wcmVzZXJ2ZUFzcGVjdFJhdGlvLmJhc2VWYWw7IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvcHJlc2VydmVBc3BlY3RSYXRpb1xuXG4gIHZhciBhbGlnbiA9IHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ247IC8vIDEgOiBtZWV0IDI6IHNsaWNlXG5cbiAgdmFyIG1lZXRPclNsaWNlID0gcHJlc2VydmVBc3BlY3RSYXRpby5tZWV0T3JTbGljZTtcbiAgdmFyIHN2Z09yaWdpbiA9IFswLCAwXTtcbiAgdmFyIHNjYWxlID0gW3NjYWxlWCwgc2NhbGVZXTtcbiAgdmFyIHRyYW5zbGF0ZSA9IFswLCAwXTtcblxuICBpZiAoYWxpZ24gIT09IDEpIHtcbiAgICB2YXIgeEFsaWduID0gKGFsaWduIC0gMikgJSAzO1xuICAgIHZhciB5QWxpZ24gPSBNYXRoLmZsb29yKChhbGlnbiAtIDIpIC8gMyk7XG4gICAgc3ZnT3JpZ2luWzBdID0gdmlld0JveFdpZHRoICogeEFsaWduIC8gMjtcbiAgICBzdmdPcmlnaW5bMV0gPSB2aWV3Qm94SGVpZ2h0ICogeUFsaWduIC8gMjtcbiAgICB2YXIgc2NhbGVEaW1lbnNpb24gPSBtZWV0T3JTbGljZSA9PT0gMiA/IE1hdGgubWF4KHNjYWxlWSwgc2NhbGVYKSA6IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcbiAgICBzY2FsZVswXSA9IHNjYWxlRGltZW5zaW9uO1xuICAgIHNjYWxlWzFdID0gc2NhbGVEaW1lbnNpb247XG4gICAgdHJhbnNsYXRlWzBdID0gKGNsaWVudFdpZHRoIC0gdmlld0JveFdpZHRoKSAvIDIgKiB4QWxpZ247XG4gICAgdHJhbnNsYXRlWzFdID0gKGNsaWVudEhlaWdodCAtIHZpZXdCb3hIZWlnaHQpIC8gMiAqIHlBbGlnbjtcbiAgfVxuXG4gIHZhciBzY2FsZU1hdHJpeCA9IGNyZWF0ZVNjYWxlTWF0cml4KHNjYWxlLCBuKTtcbiAgc2NhbGVNYXRyaXhbbiAqIChuIC0gMSldID0gdHJhbnNsYXRlWzBdLCBzY2FsZU1hdHJpeFtuICogKG4gLSAxKSArIDFdID0gdHJhbnNsYXRlWzFdO1xuICByZXR1cm4gZ2V0QWJzb2x1dGVNYXRyaXgoc2NhbGVNYXRyaXgsIG4sIHN2Z09yaWdpbik7XG59XG5cbmZ1bmN0aW9uIGdldFNWR0dyYXBoaWNzT2Zmc2V0KGVsLCBvcmlnaW4pIHtcbiAgaWYgKCFlbC5nZXRCQm94IHx8IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJnXCIpIHtcbiAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICB9XG5cbiAgdmFyIGJib3ggPSBlbC5nZXRCQm94KCk7XG4gIHZhciB2aWV3Qm94ID0gZ2V0U1ZHVmlld0JveChlbC5vd25lclNWR0VsZW1lbnQpO1xuICB2YXIgbGVmdCA9IGJib3gueCAtIHZpZXdCb3gueDtcbiAgdmFyIHRvcCA9IGJib3gueSAtIHZpZXdCb3gueTtcbiAgcmV0dXJuIFtsZWZ0LCB0b3AsIG9yaWdpblswXSAtIGxlZnQsIG9yaWdpblsxXSAtIHRvcF07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uKG1hdHJpeCwgcG9zLCBuKSB7XG4gIHJldHVybiBjYWxjdWxhdGUobWF0cml4LCBjb252ZXJ0UG9zaXRpb25NYXRyaXgocG9zLCBuKSwgbik7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2VzKG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgbikge1xuICByZXR1cm4gW1swLCAwXSwgW3dpZHRoLCAwXSwgWzAsIGhlaWdodF0sIFt3aWR0aCwgaGVpZ2h0XV0ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlUG9zaXRpb24obWF0cml4LCBwb3MsIG4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdChwb3Nlcykge1xuICB2YXIgcG9zZXNYID0gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zWzBdO1xuICB9KTtcbiAgdmFyIHBvc2VzWSA9IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvc1sxXTtcbiAgfSk7XG4gIHZhciBsZWZ0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgcG9zZXNYKTtcbiAgdmFyIHRvcCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHBvc2VzWSk7XG4gIHZhciByaWdodCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHBvc2VzWCk7XG4gIHZhciBib3R0b20gPSBNYXRoLm1heC5hcHBseShNYXRoLCBwb3Nlc1kpO1xuICB2YXIgcmVjdFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB2YXIgcmVjdEhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHRvcDogdG9wLFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICB3aWR0aDogcmVjdFdpZHRoLFxuICAgIGhlaWdodDogcmVjdEhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVSZWN0KG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgbikge1xuICB2YXIgcG9zZXMgPSBjYWxjdWxhdGVQb3NlcyhtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pO1xuICByZXR1cm4gZ2V0UmVjdChwb3Nlcyk7XG59XG5cbmZ1bmN0aW9uIGdldFNWR09mZnNldChvZmZzZXRJbmZvLCB0YXJnZXRJbmZvLCBjb250YWluZXIsIG4sIGJlZm9yZU1hdHJpeCkge1xuICB2YXIgX2E7XG5cbiAgdmFyIHRhcmdldCA9IG9mZnNldEluZm8udGFyZ2V0O1xuICB2YXIgb3JpZ2luID0gb2Zmc2V0SW5mby5vcmlnaW47XG4gIHZhciB0YXJnZXRNYXRyaXggPSB0YXJnZXRJbmZvLm1hdHJpeDtcblxuICB2YXIgX2IgPSBnZXRTaXplKHRhcmdldCksXG4gICAgICB3aWR0aCA9IF9iLm9mZnNldFdpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2Iub2Zmc2V0SGVpZ2h0O1xuXG4gIHZhciBjb250YWluZXJDbGllbnRSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgbWFyZ2luID0gWzAsIDBdO1xuXG4gIGlmIChjb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICBtYXJnaW4gPSBnZXRCb2R5T2Zmc2V0KHRhcmdldCwgdHJ1ZSk7XG4gIH1cblxuICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHJlY3RMZWZ0ID0gcmVjdC5sZWZ0IC0gY29udGFpbmVyQ2xpZW50UmVjdC5sZWZ0ICsgY29udGFpbmVyLnNjcm9sbExlZnQgLSAoY29udGFpbmVyLmNsaWVudExlZnQgfHwgMCkgKyBtYXJnaW5bMF07XG4gIHZhciByZWN0VG9wID0gcmVjdC50b3AgLSBjb250YWluZXJDbGllbnRSZWN0LnRvcCArIGNvbnRhaW5lci5zY3JvbGxUb3AgLSAoY29udGFpbmVyLmNsaWVudFRvcCB8fCAwKSArIG1hcmdpblsxXTtcbiAgdmFyIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciBtYXQgPSBtdWx0aXBsaWVzKG4sIGJlZm9yZU1hdHJpeCwgdGFyZ2V0TWF0cml4KTtcblxuICB2YXIgX2MgPSBjYWxjdWxhdGVSZWN0KG1hdCwgd2lkdGgsIGhlaWdodCwgbiksXG4gICAgICBwcmV2TGVmdCA9IF9jLmxlZnQsXG4gICAgICBwcmV2VG9wID0gX2MudG9wLFxuICAgICAgcHJldldpZHRoID0gX2Mud2lkdGgsXG4gICAgICBwcmV2SGVpZ2h0ID0gX2MuaGVpZ2h0O1xuXG4gIHZhciBwb3NPcmlnaW4gPSBjYWxjdWxhdGVQb3NpdGlvbihtYXQsIG9yaWdpbiwgbik7XG4gIHZhciBwcmV2T3JpZ2luID0gbWludXMocG9zT3JpZ2luLCBbcHJldkxlZnQsIHByZXZUb3BdKTtcbiAgdmFyIHJlY3RPcmlnaW4gPSBbcmVjdExlZnQgKyBwcmV2T3JpZ2luWzBdICogcmVjdFdpZHRoIC8gcHJldldpZHRoLCByZWN0VG9wICsgcHJldk9yaWdpblsxXSAqIHJlY3RIZWlnaHQgLyBwcmV2SGVpZ2h0XTtcbiAgdmFyIG9mZnNldCA9IFswLCAwXTtcbiAgdmFyIGNvdW50ID0gMDtcblxuICB3aGlsZSAoKytjb3VudCA8IDEwKSB7XG4gICAgdmFyIGludmVyc2VCZWZvcmVNYXRyaXggPSBpbnZlcnQoYmVmb3JlTWF0cml4LCBuKTtcbiAgICBfYSA9IG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGludmVyc2VCZWZvcmVNYXRyaXgsIHJlY3RPcmlnaW4sIG4pLCBjYWxjdWxhdGVQb3NpdGlvbihpbnZlcnNlQmVmb3JlTWF0cml4LCBwb3NPcmlnaW4sIG4pKSwgb2Zmc2V0WzBdID0gX2FbMF0sIG9mZnNldFsxXSA9IF9hWzFdO1xuICAgIHZhciBtYXQyID0gbXVsdGlwbGllcyhuLCBiZWZvcmVNYXRyaXgsIGNyZWF0ZU9yaWdpbk1hdHJpeChvZmZzZXQsIG4pLCB0YXJnZXRNYXRyaXgpO1xuXG4gICAgdmFyIF9kID0gY2FsY3VsYXRlUmVjdChtYXQyLCB3aWR0aCwgaGVpZ2h0LCBuKSxcbiAgICAgICAgbmV4dExlZnQgPSBfZC5sZWZ0LFxuICAgICAgICBuZXh0VG9wID0gX2QudG9wO1xuXG4gICAgdmFyIGRpc3RMZWZ0ID0gbmV4dExlZnQgLSByZWN0TGVmdDtcbiAgICB2YXIgZGlzdFRvcCA9IG5leHRUb3AgLSByZWN0VG9wO1xuXG4gICAgaWYgKE1hdGguYWJzKGRpc3RMZWZ0KSA8IDIgJiYgTWF0aC5hYnMoZGlzdFRvcCkgPCAyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZWN0T3JpZ2luWzBdIC09IGRpc3RMZWZ0O1xuICAgIHJlY3RPcmlnaW5bMV0gLT0gZGlzdFRvcDtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQocCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVNb3ZlYWJsZVBvc2l0aW9uKG1hdHJpeCwgb3JpZ2luLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBpczNkID0gbWF0cml4Lmxlbmd0aCA9PT0gMTY7XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICB2YXIgcG9zZXMgPSBjYWxjdWxhdGVQb3NlcyhtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pO1xuICB2YXIgX2EgPSBwb3Nlc1swXSxcbiAgICAgIHgxID0gX2FbMF0sXG4gICAgICB5MSA9IF9hWzFdLFxuICAgICAgX2IgPSBwb3Nlc1sxXSxcbiAgICAgIHgyID0gX2JbMF0sXG4gICAgICB5MiA9IF9iWzFdLFxuICAgICAgX2MgPSBwb3Nlc1syXSxcbiAgICAgIHgzID0gX2NbMF0sXG4gICAgICB5MyA9IF9jWzFdLFxuICAgICAgX2QgPSBwb3Nlc1szXSxcbiAgICAgIHg0ID0gX2RbMF0sXG4gICAgICB5NCA9IF9kWzFdO1xuXG4gIHZhciBfZSA9IGNhbGN1bGF0ZVBvc2l0aW9uKG1hdHJpeCwgb3JpZ2luLCBuKSxcbiAgICAgIG9yaWdpblggPSBfZVswXSxcbiAgICAgIG9yaWdpblkgPSBfZVsxXTtcblxuICB2YXIgbGVmdCA9IE1hdGgubWluKHgxLCB4MiwgeDMsIHg0KTtcbiAgdmFyIHRvcCA9IE1hdGgubWluKHkxLCB5MiwgeTMsIHk0KTtcbiAgdmFyIHJpZ2h0ID0gTWF0aC5tYXgoeDEsIHgyLCB4MywgeDQpO1xuICB2YXIgYm90dG9tID0gTWF0aC5tYXgoeTEsIHkyLCB5MywgeTQpO1xuICB4MSA9IHgxIC0gbGVmdCB8fCAwO1xuICB4MiA9IHgyIC0gbGVmdCB8fCAwO1xuICB4MyA9IHgzIC0gbGVmdCB8fCAwO1xuICB4NCA9IHg0IC0gbGVmdCB8fCAwO1xuICB5MSA9IHkxIC0gdG9wIHx8IDA7XG4gIHkyID0geTIgLSB0b3AgfHwgMDtcbiAgeTMgPSB5MyAtIHRvcCB8fCAwO1xuICB5NCA9IHk0IC0gdG9wIHx8IDA7XG4gIG9yaWdpblggPSBvcmlnaW5YIC0gbGVmdCB8fCAwO1xuICBvcmlnaW5ZID0gb3JpZ2luWSAtIHRvcCB8fCAwO1xuICB2YXIgZGlyZWN0aW9uID0gZ2V0U2hhcGVEaXJlY3Rpb24ocG9zZXMpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGxlZnQsXG4gICAgdG9wOiB0b3AsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIG9yaWdpbjogW29yaWdpblgsIG9yaWdpblldLFxuICAgIHBvczE6IFt4MSwgeTFdLFxuICAgIHBvczI6IFt4MiwgeTJdLFxuICAgIHBvczM6IFt4MywgeTNdLFxuICAgIHBvczQ6IFt4NCwgeTRdLFxuICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERpc3RTaXplKHZlYykge1xuICByZXR1cm4gTWF0aC5zcXJ0KHZlY1swXSAqIHZlY1swXSArIHZlY1sxXSAqIHZlY1sxXSk7XG59XG5cbmZ1bmN0aW9uIGdldERpYWdvbmFsU2l6ZShwb3MxLCBwb3MyKSB7XG4gIHJldHVybiBnZXREaXN0U2l6ZShbcG9zMlswXSAtIHBvczFbMF0sIHBvczJbMV0gLSBwb3MxWzFdXSk7XG59XG5cbmZ1bmN0aW9uIGdldExpbmVTdHlsZShwb3MxLCBwb3MyLCB6b29tLCByYWQpIHtcbiAgaWYgKHpvb20gPT09IHZvaWQgMCkge1xuICAgIHpvb20gPSAxO1xuICB9XG5cbiAgaWYgKHJhZCA9PT0gdm9pZCAwKSB7XG4gICAgcmFkID0gZ2V0UmFkKHBvczEsIHBvczIpO1xuICB9XG5cbiAgdmFyIHdpZHRoID0gZ2V0RGlhZ29uYWxTaXplKHBvczEsIHBvczIpO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC01MCUpIHRyYW5zbGF0ZShcIi5jb25jYXQocG9zMVswXSwgXCJweCwgXCIpLmNvbmNhdChwb3MxWzFdLCBcInB4KSByb3RhdGUoXCIpLmNvbmNhdChyYWQsIFwicmFkKSBzY2FsZVkoXCIpLmNvbmNhdCh6b29tLCBcIilcIiksXG4gICAgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvbnRyb2xUcmFuc2Zvcm0ocm90YXRpb24sIHpvb20pIHtcbiAgdmFyIHBvc2VzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBwb3Nlc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBwb3Nlcy5sZW5ndGg7XG4gIHZhciB4ID0gcG9zZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBwb3MpIHtcbiAgICByZXR1cm4gcHJldiArIHBvc1swXTtcbiAgfSwgMCkgLyBsZW5ndGg7XG4gIHZhciB5ID0gcG9zZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBwb3MpIHtcbiAgICByZXR1cm4gcHJldiArIHBvc1sxXTtcbiAgfSwgMCkgLyBsZW5ndGg7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVooMHB4KSB0cmFuc2xhdGUoXCIuY29uY2F0KHgsIFwicHgsIFwiKS5jb25jYXQoeSwgXCJweCkgcm90YXRlKFwiKS5jb25jYXQocm90YXRpb24sIFwicmFkKSBzY2FsZShcIikuY29uY2F0KHpvb20sIFwiKVwiKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDU1NTaXplKHRhcmdldCkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gIHJldHVybiBbcGFyc2VGbG9hdChzdHlsZS53aWR0aCksIHBhcnNlRmxvYXQoc3R5bGUuaGVpZ2h0KV07XG59XG5cbmZ1bmN0aW9uIGdldFNpemUodGFyZ2V0LCBzdHlsZSkge1xuICBpZiAoc3R5bGUgPT09IHZvaWQgMCkge1xuICAgIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICB9XG5cbiAgdmFyIGhhc09mZnNldCA9ICFpc1VuZGVmaW5lZCh0YXJnZXQub2Zmc2V0V2lkdGgpO1xuXG4gIGlmICghaGFzT2Zmc2V0ICYmIHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwic3ZnXCIpIHtcbiAgICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XG4gICAgdmFyIG9mZnNldFdpZHRoID0gYmJveC53aWR0aDtcbiAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gYmJveC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN2ZzogdHJ1ZSxcbiAgICAgIG9mZnNldFdpZHRoOiBvZmZzZXRXaWR0aCxcbiAgICAgIG9mZnNldEhlaWdodDogb2Zmc2V0SGVpZ2h0LFxuICAgICAgY2xpZW50V2lkdGg6IG9mZnNldFdpZHRoLFxuICAgICAgY2xpZW50SGVpZ2h0OiBvZmZzZXRIZWlnaHQsXG4gICAgICBjc3NXaWR0aDogb2Zmc2V0V2lkdGgsXG4gICAgICBjc3NIZWlnaHQ6IG9mZnNldEhlaWdodFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyA9PT0gXCJib3JkZXItYm94XCI7XG4gICAgdmFyIGJvcmRlckxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckxlZnRXaWR0aCkgfHwgMDtcbiAgICB2YXIgYm9yZGVyUmlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpIHx8IDA7XG4gICAgdmFyIGJvcmRlclRvcCA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpIHx8IDA7XG4gICAgdmFyIGJvcmRlckJvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpIHx8IDA7XG4gICAgdmFyIHBhZGRpbmdMZWZ0ID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nTGVmdCkgfHwgMDtcbiAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nUmlnaHQpIHx8IDA7XG4gICAgdmFyIHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdUb3ApIHx8IDA7XG4gICAgdmFyIHBhZGRpbmdCb3R0b20gPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdCb3R0b20pIHx8IDA7XG4gICAgdmFyIGNzc1dpZHRoID0gcGFyc2VGbG9hdChzdHlsZS53aWR0aCk7XG4gICAgdmFyIGNzc0hlaWdodCA9IHBhcnNlRmxvYXQoc3R5bGUuaGVpZ2h0KTtcbiAgICB2YXIgb2Zmc2V0V2lkdGggPSBjc3NXaWR0aDtcbiAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gY3NzSGVpZ2h0O1xuICAgIHZhciBjbGllbnRXaWR0aCA9IGNzc1dpZHRoO1xuICAgIHZhciBjbGllbnRIZWlnaHQgPSBjc3NIZWlnaHQ7XG4gICAgdmFyIGhvcml6b250YWxQYWRkaW5nID0gcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQ7XG4gICAgdmFyIHZlcnRpY2FsUGFkZGluZyA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nQm90dG9tO1xuICAgIHZhciBob3Jpem9udGFsQm9yZGVyID0gYm9yZGVyTGVmdCArIGJvcmRlclJpZ2h0O1xuICAgIHZhciB2ZXJ0aWNhbEJvcmRlciA9IGJvcmRlclRvcCArIGJvcmRlckJvdHRvbTtcbiAgICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IGhvcml6b250YWxQYWRkaW5nICsgaG9yaXpvbnRhbEJvcmRlcjtcbiAgICB2YXIgdmVydGljYWxPZmZzZXQgPSB2ZXJ0aWNhbFBhZGRpbmcgKyB2ZXJ0aWNhbEJvcmRlcjtcblxuICAgIGlmIChib3hTaXppbmcpIHtcbiAgICAgIGNzc1dpZHRoID0gb2Zmc2V0V2lkdGggLSBob3Jpem9udGFsT2Zmc2V0O1xuICAgICAgY3NzSGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0IC0gdmVydGljYWxPZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldFdpZHRoID0gY3NzV2lkdGggKyBob3Jpem9udGFsT2Zmc2V0O1xuICAgICAgb2Zmc2V0SGVpZ2h0ID0gY3NzSGVpZ2h0ICsgdmVydGljYWxPZmZzZXQ7XG4gICAgfVxuXG4gICAgY2xpZW50V2lkdGggPSBjc3NXaWR0aCArIGhvcml6b250YWxQYWRkaW5nO1xuICAgIGNsaWVudEhlaWdodCA9IGNzc0hlaWdodCArIHZlcnRpY2FsUGFkZGluZztcbiAgICByZXR1cm4ge1xuICAgICAgc3ZnOiBmYWxzZSxcbiAgICAgIG9mZnNldFdpZHRoOiBvZmZzZXRXaWR0aCxcbiAgICAgIG9mZnNldEhlaWdodDogb2Zmc2V0SGVpZ2h0LFxuICAgICAgY2xpZW50V2lkdGg6IGNsaWVudFdpZHRoLFxuICAgICAgY2xpZW50SGVpZ2h0OiBjbGllbnRIZWlnaHQsXG4gICAgICBjc3NXaWR0aDogY3NzV2lkdGgsXG4gICAgICBjc3NIZWlnaHQ6IGNzc0hlaWdodFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Um90YXRpb25SYWQocG9zZXMsIGRpcmVjdGlvbikge1xuICByZXR1cm4gZ2V0UmFkKGRpcmVjdGlvbiA+IDAgPyBwb3Nlc1swXSA6IHBvc2VzWzFdLCBkaXJlY3Rpb24gPiAwID8gcG9zZXNbMV0gOiBwb3Nlc1swXSk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluZm8obW92ZWFibGVFbGVtZW50LCB0YXJnZXQsIGNvbnRhaW5lciwgcGFyZW50Q29udGFpbmVyLCByb290Q29udGFpbmVyKSB7XG4gIHZhciBiZWZvcmVEaXJlY3Rpb24gPSAxO1xuICB2YXIgYmVmb3JlT3JpZ2luID0gWzAsIDBdO1xuICB2YXIgdGFyZ2V0Q2xpZW50UmVjdCA9IHJlc2V0Q2xpZW50UmVjdCgpO1xuICB2YXIgY29udGFpbmVyQ2xpZW50UmVjdCA9IHJlc2V0Q2xpZW50UmVjdCgpO1xuICB2YXIgbW92ZWFibGVDbGllbnRSZWN0ID0gcmVzZXRDbGllbnRSZWN0KCk7XG4gIHZhciByZXN1bHQgPSBjYWxjdWxhdGVFbGVtZW50SW5mbyh0YXJnZXQsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgZmFsc2UpO1xuXG4gIGlmICh0YXJnZXQpIHtcbiAgICB2YXIgbiA9IHJlc3VsdC5pczNkID8gNCA6IDM7XG4gICAgdmFyIGJlZm9yZVBvc2l0aW9uID0gY2FsY3VsYXRlTW92ZWFibGVQb3NpdGlvbihyZXN1bHQub2Zmc2V0TWF0cml4LCBwbHVzKHJlc3VsdC50cmFuc2Zvcm1PcmlnaW4sIGdldE9yaWdpbihyZXN1bHQudGFyZ2V0TWF0cml4LCBuKSksIHJlc3VsdC53aWR0aCwgcmVzdWx0LmhlaWdodCk7XG4gICAgYmVmb3JlRGlyZWN0aW9uID0gYmVmb3JlUG9zaXRpb24uZGlyZWN0aW9uO1xuICAgIGJlZm9yZU9yaWdpbiA9IHBsdXMoYmVmb3JlUG9zaXRpb24ub3JpZ2luLCBbYmVmb3JlUG9zaXRpb24ubGVmdCAtIHJlc3VsdC5sZWZ0LCBiZWZvcmVQb3NpdGlvbi50b3AgLSByZXN1bHQudG9wXSk7XG4gICAgdGFyZ2V0Q2xpZW50UmVjdCA9IGdldENsaWVudFJlY3QodGFyZ2V0KTtcbiAgICBjb250YWluZXJDbGllbnRSZWN0ID0gZ2V0Q2xpZW50UmVjdChnZXRPZmZzZXRJbmZvKHBhcmVudENvbnRhaW5lciwgcGFyZW50Q29udGFpbmVyLCB0cnVlKS5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuYm9keSwgdHJ1ZSk7XG5cbiAgICBpZiAobW92ZWFibGVFbGVtZW50KSB7XG4gICAgICBtb3ZlYWJsZUNsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0KG1vdmVhYmxlRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9fYXNzaWduKHtcbiAgICB0YXJnZXRDbGllbnRSZWN0OiB0YXJnZXRDbGllbnRSZWN0LFxuICAgIGNvbnRhaW5lckNsaWVudFJlY3Q6IGNvbnRhaW5lckNsaWVudFJlY3QsXG4gICAgbW92ZWFibGVDbGllbnRSZWN0OiBtb3ZlYWJsZUNsaWVudFJlY3QsXG4gICAgYmVmb3JlRGlyZWN0aW9uOiBiZWZvcmVEaXJlY3Rpb24sXG4gICAgYmVmb3JlT3JpZ2luOiBiZWZvcmVPcmlnaW4sXG4gICAgb3JpZ2luYWxCZWZvcmVPcmlnaW46IGJlZm9yZU9yaWdpbixcbiAgICB0YXJnZXQ6IHRhcmdldFxuICB9LCByZXN1bHQpO1xufVxuXG5mdW5jdGlvbiByZXNldENsaWVudFJlY3QoKSB7XG4gIHJldHVybiB7XG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBjbGllbnRMZWZ0OiAwLFxuICAgIGNsaWVudFRvcDogMCxcbiAgICBjbGllbnRXaWR0aDogMCxcbiAgICBjbGllbnRIZWlnaHQ6IDAsXG4gICAgc2Nyb2xsV2lkdGg6IDAsXG4gICAgc2Nyb2xsSGVpZ2h0OiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3QoZWwsIGlzRXh0ZW5kcykge1xuICB2YXIgX2E7XG5cbiAgdmFyIGxlZnQgPSAwO1xuICB2YXIgdG9wID0gMDtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGhlaWdodCA9IDA7XG5cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB2YXIgc2Nyb2xsUG9zID0gZ2V0Qm9keVNjcm9sbFBvcygpO1xuICAgIF9hID0gWy1zY3JvbGxQb3NbMF0sIC1zY3JvbGxQb3NbMV1dLCBsZWZ0ID0gX2FbMF0sIHRvcCA9IF9hWzFdO1xuICB9IGVsc2Uge1xuICAgIHZhciBjbGllbnRSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGVmdCA9IGNsaWVudFJlY3QubGVmdDtcbiAgICB0b3AgPSBjbGllbnRSZWN0LnRvcDtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICB2YXIgcmVjdCA9IHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHJpZ2h0OiBsZWZ0ICsgd2lkdGgsXG4gICAgdG9wOiB0b3AsXG4gICAgYm90dG9tOiB0b3AgKyBoZWlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG5cbiAgaWYgKGlzRXh0ZW5kcykge1xuICAgIHJlY3QuY2xpZW50TGVmdCA9IGVsLmNsaWVudExlZnQ7XG4gICAgcmVjdC5jbGllbnRUb3AgPSBlbC5jbGllbnRUb3A7XG4gICAgcmVjdC5jbGllbnRXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgIHJlY3QuY2xpZW50SGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgIHJlY3Quc2Nyb2xsV2lkdGggPSBlbC5zY3JvbGxXaWR0aDtcbiAgICByZWN0LnNjcm9sbEhlaWdodCA9IGVsLnNjcm9sbEhlaWdodDtcbiAgICByZWN0Lm92ZXJmbG93ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkub3ZlcmZsb3cgIT09IFwidmlzaWJsZVwiO1xuICB9XG5cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldERpcmVjdGlvbih0YXJnZXQpIHtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGlyZWNpdG9uID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtZGlyZWN0aW9uXCIpO1xuXG4gIGlmICghZGlyZWNpdG9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRpciA9IFswLCAwXTtcbiAgZGlyZWNpdG9uLmluZGV4T2YoXCJ3XCIpID4gLTEgJiYgKGRpclswXSA9IC0xKTtcbiAgZGlyZWNpdG9uLmluZGV4T2YoXCJlXCIpID4gLTEgJiYgKGRpclswXSA9IDEpO1xuICBkaXJlY2l0b24uaW5kZXhPZihcIm5cIikgPiAtMSAmJiAoZGlyWzFdID0gLTEpO1xuICBkaXJlY2l0b24uaW5kZXhPZihcInNcIikgPiAtMSAmJiAoZGlyWzFdID0gMSk7XG4gIHJldHVybiBkaXI7XG59XG5cbmZ1bmN0aW9uIGdldEFic29sdXRlUG9zZXMocG9zZXMsIGRpc3QpIHtcbiAgcmV0dXJuIFtwbHVzKGRpc3QsIHBvc2VzWzBdKSwgcGx1cyhkaXN0LCBwb3Nlc1sxXSksIHBsdXMoZGlzdCwgcG9zZXNbMl0pLCBwbHVzKGRpc3QsIHBvc2VzWzNdKV07XG59XG5cbmZ1bmN0aW9uIGdldEFic29sdXRlUG9zZXNCeVN0YXRlKF9hKSB7XG4gIHZhciBsZWZ0ID0gX2EubGVmdCxcbiAgICAgIHRvcCA9IF9hLnRvcCxcbiAgICAgIHBvczEgPSBfYS5wb3MxLFxuICAgICAgcG9zMiA9IF9hLnBvczIsXG4gICAgICBwb3MzID0gX2EucG9zMyxcbiAgICAgIHBvczQgPSBfYS5wb3M0O1xuICByZXR1cm4gZ2V0QWJzb2x1dGVQb3NlcyhbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF0sIFtsZWZ0LCB0b3BdKTtcbn1cblxuZnVuY3Rpb24gcm91bmRTaWduKG51bSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gJSAxID09PSAtMC41ID8gbnVtIC0gMSA6IG51bSk7XG59XG5cbmZ1bmN0aW9uIHVuc2V0KHNlbGYsIG5hbWUpIHtcbiAgdmFyIF9hO1xuXG4gIChfYSA9IHNlbGZbbmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnNldCgpO1xuICBzZWxmW25hbWVdID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgcGFyYW1zLCBpc0JlZm9yZUV2ZW50KSB7XG4gIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgaWYgKCFkYXRhcy5kYXRhcykge1xuICAgIGRhdGFzLmRhdGFzID0ge307XG4gIH1cblxuICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7XG4gICAgdGFyZ2V0OiBtb3ZlYWJsZS5zdGF0ZS50YXJnZXQsXG4gICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICBpbnB1dEV2ZW50OiBlLmlucHV0RXZlbnQsXG4gICAgY3VycmVudFRhcmdldDogbW92ZWFibGUsXG4gICAgbW92ZWFibGU6IG1vdmVhYmxlLFxuICAgIGRhdGFzOiBkYXRhcy5kYXRhc1xuICB9KTtcblxuICBpZiAoIWRhdGFzLmlzU3RhcnRFdmVudCkge1xuICAgIGRhdGFzLmlzU3RhcnRFdmVudCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoIWlzQmVmb3JlRXZlbnQpIHtcbiAgICBkYXRhcy5sYXN0RXZlbnQgPSBuZXh0UGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIG5leHRQYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHBhcmFtcykge1xuICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuICB2YXIgaXNEcmFnID0gXCJpc0RyYWdcIiBpbiBwYXJhbXMgPyBwYXJhbXMuaXNEcmFnIDogZS5pc0RyYWc7XG5cbiAgaWYgKCFkYXRhcy5kYXRhcykge1xuICAgIGRhdGFzLmRhdGFzID0ge307XG4gIH1cblxuICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe1xuICAgIGlzRHJhZzogaXNEcmFnXG4gIH0sIHBhcmFtcyksIHtcbiAgICBtb3ZlYWJsZTogbW92ZWFibGUsXG4gICAgdGFyZ2V0OiBtb3ZlYWJsZS5zdGF0ZS50YXJnZXQsXG4gICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICBpbnB1dEV2ZW50OiBlLmlucHV0RXZlbnQsXG4gICAgY3VycmVudFRhcmdldDogbW92ZWFibGUsXG4gICAgbGFzdEV2ZW50OiBkYXRhcy5sYXN0RXZlbnQsXG4gICAgaXNEb3VibGU6IGUuaXNEb3VibGUsXG4gICAgZGF0YXM6IGRhdGFzLmRhdGFzXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjYXRjaEV2ZW50KG1vdmVhYmxlLCBuYW1lLCBjYWxsYmFjaykge1xuICBtb3ZlYWJsZS5fZW1pdHRlci5vbihuYW1lLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgbmFtZSwgcGFyYW1zLCBpc01hbmFnZXIpIHtcbiAgcmV0dXJuIG1vdmVhYmxlLnRyaWdnZXJFdmVudChuYW1lLCBwYXJhbXMsIGlzTWFuYWdlcik7XG59XG5cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWwsIHBzZXVkb0VsdCkge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIHBzZXVkb0VsdCk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckFibGVzKGFibGVzLCBtZXRob2RzLCB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSkge1xuICB2YXIgZW5hYmxlZEFibGVzID0ge307XG4gIHZhciBhYmxlR3JvdXBzID0ge307XG4gIHJldHVybiBhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICB2YXIgbmFtZSA9IGFibGUubmFtZTtcblxuICAgIGlmIChlbmFibGVkQWJsZXNbbmFtZV0gfHwgIW1ldGhvZHMuc29tZShmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICByZXR1cm4gYWJsZVttZXRob2RdO1xuICAgIH0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSAmJiBhYmxlLmFibGVHcm91cCkge1xuICAgICAgaWYgKGFibGVHcm91cHNbYWJsZS5hYmxlR3JvdXBdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgYWJsZUdyb3Vwc1thYmxlLmFibGVHcm91cF0gPSB0cnVlO1xuICAgIH1cblxuICAgIGVuYWJsZWRBYmxlc1tuYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlcXVhbHMoYTEsIGEyKSB7XG4gIHJldHVybiBhMSA9PT0gYTIgfHwgYTEgPT0gbnVsbCAmJiBhMiA9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RWYWx1ZSgpIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFsdWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCAtIDE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgIGlmICghaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlc1tsZW5ndGhdO1xufVxuXG5mdW5jdGlvbiBncm91cEJ5KGFyciwgZnVuYykge1xuICB2YXIgZ3JvdXBzID0gW107XG4gIHZhciBncm91cEtleXMgPSBbXTtcbiAgYXJyLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpbmRleCkge1xuICAgIHZhciBncm91cEtleSA9IGZ1bmMoZWwsIGluZGV4LCBhcnIpO1xuICAgIHZhciBrZXlJbmRleCA9IGdyb3VwS2V5cy5pbmRleE9mKGdyb3VwS2V5KTtcbiAgICB2YXIgZ3JvdXAgPSBncm91cHNba2V5SW5kZXhdIHx8IFtdO1xuXG4gICAgaWYgKGtleUluZGV4ID09PSAtMSkge1xuICAgICAgZ3JvdXBLZXlzLnB1c2goZ3JvdXBLZXkpO1xuICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgIH1cblxuICAgIGdyb3VwLnB1c2goZWwpO1xuICB9KTtcbiAgcmV0dXJuIGdyb3Vwcztcbn1cblxuZnVuY3Rpb24gZ3JvdXBCeU1hcChhcnIsIGZ1bmMpIHtcbiAgdmFyIGdyb3VwcyA9IFtdO1xuICB2YXIgZ3JvdXBLZXlzID0ge307XG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcbiAgICB2YXIgZ3JvdXBLZXkgPSBmdW5jKGVsLCBpbmRleCwgYXJyKTtcbiAgICB2YXIgZ3JvdXAgPSBncm91cEtleXNbZ3JvdXBLZXldO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgZ3JvdXAgPSBbXTtcbiAgICAgIGdyb3VwS2V5c1tncm91cEtleV0gPSBncm91cDtcbiAgICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICB9XG5cbiAgICBncm91cC5wdXNoKGVsKTtcbiAgfSk7XG4gIHJldHVybiBncm91cHM7XG59XG5cbmZ1bmN0aW9uIGZsYXQoYXJyKSB7XG4gIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICByZXR1cm4gcHJldi5jb25jYXQoY3VyKTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBtYXhPZmZzZXQoKSB7XG4gIHZhciBhcmdzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICBhcmdzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYikgLSBNYXRoLmFicyhhKTtcbiAgfSk7XG4gIHJldHVybiBhcmdzWzBdO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24obWF0cml4LCBwb3MsIG4pIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZShpbnZlcnQobWF0cml4LCBuKSwgY29udmVydFBvc2l0aW9uTWF0cml4KHBvcywgbiksIG4pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0RHJhZ0Rpc3Qoc3RhdGUsIGUpIHtcbiAgdmFyIF9hO1xuXG4gIHZhciBpczNkID0gc3RhdGUuaXMzZCxcbiAgICAgIHJvb3RNYXRyaXggPSBzdGF0ZS5yb290TWF0cml4O1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgX2EgPSBjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW2UuZGlzdFgsIGUuZGlzdFldLCBuKSwgZS5kaXN0WCA9IF9hWzBdLCBlLmRpc3RZID0gX2FbMV07XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQYWRkaW5nKG1hdHJpeCwgcG9zLCB0cmFuc2Zvcm1PcmlnaW4sIG9yaWdpbiwgbikge1xuICByZXR1cm4gbWludXMoY2FsY3VsYXRlUG9zaXRpb24obWF0cml4LCBwbHVzKHRyYW5zZm9ybU9yaWdpbiwgcG9zKSwgbiksIG9yaWdpbik7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRDU1NTaXplKHZhbHVlLCBzaXplLCBpc1JlbGF0aXZlKSB7XG4gIHJldHVybiBpc1JlbGF0aXZlID8gXCJcIi5jb25jYXQodmFsdWUgLyBzaXplICogMTAwLCBcIiVcIikgOiBcIlwiLmNvbmNhdCh2YWx1ZSwgXCJweFwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGlueURpc3Qodikge1xuICByZXR1cm4gTWF0aC5hYnModikgPD0gVElOWV9OVU0gPyAwIDogdjtcbn1cblxuZnVuY3Rpb24gZGlyZWN0aW9uQ29uZGl0aW9uKG1vdmVhYmxlLCBlKSB7XG4gIGlmIChlLmlzUmVxdWVzdCkge1xuICAgIGlmIChlLnJlcXVlc3RBYmxlID09PSBcInJlc2l6YWJsZVwiIHx8IGUucmVxdWVzdEFibGUgPT09IFwic2NhbGFibGVcIikge1xuICAgICAgcmV0dXJuIGUucGFyZW50RGlyZWN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc0NsYXNzKGUuaW5wdXRFdmVudC50YXJnZXQsIHByZWZpeChcImRpcmVjdGlvblwiKSk7XG59XG5cbmZ1bmN0aW9uIGludmVydE9iamVjdChvYmopIHtcbiAgdmFyIG5leHRPYmogPSB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIG9iaikge1xuICAgIG5leHRPYmpbb2JqW25hbWVdXSA9IG5hbWU7XG4gIH1cblxuICByZXR1cm4gbmV4dE9iajtcbn1cblxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybUluZm8odHJhbnNmb3JtcywgaW5kZXgpIHtcbiAgdmFyIGJlZm9yZUZ1bmN0aW9uVGV4dHMgPSB0cmFuc2Zvcm1zLnNsaWNlKDAsIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGluZGV4KTtcbiAgdmFyIGJlZm9yZUZ1bmN0aW9uVGV4dHMyID0gdHJhbnNmb3Jtcy5zbGljZSgwLCBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBpbmRleCArIDEpO1xuICB2YXIgdGFyZ2V0RnVuY3Rpb25UZXh0ID0gdHJhbnNmb3Jtc1tpbmRleF0gfHwgXCJcIjtcbiAgdmFyIGFmdGVyRnVuY3Rpb25UZXh0cyA9IGluZGV4IDwgMCA/IFtdIDogdHJhbnNmb3Jtcy5zbGljZShpbmRleCk7XG4gIHZhciBhZnRlckZ1bmN0aW9uVGV4dHMyID0gaW5kZXggPCAwID8gW10gOiB0cmFuc2Zvcm1zLnNsaWNlKGluZGV4ICsgMSk7XG4gIHZhciBiZWZvcmVGdW5jdGlvbnMgPSBwYXJzZShiZWZvcmVGdW5jdGlvblRleHRzKTtcbiAgdmFyIGJlZm9yZUZ1bmN0aW9uczIgPSBwYXJzZShiZWZvcmVGdW5jdGlvblRleHRzMik7XG4gIHZhciB0YXJnZXRGdW5jdGlvbnMgPSBwYXJzZShbdGFyZ2V0RnVuY3Rpb25UZXh0XSk7XG4gIHZhciBhZnRlckZ1bmN0aW9ucyA9IHBhcnNlKGFmdGVyRnVuY3Rpb25UZXh0cyk7XG4gIHZhciBhZnRlckZ1bmN0aW9uczIgPSBwYXJzZShhZnRlckZ1bmN0aW9uVGV4dHMyKTtcbiAgdmFyIGJlZm9yZUZ1bmN0aW9uTWF0cml4ID0gdG9NYXQoYmVmb3JlRnVuY3Rpb25zKTtcbiAgdmFyIGJlZm9yZUZ1bmN0aW9uTWF0cml4MiA9IHRvTWF0KGJlZm9yZUZ1bmN0aW9uczIpO1xuICB2YXIgYWZ0ZXJGdW5jdGlvbk1hdHJpeCA9IHRvTWF0KGFmdGVyRnVuY3Rpb25zKTtcbiAgdmFyIGFmdGVyRnVuY3Rpb25NYXRyaXgyID0gdG9NYXQoYWZ0ZXJGdW5jdGlvbnMyKTtcbiAgdmFyIGFsbEZ1bmN0aW9uTWF0cml4ID0gbXVsdGlwbHkoYmVmb3JlRnVuY3Rpb25NYXRyaXgsIGFmdGVyRnVuY3Rpb25NYXRyaXgsIDQpO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybXM6IHRyYW5zZm9ybXMsXG4gICAgYmVmb3JlRnVuY3Rpb25NYXRyaXg6IGJlZm9yZUZ1bmN0aW9uTWF0cml4LFxuICAgIGJlZm9yZUZ1bmN0aW9uTWF0cml4MjogYmVmb3JlRnVuY3Rpb25NYXRyaXgyLFxuICAgIHRhcmdldEZ1bmN0aW9uTWF0cml4OiB0b01hdCh0YXJnZXRGdW5jdGlvbnMpLFxuICAgIGFmdGVyRnVuY3Rpb25NYXRyaXg6IGFmdGVyRnVuY3Rpb25NYXRyaXgsXG4gICAgYWZ0ZXJGdW5jdGlvbk1hdHJpeDI6IGFmdGVyRnVuY3Rpb25NYXRyaXgyLFxuICAgIGFsbEZ1bmN0aW9uTWF0cml4OiBhbGxGdW5jdGlvbk1hdHJpeCxcbiAgICBiZWZvcmVGdW5jdGlvbnM6IGJlZm9yZUZ1bmN0aW9ucyxcbiAgICBiZWZvcmVGdW5jdGlvbnMyOiBiZWZvcmVGdW5jdGlvbnMyLFxuICAgIHRhcmdldEZ1bmN0aW9uOiB0YXJnZXRGdW5jdGlvbnNbMF0sXG4gICAgYWZ0ZXJGdW5jdGlvbnM6IGFmdGVyRnVuY3Rpb25zLFxuICAgIGFmdGVyRnVuY3Rpb25zMjogYWZ0ZXJGdW5jdGlvbnMyLFxuICAgIGJlZm9yZUZ1bmN0aW9uVGV4dHM6IGJlZm9yZUZ1bmN0aW9uVGV4dHMsXG4gICAgYmVmb3JlRnVuY3Rpb25UZXh0czI6IGJlZm9yZUZ1bmN0aW9uVGV4dHMyLFxuICAgIHRhcmdldEZ1bmN0aW9uVGV4dDogdGFyZ2V0RnVuY3Rpb25UZXh0LFxuICAgIGFmdGVyRnVuY3Rpb25UZXh0czogYWZ0ZXJGdW5jdGlvblRleHRzLFxuICAgIGFmdGVyRnVuY3Rpb25UZXh0czI6IGFmdGVyRnVuY3Rpb25UZXh0czJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheUZvcm1hdChhcnIpIHtcbiAgaWYgKCFhcnIgfHwgIWlzT2JqZWN0KGFycikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYXJyIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5KGFycikgfHwgXCJsZW5ndGhcIiBpbiBhcnI7XG59XG5cbmZ1bmN0aW9uIGdldFJlZlRhcmdldCh0YXJnZXQsIGlzU2VsZWN0b3IpIHtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XG4gICAgaWYgKGlzU2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGlmIChpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0KCk7XG4gIH1cblxuICBpZiAoXCJjdXJyZW50XCIgaW4gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5jdXJyZW50O1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVmVGFyZ2V0cyh0YXJnZXRzLCBpc1NlbGVjdG9yKSB7XG4gIGlmICghdGFyZ2V0cykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciB1c2VyVGFyZ2V0cyA9IGlzQXJyYXlGb3JtYXQodGFyZ2V0cykgPyBbXS5zbGljZS5jYWxsKHRhcmdldHMpIDogW3RhcmdldHNdO1xuICByZXR1cm4gdXNlclRhcmdldHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCB0YXJnZXQpIHtcbiAgICBpZiAoaXNTdHJpbmcodGFyZ2V0KSAmJiBpc1NlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2LCB0cnVlKSwgW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldCkpLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwcmV2LnB1c2goZ2V0UmVmVGFyZ2V0KHRhcmdldCwgaXNTZWxlY3RvcikpO1xuICAgIHJldHVybiBwcmV2O1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRUYXJnZXRzKHRhcmdldHMsIHNlbGVjdG9yTWFwKSB7XG4gIHZhciBlbGVtZW50VGFyZ2V0cyA9IFtdO1xuICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKHRhcmdldCkpIHtcbiAgICAgIGlmIChzZWxlY3Rvck1hcFt0YXJnZXRdKSB7XG4gICAgICAgIGVsZW1lbnRUYXJnZXRzLnB1c2guYXBwbHkoZWxlbWVudFRhcmdldHMsIHNlbGVjdG9yTWFwW3RhcmdldF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudFRhcmdldHMucHVzaCh0YXJnZXQpO1xuICB9KTtcbiAgcmV0dXJuIGVsZW1lbnRUYXJnZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVJvdGF0aW9uKHBvczEsIHBvczIsIGRpcmVjdGlvbikge1xuICB2YXIgZGVnID0gZ2V0UmFkKHBvczEsIHBvczIpIC8gTWF0aC5QSSAqIDE4MDtcbiAgZGVnID0gZGlyZWN0aW9uID49IDAgPyBkZWcgOiAxODAgLSBkZWc7XG4gIGRlZyA9IGRlZyA+PSAwID8gZGVnIDogMzYwICsgZGVnO1xuICByZXR1cm4gZGVnO1xufVxuXG5mdW5jdGlvbiBnZXREcmFnRGlzdEJ5U3RhdGUoc3RhdGUsIGRpc3QpIHtcbiAgdmFyIHJvb3RNYXRyaXggPSBzdGF0ZS5yb290TWF0cml4LFxuICAgICAgaXMzZCA9IHN0YXRlLmlzM2Q7XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICB2YXIgaW52ZXJzZU1hdHJpeCA9IGludmVydChyb290TWF0cml4LCBuKTtcblxuICBpZiAoIWlzM2QpIHtcbiAgICBpbnZlcnNlTWF0cml4ID0gY29udmVydERpbWVuc2lvbihpbnZlcnNlTWF0cml4LCAzLCA0KTtcbiAgfVxuXG4gIGludmVyc2VNYXRyaXhbMTJdID0gMDtcbiAgaW52ZXJzZU1hdHJpeFsxM10gPSAwO1xuICBpbnZlcnNlTWF0cml4WzE0XSA9IDA7XG4gIHJldHVybiBjYWxjdWxhdGVNYXRyaXhEaXN0KGludmVyc2VNYXRyaXgsIGRpc3QpO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplRGlzdEJ5RGlzdChzdGFydFNpemUsIGRpc3QsIHJhdGlvLCBkaXJlY3Rpb24sIGtlZXBSYXRpbykge1xuICB2YXIgc3RhcnRPZmZzZXRXaWR0aCA9IHN0YXJ0U2l6ZVswXSxcbiAgICAgIHN0YXJ0T2Zmc2V0SGVpZ2h0ID0gc3RhcnRTaXplWzFdO1xuICB2YXIgZGlzdFdpZHRoID0gMDtcbiAgdmFyIGRpc3RIZWlnaHQgPSAwO1xuXG4gIGlmIChrZWVwUmF0aW8gJiYgc3RhcnRPZmZzZXRXaWR0aCAmJiBzdGFydE9mZnNldEhlaWdodCkge1xuICAgIHZhciByYWQgPSBnZXRSYWQoWzAsIDBdLCBkaXN0KTtcbiAgICB2YXIgc3RhbmRhcmRSYWQgPSBnZXRSYWQoWzAsIDBdLCBkaXJlY3Rpb24pO1xuICAgIHZhciBzaXplID0gZ2V0RGlzdFNpemUoZGlzdCk7XG4gICAgdmFyIHNpZ25TaXplID0gTWF0aC5jb3MocmFkIC0gc3RhbmRhcmRSYWQpICogc2l6ZTtcblxuICAgIGlmICghZGlyZWN0aW9uWzBdKSB7XG4gICAgICAvLyB0b3AsIGJvdHRvbVxuICAgICAgZGlzdEhlaWdodCA9IHNpZ25TaXplO1xuICAgICAgZGlzdFdpZHRoID0gZGlzdEhlaWdodCAqIHJhdGlvO1xuICAgIH0gZWxzZSBpZiAoIWRpcmVjdGlvblsxXSkge1xuICAgICAgLy8gbGVmdCwgcmlnaHRcbiAgICAgIGRpc3RXaWR0aCA9IHNpZ25TaXplO1xuICAgICAgZGlzdEhlaWdodCA9IGRpc3RXaWR0aCAvIHJhdGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0d28td2F5XG4gICAgICB2YXIgc3RhcnRXaWR0aFNpemUgPSBkaXJlY3Rpb25bMF0gKiAyICogc3RhcnRPZmZzZXRXaWR0aDtcbiAgICAgIHZhciBzdGFydEhlaWdodFNpemUgPSBkaXJlY3Rpb25bMV0gKiAyICogc3RhcnRPZmZzZXRIZWlnaHQ7XG4gICAgICB2YXIgZGlzdFNpemUgPSBnZXREaXN0U2l6ZShbc3RhcnRXaWR0aFNpemUgKyBkaXN0WzBdLCBzdGFydEhlaWdodFNpemUgKyBkaXN0WzFdXSkgLSBnZXREaXN0U2l6ZShbc3RhcnRXaWR0aFNpemUsIHN0YXJ0SGVpZ2h0U2l6ZV0pO1xuICAgICAgdmFyIHJhdGlvUmFkID0gZ2V0UmFkKFswLCAwXSwgW3JhdGlvLCAxXSk7XG4gICAgICBkaXN0V2lkdGggPSBNYXRoLmNvcyhyYXRpb1JhZCkgKiBkaXN0U2l6ZTtcbiAgICAgIGRpc3RIZWlnaHQgPSBNYXRoLnNpbihyYXRpb1JhZCkgKiBkaXN0U2l6ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGlzdFdpZHRoID0gZGlyZWN0aW9uWzBdICogZGlzdFswXTtcbiAgICBkaXN0SGVpZ2h0ID0gZGlyZWN0aW9uWzFdICogZGlzdFsxXTtcbiAgfVxuXG4gIHJldHVybiBbZGlzdFdpZHRoLCBkaXN0SGVpZ2h0XTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0U2l6ZURpc3Qoc2l6ZURpcmVjdGlvbiwga2VlcFJhdGlvLCBkYXRhcywgZSkge1xuICB2YXIgX2E7XG5cbiAgdmFyIHJhdGlvID0gZGF0YXMucmF0aW8sXG4gICAgICBzdGFydE9mZnNldFdpZHRoID0gZGF0YXMuc3RhcnRPZmZzZXRXaWR0aCxcbiAgICAgIHN0YXJ0T2Zmc2V0SGVpZ2h0ID0gZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQ7XG4gIHZhciBkaXN0V2lkdGggPSAwO1xuICB2YXIgZGlzdEhlaWdodCA9IDA7XG4gIHZhciBkaXN0WCA9IGUuZGlzdFgsXG4gICAgICBkaXN0WSA9IGUuZGlzdFksXG4gICAgICBwYXJlbnREaXN0YW5jZSA9IGUucGFyZW50RGlzdGFuY2UsXG4gICAgICBwYXJlbnREaXN0ID0gZS5wYXJlbnREaXN0LFxuICAgICAgcGFyZW50U2NhbGUgPSBlLnBhcmVudFNjYWxlLFxuICAgICAgaXNQaW5jaCA9IGUuaXNQaW5jaDtcbiAgdmFyIHN0YXJ0Rml4ZWREaXJlY3Rpb24gPSBkYXRhcy5maXhlZERpcmVjdGlvbjtcblxuICBpZiAocGFyZW50RGlzdCkge1xuICAgIGRpc3RXaWR0aCA9IHBhcmVudERpc3RbMF07XG4gICAgZGlzdEhlaWdodCA9IHBhcmVudERpc3RbMV07XG5cbiAgICBpZiAoa2VlcFJhdGlvKSB7XG4gICAgICBpZiAoIWRpc3RXaWR0aCkge1xuICAgICAgICBkaXN0V2lkdGggPSBkaXN0SGVpZ2h0ICogcmF0aW87XG4gICAgICB9IGVsc2UgaWYgKCFkaXN0SGVpZ2h0KSB7XG4gICAgICAgIGRpc3RIZWlnaHQgPSBkaXN0V2lkdGggLyByYXRpbztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50U2NhbGUpIHtcbiAgICBkaXN0V2lkdGggPSAocGFyZW50U2NhbGVbMF0gLSAxKSAqIHN0YXJ0T2Zmc2V0V2lkdGg7XG4gICAgZGlzdEhlaWdodCA9IChwYXJlbnRTY2FsZVsxXSAtIDEpICogc3RhcnRPZmZzZXRIZWlnaHQ7XG4gIH0gZWxzZSBpZiAoaXNQaW5jaCkge1xuICAgIGlmIChwYXJlbnREaXN0YW5jZSkge1xuICAgICAgZGlzdFdpZHRoID0gcGFyZW50RGlzdGFuY2U7XG4gICAgICBkaXN0SGVpZ2h0ID0gcGFyZW50RGlzdGFuY2UgKiBzdGFydE9mZnNldEhlaWdodCAvIHN0YXJ0T2Zmc2V0V2lkdGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXN0XzEgPSBnZXREcmFnRGlzdCh7XG4gICAgICBkYXRhczogZGF0YXMsXG4gICAgICBkaXN0WDogZGlzdFgsXG4gICAgICBkaXN0WTogZGlzdFlcbiAgICB9KTtcbiAgICBkaXN0XzEgPSBbMCwgMV0ubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgdmFyIGRpcmVjdGlvblJhdGlvID0gTWF0aC5hYnMoc2l6ZURpcmVjdGlvbltpbmRleF0gLSBzdGFydEZpeGVkRGlyZWN0aW9uW2luZGV4XSk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb25SYXRpbyAhPT0gMCkge1xuICAgICAgICBkaXJlY3Rpb25SYXRpbyA9IDIgLyBkaXJlY3Rpb25SYXRpbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpc3RfMVtpbmRleF0gKiBkaXJlY3Rpb25SYXRpbztcbiAgICB9KTtcbiAgICBfYSA9IGdldFNpemVEaXN0QnlEaXN0KFtzdGFydE9mZnNldFdpZHRoLCBzdGFydE9mZnNldEhlaWdodF0sIGRpc3RfMSwgcmF0aW8sIHNpemVEaXJlY3Rpb24sIGtlZXBSYXRpbyksIGRpc3RXaWR0aCA9IF9hWzBdLCBkaXN0SGVpZ2h0ID0gX2FbMV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIGRpcmVjdGlvbixcbiAgICAvLyBzaXplRGlyZWN0aW9uLFxuICAgIGRpc3RXaWR0aDogZGlzdFdpZHRoLFxuICAgIGRpc3RIZWlnaHQ6IGRpc3RIZWlnaHRcbiAgfTtcbn1cbi8qKlxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5QaW5jaGFibGVcbiAqIEBkZXNjcmlwdGlvbiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHBpbmNoZWQgd2l0aCBkcmFnZ2FibGUsIHJlc2l6YWJsZSwgc2NhbGFibGUsIHJvdGF0YWJsZSAoZGVmYXVsdDogZmFsc2UpXG4gKi9cblxuXG52YXIgUGluY2hhYmxlID0gbWFrZUFibGUoXCJwaW5jaGFibGVcIiwge1xuICBldmVudHM6IHtcbiAgICBvblBpbmNoU3RhcnQ6IFwicGluY2hTdGFydFwiLFxuICAgIG9uUGluY2g6IFwicGluY2hcIixcbiAgICBvblBpbmNoRW5kOiBcInBpbmNoRW5kXCIsXG4gICAgb25QaW5jaEdyb3VwU3RhcnQ6IFwicGluY2hHcm91cFN0YXJ0XCIsXG4gICAgb25QaW5jaEdyb3VwOiBcInBpbmNoR3JvdXBcIixcbiAgICBvblBpbmNoR3JvdXBFbmQ6IFwicGluY2hHcm91cEVuZFwiXG4gIH0sXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwaW5jaFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICB0YXJnZXRzID0gZS50YXJnZXRzLFxuICAgICAgICBhbmdsZSA9IGUuYW5nbGUsXG4gICAgICAgIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXM7XG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICAgIHBpbmNoYWJsZSA9IF9hLnBpbmNoYWJsZSxcbiAgICAgICAgYWJsZXMgPSBfYS5hYmxlcztcblxuICAgIGlmICghcGluY2hhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50TmFtZSA9IFwib25QaW5jaFwiLmNvbmNhdCh0YXJnZXRzID8gXCJHcm91cFwiIDogXCJcIiwgXCJTdGFydFwiKTtcbiAgICB2YXIgY29udHJvbEV2ZW50TmFtZSA9IFwiZHJhZ1wiLmNvbmNhdCh0YXJnZXRzID8gXCJHcm91cFwiIDogXCJcIiwgXCJDb250cm9sU3RhcnRcIik7XG4gICAgdmFyIHBpbmNoQWJsZXMgPSAocGluY2hhYmxlID09PSB0cnVlID8gbW92ZWFibGUuY29udHJvbEFibGVzIDogYWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICByZXR1cm4gcGluY2hhYmxlLmluZGV4T2YoYWJsZS5uYW1lKSA+IC0xO1xuICAgIH0pKS5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIHJldHVybiBhYmxlLmNhblBpbmNoICYmIGFibGVbY29udHJvbEV2ZW50TmFtZV07XG4gICAgfSk7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHt9KTtcblxuICAgIGlmICh0YXJnZXRzKSB7XG4gICAgICBwYXJhbXMudGFyZ2V0cyA9IHRhcmdldHM7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgZXZlbnROYW1lLCBwYXJhbXMpO1xuICAgIGRhdGFzLmlzUGluY2ggPSByZXN1bHQgIT09IGZhbHNlO1xuICAgIGRhdGFzLmFibGVzID0gcGluY2hBYmxlcztcbiAgICB2YXIgaXNQaW5jaCA9IGRhdGFzLmlzUGluY2g7XG5cbiAgICBpZiAoIWlzUGluY2gpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwaW5jaEFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIG9yaWdpbmFsRGF0YXNbYWJsZS5uYW1lXSA9IG9yaWdpbmFsRGF0YXNbYWJsZS5uYW1lXSB8fCB7fTtcblxuICAgICAgaWYgKCFhYmxlW2NvbnRyb2xFdmVudE5hbWVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFibGVFdmVudCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgICBkYXRhczogb3JpZ2luYWxEYXRhc1thYmxlLm5hbWVdLFxuICAgICAgICBwYXJlbnRSb3RhdGU6IGFuZ2xlLFxuICAgICAgICBpc1BpbmNoOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgYWJsZVtjb250cm9sRXZlbnROYW1lXShtb3ZlYWJsZSwgYWJsZUV2ZW50KTtcbiAgICB9KTtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcbiAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxuICAgICAgZGlyZWN0aW9uOiBbMCwgMF1cbiAgICB9O1xuICAgIHJldHVybiBpc1BpbmNoO1xuICB9LFxuICBwaW5jaDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgcGluY2hTY2FsZSA9IGUuc2NhbGUsXG4gICAgICAgIGRpc3RhbmNlID0gZS5kaXN0YW5jZSxcbiAgICAgICAgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcyxcbiAgICAgICAgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudCxcbiAgICAgICAgdGFyZ2V0cyA9IGUudGFyZ2V0cyxcbiAgICAgICAgYW5nbGUgPSBlLmFuZ2xlO1xuXG4gICAgaWYgKCFkYXRhcy5pc1BpbmNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudERpc3RhbmNlID0gZGlzdGFuY2UgKiAoMSAtIDEgLyBwaW5jaFNjYWxlKTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xuXG4gICAgaWYgKHRhcmdldHMpIHtcbiAgICAgIHBhcmFtcy50YXJnZXRzID0gdGFyZ2V0cztcbiAgICB9XG5cbiAgICB2YXIgZXZlbnROYW1lID0gXCJvblBpbmNoXCIuY29uY2F0KHRhcmdldHMgPyBcIkdyb3VwXCIgOiBcIlwiKTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIGV2ZW50TmFtZSwgcGFyYW1zKTtcbiAgICB2YXIgYWJsZXMgPSBkYXRhcy5hYmxlcztcbiAgICB2YXIgY29udHJvbEV2ZW50TmFtZSA9IFwiZHJhZ1wiLmNvbmNhdCh0YXJnZXRzID8gXCJHcm91cFwiIDogXCJcIiwgXCJDb250cm9sXCIpO1xuICAgIGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIGlmICghYWJsZVtjb250cm9sRXZlbnROYW1lXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFibGVbY29udHJvbEV2ZW50TmFtZV0obW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgICBkYXRhczogb3JpZ2luYWxEYXRhc1thYmxlLm5hbWVdLFxuICAgICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50LFxuICAgICAgICBwYXJlbnREaXN0YW5jZTogcGFyZW50RGlzdGFuY2UsXG4gICAgICAgIHBhcmVudFJvdGF0ZTogYW5nbGUsXG4gICAgICAgIGlzUGluY2g6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9LFxuICBwaW5jaEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgaXNQaW5jaCA9IGUuaXNQaW5jaCxcbiAgICAgICAgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudCxcbiAgICAgICAgdGFyZ2V0cyA9IGUudGFyZ2V0cyxcbiAgICAgICAgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNQaW5jaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBldmVudE5hbWUgPSBcIm9uUGluY2hcIi5jb25jYXQodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIsIFwiRW5kXCIpO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc0RyYWc6IGlzUGluY2hcbiAgICB9KTtcblxuICAgIGlmICh0YXJnZXRzKSB7XG4gICAgICBwYXJhbXMudGFyZ2V0cyA9IHRhcmdldHM7XG4gICAgfVxuXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBldmVudE5hbWUsIHBhcmFtcyk7XG4gICAgdmFyIGFibGVzID0gZGF0YXMuYWJsZXM7XG4gICAgdmFyIGNvbnRyb2xFdmVudE5hbWUgPSBcImRyYWdcIi5jb25jYXQodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIsIFwiQ29udHJvbEVuZFwiKTtcbiAgICBhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICBpZiAoIWFibGVbY29udHJvbEV2ZW50TmFtZV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhYmxlW2NvbnRyb2xFdmVudE5hbWVdKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgICAgaXNEcmFnOiBpc1BpbmNoLFxuICAgICAgICBkYXRhczogb3JpZ2luYWxEYXRhc1thYmxlLm5hbWVdLFxuICAgICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50LFxuICAgICAgICBpc1BpbmNoOiB0cnVlXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzUGluY2g7XG4gIH0sXG4gIHBpbmNoR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMucGluY2hTdGFydChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgfSkpO1xuICB9LFxuICBwaW5jaEdyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5waW5jaChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgfSkpO1xuICB9LFxuICBwaW5jaEdyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5waW5jaEVuZChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgfSkpO1xuICB9XG59KTtcbi8qKlxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBwaW5jaGVkIHdpdGggZHJhZ2dhYmxlLCByZXNpemFibGUsIHNjYWxhYmxlLCByb3RhdGFibGUgKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuUGluY2hhYmxlI3BpbmNoYWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5waW5jaGFibGUgPSB0cnVlO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgcGluY2ggc3RhcnRzLCB0aGUgcGluY2hTdGFydCBldmVudCBpcyBjYWxsZWQgd2l0aCBwYXJ0IG9mIHNjYWxlU3RhcnQsIHJvdGF0ZVN0YXJ0LCByZXNpemVTdGFydFxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlBpbmNoYWJsZVxuICogQGV2ZW50IHBpbmNoU3RhcnRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2hTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcGluY2hTdGFydCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgcm90YXRhYmxlOiB0cnVlLFxuICogICAgIHNjYWxhYmxlOiB0cnVlLFxuICogICAgIHBpbmNoYWJsZTogdHJ1ZSwgLy8gW1wicm90YXRhYmxlXCIsIFwic2NhbGFibGVcIl1cbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJwaW5jaFN0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3RhdGVTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gcGluY2hpbmcsIHRoZSBwaW5jaCBldmVudCBpcyBjYWxsZWQgd2l0aCBwYXJ0IG9mIHNjYWxlLCByb3RhdGUsIHJlc2l6ZVxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlBpbmNoYWJsZVxuICogQGV2ZW50IHBpbmNoXG4gKiBAcGFyYW0ge01vdmVhYmxlLlBpbmNoYWJsZS5PblBpbmNofSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBwaW5jaCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgcm90YXRhYmxlOiB0cnVlLFxuICogICAgIHNjYWxhYmxlOiB0cnVlLFxuICogICAgIHBpbmNoYWJsZTogdHJ1ZSwgLy8gW1wicm90YXRhYmxlXCIsIFwic2NhbGFibGVcIl1cbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJwaW5jaFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlXCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJzY2FsZVwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIHBpbmNoIGZpbmlzaGVzLCB0aGUgcGluY2hFbmQgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlBpbmNoYWJsZVxuICogQGV2ZW50IHBpbmNoRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLlBpbmNoYWJsZS5PblBpbmNoRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBwaW5jaEVuZCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgcm90YXRhYmxlOiB0cnVlLFxuICogICAgIHNjYWxhYmxlOiB0cnVlLFxuICogICAgIHBpbmNoYWJsZTogdHJ1ZSwgLy8gW1wicm90YXRhYmxlXCIsIFwic2NhbGFibGVcIl1cbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJwaW5jaEVuZFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlRW5kXCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJzY2FsZUVuZFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIGdyb3VwIHBpbmNoIHN0YXJ0cywgdGhlIGBwaW5jaEdyb3VwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5QaW5jaGFibGVcbiAqIEBldmVudCBwaW5jaEdyb3VwU3RhcnRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2hHcm91cFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcGluY2hHcm91cFN0YXJ0YCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqICAgICBwaW5jaGFibGU6IHRydWVcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJwaW5jaEdyb3VwU3RhcnRcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvblBpbmNoR3JvdXBTdGFydFwiLCB0YXJnZXRzKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgZ3JvdXAgcGluY2gsIHRoZSBgcGluY2hHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlBpbmNoYWJsZVxuICogQGV2ZW50IHBpbmNoR3JvdXBcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2hHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHBpbmNoR3JvdXBgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuICogICAgIHBpbmNoYWJsZTogdHJ1ZVxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInBpbmNoR3JvdXBcIiwgKHsgdGFyZ2V0cywgZXZlbnRzIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUGluY2hHcm91cFwiLCB0YXJnZXRzKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgZ3JvdXAgcGluY2ggZmluaXNoZXMsIHRoZSBgcGluY2hHcm91cEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlBpbmNoYWJsZVxuICogQGV2ZW50IHBpbmNoR3JvdXBFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2hHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHBpbmNoR3JvdXBFbmRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuICogICAgIHBpbmNoYWJsZTogdHJ1ZVxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInBpbmNoR3JvdXBFbmRcIiwgKHsgdGFyZ2V0cywgaXNEcmFnIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUGluY2hHcm91cEVuZFwiLCB0YXJnZXRzLCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIFJlc2l6YWJsZVxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZGVzY3JpcHRpb24gUmVzaXphYmxlIGluZGljYXRlcyB3aGV0aGVyIHRoZSB0YXJnZXQncyB3aWR0aCBhbmQgaGVpZ2h0IGNhbiBiZSBpbmNyZWFzZWQgb3IgZGVjcmVhc2VkLlxuICovXG5cbnZhciBSZXNpemFibGUgPSB7XG4gIG5hbWU6IFwicmVzaXphYmxlXCIsXG4gIGFibGVHcm91cDogXCJzaXplXCIsXG4gIGNhblBpbmNoOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHJlc2l6YWJsZTogQm9vbGVhbixcbiAgICB0aHJvdHRsZVJlc2l6ZTogTnVtYmVyLFxuICAgIHJlbmRlckRpcmVjdGlvbnM6IEFycmF5LFxuICAgIGtlZXBSYXRpbzogQm9vbGVhbixcbiAgICByZXNpemVGb3JtYXQ6IEZ1bmN0aW9uXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uUmVzaXplU3RhcnQ6IFwicmVzaXplU3RhcnRcIixcbiAgICBvbkJlZm9yZVJlc2l6ZTogXCJiZWZvcmVSZXNpemVcIixcbiAgICBvblJlc2l6ZTogXCJyZXNpemVcIixcbiAgICBvblJlc2l6ZUVuZDogXCJyZXNpemVFbmRcIixcbiAgICBvblJlc2l6ZUdyb3VwU3RhcnQ6IFwicmVzaXplR3JvdXBTdGFydFwiLFxuICAgIG9uQmVmb3JlUmVzaXplR3JvdXA6IFwiYmVmb3JlUmVzaXplR3JvdXBcIixcbiAgICBvblJlc2l6ZUdyb3VwOiBcInJlc2l6ZUdyb3VwXCIsXG4gICAgb25SZXNpemVHcm91cEVuZDogXCJyZXNpemVHcm91cEVuZFwiXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICByZXNpemFibGUgPSBfYS5yZXNpemFibGUsXG4gICAgICAgIGVkZ2UgPSBfYS5lZGdlO1xuXG4gICAgaWYgKHJlc2l6YWJsZSkge1xuICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlckRpYWdvbmFsRGlyZWN0aW9ucyhtb3ZlYWJsZSwgUmVhY3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVuZGVyQWxsRGlyZWN0aW9ucyhtb3ZlYWJsZSwgUmVhY3QpO1xuICAgIH1cbiAgfSxcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGRpcmVjdGlvbkNvbmRpdGlvbixcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsXG4gICAgICAgIGlzUGluY2ggPSBlLmlzUGluY2gsXG4gICAgICAgIGlzR3JvdXAgPSBlLmlzR3JvdXAsXG4gICAgICAgIHBhcmVudERpcmVjdGlvbiA9IGUucGFyZW50RGlyZWN0aW9uLFxuICAgICAgICBkYXRhcyA9IGUuZGF0YXM7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHBhcmVudERpcmVjdGlvbiB8fCAoaXNQaW5jaCA/IFswLCAwXSA6IGdldERpcmVjdGlvbihpbnB1dEV2ZW50LnRhcmdldCkpO1xuICAgIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICB0YXJnZXQgPSBfYi50YXJnZXQsXG4gICAgICAgIHdpZHRoID0gX2Iud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9iLmhlaWdodDtcblxuICAgIGlmICghZGlyZWN0aW9uIHx8ICF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAhaXNQaW5jaCAmJiBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICAgIGRhdGFzLmRhdGFzID0ge307XG4gICAgZGF0YXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGggPSB3aWR0aDtcbiAgICBkYXRhcy5zdGFydE9mZnNldEhlaWdodCA9IGhlaWdodDtcbiAgICBkYXRhcy5wcmV2V2lkdGggPSAwO1xuICAgIGRhdGFzLnByZXZIZWlnaHQgPSAwO1xuICAgIF9hID0gZ2V0Q1NTU2l6ZSh0YXJnZXQpLCBkYXRhcy5zdGFydFdpZHRoID0gX2FbMF0sIGRhdGFzLnN0YXJ0SGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIHBhZGRpbmcgPSBbTWF0aC5tYXgoMCwgd2lkdGggLSBkYXRhcy5zdGFydFdpZHRoKSwgTWF0aC5tYXgoMCwgaGVpZ2h0IC0gZGF0YXMuc3RhcnRIZWlnaHQpXTtcbiAgICBkYXRhcy5taW5TaXplID0gcGFkZGluZztcbiAgICBkYXRhcy5tYXhTaXplID0gW0luZmluaXR5LCBJbmZpbml0eV07XG5cbiAgICBpZiAoIWlzR3JvdXApIHtcbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHN0eWxlLnBvc2l0aW9uLFxuICAgICAgICAgIG1pbldpZHRoID0gc3R5bGUubWluV2lkdGgsXG4gICAgICAgICAgbWluSGVpZ2h0ID0gc3R5bGUubWluSGVpZ2h0LFxuICAgICAgICAgIG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGgsXG4gICAgICAgICAgbWF4SGVpZ2h0ID0gc3R5bGUubWF4SGVpZ2h0O1xuICAgICAgdmFyIGlzUGFyZW50RWxlbWVudCA9IHBvc2l0aW9uID09PSBcInN0YXRpY1wiIHx8IHBvc2l0aW9uID09PSBcInJlbGF0aXZlXCI7XG4gICAgICB2YXIgY29udGFpbmVyID0gaXNQYXJlbnRFbGVtZW50ID8gdGFyZ2V0LnBhcmVudEVsZW1lbnQgOiB0YXJnZXQub2Zmc2V0UGFyZW50O1xuICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gd2lkdGg7XG4gICAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgIGlmIChpc1BhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICAgICAgY29udGFpbmVyV2lkdGggLT0gcGFyc2VGbG9hdChjb250YWluZXJTdHlsZS5wYWRkaW5nTGVmdCkgfHwgMDtcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQgLT0gcGFyc2VGbG9hdChjb250YWluZXJTdHlsZS5wYWRkaW5nVG9wKSB8fCAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRhdGFzLm1pblNpemUgPSBwbHVzKFtjb252ZXJ0VW5pdFNpemUobWluV2lkdGgsIGNvbnRhaW5lcldpZHRoKSB8fCAwLCBjb252ZXJ0VW5pdFNpemUobWluSGVpZ2h0LCBjb250YWluZXJIZWlnaHQpIHx8IDBdLCBwYWRkaW5nKTtcbiAgICAgIGRhdGFzLm1heFNpemUgPSBwbHVzKFtjb252ZXJ0VW5pdFNpemUobWF4V2lkdGgsIGNvbnRhaW5lcldpZHRoKSB8fCBJbmZpbml0eSwgY29udmVydFVuaXRTaXplKG1heEhlaWdodCwgY29udGFpbmVySGVpZ2h0KSB8fCBJbmZpbml0eV0sIHBhZGRpbmcpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBtb3ZlYWJsZS5wcm9wcy50cmFuc2Zvcm1PcmlnaW4gfHwgXCIlICVcIjtcbiAgICBkYXRhcy50cmFuc2Zvcm1PcmlnaW4gPSB0cmFuc2Zvcm1PcmlnaW4gJiYgaXNTdHJpbmcodHJhbnNmb3JtT3JpZ2luKSA/IHRyYW5zZm9ybU9yaWdpbi5zcGxpdChcIiBcIikgOiB0cmFuc2Zvcm1PcmlnaW47XG4gICAgZGF0YXMuaXNXaWR0aCA9ICFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSB8fCBkaXJlY3Rpb25bMF0gfHwgIWRpcmVjdGlvblsxXTtcblxuICAgIGZ1bmN0aW9uIHNldFJhdGlvKHJhdGlvKSB7XG4gICAgICBkYXRhcy5yYXRpbyA9IHJhdGlvICYmIGlzRmluaXRlKHJhdGlvKSA/IHJhdGlvIDogMDtcbiAgICB9XG5cbiAgICBkYXRhcy5zdGFydFBvc2l0aW9ucyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIHNldEZpeGVkRGlyZWN0aW9uKGZpeGVkRGlyZWN0aW9uKSB7XG4gICAgICBkYXRhcy5maXhlZERpcmVjdGlvbiA9IGZpeGVkRGlyZWN0aW9uO1xuICAgICAgZGF0YXMuZml4ZWRQb3NpdGlvbiA9IGdldFBvc0J5RGlyZWN0aW9uKGRhdGFzLnN0YXJ0UG9zaXRpb25zLCBmaXhlZERpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0TWluKG1pblNpemUpIHtcbiAgICAgIGRhdGFzLm1pblNpemUgPSBbY29udmVydFVuaXRTaXplKFwiXCIuY29uY2F0KG1pblNpemVbMF0pLCAwKSB8fCAwLCBjb252ZXJ0VW5pdFNpemUoXCJcIi5jb25jYXQobWluU2l6ZVsxXSksIDApIHx8IDBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE1heChtYXhTaXplKSB7XG4gICAgICB2YXIgbmV4dE1heFNpemUgPSBbbWF4U2l6ZVswXSB8fCBJbmZpbml0eSwgbWF4U2l6ZVsxXSB8fCBJbmZpbml0eV07XG5cbiAgICAgIGlmICghaXNOdW1iZXIobmV4dE1heFNpemVbMF0pIHx8IGlzRmluaXRlKG5leHRNYXhTaXplWzBdKSkge1xuICAgICAgICBuZXh0TWF4U2l6ZVswXSA9IGNvbnZlcnRVbml0U2l6ZShcIlwiLmNvbmNhdChuZXh0TWF4U2l6ZVswXSksIDApIHx8IEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTnVtYmVyKG5leHRNYXhTaXplWzFdKSB8fCBpc0Zpbml0ZShuZXh0TWF4U2l6ZVsxXSkpIHtcbiAgICAgICAgbmV4dE1heFNpemVbMV0gPSBjb252ZXJ0VW5pdFNpemUoXCJcIi5jb25jYXQobmV4dE1heFNpemVbMV0pLCAwKSB8fCBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgZGF0YXMubWF4U2l6ZSA9IG5leHRNYXhTaXplO1xuICAgIH1cblxuICAgIHNldFJhdGlvKHdpZHRoIC8gaGVpZ2h0KTtcbiAgICBzZXRGaXhlZERpcmVjdGlvbihbLWRpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV0pO1xuICAgIGRhdGFzLnNldEZpeGVkRGlyZWN0aW9uID0gc2V0Rml4ZWREaXJlY3Rpb247XG4gICAgZGF0YXMuc2V0TWluID0gc2V0TWluO1xuICAgIGRhdGFzLnNldE1heCA9IHNldE1heDtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgc3RhcnRXaWR0aCA9IF9hWzBdLFxuICAgICAgICAgICAgc3RhcnRIZWlnaHQgPSBfYVsxXTtcbiAgICAgICAgZGF0YXMuc3RhcnRXaWR0aCA9IHN0YXJ0V2lkdGg7XG4gICAgICAgIGRhdGFzLnN0YXJ0SGVpZ2h0ID0gc3RhcnRIZWlnaHQ7XG4gICAgICB9LFxuICAgICAgc2V0TWluOiBzZXRNaW4sXG4gICAgICBzZXRNYXg6IHNldE1heCxcbiAgICAgIHNldFJhdGlvOiBzZXRSYXRpbyxcbiAgICAgIHNldEZpeGVkRGlyZWN0aW9uOiBzZXRGaXhlZERpcmVjdGlvbixcbiAgICAgIHNldE9yaWdpbjogZnVuY3Rpb24gKG9yaWdpbikge1xuICAgICAgICBkYXRhcy50cmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICB9LFxuICAgICAgZHJhZ1N0YXJ0OiBEcmFnZ2FibGUuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBuZXcgQ3VzdG9tR2VzdG8oKS5kcmFnU3RhcnQoWzAsIDBdLCBlKSlcbiAgICB9KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplU3RhcnRcIiwgcGFyYW1zKTtcblxuICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICBkYXRhcy5pc1Jlc2l6ZSA9IHRydWU7XG4gICAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcbiAgICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3QsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhcy5pc1Jlc2l6ZSA/IHBhcmFtcyA6IGZhbHNlO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgcGFyZW50RmxhZyA9IGUucGFyZW50RmxhZyxcbiAgICAgICAgaXNQaW5jaCA9IGUuaXNQaW5jaCxcbiAgICAgICAgcGFyZW50S2VlcFJhdGlvID0gZS5wYXJlbnRLZWVwUmF0aW8sXG4gICAgICAgIGRyYWdDbGllbnQgPSBlLmRyYWdDbGllbnQsXG4gICAgICAgIHBhcmVudERpc3QgPSBlLnBhcmVudERpc3QsXG4gICAgICAgIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0O1xuICAgIHZhciBpc1Jlc2l6ZSA9IGRhdGFzLmlzUmVzaXplLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBkYXRhcy50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICAgIHN0YXJ0V2lkdGggPSBkYXRhcy5zdGFydFdpZHRoLFxuICAgICAgICBzdGFydEhlaWdodCA9IGRhdGFzLnN0YXJ0SGVpZ2h0LFxuICAgICAgICBwcmV2V2lkdGggPSBkYXRhcy5wcmV2V2lkdGgsXG4gICAgICAgIHByZXZIZWlnaHQgPSBkYXRhcy5wcmV2SGVpZ2h0LFxuICAgICAgICBtaW5TaXplID0gZGF0YXMubWluU2l6ZSxcbiAgICAgICAgbWF4U2l6ZSA9IGRhdGFzLm1heFNpemUsXG4gICAgICAgIHJhdGlvID0gZGF0YXMucmF0aW8sXG4gICAgICAgIGlzV2lkdGggPSBkYXRhcy5pc1dpZHRoLFxuICAgICAgICBzdGFydE9mZnNldFdpZHRoID0gZGF0YXMuc3RhcnRPZmZzZXRXaWR0aCxcbiAgICAgICAgc3RhcnRPZmZzZXRIZWlnaHQgPSBkYXRhcy5zdGFydE9mZnNldEhlaWdodDtcblxuICAgIGlmICghaXNSZXNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcbiAgICB2YXIgcmVzaXplRm9ybWF0ID0gcHJvcHMucmVzaXplRm9ybWF0LFxuICAgICAgICBfYiA9IHByb3BzLnRocm90dGxlUmVzaXplLFxuICAgICAgICB0aHJvdHRsZVJlc2l6ZSA9IF9iID09PSB2b2lkIDAgPyAxIDogX2IsXG4gICAgICAgIHBhcmVudE1vdmVhYmxlID0gcHJvcHMucGFyZW50TW92ZWFibGU7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGRhdGFzLmRpcmVjdGlvbjtcbiAgICB2YXIgc2l6ZURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB2YXIgZGlzdFdpZHRoID0gMDtcbiAgICB2YXIgZGlzdEhlaWdodCA9IDA7XG5cbiAgICBpZiAoIWRpcmVjdGlvblswXSAmJiAhZGlyZWN0aW9uWzFdKSB7XG4gICAgICBzaXplRGlyZWN0aW9uID0gWzEsIDFdO1xuICAgIH1cblxuICAgIHZhciBrZWVwUmF0aW8gPSByYXRpbyAmJiAocGFyZW50S2VlcFJhdGlvICE9IG51bGwgPyBwYXJlbnRLZWVwUmF0aW8gOiBwcm9wcy5rZWVwUmF0aW8pIHx8IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZ2V0TmV4dEJvdW5kaW5nU2l6ZSgpIHtcbiAgICAgIHZhciBuZXh0U2l6ZSA9IGdldE9mZnNldFNpemVEaXN0KHNpemVEaXJlY3Rpb24sIGtlZXBSYXRpbywgZGF0YXMsIGUpO1xuICAgICAgZGlzdFdpZHRoID0gbmV4dFNpemUuZGlzdFdpZHRoO1xuICAgICAgZGlzdEhlaWdodCA9IG5leHRTaXplLmRpc3RIZWlnaHQ7XG4gICAgICB2YXIgbmV4dFdpZHRoID0gc2l6ZURpcmVjdGlvblswXSB8fCBrZWVwUmF0aW8gPyBNYXRoLm1heChzdGFydE9mZnNldFdpZHRoICsgZGlzdFdpZHRoLCBUSU5ZX05VTSkgOiBzdGFydE9mZnNldFdpZHRoO1xuICAgICAgdmFyIG5leHRIZWlnaHQgPSBzaXplRGlyZWN0aW9uWzFdIHx8IGtlZXBSYXRpbyA/IE1hdGgubWF4KHN0YXJ0T2Zmc2V0SGVpZ2h0ICsgZGlzdEhlaWdodCwgVElOWV9OVU0pIDogc3RhcnRPZmZzZXRIZWlnaHQ7XG5cbiAgICAgIGlmIChrZWVwUmF0aW8gJiYgc3RhcnRPZmZzZXRXaWR0aCAmJiBzdGFydE9mZnNldEhlaWdodCkge1xuICAgICAgICAvLyBzdGFydE9mZnNldFdpZHRoIDogc3RhcnRPZmZzZXRIZWlnaHQgPSBuZXh0V2lkdGggOiBuZXh0SGVpZ2h0XG4gICAgICAgIGlmIChpc1dpZHRoKSB7XG4gICAgICAgICAgbmV4dEhlaWdodCA9IG5leHRXaWR0aCAvIHJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRXaWR0aCA9IG5leHRIZWlnaHQgKiByYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW25leHRXaWR0aCwgbmV4dEhlaWdodF07XG4gICAgfVxuXG4gICAgdmFyIF9jID0gZ2V0TmV4dEJvdW5kaW5nU2l6ZSgpLFxuICAgICAgICBib3VuZGluZ1dpZHRoID0gX2NbMF0sXG4gICAgICAgIGJvdW5kaW5nSGVpZ2h0ID0gX2NbMV07XG5cbiAgICBkYXRhcy5zZXRGaXhlZERpcmVjdGlvbihkYXRhcy5maXhlZERpcmVjdGlvbik7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVzaXplXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIHNldEZpeGVkRGlyZWN0aW9uOiBmdW5jdGlvbiAobmV4dEZpeGVkRGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcblxuICAgICAgICBkYXRhcy5zZXRGaXhlZERpcmVjdGlvbihuZXh0Rml4ZWREaXJlY3Rpb24pO1xuICAgICAgICBfYSA9IGdldE5leHRCb3VuZGluZ1NpemUoKSwgYm91bmRpbmdXaWR0aCA9IF9hWzBdLCBib3VuZGluZ0hlaWdodCA9IF9hWzFdO1xuICAgICAgICByZXR1cm4gW2JvdW5kaW5nV2lkdGgsIGJvdW5kaW5nSGVpZ2h0XTtcbiAgICAgIH0sXG4gICAgICBib3VuZGluZ1dpZHRoOiBib3VuZGluZ1dpZHRoLFxuICAgICAgYm91bmRpbmdIZWlnaHQ6IGJvdW5kaW5nSGVpZ2h0LFxuICAgICAgc2V0U2l6ZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgYm91bmRpbmdXaWR0aCA9IHNpemVbMF0sIGJvdW5kaW5nSGVpZ2h0ID0gc2l6ZVsxXTtcbiAgICAgIH1cbiAgICB9LCB0cnVlKSk7XG4gICAgdmFyIGZpeGVkUG9zaXRpb24gPSBkcmFnQ2xpZW50O1xuXG4gICAgaWYgKCFkcmFnQ2xpZW50KSB7XG4gICAgICBpZiAoIXBhcmVudEZsYWcgJiYgaXNQaW5jaCkge1xuICAgICAgICBmaXhlZFBvc2l0aW9uID0gZ2V0QWJzb2x1dGVQb3NpdGlvbihtb3ZlYWJsZSwgWzAsIDBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbmFwRGlzdCA9IFswLCAwXTtcblxuICAgIGlmICghaXNQaW5jaCkge1xuICAgICAgc25hcERpc3QgPSBjaGVja1NuYXBSZXNpemUobW92ZWFibGUsIGJvdW5kaW5nV2lkdGgsIGJvdW5kaW5nSGVpZ2h0LCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzUmVxdWVzdCwgZGF0YXMpO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnREaXN0KSB7XG4gICAgICAhcGFyZW50RGlzdFswXSAmJiAoc25hcERpc3RbMF0gPSAwKTtcbiAgICAgICFwYXJlbnREaXN0WzFdICYmIChzbmFwRGlzdFsxXSA9IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTaXplKCkge1xuICAgICAgdmFyIF9hO1xuXG4gICAgICBpZiAocmVzaXplRm9ybWF0KSB7XG4gICAgICAgIF9hID0gcmVzaXplRm9ybWF0KFtib3VuZGluZ1dpZHRoLCBib3VuZGluZ0hlaWdodF0pLCBib3VuZGluZ1dpZHRoID0gX2FbMF0sIGJvdW5kaW5nSGVpZ2h0ID0gX2FbMV07XG4gICAgICB9XG5cbiAgICAgIGJvdW5kaW5nV2lkdGggPSB0aHJvdHRsZShib3VuZGluZ1dpZHRoLCB0aHJvdHRsZVJlc2l6ZSk7XG4gICAgICBib3VuZGluZ0hlaWdodCA9IHRocm90dGxlKGJvdW5kaW5nSGVpZ2h0LCB0aHJvdHRsZVJlc2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKGtlZXBSYXRpbykge1xuICAgICAgaWYgKHNpemVEaXJlY3Rpb25bMF0gJiYgc2l6ZURpcmVjdGlvblsxXSAmJiBzbmFwRGlzdFswXSAmJiBzbmFwRGlzdFsxXSkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoc25hcERpc3RbMF0pID4gTWF0aC5hYnMoc25hcERpc3RbMV0pKSB7XG4gICAgICAgICAgc25hcERpc3RbMV0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNuYXBEaXN0WzBdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXNOb1NuYXAgPSAhc25hcERpc3RbMF0gJiYgIXNuYXBEaXN0WzFdO1xuXG4gICAgICBpZiAoaXNOb1NuYXApIHtcbiAgICAgICAgLy8gcHJlLWNvbXB1dGUgYmVmb3JlIG1haW50YWluaW5nIHRoZSByYXRpb1xuICAgICAgICBjb21wdXRlU2l6ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZURpcmVjdGlvblswXSAmJiAhc2l6ZURpcmVjdGlvblsxXSB8fCBzbmFwRGlzdFswXSAmJiAhc25hcERpc3RbMV0gfHwgaXNOb1NuYXAgJiYgaXNXaWR0aCkge1xuICAgICAgICBib3VuZGluZ1dpZHRoICs9IHNuYXBEaXN0WzBdO1xuICAgICAgICBib3VuZGluZ0hlaWdodCA9IGJvdW5kaW5nV2lkdGggLyByYXRpbztcbiAgICAgIH0gZWxzZSBpZiAoIXNpemVEaXJlY3Rpb25bMF0gJiYgc2l6ZURpcmVjdGlvblsxXSB8fCAhc25hcERpc3RbMF0gJiYgc25hcERpc3RbMV0gfHwgaXNOb1NuYXAgJiYgIWlzV2lkdGgpIHtcbiAgICAgICAgYm91bmRpbmdIZWlnaHQgKz0gc25hcERpc3RbMV07XG4gICAgICAgIGJvdW5kaW5nV2lkdGggPSBib3VuZGluZ0hlaWdodCAqIHJhdGlvO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGluZ1dpZHRoICs9IHNuYXBEaXN0WzBdO1xuICAgICAgYm91bmRpbmdIZWlnaHQgKz0gc25hcERpc3RbMV07XG4gICAgICBib3VuZGluZ1dpZHRoID0gTWF0aC5tYXgoMCwgYm91bmRpbmdXaWR0aCk7XG4gICAgICBib3VuZGluZ0hlaWdodCA9IE1hdGgubWF4KDAsIGJvdW5kaW5nSGVpZ2h0KTtcbiAgICB9XG5cbiAgICBfYSA9IGNhbGN1bGF0ZUJvdW5kU2l6ZShbYm91bmRpbmdXaWR0aCwgYm91bmRpbmdIZWlnaHRdLCBtaW5TaXplLCBtYXhTaXplLCBrZWVwUmF0aW8gPyByYXRpbyA6IGZhbHNlKSwgYm91bmRpbmdXaWR0aCA9IF9hWzBdLCBib3VuZGluZ0hlaWdodCA9IF9hWzFdO1xuICAgIGNvbXB1dGVTaXplKCk7XG4gICAgZGlzdFdpZHRoID0gYm91bmRpbmdXaWR0aCAtIHN0YXJ0T2Zmc2V0V2lkdGg7XG4gICAgZGlzdEhlaWdodCA9IGJvdW5kaW5nSGVpZ2h0IC0gc3RhcnRPZmZzZXRIZWlnaHQ7XG4gICAgdmFyIGRlbHRhID0gW2Rpc3RXaWR0aCAtIHByZXZXaWR0aCwgZGlzdEhlaWdodCAtIHByZXZIZWlnaHRdO1xuICAgIGRhdGFzLnByZXZXaWR0aCA9IGRpc3RXaWR0aDtcbiAgICBkYXRhcy5wcmV2SGVpZ2h0ID0gZGlzdEhlaWdodDtcbiAgICB2YXIgaW52ZXJzZURlbHRhID0gZ2V0UmVzaXplRGlzdChtb3ZlYWJsZSwgYm91bmRpbmdXaWR0aCwgYm91bmRpbmdIZWlnaHQsIGRhdGFzLmZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCB0cmFuc2Zvcm1PcmlnaW4pO1xuXG4gICAgaWYgKCFwYXJlbnRNb3ZlYWJsZSAmJiBkZWx0YS5ldmVyeShmdW5jdGlvbiAobnVtKSB7XG4gICAgICByZXR1cm4gIW51bTtcbiAgICB9KSAmJiBpbnZlcnNlRGVsdGEuZXZlcnkoZnVuY3Rpb24gKG51bSkge1xuICAgICAgcmV0dXJuICFudW07XG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgd2lkdGg6IHN0YXJ0V2lkdGggKyBkaXN0V2lkdGgsXG4gICAgICBoZWlnaHQ6IHN0YXJ0SGVpZ2h0ICsgZGlzdEhlaWdodCxcbiAgICAgIG9mZnNldFdpZHRoOiBNYXRoLnJvdW5kKGJvdW5kaW5nV2lkdGgpLFxuICAgICAgb2Zmc2V0SGVpZ2h0OiBNYXRoLnJvdW5kKGJvdW5kaW5nSGVpZ2h0KSxcbiAgICAgIGJvdW5kaW5nV2lkdGg6IGJvdW5kaW5nV2lkdGgsXG4gICAgICBib3VuZGluZ0hlaWdodDogYm91bmRpbmdIZWlnaHQsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIGRpc3Q6IFtkaXN0V2lkdGgsIGRpc3RIZWlnaHRdLFxuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgaXNQaW5jaDogISFpc1BpbmNoLFxuICAgICAgZHJhZzogRHJhZ2dhYmxlLmRyYWcobW92ZWFibGUsIHNldEN1c3RvbURyYWcoZSwgbW92ZWFibGUuc3RhdGUsIGludmVyc2VEZWx0YSwgISFpc1BpbmNoLCBmYWxzZSkpXG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplXCIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0NvbnRyb2xBZnRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcbiAgICB2YXIgaXNSZXNpemUgPSBkYXRhcy5pc1Jlc2l6ZSxcbiAgICAgICAgc3RhcnRPZmZzZXRXaWR0aCA9IGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGgsXG4gICAgICAgIHN0YXJ0T2Zmc2V0SGVpZ2h0ID0gZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQsXG4gICAgICAgIHByZXZXaWR0aCA9IGRhdGFzLnByZXZXaWR0aCxcbiAgICAgICAgcHJldkhlaWdodCA9IGRhdGFzLnByZXZIZWlnaHQ7XG5cbiAgICBpZiAoIWlzUmVzaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICB2YXIgZXJyb3JXaWR0aCA9IHdpZHRoIC0gKHN0YXJ0T2Zmc2V0V2lkdGggKyBwcmV2V2lkdGgpO1xuICAgIHZhciBlcnJvckhlaWdodCA9IGhlaWdodCAtIChzdGFydE9mZnNldEhlaWdodCArIHByZXZIZWlnaHQpO1xuICAgIHZhciBpc0Vycm9yV2lkdGggPSBNYXRoLmFicyhlcnJvcldpZHRoKSA+IDM7XG4gICAgdmFyIGlzRXJyb3JIZWlnaHQgPSBNYXRoLmFicyhlcnJvckhlaWdodCkgPiAzO1xuXG4gICAgaWYgKGlzRXJyb3JXaWR0aCkge1xuICAgICAgZGF0YXMuc3RhcnRXaWR0aCArPSBlcnJvcldpZHRoO1xuICAgICAgZGF0YXMuc3RhcnRPZmZzZXRXaWR0aCArPSBlcnJvcldpZHRoO1xuICAgICAgZGF0YXMucHJldldpZHRoICs9IGVycm9yV2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKGlzRXJyb3JIZWlnaHQpIHtcbiAgICAgIGRhdGFzLnN0YXJ0SGVpZ2h0ICs9IGVycm9ySGVpZ2h0O1xuICAgICAgZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQgKz0gZXJyb3JIZWlnaHQ7XG4gICAgICBkYXRhcy5wcmV2SGVpZ2h0ICs9IGVycm9ySGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yV2lkdGggfHwgaXNFcnJvckhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIGUpO1xuICAgIH1cbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzUmVzaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGF0YXMuaXNSZXNpemUgPSBmYWxzZTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlc2l6ZUVuZFwiLCBwYXJhbXMpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xDb25kaXRpb246IGRpcmVjdGlvbkNvbmRpdGlvbixcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgaXNHcm91cDogdHJ1ZVxuICAgIH0pKTtcblxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsRXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBcInJlc2l6YWJsZVwiLCBlKTtcblxuICAgIGZ1bmN0aW9uIHNldERpc3QoY2hpbGQsIGV2KSB7XG4gICAgICB2YXIgZml4ZWREaXJlY3Rpb24gPSBkYXRhcy5maXhlZERpcmVjdGlvbjtcbiAgICAgIHZhciBmaXhlZFBvc2l0aW9uID0gZGF0YXMuZml4ZWRQb3NpdGlvbjtcbiAgICAgIHZhciBzdGFydFBvc2l0aW9ucyA9IGV2LmRhdGFzLnN0YXJ0UG9zaXRpb25zIHx8IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKGNoaWxkLnN0YXRlKTtcbiAgICAgIHZhciBwb3MgPSBnZXRQb3NCeURpcmVjdGlvbihzdGFydFBvc2l0aW9ucywgZml4ZWREaXJlY3Rpb24pO1xuXG4gICAgICB2YXIgX2EgPSBjYWxjdWxhdGUoY3JlYXRlUm90YXRlTWF0cml4KC1tb3ZlYWJsZS5yb3RhdGlvbiAvIDE4MCAqIE1hdGguUEksIDMpLCBbcG9zWzBdIC0gZml4ZWRQb3NpdGlvblswXSwgcG9zWzFdIC0gZml4ZWRQb3NpdGlvblsxXSwgMV0sIDMpLFxuICAgICAgICAgIG9yaWdpbmFsWCA9IF9hWzBdLFxuICAgICAgICAgIG9yaWdpbmFsWSA9IF9hWzFdO1xuXG4gICAgICBldi5kYXRhcy5vcmlnaW5hbFggPSBvcmlnaW5hbFg7XG4gICAgICBldi5kYXRhcy5vcmlnaW5hbFkgPSBvcmlnaW5hbFk7XG4gICAgICByZXR1cm4gZXY7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudFN0YXJ0T2Zmc2V0V2lkdGggPSBkYXRhcy5zdGFydE9mZnNldFdpZHRoLFxuICAgICAgICBwYXJlbnRTdGFydE9mZnNldEhlaWdodCA9IGRhdGFzLnN0YXJ0T2Zmc2V0SGVpZ2h0O1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlR3JvdXBNaW4oKSB7XG4gICAgICB2YXIgb3JpZ2luYWxNaW5TaXplID0gZGF0YXMubWluU2l6ZTtcbiAgICAgIG9yaWdpbmFsRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBfYSA9IGV2LmRhdGFzLFxuICAgICAgICAgICAgY2hpbGRNaW5TaXplID0gX2EubWluU2l6ZSxcbiAgICAgICAgICAgIGNoaWxkU3RhcnRPZmZzZXRXaWR0aCA9IF9hLnN0YXJ0T2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICBjaGlsZFN0YXJ0T2Zmc2V0SGVpZ2h0ID0gX2Euc3RhcnRPZmZzZXRIZWlnaHQ7XG4gICAgICAgIHZhciBwYXJlbnRNaW5XaWR0aCA9IHBhcmVudFN0YXJ0T2Zmc2V0V2lkdGggKiAoY2hpbGRTdGFydE9mZnNldFdpZHRoID8gY2hpbGRNaW5TaXplWzBdIC8gY2hpbGRTdGFydE9mZnNldFdpZHRoIDogMCk7XG4gICAgICAgIHZhciBwYXJlbnRNaW5IZWlnaHQgPSBwYXJlbnRTdGFydE9mZnNldEhlaWdodCAqIChjaGlsZFN0YXJ0T2Zmc2V0SGVpZ2h0ID8gY2hpbGRNaW5TaXplWzFdIC8gY2hpbGRTdGFydE9mZnNldEhlaWdodCA6IDApO1xuICAgICAgICBvcmlnaW5hbE1pblNpemVbMF0gPSBNYXRoLm1heChvcmlnaW5hbE1pblNpemVbMF0sIHBhcmVudE1pbldpZHRoKTtcbiAgICAgICAgb3JpZ2luYWxNaW5TaXplWzFdID0gTWF0aC5tYXgob3JpZ2luYWxNaW5TaXplWzFdLCBwYXJlbnRNaW5IZWlnaHQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlR3JvdXBNYXgoKSB7XG4gICAgICB2YXIgb3JpZ2luYWxNYXhTaXplID0gZGF0YXMubWF4U2l6ZTtcbiAgICAgIG9yaWdpbmFsRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBfYSA9IGV2LmRhdGFzLFxuICAgICAgICAgICAgY2hpbGRNYXhTaXplID0gX2EubWF4U2l6ZSxcbiAgICAgICAgICAgIGNoaWxkU3RhcnRPZmZzZXRXaWR0aCA9IF9hLnN0YXJ0T2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICBjaGlsZFN0YXJ0T2Zmc2V0SGVpZ2h0ID0gX2Euc3RhcnRPZmZzZXRIZWlnaHQ7XG4gICAgICAgIHZhciBwYXJlbnRNYXhXaWR0aCA9IHBhcmVudFN0YXJ0T2Zmc2V0V2lkdGggKiAoY2hpbGRTdGFydE9mZnNldFdpZHRoID8gY2hpbGRNYXhTaXplWzBdIC8gY2hpbGRTdGFydE9mZnNldFdpZHRoIDogMCk7XG4gICAgICAgIHZhciBwYXJlbnRNYXhIZWlnaHQgPSBwYXJlbnRTdGFydE9mZnNldEhlaWdodCAqIChjaGlsZFN0YXJ0T2Zmc2V0SGVpZ2h0ID8gY2hpbGRNYXhTaXplWzFdIC8gY2hpbGRTdGFydE9mZnNldEhlaWdodCA6IDApO1xuICAgICAgICBvcmlnaW5hbE1heFNpemVbMF0gPSBNYXRoLm1pbihvcmlnaW5hbE1heFNpemVbMF0sIHBhcmVudE1heFdpZHRoKTtcbiAgICAgICAgb3JpZ2luYWxNYXhTaXplWzFdID0gTWF0aC5taW4ob3JpZ2luYWxNYXhTaXplWzFdLCBwYXJlbnRNYXhIZWlnaHQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sU3RhcnRcIiwgZSwgZnVuY3Rpb24gKGNoaWxkLCBldikge1xuICAgICAgcmV0dXJuIHNldERpc3QoY2hpbGQsIGV2KTtcbiAgICB9KTtcbiAgICB1cGRhdGVHcm91cE1pbigpO1xuICAgIHVwZGF0ZUdyb3VwTWF4KCk7XG5cbiAgICB2YXIgc2V0Rml4ZWREaXJlY3Rpb24gPSBmdW5jdGlvbiAoZml4ZWREaXJlY3Rpb24pIHtcbiAgICAgIHBhcmFtcy5zZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbik7XG4gICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYsIGkpIHtcbiAgICAgICAgZXYuc2V0Rml4ZWREaXJlY3Rpb24oZml4ZWREaXJlY3Rpb24pO1xuICAgICAgICBzZXREaXN0KGV2Lm1vdmVhYmxlLCBvcmlnaW5hbEV2ZW50c1tpXSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZGF0YXMuc2V0Rml4ZWREaXJlY3Rpb24gPSBzZXRGaXhlZERpcmVjdGlvbjtcblxuICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtcyksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7XG4gICAgICAgICAgc2V0TWluOiBmdW5jdGlvbiAobWluU2l6ZSkge1xuICAgICAgICAgICAgZXYuc2V0TWluKG1pblNpemUpO1xuICAgICAgICAgICAgdXBkYXRlR3JvdXBNaW4oKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldE1heDogZnVuY3Rpb24gKG1heFNpemUpIHtcbiAgICAgICAgICAgIGV2LnNldE1heChtYXhTaXplKTtcbiAgICAgICAgICAgIHVwZGF0ZUdyb3VwTWF4KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgc2V0Rml4ZWREaXJlY3Rpb246IHNldEZpeGVkRGlyZWN0aW9uLFxuICAgICAgc2V0TWluOiBmdW5jdGlvbiAobWluU2l6ZSkge1xuICAgICAgICBwYXJhbXMuc2V0TWluKG1pblNpemUpO1xuICAgICAgICB1cGRhdGVHcm91cE1pbigpO1xuICAgICAgfSxcbiAgICAgIHNldE1heDogZnVuY3Rpb24gKG1heFNpemUpIHtcbiAgICAgICAgcGFyYW1zLnNldE1heChtYXhTaXplKTtcbiAgICAgICAgdXBkYXRlR3JvdXBNYXgoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZXNpemVHcm91cFN0YXJ0XCIsIG5leHRQYXJhbXMpO1xuICAgIGRhdGFzLmlzUmVzaXplID0gcmVzdWx0ICE9PSBmYWxzZTtcbiAgICByZXR1cm4gZGF0YXMuaXNSZXNpemUgPyBwYXJhbXMgOiBmYWxzZTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNSZXNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYXRjaEV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVzaXplXCIsIGZ1bmN0aW9uIChwYXJlbnRFdmVudCkge1xuICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVzaXplR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmVudEV2ZW50KSwge1xuICAgICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgICB9KSwgdHJ1ZSkpO1xuICAgIH0pO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sKG1vdmVhYmxlLCBlKTtcblxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kaW5nV2lkdGggPSBwYXJhbXMuYm91bmRpbmdXaWR0aCxcbiAgICAgICAgYm91bmRpbmdIZWlnaHQgPSBwYXJhbXMuYm91bmRpbmdIZWlnaHQsXG4gICAgICAgIGRpc3QgPSBwYXJhbXMuZGlzdDtcbiAgICB2YXIga2VlcFJhdGlvID0gbW92ZWFibGUucHJvcHMua2VlcFJhdGlvO1xuICAgIHZhciBwYXJlbnRTY2FsZSA9IFtib3VuZGluZ1dpZHRoIC8gKGJvdW5kaW5nV2lkdGggLSBkaXN0WzBdKSwgYm91bmRpbmdIZWlnaHQgLyAoYm91bmRpbmdIZWlnaHQgLSBkaXN0WzFdKV07XG4gICAgdmFyIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xuICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnQ29udHJvbFwiLCBlLCBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgIHZhciBfYSA9IGNhbGN1bGF0ZShjcmVhdGVSb3RhdGVNYXRyaXgobW92ZWFibGUucm90YXRpb24gLyAxODAgKiBNYXRoLlBJLCAzKSwgW2V2LmRhdGFzLm9yaWdpbmFsWCAqIHBhcmVudFNjYWxlWzBdLCBldi5kYXRhcy5vcmlnaW5hbFkgKiBwYXJlbnRTY2FsZVsxXSwgMV0sIDMpLFxuICAgICAgICAgIGNsaWVudFggPSBfYVswXSxcbiAgICAgICAgICBjbGllbnRZID0gX2FbMV07XG5cbiAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7XG4gICAgICAgIHBhcmVudERpc3Q6IG51bGwsXG4gICAgICAgIHBhcmVudFNjYWxlOiBwYXJlbnRTY2FsZSxcbiAgICAgICAgZHJhZ0NsaWVudDogcGx1cyhmaXhlZFBvc2l0aW9uLCBbY2xpZW50WCwgY2xpZW50WV0pLFxuICAgICAgICBwYXJlbnRLZWVwUmF0aW86IGtlZXBSYXRpb1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IGV2ZW50c1xuICAgIH0sIHBhcmFtcyk7XG5cbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZXNpemVHcm91cFwiLCBuZXh0UGFyYW1zKTtcbiAgICByZXR1cm4gbmV4dFBhcmFtcztcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGlzRHJhZyA9IGUuaXNEcmFnLFxuICAgICAgICBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzUmVzaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnQ29udHJvbEVuZChtb3ZlYWJsZSwgZSk7XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sRW5kXCIsIGUpO1xuICAgIHZhciBuZXh0UGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplR3JvdXBFbmRcIiwgbmV4dFBhcmFtcyk7XG4gICAgcmV0dXJuIGlzRHJhZztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBNb3ZlYWJsZS5SZXNpemFibGUjcmVxdWVzdFxuICAgKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5SZXNpemFibGVSZXF1ZXN0UGFyYW19IGUgLSB0aGUgUmVzaXphYmxlJ3MgcmVxdWVzdCBwYXJhbWV0ZXJcbiAgICogQHJldHVybiB7TW92ZWFibGUuUmVxdWVzdGVyfSBNb3ZlYWJsZSBSZXF1ZXN0ZXJcbiAgICogQGV4YW1wbGVcbiAgICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcbiAgICogLy8gVXNlIFJlbGF0aXZlIFZhbHVlXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0sIHRydWUpO1xuICAgKlxuICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcbiAgICogbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiLCB7IG9mZnNldFdpZHRoOiAxMDAsIG9mZnNldEhlaWdodDogMTAwIH0sIHRydWUpO1xuICAgKlxuICAgKiAvLyByZXF1ZXN0U3RhcnRcbiAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiKTtcbiAgICpcbiAgICogLy8gcmVxdWVzdFxuICAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcbiAgICpcbiAgICogLy8gVXNlIEFic29sdXRlIFZhbHVlXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBvZmZzZXRXaWR0aDogMTAwLCBvZmZzZXRIZWlnaHQ6IDEwMCB9KTtcbiAgICogbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiLCB7IG9mZnNldFdpZHRoOiAxMTAsIG9mZnNldEhlaWdodDogMTAwIH0pO1xuICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwicmVzaXphYmxlXCIsIHsgb2Zmc2V0V2lkdGg6IDEyMCwgb2Zmc2V0SGVpZ2h0OiAxMDAgfSk7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RFbmRcbiAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgICovXG4gIHJlcXVlc3Q6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBkYXRhcyA9IHt9O1xuICAgIHZhciBkaXN0V2lkdGggPSAwO1xuICAgIHZhciBkaXN0SGVpZ2h0ID0gMDtcbiAgICB2YXIgcmVjdCA9IG1vdmVhYmxlLmdldFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb250cm9sOiB0cnVlLFxuICAgICAgcmVxdWVzdFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgICBwYXJlbnREaXJlY3Rpb246IGUuZGlyZWN0aW9uIHx8IFsxLCAxXVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChcIm9mZnNldFdpZHRoXCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RXaWR0aCA9IGUub2Zmc2V0V2lkdGggLSByZWN0Lm9mZnNldFdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKFwiZGVsdGFXaWR0aFwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0V2lkdGggKz0gZS5kZWx0YVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwib2Zmc2V0SGVpZ2h0XCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RIZWlnaHQgPSBlLm9mZnNldEhlaWdodCAtIHJlY3Qub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKFwiZGVsdGFIZWlnaHRcIiBpbiBlKSB7XG4gICAgICAgICAgZGlzdEhlaWdodCArPSBlLmRlbHRhSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgcGFyZW50RGlzdDogW2Rpc3RXaWR0aCwgZGlzdEhlaWdodF0sXG4gICAgICAgICAgcGFyZW50S2VlcFJhdGlvOiBlLmtlZXBSYXRpb1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgaXNEcmFnOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSByZXNpemVkLlxuICogQG5hbWUgTW92ZWFibGUuUmVzaXphYmxlI3Jlc2l6YWJsZVxuICogQGRlZmF1bHQgZmFsc2VcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJlc2l6YWJsZTogZmFsc2UsXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS5yZXNpemFibGUgPSB0cnVlO1xuICovXG5cbi8qKlxuICogdGhyb3R0bGUgb2Ygd2lkdGgsIGhlaWdodCB3aGVuIHJlc2l6ZS4gSWYgdGhyb3R0bGVSZXNpemUgaXMgc2V0IHRvIGxlc3MgdGhhbiAxLCB0aGUgdGFyZ2V0IG1heSBzaGFrZS5cbiAqIEBuYW1lIE1vdmVhYmxlLlJlc2l6YWJsZSN0aHJvdHRsZVJlc2l6ZVxuICogQGRlZmF1bHQgMVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHJlc2l6YWJsZTogdHJ1ZSxcbiAqICAgdGhyb3R0bGVSZXNpemU6IDEsXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS50aHJvdHRsZVJlc2l6ZSA9IDA7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHJlc2l6ZSBvciBzY2FsZSwga2VlcHMgYSByYXRpbyBvZiB0aGUgd2lkdGgsIGhlaWdodC5cbiAqIEBuYW1lIE1vdmVhYmxlLlJlc2l6YWJsZSNrZWVwUmF0aW9cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgcmVzaXphYmxlOiB0cnVlLFxuICogfSk7XG4gKlxuICogbW92ZWFibGUua2VlcFJhdGlvID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFNldCBkaXJlY3Rpb25zIHRvIHNob3cgdGhlIGNvbnRyb2wgYm94LlxuICogQG5hbWUgTW92ZWFibGUuUmVzaXphYmxlI3JlbmRlckRpcmVjdGlvbnNcbiAqIEBkZWZhdWx0IFtcIm5cIiwgXCJud1wiLCBcIm5lXCIsIFwic1wiLCBcInNlXCIsIFwic3dcIiwgXCJlXCIsIFwid1wiXVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHJlc2l6YWJsZTogdHJ1ZSxcbiAqICAgcmVuZGVyRGlyZWN0aW9uczogW1wiblwiLCBcIm53XCIsIFwibmVcIiwgXCJzXCIsIFwic2VcIiwgXCJzd1wiLCBcImVcIiwgXCJ3XCJdLFxuICogfSk7XG4gKlxuICogbW92ZWFibGUucmVuZGVyRGlyZWN0aW9ucyA9IFtcIm53XCIsIFwibmVcIiwgXCJzd1wiLCBcInNlXCJdO1xuICovXG5cbi8qKlxuICogRnVuY3Rpb24gdG8gY29udmVydCBzaXplIGZvciByZXNpemVcbiAqIEBuYW1lIE1vdmVhYmxlLlJlc2l6YWJsZSNyZXNpemVGb3JtYXRcbiAqIEBkZWZhdWx0IG9uZXNlbGZcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICByZXNpemFibGU6IHRydWUsXG4gKiAgIHJlc2l6ZUZvcm1hdDogdiA9PiB2LFxuICogfSk7XG4gKlxuICogbW92ZWFibGUucmVzaXplRm9ybWF0ID0gKHNpemU6IG51bWJlcltdKSA9PiAoW01hdGgudHJ1bmMoc2l6ZVswXSksIE1hdGgudHJ1bmMoc2l6ZVsxXSldO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgcmVzaXplIHN0YXJ0cywgdGhlIHJlc2l6ZVN0YXJ0IGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcbiAqIEBldmVudCByZXNpemVTdGFydFxuICogQHBhcmFtIHtNb3ZlYWJsZS5SZXNpemFibGUuT25SZXNpemVTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcmVzaXplU3RhcnQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByZXNpemFibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJlc2l6ZVN0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiByZXNpemluZywgYGJlZm9yZVJlc2l6ZWAgaXMgY2FsbGVkIGJlZm9yZSBgcmVzaXplYCBvY2N1cnMuIEluIGBiZWZvcmVSZXNpemVgLCB5b3UgY2FuIGdldCBhbmQgc2V0IHRoZSBwcmUtdmFsdWUgYmVmb3JlIHJlc2l6aW5nLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJlc2l6YWJsZVxuICogQGV2ZW50IGJlZm9yZVJlc2l6ZVxuICogQHBhcmFtIHtNb3ZlYWJsZS5SZXNpemFibGUuT25CZWZvcmVSZXNpemV9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBiZWZvcmVSZXNpemVgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgcmVzaXphYmxlOiB0cnVlIH0pO1xuICogbW92ZWFibGUub24oXCJiZWZvcmVSZXNpemVcIiwgKHsgc2V0Rml4ZWREaXJlY3Rpb24gfSkgPT4ge1xuICogICAgIGlmIChzaGlmdEtleSkge1xuICogICAgICAgIHNldEZpeGVkRGlyZWN0aW9uKFswLCAwXSk7XG4gKiAgICAgfVxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJlc2l6ZVwiLCAoeyB0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIGRyYWcgfSkgPT4ge1xuICogICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IGAke3dpZHRofXB4YDtcbiAqICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAqICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gZHJhZy50cmFuc2Zvcm07XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gcmVzaXppbmcsIHRoZSByZXNpemUgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJlc2l6YWJsZVxuICogQGV2ZW50IHJlc2l6ZVxuICogQHBhcmFtIHtNb3ZlYWJsZS5SZXNpemFibGUuT25SZXNpemV9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHJlc2l6ZSBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJlc2l6YWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVzaXplXCIsICh7IHRhcmdldCwgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gKiAgICAgdGFyZ2V0LnN0eWxlLndpZHRoID0gYCR7ZS53aWR0aH1weGA7XG4gKiAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IGAke2UuaGVpZ2h0fXB4YDtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgcmVzaXplIGZpbmlzaGVzLCB0aGUgcmVzaXplRW5kIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcbiAqIEBldmVudCByZXNpemVFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLk9uUmVzaXplRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByZXNpemVFbmQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByZXNpemFibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJlc2l6ZUVuZFwiLCAoeyB0YXJnZXQsIGlzRHJhZyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0LCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxuLyoqXG4qIFdoZW4gdGhlIGdyb3VwIHJlc2l6ZSBzdGFydHMsIHRoZSBgcmVzaXplR3JvdXBTdGFydGAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXG4qIEBldmVudCByZXNpemVHcm91cFN0YXJ0XG4qIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLk9uUmVzaXplR3JvdXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlc2l6ZUdyb3VwU3RhcnRgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiogICAgIHJlc2l6YWJsZTogdHJ1ZVxuKiB9KTtcbiogbW92ZWFibGUub24oXCJyZXNpemVHcm91cFN0YXJ0XCIsICh7IHRhcmdldHMgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2coXCJvblJlc2l6ZUdyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XG4qIH0pO1xuKi9cblxuLyoqXG4qIFdoZW4gdGhlIGdyb3VwIHJlc2l6ZSwgdGhlIGByZXNpemVHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXG4qIEBldmVudCByZXNpemVHcm91cFxuKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5vblJlc2l6ZUdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVzaXplR3JvdXBgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiogICAgIHJlc2l6YWJsZTogdHJ1ZVxuKiB9KTtcbiogbW92ZWFibGUub24oXCJyZXNpemVHcm91cFwiLCAoeyB0YXJnZXRzLCBldmVudHMgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2coXCJvblJlc2l6ZUdyb3VwXCIsIHRhcmdldHMpO1xuKiAgICAgZXZlbnRzLmZvckVhY2goZXYgPT4ge1xuKiAgICAgICAgIGNvbnN0IG9mZnNldCA9IFtcbiogICAgICAgICAgICAgZGlyZWN0aW9uWzBdIDwgMCA/IC1ldi5kZWx0YVswXSA6IDAsXG4qICAgICAgICAgICAgIGRpcmVjdGlvblsxXSA8IDAgPyAtZXYuZGVsdGFbMV0gOiAwLFxuKiAgICAgICAgIF07XG4qICAgICAgICAgLy8gZXYuZHJhZyBpcyBhIGRyYWcgZXZlbnQgdGhhdCBvY2N1cnMgd2hlbiB0aGUgZ3JvdXAgcmVzaXplLlxuKiAgICAgICAgIGNvbnN0IGxlZnQgPSBvZmZzZXRbMF0gKyBldi5kcmFnLmJlZm9yZURpc3RbMF07XG4qICAgICAgICAgY29uc3QgdG9wID0gb2Zmc2V0WzFdICsgZXYuZHJhZy5iZWZvcmVEaXN0WzFdO1xuKiAgICAgICAgIGNvbnN0IHdpZHRoID0gZXYud2lkdGg7XG4qICAgICAgICAgY29uc3QgdG9wID0gZXYudG9wO1xuKiAgICAgfSk7XG4qIH0pO1xuKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBncm91cCByZXNpemUgZmluaXNoZXMsIHRoZSBgcmVzaXplR3JvdXBFbmRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcbiAqIEBldmVudCByZXNpemVHcm91cEVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5SZXNpemFibGUuT25SZXNpemVHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlc2l6ZUdyb3VwRW5kYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqICAgICByZXNpemFibGU6IHRydWVcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyZXNpemVHcm91cEVuZFwiLCAoeyB0YXJnZXRzLCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25SZXNpemVHcm91cEVuZFwiLCB0YXJnZXRzLCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIFNjYWxhYmxlXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBkZXNjcmlwdGlvbiBTY2FsYWJsZSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0J3MgeCBhbmQgeSBjYW4gYmUgc2NhbGUgb2YgdHJhbnNmb3JtLlxuICovXG5cbnZhciBTY2FsYWJsZSA9IHtcbiAgbmFtZTogXCJzY2FsYWJsZVwiLFxuICBhYmxlR3JvdXA6IFwic2l6ZVwiLFxuICBjYW5QaW5jaDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBzY2FsYWJsZTogQm9vbGVhbixcbiAgICB0aHJvdHRsZVNjYWxlOiBOdW1iZXIsXG4gICAgcmVuZGVyRGlyZWN0aW9uczogU3RyaW5nLFxuICAgIGtlZXBSYXRpbzogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHtcbiAgICBvblNjYWxlU3RhcnQ6IFwic2NhbGVTdGFydFwiLFxuICAgIG9uQmVmb3JlU2NhbGU6IFwiYmVmb3JlU2NhbGVcIixcbiAgICBvblNjYWxlOiBcInNjYWxlXCIsXG4gICAgb25TY2FsZUVuZDogXCJzY2FsZUVuZFwiLFxuICAgIG9uU2NhbGVHcm91cFN0YXJ0OiBcInNjYWxlR3JvdXBTdGFydFwiLFxuICAgIG9uQmVmb3JlU2NhbGVHcm91cDogXCJiZWZvcmVTY2FsZUdyb3VwXCIsXG4gICAgb25TY2FsZUdyb3VwOiBcInNjYWxlR3JvdXBcIixcbiAgICBvblNjYWxlR3JvdXBFbmQ6IFwic2NhbGVHcm91cEVuZFwiXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICByZXNpemFibGUgPSBfYS5yZXNpemFibGUsXG4gICAgICAgIHNjYWxhYmxlID0gX2Euc2NhbGFibGUsXG4gICAgICAgIGVkZ2UgPSBfYS5lZGdlO1xuXG4gICAgaWYgKCFyZXNpemFibGUgJiYgc2NhbGFibGUpIHtcbiAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJEaWFnb25hbERpcmVjdGlvbnMobW92ZWFibGUsIFJlYWN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbmRlckFsbERpcmVjdGlvbnMobW92ZWFibGUsIFJlYWN0KTtcbiAgICB9XG4gIH0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBkaXJlY3Rpb25Db25kaXRpb24sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzUGluY2ggPSBlLmlzUGluY2gsXG4gICAgICAgIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsXG4gICAgICAgIHBhcmVudERpcmVjdGlvbiA9IGUucGFyZW50RGlyZWN0aW9uO1xuICAgIHZhciBkaXJlY3Rpb24gPSBwYXJlbnREaXJlY3Rpb24gfHwgKGlzUGluY2ggPyBbMCwgMF0gOiBnZXREaXJlY3Rpb24oaW5wdXRFdmVudC50YXJnZXQpKTtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgd2lkdGggPSBfYS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0LFxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm0gPSBfYS50YXJnZXRUcmFuc2Zvcm0sXG4gICAgICAgIHRhcmdldCA9IF9hLnRhcmdldCxcbiAgICAgICAgcG9zMSA9IF9hLnBvczEsXG4gICAgICAgIHBvczIgPSBfYS5wb3MyLFxuICAgICAgICBwb3M0ID0gX2EucG9zNDtcblxuICAgIGlmICghZGlyZWN0aW9uIHx8ICF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGluY2gpIHtcbiAgICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gICAgfVxuXG4gICAgZGF0YXMuZGF0YXMgPSB7fTtcbiAgICBkYXRhcy50cmFuc2Zvcm0gPSB0YXJnZXRUcmFuc2Zvcm07XG4gICAgZGF0YXMucHJldkRpc3QgPSBbMSwgMV07XG4gICAgZGF0YXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGggPSB3aWR0aDtcbiAgICBkYXRhcy5zdGFydE9mZnNldEhlaWdodCA9IGhlaWdodDtcbiAgICBkYXRhcy5zdGFydFZhbHVlID0gWzEsIDFdO1xuICAgIHZhciBzY2FsZVdpZHRoID0gZ2V0RGlzdCQxKHBvczEsIHBvczIpO1xuICAgIHZhciBzY2FsZUhlaWdodCA9IGdldERpc3QkMShwb3MyLCBwb3M0KTtcbiAgICB2YXIgaXNXaWR0aCA9ICFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSB8fCBkaXJlY3Rpb25bMF0gfHwgIWRpcmVjdGlvblsxXTtcbiAgICBkYXRhcy5zY2FsZVdpZHRoID0gc2NhbGVXaWR0aDtcbiAgICBkYXRhcy5zY2FsZUhlaWdodCA9IHNjYWxlSGVpZ2h0O1xuICAgIGRhdGFzLnNjYWxlWFJhdGlvID0gc2NhbGVXaWR0aCAvIHdpZHRoO1xuICAgIGRhdGFzLnNjYWxlWVJhdGlvID0gc2NhbGVIZWlnaHQgLyBoZWlnaHQ7XG4gICAgc2V0RGVmYXVsdFRyYW5zZm9ybUluZGV4KGUsIFwic2NhbGVcIik7XG4gICAgZGF0YXMuaXNXaWR0aCA9IGlzV2lkdGg7XG5cbiAgICBmdW5jdGlvbiBzZXRSYXRpbyhyYXRpbykge1xuICAgICAgZGF0YXMucmF0aW8gPSByYXRpbyAmJiBpc0Zpbml0ZShyYXRpbykgPyByYXRpbyA6IDA7XG4gICAgfVxuXG4gICAgZGF0YXMuc3RhcnRQb3NpdGlvbnMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSk7XG5cbiAgICBmdW5jdGlvbiBzZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbikge1xuICAgICAgZGF0YXMuZml4ZWREaXJlY3Rpb24gPSBmaXhlZERpcmVjdGlvbjtcbiAgICAgIGRhdGFzLmZpeGVkUG9zaXRpb24gPSBnZXRQb3NCeURpcmVjdGlvbihkYXRhcy5zdGFydFBvc2l0aW9ucywgZml4ZWREaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIGRhdGFzLnNldEZpeGVkRGlyZWN0aW9uID0gc2V0Rml4ZWREaXJlY3Rpb247XG4gICAgc2V0UmF0aW8oZ2V0RGlzdCQxKHBvczEsIHBvczIpIC8gZ2V0RGlzdCQxKHBvczIsIHBvczQpKTtcbiAgICBzZXRGaXhlZERpcmVjdGlvbihbLWRpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV0pO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIHNldDogZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSBzY2FsZTtcbiAgICAgIH0sXG4gICAgICBzZXRSYXRpbzogc2V0UmF0aW8sXG4gICAgICBzZXRGaXhlZERpcmVjdGlvbjogc2V0Rml4ZWREaXJlY3Rpb25cbiAgICB9LCBmaWxsVHJhbnNmb3JtU3RhcnRFdmVudChlKSksIHtcbiAgICAgIGRyYWdTdGFydDogRHJhZ2dhYmxlLmRyYWdTdGFydChtb3ZlYWJsZSwgbmV3IEN1c3RvbUdlc3RvKCkuZHJhZ1N0YXJ0KFswLCAwXSwgZSkpXG4gICAgfSkpO1xuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZVN0YXJ0XCIsIHBhcmFtcyk7XG5cbiAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgZGF0YXMuaXNTY2FsZSA9IHRydWU7XG4gICAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcbiAgICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3QsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhcy5pc1NjYWxlID8gcGFyYW1zIDogZmFsc2U7XG4gIH0sXG4gIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXNvbHZlVHJhbnNmb3JtRXZlbnQoZSwgXCJzY2FsZVwiKTtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBwYXJlbnRLZWVwUmF0aW8gPSBlLnBhcmVudEtlZXBSYXRpbyxcbiAgICAgICAgcGFyZW50RmxhZyA9IGUucGFyZW50RmxhZyxcbiAgICAgICAgaXNQaW5jaCA9IGUuaXNQaW5jaCxcbiAgICAgICAgZHJhZ0NsaWVudCA9IGUuZHJhZ0NsaWVudCxcbiAgICAgICAgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3Q7XG4gICAgdmFyIHByZXZEaXN0ID0gZGF0YXMucHJldkRpc3QsXG4gICAgICAgIGRpcmVjdGlvbiA9IGRhdGFzLmRpcmVjdGlvbixcbiAgICAgICAgc3RhcnRPZmZzZXRXaWR0aCA9IGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGgsXG4gICAgICAgIHN0YXJ0T2Zmc2V0SGVpZ2h0ID0gZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQsXG4gICAgICAgIGlzU2NhbGUgPSBkYXRhcy5pc1NjYWxlLFxuICAgICAgICBzdGFydFZhbHVlID0gZGF0YXMuc3RhcnRWYWx1ZSxcbiAgICAgICAgaXNXaWR0aCA9IGRhdGFzLmlzV2lkdGgsXG4gICAgICAgIHJhdGlvID0gZGF0YXMucmF0aW87XG5cbiAgICBpZiAoIWlzU2NhbGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcbiAgICB2YXIgdGhyb3R0bGVTY2FsZSA9IHByb3BzLnRocm90dGxlU2NhbGUsXG4gICAgICAgIHBhcmVudE1vdmVhYmxlID0gcHJvcHMucGFyZW50TW92ZWFibGU7XG4gICAgdmFyIHNpemVEaXJlY3Rpb24gPSBkaXJlY3Rpb247XG5cbiAgICBpZiAoIWRpcmVjdGlvblswXSAmJiAhZGlyZWN0aW9uWzFdKSB7XG4gICAgICBzaXplRGlyZWN0aW9uID0gWzEsIDFdO1xuICAgIH1cblxuICAgIHZhciBrZWVwUmF0aW8gPSByYXRpbyAmJiAocGFyZW50S2VlcFJhdGlvICE9IG51bGwgPyBwYXJlbnRLZWVwUmF0aW8gOiBwcm9wcy5rZWVwUmF0aW8pIHx8IGZhbHNlO1xuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuXG4gICAgZnVuY3Rpb24gZ2V0TmV4dFNjYWxlKCkge1xuICAgICAgdmFyIF9hID0gZ2V0T2Zmc2V0U2l6ZURpc3Qoc2l6ZURpcmVjdGlvbiwga2VlcFJhdGlvLCBkYXRhcywgZSksXG4gICAgICAgICAgZGlzdFdpZHRoID0gX2EuZGlzdFdpZHRoLFxuICAgICAgICAgIGRpc3RIZWlnaHQgPSBfYS5kaXN0SGVpZ2h0O1xuXG4gICAgICB2YXIgc2NhbGVYID0gKHN0YXJ0T2Zmc2V0V2lkdGggKyBkaXN0V2lkdGgpIC8gc3RhcnRPZmZzZXRXaWR0aDtcbiAgICAgIHZhciBzY2FsZVkgPSAoc3RhcnRPZmZzZXRIZWlnaHQgKyBkaXN0SGVpZ2h0KSAvIHN0YXJ0T2Zmc2V0SGVpZ2h0O1xuICAgICAgc2NhbGVYID0gc2l6ZURpcmVjdGlvblswXSB8fCBrZWVwUmF0aW8gPyBzY2FsZVggKiBzdGFydFZhbHVlWzBdIDogc3RhcnRWYWx1ZVswXTtcbiAgICAgIHNjYWxlWSA9IHNpemVEaXJlY3Rpb25bMV0gfHwga2VlcFJhdGlvID8gc2NhbGVZICogc3RhcnRWYWx1ZVsxXSA6IHN0YXJ0VmFsdWVbMV07XG5cbiAgICAgIGlmIChzY2FsZVggPT09IDApIHtcbiAgICAgICAgc2NhbGVYID0gKHByZXZEaXN0WzBdID4gMCA/IDEgOiAtMSkgKiBNSU5fU0NBTEU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2FsZVkgPT09IDApIHtcbiAgICAgICAgc2NhbGVZID0gKHByZXZEaXN0WzFdID4gMCA/IDEgOiAtMSkgKiBNSU5fU0NBTEU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbc2NhbGVYLCBzY2FsZVldO1xuICAgIH1cblxuICAgIHZhciBzY2FsZSA9IGdldE5leHRTY2FsZSgpO1xuXG4gICAgaWYgKCFpc1BpbmNoICYmIG1vdmVhYmxlLnByb3BzLmdyb3VwYWJsZSkge1xuICAgICAgdmFyIHNuYXBSZW5kZXJJbmZvID0gc3RhdGUuc25hcFJlbmRlckluZm8gfHwge307XG4gICAgICB2YXIgc3RhdGVEaXJlY3Rpb24gPSBzbmFwUmVuZGVySW5mby5kaXJlY3Rpb247XG5cbiAgICAgIGlmIChpc0FycmF5KHN0YXRlRGlyZWN0aW9uKSAmJiAoc3RhdGVEaXJlY3Rpb25bMF0gfHwgc3RhdGVEaXJlY3Rpb25bMV0pKSB7XG4gICAgICAgIHN0YXRlLnNuYXBSZW5kZXJJbmZvID0ge1xuICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlU2NhbGVcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgc2V0Rml4ZWREaXJlY3Rpb246IGZ1bmN0aW9uIChuZXh0Rml4ZWREaXJlY3Rpb24pIHtcbiAgICAgICAgZGF0YXMuc2V0Rml4ZWREaXJlY3Rpb24obmV4dEZpeGVkRGlyZWN0aW9uKTtcbiAgICAgICAgc2NhbGUgPSBnZXROZXh0U2NhbGUoKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgfSxcbiAgICAgIHNldFNjYWxlOiBmdW5jdGlvbiAobmV4dFNjYWxlKSB7XG4gICAgICAgIHNjYWxlID0gbmV4dFNjYWxlO1xuICAgICAgfVxuICAgIH0sIHRydWUpKTtcbiAgICB2YXIgZGlzdCA9IFtzY2FsZVswXSAvIHN0YXJ0VmFsdWVbMF0sIHNjYWxlWzFdIC8gc3RhcnRWYWx1ZVsxXV07XG4gICAgdmFyIGZpeGVkUG9zaXRpb24gPSBkcmFnQ2xpZW50O1xuICAgIHZhciBzbmFwRGlzdCA9IFswLCAwXTtcblxuICAgIGlmICghZHJhZ0NsaWVudCkge1xuICAgICAgaWYgKCFwYXJlbnRGbGFnICYmIGlzUGluY2gpIHtcbiAgICAgICAgZml4ZWRQb3NpdGlvbiA9IGdldEFic29sdXRlUG9zaXRpb24obW92ZWFibGUsIFswLCAwXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXhlZFBvc2l0aW9uID0gZGF0YXMuZml4ZWRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzUGluY2gpIHtcbiAgICAgIHNuYXBEaXN0ID0gY2hlY2tTbmFwU2NhbGUobW92ZWFibGUsIGRpc3QsIGRpcmVjdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcyk7XG4gICAgfVxuXG4gICAgaWYgKGtlZXBSYXRpbykge1xuICAgICAgaWYgKHNpemVEaXJlY3Rpb25bMF0gJiYgc2l6ZURpcmVjdGlvblsxXSAmJiBzbmFwRGlzdFswXSAmJiBzbmFwRGlzdFsxXSkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoc25hcERpc3RbMF0gKiBzdGFydE9mZnNldFdpZHRoKSA+IE1hdGguYWJzKHNuYXBEaXN0WzFdICogc3RhcnRPZmZzZXRIZWlnaHQpKSB7XG4gICAgICAgICAgc25hcERpc3RbMV0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNuYXBEaXN0WzBdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXNOb1NuYXAgPSAhc25hcERpc3RbMF0gJiYgIXNuYXBEaXN0WzFdO1xuXG4gICAgICBpZiAoaXNOb1NuYXApIHtcbiAgICAgICAgaWYgKGlzV2lkdGgpIHtcbiAgICAgICAgICBkaXN0WzBdID0gdGhyb3R0bGUoZGlzdFswXSAqIHN0YXJ0VmFsdWVbMF0sIHRocm90dGxlU2NhbGUpIC8gc3RhcnRWYWx1ZVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXN0WzFdID0gdGhyb3R0bGUoZGlzdFsxXSAqIHN0YXJ0VmFsdWVbMV0sIHRocm90dGxlU2NhbGUpIC8gc3RhcnRWYWx1ZVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZURpcmVjdGlvblswXSAmJiAhc2l6ZURpcmVjdGlvblsxXSB8fCBzbmFwRGlzdFswXSAmJiAhc25hcERpc3RbMV0gfHwgaXNOb1NuYXAgJiYgaXNXaWR0aCkge1xuICAgICAgICBkaXN0WzBdICs9IHNuYXBEaXN0WzBdO1xuICAgICAgICB2YXIgc25hcEhlaWdodCA9IHN0YXJ0T2Zmc2V0V2lkdGggKiBkaXN0WzBdICogc3RhcnRWYWx1ZVswXSAvIHJhdGlvO1xuICAgICAgICBkaXN0WzFdID0gc25hcEhlaWdodCAvIHN0YXJ0T2Zmc2V0SGVpZ2h0IC8gc3RhcnRWYWx1ZVsxXTtcbiAgICAgIH0gZWxzZSBpZiAoIXNpemVEaXJlY3Rpb25bMF0gJiYgc2l6ZURpcmVjdGlvblsxXSB8fCAhc25hcERpc3RbMF0gJiYgc25hcERpc3RbMV0gfHwgaXNOb1NuYXAgJiYgIWlzV2lkdGgpIHtcbiAgICAgICAgZGlzdFsxXSArPSBzbmFwRGlzdFsxXTtcbiAgICAgICAgdmFyIHNuYXBXaWR0aCA9IHN0YXJ0T2Zmc2V0SGVpZ2h0ICogZGlzdFsxXSAqIHN0YXJ0VmFsdWVbMV0gKiByYXRpbztcbiAgICAgICAgZGlzdFswXSA9IHNuYXBXaWR0aCAvIHN0YXJ0T2Zmc2V0V2lkdGggLyBzdGFydFZhbHVlWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXN0WzBdICs9IHNuYXBEaXN0WzBdO1xuICAgICAgZGlzdFsxXSArPSBzbmFwRGlzdFsxXTtcblxuICAgICAgaWYgKCFzbmFwRGlzdFswXSkge1xuICAgICAgICBkaXN0WzBdID0gdGhyb3R0bGUoZGlzdFswXSAqIHN0YXJ0VmFsdWVbMF0sIHRocm90dGxlU2NhbGUpIC8gc3RhcnRWYWx1ZVswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzbmFwRGlzdFsxXSkge1xuICAgICAgICBkaXN0WzFdID0gdGhyb3R0bGUoZGlzdFsxXSAqIHN0YXJ0VmFsdWVbMV0sIHRocm90dGxlU2NhbGUpIC8gc3RhcnRWYWx1ZVsxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlzdFswXSA9PT0gMCkge1xuICAgICAgZGlzdFswXSA9IChwcmV2RGlzdFswXSA+IDAgPyAxIDogLTEpICogTUlOX1NDQUxFO1xuICAgIH1cblxuICAgIGlmIChkaXN0WzFdID09PSAwKSB7XG4gICAgICBkaXN0WzFdID0gKHByZXZEaXN0WzFdID4gMCA/IDEgOiAtMSkgKiBNSU5fU0NBTEU7XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhID0gW2Rpc3RbMF0gLyBwcmV2RGlzdFswXSwgZGlzdFsxXSAvIHByZXZEaXN0WzFdXTtcbiAgICBzY2FsZSA9IG11bHRpcGx5MihkaXN0LCBzdGFydFZhbHVlKTtcbiAgICB2YXIgaW52ZXJzZURpc3QgPSBnZXRTY2FsZURpc3QobW92ZWFibGUsIGRpc3QsIGRhdGFzLmZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBkYXRhcyk7XG4gICAgdmFyIGludmVyc2VEZWx0YSA9IG1pbnVzKGludmVyc2VEaXN0LCBkYXRhcy5wcmV2SW52ZXJzZURpc3QgfHwgWzAsIDBdKTtcbiAgICBkYXRhcy5wcmV2RGlzdCA9IGRpc3Q7XG4gICAgZGF0YXMucHJldkludmVyc2VEaXN0ID0gaW52ZXJzZURpc3Q7XG5cbiAgICBpZiAoc2NhbGVbMF0gPT09IHByZXZEaXN0WzBdICYmIHNjYWxlWzFdID09PSBwcmV2RGlzdFsxXSAmJiBpbnZlcnNlRGVsdGEuZXZlcnkoZnVuY3Rpb24gKG51bSkge1xuICAgICAgcmV0dXJuICFudW07XG4gICAgfSkgJiYgIXBhcmVudE1vdmVhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5leHRUcmFuc2Zvcm0gPSBjb252ZXJ0VHJhbnNmb3JtRm9ybWF0KGRhdGFzLCBcInNjYWxlKFwiLmNvbmNhdChzY2FsZS5qb2luKFwiLCBcIiksIFwiKVwiKSwgXCJzY2FsZShcIi5jb25jYXQoZGlzdC5qb2luKFwiLCBcIiksIFwiKVwiKSk7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHtcbiAgICAgIG9mZnNldFdpZHRoOiBzdGFydE9mZnNldFdpZHRoLFxuICAgICAgb2Zmc2V0SGVpZ2h0OiBzdGFydE9mZnNldEhlaWdodCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgZGlzdDogZGlzdCxcbiAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgIGlzUGluY2g6ICEhaXNQaW5jaFxuICAgIH0sIGZpbGxUcmFuc2Zvcm1FdmVudChtb3ZlYWJsZSwgbmV4dFRyYW5zZm9ybSwgaW52ZXJzZURlbHRhLCBpc1BpbmNoLCBlKSkpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNjYWxlXCIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzRHJhZyA9IGUuaXNEcmFnO1xuXG4gICAgaWYgKCFkYXRhcy5pc1NjYWxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGF0YXMuaXNTY2FsZSA9IGZhbHNlO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNjYWxlRW5kXCIsIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KSk7XG4gICAgcmV0dXJuIGlzRHJhZztcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbjogZGlyZWN0aW9uQ29uZGl0aW9uLFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2xTdGFydChtb3ZlYWJsZSwgZSk7XG5cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbEV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJyZXNpemFibGVcIiwgZSk7XG5cbiAgICBmdW5jdGlvbiBzZXREaXN0KGNoaWxkLCBldikge1xuICAgICAgdmFyIGZpeGVkRGlyZWN0aW9uID0gZGF0YXMuZml4ZWREaXJlY3Rpb247XG4gICAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGRhdGFzLmZpeGVkUG9zaXRpb247XG4gICAgICB2YXIgc3RhcnRQb3NpdGlvbnMgPSBldi5kYXRhcy5zdGFydFBvc2l0aW9ucyB8fCBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShjaGlsZC5zdGF0ZSk7XG4gICAgICB2YXIgcG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24oc3RhcnRQb3NpdGlvbnMsIGZpeGVkRGlyZWN0aW9uKTtcblxuICAgICAgdmFyIF9hID0gY2FsY3VsYXRlKGNyZWF0ZVJvdGF0ZU1hdHJpeCgtbW92ZWFibGUucm90YXRpb24gLyAxODAgKiBNYXRoLlBJLCAzKSwgW3Bvc1swXSAtIGZpeGVkUG9zaXRpb25bMF0sIHBvc1sxXSAtIGZpeGVkUG9zaXRpb25bMV0sIDFdLCAzKSxcbiAgICAgICAgICBvcmlnaW5hbFggPSBfYVswXSxcbiAgICAgICAgICBvcmlnaW5hbFkgPSBfYVsxXTtcblxuICAgICAgZXYuZGF0YXMub3JpZ2luYWxYID0gb3JpZ2luYWxYO1xuICAgICAgZXYuZGF0YXMub3JpZ2luYWxZID0gb3JpZ2luYWxZO1xuICAgICAgcmV0dXJuIGV2O1xuICAgIH1cblxuICAgIGRhdGFzLm1vdmVhYmxlU2NhbGUgPSBtb3ZlYWJsZS5zY2FsZTtcbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xTdGFydFwiLCBlLCBmdW5jdGlvbiAoY2hpbGQsIGV2KSB7XG4gICAgICByZXR1cm4gc2V0RGlzdChjaGlsZCwgZXYpO1xuICAgIH0pO1xuXG4gICAgdmFyIHNldEZpeGVkRGlyZWN0aW9uID0gZnVuY3Rpb24gKGZpeGVkRGlyZWN0aW9uKSB7XG4gICAgICBwYXJhbXMuc2V0Rml4ZWREaXJlY3Rpb24oZml4ZWREaXJlY3Rpb24pO1xuICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2LCBpKSB7XG4gICAgICAgIGV2LnNldEZpeGVkRGlyZWN0aW9uKGZpeGVkRGlyZWN0aW9uKTtcbiAgICAgICAgc2V0RGlzdChldi5tb3ZlYWJsZSwgb3JpZ2luYWxFdmVudHNbaV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGRhdGFzLnNldEZpeGVkRGlyZWN0aW9uID0gc2V0Rml4ZWREaXJlY3Rpb247XG5cbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICBzZXRGaXhlZERpcmVjdGlvbjogc2V0Rml4ZWREaXJlY3Rpb25cbiAgICB9KTtcblxuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZUdyb3VwU3RhcnRcIiwgbmV4dFBhcmFtcyk7XG4gICAgZGF0YXMuaXNTY2FsZSA9IHJlc3VsdCAhPT0gZmFsc2U7XG4gICAgcmV0dXJuIGRhdGFzLmlzU2NhbGUgPyBuZXh0UGFyYW1zIDogZmFsc2U7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzU2NhbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYXRjaEV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlU2NhbGVcIiwgZnVuY3Rpb24gKHBhcmVudEV2ZW50KSB7XG4gICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVTY2FsZUdyb3VwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJlbnRFdmVudCksIHtcbiAgICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0c1xuICAgICAgfSksIHRydWUpKTtcbiAgICB9KTtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgZSk7XG5cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtb3ZlYWJsZVNjYWxlID0gZGF0YXMubW92ZWFibGVTY2FsZTtcbiAgICBtb3ZlYWJsZS5zY2FsZSA9IFtwYXJhbXMuc2NhbGVbMF0gKiBtb3ZlYWJsZVNjYWxlWzBdLCBwYXJhbXMuc2NhbGVbMV0gKiBtb3ZlYWJsZVNjYWxlWzFdXTtcbiAgICB2YXIga2VlcFJhdGlvID0gbW92ZWFibGUucHJvcHMua2VlcFJhdGlvO1xuICAgIHZhciBkaXN0ID0gcGFyYW1zLmRpc3QsXG4gICAgICAgIHNjYWxlID0gcGFyYW1zLnNjYWxlO1xuICAgIHZhciBmaXhlZFBvc2l0aW9uID0gZGF0YXMuZml4ZWRQb3NpdGlvbjtcbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xcIiwgZSwgZnVuY3Rpb24gKF8sIGV2KSB7XG4gICAgICB2YXIgX2EgPSBjYWxjdWxhdGUoY3JlYXRlUm90YXRlTWF0cml4KG1vdmVhYmxlLnJvdGF0aW9uIC8gMTgwICogTWF0aC5QSSwgMyksIFtldi5kYXRhcy5vcmlnaW5hbFggKiBkaXN0WzBdLCBldi5kYXRhcy5vcmlnaW5hbFkgKiBkaXN0WzFdLCAxXSwgMyksXG4gICAgICAgICAgY2xpZW50WCA9IF9hWzBdLFxuICAgICAgICAgIGNsaWVudFkgPSBfYVsxXTtcblxuICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldiksIHtcbiAgICAgICAgcGFyZW50RGlzdDogbnVsbCxcbiAgICAgICAgcGFyZW50U2NhbGU6IHNjYWxlLFxuICAgICAgICBwYXJlbnRLZWVwUmF0aW86IGtlZXBSYXRpbyxcbiAgICAgICAgZHJhZ0NsaWVudDogcGx1cyhmaXhlZFBvc2l0aW9uLCBbY2xpZW50WCwgY2xpZW50WV0pXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oe1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSwgcGFyYW1zKTtcblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNjYWxlR3JvdXBcIiwgbmV4dFBhcmFtcyk7XG4gICAgcmV0dXJuIG5leHRQYXJhbXM7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBpc0RyYWcgPSBlLmlzRHJhZyxcbiAgICAgICAgZGF0YXMgPSBlLmRhdGFzO1xuXG4gICAgaWYgKCFkYXRhcy5pc1NjYWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnQ29udHJvbEVuZChtb3ZlYWJsZSwgZSk7XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sRW5kXCIsIGUpO1xuICAgIHZhciBuZXh0UGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uU2NhbGVHcm91cEVuZFwiLCBuZXh0UGFyYW1zKTtcbiAgICByZXR1cm4gaXNEcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlLlNjYWxhYmxlI3JlcXVlc3RcbiAgICogQHBhcmFtIHtNb3ZlYWJsZS5TY2FsYWJsZS5TY2FsYWJsZVJlcXVlc3RQYXJhbX0gZSAtIHRoZSBTY2FsYWJsZSdzIHJlcXVlc3QgcGFyYW1ldGVyXG4gICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXG4gICAqIEBleGFtcGxlXG4gICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJzY2FsYWJsZVwiLCB7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSwgdHJ1ZSk7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RTdGFydFxuICAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwic2NhbGFibGVcIik7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcbiAgICpcbiAgICogLy8gcmVxdWVzdEVuZFxuICAgKiByZXF1ZXN0ZXIucmVxdWVzdEVuZCgpO1xuICAgKi9cbiAgcmVxdWVzdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhcyA9IHt9O1xuICAgIHZhciBkaXN0V2lkdGggPSAwO1xuICAgIHZhciBkaXN0SGVpZ2h0ID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb250cm9sOiB0cnVlLFxuICAgICAgcmVxdWVzdFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgICBwYXJlbnREaXJlY3Rpb246IGUuZGlyZWN0aW9uIHx8IFsxLCAxXVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRpc3RXaWR0aCArPSBlLmRlbHRhV2lkdGg7XG4gICAgICAgIGRpc3RIZWlnaHQgKz0gZS5kZWx0YUhlaWdodDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgcGFyZW50RGlzdDogW2Rpc3RXaWR0aCwgZGlzdEhlaWdodF0sXG4gICAgICAgICAgcGFyZW50S2VlcFJhdGlvOiBlLmtlZXBSYXRpb1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgaXNEcmFnOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBzY2FsZWQuXG4gKlxuICogQG5hbWUgTW92ZWFibGUuU2NhbGFibGUjc2NhbGFibGVcbiAqIEBkZWZhdWx0IGZhbHNlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnNjYWxhYmxlID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIHRocm90dGxlIG9mIHNjYWxlWCwgc2NhbGVZIHdoZW4gc2NhbGUuXG4gKiBAbmFtZSBNb3ZlYWJsZS5TY2FsYWJsZSN0aHJvdHRsZVNjYWxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnRocm90dGxlU2NhbGUgPSAwLjE7XG4gKi9cblxuLyoqXG4gKiBTZXQgZGlyZWN0aW9ucyB0byBzaG93IHRoZSBjb250cm9sIGJveC4gKGRlZmF1bHQ6IFtcIm5cIiwgXCJud1wiLCBcIm5lXCIsIFwic1wiLCBcInNlXCIsIFwic3dcIiwgXCJlXCIsIFwid1wiXSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNjYWxhYmxlI3JlbmRlckRpcmVjdGlvbnNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHNjYWxhYmxlOiB0cnVlLFxuICogICByZW5kZXJEaXJlY3Rpb25zOiBbXCJuXCIsIFwibndcIiwgXCJuZVwiLCBcInNcIiwgXCJzZVwiLCBcInN3XCIsIFwiZVwiLCBcIndcIl0sXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS5yZW5kZXJEaXJlY3Rpb25zID0gW1wibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl07XG4gKi9cblxuLyoqXG4gKiBXaGVuIHJlc2l6ZSBvciBzY2FsZSwga2VlcHMgYSByYXRpbyBvZiB0aGUgd2lkdGgsIGhlaWdodC4gKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuU2NhbGFibGUja2VlcFJhdGlvXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBzY2FsYWJsZTogdHJ1ZSxcbiAqIH0pO1xuICpcbiAqIG1vdmVhYmxlLmtlZXBSYXRpbyA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBzY2FsZSBzdGFydHMsIHRoZSBzY2FsZVN0YXJ0IGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxuICogQGV2ZW50IHNjYWxlU3RhcnRcbiAqIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZVN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBzY2FsZVN0YXJ0IGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgc2NhbGFibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHNjYWxpbmcsIGBiZWZvcmVTY2FsZWAgaXMgY2FsbGVkIGJlZm9yZSBgc2NhbGVgIG9jY3Vycy4gSW4gYGJlZm9yZVNjYWxlYCwgeW91IGNhbiBnZXQgYW5kIHNldCB0aGUgcHJlLXZhbHVlIGJlZm9yZSBzY2FsaW5nLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjYWxhYmxlXG4gKiBAZXZlbnQgYmVmb3JlU2NhbGVcbiAqIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25CZWZvcmVTY2FsZX0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGJlZm9yZVNjYWxlYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHNjYWxhYmxlOiB0cnVlIH0pO1xuICogbW92ZWFibGUub24oXCJiZWZvcmVTY2FsZVwiLCAoeyBzZXRGaXhlZERpcmVjdGlvbiB9KSA9PiB7XG4gKiAgICAgaWYgKHNoaWZ0S2V5KSB7XG4gKiAgICAgICAgc2V0Rml4ZWREaXJlY3Rpb24oWzAsIDBdKTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVcIiwgKHsgdGFyZ2V0LCB0cmFuc2Zvcm0sIGRpc3QgfSkgPT4ge1xuICogICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gc2NhbGluZywgdGhlIGBzY2FsZWAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjYWxhYmxlXG4gKiBAZXZlbnQgc2NhbGVcbiAqIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZX0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjYWxlYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHNjYWxhYmxlOiB0cnVlIH0pO1xuICogbW92ZWFibGUub24oXCJzY2FsZVwiLCAoeyB0YXJnZXQsIHRyYW5zZm9ybSwgZGlzdCB9KSA9PiB7XG4gKiAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgc2NhbGUgZmluaXNoZXMsIHRoZSBgc2NhbGVFbmRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxuICogQGV2ZW50IHNjYWxlRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uU2NhbGVFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBzY2FsZUVuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBzY2FsYWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVFbmRcIiwgKHsgdGFyZ2V0LCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCwgaXNEcmFnKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuKiBXaGVuIHRoZSBncm91cCBzY2FsZSBzdGFydHMsIHRoZSBgc2NhbGVHcm91cFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxuKiBAZXZlbnQgc2NhbGVHcm91cFN0YXJ0XG4qIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZUdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBzY2FsZUdyb3VwU3RhcnRgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiogICAgIHNjYWxhYmxlOiB0cnVlXG4qIH0pO1xuKiBtb3ZlYWJsZS5vbihcInNjYWxlR3JvdXBTdGFydFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcbiogICAgIGNvbnNvbGUubG9nKFwib25TY2FsZUdyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XG4qIH0pO1xuKi9cblxuLyoqXG4qIFdoZW4gdGhlIGdyb3VwIHNjYWxlLCB0aGUgYHNjYWxlR3JvdXBgIGV2ZW50IGlzIGNhbGxlZC5cbiogQG1lbWJlcm9mIE1vdmVhYmxlLlNjYWxhYmxlXG4qIEBldmVudCBzY2FsZUdyb3VwXG4qIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZUdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgc2NhbGVHcm91cGAgZXZlbnRcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuKiAgICAgc2NhbGFibGU6IHRydWVcbiogfSk7XG4qIG1vdmVhYmxlLm9uKFwic2NhbGVHcm91cFwiLCAoeyB0YXJnZXRzLCBldmVudHMgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2coXCJvblNjYWxlR3JvdXBcIiwgdGFyZ2V0cyk7XG4qICAgICBldmVudHMuZm9yRWFjaChldiA9PiB7XG4qICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuKiAgICAgICAgIC8vIGV2LmRyYWcgaXMgYSBkcmFnIGV2ZW50IHRoYXQgb2NjdXJzIHdoZW4gdGhlIGdyb3VwIHNjYWxlLlxuKiAgICAgICAgIGNvbnN0IGxlZnQgPSBldi5kcmFnLmJlZm9yZURpc3RbMF07XG4qICAgICAgICAgY29uc3QgdG9wID0gZXYuZHJhZy5iZWZvcmVEaXN0WzFdO1xuKiAgICAgICAgIGNvbnN0IHNjYWxlWCA9IGV2LnNjYWxlWzBdO1xuKiAgICAgICAgIGNvbnN0IHNjYWxlWSA9IGV2LnNjYWxlWzFdO1xuKiAgICAgfSk7XG4qIH0pO1xuKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBncm91cCBzY2FsZSBmaW5pc2hlcywgdGhlIGBzY2FsZUdyb3VwRW5kYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU2NhbGFibGVcbiAqIEBldmVudCBzY2FsZUdyb3VwRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uU2NhbGVHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjYWxlR3JvdXBFbmRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuICogICAgIHNjYWxhYmxlOiB0cnVlXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVHcm91cEVuZFwiLCAoeyB0YXJnZXRzLCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25TY2FsZUdyb3VwRW5kXCIsIHRhcmdldHMsIGlzRHJhZyk7XG4gKiB9KTtcbiAqL1xuXG5mdW5jdGlvbiBnZXRNaWRkbGVMaW5lUG9zKHBvczEsIHBvczIpIHtcbiAgcmV0dXJuIHBvczEubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHtcbiAgICByZXR1cm4gZG90KHBvcywgcG9zMltpXSwgMSwgMik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRUcmlhbmdsZVJhZChwb3MxLCBwb3MyLCBwb3MzKSB7XG4gIC8vIHBvczEgUmFkXG4gIHZhciByYWQxID0gZ2V0UmFkKHBvczEsIHBvczIpO1xuICB2YXIgcmFkMiA9IGdldFJhZChwb3MxLCBwb3MzKTtcbiAgdmFyIHJhZCA9IHJhZDIgLSByYWQxO1xuICByZXR1cm4gcmFkID49IDAgPyByYWQgOiByYWQgKyAyICogTWF0aC5QSTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvcyhwb3NlczEsIHBvc2VzMikge1xuICB2YXIgcmFkMSA9IGdldFRyaWFuZ2xlUmFkKHBvc2VzMVswXSwgcG9zZXMxWzFdLCBwb3NlczFbMl0pO1xuICB2YXIgcmFkMiA9IGdldFRyaWFuZ2xlUmFkKHBvc2VzMlswXSwgcG9zZXMyWzFdLCBwb3NlczJbMl0pO1xuICB2YXIgcGkgPSBNYXRoLlBJO1xuXG4gIGlmIChyYWQxID49IHBpICYmIHJhZDIgPD0gcGkgfHwgcmFkMSA8PSBwaSAmJiByYWQyID49IHBpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuV2FycGFibGVcbiAqIEBkZXNjcmlwdGlvbiBXYXJwYWJsZSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0IGNhbiBiZSB3YXJwZWQoZGlzdG9ydGVkLCBiZW50ZWQpLlxuICovXG5cblxudmFyIFdhcnBhYmxlID0ge1xuICBuYW1lOiBcIndhcnBhYmxlXCIsXG4gIGFibGVHcm91cDogXCJzaXplXCIsXG4gIHByb3BzOiB7XG4gICAgd2FycGFibGU6IEJvb2xlYW4sXG4gICAgcmVuZGVyRGlyZWN0aW9uczogQXJyYXlcbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25XYXJwU3RhcnQ6IFwid2FycFN0YXJ0XCIsXG4gICAgb25XYXJwOiBcIndhcnBcIixcbiAgICBvbldhcnBFbmQ6IFwid2FycEVuZFwiXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICByZXNpemFibGUgPSBfYS5yZXNpemFibGUsXG4gICAgICAgIHNjYWxhYmxlID0gX2Euc2NhbGFibGUsXG4gICAgICAgIHdhcnBhYmxlID0gX2Eud2FycGFibGUsXG4gICAgICAgIHpvb20gPSBfYS56b29tO1xuXG4gICAgaWYgKHJlc2l6YWJsZSB8fCBzY2FsYWJsZSB8fCAhd2FycGFibGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgcG9zMSA9IF9iLnBvczEsXG4gICAgICAgIHBvczIgPSBfYi5wb3MyLFxuICAgICAgICBwb3MzID0gX2IucG9zMyxcbiAgICAgICAgcG9zNCA9IF9iLnBvczQ7XG4gICAgdmFyIGxpbmVQb3NGcm9tMSA9IGdldE1pZGRsZUxpbmVQb3MocG9zMSwgcG9zMik7XG4gICAgdmFyIGxpbmVQb3NGcm9tMiA9IGdldE1pZGRsZUxpbmVQb3MocG9zMiwgcG9zMSk7XG4gICAgdmFyIGxpbmVQb3NGcm9tMyA9IGdldE1pZGRsZUxpbmVQb3MocG9zMSwgcG9zMyk7XG4gICAgdmFyIGxpbmVQb3NGcm9tNCA9IGdldE1pZGRsZUxpbmVQb3MocG9zMywgcG9zMSk7XG4gICAgdmFyIGxpbmVQb3NUbzEgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczMsIHBvczQpO1xuICAgIHZhciBsaW5lUG9zVG8yID0gZ2V0TWlkZGxlTGluZVBvcyhwb3M0LCBwb3MzKTtcbiAgICB2YXIgbGluZVBvc1RvMyA9IGdldE1pZGRsZUxpbmVQb3MocG9zMiwgcG9zNCk7XG4gICAgdmFyIGxpbmVQb3NUbzQgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczQsIHBvczIpO1xuICAgIHJldHVybiBfX3NwcmVhZEFycmF5KFtSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwibGluZVwiKSxcbiAgICAgIGtleTogXCJtaWRkZUxpbmUxXCIsXG4gICAgICBzdHlsZTogZ2V0TGluZVN0eWxlKGxpbmVQb3NGcm9tMSwgbGluZVBvc1RvMSwgem9vbSlcbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IHByZWZpeChcImxpbmVcIiksXG4gICAgICBrZXk6IFwibWlkZGVMaW5lMlwiLFxuICAgICAgc3R5bGU6IGdldExpbmVTdHlsZShsaW5lUG9zRnJvbTIsIGxpbmVQb3NUbzIsIHpvb20pXG4gICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJsaW5lXCIpLFxuICAgICAga2V5OiBcIm1pZGRlTGluZTNcIixcbiAgICAgIHN0eWxlOiBnZXRMaW5lU3R5bGUobGluZVBvc0Zyb20zLCBsaW5lUG9zVG8zLCB6b29tKVxuICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwibGluZVwiKSxcbiAgICAgIGtleTogXCJtaWRkZUxpbmU0XCIsXG4gICAgICBzdHlsZTogZ2V0TGluZVN0eWxlKGxpbmVQb3NGcm9tNCwgbGluZVBvc1RvNCwgem9vbSlcbiAgICB9KV0sIHJlbmRlckFsbERpcmVjdGlvbnMobW92ZWFibGUsIFJlYWN0KSwgdHJ1ZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICBpZiAoZS5pc1JlcXVlc3QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzQ2xhc3MoZS5pbnB1dEV2ZW50LnRhcmdldCwgcHJlZml4KFwiZGlyZWN0aW9uXCIpKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcbiAgICB2YXIgdGFyZ2V0ID0gbW92ZWFibGUucHJvcHMudGFyZ2V0O1xuICAgIHZhciBpbnB1dFRhcmdldCA9IGlucHV0RXZlbnQudGFyZ2V0O1xuICAgIHZhciBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXRUYXJnZXQpO1xuXG4gICAgaWYgKCFkaXJlY3Rpb24gfHwgIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICAgIGlzM2QgPSBzdGF0ZS5pczNkLFxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm0gPSBzdGF0ZS50YXJnZXRUcmFuc2Zvcm0sXG4gICAgICAgIHRhcmdldE1hdHJpeCA9IHN0YXRlLnRhcmdldE1hdHJpeCxcbiAgICAgICAgd2lkdGggPSBzdGF0ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0LFxuICAgICAgICBsZWZ0ID0gc3RhdGUubGVmdCxcbiAgICAgICAgdG9wID0gc3RhdGUudG9wO1xuICAgIGRhdGFzLmRhdGFzID0ge307XG4gICAgZGF0YXMudGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0VHJhbnNmb3JtO1xuICAgIGRhdGFzLndhcnBUYXJnZXRNYXRyaXggPSBpczNkID8gdGFyZ2V0TWF0cml4IDogY29udmVydERpbWVuc2lvbih0YXJnZXRNYXRyaXgsIDMsIDQpO1xuICAgIGRhdGFzLnRhcmdldEludmVyc2VNYXRyaXggPSBpZ25vcmVEaW1lbnNpb24oaW52ZXJ0KGRhdGFzLndhcnBUYXJnZXRNYXRyaXgsIDQpLCAzLCA0KTtcbiAgICBkYXRhcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgZGF0YXMubGVmdCA9IGxlZnQ7XG4gICAgZGF0YXMudG9wID0gdG9wO1xuICAgIGRhdGFzLnBvc2VzID0gW1swLCAwXSwgW3dpZHRoLCAwXSwgWzAsIGhlaWdodF0sIFt3aWR0aCwgaGVpZ2h0XV0ubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gbWludXMocCwgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICB9KTtcbiAgICBkYXRhcy5uZXh0UG9zZXMgPSBkYXRhcy5wb3Nlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgeCA9IF9hWzBdLFxuICAgICAgICAgIHkgPSBfYVsxXTtcbiAgICAgIHJldHVybiBjYWxjdWxhdGUoZGF0YXMud2FycFRhcmdldE1hdHJpeCwgW3gsIHksIDAsIDFdLCA0KTtcbiAgICB9KTtcbiAgICBkYXRhcy5zdGFydFZhbHVlID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgoNCk7XG4gICAgZGF0YXMucHJldk1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KDQpO1xuICAgIGRhdGFzLmFic29sdXRlUG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShzdGF0ZSk7XG4gICAgZGF0YXMucG9zSW5kZXhlcyA9IGdldFBvc0luZGV4ZXNCeURpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gICAgc2V0RGVmYXVsdFRyYW5zZm9ybUluZGV4KGUsIFwibWF0cml4M2RcIik7XG4gICAgc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XG4gICAgICByZXF1ZXN0OiBlLmlzUmVxdWVzdCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oe1xuICAgICAgc2V0OiBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSBtYXRyaXg7XG4gICAgICB9XG4gICAgfSwgZmlsbFRyYW5zZm9ybVN0YXJ0RXZlbnQoZSkpKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uV2FycFN0YXJ0XCIsIHBhcmFtcyk7XG5cbiAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgZGF0YXMuaXNXYXJwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YXMuaXNXYXJwO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3Q7XG4gICAgdmFyIGRpc3RYID0gZS5kaXN0WCxcbiAgICAgICAgZGlzdFkgPSBlLmRpc3RZO1xuICAgIHZhciB0YXJnZXRJbnZlcnNlTWF0cml4ID0gZGF0YXMudGFyZ2V0SW52ZXJzZU1hdHJpeCxcbiAgICAgICAgcHJldk1hdHJpeCA9IGRhdGFzLnByZXZNYXRyaXgsXG4gICAgICAgIGlzV2FycCA9IGRhdGFzLmlzV2FycCxcbiAgICAgICAgc3RhcnRWYWx1ZSA9IGRhdGFzLnN0YXJ0VmFsdWUsXG4gICAgICAgIHBvc2VzID0gZGF0YXMucG9zZXMsXG4gICAgICAgIHBvc0luZGV4ZXMgPSBkYXRhcy5wb3NJbmRleGVzLFxuICAgICAgICBhYnNvbHV0ZVBvc2VzID0gZGF0YXMuYWJzb2x1dGVQb3NlcztcblxuICAgIGlmICghaXNXYXJwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzb2x2ZVRyYW5zZm9ybUV2ZW50KGUsIFwibWF0cml4M2RcIik7XG5cbiAgICBpZiAoaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJ3YXJwYWJsZVwiKSkge1xuICAgICAgdmFyIHNlbGVjdGVkUG9zZXMgPSBwb3NJbmRleGVzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlUG9zZXNbaW5kZXhdO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZWxlY3RlZFBvc2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2VsZWN0ZWRQb3Nlcy5wdXNoKFsoc2VsZWN0ZWRQb3Nlc1swXVswXSArIHNlbGVjdGVkUG9zZXNbMV1bMF0pIC8gMiwgKHNlbGVjdGVkUG9zZXNbMF1bMV0gKyBzZWxlY3RlZFBvc2VzWzFdWzFdKSAvIDJdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9hID0gY2hlY2tNb3ZlYWJsZVNuYXBCb3VuZHMobW92ZWFibGUsIGlzUmVxdWVzdCwge1xuICAgICAgICBob3Jpem9udGFsOiBzZWxlY3RlZFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc1sxXSArIGRpc3RZO1xuICAgICAgICB9KSxcbiAgICAgICAgdmVydGljYWw6IHNlbGVjdGVkUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICByZXR1cm4gcG9zWzBdICsgZGlzdFg7XG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgICAgICBob3Jpem9udGFsU25hcEluZm8gPSBfYS5ob3Jpem9udGFsLFxuICAgICAgICAgIHZlcnRpY2FsU25hcEluZm8gPSBfYS52ZXJ0aWNhbDtcblxuICAgICAgZGlzdFkgLT0gaG9yaXpvbnRhbFNuYXBJbmZvLm9mZnNldDtcbiAgICAgIGRpc3RYIC09IHZlcnRpY2FsU25hcEluZm8ub2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciBkaXN0ID0gZ2V0RHJhZ0Rpc3Qoe1xuICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgZGlzdFg6IGRpc3RYLFxuICAgICAgZGlzdFk6IGRpc3RZXG4gICAgfSwgdHJ1ZSk7XG4gICAgdmFyIG5leHRQb3NlcyA9IGRhdGFzLm5leHRQb3Nlcy5zbGljZSgpO1xuICAgIHBvc0luZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIG5leHRQb3Nlc1tpbmRleF0gPSBwbHVzKG5leHRQb3Nlc1tpbmRleF0sIGRpc3QpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFORUFSQllfUE9TLmV2ZXJ5KGZ1bmN0aW9uIChuZWFyQnlQb3Nlcykge1xuICAgICAgcmV0dXJuIGlzVmFsaWRQb3MobmVhckJ5UG9zZXMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBwb3Nlc1tpXTtcbiAgICAgIH0pLCBuZWFyQnlQb3Nlcy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIG5leHRQb3Nlc1tpXTtcbiAgICAgIH0pKTtcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBoID0gY3JlYXRlV2FycE1hdHJpeChwb3Nlc1swXSwgcG9zZXNbMl0sIHBvc2VzWzFdLCBwb3Nlc1szXSwgbmV4dFBvc2VzWzBdLCBuZXh0UG9zZXNbMl0sIG5leHRQb3Nlc1sxXSwgbmV4dFBvc2VzWzNdKTtcblxuICAgIGlmICghaC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIEIgKiBBICogTVxuXG5cbiAgICB2YXIgYWZ0ZXJNYXRyaXggPSBtdWx0aXBseSh0YXJnZXRJbnZlcnNlTWF0cml4LCBoLCA0KTsgLy8gQiAqIE0gKiBBXG5cbiAgICB2YXIgbWF0cml4ID0gZ2V0VHJhbnNmcm9tTWF0cml4KGRhdGFzLCBhZnRlck1hdHJpeCwgdHJ1ZSk7XG4gICAgdmFyIGRlbHRhID0gbXVsdGlwbHkoaW52ZXJ0KHByZXZNYXRyaXgsIDQpLCBtYXRyaXgsIDQpO1xuICAgIGRhdGFzLnByZXZNYXRyaXggPSBtYXRyaXg7XG4gICAgdmFyIHRvdGFsTWF0cml4ID0gbXVsdGlwbHkoc3RhcnRWYWx1ZSwgbWF0cml4LCA0KTtcbiAgICB2YXIgbmV4dFRyYW5zZm9ybSA9IGNvbnZlcnRUcmFuc2Zvcm1Gb3JtYXQoZGF0YXMsIFwibWF0cml4M2QoXCIuY29uY2F0KHRvdGFsTWF0cml4LmpvaW4oXCIsIFwiKSwgXCIpXCIpLCBcIm1hdHJpeDNkKFwiLmNvbmNhdChtYXRyaXguam9pbihcIiwgXCIpLCBcIilcIikpO1xuICAgIGZpbGxPcmlnaW5hbFRyYW5zZm9ybShlLCBuZXh0VHJhbnNmb3JtKTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25XYXJwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgIG1hdHJpeDogdG90YWxNYXRyaXgsXG4gICAgICBkaXN0OiBtYXRyaXgsXG4gICAgICBtdWx0aXBseTogbXVsdGlwbHksXG4gICAgICB0cmFuc2Zvcm06IG5leHRUcmFuc2Zvcm1cbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBpc0RyYWcgPSBlLmlzRHJhZztcblxuICAgIGlmICghZGF0YXMuaXNXYXJwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGF0YXMuaXNXYXJwID0gZmFsc2U7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uV2FycEVuZFwiLCBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSkpO1xuICAgIHJldHVybiBpc0RyYWc7XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgd2FycGVkLiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5XYXJwYWJsZSN3YXJwYWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS53YXJwYWJsZSA9IHRydWU7XG4gKi9cblxuLyoqXG4qIFNldCBkaXJlY3Rpb25zIHRvIHNob3cgdGhlIGNvbnRyb2wgYm94LiAoZGVmYXVsdDogW1wiblwiLCBcIm53XCIsIFwibmVcIiwgXCJzXCIsIFwic2VcIiwgXCJzd1wiLCBcImVcIiwgXCJ3XCJdKVxuKiBAbmFtZSBNb3ZlYWJsZS5XYXJwYWJsZSNyZW5kZXJEaXJlY3Rpb25zXG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgd2FycGFibGU6IHRydWUsXG4qICAgICByZW5kZXJEaXJlY3Rpb25zOiBbXCJuXCIsIFwibndcIiwgXCJuZVwiLCBcInNcIiwgXCJzZVwiLCBcInN3XCIsIFwiZVwiLCBcIndcIl0sXG4qIH0pO1xuKlxuKiBtb3ZlYWJsZS5yZW5kZXJEaXJlY3Rpb25zID0gW1wibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl07XG4qL1xuXG4vKipcbiogV2hlbiB0aGUgd2FycCBzdGFydHMsIHRoZSB3YXJwU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuV2FycGFibGVcbiogQGV2ZW50IHdhcnBTdGFydFxuKiBAcGFyYW0ge01vdmVhYmxlLldhcnBhYmxlLk9uV2FycFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSB3YXJwU3RhcnQgZXZlbnRcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHdhcnBhYmxlOiB0cnVlIH0pO1xuKiBtb3ZlYWJsZS5vbihcIndhcnBTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiogfSk7XG4qL1xuXG4vKipcbiAqIFdoZW4gd2FycGluZywgdGhlIHdhcnAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLldhcnBhYmxlXG4gKiBAZXZlbnQgd2FycFxuICogQHBhcmFtIHtNb3ZlYWJsZS5XYXJwYWJsZS5PbldhcnB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHdhcnAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKiBsZXQgbWF0cml4ID0gW1xuICogIDEsIDAsIDAsIDAsXG4gKiAgMCwgMSwgMCwgMCxcbiAqICAwLCAwLCAxLCAwLFxuICogIDAsIDAsIDAsIDEsXG4gKiBdO1xuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyB3YXJwYWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwid2FycFwiLCAoeyB0YXJnZXQsIHRyYW5zZm9ybSwgZGVsdGEsIG11bHRpcGx5IH0pID0+IHtcbiAqICAgIC8vIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gKiAgICBtYXRyaXggPSBtdWx0aXBseShtYXRyaXgsIGRlbHRhKTtcbiAqICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSBgbWF0cml4M2QoJHttYXRyaXguam9pbihcIixcIil9KWA7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIHdhcnAgZmluaXNoZXMsIHRoZSB3YXJwRW5kIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5XYXJwYWJsZVxuICogQGV2ZW50IHdhcnBFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuV2FycGFibGUuT25XYXJwRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSB3YXJwRW5kIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgd2FycGFibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcIndhcnBFbmRcIiwgKHsgdGFyZ2V0LCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCwgaXNEcmFnKTtcbiAqIH0pO1xuICovXG5cbnZhciBBUkVBX1BJRUNFUyA9IC8qI19fUFVSRV9fKi9wcmVmaXgoXCJhcmVhLXBpZWNlc1wiKTtcbnZhciBBUkVBX1BJRUNFID0gLyojX19QVVJFX18qL3ByZWZpeChcImFyZWEtcGllY2VcIik7XG52YXIgQVZPSUQgPSAvKiNfX1BVUkVfXyovcHJlZml4KFwiYXZvaWRcIik7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdHlsZShtb3ZlYWJsZSkge1xuICB2YXIgZWwgPSBtb3ZlYWJsZS5hcmVhRWxlbWVudDtcblxuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICByZW1vdmVDbGFzcyhlbCwgQVZPSUQpO1xuICBlbC5zdHlsZS5jc3NUZXh0ICs9IFwibGVmdDogMHB4OyB0b3A6IDBweDsgd2lkdGg6IFwiLmNvbmNhdCh3aWR0aCwgXCJweDsgaGVpZ2h0OiBcIikuY29uY2F0KGhlaWdodCwgXCJweFwiKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUGllY2VzKFJlYWN0KSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwiYXJlYV9waWVjZXNcIixcbiAgICBjbGFzc05hbWU6IEFSRUFfUElFQ0VTXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogQVJFQV9QSUVDRVxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBBUkVBX1BJRUNFXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IEFSRUFfUElFQ0VcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogQVJFQV9QSUVDRVxuICB9KSk7XG59XG5cbnZhciBEcmFnQXJlYSA9IHtcbiAgbmFtZTogXCJkcmFnQXJlYVwiLFxuICBwcm9wczoge1xuICAgIGRyYWdBcmVhOiBCb29sZWFuLFxuICAgIHBhc3NEcmFnQXJlYTogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHtcbiAgICBvbkNsaWNrOiBcImNsaWNrXCIsXG4gICAgb25DbGlja0dyb3VwOiBcImNsaWNrR3JvdXBcIlxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgdGFyZ2V0ID0gX2EudGFyZ2V0LFxuICAgICAgICBkcmFnQXJlYSA9IF9hLmRyYWdBcmVhLFxuICAgICAgICBncm91cGFibGUgPSBfYS5ncm91cGFibGUsXG4gICAgICAgIHBhc3NEcmFnQXJlYSA9IF9hLnBhc3NEcmFnQXJlYTtcbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgd2lkdGggPSBfYi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2IuaGVpZ2h0LFxuICAgICAgICByZW5kZXJQb3NlcyA9IF9iLnJlbmRlclBvc2VzO1xuICAgIHZhciBjbGFzc05hbWUgPSBwYXNzRHJhZ0FyZWEgPyBwcmVmaXgoXCJhcmVhXCIsIFwicGFzc1wiKSA6IHByZWZpeChcImFyZWFcIik7XG5cbiAgICBpZiAoZ3JvdXBhYmxlKSB7XG4gICAgICByZXR1cm4gW1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IFwiYXJlYVwiLFxuICAgICAgICByZWY6IHJlZihtb3ZlYWJsZSwgXCJhcmVhRWxlbWVudFwiKSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICAgIH0pLCByZW5kZXJQaWVjZXMoUmVhY3QpXTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldCB8fCAhZHJhZ0FyZWEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgaCA9IGNyZWF0ZVdhcnBNYXRyaXgoWzAsIDBdLCBbd2lkdGgsIDBdLCBbMCwgaGVpZ2h0XSwgW3dpZHRoLCBoZWlnaHRdLCByZW5kZXJQb3Nlc1swXSwgcmVuZGVyUG9zZXNbMV0sIHJlbmRlclBvc2VzWzJdLCByZW5kZXJQb3Nlc1szXSk7XG4gICAgdmFyIHRyYW5zZm9ybSA9IGgubGVuZ3RoID8gbWFrZU1hdHJpeENTUyhoLCB0cnVlKSA6IFwibm9uZVwiO1xuICAgIHJldHVybiBbUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBrZXk6IFwiYXJlYVwiLFxuICAgICAgcmVmOiByZWYobW92ZWFibGUsIFwiYXJlYUVsZW1lbnRcIiksXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHRvcDogXCIwcHhcIixcbiAgICAgICAgbGVmdDogXCIwcHhcIixcbiAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpLFxuICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjAgMFwiLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVxuICAgICAgfVxuICAgIH0pLCByZW5kZXJQaWVjZXMoUmVhY3QpXTtcbiAgfSxcbiAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIF9hKSB7XG4gICAgdmFyIGRhdGFzID0gX2EuZGF0YXMsXG4gICAgICAgIGNsaWVudFggPSBfYS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZID0gX2EuY2xpZW50WSxcbiAgICAgICAgaW5wdXRFdmVudCA9IF9hLmlucHV0RXZlbnQ7XG5cbiAgICBpZiAoIWlucHV0RXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkYXRhcy5pc0RyYWdBcmVhID0gZmFsc2U7XG4gICAgdmFyIGFyZWFFbGVtZW50ID0gbW92ZWFibGUuYXJlYUVsZW1lbnQ7XG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gICAgdmFyIG1vdmVhYmxlQ2xpZW50UmVjdCA9IHN0YXRlLm1vdmVhYmxlQ2xpZW50UmVjdCxcbiAgICAgICAgcmVuZGVyUG9zZXMgPSBzdGF0ZS5yZW5kZXJQb3NlcyxcbiAgICAgICAgcm9vdE1hdHJpeCA9IHN0YXRlLnJvb3RNYXRyaXgsXG4gICAgICAgIGlzM2QgPSBzdGF0ZS5pczNkO1xuICAgIHZhciBsZWZ0ID0gbW92ZWFibGVDbGllbnRSZWN0LmxlZnQsXG4gICAgICAgIHRvcCA9IG1vdmVhYmxlQ2xpZW50UmVjdC50b3A7XG5cbiAgICB2YXIgX2IgPSBnZXRSZWN0KHJlbmRlclBvc2VzKSxcbiAgICAgICAgcmVsYXRpdmVMZWZ0ID0gX2IubGVmdCxcbiAgICAgICAgcmVsYXRpdmVUb3AgPSBfYi50b3AsXG4gICAgICAgIHdpZHRoID0gX2Iud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9iLmhlaWdodDtcblxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuXG4gICAgdmFyIF9jID0gY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uKHJvb3RNYXRyaXgsIFtjbGllbnRYIC0gbGVmdCwgY2xpZW50WSAtIHRvcF0sIG4pLFxuICAgICAgICBwb3NYID0gX2NbMF0sXG4gICAgICAgIHBvc1kgPSBfY1sxXTtcblxuICAgIHBvc1ggLT0gcmVsYXRpdmVMZWZ0O1xuICAgIHBvc1kgLT0gcmVsYXRpdmVUb3A7XG4gICAgdmFyIHJlY3RzID0gW3tcbiAgICAgIGxlZnQ6IHJlbGF0aXZlTGVmdCxcbiAgICAgIHRvcDogcmVsYXRpdmVUb3AsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IHBvc1kgLSAxMFxuICAgIH0sIHtcbiAgICAgIGxlZnQ6IHJlbGF0aXZlTGVmdCxcbiAgICAgIHRvcDogcmVsYXRpdmVUb3AsXG4gICAgICB3aWR0aDogcG9zWCAtIDEwLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9LCB7XG4gICAgICBsZWZ0OiByZWxhdGl2ZUxlZnQsXG4gICAgICB0b3A6IHJlbGF0aXZlVG9wICsgcG9zWSArIDEwLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgLSBwb3NZIC0gMTBcbiAgICB9LCB7XG4gICAgICBsZWZ0OiByZWxhdGl2ZUxlZnQgKyBwb3NYICsgMTAsXG4gICAgICB0b3A6IHJlbGF0aXZlVG9wLFxuICAgICAgd2lkdGg6IHdpZHRoIC0gcG9zWCAtIDEwLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9XTtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKGFyZWFFbGVtZW50Lm5leHRFbGVtZW50U2libGluZy5jaGlsZHJlbik7XG4gICAgcmVjdHMuZm9yRWFjaChmdW5jdGlvbiAocmVjdCwgaSkge1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUuY3NzVGV4dCA9IFwibGVmdDogXCIuY29uY2F0KHJlY3QubGVmdCwgXCJweDt0b3A6IFwiKS5jb25jYXQocmVjdC50b3AsIFwicHg7IHdpZHRoOiBcIikuY29uY2F0KHJlY3Qud2lkdGgsIFwicHg7IGhlaWdodDogXCIpLmNvbmNhdChyZWN0LmhlaWdodCwgXCJweDtcIik7XG4gICAgfSk7XG4gICAgYWRkQ2xhc3MoYXJlYUVsZW1lbnQsIEFWT0lEKTtcbiAgICBzdGF0ZS5kaXNhYmxlTmF0aXZlRXZlbnQgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfSxcbiAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBfYSkge1xuICAgIHZhciBkYXRhcyA9IF9hLmRhdGFzLFxuICAgICAgICBpbnB1dEV2ZW50ID0gX2EuaW5wdXRFdmVudDtcbiAgICB0aGlzLmVuYWJsZU5hdGl2ZUV2ZW50KG1vdmVhYmxlKTtcblxuICAgIGlmICghaW5wdXRFdmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghZGF0YXMuaXNEcmFnQXJlYSkge1xuICAgICAgZGF0YXMuaXNEcmFnQXJlYSA9IHRydWU7XG4gICAgICByZXN0b3JlU3R5bGUobW92ZWFibGUpO1xuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5lbmFibGVOYXRpdmVFdmVudChtb3ZlYWJsZSk7XG4gICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsXG4gICAgICAgIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghaW5wdXRFdmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghZGF0YXMuaXNEcmFnQXJlYSkge1xuICAgICAgcmVzdG9yZVN0eWxlKG1vdmVhYmxlKTtcbiAgICB9XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xuICB9LFxuICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgcmVzdG9yZVN0eWxlKG1vdmVhYmxlKTtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5kaXNhYmxlTmF0aXZlRXZlbnQgPSBmYWxzZTtcbiAgfSxcbiAgZW5hYmxlTmF0aXZlRXZlbnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuXG4gICAgaWYgKHN0YXRlLmRpc2FibGVOYXRpdmVFdmVudCkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhdGUuZGlzYWJsZU5hdGl2ZUV2ZW50ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEFkZCBhbiBldmVudCB0byB0aGUgbW92ZWFibGUgYXJlYSBpbnN0ZWFkIG9mIHRoZSB0YXJnZXQgZm9yIHN0b3BQcm9wYWdhdGlvbi4gKGRlZmF1bHQ6IGZhbHNlLCB0cnVlIGluIGdyb3VwKVxuICogQG5hbWUgTW92ZWFibGUjZHJhZ0FyZWFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogIGRyYWdBcmVhOiBmYWxzZSxcbiAqIH0pO1xuICovXG5cbi8qKlxuICogU2V0IGBwb2ludGVyRXZlbnRzOiBub25lO2AgY3NzIHRvIHBhc3MgZXZlbnRzIGluIGRyYWdBcmVhLiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZSNwYXNzRHJhZ0FyZWFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogIGRyYWdBcmVhOiBmYWxzZSxcbiAqIH0pO1xuICovXG5cbnZhciBPcmlnaW4gPSBtYWtlQWJsZShcIm9yaWdpblwiLCB7XG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciB6b29tID0gbW92ZWFibGUucHJvcHMuem9vbTtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgYmVmb3JlT3JpZ2luID0gX2EuYmVmb3JlT3JpZ2luLFxuICAgICAgICByb3RhdGlvbiA9IF9hLnJvdGF0aW9uO1xuICAgIHJldHVybiBbUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2xcIiwgXCJvcmlnaW5cIiksXG4gICAgICBzdHlsZTogZ2V0Q29udHJvbFRyYW5zZm9ybShyb3RhdGlvbiwgem9vbSwgYmVmb3JlT3JpZ2luKSxcbiAgICAgIGtleTogXCJiZWZvcmVPcmlnaW5cIlxuICAgIH0pXTtcbiAgfVxufSk7XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBvcmlnaW4gY29udHJvbGJveCB3aWxsIGJlIHZpc2libGUgb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogQG5hbWUgTW92ZWFibGUjb3JpZ2luXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLm9yaWdpbiA9IHRydWU7XG4gKi9cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjcm9sbFBvc2l0aW9uKGUpIHtcbiAgdmFyIHNjcm9sbENvbnRhaW5lciA9IGUuc2Nyb2xsQ29udGFpbmVyO1xuICByZXR1cm4gW3Njcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0LCBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wXTtcbn1cbi8qKlxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5TY3JvbGxhYmxlXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBzY3JvbGxlZCB0byB0aGUgc2Nyb2xsIGNvbnRhaW5lciAoZGVmYXVsdDogZmFsc2UpXG4gKi9cblxuXG52YXIgU2Nyb2xsYWJsZSA9IHtcbiAgbmFtZTogXCJzY3JvbGxhYmxlXCIsXG4gIGNhblBpbmNoOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHNjcm9sbGFibGU6IEJvb2xlYW4sXG4gICAgc2Nyb2xsQ29udGFpbmVyOiBPYmplY3QsXG4gICAgc2Nyb2xsVGhyZXNob2xkOiBOdW1iZXIsXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb246IEZ1bmN0aW9uXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uU2Nyb2xsOiBcInNjcm9sbFwiLFxuICAgIG9uU2Nyb2xsR3JvdXA6IFwic2Nyb2xsR3JvdXBcIlxuICB9LFxuICBkcmFnUmVsYXRpb246IFwic3Ryb25nXCIsXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XG4gICAgdmFyIF9hID0gcHJvcHMuc2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICBzY3JvbGxDb250YWluZXIgPSBfYSA9PT0gdm9pZCAwID8gbW92ZWFibGUuZ2V0Q29udGFpbmVyKCkgOiBfYTtcbiAgICB2YXIgZHJhZ1Njcm9sbCA9IG5ldyBEcmFnU2Nyb2xsKCk7XG4gICAgdmFyIHNjcm9sbENvbnRhaW5lckVsZW1lbnQgPSBnZXRSZWZUYXJnZXQoc2Nyb2xsQ29udGFpbmVyLCB0cnVlKTtcbiAgICBlLmRhdGFzLmRyYWdTY3JvbGwgPSBkcmFnU2Nyb2xsO1xuICAgIHZhciBnZXN0b05hbWUgPSBlLmlzQ29udHJvbCA/IFwiY29udHJvbEdlc3RvXCIgOiBcInRhcmdldEdlc3RvXCI7XG4gICAgdmFyIHRhcmdldHMgPSBlLnRhcmdldHM7XG4gICAgZHJhZ1Njcm9sbC5vbihcInNjcm9sbFwiLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBfYS5jb250YWluZXIsXG4gICAgICAgICAgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uO1xuICAgICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIHZhciBldmVudE5hbWUgPSB0YXJnZXRzID8gXCJvblNjcm9sbEdyb3VwXCIgOiBcIm9uU2Nyb2xsXCI7XG5cbiAgICAgIGlmICh0YXJnZXRzKSB7XG4gICAgICAgIHBhcmFtcy50YXJnZXRzID0gdGFyZ2V0cztcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBldmVudE5hbWUsIHBhcmFtcyk7XG4gICAgfSkub24oXCJtb3ZlXCIsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIG9mZnNldFggPSBfYS5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFkgPSBfYS5vZmZzZXRZO1xuICAgICAgbW92ZWFibGVbZ2VzdG9OYW1lXS5zY3JvbGxCeShvZmZzZXRYLCBvZmZzZXRZLCBlLmlucHV0RXZlbnQsIGZhbHNlKTtcbiAgICB9KTtcbiAgICBkcmFnU2Nyb2xsLmRyYWdTdGFydChlLCB7XG4gICAgICBjb250YWluZXI6IHNjcm9sbENvbnRhaW5lckVsZW1lbnRcbiAgICB9KTtcbiAgfSxcbiAgY2hlY2tTY3JvbGw6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkcmFnU2Nyb2xsID0gZS5kYXRhcy5kcmFnU2Nyb2xsO1xuXG4gICAgaWYgKCFkcmFnU2Nyb2xsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICAgIF9iID0gX2Euc2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICBzY3JvbGxDb250YWluZXIgPSBfYiA9PT0gdm9pZCAwID8gbW92ZWFibGUuZ2V0Q29udGFpbmVyKCkgOiBfYixcbiAgICAgICAgX2MgPSBfYS5zY3JvbGxUaHJlc2hvbGQsXG4gICAgICAgIHNjcm9sbFRocmVzaG9sZCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsXG4gICAgICAgIF9kID0gX2EuZ2V0U2Nyb2xsUG9zaXRpb24sXG4gICAgICAgIGdldFNjcm9sbFBvc2l0aW9uID0gX2QgPT09IHZvaWQgMCA/IGdldERlZmF1bHRTY3JvbGxQb3NpdGlvbiA6IF9kO1xuICAgIGRyYWdTY3JvbGwuZHJhZyhlLCB7XG4gICAgICBjb250YWluZXI6IHNjcm9sbENvbnRhaW5lcixcbiAgICAgIHRocmVzaG9sZDogc2Nyb2xsVGhyZXNob2xkLFxuICAgICAgZ2V0U2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uIChldikge1xuICAgICAgICByZXR1cm4gZ2V0U2Nyb2xsUG9zaXRpb24oe1xuICAgICAgICAgIHNjcm9sbENvbnRhaW5lcjogZXYuY29udGFpbmVyLFxuICAgICAgICAgIGRpcmVjdGlvbjogZXYuZGlyZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja1Njcm9sbChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIGUuZGF0YXMuZHJhZ1Njcm9sbC5kcmFnRW5kKCk7XG4gICAgZS5kYXRhcy5kcmFnU2Nyb2xsID0gbnVsbDtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIGlzQ29udHJvbDogdHJ1ZVxuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0c1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHNcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgaXNDb250cm9sOiB0cnVlXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm86IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0c1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHNcbiAgICB9KSk7XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgc2Nyb2xsZWQgdG8gdGhlIHNjcm9sbCBjb250YWluZXIgKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuU2Nyb2xsYWJsZSNzY3JvbGxhYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgc2Nyb2xsYWJsZTogdHJ1ZSxcbiAqICAgc2Nyb2xsQ29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICogICBzY3JvbGxUaHJlc2hvbGQ6IDAsXG4gKiAgIGdldFNjcm9sbFBvc2l0aW9uOiAoeyBzY3JvbGxDb250YWluZXIgfSkgPT4gKFtzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCwgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcF0pLFxuICogfSk7XG4gKlxuICogbW92ZWFibGUuc2Nyb2xsYWJsZSA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBUaGUgY29udGFpbmVyIHRvIHdoaWNoIHNjcm9sbCBpcyBhcHBsaWVkIChkZWZhdWx0OiBjb250YWluZXIpXG4gKiBAbmFtZSBNb3ZlYWJsZS5TY3JvbGxhYmxlI3Njcm9sbENvbnRhaW5lclxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHNjcm9sbGFibGU6IHRydWUsXG4gKiAgIHNjcm9sbENvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAqICAgc2Nyb2xsVGhyZXNob2xkOiAwLFxuICogICBnZXRTY3JvbGxQb3NpdGlvbjogKHsgc2Nyb2xsQ29udGFpbmVyIH0pID0+IChbc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQsIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3BdKSxcbiAqIH0pO1xuICovXG5cbi8qKlxuICogRXhwYW5kIHRoZSByYW5nZSBvZiB0aGUgc2Nyb2xsIGNoZWNrIGFyZWEuIChkZWZhdWx0OiAwKVxuICogQG5hbWUgTW92ZWFibGUuU2Nyb2xsYWJsZSNzY3JvbGxUaHJlc2hvbGRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICBzY3JvbGxhYmxlOiB0cnVlLFxuICogICBzY3JvbGxDb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gKiAgIHNjcm9sbFRocmVzaG9sZDogMCxcbiAqICAgZ2V0U2Nyb2xsUG9zaXRpb246ICh7IHNjcm9sbENvbnRhaW5lciB9KSA9PiAoW3Njcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0LCBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wXSksXG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFNldHMgYSBmdW5jdGlvbiB0byBnZXQgdGhlIHNjcm9sbCBwb3NpdGlvbi4gKGRlZmF1bHQ6IEZ1bmN0aW9uKVxuICogQG5hbWUgTW92ZWFibGUuU2Nyb2xsYWJsZSNnZXRTY3JvbGxQb3NpdGlvblxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHNjcm9sbGFibGU6IHRydWUsXG4gKiAgIHNjcm9sbENvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAqICAgc2Nyb2xsVGhyZXNob2xkOiAwLFxuICogICBnZXRTY3JvbGxQb3NpdGlvbjogKHsgc2Nyb2xsQ29udGFpbmVyIH0pID0+IChbc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQsIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3BdKSxcbiAqIH0pO1xuICpcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIGRyYWcgY3Vyc29yIGxlYXZlcyB0aGUgc2Nyb2xsQ29udGFpbmVyLCB0aGUgYHNjcm9sbGAgZXZlbnQgb2NjdXIgdG8gc2Nyb2xsLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjcm9sbGFibGVcbiAqIEBldmVudCBzY3JvbGxcbiAqIEBwYXJhbSB7TW92ZWFibGUuU2Nyb2xsYWJsZS5PblNjcm9sbH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjcm9sbGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2Nyb2xsXCIsICh7IHNjcm9sbENvbnRhaW5lciwgZGlyZWN0aW9uIH0pID0+IHtcbiAqICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgKz0gZGlyZWN0aW9uWzBdICogMTA7XG4gKiAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgKz0gZGlyZWN0aW9uWzFdICogMTA7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIGRyYWcgY3Vyc29yIGxlYXZlcyB0aGUgc2Nyb2xsQ29udGFpbmVyLCB0aGUgYHNjcm9sbEdyb3VwYCBldmVudCBvY2N1ciB0byBzY3JvbGwgaW4gZ3JvdXAuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU2Nyb2xsYWJsZVxuICogQGV2ZW50IHNjcm9sbEdyb3VwXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjcm9sbGFibGUuT25TY3JvbGxHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjcm9sbEdyb3VwYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJzY3JvbGxcIiwgKHsgc2Nyb2xsQ29udGFpbmVyLCBkaXJlY3Rpb24gfSkgPT4ge1xuICogICBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCArPSBkaXJlY3Rpb25bMF0gKiAxMDtcbiAqICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCArPSBkaXJlY3Rpb25bMV0gKiAxMDtcbiAqIH0pO1xuICovXG5cbnZhciBEZWZhdWx0ID0ge1xuICBuYW1lOiBcIlwiLFxuICBwcm9wczoge1xuICAgIHRhcmdldDogT2JqZWN0LFxuICAgIGRyYWdUYXJnZXQ6IE9iamVjdCxcbiAgICBjb250YWluZXI6IE9iamVjdCxcbiAgICBwb3J0YWxDb250YWluZXI6IE9iamVjdCxcbiAgICByb290Q29udGFpbmVyOiBPYmplY3QsXG4gICAgdXNlUmVzaXplT2JzZXJ2ZXI6IEJvb2xlYW4sXG4gICAgem9vbTogTnVtYmVyLFxuICAgIHRyYW5zZm9ybU9yaWdpbjogQXJyYXksXG4gICAgZWRnZTogQm9vbGVhbixcbiAgICBhYmxlczogQXJyYXksXG4gICAgY2xhc3NOYW1lOiBTdHJpbmcsXG4gICAgcGluY2hUaHJlc2hvbGQ6IE51bWJlcixcbiAgICBwaW5jaE91dHNpZGU6IEJvb2xlYW4sXG4gICAgdHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHk6IEJvb2xlYW4sXG4gICAgY2hlY2tJbnB1dDogQm9vbGVhbixcbiAgICBjc3BOb25jZTogU3RyaW5nLFxuICAgIHRyYW5zbGF0ZVo6IE51bWJlcixcbiAgICBoaWRlRGVmYXVsdExpbmVzOiBCb29sZWFuLFxuICAgIHByb3BzOiBPYmplY3QsXG4gICAgZmx1c2hTeW5jOiBGdW5jdGlvblxuICB9LFxuICBldmVudHM6IHt9XG59O1xudmFyIFBhZGRpbmcgPSBtYWtlQWJsZShcInBhZGRpbmdcIiwge1xuICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcblxuICAgIGlmIChwcm9wcy5kcmFnQXJlYSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBwYWRkaW5nID0gcHJvcHMucGFkZGluZyB8fCB7fTtcbiAgICB2YXIgX2EgPSBwYWRkaW5nLmxlZnQsXG4gICAgICAgIGxlZnQgPSBfYSA9PT0gdm9pZCAwID8gMCA6IF9hLFxuICAgICAgICBfYiA9IHBhZGRpbmcudG9wLFxuICAgICAgICB0b3AgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLFxuICAgICAgICBfYyA9IHBhZGRpbmcucmlnaHQsXG4gICAgICAgIHJpZ2h0ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYyxcbiAgICAgICAgX2QgPSBwYWRkaW5nLmJvdHRvbSxcbiAgICAgICAgYm90dG9tID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZDtcbiAgICB2YXIgX2UgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgcmVuZGVyUG9zZXMgPSBfZS5yZW5kZXJQb3NlcyxcbiAgICAgICAgcG9zMSA9IF9lLnBvczEsXG4gICAgICAgIHBvczIgPSBfZS5wb3MyLFxuICAgICAgICBwb3MzID0gX2UucG9zMyxcbiAgICAgICAgcG9zNCA9IF9lLnBvczQ7XG4gICAgdmFyIHBvc2VzID0gW3BvczEsIHBvczIsIHBvczMsIHBvczRdO1xuICAgIHZhciBwYWRkaW5nRGlyZWN0aW9ucyA9IFtdO1xuXG4gICAgaWYgKGxlZnQgPiAwKSB7XG4gICAgICBwYWRkaW5nRGlyZWN0aW9ucy5wdXNoKFswLCAyXSk7XG4gICAgfVxuXG4gICAgaWYgKHRvcCA+IDApIHtcbiAgICAgIHBhZGRpbmdEaXJlY3Rpb25zLnB1c2goWzAsIDFdKTtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPiAwKSB7XG4gICAgICBwYWRkaW5nRGlyZWN0aW9ucy5wdXNoKFsxLCAzXSk7XG4gICAgfVxuXG4gICAgaWYgKGJvdHRvbSA+IDApIHtcbiAgICAgIHBhZGRpbmdEaXJlY3Rpb25zLnB1c2goWzIsIDNdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFkZGluZ0RpcmVjdGlvbnMubWFwKGZ1bmN0aW9uIChfYSwgaSkge1xuICAgICAgdmFyIGRpcjEgPSBfYVswXSxcbiAgICAgICAgICBkaXIyID0gX2FbMV07XG4gICAgICB2YXIgcGFkZGluZ1BvczEgPSBwb3Nlc1tkaXIxXTtcbiAgICAgIHZhciBwYWRkaW5nUG9zMiA9IHBvc2VzW2RpcjJdO1xuICAgICAgdmFyIHBhZGRpbmdQb3MzID0gcmVuZGVyUG9zZXNbZGlyMV07XG4gICAgICB2YXIgcGFkZGluZ1BvczQgPSByZW5kZXJQb3Nlc1tkaXIyXTtcbiAgICAgIHZhciBoID0gY3JlYXRlV2FycE1hdHJpeChbMCwgMF0sIFsxMDAsIDBdLCBbMCwgMTAwXSwgWzEwMCwgMTAwXSwgcGFkZGluZ1BvczEsIHBhZGRpbmdQb3MyLCBwYWRkaW5nUG9zMywgcGFkZGluZ1BvczQpO1xuXG4gICAgICBpZiAoIWgubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAga2V5OiBcInBhZGRpbmdcIi5jb25jYXQoaSksXG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwicGFkZGluZ1wiKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06IG1ha2VNYXRyaXhDU1MoaCwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBBZGQgcGFkZGluZyBhcm91bmQgdGhlIHRhcmdldCB0byBpbmNyZWFzZSB0aGUgZHJhZyBhcmVhLlxuICogQG5hbWUgTW92ZWFibGUjcGFkZGluZ1xuICogQGRlZmF1bHQgbnVsbFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgdGFyZ2V0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKSxcbiAqICBwYWRkaW5nOiB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9LFxuICogfSk7XG4gKiBtb3ZlYWJsZS5wYWRkaW5nID0geyBsZWZ0OiAxMCwgdG9wOiAxMCwgcmlnaHQ6IDEwLCBib3R0b206IDEwIH0sXG4gKiBtb3ZlYWJsZS51cGRhdGVSZWN0KCk7XG4gKi9cblxudmFyIFJBRElVU19ESVJFQ1RJT05TID0gW1wibndcIiwgXCJuZVwiLCBcInNlXCIsIFwic3dcIl07XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJhdGlvKHZhbHVlcywgc2l6ZSkge1xuICB2YXIgc3VtU2l6ZSA9IHZhbHVlc1swXSArIHZhbHVlc1sxXTtcbiAgdmFyIHN1bVJhdGlvID0gc3VtU2l6ZSA+IHNpemUgPyBzaXplIC8gc3VtU2l6ZSA6IDE7XG4gIHZhbHVlc1swXSAqPSBzdW1SYXRpbztcbiAgdmFsdWVzWzFdID0gc2l6ZSAtIHZhbHVlc1sxXSAqIHN1bVJhdGlvO1xuICByZXR1cm4gdmFsdWVzO1xufVxuXG52YXIgSE9SSVpPTlRBTF9SQURJVVNfT1JERVIgPSBbMSwgMiwgNSwgNl07XG52YXIgVkVSVElDQUxfUkFESVVTX09SREVSID0gWzAsIDMsIDQsIDddO1xudmFyIEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlMgPSBbMSwgLTEsIC0xLCAxXTtcbnZhciBWRVJUSUNBTF9SQURJVVNfRElSRUNUSU9OUyA9IFsxLCAxLCAtMSwgLTFdO1xuXG5mdW5jdGlvbiBnZXRSYWRpdXNTdHlsZXMocG9zZXMsIGNvbnRyb2xQb3NlcywgaXNSZWxhdGl2ZSwgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XG4gIGlmIChsZWZ0ID09PSB2b2lkIDApIHtcbiAgICBsZWZ0ID0gMDtcbiAgfVxuXG4gIGlmICh0b3AgPT09IHZvaWQgMCkge1xuICAgIHRvcCA9IDA7XG4gIH1cblxuICBpZiAocmlnaHQgPT09IHZvaWQgMCkge1xuICAgIHJpZ2h0ID0gd2lkdGg7XG4gIH1cblxuICBpZiAoYm90dG9tID09PSB2b2lkIDApIHtcbiAgICBib3R0b20gPSBoZWlnaHQ7XG4gIH1cblxuICB2YXIgY2xpcFN0eWxlcyA9IFtdO1xuICB2YXIgaXNWZXJ0aWNhbCA9IGZhbHNlO1xuICB2YXIgcmF3cyA9IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgdmFyIF9hID0gY29udHJvbFBvc2VzW2ldLFxuICAgICAgICBob3Jpem9udGFsID0gX2EuaG9yaXpvbnRhbCxcbiAgICAgICAgdmVydGljYWwgPSBfYS52ZXJ0aWNhbDtcblxuICAgIGlmICh2ZXJ0aWNhbCAmJiAhaXNWZXJ0aWNhbCkge1xuICAgICAgaXNWZXJ0aWNhbCA9IHRydWU7XG4gICAgICBjbGlwU3R5bGVzLnB1c2goXCIvXCIpO1xuICAgIH1cblxuICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICB2YXIgcmF3UG9zID0gTWF0aC5tYXgoMCwgdmVydGljYWwgPT09IDEgPyBwb3NbMV0gLSB0b3AgOiBib3R0b20gLSBwb3NbMV0pO1xuICAgICAgY2xpcFN0eWxlcy5wdXNoKGNvbnZlcnRDU1NTaXplKHJhd1BvcywgaGVpZ2h0LCBpc1JlbGF0aXZlKSk7XG4gICAgICByZXR1cm4gcmF3UG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmF3UG9zID0gTWF0aC5tYXgoMCwgaG9yaXpvbnRhbCA9PT0gMSA/IHBvc1swXSAtIGxlZnQgOiByaWdodCAtIHBvc1swXSk7XG4gICAgICBjbGlwU3R5bGVzLnB1c2goY29udmVydENTU1NpemUocmF3UG9zLCB3aWR0aCwgaXNSZWxhdGl2ZSkpO1xuICAgICAgcmV0dXJuIHJhd1BvcztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHN0eWxlczogY2xpcFN0eWxlcyxcbiAgICByYXdzOiByYXdzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJhZGl1c1JhbmdlKGNvbnRyb2xQb3Nlcykge1xuICAvLyBbc3RhcnQsIGxlbmd0aF1cbiAgdmFyIGhvcml6b250YWxSYW5nZSA9IFswLCAwXTtcbiAgdmFyIHZlcnRpY2FsUmFuZ2UgPSBbMCwgMF07XG4gIHZhciBsZW5ndGggPSBjb250cm9sUG9zZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2xpcFBvc2UgPSBjb250cm9sUG9zZXNbaV07XG5cbiAgICBpZiAoIWNsaXBQb3NlLnN1Yikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNsaXBQb3NlLmhvcml6b250YWwpIHtcbiAgICAgIGlmIChob3Jpem9udGFsUmFuZ2VbMV0gPT09IDApIHtcbiAgICAgICAgaG9yaXpvbnRhbFJhbmdlWzBdID0gaTtcbiAgICAgIH1cblxuICAgICAgaG9yaXpvbnRhbFJhbmdlWzFdID0gaSAtIGhvcml6b250YWxSYW5nZVswXSArIDE7XG4gICAgICB2ZXJ0aWNhbFJhbmdlWzBdID0gaSArIDE7XG4gICAgfVxuXG4gICAgaWYgKGNsaXBQb3NlLnZlcnRpY2FsKSB7XG4gICAgICBpZiAodmVydGljYWxSYW5nZVsxXSA9PT0gMCkge1xuICAgICAgICB2ZXJ0aWNhbFJhbmdlWzBdID0gaTtcbiAgICAgIH1cblxuICAgICAgdmVydGljYWxSYW5nZVsxXSA9IGkgLSB2ZXJ0aWNhbFJhbmdlWzBdICsgMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhvcml6b250YWxSYW5nZTogaG9yaXpvbnRhbFJhbmdlLFxuICAgIHZlcnRpY2FsUmFuZ2U6IHZlcnRpY2FsUmFuZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFkaXVzVmFsdWVzKHZhbHVlcywgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCBtaW5Db3VudHMpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuXG4gIGlmIChtaW5Db3VudHMgPT09IHZvaWQgMCkge1xuICAgIG1pbkNvdW50cyA9IFswLCAwXTtcbiAgfVxuXG4gIHZhciBzcGxpdEluZGV4ID0gdmFsdWVzLmluZGV4T2YoXCIvXCIpO1xuICB2YXIgc3BsaXRMZW5ndGggPSAoc3BsaXRJbmRleCA+IC0xID8gdmFsdWVzLnNsaWNlKDAsIHNwbGl0SW5kZXgpIDogdmFsdWVzKS5sZW5ndGg7XG4gIHZhciBob3Jpem9udGFsVmFsdWVzID0gdmFsdWVzLnNsaWNlKDAsIHNwbGl0TGVuZ3RoKTtcbiAgdmFyIHZlcnRpY2FsVmFsdWVzID0gdmFsdWVzLnNsaWNlKHNwbGl0TGVuZ3RoICsgMSk7XG4gIHZhciBfZSA9IGhvcml6b250YWxWYWx1ZXNbMF0sXG4gICAgICBud1ZhbHVlID0gX2UgPT09IHZvaWQgMCA/IFwiMHB4XCIgOiBfZSxcbiAgICAgIF9mID0gaG9yaXpvbnRhbFZhbHVlc1sxXSxcbiAgICAgIG5lVmFsdWUgPSBfZiA9PT0gdm9pZCAwID8gbndWYWx1ZSA6IF9mLFxuICAgICAgX2cgPSBob3Jpem9udGFsVmFsdWVzWzJdLFxuICAgICAgc2VWYWx1ZSA9IF9nID09PSB2b2lkIDAgPyBud1ZhbHVlIDogX2csXG4gICAgICBfaCA9IGhvcml6b250YWxWYWx1ZXNbM10sXG4gICAgICBzd1ZhbHVlID0gX2ggPT09IHZvaWQgMCA/IG5lVmFsdWUgOiBfaDtcbiAgdmFyIF9qID0gdmVydGljYWxWYWx1ZXNbMF0sXG4gICAgICB3blZhbHVlID0gX2ogPT09IHZvaWQgMCA/IG53VmFsdWUgOiBfaixcbiAgICAgIF9rID0gdmVydGljYWxWYWx1ZXNbMV0sXG4gICAgICBlblZhbHVlID0gX2sgPT09IHZvaWQgMCA/IHduVmFsdWUgOiBfayxcbiAgICAgIF9sID0gdmVydGljYWxWYWx1ZXNbMl0sXG4gICAgICBlc1ZhbHVlID0gX2wgPT09IHZvaWQgMCA/IHduVmFsdWUgOiBfbCxcbiAgICAgIF9tID0gdmVydGljYWxWYWx1ZXNbM10sXG4gICAgICB3c1ZhbHVlID0gX20gPT09IHZvaWQgMCA/IGVuVmFsdWUgOiBfbTtcbiAgdmFyIGhvcml6b250YWxSYXdQb3NlcyA9IFtud1ZhbHVlLCBuZVZhbHVlLCBzZVZhbHVlLCBzd1ZhbHVlXS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBjb252ZXJ0VW5pdFNpemUocG9zLCB3aWR0aCk7XG4gIH0pO1xuICB2YXIgdmVydGljYWxSYXdQb3NlcyA9IFt3blZhbHVlLCBlblZhbHVlLCBlc1ZhbHVlLCB3c1ZhbHVlXS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBjb252ZXJ0VW5pdFNpemUocG9zLCBoZWlnaHQpO1xuICB9KTtcbiAgdmFyIGhvcml6b250YWxQb3NlcyA9IGhvcml6b250YWxSYXdQb3Nlcy5zbGljZSgpO1xuICB2YXIgdmVydGljYWxQb3NlcyA9IHZlcnRpY2FsUmF3UG9zZXMuc2xpY2UoKTtcbiAgX2EgPSBjYWxjdWxhdGVSYXRpbyhbaG9yaXpvbnRhbFBvc2VzWzBdLCBob3Jpem9udGFsUG9zZXNbMV1dLCB3aWR0aCksIGhvcml6b250YWxQb3Nlc1swXSA9IF9hWzBdLCBob3Jpem9udGFsUG9zZXNbMV0gPSBfYVsxXTtcbiAgX2IgPSBjYWxjdWxhdGVSYXRpbyhbaG9yaXpvbnRhbFBvc2VzWzNdLCBob3Jpem9udGFsUG9zZXNbMl1dLCB3aWR0aCksIGhvcml6b250YWxQb3Nlc1szXSA9IF9iWzBdLCBob3Jpem9udGFsUG9zZXNbMl0gPSBfYlsxXTtcbiAgX2MgPSBjYWxjdWxhdGVSYXRpbyhbdmVydGljYWxQb3Nlc1swXSwgdmVydGljYWxQb3Nlc1szXV0sIGhlaWdodCksIHZlcnRpY2FsUG9zZXNbMF0gPSBfY1swXSwgdmVydGljYWxQb3Nlc1szXSA9IF9jWzFdO1xuICBfZCA9IGNhbGN1bGF0ZVJhdGlvKFt2ZXJ0aWNhbFBvc2VzWzFdLCB2ZXJ0aWNhbFBvc2VzWzJdXSwgaGVpZ2h0KSwgdmVydGljYWxQb3Nlc1sxXSA9IF9kWzBdLCB2ZXJ0aWNhbFBvc2VzWzJdID0gX2RbMV07XG4gIHZhciBuZXh0SG9yaXpvbnRhbFBvc2VzID0gaG9yaXpvbnRhbFBvc2VzLnNsaWNlKDAsIE1hdGgubWF4KG1pbkNvdW50c1swXSwgaG9yaXpvbnRhbFZhbHVlcy5sZW5ndGgpKTtcbiAgdmFyIG5leHRWZXJ0aWNhbFBvc2VzID0gdmVydGljYWxQb3Nlcy5zbGljZSgwLCBNYXRoLm1heChtaW5Db3VudHNbMV0sIHZlcnRpY2FsVmFsdWVzLmxlbmd0aCkpO1xuICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBuZXh0SG9yaXpvbnRhbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJBRElVU19ESVJFQ1RJT05TW2ldO1xuICAgIHJldHVybiB7XG4gICAgICBob3Jpem9udGFsOiBIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TW2ldLFxuICAgICAgdmVydGljYWw6IDAsXG4gICAgICBwb3M6IFtsZWZ0ICsgcG9zLCB0b3AgKyAoVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IC0xID8gaGVpZ2h0IDogMCldLFxuICAgICAgc3ViOiB0cnVlLFxuICAgICAgcmF3OiBob3Jpem9udGFsUmF3UG9zZXNbaV0sXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgIH07XG4gIH0pLCB0cnVlKSwgbmV4dFZlcnRpY2FsUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gUkFESVVTX0RJUkVDVElPTlNbaV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICB2ZXJ0aWNhbDogVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbaV0sXG4gICAgICBwb3M6IFtsZWZ0ICsgKEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IC0xID8gd2lkdGggOiAwKSwgdG9wICsgcG9zXSxcbiAgICAgIHN1YjogdHJ1ZSxcbiAgICAgIHJhdzogdmVydGljYWxSYXdQb3Nlc1tpXSxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfTtcbiAgfSksIHRydWUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVSYWRpdXNQb3MoY29udHJvbFBvc2VzLCBwb3NlcywgaW5kZXgsIHN0YXJ0SW5kZXgsIGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICBsZW5ndGggPSBwb3Nlcy5sZW5ndGg7XG4gIH1cblxuICB2YXIgX2EgPSBnZXRSYWRpdXNSYW5nZShjb250cm9sUG9zZXMuc2xpY2Uoc3RhcnRJbmRleCkpLFxuICAgICAgaG9yaXpvbnRhbFJhbmdlID0gX2EuaG9yaXpvbnRhbFJhbmdlLFxuICAgICAgdmVydGljYWxSYW5nZSA9IF9hLnZlcnRpY2FsUmFuZ2U7XG5cbiAgdmFyIHJhZGl1c2xJbmRleCA9IGluZGV4IC0gc3RhcnRJbmRleDtcbiAgdmFyIGRlbGV0ZUNvdW50ID0gMDtcblxuICBpZiAocmFkaXVzbEluZGV4ID09PSAwKSB7XG4gICAgZGVsZXRlQ291bnQgPSBsZW5ndGg7XG4gIH0gZWxzZSBpZiAocmFkaXVzbEluZGV4ID4gMCAmJiByYWRpdXNsSW5kZXggPCBob3Jpem9udGFsUmFuZ2VbMV0pIHtcbiAgICBkZWxldGVDb3VudCA9IGhvcml6b250YWxSYW5nZVsxXSAtIHJhZGl1c2xJbmRleDtcbiAgfSBlbHNlIGlmIChyYWRpdXNsSW5kZXggPj0gdmVydGljYWxSYW5nZVswXSkge1xuICAgIGRlbGV0ZUNvdW50ID0gdmVydGljYWxSYW5nZVswXSArIHZlcnRpY2FsUmFuZ2VbMV0gLSByYWRpdXNsSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29udHJvbFBvc2VzLnNwbGljZShpbmRleCwgZGVsZXRlQ291bnQpO1xuICBwb3Nlcy5zcGxpY2UoaW5kZXgsIGRlbGV0ZUNvdW50KTtcbn1cblxuZnVuY3Rpb24gYWRkUmFkaXVzUG9zKGNvbnRyb2xQb3NlcywgcG9zZXMsIHN0YXJ0SW5kZXgsIGhvcml6b250YWxJbmRleCwgdmVydGljYWxJbmRleCwgZGlzdFgsIGRpc3RZLCByaWdodCwgYm90dG9tLCBsZWZ0LCB0b3ApIHtcbiAgaWYgKGxlZnQgPT09IHZvaWQgMCkge1xuICAgIGxlZnQgPSAwO1xuICB9XG5cbiAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7XG4gICAgdG9wID0gMDtcbiAgfVxuXG4gIHZhciBfYSA9IGdldFJhZGl1c1JhbmdlKGNvbnRyb2xQb3Nlcy5zbGljZShzdGFydEluZGV4KSksXG4gICAgICBob3Jpem9udGFsUmFuZ2UgPSBfYS5ob3Jpem9udGFsUmFuZ2UsXG4gICAgICB2ZXJ0aWNhbFJhbmdlID0gX2EudmVydGljYWxSYW5nZTtcblxuICBpZiAoaG9yaXpvbnRhbEluZGV4ID4gLTEpIHtcbiAgICB2YXIgcmFkaXVzWCA9IEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaG9yaXpvbnRhbEluZGV4XSA9PT0gMSA/IGRpc3RYIC0gbGVmdCA6IHJpZ2h0IC0gZGlzdFg7XG5cbiAgICBmb3IgKHZhciBpID0gaG9yaXpvbnRhbFJhbmdlWzFdOyBpIDw9IGhvcml6b250YWxJbmRleDsgKytpKSB7XG4gICAgICB2YXIgeSA9IFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAxID8gdG9wIDogYm90dG9tO1xuICAgICAgdmFyIHggPSAwO1xuXG4gICAgICBpZiAoaG9yaXpvbnRhbEluZGV4ID09PSBpKSB7XG4gICAgICAgIHggPSBkaXN0WDtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICB4ID0gbGVmdCArIHJhZGl1c1g7XG4gICAgICB9IGVsc2UgaWYgKEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IC0xKSB7XG4gICAgICAgIHggPSByaWdodCAtIChwb3Nlc1tzdGFydEluZGV4XVswXSAtIGxlZnQpO1xuICAgICAgfVxuXG4gICAgICBjb250cm9sUG9zZXMuc3BsaWNlKHN0YXJ0SW5kZXggKyBpLCAwLCB7XG4gICAgICAgIGhvcml6b250YWw6IEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaV0sXG4gICAgICAgIHZlcnRpY2FsOiAwLFxuICAgICAgICBwb3M6IFt4LCB5XVxuICAgICAgfSk7XG4gICAgICBwb3Nlcy5zcGxpY2Uoc3RhcnRJbmRleCArIGksIDAsIFt4LCB5XSk7XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh2ZXJ0aWNhbEluZGV4ID4gLTEpIHtcbiAgICB2YXIgcmFkaXVzWSA9IFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW3ZlcnRpY2FsSW5kZXhdID09PSAxID8gZGlzdFkgLSB0b3AgOiBib3R0b20gLSBkaXN0WTtcblxuICAgIGlmIChob3Jpem9udGFsUmFuZ2VbMV0gPT09IDAgJiYgdmVydGljYWxSYW5nZVsxXSA9PT0gMCkge1xuICAgICAgdmFyIHBvcyA9IFtsZWZ0ICsgcmFkaXVzWSwgdG9wXTtcbiAgICAgIGNvbnRyb2xQb3Nlcy5wdXNoKHtcbiAgICAgICAgaG9yaXpvbnRhbDogSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OU1swXSxcbiAgICAgICAgdmVydGljYWw6IDAsXG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHBvc2VzLnB1c2gocG9zKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRWZXJ0aWNhbEluZGV4ID0gdmVydGljYWxSYW5nZVswXTtcblxuICAgIGZvciAodmFyIGkgPSB2ZXJ0aWNhbFJhbmdlWzFdOyBpIDw9IHZlcnRpY2FsSW5kZXg7ICsraSkge1xuICAgICAgdmFyIHggPSBIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAxID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgdmFyIHkgPSAwO1xuXG4gICAgICBpZiAodmVydGljYWxJbmRleCA9PT0gaSkge1xuICAgICAgICB5ID0gZGlzdFk7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgeSA9IHRvcCArIHJhZGl1c1k7XG4gICAgICB9IGVsc2UgaWYgKFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAxKSB7XG4gICAgICAgIHkgPSBwb3Nlc1tzdGFydEluZGV4ICsgc3RhcnRWZXJ0aWNhbEluZGV4XVsxXTtcbiAgICAgIH0gZWxzZSBpZiAoVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IC0xKSB7XG4gICAgICAgIHkgPSBib3R0b20gLSAocG9zZXNbc3RhcnRJbmRleCArIHN0YXJ0VmVydGljYWxJbmRleF1bMV0gLSB0b3ApO1xuICAgICAgfVxuXG4gICAgICBjb250cm9sUG9zZXMucHVzaCh7XG4gICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgIHZlcnRpY2FsOiBWRVJUSUNBTF9SQURJVVNfRElSRUNUSU9OU1tpXSxcbiAgICAgICAgcG9zOiBbeCwgeV1cbiAgICAgIH0pO1xuICAgICAgcG9zZXMucHVzaChbeCwgeV0pO1xuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BsaXRSYWRpdXNQb3Nlcyhjb250cm9sUG9zZXMsIHJhd3MpIHtcbiAgaWYgKHJhd3MgPT09IHZvaWQgMCkge1xuICAgIHJhd3MgPSBjb250cm9sUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwb3MucmF3O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhvcml6b250YWxzID0gY29udHJvbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgcmV0dXJuIHBvcy5ob3Jpem9udGFsID8gcmF3c1tpXSA6IG51bGw7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvcyAhPSBudWxsO1xuICB9KTtcbiAgdmFyIHZlcnRpY2FscyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgIHJldHVybiBwb3MudmVydGljYWwgPyByYXdzW2ldIDogbnVsbDtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zICE9IG51bGw7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGhvcml6b250YWxzOiBob3Jpem9udGFscyxcbiAgICB2ZXJ0aWNhbHM6IHZlcnRpY2Fsc1xuICB9O1xufVxuXG52YXIgQ0xJUF9ESVJFQ1RJT05TID0gW1swLCAtMSwgXCJuXCJdLCBbMSwgMCwgXCJlXCJdXTtcbnZhciBDTElQX1JFQ1RfRElSRUNUSU9OUyA9IFtbLTEsIC0xLCBcIm53XCJdLCBbMCwgLTEsIFwiblwiXSwgWzEsIC0xLCBcIm5lXCJdLCBbMSwgMCwgXCJlXCJdLCBbMSwgMSwgXCJzZVwiXSwgWzAsIDEsIFwic1wiXSwgWy0xLCAxLCBcInN3XCJdLCBbLTEsIDAsIFwid1wiXV07IC8vIDEgMiA1IDYgMCAzIDQgN1xuLy8gMCAxIDIgMyA0IDUgNiA3XG5cbmZ1bmN0aW9uIGdldENsaXBTdHlsZXMobW92ZWFibGUsIGNsaXBQYXRoLCBwb3Nlcykge1xuICB2YXIgY2xpcFJlbGF0aXZlID0gbW92ZWFibGUucHJvcHMuY2xpcFJlbGF0aXZlO1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gIHZhciBfYiA9IGNsaXBQYXRoLFxuICAgICAgY2xpcFR5cGUgPSBfYi50eXBlLFxuICAgICAgY2xpcFBvc2VzID0gX2IucG9zZXM7XG4gIHZhciBpc1JlY3QgPSBjbGlwVHlwZSA9PT0gXCJyZWN0XCI7XG4gIHZhciBpc0NpcmNsZSA9IGNsaXBUeXBlID09PSBcImNpcmNsZVwiO1xuXG4gIGlmIChjbGlwVHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICByZXR1cm4gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChjb252ZXJ0Q1NTU2l6ZShwb3NbMF0sIHdpZHRoLCBjbGlwUmVsYXRpdmUpLCBcIiBcIikuY29uY2F0KGNvbnZlcnRDU1NTaXplKHBvc1sxXSwgaGVpZ2h0LCBjbGlwUmVsYXRpdmUpKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc1JlY3QgfHwgY2xpcFR5cGUgPT09IFwiaW5zZXRcIikge1xuICAgIHZhciB0b3AgPSBwb3Nlc1sxXVsxXTtcbiAgICB2YXIgcmlnaHQgPSBwb3Nlc1szXVswXTtcbiAgICB2YXIgbGVmdCA9IHBvc2VzWzddWzBdO1xuICAgIHZhciBib3R0b20gPSBwb3Nlc1s1XVsxXTtcblxuICAgIGlmIChpc1JlY3QpIHtcbiAgICAgIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocG9zLCBcInB4XCIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNsaXBTdHlsZXMgPSBbdG9wLCB3aWR0aCAtIHJpZ2h0LCBoZWlnaHQgLSBib3R0b20sIGxlZnRdLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgICByZXR1cm4gY29udmVydENTU1NpemUocG9zLCBpICUgMiA/IHdpZHRoIDogaGVpZ2h0LCBjbGlwUmVsYXRpdmUpO1xuICAgIH0pO1xuXG4gICAgaWYgKHBvc2VzLmxlbmd0aCA+IDgpIHtcbiAgICAgIHZhciBfYyA9IG1pbnVzKHBvc2VzWzRdLCBwb3Nlc1swXSksXG4gICAgICAgICAgc3ViV2lkdGggPSBfY1swXSxcbiAgICAgICAgICBzdWJIZWlnaHQgPSBfY1sxXTtcblxuICAgICAgY2xpcFN0eWxlcy5wdXNoLmFwcGx5KGNsaXBTdHlsZXMsIF9fc3ByZWFkQXJyYXkoW1wicm91bmRcIl0sIGdldFJhZGl1c1N0eWxlcyhwb3Nlcy5zbGljZSg4KSwgY2xpcFBvc2VzLnNsaWNlKDgpLCBjbGlwUmVsYXRpdmUsIHN1YldpZHRoLCBzdWJIZWlnaHQsIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkuc3R5bGVzLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwU3R5bGVzO1xuICB9IGVsc2UgaWYgKGlzQ2lyY2xlIHx8IGNsaXBUeXBlID09PSBcImVsbGlwc2VcIikge1xuICAgIHZhciBjZW50ZXIgPSBwb3Nlc1swXTtcbiAgICB2YXIgcnkgPSBjb252ZXJ0Q1NTU2l6ZShNYXRoLmFicyhwb3Nlc1sxXVsxXSAtIGNlbnRlclsxXSksIGlzQ2lyY2xlID8gTWF0aC5zcXJ0KCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSAvIDIpIDogaGVpZ2h0LCBjbGlwUmVsYXRpdmUpO1xuICAgIHZhciBjbGlwU3R5bGVzID0gaXNDaXJjbGUgPyBbcnldIDogW2NvbnZlcnRDU1NTaXplKE1hdGguYWJzKHBvc2VzWzJdWzBdIC0gY2VudGVyWzBdKSwgd2lkdGgsIGNsaXBSZWxhdGl2ZSksIHJ5XTtcbiAgICBjbGlwU3R5bGVzLnB1c2goXCJhdFwiLCBjb252ZXJ0Q1NTU2l6ZShjZW50ZXJbMF0sIHdpZHRoLCBjbGlwUmVsYXRpdmUpLCBjb252ZXJ0Q1NTU2l6ZShjZW50ZXJbMV0sIGhlaWdodCwgY2xpcFJlbGF0aXZlKSk7XG4gICAgcmV0dXJuIGNsaXBTdHlsZXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVjdFBvc2VzKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCkge1xuICB2YXIgeHMgPSBbbGVmdCwgKGxlZnQgKyByaWdodCkgLyAyLCByaWdodF07XG4gIHZhciB5cyA9IFt0b3AsICh0b3AgKyBib3R0b20pIC8gMiwgYm90dG9tXTtcbiAgcmV0dXJuIENMSVBfUkVDVF9ESVJFQ1RJT05TLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZGlyeCA9IF9hWzBdLFxuICAgICAgICBkaXJ5ID0gX2FbMV0sXG4gICAgICAgIGRpciA9IF9hWzJdO1xuICAgIHZhciB4ID0geHNbZGlyeCArIDFdO1xuICAgIHZhciB5ID0geXNbZGlyeSArIDFdO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0aWNhbDogTWF0aC5hYnMoZGlyeSksXG4gICAgICBob3Jpem9udGFsOiBNYXRoLmFicyhkaXJ4KSxcbiAgICAgIGRpcmVjdGlvbjogZGlyLFxuICAgICAgcG9zOiBbeCwgeV1cbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udHJvbFNpemUoY29udHJvbFBvc2VzKSB7XG4gIHZhciB4UmFuZ2UgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIHZhciB5UmFuZ2UgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIGNvbnRyb2xQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwb3MgPSBfYS5wb3M7XG4gICAgeFJhbmdlWzBdID0gTWF0aC5taW4oeFJhbmdlWzBdLCBwb3NbMF0pO1xuICAgIHhSYW5nZVsxXSA9IE1hdGgubWF4KHhSYW5nZVsxXSwgcG9zWzBdKTtcbiAgICB5UmFuZ2VbMF0gPSBNYXRoLm1pbih5UmFuZ2VbMF0sIHBvc1sxXSk7XG4gICAgeVJhbmdlWzFdID0gTWF0aC5tYXgoeVJhbmdlWzFdLCBwb3NbMV0pO1xuICB9KTtcbiAgcmV0dXJuIFtNYXRoLmFicyh4UmFuZ2VbMV0gLSB4UmFuZ2VbMF0pLCBNYXRoLmFicyh5UmFuZ2VbMV0gLSB5UmFuZ2VbMF0pXTtcbn1cblxuZnVuY3Rpb24gbW92ZUNvbnRyb2xQb3MoY29udHJvbFBvc2VzLCBpbmRleCwgZGlzdCwgaXNSZWN0LCBrZWVwUmF0aW8pIHtcbiAgdmFyIF9hID0gY29udHJvbFBvc2VzW2luZGV4XSxcbiAgICAgIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbixcbiAgICAgIHN1YiA9IF9hLnN1YjtcbiAgdmFyIGRpc3RzID0gY29udHJvbFBvc2VzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfSk7XG4gIHZhciBkaXJlY3Rpb25zID0gZGlyZWN0aW9uID8gZGlyZWN0aW9uLnNwbGl0KFwiXCIpIDogW107XG5cbiAgaWYgKGlzUmVjdCAmJiBpbmRleCA8IDgpIHtcbiAgICB2YXIgdmVydGljYWxEaXJlY3Rpb25zID0gZGlyZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGRpcikge1xuICAgICAgcmV0dXJuIGRpciA9PT0gXCJ3XCIgfHwgZGlyID09PSBcImVcIjtcbiAgICB9KTtcbiAgICB2YXIgaG9yaXpvbnRhbERpcmVjdGlvbnMgPSBkaXJlY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7XG4gICAgICByZXR1cm4gZGlyID09PSBcIm5cIiB8fCBkaXIgPT09IFwic1wiO1xuICAgIH0pO1xuICAgIHZhciB2ZXJ0aWNhbERpcmVjdGlvbl8xID0gdmVydGljYWxEaXJlY3Rpb25zWzBdO1xuICAgIHZhciBob3Jpem9udGFsRGlyZWN0aW9uXzEgPSBob3Jpem9udGFsRGlyZWN0aW9uc1swXTtcbiAgICBkaXN0c1tpbmRleF0gPSBkaXN0O1xuXG4gICAgdmFyIF9iID0gZ2V0Q29udHJvbFNpemUoY29udHJvbFBvc2VzKSxcbiAgICAgICAgd2lkdGggPSBfYlswXSxcbiAgICAgICAgaGVpZ2h0ID0gX2JbMV07XG5cbiAgICB2YXIgcmF0aW8gPSB3aWR0aCAmJiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IDA7XG5cbiAgICBpZiAocmF0aW8gJiYga2VlcFJhdGlvKSB7XG4gICAgICAvLyAwIDEgMlxuICAgICAgLy8gNyAgIDNcbiAgICAgIC8vIDYgNSA0XG4gICAgICB2YXIgZml4ZWRJbmRleCA9IChpbmRleCArIDQpICUgODtcbiAgICAgIHZhciBmaXhlZFBvc2l0aW9uID0gY29udHJvbFBvc2VzW2ZpeGVkSW5kZXhdLnBvcztcbiAgICAgIHZhciBzaXplRGlyZWN0aW9uID0gWzAsIDBdO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uLmluZGV4T2YoXCJ3XCIpID4gLTEpIHtcbiAgICAgICAgc2l6ZURpcmVjdGlvblswXSA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24uaW5kZXhPZihcImVcIikgPiAtMSkge1xuICAgICAgICBzaXplRGlyZWN0aW9uWzBdID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcmVjdGlvbi5pbmRleE9mKFwiblwiKSA+IC0xKSB7XG4gICAgICAgIHNpemVEaXJlY3Rpb25bMV0gPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcbiAgICAgICAgc2l6ZURpcmVjdGlvblsxXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXh0RGlzdCA9IGdldFNpemVEaXN0QnlEaXN0KFt3aWR0aCwgaGVpZ2h0XSwgZGlzdCwgcmF0aW8sIHNpemVEaXJlY3Rpb24sIHRydWUpO1xuICAgICAgdmFyIG5leHRXaWR0aCA9IHdpZHRoICsgbmV4dERpc3RbMF07XG4gICAgICB2YXIgbmV4dEhlaWdodCA9IGhlaWdodCArIG5leHREaXN0WzFdO1xuICAgICAgdmFyIHRvcCA9IGZpeGVkUG9zaXRpb25bMV07XG4gICAgICB2YXIgYm90dG9tID0gZml4ZWRQb3NpdGlvblsxXTtcbiAgICAgIHZhciBsZWZ0ID0gZml4ZWRQb3NpdGlvblswXTtcbiAgICAgIHZhciByaWdodCA9IGZpeGVkUG9zaXRpb25bMF07XG5cbiAgICAgIGlmIChzaXplRGlyZWN0aW9uWzBdID09PSAtMSkge1xuICAgICAgICBsZWZ0ID0gcmlnaHQgLSBuZXh0V2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKHNpemVEaXJlY3Rpb25bMF0gPT09IDEpIHtcbiAgICAgICAgcmlnaHQgPSBsZWZ0ICsgbmV4dFdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IGxlZnQgLSBuZXh0V2lkdGggLyAyO1xuICAgICAgICByaWdodCA9IHJpZ2h0ICsgbmV4dFdpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNpemVEaXJlY3Rpb25bMV0gPT09IC0xKSB7XG4gICAgICAgIHRvcCA9IGJvdHRvbSAtIG5leHRIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKHNpemVEaXJlY3Rpb25bMV0gPT09IDEpIHtcbiAgICAgICAgYm90dG9tID0gdG9wICsgbmV4dEhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvcCA9IGJvdHRvbSAtIG5leHRIZWlnaHQgLyAyO1xuICAgICAgICBib3R0b20gPSB0b3AgKyBuZXh0SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dENvbnRyb2xQb3Nlc18xID0gZ2V0UmVjdFBvc2VzKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCk7XG4gICAgICBjb250cm9sUG9zZXMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbFBvc2UsIGkpIHtcbiAgICAgICAgZGlzdHNbaV1bMF0gPSBuZXh0Q29udHJvbFBvc2VzXzFbaV0ucG9zWzBdIC0gY29udHJvbFBvc2UucG9zWzBdO1xuICAgICAgICBkaXN0c1tpXVsxXSA9IG5leHRDb250cm9sUG9zZXNfMVtpXS5wb3NbMV0gLSBjb250cm9sUG9zZS5wb3NbMV07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udHJvbFBvc2VzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xQb3NlLCBpKSB7XG4gICAgICAgIHZhciBjb250cm9sRGlyID0gY29udHJvbFBvc2UuZGlyZWN0aW9uO1xuXG4gICAgICAgIGlmICghY29udHJvbERpcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250cm9sRGlyLmluZGV4T2YodmVydGljYWxEaXJlY3Rpb25fMSkgPiAtMSkge1xuICAgICAgICAgIGRpc3RzW2ldWzBdID0gZGlzdFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250cm9sRGlyLmluZGV4T2YoaG9yaXpvbnRhbERpcmVjdGlvbl8xKSA+IC0xKSB7XG4gICAgICAgICAgZGlzdHNbaV1bMV0gPSBkaXN0WzFdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHZlcnRpY2FsRGlyZWN0aW9uXzEpIHtcbiAgICAgICAgZGlzdHNbMV1bMF0gPSBkaXN0WzBdIC8gMjtcbiAgICAgICAgZGlzdHNbNV1bMF0gPSBkaXN0WzBdIC8gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGhvcml6b250YWxEaXJlY3Rpb25fMSkge1xuICAgICAgICBkaXN0c1szXVsxXSA9IGRpc3RbMV0gLyAyO1xuICAgICAgICBkaXN0c1s3XVsxXSA9IGRpc3RbMV0gLyAyO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiYgIXN1Yikge1xuICAgIGRpcmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICB2YXIgaXNWZXJ0aWNhbCA9IGRpciA9PT0gXCJuXCIgfHwgZGlyID09PSBcInNcIjtcbiAgICAgIGNvbnRyb2xQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sUG9zZSwgaSkge1xuICAgICAgICB2YXIgZGlyRGlyID0gY29udHJvbFBvc2UuZGlyZWN0aW9uLFxuICAgICAgICAgICAgZGlySG9yaXpvbnRhbCA9IGNvbnRyb2xQb3NlLmhvcml6b250YWwsXG4gICAgICAgICAgICBkaXJWZXJ0aWNhbCA9IGNvbnRyb2xQb3NlLnZlcnRpY2FsO1xuXG4gICAgICAgIGlmICghZGlyRGlyIHx8IGRpckRpci5pbmRleE9mKGRpcikgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzdHNbaV0gPSBbaXNWZXJ0aWNhbCB8fCAhZGlySG9yaXpvbnRhbCA/IDAgOiBkaXN0WzBdLCAhaXNWZXJ0aWNhbCB8fCAhZGlyVmVydGljYWwgPyAwIDogZGlzdFsxXV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkaXN0c1tpbmRleF0gPSBkaXN0O1xuICB9XG5cbiAgcmV0dXJuIGRpc3RzO1xufVxuXG5mdW5jdGlvbiBnZXRDbGlwUGF0aCh0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIGRlZmF1bHRDbGlwLCBjdXN0b21DbGlwKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcblxuICB2YXIgY2xpcFRleHQgPSBjdXN0b21DbGlwO1xuXG4gIGlmICghY2xpcFRleHQpIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gICAgdmFyIGNsaXBQYXRoID0gc3R5bGUuY2xpcFBhdGg7XG4gICAgY2xpcFRleHQgPSBjbGlwUGF0aCAhPT0gXCJub25lXCIgPyBjbGlwUGF0aCA6IHN0eWxlLmNsaXA7XG4gIH1cblxuICBpZiAoIWNsaXBUZXh0IHx8IGNsaXBUZXh0ID09PSBcIm5vbmVcIiB8fCBjbGlwVGV4dCA9PT0gXCJhdXRvXCIpIHtcbiAgICBjbGlwVGV4dCA9IGRlZmF1bHRDbGlwO1xuXG4gICAgaWYgKCFjbGlwVGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfaCA9IHNwbGl0QnJhY2tldChjbGlwVGV4dCksXG4gICAgICBfaiA9IF9oLnByZWZpeCxcbiAgICAgIGNsaXBQcmVmaXggPSBfaiA9PT0gdm9pZCAwID8gY2xpcFRleHQgOiBfaixcbiAgICAgIF9rID0gX2gudmFsdWUsXG4gICAgICB2YWx1ZSA9IF9rID09PSB2b2lkIDAgPyBcIlwiIDogX2s7XG5cbiAgdmFyIGlzQ2lyY2xlID0gY2xpcFByZWZpeCA9PT0gXCJjaXJjbGVcIjtcbiAgdmFyIHNwbGl0dGVyID0gXCIgXCI7XG5cbiAgaWYgKGNsaXBQcmVmaXggPT09IFwicG9seWdvblwiKSB7XG4gICAgdmFyIHZhbHVlcyA9IHNwbGl0Q29tbWEodmFsdWUgfHwgXCIwJSAwJSwgMTAwJSAwJSwgMTAwJSAxMDAlLCAwJSAxMDAlXCIpO1xuICAgIHNwbGl0dGVyID0gXCIsXCI7XG4gICAgdmFyIHBvc2VzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICB2YXIgX2EgPSBwb3Muc3BsaXQoXCIgXCIpLFxuICAgICAgICAgIHhQb3MgPSBfYVswXSxcbiAgICAgICAgICB5UG9zID0gX2FbMV07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRpY2FsOiAxLFxuICAgICAgICBob3Jpem9udGFsOiAxLFxuICAgICAgICBwb3M6IFtjb252ZXJ0VW5pdFNpemUoeFBvcywgd2lkdGgpLCBjb252ZXJ0VW5pdFNpemUoeVBvcywgaGVpZ2h0KV1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGNsaXBQcmVmaXgsXG4gICAgICBjbGlwVGV4dDogY2xpcFRleHQsXG4gICAgICBwb3NlczogcG9zZXMsXG4gICAgICBzcGxpdHRlcjogc3BsaXR0ZXJcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzQ2lyY2xlIHx8IGNsaXBQcmVmaXggPT09IFwiZWxsaXBzZVwiKSB7XG4gICAgdmFyIHhQb3MgPSBcIlwiO1xuICAgIHZhciB5UG9zID0gXCJcIjtcbiAgICB2YXIgcmFkaXVzWF8xID0gMDtcbiAgICB2YXIgcmFkaXVzWV8xID0gMDtcbiAgICB2YXIgdmFsdWVzID0gc3BsaXRTcGFjZSh2YWx1ZSk7XG5cbiAgICBpZiAoaXNDaXJjbGUpIHtcbiAgICAgIHZhciByYWRpdXMgPSBcIlwiO1xuICAgICAgX2EgPSB2YWx1ZXNbMF0sIHJhZGl1cyA9IF9hID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2EsIF9iID0gdmFsdWVzWzJdLCB4UG9zID0gX2IgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfYiwgX2MgPSB2YWx1ZXNbM10sIHlQb3MgPSBfYyA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9jO1xuICAgICAgcmFkaXVzWF8xID0gY29udmVydFVuaXRTaXplKHJhZGl1cywgTWF0aC5zcXJ0KCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSAvIDIpKTtcbiAgICAgIHJhZGl1c1lfMSA9IHJhZGl1c1hfMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHhSYWRpdXMgPSBcIlwiO1xuICAgICAgdmFyIHlSYWRpdXMgPSBcIlwiO1xuICAgICAgX2QgPSB2YWx1ZXNbMF0sIHhSYWRpdXMgPSBfZCA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9kLCBfZSA9IHZhbHVlc1sxXSwgeVJhZGl1cyA9IF9lID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2UsIF9mID0gdmFsdWVzWzNdLCB4UG9zID0gX2YgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfZiwgX2cgPSB2YWx1ZXNbNF0sIHlQb3MgPSBfZyA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9nO1xuICAgICAgcmFkaXVzWF8xID0gY29udmVydFVuaXRTaXplKHhSYWRpdXMsIHdpZHRoKTtcbiAgICAgIHJhZGl1c1lfMSA9IGNvbnZlcnRVbml0U2l6ZSh5UmFkaXVzLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHZhciBjZW50ZXJQb3NfMSA9IFtjb252ZXJ0VW5pdFNpemUoeFBvcywgd2lkdGgpLCBjb252ZXJ0VW5pdFNpemUoeVBvcywgaGVpZ2h0KV07XG5cbiAgICB2YXIgcG9zZXMgPSBfX3NwcmVhZEFycmF5KFt7XG4gICAgICB2ZXJ0aWNhbDogMSxcbiAgICAgIGhvcml6b250YWw6IDEsXG4gICAgICBwb3M6IGNlbnRlclBvc18xLFxuICAgICAgZGlyZWN0aW9uOiBcIm5lc3dcIlxuICAgIH1dLCBDTElQX0RJUkVDVElPTlMuc2xpY2UoMCwgaXNDaXJjbGUgPyAxIDogMikubWFwKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRpY2FsOiBNYXRoLmFicyhkaXJbMV0pLFxuICAgICAgICBob3Jpem9udGFsOiBkaXJbMF0sXG4gICAgICAgIGRpcmVjdGlvbjogZGlyWzJdLFxuICAgICAgICBzdWI6IHRydWUsXG4gICAgICAgIHBvczogW2NlbnRlclBvc18xWzBdICsgZGlyWzBdICogcmFkaXVzWF8xLCBjZW50ZXJQb3NfMVsxXSArIGRpclsxXSAqIHJhZGl1c1lfMV1cbiAgICAgIH07XG4gICAgfSksIHRydWUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGNsaXBQcmVmaXgsXG4gICAgICBjbGlwVGV4dDogY2xpcFRleHQsXG4gICAgICByYWRpdXNYOiByYWRpdXNYXzEsXG4gICAgICByYWRpdXNZOiByYWRpdXNZXzEsXG4gICAgICBsZWZ0OiBjZW50ZXJQb3NfMVswXSAtIHJhZGl1c1hfMSxcbiAgICAgIHRvcDogY2VudGVyUG9zXzFbMV0gLSByYWRpdXNZXzEsXG4gICAgICBwb3NlczogcG9zZXMsXG4gICAgICBzcGxpdHRlcjogc3BsaXR0ZXJcbiAgICB9O1xuICB9IGVsc2UgaWYgKGNsaXBQcmVmaXggPT09IFwiaW5zZXRcIikge1xuICAgIHZhciB2YWx1ZXMgPSBzcGxpdFNwYWNlKHZhbHVlIHx8IFwiMCAwIDAgMFwiKTtcbiAgICB2YXIgcm91bmRJbmRleCA9IHZhbHVlcy5pbmRleE9mKFwicm91bmRcIik7XG4gICAgdmFyIHJlY3RMZW5ndGggPSAocm91bmRJbmRleCA+IC0xID8gdmFsdWVzLnNsaWNlKDAsIHJvdW5kSW5kZXgpIDogdmFsdWVzKS5sZW5ndGg7XG4gICAgdmFyIHJhZGl1c1ZhbHVlcyA9IHZhbHVlcy5zbGljZShyZWN0TGVuZ3RoICsgMSk7XG5cbiAgICB2YXIgX2wgPSB2YWx1ZXMuc2xpY2UoMCwgcmVjdExlbmd0aCksXG4gICAgICAgIHRvcFZhbHVlID0gX2xbMF0sXG4gICAgICAgIF9tID0gX2xbMV0sXG4gICAgICAgIHJpZ2h0VmFsdWUgPSBfbSA9PT0gdm9pZCAwID8gdG9wVmFsdWUgOiBfbSxcbiAgICAgICAgX28gPSBfbFsyXSxcbiAgICAgICAgYm90dG9tVmFsdWUgPSBfbyA9PT0gdm9pZCAwID8gdG9wVmFsdWUgOiBfbyxcbiAgICAgICAgX3AgPSBfbFszXSxcbiAgICAgICAgbGVmdFZhbHVlID0gX3AgPT09IHZvaWQgMCA/IHJpZ2h0VmFsdWUgOiBfcDtcblxuICAgIHZhciBfcSA9IFt0b3BWYWx1ZSwgYm90dG9tVmFsdWVdLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gY29udmVydFVuaXRTaXplKHBvcywgaGVpZ2h0KTtcbiAgICB9KSxcbiAgICAgICAgdG9wID0gX3FbMF0sXG4gICAgICAgIGJvdHRvbSA9IF9xWzFdO1xuXG4gICAgdmFyIF9yID0gW2xlZnRWYWx1ZSwgcmlnaHRWYWx1ZV0ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBjb252ZXJ0VW5pdFNpemUocG9zLCB3aWR0aCk7XG4gICAgfSksXG4gICAgICAgIGxlZnQgPSBfclswXSxcbiAgICAgICAgcmlnaHQgPSBfclsxXTtcblxuICAgIHZhciBuZXh0UmlnaHQgPSB3aWR0aCAtIHJpZ2h0O1xuICAgIHZhciBuZXh0Qm90dG9tID0gaGVpZ2h0IC0gYm90dG9tO1xuICAgIHZhciByYWRpdXNQb3NlcyA9IGdldFJhZGl1c1ZhbHVlcyhyYWRpdXNWYWx1ZXMsIG5leHRSaWdodCAtIGxlZnQsIG5leHRCb3R0b20gLSB0b3AsIGxlZnQsIHRvcCk7XG5cbiAgICB2YXIgcG9zZXMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGdldFJlY3RQb3Nlcyh0b3AsIG5leHRSaWdodCwgbmV4dEJvdHRvbSwgbGVmdCksIHRydWUpLCByYWRpdXNQb3NlcywgdHJ1ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbnNldFwiLFxuICAgICAgY2xpcFRleHQ6IGNsaXBUZXh0LFxuICAgICAgcG9zZXM6IHBvc2VzLFxuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgcmlnaHQ6IG5leHRSaWdodCxcbiAgICAgIGJvdHRvbTogbmV4dEJvdHRvbSxcbiAgICAgIHJhZGl1czogcmFkaXVzVmFsdWVzLFxuICAgICAgc3BsaXR0ZXI6IHNwbGl0dGVyXG4gICAgfTtcbiAgfSBlbHNlIGlmIChjbGlwUHJlZml4ID09PSBcInJlY3RcIikge1xuICAgIC8vIHRvcCByaWdodCBib3R0b20gbGVmdFxuICAgIHZhciB2YWx1ZXMgPSBzcGxpdENvbW1hKHZhbHVlIHx8IFwiMHB4LCBcIi5jb25jYXQod2lkdGgsIFwicHgsIFwiKS5jb25jYXQoaGVpZ2h0LCBcInB4LCAwcHhcIikpO1xuICAgIHNwbGl0dGVyID0gXCIsXCI7XG5cbiAgICB2YXIgX3MgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHZhciBwb3NWYWx1ZSA9IHNwbGl0VW5pdChwb3MpLnZhbHVlO1xuICAgICAgcmV0dXJuIHBvc1ZhbHVlO1xuICAgIH0pLFxuICAgICAgICB0b3AgPSBfc1swXSxcbiAgICAgICAgcmlnaHQgPSBfc1sxXSxcbiAgICAgICAgYm90dG9tID0gX3NbMl0sXG4gICAgICAgIGxlZnQgPSBfc1szXTtcblxuICAgIHZhciBwb3NlcyA9IGdldFJlY3RQb3Nlcyh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJlY3RcIixcbiAgICAgIGNsaXBUZXh0OiBjbGlwVGV4dCxcbiAgICAgIHBvc2VzOiBwb3NlcyxcbiAgICAgIHRvcDogdG9wLFxuICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICBzcGxpdHRlcjogc3BsaXR0ZXJcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiBhZGRDbGlwUGF0aChtb3ZlYWJsZSwgZSkge1xuICB2YXIgX2EgPSBjYWxjdWxhdGVQb2ludGVyRGlzdChtb3ZlYWJsZSwgZSksXG4gICAgICBkaXN0WCA9IF9hWzBdLFxuICAgICAgZGlzdFkgPSBfYVsxXTtcblxuICB2YXIgX2IgPSBlLmRhdGFzLFxuICAgICAgY2xpcFBhdGggPSBfYi5jbGlwUGF0aCxcbiAgICAgIGNsaXBJbmRleCA9IF9iLmNsaXBJbmRleDtcbiAgdmFyIF9jID0gY2xpcFBhdGgsXG4gICAgICBjbGlwVHlwZSA9IF9jLnR5cGUsXG4gICAgICBjbGlwUG9zZXMgPSBfYy5wb3NlcyxcbiAgICAgIHNwbGl0dGVyID0gX2Muc3BsaXR0ZXI7XG4gIHZhciBwb3NlcyA9IGNsaXBQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3MucG9zO1xuICB9KTtcblxuICBpZiAoY2xpcFR5cGUgPT09IFwicG9seWdvblwiKSB7XG4gICAgcG9zZXMuc3BsaWNlKGNsaXBJbmRleCwgMCwgW2Rpc3RYLCBkaXN0WV0pO1xuICB9IGVsc2UgaWYgKGNsaXBUeXBlID09PSBcImluc2V0XCIpIHtcbiAgICB2YXIgaG9yaXpvbnRhbEluZGV4ID0gSE9SSVpPTlRBTF9SQURJVVNfT1JERVIuaW5kZXhPZihjbGlwSW5kZXgpO1xuICAgIHZhciB2ZXJ0aWNhbEluZGV4ID0gVkVSVElDQUxfUkFESVVTX09SREVSLmluZGV4T2YoY2xpcEluZGV4KTtcbiAgICB2YXIgbGVuZ3RoID0gY2xpcFBvc2VzLmxlbmd0aDtcbiAgICBhZGRSYWRpdXNQb3MoY2xpcFBvc2VzLCBwb3NlcywgOCwgaG9yaXpvbnRhbEluZGV4LCB2ZXJ0aWNhbEluZGV4LCBkaXN0WCwgZGlzdFksIHBvc2VzWzRdWzBdLCBwb3Nlc1s0XVsxXSwgcG9zZXNbMF1bMF0sIHBvc2VzWzBdWzFdKTtcblxuICAgIGlmIChsZW5ndGggPT09IGNsaXBQb3Nlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNsaXBTdHlsZXMgPSBnZXRDbGlwU3R5bGVzKG1vdmVhYmxlLCBjbGlwUGF0aCwgcG9zZXMpO1xuICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25DbGlwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICBjbGlwRXZlbnRUeXBlOiBcImFkZGVkXCIsXG4gICAgY2xpcFR5cGU6IGNsaXBUeXBlLFxuICAgIHBvc2VzOiBwb3NlcyxcbiAgICBjbGlwU3R5bGVzOiBjbGlwU3R5bGVzLFxuICAgIGNsaXBTdHlsZTogXCJcIi5jb25jYXQoY2xpcFR5cGUsIFwiKFwiKS5jb25jYXQoY2xpcFN0eWxlcy5qb2luKHNwbGl0dGVyKSwgXCIpXCIpLFxuICAgIGRpc3RYOiAwLFxuICAgIGRpc3RZOiAwXG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2xpcFBhdGgobW92ZWFibGUsIGUpIHtcbiAgdmFyIF9hID0gZS5kYXRhcyxcbiAgICAgIGNsaXBQYXRoID0gX2EuY2xpcFBhdGgsXG4gICAgICBjbGlwSW5kZXggPSBfYS5jbGlwSW5kZXg7XG4gIHZhciBfYiA9IGNsaXBQYXRoLFxuICAgICAgY2xpcFR5cGUgPSBfYi50eXBlLFxuICAgICAgY2xpcFBvc2VzID0gX2IucG9zZXMsXG4gICAgICBzcGxpdHRlciA9IF9iLnNwbGl0dGVyO1xuICB2YXIgcG9zZXMgPSBjbGlwUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zLnBvcztcbiAgfSk7XG4gIHZhciBsZW5ndGggPSBwb3Nlcy5sZW5ndGg7XG5cbiAgaWYgKGNsaXBUeXBlID09PSBcInBvbHlnb25cIikge1xuICAgIGNsaXBQb3Nlcy5zcGxpY2UoY2xpcEluZGV4LCAxKTtcbiAgICBwb3Nlcy5zcGxpY2UoY2xpcEluZGV4LCAxKTtcbiAgfSBlbHNlIGlmIChjbGlwVHlwZSA9PT0gXCJpbnNldFwiKSB7XG4gICAgaWYgKGNsaXBJbmRleCA8IDgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZW1vdmVSYWRpdXNQb3MoY2xpcFBvc2VzLCBwb3NlcywgY2xpcEluZGV4LCA4LCBsZW5ndGgpO1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gY2xpcFBvc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2xpcFN0eWxlcyA9IGdldENsaXBTdHlsZXMobW92ZWFibGUsIGNsaXBQYXRoLCBwb3Nlcyk7XG4gIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgIGNsaXBFdmVudFR5cGU6IFwicmVtb3ZlZFwiLFxuICAgIGNsaXBUeXBlOiBjbGlwVHlwZSxcbiAgICBwb3NlczogcG9zZXMsXG4gICAgY2xpcFN0eWxlczogY2xpcFN0eWxlcyxcbiAgICBjbGlwU3R5bGU6IFwiXCIuY29uY2F0KGNsaXBUeXBlLCBcIihcIikuY29uY2F0KGNsaXBTdHlsZXMuam9pbihzcGxpdHRlciksIFwiKVwiKSxcbiAgICBkaXN0WDogMCxcbiAgICBkaXN0WTogMFxuICB9KSk7XG59XG4vKipcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuQ2xpcHBhYmxlXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciB0byBjbGlwIHRoZSB0YXJnZXQuXG4gKi9cblxuXG52YXIgQ2xpcHBhYmxlID0ge1xuICBuYW1lOiBcImNsaXBwYWJsZVwiLFxuICBwcm9wczoge1xuICAgIGNsaXBwYWJsZTogQm9vbGVhbixcbiAgICBkZWZhdWx0Q2xpcFBhdGg6IFN0cmluZyxcbiAgICBjdXN0b21DbGlwUGF0aDogU3RyaW5nLFxuICAgIGtlZXBSYXRpbzogQm9vbGVhbixcbiAgICBjbGlwUmVsYXRpdmU6IEJvb2xlYW4sXG4gICAgY2xpcEFyZWE6IEJvb2xlYW4sXG4gICAgZHJhZ1dpdGhDbGlwOiBCb29sZWFuLFxuICAgIGNsaXBUYXJnZXRCb3VuZHM6IEJvb2xlYW4sXG4gICAgY2xpcFZlcnRpY2FsR3VpZGVsaW5lczogQXJyYXksXG4gICAgY2xpcEhvcml6b250YWxHdWlkZWxpbmVzOiBBcnJheSxcbiAgICBjbGlwU25hcFRocmVzaG9sZDogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHtcbiAgICBvbkNsaXBTdGFydDogXCJjbGlwU3RhcnRcIixcbiAgICBvbkNsaXA6IFwiY2xpcFwiLFxuICAgIG9uQ2xpcEVuZDogXCJjbGlwRW5kXCJcbiAgfSxcbiAgY3NzOiBbXCIuY29udHJvbC5jbGlwLWNvbnRyb2wge1xcbiAgICBiYWNrZ3JvdW5kOiAjNmQ2O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5jb250cm9sLmNsaXAtY29udHJvbC5jbGlwLXJhZGl1cyB7XFxuICAgIGJhY2tncm91bmQ6ICNkNjY7XFxufVxcbi5saW5lLmNsaXAtbGluZSB7XFxuICAgIGJhY2tncm91bmQ6ICM2ZTY7XFxuICAgIGN1cnNvcjogbW92ZTtcXG4gICAgei1pbmRleDogMTtcXG59XFxuLmNsaXAtYXJlYSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbn1cXG4uY2xpcC1lbGxpcHNlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBjdXJzb3I6IG1vdmU7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICM2ZDY7XFxuICAgIGJvcmRlcjogdmFyKC0tem9vbXB4KSBzb2xpZCAjNmQ2O1xcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IDBweCAwcHg7XFxufVwiLCBcIjpob3N0IHtcXG4gICAgLS1ib3VuZHMtY29sb3I6ICNkNjY7XFxufVwiLCBcIi5ndWlkZWxpbmUge1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgei1pbmRleDogMjtcXG59XCIsIFwiLmxpbmUuZ3VpZGVsaW5lLmJvdW5kcyB7XFxuICAgIGJhY2tncm91bmQ6ICNkNjY7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLWJvdW5kcy1jb2xvcik7XFxufVwiXSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICAgIGN1c3RvbUNsaXBQYXRoID0gX2EuY3VzdG9tQ2xpcFBhdGgsXG4gICAgICAgIGRlZmF1bHRDbGlwUGF0aCA9IF9hLmRlZmF1bHRDbGlwUGF0aCxcbiAgICAgICAgY2xpcEFyZWEgPSBfYS5jbGlwQXJlYSxcbiAgICAgICAgem9vbSA9IF9hLnpvb207XG4gICAgdmFyIF9iID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHRhcmdldCA9IF9iLnRhcmdldCxcbiAgICAgICAgd2lkdGggPSBfYi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2IuaGVpZ2h0LFxuICAgICAgICBhbGxNYXRyaXggPSBfYi5hbGxNYXRyaXgsXG4gICAgICAgIGlzM2QgPSBfYi5pczNkLFxuICAgICAgICBsZWZ0ID0gX2IubGVmdCxcbiAgICAgICAgdG9wID0gX2IudG9wLFxuICAgICAgICBwb3MxID0gX2IucG9zMSxcbiAgICAgICAgcG9zMiA9IF9iLnBvczIsXG4gICAgICAgIHBvczMgPSBfYi5wb3MzLFxuICAgICAgICBwb3M0ID0gX2IucG9zNCxcbiAgICAgICAgY2xpcFBhdGhTdGF0ZSA9IF9iLmNsaXBQYXRoU3RhdGUsXG4gICAgICAgIHNuYXBCb3VuZEluZm9zID0gX2Iuc25hcEJvdW5kSW5mb3MsXG4gICAgICAgIHJvdGF0aW9uUmFkID0gX2Iucm90YXRpb247XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBjbGlwUGF0aCA9IGdldENsaXBQYXRoKHRhcmdldCwgd2lkdGgsIGhlaWdodCwgZGVmYXVsdENsaXBQYXRoIHx8IFwiaW5zZXRcIiwgY2xpcFBhdGhTdGF0ZSB8fCBjdXN0b21DbGlwUGF0aCk7XG5cbiAgICBpZiAoIWNsaXBQYXRoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gICAgdmFyIHR5cGUgPSBjbGlwUGF0aC50eXBlO1xuICAgIHZhciBjbGlwUG9zZXMgPSBjbGlwUGF0aC5wb3NlcztcbiAgICB2YXIgcG9zZXMgPSBjbGlwUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIC8vIHJldHVybiBbeCwgeV07XG4gICAgICB2YXIgY2FsY3VsYXRlZFBvcyA9IGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgcG9zLnBvcywgbik7XG4gICAgICByZXR1cm4gW2NhbGN1bGF0ZWRQb3NbMF0gLSBsZWZ0LCBjYWxjdWxhdGVkUG9zWzFdIC0gdG9wXTtcbiAgICB9KTtcbiAgICB2YXIgY29udHJvbHMgPSBbXTtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICB2YXIgaXNSZWN0ID0gdHlwZSA9PT0gXCJyZWN0XCI7XG4gICAgdmFyIGlzSW5zZXQgPSB0eXBlID09PSBcImluc2V0XCI7XG4gICAgdmFyIGlzUG9seWdvbiA9IHR5cGUgPT09IFwicG9seWdvblwiO1xuXG4gICAgaWYgKGlzUmVjdCB8fCBpc0luc2V0IHx8IGlzUG9seWdvbikge1xuICAgICAgdmFyIGxpbmVQb3Nlc18xID0gaXNJbnNldCA/IHBvc2VzLnNsaWNlKDAsIDgpIDogcG9zZXM7XG4gICAgICBsaW5lcyA9IGxpbmVQb3Nlc18xLm1hcChmdW5jdGlvbiAodG8sIGkpIHtcbiAgICAgICAgdmFyIGZyb20gPSBpID09PSAwID8gbGluZVBvc2VzXzFbbGluZVBvc2VzXzEubGVuZ3RoIC0gMV0gOiBsaW5lUG9zZXNfMVtpIC0gMV07XG4gICAgICAgIHZhciByYWQgPSBnZXRSYWQoZnJvbSwgdG8pO1xuICAgICAgICB2YXIgZGlzdCA9IGdldERpYWdvbmFsU2l6ZShmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICBrZXk6IFwiY2xpcExpbmVcIi5jb25jYXQoaSksXG4gICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJsaW5lXCIsIFwiY2xpcC1saW5lXCIsIFwic25hcC1jb250cm9sXCIpLFxuICAgICAgICAgIFwiZGF0YS1jbGlwLWluZGV4XCI6IGksXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdChkaXN0LCBcInB4XCIpLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQoZnJvbVswXSwgXCJweCwgXCIpLmNvbmNhdChmcm9tWzFdLCBcInB4KSByb3RhdGUoXCIpLmNvbmNhdChyYWQsIFwicmFkKSBzY2FsZVkoXCIpLmNvbmNhdCh6b29tLCBcIilcIilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29udHJvbHMgPSBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IFwiY2xpcENvbnRyb2xcIi5jb25jYXQoaSksXG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbFwiLCBcImNsaXAtY29udHJvbFwiLCBcInNuYXAtY29udHJvbFwiKSxcbiAgICAgICAgXCJkYXRhLWNsaXAtaW5kZXhcIjogaSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChwb3NbMF0sIFwicHgsIFwiKS5jb25jYXQocG9zWzFdLCBcInB4KSByb3RhdGUoXCIpLmNvbmNhdChyb3RhdGlvblJhZCwgXCJyYWQpIHNjYWxlKFwiKS5jb25jYXQoem9vbSwgXCIpXCIpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKGlzSW5zZXQpIHtcbiAgICAgIGNvbnRyb2xzLnB1c2guYXBwbHkoY29udHJvbHMsIHBvc2VzLnNsaWNlKDgpLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICBrZXk6IFwiY2xpcFJhZGl1c0NvbnRyb2xcIi5jb25jYXQoaSksXG4gICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJjb250cm9sXCIsIFwiY2xpcC1jb250cm9sXCIsIFwiY2xpcC1yYWRpdXNcIiwgXCJzbmFwLWNvbnRyb2xcIiksXG4gICAgICAgICAgXCJkYXRhLWNsaXAtaW5kZXhcIjogOCArIGksXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHBvc1swXSwgXCJweCwgXCIpLmNvbmNhdChwb3NbMV0sIFwicHgpIHJvdGF0ZShcIikuY29uY2F0KHJvdGF0aW9uUmFkLCBcInJhZCkgc2NhbGUoXCIpLmNvbmNhdCh6b29tLCBcIilcIilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBcImNpcmNsZVwiIHx8IHR5cGUgPT09IFwiZWxsaXBzZVwiKSB7XG4gICAgICB2YXIgY2xpcExlZnQgPSBjbGlwUGF0aC5sZWZ0LFxuICAgICAgICAgIGNsaXBUb3AgPSBjbGlwUGF0aC50b3AsXG4gICAgICAgICAgcmFkaXVzWCA9IGNsaXBQYXRoLnJhZGl1c1gsXG4gICAgICAgICAgcmFkaXVzWSA9IGNsaXBQYXRoLnJhZGl1c1k7XG5cbiAgICAgIHZhciBfYyA9IG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgW2NsaXBMZWZ0LCBjbGlwVG9wXSwgbiksIGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgWzAsIDBdLCBuKSksXG4gICAgICAgICAgZGlzdExlZnQgPSBfY1swXSxcbiAgICAgICAgICBkaXN0VG9wID0gX2NbMV07XG5cbiAgICAgIHZhciBlbGxpcHNlQ2xpcFBhdGggPSBcIm5vbmVcIjtcblxuICAgICAgaWYgKCFjbGlwQXJlYSkge1xuICAgICAgICB2YXIgcGllY2UgPSBNYXRoLm1heCgxMCwgcmFkaXVzWCAvIDUsIHJhZGl1c1kgLyA1KTtcbiAgICAgICAgdmFyIGFyZWFQb3NlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHBpZWNlOyArK2kpIHtcbiAgICAgICAgICB2YXIgcmFkID0gTWF0aC5QSSAqIDIgLyBwaWVjZSAqIGk7XG4gICAgICAgICAgYXJlYVBvc2VzLnB1c2goW3JhZGl1c1ggKyAocmFkaXVzWCAtIHpvb20pICogTWF0aC5jb3MocmFkKSwgcmFkaXVzWSArIChyYWRpdXNZIC0gem9vbSkgKiBNYXRoLnNpbihyYWQpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmVhUG9zZXMucHVzaChbcmFkaXVzWCwgLTJdKTtcbiAgICAgICAgYXJlYVBvc2VzLnB1c2goWy0yLCAtMl0pO1xuICAgICAgICBhcmVhUG9zZXMucHVzaChbLTIsIHJhZGl1c1kgKiAyICsgMl0pO1xuICAgICAgICBhcmVhUG9zZXMucHVzaChbcmFkaXVzWCAqIDIgKyAyLCByYWRpdXNZICogMiArIDJdKTtcbiAgICAgICAgYXJlYVBvc2VzLnB1c2goW3JhZGl1c1ggKiAyICsgMiwgLTJdKTtcbiAgICAgICAgYXJlYVBvc2VzLnB1c2goW3JhZGl1c1gsIC0yXSk7XG4gICAgICAgIGVsbGlwc2VDbGlwUGF0aCA9IFwicG9seWdvbihcIi5jb25jYXQoYXJlYVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHBvc1swXSwgXCJweCBcIikuY29uY2F0KHBvc1sxXSwgXCJweFwiKTtcbiAgICAgICAgfSkuam9pbihcIiwgXCIpLCBcIilcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRyb2xzLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGtleTogXCJjbGlwRWxsaXBzZVwiLFxuICAgICAgICBjbGFzc05hbWU6IHByZWZpeChcImNsaXAtZWxsaXBzZVwiLCBcInNuYXAtY29udHJvbFwiKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQocmFkaXVzWCAqIDIsIFwicHhcIiksXG4gICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChyYWRpdXNZICogMiwgXCJweFwiKSxcbiAgICAgICAgICBjbGlwUGF0aDogZWxsaXBzZUNsaXBQYXRoLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KC1sZWZ0ICsgZGlzdExlZnQsIFwicHgsIFwiKS5jb25jYXQoLXRvcCArIGRpc3RUb3AsIFwicHgpIFwiKS5jb25jYXQobWFrZU1hdHJpeENTUyhhbGxNYXRyaXgpKVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKGNsaXBBcmVhKSB7XG4gICAgICB2YXIgX2QgPSBnZXRSZWN0KF9fc3ByZWFkQXJyYXkoW3BvczEsIHBvczIsIHBvczMsIHBvczRdLCBwb3NlcywgdHJ1ZSkpLFxuICAgICAgICAgIGFsbFdpZHRoID0gX2Qud2lkdGgsXG4gICAgICAgICAgYWxsSGVpZ2h0ID0gX2QuaGVpZ2h0LFxuICAgICAgICAgIGFsbExlZnRfMSA9IF9kLmxlZnQsXG4gICAgICAgICAgYWxsVG9wXzEgPSBfZC50b3A7XG5cbiAgICAgIGlmIChpc1BvbHlnb24gfHwgaXNSZWN0IHx8IGlzSW5zZXQpIHtcbiAgICAgICAgdmFyIGFyZWFQb3NlcyA9IGlzSW5zZXQgPyBwb3Nlcy5zbGljZSgwLCA4KSA6IHBvc2VzO1xuICAgICAgICBjb250cm9scy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgIGtleTogXCJjbGlwQXJlYVwiLFxuICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY2xpcC1hcmVhXCIsIFwic25hcC1jb250cm9sXCIpLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQoYWxsV2lkdGgsIFwicHhcIiksXG4gICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGFsbEhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGFsbExlZnRfMSwgXCJweCwgXCIpLmNvbmNhdChhbGxUb3BfMSwgXCJweClcIiksXG4gICAgICAgICAgICBjbGlwUGF0aDogXCJwb2x5Z29uKFwiLmNvbmNhdChhcmVhUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHBvc1swXSAtIGFsbExlZnRfMSwgXCJweCBcIikuY29uY2F0KHBvc1sxXSAtIGFsbFRvcF8xLCBcInB4XCIpO1xuICAgICAgICAgICAgfSkuam9pbihcIiwgXCIpLCBcIilcIilcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc25hcEJvdW5kSW5mb3MpIHtcbiAgICAgIFtcInZlcnRpY2FsXCIsIFwiaG9yaXpvbnRhbFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3Rpb25UeXBlKSB7XG4gICAgICAgIHZhciBpbmZvID0gc25hcEJvdW5kSW5mb3NbZGlyZWN0aW9uVHlwZV07XG4gICAgICAgIHZhciBpc0hvcml6b250YWwgPSBkaXJlY3Rpb25UeXBlID09PSBcImhvcml6b250YWxcIjtcblxuICAgICAgICBpZiAoaW5mby5pc1NuYXApIHtcbiAgICAgICAgICBsaW5lcy5wdXNoLmFwcGx5KGxpbmVzLCBpbmZvLnNuYXAucG9zSW5mb3MubWFwKGZ1bmN0aW9uIChfYSwgaSkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IF9hLnBvcztcbiAgICAgICAgICAgIHZhciBzbmFwUG9zMSA9IG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgaXNIb3Jpem9udGFsID8gWzAsIHBvc10gOiBbcG9zLCAwXSwgbiksIFtsZWZ0LCB0b3BdKTtcbiAgICAgICAgICAgIHZhciBzbmFwUG9zMiA9IG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgaXNIb3Jpem9udGFsID8gW3dpZHRoLCBwb3NdIDogW3BvcywgaGVpZ2h0XSwgbiksIFtsZWZ0LCB0b3BdKTtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJMaW5lKFJlYWN0LCBcIlwiLCBzbmFwUG9zMSwgc25hcFBvczIsIHpvb20sIFwiY2xpcFwiLmNvbmNhdChkaXJlY3Rpb25UeXBlLCBcInNuYXBcIikuY29uY2F0KGkpLCBcImd1aWRlbGluZVwiKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5mby5pc0JvdW5kKSB7XG4gICAgICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgaW5mby5ib3VuZHMubWFwKGZ1bmN0aW9uIChfYSwgaSkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IF9hLnBvcztcbiAgICAgICAgICAgIHZhciBzbmFwUG9zMSA9IG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgaXNIb3Jpem9udGFsID8gWzAsIHBvc10gOiBbcG9zLCAwXSwgbiksIFtsZWZ0LCB0b3BdKTtcbiAgICAgICAgICAgIHZhciBzbmFwUG9zMiA9IG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgaXNIb3Jpem9udGFsID8gW3dpZHRoLCBwb3NdIDogW3BvcywgaGVpZ2h0XSwgbiksIFtsZWZ0LCB0b3BdKTtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJMaW5lKFJlYWN0LCBcIlwiLCBzbmFwUG9zMSwgc25hcFBvczIsIHpvb20sIFwiY2xpcFwiLmNvbmNhdChkaXJlY3Rpb25UeXBlLCBcImJvdW5kc1wiKS5jb25jYXQoaSksIFwiZ3VpZGVsaW5lXCIsIFwiYm91bmRzXCIsIFwiYm9sZFwiKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGNvbnRyb2xzLCB0cnVlKSwgbGluZXMsIHRydWUpO1xuICB9LFxuICBkcmFnQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIGUuaW5wdXRFdmVudCAmJiAoZS5pbnB1dEV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKS5pbmRleE9mKFwiY2xpcFwiKSA+IC0xO1xuICB9LFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xuICAgIHZhciBfYSA9IHByb3BzLmRyYWdXaXRoQ2xpcCxcbiAgICAgICAgZHJhZ1dpdGhDbGlwID0gX2EgPT09IHZvaWQgMCA/IHRydWUgOiBfYTtcblxuICAgIGlmIChkcmFnV2l0aENsaXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbFN0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgaXNEcmFnVGFyZ2V0OiB0cnVlXG4gICAgfSkpO1xuICB9LFxuICBkcmFnRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbEVuZChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICBkZWZhdWx0Q2xpcFBhdGggPSBfYS5kZWZhdWx0Q2xpcFBhdGgsXG4gICAgICAgIGN1c3RvbUNsaXBQYXRoID0gX2EuY3VzdG9tQ2xpcFBhdGg7XG4gICAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldCxcbiAgICAgICAgd2lkdGggPSBzdGF0ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xuICAgIHZhciBpbnB1dFRhcmdldCA9IGUuaW5wdXRFdmVudCA/IGUuaW5wdXRFdmVudC50YXJnZXQgOiBudWxsO1xuICAgIHZhciBjbGFzc05hbWUgPSBpbnB1dFRhcmdldCAmJiBpbnB1dFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiO1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG4gICAgdmFyIGNsaXBQYXRoID0gZ2V0Q2xpcFBhdGgodGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBkZWZhdWx0Q2xpcFBhdGggfHwgXCJpbnNldFwiLCBjdXN0b21DbGlwUGF0aCk7XG5cbiAgICBpZiAoIWNsaXBQYXRoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNsaXBUZXh0ID0gY2xpcFBhdGguY2xpcFRleHQsXG4gICAgICAgIHR5cGUgPSBjbGlwUGF0aC50eXBlLFxuICAgICAgICBwb3NlcyA9IGNsaXBQYXRoLnBvc2VzO1xuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25DbGlwU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgY2xpcFR5cGU6IHR5cGUsXG4gICAgICBjbGlwU3R5bGU6IGNsaXBUZXh0LFxuICAgICAgcG9zZXM6IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MucG9zO1xuICAgICAgfSlcbiAgICB9KSk7XG5cbiAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgZGF0YXMuaXNDbGlwU3RhcnQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkYXRhcy5pc0NvbnRyb2wgPSBjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoXCJjbGlwLWNvbnRyb2xcIikgPiAtMTtcbiAgICBkYXRhcy5pc0xpbmUgPSBjbGFzc05hbWUuaW5kZXhPZihcImNsaXAtbGluZVwiKSA+IC0xO1xuICAgIGRhdGFzLmlzQXJlYSA9IGNsYXNzTmFtZS5pbmRleE9mKFwiY2xpcC1hcmVhXCIpID4gLTEgfHwgY2xhc3NOYW1lLmluZGV4T2YoXCJjbGlwLWVsbGlwc2VcIikgPiAtMTtcbiAgICBkYXRhcy5jbGlwSW5kZXggPSBpbnB1dFRhcmdldCA/IHBhcnNlSW50KGlucHV0VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY2xpcC1pbmRleFwiKSwgMTApIDogLTE7XG4gICAgZGF0YXMuY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICBkYXRhcy5pc0NsaXBTdGFydCA9IHRydWU7XG4gICAgc3RhdGUuY2xpcFBhdGhTdGF0ZSA9IGNsaXBUZXh0O1xuICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgX2E7XG5cbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzLFxuICAgICAgICBpc0RyYWdUYXJnZXQgPSBlLmlzRHJhZ1RhcmdldDtcblxuICAgIGlmICghZGF0YXMuaXNDbGlwU3RhcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX2IgPSBkYXRhcyxcbiAgICAgICAgaXNDb250cm9sID0gX2IuaXNDb250cm9sLFxuICAgICAgICBpc0xpbmUgPSBfYi5pc0xpbmUsXG4gICAgICAgIGlzQXJlYSA9IF9iLmlzQXJlYSxcbiAgICAgICAgY2xpcEluZGV4ID0gX2IuY2xpcEluZGV4LFxuICAgICAgICBjbGlwUGF0aCA9IF9iLmNsaXBQYXRoO1xuXG4gICAgaWYgKCFjbGlwUGF0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBrZWVwUmF0aW8gPSBtb3ZlYWJsZS5wcm9wcy5rZWVwUmF0aW87XG4gICAgdmFyIGRpc3RYID0gMDtcbiAgICB2YXIgZGlzdFkgPSAwO1xuICAgIHZhciBvcmlnaW5hbERyYWdnYWJsZSA9IG9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlO1xuICAgIHZhciBvcmlnaW5hbERpc3QgPSBnZXREcmFnRGlzdChlKTtcblxuICAgIGlmIChpc0RyYWdUYXJnZXQgJiYgb3JpZ2luYWxEcmFnZ2FibGUpIHtcbiAgICAgIF9hID0gb3JpZ2luYWxEcmFnZ2FibGUucHJldkJlZm9yZURpc3QsIGRpc3RYID0gX2FbMF0sIGRpc3RZID0gX2FbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3RYID0gb3JpZ2luYWxEaXN0WzBdLCBkaXN0WSA9IG9yaWdpbmFsRGlzdFsxXTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3REaXN0ID0gW2Rpc3RYLCBkaXN0WV07XG4gICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gICAgdmFyIHdpZHRoID0gc3RhdGUud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHN0YXRlLmhlaWdodDtcbiAgICB2YXIgaXNEcmFnV2l0aFRhcmdldCA9ICFpc0FyZWEgJiYgIWlzQ29udHJvbCAmJiAhaXNMaW5lO1xuICAgIHZhciBjbGlwVHlwZSA9IGNsaXBQYXRoLnR5cGUsXG4gICAgICAgIGNsaXBQb3NlcyA9IGNsaXBQYXRoLnBvc2VzLFxuICAgICAgICBzcGxpdHRlciA9IGNsaXBQYXRoLnNwbGl0dGVyO1xuICAgIHZhciBwb3NlcyA9IGNsaXBQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIHBvcy5wb3M7XG4gICAgfSk7XG5cbiAgICBpZiAoaXNEcmFnV2l0aFRhcmdldCkge1xuICAgICAgZGlzdFggPSAtZGlzdFg7XG4gICAgICBkaXN0WSA9IC1kaXN0WTtcbiAgICB9XG5cbiAgICB2YXIgaXNBbGwgPSAhaXNDb250cm9sIHx8IGNsaXBQb3Nlc1tjbGlwSW5kZXhdLmRpcmVjdGlvbiA9PT0gXCJuZXN3XCI7XG4gICAgdmFyIGlzUmVjdCA9IGNsaXBUeXBlID09PSBcImluc2V0XCIgfHwgY2xpcFR5cGUgPT09IFwicmVjdFwiO1xuICAgIHZhciBkaXN0cyA9IGNsaXBQb3Nlcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9KTtcblxuICAgIGlmIChpc0NvbnRyb2wgJiYgIWlzQWxsKSB7XG4gICAgICB2YXIgX2MgPSBjbGlwUG9zZXNbY2xpcEluZGV4XSxcbiAgICAgICAgICBob3Jpem9udGFsID0gX2MuaG9yaXpvbnRhbCxcbiAgICAgICAgICB2ZXJ0aWNhbCA9IF9jLnZlcnRpY2FsO1xuICAgICAgdmFyIGRpc3QgPSBbZGlzdFggKiBNYXRoLmFicyhob3Jpem9udGFsKSwgZGlzdFkgKiBNYXRoLmFicyh2ZXJ0aWNhbCldO1xuICAgICAgZGlzdHMgPSBtb3ZlQ29udHJvbFBvcyhjbGlwUG9zZXMsIGNsaXBJbmRleCwgZGlzdCwgaXNSZWN0LCBrZWVwUmF0aW8pO1xuICAgIH0gZWxzZSBpZiAoaXNBbGwpIHtcbiAgICAgIGRpc3RzID0gcG9zZXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtkaXN0WCwgZGlzdFldO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQb3NlcyA9IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgICByZXR1cm4gcGx1cyhwb3MsIGRpc3RzW2ldKTtcbiAgICB9KTtcblxuICAgIHZhciBndWlkZVBvc2VzID0gX19zcHJlYWRBcnJheShbXSwgbmV4dFBvc2VzLCB0cnVlKTtcblxuICAgIHN0YXRlLnNuYXBCb3VuZEluZm9zID0gbnVsbDtcbiAgICB2YXIgaXNDaXJjbGUgPSBjbGlwUGF0aC50eXBlID09PSBcImNpcmNsZVwiO1xuICAgIHZhciBpc0VsbGlwc2UgPSBjbGlwUGF0aC50eXBlID09PSBcImVsbGlwc2VcIjtcblxuICAgIGlmIChpc0NpcmNsZSB8fCBpc0VsbGlwc2UpIHtcbiAgICAgIHZhciBndWlkZVJlY3QgPSBnZXRSZWN0KG5leHRQb3Nlcyk7XG4gICAgICB2YXIgcnkgPSBNYXRoLmFicyhndWlkZVJlY3QuYm90dG9tIC0gZ3VpZGVSZWN0LnRvcCk7XG4gICAgICB2YXIgcnggPSBNYXRoLmFicyhpc0VsbGlwc2UgPyBndWlkZVJlY3QucmlnaHQgLSBndWlkZVJlY3QubGVmdCA6IHJ5KTtcbiAgICAgIHZhciBib3R0b20gPSBuZXh0UG9zZXNbMF1bMV0gKyByeTtcbiAgICAgIHZhciBsZWZ0ID0gbmV4dFBvc2VzWzBdWzBdIC0gcng7XG4gICAgICB2YXIgcmlnaHQgPSBuZXh0UG9zZXNbMF1bMF0gKyByeDsgLy8gcmlnaHRcblxuICAgICAgaWYgKGlzQ2lyY2xlKSB7XG4gICAgICAgIGd1aWRlUG9zZXMucHVzaChbcmlnaHQsIGd1aWRlUmVjdC5ib3R0b21dKTtcbiAgICAgICAgZGlzdHMucHVzaChbMSwgMF0pO1xuICAgICAgfSAvLyBib3R0b21cblxuXG4gICAgICBndWlkZVBvc2VzLnB1c2goW2d1aWRlUmVjdC5sZWZ0LCBib3R0b21dKTtcbiAgICAgIGRpc3RzLnB1c2goWzAsIDFdKTsgLy8gbGVmdFxuXG4gICAgICBndWlkZVBvc2VzLnB1c2goW2xlZnQsIGd1aWRlUmVjdC5ib3R0b21dKTtcbiAgICAgIGRpc3RzLnB1c2goWzEsIDBdKTtcbiAgICB9XG5cbiAgICB2YXIgZ3VpZGVsaW5lcyA9IGdldERlZmF1bHRHdWlkZWxpbmVzKChwcm9wcy5jbGlwSG9yaXpvbnRhbEd1aWRlbGluZXMgfHwgW10pLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIGNvbnZlcnRVbml0U2l6ZShcIlwiLmNvbmNhdCh2KSwgaGVpZ2h0KTtcbiAgICB9KSwgKHByb3BzLmNsaXBWZXJ0aWNhbEd1aWRlbGluZXMgfHwgW10pLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIGNvbnZlcnRVbml0U2l6ZShcIlwiLmNvbmNhdCh2KSwgd2lkdGgpO1xuICAgIH0pLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgZ3VpZGVYUG9zZXMgPSBbXTtcbiAgICB2YXIgZ3VpZGVZUG9zZXMgPSBbXTtcblxuICAgIGlmIChpc0NpcmNsZSB8fCBpc0VsbGlwc2UpIHtcbiAgICAgIGd1aWRlWFBvc2VzID0gW2d1aWRlUG9zZXNbNF1bMF0sIGd1aWRlUG9zZXNbMl1bMF1dO1xuICAgICAgZ3VpZGVZUG9zZXMgPSBbZ3VpZGVQb3Nlc1sxXVsxXSwgZ3VpZGVQb3Nlc1szXVsxXV07XG4gICAgfSBlbHNlIGlmIChpc1JlY3QpIHtcbiAgICAgIHZhciByZWN0UG9zZXMgPSBbZ3VpZGVQb3Nlc1swXSwgZ3VpZGVQb3Nlc1syXSwgZ3VpZGVQb3Nlc1s0XSwgZ3VpZGVQb3Nlc1s2XV07XG4gICAgICB2YXIgcmVjdERpc3RzXzEgPSBbZGlzdHNbMF0sIGRpc3RzWzJdLCBkaXN0c1s0XSwgZGlzdHNbNl1dO1xuICAgICAgZ3VpZGVYUG9zZXMgPSByZWN0UG9zZXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgIHJldHVybiByZWN0RGlzdHNfMVtpXVswXTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3NbMF07XG4gICAgICB9KTtcbiAgICAgIGd1aWRlWVBvc2VzID0gcmVjdFBvc2VzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICByZXR1cm4gcmVjdERpc3RzXzFbaV1bMV07XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zWzFdO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGd1aWRlWFBvc2VzID0gZ3VpZGVQb3Nlcy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RzW2ldWzBdO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvc1swXTtcbiAgICAgIH0pO1xuICAgICAgZ3VpZGVZUG9zZXMgPSBndWlkZVBvc2VzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICByZXR1cm4gZGlzdHNbaV1bMV07XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zWzFdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kRGVsdGEgPSBbMCwgMF07XG5cbiAgICB2YXIgX2QgPSBjaGVja1NuYXBCb3VuZHMoZ3VpZGVsaW5lcywgcHJvcHMuY2xpcFRhcmdldEJvdW5kcyAmJiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IHdpZHRoLFxuICAgICAgYm90dG9tOiBoZWlnaHRcbiAgICB9LCBndWlkZVhQb3NlcywgZ3VpZGVZUG9zZXMsIDUpLFxuICAgICAgICBob3Jpem9udGFsU25hcEluZm8gPSBfZC5ob3Jpem9udGFsLFxuICAgICAgICB2ZXJ0aWNhbFNuYXBJbmZvID0gX2QudmVydGljYWw7XG5cbiAgICB2YXIgc25hcE9mZnNldFkgPSBob3Jpem9udGFsU25hcEluZm8ub2Zmc2V0O1xuICAgIHZhciBzbmFwT2Zmc2V0WCA9IHZlcnRpY2FsU25hcEluZm8ub2Zmc2V0O1xuXG4gICAgaWYgKGhvcml6b250YWxTbmFwSW5mby5pc0JvdW5kKSB7XG4gICAgICBib3VuZERlbHRhWzFdICs9IHNuYXBPZmZzZXRZO1xuICAgIH1cblxuICAgIGlmICh2ZXJ0aWNhbFNuYXBJbmZvLmlzQm91bmQpIHtcbiAgICAgIGJvdW5kRGVsdGFbMF0gKz0gc25hcE9mZnNldFg7XG4gICAgfVxuXG4gICAgaWYgKChpc0VsbGlwc2UgfHwgaXNDaXJjbGUpICYmIGRpc3RzWzBdWzBdID09PSAwICYmIGRpc3RzWzBdWzFdID09PSAwKSB7XG4gICAgICB2YXIgZ3VpZGVSZWN0ID0gZ2V0UmVjdChuZXh0UG9zZXMpO1xuICAgICAgdmFyIGN5ID0gZ3VpZGVSZWN0LmJvdHRvbSAtIGd1aWRlUmVjdC50b3A7XG4gICAgICB2YXIgY3ggPSBpc0VsbGlwc2UgPyBndWlkZVJlY3QucmlnaHQgLSBndWlkZVJlY3QubGVmdCA6IGN5O1xuICAgICAgdmFyIGRpc3RTbmFwWCA9IHZlcnRpY2FsU25hcEluZm8uaXNCb3VuZCA/IE1hdGguYWJzKHNuYXBPZmZzZXRYKSA6IHZlcnRpY2FsU25hcEluZm8uc25hcEluZGV4ID09PSAwID8gLXNuYXBPZmZzZXRYIDogc25hcE9mZnNldFg7XG4gICAgICB2YXIgZGlzdFNuYXBZID0gaG9yaXpvbnRhbFNuYXBJbmZvLmlzQm91bmQgPyBNYXRoLmFicyhzbmFwT2Zmc2V0WSkgOiBob3Jpem9udGFsU25hcEluZm8uc25hcEluZGV4ID09PSAwID8gLXNuYXBPZmZzZXRZIDogc25hcE9mZnNldFk7XG4gICAgICBjeCAtPSBkaXN0U25hcFg7XG4gICAgICBjeSAtPSBkaXN0U25hcFk7XG5cbiAgICAgIGlmIChpc0NpcmNsZSkge1xuICAgICAgICBjeSA9IGNoZWNrU25hcEJvdW5kUHJpb3JpdHkodmVydGljYWxTbmFwSW5mbywgaG9yaXpvbnRhbFNuYXBJbmZvKSA+IDAgPyBjeSA6IGN4O1xuICAgICAgICBjeCA9IGN5O1xuICAgICAgfVxuXG4gICAgICB2YXIgY2VudGVyID0gZ3VpZGVQb3Nlc1swXTtcbiAgICAgIGd1aWRlUG9zZXNbMV1bMV0gPSBjZW50ZXJbMV0gLSBjeTtcbiAgICAgIGd1aWRlUG9zZXNbMl1bMF0gPSBjZW50ZXJbMF0gKyBjeDtcbiAgICAgIGd1aWRlUG9zZXNbM11bMV0gPSBjZW50ZXJbMV0gKyBjeTtcbiAgICAgIGd1aWRlUG9zZXNbNF1bMF0gPSBjZW50ZXJbMF0gLSBjeDtcbiAgICB9IGVsc2UgaWYgKGlzUmVjdCAmJiBrZWVwUmF0aW8gJiYgaXNDb250cm9sKSB7XG4gICAgICB2YXIgX2UgPSBnZXRDb250cm9sU2l6ZShjbGlwUG9zZXMpLFxuICAgICAgICAgIHdpZHRoXzEgPSBfZVswXSxcbiAgICAgICAgICBoZWlnaHRfMSA9IF9lWzFdO1xuXG4gICAgICB2YXIgcmF0aW8gPSB3aWR0aF8xICYmIGhlaWdodF8xID8gd2lkdGhfMSAvIGhlaWdodF8xIDogMDtcbiAgICAgIHZhciBjbGlwUG9zZSA9IGNsaXBQb3Nlc1tjbGlwSW5kZXhdO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGNsaXBQb3NlLmRpcmVjdGlvbiB8fCBcIlwiO1xuICAgICAgdmFyIHRvcCA9IGd1aWRlUG9zZXNbMV1bMV07XG4gICAgICB2YXIgYm90dG9tID0gZ3VpZGVQb3Nlc1s1XVsxXTtcbiAgICAgIHZhciBsZWZ0ID0gZ3VpZGVQb3Nlc1s3XVswXTtcbiAgICAgIHZhciByaWdodCA9IGd1aWRlUG9zZXNbM11bMF07XG5cbiAgICAgIGlmIChzbmFwT2Zmc2V0WSA8PSBzbmFwT2Zmc2V0WCkge1xuICAgICAgICBzbmFwT2Zmc2V0WSA9IHNuYXBPZmZzZXRYIC8gcmF0aW87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbmFwT2Zmc2V0WCA9IHNuYXBPZmZzZXRZICogcmF0aW87XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJlY3Rpb24uaW5kZXhPZihcIndcIikgPiAtMSkge1xuICAgICAgICBsZWZ0IC09IHNuYXBPZmZzZXRYO1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24uaW5kZXhPZihcImVcIikgPiAtMSkge1xuICAgICAgICByaWdodCAtPSBzbmFwT2Zmc2V0WDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgKz0gc25hcE9mZnNldFggLyAyO1xuICAgICAgICByaWdodCAtPSBzbmFwT2Zmc2V0WCAvIDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJlY3Rpb24uaW5kZXhPZihcIm5cIikgPiAtMSkge1xuICAgICAgICB0b3AgLT0gc25hcE9mZnNldFk7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbi5pbmRleE9mKFwic1wiKSA+IC0xKSB7XG4gICAgICAgIGJvdHRvbSAtPSBzbmFwT2Zmc2V0WTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvcCArPSBzbmFwT2Zmc2V0WSAvIDI7XG4gICAgICAgIGJvdHRvbSAtPSBzbmFwT2Zmc2V0WSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXh0Q29udHJvbFBvc2VzXzIgPSBnZXRSZWN0UG9zZXModG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KTtcbiAgICAgIGd1aWRlUG9zZXMuZm9yRWFjaChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgICAgIHZhciBfYTtcblxuICAgICAgICBfYSA9IG5leHRDb250cm9sUG9zZXNfMltpXS5wb3MsIHBvc1swXSA9IF9hWzBdLCBwb3NbMV0gPSBfYVsxXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBndWlkZVBvc2VzLmZvckVhY2goZnVuY3Rpb24gKHBvcywgaikge1xuICAgICAgICB2YXIgZGlzdCA9IGRpc3RzW2pdO1xuXG4gICAgICAgIGlmIChkaXN0WzBdKSB7XG4gICAgICAgICAgcG9zWzBdIC09IHNuYXBPZmZzZXRYO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpc3RbMV0pIHtcbiAgICAgICAgICBwb3NbMV0gLT0gc25hcE9mZnNldFk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2xpcFN0eWxlcyA9IGdldENsaXBTdHlsZXMobW92ZWFibGUsIGNsaXBQYXRoLCBuZXh0UG9zZXMpO1xuICAgIHZhciBjbGlwU3R5bGUgPSBcIlwiLmNvbmNhdChjbGlwVHlwZSwgXCIoXCIpLmNvbmNhdChuZXh0Q2xpcFN0eWxlcy5qb2luKHNwbGl0dGVyKSwgXCIpXCIpO1xuICAgIHN0YXRlLmNsaXBQYXRoU3RhdGUgPSBjbGlwU3R5bGU7XG5cbiAgICBpZiAoaXNDaXJjbGUgfHwgaXNFbGxpcHNlKSB7XG4gICAgICBndWlkZVhQb3NlcyA9IFtndWlkZVBvc2VzWzRdWzBdLCBndWlkZVBvc2VzWzJdWzBdXTtcbiAgICAgIGd1aWRlWVBvc2VzID0gW2d1aWRlUG9zZXNbMV1bMV0sIGd1aWRlUG9zZXNbM11bMV1dO1xuICAgIH0gZWxzZSBpZiAoaXNSZWN0KSB7XG4gICAgICB2YXIgcmVjdFBvc2VzID0gW2d1aWRlUG9zZXNbMF0sIGd1aWRlUG9zZXNbMl0sIGd1aWRlUG9zZXNbNF0sIGd1aWRlUG9zZXNbNl1dO1xuICAgICAgZ3VpZGVYUG9zZXMgPSByZWN0UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvc1swXTtcbiAgICAgIH0pO1xuICAgICAgZ3VpZGVZUG9zZXMgPSByZWN0UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvc1sxXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBndWlkZVhQb3NlcyA9IGd1aWRlUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvc1swXTtcbiAgICAgIH0pO1xuICAgICAgZ3VpZGVZUG9zZXMgPSBndWlkZVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3NbMV07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0ZS5zbmFwQm91bmRJbmZvcyA9IGNoZWNrU25hcEJvdW5kcyhndWlkZWxpbmVzLCBwcm9wcy5jbGlwVGFyZ2V0Qm91bmRzICYmIHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogd2lkdGgsXG4gICAgICBib3R0b206IGhlaWdodFxuICAgIH0sIGd1aWRlWFBvc2VzLCBndWlkZVlQb3NlcywgMSk7XG5cbiAgICBpZiAob3JpZ2luYWxEcmFnZ2FibGUpIHtcbiAgICAgIHZhciBpczNkID0gc3RhdGUuaXMzZCxcbiAgICAgICAgICBhbGxNYXRyaXggPSBzdGF0ZS5hbGxNYXRyaXg7XG4gICAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgICAgIHZhciBkcmFnRGlzdCA9IGJvdW5kRGVsdGE7XG5cbiAgICAgIGlmIChpc0RyYWdUYXJnZXQpIHtcbiAgICAgICAgZHJhZ0Rpc3QgPSBbZmlyc3REaXN0WzBdICsgYm91bmREZWx0YVswXSAtIG9yaWdpbmFsRGlzdFswXSwgZmlyc3REaXN0WzFdICsgYm91bmREZWx0YVsxXSAtIG9yaWdpbmFsRGlzdFsxXV07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpbmFsRHJhZ2dhYmxlLmRlbHRhT2Zmc2V0ID0gbXVsdGlwbHkoYWxsTWF0cml4LCBbZHJhZ0Rpc3RbMF0sIGRyYWdEaXN0WzFdLCAwLCAwXSwgbik7XG4gICAgfVxuXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQ2xpcFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBjbGlwRXZlbnRUeXBlOiBcImNoYW5nZWRcIixcbiAgICAgIGNsaXBUeXBlOiBjbGlwVHlwZSxcbiAgICAgIHBvc2VzOiBuZXh0UG9zZXMsXG4gICAgICBjbGlwU3R5bGU6IGNsaXBTdHlsZSxcbiAgICAgIGNsaXBTdHlsZXM6IG5leHRDbGlwU3R5bGVzLFxuICAgICAgZGlzdFg6IGRpc3RYLFxuICAgICAgZGlzdFk6IGRpc3RZXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XG4gICAgdmFyIGlzRHJhZyA9IGUuaXNEcmFnLFxuICAgICAgICBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzRG91YmxlID0gZS5pc0RvdWJsZTtcbiAgICB2YXIgaXNMaW5lID0gZGF0YXMuaXNMaW5lLFxuICAgICAgICBpc0NsaXBTdGFydCA9IGRhdGFzLmlzQ2xpcFN0YXJ0LFxuICAgICAgICBpc0NvbnRyb2wgPSBkYXRhcy5pc0NvbnRyb2w7XG5cbiAgICBpZiAoIWlzQ2xpcFN0YXJ0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQ2xpcEVuZFwiLCBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSkpO1xuXG4gICAgaWYgKGlzRG91YmxlKSB7XG4gICAgICBpZiAoaXNDb250cm9sKSB7XG4gICAgICAgIHJlbW92ZUNsaXBQYXRoKG1vdmVhYmxlLCBlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMaW5lKSB7XG4gICAgICAgIC8vIGFkZFxuICAgICAgICBhZGRDbGlwUGF0aChtb3ZlYWJsZSwgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRG91YmxlIHx8IGlzRHJhZztcbiAgfSxcbiAgdW5zZXQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIG1vdmVhYmxlLnN0YXRlLmNsaXBQYXRoU3RhdGUgPSBcIlwiO1xuICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBCb3VuZEluZm9zID0gbnVsbDtcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciB0byBjbGlwIHRoZSB0YXJnZXQuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwcGFibGVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcbiAqICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxuICogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiY2xpcFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xuICogICAgIGlmIChlLmNsaXBUeXBlID09PSBcInJlY3RcIikge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcFBhdGggPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9XG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqICBJZiBjbGlwcGF0aCBpcyBub3Qgc2V0LCB0aGUgZGVmYXVsdCB2YWx1ZSBjYW4gYmUgc2V0LiAoZGVmYXVsdENsaXBQYXRoIDwgc3R5bGUgPCBjdXN0b21DbGlwUGF0aCA8IGRyYWdnaW5nIGNsaXBQYXRoKVxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2RlZmF1bHRDbGlwUGF0aFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogJSBDYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBhYnNvbHV0ZSBweCAoYHJlY3RgIG5vdCBwb3NzaWJsZSkgKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBSZWxhdGl2ZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogWW91IGNhbiBmb3JjZSB0aGUgY3VzdG9tIGNsaXBQYXRoLiAoZGVmYXVsdENsaXBQYXRoIDwgc3R5bGUgPCBjdXN0b21DbGlwUGF0aCA8IGRyYWdnaW5nIGNsaXBQYXRoKVxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2N1c3RvbUNsaXBQYXRoXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBjbGlwcGFibGU6IHRydWUsXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXG4gKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pLm9uKFwiY2xpcFwiLCBlID0+IHtcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfVxuICogfSkub24oXCJjbGlwRW5kXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIGRyYWdnaW5nIHRoZSB0YXJnZXQsIHRoZSBjbGlwIGFsc28gbW92ZXMuIChkZWZhdWx0OiB0cnVlKVxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2RyYWdXaXRoQ2xpcFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogWW91IGNhbiBkcmFnIHRoZSBjbGlwIGJ5IHNldHRpbmcgY2xpcEFyZWEuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwQXJlYVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuKiBXaGV0aGVyIHRoZSBjbGlwIGlzIGJvdW5kIHRvIHRoZSB0YXJnZXQuIChkZWZhdWx0OiBmYWxzZSlcbiogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBUYXJnZXRCb3VuZHNcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICBjbGlwcGFibGU6IHRydWUsXG4qICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiogICAgIGNsaXBUYXJnZXRCb3VuZHM6IHRydWUsXG4qIH0pO1xuKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcbiogICAgIGNvbnNvbGUubG9nKGUpO1xuKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4qICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcbiogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XG4qICAgICB9IGVsc2Uge1xuKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XG4qICAgICB9XG4qIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiogICAgIGNvbnNvbGUubG9nKGUpO1xuKiB9KTtcbiovXG5cbi8qKlxuKiBBZGQgY2xpcCBndWlkZWxpbmVzIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24uIChkZWZhdWx0OiBbXSlcbiogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBWZXJ0aWNhbEd1aWRlbGluZXNcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICBjbGlwcGFibGU6IHRydWUsXG4qICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiogICAgIGNsaXBWZXJ0aWNhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXG4qICAgICBjbGlwSG9yaXpvbnRhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXG4qICAgICBjbGlwU25hcFRocmVzaG9sZDogNSxcbiogfSk7XG4qL1xuXG4vKipcbiogQWRkIGNsaXAgZ3VpZGVsaW5lcyBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24uIChkZWZhdWx0OiBbXSlcbiogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBIb3Jpem9udGFsR3VpZGVsaW5lc1xuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIGNsaXBwYWJsZTogdHJ1ZSxcbiogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXG4qICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxuKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxuKiAgICAgY2xpcFZlcnRpY2FsR3VpZGVsaW5lczogWzAsIDEwMCwgMjAwXSxcbiogICAgIGNsaXBIb3Jpem9udGFsR3VpZGVsaW5lczogWzAsIDEwMCwgMjAwXSxcbiogICAgIGNsaXBTbmFwVGhyZXNob2xkOiA1LFxuKiB9KTtcbiovXG5cbi8qKlxuKiBpc3RhbmNlIHZhbHVlIHRoYXQgY2FuIHNuYXAgdG8gY2xpcCBndWlkZWxpbmVzLiAoZGVmYXVsdDogNSlcbiogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBTbmFwVGhyZXNob2xkXG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXG4qICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcbiogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4qICAgICBjbGlwQXJlYTogZmFsc2UsXG4qICAgICBkcmFnV2l0aENsaXA6IHRydWUsXG4qICAgICBjbGlwVmVydGljYWxHdWlkZWxpbmVzOiBbMCwgMTAwLCAyMDBdLFxuKiAgICAgY2xpcEhvcml6b250YWxHdWlkZWxpbmVzOiBbMCwgMTAwLCAyMDBdLFxuKiAgICAgY2xpcFNuYXBUaHJlc2hvbGQ6IDUsXG4qIH0pO1xuKi9cblxuLyoqXG4gKiBXaGVuIGRyYWcgc3RhcnQgdGhlIGNsaXAgYXJlYSBvciBjb250cm9scywgdGhlIGBjbGlwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5DbGlwcGFibGVcbiAqIEBldmVudCBjbGlwU3RhcnRcbiAqIEBwYXJhbSB7TW92ZWFibGUuQ2xpcHBhYmxlLk9uQ2xpcFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgY2xpcFN0YXJ0YCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiBkcmFnIHRoZSBjbGlwIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgY2xpcGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkNsaXBwYWJsZVxuICogQGV2ZW50IGNsaXBcbiAqIEBwYXJhbSB7TW92ZWFibGUuQ2xpcHBhYmxlLk9uQ2xpcH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaXBgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBjbGlwcGFibGU6IHRydWUsXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXG4gKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pLm9uKFwiY2xpcFwiLCBlID0+IHtcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfVxuICogfSkub24oXCJjbGlwRW5kXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIGRyYWcgZW5kIHRoZSBjbGlwIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgY2xpcEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkNsaXBwYWJsZVxuICogQGV2ZW50IGNsaXBFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuQ2xpcHBhYmxlLk9uQ2xpcEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaXBFbmRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBjbGlwcGFibGU6IHRydWUsXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXG4gKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pLm9uKFwiY2xpcFwiLCBlID0+IHtcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfVxuICogfSkub24oXCJjbGlwRW5kXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIE9yaWdpbkRyYWdnYWJsZVxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciB0byBkcmFnIG9yaWdpbiAoZGVmYXVsdDogZmFsc2UpXG4gKi9cblxudmFyIE9yaWdpbkRyYWdnYWJsZSA9IHtcbiAgbmFtZTogXCJvcmlnaW5EcmFnZ2FibGVcIixcbiAgcHJvcHM6IHtcbiAgICBvcmlnaW5EcmFnZ2FibGU6IEJvb2xlYW4sXG4gICAgb3JpZ2luUmVsYXRpdmU6IEJvb2xlYW5cbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25EcmFnT3JpZ2luU3RhcnQ6IFwiZHJhZ09yaWdpblN0YXJ0XCIsXG4gICAgb25EcmFnT3JpZ2luOiBcImRyYWdPcmlnaW5cIixcbiAgICBvbkRyYWdPcmlnaW5FbmQ6IFwiZHJhZ09yaWdpbkVuZFwiXG4gIH0sXG4gIGNzczogW1wiOmhvc3RbZGF0YS1hYmxlLW9yaWdpbmRyYWdnYWJsZV0gLmNvbnRyb2wub3JpZ2luIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG87XFxufVwiXSxcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChfLCBlKSB7XG4gICAgaWYgKGUuaXNSZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gZS5yZXF1ZXN0QWJsZSA9PT0gXCJvcmlnaW5EcmFnZ2FibGVcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzQ2xhc3MoZS5pbnB1dEV2ZW50LnRhcmdldCwgcHJlZml4KFwib3JpZ2luXCIpKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcbiAgICBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBkcmFnU3RhcnQ6IERyYWdnYWJsZS5kcmFnU3RhcnQobW92ZWFibGUsIG5ldyBDdXN0b21HZXN0bygpLmRyYWdTdGFydChbMCwgMF0sIGUpKVxuICAgIH0pO1xuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnT3JpZ2luU3RhcnRcIiwgcGFyYW1zKTtcbiAgICBkYXRhcy5zdGFydE9yaWdpbiA9IG1vdmVhYmxlLnN0YXRlLnRyYW5zZm9ybU9yaWdpbjtcbiAgICBkYXRhcy5zdGFydFRhcmdldE9yaWdpbiA9IG1vdmVhYmxlLnN0YXRlLnRhcmdldE9yaWdpbjtcbiAgICBkYXRhcy5wcmV2T3JpZ2luID0gWzAsIDBdO1xuICAgIGRhdGFzLmlzRHJhZ09yaWdpbiA9IHRydWU7XG5cbiAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgZGF0YXMuaXNEcmFnT3JpZ2luID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzUGluY2ggPSBlLmlzUGluY2gsXG4gICAgICAgIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0O1xuXG4gICAgaWYgKCFkYXRhcy5pc0RyYWdPcmlnaW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSBnZXREcmFnRGlzdChlKSxcbiAgICAgICAgZGlzdFggPSBfYVswXSxcbiAgICAgICAgZGlzdFkgPSBfYVsxXTtcblxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHZhciB3aWR0aCA9IHN0YXRlLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQsXG4gICAgICAgIG9mZnNldE1hdHJpeCA9IHN0YXRlLm9mZnNldE1hdHJpeCxcbiAgICAgICAgdGFyZ2V0TWF0cml4ID0gc3RhdGUudGFyZ2V0TWF0cml4LFxuICAgICAgICBpczNkID0gc3RhdGUuaXMzZDtcbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5wcm9wcy5vcmlnaW5SZWxhdGl2ZSxcbiAgICAgICAgb3JpZ2luUmVsYXRpdmUgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICAgIHZhciBkaXN0ID0gW2Rpc3RYLCBkaXN0WV07XG5cbiAgICBpZiAoaXNSZXF1ZXN0KSB7XG4gICAgICB2YXIgZGlzdE9yaWdpbiA9IGUuZGlzdE9yaWdpbjtcblxuICAgICAgaWYgKGRpc3RPcmlnaW5bMF0gfHwgZGlzdE9yaWdpblsxXSkge1xuICAgICAgICBkaXN0ID0gZGlzdE9yaWdpbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3JpZ2luID0gcGx1cyhkYXRhcy5zdGFydE9yaWdpbiwgZGlzdCk7XG4gICAgdmFyIHRhcmdldE9yaWdpbiA9IHBsdXMoZGF0YXMuc3RhcnRUYXJnZXRPcmlnaW4sIGRpc3QpO1xuICAgIHZhciBkZWx0YSA9IG1pbnVzKGRpc3QsIGRhdGFzLnByZXZPcmlnaW4pO1xuICAgIHZhciBuZXh0TWF0cml4ID0gZ2V0TmV4dE1hdHJpeChvZmZzZXRNYXRyaXgsIHRhcmdldE1hdHJpeCwgb3JpZ2luLCBuKTtcbiAgICB2YXIgcmVjdCA9IG1vdmVhYmxlLmdldFJlY3QoKTtcbiAgICB2YXIgbmV4dFJlY3QgPSBnZXRSZWN0KGNhbGN1bGF0ZVBvc2VzKG5leHRNYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pKTtcbiAgICB2YXIgZHJhZ0RlbHRhID0gW3JlY3QubGVmdCAtIG5leHRSZWN0LmxlZnQsIHJlY3QudG9wIC0gbmV4dFJlY3QudG9wXTtcbiAgICBkYXRhcy5wcmV2T3JpZ2luID0gZGlzdDtcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gW2NvbnZlcnRDU1NTaXplKHRhcmdldE9yaWdpblswXSwgd2lkdGgsIG9yaWdpblJlbGF0aXZlKSwgY29udmVydENTU1NpemUodGFyZ2V0T3JpZ2luWzFdLCBoZWlnaHQsIG9yaWdpblJlbGF0aXZlKV0uam9pbihcIiBcIik7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgICBkaXN0OiBkaXN0LFxuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgdHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW4sXG4gICAgICBkcmFnOiBEcmFnZ2FibGUuZHJhZyhtb3ZlYWJsZSwgc2V0Q3VzdG9tRHJhZyhlLCBtb3ZlYWJsZS5zdGF0ZSwgZHJhZ0RlbHRhLCAhIWlzUGluY2gsIGZhbHNlKSlcbiAgICB9KTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnT3JpZ2luXCIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzRHJhZ09yaWdpbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdPcmlnaW5FbmRcIiwgZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2xDb25kaXRpb24obW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIGUpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIGUpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBtb3ZlYWJsZS50cmFuc2Zvcm1PcmlnaW4gPSBwYXJhbXMudHJhbnNmb3JtT3JpZ2luO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAqIEBtZXRob2QgTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlI3JlcXVlc3RcbiAgKiBAcGFyYW0ge29iamVjdH0gZSAtIHRoZSBPcmlnaW5EcmFnZ2FibGUncyByZXF1ZXN0IHBhcmFtZXRlclxuICAqIEBwYXJhbSB7bnVtYmVyfSBbZS54XSAtIHggcG9zaXRpb25cbiAgKiBAcGFyYW0ge251bWJlcn0gW2UueV0gLSB5IHBvc2l0aW9uXG4gICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhWF0gLSB4IG51bWJlciB0byBtb3ZlXG4gICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhWV0gLSB5IG51bWJlciB0byBtb3ZlXG4gICogQHBhcmFtIHthcnJheX0gW2UuZGVsdGFPcmlnaW5dIC0gbGVmdCwgdG9wIG51bWJlciB0byBtb3ZlIHRyYW5zZm9ybS1vcmlnaW5cbiAgKiBAcGFyYW0ge2FycmF5fSBbZS5vcmlnaW5dIC0gdHJhbnNmb3JtLW9yaWdpbiBwb3NpdGlvblxuICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5pc0luc3RhbnRdIC0gV2hldGhlciB0byBleGVjdXRlIHRoZSByZXF1ZXN0IGluc3RhbnRseVxuICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXG4gICogQGV4YW1wbGVcbiAgICogLy8gSW5zdGFudGx5IFJlcXVlc3QgKHJlcXVlc3RTdGFydCAtIHJlcXVlc3QgLSByZXF1ZXN0RW5kKVxuICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxuICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0sIHRydWUpO1xuICAqIC8vIFVzZSBBYnNvbHV0ZSBWYWx1ZVxuICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9LCB0cnVlKTtcbiAgKiAvLyBVc2UgVHJhbnNmb3JtIFZhbHVlXG4gICogbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiLCB7IGRlbHRhT3JpZ2luOiBbMTAsIDBdIH0sIHRydWUpO1xuICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyBvcmlnaW46IFsxMDAsIDBdIH0sIHRydWUpO1xuICAqIC8vIHJlcXVlc3RTdGFydFxuICAqIGNvbnN0IHJlcXVlc3RlciA9IG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIik7XG4gICpcbiAgKiAvLyByZXF1ZXN0XG4gICogLy8gVXNlIFJlbGF0aXZlIFZhbHVlXG4gICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xuICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcbiAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICogLy8gVXNlIEFic29sdXRlIFZhbHVlXG4gICogbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiLCB7IHg6IDIwMCwgeTogMTAwIH0pO1xuICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyB4OiAyMjAsIHk6IDEwMCB9KTtcbiAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgeDogMjQwLCB5OiAxMDAgfSk7XG4gICpcbiAgKiAvLyByZXF1ZXN0RW5kXG4gICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgKi9cbiAgcmVxdWVzdDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdmFyIGRhdGFzID0ge307XG4gICAgdmFyIHJlY3QgPSBtb3ZlYWJsZS5nZXRSZWN0KCk7XG4gICAgdmFyIGRpc3RYID0gMDtcbiAgICB2YXIgZGlzdFkgPSAwO1xuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSByZWN0LnRyYW5zZm9ybU9yaWdpbjtcbiAgICB2YXIgZGlzdE9yaWdpbiA9IFswLCAwXTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb250cm9sOiB0cnVlLFxuICAgICAgcmVxdWVzdFN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKFwiZGVsdGFPcmlnaW5cIiBpbiBlKSB7XG4gICAgICAgICAgZGlzdE9yaWdpblswXSArPSBlLmRlbHRhT3JpZ2luWzBdO1xuICAgICAgICAgIGRpc3RPcmlnaW5bMV0gKz0gZS5kZWx0YU9yaWdpblsxXTtcbiAgICAgICAgfSBlbHNlIGlmIChcIm9yaWdpblwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0T3JpZ2luWzBdID0gZS5vcmlnaW5bMF0gLSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgICAgICAgZGlzdE9yaWdpblsxXSA9IGUub3JpZ2luWzFdIC0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChcInhcIiBpbiBlKSB7XG4gICAgICAgICAgICBkaXN0WCA9IGUueCAtIHJlY3QubGVmdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiZGVsdGFYXCIgaW4gZSkge1xuICAgICAgICAgICAgZGlzdFggKz0gZS5kZWx0YVg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFwieVwiIGluIGUpIHtcbiAgICAgICAgICAgIGRpc3RZID0gZS55IC0gcmVjdC50b3A7XG4gICAgICAgICAgfSBlbHNlIGlmIChcImRlbHRhWVwiIGluIGUpIHtcbiAgICAgICAgICAgIGRpc3RZICs9IGUuZGVsdGFZO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgICAgIGRpc3RYOiBkaXN0WCxcbiAgICAgICAgICBkaXN0WTogZGlzdFksXG4gICAgICAgICAgZGlzdE9yaWdpbjogZGlzdE9yaWdpblxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgaXNEcmFnOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciB0byBkcmFnIG9yaWdpbiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGUjb3JpZ2luRHJhZ2dhYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBvcmlnaW5EcmFnZ2FibGU6IHRydWUsXG4gKiB9KTtcbiAqIGxldCB0cmFuc2xhdGUgPSBbMCwgMF07XG4gKiBtb3ZlYWJsZS5vbihcImRyYWdPcmlnaW5TdGFydFwiLCBlID0+IHtcbiAqICAgICBlLmRyYWdTdGFydCAmJiBlLmRyYWdTdGFydC5zZXQodHJhbnNsYXRlKTtcbiAqIH0pLm9uKFwiZHJhZ09yaWdpblwiLCBlID0+IHtcbiAqICAgICB0cmFuc2xhdGUgPSBlLmRyYWcuYmVmb3JlVHJhbnNsYXRlO1xuICogICAgIGUudGFyZ2V0LnN0eWxlLmNzc1RleHRcbiAqICAgICAgICAgPSBgdHJhbnNmb3JtLW9yaWdpbjogJHtlLnRyYW5zZm9ybU9yaWdpbn07YFxuICogICAgICAgICArIGB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVswXX1weCwgJHt0cmFuc2xhdGVbMV19cHgpYDtcbiAqIH0pLm9uKFwiZHJhZ09yaWdpbkVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogJSBDYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBhYnNvbHV0ZSBweCAoZGVmYXVsdDogdHJ1ZSlcbiAqIEBuYW1lIE1vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZSNvcmlnaW5SZWxhdGl2ZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgb3JpZ2luRHJhZ2dhYmxlOiB0cnVlLFxuICogICAgIG9yaWdpblJlbGF0aXZlOiBmYWxzZSxcbiAqIH0pO1xuICogbW92ZWFibGUub3JpZ2luUmVsYXRpdmUgPSB0cnVlO1xuICovXG5cbi8qKlxuKiBXaGVuIGRyYWcgc3RhcnQgdGhlIG9yaWdpbiwgdGhlIGBkcmFnT3JpZ2luU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cbiogQG1lbWJlcm9mIE1vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZVxuKiBAZXZlbnQgZHJhZ09yaWdpblN0YXJ0XG4qIEBwYXJhbSB7TW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlLk9uRHJhZ09yaWdpblN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgZHJhZ09yaWdpblN0YXJ0YCBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIG9yaWdpbkRyYWdnYWJsZTogdHJ1ZSxcbiogfSk7XG4qIGxldCB0cmFuc2xhdGUgPSBbMCwgMF07XG4qIG1vdmVhYmxlLm9uKFwiZHJhZ09yaWdpblN0YXJ0XCIsIGUgPT4ge1xuKiAgICAgZS5kcmFnU3RhcnQgJiYgZS5kcmFnU3RhcnQuc2V0KHRyYW5zbGF0ZSk7XG4qIH0pLm9uKFwiZHJhZ09yaWdpblwiLCBlID0+IHtcbiogICAgIHRyYW5zbGF0ZSA9IGUuZHJhZy5iZWZvcmVUcmFuc2xhdGU7XG4qICAgICBlLnRhcmdldC5zdHlsZS5jc3NUZXh0XG4qICAgICAgICAgPSBgdHJhbnNmb3JtLW9yaWdpbjogJHtlLnRyYW5zZm9ybU9yaWdpbn07YFxuKiAgICAgICAgICsgYHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7dHJhbnNsYXRlWzBdfXB4LCAke3RyYW5zbGF0ZVsxXX1weClgO1xuKiB9KS5vbihcImRyYWdPcmlnaW5FbmRcIiwgZSA9PiB7XG4qICAgICBjb25zb2xlLmxvZyhlKTtcbiogfSk7XG4qL1xuXG4vKipcbiogV2hlbiBkcmFnIHRoZSBvcmlnaW4sIHRoZSBgZHJhZ09yaWdpbmAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlXG4qIEBldmVudCBkcmFnT3JpZ2luXG4qIEBwYXJhbSB7TW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlLk9uRHJhZ09yaWdpbn0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGRyYWdPcmlnaW5gIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgb3JpZ2luRHJhZ2dhYmxlOiB0cnVlLFxuKiB9KTtcbiogbGV0IHRyYW5zbGF0ZSA9IFswLCAwXTtcbiogbW92ZWFibGUub24oXCJkcmFnT3JpZ2luU3RhcnRcIiwgZSA9PiB7XG4qICAgICBlLmRyYWdTdGFydCAmJiBlLmRyYWdTdGFydC5zZXQodHJhbnNsYXRlKTtcbiogfSkub24oXCJkcmFnT3JpZ2luXCIsIGUgPT4ge1xuKiAgICAgdHJhbnNsYXRlID0gZS5kcmFnLmJlZm9yZVRyYW5zbGF0ZTtcbiogICAgIGUudGFyZ2V0LnN0eWxlLmNzc1RleHRcbiogICAgICAgICA9IGB0cmFuc2Zvcm0tb3JpZ2luOiAke2UudHJhbnNmb3JtT3JpZ2lufTtgXG4qICAgICAgICAgKyBgdHJhbnNmb3JtOiB0cmFuc2xhdGUoJHt0cmFuc2xhdGVbMF19cHgsICR7dHJhbnNsYXRlWzFdfXB4KWA7XG4qIH0pLm9uKFwiZHJhZ09yaWdpbkVuZFwiLCBlID0+IHtcbiogICAgIGNvbnNvbGUubG9nKGUpO1xuKiB9KTtcbiovXG5cbi8qKlxuKiBXaGVuIGRyYWcgZW5kIHRoZSBvcmlnaW4sIHRoZSBgZHJhZ09yaWdpbkVuZGAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlXG4qIEBldmVudCBkcmFnT3JpZ2luRW5kXG4qIEBwYXJhbSB7TW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlLk9uRHJhZ09yaWdpbkVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGRyYWdPcmlnaW5FbmRgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgb3JpZ2luRHJhZ2dhYmxlOiB0cnVlLFxuKiB9KTtcbiogbGV0IHRyYW5zbGF0ZSA9IFswLCAwXTtcbiogbW92ZWFibGUub24oXCJkcmFnT3JpZ2luU3RhcnRcIiwgZSA9PiB7XG4qICAgICBlLmRyYWdTdGFydCAmJiBlLmRyYWdTdGFydC5zZXQodHJhbnNsYXRlKTtcbiogfSkub24oXCJkcmFnT3JpZ2luXCIsIGUgPT4ge1xuKiAgICAgdHJhbnNsYXRlID0gZS5kcmFnLmJlZm9yZVRyYW5zbGF0ZTtcbiogICAgIGUudGFyZ2V0LnN0eWxlLmNzc1RleHRcbiogICAgICAgICA9IGB0cmFuc2Zvcm0tb3JpZ2luOiAke2UudHJhbnNmb3JtT3JpZ2lufTtgXG4qICAgICAgICAgKyBgdHJhbnNmb3JtOiB0cmFuc2xhdGUoJHt0cmFuc2xhdGVbMF19cHgsICR7dHJhbnNsYXRlWzFdfXB4KWA7XG4qIH0pLm9uKFwiZHJhZ09yaWdpbkVuZFwiLCBlID0+IHtcbiogICAgIGNvbnNvbGUubG9nKGUpO1xuKiB9KTtcbiovXG5cbmZ1bmN0aW9uIGFkZEJvcmRlclJhZGl1cyhjb250cm9sUG9zZXMsIHBvc2VzLCBsaW5lSW5kZXgsIGRpc3RYLCBkaXN0WSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgX2EgPSBzcGxpdFJhZGl1c1Bvc2VzKGNvbnRyb2xQb3NlcyksXG4gICAgICBob3Jpem9udGFscyA9IF9hLmhvcml6b250YWxzLFxuICAgICAgdmVydGljYWxzID0gX2EudmVydGljYWxzO1xuXG4gIHZhciBob3Jpem9udGFsc0xlbmd0aCA9IGhvcml6b250YWxzLmxlbmd0aDtcbiAgdmFyIHZlcnRpY2Fsc0xlbmd0aCA9IHZlcnRpY2Fscy5sZW5ndGg7IC8vIGxpbmVJbmRleFxuICAvLyAwIHRvcFxuICAvLyAxIHJpZ2h0XG4gIC8vIDIgbGVmdFxuICAvLyAzIGJvdHRvbVxuICAvLyAwIHRvcCAtIGxlZnRcbiAgLy8gMSB0b3AgLSByaWdodFxuICAvLyAyIGJvdHRvbSAtIHJpZ2h0XG4gIC8vIDMgYm90dG9tIC0gbGVmdFxuICAvLyAwIGxlZnQgLSB0b3BcbiAgLy8gMSByaWdodCAtIHRvcFxuICAvLyAyIHJpZ2h0IC0gYm90dG9tXG4gIC8vIDMgbGVmdCAtIGJvdHRvbVxuXG4gIHZhciBob3Jpem9udGFsSW5kZXggPSAtMTtcbiAgdmFyIHZlcnRpY2FsSW5kZXggPSAtMTtcblxuICBpZiAobGluZUluZGV4ID09PSAwKSB7XG4gICAgaWYgKGhvcml6b250YWxzTGVuZ3RoID09PSAwKSB7XG4gICAgICBob3Jpem9udGFsSW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAoaG9yaXpvbnRhbHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGhvcml6b250YWxJbmRleCA9IDE7XG4gICAgfVxuICB9IGVsc2UgaWYgKGxpbmVJbmRleCA9PT0gMykge1xuICAgIGlmIChob3Jpem9udGFsc0xlbmd0aCA8PSAyKSB7XG4gICAgICBob3Jpem9udGFsSW5kZXggPSAyO1xuICAgIH0gZWxzZSBpZiAoaG9yaXpvbnRhbHNMZW5ndGggPD0gMykge1xuICAgICAgaG9yaXpvbnRhbEluZGV4ID0gMztcbiAgICB9XG4gIH1cblxuICBpZiAobGluZUluZGV4ID09PSAyKSB7XG4gICAgaWYgKHZlcnRpY2Fsc0xlbmd0aCA9PT0gMCkge1xuICAgICAgdmVydGljYWxJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmICh2ZXJ0aWNhbHNMZW5ndGggPCA0KSB7XG4gICAgICB2ZXJ0aWNhbEluZGV4ID0gMztcbiAgICB9XG4gIH0gZWxzZSBpZiAobGluZUluZGV4ID09PSAxKSB7XG4gICAgaWYgKHZlcnRpY2Fsc0xlbmd0aCA8PSAxKSB7XG4gICAgICB2ZXJ0aWNhbEluZGV4ID0gMTtcbiAgICB9IGVsc2UgaWYgKHZlcnRpY2Fsc0xlbmd0aCA8PSAyKSB7XG4gICAgICB2ZXJ0aWNhbEluZGV4ID0gMjtcbiAgICB9XG4gIH1cblxuICBhZGRSYWRpdXNQb3MoY29udHJvbFBvc2VzLCBwb3NlcywgMCwgaG9yaXpvbnRhbEluZGV4LCB2ZXJ0aWNhbEluZGV4LCBkaXN0WCwgZGlzdFksIHdpZHRoLCBoZWlnaHQpO1xufVxuXG5mdW5jdGlvbiBnZXRCb3JkZXJSYWRpdXModGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBtaW5Db3VudHMsIHN0YXRlKSB7XG4gIGlmIChtaW5Db3VudHMgPT09IHZvaWQgMCkge1xuICAgIG1pbkNvdW50cyA9IFswLCAwXTtcbiAgfVxuXG4gIHZhciBib3JkZXJSYWRpdXM7XG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBpZiAoIXN0YXRlKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgIGJvcmRlclJhZGl1cyA9IHN0eWxlICYmIHN0eWxlLmJvcmRlclJhZGl1cyB8fCBcIlwiO1xuICB9IGVsc2Uge1xuICAgIGJvcmRlclJhZGl1cyA9IHN0YXRlO1xuICB9XG5cbiAgaWYgKCFib3JkZXJSYWRpdXMgfHwgIXN0YXRlICYmIGJvcmRlclJhZGl1cyA9PT0gXCIwcHhcIikge1xuICAgIHZhbHVlcyA9IFtdO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlcyA9IHNwbGl0U3BhY2UoYm9yZGVyUmFkaXVzKTtcbiAgfVxuXG4gIHJldHVybiBnZXRSYWRpdXNWYWx1ZXModmFsdWVzLCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCBtaW5Db3VudHMpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyUm91bmRFdmVudChtb3ZlYWJsZSwgZSwgZGlzdCwgZGVsdGEsIGNvbnRyb2xQb3NlcywgbmV4dFBvc2VzKSB7XG4gIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICB2YXIgd2lkdGggPSBzdGF0ZS53aWR0aCxcbiAgICAgIGhlaWdodCA9IHN0YXRlLmhlaWdodDtcblxuICB2YXIgX2EgPSBnZXRSYWRpdXNTdHlsZXMobmV4dFBvc2VzLCBjb250cm9sUG9zZXMsIG1vdmVhYmxlLnByb3BzLnJvdW5kUmVsYXRpdmUsIHdpZHRoLCBoZWlnaHQpLFxuICAgICAgcmF3cyA9IF9hLnJhd3MsXG4gICAgICBzdHlsZXMgPSBfYS5zdHlsZXM7XG5cbiAgdmFyIF9iID0gc3BsaXRSYWRpdXNQb3Nlcyhjb250cm9sUG9zZXMsIHJhd3MpLFxuICAgICAgaG9yaXpvbnRhbHMgPSBfYi5ob3Jpem9udGFscyxcbiAgICAgIHZlcnRpY2FscyA9IF9iLnZlcnRpY2FscztcblxuICB2YXIgYm9yZGVyUmFkaXVzID0gc3R5bGVzLmpvaW4oXCIgXCIpO1xuICBzdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IGJvcmRlclJhZGl1cztcbiAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgIGhvcml6b250YWxzOiBob3Jpem9udGFscyxcbiAgICB2ZXJ0aWNhbHM6IHZlcnRpY2FscyxcbiAgICBib3JkZXJSYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgZGVsdGE6IGRlbHRhLFxuICAgIGRpc3Q6IGRpc3RcbiAgfSkpO1xufVxuLyoqXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLlJvdW5kYWJsZVxuICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgdG8gc2hvdyBhbmQgZHJhZyBvciBkb3VibGUgY2xpY2sgYm9yZGVyLXJhZGl1c1xuICovXG5cblxudmFyIFJvdW5kYWJsZSA9IHtcbiAgbmFtZTogXCJyb3VuZGFibGVcIixcbiAgcHJvcHM6IHtcbiAgICByb3VuZGFibGU6IEJvb2xlYW4sXG4gICAgcm91bmRSZWxhdGl2ZTogQm9vbGVhbixcbiAgICBtaW5Sb3VuZENvbnRyb2xzOiBBcnJheSxcbiAgICBtYXhSb3VuZENvbnRyb2xzOiBBcnJheSxcbiAgICByb3VuZENsaWNrYWJsZTogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHtcbiAgICBvblJvdW5kU3RhcnQ6IFwicm91bmRTdGFydFwiLFxuICAgIG9uUm91bmQ6IFwicm91bmRcIixcbiAgICBvblJvdW5kRW5kOiBcInJvdW5kRW5kXCJcbiAgfSxcbiAgY3NzOiBbXCIuY29udHJvbC5ib3JkZXItcmFkaXVzIHtcXG4gICAgYmFja2dyb3VuZDogI2Q2NjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cIiwgXCI6aG9zdFtkYXRhLWFibGUtcm91bmRhYmxlXSAubGluZS5kaXJlY3Rpb24ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVwiXSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHRhcmdldCA9IF9hLnRhcmdldCxcbiAgICAgICAgd2lkdGggPSBfYS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0LFxuICAgICAgICBhbGxNYXRyaXggPSBfYS5hbGxNYXRyaXgsXG4gICAgICAgIGlzM2QgPSBfYS5pczNkLFxuICAgICAgICBsZWZ0ID0gX2EubGVmdCxcbiAgICAgICAgdG9wID0gX2EudG9wLFxuICAgICAgICBib3JkZXJSYWRpdXNTdGF0ZSA9IF9hLmJvcmRlclJhZGl1c1N0YXRlO1xuICAgIHZhciBfYiA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICBfYyA9IF9iLm1pblJvdW5kQ29udHJvbHMsXG4gICAgICAgIG1pblJvdW5kQ29udHJvbHMgPSBfYyA9PT0gdm9pZCAwID8gWzAsIDBdIDogX2MsXG4gICAgICAgIF9kID0gX2IubWF4Um91bmRDb250cm9scyxcbiAgICAgICAgbWF4Um91bmRDb250cm9scyA9IF9kID09PSB2b2lkIDAgPyBbNCwgNF0gOiBfZCxcbiAgICAgICAgem9vbSA9IF9iLnpvb207XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gICAgdmFyIHJhZGl1c1ZhbHVlcyA9IGdldEJvcmRlclJhZGl1cyh0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG1pblJvdW5kQ29udHJvbHMsIGJvcmRlclJhZGl1c1N0YXRlKTtcblxuICAgIGlmICghcmFkaXVzVmFsdWVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdmVydGljYWxDb3VudCA9IDA7XG4gICAgdmFyIGhvcml6b250YWxDb3VudCA9IDA7XG4gICAgcmV0dXJuIHJhZGl1c1ZhbHVlcy5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgIGhvcml6b250YWxDb3VudCArPSBNYXRoLmFicyh2Lmhvcml6b250YWwpO1xuICAgICAgdmVydGljYWxDb3VudCArPSBNYXRoLmFicyh2LnZlcnRpY2FsKTtcbiAgICAgIHZhciBwb3MgPSBtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIHYucG9zLCBuKSwgW2xlZnQsIHRvcF0pO1xuICAgICAgdmFyIGlzRGlzcGxheSA9IHYudmVydGljYWwgPyB2ZXJ0aWNhbENvdW50IDw9IG1heFJvdW5kQ29udHJvbHNbMV0gOiBob3Jpem9udGFsQ291bnQgPD0gbWF4Um91bmRDb250cm9sc1swXTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAga2V5OiBcImJvcmRlclJhZGl1c0NvbnRyb2xcIi5jb25jYXQoaSksXG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbFwiLCBcImJvcmRlci1yYWRpdXNcIiksXG4gICAgICAgIFwiZGF0YS1yYWRpdXMtaW5kZXhcIjogaSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiBpc0Rpc3BsYXkgPyBcImJsb2NrXCIgOiBcIm5vbmVcIixcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChwb3NbMF0sIFwicHgsIFwiKS5jb25jYXQocG9zWzFdLCBcInB4KSBzY2FsZShcIikuY29uY2F0KHpvb20sIFwiKVwiKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIGlmICghZS5pbnB1dEV2ZW50IHx8IGUuaXNSZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTmFtZSA9IGUuaW5wdXRFdmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoXCJib3JkZXItcmFkaXVzXCIpID4gLTEgfHwgY2xhc3NOYW1lLmluZGV4T2YoXCJtb3ZlYWJsZS1saW5lXCIpID4gLTEgJiYgY2xhc3NOYW1lLmluZGV4T2YoXCJtb3ZlYWJsZS1kaXJlY3Rpb25cIikgPiAtMTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsXG4gICAgICAgIGRhdGFzID0gZS5kYXRhcztcbiAgICB2YXIgaW5wdXRUYXJnZXQgPSBpbnB1dEV2ZW50LnRhcmdldDtcbiAgICB2YXIgY2xhc3NOYW1lID0gaW5wdXRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIjtcbiAgICB2YXIgaXNDb250cm9sID0gY2xhc3NOYW1lLmluZGV4T2YoXCJib3JkZXItcmFkaXVzXCIpID4gLTE7XG4gICAgdmFyIGlzTGluZSA9IGNsYXNzTmFtZS5pbmRleE9mKFwibW92ZWFibGUtbGluZVwiKSA+IC0xICYmIGNsYXNzTmFtZS5pbmRleE9mKFwibW92ZWFibGUtZGlyZWN0aW9uXCIpID4gLTE7XG4gICAgdmFyIGNvbnRyb2xJbmRleCA9IGlzQ29udHJvbCA/IHBhcnNlSW50KGlucHV0VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcmFkaXVzLWluZGV4XCIpLCAxMCkgOiAtMTtcbiAgICB2YXIgbGluZUluZGV4ID0gaXNMaW5lID8gcGFyc2VJbnQoaW5wdXRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1saW5lLWluZGV4XCIpLCAxMCkgOiAtMTtcblxuICAgIGlmICghaXNDb250cm9sICYmICFpc0xpbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRTdGFydFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSkpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkYXRhcy5saW5lSW5kZXggPSBsaW5lSW5kZXg7XG4gICAgZGF0YXMuY29udHJvbEluZGV4ID0gY29udHJvbEluZGV4O1xuICAgIGRhdGFzLmlzQ29udHJvbCA9IGlzQ29udHJvbDtcbiAgICBkYXRhcy5pc0xpbmUgPSBpc0xpbmU7XG4gICAgc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgcm91bmRSZWxhdGl2ZSA9IF9hLnJvdW5kUmVsYXRpdmUsXG4gICAgICAgIF9iID0gX2EubWluUm91bmRDb250cm9scyxcbiAgICAgICAgbWluUm91bmRDb250cm9scyA9IF9iID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfYjtcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LFxuICAgICAgICB3aWR0aCA9IHN0YXRlLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG4gICAgZGF0YXMuaXNSb3VuZCA9IHRydWU7XG4gICAgZGF0YXMucHJldkRpc3QgPSBbMCwgMF07XG4gICAgdmFyIGNvbnRyb2xQb3NlcyA9IGdldEJvcmRlclJhZGl1cyh0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG1pblJvdW5kQ29udHJvbHMpIHx8IFtdO1xuICAgIGRhdGFzLmNvbnRyb2xQb3NlcyA9IGNvbnRyb2xQb3NlcztcbiAgICBzdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IGdldFJhZGl1c1N0eWxlcyhjb250cm9sUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwb3MucG9zO1xuICAgIH0pLCBjb250cm9sUG9zZXMsIHJvdW5kUmVsYXRpdmUsIHdpZHRoLCBoZWlnaHQpLnN0eWxlcy5qb2luKFwiIFwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzUm91bmQgfHwgIWRhdGFzLmlzQ29udHJvbCB8fCAhZGF0YXMuY29udHJvbFBvc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGRhdGFzLmNvbnRyb2xJbmRleDtcbiAgICB2YXIgY29udHJvbFBvc2VzID0gZGF0YXMuY29udHJvbFBvc2VzO1xuXG4gICAgdmFyIF9hID0gZ2V0RHJhZ0Rpc3QoZSksXG4gICAgICAgIGRpc3RYID0gX2FbMF0sXG4gICAgICAgIGRpc3RZID0gX2FbMV07XG5cbiAgICB2YXIgZGlzdCA9IFtkaXN0WCwgZGlzdFldO1xuICAgIHZhciBkZWx0YSA9IG1pbnVzKGRpc3QsIGRhdGFzLnByZXZEaXN0KTtcbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5wcm9wcy5tYXhSb3VuZENvbnRyb2xzLFxuICAgICAgICBtYXhSb3VuZENvbnRyb2xzID0gX2IgPT09IHZvaWQgMCA/IFs0LCA0XSA6IF9iO1xuICAgIHZhciBfYyA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICB3aWR0aCA9IF9jLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYy5oZWlnaHQ7XG4gICAgdmFyIHNlbGVjdGVkQ29udHJvbFBvc2UgPSBjb250cm9sUG9zZXNbaW5kZXhdO1xuICAgIHZhciBzZWxlY3RlZFZlcnRpY2FsID0gc2VsZWN0ZWRDb250cm9sUG9zZS52ZXJ0aWNhbDtcbiAgICB2YXIgc2VsZWN0ZWRIb3Jpem9udGFsID0gc2VsZWN0ZWRDb250cm9sUG9zZS5ob3Jpem9udGFsOyAvLyAwOiBbMCwgMSwgMiwgM10gbWF4Q291bnQgPT09IDFcbiAgICAvLyAwOiBbMCwgMl0gbWF4Q291bnQgPT09IDJcbiAgICAvLyAxOiBbMSwgM10gbWF4Q291bnQgPT09IDJcbiAgICAvLyAwOiBbMF0gbWF4Q291bnQgPT09IDNcbiAgICAvLyAxOiBbMSwgM10gbWF4Q291bnQgPT09IDNcblxuICAgIHZhciBkaXN0cyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvc2UpIHtcbiAgICAgIHZhciBob3Jpem9udGFsID0gcG9zZS5ob3Jpem9udGFsLFxuICAgICAgICAgIHZlcnRpY2FsID0gcG9zZS52ZXJ0aWNhbDtcbiAgICAgIHZhciBwb3NlRGlzdCA9IFtob3Jpem9udGFsICogc2VsZWN0ZWRIb3Jpem9udGFsICogZGlzdFswXSwgdmVydGljYWwgKiBzZWxlY3RlZFZlcnRpY2FsICogZGlzdFsxXV07XG5cbiAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChtYXhSb3VuZENvbnRyb2xzWzBdID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc2VEaXN0O1xuICAgICAgICB9IGVsc2UgaWYgKG1heFJvdW5kQ29udHJvbHNbMF0gPCA0ICYmIGhvcml6b250YWwgIT09IHNlbGVjdGVkSG9yaXpvbnRhbCkge1xuICAgICAgICAgIHJldHVybiBwb3NlRGlzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtYXhSb3VuZENvbnRyb2xzWzFdID09PSAwKSB7XG4gICAgICAgIHBvc2VEaXN0WzFdID0gdmVydGljYWwgKiBzZWxlY3RlZEhvcml6b250YWwgKiBkaXN0WzBdIC8gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgIHJldHVybiBwb3NlRGlzdDtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRWZXJ0aWNhbCkge1xuICAgICAgICBpZiAobWF4Um91bmRDb250cm9sc1sxXSA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBwb3NlRGlzdDtcbiAgICAgICAgfSBlbHNlIGlmIChtYXhSb3VuZENvbnRyb2xzWzFdIDwgNCAmJiB2ZXJ0aWNhbCAhPT0gc2VsZWN0ZWRWZXJ0aWNhbCkge1xuICAgICAgICAgIHJldHVybiBwb3NlRGlzdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH0pO1xuICAgIGRpc3RzW2luZGV4XSA9IGRpc3Q7XG4gICAgdmFyIG5leHRQb3NlcyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgICAgcmV0dXJuIHBsdXMocG9zLnBvcywgZGlzdHNbaV0pO1xuICAgIH0pO1xuICAgIGRhdGFzLnByZXZEaXN0ID0gW2Rpc3RYLCBkaXN0WV07XG4gICAgdHJpZ2dlclJvdW5kRXZlbnQobW92ZWFibGUsIGUsIGRpc3QsIGRlbHRhLCBjb250cm9sUG9zZXMsIG5leHRQb3Nlcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICBzdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IFwiXCI7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgaXNEb3VibGUgPSBlLmlzRG91YmxlO1xuXG4gICAgaWYgKCFkYXRhcy5pc1JvdW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gc3RhdGUud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHN0YXRlLmhlaWdodDtcbiAgICB2YXIgaXNDb250cm9sID0gZGF0YXMuaXNDb250cm9sLFxuICAgICAgICBjb250cm9sSW5kZXggPSBkYXRhcy5jb250cm9sSW5kZXgsXG4gICAgICAgIGlzTGluZSA9IGRhdGFzLmlzTGluZSxcbiAgICAgICAgbGluZUluZGV4ID0gZGF0YXMubGluZUluZGV4O1xuICAgIHZhciBjb250cm9sUG9zZXMgPSBkYXRhcy5jb250cm9sUG9zZXM7XG4gICAgdmFyIHBvc2VzID0gY29udHJvbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gcG9zLnBvcztcbiAgICB9KTtcbiAgICB2YXIgbGVuZ3RoID0gcG9zZXMubGVuZ3RoO1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLnJvdW5kQ2xpY2thYmxlLFxuICAgICAgICByb3VuZENsaWNrYWJsZSA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2E7XG5cbiAgICBpZiAoaXNEb3VibGUgJiYgcm91bmRDbGlja2FibGUpIHtcbiAgICAgIGlmIChpc0NvbnRyb2wpIHtcbiAgICAgICAgcmVtb3ZlUmFkaXVzUG9zKGNvbnRyb2xQb3NlcywgcG9zZXMsIGNvbnRyb2xJbmRleCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGlzTGluZSkge1xuICAgICAgICB2YXIgX2IgPSBjYWxjdWxhdGVQb2ludGVyRGlzdChtb3ZlYWJsZSwgZSksXG4gICAgICAgICAgICBkaXN0WCA9IF9iWzBdLFxuICAgICAgICAgICAgZGlzdFkgPSBfYlsxXTtcblxuICAgICAgICBhZGRCb3JkZXJSYWRpdXMoY29udHJvbFBvc2VzLCBwb3NlcywgbGluZUluZGV4LCBkaXN0WCwgZGlzdFksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoICE9PSBjb250cm9sUG9zZXMubGVuZ3RoKSB7XG4gICAgICAgIHRyaWdnZXJSb3VuZEV2ZW50KG1vdmVhYmxlLCBlLCBbMCwgMF0sIFswLCAwXSwgY29udHJvbFBvc2VzLCBwb3Nlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRFbmRcIiwgZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pKTtcbiAgICBzdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IFwiXCI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IFwiXCI7XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgdG8gc2hvdyBhbmQgZHJhZyBvciBkb3VibGUgY2xpY2sgYm9yZGVyLXJhZGl1cywgKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI3JvdW5kYWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxuICogICAgIHJvdW5kUmVsYXRpdmU6IGZhbHNlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJvdW5kU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcInJvdW5kXCIsIGUgPT4ge1xuICogICAgIGUudGFyZ2V0LnN0eWxlLmJvcmRlclJhZGl1cyA9IGUuYm9yZGVyUmFkaXVzO1xuICogfSkub24oXCJyb3VuZEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogJSBDYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBhYnNvbHV0ZSBweFxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI3JvdW5kUmVsYXRpdmVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3VuZFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJyb3VuZFwiLCBlID0+IHtcbiAqICAgICBlLnRhcmdldC5zdHlsZS5ib3JkZXJSYWRpdXMgPSBlLmJvcmRlclJhZGl1cztcbiAqIH0pLm9uKFwicm91bmRFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIE1pbmltdW0gbnVtYmVyIG9mIHJvdW5kIGNvbnRyb2xzLiBJdCBtb3ZlcyBpbiBwcm9wb3J0aW9uIGJ5IGNvbnRyb2wuIFtob3Jpem9udGFsLCB2ZXJ0aWNhbF0gKGRlZmF1bHQ6IFswLCAwXSlcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdW5kYWJsZSNtaW5Sb3VuZENvbnRyb2xzXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3VuZGFibGU6IHRydWUsXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgbWluUm91bmRDb250cm9sczogWzAsIDBdLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5tYXhSb3VuZENvbnRyb2xzID0gWzEsIDBdO1xuICovXG5cbi8qKlxuICogTWF4aW11bSBudW1iZXIgb2Ygcm91bmQgY29udHJvbHMuIEl0IG1vdmVzIGluIHByb3BvcnRpb24gYnkgY29udHJvbC4gW2hvcml6b250YWwsIHZlcnRpY2FsXSAoZGVmYXVsdDogWzQsIDRdKVxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI21heFJvdW5kQ29udHJvbHNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcbiAqICAgICBtYXhSb3VuZENvbnRyb2xzOiBbNCwgNF0sXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm1heFJvdW5kQ29udHJvbHMgPSBbMSwgMF07XG4gKi9cblxuLyoqXG4gKiBAcHJvcGVydHkgLSBXaGV0aGVyIHlvdSBjYW4gYWRkL2RlbGV0ZSByb3VuZCBjb250cm9scyBieSBkb3VibGUtY2xpY2tpbmcgYSBsaW5lIG9yIGNvbnRyb2wuIChkZWZhdWx0OiB0cnVlKVxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI3JvdW5kQ2xpY2thYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3VuZGFibGU6IHRydWUsXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgcm91bmRDbGlja2FibGU6IHRydWUsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLnJvdW5kQ2xpY2thYmxlID0gZmFsc2U7XG4gKi9cblxuLyoqXG4gKiBXaGVuIGRyYWcgc3RhcnQgdGhlIGNsaXAgYXJlYSBvciBjb250cm9scywgdGhlIGByb3VuZFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUm91bmRhYmxlXG4gKiBAZXZlbnQgcm91bmRTdGFydFxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3VuZGFibGUuT25Sb3VuZFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcm91bmRTdGFydGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3VuZFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJyb3VuZFwiLCBlID0+IHtcbiAqICAgICBlLnRhcmdldC5zdHlsZS5ib3JkZXJSYWRpdXMgPSBlLmJvcmRlclJhZGl1cztcbiAqIH0pLm9uKFwicm91bmRFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gZHJhZyBvciBkb3VibGUgY2xpY2sgdGhlIGJvcmRlciBhcmVhIG9yIGNvbnRyb2xzLCB0aGUgYHJvdW5kYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUm91bmRhYmxlXG4gKiBAZXZlbnQgcm91bmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm91bmRhYmxlLk9uUm91bmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3VuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3VuZGFibGU6IHRydWUsXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm91bmRTdGFydFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pLm9uKFwicm91bmRcIiwgZSA9PiB7XG4gKiAgICAgZS50YXJnZXQuc3R5bGUuYm9yZGVyUmFkaXVzID0gZS5ib3JkZXJSYWRpdXM7XG4gKiB9KS5vbihcInJvdW5kRW5kXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIGRyYWcgZW5kIHRoZSBib3JkZXIgYXJlYSBvciBjb250cm9scywgdGhlIGByb3VuZEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdW5kYWJsZVxuICogQGV2ZW50IHJvdW5kRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdW5kYWJsZS5vblJvdW5kRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcm91bmRFbmRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxuICogICAgIHJvdW5kUmVsYXRpdmU6IGZhbHNlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJvdW5kU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcInJvdW5kXCIsIGUgPT4ge1xuICogICAgIGUudGFyZ2V0LnN0eWxlLmJvcmRlclJhZGl1cyA9IGUuYm9yZGVyUmFkaXVzO1xuICogfSkub24oXCJyb3VuZEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbmZ1bmN0aW9uIGlzSWRlbnRpdHlNYXRyaXgobWF0cml4LCBpczNkKSB7XG4gIHZhciB2YWx1ZSA9IGlzM2QgPyBcIm1hdHJpeDNkKFwiLmNvbmNhdChjcmVhdGVJZGVudGl0eU1hdHJpeCg0KSkgOiBcIm1hdHJpeChcIi5jb25jYXQoY3JlYXRlSWRlbnRpdHlNYXRyaXgoMyksIFwiKVwiKTtcbiAgcmV0dXJuIG1hdHJpeCA9PT0gdmFsdWUgfHwgbWF0cml4ID09PSBcIm1hdHJpeCgxLDAsMCwxLDAsMClcIjtcbn1cblxudmFyIEJlZm9yZVJlbmRlcmFibGUgPSB7XG4gIGlzUGluY2g6IHRydWUsXG4gIG5hbWU6IFwiYmVmb3JlUmVuZGVyYWJsZVwiLFxuICBwcm9wczoge30sXG4gIGV2ZW50czoge1xuICAgIG9uQmVmb3JlUmVuZGVyU3RhcnQ6IFwiYmVmb3JlUmVuZGVyU3RhcnRcIixcbiAgICBvbkJlZm9yZVJlbmRlcjogXCJiZWZvcmVSZW5kZXJcIixcbiAgICBvbkJlZm9yZVJlbmRlckVuZDogXCJiZWZvcmVSZW5kZXJFbmRcIixcbiAgICBvbkJlZm9yZVJlbmRlckdyb3VwU3RhcnQ6IFwiYmVmb3JlUmVuZGVyR3JvdXBTdGFydFwiLFxuICAgIG9uQmVmb3JlUmVuZGVyR3JvdXA6IFwiYmVmb3JlUmVuZGVyR3JvdXBcIixcbiAgICBvbkJlZm9yZVJlbmRlckdyb3VwRW5kOiBcImJlZm9yZVJlbmRlckdyb3VwRW5kXCJcbiAgfSxcbiAgZHJhZ1JlbGF0aW9uOiBcIndlYWtcIixcbiAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgaXMzZCA9IF9hLmlzM2QsXG4gICAgICAgIHRhcmdldCA9IF9hLnRhcmdldCxcbiAgICAgICAgdGFyZ2V0TWF0cml4ID0gX2EudGFyZ2V0TWF0cml4O1xuICAgIHZhciB0cmFuc2Zvcm0gPSB0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQuc3R5bGUudHJhbnNmb3JtO1xuICAgIHZhciBjc3NNYXRyaXggPSBpczNkID8gXCJtYXRyaXgzZChcIi5jb25jYXQodGFyZ2V0TWF0cml4LmpvaW4oXCIsXCIpLCBcIilcIikgOiBcIm1hdHJpeChcIi5jb25jYXQoY29udmVydE1hdHJpeHRvQ1NTKHRhcmdldE1hdHJpeCwgdHJ1ZSksIFwiKVwiKTtcbiAgICB2YXIgc3RhcnRUcmFuc2Zvcm0gPSAhdHJhbnNmb3JtIHx8IHRyYW5zZm9ybSA9PT0gXCJub25lXCIgPyBjc3NNYXRyaXggOiB0cmFuc2Zvcm07XG4gICAgZS5kYXRhcy5zdGFydFRyYW5zZm9ybXMgPSBpc0lkZW50aXR5TWF0cml4KHN0YXJ0VHJhbnNmb3JtLCBpczNkKSA/IFtdIDogc3BsaXRTcGFjZShzdGFydFRyYW5zZm9ybSk7XG4gIH0sXG4gIHJlc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoZSkge1xuICAgIGUuZGF0YXMubmV4dFRyYW5zZm9ybXMgPSBlLmRhdGFzLnN0YXJ0VHJhbnNmb3JtcztcbiAgICBlLmRhdGFzLm5leHRUcmFuc2Zvcm1BcHBlbmRlZEluZGV4ZXMgPSBbXTtcbiAgfSxcbiAgZmlsbERyYWdTdGFydFBhcmFtczogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIHNldFRyYW5zZm9ybTogZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgICBlLmRhdGFzLnN0YXJ0VHJhbnNmb3JtcyA9IGlzQXJyYXkodHJhbnNmb3JtKSA/IHRyYW5zZm9ybSA6IHNwbGl0U3BhY2UodHJhbnNmb3JtKTtcbiAgICAgIH0sXG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaFxuICAgIH0pO1xuICB9LFxuICBmaWxsRHJhZ1BhcmFtczogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoXG4gICAgfSk7XG4gIH0sXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0obW92ZWFibGUsIGUpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlclN0YXJ0XCIsIHRoaXMuZmlsbERyYWdTdGFydFBhcmFtcyhtb3ZlYWJsZSwgZSkpO1xuICB9LFxuICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLnJlc2V0VHJhbnNmb3JtKGUpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlclwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaFxuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVuZGVyRW5kXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxuICAgICAgaXNEcmFnOiBlLmlzRHJhZ1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gICAgdmFyIGV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJiZWZvcmVSZW5kZXJhYmxlXCIsIGUpO1xuICAgIHZhciBtb3ZlYWJsZXMgPSBtb3ZlYWJsZS5tb3ZlYWJsZXM7XG4gICAgdmFyIHBhcmFtcyA9IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGNoaWxkRXZlbnQsIGkpIHtcbiAgICAgIHZhciBjaGlsZE1vdmVhYmxlID0gbW92ZWFibGVzW2ldO1xuXG4gICAgICBfdGhpcy5zZXRUcmFuc2Zvcm0oY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XG5cbiAgICAgIHJldHVybiBfdGhpcy5maWxsRHJhZ1N0YXJ0UGFyYW1zKGNoaWxkTW92ZWFibGUsIGNoaWxkRXZlbnQpO1xuICAgIH0pO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlckdyb3VwU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIGV2ZW50czogcGFyYW1zXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xuICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKTtcbiAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xuICAgIHZhciBwYXJhbXMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChjaGlsZEV2ZW50LCBpKSB7XG4gICAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IG1vdmVhYmxlc1tpXTtcblxuICAgICAgX3RoaXMucmVzZXRUcmFuc2Zvcm0oY2hpbGRFdmVudCk7XG5cbiAgICAgIHJldHVybiBfdGhpcy5maWxsRHJhZ1BhcmFtcyhjaGlsZE1vdmVhYmxlLCBjaGlsZEV2ZW50KTtcbiAgICB9KTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSZW5kZXJHcm91cFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IHBhcmFtc1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlckdyb3VwRW5kXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxuICAgICAgaXNEcmFnOiBlLmlzRHJhZyxcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHNcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdHcm91cFN0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwRW5kKG1vdmVhYmxlLCBlKTtcbiAgfVxufTtcbnZhciBSZW5kZXJhYmxlID0ge1xuICBuYW1lOiBcInJlbmRlcmFibGVcIixcbiAgcHJvcHM6IHt9LFxuICBldmVudHM6IHtcbiAgICBvblJlbmRlclN0YXJ0OiBcInJlbmRlclN0YXJ0XCIsXG4gICAgb25SZW5kZXI6IFwicmVuZGVyXCIsXG4gICAgb25SZW5kZXJFbmQ6IFwicmVuZGVyRW5kXCIsXG4gICAgb25SZW5kZXJHcm91cFN0YXJ0OiBcInJlbmRlckdyb3VwU3RhcnRcIixcbiAgICBvblJlbmRlckdyb3VwOiBcInJlbmRlckdyb3VwXCIsXG4gICAgb25SZW5kZXJHcm91cEVuZDogXCJyZW5kZXJHcm91cEVuZFwiXG4gIH0sXG4gIGRyYWdSZWxhdGlvbjogXCJ3ZWFrXCIsXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2hcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWc6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlbmRlclwiLCB0aGlzLmZpbGxEcmFnUGFyYW1zKG1vdmVhYmxlLCBlKSk7XG4gIH0sXG4gIGRyYWdBZnRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgaWYgKGUucmVzdWx0Q291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyRW5kXCIsIHRoaXMuZmlsbERyYWdFbmRQYXJhbXMobW92ZWFibGUsIGUpKTtcbiAgfSxcbiAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlbmRlckdyb3VwU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBcImJlZm9yZVJlbmRlcmFibGVcIiwgZSk7XG4gICAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcbiAgICB2YXIgcGFyYW1zID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoY2hpbGRFdmVudCwgaSkge1xuICAgICAgdmFyIGNoaWxkTW92ZWFibGUgPSBtb3ZlYWJsZXNbaV07XG4gICAgICByZXR1cm4gX3RoaXMuZmlsbERyYWdQYXJhbXMoY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgdHJhbnNmb3JtOiBnZXROZXh0VHJhbnNmb3JtVGV4dChlKSxcbiAgICAgIGV2ZW50czogcGFyYW1zXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBcImJlZm9yZVJlbmRlcmFibGVcIiwgZSk7XG4gICAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcbiAgICB2YXIgcGFyYW1zID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoY2hpbGRFdmVudCwgaSkge1xuICAgICAgdmFyIGNoaWxkTW92ZWFibGUgPSBtb3ZlYWJsZXNbaV07XG4gICAgICByZXR1cm4gX3RoaXMuZmlsbERyYWdFbmRQYXJhbXMoY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyR3JvdXBFbmRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICBpc0RyYWc6IGUuaXNEcmFnLFxuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogcGFyYW1zXG4gICAgfSkpO1xuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sQWZ0ZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdBZnRlcihtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnR3JvdXBTdGFydChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdHcm91cChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdHcm91cEVuZChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGZpbGxEcmFnUGFyYW1zOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICB0cmFuc2Zvcm06IGdldE5leHRUcmFuc2Zvcm1UZXh0KGUpXG4gICAgfSk7XG4gIH0sXG4gIGZpbGxEcmFnRW5kUGFyYW1zOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICBpc0RyYWc6IGUuaXNEcmFnXG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRyaWdnZXJBYmxlKG1vdmVhYmxlLCBhYmxlVHlwZSwgZXZlbnRPcGVyYXRpb24sIGV2ZW50QWZmaXgsIGV2ZW50VHlwZSwgZSwgcmVxdWVzdEluc3RhbnQpIHtcbiAgdmFyIGlzU3RhcnQgPSBldmVudFR5cGUgPT09IFwiU3RhcnRcIjtcbiAgdmFyIHRhcmdldCA9IG1vdmVhYmxlLnN0YXRlLnRhcmdldDtcbiAgdmFyIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0O1xuXG4gIGlmICghdGFyZ2V0IHx8IGlzU3RhcnQgJiYgZXZlbnRBZmZpeC5pbmRleE9mKFwiQ29udHJvbFwiKSA+IC0xICYmICFpc1JlcXVlc3QgJiYgbW92ZWFibGUuYXJlYUVsZW1lbnQgPT09IGUuaW5wdXRFdmVudC50YXJnZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gXCJkcmFnXCIgXCJDb250cm9sXCIgXCJBZnRlclwiXG5cblxuICB2YXIgZXZlbnROYW1lID0gXCJcIi5jb25jYXQoZXZlbnRPcGVyYXRpb24pLmNvbmNhdChldmVudEFmZml4KS5jb25jYXQoZXZlbnRUeXBlKTtcbiAgdmFyIGNvbmRpdGlvbk5hbWUgPSBcIlwiLmNvbmNhdChldmVudE9wZXJhdGlvbikuY29uY2F0KGV2ZW50QWZmaXgsIFwiQ29uZGl0aW9uXCIpO1xuICB2YXIgaXNFbmQgPSBldmVudFR5cGUgPT09IFwiRW5kXCI7XG4gIHZhciBpc0FmdGVyID0gZXZlbnRUeXBlID09PSBcIkFmdGVyXCI7XG4gIHZhciBpc0ZpcnN0U3RhcnQgPSBpc1N0YXJ0ICYmICghbW92ZWFibGUudGFyZ2V0R2VzdG8gfHwgIW1vdmVhYmxlLmNvbnRyb2xHZXN0byB8fCAhbW92ZWFibGUudGFyZ2V0R2VzdG8uaXNGbGFnKCkgfHwgIW1vdmVhYmxlLmNvbnRyb2xHZXN0by5pc0ZsYWcoKSk7XG5cbiAgaWYgKGlzRmlyc3RTdGFydCkge1xuICAgIG1vdmVhYmxlLnVwZGF0ZVJlY3QoZXZlbnRUeXBlLCB0cnVlLCBmYWxzZSk7XG4gIH1cblxuICBpZiAoZXZlbnRUeXBlID09PSBcIlwiICYmICFpc1JlcXVlc3QpIHtcbiAgICBjb252ZXJ0RHJhZ0Rpc3QobW92ZWFibGUuc3RhdGUsIGUpO1xuICB9IC8vIGNvbnN0IGlzR3JvdXAgPSBldmVudEFmZml4LmluZGV4T2YoXCJHcm91cFwiKSA+IC0xO1xuXG5cbiAgdmFyIGFibGVzID0gX19zcHJlYWRBcnJheShbXSwgbW92ZWFibGVbYWJsZVR5cGVdLCB0cnVlKTtcblxuICBpZiAoaXNSZXF1ZXN0KSB7XG4gICAgdmFyIHJlcXVlc3RBYmxlXzEgPSBlLnJlcXVlc3RBYmxlO1xuXG4gICAgaWYgKCFhYmxlcy5zb21lKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICByZXR1cm4gYWJsZS5uYW1lID09PSByZXF1ZXN0QWJsZV8xO1xuICAgIH0pKSB7XG4gICAgICBhYmxlcy5wdXNoLmFwcGx5KGFibGVzLCBtb3ZlYWJsZS5wcm9wcy5hYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGFibGUubmFtZSA9PT0gcmVxdWVzdEFibGVfMTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWFibGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudEFibGVzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtCZWZvcmVSZW5kZXJhYmxlXSwgYWJsZXMsIHRydWUpLCBbUmVuZGVyYWJsZV0sIGZhbHNlKS5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICByZXR1cm4gYWJsZVtldmVudE5hbWVdO1xuICB9KTtcblxuICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuXG4gIGlmIChpc0ZpcnN0U3RhcnQpIHtcbiAgICBldmVudEFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIGFibGUudW5zZXQgJiYgYWJsZS51bnNldChtb3ZlYWJsZSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcbiAgdmFyIGlucHV0VGFyZ2V0O1xuXG4gIGlmIChpc0VuZCAmJiBpbnB1dEV2ZW50KSB7XG4gICAgaW5wdXRUYXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKSB8fCBpbnB1dEV2ZW50LnRhcmdldDtcbiAgfVxuXG4gIHZhciByZXN1bHRDb3VudCA9IDA7XG4gIHZhciByZXN1bHRzID0gZXZlbnRBYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICB2YXIgYWJsZU5hbWUgPSBhYmxlLm5hbWU7XG4gICAgdmFyIG5leHREYXRhcyA9IGRhdGFzW2FibGVOYW1lXSB8fCAoZGF0YXNbYWJsZU5hbWVdID0ge30pO1xuXG4gICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgIG5leHREYXRhcy5pc0V2ZW50U3RhcnQgPSAhYWJsZVtjb25kaXRpb25OYW1lXSB8fCBhYmxlW2NvbmRpdGlvbk5hbWVdKG1vdmVhYmxlLCBlKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dERhdGFzLmlzRXZlbnRTdGFydCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGFibGVbZXZlbnROYW1lXShtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICAgIHJlc3VsdENvdW50OiByZXN1bHRDb3VudCxcbiAgICAgICAgZGF0YXM6IG5leHREYXRhcyxcbiAgICAgICAgb3JpZ2luYWxEYXRhczogZGF0YXMsXG4gICAgICAgIGlucHV0VGFyZ2V0OiBpbnB1dFRhcmdldFxuICAgICAgfSkpO1xuXG4gICAgICBtb3ZlYWJsZS5fZW1pdHRlci5vZmYoKTtcblxuICAgICAgaWYgKGlzU3RhcnQgJiYgcmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICBuZXh0RGF0YXMuaXNFdmVudFN0YXJ0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdENvdW50ICs9IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICB2YXIgaXNVcGRhdGUgPSByZXN1bHRzLmxlbmd0aDtcbiAgdmFyIGlzRm9yY2VFbmQgPSBmYWxzZTsgLy8gZW5kIGFibGVzXG5cbiAgaWYgKGlzU3RhcnQgJiYgZXZlbnRBYmxlcy5sZW5ndGggJiYgIWlzVXBkYXRlKSB7XG4gICAgaXNGb3JjZUVuZCA9IGV2ZW50QWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICB2YXIgYWJsZU5hbWUgPSBhYmxlLm5hbWU7XG4gICAgICB2YXIgbmV4dERhdGFzID0gZGF0YXNbYWJsZU5hbWVdO1xuXG4gICAgICBpZiAobmV4dERhdGFzLmlzRXZlbnRTdGFydCkge1xuICAgICAgICBpZiAoYWJsZS5kcmFnUmVsYXRpb24gPT09IFwic3Ryb25nXCIpIHtcbiAgICAgICAgICAvLyBjYW5jZWwgZHJhZ1xuICAgICAgICAgIG5leHREYXRhcy5pc0V2ZW50U3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gc3RhcnQgZHJhZ1xuXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGNhbmNlbCBldmVudFxuXG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KS5sZW5ndGggPT09IDA7XG4gIH1cblxuICBpZiAoaXNFbmQgfHwgaXNGb3JjZUVuZCkge1xuICAgIG1vdmVhYmxlLnN0YXRlLmdlc3RvID0gbnVsbDtcblxuICAgIGlmIChtb3ZlYWJsZS5tb3ZlYWJsZXMpIHtcbiAgICAgIG1vdmVhYmxlLm1vdmVhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZE1vdmVhYmxlKSB7XG4gICAgICAgIGNoaWxkTW92ZWFibGUuc3RhdGUuZ2VzdG8gPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRmlyc3RTdGFydCAmJiBpc0ZvcmNlRW5kKSB7XG4gICAgZXZlbnRBYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICBhYmxlLnVuc2V0ICYmIGFibGUudW5zZXQobW92ZWFibGUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzU3RhcnQgJiYgIWlzUmVxdWVzdCAmJiBpc1VwZGF0ZSkge1xuICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgaWYgKG1vdmVhYmxlLmlzVW5tb3VudGVkIHx8IGlzRm9yY2VFbmQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWlzU3RhcnQgJiYgaXNVcGRhdGUgJiYgIXJlcXVlc3RJbnN0YW50IHx8IGlzRW5kKSB7XG4gICAgdmFyIGZsdXNoU3luYyA9IG1vdmVhYmxlLnByb3BzLmZsdXNoU3luYyB8fCBkZWZhdWx0U3luYztcbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgbW92ZWFibGUudXBkYXRlUmVjdChpc0VuZCA/IGV2ZW50VHlwZSA6IFwiXCIsIHRydWUsIGZhbHNlKTtcbiAgICAgIG1vdmVhYmxlLmZvcmNlVXBkYXRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzU3RhcnQgJiYgIWlzRW5kICYmICFpc0FmdGVyICYmIGlzVXBkYXRlICYmICFyZXF1ZXN0SW5zdGFudCkge1xuICAgIHRyaWdnZXJBYmxlKG1vdmVhYmxlLCBhYmxlVHlwZSwgZXZlbnRPcGVyYXRpb24sIGV2ZW50QWZmaXgsIGV2ZW50VHlwZSArIFwiQWZ0ZXJcIiwgZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0QWJsZUdlc3RvKG1vdmVhYmxlLCBtb3ZlYWJsZVRhcmdldCwgZXZlbnRBZmZpeCkge1xuICB2YXIgY29udHJvbEJveCA9IG1vdmVhYmxlLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpO1xuICB2YXIgdGFyZ2V0cyA9IFtdO1xuICB0YXJnZXRzLnB1c2goY29udHJvbEJveCk7XG5cbiAgaWYgKCFtb3ZlYWJsZS5wcm9wcy5kcmFnQXJlYSB8fCBtb3ZlYWJsZS5wcm9wcy5kcmFnVGFyZ2V0KSB7XG4gICAgdGFyZ2V0cy5wdXNoKG1vdmVhYmxlVGFyZ2V0KTtcbiAgfVxuXG4gIHZhciBzdGFydEZ1bmMgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBldmVudFRhcmdldCA9IGUuaW5wdXRFdmVudC50YXJnZXQ7XG4gICAgdmFyIGFyZWFFbGVtZW50ID0gbW92ZWFibGUuYXJlYUVsZW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50VGFyZ2V0ID09PSBhcmVhRWxlbWVudCB8fCAhbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoZXZlbnRUYXJnZXQpICYmICFtb3ZlYWJsZS5jb250cm9sQm94LmdldEVsZW1lbnQoKS5jb250YWlucyhldmVudFRhcmdldCkgfHwgaGFzQ2xhc3MoZXZlbnRUYXJnZXQsIFwibW92ZWFibGUtYXJlYVwiKSB8fCBoYXNDbGFzcyhldmVudFRhcmdldCwgXCJtb3ZlYWJsZS1wYWRkaW5nXCIpO1xuICB9O1xuXG4gIHJldHVybiBnZXRBYmxlR2VzdG8obW92ZWFibGUsIHRhcmdldHMsIFwidGFyZ2V0QWJsZXNcIiwgZXZlbnRBZmZpeCwge1xuICAgIGRyYWdTdGFydDogc3RhcnRGdW5jLFxuICAgIHBpbmNoU3RhcnQ6IHN0YXJ0RnVuY1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QWJsZUdlc3RvKG1vdmVhYmxlLCB0YXJnZXQsIGFibGVUeXBlLCBldmVudEFmZml4LCBjb25kaXRpb25GdW5jdGlvbnMpIHtcbiAgaWYgKGNvbmRpdGlvbkZ1bmN0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZGl0aW9uRnVuY3Rpb25zID0ge307XG4gIH1cblxuICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgIHBpbmNoT3V0c2lkZSA9IF9hLnBpbmNoT3V0c2lkZSxcbiAgICAgIHBpbmNoVGhyZXNob2xkID0gX2EucGluY2hUaHJlc2hvbGQ7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcbiAgICBwcmV2ZW50UmlnaHRDbGljazogdHJ1ZSxcbiAgICBwcmV2ZW50V2hlZWxDbGljazogdHJ1ZSxcbiAgICBjb250YWluZXI6IHdpbmRvdyxcbiAgICBwaW5jaFRocmVzaG9sZDogcGluY2hUaHJlc2hvbGQsXG4gICAgcGluY2hPdXRzaWRlOiBwaW5jaE91dHNpZGVcbiAgfTtcbiAgdmFyIGdlc3RvID0gbmV3IEdlc3RvKHRhcmdldCwgb3B0aW9ucyk7XG4gIFtcImRyYWdcIiwgXCJwaW5jaFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE9wZXJhdGlvbikge1xuICAgIFtcIlN0YXJ0XCIsIFwiXCIsIFwiRW5kXCJdLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgZ2VzdG8ub24oXCJcIi5jb25jYXQoZXZlbnRPcGVyYXRpb24pLmNvbmNhdChldmVudFR5cGUpLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZS5ldmVudFR5cGU7XG5cbiAgICAgICAgaWYgKGNvbmRpdGlvbkZ1bmN0aW9uc1tldmVudE5hbWVdICYmICFjb25kaXRpb25GdW5jdGlvbnNbZXZlbnROYW1lXShlKSkge1xuICAgICAgICAgIGUuc3RvcCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyQWJsZShtb3ZlYWJsZSwgYWJsZVR5cGUsIGV2ZW50T3BlcmF0aW9uLCBldmVudEFmZml4LCBldmVudFR5cGUsIGUpO1xuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGdlc3RvO1xufVxuXG52YXIgRXZlbnRNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKHRhcmdldCwgbW92ZWFibGUsIGV2ZW50TmFtZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLm1vdmVhYmxlID0gbW92ZWFibGU7XG4gICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgdGhpcy5hYmxlcyA9IFtdO1xuXG4gICAgdGhpcy5fb25FdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZXZlbnROYW1lID0gX3RoaXMuZXZlbnROYW1lO1xuICAgICAgdmFyIG1vdmVhYmxlID0gX3RoaXMubW92ZWFibGU7XG5cbiAgICAgIGlmIChtb3ZlYWJsZS5zdGF0ZS5kaXNhYmxlTmF0aXZlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5hYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICAgIGFibGVbZXZlbnROYW1lXShtb3ZlYWJsZSwge1xuICAgICAgICAgIGlucHV0RXZlbnQ6IGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLnRvTG93ZXJDYXNlKCksIHRoaXMuX29uRXZlbnQpO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBFdmVudE1hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uc2V0QWJsZXMgPSBmdW5jdGlvbiAoYWJsZXMpIHtcbiAgICB0aGlzLmFibGVzID0gYWJsZXM7XG4gIH07XG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUudG9Mb3dlckNhc2UoKSwgdGhpcy5fb25FdmVudCk7XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIHRoaXMubW92ZWFibGUgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBFdmVudE1hbmFnZXI7XG59KCk7XG5cbnZhciBNb3ZlYWJsZU1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTW92ZWFibGVNYW5hZ2VyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1vdmVhYmxlTWFuYWdlcigpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnN0YXRlID0gX19hc3NpZ24oe1xuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgZ2VzdG86IG51bGwsXG4gICAgICByZW5kZXJQb3NlczogW1swLCAwXSwgWzAsIDBdLCBbMCwgMF0sIFswLCAwXV0sXG4gICAgICBkaXNhYmxlTmF0aXZlRXZlbnQ6IGZhbHNlXG4gICAgfSwgZ2V0VGFyZ2V0SW5mbyhudWxsKSk7XG4gICAgX3RoaXMuZW5hYmxlZEFibGVzID0gW107XG4gICAgX3RoaXMudGFyZ2V0QWJsZXMgPSBbXTtcbiAgICBfdGhpcy5jb250cm9sQWJsZXMgPSBbXTtcbiAgICBfdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgX3RoaXMuc2NhbGUgPSBbMSwgMV07XG4gICAgX3RoaXMuaXNVbm1vdW50ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5ldmVudHMgPSB7XG4gICAgICBcIm1vdXNlRW50ZXJcIjogbnVsbCxcbiAgICAgIFwibW91c2VMZWF2ZVwiOiBudWxsXG4gICAgfTtcbiAgICBfdGhpcy5fZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIkMSgpO1xuICAgIF90aGlzLl9wcmV2VGFyZ2V0ID0gbnVsbDtcbiAgICBfdGhpcy5fcHJldkRyYWdBcmVhID0gZmFsc2U7XG4gICAgX3RoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICBfdGhpcy5fb2JzZXJ2ZXJJZCA9IDA7XG5cbiAgICBfdGhpcy5vblByZXZlbnRDbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmVtb3ZlRXZlbnQod2luZG93LCBcImNsaWNrXCIsIF90aGlzLm9uUHJldmVudENsaWNrLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY2hlY2tVcGRhdGVSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnRNb3ZlYWJsZSA9IF90aGlzLnByb3BzLnBhcmVudE1vdmVhYmxlO1xuXG4gICAgICBpZiAocGFyZW50TW92ZWFibGUpIHtcbiAgICAgICAgcGFyZW50TW92ZWFibGUuY2hlY2tVcGRhdGVSZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX3RoaXMuX29ic2VydmVySWQpO1xuICAgICAgX3RoaXMuX29ic2VydmVySWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMudXBkYXRlUmVjdCgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHBhcmVudFBvc2l0aW9uID0gcHJvcHMucGFyZW50UG9zaXRpb24sXG4gICAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgcHJvcHNUYXJnZXQgPSBwcm9wcy50YXJnZXQsXG4gICAgICAgIHpvb20gPSBwcm9wcy56b29tLFxuICAgICAgICBjc3BOb25jZSA9IHByb3BzLmNzcE5vbmNlLFxuICAgICAgICB0cmFuc2xhdGVaID0gcHJvcHMudHJhbnNsYXRlWixcbiAgICAgICAgQ29udHJvbEJveEVsZW1lbnQgPSBwcm9wcy5jc3NTdHlsZWQsXG4gICAgICAgIHBvcnRhbENvbnRhaW5lciA9IHByb3BzLnBvcnRhbENvbnRhaW5lcjtcbiAgICB0aGlzLmNoZWNrVXBkYXRlKCk7XG4gICAgdGhpcy51cGRhdGVSZW5kZXJQb3NlcygpO1xuXG4gICAgdmFyIF9hID0gcGFyZW50UG9zaXRpb24gfHwge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH0sXG4gICAgICAgIHBhcmVudExlZnQgPSBfYS5sZWZ0LFxuICAgICAgICBwYXJlbnRUb3AgPSBfYS50b3A7XG5cbiAgICB2YXIgbGVmdCA9IHN0YXRlLmxlZnQsXG4gICAgICAgIHRvcCA9IHN0YXRlLnRvcCxcbiAgICAgICAgc3RhdGVUYXJnZXQgPSBzdGF0ZS50YXJnZXQsXG4gICAgICAgIGRpcmVjdGlvbiA9IHN0YXRlLmRpcmVjdGlvbixcbiAgICAgICAgaGFzRml4ZWQgPSBzdGF0ZS5oYXNGaXhlZDtcbiAgICB2YXIgZ3JvdXBUYXJnZXRzID0gcHJvcHMudGFyZ2V0cztcbiAgICB2YXIgaXNEaXNwbGF5ID0gKGdyb3VwVGFyZ2V0cyAmJiBncm91cFRhcmdldHMubGVuZ3RoIHx8IHByb3BzVGFyZ2V0KSAmJiBzdGF0ZVRhcmdldDtcbiAgICB2YXIgaXNEcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZygpO1xuICAgIHZhciBhYmxlQXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuZ2V0RW5hYmxlZEFibGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgYWJsZUF0dHJpYnV0ZXNbXCJkYXRhLWFibGUtXCIuY29uY2F0KGFibGUubmFtZS50b0xvd2VyQ2FzZSgpKV0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRyb2xCb3hFbGVtZW50LCBfX2Fzc2lnbih7XG4gICAgICBjc3BOb25jZTogY3NwTm9uY2UsXG4gICAgICByZWY6IHJlZih0aGlzLCBcImNvbnRyb2xCb3hcIiksXG4gICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeChcImNvbnRyb2wtYm94XCIsIGRpcmVjdGlvbiA9PT0gLTEgPyBcInJldmVyc2VcIiA6IFwiXCIsIGlzRHJhZ2dpbmcgPyBcImRyYWdnaW5nXCIgOiBcIlwiKSwgXCIgXCIpLmNvbmNhdChjbGFzc05hbWUpXG4gICAgfSwgYWJsZUF0dHJpYnV0ZXMsIHtcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25QcmV2ZW50Q2xpY2ssXG4gICAgICBwb3J0YWxDb250YWluZXI6IHBvcnRhbENvbnRhaW5lcixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIFwicG9zaXRpb25cIjogaGFzRml4ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCIsXG4gICAgICAgIFwiZGlzcGxheVwiOiBpc0Rpc3BsYXkgPyBcImJsb2NrXCIgOiBcIm5vbmVcIixcbiAgICAgICAgXCJ0cmFuc2Zvcm1cIjogXCJ0cmFuc2xhdGUzZChcIi5jb25jYXQobGVmdCAtIHBhcmVudExlZnQsIFwicHgsIFwiKS5jb25jYXQodG9wIC0gcGFyZW50VG9wLCBcInB4LCBcIikuY29uY2F0KHRyYW5zbGF0ZVosIFwiKVwiKSxcbiAgICAgICAgXCItLXpvb21cIjogem9vbSxcbiAgICAgICAgXCItLXpvb21weFwiOiBcIlwiLmNvbmNhdCh6b29tLCBcInB4XCIpXG4gICAgICB9XG4gICAgfSksIHRoaXMucmVuZGVyQWJsZXMoKSwgdGhpcy5fcmVuZGVyTGluZXMoKSk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzVW5tb3VudGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb250cm9sQm94LmdldEVsZW1lbnQoKTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwYXJlbnRNb3ZlYWJsZSA9IHByb3BzLnBhcmVudE1vdmVhYmxlLFxuICAgICAgICBjb250YWluZXIgPSBwcm9wcy5jb250YWluZXIsXG4gICAgICAgIHdyYXBwZXJNb3ZlYWJsZSA9IHByb3BzLndyYXBwZXJNb3ZlYWJsZTtcblxuICAgIHRoaXMuX3VwZGF0ZVRhcmdldHMoKTtcblxuICAgIHRoaXMuX3VwZGF0ZU5hdGl2ZUV2ZW50cygpO1xuXG4gICAgdGhpcy5fdXBkYXRlRXZlbnRzKCk7XG5cbiAgICBpZiAoIWNvbnRhaW5lciAmJiAhcGFyZW50TW92ZWFibGUgJiYgIXdyYXBwZXJNb3ZlYWJsZSkge1xuICAgICAgdGhpcy51cGRhdGVSZWN0KFwiXCIsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUNoZWNrSW5wdXQoKTtcblxuICAgIHRoaXMuX3VwZGF0ZU9ic2VydmVyKHRoaXMucHJvcHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgIHRoaXMuX3VwZGF0ZU5hdGl2ZUV2ZW50cygpO1xuXG4gICAgdGhpcy5fdXBkYXRlRXZlbnRzKCk7XG5cbiAgICB0aGlzLl91cGRhdGVUYXJnZXRzKCk7XG5cbiAgICB0aGlzLnVwZGF0ZUNoZWNrSW5wdXQoKTtcblxuICAgIHRoaXMuX3VwZGF0ZU9ic2VydmVyKHByZXZQcm9wcyk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzVW5tb3VudGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuX2VtaXR0ZXIub2ZmKCk7XG5cbiAgICB1bnNldCh0aGlzLCBcInRhcmdldEdlc3RvXCIpO1xuICAgIHVuc2V0KHRoaXMsIFwiY29udHJvbEdlc3RvXCIpO1xuICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cztcblxuICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICB2YXIgbWFuYWdlciA9IGV2ZW50c1tuYW1lXTtcbiAgICAgIG1hbmFnZXIgJiYgbWFuYWdlci5kZXN0cm95KCk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsXG4gICAgICAgIHBhcmVudE1vdmVhYmxlID0gX2EucGFyZW50TW92ZWFibGUsXG4gICAgICAgIHdyYXBwZXJNb3ZlYWJsZSA9IF9hLndyYXBwZXJNb3ZlYWJsZSxcbiAgICAgICAgY29udGFpbmVyID0gX2EuY29udGFpbmVyO1xuICAgIHJldHVybiBjb250YWluZXIgfHwgd3JhcHBlck1vdmVhYmxlICYmIHdyYXBwZXJNb3ZlYWJsZS5nZXRDb250YWluZXIoKSB8fCBwYXJlbnRNb3ZlYWJsZSAmJiBwYXJlbnRNb3ZlYWJsZS5nZXRDb250YWluZXIoKSB8fCB0aGlzLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpLnBhcmVudEVsZW1lbnQ7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGFuIGVsZW1lbnQgaW5jbHVkZWQgaW4gdGhlIG1vdmVhYmxlLlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2lzTW92ZWFibGVFbGVtZW50XG4gICAqIEBwYXJhbSAtIHRoZSB0YXJnZXRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlID0+IHtcbiAgICogICAgIGlmICghbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoZS50YXJnZXQpKSB7XG4gICAqICAgICAgICAgbW92ZWFibGUudGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNNb3ZlYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldCAmJiAodGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpLmluZGV4T2YoUFJFRklYKSA+IC0xO1xuICB9O1xuICAvKipcbiAgICogWW91IGNhbiBkcmFnIHN0YXJ0IHRoZSBNb3ZlYWJsZSB0aHJvdWdoIHRoZSBleHRlcm5hbCBgTW91c2VFdmVudGBvciBgVG91Y2hFdmVudGAuIChBbmd1bGFyOiBuZ0RyYWdTdGFydClcbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNkcmFnU3RhcnRcbiAgICogQHBhcmFtIC0gZXh0ZXJuYWwgYE1vdXNlRXZlbnRgb3IgYFRvdWNoRXZlbnRgXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcbiAgICogICAgIGlmICghbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoZS50YXJnZXQpKSB7XG4gICAqICAgICAgICAgIG1vdmVhYmxlLmRyYWdTdGFydChlKTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5kcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciB0YXJnZXRHZXN0byA9IHRoaXMudGFyZ2V0R2VzdG87XG5cbiAgICBpZiAodGFyZ2V0R2VzdG8gJiYgIXRhcmdldEdlc3RvLmlzRmxhZygpKSB7XG4gICAgICB0YXJnZXRHZXN0by50cmlnZ2VyRHJhZ1N0YXJ0KGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogSGl0IHRlc3QgYW4gZWxlbWVudCBvciByZWN0IG9uIGEgbW92ZWFibGUgdGFyZ2V0LlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2hpdFRlc3RcbiAgICogQHBhcmFtIC0gZWxlbWVudCBvciByZWN0IHRvIHRlc3RcbiAgICogQHJldHVybiAtIEdldCBoaXQgdGVzdCByYXRlIChyYXRlID4gMCBpcyBoaXR0ZWQpXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcbiAgICogICAgIGlmIChtb3ZlYWJsZS5oaXRUZXN0KGUudGFyZ2V0KSA+IDApIHtcbiAgICogICAgICAgICAgY29uc29sZS5sb2coXCJoaWl0ZWRcIik7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uaGl0VGVzdCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHRhcmdldCA9IF9hLnRhcmdldCxcbiAgICAgICAgcG9zMSA9IF9hLnBvczEsXG4gICAgICAgIHBvczIgPSBfYS5wb3MyLFxuICAgICAgICBwb3MzID0gX2EucG9zMyxcbiAgICAgICAgcG9zNCA9IF9hLnBvczQsXG4gICAgICAgIHRhcmdldENsaWVudFJlY3QgPSBfYS50YXJnZXRDbGllbnRSZWN0O1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciByZWN0O1xuXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgdmFyIGNsaWVudFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJlY3QgPSB7XG4gICAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCxcbiAgICAgICAgd2lkdGg6IGNsaWVudFJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3QgPSBfX2Fzc2lnbih7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sIGVsKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjdExlZnQgPSByZWN0LmxlZnQsXG4gICAgICAgIHJlY3RUb3AgPSByZWN0LnRvcCxcbiAgICAgICAgcmVjdFdpZHRoID0gcmVjdC53aWR0aCxcbiAgICAgICAgcmVjdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgIHZhciBwb2ludHMgPSBmaXRQb2ludHMoW3BvczEsIHBvczIsIHBvczQsIHBvczNdLCB0YXJnZXRDbGllbnRSZWN0KTtcbiAgICB2YXIgc2l6ZSA9IGdldE92ZXJsYXBTaXplKHBvaW50cywgW1tyZWN0TGVmdCwgcmVjdFRvcF0sIFtyZWN0TGVmdCArIHJlY3RXaWR0aCwgcmVjdFRvcF0sIFtyZWN0TGVmdCArIHJlY3RXaWR0aCwgcmVjdFRvcCArIHJlY3RIZWlnaHRdLCBbcmVjdExlZnQsIHJlY3RUb3AgKyByZWN0SGVpZ2h0XV0pO1xuICAgIHZhciB0b3RhbFNpemUgPSBnZXRBcmVhU2l6ZShwb2ludHMpO1xuXG4gICAgaWYgKCFzaXplIHx8ICF0b3RhbFNpemUpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1pbigxMDAsIHNpemUgLyB0b3RhbFNpemUgKiAxMDApO1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGluc2lkZSBNb3ZlYWJsZVxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2lzSW5zaWRlXG4gICAqIEBwYXJhbSAtIHggY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0gLSB5IGNvb3JkaW5hdGVcbiAgICogQHJldHVybiAtIFRydWUgaWYgdGhlIGNvb3JkaW5hdGUgaXMgaW4gbW92ZWFibGUgb3IgZmFsc2VcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xuICAgKiAgICAgaWYgKG1vdmVhYmxlLmlzSW5zaWRlKGUuY2xpZW50WCwgZS5jbGllbnRZKSkge1xuICAgKiAgICAgICAgICBjb25zb2xlLmxvZyhcImluc2lkZVwiKTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5pc0luc2lkZSA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgdmFyIF9hID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgdGFyZ2V0ID0gX2EudGFyZ2V0LFxuICAgICAgICBwb3MxID0gX2EucG9zMSxcbiAgICAgICAgcG9zMiA9IF9hLnBvczIsXG4gICAgICAgIHBvczMgPSBfYS5wb3MzLFxuICAgICAgICBwb3M0ID0gX2EucG9zNCxcbiAgICAgICAgdGFyZ2V0Q2xpZW50UmVjdCA9IF9hLnRhcmdldENsaWVudFJlY3Q7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBpc0luc2lkZShbY2xpZW50WCwgY2xpZW50WV0sIGZpdFBvaW50cyhbcG9zMSwgcG9zMiwgcG9zNCwgcG9zM10sIHRhcmdldENsaWVudFJlY3QpKTtcbiAgfTtcbiAgLyoqXG4gICAqIElmIHRoZSB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCBhbmQgdG9wIG9mIGFsbCBlbGVtZW50cyBjaGFuZ2UsIHVwZGF0ZSB0aGUgc2hhcGUgb2YgdGhlIG1vdmVhYmxlLlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI3VwZGF0ZVJlY3RcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZSA9PiB7XG4gICAqICAgICBtb3ZlYWJsZS51cGRhdGVSZWN0KCk7XG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8udXBkYXRlUmVjdCA9IGZ1bmN0aW9uICh0eXBlLCBpc1RhcmdldCwgaXNTZXRTdGF0ZSkge1xuICAgIGlmIChpc1NldFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIGlzU2V0U3RhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBhcmVudE1vdmVhYmxlID0gcHJvcHMucGFyZW50TW92ZWFibGU7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0IHx8IHRoaXMucHJvcHMudGFyZ2V0O1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcigpO1xuICAgIHZhciByb290Q29udGFpbmVyID0gcGFyZW50TW92ZWFibGUgPyBwYXJlbnRNb3ZlYWJsZS5wcm9wcy5yb290Q29udGFpbmVyIDogcHJvcHMucm9vdENvbnRhaW5lcjtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKGdldFRhcmdldEluZm8odGhpcy5jb250cm9sQm94ICYmIHRoaXMuY29udHJvbEJveC5nZXRFbGVtZW50KCksIHRhcmdldCwgY29udGFpbmVyLCBjb250YWluZXIsIHJvb3RDb250YWluZXIgfHwgY29udGFpbmVyKSwgcGFyZW50TW92ZWFibGUgPyBmYWxzZSA6IGlzU2V0U3RhdGUpO1xuICB9O1xuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIG1vdmVhYmxlIHN0YXRlIGlzIGJlaW5nIGRyYWdnZWQuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjaXNEcmFnZ2luZ1xuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiAvLyBmYWxzZVxuICAgKiBjb25zb2xlLmxvZyhtb3ZlYWJsZS5pc0RyYWdnaW5nKCkpO1xuICAgKlxuICAgKiBtb3ZlYWJsZS5vbihcImRyYWdcIiwgKCkgPT4ge1xuICAgKiAgIC8vIHRydWVcbiAgICogICBjb25zb2xlLmxvZyhtb3ZlYWJsZS5pc0RyYWdnaW5nKCkpO1xuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnRhcmdldEdlc3RvID8gdGhpcy50YXJnZXRHZXN0by5pc0ZsYWcoKSA6IGZhbHNlKSB8fCAodGhpcy5jb250cm9sR2VzdG8gPyB0aGlzLmNvbnRyb2xHZXN0by5pc0ZsYWcoKSA6IGZhbHNlKTtcbiAgfTtcbiAgLyoqXG4gICAqIElmIHRoZSB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCBhbmQgdG9wIG9mIHRoZSBvbmx5IHRhcmdldCBjaGFuZ2UsIHVwZGF0ZSB0aGUgc2hhcGUgb2YgdGhlIG1vdmVhYmxlLlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI3VwZGF0ZVRhcmdldFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiBtb3ZlYWJsZS51cGRhdGVUYXJnZXQoKTtcbiAgICovXG5cblxuICBfX3Byb3RvLnVwZGF0ZVRhcmdldCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdGhpcy51cGRhdGVSZWN0KHR5cGUsIHRydWUpO1xuICB9O1xuICAvKipcbiAgICogWW91IGNhbiBnZXQgdGhlIHZlcnRleCBpbmZvcm1hdGlvbiwgcG9zaXRpb24gYW5kIG9mZnNldCBzaXplIGluZm9ybWF0aW9uIG9mIHRoZSB0YXJnZXQgYmFzZWQgb24gdGhlIGNvbnRhaW5lci5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNnZXRSZWN0XG4gICAqIEByZXR1cm4gLSBUaGUgUmVjdCBJbmZvXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIGNvbnN0IHJlY3RJbmZvID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKHRoaXMuc3RhdGUpO1xuICAgIHZhciBwb3MxID0gcG9zZXNbMF0sXG4gICAgICAgIHBvczIgPSBwb3Nlc1sxXSxcbiAgICAgICAgcG9zMyA9IHBvc2VzWzJdLFxuICAgICAgICBwb3M0ID0gcG9zZXNbM107XG4gICAgdmFyIHJlY3QgPSBnZXRSZWN0KHBvc2VzKTtcbiAgICB2YXIgb2Zmc2V0V2lkdGggPSBzdGF0ZS53aWR0aCxcbiAgICAgICAgb2Zmc2V0SGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xuICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICB0b3AgPSByZWN0LnRvcDtcbiAgICB2YXIgc3RhdGVQb3MgPSBbc3RhdGUubGVmdCwgc3RhdGUudG9wXTtcbiAgICB2YXIgb3JpZ2luID0gcGx1cyhzdGF0ZVBvcywgc3RhdGUub3JpZ2luKTtcbiAgICB2YXIgYmVmb3JlT3JpZ2luID0gcGx1cyhzdGF0ZVBvcywgc3RhdGUuYmVmb3JlT3JpZ2luKTtcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIHBvczE6IHBvczEsXG4gICAgICBwb3MyOiBwb3MyLFxuICAgICAgcG9zMzogcG9zMyxcbiAgICAgIHBvczQ6IHBvczQsXG4gICAgICBvZmZzZXRXaWR0aDogb2Zmc2V0V2lkdGgsXG4gICAgICBvZmZzZXRIZWlnaHQ6IG9mZnNldEhlaWdodCxcbiAgICAgIGJlZm9yZU9yaWdpbjogYmVmb3JlT3JpZ2luLFxuICAgICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpbixcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKClcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogR2V0IGEgbWFuYWdlciB0aGF0IG1hbmFnZXMgdGhlIG1vdmVhYmxlJ3Mgc3RhdGUgYW5kIHByb3BzLlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2dldE1hbmFnZXJcbiAgICogQHJldHVybiAtIFRoZSBSZWN0IEluZm9cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogY29uc3QgbWFuYWdlciA9IG1vdmVhYmxlLmdldE1hbmFnZXIoKTsgLy8gcmVhbCBtb3ZlYWJsZSBjbGFzcyBpbnN0YW5jZVxuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfX3Byb3RvLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHBvczEgPSBfYS5wb3MxLFxuICAgICAgICBwb3MyID0gX2EucG9zMixcbiAgICAgICAgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uO1xuICAgIHJldHVybiBnZXRBYnNvbHV0ZVJvdGF0aW9uKHBvczEsIHBvczIsIGRpcmVjdGlvbik7XG4gIH07XG4gIC8qKlxuICAgKiBSZXF1ZXN0IGFibGUgdGhyb3VnaCBhIG1ldGhvZCByYXRoZXIgdGhhbiBhbiBldmVudC5cbiAgICogQXQgdGhlIG1vbWVudCBvZiBleGVjdXRpb24sIHJlcXVlc3RTdGFydCBpcyBleGVjdXRlZCxcbiAgICogYW5kIHRoZW4gcmVxdWVzdCBhbmQgcmVxdWVzdEVuZCBjYW4gYmUgZXhlY3V0ZWQgdGhyb3VnaCBSZXF1ZXN0ZXIuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjcmVxdWVzdFxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuRHJhZ2dhYmxlLmh0bWwjcmVxdWVzdHxEcmFnZ2FibGUgUmVxdWVzdGVyfVxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuUmVzaXphYmxlLmh0bWwjcmVxdWVzdHxSZXNpemFibGUgUmVxdWVzdGVyfVxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU2NhbGFibGUuaHRtbCNyZXF1ZXN0fFNjYWxhYmxlIFJlcXVlc3Rlcn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlJvdGF0YWJsZS5odG1sI3JlcXVlc3R8Um90YXRhYmxlIFJlcXVlc3Rlcn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZS5odG1sI3JlcXVlc3R8T3JpZ2luRHJhZ2dhYmxlIFJlcXVlc3Rlcn1cbiAgICogQHBhcmFtIC0gYWJsZU5hbWVcbiAgICogQHBhcmFtIC0gcmVxdWVzdCB0byBiZSBhYmxlIHBhcmFtcy5cbiAgICogQHBhcmFtIC0gSWYgaXNJbnN0YW50IGlzIHRydWUsIHJlcXVlc3QgYW5kIHJlcXVlc3RFbmQgYXJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICAgKiBAcmV0dXJuIC0gQWJsZSBSZXF1ZXN0ZXIuIElmIHRoZXJlIGlzIG5vIHJlcXVlc3QgaW4gYWJsZSwgbm90aGluZyB3aWxsIHdvcmsuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcbiAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSwgdHJ1ZSk7XG4gICAqXG4gICAqIC8vIFN0YXJ0IG1vdmVcbiAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiKTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgICovXG5cblxuICBfX3Byb3RvLnJlcXVlc3QgPSBmdW5jdGlvbiAoYWJsZU5hbWUsIHBhcmFtLCBpc0luc3RhbnQpIHtcbiAgICBpZiAocGFyYW0gPT09IHZvaWQgMCkge1xuICAgICAgcGFyYW0gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSB0aGlzLnByb3BzLFxuICAgICAgICBhYmxlcyA9IF9hLmFibGVzLFxuICAgICAgICBncm91cGFibGUgPSBfYS5ncm91cGFibGU7XG4gICAgdmFyIHJlcXVzZXRBYmxlID0gYWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICByZXR1cm4gYWJsZS5uYW1lID09PSBhYmxlTmFtZTtcbiAgICB9KVswXTtcblxuICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSB8fCAhcmVxdXNldEFibGUgfHwgIXJlcXVzZXRBYmxlLnJlcXVlc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWJsZVJlcXVlc3RlciA9IHJlcXVzZXRBYmxlLnJlcXVlc3QodGhpcyk7XG4gICAgdmFyIHJlcXVlc3RJbnN0YW50ID0gaXNJbnN0YW50IHx8IHBhcmFtLmlzSW5zdGFudDtcbiAgICB2YXIgYWJsZVR5cGUgPSBhYmxlUmVxdWVzdGVyLmlzQ29udHJvbCA/IFwiY29udHJvbEFibGVzXCIgOiBcInRhcmdldEFibGVzXCI7XG4gICAgdmFyIGV2ZW50QWZmaXggPSBcIlwiLmNvbmNhdChncm91cGFibGUgPyBcIkdyb3VwXCIgOiBcIlwiKS5jb25jYXQoYWJsZVJlcXVlc3Rlci5pc0NvbnRyb2wgPyBcIkNvbnRyb2xcIiA6IFwiXCIpO1xuICAgIHZhciByZXF1ZXN0ZXIgPSB7XG4gICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoYWJsZVBhcmFtKSB7XG4gICAgICAgIHRyaWdnZXJBYmxlKHNlbGYsIGFibGVUeXBlLCBcImRyYWdcIiwgZXZlbnRBZmZpeCwgXCJcIiwgX19hc3NpZ24oX19hc3NpZ24oe30sIGFibGVSZXF1ZXN0ZXIucmVxdWVzdChhYmxlUGFyYW0pKSwge1xuICAgICAgICAgIHJlcXVlc3RBYmxlOiBhYmxlTmFtZSxcbiAgICAgICAgICBpc1JlcXVlc3Q6IHRydWVcbiAgICAgICAgfSksIHJlcXVlc3RJbnN0YW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmlnZ2VyQWJsZShzZWxmLCBhYmxlVHlwZSwgXCJkcmFnXCIsIGV2ZW50QWZmaXgsIFwiRW5kXCIsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhYmxlUmVxdWVzdGVyLnJlcXVlc3RFbmQoKSksIHtcbiAgICAgICAgICByZXF1ZXN0QWJsZTogYWJsZU5hbWUsXG4gICAgICAgICAgaXNSZXF1ZXN0OiB0cnVlXG4gICAgICAgIH0pLCByZXF1ZXN0SW5zdGFudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gICAgdHJpZ2dlckFibGUoc2VsZiwgYWJsZVR5cGUsIFwiZHJhZ1wiLCBldmVudEFmZml4LCBcIlN0YXJ0XCIsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhYmxlUmVxdWVzdGVyLnJlcXVlc3RTdGFydChwYXJhbSkpLCB7XG4gICAgICByZXF1ZXN0QWJsZTogYWJsZU5hbWUsXG4gICAgICBpc1JlcXVlc3Q6IHRydWVcbiAgICB9KSwgcmVxdWVzdEluc3RhbnQpO1xuICAgIHJldHVybiByZXF1ZXN0SW5zdGFudCA/IHJlcXVlc3Rlci5yZXF1ZXN0KHBhcmFtKS5yZXF1ZXN0RW5kKCkgOiByZXF1ZXN0ZXI7XG4gIH07XG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIE1vdmVhYmxlIG9iamVjdCBhbmQgdGhlIGV2ZW50cy5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNkZXN0cm95XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIG1vdmVhYmxlLmRlc3Ryb3koKTtcbiAgICovXG5cblxuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9O1xuXG4gIF9fcHJvdG8udXBkYXRlUmVuZGVyUG9zZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBvcmlnaW5hbEJlZm9yZU9yaWdpbiA9IHN0YXRlLm9yaWdpbmFsQmVmb3JlT3JpZ2luLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICAgIGFsbE1hdHJpeCA9IHN0YXRlLmFsbE1hdHJpeCxcbiAgICAgICAgaXMzZCA9IHN0YXRlLmlzM2QsXG4gICAgICAgIHBvczEgPSBzdGF0ZS5wb3MxLFxuICAgICAgICBwb3MyID0gc3RhdGUucG9zMixcbiAgICAgICAgcG9zMyA9IHN0YXRlLnBvczMsXG4gICAgICAgIHBvczQgPSBzdGF0ZS5wb3M0LFxuICAgICAgICBzdGF0ZUxlZnQgPSBzdGF0ZS5sZWZ0LFxuICAgICAgICBzdGF0ZVRvcCA9IHN0YXRlLnRvcDtcblxuICAgIHZhciBfYSA9IHByb3BzLnBhZGRpbmcgfHwge30sXG4gICAgICAgIF9iID0gX2EubGVmdCxcbiAgICAgICAgbGVmdCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsXG4gICAgICAgIF9jID0gX2EudG9wLFxuICAgICAgICB0b3AgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLFxuICAgICAgICBfZCA9IF9hLmJvdHRvbSxcbiAgICAgICAgYm90dG9tID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCxcbiAgICAgICAgX2UgPSBfYS5yaWdodCxcbiAgICAgICAgcmlnaHQgPSBfZSA9PT0gdm9pZCAwID8gMCA6IF9lO1xuXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gICAgdmFyIGFic29sdXRlT3JpZ2luID0gcHJvcHMuZ3JvdXBhYmxlID8gb3JpZ2luYWxCZWZvcmVPcmlnaW4gOiBwbHVzKG9yaWdpbmFsQmVmb3JlT3JpZ2luLCBbc3RhdGVMZWZ0LCBzdGF0ZVRvcF0pO1xuICAgIHN0YXRlLnJlbmRlclBvc2VzID0gW3BsdXMocG9zMSwgY2FsY3VsYXRlUGFkZGluZyhhbGxNYXRyaXgsIFstbGVmdCwgLXRvcF0sIHRyYW5zZm9ybU9yaWdpbiwgYWJzb2x1dGVPcmlnaW4sIG4pKSwgcGx1cyhwb3MyLCBjYWxjdWxhdGVQYWRkaW5nKGFsbE1hdHJpeCwgW3JpZ2h0LCAtdG9wXSwgdHJhbnNmb3JtT3JpZ2luLCBhYnNvbHV0ZU9yaWdpbiwgbikpLCBwbHVzKHBvczMsIGNhbGN1bGF0ZVBhZGRpbmcoYWxsTWF0cml4LCBbLWxlZnQsIGJvdHRvbV0sIHRyYW5zZm9ybU9yaWdpbiwgYWJzb2x1dGVPcmlnaW4sIG4pKSwgcGx1cyhwb3M0LCBjYWxjdWxhdGVQYWRkaW5nKGFsbE1hdHJpeCwgW3JpZ2h0LCBib3R0b21dLCB0cmFuc2Zvcm1PcmlnaW4sIGFic29sdXRlT3JpZ2luLCBuKSldO1xuICB9O1xuXG4gIF9fcHJvdG8uY2hlY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcyxcbiAgICAgICAgdGFyZ2V0ID0gX2EudGFyZ2V0LFxuICAgICAgICBjb250YWluZXIgPSBfYS5jb250YWluZXIsXG4gICAgICAgIHBhcmVudE1vdmVhYmxlID0gX2EucGFyZW50TW92ZWFibGU7XG4gICAgdmFyIF9iID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgc3RhdGVUYXJnZXQgPSBfYi50YXJnZXQsXG4gICAgICAgIHN0YXRlQ29udGFpbmVyID0gX2IuY29udGFpbmVyO1xuXG4gICAgaWYgKCFzdGF0ZVRhcmdldCAmJiAhdGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVBYmxlcygpO1xuICAgIHZhciBpc0NoYW5nZWQgPSAhZXF1YWxzKHN0YXRlVGFyZ2V0LCB0YXJnZXQpIHx8ICFlcXVhbHMoc3RhdGVDb250YWluZXIsIGNvbnRhaW5lcik7XG5cbiAgICBpZiAoIWlzQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtb3ZlYWJsZUNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCB0aGlzLmNvbnRyb2xCb3g7XG5cbiAgICBpZiAobW92ZWFibGVDb250YWluZXIpIHtcbiAgICAgIHRoaXMudW5zZXRBYmxlcygpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICAgIH0pO1xuXG4gICAgaWYgKCFwYXJlbnRNb3ZlYWJsZSAmJiBtb3ZlYWJsZUNvbnRhaW5lcikge1xuICAgICAgdGhpcy51cGRhdGVSZWN0KFwiRW5kXCIsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8udHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGUpIHtcbiAgICB0aGlzLl9lbWl0dGVyLnRyaWdnZXIobmFtZSwgZSk7XG5cbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLnByb3BzW25hbWVdO1xuICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjayhlKTtcbiAgfTtcblxuICBfX3Byb3RvLnVzZUNTUyA9IGZ1bmN0aW9uICh0YWcsIGNzcykge1xuICAgIHZhciBjdXN0b21TdHlsZU1hcCA9IHRoaXMucHJvcHMuY3VzdG9tU3R5bGVkTWFwO1xuICAgIHZhciBrZXkgPSB0YWcgKyBjc3M7XG5cbiAgICBpZiAoIWN1c3RvbVN0eWxlTWFwW2tleV0pIHtcbiAgICAgIGN1c3RvbVN0eWxlTWFwW2tleV0gPSBzdHlsZWQodGFnLCBjc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXN0b21TdHlsZU1hcFtrZXldO1xuICB9O1xuXG4gIF9fcHJvdG8udW5zZXRBYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy50YXJnZXRBYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICBpZiAoYWJsZS51bnNldCkge1xuICAgICAgICBhYmxlLnVuc2V0KF90aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLnVwZGF0ZUFibGVzID0gZnVuY3Rpb24gKGFibGVzLCBldmVudEFmZml4KSB7XG4gICAgaWYgKGFibGVzID09PSB2b2lkIDApIHtcbiAgICAgIGFibGVzID0gdGhpcy5wcm9wcy5hYmxlcztcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRBZmZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICBldmVudEFmZml4ID0gXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSA9IHByb3BzLnRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5O1xuICAgIHZhciBlbmFibGVkQWJsZXMgPSBhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIHJldHVybiBhYmxlICYmIChhYmxlLmFsd2F5cyAmJiBwcm9wc1thYmxlLm5hbWVdICE9PSBmYWxzZSB8fCBwcm9wc1thYmxlLm5hbWVdKTtcbiAgICB9KTtcbiAgICB2YXIgZHJhZ1N0YXJ0ID0gXCJkcmFnXCIuY29uY2F0KGV2ZW50QWZmaXgsIFwiU3RhcnRcIik7XG4gICAgdmFyIHBpbmNoU3RhcnQgPSBcInBpbmNoXCIuY29uY2F0KGV2ZW50QWZmaXgsIFwiU3RhcnRcIik7XG4gICAgdmFyIGRyYWdDb250cm9sU3RhcnQgPSBcImRyYWdcIi5jb25jYXQoZXZlbnRBZmZpeCwgXCJDb250cm9sU3RhcnRcIik7XG4gICAgdmFyIHRhcmdldEFibGVzID0gZmlsdGVyQWJsZXMoZW5hYmxlZEFibGVzLCBbZHJhZ1N0YXJ0LCBwaW5jaFN0YXJ0XSwgdHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHkpO1xuICAgIHZhciBjb250cm9sQWJsZXMgPSBmaWx0ZXJBYmxlcyhlbmFibGVkQWJsZXMsIFtkcmFnQ29udHJvbFN0YXJ0XSwgdHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHkpO1xuICAgIHRoaXMuZW5hYmxlZEFibGVzID0gZW5hYmxlZEFibGVzO1xuICAgIHRoaXMudGFyZ2V0QWJsZXMgPSB0YXJnZXRBYmxlcztcbiAgICB0aGlzLmNvbnRyb2xBYmxlcyA9IGNvbnRyb2xBYmxlcztcbiAgfTtcblxuICBfX3Byb3RvLnVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKG5leHRTdGF0ZSwgaXNTZXRTdGF0ZSkge1xuICAgIGlmIChpc1NldFN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5pc1VubW91bnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0U3RhdGUpIHtcbiAgICAgICAgc3RhdGVbbmFtZV0gPSBuZXh0U3RhdGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uZ2V0RW5hYmxlZEFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFibGVzID0gcHJvcHMuYWJsZXM7XG4gICAgcmV0dXJuIGFibGVzLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgcmV0dXJuIGFibGUgJiYgcHJvcHNbYWJsZS5uYW1lXTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLnJlbmRlckFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSA9IHByb3BzLnRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5O1xuICAgIHZhciBSZW5kZXJlciA9IHtcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRcbiAgICB9O1xuICAgIHJldHVybiBncm91cEJ5TWFwKGZsYXQoZmlsdGVyQWJsZXModGhpcy5nZXRFbmFibGVkQWJsZXMoKSwgW1wicmVuZGVyXCJdLCB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSkubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIHJlbmRlciA9IF9hLnJlbmRlcjtcbiAgICAgIHJldHVybiByZW5kZXIoX3RoaXMsIFJlbmRlcmVyKSB8fCBbXTtcbiAgICB9KSkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH0pLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBrZXkgPSBfYS5rZXk7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0pLm1hcChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgIHJldHVybiBncm91cFswXTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLnVwZGF0ZUNoZWNrSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50YXJnZXRHZXN0byAmJiAodGhpcy50YXJnZXRHZXN0by5vcHRpb25zLmNoZWNrSW5wdXQgPSB0aGlzLnByb3BzLmNoZWNrSW5wdXQpO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZU9ic2VydmVyID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRhcmdldCA9IHByb3BzLnRhcmdldDtcblxuICAgIGlmICghd2luZG93LlJlc2l6ZU9ic2VydmVyIHx8ICF0YXJnZXQgfHwgIXByb3BzLnVzZVJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAoX2EgPSB0aGlzLl9vYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJldlByb3BzLnRhcmdldCA9PT0gdGFyZ2V0ICYmIHRoaXMuX29ic2VydmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuY2hlY2tVcGRhdGVSZWN0KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xuICAgICAgYm94OiBcImJvcmRlci1ib3hcIlxuICAgIH0pO1xuICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbEJveEVsZW1lbnQgPSB0aGlzLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpO1xuICAgIHZhciBoYXNUYXJnZXRBYmxlID0gdGhpcy50YXJnZXRBYmxlcy5sZW5ndGg7XG4gICAgdmFyIGhhc0NvbnRyb2xBYmxlID0gdGhpcy5jb250cm9sQWJsZXMubGVuZ3RoO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRhcmdldCA9IHByb3BzLmRyYWdUYXJnZXQgfHwgcHJvcHMudGFyZ2V0O1xuXG4gICAgdmFyIGlzVW5zZXQgPSAhaGFzVGFyZ2V0QWJsZSAmJiB0aGlzLnRhcmdldEdlc3RvIHx8IHRoaXMuX2lzVGFyZ2V0Q2hhbmdlZCh0cnVlKTtcblxuICAgIGlmIChpc1Vuc2V0KSB7XG4gICAgICB1bnNldCh0aGlzLCBcInRhcmdldEdlc3RvXCIpO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGdlc3RvOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc0NvbnRyb2xBYmxlKSB7XG4gICAgICB1bnNldCh0aGlzLCBcImNvbnRyb2xHZXN0b1wiKTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0ICYmIGhhc1RhcmdldEFibGUgJiYgIXRoaXMudGFyZ2V0R2VzdG8pIHtcbiAgICAgIHRoaXMudGFyZ2V0R2VzdG8gPSBnZXRUYXJnZXRBYmxlR2VzdG8odGhpcywgdGFyZ2V0LCBcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udHJvbEdlc3RvICYmIGhhc0NvbnRyb2xBYmxlKSB7XG4gICAgICB0aGlzLmNvbnRyb2xHZXN0byA9IGdldEFibGVHZXN0byh0aGlzLCBjb250cm9sQm94RWxlbWVudCwgXCJjb250cm9sQWJsZXNcIiwgXCJDb250cm9sXCIpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLl91cGRhdGVUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5fcHJldlRhcmdldCA9IHByb3BzLmRyYWdUYXJnZXQgfHwgcHJvcHMudGFyZ2V0O1xuICAgIHRoaXMuX3ByZXZEcmFnQXJlYSA9IHByb3BzLmRyYWdBcmVhO1xuICB9O1xuXG4gIF9fcHJvdG8uX3JlbmRlckxpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGVkZ2UgPSBwcm9wcy5lZGdlLFxuICAgICAgICB6b29tID0gcHJvcHMuem9vbSxcbiAgICAgICAgaGlkZURlZmF1bHRMaW5lcyA9IHByb3BzLmhpZGVEZWZhdWx0TGluZXM7XG5cbiAgICBpZiAoaGlkZURlZmF1bHRMaW5lcykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJQb3NlcyA9IHRoaXMuc3RhdGUucmVuZGVyUG9zZXM7XG4gICAgdmFyIFJlbmRlcmVyID0ge1xuICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFxuICAgIH07XG4gICAgcmV0dXJuIFtyZW5kZXJMaW5lKFJlbmRlcmVyLCBlZGdlID8gXCJuXCIgOiBcIlwiLCByZW5kZXJQb3Nlc1swXSwgcmVuZGVyUG9zZXNbMV0sIHpvb20sIDApLCByZW5kZXJMaW5lKFJlbmRlcmVyLCBlZGdlID8gXCJlXCIgOiBcIlwiLCByZW5kZXJQb3Nlc1sxXSwgcmVuZGVyUG9zZXNbM10sIHpvb20sIDEpLCByZW5kZXJMaW5lKFJlbmRlcmVyLCBlZGdlID8gXCJ3XCIgOiBcIlwiLCByZW5kZXJQb3Nlc1swXSwgcmVuZGVyUG9zZXNbMl0sIHpvb20sIDIpLCByZW5kZXJMaW5lKFJlbmRlcmVyLCBlZGdlID8gXCJzXCIgOiBcIlwiLCByZW5kZXJQb3Nlc1syXSwgcmVuZGVyUG9zZXNbM10sIHpvb20sIDMpXTtcbiAgfTtcblxuICBfX3Byb3RvLl9pc1RhcmdldENoYW5nZWQgPSBmdW5jdGlvbiAodXNlRHJhZ0FyZWEpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0YXJnZXQgPSBwcm9wcy5kcmFnVGFyZ2V0IHx8IHByb3BzLnRhcmdldDtcbiAgICB2YXIgcHJldlRhcmdldCA9IHRoaXMuX3ByZXZUYXJnZXQ7XG4gICAgdmFyIHByZXZEcmFnQXJlYSA9IHRoaXMuX3ByZXZEcmFnQXJlYTtcbiAgICB2YXIgZHJhZ0FyZWEgPSBwcm9wcy5kcmFnQXJlYTsgLy8gY2hlY2sgdGFyZ2V0IHdpdGhvdXQgZHJhZ0FyZWFcblxuICAgIHZhciBpc1RhcmdldENoYW5nZWQgPSAhZHJhZ0FyZWEgJiYgcHJldlRhcmdldCAhPT0gdGFyZ2V0O1xuICAgIHZhciBpc0RyYWdBcmVhQ2hhbmdlZCA9ICh1c2VEcmFnQXJlYSB8fCBkcmFnQXJlYSkgJiYgcHJldkRyYWdBcmVhICE9PSBkcmFnQXJlYTtcbiAgICByZXR1cm4gaXNUYXJnZXRDaGFuZ2VkIHx8IGlzRHJhZ0FyZWFDaGFuZ2VkO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZU5hdGl2ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdGFyZ2V0ID0gcHJvcHMuZHJhZ0FyZWEgPyB0aGlzLmFyZWFFbGVtZW50IDogdGhpcy5zdGF0ZS50YXJnZXQ7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgIHZhciBldmVudEtleXMgPSBnZXRLZXlzKGV2ZW50cyk7XG5cbiAgICBpZiAodGhpcy5faXNUYXJnZXRDaGFuZ2VkKCkpIHtcbiAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudHMpIHtcbiAgICAgICAgdmFyIG1hbmFnZXIgPSBldmVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgbWFuYWdlciAmJiBtYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVuYWJsZWRBYmxlcyA9IHRoaXMuZW5hYmxlZEFibGVzO1xuICAgIGV2ZW50S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgIHZhciBhYmxlcyA9IGZpbHRlckFibGVzKGVuYWJsZWRBYmxlcywgW2V2ZW50TmFtZV0pO1xuICAgICAgdmFyIGhhc0FibGVzID0gYWJsZXMubGVuZ3RoID4gMDtcbiAgICAgIHZhciBtYW5hZ2VyID0gZXZlbnRzW2V2ZW50TmFtZV07XG5cbiAgICAgIGlmICghaGFzQWJsZXMpIHtcbiAgICAgICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgICBtYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbWFuYWdlcikge1xuICAgICAgICBtYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcih0YXJnZXQsIF90aGlzLCBldmVudE5hbWUpO1xuICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IG1hbmFnZXI7XG4gICAgICB9XG5cbiAgICAgIG1hbmFnZXIuc2V0QWJsZXMoYWJsZXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIE1vdmVhYmxlTWFuYWdlci5kZWZhdWx0UHJvcHMgPSB7XG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIGRyYWdUYXJnZXQ6IG51bGwsXG4gICAgY29udGFpbmVyOiBudWxsLFxuICAgIHJvb3RDb250YWluZXI6IG51bGwsXG4gICAgb3JpZ2luOiB0cnVlLFxuICAgIGVkZ2U6IGZhbHNlLFxuICAgIHBhcmVudE1vdmVhYmxlOiBudWxsLFxuICAgIHdyYXBwZXJNb3ZlYWJsZTogbnVsbCxcbiAgICBwYXJlbnRQb3NpdGlvbjogbnVsbCxcbiAgICBwb3J0YWxDb250YWluZXI6IG51bGwsXG4gICAgdXNlUmVzaXplT2JzZXJ2ZXI6IGZhbHNlLFxuICAgIGFibGVzOiBbXSxcbiAgICBwaW5jaFRocmVzaG9sZDogMjAsXG4gICAgZHJhZ0FyZWE6IGZhbHNlLFxuICAgIHBhc3NEcmFnQXJlYTogZmFsc2UsXG4gICAgdHJhbnNmb3JtT3JpZ2luOiBcIlwiLFxuICAgIGNsYXNzTmFtZTogXCJcIixcbiAgICB6b29tOiAxLFxuICAgIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5OiBmYWxzZSxcbiAgICBwYWRkaW5nOiB7fSxcbiAgICBwaW5jaE91dHNpZGU6IHRydWUsXG4gICAgY2hlY2tJbnB1dDogZmFsc2UsXG4gICAgZ3JvdXBhYmxlOiBmYWxzZSxcbiAgICBoaWRlRGVmYXVsdExpbmVzOiBmYWxzZSxcbiAgICBjc3BOb25jZTogXCJcIixcbiAgICB0cmFuc2xhdGVaOiAwLFxuICAgIGNzc1N0eWxlZDogbnVsbCxcbiAgICBjdXN0b21TdHlsZWRNYXA6IHt9LFxuICAgIHByb3BzOiB7fSxcbiAgICBmbHVzaFN5bmM6IGRlZmF1bHRTeW5jXG4gIH07XG4gIHJldHVybiBNb3ZlYWJsZU1hbmFnZXI7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuLyoqXG4gKiBUaGUgdGFyZ2V0IHRvIGluZGljYXRlIE1vdmVhYmxlIENvbnRyb2wgQm94LlxuICogQG5hbWUgTW92ZWFibGUjdGFyZ2V0XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICogbW92ZWFibGUudGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIik7XG4gKi9cblxuLyoqXG4gKiBab29tcyBpbiB0aGUgZWxlbWVudHMgb2YgYSBtb3ZlYWJsZS5cbiAqIEBuYW1lIE1vdmVhYmxlI3pvb21cbiAqIEBkZWZhdWx0IDFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKiBtb3ZlYWJsZS56b29tID0gMjtcbiAqL1xuXG4vKipcbiAqIFdoZXRoZXIgdGhlIHRhcmdldCBzaXplIGlzIGRldGVjdGVkIGFuZCB1cGRhdGVkIHdoZW5ldmVyIGl0IGNoYW5nZXMuXG4gKiBAbmFtZSBNb3ZlYWJsZSN6b29tXG4gKiBAZGVmYXVsdCBmYWxzZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqIG1vdmVhYmxlLnVzZVJlc2l6ZU9ic2VydmVyID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFJlc2l6ZSwgU2NhbGUgRXZlbnRzIGF0IGVkZ2VzXG4gKiBAbmFtZSBNb3ZlYWJsZSNlZGdlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICogbW92ZWFibGUuZWRnZSA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBZb3UgY2FuIHNwZWNpZnkgdGhlIGNsYXNzTmFtZSBvZiB0aGUgbW92ZWFibGUgY29udHJvbGJveC5cbiAqIEBuYW1lIE1vdmVhYmxlI2NsYXNzTmFtZVxuICogQGRlZmF1bHQgXCJcIlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIGNsYXNzTmFtZTogXCJcIixcbiAqIH0pO1xuICpcbiAqIG1vdmVhYmxlLmNsYXNzTmFtZSA9IFwibW92ZWFibGUxXCI7XG4gKi9cblxuLyoqXG4gKiBUaGUgdGFyZ2V0KHMpIHRvIGRyYWcgTW92ZWFibGUgdGFyZ2V0KHMpXG4gKiBAbmFtZSBNb3ZlYWJsZSNkcmFnVGFyZ2V0XG4gKiBAZGVmYXVsdCB0YXJnZXRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKiBtb3ZlYWJsZS50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKTtcbiAqIG1vdmVhYmxlLmRyYWdUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmRyYWdUYXJnZXRcIik7XG4gKi9cblxuLyoqXG4gKiBgcmVuZGVyU3RhcnRgIGV2ZW50IG9jY3VycyBhdCB0aGUgZmlyc3Qgc3RhcnQgb2YgYWxsIGV2ZW50cy5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGV2ZW50IHJlbmRlclN0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uUmVuZGVyU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJTdGFydGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVuZGVyU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUmVuZGVyU3RhcnRcIiwgdGFyZ2V0KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogYHJlbmRlcmAgZXZlbnQgb2NjdXJzIGJlZm9yZSB0aGUgdGFyZ2V0IGlzIGRyYXduIG9uIHRoZSBzY3JlZW4uXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBldmVudCByZW5kZXJcbiAqIEBwYXJhbSB7TW92ZWFibGUuT25SZW5kZXJ9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJlbmRlclwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25SZW5kZXJcIiwgdGFyZ2V0KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogYHJlbmRlckVuZGAgZXZlbnQgb2NjdXJzIGF0IHRoZSBlbmQgb2YgYWxsIGV2ZW50cy5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGV2ZW50IHJlbmRlckVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5PblJlbmRlckVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlbmRlckVuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVuZGVyRW5kXCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlbmRlckVuZFwiLCB0YXJnZXQpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBgcmVuZGVyR3JvdXBTdGFydGAgZXZlbnQgb2NjdXJzIGF0IHRoZSBmaXJzdCBzdGFydCBvZiBhbGwgZXZlbnRzIGluIGdyb3VwLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZXZlbnQgcmVuZGVyR3JvdXBTdGFydFxuICogQHBhcmFtIHtNb3ZlYWJsZS5PblJlbmRlckdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJHcm91cFN0YXJ0YCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyZW5kZXJHcm91cFN0YXJ0XCIsICh7IHRhcmdldHMgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25SZW5kZXJHcm91cFN0YXJ0XCIsIHRhcmdldHMpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBgcmVuZGVyR3JvdXBgIGV2ZW50IG9jY3VycyBiZWZvcmUgdGhlIHRhcmdldCBpcyBkcmF3biBvbiB0aGUgc2NyZWVuIGluIGdyb3VwLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZXZlbnQgcmVuZGVyR3JvdXBcbiAqIEBwYXJhbSB7TW92ZWFibGUuT25SZW5kZXJHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlbmRlckdyb3VwYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyZW5kZXJHcm91cFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUmVuZGVyR3JvdXBcIiwgdGFyZ2V0cyk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIGByZW5kZXJHcm91cEVuZGAgZXZlbnQgb2NjdXJzIGF0IHRoZSBlbmQgb2YgYWxsIGV2ZW50cyBpbiBncm91cC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGV2ZW50IHJlbmRlckdyb3VwRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uUmVuZGVyR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJHcm91cEVuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVuZGVyR3JvdXBFbmRcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlbmRlckdyb3VwRW5kXCIsIHRhcmdldHMpO1xuICogfSk7XG4gKi9cblxuXG52YXIgR3JvdXBhYmxlID0ge1xuICBuYW1lOiBcImdyb3VwYWJsZVwiLFxuICBwcm9wczoge1xuICAgIGRlZmF1bHRHcm91cFJvdGF0ZTogTnVtYmVyLFxuICAgIGRlZmF1bHRHcm91cE9yaWdpbjogU3RyaW5nLFxuICAgIGdyb3VwYWJsZTogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHt9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IG1vdmVhYmxlLnByb3BzLnRhcmdldHMgfHwgW107XG4gICAgbW92ZWFibGUubW92ZWFibGVzID0gW107XG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIGxlZnQgPSBfYS5sZWZ0LFxuICAgICAgICB0b3AgPSBfYS50b3A7XG4gICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHRvcDogdG9wXG4gICAgfTtcbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcbiAgICByZXR1cm4gdGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHRhcmdldCwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW92ZWFibGVNYW5hZ2VyLCB7XG4gICAgICAgIGtleTogXCJtb3ZlYWJsZVwiICsgaSxcbiAgICAgICAgcmVmOiByZWZzKG1vdmVhYmxlLCBcIm1vdmVhYmxlc1wiLCBpKSxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIG9yaWdpbjogZmFsc2UsXG4gICAgICAgIGNzc1N0eWxlZDogcHJvcHMuY3NzU3R5bGVkLFxuICAgICAgICBjdXN0b21TdHlsZWRNYXA6IHByb3BzLmN1c3RvbVN0eWxlZE1hcCxcbiAgICAgICAgdXNlUmVzaXplT2JzZXJ2ZXI6IHByb3BzLnVzZVJlc2l6ZU9ic2VydmVyLFxuICAgICAgICBwYXJlbnRNb3ZlYWJsZTogbW92ZWFibGUsXG4gICAgICAgIHBhcmVudFBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgQ2xpY2thYmxlID0gbWFrZUFibGUoXCJjbGlja2FibGVcIiwge1xuICBwcm9wczoge1xuICAgIGNsaWNrYWJsZTogQm9vbGVhbixcbiAgICBwcmV2ZW50Q2xpY2tEZWZhdWx0OiBCb29sZWFuXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uQ2xpY2s6IFwiY2xpY2tcIixcbiAgICBvbkNsaWNrR3JvdXA6IFwiY2xpY2tHcm91cFwiXG4gIH0sXG4gIGFsd2F5czogdHJ1ZSxcbiAgZHJhZ1JlbGF0aW9uOiBcIndlYWtcIixcbiAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICBpZiAoIWUuaXNSZXF1ZXN0KSB7XG4gICAgICBhZGRFdmVudCh3aW5kb3csIFwiY2xpY2tcIiwgbW92ZWFibGUub25QcmV2ZW50Q2xpY2ssIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICAgIGUuZGF0YXMuaW5wdXRUYXJnZXQgPSBlLmlucHV0RXZlbnQgJiYgZS5pbnB1dEV2ZW50LnRhcmdldDtcbiAgfSxcbiAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5lbmRFdmVudChtb3ZlYWJsZSk7XG4gICAgdmFyIHRhcmdldCA9IG1vdmVhYmxlLnN0YXRlLnRhcmdldDtcbiAgICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcbiAgICB2YXIgaW5wdXRUYXJnZXQgPSBlLmlucHV0VGFyZ2V0O1xuICAgIHZhciBpc01vdmVhYmxlRWxlbWVudCA9IG1vdmVhYmxlLmlzTW92ZWFibGVFbGVtZW50KGlucHV0VGFyZ2V0KTtcbiAgICB2YXIgY29udGFpbnNFbGVtZW50ID0gIWlzTW92ZWFibGVFbGVtZW50ICYmIG1vdmVhYmxlLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpLmNvbnRhaW5zKGlucHV0VGFyZ2V0KTtcblxuICAgIGlmICghbW92ZWFibGUucHJvcHMucHJldmVudENsaWNrRGVmYXVsdCAmJiAhZS5pc0RyYWcgfHwgY29udGFpbnNFbGVtZW50KSB7XG4gICAgICB0aGlzLnVuc2V0KG1vdmVhYmxlKTtcbiAgICB9XG5cbiAgICBpZiAoIWlucHV0RXZlbnQgfHwgIWlucHV0VGFyZ2V0IHx8IGUuaXNEcmFnIHx8IG1vdmVhYmxlLmlzTW92ZWFibGVFbGVtZW50KGlucHV0VGFyZ2V0KSB8fCBjb250YWluc0VsZW1lbnQgLy8gRXh0ZXJuYWwgZXZlbnQgZHVwbGljYXRlIHRhcmdldCBvciBkcmFnQXJlYUVsZW1lbnRcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbnNUYXJnZXQgPSB0YXJnZXQuY29udGFpbnMoaW5wdXRUYXJnZXQpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaWNrXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGlzRG91YmxlOiBlLmlzRG91YmxlLFxuICAgICAgaW5wdXRUYXJnZXQ6IGlucHV0VGFyZ2V0LFxuICAgICAgaXNUYXJnZXQ6IHRhcmdldCA9PT0gaW5wdXRUYXJnZXQsXG4gICAgICBjb250YWluc1RhcmdldDogY29udGFpbnNUYXJnZXRcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5lbmRFdmVudChtb3ZlYWJsZSk7XG4gICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgdmFyIGlucHV0VGFyZ2V0ID0gZS5pbnB1dFRhcmdldDtcblxuICAgIGlmICghaW5wdXRFdmVudCB8fCAhaW5wdXRUYXJnZXQgfHwgZS5pc0RyYWcgfHwgbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoaW5wdXRUYXJnZXQpIC8vIEV4dGVybmFsIGV2ZW50IGR1cGxpY2F0ZSB0YXJnZXQgb3IgZHJhZ0FyZWFFbGVtZW50XG4gICAgfHwgZS5kYXRhcy5pbnB1dFRhcmdldCA9PT0gaW5wdXRUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0cyA9IG1vdmVhYmxlLnByb3BzLnRhcmdldHM7XG4gICAgdmFyIHRhcmdldEluZGV4ID0gdGFyZ2V0cy5pbmRleE9mKGlucHV0VGFyZ2V0KTtcbiAgICB2YXIgaXNUYXJnZXQgPSB0YXJnZXRJbmRleCA+IC0xO1xuICAgIHZhciBjb250YWluc1RhcmdldCA9IGZhbHNlO1xuXG4gICAgaWYgKHRhcmdldEluZGV4ID09PSAtMSkge1xuICAgICAgdGFyZ2V0SW5kZXggPSBmaW5kSW5kZXgodGFyZ2V0cywgZnVuY3Rpb24gKHBhcmVudFRhcmdldCkge1xuICAgICAgICByZXR1cm4gcGFyZW50VGFyZ2V0LmNvbnRhaW5zKGlucHV0VGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgICAgY29udGFpbnNUYXJnZXQgPSB0YXJnZXRJbmRleCA+IC0xO1xuICAgIH1cblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaWNrR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNEb3VibGU6IGUuaXNEb3VibGUsXG4gICAgICB0YXJnZXRzOiB0YXJnZXRzLFxuICAgICAgaW5wdXRUYXJnZXQ6IGlucHV0VGFyZ2V0LFxuICAgICAgdGFyZ2V0SW5kZXg6IHRhcmdldEluZGV4LFxuICAgICAgaXNUYXJnZXQ6IGlzVGFyZ2V0LFxuICAgICAgY29udGFpbnNUYXJnZXQ6IGNvbnRhaW5zVGFyZ2V0XG4gICAgfSkpO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZW5kRXZlbnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMudW5zZXQobW92ZWFibGUpO1xuICAgIH0pO1xuICB9LFxuICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgcmVtb3ZlRXZlbnQod2luZG93LCBcImNsaWNrXCIsIG1vdmVhYmxlLm9uUHJldmVudENsaWNrLCB0cnVlKTtcbiAgfVxufSk7XG4vKipcbiAqIFdoZW4geW91IGNsaWNrIG9uIHRoZSBlbGVtZW50LCB0aGUgYGNsaWNrYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBldmVudCBjbGlja1xuICogQHBhcmFtIHtNb3ZlYWJsZS5PbkNsaWNrfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgY2xpY2tgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImNsaWNrXCIsICh7IGhhc1RhcmdldCwgY29udGFpbnNUYXJnZXQsIHRhcmdldEluZGV4IH0pID0+IHtcbiAqICAgICAvLyBJZiB5b3UgY2xpY2sgb24gYW4gZWxlbWVudCBvdGhlciB0aGFuIHRoZSB0YXJnZXQgYW5kIG5vdCBpbmNsdWRlZCBpbiB0aGUgdGFyZ2V0LCBpbmRleCBpcyAtMS5cbiAqICAgICBjb25zb2xlLmxvZyhcIm9uQ2xpY2tHcm91cFwiLCB0YXJnZXQsIGhhc1RhcmdldCwgY29udGFpbnNUYXJnZXQsIHRhcmdldEluZGV4KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB5b3UgY2xpY2sgb24gdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBncm91cCwgdGhlIGBjbGlja0dyb3VwYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBldmVudCBjbGlja0dyb3VwXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uQ2xpY2tHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaWNrR3JvdXBgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImNsaWNrR3JvdXBcIiwgKHsgaW5wdXRUYXJnZXQsIGlzVGFyZ2V0LCBjb250YWluc1RhcmdldCwgdGFyZ2V0SW5kZXggfSkgPT4ge1xuICogICAgIC8vIElmIHlvdSBjbGljayBvbiBhbiBlbGVtZW50IG90aGVyIHRoYW4gdGhlIHRhcmdldCBhbmQgbm90IGluY2x1ZGVkIGluIHRoZSB0YXJnZXQsIGluZGV4IGlzIC0xLlxuICogICAgIGNvbnNvbGUubG9nKFwib25DbGlja0dyb3VwXCIsIGlucHV0VGFyZ2V0LCBpc1RhcmdldCwgY29udGFpbnNUYXJnZXQsIHRhcmdldEluZGV4KTtcbiAqIH0pO1xuICovXG5cbmZ1bmN0aW9uIGdldERyYWdnYWJsZUV2ZW50KGUpIHtcbiAgdmFyIGRhdGFzID0gZS5vcmlnaW5hbERhdGFzLmRyYWdnYWJsZTtcblxuICBpZiAoIWRhdGFzKSB7XG4gICAgZS5vcmlnaW5hbERhdGFzLmRyYWdnYWJsZSA9IHt9O1xuICAgIGRhdGFzID0gZS5vcmlnaW5hbERhdGFzLmRyYWdnYWJsZTtcbiAgfVxuXG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICBkYXRhczogZGF0YXNcbiAgfSk7XG59XG5cbnZhciBlZGdlRHJhZ2dhYmxlID0gbWFrZUFibGUoXCJlZGdlRHJhZ2dhYmxlXCIsIHtcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIGlmICghbW92ZWFibGUucHJvcHMuZWRnZURyYWdnYWJsZSB8fCAhZS5pbnB1dEV2ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGUuaW5wdXRFdmVudC50YXJnZXQ7XG4gICAgcmV0dXJuIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwiZGlyZWN0aW9uXCIpKSAmJiBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcImxpbmVcIikpO1xuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdTdGFydChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIERyYWdnYWJsZS5kcmFnKG1vdmVhYmxlLCBnZXREcmFnZ2FibGVFdmVudChlKSk7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdFbmQobW92ZWFibGUsIGdldERyYWdnYWJsZUV2ZW50KGUpKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgaWYgKCFtb3ZlYWJsZS5wcm9wcy5lZGdlRHJhZ2dhYmxlIHx8ICFlLmlucHV0RXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZS5pbnB1dEV2ZW50LnRhcmdldDtcbiAgICByZXR1cm4gaGFzQ2xhc3ModGFyZ2V0LCBwcmVmaXgoXCJkaXJlY3Rpb25cIikpICYmIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwibGluZVwiKSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIERyYWdnYWJsZS5kcmFnR3JvdXBTdGFydChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdHcm91cChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdHcm91cEVuZChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xuICB9LFxuICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgcmV0dXJuIERyYWdnYWJsZS51bnNldChtb3ZlYWJsZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBXaGV0aGVyIHRvIG1vdmUgYnkgZHJhZ2dpbmcgdGhlIGVkZ2UgbGluZSAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5EcmFnZ2FibGUjZWRnZURyYWdnYWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgZHJhZ2dhYmxlOiB0cnVlLFxuICogIGVkZ2VEcmFnZ2FibGU6IGZhbHNlLFxuICogfSk7XG4gKlxuICogbW92ZWFibGUuZWRnZURyYWdnYWJsZSA9IHRydWU7XG4gKi9cblxudmFyIEluZGl2aWR1YWxHcm91cGFibGUgPSB7XG4gIG5hbWU6IFwiaW5kaXZpZHVhbEdyb3VwYWJsZVwiLFxuICBwcm9wczoge1xuICAgIGluZGl2aWR1YWxHcm91cGFibGU6IEJvb2xlYW5cbiAgfSxcbiAgZXZlbnRzOiB7fVxufTtcbnZhciBNT1ZFQUJMRV9BQkxFUyA9IFtCZWZvcmVSZW5kZXJhYmxlLCBEZWZhdWx0LCBTbmFwcGFibGUsIFBpbmNoYWJsZSwgRHJhZ2dhYmxlLCBlZGdlRHJhZ2dhYmxlLCBSb3RhdGFibGUsIFJlc2l6YWJsZSwgU2NhbGFibGUsIFdhcnBhYmxlLCBTY3JvbGxhYmxlLCBQYWRkaW5nLCBPcmlnaW4sIE9yaWdpbkRyYWdnYWJsZSwgQ2xpcHBhYmxlLCBSb3VuZGFibGUsIEdyb3VwYWJsZSwgSW5kaXZpZHVhbEdyb3VwYWJsZSwgQ2xpY2thYmxlLCBEcmFnQXJlYSwgUmVuZGVyYWJsZV07XG52YXIgTU9WRUFCTEVfRVZFTlRTX1BST1BTX01BUCA9IC8qI19fUFVSRV9fKi9NT1ZFQUJMRV9BQkxFUy5yZWR1Y2UoZnVuY3Rpb24gKGN1cnJlbnQsIGFibGUpIHtcbiAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjdXJyZW50KSwgXCJldmVudHNcIiBpbiBhYmxlID8gYWJsZS5ldmVudHMgOiB7fSk7XG59LCB7fSk7XG52YXIgTU9WRUFCTEVfUFJPUFNfTUFQID0gLyojX19QVVJFX18qL01PVkVBQkxFX0FCTEVTLnJlZHVjZShmdW5jdGlvbiAoY3VycmVudCwgYWJsZSkge1xuICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGN1cnJlbnQpLCBhYmxlLnByb3BzKTtcbn0sIHt9KTtcbnZhciBNT1ZFQUJMRV9FVkVOVFNfTUFQID0gLyojX19QVVJFX18qL2ludmVydE9iamVjdChNT1ZFQUJMRV9FVkVOVFNfUFJPUFNfTUFQKTtcbnZhciBNT1ZFQUJMRV9FVkVOVFMgPSBPYmplY3Qua2V5cyhNT1ZFQUJMRV9FVkVOVFNfTUFQKTtcbnZhciBNT1ZFQUJMRV9QUk9QUyA9IE9iamVjdC5rZXlzKE1PVkVBQkxFX1BST1BTX01BUCk7XG5cbmZ1bmN0aW9uIGdldE1heFBvcyhwb3NlcywgaW5kZXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIHBvc2VzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcG9zMSA9IF9hWzBdLFxuICAgICAgICBwb3MyID0gX2FbMV0sXG4gICAgICAgIHBvczMgPSBfYVsyXSxcbiAgICAgICAgcG9zNCA9IF9hWzNdO1xuICAgIHJldHVybiBNYXRoLm1heChwb3MxW2luZGV4XSwgcG9zMltpbmRleF0sIHBvczNbaW5kZXhdLCBwb3M0W2luZGV4XSk7XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWluUG9zKHBvc2VzLCBpbmRleCkge1xuICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgcG9zZXMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwb3MxID0gX2FbMF0sXG4gICAgICAgIHBvczIgPSBfYVsxXSxcbiAgICAgICAgcG9zMyA9IF9hWzJdLFxuICAgICAgICBwb3M0ID0gX2FbM107XG4gICAgcmV0dXJuIE1hdGgubWluKHBvczFbaW5kZXhdLCBwb3MyW2luZGV4XSwgcG9zM1tpbmRleF0sIHBvczRbaW5kZXhdKTtcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRHcm91cFJlY3QobW92ZWFibGVzLCByb3RhdGlvbikge1xuICBpZiAoIW1vdmVhYmxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICB9XG5cbiAgdmFyIG1vdmVhYmxlUG9zZXMgPSBtb3ZlYWJsZXMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgIHJldHVybiBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShzdGF0ZSk7XG4gIH0pO1xuICB2YXIgbWluWCA9IE1BWF9OVU07XG4gIHZhciBtaW5ZID0gTUFYX05VTTtcbiAgdmFyIGdyb3VwV2lkdGggPSAwO1xuICB2YXIgZ3JvdXBIZWlnaHQgPSAwO1xuICB2YXIgZml4ZWRSb3RhdGlvbiA9IHRocm90dGxlKHJvdGF0aW9uLCBUSU5ZX05VTSk7XG5cbiAgaWYgKGZpeGVkUm90YXRpb24gJSA5MCkge1xuICAgIHZhciByYWRfMSA9IGZpeGVkUm90YXRpb24gLyAxODAgKiBNYXRoLlBJO1xuICAgIHZhciBhMV8xID0gTWF0aC50YW4ocmFkXzEpO1xuICAgIHZhciBhMl8xID0gLTEgLyBhMV8xO1xuICAgIHZhciBiMU1pbk1heF8xID0gW01JTl9OVU0sIE1BWF9OVU1dO1xuICAgIHZhciBiMk1pbk1heF8xID0gW01JTl9OVU0sIE1BWF9OVU1dO1xuICAgIG1vdmVhYmxlUG9zZXMuZm9yRWFjaChmdW5jdGlvbiAocG9zZXMpIHtcbiAgICAgIHBvc2VzLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAvLyBheCArIGIgPSB5XG4gICAgICAgIC8vIGIgPSB5IC0gYXhcbiAgICAgICAgdmFyIGIxID0gcG9zWzFdIC0gYTFfMSAqIHBvc1swXTtcbiAgICAgICAgdmFyIGIyID0gcG9zWzFdIC0gYTJfMSAqIHBvc1swXTtcbiAgICAgICAgYjFNaW5NYXhfMVswXSA9IE1hdGgubWF4KGIxTWluTWF4XzFbMF0sIGIxKTtcbiAgICAgICAgYjFNaW5NYXhfMVsxXSA9IE1hdGgubWluKGIxTWluTWF4XzFbMV0sIGIxKTtcbiAgICAgICAgYjJNaW5NYXhfMVswXSA9IE1hdGgubWF4KGIyTWluTWF4XzFbMF0sIGIyKTtcbiAgICAgICAgYjJNaW5NYXhfMVsxXSA9IE1hdGgubWluKGIyTWluTWF4XzFbMV0sIGIyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGIxTWluTWF4XzEuZm9yRWFjaChmdW5jdGlvbiAoYjEpIHtcbiAgICAgIC8vIGExeCArIGIxID0gYTJ4ICsgYjJcbiAgICAgIGIyTWluTWF4XzEuZm9yRWFjaChmdW5jdGlvbiAoYjIpIHtcbiAgICAgICAgLy8gKGExIC0gYTIpeCA9IGIyIC0gYjFcbiAgICAgICAgdmFyIHggPSAoYjIgLSBiMSkgLyAoYTFfMSAtIGEyXzEpO1xuICAgICAgICB2YXIgeSA9IGExXzEgKiB4ICsgYjE7XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHJvdGF0ZVBvc2VzID0gbW92ZWFibGVQb3Nlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgcG9zMSA9IF9hWzBdLFxuICAgICAgICAgIHBvczIgPSBfYVsxXSxcbiAgICAgICAgICBwb3MzID0gX2FbMl0sXG4gICAgICAgICAgcG9zNCA9IF9hWzNdO1xuICAgICAgcmV0dXJuIFtyb3RhdGUocG9zMSwgLXJhZF8xKSwgcm90YXRlKHBvczIsIC1yYWRfMSksIHJvdGF0ZShwb3MzLCAtcmFkXzEpLCByb3RhdGUocG9zNCwgLXJhZF8xKV07XG4gICAgfSk7XG4gICAgZ3JvdXBXaWR0aCA9IGdldE1heFBvcyhyb3RhdGVQb3NlcywgMCkgLSBnZXRNaW5Qb3Mocm90YXRlUG9zZXMsIDApO1xuICAgIGdyb3VwSGVpZ2h0ID0gZ2V0TWF4UG9zKHJvdGF0ZVBvc2VzLCAxKSAtIGdldE1pblBvcyhyb3RhdGVQb3NlcywgMSk7XG4gIH0gZWxzZSB7XG4gICAgbWluWCA9IGdldE1pblBvcyhtb3ZlYWJsZVBvc2VzLCAwKTtcbiAgICBtaW5ZID0gZ2V0TWluUG9zKG1vdmVhYmxlUG9zZXMsIDEpO1xuICAgIGdyb3VwV2lkdGggPSBnZXRNYXhQb3MobW92ZWFibGVQb3NlcywgMCkgLSBtaW5YO1xuICAgIGdyb3VwSGVpZ2h0ID0gZ2V0TWF4UG9zKG1vdmVhYmxlUG9zZXMsIDEpIC0gbWluWTtcblxuICAgIGlmIChmaXhlZFJvdGF0aW9uICUgMTgwKSB7XG4gICAgICB2YXIgY2hhbmdlZFdpZHRoID0gZ3JvdXBXaWR0aDtcbiAgICAgIGdyb3VwV2lkdGggPSBncm91cEhlaWdodDtcbiAgICAgIGdyb3VwSGVpZ2h0ID0gY2hhbmdlZFdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbWluWCwgbWluWSwgZ3JvdXBXaWR0aCwgZ3JvdXBIZWlnaHRdO1xufVxuLyoqXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLkdyb3VwXG4gKiBAZGVzY3JpcHRpb24gWW91IGNhbiBtYWtlIHRhcmdldHMgbW92ZWFibGUuXG4gKi9cblxuXG52YXIgTW92ZWFibGVHcm91cCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNb3ZlYWJsZUdyb3VwLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1vdmVhYmxlR3JvdXAoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5kaWZmZXIgPSBuZXcgQ2hpbGRyZW5EaWZmZXIoKTtcbiAgICBfdGhpcy5tb3ZlYWJsZXMgPSBbXTtcbiAgICBfdGhpcy50cmFuc2Zvcm1PcmlnaW4gPSBcIjUwJSA1MCVcIjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IE1vdmVhYmxlR3JvdXAucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY2hlY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51cGRhdGVBYmxlcygpO1xuICB9O1xuXG4gIF9fcHJvdG8udXBkYXRlUmVjdCA9IGZ1bmN0aW9uICh0eXBlLCBpc1RhcmdldCwgaXNTZXRTdGF0ZSkge1xuICAgIGlmIChpc1NldFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIGlzU2V0U3RhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sQm94KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tb3ZlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICAgIG1vdmVhYmxlLnVwZGF0ZVJlY3QodHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldCB8fCBwcm9wcy50YXJnZXQ7XG5cbiAgICBpZiAoIWlzVGFyZ2V0IHx8IHR5cGUgIT09IFwiXCIgJiYgcHJvcHMudXBkYXRlR3JvdXApIHtcbiAgICAgIC8vIHJlc2V0IHJvdGF0YWlvblxuICAgICAgdGhpcy5yb3RhdGlvbiA9IHByb3BzLmRlZmF1bHRHcm91cFJvdGF0ZTtcbiAgICAgIHRoaXMudHJhbnNmb3JtT3JpZ2luID0gcHJvcHMuZGVmYXVsdEdyb3VwT3JpZ2luIHx8IFwiNTAlIDUwJVwiO1xuICAgICAgdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgICB9XG5cbiAgICB2YXIgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgICB2YXIgX2EgPSBnZXRHcm91cFJlY3QodGhpcy5tb3ZlYWJsZXMsIHJvdGF0aW9uKSxcbiAgICAgICAgbGVmdCA9IF9hWzBdLFxuICAgICAgICB0b3AgPSBfYVsxXSxcbiAgICAgICAgd2lkdGggPSBfYVsyXSxcbiAgICAgICAgaGVpZ2h0ID0gX2FbM107IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWxpbmUtbGVuZ3RoXG5cblxuICAgIHZhciB0cmFuc2Zvcm0gPSBcInJvdGF0ZShcIi5jb25jYXQocm90YXRpb24sIFwiZGVnKSBzY2FsZShcIikuY29uY2F0KHNjYWxlWzBdID49IDAgPyAxIDogLTEsIFwiLCBcIikuY29uY2F0KHNjYWxlWzFdID49IDAgPyAxIDogLTEsIFwiKVwiKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCArPSBcImxlZnQ6MHB4O3RvcDowcHg7IHRyYW5zZm9ybS1vcmlnaW46IFwiLmNvbmNhdCh0aGlzLnRyYW5zZm9ybU9yaWdpbiwgXCI7IHdpZHRoOlwiKS5jb25jYXQod2lkdGgsIFwicHg7IGhlaWdodDpcIikuY29uY2F0KGhlaWdodCwgXCJweDtcIikgKyBcInRyYW5zZm9ybTpcIi5jb25jYXQodHJhbnNmb3JtKTtcbiAgICBzdGF0ZS53aWR0aCA9IHdpZHRoO1xuICAgIHN0YXRlLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICB2YXIgaW5mbyA9IGdldFRhcmdldEluZm8odGhpcy5jb250cm9sQm94LmdldEVsZW1lbnQoKSwgdGFyZ2V0LCB0aGlzLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpLCB0aGlzLmdldENvbnRhaW5lcigpLCB0aGlzLnByb3BzLnJvb3RDb250YWluZXIgfHwgY29udGFpbmVyKTtcbiAgICB2YXIgcG9zID0gW2luZm8ubGVmdCwgaW5mby50b3BdO1xuXG4gICAgdmFyIF9iID0gZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUoaW5mbyksXG4gICAgICAgIHBvczEgPSBfYlswXSxcbiAgICAgICAgcG9zMiA9IF9iWzFdLFxuICAgICAgICBwb3MzID0gX2JbMl0sXG4gICAgICAgIHBvczQgPSBfYlszXTsgLy8gaW5mby5sZWZ0ICsgaW5mby5wb3MoMSB+IDQpXG5cblxuICAgIHZhciBtaW5Qb3MgPSBnZXRNaW5NYXhzKFtwb3MxLCBwb3MyLCBwb3MzLCBwb3M0XSk7XG4gICAgdmFyIGRlbHRhID0gW21pblBvcy5taW5YLCBtaW5Qb3MubWluWV07XG4gICAgaW5mby5wb3MxID0gbWludXMocG9zMSwgZGVsdGEpO1xuICAgIGluZm8ucG9zMiA9IG1pbnVzKHBvczIsIGRlbHRhKTtcbiAgICBpbmZvLnBvczMgPSBtaW51cyhwb3MzLCBkZWx0YSk7XG4gICAgaW5mby5wb3M0ID0gbWludXMocG9zNCwgZGVsdGEpO1xuICAgIGluZm8ubGVmdCA9IGxlZnQgLSBpbmZvLmxlZnQgKyBkZWx0YVswXTtcbiAgICBpbmZvLnRvcCA9IHRvcCAtIGluZm8udG9wICsgZGVsdGFbMV07XG4gICAgaW5mby5vcmlnaW4gPSBtaW51cyhwbHVzKHBvcywgaW5mby5vcmlnaW4pLCBkZWx0YSk7XG4gICAgaW5mby5iZWZvcmVPcmlnaW4gPSBtaW51cyhwbHVzKHBvcywgaW5mby5iZWZvcmVPcmlnaW4pLCBkZWx0YSk7XG4gICAgaW5mby5vcmlnaW5hbEJlZm9yZU9yaWdpbiA9IHBsdXMocG9zLCBpbmZvLm9yaWdpbmFsQmVmb3JlT3JpZ2luKTsgLy8gaW5mby50cmFuc2Zvcm1PcmlnaW4gPSBtaW51cyhwbHVzKHBvcywgaW5mby50cmFuc2Zvcm1PcmlnaW4hKSwgZGVsdGEpO1xuXG4gICAgdmFyIGNsaWVudFJlY3QgPSBpbmZvLnRhcmdldENsaWVudFJlY3Q7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHNjYWxlWzBdICogc2NhbGVbMV0gPiAwID8gMSA6IC0xO1xuICAgIGNsaWVudFJlY3QudG9wICs9IGluZm8udG9wIC0gc3RhdGUudG9wO1xuICAgIGNsaWVudFJlY3QubGVmdCArPSBpbmZvLmxlZnQgLSBzdGF0ZS5sZWZ0O1xuICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQoLWRlbHRhWzBdLCBcInB4LCBcIikuY29uY2F0KC1kZWx0YVsxXSwgXCJweCkgXCIpLmNvbmNhdCh0cmFuc2Zvcm0pO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoX19hc3NpZ24oX19hc3NpZ24oe30sIGluZm8pLCB7XG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIGJlZm9yZURpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfSksIGlzU2V0U3RhdGUpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIF9zdXBlci5wcm90b3R5cGUuZ2V0UmVjdC5jYWxsKHRoaXMpKSwge1xuICAgICAgY2hpbGRyZW46IHRoaXMubW92ZWFibGVzLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLmdldFJlY3QoKTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by50cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZSwgaXNNYW5hZ2VyKSB7XG4gICAgaWYgKGlzTWFuYWdlciB8fCBuYW1lLmluZGV4T2YoXCJHcm91cFwiKSA+IC0xKSB7XG4gICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS50cmlnZ2VyRXZlbnQuY2FsbCh0aGlzLCBuYW1lLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW1pdHRlci50cmlnZ2VyKG5hbWUsIGUpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLnVwZGF0ZUFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlQWJsZXMuY2FsbCh0aGlzLCBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHRoaXMucHJvcHMuYWJsZXMsIHRydWUpLCBbR3JvdXBhYmxlXSwgZmFsc2UpLCBcIkdyb3VwXCIpO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZVRhcmdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5fdXBkYXRlVGFyZ2V0cy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fcHJldlRhcmdldCA9IHRoaXMucHJvcHMuZHJhZ1RhcmdldCB8fCB0aGlzLmFyZWFFbGVtZW50O1xuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZXZUYXJnZXQgPSB0aGlzLl9wcmV2VGFyZ2V0O1xuICAgIHZhciBuZXh0VGFyZ2V0ID0gcHJvcHMuZHJhZ1RhcmdldCB8fCB0aGlzLmFyZWFFbGVtZW50O1xuXG4gICAgaWYgKHByZXZUYXJnZXQgIT09IG5leHRUYXJnZXQpIHtcbiAgICAgIHVuc2V0KHRoaXMsIFwidGFyZ2V0R2VzdG9cIik7XG4gICAgICB1bnNldCh0aGlzLCBcImNvbnRyb2xHZXN0b1wiKTtcbiAgICAgIHN0YXRlLnRhcmdldCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS50YXJnZXQpIHtcbiAgICAgIHN0YXRlLnRhcmdldCA9IHRoaXMuYXJlYUVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnRhcmdldCkge1xuICAgICAgaWYgKCF0aGlzLnRhcmdldEdlc3RvKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0R2VzdG8gPSBnZXRUYXJnZXRBYmxlR2VzdG8odGhpcywgbmV4dFRhcmdldCwgXCJHcm91cFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNvbnRyb2xHZXN0bykge1xuICAgICAgICB0aGlzLmNvbnRyb2xHZXN0byA9IGdldEFibGVHZXN0byh0aGlzLCB0aGlzLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpLCBcImNvbnRyb2xBYmxlc1wiLCBcIkdyb3VwQ29udHJvbFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXNDb250YWluZXJDaGFuZ2VkID0gIWVxdWFscyhzdGF0ZS5jb250YWluZXIsIHByb3BzLmNvbnRhaW5lcik7XG5cbiAgICBpZiAoaXNDb250YWluZXJDaGFuZ2VkKSB7XG4gICAgICBzdGF0ZS5jb250YWluZXIgPSBwcm9wcy5jb250YWluZXI7XG4gICAgfVxuXG4gICAgdmFyIF9hID0gdGhpcy5kaWZmZXIudXBkYXRlKHByb3BzLnRhcmdldHMpLFxuICAgICAgICBhZGRlZCA9IF9hLmFkZGVkLFxuICAgICAgICBjaGFuZ2VkID0gX2EuY2hhbmdlZCxcbiAgICAgICAgcmVtb3ZlZCA9IF9hLnJlbW92ZWQ7XG5cbiAgICBpZiAoaXNDb250YWluZXJDaGFuZ2VkIHx8IGFkZGVkLmxlbmd0aCB8fCBjaGFuZ2VkLmxlbmd0aCB8fCByZW1vdmVkLmxlbmd0aCkge1xuICAgICAgdGhpcy51cGRhdGVSZWN0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZU9ic2VydmVyID0gZnVuY3Rpb24gKCkge307XG5cbiAgTW92ZWFibGVHcm91cC5kZWZhdWx0UHJvcHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgTW92ZWFibGVNYW5hZ2VyLmRlZmF1bHRQcm9wcyksIHtcbiAgICB0cmFuc2Zvcm1PcmlnaW46IFtcIjUwJVwiLCBcIjUwJVwiXSxcbiAgICBncm91cGFibGU6IHRydWUsXG4gICAgZHJhZ0FyZWE6IHRydWUsXG4gICAga2VlcFJhdGlvOiB0cnVlLFxuICAgIHRhcmdldHM6IFtdLFxuICAgIGRlZmF1bHRHcm91cFJvdGF0ZTogMCxcbiAgICBkZWZhdWx0R3JvdXBPcmlnaW46IFwiNTAlIDUwJVwiXG4gIH0pO1xuICByZXR1cm4gTW92ZWFibGVHcm91cDtcbn0oTW92ZWFibGVNYW5hZ2VyKTtcbi8qKlxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5JbmRpdmlkdWFsR3JvdXBcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgdGFyZ2V0cyBpbmRpdmlkdWFsbHksIG5vdCBhcyBhIGdyb3VwLkNyZWF0ZSB0YXJnZXRzIGluZGl2aWR1YWxseSwgbm90IGFzIGEgZ3JvdXAuXG4gKi9cblxuXG52YXIgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5tb3ZlYWJsZXMgPSBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY3NwTm9uY2UgPSBfYS5jc3BOb25jZSxcbiAgICAgICAgQ29udHJvbEJveEVsZW1lbnQgPSBfYS5jc3NTdHlsZWQsXG4gICAgICAgIHRhcmdldHMgPSBfYS50YXJnZXRzO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRyb2xCb3hFbGVtZW50LCB7XG4gICAgICBjc3BOb25jZTogY3NwTm9uY2UsXG4gICAgICByZWY6IHJlZih0aGlzLCBcImNvbnRyb2xCb3hcIiksXG4gICAgICBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2wtYm94XCIpXG4gICAgfSwgdGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHRhcmdldCwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW92ZWFibGVNYW5hZ2VyLCBfX2Fzc2lnbih7XG4gICAgICAgIGtleTogXCJtb3ZlYWJsZVwiICsgaSxcbiAgICAgICAgcmVmOiByZWZzKF90aGlzLCBcIm1vdmVhYmxlc1wiLCBpKVxuICAgICAgfSwgX3RoaXMucHJvcHMsIHtcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIHdyYXBwZXJNb3ZlYWJsZTogX3RoaXNcbiAgICAgIH0pKTtcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBfX3Byb3RvLnVwZGF0ZVJlY3QgPSBmdW5jdGlvbiAodHlwZSwgaXNUYXJnZXQsIGlzU2V0U3RhdGUpIHtcbiAgICBpZiAoaXNTZXRTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpc1NldFN0YXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLm1vdmVhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgICAgbW92ZWFibGUudXBkYXRlUmVjdCh0eXBlLCBpc1RhcmdldCwgaXNTZXRTdGF0ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5nZXRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgX3N1cGVyLnByb3RvdHlwZS5nZXRSZWN0LmNhbGwodGhpcykpLCB7XG4gICAgICBjaGlsZHJlbjogdGhpcy5tb3ZlYWJsZXMubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQuZ2V0UmVjdCgpO1xuICAgICAgfSlcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLnJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIF9fcHJvdG8uZHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9fcHJvdG8uaGl0VGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBfX3Byb3RvLmlzSW5zaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfX3Byb3RvLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9fcHJvdG8udXBkYXRlUmVuZGVyUG9zZXMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBfX3Byb3RvLmNoZWNrVXBkYXRlID0gZnVuY3Rpb24gKCkge307XG5cbiAgX19wcm90by50cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBfX3Byb3RvLnVwZGF0ZUFibGVzID0gZnVuY3Rpb24gKCkge307XG5cbiAgX19wcm90by5fdXBkYXRlRXZlbnRzID0gZnVuY3Rpb24gKCkge307XG5cbiAgX19wcm90by5fdXBkYXRlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICByZXR1cm4gTW92ZWFibGVJbmRpdmlkdWFsR3JvdXA7XG59KE1vdmVhYmxlTWFuYWdlcik7XG5cbnZhciBJbml0aWFsTW92ZWFibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoSW5pdGlhbE1vdmVhYmxlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEluaXRpYWxNb3ZlYWJsZSgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnJlZlRhcmdldHMgPSBbXTtcbiAgICBfdGhpcy5zZWxlY3Rvck1hcCA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gSW5pdGlhbE1vdmVhYmxlLnByb3RvdHlwZTtcblxuICBJbml0aWFsTW92ZWFibGUubWFrZVN0eWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3NzTWFwID0ge307XG4gICAgdmFyIGFibGVzID0gdGhpcy5nZXRUb3RhbEFibGVzKCk7XG4gICAgYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBjc3MgPSBfYS5jc3M7XG5cbiAgICAgIGlmICghY3NzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3NzLmZvckVhY2goZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgY3NzTWFwW3RleHRdID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBzdHlsZSA9IGdldEtleXMoY3NzTWFwKS5qb2luKFwiXFxuXCIpO1xuICAgIHRoaXMuZGVmYXVsdFN0eWxlZCA9IHN0eWxlZChcImRpdlwiLCBwcmVmaXhDU1MoUFJFRklYLCBNT1ZFQUJMRV9DU1MgKyBzdHlsZSkpO1xuICB9O1xuXG4gIEluaXRpYWxNb3ZlYWJsZS5nZXRUb3RhbEFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX3NwcmVhZEFycmF5KFtEZWZhdWx0LCBHcm91cGFibGUsIEluZGl2aWR1YWxHcm91cGFibGUsIERyYWdBcmVhXSwgdGhpcy5kZWZhdWx0QWJsZXMsIHRydWUpO1xuICB9O1xuXG4gIF9fcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb3ZlYWJsZUNvbnRydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKCFtb3ZlYWJsZUNvbnRydWN0b3IuZGVmYXVsdFN0eWxlZCkge1xuICAgICAgbW92ZWFibGVDb250cnVjdG9yLm1ha2VTdHlsZWQoKTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSB0aGlzLnByb3BzLFxuICAgICAgICB1c2VyQWJsZXMgPSBfYS5hYmxlcyxcbiAgICAgICAgdXNlclByb3BzID0gX2EucHJvcHMsXG4gICAgICAgIHByb3BzID0gX19yZXN0KF9hLCBbXCJhYmxlc1wiLCBcInByb3BzXCJdKTtcblxuICAgIHZhciByZWZUYXJnZXRzID0gdGhpcy5fdXBkYXRlUmVmcyh0cnVlKTtcblxuICAgIHZhciBlbGVtZW50VGFyZ2V0cyA9IGdldEVsZW1lbnRUYXJnZXRzKHJlZlRhcmdldHMsIHRoaXMuc2VsZWN0b3JNYXApO1xuICAgIHZhciBpc0dyb3VwID0gZWxlbWVudFRhcmdldHMubGVuZ3RoID4gMTtcbiAgICB2YXIgdG90YWxBYmxlcyA9IG1vdmVhYmxlQ29udHJ1Y3Rvci5nZXRUb3RhbEFibGVzKCk7XG5cbiAgICB2YXIgYWJsZXMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHRvdGFsQWJsZXMsIHRydWUpLCB1c2VyQWJsZXMgfHwgW10sIHRydWUpO1xuXG4gICAgdmFyIG5leHRQcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcm9wcyksIHVzZXJQcm9wcyB8fCB7fSksIHtcbiAgICAgIGFibGVzOiBhYmxlcyxcbiAgICAgIGNzc1N0eWxlZDogbW92ZWFibGVDb250cnVjdG9yLmRlZmF1bHRTdHlsZWQsXG4gICAgICBjdXN0b21TdHlsZWRNYXA6IG1vdmVhYmxlQ29udHJ1Y3Rvci5jdXN0b21TdHlsZWRNYXBcbiAgICB9KTtcblxuICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICBpZiAocHJvcHMuaW5kaXZpZHVhbEdyb3VwYWJsZSkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNb3ZlYWJsZUluZGl2aWR1YWxHcm91cCwgX19hc3NpZ24oe1xuICAgICAgICAgIGtleTogXCJpbmRpdmlkdWFsLWdyb3VwXCIsXG4gICAgICAgICAgcmVmOiByZWYodGhpcywgXCJtb3ZlYWJsZVwiKVxuICAgICAgICB9LCBuZXh0UHJvcHMsIHtcbiAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgdGFyZ2V0czogZWxlbWVudFRhcmdldHNcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNb3ZlYWJsZUdyb3VwLCBfX2Fzc2lnbih7XG4gICAgICAgIGtleTogXCJncm91cFwiLFxuICAgICAgICByZWY6IHJlZih0aGlzLCBcIm1vdmVhYmxlXCIpXG4gICAgICB9LCBuZXh0UHJvcHMsIHtcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICB0YXJnZXRzOiBlbGVtZW50VGFyZ2V0c1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNb3ZlYWJsZU1hbmFnZXIsIF9fYXNzaWduKHtcbiAgICAgICAga2V5OiBcInNpbmdsZVwiLFxuICAgICAgICByZWY6IHJlZih0aGlzLCBcIm1vdmVhYmxlXCIpXG4gICAgICB9LCBuZXh0UHJvcHMsIHtcbiAgICAgICAgdGFyZ2V0OiBlbGVtZW50VGFyZ2V0c1swXVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVJlZnMoKTtcbiAgfTtcblxuICBfX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91cGRhdGVSZWZzKCk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNlbGVjdG9yTWFwID0ge307XG4gICAgdGhpcy5yZWZUYXJnZXRzID0gW107XG4gIH07XG5cbiAgX19wcm90by5nZXRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1vdmVhYmxlO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZVJlZnMgPSBmdW5jdGlvbiAoaXNSZW5kZXIpIHtcbiAgICB2YXIgcHJldlJlZlRhcmdldHMgPSB0aGlzLnJlZlRhcmdldHM7XG4gICAgdmFyIG5leHRSZWZUYXJnZXRzID0gZ2V0UmVmVGFyZ2V0cyh0aGlzLnByb3BzLnRhcmdldCB8fCB0aGlzLnByb3BzLnRhcmdldHMpO1xuICAgIHZhciBpc0Jyb3dzZXIgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIGlzVXBkYXRlID0gcHJldlJlZlRhcmdldHMubGVuZ3RoICE9PSBuZXh0UmVmVGFyZ2V0cy5sZW5ndGggfHwgcHJldlJlZlRhcmdldHMuc29tZShmdW5jdGlvbiAodGFyZ2V0LCBpKSB7XG4gICAgICB2YXIgbmV4dFRhcmdldCA9IG5leHRSZWZUYXJnZXRzW2ldO1xuXG4gICAgICBpZiAoIXRhcmdldCAmJiAhbmV4dFRhcmdldCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gbmV4dFRhcmdldCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHZhciBzZWxlY3Rvck1hcCA9IHRoaXMuc2VsZWN0b3JNYXA7XG4gICAgdmFyIG5leHRTZWxlY3Rvck1hcCA9IHt9O1xuICAgIHRoaXMucmVmVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XG4gICAgICAgIHZhciBzZWxlY3RvclRhcmdldCA9IHNlbGVjdG9yTWFwW3RhcmdldF07XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yVGFyZ2V0KSB7XG4gICAgICAgICAgbmV4dFNlbGVjdG9yTWFwW3RhcmdldF0gPSBzZWxlY3Rvck1hcFt0YXJnZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICAgIGlzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBuZXh0U2VsZWN0b3JNYXBbdGFyZ2V0XSA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVmVGFyZ2V0cyA9IG5leHRSZWZUYXJnZXRzO1xuICAgIHRoaXMuc2VsZWN0b3JNYXAgPSBuZXh0U2VsZWN0b3JNYXA7XG5cbiAgICBpZiAoIWlzUmVuZGVyICYmIGlzVXBkYXRlKSB7XG4gICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRSZWZUYXJnZXRzO1xuICB9O1xuXG4gIEluaXRpYWxNb3ZlYWJsZS5kZWZhdWx0QWJsZXMgPSBbXTtcbiAgSW5pdGlhbE1vdmVhYmxlLmN1c3RvbVN0eWxlZE1hcCA9IHt9O1xuICBJbml0aWFsTW92ZWFibGUuZGVmYXVsdFN0eWxlZCA9IG51bGw7XG5cbiAgX19kZWNvcmF0ZShbd2l0aE1ldGhvZHMoTU9WRUFCTEVfTUVUSE9EUyldLCBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLCBcIm1vdmVhYmxlXCIsIHZvaWQgMCk7XG5cbiAgcmV0dXJuIEluaXRpYWxNb3ZlYWJsZTtcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cbnZhciBNb3ZlYWJsZSQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1vdmVhYmxlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1vdmVhYmxlKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIE1vdmVhYmxlLmRlZmF1bHRBYmxlcyA9IE1PVkVBQkxFX0FCTEVTO1xuICByZXR1cm4gTW92ZWFibGU7XG59KEluaXRpYWxNb3ZlYWJsZSk7XG5cbmZ1bmN0aW9uIG1ha2VNb3ZlYWJsZShhYmxlcykge1xuICB2YXIgX2E7XG5cbiAgcmV0dXJuIF9hID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW92ZWFibGUsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBNb3ZlYWJsZSgpIHtcbiAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTW92ZWFibGU7XG4gIH0oSW5pdGlhbE1vdmVhYmxlKSwgX2EuZGVmYXVsdEFibGVzID0gYWJsZXMsIF9hO1xufVxuXG52YXIgTW92ZWFibGUgPSBNb3ZlYWJsZSQxO1xuXG5leHBvcnQgeyBDbGlwcGFibGUsIERyYWdnYWJsZSwgZWRnZURyYWdnYWJsZSBhcyBFZGdlRHJhZ2dhYmxlLCBJbml0aWFsTW92ZWFibGUsIE1PVkVBQkxFX0FCTEVTLCBNT1ZFQUJMRV9FVkVOVFMsIE1PVkVBQkxFX0VWRU5UU19NQVAsIE1PVkVBQkxFX0VWRU5UU19QUk9QU19NQVAsIE1PVkVBQkxFX01FVEhPRFMsIE1PVkVBQkxFX1BST1BTLCBNT1ZFQUJMRV9QUk9QU19NQVAsIFBpbmNoYWJsZSwgUmVzaXphYmxlLCBSb3RhdGFibGUsIFJvdW5kYWJsZSwgU2NhbGFibGUsIFNuYXBwYWJsZSwgV2FycGFibGUsIE1vdmVhYmxlIGFzIGRlZmF1bHQsIGdldEVsZW1lbnRJbmZvLCBtYWtlQWJsZSwgbWFrZU1vdmVhYmxlIH07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRHJhZ2dhYmxlQ29yZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfRHJhZ2dhYmxlQ29yZS5kZWZhdWx0O1xuICB9XG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG5cbnZhciBfY2xzeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcblxudmFyIF9kb21GbnMgPSByZXF1aXJlKFwiLi91dGlscy9kb21GbnNcIik7XG5cbnZhciBfcG9zaXRpb25GbnMgPSByZXF1aXJlKFwiLi91dGlscy9wb3NpdGlvbkZuc1wiKTtcblxudmFyIF9zaGltcyA9IHJlcXVpcmUoXCIuL3V0aWxzL3NoaW1zXCIpO1xuXG52YXIgX0RyYWdnYWJsZUNvcmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0RyYWdnYWJsZUNvcmVcIikpO1xuXG52YXIgX2xvZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvbG9nXCIpKTtcblxudmFyIF9leGNsdWRlZCA9IFtcImF4aXNcIiwgXCJib3VuZHNcIiwgXCJjaGlsZHJlblwiLCBcImRlZmF1bHRQb3NpdGlvblwiLCBcImRlZmF1bHRDbGFzc05hbWVcIiwgXCJkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmdcIiwgXCJkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZFwiLCBcInBvc2l0aW9uXCIsIFwicG9zaXRpb25PZmZzZXRcIiwgXCJzY2FsZVwiXTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vXG4vLyBEZWZpbmUgPERyYWdnYWJsZT5cbi8vXG52YXIgRHJhZ2dhYmxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhEcmFnZ2FibGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRHJhZ2dhYmxlKTtcblxuICBmdW5jdGlvbiBEcmFnZ2FibGUocHJvcHNcbiAgLyo6IERyYWdnYWJsZVByb3BzKi9cbiAgKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyYWdnYWJsZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbkRyYWdTdGFydFwiLCBmdW5jdGlvbiAoZSwgY29yZURhdGEpIHtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGU6IG9uRHJhZ1N0YXJ0OiAlaicsIGNvcmVEYXRhKTsgLy8gU2hvcnQtY2lyY3VpdCBpZiB1c2VyJ3MgY2FsbGJhY2sga2lsbGVkIGl0LlxuXG4gICAgICB2YXIgc2hvdWxkU3RhcnQgPSBfdGhpcy5wcm9wcy5vblN0YXJ0KGUsICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGNvcmVEYXRhKSk7IC8vIEtpbGxzIHN0YXJ0IGV2ZW50IG9uIGNvcmUgYXMgd2VsbCwgc28gbW92ZSBoYW5kbGVycyBhcmUgbmV2ZXIgYm91bmQuXG5cblxuICAgICAgaWYgKHNob3VsZFN0YXJ0ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgICAgICBkcmFnZ2VkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbkRyYWdcIiwgZnVuY3Rpb24gKGUsIGNvcmVEYXRhKSB7XG4gICAgICBpZiAoIV90aGlzLnN0YXRlLmRyYWdnaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlOiBvbkRyYWc6ICVqJywgY29yZURhdGEpO1xuICAgICAgdmFyIHVpRGF0YSA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGNvcmVEYXRhKTtcbiAgICAgIHZhciBuZXdTdGF0ZVxuICAgICAgLyo6ICRTaGFwZTxEcmFnZ2FibGVTdGF0ZT4qL1xuICAgICAgPSB7XG4gICAgICAgIHg6IHVpRGF0YS54LFxuICAgICAgICB5OiB1aURhdGEueVxuICAgICAgfTsgLy8gS2VlcCB3aXRoaW4gYm91bmRzLlxuXG4gICAgICBpZiAoX3RoaXMucHJvcHMuYm91bmRzKSB7XG4gICAgICAgIC8vIFNhdmUgb3JpZ2luYWwgeCBhbmQgeS5cbiAgICAgICAgdmFyIHggPSBuZXdTdGF0ZS54LFxuICAgICAgICAgICAgeSA9IG5ld1N0YXRlLnk7IC8vIEFkZCBzbGFjayB0byB0aGUgdmFsdWVzIHVzZWQgdG8gY2FsY3VsYXRlIGJvdW5kIHBvc2l0aW9uLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgaWZcbiAgICAgICAgLy8gd2Ugc3RhcnQgcmVtb3Zpbmcgc2xhY2ssIHRoZSBlbGVtZW50IHdvbid0IHJlYWN0IHRvIGl0IHJpZ2h0IGF3YXkgdW50aWwgaXQncyBiZWVuXG4gICAgICAgIC8vIGNvbXBsZXRlbHkgcmVtb3ZlZC5cblxuICAgICAgICBuZXdTdGF0ZS54ICs9IF90aGlzLnN0YXRlLnNsYWNrWDtcbiAgICAgICAgbmV3U3RhdGUueSArPSBfdGhpcy5zdGF0ZS5zbGFja1k7IC8vIEdldCBib3VuZCBwb3NpdGlvbi4gVGhpcyB3aWxsIGNlaWwvZmxvb3IgdGhlIHggYW5kIHkgd2l0aGluIHRoZSBib3VuZGFyaWVzLlxuXG4gICAgICAgIHZhciBfZ2V0Qm91bmRQb3NpdGlvbiA9ICgwLCBfcG9zaXRpb25GbnMuZ2V0Qm91bmRQb3NpdGlvbikoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIG5ld1N0YXRlLngsIG5ld1N0YXRlLnkpLFxuICAgICAgICAgICAgX2dldEJvdW5kUG9zaXRpb24yID0gX3NsaWNlZFRvQXJyYXkoX2dldEJvdW5kUG9zaXRpb24sIDIpLFxuICAgICAgICAgICAgbmV3U3RhdGVYID0gX2dldEJvdW5kUG9zaXRpb24yWzBdLFxuICAgICAgICAgICAgbmV3U3RhdGVZID0gX2dldEJvdW5kUG9zaXRpb24yWzFdO1xuXG4gICAgICAgIG5ld1N0YXRlLnggPSBuZXdTdGF0ZVg7XG4gICAgICAgIG5ld1N0YXRlLnkgPSBuZXdTdGF0ZVk7IC8vIFJlY2FsY3VsYXRlIHNsYWNrIGJ5IG5vdGluZyBob3cgbXVjaCB3YXMgc2hhdmVkIGJ5IHRoZSBib3VuZFBvc2l0aW9uIGhhbmRsZXIuXG5cbiAgICAgICAgbmV3U3RhdGUuc2xhY2tYID0gX3RoaXMuc3RhdGUuc2xhY2tYICsgKHggLSBuZXdTdGF0ZS54KTtcbiAgICAgICAgbmV3U3RhdGUuc2xhY2tZID0gX3RoaXMuc3RhdGUuc2xhY2tZICsgKHkgLSBuZXdTdGF0ZS55KTsgLy8gVXBkYXRlIHRoZSBldmVudCB3ZSBmaXJlIHRvIHJlZmxlY3Qgd2hhdCByZWFsbHkgaGFwcGVuZWQgYWZ0ZXIgYm91bmRzIHRvb2sgZWZmZWN0LlxuXG4gICAgICAgIHVpRGF0YS54ID0gbmV3U3RhdGUueDtcbiAgICAgICAgdWlEYXRhLnkgPSBuZXdTdGF0ZS55O1xuICAgICAgICB1aURhdGEuZGVsdGFYID0gbmV3U3RhdGUueCAtIF90aGlzLnN0YXRlLng7XG4gICAgICAgIHVpRGF0YS5kZWx0YVkgPSBuZXdTdGF0ZS55IC0gX3RoaXMuc3RhdGUueTtcbiAgICAgIH0gLy8gU2hvcnQtY2lyY3VpdCBpZiB1c2VyJ3MgY2FsbGJhY2sga2lsbGVkIGl0LlxuXG5cbiAgICAgIHZhciBzaG91bGRVcGRhdGUgPSBfdGhpcy5wcm9wcy5vbkRyYWcoZSwgdWlEYXRhKTtcblxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uRHJhZ1N0b3BcIiwgZnVuY3Rpb24gKGUsIGNvcmVEYXRhKSB7XG4gICAgICBpZiAoIV90aGlzLnN0YXRlLmRyYWdnaW5nKSByZXR1cm4gZmFsc2U7IC8vIFNob3J0LWNpcmN1aXQgaWYgdXNlcidzIGNhbGxiYWNrIGtpbGxlZCBpdC5cblxuICAgICAgdmFyIHNob3VsZENvbnRpbnVlID0gX3RoaXMucHJvcHMub25TdG9wKGUsICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGNvcmVEYXRhKSk7XG5cbiAgICAgIGlmIChzaG91bGRDb250aW51ZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGU6IG9uRHJhZ1N0b3A6ICVqJywgY29yZURhdGEpO1xuICAgICAgdmFyIG5ld1N0YXRlXG4gICAgICAvKjogJFNoYXBlPERyYWdnYWJsZVN0YXRlPiovXG4gICAgICA9IHtcbiAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICBzbGFja1g6IDAsXG4gICAgICAgIHNsYWNrWTogMFxuICAgICAgfTsgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgY29tcG9uZW50LCB0aGUgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uIHdpbGwgYmUgdG9cbiAgICAgIC8vIHJldmVydCBiYWNrIHRvIHRoZSBvbGQgcG9zaXRpb24uIFdlIGV4cGVjdCBhIGhhbmRsZXIgb24gYG9uRHJhZ1N0b3BgLCBhdCB0aGUgbGVhc3QuXG5cbiAgICAgIHZhciBjb250cm9sbGVkID0gQm9vbGVhbihfdGhpcy5wcm9wcy5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChjb250cm9sbGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyRwb3NpdGlvbiA9IF90aGlzLnByb3BzLnBvc2l0aW9uLFxuICAgICAgICAgICAgeCA9IF90aGlzJHByb3BzJHBvc2l0aW9uLngsXG4gICAgICAgICAgICB5ID0gX3RoaXMkcHJvcHMkcG9zaXRpb24ueTtcbiAgICAgICAgbmV3U3RhdGUueCA9IHg7XG4gICAgICAgIG5ld1N0YXRlLnkgPSB5O1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBjdXJyZW50bHkgZHJhZ2dpbmcuXG4gICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAvLyBXaGV0aGVyIG9yIG5vdCB3ZSBoYXZlIGJlZW4gZHJhZ2dlZCBiZWZvcmUuXG4gICAgICBkcmFnZ2VkOiBmYWxzZSxcbiAgICAgIC8vIEN1cnJlbnQgdHJhbnNmb3JtIHggYW5kIHkuXG4gICAgICB4OiBwcm9wcy5wb3NpdGlvbiA/IHByb3BzLnBvc2l0aW9uLnggOiBwcm9wcy5kZWZhdWx0UG9zaXRpb24ueCxcbiAgICAgIHk6IHByb3BzLnBvc2l0aW9uID8gcHJvcHMucG9zaXRpb24ueSA6IHByb3BzLmRlZmF1bHRQb3NpdGlvbi55LFxuICAgICAgcHJldlByb3BzUG9zaXRpb246IF9vYmplY3RTcHJlYWQoe30sIHByb3BzLnBvc2l0aW9uKSxcbiAgICAgIC8vIFVzZWQgZm9yIGNvbXBlbnNhdGluZyBmb3Igb3V0LW9mLWJvdW5kcyBkcmFnc1xuICAgICAgc2xhY2tYOiAwLFxuICAgICAgc2xhY2tZOiAwLFxuICAgICAgLy8gQ2FuIG9ubHkgZGV0ZXJtaW5lIGlmIFNWRyBhZnRlciBtb3VudGluZ1xuICAgICAgaXNFbGVtZW50U1ZHOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAocHJvcHMucG9zaXRpb24gJiYgIShwcm9wcy5vbkRyYWcgfHwgcHJvcHMub25TdG9wKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybignQSBgcG9zaXRpb25gIHdhcyBhcHBsaWVkIHRvIHRoaXMgPERyYWdnYWJsZT4sIHdpdGhvdXQgZHJhZyBoYW5kbGVycy4gVGhpcyB3aWxsIG1ha2UgdGhpcyAnICsgJ2NvbXBvbmVudCBlZmZlY3RpdmVseSB1bmRyYWdnYWJsZS4gUGxlYXNlIGF0dGFjaCBgb25EcmFnYCBvciBgb25TdG9wYCBoYW5kbGVycyBzbyB5b3UgY2FuIGFkanVzdCB0aGUgJyArICdgcG9zaXRpb25gIG9mIHRoaXMgZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRHJhZ2dhYmxlLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZWxlbWVudCBwYXNzZWQgaXMgYW4gaW5zdGFuY2VvZiBTVkdFbGVtZW50XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5TVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLmZpbmRET01Ob2RlKCkgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpc0VsZW1lbnRTVkc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZVxuICAgICAgfSk7IC8vIHByZXZlbnRzIGludmFyaWFudCBpZiB1bm1vdW50ZWQgd2hpbGUgZHJhZ2dpbmdcbiAgICB9IC8vIFJlYWN0IFN0cmljdCBNb2RlIGNvbXBhdGliaWxpdHk6IGlmIGBub2RlUmVmYCBpcyBwYXNzZWQsIHdlIHdpbGwgdXNlIGl0IGluc3RlYWQgb2YgdHJ5aW5nIHRvIGZpbmRcbiAgICAvLyB0aGUgdW5kZXJseWluZyBET00gbm9kZSBvdXJzZWx2ZXMuIFNlZSB0aGUgUkVBRE1FIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZERPTU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZERPTU5vZGUoKVxuICAgIC8qOiA/SFRNTEVsZW1lbnQqL1xuICAgIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRub2RlUmVmJGMsIF90aGlzJHByb3BzLCBfdGhpcyRwcm9wcyRub2RlUmVmO1xuXG4gICAgICByZXR1cm4gKF90aGlzJHByb3BzJG5vZGVSZWYkYyA9IChfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMpID09PSBudWxsIHx8IF90aGlzJHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXMkcHJvcHMkbm9kZVJlZiA9IF90aGlzJHByb3BzLm5vZGVSZWYpID09PSBudWxsIHx8IF90aGlzJHByb3BzJG5vZGVSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJG5vZGVSZWYuY3VycmVudCkgIT09IG51bGwgJiYgX3RoaXMkcHJvcHMkbm9kZVJlZiRjICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRub2RlUmVmJGMgOiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpXG4gICAgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki9cbiAgICB7XG4gICAgICB2YXIgX2Nsc3g7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGF4aXMgPSBfdGhpcyRwcm9wczIuYXhpcyxcbiAgICAgICAgICBib3VuZHMgPSBfdGhpcyRwcm9wczIuYm91bmRzLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMyLmNoaWxkcmVuLFxuICAgICAgICAgIGRlZmF1bHRQb3NpdGlvbiA9IF90aGlzJHByb3BzMi5kZWZhdWx0UG9zaXRpb24sXG4gICAgICAgICAgZGVmYXVsdENsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5kZWZhdWx0Q2xhc3NOYW1lLFxuICAgICAgICAgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZyA9IF90aGlzJHByb3BzMi5kZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmcsXG4gICAgICAgICAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQgPSBfdGhpcyRwcm9wczIuZGVmYXVsdENsYXNzTmFtZURyYWdnZWQsXG4gICAgICAgICAgcG9zaXRpb24gPSBfdGhpcyRwcm9wczIucG9zaXRpb24sXG4gICAgICAgICAgcG9zaXRpb25PZmZzZXQgPSBfdGhpcyRwcm9wczIucG9zaXRpb25PZmZzZXQsXG4gICAgICAgICAgc2NhbGUgPSBfdGhpcyRwcm9wczIuc2NhbGUsXG4gICAgICAgICAgZHJhZ2dhYmxlQ29yZVByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzMiwgX2V4Y2x1ZGVkKTtcblxuICAgICAgdmFyIHN0eWxlID0ge307XG4gICAgICB2YXIgc3ZnVHJhbnNmb3JtID0gbnVsbDsgLy8gSWYgdGhpcyBpcyBjb250cm9sbGVkLCB3ZSBkb24ndCB3YW50IHRvIG1vdmUgaXQgLSB1bmxlc3MgaXQncyBkcmFnZ2luZy5cblxuICAgICAgdmFyIGNvbnRyb2xsZWQgPSBCb29sZWFuKHBvc2l0aW9uKTtcbiAgICAgIHZhciBkcmFnZ2FibGUgPSAhY29udHJvbGxlZCB8fCB0aGlzLnN0YXRlLmRyYWdnaW5nO1xuICAgICAgdmFyIHZhbGlkUG9zaXRpb24gPSBwb3NpdGlvbiB8fCBkZWZhdWx0UG9zaXRpb247XG4gICAgICB2YXIgdHJhbnNmb3JtT3B0cyA9IHtcbiAgICAgICAgLy8gU2V0IGxlZnQgaWYgaG9yaXpvbnRhbCBkcmFnIGlzIGVuYWJsZWRcbiAgICAgICAgeDogKDAsIF9wb3NpdGlvbkZucy5jYW5EcmFnWCkodGhpcykgJiYgZHJhZ2dhYmxlID8gdGhpcy5zdGF0ZS54IDogdmFsaWRQb3NpdGlvbi54LFxuICAgICAgICAvLyBTZXQgdG9wIGlmIHZlcnRpY2FsIGRyYWcgaXMgZW5hYmxlZFxuICAgICAgICB5OiAoMCwgX3Bvc2l0aW9uRm5zLmNhbkRyYWdZKSh0aGlzKSAmJiBkcmFnZ2FibGUgPyB0aGlzLnN0YXRlLnkgOiB2YWxpZFBvc2l0aW9uLnlcbiAgICAgIH07IC8vIElmIHRoaXMgZWxlbWVudCB3YXMgU1ZHLCB3ZSB1c2UgdGhlIGB0cmFuc2Zvcm1gIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKHRoaXMuc3RhdGUuaXNFbGVtZW50U1ZHKSB7XG4gICAgICAgIHN2Z1RyYW5zZm9ybSA9ICgwLCBfZG9tRm5zLmNyZWF0ZVNWR1RyYW5zZm9ybSkodHJhbnNmb3JtT3B0cywgcG9zaXRpb25PZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkIGEgQ1NTIHRyYW5zZm9ybSB0byBtb3ZlIHRoZSBlbGVtZW50IGFyb3VuZC4gVGhpcyBhbGxvd3MgdXMgdG8gbW92ZSB0aGUgZWxlbWVudCBhcm91bmRcbiAgICAgICAgLy8gd2l0aG91dCB3b3JyeWluZyBhYm91dCB3aGV0aGVyIG9yIG5vdCBpdCBpcyByZWxhdGl2ZWx5IG9yIGFic29sdXRlbHkgcG9zaXRpb25lZC5cbiAgICAgICAgLy8gSWYgdGhlIGl0ZW0geW91IGFyZSBkcmFnZ2luZyBhbHJlYWR5IGhhcyBhIHRyYW5zZm9ybSBzZXQsIHdyYXAgaXQgaW4gYSA8c3Bhbj4gc28gPERyYWdnYWJsZT5cbiAgICAgICAgLy8gaGFzIGEgY2xlYW4gc2xhdGUuXG4gICAgICAgIHN0eWxlID0gKDAsIF9kb21GbnMuY3JlYXRlQ1NTVHJhbnNmb3JtKSh0cmFuc2Zvcm1PcHRzLCBwb3NpdGlvbk9mZnNldCk7XG4gICAgICB9IC8vIE1hcmsgd2l0aCBjbGFzcyB3aGlsZSBkcmFnZ2luZ1xuXG5cbiAgICAgIHZhciBjbGFzc05hbWUgPSAoMCwgX2Nsc3gyLmRlZmF1bHQpKGNoaWxkcmVuLnByb3BzLmNsYXNzTmFtZSB8fCAnJywgZGVmYXVsdENsYXNzTmFtZSwgKF9jbHN4ID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xzeCwgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nLCB0aGlzLnN0YXRlLmRyYWdnaW5nKSwgX2RlZmluZVByb3BlcnR5KF9jbHN4LCBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZCwgdGhpcy5zdGF0ZS5kcmFnZ2VkKSwgX2Nsc3gpKTsgLy8gUmV1c2UgdGhlIGNoaWxkIHByb3ZpZGVkXG4gICAgICAvLyBUaGlzIG1ha2VzIGl0IGZsZXhpYmxlIHRvIHVzZSB3aGF0ZXZlciBlbGVtZW50IGlzIHdhbnRlZCAoZGl2LCB1bCwgZXRjKVxuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX0RyYWdnYWJsZUNvcmUuZGVmYXVsdCwgX2V4dGVuZHMoe30sIGRyYWdnYWJsZUNvcmVQcm9wcywge1xuICAgICAgICBvblN0YXJ0OiB0aGlzLm9uRHJhZ1N0YXJ0LFxuICAgICAgICBvbkRyYWc6IHRoaXMub25EcmFnLFxuICAgICAgICBvblN0b3A6IHRoaXMub25EcmFnU3RvcFxuICAgICAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbiksIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkcmVuLnByb3BzLnN0eWxlKSwgc3R5bGUpLFxuICAgICAgICB0cmFuc2Zvcm06IHN2Z1RyYW5zZm9ybVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxuICAgIHZhbHVlOiAvLyBSZWFjdCAxNi4zK1xuICAgIC8vIEFyaXR5IChwcm9wcywgc3RhdGUpXG4gICAgZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKF9yZWYsIF9yZWYyKVxuICAgIC8qOiA/JFNoYXBlPERyYWdnYWJsZVN0YXRlPiovXG4gICAge1xuICAgICAgdmFyIHBvc2l0aW9uID0gX3JlZi5wb3NpdGlvbjtcbiAgICAgIHZhciBwcmV2UHJvcHNQb3NpdGlvbiA9IF9yZWYyLnByZXZQcm9wc1Bvc2l0aW9uO1xuXG4gICAgICAvLyBTZXQgeC95IGlmIGEgbmV3IHBvc2l0aW9uIGlzIHByb3ZpZGVkIGluIHByb3BzIHRoYXQgaXMgZGlmZmVyZW50IHRoYW4gdGhlIHByZXZpb3VzLlxuICAgICAgaWYgKHBvc2l0aW9uICYmICghcHJldlByb3BzUG9zaXRpb24gfHwgcG9zaXRpb24ueCAhPT0gcHJldlByb3BzUG9zaXRpb24ueCB8fCBwb3NpdGlvbi55ICE9PSBwcmV2UHJvcHNQb3NpdGlvbi55KSkge1xuICAgICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJWonLCB7XG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgIHByZXZQcm9wc1Bvc2l0aW9uOiBwcmV2UHJvcHNQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBwb3NpdGlvbi54LFxuICAgICAgICAgIHk6IHBvc2l0aW9uLnksXG4gICAgICAgICAgcHJldlByb3BzUG9zaXRpb246IF9vYmplY3RTcHJlYWQoe30sIHBvc2l0aW9uKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRHJhZ2dhYmxlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGU7XG5cbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGUsIFwiZGlzcGxheU5hbWVcIiwgJ0RyYWdnYWJsZScpO1xuXG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlLCBcInByb3BUeXBlc1wiLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF9EcmFnZ2FibGVDb3JlLmRlZmF1bHQucHJvcFR5cGVzKSwge30sIHtcbiAgLyoqXG4gICAqIGBheGlzYCBkZXRlcm1pbmVzIHdoaWNoIGF4aXMgdGhlIGRyYWdnYWJsZSBjYW4gbW92ZS5cbiAgICpcbiAgICogIE5vdGUgdGhhdCBhbGwgY2FsbGJhY2tzIHdpbGwgc3RpbGwgcmV0dXJuIGRhdGEgYXMgbm9ybWFsLiBUaGlzIG9ubHlcbiAgICogIGNvbnRyb2xzIGZsdXNoaW5nIHRvIHRoZSBET00uXG4gICAqXG4gICAqICdib3RoJyBhbGxvd3MgbW92ZW1lbnQgaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5LlxuICAgKiAneCcgbGltaXRzIG1vdmVtZW50IHRvIGhvcml6b250YWwgYXhpcy5cbiAgICogJ3knIGxpbWl0cyBtb3ZlbWVudCB0byB2ZXJ0aWNhbCBheGlzLlxuICAgKiAnbm9uZScgbGltaXRzIGFsbCBtb3ZlbWVudC5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gJ2JvdGgnLlxuICAgKi9cbiAgYXhpczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFsnYm90aCcsICd4JywgJ3knLCAnbm9uZSddKSxcblxuICAvKipcbiAgICogYGJvdW5kc2AgZGV0ZXJtaW5lcyB0aGUgcmFuZ2Ugb2YgbW92ZW1lbnQgYXZhaWxhYmxlIHRvIHRoZSBlbGVtZW50LlxuICAgKiBBdmFpbGFibGUgdmFsdWVzIGFyZTpcbiAgICpcbiAgICogJ3BhcmVudCcgcmVzdHJpY3RzIG1vdmVtZW50IHdpdGhpbiB0aGUgRHJhZ2dhYmxlJ3MgcGFyZW50IG5vZGUuXG4gICAqXG4gICAqIEFsdGVybmF0aXZlbHksIHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzLCBhbGwgb2Ygd2hpY2ggYXJlIG9wdGlvbmFsOlxuICAgKlxuICAgKiB7bGVmdDogTEVGVF9CT1VORCwgcmlnaHQ6IFJJR0hUX0JPVU5ELCBib3R0b206IEJPVFRPTV9CT1VORCwgdG9wOiBUT1BfQk9VTkR9XG4gICAqXG4gICAqIEFsbCB2YWx1ZXMgYXJlIGluIHB4LlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgIDxEcmFnZ2FibGUgYm91bmRzPXt7cmlnaHQ6IDMwMCwgYm90dG9tOiAzMDB9fT5cbiAgICogICAgICAgICAgICAgIDxkaXY+Q29udGVudDwvZGl2PlxuICAgKiAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgICAgICAgKTtcbiAgICogICAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGJvdW5kczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICBsZWZ0OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHJpZ2h0OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHRvcDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICBib3R0b206IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbiAgfSksIF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsIF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbZmFsc2VdKV0pLFxuICBkZWZhdWx0Q2xhc3NOYW1lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmc6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBgZGVmYXVsdFBvc2l0aW9uYCBzcGVjaWZpZXMgdGhlIHggYW5kIHkgdGhhdCB0aGUgZHJhZ2dlZCBpdGVtIHNob3VsZCBzdGFydCBhdFxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICAgICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICAgICAgIHJldHVybiAoXG4gICAqICAgICAgICAgICAgICAgICAgPERyYWdnYWJsZSBkZWZhdWx0UG9zaXRpb249e3t4OiAyNSwgeTogMjV9fT5cbiAgICogICAgICAgICAgICAgICAgICAgICAgPGRpdj5JIHN0YXJ0IHdpdGggdHJhbnNmb3JtWDogMjVweCBhbmQgdHJhbnNmb3JtWTogMjVweDs8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICogICAgICAgICAgICAgICk7XG4gICAqICAgICAgICAgIH1cbiAgICogICAgICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBkZWZhdWx0UG9zaXRpb246IF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgeDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB5OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLFxuICBwb3NpdGlvbk9mZnNldDogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICB4OiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nXSksXG4gICAgeTogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZ10pXG4gIH0pLFxuXG4gIC8qKlxuICAgKiBgcG9zaXRpb25gLCBpZiBwcmVzZW50LCBkZWZpbmVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiAgVGhpcyBpcyBzaW1pbGFyIHRvIGhvdyBmb3JtIGVsZW1lbnRzIGluIFJlYWN0IHdvcmsgLSBpZiBubyBgcG9zaXRpb25gIGlzIHN1cHBsaWVkLCB0aGUgY29tcG9uZW50XG4gICAqICBpcyB1bmNvbnRyb2xsZWQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiAgICAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgKiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICogICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIHBvc2l0aW9uPXt7eDogMjUsIHk6IDI1fX0+XG4gICAqICAgICAgICAgICAgICAgICAgICAgIDxkaXY+SSBzdGFydCB3aXRoIHRyYW5zZm9ybVg6IDI1cHggYW5kIHRyYW5zZm9ybVk6IDI1cHg7PC9kaXY+XG4gICAqICAgICAgICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgICAgICAgICAgICApO1xuICAgKiAgICAgICAgICB9XG4gICAqICAgICAgfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgcG9zaXRpb246IF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgeDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB5OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLFxuXG4gIC8qKlxuICAgKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSBkZWZpbmVkIG9uIHRoZSBjaGlsZCwgbm90IGhlcmUuXG4gICAqL1xuICBjbGFzc05hbWU6IF9zaGltcy5kb250U2V0TWUsXG4gIHN0eWxlOiBfc2hpbXMuZG9udFNldE1lLFxuICB0cmFuc2Zvcm06IF9zaGltcy5kb250U2V0TWVcbn0pKTtcblxuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZSwgXCJkZWZhdWx0UHJvcHNcIiwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfRHJhZ2dhYmxlQ29yZS5kZWZhdWx0LmRlZmF1bHRQcm9wcyksIHt9LCB7XG4gIGF4aXM6ICdib3RoJyxcbiAgYm91bmRzOiBmYWxzZSxcbiAgZGVmYXVsdENsYXNzTmFtZTogJ3JlYWN0LWRyYWdnYWJsZScsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZzogJ3JlYWN0LWRyYWdnYWJsZS1kcmFnZ2luZycsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkOiAncmVhY3QtZHJhZ2dhYmxlLWRyYWdnZWQnLFxuICBkZWZhdWx0UG9zaXRpb246IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSxcbiAgc2NhbGU6IDFcbn0pKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX3JlYWN0RG9tID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcblxudmFyIF9kb21GbnMgPSByZXF1aXJlKFwiLi91dGlscy9kb21GbnNcIik7XG5cbnZhciBfcG9zaXRpb25GbnMgPSByZXF1aXJlKFwiLi91dGlscy9wb3NpdGlvbkZuc1wiKTtcblxudmFyIF9zaGltcyA9IHJlcXVpcmUoXCIuL3V0aWxzL3NoaW1zXCIpO1xuXG52YXIgX2xvZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvbG9nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBTaW1wbGUgYWJzdHJhY3Rpb24gZm9yIGRyYWdnaW5nIGV2ZW50cyBuYW1lcy5cbnZhciBldmVudHNGb3IgPSB7XG4gIHRvdWNoOiB7XG4gICAgc3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgICBtb3ZlOiAndG91Y2htb3ZlJyxcbiAgICBzdG9wOiAndG91Y2hlbmQnXG4gIH0sXG4gIG1vdXNlOiB7XG4gICAgc3RhcnQ6ICdtb3VzZWRvd24nLFxuICAgIG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIHN0b3A6ICdtb3VzZXVwJ1xuICB9XG59OyAvLyBEZWZhdWx0IHRvIG1vdXNlIGV2ZW50cy5cblxudmFyIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci5tb3VzZTtcbi8qOjogdHlwZSBEcmFnZ2FibGVDb3JlU3RhdGUgPSB7XG4gIGRyYWdnaW5nOiBib29sZWFuLFxuICBsYXN0WDogbnVtYmVyLFxuICBsYXN0WTogbnVtYmVyLFxuICB0b3VjaElkZW50aWZpZXI6ID9udW1iZXJcbn07Ki9cblxuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVEYXRhID0ge1xuICBub2RlOiBIVE1MRWxlbWVudCxcbiAgeDogbnVtYmVyLCB5OiBudW1iZXIsXG4gIGRlbHRhWDogbnVtYmVyLCBkZWx0YVk6IG51bWJlcixcbiAgbGFzdFg6IG51bWJlciwgbGFzdFk6IG51bWJlcixcbn07Ki9cblxuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVFdmVudEhhbmRsZXIgPSAoZTogTW91c2VFdmVudCwgZGF0YTogRHJhZ2dhYmxlRGF0YSkgPT4gdm9pZCB8IGZhbHNlOyovXG5cbi8qOjogZXhwb3J0IHR5cGUgQ29udHJvbFBvc2l0aW9uID0ge3g6IG51bWJlciwgeTogbnVtYmVyfTsqL1xuXG4vKjo6IGV4cG9ydCB0eXBlIFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uID0ge3g6IG51bWJlcnxzdHJpbmcsIHk6IG51bWJlcnxzdHJpbmd9OyovXG5cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wcyA9IHtcbiAgYWxsb3dBbnlDbGljazogYm9vbGVhbixcbiAgZGlzYWJsZWQ6IGJvb2xlYW4sXG4gIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiBib29sZWFuLFxuICBvblN0YXJ0OiBEcmFnZ2FibGVFdmVudEhhbmRsZXIsXG4gIG9uRHJhZzogRHJhZ2dhYmxlRXZlbnRIYW5kbGVyLFxuICBvblN0b3A6IERyYWdnYWJsZUV2ZW50SGFuZGxlcixcbiAgb25Nb3VzZURvd246IChlOiBNb3VzZUV2ZW50KSA9PiB2b2lkLFxuICBzY2FsZTogbnVtYmVyLFxufTsqL1xuXG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZUNvcmVQcm9wcyA9IHtcbiAgLi4uRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wcyxcbiAgY2FuY2VsOiBzdHJpbmcsXG4gIGNoaWxkcmVuOiBSZWFjdEVsZW1lbnQ8YW55PixcbiAgb2Zmc2V0UGFyZW50OiBIVE1MRWxlbWVudCxcbiAgZ3JpZDogW251bWJlciwgbnVtYmVyXSxcbiAgaGFuZGxlOiBzdHJpbmcsXG4gIG5vZGVSZWY/OiA/UmVhY3QuRWxlbWVudFJlZjxhbnk+LFxufTsqL1xuXG4vL1xuLy8gRGVmaW5lIDxEcmFnZ2FibGVDb3JlPi5cbi8vXG4vLyA8RHJhZ2dhYmxlQ29yZT4gaXMgZm9yIGFkdmFuY2VkIHVzYWdlIG9mIDxEcmFnZ2FibGU+LiBJdCBtYWludGFpbnMgbWluaW1hbCBpbnRlcm5hbCBzdGF0ZSBzbyBpdCBjYW5cbi8vIHdvcmsgd2VsbCB3aXRoIGxpYnJhcmllcyB0aGF0IHJlcXVpcmUgbW9yZSBjb250cm9sIG92ZXIgdGhlIGVsZW1lbnQuXG4vL1xudmFyIERyYWdnYWJsZUNvcmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERyYWdnYWJsZUNvcmUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRHJhZ2dhYmxlQ29yZSk7XG5cbiAgZnVuY3Rpb24gRHJhZ2dhYmxlQ29yZSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZ2dhYmxlQ29yZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0YXRlXCIsIHtcbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIC8vIFVzZWQgd2hpbGUgZHJhZ2dpbmcgdG8gZGV0ZXJtaW5lIGRlbHRhcy5cbiAgICAgIGxhc3RYOiBOYU4sXG4gICAgICBsYXN0WTogTmFOLFxuICAgICAgdG91Y2hJZGVudGlmaWVyOiBudWxsXG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibW91bnRlZFwiLCBmYWxzZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlRHJhZ1N0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGF0dGFjaCBldmVudCBoYW5kbGVycyBvbiB0b3Agb2YgdGhpcyBvbmUuXG4gICAgICBfdGhpcy5wcm9wcy5vbk1vdXNlRG93bihlKTsgLy8gT25seSBhY2NlcHQgbGVmdC1jbGlja3MuXG5cblxuICAgICAgaWYgKCFfdGhpcy5wcm9wcy5hbGxvd0FueUNsaWNrICYmIHR5cGVvZiBlLmJ1dHRvbiA9PT0gJ251bWJlcicgJiYgZS5idXR0b24gIT09IDApIHJldHVybiBmYWxzZTsgLy8gR2V0IG5vZGVzLiBCZSBzdXJlIHRvIGdyYWIgcmVsYXRpdmUgZG9jdW1lbnQgKGNvdWxkIGJlIGlmcmFtZWQpXG5cbiAgICAgIHZhciB0aGlzTm9kZSA9IF90aGlzLmZpbmRET01Ob2RlKCk7XG5cbiAgICAgIGlmICghdGhpc05vZGUgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxEcmFnZ2FibGVDb3JlPiBub3QgbW91bnRlZCBvbiBEcmFnU3RhcnQhJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpc05vZGUub3duZXJEb2N1bWVudDsgLy8gU2hvcnQgY2lyY3VpdCBpZiBoYW5kbGUgb3IgY2FuY2VsIHByb3Agd2FzIHByb3ZpZGVkIGFuZCBzZWxlY3RvciBkb2Vzbid0IG1hdGNoLlxuXG4gICAgICBpZiAoX3RoaXMucHJvcHMuZGlzYWJsZWQgfHwgIShlLnRhcmdldCBpbnN0YW5jZW9mIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuTm9kZSkgfHwgX3RoaXMucHJvcHMuaGFuZGxlICYmICEoMCwgX2RvbUZucy5tYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG8pKGUudGFyZ2V0LCBfdGhpcy5wcm9wcy5oYW5kbGUsIHRoaXNOb2RlKSB8fCBfdGhpcy5wcm9wcy5jYW5jZWwgJiYgKDAsIF9kb21GbnMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKShlLnRhcmdldCwgX3RoaXMucHJvcHMuY2FuY2VsLCB0aGlzTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiBtb2JpbGUgZGV2aWNlcywgbGlrZSBpcGFkL2lwaG9uZS5cbiAgICAgIC8vIEltcG9ydGFudCB0aGF0IHRoaXMgaXMgYWZ0ZXIgaGFuZGxlL2NhbmNlbC5cblxuXG4gICAgICBpZiAoZS50eXBlID09PSAndG91Y2hzdGFydCcpIGUucHJldmVudERlZmF1bHQoKTsgLy8gU2V0IHRvdWNoIGlkZW50aWZpZXIgaW4gY29tcG9uZW50IHN0YXRlIGlmIHRoaXMgaXMgYSB0b3VjaCBldmVudC4gVGhpcyBhbGxvd3MgdXMgdG9cbiAgICAgIC8vIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW5kaXZpZHVhbCB0b3VjaGVzIG9uIG11bHRpdG91Y2ggc2NyZWVucyBieSBpZGVudGlmeWluZyB3aGljaFxuICAgICAgLy8gdG91Y2hwb2ludCB3YXMgc2V0IHRvIHRoaXMgZWxlbWVudC5cblxuICAgICAgdmFyIHRvdWNoSWRlbnRpZmllciA9ICgwLCBfZG9tRm5zLmdldFRvdWNoSWRlbnRpZmllcikoZSk7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdG91Y2hJZGVudGlmaWVyOiB0b3VjaElkZW50aWZpZXJcbiAgICAgIH0pOyAvLyBHZXQgdGhlIGN1cnJlbnQgZHJhZyBwb2ludCBmcm9tIHRoZSBldmVudC4gVGhpcyBpcyB1c2VkIGFzIHRoZSBvZmZzZXQuXG5cblxuICAgICAgdmFyIHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIHRvdWNoSWRlbnRpZmllciwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgaWYgKHBvc2l0aW9uID09IG51bGwpIHJldHVybjsgLy8gbm90IHBvc3NpYmxlIGJ1dCBzYXRpc2ZpZXMgZmxvd1xuXG4gICAgICB2YXIgeCA9IHBvc2l0aW9uLngsXG4gICAgICAgICAgeSA9IHBvc2l0aW9uLnk7IC8vIENyZWF0ZSBhbiBldmVudCBvYmplY3Qgd2l0aCBhbGwgdGhlIGRhdGEgcGFyZW50cyBuZWVkIHRvIG1ha2UgYSBkZWNpc2lvbiBoZXJlLlxuXG4gICAgICB2YXIgY29yZUV2ZW50ID0gKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVDb3JlRGF0YSkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHgsIHkpO1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWdTdGFydDogJWonLCBjb3JlRXZlbnQpOyAvLyBDYWxsIGV2ZW50IGhhbmRsZXIuIElmIGl0IHJldHVybnMgZXhwbGljaXQgZmFsc2UsIGNhbmNlbC5cblxuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ2NhbGxpbmcnLCBfdGhpcy5wcm9wcy5vblN0YXJ0KTtcblxuICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IF90aGlzLnByb3BzLm9uU3RhcnQoZSwgY29yZUV2ZW50KTtcblxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gZmFsc2UgfHwgX3RoaXMubW91bnRlZCA9PT0gZmFsc2UpIHJldHVybjsgLy8gQWRkIGEgc3R5bGUgdG8gdGhlIGJvZHkgdG8gZGlzYWJsZSB1c2VyLXNlbGVjdC4gVGhpcyBwcmV2ZW50cyB0ZXh0IGZyb21cbiAgICAgIC8vIGJlaW5nIHNlbGVjdGVkIGFsbCBvdmVyIHRoZSBwYWdlLlxuXG4gICAgICBpZiAoX3RoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLmFkZFVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQpOyAvLyBJbml0aWF0ZSBkcmFnZ2luZy4gU2V0IHRoZSBjdXJyZW50IHggYW5kIHkgYXMgb2Zmc2V0c1xuICAgICAgLy8gc28gd2Uga25vdyBob3cgbXVjaCB3ZSd2ZSBtb3ZlZCBkdXJpbmcgdGhlIGRyYWcuIFRoaXMgYWxsb3dzIHVzXG4gICAgICAvLyB0byBkcmFnIGVsZW1lbnRzIGFyb3VuZCBldmVuIGlmIHRoZXkgaGF2ZSBiZWVuIG1vdmVkLCB3aXRob3V0IGlzc3VlLlxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgICAgICBsYXN0WDogeCxcbiAgICAgICAgbGFzdFk6IHlcbiAgICAgIH0pOyAvLyBBZGQgZXZlbnRzIHRvIHRoZSBkb2N1bWVudCBkaXJlY3RseSBzbyB3ZSBjYXRjaCB3aGVuIHRoZSB1c2VyJ3MgbW91c2UvdG91Y2ggbW92ZXMgb3V0c2lkZSBvZlxuICAgICAgLy8gdGhpcyBlbGVtZW50LiBXZSB1c2UgZGlmZmVyZW50IGV2ZW50cyBkZXBlbmRpbmcgb24gd2hldGhlciBvciBub3Qgd2UgaGF2ZSBkZXRlY3RlZCB0aGF0IHRoaXNcbiAgICAgIC8vIGlzIGEgdG91Y2gtY2FwYWJsZSBkZXZpY2UuXG5cblxuICAgICAgKDAsIF9kb21GbnMuYWRkRXZlbnQpKG93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5tb3ZlLCBfdGhpcy5oYW5kbGVEcmFnKTtcbiAgICAgICgwLCBfZG9tRm5zLmFkZEV2ZW50KShvd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3Iuc3RvcCwgX3RoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhbmRsZURyYWdcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBkcmFnIHBvaW50IGZyb20gdGhlIGV2ZW50LiBUaGlzIGlzIHVzZWQgYXMgdGhlIG9mZnNldC5cbiAgICAgIHZhciBwb3NpdGlvbiA9ICgwLCBfcG9zaXRpb25GbnMuZ2V0Q29udHJvbFBvc2l0aW9uKShlLCBfdGhpcy5zdGF0ZS50b3VjaElkZW50aWZpZXIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgeCA9IHBvc2l0aW9uLngsXG4gICAgICAgICAgeSA9IHBvc2l0aW9uLnk7IC8vIFNuYXAgdG8gZ3JpZCBpZiBwcm9wIGhhcyBiZWVuIHByb3ZpZGVkXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KF90aGlzLnByb3BzLmdyaWQpKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSB4IC0gX3RoaXMuc3RhdGUubGFzdFgsXG4gICAgICAgICAgICBkZWx0YVkgPSB5IC0gX3RoaXMuc3RhdGUubGFzdFk7XG5cbiAgICAgICAgdmFyIF9zbmFwVG9HcmlkID0gKDAsIF9wb3NpdGlvbkZucy5zbmFwVG9HcmlkKShfdGhpcy5wcm9wcy5ncmlkLCBkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgdmFyIF9zbmFwVG9HcmlkMiA9IF9zbGljZWRUb0FycmF5KF9zbmFwVG9HcmlkLCAyKTtcblxuICAgICAgICBkZWx0YVggPSBfc25hcFRvR3JpZDJbMF07XG4gICAgICAgIGRlbHRhWSA9IF9zbmFwVG9HcmlkMlsxXTtcbiAgICAgICAgaWYgKCFkZWx0YVggJiYgIWRlbHRhWSkgcmV0dXJuOyAvLyBza2lwIHVzZWxlc3MgZHJhZ1xuXG4gICAgICAgIHggPSBfdGhpcy5zdGF0ZS5sYXN0WCArIGRlbHRhWCwgeSA9IF90aGlzLnN0YXRlLmxhc3RZICsgZGVsdGFZO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29yZUV2ZW50ID0gKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVDb3JlRGF0YSkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHgsIHkpO1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWc6ICVqJywgY29yZUV2ZW50KTsgLy8gQ2FsbCBldmVudCBoYW5kbGVyLiBJZiBpdCByZXR1cm5zIGV4cGxpY2l0IGZhbHNlLCB0cmlnZ2VyIGVuZC5cblxuICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IF90aGlzLnByb3BzLm9uRHJhZyhlLCBjb3JlRXZlbnQpO1xuXG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSB8fCBfdGhpcy5tb3VudGVkID09PSBmYWxzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vICRGbG93SWdub3JlXG4gICAgICAgICAgX3RoaXMuaGFuZGxlRHJhZ1N0b3AobmV3IE1vdXNlRXZlbnQoJ21vdXNldXAnKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIE9sZCBicm93c2Vyc1xuICAgICAgICAgIHZhciBldmVudCA9ICgoZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJylcbiAgICAgICAgICAvKjogYW55Ki9cbiAgICAgICAgICApXG4gICAgICAgICAgLyo6IE1vdXNlVG91Y2hFdmVudCovXG4gICAgICAgICAgKTsgLy8gSSBzZWUgd2h5IHRoaXMgaW5zYW5pdHkgd2FzIGRlcHJlY2F0ZWRcbiAgICAgICAgICAvLyAkRmxvd0lnbm9yZVxuXG4gICAgICAgICAgZXZlbnQuaW5pdE1vdXNlRXZlbnQoJ21vdXNldXAnLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblxuICAgICAgICAgIF90aGlzLmhhbmRsZURyYWdTdG9wKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBsYXN0WDogeCxcbiAgICAgICAgbGFzdFk6IHlcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhbmRsZURyYWdTdG9wXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIV90aGlzLnN0YXRlLmRyYWdnaW5nKSByZXR1cm47XG4gICAgICB2YXIgcG9zaXRpb24gPSAoMCwgX3Bvc2l0aW9uRm5zLmdldENvbnRyb2xQb3NpdGlvbikoZSwgX3RoaXMuc3RhdGUudG91Y2hJZGVudGlmaWVyLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIHggPSBwb3NpdGlvbi54LFxuICAgICAgICAgIHkgPSBwb3NpdGlvbi55O1xuICAgICAgdmFyIGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB4LCB5KTsgLy8gQ2FsbCBldmVudCBoYW5kbGVyXG5cbiAgICAgIHZhciBzaG91bGRDb250aW51ZSA9IF90aGlzLnByb3BzLm9uU3RvcChlLCBjb3JlRXZlbnQpO1xuXG4gICAgICBpZiAoc2hvdWxkQ29udGludWUgPT09IGZhbHNlIHx8IF90aGlzLm1vdW50ZWQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHZhciB0aGlzTm9kZSA9IF90aGlzLmZpbmRET01Ob2RlKCk7XG5cbiAgICAgIGlmICh0aGlzTm9kZSkge1xuICAgICAgICAvLyBSZW1vdmUgdXNlci1zZWxlY3QgaGFja1xuICAgICAgICBpZiAoX3RoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlQ29yZTogaGFuZGxlRHJhZ1N0b3A6ICVqJywgY29yZUV2ZW50KTsgLy8gUmVzZXQgdGhlIGVsLlxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgbGFzdFg6IE5hTixcbiAgICAgICAgbGFzdFk6IE5hTlxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzTm9kZSkge1xuICAgICAgICAvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IFJlbW92aW5nIGhhbmRsZXJzJyk7XG4gICAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KSh0aGlzTm9kZS5vd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3IubW92ZSwgX3RoaXMuaGFuZGxlRHJhZyk7XG4gICAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KSh0aGlzTm9kZS5vd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3Iuc3RvcCwgX3RoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uTW91c2VEb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7IC8vIG9uIHRvdWNoc2NyZWVuIGxhcHRvcHMgd2UgY291bGQgc3dpdGNoIGJhY2sgdG8gbW91c2VcblxuICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZURyYWdTdGFydChlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbk1vdXNlVXBcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci5tb3VzZTtcbiAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVEcmFnU3RvcChlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblRvdWNoU3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIFdlJ3JlIG9uIGEgdG91Y2ggZGV2aWNlIG5vdywgc28gY2hhbmdlIHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLnRvdWNoO1xuICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZURyYWdTdGFydChlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblRvdWNoRW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBXZSdyZSBvbiBhIHRvdWNoIGRldmljZSBub3csIHNvIGNoYW5nZSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci50b3VjaDtcbiAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVEcmFnU3RvcChlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEcmFnZ2FibGVDb3JlLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7IC8vIFRvdWNoIGhhbmRsZXJzIG11c3QgYmUgYWRkZWQgd2l0aCB7cGFzc2l2ZTogZmFsc2V9IHRvIGJlIGNhbmNlbGFibGUuXG4gICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzAxL3Njcm9sbGluZy1pbnRlcnZlbnRpb25cblxuICAgICAgdmFyIHRoaXNOb2RlID0gdGhpcy5maW5kRE9NTm9kZSgpO1xuXG4gICAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgICAgKDAsIF9kb21GbnMuYWRkRXZlbnQpKHRoaXNOb2RlLCBldmVudHNGb3IudG91Y2guc3RhcnQsIHRoaXMub25Ub3VjaFN0YXJ0LCB7XG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7IC8vIFJlbW92ZSBhbnkgbGVmdG92ZXIgZXZlbnQgaGFuZGxlcnMuIFJlbW92ZSBib3RoIHRvdWNoIGFuZCBtb3VzZSBoYW5kbGVycyBpbiBjYXNlXG4gICAgICAvLyBzb21lIGJyb3dzZXIgcXVpcmsgY2F1c2VkIGEgdG91Y2ggZXZlbnQgdG8gZmlyZSBkdXJpbmcgYSBtb3VzZSBtb3ZlLCBvciB2aWNlIHZlcnNhLlxuXG4gICAgICB2YXIgdGhpc05vZGUgPSB0aGlzLmZpbmRET01Ob2RlKCk7XG5cbiAgICAgIGlmICh0aGlzTm9kZSkge1xuICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXNOb2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IubW91c2UubW92ZSwgdGhpcy5oYW5kbGVEcmFnKTtcbiAgICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci50b3VjaC5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkob3duZXJEb2N1bWVudCwgZXZlbnRzRm9yLm1vdXNlLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkob3duZXJEb2N1bWVudCwgZXZlbnRzRm9yLnRvdWNoLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkodGhpc05vZGUsIGV2ZW50c0Zvci50b3VjaC5zdGFydCwgdGhpcy5vblRvdWNoU3RhcnQsIHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgIH0gLy8gUmVhY3QgU3RyaWN0IE1vZGUgY29tcGF0aWJpbGl0eTogaWYgYG5vZGVSZWZgIGlzIHBhc3NlZCwgd2Ugd2lsbCB1c2UgaXQgaW5zdGVhZCBvZiB0cnlpbmcgdG8gZmluZFxuICAgIC8vIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlIG91cnNlbHZlcy4gU2VlIHRoZSBSRUFETUUgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5kRE9NTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kRE9NTm9kZSgpXG4gICAgLyo6ID9IVE1MRWxlbWVudCovXG4gICAge1xuICAgICAgdmFyIF90aGlzJHByb3BzJG5vZGVSZWYkYywgX3RoaXMkcHJvcHMsIF90aGlzJHByb3BzJG5vZGVSZWY7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkcHJvcHMkbm9kZVJlZiRjID0gKF90aGlzJHByb3BzID0gdGhpcy5wcm9wcykgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGhpcyRwcm9wcyRub2RlUmVmID0gX3RoaXMkcHJvcHMubm9kZVJlZikgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMkbm9kZVJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkbm9kZVJlZi5jdXJyZW50KSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyRub2RlUmVmJGMgIT09IHZvaWQgMCA/IF90aGlzJHByb3BzJG5vZGVSZWYkYyA6IF9yZWFjdERvbS5kZWZhdWx0LmZpbmRET01Ob2RlKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKClcbiAgICAvKjogUmVhY3QuRWxlbWVudDxhbnk+Ki9cbiAgICB7XG4gICAgICAvLyBSZXVzZSB0aGUgY2hpbGQgcHJvdmlkZWRcbiAgICAgIC8vIFRoaXMgbWFrZXMgaXQgZmxleGlibGUgdG8gdXNlIHdoYXRldmVyIGVsZW1lbnQgaXMgd2FudGVkIChkaXYsIHVsLCBldGMpXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB7XG4gICAgICAgIC8vIE5vdGU6IG1vdXNlTW92ZSBoYW5kbGVyIGlzIGF0dGFjaGVkIHRvIGRvY3VtZW50IHNvIGl0IHdpbGwgc3RpbGwgZnVuY3Rpb25cbiAgICAgICAgLy8gd2hlbiB0aGUgdXNlciBkcmFncyBxdWlja2x5IGFuZCBsZWF2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZWxlbWVudC5cbiAgICAgICAgb25Nb3VzZURvd246IHRoaXMub25Nb3VzZURvd24sXG4gICAgICAgIG9uTW91c2VVcDogdGhpcy5vbk1vdXNlVXAsXG4gICAgICAgIC8vIG9uVG91Y2hTdGFydCBpcyBhZGRlZCBvbiBgY29tcG9uZW50RGlkTW91bnRgIHNvIHRoZXkgY2FuIGJlIGFkZGVkIHdpdGhcbiAgICAgICAgLy8ge3Bhc3NpdmU6IGZhbHNlfSwgd2hpY2ggYWxsb3dzIGl0IHRvIGNhbmNlbC4gU2VlXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTcvMDEvc2Nyb2xsaW5nLWludGVydmVudGlvblxuICAgICAgICBvblRvdWNoRW5kOiB0aGlzLm9uVG91Y2hFbmRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEcmFnZ2FibGVDb3JlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGVDb3JlO1xuXG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlQ29yZSwgXCJkaXNwbGF5TmFtZVwiLCAnRHJhZ2dhYmxlQ29yZScpO1xuXG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlQ29yZSwgXCJwcm9wVHlwZXNcIiwge1xuICAvKipcbiAgICogYGFsbG93QW55Q2xpY2tgIGFsbG93cyBkcmFnZ2luZyB1c2luZyBhbnkgbW91c2UgYnV0dG9uLlxuICAgKiBCeSBkZWZhdWx0LCB3ZSBvbmx5IGFjY2VwdCB0aGUgbGVmdCBidXR0b24uXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqL1xuICBhbGxvd0FueUNsaWNrOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogYGRpc2FibGVkYCwgaWYgdHJ1ZSwgc3RvcHMgdGhlIDxEcmFnZ2FibGU+IGZyb20gZHJhZ2dpbmcuIEFsbCBoYW5kbGVycyxcbiAgICogd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGBvbk1vdXNlRG93bmAsIHdpbGwgbm90IGZpcmUuXG4gICAqL1xuICBkaXNhYmxlZDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQsIHdlIGFkZCAndXNlci1zZWxlY3Q6bm9uZScgYXR0cmlidXRlcyB0byB0aGUgZG9jdW1lbnQgYm9keVxuICAgKiB0byBwcmV2ZW50IHVnbHkgdGV4dCBzZWxlY3Rpb24gZHVyaW5nIGRyYWcuIElmIHRoaXMgaXMgY2F1c2luZyBwcm9ibGVtc1xuICAgKiBmb3IgeW91ciBhcHAsIHNldCB0aGlzIHRvIGBmYWxzZWAuXG4gICAqL1xuICBlbmFibGVVc2VyU2VsZWN0SGFjazogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIGBvZmZzZXRQYXJlbnRgLCBpZiBzZXQsIHVzZXMgdGhlIHBhc3NlZCBET00gbm9kZSB0byBjb21wdXRlIGRyYWcgb2Zmc2V0c1xuICAgKiBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBwYXJlbnQgbm9kZS5cbiAgICovXG4gIG9mZnNldFBhcmVudDogZnVuY3Rpb24gb2Zmc2V0UGFyZW50KHByb3BzXG4gIC8qOiBEcmFnZ2FibGVDb3JlUHJvcHMqL1xuICAsIHByb3BOYW1lXG4gIC8qOiAkS2V5czxEcmFnZ2FibGVDb3JlUHJvcHM+Ki9cbiAgKSB7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSAmJiBwcm9wc1twcm9wTmFtZV0ubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHJhZ2dhYmxlXFwncyBvZmZzZXRQYXJlbnQgbXVzdCBiZSBhIERPTSBOb2RlLicpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogYGdyaWRgIHNwZWNpZmllcyB0aGUgeCBhbmQgeSB0aGF0IGRyYWdnaW5nIHNob3VsZCBzbmFwIHRvLlxuICAgKi9cbiAgZ3JpZDogX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciksXG5cbiAgLyoqXG4gICAqIGBoYW5kbGVgIHNwZWNpZmllcyBhIHNlbGVjdG9yIHRvIGJlIHVzZWQgYXMgdGhlIGhhbmRsZSB0aGF0IGluaXRpYXRlcyBkcmFnLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgIDxEcmFnZ2FibGUgaGFuZGxlPVwiLmhhbmRsZVwiPlxuICAgKiAgICAgICAgICAgICAgPGRpdj5cbiAgICogICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhhbmRsZVwiPkNsaWNrIG1lIHRvIGRyYWc8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICA8ZGl2PlRoaXMgaXMgc29tZSBvdGhlciBjb250ZW50PC9kaXY+XG4gICAqICAgICAgICAgICAgICA8L2Rpdj5cbiAgICogICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBoYW5kbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIGBjYW5jZWxgIHNwZWNpZmllcyBhIHNlbGVjdG9yIHRvIGJlIHVzZWQgdG8gcHJldmVudCBkcmFnIGluaXRpYWxpemF0aW9uLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICAgIHJldHVybihcbiAgICogICAgICAgICAgICAgICA8RHJhZ2dhYmxlIGNhbmNlbD1cIi5jYW5jZWxcIj5cbiAgICogICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhbmNlbFwiPllvdSBjYW4ndCBkcmFnIGZyb20gaGVyZTwvZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgICAgIDxkaXY+RHJhZ2dpbmcgaGVyZSB3b3JrcyBmaW5lPC9kaXY+XG4gICAqICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgKiAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICAgKTtcbiAgICogICAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGNhbmNlbDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcblxuICAvKiBJZiBydW5uaW5nIGluIFJlYWN0IFN0cmljdCBtb2RlLCBSZWFjdERPTS5maW5kRE9NTm9kZSgpIGlzIGRlcHJlY2F0ZWQuXG4gICAqIFVuZm9ydHVuYXRlbHksIGluIG9yZGVyIGZvciA8RHJhZ2dhYmxlPiB0byB3b3JrIHByb3Blcmx5LCB3ZSBuZWVkIHJhdyBhY2Nlc3NcbiAgICogdG8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUuIElmIHlvdSB3YW50IHRvIGF2b2lkIHRoZSB3YXJuaW5nLCBwYXNzIGEgYG5vZGVSZWZgXG4gICAqIGFzIGluIHRoaXMgZXhhbXBsZTpcbiAgICpcbiAgICogZnVuY3Rpb24gTXlDb21wb25lbnQoKSB7XG4gICAqICAgY29uc3Qgbm9kZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICogICByZXR1cm4gKFxuICAgKiAgICAgPERyYWdnYWJsZSBub2RlUmVmPXtub2RlUmVmfT5cbiAgICogICAgICAgPGRpdiByZWY9e25vZGVSZWZ9PkV4YW1wbGUgVGFyZ2V0PC9kaXY+XG4gICAqICAgICA8L0RyYWdnYWJsZT5cbiAgICogICApO1xuICAgKiB9XG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGFyYml0cmFyaWx5IG5lc3RlZCBjb21wb25lbnRzLCBzbyBsb25nIGFzIHRoZSByZWYgZW5kcyB1cFxuICAgKiBwb2ludGluZyB0byB0aGUgYWN0dWFsIGNoaWxkIERPTSBub2RlIGFuZCBub3QgYSBjdXN0b20gY29tcG9uZW50LlxuICAgKi9cbiAgbm9kZVJlZjogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdCxcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzLlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIGRyYWdnaW5nIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAqL1xuICBvblN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGVkIHdoaWxlIGRyYWdnaW5nLlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIGRyYWdnaW5nIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAqL1xuICBvbkRyYWc6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBkcmFnZ2luZyBzdG9wcy5cbiAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBib29sZWFuIGZhbHNlLCB0aGUgZHJhZyB3aWxsIHJlbWFpbiBhY3RpdmUuXG4gICAqL1xuICBvblN0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuXG4gIC8qKlxuICAgKiBBIHdvcmthcm91bmQgb3B0aW9uIHdoaWNoIGNhbiBiZSBwYXNzZWQgaWYgb25Nb3VzZURvd24gbmVlZHMgdG8gYmUgYWNjZXNzZWQsXG4gICAqIHNpbmNlIGl0J2xsIGFsd2F5cyBiZSBibG9ja2VkIChhcyB0aGVyZSBpcyBpbnRlcm5hbCB1c2Ugb2Ygb25Nb3VzZURvd24pXG4gICAqL1xuICBvbk1vdXNlRG93bjogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG5cbiAgLyoqXG4gICAqIGBzY2FsZWAsIGlmIHNldCwgYXBwbGllcyBzY2FsaW5nIHdoaWxlIGRyYWdnaW5nIGFuIGVsZW1lbnRcbiAgICovXG4gIHNjYWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSBkZWZpbmVkIG9uIHRoZSBjaGlsZCwgbm90IGhlcmUuXG4gICAqL1xuICBjbGFzc05hbWU6IF9zaGltcy5kb250U2V0TWUsXG4gIHN0eWxlOiBfc2hpbXMuZG9udFNldE1lLFxuICB0cmFuc2Zvcm06IF9zaGltcy5kb250U2V0TWVcbn0pO1xuXG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlQ29yZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBhbGxvd0FueUNsaWNrOiBmYWxzZSxcbiAgLy8gYnkgZGVmYXVsdCBvbmx5IGFjY2VwdCBsZWZ0IGNsaWNrXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgZW5hYmxlVXNlclNlbGVjdEhhY2s6IHRydWUsXG4gIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7fSxcbiAgb25EcmFnOiBmdW5jdGlvbiBvbkRyYWcoKSB7fSxcbiAgb25TdG9wOiBmdW5jdGlvbiBvblN0b3AoKSB7fSxcbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uIG9uTW91c2VEb3duKCkge30sXG4gIHNjYWxlOiAxXG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9EcmFnZ2FibGUnKSxcbiAgICBEcmFnZ2FibGUgPSBfcmVxdWlyZS5kZWZhdWx0LFxuICAgIERyYWdnYWJsZUNvcmUgPSBfcmVxdWlyZS5EcmFnZ2FibGVDb3JlOyAvLyBQcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGlzIGxpYiBleHBvcnRlZCA8RHJhZ2dhYmxlPiBhcyB0aGUgcm9vdCBleHBvcnQuIEFzIHRvIG5vLS8vIHRoZW0sIG9yIFR5cGVTY3JpcHQsIHdlIGV4cG9ydCAqYm90aCogYXMgdGhlIHJvb3QgYW5kIGFzICdkZWZhdWx0Jy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9yZWFjdC1kcmFnZ2FibGUvcHVsbC8yNTRcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9yZWFjdC1kcmFnZ2FibGUvaXNzdWVzLzI2NlxuXG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZ2dhYmxlO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IERyYWdnYWJsZTtcbm1vZHVsZS5leHBvcnRzLkRyYWdnYWJsZUNvcmUgPSBEcmFnZ2FibGVDb3JlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hdGNoZXNTZWxlY3RvciA9IG1hdGNoZXNTZWxlY3RvcjtcbmV4cG9ydHMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvID0gbWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvO1xuZXhwb3J0cy5hZGRFdmVudCA9IGFkZEV2ZW50O1xuZXhwb3J0cy5yZW1vdmVFdmVudCA9IHJlbW92ZUV2ZW50O1xuZXhwb3J0cy5vdXRlckhlaWdodCA9IG91dGVySGVpZ2h0O1xuZXhwb3J0cy5vdXRlcldpZHRoID0gb3V0ZXJXaWR0aDtcbmV4cG9ydHMuaW5uZXJIZWlnaHQgPSBpbm5lckhlaWdodDtcbmV4cG9ydHMuaW5uZXJXaWR0aCA9IGlubmVyV2lkdGg7XG5leHBvcnRzLm9mZnNldFhZRnJvbVBhcmVudCA9IG9mZnNldFhZRnJvbVBhcmVudDtcbmV4cG9ydHMuY3JlYXRlQ1NTVHJhbnNmb3JtID0gY3JlYXRlQ1NTVHJhbnNmb3JtO1xuZXhwb3J0cy5jcmVhdGVTVkdUcmFuc2Zvcm0gPSBjcmVhdGVTVkdUcmFuc2Zvcm07XG5leHBvcnRzLmdldFRyYW5zbGF0aW9uID0gZ2V0VHJhbnNsYXRpb247XG5leHBvcnRzLmdldFRvdWNoID0gZ2V0VG91Y2g7XG5leHBvcnRzLmdldFRvdWNoSWRlbnRpZmllciA9IGdldFRvdWNoSWRlbnRpZmllcjtcbmV4cG9ydHMuYWRkVXNlclNlbGVjdFN0eWxlcyA9IGFkZFVzZXJTZWxlY3RTdHlsZXM7XG5leHBvcnRzLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMgPSByZW1vdmVVc2VyU2VsZWN0U3R5bGVzO1xuZXhwb3J0cy5hZGRDbGFzc05hbWUgPSBhZGRDbGFzc05hbWU7XG5leHBvcnRzLnJlbW92ZUNsYXNzTmFtZSA9IHJlbW92ZUNsYXNzTmFtZTtcblxudmFyIF9zaGltcyA9IHJlcXVpcmUoXCIuL3NoaW1zXCIpO1xuXG52YXIgX2dldFByZWZpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2dldFByZWZpeFwiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgbWF0Y2hlc1NlbGVjdG9yRnVuYyA9ICcnO1xuXG5mdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3IoZWxcbi8qOiBOb2RlKi9cbiwgc2VsZWN0b3Jcbi8qOiBzdHJpbmcqL1xuKVxuLyo6IGJvb2xlYW4qL1xue1xuICBpZiAoIW1hdGNoZXNTZWxlY3RvckZ1bmMpIHtcbiAgICBtYXRjaGVzU2VsZWN0b3JGdW5jID0gKDAsIF9zaGltcy5maW5kSW5BcnJheSkoWydtYXRjaGVzJywgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicsICdtb3pNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnb01hdGNoZXNTZWxlY3RvciddLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG4gICAgICByZXR1cm4gKDAsIF9zaGltcy5pc0Z1bmN0aW9uKShlbFttZXRob2RdKTtcbiAgICB9KTtcbiAgfSAvLyBNaWdodCBub3QgYmUgZm91bmQgZW50aXJlbHkgKG5vdCBhbiBFbGVtZW50PykgLSBpbiB0aGF0IGNhc2UsIGJhaWxcbiAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuXG5cbiAgaWYgKCEoMCwgX3NoaW1zLmlzRnVuY3Rpb24pKGVsW21hdGNoZXNTZWxlY3RvckZ1bmNdKSkgcmV0dXJuIGZhbHNlOyAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG5cbiAgcmV0dXJuIGVsW21hdGNoZXNTZWxlY3RvckZ1bmNdKHNlbGVjdG9yKTtcbn0gLy8gV29ya3MgdXAgdGhlIHRyZWUgdG8gdGhlIGRyYWdnYWJsZSBpdHNlbGYgYXR0ZW1wdGluZyB0byBtYXRjaCBzZWxlY3Rvci5cblxuXG5mdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG8oZWxcbi8qOiBOb2RlKi9cbiwgc2VsZWN0b3Jcbi8qOiBzdHJpbmcqL1xuLCBiYXNlTm9kZVxuLyo6IE5vZGUqL1xuKVxuLyo6IGJvb2xlYW4qL1xue1xuICB2YXIgbm9kZSA9IGVsO1xuXG4gIGRvIHtcbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKG5vZGUsIHNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKG5vZGUgPT09IGJhc2VOb2RlKSByZXR1cm4gZmFsc2U7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfSB3aGlsZSAobm9kZSk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudChlbFxuLyo6ID9Ob2RlKi9cbiwgZXZlbnRcbi8qOiBzdHJpbmcqL1xuLCBoYW5kbGVyXG4vKjogRnVuY3Rpb24qL1xuLCBpbnB1dE9wdGlvbnNcbi8qOiBPYmplY3QqL1xuKVxuLyo6IHZvaWQqL1xue1xuICBpZiAoIWVsKSByZXR1cm47XG5cbiAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBjYXB0dXJlOiB0cnVlXG4gIH0sIGlucHV0T3B0aW9ucyk7IC8vICRGbG93SWdub3JlW21ldGhvZC11bmJpbmRpbmddXG5cblxuICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG4gICAgZWxbJ29uJyArIGV2ZW50XSA9IGhhbmRsZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWxcbi8qOiA/Tm9kZSovXG4sIGV2ZW50XG4vKjogc3RyaW5nKi9cbiwgaGFuZGxlclxuLyo6IEZ1bmN0aW9uKi9cbiwgaW5wdXRPcHRpb25zXG4vKjogT2JqZWN0Ki9cbilcbi8qOiB2b2lkKi9cbntcbiAgaWYgKCFlbCkgcmV0dXJuO1xuXG4gIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7XG4gICAgY2FwdHVyZTogdHJ1ZVxuICB9LCBpbnB1dE9wdGlvbnMpOyAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuXG5cbiAgaWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmIChlbC5kZXRhY2hFdmVudCkge1xuICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgaGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICAgIGVsWydvbicgKyBldmVudF0gPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIG91dGVySGVpZ2h0KG5vZGVcbi8qOiBIVE1MRWxlbWVudCovXG4pXG4vKjogbnVtYmVyKi9cbntcbiAgLy8gVGhpcyBpcyBkZWxpYmVyYXRlbHkgZXhjbHVkaW5nIG1hcmdpbiBmb3Igb3VyIGNhbGN1bGF0aW9ucywgc2luY2Ugd2UgYXJlIHVzaW5nXG4gIC8vIG9mZnNldFRvcCB3aGljaCBpcyBpbmNsdWRpbmcgbWFyZ2luLiBTZWUgZ2V0Qm91bmRQb3NpdGlvblxuICB2YXIgaGVpZ2h0ID0gbm9kZS5jbGllbnRIZWlnaHQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGhlaWdodCArPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCk7XG4gIGhlaWdodCArPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCk7XG4gIHJldHVybiBoZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIG91dGVyV2lkdGgobm9kZVxuLyo6IEhUTUxFbGVtZW50Ki9cbilcbi8qOiBudW1iZXIqL1xue1xuICAvLyBUaGlzIGlzIGRlbGliZXJhdGVseSBleGNsdWRpbmcgbWFyZ2luIGZvciBvdXIgY2FsY3VsYXRpb25zLCBzaW5jZSB3ZSBhcmUgdXNpbmdcbiAgLy8gb2Zmc2V0TGVmdCB3aGljaCBpcyBpbmNsdWRpbmcgbWFyZ2luLiBTZWUgZ2V0Qm91bmRQb3NpdGlvblxuICB2YXIgd2lkdGggPSBub2RlLmNsaWVudFdpZHRoO1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICB3aWR0aCArPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgpO1xuICB3aWR0aCArPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoKTtcbiAgcmV0dXJuIHdpZHRoO1xufVxuXG5mdW5jdGlvbiBpbm5lckhlaWdodChub2RlXG4vKjogSFRNTEVsZW1lbnQqL1xuKVxuLyo6IG51bWJlciovXG57XG4gIHZhciBoZWlnaHQgPSBub2RlLmNsaWVudEhlaWdodDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgaGVpZ2h0IC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApO1xuICBoZWlnaHQgLT0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gIHJldHVybiBoZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGlubmVyV2lkdGgobm9kZVxuLyo6IEhUTUxFbGVtZW50Ki9cbilcbi8qOiBudW1iZXIqL1xue1xuICB2YXIgd2lkdGggPSBub2RlLmNsaWVudFdpZHRoO1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICB3aWR0aCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCk7XG4gIHdpZHRoIC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gIHJldHVybiB3aWR0aDtcbn1cbi8qOjogaW50ZXJmYWNlIEV2ZW50V2l0aE9mZnNldCB7XG4gIGNsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyXG59Ki9cblxuXG4vLyBHZXQgZnJvbSBvZmZzZXRQYXJlbnRcbmZ1bmN0aW9uIG9mZnNldFhZRnJvbVBhcmVudChldnRcbi8qOiBFdmVudFdpdGhPZmZzZXQqL1xuLCBvZmZzZXRQYXJlbnRcbi8qOiBIVE1MRWxlbWVudCovXG4sIHNjYWxlXG4vKjogbnVtYmVyKi9cbilcbi8qOiBDb250cm9sUG9zaXRpb24qL1xue1xuICB2YXIgaXNCb2R5ID0gb2Zmc2V0UGFyZW50ID09PSBvZmZzZXRQYXJlbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGlzQm9keSA/IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMFxuICB9IDogb2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgeCA9IChldnQuY2xpZW50WCArIG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0IC0gb2Zmc2V0UGFyZW50UmVjdC5sZWZ0KSAvIHNjYWxlO1xuICB2YXIgeSA9IChldnQuY2xpZW50WSArIG9mZnNldFBhcmVudC5zY3JvbGxUb3AgLSBvZmZzZXRQYXJlbnRSZWN0LnRvcCkgLyBzY2FsZTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ1NTVHJhbnNmb3JtKGNvbnRyb2xQb3Ncbi8qOiBDb250cm9sUG9zaXRpb24qL1xuLCBwb3NpdGlvbk9mZnNldFxuLyo6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uKi9cbilcbi8qOiBPYmplY3QqL1xue1xuICB2YXIgdHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbihjb250cm9sUG9zLCBwb3NpdGlvbk9mZnNldCwgJ3B4Jyk7XG4gIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sICgwLCBfZ2V0UHJlZml4LmJyb3dzZXJQcmVmaXhUb0tleSkoJ3RyYW5zZm9ybScsIF9nZXRQcmVmaXguZGVmYXVsdCksIHRyYW5zbGF0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU1ZHVHJhbnNmb3JtKGNvbnRyb2xQb3Ncbi8qOiBDb250cm9sUG9zaXRpb24qL1xuLCBwb3NpdGlvbk9mZnNldFxuLyo6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uKi9cbilcbi8qOiBzdHJpbmcqL1xue1xuICB2YXIgdHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbihjb250cm9sUG9zLCBwb3NpdGlvbk9mZnNldCwgJycpO1xuICByZXR1cm4gdHJhbnNsYXRpb247XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKF9yZWYyLCBwb3NpdGlvbk9mZnNldFxuLyo6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uKi9cbiwgdW5pdFN1ZmZpeFxuLyo6IHN0cmluZyovXG4pXG4vKjogc3RyaW5nKi9cbntcbiAgdmFyIHggPSBfcmVmMi54LFxuICAgICAgeSA9IF9yZWYyLnk7XG4gIHZhciB0cmFuc2xhdGlvbiA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh4KS5jb25jYXQodW5pdFN1ZmZpeCwgXCIsXCIpLmNvbmNhdCh5KS5jb25jYXQodW5pdFN1ZmZpeCwgXCIpXCIpO1xuXG4gIGlmIChwb3NpdGlvbk9mZnNldCkge1xuICAgIHZhciBkZWZhdWx0WCA9IFwiXCIuY29uY2F0KHR5cGVvZiBwb3NpdGlvbk9mZnNldC54ID09PSAnc3RyaW5nJyA/IHBvc2l0aW9uT2Zmc2V0LnggOiBwb3NpdGlvbk9mZnNldC54ICsgdW5pdFN1ZmZpeCk7XG4gICAgdmFyIGRlZmF1bHRZID0gXCJcIi5jb25jYXQodHlwZW9mIHBvc2l0aW9uT2Zmc2V0LnkgPT09ICdzdHJpbmcnID8gcG9zaXRpb25PZmZzZXQueSA6IHBvc2l0aW9uT2Zmc2V0LnkgKyB1bml0U3VmZml4KTtcbiAgICB0cmFuc2xhdGlvbiA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChkZWZhdWx0WCwgXCIsIFwiKS5jb25jYXQoZGVmYXVsdFksIFwiKVwiKSArIHRyYW5zbGF0aW9uO1xuICB9XG5cbiAgcmV0dXJuIHRyYW5zbGF0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRUb3VjaChlXG4vKjogTW91c2VUb3VjaEV2ZW50Ki9cbiwgaWRlbnRpZmllclxuLyo6IG51bWJlciovXG4pXG4vKjogP3tjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlcn0qL1xue1xuICByZXR1cm4gZS50YXJnZXRUb3VjaGVzICYmICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKGUudGFyZ2V0VG91Y2hlcywgZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllciA9PT0gdC5pZGVudGlmaWVyO1xuICB9KSB8fCBlLmNoYW5nZWRUb3VjaGVzICYmICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKGUuY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXIgPT09IHQuaWRlbnRpZmllcjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFRvdWNoSWRlbnRpZmllcihlXG4vKjogTW91c2VUb3VjaEV2ZW50Ki9cbilcbi8qOiA/bnVtYmVyKi9cbntcbiAgaWYgKGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXNbMF0pIHJldHVybiBlLnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbiAgaWYgKGUuY2hhbmdlZFRvdWNoZXMgJiYgZS5jaGFuZ2VkVG91Y2hlc1swXSkgcmV0dXJuIGUuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbn0gLy8gVXNlci1zZWxlY3QgSGFja3M6XG4vL1xuLy8gVXNlZnVsIGZvciBwcmV2ZW50aW5nIGJsdWUgaGlnaGxpZ2h0cyBhbGwgb3ZlciBldmVyeXRoaW5nIHdoZW4gZHJhZ2dpbmcuXG4vLyBOb3RlIHdlJ3JlIHBhc3NpbmcgYGRvY3VtZW50YCBiL2Mgd2UgY291bGQgYmUgaWZyYW1lZFxuXG5cbmZ1bmN0aW9uIGFkZFVzZXJTZWxlY3RTdHlsZXMoZG9jXG4vKjogP0RvY3VtZW50Ki9cbikge1xuICBpZiAoIWRvYykgcmV0dXJuO1xuICB2YXIgc3R5bGVFbCA9IGRvYy5nZXRFbGVtZW50QnlJZCgncmVhY3QtZHJhZ2dhYmxlLXN0eWxlLWVsJyk7XG5cbiAgaWYgKCFzdHlsZUVsKSB7XG4gICAgc3R5bGVFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlRWwudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgc3R5bGVFbC5pZCA9ICdyZWFjdC1kcmFnZ2FibGUtc3R5bGUtZWwnO1xuICAgIHN0eWxlRWwuaW5uZXJIVE1MID0gJy5yZWFjdC1kcmFnZ2FibGUtdHJhbnNwYXJlbnQtc2VsZWN0aW9uICo6Oi1tb3otc2VsZWN0aW9uIHthbGw6IGluaGVyaXQ7fVxcbic7XG4gICAgc3R5bGVFbC5pbm5lckhUTUwgKz0gJy5yZWFjdC1kcmFnZ2FibGUtdHJhbnNwYXJlbnQtc2VsZWN0aW9uICo6OnNlbGVjdGlvbiB7YWxsOiBpbmhlcml0O31cXG4nO1xuICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlRWwpO1xuICB9XG5cbiAgaWYgKGRvYy5ib2R5KSBhZGRDbGFzc05hbWUoZG9jLmJvZHksICdyZWFjdC1kcmFnZ2FibGUtdHJhbnNwYXJlbnQtc2VsZWN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVVzZXJTZWxlY3RTdHlsZXMoZG9jXG4vKjogP0RvY3VtZW50Ki9cbikge1xuICBpZiAoIWRvYykgcmV0dXJuO1xuXG4gIHRyeSB7XG4gICAgaWYgKGRvYy5ib2R5KSByZW1vdmVDbGFzc05hbWUoZG9jLmJvZHksICdyZWFjdC1kcmFnZ2FibGUtdHJhbnNwYXJlbnQtc2VsZWN0aW9uJyk7IC8vICRGbG93SWdub3JlOiBJRVxuXG4gICAgaWYgKGRvYy5zZWxlY3Rpb24pIHtcbiAgICAgIC8vICRGbG93SWdub3JlOiBJRVxuICAgICAgZG9jLnNlbGVjdGlvbi5lbXB0eSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgc2VsZWN0aW9uIGNhdXNlZCBieSBzY3JvbGwsIHVubGVzcyBpdCdzIGEgZm9jdXNlZCBpbnB1dFxuICAgICAgLy8gKHdlIHVzZSBkb2MuZGVmYXVsdFZpZXcgaW4gY2FzZSB3ZSdyZSBpbiBhbiBpZnJhbWUpXG4gICAgICB2YXIgc2VsZWN0aW9uID0gKGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi50eXBlICE9PSAnQ2FyZXQnKSB7XG4gICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsvLyBwcm9iYWJseSBJRVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENsYXNzTmFtZShlbFxuLyo6IEhUTUxFbGVtZW50Ki9cbiwgY2xhc3NOYW1lXG4vKjogc3RyaW5nKi9cbikge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIGlmICghZWwuY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKVwiLmNvbmNhdChjbGFzc05hbWUsIFwiKD8hXFxcXFMpXCIpKSkpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSArPSBcIiBcIi5jb25jYXQoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lKGVsXG4vKjogSFRNTEVsZW1lbnQqL1xuLCBjbGFzc05hbWVcbi8qOiBzdHJpbmcqL1xuKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIoPyFcXFxcUylcIiksICdnJyksICcnKTtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRQcmVmaXggPSBnZXRQcmVmaXg7XG5leHBvcnRzLmJyb3dzZXJQcmVmaXhUb0tleSA9IGJyb3dzZXJQcmVmaXhUb0tleTtcbmV4cG9ydHMuYnJvd3NlclByZWZpeFRvU3R5bGUgPSBicm93c2VyUHJlZml4VG9TdHlsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBwcmVmaXhlcyA9IFsnTW96JywgJ1dlYmtpdCcsICdPJywgJ21zJ107XG5cbmZ1bmN0aW9uIGdldFByZWZpeCgpXG4vKjogc3RyaW5nKi9cbntcbiAgdmFyIF93aW5kb3ckZG9jdW1lbnQsIF93aW5kb3ckZG9jdW1lbnQkZG9jdTtcblxuICB2YXIgcHJvcFxuICAvKjogc3RyaW5nKi9cbiAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICd0cmFuc2Zvcm0nO1xuICAvLyBFbnN1cmUgd2UncmUgcnVubmluZyBpbiBhbiBlbnZpcm9ubWVudCB3aGVyZSB0aGVyZSBpcyBhY3R1YWxseSBhIGdsb2JhbFxuICAvLyBgd2luZG93YCBvYmpcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJyc7IC8vIElmIHdlJ3JlIGluIGEgcHNldWRvLWJyb3dzZXIgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQsIHRoaXMgYWNjZXNzXG4gIC8vIHBhdGggbWF5IG5vdCBleGlzdCwgc28gYmFpbCBvdXQgaWYgaXQgZG9lc24ndC5cblxuICB2YXIgc3R5bGUgPSAoX3dpbmRvdyRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkgPT09IG51bGwgfHwgX3dpbmRvdyRkb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF93aW5kb3ckZG9jdW1lbnQkZG9jdSA9IF93aW5kb3ckZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfd2luZG93JGRvY3VtZW50JGRvY3UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3ckZG9jdW1lbnQkZG9jdS5zdHlsZTtcbiAgaWYgKCFzdHlsZSkgcmV0dXJuICcnO1xuICBpZiAocHJvcCBpbiBzdHlsZSkgcmV0dXJuICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYnJvd3NlclByZWZpeFRvS2V5KHByb3AsIHByZWZpeGVzW2ldKSBpbiBzdHlsZSkgcmV0dXJuIHByZWZpeGVzW2ldO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBicm93c2VyUHJlZml4VG9LZXkocHJvcFxuLyo6IHN0cmluZyovXG4sIHByZWZpeFxuLyo6IHN0cmluZyovXG4pXG4vKjogc3RyaW5nKi9cbntcbiAgcmV0dXJuIHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCkuY29uY2F0KGtlYmFiVG9UaXRsZUNhc2UocHJvcCkpIDogcHJvcDtcbn1cblxuZnVuY3Rpb24gYnJvd3NlclByZWZpeFRvU3R5bGUocHJvcFxuLyo6IHN0cmluZyovXG4sIHByZWZpeFxuLyo6IHN0cmluZyovXG4pXG4vKjogc3RyaW5nKi9cbntcbiAgcmV0dXJuIHByZWZpeCA/IFwiLVwiLmNvbmNhdChwcmVmaXgudG9Mb3dlckNhc2UoKSwgXCItXCIpLmNvbmNhdChwcm9wKSA6IHByb3A7XG59XG5cbmZ1bmN0aW9uIGtlYmFiVG9UaXRsZUNhc2Uoc3RyXG4vKjogc3RyaW5nKi9cbilcbi8qOiBzdHJpbmcqL1xue1xuICB2YXIgb3V0ID0gJyc7XG4gIHZhciBzaG91bGRDYXBpdGFsaXplID0gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzaG91bGRDYXBpdGFsaXplKSB7XG4gICAgICBvdXQgKz0gc3RyW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICBzaG91bGRDYXBpdGFsaXplID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzdHJbaV0gPT09ICctJykge1xuICAgICAgc2hvdWxkQ2FwaXRhbGl6ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBzdHJbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn0gLy8gRGVmYXVsdCBleHBvcnQgaXMgdGhlIHByZWZpeCBpdHNlbGYsIGxpa2UgJ01veicsICdXZWJraXQnLCBldGNcbi8vIE5vdGUgdGhhdCB5b3UgbWF5IGhhdmUgdG8gcmUtdGVzdCBmb3IgY2VydGFpbiB0aGluZ3M7IGZvciBpbnN0YW5jZSwgQ2hyb21lIDUwXG4vLyBjYW4gaGFuZGxlIHVucHJlZml4ZWQgYHRyYW5zZm9ybWAsIGJ1dCBub3QgdW5wcmVmaXhlZCBgdXNlci1zZWxlY3RgXG5cblxudmFyIF9kZWZhdWx0ID0gKGdldFByZWZpeCgpXG4vKjogc3RyaW5nKi9cbik7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbG9nO1xuXG4vKmVzbGludCBuby1jb25zb2xlOjAqL1xuZnVuY3Rpb24gbG9nKCkge1xuICB2YXIgX2NvbnNvbGU7XG5cbiAgaWYgKHVuZGVmaW5lZCkgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBhcmd1bWVudHMpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRCb3VuZFBvc2l0aW9uID0gZ2V0Qm91bmRQb3NpdGlvbjtcbmV4cG9ydHMuc25hcFRvR3JpZCA9IHNuYXBUb0dyaWQ7XG5leHBvcnRzLmNhbkRyYWdYID0gY2FuRHJhZ1g7XG5leHBvcnRzLmNhbkRyYWdZID0gY2FuRHJhZ1k7XG5leHBvcnRzLmdldENvbnRyb2xQb3NpdGlvbiA9IGdldENvbnRyb2xQb3NpdGlvbjtcbmV4cG9ydHMuY3JlYXRlQ29yZURhdGEgPSBjcmVhdGVDb3JlRGF0YTtcbmV4cG9ydHMuY3JlYXRlRHJhZ2dhYmxlRGF0YSA9IGNyZWF0ZURyYWdnYWJsZURhdGE7XG5cbnZhciBfc2hpbXMgPSByZXF1aXJlKFwiLi9zaGltc1wiKTtcblxudmFyIF9kb21GbnMgPSByZXF1aXJlKFwiLi9kb21GbnNcIik7XG5cbmZ1bmN0aW9uIGdldEJvdW5kUG9zaXRpb24oZHJhZ2dhYmxlXG4vKjogRHJhZ2dhYmxlKi9cbiwgeFxuLyo6IG51bWJlciovXG4sIHlcbi8qOiBudW1iZXIqL1xuKVxuLyo6IFtudW1iZXIsIG51bWJlcl0qL1xue1xuICAvLyBJZiBubyBib3VuZHMsIHNob3J0LWNpcmN1aXQgYW5kIG1vdmUgb25cbiAgaWYgKCFkcmFnZ2FibGUucHJvcHMuYm91bmRzKSByZXR1cm4gW3gsIHldOyAvLyBDbG9uZSBuZXcgYm91bmRzXG5cbiAgdmFyIGJvdW5kcyA9IGRyYWdnYWJsZS5wcm9wcy5ib3VuZHM7XG4gIGJvdW5kcyA9IHR5cGVvZiBib3VuZHMgPT09ICdzdHJpbmcnID8gYm91bmRzIDogY2xvbmVCb3VuZHMoYm91bmRzKTtcbiAgdmFyIG5vZGUgPSBmaW5kRE9NTm9kZShkcmFnZ2FibGUpO1xuXG4gIGlmICh0eXBlb2YgYm91bmRzID09PSAnc3RyaW5nJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHZhciBvd25lcldpbmRvdyA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgdmFyIGJvdW5kTm9kZTtcblxuICAgIGlmIChib3VuZHMgPT09ICdwYXJlbnQnKSB7XG4gICAgICBib3VuZE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kTm9kZSA9IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3Rvcihib3VuZHMpO1xuICAgIH1cblxuICAgIGlmICghKGJvdW5kTm9kZSBpbnN0YW5jZW9mIG93bmVyV2luZG93LkhUTUxFbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgc2VsZWN0b3IgXCInICsgYm91bmRzICsgJ1wiIGNvdWxkIG5vdCBmaW5kIGFuIGVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kTm9kZUVsXG4gICAgLyo6IEhUTUxFbGVtZW50Ki9cbiAgICA9IGJvdW5kTm9kZTsgLy8gZm9yIEZsb3csIGNhbid0IHNlZW0gdG8gcmVmaW5lIGNvcnJlY3RseVxuXG4gICAgdmFyIG5vZGVTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgdmFyIGJvdW5kTm9kZVN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShib3VuZE5vZGVFbCk7IC8vIENvbXB1dGUgYm91bmRzLiBUaGlzIGlzIGEgcGFpbiB3aXRoIHBhZGRpbmcgYW5kIG9mZnNldHMgYnV0IHRoaXMgZ2V0cyBpdCBleGFjdGx5IHJpZ2h0LlxuXG4gICAgYm91bmRzID0ge1xuICAgICAgbGVmdDogLW5vZGUub2Zmc2V0TGVmdCArICgwLCBfc2hpbXMuaW50KShib3VuZE5vZGVTdHlsZS5wYWRkaW5nTGVmdCkgKyAoMCwgX3NoaW1zLmludCkobm9kZVN0eWxlLm1hcmdpbkxlZnQpLFxuICAgICAgdG9wOiAtbm9kZS5vZmZzZXRUb3AgKyAoMCwgX3NoaW1zLmludCkoYm91bmROb2RlU3R5bGUucGFkZGluZ1RvcCkgKyAoMCwgX3NoaW1zLmludCkobm9kZVN0eWxlLm1hcmdpblRvcCksXG4gICAgICByaWdodDogKDAsIF9kb21GbnMuaW5uZXJXaWR0aCkoYm91bmROb2RlRWwpIC0gKDAsIF9kb21GbnMub3V0ZXJXaWR0aCkobm9kZSkgLSBub2RlLm9mZnNldExlZnQgKyAoMCwgX3NoaW1zLmludCkoYm91bmROb2RlU3R5bGUucGFkZGluZ1JpZ2h0KSAtICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luUmlnaHQpLFxuICAgICAgYm90dG9tOiAoMCwgX2RvbUZucy5pbm5lckhlaWdodCkoYm91bmROb2RlRWwpIC0gKDAsIF9kb21GbnMub3V0ZXJIZWlnaHQpKG5vZGUpIC0gbm9kZS5vZmZzZXRUb3AgKyAoMCwgX3NoaW1zLmludCkoYm91bmROb2RlU3R5bGUucGFkZGluZ0JvdHRvbSkgLSAoMCwgX3NoaW1zLmludCkobm9kZVN0eWxlLm1hcmdpbkJvdHRvbSlcbiAgICB9O1xuICB9IC8vIEtlZXAgeCBhbmQgeSBiZWxvdyByaWdodCBhbmQgYm90dG9tIGxpbWl0cy4uLlxuXG5cbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy5yaWdodCkpIHggPSBNYXRoLm1pbih4LCBib3VuZHMucmlnaHQpO1xuICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLmJvdHRvbSkpIHkgPSBNYXRoLm1pbih5LCBib3VuZHMuYm90dG9tKTsgLy8gQnV0IGFib3ZlIGxlZnQgYW5kIHRvcCBsaW1pdHMuXG5cbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy5sZWZ0KSkgeCA9IE1hdGgubWF4KHgsIGJvdW5kcy5sZWZ0KTtcbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy50b3ApKSB5ID0gTWF0aC5tYXgoeSwgYm91bmRzLnRvcCk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbmZ1bmN0aW9uIHNuYXBUb0dyaWQoZ3JpZFxuLyo6IFtudW1iZXIsIG51bWJlcl0qL1xuLCBwZW5kaW5nWFxuLyo6IG51bWJlciovXG4sIHBlbmRpbmdZXG4vKjogbnVtYmVyKi9cbilcbi8qOiBbbnVtYmVyLCBudW1iZXJdKi9cbntcbiAgdmFyIHggPSBNYXRoLnJvdW5kKHBlbmRpbmdYIC8gZ3JpZFswXSkgKiBncmlkWzBdO1xuICB2YXIgeSA9IE1hdGgucm91bmQocGVuZGluZ1kgLyBncmlkWzFdKSAqIGdyaWRbMV07XG4gIHJldHVybiBbeCwgeV07XG59XG5cbmZ1bmN0aW9uIGNhbkRyYWdYKGRyYWdnYWJsZVxuLyo6IERyYWdnYWJsZSovXG4pXG4vKjogYm9vbGVhbiovXG57XG4gIHJldHVybiBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAneCc7XG59XG5cbmZ1bmN0aW9uIGNhbkRyYWdZKGRyYWdnYWJsZVxuLyo6IERyYWdnYWJsZSovXG4pXG4vKjogYm9vbGVhbiovXG57XG4gIHJldHVybiBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAneSc7XG59IC8vIEdldCB7eCwgeX0gcG9zaXRpb25zIGZyb20gZXZlbnQuXG5cblxuZnVuY3Rpb24gZ2V0Q29udHJvbFBvc2l0aW9uKGVcbi8qOiBNb3VzZVRvdWNoRXZlbnQqL1xuLCB0b3VjaElkZW50aWZpZXJcbi8qOiA/bnVtYmVyKi9cbiwgZHJhZ2dhYmxlQ29yZVxuLyo6IERyYWdnYWJsZUNvcmUqL1xuKVxuLyo6ID9Db250cm9sUG9zaXRpb24qL1xue1xuICB2YXIgdG91Y2hPYmogPSB0eXBlb2YgdG91Y2hJZGVudGlmaWVyID09PSAnbnVtYmVyJyA/ICgwLCBfZG9tRm5zLmdldFRvdWNoKShlLCB0b3VjaElkZW50aWZpZXIpIDogbnVsbDtcbiAgaWYgKHR5cGVvZiB0b3VjaElkZW50aWZpZXIgPT09ICdudW1iZXInICYmICF0b3VjaE9iaikgcmV0dXJuIG51bGw7IC8vIG5vdCB0aGUgcmlnaHQgdG91Y2hcblxuICB2YXIgbm9kZSA9IGZpbmRET01Ob2RlKGRyYWdnYWJsZUNvcmUpOyAvLyBVc2VyIGNhbiBwcm92aWRlIGFuIG9mZnNldFBhcmVudCBpZiBkZXNpcmVkLlxuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBkcmFnZ2FibGVDb3JlLnByb3BzLm9mZnNldFBhcmVudCB8fCBub2RlLm9mZnNldFBhcmVudCB8fCBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgcmV0dXJuICgwLCBfZG9tRm5zLm9mZnNldFhZRnJvbVBhcmVudCkodG91Y2hPYmogfHwgZSwgb2Zmc2V0UGFyZW50LCBkcmFnZ2FibGVDb3JlLnByb3BzLnNjYWxlKTtcbn0gLy8gQ3JlYXRlIGFuIGRhdGEgb2JqZWN0IGV4cG9zZWQgYnkgPERyYWdnYWJsZUNvcmU+J3MgZXZlbnRzXG5cblxuZnVuY3Rpb24gY3JlYXRlQ29yZURhdGEoZHJhZ2dhYmxlXG4vKjogRHJhZ2dhYmxlQ29yZSovXG4sIHhcbi8qOiBudW1iZXIqL1xuLCB5XG4vKjogbnVtYmVyKi9cbilcbi8qOiBEcmFnZ2FibGVEYXRhKi9cbntcbiAgdmFyIHN0YXRlID0gZHJhZ2dhYmxlLnN0YXRlO1xuICB2YXIgaXNTdGFydCA9ICEoMCwgX3NoaW1zLmlzTnVtKShzdGF0ZS5sYXN0WCk7XG4gIHZhciBub2RlID0gZmluZERPTU5vZGUoZHJhZ2dhYmxlKTtcblxuICBpZiAoaXNTdGFydCkge1xuICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IG1vdmUsIHVzZSB0aGUgeCBhbmQgeSBhcyBsYXN0IGNvb3Jkcy5cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbm9kZSxcbiAgICAgIGRlbHRhWDogMCxcbiAgICAgIGRlbHRhWTogMCxcbiAgICAgIGxhc3RYOiB4LFxuICAgICAgbGFzdFk6IHksXG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlIGNhbGN1bGF0ZSBwcm9wZXIgdmFsdWVzLlxuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgZGVsdGFYOiB4IC0gc3RhdGUubGFzdFgsXG4gICAgICBkZWx0YVk6IHkgLSBzdGF0ZS5sYXN0WSxcbiAgICAgIGxhc3RYOiBzdGF0ZS5sYXN0WCxcbiAgICAgIGxhc3RZOiBzdGF0ZS5sYXN0WSxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgfVxufSAvLyBDcmVhdGUgYW4gZGF0YSBleHBvc2VkIGJ5IDxEcmFnZ2FibGU+J3MgZXZlbnRzXG5cblxuZnVuY3Rpb24gY3JlYXRlRHJhZ2dhYmxlRGF0YShkcmFnZ2FibGVcbi8qOiBEcmFnZ2FibGUqL1xuLCBjb3JlRGF0YVxuLyo6IERyYWdnYWJsZURhdGEqL1xuKVxuLyo6IERyYWdnYWJsZURhdGEqL1xue1xuICB2YXIgc2NhbGUgPSBkcmFnZ2FibGUucHJvcHMuc2NhbGU7XG4gIHJldHVybiB7XG4gICAgbm9kZTogY29yZURhdGEubm9kZSxcbiAgICB4OiBkcmFnZ2FibGUuc3RhdGUueCArIGNvcmVEYXRhLmRlbHRhWCAvIHNjYWxlLFxuICAgIHk6IGRyYWdnYWJsZS5zdGF0ZS55ICsgY29yZURhdGEuZGVsdGFZIC8gc2NhbGUsXG4gICAgZGVsdGFYOiBjb3JlRGF0YS5kZWx0YVggLyBzY2FsZSxcbiAgICBkZWx0YVk6IGNvcmVEYXRhLmRlbHRhWSAvIHNjYWxlLFxuICAgIGxhc3RYOiBkcmFnZ2FibGUuc3RhdGUueCxcbiAgICBsYXN0WTogZHJhZ2dhYmxlLnN0YXRlLnlcbiAgfTtcbn0gLy8gQSBsb3QgZmFzdGVyIHRoYW4gc3RyaW5naWZ5L3BhcnNlXG5cblxuZnVuY3Rpb24gY2xvbmVCb3VuZHMoYm91bmRzXG4vKjogQm91bmRzKi9cbilcbi8qOiBCb3VuZHMqL1xue1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGJvdW5kcy5sZWZ0LFxuICAgIHRvcDogYm91bmRzLnRvcCxcbiAgICByaWdodDogYm91bmRzLnJpZ2h0LFxuICAgIGJvdHRvbTogYm91bmRzLmJvdHRvbVxuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShkcmFnZ2FibGVcbi8qOiBEcmFnZ2FibGUgfCBEcmFnZ2FibGVDb3JlKi9cbilcbi8qOiBIVE1MRWxlbWVudCovXG57XG4gIHZhciBub2RlID0gZHJhZ2dhYmxlLmZpbmRET01Ob2RlKCk7XG5cbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc8RHJhZ2dhYmxlQ29yZT46IFVubW91bnRlZCBkdXJpbmcgZXZlbnQhJyk7XG4gIH0gLy8gJEZsb3dJZ25vcmUgd2UgY2FuJ3QgYXNzZXJ0IG9uIEhUTUxFbGVtZW50IGR1ZSB0byB0ZXN0cy4uLiBGSVhNRVxuXG5cbiAgcmV0dXJuIG5vZGU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZpbmRJbkFycmF5ID0gZmluZEluQXJyYXk7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc051bSA9IGlzTnVtO1xuZXhwb3J0cy5pbnQgPSBpbnQ7XG5leHBvcnRzLmRvbnRTZXRNZSA9IGRvbnRTZXRNZTtcblxuLy8gQGNyZWRpdHMgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcm9nb3pobmlrb2ZmL2E0M2NmZWQyN2M0MWU0ZTY4Y2RjXG5mdW5jdGlvbiBmaW5kSW5BcnJheShhcnJheVxuLyo6IEFycmF5PGFueT4gfCBUb3VjaExpc3QqL1xuLCBjYWxsYmFja1xuLyo6IEZ1bmN0aW9uKi9cbilcbi8qOiBhbnkqL1xue1xuICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIFthcnJheVtpXSwgaSwgYXJyYXldKSkgcmV0dXJuIGFycmF5W2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY1xuLyo6IGFueSovXG4pXG4vKjogYm9vbGVhbiAlY2hlY2tzKi9cbntcbiAgLy8gJEZsb3dJZ25vcmVbbWV0aG9kLXVuYmluZGluZ11cbiAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmdW5jKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuZnVuY3Rpb24gaXNOdW0obnVtXG4vKjogYW55Ki9cbilcbi8qOiBib29sZWFuICVjaGVja3MqL1xue1xuICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG51bSk7XG59XG5cbmZ1bmN0aW9uIGludChhXG4vKjogc3RyaW5nKi9cbilcbi8qOiBudW1iZXIqL1xue1xuICByZXR1cm4gcGFyc2VJbnQoYSwgMTApO1xufVxuXG5mdW5jdGlvbiBkb250U2V0TWUocHJvcHNcbi8qOiBPYmplY3QqL1xuLCBwcm9wTmFtZVxuLyo6IHN0cmluZyovXG4sIGNvbXBvbmVudE5hbWVcbi8qOiBzdHJpbmcqL1xuKVxuLyo6ID9FcnJvciovXG57XG4gIGlmIChwcm9wc1twcm9wTmFtZV0pIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wIFwiLmNvbmNhdChwcm9wTmFtZSwgXCIgcGFzc2VkIHRvIFwiKS5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIgLSBkbyBub3Qgc2V0IHRoaXMsIHNldCBpdCBvbiB0aGUgY2hpbGQuXCIpKTtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3JlYWN0RHJhZ2dhYmxlID0gcmVxdWlyZShcInJlYWN0LWRyYWdnYWJsZVwiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoXCIuL3Byb3BUeXBlc1wiKTtcblxudmFyIF9leGNsdWRlZCA9IFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwiZHJhZ2dhYmxlT3B0c1wiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiaGFuZGxlXCIsIFwiaGFuZGxlU2l6ZVwiLCBcImxvY2tBc3BlY3RSYXRpb1wiLCBcImF4aXNcIiwgXCJtaW5Db25zdHJhaW50c1wiLCBcIm1heENvbnN0cmFpbnRzXCIsIFwib25SZXNpemVcIiwgXCJvblJlc2l6ZVN0b3BcIiwgXCJvblJlc2l6ZVN0YXJ0XCIsIFwicmVzaXplSGFuZGxlc1wiLCBcInRyYW5zZm9ybVNjYWxlXCJdO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbi8vIFRoZSBiYXNlIDxSZXNpemFibGU+IGNvbXBvbmVudC5cbi8vIFRoaXMgY29tcG9uZW50IGRvZXMgbm90IGhhdmUgc3RhdGUgYW5kIHJlbGllcyBvbiB0aGUgcGFyZW50IHRvIHNldCBpdHMgcHJvcHMgYmFzZWQgb24gY2FsbGJhY2sgZGF0YS5cbnZhciBSZXNpemFibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVzaXphYmxlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSZXNpemFibGUoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuaGFuZGxlUmVmcyA9IHt9O1xuICAgIF90aGlzLmxhc3RIYW5kbGVSZWN0ID0gbnVsbDtcbiAgICBfdGhpcy5zbGFjayA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlc2l6YWJsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5yZXNldERhdGEoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXREYXRhID0gZnVuY3Rpb24gcmVzZXREYXRhKCkge1xuICAgIHRoaXMubGFzdEhhbmRsZVJlY3QgPSB0aGlzLnNsYWNrID0gbnVsbDtcbiAgfSAvLyBDbGFtcCB3aWR0aCBhbmQgaGVpZ2h0IHdpdGhpbiBwcm92aWRlZCBjb25zdHJhaW50c1xuICA7XG5cbiAgX3Byb3RvLnJ1bkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gcnVuQ29uc3RyYWludHMod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIG1pbkNvbnN0cmFpbnRzID0gX3RoaXMkcHJvcHMubWluQ29uc3RyYWludHMsXG4gICAgICAgIG1heENvbnN0cmFpbnRzID0gX3RoaXMkcHJvcHMubWF4Q29uc3RyYWludHMsXG4gICAgICAgIGxvY2tBc3BlY3RSYXRpbyA9IF90aGlzJHByb3BzLmxvY2tBc3BlY3RSYXRpbzsgLy8gc2hvcnQgY2lyY3VpdFxuXG4gICAgaWYgKCFtaW5Db25zdHJhaW50cyAmJiAhbWF4Q29uc3RyYWludHMgJiYgIWxvY2tBc3BlY3RSYXRpbykgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTsgLy8gSWYgY29uc3RyYWluaW5nIHRvIG1pbiBhbmQgbWF4LCB3ZSBuZWVkIHRvIGFsc28gZml0IHdpZHRoIGFuZCBoZWlnaHQgdG8gYXNwZWN0IHJhdGlvLlxuXG4gICAgaWYgKGxvY2tBc3BlY3RSYXRpbykge1xuICAgICAgdmFyIHJhdGlvID0gdGhpcy5wcm9wcy53aWR0aCAvIHRoaXMucHJvcHMuaGVpZ2h0O1xuICAgICAgdmFyIGRlbHRhVyA9IHdpZHRoIC0gdGhpcy5wcm9wcy53aWR0aDtcbiAgICAgIHZhciBkZWx0YUggPSBoZWlnaHQgLSB0aGlzLnByb3BzLmhlaWdodDsgLy8gRmluZCB3aGljaCBjb29yZGluYXRlIHdhcyBncmVhdGVyIGFuZCBzaG91bGQgcHVzaCB0aGUgb3RoZXIgdG93YXJkIGl0LlxuICAgICAgLy8gRS5nLjpcbiAgICAgIC8vIHJhdGlvID0gMSwgZGVsdGFXID0gMTAsIGRlbHRhSCA9IDUsIGRlbHRhSCBzaG91bGQgYmVjb21lIDEwLlxuICAgICAgLy8gcmF0aW8gPSAyLCBkZWx0YVcgPSAxMCwgZGVsdGFIID0gNiwgZGVsdGFXIHNob3VsZCBiZWNvbWUgMTIuXG5cbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YVcpID4gTWF0aC5hYnMoZGVsdGFIICogcmF0aW8pKSB7XG4gICAgICAgIGhlaWdodCA9IHdpZHRoIC8gcmF0aW87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCA9IGhlaWdodCAqIHJhdGlvO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvbGRXID0gd2lkdGgsXG4gICAgICAgIG9sZEggPSBoZWlnaHQ7IC8vIEFkZCBzbGFjayB0byB0aGUgdmFsdWVzIHVzZWQgdG8gY2FsY3VsYXRlIGJvdW5kIHBvc2l0aW9uLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgaWZcbiAgICAvLyB3ZSBzdGFydCByZW1vdmluZyBzbGFjaywgdGhlIGVsZW1lbnQgd29uJ3QgcmVhY3QgdG8gaXQgcmlnaHQgYXdheSB1bnRpbCBpdCdzIGJlZW5cbiAgICAvLyBjb21wbGV0ZWx5IHJlbW92ZWQuXG5cbiAgICB2YXIgX3JlZiA9IHRoaXMuc2xhY2sgfHwgWzAsIDBdLFxuICAgICAgICBzbGFja1cgPSBfcmVmWzBdLFxuICAgICAgICBzbGFja0ggPSBfcmVmWzFdO1xuXG4gICAgd2lkdGggKz0gc2xhY2tXO1xuICAgIGhlaWdodCArPSBzbGFja0g7XG5cbiAgICBpZiAobWluQ29uc3RyYWludHMpIHtcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgobWluQ29uc3RyYWludHNbMF0sIHdpZHRoKTtcbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KG1pbkNvbnN0cmFpbnRzWzFdLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIGlmIChtYXhDb25zdHJhaW50cykge1xuICAgICAgd2lkdGggPSBNYXRoLm1pbihtYXhDb25zdHJhaW50c1swXSwgd2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5taW4obWF4Q29uc3RyYWludHNbMV0sIGhlaWdodCk7XG4gICAgfSAvLyBJZiB0aGUgd2lkdGggb3IgaGVpZ2h0IGNoYW5nZWQsIHdlIG11c3QgaGF2ZSBpbnRyb2R1Y2VkIHNvbWUgc2xhY2suIFJlY29yZCBpdCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uLlxuXG5cbiAgICB0aGlzLnNsYWNrID0gW3NsYWNrVyArIChvbGRXIC0gd2lkdGgpLCBzbGFja0ggKyAob2xkSCAtIGhlaWdodCldO1xuICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIGRyYWcgZXZlbnRzIHRvIHByb3ZpZGUgbW9yZSB1c2VmdWwgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBoYW5kbGVyTmFtZSBIYW5kbGVyIG5hbWUgdG8gd3JhcC5cbiAgICogQHJldHVybiB7RnVuY3Rpb259ICAgICAgICAgICBIYW5kbGVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gcmVzaXplSGFuZGxlcihoYW5kbGVyTmFtZSwgYXhpcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlLCBfcmVmMikge1xuICAgICAgdmFyIG5vZGUgPSBfcmVmMi5ub2RlLFxuICAgICAgICAgIGRlbHRhWCA9IF9yZWYyLmRlbHRhWCxcbiAgICAgICAgICBkZWx0YVkgPSBfcmVmMi5kZWx0YVk7XG4gICAgICAvLyBSZXNldCBkYXRhIGluIGNhc2UgaXQgd2FzIGxlZnQgb3ZlciBzb21laG93IChzaG91bGQgbm90IGJlIHBvc3NpYmxlKVxuICAgICAgaWYgKGhhbmRsZXJOYW1lID09PSAnb25SZXNpemVTdGFydCcpIF90aGlzMi5yZXNldERhdGEoKTsgLy8gQXhpcyByZXN0cmljdGlvbnNcblxuICAgICAgdmFyIGNhbkRyYWdYID0gKF90aGlzMi5wcm9wcy5heGlzID09PSAnYm90aCcgfHwgX3RoaXMyLnByb3BzLmF4aXMgPT09ICd4JykgJiYgYXhpcyAhPT0gJ24nICYmIGF4aXMgIT09ICdzJztcbiAgICAgIHZhciBjYW5EcmFnWSA9IChfdGhpczIucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IF90aGlzMi5wcm9wcy5heGlzID09PSAneScpICYmIGF4aXMgIT09ICdlJyAmJiBheGlzICE9PSAndyc7IC8vIE5vIGRyYWdnaW5nIHBvc3NpYmxlLlxuXG4gICAgICBpZiAoIWNhbkRyYWdYICYmICFjYW5EcmFnWSkgcmV0dXJuOyAvLyBEZWNvbXBvc2UgYXhpcyBmb3IgbGF0ZXIgdXNlXG5cbiAgICAgIHZhciBheGlzViA9IGF4aXNbMF07XG4gICAgICB2YXIgYXhpc0ggPSBheGlzW2F4aXMubGVuZ3RoIC0gMV07IC8vIGludGVudGlvbmFsbHkgbm90IGF4aXNbMV0sIHNvIHRoYXQgdGhpcyBjYXRjaGVzIGF4aXMgPT09ICd3JyBmb3IgZXhhbXBsZVxuICAgICAgLy8gVHJhY2sgdGhlIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZCB0byBhY2NvdW50IGZvciBjaGFuZ2VzIGluIHBvc2l0aW9uLlxuICAgICAgLy8gSWYgYSBoYW5kbGUncyBwb3NpdGlvbiBpcyBjaGFuZ2VkIGJldHdlZW4gY2FsbGJhY2tzLCB3ZSBuZWVkIHRvIGZhY3RvciB0aGlzIGluIHRvIHRoZSBuZXh0IGNhbGxiYWNrLlxuICAgICAgLy8gRmFpbHVyZSB0byBkbyBzbyB3aWxsIGNhdXNlIHRoZSBlbGVtZW50IHRvIFwic2tpcFwiIHdoZW4gcmVzaXplZCB1cHdhcmRzIG9yIGxlZnR3YXJkcy5cblxuICAgICAgdmFyIGhhbmRsZVJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAoX3RoaXMyLmxhc3RIYW5kbGVSZWN0ICE9IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGhhbmRsZSBoYXMgcmVwb3NpdGlvbmVkIG9uIGVpdGhlciBheGlzIHNpbmNlIGxhc3QgcmVuZGVyLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGluY3JlYXNlIG91ciBjYWxsYmFjayB2YWx1ZXMgYnkgdGhpcyBtdWNoLlxuICAgICAgICAvLyBPbmx5IGNoZWNraW5nICduJywgJ3cnIHNpbmNlIHJlc2l6aW5nIGJ5ICdzJywgJ3cnIHdvbid0IGFmZmVjdCB0aGUgb3ZlcmFsbCBwb3NpdGlvbiBvbiBwYWdlLFxuICAgICAgICBpZiAoYXhpc0ggPT09ICd3Jykge1xuICAgICAgICAgIHZhciBkZWx0YUxlZnRTaW5jZUxhc3QgPSBoYW5kbGVSZWN0LmxlZnQgLSBfdGhpczIubGFzdEhhbmRsZVJlY3QubGVmdDtcbiAgICAgICAgICBkZWx0YVggKz0gZGVsdGFMZWZ0U2luY2VMYXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF4aXNWID09PSAnbicpIHtcbiAgICAgICAgICB2YXIgZGVsdGFUb3BTaW5jZUxhc3QgPSBoYW5kbGVSZWN0LnRvcCAtIF90aGlzMi5sYXN0SGFuZGxlUmVjdC50b3A7XG4gICAgICAgICAgZGVsdGFZICs9IGRlbHRhVG9wU2luY2VMYXN0O1xuICAgICAgICB9XG4gICAgICB9IC8vIFN0b3JhZ2Ugb2YgbGFzdCByZWN0IHNvIHdlIGtub3cgaG93IG11Y2ggaXQgaGFzIHJlYWxseSBtb3ZlZC5cblxuXG4gICAgICBfdGhpczIubGFzdEhhbmRsZVJlY3QgPSBoYW5kbGVSZWN0OyAvLyBSZXZlcnNlIGRlbHRhIGlmIHVzaW5nIHRvcCBvciBsZWZ0IGRyYWcgaGFuZGxlcy5cblxuICAgICAgaWYgKGF4aXNIID09PSAndycpIGRlbHRhWCA9IC1kZWx0YVg7XG4gICAgICBpZiAoYXhpc1YgPT09ICduJykgZGVsdGFZID0gLWRlbHRhWTsgLy8gVXBkYXRlIHcvaCBieSB0aGUgZGVsdGFzLiBBbHNvIGZhY3RvciBpbiB0cmFuc2Zvcm1TY2FsZS5cblxuICAgICAgdmFyIHdpZHRoID0gX3RoaXMyLnByb3BzLndpZHRoICsgKGNhbkRyYWdYID8gZGVsdGFYIC8gX3RoaXMyLnByb3BzLnRyYW5zZm9ybVNjYWxlIDogMCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gX3RoaXMyLnByb3BzLmhlaWdodCArIChjYW5EcmFnWSA/IGRlbHRhWSAvIF90aGlzMi5wcm9wcy50cmFuc2Zvcm1TY2FsZSA6IDApOyAvLyBSdW4gdXNlci1wcm92aWRlZCBjb25zdHJhaW50cy5cblxuICAgICAgdmFyIF90aGlzMiRydW5Db25zdHJhaW50cyA9IF90aGlzMi5ydW5Db25zdHJhaW50cyh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgd2lkdGggPSBfdGhpczIkcnVuQ29uc3RyYWludHNbMF07XG4gICAgICBoZWlnaHQgPSBfdGhpczIkcnVuQ29uc3RyYWludHNbMV07XG4gICAgICB2YXIgZGltZW5zaW9uc0NoYW5nZWQgPSB3aWR0aCAhPT0gX3RoaXMyLnByb3BzLndpZHRoIHx8IGhlaWdodCAhPT0gX3RoaXMyLnByb3BzLmhlaWdodDsgLy8gQ2FsbCB1c2VyLXN1cHBsaWVkIGNhbGxiYWNrIGlmIHByZXNlbnQuXG5cbiAgICAgIHZhciBjYiA9IHR5cGVvZiBfdGhpczIucHJvcHNbaGFuZGxlck5hbWVdID09PSAnZnVuY3Rpb24nID8gX3RoaXMyLnByb3BzW2hhbmRsZXJOYW1lXSA6IG51bGw7IC8vIERvbid0IGNhbGwgJ29uUmVzaXplJyBpZiBkaW1lbnNpb25zIGhhdmVuJ3QgY2hhbmdlZC5cblxuICAgICAgdmFyIHNob3VsZFNraXBDYiA9IGhhbmRsZXJOYW1lID09PSAnb25SZXNpemUnICYmICFkaW1lbnNpb25zQ2hhbmdlZDtcblxuICAgICAgaWYgKGNiICYmICFzaG91bGRTa2lwQ2IpIHtcbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgPyB2b2lkIDAgOiBlLnBlcnNpc3QoKTtcbiAgICAgICAgY2IoZSwge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhbmRsZTogYXhpc1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gUmVzZXQgaW50ZXJuYWwgZGF0YVxuXG5cbiAgICAgIGlmIChoYW5kbGVyTmFtZSA9PT0gJ29uUmVzaXplU3RvcCcpIF90aGlzMi5yZXNldERhdGEoKTtcbiAgICB9O1xuICB9IC8vIFJlbmRlciBhIHJlc2l6ZSBoYW5kbGUgZ2l2ZW4gYW4gYXhpcyAmIERPTSByZWYuIFJlZiAqbXVzdCogYmUgYXR0YWNoZWQgZm9yXG4gIC8vIHRoZSB1bmRlcmx5aW5nIGRyYWdnYWJsZSBsaWJyYXJ5IHRvIHdvcmsgcHJvcGVybHkuXG4gIDtcblxuICBfcHJvdG8ucmVuZGVyUmVzaXplSGFuZGxlID0gZnVuY3Rpb24gcmVuZGVyUmVzaXplSGFuZGxlKGhhbmRsZUF4aXMsIHJlZikge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLnByb3BzLmhhbmRsZTsgLy8gTm8gaGFuZGxlIHByb3ZpZGVkLCBtYWtlIHRoZSBkZWZhdWx0XG5cbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1yZXNpemFibGUtaGFuZGxlIHJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtXCIgKyBoYW5kbGVBeGlzLFxuICAgICAgICByZWY6IHJlZlxuICAgICAgfSk7XG4gICAgfSAvLyBIYW5kbGUgaXMgYSBmdW5jdGlvbiwgc3VjaCBhczpcbiAgICAvLyBgaGFuZGxlPXsoaGFuZGxlQXhpcykgPT4gPHNwYW4gY2xhc3NOYW1lPXsuLi59IC8+fWBcblxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBoYW5kbGUoaGFuZGxlQXhpcywgcmVmKTtcbiAgICB9IC8vIEhhbmRsZSBpcyBhIFJlYWN0IGNvbXBvbmVudCAoY29tcG9zaXRlIG9yIERPTSkuXG5cblxuICAgIHZhciBpc0RPTUVsZW1lbnQgPSB0eXBlb2YgaGFuZGxlLnR5cGUgPT09ICdzdHJpbmcnO1xuXG4gICAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gICAgICByZWY6IHJlZlxuICAgIH0sIGlzRE9NRWxlbWVudCA/IHt9IDoge1xuICAgICAgaGFuZGxlQXhpczogaGFuZGxlQXhpc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoaGFuZGxlLCBwcm9wcyk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIFBhc3MgYWxvbmcgb25seSBwcm9wcyBub3QgbWVhbnQgZm9yIHRoZSBgPFJlc2l6YWJsZT5gLmBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczIuY2hpbGRyZW4sXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5jbGFzc05hbWUsXG4gICAgICAgIGRyYWdnYWJsZU9wdHMgPSBfdGhpcyRwcm9wczIuZHJhZ2dhYmxlT3B0cyxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzMi5oZWlnaHQsXG4gICAgICAgIGhhbmRsZSA9IF90aGlzJHByb3BzMi5oYW5kbGUsXG4gICAgICAgIGhhbmRsZVNpemUgPSBfdGhpcyRwcm9wczIuaGFuZGxlU2l6ZSxcbiAgICAgICAgbG9ja0FzcGVjdFJhdGlvID0gX3RoaXMkcHJvcHMyLmxvY2tBc3BlY3RSYXRpbyxcbiAgICAgICAgYXhpcyA9IF90aGlzJHByb3BzMi5heGlzLFxuICAgICAgICBtaW5Db25zdHJhaW50cyA9IF90aGlzJHByb3BzMi5taW5Db25zdHJhaW50cyxcbiAgICAgICAgbWF4Q29uc3RyYWludHMgPSBfdGhpcyRwcm9wczIubWF4Q29uc3RyYWludHMsXG4gICAgICAgIG9uUmVzaXplID0gX3RoaXMkcHJvcHMyLm9uUmVzaXplLFxuICAgICAgICBvblJlc2l6ZVN0b3AgPSBfdGhpcyRwcm9wczIub25SZXNpemVTdG9wLFxuICAgICAgICBvblJlc2l6ZVN0YXJ0ID0gX3RoaXMkcHJvcHMyLm9uUmVzaXplU3RhcnQsXG4gICAgICAgIHJlc2l6ZUhhbmRsZXMgPSBfdGhpcyRwcm9wczIucmVzaXplSGFuZGxlcyxcbiAgICAgICAgdHJhbnNmb3JtU2NhbGUgPSBfdGhpcyRwcm9wczIudHJhbnNmb3JtU2NhbGUsXG4gICAgICAgIHAgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczIsIF9leGNsdWRlZCk7IC8vIFdoYXQgd2UncmUgZG9pbmcgaGVyZSBpcyBnZXR0aW5nIHRoZSBjaGlsZCBvZiB0aGlzIGVsZW1lbnQsIGFuZCBjbG9uaW5nIGl0IHdpdGggdGhpcyBlbGVtZW50J3MgcHJvcHMuXG4gICAgLy8gV2UgYXJlIHRoZW4gZGVmaW5pbmcgaXRzIGNoaWxkcmVuIGFzOlxuICAgIC8vIDEuIEl0cyBvcmlnaW5hbCBjaGlsZHJlbiAocmVzaXphYmxlJ3MgY2hpbGQncyBjaGlsZHJlbiksIGFuZFxuICAgIC8vIDIuIE9uZSBvciBtb3JlIGRyYWdnYWJsZSBoYW5kbGVzLlxuXG5cbiAgICByZXR1cm4gKDAsIF91dGlscy5jbG9uZUVsZW1lbnQpKGNoaWxkcmVuLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHApLCB7fSwge1xuICAgICAgY2xhc3NOYW1lOiAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgXCIgXCIgOiAnJykgKyBcInJlYWN0LXJlc2l6YWJsZVwiLFxuICAgICAgY2hpbGRyZW46IFtdLmNvbmNhdChjaGlsZHJlbi5wcm9wcy5jaGlsZHJlbiwgcmVzaXplSGFuZGxlcy5tYXAoZnVuY3Rpb24gKGhhbmRsZUF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzMyRoYW5kbGVSZWZzJGhhbjtcblxuICAgICAgICAvLyBDcmVhdGUgYSByZWYgdG8gdGhlIGhhbmRsZSBzbyB0aGF0IGA8RHJhZ2dhYmxlQ29yZT5gIGRvZXNuJ3QgaGF2ZSB0byB1c2UgUmVhY3RET00uZmluZERPTU5vZGUoKS5cbiAgICAgICAgdmFyIHJlZiA9IChfdGhpczMkaGFuZGxlUmVmcyRoYW4gPSBfdGhpczMuaGFuZGxlUmVmc1toYW5kbGVBeGlzXSkgIT0gbnVsbCA/IF90aGlzMyRoYW5kbGVSZWZzJGhhbiA6IF90aGlzMy5oYW5kbGVSZWZzW2hhbmRsZUF4aXNdID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0RHJhZ2dhYmxlLkRyYWdnYWJsZUNvcmUsIF9leHRlbmRzKHt9LCBkcmFnZ2FibGVPcHRzLCB7XG4gICAgICAgICAgbm9kZVJlZjogcmVmLFxuICAgICAgICAgIGtleTogXCJyZXNpemFibGVIYW5kbGUtXCIgKyBoYW5kbGVBeGlzLFxuICAgICAgICAgIG9uU3RvcDogX3RoaXMzLnJlc2l6ZUhhbmRsZXIoJ29uUmVzaXplU3RvcCcsIGhhbmRsZUF4aXMpLFxuICAgICAgICAgIG9uU3RhcnQ6IF90aGlzMy5yZXNpemVIYW5kbGVyKCdvblJlc2l6ZVN0YXJ0JywgaGFuZGxlQXhpcyksXG4gICAgICAgICAgb25EcmFnOiBfdGhpczMucmVzaXplSGFuZGxlcignb25SZXNpemUnLCBoYW5kbGVBeGlzKVxuICAgICAgICB9KSwgX3RoaXMzLnJlbmRlclJlc2l6ZUhhbmRsZShoYW5kbGVBeGlzLCByZWYpKTtcbiAgICAgIH0pKVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gUmVzaXphYmxlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZXNpemFibGU7XG5SZXNpemFibGUucHJvcFR5cGVzID0gX3Byb3BUeXBlcy5yZXNpemFibGVQcm9wcztcblJlc2l6YWJsZS5kZWZhdWx0UHJvcHMgPSB7XG4gIGF4aXM6ICdib3RoJyxcbiAgaGFuZGxlU2l6ZTogWzIwLCAyMF0sXG4gIGxvY2tBc3BlY3RSYXRpbzogZmFsc2UsXG4gIG1pbkNvbnN0cmFpbnRzOiBbMjAsIDIwXSxcbiAgbWF4Q29uc3RyYWludHM6IFtJbmZpbml0eSwgSW5maW5pdHldLFxuICByZXNpemVIYW5kbGVzOiBbJ3NlJ10sXG4gIHRyYW5zZm9ybVNjYWxlOiAxXG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX1Jlc2l6YWJsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUmVzaXphYmxlXCIpKTtcblxudmFyIF9wcm9wVHlwZXMyID0gcmVxdWlyZShcIi4vcHJvcFR5cGVzXCIpO1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wiaGFuZGxlXCIsIFwiaGFuZGxlU2l6ZVwiLCBcIm9uUmVzaXplXCIsIFwib25SZXNpemVTdGFydFwiLCBcIm9uUmVzaXplU3RvcFwiLCBcImRyYWdnYWJsZU9wdHNcIiwgXCJtaW5Db25zdHJhaW50c1wiLCBcIm1heENvbnN0cmFpbnRzXCIsIFwibG9ja0FzcGVjdFJhdGlvXCIsIFwiYXhpc1wiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwicmVzaXplSGFuZGxlc1wiLCBcInN0eWxlXCIsIFwidHJhbnNmb3JtU2NhbGVcIl07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFJlc2l6YWJsZUJveCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShSZXNpemFibGVCb3gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlc2l6YWJsZUJveCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHdpZHRoOiBfdGhpcy5wcm9wcy53aWR0aCxcbiAgICAgIGhlaWdodDogX3RoaXMucHJvcHMuaGVpZ2h0LFxuICAgICAgcHJvcHNXaWR0aDogX3RoaXMucHJvcHMud2lkdGgsXG4gICAgICBwcm9wc0hlaWdodDogX3RoaXMucHJvcHMuaGVpZ2h0XG4gICAgfTtcblxuICAgIF90aGlzLm9uUmVzaXplID0gZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgIHZhciBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25SZXNpemUpIHtcbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgPyB2b2lkIDAgOiBlLnBlcnNpc3QoKTtcblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZShzaXplLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm9uUmVzaXplICYmIF90aGlzLnByb3BzLm9uUmVzaXplKGUsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHNpemUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBSZXNpemFibGVCb3guZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIC8vIElmIHBhcmVudCBjaGFuZ2VzIGhlaWdodC93aWR0aCwgc2V0IHRoYXQgaW4gb3VyIHN0YXRlLlxuICAgIGlmIChzdGF0ZS5wcm9wc1dpZHRoICE9PSBwcm9wcy53aWR0aCB8fCBzdGF0ZS5wcm9wc0hlaWdodCAhPT0gcHJvcHMuaGVpZ2h0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcHJvcHMud2lkdGgsXG4gICAgICAgIGhlaWdodDogcHJvcHMuaGVpZ2h0LFxuICAgICAgICBwcm9wc1dpZHRoOiBwcm9wcy53aWR0aCxcbiAgICAgICAgcHJvcHNIZWlnaHQ6IHByb3BzLmhlaWdodFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gUmVzaXphYmxlQm94LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIC8vIEJhc2ljIHdyYXBwZXIgYXJvdW5kIGEgUmVzaXphYmxlIGluc3RhbmNlLlxuICAgIC8vIElmIHlvdSB1c2UgUmVzaXphYmxlIGRpcmVjdGx5LCB5b3UgYXJlIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZyB0aGUgY2hpbGQgY29tcG9uZW50XG4gICAgLy8gd2l0aCBhIG5ldyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGhhbmRsZSA9IF90aGlzJHByb3BzLmhhbmRsZSxcbiAgICAgICAgaGFuZGxlU2l6ZSA9IF90aGlzJHByb3BzLmhhbmRsZVNpemUsXG4gICAgICAgIG9uUmVzaXplID0gX3RoaXMkcHJvcHMub25SZXNpemUsXG4gICAgICAgIG9uUmVzaXplU3RhcnQgPSBfdGhpcyRwcm9wcy5vblJlc2l6ZVN0YXJ0LFxuICAgICAgICBvblJlc2l6ZVN0b3AgPSBfdGhpcyRwcm9wcy5vblJlc2l6ZVN0b3AsXG4gICAgICAgIGRyYWdnYWJsZU9wdHMgPSBfdGhpcyRwcm9wcy5kcmFnZ2FibGVPcHRzLFxuICAgICAgICBtaW5Db25zdHJhaW50cyA9IF90aGlzJHByb3BzLm1pbkNvbnN0cmFpbnRzLFxuICAgICAgICBtYXhDb25zdHJhaW50cyA9IF90aGlzJHByb3BzLm1heENvbnN0cmFpbnRzLFxuICAgICAgICBsb2NrQXNwZWN0UmF0aW8gPSBfdGhpcyRwcm9wcy5sb2NrQXNwZWN0UmF0aW8sXG4gICAgICAgIGF4aXMgPSBfdGhpcyRwcm9wcy5heGlzLFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wcy5oZWlnaHQsXG4gICAgICAgIHJlc2l6ZUhhbmRsZXMgPSBfdGhpcyRwcm9wcy5yZXNpemVIYW5kbGVzLFxuICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzLnN0eWxlLFxuICAgICAgICB0cmFuc2Zvcm1TY2FsZSA9IF90aGlzJHByb3BzLnRyYW5zZm9ybVNjYWxlLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9SZXNpemFibGUuZGVmYXVsdCwge1xuICAgICAgYXhpczogYXhpcyxcbiAgICAgIGRyYWdnYWJsZU9wdHM6IGRyYWdnYWJsZU9wdHMsXG4gICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgIGhhbmRsZVNpemU6IGhhbmRsZVNpemUsXG4gICAgICBoZWlnaHQ6IHRoaXMuc3RhdGUuaGVpZ2h0LFxuICAgICAgbG9ja0FzcGVjdFJhdGlvOiBsb2NrQXNwZWN0UmF0aW8sXG4gICAgICBtYXhDb25zdHJhaW50czogbWF4Q29uc3RyYWludHMsXG4gICAgICBtaW5Db25zdHJhaW50czogbWluQ29uc3RyYWludHMsXG4gICAgICBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LFxuICAgICAgb25SZXNpemU6IHRoaXMub25SZXNpemUsXG4gICAgICBvblJlc2l6ZVN0b3A6IG9uUmVzaXplU3RvcCxcbiAgICAgIHJlc2l6ZUhhbmRsZXM6IHJlc2l6ZUhhbmRsZXMsXG4gICAgICB0cmFuc2Zvcm1TY2FsZTogdHJhbnNmb3JtU2NhbGUsXG4gICAgICB3aWR0aDogdGhpcy5zdGF0ZS53aWR0aFxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3R5bGUpLCB7fSwge1xuICAgICAgICB3aWR0aDogdGhpcy5zdGF0ZS53aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogdGhpcy5zdGF0ZS5oZWlnaHQgKyAncHgnXG4gICAgICB9KVxuICAgIH0pKSk7XG4gIH07XG5cbiAgcmV0dXJuIFJlc2l6YWJsZUJveDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVzaXphYmxlQm94O1xuUmVzaXphYmxlQm94LnByb3BUeXBlcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3Byb3BUeXBlczIucmVzaXphYmxlUHJvcHMpLCB7fSwge1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0LmVsZW1lbnRcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5yZXNpemFibGVQcm9wcyA9IHZvaWQgMDtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIF9yZWFjdERyYWdnYWJsZSA9IHJlcXVpcmUoXCJyZWFjdC1kcmFnZ2FibGVcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciByZXNpemFibGVQcm9wcyA9IHtcbiAgLypcbiAgKiBSZXN0cmljdHMgcmVzaXppbmcgdG8gYSBwYXJ0aWN1bGFyIGF4aXMgKGRlZmF1bHQ6ICdib3RoJylcbiAgKiAnYm90aCcgLSBhbGxvd3MgcmVzaXppbmcgYnkgd2lkdGggb3IgaGVpZ2h0XG4gICogJ3gnIC0gb25seSBhbGxvd3MgdGhlIHdpZHRoIHRvIGJlIGNoYW5nZWRcbiAgKiAneScgLSBvbmx5IGFsbG93cyB0aGUgaGVpZ2h0IHRvIGJlIGNoYW5nZWRcbiAgKiAnbm9uZScgLSBkaXNhYmxlcyByZXNpemluZyBhbHRvZ2V0aGVyXG4gICogKi9cbiAgYXhpczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFsnYm90aCcsICd4JywgJ3knLCAnbm9uZSddKSxcbiAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuXG4gIC8qXG4gICogUmVxdWlyZSB0aGF0IG9uZSBhbmQgb25seSBvbmUgY2hpbGQgYmUgcHJlc2VudC5cbiAgKiAqL1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0LmVsZW1lbnQuaXNSZXF1aXJlZCxcblxuICAvKlxuICAqIFRoZXNlIHdpbGwgYmUgcGFzc2VkIHdob2xlc2FsZSB0byByZWFjdC1kcmFnZ2FibGUncyBEcmFnZ2FibGVDb3JlXG4gICogKi9cbiAgZHJhZ2dhYmxlT3B0czogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICBhbGxvd0FueUNsaWNrOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgICBjYW5jZWw6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gICAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLFxuICAgIGRpc2FibGVkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgICBlbmFibGVVc2VyU2VsZWN0SGFjazogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gICAgb2Zmc2V0UGFyZW50OiBfcHJvcFR5cGVzLmRlZmF1bHQubm9kZSxcbiAgICBncmlkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcbiAgICBoYW5kbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gICAgbm9kZVJlZjogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdCxcbiAgICBvblN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgICBvbkRyYWc6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAgIG9uU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gICAgb25Nb3VzZURvd246IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAgIHNjYWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLFxuXG4gIC8qXG4gICogSW5pdGlhbCBoZWlnaHRcbiAgKiAqL1xuICBoZWlnaHQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcblxuICAvKlxuICAqIEN1c3RvbWl6ZSBjdXJzb3IgcmVzaXplIGhhbmRsZVxuICAqICovXG4gIGhhbmRsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUsIF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jXSksXG5cbiAgLypcbiAgKiBJZiB5b3UgY2hhbmdlIHRoaXMsIGJlIHN1cmUgdG8gdXBkYXRlIHlvdXIgY3NzXG4gICogKi9cbiAgaGFuZGxlU2l6ZTogX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciksXG4gIGxvY2tBc3BlY3RSYXRpbzogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLypcbiAgKiBNYXggWCAmIFkgbWVhc3VyZVxuICAqICovXG4gIG1heENvbnN0cmFpbnRzOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcblxuICAvKlxuICAqIE1pbiBYICYgWSBtZWFzdXJlXG4gICogKi9cbiAgbWluQ29uc3RyYWludHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIpLFxuXG4gIC8qXG4gICogQ2FsbGVkIG9uIHN0b3AgcmVzaXplIGV2ZW50XG4gICogKi9cbiAgb25SZXNpemVTdG9wOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcblxuICAvKlxuICAqIENhbGxlZCBvbiBzdGFydCByZXNpemUgZXZlbnRcbiAgKiAqL1xuICBvblJlc2l6ZVN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcblxuICAvKlxuICAqIENhbGxlZCBvbiByZXNpemUgZXZlbnRcbiAgKiAqL1xuICBvblJlc2l6ZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG5cbiAgLypcbiAgKiBEZWZpbmVzIHdoaWNoIHJlc2l6ZSBoYW5kbGVzIHNob3VsZCBiZSByZW5kZXJlZCAoZGVmYXVsdDogJ3NlJylcbiAgKiAncycgLSBTb3V0aCBoYW5kbGUgKGJvdHRvbS1jZW50ZXIpXG4gICogJ3cnIC0gV2VzdCBoYW5kbGUgKGxlZnQtY2VudGVyKVxuICAqICdlJyAtIEVhc3QgaGFuZGxlIChyaWdodC1jZW50ZXIpXG4gICogJ24nIC0gTm9ydGggaGFuZGxlICh0b3AtY2VudGVyKVxuICAqICdzdycgLSBTb3V0aHdlc3QgaGFuZGxlIChib3R0b20tbGVmdClcbiAgKiAnbncnIC0gTm9ydGh3ZXN0IGhhbmRsZSAodG9wLWxlZnQpXG4gICogJ3NlJyAtIFNvdXRoZWFzdCBoYW5kbGUgKGJvdHRvbS1yaWdodClcbiAgKiAnbmUnIC0gTm9ydGhlYXN0IGhhbmRsZSAodG9wLWNlbnRlcilcbiAgKiAqL1xuICByZXNpemVIYW5kbGVzOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoWydzJywgJ3cnLCAnZScsICduJywgJ3N3JywgJ253JywgJ3NlJywgJ25lJ10pKSxcblxuICAvKlxuICAqIElmIGB0cmFuc2Zvcm06IHNjYWxlKG4pYCBpcyBzZXQgb24gdGhlIHBhcmVudCwgdGhpcyBzaG91bGQgYmUgc2V0IHRvIGBuYC5cbiAgKiAqL1xuICB0cmFuc2Zvcm1TY2FsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcblxuICAvKlxuICAgKiBJbml0aWFsIHdpZHRoXG4gICAqL1xuICB3aWR0aDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkXG59O1xuZXhwb3J0cy5yZXNpemFibGVQcm9wcyA9IHJlc2l6YWJsZVByb3BzOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQ7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gUmVhY3QuYWRkb25zLmNsb25lV2l0aFByb3BzIGxvb2stYWxpa2UgdGhhdCBtZXJnZXMgc3R5bGUgJiBjbGFzc05hbWUuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzLnN0eWxlICYmIGVsZW1lbnQucHJvcHMuc3R5bGUpIHtcbiAgICBwcm9wcy5zdHlsZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZWxlbWVudC5wcm9wcy5zdHlsZSksIHByb3BzLnN0eWxlKTtcbiAgfVxuXG4gIGlmIChwcm9wcy5jbGFzc05hbWUgJiYgZWxlbWVudC5wcm9wcy5jbGFzc05hbWUpIHtcbiAgICBwcm9wcy5jbGFzc05hbWUgPSBlbGVtZW50LnByb3BzLmNsYXNzTmFtZSArIFwiIFwiICsgcHJvcHMuY2xhc3NOYW1lO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoZWxlbWVudCwgcHJvcHMpO1xufSIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIkRvbid0IGluc3RhbnRpYXRlIFJlc2l6YWJsZSBkaXJlY3RseSEgVXNlIHJlcXVpcmUoJ3JlYWN0LXJlc2l6YWJsZScpLlJlc2l6YWJsZVwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLlJlc2l6YWJsZSA9IHJlcXVpcmUoJy4vYnVpbGQvUmVzaXphYmxlJykuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLlJlc2l6YWJsZUJveCA9IHJlcXVpcmUoJy4vYnVpbGQvUmVzaXphYmxlQm94JykuZGVmYXVsdDtcbiIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgZnJvbSAnLi91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JztcbmZ1bmN0aW9uIHVzZU9ic2VydmFibGUob2JzZXJ2YWJsZSQsIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBfYSA9IHVzZVN0YXRlKGluaXRpYWxWYWx1ZSksIHZhbHVlID0gX2FbMF0sIHVwZGF0ZSA9IF9hWzFdO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcyA9IG9ic2VydmFibGUkLnN1YnNjcmliZSh1cGRhdGUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gcy51bnN1YnNjcmliZSgpOyB9O1xuICAgIH0sIFtvYnNlcnZhYmxlJF0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBkZWZhdWx0IHVzZU9ic2VydmFibGU7XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE4IERheWJydXNoXG5AbmFtZTogQGRheWJydXNoL3V0aWxzXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC91dGlsc1xuQHZlcnNpb24gMS42LjBcbiovXG4vKipcbiogQG5hbWVzcGFjZVxuKiBAbmFtZSBDb25zdHNcbiovXG5cbi8qKlxuKiBnZXQgc3RyaW5nIFwicmdiXCJcbiogQG1lbWJlcm9mIENvbG9yXG4qIEBleGFtcGxlXG5pbXBvcnQge1JHQn0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhSR0IpOyAvLyBcInJnYlwiXG4qL1xudmFyIFJHQiA9IFwicmdiXCI7XG4vKipcbiogZ2V0IHN0cmluZyBcInJnYmFcIlxuKiBAbWVtYmVyb2YgQ29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7UkdCQX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhSR0JBKTsgLy8gXCJyZ2JhXCJcbiovXG5cbnZhciBSR0JBID0gXCJyZ2JhXCI7XG4vKipcbiogZ2V0IHN0cmluZyBcImhzbFwiXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtIU0x9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coSFNMKTsgLy8gXCJoc2xcIlxuKi9cblxudmFyIEhTTCA9IFwiaHNsXCI7XG4vKipcbiogZ2V0IHN0cmluZyBcImhzbGFcIlxuKiBAbWVtYmVyb2YgQ29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7SFNMQX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhIU0xBKTsgLy8gXCJoc2xhXCJcbiovXG5cbnZhciBIU0xBID0gXCJoc2xhXCI7XG4vKipcbiogZ2V0cyBhbiBhcnJheSBvZiBjb2xvciBtb2RlbHMuXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtDT0xPUl9NT0RFTFN9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coQ09MT1JfTU9ERUxTKTsgLy8gW1wicmdiXCIsIFwicmdiYVwiLCBcImhzbFwiLCBcImhzbGFcIl07XG4qL1xuXG52YXIgQ09MT1JfTU9ERUxTID0gW1JHQiwgUkdCQSwgSFNMLCBIU0xBXTtcbi8qKlxuKiBnZXQgc3RyaW5nIFwiZnVuY3Rpb25cIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge0ZVTkNUSU9OfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKEZVTkNUSU9OKTsgLy8gXCJmdW5jdGlvblwiXG4qL1xuXG52YXIgRlVOQ1RJT04gPSBcImZ1bmN0aW9uXCI7XG4vKipcbiogZ2V0IHN0cmluZyBcInByb3BlcnR5XCJcbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtQUk9QRVJUWX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhQUk9QRVJUWSk7IC8vIFwicHJvcGVydHlcIlxuKi9cblxudmFyIFBST1BFUlRZID0gXCJwcm9wZXJ0eVwiO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJhcnJheVwiXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7QVJSQVl9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coQVJSQVkpOyAvLyBcImFycmF5XCJcbiovXG5cbnZhciBBUlJBWSA9IFwiYXJyYXlcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwib2JqZWN0XCJcbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtPQkpFQ1R9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coT0JKRUNUKTsgLy8gXCJvYmplY3RcIlxuKi9cblxudmFyIE9CSkVDVCA9IFwib2JqZWN0XCI7XG4vKipcbiogZ2V0IHN0cmluZyBcInN0cmluZ1wiXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7U1RSSU5HfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKFNUUklORyk7IC8vIFwic3RyaW5nXCJcbiovXG5cbnZhciBTVFJJTkcgPSBcInN0cmluZ1wiO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJudW1iZXJcIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge05VTUJFUn0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhOVU1CRVIpOyAvLyBcIm51bWJlclwiXG4qL1xuXG52YXIgTlVNQkVSID0gXCJudW1iZXJcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwidW5kZWZpbmVkXCJcbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtVTkRFRklORUR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coVU5ERUZJTkVEKTsgLy8gXCJ1bmRlZmluZWRcIlxuKi9cblxudmFyIFVOREVGSU5FRCA9IFwidW5kZWZpbmVkXCI7XG4vKipcbiogQ2hlY2sgd2hldGhlciB0aGUgZW52aXJvbm1lbnQgaXMgd2luZG93IG9yIG5vZGUuanMuXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7SVNfV0lORE9XfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKElTX1dJTkRPVyk7IC8vIGZhbHNlIGluIG5vZGUuanNcbmNvbnNvbGUubG9nKElTX1dJTkRPVyk7IC8vIHRydWUgaW4gYnJvd3NlclxuKi9cblxudmFyIElTX1dJTkRPVyA9IHR5cGVvZiB3aW5kb3cgIT09IFVOREVGSU5FRDtcbi8qKlxuKiBDaGVjayB3aGV0aGVyIHRoZSBlbnZpcm9ubWVudCBpcyB3aW5kb3cgb3Igbm9kZS5qcy5cbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAbmFtZSBkb2N1bWVudFxuKiBAZXhhbXBsZVxuaW1wb3J0IHtJU19XSU5ET1d9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coSVNfV0lORE9XKTsgLy8gZmFsc2UgaW4gbm9kZS5qc1xuY29uc29sZS5sb2coSVNfV0lORE9XKTsgLy8gdHJ1ZSBpbiBicm93c2VyXG4qL1xuXG52YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBVTkRFRklORUQgJiYgZG9jdW1lbnQ7IC8vIEZJWE1FOiB0aGlzIHR5cGUgbWF5YmUgZmFsc2VcbnZhciBwcmVmaXhlcyA9IFtcIndlYmtpdFwiLCBcIm1zXCIsIFwibW96XCIsIFwib1wiXTtcbi8qKlxuICogQG5hbWVzcGFjZSBDcm9zc0Jyb3dzZXJcbiAqL1xuXG4vKipcbiogR2V0IGEgQ1NTIHByb3BlcnR5IHdpdGggYSB2ZW5kb3IgcHJlZml4IHRoYXQgc3VwcG9ydHMgY3Jvc3MgYnJvd3Nlci5cbiogQGZ1bmN0aW9uXG4qIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIEEgQ1NTIHByb3BlcnR5XG4qIEByZXR1cm4ge3N0cmluZ30gQ1NTIHByb3BlcnR5IHdpdGggY3Jvc3MtYnJvd3NlciB2ZW5kb3IgcHJlZml4XG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQGV4YW1wbGVcbmltcG9ydCB7Z2V0Q3Jvc3NCcm93c2VyUHJvcGVydHl9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coZ2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoXCJ0cmFuc2Zvcm1cIikpOyAvLyBcInRyYW5zZm9ybVwiLCBcIi1tcy10cmFuc2Zvcm1cIiwgXCItd2Via2l0LXRyYW5zZm9ybVwiXG5jb25zb2xlLmxvZyhnZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShcImZpbHRlclwiKSk7IC8vIFwiZmlsdGVyXCIsIFwiLXdlYmtpdC1maWx0ZXJcIlxuKi9cblxudmFyIGdldENyb3NzQnJvd3NlclByb3BlcnR5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChwcm9wZXJ0eSkge1xuICBpZiAoIWRvYykge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgdmFyIHN0eWxlcyA9IChkb2MuYm9keSB8fCBkb2MuZG9jdW1lbnRFbGVtZW50KS5zdHlsZTtcbiAgdmFyIGxlbmd0aCA9IHByZWZpeGVzLmxlbmd0aDtcblxuICBpZiAodHlwZW9mIHN0eWxlc1twcm9wZXJ0eV0gIT09IFVOREVGSU5FRCkge1xuICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbmFtZSA9IFwiLVwiICsgcHJlZml4ZXNbaV0gKyBcIi1cIiArIHByb3BlcnR5O1xuXG4gICAgaWYgKHR5cGVvZiBzdHlsZXNbbmFtZV0gIT09IFVOREVGSU5FRCkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCI7XG59O1xuLyoqXG4qIGdldCBzdHJpbmcgXCJ0cmFuc2Zyb21cIiB3aXRoIHRoZSB2ZW5kb3IgcHJlZml4LlxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBleGFtcGxlXG5pbXBvcnQge1RSQU5TRk9STX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhUUkFOU0ZPUk0pOyAvLyBcInRyYW5zZm9ybVwiLCBcIi1tcy10cmFuc2Zvcm1cIiwgXCItd2Via2l0LXRyYW5zZm9ybVwiXG4qL1xuXG52YXIgVFJBTlNGT1JNID0gLyojX19QVVJFX18qL2dldENyb3NzQnJvd3NlclByb3BlcnR5KFwidHJhbnNmb3JtXCIpO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJmaWx0ZXJcIiB3aXRoIHRoZSB2ZW5kb3IgcHJlZml4LlxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBleGFtcGxlXG5pbXBvcnQge0ZJTFRFUn0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhGSUxURVIpOyAvLyBcImZpbHRlclwiLCBcIi1tcy1maWx0ZXJcIiwgXCItd2Via2l0LWZpbHRlclwiXG4qL1xuXG52YXIgRklMVEVSID0gLyojX19QVVJFX18qL2dldENyb3NzQnJvd3NlclByb3BlcnR5KFwiZmlsdGVyXCIpO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJhbmltYXRpb25cIiB3aXRoIHRoZSB2ZW5kb3IgcHJlZml4LlxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBleGFtcGxlXG5pbXBvcnQge0FOSU1BVElPTn0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhBTklNQVRJT04pOyAvLyBcImFuaW1hdGlvblwiLCBcIi1tcy1hbmltYXRpb25cIiwgXCItd2Via2l0LWFuaW1hdGlvblwiXG4qL1xuXG52YXIgQU5JTUFUSU9OID0gLyojX19QVVJFX18qL2dldENyb3NzQnJvd3NlclByb3BlcnR5KFwiYW5pbWF0aW9uXCIpO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJrZXlmcmFtZXNcIiB3aXRoIHRoZSB2ZW5kb3IgcHJlZml4LlxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBleGFtcGxlXG5pbXBvcnQge0tFWUZSQU1FU30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhLRVlGUkFNRVMpOyAvLyBcImtleWZyYW1lc1wiLCBcIi1tcy1rZXlmcmFtZXNcIiwgXCItd2Via2l0LWtleWZyYW1lc1wiXG4qL1xuXG52YXIgS0VZRlJBTUVTID0gLyojX19QVVJFX18qL0FOSU1BVElPTi5yZXBsYWNlKFwiYW5pbWF0aW9uXCIsIFwia2V5ZnJhbWVzXCIpO1xudmFyIE9QRU5fQ0xPU0VEX0NIQVJBQ1RFUlMgPSBbe1xuICBvcGVuOiBcIihcIixcbiAgY2xvc2U6IFwiKVwiXG59LCB7XG4gIG9wZW46IFwiXFxcIlwiLFxuICBjbG9zZTogXCJcXFwiXCJcbn0sIHtcbiAgb3BlbjogXCInXCIsXG4gIGNsb3NlOiBcIidcIlxufSwge1xuICBvcGVuOiBcIlxcXFxcXFwiXCIsXG4gIGNsb3NlOiBcIlxcXFxcXFwiXCJcbn0sIHtcbiAgb3BlbjogXCJcXFxcJ1wiLFxuICBjbG9zZTogXCJcXFxcJ1wiXG59XTtcbnZhciBUSU5ZX05VTSA9IDAuMDAwMDAwMTtcbnZhciBERUZBVUxUX1VOSVRfUFJFU0VUUyA9IHtcbiAgXCJjbVwiOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvcyAqIDk2IC8gMi41NDtcbiAgfSxcbiAgXCJtbVwiOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvcyAqIDk2IC8gMjU0O1xuICB9LFxuICBcImluXCI6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zICogOTY7XG4gIH0sXG4gIFwicHRcIjogZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3MgKiA5NiAvIDcyO1xuICB9LFxuICBcInBjXCI6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zICogOTYgLyA2O1xuICB9LFxuICBcIiVcIjogZnVuY3Rpb24gKHBvcywgc2l6ZSkge1xuICAgIHJldHVybiBwb3MgKiBzaXplIC8gMTAwO1xuICB9LFxuICBcInZ3XCI6IGZ1bmN0aW9uIChwb3MsIHNpemUpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzaXplID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcyAvIDEwMCAqIHNpemU7XG4gIH0sXG4gIFwidmhcIjogZnVuY3Rpb24gKHBvcywgc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHtcbiAgICAgIHNpemUgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcyAvIDEwMCAqIHNpemU7XG4gIH0sXG4gIFwidm1heFwiOiBmdW5jdGlvbiAocG9zLCBzaXplKSB7XG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3MgLyAxMDAgKiBzaXplO1xuICB9LFxuICBcInZtaW5cIjogZnVuY3Rpb24gKHBvcywgc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHtcbiAgICAgIHNpemUgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zIC8gMTAwICogc2l6ZTtcbiAgfVxufTtcblxuLyoqXG4qIEBuYW1lc3BhY2VcbiogQG5hbWUgVXRpbHNcbiovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5uZXIgcHJvZHVjdCBvZiB0d28gbnVtYmVycyhgYTFgLCBgYTJgKSBieSB0d28gY3JpdGVyaWEoYGIxYCwgYGIyYCkuXG4gKiBAbWVtYmVyb2YgVXRpbHNcbiAqIEBwYXJhbSAtIFRoZSBmaXJzdCBudW1iZXJcbiAqIEBwYXJhbSAtIFRoZSBzZWNvbmQgbnVtYmVyXG4gKiBAcGFyYW0gLSBUaGUgZmlyc3QgbnVtYmVyIHRvIGJhc2Ugb24gdGhlIGlubmVyIHByb2R1Y3RcbiAqIEBwYXJhbSAtIFRoZSBzZWNvbmQgbnVtYmVyIHRvIGJhc2Ugb24gdGhlIGlubmVyIHByb2R1Y3RcbiAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBpbm5lciBwcm9kdWN0XG5pbXBvcnQgeyBkb3QgfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGRvdCgwLCAxNSwgMiwgMykpOyAvLyA2XG5jb25zb2xlLmxvZyhkb3QoNSwgMTUsIDIsIDMpKTsgLy8gOVxuY29uc29sZS5sb2coZG90KDUsIDE1LCAxLCAxKSk7IC8vIDEwXG4gKi9cblxuZnVuY3Rpb24gZG90KGExLCBhMiwgYjEsIGIyKSB7XG4gIHJldHVybiAoYTEgKiBiMiArIGEyICogYjEpIC8gKGIxICsgYjIpO1xufVxuLyoqXG4qIENoZWNrIHRoZSB0eXBlIHRoYXQgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZC5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIHRoZSB0eXBlXG4qIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzVW5kZWZpbmVkfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzVW5kZWZpbmVkKHVuZGVmaW5lZCkpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc1VuZGVmaW5lZChcIlwiKSk7IC8vIGZhbHNlXG5jb25zb2xlLmxvZyhpc1VuZGVmaW5lZCgxKSk7IC8vIGZhbHNlXG5jb25zb2xlLmxvZyhpc1VuZGVmaW5lZChudWxsKSk7IC8vIGZhbHNlXG4qL1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBVTkRFRklORUQ7XG59XG4vKipcbiogQ2hlY2sgdGhlIHR5cGUgdGhhdCB0aGUgdmFsdWUgaXMgb2JqZWN0LlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7fSB0cnVlIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuKiBAZXhhbXBsZVxuaW1wb3J0IHtpc09iamVjdH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhpc09iamVjdCh7fSkpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc09iamVjdCh1bmRlZmluZWQpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzT2JqZWN0KFwiXCIpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzT2JqZWN0KG51bGwpKTsgLy8gZmFsc2VcbiovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IE9CSkVDVDtcbn1cbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBpc0FycmF5LlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7fSB0cnVlIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuKiBAZXhhbXBsZVxuaW1wb3J0IHtpc0FycmF5fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzQXJyYXkoW10pKTsgLy8gdHJ1ZVxuY29uc29sZS5sb2coaXNBcnJheSh7fSkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNBcnJheSh1bmRlZmluZWQpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzQXJyYXkobnVsbCkpOyAvLyBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG4vKipcbiogQ2hlY2sgdGhlIHR5cGUgdGhhdCB0aGUgdmFsdWUgaXMgc3RyaW5nLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7fSB0cnVlIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuKiBAZXhhbXBsZVxuaW1wb3J0IHtpc1N0cmluZ30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhpc1N0cmluZyhcIjEyMzRcIikpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc1N0cmluZyh1bmRlZmluZWQpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzU3RyaW5nKDEpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzU3RyaW5nKG51bGwpKTsgLy8gZmFsc2VcbiovXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFNUUklORztcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IE5VTUJFUjtcbn1cbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBmdW5jdGlvbi5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIHRoZSB0eXBlXG4qIEByZXR1cm4ge30gdHJ1ZSBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCBmYWxzZSBvdGhlcndpc2VcbiogQGV4YW1wbGVcbmltcG9ydCB7aXNGdW5jdGlvbn0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhpc0Z1bmN0aW9uKGZ1bmN0aW9uIGEoKSB7fSkpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc0Z1bmN0aW9uKCgpID0+IHt9KSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzRnVuY3Rpb24oXCIxMjM0XCIpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzRnVuY3Rpb24oMSkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNGdW5jdGlvbihudWxsKSk7IC8vIGZhbHNlXG4qL1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IEZVTkNUSU9OO1xufVxuXG5mdW5jdGlvbiBpc0VxdWFsU2VwYXJhdG9yKGNoYXJhY3Rlciwgc2VwYXJhdG9yKSB7XG4gIHZhciBpc0NoYXJhY3RlclNwYWNlID0gY2hhcmFjdGVyID09PSBcIlwiIHx8IGNoYXJhY3RlciA9PSBcIiBcIjtcbiAgdmFyIGlzU2VwYXJhdG9yU3BhY2UgPSBzZXBhcmF0b3IgPT09IFwiXCIgfHwgc2VwYXJhdG9yID09IFwiIFwiO1xuICByZXR1cm4gaXNTZXBhcmF0b3JTcGFjZSAmJiBpc0NoYXJhY3RlclNwYWNlIHx8IGNoYXJhY3RlciA9PT0gc2VwYXJhdG9yO1xufVxuXG5mdW5jdGlvbiBmaW5kT3BlbihvcGVuQ2hhcmFjdGVyLCB0ZXh0cywgaW5kZXgsIGxlbmd0aCwgb3BlbkNsb3NlQ2hhcmFjdGVycykge1xuICB2YXIgaXNJZ25vcmUgPSBmaW5kSWdub3JlKG9wZW5DaGFyYWN0ZXIsIHRleHRzLCBpbmRleCk7XG5cbiAgaWYgKCFpc0lnbm9yZSkge1xuICAgIHJldHVybiBmaW5kQ2xvc2Uob3BlbkNoYXJhY3RlciwgdGV4dHMsIGluZGV4ICsgMSwgbGVuZ3RoLCBvcGVuQ2xvc2VDaGFyYWN0ZXJzKTtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gZmluZElnbm9yZShjaGFyYWN0ZXIsIHRleHRzLCBpbmRleCkge1xuICBpZiAoIWNoYXJhY3Rlci5pZ25vcmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBvdGhlclRleHQgPSB0ZXh0cy5zbGljZShNYXRoLm1heChpbmRleCAtIDMsIDApLCBpbmRleCArIDMpLmpvaW4oXCJcIik7XG4gIHJldHVybiBuZXcgUmVnRXhwKGNoYXJhY3Rlci5pZ25vcmUpLmV4ZWMob3RoZXJUZXh0KTtcbn1cblxuZnVuY3Rpb24gZmluZENsb3NlKGNsb3NlQ2hhcmFjdGVyLCB0ZXh0cywgaW5kZXgsIGxlbmd0aCwgb3BlbkNsb3NlQ2hhcmFjdGVycykge1xuICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgdmFyIGNoYXJhY3RlciA9IHRleHRzW2ldLnRyaW0oKTtcblxuICAgIGlmIChjaGFyYWN0ZXIgPT09IGNsb3NlQ2hhcmFjdGVyLmNsb3NlICYmICFmaW5kSWdub3JlKGNsb3NlQ2hhcmFjdGVyLCB0ZXh0cywgaSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBuZXh0SW5kZXggPSBpOyAvLyByZSBvcGVuXG5cbiAgICB2YXIgb3BlbkNoYXJhY3RlciA9IGZpbmQob3BlbkNsb3NlQ2hhcmFjdGVycywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgb3BlbiA9IF9hLm9wZW47XG4gICAgICByZXR1cm4gb3BlbiA9PT0gY2hhcmFjdGVyO1xuICAgIH0pO1xuXG4gICAgaWYgKG9wZW5DaGFyYWN0ZXIpIHtcbiAgICAgIG5leHRJbmRleCA9IGZpbmRPcGVuKG9wZW5DaGFyYWN0ZXIsIHRleHRzLCBpLCBsZW5ndGgsIG9wZW5DbG9zZUNoYXJhY3RlcnMpO1xuICAgIH1cblxuICAgIGlmIChuZXh0SW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gb3V0X2lfMSA9IGksIFwiYnJlYWtcIjtcbiAgICB9XG5cbiAgICBpID0gbmV4dEluZGV4O1xuICAgIG91dF9pXzEgPSBpO1xuICB9O1xuXG4gIHZhciBvdXRfaV8xO1xuXG4gIGZvciAodmFyIGkgPSBpbmRleDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8xKGkpO1xuXG4gICAgaSA9IG91dF9pXzE7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZV8xID09PSBcIm9iamVjdFwiKSByZXR1cm4gc3RhdGVfMS52YWx1ZTtcbiAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc3BsaXRUZXh0KHRleHQsIHNwbGl0T3B0aW9ucykge1xuICB2YXIgX2EgPSBpc1N0cmluZyhzcGxpdE9wdGlvbnMpID8ge1xuICAgIHNlcGFyYXRvcjogc3BsaXRPcHRpb25zXG4gIH0gOiBzcGxpdE9wdGlvbnMsXG4gICAgICBfYiA9IF9hLnNlcGFyYXRvcixcbiAgICAgIHNlcGFyYXRvciA9IF9iID09PSB2b2lkIDAgPyBcIixcIiA6IF9iLFxuICAgICAgaXNTZXBhcmF0ZUZpcnN0ID0gX2EuaXNTZXBhcmF0ZUZpcnN0LFxuICAgICAgaXNTZXBhcmF0ZU9ubHlPcGVuQ2xvc2UgPSBfYS5pc1NlcGFyYXRlT25seU9wZW5DbG9zZSxcbiAgICAgIF9jID0gX2EuaXNTZXBhcmF0ZU9wZW5DbG9zZSxcbiAgICAgIGlzU2VwYXJhdGVPcGVuQ2xvc2UgPSBfYyA9PT0gdm9pZCAwID8gaXNTZXBhcmF0ZU9ubHlPcGVuQ2xvc2UgOiBfYyxcbiAgICAgIF9kID0gX2Eub3BlbkNsb3NlQ2hhcmFjdGVycyxcbiAgICAgIG9wZW5DbG9zZUNoYXJhY3RlcnMgPSBfZCA9PT0gdm9pZCAwID8gT1BFTl9DTE9TRURfQ0hBUkFDVEVSUyA6IF9kO1xuXG4gIHZhciBvcGVuQ2xvc2VkVGV4dCA9IG9wZW5DbG9zZUNoYXJhY3RlcnMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBvcGVuID0gX2Eub3BlbixcbiAgICAgICAgY2xvc2UgPSBfYS5jbG9zZTtcblxuICAgIGlmIChvcGVuID09PSBjbG9zZSkge1xuICAgICAgcmV0dXJuIG9wZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wZW4gKyBcInxcIiArIGNsb3NlO1xuICB9KS5qb2luKFwifFwiKTtcbiAgdmFyIHJlZ2V4VGV4dCA9IFwiKFxcXFxzKlwiICsgc2VwYXJhdG9yICsgXCJcXFxccyp8XCIgKyBvcGVuQ2xvc2VkVGV4dCArIFwifFxcXFxzKylcIjtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFRleHQsIFwiZ1wiKTtcbiAgdmFyIHRleHRzID0gdGV4dC5zcGxpdChyZWdleCkuZmlsdGVyKEJvb2xlYW4pO1xuICB2YXIgbGVuZ3RoID0gdGV4dHMubGVuZ3RoO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciB0ZW1wVmFsdWVzID0gW107XG5cbiAgZnVuY3Rpb24gcmVzZXRUZW1wKCkge1xuICAgIGlmICh0ZW1wVmFsdWVzLmxlbmd0aCkge1xuICAgICAgdmFsdWVzLnB1c2godGVtcFZhbHVlcy5qb2luKFwiXCIpKTtcbiAgICAgIHRlbXBWYWx1ZXMgPSBbXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcbiAgICB2YXIgY2hhcmFjdGVyID0gdGV4dHNbaV0udHJpbSgpO1xuICAgIHZhciBuZXh0SW5kZXggPSBpO1xuICAgIHZhciBvcGVuQ2hhcmFjdGVyID0gZmluZChvcGVuQ2xvc2VDaGFyYWN0ZXJzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBvcGVuID0gX2Eub3BlbjtcbiAgICAgIHJldHVybiBvcGVuID09PSBjaGFyYWN0ZXI7XG4gICAgfSk7XG4gICAgdmFyIGNsb3NlQ2hhcmFjdGVyID0gZmluZChvcGVuQ2xvc2VDaGFyYWN0ZXJzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBjbG9zZSA9IF9hLmNsb3NlO1xuICAgICAgcmV0dXJuIGNsb3NlID09PSBjaGFyYWN0ZXI7XG4gICAgfSk7XG5cbiAgICBpZiAob3BlbkNoYXJhY3Rlcikge1xuICAgICAgbmV4dEluZGV4ID0gZmluZE9wZW4ob3BlbkNoYXJhY3RlciwgdGV4dHMsIGksIGxlbmd0aCwgb3BlbkNsb3NlQ2hhcmFjdGVycyk7XG5cbiAgICAgIGlmIChuZXh0SW5kZXggIT09IC0xICYmIGlzU2VwYXJhdGVPcGVuQ2xvc2UpIHtcbiAgICAgICAgaWYgKHJlc2V0VGVtcCgpICYmIGlzU2VwYXJhdGVGaXJzdCkge1xuICAgICAgICAgIHJldHVybiBvdXRfaV8yID0gaSwgXCJicmVha1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVzLnB1c2godGV4dHMuc2xpY2UoaSwgbmV4dEluZGV4ICsgMSkuam9pbihcIlwiKSk7XG4gICAgICAgIGkgPSBuZXh0SW5kZXg7XG5cbiAgICAgICAgaWYgKGlzU2VwYXJhdGVGaXJzdCkge1xuICAgICAgICAgIHJldHVybiBvdXRfaV8yID0gaSwgXCJicmVha1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dF9pXzIgPSBpLCBcImNvbnRpbnVlXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjbG9zZUNoYXJhY3RlciAmJiAhZmluZElnbm9yZShjbG9zZUNoYXJhY3RlciwgdGV4dHMsIGkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBjbG9zZUNoYXJhY3Rlci5jbG9zZSk7XG4gICAgfSBlbHNlIGlmIChpc0VxdWFsU2VwYXJhdG9yKGNoYXJhY3Rlciwgc2VwYXJhdG9yKSAmJiAhaXNTZXBhcmF0ZU9ubHlPcGVuQ2xvc2UpIHtcbiAgICAgIHJlc2V0VGVtcCgpO1xuXG4gICAgICBpZiAoaXNTZXBhcmF0ZUZpcnN0KSB7XG4gICAgICAgIHJldHVybiBvdXRfaV8yID0gaSwgXCJicmVha1wiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0X2lfMiA9IGksIFwiY29udGludWVcIjtcbiAgICB9XG5cbiAgICBpZiAobmV4dEluZGV4ID09PSAtMSkge1xuICAgICAgbmV4dEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICB0ZW1wVmFsdWVzLnB1c2godGV4dHMuc2xpY2UoaSwgbmV4dEluZGV4ICsgMSkuam9pbihcIlwiKSk7XG4gICAgaSA9IG5leHRJbmRleDtcbiAgICBvdXRfaV8yID0gaTtcbiAgfTtcblxuICB2YXIgb3V0X2lfMjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHN0YXRlXzIgPSBfbG9vcF8yKGkpO1xuXG4gICAgaSA9IG91dF9pXzI7XG4gICAgaWYgKHN0YXRlXzIgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gIH1cblxuICBpZiAodGVtcFZhbHVlcy5sZW5ndGgpIHtcbiAgICB2YWx1ZXMucHVzaCh0ZW1wVmFsdWVzLmpvaW4oXCJcIikpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn1cbi8qKlxuKiBkaXZpZGUgdGV4dCBieSBzcGFjZS5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBkaXZpZGVcbiogQHJldHVybiB7QXJyYXl9IGRpdmlkZWQgdGV4dHNcbiogQGV4YW1wbGVcbmltcG9ydCB7c3BsaWNlU3BhY2V9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coc3BsaXRTcGFjZShcImEgYiBjIGQgZSBmIGdcIikpO1xuLy8gW1wiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImVcIiwgXCJmXCIsIFwiZ1wiXVxuY29uc29sZS5sb2coc3BsaXRTcGFjZShcIidhLGInIGMgJ2QsZScgZiBnXCIpKTtcbi8vIFtcIidhLGInXCIsIFwiY1wiLCBcIidkLGUnXCIsIFwiZlwiLCBcImdcIl1cbiovXG5cbmZ1bmN0aW9uIHNwbGl0U3BhY2UodGV4dCkge1xuICAvLyBkaXZpZGUgY29tbWEoc3BhY2UpXG4gIHJldHVybiBzcGxpdFRleHQodGV4dCwgXCJcIik7XG59XG4vKipcbiogZGl2aWRlIHRleHQgYnkgY29tbWEuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gZGl2aWRlXG4qIEByZXR1cm4ge0FycmF5fSBkaXZpZGVkIHRleHRzXG4qIEBleGFtcGxlXG5pbXBvcnQge3NwbGl0Q29tbWF9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coc3BsaXRDb21tYShcImEsYixjLGQsZSxmLGdcIikpO1xuLy8gW1wiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImVcIiwgXCJmXCIsIFwiZ1wiXVxuY29uc29sZS5sb2coc3BsaXRDb21tYShcIidhLGInLGMsJ2QsZScsZixnXCIpKTtcbi8vIFtcIidhLGInXCIsIFwiY1wiLCBcIidkLGUnXCIsIFwiZlwiLCBcImdcIl1cbiovXG5cbmZ1bmN0aW9uIHNwbGl0Q29tbWEodGV4dCkge1xuICAvLyBkaXZpZGUgY29tbWEoLClcbiAgLy8gXCJbXlwiXSpcInwnW14nXSonXG4gIHJldHVybiBzcGxpdFRleHQodGV4dCwgXCIsXCIpO1xufVxuLyoqXG4qIGRpdmlkZSB0ZXh0IGJ5IGJyYWNrZXQgXCIoXCIsIFwiKVwiLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIGRpdmlkZVxuKiBAcmV0dXJuIHtvYmplY3R9IGRpdmlkZWQgdGV4dHNcbiogQGV4YW1wbGVcbmltcG9ydCB7c3BsaXRCcmFja2V0fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKHNwbGl0QnJhY2tldChcImEoMSwgMilcIikpO1xuLy8ge3ByZWZpeDogXCJhXCIsIHZhbHVlOiBcIjEsIDJcIiwgc3VmZml4OiBcIlwifVxuY29uc29sZS5sb2coc3BsaXRCcmFja2V0KFwiYSgxLCAyKWJcIikpO1xuLy8ge3ByZWZpeDogXCJhXCIsIHZhbHVlOiBcIjEsIDJcIiwgc3VmZml4OiBcImJcIn1cbiovXG5cbmZ1bmN0aW9uIHNwbGl0QnJhY2tldCh0ZXh0KSB7XG4gIHZhciBtYXRjaGVzID0gLyhbXihdKilcXCgoW1xcc1xcU10qKVxcKShbXFxzXFxTXSopL2cuZXhlYyh0ZXh0KTtcblxuICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCA0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXg6IG1hdGNoZXNbMV0sXG4gICAgICB2YWx1ZTogbWF0Y2hlc1syXSxcbiAgICAgIHN1ZmZpeDogbWF0Y2hlc1szXVxuICAgIH07XG4gIH1cbn1cbi8qKlxuKiBkaXZpZGUgdGV4dCBieSBudW1iZXIgYW5kIHVuaXQuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gZGl2aWRlXG4qIEByZXR1cm4ge30gZGl2aWRlZCB0ZXh0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtzcGxpdFVuaXR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coc3BsaXRVbml0KFwiMTBweFwiKSk7XG4vLyB7cHJlZml4OiBcIlwiLCB2YWx1ZTogMTAsIHVuaXQ6IFwicHhcIn1cbmNvbnNvbGUubG9nKHNwbGl0VW5pdChcIi0xMHB4XCIpKTtcbi8vIHtwcmVmaXg6IFwiXCIsIHZhbHVlOiAtMTAsIHVuaXQ6IFwicHhcIn1cbmNvbnNvbGUubG9nKHNwbGl0VW5pdChcImExMCVcIikpO1xuLy8ge3ByZWZpeDogXCJhXCIsIHZhbHVlOiAxMCwgdW5pdDogXCIlXCJ9XG4qL1xuXG5mdW5jdGlvbiBzcGxpdFVuaXQodGV4dCkge1xuICB2YXIgbWF0Y2hlcyA9IC9eKFteXFxkfGV8XFwtfFxcK10qKSgoPzpcXGR8XFwufC18ZS18ZVxcKykrKShcXFMqKSQvZy5leGVjKHRleHQpO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICB1bml0OiBcIlwiLFxuICAgICAgdmFsdWU6IE5hTlxuICAgIH07XG4gIH1cblxuICB2YXIgcHJlZml4ID0gbWF0Y2hlc1sxXTtcbiAgdmFyIHZhbHVlID0gbWF0Y2hlc1syXTtcbiAgdmFyIHVuaXQgPSBtYXRjaGVzWzNdO1xuICByZXR1cm4ge1xuICAgIHByZWZpeDogcHJlZml4LFxuICAgIHVuaXQ6IHVuaXQsXG4gICAgdmFsdWU6IHBhcnNlRmxvYXQodmFsdWUpXG4gIH07XG59XG4vKipcbiogdHJhbnNmb3JtIHN0cmluZ3MgdG8gY2FtZWwtY2FzZVxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSBzdHJpbmdcbiogQHJldHVybiB7U3RyaW5nfSBjYW1lbC1jYXNlIHN0cmluZ1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtjYW1lbGl6ZX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhjYW1lbGl6ZShcInRyYW5zZm9ybS1vcmlnaW5cIikpOyAvLyB0cmFuc2Zvcm1PcmlnaW5cbmNvbnNvbGUubG9nKGNhbWVsaXplKFwiYWJjZF9lZmdcIikpOyAvLyBhYmNkRWZnXG5jb25zb2xlLmxvZyhjYW1lbGl6ZShcImFiY2QgZWZnXCIpKTsgLy8gYWJjZEVmZ1xuKi9cblxuZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xccy1fXShbYS16XSkvZywgZnVuY3Rpb24gKGFsbCwgbGV0dGVyKSB7XG4gICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cbi8qKlxuKiB0cmFuc2Zvcm0gYSBjYW1lbGl6ZWQgc3RyaW5nIGludG8gYSBsb3dlcmNhc2VkIHN0cmluZy5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gYSBjYW1lbC1jYXNlZCBzdHJpbmdcbiogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9XCItXCJdIC0gYSBzZXBhcmF0b3JcbiogQHJldHVybiB7c3RyaW5nfSAgYSBsb3dlcmNhc2VkIHN0cmluZ1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtkZWNhbWVsaXplfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGRlY2FtZWxpemUoXCJ0cmFuc2Zvcm1PcmlnaW5cIikpOyAvLyB0cmFuc2Zvcm0tb3JpZ2luXG5jb25zb2xlLmxvZyhkZWNhbWVsaXplKFwiYWJjZEVmZ1wiLCBcIl9cIikpOyAvLyBhYmNkX2VmZ1xuKi9cblxuZnVuY3Rpb24gZGVjYW1lbGl6ZShzdHIsIHNlcGFyYXRvcikge1xuICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHtcbiAgICBzZXBhcmF0b3IgPSBcIi1cIjtcbiAgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgZnVuY3Rpb24gKGFsbCwgbGV0dGVyLCBsZXR0ZXIyKSB7XG4gICAgcmV0dXJuIFwiXCIgKyBsZXR0ZXIgKyBzZXBhcmF0b3IgKyBsZXR0ZXIyLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufVxuLyoqXG4qIHRyYW5zZm9ybXMgc29tZXRoaW5nIGluIGFuIGFycmF5IGludG8gYW4gYXJyYXkuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0gLSBBcnJheSBmb3JtXG4qIEByZXR1cm4gYW4gYXJyYXlcbiogQGV4YW1wbGVcbmltcG9ydCB7dG9BcnJheX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zdCBhcnIxID0gdG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFcIikpOyAvLyBFbGVtZW50W11cbmNvbnN0IGFycjIgPSB0b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTEVsZW1lbnQ+KFwiLmFcIikpOyAvLyBIVE1MRWxlbWVudFtdXG4qL1xuXG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKHZhbHVlKTtcbn1cbi8qKlxuKiBEYXRlLm5vdygpIG1ldGhvZFxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEByZXR1cm4ge251bWJlcn0gbWlsbGlzZWNvbmRzXG4qIEBleGFtcGxlXG5pbXBvcnQge25vd30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhub3coKSk7IC8vIDEyMTIxMzI0MjQxKG1pbGxpc2Vjb25kcylcbiovXG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuLyoqXG4qIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHBhcmFtIC0gVGhlIGFycmF5IGBmaW5kSW5kZXhgIHdhcyBjYWxsZWQgdXBvbi5cbiogQHBhcmFtIC0gQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5IHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiogQHBhcmFtIC0gUmV0dXJucyBkZWZhdWx0SW5kZXggaWYgbm90IGZvdW5kIGJ5IHRoZSBmdW5jdGlvbi5cbiogQGV4YW1wbGVcbmltcG9ydCB7IGZpbmRJbmRleCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuZmluZEluZGV4KFt7YTogMX0sIHthOiAyfSwge2E6IDN9LCB7YTogNH1dLCAoeyBhIH0pID0+IGEgPT09IDIpOyAvLyAxXG4qL1xuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBjYWxsYmFjaywgZGVmYXVsdEluZGV4KSB7XG4gIGlmIChkZWZhdWx0SW5kZXggPT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHRJbmRleCA9IC0xO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmIChjYWxsYmFjayhhcnJbaV0sIGksIGFycikpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0SW5kZXg7XG59XG4vKipcbiogUmV0dXJucyB0aGUgcmV2ZXJzZSBkaXJlY3Rpb24gaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIENyb3NzQnJvd3NlclxuKiBAcGFyYW0gLSBUaGUgYXJyYXkgYGZpbmRMYXN0SW5kZXhgIHdhcyBjYWxsZWQgdXBvbi5cbiogQHBhcmFtIC0gQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5IHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiogQHBhcmFtIC0gUmV0dXJucyBkZWZhdWx0SW5kZXggaWYgbm90IGZvdW5kIGJ5IHRoZSBmdW5jdGlvbi5cbiogQGV4YW1wbGVcbmltcG9ydCB7IGZpbmRMYXN0SW5kZXggfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmZpbmRMYXN0SW5kZXgoW3thOiAxfSwge2E6IDJ9LCB7YTogM30sIHthOiA0fV0sICh7IGEgfSkgPT4gYSA9PT0gMik7IC8vIDFcbiovXG5cbmZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyLCBjYWxsYmFjaywgZGVmYXVsdEluZGV4KSB7XG4gIGlmIChkZWZhdWx0SW5kZXggPT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHRJbmRleCA9IC0xO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycltpXSwgaSwgYXJyKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRJbmRleDtcbn1cbi8qKlxuKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb24gZWxlbWVudCBpbiB0aGUgYXJyYXkgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBwYXJhbSAtIFRoZSBhcnJheSBgZmluZExhc3RgIHdhcyBjYWxsZWQgdXBvbi5cbiogQHBhcmFtIC0gQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LFxuKiBAcGFyYW0gLSBSZXR1cm5zIGRlZmFsdXRWYWx1ZSBpZiBub3QgZm91bmQgYnkgdGhlIGZ1bmN0aW9uLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHsgZmluZCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuZmluZChbe2E6IDF9LCB7YTogMn0sIHthOiAzfSwge2E6IDR9XSwgKHsgYSB9KSA9PiBhID09PSAyKTsgLy8ge2E6IDJ9XG4qL1xuXG5mdW5jdGlvbiBmaW5kTGFzdChhcnIsIGNhbGxiYWNrLCBkZWZhbHV0VmFsdWUpIHtcbiAgdmFyIGluZGV4ID0gZmluZExhc3RJbmRleChhcnIsIGNhbGxiYWNrKTtcbiAgcmV0dXJuIGluZGV4ID4gLTEgPyBhcnJbaW5kZXhdIDogZGVmYWx1dFZhbHVlO1xufVxuLyoqXG4qIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHBhcmFtIC0gVGhlIGFycmF5IGBmaW5kYCB3YXMgY2FsbGVkIHVwb24uXG4qIEBwYXJhbSAtIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIGluIHRoZSBhcnJheSxcbiogQHBhcmFtIC0gUmV0dXJucyBkZWZhbHV0VmFsdWUgaWYgbm90IGZvdW5kIGJ5IHRoZSBmdW5jdGlvbi5cbiogQGV4YW1wbGVcbmltcG9ydCB7IGZpbmQgfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmZpbmQoW3thOiAxfSwge2E6IDJ9LCB7YTogM30sIHthOiA0fV0sICh7IGEgfSkgPT4gYSA9PT0gMik7IC8vIHthOiAyfVxuKi9cblxuZnVuY3Rpb24gZmluZChhcnIsIGNhbGxiYWNrLCBkZWZhbHV0VmFsdWUpIHtcbiAgdmFyIGluZGV4ID0gZmluZEluZGV4KGFyciwgY2FsbGJhY2spO1xuICByZXR1cm4gaW5kZXggPiAtMSA/IGFycltpbmRleF0gOiBkZWZhbHV0VmFsdWU7XG59XG4vKipcbiogd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgpIG1ldGhvZCB3aXRoIGNyb3NzIGJyb3dzZXIuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBwYXJhbSB7RnJhbWVSZXF1ZXN0Q2FsbGJhY2t9IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBpdCdzIHRpbWUgdG8gdXBkYXRlIHlvdXIgYW5pbWF0aW9uIGZvciB0aGUgbmV4dCByZXBhaW50LlxuKiBAcmV0dXJuIHtudW1iZXJ9IGlkXG4qIEBleGFtcGxlXG5pbXBvcnQge3JlcXVlc3RBbmltYXRpb25GcmFtZX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4ge1xuICBjb25zb2xlLmxvZyh0aW1lc3RhbXApO1xufSk7XG4qL1xuXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIGZpcnN0VGltZSA9IG5vdygpO1xuICB2YXIgcmFmID0gSVNfV0lORE9XICYmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpO1xuICByZXR1cm4gcmFmID8gcmFmLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBjdXJyVGltZSA9IG5vdygpO1xuICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGN1cnJUaW1lIC0gZmlyc3RUaW1lKTtcbiAgICB9LCAxMDAwIC8gNjApO1xuICAgIHJldHVybiBpZDtcbiAgfTtcbn0oKTtcbi8qKlxuKiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoKSBtZXRob2Qgd2l0aCBjcm9zcyBicm93c2VyLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIENyb3NzQnJvd3NlclxuKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIC0gdGhlIGlkIG9idGFpbmVkIHRocm91Z2ggcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG1ldGhvZFxuKiBAcmV0dXJuIHt2b2lkfVxuKiBAZXhhbXBsZVxuaW1wb3J0IHsgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc3QgaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4ge1xuICBjb25zb2xlLmxvZyh0aW1lc3RhbXApO1xufSk7XG5cbmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiovXG5cbnZhciBjYW5jZWxBbmltYXRpb25GcmFtZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBjYWYgPSBJU19XSU5ET1cgJiYgKHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lKTtcbiAgcmV0dXJuIGNhZiA/IGNhZi5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gIH07XG59KCk7XG4vKipcbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gZ2V0S2V5cyhvYmopIHtcbiAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gIH1cblxuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIG5hbWUgaW4ga2V5cykge1xuICAgIGtleXMucHVzaChuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuLyoqXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHNvcnRPcmRlcnMoa2V5cywgb3JkZXJzKSB7XG4gIGlmIChvcmRlcnMgPT09IHZvaWQgMCkge1xuICAgIG9yZGVycyA9IFtdO1xuICB9XG5cbiAga2V5cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGluZGV4MSA9IG9yZGVycy5pbmRleE9mKGEpO1xuICAgIHZhciBpbmRleDIgPSBvcmRlcnMuaW5kZXhPZihiKTtcblxuICAgIGlmIChpbmRleDIgPT09IC0xICYmIGluZGV4MSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChpbmRleDEgPT09IC0xKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXgyID09PSAtMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDEgLSBpbmRleDI7XG4gIH0pO1xufVxuLyoqXG4qIGNvbnZlcnQgdW5pdCBzaXplIHRvIHB4IHNpemVcbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gY29udmVydFVuaXRTaXplKHBvcywgc2l6ZSkge1xuICB2YXIgX2EgPSBzcGxpdFVuaXQocG9zKSxcbiAgICAgIHZhbHVlID0gX2EudmFsdWUsXG4gICAgICB1bml0ID0gX2EudW5pdDtcblxuICBpZiAoaXNPYmplY3Qoc2l6ZSkpIHtcbiAgICB2YXIgc2l6ZUZ1bmN0aW9uID0gc2l6ZVt1bml0XTtcblxuICAgIGlmIChzaXplRnVuY3Rpb24pIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHNpemVGdW5jdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHNpemVGdW5jdGlvbih2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKERFRkFVTFRfVU5JVF9QUkVTRVRTW3VuaXRdKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX1VOSVRfUFJFU0VUU1t1bml0XSh2YWx1ZSwgc2l6ZUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gXCIlXCIpIHtcbiAgICByZXR1cm4gdmFsdWUgKiBzaXplIC8gMTAwO1xuICB9XG5cbiAgaWYgKERFRkFVTFRfVU5JVF9QUkVTRVRTW3VuaXRdKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfVU5JVF9QUkVTRVRTW3VuaXRdKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuKiBjYWxjdWxhdGUgYmV0d2VlbiBtaW4sIG1heFxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBiZXR3ZWVuKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG59XG5mdW5jdGlvbiBjaGVja0JvdW5kU2l6ZSh0YXJnZXRTaXplLCBjb21wYXJlU2l6ZSwgaXNNYXgpIHtcbiAgcmV0dXJuIFtbdGhyb3R0bGUoY29tcGFyZVNpemVbMF0sIFRJTllfTlVNKSwgdGhyb3R0bGUoY29tcGFyZVNpemVbMF0gKiB0YXJnZXRTaXplWzFdIC8gdGFyZ2V0U2l6ZVswXSwgVElOWV9OVU0pXSwgW3Rocm90dGxlKGNvbXBhcmVTaXplWzFdICogdGFyZ2V0U2l6ZVswXSAvIHRhcmdldFNpemVbMV0sIFRJTllfTlVNKSwgdGhyb3R0bGUoY29tcGFyZVNpemVbMV0sIFRJTllfTlVNKV1dLmZpbHRlcihmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiBzaXplLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgcmV0dXJuIGlzTWF4ID8gdmFsdWUgPD0gY29tcGFyZVNpemVbaV0gOiB2YWx1ZSA+PSBjb21wYXJlU2l6ZVtpXTtcbiAgICB9KTtcbiAgfSlbMF0gfHwgdGFyZ2V0U2l6ZTtcbn1cbi8qKlxuKiBjYWxjdWxhdGUgYm91bmQgc2l6ZVxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVCb3VuZFNpemUoc2l6ZSwgbWluU2l6ZSwgbWF4U2l6ZSwga2VlcFJhdGlvKSB7XG4gIGlmICgha2VlcFJhdGlvKSB7XG4gICAgcmV0dXJuIHNpemUubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgcmV0dXJuIGJldHdlZW4odmFsdWUsIG1pblNpemVbaV0sIG1heFNpemVbaV0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHdpZHRoID0gc2l6ZVswXSxcbiAgICAgIGhlaWdodCA9IHNpemVbMV07IC8vIHdpZHRoIDogaGVpZ2h0ID0gbWluV2lkdGggOiBtaW5IZWlnaHQ7XG5cbiAgdmFyIF9hID0gY2hlY2tCb3VuZFNpemUoc2l6ZSwgbWluU2l6ZSwgZmFsc2UpLFxuICAgICAgbWluV2lkdGggPSBfYVswXSxcbiAgICAgIG1pbkhlaWdodCA9IF9hWzFdO1xuXG4gIHZhciBfYiA9IGNoZWNrQm91bmRTaXplKHNpemUsIG1heFNpemUsIHRydWUpLFxuICAgICAgbWF4V2lkdGggPSBfYlswXSxcbiAgICAgIG1heEhlaWdodCA9IF9iWzFdO1xuXG4gIGlmICh3aWR0aCA8IG1pbldpZHRoIHx8IGhlaWdodCA8IG1pbkhlaWdodCkge1xuICAgIHdpZHRoID0gbWluV2lkdGg7XG4gICAgaGVpZ2h0ID0gbWluSGVpZ2h0O1xuICB9IGVsc2UgaWYgKHdpZHRoID4gbWF4V2lkdGggfHwgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG4gICAgd2lkdGggPSBtYXhXaWR0aDtcbiAgICBoZWlnaHQgPSBtYXhIZWlnaHQ7XG4gIH1cblxuICByZXR1cm4gW3dpZHRoLCBoZWlnaHRdO1xufVxuLyoqXG4qIEFkZCBhbGwgdGhlIG51bWJlcnMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHN1bShudW1zKSB7XG4gIHZhciBsZW5ndGggPSBudW1zLmxlbmd0aDtcbiAgdmFyIHRvdGFsID0gMDtcblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB0b3RhbCArPSBudW1zW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRvdGFsO1xufVxuLyoqXG4qIEF2ZXJhZ2UgYWxsIG51bWJlcnMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGF2ZXJhZ2UobnVtcykge1xuICB2YXIgbGVuZ3RoID0gbnVtcy5sZW5ndGg7XG4gIHZhciB0b3RhbCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdG90YWwgKz0gbnVtc1tpXTtcbiAgfVxuXG4gIHJldHVybiBsZW5ndGggPyB0b3RhbCAvIGxlbmd0aCA6IDA7XG59XG4vKipcbiogR2V0IHRoZSBhbmdsZSBvZiB0d28gcG9pbnRzLiAoMCA8PSByYWQgPCAzNTkpXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGdldFJhZChwb3MxLCBwb3MyKSB7XG4gIHZhciBkaXN0WCA9IHBvczJbMF0gLSBwb3MxWzBdO1xuICB2YXIgZGlzdFkgPSBwb3MyWzFdIC0gcG9zMVsxXTtcbiAgdmFyIHJhZCA9IE1hdGguYXRhbjIoZGlzdFksIGRpc3RYKTtcbiAgcmV0dXJuIHJhZCA+PSAwID8gcmFkIDogcmFkICsgTWF0aC5QSSAqIDI7XG59XG4vKipcbiogR2V0IHRoZSBhdmVyYWdlIHBvaW50IG9mIGFsbCBwb2ludHMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGdldENlbnRlclBvaW50KHBvaW50cykge1xuICByZXR1cm4gWzAsIDFdLm1hcChmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdmVyYWdlKHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIHBvc1tpXTtcbiAgICB9KSk7XG4gIH0pO1xufVxuLyoqXG4qIEdldHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2hhcGUuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGdldFNoYXBlRGlyZWN0aW9uKHBvaW50cykge1xuICB2YXIgY2VudGVyID0gZ2V0Q2VudGVyUG9pbnQocG9pbnRzKTtcbiAgdmFyIHBvczFSYWQgPSBnZXRSYWQoY2VudGVyLCBwb2ludHNbMF0pO1xuICB2YXIgcG9zMlJhZCA9IGdldFJhZChjZW50ZXIsIHBvaW50c1sxXSk7XG4gIHJldHVybiBwb3MxUmFkIDwgcG9zMlJhZCAmJiBwb3MyUmFkIC0gcG9zMVJhZCA8IE1hdGguUEkgfHwgcG9zMVJhZCA+IHBvczJSYWQgJiYgcG9zMlJhZCAtIHBvczFSYWQgPCAtTWF0aC5QSSA/IDEgOiAtMTtcbn1cbi8qKlxuKiBHZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gZ2V0RGlzdChhLCBiKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coKGIgPyBiWzBdIDogMCkgLSBhWzBdLCAyKSArIE1hdGgucG93KChiID8gYlsxXSA6IDApIC0gYVsxXSwgMikpO1xufVxuLyoqXG4qIHRocm90dGxlIG51bWJlciBkZXBlbmRpbmcgb24gdGhlIHVuaXQuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHRocm90dGxlKG51bSwgdW5pdCkge1xuICBpZiAoIXVuaXQpIHtcbiAgICByZXR1cm4gbnVtO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtIC8gdW5pdCkgKiB1bml0O1xufVxuLyoqXG4qIHRocm90dGxlIG51bWJlciBhcnJheSBkZXBlbmRpbmcgb24gdGhlIHVuaXQuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHRocm90dGxlQXJyYXkobnVtcywgdW5pdCkge1xuICBudW1zLmZvckVhY2goZnVuY3Rpb24gKF8sIGkpIHtcbiAgICBudW1zW2ldID0gdGhyb3R0bGUobnVtc1tpXSwgdW5pdCk7XG4gIH0pO1xuICByZXR1cm4gbnVtcztcbn1cbi8qKlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBjb3VudGVyKG51bSkge1xuICB2YXIgbnVtcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyArK2kpIHtcbiAgICBudW1zLnB1c2goaSk7XG4gIH1cblxuICByZXR1cm4gbnVtcztcbn1cbi8qKlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiByZXBsYWNlT25jZSh0ZXh0LCBmcm9tVGV4dCwgdG9UZXh0KSB7XG4gIHZhciBpc09uY2UgPSBmYWxzZTtcbiAgcmV0dXJuIHRleHQucmVwbGFjZShmcm9tVGV4dCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cblxuICAgIGlmIChpc09uY2UpIHtcbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlzT25jZSA9IHRydWU7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHRvVGV4dCkgPyB0b1RleHQgOiB0b1RleHQuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgfSk7XG59XG5cbi8qKlxuKiBAbmFtZXNwYWNlXG4qIEBuYW1lIENvbG9yXG4qL1xuXG4vKipcbiogUmVtb3ZlIHRoZSAjIGZyb20gdGhlIGhleCBjb2xvci5cbiogQG1lbWJlcm9mIENvbG9yXG4qIEBwYXJhbSB7fSBoZXggLSBoZXggY29sb3JcbiogQHJldHVybiB7fSBoZXggY29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7Y3V0SGV4fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGN1dEhleChcIiMwMDAwMDBcIikpIC8vIFwiMDAwMDAwXCJcbiovXG5cbmZ1bmN0aW9uIGN1dEhleChoZXgpIHtcbiAgcmV0dXJuIGhleC5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcbn1cbi8qKlxuKiBjb252ZXJ0IGhleCBjb2xvciB0byByZ2IgY29sb3IuXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAcGFyYW0ge30gaGV4IC0gaGV4IGNvbG9yXG4qIEByZXR1cm4ge30gcmdiIGNvbG9yXG4qIEBleGFtcGxlXG5pbXBvcnQge2hleFRvUkdCQX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhoZXhUb1JHQkEoXCIjMDAwMDAwMDVcIikpO1xuLy8gWzAsIDAsIDAsIDFdXG5jb25zb2xlLmxvZyhoZXhUb1JHQkEoXCIjMjAxMDQ1XCIpKTtcbi8vIFszMiwgMTYsIDY5LCAxXVxuKi9cblxuZnVuY3Rpb24gaGV4VG9SR0JBKGhleCkge1xuICB2YXIgaCA9IGN1dEhleChoZXgpO1xuICB2YXIgciA9IHBhcnNlSW50KGguc3Vic3RyaW5nKDAsIDIpLCAxNik7XG4gIHZhciBnID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoMiwgNCksIDE2KTtcbiAgdmFyIGIgPSBwYXJzZUludChoLnN1YnN0cmluZyg0LCA2KSwgMTYpO1xuICB2YXIgYSA9IHBhcnNlSW50KGguc3Vic3RyaW5nKDYsIDgpLCAxNikgLyAyNTU7XG5cbiAgaWYgKGlzTmFOKGEpKSB7XG4gICAgYSA9IDE7XG4gIH1cblxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxuLyoqXG4qIGNvbnZlcnQgMyhvciA0KS1kaWdpdCBoZXggY29sb3IgdG8gNihvciA4KS1kaWdpdCBoZXggY29sb3IuXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAcGFyYW0ge30gaGV4IC0gMyhvciA0KS1kaWdpdCBoZXggY29sb3JcbiogQHJldHVybiB7fSA2KG9yIDgpLWRpZ2l0IGhleCBjb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHt0b0Z1bGxIZXh9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2codG9GdWxsSGV4KFwiIzEyM1wiKSk7IC8vIFwiIzExMjIzM1wiXG5jb25zb2xlLmxvZyh0b0Z1bGxIZXgoXCIjMTIzYVwiKSk7IC8vIFwiIzExMjIzM2FhXCJcbiovXG5cbmZ1bmN0aW9uIHRvRnVsbEhleChoKSB7XG4gIHZhciByID0gaC5jaGFyQXQoMSk7XG4gIHZhciBnID0gaC5jaGFyQXQoMik7XG4gIHZhciBiID0gaC5jaGFyQXQoMyk7XG4gIHZhciBhID0gaC5jaGFyQXQoNCk7XG4gIHZhciBhcnIgPSBbXCIjXCIsIHIsIHIsIGcsIGcsIGIsIGIsIGEsIGFdO1xuICByZXR1cm4gYXJyLmpvaW4oXCJcIik7XG59XG4vKipcbiogY29udmVydCBoc2wgY29sb3IgdG8gcmdiYSBjb2xvci5cbiogQG1lbWJlcm9mIENvbG9yXG4qIEBwYXJhbSB7fSBoc2wgLSBoc2wgY29sb3IoaHVlOiAwIH4gMzYwLCBzYXR1cmF0aW9uOiAwIH4gMSwgbGlnaHRuZXNzOiAwIH4gMSwgYWxwaGE6IDAgfiAxKVxuKiBAcmV0dXJuIHt9IHJnYmEgY29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7aHNsVG9SR0JBfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGhzbFRvUkdCQShbMTUwLCAwLjUsIDAuNF0pKTtcbi8vIFs1MSwgMTUzLCAxMDIsIDFdXG4qL1xuXG5mdW5jdGlvbiBoc2xUb1JHQkEoaHNsKSB7XG4gIHZhciBfYTtcblxuICB2YXIgaCA9IGhzbFswXTtcbiAgdmFyIHMgPSBoc2xbMV07XG4gIHZhciBsID0gaHNsWzJdO1xuXG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gTWF0aC5mbG9vcigoTWF0aC5hYnMoaCkgKyAzNjApIC8gMzYwKSAqIDM2MDtcbiAgfVxuXG4gIGggJT0gMzYwO1xuICB2YXIgYyA9ICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSkgKiBzO1xuICB2YXIgeCA9IGMgKiAoMSAtIE1hdGguYWJzKGggLyA2MCAlIDIgLSAxKSk7XG4gIHZhciBtID0gbCAtIGMgLyAyO1xuICB2YXIgcmdiO1xuXG4gIGlmIChoIDwgNjApIHtcbiAgICByZ2IgPSBbYywgeCwgMF07XG4gIH0gZWxzZSBpZiAoaCA8IDEyMCkge1xuICAgIHJnYiA9IFt4LCBjLCAwXTtcbiAgfSBlbHNlIGlmIChoIDwgMTgwKSB7XG4gICAgcmdiID0gWzAsIGMsIHhdO1xuICB9IGVsc2UgaWYgKGggPCAyNDApIHtcbiAgICByZ2IgPSBbMCwgeCwgY107XG4gIH0gZWxzZSBpZiAoaCA8IDMwMCkge1xuICAgIHJnYiA9IFt4LCAwLCBjXTtcbiAgfSBlbHNlIGlmIChoIDwgMzYwKSB7XG4gICAgcmdiID0gW2MsIDAsIHhdO1xuICB9IGVsc2Uge1xuICAgIHJnYiA9IFswLCAwLCAwXTtcbiAgfVxuXG4gIHJldHVybiBbTWF0aC5yb3VuZCgocmdiWzBdICsgbSkgKiAyNTUpLCBNYXRoLnJvdW5kKChyZ2JbMV0gKyBtKSAqIDI1NSksIE1hdGgucm91bmQoKHJnYlsyXSArIG0pICogMjU1KSwgKF9hID0gaHNsWzNdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxXTtcbn1cbi8qKlxuKiBjb252ZXJ0IHN0cmluZyB0byByZ2JhIGNvbG9yLlxuKiBAbWVtYmVyb2YgQ29sb3JcbiogQHBhcmFtIHt9IC0gMy1oZXgoIzAwMCksIDQtaGV4KCMwMDAwKSA2LWhleCgjMDAwMDAwKSwgOC1oZXgoIzAwMDAwMDAwKSBvciBSR0IoQSksIG9yIEhTTChBKVxuKiBAcmV0dXJuIHt9IHJnYmEgY29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7c3RyaW5nVG9SR0JBfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKHN0cmluZ1RvUkdCQShcIiMwMDAwMDBcIikpOyAvLyBbMCwgMCwgMCwgMV1cbmNvbnNvbGUubG9nKHN0cmluZ1RvUkdCQShcInJnYigxMDAsIDEwMCwgMTAwKVwiKSk7IC8vIFsxMDAsIDEwMCwgMTAwLCAxXVxuY29uc29sZS5sb2coc3RyaW5nVG9SR0JBKFwiaHNsKDE1MCwgMC41LCAwLjQpXCIpKTsgLy8gWzUxLCAxNTMsIDEwMiwgMV1cbiovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvUkdCQShjb2xvcikge1xuICBpZiAoY29sb3IuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgIGlmIChjb2xvci5sZW5ndGggPT09IDQgfHwgY29sb3IubGVuZ3RoID09PSA1KSB7XG4gICAgICByZXR1cm4gaGV4VG9SR0JBKHRvRnVsbEhleChjb2xvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaGV4VG9SR0JBKGNvbG9yKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29sb3IuaW5kZXhPZihcIihcIikgIT09IC0xKSB7XG4gICAgLy8gaW4gYnJhY2tldC5cbiAgICB2YXIgX2EgPSBzcGxpdEJyYWNrZXQoY29sb3IpLFxuICAgICAgICBwcmVmaXggPSBfYS5wcmVmaXgsXG4gICAgICAgIHZhbHVlID0gX2EudmFsdWU7XG5cbiAgICBpZiAoIXByZWZpeCB8fCAhdmFsdWUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGFyciA9IHNwbGl0Q29tbWEodmFsdWUpO1xuICAgIHZhciBjb2xvckFyciA9IFswLCAwLCAwLCAxXTtcbiAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICAgIHN3aXRjaCAocHJlZml4KSB7XG4gICAgICBjYXNlIFJHQjpcbiAgICAgIGNhc2UgUkdCQTpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbG9yQXJyW2ldID0gcGFyc2VGbG9hdChhcnJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yQXJyO1xuXG4gICAgICBjYXNlIEhTTDpcbiAgICAgIGNhc2UgSFNMQTpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChhcnJbaV0uaW5kZXhPZihcIiVcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBjb2xvckFycltpXSA9IHBhcnNlRmxvYXQoYXJyW2ldKSAvIDEwMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sb3JBcnJbaV0gPSBwYXJzZUZsb2F0KGFycltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGhzbCwgaHNsYSB0byByZ2JhXG5cblxuICAgICAgICByZXR1cm4gaHNsVG9SR0JBKGNvbG9yQXJyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgYWxsIGVsZW1lbnQgZGVzY2VuZGFudHMgb2Ygbm9kZSB0aGF0XG4gKiBtYXRjaCBzZWxlY3RvcnMuXG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBjbGFzcyB2YWx1ZSBleGlzdHMgaW4gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXG4gKiBAbWVtYmVyb2YgRE9NXG4gKiBAcGFyYW0gLSBBIERPTVN0cmluZyBjb250YWluaW5nIG9uZSBvciBtb3JlIHNlbGVjdG9ycyB0byBtYXRjaFxuICogQHBhcmFtIC0gSWYgbXVsdGkgaXMgdHJ1ZSwgYSBET01TdHJpbmcgY29udGFpbmluZyBvbmUgb3IgbW9yZSBzZWxlY3RvcnMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIEBleGFtcGxlXG5pbXBvcnQgeyR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coJChcImRpdlwiKSk7IC8vIGRpdiBlbGVtZW50XG5jb25zb2xlLmxvZygkKFwiZGl2XCIsIHRydWUpKTsgLy8gW2RpdiwgZGl2XSBlbGVtZW50c1xuKi9cblxuZnVuY3Rpb24gJChzZWxlY3RvcnMsIG11bHRpKSB7XG4gIHJldHVybiBtdWx0aSA/IGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9ycykgOiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvcnMpO1xufVxuLyoqXG4qIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGNsYXNzIHZhbHVlIGV4aXN0cyBpbiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cbiogQG1lbWJlcm9mIERPTVxuKiBAcGFyYW0gZWxlbWVudCAtIHRhcmdldFxuKiBAcGFyYW0gY2xhc3NOYW1lIC0gdGhlIGNsYXNzIG5hbWUgdG8gc2VhcmNoXG4qIEByZXR1cm4ge2Jvb2xlYW59IHJldHVybiBmYWxzZSBpZiB0aGUgY2xhc3MgaXMgbm90IGZvdW5kLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHtoYXNDbGFzc30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhoYXNDbGFzcyhlbGVtZW50LCBcInN0YXJ0XCIpKTsgLy8gdHJ1ZSBvciBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICB9XG5cbiAgcmV0dXJuICEhZWxlbWVudC5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cChcIihcXFxcc3xeKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHN8JClcIikpO1xufVxuLyoqXG4qIEFkZCB0aGUgc3BlY2lmaWVkIGNsYXNzIHZhbHVlLiBJZiB0aGVzZSBjbGFzc2UgYWxyZWFkeSBleGlzdCBpbiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSB0aGV5IGFyZSBpZ25vcmVkLlxuKiBAbWVtYmVyb2YgRE9NXG4qIEBwYXJhbSBlbGVtZW50IC0gdGFyZ2V0XG4qIEBwYXJhbSBjbGFzc05hbWUgLSB0aGUgY2xhc3MgbmFtZSB0byBhZGRcbiogQGV4YW1wbGVcbmltcG9ydCB7YWRkQ2xhc3N9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuYWRkQ2xhc3MoZWxlbWVudCwgXCJzdGFydFwiKTtcbiovXG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgfVxufVxuLyoqXG4qIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBjbGFzcyB2YWx1ZS5cbiogQG1lbWJlcm9mIERPTVxuKiBAcGFyYW0gZWxlbWVudCAtIHRhcmdldFxuKiBAcGFyYW0gY2xhc3NOYW1lIC0gdGhlIGNsYXNzIG5hbWUgdG8gcmVtb3ZlXG4qIEBleGFtcGxlXG5pbXBvcnQge3JlbW92ZUNsYXNzfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbnJlbW92ZUNsYXNzKGVsZW1lbnQsIFwic3RhcnRcIik7XG4qL1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoXFxcXHN8XilcIiArIGNsYXNzTmFtZSArIFwiKFxcXFxzfCQpXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShyZWcsIFwiIFwiKTtcbiAgfVxufVxuLyoqXG4qIEdldHMgdGhlIENTUyBwcm9wZXJ0aWVzIGZyb20gdGhlIGVsZW1lbnQuXG4qIEBtZW1iZXJvZiBET01cbiogQHBhcmFtIGVsZW1lbnRzIC0gZWxlbWVudHNcbiogQHBhcmFtIHByb3Blcml0ZXMgLSB0aGUgQ1NTIHByb3BlcnRpZXNcbiogQHJldHVybiByZXR1cm5zIENTUyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMuXG4qIEBleGFtcGxlXG5pbXBvcnQge2Zyb21DU1N9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coZnJvbUNTUyhlbGVtZW50LCBbXCJsZWZ0XCIsIFwib3BhY2l0eVwiLCBcInRvcFwiXSkpOyAvLyB7XCJsZWZ0XCI6IFwiMTBweFwiLCBcIm9wYWNpdHlcIjogMSwgXCJ0b3BcIjogXCIxMHB4XCJ9XG4qL1xuXG5mdW5jdGlvbiBmcm9tQ1NTKGVsZW1lbnRzLCBwcm9wZXJ0aWVzKSB7XG4gIGlmICghZWxlbWVudHMgfHwgIXByb3BlcnRpZXMgfHwgIXByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIGVsZW1lbnQ7XG5cbiAgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50cztcbiAgfSBlbHNlIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIGNzc09iamVjdCA9IHt9O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY3NzT2JqZWN0W3Byb3BlcnRpZXNbaV1dID0gc3R5bGVzW3Byb3BlcnRpZXNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIGNzc09iamVjdDtcbn1cbi8qKlxuKiBTZXRzIHVwIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc3BlY2lmaWVkIGV2ZW50IGlzIGRlbGl2ZXJlZCB0byB0aGUgdGFyZ2V0XG4qIEBtZW1iZXJvZiBET01cbiogQHBhcmFtIC0gZXZlbnQgdGFyZ2V0XG4qIEBwYXJhbSAtIEEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yLlxuKiBAcGFyYW0gLSBUaGUgb2JqZWN0IHdoaWNoIHJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHRoZSBFdmVudCBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuKiBAcGFyYW0gLSBBbiBvcHRpb25zIG9iamVjdCB0aGF0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXQgdGhlIGV2ZW50IGxpc3RlbmVyLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHthZGRFdmVudH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5hZGRFdmVudChlbCwgXCJjbGlja1wiLCBlID0+IHtcbiAgY29uc29sZS5sb2coZSk7XG59KTtcbiovXG5cbmZ1bmN0aW9uIGFkZEV2ZW50KGVsLCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbn1cbi8qKlxuKiByZW1vdmVzIGZyb20gdGhlIEV2ZW50VGFyZ2V0IGFuIGV2ZW50IGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoKVxuKiBAbWVtYmVyb2YgRE9NXG4qIEBwYXJhbSAtIGV2ZW50IHRhcmdldFxuKiBAcGFyYW0gLSBBIGNhc2Utc2Vuc2l0aXZlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvci5cbiogQHBhcmFtIC0gVGhlIEV2ZW50TGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IGhhbmRsZXIgdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cbiogQHBhcmFtIC0gQW4gb3B0aW9ucyBvYmplY3QgdGhhdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0IHRoZSBldmVudCBsaXN0ZW5lci5cbiogQGV4YW1wbGVcbmltcG9ydCB7YWRkRXZlbnQsIHJlbW92ZUV2ZW50fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5jb25zdCBsaXN0ZW5lciA9IGUgPT4ge1xuICBjb25zb2xlLmxvZyhlKTtcbn07XG5hZGRFdmVudChlbCwgXCJjbGlja1wiLCBsaXN0ZW5lcik7XG5yZW1vdmVFdmVudChlbCwgXCJjbGlja1wiLCBsaXN0ZW5lcik7XG4qL1xuXG5mdW5jdGlvbiByZW1vdmVFdmVudChlbCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IFJHQiwgUkdCQSwgSFNMLCBIU0xBLCBDT0xPUl9NT0RFTFMsIEZVTkNUSU9OLCBQUk9QRVJUWSwgQVJSQVksIE9CSkVDVCwgU1RSSU5HLCBOVU1CRVIsIFVOREVGSU5FRCwgSVNfV0lORE9XLCBkb2MgYXMgZG9jdW1lbnQsIGdldENyb3NzQnJvd3NlclByb3BlcnR5LCBUUkFOU0ZPUk0sIEZJTFRFUiwgQU5JTUFUSU9OLCBLRVlGUkFNRVMsIE9QRU5fQ0xPU0VEX0NIQVJBQ1RFUlMsIFRJTllfTlVNLCBERUZBVUxUX1VOSVRfUFJFU0VUUywgY3V0SGV4LCBoZXhUb1JHQkEsIHRvRnVsbEhleCwgaHNsVG9SR0JBLCBzdHJpbmdUb1JHQkEsIGRvdCwgaXNVbmRlZmluZWQsIGlzT2JqZWN0LCBpc0FycmF5LCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRnVuY3Rpb24sIHNwbGl0VGV4dCwgc3BsaXRTcGFjZSwgc3BsaXRDb21tYSwgc3BsaXRCcmFja2V0LCBzcGxpdFVuaXQsIGNhbWVsaXplLCBkZWNhbWVsaXplLCB0b0FycmF5LCBub3csIGZpbmRJbmRleCwgZmluZExhc3RJbmRleCwgZmluZExhc3QsIGZpbmQsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUsIGdldEtleXMsIHNvcnRPcmRlcnMsIGNvbnZlcnRVbml0U2l6ZSwgYmV0d2VlbiwgY2hlY2tCb3VuZFNpemUsIGNhbGN1bGF0ZUJvdW5kU2l6ZSwgc3VtLCBhdmVyYWdlLCBnZXRSYWQsIGdldENlbnRlclBvaW50LCBnZXRTaGFwZURpcmVjdGlvbiwgZ2V0RGlzdCwgdGhyb3R0bGUsIHRocm90dGxlQXJyYXksIGNvdW50ZXIsIHJlcGxhY2VPbmNlLCAkLCBoYXNDbGFzcywgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzLCBmcm9tQ1NTLCBhZGRFdmVudCwgcmVtb3ZlRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTggRGF5YnJ1c2hcbkBuYW1lOiBAZGF5YnJ1c2gvdXRpbHNcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL3V0aWxzXG5AdmVyc2lvbiAxLjcuMFxuKi9cbi8qKlxuKiBAbmFtZXNwYWNlXG4qIEBuYW1lIENvbnN0c1xuKi9cblxuLyoqXG4qIGdldCBzdHJpbmcgXCJyZ2JcIlxuKiBAbWVtYmVyb2YgQ29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7UkdCfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKFJHQik7IC8vIFwicmdiXCJcbiovXG52YXIgUkdCID0gXCJyZ2JcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwicmdiYVwiXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtSR0JBfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKFJHQkEpOyAvLyBcInJnYmFcIlxuKi9cblxudmFyIFJHQkEgPSBcInJnYmFcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwiaHNsXCJcbiogQG1lbWJlcm9mIENvbG9yXG4qIEBleGFtcGxlXG5pbXBvcnQge0hTTH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhIU0wpOyAvLyBcImhzbFwiXG4qL1xuXG52YXIgSFNMID0gXCJoc2xcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwiaHNsYVwiXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtIU0xBfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKEhTTEEpOyAvLyBcImhzbGFcIlxuKi9cblxudmFyIEhTTEEgPSBcImhzbGFcIjtcbi8qKlxuKiBnZXRzIGFuIGFycmF5IG9mIGNvbG9yIG1vZGVscy5cbiogQG1lbWJlcm9mIENvbG9yXG4qIEBleGFtcGxlXG5pbXBvcnQge0NPTE9SX01PREVMU30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhDT0xPUl9NT0RFTFMpOyAvLyBbXCJyZ2JcIiwgXCJyZ2JhXCIsIFwiaHNsXCIsIFwiaHNsYVwiXTtcbiovXG5cbnZhciBDT0xPUl9NT0RFTFMgPSBbUkdCLCBSR0JBLCBIU0wsIEhTTEFdO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJmdW5jdGlvblwiXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7RlVOQ1RJT059IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coRlVOQ1RJT04pOyAvLyBcImZ1bmN0aW9uXCJcbiovXG5cbnZhciBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwicHJvcGVydHlcIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge1BST1BFUlRZfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKFBST1BFUlRZKTsgLy8gXCJwcm9wZXJ0eVwiXG4qL1xuXG52YXIgUFJPUEVSVFkgPSBcInByb3BlcnR5XCI7XG4vKipcbiogZ2V0IHN0cmluZyBcImFycmF5XCJcbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtBUlJBWX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhBUlJBWSk7IC8vIFwiYXJyYXlcIlxuKi9cblxudmFyIEFSUkFZID0gXCJhcnJheVwiO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJvYmplY3RcIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge09CSkVDVH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhPQkpFQ1QpOyAvLyBcIm9iamVjdFwiXG4qL1xuXG52YXIgT0JKRUNUID0gXCJvYmplY3RcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwic3RyaW5nXCJcbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtTVFJJTkd9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coU1RSSU5HKTsgLy8gXCJzdHJpbmdcIlxuKi9cblxudmFyIFNUUklORyA9IFwic3RyaW5nXCI7XG4vKipcbiogZ2V0IHN0cmluZyBcIm51bWJlclwiXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7TlVNQkVSfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKE5VTUJFUik7IC8vIFwibnVtYmVyXCJcbiovXG5cbnZhciBOVU1CRVIgPSBcIm51bWJlclwiO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJ1bmRlZmluZWRcIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge1VOREVGSU5FRH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhVTkRFRklORUQpOyAvLyBcInVuZGVmaW5lZFwiXG4qL1xuXG52YXIgVU5ERUZJTkVEID0gXCJ1bmRlZmluZWRcIjtcbi8qKlxuKiBDaGVjayB3aGV0aGVyIHRoZSBlbnZpcm9ubWVudCBpcyB3aW5kb3cgb3Igbm9kZS5qcy5cbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtJU19XSU5ET1d9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coSVNfV0lORE9XKTsgLy8gZmFsc2UgaW4gbm9kZS5qc1xuY29uc29sZS5sb2coSVNfV0lORE9XKTsgLy8gdHJ1ZSBpbiBicm93c2VyXG4qL1xuXG52YXIgSVNfV0lORE9XID0gdHlwZW9mIHdpbmRvdyAhPT0gVU5ERUZJTkVEO1xuLyoqXG4qIENoZWNrIHdoZXRoZXIgdGhlIGVudmlyb25tZW50IGlzIHdpbmRvdyBvciBub2RlLmpzLlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBuYW1lIGRvY3VtZW50XG4qIEBleGFtcGxlXG5pbXBvcnQge0lTX1dJTkRPV30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhJU19XSU5ET1cpOyAvLyBmYWxzZSBpbiBub2RlLmpzXG5jb25zb2xlLmxvZyhJU19XSU5ET1cpOyAvLyB0cnVlIGluIGJyb3dzZXJcbiovXG5cbnZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFVOREVGSU5FRCAmJiBkb2N1bWVudDsgLy8gRklYTUU6IHRoaXMgdHlwZSBtYXliZSBmYWxzZVxudmFyIHByZWZpeGVzID0gW1wid2Via2l0XCIsIFwibXNcIiwgXCJtb3pcIiwgXCJvXCJdO1xuLyoqXG4gKiBAbmFtZXNwYWNlIENyb3NzQnJvd3NlclxuICovXG5cbi8qKlxuKiBHZXQgYSBDU1MgcHJvcGVydHkgd2l0aCBhIHZlbmRvciBwcmVmaXggdGhhdCBzdXBwb3J0cyBjcm9zcyBicm93c2VyLlxuKiBAZnVuY3Rpb25cbiogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gQSBDU1MgcHJvcGVydHlcbiogQHJldHVybiB7c3RyaW5nfSBDU1MgcHJvcGVydHkgd2l0aCBjcm9zcy1icm93c2VyIHZlbmRvciBwcmVmaXhcbiogQG1lbWJlcm9mIENyb3NzQnJvd3NlclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtnZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhnZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShcInRyYW5zZm9ybVwiKSk7IC8vIFwidHJhbnNmb3JtXCIsIFwiLW1zLXRyYW5zZm9ybVwiLCBcIi13ZWJraXQtdHJhbnNmb3JtXCJcbmNvbnNvbGUubG9nKGdldENyb3NzQnJvd3NlclByb3BlcnR5KFwiZmlsdGVyXCIpKTsgLy8gXCJmaWx0ZXJcIiwgXCItd2Via2l0LWZpbHRlclwiXG4qL1xuXG52YXIgZ2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gIGlmICghZG9jKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICB2YXIgc3R5bGVzID0gKGRvYy5ib2R5IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQpLnN0eWxlO1xuICB2YXIgbGVuZ3RoID0gcHJlZml4ZXMubGVuZ3RoO1xuXG4gIGlmICh0eXBlb2Ygc3R5bGVzW3Byb3BlcnR5XSAhPT0gVU5ERUZJTkVEKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBuYW1lID0gXCItXCIgKyBwcmVmaXhlc1tpXSArIFwiLVwiICsgcHJvcGVydHk7XG5cbiAgICBpZiAodHlwZW9mIHN0eWxlc1tuYW1lXSAhPT0gVU5ERUZJTkVEKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gXCJcIjtcbn07XG4vKipcbiogZ2V0IHN0cmluZyBcInRyYW5zZnJvbVwiIHdpdGggdGhlIHZlbmRvciBwcmVmaXguXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQGV4YW1wbGVcbmltcG9ydCB7VFJBTlNGT1JNfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKFRSQU5TRk9STSk7IC8vIFwidHJhbnNmb3JtXCIsIFwiLW1zLXRyYW5zZm9ybVwiLCBcIi13ZWJraXQtdHJhbnNmb3JtXCJcbiovXG5cbnZhciBUUkFOU0ZPUk0gPSAvKiNfX1BVUkVfXyovZ2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoXCJ0cmFuc2Zvcm1cIik7XG4vKipcbiogZ2V0IHN0cmluZyBcImZpbHRlclwiIHdpdGggdGhlIHZlbmRvciBwcmVmaXguXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQGV4YW1wbGVcbmltcG9ydCB7RklMVEVSfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKEZJTFRFUik7IC8vIFwiZmlsdGVyXCIsIFwiLW1zLWZpbHRlclwiLCBcIi13ZWJraXQtZmlsdGVyXCJcbiovXG5cbnZhciBGSUxURVIgPSAvKiNfX1BVUkVfXyovZ2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoXCJmaWx0ZXJcIik7XG4vKipcbiogZ2V0IHN0cmluZyBcImFuaW1hdGlvblwiIHdpdGggdGhlIHZlbmRvciBwcmVmaXguXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQGV4YW1wbGVcbmltcG9ydCB7QU5JTUFUSU9OfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKEFOSU1BVElPTik7IC8vIFwiYW5pbWF0aW9uXCIsIFwiLW1zLWFuaW1hdGlvblwiLCBcIi13ZWJraXQtYW5pbWF0aW9uXCJcbiovXG5cbnZhciBBTklNQVRJT04gPSAvKiNfX1BVUkVfXyovZ2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoXCJhbmltYXRpb25cIik7XG4vKipcbiogZ2V0IHN0cmluZyBcImtleWZyYW1lc1wiIHdpdGggdGhlIHZlbmRvciBwcmVmaXguXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQGV4YW1wbGVcbmltcG9ydCB7S0VZRlJBTUVTfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKEtFWUZSQU1FUyk7IC8vIFwia2V5ZnJhbWVzXCIsIFwiLW1zLWtleWZyYW1lc1wiLCBcIi13ZWJraXQta2V5ZnJhbWVzXCJcbiovXG5cbnZhciBLRVlGUkFNRVMgPSAvKiNfX1BVUkVfXyovQU5JTUFUSU9OLnJlcGxhY2UoXCJhbmltYXRpb25cIiwgXCJrZXlmcmFtZXNcIik7XG52YXIgT1BFTl9DTE9TRURfQ0hBUkFDVEVSUyA9IFt7XG4gIG9wZW46IFwiKFwiLFxuICBjbG9zZTogXCIpXCJcbn0sIHtcbiAgb3BlbjogXCJcXFwiXCIsXG4gIGNsb3NlOiBcIlxcXCJcIlxufSwge1xuICBvcGVuOiBcIidcIixcbiAgY2xvc2U6IFwiJ1wiXG59LCB7XG4gIG9wZW46IFwiXFxcXFxcXCJcIixcbiAgY2xvc2U6IFwiXFxcXFxcXCJcIlxufSwge1xuICBvcGVuOiBcIlxcXFwnXCIsXG4gIGNsb3NlOiBcIlxcXFwnXCJcbn1dO1xudmFyIFRJTllfTlVNID0gMC4wMDAwMDAxO1xudmFyIERFRkFVTFRfVU5JVF9QUkVTRVRTID0ge1xuICBcImNtXCI6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zICogOTYgLyAyLjU0O1xuICB9LFxuICBcIm1tXCI6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zICogOTYgLyAyNTQ7XG4gIH0sXG4gIFwiaW5cIjogZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3MgKiA5NjtcbiAgfSxcbiAgXCJwdFwiOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvcyAqIDk2IC8gNzI7XG4gIH0sXG4gIFwicGNcIjogZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3MgKiA5NiAvIDY7XG4gIH0sXG4gIFwiJVwiOiBmdW5jdGlvbiAocG9zLCBzaXplKSB7XG4gICAgcmV0dXJuIHBvcyAqIHNpemUgLyAxMDA7XG4gIH0sXG4gIFwidndcIjogZnVuY3Rpb24gKHBvcywgc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHtcbiAgICAgIHNpemUgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zIC8gMTAwICogc2l6ZTtcbiAgfSxcbiAgXCJ2aFwiOiBmdW5jdGlvbiAocG9zLCBzaXplKSB7XG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkge1xuICAgICAgc2l6ZSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zIC8gMTAwICogc2l6ZTtcbiAgfSxcbiAgXCJ2bWF4XCI6IGZ1bmN0aW9uIChwb3MsIHNpemUpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcyAvIDEwMCAqIHNpemU7XG4gIH0sXG4gIFwidm1pblwiOiBmdW5jdGlvbiAocG9zLCBzaXplKSB7XG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkge1xuICAgICAgc2l6ZSA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3MgLyAxMDAgKiBzaXplO1xuICB9XG59O1xuXG4vKipcbiogQG5hbWVzcGFjZVxuKiBAbmFtZSBVdGlsc1xuKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbm5lciBwcm9kdWN0IG9mIHR3byBudW1iZXJzKGBhMWAsIGBhMmApIGJ5IHR3byBjcml0ZXJpYShgYjFgLCBgYjJgKS5cbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHBhcmFtIC0gVGhlIGZpcnN0IG51bWJlclxuICogQHBhcmFtIC0gVGhlIHNlY29uZCBudW1iZXJcbiAqIEBwYXJhbSAtIFRoZSBmaXJzdCBudW1iZXIgdG8gYmFzZSBvbiB0aGUgaW5uZXIgcHJvZHVjdFxuICogQHBhcmFtIC0gVGhlIHNlY29uZCBudW1iZXIgdG8gYmFzZSBvbiB0aGUgaW5uZXIgcHJvZHVjdFxuICogQHJldHVybiAtIFJldHVybnMgdGhlIGlubmVyIHByb2R1Y3RcbmltcG9ydCB7IGRvdCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coZG90KDAsIDE1LCAyLCAzKSk7IC8vIDZcbmNvbnNvbGUubG9nKGRvdCg1LCAxNSwgMiwgMykpOyAvLyA5XG5jb25zb2xlLmxvZyhkb3QoNSwgMTUsIDEsIDEpKTsgLy8gMTBcbiAqL1xuXG5mdW5jdGlvbiBkb3QoYTEsIGEyLCBiMSwgYjIpIHtcbiAgcmV0dXJuIChhMSAqIGIyICsgYTIgKiBiMSkgLyAoYjEgKyBiMik7XG59XG4vKipcbiogQ2hlY2sgdGhlIHR5cGUgdGhhdCB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCBmYWxzZSBvdGhlcndpc2VcbiogQGV4YW1wbGVcbmltcG9ydCB7aXNVbmRlZmluZWR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coaXNVbmRlZmluZWQodW5kZWZpbmVkKSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzVW5kZWZpbmVkKFwiXCIpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzVW5kZWZpbmVkKDEpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzVW5kZWZpbmVkKG51bGwpKTsgLy8gZmFsc2VcbiovXG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFVOREVGSU5FRDtcbn1cbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBvYmplY3QuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzT2JqZWN0fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzT2JqZWN0KHt9KSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzT2JqZWN0KHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNPYmplY3QoXCJcIikpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNPYmplY3QobnVsbCkpOyAvLyBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gT0JKRUNUO1xufVxuLyoqXG4qIENoZWNrIHRoZSB0eXBlIHRoYXQgdGhlIHZhbHVlIGlzIGlzQXJyYXkuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzQXJyYXl9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coaXNBcnJheShbXSkpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc0FycmF5KHt9KSk7IC8vIGZhbHNlXG5jb25zb2xlLmxvZyhpc0FycmF5KHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNBcnJheShudWxsKSk7IC8vIGZhbHNlXG4qL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBzdHJpbmcuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzU3RyaW5nfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzU3RyaW5nKFwiMTIzNFwiKSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzU3RyaW5nKHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNTdHJpbmcoMSkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNTdHJpbmcobnVsbCkpOyAvLyBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gU1RSSU5HO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gTlVNQkVSO1xufVxuLyoqXG4qIENoZWNrIHRoZSB0eXBlIHRoYXQgdGhlIHZhbHVlIGlzIGZ1bmN0aW9uLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7fSB0cnVlIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuKiBAZXhhbXBsZVxuaW1wb3J0IHtpc0Z1bmN0aW9ufSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzRnVuY3Rpb24oZnVuY3Rpb24gYSgpIHt9KSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzRnVuY3Rpb24oKCkgPT4ge30pKTsgLy8gdHJ1ZVxuY29uc29sZS5sb2coaXNGdW5jdGlvbihcIjEyMzRcIikpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNGdW5jdGlvbigxKSk7IC8vIGZhbHNlXG5jb25zb2xlLmxvZyhpc0Z1bmN0aW9uKG51bGwpKTsgLy8gZmFsc2VcbiovXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gRlVOQ1RJT047XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWxTZXBhcmF0b3IoY2hhcmFjdGVyLCBzZXBhcmF0b3IpIHtcbiAgdmFyIGlzQ2hhcmFjdGVyU3BhY2UgPSBjaGFyYWN0ZXIgPT09IFwiXCIgfHwgY2hhcmFjdGVyID09IFwiIFwiO1xuICB2YXIgaXNTZXBhcmF0b3JTcGFjZSA9IHNlcGFyYXRvciA9PT0gXCJcIiB8fCBzZXBhcmF0b3IgPT0gXCIgXCI7XG4gIHJldHVybiBpc1NlcGFyYXRvclNwYWNlICYmIGlzQ2hhcmFjdGVyU3BhY2UgfHwgY2hhcmFjdGVyID09PSBzZXBhcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGZpbmRPcGVuKG9wZW5DaGFyYWN0ZXIsIHRleHRzLCBpbmRleCwgbGVuZ3RoLCBvcGVuQ2xvc2VDaGFyYWN0ZXJzKSB7XG4gIHZhciBpc0lnbm9yZSA9IGZpbmRJZ25vcmUob3BlbkNoYXJhY3RlciwgdGV4dHMsIGluZGV4KTtcblxuICBpZiAoIWlzSWdub3JlKSB7XG4gICAgcmV0dXJuIGZpbmRDbG9zZShvcGVuQ2hhcmFjdGVyLCB0ZXh0cywgaW5kZXggKyAxLCBsZW5ndGgsIG9wZW5DbG9zZUNoYXJhY3RlcnMpO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5mdW5jdGlvbiBmaW5kSWdub3JlKGNoYXJhY3RlciwgdGV4dHMsIGluZGV4KSB7XG4gIGlmICghY2hhcmFjdGVyLmlnbm9yZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG90aGVyVGV4dCA9IHRleHRzLnNsaWNlKE1hdGgubWF4KGluZGV4IC0gMywgMCksIGluZGV4ICsgMykuam9pbihcIlwiKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoY2hhcmFjdGVyLmlnbm9yZSkuZXhlYyhvdGhlclRleHQpO1xufVxuXG5mdW5jdGlvbiBmaW5kQ2xvc2UoY2xvc2VDaGFyYWN0ZXIsIHRleHRzLCBpbmRleCwgbGVuZ3RoLCBvcGVuQ2xvc2VDaGFyYWN0ZXJzKSB7XG4gIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICB2YXIgY2hhcmFjdGVyID0gdGV4dHNbaV0udHJpbSgpO1xuXG4gICAgaWYgKGNoYXJhY3RlciA9PT0gY2xvc2VDaGFyYWN0ZXIuY2xvc2UgJiYgIWZpbmRJZ25vcmUoY2xvc2VDaGFyYWN0ZXIsIHRleHRzLCBpKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG5leHRJbmRleCA9IGk7IC8vIHJlIG9wZW5cblxuICAgIHZhciBvcGVuQ2hhcmFjdGVyID0gZmluZChvcGVuQ2xvc2VDaGFyYWN0ZXJzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBvcGVuID0gX2Eub3BlbjtcbiAgICAgIHJldHVybiBvcGVuID09PSBjaGFyYWN0ZXI7XG4gICAgfSk7XG5cbiAgICBpZiAob3BlbkNoYXJhY3Rlcikge1xuICAgICAgbmV4dEluZGV4ID0gZmluZE9wZW4ob3BlbkNoYXJhY3RlciwgdGV4dHMsIGksIGxlbmd0aCwgb3BlbkNsb3NlQ2hhcmFjdGVycyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBvdXRfaV8xID0gaSwgXCJicmVha1wiO1xuICAgIH1cblxuICAgIGkgPSBuZXh0SW5kZXg7XG4gICAgb3V0X2lfMSA9IGk7XG4gIH07XG5cbiAgdmFyIG91dF9pXzE7XG5cbiAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoaSk7XG5cbiAgICBpID0gb3V0X2lfMTtcbiAgICBpZiAodHlwZW9mIHN0YXRlXzEgPT09IFwib2JqZWN0XCIpIHJldHVybiBzdGF0ZV8xLnZhbHVlO1xuICAgIGlmIChzdGF0ZV8xID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzcGxpdFRleHQodGV4dCwgc3BsaXRPcHRpb25zKSB7XG4gIHZhciBfYSA9IGlzU3RyaW5nKHNwbGl0T3B0aW9ucykgPyB7XG4gICAgc2VwYXJhdG9yOiBzcGxpdE9wdGlvbnNcbiAgfSA6IHNwbGl0T3B0aW9ucyxcbiAgICAgIF9iID0gX2Euc2VwYXJhdG9yLFxuICAgICAgc2VwYXJhdG9yID0gX2IgPT09IHZvaWQgMCA/IFwiLFwiIDogX2IsXG4gICAgICBpc1NlcGFyYXRlRmlyc3QgPSBfYS5pc1NlcGFyYXRlRmlyc3QsXG4gICAgICBpc1NlcGFyYXRlT25seU9wZW5DbG9zZSA9IF9hLmlzU2VwYXJhdGVPbmx5T3BlbkNsb3NlLFxuICAgICAgX2MgPSBfYS5pc1NlcGFyYXRlT3BlbkNsb3NlLFxuICAgICAgaXNTZXBhcmF0ZU9wZW5DbG9zZSA9IF9jID09PSB2b2lkIDAgPyBpc1NlcGFyYXRlT25seU9wZW5DbG9zZSA6IF9jLFxuICAgICAgX2QgPSBfYS5vcGVuQ2xvc2VDaGFyYWN0ZXJzLFxuICAgICAgb3BlbkNsb3NlQ2hhcmFjdGVycyA9IF9kID09PSB2b2lkIDAgPyBPUEVOX0NMT1NFRF9DSEFSQUNURVJTIDogX2Q7XG5cbiAgdmFyIG9wZW5DbG9zZWRUZXh0ID0gb3BlbkNsb3NlQ2hhcmFjdGVycy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG9wZW4gPSBfYS5vcGVuLFxuICAgICAgICBjbG9zZSA9IF9hLmNsb3NlO1xuXG4gICAgaWYgKG9wZW4gPT09IGNsb3NlKSB7XG4gICAgICByZXR1cm4gb3BlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gb3BlbiArIFwifFwiICsgY2xvc2U7XG4gIH0pLmpvaW4oXCJ8XCIpO1xuICB2YXIgcmVnZXhUZXh0ID0gXCIoXFxcXHMqXCIgKyBzZXBhcmF0b3IgKyBcIlxcXFxzKnxcIiArIG9wZW5DbG9zZWRUZXh0ICsgXCJ8XFxcXHMrKVwiO1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4VGV4dCwgXCJnXCIpO1xuICB2YXIgdGV4dHMgPSB0ZXh0LnNwbGl0KHJlZ2V4KS5maWx0ZXIoQm9vbGVhbik7XG4gIHZhciBsZW5ndGggPSB0ZXh0cy5sZW5ndGg7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIHRlbXBWYWx1ZXMgPSBbXTtcblxuICBmdW5jdGlvbiByZXNldFRlbXAoKSB7XG4gICAgaWYgKHRlbXBWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICB2YWx1ZXMucHVzaCh0ZW1wVmFsdWVzLmpvaW4oXCJcIikpO1xuICAgICAgdGVtcFZhbHVlcyA9IFtdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBjaGFyYWN0ZXIgPSB0ZXh0c1tpXS50cmltKCk7XG4gICAgdmFyIG5leHRJbmRleCA9IGk7XG4gICAgdmFyIG9wZW5DaGFyYWN0ZXIgPSBmaW5kKG9wZW5DbG9zZUNoYXJhY3RlcnMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIG9wZW4gPSBfYS5vcGVuO1xuICAgICAgcmV0dXJuIG9wZW4gPT09IGNoYXJhY3RlcjtcbiAgICB9KTtcbiAgICB2YXIgY2xvc2VDaGFyYWN0ZXIgPSBmaW5kKG9wZW5DbG9zZUNoYXJhY3RlcnMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIGNsb3NlID0gX2EuY2xvc2U7XG4gICAgICByZXR1cm4gY2xvc2UgPT09IGNoYXJhY3RlcjtcbiAgICB9KTtcblxuICAgIGlmIChvcGVuQ2hhcmFjdGVyKSB7XG4gICAgICBuZXh0SW5kZXggPSBmaW5kT3BlbihvcGVuQ2hhcmFjdGVyLCB0ZXh0cywgaSwgbGVuZ3RoLCBvcGVuQ2xvc2VDaGFyYWN0ZXJzKTtcblxuICAgICAgaWYgKG5leHRJbmRleCAhPT0gLTEgJiYgaXNTZXBhcmF0ZU9wZW5DbG9zZSkge1xuICAgICAgICBpZiAocmVzZXRUZW1wKCkgJiYgaXNTZXBhcmF0ZUZpcnN0KSB7XG4gICAgICAgICAgcmV0dXJuIG91dF9pXzIgPSBpLCBcImJyZWFrXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZXMucHVzaCh0ZXh0cy5zbGljZShpLCBuZXh0SW5kZXggKyAxKS5qb2luKFwiXCIpKTtcbiAgICAgICAgaSA9IG5leHRJbmRleDtcblxuICAgICAgICBpZiAoaXNTZXBhcmF0ZUZpcnN0KSB7XG4gICAgICAgICAgcmV0dXJuIG91dF9pXzIgPSBpLCBcImJyZWFrXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0X2lfMiA9IGksIFwiY29udGludWVcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNsb3NlQ2hhcmFjdGVyICYmICFmaW5kSWdub3JlKGNsb3NlQ2hhcmFjdGVyLCB0ZXh0cywgaSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIGNsb3NlQ2hhcmFjdGVyLmNsb3NlKTtcbiAgICB9IGVsc2UgaWYgKGlzRXF1YWxTZXBhcmF0b3IoY2hhcmFjdGVyLCBzZXBhcmF0b3IpICYmICFpc1NlcGFyYXRlT25seU9wZW5DbG9zZSkge1xuICAgICAgcmVzZXRUZW1wKCk7XG5cbiAgICAgIGlmIChpc1NlcGFyYXRlRmlyc3QpIHtcbiAgICAgICAgcmV0dXJuIG91dF9pXzIgPSBpLCBcImJyZWFrXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRfaV8yID0gaSwgXCJjb250aW51ZVwiO1xuICAgIH1cblxuICAgIGlmIChuZXh0SW5kZXggPT09IC0xKSB7XG4gICAgICBuZXh0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgIH1cblxuICAgIHRlbXBWYWx1ZXMucHVzaCh0ZXh0cy5zbGljZShpLCBuZXh0SW5kZXggKyAxKS5qb2luKFwiXCIpKTtcbiAgICBpID0gbmV4dEluZGV4O1xuICAgIG91dF9pXzIgPSBpO1xuICB9O1xuXG4gIHZhciBvdXRfaV8yO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgc3RhdGVfMiA9IF9sb29wXzIoaSk7XG5cbiAgICBpID0gb3V0X2lfMjtcbiAgICBpZiAoc3RhdGVfMiA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgfVxuXG4gIGlmICh0ZW1wVmFsdWVzLmxlbmd0aCkge1xuICAgIHZhbHVlcy5wdXNoKHRlbXBWYWx1ZXMuam9pbihcIlwiKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufVxuLyoqXG4qIGRpdmlkZSB0ZXh0IGJ5IHNwYWNlLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIGRpdmlkZVxuKiBAcmV0dXJuIHtBcnJheX0gZGl2aWRlZCB0ZXh0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtzcGxpY2VTcGFjZX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhzcGxpdFNwYWNlKFwiYSBiIGMgZCBlIGYgZ1wiKSk7XG4vLyBbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIiwgXCJnXCJdXG5jb25zb2xlLmxvZyhzcGxpdFNwYWNlKFwiJ2EsYicgYyAnZCxlJyBmIGdcIikpO1xuLy8gW1wiJ2EsYidcIiwgXCJjXCIsIFwiJ2QsZSdcIiwgXCJmXCIsIFwiZ1wiXVxuKi9cblxuZnVuY3Rpb24gc3BsaXRTcGFjZSh0ZXh0KSB7XG4gIC8vIGRpdmlkZSBjb21tYShzcGFjZSlcbiAgcmV0dXJuIHNwbGl0VGV4dCh0ZXh0LCBcIlwiKTtcbn1cbi8qKlxuKiBkaXZpZGUgdGV4dCBieSBjb21tYS5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBkaXZpZGVcbiogQHJldHVybiB7QXJyYXl9IGRpdmlkZWQgdGV4dHNcbiogQGV4YW1wbGVcbmltcG9ydCB7c3BsaXRDb21tYX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhzcGxpdENvbW1hKFwiYSxiLGMsZCxlLGYsZ1wiKSk7XG4vLyBbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIiwgXCJnXCJdXG5jb25zb2xlLmxvZyhzcGxpdENvbW1hKFwiJ2EsYicsYywnZCxlJyxmLGdcIikpO1xuLy8gW1wiJ2EsYidcIiwgXCJjXCIsIFwiJ2QsZSdcIiwgXCJmXCIsIFwiZ1wiXVxuKi9cblxuZnVuY3Rpb24gc3BsaXRDb21tYSh0ZXh0KSB7XG4gIC8vIGRpdmlkZSBjb21tYSgsKVxuICAvLyBcIlteXCJdKlwifCdbXiddKidcbiAgcmV0dXJuIHNwbGl0VGV4dCh0ZXh0LCBcIixcIik7XG59XG4vKipcbiogZGl2aWRlIHRleHQgYnkgYnJhY2tldCBcIihcIiwgXCIpXCIuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gZGl2aWRlXG4qIEByZXR1cm4ge29iamVjdH0gZGl2aWRlZCB0ZXh0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtzcGxpdEJyYWNrZXR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coc3BsaXRCcmFja2V0KFwiYSgxLCAyKVwiKSk7XG4vLyB7cHJlZml4OiBcImFcIiwgdmFsdWU6IFwiMSwgMlwiLCBzdWZmaXg6IFwiXCJ9XG5jb25zb2xlLmxvZyhzcGxpdEJyYWNrZXQoXCJhKDEsIDIpYlwiKSk7XG4vLyB7cHJlZml4OiBcImFcIiwgdmFsdWU6IFwiMSwgMlwiLCBzdWZmaXg6IFwiYlwifVxuKi9cblxuZnVuY3Rpb24gc3BsaXRCcmFja2V0KHRleHQpIHtcbiAgdmFyIG1hdGNoZXMgPSAvKFteKF0qKVxcKChbXFxzXFxTXSopXFwpKFtcXHNcXFNdKikvZy5leGVjKHRleHQpO1xuXG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDQpIHtcbiAgICByZXR1cm4ge307XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZWZpeDogbWF0Y2hlc1sxXSxcbiAgICAgIHZhbHVlOiBtYXRjaGVzWzJdLFxuICAgICAgc3VmZml4OiBtYXRjaGVzWzNdXG4gICAgfTtcbiAgfVxufVxuLyoqXG4qIGRpdmlkZSB0ZXh0IGJ5IG51bWJlciBhbmQgdW5pdC5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBkaXZpZGVcbiogQHJldHVybiB7fSBkaXZpZGVkIHRleHRzXG4qIEBleGFtcGxlXG5pbXBvcnQge3NwbGl0VW5pdH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhzcGxpdFVuaXQoXCIxMHB4XCIpKTtcbi8vIHtwcmVmaXg6IFwiXCIsIHZhbHVlOiAxMCwgdW5pdDogXCJweFwifVxuY29uc29sZS5sb2coc3BsaXRVbml0KFwiLTEwcHhcIikpO1xuLy8ge3ByZWZpeDogXCJcIiwgdmFsdWU6IC0xMCwgdW5pdDogXCJweFwifVxuY29uc29sZS5sb2coc3BsaXRVbml0KFwiYTEwJVwiKSk7XG4vLyB7cHJlZml4OiBcImFcIiwgdmFsdWU6IDEwLCB1bml0OiBcIiVcIn1cbiovXG5cbmZ1bmN0aW9uIHNwbGl0VW5pdCh0ZXh0KSB7XG4gIHZhciBtYXRjaGVzID0gL14oW15cXGR8ZXxcXC18XFwrXSopKCg/OlxcZHxcXC58LXxlLXxlXFwrKSspKFxcUyopJC9nLmV4ZWModGV4dCk7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZWZpeDogXCJcIixcbiAgICAgIHVuaXQ6IFwiXCIsXG4gICAgICB2YWx1ZTogTmFOXG4gICAgfTtcbiAgfVxuXG4gIHZhciBwcmVmaXggPSBtYXRjaGVzWzFdO1xuICB2YXIgdmFsdWUgPSBtYXRjaGVzWzJdO1xuICB2YXIgdW5pdCA9IG1hdGNoZXNbM107XG4gIHJldHVybiB7XG4gICAgcHJlZml4OiBwcmVmaXgsXG4gICAgdW5pdDogdW5pdCxcbiAgICB2YWx1ZTogcGFyc2VGbG9hdCh2YWx1ZSlcbiAgfTtcbn1cbi8qKlxuKiB0cmFuc2Zvcm0gc3RyaW5ncyB0byBjYW1lbC1jYXNlXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIHN0cmluZ1xuKiBAcmV0dXJuIHtTdHJpbmd9IGNhbWVsLWNhc2Ugc3RyaW5nXG4qIEBleGFtcGxlXG5pbXBvcnQge2NhbWVsaXplfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGNhbWVsaXplKFwidHJhbnNmb3JtLW9yaWdpblwiKSk7IC8vIHRyYW5zZm9ybU9yaWdpblxuY29uc29sZS5sb2coY2FtZWxpemUoXCJhYmNkX2VmZ1wiKSk7IC8vIGFiY2RFZmdcbmNvbnNvbGUubG9nKGNhbWVsaXplKFwiYWJjZCBlZmdcIikpOyAvLyBhYmNkRWZnXG4qL1xuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxzLV9dKFthLXpdKS9nLCBmdW5jdGlvbiAoYWxsLCBsZXR0ZXIpIHtcbiAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuLyoqXG4qIHRyYW5zZm9ybSBhIGNhbWVsaXplZCBzdHJpbmcgaW50byBhIGxvd2VyY2FzZWQgc3RyaW5nLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBhIGNhbWVsLWNhc2VkIHN0cmluZ1xuKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj1cIi1cIl0gLSBhIHNlcGFyYXRvclxuKiBAcmV0dXJuIHtzdHJpbmd9ICBhIGxvd2VyY2FzZWQgc3RyaW5nXG4qIEBleGFtcGxlXG5pbXBvcnQge2RlY2FtZWxpemV9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coZGVjYW1lbGl6ZShcInRyYW5zZm9ybU9yaWdpblwiKSk7IC8vIHRyYW5zZm9ybS1vcmlnaW5cbmNvbnNvbGUubG9nKGRlY2FtZWxpemUoXCJhYmNkRWZnXCIsIFwiX1wiKSk7IC8vIGFiY2RfZWZnXG4qL1xuXG5mdW5jdGlvbiBkZWNhbWVsaXplKHN0ciwgc2VwYXJhdG9yKSB7XG4gIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCkge1xuICAgIHNlcGFyYXRvciA9IFwiLVwiO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBmdW5jdGlvbiAoYWxsLCBsZXR0ZXIsIGxldHRlcjIpIHtcbiAgICByZXR1cm4gXCJcIiArIGxldHRlciArIHNlcGFyYXRvciArIGxldHRlcjIudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59XG4vKipcbiogdHJhbnNmb3JtcyBzb21ldGhpbmcgaW4gYW4gYXJyYXkgaW50byBhbiBhcnJheS5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSAtIEFycmF5IGZvcm1cbiogQHJldHVybiBhbiBhcnJheVxuKiBAZXhhbXBsZVxuaW1wb3J0IHt0b0FycmF5fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnN0IGFycjEgPSB0b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYVwiKSk7IC8vIEVsZW1lbnRbXVxuY29uc3QgYXJyMiA9IHRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbDxIVE1MRWxlbWVudD4oXCIuYVwiKSk7IC8vIEhUTUxFbGVtZW50W11cbiovXG5cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodmFsdWUpO1xufVxuLyoqXG4qIERhdGUubm93KCkgbWV0aG9kXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHJldHVybiB7bnVtYmVyfSBtaWxsaXNlY29uZHNcbiogQGV4YW1wbGVcbmltcG9ydCB7bm93fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKG5vdygpKTsgLy8gMTIxMjEzMjQyNDEobWlsbGlzZWNvbmRzKVxuKi9cblxuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59XG4vKipcbiogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIENyb3NzQnJvd3NlclxuKiBAcGFyYW0gLSBUaGUgYXJyYXkgYGZpbmRJbmRleGAgd2FzIGNhbGxlZCB1cG9uLlxuKiBAcGFyYW0gLSBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXkgdW50aWwgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBzYXRpc2Z5aW5nIGVsZW1lbnQgd2FzIGZvdW5kLlxuKiBAcGFyYW0gLSBSZXR1cm5zIGRlZmF1bHRJbmRleCBpZiBub3QgZm91bmQgYnkgdGhlIGZ1bmN0aW9uLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHsgZmluZEluZGV4IH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5maW5kSW5kZXgoW3thOiAxfSwge2E6IDJ9LCB7YTogM30sIHthOiA0fV0sICh7IGEgfSkgPT4gYSA9PT0gMik7IC8vIDFcbiovXG5cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIGNhbGxiYWNrLCBkZWZhdWx0SW5kZXgpIHtcbiAgaWYgKGRlZmF1bHRJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgZGVmYXVsdEluZGV4ID0gLTE7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycltpXSwgaSwgYXJyKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRJbmRleDtcbn1cbi8qKlxuKiBSZXR1cm5zIHRoZSByZXZlcnNlIGRpcmVjdGlvbiBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBwYXJhbSAtIFRoZSBhcnJheSBgZmluZExhc3RJbmRleGAgd2FzIGNhbGxlZCB1cG9uLlxuKiBAcGFyYW0gLSBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXkgdW50aWwgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBzYXRpc2Z5aW5nIGVsZW1lbnQgd2FzIGZvdW5kLlxuKiBAcGFyYW0gLSBSZXR1cm5zIGRlZmF1bHRJbmRleCBpZiBub3QgZm91bmQgYnkgdGhlIGZ1bmN0aW9uLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHsgZmluZExhc3RJbmRleCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuZmluZExhc3RJbmRleChbe2E6IDF9LCB7YTogMn0sIHthOiAzfSwge2E6IDR9XSwgKHsgYSB9KSA9PiBhID09PSAyKTsgLy8gMVxuKi9cblxuZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnIsIGNhbGxiYWNrLCBkZWZhdWx0SW5kZXgpIHtcbiAgaWYgKGRlZmF1bHRJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgZGVmYXVsdEluZGV4ID0gLTE7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAoY2FsbGJhY2soYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdEluZGV4O1xufVxuLyoqXG4qIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSByZXZlcnNlIGRpcmVjdGlvbiBlbGVtZW50IGluIHRoZSBhcnJheSB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHBhcmFtIC0gVGhlIGFycmF5IGBmaW5kTGFzdGAgd2FzIGNhbGxlZCB1cG9uLlxuKiBAcGFyYW0gLSBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXksXG4qIEBwYXJhbSAtIFJldHVybnMgZGVmYWx1dFZhbHVlIGlmIG5vdCBmb3VuZCBieSB0aGUgZnVuY3Rpb24uXG4qIEBleGFtcGxlXG5pbXBvcnQgeyBmaW5kIH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5maW5kKFt7YTogMX0sIHthOiAyfSwge2E6IDN9LCB7YTogNH1dLCAoeyBhIH0pID0+IGEgPT09IDIpOyAvLyB7YTogMn1cbiovXG5cbmZ1bmN0aW9uIGZpbmRMYXN0KGFyciwgY2FsbGJhY2ssIGRlZmFsdXRWYWx1ZSkge1xuICB2YXIgaW5kZXggPSBmaW5kTGFzdEluZGV4KGFyciwgY2FsbGJhY2spO1xuICByZXR1cm4gaW5kZXggPiAtMSA/IGFycltpbmRleF0gOiBkZWZhbHV0VmFsdWU7XG59XG4vKipcbiogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIENyb3NzQnJvd3NlclxuKiBAcGFyYW0gLSBUaGUgYXJyYXkgYGZpbmRgIHdhcyBjYWxsZWQgdXBvbi5cbiogQHBhcmFtIC0gQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LFxuKiBAcGFyYW0gLSBSZXR1cm5zIGRlZmFsdXRWYWx1ZSBpZiBub3QgZm91bmQgYnkgdGhlIGZ1bmN0aW9uLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHsgZmluZCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuZmluZChbe2E6IDF9LCB7YTogMn0sIHthOiAzfSwge2E6IDR9XSwgKHsgYSB9KSA9PiBhID09PSAyKTsgLy8ge2E6IDJ9XG4qL1xuXG5mdW5jdGlvbiBmaW5kKGFyciwgY2FsbGJhY2ssIGRlZmFsdXRWYWx1ZSkge1xuICB2YXIgaW5kZXggPSBmaW5kSW5kZXgoYXJyLCBjYWxsYmFjayk7XG4gIHJldHVybiBpbmRleCA+IC0xID8gYXJyW2luZGV4XSA6IGRlZmFsdXRWYWx1ZTtcbn1cbi8qKlxuKiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgbWV0aG9kIHdpdGggY3Jvc3MgYnJvd3Nlci5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHBhcmFtIHtGcmFtZVJlcXVlc3RDYWxsYmFja30gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGl0J3MgdGltZSB0byB1cGRhdGUgeW91ciBhbmltYXRpb24gZm9yIHRoZSBuZXh0IHJlcGFpbnQuXG4qIEByZXR1cm4ge251bWJlcn0gaWRcbiogQGV4YW1wbGVcbmltcG9ydCB7cmVxdWVzdEFuaW1hdGlvbkZyYW1lfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbnJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB7XG4gIGNvbnNvbGUubG9nKHRpbWVzdGFtcCk7XG59KTtcbiovXG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgZmlyc3RUaW1lID0gbm93KCk7XG4gIHZhciByYWYgPSBJU19XSU5ET1cgJiYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSk7XG4gIHJldHVybiByYWYgPyByYWYuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGN1cnJUaW1lID0gbm93KCk7XG4gICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2soY3VyclRpbWUgLSBmaXJzdFRpbWUpO1xuICAgIH0sIDEwMDAgLyA2MCk7XG4gICAgcmV0dXJuIGlkO1xuICB9O1xufSgpO1xuLyoqXG4qIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSgpIG1ldGhvZCB3aXRoIGNyb3NzIGJyb3dzZXIuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgLSB0aGUgaWQgb2J0YWluZWQgdGhyb3VnaCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbWV0aG9kXG4qIEByZXR1cm4ge3ZvaWR9XG4qIEBleGFtcGxlXG5pbXBvcnQgeyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbEFuaW1hdGlvbkZyYW1lIH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zdCBpZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB7XG4gIGNvbnNvbGUubG9nKHRpbWVzdGFtcCk7XG59KTtcblxuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuKi9cblxudmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIGNhZiA9IElTX1dJTkRPVyAmJiAod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUpO1xuICByZXR1cm4gY2FmID8gY2FmLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgfTtcbn0oKTtcbi8qKlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBnZXRLZXlzKG9iaikge1xuICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBrZXlzKSB7XG4gICAga2V5cy5wdXNoKG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG4vKipcbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gc29ydE9yZGVycyhrZXlzLCBvcmRlcnMpIHtcbiAgaWYgKG9yZGVycyA9PT0gdm9pZCAwKSB7XG4gICAgb3JkZXJzID0gW107XG4gIH1cblxuICBrZXlzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgaW5kZXgxID0gb3JkZXJzLmluZGV4T2YoYSk7XG4gICAgdmFyIGluZGV4MiA9IG9yZGVycy5pbmRleE9mKGIpO1xuXG4gICAgaWYgKGluZGV4MiA9PT0gLTEgJiYgaW5kZXgxID09PSAtMSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4MSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmIChpbmRleDIgPT09IC0xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4MSAtIGluZGV4MjtcbiAgfSk7XG59XG4vKipcbiogY29udmVydCB1bml0IHNpemUgdG8gcHggc2l6ZVxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBjb252ZXJ0VW5pdFNpemUocG9zLCBzaXplKSB7XG4gIHZhciBfYSA9IHNwbGl0VW5pdChwb3MpLFxuICAgICAgdmFsdWUgPSBfYS52YWx1ZSxcbiAgICAgIHVuaXQgPSBfYS51bml0O1xuXG4gIGlmIChpc09iamVjdChzaXplKSkge1xuICAgIHZhciBzaXplRnVuY3Rpb24gPSBzaXplW3VuaXRdO1xuXG4gICAgaWYgKHNpemVGdW5jdGlvbikge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oc2l6ZUZ1bmN0aW9uKSkge1xuICAgICAgICByZXR1cm4gc2l6ZUZ1bmN0aW9uKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoREVGQVVMVF9VTklUX1BSRVNFVFNbdW5pdF0pIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfVU5JVF9QUkVTRVRTW3VuaXRdKHZhbHVlLCBzaXplRnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh1bml0ID09PSBcIiVcIikge1xuICAgIHJldHVybiB2YWx1ZSAqIHNpemUgLyAxMDA7XG4gIH1cblxuICBpZiAoREVGQVVMVF9VTklUX1BSRVNFVFNbdW5pdF0pIHtcbiAgICByZXR1cm4gREVGQVVMVF9VTklUX1BSRVNFVFNbdW5pdF0odmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4qIGNhbGN1bGF0ZSBiZXR3ZWVuIG1pbiwgbWF4XG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGJldHdlZW4odmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQm91bmRTaXplKHRhcmdldFNpemUsIGNvbXBhcmVTaXplLCBpc01heCwgcmF0aW8pIHtcbiAgaWYgKHJhdGlvID09PSB2b2lkIDApIHtcbiAgICByYXRpbyA9IHRhcmdldFNpemVbMF0gLyB0YXJnZXRTaXplWzFdO1xuICB9XG5cbiAgcmV0dXJuIFtbdGhyb3R0bGUoY29tcGFyZVNpemVbMF0sIFRJTllfTlVNKSwgdGhyb3R0bGUoY29tcGFyZVNpemVbMF0gLyByYXRpbywgVElOWV9OVU0pXSwgW3Rocm90dGxlKGNvbXBhcmVTaXplWzFdICogcmF0aW8sIFRJTllfTlVNKSwgdGhyb3R0bGUoY29tcGFyZVNpemVbMV0sIFRJTllfTlVNKV1dLmZpbHRlcihmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiBzaXplLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgcmV0dXJuIGlzTWF4ID8gdmFsdWUgPD0gY29tcGFyZVNpemVbaV0gOiB2YWx1ZSA+PSBjb21wYXJlU2l6ZVtpXTtcbiAgICB9KTtcbiAgfSlbMF0gfHwgdGFyZ2V0U2l6ZTtcbn1cbi8qKlxuKiBjYWxjdWxhdGUgYm91bmQgc2l6ZVxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVCb3VuZFNpemUoc2l6ZSwgbWluU2l6ZSwgbWF4U2l6ZSwga2VlcFJhdGlvKSB7XG4gIGlmICgha2VlcFJhdGlvKSB7XG4gICAgcmV0dXJuIHNpemUubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgcmV0dXJuIGJldHdlZW4odmFsdWUsIG1pblNpemVbaV0sIG1heFNpemVbaV0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHdpZHRoID0gc2l6ZVswXSxcbiAgICAgIGhlaWdodCA9IHNpemVbMV07XG4gIHZhciByYXRpbyA9IGtlZXBSYXRpbyA9PT0gdHJ1ZSA/IHdpZHRoIC8gaGVpZ2h0IDoga2VlcFJhdGlvOyAvLyB3aWR0aCA6IGhlaWdodCA9IG1pbldpZHRoIDogbWluSGVpZ2h0O1xuXG4gIHZhciBfYSA9IGNoZWNrQm91bmRTaXplKHNpemUsIG1pblNpemUsIGZhbHNlLCByYXRpbyksXG4gICAgICBtaW5XaWR0aCA9IF9hWzBdLFxuICAgICAgbWluSGVpZ2h0ID0gX2FbMV07XG5cbiAgdmFyIF9iID0gY2hlY2tCb3VuZFNpemUoc2l6ZSwgbWF4U2l6ZSwgdHJ1ZSwgcmF0aW8pLFxuICAgICAgbWF4V2lkdGggPSBfYlswXSxcbiAgICAgIG1heEhlaWdodCA9IF9iWzFdO1xuXG4gIGlmICh3aWR0aCA8IG1pbldpZHRoIHx8IGhlaWdodCA8IG1pbkhlaWdodCkge1xuICAgIHdpZHRoID0gbWluV2lkdGg7XG4gICAgaGVpZ2h0ID0gbWluSGVpZ2h0O1xuICB9IGVsc2UgaWYgKHdpZHRoID4gbWF4V2lkdGggfHwgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG4gICAgd2lkdGggPSBtYXhXaWR0aDtcbiAgICBoZWlnaHQgPSBtYXhIZWlnaHQ7XG4gIH1cblxuICByZXR1cm4gW3dpZHRoLCBoZWlnaHRdO1xufVxuLyoqXG4qIEFkZCBhbGwgdGhlIG51bWJlcnMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHN1bShudW1zKSB7XG4gIHZhciBsZW5ndGggPSBudW1zLmxlbmd0aDtcbiAgdmFyIHRvdGFsID0gMDtcblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB0b3RhbCArPSBudW1zW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRvdGFsO1xufVxuLyoqXG4qIEF2ZXJhZ2UgYWxsIG51bWJlcnMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGF2ZXJhZ2UobnVtcykge1xuICB2YXIgbGVuZ3RoID0gbnVtcy5sZW5ndGg7XG4gIHZhciB0b3RhbCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdG90YWwgKz0gbnVtc1tpXTtcbiAgfVxuXG4gIHJldHVybiBsZW5ndGggPyB0b3RhbCAvIGxlbmd0aCA6IDA7XG59XG4vKipcbiogR2V0IHRoZSBhbmdsZSBvZiB0d28gcG9pbnRzLiAoMCA8PSByYWQgPCAzNTkpXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGdldFJhZChwb3MxLCBwb3MyKSB7XG4gIHZhciBkaXN0WCA9IHBvczJbMF0gLSBwb3MxWzBdO1xuICB2YXIgZGlzdFkgPSBwb3MyWzFdIC0gcG9zMVsxXTtcbiAgdmFyIHJhZCA9IE1hdGguYXRhbjIoZGlzdFksIGRpc3RYKTtcbiAgcmV0dXJuIHJhZCA+PSAwID8gcmFkIDogcmFkICsgTWF0aC5QSSAqIDI7XG59XG4vKipcbiogR2V0IHRoZSBhdmVyYWdlIHBvaW50IG9mIGFsbCBwb2ludHMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGdldENlbnRlclBvaW50KHBvaW50cykge1xuICByZXR1cm4gWzAsIDFdLm1hcChmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdmVyYWdlKHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIHBvc1tpXTtcbiAgICB9KSk7XG4gIH0pO1xufVxuLyoqXG4qIEdldHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2hhcGUuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGdldFNoYXBlRGlyZWN0aW9uKHBvaW50cykge1xuICB2YXIgY2VudGVyID0gZ2V0Q2VudGVyUG9pbnQocG9pbnRzKTtcbiAgdmFyIHBvczFSYWQgPSBnZXRSYWQoY2VudGVyLCBwb2ludHNbMF0pO1xuICB2YXIgcG9zMlJhZCA9IGdldFJhZChjZW50ZXIsIHBvaW50c1sxXSk7XG4gIHJldHVybiBwb3MxUmFkIDwgcG9zMlJhZCAmJiBwb3MyUmFkIC0gcG9zMVJhZCA8IE1hdGguUEkgfHwgcG9zMVJhZCA+IHBvczJSYWQgJiYgcG9zMlJhZCAtIHBvczFSYWQgPCAtTWF0aC5QSSA/IDEgOiAtMTtcbn1cbi8qKlxuKiBHZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gZ2V0RGlzdChhLCBiKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coKGIgPyBiWzBdIDogMCkgLSBhWzBdLCAyKSArIE1hdGgucG93KChiID8gYlsxXSA6IDApIC0gYVsxXSwgMikpO1xufVxuLyoqXG4qIHRocm90dGxlIG51bWJlciBkZXBlbmRpbmcgb24gdGhlIHVuaXQuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHRocm90dGxlKG51bSwgdW5pdCkge1xuICBpZiAoIXVuaXQpIHtcbiAgICByZXR1cm4gbnVtO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtIC8gdW5pdCkgKiB1bml0O1xufVxuLyoqXG4qIHRocm90dGxlIG51bWJlciBhcnJheSBkZXBlbmRpbmcgb24gdGhlIHVuaXQuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHRocm90dGxlQXJyYXkobnVtcywgdW5pdCkge1xuICBudW1zLmZvckVhY2goZnVuY3Rpb24gKF8sIGkpIHtcbiAgICBudW1zW2ldID0gdGhyb3R0bGUobnVtc1tpXSwgdW5pdCk7XG4gIH0pO1xuICByZXR1cm4gbnVtcztcbn1cbi8qKlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBjb3VudGVyKG51bSkge1xuICB2YXIgbnVtcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyArK2kpIHtcbiAgICBudW1zLnB1c2goaSk7XG4gIH1cblxuICByZXR1cm4gbnVtcztcbn1cbi8qKlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiByZXBsYWNlT25jZSh0ZXh0LCBmcm9tVGV4dCwgdG9UZXh0KSB7XG4gIHZhciBpc09uY2UgPSBmYWxzZTtcbiAgcmV0dXJuIHRleHQucmVwbGFjZShmcm9tVGV4dCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cblxuICAgIGlmIChpc09uY2UpIHtcbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlzT25jZSA9IHRydWU7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHRvVGV4dCkgPyB0b1RleHQgOiB0b1RleHQuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgfSk7XG59XG5cbi8qKlxuKiBAbmFtZXNwYWNlXG4qIEBuYW1lIENvbG9yXG4qL1xuXG4vKipcbiogUmVtb3ZlIHRoZSAjIGZyb20gdGhlIGhleCBjb2xvci5cbiogQG1lbWJlcm9mIENvbG9yXG4qIEBwYXJhbSB7fSBoZXggLSBoZXggY29sb3JcbiogQHJldHVybiB7fSBoZXggY29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7Y3V0SGV4fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGN1dEhleChcIiMwMDAwMDBcIikpIC8vIFwiMDAwMDAwXCJcbiovXG5cbmZ1bmN0aW9uIGN1dEhleChoZXgpIHtcbiAgcmV0dXJuIGhleC5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcbn1cbi8qKlxuKiBjb252ZXJ0IGhleCBjb2xvciB0byByZ2IgY29sb3IuXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAcGFyYW0ge30gaGV4IC0gaGV4IGNvbG9yXG4qIEByZXR1cm4ge30gcmdiIGNvbG9yXG4qIEBleGFtcGxlXG5pbXBvcnQge2hleFRvUkdCQX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhoZXhUb1JHQkEoXCIjMDAwMDAwMDVcIikpO1xuLy8gWzAsIDAsIDAsIDFdXG5jb25zb2xlLmxvZyhoZXhUb1JHQkEoXCIjMjAxMDQ1XCIpKTtcbi8vIFszMiwgMTYsIDY5LCAxXVxuKi9cblxuZnVuY3Rpb24gaGV4VG9SR0JBKGhleCkge1xuICB2YXIgaCA9IGN1dEhleChoZXgpO1xuICB2YXIgciA9IHBhcnNlSW50KGguc3Vic3RyaW5nKDAsIDIpLCAxNik7XG4gIHZhciBnID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoMiwgNCksIDE2KTtcbiAgdmFyIGIgPSBwYXJzZUludChoLnN1YnN0cmluZyg0LCA2KSwgMTYpO1xuICB2YXIgYSA9IHBhcnNlSW50KGguc3Vic3RyaW5nKDYsIDgpLCAxNikgLyAyNTU7XG5cbiAgaWYgKGlzTmFOKGEpKSB7XG4gICAgYSA9IDE7XG4gIH1cblxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxuLyoqXG4qIGNvbnZlcnQgMyhvciA0KS1kaWdpdCBoZXggY29sb3IgdG8gNihvciA4KS1kaWdpdCBoZXggY29sb3IuXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAcGFyYW0ge30gaGV4IC0gMyhvciA0KS1kaWdpdCBoZXggY29sb3JcbiogQHJldHVybiB7fSA2KG9yIDgpLWRpZ2l0IGhleCBjb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHt0b0Z1bGxIZXh9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2codG9GdWxsSGV4KFwiIzEyM1wiKSk7IC8vIFwiIzExMjIzM1wiXG5jb25zb2xlLmxvZyh0b0Z1bGxIZXgoXCIjMTIzYVwiKSk7IC8vIFwiIzExMjIzM2FhXCJcbiovXG5cbmZ1bmN0aW9uIHRvRnVsbEhleChoKSB7XG4gIHZhciByID0gaC5jaGFyQXQoMSk7XG4gIHZhciBnID0gaC5jaGFyQXQoMik7XG4gIHZhciBiID0gaC5jaGFyQXQoMyk7XG4gIHZhciBhID0gaC5jaGFyQXQoNCk7XG4gIHZhciBhcnIgPSBbXCIjXCIsIHIsIHIsIGcsIGcsIGIsIGIsIGEsIGFdO1xuICByZXR1cm4gYXJyLmpvaW4oXCJcIik7XG59XG4vKipcbiogY29udmVydCBoc2wgY29sb3IgdG8gcmdiYSBjb2xvci5cbiogQG1lbWJlcm9mIENvbG9yXG4qIEBwYXJhbSB7fSBoc2wgLSBoc2wgY29sb3IoaHVlOiAwIH4gMzYwLCBzYXR1cmF0aW9uOiAwIH4gMSwgbGlnaHRuZXNzOiAwIH4gMSwgYWxwaGE6IDAgfiAxKVxuKiBAcmV0dXJuIHt9IHJnYmEgY29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7aHNsVG9SR0JBfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGhzbFRvUkdCQShbMTUwLCAwLjUsIDAuNF0pKTtcbi8vIFs1MSwgMTUzLCAxMDIsIDFdXG4qL1xuXG5mdW5jdGlvbiBoc2xUb1JHQkEoaHNsKSB7XG4gIHZhciBfYTtcblxuICB2YXIgaCA9IGhzbFswXTtcbiAgdmFyIHMgPSBoc2xbMV07XG4gIHZhciBsID0gaHNsWzJdO1xuXG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gTWF0aC5mbG9vcigoTWF0aC5hYnMoaCkgKyAzNjApIC8gMzYwKSAqIDM2MDtcbiAgfVxuXG4gIGggJT0gMzYwO1xuICB2YXIgYyA9ICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSkgKiBzO1xuICB2YXIgeCA9IGMgKiAoMSAtIE1hdGguYWJzKGggLyA2MCAlIDIgLSAxKSk7XG4gIHZhciBtID0gbCAtIGMgLyAyO1xuICB2YXIgcmdiO1xuXG4gIGlmIChoIDwgNjApIHtcbiAgICByZ2IgPSBbYywgeCwgMF07XG4gIH0gZWxzZSBpZiAoaCA8IDEyMCkge1xuICAgIHJnYiA9IFt4LCBjLCAwXTtcbiAgfSBlbHNlIGlmIChoIDwgMTgwKSB7XG4gICAgcmdiID0gWzAsIGMsIHhdO1xuICB9IGVsc2UgaWYgKGggPCAyNDApIHtcbiAgICByZ2IgPSBbMCwgeCwgY107XG4gIH0gZWxzZSBpZiAoaCA8IDMwMCkge1xuICAgIHJnYiA9IFt4LCAwLCBjXTtcbiAgfSBlbHNlIGlmIChoIDwgMzYwKSB7XG4gICAgcmdiID0gW2MsIDAsIHhdO1xuICB9IGVsc2Uge1xuICAgIHJnYiA9IFswLCAwLCAwXTtcbiAgfVxuXG4gIHJldHVybiBbTWF0aC5yb3VuZCgocmdiWzBdICsgbSkgKiAyNTUpLCBNYXRoLnJvdW5kKChyZ2JbMV0gKyBtKSAqIDI1NSksIE1hdGgucm91bmQoKHJnYlsyXSArIG0pICogMjU1KSwgKF9hID0gaHNsWzNdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxXTtcbn1cbi8qKlxuKiBjb252ZXJ0IHN0cmluZyB0byByZ2JhIGNvbG9yLlxuKiBAbWVtYmVyb2YgQ29sb3JcbiogQHBhcmFtIHt9IC0gMy1oZXgoIzAwMCksIDQtaGV4KCMwMDAwKSA2LWhleCgjMDAwMDAwKSwgOC1oZXgoIzAwMDAwMDAwKSBvciBSR0IoQSksIG9yIEhTTChBKVxuKiBAcmV0dXJuIHt9IHJnYmEgY29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7c3RyaW5nVG9SR0JBfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKHN0cmluZ1RvUkdCQShcIiMwMDAwMDBcIikpOyAvLyBbMCwgMCwgMCwgMV1cbmNvbnNvbGUubG9nKHN0cmluZ1RvUkdCQShcInJnYigxMDAsIDEwMCwgMTAwKVwiKSk7IC8vIFsxMDAsIDEwMCwgMTAwLCAxXVxuY29uc29sZS5sb2coc3RyaW5nVG9SR0JBKFwiaHNsKDE1MCwgMC41LCAwLjQpXCIpKTsgLy8gWzUxLCAxNTMsIDEwMiwgMV1cbiovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvUkdCQShjb2xvcikge1xuICBpZiAoY29sb3IuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgIGlmIChjb2xvci5sZW5ndGggPT09IDQgfHwgY29sb3IubGVuZ3RoID09PSA1KSB7XG4gICAgICByZXR1cm4gaGV4VG9SR0JBKHRvRnVsbEhleChjb2xvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaGV4VG9SR0JBKGNvbG9yKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29sb3IuaW5kZXhPZihcIihcIikgIT09IC0xKSB7XG4gICAgLy8gaW4gYnJhY2tldC5cbiAgICB2YXIgX2EgPSBzcGxpdEJyYWNrZXQoY29sb3IpLFxuICAgICAgICBwcmVmaXggPSBfYS5wcmVmaXgsXG4gICAgICAgIHZhbHVlID0gX2EudmFsdWU7XG5cbiAgICBpZiAoIXByZWZpeCB8fCAhdmFsdWUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGFyciA9IHNwbGl0Q29tbWEodmFsdWUpO1xuICAgIHZhciBjb2xvckFyciA9IFswLCAwLCAwLCAxXTtcbiAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICAgIHN3aXRjaCAocHJlZml4KSB7XG4gICAgICBjYXNlIFJHQjpcbiAgICAgIGNhc2UgUkdCQTpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbG9yQXJyW2ldID0gcGFyc2VGbG9hdChhcnJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yQXJyO1xuXG4gICAgICBjYXNlIEhTTDpcbiAgICAgIGNhc2UgSFNMQTpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChhcnJbaV0uaW5kZXhPZihcIiVcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBjb2xvckFycltpXSA9IHBhcnNlRmxvYXQoYXJyW2ldKSAvIDEwMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sb3JBcnJbaV0gPSBwYXJzZUZsb2F0KGFycltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGhzbCwgaHNsYSB0byByZ2JhXG5cblxuICAgICAgICByZXR1cm4gaHNsVG9SR0JBKGNvbG9yQXJyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgYWxsIGVsZW1lbnQgZGVzY2VuZGFudHMgb2Ygbm9kZSB0aGF0XG4gKiBtYXRjaCBzZWxlY3RvcnMuXG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBjbGFzcyB2YWx1ZSBleGlzdHMgaW4gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXG4gKiBAbWVtYmVyb2YgRE9NXG4gKiBAcGFyYW0gLSBBIERPTVN0cmluZyBjb250YWluaW5nIG9uZSBvciBtb3JlIHNlbGVjdG9ycyB0byBtYXRjaFxuICogQHBhcmFtIC0gSWYgbXVsdGkgaXMgdHJ1ZSwgYSBET01TdHJpbmcgY29udGFpbmluZyBvbmUgb3IgbW9yZSBzZWxlY3RvcnMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIEBleGFtcGxlXG5pbXBvcnQgeyR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coJChcImRpdlwiKSk7IC8vIGRpdiBlbGVtZW50XG5jb25zb2xlLmxvZygkKFwiZGl2XCIsIHRydWUpKTsgLy8gW2RpdiwgZGl2XSBlbGVtZW50c1xuKi9cblxuZnVuY3Rpb24gJChzZWxlY3RvcnMsIG11bHRpKSB7XG4gIHJldHVybiBtdWx0aSA/IGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9ycykgOiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvcnMpO1xufVxuLyoqXG4qIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGNsYXNzIHZhbHVlIGV4aXN0cyBpbiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cbiogQG1lbWJlcm9mIERPTVxuKiBAcGFyYW0gZWxlbWVudCAtIHRhcmdldFxuKiBAcGFyYW0gY2xhc3NOYW1lIC0gdGhlIGNsYXNzIG5hbWUgdG8gc2VhcmNoXG4qIEByZXR1cm4ge2Jvb2xlYW59IHJldHVybiBmYWxzZSBpZiB0aGUgY2xhc3MgaXMgbm90IGZvdW5kLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHtoYXNDbGFzc30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhoYXNDbGFzcyhlbGVtZW50LCBcInN0YXJ0XCIpKTsgLy8gdHJ1ZSBvciBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICB9XG5cbiAgcmV0dXJuICEhZWxlbWVudC5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cChcIihcXFxcc3xeKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHN8JClcIikpO1xufVxuLyoqXG4qIEFkZCB0aGUgc3BlY2lmaWVkIGNsYXNzIHZhbHVlLiBJZiB0aGVzZSBjbGFzc2UgYWxyZWFkeSBleGlzdCBpbiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSB0aGV5IGFyZSBpZ25vcmVkLlxuKiBAbWVtYmVyb2YgRE9NXG4qIEBwYXJhbSBlbGVtZW50IC0gdGFyZ2V0XG4qIEBwYXJhbSBjbGFzc05hbWUgLSB0aGUgY2xhc3MgbmFtZSB0byBhZGRcbiogQGV4YW1wbGVcbmltcG9ydCB7YWRkQ2xhc3N9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuYWRkQ2xhc3MoZWxlbWVudCwgXCJzdGFydFwiKTtcbiovXG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgfVxufVxuLyoqXG4qIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBjbGFzcyB2YWx1ZS5cbiogQG1lbWJlcm9mIERPTVxuKiBAcGFyYW0gZWxlbWVudCAtIHRhcmdldFxuKiBAcGFyYW0gY2xhc3NOYW1lIC0gdGhlIGNsYXNzIG5hbWUgdG8gcmVtb3ZlXG4qIEBleGFtcGxlXG5pbXBvcnQge3JlbW92ZUNsYXNzfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbnJlbW92ZUNsYXNzKGVsZW1lbnQsIFwic3RhcnRcIik7XG4qL1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoXFxcXHN8XilcIiArIGNsYXNzTmFtZSArIFwiKFxcXFxzfCQpXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShyZWcsIFwiIFwiKTtcbiAgfVxufVxuLyoqXG4qIEdldHMgdGhlIENTUyBwcm9wZXJ0aWVzIGZyb20gdGhlIGVsZW1lbnQuXG4qIEBtZW1iZXJvZiBET01cbiogQHBhcmFtIGVsZW1lbnRzIC0gZWxlbWVudHNcbiogQHBhcmFtIHByb3Blcml0ZXMgLSB0aGUgQ1NTIHByb3BlcnRpZXNcbiogQHJldHVybiByZXR1cm5zIENTUyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMuXG4qIEBleGFtcGxlXG5pbXBvcnQge2Zyb21DU1N9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coZnJvbUNTUyhlbGVtZW50LCBbXCJsZWZ0XCIsIFwib3BhY2l0eVwiLCBcInRvcFwiXSkpOyAvLyB7XCJsZWZ0XCI6IFwiMTBweFwiLCBcIm9wYWNpdHlcIjogMSwgXCJ0b3BcIjogXCIxMHB4XCJ9XG4qL1xuXG5mdW5jdGlvbiBmcm9tQ1NTKGVsZW1lbnRzLCBwcm9wZXJ0aWVzKSB7XG4gIGlmICghZWxlbWVudHMgfHwgIXByb3BlcnRpZXMgfHwgIXByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIGVsZW1lbnQ7XG5cbiAgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50cztcbiAgfSBlbHNlIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIGNzc09iamVjdCA9IHt9O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY3NzT2JqZWN0W3Byb3BlcnRpZXNbaV1dID0gc3R5bGVzW3Byb3BlcnRpZXNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIGNzc09iamVjdDtcbn1cbi8qKlxuKiBTZXRzIHVwIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc3BlY2lmaWVkIGV2ZW50IGlzIGRlbGl2ZXJlZCB0byB0aGUgdGFyZ2V0XG4qIEBtZW1iZXJvZiBET01cbiogQHBhcmFtIC0gZXZlbnQgdGFyZ2V0XG4qIEBwYXJhbSAtIEEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yLlxuKiBAcGFyYW0gLSBUaGUgb2JqZWN0IHdoaWNoIHJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHRoZSBFdmVudCBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuKiBAcGFyYW0gLSBBbiBvcHRpb25zIG9iamVjdCB0aGF0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXQgdGhlIGV2ZW50IGxpc3RlbmVyLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHthZGRFdmVudH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5hZGRFdmVudChlbCwgXCJjbGlja1wiLCBlID0+IHtcbiAgY29uc29sZS5sb2coZSk7XG59KTtcbiovXG5cbmZ1bmN0aW9uIGFkZEV2ZW50KGVsLCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbn1cbi8qKlxuKiByZW1vdmVzIGZyb20gdGhlIEV2ZW50VGFyZ2V0IGFuIGV2ZW50IGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoKVxuKiBAbWVtYmVyb2YgRE9NXG4qIEBwYXJhbSAtIGV2ZW50IHRhcmdldFxuKiBAcGFyYW0gLSBBIGNhc2Utc2Vuc2l0aXZlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvci5cbiogQHBhcmFtIC0gVGhlIEV2ZW50TGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IGhhbmRsZXIgdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cbiogQHBhcmFtIC0gQW4gb3B0aW9ucyBvYmplY3QgdGhhdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0IHRoZSBldmVudCBsaXN0ZW5lci5cbiogQGV4YW1wbGVcbmltcG9ydCB7YWRkRXZlbnQsIHJlbW92ZUV2ZW50fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5jb25zdCBsaXN0ZW5lciA9IGUgPT4ge1xuICBjb25zb2xlLmxvZyhlKTtcbn07XG5hZGRFdmVudChlbCwgXCJjbGlja1wiLCBsaXN0ZW5lcik7XG5yZW1vdmVFdmVudChlbCwgXCJjbGlja1wiLCBsaXN0ZW5lcik7XG4qL1xuXG5mdW5jdGlvbiByZW1vdmVFdmVudChlbCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IFJHQiwgUkdCQSwgSFNMLCBIU0xBLCBDT0xPUl9NT0RFTFMsIEZVTkNUSU9OLCBQUk9QRVJUWSwgQVJSQVksIE9CSkVDVCwgU1RSSU5HLCBOVU1CRVIsIFVOREVGSU5FRCwgSVNfV0lORE9XLCBkb2MgYXMgZG9jdW1lbnQsIGdldENyb3NzQnJvd3NlclByb3BlcnR5LCBUUkFOU0ZPUk0sIEZJTFRFUiwgQU5JTUFUSU9OLCBLRVlGUkFNRVMsIE9QRU5fQ0xPU0VEX0NIQVJBQ1RFUlMsIFRJTllfTlVNLCBERUZBVUxUX1VOSVRfUFJFU0VUUywgY3V0SGV4LCBoZXhUb1JHQkEsIHRvRnVsbEhleCwgaHNsVG9SR0JBLCBzdHJpbmdUb1JHQkEsIGRvdCwgaXNVbmRlZmluZWQsIGlzT2JqZWN0LCBpc0FycmF5LCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRnVuY3Rpb24sIHNwbGl0VGV4dCwgc3BsaXRTcGFjZSwgc3BsaXRDb21tYSwgc3BsaXRCcmFja2V0LCBzcGxpdFVuaXQsIGNhbWVsaXplLCBkZWNhbWVsaXplLCB0b0FycmF5LCBub3csIGZpbmRJbmRleCwgZmluZExhc3RJbmRleCwgZmluZExhc3QsIGZpbmQsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUsIGdldEtleXMsIHNvcnRPcmRlcnMsIGNvbnZlcnRVbml0U2l6ZSwgYmV0d2VlbiwgY2hlY2tCb3VuZFNpemUsIGNhbGN1bGF0ZUJvdW5kU2l6ZSwgc3VtLCBhdmVyYWdlLCBnZXRSYWQsIGdldENlbnRlclBvaW50LCBnZXRTaGFwZURpcmVjdGlvbiwgZ2V0RGlzdCwgdGhyb3R0bGUsIHRocm90dGxlQXJyYXksIGNvdW50ZXIsIHJlcGxhY2VPbmNlLCAkLCBoYXNDbGFzcywgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzLCBmcm9tQ1NTLCBhZGRFdmVudCwgcmVtb3ZlRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2FnZW50XG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYWdlbnQuZ2l0XG52ZXJzaW9uOiAyLjMuMFxuKi9cbmZ1bmN0aW9uIHNvbWUoYXJyLCBjYWxsYmFjaykge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycltpXSwgaSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjYWxsYmFjaykge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycltpXSwgaSkpIHtcbiAgICAgIHJldHVybiBhcnJbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoYWdlbnQpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGFnZW50O1xuXG4gIGlmICh0eXBlb2YgdXNlckFnZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIgfHwgIW5hdmlnYXRvcikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBcIlwiO1xuICB9XG5cbiAgcmV0dXJuIHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gZXhlY1JlZ0V4cChwYXR0ZXJuLCB0ZXh0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgXCJnXCIpLmV4ZWModGV4dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gaGFzVXNlckFnZW50RGF0YSgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIgfHwgIW5hdmlnYXRvciB8fCAhbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdXNlckFnZW50RGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICB2YXIgYnJhbmRzID0gdXNlckFnZW50RGF0YS5icmFuZHMgfHwgdXNlckFnZW50RGF0YS51YUxpc3Q7XG4gIHJldHVybiAhIShicmFuZHMgJiYgYnJhbmRzLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBmaW5kVmVyc2lvbih2ZXJzaW9uVGVzdCwgdXNlckFnZW50KSB7XG4gIHZhciByZXN1bHQgPSBleGVjUmVnRXhwKFwiKFwiICsgdmVyc2lvblRlc3QgKyBcIikoKD86XFxcXC98XFxcXHN8OikoWzAtOXxcXFxcLnxfXSspKVwiLCB1c2VyQWdlbnQpO1xuICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0WzNdIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRWZXJzaW9uKHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSgvXy9nLCBcIi5cIik7XG59XG5mdW5jdGlvbiBmaW5kUHJlc2V0KHByZXNldHMsIHVzZXJBZ2VudCkge1xuICB2YXIgdXNlclByZXNldCA9IG51bGw7XG4gIHZhciB2ZXJzaW9uID0gXCItMVwiO1xuICBzb21lKHByZXNldHMsIGZ1bmN0aW9uIChwcmVzZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlY1JlZ0V4cChcIihcIiArIHByZXNldC50ZXN0ICsgXCIpKCg/OlxcXFwvfFxcXFxzfDopKFswLTl8XFxcXC58X10rKSk/XCIsIHVzZXJBZ2VudCk7XG5cbiAgICBpZiAoIXJlc3VsdCB8fCBwcmVzZXQuYnJhbmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB1c2VyUHJlc2V0ID0gcHJlc2V0O1xuICAgIHZlcnNpb24gPSByZXN1bHRbM10gfHwgXCItMVwiO1xuXG4gICAgaWYgKHByZXNldC52ZXJzaW9uQWxpYXMpIHtcbiAgICAgIHZlcnNpb24gPSBwcmVzZXQudmVyc2lvbkFsaWFzO1xuICAgIH0gZWxzZSBpZiAocHJlc2V0LnZlcnNpb25UZXN0KSB7XG4gICAgICB2ZXJzaW9uID0gZmluZFZlcnNpb24ocHJlc2V0LnZlcnNpb25UZXN0LnRvTG93ZXJDYXNlKCksIHVzZXJBZ2VudCkgfHwgdmVyc2lvbjtcbiAgICB9XG5cbiAgICB2ZXJzaW9uID0gY29udmVydFZlcnNpb24odmVyc2lvbik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByZXNldDogdXNlclByZXNldCxcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kUHJlc2V0QnJhbmQocHJlc2V0cywgYnJhbmRzKSB7XG4gIHZhciBicmFuZEluZm8gPSB7XG4gICAgYnJhbmQ6IFwiXCIsXG4gICAgdmVyc2lvbjogXCItMVwiXG4gIH07XG4gIHNvbWUocHJlc2V0cywgZnVuY3Rpb24gKHByZXNldCkge1xuICAgIHZhciByZXN1bHQgPSBmaW5kQnJhbmQoYnJhbmRzLCBwcmVzZXQpO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBicmFuZEluZm8uYnJhbmQgPSBwcmVzZXQuaWQ7XG4gICAgYnJhbmRJbmZvLnZlcnNpb24gPSBwcmVzZXQudmVyc2lvbkFsaWFzIHx8IHJlc3VsdC52ZXJzaW9uO1xuICAgIHJldHVybiBicmFuZEluZm8udmVyc2lvbiAhPT0gXCItMVwiO1xuICB9KTtcbiAgcmV0dXJuIGJyYW5kSW5mbztcbn1cbmZ1bmN0aW9uIGZpbmRCcmFuZChicmFuZHMsIHByZXNldCkge1xuICByZXR1cm4gZmluZChicmFuZHMsIGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBicmFuZCA9IF9hLmJyYW5kO1xuICAgIHJldHVybiBleGVjUmVnRXhwKFwiXCIgKyBwcmVzZXQudGVzdCwgYnJhbmQudG9Mb3dlckNhc2UoKSk7XG4gIH0pO1xufVxuXG52YXIgQlJPV1NFUl9QUkVTRVRTID0gW3tcbiAgdGVzdDogXCJwaGFudG9tanNcIixcbiAgaWQ6IFwicGhhbnRvbWpzXCJcbn0sIHtcbiAgdGVzdDogXCJ3aGFsZVwiLFxuICBpZDogXCJ3aGFsZVwiXG59LCB7XG4gIHRlc3Q6IFwiZWRnaW9zfGVkZ2V8ZWRnXCIsXG4gIGlkOiBcImVkZ2VcIlxufSwge1xuICB0ZXN0OiBcIm1zaWV8dHJpZGVudHx3aW5kb3dzIHBob25lXCIsXG4gIGlkOiBcImllXCIsXG4gIHZlcnNpb25UZXN0OiBcImllbW9iaWxlfG1zaWV8cnZcIlxufSwge1xuICB0ZXN0OiBcIm1pdWlicm93c2VyXCIsXG4gIGlkOiBcIm1pdWkgYnJvd3NlclwiXG59LCB7XG4gIHRlc3Q6IFwic2Ftc3VuZ2Jyb3dzZXJcIixcbiAgaWQ6IFwic2Ftc3VuZyBpbnRlcm5ldFwiXG59LCB7XG4gIHRlc3Q6IFwic2Ftc3VuZ1wiLFxuICBpZDogXCJzYW1zdW5nIGludGVybmV0XCIsXG4gIHZlcnNpb25UZXN0OiBcInZlcnNpb25cIlxufSwge1xuICB0ZXN0OiBcImNocm9tZXxjcmlvc1wiLFxuICBpZDogXCJjaHJvbWVcIlxufSwge1xuICB0ZXN0OiBcImZpcmVmb3h8Znhpb3NcIixcbiAgaWQ6IFwiZmlyZWZveFwiXG59LCB7XG4gIHRlc3Q6IFwiYW5kcm9pZFwiLFxuICBpZDogXCJhbmRyb2lkIGJyb3dzZXJcIixcbiAgdmVyc2lvblRlc3Q6IFwidmVyc2lvblwiXG59LCB7XG4gIHRlc3Q6IFwic2FmYXJpfGlwaG9uZXxpcGFkfGlwb2RcIixcbiAgaWQ6IFwic2FmYXJpXCIsXG4gIHZlcnNpb25UZXN0OiBcInZlcnNpb25cIlxufV07IC8vIGNocm9taXVtJ3MgZW5naW5lKGJsaW5rKSBpcyBiYXNlZCBvbiBhcHBsZXdlYmtpdCA1MzcuMzYuXG5cbnZhciBDSFJPTUlVTV9QUkVTRVRTID0gW3tcbiAgdGVzdDogXCIoPz0uKmFwcGxld2Via2l0Lyg1M1swLTddfDVbMC0yXXxbMC00XSkpKD89LipcXFxcc2Nocm9tZSlcIixcbiAgaWQ6IFwiY2hyb21lXCIsXG4gIHZlcnNpb25UZXN0OiBcImNocm9tZVwiXG59LCB7XG4gIHRlc3Q6IFwiY2hyb21pdW1cIixcbiAgaWQ6IFwiY2hyb21lXCJcbn0sIHtcbiAgdGVzdDogXCJ3aGFsZVwiLFxuICBpZDogXCJjaHJvbWVcIixcbiAgdmVyc2lvbkFsaWFzOiBcIi0xXCIsXG4gIGJyYW5kOiB0cnVlXG59XTtcbnZhciBXRUJLSVRfUFJFU0VUUyA9IFt7XG4gIHRlc3Q6IFwiYXBwbGV3ZWJraXRcIixcbiAgaWQ6IFwid2Via2l0XCIsXG4gIHZlcnNpb25UZXN0OiBcImFwcGxld2Via2l0fHNhZmFyaVwiXG59XTtcbnZhciBXRUJWSUVXX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcIig/PShpcGhvbmV8aXBhZCkpKD8hKC4qdmVyc2lvbikpXCIsXG4gIGlkOiBcIndlYnZpZXdcIlxufSwge1xuICB0ZXN0OiBcIig/PShhbmRyb2lkfGlwaG9uZXxpcGFkKSkoPz0uKihuYXZlcnxkYXVtfDsgd3YpKVwiLFxuICBpZDogXCJ3ZWJ2aWV3XCJcbn0sIHtcbiAgLy8gdGVzdCB3ZWJ2aWV3XG4gIHRlc3Q6IFwid2Vidmlld1wiLFxuICBpZDogXCJ3ZWJ2aWV3XCJcbn1dO1xudmFyIE9TX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcIndpbmRvd3MgcGhvbmVcIixcbiAgaWQ6IFwid2luZG93cyBwaG9uZVwiXG59LCB7XG4gIHRlc3Q6IFwid2luZG93cyAyMDAwXCIsXG4gIGlkOiBcIndpbmRvd1wiLFxuICB2ZXJzaW9uQWxpYXM6IFwiNS4wXCJcbn0sIHtcbiAgdGVzdDogXCJ3aW5kb3dzIG50XCIsXG4gIGlkOiBcIndpbmRvd1wiXG59LCB7XG4gIHRlc3Q6IFwiaXBob25lfGlwYWR8aXBvZFwiLFxuICBpZDogXCJpb3NcIixcbiAgdmVyc2lvblRlc3Q6IFwiaXBob25lIG9zfGNwdSBvc1wiXG59LCB7XG4gIHRlc3Q6IFwibWFjIG9zIHhcIixcbiAgaWQ6IFwibWFjXCJcbn0sIHtcbiAgdGVzdDogXCJhbmRyb2lkXCIsXG4gIGlkOiBcImFuZHJvaWRcIlxufSwge1xuICB0ZXN0OiBcInRpemVuXCIsXG4gIGlkOiBcInRpemVuXCJcbn0sIHtcbiAgdGVzdDogXCJ3ZWJvc3x3ZWIwc1wiLFxuICBpZDogXCJ3ZWJvc1wiXG59XTtcblxuZnVuY3Rpb24gcGFyc2VVc2VyQWdlbnREYXRhKG9zRGF0YSkge1xuICB2YXIgdXNlckFnZW50RGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICB2YXIgYnJhbmRzID0gKHVzZXJBZ2VudERhdGEudWFMaXN0IHx8IHVzZXJBZ2VudERhdGEuYnJhbmRzKS5zbGljZSgpO1xuICB2YXIgaXNNb2JpbGUgPSB1c2VyQWdlbnREYXRhLm1vYmlsZSB8fCBmYWxzZTtcbiAgdmFyIGZpcnN0QnJhbmQgPSBicmFuZHNbMF07XG4gIHZhciBicm93c2VyID0ge1xuICAgIG5hbWU6IGZpcnN0QnJhbmQuYnJhbmQsXG4gICAgdmVyc2lvbjogZmlyc3RCcmFuZC52ZXJzaW9uLFxuICAgIG1ham9yVmVyc2lvbjogLTEsXG4gICAgd2Via2l0OiBmYWxzZSxcbiAgICB3ZWJraXRWZXJzaW9uOiBcIi0xXCIsXG4gICAgY2hyb21pdW06IGZhbHNlLFxuICAgIGNocm9taXVtVmVyc2lvbjogXCItMVwiLFxuICAgIHdlYnZpZXc6ICEhZmluZFByZXNldEJyYW5kKFdFQlZJRVdfUFJFU0VUUywgYnJhbmRzKS5icmFuZFxuICB9O1xuICB2YXIgb3MgPSB7XG4gICAgbmFtZTogXCJ1bmtub3duXCIsXG4gICAgdmVyc2lvbjogXCItMVwiLFxuICAgIG1ham9yVmVyc2lvbjogLTFcbiAgfTtcbiAgYnJvd3Nlci53ZWJraXQgPSAhYnJvd3Nlci5jaHJvbWl1bSAmJiBzb21lKFdFQktJVF9QUkVTRVRTLCBmdW5jdGlvbiAocHJlc2V0KSB7XG4gICAgcmV0dXJuIGZpbmRCcmFuZChicmFuZHMsIHByZXNldCk7XG4gIH0pO1xuICB2YXIgY2hyb21pdW1CcmFuZCA9IGZpbmRQcmVzZXRCcmFuZChDSFJPTUlVTV9QUkVTRVRTLCBicmFuZHMpO1xuICBicm93c2VyLmNocm9taXVtID0gISFjaHJvbWl1bUJyYW5kLmJyYW5kO1xuICBicm93c2VyLmNocm9taXVtVmVyc2lvbiA9IGNocm9taXVtQnJhbmQudmVyc2lvbjtcblxuICBpZiAoIWJyb3dzZXIuY2hyb21pdW0pIHtcbiAgICB2YXIgd2Via2l0QnJhbmQgPSBmaW5kUHJlc2V0QnJhbmQoV0VCS0lUX1BSRVNFVFMsIGJyYW5kcyk7XG4gICAgYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdEJyYW5kLmJyYW5kO1xuICAgIGJyb3dzZXIud2Via2l0VmVyc2lvbiA9IHdlYmtpdEJyYW5kLnZlcnNpb247XG4gIH1cblxuICBpZiAob3NEYXRhKSB7XG4gICAgdmFyIHBsYXRmb3JtXzEgPSBvc0RhdGEucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgcmVzdWx0ID0gZmluZChPU19QUkVTRVRTLCBmdW5jdGlvbiAocHJlc2V0KSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIlwiICsgcHJlc2V0LnRlc3QsIFwiZ1wiKS5leGVjKHBsYXRmb3JtXzEpO1xuICAgIH0pO1xuICAgIG9zLm5hbWUgPSByZXN1bHQgPyByZXN1bHQuaWQgOiBwbGF0Zm9ybV8xO1xuICAgIG9zLnZlcnNpb24gPSBvc0RhdGEucGxhdGZvcm1WZXJzaW9uO1xuICB9XG5cbiAgdmFyIGJyb3dzZXJCcmFuZCA9IGZpbmRQcmVzZXRCcmFuZChCUk9XU0VSX1BSRVNFVFMsIGJyYW5kcyk7XG5cbiAgaWYgKGJyb3dzZXJCcmFuZC5icmFuZCkge1xuICAgIGJyb3dzZXIubmFtZSA9IGJyb3dzZXJCcmFuZC5icmFuZDtcbiAgICBicm93c2VyLnZlcnNpb24gPSBvc0RhdGEgPyBvc0RhdGEudWFGdWxsVmVyc2lvbiA6IGJyb3dzZXJCcmFuZC52ZXJzaW9uO1xuICB9XG5cbiAgaWYgKG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gXCJMaW51eCBhcm12OGxcIikge1xuICAgIG9zLm5hbWUgPSBcImFuZHJvaWRcIjtcbiAgfSBlbHNlIGlmIChicm93c2VyLndlYmtpdCkge1xuICAgIG9zLm5hbWUgPSBpc01vYmlsZSA/IFwiaW9zXCIgOiBcIm1hY1wiO1xuICB9XG5cbiAgaWYgKG9zLm5hbWUgPT09IFwiaW9zXCIgJiYgYnJvd3Nlci53ZWJ2aWV3KSB7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gXCItMVwiO1xuICB9XG5cbiAgb3MudmVyc2lvbiA9IGNvbnZlcnRWZXJzaW9uKG9zLnZlcnNpb24pO1xuICBicm93c2VyLnZlcnNpb24gPSBjb252ZXJ0VmVyc2lvbihicm93c2VyLnZlcnNpb24pO1xuICBvcy5tYWpvclZlcnNpb24gPSBwYXJzZUludChvcy52ZXJzaW9uLCAxMCk7XG4gIGJyb3dzZXIubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQoYnJvd3Nlci52ZXJzaW9uLCAxMCk7XG4gIHJldHVybiB7XG4gICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICBvczogb3MsXG4gICAgaXNNb2JpbGU6IGlzTW9iaWxlLFxuICAgIGlzSGludHM6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVc2VyQWdlbnQodXNlckFnZW50KSB7XG4gIHZhciBuZXh0QWdlbnQgPSBnZXRVc2VyQWdlbnQodXNlckFnZW50KTtcbiAgdmFyIGlzTW9iaWxlID0gISEvbW9iaS9nLmV4ZWMobmV4dEFnZW50KTtcbiAgdmFyIGJyb3dzZXIgPSB7XG4gICAgbmFtZTogXCJ1bmtub3duXCIsXG4gICAgdmVyc2lvbjogXCItMVwiLFxuICAgIG1ham9yVmVyc2lvbjogLTEsXG4gICAgd2VidmlldzogISFmaW5kUHJlc2V0KFdFQlZJRVdfUFJFU0VUUywgbmV4dEFnZW50KS5wcmVzZXQsXG4gICAgY2hyb21pdW06IGZhbHNlLFxuICAgIGNocm9taXVtVmVyc2lvbjogXCItMVwiLFxuICAgIHdlYmtpdDogZmFsc2UsXG4gICAgd2Via2l0VmVyc2lvbjogXCItMVwiXG4gIH07XG4gIHZhciBvcyA9IHtcbiAgICBuYW1lOiBcInVua25vd25cIixcbiAgICB2ZXJzaW9uOiBcIi0xXCIsXG4gICAgbWFqb3JWZXJzaW9uOiAtMVxuICB9O1xuXG4gIHZhciBfYSA9IGZpbmRQcmVzZXQoQlJPV1NFUl9QUkVTRVRTLCBuZXh0QWdlbnQpLFxuICAgICAgYnJvd3NlclByZXNldCA9IF9hLnByZXNldCxcbiAgICAgIGJyb3dzZXJWZXJzaW9uID0gX2EudmVyc2lvbjtcblxuICB2YXIgX2IgPSBmaW5kUHJlc2V0KE9TX1BSRVNFVFMsIG5leHRBZ2VudCksXG4gICAgICBvc1ByZXNldCA9IF9iLnByZXNldCxcbiAgICAgIG9zVmVyc2lvbiA9IF9iLnZlcnNpb247XG5cbiAgdmFyIGNocm9taXVtUHJlc2V0ID0gZmluZFByZXNldChDSFJPTUlVTV9QUkVTRVRTLCBuZXh0QWdlbnQpO1xuICBicm93c2VyLmNocm9taXVtID0gISFjaHJvbWl1bVByZXNldC5wcmVzZXQ7XG4gIGJyb3dzZXIuY2hyb21pdW1WZXJzaW9uID0gY2hyb21pdW1QcmVzZXQudmVyc2lvbjtcblxuICBpZiAoIWJyb3dzZXIuY2hyb21pdW0pIHtcbiAgICB2YXIgd2Via2l0UHJlc2V0ID0gZmluZFByZXNldChXRUJLSVRfUFJFU0VUUywgbmV4dEFnZW50KTtcbiAgICBicm93c2VyLndlYmtpdCA9ICEhd2Via2l0UHJlc2V0LnByZXNldDtcbiAgICBicm93c2VyLndlYmtpdFZlcnNpb24gPSB3ZWJraXRQcmVzZXQudmVyc2lvbjtcbiAgfVxuXG4gIGlmIChvc1ByZXNldCkge1xuICAgIG9zLm5hbWUgPSBvc1ByZXNldC5pZDtcbiAgICBvcy52ZXJzaW9uID0gb3NWZXJzaW9uO1xuICAgIG9zLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KG9zVmVyc2lvbiwgMTApO1xuICB9XG5cbiAgaWYgKGJyb3dzZXJQcmVzZXQpIHtcbiAgICBicm93c2VyLm5hbWUgPSBicm93c2VyUHJlc2V0LmlkO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IGJyb3dzZXJWZXJzaW9uO1xuXG4gICAgaWYgKGJyb3dzZXIud2VidmlldyAmJiBvcy5uYW1lID09PSBcImlvc1wiICYmIGJyb3dzZXIubmFtZSAhPT0gXCJzYWZhcmlcIikge1xuICAgICAgYnJvd3Nlci53ZWJ2aWV3ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYnJvd3Nlci5tYWpvclZlcnNpb24gPSBwYXJzZUludChicm93c2VyLnZlcnNpb24sIDEwKTtcbiAgcmV0dXJuIHtcbiAgICBicm93c2VyOiBicm93c2VyLFxuICAgIG9zOiBvcyxcbiAgICBpc01vYmlsZTogaXNNb2JpbGUsXG4gICAgaXNIaW50czogZmFsc2VcbiAgfTtcbn1cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGVnLmFnZW50XG4gKi9cblxuLyoqXG4qIEV4dHJhY3RzIGFjY3VhdGUgYnJvd3NlciBhbmQgb3BlcmF0aW5nIHN5c3RlbSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyIGFnZW50IHN0cmluZyBvciBjbGllbnQgaGludHMuXG4qIEBrbyDsnKDsoIAg7JeQ7J207KCE7Yq4IOusuOyekOyXtCDrmJDripQgY2xpZW50IGhpbnRz7JeQ7IScIOygle2Zle2VnCDruIzrnbzsmrDsoIDsmYAg7Jq07JiB7LK07KCcIOygleuztOulvCDstpTstpztlZzri6QuXG4qIEBmdW5jdGlvbiBlZy5hZ2VudCNnZXRBY2N1cmF0ZUFnZW50XG4qIEBwYXJhbSAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGdldCB0aGUgYWNjdWF0ZSBhZ2VudCA8a28+7KCV7ZmV7ZWcIOyXkOydtOyghO2KuOulvCDqsIDsoLjsmKTquLAg7JyE7ZWcIGNhbGxiYWNrIO2VqOyImDwva28+XG4qIEByZXR1cm4gLSBnZXQgdGhlIGFjY3VhdGUgYWdlbnQgcHJvbWlzZS4gSWYgUHJvbWlzZSBhcmUgbm90IHN1cHBvcnRlZCwgbnVsbCBpcyByZXR1cm5lZC4gPGtvPiDsoJXtmZXtlZwg7JeQ7J207KCE7Yq4IHByb21pc2Xrpbwg6rCA7KC47Jio64ukLiBQcm9taXNl66W8IOyngOybkCDtlZjsp4Ag7JWK64qUIOqyveyasCwgbnVsbOydhCDrsJjtmZjtlZzri6QuIDwva28+XG4qIEBleGFtcGxlXG5pbXBvcnQgeyBnZXRBY2N1cmF0ZUFnZW50IH0gZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG4vLyBlZy5hZ2VudC5nZXRBY2N1cmF0ZUFnZW50KClcbmdldEFjY3VyYXRlQWdlbnQoKS50aGVuKGFnZW50ID0+IHtcbiAgIGNvbnN0IHsgb3MsIGJyb3dzZXIsIGlzTW9iaWxlIH0gPSBhZ2VudDtcbn0pO1xuZ2V0QWNjdXJhdGVBZ2VudChhZ2VudCA9PiB7XG4gICAgY29uc3QgeyBvcywgYnJvd3NlciwgaXNNb2JpbGUgfSA9IGFnZW50O1xufSk7XG4qL1xuXG5mdW5jdGlvbiBnZXRBY2N1cmF0ZUFnZW50KGNhbGxiYWNrKSB7XG4gIGlmIChoYXNVc2VyQWdlbnREYXRhKCkpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuZ2V0SGlnaEVudHJvcHlWYWx1ZXMoW1wiYXJjaGl0ZWN0dXJlXCIsIFwibW9kZWxcIiwgXCJwbGF0Zm9ybVwiLCBcInBsYXRmb3JtVmVyc2lvblwiLCBcInVhRnVsbFZlcnNpb25cIl0pLnRoZW4oZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHZhciBhZ2VudEluZm8gPSBwYXJzZVVzZXJBZ2VudERhdGEoaW5mbyk7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhhZ2VudEluZm8pO1xuICAgICAgcmV0dXJuIGFnZW50SW5mbztcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGxiYWNrICYmIGNhbGxiYWNrKGFnZW50KCkpO1xuXG4gIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUHJvbWlzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhZ2VudCgpKTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYnJvd3NlciBhbmQgb3BlcmF0aW5nIHN5c3RlbSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyIGFnZW50IHN0cmluZy5cbiAqIEBrbyDsnKDsoIAg7JeQ7J207KCE7Yq4IOusuOyekOyXtOyXkOyEnCDruIzrnbzsmrDsoIDsmYAg7Jq07JiB7LK07KCcIOygleuztOulvCDstpTstpztlZzri6QuXG4gKiBAZnVuY3Rpb24gZWcuYWdlbnQjYWdlbnRcbiAqIEBwYXJhbSAtIHVzZXIgYWdlbnQgc3RyaW5nIHRvIHBhcnNlIDxrbz7tjIzsi7HtlaAg7Jyg7KCA7JeQ7J207KCE7Yq4IOusuOyekOyXtDwva28+XG4gKiBAcmV0dXJuIC0gYWdlbnQgSW5mbyA8a28+IOyXkOydtOyghO2KuCDsoJXrs7QgPC9rbz5cbiAqIEBleGFtcGxlXG5pbXBvcnQgYWdlbnQgZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG4vLyBlZy5hZ2VudCgpO1xuY29uc3QgeyBvcywgYnJvd3NlciwgaXNNb2JpbGUgfSA9IGFnZW50KCk7XG4gKi9cblxuZnVuY3Rpb24gYWdlbnQodXNlckFnZW50KSB7XG4gIGlmICh0eXBlb2YgdXNlckFnZW50ID09PSBcInVuZGVmaW5lZFwiICYmIGhhc1VzZXJBZ2VudERhdGEoKSkge1xuICAgIHJldHVybiBwYXJzZVVzZXJBZ2VudERhdGEoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VVc2VyQWdlbnQodXNlckFnZW50KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhZ2VudDtcbmV4cG9ydCB7IGdldEFjY3VyYXRlQWdlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZW50LmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvY2hpbGRyZW4tZGlmZmVyXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWNoaWxkcmVuLWRpZmZlclxudmVyc2lvbjogMS4wLjFcbiovXG5pbXBvcnQgTGlzdERpZmZlciwgeyBkaWZmIGFzIGRpZmYkMSB9IGZyb20gJ0BlZ2pzL2xpc3QtZGlmZmVyJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbi8qXG5lZ2pzLWNoaWxkcmVuLWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIGZpbmRLZXlDYWxsYmFjayA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoaWxkcmVuQ291bnQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIGVsLl9fRElGRl9LRVlfXyB8fCAoZWwuX19ESUZGX0tFWV9fID0gKytjaGlsZHJlbkNvdW50KTtcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBBIG1vZHVsZSB0aGF0IGNoZWNrcyBkaWZmIHdoZW4gY2hpbGQgYXJlIGFkZGVkLCByZW1vdmVkLCBvciBjaGFuZ2VkIC5cbiAqIEBrbyDsnpDsi50g64W465Oc65Ok7JeQ7IScIOyekOyLnSDrhbjrk5zqsIAg7LaU6rCA65CY6rGw64KYIOyCreygnOuQmOqxsOuCmCDsiJzshJzqsIAg67OA6rK965CcIOyCrO2VreydhCDssrTtgaztlZjripQg66qo65OI7J6F64uI64ukLlxuICogQG1lbWJlcm9mIGVnXG4gKiBAZXh0ZW5kcyBlZy5MaXN0RGlmZmVyXG4gKi9cblxudmFyIENoaWxkcmVuRGlmZmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKENoaWxkcmVuRGlmZmVyLCBfc3VwZXIpO1xuICAvKipcbiAgICogQHBhcmFtIC0gSW5pdGlhbGl6aW5nIENoaWxkcmVuIDxrbz4g7LSI6riwIOyEpOygle2VoCDsnpDsi50g64W465Oc65OkPC9rbz5cbiAgICovXG5cblxuICBmdW5jdGlvbiBDaGlsZHJlbkRpZmZlcihsaXN0KSB7XG4gICAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgICAgbGlzdCA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBsaXN0LCBmaW5kS2V5Q2FsbGJhY2spIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gQ2hpbGRyZW5EaWZmZXI7XG59KExpc3REaWZmZXIpO1xuXG4vKlxuZWdqcy1jaGlsZHJlbi1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbi8qKlxuICpcbiAqIEBtZW1iZXJvZiBlZy5DaGlsZHJlbkRpZmZlclxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0gLSBQcmV2aW91cyBMaXN0IDxrbz4g7J207KCEIOuqqeuhnSA8L2tvPlxuICogQHBhcmFtIC0gTGlzdCB0byBVcGRhdGUgPGtvPiDsl4XrjbDsnbTtirgg7ZWgIOuqqeuhnSA8L2tvPlxuICogQHJldHVybiAtIFJldHVybnMgdGhlIGRpZmYgYmV0d2VlbiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgPGtvPiBgcHJldkxpc3Rg7JmAIGBsaXN0YOydmCDri6Trpbgg7KCQ7J2EIOuwmO2ZmO2VnOuLpC48L2tvPlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGRpZmYgfSBmcm9tIFwiQGVnanMvY2hpbGRyZW4tZGlmZmVyXCI7XG4gKiAvLyBzY3JpcHQgPT4gZWcuQ2hpbGRyZW5EaWZmZXIuZGlmZlxuICogY29uc3QgcmVzdWx0ID0gZGlmZihbMCwgMSwgMiwgMywgNCwgNV0sIFs3LCA4LCAwLCA0LCAzLCA2LCAyLCAxXSk7XG4gKiAvLyBMaXN0IGJlZm9yZSB1cGRhdGVcbiAqIC8vIFsxLCAyLCAzLCA0LCA1XVxuICogY29uc29sZS5sb2cocmVzdWx0LnByZXZMaXN0KTtcbiAqIC8vIFVwZGF0ZWQgbGlzdFxuICogLy8gWzQsIDMsIDYsIDIsIDFdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQubGlzdCk7XG4gKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgYWRkZWQgdG8gYGxpc3RgXG4gKiAvLyBbMCwgMSwgNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5hZGRlZCk7XG4gKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgcmVtb3ZlZCBpbiBgcHJldkxpc3RgXG4gKiAvLyBbNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5yZW1vdmVkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB3aXRoIGRpZmZlcmVudCBpbmRleGVzIGZyb20gYHByZXZMaXN0YCBhbmQgYGxpc3RgXG4gKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuY2hhbmdlZCk7XG4gKiAvLyBUaGUgc3Vic2V0IG9mIGBjaGFuZ2VkYCBhbmQgYW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdGhhdCBtb3ZlZCBkYXRhIGRpcmVjdGx5LiBJbmRpY2F0ZSBhbiBhcnJheSBvZiBhYnNvbHV0ZSBpbmRleCBwYWlycyBvZiBgb3JkZXJlZGAuKEZvcm1hdHRlZCBieTogQXJyYXk8W2luZGV4IG9mIHByZXZMaXN0LCBpbmRleCBvZiBsaXN0XT4pXG4gKiAvLyBbWzQsIDNdLCBbMywgNF0sIFsyLCA2XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5wdXJlQ2hhbmdlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyB0byBiZSBgb3JkZXJlZGAgdGhhdCBjYW4gc3luY2hyb25pemUgYGxpc3RgIGJlZm9yZSBhZGRpbmcgZGF0YS4gKEZvcm1hdHRlZCBieTogQXJyYXk8W3ByZXZJbmRleCwgbmV4dEluZGV4XT4pXG4gKiAvLyBbWzQsIDFdLCBbNCwgMl0sIFs0LCAzXV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5vcmRlcmVkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB0aGF0IGhhdmUgbm90IGJlZW4gYWRkZWQvcmVtb3ZlZCBzbyBkYXRhIGlzIHByZXNlcnZlZFxuICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICogY29uc29sZS5sb2cocmVzdWx0Lm1haW50YWluZWQpO1xuICovXG5cbmZ1bmN0aW9uIGRpZmYocHJldkxpc3QsIGxpc3QpIHtcbiAgcmV0dXJuIGRpZmYkMShwcmV2TGlzdCwgbGlzdCwgZmluZEtleUNhbGxiYWNrKTtcbn1cblxuLypcbmVnanMtY2hpbGRyZW4tZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG5cbmV4cG9ydCBkZWZhdWx0IENoaWxkcmVuRGlmZmVyO1xuZXhwb3J0IHsgZGlmZiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hpbGRyZW4tZGlmZmVyLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvbGlzdC1kaWZmZXJcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtbGlzdC1kaWZmZXJcbnZlcnNpb246IDEuMC4wXG4qL1xuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBQb2x5TWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9seU1hcCgpIHtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBQb2x5TWFwLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbdGhpcy5rZXlzLmluZGV4T2Yoa2V5KV07XG4gIH07XG5cbiAgX19wcm90by5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICB2YXIgcHJldkluZGV4ID0ga2V5cy5pbmRleE9mKGtleSk7XG4gICAgdmFyIGluZGV4ID0gcHJldkluZGV4ID09PSAtMSA/IGtleXMubGVuZ3RoIDogcHJldkluZGV4O1xuICAgIGtleXNbaW5kZXhdID0ga2V5O1xuICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gUG9seU1hcDtcbn0oKTtcblxuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBIYXNoTWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGFzaE1hcCgpIHtcbiAgICB0aGlzLm9iamVjdCA9IHt9O1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBIYXNoTWFwLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3Rba2V5XTtcbiAgfTtcblxuICBfX3Byb3RvLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5vYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBIYXNoTWFwO1xufSgpO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIFNVUFBPUlRfTUFQID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIExpbmsgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5rKCkge31cblxuICB2YXIgX19wcm90byA9IExpbmsucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uIChwcmV2TGluaywgbmV4dExpbmspIHtcbiAgICB0aGlzLnByZXYgPSBwcmV2TGluaztcbiAgICB0aGlzLm5leHQgPSBuZXh0TGluaztcbiAgICBwcmV2TGluayAmJiAocHJldkxpbmsubmV4dCA9IHRoaXMpO1xuICAgIG5leHRMaW5rICYmIChuZXh0TGluay5wcmV2ID0gdGhpcyk7XG4gIH07XG5cbiAgX19wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEluIGRvdWJsZSBsaW5rZWQgbGlzdCwgZGljb25uZWN0IHRoZSBpbnRlcmNvbm5lY3RlZCByZWxhdGlvbnNoaXAuXG4gICAgdmFyIHByZXZMaW5rID0gdGhpcy5wcmV2O1xuICAgIHZhciBuZXh0TGluayA9IHRoaXMubmV4dDtcbiAgICBwcmV2TGluayAmJiAocHJldkxpbmsubmV4dCA9IG5leHRMaW5rKTtcbiAgICBuZXh0TGluayAmJiAobmV4dExpbmsucHJldiA9IHByZXZMaW5rKTtcbiAgfTtcblxuICBfX3Byb3RvLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaW5rID0gdGhpcztcbiAgICB2YXIgaW5kZXggPSAtMTtcblxuICAgIHdoaWxlIChsaW5rKSB7XG4gICAgICBsaW5rID0gbGluay5wcmV2O1xuICAgICAgKytpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgcmV0dXJuIExpbms7XG59KCk7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG5cbmZ1bmN0aW9uIG9yZGVyQ2hhbmdlZChjaGFuZ2VkLCBmaXhlZCkge1xuICAvLyBJdCBpcyByb3VnaGx5IGluIHRoZSBvcmRlciBvZiB0aGVzZSBleGFtcGxlcy5cbiAgLy8gNCwgNiwgMCwgMiwgMSwgMywgNSwgN1xuICB2YXIgZnJvbUxpbmtzID0gW107IC8vIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDdcblxuICB2YXIgdG9MaW5rcyA9IFtdO1xuICBjaGFuZ2VkLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGZyb20gPSBfYVswXSxcbiAgICAgICAgdG8gPSBfYVsxXTtcbiAgICB2YXIgbGluayA9IG5ldyBMaW5rKCk7XG4gICAgZnJvbUxpbmtzW2Zyb21dID0gbGluaztcbiAgICB0b0xpbmtzW3RvXSA9IGxpbms7XG4gIH0pOyAvLyBgZnJvbUxpbmtzYCBhcmUgY29ubmVjdGVkIHRvIGVhY2ggb3RoZXIgYnkgZG91YmxlIGxpbmtlZCBsaXN0LlxuXG4gIGZyb21MaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rLCBpKSB7XG4gICAgbGluay5jb25uZWN0KGZyb21MaW5rc1tpIC0gMV0pO1xuICB9KTtcbiAgcmV0dXJuIGNoYW5nZWQuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgcmV0dXJuICFmaXhlZFtpXTtcbiAgfSkubWFwKGZ1bmN0aW9uIChfYSwgaSkge1xuICAgIHZhciBmcm9tID0gX2FbMF0sXG4gICAgICAgIHRvID0gX2FbMV07XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuXG4gICAgdmFyIGZyb21MaW5rID0gZnJvbUxpbmtzW2Zyb21dO1xuICAgIHZhciB0b0xpbmsgPSB0b0xpbmtzW3RvIC0gMV07XG4gICAgdmFyIGZyb21JbmRleCA9IGZyb21MaW5rLmdldEluZGV4KCk7IC8vIERpc2Nvbm5lY3QgdGhlIGxpbmsgY29ubmVjdGVkIHRvIGBmcm9tTGlua2AuXG5cbiAgICBmcm9tTGluay5kaXNjb25uZWN0KCk7IC8vIENvbm5lY3QgYGZyb21MaW5rYCB0byB0aGUgcmlnaHQgb2YgYHRvTGlua2AuXG5cbiAgICBpZiAoIXRvTGluaykge1xuICAgICAgZnJvbUxpbmsuY29ubmVjdCh1bmRlZmluZWQsIGZyb21MaW5rc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21MaW5rLmNvbm5lY3QodG9MaW5rLCB0b0xpbmsubmV4dCk7XG4gICAgfVxuXG4gICAgdmFyIHRvSW5kZXggPSBmcm9tTGluay5nZXRJbmRleCgpO1xuICAgIHJldHVybiBbZnJvbUluZGV4LCB0b0luZGV4XTtcbiAgfSk7XG59XG5cbnZhciBSZXN1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXN1bHQocHJldkxpc3QsIGxpc3QsIGFkZGVkLCByZW1vdmVkLCBjaGFuZ2VkLCBtYWludGFpbmVkLCBjaGFuZ2VkQmVmb3JlQWRkZWQsIGZpeGVkKSB7XG4gICAgdGhpcy5wcmV2TGlzdCA9IHByZXZMaXN0O1xuICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgdGhpcy5hZGRlZCA9IGFkZGVkO1xuICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgdGhpcy5jaGFuZ2VkID0gY2hhbmdlZDtcbiAgICB0aGlzLm1haW50YWluZWQgPSBtYWludGFpbmVkO1xuICAgIHRoaXMuY2hhbmdlZEJlZm9yZUFkZGVkID0gY2hhbmdlZEJlZm9yZUFkZGVkO1xuICAgIHRoaXMuZml4ZWQgPSBmaXhlZDtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gUmVzdWx0LnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwib3JkZXJlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuY2FjaGVPcmRlcmVkKSB7XG4gICAgICAgIHRoaXMuY2FjdWxhdGVPcmRlcmVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlT3JkZXJlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwdXJlQ2hhbmdlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuY2FjaGVQdXJlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLmNhY3VsYXRlT3JkZXJlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVB1cmVDaGFuZ2VkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG5cbiAgX19wcm90by5jYWN1bGF0ZU9yZGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yZGVyZWQgPSBvcmRlckNoYW5nZWQodGhpcy5jaGFuZ2VkQmVmb3JlQWRkZWQsIHRoaXMuZml4ZWQpO1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5jaGFuZ2VkO1xuICAgIHZhciBwdXJlQ2hhbmdlZCA9IFtdO1xuICAgIHRoaXMuY2FjaGVPcmRlcmVkID0gb3JkZXJlZC5maWx0ZXIoZnVuY3Rpb24gKF9hLCBpKSB7XG4gICAgICB2YXIgZnJvbSA9IF9hWzBdLFxuICAgICAgICAgIHRvID0gX2FbMV07XG4gICAgICB2YXIgX2IgPSBjaGFuZ2VkW2ldLFxuICAgICAgICAgIGZyb21CZWZvcmUgPSBfYlswXSxcbiAgICAgICAgICB0b0JlZm9yZSA9IF9iWzFdO1xuXG4gICAgICBpZiAoZnJvbSAhPT0gdG8pIHtcbiAgICAgICAgcHVyZUNoYW5nZWQucHVzaChbZnJvbUJlZm9yZSwgdG9CZWZvcmVdKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jYWNoZVB1cmVDaGFuZ2VkID0gcHVyZUNoYW5nZWQ7XG4gIH07XG5cbiAgcmV0dXJuIFJlc3VsdDtcbn0oKTtcblxuLyoqXG4gKlxuICogQG1lbWJlcm9mIGVnLkxpc3REaWZmZXJcbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIC0gUHJldmlvdXMgTGlzdCA8a28+IOydtOyghCDrqqnroZ0gPC9rbz5cbiAqIEBwYXJhbSAtIExpc3QgdG8gVXBkYXRlIDxrbz4g7JeF642w7J207Yq4IO2VoCDrqqnroZ0gPC9rbz5cbiAqIEBwYXJhbSAtIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyB0aGUga2V5IG9mIHRoZSBpdGVtLiA8a28+IOyVhOydtO2FnOydmCDtgqTrpbwg67CY7ZmY7ZWY64qUIOy9nOuwsSDtlajsiJjsnoXri4jri6QuPC9rbz5cbiAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBkaWZmIGJldHdlZW4gYHByZXZMaXN0YCBhbmQgYGxpc3RgIDxrbz4gYHByZXZMaXN0YOyZgCBgbGlzdGDsnZgg64uk66W4IOygkOydhCDrsJjtmZjtlZzri6QuPC9rbz5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBkaWZmIH0gZnJvbSBcIkBlZ2pzL2xpc3QtZGlmZmVyXCI7XG4gKiAvLyBzY3JpcHQgPT4gZWcuTGlzdERpZmZlci5kaWZmXG4gKiBjb25zdCByZXN1bHQgPSBkaWZmKFswLCAxLCAyLCAzLCA0LCA1XSwgWzcsIDgsIDAsIDQsIDMsIDYsIDIsIDFdLCBlID0+IGUpO1xuICogLy8gTGlzdCBiZWZvcmUgdXBkYXRlXG4gKiAvLyBbMSwgMiwgMywgNCwgNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5wcmV2TGlzdCk7XG4gKiAvLyBVcGRhdGVkIGxpc3RcbiAqIC8vIFs0LCAzLCA2LCAyLCAxXVxuICogY29uc29sZS5sb2cocmVzdWx0Lmxpc3QpO1xuICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIGFkZGVkIHRvIGBsaXN0YFxuICogLy8gWzAsIDEsIDVdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuYWRkZWQpO1xuICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIHJlbW92ZWQgaW4gYHByZXZMaXN0YFxuICogLy8gWzVdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQucmVtb3ZlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgd2l0aCBkaWZmZXJlbnQgaW5kZXhlcyBmcm9tIGBwcmV2TGlzdGAgYW5kIGBsaXN0YFxuICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICogY29uc29sZS5sb2cocmVzdWx0LmNoYW5nZWQpO1xuICogLy8gVGhlIHN1YnNldCBvZiBgY2hhbmdlZGAgYW5kIGFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRoYXQgbW92ZWQgZGF0YSBkaXJlY3RseS4gSW5kaWNhdGUgYW4gYXJyYXkgb2YgYWJzb2x1dGUgaW5kZXggcGFpcnMgb2YgYG9yZGVyZWRgLihGb3JtYXR0ZWQgYnk6IEFycmF5PFtpbmRleCBvZiBwcmV2TGlzdCwgaW5kZXggb2YgbGlzdF0+KVxuICogLy8gW1s0LCAzXSwgWzMsIDRdLCBbMiwgNl1dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQucHVyZUNoYW5nZWQpO1xuICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdG8gYmUgYG9yZGVyZWRgIHRoYXQgY2FuIHN5bmNocm9uaXplIGBsaXN0YCBiZWZvcmUgYWRkaW5nIGRhdGEuIChGb3JtYXR0ZWQgYnk6IEFycmF5PFtwcmV2SW5kZXgsIG5leHRJbmRleF0+KVxuICogLy8gW1s0LCAxXSwgWzQsIDJdLCBbNCwgM11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQub3JkZXJlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgdGhhdCBoYXZlIG5vdCBiZWVuIGFkZGVkL3JlbW92ZWQgc28gZGF0YSBpcyBwcmVzZXJ2ZWRcbiAqIC8vIFtbMCwgMl0sIFs0LCAzXSwgWzMsIDRdLCBbMiwgNl0sIFsxLCA3XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5tYWludGFpbmVkKTtcbiAqL1xuXG5mdW5jdGlvbiBkaWZmKHByZXZMaXN0LCBsaXN0LCBmaW5kS2V5Q2FsbGJhY2spIHtcbiAgdmFyIG1hcENsYXNzID0gU1VQUE9SVF9NQVAgPyBNYXAgOiBmaW5kS2V5Q2FsbGJhY2sgPyBIYXNoTWFwIDogUG9seU1hcDtcblxuICB2YXIgY2FsbGJhY2sgPSBmaW5kS2V5Q2FsbGJhY2sgfHwgZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfTtcblxuICB2YXIgYWRkZWQgPSBbXTtcbiAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgdmFyIG1haW50YWluZWQgPSBbXTtcbiAgdmFyIHByZXZLZXlzID0gcHJldkxpc3QubWFwKGNhbGxiYWNrKTtcbiAgdmFyIGtleXMgPSBsaXN0Lm1hcChjYWxsYmFjayk7XG4gIHZhciBwcmV2S2V5TWFwID0gbmV3IG1hcENsYXNzKCk7XG4gIHZhciBrZXlNYXAgPSBuZXcgbWFwQ2xhc3MoKTtcbiAgdmFyIGNoYW5nZWRCZWZvcmVBZGRlZCA9IFtdO1xuICB2YXIgZml4ZWQgPSBbXTtcbiAgdmFyIHJlbW92ZWRNYXAgPSB7fTtcbiAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgdmFyIGFkZGVkQ291bnQgPSAwO1xuICB2YXIgcmVtb3ZlZENvdW50ID0gMDsgLy8gQWRkIHByZXZLZXlzIGFuZCBrZXlzIHRvIHRoZSBoYXNobWFwLlxuXG4gIHByZXZLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgcHJldkxpc3RJbmRleCkge1xuICAgIHByZXZLZXlNYXAuc2V0KGtleSwgcHJldkxpc3RJbmRleCk7XG4gIH0pO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgbGlzdEluZGV4KSB7XG4gICAga2V5TWFwLnNldChrZXksIGxpc3RJbmRleCk7XG4gIH0pOyAvLyBDb21wYXJlIGBwcmV2S2V5c2AgYW5kIGBrZXlzYCBhbmQgYWRkIHRoZW0gdG8gYHJlbW92ZWRgIGlmIHRoZXkgYXJlIG5vdCBpbiBga2V5c2AuXG5cbiAgcHJldktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBwcmV2TGlzdEluZGV4KSB7XG4gICAgdmFyIGxpc3RJbmRleCA9IGtleU1hcC5nZXQoa2V5KTsgLy8gSW4gcHJldkxpc3QsIGJ1dCBub3QgaW4gbGlzdCwgaXQgaXMgcmVtb3ZlZC5cblxuICAgIGlmICh0eXBlb2YgbGlzdEluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICArK3JlbW92ZWRDb3VudDtcbiAgICAgIHJlbW92ZWQucHVzaChwcmV2TGlzdEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlZE1hcFtsaXN0SW5kZXhdID0gcmVtb3ZlZENvdW50O1xuICAgIH1cbiAgfSk7IC8vIENvbXBhcmUgYHByZXZLZXlzYCBhbmQgYGtleXNgIGFuZCBhZGQgdGhlbSB0byBgYWRkZWRgIGlmIHRoZXkgYXJlIG5vdCBpbiBgcHJldktleXNgLlxuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBsaXN0SW5kZXgpIHtcbiAgICB2YXIgcHJldkxpc3RJbmRleCA9IHByZXZLZXlNYXAuZ2V0KGtleSk7IC8vIEluIGxpc3QsIGJ1dCBub3QgaW4gcHJldkxpc3QsIGl0IGlzIGFkZGVkLlxuXG4gICAgaWYgKHR5cGVvZiBwcmV2TGlzdEluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBhZGRlZC5wdXNoKGxpc3RJbmRleCk7XG4gICAgICArK2FkZGVkQ291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1haW50YWluZWQucHVzaChbcHJldkxpc3RJbmRleCwgbGlzdEluZGV4XSk7XG4gICAgICByZW1vdmVkQ291bnQgPSByZW1vdmVkTWFwW2xpc3RJbmRleF0gfHwgMDtcbiAgICAgIGNoYW5nZWRCZWZvcmVBZGRlZC5wdXNoKFtwcmV2TGlzdEluZGV4IC0gcmVtb3ZlZENvdW50LCBsaXN0SW5kZXggLSBhZGRlZENvdW50XSk7XG4gICAgICBmaXhlZC5wdXNoKGxpc3RJbmRleCA9PT0gcHJldkxpc3RJbmRleCk7XG5cbiAgICAgIGlmIChwcmV2TGlzdEluZGV4ICE9PSBsaXN0SW5kZXgpIHtcbiAgICAgICAgY2hhbmdlZC5wdXNoKFtwcmV2TGlzdEluZGV4LCBsaXN0SW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBTb3J0IGJ5IGFzY2VuZGluZyBvcmRlciBvZiAndG8obGlzdCdzIGluZGV4KS5cblxuICByZW1vdmVkLnJldmVyc2UoKTtcbiAgcmV0dXJuIG5ldyBSZXN1bHQocHJldkxpc3QsIGxpc3QsIGFkZGVkLCByZW1vdmVkLCBjaGFuZ2VkLCBtYWludGFpbmVkLCBjaGFuZ2VkQmVmb3JlQWRkZWQsIGZpeGVkKTtcbn1cblxuLyoqXG4gKiBBIG1vZHVsZSB0aGF0IGNoZWNrcyBkaWZmIHdoZW4gdmFsdWVzIGFyZSBhZGRlZCwgcmVtb3ZlZCwgb3IgY2hhbmdlZCBpbiBhbiBhcnJheS5cbiAqIEBrbyDrsLDsl7Qg65iQ64qUIOyYpOu4jOygne2KuOyXkOyEnCDqsJLsnbQg7LaU6rCA65CY6rGw64KYIOyCreygnOuQmOqxsOuCmCDsiJzshJzqsIAg67OA6rK97IKs7ZWt7J2EIOyytO2BrO2VmOuKlCDrqqjrk4jsnoXri4jri6QuXG4gKiBAbWVtYmVyb2YgZWdcbiAqL1xuXG52YXIgTGlzdERpZmZlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gLSBJbml0aWFsaXppbmcgRGF0YSBBcnJheS4gPGtvPiDstIjquLAg7ISk7KCV7ZWgIOuNsOydtO2EsCDrsLDsl7QuPC9rbz5cbiAgICogQHBhcmFtIC0gVGhpcyBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGl0ZW0uIDxrbz4g7JWE7J207YWc7J2YIO2CpOulvCDrsJjtmZjtlZjripQg7L2c67CxIO2VqOyImOyeheuLiOuLpC48L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTGlzdERpZmZlciBmcm9tIFwiQGVnanMvbGlzdC1kaWZmZXJcIjtcbiAgICogLy8gc2NyaXB0ID0+IGVnLkxpc3REaWZmZXJcbiAgICogY29uc3QgZGlmZmVyID0gbmV3IExpc3REaWZmZXIoWzAsIDEsIDIsIDMsIDQsIDVdLCBlID0+IGUpO1xuICAgKiBjb25zdCByZXN1bHQgPSBkaWZmZXIudXBkYXRlKFs3LCA4LCAwLCA0LCAzLCA2LCAyLCAxXSk7XG4gICAqIC8vIExpc3QgYmVmb3JlIHVwZGF0ZVxuICAgKiAvLyBbMSwgMiwgMywgNCwgNV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LnByZXZMaXN0KTtcbiAgICogLy8gVXBkYXRlZCBsaXN0XG4gICAqIC8vIFs0LCAzLCA2LCAyLCAxXVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQubGlzdCk7XG4gICAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyBhZGRlZCB0byBgbGlzdGAuXG4gICAqIC8vIFswLCAxLCA1XVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQuYWRkZWQpO1xuICAgKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgcmVtb3ZlZCBpbiBgcHJldkxpc3RgLlxuICAgKiAvLyBbNV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LnJlbW92ZWQpO1xuICAgKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgd2l0aCBkaWZmZXJlbnQgaW5kZXhlcyBmcm9tIGBwcmV2TGlzdGAgYW5kIGBsaXN0YC5cbiAgICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQuY2hhbmdlZCk7XG4gICAqIC8vIFRoZSBzdWJzZXQgb2YgYGNoYW5nZWRgIGFuZCBhbiBhcnJheSBvZiBpbmRleCBwYWlycyB0aGF0IG1vdmVkIGRhdGEgZGlyZWN0bHkuIEluZGljYXRlIGFuIGFycmF5IG9mIGFic29sdXRlIGluZGV4IHBhaXJzIG9mIGBvcmRlcmVkYC4oRm9ybWF0dGVkIGJ5OiBBcnJheTxbaW5kZXggb2YgcHJldkxpc3QsIGluZGV4IG9mIGxpc3RdPilcbiAgICogLy8gW1s0LCAzXSwgWzMsIDRdLCBbMiwgNl1dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5wdXJlQ2hhbmdlZCk7XG4gICAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRvIGJlIGBvcmRlcmVkYCB0aGF0IGNhbiBzeW5jaHJvbml6ZSBgbGlzdGAgYmVmb3JlIGFkZGluZyBkYXRhLiAoRm9ybWF0dGVkIGJ5OiBBcnJheTxbcHJldkluZGV4LCBuZXh0SW5kZXhdPilcbiAgICogLy8gW1s0LCAxXSwgWzQsIDJdLCBbNCwgM11dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5vcmRlcmVkKTtcbiAgICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgb2YgYHByZXZMaXN0YCBhbmQgYGxpc3RgIHRoYXQgaGF2ZSBub3QgYmVlbiBhZGRlZC9yZW1vdmVkIHNvIGRhdGEgaXMgcHJlc2VydmVkLlxuICAgKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5tYWludGFpbmVkKTtcbiAgICovXG4gIGZ1bmN0aW9uIExpc3REaWZmZXIobGlzdCwgZmluZEtleUNhbGxiYWNrKSB7XG4gICAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgICAgbGlzdCA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuZmluZEtleUNhbGxiYWNrID0gZmluZEtleUNhbGxiYWNrO1xuICAgIHRoaXMubGlzdCA9IFtdLnNsaWNlLmNhbGwobGlzdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBsaXN0LlxuICAgKiBAa28g66as7Iqk7Yq466W8IOyXheuNsOydtO2KuOulvCDtlanri4jri6QuXG4gICAqIEBwYXJhbSAtIExpc3QgdG8gdXBkYXRlIDxrbz4g7JeF642w7J207Yq47ZWgIOumrOyKpO2KuCA8L2tvPlxuICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhbiB1cGRhdGUgZnJvbSBgcHJldkxpc3RgIHRvIGBsaXN0YC48a28+IGBwcmV2TGlzdGDsl5DshJwgYGxpc3Rg66GcIOyXheuNsOydtO2KuO2VnCDqsrDqs7zrpbwg67CY7ZmY7ZWc64ukLiA8L2tvPlxuICAgKi9cblxuXG4gIHZhciBfX3Byb3RvID0gTGlzdERpZmZlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by51cGRhdGUgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciBuZXdEYXRhID0gW10uc2xpY2UuY2FsbChsaXN0KTtcbiAgICB2YXIgcmVzdWx0ID0gZGlmZih0aGlzLmxpc3QsIG5ld0RhdGEsIHRoaXMuZmluZEtleUNhbGxiYWNrKTtcbiAgICB0aGlzLmxpc3QgPSBuZXdEYXRhO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIExpc3REaWZmZXI7XG59KCk7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG5cbmV4cG9ydCBkZWZhdWx0IExpc3REaWZmZXI7XG5leHBvcnQgeyBkaWZmIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0LWRpZmZlci5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBAc2NlbmEvZHJhZ3Njcm9sbFxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2RyYWdzY3JvbGwuZ2l0XG52ZXJzaW9uOiAxLjEuMVxuKi9cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnQHNjZW5hL2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjcm9sbFBvc2l0aW9uKGUpIHtcbiAgdmFyIGNvbnRhaW5lciA9IGUuY29udGFpbmVyO1xuXG4gIGlmIChjb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gW2NvbnRhaW5lci5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LCBjb250YWluZXIuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BdO1xuICB9XG5cbiAgcmV0dXJuIFtjb250YWluZXIuc2Nyb2xsTGVmdCwgY29udGFpbmVyLnNjcm9sbFRvcF07XG59XG5cbnZhciBEcmFnU2Nyb2xsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKERyYWdTY3JvbGwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gRHJhZ1Njcm9sbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLl9zdGFydFJlY3QgPSBudWxsO1xuICAgIF90aGlzLl9zdGFydFBvcyA9IFtdO1xuICAgIF90aGlzLl9wcmV2VGltZSA9IDA7XG4gICAgX3RoaXMuX3RpbWVyID0gMDtcbiAgICBfdGhpcy5fcHJldlNjcm9sbFBvcyA9IFswLCAwXTtcbiAgICBfdGhpcy5faXNXYWl0ID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBEcmFnU2Nyb2xsLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgIHZhciB0b3AgPSAwO1xuICAgIHZhciBsZWZ0ID0gMDtcbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIHZhciBoZWlnaHQgPSAwO1xuXG4gICAgaWYgKGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0b3AgPSByZWN0LnRvcDtcbiAgICAgIGxlZnQgPSByZWN0LmxlZnQ7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGFydFBvcyA9IFtlLmNsaWVudFgsIGUuY2xpZW50WV07XG4gICAgdGhpcy5fc3RhcnRSZWN0ID0ge1xuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICAgIHRoaXMuX3ByZXZTY3JvbGxQb3MgPSB0aGlzLl9nZXRTY3JvbGxQb3NpdGlvbihbMCwgMF0sIG9wdGlvbnMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZHJhZyA9IGZ1bmN0aW9uIChlLCBvcHRpb25zKSB7XG4gICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFkgPSBlLmNsaWVudFk7XG4gICAgdmFyIF9hID0gb3B0aW9ucy50aHJlc2hvbGQsXG4gICAgICAgIHRocmVzaG9sZCA9IF9hID09PSB2b2lkIDAgPyAwIDogX2E7XG5cbiAgICB2YXIgX2IgPSB0aGlzLFxuICAgICAgICBfc3RhcnRSZWN0ID0gX2IuX3N0YXJ0UmVjdCxcbiAgICAgICAgX3N0YXJ0UG9zID0gX2IuX3N0YXJ0UG9zO1xuXG4gICAgdmFyIGRpcmVjdGlvbiA9IFswLCAwXTtcblxuICAgIGlmIChfc3RhcnRSZWN0LnRvcCA+IGNsaWVudFkgLSB0aHJlc2hvbGQpIHtcbiAgICAgIGlmIChfc3RhcnRQb3NbMV0gPiBfc3RhcnRSZWN0LnRvcCB8fCBjbGllbnRZIDwgX3N0YXJ0UG9zWzFdKSB7XG4gICAgICAgIGRpcmVjdGlvblsxXSA9IC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3N0YXJ0UmVjdC50b3AgKyBfc3RhcnRSZWN0LmhlaWdodCA8IGNsaWVudFkgKyB0aHJlc2hvbGQpIHtcbiAgICAgIGlmIChfc3RhcnRQb3NbMV0gPCBfc3RhcnRSZWN0LnRvcCArIF9zdGFydFJlY3QuaGVpZ2h0IHx8IGNsaWVudFkgPiBfc3RhcnRQb3NbMV0pIHtcbiAgICAgICAgZGlyZWN0aW9uWzFdID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3N0YXJ0UmVjdC5sZWZ0ID4gY2xpZW50WCAtIHRocmVzaG9sZCkge1xuICAgICAgaWYgKF9zdGFydFBvc1swXSA+IF9zdGFydFJlY3QubGVmdCB8fCBjbGllbnRYIDwgX3N0YXJ0UG9zWzBdKSB7XG4gICAgICAgIGRpcmVjdGlvblswXSA9IC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3N0YXJ0UmVjdC5sZWZ0ICsgX3N0YXJ0UmVjdC53aWR0aCA8IGNsaWVudFggKyB0aHJlc2hvbGQpIHtcbiAgICAgIGlmIChfc3RhcnRQb3NbMF0gPCBfc3RhcnRSZWN0LmxlZnQgKyBfc3RhcnRSZWN0LndpZHRoIHx8IGNsaWVudFggPiBfc3RhcnRQb3NbMF0pIHtcbiAgICAgICAgZGlyZWN0aW9uWzBdID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuXG4gICAgaWYgKCFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jb250aW51ZURyYWcoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIGlucHV0RXZlbnQ6IGUsXG4gICAgICBpc0RyYWc6IHRydWVcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5jaGVja1Njcm9sbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLl9pc1dhaXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZXZTY3JvbGxQb3MsXG4gICAgICAgIHByZXZTY3JvbGxQb3MgPSBfYSA9PT0gdm9pZCAwID8gdGhpcy5fcHJldlNjcm9sbFBvcyA6IF9hLFxuICAgICAgICBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbixcbiAgICAgICAgX2IgPSBvcHRpb25zLnRocm90dGxlVGltZSxcbiAgICAgICAgdGhyb3R0bGVUaW1lID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYixcbiAgICAgICAgaW5wdXRFdmVudCA9IG9wdGlvbnMuaW5wdXRFdmVudCxcbiAgICAgICAgaXNEcmFnID0gb3B0aW9ucy5pc0RyYWc7XG5cbiAgICB2YXIgbmV4dFNjcm9sbFBvcyA9IHRoaXMuX2dldFNjcm9sbFBvc2l0aW9uKGRpcmVjdGlvbiB8fCBbMCwgMF0sIG9wdGlvbnMpO1xuXG4gICAgdmFyIG9mZnNldFggPSBuZXh0U2Nyb2xsUG9zWzBdIC0gcHJldlNjcm9sbFBvc1swXTtcbiAgICB2YXIgb2Zmc2V0WSA9IG5leHRTY3JvbGxQb3NbMV0gLSBwcmV2U2Nyb2xsUG9zWzFdO1xuICAgIHZhciBuZXh0RGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IFtvZmZzZXRYID8gTWF0aC5hYnMob2Zmc2V0WCkgLyBvZmZzZXRYIDogMCwgb2Zmc2V0WSA/IE1hdGguYWJzKG9mZnNldFkpIC8gb2Zmc2V0WSA6IDBdO1xuICAgIHRoaXMuX3ByZXZTY3JvbGxQb3MgPSBuZXh0U2Nyb2xsUG9zO1xuXG4gICAgaWYgKCFvZmZzZXRYICYmICFvZmZzZXRZKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKFwibW92ZVwiLCB7XG4gICAgICBvZmZzZXRYOiBuZXh0RGlyZWN0aW9uWzBdID8gb2Zmc2V0WCA6IDAsXG4gICAgICBvZmZzZXRZOiBuZXh0RGlyZWN0aW9uWzFdID8gb2Zmc2V0WSA6IDAsXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgfSk7XG5cbiAgICBpZiAodGhyb3R0bGVUaW1lICYmIGlzRHJhZykge1xuICAgICAgdGhpcy5fdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9jb250aW51ZURyYWcob3B0aW9ucyk7XG4gICAgICB9LCB0aHJvdHRsZVRpbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uZHJhZ0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9O1xuXG4gIF9fcHJvdG8uX2dldFNjcm9sbFBvc2l0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcixcbiAgICAgICAgX2EgPSBvcHRpb25zLmdldFNjcm9sbFBvc2l0aW9uLFxuICAgICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IF9hID09PSB2b2lkIDAgPyBnZXREZWZhdWx0U2Nyb2xsUG9zaXRpb24gOiBfYTtcbiAgICByZXR1cm4gZ2V0U2Nyb2xsUG9zaXRpb24oe1xuICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2NvbnRpbnVlRHJhZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcixcbiAgICAgICAgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24sXG4gICAgICAgIHRocm90dGxlVGltZSA9IG9wdGlvbnMudGhyb3R0bGVUaW1lLFxuICAgICAgICB1c2VTY3JvbGwgPSBvcHRpb25zLnVzZVNjcm9sbCxcbiAgICAgICAgaXNEcmFnID0gb3B0aW9ucy5pc0RyYWcsXG4gICAgICAgIGlucHV0RXZlbnQgPSBvcHRpb25zLmlucHV0RXZlbnQ7XG5cbiAgICBpZiAoaXNEcmFnICYmIHRoaXMuX2lzV2FpdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub3dUaW1lID0gbm93KCk7XG4gICAgdmFyIGRpc3RUaW1lID0gTWF0aC5tYXgodGhyb3R0bGVUaW1lICsgdGhpcy5fcHJldlRpbWUgLSBub3dUaW1lLCAwKTtcblxuICAgIGlmIChkaXN0VGltZSA+IDApIHtcbiAgICAgIHRoaXMuX3RpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fY29udGludWVEcmFnKG9wdGlvbnMpO1xuICAgICAgfSwgZGlzdFRpbWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3ByZXZUaW1lID0gbm93VGltZTtcblxuICAgIHZhciBwcmV2U2Nyb2xsUG9zID0gdGhpcy5fZ2V0U2Nyb2xsUG9zaXRpb24oZGlyZWN0aW9uLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX3ByZXZTY3JvbGxQb3MgPSBwcmV2U2Nyb2xsUG9zO1xuXG4gICAgaWYgKGlzRHJhZykge1xuICAgICAgdGhpcy5faXNXYWl0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoXCJzY3JvbGxcIiwge1xuICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLl9pc1dhaXQgPSBmYWxzZTtcbiAgICByZXR1cm4gdXNlU2Nyb2xsIHx8IHRoaXMuY2hlY2tTY3JvbGwoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICBwcmV2U2Nyb2xsUG9zOiBwcmV2U2Nyb2xsUG9zLFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBEcmFnU2Nyb2xsO1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBEcmFnU2Nyb2xsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhZ3Njcm9sbC5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBAc2NlbmEvZXZlbnQtZW1pdHRlclxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2dlc3R1cmUuZ2l0XG52ZXJzaW9uOiAxLjAuNVxuKi9cbmltcG9ydCB7IGlzT2JqZWN0LCBmaW5kSW5kZXggfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xudmFyIF9fYXNzaWduID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKSBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKykgcltrXSA9IGFbal07XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogSW1wbGVtZW50IEV2ZW50RW1pdHRlciBvbiBvYmplY3Qgb3IgY29tcG9uZW50LlxuICovXG5cbnZhciBFdmVudEVtaXR0ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIHRoZSByZWdpc3RlcmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gLSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0gLSBsaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICogY29zbnQgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogLy8gQWRkIGxpc3RlbmVyIGluIFwiYVwiIGV2ZW50XG4gICAqIGVtaXR0ZXIub24oXCJhXCIsICgpID0+IHtcbiAgICogfSk7XG4gICAqIC8vIEFkZCBsaXN0ZW5lcnNcbiAgICogZW1pdHRlci5vbih7XG4gICAqICBhOiAoKSA9PiB7fSxcbiAgICogIGI6ICgpID0+IHt9LFxuICAgKiB9KTtcbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzT2JqZWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMub24obmFtZSwgZXZlbnROYW1lW25hbWVdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkRXZlbnQoZXZlbnROYW1lLCBsaXN0ZW5lciwge30pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmVtb3ZlIGxpc3RlbmVycyByZWdpc3RlcmVkIGluIHRoZSBldmVudCB0YXJnZXQuXG4gICAqIEBwYXJhbSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIHJlbW92ZWRcbiAgICogQHBhcmFtIC0gbGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIHJlbW92ZWRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICogY29zbnQgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMuXG4gICAqIGVtaXR0ZXIub2ZmKCk7XG4gICAqXG4gICAqIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGluIFwiQVwiIGV2ZW50LlxuICAgKiBlbWl0dGVyLm9mZihcImFcIik7XG4gICAqXG4gICAqXG4gICAqIC8vIFJlbW92ZSBcImxpc3RlbmVyXCIgbGlzdGVuZXIgaW4gXCJhXCIgZXZlbnQuXG4gICAqIGVtaXR0ZXIub2ZmKFwiYVwiLCBsaXN0ZW5lcik7XG4gICAqL1xuXG5cbiAgX19wcm90by5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMub2ZmKG5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV07XG5cbiAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4KGV2ZW50cywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5saXN0ZW5lciA9PT0gbGlzdGVuZXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgZXZlbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEFkZCBhIGRpc3Bvc2FibGUgbGlzdGVuZXIgYW5kIFVzZSBwcm9taXNlIHRvIHRoZSByZWdpc3RlcmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gLSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0gLSBkaXNwb3NhYmxlIGxpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKiBjb3NudCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiAvLyBBZGQgYSBkaXNwb3NhYmxlIGxpc3RlbmVyIGluIFwiYVwiIGV2ZW50XG4gICAqIGVtaXR0ZXIub25jZShcImFcIiwgKCkgPT4ge1xuICAgKiB9KTtcbiAgICpcbiAgICogLy8gVXNlIFByb21pc2VcbiAgICogZW1pdHRlci5vbmNlKFwiYVwiKS50aGVuKGUgPT4ge1xuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50KGV2ZW50TmFtZSwgbGlzdGVuZXIsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfdGhpcy5fYWRkRXZlbnQoZXZlbnROYW1lLCByZXNvbHZlLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogRmlyZXMgYW4gZXZlbnQgdG8gY2FsbCBsaXN0ZW5lcnMuXG4gICAqIEBwYXJhbSAtIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIC0gRXZlbnQgcGFyYW1ldGVyXG4gICAqIEByZXR1cm4gSWYgZmFsc2UsIHN0b3AgdGhlIGV2ZW50LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKlxuICAgKlxuICAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiBlbWl0dGVyLm9uKFwiYVwiLCBlID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIGVtaXR0ZXIuZW1pdChcImFcIiwge1xuICAgKiAgIGE6IDEsXG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHBhcmFtKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChwYXJhbSA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbSA9IHt9O1xuICAgIH1cblxuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcblxuICAgIGlmICghZXZlbnROYW1lIHx8ICFldmVudHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1N0b3AgPSBmYWxzZTtcbiAgICBwYXJhbS5ldmVudFR5cGUgPSBldmVudE5hbWU7XG5cbiAgICBwYXJhbS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgaXNTdG9wID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcGFyYW0uY3VycmVudFRhcmdldCA9IHRoaXM7XG5cbiAgICBfX3NwcmVhZEFycmF5cyhldmVudHMpLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIGluZm8ubGlzdGVuZXIocGFyYW0pO1xuXG4gICAgICBpZiAoaW5mby5vbmNlKSB7XG4gICAgICAgIF90aGlzLm9mZihldmVudE5hbWUsIGluZm8ubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuICFpc1N0b3A7XG4gIH07XG4gIC8qKlxuICAgKiBGaXJlcyBhbiBldmVudCB0byBjYWxsIGxpc3RlbmVycy5cbiAgICogQHBhcmFtIC0gRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gLSBFdmVudCBwYXJhbWV0ZXJcbiAgICogQHJldHVybiBJZiBmYWxzZSwgc3RvcCB0aGUgZXZlbnQuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqXG4gICAqXG4gICAqIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIGVtaXR0ZXIub24oXCJhXCIsIGUgPT4ge1xuICAgKiB9KTtcbiAgICpcbiAgICpcbiAgICogZW1pdHRlci5lbWl0KFwiYVwiLCB7XG4gICAqICAgYTogMSxcbiAgICogfSk7XG4gICAqL1xuXG4gIC8qKlxuICAqIEZpcmVzIGFuIGV2ZW50IHRvIGNhbGwgbGlzdGVuZXJzLlxuICAqIEBwYXJhbSAtIEV2ZW50IG5hbWVcbiAgKiBAcGFyYW0gLSBFdmVudCBwYXJhbWV0ZXJcbiAgKiBAcmV0dXJuIElmIGZhbHNlLCBzdG9wIHRoZSBldmVudC5cbiAgKiBAZXhhbXBsZVxuICAqXG4gICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgKlxuICAqXG4gICogY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgKlxuICAqIGVtaXR0ZXIub24oXCJhXCIsIGUgPT4ge1xuICAqIH0pO1xuICAqXG4gICogLy8gZW1pdFxuICAqIGVtaXR0ZXIudHJpZ2dlcihcImFcIiwge1xuICAqICAgYTogMSxcbiAgKiB9KTtcbiAgKi9cblxuXG4gIF9fcHJvdG8udHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHBhcmFtKSB7XG4gICAgaWYgKHBhcmFtID09PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZW1pdChldmVudE5hbWUsIHBhcmFtKTtcbiAgfTtcblxuICBfX3Byb3RvLl9hZGRFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBldmVudHNbZXZlbnROYW1lXSA9IGV2ZW50c1tldmVudE5hbWVdIHx8IFtdO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBldmVudHNbZXZlbnROYW1lXTtcbiAgICBsaXN0ZW5lcnMucHVzaChfX2Fzc2lnbih7XG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgICB9LCBvcHRpb25zKSk7XG4gIH07XG5cbiAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnQtZW1pdHRlci5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDIwIERheWJydXNoXG5uYW1lOiBAc2NlbmEvbWF0cml4XG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvbWF0cml4XG52ZXJzaW9uOiAxLjEuMVxuKi9cbmltcG9ydCB7IHRocm90dGxlLCBUSU5ZX05VTSwgYXZlcmFnZSB9IGZyb20gJ0BkYXlicnVzaC91dGlscyc7XG5cbmZ1bmN0aW9uIGFkZChtYXRyaXgsIGludmVyc2VNYXRyaXgsIHN0YXJ0SW5kZXgsIGZyb21JbmRleCwgbiwgaykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHZhciB4ID0gc3RhcnRJbmRleCArIGkgKiBuO1xuICAgIHZhciBmcm9tWCA9IGZyb21JbmRleCArIGkgKiBuO1xuICAgIG1hdHJpeFt4XSArPSBtYXRyaXhbZnJvbVhdICogaztcbiAgICBpbnZlcnNlTWF0cml4W3hdICs9IGludmVyc2VNYXRyaXhbZnJvbVhdICogaztcbiAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKG1hdHJpeCwgaW52ZXJzZU1hdHJpeCwgc3RhcnRJbmRleCwgZnJvbUluZGV4LCBuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgdmFyIHggPSBzdGFydEluZGV4ICsgaSAqIG47XG4gICAgdmFyIGZyb21YID0gZnJvbUluZGV4ICsgaSAqIG47XG4gICAgdmFyIHYgPSBtYXRyaXhbeF07XG4gICAgdmFyIGl2ID0gaW52ZXJzZU1hdHJpeFt4XTtcbiAgICBtYXRyaXhbeF0gPSBtYXRyaXhbZnJvbVhdO1xuICAgIG1hdHJpeFtmcm9tWF0gPSB2O1xuICAgIGludmVyc2VNYXRyaXhbeF0gPSBpbnZlcnNlTWF0cml4W2Zyb21YXTtcbiAgICBpbnZlcnNlTWF0cml4W2Zyb21YXSA9IGl2O1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpdmlkZShtYXRyaXgsIGludmVyc2VNYXRyaXgsIHN0YXJ0SW5kZXgsIG4sIGspIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICB2YXIgeCA9IHN0YXJ0SW5kZXggKyBpICogbjtcbiAgICBtYXRyaXhbeF0gLz0gaztcbiAgICBpbnZlcnNlTWF0cml4W3hdIC89IGs7XG4gIH1cbn1cbi8qKlxuICpcbiAqIEBuYW1lc3BhY2UgTWF0cml4XG4gKi9cblxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuXG5mdW5jdGlvbiBpZ25vcmVEaW1lbnNpb24obWF0cml4LCBtLCBuKSB7XG4gIGlmIChuID09PSB2b2lkIDApIHtcbiAgICBuID0gTWF0aC5zcXJ0KG1hdHJpeC5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIG5ld01hdHJpeCA9IG1hdHJpeC5zbGljZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgbmV3TWF0cml4W2kgKiBuICsgbSAtIDFdID0gMDtcbiAgICBuZXdNYXRyaXhbKG0gLSAxKSAqIG4gKyBpXSA9IDA7XG4gIH1cblxuICBuZXdNYXRyaXhbKG0gLSAxKSAqIChuICsgMSldID0gMTtcbiAgcmV0dXJuIG5ld01hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGludmVydChtYXRyaXgsIG4pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIG4gPSBNYXRoLnNxcnQobWF0cml4Lmxlbmd0aCk7XG4gIH1cblxuICB2YXIgbmV3TWF0cml4ID0gbWF0cml4LnNsaWNlKCk7XG4gIHZhciBpbnZlcnNlTWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAvLyBkaWFnb25hbFxuICAgIHZhciBpZGVudGl0eUluZGV4ID0gbiAqIGkgKyBpO1xuXG4gICAgaWYgKCF0aHJvdHRsZShuZXdNYXRyaXhbaWRlbnRpdHlJbmRleF0sIFRJTllfTlVNKSkge1xuICAgICAgLy8gbmV3TWF0cml4W2lkZW50aXR5SW5kZXhdID0gMDtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG47ICsraikge1xuICAgICAgICBpZiAobmV3TWF0cml4W24gKiBpICsgal0pIHtcbiAgICAgICAgICBzd2FwKG5ld01hdHJpeCwgaW52ZXJzZU1hdHJpeCwgaSwgaiwgbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRocm90dGxlKG5ld01hdHJpeFtpZGVudGl0eUluZGV4XSwgVElOWV9OVU0pKSB7XG4gICAgICAvLyBubyBpbnZlcnNlIG1hdHJpeFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGRpdmlkZShuZXdNYXRyaXgsIGludmVyc2VNYXRyaXgsIGksIG4sIG5ld01hdHJpeFtpZGVudGl0eUluZGV4XSk7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgdmFyIHRhcmdldFN0YXJ0SW5kZXggPSBqO1xuICAgICAgdmFyIHRhcmdldEluZGV4ID0gaiArIGkgKiBuO1xuICAgICAgdmFyIHRhcmdldCA9IG5ld01hdHJpeFt0YXJnZXRJbmRleF07XG5cbiAgICAgIGlmICghdGhyb3R0bGUodGFyZ2V0LCBUSU5ZX05VTSkgfHwgaSA9PT0gaikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYWRkKG5ld01hdHJpeCwgaW52ZXJzZU1hdHJpeCwgdGFyZ2V0U3RhcnRJbmRleCwgaSwgbiwgLXRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGludmVyc2VNYXRyaXg7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiB0cmFuc3Bvc2UobWF0cml4LCBuKSB7XG4gIGlmIChuID09PSB2b2lkIDApIHtcbiAgICBuID0gTWF0aC5zcXJ0KG1hdHJpeC5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIG5ld01hdHJpeCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgIG5ld01hdHJpeFtqICogbiArIGldID0gbWF0cml4W24gKiBpICsgal07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld01hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGdldE9yaWdpbihtYXRyaXgsIG4pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIG4gPSBNYXRoLnNxcnQobWF0cml4Lmxlbmd0aCk7XG4gIH1cblxuICB2YXIgb3JpZ2luTWF0cml4ID0gW107XG4gIHZhciB3ID0gbWF0cml4W24gKiBuIC0gMV07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuIC0gMTsgKytpKSB7XG4gICAgb3JpZ2luTWF0cml4W2ldID0gbWF0cml4W24gKiAobiAtIDEpICsgaV0gLyB3O1xuICB9XG5cbiAgb3JpZ2luTWF0cml4W24gLSAxXSA9IDA7XG4gIHJldHVybiBvcmlnaW5NYXRyaXg7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ocG9zLCBuKSB7XG4gIHZhciBuZXdNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG4gLSAxOyArK2kpIHtcbiAgICBuZXdNYXRyaXhbbiAqIChuIC0gMSkgKyBpXSA9IHBvc1tpXSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIG5ld01hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNvbnZlcnRQb3NpdGlvbk1hdHJpeChtYXRyaXgsIG4pIHtcbiAgdmFyIG5ld01hdHJpeCA9IG1hdHJpeC5zbGljZSgpO1xuXG4gIGZvciAodmFyIGkgPSBtYXRyaXgubGVuZ3RoOyBpIDwgbiAtIDE7ICsraSkge1xuICAgIG5ld01hdHJpeFtpXSA9IDA7XG4gIH1cblxuICBuZXdNYXRyaXhbbiAtIDFdID0gMTtcbiAgcmV0dXJuIG5ld01hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNvbnZlcnREaW1lbnNpb24obWF0cml4LCBuLCBtKSB7XG4gIGlmIChuID09PSB2b2lkIDApIHtcbiAgICBuID0gTWF0aC5zcXJ0KG1hdHJpeC5sZW5ndGgpO1xuICB9IC8vIG4gPCBtXG5cblxuICBpZiAobiA9PT0gbSkge1xuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cblxuICB2YXIgbmV3TWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobSk7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihuLCBtKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAtIDE7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoIC0gMTsgKytqKSB7XG4gICAgICBuZXdNYXRyaXhbaSAqIG0gKyBqXSA9IG1hdHJpeFtpICogbiArIGpdO1xuICAgIH1cblxuICAgIG5ld01hdHJpeFsoaSArIDEpICogbSAtIDFdID0gbWF0cml4WyhpICsgMSkgKiBuIC0gMV07XG4gICAgbmV3TWF0cml4WyhtIC0gMSkgKiBtICsgaV0gPSBtYXRyaXhbKG4gLSAxKSAqIG4gKyBpXTtcbiAgfVxuXG4gIG5ld01hdHJpeFttICogbSAtIDFdID0gbWF0cml4W24gKiBuIC0gMV07XG4gIHJldHVybiBuZXdNYXRyaXg7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBtdWx0aXBsaWVzKG4pIHtcbiAgdmFyIG1hdHJpeGVzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBtYXRyaXhlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciBtID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIG1hdHJpeGVzLmZvckVhY2goZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgIG0gPSBtdWx0aXBseShtLCBtYXRyaXgsIG4pO1xuICB9KTtcbiAgcmV0dXJuIG07XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBtdWx0aXBseShtYXRyaXgsIG1hdHJpeDIsIG4pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIG4gPSBNYXRoLnNxcnQobWF0cml4Lmxlbmd0aCk7XG4gIH1cblxuICB2YXIgbmV3TWF0cml4ID0gW107IC8vIDEgeTogblxuICAvLyAxIHg6IG1cbiAgLy8gMiB4OiBtXG4gIC8vIDIgeToga1xuICAvLyBuICogbSBYIG0gKiBrXG5cbiAgdmFyIG0gPSBtYXRyaXgubGVuZ3RoIC8gbjtcbiAgdmFyIGsgPSBtYXRyaXgyLmxlbmd0aCAvIG07XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIG1hdHJpeDI7XG4gIH0gZWxzZSBpZiAoIWspIHtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGs7ICsraikge1xuICAgICAgbmV3TWF0cml4W2ogKiBuICsgaV0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IG07ICsrbCkge1xuICAgICAgICAvLyBtMSB4OiBtKGwpLCB5OiBuKGkpXG4gICAgICAgIC8vIG0yIHg6IGsoaik6ICB5OiBtKGwpXG4gICAgICAgIC8vIG53IHg6IG4oaSksIHk6IGsoailcbiAgICAgICAgbmV3TWF0cml4W2ogKiBuICsgaV0gKz0gbWF0cml4W2wgKiBuICsgaV0gKiBtYXRyaXgyW2ogKiBtICsgbF07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIG4gKiBrXG5cblxuICByZXR1cm4gbmV3TWF0cml4O1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gcGx1cyhwb3MxLCBwb3MyKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihwb3MxLmxlbmd0aCwgcG9zMi5sZW5ndGgpO1xuICB2YXIgbmV4dFBvcyA9IHBvczEuc2xpY2UoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgbmV4dFBvc1tpXSA9IG5leHRQb3NbaV0gKyBwb3MyW2ldO1xuICB9XG5cbiAgcmV0dXJuIG5leHRQb3M7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBtaW51cyhwb3MxLCBwb3MyKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihwb3MxLmxlbmd0aCwgcG9zMi5sZW5ndGgpO1xuICB2YXIgbmV4dFBvcyA9IHBvczEuc2xpY2UoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgbmV4dFBvc1tpXSA9IG5leHRQb3NbaV0gLSBwb3MyW2ldO1xuICB9XG5cbiAgcmV0dXJuIG5leHRQb3M7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0Q1NTdG9NYXRyaXgoYSwgaXMyZCkge1xuICBpZiAoaXMyZCA9PT0gdm9pZCAwKSB7XG4gICAgaXMyZCA9IGEubGVuZ3RoID09PSA2O1xuICB9XG5cbiAgaWYgKGlzMmQpIHtcbiAgICByZXR1cm4gW2FbMF0sIGFbMV0sIDAsIGFbMl0sIGFbM10sIDAsIGFbNF0sIGFbNV0sIDFdO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0TWF0cml4dG9DU1MoYSwgaXMyZCkge1xuICBpZiAoaXMyZCA9PT0gdm9pZCAwKSB7XG4gICAgaXMyZCA9IGEubGVuZ3RoID09PSA5O1xuICB9XG5cbiAgaWYgKGlzMmQpIHtcbiAgICByZXR1cm4gW2FbMF0sIGFbMV0sIGFbM10sIGFbNF0sIGFbNl0sIGFbN11dO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjYWxjdWxhdGUobWF0cml4LCBtYXRyaXgyLCBuKSB7XG4gIGlmIChuID09PSB2b2lkIDApIHtcbiAgICBuID0gbWF0cml4Mi5sZW5ndGg7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbXVsdGlwbHkobWF0cml4LCBtYXRyaXgyLCBuKTtcbiAgdmFyIGsgPSByZXN1bHRbbiAtIDFdO1xuICByZXR1cm4gcmVzdWx0Lm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2IC8gaztcbiAgfSk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiByb3RhdGVYM2QobWF0cml4LCByYWQpIHtcbiAgcmV0dXJuIG11bHRpcGx5KG1hdHJpeCwgWzEsIDAsIDAsIDAsIDAsIE1hdGguY29zKHJhZCksIE1hdGguc2luKHJhZCksIDAsIDAsIC1NYXRoLnNpbihyYWQpLCBNYXRoLmNvcyhyYWQpLCAwLCAwLCAwLCAwLCAxXSwgNCk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiByb3RhdGVZM2QobWF0cml4LCByYWQpIHtcbiAgcmV0dXJuIG11bHRpcGx5KG1hdHJpeCwgW01hdGguY29zKHJhZCksIDAsIC1NYXRoLnNpbihyYWQpLCAwLCAwLCAxLCAwLCAwLCBNYXRoLnNpbihyYWQpLCAwLCBNYXRoLmNvcyhyYWQpLCAwLCAwLCAwLCAwLCAxXSwgNCk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiByb3RhdGVaM2QobWF0cml4LCByYWQpIHtcbiAgcmV0dXJuIG11bHRpcGx5KG1hdHJpeCwgY3JlYXRlUm90YXRlTWF0cml4KHJhZCwgNCkpO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gc2NhbGUzZChtYXRyaXgsIF9hKSB7XG4gIHZhciBfYiA9IF9hWzBdLFxuICAgICAgc3ggPSBfYiA9PT0gdm9pZCAwID8gMSA6IF9iLFxuICAgICAgX2MgPSBfYVsxXSxcbiAgICAgIHN5ID0gX2MgPT09IHZvaWQgMCA/IDEgOiBfYyxcbiAgICAgIF9kID0gX2FbMl0sXG4gICAgICBzeiA9IF9kID09PSB2b2lkIDAgPyAxIDogX2Q7XG4gIHJldHVybiBtdWx0aXBseShtYXRyaXgsIFtzeCwgMCwgMCwgMCwgMCwgc3ksIDAsIDAsIDAsIDAsIHN6LCAwLCAwLCAwLCAwLCAxXSwgNCk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiByb3RhdGUocG9zLCByYWQpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZShjcmVhdGVSb3RhdGVNYXRyaXgocmFkLCAzKSwgY29udmVydFBvc2l0aW9uTWF0cml4KHBvcywgMykpO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNsYXRlM2QobWF0cml4LCBfYSkge1xuICB2YXIgX2IgPSBfYVswXSxcbiAgICAgIHR4ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYixcbiAgICAgIF9jID0gX2FbMV0sXG4gICAgICB0eSA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsXG4gICAgICBfZCA9IF9hWzJdLFxuICAgICAgdHogPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kO1xuICByZXR1cm4gbXVsdGlwbHkobWF0cml4LCBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgdHgsIHR5LCB0eiwgMV0sIDQpO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gbWF0cml4M2QobWF0cml4MSwgbWF0cml4Mikge1xuICByZXR1cm4gbXVsdGlwbHkobWF0cml4MSwgbWF0cml4MiwgNCk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSb3RhdGVNYXRyaXgocmFkLCBuKSB7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgc2luID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIG0gPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTsgLy8gY29zIC1zaW5cbiAgLy8gc2luIGNvc1xuXG4gIG1bMF0gPSBjb3M7XG4gIG1bMV0gPSBzaW47XG4gIG1bbl0gPSAtc2luO1xuICBtW24gKyAxXSA9IGNvcztcbiAgcmV0dXJuIG07XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSB7XG4gIHZhciBsZW5ndGggPSBuICogbjtcbiAgdmFyIG1hdHJpeCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBtYXRyaXhbaV0gPSBpICUgKG4gKyAxKSA/IDAgOiAxO1xuICB9XG5cbiAgcmV0dXJuIG1hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlTWF0cml4KHNjYWxlLCBuKSB7XG4gIHZhciBtID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihzY2FsZS5sZW5ndGgsIG4gLSAxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgbVsobiArIDEpICogaV0gPSBzY2FsZVtpXTtcbiAgfVxuXG4gIHJldHVybiBtO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlT3JpZ2luTWF0cml4KG9yaWdpbiwgbikge1xuICB2YXIgbSA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4ob3JpZ2luLmxlbmd0aCwgbiAtIDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBtW24gKiAobiAtIDEpICsgaV0gPSBvcmlnaW5baV07XG4gIH1cblxuICByZXR1cm4gbTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVdhcnBNYXRyaXgocG9zMCwgcG9zMSwgcG9zMiwgcG9zMywgbmV4dFBvczAsIG5leHRQb3MxLCBuZXh0UG9zMiwgbmV4dFBvczMpIHtcbiAgdmFyIHgwID0gcG9zMFswXSxcbiAgICAgIHkwID0gcG9zMFsxXTtcbiAgdmFyIHgxID0gcG9zMVswXSxcbiAgICAgIHkxID0gcG9zMVsxXTtcbiAgdmFyIHgyID0gcG9zMlswXSxcbiAgICAgIHkyID0gcG9zMlsxXTtcbiAgdmFyIHgzID0gcG9zM1swXSxcbiAgICAgIHkzID0gcG9zM1sxXTtcbiAgdmFyIHUwID0gbmV4dFBvczBbMF0sXG4gICAgICB2MCA9IG5leHRQb3MwWzFdO1xuICB2YXIgdTEgPSBuZXh0UG9zMVswXSxcbiAgICAgIHYxID0gbmV4dFBvczFbMV07XG4gIHZhciB1MiA9IG5leHRQb3MyWzBdLFxuICAgICAgdjIgPSBuZXh0UG9zMlsxXTtcbiAgdmFyIHUzID0gbmV4dFBvczNbMF0sXG4gICAgICB2MyA9IG5leHRQb3MzWzFdO1xuICB2YXIgbWF0cml4ID0gW3gwLCAwLCB4MSwgMCwgeDIsIDAsIHgzLCAwLCB5MCwgMCwgeTEsIDAsIHkyLCAwLCB5MywgMCwgMSwgMCwgMSwgMCwgMSwgMCwgMSwgMCwgMCwgeDAsIDAsIHgxLCAwLCB4MiwgMCwgeDMsIDAsIHkwLCAwLCB5MSwgMCwgeTIsIDAsIHkzLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAtdTAgKiB4MCwgLXYwICogeDAsIC11MSAqIHgxLCAtdjEgKiB4MSwgLXUyICogeDIsIC12MiAqIHgyLCAtdTMgKiB4MywgLXYzICogeDMsIC11MCAqIHkwLCAtdjAgKiB5MCwgLXUxICogeTEsIC12MSAqIHkxLCAtdTIgKiB5MiwgLXYyICogeTIsIC11MyAqIHkzLCAtdjMgKiB5M107XG4gIHZhciBpbnZlcnNlTWF0cml4ID0gaW52ZXJ0KG1hdHJpeCwgOCk7XG5cbiAgaWYgKCFpbnZlcnNlTWF0cml4Lmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBoID0gbXVsdGlwbHkoaW52ZXJzZU1hdHJpeCwgW3UwLCB2MCwgdTEsIHYxLCB1MiwgdjIsIHUzLCB2M10sIDgpO1xuICBoWzhdID0gMTtcbiAgcmV0dXJuIGNvbnZlcnREaW1lbnNpb24odHJhbnNwb3NlKGgpLCAzLCA0KTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGdldENlbnRlcihwb2ludHMpIHtcbiAgcmV0dXJuIFswLCAxXS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gYXZlcmFnZShwb2ludHMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwb3NbaV07XG4gICAgfSkpO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgY2FsY3VsYXRlLCBjb252ZXJ0Q1NTdG9NYXRyaXgsIGNvbnZlcnREaW1lbnNpb24sIGNvbnZlcnRNYXRyaXh0b0NTUywgY29udmVydFBvc2l0aW9uTWF0cml4LCBjcmVhdGVJZGVudGl0eU1hdHJpeCwgY3JlYXRlT3JpZ2luTWF0cml4LCBjcmVhdGVSb3RhdGVNYXRyaXgsIGNyZWF0ZVNjYWxlTWF0cml4LCBjcmVhdGVXYXJwTWF0cml4LCBmcm9tVHJhbnNsYXRpb24sIGdldENlbnRlciwgZ2V0T3JpZ2luLCBpZ25vcmVEaW1lbnNpb24sIGludmVydCwgbWF0cml4M2QsIG1pbnVzLCBtdWx0aXBsaWVzLCBtdWx0aXBseSwgcGx1cywgcm90YXRlLCByb3RhdGVYM2QsIHJvdGF0ZVkzZCwgcm90YXRlWjNkLCBzY2FsZTNkLCB0cmFuc2xhdGUzZCwgdHJhbnNwb3NlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRyaXguZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxOSBEYXlicnVzaFxubmFtZTogY3NzLXRvLW1hdFxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2Nzcy10by1tYXQuZ2l0XG52ZXJzaW9uOiAxLjAuM1xuKi9cbmltcG9ydCB7IHNwbGl0QnJhY2tldCwgc3BsaXRDb21tYSwgc3BsaXRVbml0LCBpc0FycmF5LCBzcGxpdFNwYWNlIH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcbmltcG9ydCB7IGNhbGN1bGF0ZSwgbWF0cml4M2QsIGludmVydCwgdHJhbnNsYXRlM2QsIHNjYWxlM2QsIHJvdGF0ZVozZCwgcm90YXRlWDNkLCByb3RhdGVZM2QgfSBmcm9tICdAc2NlbmEvbWF0cml4JztcblxuZnVuY3Rpb24gY3JlYXRlTWF0cml4KCkge1xuICByZXR1cm4gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xufVxuZnVuY3Rpb24gcGFyc2VNYXQodHJhbnNmb3JtKSB7XG4gIHJldHVybiB0b01hdChwYXJzZSh0cmFuc2Zvcm0pKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRNYXRyaXgoZWwpIHtcbiAgcmV0dXJuIHBhcnNlTWF0KGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zZm9ybSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVNYXRyaXhEaXN0KG1hdHJpeCwgcG9zKSB7XG4gIHZhciByZXMgPSBjYWxjdWxhdGUobWF0cml4LCBbcG9zWzBdLCBwb3NbMV0gfHwgMCwgcG9zWzJdIHx8IDAsIDFdLCA0KTtcbiAgdmFyIHcgPSByZXNbM10gfHwgMTtcbiAgcmV0dXJuIFtyZXNbMF0gLyB3LCByZXNbMV0gLyB3LCByZXNbMl0gLyB3XTtcbn1cbmZ1bmN0aW9uIGdldERpc3RFbGVtZW50TWF0cml4KGVsLCBjb250YWluZXIpIHtcbiAgaWYgKGNvbnRhaW5lciA9PT0gdm9pZCAwKSB7XG4gICAgY29udGFpbmVyID0gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSBlbDtcbiAgdmFyIG1hdHJpeCA9IGNyZWF0ZU1hdHJpeCgpO1xuXG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICB2YXIgdHJhbnNmb3JtID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLnRyYW5zZm9ybTtcbiAgICBtYXRyaXggPSBtYXRyaXgzZChwYXJzZU1hdCh0cmFuc2Zvcm0pLCBtYXRyaXgpO1xuXG4gICAgaWYgKHRhcmdldCA9PT0gY29udGFpbmVyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgfVxuXG4gIG1hdHJpeCA9IGludmVydChtYXRyaXgsIDQpO1xuICBtYXRyaXhbMTJdID0gMDtcbiAgbWF0cml4WzEzXSA9IDA7XG4gIG1hdHJpeFsxNF0gPSAwO1xuICByZXR1cm4gbWF0cml4O1xufVxuZnVuY3Rpb24gdG9NYXQobWF0cml4SW5mb3MpIHtcbiAgdmFyIHRhcmdldCA9IGNyZWF0ZU1hdHJpeCgpO1xuICBtYXRyaXhJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgdmFyIG1hdHJpeEZ1bmN0aW9uID0gaW5mby5tYXRyaXhGdW5jdGlvbixcbiAgICAgICAgZnVuY3Rpb25WYWx1ZSA9IGluZm8uZnVuY3Rpb25WYWx1ZTtcblxuICAgIGlmICghbWF0cml4RnVuY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBtYXRyaXhGdW5jdGlvbih0YXJnZXQsIGZ1bmN0aW9uVmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHBhcnNlKHRyYW5zZm9ybSkge1xuICB2YXIgdHJhbnNmb3JtcyA9IGlzQXJyYXkodHJhbnNmb3JtKSA/IHRyYW5zZm9ybSA6IHNwbGl0U3BhY2UodHJhbnNmb3JtKTtcbiAgcmV0dXJuIHRyYW5zZm9ybXMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIF9hID0gc3BsaXRCcmFja2V0KHQpLFxuICAgICAgICBuYW1lID0gX2EucHJlZml4LFxuICAgICAgICB2YWx1ZSA9IF9hLnZhbHVlO1xuXG4gICAgdmFyIG1hdHJpeEZ1bmN0aW9uID0gbnVsbDtcbiAgICB2YXIgZnVuY3Rpb25OYW1lID0gbmFtZTtcbiAgICB2YXIgZnVuY3Rpb25WYWx1ZSA9IFwiXCI7XG5cbiAgICBpZiAobmFtZSA9PT0gXCJ0cmFuc2xhdGVcIiB8fCBuYW1lID09PSBcInRyYW5zbGF0ZVhcIiB8fCBuYW1lID09PSBcInRyYW5zbGF0ZTNkXCIpIHtcbiAgICAgIHZhciBfYiA9IHNwbGl0Q29tbWEodmFsdWUpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgICAgIH0pLFxuICAgICAgICAgIHBvc1ggPSBfYlswXSxcbiAgICAgICAgICBfYyA9IF9iWzFdLFxuICAgICAgICAgIHBvc1kgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLFxuICAgICAgICAgIF9kID0gX2JbMl0sXG4gICAgICAgICAgcG9zWiA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG5cbiAgICAgIG1hdHJpeEZ1bmN0aW9uID0gdHJhbnNsYXRlM2Q7XG4gICAgICBmdW5jdGlvblZhbHVlID0gW3Bvc1gsIHBvc1ksIHBvc1pdO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJ0cmFuc2xhdGVZXCIpIHtcbiAgICAgIHZhciBwb3NZID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBtYXRyaXhGdW5jdGlvbiA9IHRyYW5zbGF0ZTNkO1xuICAgICAgZnVuY3Rpb25WYWx1ZSA9IFswLCBwb3NZLCAwXTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwidHJhbnNsYXRlWlwiKSB7XG4gICAgICB2YXIgcG9zWiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgbWF0cml4RnVuY3Rpb24gPSB0cmFuc2xhdGUzZDtcbiAgICAgIGZ1bmN0aW9uVmFsdWUgPSBbMCwgMCwgcG9zWl07XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcInNjYWxlXCIgfHwgbmFtZSA9PT0gXCJzY2FsZTNkXCIpIHtcbiAgICAgIHZhciBfZSA9IHNwbGl0Q29tbWEodmFsdWUpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgICAgIH0pLFxuICAgICAgICAgIHN4ID0gX2VbMF0sXG4gICAgICAgICAgX2YgPSBfZVsxXSxcbiAgICAgICAgICBzeSA9IF9mID09PSB2b2lkIDAgPyBzeCA6IF9mLFxuICAgICAgICAgIF9nID0gX2VbMl0sXG4gICAgICAgICAgc3ogPSBfZyA9PT0gdm9pZCAwID8gMSA6IF9nO1xuXG4gICAgICBtYXRyaXhGdW5jdGlvbiA9IHNjYWxlM2Q7XG4gICAgICBmdW5jdGlvblZhbHVlID0gW3N4LCBzeSwgc3pdO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzY2FsZVhcIikge1xuICAgICAgdmFyIHN4ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBtYXRyaXhGdW5jdGlvbiA9IHNjYWxlM2Q7XG4gICAgICBmdW5jdGlvblZhbHVlID0gW3N4LCAxLCAxXTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic2NhbGVZXCIpIHtcbiAgICAgIHZhciBzeSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgbWF0cml4RnVuY3Rpb24gPSBzY2FsZTNkO1xuICAgICAgZnVuY3Rpb25WYWx1ZSA9IFsxLCBzeSwgMV07XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcInNjYWxlWlwiKSB7XG4gICAgICB2YXIgc3ogPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIG1hdHJpeEZ1bmN0aW9uID0gc2NhbGUzZDtcbiAgICAgIGZ1bmN0aW9uVmFsdWUgPSBbMSwgMSwgc3pdO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJyb3RhdGVcIiB8fCBuYW1lID09PSBcInJvdGF0ZVpcIiB8fCBuYW1lID09PSBcInJvdGF0ZVhcIiB8fCBuYW1lID09PSBcInJvdGF0ZVlcIikge1xuICAgICAgdmFyIF9oID0gc3BsaXRVbml0KHZhbHVlKSxcbiAgICAgICAgICB1bml0ID0gX2gudW5pdCxcbiAgICAgICAgICB1bml0VmFsdWUgPSBfaC52YWx1ZTtcblxuICAgICAgdmFyIHJhZCA9IHVuaXQgPT09IFwicmFkXCIgPyB1bml0VmFsdWUgOiB1bml0VmFsdWUgKiBNYXRoLlBJIC8gMTgwO1xuXG4gICAgICBpZiAobmFtZSA9PT0gXCJyb3RhdGVcIiB8fCBuYW1lID09PSBcInJvdGF0ZVpcIikge1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSBcInJvdGF0ZVpcIjtcbiAgICAgICAgbWF0cml4RnVuY3Rpb24gPSByb3RhdGVaM2Q7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwicm90YXRlWFwiKSB7XG4gICAgICAgIG1hdHJpeEZ1bmN0aW9uID0gcm90YXRlWDNkO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcInJvdGF0ZVlcIikge1xuICAgICAgICBtYXRyaXhGdW5jdGlvbiA9IHJvdGF0ZVkzZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb25WYWx1ZSA9IHJhZDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwibWF0cml4M2RcIikge1xuICAgICAgbWF0cml4RnVuY3Rpb24gPSBtYXRyaXgzZDtcbiAgICAgIGZ1bmN0aW9uVmFsdWUgPSBzcGxpdENvbW1hKHZhbHVlKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwibWF0cml4XCIpIHtcbiAgICAgIHZhciBtID0gc3BsaXRDb21tYSh2YWx1ZSkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHYpO1xuICAgICAgfSk7XG4gICAgICBtYXRyaXhGdW5jdGlvbiA9IG1hdHJpeDNkO1xuICAgICAgZnVuY3Rpb25WYWx1ZSA9IFttWzBdLCBtWzFdLCAwLCAwLCBtWzJdLCBtWzNdLCAwLCAwLCAwLCAwLCAxLCAwLCBtWzRdLCBtWzVdLCAwLCAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVuY3Rpb25OYW1lID0gXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgbWF0cml4RnVuY3Rpb246IG1hdHJpeEZ1bmN0aW9uLFxuICAgICAgZnVuY3Rpb25WYWx1ZTogZnVuY3Rpb25WYWx1ZVxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgeyBjYWxjdWxhdGVNYXRyaXhEaXN0LCBjcmVhdGVNYXRyaXgsIGdldERpc3RFbGVtZW50TWF0cml4LCBnZXRFbGVtZW50TWF0cml4LCBwYXJzZSwgcGFyc2VNYXQsIHRvTWF0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3MtdG8tbWF0LmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IGZyYW1ld29yay11dGlsc1xubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2ZyYW1ld29yay11dGlscy5naXRcbnZlcnNpb246IDEuMS4wXG4qL1xuZnVuY3Rpb24gcHJlZml4TmFtZXMocHJlZml4KSB7XG4gIHZhciBjbGFzc05hbWVzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBjbGFzc05hbWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgcmV0dXJuIGNsYXNzTmFtZXMubWFwKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lID8gXCJcIiArIHByZWZpeCArIG5hbWUgOiBcIlwiO1xuICAgIH0pLmpvaW4oXCIgXCIpO1xuICB9KS5qb2luKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIHByZWZpeENTUyhwcmVmaXgsIGNzcykge1xuICByZXR1cm4gY3NzLnJlcGxhY2UoLyhbXn17XSopey9nbSwgZnVuY3Rpb24gKF8sIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoL1xcLihbXnssXFxzXFxkLl0rKS9nLCBcIi5cIiArIHByZWZpeCArIFwiJDFcIikgKyBcIntcIjtcbiAgfSk7XG59XG4vKiByZWFjdCAqL1xuXG5mdW5jdGlvbiByZWYodGFyZ2V0LCBuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgIGUgJiYgKHRhcmdldFtuYW1lXSA9IGUpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVmcyh0YXJnZXQsIG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgZSAmJiAodGFyZ2V0W25hbWVdW2ldID0gZSk7XG4gIH07XG59XG4vKiBDbGFzcyBEZWNvcmF0b3IgKi9cblxuZnVuY3Rpb24gUHJvcGVydGllcyhwcm9wZXJ0aWVzLCBhY3Rpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICB2YXIgcHJvdG90eXBlID0gY29tcG9uZW50LnByb3RvdHlwZTtcbiAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICBhY3Rpb24ocHJvdG90eXBlLCBwcm9wZXJ0eSk7XG4gICAgfSk7XG4gIH07XG59XG4vKiBQcm9wZXJ0eSBEZWNvcmF0b3IgKi9cblxuZnVuY3Rpb24gd2l0aE1ldGhvZHMobWV0aG9kcywgZHVwbGljYXRlKSB7XG4gIGlmIChkdXBsaWNhdGUgPT09IHZvaWQgMCkge1xuICAgIGR1cGxpY2F0ZSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnR5TmFtZSkge1xuICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIG1ldGhvZE5hbWUgPSBkdXBsaWNhdGVbbmFtZV0gfHwgbmFtZTtcblxuICAgICAgaWYgKG1ldGhvZE5hbWUgaW4gcHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSAoX2EgPSB0aGlzW3Byb3BlcnR5TmFtZV0pW25hbWVdLmFwcGx5KF9hLCBhcmdzKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB0aGlzW3Byb3BlcnR5TmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgeyBQcm9wZXJ0aWVzLCBwcmVmaXhDU1MsIHByZWZpeE5hbWVzLCByZWYsIHJlZnMsIHdpdGhNZXRob2RzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBnZXN0b1xubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2dlc3RvLmdpdFxudmVyc2lvbjogMS43LjBcbiovXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ0BzY2VuYS9ldmVudC1lbWl0dGVyJztcbmltcG9ydCB7IHJlbW92ZUV2ZW50LCBub3csIGFkZEV2ZW50IH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gZ2V0UmFkKHBvczEsIHBvczIpIHtcbiAgdmFyIGRpc3RYID0gcG9zMlswXSAtIHBvczFbMF07XG4gIHZhciBkaXN0WSA9IHBvczJbMV0gLSBwb3MxWzFdO1xuICB2YXIgcmFkID0gTWF0aC5hdGFuMihkaXN0WSwgZGlzdFgpO1xuICByZXR1cm4gcmFkID49IDAgPyByYWQgOiByYWQgKyBNYXRoLlBJICogMjtcbn1cbmZ1bmN0aW9uIGdldFJvdGF0aWlvbih0b3VjaGVzKSB7XG4gIHJldHVybiBnZXRSYWQoW3RvdWNoZXNbMF0uY2xpZW50WCwgdG91Y2hlc1swXS5jbGllbnRZXSwgW3RvdWNoZXNbMV0uY2xpZW50WCwgdG91Y2hlc1sxXS5jbGllbnRZXSkgLyBNYXRoLlBJICogMTgwO1xufVxuZnVuY3Rpb24gaXNNdWx0aVRvdWNoKGUpIHtcbiAgcmV0dXJuIGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID49IDI7XG59XG5mdW5jdGlvbiBnZXRFdmVudENsaWVudHMoZSkge1xuICBpZiAoZS50b3VjaGVzKSB7XG4gICAgcmV0dXJuIGdldENsaWVudHMoZS50b3VjaGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2dldENsaWVudChlKV07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGNsaWVudHMsIHByZXZDbGllbnRzLCBzdGFydENsaWVudHMpIHtcbiAgdmFyIGxlbmd0aCA9IHN0YXJ0Q2xpZW50cy5sZW5ndGg7XG5cbiAgdmFyIF9hID0gZ2V0QXZlcmFnZUNsaWVudChjbGllbnRzLCBsZW5ndGgpLFxuICAgICAgY2xpZW50WCA9IF9hLmNsaWVudFgsXG4gICAgICBjbGllbnRZID0gX2EuY2xpZW50WSxcbiAgICAgIG9yaWdpbmFsQ2xpZW50WCA9IF9hLm9yaWdpbmFsQ2xpZW50WCxcbiAgICAgIG9yaWdpbmFsQ2xpZW50WSA9IF9hLm9yaWdpbmFsQ2xpZW50WTtcblxuICB2YXIgX2IgPSBnZXRBdmVyYWdlQ2xpZW50KHByZXZDbGllbnRzLCBsZW5ndGgpLFxuICAgICAgcHJldlggPSBfYi5jbGllbnRYLFxuICAgICAgcHJldlkgPSBfYi5jbGllbnRZO1xuXG4gIHZhciBfYyA9IGdldEF2ZXJhZ2VDbGllbnQoc3RhcnRDbGllbnRzLCBsZW5ndGgpLFxuICAgICAgc3RhcnRYID0gX2MuY2xpZW50WCxcbiAgICAgIHN0YXJ0WSA9IF9jLmNsaWVudFk7XG5cbiAgdmFyIGRlbHRhWCA9IGNsaWVudFggLSBwcmV2WDtcbiAgdmFyIGRlbHRhWSA9IGNsaWVudFkgLSBwcmV2WTtcbiAgdmFyIGRpc3RYID0gY2xpZW50WCAtIHN0YXJ0WDtcbiAgdmFyIGRpc3RZID0gY2xpZW50WSAtIHN0YXJ0WTtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRYOiBvcmlnaW5hbENsaWVudFgsXG4gICAgY2xpZW50WTogb3JpZ2luYWxDbGllbnRZLFxuICAgIGRlbHRhWDogZGVsdGFYLFxuICAgIGRlbHRhWTogZGVsdGFZLFxuICAgIGRpc3RYOiBkaXN0WCxcbiAgICBkaXN0WTogZGlzdFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERpc3QoY2xpZW50cykge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGNsaWVudHNbMF0uY2xpZW50WCAtIGNsaWVudHNbMV0uY2xpZW50WCwgMikgKyBNYXRoLnBvdyhjbGllbnRzWzBdLmNsaWVudFkgLSBjbGllbnRzWzFdLmNsaWVudFksIDIpKTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudHModG91Y2hlcykge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4odG91Y2hlcy5sZW5ndGgsIDIpO1xuICB2YXIgY2xpZW50cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjbGllbnRzLnB1c2goZ2V0Q2xpZW50KHRvdWNoZXNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBjbGllbnRzO1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50KGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgY2xpZW50WTogZS5jbGllbnRZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBdmVyYWdlQ2xpZW50KGNsaWVudHMsIGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICBsZW5ndGggPSBjbGllbnRzLmxlbmd0aDtcbiAgfVxuXG4gIHZhciBzdW1DbGllbnQgPSB7XG4gICAgY2xpZW50WDogMCxcbiAgICBjbGllbnRZOiAwLFxuICAgIG9yaWdpbmFsQ2xpZW50WDogMCxcbiAgICBvcmlnaW5hbENsaWVudFk6IDBcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNsaWVudCA9IGNsaWVudHNbaV07XG4gICAgc3VtQ2xpZW50Lm9yaWdpbmFsQ2xpZW50WCArPSBcIm9yaWdpbmFsQ2xpZW50WFwiIGluIGNsaWVudCA/IGNsaWVudC5vcmlnaW5hbENsaWVudFggOiBjbGllbnQuY2xpZW50WDtcbiAgICBzdW1DbGllbnQub3JpZ2luYWxDbGllbnRZICs9IFwib3JpZ2luYWxDbGllbnRZXCIgaW4gY2xpZW50ID8gY2xpZW50Lm9yaWdpbmFsQ2xpZW50WSA6IGNsaWVudC5jbGllbnRZO1xuICAgIHN1bUNsaWVudC5jbGllbnRYICs9IGNsaWVudC5jbGllbnRYO1xuICAgIHN1bUNsaWVudC5jbGllbnRZICs9IGNsaWVudC5jbGllbnRZO1xuICB9XG5cbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gc3VtQ2xpZW50O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjbGllbnRYOiBzdW1DbGllbnQuY2xpZW50WCAvIGxlbmd0aCxcbiAgICBjbGllbnRZOiBzdW1DbGllbnQuY2xpZW50WSAvIGxlbmd0aCxcbiAgICBvcmlnaW5hbENsaWVudFg6IHN1bUNsaWVudC5vcmlnaW5hbENsaWVudFggLyBsZW5ndGgsXG4gICAgb3JpZ2luYWxDbGllbnRZOiBzdW1DbGllbnQub3JpZ2luYWxDbGllbnRZIC8gbGVuZ3RoXG4gIH07XG59XG5cbnZhciBDbGllbnRTdG9yZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENsaWVudFN0b3JlKGNsaWVudHMpIHtcbiAgICB0aGlzLnByZXZDbGllbnRzID0gW107XG4gICAgdGhpcy5zdGFydENsaWVudHMgPSBbXTtcbiAgICB0aGlzLm1vdmVtZW50ID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zdGFydENsaWVudHMgPSBjbGllbnRzO1xuICAgIHRoaXMucHJldkNsaWVudHMgPSBjbGllbnRzO1xuICAgIHRoaXMubGVuZ3RoID0gY2xpZW50cy5sZW5ndGg7XG4gIH1cblxuICB2YXIgX19wcm90byA9IENsaWVudFN0b3JlLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmdldEFuZ2xlID0gZnVuY3Rpb24gKGNsaWVudHMpIHtcbiAgICBpZiAoY2xpZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICBjbGllbnRzID0gdGhpcy5wcmV2Q2xpZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0Um90YXRpaW9uKGNsaWVudHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRSb3RhdGlpb24oY2xpZW50cykgLSBnZXRSb3RhdGlpb24odGhpcy5zdGFydENsaWVudHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoY2xpZW50cywgaXNBZGQpIHtcbiAgICBpZiAoY2xpZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICBjbGllbnRzID0gdGhpcy5wcmV2Q2xpZW50cztcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihjbGllbnRzIHx8IHRoaXMucHJldkNsaWVudHMsIHRoaXMucHJldkNsaWVudHMsIHRoaXMuc3RhcnRDbGllbnRzKTtcbiAgICB2YXIgZGVsdGFYID0gcG9zaXRpb24uZGVsdGFYLFxuICAgICAgICBkZWx0YVkgPSBwb3NpdGlvbi5kZWx0YVk7XG4gICAgdGhpcy5tb3ZlbWVudCArPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKTtcbiAgICB0aGlzLnByZXZDbGllbnRzID0gY2xpZW50cztcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH07XG5cbiAgX19wcm90by5nZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHZhciBwcmV2Q2xpZW50cyA9IHRoaXMucHJldkNsaWVudHM7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRDbGllbnRzLm1hcChmdW5jdGlvbiAoc3RhcnRDbGllbnQsIGkpIHtcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbihbY2xpZW50c1tpXV0sIFtwcmV2Q2xpZW50c1tpXV0sIFtzdGFydENsaWVudF0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIHZhciBtb3ZlbWVudCA9IHRoaXMubW92ZW1lbnQ7XG5cbiAgICBpZiAoIWNsaWVudHMpIHtcbiAgICAgIHJldHVybiBtb3ZlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudENsaWVudCA9IGdldEF2ZXJhZ2VDbGllbnQoY2xpZW50cywgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBwcmV2Q2xpZW50ID0gZ2V0QXZlcmFnZUNsaWVudCh0aGlzLnByZXZDbGllbnRzLCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGRlbHRhWCA9IGN1cnJlbnRDbGllbnQuY2xpZW50WCAtIHByZXZDbGllbnQuY2xpZW50WDtcbiAgICB2YXIgZGVsdGFZID0gY3VycmVudENsaWVudC5jbGllbnRZIC0gcHJldkNsaWVudC5jbGllbnRZO1xuICAgIHJldHVybiBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKSArIG1vdmVtZW50O1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBnZXREaXN0KGNsaWVudHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0U2NhbGUgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBnZXREaXN0KGNsaWVudHMpIC8gZ2V0RGlzdCh0aGlzLnN0YXJ0Q2xpZW50cyk7XG4gIH07XG5cbiAgX19wcm90by5tb3ZlID0gZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdGhpcy5zdGFydENsaWVudHMuZm9yRWFjaChmdW5jdGlvbiAoY2xpZW50KSB7XG4gICAgICBjbGllbnQuY2xpZW50WCAtPSBkZWx0YVg7XG4gICAgICBjbGllbnQuY2xpZW50WSAtPSBkZWx0YVk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIENsaWVudFN0b3JlO1xufSgpO1xuXG52YXIgSU5QVVRfVEFHTkFNRVMgPSBbXCJ0ZXh0YXJlYVwiLCBcImlucHV0XCJdO1xuLyoqXG4gKiBZb3UgY2FuIHNldCB1cCBkcmFnLCBwaW5jaCBldmVudHMgaW4gYW55IGJyb3dzZXIuXG4gKi9cblxudmFyIEdlc3RvID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEdlc3RvLCBfc3VwZXIpO1xuICAvKipcbiAgICpcbiAgICovXG5cblxuICBmdW5jdGlvbiBHZXN0byh0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5vcHRpb25zID0ge307XG4gICAgX3RoaXMuZmxhZyA9IGZhbHNlO1xuICAgIF90aGlzLnBpbmNoRmxhZyA9IGZhbHNlO1xuICAgIF90aGlzLmRhdGFzID0ge307XG4gICAgX3RoaXMuaXNEcmFnID0gZmFsc2U7XG4gICAgX3RoaXMuaXNQaW5jaCA9IGZhbHNlO1xuICAgIF90aGlzLmlzTW91c2UgPSBmYWxzZTtcbiAgICBfdGhpcy5pc1RvdWNoID0gZmFsc2U7XG4gICAgX3RoaXMuY2xpZW50U3RvcmVzID0gW107XG4gICAgX3RoaXMudGFyZ2V0cyA9IFtdO1xuICAgIF90aGlzLnByZXZUaW1lID0gMDtcbiAgICBfdGhpcy5kb3VibGVGbGFnID0gZmFsc2U7XG4gICAgX3RoaXMuX2RyYWdGbGFnID0gZmFsc2U7XG5cbiAgICBfdGhpcy5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCBpc1RydXN0ZWQpIHtcbiAgICAgIGlmIChpc1RydXN0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgICBpc1RydXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV90aGlzLmZsYWcgJiYgZS5jYW5jZWxhYmxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfYSA9IF90aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY29udGFpbmVyID0gX2EuY29udGFpbmVyLFxuICAgICAgICAgIHBpbmNoT3V0c2lkZSA9IF9hLnBpbmNoT3V0c2lkZSxcbiAgICAgICAgICBwcmV2ZW50UmlnaHRDbGljayA9IF9hLnByZXZlbnRSaWdodENsaWNrLFxuICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gX2EucHJldmVudERlZmF1bHQsXG4gICAgICAgICAgY2hlY2tJbnB1dCA9IF9hLmNoZWNrSW5wdXQ7XG4gICAgICB2YXIgaXNUb3VjaCA9IF90aGlzLmlzVG91Y2g7XG4gICAgICB2YXIgaXNEcmFnU3RhcnQgPSAhX3RoaXMuZmxhZztcblxuICAgICAgaWYgKGlzRHJhZ1N0YXJ0KSB7XG4gICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBoYXNJbnB1dCA9IElOUFVUX1RBR05BTUVTLmluZGV4T2YodGFnTmFtZSkgPiAtMTtcbiAgICAgICAgdmFyIGhhc0NvbnRlbnRFZGl0YWJsZSA9IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZTtcblxuICAgICAgICBpZiAoaGFzSW5wdXQgfHwgaGFzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgaWYgKGNoZWNrSW5wdXQgfHwgYWN0aXZlRWxlbWVudCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBmb3JjZSBmYWxzZSBvciBhbHJlYWR5IGZvY3VzZWQuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSAvLyBubyBmb2N1c1xuXG5cbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBoYXNDb250ZW50RWRpdGFibGUgJiYgYWN0aXZlRWxlbWVudC5pc0NvbnRlbnRFZGl0YWJsZSAmJiBhY3RpdmVFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKHByZXZlbnREZWZhdWx0IHx8IGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpICYmIGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgYWN0aXZlVGFnTmFtZSA9IGFjdGl2ZUVsZW1lbnQudGFnTmFtZTtcblxuICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50LmlzQ29udGVudEVkaXRhYmxlIHx8IElOUFVUX1RBR05BTUVTLmluZGV4T2YoYWN0aXZlVGFnTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuY2xpZW50U3RvcmVzID0gW25ldyBDbGllbnRTdG9yZShnZXRFdmVudENsaWVudHMoZSkpXTtcbiAgICAgICAgX3RoaXMuZmxhZyA9IHRydWU7XG4gICAgICAgIF90aGlzLmlzRHJhZyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fZHJhZ0ZsYWcgPSB0cnVlO1xuICAgICAgICBfdGhpcy5kYXRhcyA9IHt9O1xuXG4gICAgICAgIGlmIChwcmV2ZW50UmlnaHRDbGljayAmJiAoZS53aGljaCA9PT0gMyB8fCBlLmJ1dHRvbiA9PT0gMikpIHtcbiAgICAgICAgICBfdGhpcy5pbml0RHJhZygpO1xuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZG91YmxlRmxhZyA9IG5vdygpIC0gX3RoaXMucHJldlRpbWUgPCAyMDA7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLmVtaXQoXCJkcmFnU3RhcnRcIiwgX19hc3NpZ24oe1xuICAgICAgICAgIGRhdGFzOiBfdGhpcy5kYXRhcyxcbiAgICAgICAgICBpbnB1dEV2ZW50OiBlLFxuICAgICAgICAgIGlzVHJ1c3RlZDogaXNUcnVzdGVkLFxuICAgICAgICAgIGlzRG91YmxlOiBfdGhpcy5kb3VibGVGbGFnXG4gICAgICAgIH0sIF90aGlzLmdldEN1cnJlbnRTdG9yZSgpLmdldFBvc2l0aW9uKCksIHtcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJldmVudERyYWc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9kcmFnRmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgX3RoaXMuaW5pdERyYWcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmZsYWcgJiYgcHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV90aGlzLmZsYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZXIgPSAwO1xuXG4gICAgICBpZiAoaXNEcmFnU3RhcnQgJiYgaXNUb3VjaCAmJiBwaW5jaE91dHNpZGUpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhZGRFdmVudChjb250YWluZXIsIFwidG91Y2hzdGFydFwiLCBfdGhpcy5vbkRyYWdTdGFydCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNEcmFnU3RhcnQgJiYgaXNUb3VjaCAmJiBwaW5jaE91dHNpZGUpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcInRvdWNoc3RhcnRcIiwgX3RoaXMub25EcmFnU3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuZmxhZyAmJiBpc011bHRpVG91Y2goZSkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICBpZiAoaXNEcmFnU3RhcnQgJiYgZS50b3VjaGVzLmxlbmd0aCAhPT0gZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV90aGlzLnBpbmNoRmxhZykge1xuICAgICAgICAgIF90aGlzLm9uUGluY2hTdGFydChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkRyYWcgPSBmdW5jdGlvbiAoZSwgaXNTY3JvbGwpIHtcbiAgICAgIGlmICghX3RoaXMuZmxhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGllbnRzID0gZ2V0RXZlbnRDbGllbnRzKGUpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gX3RoaXMubW92ZUNsaWVudHMoY2xpZW50cywgZSwgZmFsc2UpO1xuXG4gICAgICBpZiAoX3RoaXMuX2RyYWdGbGFnKSB7XG4gICAgICAgIGlmIChfdGhpcy5waW5jaEZsYWcgfHwgcmVzdWx0LmRlbHRhWCB8fCByZXN1bHQuZGVsdGFZKSB7XG4gICAgICAgICAgdmFyIGRyYWdSZXN1bHQgPSBfdGhpcy5lbWl0KFwiZHJhZ1wiLCBfX2Fzc2lnbih7fSwgcmVzdWx0LCB7XG4gICAgICAgICAgICBpc1Njcm9sbDogISFpc1Njcm9sbCxcbiAgICAgICAgICAgIGlucHV0RXZlbnQ6IGVcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBpZiAoZHJhZ1Jlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF90aGlzLnN0b3AoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcy5waW5jaEZsYWcpIHtcbiAgICAgICAgICBfdGhpcy5vblBpbmNoKGUsIGNsaWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmdldEN1cnJlbnRTdG9yZSgpLmdldFBvc2l0aW9uKGNsaWVudHMsIHRydWUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFfdGhpcy5mbGFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9hID0gX3RoaXMub3B0aW9ucyxcbiAgICAgICAgICBwaW5jaE91dHNpZGUgPSBfYS5waW5jaE91dHNpZGUsXG4gICAgICAgICAgY29udGFpbmVyID0gX2EuY29udGFpbmVyO1xuXG4gICAgICBpZiAoX3RoaXMuaXNUb3VjaCAmJiBwaW5jaE91dHNpZGUpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcInRvdWNoc3RhcnRcIiwgX3RoaXMub25EcmFnU3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5mbGFnID0gZmFsc2U7XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IF90aGlzLl9nZXRQb3NpdGlvbigpO1xuXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICAgIHZhciBpc0RvdWJsZSA9ICFfdGhpcy5pc0RyYWcgJiYgX3RoaXMuZG91YmxlRmxhZztcbiAgICAgIF90aGlzLnByZXZUaW1lID0gX3RoaXMuaXNEcmFnIHx8IGlzRG91YmxlID8gMCA6IGN1cnJlbnRUaW1lO1xuXG4gICAgICBfdGhpcy5lbWl0KFwiZHJhZ0VuZFwiLCBfX2Fzc2lnbih7XG4gICAgICAgIGRhdGFzOiBfdGhpcy5kYXRhcyxcbiAgICAgICAgaXNEb3VibGU6IGlzRG91YmxlLFxuICAgICAgICBpc0RyYWc6IF90aGlzLmlzRHJhZyxcbiAgICAgICAgaXNDbGljazogIV90aGlzLmlzRHJhZyxcbiAgICAgICAgaW5wdXRFdmVudDogZVxuICAgICAgfSwgcG9zaXRpb24pKTtcblxuICAgICAgaWYgKF90aGlzLnBpbmNoRmxhZykge1xuICAgICAgICBfdGhpcy5vblBpbmNoRW5kKGUpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jbGllbnRTdG9yZXMgPSBbXTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25EcmFnRW5kKCk7XG4gICAgfTtcblxuICAgIHZhciBlbGVtZW50cyA9IFtdLmNvbmNhdCh0YXJnZXRzKTtcbiAgICBfdGhpcy5vcHRpb25zID0gX19hc3NpZ24oe1xuICAgICAgY2hlY2tJbnB1dDogZmFsc2UsXG4gICAgICBjb250YWluZXI6IGVsZW1lbnRzLmxlbmd0aCA+IDEgPyB3aW5kb3cgOiBlbGVtZW50c1swXSxcbiAgICAgIHByZXZlbnRSaWdodENsaWNrOiB0cnVlLFxuICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICBjaGVja1dpbmRvd0JsdXI6IGZhbHNlLFxuICAgICAgcGluY2hUaHJlc2hvbGQ6IDAsXG4gICAgICBldmVudHM6IFtcInRvdWNoXCIsIFwibW91c2VcIl1cbiAgICB9LCBvcHRpb25zKTtcbiAgICB2YXIgX2EgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICBjb250YWluZXIgPSBfYS5jb250YWluZXIsXG4gICAgICAgIGV2ZW50cyA9IF9hLmV2ZW50cyxcbiAgICAgICAgY2hlY2tXaW5kb3dCbHVyID0gX2EuY2hlY2tXaW5kb3dCbHVyO1xuICAgIF90aGlzLmlzVG91Y2ggPSBldmVudHMuaW5kZXhPZihcInRvdWNoXCIpID4gLTE7XG4gICAgX3RoaXMuaXNNb3VzZSA9IGV2ZW50cy5pbmRleE9mKFwibW91c2VcIikgPiAtMTtcbiAgICBfdGhpcy50YXJnZXRzID0gZWxlbWVudHM7XG5cbiAgICBpZiAoX3RoaXMuaXNNb3VzZSkge1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgYWRkRXZlbnQoZWwsIFwibW91c2Vkb3duXCIsIF90aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgIH0pO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcIm1vdXNlbW92ZVwiLCBfdGhpcy5vbkRyYWcpO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcIm1vdXNldXBcIiwgX3RoaXMub25EcmFnRW5kKTtcbiAgICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgXCJjb250ZXh0bWVudVwiLCBfdGhpcy5vbkRyYWdFbmQpO1xuICAgIH1cblxuICAgIGlmIChjaGVja1dpbmRvd0JsdXIpIHtcbiAgICAgIGFkZEV2ZW50KHdpbmRvdywgXCJibHVyXCIsIF90aGlzLm9uQmx1cik7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmlzVG91Y2gpIHtcbiAgICAgIHZhciBwYXNzaXZlXzEgPSB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgYWRkRXZlbnQoZWwsIFwidG91Y2hzdGFydFwiLCBfdGhpcy5vbkRyYWdTdGFydCwgcGFzc2l2ZV8xKTtcbiAgICAgIH0pO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcInRvdWNobW92ZVwiLCBfdGhpcy5vbkRyYWcsIHBhc3NpdmVfMSk7XG4gICAgICBhZGRFdmVudChjb250YWluZXIsIFwidG91Y2hlbmRcIiwgX3RoaXMub25EcmFnRW5kLCBwYXNzaXZlXzEpO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcInRvdWNoY2FuY2VsXCIsIF90aGlzLm9uRHJhZ0VuZCwgcGFzc2l2ZV8xKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgR2VzdG8ncyBkcmFnIGV2ZW50cy5cbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IEdlc3RvLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0RyYWcgPSBmYWxzZTtcbiAgICB0aGlzLmZsYWcgPSBmYWxzZTtcbiAgICB0aGlzLmNsaWVudFN0b3JlcyA9IFtdO1xuICAgIHRoaXMuZGF0YXMgPSB7fTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBtb3ZlZCBkaXN0YW5jZVxuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRTdG9yZSgpLmdldE1vdmVtZW50KGNsaWVudHMpICsgdGhpcy5jbGllbnRTdG9yZXMuc2xpY2UoMSkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgIHJldHVybiBwcmV2ICsgY3VyLm1vdmVtZW50O1xuICAgIH0sIDApO1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0byBkcmFnXG4gICAqL1xuXG5cbiAgX19wcm90by5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzRHJhZztcbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RhcnQgZHJhZ1xuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNGbGFnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZsYWc7XG4gIH07XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0YXJ0IHBpbmNoXG4gICAqL1xuXG5cbiAgX19wcm90by5pc1BpbmNoRmxhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5waW5jaEZsYWc7XG4gIH07XG4gIC8qKlxuICAqIFdoZXRoZXIgdG8gc3RhcnQgZG91YmxlIGNsaWNrXG4gICovXG5cblxuICBfX3Byb3RvLmlzRG91YmxlRmxhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kb3VibGVGbGFnO1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0byBwaW5jaFxuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNQaW5jaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpbmNoO1xuICB9O1xuICAvKipcbiAgICogSWYgYSBzY3JvbGwgZXZlbnQgb2NjdXJzLCBpdCBpcyBjb3JyZWN0ZWQgYnkgdGhlIHNjcm9sbCBkaXN0YW5jZS5cbiAgICovXG5cblxuICBfX3Byb3RvLnNjcm9sbEJ5ID0gZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZLCBlLCBpc0NhbGxEcmFnKSB7XG4gICAgaWYgKGlzQ2FsbERyYWcgPT09IHZvaWQgMCkge1xuICAgICAgaXNDYWxsRHJhZyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZsYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsaWVudFN0b3Jlc1swXS5tb3ZlKGRlbHRhWCwgZGVsdGFZKTtcbiAgICBpc0NhbGxEcmFnICYmIHRoaXMub25EcmFnKGUsIHRydWUpO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlIGEgdmlydHVhbCBkcmFnIGV2ZW50LlxuICAgKi9cblxuXG4gIF9fcHJvdG8ubW92ZSA9IGZ1bmN0aW9uIChfYSwgaW5wdXRFdmVudCkge1xuICAgIHZhciBkZWx0YVggPSBfYVswXSxcbiAgICAgICAgZGVsdGFZID0gX2FbMV07XG4gICAgdmFyIHN0b3JlID0gdGhpcy5nZXRDdXJyZW50U3RvcmUoKTtcbiAgICB2YXIgbmV4dENsaWVudHMgPSBzdG9yZS5wcmV2Q2xpZW50cztcbiAgICByZXR1cm4gdGhpcy5tb3ZlQ2xpZW50cyhuZXh0Q2xpZW50cy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IF9hLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IF9hLmNsaWVudFk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRYOiBjbGllbnRYICsgZGVsdGFYLFxuICAgICAgICBjbGllbnRZOiBjbGllbnRZICsgZGVsdGFZLFxuICAgICAgICBvcmlnaW5hbENsaWVudFg6IGNsaWVudFgsXG4gICAgICAgIG9yaWdpbmFsQ2xpZW50WTogY2xpZW50WVxuICAgICAgfTtcbiAgICB9KSwgaW5wdXRFdmVudCwgdHJ1ZSk7XG4gIH07XG4gIC8qKlxuICAgKiBUaGUgZHJhZ1N0YXJ0IGV2ZW50IGlzIHRyaWdnZXJlZCBieSBhbiBleHRlcm5hbCBldmVudC5cbiAgICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXJEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHRoaXMub25EcmFnU3RhcnQoZSwgZmFsc2UpO1xuICB9O1xuICAvKipcbiAgICogU2V0IHRoZSBldmVudCBkYXRhIHdoaWxlIGRyYWdnaW5nLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uc2V0RXZlbnREYXRhcyA9IGZ1bmN0aW9uIChkYXRhcykge1xuICAgIHZhciBjdXJyZW50RGF0YXMgPSB0aGlzLmRhdGFzO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBkYXRhcykge1xuICAgICAgY3VycmVudERhdGFzW25hbWVdID0gZGF0YXNbbmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZXZlbnQgc3RhdGUgd2hpbGUgZHJhZ2dpbmcuXG4gICAqL1xuXG5cbiAgX19wcm90by5nZXRDdXJyZW50RXZlbnQgPSBmdW5jdGlvbiAoaW5wdXRFdmVudCkge1xuICAgIHJldHVybiBfX2Fzc2lnbih7XG4gICAgICBkYXRhczogdGhpcy5kYXRhc1xuICAgIH0sIHRoaXMuX2dldFBvc2l0aW9uKCksIHtcbiAgICAgIG1vdmVtZW50OiB0aGlzLmdldE1vdmVtZW50KCksXG4gICAgICBpc0RyYWc6IHRoaXMuaXNEcmFnLFxuICAgICAgaXNQaW5jaDogdGhpcy5pc1BpbmNoLFxuICAgICAgaXNTY3JvbGw6IGZhbHNlLFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudFxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogR2V0ICYgU2V0IHRoZSBldmVudCBkYXRhIHdoaWxlIGRyYWdnaW5nLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0RXZlbnREYXRhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhcztcbiAgfTtcbiAgLyoqXG4gICAqIFVuc2V0IEdlc3RvXG4gICAqL1xuXG5cbiAgX19wcm90by51bnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRhcmdldHMgPSB0aGlzLnRhcmdldHM7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5vZmYoKTtcbiAgICByZW1vdmVFdmVudCh3aW5kb3csIFwiYmx1clwiLCB0aGlzLm9uQmx1cik7XG5cbiAgICBpZiAodGhpcy5pc01vdXNlKSB7XG4gICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICByZW1vdmVFdmVudCh0YXJnZXQsIFwibW91c2Vkb3duXCIsIF90aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcIm1vdXNlbW92ZVwiLCB0aGlzLm9uRHJhZyk7XG4gICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwibW91c2V1cFwiLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwiY29udGV4dG1lbnVcIiwgdGhpcy5vbkRyYWdFbmQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzVG91Y2gpIHtcbiAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHJlbW92ZUV2ZW50KHRhcmdldCwgXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwidG91Y2htb3ZlXCIsIHRoaXMub25EcmFnKTtcbiAgICAgIHJlbW92ZUV2ZW50KGNvbnRhaW5lciwgXCJ0b3VjaGVuZFwiLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwidG91Y2hjYW5jZWxcIiwgdGhpcy5vbkRyYWdFbmQpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLm9uUGluY2hTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHBpbmNoVGhyZXNob2xkID0gdGhpcy5vcHRpb25zLnBpbmNoVGhyZXNob2xkO1xuXG4gICAgaWYgKHRoaXMuaXNEcmFnICYmIHRoaXMuZ2V0TW92ZW1lbnQoKSA+IHBpbmNoVGhyZXNob2xkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0b3JlID0gbmV3IENsaWVudFN0b3JlKGdldEV2ZW50Q2xpZW50cyhlKSk7XG4gICAgdGhpcy5waW5jaEZsYWcgPSB0cnVlO1xuICAgIHRoaXMuY2xpZW50U3RvcmVzLnNwbGljZSgwLCAwLCBzdG9yZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZW1pdChcInBpbmNoU3RhcnRcIiwgX19hc3NpZ24oe1xuICAgICAgZGF0YXM6IHRoaXMuZGF0YXMsXG4gICAgICBhbmdsZTogc3RvcmUuZ2V0QW5nbGUoKSxcbiAgICAgIHRvdWNoZXM6IHRoaXMuZ2V0Q3VycmVudFN0b3JlKCkuZ2V0UG9zaXRpb25zKClcbiAgICB9LCBzdG9yZS5nZXRQb3NpdGlvbigpLCB7XG4gICAgICBpbnB1dEV2ZW50OiBlXG4gICAgfSkpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucGluY2hGbGFnID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8ub25QaW5jaCA9IGZ1bmN0aW9uIChlLCBjbGllbnRzKSB7XG4gICAgaWYgKCF0aGlzLmZsYWcgfHwgIXRoaXMucGluY2hGbGFnIHx8IGNsaWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdG9yZSA9IHRoaXMuZ2V0Q3VycmVudFN0b3JlKCk7XG4gICAgdGhpcy5pc1BpbmNoID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJwaW5jaFwiLCBfX2Fzc2lnbih7XG4gICAgICBkYXRhczogdGhpcy5kYXRhcyxcbiAgICAgIG1vdmVtZW50OiB0aGlzLmdldE1vdmVtZW50KGNsaWVudHMpLFxuICAgICAgYW5nbGU6IHN0b3JlLmdldEFuZ2xlKGNsaWVudHMpLFxuICAgICAgcm90YXRpb246IHN0b3JlLmdldFJvdGF0aW9uKGNsaWVudHMpLFxuICAgICAgdG91Y2hlczogc3RvcmUuZ2V0UG9zaXRpb25zKGNsaWVudHMpLFxuICAgICAgc2NhbGU6IHN0b3JlLmdldFNjYWxlKGNsaWVudHMpLFxuICAgICAgZGlzdGFuY2U6IHN0b3JlLmdldERpc3RhbmNlKGNsaWVudHMpXG4gICAgfSwgc3RvcmUuZ2V0UG9zaXRpb24oY2xpZW50cyksIHtcbiAgICAgIGlucHV0RXZlbnQ6IGVcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5vblBpbmNoRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIXRoaXMucGluY2hGbGFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlzUGluY2ggPSB0aGlzLmlzUGluY2g7XG4gICAgdGhpcy5pc1BpbmNoID0gZmFsc2U7XG4gICAgdGhpcy5waW5jaEZsYWcgPSBmYWxzZTtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLmdldEN1cnJlbnRTdG9yZSgpO1xuICAgIHRoaXMuZW1pdChcInBpbmNoRW5kXCIsIF9fYXNzaWduKHtcbiAgICAgIGRhdGFzOiB0aGlzLmRhdGFzLFxuICAgICAgaXNQaW5jaDogaXNQaW5jaCxcbiAgICAgIHRvdWNoZXM6IHN0b3JlLmdldFBvc2l0aW9ucygpXG4gICAgfSwgc3RvcmUuZ2V0UG9zaXRpb24oKSwge1xuICAgICAgaW5wdXRFdmVudDogZVxuICAgIH0pKTtcbiAgICB0aGlzLmlzUGluY2ggPSBmYWxzZTtcbiAgICB0aGlzLnBpbmNoRmxhZyA9IGZhbHNlO1xuICB9O1xuXG4gIF9fcHJvdG8uaW5pdERyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGllbnRTdG9yZXMgPSBbXTtcbiAgICB0aGlzLnBpbmNoRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMuZG91YmxlRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMucHJldlRpbWUgPSAwO1xuICAgIHRoaXMuZmxhZyA9IGZhbHNlO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0Q3VycmVudFN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudFN0b3Jlc1swXTtcbiAgfTtcblxuICBfX3Byb3RvLm1vdmVDbGllbnRzID0gZnVuY3Rpb24gKGNsaWVudHMsIGlucHV0RXZlbnQsIGlzQWRkKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb24oY2xpZW50cywgaXNBZGQpO1xuXG4gICAgaWYgKHBvc2l0aW9uLmRlbHRhWCB8fCBwb3NpdGlvbi5kZWx0YVkpIHtcbiAgICAgIHRoaXMuaXNEcmFnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX19hc3NpZ24oe1xuICAgICAgZGF0YXM6IHRoaXMuZGF0YXNcbiAgICB9LCBwb3NpdGlvbiwge1xuICAgICAgbW92ZW1lbnQ6IHRoaXMuZ2V0TW92ZW1lbnQoY2xpZW50cyksXG4gICAgICBpc0RyYWc6IHRoaXMuaXNEcmFnLFxuICAgICAgaXNQaW5jaDogdGhpcy5pc1BpbmNoLFxuICAgICAgaXNTY3JvbGw6IGZhbHNlLFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudFxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2dldFBvc2l0aW9uID0gZnVuY3Rpb24gKGNsaWVudHMsIGlzQWRkKSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5nZXRDdXJyZW50U3RvcmUoKTtcbiAgICB2YXIgcG9zaXRpb24gPSBzdG9yZS5nZXRQb3NpdGlvbihjbGllbnRzLCBpc0FkZCk7XG5cbiAgICB2YXIgX2EgPSB0aGlzLmNsaWVudFN0b3Jlcy5zbGljZSgxKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgICAgdmFyIHN0b3JlUG9zaXRpb24gPSBjdXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgIHByZXYuZGlzdFggKz0gc3RvcmVQb3NpdGlvbi5kaXN0WDtcbiAgICAgIHByZXYuZGlzdFkgKz0gc3RvcmVQb3NpdGlvbi5kaXN0WTtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIHBvc2l0aW9uKSxcbiAgICAgICAgZGlzdFggPSBfYS5kaXN0WCxcbiAgICAgICAgZGlzdFkgPSBfYS5kaXN0WTtcblxuICAgIHJldHVybiBfX2Fzc2lnbih7fSwgcG9zaXRpb24sIHtcbiAgICAgIGRpc3RYOiBkaXN0WCxcbiAgICAgIGRpc3RZOiBkaXN0WVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBHZXN0bztcbn0oRXZlbnRFbWl0dGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgR2VzdG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXN0by5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBnZXN0b1xubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2dlc3RvLmdpdFxudmVyc2lvbjogMS45LjBcbiovXG5pbXBvcnQgeyByZW1vdmVFdmVudCwgbm93LCBhZGRFdmVudCB9IGZyb20gJ0BkYXlicnVzaC91dGlscyc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ0BzY2VuYS9ldmVudC1lbWl0dGVyJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gZ2V0UmFkKHBvczEsIHBvczIpIHtcbiAgdmFyIGRpc3RYID0gcG9zMlswXSAtIHBvczFbMF07XG4gIHZhciBkaXN0WSA9IHBvczJbMV0gLSBwb3MxWzFdO1xuICB2YXIgcmFkID0gTWF0aC5hdGFuMihkaXN0WSwgZGlzdFgpO1xuICByZXR1cm4gcmFkID49IDAgPyByYWQgOiByYWQgKyBNYXRoLlBJICogMjtcbn1cbmZ1bmN0aW9uIGdldFJvdGF0aWlvbih0b3VjaGVzKSB7XG4gIHJldHVybiBnZXRSYWQoW3RvdWNoZXNbMF0uY2xpZW50WCwgdG91Y2hlc1swXS5jbGllbnRZXSwgW3RvdWNoZXNbMV0uY2xpZW50WCwgdG91Y2hlc1sxXS5jbGllbnRZXSkgLyBNYXRoLlBJICogMTgwO1xufVxuZnVuY3Rpb24gaXNNdWx0aVRvdWNoKGUpIHtcbiAgcmV0dXJuIGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID49IDI7XG59XG5mdW5jdGlvbiBnZXRFdmVudENsaWVudHMoZSkge1xuICBpZiAoIWUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAoZS50b3VjaGVzKSB7XG4gICAgcmV0dXJuIGdldENsaWVudHMoZS50b3VjaGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2dldENsaWVudChlKV07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGNsaWVudHMsIHByZXZDbGllbnRzLCBzdGFydENsaWVudHMpIHtcbiAgdmFyIGxlbmd0aCA9IHN0YXJ0Q2xpZW50cy5sZW5ndGg7XG5cbiAgdmFyIF9hID0gZ2V0QXZlcmFnZUNsaWVudChjbGllbnRzLCBsZW5ndGgpLFxuICAgICAgY2xpZW50WCA9IF9hLmNsaWVudFgsXG4gICAgICBjbGllbnRZID0gX2EuY2xpZW50WSxcbiAgICAgIG9yaWdpbmFsQ2xpZW50WCA9IF9hLm9yaWdpbmFsQ2xpZW50WCxcbiAgICAgIG9yaWdpbmFsQ2xpZW50WSA9IF9hLm9yaWdpbmFsQ2xpZW50WTtcblxuICB2YXIgX2IgPSBnZXRBdmVyYWdlQ2xpZW50KHByZXZDbGllbnRzLCBsZW5ndGgpLFxuICAgICAgcHJldlggPSBfYi5jbGllbnRYLFxuICAgICAgcHJldlkgPSBfYi5jbGllbnRZO1xuXG4gIHZhciBfYyA9IGdldEF2ZXJhZ2VDbGllbnQoc3RhcnRDbGllbnRzLCBsZW5ndGgpLFxuICAgICAgc3RhcnRYID0gX2MuY2xpZW50WCxcbiAgICAgIHN0YXJ0WSA9IF9jLmNsaWVudFk7XG5cbiAgdmFyIGRlbHRhWCA9IGNsaWVudFggLSBwcmV2WDtcbiAgdmFyIGRlbHRhWSA9IGNsaWVudFkgLSBwcmV2WTtcbiAgdmFyIGRpc3RYID0gY2xpZW50WCAtIHN0YXJ0WDtcbiAgdmFyIGRpc3RZID0gY2xpZW50WSAtIHN0YXJ0WTtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRYOiBvcmlnaW5hbENsaWVudFgsXG4gICAgY2xpZW50WTogb3JpZ2luYWxDbGllbnRZLFxuICAgIGRlbHRhWDogZGVsdGFYLFxuICAgIGRlbHRhWTogZGVsdGFZLFxuICAgIGRpc3RYOiBkaXN0WCxcbiAgICBkaXN0WTogZGlzdFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERpc3QoY2xpZW50cykge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGNsaWVudHNbMF0uY2xpZW50WCAtIGNsaWVudHNbMV0uY2xpZW50WCwgMikgKyBNYXRoLnBvdyhjbGllbnRzWzBdLmNsaWVudFkgLSBjbGllbnRzWzFdLmNsaWVudFksIDIpKTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudHModG91Y2hlcykge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4odG91Y2hlcy5sZW5ndGgsIDIpO1xuICB2YXIgY2xpZW50cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjbGllbnRzLnB1c2goZ2V0Q2xpZW50KHRvdWNoZXNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBjbGllbnRzO1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50KGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgY2xpZW50WTogZS5jbGllbnRZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBdmVyYWdlQ2xpZW50KGNsaWVudHMsIGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICBsZW5ndGggPSBjbGllbnRzLmxlbmd0aDtcbiAgfVxuXG4gIHZhciBzdW1DbGllbnQgPSB7XG4gICAgY2xpZW50WDogMCxcbiAgICBjbGllbnRZOiAwLFxuICAgIG9yaWdpbmFsQ2xpZW50WDogMCxcbiAgICBvcmlnaW5hbENsaWVudFk6IDBcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNsaWVudCA9IGNsaWVudHNbaV07XG4gICAgc3VtQ2xpZW50Lm9yaWdpbmFsQ2xpZW50WCArPSBcIm9yaWdpbmFsQ2xpZW50WFwiIGluIGNsaWVudCA/IGNsaWVudC5vcmlnaW5hbENsaWVudFggOiBjbGllbnQuY2xpZW50WDtcbiAgICBzdW1DbGllbnQub3JpZ2luYWxDbGllbnRZICs9IFwib3JpZ2luYWxDbGllbnRZXCIgaW4gY2xpZW50ID8gY2xpZW50Lm9yaWdpbmFsQ2xpZW50WSA6IGNsaWVudC5jbGllbnRZO1xuICAgIHN1bUNsaWVudC5jbGllbnRYICs9IGNsaWVudC5jbGllbnRYO1xuICAgIHN1bUNsaWVudC5jbGllbnRZICs9IGNsaWVudC5jbGllbnRZO1xuICB9XG5cbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gc3VtQ2xpZW50O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjbGllbnRYOiBzdW1DbGllbnQuY2xpZW50WCAvIGxlbmd0aCxcbiAgICBjbGllbnRZOiBzdW1DbGllbnQuY2xpZW50WSAvIGxlbmd0aCxcbiAgICBvcmlnaW5hbENsaWVudFg6IHN1bUNsaWVudC5vcmlnaW5hbENsaWVudFggLyBsZW5ndGgsXG4gICAgb3JpZ2luYWxDbGllbnRZOiBzdW1DbGllbnQub3JpZ2luYWxDbGllbnRZIC8gbGVuZ3RoXG4gIH07XG59XG5cbnZhciBDbGllbnRTdG9yZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENsaWVudFN0b3JlKGNsaWVudHMpIHtcbiAgICB0aGlzLnByZXZDbGllbnRzID0gW107XG4gICAgdGhpcy5zdGFydENsaWVudHMgPSBbXTtcbiAgICB0aGlzLm1vdmVtZW50ID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zdGFydENsaWVudHMgPSBjbGllbnRzO1xuICAgIHRoaXMucHJldkNsaWVudHMgPSBjbGllbnRzO1xuICAgIHRoaXMubGVuZ3RoID0gY2xpZW50cy5sZW5ndGg7XG4gIH1cblxuICB2YXIgX19wcm90byA9IENsaWVudFN0b3JlLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmdldEFuZ2xlID0gZnVuY3Rpb24gKGNsaWVudHMpIHtcbiAgICBpZiAoY2xpZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICBjbGllbnRzID0gdGhpcy5wcmV2Q2xpZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0Um90YXRpaW9uKGNsaWVudHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRSb3RhdGlpb24oY2xpZW50cykgLSBnZXRSb3RhdGlpb24odGhpcy5zdGFydENsaWVudHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoY2xpZW50cywgaXNBZGQpIHtcbiAgICBpZiAoY2xpZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICBjbGllbnRzID0gdGhpcy5wcmV2Q2xpZW50cztcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihjbGllbnRzIHx8IHRoaXMucHJldkNsaWVudHMsIHRoaXMucHJldkNsaWVudHMsIHRoaXMuc3RhcnRDbGllbnRzKTtcbiAgICB2YXIgZGVsdGFYID0gcG9zaXRpb24uZGVsdGFYLFxuICAgICAgICBkZWx0YVkgPSBwb3NpdGlvbi5kZWx0YVk7XG4gICAgdGhpcy5tb3ZlbWVudCArPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKTtcbiAgICB0aGlzLnByZXZDbGllbnRzID0gY2xpZW50cztcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH07XG5cbiAgX19wcm90by5nZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHZhciBwcmV2Q2xpZW50cyA9IHRoaXMucHJldkNsaWVudHM7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRDbGllbnRzLm1hcChmdW5jdGlvbiAoc3RhcnRDbGllbnQsIGkpIHtcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbihbY2xpZW50c1tpXV0sIFtwcmV2Q2xpZW50c1tpXV0sIFtzdGFydENsaWVudF0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIHZhciBtb3ZlbWVudCA9IHRoaXMubW92ZW1lbnQ7XG5cbiAgICBpZiAoIWNsaWVudHMpIHtcbiAgICAgIHJldHVybiBtb3ZlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudENsaWVudCA9IGdldEF2ZXJhZ2VDbGllbnQoY2xpZW50cywgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBwcmV2Q2xpZW50ID0gZ2V0QXZlcmFnZUNsaWVudCh0aGlzLnByZXZDbGllbnRzLCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGRlbHRhWCA9IGN1cnJlbnRDbGllbnQuY2xpZW50WCAtIHByZXZDbGllbnQuY2xpZW50WDtcbiAgICB2YXIgZGVsdGFZID0gY3VycmVudENsaWVudC5jbGllbnRZIC0gcHJldkNsaWVudC5jbGllbnRZO1xuICAgIHJldHVybiBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKSArIG1vdmVtZW50O1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBnZXREaXN0KGNsaWVudHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0U2NhbGUgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBnZXREaXN0KGNsaWVudHMpIC8gZ2V0RGlzdCh0aGlzLnN0YXJ0Q2xpZW50cyk7XG4gIH07XG5cbiAgX19wcm90by5tb3ZlID0gZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdGhpcy5zdGFydENsaWVudHMuZm9yRWFjaChmdW5jdGlvbiAoY2xpZW50KSB7XG4gICAgICBjbGllbnQuY2xpZW50WCAtPSBkZWx0YVg7XG4gICAgICBjbGllbnQuY2xpZW50WSAtPSBkZWx0YVk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIENsaWVudFN0b3JlO1xufSgpO1xuXG52YXIgSU5QVVRfVEFHTkFNRVMgPSBbXCJ0ZXh0YXJlYVwiLCBcImlucHV0XCJdO1xuLyoqXG4gKiBZb3UgY2FuIHNldCB1cCBkcmFnLCBwaW5jaCBldmVudHMgaW4gYW55IGJyb3dzZXIuXG4gKi9cblxudmFyIEdlc3RvID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEdlc3RvLCBfc3VwZXIpO1xuICAvKipcbiAgICpcbiAgICovXG5cblxuICBmdW5jdGlvbiBHZXN0byh0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5vcHRpb25zID0ge307XG4gICAgX3RoaXMuZmxhZyA9IGZhbHNlO1xuICAgIF90aGlzLnBpbmNoRmxhZyA9IGZhbHNlO1xuICAgIF90aGlzLmRhdGFzID0ge307XG4gICAgX3RoaXMuaXNEcmFnID0gZmFsc2U7XG4gICAgX3RoaXMuaXNQaW5jaCA9IGZhbHNlO1xuICAgIF90aGlzLmlzTW91c2UgPSBmYWxzZTtcbiAgICBfdGhpcy5pc1RvdWNoID0gZmFsc2U7XG4gICAgX3RoaXMuY2xpZW50U3RvcmVzID0gW107XG4gICAgX3RoaXMudGFyZ2V0cyA9IFtdO1xuICAgIF90aGlzLnByZXZUaW1lID0gMDtcbiAgICBfdGhpcy5kb3VibGVGbGFnID0gZmFsc2U7XG4gICAgX3RoaXMuX2RyYWdGbGFnID0gZmFsc2U7XG5cbiAgICBfdGhpcy5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCBpc1RydXN0ZWQpIHtcbiAgICAgIGlmIChpc1RydXN0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgICBpc1RydXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV90aGlzLmZsYWcgJiYgZS5jYW5jZWxhYmxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfYSA9IF90aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY29udGFpbmVyID0gX2EuY29udGFpbmVyLFxuICAgICAgICAgIHBpbmNoT3V0c2lkZSA9IF9hLnBpbmNoT3V0c2lkZSxcbiAgICAgICAgICBwcmV2ZW50V2hlZWxDbGljayA9IF9hLnByZXZlbnRXaGVlbENsaWNrLFxuICAgICAgICAgIHByZXZlbnRSaWdodENsaWNrID0gX2EucHJldmVudFJpZ2h0Q2xpY2ssXG4gICAgICAgICAgcHJldmVudERlZmF1bHQgPSBfYS5wcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICBjaGVja0lucHV0ID0gX2EuY2hlY2tJbnB1dDtcbiAgICAgIHZhciBpc1RvdWNoID0gX3RoaXMuaXNUb3VjaDtcbiAgICAgIHZhciBpc0RyYWdTdGFydCA9ICFfdGhpcy5mbGFnO1xuXG4gICAgICBpZiAocHJldmVudFdoZWVsQ2xpY2sgJiYgKGUud2hpY2ggPT09IDIgfHwgZS5idXR0b24gPT09IDEpIHx8IHByZXZlbnRSaWdodENsaWNrICYmIChlLndoaWNoID09PSAzIHx8IGUuYnV0dG9uID09PSAyKSkge1xuICAgICAgICBfdGhpcy5pbml0RHJhZygpO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRHJhZ1N0YXJ0KSB7XG4gICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBoYXNJbnB1dCA9IElOUFVUX1RBR05BTUVTLmluZGV4T2YodGFnTmFtZSkgPiAtMTtcbiAgICAgICAgdmFyIGhhc0NvbnRlbnRFZGl0YWJsZSA9IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZTtcblxuICAgICAgICBpZiAoaGFzSW5wdXQgfHwgaGFzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgaWYgKGNoZWNrSW5wdXQgfHwgYWN0aXZlRWxlbWVudCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBmb3JjZSBmYWxzZSBvciBhbHJlYWR5IGZvY3VzZWQuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSAvLyBubyBmb2N1c1xuXG5cbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBoYXNDb250ZW50RWRpdGFibGUgJiYgYWN0aXZlRWxlbWVudC5pc0NvbnRlbnRFZGl0YWJsZSAmJiBhY3RpdmVFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKHByZXZlbnREZWZhdWx0IHx8IGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpICYmIGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgYWN0aXZlVGFnTmFtZSA9IGFjdGl2ZUVsZW1lbnQudGFnTmFtZTtcblxuICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50LmlzQ29udGVudEVkaXRhYmxlIHx8IElOUFVUX1RBR05BTUVTLmluZGV4T2YoYWN0aXZlVGFnTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuY2xpZW50U3RvcmVzID0gW25ldyBDbGllbnRTdG9yZShnZXRFdmVudENsaWVudHMoZSkpXTtcbiAgICAgICAgX3RoaXMuZmxhZyA9IHRydWU7XG4gICAgICAgIF90aGlzLmlzRHJhZyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fZHJhZ0ZsYWcgPSB0cnVlO1xuICAgICAgICBfdGhpcy5kYXRhcyA9IHt9O1xuICAgICAgICBfdGhpcy5kb3VibGVGbGFnID0gbm93KCkgLSBfdGhpcy5wcmV2VGltZSA8IDIwMDtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuZW1pdChcImRyYWdTdGFydFwiLCBfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgICAgICAgZGF0YXM6IF90aGlzLmRhdGFzLFxuICAgICAgICAgIGlucHV0RXZlbnQ6IGUsXG4gICAgICAgICAgaXNUcnVzdGVkOiBpc1RydXN0ZWQsXG4gICAgICAgICAgaXNEb3VibGU6IF90aGlzLmRvdWJsZUZsYWdcbiAgICAgICAgfSwgX3RoaXMuZ2V0Q3VycmVudFN0b3JlKCkuZ2V0UG9zaXRpb24oKSksIHtcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJldmVudERyYWc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9kcmFnRmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgX3RoaXMuaW5pdERyYWcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmZsYWcgJiYgcHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV90aGlzLmZsYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZXIgPSAwO1xuXG4gICAgICBpZiAoaXNEcmFnU3RhcnQgJiYgaXNUb3VjaCAmJiBwaW5jaE91dHNpZGUpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhZGRFdmVudChjb250YWluZXIsIFwidG91Y2hzdGFydFwiLCBfdGhpcy5vbkRyYWdTdGFydCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNEcmFnU3RhcnQgJiYgaXNUb3VjaCAmJiBwaW5jaE91dHNpZGUpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcInRvdWNoc3RhcnRcIiwgX3RoaXMub25EcmFnU3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuZmxhZyAmJiBpc011bHRpVG91Y2goZSkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICBpZiAoaXNEcmFnU3RhcnQgJiYgZS50b3VjaGVzLmxlbmd0aCAhPT0gZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV90aGlzLnBpbmNoRmxhZykge1xuICAgICAgICAgIF90aGlzLm9uUGluY2hTdGFydChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkRyYWcgPSBmdW5jdGlvbiAoZSwgaXNTY3JvbGwpIHtcbiAgICAgIGlmICghX3RoaXMuZmxhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGllbnRzID0gZ2V0RXZlbnRDbGllbnRzKGUpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gX3RoaXMubW92ZUNsaWVudHMoY2xpZW50cywgZSwgZmFsc2UpO1xuXG4gICAgICBpZiAoX3RoaXMuX2RyYWdGbGFnKSB7XG4gICAgICAgIGlmIChfdGhpcy5waW5jaEZsYWcgfHwgcmVzdWx0LmRlbHRhWCB8fCByZXN1bHQuZGVsdGFZKSB7XG4gICAgICAgICAgdmFyIGRyYWdSZXN1bHQgPSBfdGhpcy5lbWl0KFwiZHJhZ1wiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzdWx0KSwge1xuICAgICAgICAgICAgaXNTY3JvbGw6ICEhaXNTY3JvbGwsXG4gICAgICAgICAgICBpbnB1dEV2ZW50OiBlXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgaWYgKGRyYWdSZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMucGluY2hGbGFnKSB7XG4gICAgICAgICAgX3RoaXMub25QaW5jaChlLCBjbGllbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpcy5nZXRDdXJyZW50U3RvcmUoKS5nZXRQb3NpdGlvbihjbGllbnRzLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25EcmFnRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghX3RoaXMuZmxhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfYSA9IF90aGlzLm9wdGlvbnMsXG4gICAgICAgICAgcGluY2hPdXRzaWRlID0gX2EucGluY2hPdXRzaWRlLFxuICAgICAgICAgIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lcjtcblxuICAgICAgaWYgKF90aGlzLmlzVG91Y2ggJiYgcGluY2hPdXRzaWRlKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50KGNvbnRhaW5lciwgXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLnBpbmNoRmxhZykge1xuICAgICAgICBfdGhpcy5vblBpbmNoRW5kKGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xpZW50cyA9IChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUudG91Y2hlcykgPyBnZXRFdmVudENsaWVudHMoZSkgOiBbXTtcbiAgICAgIHZhciBjbGllbnRzTGVuZ3RoID0gY2xpZW50cy5sZW5ndGg7XG5cbiAgICAgIGlmIChjbGllbnRzTGVuZ3RoID09PSAwIHx8ICFfdGhpcy5vcHRpb25zLmtlZXBEcmFnZ2luZykge1xuICAgICAgICBfdGhpcy5mbGFnID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5fYWRkU3RvcmUobmV3IENsaWVudFN0b3JlKGNsaWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvc2l0aW9uID0gX3RoaXMuX2dldFBvc2l0aW9uKCk7XG5cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IG5vdygpO1xuICAgICAgdmFyIGlzRG91YmxlID0gIV90aGlzLmlzRHJhZyAmJiBfdGhpcy5kb3VibGVGbGFnO1xuICAgICAgX3RoaXMucHJldlRpbWUgPSBfdGhpcy5pc0RyYWcgfHwgaXNEb3VibGUgPyAwIDogY3VycmVudFRpbWU7XG5cbiAgICAgIGlmICghX3RoaXMuZmxhZykge1xuICAgICAgICBfdGhpcy5lbWl0KFwiZHJhZ0VuZFwiLCBfX2Fzc2lnbih7XG4gICAgICAgICAgZGF0YXM6IF90aGlzLmRhdGFzLFxuICAgICAgICAgIGlzRG91YmxlOiBpc0RvdWJsZSxcbiAgICAgICAgICBpc0RyYWc6IF90aGlzLmlzRHJhZyxcbiAgICAgICAgICBpc0NsaWNrOiAhX3RoaXMuaXNEcmFnLFxuICAgICAgICAgIGlucHV0RXZlbnQ6IGVcbiAgICAgICAgfSwgcG9zaXRpb24pKTtcblxuICAgICAgICBfdGhpcy5jbGllbnRTdG9yZXMgPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25EcmFnRW5kKCk7XG4gICAgfTtcblxuICAgIHZhciBlbGVtZW50cyA9IFtdLmNvbmNhdCh0YXJnZXRzKTtcbiAgICBfdGhpcy5vcHRpb25zID0gX19hc3NpZ24oe1xuICAgICAgY2hlY2tJbnB1dDogZmFsc2UsXG4gICAgICBjb250YWluZXI6IGVsZW1lbnRzLmxlbmd0aCA+IDEgPyB3aW5kb3cgOiBlbGVtZW50c1swXSxcbiAgICAgIHByZXZlbnRSaWdodENsaWNrOiB0cnVlLFxuICAgICAgcHJldmVudFdoZWVsQ2xpY2s6IHRydWUsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgIGNoZWNrV2luZG93Qmx1cjogZmFsc2UsXG4gICAgICBrZWVwRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgcGluY2hUaHJlc2hvbGQ6IDAsXG4gICAgICBldmVudHM6IFtcInRvdWNoXCIsIFwibW91c2VcIl1cbiAgICB9LCBvcHRpb25zKTtcbiAgICB2YXIgX2EgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICBjb250YWluZXIgPSBfYS5jb250YWluZXIsXG4gICAgICAgIGV2ZW50cyA9IF9hLmV2ZW50cyxcbiAgICAgICAgY2hlY2tXaW5kb3dCbHVyID0gX2EuY2hlY2tXaW5kb3dCbHVyO1xuICAgIF90aGlzLmlzVG91Y2ggPSBldmVudHMuaW5kZXhPZihcInRvdWNoXCIpID4gLTE7XG4gICAgX3RoaXMuaXNNb3VzZSA9IGV2ZW50cy5pbmRleE9mKFwibW91c2VcIikgPiAtMTtcbiAgICBfdGhpcy50YXJnZXRzID0gZWxlbWVudHM7XG5cbiAgICBpZiAoX3RoaXMuaXNNb3VzZSkge1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgYWRkRXZlbnQoZWwsIFwibW91c2Vkb3duXCIsIF90aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgIH0pO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcIm1vdXNlbW92ZVwiLCBfdGhpcy5vbkRyYWcpO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcIm1vdXNldXBcIiwgX3RoaXMub25EcmFnRW5kKTtcbiAgICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgXCJjb250ZXh0bWVudVwiLCBfdGhpcy5vbkRyYWdFbmQpO1xuICAgIH1cblxuICAgIGlmIChjaGVja1dpbmRvd0JsdXIpIHtcbiAgICAgIGFkZEV2ZW50KHdpbmRvdywgXCJibHVyXCIsIF90aGlzLm9uQmx1cik7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmlzVG91Y2gpIHtcbiAgICAgIHZhciBwYXNzaXZlXzEgPSB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgYWRkRXZlbnQoZWwsIFwidG91Y2hzdGFydFwiLCBfdGhpcy5vbkRyYWdTdGFydCwgcGFzc2l2ZV8xKTtcbiAgICAgIH0pO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcInRvdWNobW92ZVwiLCBfdGhpcy5vbkRyYWcsIHBhc3NpdmVfMSk7XG4gICAgICBhZGRFdmVudChjb250YWluZXIsIFwidG91Y2hlbmRcIiwgX3RoaXMub25EcmFnRW5kLCBwYXNzaXZlXzEpO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcInRvdWNoY2FuY2VsXCIsIF90aGlzLm9uRHJhZ0VuZCwgcGFzc2l2ZV8xKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgR2VzdG8ncyBkcmFnIGV2ZW50cy5cbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IEdlc3RvLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0RyYWcgPSBmYWxzZTtcbiAgICB0aGlzLmZsYWcgPSBmYWxzZTtcbiAgICB0aGlzLmNsaWVudFN0b3JlcyA9IFtdO1xuICAgIHRoaXMuZGF0YXMgPSB7fTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBtb3ZlZCBkaXN0YW5jZVxuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRTdG9yZSgpLmdldE1vdmVtZW50KGNsaWVudHMpICsgdGhpcy5jbGllbnRTdG9yZXMuc2xpY2UoMSkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgIHJldHVybiBwcmV2ICsgY3VyLm1vdmVtZW50O1xuICAgIH0sIDApO1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0byBkcmFnXG4gICAqL1xuXG5cbiAgX19wcm90by5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzRHJhZztcbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RhcnQgZHJhZ1xuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNGbGFnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZsYWc7XG4gIH07XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0YXJ0IHBpbmNoXG4gICAqL1xuXG5cbiAgX19wcm90by5pc1BpbmNoRmxhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5waW5jaEZsYWc7XG4gIH07XG4gIC8qKlxuICAqIFdoZXRoZXIgdG8gc3RhcnQgZG91YmxlIGNsaWNrXG4gICovXG5cblxuICBfX3Byb3RvLmlzRG91YmxlRmxhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kb3VibGVGbGFnO1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0byBwaW5jaFxuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNQaW5jaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpbmNoO1xuICB9O1xuICAvKipcbiAgICogSWYgYSBzY3JvbGwgZXZlbnQgb2NjdXJzLCBpdCBpcyBjb3JyZWN0ZWQgYnkgdGhlIHNjcm9sbCBkaXN0YW5jZS5cbiAgICovXG5cblxuICBfX3Byb3RvLnNjcm9sbEJ5ID0gZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZLCBlLCBpc0NhbGxEcmFnKSB7XG4gICAgaWYgKGlzQ2FsbERyYWcgPT09IHZvaWQgMCkge1xuICAgICAgaXNDYWxsRHJhZyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZsYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsaWVudFN0b3Jlc1swXS5tb3ZlKGRlbHRhWCwgZGVsdGFZKTtcbiAgICBpc0NhbGxEcmFnICYmIHRoaXMub25EcmFnKGUsIHRydWUpO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlIGEgdmlydHVhbCBkcmFnIGV2ZW50LlxuICAgKi9cblxuXG4gIF9fcHJvdG8ubW92ZSA9IGZ1bmN0aW9uIChfYSwgaW5wdXRFdmVudCkge1xuICAgIHZhciBkZWx0YVggPSBfYVswXSxcbiAgICAgICAgZGVsdGFZID0gX2FbMV07XG4gICAgdmFyIHN0b3JlID0gdGhpcy5nZXRDdXJyZW50U3RvcmUoKTtcbiAgICB2YXIgbmV4dENsaWVudHMgPSBzdG9yZS5wcmV2Q2xpZW50cztcbiAgICByZXR1cm4gdGhpcy5tb3ZlQ2xpZW50cyhuZXh0Q2xpZW50cy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IF9hLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IF9hLmNsaWVudFk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRYOiBjbGllbnRYICsgZGVsdGFYLFxuICAgICAgICBjbGllbnRZOiBjbGllbnRZICsgZGVsdGFZLFxuICAgICAgICBvcmlnaW5hbENsaWVudFg6IGNsaWVudFgsXG4gICAgICAgIG9yaWdpbmFsQ2xpZW50WTogY2xpZW50WVxuICAgICAgfTtcbiAgICB9KSwgaW5wdXRFdmVudCwgdHJ1ZSk7XG4gIH07XG4gIC8qKlxuICAgKiBUaGUgZHJhZ1N0YXJ0IGV2ZW50IGlzIHRyaWdnZXJlZCBieSBhbiBleHRlcm5hbCBldmVudC5cbiAgICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXJEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHRoaXMub25EcmFnU3RhcnQoZSwgZmFsc2UpO1xuICB9O1xuICAvKipcbiAgICogU2V0IHRoZSBldmVudCBkYXRhIHdoaWxlIGRyYWdnaW5nLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uc2V0RXZlbnREYXRhcyA9IGZ1bmN0aW9uIChkYXRhcykge1xuICAgIHZhciBjdXJyZW50RGF0YXMgPSB0aGlzLmRhdGFzO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBkYXRhcykge1xuICAgICAgY3VycmVudERhdGFzW25hbWVdID0gZGF0YXNbbmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZXZlbnQgc3RhdGUgd2hpbGUgZHJhZ2dpbmcuXG4gICAqL1xuXG5cbiAgX19wcm90by5nZXRDdXJyZW50RXZlbnQgPSBmdW5jdGlvbiAoaW5wdXRFdmVudCkge1xuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgICBkYXRhczogdGhpcy5kYXRhc1xuICAgIH0sIHRoaXMuX2dldFBvc2l0aW9uKCkpLCB7XG4gICAgICBtb3ZlbWVudDogdGhpcy5nZXRNb3ZlbWVudCgpLFxuICAgICAgaXNEcmFnOiB0aGlzLmlzRHJhZyxcbiAgICAgIGlzUGluY2g6IHRoaXMuaXNQaW5jaCxcbiAgICAgIGlzU2Nyb2xsOiBmYWxzZSxcbiAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnRcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCAmIFNldCB0aGUgZXZlbnQgZGF0YSB3aGlsZSBkcmFnZ2luZy5cbiAgICovXG5cblxuICBfX3Byb3RvLmdldEV2ZW50RGF0YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YXM7XG4gIH07XG4gIC8qKlxuICAgKiBVbnNldCBHZXN0b1xuICAgKi9cblxuXG4gIF9fcHJvdG8udW5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciB0YXJnZXRzID0gdGhpcy50YXJnZXRzO1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIHRoaXMub2ZmKCk7XG4gICAgcmVtb3ZlRXZlbnQod2luZG93LCBcImJsdXJcIiwgdGhpcy5vbkJsdXIpO1xuXG4gICAgaWYgKHRoaXMuaXNNb3VzZSkge1xuICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnQodGFyZ2V0LCBcIm1vdXNlZG93blwiLCBfdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgICB9KTtcbiAgICAgIHJlbW92ZUV2ZW50KGNvbnRhaW5lciwgXCJtb3VzZW1vdmVcIiwgdGhpcy5vbkRyYWcpO1xuICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcIm1vdXNldXBcIiwgdGhpcy5vbkRyYWdFbmQpO1xuICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcImNvbnRleHRtZW51XCIsIHRoaXMub25EcmFnRW5kKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1RvdWNoKSB7XG4gICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICByZW1vdmVFdmVudCh0YXJnZXQsIFwidG91Y2hzdGFydFwiLCBfdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgICB9KTtcbiAgICAgIHJlbW92ZUV2ZW50KGNvbnRhaW5lciwgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcInRvdWNobW92ZVwiLCB0aGlzLm9uRHJhZyk7XG4gICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwidG91Y2hlbmRcIiwgdGhpcy5vbkRyYWdFbmQpO1xuICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcInRvdWNoY2FuY2VsXCIsIHRoaXMub25EcmFnRW5kKTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5vblBpbmNoU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBwaW5jaFRocmVzaG9sZCA9IHRoaXMub3B0aW9ucy5waW5jaFRocmVzaG9sZDtcblxuICAgIGlmICh0aGlzLmlzRHJhZyAmJiB0aGlzLmdldE1vdmVtZW50KCkgPiBwaW5jaFRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdG9yZSA9IG5ldyBDbGllbnRTdG9yZShnZXRFdmVudENsaWVudHMoZSkpO1xuICAgIHRoaXMucGluY2hGbGFnID0gdHJ1ZTtcblxuICAgIHRoaXMuX2FkZFN0b3JlKHN0b3JlKTtcblxuICAgIHZhciByZXN1bHQgPSB0aGlzLmVtaXQoXCJwaW5jaFN0YXJ0XCIsIF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgIGRhdGFzOiB0aGlzLmRhdGFzLFxuICAgICAgYW5nbGU6IHN0b3JlLmdldEFuZ2xlKCksXG4gICAgICB0b3VjaGVzOiB0aGlzLmdldEN1cnJlbnRTdG9yZSgpLmdldFBvc2l0aW9ucygpXG4gICAgfSwgc3RvcmUuZ2V0UG9zaXRpb24oKSksIHtcbiAgICAgIGlucHV0RXZlbnQ6IGVcbiAgICB9KSk7XG5cbiAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5waW5jaEZsYWcgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5vblBpbmNoID0gZnVuY3Rpb24gKGUsIGNsaWVudHMpIHtcbiAgICBpZiAoIXRoaXMuZmxhZyB8fCAhdGhpcy5waW5jaEZsYWcgfHwgY2xpZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0b3JlID0gdGhpcy5nZXRDdXJyZW50U3RvcmUoKTtcbiAgICB0aGlzLmlzUGluY2ggPSB0cnVlO1xuICAgIHRoaXMuZW1pdChcInBpbmNoXCIsIF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgIGRhdGFzOiB0aGlzLmRhdGFzLFxuICAgICAgbW92ZW1lbnQ6IHRoaXMuZ2V0TW92ZW1lbnQoY2xpZW50cyksXG4gICAgICBhbmdsZTogc3RvcmUuZ2V0QW5nbGUoY2xpZW50cyksXG4gICAgICByb3RhdGlvbjogc3RvcmUuZ2V0Um90YXRpb24oY2xpZW50cyksXG4gICAgICB0b3VjaGVzOiBzdG9yZS5nZXRQb3NpdGlvbnMoY2xpZW50cyksXG4gICAgICBzY2FsZTogc3RvcmUuZ2V0U2NhbGUoY2xpZW50cyksXG4gICAgICBkaXN0YW5jZTogc3RvcmUuZ2V0RGlzdGFuY2UoY2xpZW50cylcbiAgICB9LCBzdG9yZS5nZXRQb3NpdGlvbihjbGllbnRzKSksIHtcbiAgICAgIGlucHV0RXZlbnQ6IGVcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5vblBpbmNoRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIXRoaXMucGluY2hGbGFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlzUGluY2ggPSB0aGlzLmlzUGluY2g7XG4gICAgdGhpcy5pc1BpbmNoID0gZmFsc2U7XG4gICAgdGhpcy5waW5jaEZsYWcgPSBmYWxzZTtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLmdldEN1cnJlbnRTdG9yZSgpO1xuICAgIHRoaXMuZW1pdChcInBpbmNoRW5kXCIsIF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgIGRhdGFzOiB0aGlzLmRhdGFzLFxuICAgICAgaXNQaW5jaDogaXNQaW5jaCxcbiAgICAgIHRvdWNoZXM6IHN0b3JlLmdldFBvc2l0aW9ucygpXG4gICAgfSwgc3RvcmUuZ2V0UG9zaXRpb24oKSksIHtcbiAgICAgIGlucHV0RXZlbnQ6IGVcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5pbml0RHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsaWVudFN0b3JlcyA9IFtdO1xuICAgIHRoaXMucGluY2hGbGFnID0gZmFsc2U7XG4gICAgdGhpcy5kb3VibGVGbGFnID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2VGltZSA9IDA7XG4gICAgdGhpcy5mbGFnID0gZmFsc2U7XG4gIH07XG5cbiAgX19wcm90by5nZXRDdXJyZW50U3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50U3RvcmVzWzBdO1xuICB9O1xuXG4gIF9fcHJvdG8ubW92ZUNsaWVudHMgPSBmdW5jdGlvbiAoY2xpZW50cywgaW5wdXRFdmVudCwgaXNBZGQpIHtcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbihjbGllbnRzLCBpc0FkZCk7XG5cbiAgICBpZiAocG9zaXRpb24uZGVsdGFYIHx8IHBvc2l0aW9uLmRlbHRhWSkge1xuICAgICAgdGhpcy5pc0RyYWcgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgICBkYXRhczogdGhpcy5kYXRhc1xuICAgIH0sIHBvc2l0aW9uKSwge1xuICAgICAgbW92ZW1lbnQ6IHRoaXMuZ2V0TW92ZW1lbnQoY2xpZW50cyksXG4gICAgICBpc0RyYWc6IHRoaXMuaXNEcmFnLFxuICAgICAgaXNQaW5jaDogdGhpcy5pc1BpbmNoLFxuICAgICAgaXNTY3JvbGw6IGZhbHNlLFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudFxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2FkZFN0b3JlID0gZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgdGhpcy5jbGllbnRTdG9yZXMuc3BsaWNlKDAsIDAsIHN0b3JlKTtcbiAgfTtcblxuICBfX3Byb3RvLl9nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChjbGllbnRzLCBpc0FkZCkge1xuICAgIHZhciBzdG9yZSA9IHRoaXMuZ2V0Q3VycmVudFN0b3JlKCk7XG4gICAgdmFyIHBvc2l0aW9uID0gc3RvcmUuZ2V0UG9zaXRpb24oY2xpZW50cywgaXNBZGQpO1xuXG4gICAgdmFyIF9hID0gdGhpcy5jbGllbnRTdG9yZXMuc2xpY2UoMSkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgIHZhciBzdG9yZVBvc2l0aW9uID0gY3VyLmdldFBvc2l0aW9uKCk7XG4gICAgICBwcmV2LmRpc3RYICs9IHN0b3JlUG9zaXRpb24uZGlzdFg7XG4gICAgICBwcmV2LmRpc3RZICs9IHN0b3JlUG9zaXRpb24uZGlzdFk7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9LCBwb3NpdGlvbiksXG4gICAgICAgIGRpc3RYID0gX2EuZGlzdFgsXG4gICAgICAgIGRpc3RZID0gX2EuZGlzdFk7XG5cbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHBvc2l0aW9uKSwge1xuICAgICAgZGlzdFg6IGRpc3RYLFxuICAgICAgZGlzdFk6IGRpc3RZXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEdlc3RvO1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBHZXN0bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlc3RvLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIERheWJydXNoXG5uYW1lOiBrZXljb25cbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9rZXljb24uZ2l0XG52ZXJzaW9uOiAxLjEuMlxuKi9cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gIH07XG5cbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE4IERheWJydXNoXG5AbmFtZTogQGRheWJydXNoL3V0aWxzXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC91dGlsc1xuQHZlcnNpb24gMS4wLjBcbiovXG4vKipcbiogZ2V0IHN0cmluZyBcIm9iamVjdFwiXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7T0JKRUNUfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKE9CSkVDVCk7IC8vIFwib2JqZWN0XCJcbiovXG5cbnZhciBPQkpFQ1QgPSBcIm9iamVjdFwiO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJzdHJpbmdcIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge1NUUklOR30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhTVFJJTkcpOyAvLyBcInN0cmluZ1wiXG4qL1xuXG52YXIgU1RSSU5HID0gXCJzdHJpbmdcIjtcbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBvYmplY3QuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzT2JqZWN0fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzT2JqZWN0KHt9KSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzT2JqZWN0KHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNPYmplY3QoXCJcIikpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNPYmplY3QobnVsbCkpOyAvLyBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gT0JKRUNUO1xufVxuLyoqXG4qIENoZWNrIHRoZSB0eXBlIHRoYXQgdGhlIHZhbHVlIGlzIGlzQXJyYXkuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzQXJyYXl9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coaXNBcnJheShbXSkpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc0FycmF5KHt9KSk7IC8vIGZhbHNlXG5jb25zb2xlLmxvZyhpc0FycmF5KHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNBcnJheShudWxsKSk7IC8vIGZhbHNlXG4qL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBzdHJpbmcuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzU3RyaW5nfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzU3RyaW5nKFwiMTIzNFwiKSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzU3RyaW5nKHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNTdHJpbmcoMSkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNTdHJpbmcobnVsbCkpOyAvLyBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gU1RSSU5HO1xufVxuLyoqXG4qIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHBhcmFtIC0gVGhlIGFycmF5IGBmaW5kSW5kZXhgIHdhcyBjYWxsZWQgdXBvbi5cbiogQHBhcmFtIC0gQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5IHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiogQHBhcmFtIC0gUmV0dXJucyBkZWZhdWx0SW5kZXggaWYgbm90IGZvdW5kIGJ5IHRoZSBmdW5jdGlvbi5cbiogQGV4YW1wbGVcbmltcG9ydCB7IGZpbmRJbmRleCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuZmluZEluZGV4KFt7YTogMX0sIHthOiAyfSwge2E6IDN9LCB7YTogNH1dLCAoeyBhIH0pID0+IGEgPT09IDIpOyAvLyAxXG4qL1xuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBjYWxsYmFjaywgZGVmYXVsdEluZGV4KSB7XG4gIGlmIChkZWZhdWx0SW5kZXggPT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHRJbmRleCA9IC0xO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmIChjYWxsYmFjayhhcnJbaV0sIGksIGFycikpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0SW5kZXg7XG59XG4vKipcbiogU2V0cyB1cCBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHNwZWNpZmllZCBldmVudCBpcyBkZWxpdmVyZWQgdG8gdGhlIHRhcmdldFxuKiBAbWVtYmVyb2YgRE9NXG4qIEBwYXJhbSAtIGV2ZW50IHRhcmdldFxuKiBAcGFyYW0gLSBBIGNhc2Utc2Vuc2l0aXZlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvci5cbiogQHBhcmFtIC0gVGhlIG9iamVjdCB3aGljaCByZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiAoYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgRXZlbnQgaW50ZXJmYWNlKSB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnNcbiogQHBhcmFtIC0gQW4gb3B0aW9ucyBvYmplY3QgdGhhdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0IHRoZSBldmVudCBsaXN0ZW5lci4gVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiogQGV4YW1wbGVcbmltcG9ydCB7YWRkRXZlbnR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuYWRkRXZlbnQoZWwsIFwiY2xpY2tcIiwgZSA9PiB7XG4gIGNvbnNvbGUubG9nKGUpO1xufSk7XG4qL1xuXG5mdW5jdGlvbiBhZGRFdmVudChlbCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG59XG4vKipcbiogcmVtb3ZlcyBmcm9tIHRoZSBFdmVudFRhcmdldCBhbiBldmVudCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKClcbiogQG1lbWJlcm9mIERPTVxuKiBAcGFyYW0gLSBldmVudCB0YXJnZXRcbiogQHBhcmFtIC0gQSBjYXNlLXNlbnNpdGl2ZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3IuXG4qIEBwYXJhbSAtIFRoZSBFdmVudExpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCBoYW5kbGVyIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudCB0YXJnZXQuXG4qIEBleGFtcGxlXG5pbXBvcnQge2FkZEV2ZW50LCByZW1vdmVFdmVudH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuY29uc3QgbGlzdGVuZXIgPSBlID0+IHtcbiAgY29uc29sZS5sb2coZSk7XG59O1xuYWRkRXZlbnQoZWwsIFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xucmVtb3ZlRXZlbnQoZWwsIFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xuKi9cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWwsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xufVxuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBAc2NlbmEvZXZlbnQtZW1pdHRlclxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2dlc3R1cmUuZ2l0XG52ZXJzaW9uOiAxLjAuMlxuKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKykgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspIHJba10gPSBhW2pdO1xuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEltcGxlbWVudCBFdmVudEVtaXR0ZXIgb24gb2JqZWN0IG9yIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgRXZlbnRFbWl0dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgcmVnaXN0ZXJlZCBldmVudC5cbiAgICogQHBhcmFtIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQHBhcmFtIC0gbGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqIGNvc250IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIC8vIEFkZCBsaXN0ZW5lciBpbiBcImFcIiBldmVudFxuICAgKiBlbWl0dGVyLm9uKFwiYVwiLCAoKSA9PiB7XG4gICAqIH0pO1xuICAgKiAvLyBBZGQgbGlzdGVuZXJzXG4gICAqIGVtaXR0ZXIub24oe1xuICAgKiAgYTogKCkgPT4ge30sXG4gICAqICBiOiAoKSA9PiB7fSxcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgdmFyIF9fcHJvdG8gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8ub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChpc09iamVjdChldmVudE5hbWUpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLm9uKG5hbWUsIGV2ZW50TmFtZVtuYW1lXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50KGV2ZW50TmFtZSwgbGlzdGVuZXIsIHt9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBpbiB0aGUgZXZlbnQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gLSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSByZW1vdmVkXG4gICAqIEBwYXJhbSAtIGxpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSByZW1vdmVkXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqIGNvc250IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzLlxuICAgKiBlbWl0dGVyLm9mZigpO1xuICAgKlxuICAgKiAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBpbiBcIkFcIiBldmVudC5cbiAgICogZW1pdHRlci5vZmYoXCJhXCIpO1xuICAgKlxuICAgKlxuICAgKiAvLyBSZW1vdmUgXCJsaXN0ZW5lclwiIGxpc3RlbmVyIGluIFwiYVwiIGV2ZW50LlxuICAgKiBlbWl0dGVyLm9mZihcImFcIiwgbGlzdGVuZXIpO1xuICAgKi9cblxuXG4gIF9fcHJvdG8ub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChldmVudE5hbWUpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLm9mZihuYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuXG4gICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleChldmVudHMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUubGlzdGVuZXIgPT09IGxpc3RlbmVyO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIGV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBBZGQgYSBkaXNwb3NhYmxlIGxpc3RlbmVyIGFuZCBVc2UgcHJvbWlzZSB0byB0aGUgcmVnaXN0ZXJlZCBldmVudC5cbiAgICogQHBhcmFtIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQHBhcmFtIC0gZGlzcG9zYWJsZSBsaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICogY29zbnQgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogLy8gQWRkIGEgZGlzcG9zYWJsZSBsaXN0ZW5lciBpbiBcImFcIiBldmVudFxuICAgKiBlbWl0dGVyLm9uY2UoXCJhXCIsICgpID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIFVzZSBQcm9taXNlXG4gICAqIGVtaXR0ZXIub25jZShcImFcIikudGhlbihlID0+IHtcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9hZGRFdmVudChldmVudE5hbWUsIGxpc3RlbmVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3RoaXMuX2FkZEV2ZW50KGV2ZW50TmFtZSwgcmVzb2x2ZSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEZpcmVzIGFuIGV2ZW50IHRvIGNhbGwgbGlzdGVuZXJzLlxuICAgKiBAcGFyYW0gLSBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSAtIEV2ZW50IHBhcmFtZXRlclxuICAgKiBAcmV0dXJuIElmIGZhbHNlLCBzdG9wIHRoZSBldmVudC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICpcbiAgICpcbiAgICogY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogZW1pdHRlci5vbihcImFcIiwgZSA9PiB7XG4gICAqIH0pO1xuICAgKlxuICAgKlxuICAgKiBlbWl0dGVyLmVtaXQoXCJhXCIsIHtcbiAgICogICBhOiAxLFxuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXJhbSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAocGFyYW0gPT09IHZvaWQgMCkge1xuICAgICAgcGFyYW0gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV07XG5cbiAgICBpZiAoIWV2ZW50TmFtZSB8fCAhZXZlbnRzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdG9wID0gZmFsc2U7XG4gICAgcGFyYW0uZXZlbnRUeXBlID0gZXZlbnROYW1lO1xuXG4gICAgcGFyYW0uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzU3RvcCA9IHRydWU7XG4gICAgfTtcblxuICAgIHBhcmFtLmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXG4gICAgX19zcHJlYWRBcnJheXMoZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBpbmZvLmxpc3RlbmVyKHBhcmFtKTtcblxuICAgICAgaWYgKGluZm8ub25jZSkge1xuICAgICAgICBfdGhpcy5vZmYoZXZlbnROYW1lLCBpbmZvLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAhaXNTdG9wO1xuICB9O1xuICAvKipcbiAgICogRmlyZXMgYW4gZXZlbnQgdG8gY2FsbCBsaXN0ZW5lcnMuXG4gICAqIEBwYXJhbSAtIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIC0gRXZlbnQgcGFyYW1ldGVyXG4gICAqIEByZXR1cm4gSWYgZmFsc2UsIHN0b3AgdGhlIGV2ZW50LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKlxuICAgKlxuICAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiBlbWl0dGVyLm9uKFwiYVwiLCBlID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIGVtaXR0ZXIuZW1pdChcImFcIiwge1xuICAgKiAgIGE6IDEsXG4gICAqIH0pO1xuICAgKi9cblxuICAvKipcbiAgKiBGaXJlcyBhbiBldmVudCB0byBjYWxsIGxpc3RlbmVycy5cbiAgKiBAcGFyYW0gLSBFdmVudCBuYW1lXG4gICogQHBhcmFtIC0gRXZlbnQgcGFyYW1ldGVyXG4gICogQHJldHVybiBJZiBmYWxzZSwgc3RvcCB0aGUgZXZlbnQuXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICpcbiAgKlxuICAqIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICpcbiAgKiBlbWl0dGVyLm9uKFwiYVwiLCBlID0+IHtcbiAgKiB9KTtcbiAgKlxuICAqIC8vIGVtaXRcbiAgKiBlbWl0dGVyLnRyaWdnZXIoXCJhXCIsIHtcbiAgKiAgIGE6IDEsXG4gICogfSk7XG4gICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXJhbSkge1xuICAgIGlmIChwYXJhbSA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbSA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnROYW1lLCBwYXJhbSk7XG4gIH07XG5cbiAgX19wcm90by5fYWRkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgZXZlbnRzW2V2ZW50TmFtZV0gPSBldmVudHNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgbGlzdGVuZXJzLnB1c2goX19hc3NpZ24oe1xuICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gICAgfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcbiAgcmV0dXJuIG1vZHVsZSA9IHtcbiAgICBleHBvcnRzOiB7fVxuICB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBrZXljb2RlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLy8gU291cmNlOiBodHRwOi8vanNmaWRkbGUubmV0L3ZXeDhWL1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjAzMTk1L2Z1bGwtbGlzdC1vZi1qYXZhc2NyaXB0LWtleWNvZGVzXG5cbi8qKlxuICogQ29uZW5pZW5jZSBtZXRob2QgcmV0dXJucyBjb3JyZXNwb25kaW5nIHZhbHVlIGZvciBnaXZlbiBrZXlOYW1lIG9yIGtleUNvZGUuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0ga2V5Q29kZSB7TnVtYmVyfSBvciBrZXlOYW1lIHtTdHJpbmd9XG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24ga2V5Q29kZShzZWFyY2hJbnB1dCkge1xuICAvLyBLZXlib2FyZCBFdmVudHNcbiAgaWYgKHNlYXJjaElucHV0ICYmICdvYmplY3QnID09PSB0eXBlb2Ygc2VhcmNoSW5wdXQpIHtcbiAgICB2YXIgaGFzS2V5Q29kZSA9IHNlYXJjaElucHV0LndoaWNoIHx8IHNlYXJjaElucHV0LmtleUNvZGUgfHwgc2VhcmNoSW5wdXQuY2hhckNvZGU7XG4gICAgaWYgKGhhc0tleUNvZGUpIHNlYXJjaElucHV0ID0gaGFzS2V5Q29kZTtcbiAgfVxuXG4gIC8vIE51bWJlcnNcbiAgaWYgKCdudW1iZXInID09PSB0eXBlb2Ygc2VhcmNoSW5wdXQpIHJldHVybiBuYW1lc1tzZWFyY2hJbnB1dF1cblxuICAvLyBFdmVyeXRoaW5nIGVsc2UgKGNhc3QgdG8gc3RyaW5nKVxuICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaElucHV0KTtcblxuICAvLyBjaGVjayBjb2Rlc1xuICB2YXIgZm91bmROYW1lZEtleSA9IGNvZGVzW3NlYXJjaC50b0xvd2VyQ2FzZSgpXTtcbiAgaWYgKGZvdW5kTmFtZWRLZXkpIHJldHVybiBmb3VuZE5hbWVkS2V5XG5cbiAgLy8gY2hlY2sgYWxpYXNlc1xuICB2YXIgZm91bmROYW1lZEtleSA9IGFsaWFzZXNbc2VhcmNoLnRvTG93ZXJDYXNlKCldO1xuICBpZiAoZm91bmROYW1lZEtleSkgcmV0dXJuIGZvdW5kTmFtZWRLZXlcblxuICAvLyB3ZWlyZCBjaGFyYWN0ZXI/XG4gIGlmIChzZWFyY2gubGVuZ3RoID09PSAxKSByZXR1cm4gc2VhcmNoLmNoYXJDb2RlQXQoMClcblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogQ29tcGFyZXMgYSBrZXlib2FyZCBldmVudCB3aXRoIGEgZ2l2ZW4ga2V5Q29kZSBvciBrZXlOYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEtleWJvYXJkIGV2ZW50IHRoYXQgc2hvdWxkIGJlIHRlc3RlZFxuICogQHBhcmFtIHtNaXhlZH0ga2V5Q29kZSB7TnVtYmVyfSBvciBrZXlOYW1lIHtTdHJpbmd9XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xua2V5Q29kZS5pc0V2ZW50S2V5ID0gZnVuY3Rpb24gaXNFdmVudEtleShldmVudCwgbmFtZU9yQ29kZSkge1xuICBpZiAoZXZlbnQgJiYgJ29iamVjdCcgPT09IHR5cGVvZiBldmVudCkge1xuICAgIHZhciBrZXlDb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZSB8fCBldmVudC5jaGFyQ29kZTtcbiAgICBpZiAoa2V5Q29kZSA9PT0gbnVsbCB8fCBrZXlDb2RlID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHR5cGVvZiBuYW1lT3JDb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gY2hlY2sgY29kZXNcbiAgICAgIHZhciBmb3VuZE5hbWVkS2V5ID0gY29kZXNbbmFtZU9yQ29kZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmIChmb3VuZE5hbWVkS2V5KSB7IHJldHVybiBmb3VuZE5hbWVkS2V5ID09PSBrZXlDb2RlOyB9XG4gICAgXG4gICAgICAvLyBjaGVjayBhbGlhc2VzXG4gICAgICB2YXIgZm91bmROYW1lZEtleSA9IGFsaWFzZXNbbmFtZU9yQ29kZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmIChmb3VuZE5hbWVkS2V5KSB7IHJldHVybiBmb3VuZE5hbWVkS2V5ID09PSBrZXlDb2RlOyB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZU9yQ29kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBuYW1lT3JDb2RlID09PSBrZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGtleUNvZGU7XG5cbi8qKlxuICogR2V0IGJ5IG5hbWVcbiAqXG4gKiAgIGV4cG9ydHMuY29kZVsnZW50ZXInXSAvLyA9PiAxM1xuICovXG5cbnZhciBjb2RlcyA9IGV4cG9ydHMuY29kZSA9IGV4cG9ydHMuY29kZXMgPSB7XG4gICdiYWNrc3BhY2UnOiA4LFxuICAndGFiJzogOSxcbiAgJ2VudGVyJzogMTMsXG4gICdzaGlmdCc6IDE2LFxuICAnY3RybCc6IDE3LFxuICAnYWx0JzogMTgsXG4gICdwYXVzZS9icmVhayc6IDE5LFxuICAnY2FwcyBsb2NrJzogMjAsXG4gICdlc2MnOiAyNyxcbiAgJ3NwYWNlJzogMzIsXG4gICdwYWdlIHVwJzogMzMsXG4gICdwYWdlIGRvd24nOiAzNCxcbiAgJ2VuZCc6IDM1LFxuICAnaG9tZSc6IDM2LFxuICAnbGVmdCc6IDM3LFxuICAndXAnOiAzOCxcbiAgJ3JpZ2h0JzogMzksXG4gICdkb3duJzogNDAsXG4gICdpbnNlcnQnOiA0NSxcbiAgJ2RlbGV0ZSc6IDQ2LFxuICAnY29tbWFuZCc6IDkxLFxuICAnbGVmdCBjb21tYW5kJzogOTEsXG4gICdyaWdodCBjb21tYW5kJzogOTMsXG4gICdudW1wYWQgKic6IDEwNixcbiAgJ251bXBhZCArJzogMTA3LFxuICAnbnVtcGFkIC0nOiAxMDksXG4gICdudW1wYWQgLic6IDExMCxcbiAgJ251bXBhZCAvJzogMTExLFxuICAnbnVtIGxvY2snOiAxNDQsXG4gICdzY3JvbGwgbG9jayc6IDE0NSxcbiAgJ215IGNvbXB1dGVyJzogMTgyLFxuICAnbXkgY2FsY3VsYXRvcic6IDE4MyxcbiAgJzsnOiAxODYsXG4gICc9JzogMTg3LFxuICAnLCc6IDE4OCxcbiAgJy0nOiAxODksXG4gICcuJzogMTkwLFxuICAnLyc6IDE5MSxcbiAgJ2AnOiAxOTIsXG4gICdbJzogMjE5LFxuICAnXFxcXCc6IDIyMCxcbiAgJ10nOiAyMjEsXG4gIFwiJ1wiOiAyMjJcbn07XG5cbi8vIEhlbHBlciBhbGlhc2VzXG5cbnZhciBhbGlhc2VzID0gZXhwb3J0cy5hbGlhc2VzID0ge1xuICAnd2luZG93cyc6IDkxLFxuICAn4oenJzogMTYsXG4gICfijKUnOiAxOCxcbiAgJ+KMgyc6IDE3LFxuICAn4oyYJzogOTEsXG4gICdjdGwnOiAxNyxcbiAgJ2NvbnRyb2wnOiAxNyxcbiAgJ29wdGlvbic6IDE4LFxuICAncGF1c2UnOiAxOSxcbiAgJ2JyZWFrJzogMTksXG4gICdjYXBzJzogMjAsXG4gICdyZXR1cm4nOiAxMyxcbiAgJ2VzY2FwZSc6IDI3LFxuICAnc3BjJzogMzIsXG4gICdzcGFjZWJhcic6IDMyLFxuICAncGd1cCc6IDMzLFxuICAncGdkbic6IDM0LFxuICAnaW5zJzogNDUsXG4gICdkZWwnOiA0NixcbiAgJ2NtZCc6IDkxXG59O1xuXG4vKiFcbiAqIFByb2dyYW1hdGljYWxseSBhZGQgdGhlIGZvbGxvd2luZ1xuICovXG5cbi8vIGxvd2VyIGNhc2UgY2hhcnNcbmZvciAoaSA9IDk3OyBpIDwgMTIzOyBpKyspIGNvZGVzW1N0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaSAtIDMyO1xuXG4vLyBudW1iZXJzXG5mb3IgKHZhciBpID0gNDg7IGkgPCA1ODsgaSsrKSBjb2Rlc1tpIC0gNDhdID0gaTtcblxuLy8gZnVuY3Rpb24ga2V5c1xuZm9yIChpID0gMTsgaSA8IDEzOyBpKyspIGNvZGVzWydmJytpXSA9IGkgKyAxMTE7XG5cbi8vIG51bXBhZCBrZXlzXG5mb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykgY29kZXNbJ251bXBhZCAnK2ldID0gaSArIDk2O1xuXG4vKipcbiAqIEdldCBieSBjb2RlXG4gKlxuICogICBleHBvcnRzLm5hbWVbMTNdIC8vID0+ICdFbnRlcidcbiAqL1xuXG52YXIgbmFtZXMgPSBleHBvcnRzLm5hbWVzID0gZXhwb3J0cy50aXRsZSA9IHt9OyAvLyB0aXRsZSBmb3IgYmFja3dhcmQgY29tcGF0XG5cbi8vIENyZWF0ZSByZXZlcnNlIG1hcHBpbmdcbmZvciAoaSBpbiBjb2RlcykgbmFtZXNbY29kZXNbaV1dID0gaTtcblxuLy8gQWRkIGFsaWFzZXNcbmZvciAodmFyIGFsaWFzIGluIGFsaWFzZXMpIHtcbiAgY29kZXNbYWxpYXNdID0gYWxpYXNlc1thbGlhc107XG59XG59KTtcbnZhciBrZXljb2RlXzEgPSBrZXljb2RlLmNvZGU7XG52YXIga2V5Y29kZV8yID0ga2V5Y29kZS5jb2RlcztcbnZhciBrZXljb2RlXzMgPSBrZXljb2RlLmFsaWFzZXM7XG52YXIga2V5Y29kZV80ID0ga2V5Y29kZS5uYW1lcztcbnZhciBrZXljb2RlXzUgPSBrZXljb2RlLnRpdGxlO1xuXG52YXIgY29kZURhdGEgPSB7XG4gIFwiK1wiOiBcInBsdXNcIixcbiAgXCJsZWZ0IGNvbW1hbmRcIjogXCJtZXRhXCIsXG4gIFwicmlnaHQgY29tbWFuZFwiOiBcIm1ldGFcIlxufTtcbnZhciBrZXlzU29ydCA9IHtcbiAgc2hpZnQ6IDEsXG4gIGN0cmw6IDIsXG4gIGFsdDogMyxcbiAgbWV0YTogNFxufTtcbi8qKlxuICogQG1lbWJlcm9mIEtleUNvbnRyb2xsZXJcbiAqL1xuXG5mdW5jdGlvbiBnZXRLZXkoa2V5Q29kZSkge1xuICB2YXIga2V5ID0ga2V5Y29kZV80W2tleUNvZGVdIHx8IFwiXCI7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBjb2RlRGF0YSkge1xuICAgIGtleSA9IGtleS5yZXBsYWNlKG5hbWUsIGNvZGVEYXRhW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBrZXkucmVwbGFjZSgvXFxzL2csIFwiXCIpO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgS2V5Q29udHJvbGxlclxuICovXG5cbmZ1bmN0aW9uIGdldENvbWJpKGUsIGtleSkge1xuICBpZiAoa2V5ID09PSB2b2lkIDApIHtcbiAgICBrZXkgPSBnZXRLZXkoZS5rZXlDb2RlKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gZ2V0TW9kaWZpZXJDb21iaShlKTtcbiAga2V5cy5pbmRleE9mKGtleSkgPT09IC0xICYmIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cy5maWx0ZXIoQm9vbGVhbik7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBLZXlDb250cm9sbGVyXG4gKi9cblxuZnVuY3Rpb24gZ2V0TW9kaWZpZXJDb21iaShlKSB7XG4gIHZhciBrZXlzID0gW2Uuc2hpZnRLZXkgJiYgXCJzaGlmdFwiLCBlLmN0cmxLZXkgJiYgXCJjdHJsXCIsIGUuYWx0S2V5ICYmIFwiYWx0XCIsIGUubWV0YUtleSAmJiBcIm1ldGFcIl07XG4gIHJldHVybiBrZXlzLmZpbHRlcihCb29sZWFuKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYW5nZUNvbWJpKGtleXMpIHtcbiAgdmFyIGFycmFuZ2VLZXlzID0ga2V5cy5zbGljZSgpO1xuICBhcnJhbmdlS2V5cy5zb3J0KGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gICAgdmFyIHByZXZTY29yZSA9IGtleXNTb3J0W3ByZXZdIHx8IDU7XG4gICAgdmFyIG5leHRTY29yZSA9IGtleXNTb3J0W25leHRdIHx8IDU7XG4gICAgcmV0dXJuIHByZXZTY29yZSAtIG5leHRTY29yZTtcbiAgfSk7XG4gIHJldHVybiBhcnJhbmdlS2V5cztcbn1cblxudmFyIGdsb2JhbEtleUNvbnRyb2xsZXI7XG4vKipcbiAqL1xuXG52YXIgS2V5Q29udHJvbGxlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhLZXlDb250cm9sbGVyLCBfc3VwZXIpO1xuICAvKipcbiAgICpcbiAgICovXG5cblxuICBmdW5jdGlvbiBLZXlDb250cm9sbGVyKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIgPT09IHZvaWQgMCkge1xuICAgICAgY29udGFpbmVyID0gd2luZG93O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgLyoqXG4gICAgICovXG5cbiAgICBfdGhpcy5jdHJsS2V5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICovXG5cbiAgICBfdGhpcy5hbHRLZXkgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuXG4gICAgX3RoaXMuc2hpZnRLZXkgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuXG4gICAgX3RoaXMubWV0YUtleSA9IGZhbHNlO1xuXG4gICAgX3RoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jdHJsS2V5ID0gZmFsc2U7XG4gICAgICBfdGhpcy5hbHRLZXkgPSBmYWxzZTtcbiAgICAgIF90aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG4gICAgICBfdGhpcy5tZXRhS2V5ID0gZmFsc2U7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIF90aGlzLmtleWRvd25FdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy50cmlnZ2VyRXZlbnQoXCJrZXlkb3duXCIsIGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5rZXl1cEV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIF90aGlzLnRyaWdnZXJFdmVudChcImtleXVwXCIsIGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5ibHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY2xlYXIoKTtcblxuICAgICAgX3RoaXMudHJpZ2dlcihcImJsdXJcIik7XG4gICAgfTtcblxuICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgXCJibHVyXCIsIF90aGlzLmJsdXIpO1xuICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgXCJrZXlkb3duXCIsIF90aGlzLmtleWRvd25FdmVudCk7XG4gICAgYWRkRXZlbnQoY29udGFpbmVyLCBcImtleXVwXCIsIF90aGlzLmtleXVwRXZlbnQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gS2V5Q29udHJvbGxlci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLZXlDb250cm9sbGVyLCBcImdsb2JhbFwiLCB7XG4gICAgLyoqXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsS2V5Q29udHJvbGxlciB8fCAoZ2xvYmFsS2V5Q29udHJvbGxlciA9IG5ldyBLZXlDb250cm9sbGVyKCkpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIEtleUNvbnRyb2xsZXIuc2V0R2xvYmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbDtcbiAgfTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5vZmYoKTtcbiAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwiYmx1clwiLCB0aGlzLmJsdXIpO1xuICAgIHJlbW92ZUV2ZW50KGNvbnRhaW5lciwgXCJrZXlkb3duXCIsIHRoaXMua2V5ZG93bkV2ZW50KTtcbiAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwia2V5dXBcIiwgdGhpcy5rZXl1cEV2ZW50KTtcbiAgfTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgX19wcm90by5rZXlkb3duID0gZnVuY3Rpb24gKGNvbWIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkRXZlbnQoXCJrZXlkb3duXCIsIGNvbWIsIGNhbGxiYWNrKTtcbiAgfTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgX19wcm90by5vZmZLZXlkb3duID0gZnVuY3Rpb24gKGNvbWIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlRXZlbnQoXCJrZXlkb3duXCIsIGNvbWIsIGNhbGxiYWNrKTtcbiAgfTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgX19wcm90by5vZmZLZXl1cCA9IGZ1bmN0aW9uIChjb21iLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUV2ZW50KFwia2V5dXBcIiwgY29tYiwgY2FsbGJhY2spO1xuICB9O1xuICAvKipcbiAgICpcbiAgICovXG5cblxuICBfX3Byb3RvLmtleXVwID0gZnVuY3Rpb24gKGNvbWIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkRXZlbnQoXCJrZXl1cFwiLCBjb21iLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgX19wcm90by5hZGRFdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb21iLCBjYWxsYmFjaykge1xuICAgIGlmIChpc0FycmF5KGNvbWIpKSB7XG4gICAgICB0aGlzLm9uKHR5cGUgKyBcIi5cIiArIGdldEFycmFuZ2VDb21iaShjb21iKS5qb2luKFwiLlwiKSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoY29tYikpIHtcbiAgICAgIHRoaXMub24odHlwZSArIFwiLlwiICsgY29tYiwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKHR5cGUsIGNvbWIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9fcHJvdG8ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAodHlwZSwgY29tYiwgY2FsbGJhY2spIHtcbiAgICBpZiAoaXNBcnJheShjb21iKSkge1xuICAgICAgdGhpcy5vZmYodHlwZSArIFwiLlwiICsgZ2V0QXJyYW5nZUNvbWJpKGNvbWIpLmpvaW4oXCIuXCIpLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhjb21iKSkge1xuICAgICAgdGhpcy5vZmYodHlwZSArIFwiLlwiICsgY29tYiwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9mZih0eXBlLCBjb21iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfX3Byb3RvLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgdGhpcy5jdHJsS2V5ID0gZS5jdHJsS2V5O1xuICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICAgIHRoaXMuYWx0S2V5ID0gZS5hbHRLZXk7XG4gICAgdGhpcy5tZXRhS2V5ID0gZS5tZXRhS2V5O1xuICAgIHZhciBrZXkgPSBnZXRLZXkoZS5rZXlDb2RlKTtcbiAgICB2YXIgaXNUb2dnbGUgPSBrZXkgPT09IFwiY3RybFwiIHx8IGtleSA9PT0gXCJzaGlmdFwiIHx8IGtleSA9PT0gXCJtZXRhXCIgfHwga2V5ID09PSBcImFsdFwiO1xuICAgIHZhciBwYXJhbSA9IHtcbiAgICAgIGtleToga2V5LFxuICAgICAgaXNUb2dnbGU6IGlzVG9nZ2xlLFxuICAgICAgaW5wdXRFdmVudDogZSxcbiAgICAgIGtleUNvZGU6IGUua2V5Q29kZSxcbiAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAgICAgIGFsdEtleTogZS5hbHRLZXksXG4gICAgICBzaGlmdEtleTogZS5zaGlmdEtleSxcbiAgICAgIG1ldGFLZXk6IGUubWV0YUtleVxuICAgIH07XG4gICAgdGhpcy50cmlnZ2VyKHR5cGUsIHBhcmFtKTtcbiAgICB0aGlzLnRyaWdnZXIodHlwZSArIFwiLlwiICsga2V5LCBwYXJhbSk7XG4gICAgdmFyIGNvbWJpID0gZ2V0Q29tYmkoZSwga2V5KTtcbiAgICBjb21iaS5sZW5ndGggPiAxICYmIHRoaXMudHJpZ2dlcih0eXBlICsgXCIuXCIgKyBjb21iaS5qb2luKFwiLlwiKSwgcGFyYW0pO1xuICB9O1xuXG4gIHJldHVybiBLZXlDb250cm9sbGVyO1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBLZXlDb250cm9sbGVyO1xuZXhwb3J0IHsgZ2V0Q29tYmksIGdldEtleSwgZ2V0TW9kaWZpZXJDb21iaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5Y29uLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IG1vdmVhYmxlXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9tb3ZlYWJsZS9ibG9iL21hc3Rlci9wYWNrYWdlcy9tb3ZlYWJsZVxudmVyc2lvbjogMC4zMC4wXG4qL1xuaW1wb3J0IHsgcmVmLCBQcm9wZXJ0aWVzIH0gZnJvbSAnZnJhbWV3b3JrLXV0aWxzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0LXNpbXBsZS1jb21wYXQnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsLCByZW5kZXIgfSBmcm9tICdyZWFjdC1zaW1wbGUtY29tcGF0JztcbmltcG9ydCBNb3ZlYWJsZSQxLCB7IE1PVkVBQkxFX1BST1BTLCBNT1ZFQUJMRV9NRVRIT0RTLCBNT1ZFQUJMRV9FVkVOVFMsIE1PVkVBQkxFX1BST1BTX01BUCwgZ2V0RWxlbWVudEluZm8gYXMgZ2V0RWxlbWVudEluZm8kMSwgbWFrZUFibGUgYXMgbWFrZUFibGUkMSB9IGZyb20gJ3JlYWN0LWNvbXBhdC1tb3ZlYWJsZSc7XG5pbXBvcnQgeyBpc09iamVjdCwgZmluZEluZGV4LCBjYW1lbGl6ZSwgaXNBcnJheSB9IGZyb20gJ0BkYXlicnVzaC91dGlscyc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiQxID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiQxID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbiQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XG5cbnZhciBJbm5lck1vdmVhYmxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKElubmVyTW92ZWFibGUsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gSW5uZXJNb3ZlYWJsZShwcm9wcykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLnByb3BzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gSW5uZXJNb3ZlYWJsZS5wcm90b3R5cGU7XG5cbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChSZWFjdC5jcmVhdGVFbGVtZW50KE1vdmVhYmxlJDEsIF9fYXNzaWduJDEoe1xuICAgICAgcmVmOiByZWYodGhpcywgXCJtb3ZlYWJsZVwiKVxuICAgIH0sIHRoaXMuc3RhdGUpKSwgdGhpcy5zdGF0ZS5wYXJlbnRFbGVtZW50KTtcbiAgfTtcblxuICByZXR1cm4gSW5uZXJNb3ZlYWJsZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxudmFyIFBST1BFUlRJRVMgPSBNT1ZFQUJMRV9QUk9QUztcbnZhciBNRVRIT0RTID0gTU9WRUFCTEVfTUVUSE9EUztcbnZhciBFVkVOVFMgPSBNT1ZFQUJMRV9FVkVOVFM7XG52YXIgUFJPUFNfTUFQID0gTU9WRUFCTEVfUFJPUFNfTUFQO1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBAc2NlbmEvZXZlbnQtZW1pdHRlclxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2dlc3R1cmUuZ2l0XG52ZXJzaW9uOiAxLjAuNVxuKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKykgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspIHJba10gPSBhW2pdO1xuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEltcGxlbWVudCBFdmVudEVtaXR0ZXIgb24gb2JqZWN0IG9yIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgRXZlbnRFbWl0dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgcmVnaXN0ZXJlZCBldmVudC5cbiAgICogQHBhcmFtIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQHBhcmFtIC0gbGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqIGNvc250IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIC8vIEFkZCBsaXN0ZW5lciBpbiBcImFcIiBldmVudFxuICAgKiBlbWl0dGVyLm9uKFwiYVwiLCAoKSA9PiB7XG4gICAqIH0pO1xuICAgKiAvLyBBZGQgbGlzdGVuZXJzXG4gICAqIGVtaXR0ZXIub24oe1xuICAgKiAgYTogKCkgPT4ge30sXG4gICAqICBiOiAoKSA9PiB7fSxcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgdmFyIF9fcHJvdG8gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8ub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChpc09iamVjdChldmVudE5hbWUpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLm9uKG5hbWUsIGV2ZW50TmFtZVtuYW1lXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50KGV2ZW50TmFtZSwgbGlzdGVuZXIsIHt9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBpbiB0aGUgZXZlbnQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gLSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSByZW1vdmVkXG4gICAqIEBwYXJhbSAtIGxpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSByZW1vdmVkXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqIGNvc250IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzLlxuICAgKiBlbWl0dGVyLm9mZigpO1xuICAgKlxuICAgKiAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBpbiBcIkFcIiBldmVudC5cbiAgICogZW1pdHRlci5vZmYoXCJhXCIpO1xuICAgKlxuICAgKlxuICAgKiAvLyBSZW1vdmUgXCJsaXN0ZW5lclwiIGxpc3RlbmVyIGluIFwiYVwiIGV2ZW50LlxuICAgKiBlbWl0dGVyLm9mZihcImFcIiwgbGlzdGVuZXIpO1xuICAgKi9cblxuXG4gIF9fcHJvdG8ub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChldmVudE5hbWUpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLm9mZihuYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuXG4gICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleChldmVudHMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUubGlzdGVuZXIgPT09IGxpc3RlbmVyO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIGV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBBZGQgYSBkaXNwb3NhYmxlIGxpc3RlbmVyIGFuZCBVc2UgcHJvbWlzZSB0byB0aGUgcmVnaXN0ZXJlZCBldmVudC5cbiAgICogQHBhcmFtIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQHBhcmFtIC0gZGlzcG9zYWJsZSBsaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICogY29zbnQgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogLy8gQWRkIGEgZGlzcG9zYWJsZSBsaXN0ZW5lciBpbiBcImFcIiBldmVudFxuICAgKiBlbWl0dGVyLm9uY2UoXCJhXCIsICgpID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIFVzZSBQcm9taXNlXG4gICAqIGVtaXR0ZXIub25jZShcImFcIikudGhlbihlID0+IHtcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9hZGRFdmVudChldmVudE5hbWUsIGxpc3RlbmVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3RoaXMuX2FkZEV2ZW50KGV2ZW50TmFtZSwgcmVzb2x2ZSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEZpcmVzIGFuIGV2ZW50IHRvIGNhbGwgbGlzdGVuZXJzLlxuICAgKiBAcGFyYW0gLSBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSAtIEV2ZW50IHBhcmFtZXRlclxuICAgKiBAcmV0dXJuIElmIGZhbHNlLCBzdG9wIHRoZSBldmVudC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICpcbiAgICpcbiAgICogY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogZW1pdHRlci5vbihcImFcIiwgZSA9PiB7XG4gICAqIH0pO1xuICAgKlxuICAgKlxuICAgKiBlbWl0dGVyLmVtaXQoXCJhXCIsIHtcbiAgICogICBhOiAxLFxuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXJhbSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAocGFyYW0gPT09IHZvaWQgMCkge1xuICAgICAgcGFyYW0gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV07XG5cbiAgICBpZiAoIWV2ZW50TmFtZSB8fCAhZXZlbnRzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdG9wID0gZmFsc2U7XG4gICAgcGFyYW0uZXZlbnRUeXBlID0gZXZlbnROYW1lO1xuXG4gICAgcGFyYW0uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzU3RvcCA9IHRydWU7XG4gICAgfTtcblxuICAgIHBhcmFtLmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXG4gICAgX19zcHJlYWRBcnJheXMoZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBpbmZvLmxpc3RlbmVyKHBhcmFtKTtcblxuICAgICAgaWYgKGluZm8ub25jZSkge1xuICAgICAgICBfdGhpcy5vZmYoZXZlbnROYW1lLCBpbmZvLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAhaXNTdG9wO1xuICB9O1xuICAvKipcbiAgICogRmlyZXMgYW4gZXZlbnQgdG8gY2FsbCBsaXN0ZW5lcnMuXG4gICAqIEBwYXJhbSAtIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIC0gRXZlbnQgcGFyYW1ldGVyXG4gICAqIEByZXR1cm4gSWYgZmFsc2UsIHN0b3AgdGhlIGV2ZW50LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKlxuICAgKlxuICAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiBlbWl0dGVyLm9uKFwiYVwiLCBlID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIGVtaXR0ZXIuZW1pdChcImFcIiwge1xuICAgKiAgIGE6IDEsXG4gICAqIH0pO1xuICAgKi9cblxuICAvKipcbiAgKiBGaXJlcyBhbiBldmVudCB0byBjYWxsIGxpc3RlbmVycy5cbiAgKiBAcGFyYW0gLSBFdmVudCBuYW1lXG4gICogQHBhcmFtIC0gRXZlbnQgcGFyYW1ldGVyXG4gICogQHJldHVybiBJZiBmYWxzZSwgc3RvcCB0aGUgZXZlbnQuXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICpcbiAgKlxuICAqIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICpcbiAgKiBlbWl0dGVyLm9uKFwiYVwiLCBlID0+IHtcbiAgKiB9KTtcbiAgKlxuICAqIC8vIGVtaXRcbiAgKiBlbWl0dGVyLnRyaWdnZXIoXCJhXCIsIHtcbiAgKiAgIGE6IDEsXG4gICogfSk7XG4gICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXJhbSkge1xuICAgIGlmIChwYXJhbSA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbSA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnROYW1lLCBwYXJhbSk7XG4gIH07XG5cbiAgX19wcm90by5fYWRkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgZXZlbnRzW2V2ZW50TmFtZV0gPSBldmVudHNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgbGlzdGVuZXJzLnB1c2goX19hc3NpZ24oe1xuICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gICAgfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCk7XG5cbnZhciBFdmVudEVtaXR0ZXIkMSA9IEV2ZW50RW1pdHRlcjtcblxuLyoqXG4gKiBNb3ZlYWJsZSBpcyBEcmFnZ2FibGUhIFJlc2l6YWJsZSEgU2NhbGFibGUhIFJvdGF0YWJsZSFcbiAqIEBzb3J0IDFcbiAqIEBhbGlhcyBNb3ZlYWJsZVxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cblxudmFyIE1vdmVhYmxlTWFuYWdlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNb3ZlYWJsZU1hbmFnZXIsIF9zdXBlcik7XG4gIC8qKlxuICAgKlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIE1vdmVhYmxlTWFuYWdlcihwYXJlbnRFbGVtZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50ZW1wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICB2YXIgbmV4dE9wdGlvbnMgPSBfX2Fzc2lnbiQxKHt9LCBvcHRpb25zKTtcblxuICAgIHZhciBldmVudHMgPSB7fTtcbiAgICBFVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgZXZlbnRzW2NhbWVsaXplKFwib24gXCIuY29uY2F0KG5hbWUpKV0gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMudHJpZ2dlcihuYW1lLCBlKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmVuZGVyKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5uZXJNb3ZlYWJsZSwgX19hc3NpZ24kMSh7XG4gICAgICByZWY6IHJlZihfdGhpcywgXCJpbm5lck1vdmVhYmxlXCIpLFxuICAgICAgcGFyZW50RWxlbWVudDogcGFyZW50RWxlbWVudFxuICAgIH0sIG5leHRPcHRpb25zLCBldmVudHMpKSwgX3RoaXMudGVtcEVsZW1lbnQpO1xuICAgIHZhciB0YXJnZXQgPSBuZXh0T3B0aW9ucy50YXJnZXQ7XG5cbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIHRhcmdldC5sZW5ndGggPiAxKSB7XG4gICAgICBfdGhpcy51cGRhdGVSZWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pbm5lck1vdmVhYmxlLnNldFN0YXRlKHN0YXRlLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgX19wcm90by5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuaW5uZXJNb3ZlYWJsZS5mb3JjZVVwZGF0ZShjYWxsYmFjayk7XG4gIH07XG5cbiAgX19wcm90by5kcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBpbm5lck1vdmVhYmxlID0gdGhpcy5pbm5lck1vdmVhYmxlO1xuXG4gICAgaWYgKGlubmVyTW92ZWFibGUuJF90aW1lcikge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0TW92ZWFibGUoKS5kcmFnU3RhcnQoZSk7XG4gIH07XG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHJlbmRlcihudWxsLCB0aGlzLnRlbXBFbGVtZW50KTtcbiAgICB0aGlzLm9mZigpO1xuICAgIHRoaXMudGVtcEVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuaW5uZXJNb3ZlYWJsZSA9IG51bGw7XG4gIH07XG5cbiAgX19wcm90by5nZXRNb3ZlYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbm5lck1vdmVhYmxlLm1vdmVhYmxlO1xuICB9O1xuXG4gIE1vdmVhYmxlTWFuYWdlciA9IF9fZGVjb3JhdGUoW1Byb3BlcnRpZXMoTUVUSE9EUywgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHkpIHtcbiAgICBpZiAocHJvdG90eXBlW3Byb3BlcnR5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByb3RvdHlwZVtwcm9wZXJ0eV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcy5nZXRNb3ZlYWJsZSgpO1xuXG4gICAgICBpZiAoIXNlbGYgfHwgIXNlbGZbcHJvcGVydHldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGZbcHJvcGVydHldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH07XG4gIH0pLCBQcm9wZXJ0aWVzKFBST1BFUlRJRVMsIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnR5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgcHJvcGVydHksIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb3ZlYWJsZSgpLnByb3BzW3Byb3BlcnR5XTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgoX2EgPSB7fSwgX2FbcHJvcGVydHldID0gdmFsdWUsIF9hKSk7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KV0sIE1vdmVhYmxlTWFuYWdlcik7XG4gIHJldHVybiBNb3ZlYWJsZU1hbmFnZXI7XG59KEV2ZW50RW1pdHRlciQxKTtcblxudmFyIE1vdmVhYmxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1vdmVhYmxlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1vdmVhYmxlKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBNb3ZlYWJsZTtcbn0oTW92ZWFibGVNYW5hZ2VyKTtcblxuZnVuY3Rpb24gZ2V0RWxlbWVudEluZm8odGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIpIHtcbiAgcmV0dXJuIGdldEVsZW1lbnRJbmZvJDEodGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIpO1xufVxuZnVuY3Rpb24gbWFrZUFibGUobmFtZSwgYWJsZSkge1xuICByZXR1cm4gbWFrZUFibGUkMShuYW1lLCBhYmxlKTtcbn1cblxuZXhwb3J0IHsgRVZFTlRTLCBNRVRIT0RTLCBQUk9QRVJUSUVTLCBQUk9QU19NQVAsIE1vdmVhYmxlIGFzIGRlZmF1bHQsIGdldEVsZW1lbnRJbmZvLCBtYWtlQWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZWFibGUuZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAyMCBEYXlicnVzaFxubmFtZTogb3ZlcmxhcC1hcmVhXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvb3ZlcmxhcC1hcmVhLmdpdFxudmVyc2lvbjogMS4wLjBcbiovXG5pbXBvcnQgeyBzdW0sIGZpbmRJbmRleCwgZ2V0U2hhcGVEaXJlY3Rpb24sIGdldERpc3QgfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKykgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspIHJba10gPSBhW2pdO1xuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEBuYW1lc3BhY2UgT3ZlcmxhcEFyZWFcbiAqL1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYSBzaGFwZSAocG9seWdvbikgbWFkZSBvZiBwb2ludHMuXG4gKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiAqL1xuXG5mdW5jdGlvbiBnZXRBcmVhU2l6ZShwb2ludHMpIHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gTWF0aC5hYnMoc3VtKHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50LCBpKSB7XG4gICAgdmFyIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV0gfHwgcG9pbnRzWzBdO1xuICAgIHJldHVybiBwb2ludFswXSAqIG5leHRQb2ludFsxXSAtIG5leHRQb2ludFswXSAqIHBvaW50WzFdO1xuICB9KSkpIC8gMjtcbn1cbi8qKlxuICogR2V0IHBvaW50cyB0aGF0IGZpdCB0aGUgcmVjdCxcbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGZpdFBvaW50cyhwb2ludHMsIHJlY3QpIHtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCxcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgIHRvcCA9IHJlY3QudG9wO1xuXG4gIHZhciBfYSA9IGdldE1pbk1heHMocG9pbnRzKSxcbiAgICAgIG1pblggPSBfYS5taW5YLFxuICAgICAgbWluWSA9IF9hLm1pblksXG4gICAgICBtYXhYID0gX2EubWF4WCxcbiAgICAgIG1heFkgPSBfYS5tYXhZO1xuXG4gIHZhciByYXRpb1ggPSB3aWR0aCAvIChtYXhYIC0gbWluWCk7XG4gIHZhciByYXRpb1kgPSBoZWlnaHQgLyAobWF4WSAtIG1pblkpO1xuICByZXR1cm4gcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gW2xlZnQgKyAocG9pbnRbMF0gLSBtaW5YKSAqIHJhdGlvWCwgdG9wICsgKHBvaW50WzFdIC0gbWluWSkgKiByYXRpb1ldO1xuICB9KTtcbn1cbi8qKlxuICogR2V0IHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHBvaW50cyBvZiB0aGUgcG9pbnRzLlxuICogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4gKi9cblxuZnVuY3Rpb24gZ2V0TWluTWF4cyhwb2ludHMpIHtcbiAgdmFyIHhzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnRbMF07XG4gIH0pO1xuICB2YXIgeXMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHJldHVybiBwb2ludFsxXTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbWluWDogTWF0aC5taW4uYXBwbHkoTWF0aCwgeHMpLFxuICAgIG1pblk6IE1hdGgubWluLmFwcGx5KE1hdGgsIHlzKSxcbiAgICBtYXhYOiBNYXRoLm1heC5hcHBseShNYXRoLCB4cyksXG4gICAgbWF4WTogTWF0aC5tYXguYXBwbHkoTWF0aCwgeXMpXG4gIH07XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIHBvaW50IGlzIGluIHNoYXBlXG4gKiBAcGFyYW0gLSBwb2ludCBwb3NcbiAqIEBwYXJhbSAtIHNoYXBlIHBvaW50c1xuICogQHBhcmFtIC0gd2hldGhlciB0byBjaGVjayBleGNlcHQgbGluZVxuICogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4gKi9cblxuZnVuY3Rpb24gaXNJbnNpZGUocG9zLCBwb2ludHMsIGV4Y2x1ZGVMaW5lKSB7XG4gIHZhciB4ID0gcG9zWzBdLFxuICAgICAgeSA9IHBvc1sxXTtcblxuICB2YXIgX2EgPSBnZXRNaW5NYXhzKHBvaW50cyksXG4gICAgICBtaW5YID0gX2EubWluWCxcbiAgICAgIG1pblkgPSBfYS5taW5ZLFxuICAgICAgbWF4WCA9IF9hLm1heFgsXG4gICAgICBtYXhZID0gX2EubWF4WTtcblxuICB2YXIgeExpbmUgPSBbW21pblgsIHldLCBbbWF4WCwgeV1dO1xuICB2YXIgeUxpbmUgPSBbW3gsIG1pblldLCBbeCwgbWF4WV1dO1xuICB2YXIgeExpbmVhckNvbnN0YW50cyA9IGdldExpbmVhckNvbnN0YW50cyh4TGluZVswXSwgeExpbmVbMV0pO1xuICB2YXIgeUxpbmVhckNvbnN0YW50cyA9IGdldExpbmVhckNvbnN0YW50cyh5TGluZVswXSwgeUxpbmVbMV0pO1xuICB2YXIgbGluZXMgPSBjb252ZXJ0TGluZXMocG9pbnRzKTtcbiAgdmFyIGludGVyc2VjdGlvblhQb2ludHMgPSBbXTtcbiAgdmFyIGludGVyc2VjdGlvbllQb2ludHMgPSBbXTtcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIHZhciBsaW5lYXJDb25zdGFudHMgPSBnZXRMaW5lYXJDb25zdGFudHMobGluZVswXSwgbGluZVsxXSk7XG4gICAgdmFyIHhQb2ludHMgPSBnZXRQb2ludHNPbkxpbmVzKGdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzKHhMaW5lYXJDb25zdGFudHMsIGxpbmVhckNvbnN0YW50cyksIFt4TGluZSwgbGluZV0pO1xuICAgIHZhciB5UG9pbnRzID0gZ2V0UG9pbnRzT25MaW5lcyhnZXRJbnRlcnNlY3Rpb25Qb2ludHNCeUNvbnN0YW50cyh5TGluZWFyQ29uc3RhbnRzLCBsaW5lYXJDb25zdGFudHMpLCBbeUxpbmUsIGxpbmVdKTtcblxuICAgIGlmICh4UG9pbnRzLmxlbmd0aCA9PT0gMSA/IGxpbmVbMF1bMV0gIT09IHkgOiB0cnVlKSB7XG4gICAgICBpbnRlcnNlY3Rpb25YUG9pbnRzLnB1c2guYXBwbHkoaW50ZXJzZWN0aW9uWFBvaW50cywgeFBvaW50cyk7XG4gICAgfVxuXG4gICAgaWYgKHlQb2ludHMubGVuZ3RoID09PSAxID8gbGluZVswXVswXSAhPT0geCA6IHRydWUpIHtcbiAgICAgIGludGVyc2VjdGlvbllQb2ludHMucHVzaC5hcHBseShpbnRlcnNlY3Rpb25ZUG9pbnRzLCB5UG9pbnRzKTtcbiAgICB9XG5cbiAgICBpZiAoIWxpbmVhckNvbnN0YW50c1swXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWFBvaW50cy5wdXNoLmFwcGx5KGludGVyc2VjdGlvblhQb2ludHMsIHhQb2ludHMpO1xuICAgIH1cblxuICAgIGlmICghbGluZWFyQ29uc3RhbnRzWzFdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25ZUG9pbnRzLnB1c2guYXBwbHkoaW50ZXJzZWN0aW9uWVBvaW50cywgeVBvaW50cyk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWV4Y2x1ZGVMaW5lKSB7XG4gICAgaWYgKGZpbmRJbmRleChpbnRlcnNlY3Rpb25YUG9pbnRzLCBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIHBbMF0gPT09IHg7XG4gICAgfSkgPiAtMSB8fCBmaW5kSW5kZXgoaW50ZXJzZWN0aW9uWVBvaW50cywgZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBwWzFdID09PSB5O1xuICAgIH0pID4gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbnRlcnNlY3Rpb25YUG9pbnRzLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwWzBdID4geDtcbiAgfSkubGVuZ3RoICUgMiAmJiBpbnRlcnNlY3Rpb25ZUG9pbnRzLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwWzFdID4geTtcbiAgfSkubGVuZ3RoICUgMikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBHZXQgdGhlIGNvZWZmaWNpZW50IG9mIHRoZSBsaW5lYXIgZnVuY3Rpb24uIFthLCBiLCBjXSAoYXggKyBieSArIGMgPSAwKVxuICogQHJldHVybiBbYSwgYiwgY11cbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGdldExpbmVhckNvbnN0YW50cyhwb2ludDEsIHBvaW50Mikge1xuICB2YXIgeDEgPSBwb2ludDFbMF0sXG4gICAgICB5MSA9IHBvaW50MVsxXTtcbiAgdmFyIHgyID0gcG9pbnQyWzBdLFxuICAgICAgeTIgPSBwb2ludDJbMV07IC8vIGF4ICsgYnkgKyBjID0gMFxuXG4gIGlmICh4MSA9PT0geDIgJiYgeTEgPT09IHkyKSB7XG4gICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIGlmICh4MSA9PT0geDIpIHtcbiAgICAvLyB4ID0geDFcbiAgICByZXR1cm4gWzEsIDAsIC14MV07XG4gIH0gZWxzZSBpZiAoeTEgPT09IHkyKSB7XG4gICAgLy8geSA9IHkxXG4gICAgcmV0dXJuIFswLCAxLCAteTFdO1xuICB9IGVsc2Uge1xuICAgIC8vIHgxICsgYSAqIHkxICsgYiA9IDBcbiAgICAvLyB4MiArIGEgKiB5MiArIGIgPSAwXG4gICAgLy8gKHgxIC14MikgKyAoeTEgLSB5MikgKiBhID0gMFxuICAgIC8vIGEgPSAoeDIgLSB4MSkgLyAoeTEgLSB5MilcbiAgICAvLyB4MSArICh4MiAtIHgxKSAvICh5MSAtIHkyKVxuICAgIHZhciBhXzEgPSAoeDIgLSB4MSkgLyAoeTEgLSB5Mik7XG4gICAgdmFyIGJfMSA9IC14MSAtIGFfMSAqIHkxO1xuICAgIHJldHVybiBbMSwgYV8xLCBiXzFdO1xuICB9XG59XG4vKipcbiAqIEdldCBpbnRlcnNlY3Rpb24gcG9pbnRzIHdpdGggbGluZWFyIGZ1bmN0aW9ucy5cbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzKGxpbmVhckNvbnN0YW50czEsIGxpbmVhckNvbnN0YW50czIpIHtcbiAgdmFyIGExID0gbGluZWFyQ29uc3RhbnRzMVswXSxcbiAgICAgIGIxID0gbGluZWFyQ29uc3RhbnRzMVsxXSxcbiAgICAgIGMxID0gbGluZWFyQ29uc3RhbnRzMVsyXTtcbiAgdmFyIGEyID0gbGluZWFyQ29uc3RhbnRzMlswXSxcbiAgICAgIGIyID0gbGluZWFyQ29uc3RhbnRzMlsxXSxcbiAgICAgIGMyID0gbGluZWFyQ29uc3RhbnRzMlsyXTtcbiAgdmFyIGlzWmVyb0EgPSBhMSA9PT0gMCAmJiBhMiA9PT0gMDtcbiAgdmFyIGlzWmVyb0IgPSBiMSA9PT0gMCAmJiBiMiA9PT0gMDtcblxuICBpZiAoaXNaZXJvQSAmJiBpc1plcm9CKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2UgaWYgKGlzWmVyb0EpIHtcbiAgICAvLyBiMSAqIHkgKyBjMSA9IDBcbiAgICAvLyBiMiAqIHkgKyBjMiA9IDBcbiAgICB2YXIgeTEgPSAtYzEgLyBiMTtcbiAgICB2YXIgeTIgPSAtYzIgLyBiMjtcblxuICAgIGlmICh5MSAhPT0geTIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtbLUluZmluaXR5LCB5MV0sIFtJbmZpbml0eSwgeTFdXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNaZXJvQikge1xuICAgIC8vIGExICogeCArIGMxID0gMFxuICAgIC8vIGEyICogeCArIGMyID0gMFxuICAgIHZhciB4MSA9IC1jMSAvIGExO1xuICAgIHZhciB4MiA9IC1jMiAvIGEyO1xuXG4gICAgaWYgKHgxICE9PSB4Mikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW1t4MSwgLUluZmluaXR5XSwgW3gxLCBJbmZpbml0eV1dO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhMSA9PT0gMCkge1xuICAgIC8vIGIxICogeSArIGMxID0gMFxuICAgIC8vIHkgPSAtIGMxIC8gYjE7XG4gICAgLy8gYTIgKiB4ICsgYjIgKiB5ICsgYzIgPSAwXG4gICAgdmFyIHkgPSAtYzEgLyBiMTtcbiAgICB2YXIgeCA9IC0oYjIgKiB5ICsgYzIpIC8gYTI7XG4gICAgcmV0dXJuIFtbeCwgeV1dO1xuICB9IGVsc2UgaWYgKGEyID09PSAwKSB7XG4gICAgLy8gYjIgKiB5ICsgYzIgPSAwXG4gICAgLy8geSA9IC0gYzIgLyBiMjtcbiAgICAvLyBhMSAqIHggKyBiMSAqIHkgKyBjMSA9IDBcbiAgICB2YXIgeSA9IC1jMiAvIGIyO1xuICAgIHZhciB4ID0gLShiMSAqIHkgKyBjMSkgLyBhMTtcbiAgICByZXR1cm4gW1t4LCB5XV07XG4gIH0gZWxzZSBpZiAoYjEgPT09IDApIHtcbiAgICAvLyBhMSAqIHggKyBjMSA9IDBcbiAgICAvLyB4ID0gLSBjMSAvIGExO1xuICAgIC8vIGEyICogeCArIGIyICogeSArIGMyID0gMFxuICAgIHZhciB4ID0gLWMxIC8gYTE7XG4gICAgdmFyIHkgPSAtKGEyICogeCArIGMyKSAvIGIyO1xuICAgIHJldHVybiBbW3gsIHldXTtcbiAgfSBlbHNlIGlmIChiMiA9PT0gMCkge1xuICAgIC8vIGEyICogeCArIGMyID0gMFxuICAgIC8vIHggPSAtIGMyIC8gYTI7XG4gICAgLy8gYTEgKiB4ICsgYjEgKiB5ICsgYzEgPSAwXG4gICAgdmFyIHggPSAtYzIgLyBhMjtcbiAgICB2YXIgeSA9IC0oYTEgKiB4ICsgYzEpIC8gYjE7XG4gICAgcmV0dXJuIFtbeCwgeV1dO1xuICB9IGVsc2Uge1xuICAgIC8vIGExICogeCArIGIxICogeSArIGMxID0gMFxuICAgIC8vIGEyICogeCArIGIyICogeSArIGMyID0gMFxuICAgIC8vIGIyICogYTEgKiB4ICsgYjIgKiBiMSAqIHkgKyBiMiAqIGMxID0gMFxuICAgIC8vIGIxICogYTIgKiB4ICsgYjEgKiBiMiAqIHkgKyBiMSAqIGMyID0gMFxuICAgIC8vIChiMiAqIGExIC0gYjEgKiBhMikgICogeCA9IChiMSAqIGMyIC0gYjIgKiBjMSlcbiAgICB2YXIgeCA9IChiMSAqIGMyIC0gYjIgKiBjMSkgLyAoYjIgKiBhMSAtIGIxICogYTIpO1xuICAgIHZhciB5ID0gLShhMSAqIHggKyBjMSkgLyBiMTtcbiAgICByZXR1cm4gW1t4LCB5XV07XG4gIH1cbn1cbi8qKlxuICogR2V0IGludGVyc2VjdGlvbiBwb2ludHMgdG8gdGhlIHR3byBsaW5lcy5cbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50cyhsaW5lMSwgbGluZTIsIGlzTGltaXQpIHtcbiAgdmFyIHBvaW50cyA9IGdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzKGdldExpbmVhckNvbnN0YW50cyhsaW5lMVswXSwgbGluZTFbMV0pLCBnZXRMaW5lYXJDb25zdGFudHMobGluZTJbMF0sIGxpbmUyWzFdKSk7XG5cbiAgaWYgKGlzTGltaXQpIHtcbiAgICByZXR1cm4gZ2V0UG9pbnRzT25MaW5lcyhwb2ludHMsIFtsaW5lMSwgbGluZTJdKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG4vKipcbiAqIEdldCB0aGUgcG9pbnRzIG9uIHRoZSBsaW5lcyAoYmV0d2VlbiB0d28gcG9pbnRzKS5cbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGdldFBvaW50c09uTGluZXMocG9pbnRzLCBsaW5lcykge1xuICB2YXIgbWluTWF4cyA9IGxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgIHJldHVybiBbMCwgMV0ubWFwKGZ1bmN0aW9uIChvcmRlcikge1xuICAgICAgcmV0dXJuIFtNYXRoLm1pbihsaW5lWzBdW29yZGVyXSwgbGluZVsxXVtvcmRlcl0pLCBNYXRoLm1heChsaW5lWzBdW29yZGVyXSwgbGluZVsxXVtvcmRlcl0pXTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgX2EgPSBwb2ludHNbMF0sXG4gICAgICAgIHggPSBfYVswXSxcbiAgICAgICAgeSA9IF9hWzFdO1xuXG4gICAgaWYgKHggPT09IHBvaW50c1sxXVswXSkge1xuICAgICAgLy8vIE1hdGgubWF4KG1pblkxLCBtaW5ZMilcbiAgICAgIHZhciB0b3AgPSBNYXRoLm1heC5hcHBseShNYXRoLCBtaW5NYXhzLm1hcChmdW5jdGlvbiAobWluTWF4KSB7XG4gICAgICAgIHJldHVybiBtaW5NYXhbMV1bMF07XG4gICAgICB9KSk7IC8vLyBNYXRoLm1pbihtYXhZMSwgbWlheDIpXG5cbiAgICAgIHZhciBib3R0b20gPSBNYXRoLm1pbi5hcHBseShNYXRoLCBtaW5NYXhzLm1hcChmdW5jdGlvbiAobWluTWF4KSB7XG4gICAgICAgIHJldHVybiBtaW5NYXhbMV1bMV07XG4gICAgICB9KSk7XG5cbiAgICAgIGlmICh0b3AgPiBib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1t4LCB0b3BdLCBbeCwgYm90dG9tXV07XG4gICAgfSBlbHNlIGlmICh5ID09PSBwb2ludHNbMV1bMV0pIHtcbiAgICAgIC8vLyBNYXRoLm1heChtaW5ZMSwgbWluWTIpXG4gICAgICB2YXIgbGVmdCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIG1pbk1heHMubWFwKGZ1bmN0aW9uIChtaW5NYXgpIHtcbiAgICAgICAgcmV0dXJuIG1pbk1heFswXVswXTtcbiAgICAgIH0pKTsgLy8vIE1hdGgubWluKG1heFkxLCBtaWF4MilcblxuICAgICAgdmFyIHJpZ2h0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgbWluTWF4cy5tYXAoZnVuY3Rpb24gKG1pbk1heCkge1xuICAgICAgICByZXR1cm4gbWluTWF4WzBdWzFdO1xuICAgICAgfSkpO1xuXG4gICAgICBpZiAobGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtbbGVmdCwgeV0sIFtyaWdodCwgeV1dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHJldHVybiBtaW5NYXhzLmV2ZXJ5KGZ1bmN0aW9uIChtaW5NYXgpIHtcbiAgICAgIHJldHVybiBtaW5NYXhbMF1bMF0gPD0gcG9pbnRbMF0gJiYgcG9pbnRbMF0gPD0gbWluTWF4WzBdWzFdICYmIG1pbk1heFsxXVswXSA8PSBwb2ludFsxXSAmJiBwb2ludFsxXSA8PSBtaW5NYXhbMV1bMV07XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4qIENvbnZlcnQgdHdvIHBvaW50cyBpbnRvIGxpbmVzLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4qL1xuXG5mdW5jdGlvbiBjb252ZXJ0TGluZXMocG9pbnRzKSB7XG4gIHJldHVybiBfX3NwcmVhZEFycmF5cyhwb2ludHMuc2xpY2UoMSksIFtwb2ludHNbMF1dKS5tYXAoZnVuY3Rpb24gKHBvaW50LCBpKSB7XG4gICAgcmV0dXJuIFtwb2ludHNbaV0sIHBvaW50XTtcbiAgfSk7XG59XG4vKipcbiogR2V0IHRoZSBwb2ludHMgb2YgdGhlIG92ZXJsYXBwZWQgcGFydCBvZiB0d28gc2hhcGVzLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4qL1xuXG5mdW5jdGlvbiBnZXRPdmVybGFwUG9pbnRzKHBvaW50czEsIHBvaW50czIpIHtcbiAgdmFyIHRhcmdldFBvaW50czEgPSBwb2ludHMxLnNsaWNlKCk7XG4gIHZhciB0YXJnZXRQb2ludHMyID0gcG9pbnRzMi5zbGljZSgpO1xuXG4gIGlmIChnZXRTaGFwZURpcmVjdGlvbih0YXJnZXRQb2ludHMxKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRQb2ludHMxLnJldmVyc2UoKTtcbiAgfVxuXG4gIGlmIChnZXRTaGFwZURpcmVjdGlvbih0YXJnZXRQb2ludHMyKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRQb2ludHMyLnJldmVyc2UoKTtcbiAgfVxuXG4gIHZhciBsaW5lczEgPSBjb252ZXJ0TGluZXModGFyZ2V0UG9pbnRzMSk7XG4gIHZhciBsaW5lczIgPSBjb252ZXJ0TGluZXModGFyZ2V0UG9pbnRzMik7XG4gIHZhciBsaW5lYXJDb25zdGFudHNzMSA9IGxpbmVzMS5tYXAoZnVuY3Rpb24gKGxpbmUxKSB7XG4gICAgcmV0dXJuIGdldExpbmVhckNvbnN0YW50cyhsaW5lMVswXSwgbGluZTFbMV0pO1xuICB9KTtcbiAgdmFyIGxpbmVhckNvbnN0YW50c3MyID0gbGluZXMyLm1hcChmdW5jdGlvbiAobGluZTIpIHtcbiAgICByZXR1cm4gZ2V0TGluZWFyQ29uc3RhbnRzKGxpbmUyWzBdLCBsaW5lMlsxXSk7XG4gIH0pO1xuICB2YXIgb3ZlcmxhcEluZm9zID0gW107XG4gIGxpbmVhckNvbnN0YW50c3MxLmZvckVhY2goZnVuY3Rpb24gKGxpbmVhckNvbnN0YW50czEsIGkpIHtcbiAgICB2YXIgbGluZTEgPSBsaW5lczFbaV07XG4gICAgdmFyIGxpbmVQb2ludEluZm9zID0gW107XG4gICAgbGluZWFyQ29uc3RhbnRzczIuZm9yRWFjaChmdW5jdGlvbiAobGluZWFyQ29uc3RhbnRzMiwgaikge1xuICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50cyA9IGdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzKGxpbmVhckNvbnN0YW50czEsIGxpbmVhckNvbnN0YW50czIpO1xuICAgICAgdmFyIHBvaW50cyA9IGdldFBvaW50c09uTGluZXMoaW50ZXJzZWN0aW9uUG9pbnRzLCBbbGluZTEsIGxpbmVzMltqXV0pO1xuICAgICAgbGluZVBvaW50SW5mb3MucHVzaC5hcHBseShsaW5lUG9pbnRJbmZvcywgcG9pbnRzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZXgxOiBpLFxuICAgICAgICAgIGluZGV4MjogaixcbiAgICAgICAgICBwb3M6IHBvc1xuICAgICAgICB9O1xuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIGxpbmVQb2ludEluZm9zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBnZXREaXN0KGxpbmUxWzBdLCBhLnBvcykgLSBnZXREaXN0KGxpbmUxWzBdLCBiLnBvcyk7XG4gICAgfSk7XG4gICAgb3ZlcmxhcEluZm9zLnB1c2guYXBwbHkob3ZlcmxhcEluZm9zLCBsaW5lUG9pbnRJbmZvcyk7XG5cbiAgICBpZiAoaXNJbnNpZGUobGluZTFbMV0sIHRhcmdldFBvaW50czIpKSB7XG4gICAgICBvdmVybGFwSW5mb3MucHVzaCh7XG4gICAgICAgIGluZGV4MTogaSxcbiAgICAgICAgaW5kZXgyOiAtMSxcbiAgICAgICAgcG9zOiBsaW5lMVsxXVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbGluZXMyLmZvckVhY2goZnVuY3Rpb24gKGxpbmUyLCBpKSB7XG4gICAgaWYgKGlzSW5zaWRlKGxpbmUyWzFdLCB0YXJnZXRQb2ludHMxKSkge1xuICAgICAgdmFyIGlzTmV4dF8xID0gZmFsc2U7XG4gICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgob3ZlcmxhcEluZm9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGluZGV4MiA9IF9hLmluZGV4MjtcblxuICAgICAgICBpZiAoaW5kZXgyID09PSBpKSB7XG4gICAgICAgICAgaXNOZXh0XzEgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05leHRfMSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgaXNOZXh0XzEgPSBmYWxzZTtcbiAgICAgICAgaW5kZXggPSBmaW5kSW5kZXgob3ZlcmxhcEluZm9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICB2YXIgaW5kZXgxID0gX2EuaW5kZXgxLFxuICAgICAgICAgICAgICBpbmRleDIgPSBfYS5pbmRleDI7XG5cbiAgICAgICAgICBpZiAoaW5kZXgxID09PSAtMSAmJiBpbmRleDIgKyAxID09PSBpKSB7XG4gICAgICAgICAgICBpc05leHRfMSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzTmV4dF8xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIG92ZXJsYXBJbmZvcy5wdXNoKHtcbiAgICAgICAgICBpbmRleDE6IC0xLFxuICAgICAgICAgIGluZGV4MjogaSxcbiAgICAgICAgICBwb3M6IGxpbmUyWzFdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3ZlcmxhcEluZm9zLnNwbGljZShpbmRleCwgMCwge1xuICAgICAgICAgIGluZGV4MTogLTEsXG4gICAgICAgICAgaW5kZXgyOiBpLFxuICAgICAgICAgIHBvczogbGluZTJbMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTsgLy8gY29uc29sZS5sb2cob3ZlcmxhcEluZm9zKTtcblxuICB2YXIgb3ZlcmxhcFBvaW50cyA9IG92ZXJsYXBJbmZvcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHBvcyA9IF9hLnBvcztcbiAgICByZXR1cm4gcG9zO1xuICB9KTtcbiAgdmFyIHBvaW50TWFwID0ge307XG4gIHJldHVybiBvdmVybGFwUG9pbnRzLmZpbHRlcihmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIga2V5ID0gcG9pbnRbMF0gKyBcInhcIiArIHBvaW50WzFdO1xuXG4gICAgaWYgKHBvaW50TWFwW2tleV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwb2ludE1hcFtrZXldID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG4vKipcbiogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgb3ZlcmxhcHBlZCBwYXJ0IG9mIHR3byBzaGFwZXMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiovXG5cbmZ1bmN0aW9uIGdldE92ZXJsYXBTaXplKHBvaW50czEsIHBvaW50czIpIHtcbiAgdmFyIHBvaW50cyA9IGdldE92ZXJsYXBQb2ludHMocG9pbnRzMSwgcG9pbnRzMik7XG4gIHJldHVybiBnZXRBcmVhU2l6ZShwb2ludHMpO1xufVxuXG5leHBvcnQgeyBjb252ZXJ0TGluZXMsIGZpdFBvaW50cywgZ2V0QXJlYVNpemUsIGdldEludGVyc2VjdGlvblBvaW50cywgZ2V0SW50ZXJzZWN0aW9uUG9pbnRzQnlDb25zdGFudHMsIGdldExpbmVhckNvbnN0YW50cywgZ2V0TWluTWF4cywgZ2V0T3ZlcmxhcFBvaW50cywgZ2V0T3ZlcmxhcFNpemUsIGdldFBvaW50c09uTGluZXMsIGlzSW5zaWRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdmVybGFwLWFyZWEuZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgRGF5YnJ1c2hcbm5hbWU6IHJlYWN0LWNvbXBhdC1jc3Mtc3R5bGVkXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvY3NzLXN0eWxlZC5naXRcbnZlcnNpb246IDEuMC44XG4qL1xuaW1wb3J0IGNzc1N0eWxlZCBmcm9tICdjc3Mtc3R5bGVkJztcbmltcG9ydCB7IHZlcnNpb24sIGNyZWF0ZUVsZW1lbnQsIENvbXBvbmVudCB9IGZyb20gJ3JlYWN0LXNpbXBsZS1jb21wYXQnO1xuaW1wb3J0IHsgcmVmIH0gZnJvbSAnZnJhbWV3b3JrLXV0aWxzJztcblxuLypcbkNvcHlyaWdodCAoYykgMjAxOSBEYXlicnVzaFxubmFtZTogcmVhY3QtY3NzLXN0eWxlZFxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvY3NzLXN0eWxlZC90cmVlL21hc3Rlci9wYWNrYWdlcy9yZWFjdC1jc3Mtc3R5bGVkXG52ZXJzaW9uOiAxLjAuM1xuKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG5cbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuXG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbnZhciBTdHlsZWRFbGVtZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFN0eWxlZEVsZW1lbnQsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU3R5bGVkRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLmluamVjdFJlc3VsdCA9IG51bGw7XG4gICAgX3RoaXMudGFnID0gXCJkaXZcIjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IFN0eWxlZEVsZW1lbnQucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsXG4gICAgICAgIF9iID0gX2EuY2xhc3NOYW1lLFxuICAgICAgICBjbGFzc05hbWUgPSBfYiA9PT0gdm9pZCAwID8gXCJcIiA6IF9iLFxuICAgICAgICBjc3BOb25jZSA9IF9hLmNzcE5vbmNlLFxuICAgICAgICBwb3J0YWxDb250YWluZXIgPSBfYS5wb3J0YWxDb250YWluZXIsXG4gICAgICAgIGF0dHJpYnV0ZXMgPSBfX3Jlc3QoX2EsIFtcImNsYXNzTmFtZVwiLCBcImNzcE5vbmNlXCIsIFwicG9ydGFsQ29udGFpbmVyXCJdKTtcblxuICAgIHZhciBjc3NJZCA9IHRoaXMuaW5qZWN0b3IuY2xhc3NOYW1lO1xuICAgIHZhciBUYWcgPSB0aGlzLnRhZztcbiAgICB2YXIgcG9ydGFsQXR0cmlidXRlcyA9IHt9O1xuXG4gICAgaWYgKCh2ZXJzaW9uIHx8IFwiXCIpLmluZGV4T2YoXCJzaW1wbGVcIikgPiAtMSAmJiBwb3J0YWxDb250YWluZXIpIHtcbiAgICAgIHBvcnRhbEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHBvcnRhbENvbnRhaW5lcjogcG9ydGFsQ29udGFpbmVyXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFRhZywgX19hc3NpZ24oe1xuICAgICAgXCJyZWZcIjogcmVmKHRoaXMsIFwiZWxlbWVudFwiKSxcbiAgICAgIFwiZGF0YS1zdHlsZWQtaWRcIjogY3NzSWQsXG4gICAgICBcImNsYXNzTmFtZVwiOiBjbGFzc05hbWUgKyBcIiBcIiArIGNzc0lkXG4gICAgfSwgcG9ydGFsQXR0cmlidXRlcywgYXR0cmlidXRlcykpO1xuICB9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pbmplY3RSZXN1bHQgPSB0aGlzLmluamVjdG9yLmluamVjdCh0aGlzLmVsZW1lbnQsIHtcbiAgICAgIG5vbmNlOiB0aGlzLnByb3BzLmNzcE5vbmNlXG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmluamVjdFJlc3VsdC5kZXN0cm95KCk7XG4gICAgdGhpcy5pbmplY3RSZXN1bHQgPSBudWxsO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICB9O1xuXG4gIHJldHVybiBTdHlsZWRFbGVtZW50O1xufShDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBzdHlsZWQodGFnLCBjc3MpIHtcbiAgdmFyIGluamVjdG9yID0gY3NzU3R5bGVkKGNzcyk7XG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhTdHlsZWQsIF9zdXBlcik7XG5cbiAgICAgIGZ1bmN0aW9uIFN0eWxlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICAgICAgX3RoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgX3RoaXMudGFnID0gdGFnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTdHlsZWQ7XG4gICAgfShTdHlsZWRFbGVtZW50KVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHlsZWQ7XG5leHBvcnQgeyBTdHlsZWRFbGVtZW50IH07XG4iLCIvKlxuQ29weXJpZ2h0IChjKSBEYXlicnVzaFxubmFtZTogcmVhY3Qtc2ltcGxlLWNvbXBhdFxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL3JlYWN0LXNpbXBsZS1jb21wYXQuZ2l0XG52ZXJzaW9uOiAxLjIuMlxuKi9cbmltcG9ydCB7IGRpZmYgfSBmcm9tICdAZWdqcy9saXN0LWRpZmZlcic7XG5pbXBvcnQgeyBpc0FycmF5LCBpc1N0cmluZywgaXNOdW1iZXIsIGlzVW5kZWZpbmVkLCBkZWNhbWVsaXplIH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG5cbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuXG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKSBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKykgcltrXSA9IGFbal07XG5cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGlzRGlmZihhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSBpbiBhKSB7XG4gICAgaWYgKCEoaSBpbiBiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZGlmZk9iamVjdChhLCBiKSB7XG4gIHZhciBrZXlzMSA9IE9iamVjdC5rZXlzKGEpO1xuICB2YXIga2V5czIgPSBPYmplY3Qua2V5cyhiKTtcbiAgdmFyIHJlc3VsdCA9IGRpZmYoa2V5czEsIGtleXMyLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG4gIHZhciBhZGRlZCA9IHt9O1xuICB2YXIgcmVtb3ZlZCA9IHt9O1xuICB2YXIgY2hhbmdlZCA9IHt9O1xuICByZXN1bHQuYWRkZWQuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgbmFtZSA9IGtleXMyW2luZGV4XTtcbiAgICBhZGRlZFtuYW1lXSA9IGJbbmFtZV07XG4gIH0pO1xuICByZXN1bHQucmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBuYW1lID0ga2V5czFbaW5kZXhdO1xuICAgIHJlbW92ZWRbbmFtZV0gPSBhW25hbWVdO1xuICB9KTtcbiAgcmVzdWx0Lm1haW50YWluZWQuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgaW5kZXggPSBfYVswXTtcbiAgICB2YXIgbmFtZSA9IGtleXMxW2luZGV4XTtcbiAgICB2YXIgdmFsdWVzID0gW2FbbmFtZV0sIGJbbmFtZV1dO1xuXG4gICAgaWYgKGFbbmFtZV0gIT09IGJbbmFtZV0pIHtcbiAgICAgIGNoYW5nZWRbbmFtZV0gPSB2YWx1ZXM7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBhZGRlZDogYWRkZWQsXG4gICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICBjaGFuZ2VkOiBjaGFuZ2VkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVIb29rcyhob29rcykge1xuICBob29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9vaygpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZmlsbEtleXMoa2V5cykge1xuICB2YXIgaW5kZXggPSAwO1xuICByZXR1cm4ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkgPT0gbnVsbCA/IFwiJGNvbXBhdFwiICsgKytpbmRleCA6IFwiXCIgKyBrZXk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm92aWRlcihlbCwga2V5LCBpbmRleCwgY29udGFpbmVyKSB7XG4gIGlmIChpc1N0cmluZyhlbCkgfHwgaXNOdW1iZXIoZWwpKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0UHJvdmlkZXIoXCJ0ZXh0X1wiICsgZWwsIGtleSwgaW5kZXgsIGNvbnRhaW5lciwgbnVsbCwge30pO1xuICB9XG5cbiAgdmFyIHByb3ZpZGVyQ2xhc3MgPSB0eXBlb2YgZWwudHlwZSA9PT0gXCJzdHJpbmdcIiA/IEVsZW1lbnRQcm92aWRlciA6IGVsLnR5cGUucHJvdG90eXBlLnJlbmRlciA/IENvbXBvbmVudFByb3ZpZGVyIDogRnVuY3Rpb25Qcm92aWRlcjtcbiAgcmV0dXJuIG5ldyBwcm92aWRlckNsYXNzKGVsLnR5cGUsIGtleSwgaW5kZXgsIGNvbnRhaW5lciwgZWwucmVmLCBlbC5wcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGZsYXQoYXJyKSB7XG4gIHZhciBhcnIyID0gW107XG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGFycjIgPSBhcnIyLmNvbmNhdChpc0FycmF5KGVsKSA/IGZsYXQoZWwpIDogZWwpO1xuICB9KTtcbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIG90aGVyUHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcImNsYXNzTmFtZVwiXSk7XG5cbiAgaWYgKGNsYXNzTmFtZSAhPSBudWxsKSB7XG4gICAgb3RoZXJQcm9wcy5jbGFzcyA9IGNsYXNzTmFtZTtcbiAgfVxuXG4gIGRlbGV0ZSBvdGhlclByb3BzLnN0eWxlO1xuICBkZWxldGUgb3RoZXJQcm9wcy5jaGlsZHJlbjtcbiAgcmV0dXJuIG90aGVyUHJvcHM7XG59XG5cbmZ1bmN0aW9uIGZpbGxQcm9wcyhwcm9wcywgZGVmYXVsdFByb3BzKSB7XG4gIGlmICghZGVmYXVsdFByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQocHJvcHNbbmFtZV0pKSB7XG4gICAgICBwcm9wc1tuYW1lXSA9IGRlZmF1bHRQcm9wc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBjaGlsZHJlbltfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciBfYSA9IHByb3BzIHx8IHt9LFxuICAgICAga2V5ID0gX2Eua2V5LFxuICAgICAgcmVmID0gX2EucmVmLFxuICAgICAgb3RoZXJQcm9wcyA9IF9fcmVzdChfYSwgW1wia2V5XCIsIFwicmVmXCJdKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBvdGhlclByb3BzKSwge1xuICAgICAgY2hpbGRyZW46IGZsYXQoY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkICE9IG51bGwgJiYgY2hpbGQgIT09IGZhbHNlO1xuICAgICAgfSlcbiAgICB9KVxuICB9O1xufVxuXG52YXIgUHJvdmlkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm92aWRlcih0eXBlLCBrZXksIGluZGV4LCBjb250YWluZXIsIHJlZiwgcHJvcHMpIHtcbiAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5fcHJvdmlkZXJzID0gW107XG4gIH1cblxuICB2YXIgX19wcm90byA9IFByb3ZpZGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLl9zaG91bGQgPSBmdW5jdGlvbiAobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfX3Byb3RvLl91cGRhdGUgPSBmdW5jdGlvbiAoaG9va3MsIG5leHRFbGVtZW50LCBuZXh0U3RhdGUsIGlzRm9yY2VVcGRhdGUpIHtcbiAgICBpZiAodGhpcy5iYXNlICYmICFpc1N0cmluZyhuZXh0RWxlbWVudCkgJiYgIWlzRm9yY2VVcGRhdGUgJiYgIXRoaXMuX3Nob3VsZChuZXh0RWxlbWVudC5wcm9wcywgbmV4dFN0YXRlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMub3JpZ2luYWwgPSBuZXh0RWxlbWVudDtcblxuICAgIHRoaXMuX3NldFN0YXRlKG5leHRTdGF0ZSk7IC8vIHJlbmRlclxuXG5cbiAgICB2YXIgcHJldlByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghaXNTdHJpbmcobmV4dEVsZW1lbnQpKSB7XG4gICAgICB0aGlzLnByb3BzID0gbmV4dEVsZW1lbnQucHJvcHM7XG4gICAgICB0aGlzLnJlZiA9IG5leHRFbGVtZW50LnJlZjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoaG9va3MsIHRoaXMuYmFzZSA/IHByZXZQcm9wcyA6IHt9LCBuZXh0U3RhdGUpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5fbW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5yZWY7XG4gICAgcmVmICYmIHJlZih0aGlzLmJhc2UpO1xuICB9O1xuXG4gIF9fcHJvdG8uX3NldFN0YXRlID0gZnVuY3Rpb24gKG5leHRzdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfTtcblxuICBfX3Byb3RvLl91cGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWYgPSB0aGlzLnJlZjtcbiAgICByZWYgJiYgcmVmKHRoaXMuYmFzZSk7XG4gIH07XG5cbiAgX19wcm90by5fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5yZWY7XG4gICAgcmVmICYmIHJlZihudWxsKTtcbiAgfTtcblxuICByZXR1cm4gUHJvdmlkZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGRpZmZBdHRyaWJ1dGVzKGF0dHJzMSwgYXR0cnMyLCBlbCkge1xuICB2YXIgX2EgPSBkaWZmT2JqZWN0KGF0dHJzMSwgYXR0cnMyKSxcbiAgICAgIGFkZGVkID0gX2EuYWRkZWQsXG4gICAgICByZW1vdmVkID0gX2EucmVtb3ZlZCxcbiAgICAgIGNoYW5nZWQgPSBfYS5jaGFuZ2VkO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gYWRkZWQpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgYWRkZWRbbmFtZV0pO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBjaGFuZ2VkKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIGNoYW5nZWRbbmFtZV1bMV0pO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiByZW1vdmVkKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpZmZFdmVudHMoZXZlbnRzMSwgZXZlbnRzMiwgcHJvdmllcikge1xuICB2YXIgX2EgPSBkaWZmT2JqZWN0KGV2ZW50czEsIGV2ZW50czIpLFxuICAgICAgYWRkZWQgPSBfYS5hZGRlZCxcbiAgICAgIHJlbW92ZWQgPSBfYS5yZW1vdmVkLFxuICAgICAgY2hhbmdlZCA9IF9hLmNoYW5nZWQ7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiByZW1vdmVkKSB7XG4gICAgcHJvdmllci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUpO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBhZGRlZCkge1xuICAgIHByb3ZpZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBhZGRlZFtuYW1lXSk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIGNoYW5nZWQpIHtcbiAgICBwcm92aWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSk7XG4gICAgcHJvdmllci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNoYW5nZWRbbmFtZV1bMV0pO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiByZW1vdmVkKSB7XG4gICAgcHJvdmllci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpZmZTdHlsZShzdHlsZTEsIHN0eWxlMiwgZWwpIHtcbiAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XG5cbiAgdmFyIF9hID0gZGlmZk9iamVjdChzdHlsZTEsIHN0eWxlMiksXG4gICAgICBhZGRlZCA9IF9hLmFkZGVkLFxuICAgICAgcmVtb3ZlZCA9IF9hLnJlbW92ZWQsXG4gICAgICBjaGFuZ2VkID0gX2EuY2hhbmdlZDtcblxuICBmb3IgKHZhciBiZWZvcmVOYW1lIGluIGFkZGVkKSB7XG4gICAgdmFyIG5hbWUgPSBkZWNhbWVsaXplKGJlZm9yZU5hbWUsIFwiLVwiKTtcblxuICAgIGlmIChzdHlsZS5zZXRQcm9wZXJ0eSkge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgYWRkZWRbYmVmb3JlTmFtZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtuYW1lXSA9IGFkZGVkW2JlZm9yZU5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGJlZm9yZU5hbWUgaW4gY2hhbmdlZCkge1xuICAgIHZhciBuYW1lID0gZGVjYW1lbGl6ZShiZWZvcmVOYW1lLCBcIi1cIik7XG5cbiAgICBpZiAoc3R5bGUuc2V0UHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGNoYW5nZWRbYmVmb3JlTmFtZV1bMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtuYW1lXSA9IGNoYW5nZWRbYmVmb3JlTmFtZV1bMV07XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgYmVmb3JlTmFtZSBpbiByZW1vdmVkKSB7XG4gICAgdmFyIG5hbWUgPSBkZWNhbWVsaXplKGJlZm9yZU5hbWUsIFwiLVwiKTtcblxuICAgIGlmIChzdHlsZS5yZW1vdmVQcm9wZXJ0eSkge1xuICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW25hbWVdID0gXCJcIjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BsaXRQcm9wcyhwcm9wcykge1xuICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICB2YXIgZXZlbnRzID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xuICAgIGlmIChuYW1lLmluZGV4T2YoXCJvblwiKSA9PT0gMCkge1xuICAgICAgZXZlbnRzW25hbWUucmVwbGFjZShcIm9uXCIsIFwiXCIpLnRvTG93ZXJDYXNlKCldID0gcHJvcHNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgZXZlbnRzOiBldmVudHNcbiAgfTtcbn1cblxudmFyIFRleHRQcm92aWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUZXh0UHJvdmlkZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVGV4dFByb3ZpZGVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gVGV4dFByb3ZpZGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLl9yZW5kZXIgPSBmdW5jdGlvbiAoaG9va3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGlzTW91bnQgPSAhdGhpcy5iYXNlO1xuXG4gICAgaWYgKGlzTW91bnQpIHtcbiAgICAgIHRoaXMuYmFzZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudHlwZS5yZXBsYWNlKFwidGV4dF9cIiwgXCJcIikpO1xuICAgIH1cblxuICAgIGhvb2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgX3RoaXMuX21vdW50ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl91cGRhdGVkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5fdW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJhc2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhc2UpO1xuICB9O1xuXG4gIHJldHVybiBUZXh0UHJvdmlkZXI7XG59KFByb3ZpZGVyKTtcblxudmFyIEVsZW1lbnRQcm92aWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhFbGVtZW50UHJvdmlkZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gRWxlbWVudFByb3ZpZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuZXZlbnRzID0ge307XG4gICAgX3RoaXMuX2lzU1ZHID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBFbGVtZW50UHJvdmlkZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cztcblxuICAgIGV2ZW50c1tuYW1lXSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLm5hdGl2ZUV2ZW50ID0gZTtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgIH07XG5cbiAgICB0aGlzLmJhc2UuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudHNbbmFtZV0pO1xuICB9O1xuXG4gIF9fcHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgIHRoaXMuYmFzZS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50c1tuYW1lXSk7XG4gICAgZGVsZXRlIGV2ZW50c1tuYW1lXTtcbiAgfTtcblxuICBfX3Byb3RvLl9zaG91bGQgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgcmV0dXJuIGlzRGlmZih0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uX3JlbmRlciA9IGZ1bmN0aW9uIChob29rcywgcHJldlByb3BzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBpc01vdW50ID0gIXRoaXMuYmFzZTtcblxuICAgIGlmIChpc01vdW50KSB7XG4gICAgICB2YXIgaXNTVkcgPSB0aGlzLl9oYXNTVkcoKTtcblxuICAgICAgdGhpcy5faXNTVkcgPSBpc1NWRztcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wcm9wcy5wb3J0YWxDb250YWluZXI7XG5cbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5iYXNlID0gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZW5kZXJQcm92aWRlcnModGhpcywgdGhpcy5fcHJvdmlkZXJzLCB0aGlzLnByb3BzLmNoaWxkcmVuLCBob29rcywgbnVsbCk7XG4gICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG5cbiAgICB2YXIgX2EgPSBzcGxpdFByb3BzKHByZXZQcm9wcyksXG4gICAgICAgIHByZXZBdHRyaWJ1dGVzID0gX2EuYXR0cmlidXRlcyxcbiAgICAgICAgcHJldkV2ZW50cyA9IF9hLmV2ZW50cztcblxuICAgIHZhciBfYiA9IHNwbGl0UHJvcHModGhpcy5wcm9wcyksXG4gICAgICAgIG5leHRBdHRyaWJ1dGVzID0gX2IuYXR0cmlidXRlcyxcbiAgICAgICAgbmV4dEV2ZW50cyA9IF9iLmV2ZW50cztcblxuICAgIGRpZmZBdHRyaWJ1dGVzKGdldEF0dHJpYnV0ZXMocHJldkF0dHJpYnV0ZXMpLCBnZXRBdHRyaWJ1dGVzKG5leHRBdHRyaWJ1dGVzKSwgYmFzZSk7XG4gICAgZGlmZkV2ZW50cyhwcmV2RXZlbnRzLCBuZXh0RXZlbnRzLCB0aGlzKTtcbiAgICBkaWZmU3R5bGUocHJldlByb3BzLnN0eWxlIHx8IHt9LCB0aGlzLnByb3BzLnN0eWxlIHx8IHt9LCBiYXNlKTtcbiAgICBob29rcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc01vdW50KSB7XG4gICAgICAgIF90aGlzLl9tb3VudGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5fdXBkYXRlZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICAgIGJhc2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudHNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3Byb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgcHJvdmlkZXIuX3VubW91bnQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZXZlbnRzID0ge307XG5cbiAgICBpZiAoIXRoaXMucHJvcHMucG9ydGFsQ29udGFpbmVyKSB7XG4gICAgICBiYXNlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFzZSk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uX2hhc1NWRyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faXNTVkcgfHwgdGhpcy50eXBlID09PSBcInN2Z1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyTm9kZSA9IGZpbmRDb250YWluZXJOb2RlKHRoaXMuY29udGFpbmVyKTtcbiAgICByZXR1cm4gY29udGFpbmVyTm9kZSAmJiBcIm93bmVyU1ZHRWxlbWVudFwiIGluIGNvbnRhaW5lck5vZGU7XG4gIH07XG5cbiAgcmV0dXJuIEVsZW1lbnRQcm92aWRlcjtcbn0oUHJvdmlkZXIpO1xuXG5mdW5jdGlvbiBmaW5kQ29udGFpbmVyTm9kZShwcm92aWRlcikge1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYmFzZSA9IHByb3ZpZGVyLmJhc2U7XG5cbiAgaWYgKGJhc2UgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICByZXR1cm4gZmluZENvbnRhaW5lck5vZGUocHJvdmlkZXIuY29udGFpbmVyKTtcbn1cblxuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcCkge1xuICBpZiAoIWNvbXApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb21wIGluc3RhbmNlb2YgTm9kZSkge1xuICAgIHJldHVybiBjb21wO1xuICB9XG5cbiAgdmFyIHByb3ZpZGVycyA9IGNvbXAuJF9wcm92aWRlci5fcHJvdmlkZXJzO1xuXG4gIGlmICghcHJvdmlkZXJzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGZpbmRET01Ob2RlKHByb3ZpZGVyc1swXS5iYXNlKTtcbn1cblxudmFyIEZ1bmN0aW9uUHJvdmlkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRnVuY3Rpb25Qcm92aWRlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBGdW5jdGlvblByb3ZpZGVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gRnVuY3Rpb25Qcm92aWRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5fcmVuZGVyID0gZnVuY3Rpb24gKGhvb2tzKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy50eXBlKHRoaXMucHJvcHMpO1xuICAgIHJlbmRlclByb3ZpZGVycyh0aGlzLCB0aGlzLl9wcm92aWRlcnMsIHRlbXBsYXRlID8gW3RlbXBsYXRlXSA6IFtdLCBob29rcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5fdW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgIHByb3ZpZGVyLl91bm1vdW50KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEZ1bmN0aW9uUHJvdmlkZXI7XG59KFByb3ZpZGVyKTtcblxudmFyIENvbnRhaW5lclByb3ZpZGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKENvbnRhaW5lclByb3ZpZGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIENvbnRhaW5lclByb3ZpZGVyKGJhc2UpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcImNvbnRhaW5lclwiLCBcImNvbnRhaW5lclwiLCAwLCBudWxsKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuYmFzZSA9IGJhc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBDb250YWluZXJQcm92aWRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIHJldHVybiBDb250YWluZXJQcm92aWRlcjtcbn0oUHJvdmlkZXIpO1xuXG52YXIgQ29tcG9uZW50UHJvdmlkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ29tcG9uZW50UHJvdmlkZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50UHJvdmlkZXIodHlwZSwga2V5LCBpbmRleCwgY29udGFpbmVyLCByZWYsIHByb3BzKSB7XG4gICAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICAgIHByb3BzID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIGtleSwgaW5kZXgsIGNvbnRhaW5lciwgcmVmLCBmaWxsUHJvcHMocHJvcHMsIHR5cGUuZGVmYXVsdFByb3BzKSkgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gQ29tcG9uZW50UHJvdmlkZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uX3Nob3VsZCA9IGZ1bmN0aW9uIChuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmJhc2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKGZpbGxQcm9wcyhuZXh0UHJvcHMsIHRoaXMudHlwZS5kZWZhdWx0UHJvcHMpLCBuZXh0U3RhdGUgfHwgdGhpcy5iYXNlLnN0YXRlKTtcbiAgfTtcblxuICBfX3Byb3RvLl9yZW5kZXIgPSBmdW5jdGlvbiAoaG9va3MsIHByZXZQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMucHJvcHMgPSBmaWxsUHJvcHModGhpcy5wcm9wcywgdGhpcy50eXBlLmRlZmF1bHRQcm9wcyk7XG4gICAgdmFyIGlzTW91bnQgPSAhdGhpcy5iYXNlO1xuXG4gICAgaWYgKGlzTW91bnQpIHtcbiAgICAgIHRoaXMuYmFzZSA9IG5ldyB0aGlzLnR5cGUodGhpcy5wcm9wcyk7XG4gICAgICB0aGlzLmJhc2UuJF9wcm92aWRlciA9IHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmFzZS5wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgdmFyIHByZXZTdGF0ZSA9IGJhc2Uuc3RhdGU7XG4gICAgdmFyIHRlbXBsYXRlID0gYmFzZS5yZW5kZXIoKTtcblxuICAgIGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5wcm9wcyAmJiAhdGVtcGxhdGUucHJvcHMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0ZW1wbGF0ZS5wcm9wcy5jaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgcmVuZGVyUHJvdmlkZXJzKHRoaXMsIHRoaXMuX3Byb3ZpZGVycywgdGVtcGxhdGUgPyBbdGVtcGxhdGVdIDogW10sIGhvb2tzLCBuZXh0U3RhdGUsIG51bGwpO1xuICAgIGhvb2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgX3RoaXMuX21vdW50ZWQoKTtcblxuICAgICAgICBiYXNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5fdXBkYXRlZCgpO1xuXG4gICAgICAgIGJhc2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLl9zZXRTdGF0ZSA9IGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICB2YXIgYmFzZSA9IHRoaXMuYmFzZTtcblxuICAgIGlmICghYmFzZSB8fCAhbmV4dFN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYmFzZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgfTtcblxuICBfX3Byb3RvLl91bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Byb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgcHJvdmlkZXIuX3VubW91bnQoKTtcbiAgICB9KTtcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLmJhc2UuJF90aW1lcik7XG4gICAgdGhpcy5iYXNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gIH07XG5cbiAgcmV0dXJuIENvbXBvbmVudFByb3ZpZGVyO1xufShQcm92aWRlcik7XG5cbnZhciBDb21wb25lbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMpIHtcbiAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMuJF90aW1lciA9IDA7XG4gICAgdGhpcy4kX3N0YXRlID0ge307XG4gIH1cblxuICB2YXIgX19wcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbiAgX19wcm90by5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAocHJvcHMsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX19wcm90by5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2FsbGJhY2ssIGlzRm9yY2VVcGRhdGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLiRfdGltZXIpIHtcbiAgICAgIHRoaXMuJF9zdGF0ZSA9IHt9O1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dCh0aGlzLiRfdGltZXIpO1xuICAgIHRoaXMuJF90aW1lciA9IDA7XG4gICAgdGhpcy4kX3N0YXRlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuJF9zdGF0ZSksIHN0YXRlKTtcblxuICAgIGlmICghaXNGb3JjZVVwZGF0ZSkge1xuICAgICAgdGhpcy4kX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLiRfdGltZXIgPSAwO1xuXG4gICAgICAgIF90aGlzLiRfc2V0U3RhdGUoY2FsbGJhY2ssIGlzRm9yY2VVcGRhdGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJF9zZXRTdGF0ZShjYWxsYmFjaywgaXNGb3JjZVVwZGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIF9fcHJvdG8uZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnNldFN0YXRlKHt9LCBjYWxsYmFjaywgdHJ1ZSk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcywgcHJldlN0YXRlKSB7fTtcblxuICBfX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge307XG5cbiAgX19wcm90by4kX3NldFN0YXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBpc0ZvcmNlVXBkYXRlKSB7XG4gICAgdmFyIGhvb2tzID0gW107XG4gICAgdmFyIHByb3ZpZGVyID0gdGhpcy4kX3Byb3ZpZGVyO1xuICAgIHZhciBpc1VwZGF0ZSA9IHJlbmRlclByb3ZpZGVycyhwcm92aWRlci5jb250YWluZXIsIFtwcm92aWRlcl0sIFtwcm92aWRlci5vcmlnaW5hbF0sIGhvb2tzLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5zdGF0ZSksIHRoaXMuJF9zdGF0ZSksIGlzRm9yY2VVcGRhdGUpO1xuXG4gICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgaG9va3MucHVzaChjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIGV4ZWN1dGVIb29rcyhob29rcyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59KCk7XG5cbnZhciBQdXJlQ29tcG9uZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFB1cmVDb21wb25lbnQsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUHVyZUNvbXBvbmVudCgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gKHByb3BzLCBzdGF0ZSkge1xuICAgIHJldHVybiBpc0RpZmYodGhpcy5wcm9wcywgcHJvcHMpIHx8IGlzRGlmZih0aGlzLnN0YXRlLCBzdGF0ZSk7XG4gIH07XG5cbiAgcmV0dXJuIFB1cmVDb21wb25lbnQ7XG59KENvbXBvbmVudCk7XG5cbnZhciBfUG9ydGFsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKF9Qb3J0YWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gX1BvcnRhbCgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IF9Qb3J0YWwucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZWxlbWVudCA9IF9hLmVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lcjtcbiAgICB0aGlzLl9wb3J0YWxQcm92aWRlciA9IG5ldyBDb250YWluZXJQcm92aWRlcihjb250YWluZXIpO1xuICAgIHJlbmRlclByb3ZpZGVyKGVsZW1lbnQsIGNvbnRhaW5lciwgdGhpcy5fcG9ydGFsUHJvdmlkZXIpO1xuICB9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsXG4gICAgICAgIGVsZW1lbnQgPSBfYS5lbGVtZW50LFxuICAgICAgICBjb250YWluZXIgPSBfYS5jb250YWluZXI7XG4gICAgcmVuZGVyUHJvdmlkZXIoZWxlbWVudCwgY29udGFpbmVyLCB0aGlzLl9wb3J0YWxQcm92aWRlcik7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5wcm9wcy5jb250YWluZXI7XG4gICAgcmVuZGVyUHJvdmlkZXIobnVsbCwgY29udGFpbmVyLCB0aGlzLl9wb3J0YWxQcm92aWRlcik7XG4gICAgdGhpcy5fcG9ydGFsUHJvdmlkZXIgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBfUG9ydGFsO1xufShQdXJlQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gdXBkYXRlUHJvdmlkZXIocHJvdmlkZXIsIGNoaWxkcmVuLCBuZXh0U3RhdGUpIHtcbiAgdmFyIGhvb2tzID0gW107XG4gIHJlbmRlclByb3ZpZGVycyhwcm92aWRlciwgcHJvdmlkZXIuX3Byb3ZpZGVycywgY2hpbGRyZW4sIGhvb2tzLCBuZXh0U3RhdGUpO1xuICBleGVjdXRlSG9va3MoaG9va3MpO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0U2liaWxpbmcocHJvdmlkZXIsIGNoaWxkUHJvdmlkZXIpIHtcbiAgdmFyIGNoaWxkUHJvdmlkZXJzID0gcHJvdmlkZXIuX3Byb3ZpZGVycztcbiAgdmFyIGxlbmd0aCA9IGNoaWxkUHJvdmlkZXJzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gY2hpbGRQcm92aWRlci5pbmRleCArIDE7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBlbCA9IGZpbmRET01Ob2RlKGNoaWxkUHJvdmlkZXJzW2ldLmJhc2UpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRpZmZQcm92aWRlcnMoY29udGFpbmVyUHJvdmlkZXIsIHByb3ZpZGVycywgY2hpbGRyZW4pIHtcbiAgdmFyIGNoaWxkcmVuS2V5cyA9IGNoaWxkcmVuLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBpc1N0cmluZyhwKSA/IG51bGwgOiBwLmtleTtcbiAgfSk7XG4gIHZhciBrZXlzMSA9IGZpbGxLZXlzKHByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC5rZXk7XG4gIH0pKTtcbiAgdmFyIGtleXMyID0gZmlsbEtleXMoY2hpbGRyZW5LZXlzKTtcbiAgdmFyIHJlc3VsdCA9IGRpZmYoa2V5czEsIGtleXMyLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG4gIHJlc3VsdC5yZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcHJvdmlkZXJzLnNwbGljZShpbmRleCwgMSlbMF0uX3VubW91bnQoKTtcbiAgfSk7XG4gIHJlc3VsdC5vcmRlcmVkLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGZyb20gPSBfYVswXSxcbiAgICAgICAgdG8gPSBfYVsxXTtcbiAgICB2YXIgY2hpbGRyZW5Qcm92aWRlciA9IHByb3ZpZGVycy5zcGxpY2UoZnJvbSwgMSlbMF07XG4gICAgcHJvdmlkZXJzLnNwbGljZSh0bywgMCwgY2hpbGRyZW5Qcm92aWRlcik7XG4gICAgdmFyIGVsID0gZmluZERPTU5vZGUoY2hpbGRyZW5Qcm92aWRlci5iYXNlKTtcbiAgICB2YXIgbmV4dCA9IGZpbmRET01Ob2RlKHByb3ZpZGVyc1t0byArIDFdICYmIHByb3ZpZGVyc1t0byArIDFdLmJhc2UpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbmV4dCk7XG4gICAgfVxuICB9KTtcbiAgcmVzdWx0LmFkZGVkLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcHJvdmlkZXJzLnNwbGljZShpbmRleCwgMCwgY3JlYXRlUHJvdmlkZXIoY2hpbGRyZW5baW5kZXhdLCBjaGlsZHJlbktleXNbaW5kZXhdLCBpbmRleCwgY29udGFpbmVyUHJvdmlkZXIpKTtcbiAgfSk7XG4gIHZhciBjaGFuZ2VkID0gcmVzdWx0Lm1haW50YWluZWQuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfID0gX2FbMF0sXG4gICAgICAgIHRvID0gX2FbMV07XG4gICAgdmFyIGVsID0gY2hpbGRyZW5bdG9dO1xuICAgIHZhciBjaGlsZFByb3ZpZGVyID0gcHJvdmlkZXJzW3RvXTtcbiAgICB2YXIgdHlwZSA9IGlzU3RyaW5nKGVsKSA/IFwidGV4dF9cIiArIGVsIDogZWwudHlwZTtcblxuICAgIGlmICh0eXBlICE9PSBjaGlsZFByb3ZpZGVyLnR5cGUpIHtcbiAgICAgIGNoaWxkUHJvdmlkZXIuX3VubW91bnQoKTtcblxuICAgICAgcHJvdmlkZXJzLnNwbGljZSh0bywgMSwgY3JlYXRlUHJvdmlkZXIoZWwsIGNoaWxkcmVuS2V5c1t0b10sIHRvLCBjb250YWluZXJQcm92aWRlcikpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY2hpbGRQcm92aWRlci5pbmRleCA9IHRvO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIHJldHVybiBfX3NwcmVhZEFycmF5cyhyZXN1bHQuYWRkZWQsIGNoYW5nZWQubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfID0gX2FbMF0sXG4gICAgICAgIHRvID0gX2FbMV07XG4gICAgcmV0dXJuIHRvO1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclByb3ZpZGVycyhjb250YWluZXJQcm92aWRlciwgcHJvdmlkZXJzLCBjaGlsZHJlbiwgdXBkYXRlZEhvb2tzLCBuZXh0U3RhdGUsIGlzRm9yY2VVcGRhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IGRpZmZQcm92aWRlcnMoY29udGFpbmVyUHJvdmlkZXIsIHByb3ZpZGVycywgY2hpbGRyZW4pO1xuICB2YXIgdXBkYXRlZCA9IHByb3ZpZGVycy5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkUHJvdmlkZXIsIGkpIHtcbiAgICByZXR1cm4gY2hpbGRQcm92aWRlci5fdXBkYXRlKHVwZGF0ZWRIb29rcywgY2hpbGRyZW5baV0sIG5leHRTdGF0ZSwgaXNGb3JjZVVwZGF0ZSk7XG4gIH0pO1xuICB2YXIgY29udGFpbmVyTm9kZSA9IGZpbmRDb250YWluZXJOb2RlKGNvbnRhaW5lclByb3ZpZGVyKTtcblxuICBpZiAoY29udGFpbmVyTm9kZSkge1xuICAgIHJlc3VsdC5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHZhciBjaGlsZFByb3ZpZGVyID0gcHJvdmlkZXJzW2luZGV4XTtcbiAgICAgIHZhciBlbCA9IGZpbmRET01Ob2RlKGNoaWxkUHJvdmlkZXIuYmFzZSk7XG5cbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGFpbmVyTm9kZSAhPT0gZWwgJiYgIWVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdmFyIG5leHRFbGVtZW50ID0gZ2V0TmV4dFNpYmlsaW5nKGNvbnRhaW5lclByb3ZpZGVyLCBjaGlsZFByb3ZpZGVyKTtcbiAgICAgICAgY29udGFpbmVyTm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5leHRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVkLmxlbmd0aCA+IDA7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclByb3ZpZGVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcHJvdmlkZXIpIHtcbiAgaWYgKHByb3ZpZGVyID09PSB2b2lkIDApIHtcbiAgICBwcm92aWRlciA9IGNvbnRhaW5lci5fX1JFQUNUX0NPTVBBVF9fO1xuICB9XG5cbiAgdmFyIGlzUHJvdmlkZXIgPSAhIXByb3ZpZGVyO1xuXG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICBwcm92aWRlciA9IG5ldyBDb250YWluZXJQcm92aWRlcihjb250YWluZXIpO1xuICB9XG5cbiAgdXBkYXRlUHJvdmlkZXIocHJvdmlkZXIsIGVsZW1lbnQgPyBbZWxlbWVudF0gOiBbXSk7XG5cbiAgaWYgKCFpc1Byb3ZpZGVyKSB7XG4gICAgY29udGFpbmVyLl9fUkVBQ1RfQ09NUEFUX18gPSBwcm92aWRlcjtcbiAgfVxuXG4gIHJldHVybiBwcm92aWRlcjtcbn1cblxuZnVuY3Rpb24gcmVuZGVyKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgdmFyIHByb3ZpZGVyID0gY29udGFpbmVyLl9fUkVBQ1RfQ09NUEFUX187XG5cbiAgaWYgKGVsZW1lbnQgJiYgIXByb3ZpZGVyKSB7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gIH1cblxuICByZW5kZXJQcm92aWRlcihlbGVtZW50LCBjb250YWluZXIsIHByb3ZpZGVyKTtcbiAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChlbCwgY29udGFpbmVyKSB7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KF9Qb3J0YWwsIHtcbiAgICBlbGVtZW50OiBlbCxcbiAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICB9KTtcbn1cbnZhciB2ZXJzaW9uID0gXCJzaW1wbGUtMS4xLjBcIjtcblxuZXhwb3J0IHsgQ29tcG9uZW50LCBQdXJlQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBjcmVhdGVQb3J0YWwsIGZpbmRET01Ob2RlLCByZW5kZXIsIHZlcnNpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhdC5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDIwIERheWJydXNoXG5uYW1lOiBzZWxlY3RvXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvc2VsZWN0by5naXRcbnZlcnNpb246IDEuMTYuMlxuKi9cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnQHNjZW5hL2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IEdlc3RvIGZyb20gJ2dlc3RvJztcbmltcG9ydCB7IFByb3BlcnRpZXMgfSBmcm9tICdmcmFtZXdvcmstdXRpbHMnO1xuaW1wb3J0IHsgaGFzQ2xhc3MsIGFkZENsYXNzLCBjYWxjdWxhdGVCb3VuZFNpemUsIGlzT2JqZWN0LCBpc1N0cmluZywgcmVtb3ZlRXZlbnQsIGFkZEV2ZW50LCBzcGxpdFVuaXQsIGJldHdlZW4sIGlzQXJyYXksIGNhbWVsaXplIH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcbmltcG9ydCB7IGRpZmYgfSBmcm9tICdAZWdqcy9jaGlsZHJlbi1kaWZmZXInO1xuaW1wb3J0IERyYWdTY3JvbGwgZnJvbSAnQHNjZW5hL2RyYWdzY3JvbGwnO1xuaW1wb3J0IEtleUNvbnRyb2xsZXIsIHsgZ2V0Q29tYmkgfSBmcm9tICdrZXljb24nO1xuaW1wb3J0IHsgZml0UG9pbnRzLCBpc0luc2lkZSwgZ2V0T3ZlcmxhcFBvaW50cywgZ2V0QXJlYVNpemUgfSBmcm9tICdvdmVybGFwLWFyZWEnO1xuaW1wb3J0IHsgY3JlYXRlTWF0cml4LCBnZXREaXN0RWxlbWVudE1hdHJpeCwgY2FsY3VsYXRlTWF0cml4RGlzdCB9IGZyb20gJ2Nzcy10by1tYXQnO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdjc3Mtc3R5bGVkJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG5cbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuXG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLFxuICAgICAgZDtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKykgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspIHJba10gPSBhW2pdO1xuXG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnQoZSkge1xuICBpZiAoXCJ0b3VjaGVzXCIgaW4gZSkge1xuICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXSB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogdG91Y2guY2xpZW50WVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGUuY2xpZW50WVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoanN4LCBwcmV2VGFyZ2V0LCBjb250YWluZXIpIHtcbiAgdmFyIHRhZyA9IGpzeC50YWcsXG4gICAgICBjaGlsZHJlbiA9IGpzeC5jaGlsZHJlbixcbiAgICAgIGF0dHJpYnV0ZXMgPSBqc3guYXR0cmlidXRlcyxcbiAgICAgIGNsYXNzTmFtZSA9IGpzeC5jbGFzc05hbWUsXG4gICAgICBzdHlsZSA9IGpzeC5zdHlsZTtcbiAgdmFyIGVsID0gcHJldlRhcmdldCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZXNbbmFtZV0pO1xuICB9XG5cbiAgdmFyIGVsQ2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICBjcmVhdGVFbGVtZW50KGNoaWxkLCBlbENoaWxkcmVuW2ldLCBlbCk7XG4gIH0pO1xuXG4gIGlmIChjbGFzc05hbWUpIHtcbiAgICBjbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmICghaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XG4gICAgICAgIGFkZENsYXNzKGVsLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzdHlsZSkge1xuICAgIHZhciBlbFN0eWxlID0gZWwuc3R5bGU7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlKSB7XG4gICAgICBlbFN0eWxlW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwcmV2VGFyZ2V0ICYmIGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBoKHRhZywgYXR0cnMpIHtcbiAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBjaGlsZHJlbltfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciBfYSA9IGF0dHJzIHx8IHt9LFxuICAgICAgX2IgPSBfYS5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfYiA9PT0gdm9pZCAwID8gXCJcIiA6IF9iLFxuICAgICAgX2MgPSBfYS5zdHlsZSxcbiAgICAgIHN0eWxlID0gX2MgPT09IHZvaWQgMCA/IHt9IDogX2MsXG4gICAgICBhdHRyaWJ1dGVzID0gX19yZXN0KF9hLCBbXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiXSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0YWc6IHRhZyxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZWYWx1ZShwcmV2LCBjdXIsIGZ1bmMpIHtcbiAgaWYgKHByZXYgIT09IGN1cikge1xuICAgIGZ1bmMocHJldiwgY3VyKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVjdChlLCByYXRpbywgYm91bmRBcmVhKSB7XG4gIHZhciBfYTtcblxuICBpZiAoYm91bmRBcmVhID09PSB2b2lkIDApIHtcbiAgICBib3VuZEFyZWEgPSBlLmRhdGFzLmJvdW5kQXJlYTtcbiAgfVxuXG4gIHZhciBfYiA9IGUuZGlzdFgsXG4gICAgICBkaXN0WCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsXG4gICAgICBfYyA9IGUuZGlzdFksXG4gICAgICBkaXN0WSA9IF9jID09PSB2b2lkIDAgPyAwIDogX2M7XG4gIHZhciBfZCA9IGUuZGF0YXMsXG4gICAgICBzdGFydFggPSBfZC5zdGFydFgsXG4gICAgICBzdGFydFkgPSBfZC5zdGFydFk7XG5cbiAgaWYgKHJhdGlvID4gMCkge1xuICAgIHZhciBuZXh0SGVpZ2h0ID0gTWF0aC5zcXJ0KChkaXN0WCAqIGRpc3RYICsgZGlzdFkgKiBkaXN0WSkgLyAoMSArIHJhdGlvICogcmF0aW8pKTtcbiAgICB2YXIgbmV4dFdpZHRoID0gcmF0aW8gKiBuZXh0SGVpZ2h0O1xuICAgIGRpc3RYID0gKGRpc3RYID49IDAgPyAxIDogLTEpICogbmV4dFdpZHRoO1xuICAgIGRpc3RZID0gKGRpc3RZID49IDAgPyAxIDogLTEpICogbmV4dEhlaWdodDtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IE1hdGguYWJzKGRpc3RYKTtcbiAgdmFyIGhlaWdodCA9IE1hdGguYWJzKGRpc3RZKTtcbiAgdmFyIG1heFdpZHRoID0gZGlzdFggPCAwID8gc3RhcnRYIC0gYm91bmRBcmVhLmxlZnQgOiBib3VuZEFyZWEucmlnaHQgLSBzdGFydFg7XG4gIHZhciBtYXhIZWlnaHQgPSBkaXN0WSA8IDAgPyBzdGFydFkgLSBib3VuZEFyZWEudG9wIDogYm91bmRBcmVhLmJvdHRvbSAtIHN0YXJ0WTtcbiAgX2EgPSBjYWxjdWxhdGVCb3VuZFNpemUoW3dpZHRoLCBoZWlnaHRdLCBbMCwgMF0sIFttYXhXaWR0aCwgbWF4SGVpZ2h0XSwgISFyYXRpbyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICBkaXN0WCA9IChkaXN0WCA+PSAwID8gMSA6IC0xKSAqIHdpZHRoO1xuICBkaXN0WSA9IChkaXN0WSA+PSAwID8gMSA6IC0xKSAqIGhlaWdodDtcbiAgdmFyIHR4ID0gTWF0aC5taW4oMCwgZGlzdFgpO1xuICB2YXIgdHkgPSBNYXRoLm1pbigwLCBkaXN0WSk7XG4gIHZhciBsZWZ0ID0gc3RhcnRYICsgdHg7XG4gIHZhciB0b3AgPSBzdGFydFkgKyB0eTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHRvcDogdG9wLFxuICAgIHJpZ2h0OiBsZWZ0ICsgd2lkdGgsXG4gICAgYm90dG9tOiB0b3AgKyBoZWlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0RWxlbWVudFJlY3QoZWwpIHtcbiAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGxlZnQgPSByZWN0LmxlZnQsXG4gICAgICB0b3AgPSByZWN0LnRvcCxcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCxcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICByZXR1cm4ge1xuICAgIHBvczE6IFtsZWZ0LCB0b3BdLFxuICAgIHBvczI6IFtsZWZ0ICsgd2lkdGgsIHRvcF0sXG4gICAgcG9zMzogW2xlZnQsIHRvcCArIGhlaWdodF0sXG4gICAgcG9zNDogW2xlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0XVxuICB9O1xufVxuZnVuY3Rpb24gcGFzc1RhcmdldHMoYmVmb3JlVGFyZ2V0cywgYWZ0ZXJUYXJnZXRzLCBjb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCkge1xuICB2YXIgX2EgPSBkaWZmKGJlZm9yZVRhcmdldHMsIGFmdGVyVGFyZ2V0cyksXG4gICAgICBsaXN0ID0gX2EubGlzdCxcbiAgICAgIHByZXZMaXN0ID0gX2EucHJldkxpc3QsXG4gICAgICBhZGRlZCA9IF9hLmFkZGVkLFxuICAgICAgcmVtb3ZlZCA9IF9hLnJlbW92ZWQsXG4gICAgICBtYWludGFpbmVkID0gX2EubWFpbnRhaW5lZDtcblxuICByZXR1cm4gX19zcHJlYWRBcnJheXMoYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBsaXN0W2luZGV4XTtcbiAgfSksIHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBwcmV2TGlzdFtpbmRleF07XG4gIH0pLCBjb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCA/IG1haW50YWluZWQubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBuZXh0SW5kZXggPSBfYVsxXTtcbiAgICByZXR1cm4gbGlzdFtuZXh0SW5kZXhdO1xuICB9KSA6IFtdKTtcbn1cblxudmFyIGluamVjdG9yID0gc3R5bGVkKFwiXFxuOmhvc3Qge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICM0YWY7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoNjgsIDE3MCwgMjU1LCAwLjUpO1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG4gICAgei1pbmRleDogMTAwO1xcbn1cXG5cIik7XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cblxudmFyIENMQVNTX05BTUUgPSBcInNlbGVjdG8tc2VsZWN0aW9uIFwiICsgaW5qZWN0b3IuY2xhc3NOYW1lO1xudmFyIFBST1BFUlRJRVMgPSBbXCJib3VuZENvbnRhaW5lclwiLCBcInNlbGVjdGFibGVUYXJnZXRzXCIsIFwic2VsZWN0QnlDbGlja1wiLCBcInNlbGVjdEZyb21JbnNpZGVcIiwgXCJjb250aW51ZVNlbGVjdFwiLCBcInRvZ2dsZUNvbnRpbnVlU2VsZWN0XCIsIFwia2V5Q29udGFpbmVyXCIsIFwiaGl0UmF0ZVwiLCBcInNjcm9sbE9wdGlvbnNcIiwgXCJjaGVja0lucHV0XCIsIFwicHJldmVudERlZmF1bHRcIiwgXCJyYXRpb1wiLCBcImdldEVsZW1lbnRSZWN0XCIsIFwicHJldmVudERyYWdGcm9tSW5zaWRlXCIsIFwicm9vdENvbnRhaW5lclwiLCBcImRyYWdDb25kaXRpb25cIiwgXCJjbGlja0J5U2VsZWN0RW5kXCJdO1xuLyoqXG4gKiBAbWVtYmVyb2YgU2VsZWN0b1xuICovXG5cbnZhciBPUFRJT05TID0gX19zcHJlYWRBcnJheXMoWy8vIGlnbm9yZSB0YXJnZXQsIGNvbnRhaW5lcixcblwiZHJhZ0NvbnRhaW5lclwiLCBcImNzcE5vbmNlXCIsIFwiY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3RcIl0sIFBST1BFUlRJRVMpO1xudmFyIE9QVElPTl9UWVBFUyA9IHtcbiAgYm91bmRDb250YWluZXI6IG51bGwsXG4gIHBvcnRhbENvbnRhaW5lcjogbnVsbCxcbiAgY29udGFpbmVyOiBudWxsLFxuICBkcmFnQ29udGFpbmVyOiBudWxsLFxuICBzZWxlY3RhYmxlVGFyZ2V0czogQXJyYXksXG4gIHNlbGVjdEJ5Q2xpY2s6IEJvb2xlYW4sXG4gIHNlbGVjdEZyb21JbnNpZGU6IEJvb2xlYW4sXG4gIGNvbnRpbnVlU2VsZWN0OiBCb29sZWFuLFxuICB0b2dnbGVDb250aW51ZVNlbGVjdDogQXJyYXksXG4gIGtleUNvbnRhaW5lcjogbnVsbCxcbiAgaGl0UmF0ZTogTnVtYmVyLFxuICBzY3JvbGxPcHRpb25zOiBPYmplY3QsXG4gIGNoZWNrSW5wdXQ6IEJvb2xlYW4sXG4gIHByZXZlbnREZWZhdWx0OiBCb29sZWFuLFxuICBjc3BOb25jZTogU3RyaW5nLFxuICByYXRpbzogTnVtYmVyLFxuICBnZXRFbGVtZW50UmVjdDogRnVuY3Rpb24sXG4gIHByZXZlbnREcmFnRnJvbUluc2lkZTogQm9vbGVhbixcbiAgcm9vdENvbnRhaW5lcjogT2JqZWN0LFxuICBkcmFnQ29uZGl0aW9uOiBGdW5jdGlvbixcbiAgY2xpY2tCeVNlbGVjdEVuZDogQm9vbGVhbixcbiAgY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Q6IEJvb2xlYW5cbn07XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cblxudmFyIEVWRU5UUyA9IFtcImRyYWdTdGFydFwiLCBcImRyYWdcIiwgXCJkcmFnRW5kXCIsIFwic2VsZWN0U3RhcnRcIiwgXCJzZWxlY3RcIiwgXCJzZWxlY3RFbmRcIiwgXCJrZXlkb3duXCIsIFwia2V5dXBcIiwgXCJzY3JvbGxcIl07XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cblxudmFyIE1FVEhPRFMgPSBbXCJjbGlja1RhcmdldFwiLCBcImdldFNlbGVjdGFibGVFbGVtZW50c1wiLCBcInNldFNlbGVjdGVkVGFyZ2V0c1wiLCBcImdldEVsZW1lbnRQb2ludHNcIiwgXCJnZXRTZWxlY3RlZFRhcmdldHNcIiwgXCJmaW5kU2VsZWN0YWJsZVRhcmdldHNcIiwgXCJ0cmlnZ2VyRHJhZ1N0YXJ0XCIsIFwiY2hlY2tTY3JvbGxcIl07XG5cbi8qKlxuICogU2VsZWN0by5qcyBpcyBhIGNvbXBvbmVudCB0aGF0IGFsbG93cyB5b3UgdG8gc2VsZWN0IGVsZW1lbnRzIGluIHRoZSBkcmFnIGFyZWEgdXNpbmcgdGhlIG1vdXNlIG9yIHRvdWNoLlxuICogQHNvcnQgMVxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cblxudmFyIFNlbGVjdG8gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2VsZWN0bywgX3N1cGVyKTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gU2VsZWN0byhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5zZWxlY3RlZFRhcmdldHMgPSBbXTtcbiAgICBfdGhpcy5kcmFnU2Nyb2xsID0gbmV3IERyYWdTY3JvbGwoKTtcblxuICAgIF90aGlzLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCBjbGlja2VkVGFyZ2V0KSB7XG4gICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICAgIGNsaWVudFggPSBlLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IGUuY2xpZW50WSxcbiAgICAgICAgICBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50O1xuICAgICAgdmFyIF9hID0gX3RoaXMub3B0aW9ucyxcbiAgICAgICAgICBjb250aW51ZVNlbGVjdCA9IF9hLmNvbnRpbnVlU2VsZWN0LFxuICAgICAgICAgIGNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0ID0gX2EuY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QsXG4gICAgICAgICAgc2VsZWN0RnJvbUluc2lkZSA9IF9hLnNlbGVjdEZyb21JbnNpZGUsXG4gICAgICAgICAgc2VsZWN0QnlDbGljayA9IF9hLnNlbGVjdEJ5Q2xpY2ssXG4gICAgICAgICAgcm9vdENvbnRhaW5lciA9IF9hLnJvb3RDb250YWluZXIsXG4gICAgICAgICAgYm91bmRDb250YWluZXIgPSBfYS5ib3VuZENvbnRhaW5lcixcbiAgICAgICAgICBfYiA9IF9hLnByZXZlbnREcmFnRnJvbUluc2lkZSxcbiAgICAgICAgICBwcmV2ZW50RHJhZ0Zyb21JbnNpZGUgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLFxuICAgICAgICAgIGNsaWNrQnlTZWxlY3RFbmQgPSBfYS5jbGlja0J5U2VsZWN0RW5kLFxuICAgICAgICAgIGRyYWdDb25kaXRpb24gPSBfYS5kcmFnQ29uZGl0aW9uO1xuXG4gICAgICBpZiAoZHJhZ0NvbmRpdGlvbiAmJiAhZHJhZ0NvbmRpdGlvbihlKSkge1xuICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5maW5kU2VsZWN0YWJsZVRhcmdldHMoZGF0YXMpO1xuXG4gICAgICBkYXRhcy5zdGFydFNlbGVjdGVkVGFyZ2V0cyA9IF90aGlzLnNlbGVjdGVkVGFyZ2V0cztcbiAgICAgIGRhdGFzLnNjYWxlTWF0cml4ID0gY3JlYXRlTWF0cml4KCk7XG4gICAgICBkYXRhcy5jb250YWluZXJYID0gMDtcbiAgICAgIGRhdGFzLmNvbnRhaW5lclkgPSAwO1xuICAgICAgdmFyIGJvdW5kQXJlYSA9IHtcbiAgICAgICAgbGVmdDogLUluZmluaXR5LFxuICAgICAgICB0b3A6IC1JbmZpbml0eSxcbiAgICAgICAgcmlnaHQ6IEluZmluaXR5LFxuICAgICAgICBib3R0b206IEluZmluaXR5XG4gICAgICB9O1xuXG4gICAgICBpZiAocm9vdENvbnRhaW5lcikge1xuICAgICAgICB2YXIgY29udGFpbmVyUmVjdCA9IF90aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBkYXRhcy5jb250YWluZXJYID0gY29udGFpbmVyUmVjdC5sZWZ0O1xuICAgICAgICBkYXRhcy5jb250YWluZXJZID0gY29udGFpbmVyUmVjdC50b3A7XG4gICAgICAgIGRhdGFzLnNjYWxlTWF0cml4ID0gZ2V0RGlzdEVsZW1lbnRNYXRyaXgoX3RoaXMuY29udGFpbmVyLCByb290Q29udGFpbmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kQ29udGFpbmVyKSB7XG4gICAgICAgIHZhciBib3VuZEluZm8gPSBpc09iamVjdChib3VuZENvbnRhaW5lcikgJiYgXCJlbGVtZW50XCIgaW4gYm91bmRDb250YWluZXIgPyBfX2Fzc2lnbih7XG4gICAgICAgICAgbGVmdDogdHJ1ZSxcbiAgICAgICAgICB0b3A6IHRydWUsXG4gICAgICAgICAgYm90dG9tOiB0cnVlLFxuICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgIH0sIGJvdW5kQ29udGFpbmVyKSA6IHtcbiAgICAgICAgICBlbGVtZW50OiBib3VuZENvbnRhaW5lcixcbiAgICAgICAgICBsZWZ0OiB0cnVlLFxuICAgICAgICAgIHRvcDogdHJ1ZSxcbiAgICAgICAgICBib3R0b206IHRydWUsXG4gICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJvdW5kRWxlbWVudCA9IGJvdW5kSW5mby5lbGVtZW50O1xuICAgICAgICB2YXIgcmVjdEVsZW1lbnQgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGJvdW5kRWxlbWVudCkge1xuICAgICAgICAgIGlmIChpc1N0cmluZyhib3VuZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZWN0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYm91bmRFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJvdW5kRWxlbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVjdEVsZW1lbnQgPSBfdGhpcy5jb250YWluZXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY3RFbGVtZW50ID0gYm91bmRFbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWN0ID0gcmVjdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICBpZiAoYm91bmRJbmZvLmxlZnQpIHtcbiAgICAgICAgICAgIGJvdW5kQXJlYS5sZWZ0ID0gcmVjdC5sZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChib3VuZEluZm8udG9wKSB7XG4gICAgICAgICAgICBib3VuZEFyZWEudG9wID0gcmVjdC50b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJvdW5kSW5mby5yaWdodCkge1xuICAgICAgICAgICAgYm91bmRBcmVhLnJpZ2h0ID0gcmVjdC5yaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYm91bmRJbmZvLmJvdHRvbSkge1xuICAgICAgICAgICAgYm91bmRBcmVhLmJvdHRvbSA9IHJlY3QuYm90dG9tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkYXRhcy5ib3VuZEFyZWEgPSBib3VuZEFyZWE7XG4gICAgICB2YXIgaGl0UmVjdCA9IHtcbiAgICAgICAgbGVmdDogY2xpZW50WCxcbiAgICAgICAgdG9wOiBjbGllbnRZLFxuICAgICAgICByaWdodDogY2xpZW50WCxcbiAgICAgICAgYm90dG9tOiBjbGllbnRZLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9O1xuICAgICAgdmFyIGZpcnN0UGFzc2VkVGFyZ2V0cyA9IFtdO1xuXG4gICAgICBpZiAoIXNlbGVjdEZyb21JbnNpZGUgfHwgc2VsZWN0QnlDbGljayAmJiAhY2xpY2tCeVNlbGVjdEVuZCkge1xuICAgICAgICB2YXIgcG9pbnRUYXJnZXQgPSBfdGhpcy5fZmluZEVsZW1lbnQoY2xpY2tlZFRhcmdldCB8fCBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGNsaWVudFgsIGNsaWVudFkpLCBkYXRhcy5zZWxlY3RhYmxlVGFyZ2V0cyk7XG5cbiAgICAgICAgZmlyc3RQYXNzZWRUYXJnZXRzID0gcG9pbnRUYXJnZXQgPyBbcG9pbnRUYXJnZXRdIDogW107XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNJbnNpZGVUYXJnZXRzID0gZmlyc3RQYXNzZWRUYXJnZXRzLmxlbmd0aCA+IDA7XG4gICAgICB2YXIgaXNQcmV2ZW50U2VsZWN0ID0gIXNlbGVjdEZyb21JbnNpZGUgJiYgaGFzSW5zaWRlVGFyZ2V0czsgLy8gcHJldmVudCBkcmFnIGZyb20gaW5zaWRlIHdoZW4gc2VsZWN0QnlDbGljayBpcyBmYWxzZVxuXG4gICAgICBpZiAoaXNQcmV2ZW50U2VsZWN0ICYmICFzZWxlY3RCeUNsaWNrKSB7XG4gICAgICAgIGUuc3RvcCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gaW5wdXRFdmVudC50eXBlO1xuICAgICAgdmFyIGlzVHJ1c3RlZCA9IHR5cGUgPT09IFwibW91c2Vkb3duXCIgfHwgdHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCI7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdGhlIGRyYWcgc3RhcnRzICh0cmlnZ2VycyBvbiBtb3VzZWRvd24gb3IgdG91Y2hzdGFydCksIHRoZSBkcmFnU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxuICAgICAgICogQ2FsbCB0aGUgc3RvcCAoKSBmdW5jdGlvbiBpZiB5b3UgaGF2ZSBhIHNwZWNpZmljIGVsZW1lbnQgb3IgZG9uJ3Qgd2FudCB0byByYWlzZSBhIHNlbGVjdFxuICAgICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgICAqIEBldmVudCBkcmFnU3RhcnRcbiAgICAgICAqIEBwYXJhbSB7T25EcmFnU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGRyYWdTdGFydCBldmVudFxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICAgKlxuICAgICAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKHtcbiAgICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICogICBzZWxlY3RCeUNsaWNrOiB0cnVlLFxuICAgICAgICogICBzZWxlY3RGcm9tSW5zaWRlOiBmYWxzZSxcbiAgICAgICAqIH0pO1xuICAgICAgICpcbiAgICAgICAqIHNlbGVjdG8ub24oXCJkcmFnU3RhcnRcIiwgZSA9PiB7XG4gICAgICAgKiAgIGlmIChlLmlucHV0RXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09IFwiU1BBTlwiKSB7XG4gICAgICAgKiAgICAgZS5zdG9wKCk7XG4gICAgICAgKiAgIH1cbiAgICAgICAqIH0pLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogfSk7XG4gICAgICAgKi9cblxuICAgICAgdmFyIHJlc3VsdCA9ICFlLmlzQ2xpY2sgJiYgaXNUcnVzdGVkID8gX3RoaXMuZW1pdChcImRyYWdTdGFydFwiLCBfX2Fzc2lnbih7fSwgZSkpIDogdHJ1ZTtcblxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRpbnVlU2VsZWN0KSB7XG4gICAgICAgIGZpcnN0UGFzc2VkVGFyZ2V0cyA9IHBhc3NUYXJnZXRzKF90aGlzLnNlbGVjdGVkVGFyZ2V0cywgZmlyc3RQYXNzZWRUYXJnZXRzLCBjb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCk7XG4gICAgICAgIGRhdGFzLnN0YXJ0UGFzc2VkVGFyZ2V0cyA9IF90aGlzLnNlbGVjdGVkVGFyZ2V0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFzLnN0YXJ0UGFzc2VkVGFyZ2V0cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5fc2VsZWN0KF90aGlzLnNlbGVjdGVkVGFyZ2V0cywgZmlyc3RQYXNzZWRUYXJnZXRzLCBoaXRSZWN0LCBpbnB1dEV2ZW50LCB0cnVlKTtcblxuICAgICAgZGF0YXMuc3RhcnRYID0gY2xpZW50WDtcbiAgICAgIGRhdGFzLnN0YXJ0WSA9IGNsaWVudFk7XG4gICAgICBkYXRhcy5zZWxlY3RGbGFnID0gZmFsc2U7XG4gICAgICBkYXRhcy5wcmV2ZW50RHJhZ0Zyb21JbnNpZGUgPSBmYWxzZTtcbiAgICAgIHZhciBvZmZzZXRQb3MgPSBjYWxjdWxhdGVNYXRyaXhEaXN0KGRhdGFzLnNjYWxlTWF0cml4LCBbY2xpZW50WCAtIGRhdGFzLmNvbnRhaW5lclgsIGNsaWVudFkgLSBkYXRhcy5jb250YWluZXJZXSk7XG4gICAgICBkYXRhcy5ib3VuZHNBcmVhID0gX3RoaXMudGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gXCJwb3NpdGlvbjogXCIgKyAocm9vdENvbnRhaW5lciA/IFwiYWJzb2x1dGVcIiA6IFwiZml4ZWRcIikgKyBcIjtcIiArIFwibGVmdDowcHg7dG9wOjBweDtcIiArIChcInRyYW5zZm9ybTogdHJhbnNsYXRlKFwiICsgb2Zmc2V0UG9zWzBdICsgXCJweCwgXCIgKyBvZmZzZXRQb3NbMV0gKyBcInB4KVwiKTtcblxuICAgICAgaWYgKGlzUHJldmVudFNlbGVjdCAmJiBzZWxlY3RCeUNsaWNrICYmICFjbGlja0J5U2VsZWN0RW5kKSB7XG4gICAgICAgIGlucHV0RXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBkcmFnIGZyb20gaW5zaWRlIHdoZW4gc2VsZWN0QnlDbGljayBpcyB0cnVlIGFuZCBmb3JjZSBjYWxsIGBzZWxlY3RFbmRgXG5cbiAgICAgICAgaWYgKHByZXZlbnREcmFnRnJvbUluc2lkZSkge1xuICAgICAgICAgIF90aGlzLl9zZWxlY3RFbmQoZGF0YXMuc3RhcnRTZWxlY3RlZFRhcmdldHMsIGRhdGFzLnN0YXJ0UGFzc2VkVGFyZ2V0cywgaGl0UmVjdCwgZSk7XG5cbiAgICAgICAgICBkYXRhcy5wcmV2ZW50RHJhZ0Zyb21JbnNpZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhcy5zZWxlY3RGbGFnID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpIHtcbiAgICAgICAgICBpbnB1dEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Nyb2xsT3B0aW9ucyA9IF90aGlzLm9wdGlvbnMuc2Nyb2xsT3B0aW9ucztcblxuICAgICAgICBpZiAoc2Nyb2xsT3B0aW9ucyAmJiBzY3JvbGxPcHRpb25zLmNvbnRhaW5lcikge1xuICAgICAgICAgIF90aGlzLmRyYWdTY3JvbGwuZHJhZ1N0YXJ0KGUsIHNjcm9sbE9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsaWNrQnlTZWxlY3RFbmQpIHtcbiAgICAgICAgICBkYXRhcy5zZWxlY3RGbGFnID0gZmFsc2U7XG4gICAgICAgICAgZS5wcmV2ZW50RHJhZygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBfdGhpcy5fb25EcmFnID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBfYTtcblxuICAgICAgaWYgKGUuZGF0YXMuc2VsZWN0RmxhZykge1xuICAgICAgICB2YXIgc2Nyb2xsT3B0aW9ucyA9IF90aGlzLnNjcm9sbE9wdGlvbnM7IC8vIElmIGl0IGlzIGEgc2Nyb2xsaW5nIHBvc2l0aW9uLCBwYXNzIGRyYWdcblxuICAgICAgICBpZiAoKChfYSA9IHNjcm9sbE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWluZXIpICYmIF90aGlzLmRyYWdTY3JvbGwuZHJhZyhlLCBzY3JvbGxPcHRpb25zKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpcy5fY2hlY2tTZWxlY3RlZChlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICAgIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgICB2YXIgcmVjdCA9IGdldFJlY3QoZSwgX3RoaXMub3B0aW9ucy5yYXRpbyk7XG4gICAgICB2YXIgc2VsZWN0RmxhZyA9IGRhdGFzLnNlbGVjdEZsYWc7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdGhlIGRyYWcgZW5kcyAodHJpZ2dlcnMgb24gbW91c2V1cCBvciB0b3VjaGVuZCBhZnRlciBkcmFnKSwgdGhlIGRyYWdFbmQgZXZlbnQgaXMgY2FsbGVkLlxuICAgICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgICAqIEBldmVudCBkcmFnRW5kXG4gICAgICAgKiBAcGFyYW0ge09uRHJhZ0VuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZ0VuZCBldmVudFxuICAgICAgICovXG5cbiAgICAgIGlmIChpbnB1dEV2ZW50ICYmICFlLmlzQ2xpY2spIHtcbiAgICAgICAgX3RoaXMuZW1pdChcImRyYWdFbmRcIiwgX19hc3NpZ24oX19hc3NpZ24oe1xuICAgICAgICAgIGlzRG91YmxlOiAhIWUuaXNEb3VibGUsXG4gICAgICAgICAgaXNEcmFnOiBmYWxzZSxcbiAgICAgICAgICBpc1NlbGVjdDogc2VsZWN0RmxhZ1xuICAgICAgICB9LCBlKSwge1xuICAgICAgICAgIGlzQ2xpY2s6ICEhZS5pc0NsaWNrLFxuICAgICAgICAgIHJlY3Q6IHJlY3RcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy50YXJnZXQuc3R5bGUuY3NzVGV4dCArPSBcImRpc3BsYXk6IG5vbmU7XCI7XG5cbiAgICAgIGlmIChzZWxlY3RGbGFnKSB7XG4gICAgICAgIGRhdGFzLnNlbGVjdEZsYWcgPSBmYWxzZTtcblxuICAgICAgICBfdGhpcy5kcmFnU2Nyb2xsLmRyYWdFbmQoKTtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMuc2VsZWN0QnlDbGljayAmJiBfdGhpcy5jbGlja0J5U2VsZWN0RW5kKSB7XG4gICAgICAgIC8vIG9ubHkgY2xpY2tCeVNlbGVjdEVuZFxuICAgICAgICB2YXIgcG9pbnRUYXJnZXQgPSBfdGhpcy5fZmluZEVsZW1lbnQoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSksIGRhdGFzLnNlbGVjdGFibGVUYXJnZXRzKTtcblxuICAgICAgICBfdGhpcy5fc2VsZWN0KF90aGlzLnNlbGVjdGVkVGFyZ2V0cywgcG9pbnRUYXJnZXQgPyBbcG9pbnRUYXJnZXRdIDogW10sIHJlY3QsIGlucHV0RXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGFzLnByZXZlbnREcmFnRnJvbUluc2lkZSkge1xuICAgICAgICBfdGhpcy5fc2VsZWN0RW5kKGRhdGFzLnN0YXJ0U2VsZWN0ZWRUYXJnZXRzLCBkYXRhcy5zdGFydFBhc3NlZFRhcmdldHMsIHJlY3QsIGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5fb25LZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghX3RoaXMuX3NhbWVDb21iaUtleShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmNvbnRpbnVlU2VsZWN0ID0gdHJ1ZTtcbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB5b3Uga2V5ZG93biB0aGUga2V5IHlvdSBzcGVjaWZpZWQgaW4gdG9nZ2xlQ29udGludWVTZWxlY3QsIHRoZSBrZXlkb3duIGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICAgKiBAZXZlbnQga2V5ZG93blxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICAgKlxuICAgICAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKHtcbiAgICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICogICB0b2dnbGVDb250aW51ZVNlbGVjdDogXCJzaGlmdFwiO1xuICAgICAgICogICBrZXlDb250YWluZXI6IHdpbmRvdyxcbiAgICAgICAqIH0pO1xuICAgICAgICpcbiAgICAgICAqIHNlbGVjdG8ub24oXCJrZXlkb3duXCIsICgpID0+IHtcbiAgICAgICAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5idXR0b25cIikuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICogfSkub24oXCJrZXl1cFwiLCAoKSA9PiB7XG4gICAgICAgKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqIH0pLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogfSk7XG4gICAgICAgKi9cblxuICAgICAgX3RoaXMuZW1pdChcImtleWRvd25cIiwge30pO1xuICAgIH07XG5cbiAgICBfdGhpcy5fb25LZXlVcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIV90aGlzLl9zYW1lQ29tYmlLZXkoZSwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jb250aW51ZVNlbGVjdCA9IGZhbHNlO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHlvdSBrZXl1cCB0aGUga2V5IHlvdSBzcGVjaWZpZWQgaW4gdG9nZ2xlQ29udGludWVTZWxlY3QsIHRoZSBrZXl1cCBldmVudCBpcyBjYWxsZWQuXG4gICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAgICogQGV2ZW50IGtleXVwXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgICAqXG4gICAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICAgKiAgIHRvZ2dsZUNvbnRpbnVlU2VsZWN0OiBcInNoaWZ0XCI7XG4gICAgICAgKiAgIGtleUNvbnRhaW5lcjogd2luZG93LFxuICAgICAgICogfSk7XG4gICAgICAgKlxuICAgICAgICogc2VsZWN0by5vbihcImtleWRvd25cIiwgKCkgPT4ge1xuICAgICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmJ1dHRvblwiKS5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiB9KS5vbihcImtleXVwXCIsICgpID0+IHtcbiAgICAgICAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5idXR0b25cIikuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xuICAgICAgICogfSkub24oXCJzZWxlY3RcIiwgZSA9PiB7XG4gICAgICAgKiAgIGUuYWRkZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqICAgZS5yZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiB9KTtcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5lbWl0KFwia2V5dXBcIiwge30pO1xuICAgIH07XG5cbiAgICBfdGhpcy5fb25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnRvZ2dsZUNvbnRpbnVlU2VsZWN0ICYmIF90aGlzLmNvbnRpbnVlU2VsZWN0KSB7XG4gICAgICAgIF90aGlzLmNvbnRpbnVlU2VsZWN0ID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMuZW1pdChcImtleXVwXCIsIHt9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuX29uRG9jdW1lbnRTZWxlY3RTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIV90aGlzLmdlc3RvLmlzRmxhZygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRyYWdDb250YWluZXIgPSBfdGhpcy5kcmFnQ29udGFpbmVyO1xuXG4gICAgICBpZiAoZHJhZ0NvbnRhaW5lciA9PT0gd2luZG93KSB7XG4gICAgICAgIGRyYWdDb250YWluZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250YWluZXJzID0gZHJhZ0NvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQgPyBbZHJhZ0NvbnRhaW5lcl0gOiBbXS5zbGljZS5jYWxsKGRyYWdDb250YWluZXIpO1xuICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgY29udGFpbmVycy5zb21lKGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gdGFyZ2V0IHx8IGNvbnRhaW5lci5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMudGFyZ2V0ID0gb3B0aW9ucy5wb3J0YWxDb250YWluZXI7XG4gICAgX3RoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICBfdGhpcy5vcHRpb25zID0gX19hc3NpZ24oe1xuICAgICAgcG9ydGFsQ29udGFpbmVyOiBudWxsLFxuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgZHJhZ0NvbnRhaW5lcjogbnVsbCxcbiAgICAgIHNlbGVjdGFibGVUYXJnZXRzOiBbXSxcbiAgICAgIHNlbGVjdEJ5Q2xpY2s6IHRydWUsXG4gICAgICBzZWxlY3RGcm9tSW5zaWRlOiB0cnVlLFxuICAgICAgY2xpY2tCeVNlbGVjdEVuZDogZmFsc2UsXG4gICAgICBoaXRSYXRlOiAxMDAsXG4gICAgICBjb250aW51ZVNlbGVjdDogZmFsc2UsXG4gICAgICBjb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdDogZmFsc2UsXG4gICAgICB0b2dnbGVDb250aW51ZVNlbGVjdDogbnVsbCxcbiAgICAgIGtleUNvbnRhaW5lcjogbnVsbCxcbiAgICAgIHNjcm9sbE9wdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgIGNoZWNrSW5wdXQ6IGZhbHNlLFxuICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuICAgICAgYm91bmRDb250YWluZXI6IGZhbHNlLFxuICAgICAgcHJldmVudERyYWdGcm9tSW5zaWRlOiB0cnVlLFxuICAgICAgZHJhZ0NvbmRpdGlvbjogbnVsbCxcbiAgICAgIHJvb3RDb250YWluZXI6IG51bGwsXG4gICAgICBnZXRFbGVtZW50UmVjdDogZ2V0RGVmYXVsdEVsZW1lbnRSZWN0LFxuICAgICAgY3NwTm9uY2U6IFwiXCIsXG4gICAgICByYXRpbzogMFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgX3RoaXMuaW5pdEVsZW1lbnQoKTtcblxuICAgIF90aGlzLmluaXREcmFnU2Nyb2xsKCk7XG5cbiAgICBfdGhpcy5zZXRLZXlDb250cm9sbGVyKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFlvdSBjYW4gc2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFyZ2V0cy5cbiAgICpcbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IFNlbGVjdG8ucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uc2V0U2VsZWN0ZWRUYXJnZXRzID0gZnVuY3Rpb24gKHNlbGVjdGVkVGFyZ2V0cykge1xuICAgIHRoaXMuc2VsZWN0ZWRUYXJnZXRzID0gc2VsZWN0ZWRUYXJnZXRzO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogWW91IGNhbiBnZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0YXJnZXRzLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0U2VsZWN0ZWRUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkVGFyZ2V0cztcbiAgfTtcblxuICBfX3Byb3RvLnNldEtleUNvbnRhaW5lciA9IGZ1bmN0aW9uIChrZXlDb250YWluZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgZGlmZlZhbHVlKG9wdGlvbnMua2V5Q29udGFpbmVyLCBrZXlDb250YWluZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9wdGlvbnMua2V5Q29udGFpbmVyID0ga2V5Q29udGFpbmVyO1xuXG4gICAgICBfdGhpcy5zZXRLZXlDb250cm9sbGVyKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5zZXRUb2dnbGVDb250aW51ZVNlbGVjdCA9IGZ1bmN0aW9uICh0b2dnbGVDb250aW51ZVNlbGVjdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBkaWZmVmFsdWUob3B0aW9ucy50b2dnbGVDb250aW51ZVNlbGVjdCwgdG9nZ2xlQ29udGludWVTZWxlY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9wdGlvbnMudG9nZ2xlQ29udGludWVTZWxlY3QgPSB0b2dnbGVDb250aW51ZVNlbGVjdDtcblxuICAgICAgX3RoaXMuc2V0S2V5RXZlbnQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLnNldFByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5nZXN0by5vcHRpb25zLnByZXZlbnREZWZhdWx0ID0gdmFsdWU7XG4gIH07XG5cbiAgX19wcm90by5zZXRDaGVja0lucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5nZXN0by5vcHRpb25zLmNoZWNrSW5wdXQgPSB2YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIGBPbkRyYWdTdGFydGAgaXMgdHJpZ2dlcmVkIGJ5IGFuIGV4dGVybmFsIGV2ZW50LlxuICAgKiBAcGFyYW0gLSBleHRlcm5hbCBldmVudFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgU2VsZWN0byBmcm9tIFwic2VsZWN0b1wiO1xuICAgKlxuICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oKTtcbiAgICpcbiAgICogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZSA9PiB7XG4gICAqICAgc2VsZWN0by50cmlnZ2VyRHJhZ1N0YXJ0KGUpO1xuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXJEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHRoaXMuZ2VzdG8udHJpZ2dlckRyYWdTdGFydChlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIERlc3Ryb3kgZWxlbWVudHMsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuXG4gICAqL1xuXG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub2ZmKCk7XG4gICAgdGhpcy5rZXljb24gJiYgdGhpcy5rZXljb24uZGVzdHJveSgpO1xuICAgIHRoaXMuZ2VzdG8udW5zZXQoKTtcbiAgICB0aGlzLmluamVjdFJlc3VsdC5kZXN0cm95KCk7XG4gICAgcmVtb3ZlRXZlbnQoZG9jdW1lbnQsIFwic2VsZWN0c3RhcnRcIiwgdGhpcy5fb25Eb2N1bWVudFNlbGVjdFN0YXJ0KTtcbiAgICB0aGlzLmtleWNvbiA9IG51bGw7XG4gICAgdGhpcy5nZXN0byA9IG51bGw7XG4gICAgdGhpcy5pbmplY3RSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgfTtcblxuICBfX3Byb3RvLmdldEVsZW1lbnRQb2ludHMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIGdldEVsZW1lbnRSZWN0ID0gdGhpcy5nZXRFbGVtZW50UmVjdCB8fCBnZXREZWZhdWx0RWxlbWVudFJlY3Q7XG4gICAgdmFyIGluZm8gPSBnZXRFbGVtZW50UmVjdCh0YXJnZXQpO1xuICAgIHZhciBwb2ludHMgPSBbaW5mby5wb3MxLCBpbmZvLnBvczIsIGluZm8ucG9zNCwgaW5mby5wb3MzXTtcblxuICAgIGlmIChnZXRFbGVtZW50UmVjdCAhPT0gZ2V0RGVmYXVsdEVsZW1lbnRSZWN0KSB7XG4gICAgICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiBmaXRQb2ludHMocG9pbnRzLCByZWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9O1xuICAvKipcbiAgICogR2V0IGFsbCBlbGVtZW50cyBzZXQgaW4gYHNlbGVjdGFibGVUYXJnZXRzYC5cbiAgICovXG5cblxuICBfX3Byb3RvLmdldFNlbGVjdGFibGVFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZWN0YWJsZUVsZW1lbnRzID0gW107XG4gICAgdGhpcy5vcHRpb25zLnNlbGVjdGFibGVUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgc2VsZWN0YWJsZUVsZW1lbnRzLnB1c2godGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpKTtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBzZWxlY3RhYmxlRWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxlY3RhYmxlRWxlbWVudHM7XG4gIH07XG4gIC8qKlxuICAgKiBJZiBzY3JvbGwgb2NjdXJzIGR1cmluZyBkcmFnZ2luZywgeW91IGNhbiBtYW51YWxseSBjYWxsIHRoaXMgbWV0aG9kIHRvIGNoZWNrIHRoZSBwb3NpdGlvbiBhZ2Fpbi5cbiAgICovXG5cblxuICBfX3Byb3RvLmNoZWNrU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcblxuICAgIGlmICghdGhpcy5nZXN0by5pc0ZsYWcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxPcHRpb25zID0gdGhpcy5zY3JvbGxPcHRpb25zOyAvLyBJZiBpdCBpcyBhIHNjcm9sbGluZyBwb3NpdGlvbiwgcGFzcyBkcmFnXG5cbiAgICAoKF9hID0gc2Nyb2xsT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5lcikgJiYgdGhpcy5kcmFnU2Nyb2xsLmNoZWNrU2Nyb2xsKF9fYXNzaWduKHtcbiAgICAgIGlucHV0RXZlbnQ6IHRoaXMuZ2VzdG8uZ2V0Q3VycmVudEV2ZW50KClcbiAgICB9LCBzY3JvbGxPcHRpb25zKSk7XG4gIH07XG4gIC8qKlxuICAgKiBGaW5kIGZvciBzZWxlY3RhYmxlVGFyZ2V0cyBhZ2FpbiBkdXJpbmcgZHJhZyBldmVudFxuICAgKi9cblxuXG4gIF9fcHJvdG8uZmluZFNlbGVjdGFibGVUYXJnZXRzID0gZnVuY3Rpb24gKGRhdGFzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChkYXRhcyA9PT0gdm9pZCAwKSB7XG4gICAgICBkYXRhcyA9IHRoaXMuZ2VzdG8uZ2V0RXZlbnREYXRhcygpO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3RhYmxlVGFyZ2V0cyA9IHRoaXMuZ2V0U2VsZWN0YWJsZUVsZW1lbnRzKCk7XG4gICAgdmFyIHNlbGVjdGFibGVQb2ludHMgPSBzZWxlY3RhYmxlVGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgcmV0dXJuIF90aGlzLmdldEVsZW1lbnRQb2ludHModGFyZ2V0KTtcbiAgICB9KTtcbiAgICBkYXRhcy5zZWxlY3RhYmxlVGFyZ2V0cyA9IHNlbGVjdGFibGVUYXJnZXRzO1xuICAgIGRhdGFzLnNlbGVjdGFibGVQb2ludHMgPSBzZWxlY3RhYmxlUG9pbnRzO1xuICB9O1xuICAvKipcbiAgICogRXh0ZXJuYWwgY2xpY2sgb3IgbW91c2UgZXZlbnRzIGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBzZWxlY3RvLlxuICAgKiBAcGFyYW1zIC0gRXh0ZW5hbCBjbGljayBvciBtb3VzZSBldmVudFxuICAgKiBAcGFyYW1zIC0gU3BlY2lmeSB0aGUgY2xpY2tlZCB0YXJnZXQgZGlyZWN0bHkuXG4gICAqL1xuXG5cbiAgX19wcm90by5jbGlja1RhcmdldCA9IGZ1bmN0aW9uIChlLCBjbGlja2VkVGFyZ2V0KSB7XG4gICAgdmFyIF9hID0gZ2V0Q2xpZW50KGUpLFxuICAgICAgICBjbGllbnRYID0gX2EuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WSA9IF9hLmNsaWVudFk7XG5cbiAgICB2YXIgZHJhZ0V2ZW50ID0ge1xuICAgICAgZGF0YXM6IHtcbiAgICAgICAgc2VsZWN0RmxhZzogZmFsc2VcbiAgICAgIH0sXG4gICAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgICAgY2xpZW50WTogY2xpZW50WSxcbiAgICAgIGlucHV0RXZlbnQ6IGUsXG4gICAgICBpc0NsaWNrOiB0cnVlLFxuICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9vbkRyYWdTdGFydChkcmFnRXZlbnQsIGNsaWNrZWRUYXJnZXQpKSB7XG4gICAgICB0aGlzLl9vbkRyYWdFbmQoZHJhZ0V2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfX3Byb3RvLnNldEtleUNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBrZXlDb250YWluZXIgPSBfYS5rZXlDb250YWluZXIsXG4gICAgICAgIHRvZ2dsZUNvbnRpbnVlU2VsZWN0ID0gX2EudG9nZ2xlQ29udGludWVTZWxlY3Q7XG5cbiAgICBpZiAodGhpcy5rZXljb24pIHtcbiAgICAgIHRoaXMua2V5Y29uLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMua2V5Y29uID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodG9nZ2xlQ29udGludWVTZWxlY3QpIHtcbiAgICAgIHRoaXMua2V5Y29uID0gbmV3IEtleUNvbnRyb2xsZXIoa2V5Q29udGFpbmVyIHx8IHdpbmRvdyk7XG4gICAgICB0aGlzLmtleWNvbi5rZXlkb3duKHRoaXMuX29uS2V5RG93bikua2V5dXAodGhpcy5fb25LZXlVcCkub24oXCJibHVyXCIsIHRoaXMuX29uQmx1cik7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uc2V0S2V5RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRvZ2dsZUNvbnRpbnVlU2VsZWN0ID0gdGhpcy5vcHRpb25zLnRvZ2dsZUNvbnRpbnVlU2VsZWN0O1xuXG4gICAgaWYgKCF0b2dnbGVDb250aW51ZVNlbGVjdCB8fCB0aGlzLmtleWNvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0S2V5Q29udHJvbGxlcigpO1xuICB9O1xuXG4gIF9fcHJvdG8uaW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50YXJnZXQgPSBjcmVhdGVFbGVtZW50KGgoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBDTEFTU19OQU1FXG4gICAgfSksIHRoaXMudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcik7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZHJhZ0NvbnRhaW5lciA9IF9hLmRyYWdDb250YWluZXIsXG4gICAgICAgIGNoZWNrSW5wdXQgPSBfYS5jaGVja0lucHV0LFxuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IF9hLnByZXZlbnREZWZhdWx0O1xuICAgIHRoaXMuZHJhZ0NvbnRhaW5lciA9IHR5cGVvZiBkcmFnQ29udGFpbmVyID09PSBcInN0cmluZ1wiID8gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGRyYWdDb250YWluZXIpKSA6IGRyYWdDb250YWluZXIgfHwgdGhpcy50YXJnZXQucGFyZW50Tm9kZTtcbiAgICB0aGlzLmdlc3RvID0gbmV3IEdlc3RvKHRoaXMuZHJhZ0NvbnRhaW5lciwge1xuICAgICAgY2hlY2tXaW5kb3dCbHVyOiB0cnVlLFxuICAgICAgY29udGFpbmVyOiB3aW5kb3csXG4gICAgICBjaGVja0lucHV0OiBjaGVja0lucHV0LFxuICAgICAgcHJldmVudERlZmF1bHQ6IHByZXZlbnREZWZhdWx0XG4gICAgfSkub24oe1xuICAgICAgZHJhZ1N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZFxuICAgIH0pO1xuICAgIGFkZEV2ZW50KGRvY3VtZW50LCBcInNlbGVjdHN0YXJ0XCIsIHRoaXMuX29uRG9jdW1lbnRTZWxlY3RTdGFydCk7XG4gICAgdGhpcy5pbmplY3RSZXN1bHQgPSBpbmplY3Rvci5pbmplY3QodGFyZ2V0LCB7XG4gICAgICBub25jZTogdGhpcy5vcHRpb25zLmNzcE5vbmNlXG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5oaXRUZXN0ID0gZnVuY3Rpb24gKHNlbGVjdFJlY3QsIGNsaWVudFgsIGNsaWVudFksIHRhcmdldHMsIHNlbGVjdGFibGVQb2ludHMpIHtcbiAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGhpdFJhdGUgPSBfYS5oaXRSYXRlLFxuICAgICAgICBzZWxlY3RCeUNsaWNrID0gX2Euc2VsZWN0QnlDbGljaztcbiAgICB2YXIgbGVmdCA9IHNlbGVjdFJlY3QubGVmdCxcbiAgICAgICAgdG9wID0gc2VsZWN0UmVjdC50b3AsXG4gICAgICAgIHJpZ2h0ID0gc2VsZWN0UmVjdC5yaWdodCxcbiAgICAgICAgYm90dG9tID0gc2VsZWN0UmVjdC5ib3R0b207XG4gICAgdmFyIHJlY3RQb2ludHMgPSBbW2xlZnQsIHRvcF0sIFtyaWdodCwgdG9wXSwgW3JpZ2h0LCBib3R0b21dLCBbbGVmdCwgYm90dG9tXV07XG4gICAgcmV0dXJuIHRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICB2YXIgcG9pbnRzID0gc2VsZWN0YWJsZVBvaW50c1tpXTtcbiAgICAgIHZhciBpbkFyZWEgPSBpc0luc2lkZShbY2xpZW50WCwgY2xpZW50WV0sIHBvaW50cyk7XG5cbiAgICAgIGlmIChzZWxlY3RCeUNsaWNrICYmIGluQXJlYSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG92ZXJsYXBQb2ludHMgPSBnZXRPdmVybGFwUG9pbnRzKHJlY3RQb2ludHMsIHBvaW50cyk7XG5cbiAgICAgIGlmICghb3ZlcmxhcFBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3ZlcmxhcFNpemUgPSBnZXRBcmVhU2l6ZShvdmVybGFwUG9pbnRzKTtcbiAgICAgIHZhciB0YXJnZXRTaXplID0gZ2V0QXJlYVNpemUocG9pbnRzKTtcbiAgICAgIHZhciBoaXRSYXRlVmFsdWUgPSBzcGxpdFVuaXQoXCJcIiArIGhpdFJhdGUpO1xuXG4gICAgICBpZiAoaGl0UmF0ZVZhbHVlLnVuaXQgPT09IFwicHhcIikge1xuICAgICAgICByZXR1cm4gb3ZlcmxhcFNpemUgPj0gaGl0UmF0ZVZhbHVlLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhdGUgPSBiZXR3ZWVuKE1hdGgucm91bmQob3ZlcmxhcFNpemUgLyB0YXJnZXRTaXplICogMTAwKSwgMCwgMTAwKTtcbiAgICAgICAgcmV0dXJuIHJhdGUgPj0gTWF0aC5taW4oMTAwLCBoaXRSYXRlVmFsdWUudmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uaW5pdERyYWdTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuZHJhZ1Njcm9sbC5vbihcInNjcm9sbFwiLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBfYS5jb250YWluZXIsXG4gICAgICAgICAgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uO1xuXG4gICAgICBfdGhpcy5lbWl0KFwic2Nyb2xsXCIsIHtcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICB9KTtcbiAgICB9KS5vbihcIm1vdmVcIiwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgb2Zmc2V0WCA9IF9hLm9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WSA9IF9hLm9mZnNldFksXG4gICAgICAgICAgaW5wdXRFdmVudCA9IF9hLmlucHV0RXZlbnQ7XG4gICAgICB2YXIgZ2VzdG8gPSBfdGhpcy5nZXN0bztcblxuICAgICAgaWYgKCFnZXN0byB8fCAhZ2VzdG8uaXNGbGFnKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YXMgPSBfdGhpcy5nZXN0by5nZXRFdmVudERhdGFzKCk7XG5cbiAgICAgIHZhciBib3VuZEFyZWEgPSBkYXRhcy5ib3VuZEFyZWE7XG4gICAgICBkYXRhcy5zdGFydFggLT0gb2Zmc2V0WDtcbiAgICAgIGRhdGFzLnN0YXJ0WSAtPSBvZmZzZXRZO1xuICAgICAgZGF0YXMuc2VsZWN0YWJsZVBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgIHBvc1swXSAtPSBvZmZzZXRYO1xuICAgICAgICAgIHBvc1sxXSAtPSBvZmZzZXRZO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgYm91bmRBcmVhLmxlZnQgLT0gb2Zmc2V0WDtcbiAgICAgIGJvdW5kQXJlYS5yaWdodCAtPSBvZmZzZXRYO1xuICAgICAgYm91bmRBcmVhLnRvcCAtPSBvZmZzZXRZO1xuICAgICAgYm91bmRBcmVhLmJvdHRvbSAtPSBvZmZzZXRZO1xuXG4gICAgICBfdGhpcy5nZXN0by5zY3JvbGxCeShvZmZzZXRYLCBvZmZzZXRZLCBpbnB1dEV2ZW50LmlucHV0RXZlbnQsIGZhbHNlKTtcblxuICAgICAgX3RoaXMuX2NoZWNrU2VsZWN0ZWQoX3RoaXMuZ2VzdG8uZ2V0Q3VycmVudEV2ZW50KCkpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX3NlbGVjdCA9IGZ1bmN0aW9uIChwcmV2U2VsZWN0ZWRUYXJnZXRzLCBzZWxlY3RlZFRhcmdldHMsIHJlY3QsIGlucHV0RXZlbnQsIGlzU3RhcnQpIHtcbiAgICB2YXIgX2EgPSBkaWZmKHByZXZTZWxlY3RlZFRhcmdldHMsIHNlbGVjdGVkVGFyZ2V0cyksXG4gICAgICAgIGFkZGVkID0gX2EuYWRkZWQsXG4gICAgICAgIHJlbW92ZWQgPSBfYS5yZW1vdmVkLFxuICAgICAgICBwcmV2TGlzdCA9IF9hLnByZXZMaXN0LFxuICAgICAgICBsaXN0ID0gX2EubGlzdDtcblxuICAgIHRoaXMuc2VsZWN0ZWRUYXJnZXRzID0gc2VsZWN0ZWRUYXJnZXRzO1xuXG4gICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0aGUgc2VsZWN0KGRyYWcpIHN0YXJ0cywgdGhlIHNlbGVjdFN0YXJ0IGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICAgKiBAZXZlbnQgc2VsZWN0U3RhcnRcbiAgICAgICAqIEBwYXJhbSB7U2VsZWN0by5PblNlbGVjdH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgc2VsZWN0U3RhcnQgZXZlbnRcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBpbXBvcnQgU2VsZWN0byBmcm9tIFwic2VsZWN0b1wiO1xuICAgICAgICpcbiAgICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICAgKiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgICAgICAqICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgICAqICAgc2VsZWN0RnJvbUluc2lkZTogZmFsc2UsXG4gICAgICAgKiB9KTtcbiAgICAgICAqXG4gICAgICAgKiBzZWxlY3RvLm9uKFwic2VsZWN0U3RhcnRcIiwgZSA9PiB7XG4gICAgICAgKiAgIGUuYWRkZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqICAgZS5yZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiB9KS5vbihcInNlbGVjdEVuZFwiLCBlID0+IHtcbiAgICAgICAqICAgZS5hZnRlckFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiAgIGUuYWZ0ZXJSZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiB9KTtcbiAgICAgICAqL1xuICAgICAgdGhpcy5lbWl0KFwic2VsZWN0U3RhcnRcIiwge1xuICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRUYXJnZXRzLFxuICAgICAgICBhZGRlZDogYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIHJldHVybiBsaXN0W2luZGV4XTtcbiAgICAgICAgfSksXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIHJldHVybiBwcmV2TGlzdFtpbmRleF07XG4gICAgICAgIH0pLFxuICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWRkZWQubGVuZ3RoIHx8IHJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdGhlIHNlbGVjdCBpbiByZWFsIHRpbWUsIHRoZSBzZWxlY3QgZXZlbnQgaXMgY2FsbGVkLlxuICAgICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgICAqIEBldmVudCBzZWxlY3RcbiAgICAgICAqIEBwYXJhbSB7U2VsZWN0by5PblNlbGVjdH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgc2VsZWN0IGV2ZW50XG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgICAqXG4gICAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICAgKiAgIHNlbGVjdEJ5Q2xpY2s6IHRydWUsXG4gICAgICAgKiAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAgICogfSk7XG4gICAgICAgKlxuICAgICAgICogc2VsZWN0by5vbihcInNlbGVjdFwiLCBlID0+IHtcbiAgICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqIH0pO1xuICAgICAgICovXG4gICAgICB0aGlzLmVtaXQoXCJzZWxlY3RcIiwge1xuICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRUYXJnZXRzLFxuICAgICAgICBhZGRlZDogYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIHJldHVybiBsaXN0W2luZGV4XTtcbiAgICAgICAgfSksXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIHJldHVybiBwcmV2TGlzdFtpbmRleF07XG4gICAgICAgIH0pLFxuICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5fc2VsZWN0RW5kID0gZnVuY3Rpb24gKHN0YXJ0U2VsZWN0ZWRUYXJnZXRzLCBzdGFydFBhc3NlZFRhcmdldHMsIHJlY3QsIGUpIHtcbiAgICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudCxcbiAgICAgICAgaXNEb3VibGUgPSBlLmlzRG91YmxlO1xuXG4gICAgdmFyIF9hID0gZGlmZihzdGFydFNlbGVjdGVkVGFyZ2V0cywgdGhpcy5zZWxlY3RlZFRhcmdldHMpLFxuICAgICAgICBhZGRlZCA9IF9hLmFkZGVkLFxuICAgICAgICByZW1vdmVkID0gX2EucmVtb3ZlZCxcbiAgICAgICAgcHJldkxpc3QgPSBfYS5wcmV2TGlzdCxcbiAgICAgICAgbGlzdCA9IF9hLmxpc3Q7XG5cbiAgICB2YXIgX2IgPSBkaWZmKHN0YXJ0UGFzc2VkVGFyZ2V0cywgdGhpcy5zZWxlY3RlZFRhcmdldHMpLFxuICAgICAgICBhZnRlckFkZGVkID0gX2IuYWRkZWQsXG4gICAgICAgIGFmdGVyUmVtb3ZlZCA9IF9iLnJlbW92ZWQsXG4gICAgICAgIGFmdGVyUHJldkxpc3QgPSBfYi5wcmV2TGlzdCxcbiAgICAgICAgYWZ0ZXJMaXN0ID0gX2IubGlzdDtcblxuICAgIHZhciB0eXBlID0gaW5wdXRFdmVudCAmJiBpbnB1dEV2ZW50LnR5cGU7XG4gICAgdmFyIGlzRHJhZ1N0YXJ0ID0gdHlwZSA9PT0gXCJtb3VzZWRvd25cIiB8fCB0eXBlID09PSBcInRvdWNoc3RhcnRcIjtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBzZWxlY3QoZHJhZ0VuZCBvciBjbGljaykgZW5kcywgdGhlIHNlbGVjdEVuZCBldmVudCBpcyBjYWxsZWQuXG4gICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgKiBAZXZlbnQgc2VsZWN0RW5kXG4gICAgICogQHBhcmFtIHtTZWxlY3RvLk9uU2VsZWN0RW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBzZWxlY3RFbmQgZXZlbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAqICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgKiAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2VsZWN0by5vbihcInNlbGVjdFN0YXJ0XCIsIGUgPT4ge1xuICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAqICAgfSk7XG4gICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pLm9uKFwic2VsZWN0RW5kXCIsIGUgPT4ge1xuICAgICAqICAgZS5hZnRlckFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICogICB9KTtcbiAgICAgKiAgIGUuYWZ0ZXJSZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIHRoaXMuZW1pdChcInNlbGVjdEVuZFwiLCB7XG4gICAgICBzZWxlY3RlZDogdGhpcy5zZWxlY3RlZFRhcmdldHMsXG4gICAgICBhZGRlZDogYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFtpbmRleF07XG4gICAgICB9KSxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gcHJldkxpc3RbaW5kZXhdO1xuICAgICAgfSksXG4gICAgICBhZnRlckFkZGVkOiBhZnRlckFkZGVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFmdGVyTGlzdFtpbmRleF07XG4gICAgICB9KSxcbiAgICAgIGFmdGVyUmVtb3ZlZDogYWZ0ZXJSZW1vdmVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFmdGVyUHJldkxpc3RbaW5kZXhdO1xuICAgICAgfSksXG4gICAgICBpc0RyYWdTdGFydDogaXNEcmFnU3RhcnQsXG4gICAgICBpc0NsaWNrOiAhIWUuaXNDbGljayxcbiAgICAgIGlzRG91YmxlOiAhIWlzRG91YmxlLFxuICAgICAgcmVjdDogcmVjdCxcbiAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnRcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLl9jaGVja1NlbGVjdGVkID0gZnVuY3Rpb24gKGUsIHJlY3QpIHtcbiAgICBpZiAocmVjdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZWN0ID0gZ2V0UmVjdChlLCB0aGlzLm9wdGlvbnMucmF0aW8pO1xuICAgIH1cblxuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgdmFyIHRvcCA9IHJlY3QudG9wLFxuICAgICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgIHZhciBzZWxlY3RGbGFnID0gZGF0YXMuc2VsZWN0RmxhZztcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgY29udGFpbmVyWCA9IGRhdGFzLmNvbnRhaW5lclgsXG4gICAgICAgIGNvbnRhaW5lclkgPSBkYXRhcy5jb250YWluZXJZLFxuICAgICAgICBzY2FsZU1hdHJpeCA9IGRhdGFzLnNjYWxlTWF0cml4O1xuICAgIHZhciBvZmZzZXRQb3MgPSBjYWxjdWxhdGVNYXRyaXhEaXN0KHNjYWxlTWF0cml4LCBbbGVmdCAtIGNvbnRhaW5lclgsIHRvcCAtIGNvbnRhaW5lclldKTtcbiAgICB2YXIgb2Zmc2V0U2l6ZSA9IGNhbGN1bGF0ZU1hdHJpeERpc3Qoc2NhbGVNYXRyaXgsIFt3aWR0aCwgaGVpZ2h0XSk7XG4gICAgdmFyIHByZXZTZWxlY3RlZFRhcmdldHMgPSBbXTtcbiAgICB2YXIgc2VsZWN0ZWRUYXJnZXRzID0gW107XG5cbiAgICBpZiAoc2VsZWN0RmxhZykge1xuICAgICAgdGhpcy50YXJnZXQuc3R5bGUuY3NzVGV4dCArPSBcImRpc3BsYXk6IGJsb2NrO1wiICsgXCJsZWZ0OjBweDt0b3A6MHB4O1wiICsgKFwidHJhbnNmb3JtOiB0cmFuc2xhdGUoXCIgKyBvZmZzZXRQb3NbMF0gKyBcInB4LCBcIiArIG9mZnNldFBvc1sxXSArIFwicHgpO1wiKSArIChcIndpZHRoOlwiICsgb2Zmc2V0U2l6ZVswXSArIFwicHg7aGVpZ2h0OlwiICsgb2Zmc2V0U2l6ZVsxXSArIFwicHg7XCIpO1xuICAgICAgdmFyIHBhc3NlZFRhcmdldHMgPSB0aGlzLmhpdFRlc3QocmVjdCwgZGF0YXMuc3RhcnRYLCBkYXRhcy5zdGFydFksIGRhdGFzLnNlbGVjdGFibGVUYXJnZXRzLCBkYXRhcy5zZWxlY3RhYmxlUG9pbnRzKTtcbiAgICAgIHByZXZTZWxlY3RlZFRhcmdldHMgPSB0aGlzLnNlbGVjdGVkVGFyZ2V0cztcbiAgICAgIHNlbGVjdGVkVGFyZ2V0cyA9IHBhc3NUYXJnZXRzKGRhdGFzLnN0YXJ0UGFzc2VkVGFyZ2V0cywgcGFzc2VkVGFyZ2V0cywgb3B0aW9ucy5jb250aW51ZVNlbGVjdCAmJiBvcHRpb25zLmNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0KTtcbiAgICAgIHRoaXMuc2VsZWN0ZWRUYXJnZXRzID0gc2VsZWN0ZWRUYXJnZXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBkcmFnLCB0aGUgZHJhZyBldmVudCBpcyBjYWxsZWQuXG4gICAgICogQ2FsbCB0aGUgc3RvcCAoKSBmdW5jdGlvbiBpZiB5b3UgaGF2ZSBhIHNwZWNpZmljIGVsZW1lbnQgb3IgZG9uJ3Qgd2FudCB0byByYWlzZSBhIHNlbGVjdFxuICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICogQGV2ZW50IGRyYWdcbiAgICAgKiBAcGFyYW0ge09uRHJhZ30gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZyBldmVudFxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICogICBzZWxlY3RCeUNsaWNrOiB0cnVlLFxuICAgICAqICAgc2VsZWN0RnJvbUluc2lkZTogZmFsc2UsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzZWxlY3RvLm9uKFwiZHJhZ1wiLCBlID0+IHtcbiAgICAgKiAgIGUuc3RvcCgpO1xuICAgICAqIH0pLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAqICAgfSk7XG4gICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqL1xuXG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5lbWl0KFwiZHJhZ1wiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIGlzU2VsZWN0OiBzZWxlY3RGbGFnLFxuICAgICAgcmVjdDogcmVjdFxuICAgIH0pKTtcblxuICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnRhcmdldC5zdHlsZS5jc3NUZXh0ICs9IFwiZGlzcGxheTogbm9uZTtcIjtcbiAgICAgIGUuc3RvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RGbGFnKSB7XG4gICAgICB0aGlzLl9zZWxlY3QocHJldlNlbGVjdGVkVGFyZ2V0cywgc2VsZWN0ZWRUYXJnZXRzLCByZWN0LCBpbnB1dEV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5fc2FtZUNvbWJpS2V5ID0gZnVuY3Rpb24gKGUsIGlzS2V5dXApIHtcbiAgICB2YXIgdG9nZ2xlQ29udGludWVTZWxlY3QgPSBbXS5jb25jYXQodGhpcy5vcHRpb25zLnRvZ2dsZUNvbnRpbnVlU2VsZWN0KTtcbiAgICB2YXIgY29tYmkgPSBnZXRDb21iaShlLmlucHV0RXZlbnQsIGUua2V5KTtcbiAgICB2YXIgdG9nZ2xlS2V5cyA9IGlzQXJyYXkodG9nZ2xlQ29udGludWVTZWxlY3RbMF0pID8gdG9nZ2xlQ29udGludWVTZWxlY3QgOiBbdG9nZ2xlQ29udGludWVTZWxlY3RdO1xuXG4gICAgaWYgKGlzS2V5dXApIHtcbiAgICAgIHZhciBzaW5nbGVLZXlfMSA9IGUua2V5O1xuICAgICAgcmV0dXJuIHRvZ2dsZUtleXMuc29tZShmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICByZXR1cm4ga2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4ga2V5ID09PSBzaW5nbGVLZXlfMTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9nZ2xlS2V5cy5zb21lKGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICByZXR1cm4ga2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBjb21iaS5pbmRleE9mKGtleSkgPiAtMTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2ZpbmRFbGVtZW50ID0gZnVuY3Rpb24gKGNsaWNrZWRUYXJnZXQsIHNlbGVjdGFibGVUYXJnZXRzKSB7XG4gICAgdmFyIHBvaW50VGFyZ2V0ID0gY2xpY2tlZFRhcmdldDtcblxuICAgIHdoaWxlIChwb2ludFRhcmdldCkge1xuICAgICAgaWYgKHNlbGVjdGFibGVUYXJnZXRzLmluZGV4T2YocG9pbnRUYXJnZXQpID4gLTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBvaW50VGFyZ2V0ID0gcG9pbnRUYXJnZXQucGFyZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRUYXJnZXQ7XG4gIH07XG5cbiAgU2VsZWN0byA9IF9fZGVjb3JhdGUoW1Byb3BlcnRpZXMoUFJPUEVSVElFUywgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHkpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1twcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gY2FtZWxpemUoXCJzZXQgXCIgKyBwcm9wZXJ0eSk7XG5cbiAgICBpZiAocHJvdG90eXBlW3NldHRlcl0pIHtcbiAgICAgIGF0dHJpYnV0ZXMuc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXNbc2V0dGVyXSh2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGVzLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIHByb3BlcnR5LCBhdHRyaWJ1dGVzKTtcbiAgfSldLCBTZWxlY3RvKTtcbiAgcmV0dXJuIFNlbGVjdG87XG59KEV2ZW50RW1pdHRlcik7XG5cbnZhciBTZWxlY3RvJDEgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2VsZWN0bywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTZWxlY3RvKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBTZWxlY3RvO1xufShTZWxlY3RvKTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0byQxO1xuZXhwb3J0IHsgQ0xBU1NfTkFNRSwgRVZFTlRTLCBNRVRIT0RTLCBPUFRJT05TLCBPUFRJT05fVFlQRVMsIFBST1BFUlRJRVMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdG8uZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiVmFsdWVQaWNrZXIiLCJBZGRMYXllckJ1dHRvbiIsIm9uQ2hhbmdlIiwib3B0aW9ucyIsImxhYmVsIiwiY3NzIiwiY3giLCJEcmFnRHJvcENvbnRleHQiLCJEcmFnZ2FibGUiLCJEcm9wcGFibGUiLCJjb25maWciLCJJY29uIiwiSWNvbkJ1dHRvbiIsInN0eWxlc0ZhY3RvcnkiLCJMYXllck5hbWUiLCJMYXllckRyYWdEcm9wTGlzdCIsImxheWVycyIsImdldExheWVySW5mbyIsIm9uRHJhZ0VuZCIsIm9uU2VsZWN0Iiwib25EZWxldGUiLCJvbkR1cGxpY2F0ZSIsInNob3dBY3Rpb25zIiwic2VsZWN0aW9uIiwiZXhjbHVkZUJhc2VMYXllciIsIm9uTmFtZUNoYW5nZSIsInZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3MiLCJzdHlsZSIsInN0eWxlcyIsInRoZW1lIiwiZ2V0Um93U3R5bGUiLCJpc1NlbGVjdGVkIiwicm93Iiwic2VsIiwicHJvdmlkZWQiLCJzbmFwc2hvdCIsImRyb3BwYWJsZVByb3BzIiwiaW5uZXJSZWYiLCJyb3dzIiwibGFzdExheWVySW5kZXgiLCJzaG91bGRSZW5kZXJEcmFnSWNvbkxlbmd0aFRocmVzaG9sZCIsImkiLCJsZW5ndGgiLCJlbGVtZW50IiwidWlkIiwiZ2V0TmFtZSIsIkJvb2xlYW4iLCJpbmNsdWRlcyIsInB1c2giLCJkcmFnZ2FibGVQcm9wcyIsImRyYWdIYW5kbGVQcm9wcyIsInYiLCJ1bmRlZmluZWQiLCJ0ZXh0V3JhcHBlciIsImFjdGlvbkljb24iLCJkcmFnSWNvbiIsInBsYWNlaG9sZGVyIiwiZGVmYXVsdFByb3BzIiwiaXNHcm91cCIsIndyYXBwZXIiLCJzcGFjaW5nIiwibWQiLCJ4cyIsInNtIiwiYm9yZGVyIiwicmFkaXVzIiwiY29sb3JzIiwiYmcyIiwiZm9ybUlucHV0SGVpZ2h0IiwiZm9ybUlucHV0Qm9yZGVyIiwiZm9ybUlucHV0Qm9yZGVySG92ZXIiLCJmb3JtSW5wdXRCb3JkZXJBY3RpdmUiLCJ0ZXh0V2VhayIsInRleHQiLCJ0eXBlV3JhcHBlciIsInRleHRCbHVlIiwidXNlU3RhdGUiLCJJbnB1dCIsIkZpZWxkVmFsaWRhdGlvbk1lc3NhZ2UiLCJ1c2VTdHlsZXMiLCJuYW1lIiwiZ2V0U3R5bGVzIiwiaXNFZGl0aW5nIiwic2V0SXNFZGl0aW5nIiwidmFsaWRhdGlvbkVycm9yIiwic2V0VmFsaWRhdGlvbkVycm9yIiwib25FZGl0TGF5ZXIiLCJldmVudCIsIm9uRW5kRWRpdE5hbWUiLCJuZXdOYW1lIiwib25JbnB1dENoYW5nZSIsImN1cnJlbnRUYXJnZXQiLCJ2YWx1ZSIsInRyaW0iLCJvbkVkaXRMYXllckJsdXIiLCJvbktleURvd24iLCJrZXkiLCJ0YXJnZXQiLCJvbkZvY3VzIiwic2VsZWN0IiwibGF5ZXJOYW1lV3JhcHBlciIsImxheWVyTmFtZSIsImxheWVyRWRpdEljb24iLCJsYXllck5hbWVJbnB1dCIsImJnMyIsImJvcmRlcjMiLCJ0eXBvZ3JhcGh5Iiwid2VpZ2h0Iiwic2VtaWJvbGQiLCJQdXJlQ29tcG9uZW50IiwiQnV0dG9uIiwiVGV4dERpbWVuc2lvbkVkaXRvciIsIkFQSUVkaXRvciIsImNhbGxBcGkiLCJCdXR0b25EaXNwbGF5IiwicmVuZGVyIiwiZGF0YSIsInByb3BzIiwib25DbGljayIsImFwaSIsImJ1dHRvbkl0ZW0iLCJpZCIsImRlc2NyaXB0aW9uIiwiZGlzcGxheSIsImRlZmF1bHRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJnZXROZXdPcHRpb25zIiwicHJlcGFyZURhdGEiLCJjdHgiLCJjZmciLCJnZXRUZXh0IiwicmVnaXN0ZXJPcHRpb25zVUkiLCJidWlsZGVyIiwiY2F0ZWdvcnkiLCJhZGRDdXN0b21FZGl0b3IiLCJwYXRoIiwiZWRpdG9yIiwidXNlU3R5bGVzMiIsIlNjYWxhckRpbWVuc2lvbkVkaXRvciIsIkRyb25lRnJvbnREaXNwbGF5IiwiZHJvbmVGcm9udFRyYW5zZm9ybVN0eWxlIiwicm9sbEFuZ2xlIiwiZHJvbmVGcm9udCIsInRyYW5zZm9ybSIsImRyb25lRnJvbnRJdGVtIiwiZ2V0U2NhbGFyIiwiRHJvbmVTaWRlRGlzcGxheSIsImRyb25lU2lkZVBpdGNoVHJhbnNmb3JtU3R5bGUiLCJwaXRjaEFuZ2xlIiwiZHJvbmVTaWRlIiwiZHJvbmVTaWRlSXRlbSIsIkRyb25lVG9wRGlzcGxheSIsImZSaWdodFJvdG9yQW5pbWF0aW9uIiwiZlJpZ2h0Um90b3JSUE0iLCJNYXRoIiwiYWJzIiwiZkxlZnRSb3RvckFuaW1hdGlvbiIsImZMZWZ0Um90b3JSUE0iLCJiUmlnaHRSb3RvckFuaW1hdGlvbiIsImJSaWdodFJvdG9yUlBNIiwiYkxlZnRSb3RvckFuaW1hdGlvbiIsImJMZWZ0Um90b3JSUE0iLCJkcm9uZVRvcFRyYW5zZm9ybVN0eWxlIiwieWF3QW5nbGUiLCJwcm9wZWxsZXIiLCJwcm9wZWxsZXJDVyIsImFuaW1hdGlvbiIsInByb3BlbGxlckNDVyIsImRyb25lVG9wSXRlbSIsImlzU3RyaW5nIiwiU1ZHIiwiUmVzb3VyY2VEaW1lbnNpb25Nb2RlIiwiZ2V0UHVibGljT3JBYnNvbHV0ZVVybCIsIkNvbG9yRGltZW5zaW9uRWRpdG9yIiwiUmVzb3VyY2VEaW1lbnNpb25FZGl0b3IiLCJzdmdTdHJva2VQYXRoQ2xhc3MiLCJJY29uRGlzcGxheSIsInN2Z1N0eWxlIiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZUNvbG9yIiwic3Ryb2tlV2lkdGgiLCJpY29uSXRlbSIsInBsYWNlbWVudCIsInRvcCIsImxlZnQiLCJtb2RlIiwiRml4ZWQiLCJmaXhlZCIsImdldFJlc291cmNlIiwiZ2V0Q29sb3IiLCJjb2xvciIsInNldHRpbmdzIiwicmVzb3VyY2VUeXBlIiwiZGVmYXVsdFZhbHVlIiwiYWRkU2xpZGVySW5wdXQiLCJtaW4iLCJtYXgiLCJzaG93SWYiLCJOb3RGb3VuZERpc3BsYXkiLCJKU09OIiwic3RyaW5naWZ5Iiwibm90Rm91bmRJdGVtIiwiQWxpZ24iLCJWQWxpZ24iLCJUZXh0Qm94RGlzcGxheSIsInRoZW1lMiIsImNvbnRhaW5lciIsInNwYW4iLCJ2YWxpZ24iLCJhbGlnbiIsInNpemUiLCJ0ZXh0Qm94SXRlbSIsImJhY2tncm91bmQiLCJMZWZ0IiwiTWlkZGxlIiwiQ2VudGVyIiwiYWRkUmFkaW8iLCJSaWdodCIsIlRvcCIsIkJvdHRvbSIsImFkZE51bWJlcklucHV0IiwiV2luZFR1cmJpbmVEaXNwbGF5Iiwid2luZFR1cmJpbmVBbmltYXRpb24iLCJycG0iLCJibGFkZSIsIndpbmRUdXJiaW5lSXRlbSIsIkNhbnZhc0ZyYW1lT3B0aW9ucyIsIlJlZ2lzdHJ5IiwiREVGQVVMVF9DQU5WQVNfRUxFTUVOVF9DT05GSUciLCJ0eXBlIiwiY2FudmFzRWxlbWVudFJlZ2lzdHJ5IiwiSG9yaXpvbnRhbENvbnN0cmFpbnQiLCJWZXJ0aWNhbENvbnN0cmFpbnQiLCJkaW1lbnNpb25WaWV3YWJsZSIsImV2ZW50cyIsIm1vdmVhYmxlIiwicmVjdCIsImdldFJlY3QiLCJwb3NpdGlvbiIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciLCJmb250U2l6ZSIsIndoaXRlU3BhY2UiLCJmb250V2VpZ2h0Iiwid2lsbENoYW5nZSIsInpJbmRleCIsInJvdW5kIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJjb25zdHJhaW50Vmlld2FibGUiLCJzY2VuZSIsInRhcmdldEVsZW1lbnQiLCJmaW5kRWxlbWVudEJ5VGFyZ2V0Iiwic3RhdGUiLCJpc01vdmluZyIsInNlbGVjdG8iLCJnZXRTZWxlY3RlZFRhcmdldHMiLCJ2ZXJ0aWNhbENvbnN0cmFpbnRWaXN1YWxpemF0aW9uIiwiaG9yaXpvbnRhbENvbnN0cmFpbnRWaXN1YWxpemF0aW9uIiwiY29uc3RyYWludCIsInRlbXBDb25zdHJhaW50IiwiYm9yZGVyU3R5bGUiLCJjZW50ZXJJbmRpY2F0b3JMaW5lT25lIiwiY3JlYXRlRWxlbWVudCIsImJvcmRlckxlZnQiLCJjZW50ZXJJbmRpY2F0b3JMaW5lVHdvIiwiY2VudGVySW5kaWNhdG9yIiwidmVydGljYWxDb25zdHJhaW50VG9wIiwiYm90dG9tIiwidmVydGljYWxDb25zdHJhaW50Qm90dG9tIiwidmVydGljYWxDb25zdHJhaW50VG9wQm90dG9tIiwidmVydGljYWxDb25zdHJhaW50Q2VudGVyTGluZSIsInZlcnRpY2FsQ29uc3RyYWludENlbnRlciIsInZlcnRpY2FsIiwiVG9wQm90dG9tIiwiaG9yaXpvbnRhbENvbnN0cmFpbnRMZWZ0IiwicmlnaHQiLCJib3JkZXJUb3AiLCJob3Jpem9udGFsQ29uc3RyYWludFJpZ2h0IiwiaG9yaXpvbnRhbENvbnN0cmFpbnRMZWZ0UmlnaHQiLCJob3Jpem9udGFsQ29uc3RyYWludENlbnRlckxpbmUiLCJob3Jpem9udGFsQ29uc3RyYWludENlbnRlciIsImhvcml6b250YWwiLCJMZWZ0UmlnaHQiLCJjb25zdHJhaW50VmlzdWFsaXphdGlvbiIsIkJhY2tncm91bmRJbWFnZVNpemUiLCJjb3VudGVyIiwiRWxlbWVudFN0YXRlIiwiY29uc3RydWN0b3IiLCJpdGVtIiwicGFyZW50IiwiZGl2IiwiYXBwbHlMYXlvdXRTdHlsZXNUb0RpdiIsImhhc0hvcml6b250YWxDZW50ZXJDb25zdHJhaW50IiwiaGFzVmVydGljYWxDZW50ZXJDb25zdHJhaW50IiwibnVtYmVyT2ZUYXJnZXRzIiwiZ2V0U2NlbmUiLCJpc011bHRpU2VsZWN0aW9uIiwiZWxlbWVudENvbnRhaW5lciIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInlPZmZzZXQiLCJ0cmFuc2xhdGUiLCJkZWx0YVgiLCJkZWx0YSIsImRlbHRhWSIsImRpckxSIiwiZGlyZWN0aW9uIiwiZGlyVEIiLCJmYWxsYmFja05hbWUiLCJEYXRlIiwibm93IiwiZ2V0TmV4dEVsZW1lbnROYW1lIiwiYnlOYW1lIiwic2V0IiwidHJhdiIsImlzUm9vdCIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwiU2NhbGUiLCJzaXplU3R5bGUiLCJkYXRhU3R5bGUiLCJzZXRQbGFjZW1lbnRGcm9tQ29uc3RyYWludCIsInBhcmVudENvbnRhaW5lciIsInBhcmVudEVsZW1lbnQiLCJyZWxhdGl2ZVRvcCIsInJlbGF0aXZlQm90dG9tIiwicmVsYXRpdmVMZWZ0IiwicmVsYXRpdmVSaWdodCIsImVsZW1lbnRDZW50ZXIiLCJwYXJlbnRDZW50ZXIiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJyZXZJZCIsInVwZGF0ZURhdGEiLCJiYWNrZ3JvdW5kQ29sb3IiLCJpbWFnZSIsImJhY2tncm91bmRJbWFnZSIsIkNvbnRhaW4iLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRSZXBlYXQiLCJDb3ZlciIsIk9yaWdpbmFsIiwiVGlsZSIsIkZpbGwiLCJib3JkZXJXaWR0aCIsImJvcmRlckNvbG9yIiwiYmFja2dyb3VuZE9yaWdpbiIsInZpc2l0IiwidmlzaXRvciIsImdldElmRXhpc3RzIiwib2xkTmFtZSIsInNhdmUiLCJkZWxldGUiLCJnZXRTYXZlTW9kZWwiLCJpbml0RWxlbWVudCIsIlVJRCIsImNsb25lRGVlcCIsIkxheWVyQWN0aW9uSUQiLCJmcmFtZUl0ZW1EdW1teSIsIkZyYW1lU3RhdGUiLCJhY3Rpb24iLCJ1cGRhdGVOYW1lIiwic2hpZnRJdGVtc09uRHVwbGljYXRlIiwiRGVsZXRlIiwiZWxlbWVudHMiLCJmaWx0ZXIiLCJlIiwicmVpbml0aWFsaXplTW92ZWFibGUiLCJEdXBsaWNhdGUiLCJjb25zb2xlIiwibG9nIiwib3B0cyIsIm9sZFBsYWNlbWVudCIsImNvcHkiLCJjb250ZXh0IiwiTW92ZVRvcCIsIk1vdmVCb3R0b20iLCJkb01vdmUiLCJjIiwiZWxlbSIsInJlb3JkZXIiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJyZXN1bHQiLCJBcnJheSIsImZyb20iLCJyZW1vdmVkIiwic3BsaWNlIiwiY2hpbGQiLCJ2YWxzIiwidW5zaGlmdCIsImNsZWFyQ3VycmVudFNlbGVjdGlvbiIsInNldFRpbWVvdXQiLCJpbml0TW92ZWFibGUiLCJpc0VkaXRpbmdFbmFibGVkIiwib3ZlcmZsb3ciLCJtYXAiLCJSb290RWxlbWVudCIsImNoYW5nZUNhbGxiYWNrIiwicmVzdCIsInByZXZlbnREZWZhdWx0Iiwic2V0Um9vdFJlZiIsIk1vdmVhYmxlIiwiUmVwbGF5U3ViamVjdCIsIlN1YmplY3QiLCJmaXJzdCIsIlNlbGVjdG8iLCJsb2NhdGlvblNlcnZpY2UiLCJQb3J0YWwiLCJnZXRDb2xvckRpbWVuc2lvbkZyb21EYXRhIiwiZ2V0UmVzb3VyY2VEaW1lbnNpb25Gcm9tRGF0YSIsImdldFNjYWxhckRpbWVuc2lvbkZyb21EYXRhIiwiZ2V0U2NhbGVEaW1lbnNpb25Gcm9tRGF0YSIsImdldFRleHREaW1lbnNpb25Gcm9tRGF0YSIsIkNhbnZhc0NvbnRleHRNZW51IiwiU2NlbmUiLCJlbmFibGVFZGl0aW5nIiwib25TYXZlIiwiTWFwIiwiZ2V0U2VhcmNoT2JqZWN0IiwiZWRpdFBhbmVsIiwiaXNGcmFtZSIsImlkeCIsImhhcyIsImdldFNjYWxlIiwic2NhbGUiLCJzY2FsYXIiLCJyZXMiLCJtaW5Ub3AiLCJJbmZpbml0eSIsIm1pbkxlZnQiLCJtYXhSaWdodCIsIm1heEJvdHRvbSIsImZvckVhY2giLCJ1cGRhdGVNb3ZlYWJsZSIsInJvb3QiLCJzdGFjayIsImN1cnJlbnRFbGVtZW50Iiwic2hpZnQiLCJuZXN0ZWRFbGVtZW50cyIsIm5lc3RlZEVsZW1lbnQiLCJzY2VuZUNvbnRhaW5lciIsInNldFNlbGVjdGVkVGFyZ2V0cyIsInRhcmdldHMiLCJ1cGRhdGVTZWxlY3Rpb24iLCJza2lwTmV4dFNlbGVjdGlvbkJyb2FkY2FzdCIsImZyYW1lIiwibmV4dCIsInMiLCJ0Iiwicm9vdEVsZW1lbnRzIiwidGFyZ2V0RWxlbWVudHMiLCJkZXN0cm95U2VsZWN0byIsImFsbG93Q2hhbmdlcyIsImdlbmVyYXRlVGFyZ2V0RWxlbWVudHMiLCJkZXN0cm95Iiwic2VsZWN0YWJsZVRhcmdldHMiLCJzZWxlY3RCeUNsaWNrIiwiZHJhZ2dhYmxlIiwicmVzaXphYmxlIiwiYWJsZXMiLCJvcmlnaW4iLCJjbGFzc05hbWUiLCJzZWxlY3RlZCIsIm9uIiwiY2xpY2tUYXJnZXQiLCJpbnB1dEV2ZW50IiwiaW5wdXRUYXJnZXQiLCJ0YXJnZXRlZEVsZW1lbnQiLCJhcHBseURyYWciLCJtb3ZlZCIsImFwcGx5UmVzaXplIiwic2VsZWN0ZWRUYXJnZXQiLCJpc1RhcmdldE1vdmVhYmxlRWxlbWVudCIsImlzTW92ZWFibGVFbGVtZW50Iiwic29tZSIsImNvbnRhaW5zIiwic3RvcCIsImlzRHJhZ1N0YXJ0IiwiZHJhZ1N0YXJ0IiwibG9hZCIsImN1cnJlbnRMYXllciIsInVwZGF0ZVNpemUiLCJmcmFtZVNlbGVjdGlvbiIsInBpcGUiLCJzdWJzY3JpYmUiLCJjdXJyZW50U2VsZWN0ZWRFbGVtZW50cyIsIm5ld0xheWVyIiwiZnJhbWVQbGFjZW1lbnQiLCJnZW5lcmF0ZUZyYW1lQ29udGFpbmVyIiwiZG9BY3Rpb24iLCJNb3VzZUV2ZW50IiwidXBkYXRlQ3VycmVudExheWVyIiwiY2FuU2hvd0NvbnRleHRNZW51IiwiaXNQYW5lbEVkaXRpbmciLCJ3cmFwIiwic2V0UmVmIiwiUXVpY2tQbGFjZW1lbnQiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsIkNvbnRleHRNZW51IiwiTWVudUl0ZW0iLCJpc01lbnVWaXNpYmxlIiwic2V0SXNNZW51VmlzaWJsZSIsImFuY2hvclBvaW50Iiwic2V0QW5jaG9yUG9pbnQiLCJ4IiwieSIsInNlbGVjdGVkRWxlbWVudHMiLCJoYW5kbGVDb250ZXh0TWVudSIsInBhZ2VYIiwicGFnZVkiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xvc2VDb250ZXh0TWVudSIsInJlbmRlck1lbnVJdGVtcyIsImNvbnRleHRNZW51QWN0aW9uIiwibWVudUl0ZW0iLCJhY3Rpb25UeXBlIiwiY3VycmVudFNlbGVjdGVkRWxlbWVudCIsIkNvbXBvbmVudCIsIlN1YnNjcmlwdGlvbiIsIlBhbmVsQ29udGV4dFJvb3QiLCJQYW5lbEVkaXRFbnRlcmVkRXZlbnQiLCJQYW5lbEVkaXRFeGl0ZWRFdmVudCIsIklubGluZUVkaXQiLCJjYW52YXNJbnN0YW5jZXMiLCJhY3RpdmVDYW52YXNQYW5lbCIsImlzSW5saW5lRWRpdE9wZW4iLCJhY3RpdmVQYW5lbFN1YmplY3QiLCJDYW52YXNQYW5lbCIsIm9uT3B0aW9uc0NoYW5nZSIsInNldFN0YXRlIiwicmVmcmVzaCIsImZvcmNlVXBkYXRlIiwic2V0QWN0aXZlUGFuZWwiLCJvcGVuSW5saW5lRWRpdCIsInBhbmVsIiwiaW5saW5lRWRpdEJ1dHRvbkNsb3NlIiwiaW5saW5lRWRpdGluZyIsIm9uVXBkYXRlU2NlbmUiLCJzdWJzIiwiYWRkIiwiZXZlbnRCdXMiLCJldnQiLCJwYXlsb2FkIiwibmVlZHNSZWxvYWQiLCJjb21wb25lbnREaWRNb3VudCIsInBhbmVsQ29udGV4dCIsIm9uSW5zdGFuY2VTdGF0ZUNoYW5nZSIsImxheWVyIiwiY2FudmFzSW5zdGFuY2UiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInVuc3Vic2NyaWJlIiwiY2kiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJuZXh0UHJvcHMiLCJuZXh0U3RhdGUiLCJjaGFuZ2VkIiwic2hvdWxkVXBkYXRlU2NlbmVBbmRQYW5lbCIsImlubGluZUVkaXRpbmdTd2l0Y2hlZCIsImlubGluZUVkaXRCdXR0b24iLCJpbmxpbmVFZGl0QnV0dG9uQ2xpY2siLCJyZW5kZXJJbmxpbmVFZGl0IiwidXNlUmVmIiwiUmVzaXphYmxlIiwic3RvcmUiLCJJbmxpbmVFZGl0Qm9keSIsIk9GRlNFVF9YIiwib25DbG9zZSIsImJ0bklubGluZUVkaXQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJyZWYiLCJpbmxpbmVFZGl0S2V5IiwiZGVmYXVsdE1lYXN1cmVtZW50cyIsImRlZmF1bHRYIiwiZGVmYXVsdFkiLCJzYXZlZFBsYWNlbWVudCIsImdldE9iamVjdCIsInciLCJoIiwibWVhc3VyZW1lbnRzIiwic2V0TWVhc3VyZW1lbnRzIiwic2V0UGxhY2VtZW50Iiwib25EcmFnU3RvcCIsImRyYWdFbGVtZW50Iiwic2F2ZVRvU3RvcmUiLCJvblJlc2l6ZVN0b3AiLCJzZXRPYmplY3QiLCJkcmFnZ2FibGVXcmFwcGVyIiwiaW5saW5lRWRpdG9yQ29udGFpbmVyIiwiaW5saW5lRWRpdG9ySGVhZGVyIiwiaW5saW5lRWRpdG9yQ2xvc2UiLCJpbmxpbmVFZGl0b3JDb250ZW50V3JhcHBlciIsImlubGluZUVkaXRvckNvbnRlbnQiLCJ2MSIsInBhbmVsQmciLCJjYW52YXMiLCJ3ZWFrIiwiZ2V0IiwibG9kYXNoR2V0IiwidXNlTWVtbyIsInVzZU9ic2VydmFibGUiLCJPcHRpb25zUGFuZUNhdGVnb3J5RGVzY3JpcHRvciIsImZpbGxPcHRpb25zUGFuZUl0ZW1zIiwic2V0T3B0aW9uSW1tdXRhYmx5IiwiZ2V0RWxlbWVudEVkaXRvciIsImdldExheWVyRWRpdG9yIiwiYWN0aXZlUGFuZWwiLCJpbnN0YW5jZVN0YXRlIiwicGFuZSIsInRpdGxlIiwic3VwcGxpZXIiLCJhZGROZXN0ZWRPcHRpb25zIiwiZ2V0T3B0aW9uc1BhbmVDYXRlZ29yeURlc2NyaXB0b3IiLCJpdGVtcyIsImNhdGVnb3JpZXMiLCJpbnB1dCIsImdldE9wdGlvbnNQYW5lQ2F0ZWdvcnkiLCJjYXRlZ29yeU5hbWVzIiwic3ViIiwiZmluZCIsImFjY2VzcyIsImdldFZhbHVlIiwiQXBwRXZlbnRzIiwiZ2V0QmFja2VuZFNydiIsIklubGluZUZpZWxkIiwiSW5saW5lRmllbGRSb3ciLCJKU09ORm9ybWF0dGVyIiwiU3RyaW5nVmFsdWVFZGl0b3IiLCJhcHBFdmVudHMiLCJkdW1teVN0cmluZ1NldHRpbmdzIiwiaXNUZXN0IiwiZmV0Y2giLCJ1cmwiLCJlbmRwb2ludCIsIm1ldGhvZCIsImVycm9yIiwiZW1pdCIsImFsZXJ0RXJyb3IiLCJjb21wbGV0ZSIsImFsZXJ0U3VjY2VzcyIsImxhYmVsV2lkdGgiLCJvbkVuZHBvaW50Q2hhbmdlIiwib25EYXRhQ2hhbmdlIiwicmVuZGVySlNPTiIsImpzb24iLCJwYXJzZSIsIkVycm9yIiwibWVzc2FnZSIsInJlbmRlclRlc3RBUElCdXR0b24iLCJkaXNhYmxlU2FuaXRpemVIdG1sIiwiQ29uc3RyYWludFNlbGVjdGlvbkJveCIsIm9uVmVydGljYWxDb25zdHJhaW50Q2hhbmdlIiwib25Ib3Jpem9udGFsQ29uc3RyYWludENoYW5nZSIsImN1cnJlbnRDb25zdHJhaW50cyIsIm9uQ2xpY2tUb3BDb25zdHJhaW50Iiwib25DbGlja0JvdHRvbUNvbnN0cmFpbnQiLCJvbkNsaWNrVmVydGljYWxDZW50ZXJDb25zdHJhaW50Iiwib25DbGlja0xlZnRDb25zdHJhaW50Iiwib25DbGlja1JpZ2h0Q29uc3RyYWludCIsIm9uQ2xpY2tIb3Jpem9udGFsQ2VudGVyQ29uc3RyYWludCIsIm1hcmdpbkJvdHRvbSIsInRvcENvbnN0cmFpbnQiLCJjb25zdHJhaW50SG92ZXIiLCJib3R0b21Db25zdHJhaW50IiwibGVmdENvbnN0cmFpbnQiLCJyaWdodENvbnN0cmFpbnQiLCJib3giLCJ2ZXJ0aWNhbENlbnRlckNvbnN0cmFpbnQiLCJob3Jpem9udGFsQ2VudGVyQ29uc3RyYWludCIsIkhPVkVSX0NPTE9SIiwiSE9WRVJfT1BBQ0lUWSIsIlNFTEVDVEVEX0NPTE9SIiwic2VsZWN0aW9uQm94Q29sb3IiLCJpc0RhcmsiLCJIb3Jpem9udGFsR3JvdXAiLCJTaG93Q29uZmlybU1vZGFsRXZlbnQiLCJMYXllckVsZW1lbnRMaXN0RWRpdG9yIiwibmV3RWxlbWVudE9wdGlvbnMiLCJuZXdFbGVtZW50IiwiZGVzdGluYXRpb24iLCJjb3VudCIsInNyYyIsInNvdXJjZSIsImluZGV4IiwiZHN0IiwiZGVsZXRlRnJhbWUiLCJwdWJsaXNoIiwidGV4dDIiLCJjb25maXJtVGV4dCIsInllc1RleHQiLCJvbkNvbmZpcm0iLCJkZWNvdXBsZUZyYW1lIiwiZ29VcExheWVyIiwid2FybiIsImljb24iLCJuYW1lVG9WZXJpZnkiLCJjYW5SZW5hbWUiLCJvbkRlY291cGxlRnJhbWUiLCJvbkRlbGV0ZUZyYW1lIiwib25BZGRJdGVtIiwic2VsZWN0T3B0aW9ucyIsIm9uQ2xlYXJTZWxlY3Rpb24iLCJmZWF0dXJlVG9nZ2xlcyIsImNhbnZhc1BhbmVsTmVzdGluZyIsIm9uRnJhbWVTZWxlY3Rpb24iLCJGaWVsZCIsIlNlbGVjdCIsIlZlcnRpY2FsR3JvdXAiLCJOdW1iZXJJbnB1dCIsIlF1aWNrUG9zaXRpb25pbmciLCJwbGFjZXMiLCJob3Jpem9udGFsT3B0aW9ucyIsInZlcnRpY2FsT3B0aW9ucyIsIlBsYWNlbWVudEVkaXRvciIsImxheW91dCIsInJlc2VsZWN0RWxlbWVudEFmdGVyQ2hhbmdlIiwib25Ib3Jpem9udGFsQ29uc3RyYWludFNlbGVjdCIsIm9uVmVydGljYWxDb25zdHJhaW50U2VsZWN0Iiwib25Qb3NpdGlvbkNoYW5nZSIsInAiLCJvblF1aWNrUG9zaXRpb25pbmdDaGFuZ2UiLCJkZWZhdWx0Q29uc3RyYWludCIsIm9yaWdpbmFsQ29uc3RyYWludCIsImdldFJpZ2h0Qm90dG9tUG9zaXRpb24iLCJWZXJ0aWNhbENlbnRlciIsImdldENlbnRlclBvc2l0aW9uIiwiSG9yaXpvbnRhbENlbnRlciIsImVsZW1lbnRTaXplIiwic2NlbmVTaXplIiwiYnV0dG9uR3JvdXAiLCJidXR0b24iLCJvcHRpb25CdWlsZGVyIiwidmFsdWVzIiwiYnVpbGQiLCJsYXllclR5cGVzIiwiYWRkU2VsZWN0IiwiY3VycmVudE9wdGlvbnMiLCJmbG9vciIsInJhbmRvbSIsImFkZEJhY2tncm91bmQiLCJhZGRCb3JkZXIiLCJQYW5lbFBsdWdpbiIsInBsdWdpbiIsInNldE5vUGFkZGluZyIsInVzZUZpZWxkQ29uZmlnIiwic2V0UGFuZWxPcHRpb25zIiwiYWRkQm9vbGVhblN3aXRjaCJdLCJzb3VyY2VSb290IjoiIn0=