{"ast":null,"code":"import { find, isEqual, omit } from 'lodash';\nimport store from '../store';\nimport { RichHistoryServiceError, RichHistoryStorageWarning } from './RichHistoryStorage';\nimport { fromDTO, toDTO } from './localStorageConverter';\nimport { createRetentionPeriodBoundary, filterAndSortQueries, RICH_HISTORY_SETTING_KEYS } from './richHistoryLocalStorageUtils';\nexport const RICH_HISTORY_KEY = 'grafana.explore.richHistory';\nexport const MAX_HISTORY_ITEMS = 10000;\n\n/**\n * Local storage implementation for Rich History. It keeps all entries in browser's local storage.\n */\nexport default class RichHistoryLocalStorage {\n  /**\n   * Return history entries based on provided filters, perform migration and clean up entries not matching retention policy.\n   */\n  async getRichHistory(filters) {\n    const allQueries = getRichHistoryDTOs().map(fromDTO);\n    const queries = filters.starred ? allQueries.filter(q => q.starred === true) : allQueries;\n    const richHistory = filterAndSortQueries(queries, filters.sortOrder, filters.datasourceFilters, filters.search, [filters.from, filters.to]);\n    return {\n      richHistory,\n      total: richHistory.length\n    };\n  }\n\n  async addToRichHistory(newRichHistoryQuery) {\n    const ts = Date.now();\n    const richHistoryQuery = Object.assign({\n      id: ts.toString(),\n      createdAt: ts\n    }, newRichHistoryQuery);\n    const newRichHistoryQueryDTO = toDTO(richHistoryQuery);\n    const currentRichHistoryDTOs = cleanUp(getRichHistoryDTOs());\n    /* Compare queries of a new query and last saved queries. If they are the same, (except selected properties,\n     * which can be different) don't save it in rich history.\n     */\n\n    const newQueriesToCompare = newRichHistoryQueryDTO.queries.map(q => omit(q, ['key', 'refId']));\n    const lastQueriesToCompare = currentRichHistoryDTOs.length > 0 && currentRichHistoryDTOs[0].queries.map(q => {\n      return omit(q, ['key', 'refId']);\n    });\n\n    if (isEqual(newQueriesToCompare, lastQueriesToCompare)) {\n      const error = new Error('Entry already exists');\n      error.name = RichHistoryServiceError.DuplicatedEntry;\n      throw error;\n    }\n\n    const {\n      queriesToKeep,\n      limitExceeded\n    } = checkLimits(currentRichHistoryDTOs);\n    const updatedHistory = [newRichHistoryQueryDTO, ...queriesToKeep];\n\n    try {\n      store.setObject(RICH_HISTORY_KEY, updatedHistory);\n    } catch (error) {\n      if (error instanceof Error && error.name === 'QuotaExceededError') {\n        throwError(RichHistoryServiceError.StorageFull, `Saving rich history failed: ${error.message}`);\n      } else {\n        throw error;\n      }\n    }\n\n    if (limitExceeded) {\n      return {\n        warning: {\n          type: RichHistoryStorageWarning.LimitExceeded,\n          message: `Query history reached the limit of ${MAX_HISTORY_ITEMS}. Old, not-starred items have been removed.`\n        },\n        richHistoryQuery\n      };\n    }\n\n    return {\n      richHistoryQuery\n    };\n  }\n\n  async deleteAll() {\n    store.delete(RICH_HISTORY_KEY);\n  }\n\n  async deleteRichHistory(id) {\n    const ts = parseInt(id, 10);\n    const richHistory = store.getObject(RICH_HISTORY_KEY, []);\n    const updatedHistory = richHistory.filter(query => query.ts !== ts);\n    store.setObject(RICH_HISTORY_KEY, updatedHistory);\n  }\n\n  async updateStarred(id, starred) {\n    return updateRichHistory(id, richHistoryDTO => richHistoryDTO.starred = starred);\n  }\n\n  async updateComment(id, comment) {\n    return updateRichHistory(id, richHistoryDTO => richHistoryDTO.comment = comment);\n  }\n\n  async getSettings() {\n    return {\n      activeDatasourceOnly: store.getObject(RICH_HISTORY_SETTING_KEYS.activeDatasourceOnly, false),\n      retentionPeriod: store.getObject(RICH_HISTORY_SETTING_KEYS.retentionPeriod, 7),\n      starredTabAsFirstTab: store.getBool(RICH_HISTORY_SETTING_KEYS.starredTabAsFirstTab, false),\n      lastUsedDatasourceFilters: store.getObject(RICH_HISTORY_SETTING_KEYS.datasourceFilters, []).map(selectableValue => selectableValue.value)\n    };\n  }\n\n  async updateSettings(settings) {\n    store.set(RICH_HISTORY_SETTING_KEYS.activeDatasourceOnly, settings.activeDatasourceOnly);\n    store.set(RICH_HISTORY_SETTING_KEYS.retentionPeriod, settings.retentionPeriod);\n    store.set(RICH_HISTORY_SETTING_KEYS.starredTabAsFirstTab, settings.starredTabAsFirstTab);\n    store.setObject(RICH_HISTORY_SETTING_KEYS.datasourceFilters, (settings.lastUsedDatasourceFilters || []).map(datasourceName => {\n      return {\n        value: datasourceName\n      };\n    }));\n  }\n\n}\n\nfunction updateRichHistory(id, updateCallback) {\n  const ts = parseInt(id, 10);\n  const richHistoryDTOs = store.getObject(RICH_HISTORY_KEY, []);\n  const richHistoryDTO = find(richHistoryDTOs, {\n    ts\n  });\n\n  if (!richHistoryDTO) {\n    throw new Error('Rich history item not found.');\n  }\n\n  updateCallback(richHistoryDTO);\n  store.setObject(RICH_HISTORY_KEY, richHistoryDTOs);\n  return fromDTO(richHistoryDTO);\n}\n/**\n * Removes entries that do not match retention policy criteria.\n */\n\n\nfunction cleanUp(richHistory) {\n  const retentionPeriod = store.getObject(RICH_HISTORY_SETTING_KEYS.retentionPeriod, 7);\n  const retentionPeriodLastTs = createRetentionPeriodBoundary(retentionPeriod, false);\n  /* Keep only queries, that are within the selected retention period or that are starred.\n   * If no queries, initialize with empty array\n   */\n\n  return richHistory.filter(q => q.ts > retentionPeriodLastTs || q.starred === true) || [];\n}\n/**\n * Ensures the entry can be added. Throws an error if current limit has been hit.\n * Returns queries that should be saved back giving space for one extra query.\n */\n\n\nfunction checkLimits(queriesToKeep) {\n  // remove oldest non-starred items to give space for the recent query\n  let limitExceeded = false;\n  let current = queriesToKeep.length - 1;\n\n  while (current >= 0 && queriesToKeep.length >= MAX_HISTORY_ITEMS) {\n    if (!queriesToKeep[current].starred) {\n      queriesToKeep.splice(current, 1);\n      limitExceeded = true;\n    }\n\n    current--;\n  }\n\n  return {\n    queriesToKeep,\n    limitExceeded\n  };\n}\n\nfunction getRichHistoryDTOs() {\n  const richHistory = store.getObject(RICH_HISTORY_KEY, []);\n  return migrateRichHistory(richHistory);\n}\n\nfunction migrateRichHistory(richHistory) {\n  const transformedRichHistory = richHistory.map(query => {\n    const transformedQueries = query.queries.map((q, index) => createDataQuery(query, q, index));\n    return Object.assign({}, query, {\n      queries: transformedQueries\n    });\n  });\n  return transformedRichHistory;\n}\n\nfunction createDataQuery(query, individualQuery, index) {\n  const letters = 'ABCDEFGHIJKLMNOPQRSTUVXYZ';\n\n  if (typeof individualQuery === 'object') {\n    // the current format\n    return individualQuery;\n  } else if (isParsable(individualQuery)) {\n    // ElasticSearch (maybe other datasoures too) before grafana7\n    return JSON.parse(individualQuery);\n  } // prometehus (maybe other datasources too) before grafana7\n\n\n  return {\n    expr: individualQuery,\n    refId: letters[index]\n  };\n}\n\nfunction isParsable(string) {\n  try {\n    JSON.parse(string);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction throwError(name, message) {\n  const error = new Error(message);\n  error.name = name;\n  throw error;\n}","map":{"version":3,"names":["find","isEqual","omit","store","RichHistoryServiceError","RichHistoryStorageWarning","fromDTO","toDTO","createRetentionPeriodBoundary","filterAndSortQueries","RICH_HISTORY_SETTING_KEYS","RICH_HISTORY_KEY","MAX_HISTORY_ITEMS","RichHistoryLocalStorage","getRichHistory","filters","allQueries","getRichHistoryDTOs","map","queries","starred","filter","q","richHistory","sortOrder","datasourceFilters","search","from","to","total","length","addToRichHistory","newRichHistoryQuery","ts","Date","now","richHistoryQuery","id","toString","createdAt","newRichHistoryQueryDTO","currentRichHistoryDTOs","cleanUp","newQueriesToCompare","lastQueriesToCompare","error","Error","name","DuplicatedEntry","queriesToKeep","limitExceeded","checkLimits","updatedHistory","setObject","throwError","StorageFull","message","warning","type","LimitExceeded","deleteAll","delete","deleteRichHistory","parseInt","getObject","query","updateStarred","updateRichHistory","richHistoryDTO","updateComment","comment","getSettings","activeDatasourceOnly","retentionPeriod","starredTabAsFirstTab","getBool","lastUsedDatasourceFilters","selectableValue","value","updateSettings","settings","set","datasourceName","updateCallback","richHistoryDTOs","retentionPeriodLastTs","current","splice","migrateRichHistory","transformedRichHistory","transformedQueries","index","createDataQuery","individualQuery","letters","isParsable","JSON","parse","expr","refId","string","e"],"sources":["/home/soula/grafana/public/app/core/history/RichHistoryLocalStorage.ts"],"sourcesContent":["import { find, isEqual, omit } from 'lodash';\n\nimport { DataQuery, SelectableValue } from '@grafana/data';\nimport { RichHistorySearchFilters, RichHistorySettings } from 'app/core/utils/richHistory';\n\nimport { RichHistoryQuery } from '../../types';\nimport store from '../store';\n\nimport RichHistoryStorage, { RichHistoryServiceError, RichHistoryStorageWarning } from './RichHistoryStorage';\nimport { fromDTO, toDTO } from './localStorageConverter';\nimport {\n  createRetentionPeriodBoundary,\n  filterAndSortQueries,\n  RICH_HISTORY_SETTING_KEYS,\n} from './richHistoryLocalStorageUtils';\n\nexport const RICH_HISTORY_KEY = 'grafana.explore.richHistory';\nexport const MAX_HISTORY_ITEMS = 10000;\n\nexport type RichHistoryLocalStorageDTO = {\n  // works as an unique identifier\n  ts: number;\n  datasourceName: string;\n  starred: boolean;\n  comment: string;\n  queries: DataQuery[];\n};\n\n/**\n * Local storage implementation for Rich History. It keeps all entries in browser's local storage.\n */\nexport default class RichHistoryLocalStorage implements RichHistoryStorage {\n  /**\n   * Return history entries based on provided filters, perform migration and clean up entries not matching retention policy.\n   */\n  async getRichHistory(filters: RichHistorySearchFilters) {\n    const allQueries = getRichHistoryDTOs().map(fromDTO);\n    const queries = filters.starred ? allQueries.filter((q) => q.starred === true) : allQueries;\n\n    const richHistory = filterAndSortQueries(queries, filters.sortOrder, filters.datasourceFilters, filters.search, [\n      filters.from,\n      filters.to,\n    ]);\n    return { richHistory, total: richHistory.length };\n  }\n\n  async addToRichHistory(newRichHistoryQuery: Omit<RichHistoryQuery, 'id' | 'createdAt'>) {\n    const ts = Date.now();\n    const richHistoryQuery = {\n      id: ts.toString(),\n      createdAt: ts,\n      ...newRichHistoryQuery,\n    };\n\n    const newRichHistoryQueryDTO = toDTO(richHistoryQuery);\n    const currentRichHistoryDTOs = cleanUp(getRichHistoryDTOs());\n\n    /* Compare queries of a new query and last saved queries. If they are the same, (except selected properties,\n     * which can be different) don't save it in rich history.\n     */\n    const newQueriesToCompare = newRichHistoryQueryDTO.queries.map((q) => omit(q, ['key', 'refId']));\n    const lastQueriesToCompare =\n      currentRichHistoryDTOs.length > 0 &&\n      currentRichHistoryDTOs[0].queries.map((q) => {\n        return omit(q, ['key', 'refId']);\n      });\n\n    if (isEqual(newQueriesToCompare, lastQueriesToCompare)) {\n      const error = new Error('Entry already exists');\n      error.name = RichHistoryServiceError.DuplicatedEntry;\n      throw error;\n    }\n\n    const { queriesToKeep, limitExceeded } = checkLimits(currentRichHistoryDTOs);\n\n    const updatedHistory: RichHistoryLocalStorageDTO[] = [newRichHistoryQueryDTO, ...queriesToKeep];\n\n    try {\n      store.setObject(RICH_HISTORY_KEY, updatedHistory);\n    } catch (error) {\n      if (error instanceof Error && error.name === 'QuotaExceededError') {\n        throwError(RichHistoryServiceError.StorageFull, `Saving rich history failed: ${error.message}`);\n      } else {\n        throw error;\n      }\n    }\n\n    if (limitExceeded) {\n      return {\n        warning: {\n          type: RichHistoryStorageWarning.LimitExceeded,\n          message: `Query history reached the limit of ${MAX_HISTORY_ITEMS}. Old, not-starred items have been removed.`,\n        },\n        richHistoryQuery,\n      };\n    }\n\n    return { richHistoryQuery };\n  }\n\n  async deleteAll() {\n    store.delete(RICH_HISTORY_KEY);\n  }\n\n  async deleteRichHistory(id: string) {\n    const ts = parseInt(id, 10);\n    const richHistory: RichHistoryLocalStorageDTO[] = store.getObject(RICH_HISTORY_KEY, []);\n    const updatedHistory = richHistory.filter((query) => query.ts !== ts);\n    store.setObject(RICH_HISTORY_KEY, updatedHistory);\n  }\n\n  async updateStarred(id: string, starred: boolean) {\n    return updateRichHistory(id, (richHistoryDTO) => (richHistoryDTO.starred = starred));\n  }\n\n  async updateComment(id: string, comment: string) {\n    return updateRichHistory(id, (richHistoryDTO) => (richHistoryDTO.comment = comment));\n  }\n\n  async getSettings() {\n    return {\n      activeDatasourceOnly: store.getObject(RICH_HISTORY_SETTING_KEYS.activeDatasourceOnly, false),\n      retentionPeriod: store.getObject(RICH_HISTORY_SETTING_KEYS.retentionPeriod, 7),\n      starredTabAsFirstTab: store.getBool(RICH_HISTORY_SETTING_KEYS.starredTabAsFirstTab, false),\n      lastUsedDatasourceFilters: store\n        .getObject(RICH_HISTORY_SETTING_KEYS.datasourceFilters, [])\n        .map((selectableValue: SelectableValue) => selectableValue.value),\n    };\n  }\n\n  async updateSettings(settings: RichHistorySettings) {\n    store.set(RICH_HISTORY_SETTING_KEYS.activeDatasourceOnly, settings.activeDatasourceOnly);\n    store.set(RICH_HISTORY_SETTING_KEYS.retentionPeriod, settings.retentionPeriod);\n    store.set(RICH_HISTORY_SETTING_KEYS.starredTabAsFirstTab, settings.starredTabAsFirstTab);\n    store.setObject(\n      RICH_HISTORY_SETTING_KEYS.datasourceFilters,\n      (settings.lastUsedDatasourceFilters || []).map((datasourceName: string) => {\n        return { value: datasourceName };\n      })\n    );\n  }\n}\n\nfunction updateRichHistory(\n  id: string,\n  updateCallback: (richHistoryDTO: RichHistoryLocalStorageDTO) => void\n): RichHistoryQuery {\n  const ts = parseInt(id, 10);\n  const richHistoryDTOs: RichHistoryLocalStorageDTO[] = store.getObject(RICH_HISTORY_KEY, []);\n  const richHistoryDTO = find(richHistoryDTOs, { ts });\n\n  if (!richHistoryDTO) {\n    throw new Error('Rich history item not found.');\n  }\n\n  updateCallback(richHistoryDTO);\n\n  store.setObject(RICH_HISTORY_KEY, richHistoryDTOs);\n  return fromDTO(richHistoryDTO);\n}\n\n/**\n * Removes entries that do not match retention policy criteria.\n */\nfunction cleanUp(richHistory: RichHistoryLocalStorageDTO[]): RichHistoryLocalStorageDTO[] {\n  const retentionPeriod: number = store.getObject(RICH_HISTORY_SETTING_KEYS.retentionPeriod, 7);\n  const retentionPeriodLastTs = createRetentionPeriodBoundary(retentionPeriod, false);\n\n  /* Keep only queries, that are within the selected retention period or that are starred.\n   * If no queries, initialize with empty array\n   */\n  return richHistory.filter((q) => q.ts > retentionPeriodLastTs || q.starred === true) || [];\n}\n\n/**\n * Ensures the entry can be added. Throws an error if current limit has been hit.\n * Returns queries that should be saved back giving space for one extra query.\n */\nfunction checkLimits(queriesToKeep: RichHistoryLocalStorageDTO[]): {\n  queriesToKeep: RichHistoryLocalStorageDTO[];\n  limitExceeded: boolean;\n} {\n  // remove oldest non-starred items to give space for the recent query\n  let limitExceeded = false;\n  let current = queriesToKeep.length - 1;\n  while (current >= 0 && queriesToKeep.length >= MAX_HISTORY_ITEMS) {\n    if (!queriesToKeep[current].starred) {\n      queriesToKeep.splice(current, 1);\n      limitExceeded = true;\n    }\n    current--;\n  }\n\n  return { queriesToKeep, limitExceeded };\n}\n\nfunction getRichHistoryDTOs(): RichHistoryLocalStorageDTO[] {\n  const richHistory: RichHistoryLocalStorageDTO[] = store.getObject(RICH_HISTORY_KEY, []);\n  return migrateRichHistory(richHistory);\n}\n\nfunction migrateRichHistory(richHistory: RichHistoryLocalStorageDTO[]): RichHistoryLocalStorageDTO[] {\n  const transformedRichHistory = richHistory.map((query) => {\n    const transformedQueries: DataQuery[] = query.queries.map((q, index) => createDataQuery(query, q, index));\n    return { ...query, queries: transformedQueries };\n  });\n\n  return transformedRichHistory;\n}\n\nfunction createDataQuery(query: RichHistoryLocalStorageDTO, individualQuery: DataQuery | string, index: number) {\n  const letters = 'ABCDEFGHIJKLMNOPQRSTUVXYZ';\n  if (typeof individualQuery === 'object') {\n    // the current format\n    return individualQuery;\n  } else if (isParsable(individualQuery)) {\n    // ElasticSearch (maybe other datasoures too) before grafana7\n    return JSON.parse(individualQuery);\n  }\n  // prometehus (maybe other datasources too) before grafana7\n  return { expr: individualQuery, refId: letters[index] };\n}\n\nfunction isParsable(string: string) {\n  try {\n    JSON.parse(string);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n\nfunction throwError(name: string, message: string) {\n  const error = new Error(message);\n  error.name = name;\n  throw error;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}