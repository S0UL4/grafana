{"ast":null,"code":"const _excluded = [\"__interval\", \"__interval_ms\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Libraries\nimport { cloneDeep, map as lodashMap } from 'lodash';\nimport Prism from 'prismjs';\nimport { lastValueFrom, merge, of, throwError } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators'; // Types\n\nimport { CoreApp, DataFrameView, dateMath, FieldCache, FieldType, getLogLevelFromKey, LoadingState, LogLevel, rangeUtil, toUtc } from '@grafana/data';\nimport { config, DataSourceWithBackend } from '@grafana/runtime';\nimport { queryLogsVolume } from 'app/core/logs_model';\nimport { convertToWebSocketUrl } from 'app/core/utils/explore';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { getTemplateSrv } from 'app/features/templating/template_srv';\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { renderLegendFormat } from '../prometheus/legend';\nimport { addLabelToQuery } from './add_label_to_query';\nimport { transformBackendResult } from './backendResultTransformer';\nimport { LokiAnnotationsQueryEditor } from './components/AnnotationsQueryEditor';\nimport LanguageProvider from './language_provider';\nimport { escapeLabelValueInSelector } from './language_utils';\nimport { LiveStreams } from './live_streams';\nimport { getNormalizedLokiQuery } from './query_utils';\nimport { sortDataFrameByTime } from './sortDataFrame';\nimport { doLokiChannelStream } from './streaming';\nimport syntax from './syntax';\nimport { LokiQueryDirection, LokiQueryType } from './types';\nexport const DEFAULT_MAX_LINES = 1000;\nexport const LOKI_ENDPOINT = '/loki/api/v1';\nconst NS_IN_MS = 1000000;\n\nfunction makeRequest(query, range, app, requestId) {\n  const intervalInfo = rangeUtil.calculateInterval(range, 1);\n  return {\n    targets: [query],\n    requestId,\n    interval: intervalInfo.interval,\n    intervalMs: intervalInfo.intervalMs,\n    range: range,\n    scopedVars: {},\n    timezone: 'UTC',\n    app,\n    startTime: Date.now()\n  };\n}\n\nexport class LokiDatasource extends DataSourceWithBackend {\n  constructor(instanceSettings, templateSrv = getTemplateSrv(), timeSrv = getTimeSrv()) {\n    var _settingsData$maxLine;\n\n    super(instanceSettings);\n\n    _defineProperty(this, \"streams\", new LiveStreams());\n\n    _defineProperty(this, \"languageProvider\", void 0);\n\n    _defineProperty(this, \"maxLines\", void 0);\n\n    _defineProperty(this, \"runLiveQuery\", (target, maxDataPoints) => {\n      const liveTarget = this.createLiveTarget(target, maxDataPoints);\n      return this.streams.getStream(liveTarget).pipe(map(data => ({\n        data: data || [],\n        key: `loki-${liveTarget.refId}`,\n        state: LoadingState.Streaming\n      })), catchError(err => {\n        return throwError(() => `Live tailing was stopped due to following error: ${err.reason}`);\n      }));\n    });\n\n    _defineProperty(this, \"getLogRowContext\", (row, options) => {\n      const direction = options && options.direction || 'BACKWARD';\n      const limit = options && options.limit || 10;\n      const {\n        query,\n        range\n      } = this.prepareLogRowContextQueryTarget(row, limit, direction);\n\n      const processDataFrame = frame => {\n        // log-row-context requires specific field-names to work, so we set them here: \"ts\", \"line\", \"id\"\n        const cache = new FieldCache(frame);\n        const timestampField = cache.getFirstFieldOfType(FieldType.time);\n        const lineField = cache.getFirstFieldOfType(FieldType.string);\n        const idField = cache.getFieldByName('id');\n\n        if (timestampField === undefined || lineField === undefined || idField === undefined) {\n          // this should never really happen, but i want to keep typescript happy\n          return Object.assign({}, frame, {\n            fields: []\n          });\n        }\n\n        return Object.assign({}, frame, {\n          fields: [Object.assign({}, timestampField, {\n            name: 'ts'\n          }), Object.assign({}, lineField, {\n            name: 'line'\n          }), Object.assign({}, idField, {\n            name: 'id'\n          })]\n        });\n      };\n\n      const processResults = result => {\n        const frames = result.data;\n        const processedFrames = frames.map(frame => sortDataFrameByTime(frame, 'DESCENDING')).map(frame => processDataFrame(frame)); // rename fields if needed\n\n        return Object.assign({}, result, {\n          data: processedFrames\n        });\n      }; // this can only be called from explore currently\n\n\n      const app = CoreApp.Explore;\n      return lastValueFrom(this.query(makeRequest(query, range, app, `log-row-context-query-${direction}`)).pipe(catchError(err => {\n        const error = {\n          message: 'Error during context query. Please check JS console logs.',\n          status: err.status,\n          statusText: err.statusText\n        };\n        throw error;\n      }), switchMap(res => of(processResults(res)))));\n    });\n\n    _defineProperty(this, \"prepareLogRowContextQueryTarget\", (row, limit, direction) => {\n      const labels = this.languageProvider.getLabelKeys();\n      const expr = Object.keys(row.labels).map(label => {\n        if (labels.includes(label)) {\n          // escape backslashes in label as users can't escape them by themselves\n          return `${label}=\"${row.labels[label].replace(/\\\\/g, '\\\\\\\\')}\"`;\n        }\n\n        return '';\n      }) // Filter empty strings\n      .filter(label => !!label).join(',');\n      const contextTimeBuffer = 2 * 60 * 60 * 1000; // 2h buffer\n\n      const queryDirection = direction === 'FORWARD' ? LokiQueryDirection.Forward : LokiQueryDirection.Backward;\n      const query = {\n        expr: `{${expr}}`,\n        queryType: LokiQueryType.Range,\n        refId: '',\n        maxLines: limit,\n        direction: queryDirection\n      };\n      const fieldCache = new FieldCache(row.dataFrame);\n      const tsField = fieldCache.getFirstFieldOfType(FieldType.time);\n\n      if (tsField === undefined) {\n        throw new Error('loki: dataframe missing time-field, should never happen');\n      }\n\n      const tsValue = tsField.values.get(row.rowIndex);\n      const timestamp = toUtc(tsValue);\n      const range = queryDirection === LokiQueryDirection.Forward ? {\n        // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from\n        // and any other that were logged in the same ns but before the row. Right now these rows will be lost\n        // because the are before but came it he response that should return only rows after.\n        from: timestamp,\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        to: toUtc(row.timeEpochMs + contextTimeBuffer)\n      } : {\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        from: toUtc(row.timeEpochMs - contextTimeBuffer),\n        to: timestamp\n      };\n      return {\n        query,\n        range: {\n          from: range.from,\n          to: range.to,\n          raw: range\n        }\n      };\n    });\n\n    this.instanceSettings = instanceSettings;\n    this.templateSrv = templateSrv;\n    this.timeSrv = timeSrv;\n    this.languageProvider = new LanguageProvider(this);\n    const settingsData = instanceSettings.jsonData || {};\n    this.maxLines = parseInt((_settingsData$maxLine = settingsData.maxLines) !== null && _settingsData$maxLine !== void 0 ? _settingsData$maxLine : '0', 10) || DEFAULT_MAX_LINES;\n    this.annotations = {\n      QueryEditor: LokiAnnotationsQueryEditor\n    };\n  }\n\n  getLogsVolumeDataProvider(request) {\n    const isQuerySuitable = query => {\n      const normalized = getNormalizedLokiQuery(query);\n      const {\n        expr\n      } = normalized; // it has to be a logs-producing range-query\n\n      return expr && !isMetricsQuery(expr) && normalized.queryType === LokiQueryType.Range;\n    };\n\n    const isLogsVolumeAvailable = request.targets.some(isQuerySuitable);\n\n    if (!isLogsVolumeAvailable) {\n      return undefined;\n    }\n\n    const logsVolumeRequest = cloneDeep(request);\n    logsVolumeRequest.targets = logsVolumeRequest.targets.filter(isQuerySuitable).map(target => {\n      return Object.assign({}, target, {\n        instant: false,\n        volumeQuery: true,\n        expr: `sum by (level) (count_over_time(${target.expr}[$__interval]))`\n      });\n    });\n    return queryLogsVolume(this, logsVolumeRequest, {\n      extractLevel,\n      range: request.range,\n      targets: request.targets\n    });\n  }\n\n  query(request) {\n    var _fixedRequest$rangeRa;\n\n    const queries = request.targets.map(getNormalizedLokiQuery) // \"fix\" the `.queryType` prop\n    .map(q => Object.assign({}, q, {\n      maxLines: q.maxLines || this.maxLines\n    })); // set maxLines if not set\n\n    const fixedRequest = Object.assign({}, request, {\n      targets: queries\n    });\n    const streamQueries = fixedRequest.targets.filter(q => q.queryType === LokiQueryType.Stream);\n\n    if (config.featureToggles.lokiLive && streamQueries.length > 0 && ((_fixedRequest$rangeRa = fixedRequest.rangeRaw) === null || _fixedRequest$rangeRa === void 0 ? void 0 : _fixedRequest$rangeRa.to) === 'now') {\n      // this is still an in-development feature,\n      // we do not support mixing stream-queries with normal-queries for now.\n      const streamRequest = Object.assign({}, fixedRequest, {\n        targets: streamQueries\n      });\n      return merge(...streamQueries.map(q => doLokiChannelStream(q, this, streamRequest)));\n    }\n\n    if (fixedRequest.liveStreaming) {\n      return this.runLiveQueryThroughBackend(fixedRequest);\n    } else {\n      return super.query(fixedRequest).pipe(map(response => {\n        var _this$instanceSetting;\n\n        return transformBackendResult(response, fixedRequest.targets, (_this$instanceSetting = this.instanceSettings.jsonData.derivedFields) !== null && _this$instanceSetting !== void 0 ? _this$instanceSetting : []);\n      }));\n    }\n  }\n\n  runLiveQueryThroughBackend(request) {\n    // this only works in explore-mode, so variables don't need to be handled,\n    //  and only for logs-queries, not metric queries\n    const logsQueries = request.targets.filter(query => query.expr !== '' && !isMetricsQuery(query.expr));\n\n    if (logsQueries.length === 0) {\n      return of({\n        data: [],\n        state: LoadingState.Done\n      });\n    }\n\n    const subQueries = logsQueries.map(query => {\n      const maxDataPoints = query.maxLines || this.maxLines; // FIXME: currently we are running it through the frontend still.\n\n      return this.runLiveQuery(query, maxDataPoints);\n    });\n    return merge(...subQueries);\n  }\n\n  createLiveTarget(target, maxDataPoints) {\n    const query = target.expr;\n    const baseUrl = this.instanceSettings.url;\n    const params = serializeParams({\n      query\n    });\n    return {\n      query,\n      url: convertToWebSocketUrl(`${baseUrl}/loki/api/v1/tail?${params}`),\n      refId: target.refId,\n      size: maxDataPoints\n    };\n  }\n  /**\n   * Runs live queries which in this case means creating a websocket and listening on it for new logs.\n   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple\n   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique\n   * labels per row.\n   */\n\n\n  getRangeScopedVars(range = this.timeSrv.timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: {\n        text: msRange,\n        value: msRange\n      },\n      __range_s: {\n        text: sRange,\n        value: sRange\n      },\n      __range: {\n        text: sRange + 's',\n        value: sRange + 's'\n      }\n    };\n  }\n\n  interpolateVariablesInQueries(queries, scopedVars) {\n    let expandedQueries = queries;\n\n    if (queries && queries.length) {\n      expandedQueries = queries.map(query => Object.assign({}, query, {\n        datasource: this.getRef(),\n        expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr)\n      }));\n    }\n\n    return expandedQueries;\n  }\n\n  getQueryDisplayText(query) {\n    return query.expr;\n  }\n\n  getTimeRangeParams() {\n    const timeRange = this.timeSrv.timeRange();\n    return {\n      start: timeRange.from.valueOf() * NS_IN_MS,\n      end: timeRange.to.valueOf() * NS_IN_MS\n    };\n  }\n\n  async importFromAbstractQueries(abstractQueries) {\n    await this.languageProvider.start();\n    const existingKeys = this.languageProvider.labelKeys;\n\n    if (existingKeys && existingKeys.length) {\n      abstractQueries = abstractQueries.map(abstractQuery => {\n        abstractQuery.labelMatchers = abstractQuery.labelMatchers.filter(labelMatcher => {\n          return existingKeys.includes(labelMatcher.name);\n        });\n        return abstractQuery;\n      });\n    }\n\n    return abstractQueries.map(abstractQuery => this.languageProvider.importFromAbstractQuery(abstractQuery));\n  }\n\n  async exportToAbstractQueries(queries) {\n    return queries.map(query => this.languageProvider.exportToAbstractQuery(query));\n  }\n\n  async metadataRequest(url, params) {\n    // url must not start with a `/`, otherwise the AJAX-request\n    // going from the browser will contain `//`, which can cause problems.\n    if (url.startsWith('/')) {\n      throw new Error(`invalid metadata request url: ${url}`);\n    }\n\n    const res = await this.getResource(url, params);\n    return res.data || [];\n  }\n\n  async metricFindQuery(query) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const interpolated = this.templateSrv.replace(query, {}, this.interpolateQueryExpr);\n    return await this.processMetricFindQuery(interpolated);\n  }\n\n  async processMetricFindQuery(query) {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n    const labelNames = query.match(labelNamesRegex);\n\n    if (labelNames) {\n      return await this.labelNamesQuery();\n    }\n\n    const labelValues = query.match(labelValuesRegex);\n\n    if (labelValues) {\n      // If we have query expr, use /series endpoint\n      if (labelValues[1]) {\n        return await this.labelValuesSeriesQuery(labelValues[1], labelValues[2]);\n      }\n\n      return await this.labelValuesQuery(labelValues[2]);\n    }\n\n    return Promise.resolve([]);\n  }\n\n  async labelNamesQuery() {\n    const url = 'labels';\n    const params = this.getTimeRangeParams();\n    const result = await this.metadataRequest(url, params);\n    return result.map(value => ({\n      text: value\n    }));\n  }\n\n  async labelValuesQuery(label) {\n    const params = this.getTimeRangeParams();\n    const url = `label/${label}/values`;\n    const result = await this.metadataRequest(url, params);\n    return result.map(value => ({\n      text: value\n    }));\n  }\n\n  async labelValuesSeriesQuery(expr, label) {\n    const timeParams = this.getTimeRangeParams();\n    const params = Object.assign({}, timeParams, {\n      'match[]': expr\n    });\n    const url = 'series';\n    const streams = new Set();\n    const result = await this.metadataRequest(url, params);\n    result.forEach(stream => {\n      if (stream[label]) {\n        streams.add({\n          text: stream[label]\n        });\n      }\n    });\n    return Array.from(streams);\n  } // By implementing getTagKeys and getTagValues we add ad-hoc filtters functionality\n\n\n  async getTagKeys() {\n    return await this.labelNamesQuery();\n  }\n\n  async getTagValues(options = {}) {\n    return await this.labelValuesQuery(options.key);\n  }\n\n  interpolateQueryExpr(value, variable) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return lokiRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return lokiSpecialRegexEscape(value);\n    }\n\n    const escapedValues = lodashMap(value, lokiSpecialRegexEscape);\n    return escapedValues.join('|');\n  }\n\n  modifyQuery(query, action) {\n    var _query$expr;\n\n    let expression = (_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : '';\n\n    switch (action.type) {\n      case 'ADD_FILTER':\n        {\n          expression = this.addLabelToQuery(expression, action.key, '=', action.value);\n          break;\n        }\n\n      case 'ADD_FILTER_OUT':\n        {\n          expression = this.addLabelToQuery(expression, action.key, '!=', action.value);\n          break;\n        }\n\n      default:\n        break;\n    }\n\n    return Object.assign({}, query, {\n      expr: expression\n    });\n  }\n\n  getTime(date, roundUp) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp);\n    }\n\n    return Math.ceil(date.valueOf() * 1e6);\n  }\n\n  testDatasource() {\n    // Consider only last 10 minutes otherwise request takes too long\n    const nowMs = Date.now();\n    const params = {\n      start: (nowMs - 10 * 60 * 1000) * NS_IN_MS,\n      end: nowMs * NS_IN_MS\n    };\n    return this.metadataRequest('labels', params).then(values => {\n      return values.length > 0 ? {\n        status: 'success',\n        message: 'Data source connected and labels found.'\n      } : {\n        status: 'error',\n        message: 'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.'\n      };\n    }, err => {\n      var _err$data$message, _err$data;\n\n      // we did a resource-call that failed.\n      // the only info we have, if exists, is err.data.message\n      // (when in development-mode, err.data.error exists too, but not in production-mode)\n      // things like err.status & err.statusText does not help,\n      // because those will only describe how the request between browser<>server failed\n      const info = (_err$data$message = err === null || err === void 0 ? void 0 : (_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.message) !== null && _err$data$message !== void 0 ? _err$data$message : '';\n      const infoInParentheses = info !== '' ? ` (${info})` : '';\n      const message = `Unable to fetch labels from Loki${infoInParentheses}, please check the server logs for more details`;\n      return {\n        status: 'error',\n        message: message\n      };\n    });\n  }\n\n  async annotationQuery(options) {\n    const {\n      expr,\n      maxLines,\n      instant,\n      tagKeys = '',\n      titleFormat = '',\n      textFormat = ''\n    } = options.annotation;\n\n    if (!expr) {\n      return [];\n    }\n\n    const id = `annotation-${options.annotation.name}`;\n    const query = {\n      refId: id,\n      expr,\n      maxLines,\n      instant,\n      queryType: instant ? LokiQueryType.Instant : LokiQueryType.Range\n    };\n    const request = makeRequest(query, options.range, CoreApp.Dashboard, id);\n    const {\n      data\n    } = await lastValueFrom(this.query(request));\n    const annotations = [];\n    const splitKeys = tagKeys.split(',').filter(v => v !== '');\n\n    for (const frame of data) {\n      const view = new DataFrameView(frame);\n      view.forEach(row => {\n        const {\n          labels\n        } = row;\n        const maybeDuplicatedTags = Object.entries(labels).map(([key, val]) => [key, val.trim()]) // trim all label-values\n        .filter(([key, val]) => {\n          if (val === '') {\n            // remove empty\n            return false;\n          } // if tags are specified, remove label if does not match tags\n\n\n          if (splitKeys.length && !splitKeys.includes(key)) {\n            return false;\n          }\n\n          return true;\n        }).map(([key, val]) => val); // keep only the label-value\n        // remove duplicates\n\n        const tags = Array.from(new Set(maybeDuplicatedTags));\n        annotations.push({\n          time: new Date(row.Time).valueOf(),\n          title: renderLegendFormat(titleFormat, labels),\n          text: renderLegendFormat(textFormat, labels) || row.Line,\n          tags\n        });\n      });\n    }\n\n    return annotations;\n  }\n\n  showContextToggle(row) {\n    return (row && row.searchWords && row.searchWords.length > 0) === true;\n  }\n\n  processError(err, target) {\n    let error = cloneDeep(err);\n    error.refId = target.refId;\n\n    if (error.data && err.data.message.includes('escape') && target.expr.includes('\\\\')) {\n      error.data.message = `Error: ${err.data.message}. Make sure that all special characters are escaped with \\\\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`;\n    }\n\n    return error;\n  }\n\n  addAdHocFilters(queryExpr) {\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    let expr = queryExpr;\n    expr = adhocFilters.reduce((acc, filter) => {\n      const {\n        key,\n        operator,\n        value\n      } = filter;\n      return this.addLabelToQuery(acc, key, operator, value);\n    }, expr);\n    return expr;\n  }\n\n  addLabelToQuery(queryExpr, key, operator, value) {\n    const escapedValue = escapeLabelValueInSelector(value, operator);\n    return addLabelToQuery(queryExpr, key, operator, escapedValue);\n  } // Used when running queries through backend\n\n\n  filterQuery(query) {\n    if (query.hide || query.expr === '') {\n      return false;\n    }\n\n    return true;\n  } // Used when running queries through backend\n\n\n  applyTemplateVariables(target, scopedVars) {\n    // We want to interpolate these variables on backend\n    const rest = _objectWithoutPropertiesLoose(scopedVars, _excluded);\n\n    const exprWithAdHoc = this.addAdHocFilters(target.expr);\n    return Object.assign({}, target, {\n      legendFormat: this.templateSrv.replace(target.legendFormat, rest),\n      expr: this.templateSrv.replace(exprWithAdHoc, rest, this.interpolateQueryExpr)\n    });\n  }\n\n  interpolateString(string) {\n    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);\n  }\n\n  getVariables() {\n    return this.templateSrv.getVariables().map(v => `$${v.name}`);\n  }\n\n}\nexport function lokiRegularEscape(value) {\n  if (typeof value === 'string') {\n    return value.replace(/'/g, \"\\\\\\\\'\");\n  }\n\n  return value;\n}\nexport function lokiSpecialRegexEscape(value) {\n  if (typeof value === 'string') {\n    return lokiRegularEscape(value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]+?.()|]/g, '\\\\\\\\$&'));\n  }\n\n  return value;\n}\n/**\n * Checks if the query expression uses function and so should return a time series instead of logs.\n * Sometimes important to know that before we actually do the query.\n */\n\nexport function isMetricsQuery(query) {\n  if (!query) {\n    return false;\n  }\n\n  const tokens = Prism.tokenize(query, syntax);\n  return tokens.some(t => {\n    // Not sure in which cases it can be string maybe if nothing matched which means it should not be a function\n    return typeof t !== 'string' && t.type === 'function';\n  });\n}\n\nfunction extractLevel(dataFrame) {\n  var _valueField;\n\n  let valueField;\n\n  try {\n    valueField = new FieldCache(dataFrame).getFirstFieldOfType(FieldType.number);\n  } catch {}\n\n  return (_valueField = valueField) !== null && _valueField !== void 0 && _valueField.labels ? getLogLevelFromLabels(valueField.labels) : LogLevel.unknown;\n}\n\nfunction getLogLevelFromLabels(labels) {\n  const labelNames = ['level', 'lvl', 'loglevel'];\n  let levelLabel;\n\n  for (let labelName of labelNames) {\n    if (labelName in labels) {\n      levelLabel = labelName;\n      break;\n    }\n  }\n\n  return levelLabel ? getLogLevelFromKey(labels[levelLabel]) : LogLevel.unknown;\n}","map":{"version":3,"names":["cloneDeep","map","lodashMap","Prism","lastValueFrom","merge","of","throwError","catchError","switchMap","CoreApp","DataFrameView","dateMath","FieldCache","FieldType","getLogLevelFromKey","LoadingState","LogLevel","rangeUtil","toUtc","config","DataSourceWithBackend","queryLogsVolume","convertToWebSocketUrl","getTimeSrv","getTemplateSrv","serializeParams","renderLegendFormat","addLabelToQuery","transformBackendResult","LokiAnnotationsQueryEditor","LanguageProvider","escapeLabelValueInSelector","LiveStreams","getNormalizedLokiQuery","sortDataFrameByTime","doLokiChannelStream","syntax","LokiQueryDirection","LokiQueryType","DEFAULT_MAX_LINES","LOKI_ENDPOINT","NS_IN_MS","makeRequest","query","range","app","requestId","intervalInfo","calculateInterval","targets","interval","intervalMs","scopedVars","timezone","startTime","Date","now","LokiDatasource","constructor","instanceSettings","templateSrv","timeSrv","target","maxDataPoints","liveTarget","createLiveTarget","streams","getStream","pipe","data","key","refId","state","Streaming","err","reason","row","options","direction","limit","prepareLogRowContextQueryTarget","processDataFrame","frame","cache","timestampField","getFirstFieldOfType","time","lineField","string","idField","getFieldByName","undefined","fields","name","processResults","result","frames","processedFrames","Explore","error","message","status","statusText","res","labels","languageProvider","getLabelKeys","expr","Object","keys","label","includes","replace","filter","join","contextTimeBuffer","queryDirection","Forward","Backward","queryType","Range","maxLines","fieldCache","dataFrame","tsField","Error","tsValue","values","get","rowIndex","timestamp","from","to","timeEpochMs","raw","settingsData","jsonData","parseInt","annotations","QueryEditor","getLogsVolumeDataProvider","request","isQuerySuitable","normalized","isMetricsQuery","isLogsVolumeAvailable","some","logsVolumeRequest","instant","volumeQuery","extractLevel","queries","q","fixedRequest","streamQueries","Stream","featureToggles","lokiLive","length","rangeRaw","streamRequest","liveStreaming","runLiveQueryThroughBackend","response","derivedFields","logsQueries","Done","subQueries","runLiveQuery","baseUrl","url","params","size","getRangeScopedVars","timeRange","msRange","diff","sRange","Math","round","__range_ms","text","value","__range_s","__range","interpolateVariablesInQueries","expandedQueries","datasource","getRef","interpolateQueryExpr","getQueryDisplayText","getTimeRangeParams","start","valueOf","end","importFromAbstractQueries","abstractQueries","existingKeys","labelKeys","abstractQuery","labelMatchers","labelMatcher","importFromAbstractQuery","exportToAbstractQueries","exportToAbstractQuery","metadataRequest","startsWith","getResource","metricFindQuery","Promise","resolve","interpolated","processMetricFindQuery","labelNamesRegex","labelValuesRegex","labelNames","match","labelNamesQuery","labelValues","labelValuesSeriesQuery","labelValuesQuery","timeParams","Set","forEach","stream","add","Array","getTagKeys","getTagValues","variable","multi","includeAll","lokiRegularEscape","lokiSpecialRegexEscape","escapedValues","modifyQuery","action","expression","type","getTime","date","roundUp","parse","ceil","testDatasource","nowMs","then","info","infoInParentheses","annotationQuery","tagKeys","titleFormat","textFormat","annotation","id","Instant","Dashboard","splitKeys","split","v","view","maybeDuplicatedTags","entries","val","trim","tags","push","Time","title","Line","showContextToggle","searchWords","processError","addAdHocFilters","queryExpr","adhocFilters","getAdhocFilters","reduce","acc","operator","escapedValue","filterQuery","hide","applyTemplateVariables","rest","exprWithAdHoc","legendFormat","interpolateString","getVariables","tokens","tokenize","t","valueField","number","getLogLevelFromLabels","unknown","levelLabel","labelName"],"sources":["/home/soula/grafana/public/app/plugins/datasource/loki/datasource.ts"],"sourcesContent":["// Libraries\nimport { cloneDeep, map as lodashMap } from 'lodash';\nimport Prism from 'prismjs';\nimport { lastValueFrom, merge, Observable, of, throwError } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\n\n// Types\nimport {\n  AnnotationEvent,\n  AnnotationQueryRequest,\n  CoreApp,\n  DataFrame,\n  DataFrameView,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n  DataSourceWithLogsContextSupport,\n  DataSourceWithLogsVolumeSupport,\n  DataSourceWithQueryExportSupport,\n  DataSourceWithQueryImportSupport,\n  dateMath,\n  DateTime,\n  FieldCache,\n  AbstractQuery,\n  FieldType,\n  getLogLevelFromKey,\n  Labels,\n  LoadingState,\n  LogLevel,\n  LogRowModel,\n  ScopedVars,\n  TimeRange,\n  rangeUtil,\n  toUtc,\n} from '@grafana/data';\nimport { FetchError, config, DataSourceWithBackend } from '@grafana/runtime';\nimport { RowContextOptions } from '@grafana/ui/src/components/Logs/LogRowContextProvider';\nimport { queryLogsVolume } from 'app/core/logs_model';\nimport { convertToWebSocketUrl } from 'app/core/utils/explore';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\n\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { renderLegendFormat } from '../prometheus/legend';\n\nimport { addLabelToQuery } from './add_label_to_query';\nimport { transformBackendResult } from './backendResultTransformer';\nimport { LokiAnnotationsQueryEditor } from './components/AnnotationsQueryEditor';\nimport LanguageProvider from './language_provider';\nimport { escapeLabelValueInSelector } from './language_utils';\nimport { LiveStreams, LokiLiveTarget } from './live_streams';\nimport { getNormalizedLokiQuery } from './query_utils';\nimport { sortDataFrameByTime } from './sortDataFrame';\nimport { doLokiChannelStream } from './streaming';\nimport syntax from './syntax';\nimport { LokiOptions, LokiQuery, LokiQueryDirection, LokiQueryType } from './types';\n\nexport type RangeQueryOptions = DataQueryRequest<LokiQuery> | AnnotationQueryRequest<LokiQuery>;\nexport const DEFAULT_MAX_LINES = 1000;\nexport const LOKI_ENDPOINT = '/loki/api/v1';\nconst NS_IN_MS = 1000000;\n\nfunction makeRequest(query: LokiQuery, range: TimeRange, app: CoreApp, requestId: string): DataQueryRequest<LokiQuery> {\n  const intervalInfo = rangeUtil.calculateInterval(range, 1);\n  return {\n    targets: [query],\n    requestId,\n    interval: intervalInfo.interval,\n    intervalMs: intervalInfo.intervalMs,\n    range: range,\n    scopedVars: {},\n    timezone: 'UTC',\n    app,\n    startTime: Date.now(),\n  };\n}\n\nexport class LokiDatasource\n  extends DataSourceWithBackend<LokiQuery, LokiOptions>\n  implements\n    DataSourceWithLogsContextSupport,\n    DataSourceWithLogsVolumeSupport<LokiQuery>,\n    DataSourceWithQueryImportSupport<LokiQuery>,\n    DataSourceWithQueryExportSupport<LokiQuery>\n{\n  private streams = new LiveStreams();\n  languageProvider: LanguageProvider;\n  maxLines: number;\n\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<LokiOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super(instanceSettings);\n\n    this.languageProvider = new LanguageProvider(this);\n    const settingsData = instanceSettings.jsonData || {};\n    this.maxLines = parseInt(settingsData.maxLines ?? '0', 10) || DEFAULT_MAX_LINES;\n    this.annotations = {\n      QueryEditor: LokiAnnotationsQueryEditor,\n    };\n  }\n\n  getLogsVolumeDataProvider(request: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> | undefined {\n    const isQuerySuitable = (query: LokiQuery) => {\n      const normalized = getNormalizedLokiQuery(query);\n      const { expr } = normalized;\n      // it has to be a logs-producing range-query\n      return expr && !isMetricsQuery(expr) && normalized.queryType === LokiQueryType.Range;\n    };\n\n    const isLogsVolumeAvailable = request.targets.some(isQuerySuitable);\n\n    if (!isLogsVolumeAvailable) {\n      return undefined;\n    }\n\n    const logsVolumeRequest = cloneDeep(request);\n    logsVolumeRequest.targets = logsVolumeRequest.targets.filter(isQuerySuitable).map((target) => {\n      return {\n        ...target,\n        instant: false,\n        volumeQuery: true,\n        expr: `sum by (level) (count_over_time(${target.expr}[$__interval]))`,\n      };\n    });\n\n    return queryLogsVolume(this, logsVolumeRequest, {\n      extractLevel,\n      range: request.range,\n      targets: request.targets,\n    });\n  }\n\n  query(request: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    const queries = request.targets\n      .map(getNormalizedLokiQuery) // \"fix\" the `.queryType` prop\n      .map((q) => ({ ...q, maxLines: q.maxLines || this.maxLines })); // set maxLines if not set\n\n    const fixedRequest = {\n      ...request,\n      targets: queries,\n    };\n\n    const streamQueries = fixedRequest.targets.filter((q) => q.queryType === LokiQueryType.Stream);\n    if (config.featureToggles.lokiLive && streamQueries.length > 0 && fixedRequest.rangeRaw?.to === 'now') {\n      // this is still an in-development feature,\n      // we do not support mixing stream-queries with normal-queries for now.\n      const streamRequest = {\n        ...fixedRequest,\n        targets: streamQueries,\n      };\n      return merge(...streamQueries.map((q) => doLokiChannelStream(q, this, streamRequest)));\n    }\n\n    if (fixedRequest.liveStreaming) {\n      return this.runLiveQueryThroughBackend(fixedRequest);\n    } else {\n      return super\n        .query(fixedRequest)\n        .pipe(\n          map((response) =>\n            transformBackendResult(response, fixedRequest.targets, this.instanceSettings.jsonData.derivedFields ?? [])\n          )\n        );\n    }\n  }\n\n  runLiveQueryThroughBackend(request: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    // this only works in explore-mode, so variables don't need to be handled,\n    //  and only for logs-queries, not metric queries\n    const logsQueries = request.targets.filter((query) => query.expr !== '' && !isMetricsQuery(query.expr));\n\n    if (logsQueries.length === 0) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    const subQueries = logsQueries.map((query) => {\n      const maxDataPoints = query.maxLines || this.maxLines;\n      // FIXME: currently we are running it through the frontend still.\n      return this.runLiveQuery(query, maxDataPoints);\n    });\n\n    return merge(...subQueries);\n  }\n\n  createLiveTarget(target: LokiQuery, maxDataPoints: number): LokiLiveTarget {\n    const query = target.expr;\n    const baseUrl = this.instanceSettings.url;\n    const params = serializeParams({ query });\n\n    return {\n      query,\n      url: convertToWebSocketUrl(`${baseUrl}/loki/api/v1/tail?${params}`),\n      refId: target.refId,\n      size: maxDataPoints,\n    };\n  }\n\n  /**\n   * Runs live queries which in this case means creating a websocket and listening on it for new logs.\n   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple\n   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique\n   * labels per row.\n   */\n  runLiveQuery = (target: LokiQuery, maxDataPoints: number): Observable<DataQueryResponse> => {\n    const liveTarget = this.createLiveTarget(target, maxDataPoints);\n\n    return this.streams.getStream(liveTarget).pipe(\n      map((data) => ({\n        data: data || [],\n        key: `loki-${liveTarget.refId}`,\n        state: LoadingState.Streaming,\n      })),\n      catchError((err: any) => {\n        return throwError(() => `Live tailing was stopped due to following error: ${err.reason}`);\n      })\n    );\n  };\n\n  getRangeScopedVars(range: TimeRange = this.timeSrv.timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  interpolateVariablesInQueries(queries: LokiQuery[], scopedVars: ScopedVars): LokiQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map((query) => ({\n        ...query,\n        datasource: this.getRef(),\n        expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n      }));\n    }\n\n    return expandedQueries;\n  }\n\n  getQueryDisplayText(query: LokiQuery) {\n    return query.expr;\n  }\n\n  getTimeRangeParams() {\n    const timeRange = this.timeSrv.timeRange();\n    return { start: timeRange.from.valueOf() * NS_IN_MS, end: timeRange.to.valueOf() * NS_IN_MS };\n  }\n\n  async importFromAbstractQueries(abstractQueries: AbstractQuery[]): Promise<LokiQuery[]> {\n    await this.languageProvider.start();\n    const existingKeys = this.languageProvider.labelKeys;\n\n    if (existingKeys && existingKeys.length) {\n      abstractQueries = abstractQueries.map((abstractQuery) => {\n        abstractQuery.labelMatchers = abstractQuery.labelMatchers.filter((labelMatcher) => {\n          return existingKeys.includes(labelMatcher.name);\n        });\n        return abstractQuery;\n      });\n    }\n\n    return abstractQueries.map((abstractQuery) => this.languageProvider.importFromAbstractQuery(abstractQuery));\n  }\n\n  async exportToAbstractQueries(queries: LokiQuery[]): Promise<AbstractQuery[]> {\n    return queries.map((query) => this.languageProvider.exportToAbstractQuery(query));\n  }\n\n  async metadataRequest(url: string, params?: Record<string, string | number>) {\n    // url must not start with a `/`, otherwise the AJAX-request\n    // going from the browser will contain `//`, which can cause problems.\n    if (url.startsWith('/')) {\n      throw new Error(`invalid metadata request url: ${url}`);\n    }\n\n    const res = await this.getResource(url, params);\n    return res.data || [];\n  }\n\n  async metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const interpolated = this.templateSrv.replace(query, {}, this.interpolateQueryExpr);\n    return await this.processMetricFindQuery(interpolated);\n  }\n\n  async processMetricFindQuery(query: string) {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n\n    const labelNames = query.match(labelNamesRegex);\n    if (labelNames) {\n      return await this.labelNamesQuery();\n    }\n\n    const labelValues = query.match(labelValuesRegex);\n    if (labelValues) {\n      // If we have query expr, use /series endpoint\n      if (labelValues[1]) {\n        return await this.labelValuesSeriesQuery(labelValues[1], labelValues[2]);\n      }\n      return await this.labelValuesQuery(labelValues[2]);\n    }\n\n    return Promise.resolve([]);\n  }\n\n  async labelNamesQuery() {\n    const url = 'labels';\n    const params = this.getTimeRangeParams();\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesQuery(label: string) {\n    const params = this.getTimeRangeParams();\n    const url = `label/${label}/values`;\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesSeriesQuery(expr: string, label: string) {\n    const timeParams = this.getTimeRangeParams();\n    const params = {\n      ...timeParams,\n      'match[]': expr,\n    };\n    const url = 'series';\n    const streams = new Set();\n    const result = await this.metadataRequest(url, params);\n    result.forEach((stream: { [key: string]: string }) => {\n      if (stream[label]) {\n        streams.add({ text: stream[label] });\n      }\n    });\n\n    return Array.from(streams);\n  }\n\n  // By implementing getTagKeys and getTagValues we add ad-hoc filtters functionality\n  async getTagKeys() {\n    return await this.labelNamesQuery();\n  }\n\n  async getTagValues(options: any = {}) {\n    return await this.labelValuesQuery(options.key);\n  }\n\n  interpolateQueryExpr(value: any, variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return lokiRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return lokiSpecialRegexEscape(value);\n    }\n\n    const escapedValues = lodashMap(value, lokiSpecialRegexEscape);\n    return escapedValues.join('|');\n  }\n\n  modifyQuery(query: LokiQuery, action: any): LokiQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = this.addLabelToQuery(expression, action.key, '=', action.value);\n        break;\n      }\n      case 'ADD_FILTER_OUT': {\n        expression = this.addLabelToQuery(expression, action.key, '!=', action.value);\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp)!;\n    }\n\n    return Math.ceil(date.valueOf() * 1e6);\n  }\n\n  getLogRowContext = (row: LogRowModel, options?: RowContextOptions): Promise<{ data: DataFrame[] }> => {\n    const direction = (options && options.direction) || 'BACKWARD';\n    const limit = (options && options.limit) || 10;\n    const { query, range } = this.prepareLogRowContextQueryTarget(row, limit, direction);\n\n    const processDataFrame = (frame: DataFrame): DataFrame => {\n      // log-row-context requires specific field-names to work, so we set them here: \"ts\", \"line\", \"id\"\n      const cache = new FieldCache(frame);\n      const timestampField = cache.getFirstFieldOfType(FieldType.time);\n      const lineField = cache.getFirstFieldOfType(FieldType.string);\n      const idField = cache.getFieldByName('id');\n\n      if (timestampField === undefined || lineField === undefined || idField === undefined) {\n        // this should never really happen, but i want to keep typescript happy\n        return { ...frame, fields: [] };\n      }\n\n      return {\n        ...frame,\n        fields: [\n          {\n            ...timestampField,\n            name: 'ts',\n          },\n          {\n            ...lineField,\n            name: 'line',\n          },\n          {\n            ...idField,\n            name: 'id',\n          },\n        ],\n      };\n    };\n\n    const processResults = (result: DataQueryResponse): DataQueryResponse => {\n      const frames: DataFrame[] = result.data;\n      const processedFrames = frames\n        .map((frame) => sortDataFrameByTime(frame, 'DESCENDING'))\n        .map((frame) => processDataFrame(frame)); // rename fields if needed\n\n      return {\n        ...result,\n        data: processedFrames,\n      };\n    };\n\n    // this can only be called from explore currently\n    const app = CoreApp.Explore;\n\n    return lastValueFrom(\n      this.query(makeRequest(query, range, app, `log-row-context-query-${direction}`)).pipe(\n        catchError((err) => {\n          const error: DataQueryError = {\n            message: 'Error during context query. Please check JS console logs.',\n            status: err.status,\n            statusText: err.statusText,\n          };\n          throw error;\n        }),\n        switchMap((res) => of(processResults(res)))\n      )\n    );\n  };\n\n  prepareLogRowContextQueryTarget = (\n    row: LogRowModel,\n    limit: number,\n    direction: 'BACKWARD' | 'FORWARD'\n  ): { query: LokiQuery; range: TimeRange } => {\n    const labels = this.languageProvider.getLabelKeys();\n    const expr = Object.keys(row.labels)\n      .map((label: string) => {\n        if (labels.includes(label)) {\n          // escape backslashes in label as users can't escape them by themselves\n          return `${label}=\"${row.labels[label].replace(/\\\\/g, '\\\\\\\\')}\"`;\n        }\n        return '';\n      })\n      // Filter empty strings\n      .filter((label) => !!label)\n      .join(',');\n\n    const contextTimeBuffer = 2 * 60 * 60 * 1000; // 2h buffer\n\n    const queryDirection = direction === 'FORWARD' ? LokiQueryDirection.Forward : LokiQueryDirection.Backward;\n\n    const query: LokiQuery = {\n      expr: `{${expr}}`,\n      queryType: LokiQueryType.Range,\n      refId: '',\n      maxLines: limit,\n      direction: queryDirection,\n    };\n\n    const fieldCache = new FieldCache(row.dataFrame);\n    const tsField = fieldCache.getFirstFieldOfType(FieldType.time);\n    if (tsField === undefined) {\n      throw new Error('loki: dataframe missing time-field, should never happen');\n    }\n    const tsValue = tsField.values.get(row.rowIndex);\n    const timestamp = toUtc(tsValue);\n\n    const range =\n      queryDirection === LokiQueryDirection.Forward\n        ? {\n            // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from\n            // and any other that were logged in the same ns but before the row. Right now these rows will be lost\n            // because the are before but came it he response that should return only rows after.\n            from: timestamp,\n            // convert to ns, we loose some precision here but it is not that important at the far points of the context\n            to: toUtc(row.timeEpochMs + contextTimeBuffer),\n          }\n        : {\n            // convert to ns, we loose some precision here but it is not that important at the far points of the context\n            from: toUtc(row.timeEpochMs - contextTimeBuffer),\n            to: timestamp,\n          };\n\n    return {\n      query,\n      range: {\n        from: range.from,\n        to: range.to,\n        raw: range,\n      },\n    };\n  };\n\n  testDatasource(): Promise<{ status: string; message: string }> {\n    // Consider only last 10 minutes otherwise request takes too long\n    const nowMs = Date.now();\n    const params = {\n      start: (nowMs - 10 * 60 * 1000) * NS_IN_MS,\n      end: nowMs * NS_IN_MS,\n    };\n\n    return this.metadataRequest('labels', params).then(\n      (values) => {\n        return values.length > 0\n          ? { status: 'success', message: 'Data source connected and labels found.' }\n          : {\n              status: 'error',\n              message:\n                'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.',\n            };\n      },\n      (err) => {\n        // we did a resource-call that failed.\n        // the only info we have, if exists, is err.data.message\n        // (when in development-mode, err.data.error exists too, but not in production-mode)\n        // things like err.status & err.statusText does not help,\n        // because those will only describe how the request between browser<>server failed\n        const info: string = err?.data?.message ?? '';\n        const infoInParentheses = info !== '' ? ` (${info})` : '';\n        const message = `Unable to fetch labels from Loki${infoInParentheses}, please check the server logs for more details`;\n        return { status: 'error', message: message };\n      }\n    );\n  }\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const { expr, maxLines, instant, tagKeys = '', titleFormat = '', textFormat = '' } = options.annotation;\n\n    if (!expr) {\n      return [];\n    }\n\n    const id = `annotation-${options.annotation.name}`;\n\n    const query: LokiQuery = {\n      refId: id,\n      expr,\n      maxLines,\n      instant,\n      queryType: instant ? LokiQueryType.Instant : LokiQueryType.Range,\n    };\n\n    const request = makeRequest(query, options.range, CoreApp.Dashboard, id);\n\n    const { data } = await lastValueFrom(this.query(request));\n\n    const annotations: AnnotationEvent[] = [];\n    const splitKeys: string[] = tagKeys.split(',').filter((v: string) => v !== '');\n\n    for (const frame of data) {\n      const view = new DataFrameView<{ Time: string; Line: string; labels: Labels }>(frame);\n\n      view.forEach((row) => {\n        const { labels } = row;\n\n        const maybeDuplicatedTags = Object.entries(labels)\n          .map(([key, val]) => [key, val.trim()]) // trim all label-values\n          .filter(([key, val]) => {\n            if (val === '') {\n              // remove empty\n              return false;\n            }\n\n            // if tags are specified, remove label if does not match tags\n            if (splitKeys.length && !splitKeys.includes(key)) {\n              return false;\n            }\n\n            return true;\n          })\n          .map(([key, val]) => val); // keep only the label-value\n\n        // remove duplicates\n        const tags = Array.from(new Set(maybeDuplicatedTags));\n\n        annotations.push({\n          time: new Date(row.Time).valueOf(),\n          title: renderLegendFormat(titleFormat, labels),\n          text: renderLegendFormat(textFormat, labels) || row.Line,\n          tags,\n        });\n      });\n    }\n\n    return annotations;\n  }\n\n  showContextToggle(row?: LogRowModel): boolean {\n    return (row && row.searchWords && row.searchWords.length > 0) === true;\n  }\n\n  processError(err: FetchError, target: LokiQuery) {\n    let error: DataQueryError = cloneDeep(err);\n    error.refId = target.refId;\n\n    if (error.data && err.data.message.includes('escape') && target.expr.includes('\\\\')) {\n      error.data.message = `Error: ${err.data.message}. Make sure that all special characters are escaped with \\\\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`;\n    }\n\n    return error;\n  }\n\n  addAdHocFilters(queryExpr: string) {\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    let expr = queryExpr;\n\n    expr = adhocFilters.reduce((acc: string, filter: { key: string; operator: string; value: string }) => {\n      const { key, operator, value } = filter;\n      return this.addLabelToQuery(acc, key, operator, value);\n    }, expr);\n\n    return expr;\n  }\n\n  addLabelToQuery(queryExpr: string, key: string, operator: string, value: string) {\n    const escapedValue = escapeLabelValueInSelector(value, operator);\n    return addLabelToQuery(queryExpr, key, operator, escapedValue);\n  }\n\n  // Used when running queries through backend\n  filterQuery(query: LokiQuery): boolean {\n    if (query.hide || query.expr === '') {\n      return false;\n    }\n    return true;\n  }\n\n  // Used when running queries through backend\n  applyTemplateVariables(target: LokiQuery, scopedVars: ScopedVars): LokiQuery {\n    // We want to interpolate these variables on backend\n    const { __interval, __interval_ms, ...rest } = scopedVars;\n\n    const exprWithAdHoc = this.addAdHocFilters(target.expr);\n\n    return {\n      ...target,\n      legendFormat: this.templateSrv.replace(target.legendFormat, rest),\n      expr: this.templateSrv.replace(exprWithAdHoc, rest, this.interpolateQueryExpr),\n    };\n  }\n\n  interpolateString(string: string) {\n    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);\n  }\n\n  getVariables(): string[] {\n    return this.templateSrv.getVariables().map((v) => `$${v.name}`);\n  }\n}\n\nexport function lokiRegularEscape(value: any) {\n  if (typeof value === 'string') {\n    return value.replace(/'/g, \"\\\\\\\\'\");\n  }\n  return value;\n}\n\nexport function lokiSpecialRegexEscape(value: any) {\n  if (typeof value === 'string') {\n    return lokiRegularEscape(value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]+?.()|]/g, '\\\\\\\\$&'));\n  }\n  return value;\n}\n\n/**\n * Checks if the query expression uses function and so should return a time series instead of logs.\n * Sometimes important to know that before we actually do the query.\n */\nexport function isMetricsQuery(query: string): boolean {\n  if (!query) {\n    return false;\n  }\n  const tokens = Prism.tokenize(query, syntax);\n  return tokens.some((t) => {\n    // Not sure in which cases it can be string maybe if nothing matched which means it should not be a function\n    return typeof t !== 'string' && t.type === 'function';\n  });\n}\n\nfunction extractLevel(dataFrame: DataFrame): LogLevel {\n  let valueField;\n  try {\n    valueField = new FieldCache(dataFrame).getFirstFieldOfType(FieldType.number);\n  } catch {}\n  return valueField?.labels ? getLogLevelFromLabels(valueField.labels) : LogLevel.unknown;\n}\n\nfunction getLogLevelFromLabels(labels: Labels): LogLevel {\n  const labelNames = ['level', 'lvl', 'loglevel'];\n  let levelLabel;\n  for (let labelName of labelNames) {\n    if (labelName in labels) {\n      levelLabel = labelName;\n      break;\n    }\n  }\n  return levelLabel ? getLogLevelFromKey(labels[levelLabel]) : LogLevel.unknown;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}