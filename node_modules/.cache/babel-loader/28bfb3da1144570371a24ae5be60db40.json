{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { map, find, filter, indexOf } from 'lodash';\nimport kbn from 'app/core/utils/kbn';\nimport queryPart from './query_part';\nexport default class InfluxQueryModel {\n  /** @ngInject */\n  constructor(target, templateSrv, scopedVars) {\n    _defineProperty(this, \"target\", void 0);\n\n    _defineProperty(this, \"selectModels\", []);\n\n    _defineProperty(this, \"queryBuilder\", void 0);\n\n    _defineProperty(this, \"groupByParts\", void 0);\n\n    _defineProperty(this, \"templateSrv\", void 0);\n\n    _defineProperty(this, \"scopedVars\", void 0);\n\n    _defineProperty(this, \"refId\", void 0);\n\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n    target.policy = target.policy || 'default';\n    target.resultFormat = target.resultFormat || 'time_series';\n    target.orderByTime = target.orderByTime || 'ASC';\n    target.tags = target.tags || [];\n    target.groupBy = target.groupBy || [{\n      type: 'time',\n      params: ['$__interval']\n    }, {\n      type: 'fill',\n      params: ['null']\n    }];\n    target.select = target.select || [[{\n      type: 'field',\n      params: ['value']\n    }, {\n      type: 'mean',\n      params: []\n    }]];\n    this.updateProjection();\n  }\n\n  updateProjection() {\n    this.selectModels = map(this.target.select, parts => {\n      return map(parts, queryPart.create);\n    });\n    this.groupByParts = map(this.target.groupBy, queryPart.create);\n  }\n\n  updatePersistedParts() {\n    this.target.select = map(this.selectModels, selectParts => {\n      return map(selectParts, part => {\n        return {\n          type: part.def.type,\n          params: part.params\n        };\n      });\n    });\n  }\n\n  hasGroupByTime() {\n    return find(this.target.groupBy, g => g.type === 'time');\n  }\n\n  hasFill() {\n    return find(this.target.groupBy, g => g.type === 'fill');\n  }\n\n  addGroupBy(value) {\n    let stringParts = value.match(/^(\\w+)\\((.*)\\)$/);\n\n    if (!stringParts || !this.target.groupBy) {\n      return;\n    }\n\n    const typePart = stringParts[1];\n    const arg = stringParts[2];\n    const partModel = queryPart.create({\n      type: typePart,\n      params: [arg]\n    });\n    const partCount = this.target.groupBy.length;\n\n    if (partCount === 0) {\n      this.target.groupBy.push(partModel.part);\n    } else if (typePart === 'time') {\n      this.target.groupBy.splice(0, 0, partModel.part);\n    } else if (typePart === 'tag') {\n      if (this.target.groupBy[partCount - 1].type === 'fill') {\n        this.target.groupBy.splice(partCount - 1, 0, partModel.part);\n      } else {\n        this.target.groupBy.push(partModel.part);\n      }\n    } else {\n      this.target.groupBy.push(partModel.part);\n    }\n\n    this.updateProjection();\n  }\n\n  removeGroupByPart(part, index) {\n    const categories = queryPart.getCategories();\n\n    if (part.def.type === 'time') {\n      // remove fill\n      this.target.groupBy = filter(this.target.groupBy, g => g.type !== 'fill'); // remove aggregations\n\n      this.target.select = map(this.target.select, s => {\n        return filter(s, part => {\n          const partModel = queryPart.create(part);\n\n          if (partModel.def.category === categories.Aggregations) {\n            return false;\n          }\n\n          if (partModel.def.category === categories.Selectors) {\n            return false;\n          }\n\n          return true;\n        });\n      });\n    }\n\n    this.target.groupBy.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelect(index) {\n    this.target.select.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelectPart(selectParts, part) {\n    // if we remove the field remove the whole statement\n    if (part.def.type === 'field') {\n      if (this.selectModels.length > 1) {\n        const modelsIndex = indexOf(this.selectModels, selectParts);\n        this.selectModels.splice(modelsIndex, 1);\n      }\n    } else {\n      const partIndex = indexOf(selectParts, part);\n      selectParts.splice(partIndex, 1);\n    }\n\n    this.updatePersistedParts();\n  }\n\n  addSelectPart(selectParts, type) {\n    const partModel = queryPart.create({\n      type: type\n    });\n    partModel.def.addStrategy(selectParts, partModel, this);\n    this.updatePersistedParts();\n  }\n\n  renderTagCondition(tag, index, interpolate) {\n    // FIXME: merge this function with query_builder/renderTagCondition\n    let str = '';\n    let operator = tag.operator;\n    let value = tag.value;\n\n    if (index > 0) {\n      str = (tag.condition || 'AND') + ' ';\n    }\n\n    if (!operator) {\n      if (/^\\/.*\\/$/.test(value)) {\n        operator = '=~';\n      } else {\n        operator = '=';\n      }\n    } // quote value unless regex\n\n\n    if (operator !== '=~' && operator !== '!~') {\n      if (interpolate) {\n        value = this.templateSrv.replace(value, this.scopedVars);\n      }\n\n      if (operator !== '>' && operator !== '<') {\n        value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\n      }\n    } else if (interpolate) {\n      value = this.templateSrv.replace(value, this.scopedVars, 'regex');\n    }\n\n    return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n  }\n\n  getMeasurementAndPolicy(interpolate) {\n    let policy = this.target.policy;\n    let measurement = this.target.measurement || 'measurement';\n\n    if (!measurement.match('^/.*/$')) {\n      measurement = '\"' + measurement + '\"';\n    } else if (interpolate) {\n      measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');\n    }\n\n    if (policy !== 'default') {\n      policy = '\"' + this.target.policy + '\".';\n    } else {\n      policy = '';\n    }\n\n    return policy + measurement;\n  }\n\n  interpolateQueryStr(value, variable, defaultFormatFn) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return kbn.regexEscape(value);\n    }\n\n    const escapedValues = map(value, kbn.regexEscape);\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  render(interpolate) {\n    const target = this.target;\n\n    if (target.rawQuery) {\n      if (interpolate) {\n        return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);\n      } else {\n        return target.query;\n      }\n    }\n\n    let query = 'SELECT ';\n    let i, y;\n\n    for (i = 0; i < this.selectModels.length; i++) {\n      const parts = this.selectModels[i];\n      let selectText = '';\n\n      for (y = 0; y < parts.length; y++) {\n        const part = parts[y];\n        selectText = part.render(selectText);\n      }\n\n      if (i > 0) {\n        query += ', ';\n      }\n\n      query += selectText;\n    }\n\n    query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';\n    const conditions = map(target.tags, (tag, index) => {\n      return this.renderTagCondition(tag, index, interpolate);\n    });\n\n    if (conditions.length > 0) {\n      query += '(' + conditions.join(' ') + ') AND ';\n    }\n\n    query += '$timeFilter';\n    let groupBySection = '';\n\n    for (i = 0; i < this.groupByParts.length; i++) {\n      const part = this.groupByParts[i];\n\n      if (i > 0) {\n        // for some reason fill has no separator\n        groupBySection += part.def.type === 'fill' ? ' ' : ', ';\n      }\n\n      groupBySection += part.render('');\n    }\n\n    if (groupBySection.length) {\n      query += ' GROUP BY ' + groupBySection;\n    }\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    if (target.orderByTime === 'DESC') {\n      query += ' ORDER BY time DESC';\n    }\n\n    if (target.limit) {\n      query += ' LIMIT ' + target.limit;\n    }\n\n    if (target.slimit) {\n      query += ' SLIMIT ' + target.slimit;\n    }\n\n    if (target.tz) {\n      query += \" tz('\" + target.tz + \"')\";\n    }\n\n    return query;\n  }\n\n  renderAdhocFilters(filters) {\n    const conditions = map(filters, (tag, index) => {\n      return this.renderTagCondition(tag, index, true);\n    });\n    return conditions.join(' ');\n  }\n\n}\nInfluxQueryModel.$inject = [\"target\", \"templateSrv\", \"scopedVars\"];","map":{"version":3,"names":["map","find","filter","indexOf","kbn","queryPart","InfluxQueryModel","constructor","target","templateSrv","scopedVars","policy","resultFormat","orderByTime","tags","groupBy","type","params","select","updateProjection","selectModels","parts","create","groupByParts","updatePersistedParts","selectParts","part","def","hasGroupByTime","g","hasFill","addGroupBy","value","stringParts","match","typePart","arg","partModel","partCount","length","push","splice","removeGroupByPart","index","categories","getCategories","s","category","Aggregations","Selectors","removeSelect","removeSelectPart","modelsIndex","partIndex","addSelectPart","addStrategy","renderTagCondition","tag","interpolate","str","operator","condition","test","replace","key","getMeasurementAndPolicy","measurement","interpolateQueryStr","variable","defaultFormatFn","multi","includeAll","regexEscape","escapedValues","join","render","rawQuery","query","i","y","selectText","conditions","groupBySection","fill","limit","slimit","tz","renderAdhocFilters","filters"],"sources":["/home/soula/grafana/public/app/plugins/datasource/influxdb/influx_query_model.ts"],"sourcesContent":["import { map, find, filter, indexOf } from 'lodash';\n\nimport { ScopedVars } from '@grafana/data';\nimport { TemplateSrv } from '@grafana/runtime';\nimport kbn from 'app/core/utils/kbn';\n\nimport queryPart from './query_part';\nimport { InfluxQuery, InfluxQueryTag } from './types';\n\nexport default class InfluxQueryModel {\n  target: InfluxQuery;\n  selectModels: any[] = [];\n  queryBuilder: any;\n  groupByParts: any;\n  templateSrv: any;\n  scopedVars: any;\n  refId?: string;\n\n  /** @ngInject */\n  constructor(target: InfluxQuery, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n\n    target.policy = target.policy || 'default';\n    target.resultFormat = target.resultFormat || 'time_series';\n    target.orderByTime = target.orderByTime || 'ASC';\n    target.tags = target.tags || [];\n    target.groupBy = target.groupBy || [\n      { type: 'time', params: ['$__interval'] },\n      { type: 'fill', params: ['null'] },\n    ];\n    target.select = target.select || [\n      [\n        { type: 'field', params: ['value'] },\n        { type: 'mean', params: [] },\n      ],\n    ];\n\n    this.updateProjection();\n  }\n\n  updateProjection() {\n    this.selectModels = map(this.target.select, (parts: any) => {\n      return map(parts, queryPart.create);\n    });\n    this.groupByParts = map(this.target.groupBy, queryPart.create);\n  }\n\n  updatePersistedParts() {\n    this.target.select = map(this.selectModels, (selectParts) => {\n      return map(selectParts, (part: any) => {\n        return { type: part.def.type, params: part.params };\n      });\n    });\n  }\n\n  hasGroupByTime() {\n    return find(this.target.groupBy, (g: any) => g.type === 'time');\n  }\n\n  hasFill() {\n    return find(this.target.groupBy, (g: any) => g.type === 'fill');\n  }\n\n  addGroupBy(value: string) {\n    let stringParts = value.match(/^(\\w+)\\((.*)\\)$/);\n\n    if (!stringParts || !this.target.groupBy) {\n      return;\n    }\n\n    const typePart = stringParts[1];\n    const arg = stringParts[2];\n    const partModel = queryPart.create({ type: typePart, params: [arg] });\n    const partCount = this.target.groupBy.length;\n\n    if (partCount === 0) {\n      this.target.groupBy.push(partModel.part);\n    } else if (typePart === 'time') {\n      this.target.groupBy.splice(0, 0, partModel.part);\n    } else if (typePart === 'tag') {\n      if (this.target.groupBy[partCount - 1].type === 'fill') {\n        this.target.groupBy.splice(partCount - 1, 0, partModel.part);\n      } else {\n        this.target.groupBy.push(partModel.part);\n      }\n    } else {\n      this.target.groupBy.push(partModel.part);\n    }\n\n    this.updateProjection();\n  }\n\n  removeGroupByPart(part: { def: { type: string } }, index: number) {\n    const categories = queryPart.getCategories();\n\n    if (part.def.type === 'time') {\n      // remove fill\n      this.target.groupBy = filter(this.target.groupBy, (g: any) => g.type !== 'fill');\n      // remove aggregations\n      this.target.select = map(this.target.select, (s: any) => {\n        return filter(s, (part: any) => {\n          const partModel = queryPart.create(part);\n          if (partModel.def.category === categories.Aggregations) {\n            return false;\n          }\n          if (partModel.def.category === categories.Selectors) {\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n\n    this.target.groupBy!.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelect(index: number) {\n    this.target.select!.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelectPart(selectParts: any[], part: any) {\n    // if we remove the field remove the whole statement\n    if (part.def.type === 'field') {\n      if (this.selectModels.length > 1) {\n        const modelsIndex = indexOf(this.selectModels, selectParts);\n        this.selectModels.splice(modelsIndex, 1);\n      }\n    } else {\n      const partIndex = indexOf(selectParts, part);\n      selectParts.splice(partIndex, 1);\n    }\n\n    this.updatePersistedParts();\n  }\n\n  addSelectPart(selectParts: any[], type: string) {\n    const partModel = queryPart.create({ type: type });\n    partModel.def.addStrategy(selectParts, partModel, this);\n    this.updatePersistedParts();\n  }\n\n  private renderTagCondition(tag: InfluxQueryTag, index: number, interpolate?: boolean) {\n    // FIXME: merge this function with query_builder/renderTagCondition\n    let str = '';\n    let operator = tag.operator;\n    let value = tag.value;\n    if (index > 0) {\n      str = (tag.condition || 'AND') + ' ';\n    }\n\n    if (!operator) {\n      if (/^\\/.*\\/$/.test(value)) {\n        operator = '=~';\n      } else {\n        operator = '=';\n      }\n    }\n\n    // quote value unless regex\n    if (operator !== '=~' && operator !== '!~') {\n      if (interpolate) {\n        value = this.templateSrv.replace(value, this.scopedVars);\n      }\n      if (operator !== '>' && operator !== '<') {\n        value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\n      }\n    } else if (interpolate) {\n      value = this.templateSrv.replace(value, this.scopedVars, 'regex');\n    }\n\n    return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n  }\n\n  getMeasurementAndPolicy(interpolate: any) {\n    let policy = this.target.policy;\n    let measurement = this.target.measurement || 'measurement';\n\n    if (!measurement.match('^/.*/$')) {\n      measurement = '\"' + measurement + '\"';\n    } else if (interpolate) {\n      measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');\n    }\n\n    if (policy !== 'default') {\n      policy = '\"' + this.target.policy + '\".';\n    } else {\n      policy = '';\n    }\n\n    return policy + measurement;\n  }\n\n  interpolateQueryStr(value: any[], variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return kbn.regexEscape(value);\n    }\n\n    const escapedValues = map(value, kbn.regexEscape);\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  render(interpolate?: boolean) {\n    const target = this.target;\n\n    if (target.rawQuery) {\n      if (interpolate) {\n        return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);\n      } else {\n        return target.query;\n      }\n    }\n\n    let query = 'SELECT ';\n    let i, y;\n    for (i = 0; i < this.selectModels.length; i++) {\n      const parts = this.selectModels[i];\n      let selectText = '';\n      for (y = 0; y < parts.length; y++) {\n        const part = parts[y];\n        selectText = part.render(selectText);\n      }\n\n      if (i > 0) {\n        query += ', ';\n      }\n      query += selectText;\n    }\n\n    query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';\n    const conditions = map(target.tags, (tag, index) => {\n      return this.renderTagCondition(tag, index, interpolate);\n    });\n\n    if (conditions.length > 0) {\n      query += '(' + conditions.join(' ') + ') AND ';\n    }\n\n    query += '$timeFilter';\n\n    let groupBySection = '';\n    for (i = 0; i < this.groupByParts.length; i++) {\n      const part = this.groupByParts[i];\n      if (i > 0) {\n        // for some reason fill has no separator\n        groupBySection += part.def.type === 'fill' ? ' ' : ', ';\n      }\n      groupBySection += part.render('');\n    }\n\n    if (groupBySection.length) {\n      query += ' GROUP BY ' + groupBySection;\n    }\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    if (target.orderByTime === 'DESC') {\n      query += ' ORDER BY time DESC';\n    }\n\n    if (target.limit) {\n      query += ' LIMIT ' + target.limit;\n    }\n\n    if (target.slimit) {\n      query += ' SLIMIT ' + target.slimit;\n    }\n\n    if (target.tz) {\n      query += \" tz('\" + target.tz + \"')\";\n    }\n\n    return query;\n  }\n\n  renderAdhocFilters(filters: any[]) {\n    const conditions = map(filters, (tag, index) => {\n      return this.renderTagCondition(tag, index, true);\n    });\n    return conditions.join(' ');\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}