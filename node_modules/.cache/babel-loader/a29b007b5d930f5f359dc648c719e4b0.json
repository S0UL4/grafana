{"ast":null,"code":"import { useEffect, useRef, useState, useMemo } from 'react';\nimport useMountedState from 'react-use/lib/useMountedState';\nimport usePrevious from 'react-use/lib/usePrevious';\n\n/**\n * Based on https://github.com/streamich/react-use/blob/master/src/useSlider.ts\n * Returns position x/y coordinates which can be directly used in transform: translate().\n * @param scale - Can be used when we want to scale the movement if we are moving a scaled element. We need to do it\n *   here because we don't want to change the pos when scale changes.\n * @param bounds - If set the panning cannot go outside of those bounds.\n * @param focus - Position to focus on.\n */\nexport function usePanning({\n  scale = 1,\n  bounds,\n  focus\n} = {}) {\n  const isMounted = useMountedState();\n  const isPanning = useRef(false);\n  const frame = useRef(0);\n  const panRef = useRef(null);\n  const initial = {\n    x: 0,\n    y: 0\n  }; // As we return a diff of the view port to be applied we need as translate coordinates we have to invert the\n  // bounds of the content to get the bounds of the view port diff.\n\n  const viewBounds = useMemo(() => ({\n    right: bounds ? -bounds.left : Infinity,\n    left: bounds ? -bounds.right : -Infinity,\n    bottom: bounds ? -bounds.top : -Infinity,\n    top: bounds ? -bounds.bottom : Infinity\n  }), [bounds]); // We need to keep some state so we can compute the position diff and add that to the previous position.\n\n  const startMousePosition = useRef(initial);\n  const prevPosition = useRef(initial); // We cannot use the state as that would rerun the effect on each state change which we don't want so we have to keep\n  // separate variable for the state that won't cause useEffect eval\n\n  const currentPosition = useRef(initial);\n  const [state, setState] = useState({\n    isPanning: false,\n    position: initial\n  });\n  useEffect(() => {\n    const startPanning = event => {\n      if (!isPanning.current && isMounted()) {\n        isPanning.current = true; // Snapshot the current position of both mouse pointer and the element\n\n        startMousePosition.current = getEventXY(event);\n        prevPosition.current = Object.assign({}, currentPosition.current);\n        setState(state => Object.assign({}, state, {\n          isPanning: true\n        }));\n        bindEvents();\n      }\n    };\n\n    const stopPanning = () => {\n      if (isPanning.current && isMounted()) {\n        isPanning.current = false;\n        setState(state => Object.assign({}, state, {\n          isPanning: false\n        }));\n        unbindEvents();\n      }\n    };\n\n    const onPanStart = event => {\n      startPanning(event);\n      onPan(event);\n    };\n\n    const bindEvents = () => {\n      document.addEventListener('mousemove', onPan);\n      document.addEventListener('mouseup', stopPanning);\n      document.addEventListener('touchmove', onPan);\n      document.addEventListener('touchend', stopPanning);\n    };\n\n    const unbindEvents = () => {\n      document.removeEventListener('mousemove', onPan);\n      document.removeEventListener('mouseup', stopPanning);\n      document.removeEventListener('touchmove', onPan);\n      document.removeEventListener('touchend', stopPanning);\n    };\n\n    const onPan = event => {\n      cancelAnimationFrame(frame.current);\n      const pos = getEventXY(event);\n      frame.current = requestAnimationFrame(() => {\n        if (isMounted() && panRef.current) {\n          // Get the diff by which we moved the mouse.\n          let xDiff = pos.x - startMousePosition.current.x;\n          let yDiff = pos.y - startMousePosition.current.y; // Add the diff to the position from the moment we started panning.\n\n          currentPosition.current = {\n            x: inBounds(prevPosition.current.x + xDiff / scale, viewBounds.left, viewBounds.right),\n            y: inBounds(prevPosition.current.y + yDiff / scale, viewBounds.top, viewBounds.bottom)\n          };\n          setState(state => Object.assign({}, state, {\n            position: Object.assign({}, currentPosition.current)\n          }));\n        }\n      });\n    };\n\n    const ref = panRef.current;\n\n    if (ref) {\n      ref.addEventListener('mousedown', onPanStart);\n      ref.addEventListener('touchstart', onPanStart);\n    }\n\n    return () => {\n      if (ref) {\n        ref.removeEventListener('mousedown', onPanStart);\n        ref.removeEventListener('touchstart', onPanStart);\n      }\n    };\n  }, [scale, viewBounds, isMounted]);\n  const previousFocus = usePrevious(focus); // We need to update the state in case need to focus on something but we want to do it only once when the focus\n  // changes to something new.\n\n  useEffect(() => {\n    if (focus && (previousFocus === null || previousFocus === void 0 ? void 0 : previousFocus.x) !== focus.x && (previousFocus === null || previousFocus === void 0 ? void 0 : previousFocus.y) !== focus.y) {\n      const position = {\n        x: inBounds(focus.x, viewBounds.left, viewBounds.right),\n        y: inBounds(focus.y, viewBounds.top, viewBounds.bottom)\n      };\n      setState({\n        position,\n        isPanning: false\n      });\n      currentPosition.current = position;\n      prevPosition.current = position;\n    }\n  }, [focus, previousFocus, viewBounds, currentPosition, prevPosition]);\n  let position = state.position; // This part prevents an ugly jump from initial position to the focused one as the set state in the effects is after\n  // initial render.\n\n  if (focus && (previousFocus === null || previousFocus === void 0 ? void 0 : previousFocus.x) !== focus.x && (previousFocus === null || previousFocus === void 0 ? void 0 : previousFocus.y) !== focus.y) {\n    position = focus;\n  }\n\n  return {\n    state: Object.assign({}, state, {\n      position: {\n        x: inBounds(position.x, viewBounds.left, viewBounds.right),\n        y: inBounds(position.y, viewBounds.top, viewBounds.bottom)\n      }\n    }),\n    ref: panRef\n  };\n}\n\nfunction inBounds(value, min, max) {\n  return Math.min(Math.max(value, min !== null && min !== void 0 ? min : -Infinity), max !== null && max !== void 0 ? max : Infinity);\n}\n\nfunction getEventXY(event) {\n  if (event.changedTouches) {\n    const e = event;\n    return {\n      x: e.changedTouches[0].clientX,\n      y: e.changedTouches[0].clientY\n    };\n  } else {\n    const e = event;\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n}","map":{"version":3,"names":["useEffect","useRef","useState","useMemo","useMountedState","usePrevious","usePanning","scale","bounds","focus","isMounted","isPanning","frame","panRef","initial","x","y","viewBounds","right","left","Infinity","bottom","top","startMousePosition","prevPosition","currentPosition","state","setState","position","startPanning","event","current","getEventXY","bindEvents","stopPanning","unbindEvents","onPanStart","onPan","document","addEventListener","removeEventListener","cancelAnimationFrame","pos","requestAnimationFrame","xDiff","yDiff","inBounds","ref","previousFocus","value","min","max","Math","changedTouches","e","clientX","clientY"],"sources":["/home/soula/grafana/public/app/plugins/panel/nodeGraph/usePanning.ts"],"sourcesContent":["import { useEffect, useRef, RefObject, useState, useMemo } from 'react';\nimport useMountedState from 'react-use/lib/useMountedState';\nimport usePrevious from 'react-use/lib/usePrevious';\n\nimport { Bounds } from './utils';\n\nexport interface State {\n  isPanning: boolean;\n  position: {\n    x: number;\n    y: number;\n  };\n}\n\ninterface Options {\n  scale?: number;\n  bounds?: Bounds;\n  focus?: {\n    x: number;\n    y: number;\n  };\n}\n\n/**\n * Based on https://github.com/streamich/react-use/blob/master/src/useSlider.ts\n * Returns position x/y coordinates which can be directly used in transform: translate().\n * @param scale - Can be used when we want to scale the movement if we are moving a scaled element. We need to do it\n *   here because we don't want to change the pos when scale changes.\n * @param bounds - If set the panning cannot go outside of those bounds.\n * @param focus - Position to focus on.\n */\nexport function usePanning<T extends Element>({ scale = 1, bounds, focus }: Options = {}): {\n  state: State;\n  ref: RefObject<T>;\n} {\n  const isMounted = useMountedState();\n  const isPanning = useRef(false);\n  const frame = useRef(0);\n  const panRef = useRef<T>(null);\n\n  const initial = { x: 0, y: 0 };\n  // As we return a diff of the view port to be applied we need as translate coordinates we have to invert the\n  // bounds of the content to get the bounds of the view port diff.\n  const viewBounds = useMemo(\n    () => ({\n      right: bounds ? -bounds.left : Infinity,\n      left: bounds ? -bounds.right : -Infinity,\n      bottom: bounds ? -bounds.top : -Infinity,\n      top: bounds ? -bounds.bottom : Infinity,\n    }),\n    [bounds]\n  );\n\n  // We need to keep some state so we can compute the position diff and add that to the previous position.\n  const startMousePosition = useRef(initial);\n  const prevPosition = useRef(initial);\n  // We cannot use the state as that would rerun the effect on each state change which we don't want so we have to keep\n  // separate variable for the state that won't cause useEffect eval\n  const currentPosition = useRef(initial);\n\n  const [state, setState] = useState<State>({\n    isPanning: false,\n    position: initial,\n  });\n\n  useEffect(() => {\n    const startPanning = (event: Event) => {\n      if (!isPanning.current && isMounted()) {\n        isPanning.current = true;\n        // Snapshot the current position of both mouse pointer and the element\n        startMousePosition.current = getEventXY(event);\n        prevPosition.current = { ...currentPosition.current };\n        setState((state) => ({ ...state, isPanning: true }));\n        bindEvents();\n      }\n    };\n\n    const stopPanning = () => {\n      if (isPanning.current && isMounted()) {\n        isPanning.current = false;\n        setState((state) => ({ ...state, isPanning: false }));\n        unbindEvents();\n      }\n    };\n\n    const onPanStart = (event: Event) => {\n      startPanning(event);\n      onPan(event);\n    };\n\n    const bindEvents = () => {\n      document.addEventListener('mousemove', onPan);\n      document.addEventListener('mouseup', stopPanning);\n      document.addEventListener('touchmove', onPan);\n      document.addEventListener('touchend', stopPanning);\n    };\n\n    const unbindEvents = () => {\n      document.removeEventListener('mousemove', onPan);\n      document.removeEventListener('mouseup', stopPanning);\n      document.removeEventListener('touchmove', onPan);\n      document.removeEventListener('touchend', stopPanning);\n    };\n\n    const onPan = (event: Event) => {\n      cancelAnimationFrame(frame.current);\n      const pos = getEventXY(event);\n\n      frame.current = requestAnimationFrame(() => {\n        if (isMounted() && panRef.current) {\n          // Get the diff by which we moved the mouse.\n          let xDiff = pos.x - startMousePosition.current.x;\n          let yDiff = pos.y - startMousePosition.current.y;\n\n          // Add the diff to the position from the moment we started panning.\n          currentPosition.current = {\n            x: inBounds(prevPosition.current.x + xDiff / scale, viewBounds.left, viewBounds.right),\n            y: inBounds(prevPosition.current.y + yDiff / scale, viewBounds.top, viewBounds.bottom),\n          };\n          setState((state) => ({\n            ...state,\n            position: {\n              ...currentPosition.current,\n            },\n          }));\n        }\n      });\n    };\n\n    const ref = panRef.current;\n    if (ref) {\n      ref.addEventListener('mousedown', onPanStart);\n      ref.addEventListener('touchstart', onPanStart);\n    }\n    return () => {\n      if (ref) {\n        ref.removeEventListener('mousedown', onPanStart);\n        ref.removeEventListener('touchstart', onPanStart);\n      }\n    };\n  }, [scale, viewBounds, isMounted]);\n\n  const previousFocus = usePrevious(focus);\n\n  // We need to update the state in case need to focus on something but we want to do it only once when the focus\n  // changes to something new.\n  useEffect(() => {\n    if (focus && previousFocus?.x !== focus.x && previousFocus?.y !== focus.y) {\n      const position = {\n        x: inBounds(focus.x, viewBounds.left, viewBounds.right),\n        y: inBounds(focus.y, viewBounds.top, viewBounds.bottom),\n      };\n      setState({\n        position,\n        isPanning: false,\n      });\n\n      currentPosition.current = position;\n      prevPosition.current = position;\n    }\n  }, [focus, previousFocus, viewBounds, currentPosition, prevPosition]);\n\n  let position = state.position;\n  // This part prevents an ugly jump from initial position to the focused one as the set state in the effects is after\n  // initial render.\n  if (focus && previousFocus?.x !== focus.x && previousFocus?.y !== focus.y) {\n    position = focus;\n  }\n\n  return {\n    state: {\n      ...state,\n      position: {\n        x: inBounds(position.x, viewBounds.left, viewBounds.right),\n        y: inBounds(position.y, viewBounds.top, viewBounds.bottom),\n      },\n    },\n    ref: panRef,\n  };\n}\n\nfunction inBounds(value: number, min: number | undefined, max: number | undefined) {\n  return Math.min(Math.max(value, min ?? -Infinity), max ?? Infinity);\n}\n\nfunction getEventXY(event: Event): { x: number; y: number } {\n  if ((event as any).changedTouches) {\n    const e = event as TouchEvent;\n    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };\n  } else {\n    const e = event as MouseEvent;\n    return { x: e.clientX, y: e.clientY };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}