{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport EventEmitter from 'eventemitter3';\nimport { Observable } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n/**\n * @alpha\n */\nexport class EventBusSrv {\n  constructor() {\n    _defineProperty(this, \"emitter\", void 0);\n\n    this.emitter = new EventEmitter();\n  }\n\n  publish(event) {\n    this.emitter.emit(event.type, event);\n  }\n\n  subscribe(typeFilter, handler) {\n    return this.getStream(typeFilter).subscribe({\n      next: handler\n    });\n  }\n\n  getStream(eventType) {\n    return new Observable(observer => {\n      const handler = event => {\n        observer.next(event);\n      };\n\n      this.emitter.on(eventType.type, handler);\n      return () => {\n        this.emitter.off(eventType.type, handler);\n      };\n    });\n  }\n\n  newScopedBus(key, filter) {\n    return new ScopedEventBus([key], this, filter);\n  }\n  /**\n   * Legacy functions\n   */\n\n\n  emit(event, payload) {\n    // console.log(`Deprecated emitter function used (emit), use $emit`);\n    if (typeof event === 'string') {\n      this.emitter.emit(event, {\n        type: event,\n        payload\n      });\n    } else {\n      this.emitter.emit(event.name, {\n        type: event.name,\n        payload\n      });\n    }\n  }\n\n  on(event, handler, scope) {\n    // console.log(`Deprecated emitter function used (on), use $on`);\n    // need this wrapper to make old events compatible with old handlers\n    handler.wrapper = emittedEvent => {\n      handler(emittedEvent.payload);\n    };\n\n    if (typeof event === 'string') {\n      this.emitter.on(event, handler.wrapper);\n    } else {\n      this.emitter.on(event.name, handler.wrapper);\n    }\n\n    if (scope) {\n      const unbind = scope.$on('$destroy', () => {\n        this.off(event, handler);\n        unbind();\n      });\n    }\n  }\n\n  off(event, handler) {\n    if (typeof event === 'string') {\n      this.emitter.off(event, handler.wrapper);\n      return;\n    }\n\n    this.emitter.off(event.name, handler.wrapper);\n  }\n\n  removeAllListeners() {\n    this.emitter.removeAllListeners();\n  }\n\n}\n/**\n * Wraps EventBus and adds a source to help with identifying if a subscriber should react to the event or not.\n */\n\nclass ScopedEventBus {\n  // will be mutated by panel runners\n  // The path is not yet exposed, but can be used to indicate nested groups and support faster filtering\n  constructor(path, eventBus, filter) {\n    _defineProperty(this, \"filterConfig\", void 0);\n\n    _defineProperty(this, \"filter\", event => {\n      if (this.filterConfig.onlyLocal) {\n        return event.origin === this;\n      }\n\n      return true;\n    });\n\n    this.path = path;\n    this.eventBus = eventBus;\n    this.filterConfig = filter !== null && filter !== void 0 ? filter : {\n      onlyLocal: false\n    };\n  }\n\n  publish(event) {\n    if (!event.origin) {\n      event.origin = this;\n    }\n\n    this.eventBus.publish(event);\n  }\n\n  getStream(eventType) {\n    return this.eventBus.getStream(eventType).pipe(filter(this.filter));\n  } // syntax sugar\n\n\n  subscribe(typeFilter, handler) {\n    return this.getStream(typeFilter).subscribe({\n      next: handler\n    });\n  }\n\n  removeAllListeners() {\n    this.eventBus.removeAllListeners();\n  }\n  /**\n   * Creates a nested event bus structure\n   */\n\n\n  newScopedBus(key, filter) {\n    return new ScopedEventBus([...this.path, key], this, filter);\n  }\n\n}","map":{"version":3,"names":["EventEmitter","Observable","filter","EventBusSrv","constructor","emitter","publish","event","emit","type","subscribe","typeFilter","handler","getStream","next","eventType","observer","on","off","newScopedBus","key","ScopedEventBus","payload","name","scope","wrapper","emittedEvent","unbind","$on","removeAllListeners","path","eventBus","filterConfig","onlyLocal","origin","pipe"],"sources":["/home/soula/grafana/packages/grafana-data/src/events/EventBus.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { Unsubscribable, Observable } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nimport {\n  EventBus,\n  LegacyEmitter,\n  BusEventHandler,\n  BusEventType,\n  LegacyEventHandler,\n  BusEvent,\n  AppEvent,\n  EventFilterOptions,\n} from './types';\n\n/**\n * @alpha\n */\nexport class EventBusSrv implements EventBus, LegacyEmitter {\n  private emitter: EventEmitter;\n\n  constructor() {\n    this.emitter = new EventEmitter();\n  }\n\n  publish<T extends BusEvent>(event: T): void {\n    this.emitter.emit(event.type, event);\n  }\n\n  subscribe<T extends BusEvent>(typeFilter: BusEventType<T>, handler: BusEventHandler<T>): Unsubscribable {\n    return this.getStream(typeFilter).subscribe({ next: handler });\n  }\n\n  getStream<T extends BusEvent>(eventType: BusEventType<T>): Observable<T> {\n    return new Observable<T>((observer) => {\n      const handler = (event: T) => {\n        observer.next(event);\n      };\n\n      this.emitter.on(eventType.type, handler);\n\n      return () => {\n        this.emitter.off(eventType.type, handler);\n      };\n    });\n  }\n\n  newScopedBus(key: string, filter?: EventFilterOptions): EventBus {\n    return new ScopedEventBus([key], this, filter);\n  }\n\n  /**\n   * Legacy functions\n   */\n  emit<T>(event: AppEvent<T> | string, payload?: T | any): void {\n    // console.log(`Deprecated emitter function used (emit), use $emit`);\n\n    if (typeof event === 'string') {\n      this.emitter.emit(event, { type: event, payload });\n    } else {\n      this.emitter.emit(event.name, { type: event.name, payload });\n    }\n  }\n\n  on<T>(event: AppEvent<T> | string, handler: LegacyEventHandler<T>, scope?: any) {\n    // console.log(`Deprecated emitter function used (on), use $on`);\n\n    // need this wrapper to make old events compatible with old handlers\n    handler.wrapper = (emittedEvent: BusEvent) => {\n      handler(emittedEvent.payload);\n    };\n\n    if (typeof event === 'string') {\n      this.emitter.on(event, handler.wrapper);\n    } else {\n      this.emitter.on(event.name, handler.wrapper);\n    }\n\n    if (scope) {\n      const unbind = scope.$on('$destroy', () => {\n        this.off(event, handler);\n        unbind();\n      });\n    }\n  }\n\n  off<T>(event: AppEvent<T> | string, handler: LegacyEventHandler<T>) {\n    if (typeof event === 'string') {\n      this.emitter.off(event, handler.wrapper);\n      return;\n    }\n\n    this.emitter.off(event.name, handler.wrapper);\n  }\n\n  removeAllListeners() {\n    this.emitter.removeAllListeners();\n  }\n}\n\n/**\n * Wraps EventBus and adds a source to help with identifying if a subscriber should react to the event or not.\n */\nclass ScopedEventBus implements EventBus {\n  // will be mutated by panel runners\n  filterConfig: EventFilterOptions;\n\n  // The path is not yet exposed, but can be used to indicate nested groups and support faster filtering\n  constructor(public path: string[], private eventBus: EventBus, filter?: EventFilterOptions) {\n    this.filterConfig = filter ?? { onlyLocal: false };\n  }\n\n  publish<T extends BusEvent>(event: T): void {\n    if (!event.origin) {\n      (event as any).origin = this;\n    }\n    this.eventBus.publish(event);\n  }\n\n  filter = (event: BusEvent) => {\n    if (this.filterConfig.onlyLocal) {\n      return event.origin === this;\n    }\n    return true;\n  };\n\n  getStream<T extends BusEvent>(eventType: BusEventType<T>): Observable<T> {\n    return this.eventBus.getStream(eventType).pipe(filter(this.filter)) as Observable<T>;\n  }\n\n  // syntax sugar\n  subscribe<T extends BusEvent>(typeFilter: BusEventType<T>, handler: BusEventHandler<T>): Unsubscribable {\n    return this.getStream(typeFilter).subscribe({ next: handler });\n  }\n\n  removeAllListeners(): void {\n    this.eventBus.removeAllListeners();\n  }\n\n  /**\n   * Creates a nested event bus structure\n   */\n  newScopedBus(key: string, filter: EventFilterOptions): EventBus {\n    return new ScopedEventBus([...this.path, key], this, filter);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}