{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { cloneDeep, defaultsDeep, isArray, isEqual, keys } from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport { DataLinkBuiltInVars, EventBusSrv, urlUtil } from '@grafana/data';\nimport { getTemplateSrv, RefreshEvent } from '@grafana/runtime';\nimport config from 'app/core/config';\nimport { getNextRefIdChar } from 'app/core/utils/query';\nimport { PanelOptionsChangedEvent, PanelQueriesChangedEvent, PanelTransformationsChangedEvent, RenderEvent } from 'app/types/events';\nimport { PanelQueryRunner } from '../../query/state/PanelQueryRunner';\nimport { getVariablesUrlParams } from '../../variables/getAllVariableValuesForUrl';\nimport { getTimeSrv } from '../services/TimeSrv';\nimport { filterFieldConfigOverrides, getPanelOptionsWithDefaults, isStandardFieldProp, restoreCustomOverrideRules } from './getPanelOptionsWithDefaults';\nconst notPersistedProperties = {\n  events: true,\n  isViewing: true,\n  isEditing: true,\n  isInView: true,\n  hasRefreshed: true,\n  cachedPluginOptions: true,\n  plugin: true,\n  queryRunner: true,\n  replaceVariables: true,\n  configRev: true,\n  getDisplayTitle: true,\n  dataSupport: true,\n  key: true\n}; // For angular panels we need to clean up properties when changing type\n// To make sure the change happens without strange bugs happening when panels use same\n// named property with different type / value expectations\n// This is not required for react panels\n\nconst mustKeepProps = {\n  id: true,\n  gridPos: true,\n  type: true,\n  title: true,\n  scopedVars: true,\n  repeat: true,\n  repeatIteration: true,\n  repeatPanelId: true,\n  repeatDirection: true,\n  repeatedByRow: true,\n  minSpan: true,\n  collapsed: true,\n  panels: true,\n  targets: true,\n  datasource: true,\n  timeFrom: true,\n  timeShift: true,\n  hideTimeOverride: true,\n  description: true,\n  links: true,\n  fullscreen: true,\n  isEditing: true,\n  hasRefreshed: true,\n  events: true,\n  cacheTimeout: true,\n  cachedPluginOptions: true,\n  transparent: true,\n  pluginVersion: true,\n  queryRunner: true,\n  transformations: true,\n  fieldConfig: true,\n  maxDataPoints: true,\n  interval: true,\n  replaceVariables: true,\n  libraryPanel: true,\n  getDisplayTitle: true,\n  configRev: true,\n  key: true\n};\nconst defaults = {\n  gridPos: {\n    x: 0,\n    y: 0,\n    h: 3,\n    w: 6\n  },\n  targets: [{\n    refId: 'A'\n  }],\n  cachedPluginOptions: {},\n  transparent: false,\n  options: {},\n  fieldConfig: {\n    defaults: {},\n    overrides: []\n  },\n  title: ''\n};\nexport class PanelModel {\n  /* persisted id, used in URL to identify a panel */\n  // non persisted\n  // increments when configs change\n\n  /**\n   * Unique in application state, this is used as redux key for panel and for redux panel state\n   * Change will cause unmount and re-init of panel\n   */\n\n  /**\n   * The PanelModel event bus only used for internal and legacy angular support.\n   * The EventBus passed to panels is based on the dashboard event model.\n   */\n  constructor(model) {\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"gridPos\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"title\", void 0);\n\n    _defineProperty(this, \"alert\", void 0);\n\n    _defineProperty(this, \"scopedVars\", void 0);\n\n    _defineProperty(this, \"repeat\", void 0);\n\n    _defineProperty(this, \"repeatIteration\", void 0);\n\n    _defineProperty(this, \"repeatPanelId\", void 0);\n\n    _defineProperty(this, \"repeatDirection\", void 0);\n\n    _defineProperty(this, \"repeatedByRow\", void 0);\n\n    _defineProperty(this, \"maxPerRow\", void 0);\n\n    _defineProperty(this, \"collapsed\", void 0);\n\n    _defineProperty(this, \"panels\", void 0);\n\n    _defineProperty(this, \"transformations\", void 0);\n\n    _defineProperty(this, \"datasource\", null);\n\n    _defineProperty(this, \"thresholds\", void 0);\n\n    _defineProperty(this, \"pluginVersion\", void 0);\n\n    _defineProperty(this, \"snapshotData\", void 0);\n\n    _defineProperty(this, \"timeFrom\", void 0);\n\n    _defineProperty(this, \"timeShift\", void 0);\n\n    _defineProperty(this, \"hideTimeOverride\", void 0);\n\n    _defineProperty(this, \"maxDataPoints\", void 0);\n\n    _defineProperty(this, \"interval\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"links\", void 0);\n\n    _defineProperty(this, \"libraryPanel\", void 0);\n\n    _defineProperty(this, \"autoMigrateFrom\", void 0);\n\n    _defineProperty(this, \"isViewing\", false);\n\n    _defineProperty(this, \"isEditing\", false);\n\n    _defineProperty(this, \"isInView\", false);\n\n    _defineProperty(this, \"configRev\", 0);\n\n    _defineProperty(this, \"hasRefreshed\", void 0);\n\n    _defineProperty(this, \"cacheTimeout\", void 0);\n\n    _defineProperty(this, \"cachedPluginOptions\", {});\n\n    _defineProperty(this, \"legend\", void 0);\n\n    _defineProperty(this, \"plugin\", void 0);\n\n    _defineProperty(this, \"key\", void 0);\n\n    _defineProperty(this, \"events\", void 0);\n\n    _defineProperty(this, \"queryRunner\", void 0);\n\n    this.events = new EventBusSrv();\n    this.restoreModel(model);\n    this.replaceVariables = this.replaceVariables.bind(this);\n    this.key = uuidv4();\n  }\n  /** Given a persistened PanelModel restores property values */\n\n\n  restoreModel(model) {\n    var _config$featureToggle;\n\n    // Start with clean-up\n    for (const property in this) {\n      if (notPersistedProperties[property] || !this.hasOwnProperty(property)) {\n        continue;\n      }\n\n      if (model[property]) {\n        continue;\n      }\n\n      if (typeof this[property] === 'function') {\n        continue;\n      }\n\n      if (typeof this[property] === 'symbol') {\n        continue;\n      }\n\n      delete this[property];\n    } // copy properties from persisted model\n\n\n    for (const property in model) {\n      this[property] = model[property];\n    }\n\n    switch (this.type) {\n      case 'graph':\n        if (config !== null && config !== void 0 && (_config$featureToggle = config.featureToggles) !== null && _config$featureToggle !== void 0 && _config$featureToggle.autoMigrateGraphPanels) {\n          this.autoMigrateFrom = this.type;\n          this.type = 'timeseries';\n        }\n\n        break;\n\n      case 'heatmap-new':\n        this.autoMigrateFrom = this.type;\n        this.type = 'heatmap';\n        break;\n    } // defaults\n\n\n    defaultsDeep(this, cloneDeep(defaults)); // queries must have refId\n\n    this.ensureQueryIds();\n  }\n\n  generateNewKey() {\n    this.key = uuidv4();\n  }\n\n  ensureQueryIds() {\n    if (this.targets && isArray(this.targets)) {\n      for (const query of this.targets) {\n        if (!query.refId) {\n          query.refId = getNextRefIdChar(this.targets);\n        }\n      }\n    }\n  }\n\n  getOptions() {\n    return this.options;\n  }\n\n  get hasChanged() {\n    return this.configRev > 0;\n  }\n\n  updateOptions(options) {\n    this.options = options;\n    this.configRev++;\n    this.events.publish(new PanelOptionsChangedEvent());\n    this.render();\n  }\n\n  updateFieldConfig(config) {\n    this.fieldConfig = config;\n    this.configRev++;\n    this.events.publish(new PanelOptionsChangedEvent());\n    this.resendLastResult();\n    this.render();\n  }\n\n  getSaveModel() {\n    const model = {};\n\n    for (const property in this) {\n      if (notPersistedProperties[property] || !this.hasOwnProperty(property)) {\n        continue;\n      }\n\n      if (isEqual(this[property], defaults[property])) {\n        continue;\n      }\n\n      model[property] = cloneDeep(this[property]);\n    }\n\n    return model;\n  }\n\n  setIsViewing(isViewing) {\n    this.isViewing = isViewing;\n  }\n\n  updateGridPos(newPos) {\n    if (newPos.x === this.gridPos.x && newPos.y === this.gridPos.y && newPos.h === this.gridPos.h && newPos.w === this.gridPos.w) {\n      return;\n    }\n\n    this.gridPos.x = newPos.x;\n    this.gridPos.y = newPos.y;\n    this.gridPos.w = newPos.w;\n    this.gridPos.h = newPos.h;\n    this.configRev++;\n  }\n\n  runAllPanelQueries(dashboardId, dashboardTimezone, timeData, width, publicDashboardAccessToken) {\n    this.getQueryRunner().run({\n      datasource: this.datasource,\n      queries: this.targets,\n      panelId: this.id,\n      dashboardId: dashboardId,\n      publicDashboardAccessToken,\n      timezone: dashboardTimezone,\n      timeRange: timeData.timeRange,\n      timeInfo: timeData.timeInfo,\n      maxDataPoints: this.maxDataPoints || Math.floor(width),\n      minInterval: this.interval,\n      scopedVars: this.scopedVars,\n      cacheTimeout: this.cacheTimeout,\n      transformations: this.transformations\n    });\n  }\n\n  refresh() {\n    this.hasRefreshed = true;\n    this.events.publish(new RefreshEvent());\n  }\n\n  render() {\n    if (!this.hasRefreshed) {\n      this.refresh();\n    } else {\n      this.events.publish(new RenderEvent());\n    }\n  }\n\n  getOptionsToRemember() {\n    return Object.keys(this).reduce((acc, property) => {\n      if (notPersistedProperties[property] || mustKeepProps[property]) {\n        return acc;\n      }\n\n      return Object.assign({}, acc, {\n        [property]: this[property]\n      });\n    }, {});\n  }\n\n  restorePanelOptions(pluginId) {\n    const prevOptions = this.cachedPluginOptions[pluginId];\n\n    if (!prevOptions) {\n      return;\n    }\n\n    Object.keys(prevOptions.properties).map(property => {\n      this[property] = prevOptions.properties[property];\n    });\n    this.fieldConfig = restoreCustomOverrideRules(this.fieldConfig, prevOptions.fieldConfig);\n  }\n\n  applyPluginOptionDefaults(plugin, isAfterPluginChange) {\n    const options = getPanelOptionsWithDefaults({\n      plugin,\n      currentOptions: this.options,\n      currentFieldConfig: this.fieldConfig,\n      isAfterPluginChange: isAfterPluginChange\n    });\n    this.fieldConfig = options.fieldConfig;\n    this.options = options.options;\n  }\n\n  pluginLoaded(plugin) {\n    this.plugin = plugin;\n    const version = getPluginVersion(plugin);\n\n    if (this.autoMigrateFrom) {\n      const wasAngular = this.autoMigrateFrom === 'graph';\n      this.callPanelTypeChangeHandler(plugin, this.autoMigrateFrom, this.getOptionsToRemember(), // old options\n      wasAngular);\n      delete this.autoMigrateFrom;\n    }\n\n    if (plugin.onPanelMigration) {\n      if (version !== this.pluginVersion) {\n        this.options = plugin.onPanelMigration(this);\n        this.pluginVersion = version;\n      }\n    }\n\n    this.applyPluginOptionDefaults(plugin, false);\n    this.resendLastResult();\n  }\n\n  clearPropertiesBeforePluginChange() {\n    // remove panel type specific  options\n    for (const key of keys(this)) {\n      if (mustKeepProps[key]) {\n        continue;\n      }\n\n      delete this[key];\n    }\n\n    this.options = {}; // clear custom options\n\n    this.fieldConfig = {\n      defaults: Object.assign({}, this.fieldConfig.defaults, {\n        custom: {}\n      }),\n      // filter out custom overrides\n      overrides: filterFieldConfigOverrides(this.fieldConfig.overrides, isStandardFieldProp)\n    };\n  } // Let panel plugins inspect options from previous panel and keep any that it can use\n\n\n  callPanelTypeChangeHandler(newPlugin, oldPluginId, oldOptions, wasAngular) {\n    if (newPlugin.onPanelTypeChanged) {\n      const prevOptions = wasAngular ? {\n        angular: oldOptions\n      } : oldOptions.options;\n      Object.assign(this.options, newPlugin.onPanelTypeChanged(this, oldPluginId, prevOptions, this.fieldConfig));\n    }\n  }\n\n  changePlugin(newPlugin) {\n    const pluginId = newPlugin.meta.id;\n    const oldOptions = this.getOptionsToRemember();\n    const prevFieldConfig = this.fieldConfig;\n    const oldPluginId = this.type;\n    const wasAngular = this.isAngularPlugin();\n    this.cachedPluginOptions[oldPluginId] = {\n      properties: oldOptions,\n      fieldConfig: prevFieldConfig\n    };\n    this.clearPropertiesBeforePluginChange();\n    this.restorePanelOptions(pluginId); // Potentially modify current options\n\n    this.callPanelTypeChangeHandler(newPlugin, oldPluginId, oldOptions, wasAngular); // switch\n\n    this.type = pluginId;\n    this.plugin = newPlugin;\n    this.configRev++;\n    this.applyPluginOptionDefaults(newPlugin, true);\n\n    if (newPlugin.onPanelMigration) {\n      this.pluginVersion = getPluginVersion(newPlugin);\n    }\n  }\n\n  updateQueries(options) {\n    var _options$timeRange, _options$timeRange2, _options$timeRange3;\n\n    const {\n      dataSource\n    } = options;\n    this.datasource = {\n      uid: dataSource.uid,\n      type: dataSource.type\n    };\n    this.cacheTimeout = options.cacheTimeout;\n    this.timeFrom = (_options$timeRange = options.timeRange) === null || _options$timeRange === void 0 ? void 0 : _options$timeRange.from;\n    this.timeShift = (_options$timeRange2 = options.timeRange) === null || _options$timeRange2 === void 0 ? void 0 : _options$timeRange2.shift;\n    this.hideTimeOverride = (_options$timeRange3 = options.timeRange) === null || _options$timeRange3 === void 0 ? void 0 : _options$timeRange3.hide;\n    this.interval = options.minInterval;\n    this.maxDataPoints = options.maxDataPoints;\n    this.targets = options.queries;\n    this.configRev++;\n    this.events.publish(new PanelQueriesChangedEvent());\n  }\n\n  addQuery(query) {\n    query = query || {\n      refId: 'A'\n    };\n    query.refId = getNextRefIdChar(this.targets);\n    this.targets.push(query);\n    this.configRev++;\n  }\n\n  changeQuery(query, index) {\n    // ensure refId is maintained\n    query.refId = this.targets[index].refId;\n    this.configRev++; // update query in array\n\n    this.targets = this.targets.map((item, itemIndex) => {\n      if (itemIndex === index) {\n        return query;\n      }\n\n      return item;\n    });\n  }\n\n  getEditClone() {\n    const sourceModel = this.getSaveModel();\n    const clone = new PanelModel(sourceModel);\n    clone.isEditing = true;\n    const sourceQueryRunner = this.getQueryRunner(); // Copy last query result\n\n    clone.getQueryRunner().useLastResultFrom(sourceQueryRunner);\n    return clone;\n  }\n\n  getTransformations() {\n    return this.transformations;\n  }\n\n  getFieldOverrideOptions() {\n    if (!this.plugin) {\n      return undefined;\n    }\n\n    return {\n      fieldConfig: this.fieldConfig,\n      replaceVariables: this.replaceVariables,\n      fieldConfigRegistry: this.plugin.fieldConfigRegistry,\n      theme: config.theme2\n    };\n  }\n\n  getDataSupport() {\n    var _this$plugin$dataSupp, _this$plugin;\n\n    return (_this$plugin$dataSupp = (_this$plugin = this.plugin) === null || _this$plugin === void 0 ? void 0 : _this$plugin.dataSupport) !== null && _this$plugin$dataSupp !== void 0 ? _this$plugin$dataSupp : {\n      annotations: false,\n      alertStates: false\n    };\n  }\n\n  getQueryRunner() {\n    if (!this.queryRunner) {\n      this.queryRunner = new PanelQueryRunner(this);\n    }\n\n    return this.queryRunner;\n  }\n\n  hasTitle() {\n    return this.title && this.title.length > 0;\n  }\n\n  isAngularPlugin() {\n    return (this.plugin && this.plugin.angularPanelCtrl) !== undefined;\n  }\n\n  destroy() {\n    this.events.removeAllListeners();\n\n    if (this.queryRunner) {\n      this.queryRunner.destroy();\n    }\n  }\n\n  setTransformations(transformations) {\n    this.transformations = transformations;\n    this.resendLastResult();\n    this.configRev++;\n    this.events.publish(new PanelTransformationsChangedEvent());\n  }\n\n  setProperty(key, value) {\n    this[key] = value;\n    this.configRev++; // Custom handling of repeat dependent options, handled here as PanelEditor can\n    // update one key at a time right now\n\n    if (key === 'repeat') {\n      if (this.repeat && !this.repeatDirection) {\n        this.repeatDirection = 'h';\n      } else if (!this.repeat) {\n        delete this.repeatDirection;\n        delete this.maxPerRow;\n      }\n    }\n  }\n\n  replaceVariables(value, extraVars, format) {\n    const lastRequest = this.getQueryRunner().getLastRequest();\n    const vars = Object.assign({}, this.scopedVars, lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.scopedVars, extraVars);\n    const allVariablesParams = getVariablesUrlParams(vars);\n    const variablesQuery = urlUtil.toUrlParams(allVariablesParams);\n    const timeRangeUrl = urlUtil.toUrlParams(getTimeSrv().timeRangeForUrl());\n    vars[DataLinkBuiltInVars.keepTime] = {\n      text: timeRangeUrl,\n      value: timeRangeUrl\n    };\n    vars[DataLinkBuiltInVars.includeVars] = {\n      text: variablesQuery,\n      value: variablesQuery\n    };\n    return getTemplateSrv().replace(value, vars, format);\n  }\n\n  resendLastResult() {\n    if (!this.plugin) {\n      return;\n    }\n\n    this.getQueryRunner().resendLastResult();\n  }\n  /*\n   * This is the title used when displaying the title in the UI so it will include any interpolated variables.\n   * If you need the raw title without interpolation use title property instead.\n   * */\n\n\n  getDisplayTitle() {\n    return this.replaceVariables(this.title, undefined, 'text');\n  }\n\n}\n\nfunction getPluginVersion(plugin) {\n  return plugin && plugin.meta.info.version ? plugin.meta.info.version : config.buildInfo.version;\n}","map":{"version":3,"names":["cloneDeep","defaultsDeep","isArray","isEqual","keys","v4","uuidv4","DataLinkBuiltInVars","EventBusSrv","urlUtil","getTemplateSrv","RefreshEvent","config","getNextRefIdChar","PanelOptionsChangedEvent","PanelQueriesChangedEvent","PanelTransformationsChangedEvent","RenderEvent","PanelQueryRunner","getVariablesUrlParams","getTimeSrv","filterFieldConfigOverrides","getPanelOptionsWithDefaults","isStandardFieldProp","restoreCustomOverrideRules","notPersistedProperties","events","isViewing","isEditing","isInView","hasRefreshed","cachedPluginOptions","plugin","queryRunner","replaceVariables","configRev","getDisplayTitle","dataSupport","key","mustKeepProps","id","gridPos","type","title","scopedVars","repeat","repeatIteration","repeatPanelId","repeatDirection","repeatedByRow","minSpan","collapsed","panels","targets","datasource","timeFrom","timeShift","hideTimeOverride","description","links","fullscreen","cacheTimeout","transparent","pluginVersion","transformations","fieldConfig","maxDataPoints","interval","libraryPanel","defaults","x","y","h","w","refId","options","overrides","PanelModel","constructor","model","restoreModel","bind","property","hasOwnProperty","featureToggles","autoMigrateGraphPanels","autoMigrateFrom","ensureQueryIds","generateNewKey","query","getOptions","hasChanged","updateOptions","publish","render","updateFieldConfig","resendLastResult","getSaveModel","setIsViewing","updateGridPos","newPos","runAllPanelQueries","dashboardId","dashboardTimezone","timeData","width","publicDashboardAccessToken","getQueryRunner","run","queries","panelId","timezone","timeRange","timeInfo","Math","floor","minInterval","refresh","getOptionsToRemember","Object","reduce","acc","restorePanelOptions","pluginId","prevOptions","properties","map","applyPluginOptionDefaults","isAfterPluginChange","currentOptions","currentFieldConfig","pluginLoaded","version","getPluginVersion","wasAngular","callPanelTypeChangeHandler","onPanelMigration","clearPropertiesBeforePluginChange","custom","newPlugin","oldPluginId","oldOptions","onPanelTypeChanged","angular","assign","changePlugin","meta","prevFieldConfig","isAngularPlugin","updateQueries","dataSource","uid","from","shift","hide","addQuery","push","changeQuery","index","item","itemIndex","getEditClone","sourceModel","clone","sourceQueryRunner","useLastResultFrom","getTransformations","getFieldOverrideOptions","undefined","fieldConfigRegistry","theme","theme2","getDataSupport","annotations","alertStates","hasTitle","length","angularPanelCtrl","destroy","removeAllListeners","setTransformations","setProperty","value","maxPerRow","extraVars","format","lastRequest","getLastRequest","vars","allVariablesParams","variablesQuery","toUrlParams","timeRangeUrl","timeRangeForUrl","keepTime","text","includeVars","replace","info","buildInfo"],"sources":["/home/soula/grafana/public/app/features/dashboard/state/PanelModel.ts"],"sourcesContent":["import { cloneDeep, defaultsDeep, isArray, isEqual, keys } from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport {\n  DataConfigSource,\n  DataFrameDTO,\n  DataLink,\n  DataLinkBuiltInVars,\n  DataQuery,\n  DataTransformerConfig,\n  EventBusSrv,\n  FieldConfigSource,\n  PanelPlugin,\n  PanelPluginDataSupport,\n  ScopedVars,\n  urlUtil,\n  PanelModel as IPanelModel,\n  DataSourceRef,\n} from '@grafana/data';\nimport { getTemplateSrv, RefreshEvent } from '@grafana/runtime';\nimport config from 'app/core/config';\nimport { getNextRefIdChar } from 'app/core/utils/query';\nimport { QueryGroupOptions } from 'app/types';\nimport {\n  PanelOptionsChangedEvent,\n  PanelQueriesChangedEvent,\n  PanelTransformationsChangedEvent,\n  RenderEvent,\n} from 'app/types/events';\n\nimport { PanelModelLibraryPanel } from '../../library-panels/types';\nimport { PanelQueryRunner } from '../../query/state/PanelQueryRunner';\nimport { getVariablesUrlParams } from '../../variables/getAllVariableValuesForUrl';\nimport { getTimeSrv } from '../services/TimeSrv';\nimport { TimeOverrideResult } from '../utils/panel';\n\nimport {\n  filterFieldConfigOverrides,\n  getPanelOptionsWithDefaults,\n  isStandardFieldProp,\n  restoreCustomOverrideRules,\n} from './getPanelOptionsWithDefaults';\n\nexport interface GridPos {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n  static?: boolean;\n}\n\nconst notPersistedProperties: { [str: string]: boolean } = {\n  events: true,\n  isViewing: true,\n  isEditing: true,\n  isInView: true,\n  hasRefreshed: true,\n  cachedPluginOptions: true,\n  plugin: true,\n  queryRunner: true,\n  replaceVariables: true,\n  configRev: true,\n  getDisplayTitle: true,\n  dataSupport: true,\n  key: true,\n};\n\n// For angular panels we need to clean up properties when changing type\n// To make sure the change happens without strange bugs happening when panels use same\n// named property with different type / value expectations\n// This is not required for react panels\nconst mustKeepProps: { [str: string]: boolean } = {\n  id: true,\n  gridPos: true,\n  type: true,\n  title: true,\n  scopedVars: true,\n  repeat: true,\n  repeatIteration: true,\n  repeatPanelId: true,\n  repeatDirection: true,\n  repeatedByRow: true,\n  minSpan: true,\n  collapsed: true,\n  panels: true,\n  targets: true,\n  datasource: true,\n  timeFrom: true,\n  timeShift: true,\n  hideTimeOverride: true,\n  description: true,\n  links: true,\n  fullscreen: true,\n  isEditing: true,\n  hasRefreshed: true,\n  events: true,\n  cacheTimeout: true,\n  cachedPluginOptions: true,\n  transparent: true,\n  pluginVersion: true,\n  queryRunner: true,\n  transformations: true,\n  fieldConfig: true,\n  maxDataPoints: true,\n  interval: true,\n  replaceVariables: true,\n  libraryPanel: true,\n  getDisplayTitle: true,\n  configRev: true,\n  key: true,\n};\n\nconst defaults: any = {\n  gridPos: { x: 0, y: 0, h: 3, w: 6 },\n  targets: [{ refId: 'A' }],\n  cachedPluginOptions: {},\n  transparent: false,\n  options: {},\n  fieldConfig: {\n    defaults: {},\n    overrides: [],\n  },\n  title: '',\n};\n\nexport class PanelModel implements DataConfigSource, IPanelModel {\n  /* persisted id, used in URL to identify a panel */\n  id!: number;\n  gridPos!: GridPos;\n  type!: string;\n  title!: string;\n  alert?: any;\n  scopedVars?: ScopedVars;\n  repeat?: string;\n  repeatIteration?: number;\n  repeatPanelId?: number;\n  repeatDirection?: string;\n  repeatedByRow?: boolean;\n  maxPerRow?: number;\n  collapsed?: boolean;\n\n  panels?: PanelModel[];\n  declare targets: DataQuery[];\n  transformations?: DataTransformerConfig[];\n  datasource: DataSourceRef | null = null;\n  thresholds?: any;\n  pluginVersion?: string;\n\n  snapshotData?: DataFrameDTO[];\n  timeFrom?: any;\n  timeShift?: any;\n  hideTimeOverride?: any;\n  declare options: {\n    [key: string]: any;\n  };\n  declare fieldConfig: FieldConfigSource;\n\n  maxDataPoints?: number | null;\n  interval?: string | null;\n  description?: string;\n  links?: DataLink[];\n  declare transparent: boolean;\n\n  libraryPanel?: { uid: undefined; name: string } | PanelModelLibraryPanel;\n\n  autoMigrateFrom?: string;\n\n  // non persisted\n  isViewing = false;\n  isEditing = false;\n  isInView = false;\n  configRev = 0; // increments when configs change\n  hasRefreshed?: boolean;\n  cacheTimeout?: string | null;\n  cachedPluginOptions: Record<string, PanelOptionsCache> = {};\n  legend?: { show: boolean; sort?: string; sortDesc?: boolean };\n  plugin?: PanelPlugin;\n  /**\n   * Unique in application state, this is used as redux key for panel and for redux panel state\n   * Change will cause unmount and re-init of panel\n   */\n  key: string;\n\n  /**\n   * The PanelModel event bus only used for internal and legacy angular support.\n   * The EventBus passed to panels is based on the dashboard event model.\n   */\n  events: EventBusSrv;\n\n  private queryRunner?: PanelQueryRunner;\n\n  constructor(model: any) {\n    this.events = new EventBusSrv();\n    this.restoreModel(model);\n    this.replaceVariables = this.replaceVariables.bind(this);\n    this.key = uuidv4();\n  }\n\n  /** Given a persistened PanelModel restores property values */\n  restoreModel(model: any) {\n    // Start with clean-up\n    for (const property in this) {\n      if (notPersistedProperties[property] || !this.hasOwnProperty(property)) {\n        continue;\n      }\n\n      if (model[property]) {\n        continue;\n      }\n\n      if (typeof (this as any)[property] === 'function') {\n        continue;\n      }\n\n      if (typeof (this as any)[property] === 'symbol') {\n        continue;\n      }\n\n      delete (this as any)[property];\n    }\n\n    // copy properties from persisted model\n    for (const property in model) {\n      (this as any)[property] = model[property];\n    }\n\n    switch (this.type) {\n      case 'graph':\n        if (config?.featureToggles?.autoMigrateGraphPanels) {\n          this.autoMigrateFrom = this.type;\n          this.type = 'timeseries';\n        }\n        break;\n      case 'heatmap-new':\n        this.autoMigrateFrom = this.type;\n        this.type = 'heatmap';\n        break;\n    }\n\n    // defaults\n    defaultsDeep(this, cloneDeep(defaults));\n\n    // queries must have refId\n    this.ensureQueryIds();\n  }\n\n  generateNewKey() {\n    this.key = uuidv4();\n  }\n\n  ensureQueryIds() {\n    if (this.targets && isArray(this.targets)) {\n      for (const query of this.targets) {\n        if (!query.refId) {\n          query.refId = getNextRefIdChar(this.targets);\n        }\n      }\n    }\n  }\n\n  getOptions() {\n    return this.options;\n  }\n\n  get hasChanged(): boolean {\n    return this.configRev > 0;\n  }\n\n  updateOptions(options: object) {\n    this.options = options;\n    this.configRev++;\n    this.events.publish(new PanelOptionsChangedEvent());\n    this.render();\n  }\n\n  updateFieldConfig(config: FieldConfigSource) {\n    this.fieldConfig = config;\n    this.configRev++;\n    this.events.publish(new PanelOptionsChangedEvent());\n\n    this.resendLastResult();\n    this.render();\n  }\n\n  getSaveModel() {\n    const model: any = {};\n\n    for (const property in this) {\n      if (notPersistedProperties[property] || !this.hasOwnProperty(property)) {\n        continue;\n      }\n\n      if (isEqual(this[property], defaults[property])) {\n        continue;\n      }\n\n      model[property] = cloneDeep(this[property]);\n    }\n\n    return model;\n  }\n\n  setIsViewing(isViewing: boolean) {\n    this.isViewing = isViewing;\n  }\n\n  updateGridPos(newPos: GridPos) {\n    if (\n      newPos.x === this.gridPos.x &&\n      newPos.y === this.gridPos.y &&\n      newPos.h === this.gridPos.h &&\n      newPos.w === this.gridPos.w\n    ) {\n      return;\n    }\n\n    this.gridPos.x = newPos.x;\n    this.gridPos.y = newPos.y;\n    this.gridPos.w = newPos.w;\n    this.gridPos.h = newPos.h;\n    this.configRev++;\n  }\n\n  runAllPanelQueries(\n    dashboardId: number,\n    dashboardTimezone: string,\n    timeData: TimeOverrideResult,\n    width: number,\n    publicDashboardAccessToken?: string\n  ) {\n    this.getQueryRunner().run({\n      datasource: this.datasource,\n      queries: this.targets,\n      panelId: this.id,\n      dashboardId: dashboardId,\n      publicDashboardAccessToken,\n      timezone: dashboardTimezone,\n      timeRange: timeData.timeRange,\n      timeInfo: timeData.timeInfo,\n      maxDataPoints: this.maxDataPoints || Math.floor(width),\n      minInterval: this.interval,\n      scopedVars: this.scopedVars,\n      cacheTimeout: this.cacheTimeout,\n      transformations: this.transformations,\n    });\n  }\n\n  refresh() {\n    this.hasRefreshed = true;\n    this.events.publish(new RefreshEvent());\n  }\n\n  render() {\n    if (!this.hasRefreshed) {\n      this.refresh();\n    } else {\n      this.events.publish(new RenderEvent());\n    }\n  }\n\n  private getOptionsToRemember() {\n    return Object.keys(this).reduce((acc, property) => {\n      if (notPersistedProperties[property] || mustKeepProps[property]) {\n        return acc;\n      }\n      return {\n        ...acc,\n        [property]: (this as any)[property],\n      };\n    }, {});\n  }\n\n  private restorePanelOptions(pluginId: string) {\n    const prevOptions = this.cachedPluginOptions[pluginId];\n\n    if (!prevOptions) {\n      return;\n    }\n\n    Object.keys(prevOptions.properties).map((property) => {\n      (this as any)[property] = prevOptions.properties[property];\n    });\n\n    this.fieldConfig = restoreCustomOverrideRules(this.fieldConfig, prevOptions.fieldConfig);\n  }\n\n  applyPluginOptionDefaults(plugin: PanelPlugin, isAfterPluginChange: boolean) {\n    const options = getPanelOptionsWithDefaults({\n      plugin,\n      currentOptions: this.options,\n      currentFieldConfig: this.fieldConfig,\n      isAfterPluginChange: isAfterPluginChange,\n    });\n\n    this.fieldConfig = options.fieldConfig;\n    this.options = options.options;\n  }\n\n  pluginLoaded(plugin: PanelPlugin) {\n    this.plugin = plugin;\n    const version = getPluginVersion(plugin);\n\n    if (this.autoMigrateFrom) {\n      const wasAngular = this.autoMigrateFrom === 'graph';\n      this.callPanelTypeChangeHandler(\n        plugin,\n        this.autoMigrateFrom,\n        this.getOptionsToRemember(), // old options\n        wasAngular\n      );\n\n      delete this.autoMigrateFrom;\n    }\n\n    if (plugin.onPanelMigration) {\n      if (version !== this.pluginVersion) {\n        this.options = plugin.onPanelMigration(this);\n        this.pluginVersion = version;\n      }\n    }\n\n    this.applyPluginOptionDefaults(plugin, false);\n    this.resendLastResult();\n  }\n\n  clearPropertiesBeforePluginChange() {\n    // remove panel type specific  options\n    for (const key of keys(this)) {\n      if (mustKeepProps[key]) {\n        continue;\n      }\n      delete (this as any)[key];\n    }\n\n    this.options = {};\n\n    // clear custom options\n    this.fieldConfig = {\n      defaults: {\n        ...this.fieldConfig.defaults,\n        custom: {},\n      },\n      // filter out custom overrides\n      overrides: filterFieldConfigOverrides(this.fieldConfig.overrides, isStandardFieldProp),\n    };\n  }\n\n  // Let panel plugins inspect options from previous panel and keep any that it can use\n  private callPanelTypeChangeHandler(\n    newPlugin: PanelPlugin,\n    oldPluginId: string,\n    oldOptions: any,\n    wasAngular: boolean\n  ) {\n    if (newPlugin.onPanelTypeChanged) {\n      const prevOptions = wasAngular ? { angular: oldOptions } : oldOptions.options;\n      Object.assign(this.options, newPlugin.onPanelTypeChanged(this, oldPluginId, prevOptions, this.fieldConfig));\n    }\n  }\n\n  changePlugin(newPlugin: PanelPlugin) {\n    const pluginId = newPlugin.meta.id;\n    const oldOptions: any = this.getOptionsToRemember();\n    const prevFieldConfig = this.fieldConfig;\n    const oldPluginId = this.type;\n    const wasAngular = this.isAngularPlugin();\n    this.cachedPluginOptions[oldPluginId] = {\n      properties: oldOptions,\n      fieldConfig: prevFieldConfig,\n    };\n\n    this.clearPropertiesBeforePluginChange();\n    this.restorePanelOptions(pluginId);\n\n    // Potentially modify current options\n    this.callPanelTypeChangeHandler(newPlugin, oldPluginId, oldOptions, wasAngular);\n\n    // switch\n    this.type = pluginId;\n    this.plugin = newPlugin;\n    this.configRev++;\n\n    this.applyPluginOptionDefaults(newPlugin, true);\n\n    if (newPlugin.onPanelMigration) {\n      this.pluginVersion = getPluginVersion(newPlugin);\n    }\n  }\n\n  updateQueries(options: QueryGroupOptions) {\n    const { dataSource } = options;\n    this.datasource = {\n      uid: dataSource.uid,\n      type: dataSource.type,\n    };\n    this.cacheTimeout = options.cacheTimeout;\n    this.timeFrom = options.timeRange?.from;\n    this.timeShift = options.timeRange?.shift;\n    this.hideTimeOverride = options.timeRange?.hide;\n    this.interval = options.minInterval;\n    this.maxDataPoints = options.maxDataPoints;\n    this.targets = options.queries;\n    this.configRev++;\n\n    this.events.publish(new PanelQueriesChangedEvent());\n  }\n\n  addQuery(query?: Partial<DataQuery>) {\n    query = query || { refId: 'A' };\n    query.refId = getNextRefIdChar(this.targets);\n    this.targets.push(query as DataQuery);\n    this.configRev++;\n  }\n\n  changeQuery(query: DataQuery, index: number) {\n    // ensure refId is maintained\n    query.refId = this.targets[index].refId;\n    this.configRev++;\n\n    // update query in array\n    this.targets = this.targets.map((item, itemIndex) => {\n      if (itemIndex === index) {\n        return query;\n      }\n      return item;\n    });\n  }\n\n  getEditClone() {\n    const sourceModel = this.getSaveModel();\n\n    const clone = new PanelModel(sourceModel);\n    clone.isEditing = true;\n\n    const sourceQueryRunner = this.getQueryRunner();\n\n    // Copy last query result\n    clone.getQueryRunner().useLastResultFrom(sourceQueryRunner);\n\n    return clone;\n  }\n\n  getTransformations() {\n    return this.transformations;\n  }\n\n  getFieldOverrideOptions() {\n    if (!this.plugin) {\n      return undefined;\n    }\n\n    return {\n      fieldConfig: this.fieldConfig,\n      replaceVariables: this.replaceVariables,\n      fieldConfigRegistry: this.plugin.fieldConfigRegistry,\n      theme: config.theme2,\n    };\n  }\n\n  getDataSupport(): PanelPluginDataSupport {\n    return this.plugin?.dataSupport ?? { annotations: false, alertStates: false };\n  }\n\n  getQueryRunner(): PanelQueryRunner {\n    if (!this.queryRunner) {\n      this.queryRunner = new PanelQueryRunner(this);\n    }\n    return this.queryRunner;\n  }\n\n  hasTitle() {\n    return this.title && this.title.length > 0;\n  }\n\n  isAngularPlugin(): boolean {\n    return (this.plugin && this.plugin.angularPanelCtrl) !== undefined;\n  }\n\n  destroy() {\n    this.events.removeAllListeners();\n\n    if (this.queryRunner) {\n      this.queryRunner.destroy();\n    }\n  }\n\n  setTransformations(transformations: DataTransformerConfig[]) {\n    this.transformations = transformations;\n    this.resendLastResult();\n    this.configRev++;\n    this.events.publish(new PanelTransformationsChangedEvent());\n  }\n\n  setProperty(key: keyof this, value: any) {\n    this[key] = value;\n    this.configRev++;\n\n    // Custom handling of repeat dependent options, handled here as PanelEditor can\n    // update one key at a time right now\n    if (key === 'repeat') {\n      if (this.repeat && !this.repeatDirection) {\n        this.repeatDirection = 'h';\n      } else if (!this.repeat) {\n        delete this.repeatDirection;\n        delete this.maxPerRow;\n      }\n    }\n  }\n\n  replaceVariables(value: string, extraVars: ScopedVars | undefined, format?: string | Function) {\n    const lastRequest = this.getQueryRunner().getLastRequest();\n    const vars: ScopedVars = Object.assign({}, this.scopedVars, lastRequest?.scopedVars, extraVars);\n\n    const allVariablesParams = getVariablesUrlParams(vars);\n    const variablesQuery = urlUtil.toUrlParams(allVariablesParams);\n    const timeRangeUrl = urlUtil.toUrlParams(getTimeSrv().timeRangeForUrl());\n\n    vars[DataLinkBuiltInVars.keepTime] = {\n      text: timeRangeUrl,\n      value: timeRangeUrl,\n    };\n\n    vars[DataLinkBuiltInVars.includeVars] = {\n      text: variablesQuery,\n      value: variablesQuery,\n    };\n\n    return getTemplateSrv().replace(value, vars, format);\n  }\n\n  resendLastResult() {\n    if (!this.plugin) {\n      return;\n    }\n\n    this.getQueryRunner().resendLastResult();\n  }\n\n  /*\n   * This is the title used when displaying the title in the UI so it will include any interpolated variables.\n   * If you need the raw title without interpolation use title property instead.\n   * */\n  getDisplayTitle(): string {\n    return this.replaceVariables(this.title, undefined, 'text');\n  }\n}\n\nfunction getPluginVersion(plugin: PanelPlugin): string {\n  return plugin && plugin.meta.info.version ? plugin.meta.info.version : config.buildInfo.version;\n}\n\ninterface PanelOptionsCache {\n  properties: any;\n  fieldConfig: FieldConfigSource;\n}\n"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,YAApB,EAAkCC,OAAlC,EAA2CC,OAA3C,EAAoDC,IAApD,QAAgE,QAAhE;AACA,SAASC,EAAE,IAAIC,MAAf,QAA6B,MAA7B;AAEA,SAIEC,mBAJF,EAOEC,WAPF,EAYEC,OAZF,QAeO,eAfP;AAgBA,SAASC,cAAT,EAAyBC,YAAzB,QAA6C,kBAA7C;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AACA,SAASC,gBAAT,QAAiC,sBAAjC;AAEA,SACEC,wBADF,EAEEC,wBAFF,EAGEC,gCAHF,EAIEC,WAJF,QAKO,kBALP;AAQA,SAASC,gBAAT,QAAiC,oCAAjC;AACA,SAASC,qBAAT,QAAsC,4CAAtC;AACA,SAASC,UAAT,QAA2B,qBAA3B;AAGA,SACEC,0BADF,EAEEC,2BAFF,EAGEC,mBAHF,EAIEC,0BAJF,QAKO,+BALP;AAeA,MAAMC,sBAAkD,GAAG;EACzDC,MAAM,EAAE,IADiD;EAEzDC,SAAS,EAAE,IAF8C;EAGzDC,SAAS,EAAE,IAH8C;EAIzDC,QAAQ,EAAE,IAJ+C;EAKzDC,YAAY,EAAE,IAL2C;EAMzDC,mBAAmB,EAAE,IANoC;EAOzDC,MAAM,EAAE,IAPiD;EAQzDC,WAAW,EAAE,IAR4C;EASzDC,gBAAgB,EAAE,IATuC;EAUzDC,SAAS,EAAE,IAV8C;EAWzDC,eAAe,EAAE,IAXwC;EAYzDC,WAAW,EAAE,IAZ4C;EAazDC,GAAG,EAAE;AAboD,CAA3D,C,CAgBA;AACA;AACA;AACA;;AACA,MAAMC,aAAyC,GAAG;EAChDC,EAAE,EAAE,IAD4C;EAEhDC,OAAO,EAAE,IAFuC;EAGhDC,IAAI,EAAE,IAH0C;EAIhDC,KAAK,EAAE,IAJyC;EAKhDC,UAAU,EAAE,IALoC;EAMhDC,MAAM,EAAE,IANwC;EAOhDC,eAAe,EAAE,IAP+B;EAQhDC,aAAa,EAAE,IARiC;EAShDC,eAAe,EAAE,IAT+B;EAUhDC,aAAa,EAAE,IAViC;EAWhDC,OAAO,EAAE,IAXuC;EAYhDC,SAAS,EAAE,IAZqC;EAahDC,MAAM,EAAE,IAbwC;EAchDC,OAAO,EAAE,IAduC;EAehDC,UAAU,EAAE,IAfoC;EAgBhDC,QAAQ,EAAE,IAhBsC;EAiBhDC,SAAS,EAAE,IAjBqC;EAkBhDC,gBAAgB,EAAE,IAlB8B;EAmBhDC,WAAW,EAAE,IAnBmC;EAoBhDC,KAAK,EAAE,IApByC;EAqBhDC,UAAU,EAAE,IArBoC;EAsBhDhC,SAAS,EAAE,IAtBqC;EAuBhDE,YAAY,EAAE,IAvBkC;EAwBhDJ,MAAM,EAAE,IAxBwC;EAyBhDmC,YAAY,EAAE,IAzBkC;EA0BhD9B,mBAAmB,EAAE,IA1B2B;EA2BhD+B,WAAW,EAAE,IA3BmC;EA4BhDC,aAAa,EAAE,IA5BiC;EA6BhD9B,WAAW,EAAE,IA7BmC;EA8BhD+B,eAAe,EAAE,IA9B+B;EA+BhDC,WAAW,EAAE,IA/BmC;EAgChDC,aAAa,EAAE,IAhCiC;EAiChDC,QAAQ,EAAE,IAjCsC;EAkChDjC,gBAAgB,EAAE,IAlC8B;EAmChDkC,YAAY,EAAE,IAnCkC;EAoChDhC,eAAe,EAAE,IApC+B;EAqChDD,SAAS,EAAE,IArCqC;EAsChDG,GAAG,EAAE;AAtC2C,CAAlD;AAyCA,MAAM+B,QAAa,GAAG;EACpB5B,OAAO,EAAE;IAAE6B,CAAC,EAAE,CAAL;IAAQC,CAAC,EAAE,CAAX;IAAcC,CAAC,EAAE,CAAjB;IAAoBC,CAAC,EAAE;EAAvB,CADW;EAEpBpB,OAAO,EAAE,CAAC;IAAEqB,KAAK,EAAE;EAAT,CAAD,CAFW;EAGpB3C,mBAAmB,EAAE,EAHD;EAIpB+B,WAAW,EAAE,KAJO;EAKpBa,OAAO,EAAE,EALW;EAMpBV,WAAW,EAAE;IACXI,QAAQ,EAAE,EADC;IAEXO,SAAS,EAAE;EAFA,CANO;EAUpBjC,KAAK,EAAE;AAVa,CAAtB;AAaA,OAAO,MAAMkC,UAAN,CAA0D;EAC/D;EAyCA;EAIe;;EAMf;AACF;AACA;AACA;;EAGE;AACF;AACA;AACA;EAKEC,WAAW,CAACC,KAAD,EAAa;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA,oCA/CW,IA+CX;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA,mCAvBZ,KAuBY;;IAAA,mCAtBZ,KAsBY;;IAAA,kCArBb,KAqBa;;IAAA,mCApBZ,CAoBY;;IAAA;;IAAA;;IAAA,6CAjBiC,EAiBjC;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IACtB,KAAKrD,MAAL,GAAc,IAAIlB,WAAJ,EAAd;IACA,KAAKwE,YAAL,CAAkBD,KAAlB;IACA,KAAK7C,gBAAL,GAAwB,KAAKA,gBAAL,CAAsB+C,IAAtB,CAA2B,IAA3B,CAAxB;IACA,KAAK3C,GAAL,GAAWhC,MAAM,EAAjB;EACD;EAED;;;EACA0E,YAAY,CAACD,KAAD,EAAa;IAAA;;IACvB;IACA,KAAK,MAAMG,QAAX,IAAuB,IAAvB,EAA6B;MAC3B,IAAIzD,sBAAsB,CAACyD,QAAD,CAAtB,IAAoC,CAAC,KAAKC,cAAL,CAAoBD,QAApB,CAAzC,EAAwE;QACtE;MACD;;MAED,IAAIH,KAAK,CAACG,QAAD,CAAT,EAAqB;QACnB;MACD;;MAED,IAAI,OAAQ,IAAD,CAAcA,QAAd,CAAP,KAAmC,UAAvC,EAAmD;QACjD;MACD;;MAED,IAAI,OAAQ,IAAD,CAAcA,QAAd,CAAP,KAAmC,QAAvC,EAAiD;QAC/C;MACD;;MAED,OAAQ,IAAD,CAAcA,QAAd,CAAP;IACD,CApBsB,CAsBvB;;;IACA,KAAK,MAAMA,QAAX,IAAuBH,KAAvB,EAA8B;MAC3B,IAAD,CAAcG,QAAd,IAA0BH,KAAK,CAACG,QAAD,CAA/B;IACD;;IAED,QAAQ,KAAKxC,IAAb;MACE,KAAK,OAAL;QACE,IAAI9B,MAAJ,aAAIA,MAAJ,wCAAIA,MAAM,CAAEwE,cAAZ,kDAAI,sBAAwBC,sBAA5B,EAAoD;UAClD,KAAKC,eAAL,GAAuB,KAAK5C,IAA5B;UACA,KAAKA,IAAL,GAAY,YAAZ;QACD;;QACD;;MACF,KAAK,aAAL;QACE,KAAK4C,eAAL,GAAuB,KAAK5C,IAA5B;QACA,KAAKA,IAAL,GAAY,SAAZ;QACA;IAVJ,CA3BuB,CAwCvB;;;IACAzC,YAAY,CAAC,IAAD,EAAOD,SAAS,CAACqE,QAAD,CAAhB,CAAZ,CAzCuB,CA2CvB;;IACA,KAAKkB,cAAL;EACD;;EAEDC,cAAc,GAAG;IACf,KAAKlD,GAAL,GAAWhC,MAAM,EAAjB;EACD;;EAEDiF,cAAc,GAAG;IACf,IAAI,KAAKlC,OAAL,IAAgBnD,OAAO,CAAC,KAAKmD,OAAN,CAA3B,EAA2C;MACzC,KAAK,MAAMoC,KAAX,IAAoB,KAAKpC,OAAzB,EAAkC;QAChC,IAAI,CAACoC,KAAK,CAACf,KAAX,EAAkB;UAChBe,KAAK,CAACf,KAAN,GAAc7D,gBAAgB,CAAC,KAAKwC,OAAN,CAA9B;QACD;MACF;IACF;EACF;;EAEDqC,UAAU,GAAG;IACX,OAAO,KAAKf,OAAZ;EACD;;EAEa,IAAVgB,UAAU,GAAY;IACxB,OAAO,KAAKxD,SAAL,GAAiB,CAAxB;EACD;;EAEDyD,aAAa,CAACjB,OAAD,EAAkB;IAC7B,KAAKA,OAAL,GAAeA,OAAf;IACA,KAAKxC,SAAL;IACA,KAAKT,MAAL,CAAYmE,OAAZ,CAAoB,IAAI/E,wBAAJ,EAApB;IACA,KAAKgF,MAAL;EACD;;EAEDC,iBAAiB,CAACnF,MAAD,EAA4B;IAC3C,KAAKqD,WAAL,GAAmBrD,MAAnB;IACA,KAAKuB,SAAL;IACA,KAAKT,MAAL,CAAYmE,OAAZ,CAAoB,IAAI/E,wBAAJ,EAApB;IAEA,KAAKkF,gBAAL;IACA,KAAKF,MAAL;EACD;;EAEDG,YAAY,GAAG;IACb,MAAMlB,KAAU,GAAG,EAAnB;;IAEA,KAAK,MAAMG,QAAX,IAAuB,IAAvB,EAA6B;MAC3B,IAAIzD,sBAAsB,CAACyD,QAAD,CAAtB,IAAoC,CAAC,KAAKC,cAAL,CAAoBD,QAApB,CAAzC,EAAwE;QACtE;MACD;;MAED,IAAI/E,OAAO,CAAC,KAAK+E,QAAL,CAAD,EAAiBb,QAAQ,CAACa,QAAD,CAAzB,CAAX,EAAiD;QAC/C;MACD;;MAEDH,KAAK,CAACG,QAAD,CAAL,GAAkBlF,SAAS,CAAC,KAAKkF,QAAL,CAAD,CAA3B;IACD;;IAED,OAAOH,KAAP;EACD;;EAEDmB,YAAY,CAACvE,SAAD,EAAqB;IAC/B,KAAKA,SAAL,GAAiBA,SAAjB;EACD;;EAEDwE,aAAa,CAACC,MAAD,EAAkB;IAC7B,IACEA,MAAM,CAAC9B,CAAP,KAAa,KAAK7B,OAAL,CAAa6B,CAA1B,IACA8B,MAAM,CAAC7B,CAAP,KAAa,KAAK9B,OAAL,CAAa8B,CAD1B,IAEA6B,MAAM,CAAC5B,CAAP,KAAa,KAAK/B,OAAL,CAAa+B,CAF1B,IAGA4B,MAAM,CAAC3B,CAAP,KAAa,KAAKhC,OAAL,CAAagC,CAJ5B,EAKE;MACA;IACD;;IAED,KAAKhC,OAAL,CAAa6B,CAAb,GAAiB8B,MAAM,CAAC9B,CAAxB;IACA,KAAK7B,OAAL,CAAa8B,CAAb,GAAiB6B,MAAM,CAAC7B,CAAxB;IACA,KAAK9B,OAAL,CAAagC,CAAb,GAAiB2B,MAAM,CAAC3B,CAAxB;IACA,KAAKhC,OAAL,CAAa+B,CAAb,GAAiB4B,MAAM,CAAC5B,CAAxB;IACA,KAAKrC,SAAL;EACD;;EAEDkE,kBAAkB,CAChBC,WADgB,EAEhBC,iBAFgB,EAGhBC,QAHgB,EAIhBC,KAJgB,EAKhBC,0BALgB,EAMhB;IACA,KAAKC,cAAL,GAAsBC,GAAtB,CAA0B;MACxBtD,UAAU,EAAE,KAAKA,UADO;MAExBuD,OAAO,EAAE,KAAKxD,OAFU;MAGxByD,OAAO,EAAE,KAAKtE,EAHU;MAIxB8D,WAAW,EAAEA,WAJW;MAKxBI,0BALwB;MAMxBK,QAAQ,EAAER,iBANc;MAOxBS,SAAS,EAAER,QAAQ,CAACQ,SAPI;MAQxBC,QAAQ,EAAET,QAAQ,CAACS,QARK;MASxB/C,aAAa,EAAE,KAAKA,aAAL,IAAsBgD,IAAI,CAACC,KAAL,CAAWV,KAAX,CATb;MAUxBW,WAAW,EAAE,KAAKjD,QAVM;MAWxBvB,UAAU,EAAE,KAAKA,UAXO;MAYxBiB,YAAY,EAAE,KAAKA,YAZK;MAaxBG,eAAe,EAAE,KAAKA;IAbE,CAA1B;EAeD;;EAEDqD,OAAO,GAAG;IACR,KAAKvF,YAAL,GAAoB,IAApB;IACA,KAAKJ,MAAL,CAAYmE,OAAZ,CAAoB,IAAIlF,YAAJ,EAApB;EACD;;EAEDmF,MAAM,GAAG;IACP,IAAI,CAAC,KAAKhE,YAAV,EAAwB;MACtB,KAAKuF,OAAL;IACD,CAFD,MAEO;MACL,KAAK3F,MAAL,CAAYmE,OAAZ,CAAoB,IAAI5E,WAAJ,EAApB;IACD;EACF;;EAEOqG,oBAAoB,GAAG;IAC7B,OAAOC,MAAM,CAACnH,IAAP,CAAY,IAAZ,EAAkBoH,MAAlB,CAAyB,CAACC,GAAD,EAAMvC,QAAN,KAAmB;MACjD,IAAIzD,sBAAsB,CAACyD,QAAD,CAAtB,IAAoC3C,aAAa,CAAC2C,QAAD,CAArD,EAAiE;QAC/D,OAAOuC,GAAP;MACD;;MACD,yBACKA,GADL;QAEE,CAACvC,QAAD,GAAa,IAAD,CAAcA,QAAd;MAFd;IAID,CARM,EAQJ,EARI,CAAP;EASD;;EAEOwC,mBAAmB,CAACC,QAAD,EAAmB;IAC5C,MAAMC,WAAW,GAAG,KAAK7F,mBAAL,CAAyB4F,QAAzB,CAApB;;IAEA,IAAI,CAACC,WAAL,EAAkB;MAChB;IACD;;IAEDL,MAAM,CAACnH,IAAP,CAAYwH,WAAW,CAACC,UAAxB,EAAoCC,GAApC,CAAyC5C,QAAD,IAAc;MACnD,IAAD,CAAcA,QAAd,IAA0B0C,WAAW,CAACC,UAAZ,CAAuB3C,QAAvB,CAA1B;IACD,CAFD;IAIA,KAAKjB,WAAL,GAAmBzC,0BAA0B,CAAC,KAAKyC,WAAN,EAAmB2D,WAAW,CAAC3D,WAA/B,CAA7C;EACD;;EAED8D,yBAAyB,CAAC/F,MAAD,EAAsBgG,mBAAtB,EAAoD;IAC3E,MAAMrD,OAAO,GAAGrD,2BAA2B,CAAC;MAC1CU,MAD0C;MAE1CiG,cAAc,EAAE,KAAKtD,OAFqB;MAG1CuD,kBAAkB,EAAE,KAAKjE,WAHiB;MAI1C+D,mBAAmB,EAAEA;IAJqB,CAAD,CAA3C;IAOA,KAAK/D,WAAL,GAAmBU,OAAO,CAACV,WAA3B;IACA,KAAKU,OAAL,GAAeA,OAAO,CAACA,OAAvB;EACD;;EAEDwD,YAAY,CAACnG,MAAD,EAAsB;IAChC,KAAKA,MAAL,GAAcA,MAAd;IACA,MAAMoG,OAAO,GAAGC,gBAAgB,CAACrG,MAAD,CAAhC;;IAEA,IAAI,KAAKsD,eAAT,EAA0B;MACxB,MAAMgD,UAAU,GAAG,KAAKhD,eAAL,KAAyB,OAA5C;MACA,KAAKiD,0BAAL,CACEvG,MADF,EAEE,KAAKsD,eAFP,EAGE,KAAKgC,oBAAL,EAHF,EAG+B;MAC7BgB,UAJF;MAOA,OAAO,KAAKhD,eAAZ;IACD;;IAED,IAAItD,MAAM,CAACwG,gBAAX,EAA6B;MAC3B,IAAIJ,OAAO,KAAK,KAAKrE,aAArB,EAAoC;QAClC,KAAKY,OAAL,GAAe3C,MAAM,CAACwG,gBAAP,CAAwB,IAAxB,CAAf;QACA,KAAKzE,aAAL,GAAqBqE,OAArB;MACD;IACF;;IAED,KAAKL,yBAAL,CAA+B/F,MAA/B,EAAuC,KAAvC;IACA,KAAKgE,gBAAL;EACD;;EAEDyC,iCAAiC,GAAG;IAClC;IACA,KAAK,MAAMnG,GAAX,IAAkBlC,IAAI,CAAC,IAAD,CAAtB,EAA8B;MAC5B,IAAImC,aAAa,CAACD,GAAD,CAAjB,EAAwB;QACtB;MACD;;MACD,OAAQ,IAAD,CAAcA,GAAd,CAAP;IACD;;IAED,KAAKqC,OAAL,GAAe,EAAf,CATkC,CAWlC;;IACA,KAAKV,WAAL,GAAmB;MACjBI,QAAQ,oBACH,KAAKJ,WAAL,CAAiBI,QADd;QAENqE,MAAM,EAAE;MAFF,EADS;MAKjB;MACA9D,SAAS,EAAEvD,0BAA0B,CAAC,KAAK4C,WAAL,CAAiBW,SAAlB,EAA6BrD,mBAA7B;IANpB,CAAnB;EAQD,CAhU8D,CAkU/D;;;EACQgH,0BAA0B,CAChCI,SADgC,EAEhCC,WAFgC,EAGhCC,UAHgC,EAIhCP,UAJgC,EAKhC;IACA,IAAIK,SAAS,CAACG,kBAAd,EAAkC;MAChC,MAAMlB,WAAW,GAAGU,UAAU,GAAG;QAAES,OAAO,EAAEF;MAAX,CAAH,GAA6BA,UAAU,CAAClE,OAAtE;MACA4C,MAAM,CAACyB,MAAP,CAAc,KAAKrE,OAAnB,EAA4BgE,SAAS,CAACG,kBAAV,CAA6B,IAA7B,EAAmCF,WAAnC,EAAgDhB,WAAhD,EAA6D,KAAK3D,WAAlE,CAA5B;IACD;EACF;;EAEDgF,YAAY,CAACN,SAAD,EAAyB;IACnC,MAAMhB,QAAQ,GAAGgB,SAAS,CAACO,IAAV,CAAe1G,EAAhC;IACA,MAAMqG,UAAe,GAAG,KAAKvB,oBAAL,EAAxB;IACA,MAAM6B,eAAe,GAAG,KAAKlF,WAA7B;IACA,MAAM2E,WAAW,GAAG,KAAKlG,IAAzB;IACA,MAAM4F,UAAU,GAAG,KAAKc,eAAL,EAAnB;IACA,KAAKrH,mBAAL,CAAyB6G,WAAzB,IAAwC;MACtCf,UAAU,EAAEgB,UAD0B;MAEtC5E,WAAW,EAAEkF;IAFyB,CAAxC;IAKA,KAAKV,iCAAL;IACA,KAAKf,mBAAL,CAAyBC,QAAzB,EAZmC,CAcnC;;IACA,KAAKY,0BAAL,CAAgCI,SAAhC,EAA2CC,WAA3C,EAAwDC,UAAxD,EAAoEP,UAApE,EAfmC,CAiBnC;;IACA,KAAK5F,IAAL,GAAYiF,QAAZ;IACA,KAAK3F,MAAL,GAAc2G,SAAd;IACA,KAAKxG,SAAL;IAEA,KAAK4F,yBAAL,CAA+BY,SAA/B,EAA0C,IAA1C;;IAEA,IAAIA,SAAS,CAACH,gBAAd,EAAgC;MAC9B,KAAKzE,aAAL,GAAqBsE,gBAAgB,CAACM,SAAD,CAArC;IACD;EACF;;EAEDU,aAAa,CAAC1E,OAAD,EAA6B;IAAA;;IACxC,MAAM;MAAE2E;IAAF,IAAiB3E,OAAvB;IACA,KAAKrB,UAAL,GAAkB;MAChBiG,GAAG,EAAED,UAAU,CAACC,GADA;MAEhB7G,IAAI,EAAE4G,UAAU,CAAC5G;IAFD,CAAlB;IAIA,KAAKmB,YAAL,GAAoBc,OAAO,CAACd,YAA5B;IACA,KAAKN,QAAL,yBAAgBoB,OAAO,CAACqC,SAAxB,uDAAgB,mBAAmBwC,IAAnC;IACA,KAAKhG,SAAL,0BAAiBmB,OAAO,CAACqC,SAAzB,wDAAiB,oBAAmByC,KAApC;IACA,KAAKhG,gBAAL,0BAAwBkB,OAAO,CAACqC,SAAhC,wDAAwB,oBAAmB0C,IAA3C;IACA,KAAKvF,QAAL,GAAgBQ,OAAO,CAACyC,WAAxB;IACA,KAAKlD,aAAL,GAAqBS,OAAO,CAACT,aAA7B;IACA,KAAKb,OAAL,GAAesB,OAAO,CAACkC,OAAvB;IACA,KAAK1E,SAAL;IAEA,KAAKT,MAAL,CAAYmE,OAAZ,CAAoB,IAAI9E,wBAAJ,EAApB;EACD;;EAED4I,QAAQ,CAAClE,KAAD,EAA6B;IACnCA,KAAK,GAAGA,KAAK,IAAI;MAAEf,KAAK,EAAE;IAAT,CAAjB;IACAe,KAAK,CAACf,KAAN,GAAc7D,gBAAgB,CAAC,KAAKwC,OAAN,CAA9B;IACA,KAAKA,OAAL,CAAauG,IAAb,CAAkBnE,KAAlB;IACA,KAAKtD,SAAL;EACD;;EAED0H,WAAW,CAACpE,KAAD,EAAmBqE,KAAnB,EAAkC;IAC3C;IACArE,KAAK,CAACf,KAAN,GAAc,KAAKrB,OAAL,CAAayG,KAAb,EAAoBpF,KAAlC;IACA,KAAKvC,SAAL,GAH2C,CAK3C;;IACA,KAAKkB,OAAL,GAAe,KAAKA,OAAL,CAAayE,GAAb,CAAiB,CAACiC,IAAD,EAAOC,SAAP,KAAqB;MACnD,IAAIA,SAAS,KAAKF,KAAlB,EAAyB;QACvB,OAAOrE,KAAP;MACD;;MACD,OAAOsE,IAAP;IACD,CALc,CAAf;EAMD;;EAEDE,YAAY,GAAG;IACb,MAAMC,WAAW,GAAG,KAAKjE,YAAL,EAApB;IAEA,MAAMkE,KAAK,GAAG,IAAItF,UAAJ,CAAeqF,WAAf,CAAd;IACAC,KAAK,CAACvI,SAAN,GAAkB,IAAlB;IAEA,MAAMwI,iBAAiB,GAAG,KAAKzD,cAAL,EAA1B,CANa,CAQb;;IACAwD,KAAK,CAACxD,cAAN,GAAuB0D,iBAAvB,CAAyCD,iBAAzC;IAEA,OAAOD,KAAP;EACD;;EAEDG,kBAAkB,GAAG;IACnB,OAAO,KAAKtG,eAAZ;EACD;;EAEDuG,uBAAuB,GAAG;IACxB,IAAI,CAAC,KAAKvI,MAAV,EAAkB;MAChB,OAAOwI,SAAP;IACD;;IAED,OAAO;MACLvG,WAAW,EAAE,KAAKA,WADb;MAEL/B,gBAAgB,EAAE,KAAKA,gBAFlB;MAGLuI,mBAAmB,EAAE,KAAKzI,MAAL,CAAYyI,mBAH5B;MAILC,KAAK,EAAE9J,MAAM,CAAC+J;IAJT,CAAP;EAMD;;EAEDC,cAAc,GAA2B;IAAA;;IACvC,gDAAO,KAAK5I,MAAZ,iDAAO,aAAaK,WAApB,yEAAmC;MAAEwI,WAAW,EAAE,KAAf;MAAsBC,WAAW,EAAE;IAAnC,CAAnC;EACD;;EAEDnE,cAAc,GAAqB;IACjC,IAAI,CAAC,KAAK1E,WAAV,EAAuB;MACrB,KAAKA,WAAL,GAAmB,IAAIf,gBAAJ,CAAqB,IAArB,CAAnB;IACD;;IACD,OAAO,KAAKe,WAAZ;EACD;;EAED8I,QAAQ,GAAG;IACT,OAAO,KAAKpI,KAAL,IAAc,KAAKA,KAAL,CAAWqI,MAAX,GAAoB,CAAzC;EACD;;EAED5B,eAAe,GAAY;IACzB,OAAO,CAAC,KAAKpH,MAAL,IAAe,KAAKA,MAAL,CAAYiJ,gBAA5B,MAAkDT,SAAzD;EACD;;EAEDU,OAAO,GAAG;IACR,KAAKxJ,MAAL,CAAYyJ,kBAAZ;;IAEA,IAAI,KAAKlJ,WAAT,EAAsB;MACpB,KAAKA,WAAL,CAAiBiJ,OAAjB;IACD;EACF;;EAEDE,kBAAkB,CAACpH,eAAD,EAA2C;IAC3D,KAAKA,eAAL,GAAuBA,eAAvB;IACA,KAAKgC,gBAAL;IACA,KAAK7D,SAAL;IACA,KAAKT,MAAL,CAAYmE,OAAZ,CAAoB,IAAI7E,gCAAJ,EAApB;EACD;;EAEDqK,WAAW,CAAC/I,GAAD,EAAkBgJ,KAAlB,EAA8B;IACvC,KAAKhJ,GAAL,IAAYgJ,KAAZ;IACA,KAAKnJ,SAAL,GAFuC,CAIvC;IACA;;IACA,IAAIG,GAAG,KAAK,QAAZ,EAAsB;MACpB,IAAI,KAAKO,MAAL,IAAe,CAAC,KAAKG,eAAzB,EAA0C;QACxC,KAAKA,eAAL,GAAuB,GAAvB;MACD,CAFD,MAEO,IAAI,CAAC,KAAKH,MAAV,EAAkB;QACvB,OAAO,KAAKG,eAAZ;QACA,OAAO,KAAKuI,SAAZ;MACD;IACF;EACF;;EAEDrJ,gBAAgB,CAACoJ,KAAD,EAAgBE,SAAhB,EAAmDC,MAAnD,EAA+E;IAC7F,MAAMC,WAAW,GAAG,KAAK/E,cAAL,GAAsBgF,cAAtB,EAApB;IACA,MAAMC,IAAgB,GAAGrE,MAAM,CAACyB,MAAP,CAAc,EAAd,EAAkB,KAAKpG,UAAvB,EAAmC8I,WAAnC,aAAmCA,WAAnC,uBAAmCA,WAAW,CAAE9I,UAAhD,EAA4D4I,SAA5D,CAAzB;IAEA,MAAMK,kBAAkB,GAAG1K,qBAAqB,CAACyK,IAAD,CAAhD;IACA,MAAME,cAAc,GAAGrL,OAAO,CAACsL,WAAR,CAAoBF,kBAApB,CAAvB;IACA,MAAMG,YAAY,GAAGvL,OAAO,CAACsL,WAAR,CAAoB3K,UAAU,GAAG6K,eAAb,EAApB,CAArB;IAEAL,IAAI,CAACrL,mBAAmB,CAAC2L,QAArB,CAAJ,GAAqC;MACnCC,IAAI,EAAEH,YAD6B;MAEnCV,KAAK,EAAEU;IAF4B,CAArC;IAKAJ,IAAI,CAACrL,mBAAmB,CAAC6L,WAArB,CAAJ,GAAwC;MACtCD,IAAI,EAAEL,cADgC;MAEtCR,KAAK,EAAEQ;IAF+B,CAAxC;IAKA,OAAOpL,cAAc,GAAG2L,OAAjB,CAAyBf,KAAzB,EAAgCM,IAAhC,EAAsCH,MAAtC,CAAP;EACD;;EAEDzF,gBAAgB,GAAG;IACjB,IAAI,CAAC,KAAKhE,MAAV,EAAkB;MAChB;IACD;;IAED,KAAK2E,cAAL,GAAsBX,gBAAtB;EACD;EAED;AACF;AACA;AACA;;;EACE5D,eAAe,GAAW;IACxB,OAAO,KAAKF,gBAAL,CAAsB,KAAKS,KAA3B,EAAkC6H,SAAlC,EAA6C,MAA7C,CAAP;EACD;;AAvgB8D;;AA0gBjE,SAASnC,gBAAT,CAA0BrG,MAA1B,EAAuD;EACrD,OAAOA,MAAM,IAAIA,MAAM,CAACkH,IAAP,CAAYoD,IAAZ,CAAiBlE,OAA3B,GAAqCpG,MAAM,CAACkH,IAAP,CAAYoD,IAAZ,CAAiBlE,OAAtD,GAAgExH,MAAM,CAAC2L,SAAP,CAAiBnE,OAAxF;AACD"},"metadata":{},"sourceType":"module"}