{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nconst BRACES = {\n  '[': ']',\n  '{': '}',\n  '(': ')'\n};\nconst MATCH_MARK = 'brace_match';\nexport function BracesPlugin() {\n  return {\n    onKeyDown(event, editor, next) {\n      const keyEvent = event;\n      const {\n        value\n      } = editor;\n\n      switch (keyEvent.key) {\n        case '(':\n        case '{':\n        case '[':\n          {\n            const {\n              start: {\n                offset: startOffset,\n                key: startKey\n              },\n              end: {\n                offset: endOffset,\n                key: endKey\n              },\n              focus: {\n                offset: focusOffset\n              }\n            } = value.selection;\n            const text = value.focusText.text; // If text is selected, wrap selected text in parens\n\n            if (value.selection.isExpanded) {\n              keyEvent.preventDefault();\n              editor.insertTextByKey(startKey, startOffset, keyEvent.key).insertTextByKey(endKey, endOffset + 1, BRACES[keyEvent.key]).moveEndBackward(1);\n              return true;\n            } else if ( // Insert matching brace when there is no input after caret\n            focusOffset === text.length || text[focusOffset] === ' ' || Object.values(BRACES).includes(text[focusOffset])) {\n              keyEvent.preventDefault();\n              const complement = BRACES[keyEvent.key];\n              const matchAnnotation = {\n                key: `${MATCH_MARK}-${uuidv4()}`,\n                type: `${MATCH_MARK}-${complement}`,\n                anchor: {\n                  key: startKey,\n                  offset: startOffset,\n                  object: 'point'\n                },\n                focus: {\n                  key: endKey,\n                  offset: endOffset + 1,\n                  object: 'point'\n                },\n                object: 'annotation'\n              };\n              editor.insertText(keyEvent.key).insertText(complement).addAnnotation(matchAnnotation).moveBackward(1);\n              return true;\n            }\n\n            break;\n          }\n\n        case ')':\n        case '}':\n        case ']':\n          {\n            const text = value.anchorText.text;\n            const offset = value.selection.anchor.offset;\n            const nextChar = text[offset]; // Handle closing brace when it's already the next character\n\n            const complement = keyEvent.key;\n            const annotationType = `${MATCH_MARK}-${complement}`;\n            const annotation = value.annotations.find(a => (a === null || a === void 0 ? void 0 : a.type) === annotationType && a.anchor.key === value.anchorText.key);\n\n            if (annotation && nextChar === complement && !value.selection.isExpanded) {\n              keyEvent.preventDefault();\n              editor.moveFocusForward(1).removeAnnotation(annotation).moveAnchorForward(1);\n              return true;\n            }\n\n            break;\n          }\n\n        case 'Backspace':\n          {\n            const text = value.anchorText.text;\n            const offset = value.selection.anchor.offset;\n            const previousChar = text[offset - 1];\n            const nextChar = text[offset];\n\n            if (BRACES[previousChar] && BRACES[previousChar] === nextChar) {\n              keyEvent.preventDefault(); // Remove closing brace if directly following\n\n              editor.deleteBackward(1).deleteForward(1).focus();\n              return true;\n            }\n          }\n\n        default:\n          {\n            break;\n          }\n      }\n\n      return next();\n    }\n\n  };\n}","map":{"version":3,"names":["v4","uuidv4","BRACES","MATCH_MARK","BracesPlugin","onKeyDown","event","editor","next","keyEvent","value","key","start","offset","startOffset","startKey","end","endOffset","endKey","focus","focusOffset","selection","text","focusText","isExpanded","preventDefault","insertTextByKey","moveEndBackward","length","Object","values","includes","complement","matchAnnotation","type","anchor","object","insertText","addAnnotation","moveBackward","anchorText","nextChar","annotationType","annotation","annotations","find","a","moveFocusForward","removeAnnotation","moveAnchorForward","previousChar","deleteBackward","deleteForward"],"sources":["/home/soula/grafana/packages/grafana-ui/src/slate-plugins/braces.ts"],"sourcesContent":["import { Editor as CoreEditor, Annotation } from 'slate';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { Plugin } from '@grafana/slate-react';\n\nconst BRACES: any = {\n  '[': ']',\n  '{': '}',\n  '(': ')',\n};\n\nconst MATCH_MARK = 'brace_match';\n\nexport function BracesPlugin(): Plugin {\n  return {\n    onKeyDown(event: Event, editor: CoreEditor, next: Function) {\n      const keyEvent = event as KeyboardEvent;\n      const { value } = editor;\n\n      switch (keyEvent.key) {\n        case '(':\n        case '{':\n        case '[': {\n          const {\n            start: { offset: startOffset, key: startKey },\n            end: { offset: endOffset, key: endKey },\n            focus: { offset: focusOffset },\n          } = value.selection;\n          const text = value.focusText.text;\n\n          // If text is selected, wrap selected text in parens\n          if (value.selection.isExpanded) {\n            keyEvent.preventDefault();\n            editor\n              .insertTextByKey(startKey, startOffset, keyEvent.key)\n              .insertTextByKey(endKey, endOffset + 1, BRACES[keyEvent.key])\n              .moveEndBackward(1);\n            return true;\n          } else if (\n            // Insert matching brace when there is no input after caret\n            focusOffset === text.length ||\n            text[focusOffset] === ' ' ||\n            Object.values(BRACES).includes(text[focusOffset])\n          ) {\n            keyEvent.preventDefault();\n            const complement = BRACES[keyEvent.key];\n            const matchAnnotation = {\n              key: `${MATCH_MARK}-${uuidv4()}`,\n              type: `${MATCH_MARK}-${complement}`,\n              anchor: {\n                key: startKey,\n                offset: startOffset,\n                object: 'point',\n              },\n              focus: {\n                key: endKey,\n                offset: endOffset + 1,\n                object: 'point',\n              },\n              object: 'annotation',\n            } as Annotation;\n            editor.insertText(keyEvent.key).insertText(complement).addAnnotation(matchAnnotation).moveBackward(1);\n\n            return true;\n          }\n          break;\n        }\n\n        case ')':\n        case '}':\n        case ']': {\n          const text = value.anchorText.text;\n          const offset = value.selection.anchor.offset;\n          const nextChar = text[offset];\n          // Handle closing brace when it's already the next character\n          const complement = keyEvent.key;\n          const annotationType = `${MATCH_MARK}-${complement}`;\n          const annotation = value.annotations.find(\n            (a) => a?.type === annotationType && a.anchor.key === value.anchorText.key\n          );\n          if (annotation && nextChar === complement && !value.selection.isExpanded) {\n            keyEvent.preventDefault();\n            editor.moveFocusForward(1).removeAnnotation(annotation).moveAnchorForward(1);\n            return true;\n          }\n          break;\n        }\n\n        case 'Backspace': {\n          const text = value.anchorText.text;\n          const offset = value.selection.anchor.offset;\n          const previousChar = text[offset - 1];\n          const nextChar = text[offset];\n          if (BRACES[previousChar] && BRACES[previousChar] === nextChar) {\n            keyEvent.preventDefault();\n            // Remove closing brace if directly following\n            editor.deleteBackward(1).deleteForward(1).focus();\n            return true;\n          }\n        }\n\n        default: {\n          break;\n        }\n      }\n\n      return next();\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}