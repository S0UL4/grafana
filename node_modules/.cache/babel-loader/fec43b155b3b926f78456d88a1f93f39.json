{"ast":null,"code":"import { last } from 'lodash';\n\n/**\n * Attempts to do a partial input search, e.g. allowing to search for a text (needle)\n * in another text (stack) by skipping some letters in-between. All letters from\n * the needle must exist in the stack in the same order to find a match.\n *\n * The search is case sensitive. Convert stack and needle to lower case\n * to make it case insensitive.\n *\n * @param stack - main text to be searched\n * @param needle - partial text to find in the stack\n *\n * @internal\n */\nexport function fuzzyMatch(stack, needle) {\n  let distance = 0,\n      searchIndex = stack.indexOf(needle); // Remove whitespace from needle as a temporary solution to treat separate string\n  // queries as 'AND'\n\n  needle = needle.replace(/\\s/g, '');\n  const ranges = [];\n\n  if (searchIndex !== -1) {\n    return {\n      distance: 0,\n      found: true,\n      ranges: [{\n        start: searchIndex,\n        end: searchIndex + needle.length - 1\n      }]\n    };\n  }\n\n  for (const letter of needle) {\n    const letterIndex = stack.indexOf(letter, searchIndex);\n\n    if (letterIndex === -1) {\n      return {\n        distance: Infinity,\n        ranges: [],\n        found: false\n      };\n    } // do not cumulate the distance if it's the first letter\n\n\n    if (searchIndex !== -1) {\n      distance += letterIndex - searchIndex;\n    }\n\n    searchIndex = letterIndex + 1;\n\n    if (ranges.length === 0) {\n      ranges.push({\n        start: letterIndex,\n        end: letterIndex\n      });\n    } else {\n      const lastRange = last(ranges);\n\n      if (letterIndex === lastRange.end + 1) {\n        lastRange.end++;\n      } else {\n        ranges.push({\n          start: letterIndex,\n          end: letterIndex\n        });\n      }\n    }\n  }\n\n  return {\n    distance: distance,\n    ranges,\n    found: true\n  };\n}","map":{"version":3,"names":["last","fuzzyMatch","stack","needle","distance","searchIndex","indexOf","replace","ranges","found","start","end","length","letter","letterIndex","Infinity","push","lastRange"],"sources":["/home/soula/grafana/packages/grafana-ui/src/utils/fuzzy.ts"],"sourcesContent":["import { last } from 'lodash';\n\nimport { HighlightPart } from '../types';\n\ntype FuzzyMatch = {\n  /**\n   * Total number of unmatched letters between matched letters\n   */\n  distance: number;\n  ranges: HighlightPart[];\n  found: boolean;\n};\n\n/**\n * Attempts to do a partial input search, e.g. allowing to search for a text (needle)\n * in another text (stack) by skipping some letters in-between. All letters from\n * the needle must exist in the stack in the same order to find a match.\n *\n * The search is case sensitive. Convert stack and needle to lower case\n * to make it case insensitive.\n *\n * @param stack - main text to be searched\n * @param needle - partial text to find in the stack\n *\n * @internal\n */\nexport function fuzzyMatch(stack: string, needle: string): FuzzyMatch {\n  let distance = 0,\n    searchIndex = stack.indexOf(needle);\n  // Remove whitespace from needle as a temporary solution to treat separate string\n  // queries as 'AND'\n  needle = needle.replace(/\\s/g, '');\n\n  const ranges: HighlightPart[] = [];\n\n  if (searchIndex !== -1) {\n    return {\n      distance: 0,\n      found: true,\n      ranges: [{ start: searchIndex, end: searchIndex + needle.length - 1 }],\n    };\n  }\n\n  for (const letter of needle) {\n    const letterIndex = stack.indexOf(letter, searchIndex);\n\n    if (letterIndex === -1) {\n      return { distance: Infinity, ranges: [], found: false };\n    }\n    // do not cumulate the distance if it's the first letter\n    if (searchIndex !== -1) {\n      distance += letterIndex - searchIndex;\n    }\n    searchIndex = letterIndex + 1;\n\n    if (ranges.length === 0) {\n      ranges.push({ start: letterIndex, end: letterIndex });\n    } else {\n      const lastRange = last(ranges)!;\n      if (letterIndex === lastRange.end + 1) {\n        lastRange.end++;\n      } else {\n        ranges.push({ start: letterIndex, end: letterIndex });\n      }\n    }\n  }\n\n  return {\n    distance: distance,\n    ranges,\n    found: true,\n  };\n}\n"],"mappings":"AAAA,SAASA,IAAT,QAAqB,QAArB;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAT,CAAoBC,KAApB,EAAmCC,MAAnC,EAA+D;EACpE,IAAIC,QAAQ,GAAG,CAAf;EAAA,IACEC,WAAW,GAAGH,KAAK,CAACI,OAAN,CAAcH,MAAd,CADhB,CADoE,CAGpE;EACA;;EACAA,MAAM,GAAGA,MAAM,CAACI,OAAP,CAAe,KAAf,EAAsB,EAAtB,CAAT;EAEA,MAAMC,MAAuB,GAAG,EAAhC;;EAEA,IAAIH,WAAW,KAAK,CAAC,CAArB,EAAwB;IACtB,OAAO;MACLD,QAAQ,EAAE,CADL;MAELK,KAAK,EAAE,IAFF;MAGLD,MAAM,EAAE,CAAC;QAAEE,KAAK,EAAEL,WAAT;QAAsBM,GAAG,EAAEN,WAAW,GAAGF,MAAM,CAACS,MAArB,GAA8B;MAAzD,CAAD;IAHH,CAAP;EAKD;;EAED,KAAK,MAAMC,MAAX,IAAqBV,MAArB,EAA6B;IAC3B,MAAMW,WAAW,GAAGZ,KAAK,CAACI,OAAN,CAAcO,MAAd,EAAsBR,WAAtB,CAApB;;IAEA,IAAIS,WAAW,KAAK,CAAC,CAArB,EAAwB;MACtB,OAAO;QAAEV,QAAQ,EAAEW,QAAZ;QAAsBP,MAAM,EAAE,EAA9B;QAAkCC,KAAK,EAAE;MAAzC,CAAP;IACD,CAL0B,CAM3B;;;IACA,IAAIJ,WAAW,KAAK,CAAC,CAArB,EAAwB;MACtBD,QAAQ,IAAIU,WAAW,GAAGT,WAA1B;IACD;;IACDA,WAAW,GAAGS,WAAW,GAAG,CAA5B;;IAEA,IAAIN,MAAM,CAACI,MAAP,KAAkB,CAAtB,EAAyB;MACvBJ,MAAM,CAACQ,IAAP,CAAY;QAAEN,KAAK,EAAEI,WAAT;QAAsBH,GAAG,EAAEG;MAA3B,CAAZ;IACD,CAFD,MAEO;MACL,MAAMG,SAAS,GAAGjB,IAAI,CAACQ,MAAD,CAAtB;;MACA,IAAIM,WAAW,KAAKG,SAAS,CAACN,GAAV,GAAgB,CAApC,EAAuC;QACrCM,SAAS,CAACN,GAAV;MACD,CAFD,MAEO;QACLH,MAAM,CAACQ,IAAP,CAAY;UAAEN,KAAK,EAAEI,WAAT;UAAsBH,GAAG,EAAEG;QAA3B,CAAZ;MACD;IACF;EACF;;EAED,OAAO;IACLV,QAAQ,EAAEA,QADL;IAELI,MAFK;IAGLC,KAAK,EAAE;EAHF,CAAP;AAKD"},"metadata":{},"sourceType":"module"}