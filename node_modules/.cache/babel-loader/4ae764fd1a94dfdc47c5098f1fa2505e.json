{"ast":null,"code":"export const QUERY_COMMANDS = [{\n  label: 'fields',\n  documentation: 'Retrieves the specified fields from log events'\n}, {\n  label: 'display',\n  documentation: 'Specifies which fields to display in the query results'\n}, {\n  label: 'filter',\n  documentation: 'Filters the results of a query based on one or more conditions'\n}, {\n  label: 'stats',\n  documentation: 'Calculates aggregate statistics based on the values of log fields'\n}, {\n  label: 'sort',\n  documentation: 'Sorts the retrieved log events'\n}, {\n  label: 'limit',\n  documentation: 'Specifies the number of log events returned by the query'\n}, {\n  label: 'parse',\n  documentation: 'Extracts data from a log field, creating one or more ephemeral fields that you can process further in the query'\n}];\nexport const COMPARISON_OPERATORS = ['=', '!=', '<', '<=', '>', '>='];\nexport const ARITHMETIC_OPERATORS = ['+', '-', '*', '/', '^', '%'];\nexport const NUMERIC_OPERATORS = [{\n  label: 'abs',\n  detail: 'abs(a)',\n  documentation: 'Absolute value.'\n}, {\n  label: 'ceil',\n  detail: 'ceil(a)',\n  documentation: 'Round to ceiling (the smallest integer that is greater than the value of a).'\n}, {\n  label: 'floor',\n  detail: 'floor(a)',\n  documentation: 'Round to floor (the largest integer that is smaller than the value of a).'\n}, {\n  label: 'greatest',\n  detail: 'greatest(a,b, ... z)',\n  documentation: 'Returns the largest value.'\n}, {\n  label: 'least',\n  detail: 'least(a, b, ... z)',\n  documentation: 'Returns the smallest value.'\n}, {\n  label: 'log',\n  detail: 'log(a)',\n  documentation: 'Natural logarithm.'\n}, {\n  label: 'sqrt',\n  detail: 'sqrt(a)',\n  documentation: 'Square root.'\n}];\nexport const GENERAL_FUNCTIONS = [{\n  label: 'ispresent',\n  detail: 'ispresent(fieldname)',\n  documentation: 'Returns true if the field exists.'\n}, {\n  label: 'coalesce',\n  detail: 'coalesce(fieldname1, fieldname2, ... fieldnamex)',\n  documentation: 'Returns the first non-null value from the list.'\n}];\nexport const STRING_FUNCTIONS = [{\n  label: 'isempty',\n  detail: 'isempty(fieldname)',\n  documentation: 'Returns true if the field is missing or is an empty string.'\n}, {\n  label: 'isblank',\n  detail: 'isblank(fieldname)',\n  documentation: 'Returns true if the field is missing, an empty string, or contains only white space.'\n}, {\n  label: 'concat',\n  detail: 'concat(string1, string2, ... stringz)',\n  documentation: 'Concatenates the strings.'\n}, {\n  label: 'ltrim',\n  detail: 'ltrim(string) or ltrim(string1, string2)',\n  documentation: 'Remove white space from the left of the string. If the function has a second string argument, it removes the characters of string2 from the left of string1.'\n}, {\n  label: 'rtrim',\n  detail: 'rtrim(string) or rtrim(string1, string2)',\n  documentation: 'Remove white space from the right of the string. If the function has a second string argument, it removes the characters of string2 from the right of string1.'\n}, {\n  label: 'trim',\n  detail: 'trim(string) or trim(string1, string2)',\n  documentation: 'Remove white space from both ends of the string. If the function has a second string argument, it removes the characters of string2 from both sides of string1.'\n}, {\n  label: 'strlen',\n  detail: 'strlen(string)',\n  documentation: 'Returns the length of the string in Unicode code points.'\n}, {\n  label: 'toupper',\n  detail: 'toupper(string)',\n  documentation: 'Converts the string to uppercase.'\n}, {\n  label: 'tolower',\n  detail: 'tolower(string)',\n  documentation: 'Converts the string to lowercase.'\n}, {\n  label: 'substr',\n  detail: 'substr(string1, x), or substr(string1, x, y)',\n  documentation: 'Returns a substring from the index specified by the number argument to the end of the string. If the function has a second number argument, it contains the length of the substring to be retrieved.'\n}, {\n  label: 'replace',\n  detail: 'replace(string1, string2, string3)',\n  documentation: 'Replaces all instances of string2 in string1 with string3.'\n}, {\n  label: 'strcontains',\n  detail: 'strcontains(string1, string2)',\n  documentation: 'Returns 1 if string1 contains string2 and 0 otherwise.'\n}];\nexport const DATETIME_FUNCTIONS = [{\n  label: 'bin',\n  detail: 'bin(period)',\n  documentation: 'Rounds the value of @timestamp to the given period and then truncates.'\n}, {\n  label: 'datefloor',\n  detail: 'datefloor(a, period)',\n  documentation: 'Truncates the timestamp to the given period.'\n}, {\n  label: 'dateceil',\n  detail: 'dateceil(a, period)',\n  documentation: 'Rounds up the timestamp to the given period and then truncates.'\n}, {\n  label: 'fromMillis',\n  detail: 'fromMillis(fieldname)',\n  documentation: 'Interprets the input field as the number of milliseconds since the Unix epoch and converts it to a timestamp.'\n}, {\n  label: 'toMillis',\n  detail: 'toMillis(fieldname)',\n  documentation: 'Converts the timestamp found in the named field into a number representing the milliseconds since the Unix epoch.'\n}];\nexport const IP_FUNCTIONS = [{\n  label: 'isValidIp',\n  detail: 'isValidIp(fieldname)',\n  documentation: 'Returns true if the field is a valid v4 or v6 IP address.'\n}, {\n  label: 'isValidIpV4',\n  detail: 'isValidIpV4(fieldname)',\n  documentation: 'Returns true if the field is a valid v4 IP address.'\n}, {\n  label: 'isValidIpV6',\n  detail: 'isValidIpV6(fieldname)',\n  documentation: 'Returns true if the field is a valid v6 IP address.'\n}, {\n  label: 'isIpInSubnet',\n  detail: 'isIpInSubnet(fieldname, string)',\n  documentation: 'Returns true if the field is a valid v4 or v6 IP address within the specified v4 or v6 subnet.'\n}, {\n  label: 'isIpv4InSubnet',\n  detail: 'isIpv4InSubnet(fieldname, string)',\n  documentation: 'Returns true if the field is a valid v4 IP address within the specified v4 subnet.'\n}, {\n  label: 'isIpv6InSubnet',\n  detail: 'isIpv6InSubnet(fieldname, string)',\n  documentation: 'Returns true if the field is a valid v6 IP address within the specified v6 subnet.'\n}];\nexport const BOOLEAN_FUNCTIONS = [{\n  label: 'ispresent',\n  detail: 'ispresent(fieldname)',\n  documentation: 'Returns true if the field exists.'\n}, {\n  label: 'isempty',\n  detail: 'isempty(fieldname)',\n  documentation: 'Returns true if the field is missing or is an empty string.'\n}, {\n  label: 'isblank',\n  detail: 'isblank(fieldname)',\n  documentation: 'Returns true if the field is missing, an empty string, or contains only white space.'\n}, {\n  label: 'strcontains',\n  detail: 'strcontains(string1, string2)',\n  documentation: 'Returns 1 if string1 contains string2 and 0 otherwise.'\n}, ...IP_FUNCTIONS];\nexport const AGGREGATION_FUNCTIONS_STATS = [{\n  label: 'avg',\n  detail: 'avg(NumericFieldname)',\n  documentation: 'The average of the values in the specified field.'\n}, {\n  label: 'count',\n  detail: 'count(fieldname) or count(*)',\n  documentation: 'Counts the log records.'\n}, {\n  label: 'count_distinct',\n  detail: 'count_distinct(fieldname)',\n  documentation: 'Returns the number of unique values for the field.'\n}, {\n  label: 'max',\n  detail: 'max(fieldname)',\n  documentation: 'The maximum of the values for this log field in the queried logs.'\n}, {\n  label: 'min',\n  detail: 'min(fieldname)',\n  documentation: 'The minimum of the values for this log field in the queried logs.'\n}, {\n  label: 'pct',\n  detail: 'pct(fieldname, value)',\n  documentation: 'A percentile indicates the relative standing of a value in a datas.'\n}, {\n  label: 'stddev',\n  detail: 'stddev(NumericFieldname)',\n  documentation: 'The standard deviation of the values in the specified field.'\n}, {\n  label: 'sum',\n  detail: 'sum(NumericFieldname)',\n  documentation: 'The sum of the values in the specified field.'\n}];\nexport const NON_AGGREGATION_FUNCS_STATS = [{\n  label: 'earliest',\n  detail: 'earliest(fieldname)',\n  documentation: 'Returns the value of fieldName from the log event that has the earliest time stamp in the queried logs.'\n}, {\n  label: 'latest',\n  detail: 'latest(fieldname)',\n  documentation: 'Returns the value of fieldName from the log event that has the latest time stamp in the queried logs.'\n}, {\n  label: 'sortsFirst',\n  detail: 'sortsFirst(fieldname)',\n  documentation: 'Returns the value of fieldName that sorts first in the queried logs.'\n}, {\n  label: 'sortsLast',\n  detail: 'sortsLast(fieldname)',\n  documentation: 'Returns the value of fieldName that sorts last in the queried logs.'\n}];\nexport const STATS_FUNCS = [...AGGREGATION_FUNCTIONS_STATS, ...NON_AGGREGATION_FUNCS_STATS];\nexport const KEYWORDS = ['as', 'like', 'by', 'in', 'desc', 'asc'];\nexport const FIELD_AND_FILTER_FUNCTIONS = [...NUMERIC_OPERATORS, ...GENERAL_FUNCTIONS, ...STRING_FUNCTIONS, ...DATETIME_FUNCTIONS, ...IP_FUNCTIONS];\nexport const FUNCTIONS = [...FIELD_AND_FILTER_FUNCTIONS, ...STATS_FUNCS];\nconst tokenizer = {\n  comment: {\n    pattern: /^#.*/,\n    greedy: true\n  },\n  backticks: {\n    pattern: /`.*?`/,\n    alias: 'string',\n    greedy: true\n  },\n  quote: {\n    pattern: /\".*?\"/,\n    alias: 'string',\n    greedy: true\n  },\n  regex: {\n    pattern: /\\/.*?\\/(?=\\||\\s*$|,)/,\n    greedy: true\n  },\n  'query-command': {\n    pattern: new RegExp(`\\\\b(?:${QUERY_COMMANDS.map(command => command.label).join('|')})\\\\b`, 'i'),\n    alias: 'function'\n  },\n  function: {\n    pattern: new RegExp(`\\\\b(?:${FUNCTIONS.map(f => f.label).join('|')})\\\\b`, 'i')\n  },\n  keyword: {\n    pattern: new RegExp(`(\\\\s+)(${KEYWORDS.join('|')})(?=\\\\s+)`, 'i'),\n    lookbehind: true\n  },\n  // 'log-group-name': {\n  //   pattern: /[\\.\\-_/#A-Za-z0-9]+/,\n  // },\n  'field-name': {\n    pattern: /(@?[_a-zA-Z]+[_.0-9a-zA-Z]*)|(`((\\\\`)|([^`]))*?`)/,\n    greedy: true\n  },\n  number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  'command-separator': {\n    pattern: /\\|/,\n    alias: 'punctuation'\n  },\n  'comparison-operator': {\n    pattern: /([<>]=?)|(!?=)/\n  },\n  punctuation: /[{}()`,.]/,\n  whitespace: /\\s+/\n};\nexport default tokenizer;","map":{"version":3,"names":["QUERY_COMMANDS","label","documentation","COMPARISON_OPERATORS","ARITHMETIC_OPERATORS","NUMERIC_OPERATORS","detail","GENERAL_FUNCTIONS","STRING_FUNCTIONS","DATETIME_FUNCTIONS","IP_FUNCTIONS","BOOLEAN_FUNCTIONS","AGGREGATION_FUNCTIONS_STATS","NON_AGGREGATION_FUNCS_STATS","STATS_FUNCS","KEYWORDS","FIELD_AND_FILTER_FUNCTIONS","FUNCTIONS","tokenizer","comment","pattern","greedy","backticks","alias","quote","regex","RegExp","map","command","join","function","f","keyword","lookbehind","number","punctuation","whitespace"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/syntax.ts"],"sourcesContent":["import { Grammar } from 'prismjs';\n\nimport { CompletionItem } from '@grafana/ui';\n\nexport const QUERY_COMMANDS: CompletionItem[] = [\n  {\n    label: 'fields',\n    documentation: 'Retrieves the specified fields from log events',\n  },\n  { label: 'display', documentation: 'Specifies which fields to display in the query results' },\n  {\n    label: 'filter',\n    documentation: 'Filters the results of a query based on one or more conditions',\n  },\n  {\n    label: 'stats',\n    documentation: 'Calculates aggregate statistics based on the values of log fields',\n  },\n  { label: 'sort', documentation: 'Sorts the retrieved log events' },\n  { label: 'limit', documentation: 'Specifies the number of log events returned by the query' },\n  {\n    label: 'parse',\n    documentation:\n      'Extracts data from a log field, creating one or more ephemeral fields that you can process further in the query',\n  },\n];\n\nexport const COMPARISON_OPERATORS = ['=', '!=', '<', '<=', '>', '>='];\nexport const ARITHMETIC_OPERATORS = ['+', '-', '*', '/', '^', '%'];\n\nexport const NUMERIC_OPERATORS = [\n  {\n    label: 'abs',\n    detail: 'abs(a)',\n    documentation: 'Absolute value.',\n  },\n  {\n    label: 'ceil',\n    detail: 'ceil(a)',\n    documentation: 'Round to ceiling (the smallest integer that is greater than the value of a).',\n  },\n  {\n    label: 'floor',\n    detail: 'floor(a)',\n    documentation: 'Round to floor (the largest integer that is smaller than the value of a).',\n  },\n  {\n    label: 'greatest',\n    detail: 'greatest(a,b, ... z)',\n    documentation: 'Returns the largest value.',\n  },\n  {\n    label: 'least',\n    detail: 'least(a, b, ... z)',\n    documentation: 'Returns the smallest value.',\n  },\n  {\n    label: 'log',\n    detail: 'log(a)',\n    documentation: 'Natural logarithm.',\n  },\n  {\n    label: 'sqrt',\n    detail: 'sqrt(a)',\n    documentation: 'Square root.',\n  },\n];\n\nexport const GENERAL_FUNCTIONS = [\n  {\n    label: 'ispresent',\n    detail: 'ispresent(fieldname)',\n    documentation: 'Returns true if the field exists.',\n  },\n  {\n    label: 'coalesce',\n    detail: 'coalesce(fieldname1, fieldname2, ... fieldnamex)',\n    documentation: 'Returns the first non-null value from the list.',\n  },\n];\n\nexport const STRING_FUNCTIONS = [\n  {\n    label: 'isempty',\n    detail: 'isempty(fieldname)',\n    documentation: 'Returns true if the field is missing or is an empty string.',\n  },\n  {\n    label: 'isblank',\n    detail: 'isblank(fieldname)',\n    documentation: 'Returns true if the field is missing, an empty string, or contains only white space.',\n  },\n  {\n    label: 'concat',\n    detail: 'concat(string1, string2, ... stringz)',\n    documentation: 'Concatenates the strings.',\n  },\n  {\n    label: 'ltrim',\n    detail: 'ltrim(string) or ltrim(string1, string2)',\n    documentation:\n      'Remove white space from the left of the string. If the function has a second string argument, it removes the characters of string2 from the left of string1.',\n  },\n  {\n    label: 'rtrim',\n    detail: 'rtrim(string) or rtrim(string1, string2)',\n    documentation:\n      'Remove white space from the right of the string. If the function has a second string argument, it removes the characters of string2 from the right of string1.',\n  },\n  {\n    label: 'trim',\n    detail: 'trim(string) or trim(string1, string2)',\n    documentation:\n      'Remove white space from both ends of the string. If the function has a second string argument, it removes the characters of string2 from both sides of string1.',\n  },\n  {\n    label: 'strlen',\n    detail: 'strlen(string)',\n    documentation: 'Returns the length of the string in Unicode code points.',\n  },\n  {\n    label: 'toupper',\n    detail: 'toupper(string)',\n    documentation: 'Converts the string to uppercase.',\n  },\n  {\n    label: 'tolower',\n    detail: 'tolower(string)',\n    documentation: 'Converts the string to lowercase.',\n  },\n  {\n    label: 'substr',\n    detail: 'substr(string1, x), or substr(string1, x, y)',\n    documentation:\n      'Returns a substring from the index specified by the number argument to the end of the string. If the function has a second number argument, it contains the length of the substring to be retrieved.',\n  },\n  {\n    label: 'replace',\n    detail: 'replace(string1, string2, string3)',\n    documentation: 'Replaces all instances of string2 in string1 with string3.',\n  },\n  {\n    label: 'strcontains',\n    detail: 'strcontains(string1, string2)',\n    documentation: 'Returns 1 if string1 contains string2 and 0 otherwise.',\n  },\n];\n\nexport const DATETIME_FUNCTIONS = [\n  {\n    label: 'bin',\n    detail: 'bin(period)',\n    documentation: 'Rounds the value of @timestamp to the given period and then truncates.',\n  },\n  {\n    label: 'datefloor',\n    detail: 'datefloor(a, period)',\n    documentation: 'Truncates the timestamp to the given period.',\n  },\n  {\n    label: 'dateceil',\n    detail: 'dateceil(a, period)',\n    documentation: 'Rounds up the timestamp to the given period and then truncates.',\n  },\n  {\n    label: 'fromMillis',\n    detail: 'fromMillis(fieldname)',\n    documentation:\n      'Interprets the input field as the number of milliseconds since the Unix epoch and converts it to a timestamp.',\n  },\n  {\n    label: 'toMillis',\n    detail: 'toMillis(fieldname)',\n    documentation:\n      'Converts the timestamp found in the named field into a number representing the milliseconds since the Unix epoch.',\n  },\n];\n\nexport const IP_FUNCTIONS = [\n  {\n    label: 'isValidIp',\n    detail: 'isValidIp(fieldname)',\n    documentation: 'Returns true if the field is a valid v4 or v6 IP address.',\n  },\n  {\n    label: 'isValidIpV4',\n    detail: 'isValidIpV4(fieldname)',\n    documentation: 'Returns true if the field is a valid v4 IP address.',\n  },\n  {\n    label: 'isValidIpV6',\n    detail: 'isValidIpV6(fieldname)',\n    documentation: 'Returns true if the field is a valid v6 IP address.',\n  },\n  {\n    label: 'isIpInSubnet',\n    detail: 'isIpInSubnet(fieldname, string)',\n    documentation: 'Returns true if the field is a valid v4 or v6 IP address within the specified v4 or v6 subnet.',\n  },\n  {\n    label: 'isIpv4InSubnet',\n    detail: 'isIpv4InSubnet(fieldname, string)',\n    documentation: 'Returns true if the field is a valid v4 IP address within the specified v4 subnet.',\n  },\n  {\n    label: 'isIpv6InSubnet',\n    detail: 'isIpv6InSubnet(fieldname, string)',\n    documentation: 'Returns true if the field is a valid v6 IP address within the specified v6 subnet.',\n  },\n];\n\nexport const BOOLEAN_FUNCTIONS = [\n  {\n    label: 'ispresent',\n    detail: 'ispresent(fieldname)',\n    documentation: 'Returns true if the field exists.',\n  },\n  {\n    label: 'isempty',\n    detail: 'isempty(fieldname)',\n    documentation: 'Returns true if the field is missing or is an empty string.',\n  },\n  {\n    label: 'isblank',\n    detail: 'isblank(fieldname)',\n    documentation: 'Returns true if the field is missing, an empty string, or contains only white space.',\n  },\n  {\n    label: 'strcontains',\n    detail: 'strcontains(string1, string2)',\n    documentation: 'Returns 1 if string1 contains string2 and 0 otherwise.',\n  },\n  ...IP_FUNCTIONS,\n];\n\nexport const AGGREGATION_FUNCTIONS_STATS = [\n  {\n    label: 'avg',\n    detail: 'avg(NumericFieldname)',\n    documentation: 'The average of the values in the specified field.',\n  },\n  {\n    label: 'count',\n    detail: 'count(fieldname) or count(*)',\n    documentation: 'Counts the log records.',\n  },\n  {\n    label: 'count_distinct',\n    detail: 'count_distinct(fieldname)',\n    documentation: 'Returns the number of unique values for the field.',\n  },\n  {\n    label: 'max',\n    detail: 'max(fieldname)',\n    documentation: 'The maximum of the values for this log field in the queried logs.',\n  },\n  {\n    label: 'min',\n    detail: 'min(fieldname)',\n    documentation: 'The minimum of the values for this log field in the queried logs.',\n  },\n  {\n    label: 'pct',\n    detail: 'pct(fieldname, value)',\n    documentation: 'A percentile indicates the relative standing of a value in a datas.',\n  },\n  {\n    label: 'stddev',\n    detail: 'stddev(NumericFieldname)',\n    documentation: 'The standard deviation of the values in the specified field.',\n  },\n  {\n    label: 'sum',\n    detail: 'sum(NumericFieldname)',\n    documentation: 'The sum of the values in the specified field.',\n  },\n];\n\nexport const NON_AGGREGATION_FUNCS_STATS = [\n  {\n    label: 'earliest',\n    detail: 'earliest(fieldname)',\n    documentation:\n      'Returns the value of fieldName from the log event that has the earliest time stamp in the queried logs.',\n  },\n  {\n    label: 'latest',\n    detail: 'latest(fieldname)',\n    documentation:\n      'Returns the value of fieldName from the log event that has the latest time stamp in the queried logs.',\n  },\n  {\n    label: 'sortsFirst',\n    detail: 'sortsFirst(fieldname)',\n    documentation: 'Returns the value of fieldName that sorts first in the queried logs.',\n  },\n  {\n    label: 'sortsLast',\n    detail: 'sortsLast(fieldname)',\n    documentation: 'Returns the value of fieldName that sorts last in the queried logs.',\n  },\n];\n\nexport const STATS_FUNCS = [...AGGREGATION_FUNCTIONS_STATS, ...NON_AGGREGATION_FUNCS_STATS];\n\nexport const KEYWORDS = ['as', 'like', 'by', 'in', 'desc', 'asc'];\nexport const FIELD_AND_FILTER_FUNCTIONS = [\n  ...NUMERIC_OPERATORS,\n  ...GENERAL_FUNCTIONS,\n  ...STRING_FUNCTIONS,\n  ...DATETIME_FUNCTIONS,\n  ...IP_FUNCTIONS,\n];\n\nexport const FUNCTIONS = [...FIELD_AND_FILTER_FUNCTIONS, ...STATS_FUNCS];\n\nconst tokenizer: Grammar = {\n  comment: {\n    pattern: /^#.*/,\n    greedy: true,\n  },\n  backticks: {\n    pattern: /`.*?`/,\n    alias: 'string',\n    greedy: true,\n  },\n  quote: {\n    pattern: /\".*?\"/,\n    alias: 'string',\n    greedy: true,\n  },\n  regex: {\n    pattern: /\\/.*?\\/(?=\\||\\s*$|,)/,\n    greedy: true,\n  },\n  'query-command': {\n    pattern: new RegExp(`\\\\b(?:${QUERY_COMMANDS.map((command) => command.label).join('|')})\\\\b`, 'i'),\n    alias: 'function',\n  },\n  function: {\n    pattern: new RegExp(`\\\\b(?:${FUNCTIONS.map((f) => f.label).join('|')})\\\\b`, 'i'),\n  },\n  keyword: {\n    pattern: new RegExp(`(\\\\s+)(${KEYWORDS.join('|')})(?=\\\\s+)`, 'i'),\n    lookbehind: true,\n  },\n  // 'log-group-name': {\n  //   pattern: /[\\.\\-_/#A-Za-z0-9]+/,\n  // },\n  'field-name': {\n    pattern: /(@?[_a-zA-Z]+[_.0-9a-zA-Z]*)|(`((\\\\`)|([^`]))*?`)/,\n    greedy: true,\n  },\n  number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  'command-separator': {\n    pattern: /\\|/,\n    alias: 'punctuation',\n  },\n  'comparison-operator': {\n    pattern: /([<>]=?)|(!?=)/,\n  },\n  punctuation: /[{}()`,.]/,\n  whitespace: /\\s+/,\n};\n\nexport default tokenizer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}