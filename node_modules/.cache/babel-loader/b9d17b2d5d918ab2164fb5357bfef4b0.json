{"ast":null,"code":"import tinycolor from 'tinycolor2';\nimport { colorManipulator, FieldColorModeId, ThresholdsMode } from '@grafana/data';\nimport { ScaleOrientation } from '@grafana/schema';\nimport { getCanvasContext } from '../../../utils/measureText';\n\nfunction makeDirectionalGradient(direction, bbox, ctx) {\n  let x0 = 0,\n      y0 = 0,\n      x1 = 0,\n      y1 = 0;\n\n  if (direction === GradientDirection.Down) {\n    y0 = bbox.top;\n    y1 = bbox.top + bbox.height;\n  } else if (direction === GradientDirection.Left) {\n    x0 = bbox.left + bbox.width;\n    x1 = bbox.left;\n  } else if (direction === GradientDirection.Up) {\n    y0 = bbox.top + bbox.height;\n    y1 = bbox.top;\n  } else if (direction === GradientDirection.Right) {\n    x0 = bbox.left;\n    x1 = bbox.left + bbox.width;\n  }\n\n  return ctx.createLinearGradient(x0, y0, x1, y1);\n}\n\nexport function getOpacityGradientFn(color, opacity) {\n  return (plot, seriesIdx) => {\n    const ctx = getCanvasContext();\n    const gradient = makeDirectionalGradient(plot.scales.x.ori === ScaleOrientation.Horizontal ? GradientDirection.Down : GradientDirection.Left, plot.bbox, ctx);\n    gradient.addColorStop(0, colorManipulator.alpha(color, opacity));\n    gradient.addColorStop(1, colorManipulator.alpha(color, 0));\n    return gradient;\n  };\n}\nexport function getHueGradientFn(color, opacity, theme) {\n  return (plot, seriesIdx) => {\n    const ctx = getCanvasContext();\n    const gradient = makeDirectionalGradient(plot.scales.x.ori === ScaleOrientation.Horizontal ? GradientDirection.Down : GradientDirection.Left, plot.bbox, ctx);\n    const color1 = tinycolor(color).spin(-15);\n    const color2 = tinycolor(color).spin(15);\n\n    if (theme.isDark) {\n      gradient.addColorStop(0, color2.lighten(10).setAlpha(opacity).toString());\n      gradient.addColorStop(1, color1.darken(10).setAlpha(opacity).toString());\n    } else {\n      gradient.addColorStop(0, color2.lighten(10).setAlpha(opacity).toString());\n      gradient.addColorStop(1, color1.setAlpha(opacity).toString());\n    }\n\n    return gradient;\n  };\n}\nexport let GradientDirection;\n\n(function (GradientDirection) {\n  GradientDirection[GradientDirection[\"Right\"] = 0] = \"Right\";\n  GradientDirection[GradientDirection[\"Up\"] = 1] = \"Up\";\n  GradientDirection[GradientDirection[\"Left\"] = 2] = \"Left\";\n  GradientDirection[GradientDirection[\"Down\"] = 3] = \"Down\";\n})(GradientDirection || (GradientDirection = {}));\n\nexport function scaleGradient(u, scaleKey, scaleStops, discrete = false) {\n  let scale = u.scales[scaleKey]; // we want the stop below or at the scaleMax\n  // and the stop below or at the scaleMin, else the stop above scaleMin\n\n  let minStopIdx = null;\n  let maxStopIdx = null;\n\n  for (let i = 0; i < scaleStops.length; i++) {\n    let stopVal = scaleStops[i][0];\n\n    if (stopVal <= scale.min || minStopIdx == null) {\n      minStopIdx = i;\n    }\n\n    maxStopIdx = i;\n\n    if (stopVal >= scale.max) {\n      break;\n    }\n  }\n\n  if (minStopIdx === maxStopIdx) {\n    return scaleStops[minStopIdx][1];\n  }\n\n  let minStopVal = scaleStops[minStopIdx][0];\n  let maxStopVal = scaleStops[maxStopIdx][0];\n\n  if (minStopVal === -Infinity) {\n    minStopVal = scale.min;\n  }\n\n  if (maxStopVal === Infinity) {\n    maxStopVal = scale.max;\n  }\n\n  let minStopPos = Math.round(u.valToPos(minStopVal, scaleKey, true));\n  let maxStopPos = Math.round(u.valToPos(maxStopVal, scaleKey, true));\n  let range = minStopPos - maxStopPos;\n\n  if (range === 0) {\n    return scaleStops[maxStopIdx][1];\n  }\n\n  let x0, y0, x1, y1;\n\n  if (u.scales.x.ori === ScaleOrientation.Horizontal) {\n    x0 = x1 = 0;\n    y0 = minStopPos;\n    y1 = maxStopPos;\n  } else {\n    y0 = y1 = 0;\n    x0 = minStopPos;\n    x1 = maxStopPos;\n  }\n\n  let ctx = getCanvasContext();\n  let grd = ctx.createLinearGradient(x0, y0, x1, y1);\n  let prevColor;\n\n  for (let i = minStopIdx; i <= maxStopIdx; i++) {\n    let s = scaleStops[i];\n    let stopPos = i === minStopIdx ? minStopPos : i === maxStopIdx ? maxStopPos : Math.round(u.valToPos(s[0], scaleKey, true));\n    let pct = (minStopPos - stopPos) / range;\n\n    if (discrete && i > minStopIdx) {\n      grd.addColorStop(pct, prevColor);\n    }\n\n    grd.addColorStop(pct, prevColor = s[1]);\n  }\n\n  return grd;\n}\nexport function getDataRange(plot, scaleKey) {\n  let sc = plot.scales[scaleKey];\n  let min = Infinity;\n  let max = -Infinity;\n  plot.series.forEach((ser, seriesIdx) => {\n    if (ser.show && ser.scale === scaleKey) {\n      // uPlot skips finding data min/max when a scale has a pre-defined range\n      if (ser.min == null) {\n        let data = plot.data[seriesIdx];\n\n        for (let i = 0; i < data.length; i++) {\n          if (data[i] != null) {\n            min = Math.min(min, data[i]);\n            max = Math.max(max, data[i]);\n          }\n        }\n      } else {\n        min = Math.min(min, ser.min);\n        max = Math.max(max, ser.max);\n      }\n    }\n  });\n\n  if (max === min) {\n    min = sc.min;\n    max = sc.max;\n  }\n\n  return [min, max];\n}\nexport function getGradientRange(u, scaleKey, hardMin, hardMax, softMin, softMax) {\n  var _ref, _ref2;\n\n  let min = (_ref = hardMin !== null && hardMin !== void 0 ? hardMin : softMin) !== null && _ref !== void 0 ? _ref : null;\n  let max = (_ref2 = hardMax !== null && hardMax !== void 0 ? hardMax : softMax) !== null && _ref2 !== void 0 ? _ref2 : null;\n\n  if (min == null || max == null) {\n    var _ref3, _min, _ref4, _max;\n\n    let [dataMin, dataMax] = getDataRange(u, scaleKey);\n    min = (_ref3 = (_min = min) !== null && _min !== void 0 ? _min : dataMin) !== null && _ref3 !== void 0 ? _ref3 : 0;\n    max = (_ref4 = (_max = max) !== null && _max !== void 0 ? _max : dataMax) !== null && _ref4 !== void 0 ? _ref4 : 100;\n  }\n\n  return [min, max];\n}\nexport function getScaleGradientFn(opacity, theme, colorMode, thresholds, hardMin, hardMax, softMin, softMax) {\n  if (!colorMode) {\n    throw Error('Missing colorMode required for color scheme gradients');\n  }\n\n  if (!thresholds) {\n    throw Error('Missing thresholds required for color scheme gradients');\n  }\n\n  return (plot, seriesIdx) => {\n    let scaleKey = plot.series[seriesIdx].scale;\n    let gradient = '';\n\n    if (colorMode.id === FieldColorModeId.Thresholds) {\n      if (thresholds.mode === ThresholdsMode.Absolute) {\n        const valueStops = thresholds.steps.map(step => [step.value, colorManipulator.alpha(theme.visualization.getColorByName(step.color), opacity)]);\n        gradient = scaleGradient(plot, scaleKey, valueStops, true);\n      } else {\n        const [min, max] = getGradientRange(plot, scaleKey, hardMin, hardMax, softMin, softMax);\n        const range = max - min;\n        const valueStops = thresholds.steps.map(step => [min + range * (step.value / 100), colorManipulator.alpha(theme.visualization.getColorByName(step.color), opacity)]);\n        gradient = scaleGradient(plot, scaleKey, valueStops, true);\n      }\n    } else if (colorMode.getColors) {\n      const colors = colorMode.getColors(theme);\n      const [min, max] = getGradientRange(plot, scaleKey, hardMin, hardMax, softMin, softMax);\n      const range = max - min;\n      const valueStops = colors.map((color, i) => [min + range * (i / (colors.length - 1)), colorManipulator.alpha(theme.visualization.getColorByName(color), opacity)]);\n      gradient = scaleGradient(plot, scaleKey, valueStops, false);\n    }\n\n    return gradient;\n  };\n}","map":{"version":3,"names":["tinycolor","colorManipulator","FieldColorModeId","ThresholdsMode","ScaleOrientation","getCanvasContext","makeDirectionalGradient","direction","bbox","ctx","x0","y0","x1","y1","GradientDirection","Down","top","height","Left","left","width","Up","Right","createLinearGradient","getOpacityGradientFn","color","opacity","plot","seriesIdx","gradient","scales","x","ori","Horizontal","addColorStop","alpha","getHueGradientFn","theme","color1","spin","color2","isDark","lighten","setAlpha","toString","darken","scaleGradient","u","scaleKey","scaleStops","discrete","scale","minStopIdx","maxStopIdx","i","length","stopVal","min","max","minStopVal","maxStopVal","Infinity","minStopPos","Math","round","valToPos","maxStopPos","range","grd","prevColor","s","stopPos","pct","getDataRange","sc","series","forEach","ser","show","data","getGradientRange","hardMin","hardMax","softMin","softMax","dataMin","dataMax","getScaleGradientFn","colorMode","thresholds","Error","id","Thresholds","mode","Absolute","valueStops","steps","map","step","value","visualization","getColorByName","getColors","colors"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/uPlot/config/gradientFills.ts"],"sourcesContent":["import tinycolor from 'tinycolor2';\nimport uPlot from 'uplot';\n\nimport {\n  colorManipulator,\n  FieldColorMode,\n  FieldColorModeId,\n  GrafanaTheme2,\n  ThresholdsConfig,\n  ThresholdsMode,\n} from '@grafana/data';\nimport { ScaleOrientation } from '@grafana/schema';\n\nimport { getCanvasContext } from '../../../utils/measureText';\n\nfunction makeDirectionalGradient(direction: GradientDirection, bbox: uPlot.BBox, ctx: CanvasRenderingContext2D) {\n  let x0 = 0,\n    y0 = 0,\n    x1 = 0,\n    y1 = 0;\n\n  if (direction === GradientDirection.Down) {\n    y0 = bbox.top;\n    y1 = bbox.top + bbox.height;\n  } else if (direction === GradientDirection.Left) {\n    x0 = bbox.left + bbox.width;\n    x1 = bbox.left;\n  } else if (direction === GradientDirection.Up) {\n    y0 = bbox.top + bbox.height;\n    y1 = bbox.top;\n  } else if (direction === GradientDirection.Right) {\n    x0 = bbox.left;\n    x1 = bbox.left + bbox.width;\n  }\n\n  return ctx.createLinearGradient(x0, y0, x1, y1);\n}\n\nexport function getOpacityGradientFn(\n  color: string,\n  opacity: number\n): (self: uPlot, seriesIdx: number) => CanvasGradient {\n  return (plot: uPlot, seriesIdx: number) => {\n    const ctx = getCanvasContext();\n    const gradient = makeDirectionalGradient(\n      plot.scales.x!.ori === ScaleOrientation.Horizontal ? GradientDirection.Down : GradientDirection.Left,\n      plot.bbox,\n      ctx\n    );\n\n    gradient.addColorStop(0, colorManipulator.alpha(color, opacity));\n    gradient.addColorStop(1, colorManipulator.alpha(color, 0));\n\n    return gradient;\n  };\n}\n\nexport function getHueGradientFn(\n  color: string,\n  opacity: number,\n  theme: GrafanaTheme2\n): (self: uPlot, seriesIdx: number) => CanvasGradient {\n  return (plot: uPlot, seriesIdx: number) => {\n    const ctx = getCanvasContext();\n    const gradient = makeDirectionalGradient(\n      plot.scales.x!.ori === ScaleOrientation.Horizontal ? GradientDirection.Down : GradientDirection.Left,\n      plot.bbox,\n      ctx\n    );\n\n    const color1 = tinycolor(color).spin(-15);\n    const color2 = tinycolor(color).spin(15);\n\n    if (theme.isDark) {\n      gradient.addColorStop(0, color2.lighten(10).setAlpha(opacity).toString());\n      gradient.addColorStop(1, color1.darken(10).setAlpha(opacity).toString());\n    } else {\n      gradient.addColorStop(0, color2.lighten(10).setAlpha(opacity).toString());\n      gradient.addColorStop(1, color1.setAlpha(opacity).toString());\n    }\n\n    return gradient;\n  };\n}\n\nexport enum GradientDirection {\n  Right = 0,\n  Up = 1,\n  Left = 2,\n  Down = 3,\n}\n\ntype ValueStop = [value: number, color: string];\n\ntype ScaleValueStops = ValueStop[];\n\nexport function scaleGradient(u: uPlot, scaleKey: string, scaleStops: ScaleValueStops, discrete = false) {\n  let scale = u.scales[scaleKey];\n\n  // we want the stop below or at the scaleMax\n  // and the stop below or at the scaleMin, else the stop above scaleMin\n  let minStopIdx: number | null = null;\n  let maxStopIdx: number | null = null;\n\n  for (let i = 0; i < scaleStops.length; i++) {\n    let stopVal = scaleStops[i][0];\n\n    if (stopVal <= scale.min! || minStopIdx == null) {\n      minStopIdx = i;\n    }\n\n    maxStopIdx = i;\n\n    if (stopVal >= scale.max!) {\n      break;\n    }\n  }\n\n  if (minStopIdx === maxStopIdx) {\n    return scaleStops[minStopIdx!][1];\n  }\n\n  let minStopVal = scaleStops[minStopIdx!][0];\n  let maxStopVal = scaleStops[maxStopIdx!][0];\n\n  if (minStopVal === -Infinity) {\n    minStopVal = scale.min!;\n  }\n\n  if (maxStopVal === Infinity) {\n    maxStopVal = scale.max!;\n  }\n\n  let minStopPos = Math.round(u.valToPos(minStopVal, scaleKey, true));\n  let maxStopPos = Math.round(u.valToPos(maxStopVal, scaleKey, true));\n\n  let range = minStopPos - maxStopPos;\n\n  if (range === 0) {\n    return scaleStops[maxStopIdx!][1];\n  }\n\n  let x0, y0, x1, y1;\n\n  if (u.scales.x!.ori === ScaleOrientation.Horizontal) {\n    x0 = x1 = 0;\n    y0 = minStopPos;\n    y1 = maxStopPos;\n  } else {\n    y0 = y1 = 0;\n    x0 = minStopPos;\n    x1 = maxStopPos;\n  }\n\n  let ctx = getCanvasContext();\n\n  let grd = ctx.createLinearGradient(x0, y0, x1, y1);\n\n  let prevColor: string;\n\n  for (let i = minStopIdx!; i <= maxStopIdx!; i++) {\n    let s = scaleStops[i];\n\n    let stopPos =\n      i === minStopIdx ? minStopPos : i === maxStopIdx ? maxStopPos : Math.round(u.valToPos(s[0], scaleKey, true));\n\n    let pct = (minStopPos - stopPos) / range;\n\n    if (discrete && i > minStopIdx!) {\n      grd.addColorStop(pct, prevColor!);\n    }\n\n    grd.addColorStop(pct, (prevColor = s[1]));\n  }\n\n  return grd;\n}\n\nexport function getDataRange(plot: uPlot, scaleKey: string) {\n  let sc = plot.scales[scaleKey];\n\n  let min = Infinity;\n  let max = -Infinity;\n\n  plot.series.forEach((ser, seriesIdx) => {\n    if (ser.show && ser.scale === scaleKey) {\n      // uPlot skips finding data min/max when a scale has a pre-defined range\n      if (ser.min == null) {\n        let data = plot.data[seriesIdx];\n        for (let i = 0; i < data.length; i++) {\n          if (data[i] != null) {\n            min = Math.min(min, data[i]!);\n            max = Math.max(max, data[i]!);\n          }\n        }\n      } else {\n        min = Math.min(min, ser.min!);\n        max = Math.max(max, ser.max!);\n      }\n    }\n  });\n\n  if (max === min) {\n    min = sc.min!;\n    max = sc.max!;\n  }\n\n  return [min, max];\n}\n\nexport function getGradientRange(\n  u: uPlot,\n  scaleKey: string,\n  hardMin?: number | null,\n  hardMax?: number | null,\n  softMin?: number | null,\n  softMax?: number | null\n) {\n  let min = hardMin ?? softMin ?? null;\n  let max = hardMax ?? softMax ?? null;\n\n  if (min == null || max == null) {\n    let [dataMin, dataMax] = getDataRange(u, scaleKey);\n\n    min = min ?? dataMin ?? 0;\n    max = max ?? dataMax ?? 100;\n  }\n\n  return [min, max];\n}\n\nexport function getScaleGradientFn(\n  opacity: number,\n  theme: GrafanaTheme2,\n  colorMode?: FieldColorMode,\n  thresholds?: ThresholdsConfig,\n  hardMin?: number | null,\n  hardMax?: number | null,\n  softMin?: number | null,\n  softMax?: number | null\n): (self: uPlot, seriesIdx: number) => CanvasGradient | string {\n  if (!colorMode) {\n    throw Error('Missing colorMode required for color scheme gradients');\n  }\n\n  if (!thresholds) {\n    throw Error('Missing thresholds required for color scheme gradients');\n  }\n\n  return (plot: uPlot, seriesIdx: number) => {\n    let scaleKey = plot.series[seriesIdx].scale!;\n\n    let gradient: CanvasGradient | string = '';\n\n    if (colorMode.id === FieldColorModeId.Thresholds) {\n      if (thresholds.mode === ThresholdsMode.Absolute) {\n        const valueStops = thresholds.steps.map(\n          (step) =>\n            [step.value, colorManipulator.alpha(theme.visualization.getColorByName(step.color), opacity)] as ValueStop\n        );\n        gradient = scaleGradient(plot, scaleKey, valueStops, true);\n      } else {\n        const [min, max] = getGradientRange(plot, scaleKey, hardMin, hardMax, softMin, softMax);\n        const range = max - min;\n        const valueStops = thresholds.steps.map(\n          (step) =>\n            [\n              min + range * (step.value / 100),\n              colorManipulator.alpha(theme.visualization.getColorByName(step.color), opacity),\n            ] as ValueStop\n        );\n        gradient = scaleGradient(plot, scaleKey, valueStops, true);\n      }\n    } else if (colorMode.getColors) {\n      const colors = colorMode.getColors(theme);\n      const [min, max] = getGradientRange(plot, scaleKey, hardMin, hardMax, softMin, softMax);\n      const range = max - min;\n      const valueStops = colors.map(\n        (color, i) =>\n          [\n            min + range * (i / (colors.length - 1)),\n            colorManipulator.alpha(theme.visualization.getColorByName(color), opacity),\n          ] as ValueStop\n      );\n      gradient = scaleGradient(plot, scaleKey, valueStops, false);\n    }\n\n    return gradient;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}