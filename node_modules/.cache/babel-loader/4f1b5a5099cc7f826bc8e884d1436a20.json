{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { AbstractLabelOperator, LanguageProvider } from '@grafana/data';\nexport default class ElasticsearchLanguageProvider extends LanguageProvider {\n  constructor(datasource, initialValues) {\n    super();\n\n    _defineProperty(this, \"datasource\", void 0);\n\n    this.datasource = datasource;\n    Object.assign(this, initialValues);\n  }\n  /**\n   * Queries are transformed to an ES Logs query since it's the behaviour most users expect.\n   **/\n\n\n  importFromAbstractQuery(abstractQuery) {\n    return {\n      metrics: [{\n        id: '1',\n        type: 'logs'\n      }],\n      query: this.getElasticsearchQuery(abstractQuery.labelMatchers),\n      refId: abstractQuery.refId\n    };\n  }\n\n  getElasticsearchQuery(labels) {\n    return labels.map(label => {\n      switch (label.operator) {\n        case AbstractLabelOperator.Equal:\n          {\n            return label.name + ':\"' + label.value + '\"';\n          }\n\n        case AbstractLabelOperator.NotEqual:\n          {\n            return 'NOT ' + label.name + ':\"' + label.value + '\"';\n          }\n\n        case AbstractLabelOperator.EqualRegEx:\n          {\n            return label.name + ':/' + label.value + '/';\n          }\n\n        case AbstractLabelOperator.NotEqualRegEx:\n          {\n            return 'NOT ' + label.name + ':/' + label.value + '/';\n          }\n      }\n    }).join(' AND ');\n  }\n\n}","map":{"version":3,"names":["AbstractLabelOperator","LanguageProvider","ElasticsearchLanguageProvider","constructor","datasource","initialValues","Object","assign","importFromAbstractQuery","abstractQuery","metrics","id","type","query","getElasticsearchQuery","labelMatchers","refId","labels","map","label","operator","Equal","name","value","NotEqual","EqualRegEx","NotEqualRegEx","join"],"sources":["/home/soula/grafana/public/app/plugins/datasource/elasticsearch/language_provider.ts"],"sourcesContent":["import { AbstractLabelOperator, AbstractLabelMatcher, LanguageProvider, AbstractQuery } from '@grafana/data';\n\nimport { ElasticDatasource } from './datasource';\nimport { ElasticsearchQuery } from './types';\n\nexport default class ElasticsearchLanguageProvider extends LanguageProvider {\n  declare request: (url: string, params?: any) => Promise<any>;\n  declare start: () => Promise<any[]>;\n  datasource: ElasticDatasource;\n\n  constructor(datasource: ElasticDatasource, initialValues?: any) {\n    super();\n    this.datasource = datasource;\n\n    Object.assign(this, initialValues);\n  }\n\n  /**\n   * Queries are transformed to an ES Logs query since it's the behaviour most users expect.\n   **/\n  importFromAbstractQuery(abstractQuery: AbstractQuery): ElasticsearchQuery {\n    return {\n      metrics: [\n        {\n          id: '1',\n          type: 'logs',\n        },\n      ],\n      query: this.getElasticsearchQuery(abstractQuery.labelMatchers),\n      refId: abstractQuery.refId,\n    };\n  }\n\n  getElasticsearchQuery(labels: AbstractLabelMatcher[]): string {\n    return labels\n      .map((label) => {\n        switch (label.operator) {\n          case AbstractLabelOperator.Equal: {\n            return label.name + ':\"' + label.value + '\"';\n          }\n          case AbstractLabelOperator.NotEqual: {\n            return 'NOT ' + label.name + ':\"' + label.value + '\"';\n          }\n          case AbstractLabelOperator.EqualRegEx: {\n            return label.name + ':/' + label.value + '/';\n          }\n          case AbstractLabelOperator.NotEqualRegEx: {\n            return 'NOT ' + label.name + ':/' + label.value + '/';\n          }\n        }\n      })\n      .join(' AND ');\n  }\n}\n"],"mappings":";;AAAA,SAASA,qBAAT,EAAsDC,gBAAtD,QAA6F,eAA7F;AAKA,eAAe,MAAMC,6BAAN,SAA4CD,gBAA5C,CAA6D;EAK1EE,WAAW,CAACC,UAAD,EAAgCC,aAAhC,EAAqD;IAC9D;;IAD8D;;IAE9D,KAAKD,UAAL,GAAkBA,UAAlB;IAEAE,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBF,aAApB;EACD;EAED;AACF;AACA;;;EACEG,uBAAuB,CAACC,aAAD,EAAmD;IACxE,OAAO;MACLC,OAAO,EAAE,CACP;QACEC,EAAE,EAAE,GADN;QAEEC,IAAI,EAAE;MAFR,CADO,CADJ;MAOLC,KAAK,EAAE,KAAKC,qBAAL,CAA2BL,aAAa,CAACM,aAAzC,CAPF;MAQLC,KAAK,EAAEP,aAAa,CAACO;IARhB,CAAP;EAUD;;EAEDF,qBAAqB,CAACG,MAAD,EAAyC;IAC5D,OAAOA,MAAM,CACVC,GADI,CACCC,KAAD,IAAW;MACd,QAAQA,KAAK,CAACC,QAAd;QACE,KAAKpB,qBAAqB,CAACqB,KAA3B;UAAkC;YAChC,OAAOF,KAAK,CAACG,IAAN,GAAa,IAAb,GAAoBH,KAAK,CAACI,KAA1B,GAAkC,GAAzC;UACD;;QACD,KAAKvB,qBAAqB,CAACwB,QAA3B;UAAqC;YACnC,OAAO,SAASL,KAAK,CAACG,IAAf,GAAsB,IAAtB,GAA6BH,KAAK,CAACI,KAAnC,GAA2C,GAAlD;UACD;;QACD,KAAKvB,qBAAqB,CAACyB,UAA3B;UAAuC;YACrC,OAAON,KAAK,CAACG,IAAN,GAAa,IAAb,GAAoBH,KAAK,CAACI,KAA1B,GAAkC,GAAzC;UACD;;QACD,KAAKvB,qBAAqB,CAAC0B,aAA3B;UAA0C;YACxC,OAAO,SAASP,KAAK,CAACG,IAAf,GAAsB,IAAtB,GAA6BH,KAAK,CAACI,KAAnC,GAA2C,GAAlD;UACD;MAZH;IAcD,CAhBI,EAiBJI,IAjBI,CAiBC,OAjBD,CAAP;EAkBD;;AA/CyE"},"metadata":{},"sourceType":"module"}