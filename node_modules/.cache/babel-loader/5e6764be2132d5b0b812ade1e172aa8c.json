{"ast":null,"code":"import { SCHEMA } from '../../cloudwatch-sql/language';\nimport { QueryEditorExpressionType, QueryEditorPropertyType } from '../../expressions';\nexport function getMetricNameFromExpression(selectExpression) {\n  var _selectExpression$par;\n\n  return selectExpression === null || selectExpression === void 0 ? void 0 : (_selectExpression$par = selectExpression.parameters) === null || _selectExpression$par === void 0 ? void 0 : _selectExpression$par[0].name;\n}\nexport function getNamespaceFromExpression(fromExpression) {\n  // It's just a simple `FROM \"AWS/EC2\"` expression\n  if ((fromExpression === null || fromExpression === void 0 ? void 0 : fromExpression.type) === QueryEditorExpressionType.Property) {\n    return fromExpression.property.name; // PR TODO: do we need to test the type here? It can only be string?\n  } // It's a more complicated `FROM SCHEMA(\"AWS/EC2\", ...)` expression\n\n\n  if ((fromExpression === null || fromExpression === void 0 ? void 0 : fromExpression.type) === QueryEditorExpressionType.Function) {\n    var _fromExpression$param;\n\n    // TODO: do we need to test the name of the function?\n    return (_fromExpression$param = fromExpression.parameters) === null || _fromExpression$param === void 0 ? void 0 : _fromExpression$param[0].name;\n  }\n\n  return undefined;\n}\nexport function getSchemaLabelKeys(fromExpression) {\n  var _fromExpression$param2;\n\n  // Schema label keys are second to n arguments in the from expression function\n  if ((fromExpression === null || fromExpression === void 0 ? void 0 : fromExpression.type) === QueryEditorExpressionType.Function && fromExpression !== null && fromExpression !== void 0 && (_fromExpression$param2 = fromExpression.parameters) !== null && _fromExpression$param2 !== void 0 && _fromExpression$param2.length) {\n    var _fromExpression$param3;\n\n    if ((fromExpression === null || fromExpression === void 0 ? void 0 : (_fromExpression$param3 = fromExpression.parameters) === null || _fromExpression$param3 === void 0 ? void 0 : _fromExpression$param3.length) <= 1) {\n      return [];\n    } // ignore the first arg (the namespace)\n\n\n    const paramExpressions = fromExpression === null || fromExpression === void 0 ? void 0 : fromExpression.parameters.slice(1);\n    return paramExpressions.reduce((acc, curr) => curr.name ? [...acc, curr.name] : acc, []);\n  }\n\n  return undefined;\n}\nexport function isUsingWithSchema(fromExpression) {\n  return (fromExpression === null || fromExpression === void 0 ? void 0 : fromExpression.type) === QueryEditorExpressionType.Function && fromExpression.name === SCHEMA;\n}\n/** Given a partial operator expression, return a non-partial if it's valid, or undefined */\n\nexport function sanitizeOperator(expression) {\n  var _expression$property, _expression$operator, _expression$operator2;\n\n  const key = (_expression$property = expression.property) === null || _expression$property === void 0 ? void 0 : _expression$property.name;\n  const value = (_expression$operator = expression.operator) === null || _expression$operator === void 0 ? void 0 : _expression$operator.value;\n  const operator = (_expression$operator2 = expression.operator) === null || _expression$operator2 === void 0 ? void 0 : _expression$operator2.name;\n\n  if (key && value && operator) {\n    return {\n      type: QueryEditorExpressionType.Operator,\n      property: {\n        type: QueryEditorPropertyType.String,\n        name: key\n      },\n      operator: {\n        value,\n        name: operator\n      }\n    };\n  }\n\n  return undefined;\n}\n/**\n * Given an array of Expressions, flattens them to the leaf Operator expressions.\n * Note, this loses context of any nested ANDs or ORs, so will not be useful once we support nested conditions */\n\nfunction flattenOperatorExpressions(expressions) {\n  return expressions.flatMap(expression => {\n    if (expression.type === QueryEditorExpressionType.Operator) {\n      return expression;\n    }\n\n    if (expression.type === QueryEditorExpressionType.And || expression.type === QueryEditorExpressionType.Or) {\n      return flattenOperatorExpressions(expression.expressions);\n    } // Expressions that we don't expect to find in the WHERE filter will be ignored\n\n\n    return [];\n  });\n}\n/** Returns a flattened list of WHERE filters, losing all context of nested filters or AND vs OR. Not suitable\n * if the UI supports nested conditions\n */\n\n\nexport function getFlattenedFilters(sql) {\n  var _where$expressions;\n\n  const where = sql.where;\n  return flattenOperatorExpressions((_where$expressions = where === null || where === void 0 ? void 0 : where.expressions) !== null && _where$expressions !== void 0 ? _where$expressions : []);\n}\n/**\n * Given an array of Expressions, flattens them to the leaf Operator expressions.\n * Note, this loses context of any nested ANDs or ORs, so will not be useful once we support nested conditions */\n\nfunction flattenGroupByExpressions(expressions) {\n  return expressions.flatMap(expression => {\n    if (expression.type === QueryEditorExpressionType.GroupBy) {\n      return expression;\n    } // Expressions that we don't expect to find in the GROUP BY will be ignored\n\n\n    return [];\n  });\n}\n/** Returns a flattened list of GROUP BY expressions, losing all context of nested filters or AND vs OR.\n */\n\n\nexport function getFlattenedGroupBys(sql) {\n  var _groupBy$expressions;\n\n  const groupBy = sql.groupBy;\n  return flattenGroupByExpressions((_groupBy$expressions = groupBy === null || groupBy === void 0 ? void 0 : groupBy.expressions) !== null && _groupBy$expressions !== void 0 ? _groupBy$expressions : []);\n}\n/** Converts a string array to a Dimensions object with null values  **/\n\nexport function stringArrayToDimensions(arr) {\n  return arr.reduce((acc, curr) => {\n    if (curr) {\n      return Object.assign({}, acc, {\n        [curr]: null\n      });\n    }\n\n    return acc;\n  }, {});\n}\nexport function setSql(query, sql) {\n  var _query$sql;\n\n  return Object.assign({}, query, {\n    sql: Object.assign({}, (_query$sql = query.sql) !== null && _query$sql !== void 0 ? _query$sql : {}, sql)\n  });\n}\nexport function setNamespace(query, namespace) {\n  var _query$sql2;\n\n  const sql = (_query$sql2 = query.sql) !== null && _query$sql2 !== void 0 ? _query$sql2 : {}; //updating `namespace` props for CloudWatchMetricsQuery\n\n  query.namespace = namespace ? namespace : '';\n\n  if (namespace === undefined) {\n    return setSql(query, {\n      from: undefined\n    });\n  } // It's just a simple `FROM \"AWS/EC2\"` expression\n\n\n  if (!sql.from || sql.from.type === QueryEditorExpressionType.Property) {\n    return setSql(query, {\n      from: {\n        type: QueryEditorExpressionType.Property,\n        property: {\n          type: QueryEditorPropertyType.String,\n          name: namespace\n        }\n      }\n    });\n  } // It's a more complicated `FROM SCHEMA(\"AWS/EC2\", ...)` expression\n\n\n  if (sql.from.type === QueryEditorExpressionType.Function) {\n    var _sql$from$parameters;\n\n    const namespaceParam = {\n      type: QueryEditorExpressionType.FunctionParameter,\n      name: namespace\n    };\n    const labelKeys = ((_sql$from$parameters = sql.from.parameters) !== null && _sql$from$parameters !== void 0 ? _sql$from$parameters : []).slice(1);\n    return setSql(query, {\n      from: {\n        type: QueryEditorExpressionType.Function,\n        name: SCHEMA,\n        parameters: [namespaceParam, ...labelKeys]\n      }\n    });\n  } // TODO: do the with schema bit\n\n\n  return query;\n}\nexport function setSchemaLabels(query, schemaLabels) {\n  var _query$sql3, _sql$from, _sql$from$parameters2;\n\n  const sql = (_query$sql3 = query.sql) !== null && _query$sql3 !== void 0 ? _query$sql3 : {};\n  schemaLabels = Array.isArray(schemaLabels) ? schemaLabels.map(l => l.value) : [schemaLabels.value]; // schema labels are the second parameter in the schema function. `... FROM SCHEMA(\"AWS/EC2\", label1, label2 ...)`\n\n  if (((_sql$from = sql.from) === null || _sql$from === void 0 ? void 0 : _sql$from.type) === QueryEditorExpressionType.Function && (_sql$from$parameters2 = sql.from.parameters) !== null && _sql$from$parameters2 !== void 0 && _sql$from$parameters2.length) {\n    var _schemaLabels, _sql$from$parameters3;\n\n    const parameters = ((_schemaLabels = schemaLabels) !== null && _schemaLabels !== void 0 ? _schemaLabels : []).map(label => ({\n      type: QueryEditorExpressionType.FunctionParameter,\n      name: label\n    }));\n    const namespaceParam = ((_sql$from$parameters3 = sql.from.parameters) !== null && _sql$from$parameters3 !== void 0 ? _sql$from$parameters3 : [])[0];\n    return setSql(query, {\n      from: {\n        type: QueryEditorExpressionType.Function,\n        name: SCHEMA,\n        parameters: [namespaceParam, ...parameters]\n      }\n    });\n  }\n\n  return query;\n}\nexport function setMetricName(query, metricName) {\n  var _query$sql$select, _query$sql4;\n\n  const param = {\n    type: QueryEditorExpressionType.FunctionParameter,\n    name: metricName\n  };\n  return setSql(query, {\n    select: Object.assign({\n      type: QueryEditorExpressionType.Function\n    }, (_query$sql$select = (_query$sql4 = query.sql) === null || _query$sql4 === void 0 ? void 0 : _query$sql4.select) !== null && _query$sql$select !== void 0 ? _query$sql$select : {}, {\n      parameters: [param]\n    })\n  });\n}\nexport function removeMetricName(query) {\n  var _queryWithNoParams$sq, _queryWithNoParams$sq2;\n\n  const queryWithNoParams = Object.assign({}, query);\n  (_queryWithNoParams$sq = queryWithNoParams.sql) === null || _queryWithNoParams$sq === void 0 ? true : (_queryWithNoParams$sq2 = _queryWithNoParams$sq.select) === null || _queryWithNoParams$sq2 === void 0 ? true : delete _queryWithNoParams$sq2.parameters;\n  return queryWithNoParams;\n}\nexport function setAggregation(query, aggregation) {\n  var _query$sql$select2, _query$sql5;\n\n  return setSql(query, {\n    select: Object.assign({\n      type: QueryEditorExpressionType.Function\n    }, (_query$sql$select2 = (_query$sql5 = query.sql) === null || _query$sql5 === void 0 ? void 0 : _query$sql5.select) !== null && _query$sql$select2 !== void 0 ? _query$sql$select2 : {}, {\n      name: aggregation\n    })\n  });\n}\nexport function setOrderBy(query, aggregation) {\n  return setSql(query, {\n    orderBy: {\n      type: QueryEditorExpressionType.Function,\n      name: aggregation\n    }\n  });\n}\nexport function setWithSchema(query, withSchema) {\n  var _query$sql6;\n\n  const namespace = getNamespaceFromExpression(((_query$sql6 = query.sql) !== null && _query$sql6 !== void 0 ? _query$sql6 : {}).from);\n\n  if (withSchema) {\n    const namespaceParam = {\n      type: QueryEditorExpressionType.FunctionParameter,\n      name: namespace\n    };\n    return setSql(query, {\n      from: {\n        type: QueryEditorExpressionType.Function,\n        name: SCHEMA,\n        parameters: [namespaceParam]\n      }\n    });\n  }\n\n  return setSql(query, {\n    from: {\n      type: QueryEditorExpressionType.Property,\n      property: {\n        type: QueryEditorPropertyType.String,\n        name: namespace\n      }\n    }\n  });\n}\n/** Sets the left hand side (InstanceId) in an OperatorExpression\n * Accepts a partial expression to use in an editor\n */\n\nexport function setOperatorExpressionProperty(expression, property) {\n  var _expression$operator3;\n\n  return {\n    type: QueryEditorExpressionType.Operator,\n    property: {\n      type: QueryEditorPropertyType.String,\n      name: property\n    },\n    operator: (_expression$operator3 = expression.operator) !== null && _expression$operator3 !== void 0 ? _expression$operator3 : {}\n  };\n}\n/** Sets the operator (\"==\") in an OperatorExpression\n * Accepts a partial expression to use in an editor\n */\n\nexport function setOperatorExpressionName(expression, name) {\n  var _expression$property2;\n\n  return {\n    type: QueryEditorExpressionType.Operator,\n    property: (_expression$property2 = expression.property) !== null && _expression$property2 !== void 0 ? _expression$property2 : {\n      type: QueryEditorPropertyType.String\n    },\n    operator: Object.assign({}, expression.operator, {\n      name\n    })\n  };\n}\n/** Sets the right hand side (\"i-abc123445\") in an OperatorExpression\n * Accepts a partial expression to use in an editor\n */\n\nexport function setOperatorExpressionValue(expression, value) {\n  var _expression$property3;\n\n  return {\n    type: QueryEditorExpressionType.Operator,\n    property: (_expression$property3 = expression.property) !== null && _expression$property3 !== void 0 ? _expression$property3 : {\n      type: QueryEditorPropertyType.String\n    },\n    operator: Object.assign({}, expression.operator, {\n      value\n    })\n  };\n}\n/** Creates a GroupByExpression for a specified field\n */\n\nexport function setGroupByField(field) {\n  return {\n    type: QueryEditorExpressionType.GroupBy,\n    property: {\n      type: QueryEditorPropertyType.String,\n      name: field\n    }\n  };\n}","map":{"version":3,"names":["SCHEMA","QueryEditorExpressionType","QueryEditorPropertyType","getMetricNameFromExpression","selectExpression","parameters","name","getNamespaceFromExpression","fromExpression","type","Property","property","Function","undefined","getSchemaLabelKeys","length","paramExpressions","slice","reduce","acc","curr","isUsingWithSchema","sanitizeOperator","expression","key","value","operator","Operator","String","flattenOperatorExpressions","expressions","flatMap","And","Or","getFlattenedFilters","sql","where","flattenGroupByExpressions","GroupBy","getFlattenedGroupBys","groupBy","stringArrayToDimensions","arr","setSql","query","setNamespace","namespace","from","namespaceParam","FunctionParameter","labelKeys","setSchemaLabels","schemaLabels","Array","isArray","map","l","label","setMetricName","metricName","param","select","removeMetricName","queryWithNoParams","setAggregation","aggregation","setOrderBy","orderBy","setWithSchema","withSchema","setOperatorExpressionProperty","setOperatorExpressionName","setOperatorExpressionValue","setGroupByField","field"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/components/SQLBuilderEditor/utils.ts"],"sourcesContent":["import { SCHEMA } from '../../cloudwatch-sql/language';\nimport {\n  QueryEditorExpressionType,\n  QueryEditorPropertyType,\n  QueryEditorFunctionParameterExpression,\n  QueryEditorArrayExpression,\n  QueryEditorOperatorExpression,\n  QueryEditorGroupByExpression,\n} from '../../expressions';\nimport { SQLExpression, CloudWatchMetricsQuery, Dimensions } from '../../types';\n\nimport { SelectableValue } from './../../../../../../../packages/grafana-data/src/types/select';\n\nexport function getMetricNameFromExpression(selectExpression: SQLExpression['select']): string | undefined {\n  return selectExpression?.parameters?.[0].name;\n}\n\nexport function getNamespaceFromExpression(fromExpression: SQLExpression['from']): string | undefined {\n  // It's just a simple `FROM \"AWS/EC2\"` expression\n  if (fromExpression?.type === QueryEditorExpressionType.Property) {\n    return fromExpression.property.name; // PR TODO: do we need to test the type here? It can only be string?\n  }\n\n  // It's a more complicated `FROM SCHEMA(\"AWS/EC2\", ...)` expression\n  if (fromExpression?.type === QueryEditorExpressionType.Function) {\n    // TODO: do we need to test the name of the function?\n    return fromExpression.parameters?.[0].name;\n  }\n\n  return undefined;\n}\n\nexport function getSchemaLabelKeys(fromExpression: SQLExpression['from']): string[] | undefined {\n  // Schema label keys are second to n arguments in the from expression function\n  if (fromExpression?.type === QueryEditorExpressionType.Function && fromExpression?.parameters?.length) {\n    if (fromExpression?.parameters?.length <= 1) {\n      return [];\n    }\n\n    // ignore the first arg (the namespace)\n    const paramExpressions = fromExpression?.parameters.slice(1);\n    return paramExpressions.reduce<string[]>((acc, curr) => (curr.name ? [...acc, curr.name] : acc), []);\n  }\n\n  return undefined;\n}\n\nexport function isUsingWithSchema(fromExpression: SQLExpression['from']): boolean {\n  return fromExpression?.type === QueryEditorExpressionType.Function && fromExpression.name === SCHEMA;\n}\n\n/** Given a partial operator expression, return a non-partial if it's valid, or undefined */\nexport function sanitizeOperator(\n  expression: Partial<QueryEditorOperatorExpression>\n): QueryEditorOperatorExpression | undefined {\n  const key = expression.property?.name;\n  const value = expression.operator?.value;\n  const operator = expression.operator?.name;\n\n  if (key && value && operator) {\n    return {\n      type: QueryEditorExpressionType.Operator,\n      property: {\n        type: QueryEditorPropertyType.String,\n        name: key,\n      },\n      operator: {\n        value,\n        name: operator,\n      },\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Given an array of Expressions, flattens them to the leaf Operator expressions.\n * Note, this loses context of any nested ANDs or ORs, so will not be useful once we support nested conditions */\nfunction flattenOperatorExpressions(\n  expressions: QueryEditorArrayExpression['expressions']\n): QueryEditorOperatorExpression[] {\n  return expressions.flatMap((expression) => {\n    if (expression.type === QueryEditorExpressionType.Operator) {\n      return expression;\n    }\n\n    if (expression.type === QueryEditorExpressionType.And || expression.type === QueryEditorExpressionType.Or) {\n      return flattenOperatorExpressions(expression.expressions);\n    }\n\n    // Expressions that we don't expect to find in the WHERE filter will be ignored\n    return [];\n  });\n}\n\n/** Returns a flattened list of WHERE filters, losing all context of nested filters or AND vs OR. Not suitable\n * if the UI supports nested conditions\n */\nexport function getFlattenedFilters(sql: SQLExpression): QueryEditorOperatorExpression[] {\n  const where = sql.where;\n  return flattenOperatorExpressions(where?.expressions ?? []);\n}\n\n/**\n * Given an array of Expressions, flattens them to the leaf Operator expressions.\n * Note, this loses context of any nested ANDs or ORs, so will not be useful once we support nested conditions */\nfunction flattenGroupByExpressions(\n  expressions: QueryEditorArrayExpression['expressions']\n): QueryEditorGroupByExpression[] {\n  return expressions.flatMap((expression) => {\n    if (expression.type === QueryEditorExpressionType.GroupBy) {\n      return expression;\n    }\n\n    // Expressions that we don't expect to find in the GROUP BY will be ignored\n    return [];\n  });\n}\n\n/** Returns a flattened list of GROUP BY expressions, losing all context of nested filters or AND vs OR.\n */\nexport function getFlattenedGroupBys(sql: SQLExpression): QueryEditorGroupByExpression[] {\n  const groupBy = sql.groupBy;\n  return flattenGroupByExpressions(groupBy?.expressions ?? []);\n}\n\n/** Converts a string array to a Dimensions object with null values  **/\nexport function stringArrayToDimensions(arr: string[]): Dimensions {\n  return arr.reduce((acc, curr) => {\n    if (curr) {\n      return { ...acc, [curr]: null };\n    }\n    return acc;\n  }, {});\n}\n\nexport function setSql(query: CloudWatchMetricsQuery, sql: SQLExpression): CloudWatchMetricsQuery {\n  return {\n    ...query,\n    sql: {\n      ...(query.sql ?? {}),\n      ...sql,\n    },\n  };\n}\n\nexport function setNamespace(query: CloudWatchMetricsQuery, namespace: string | undefined): CloudWatchMetricsQuery {\n  const sql = query.sql ?? {};\n  //updating `namespace` props for CloudWatchMetricsQuery\n  query.namespace = namespace ? namespace : '';\n\n  if (namespace === undefined) {\n    return setSql(query, {\n      from: undefined,\n    });\n  }\n\n  // It's just a simple `FROM \"AWS/EC2\"` expression\n  if (!sql.from || sql.from.type === QueryEditorExpressionType.Property) {\n    return setSql(query, {\n      from: {\n        type: QueryEditorExpressionType.Property,\n        property: {\n          type: QueryEditorPropertyType.String,\n          name: namespace,\n        },\n      },\n    });\n  }\n\n  // It's a more complicated `FROM SCHEMA(\"AWS/EC2\", ...)` expression\n  if (sql.from.type === QueryEditorExpressionType.Function) {\n    const namespaceParam: QueryEditorFunctionParameterExpression = {\n      type: QueryEditorExpressionType.FunctionParameter,\n      name: namespace,\n    };\n\n    const labelKeys = (sql.from.parameters ?? []).slice(1);\n\n    return setSql(query, {\n      from: {\n        type: QueryEditorExpressionType.Function,\n        name: SCHEMA,\n        parameters: [namespaceParam, ...labelKeys],\n      },\n    });\n  }\n\n  // TODO: do the with schema bit\n  return query;\n}\n\nexport function setSchemaLabels(\n  query: CloudWatchMetricsQuery,\n  schemaLabels: Array<SelectableValue<string>> | SelectableValue<string>\n): CloudWatchMetricsQuery {\n  const sql = query.sql ?? {};\n  schemaLabels = Array.isArray(schemaLabels) ? schemaLabels.map((l) => l.value) : [schemaLabels.value];\n\n  // schema labels are the second parameter in the schema function. `... FROM SCHEMA(\"AWS/EC2\", label1, label2 ...)`\n  if (sql.from?.type === QueryEditorExpressionType.Function && sql.from.parameters?.length) {\n    const parameters: QueryEditorFunctionParameterExpression[] = (schemaLabels ?? []).map((label: string) => ({\n      type: QueryEditorExpressionType.FunctionParameter,\n      name: label,\n    }));\n    const namespaceParam = (sql.from.parameters ?? [])[0];\n\n    return setSql(query, {\n      from: {\n        type: QueryEditorExpressionType.Function,\n        name: SCHEMA,\n        parameters: [namespaceParam, ...parameters],\n      },\n    });\n  }\n\n  return query;\n}\n\nexport function setMetricName(query: CloudWatchMetricsQuery, metricName: string): CloudWatchMetricsQuery {\n  const param: QueryEditorFunctionParameterExpression = {\n    type: QueryEditorExpressionType.FunctionParameter,\n    name: metricName,\n  };\n\n  return setSql(query, {\n    select: {\n      type: QueryEditorExpressionType.Function,\n      ...(query.sql?.select ?? {}),\n      parameters: [param],\n    },\n  });\n}\n\nexport function removeMetricName(query: CloudWatchMetricsQuery): CloudWatchMetricsQuery {\n  const queryWithNoParams = { ...query };\n  delete queryWithNoParams.sql?.select?.parameters;\n\n  return queryWithNoParams;\n}\n\nexport function setAggregation(query: CloudWatchMetricsQuery, aggregation: string): CloudWatchMetricsQuery {\n  return setSql(query, {\n    select: {\n      type: QueryEditorExpressionType.Function,\n      ...(query.sql?.select ?? {}),\n      name: aggregation,\n    },\n  });\n}\n\nexport function setOrderBy(query: CloudWatchMetricsQuery, aggregation: string): CloudWatchMetricsQuery {\n  return setSql(query, {\n    orderBy: {\n      type: QueryEditorExpressionType.Function,\n      name: aggregation,\n    },\n  });\n}\n\nexport function setWithSchema(query: CloudWatchMetricsQuery, withSchema: boolean): CloudWatchMetricsQuery {\n  const namespace = getNamespaceFromExpression((query.sql ?? {}).from);\n\n  if (withSchema) {\n    const namespaceParam: QueryEditorFunctionParameterExpression = {\n      type: QueryEditorExpressionType.FunctionParameter,\n      name: namespace,\n    };\n\n    return setSql(query, {\n      from: {\n        type: QueryEditorExpressionType.Function,\n        name: SCHEMA,\n        parameters: [namespaceParam],\n      },\n    });\n  }\n\n  return setSql(query, {\n    from: {\n      type: QueryEditorExpressionType.Property,\n      property: {\n        type: QueryEditorPropertyType.String,\n        name: namespace,\n      },\n    },\n  });\n}\n\n/** Sets the left hand side (InstanceId) in an OperatorExpression\n * Accepts a partial expression to use in an editor\n */\nexport function setOperatorExpressionProperty(\n  expression: Partial<QueryEditorOperatorExpression>,\n  property: string\n): QueryEditorOperatorExpression {\n  return {\n    type: QueryEditorExpressionType.Operator,\n    property: {\n      type: QueryEditorPropertyType.String,\n      name: property,\n    },\n    operator: expression.operator ?? {},\n  };\n}\n\n/** Sets the operator (\"==\") in an OperatorExpression\n * Accepts a partial expression to use in an editor\n */\nexport function setOperatorExpressionName(\n  expression: Partial<QueryEditorOperatorExpression>,\n  name: string\n): QueryEditorOperatorExpression {\n  return {\n    type: QueryEditorExpressionType.Operator,\n    property: expression.property ?? {\n      type: QueryEditorPropertyType.String,\n    },\n    operator: {\n      ...expression.operator,\n      name,\n    },\n  };\n}\n\n/** Sets the right hand side (\"i-abc123445\") in an OperatorExpression\n * Accepts a partial expression to use in an editor\n */\nexport function setOperatorExpressionValue(\n  expression: Partial<QueryEditorOperatorExpression>,\n  value: string\n): QueryEditorOperatorExpression {\n  return {\n    type: QueryEditorExpressionType.Operator,\n    property: expression.property ?? {\n      type: QueryEditorPropertyType.String,\n    },\n    operator: {\n      ...expression.operator,\n      value,\n    },\n  };\n}\n\n/** Creates a GroupByExpression for a specified field\n */\nexport function setGroupByField(field: string): QueryEditorGroupByExpression {\n  return {\n    type: QueryEditorExpressionType.GroupBy,\n    property: {\n      type: QueryEditorPropertyType.String,\n      name: field,\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}