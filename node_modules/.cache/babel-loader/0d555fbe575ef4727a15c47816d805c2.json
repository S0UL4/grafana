{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { ArrayVector, DataTransformerID, getFieldDisplayName } from '@grafana/data';\nimport { getFieldConfigFromFrame, evaluteFieldMappings, FieldConfigHandlerKey } from '../fieldToConfigMapping/fieldToConfigMapping';\nexport const rowsToFieldsTransformer = {\n  id: DataTransformerID.rowsToFields,\n  name: 'Rows to fields',\n  description: 'Convert each row into a field with dynamic config',\n  defaultOptions: {},\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: options => source => source.pipe(map(data => {\n    return data.map(frame => rowsToFields(options, frame));\n  }))\n};\nexport function rowsToFields(options, data) {\n  var _options$mappings;\n\n  const mappingResult = evaluteFieldMappings(data, (_options$mappings = options.mappings) !== null && _options$mappings !== void 0 ? _options$mappings : [], true);\n  const {\n    nameField,\n    valueField\n  } = mappingResult;\n\n  if (!nameField || !valueField) {\n    return data;\n  }\n\n  const outFields = [];\n\n  for (let index = 0; index < nameField.values.length; index++) {\n    const name = nameField.values.get(index);\n    const value = valueField.values.get(index);\n    const config = getFieldConfigFromFrame(data, index, mappingResult);\n    const labels = getLabelsFromRow(data, index, mappingResult);\n    const field = {\n      name: `${name}`,\n      type: valueField.type,\n      values: new ArrayVector([value]),\n      config: config,\n      labels\n    };\n    outFields.push(field);\n  }\n\n  return {\n    fields: outFields,\n    length: 1\n  };\n}\n\nfunction getLabelsFromRow(frame, index, mappingResult) {\n  const labels = Object.assign({}, mappingResult.nameField.labels);\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n    const fieldName = getFieldDisplayName(field, frame);\n    const fieldMapping = mappingResult.index[fieldName];\n\n    if (fieldMapping.handler && fieldMapping.handler.key !== FieldConfigHandlerKey.Label) {\n      continue;\n    }\n\n    const value = field.values.get(index);\n\n    if (value != null) {\n      labels[fieldName] = value;\n    }\n  }\n\n  return labels;\n}","map":{"version":3,"names":["map","ArrayVector","DataTransformerID","getFieldDisplayName","getFieldConfigFromFrame","evaluteFieldMappings","FieldConfigHandlerKey","rowsToFieldsTransformer","id","rowsToFields","name","description","defaultOptions","operator","options","source","pipe","data","frame","mappingResult","mappings","nameField","valueField","outFields","index","values","length","get","value","config","labels","getLabelsFromRow","field","type","push","fields","i","fieldName","fieldMapping","handler","key","Label"],"sources":["/home/soula/grafana/public/app/features/transformers/rowsToFields/rowsToFields.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport {\n  ArrayVector,\n  DataFrame,\n  DataTransformerID,\n  DataTransformerInfo,\n  Field,\n  getFieldDisplayName,\n  Labels,\n} from '@grafana/data';\n\nimport {\n  getFieldConfigFromFrame,\n  FieldToConfigMapping,\n  evaluteFieldMappings,\n  EvaluatedMappingResult,\n  FieldConfigHandlerKey,\n} from '../fieldToConfigMapping/fieldToConfigMapping';\n\nexport interface RowToFieldsTransformOptions {\n  nameField?: string;\n  valueField?: string;\n  mappings?: FieldToConfigMapping[];\n}\n\nexport const rowsToFieldsTransformer: DataTransformerInfo<RowToFieldsTransformOptions> = {\n  id: DataTransformerID.rowsToFields,\n  name: 'Rows to fields',\n  description: 'Convert each row into a field with dynamic config',\n  defaultOptions: {},\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        return data.map((frame) => rowsToFields(options, frame));\n      })\n    ),\n};\n\nexport function rowsToFields(options: RowToFieldsTransformOptions, data: DataFrame): DataFrame {\n  const mappingResult = evaluteFieldMappings(data, options.mappings ?? [], true);\n  const { nameField, valueField } = mappingResult;\n\n  if (!nameField || !valueField) {\n    return data;\n  }\n\n  const outFields: Field[] = [];\n\n  for (let index = 0; index < nameField.values.length; index++) {\n    const name = nameField.values.get(index);\n    const value = valueField.values.get(index);\n    const config = getFieldConfigFromFrame(data, index, mappingResult);\n    const labels = getLabelsFromRow(data, index, mappingResult);\n\n    const field: Field = {\n      name: `${name}`,\n      type: valueField.type,\n      values: new ArrayVector([value]),\n      config: config,\n      labels,\n    };\n\n    outFields.push(field);\n  }\n\n  return {\n    fields: outFields,\n    length: 1,\n  };\n}\n\nfunction getLabelsFromRow(frame: DataFrame, index: number, mappingResult: EvaluatedMappingResult): Labels {\n  const labels = { ...mappingResult.nameField!.labels };\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n    const fieldName = getFieldDisplayName(field, frame);\n    const fieldMapping = mappingResult.index[fieldName];\n\n    if (fieldMapping.handler && fieldMapping.handler.key !== FieldConfigHandlerKey.Label) {\n      continue;\n    }\n\n    const value = field.values.get(index);\n    if (value != null) {\n      labels[fieldName] = value;\n    }\n  }\n\n  return labels;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}