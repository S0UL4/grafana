{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { debounce } from 'lodash';\nimport React, { PureComponent } from 'react';\nimport { AppEvents } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { AsyncSelect } from '@grafana/ui';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { createFolder, getFolderById, searchFolders } from 'app/features/manage-dashboards/state/actions';\nimport { AccessControlAction, PermissionLevelString } from '../../../types';\nimport appEvents from '../../app_events';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport class FolderPicker extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"debouncedSearch\", void 0);\n\n    _defineProperty(this, \"componentDidMount\", async () => {\n      if (this.props.skipInitialLoad) {\n        const folder = await getInitialValues({\n          getFolder: getFolderById,\n          folderId: this.props.initialFolderId,\n          folderName: this.props.initialTitle\n        });\n        this.setState({\n          folder\n        });\n        return;\n      }\n\n      await this.loadInitialValue();\n    });\n\n    _defineProperty(this, \"loadOptions\", (query, callback) => {\n      this.searchFolders(query).then(callback);\n    });\n\n    _defineProperty(this, \"searchFolders\", async query => {\n      const {\n        rootName,\n        enableReset,\n        initialTitle,\n        permissionLevel,\n        filter,\n        accessControlMetadata,\n        initialFolderId,\n        showRoot\n      } = this.props;\n      const searchHits = await searchFolders(query, permissionLevel, accessControlMetadata);\n      const options = mapSearchHitsToOptions(searchHits, filter);\n      const hasAccess = contextSrv.hasAccess(AccessControlAction.DashboardsWrite, contextSrv.isEditor) || contextSrv.hasAccess(AccessControlAction.DashboardsCreate, contextSrv.isEditor);\n\n      if (hasAccess && rootName !== null && rootName !== void 0 && rootName.toLowerCase().startsWith(query.toLowerCase()) && showRoot) {\n        options.unshift({\n          label: rootName,\n          value: 0\n        });\n      }\n\n      if (enableReset && query === '' && initialTitle !== '' && !options.find(option => option.label === initialTitle)) {\n        options.unshift({\n          label: initialTitle,\n          value: initialFolderId\n        });\n      }\n\n      return options;\n    });\n\n    _defineProperty(this, \"onFolderChange\", (newFolder, actionMeta) => {\n      if (!newFolder) {\n        newFolder = {\n          value: 0,\n          label: this.props.rootName\n        };\n      }\n\n      if (actionMeta.action === 'clear' && this.props.onClear) {\n        this.props.onClear();\n        return;\n      }\n\n      this.setState({\n        folder: newFolder\n      }, () => this.props.onChange({\n        id: newFolder.value,\n        title: newFolder.label\n      }));\n    });\n\n    _defineProperty(this, \"createNewFolder\", async folderName => {\n      const newFolder = await createFolder({\n        title: folderName\n      });\n      let folder = {\n        value: -1,\n        label: 'Not created'\n      };\n\n      if (newFolder.id > -1) {\n        appEvents.emit(AppEvents.alertSuccess, ['Folder Created', 'OK']);\n        folder = {\n          value: newFolder.id,\n          label: newFolder.title\n        };\n        this.setState({\n          folder: newFolder\n        }, () => {\n          this.onFolderChange(folder, {\n            action: 'create-option',\n            option: folder\n          });\n        });\n      } else {\n        appEvents.emit(AppEvents.alertError, ['Folder could not be created']);\n      }\n\n      return folder;\n    });\n\n    _defineProperty(this, \"loadInitialValue\", async () => {\n      const {\n        initialTitle,\n        rootName,\n        initialFolderId,\n        enableReset,\n        dashboardId\n      } = this.props;\n      const resetFolder = {\n        label: initialTitle,\n        value: undefined\n      };\n      const rootFolder = {\n        label: rootName,\n        value: 0\n      };\n      const options = await this.searchFolders('');\n      let folder = null;\n\n      if (initialFolderId !== undefined && initialFolderId !== null && initialFolderId > -1) {\n        folder = options.find(option => option.value === initialFolderId) || null;\n      } else if (enableReset && initialTitle) {\n        folder = resetFolder;\n      } else if (initialFolderId) {\n        folder = options.find(option => option.id === initialFolderId) || null;\n      }\n\n      if (!folder && !this.props.allowEmpty) {\n        if (contextSrv.isEditor) {\n          folder = rootFolder;\n        } else {\n          // We shouldn't assign a random folder without the user actively choosing it on a persisted dashboard\n          const isPersistedDashBoard = !!dashboardId;\n\n          if (isPersistedDashBoard) {\n            folder = resetFolder;\n          } else {\n            folder = options.length > 0 ? options[0] : resetFolder;\n          }\n        }\n      }\n\n      this.setState({\n        folder\n      }, () => {\n        // if this is not the same as our initial value notify parent\n        if (folder && folder.value !== initialFolderId) {\n          this.props.onChange({\n            id: folder.value,\n            title: folder.label\n          });\n        }\n      });\n    });\n\n    this.state = {\n      folder: null\n    };\n    this.debouncedSearch = debounce(this.loadOptions, 300, {\n      leading: true,\n      trailing: true\n    });\n  }\n\n  render() {\n    const {\n      folder\n    } = this.state;\n    const {\n      enableCreateNew,\n      inputId,\n      onClear\n    } = this.props;\n    const isClearable = typeof onClear === 'function';\n    return /*#__PURE__*/_jsx(\"div\", {\n      \"data-testid\": selectors.components.FolderPicker.containerV2,\n      children: /*#__PURE__*/_jsx(AsyncSelect, {\n        inputId: inputId,\n        \"aria-label\": selectors.components.FolderPicker.input,\n        loadingMessage: \"Loading folders...\",\n        defaultOptions: true,\n        defaultValue: folder,\n        value: folder,\n        allowCustomValue: enableCreateNew,\n        loadOptions: this.debouncedSearch,\n        onChange: this.onFolderChange,\n        onCreateOption: this.createNewFolder,\n        isClearable: isClearable\n      })\n    });\n  }\n\n}\n\n_defineProperty(FolderPicker, \"defaultProps\", {\n  rootName: 'General',\n  enableReset: false,\n  initialTitle: '',\n  enableCreateNew: false,\n  permissionLevel: PermissionLevelString.Edit,\n  allowEmpty: false,\n  showRoot: true\n});\n\nfunction mapSearchHitsToOptions(hits, filter) {\n  const filteredHits = filter ? filter(hits) : hits;\n  return filteredHits.map(hit => ({\n    label: hit.title,\n    value: hit.id\n  }));\n}\n\nexport async function getInitialValues({\n  folderName,\n  folderId,\n  getFolder\n}) {\n  if (folderId === null || folderId === undefined || folderId < 0) {\n    throw new Error('folderId should to be greater or equal to zero.');\n  }\n\n  if (folderName) {\n    return {\n      label: folderName,\n      value: folderId\n    };\n  }\n\n  const folderDto = await getFolder(folderId);\n  return {\n    label: folderDto.title,\n    value: folderId\n  };\n}","map":{"version":3,"names":["debounce","React","PureComponent","AppEvents","selectors","AsyncSelect","contextSrv","createFolder","getFolderById","searchFolders","AccessControlAction","PermissionLevelString","appEvents","FolderPicker","constructor","props","skipInitialLoad","folder","getInitialValues","getFolder","folderId","initialFolderId","folderName","initialTitle","setState","loadInitialValue","query","callback","then","rootName","enableReset","permissionLevel","filter","accessControlMetadata","showRoot","searchHits","options","mapSearchHitsToOptions","hasAccess","DashboardsWrite","isEditor","DashboardsCreate","toLowerCase","startsWith","unshift","label","value","find","option","newFolder","actionMeta","action","onClear","onChange","id","title","emit","alertSuccess","onFolderChange","alertError","dashboardId","resetFolder","undefined","rootFolder","allowEmpty","isPersistedDashBoard","length","state","debouncedSearch","loadOptions","leading","trailing","render","enableCreateNew","inputId","isClearable","components","containerV2","input","createNewFolder","Edit","hits","filteredHits","map","hit","Error","folderDto"],"sources":["/home/soula/grafana/public/app/core/components/Select/FolderPicker.tsx"],"sourcesContent":["import { debounce } from 'lodash';\nimport React, { PureComponent } from 'react';\n\nimport { AppEvents, SelectableValue } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { ActionMeta, AsyncSelect, LoadOptionsCallback } from '@grafana/ui';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { createFolder, getFolderById, searchFolders } from 'app/features/manage-dashboards/state/actions';\nimport { DashboardSearchHit } from 'app/features/search/types';\n\nimport { AccessControlAction, PermissionLevelString } from '../../../types';\nimport appEvents from '../../app_events';\n\nexport type FolderPickerFilter = (hits: DashboardSearchHit[]) => DashboardSearchHit[];\n\nexport interface Props {\n  onChange: ($folder: { title: string; id: number }) => void;\n  enableCreateNew?: boolean;\n  rootName?: string;\n  enableReset?: boolean;\n  dashboardId?: any;\n  initialTitle?: string;\n  initialFolderId?: number;\n  permissionLevel?: Exclude<PermissionLevelString, PermissionLevelString.Admin>;\n  filter?: FolderPickerFilter;\n  allowEmpty?: boolean;\n  showRoot?: boolean;\n  onClear?: () => void;\n  accessControlMetadata?: boolean;\n  /**\n   * Skips loading all folders in order to find the folder matching\n   * the folder where the dashboard is stored.\n   * Instead initialFolderId and initialTitle will be used to display the correct folder.\n   * initialFolderId needs to have an value > -1 or an error will be thrown.\n   */\n  skipInitialLoad?: boolean;\n  /** The id of the search input. Use this to set a matching label with htmlFor */\n  inputId?: string;\n}\n\ninterface State {\n  folder: SelectableValue<number> | null;\n}\n\nexport class FolderPicker extends PureComponent<Props, State> {\n  debouncedSearch: any;\n\n  constructor(props: Props) {\n    super(props);\n\n    this.state = {\n      folder: null,\n    };\n\n    this.debouncedSearch = debounce(this.loadOptions, 300, {\n      leading: true,\n      trailing: true,\n    });\n  }\n\n  static defaultProps: Partial<Props> = {\n    rootName: 'General',\n    enableReset: false,\n    initialTitle: '',\n    enableCreateNew: false,\n    permissionLevel: PermissionLevelString.Edit,\n    allowEmpty: false,\n    showRoot: true,\n  };\n\n  componentDidMount = async () => {\n    if (this.props.skipInitialLoad) {\n      const folder = await getInitialValues({\n        getFolder: getFolderById,\n        folderId: this.props.initialFolderId,\n        folderName: this.props.initialTitle,\n      });\n      this.setState({ folder });\n      return;\n    }\n\n    await this.loadInitialValue();\n  };\n\n  // when debouncing, we must use the callback form of react-select's loadOptions so we don't\n  // drop results for user input. This must not return a promise/use await.\n  loadOptions = (query: string, callback: LoadOptionsCallback<number>): void => {\n    this.searchFolders(query).then(callback);\n  };\n\n  private searchFolders = async (query: string) => {\n    const {\n      rootName,\n      enableReset,\n      initialTitle,\n      permissionLevel,\n      filter,\n      accessControlMetadata,\n      initialFolderId,\n      showRoot,\n    } = this.props;\n\n    const searchHits = await searchFolders(query, permissionLevel, accessControlMetadata);\n    const options: Array<SelectableValue<number>> = mapSearchHitsToOptions(searchHits, filter);\n\n    const hasAccess =\n      contextSrv.hasAccess(AccessControlAction.DashboardsWrite, contextSrv.isEditor) ||\n      contextSrv.hasAccess(AccessControlAction.DashboardsCreate, contextSrv.isEditor);\n\n    if (hasAccess && rootName?.toLowerCase().startsWith(query.toLowerCase()) && showRoot) {\n      options.unshift({ label: rootName, value: 0 });\n    }\n\n    if (\n      enableReset &&\n      query === '' &&\n      initialTitle !== '' &&\n      !options.find((option) => option.label === initialTitle)\n    ) {\n      options.unshift({ label: initialTitle, value: initialFolderId });\n    }\n\n    return options;\n  };\n\n  onFolderChange = (newFolder: SelectableValue<number>, actionMeta: ActionMeta) => {\n    if (!newFolder) {\n      newFolder = { value: 0, label: this.props.rootName };\n    }\n\n    if (actionMeta.action === 'clear' && this.props.onClear) {\n      this.props.onClear();\n      return;\n    }\n\n    this.setState(\n      {\n        folder: newFolder,\n      },\n      () => this.props.onChange({ id: newFolder.value!, title: newFolder.label! })\n    );\n  };\n\n  createNewFolder = async (folderName: string) => {\n    const newFolder = await createFolder({ title: folderName });\n    let folder: SelectableValue<number> = { value: -1, label: 'Not created' };\n\n    if (newFolder.id > -1) {\n      appEvents.emit(AppEvents.alertSuccess, ['Folder Created', 'OK']);\n      folder = { value: newFolder.id, label: newFolder.title };\n\n      this.setState(\n        {\n          folder: newFolder,\n        },\n        () => {\n          this.onFolderChange(folder, { action: 'create-option', option: folder });\n        }\n      );\n    } else {\n      appEvents.emit(AppEvents.alertError, ['Folder could not be created']);\n    }\n\n    return folder;\n  };\n\n  private loadInitialValue = async () => {\n    const { initialTitle, rootName, initialFolderId, enableReset, dashboardId } = this.props;\n    const resetFolder: SelectableValue<number> = { label: initialTitle, value: undefined };\n    const rootFolder: SelectableValue<number> = { label: rootName, value: 0 };\n\n    const options = await this.searchFolders('');\n\n    let folder: SelectableValue<number> | null = null;\n\n    if (initialFolderId !== undefined && initialFolderId !== null && initialFolderId > -1) {\n      folder = options.find((option) => option.value === initialFolderId) || null;\n    } else if (enableReset && initialTitle) {\n      folder = resetFolder;\n    } else if (initialFolderId) {\n      folder = options.find((option) => option.id === initialFolderId) || null;\n    }\n\n    if (!folder && !this.props.allowEmpty) {\n      if (contextSrv.isEditor) {\n        folder = rootFolder;\n      } else {\n        // We shouldn't assign a random folder without the user actively choosing it on a persisted dashboard\n        const isPersistedDashBoard = !!dashboardId;\n        if (isPersistedDashBoard) {\n          folder = resetFolder;\n        } else {\n          folder = options.length > 0 ? options[0] : resetFolder;\n        }\n      }\n    }\n\n    this.setState(\n      {\n        folder,\n      },\n      () => {\n        // if this is not the same as our initial value notify parent\n        if (folder && folder.value !== initialFolderId) {\n          this.props.onChange({ id: folder.value!, title: folder.label! });\n        }\n      }\n    );\n  };\n\n  render() {\n    const { folder } = this.state;\n    const { enableCreateNew, inputId, onClear } = this.props;\n    const isClearable = typeof onClear === 'function';\n\n    return (\n      <div data-testid={selectors.components.FolderPicker.containerV2}>\n        <AsyncSelect\n          inputId={inputId}\n          aria-label={selectors.components.FolderPicker.input}\n          loadingMessage=\"Loading folders...\"\n          defaultOptions\n          defaultValue={folder}\n          value={folder}\n          allowCustomValue={enableCreateNew}\n          loadOptions={this.debouncedSearch}\n          onChange={this.onFolderChange}\n          onCreateOption={this.createNewFolder}\n          isClearable={isClearable}\n        />\n      </div>\n    );\n  }\n}\n\nfunction mapSearchHitsToOptions(hits: DashboardSearchHit[], filter?: FolderPickerFilter) {\n  const filteredHits = filter ? filter(hits) : hits;\n  return filteredHits.map((hit) => ({ label: hit.title, value: hit.id }));\n}\n\ninterface Args {\n  getFolder: typeof getFolderById;\n  folderId?: number;\n  folderName?: string;\n}\n\nexport async function getInitialValues({ folderName, folderId, getFolder }: Args): Promise<SelectableValue<number>> {\n  if (folderId === null || folderId === undefined || folderId < 0) {\n    throw new Error('folderId should to be greater or equal to zero.');\n  }\n\n  if (folderName) {\n    return { label: folderName, value: folderId };\n  }\n\n  const folderDto = await getFolder(folderId);\n  return { label: folderDto.title, value: folderId };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}