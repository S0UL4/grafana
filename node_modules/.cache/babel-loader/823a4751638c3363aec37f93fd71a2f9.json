{"ast":null,"code":"import { isNumber, set, unset, get, cloneDeep } from 'lodash';\nimport { guessFieldTypeForField } from '../dataframe';\nimport { getTimeField } from '../dataframe/processDataFrame';\nimport { asHexString } from '../themes/colorManipulator';\nimport { fieldMatchers, reduceField, ReducerID } from '../transformations';\nimport { FieldColorModeId, FieldType } from '../types';\nimport { DataLinkBuiltInVars, locationUtil } from '../utils';\nimport { mapInternalLinkToExplore } from '../utils/dataLinks';\nimport { formattedValueToString } from '../valueFormats';\nimport { getDisplayProcessor, getRawDisplayProcessor } from './displayProcessor';\nimport { getFrameDisplayName } from './fieldState';\nimport { getFieldDisplayValuesProxy } from './getFieldDisplayValuesProxy';\nimport { standardFieldConfigEditorRegistry } from './standardFieldConfigEditorRegistry';\nimport { getTemplateProxyForField } from './templateProxies';\nexport function findNumericFieldMinMax(data) {\n  var _max, _min;\n\n  let min = null;\n  let max = null;\n  const reducers = [ReducerID.min, ReducerID.max];\n\n  for (const frame of data) {\n    for (const field of frame.fields) {\n      if (field.type === FieldType.number) {\n        const stats = reduceField({\n          field,\n          reducers\n        });\n        const statsMin = stats[ReducerID.min];\n        const statsMax = stats[ReducerID.max];\n\n        if (min === null || statsMin < min) {\n          min = statsMin;\n        }\n\n        if (max === null || statsMax > max) {\n          max = statsMax;\n        }\n      }\n    }\n  }\n\n  return {\n    min,\n    max,\n    delta: ((_max = max) !== null && _max !== void 0 ? _max : 0) - ((_min = min) !== null && _min !== void 0 ? _min : 0)\n  };\n}\n/**\n * Return a copy of the DataFrame with all rules applied\n */\n\nexport function applyFieldOverrides(options) {\n  var _options$fieldConfigR;\n\n  if (!options.data) {\n    return [];\n  }\n\n  const source = options.fieldConfig;\n\n  if (!source) {\n    return options.data;\n  }\n\n  const fieldConfigRegistry = (_options$fieldConfigR = options.fieldConfigRegistry) !== null && _options$fieldConfigR !== void 0 ? _options$fieldConfigR : standardFieldConfigEditorRegistry;\n  let seriesIndex = 0;\n  let globalRange = undefined; // Prepare the Matchers\n\n  const override = [];\n\n  if (source.overrides) {\n    for (const rule of source.overrides) {\n      const info = fieldMatchers.get(rule.matcher.id);\n\n      if (info) {\n        override.push({\n          match: info.get(rule.matcher.options),\n          properties: rule.properties\n        });\n      }\n    }\n  }\n\n  return options.data.map((originalFrame, index) => {\n    // Need to define this new frame here as it's passed to the getLinkSupplier function inside the fields loop\n    const newFrame = Object.assign({}, originalFrame); // Copy fields\n\n    newFrame.fields = newFrame.fields.map(field => {\n      return Object.assign({}, field, {\n        config: cloneDeep(field.config),\n        state: Object.assign({}, field.state)\n      });\n    });\n    const scopedVars = {\n      __series: {\n        text: 'Series',\n        value: {\n          name: getFrameDisplayName(newFrame, index)\n        }\n      } // might be missing\n\n    };\n\n    for (const field of newFrame.fields) {\n      const config = field.config;\n      field.state.scopedVars = Object.assign({}, scopedVars, {\n        __field: {\n          text: 'Field',\n          value: getTemplateProxyForField(field, newFrame, options.data)\n        }\n      });\n      const context = {\n        field: field,\n        data: options.data,\n        dataFrameIndex: index,\n        replaceVariables: options.replaceVariables,\n        fieldConfigRegistry: fieldConfigRegistry\n      }; // Anything in the field config that's not set by the datasource\n      // will be filled in by panel's field configuration\n\n      setFieldConfigDefaults(config, source.defaults, context); // Find any matching rules and then override\n\n      for (const rule of override) {\n        if (rule.match(field, newFrame, options.data)) {\n          for (const prop of rule.properties) {\n            // config.scopedVars is set already here\n            setDynamicConfigValue(config, prop, context);\n          }\n        }\n      } // Try harder to set a real value that is not 'other'\n\n\n      let type = field.type;\n\n      if (!type || type === FieldType.other) {\n        const t = guessFieldTypeForField(field);\n\n        if (t) {\n          type = t;\n        }\n      } // Set the Min/Max value automatically\n\n\n      let range = undefined;\n\n      if (field.type === FieldType.number) {\n        var _config$min, _config$max;\n\n        if (!globalRange && (!isNumber(config.min) || !isNumber(config.max))) {\n          globalRange = findNumericFieldMinMax(options.data);\n        }\n\n        const min = (_config$min = config.min) !== null && _config$min !== void 0 ? _config$min : globalRange.min;\n        const max = (_config$max = config.max) !== null && _config$max !== void 0 ? _config$max : globalRange.max;\n        range = {\n          min,\n          max,\n          delta: max - min\n        };\n      }\n\n      field.state.seriesIndex = seriesIndex;\n      field.state.range = range;\n      field.type = type; // Some color modes needs series index to assign field color so we count\n      // up series index here but ignore time fields\n\n      if (field.type !== FieldType.time) {\n        seriesIndex++;\n      } // and set the display processor using it\n\n\n      field.display = getDisplayProcessor({\n        field: field,\n        theme: options.theme,\n        timeZone: options.timeZone\n      }); // Wrap the display with a cache to avoid double calls\n\n      if (field.config.unit !== 'dateTimeFromNow') {\n        field.display = cachingDisplayProcessor(field.display, 2500);\n      } // Attach data links supplier\n\n\n      field.getLinks = getLinksSupplier(newFrame, field, field.state.scopedVars, context.replaceVariables, options.timeZone);\n    }\n\n    return newFrame;\n  });\n} // this is a significant optimization for streaming, where we currently re-process all values in the buffer on ech update\n// via field.display(value). this can potentially be removed once we...\n// 1. process data packets incrementally and/if cache the results in the streaming datafame (maybe by buffer index)\n// 2. have the ability to selectively get display color or text (but not always both, which are each quite expensive)\n// 3. sufficently optimize text formatting and threshold color determinitation\n\nfunction cachingDisplayProcessor(disp, maxCacheSize = 2500) {\n  const cache = new Map();\n  return value => {\n    let v = cache.get(value);\n\n    if (!v) {\n      // Don't grow too big\n      if (cache.size === maxCacheSize) {\n        cache.clear();\n      }\n\n      v = disp(value); // convert to hex6 or hex8 so downstream we can cheaply test for alpha (and set new alpha)\n      // via a simple length check (in colorManipulator) rather using slow parsing via tinycolor\n\n      if (v.color) {\n        v.color = asHexString(v.color);\n      }\n\n      cache.set(value, v);\n    }\n\n    return v;\n  };\n}\n\nexport function setDynamicConfigValue(config, value, context) {\n  const reg = context.fieldConfigRegistry;\n  const item = reg.getIfExists(value.id);\n\n  if (!item) {\n    return;\n  }\n\n  const val = item.process(value.value, context, item.settings);\n  const remove = val === undefined || val === null;\n\n  if (remove) {\n    if (item.isCustom && config.custom) {\n      unset(config.custom, item.path);\n    } else {\n      unset(config, item.path);\n    }\n  } else {\n    if (item.isCustom) {\n      if (!config.custom) {\n        config.custom = {};\n      }\n\n      set(config.custom, item.path, val);\n    } else {\n      set(config, item.path, val);\n    }\n  }\n} // config -> from DS\n// defaults -> from Panel config\n\nexport function setFieldConfigDefaults(config, defaults, context) {\n  for (const fieldConfigProperty of context.fieldConfigRegistry.list()) {\n    if (fieldConfigProperty.isCustom && !config.custom) {\n      config.custom = {};\n    }\n\n    processFieldConfigValue(fieldConfigProperty.isCustom ? config.custom : config, fieldConfigProperty.isCustom ? defaults.custom : defaults, fieldConfigProperty, context);\n  }\n\n  validateFieldConfig(config);\n}\n\nfunction processFieldConfigValue(destination, // it's mutable\nsource, fieldConfigProperty, context) {\n  const currentConfig = get(destination, fieldConfigProperty.path);\n\n  if (currentConfig === null || currentConfig === undefined) {\n    const item = context.fieldConfigRegistry.getIfExists(fieldConfigProperty.id);\n\n    if (!item) {\n      return;\n    }\n\n    if (item && item.shouldApply(context.field)) {\n      const val = item.process(get(source, item.path), context, item.settings);\n\n      if (val !== undefined && val !== null) {\n        set(destination, item.path, val);\n      }\n    }\n  }\n}\n/**\n * This checks that all options on FieldConfig make sense.  It mutates any value that needs\n * fixed.  In particular this makes sure that the first threshold value is -Infinity (not valid in JSON)\n */\n\n\nexport function validateFieldConfig(config) {\n  const {\n    thresholds\n  } = config;\n\n  if (!config.color) {\n    if (thresholds) {\n      config.color = {\n        mode: FieldColorModeId.Thresholds\n      };\n    } // No Color settings\n\n  } else if (!config.color.mode) {\n    // Without a mode, skip color altogether\n    delete config.color;\n  } // Verify that max > min (swap if necessary)\n\n\n  if (config.hasOwnProperty('min') && config.hasOwnProperty('max') && config.min > config.max) {\n    const tmp = config.max;\n    config.max = config.min;\n    config.min = tmp;\n  }\n}\nexport const getLinksSupplier = (frame, field, fieldScopedVars, replaceVariables, timeZone) => config => {\n  if (!field.config.links || field.config.links.length === 0) {\n    return [];\n  }\n\n  const timeRangeUrl = locationUtil.getTimeRangeUrlParams();\n  const {\n    timeField\n  } = getTimeField(frame);\n  return field.config.links.map(link => {\n    const variablesQuery = locationUtil.getVariablesUrlParams();\n    let dataFrameVars = {};\n    let valueVars = {}; // We are not displaying reduction result\n\n    if (config.valueRowIndex !== undefined && !isNaN(config.valueRowIndex)) {\n      const fieldsProxy = getFieldDisplayValuesProxy({\n        frame,\n        rowIndex: config.valueRowIndex,\n        timeZone: timeZone\n      });\n      valueVars = {\n        raw: field.values.get(config.valueRowIndex),\n        numeric: fieldsProxy[field.name].numeric,\n        text: fieldsProxy[field.name].text,\n        time: timeField ? timeField.values.get(config.valueRowIndex) : undefined\n      };\n      dataFrameVars = {\n        __data: {\n          value: {\n            name: frame.name,\n            refId: frame.refId,\n            fields: fieldsProxy\n          },\n          text: 'Data'\n        }\n      };\n    } else {\n      if (config.calculatedValue) {\n        valueVars = {\n          raw: config.calculatedValue.numeric,\n          numeric: config.calculatedValue.numeric,\n          text: formattedValueToString(config.calculatedValue)\n        };\n      }\n    }\n\n    const variables = Object.assign({}, fieldScopedVars, {\n      __value: {\n        text: 'Value',\n        value: valueVars\n      }\n    }, dataFrameVars, {\n      [DataLinkBuiltInVars.keepTime]: {\n        text: timeRangeUrl,\n        value: timeRangeUrl\n      },\n      [DataLinkBuiltInVars.includeVars]: {\n        text: variablesQuery,\n        value: variablesQuery\n      }\n    });\n\n    if (link.onClick) {\n      return {\n        href: link.url,\n        title: replaceVariables(link.title || '', variables),\n        target: link.targetBlank ? '_blank' : undefined,\n        onClick: (evt, origin) => {\n          link.onClick({\n            origin: origin !== null && origin !== void 0 ? origin : field,\n            e: evt,\n            replaceVariables: v => replaceVariables(v, variables)\n          });\n        },\n        origin: field\n      };\n    }\n\n    if (link.internal) {\n      // For internal links at the moment only destination is Explore.\n      return mapInternalLinkToExplore({\n        link,\n        internalLink: link.internal,\n        scopedVars: variables,\n        field,\n        range: {},\n        replaceVariables\n      });\n    }\n\n    let href = locationUtil.assureBaseUrl(link.url.replace(/\\n/g, ''));\n    href = replaceVariables(href, variables);\n    href = locationUtil.processUrl(href);\n    const info = {\n      href,\n      title: replaceVariables(link.title || '', variables),\n      target: link.targetBlank ? '_blank' : undefined,\n      origin: field\n    };\n    return info;\n  });\n};\n/**\n * Return a copy of the DataFrame with raw data\n */\n\nexport function applyRawFieldOverrides(data) {\n  if (!data || data.length === 0) {\n    return [];\n  }\n\n  const newData = [...data];\n  const processor = getRawDisplayProcessor();\n\n  for (let frameIndex = 0; frameIndex < newData.length; frameIndex++) {\n    const newFrame = Object.assign({}, newData[frameIndex]);\n    const newFields = [...newFrame.fields];\n\n    for (let fieldIndex = 0; fieldIndex < newFields.length; fieldIndex++) {\n      newFields[fieldIndex] = Object.assign({}, newFields[fieldIndex], {\n        display: processor\n      });\n    }\n\n    newData[frameIndex] = Object.assign({}, newFrame, {\n      fields: newFields\n    });\n  }\n\n  return newData;\n}","map":{"version":3,"names":["isNumber","set","unset","get","cloneDeep","guessFieldTypeForField","getTimeField","asHexString","fieldMatchers","reduceField","ReducerID","FieldColorModeId","FieldType","DataLinkBuiltInVars","locationUtil","mapInternalLinkToExplore","formattedValueToString","getDisplayProcessor","getRawDisplayProcessor","getFrameDisplayName","getFieldDisplayValuesProxy","standardFieldConfigEditorRegistry","getTemplateProxyForField","findNumericFieldMinMax","data","min","max","reducers","frame","field","fields","type","number","stats","statsMin","statsMax","delta","applyFieldOverrides","options","source","fieldConfig","fieldConfigRegistry","seriesIndex","globalRange","undefined","override","overrides","rule","info","matcher","id","push","match","properties","map","originalFrame","index","newFrame","config","state","scopedVars","__series","text","value","name","__field","context","dataFrameIndex","replaceVariables","setFieldConfigDefaults","defaults","prop","setDynamicConfigValue","other","t","range","time","display","theme","timeZone","unit","cachingDisplayProcessor","getLinks","getLinksSupplier","disp","maxCacheSize","cache","Map","v","size","clear","color","reg","item","getIfExists","val","process","settings","remove","isCustom","custom","path","fieldConfigProperty","list","processFieldConfigValue","validateFieldConfig","destination","currentConfig","shouldApply","thresholds","mode","Thresholds","hasOwnProperty","tmp","fieldScopedVars","links","length","timeRangeUrl","getTimeRangeUrlParams","timeField","link","variablesQuery","getVariablesUrlParams","dataFrameVars","valueVars","valueRowIndex","isNaN","fieldsProxy","rowIndex","raw","values","numeric","__data","refId","calculatedValue","variables","__value","keepTime","includeVars","onClick","href","url","title","target","targetBlank","evt","origin","e","internal","internalLink","assureBaseUrl","replace","processUrl","applyRawFieldOverrides","newData","processor","frameIndex","newFields","fieldIndex"],"sources":["/home/soula/grafana/packages/grafana-data/src/field/fieldOverrides.ts"],"sourcesContent":["import { isNumber, set, unset, get, cloneDeep } from 'lodash';\n\nimport { guessFieldTypeForField } from '../dataframe';\nimport { getTimeField } from '../dataframe/processDataFrame';\nimport { asHexString } from '../themes/colorManipulator';\nimport { fieldMatchers, reduceField, ReducerID } from '../transformations';\nimport {\n  ApplyFieldOverrideOptions,\n  DataFrame,\n  DataLink,\n  DisplayProcessor,\n  DisplayValue,\n  DynamicConfigValue,\n  Field,\n  FieldColorModeId,\n  FieldConfig,\n  FieldConfigPropertyItem,\n  FieldOverrideContext,\n  FieldType,\n  InterpolateFunction,\n  LinkModel,\n  NumericRange,\n  ScopedVars,\n  TimeZone,\n  ValueLinkConfig,\n} from '../types';\nimport { FieldMatcher } from '../types/transformations';\nimport { DataLinkBuiltInVars, locationUtil } from '../utils';\nimport { mapInternalLinkToExplore } from '../utils/dataLinks';\nimport { formattedValueToString } from '../valueFormats';\n\nimport { FieldConfigOptionsRegistry } from './FieldConfigOptionsRegistry';\nimport { getDisplayProcessor, getRawDisplayProcessor } from './displayProcessor';\nimport { getFrameDisplayName } from './fieldState';\nimport { getFieldDisplayValuesProxy } from './getFieldDisplayValuesProxy';\nimport { standardFieldConfigEditorRegistry } from './standardFieldConfigEditorRegistry';\nimport { getTemplateProxyForField } from './templateProxies';\n\ninterface OverrideProps {\n  match: FieldMatcher;\n  properties: DynamicConfigValue[];\n}\n\nexport function findNumericFieldMinMax(data: DataFrame[]): NumericRange {\n  let min: number | null = null;\n  let max: number | null = null;\n\n  const reducers = [ReducerID.min, ReducerID.max];\n\n  for (const frame of data) {\n    for (const field of frame.fields) {\n      if (field.type === FieldType.number) {\n        const stats = reduceField({ field, reducers });\n        const statsMin = stats[ReducerID.min];\n        const statsMax = stats[ReducerID.max];\n\n        if (min === null || statsMin < min) {\n          min = statsMin;\n        }\n\n        if (max === null || statsMax > max) {\n          max = statsMax;\n        }\n      }\n    }\n  }\n\n  return { min, max, delta: (max ?? 0) - (min ?? 0) };\n}\n\n/**\n * Return a copy of the DataFrame with all rules applied\n */\nexport function applyFieldOverrides(options: ApplyFieldOverrideOptions): DataFrame[] {\n  if (!options.data) {\n    return [];\n  }\n\n  const source = options.fieldConfig;\n  if (!source) {\n    return options.data;\n  }\n\n  const fieldConfigRegistry = options.fieldConfigRegistry ?? standardFieldConfigEditorRegistry;\n\n  let seriesIndex = 0;\n  let globalRange: NumericRange | undefined = undefined;\n\n  // Prepare the Matchers\n  const override: OverrideProps[] = [];\n  if (source.overrides) {\n    for (const rule of source.overrides) {\n      const info = fieldMatchers.get(rule.matcher.id);\n      if (info) {\n        override.push({\n          match: info.get(rule.matcher.options),\n          properties: rule.properties,\n        });\n      }\n    }\n  }\n\n  return options.data.map((originalFrame, index) => {\n    // Need to define this new frame here as it's passed to the getLinkSupplier function inside the fields loop\n    const newFrame: DataFrame = { ...originalFrame };\n    // Copy fields\n    newFrame.fields = newFrame.fields.map((field) => {\n      return {\n        ...field,\n        config: cloneDeep(field.config),\n        state: {\n          ...field.state,\n        },\n      };\n    });\n\n    const scopedVars: ScopedVars = {\n      __series: { text: 'Series', value: { name: getFrameDisplayName(newFrame, index) } }, // might be missing\n    };\n\n    for (const field of newFrame.fields) {\n      const config = field.config;\n\n      field.state!.scopedVars = {\n        ...scopedVars,\n        __field: {\n          text: 'Field',\n          value: getTemplateProxyForField(field, newFrame, options.data),\n        },\n      };\n\n      const context = {\n        field: field,\n        data: options.data!,\n        dataFrameIndex: index,\n        replaceVariables: options.replaceVariables,\n        fieldConfigRegistry: fieldConfigRegistry,\n      };\n\n      // Anything in the field config that's not set by the datasource\n      // will be filled in by panel's field configuration\n      setFieldConfigDefaults(config, source.defaults, context);\n\n      // Find any matching rules and then override\n      for (const rule of override) {\n        if (rule.match(field, newFrame, options.data!)) {\n          for (const prop of rule.properties) {\n            // config.scopedVars is set already here\n            setDynamicConfigValue(config, prop, context);\n          }\n        }\n      }\n\n      // Try harder to set a real value that is not 'other'\n      let type = field.type;\n      if (!type || type === FieldType.other) {\n        const t = guessFieldTypeForField(field);\n        if (t) {\n          type = t;\n        }\n      }\n\n      // Set the Min/Max value automatically\n      let range: NumericRange | undefined = undefined;\n      if (field.type === FieldType.number) {\n        if (!globalRange && (!isNumber(config.min) || !isNumber(config.max))) {\n          globalRange = findNumericFieldMinMax(options.data!);\n        }\n        const min = config.min ?? globalRange!.min;\n        const max = config.max ?? globalRange!.max;\n        range = { min, max, delta: max! - min! };\n      }\n\n      field.state!.seriesIndex = seriesIndex;\n      field.state!.range = range;\n      field.type = type;\n\n      // Some color modes needs series index to assign field color so we count\n      // up series index here but ignore time fields\n      if (field.type !== FieldType.time) {\n        seriesIndex++;\n      }\n\n      // and set the display processor using it\n      field.display = getDisplayProcessor({\n        field: field,\n        theme: options.theme,\n        timeZone: options.timeZone,\n      });\n\n      // Wrap the display with a cache to avoid double calls\n      if (field.config.unit !== 'dateTimeFromNow') {\n        field.display = cachingDisplayProcessor(field.display, 2500);\n      }\n\n      // Attach data links supplier\n      field.getLinks = getLinksSupplier(\n        newFrame,\n        field,\n        field.state!.scopedVars,\n        context.replaceVariables,\n        options.timeZone\n      );\n    }\n\n    return newFrame;\n  });\n}\n\n// this is a significant optimization for streaming, where we currently re-process all values in the buffer on ech update\n// via field.display(value). this can potentially be removed once we...\n// 1. process data packets incrementally and/if cache the results in the streaming datafame (maybe by buffer index)\n// 2. have the ability to selectively get display color or text (but not always both, which are each quite expensive)\n// 3. sufficently optimize text formatting and threshold color determinitation\nfunction cachingDisplayProcessor(disp: DisplayProcessor, maxCacheSize = 2500): DisplayProcessor {\n  const cache = new Map<any, DisplayValue>();\n\n  return (value: any) => {\n    let v = cache.get(value);\n\n    if (!v) {\n      // Don't grow too big\n      if (cache.size === maxCacheSize) {\n        cache.clear();\n      }\n\n      v = disp(value);\n\n      // convert to hex6 or hex8 so downstream we can cheaply test for alpha (and set new alpha)\n      // via a simple length check (in colorManipulator) rather using slow parsing via tinycolor\n      if (v.color) {\n        v.color = asHexString(v.color);\n      }\n\n      cache.set(value, v);\n    }\n\n    return v;\n  };\n}\n\nexport interface FieldOverrideEnv extends FieldOverrideContext {\n  fieldConfigRegistry: FieldConfigOptionsRegistry;\n}\n\nexport function setDynamicConfigValue(config: FieldConfig, value: DynamicConfigValue, context: FieldOverrideEnv) {\n  const reg = context.fieldConfigRegistry;\n  const item = reg.getIfExists(value.id);\n\n  if (!item) {\n    return;\n  }\n\n  const val = item.process(value.value, context, item.settings);\n\n  const remove = val === undefined || val === null;\n\n  if (remove) {\n    if (item.isCustom && config.custom) {\n      unset(config.custom, item.path);\n    } else {\n      unset(config, item.path);\n    }\n  } else {\n    if (item.isCustom) {\n      if (!config.custom) {\n        config.custom = {};\n      }\n      set(config.custom, item.path, val);\n    } else {\n      set(config, item.path, val);\n    }\n  }\n}\n\n// config -> from DS\n// defaults -> from Panel config\nexport function setFieldConfigDefaults(config: FieldConfig, defaults: FieldConfig, context: FieldOverrideEnv) {\n  for (const fieldConfigProperty of context.fieldConfigRegistry.list()) {\n    if (fieldConfigProperty.isCustom && !config.custom) {\n      config.custom = {};\n    }\n    processFieldConfigValue(\n      fieldConfigProperty.isCustom ? config.custom : config,\n      fieldConfigProperty.isCustom ? defaults.custom : defaults,\n      fieldConfigProperty,\n      context\n    );\n  }\n\n  validateFieldConfig(config);\n}\n\nfunction processFieldConfigValue(\n  destination: Record<string, any>, // it's mutable\n  source: Record<string, any>,\n  fieldConfigProperty: FieldConfigPropertyItem,\n  context: FieldOverrideEnv\n) {\n  const currentConfig = get(destination, fieldConfigProperty.path);\n  if (currentConfig === null || currentConfig === undefined) {\n    const item = context.fieldConfigRegistry.getIfExists(fieldConfigProperty.id);\n    if (!item) {\n      return;\n    }\n\n    if (item && item.shouldApply(context.field!)) {\n      const val = item.process(get(source, item.path), context, item.settings);\n      if (val !== undefined && val !== null) {\n        set(destination, item.path, val);\n      }\n    }\n  }\n}\n\n/**\n * This checks that all options on FieldConfig make sense.  It mutates any value that needs\n * fixed.  In particular this makes sure that the first threshold value is -Infinity (not valid in JSON)\n */\nexport function validateFieldConfig(config: FieldConfig) {\n  const { thresholds } = config;\n\n  if (!config.color) {\n    if (thresholds) {\n      config.color = {\n        mode: FieldColorModeId.Thresholds,\n      };\n    }\n    // No Color settings\n  } else if (!config.color.mode) {\n    // Without a mode, skip color altogether\n    delete config.color;\n  }\n\n  // Verify that max > min (swap if necessary)\n  if (config.hasOwnProperty('min') && config.hasOwnProperty('max') && config.min! > config.max!) {\n    const tmp = config.max;\n    config.max = config.min;\n    config.min = tmp;\n  }\n}\n\nexport const getLinksSupplier =\n  (\n    frame: DataFrame,\n    field: Field,\n    fieldScopedVars: ScopedVars,\n    replaceVariables: InterpolateFunction,\n    timeZone?: TimeZone\n  ) =>\n  (config: ValueLinkConfig): Array<LinkModel<Field>> => {\n    if (!field.config.links || field.config.links.length === 0) {\n      return [];\n    }\n    const timeRangeUrl = locationUtil.getTimeRangeUrlParams();\n    const { timeField } = getTimeField(frame);\n\n    return field.config.links.map((link: DataLink) => {\n      const variablesQuery = locationUtil.getVariablesUrlParams();\n      let dataFrameVars = {};\n      let valueVars = {};\n\n      // We are not displaying reduction result\n      if (config.valueRowIndex !== undefined && !isNaN(config.valueRowIndex)) {\n        const fieldsProxy = getFieldDisplayValuesProxy({\n          frame,\n          rowIndex: config.valueRowIndex,\n          timeZone: timeZone,\n        });\n\n        valueVars = {\n          raw: field.values.get(config.valueRowIndex),\n          numeric: fieldsProxy[field.name].numeric,\n          text: fieldsProxy[field.name].text,\n          time: timeField ? timeField.values.get(config.valueRowIndex) : undefined,\n        };\n\n        dataFrameVars = {\n          __data: {\n            value: {\n              name: frame.name,\n              refId: frame.refId,\n              fields: fieldsProxy,\n            },\n            text: 'Data',\n          },\n        };\n      } else {\n        if (config.calculatedValue) {\n          valueVars = {\n            raw: config.calculatedValue.numeric,\n            numeric: config.calculatedValue.numeric,\n            text: formattedValueToString(config.calculatedValue),\n          };\n        }\n      }\n\n      const variables = {\n        ...fieldScopedVars,\n        __value: {\n          text: 'Value',\n          value: valueVars,\n        },\n        ...dataFrameVars,\n        [DataLinkBuiltInVars.keepTime]: {\n          text: timeRangeUrl,\n          value: timeRangeUrl,\n        },\n        [DataLinkBuiltInVars.includeVars]: {\n          text: variablesQuery,\n          value: variablesQuery,\n        },\n      };\n\n      if (link.onClick) {\n        return {\n          href: link.url,\n          title: replaceVariables(link.title || '', variables),\n          target: link.targetBlank ? '_blank' : undefined,\n          onClick: (evt, origin) => {\n            link.onClick!({\n              origin: origin ?? field,\n              e: evt,\n              replaceVariables: (v) => replaceVariables(v, variables),\n            });\n          },\n          origin: field,\n        };\n      }\n\n      if (link.internal) {\n        // For internal links at the moment only destination is Explore.\n        return mapInternalLinkToExplore({\n          link,\n          internalLink: link.internal,\n          scopedVars: variables,\n          field,\n          range: {} as any,\n          replaceVariables,\n        });\n      }\n\n      let href = locationUtil.assureBaseUrl(link.url.replace(/\\n/g, ''));\n      href = replaceVariables(href, variables);\n      href = locationUtil.processUrl(href);\n\n      const info: LinkModel<Field> = {\n        href,\n        title: replaceVariables(link.title || '', variables),\n        target: link.targetBlank ? '_blank' : undefined,\n        origin: field,\n      };\n      return info;\n    });\n  };\n\n/**\n * Return a copy of the DataFrame with raw data\n */\nexport function applyRawFieldOverrides(data: DataFrame[]): DataFrame[] {\n  if (!data || data.length === 0) {\n    return [];\n  }\n\n  const newData = [...data];\n  const processor = getRawDisplayProcessor();\n\n  for (let frameIndex = 0; frameIndex < newData.length; frameIndex++) {\n    const newFrame = { ...newData[frameIndex] };\n    const newFields = [...newFrame.fields];\n\n    for (let fieldIndex = 0; fieldIndex < newFields.length; fieldIndex++) {\n      newFields[fieldIndex] = {\n        ...newFields[fieldIndex],\n        display: processor,\n      };\n    }\n\n    newData[frameIndex] = {\n      ...newFrame,\n      fields: newFields,\n    };\n  }\n\n  return newData;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}