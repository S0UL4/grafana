{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { from, lastValueFrom, merge, Observable, of, Subject, Subscription, throwError } from 'rxjs';\nimport { fromFetch } from 'rxjs/fetch';\nimport { catchError, filter, map, mergeMap, retryWhen, share, takeUntil, tap, throwIfEmpty } from 'rxjs/operators';\nimport { v4 as uuidv4 } from 'uuid';\nimport { AppEvents, DataQueryErrorType } from '@grafana/data';\nimport appEvents from 'app/core/app_events';\nimport { getConfig } from 'app/core/config';\nimport { TokenRevokedModal } from 'app/features/users/TokenRevokedModal';\nimport { ShowModalReactEvent } from '../../types/events';\nimport { isContentTypeApplicationJson, parseInitFromOptions, parseResponseBody, parseUrlFromOptions } from '../utils/fetch';\nimport { isDataQuery, isLocalUrl } from '../utils/query';\nimport { FetchQueue } from './FetchQueue';\nimport { FetchQueueWorker } from './FetchQueueWorker';\nimport { ResponseQueue } from './ResponseQueue';\nimport { contextSrv } from './context_srv';\nconst CANCEL_ALL_REQUESTS_REQUEST_ID = 'cancel_all_requests_request_id';\nexport class BackendSrv {\n  constructor(deps) {\n    _defineProperty(this, \"inFlightRequests\", new Subject());\n\n    _defineProperty(this, \"HTTP_REQUEST_CANCELED\", -1);\n\n    _defineProperty(this, \"noBackendCache\", void 0);\n\n    _defineProperty(this, \"inspectorStream\", new Subject());\n\n    _defineProperty(this, \"fetchQueue\", void 0);\n\n    _defineProperty(this, \"responseQueue\", void 0);\n\n    _defineProperty(this, \"dependencies\", {\n      fromFetch: fromFetch,\n      appEvents: appEvents,\n      contextSrv: contextSrv,\n      logout: () => {\n        contextSrv.setLoggedOut();\n        window.location.reload();\n      }\n    });\n\n    if (deps) {\n      this.dependencies = Object.assign({}, this.dependencies, deps);\n    }\n\n    this.noBackendCache = false;\n    this.internalFetch = this.internalFetch.bind(this);\n    this.fetchQueue = new FetchQueue();\n    this.responseQueue = new ResponseQueue(this.fetchQueue, this.internalFetch);\n    new FetchQueueWorker(this.fetchQueue, this.responseQueue, getConfig());\n  }\n\n  async request(options) {\n    return await lastValueFrom(this.fetch(options).pipe(map(response => response.data)));\n  }\n\n  fetch(options) {\n    // We need to match an entry added to the queue stream with the entry that is eventually added to the response stream\n    const id = uuidv4();\n    const fetchQueue = this.fetchQueue;\n    return new Observable(observer => {\n      // Subscription is an object that is returned whenever you subscribe to an Observable.\n      // You can also use it as a container of many subscriptions and when it is unsubscribed all subscriptions within are also unsubscribed.\n      const subscriptions = new Subscription(); // We're using the subscriptions.add function to add the subscription implicitly returned by this.responseQueue.getResponses<T>(id).subscribe below.\n\n      subscriptions.add(this.responseQueue.getResponses(id).subscribe(result => {\n        // The one liner below can seem magical if you're not accustomed to RxJs.\n        // Firstly, we're subscribing to the result from the result.observable and we're passing in the outer observer object.\n        // By passing the outer observer object then any updates on result.observable are passed through to any subscriber of the fetch<T> function.\n        // Secondly, we're adding the subscription implicitly returned by result.observable.subscribe(observer).\n        subscriptions.add(result.observable.subscribe(observer));\n      })); // Let the fetchQueue know that this id needs to start data fetching.\n\n      this.fetchQueue.add(id, options); // This returned function will be called whenever the returned Observable from the fetch<T> function is unsubscribed/errored/completed/canceled.\n\n      return function unsubscribe() {\n        // Change status to Done moved here from ResponseQueue because this unsubscribe was called before the responseQueue produced a result\n        fetchQueue.setDone(id); // When subscriptions is unsubscribed all the implicitly added subscriptions above are also unsubscribed.\n\n        subscriptions.unsubscribe();\n      };\n    });\n  }\n\n  internalFetch(options) {\n    if (options.requestId) {\n      this.inFlightRequests.next(options.requestId);\n    }\n\n    options = this.parseRequestOptions(options);\n    const fromFetchStream = this.getFromFetchStream(options);\n    const failureStream = fromFetchStream.pipe(this.toFailureStream(options));\n    const successStream = fromFetchStream.pipe(filter(response => response.ok === true), tap(response => {\n      this.showSuccessAlert(response);\n      this.inspectorStream.next(response);\n    }));\n    return merge(successStream, failureStream).pipe(catchError(err => throwError(this.processRequestError(options, err))), this.handleStreamCancellation(options));\n  }\n\n  resolveCancelerIfExists(requestId) {\n    this.inFlightRequests.next(requestId);\n  }\n\n  cancelAllInFlightRequests() {\n    this.inFlightRequests.next(CANCEL_ALL_REQUESTS_REQUEST_ID);\n  }\n\n  async datasourceRequest(options) {\n    return lastValueFrom(this.fetch(options));\n  }\n\n  parseRequestOptions(options) {\n    var _this$dependencies$co, _options$retry;\n\n    const orgId = (_this$dependencies$co = this.dependencies.contextSrv.user) === null || _this$dependencies$co === void 0 ? void 0 : _this$dependencies$co.orgId; // init retry counter\n\n    options.retry = (_options$retry = options.retry) !== null && _options$retry !== void 0 ? _options$retry : 0;\n\n    if (isLocalUrl(options.url)) {\n      var _options$headers2;\n\n      if (orgId) {\n        var _options$headers;\n\n        options.headers = (_options$headers = options.headers) !== null && _options$headers !== void 0 ? _options$headers : {};\n        options.headers['X-Grafana-Org-Id'] = orgId;\n      }\n\n      if (options.url.startsWith('/')) {\n        options.url = options.url.substring(1);\n      }\n\n      if ((_options$headers2 = options.headers) !== null && _options$headers2 !== void 0 && _options$headers2.Authorization) {\n        options.headers['X-DS-Authorization'] = options.headers.Authorization;\n        delete options.headers.Authorization;\n      }\n\n      if (this.noBackendCache) {\n        var _options$headers3;\n\n        options.headers = (_options$headers3 = options.headers) !== null && _options$headers3 !== void 0 ? _options$headers3 : {};\n        options.headers['X-Grafana-NoCache'] = 'true';\n      }\n    }\n\n    if (options.hideFromInspector === undefined) {\n      // Hide all local non data query calls\n      options.hideFromInspector = isLocalUrl(options.url) && !isDataQuery(options.url);\n    }\n\n    return options;\n  }\n\n  getFromFetchStream(options) {\n    const url = parseUrlFromOptions(options);\n    const init = parseInitFromOptions(options);\n    return this.dependencies.fromFetch(url, init).pipe(mergeMap(async response => {\n      var _options$responseType;\n\n      const {\n        status,\n        statusText,\n        ok,\n        headers,\n        url,\n        type,\n        redirected\n      } = response;\n      const responseType = (_options$responseType = options.responseType) !== null && _options$responseType !== void 0 ? _options$responseType : isContentTypeApplicationJson(headers) ? 'json' : undefined;\n      const data = await parseResponseBody(response, responseType);\n      const fetchResponse = {\n        status,\n        statusText,\n        ok,\n        data,\n        headers,\n        url,\n        type,\n        redirected,\n        config: options\n      };\n      return fetchResponse;\n    }), share() // sharing this so we can split into success and failure and then merge back\n    );\n  }\n\n  toFailureStream(options) {\n    const {\n      isSignedIn\n    } = this.dependencies.contextSrv.user;\n    return inputStream => inputStream.pipe(filter(response => response.ok === false), mergeMap(response => {\n      const {\n        status,\n        statusText,\n        data\n      } = response;\n      const fetchErrorResponse = {\n        status,\n        statusText,\n        data,\n        config: options\n      };\n      return throwError(fetchErrorResponse);\n    }), retryWhen(attempts => attempts.pipe(mergeMap((error, i) => {\n      const firstAttempt = i === 0 && options.retry === 0;\n\n      if (error.status === 401 && isLocalUrl(options.url) && firstAttempt && isSignedIn) {\n        var _error$data, _error$data$error;\n\n        if (((_error$data = error.data) === null || _error$data === void 0 ? void 0 : (_error$data$error = _error$data.error) === null || _error$data$error === void 0 ? void 0 : _error$data$error.id) === 'ERR_TOKEN_REVOKED') {\n          var _error$data2, _error$data2$error;\n\n          this.dependencies.appEvents.publish(new ShowModalReactEvent({\n            component: TokenRevokedModal,\n            props: {\n              maxConcurrentSessions: (_error$data2 = error.data) === null || _error$data2 === void 0 ? void 0 : (_error$data2$error = _error$data2.error) === null || _error$data2$error === void 0 ? void 0 : _error$data2$error.maxConcurrentSessions\n            }\n          }));\n          return of({});\n        }\n\n        return from(this.loginPing()).pipe(catchError(err => {\n          if (err.status === 401) {\n            this.dependencies.logout();\n            return throwError(err);\n          }\n\n          return throwError(err);\n        }));\n      }\n\n      return throwError(error);\n    }))));\n  }\n\n  showApplicationErrorAlert(err) {}\n\n  showSuccessAlert(response) {\n    const {\n      config\n    } = response;\n\n    if (config.showSuccessAlert === false) {\n      return;\n    } // is showSuccessAlert is undefined we only show alerts non GET request, non data query and local api requests\n\n\n    if (config.showSuccessAlert === undefined && (config.method === 'GET' || isDataQuery(config.url) || !isLocalUrl(config.url))) {\n      return;\n    }\n\n    const data = response.data;\n\n    if (data !== null && data !== void 0 && data.message) {\n      this.dependencies.appEvents.emit(AppEvents.alertSuccess, [data.message]);\n    }\n  }\n\n  showErrorAlert(config, err) {\n    if (config.showErrorAlert === false) {\n      return;\n    } // is showErrorAlert is undefined we only show alerts non data query and local api requests\n\n\n    if (config.showErrorAlert === undefined && (isDataQuery(config.url) || !isLocalUrl(config.url))) {\n      return;\n    }\n\n    let description = '';\n    let message = err.data.message;\n\n    if (message.length > 80) {\n      description = message;\n      message = 'Error';\n    } // Validation\n\n\n    if (err.status === 422) {\n      message = 'Validation failed';\n    }\n\n    this.dependencies.appEvents.emit(err.status < 500 ? AppEvents.alertWarning : AppEvents.alertError, [message, description, err.data.traceID]);\n  }\n  /**\n   * Processes FetchError to ensure \"data\" property is an object.\n   *\n   * @see DataQueryError.data\n   */\n\n\n  processRequestError(options, err) {\n    var _err$data;\n\n    err.data = (_err$data = err.data) !== null && _err$data !== void 0 ? _err$data : {\n      message: 'Unexpected error'\n    };\n\n    if (typeof err.data === 'string') {\n      err.data = {\n        message: err.data,\n        error: err.statusText,\n        response: err.data\n      };\n    } // If no message but got error string, copy to message prop\n\n\n    if (err.data && !err.data.message && typeof err.data.error === 'string') {\n      err.data.message = err.data.error;\n    } // check if we should show an error alert\n\n\n    if (err.data.message) {\n      setTimeout(() => {\n        if (!err.isHandled) {\n          this.showErrorAlert(options, err);\n        }\n      }, 50);\n    }\n\n    this.inspectorStream.next(err);\n    return err;\n  }\n\n  handleStreamCancellation(options) {\n    return inputStream => inputStream.pipe(takeUntil(this.inFlightRequests.pipe(filter(requestId => {\n      let cancelRequest = false;\n\n      if (options && options.requestId && options.requestId === requestId) {\n        // when a new requestId is started it will be published to inFlightRequests\n        // if a previous long running request that hasn't finished yet has the same requestId\n        // we need to cancel that request\n        cancelRequest = true;\n      }\n\n      if (requestId === CANCEL_ALL_REQUESTS_REQUEST_ID) {\n        cancelRequest = true;\n      }\n\n      return cancelRequest;\n    }))), // when a request is cancelled by takeUntil it will complete without emitting anything so we use throwIfEmpty to identify this case\n    // in throwIfEmpty we'll then throw an cancelled error and then we'll return the correct result in the catchError or rethrow\n    throwIfEmpty(() => ({\n      type: DataQueryErrorType.Cancelled,\n      cancelled: true,\n      data: null,\n      status: this.HTTP_REQUEST_CANCELED,\n      statusText: 'Request was aborted',\n      config: options\n    })));\n  }\n\n  getInspectorStream() {\n    return this.inspectorStream;\n  }\n\n  async get(url, params, requestId) {\n    return await this.request({\n      method: 'GET',\n      url,\n      params,\n      requestId\n    });\n  }\n\n  async delete(url, data) {\n    return await this.request({\n      method: 'DELETE',\n      url,\n      data\n    });\n  }\n\n  async post(url, data) {\n    return await this.request({\n      method: 'POST',\n      url,\n      data\n    });\n  }\n\n  async patch(url, data) {\n    return await this.request({\n      method: 'PATCH',\n      url,\n      data\n    });\n  }\n\n  async put(url, data) {\n    return await this.request({\n      method: 'PUT',\n      url,\n      data\n    });\n  }\n\n  withNoBackendCache(callback) {\n    this.noBackendCache = true;\n    return callback().finally(() => {\n      this.noBackendCache = false;\n    });\n  }\n\n  loginPing() {\n    return this.request({\n      url: '/api/login/ping',\n      method: 'GET',\n      retry: 1\n    });\n  }\n\n  search(query) {\n    return this.get('/api/search', query);\n  }\n\n  getDashboardByUid(uid) {\n    return this.get(`/api/dashboards/uid/${uid}`);\n  }\n\n  getPublicDashboardByUid(uid) {\n    return this.get(`/api/public/dashboards/${uid}`);\n  }\n\n  getFolderByUid(uid) {\n    return this.get(`/api/folders/${uid}`);\n  }\n\n} // Used for testing and things that really need BackendSrv\n\nexport const backendSrv = new BackendSrv();\nexport const getBackendSrv = () => backendSrv;","map":{"version":3,"names":["from","lastValueFrom","merge","Observable","of","Subject","Subscription","throwError","fromFetch","catchError","filter","map","mergeMap","retryWhen","share","takeUntil","tap","throwIfEmpty","v4","uuidv4","AppEvents","DataQueryErrorType","appEvents","getConfig","TokenRevokedModal","ShowModalReactEvent","isContentTypeApplicationJson","parseInitFromOptions","parseResponseBody","parseUrlFromOptions","isDataQuery","isLocalUrl","FetchQueue","FetchQueueWorker","ResponseQueue","contextSrv","CANCEL_ALL_REQUESTS_REQUEST_ID","BackendSrv","constructor","deps","logout","setLoggedOut","window","location","reload","dependencies","noBackendCache","internalFetch","bind","fetchQueue","responseQueue","request","options","fetch","pipe","response","data","id","observer","subscriptions","add","getResponses","subscribe","result","observable","unsubscribe","setDone","requestId","inFlightRequests","next","parseRequestOptions","fromFetchStream","getFromFetchStream","failureStream","toFailureStream","successStream","ok","showSuccessAlert","inspectorStream","err","processRequestError","handleStreamCancellation","resolveCancelerIfExists","cancelAllInFlightRequests","datasourceRequest","orgId","user","retry","url","headers","startsWith","substring","Authorization","hideFromInspector","undefined","init","status","statusText","type","redirected","responseType","fetchResponse","config","isSignedIn","inputStream","fetchErrorResponse","attempts","error","i","firstAttempt","publish","component","props","maxConcurrentSessions","loginPing","showApplicationErrorAlert","method","message","emit","alertSuccess","showErrorAlert","description","length","alertWarning","alertError","traceID","setTimeout","isHandled","cancelRequest","Cancelled","cancelled","HTTP_REQUEST_CANCELED","getInspectorStream","get","params","delete","post","patch","put","withNoBackendCache","callback","finally","search","query","getDashboardByUid","uid","getPublicDashboardByUid","getFolderByUid","backendSrv","getBackendSrv"],"sources":["/home/soula/grafana/public/app/core/services/backend_srv.ts"],"sourcesContent":["import {\n  from,\n  lastValueFrom,\n  merge,\n  MonoTypeOperatorFunction,\n  Observable,\n  of,\n  Subject,\n  Subscription,\n  throwError,\n} from 'rxjs';\nimport { fromFetch } from 'rxjs/fetch';\nimport { catchError, filter, map, mergeMap, retryWhen, share, takeUntil, tap, throwIfEmpty } from 'rxjs/operators';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { AppEvents, DataQueryErrorType } from '@grafana/data';\nimport { BackendSrv as BackendService, BackendSrvRequest, FetchError, FetchResponse } from '@grafana/runtime';\nimport appEvents from 'app/core/app_events';\nimport { getConfig } from 'app/core/config';\nimport { DashboardSearchHit } from 'app/features/search/types';\nimport { TokenRevokedModal } from 'app/features/users/TokenRevokedModal';\nimport { DashboardDTO, FolderDTO } from 'app/types';\n\nimport { ShowModalReactEvent } from '../../types/events';\nimport {\n  isContentTypeApplicationJson,\n  parseInitFromOptions,\n  parseResponseBody,\n  parseUrlFromOptions,\n} from '../utils/fetch';\nimport { isDataQuery, isLocalUrl } from '../utils/query';\n\nimport { FetchQueue } from './FetchQueue';\nimport { FetchQueueWorker } from './FetchQueueWorker';\nimport { ResponseQueue } from './ResponseQueue';\nimport { ContextSrv, contextSrv } from './context_srv';\n\nconst CANCEL_ALL_REQUESTS_REQUEST_ID = 'cancel_all_requests_request_id';\n\nexport interface BackendSrvDependencies {\n  fromFetch: (input: string | Request, init?: RequestInit) => Observable<Response>;\n  appEvents: typeof appEvents;\n  contextSrv: ContextSrv;\n  logout: () => void;\n}\n\nexport class BackendSrv implements BackendService {\n  private inFlightRequests: Subject<string> = new Subject<string>();\n  private HTTP_REQUEST_CANCELED = -1;\n  private noBackendCache: boolean;\n  private inspectorStream: Subject<FetchResponse | FetchError> = new Subject<FetchResponse | FetchError>();\n  private readonly fetchQueue: FetchQueue;\n  private readonly responseQueue: ResponseQueue;\n\n  private dependencies: BackendSrvDependencies = {\n    fromFetch: fromFetch,\n    appEvents: appEvents,\n    contextSrv: contextSrv,\n    logout: () => {\n      contextSrv.setLoggedOut();\n      window.location.reload();\n    },\n  };\n\n  constructor(deps?: BackendSrvDependencies) {\n    if (deps) {\n      this.dependencies = {\n        ...this.dependencies,\n        ...deps,\n      };\n    }\n\n    this.noBackendCache = false;\n    this.internalFetch = this.internalFetch.bind(this);\n    this.fetchQueue = new FetchQueue();\n    this.responseQueue = new ResponseQueue(this.fetchQueue, this.internalFetch);\n    new FetchQueueWorker(this.fetchQueue, this.responseQueue, getConfig());\n  }\n\n  async request<T = any>(options: BackendSrvRequest): Promise<T> {\n    return await lastValueFrom(this.fetch<T>(options).pipe(map((response: FetchResponse<T>) => response.data)));\n  }\n\n  fetch<T>(options: BackendSrvRequest): Observable<FetchResponse<T>> {\n    // We need to match an entry added to the queue stream with the entry that is eventually added to the response stream\n    const id = uuidv4();\n    const fetchQueue = this.fetchQueue;\n\n    return new Observable((observer) => {\n      // Subscription is an object that is returned whenever you subscribe to an Observable.\n      // You can also use it as a container of many subscriptions and when it is unsubscribed all subscriptions within are also unsubscribed.\n      const subscriptions: Subscription = new Subscription();\n\n      // We're using the subscriptions.add function to add the subscription implicitly returned by this.responseQueue.getResponses<T>(id).subscribe below.\n      subscriptions.add(\n        this.responseQueue.getResponses<T>(id).subscribe((result) => {\n          // The one liner below can seem magical if you're not accustomed to RxJs.\n          // Firstly, we're subscribing to the result from the result.observable and we're passing in the outer observer object.\n          // By passing the outer observer object then any updates on result.observable are passed through to any subscriber of the fetch<T> function.\n          // Secondly, we're adding the subscription implicitly returned by result.observable.subscribe(observer).\n          subscriptions.add(result.observable.subscribe(observer));\n        })\n      );\n\n      // Let the fetchQueue know that this id needs to start data fetching.\n      this.fetchQueue.add(id, options);\n\n      // This returned function will be called whenever the returned Observable from the fetch<T> function is unsubscribed/errored/completed/canceled.\n      return function unsubscribe() {\n        // Change status to Done moved here from ResponseQueue because this unsubscribe was called before the responseQueue produced a result\n        fetchQueue.setDone(id);\n\n        // When subscriptions is unsubscribed all the implicitly added subscriptions above are also unsubscribed.\n        subscriptions.unsubscribe();\n      };\n    });\n  }\n\n  private internalFetch<T>(options: BackendSrvRequest): Observable<FetchResponse<T>> {\n    if (options.requestId) {\n      this.inFlightRequests.next(options.requestId);\n    }\n\n    options = this.parseRequestOptions(options);\n\n    const fromFetchStream = this.getFromFetchStream<T>(options);\n    const failureStream = fromFetchStream.pipe(this.toFailureStream<T>(options));\n    const successStream = fromFetchStream.pipe(\n      filter((response) => response.ok === true),\n      tap((response) => {\n        this.showSuccessAlert(response);\n        this.inspectorStream.next(response);\n      })\n    );\n\n    return merge(successStream, failureStream).pipe(\n      catchError((err: FetchError) => throwError(this.processRequestError(options, err))),\n      this.handleStreamCancellation(options)\n    );\n  }\n\n  resolveCancelerIfExists(requestId: string) {\n    this.inFlightRequests.next(requestId);\n  }\n\n  cancelAllInFlightRequests() {\n    this.inFlightRequests.next(CANCEL_ALL_REQUESTS_REQUEST_ID);\n  }\n\n  async datasourceRequest(options: BackendSrvRequest): Promise<any> {\n    return lastValueFrom(this.fetch(options));\n  }\n\n  private parseRequestOptions(options: BackendSrvRequest): BackendSrvRequest {\n    const orgId = this.dependencies.contextSrv.user?.orgId;\n\n    // init retry counter\n    options.retry = options.retry ?? 0;\n\n    if (isLocalUrl(options.url)) {\n      if (orgId) {\n        options.headers = options.headers ?? {};\n        options.headers['X-Grafana-Org-Id'] = orgId;\n      }\n\n      if (options.url.startsWith('/')) {\n        options.url = options.url.substring(1);\n      }\n\n      if (options.headers?.Authorization) {\n        options.headers['X-DS-Authorization'] = options.headers.Authorization;\n        delete options.headers.Authorization;\n      }\n\n      if (this.noBackendCache) {\n        options.headers = options.headers ?? {};\n        options.headers['X-Grafana-NoCache'] = 'true';\n      }\n    }\n\n    if (options.hideFromInspector === undefined) {\n      // Hide all local non data query calls\n      options.hideFromInspector = isLocalUrl(options.url) && !isDataQuery(options.url);\n    }\n\n    return options;\n  }\n\n  private getFromFetchStream<T>(options: BackendSrvRequest): Observable<FetchResponse<T>> {\n    const url = parseUrlFromOptions(options);\n    const init = parseInitFromOptions(options);\n\n    return this.dependencies.fromFetch(url, init).pipe(\n      mergeMap(async (response) => {\n        const { status, statusText, ok, headers, url, type, redirected } = response;\n\n        const responseType = options.responseType ?? (isContentTypeApplicationJson(headers) ? 'json' : undefined);\n\n        const data = await parseResponseBody<T>(response, responseType);\n        const fetchResponse: FetchResponse<T> = {\n          status,\n          statusText,\n          ok,\n          data,\n          headers,\n          url,\n          type,\n          redirected,\n          config: options,\n        };\n        return fetchResponse;\n      }),\n      share() // sharing this so we can split into success and failure and then merge back\n    );\n  }\n\n  private toFailureStream<T>(options: BackendSrvRequest): MonoTypeOperatorFunction<FetchResponse<T>> {\n    const { isSignedIn } = this.dependencies.contextSrv.user;\n\n    return (inputStream) =>\n      inputStream.pipe(\n        filter((response) => response.ok === false),\n        mergeMap((response) => {\n          const { status, statusText, data } = response;\n          const fetchErrorResponse: FetchError = { status, statusText, data, config: options };\n          return throwError(fetchErrorResponse);\n        }),\n        retryWhen((attempts: Observable<any>) =>\n          attempts.pipe(\n            mergeMap((error, i) => {\n              const firstAttempt = i === 0 && options.retry === 0;\n\n              if (error.status === 401 && isLocalUrl(options.url) && firstAttempt && isSignedIn) {\n                if (error.data?.error?.id === 'ERR_TOKEN_REVOKED') {\n                  this.dependencies.appEvents.publish(\n                    new ShowModalReactEvent({\n                      component: TokenRevokedModal,\n                      props: {\n                        maxConcurrentSessions: error.data?.error?.maxConcurrentSessions,\n                      },\n                    })\n                  );\n\n                  return of({});\n                }\n\n                return from(this.loginPing()).pipe(\n                  catchError((err) => {\n                    if (err.status === 401) {\n                      this.dependencies.logout();\n                      return throwError(err);\n                    }\n                    return throwError(err);\n                  })\n                );\n              }\n\n              return throwError(error);\n            })\n          )\n        )\n      );\n  }\n\n  showApplicationErrorAlert(err: FetchError) {}\n\n  showSuccessAlert<T>(response: FetchResponse<T>) {\n    const { config } = response;\n\n    if (config.showSuccessAlert === false) {\n      return;\n    }\n\n    // is showSuccessAlert is undefined we only show alerts non GET request, non data query and local api requests\n    if (\n      config.showSuccessAlert === undefined &&\n      (config.method === 'GET' || isDataQuery(config.url) || !isLocalUrl(config.url))\n    ) {\n      return;\n    }\n\n    const data: { message: string } = response.data as any;\n\n    if (data?.message) {\n      this.dependencies.appEvents.emit(AppEvents.alertSuccess, [data.message]);\n    }\n  }\n\n  showErrorAlert<T>(config: BackendSrvRequest, err: FetchError) {\n    if (config.showErrorAlert === false) {\n      return;\n    }\n\n    // is showErrorAlert is undefined we only show alerts non data query and local api requests\n    if (config.showErrorAlert === undefined && (isDataQuery(config.url) || !isLocalUrl(config.url))) {\n      return;\n    }\n\n    let description = '';\n    let message = err.data.message;\n\n    if (message.length > 80) {\n      description = message;\n      message = 'Error';\n    }\n\n    // Validation\n    if (err.status === 422) {\n      message = 'Validation failed';\n    }\n\n    this.dependencies.appEvents.emit(err.status < 500 ? AppEvents.alertWarning : AppEvents.alertError, [\n      message,\n      description,\n      err.data.traceID,\n    ]);\n  }\n\n  /**\n   * Processes FetchError to ensure \"data\" property is an object.\n   *\n   * @see DataQueryError.data\n   */\n  processRequestError(options: BackendSrvRequest, err: FetchError): FetchError<{ message: string; error?: string }> {\n    err.data = err.data ?? { message: 'Unexpected error' };\n\n    if (typeof err.data === 'string') {\n      err.data = {\n        message: err.data,\n        error: err.statusText,\n        response: err.data,\n      };\n    }\n\n    // If no message but got error string, copy to message prop\n    if (err.data && !err.data.message && typeof err.data.error === 'string') {\n      err.data.message = err.data.error;\n    }\n\n    // check if we should show an error alert\n    if (err.data.message) {\n      setTimeout(() => {\n        if (!err.isHandled) {\n          this.showErrorAlert(options, err);\n        }\n      }, 50);\n    }\n\n    this.inspectorStream.next(err);\n    return err;\n  }\n\n  private handleStreamCancellation(options: BackendSrvRequest): MonoTypeOperatorFunction<FetchResponse<any>> {\n    return (inputStream) =>\n      inputStream.pipe(\n        takeUntil(\n          this.inFlightRequests.pipe(\n            filter((requestId) => {\n              let cancelRequest = false;\n\n              if (options && options.requestId && options.requestId === requestId) {\n                // when a new requestId is started it will be published to inFlightRequests\n                // if a previous long running request that hasn't finished yet has the same requestId\n                // we need to cancel that request\n                cancelRequest = true;\n              }\n\n              if (requestId === CANCEL_ALL_REQUESTS_REQUEST_ID) {\n                cancelRequest = true;\n              }\n\n              return cancelRequest;\n            })\n          )\n        ),\n        // when a request is cancelled by takeUntil it will complete without emitting anything so we use throwIfEmpty to identify this case\n        // in throwIfEmpty we'll then throw an cancelled error and then we'll return the correct result in the catchError or rethrow\n        throwIfEmpty(() => ({\n          type: DataQueryErrorType.Cancelled,\n          cancelled: true,\n          data: null,\n          status: this.HTTP_REQUEST_CANCELED,\n          statusText: 'Request was aborted',\n          config: options,\n        }))\n      );\n  }\n\n  getInspectorStream(): Observable<FetchResponse<any> | FetchError> {\n    return this.inspectorStream;\n  }\n\n  async get<T = any>(url: string, params?: any, requestId?: string): Promise<T> {\n    return await this.request({ method: 'GET', url, params, requestId });\n  }\n\n  async delete(url: string, data?: any) {\n    return await this.request({ method: 'DELETE', url, data });\n  }\n\n  async post(url: string, data?: any) {\n    return await this.request({ method: 'POST', url, data });\n  }\n\n  async patch(url: string, data: any) {\n    return await this.request({ method: 'PATCH', url, data });\n  }\n\n  async put(url: string, data: any) {\n    return await this.request({ method: 'PUT', url, data });\n  }\n\n  withNoBackendCache(callback: any) {\n    this.noBackendCache = true;\n    return callback().finally(() => {\n      this.noBackendCache = false;\n    });\n  }\n\n  loginPing() {\n    return this.request({ url: '/api/login/ping', method: 'GET', retry: 1 });\n  }\n\n  search(query: any): Promise<DashboardSearchHit[]> {\n    return this.get('/api/search', query);\n  }\n\n  getDashboardByUid(uid: string) {\n    return this.get<DashboardDTO>(`/api/dashboards/uid/${uid}`);\n  }\n\n  getPublicDashboardByUid(uid: string) {\n    return this.get<DashboardDTO>(`/api/public/dashboards/${uid}`);\n  }\n\n  getFolderByUid(uid: string) {\n    return this.get<FolderDTO>(`/api/folders/${uid}`);\n  }\n}\n\n// Used for testing and things that really need BackendSrv\nexport const backendSrv = new BackendSrv();\nexport const getBackendSrv = (): BackendSrv => backendSrv;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}