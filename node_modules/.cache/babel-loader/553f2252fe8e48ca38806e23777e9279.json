{"ast":null,"code":"// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nexport default function filterSpans(textFilter, spans) {\n  if (!spans) {\n    return undefined;\n  } // if a span field includes at least one filter in includeFilters, the span is a match\n\n\n  const includeFilters = []; // values with keys that include text in any one of the excludeKeys will be ignored\n\n  const excludeKeys = []; // split textFilter by whitespace, remove empty strings, and extract includeFilters and excludeKeys\n\n  textFilter.split(/\\s+/).filter(Boolean).forEach(w => {\n    if (w[0] === '-') {\n      excludeKeys.push(w.slice(1).toLowerCase());\n    } else {\n      includeFilters.push(w.toLowerCase());\n    }\n  });\n\n  const isTextInFilters = (filters, text) => filters.some(filter => text.toLowerCase().includes(filter));\n\n  const isTextInKeyValues = kvs => kvs ? kvs.some(kv => {\n    // ignore checking key and value for a match if key is in excludeKeys\n    if (isTextInFilters(excludeKeys, kv.key)) {\n      return false;\n    } // match if key or value matches an item in includeFilters\n\n\n    return isTextInFilters(includeFilters, kv.key) || isTextInFilters(includeFilters, kv.value.toString());\n  }) : false;\n\n  const isSpanAMatch = span => isTextInFilters(includeFilters, span.operationName) || isTextInFilters(includeFilters, span.process.serviceName) || isTextInKeyValues(span.tags) || span.logs !== null && span.logs.some(log => isTextInKeyValues(log.fields)) || isTextInKeyValues(span.process.tags) || includeFilters.some(filter => filter === span.spanID); // declare as const because need to disambiguate the type\n\n\n  const rv = new Set(spans.filter(isSpanAMatch).map(span => span.spanID));\n  return rv;\n}","map":{"version":3,"names":["filterSpans","textFilter","spans","undefined","includeFilters","excludeKeys","split","filter","Boolean","forEach","w","push","slice","toLowerCase","isTextInFilters","filters","text","some","includes","isTextInKeyValues","kvs","kv","key","value","toString","isSpanAMatch","span","operationName","process","serviceName","tags","logs","log","fields","spanID","rv","Set","map"],"sources":["/home/soula/grafana/packages/jaeger-ui-components/src/utils/filter-spans.tsx"],"sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { TNil } from '../types';\nimport { TraceKeyValuePair, TraceSpan } from '../types/trace';\n\nexport default function filterSpans(textFilter: string, spans: TraceSpan[] | TNil) {\n  if (!spans) {\n    return undefined;\n  }\n\n  // if a span field includes at least one filter in includeFilters, the span is a match\n  const includeFilters: string[] = [];\n\n  // values with keys that include text in any one of the excludeKeys will be ignored\n  const excludeKeys: string[] = [];\n\n  // split textFilter by whitespace, remove empty strings, and extract includeFilters and excludeKeys\n  textFilter\n    .split(/\\s+/)\n    .filter(Boolean)\n    .forEach((w) => {\n      if (w[0] === '-') {\n        excludeKeys.push(w.slice(1).toLowerCase());\n      } else {\n        includeFilters.push(w.toLowerCase());\n      }\n    });\n\n  const isTextInFilters = (filters: string[], text: string) =>\n    filters.some((filter) => text.toLowerCase().includes(filter));\n\n  const isTextInKeyValues = (kvs: TraceKeyValuePair[]) =>\n    kvs\n      ? kvs.some((kv) => {\n          // ignore checking key and value for a match if key is in excludeKeys\n          if (isTextInFilters(excludeKeys, kv.key)) {\n            return false;\n          }\n          // match if key or value matches an item in includeFilters\n          return isTextInFilters(includeFilters, kv.key) || isTextInFilters(includeFilters, kv.value.toString());\n        })\n      : false;\n\n  const isSpanAMatch = (span: TraceSpan) =>\n    isTextInFilters(includeFilters, span.operationName) ||\n    isTextInFilters(includeFilters, span.process.serviceName) ||\n    isTextInKeyValues(span.tags) ||\n    (span.logs !== null && span.logs.some((log) => isTextInKeyValues(log.fields))) ||\n    isTextInKeyValues(span.process.tags) ||\n    includeFilters.some((filter) => filter === span.spanID);\n\n  // declare as const because need to disambiguate the type\n  const rv: Set<string> = new Set(spans.filter(isSpanAMatch).map((span: TraceSpan) => span.spanID));\n  return rv;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA,eAAe,SAASA,WAAT,CAAqBC,UAArB,EAAyCC,KAAzC,EAAoE;EACjF,IAAI,CAACA,KAAL,EAAY;IACV,OAAOC,SAAP;EACD,CAHgF,CAKjF;;;EACA,MAAMC,cAAwB,GAAG,EAAjC,CANiF,CAQjF;;EACA,MAAMC,WAAqB,GAAG,EAA9B,CATiF,CAWjF;;EACAJ,UAAU,CACPK,KADH,CACS,KADT,EAEGC,MAFH,CAEUC,OAFV,EAGGC,OAHH,CAGYC,CAAD,IAAO;IACd,IAAIA,CAAC,CAAC,CAAD,CAAD,KAAS,GAAb,EAAkB;MAChBL,WAAW,CAACM,IAAZ,CAAiBD,CAAC,CAACE,KAAF,CAAQ,CAAR,EAAWC,WAAX,EAAjB;IACD,CAFD,MAEO;MACLT,cAAc,CAACO,IAAf,CAAoBD,CAAC,CAACG,WAAF,EAApB;IACD;EACF,CATH;;EAWA,MAAMC,eAAe,GAAG,CAACC,OAAD,EAAoBC,IAApB,KACtBD,OAAO,CAACE,IAAR,CAAcV,MAAD,IAAYS,IAAI,CAACH,WAAL,GAAmBK,QAAnB,CAA4BX,MAA5B,CAAzB,CADF;;EAGA,MAAMY,iBAAiB,GAAIC,GAAD,IACxBA,GAAG,GACCA,GAAG,CAACH,IAAJ,CAAUI,EAAD,IAAQ;IACf;IACA,IAAIP,eAAe,CAACT,WAAD,EAAcgB,EAAE,CAACC,GAAjB,CAAnB,EAA0C;MACxC,OAAO,KAAP;IACD,CAJc,CAKf;;;IACA,OAAOR,eAAe,CAACV,cAAD,EAAiBiB,EAAE,CAACC,GAApB,CAAf,IAA2CR,eAAe,CAACV,cAAD,EAAiBiB,EAAE,CAACE,KAAH,CAASC,QAAT,EAAjB,CAAjE;EACD,CAPD,CADD,GASC,KAVN;;EAYA,MAAMC,YAAY,GAAIC,IAAD,IACnBZ,eAAe,CAACV,cAAD,EAAiBsB,IAAI,CAACC,aAAtB,CAAf,IACAb,eAAe,CAACV,cAAD,EAAiBsB,IAAI,CAACE,OAAL,CAAaC,WAA9B,CADf,IAEAV,iBAAiB,CAACO,IAAI,CAACI,IAAN,CAFjB,IAGCJ,IAAI,CAACK,IAAL,KAAc,IAAd,IAAsBL,IAAI,CAACK,IAAL,CAAUd,IAAV,CAAgBe,GAAD,IAASb,iBAAiB,CAACa,GAAG,CAACC,MAAL,CAAzC,CAHvB,IAIAd,iBAAiB,CAACO,IAAI,CAACE,OAAL,CAAaE,IAAd,CAJjB,IAKA1B,cAAc,CAACa,IAAf,CAAqBV,MAAD,IAAYA,MAAM,KAAKmB,IAAI,CAACQ,MAAhD,CANF,CAtCiF,CA8CjF;;;EACA,MAAMC,EAAe,GAAG,IAAIC,GAAJ,CAAQlC,KAAK,CAACK,MAAN,CAAakB,YAAb,EAA2BY,GAA3B,CAAgCX,IAAD,IAAqBA,IAAI,CAACQ,MAAzD,CAAR,CAAxB;EACA,OAAOC,EAAP;AACD"},"metadata":{},"sourceType":"module"}