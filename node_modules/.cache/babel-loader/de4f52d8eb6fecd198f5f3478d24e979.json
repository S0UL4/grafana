{"ast":null,"code":"const _excluded = [\"__name__\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { invert } from 'lodash';\nimport { Token } from 'prismjs';\nimport { AbstractLabelOperator } from '@grafana/data';\nimport { addLabelToQuery } from './add_label_to_query';\nimport { SUGGESTIONS_LIMIT } from './language_provider';\nexport const processHistogramMetrics = metrics => {\n  const resultSet = new Set();\n  const regexp = new RegExp('_bucket($|:)');\n\n  for (let index = 0; index < metrics.length; index++) {\n    const metric = metrics[index];\n    const isHistogramValue = regexp.test(metric);\n\n    if (isHistogramValue) {\n      resultSet.add(metric);\n    }\n  }\n\n  return [...resultSet];\n};\nexport function processLabels(labels, withName = false) {\n  // For processing we are going to use sets as they have significantly better performance than arrays\n  // After we process labels, we will convert sets to arrays and return object with label values in arrays\n  const valueSet = {};\n  labels.forEach(label => {\n    const {\n      __name__\n    } = label,\n          rest = _objectWithoutPropertiesLoose(label, _excluded);\n\n    if (withName) {\n      valueSet['__name__'] = valueSet['__name__'] || new Set();\n\n      if (!valueSet['__name__'].has(__name__)) {\n        valueSet['__name__'].add(__name__);\n      }\n    }\n\n    Object.keys(rest).forEach(key => {\n      if (!valueSet[key]) {\n        valueSet[key] = new Set();\n      }\n\n      if (!valueSet[key].has(rest[key])) {\n        valueSet[key].add(rest[key]);\n      }\n    });\n  }); // valueArray that we are going to return in the object\n\n  const valueArray = {};\n  limitSuggestions(Object.keys(valueSet)).forEach(key => {\n    valueArray[key] = limitSuggestions(Array.from(valueSet[key]));\n  });\n  return {\n    values: valueArray,\n    keys: Object.keys(valueArray)\n  };\n} // const cleanSelectorRegexp = /\\{(\\w+=\"[^\"\\n]*?\")(,\\w+=\"[^\"\\n]*?\")*\\}/;\n\nexport const selectorRegexp = /\\{[^}]*?(\\}|$)/;\nexport const labelRegexp = /\\b(\\w+)(!?=~?)(\"[^\"\\n]*?\")/g;\nexport function parseSelector(query, cursorOffset = 1) {\n  if (!query.match(selectorRegexp)) {\n    // Special matcher for metrics\n    if (query.match(/^[A-Za-z:][\\w:]*$/)) {\n      return {\n        selector: `{__name__=\"${query}\"}`,\n        labelKeys: ['__name__']\n      };\n    }\n\n    throw new Error('Query must contain a selector: ' + query);\n  } // Check if inside a selector\n\n\n  const prefix = query.slice(0, cursorOffset);\n  const prefixOpen = prefix.lastIndexOf('{');\n  const prefixClose = prefix.lastIndexOf('}');\n\n  if (prefixOpen === -1) {\n    throw new Error('Not inside selector, missing open brace: ' + prefix);\n  }\n\n  if (prefixClose > -1 && prefixClose > prefixOpen) {\n    throw new Error('Not inside selector, previous selector already closed: ' + prefix);\n  }\n\n  const suffix = query.slice(cursorOffset);\n  const suffixCloseIndex = suffix.indexOf('}');\n  const suffixClose = suffixCloseIndex + cursorOffset;\n  const suffixOpenIndex = suffix.indexOf('{');\n  const suffixOpen = suffixOpenIndex + cursorOffset;\n\n  if (suffixClose === -1) {\n    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);\n  }\n\n  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {\n    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);\n  } // Extract clean labels to form clean selector, incomplete labels are dropped\n\n\n  const selector = query.slice(prefixOpen, suffixClose);\n  const labels = {};\n  selector.replace(labelRegexp, (label, key, operator, value) => {\n    const labelOffset = query.indexOf(label);\n    const valueStart = labelOffset + key.length + operator.length + 1;\n    const valueEnd = labelOffset + key.length + operator.length + value.length - 1; // Skip label if cursor is in value\n\n    if (cursorOffset < valueStart || cursorOffset > valueEnd) {\n      labels[key] = {\n        value,\n        operator\n      };\n    }\n\n    return '';\n  }); // Add metric if there is one before the selector\n\n  const metricPrefix = query.slice(0, prefixOpen);\n  const metricMatch = metricPrefix.match(/[A-Za-z:][\\w:]*$/);\n\n  if (metricMatch) {\n    labels['__name__'] = {\n      value: `\"${metricMatch[0]}\"`,\n      operator: '='\n    };\n  } // Build sorted selector\n\n\n  const labelKeys = Object.keys(labels).sort();\n  const cleanSelector = labelKeys.map(key => `${key}${labels[key].operator}${labels[key].value}`).join(',');\n  const selectorString = ['{', cleanSelector, '}'].join('');\n  return {\n    labelKeys,\n    selector: selectorString\n  };\n}\nexport function expandRecordingRules(query, mapping) {\n  const ruleNames = Object.keys(mapping);\n  const rulesRegex = new RegExp(`(\\\\s|^)(${ruleNames.join('|')})(\\\\s|$|\\\\(|\\\\[|\\\\{)`, 'ig');\n  const expandedQuery = query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`); // Split query into array, so if query uses operators, we can correctly add labels to each individual part.\n\n  const queryArray = expandedQuery.split(/(\\+|\\-|\\*|\\/|\\%|\\^)/); // Regex that matches occurrences of ){ or }{ or ]{ which is a sign of incorrecly added labels.\n\n  const invalidLabelsRegex = /(\\)\\{|\\}\\{|\\]\\{)/;\n  const correctlyExpandedQueryArray = queryArray.map(query => {\n    return addLabelsToExpression(query, invalidLabelsRegex);\n  });\n  return correctlyExpandedQueryArray.join('');\n}\n\nfunction addLabelsToExpression(expr, invalidLabelsRegexp) {\n  var _match$index;\n\n  const match = expr.match(invalidLabelsRegexp);\n\n  if (!match) {\n    return expr;\n  } // Split query into 2 parts - before the invalidLabelsRegex match and after.\n\n\n  const indexOfRegexMatch = (_match$index = match.index) !== null && _match$index !== void 0 ? _match$index : 0;\n  const exprBeforeRegexMatch = expr.slice(0, indexOfRegexMatch + 1);\n  const exprAfterRegexMatch = expr.slice(indexOfRegexMatch + 1); // Create arrayOfLabelObjects with label objects that have key, operator and value.\n\n  const arrayOfLabelObjects = [];\n  exprAfterRegexMatch.replace(labelRegexp, (label, key, operator, value) => {\n    arrayOfLabelObjects.push({\n      key,\n      operator,\n      value\n    });\n    return '';\n  }); // Loop through all label objects and add them to query.\n  // As a starting point we have valid query without the labels.\n\n  let result = exprBeforeRegexMatch;\n  arrayOfLabelObjects.filter(Boolean).forEach(obj => {\n    // Remove extra set of quotes from obj.value\n    const value = obj.value.slice(1, -1);\n    result = addLabelToQuery(result, obj.key, value, obj.operator);\n  });\n  return result;\n}\n/**\n * Adds metadata for synthetic metrics for which the API does not provide metadata.\n * See https://github.com/grafana/grafana/issues/22337 for details.\n *\n * @param metadata HELP and TYPE metadata from /api/v1/metadata\n */\n\n\nexport function fixSummariesMetadata(metadata) {\n  if (!metadata) {\n    return metadata;\n  }\n\n  const baseMetadata = {};\n  const summaryMetadata = {};\n\n  for (const metric in metadata) {\n    // NOTE: based on prometheus-documentation, we can receive\n    // multiple metadata-entries for the given metric, it seems\n    // it happens when the same metric is on multiple targets\n    // and their help-text differs\n    // (https://prometheus.io/docs/prometheus/latest/querying/api/#querying-metric-metadata)\n    // for now we just use the first entry.\n    const item = metadata[metric][0];\n    baseMetadata[metric] = item;\n\n    if (item.type === 'histogram') {\n      summaryMetadata[`${metric}_bucket`] = {\n        type: 'counter',\n        help: `Cumulative counters for the observation buckets (${item.help})`\n      };\n      summaryMetadata[`${metric}_count`] = {\n        type: 'counter',\n        help: `Count of events that have been observed for the histogram metric (${item.help})`\n      };\n      summaryMetadata[`${metric}_sum`] = {\n        type: 'counter',\n        help: `Total sum of all observed values for the histogram metric (${item.help})`\n      };\n    }\n\n    if (item.type === 'summary') {\n      summaryMetadata[`${metric}_count`] = {\n        type: 'counter',\n        help: `Count of events that have been observed for the base metric (${item.help})`\n      };\n      summaryMetadata[`${metric}_sum`] = {\n        type: 'counter',\n        help: `Total sum of all observed values for the base metric (${item.help})`\n      };\n    }\n  } // Synthetic series\n\n\n  const syntheticMetadata = {};\n  syntheticMetadata['ALERTS'] = {\n    type: 'counter',\n    help: 'Time series showing pending and firing alerts. The sample value is set to 1 as long as the alert is in the indicated active (pending or firing) state.'\n  };\n  return Object.assign({}, baseMetadata, summaryMetadata, syntheticMetadata);\n}\nexport function roundMsToMin(milliseconds) {\n  return roundSecToMin(milliseconds / 1000);\n}\nexport function roundSecToMin(seconds) {\n  return Math.floor(seconds / 60);\n}\nexport function limitSuggestions(items) {\n  return items.slice(0, SUGGESTIONS_LIMIT);\n}\nexport function addLimitInfo(items) {\n  return items && items.length >= SUGGESTIONS_LIMIT ? `, limited to the first ${SUGGESTIONS_LIMIT} received items` : '';\n} // NOTE: the following 2 exported functions are very similar to the prometheus*Escape\n// functions in datasource.ts, but they are not exactly the same algorithm, and we found\n// no way to reuse one in the another or vice versa.\n// Prometheus regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),\n// so every character that matches something in that list has to be escaped.\n// the list of metacharacters is: *+?()|\\.[]{}^$\n// we make a javascript regular expression that matches those characters:\n\nconst RE2_METACHARACTERS = /[*+?()|\\\\.\\[\\]{}^$]/g;\n\nfunction escapePrometheusRegexp(value) {\n  return value.replace(RE2_METACHARACTERS, '\\\\$&');\n} // based on the openmetrics-documentation, the 3 symbols we have to handle are:\n// - \\n ... the newline character\n// - \\  ... the backslash character\n// - \"  ... the double-quote character\n\n\nexport function escapeLabelValueInExactSelector(labelValue) {\n  return labelValue.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n').replace(/\"/g, '\\\\\"');\n}\nexport function escapeLabelValueInRegexSelector(labelValue) {\n  return escapeLabelValueInExactSelector(escapePrometheusRegexp(labelValue));\n}\nconst FromPromLikeMap = {\n  '=': AbstractLabelOperator.Equal,\n  '!=': AbstractLabelOperator.NotEqual,\n  '=~': AbstractLabelOperator.EqualRegEx,\n  '!~': AbstractLabelOperator.NotEqualRegEx\n};\nconst ToPromLikeMap = invert(FromPromLikeMap);\nexport function toPromLikeExpr(labelBasedQuery) {\n  const expr = labelBasedQuery.labelMatchers.map(selector => {\n    const operator = ToPromLikeMap[selector.operator];\n\n    if (operator) {\n      return `${selector.name}${operator}\"${selector.value}\"`;\n    } else {\n      return '';\n    }\n  }).filter(e => e !== '').join(', ');\n  return expr ? `{${expr}}` : '';\n}\nexport function toPromLikeQuery(labelBasedQuery) {\n  return {\n    refId: labelBasedQuery.refId,\n    expr: toPromLikeExpr(labelBasedQuery),\n    range: true\n  };\n}\nexport function extractLabelMatchers(tokens) {\n  const labelMatchers = [];\n\n  for (let prop in tokens) {\n    if (tokens[prop] instanceof Token) {\n      let token = tokens[prop];\n\n      if (token.type === 'context-labels') {\n        let labelKey = '';\n        let labelValue = '';\n        let labelOperator = '';\n        let contentTokens = token.content;\n\n        for (let currentToken in contentTokens) {\n          if (typeof contentTokens[currentToken] === 'string') {\n            let currentStr;\n            currentStr = contentTokens[currentToken];\n\n            if (currentStr === '=' || currentStr === '!=' || currentStr === '=~' || currentStr === '!~') {\n              labelOperator = currentStr;\n            }\n          } else if (contentTokens[currentToken] instanceof Token) {\n            switch (contentTokens[currentToken].type) {\n              case 'label-key':\n                labelKey = contentTokens[currentToken].content;\n                break;\n\n              case 'label-value':\n                labelValue = contentTokens[currentToken].content;\n                labelValue = labelValue.substring(1, labelValue.length - 1);\n                const labelComparator = FromPromLikeMap[labelOperator];\n\n                if (labelComparator) {\n                  labelMatchers.push({\n                    name: labelKey,\n                    operator: labelComparator,\n                    value: labelValue\n                  });\n                }\n\n                break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return labelMatchers;\n}","map":{"version":3,"names":["invert","Token","AbstractLabelOperator","addLabelToQuery","SUGGESTIONS_LIMIT","processHistogramMetrics","metrics","resultSet","Set","regexp","RegExp","index","length","metric","isHistogramValue","test","add","processLabels","labels","withName","valueSet","forEach","label","__name__","rest","has","Object","keys","key","valueArray","limitSuggestions","Array","from","values","selectorRegexp","labelRegexp","parseSelector","query","cursorOffset","match","selector","labelKeys","Error","prefix","slice","prefixOpen","lastIndexOf","prefixClose","suffix","suffixCloseIndex","indexOf","suffixClose","suffixOpenIndex","suffixOpen","replace","operator","value","labelOffset","valueStart","valueEnd","metricPrefix","metricMatch","sort","cleanSelector","map","join","selectorString","expandRecordingRules","mapping","ruleNames","rulesRegex","expandedQuery","pre","name","post","queryArray","split","invalidLabelsRegex","correctlyExpandedQueryArray","addLabelsToExpression","expr","invalidLabelsRegexp","indexOfRegexMatch","exprBeforeRegexMatch","exprAfterRegexMatch","arrayOfLabelObjects","push","result","filter","Boolean","obj","fixSummariesMetadata","metadata","baseMetadata","summaryMetadata","item","type","help","syntheticMetadata","roundMsToMin","milliseconds","roundSecToMin","seconds","Math","floor","items","addLimitInfo","RE2_METACHARACTERS","escapePrometheusRegexp","escapeLabelValueInExactSelector","labelValue","escapeLabelValueInRegexSelector","FromPromLikeMap","Equal","NotEqual","EqualRegEx","NotEqualRegEx","ToPromLikeMap","toPromLikeExpr","labelBasedQuery","labelMatchers","e","toPromLikeQuery","refId","range","extractLabelMatchers","tokens","prop","token","labelKey","labelOperator","contentTokens","content","currentToken","currentStr","substring","labelComparator"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/language_utils.ts"],"sourcesContent":["import { invert } from 'lodash';\nimport { Token } from 'prismjs';\n\nimport { DataQuery, AbstractQuery, AbstractLabelOperator, AbstractLabelMatcher } from '@grafana/data';\n\nimport { addLabelToQuery } from './add_label_to_query';\nimport { SUGGESTIONS_LIMIT } from './language_provider';\nimport { PromMetricsMetadata, PromMetricsMetadataItem } from './types';\n\nexport const processHistogramMetrics = (metrics: string[]) => {\n  const resultSet: Set<string> = new Set();\n  const regexp = new RegExp('_bucket($|:)');\n  for (let index = 0; index < metrics.length; index++) {\n    const metric = metrics[index];\n    const isHistogramValue = regexp.test(metric);\n    if (isHistogramValue) {\n      resultSet.add(metric);\n    }\n  }\n  return [...resultSet];\n};\n\nexport function processLabels(labels: Array<{ [key: string]: string }>, withName = false) {\n  // For processing we are going to use sets as they have significantly better performance than arrays\n  // After we process labels, we will convert sets to arrays and return object with label values in arrays\n  const valueSet: { [key: string]: Set<string> } = {};\n  labels.forEach((label) => {\n    const { __name__, ...rest } = label;\n    if (withName) {\n      valueSet['__name__'] = valueSet['__name__'] || new Set();\n      if (!valueSet['__name__'].has(__name__)) {\n        valueSet['__name__'].add(__name__);\n      }\n    }\n\n    Object.keys(rest).forEach((key) => {\n      if (!valueSet[key]) {\n        valueSet[key] = new Set();\n      }\n      if (!valueSet[key].has(rest[key])) {\n        valueSet[key].add(rest[key]);\n      }\n    });\n  });\n\n  // valueArray that we are going to return in the object\n  const valueArray: { [key: string]: string[] } = {};\n  limitSuggestions(Object.keys(valueSet)).forEach((key) => {\n    valueArray[key] = limitSuggestions(Array.from(valueSet[key]));\n  });\n\n  return { values: valueArray, keys: Object.keys(valueArray) };\n}\n\n// const cleanSelectorRegexp = /\\{(\\w+=\"[^\"\\n]*?\")(,\\w+=\"[^\"\\n]*?\")*\\}/;\nexport const selectorRegexp = /\\{[^}]*?(\\}|$)/;\nexport const labelRegexp = /\\b(\\w+)(!?=~?)(\"[^\"\\n]*?\")/g;\nexport function parseSelector(query: string, cursorOffset = 1): { labelKeys: any[]; selector: string } {\n  if (!query.match(selectorRegexp)) {\n    // Special matcher for metrics\n    if (query.match(/^[A-Za-z:][\\w:]*$/)) {\n      return {\n        selector: `{__name__=\"${query}\"}`,\n        labelKeys: ['__name__'],\n      };\n    }\n    throw new Error('Query must contain a selector: ' + query);\n  }\n\n  // Check if inside a selector\n  const prefix = query.slice(0, cursorOffset);\n  const prefixOpen = prefix.lastIndexOf('{');\n  const prefixClose = prefix.lastIndexOf('}');\n  if (prefixOpen === -1) {\n    throw new Error('Not inside selector, missing open brace: ' + prefix);\n  }\n  if (prefixClose > -1 && prefixClose > prefixOpen) {\n    throw new Error('Not inside selector, previous selector already closed: ' + prefix);\n  }\n  const suffix = query.slice(cursorOffset);\n  const suffixCloseIndex = suffix.indexOf('}');\n  const suffixClose = suffixCloseIndex + cursorOffset;\n  const suffixOpenIndex = suffix.indexOf('{');\n  const suffixOpen = suffixOpenIndex + cursorOffset;\n  if (suffixClose === -1) {\n    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);\n  }\n  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {\n    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);\n  }\n\n  // Extract clean labels to form clean selector, incomplete labels are dropped\n  const selector = query.slice(prefixOpen, suffixClose);\n  const labels: { [key: string]: { value: string; operator: string } } = {};\n  selector.replace(labelRegexp, (label, key, operator, value) => {\n    const labelOffset = query.indexOf(label);\n    const valueStart = labelOffset + key.length + operator.length + 1;\n    const valueEnd = labelOffset + key.length + operator.length + value.length - 1;\n    // Skip label if cursor is in value\n    if (cursorOffset < valueStart || cursorOffset > valueEnd) {\n      labels[key] = { value, operator };\n    }\n    return '';\n  });\n\n  // Add metric if there is one before the selector\n  const metricPrefix = query.slice(0, prefixOpen);\n  const metricMatch = metricPrefix.match(/[A-Za-z:][\\w:]*$/);\n  if (metricMatch) {\n    labels['__name__'] = { value: `\"${metricMatch[0]}\"`, operator: '=' };\n  }\n\n  // Build sorted selector\n  const labelKeys = Object.keys(labels).sort();\n  const cleanSelector = labelKeys.map((key) => `${key}${labels[key].operator}${labels[key].value}`).join(',');\n\n  const selectorString = ['{', cleanSelector, '}'].join('');\n\n  return { labelKeys, selector: selectorString };\n}\n\nexport function expandRecordingRules(query: string, mapping: { [name: string]: string }): string {\n  const ruleNames = Object.keys(mapping);\n  const rulesRegex = new RegExp(`(\\\\s|^)(${ruleNames.join('|')})(\\\\s|$|\\\\(|\\\\[|\\\\{)`, 'ig');\n  const expandedQuery = query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`);\n\n  // Split query into array, so if query uses operators, we can correctly add labels to each individual part.\n  const queryArray = expandedQuery.split(/(\\+|\\-|\\*|\\/|\\%|\\^)/);\n\n  // Regex that matches occurrences of ){ or }{ or ]{ which is a sign of incorrecly added labels.\n  const invalidLabelsRegex = /(\\)\\{|\\}\\{|\\]\\{)/;\n  const correctlyExpandedQueryArray = queryArray.map((query) => {\n    return addLabelsToExpression(query, invalidLabelsRegex);\n  });\n\n  return correctlyExpandedQueryArray.join('');\n}\n\nfunction addLabelsToExpression(expr: string, invalidLabelsRegexp: RegExp) {\n  const match = expr.match(invalidLabelsRegexp);\n  if (!match) {\n    return expr;\n  }\n\n  // Split query into 2 parts - before the invalidLabelsRegex match and after.\n  const indexOfRegexMatch = match.index ?? 0;\n  const exprBeforeRegexMatch = expr.slice(0, indexOfRegexMatch + 1);\n  const exprAfterRegexMatch = expr.slice(indexOfRegexMatch + 1);\n\n  // Create arrayOfLabelObjects with label objects that have key, operator and value.\n  const arrayOfLabelObjects: Array<{ key: string; operator: string; value: string }> = [];\n  exprAfterRegexMatch.replace(labelRegexp, (label, key, operator, value) => {\n    arrayOfLabelObjects.push({ key, operator, value });\n    return '';\n  });\n\n  // Loop through all label objects and add them to query.\n  // As a starting point we have valid query without the labels.\n  let result = exprBeforeRegexMatch;\n  arrayOfLabelObjects.filter(Boolean).forEach((obj) => {\n    // Remove extra set of quotes from obj.value\n    const value = obj.value.slice(1, -1);\n    result = addLabelToQuery(result, obj.key, value, obj.operator);\n  });\n\n  return result;\n}\n\n/**\n * Adds metadata for synthetic metrics for which the API does not provide metadata.\n * See https://github.com/grafana/grafana/issues/22337 for details.\n *\n * @param metadata HELP and TYPE metadata from /api/v1/metadata\n */\nexport function fixSummariesMetadata(metadata: { [metric: string]: PromMetricsMetadataItem[] }): PromMetricsMetadata {\n  if (!metadata) {\n    return metadata;\n  }\n  const baseMetadata: PromMetricsMetadata = {};\n  const summaryMetadata: PromMetricsMetadata = {};\n  for (const metric in metadata) {\n    // NOTE: based on prometheus-documentation, we can receive\n    // multiple metadata-entries for the given metric, it seems\n    // it happens when the same metric is on multiple targets\n    // and their help-text differs\n    // (https://prometheus.io/docs/prometheus/latest/querying/api/#querying-metric-metadata)\n    // for now we just use the first entry.\n    const item = metadata[metric][0];\n    baseMetadata[metric] = item;\n\n    if (item.type === 'histogram') {\n      summaryMetadata[`${metric}_bucket`] = {\n        type: 'counter',\n        help: `Cumulative counters for the observation buckets (${item.help})`,\n      };\n      summaryMetadata[`${metric}_count`] = {\n        type: 'counter',\n        help: `Count of events that have been observed for the histogram metric (${item.help})`,\n      };\n      summaryMetadata[`${metric}_sum`] = {\n        type: 'counter',\n        help: `Total sum of all observed values for the histogram metric (${item.help})`,\n      };\n    }\n    if (item.type === 'summary') {\n      summaryMetadata[`${metric}_count`] = {\n        type: 'counter',\n        help: `Count of events that have been observed for the base metric (${item.help})`,\n      };\n      summaryMetadata[`${metric}_sum`] = {\n        type: 'counter',\n        help: `Total sum of all observed values for the base metric (${item.help})`,\n      };\n    }\n  }\n  // Synthetic series\n  const syntheticMetadata: PromMetricsMetadata = {};\n  syntheticMetadata['ALERTS'] = {\n    type: 'counter',\n    help: 'Time series showing pending and firing alerts. The sample value is set to 1 as long as the alert is in the indicated active (pending or firing) state.',\n  };\n\n  return { ...baseMetadata, ...summaryMetadata, ...syntheticMetadata };\n}\n\nexport function roundMsToMin(milliseconds: number): number {\n  return roundSecToMin(milliseconds / 1000);\n}\n\nexport function roundSecToMin(seconds: number): number {\n  return Math.floor(seconds / 60);\n}\n\nexport function limitSuggestions(items: string[]) {\n  return items.slice(0, SUGGESTIONS_LIMIT);\n}\n\nexport function addLimitInfo(items: any[] | undefined): string {\n  return items && items.length >= SUGGESTIONS_LIMIT ? `, limited to the first ${SUGGESTIONS_LIMIT} received items` : '';\n}\n\n// NOTE: the following 2 exported functions are very similar to the prometheus*Escape\n// functions in datasource.ts, but they are not exactly the same algorithm, and we found\n// no way to reuse one in the another or vice versa.\n\n// Prometheus regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),\n// so every character that matches something in that list has to be escaped.\n// the list of metacharacters is: *+?()|\\.[]{}^$\n// we make a javascript regular expression that matches those characters:\nconst RE2_METACHARACTERS = /[*+?()|\\\\.\\[\\]{}^$]/g;\nfunction escapePrometheusRegexp(value: string): string {\n  return value.replace(RE2_METACHARACTERS, '\\\\$&');\n}\n\n// based on the openmetrics-documentation, the 3 symbols we have to handle are:\n// - \\n ... the newline character\n// - \\  ... the backslash character\n// - \"  ... the double-quote character\nexport function escapeLabelValueInExactSelector(labelValue: string): string {\n  return labelValue.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n').replace(/\"/g, '\\\\\"');\n}\n\nexport function escapeLabelValueInRegexSelector(labelValue: string): string {\n  return escapeLabelValueInExactSelector(escapePrometheusRegexp(labelValue));\n}\n\nconst FromPromLikeMap: Record<string, AbstractLabelOperator> = {\n  '=': AbstractLabelOperator.Equal,\n  '!=': AbstractLabelOperator.NotEqual,\n  '=~': AbstractLabelOperator.EqualRegEx,\n  '!~': AbstractLabelOperator.NotEqualRegEx,\n};\nconst ToPromLikeMap: Record<AbstractLabelOperator, string> = invert(FromPromLikeMap) as Record<\n  AbstractLabelOperator,\n  string\n>;\n\nexport function toPromLikeExpr(labelBasedQuery: AbstractQuery): string {\n  const expr = labelBasedQuery.labelMatchers\n    .map((selector: AbstractLabelMatcher) => {\n      const operator = ToPromLikeMap[selector.operator];\n      if (operator) {\n        return `${selector.name}${operator}\"${selector.value}\"`;\n      } else {\n        return '';\n      }\n    })\n    .filter((e: string) => e !== '')\n    .join(', ');\n\n  return expr ? `{${expr}}` : '';\n}\n\nexport function toPromLikeQuery(labelBasedQuery: AbstractQuery): PromLikeQuery {\n  return {\n    refId: labelBasedQuery.refId,\n    expr: toPromLikeExpr(labelBasedQuery),\n    range: true,\n  };\n}\n\nexport interface PromLikeQuery extends DataQuery {\n  expr: string;\n  range: boolean;\n}\n\nexport function extractLabelMatchers(tokens: Array<string | Token>): AbstractLabelMatcher[] {\n  const labelMatchers: AbstractLabelMatcher[] = [];\n\n  for (let prop in tokens) {\n    if (tokens[prop] instanceof Token) {\n      let token: Token = tokens[prop] as Token;\n      if (token.type === 'context-labels') {\n        let labelKey = '';\n        let labelValue = '';\n        let labelOperator = '';\n        let contentTokens: any[] = token.content as any[];\n        for (let currentToken in contentTokens) {\n          if (typeof contentTokens[currentToken] === 'string') {\n            let currentStr: string;\n            currentStr = contentTokens[currentToken] as string;\n            if (currentStr === '=' || currentStr === '!=' || currentStr === '=~' || currentStr === '!~') {\n              labelOperator = currentStr;\n            }\n          } else if (contentTokens[currentToken] instanceof Token) {\n            switch (contentTokens[currentToken].type) {\n              case 'label-key':\n                labelKey = contentTokens[currentToken].content as string;\n                break;\n              case 'label-value':\n                labelValue = contentTokens[currentToken].content as string;\n                labelValue = labelValue.substring(1, labelValue.length - 1);\n                const labelComparator = FromPromLikeMap[labelOperator];\n                if (labelComparator) {\n                  labelMatchers.push({ name: labelKey, operator: labelComparator, value: labelValue });\n                }\n                break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return labelMatchers;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}