{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { guessFieldTypeForField } from '../../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../../field';\nimport { FieldType } from '../../types/dataFrame';\nimport { ArrayVector } from '../../vector/ArrayVector';\nimport { fieldReducers, reduceField, ReducerID } from '../fieldReducer';\nimport { getFieldMatcher } from '../matchers';\nimport { alwaysFieldMatcher, notTimeFieldMatcher } from '../matchers/predicates';\nimport { DataTransformerID } from './ids';\nexport let ReduceTransformerMode;\n\n(function (ReduceTransformerMode) {\n  ReduceTransformerMode[\"SeriesToRows\"] = \"seriesToRows\";\n  ReduceTransformerMode[\"ReduceFields\"] = \"reduceFields\";\n})(ReduceTransformerMode || (ReduceTransformerMode = {}));\n\nexport const reduceTransformer = {\n  id: DataTransformerID.reduce,\n  name: 'Reduce',\n  description: 'Reduce all rows or data points to a single value using a function like max, min, mean or last',\n  defaultOptions: {\n    reducers: [ReducerID.max]\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: options => source => source.pipe(map(data => {\n    var _options$reducers;\n\n    if (!(options !== null && options !== void 0 && (_options$reducers = options.reducers) !== null && _options$reducers !== void 0 && _options$reducers.length)) {\n      return data; // nothing selected\n    }\n\n    const matcher = options.fields ? getFieldMatcher(options.fields) : options.includeTimeField && options.mode === ReduceTransformerMode.ReduceFields ? alwaysFieldMatcher : notTimeFieldMatcher; // Collapse all matching fields into a single row\n\n    if (options.mode === ReduceTransformerMode.ReduceFields) {\n      return reduceFields(data, matcher, options.reducers);\n    } // Add a row for each series\n\n\n    const res = reduceSeriesToRows(data, matcher, options.reducers, options.labelsToFields);\n    return res ? [res] : [];\n  }))\n};\n/**\n * @internal only exported for testing\n */\n\nexport function reduceSeriesToRows(data, matcher, reducerId, labelsToFields) {\n  const calculators = fieldReducers.list(reducerId);\n  const reducers = calculators.map(c => c.id);\n  const processed = [];\n  const distinctLabels = labelsToFields ? getDistinctLabelKeys(data) : [];\n\n  for (const series of data) {\n    const source = series.fields.filter(f => matcher(f, series, data));\n    const size = source.length;\n    const fields = [];\n    const names = new ArrayVector(new Array(size));\n    fields.push({\n      name: 'Field',\n      type: FieldType.string,\n      values: names,\n      config: {}\n    });\n    const labels = {};\n\n    if (labelsToFields) {\n      for (const key of distinctLabels) {\n        labels[key] = new ArrayVector(new Array(size));\n        fields.push({\n          name: key,\n          type: FieldType.string,\n          values: labels[key],\n          config: {}\n        });\n      }\n    }\n\n    const calcs = {};\n\n    for (const info of calculators) {\n      calcs[info.id] = new ArrayVector(new Array(size));\n      fields.push({\n        name: info.name,\n        type: FieldType.other,\n        // UNKNOWN until after we call the functions\n        values: calcs[info.id],\n        config: {}\n      });\n    }\n\n    for (let i = 0; i < source.length; i++) {\n      const field = source[i];\n      const results = reduceField({\n        field,\n        reducers\n      });\n\n      if (labelsToFields) {\n        names.buffer[i] = field.name;\n\n        if (field.labels) {\n          for (const key of Object.keys(field.labels)) {\n            labels[key].set(i, field.labels[key]);\n          }\n        }\n      } else {\n        names.buffer[i] = getFieldDisplayName(field, series, data);\n      }\n\n      for (const info of calculators) {\n        const v = results[info.id];\n        calcs[info.id].buffer[i] = v;\n      }\n    } // For reduced fields, we don't know the type until we see the value\n\n\n    for (const f of fields) {\n      if (f.type === FieldType.other) {\n        const t = guessFieldTypeForField(f);\n\n        if (t) {\n          f.type = t;\n        }\n      }\n    }\n\n    processed.push(Object.assign({}, series, {\n      // Same properties, different fields\n      fields,\n      length: size\n    }));\n  }\n\n  return mergeResults(processed);\n}\nexport function getDistinctLabelKeys(frames) {\n  const keys = new Set();\n\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.labels) {\n        for (const k of Object.keys(field.labels)) {\n          keys.add(k);\n        }\n      }\n    }\n  }\n\n  return [...keys];\n}\n/**\n * @internal only exported for testing\n */\n\nexport function mergeResults(data) {\n  if (!(data !== null && data !== void 0 && data.length)) {\n    return undefined;\n  }\n\n  const baseFrame = data[0];\n\n  for (let seriesIndex = 1; seriesIndex < data.length; seriesIndex++) {\n    const series = data[seriesIndex];\n\n    for (let baseIndex = 0; baseIndex < baseFrame.fields.length; baseIndex++) {\n      const baseField = baseFrame.fields[baseIndex];\n\n      for (let fieldIndex = 0; fieldIndex < series.fields.length; fieldIndex++) {\n        const field = series.fields[fieldIndex];\n        const isFirstField = baseIndex === 0 && fieldIndex === 0;\n        const isSameField = baseField.type === field.type && baseField.name === field.name;\n\n        if (isFirstField || isSameField) {\n          const baseValues = baseField.values.toArray();\n          const values = field.values.toArray();\n          baseField.values.buffer = baseValues.concat(values);\n        }\n      }\n    }\n  }\n\n  baseFrame.name = undefined;\n  baseFrame.length = baseFrame.fields[0].values.length;\n  return baseFrame;\n}\n/**\n * @internal -- only exported for testing\n */\n\nexport function reduceFields(data, matcher, reducerId) {\n  const calculators = fieldReducers.list(reducerId);\n  const reducers = calculators.map(c => c.id);\n  const processed = [];\n\n  for (const series of data) {\n    const fields = [];\n\n    for (const field of series.fields) {\n      if (matcher(field, series, data)) {\n        const results = reduceField({\n          field,\n          reducers\n        });\n\n        for (const reducer of reducers) {\n          const value = results[reducer];\n          const copy = Object.assign({}, field, {\n            values: new ArrayVector([value])\n          });\n          copy.state = undefined;\n\n          if (reducers.length > 1) {\n            if (!copy.labels) {\n              copy.labels = {};\n            }\n\n            copy.labels['reducer'] = fieldReducers.get(reducer).name;\n          }\n\n          fields.push(copy);\n        }\n      }\n    }\n\n    if (fields.length) {\n      processed.push(Object.assign({}, series, {\n        fields,\n        length: 1 // always one row\n\n      }));\n    }\n  }\n\n  return processed;\n}","map":{"version":3,"names":["map","guessFieldTypeForField","getFieldDisplayName","FieldType","ArrayVector","fieldReducers","reduceField","ReducerID","getFieldMatcher","alwaysFieldMatcher","notTimeFieldMatcher","DataTransformerID","ReduceTransformerMode","reduceTransformer","id","reduce","name","description","defaultOptions","reducers","max","operator","options","source","pipe","data","length","matcher","fields","includeTimeField","mode","ReduceFields","reduceFields","res","reduceSeriesToRows","labelsToFields","reducerId","calculators","list","c","processed","distinctLabels","getDistinctLabelKeys","series","filter","f","size","names","Array","push","type","string","values","config","labels","key","calcs","info","other","i","field","results","buffer","Object","keys","set","v","t","mergeResults","frames","Set","frame","k","add","undefined","baseFrame","seriesIndex","baseIndex","baseField","fieldIndex","isFirstField","isSameField","baseValues","toArray","concat","reducer","value","copy","state","get"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/reduce.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { guessFieldTypeForField } from '../../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../../field';\nimport { KeyValue } from '../../types/data';\nimport { DataFrame, Field, FieldType } from '../../types/dataFrame';\nimport { DataTransformerInfo, FieldMatcher, MatcherConfig } from '../../types/transformations';\nimport { ArrayVector } from '../../vector/ArrayVector';\nimport { fieldReducers, reduceField, ReducerID } from '../fieldReducer';\nimport { getFieldMatcher } from '../matchers';\nimport { alwaysFieldMatcher, notTimeFieldMatcher } from '../matchers/predicates';\n\nimport { DataTransformerID } from './ids';\n\nexport enum ReduceTransformerMode {\n  SeriesToRows = 'seriesToRows', // default\n  ReduceFields = 'reduceFields', // same structure, add additional row for each type\n}\nexport interface ReduceTransformerOptions {\n  reducers: ReducerID[];\n  fields?: MatcherConfig; // Assume all fields\n  mode?: ReduceTransformerMode;\n  includeTimeField?: boolean;\n  labelsToFields?: boolean;\n}\n\nexport const reduceTransformer: DataTransformerInfo<ReduceTransformerOptions> = {\n  id: DataTransformerID.reduce,\n  name: 'Reduce',\n  description: 'Reduce all rows or data points to a single value using a function like max, min, mean or last',\n  defaultOptions: {\n    reducers: [ReducerID.max],\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        if (!options?.reducers?.length) {\n          return data; // nothing selected\n        }\n\n        const matcher = options.fields\n          ? getFieldMatcher(options.fields)\n          : options.includeTimeField && options.mode === ReduceTransformerMode.ReduceFields\n          ? alwaysFieldMatcher\n          : notTimeFieldMatcher;\n\n        // Collapse all matching fields into a single row\n        if (options.mode === ReduceTransformerMode.ReduceFields) {\n          return reduceFields(data, matcher, options.reducers);\n        }\n\n        // Add a row for each series\n        const res = reduceSeriesToRows(data, matcher, options.reducers, options.labelsToFields);\n        return res ? [res] : [];\n      })\n    ),\n};\n\n/**\n * @internal only exported for testing\n */\nexport function reduceSeriesToRows(\n  data: DataFrame[],\n  matcher: FieldMatcher,\n  reducerId: ReducerID[],\n  labelsToFields?: boolean\n): DataFrame | undefined {\n  const calculators = fieldReducers.list(reducerId);\n  const reducers = calculators.map((c) => c.id);\n  const processed: DataFrame[] = [];\n  const distinctLabels = labelsToFields ? getDistinctLabelKeys(data) : [];\n\n  for (const series of data) {\n    const source = series.fields.filter((f) => matcher(f, series, data));\n\n    const size = source.length;\n    const fields: Field[] = [];\n    const names = new ArrayVector<string>(new Array(size));\n    fields.push({\n      name: 'Field',\n      type: FieldType.string,\n      values: names,\n      config: {},\n    });\n\n    const labels: KeyValue<ArrayVector> = {};\n    if (labelsToFields) {\n      for (const key of distinctLabels) {\n        labels[key] = new ArrayVector<string>(new Array(size));\n        fields.push({\n          name: key,\n          type: FieldType.string,\n          values: labels[key],\n          config: {},\n        });\n      }\n    }\n\n    const calcs: KeyValue<ArrayVector> = {};\n    for (const info of calculators) {\n      calcs[info.id] = new ArrayVector(new Array(size));\n      fields.push({\n        name: info.name,\n        type: FieldType.other, // UNKNOWN until after we call the functions\n        values: calcs[info.id],\n        config: {},\n      });\n    }\n\n    for (let i = 0; i < source.length; i++) {\n      const field = source[i];\n      const results = reduceField({\n        field,\n        reducers,\n      });\n\n      if (labelsToFields) {\n        names.buffer[i] = field.name;\n        if (field.labels) {\n          for (const key of Object.keys(field.labels)) {\n            labels[key].set(i, field.labels[key]);\n          }\n        }\n      } else {\n        names.buffer[i] = getFieldDisplayName(field, series, data);\n      }\n\n      for (const info of calculators) {\n        const v = results[info.id];\n        calcs[info.id].buffer[i] = v;\n      }\n    }\n\n    // For reduced fields, we don't know the type until we see the value\n    for (const f of fields) {\n      if (f.type === FieldType.other) {\n        const t = guessFieldTypeForField(f);\n        if (t) {\n          f.type = t;\n        }\n      }\n    }\n\n    processed.push({\n      ...series, // Same properties, different fields\n      fields,\n      length: size,\n    });\n  }\n\n  return mergeResults(processed);\n}\n\nexport function getDistinctLabelKeys(frames: DataFrame[]): string[] {\n  const keys = new Set<string>();\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.labels) {\n        for (const k of Object.keys(field.labels)) {\n          keys.add(k);\n        }\n      }\n    }\n  }\n  return [...keys];\n}\n\n/**\n * @internal only exported for testing\n */\nexport function mergeResults(data: DataFrame[]): DataFrame | undefined {\n  if (!data?.length) {\n    return undefined;\n  }\n\n  const baseFrame = data[0];\n\n  for (let seriesIndex = 1; seriesIndex < data.length; seriesIndex++) {\n    const series = data[seriesIndex];\n\n    for (let baseIndex = 0; baseIndex < baseFrame.fields.length; baseIndex++) {\n      const baseField = baseFrame.fields[baseIndex];\n      for (let fieldIndex = 0; fieldIndex < series.fields.length; fieldIndex++) {\n        const field = series.fields[fieldIndex];\n        const isFirstField = baseIndex === 0 && fieldIndex === 0;\n        const isSameField = baseField.type === field.type && baseField.name === field.name;\n\n        if (isFirstField || isSameField) {\n          const baseValues: any[] = baseField.values.toArray();\n          const values: any[] = field.values.toArray();\n          (baseField.values as unknown as ArrayVector).buffer = baseValues.concat(values);\n        }\n      }\n    }\n  }\n\n  baseFrame.name = undefined;\n  baseFrame.length = baseFrame.fields[0].values.length;\n  return baseFrame;\n}\n\n/**\n * @internal -- only exported for testing\n */\nexport function reduceFields(data: DataFrame[], matcher: FieldMatcher, reducerId: ReducerID[]): DataFrame[] {\n  const calculators = fieldReducers.list(reducerId);\n  const reducers = calculators.map((c) => c.id);\n  const processed: DataFrame[] = [];\n\n  for (const series of data) {\n    const fields: Field[] = [];\n    for (const field of series.fields) {\n      if (matcher(field, series, data)) {\n        const results = reduceField({\n          field,\n          reducers,\n        });\n        for (const reducer of reducers) {\n          const value = results[reducer];\n          const copy = {\n            ...field,\n            values: new ArrayVector([value]),\n          };\n          copy.state = undefined;\n          if (reducers.length > 1) {\n            if (!copy.labels) {\n              copy.labels = {};\n            }\n            copy.labels['reducer'] = fieldReducers.get(reducer).name;\n          }\n          fields.push(copy);\n        }\n      }\n    }\n    if (fields.length) {\n      processed.push({\n        ...series,\n        fields,\n        length: 1, // always one row\n      });\n    }\n  }\n\n  return processed;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}