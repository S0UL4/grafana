{"ast":null,"code":"const _excluded = [\"key\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { flatten, omit, uniq } from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport { CoreApp, dateMath, DefaultTimeZone, isDateTime, LogsDedupStrategy, LogsSortOrder, rangeUtil, toUtc, urlUtil } from '@grafana/data';\nimport { RefreshPicker } from '@grafana/ui';\nimport store from 'app/core/store';\nimport { EXPLORE_GRAPH_STYLES } from 'app/types/explore';\nimport { config } from '../config';\nimport { getNextRefIdChar } from './query';\nexport const DEFAULT_RANGE = {\n  from: 'now-1h',\n  to: 'now'\n};\nexport const DEFAULT_UI_STATE = {\n  dedupStrategy: LogsDedupStrategy.none\n};\nconst MAX_HISTORY_ITEMS = 100;\nexport const LAST_USED_DATASOURCE_KEY = 'grafana.explore.datasource';\nexport const lastUsedDatasourceKeyForOrgId = orgId => `${LAST_USED_DATASOURCE_KEY}.${orgId}`;\n\n/**\n * Returns an Explore-URL that contains a panel's queries and the dashboard time range.\n */\nexport async function getExploreUrl(args) {\n  var _exploreDatasource$me;\n\n  const {\n    panel,\n    datasourceSrv,\n    timeSrv\n  } = args;\n  let exploreDatasource = await datasourceSrv.get(panel.datasource);\n  /** In Explore, we don't have legend formatter and we don't want to keep\n   * legend formatting as we can't change it\n   */\n\n  let exploreTargets = panel.targets.map(t => omit(t, 'legendFormat'));\n  let url; // Mixed datasources need to choose only one datasource\n\n  if (((_exploreDatasource$me = exploreDatasource.meta) === null || _exploreDatasource$me === void 0 ? void 0 : _exploreDatasource$me.id) === 'mixed' && exploreTargets) {\n    // Find first explore datasource among targets\n    for (const t of exploreTargets) {\n      const datasource = await datasourceSrv.get(t.datasource || undefined);\n\n      if (datasource) {\n        exploreDatasource = datasource;\n        exploreTargets = panel.targets.filter(t => t.datasource === datasource.name);\n        break;\n      }\n    }\n  }\n\n  if (exploreDatasource) {\n    const range = timeSrv.timeRangeForUrl();\n    let state = {\n      range\n    };\n\n    if (exploreDatasource.interpolateVariablesInQueries) {\n      const scopedVars = panel.scopedVars || {};\n      state = Object.assign({}, state, {\n        datasource: exploreDatasource.name,\n        context: 'explore',\n        queries: exploreDatasource.interpolateVariablesInQueries(exploreTargets, scopedVars)\n      });\n    } else {\n      state = Object.assign({}, state, {\n        datasource: exploreDatasource.name,\n        context: 'explore',\n        queries: exploreTargets.map(t => Object.assign({}, t, {\n          datasource: exploreDatasource.getRef()\n        }))\n      });\n    }\n\n    const exploreState = JSON.stringify(state);\n    url = urlUtil.renderUrl('/explore', {\n      left: exploreState\n    });\n  }\n\n  return url;\n}\nexport function buildQueryTransaction(exploreId, queries, queryOptions, range, scanning, timeZone) {\n  const key = queries.reduce((combinedKey, query) => {\n    combinedKey += query.key;\n    return combinedKey;\n  }, '');\n  const {\n    interval,\n    intervalMs\n  } = getIntervals(range, queryOptions.minInterval, queryOptions.maxDataPoints); // Most datasource is using `panelId + query.refId` for cancellation logic.\n  // Using `format` here because it relates to the view panel that the request is for.\n  // However, some datasources don't use `panelId + query.refId`, but only `panelId`.\n  // Therefore panel id has to be unique.\n\n  const panelId = `${key}`;\n  const request = {\n    app: CoreApp.Explore,\n    dashboardId: 0,\n    // TODO probably should be taken from preferences but does not seem to be used anyway.\n    timezone: timeZone || DefaultTimeZone,\n    startTime: Date.now(),\n    interval,\n    intervalMs,\n    // TODO: the query request expects number and we are using string here. Seems like it works so far but can create\n    // issues down the road.\n    panelId: panelId,\n    targets: queries,\n    // Datasources rely on DataQueries being passed under the targets key.\n    range,\n    requestId: 'explore_' + exploreId,\n    rangeRaw: range.raw,\n    scopedVars: {\n      __interval: {\n        text: interval,\n        value: interval\n      },\n      __interval_ms: {\n        text: intervalMs,\n        value: intervalMs\n      }\n    },\n    maxDataPoints: queryOptions.maxDataPoints,\n    liveStreaming: queryOptions.liveStreaming\n  };\n  return {\n    queries,\n    request,\n    scanning,\n    id: generateKey(),\n    // reusing for unique ID\n    done: false\n  };\n}\nexport const clearQueryKeys = _ref => {\n  let rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  return rest;\n};\n\nconst isSegment = (segment, ...props) => props.some(prop => segment.hasOwnProperty(prop));\n\nvar ParseUrlStateIndex;\n\n(function (ParseUrlStateIndex) {\n  ParseUrlStateIndex[ParseUrlStateIndex[\"RangeFrom\"] = 0] = \"RangeFrom\";\n  ParseUrlStateIndex[ParseUrlStateIndex[\"RangeTo\"] = 1] = \"RangeTo\";\n  ParseUrlStateIndex[ParseUrlStateIndex[\"Datasource\"] = 2] = \"Datasource\";\n  ParseUrlStateIndex[ParseUrlStateIndex[\"SegmentsStart\"] = 3] = \"SegmentsStart\";\n})(ParseUrlStateIndex || (ParseUrlStateIndex = {}));\n\nexport const safeParseJson = text => {\n  if (!text) {\n    return;\n  }\n\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    console.error(error);\n  }\n};\nexport const safeStringifyValue = (value, space) => {\n  if (!value) {\n    return '';\n  }\n\n  try {\n    return JSON.stringify(value, null, space);\n  } catch (error) {\n    console.error(error);\n  }\n\n  return '';\n};\nconst DEFAULT_GRAPH_STYLE = 'lines'; // we use this function to take any kind of data we loaded\n// from an external source (URL, localStorage, whatever),\n// and extract the graph-style from it, or return the default\n// graph-style if we are not able to do that.\n// it is important that this function is able to take any form of data,\n// (be it objects, or arrays, or booleans or whatever),\n// and produce a best-effort graphStyle.\n// note that typescript makes sure we make no mistake in this function.\n// we do not rely on ` as ` or ` any `.\n\nexport const toGraphStyle = data => {\n  const found = EXPLORE_GRAPH_STYLES.find(v => v === data);\n  return found !== null && found !== void 0 ? found : DEFAULT_GRAPH_STYLE;\n};\nexport function parseUrlState(initial) {\n  var _parsedSegments$find;\n\n  const parsed = safeParseJson(initial);\n  const errorResult = {\n    datasource: null,\n    queries: [],\n    range: DEFAULT_RANGE,\n    mode: null\n  };\n\n  if (!parsed) {\n    return errorResult;\n  }\n\n  if (!Array.isArray(parsed)) {\n    return parsed;\n  }\n\n  if (parsed.length <= ParseUrlStateIndex.SegmentsStart) {\n    console.error('Error parsing compact URL state for Explore.');\n    return errorResult;\n  }\n\n  const range = {\n    from: parsed[ParseUrlStateIndex.RangeFrom],\n    to: parsed[ParseUrlStateIndex.RangeTo]\n  };\n  const datasource = parsed[ParseUrlStateIndex.Datasource];\n  const parsedSegments = parsed.slice(ParseUrlStateIndex.SegmentsStart);\n  const queries = parsedSegments.filter(segment => !isSegment(segment, 'ui', 'mode', '__panelsState'));\n  const panelsState = (_parsedSegments$find = parsedSegments.find(segment => isSegment(segment, '__panelsState'))) === null || _parsedSegments$find === void 0 ? void 0 : _parsedSegments$find.__panelsState;\n  return {\n    datasource,\n    queries,\n    range,\n    panelsState\n  };\n}\nexport function generateKey(index = 0) {\n  return `Q-${uuidv4()}-${index}`;\n}\nexport function generateEmptyQuery(queries, index = 0) {\n  return {\n    refId: getNextRefIdChar(queries),\n    key: generateKey(index)\n  };\n}\nexport const generateNewKeyAndAddRefIdIfMissing = (target, queries, index = 0) => {\n  const key = generateKey(index);\n  const refId = target.refId || getNextRefIdChar(queries);\n  return Object.assign({}, target, {\n    refId,\n    key\n  });\n};\n/**\n * Ensure at least one target exists and that targets have the necessary keys\n */\n\nexport function ensureQueries(queries) {\n  if (queries && typeof queries === 'object' && queries.length > 0) {\n    const allQueries = [];\n\n    for (let index = 0; index < queries.length; index++) {\n      const query = queries[index];\n      const key = generateKey(index);\n      let refId = query.refId;\n\n      if (!refId) {\n        refId = getNextRefIdChar(allQueries);\n      }\n\n      allQueries.push(Object.assign({}, query, {\n        refId,\n        key\n      }));\n    }\n\n    return allQueries;\n  }\n\n  return [Object.assign({}, generateEmptyQuery(queries !== null && queries !== void 0 ? queries : []))];\n}\n/**\n * A target is non-empty when it has keys (with non-empty values) other than refId, key, context and datasource.\n * FIXME: While this is reasonable for practical use cases, a query without any propery might still be \"non-empty\"\n * in its own scope, for instance when there's no user input needed. This might be the case for an hypothetic datasource in\n * which query options are only set in its config and the query object itself, as generated from its query editor it's always \"empty\"\n */\n\nconst validKeys = ['refId', 'key', 'context', 'datasource'];\nexport function hasNonEmptyQuery(queries) {\n  return queries && queries.some(query => {\n    const keys = Object.keys(query).filter(key => validKeys.indexOf(key) === -1).map(k => query[k]).filter(v => v);\n    return keys.length > 0;\n  });\n}\n/**\n * Update the query history. Side-effect: store history in local storage\n */\n\nexport function updateHistory(history, datasourceId, queries) {\n  const ts = Date.now();\n  let updatedHistory = history;\n  queries.forEach(query => {\n    updatedHistory = [{\n      query,\n      ts\n    }, ...updatedHistory];\n  });\n\n  if (updatedHistory.length > MAX_HISTORY_ITEMS) {\n    updatedHistory = updatedHistory.slice(0, MAX_HISTORY_ITEMS);\n  } // Combine all queries of a datasource type into one history\n\n\n  const historyKey = `grafana.explore.history.${datasourceId}`;\n\n  try {\n    store.setObject(historyKey, updatedHistory);\n    return updatedHistory;\n  } catch (error) {\n    console.error(error);\n    return history;\n  }\n}\nexport function clearHistory(datasourceId) {\n  const historyKey = `grafana.explore.history.${datasourceId}`;\n  store.delete(historyKey);\n}\nexport const getQueryKeys = (queries, datasourceInstance) => {\n  const queryKeys = queries.reduce((newQueryKeys, query, index) => {\n    const primaryKey = datasourceInstance && datasourceInstance.name ? datasourceInstance.name : query.key;\n    return newQueryKeys.concat(`${primaryKey}-${index}`);\n  }, []);\n  return queryKeys;\n};\nexport const getTimeRange = (timeZone, rawRange, fiscalYearStartMonth) => {\n  let range = rangeUtil.convertRawToRange(rawRange, timeZone, fiscalYearStartMonth);\n\n  if (range.to.isBefore(range.from)) {\n    range = rangeUtil.convertRawToRange({\n      from: range.raw.to,\n      to: range.raw.from\n    }, timeZone, fiscalYearStartMonth);\n  }\n\n  return range;\n};\n\nconst parseRawTime = value => {\n  if (value === null) {\n    return null;\n  }\n\n  if (isDateTime(value)) {\n    return value;\n  }\n\n  if (value.indexOf('now') !== -1) {\n    return value;\n  }\n\n  if (value.length === 8) {\n    return toUtc(value, 'YYYYMMDD');\n  }\n\n  if (value.length === 15) {\n    return toUtc(value, 'YYYYMMDDTHHmmss');\n  } // Backward compatibility\n\n\n  if (value.length === 19) {\n    return toUtc(value, 'YYYY-MM-DD HH:mm:ss');\n  } // This should handle cases where value is an epoch time as string\n\n\n  if (value.match(/^\\d+$/)) {\n    const epoch = parseInt(value, 10);\n    return toUtc(epoch);\n  } // This should handle ISO strings\n\n\n  const time = toUtc(value);\n\n  if (time.isValid()) {\n    return time;\n  }\n\n  return null;\n};\n\nexport const getTimeRangeFromUrl = (range, timeZone, fiscalYearStartMonth) => {\n  const raw = {\n    from: parseRawTime(range.from),\n    to: parseRawTime(range.to)\n  };\n  return {\n    from: dateMath.parse(raw.from, false, timeZone),\n    to: dateMath.parse(raw.to, true, timeZone),\n    raw\n  };\n};\nexport const getValueWithRefId = value => {\n  if (!value || typeof value !== 'object') {\n    return undefined;\n  }\n\n  if (value.refId) {\n    return value;\n  }\n\n  const keys = Object.keys(value);\n\n  for (let index = 0; index < keys.length; index++) {\n    const key = keys[index];\n    const refId = getValueWithRefId(value[key]);\n\n    if (refId) {\n      return refId;\n    }\n  }\n\n  return undefined;\n};\nexport const getRefIds = value => {\n  if (!value) {\n    return [];\n  }\n\n  if (typeof value !== 'object') {\n    return [];\n  }\n\n  const keys = Object.keys(value);\n  const refIds = [];\n\n  for (let index = 0; index < keys.length; index++) {\n    const key = keys[index];\n\n    if (key === 'refId') {\n      refIds.push(value[key]);\n      continue;\n    }\n\n    refIds.push(getRefIds(value[key]));\n  }\n\n  return uniq(flatten(refIds));\n};\nexport const refreshIntervalToSortOrder = refreshInterval => RefreshPicker.isLive(refreshInterval) ? LogsSortOrder.Ascending : LogsSortOrder.Descending;\nexport const convertToWebSocketUrl = url => {\n  const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';\n  let backend = `${protocol}${window.location.host}${config.appSubUrl}`;\n\n  if (backend.endsWith('/')) {\n    backend = backend.slice(0, -1);\n  }\n\n  return `${backend}${url}`;\n};\nexport const stopQueryState = querySubscription => {\n  if (querySubscription) {\n    querySubscription.unsubscribe();\n  }\n};\nexport function getIntervals(range, lowLimit, resolution) {\n  if (!resolution) {\n    return {\n      interval: '1s',\n      intervalMs: 1000\n    };\n  }\n\n  return rangeUtil.calculateInterval(range, resolution, lowLimit);\n}\nexport const copyStringToClipboard = string => {\n  const el = document.createElement('textarea');\n  el.value = string;\n  document.body.appendChild(el);\n  el.select();\n  document.execCommand('copy');\n  document.body.removeChild(el);\n};","map":{"version":3,"names":["flatten","omit","uniq","v4","uuidv4","CoreApp","dateMath","DefaultTimeZone","isDateTime","LogsDedupStrategy","LogsSortOrder","rangeUtil","toUtc","urlUtil","RefreshPicker","store","EXPLORE_GRAPH_STYLES","config","getNextRefIdChar","DEFAULT_RANGE","from","to","DEFAULT_UI_STATE","dedupStrategy","none","MAX_HISTORY_ITEMS","LAST_USED_DATASOURCE_KEY","lastUsedDatasourceKeyForOrgId","orgId","getExploreUrl","args","panel","datasourceSrv","timeSrv","exploreDatasource","get","datasource","exploreTargets","targets","map","t","url","meta","id","undefined","filter","name","range","timeRangeForUrl","state","interpolateVariablesInQueries","scopedVars","context","queries","getRef","exploreState","JSON","stringify","renderUrl","left","buildQueryTransaction","exploreId","queryOptions","scanning","timeZone","key","reduce","combinedKey","query","interval","intervalMs","getIntervals","minInterval","maxDataPoints","panelId","request","app","Explore","dashboardId","timezone","startTime","Date","now","requestId","rangeRaw","raw","__interval","text","value","__interval_ms","liveStreaming","generateKey","done","clearQueryKeys","rest","isSegment","segment","props","some","prop","hasOwnProperty","ParseUrlStateIndex","safeParseJson","parse","error","console","safeStringifyValue","space","DEFAULT_GRAPH_STYLE","toGraphStyle","data","found","find","v","parseUrlState","initial","parsed","errorResult","mode","Array","isArray","length","SegmentsStart","RangeFrom","RangeTo","Datasource","parsedSegments","slice","panelsState","__panelsState","index","generateEmptyQuery","refId","generateNewKeyAndAddRefIdIfMissing","target","ensureQueries","allQueries","push","validKeys","hasNonEmptyQuery","keys","Object","indexOf","k","updateHistory","history","datasourceId","ts","updatedHistory","forEach","historyKey","setObject","clearHistory","delete","getQueryKeys","datasourceInstance","queryKeys","newQueryKeys","primaryKey","concat","getTimeRange","rawRange","fiscalYearStartMonth","convertRawToRange","isBefore","parseRawTime","match","epoch","parseInt","time","isValid","getTimeRangeFromUrl","getValueWithRefId","getRefIds","refIds","refreshIntervalToSortOrder","refreshInterval","isLive","Ascending","Descending","convertToWebSocketUrl","protocol","window","location","backend","host","appSubUrl","endsWith","stopQueryState","querySubscription","unsubscribe","lowLimit","resolution","calculateInterval","copyStringToClipboard","string","el","document","createElement","body","appendChild","select","execCommand","removeChild"],"sources":["/home/soula/grafana/public/app/core/utils/explore.ts"],"sourcesContent":["import { flatten, omit, uniq } from 'lodash';\nimport { Unsubscribable } from 'rxjs';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport {\n  CoreApp,\n  DataQuery,\n  DataQueryRequest,\n  DataSourceApi,\n  dateMath,\n  DateTime,\n  DefaultTimeZone,\n  ExploreUrlState,\n  HistoryItem,\n  IntervalValues,\n  isDateTime,\n  LogsDedupStrategy,\n  LogsSortOrder,\n  rangeUtil,\n  RawTimeRange,\n  TimeFragment,\n  TimeRange,\n  TimeZone,\n  toUtc,\n  urlUtil,\n} from '@grafana/data';\nimport { DataSourceSrv } from '@grafana/runtime';\nimport { RefreshPicker } from '@grafana/ui';\nimport store from 'app/core/store';\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { PanelModel } from 'app/features/dashboard/state';\nimport { EXPLORE_GRAPH_STYLES, ExploreGraphStyle, ExploreId, QueryOptions, QueryTransaction } from 'app/types/explore';\n\nimport { config } from '../config';\n\nimport { getNextRefIdChar } from './query';\n\nexport const DEFAULT_RANGE = {\n  from: 'now-1h',\n  to: 'now',\n};\n\nexport const DEFAULT_UI_STATE = {\n  dedupStrategy: LogsDedupStrategy.none,\n};\n\nconst MAX_HISTORY_ITEMS = 100;\n\nexport const LAST_USED_DATASOURCE_KEY = 'grafana.explore.datasource';\nexport const lastUsedDatasourceKeyForOrgId = (orgId: number) => `${LAST_USED_DATASOURCE_KEY}.${orgId}`;\n\nexport interface GetExploreUrlArguments {\n  panel: PanelModel;\n  /** Datasource service to query other datasources in case the panel datasource is mixed */\n  datasourceSrv: DataSourceSrv;\n  /** Time service to get the current dashboard range from */\n  timeSrv: TimeSrv;\n}\n\n/**\n * Returns an Explore-URL that contains a panel's queries and the dashboard time range.\n */\nexport async function getExploreUrl(args: GetExploreUrlArguments): Promise<string | undefined> {\n  const { panel, datasourceSrv, timeSrv } = args;\n  let exploreDatasource = await datasourceSrv.get(panel.datasource);\n\n  /** In Explore, we don't have legend formatter and we don't want to keep\n   * legend formatting as we can't change it\n   */\n  let exploreTargets: DataQuery[] = panel.targets.map((t) => omit(t, 'legendFormat'));\n  let url: string | undefined;\n\n  // Mixed datasources need to choose only one datasource\n  if (exploreDatasource.meta?.id === 'mixed' && exploreTargets) {\n    // Find first explore datasource among targets\n    for (const t of exploreTargets) {\n      const datasource = await datasourceSrv.get(t.datasource || undefined);\n      if (datasource) {\n        exploreDatasource = datasource;\n        exploreTargets = panel.targets.filter((t) => t.datasource === datasource.name);\n        break;\n      }\n    }\n  }\n\n  if (exploreDatasource) {\n    const range = timeSrv.timeRangeForUrl();\n    let state: Partial<ExploreUrlState> = { range };\n    if (exploreDatasource.interpolateVariablesInQueries) {\n      const scopedVars = panel.scopedVars || {};\n      state = {\n        ...state,\n        datasource: exploreDatasource.name,\n        context: 'explore',\n        queries: exploreDatasource.interpolateVariablesInQueries(exploreTargets, scopedVars),\n      };\n    } else {\n      state = {\n        ...state,\n        datasource: exploreDatasource.name,\n        context: 'explore',\n        queries: exploreTargets.map((t) => ({ ...t, datasource: exploreDatasource.getRef() })),\n      };\n    }\n\n    const exploreState = JSON.stringify(state);\n    url = urlUtil.renderUrl('/explore', { left: exploreState });\n  }\n\n  return url;\n}\n\nexport function buildQueryTransaction(\n  exploreId: ExploreId,\n  queries: DataQuery[],\n  queryOptions: QueryOptions,\n  range: TimeRange,\n  scanning: boolean,\n  timeZone?: TimeZone\n): QueryTransaction {\n  const key = queries.reduce((combinedKey, query) => {\n    combinedKey += query.key;\n    return combinedKey;\n  }, '');\n\n  const { interval, intervalMs } = getIntervals(range, queryOptions.minInterval, queryOptions.maxDataPoints);\n\n  // Most datasource is using `panelId + query.refId` for cancellation logic.\n  // Using `format` here because it relates to the view panel that the request is for.\n  // However, some datasources don't use `panelId + query.refId`, but only `panelId`.\n  // Therefore panel id has to be unique.\n  const panelId = `${key}`;\n\n  const request: DataQueryRequest = {\n    app: CoreApp.Explore,\n    dashboardId: 0,\n    // TODO probably should be taken from preferences but does not seem to be used anyway.\n    timezone: timeZone || DefaultTimeZone,\n    startTime: Date.now(),\n    interval,\n    intervalMs,\n    // TODO: the query request expects number and we are using string here. Seems like it works so far but can create\n    // issues down the road.\n    panelId: panelId as any,\n    targets: queries, // Datasources rely on DataQueries being passed under the targets key.\n    range,\n    requestId: 'explore_' + exploreId,\n    rangeRaw: range.raw,\n    scopedVars: {\n      __interval: { text: interval, value: interval },\n      __interval_ms: { text: intervalMs, value: intervalMs },\n    },\n    maxDataPoints: queryOptions.maxDataPoints,\n    liveStreaming: queryOptions.liveStreaming,\n  };\n\n  return {\n    queries,\n    request,\n    scanning,\n    id: generateKey(), // reusing for unique ID\n    done: false,\n  };\n}\n\nexport const clearQueryKeys: (query: DataQuery) => DataQuery = ({ key, ...rest }) => rest;\n\nconst isSegment = (segment: { [key: string]: string }, ...props: string[]) =>\n  props.some((prop) => segment.hasOwnProperty(prop));\n\nenum ParseUrlStateIndex {\n  RangeFrom = 0,\n  RangeTo = 1,\n  Datasource = 2,\n  SegmentsStart = 3,\n}\n\nexport const safeParseJson = (text?: string): any | undefined => {\n  if (!text) {\n    return;\n  }\n\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nexport const safeStringifyValue = (value: any, space?: number) => {\n  if (!value) {\n    return '';\n  }\n\n  try {\n    return JSON.stringify(value, null, space);\n  } catch (error) {\n    console.error(error);\n  }\n\n  return '';\n};\n\nconst DEFAULT_GRAPH_STYLE: ExploreGraphStyle = 'lines';\n// we use this function to take any kind of data we loaded\n// from an external source (URL, localStorage, whatever),\n// and extract the graph-style from it, or return the default\n// graph-style if we are not able to do that.\n// it is important that this function is able to take any form of data,\n// (be it objects, or arrays, or booleans or whatever),\n// and produce a best-effort graphStyle.\n// note that typescript makes sure we make no mistake in this function.\n// we do not rely on ` as ` or ` any `.\nexport const toGraphStyle = (data: unknown): ExploreGraphStyle => {\n  const found = EXPLORE_GRAPH_STYLES.find((v) => v === data);\n  return found ?? DEFAULT_GRAPH_STYLE;\n};\n\nexport function parseUrlState(initial: string | undefined): ExploreUrlState {\n  const parsed = safeParseJson(initial);\n  const errorResult: any = {\n    datasource: null,\n    queries: [],\n    range: DEFAULT_RANGE,\n    mode: null,\n  };\n\n  if (!parsed) {\n    return errorResult;\n  }\n\n  if (!Array.isArray(parsed)) {\n    return parsed;\n  }\n\n  if (parsed.length <= ParseUrlStateIndex.SegmentsStart) {\n    console.error('Error parsing compact URL state for Explore.');\n    return errorResult;\n  }\n\n  const range = {\n    from: parsed[ParseUrlStateIndex.RangeFrom],\n    to: parsed[ParseUrlStateIndex.RangeTo],\n  };\n  const datasource = parsed[ParseUrlStateIndex.Datasource];\n  const parsedSegments = parsed.slice(ParseUrlStateIndex.SegmentsStart);\n  const queries = parsedSegments.filter((segment) => !isSegment(segment, 'ui', 'mode', '__panelsState'));\n\n  const panelsState = parsedSegments.find((segment) => isSegment(segment, '__panelsState'))?.__panelsState;\n  return { datasource, queries, range, panelsState };\n}\n\nexport function generateKey(index = 0): string {\n  return `Q-${uuidv4()}-${index}`;\n}\n\nexport function generateEmptyQuery(queries: DataQuery[], index = 0): DataQuery {\n  return { refId: getNextRefIdChar(queries), key: generateKey(index) };\n}\n\nexport const generateNewKeyAndAddRefIdIfMissing = (target: DataQuery, queries: DataQuery[], index = 0): DataQuery => {\n  const key = generateKey(index);\n  const refId = target.refId || getNextRefIdChar(queries);\n\n  return { ...target, refId, key };\n};\n\n/**\n * Ensure at least one target exists and that targets have the necessary keys\n */\nexport function ensureQueries(queries?: DataQuery[]): DataQuery[] {\n  if (queries && typeof queries === 'object' && queries.length > 0) {\n    const allQueries = [];\n    for (let index = 0; index < queries.length; index++) {\n      const query = queries[index];\n      const key = generateKey(index);\n      let refId = query.refId;\n      if (!refId) {\n        refId = getNextRefIdChar(allQueries);\n      }\n\n      allQueries.push({\n        ...query,\n        refId,\n        key,\n      });\n    }\n    return allQueries;\n  }\n  return [{ ...generateEmptyQuery(queries ?? []) }];\n}\n\n/**\n * A target is non-empty when it has keys (with non-empty values) other than refId, key, context and datasource.\n * FIXME: While this is reasonable for practical use cases, a query without any propery might still be \"non-empty\"\n * in its own scope, for instance when there's no user input needed. This might be the case for an hypothetic datasource in\n * which query options are only set in its config and the query object itself, as generated from its query editor it's always \"empty\"\n */\nconst validKeys = ['refId', 'key', 'context', 'datasource'];\nexport function hasNonEmptyQuery<TQuery extends DataQuery>(queries: TQuery[]): boolean {\n  return (\n    queries &&\n    queries.some((query: any) => {\n      const keys = Object.keys(query)\n        .filter((key) => validKeys.indexOf(key) === -1)\n        .map((k) => query[k])\n        .filter((v) => v);\n      return keys.length > 0;\n    })\n  );\n}\n\n/**\n * Update the query history. Side-effect: store history in local storage\n */\nexport function updateHistory<T extends DataQuery>(\n  history: Array<HistoryItem<T>>,\n  datasourceId: string,\n  queries: T[]\n): Array<HistoryItem<T>> {\n  const ts = Date.now();\n  let updatedHistory = history;\n  queries.forEach((query) => {\n    updatedHistory = [{ query, ts }, ...updatedHistory];\n  });\n\n  if (updatedHistory.length > MAX_HISTORY_ITEMS) {\n    updatedHistory = updatedHistory.slice(0, MAX_HISTORY_ITEMS);\n  }\n\n  // Combine all queries of a datasource type into one history\n  const historyKey = `grafana.explore.history.${datasourceId}`;\n  try {\n    store.setObject(historyKey, updatedHistory);\n    return updatedHistory;\n  } catch (error) {\n    console.error(error);\n    return history;\n  }\n}\n\nexport function clearHistory(datasourceId: string) {\n  const historyKey = `grafana.explore.history.${datasourceId}`;\n  store.delete(historyKey);\n}\n\nexport const getQueryKeys = (queries: DataQuery[], datasourceInstance?: DataSourceApi | null): string[] => {\n  const queryKeys = queries.reduce<string[]>((newQueryKeys, query, index) => {\n    const primaryKey = datasourceInstance && datasourceInstance.name ? datasourceInstance.name : query.key;\n    return newQueryKeys.concat(`${primaryKey}-${index}`);\n  }, []);\n\n  return queryKeys;\n};\n\nexport const getTimeRange = (timeZone: TimeZone, rawRange: RawTimeRange, fiscalYearStartMonth: number): TimeRange => {\n  let range = rangeUtil.convertRawToRange(rawRange, timeZone, fiscalYearStartMonth);\n\n  if (range.to.isBefore(range.from)) {\n    range = rangeUtil.convertRawToRange({ from: range.raw.to, to: range.raw.from }, timeZone, fiscalYearStartMonth);\n  }\n\n  return range;\n};\n\nconst parseRawTime = (value: string | DateTime): TimeFragment | null => {\n  if (value === null) {\n    return null;\n  }\n\n  if (isDateTime(value)) {\n    return value;\n  }\n\n  if (value.indexOf('now') !== -1) {\n    return value;\n  }\n  if (value.length === 8) {\n    return toUtc(value, 'YYYYMMDD');\n  }\n  if (value.length === 15) {\n    return toUtc(value, 'YYYYMMDDTHHmmss');\n  }\n  // Backward compatibility\n  if (value.length === 19) {\n    return toUtc(value, 'YYYY-MM-DD HH:mm:ss');\n  }\n\n  // This should handle cases where value is an epoch time as string\n  if (value.match(/^\\d+$/)) {\n    const epoch = parseInt(value, 10);\n    return toUtc(epoch);\n  }\n\n  // This should handle ISO strings\n  const time = toUtc(value);\n  if (time.isValid()) {\n    return time;\n  }\n\n  return null;\n};\n\nexport const getTimeRangeFromUrl = (\n  range: RawTimeRange,\n  timeZone: TimeZone,\n  fiscalYearStartMonth: number\n): TimeRange => {\n  const raw = {\n    from: parseRawTime(range.from)!,\n    to: parseRawTime(range.to)!,\n  };\n\n  return {\n    from: dateMath.parse(raw.from, false, timeZone as any)!,\n    to: dateMath.parse(raw.to, true, timeZone as any)!,\n    raw,\n  };\n};\n\nexport const getValueWithRefId = (value?: any): any => {\n  if (!value || typeof value !== 'object') {\n    return undefined;\n  }\n\n  if (value.refId) {\n    return value;\n  }\n\n  const keys = Object.keys(value);\n  for (let index = 0; index < keys.length; index++) {\n    const key = keys[index];\n    const refId = getValueWithRefId(value[key]);\n    if (refId) {\n      return refId;\n    }\n  }\n\n  return undefined;\n};\n\nexport const getRefIds = (value: any): string[] => {\n  if (!value) {\n    return [];\n  }\n\n  if (typeof value !== 'object') {\n    return [];\n  }\n\n  const keys = Object.keys(value);\n  const refIds = [];\n  for (let index = 0; index < keys.length; index++) {\n    const key = keys[index];\n    if (key === 'refId') {\n      refIds.push(value[key]);\n      continue;\n    }\n    refIds.push(getRefIds(value[key]));\n  }\n\n  return uniq(flatten(refIds));\n};\n\nexport const refreshIntervalToSortOrder = (refreshInterval?: string) =>\n  RefreshPicker.isLive(refreshInterval) ? LogsSortOrder.Ascending : LogsSortOrder.Descending;\n\nexport const convertToWebSocketUrl = (url: string) => {\n  const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';\n  let backend = `${protocol}${window.location.host}${config.appSubUrl}`;\n  if (backend.endsWith('/')) {\n    backend = backend.slice(0, -1);\n  }\n  return `${backend}${url}`;\n};\n\nexport const stopQueryState = (querySubscription: Unsubscribable | undefined) => {\n  if (querySubscription) {\n    querySubscription.unsubscribe();\n  }\n};\n\nexport function getIntervals(range: TimeRange, lowLimit?: string, resolution?: number): IntervalValues {\n  if (!resolution) {\n    return { interval: '1s', intervalMs: 1000 };\n  }\n\n  return rangeUtil.calculateInterval(range, resolution, lowLimit);\n}\n\nexport const copyStringToClipboard = (string: string) => {\n  const el = document.createElement('textarea');\n  el.value = string;\n  document.body.appendChild(el);\n  el.select();\n  document.execCommand('copy');\n  document.body.removeChild(el);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}