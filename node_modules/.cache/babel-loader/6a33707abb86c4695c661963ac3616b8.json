{"ast":null,"code":"import { getTemplateSrv } from 'app/features/templating/template_srv';\nimport { QueryEditorExpressionType } from '../expressions';\nexport default class SQLGenerator {\n  constructor(templateSrv = getTemplateSrv()) {\n    this.templateSrv = templateSrv;\n  }\n\n  expressionToSqlQuery({\n    select,\n    from,\n    where,\n    groupBy,\n    orderBy,\n    orderByDirection,\n    limit\n  }) {\n    var _select$parameters, _where$expressions$le, _where$expressions;\n\n    if (!from || !(select !== null && select !== void 0 && select.name) || !(select !== null && select !== void 0 && (_select$parameters = select.parameters) !== null && _select$parameters !== void 0 && _select$parameters.length)) {\n      return undefined;\n    }\n\n    let parts = [];\n    this.appendSelect(select, parts);\n    this.appendFrom(from, parts);\n    this.appendWhere(where, parts, true, (_where$expressions$le = where === null || where === void 0 ? void 0 : (_where$expressions = where.expressions) === null || _where$expressions === void 0 ? void 0 : _where$expressions.length) !== null && _where$expressions$le !== void 0 ? _where$expressions$le : 0);\n    this.appendGroupBy(groupBy, parts);\n    this.appendOrderBy(orderBy, orderByDirection, parts);\n    this.appendLimit(limit, parts);\n    return parts.join(' ');\n  }\n\n  appendSelect(select, parts) {\n    parts.push('SELECT');\n    this.appendFunction(select, parts);\n  }\n\n  appendFrom(from, parts) {\n    var _from$property$name, _from$property;\n\n    parts.push('FROM');\n    (from === null || from === void 0 ? void 0 : from.type) === QueryEditorExpressionType.Function ? this.appendFunction(from, parts) : parts.push(this.formatValue((_from$property$name = from === null || from === void 0 ? void 0 : (_from$property = from.property) === null || _from$property === void 0 ? void 0 : _from$property.name) !== null && _from$property$name !== void 0 ? _from$property$name : ''));\n  }\n\n  appendWhere(filter, parts, isTopLevelExpression, topLevelExpressionsCount) {\n    if (!filter) {\n      return;\n    }\n\n    const hasChildExpressions = 'expressions' in filter && filter.expressions.length > 0;\n\n    if (isTopLevelExpression && hasChildExpressions) {\n      parts.push('WHERE');\n    }\n\n    if (filter.type === QueryEditorExpressionType.And) {\n      const andParts = [];\n      filter.expressions.map(exp => this.appendWhere(exp, andParts, false, topLevelExpressionsCount));\n\n      if (andParts.length === 0) {\n        return;\n      }\n\n      const andCombined = andParts.join(' AND ');\n      const wrapInParentheses = !isTopLevelExpression && topLevelExpressionsCount > 1 && andParts.length > 1;\n      return parts.push(wrapInParentheses ? `(${andCombined})` : andCombined);\n    }\n\n    if (filter.type === QueryEditorExpressionType.Or) {\n      const orParts = [];\n      filter.expressions.map(exp => this.appendWhere(exp, orParts, false, topLevelExpressionsCount));\n\n      if (orParts.length === 0) {\n        return;\n      }\n\n      const orCombined = orParts.join(' OR ');\n      const wrapInParentheses = !isTopLevelExpression && topLevelExpressionsCount > 1 && orParts.length > 1;\n      parts.push(wrapInParentheses ? `(${orCombined})` : orCombined);\n      return;\n    }\n\n    if (filter.type === QueryEditorExpressionType.Operator) {\n      return this.appendOperator(filter, parts);\n    }\n  }\n\n  appendGroupBy(groupBy, parts) {\n    const groupByParts = [];\n\n    for (const expression of (_groupBy$expressions = groupBy === null || groupBy === void 0 ? void 0 : groupBy.expressions) !== null && _groupBy$expressions !== void 0 ? _groupBy$expressions : []) {\n      var _groupBy$expressions;\n\n      if ((expression === null || expression === void 0 ? void 0 : expression.type) !== QueryEditorExpressionType.GroupBy || !expression.property.name) {\n        continue;\n      }\n\n      groupByParts.push(this.formatValue(expression.property.name));\n    }\n\n    if (groupByParts.length > 0) {\n      parts.push(`GROUP BY ${groupByParts.join(', ')}`);\n    }\n  }\n\n  appendOrderBy(orderBy, orderByDirection, parts) {\n    if (orderBy) {\n      parts.push('ORDER BY');\n      this.appendFunction(orderBy, parts);\n      parts.push(orderByDirection !== null && orderByDirection !== void 0 ? orderByDirection : 'ASC');\n    }\n  }\n\n  appendLimit(limit, parts) {\n    limit && parts.push(`LIMIT ${limit}`);\n  }\n\n  appendOperator(expression, parts, prefix) {\n    const {\n      property,\n      operator\n    } = expression;\n\n    if (!property.name || !operator.name || !operator.value) {\n      return;\n    }\n\n    parts.push(`${this.formatValue(property.name)} ${operator.name} '${operator.value}'`);\n  }\n\n  appendFunction(select, parts) {\n    var _select$parameters2;\n\n    if (!(select !== null && select !== void 0 && select.name)) {\n      return;\n    }\n\n    const params = ((_select$parameters2 = select.parameters) !== null && _select$parameters2 !== void 0 ? _select$parameters2 : []).map(p => p.name && this.formatValue(p.name)).filter(Boolean).join(', ');\n    parts.push(`${select.name}(${params})`);\n  }\n\n  formatValue(label) {\n    const specialCharacters = /[/\\s\\.-]/; // slash, space, dot or dash\n\n    const interpolated = this.templateSrv.replace(label, {}, 'raw');\n\n    if (specialCharacters.test(interpolated)) {\n      return `\"${label}\"`;\n    }\n\n    return label;\n  }\n\n}","map":{"version":3,"names":["getTemplateSrv","QueryEditorExpressionType","SQLGenerator","constructor","templateSrv","expressionToSqlQuery","select","from","where","groupBy","orderBy","orderByDirection","limit","name","parameters","length","undefined","parts","appendSelect","appendFrom","appendWhere","expressions","appendGroupBy","appendOrderBy","appendLimit","join","push","appendFunction","type","Function","formatValue","property","filter","isTopLevelExpression","topLevelExpressionsCount","hasChildExpressions","And","andParts","map","exp","andCombined","wrapInParentheses","Or","orParts","orCombined","Operator","appendOperator","groupByParts","expression","GroupBy","prefix","operator","value","params","p","Boolean","label","specialCharacters","interpolated","replace","test"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/cloudwatch-sql/SQLGenerator.ts"],"sourcesContent":["import { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\n\nimport {\n  QueryEditorArrayExpression,\n  QueryEditorExpression,\n  QueryEditorExpressionType,\n  QueryEditorFunctionExpression,\n  QueryEditorOperatorExpression,\n  QueryEditorPropertyExpression,\n} from '../expressions';\nimport { SQLExpression } from '../types';\n\nexport default class SQLGenerator {\n  constructor(private templateSrv: TemplateSrv = getTemplateSrv()) {}\n\n  expressionToSqlQuery({\n    select,\n    from,\n    where,\n    groupBy,\n    orderBy,\n    orderByDirection,\n    limit,\n  }: SQLExpression): string | undefined {\n    if (!from || !select?.name || !select?.parameters?.length) {\n      return undefined;\n    }\n\n    let parts: string[] = [];\n    this.appendSelect(select, parts);\n    this.appendFrom(from, parts);\n    this.appendWhere(where, parts, true, where?.expressions?.length ?? 0);\n    this.appendGroupBy(groupBy, parts);\n    this.appendOrderBy(orderBy, orderByDirection, parts);\n    this.appendLimit(limit, parts);\n\n    return parts.join(' ');\n  }\n\n  private appendSelect(select: QueryEditorFunctionExpression | undefined, parts: string[]) {\n    parts.push('SELECT');\n    this.appendFunction(select, parts);\n  }\n\n  private appendFrom(from: QueryEditorPropertyExpression | QueryEditorFunctionExpression | undefined, parts: string[]) {\n    parts.push('FROM');\n    from?.type === QueryEditorExpressionType.Function\n      ? this.appendFunction(from, parts)\n      : parts.push(this.formatValue(from?.property?.name ?? ''));\n  }\n\n  private appendWhere(\n    filter: QueryEditorExpression | undefined,\n    parts: string[],\n    isTopLevelExpression: boolean,\n    topLevelExpressionsCount: number\n  ) {\n    if (!filter) {\n      return;\n    }\n\n    const hasChildExpressions = 'expressions' in filter && filter.expressions.length > 0;\n    if (isTopLevelExpression && hasChildExpressions) {\n      parts.push('WHERE');\n    }\n\n    if (filter.type === QueryEditorExpressionType.And) {\n      const andParts: string[] = [];\n      filter.expressions.map((exp) => this.appendWhere(exp, andParts, false, topLevelExpressionsCount));\n      if (andParts.length === 0) {\n        return;\n      }\n      const andCombined = andParts.join(' AND ');\n      const wrapInParentheses = !isTopLevelExpression && topLevelExpressionsCount > 1 && andParts.length > 1;\n      return parts.push(wrapInParentheses ? `(${andCombined})` : andCombined);\n    }\n\n    if (filter.type === QueryEditorExpressionType.Or) {\n      const orParts: string[] = [];\n      filter.expressions.map((exp) => this.appendWhere(exp, orParts, false, topLevelExpressionsCount));\n      if (orParts.length === 0) {\n        return;\n      }\n      const orCombined = orParts.join(' OR ');\n      const wrapInParentheses = !isTopLevelExpression && topLevelExpressionsCount > 1 && orParts.length > 1;\n      parts.push(wrapInParentheses ? `(${orCombined})` : orCombined);\n      return;\n    }\n\n    if (filter.type === QueryEditorExpressionType.Operator) {\n      return this.appendOperator(filter, parts);\n    }\n  }\n\n  private appendGroupBy(groupBy: QueryEditorArrayExpression | undefined, parts: string[]) {\n    const groupByParts: string[] = [];\n    for (const expression of groupBy?.expressions ?? []) {\n      if (expression?.type !== QueryEditorExpressionType.GroupBy || !expression.property.name) {\n        continue;\n      }\n      groupByParts.push(this.formatValue(expression.property.name));\n    }\n\n    if (groupByParts.length > 0) {\n      parts.push(`GROUP BY ${groupByParts.join(', ')}`);\n    }\n  }\n\n  private appendOrderBy(\n    orderBy: QueryEditorFunctionExpression | undefined,\n    orderByDirection: string | undefined,\n    parts: string[]\n  ) {\n    if (orderBy) {\n      parts.push('ORDER BY');\n      this.appendFunction(orderBy, parts);\n      parts.push(orderByDirection ?? 'ASC');\n    }\n  }\n\n  private appendLimit(limit: number | undefined, parts: string[]) {\n    limit && parts.push(`LIMIT ${limit}`);\n  }\n\n  private appendOperator(expression: QueryEditorOperatorExpression, parts: string[], prefix?: string) {\n    const { property, operator } = expression;\n\n    if (!property.name || !operator.name || !operator.value) {\n      return;\n    }\n\n    parts.push(`${this.formatValue(property.name)} ${operator.name} '${operator.value}'`);\n  }\n\n  private appendFunction(select: QueryEditorFunctionExpression | undefined, parts: string[]) {\n    if (!select?.name) {\n      return;\n    }\n\n    const params = (select.parameters ?? [])\n      .map((p) => p.name && this.formatValue(p.name))\n      .filter(Boolean)\n      .join(', ');\n\n    parts.push(`${select.name}(${params})`);\n  }\n\n  private formatValue(label: string): string {\n    const specialCharacters = /[/\\s\\.-]/; // slash, space, dot or dash\n\n    const interpolated = this.templateSrv.replace(label, {}, 'raw');\n    if (specialCharacters.test(interpolated)) {\n      return `\"${label}\"`;\n    }\n\n    return label;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}