{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { FunctionalVector } from './FunctionalVector';\nimport { vectorToArray } from './vectorToArray';\n\n/**\n * Circular vector uses a single buffer to capture a stream of values\n * overwriting the oldest value on add.\n *\n * This supports adding to the 'head' or 'tail' and will grow the buffer\n * to match a configured capacity.\n *\n * @public\n */\nexport class CircularVector extends FunctionalVector {\n  constructor(options) {\n    super();\n\n    _defineProperty(this, \"buffer\", void 0);\n\n    _defineProperty(this, \"index\", void 0);\n\n    _defineProperty(this, \"capacity\", void 0);\n\n    _defineProperty(this, \"tail\", void 0);\n\n    _defineProperty(this, \"add\", void 0);\n\n    this.buffer = options.buffer || [];\n    this.capacity = this.buffer.length;\n    this.tail = 'head' !== options.append;\n    this.index = 0;\n    this.add = this.getAddFunction();\n\n    if (options.capacity) {\n      this.setCapacity(options.capacity);\n    }\n  }\n  /**\n   * This gets the appropriate add function depending on the buffer state:\n   *  * head vs tail\n   *  * growing buffer vs overwriting values\n   */\n\n\n  getAddFunction() {\n    // When we are not at capacity, it should actually modify the buffer\n    if (this.capacity > this.buffer.length) {\n      if (this.tail) {\n        return value => {\n          this.buffer.push(value);\n\n          if (this.buffer.length >= this.capacity) {\n            this.add = this.getAddFunction();\n          }\n        };\n      } else {\n        return value => {\n          this.buffer.unshift(value);\n\n          if (this.buffer.length >= this.capacity) {\n            this.add = this.getAddFunction();\n          }\n        };\n      }\n    }\n\n    if (this.tail) {\n      return value => {\n        this.buffer[this.index] = value;\n        this.index = (this.index + 1) % this.buffer.length;\n      };\n    } // Append values to the head\n\n\n    return value => {\n      let idx = this.index - 1;\n\n      if (idx < 0) {\n        idx = this.buffer.length - 1;\n      }\n\n      this.buffer[idx] = value;\n      this.index = idx;\n    };\n  }\n\n  setCapacity(v) {\n    if (this.capacity === v) {\n      return;\n    } // Make a copy so it is in order and new additions can be at the head or tail\n\n\n    const copy = this.toArray();\n\n    if (v > this.length) {\n      this.buffer = copy;\n    } else if (v < this.capacity) {\n      // Shrink the buffer\n      const delta = this.length - v;\n\n      if (this.tail) {\n        this.buffer = copy.slice(delta, copy.length); // Keep last items\n      } else {\n        this.buffer = copy.slice(0, copy.length - delta); // Keep first items\n      }\n    }\n\n    this.capacity = v;\n    this.index = 0;\n    this.add = this.getAddFunction();\n  }\n\n  setAppendMode(mode) {\n    const tail = 'head' !== mode;\n\n    if (tail !== this.tail) {\n      this.buffer = this.toArray().reverse();\n      this.index = 0;\n      this.tail = tail;\n      this.add = this.getAddFunction();\n    }\n  }\n\n  reverse() {\n    this.buffer.reverse();\n  }\n  /**\n   * Add the value to the buffer\n   */\n\n\n  get(index) {\n    return this.buffer[(index + this.index) % this.buffer.length];\n  }\n\n  set(index, value) {\n    this.buffer[(index + this.index) % this.buffer.length] = value;\n  }\n\n  get length() {\n    return this.buffer.length;\n  }\n\n  toArray() {\n    return vectorToArray(this);\n  }\n\n  toJSON() {\n    return vectorToArray(this);\n  }\n\n}","map":{"version":3,"names":["FunctionalVector","vectorToArray","CircularVector","constructor","options","buffer","capacity","length","tail","append","index","add","getAddFunction","setCapacity","value","push","unshift","idx","v","copy","toArray","delta","slice","setAppendMode","mode","reverse","get","set","toJSON"],"sources":["/home/soula/grafana/packages/grafana-data/src/vector/CircularVector.ts"],"sourcesContent":["import { MutableVector } from '../types/vector';\n\nimport { FunctionalVector } from './FunctionalVector';\nimport { vectorToArray } from './vectorToArray';\n\ninterface CircularOptions<T> {\n  buffer?: T[];\n  append?: 'head' | 'tail';\n  capacity?: number;\n}\n\n/**\n * Circular vector uses a single buffer to capture a stream of values\n * overwriting the oldest value on add.\n *\n * This supports adding to the 'head' or 'tail' and will grow the buffer\n * to match a configured capacity.\n *\n * @public\n */\nexport class CircularVector<T = any> extends FunctionalVector<T> implements MutableVector<T> {\n  private buffer: T[];\n  private index: number;\n  private capacity: number;\n  private tail: boolean;\n\n  constructor(options: CircularOptions<T>) {\n    super();\n\n    this.buffer = options.buffer || [];\n    this.capacity = this.buffer.length;\n    this.tail = 'head' !== options.append;\n    this.index = 0;\n\n    this.add = this.getAddFunction();\n    if (options.capacity) {\n      this.setCapacity(options.capacity);\n    }\n  }\n\n  /**\n   * This gets the appropriate add function depending on the buffer state:\n   *  * head vs tail\n   *  * growing buffer vs overwriting values\n   */\n  private getAddFunction() {\n    // When we are not at capacity, it should actually modify the buffer\n    if (this.capacity > this.buffer.length) {\n      if (this.tail) {\n        return (value: T) => {\n          this.buffer.push(value);\n          if (this.buffer.length >= this.capacity) {\n            this.add = this.getAddFunction();\n          }\n        };\n      } else {\n        return (value: T) => {\n          this.buffer.unshift(value);\n          if (this.buffer.length >= this.capacity) {\n            this.add = this.getAddFunction();\n          }\n        };\n      }\n    }\n\n    if (this.tail) {\n      return (value: T) => {\n        this.buffer[this.index] = value;\n        this.index = (this.index + 1) % this.buffer.length;\n      };\n    }\n\n    // Append values to the head\n    return (value: T) => {\n      let idx = this.index - 1;\n      if (idx < 0) {\n        idx = this.buffer.length - 1;\n      }\n      this.buffer[idx] = value;\n      this.index = idx;\n    };\n  }\n\n  setCapacity(v: number) {\n    if (this.capacity === v) {\n      return;\n    }\n    // Make a copy so it is in order and new additions can be at the head or tail\n    const copy = this.toArray();\n    if (v > this.length) {\n      this.buffer = copy;\n    } else if (v < this.capacity) {\n      // Shrink the buffer\n      const delta = this.length - v;\n      if (this.tail) {\n        this.buffer = copy.slice(delta, copy.length); // Keep last items\n      } else {\n        this.buffer = copy.slice(0, copy.length - delta); // Keep first items\n      }\n    }\n    this.capacity = v;\n    this.index = 0;\n    this.add = this.getAddFunction();\n  }\n\n  setAppendMode(mode: 'head' | 'tail') {\n    const tail = 'head' !== mode;\n    if (tail !== this.tail) {\n      this.buffer = this.toArray().reverse();\n      this.index = 0;\n      this.tail = tail;\n      this.add = this.getAddFunction();\n    }\n  }\n\n  reverse() {\n    this.buffer.reverse();\n  }\n\n  /**\n   * Add the value to the buffer\n   */\n  add: (value: T) => void;\n\n  get(index: number) {\n    return this.buffer[(index + this.index) % this.buffer.length];\n  }\n\n  set(index: number, value: T) {\n    this.buffer[(index + this.index) % this.buffer.length] = value;\n  }\n\n  get length() {\n    return this.buffer.length;\n  }\n\n  toArray(): T[] {\n    return vectorToArray(this);\n  }\n\n  toJSON(): T[] {\n    return vectorToArray(this);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}