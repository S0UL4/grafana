{"ast":null,"code":"import { dateTimeFormat, isBooleanUnit, systemDateFormats } from '@grafana/data';\nimport { AxisPlacement } from '@grafana/schema';\nimport { measureText } from '../../../utils/measureText';\nimport { PlotConfigBuilder } from '../types';\nimport { optMinMax } from './UPlotScaleBuilder';\nexport const UPLOT_AXIS_FONT_SIZE = 12;\nconst labelPad = 8;\nexport class UPlotAxisBuilder extends PlotConfigBuilder {\n  merge(props) {\n    this.props.size = optMinMax('max', this.props.size, props.size);\n\n    if (!this.props.label) {\n      this.props.label = props.label;\n    }\n\n    if (this.props.placement === AxisPlacement.Auto) {\n      this.props.placement = props.placement;\n    }\n  }\n  /* Minimum grid & tick spacing in CSS pixels */\n\n\n  calculateSpace(self, axisIdx, scaleMin, scaleMax, plotDim) {\n    const axis = self.axes[axisIdx];\n    const scale = self.scales[axis.scale]; // for axis left & right\n\n    if (axis.side !== 2 || !scale) {\n      return 30;\n    }\n\n    const defaultSpacing = 40;\n\n    if (scale.time) {\n      const maxTicks = plotDim / defaultSpacing;\n      const increment = (scaleMax - scaleMin) / maxTicks;\n      const sample = formatTime(self, [scaleMin], axisIdx, defaultSpacing, increment);\n      const width = measureText(sample[0], UPLOT_AXIS_FONT_SIZE).width + 18;\n      return width;\n    }\n\n    return defaultSpacing;\n  }\n  /** height of x axis or width of y axis in CSS pixels alloted for values, gap & ticks, but excluding axis label */\n\n\n  calculateAxisSize(self, values, axisIdx) {\n    const axis = self.axes[axisIdx];\n    let axisSize = axis.ticks.size;\n\n    if (axis.side === 2) {\n      axisSize += axis.gap + UPLOT_AXIS_FONT_SIZE;\n    } else if (values !== null && values !== void 0 && values.length) {\n      let maxTextWidth = values.reduce((acc, value) => Math.max(acc, measureText(value, UPLOT_AXIS_FONT_SIZE).width), 0); // limit y tick label width to 40% of visualization\n\n      const textWidthWithLimit = Math.min(self.width * 0.4, maxTextWidth); // Not sure why this += and not normal assignment\n\n      axisSize += axis.gap + axis.labelGap + textWidthWithLimit;\n    }\n\n    return Math.ceil(axisSize);\n  }\n\n  getConfig() {\n    let {\n      scaleKey,\n      label,\n      show = true,\n      placement = AxisPlacement.Auto,\n      grid = {\n        show: true\n      },\n      ticks,\n      space,\n      filter,\n      gap = 5,\n      formatValue,\n      splits,\n      values,\n      isTime,\n      timeZone,\n      theme,\n      tickLabelRotation,\n      size\n    } = this.props;\n    const font = `${UPLOT_AXIS_FONT_SIZE}px ${theme.typography.fontFamily}`;\n    const gridColor = theme.isDark ? 'rgba(240, 250, 255, 0.09)' : 'rgba(0, 10, 23, 0.09)';\n\n    if (isBooleanUnit(scaleKey)) {\n      splits = [0, 1];\n    }\n\n    let config = {\n      scale: scaleKey,\n      show,\n      stroke: theme.colors.text.primary,\n      side: getUPlotSideFromAxis(placement),\n      font,\n      size: size !== null && size !== void 0 ? size : (self, values, axisIdx) => {\n        return this.calculateAxisSize(self, values, axisIdx);\n      },\n      rotate: tickLabelRotation,\n      gap,\n      labelGap: 0,\n      grid: {\n        show: grid.show,\n        stroke: gridColor,\n        width: 1 / devicePixelRatio\n      },\n      ticks: Object.assign({\n        show: true,\n        stroke: gridColor,\n        width: 1 / devicePixelRatio,\n        size: 4\n      }, ticks),\n      splits,\n      values: values,\n      space: space !== null && space !== void 0 ? space : (self, axisIdx, scaleMin, scaleMax, plotDim) => {\n        return this.calculateSpace(self, axisIdx, scaleMin, scaleMax, plotDim);\n      },\n      filter\n    };\n\n    if (label != null && label.length > 0) {\n      config.label = label;\n      config.labelSize = UPLOT_AXIS_FONT_SIZE + labelPad;\n      config.labelFont = font;\n      config.labelGap = labelPad;\n    }\n\n    if (values) {\n      config.values = values;\n    } else if (isTime) {\n      config.values = formatTime;\n    } else if (formatValue) {\n      config.values = (u, vals) => vals.map(formatValue);\n    } // store timezone\n\n\n    config.timeZone = timeZone;\n    return config;\n  }\n\n}\nconst timeUnitSize = {\n  second: 1000,\n  minute: 60 * 1000,\n  hour: 60 * 60 * 1000,\n  day: 24 * 60 * 60 * 1000,\n  month: 28 * 24 * 60 * 60 * 1000,\n  year: 365 * 24 * 60 * 60 * 1000\n};\n/** Format time axis ticks */\n\nexport function formatTime(self, splits, axisIdx, foundSpace, foundIncr) {\n  var _scale$max, _scale$min;\n\n  const timeZone = self.axes[axisIdx].timeZone;\n  const scale = self.scales.x;\n  const range = ((_scale$max = scale === null || scale === void 0 ? void 0 : scale.max) !== null && _scale$max !== void 0 ? _scale$max : 0) - ((_scale$min = scale === null || scale === void 0 ? void 0 : scale.min) !== null && _scale$min !== void 0 ? _scale$min : 0);\n  const yearRoundedToDay = Math.round(timeUnitSize.year / timeUnitSize.day) * timeUnitSize.day;\n  const incrementRoundedToDay = Math.round(foundIncr / timeUnitSize.day) * timeUnitSize.day;\n  let format = systemDateFormats.interval.year;\n\n  if (foundIncr < timeUnitSize.second) {\n    format = systemDateFormats.interval.second.replace('ss', 'ss.SS');\n  } else if (foundIncr <= timeUnitSize.minute) {\n    format = systemDateFormats.interval.second;\n  } else if (range <= timeUnitSize.day) {\n    format = systemDateFormats.interval.minute;\n  } else if (foundIncr <= timeUnitSize.day) {\n    format = systemDateFormats.interval.hour;\n  } else if (range < timeUnitSize.year) {\n    format = systemDateFormats.interval.day;\n  } else if (incrementRoundedToDay === yearRoundedToDay) {\n    format = systemDateFormats.interval.year;\n  } else if (foundIncr <= timeUnitSize.year) {\n    format = systemDateFormats.interval.month;\n  }\n\n  return splits.map(v => dateTimeFormat(v, {\n    format,\n    timeZone\n  }));\n}\nexport function getUPlotSideFromAxis(axis) {\n  switch (axis) {\n    case AxisPlacement.Top:\n      return 0;\n\n    case AxisPlacement.Right:\n      return 1;\n\n    case AxisPlacement.Bottom:\n      return 2;\n\n    case AxisPlacement.Left:\n  }\n\n  return 3; // default everythign to the left\n}","map":{"version":3,"names":["dateTimeFormat","isBooleanUnit","systemDateFormats","AxisPlacement","measureText","PlotConfigBuilder","optMinMax","UPLOT_AXIS_FONT_SIZE","labelPad","UPlotAxisBuilder","merge","props","size","label","placement","Auto","calculateSpace","self","axisIdx","scaleMin","scaleMax","plotDim","axis","axes","scale","scales","side","defaultSpacing","time","maxTicks","increment","sample","formatTime","width","calculateAxisSize","values","axisSize","ticks","gap","length","maxTextWidth","reduce","acc","value","Math","max","textWidthWithLimit","min","labelGap","ceil","getConfig","scaleKey","show","grid","space","filter","formatValue","splits","isTime","timeZone","theme","tickLabelRotation","font","typography","fontFamily","gridColor","isDark","config","stroke","colors","text","primary","getUPlotSideFromAxis","rotate","devicePixelRatio","Object","assign","labelSize","labelFont","u","vals","map","timeUnitSize","second","minute","hour","day","month","year","foundSpace","foundIncr","x","range","yearRoundedToDay","round","incrementRoundedToDay","format","interval","replace","v","Top","Right","Bottom","Left"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/uPlot/config/UPlotAxisBuilder.ts"],"sourcesContent":["import uPlot, { Axis } from 'uplot';\n\nimport { dateTimeFormat, GrafanaTheme2, isBooleanUnit, systemDateFormats, TimeZone } from '@grafana/data';\nimport { AxisPlacement } from '@grafana/schema';\n\nimport { measureText } from '../../../utils/measureText';\nimport { PlotConfigBuilder } from '../types';\n\nimport { optMinMax } from './UPlotScaleBuilder';\n\nexport interface AxisProps {\n  scaleKey: string;\n  theme: GrafanaTheme2;\n  label?: string;\n  show?: boolean;\n  size?: number | null;\n  gap?: number;\n  tickLabelRotation?: number;\n  placement?: AxisPlacement;\n  grid?: Axis.Grid;\n  ticks?: Axis.Ticks;\n  filter?: Axis.Filter;\n  space?: Axis.Space;\n  formatValue?: (v: any) => string;\n  incrs?: Axis.Incrs;\n  splits?: Axis.Splits;\n  values?: Axis.Values;\n  isTime?: boolean;\n  timeZone?: TimeZone;\n}\n\nexport const UPLOT_AXIS_FONT_SIZE = 12;\nconst labelPad = 8;\n\nexport class UPlotAxisBuilder extends PlotConfigBuilder<AxisProps, Axis> {\n  merge(props: AxisProps) {\n    this.props.size = optMinMax('max', this.props.size, props.size);\n    if (!this.props.label) {\n      this.props.label = props.label;\n    }\n    if (this.props.placement === AxisPlacement.Auto) {\n      this.props.placement = props.placement;\n    }\n  }\n  /* Minimum grid & tick spacing in CSS pixels */\n  calculateSpace(self: uPlot, axisIdx: number, scaleMin: number, scaleMax: number, plotDim: number): number {\n    const axis = self.axes[axisIdx];\n    const scale = self.scales[axis.scale!];\n\n    // for axis left & right\n    if (axis.side !== 2 || !scale) {\n      return 30;\n    }\n\n    const defaultSpacing = 40;\n\n    if (scale.time) {\n      const maxTicks = plotDim / defaultSpacing;\n      const increment = (scaleMax - scaleMin) / maxTicks;\n      const sample = formatTime(self, [scaleMin], axisIdx, defaultSpacing, increment);\n      const width = measureText(sample[0], UPLOT_AXIS_FONT_SIZE).width + 18;\n      return width;\n    }\n\n    return defaultSpacing;\n  }\n\n  /** height of x axis or width of y axis in CSS pixels alloted for values, gap & ticks, but excluding axis label */\n  calculateAxisSize(self: uPlot, values: string[], axisIdx: number) {\n    const axis = self.axes[axisIdx];\n\n    let axisSize = axis.ticks!.size!;\n\n    if (axis.side === 2) {\n      axisSize += axis!.gap! + UPLOT_AXIS_FONT_SIZE;\n    } else if (values?.length) {\n      let maxTextWidth = values.reduce(\n        (acc, value) => Math.max(acc, measureText(value, UPLOT_AXIS_FONT_SIZE).width),\n        0\n      );\n      // limit y tick label width to 40% of visualization\n      const textWidthWithLimit = Math.min(self.width * 0.4, maxTextWidth);\n      // Not sure why this += and not normal assignment\n      axisSize += axis!.gap! + axis!.labelGap! + textWidthWithLimit;\n    }\n\n    return Math.ceil(axisSize);\n  }\n\n  getConfig(): Axis {\n    let {\n      scaleKey,\n      label,\n      show = true,\n      placement = AxisPlacement.Auto,\n      grid = { show: true },\n      ticks,\n      space,\n      filter,\n      gap = 5,\n      formatValue,\n      splits,\n      values,\n      isTime,\n      timeZone,\n      theme,\n      tickLabelRotation,\n      size,\n    } = this.props;\n\n    const font = `${UPLOT_AXIS_FONT_SIZE}px ${theme.typography.fontFamily}`;\n\n    const gridColor = theme.isDark ? 'rgba(240, 250, 255, 0.09)' : 'rgba(0, 10, 23, 0.09)';\n\n    if (isBooleanUnit(scaleKey)) {\n      splits = [0, 1];\n    }\n\n    let config: Axis = {\n      scale: scaleKey,\n      show,\n      stroke: theme.colors.text.primary,\n      side: getUPlotSideFromAxis(placement),\n      font,\n      size:\n        size ??\n        ((self, values, axisIdx) => {\n          return this.calculateAxisSize(self, values, axisIdx);\n        }),\n      rotate: tickLabelRotation,\n      gap,\n\n      labelGap: 0,\n\n      grid: {\n        show: grid.show,\n        stroke: gridColor,\n        width: 1 / devicePixelRatio,\n      },\n      ticks: Object.assign(\n        {\n          show: true,\n          stroke: gridColor,\n          width: 1 / devicePixelRatio,\n          size: 4,\n        },\n        ticks\n      ),\n      splits,\n      values: values,\n      space:\n        space ??\n        ((self, axisIdx, scaleMin, scaleMax, plotDim) => {\n          return this.calculateSpace(self, axisIdx, scaleMin, scaleMax, plotDim);\n        }),\n      filter,\n    };\n\n    if (label != null && label.length > 0) {\n      config.label = label;\n      config.labelSize = UPLOT_AXIS_FONT_SIZE + labelPad;\n      config.labelFont = font;\n      config.labelGap = labelPad;\n    }\n\n    if (values) {\n      config.values = values;\n    } else if (isTime) {\n      config.values = formatTime;\n    } else if (formatValue) {\n      config.values = (u: uPlot, vals: any[]) => vals.map(formatValue!);\n    }\n\n    // store timezone\n    (config as any).timeZone = timeZone;\n\n    return config;\n  }\n}\n\nconst timeUnitSize = {\n  second: 1000,\n  minute: 60 * 1000,\n  hour: 60 * 60 * 1000,\n  day: 24 * 60 * 60 * 1000,\n  month: 28 * 24 * 60 * 60 * 1000,\n  year: 365 * 24 * 60 * 60 * 1000,\n};\n\n/** Format time axis ticks */\nexport function formatTime(\n  self: uPlot,\n  splits: number[],\n  axisIdx: number,\n  foundSpace: number,\n  foundIncr: number\n): string[] {\n  const timeZone = (self.axes[axisIdx] as any).timeZone;\n  const scale = self.scales.x;\n  const range = (scale?.max ?? 0) - (scale?.min ?? 0);\n  const yearRoundedToDay = Math.round(timeUnitSize.year / timeUnitSize.day) * timeUnitSize.day;\n  const incrementRoundedToDay = Math.round(foundIncr / timeUnitSize.day) * timeUnitSize.day;\n\n  let format = systemDateFormats.interval.year;\n\n  if (foundIncr < timeUnitSize.second) {\n    format = systemDateFormats.interval.second.replace('ss', 'ss.SS');\n  } else if (foundIncr <= timeUnitSize.minute) {\n    format = systemDateFormats.interval.second;\n  } else if (range <= timeUnitSize.day) {\n    format = systemDateFormats.interval.minute;\n  } else if (foundIncr <= timeUnitSize.day) {\n    format = systemDateFormats.interval.hour;\n  } else if (range < timeUnitSize.year) {\n    format = systemDateFormats.interval.day;\n  } else if (incrementRoundedToDay === yearRoundedToDay) {\n    format = systemDateFormats.interval.year;\n  } else if (foundIncr <= timeUnitSize.year) {\n    format = systemDateFormats.interval.month;\n  }\n\n  return splits.map((v) => dateTimeFormat(v, { format, timeZone }));\n}\n\nexport function getUPlotSideFromAxis(axis: AxisPlacement) {\n  switch (axis) {\n    case AxisPlacement.Top:\n      return 0;\n    case AxisPlacement.Right:\n      return 1;\n    case AxisPlacement.Bottom:\n      return 2;\n    case AxisPlacement.Left:\n  }\n\n  return 3; // default everythign to the left\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}