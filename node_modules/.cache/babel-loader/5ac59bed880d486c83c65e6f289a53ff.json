{"ast":null,"code":"import { omitBy } from 'lodash';\nimport { deprecationWarning } from '@grafana/data';\nexport const parseInitFromOptions = options => {\n  const method = options.method;\n  const headers = parseHeaders(options);\n  const isAppJson = isContentTypeApplicationJson(headers);\n  const body = parseBody(options, isAppJson);\n  const credentials = parseCredentials(options);\n  return {\n    method,\n    headers,\n    body,\n    credentials\n  };\n};\nconst defaultHeaderParser = {\n  canParse: () => true,\n  parse: headers => {\n    const accept = headers.get('accept');\n\n    if (accept) {\n      return headers;\n    }\n\n    headers.set('accept', 'application/json, text/plain, */*');\n    return headers;\n  }\n};\n\nconst parseHeaderByMethodFactory = methodPredicate => ({\n  canParse: options => {\n    const method = options !== null && options !== void 0 && options.method ? options === null || options === void 0 ? void 0 : options.method.toLowerCase() : '';\n    return method === methodPredicate;\n  },\n  parse: headers => {\n    const contentType = headers.get('content-type');\n\n    if (contentType) {\n      return headers;\n    }\n\n    headers.set('content-type', 'application/json');\n    return headers;\n  }\n});\n\nconst postHeaderParser = parseHeaderByMethodFactory('post');\nconst putHeaderParser = parseHeaderByMethodFactory('put');\nconst patchHeaderParser = parseHeaderByMethodFactory('patch');\nconst headerParsers = [postHeaderParser, putHeaderParser, patchHeaderParser, defaultHeaderParser];\nexport const parseHeaders = options => {\n  const headers = options !== null && options !== void 0 && options.headers ? new Headers(options.headers) : new Headers();\n  const parsers = headerParsers.filter(parser => parser.canParse(options));\n  const combinedHeaders = parsers.reduce((prev, parser) => {\n    return parser.parse(prev);\n  }, headers);\n  return combinedHeaders;\n};\nexport const isContentTypeApplicationJson = headers => {\n  if (!headers) {\n    return false;\n  }\n\n  const contentType = headers.get('content-type');\n\n  if (contentType && contentType.toLowerCase() === 'application/json') {\n    return true;\n  }\n\n  return false;\n};\nexport const parseBody = (options, isAppJson) => {\n  if (!options) {\n    return options;\n  }\n\n  if (!options.data || typeof options.data === 'string') {\n    return options.data;\n  }\n\n  return isAppJson ? JSON.stringify(options.data) : new URLSearchParams(options.data);\n};\nexport async function parseResponseBody(response, responseType) {\n  if (responseType) {\n    switch (responseType) {\n      case 'arraybuffer':\n        return response.arrayBuffer();\n\n      case 'blob':\n        return response.blob();\n\n      case 'json':\n        // An empty string is not a valid JSON.\n        // Sometimes (unfortunately) our APIs declare their Content-Type as JSON, however they return an empty body.\n        if (response.headers.get('Content-Length') === '0') {\n          console.warn(`${response.url} returned an invalid JSON`);\n          return {};\n        }\n\n        return await response.json();\n\n      case 'text':\n        return response.text();\n    }\n  }\n\n  const textData = await response.text(); // this could be just a string, prometheus requests for instance\n\n  try {\n    return JSON.parse(textData); // majority of the requests this will be something that can be parsed\n  } catch {}\n\n  return textData;\n}\nexport function serializeParams(data) {\n  return Object.keys(data).map(key => {\n    const value = data[key];\n\n    if (Array.isArray(value)) {\n      return value.map(arrayValue => `${encodeURIComponent(key)}=${encodeURIComponent(arrayValue)}`).join('&');\n    }\n\n    return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n  }).join('&');\n}\nexport const parseUrlFromOptions = options => {\n  const cleanParams = omitBy(options.params, v => v === undefined || v && v.length === 0);\n  const serializedParams = serializeParams(cleanParams);\n  return options.params && serializedParams.length ? `${options.url}?${serializedParams}` : options.url;\n};\nexport const parseCredentials = options => {\n  if (!options) {\n    return options;\n  }\n\n  if (options.credentials) {\n    return options.credentials;\n  }\n\n  if (options.withCredentials) {\n    deprecationWarning('BackendSrvRequest', 'withCredentials', 'credentials');\n    return 'include';\n  }\n\n  return 'same-origin';\n};","map":{"version":3,"names":["omitBy","deprecationWarning","parseInitFromOptions","options","method","headers","parseHeaders","isAppJson","isContentTypeApplicationJson","body","parseBody","credentials","parseCredentials","defaultHeaderParser","canParse","parse","accept","get","set","parseHeaderByMethodFactory","methodPredicate","toLowerCase","contentType","postHeaderParser","putHeaderParser","patchHeaderParser","headerParsers","Headers","parsers","filter","parser","combinedHeaders","reduce","prev","data","JSON","stringify","URLSearchParams","parseResponseBody","response","responseType","arrayBuffer","blob","console","warn","url","json","text","textData","serializeParams","Object","keys","map","key","value","Array","isArray","arrayValue","encodeURIComponent","join","parseUrlFromOptions","cleanParams","params","v","undefined","length","serializedParams","withCredentials"],"sources":["/home/soula/grafana/public/app/core/utils/fetch.ts"],"sourcesContent":["import { omitBy } from 'lodash';\n\nimport { deprecationWarning } from '@grafana/data';\nimport { BackendSrvRequest } from '@grafana/runtime';\n\nexport const parseInitFromOptions = (options: BackendSrvRequest): RequestInit => {\n  const method = options.method;\n  const headers = parseHeaders(options);\n  const isAppJson = isContentTypeApplicationJson(headers);\n  const body = parseBody(options, isAppJson);\n  const credentials = parseCredentials(options);\n\n  return {\n    method,\n    headers,\n    body,\n    credentials,\n  };\n};\n\ninterface HeaderParser {\n  canParse: (options: BackendSrvRequest) => boolean;\n  parse: (headers: Headers) => Headers;\n}\n\nconst defaultHeaderParser: HeaderParser = {\n  canParse: () => true,\n  parse: (headers) => {\n    const accept = headers.get('accept');\n    if (accept) {\n      return headers;\n    }\n\n    headers.set('accept', 'application/json, text/plain, */*');\n    return headers;\n  },\n};\n\nconst parseHeaderByMethodFactory = (methodPredicate: string): HeaderParser => ({\n  canParse: (options) => {\n    const method = options?.method ? options?.method.toLowerCase() : '';\n    return method === methodPredicate;\n  },\n  parse: (headers) => {\n    const contentType = headers.get('content-type');\n    if (contentType) {\n      return headers;\n    }\n\n    headers.set('content-type', 'application/json');\n    return headers;\n  },\n});\n\nconst postHeaderParser: HeaderParser = parseHeaderByMethodFactory('post');\nconst putHeaderParser: HeaderParser = parseHeaderByMethodFactory('put');\nconst patchHeaderParser: HeaderParser = parseHeaderByMethodFactory('patch');\n\nconst headerParsers = [postHeaderParser, putHeaderParser, patchHeaderParser, defaultHeaderParser];\n\nexport const parseHeaders = (options: BackendSrvRequest) => {\n  const headers = options?.headers ? new Headers(options.headers) : new Headers();\n  const parsers = headerParsers.filter((parser) => parser.canParse(options));\n  const combinedHeaders = parsers.reduce((prev, parser) => {\n    return parser.parse(prev);\n  }, headers);\n\n  return combinedHeaders;\n};\n\nexport const isContentTypeApplicationJson = (headers: Headers) => {\n  if (!headers) {\n    return false;\n  }\n\n  const contentType = headers.get('content-type');\n  if (contentType && contentType.toLowerCase() === 'application/json') {\n    return true;\n  }\n\n  return false;\n};\n\nexport const parseBody = (options: BackendSrvRequest, isAppJson: boolean) => {\n  if (!options) {\n    return options;\n  }\n\n  if (!options.data || typeof options.data === 'string') {\n    return options.data;\n  }\n\n  return isAppJson ? JSON.stringify(options.data) : new URLSearchParams(options.data);\n};\n\nexport async function parseResponseBody<T>(\n  response: Response,\n  responseType?: 'json' | 'text' | 'arraybuffer' | 'blob'\n): Promise<T> {\n  if (responseType) {\n    switch (responseType) {\n      case 'arraybuffer':\n        return response.arrayBuffer() as any;\n\n      case 'blob':\n        return response.blob() as any;\n\n      case 'json':\n        // An empty string is not a valid JSON.\n        // Sometimes (unfortunately) our APIs declare their Content-Type as JSON, however they return an empty body.\n        if (response.headers.get('Content-Length') === '0') {\n          console.warn(`${response.url} returned an invalid JSON`);\n          return {} as unknown as T;\n        }\n\n        return await response.json();\n\n      case 'text':\n        return response.text() as any;\n    }\n  }\n\n  const textData = await response.text(); // this could be just a string, prometheus requests for instance\n  try {\n    return JSON.parse(textData); // majority of the requests this will be something that can be parsed\n  } catch {}\n  return textData as any;\n}\n\nexport function serializeParams(data: Record<string, any>): string {\n  return Object.keys(data)\n    .map((key) => {\n      const value = data[key];\n      if (Array.isArray(value)) {\n        return value.map((arrayValue) => `${encodeURIComponent(key)}=${encodeURIComponent(arrayValue)}`).join('&');\n      }\n      return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n    })\n    .join('&');\n}\n\nexport const parseUrlFromOptions = (options: BackendSrvRequest): string => {\n  const cleanParams = omitBy(options.params, (v) => v === undefined || (v && v.length === 0));\n  const serializedParams = serializeParams(cleanParams);\n  return options.params && serializedParams.length ? `${options.url}?${serializedParams}` : options.url;\n};\n\nexport const parseCredentials = (options: BackendSrvRequest): RequestCredentials => {\n  if (!options) {\n    return options;\n  }\n\n  if (options.credentials) {\n    return options.credentials;\n  }\n\n  if (options.withCredentials) {\n    deprecationWarning('BackendSrvRequest', 'withCredentials', 'credentials');\n    return 'include';\n  }\n\n  return 'same-origin';\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}