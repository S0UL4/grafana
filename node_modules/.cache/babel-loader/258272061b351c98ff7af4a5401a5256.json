{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { map, Observable, ReplaySubject } from 'rxjs';\nimport { isLiveChannelMessageEvent, isLiveChannelStatusEvent, LiveChannelConnectionState, LoadingState } from '@grafana/data';\nimport { StreamingFrameAction } from '@grafana/runtime/src/services/live';\nimport { toDataQueryError } from '@grafana/runtime/src/utils/toDataQueryError';\nimport { getStreamingFrameOptions, StreamingDataFrame } from '../data/StreamingDataFrame';\nimport { StreamingResponseDataType } from '../data/utils';\n\nconst bufferIfNot = canEmitObservable => source => {\n  return new Observable(subscriber => {\n    let buffer = [];\n    let canEmit = true;\n\n    const emitBuffer = () => {\n      subscriber.next(buffer);\n      buffer = [];\n    };\n\n    const canEmitSub = canEmitObservable.subscribe({\n      next: val => {\n        canEmit = val;\n\n        if (canEmit && buffer.length) {\n          emitBuffer();\n        }\n      }\n    });\n    const sourceSub = source.subscribe({\n      next(value) {\n        if (canEmit) {\n          if (!buffer.length) {\n            subscriber.next([value]);\n          } else {\n            emitBuffer();\n          }\n        } else {\n          buffer.push(value);\n        }\n      },\n\n      error(error) {\n        subscriber.error(error);\n      },\n\n      complete() {\n        subscriber.complete();\n      }\n\n    });\n    return () => {\n      sourceSub.unsubscribe();\n      canEmitSub.unsubscribe();\n    };\n  });\n};\n\nvar InternalStreamMessageType;\n\n(function (InternalStreamMessageType) {\n  InternalStreamMessageType[InternalStreamMessageType[\"Error\"] = 0] = \"Error\";\n  InternalStreamMessageType[InternalStreamMessageType[\"NewValuesSameSchema\"] = 1] = \"NewValuesSameSchema\";\n  InternalStreamMessageType[InternalStreamMessageType[\"ChangedSchema\"] = 2] = \"ChangedSchema\";\n})(InternalStreamMessageType || (InternalStreamMessageType = {}));\n\nconst reduceNewValuesSameSchemaMessages = packets => ({\n  values: packets.reduce((acc, {\n    values\n  }) => {\n    for (let i = 0; i < values.length; i++) {\n      if (!acc[i]) {\n        acc[i] = [];\n      }\n\n      for (let j = 0; j < values[i].length; j++) {\n        acc[i].push(values[i][j]);\n      }\n    }\n\n    return acc;\n  }, []),\n  type: InternalStreamMessageType.NewValuesSameSchema\n});\n\nconst filterMessages = (packets, type) => packets.filter(p => p.type === type);\n\nexport class LiveDataStream {\n  constructor(deps) {\n    _defineProperty(this, \"frameBuffer\", void 0);\n\n    _defineProperty(this, \"liveEventsSubscription\", void 0);\n\n    _defineProperty(this, \"stream\", new ReplaySubject(1));\n\n    _defineProperty(this, \"shutdownTimeoutId\", void 0);\n\n    _defineProperty(this, \"shutdown\", () => {\n      this.stream.complete();\n      this.liveEventsSubscription.unsubscribe();\n      this.deps.onShutdown();\n    });\n\n    _defineProperty(this, \"shutdownIfNoSubscribers\", () => {\n      if (!this.stream.observed) {\n        this.shutdown();\n      }\n    });\n\n    _defineProperty(this, \"onError\", err => {\n      console.log('LiveQuery [error]', {\n        err\n      }, this.deps.channelId);\n      this.stream.next({\n        type: InternalStreamMessageType.Error,\n        error: toDataQueryError(err)\n      });\n      this.shutdown();\n    });\n\n    _defineProperty(this, \"onComplete\", () => {\n      console.log('LiveQuery [complete]', this.deps.channelId);\n      this.shutdown();\n    });\n\n    _defineProperty(this, \"onNext\", evt => {\n      if (isLiveChannelMessageEvent(evt)) {\n        this.process(evt.message);\n        return;\n      }\n\n      const liveChannelStatusEvent = isLiveChannelStatusEvent(evt);\n\n      if (liveChannelStatusEvent && evt.error) {\n        this.stream.next({\n          type: InternalStreamMessageType.Error,\n          error: Object.assign({}, toDataQueryError(evt.error), {\n            message: `Streaming channel error: ${evt.error.message}`\n          })\n        });\n        return;\n      }\n\n      if (liveChannelStatusEvent && (evt.state === LiveChannelConnectionState.Connected || evt.state === LiveChannelConnectionState.Pending) && evt.message) {\n        this.process(evt.message);\n      }\n    });\n\n    _defineProperty(this, \"process\", msg => {\n      const packetInfo = this.frameBuffer.push(msg);\n\n      if (packetInfo.schemaChanged) {\n        this.stream.next({\n          type: InternalStreamMessageType.ChangedSchema\n        });\n      } else {\n        this.stream.next({\n          type: InternalStreamMessageType.NewValuesSameSchema,\n          values: this.frameBuffer.getValuesFromLastPacket()\n        });\n      }\n    });\n\n    _defineProperty(this, \"resizeBuffer\", bufferOptions => {\n      if (bufferOptions && this.frameBuffer.needsResizing(bufferOptions)) {\n        this.frameBuffer.resize(bufferOptions);\n      }\n    });\n\n    _defineProperty(this, \"prepareInternalStreamForNewSubscription\", options => {\n      if (!this.frameBuffer.hasAtLeastOnePacket() && options.frame) {\n        // will skip initial frames from subsequent subscribers\n        this.process(options.frame);\n      }\n    });\n\n    _defineProperty(this, \"clearShutdownTimeout\", () => {\n      if (this.shutdownTimeoutId) {\n        clearTimeout(this.shutdownTimeoutId);\n        this.shutdownTimeoutId = undefined;\n      }\n    });\n\n    _defineProperty(this, \"get\", (options, subKey) => {\n      var _options$buffer, _options$filter;\n\n      this.clearShutdownTimeout();\n      const buffer = getStreamingFrameOptions(options.buffer);\n      this.resizeBuffer(buffer);\n      this.prepareInternalStreamForNewSubscription(options);\n      const shouldSendLastPacketOnly = (options === null || options === void 0 ? void 0 : (_options$buffer = options.buffer) === null || _options$buffer === void 0 ? void 0 : _options$buffer.action) === StreamingFrameAction.Replace;\n      const fieldsNamesFilter = (_options$filter = options.filter) === null || _options$filter === void 0 ? void 0 : _options$filter.fields;\n      const dataNeedsFiltering = fieldsNamesFilter === null || fieldsNamesFilter === void 0 ? void 0 : fieldsNamesFilter.length;\n      const fieldFilterPredicate = dataNeedsFiltering ? ({\n        name\n      }) => fieldsNamesFilter.includes(name) : undefined;\n      let matchingFieldIndexes = undefined;\n\n      const getFullFrameResponseData = (messages, error) => {\n        matchingFieldIndexes = fieldFilterPredicate ? this.frameBuffer.getMatchingFieldIndexes(fieldFilterPredicate) : undefined;\n\n        if (!shouldSendLastPacketOnly) {\n          return {\n            key: subKey,\n            state: error ? LoadingState.Error : LoadingState.Streaming,\n            data: [{\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer)\n            }],\n            error\n          };\n        }\n\n        if (error) {\n          // send empty frame with error\n          return {\n            key: subKey,\n            state: LoadingState.Error,\n            data: [{\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, {\n                maxLength: 0\n              })\n            }],\n            error\n          };\n        }\n\n        if (!messages.length) {\n          console.warn(`expected to find at least one non error message ${messages.map(({\n            type\n          }) => type)}`); // send empty frame\n\n          return {\n            key: subKey,\n            state: LoadingState.Streaming,\n            data: [{\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, {\n                maxLength: 0\n              })\n            }],\n            error\n          };\n        }\n\n        return {\n          key: subKey,\n          state: LoadingState.Streaming,\n          data: [{\n            type: StreamingResponseDataType.FullFrame,\n            frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, {\n              maxLength: this.frameBuffer.packetInfo.length\n            })\n          }],\n          error\n        };\n      };\n\n      const getNewValuesSameSchemaResponseData = messages => {\n        const lastMessage = messages.length ? messages[messages.length - 1] : undefined;\n        const values = shouldSendLastPacketOnly && lastMessage ? lastMessage.values : reduceNewValuesSameSchemaMessages(messages).values;\n        const filteredValues = matchingFieldIndexes ? values.filter((v, i) => matchingFieldIndexes.includes(i)) : values;\n        return {\n          key: subKey,\n          state: LoadingState.Streaming,\n          data: [{\n            type: StreamingResponseDataType.NewValuesSameSchema,\n            values: filteredValues\n          }]\n        };\n      };\n\n      let shouldSendFullFrame = true;\n      const transformedInternalStream = this.stream.pipe(bufferIfNot(this.deps.subscriberReadiness), map((messages, i) => {\n        const errors = filterMessages(messages, InternalStreamMessageType.Error);\n        const lastError = errors.length ? errors[errors.length - 1].error : undefined;\n\n        if (shouldSendFullFrame) {\n          shouldSendFullFrame = false;\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        if (errors.length) {\n          // send the latest frame with the last error, discard everything else\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        const schemaChanged = messages.some(n => n.type === InternalStreamMessageType.ChangedSchema);\n\n        if (schemaChanged) {\n          // send the latest frame, discard intermediate appends\n          return getFullFrameResponseData(messages, undefined);\n        }\n\n        const newValueSameSchemaMessages = filterMessages(messages, InternalStreamMessageType.NewValuesSameSchema);\n\n        if (newValueSameSchemaMessages.length !== messages.length) {\n          console.warn(`unsupported message type ${messages.map(({\n            type\n          }) => type)}`);\n        }\n\n        return getNewValuesSameSchemaResponseData(newValueSameSchemaMessages);\n      }));\n      return new Observable(subscriber => {\n        const sub = transformedInternalStream.subscribe({\n          next: n => {\n            subscriber.next(n);\n          },\n          error: err => {\n            subscriber.error(err);\n          },\n          complete: () => {\n            subscriber.complete();\n          }\n        });\n        return () => {\n          // TODO: potentially resize (downsize) the buffer on unsubscribe\n          sub.unsubscribe();\n\n          if (!this.stream.observed) {\n            this.clearShutdownTimeout();\n            this.shutdownTimeoutId = setTimeout(this.shutdownIfNoSubscribers, this.deps.shutdownDelayInMs);\n          }\n        };\n      });\n    });\n\n    this.deps = deps;\n    this.frameBuffer = StreamingDataFrame.empty(deps.defaultStreamingFrameOptions);\n    this.liveEventsSubscription = deps.liveEventsObservable.subscribe({\n      error: this.onError,\n      complete: this.onComplete,\n      next: this.onNext\n    });\n  }\n\n}","map":{"version":3,"names":["map","Observable","ReplaySubject","isLiveChannelMessageEvent","isLiveChannelStatusEvent","LiveChannelConnectionState","LoadingState","StreamingFrameAction","toDataQueryError","getStreamingFrameOptions","StreamingDataFrame","StreamingResponseDataType","bufferIfNot","canEmitObservable","source","subscriber","buffer","canEmit","emitBuffer","next","canEmitSub","subscribe","val","length","sourceSub","value","push","error","complete","unsubscribe","InternalStreamMessageType","reduceNewValuesSameSchemaMessages","packets","values","reduce","acc","i","j","type","NewValuesSameSchema","filterMessages","filter","p","LiveDataStream","constructor","deps","stream","liveEventsSubscription","onShutdown","observed","shutdown","err","console","log","channelId","Error","evt","process","message","liveChannelStatusEvent","state","Connected","Pending","msg","packetInfo","frameBuffer","schemaChanged","ChangedSchema","getValuesFromLastPacket","bufferOptions","needsResizing","resize","options","hasAtLeastOnePacket","frame","shutdownTimeoutId","clearTimeout","undefined","subKey","clearShutdownTimeout","resizeBuffer","prepareInternalStreamForNewSubscription","shouldSendLastPacketOnly","action","Replace","fieldsNamesFilter","fields","dataNeedsFiltering","fieldFilterPredicate","name","includes","matchingFieldIndexes","getFullFrameResponseData","messages","getMatchingFieldIndexes","key","Streaming","data","FullFrame","serialize","maxLength","warn","getNewValuesSameSchemaResponseData","lastMessage","filteredValues","v","shouldSendFullFrame","transformedInternalStream","pipe","subscriberReadiness","errors","lastError","some","n","newValueSameSchemaMessages","sub","setTimeout","shutdownIfNoSubscribers","shutdownDelayInMs","empty","defaultStreamingFrameOptions","liveEventsObservable","onError","onComplete","onNext"],"sources":["/home/soula/grafana/public/app/features/live/centrifuge/LiveDataStream.ts"],"sourcesContent":["import { map, Observable, ReplaySubject, Subject, Subscriber, Subscription } from 'rxjs';\n\nimport {\n  DataFrameJSON,\n  DataQueryError,\n  Field,\n  isLiveChannelMessageEvent,\n  isLiveChannelStatusEvent,\n  LiveChannelConnectionState,\n  LiveChannelEvent,\n  LiveChannelId,\n  LoadingState,\n} from '@grafana/data';\nimport { LiveDataStreamOptions, StreamingFrameAction, StreamingFrameOptions } from '@grafana/runtime/src/services/live';\nimport { toDataQueryError } from '@grafana/runtime/src/utils/toDataQueryError';\n\nimport { getStreamingFrameOptions, StreamingDataFrame } from '../data/StreamingDataFrame';\nimport { StreamingResponseDataType } from '../data/utils';\n\nimport { DataStreamSubscriptionKey, StreamingDataQueryResponse } from './service';\n\nconst bufferIfNot =\n  (canEmitObservable: Observable<boolean>) =>\n  <T>(source: Observable<T>): Observable<T[]> => {\n    return new Observable((subscriber: Subscriber<T[]>) => {\n      let buffer: T[] = [];\n      let canEmit = true;\n\n      const emitBuffer = () => {\n        subscriber.next(buffer);\n        buffer = [];\n      };\n\n      const canEmitSub = canEmitObservable.subscribe({\n        next: (val) => {\n          canEmit = val;\n\n          if (canEmit && buffer.length) {\n            emitBuffer();\n          }\n        },\n      });\n\n      const sourceSub = source.subscribe({\n        next(value) {\n          if (canEmit) {\n            if (!buffer.length) {\n              subscriber.next([value]);\n            } else {\n              emitBuffer();\n            }\n          } else {\n            buffer.push(value);\n          }\n        },\n        error(error) {\n          subscriber.error(error);\n        },\n        complete() {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        sourceSub.unsubscribe();\n        canEmitSub.unsubscribe();\n      };\n    });\n  };\n\nexport type DataStreamHandlerDeps<T> = {\n  channelId: LiveChannelId;\n  liveEventsObservable: Observable<LiveChannelEvent<T>>;\n  onShutdown: () => void;\n  subscriberReadiness: Observable<boolean>;\n  defaultStreamingFrameOptions: Readonly<StreamingFrameOptions>;\n  shutdownDelayInMs: number;\n};\n\nenum InternalStreamMessageType {\n  Error,\n  NewValuesSameSchema,\n  ChangedSchema,\n}\n\ntype InternalStreamMessageTypeToData = {\n  [InternalStreamMessageType.Error]: {\n    error: DataQueryError;\n  };\n  [InternalStreamMessageType.ChangedSchema]: {};\n  [InternalStreamMessageType.NewValuesSameSchema]: {\n    values: unknown[][];\n  };\n};\n\ntype InternalStreamMessage<T = InternalStreamMessageType> = T extends InternalStreamMessageType\n  ? {\n      type: T;\n    } & InternalStreamMessageTypeToData[T]\n  : never;\n\nconst reduceNewValuesSameSchemaMessages = (\n  packets: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n) => ({\n  values: packets.reduce((acc, { values }) => {\n    for (let i = 0; i < values.length; i++) {\n      if (!acc[i]) {\n        acc[i] = [];\n      }\n      for (let j = 0; j < values[i].length; j++) {\n        acc[i].push(values[i][j]);\n      }\n    }\n    return acc;\n  }, [] as unknown[][]),\n  type: InternalStreamMessageType.NewValuesSameSchema,\n});\n\nconst filterMessages = <T extends InternalStreamMessageType>(\n  packets: InternalStreamMessage[],\n  type: T\n): Array<InternalStreamMessage<T>> => packets.filter((p) => p.type === type) as Array<InternalStreamMessage<T>>;\n\nexport class LiveDataStream<T = unknown> {\n  private frameBuffer: StreamingDataFrame;\n  private liveEventsSubscription: Subscription;\n  private stream: Subject<InternalStreamMessage> = new ReplaySubject(1);\n  private shutdownTimeoutId: ReturnType<typeof setTimeout> | undefined;\n\n  constructor(private deps: DataStreamHandlerDeps<T>) {\n    this.frameBuffer = StreamingDataFrame.empty(deps.defaultStreamingFrameOptions);\n    this.liveEventsSubscription = deps.liveEventsObservable.subscribe({\n      error: this.onError,\n      complete: this.onComplete,\n      next: this.onNext,\n    });\n  }\n\n  private shutdown = () => {\n    this.stream.complete();\n    this.liveEventsSubscription.unsubscribe();\n    this.deps.onShutdown();\n  };\n\n  private shutdownIfNoSubscribers = () => {\n    if (!this.stream.observed) {\n      this.shutdown();\n    }\n  };\n\n  private onError = (err: any) => {\n    console.log('LiveQuery [error]', { err }, this.deps.channelId);\n    this.stream.next({\n      type: InternalStreamMessageType.Error,\n      error: toDataQueryError(err),\n    });\n    this.shutdown();\n  };\n\n  private onComplete = () => {\n    console.log('LiveQuery [complete]', this.deps.channelId);\n    this.shutdown();\n  };\n\n  private onNext = (evt: LiveChannelEvent) => {\n    if (isLiveChannelMessageEvent(evt)) {\n      this.process(evt.message);\n      return;\n    }\n\n    const liveChannelStatusEvent = isLiveChannelStatusEvent(evt);\n    if (liveChannelStatusEvent && evt.error) {\n      this.stream.next({\n        type: InternalStreamMessageType.Error,\n        error: {\n          ...toDataQueryError(evt.error),\n          message: `Streaming channel error: ${evt.error.message}`,\n        },\n      });\n      return;\n    }\n\n    if (\n      liveChannelStatusEvent &&\n      (evt.state === LiveChannelConnectionState.Connected || evt.state === LiveChannelConnectionState.Pending) &&\n      evt.message\n    ) {\n      this.process(evt.message);\n    }\n  };\n\n  private process = (msg: DataFrameJSON) => {\n    const packetInfo = this.frameBuffer.push(msg);\n\n    if (packetInfo.schemaChanged) {\n      this.stream.next({\n        type: InternalStreamMessageType.ChangedSchema,\n      });\n    } else {\n      this.stream.next({\n        type: InternalStreamMessageType.NewValuesSameSchema,\n        values: this.frameBuffer.getValuesFromLastPacket(),\n      });\n    }\n  };\n\n  private resizeBuffer = (bufferOptions: StreamingFrameOptions) => {\n    if (bufferOptions && this.frameBuffer.needsResizing(bufferOptions)) {\n      this.frameBuffer.resize(bufferOptions);\n    }\n  };\n\n  private prepareInternalStreamForNewSubscription = (options: LiveDataStreamOptions): void => {\n    if (!this.frameBuffer.hasAtLeastOnePacket() && options.frame) {\n      // will skip initial frames from subsequent subscribers\n      this.process(options.frame);\n    }\n  };\n\n  private clearShutdownTimeout = () => {\n    if (this.shutdownTimeoutId) {\n      clearTimeout(this.shutdownTimeoutId);\n      this.shutdownTimeoutId = undefined;\n    }\n  };\n\n  get = (options: LiveDataStreamOptions, subKey: DataStreamSubscriptionKey): Observable<StreamingDataQueryResponse> => {\n    this.clearShutdownTimeout();\n    const buffer = getStreamingFrameOptions(options.buffer);\n\n    this.resizeBuffer(buffer);\n    this.prepareInternalStreamForNewSubscription(options);\n\n    const shouldSendLastPacketOnly = options?.buffer?.action === StreamingFrameAction.Replace;\n    const fieldsNamesFilter = options.filter?.fields;\n    const dataNeedsFiltering = fieldsNamesFilter?.length;\n    const fieldFilterPredicate = dataNeedsFiltering ? ({ name }: Field) => fieldsNamesFilter.includes(name) : undefined;\n    let matchingFieldIndexes: number[] | undefined = undefined;\n\n    const getFullFrameResponseData = <T>(\n      messages: InternalStreamMessage[],\n      error?: DataQueryError\n    ): StreamingDataQueryResponse => {\n      matchingFieldIndexes = fieldFilterPredicate\n        ? this.frameBuffer.getMatchingFieldIndexes(fieldFilterPredicate)\n        : undefined;\n\n      if (!shouldSendLastPacketOnly) {\n        return {\n          key: subKey,\n          state: error ? LoadingState.Error : LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (error) {\n        // send empty frame with error\n        return {\n          key: subKey,\n          state: LoadingState.Error,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (!messages.length) {\n        console.warn(`expected to find at least one non error message ${messages.map(({ type }) => type)}`);\n        // send empty frame\n        return {\n          key: subKey,\n          state: LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.FullFrame,\n            frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, {\n              maxLength: this.frameBuffer.packetInfo.length,\n            }),\n          },\n        ],\n        error,\n      };\n    };\n\n    const getNewValuesSameSchemaResponseData = (\n      messages: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n    ): StreamingDataQueryResponse => {\n      const lastMessage = messages.length ? messages[messages.length - 1] : undefined;\n      const values =\n        shouldSendLastPacketOnly && lastMessage\n          ? lastMessage.values\n          : reduceNewValuesSameSchemaMessages(messages).values;\n\n      const filteredValues = matchingFieldIndexes\n        ? values.filter((v, i) => (matchingFieldIndexes as number[]).includes(i))\n        : values;\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.NewValuesSameSchema,\n            values: filteredValues,\n          },\n        ],\n      };\n    };\n\n    let shouldSendFullFrame = true;\n    const transformedInternalStream = this.stream.pipe(\n      bufferIfNot(this.deps.subscriberReadiness),\n      map((messages, i) => {\n        const errors = filterMessages(messages, InternalStreamMessageType.Error);\n        const lastError = errors.length ? errors[errors.length - 1].error : undefined;\n\n        if (shouldSendFullFrame) {\n          shouldSendFullFrame = false;\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        if (errors.length) {\n          // send the latest frame with the last error, discard everything else\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        const schemaChanged = messages.some((n) => n.type === InternalStreamMessageType.ChangedSchema);\n        if (schemaChanged) {\n          // send the latest frame, discard intermediate appends\n          return getFullFrameResponseData(messages, undefined);\n        }\n\n        const newValueSameSchemaMessages = filterMessages(messages, InternalStreamMessageType.NewValuesSameSchema);\n        if (newValueSameSchemaMessages.length !== messages.length) {\n          console.warn(`unsupported message type ${messages.map(({ type }) => type)}`);\n        }\n\n        return getNewValuesSameSchemaResponseData(newValueSameSchemaMessages);\n      })\n    );\n\n    return new Observable<StreamingDataQueryResponse>((subscriber) => {\n      const sub = transformedInternalStream.subscribe({\n        next: (n) => {\n          subscriber.next(n);\n        },\n        error: (err) => {\n          subscriber.error(err);\n        },\n        complete: () => {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        // TODO: potentially resize (downsize) the buffer on unsubscribe\n        sub.unsubscribe();\n        if (!this.stream.observed) {\n          this.clearShutdownTimeout();\n          this.shutdownTimeoutId = setTimeout(this.shutdownIfNoSubscribers, this.deps.shutdownDelayInMs);\n        }\n      };\n    });\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}