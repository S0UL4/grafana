{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Libraries\nimport { pickBy } from 'lodash'; // Utils\n\nimport { locationUtil, urlUtil, rangeUtil } from '@grafana/data';\nimport { getBackendSrv, locationService } from '@grafana/runtime';\nexport const queryParamsToPreserve = {\n  kiosk: true,\n  autofitpanels: true,\n  orgId: true\n};\nexport class PlaylistSrv {\n  constructor() {\n    _defineProperty(this, \"nextTimeoutId\", void 0);\n\n    _defineProperty(this, \"index\", 0);\n\n    _defineProperty(this, \"numberOfLoops\", 0);\n\n    _defineProperty(this, \"locationListenerUnsub\", void 0);\n\n    _defineProperty(this, \"isPlaying\", false);\n\n    this.locationUpdated = this.locationUpdated.bind(this);\n  }\n\n  next() {\n    clearTimeout(this.nextTimeoutId);\n    const playedAllDashboards = this.index > this.dashboards.length - 1;\n\n    if (playedAllDashboards) {\n      this.numberOfLoops++; // This does full reload of the playlist to keep memory in check due to existing leaks but at the same time\n      // we do not want page to flicker after each full loop.\n\n      if (this.numberOfLoops >= 3) {\n        window.location.href = this.startUrl;\n        return;\n      }\n\n      this.index = 0;\n    }\n\n    const dash = this.dashboards[this.index];\n    const queryParams = locationService.getSearchObject();\n    const filteredParams = pickBy(queryParams, (value, key) => queryParamsToPreserve[key]);\n    const nextDashboardUrl = locationUtil.stripBaseFromUrl(dash.url);\n    this.index++;\n    this.validPlaylistUrl = nextDashboardUrl;\n    this.nextTimeoutId = setTimeout(() => this.next(), this.interval);\n    locationService.push(nextDashboardUrl + '?' + urlUtil.toUrlParams(filteredParams));\n  }\n\n  prev() {\n    this.index = Math.max(this.index - 2, 0);\n    this.next();\n  } // Detect url changes not caused by playlist srv and stop playlist\n\n\n  locationUpdated(location) {\n    if (location.pathname !== this.validPlaylistUrl) {\n      this.stop();\n    }\n  }\n\n  start(playlistUid) {\n    this.stop();\n    this.startUrl = window.location.href;\n    this.index = 0;\n    this.isPlaying = true; // setup location tracking\n\n    this.locationListenerUnsub = locationService.getHistory().listen(this.locationUpdated);\n    return getBackendSrv().get(`/api/playlists/${playlistUid}`).then(playlist => {\n      return getBackendSrv().get(`/api/playlists/${playlistUid}/dashboards`).then(dashboards => {\n        this.dashboards = dashboards;\n        this.interval = rangeUtil.intervalToMs(playlist.interval);\n        this.next();\n      });\n    });\n  }\n\n  stop() {\n    if (!this.isPlaying) {\n      return;\n    }\n\n    this.index = 0;\n    this.isPlaying = false;\n\n    if (this.locationListenerUnsub) {\n      this.locationListenerUnsub();\n    }\n\n    if (this.nextTimeoutId) {\n      clearTimeout(this.nextTimeoutId);\n    }\n\n    if (locationService.getSearchObject().kiosk) {\n      locationService.partial({\n        kiosk: null\n      });\n    }\n  }\n\n}\nexport const playlistSrv = new PlaylistSrv();","map":{"version":3,"names":["pickBy","locationUtil","urlUtil","rangeUtil","getBackendSrv","locationService","queryParamsToPreserve","kiosk","autofitpanels","orgId","PlaylistSrv","constructor","locationUpdated","bind","next","clearTimeout","nextTimeoutId","playedAllDashboards","index","dashboards","length","numberOfLoops","window","location","href","startUrl","dash","queryParams","getSearchObject","filteredParams","value","key","nextDashboardUrl","stripBaseFromUrl","url","validPlaylistUrl","setTimeout","interval","push","toUrlParams","prev","Math","max","pathname","stop","start","playlistUid","isPlaying","locationListenerUnsub","getHistory","listen","get","then","playlist","intervalToMs","partial","playlistSrv"],"sources":["/home/soula/grafana/public/app/features/playlist/PlaylistSrv.ts"],"sourcesContent":["// Libraries\nimport { Location } from 'history';\nimport { pickBy } from 'lodash';\n\n// Utils\nimport { locationUtil, urlUtil, rangeUtil } from '@grafana/data';\nimport { getBackendSrv, locationService } from '@grafana/runtime';\n\nexport const queryParamsToPreserve: { [key: string]: boolean } = {\n  kiosk: true,\n  autofitpanels: true,\n  orgId: true,\n};\n\nexport class PlaylistSrv {\n  private nextTimeoutId: any;\n  private declare dashboards: Array<{ url: string }>;\n  private index = 0;\n  private declare interval: number;\n  private declare startUrl: string;\n  private numberOfLoops = 0;\n  private declare validPlaylistUrl: string;\n  private locationListenerUnsub?: () => void;\n\n  isPlaying = false;\n\n  constructor() {\n    this.locationUpdated = this.locationUpdated.bind(this);\n  }\n\n  next() {\n    clearTimeout(this.nextTimeoutId);\n\n    const playedAllDashboards = this.index > this.dashboards.length - 1;\n    if (playedAllDashboards) {\n      this.numberOfLoops++;\n\n      // This does full reload of the playlist to keep memory in check due to existing leaks but at the same time\n      // we do not want page to flicker after each full loop.\n      if (this.numberOfLoops >= 3) {\n        window.location.href = this.startUrl;\n        return;\n      }\n      this.index = 0;\n    }\n\n    const dash = this.dashboards[this.index];\n    const queryParams = locationService.getSearchObject();\n    const filteredParams = pickBy(queryParams, (value: any, key: string) => queryParamsToPreserve[key]);\n    const nextDashboardUrl = locationUtil.stripBaseFromUrl(dash.url);\n\n    this.index++;\n    this.validPlaylistUrl = nextDashboardUrl;\n    this.nextTimeoutId = setTimeout(() => this.next(), this.interval);\n\n    locationService.push(nextDashboardUrl + '?' + urlUtil.toUrlParams(filteredParams));\n  }\n\n  prev() {\n    this.index = Math.max(this.index - 2, 0);\n    this.next();\n  }\n\n  // Detect url changes not caused by playlist srv and stop playlist\n  locationUpdated(location: Location) {\n    if (location.pathname !== this.validPlaylistUrl) {\n      this.stop();\n    }\n  }\n\n  start(playlistUid: string) {\n    this.stop();\n\n    this.startUrl = window.location.href;\n    this.index = 0;\n    this.isPlaying = true;\n\n    // setup location tracking\n    this.locationListenerUnsub = locationService.getHistory().listen(this.locationUpdated);\n\n    return getBackendSrv()\n      .get(`/api/playlists/${playlistUid}`)\n      .then((playlist: any) => {\n        return getBackendSrv()\n          .get(`/api/playlists/${playlistUid}/dashboards`)\n          .then((dashboards: any) => {\n            this.dashboards = dashboards;\n            this.interval = rangeUtil.intervalToMs(playlist.interval);\n            this.next();\n          });\n      });\n  }\n\n  stop() {\n    if (!this.isPlaying) {\n      return;\n    }\n\n    this.index = 0;\n    this.isPlaying = false;\n\n    if (this.locationListenerUnsub) {\n      this.locationListenerUnsub();\n    }\n\n    if (this.nextTimeoutId) {\n      clearTimeout(this.nextTimeoutId);\n    }\n\n    if (locationService.getSearchObject().kiosk) {\n      locationService.partial({ kiosk: null });\n    }\n  }\n}\n\nexport const playlistSrv = new PlaylistSrv();\n"],"mappings":";;AAAA;AAEA,SAASA,MAAT,QAAuB,QAAvB,C,CAEA;;AACA,SAASC,YAAT,EAAuBC,OAAvB,EAAgCC,SAAhC,QAAiD,eAAjD;AACA,SAASC,aAAT,EAAwBC,eAAxB,QAA+C,kBAA/C;AAEA,OAAO,MAAMC,qBAAiD,GAAG;EAC/DC,KAAK,EAAE,IADwD;EAE/DC,aAAa,EAAE,IAFgD;EAG/DC,KAAK,EAAE;AAHwD,CAA1D;AAMP,OAAO,MAAMC,WAAN,CAAkB;EAYvBC,WAAW,GAAG;IAAA;;IAAA,+BATE,CASF;;IAAA,uCANU,CAMV;;IAAA;;IAAA,mCAFF,KAEE;;IACZ,KAAKC,eAAL,GAAuB,KAAKA,eAAL,CAAqBC,IAArB,CAA0B,IAA1B,CAAvB;EACD;;EAEDC,IAAI,GAAG;IACLC,YAAY,CAAC,KAAKC,aAAN,CAAZ;IAEA,MAAMC,mBAAmB,GAAG,KAAKC,KAAL,GAAa,KAAKC,UAAL,CAAgBC,MAAhB,GAAyB,CAAlE;;IACA,IAAIH,mBAAJ,EAAyB;MACvB,KAAKI,aAAL,GADuB,CAGvB;MACA;;MACA,IAAI,KAAKA,aAAL,IAAsB,CAA1B,EAA6B;QAC3BC,MAAM,CAACC,QAAP,CAAgBC,IAAhB,GAAuB,KAAKC,QAA5B;QACA;MACD;;MACD,KAAKP,KAAL,GAAa,CAAb;IACD;;IAED,MAAMQ,IAAI,GAAG,KAAKP,UAAL,CAAgB,KAAKD,KAArB,CAAb;IACA,MAAMS,WAAW,GAAGtB,eAAe,CAACuB,eAAhB,EAApB;IACA,MAAMC,cAAc,GAAG7B,MAAM,CAAC2B,WAAD,EAAc,CAACG,KAAD,EAAaC,GAAb,KAA6BzB,qBAAqB,CAACyB,GAAD,CAAhE,CAA7B;IACA,MAAMC,gBAAgB,GAAG/B,YAAY,CAACgC,gBAAb,CAA8BP,IAAI,CAACQ,GAAnC,CAAzB;IAEA,KAAKhB,KAAL;IACA,KAAKiB,gBAAL,GAAwBH,gBAAxB;IACA,KAAKhB,aAAL,GAAqBoB,UAAU,CAAC,MAAM,KAAKtB,IAAL,EAAP,EAAoB,KAAKuB,QAAzB,CAA/B;IAEAhC,eAAe,CAACiC,IAAhB,CAAqBN,gBAAgB,GAAG,GAAnB,GAAyB9B,OAAO,CAACqC,WAAR,CAAoBV,cAApB,CAA9C;EACD;;EAEDW,IAAI,GAAG;IACL,KAAKtB,KAAL,GAAauB,IAAI,CAACC,GAAL,CAAS,KAAKxB,KAAL,GAAa,CAAtB,EAAyB,CAAzB,CAAb;IACA,KAAKJ,IAAL;EACD,CA/CsB,CAiDvB;;;EACAF,eAAe,CAACW,QAAD,EAAqB;IAClC,IAAIA,QAAQ,CAACoB,QAAT,KAAsB,KAAKR,gBAA/B,EAAiD;MAC/C,KAAKS,IAAL;IACD;EACF;;EAEDC,KAAK,CAACC,WAAD,EAAsB;IACzB,KAAKF,IAAL;IAEA,KAAKnB,QAAL,GAAgBH,MAAM,CAACC,QAAP,CAAgBC,IAAhC;IACA,KAAKN,KAAL,GAAa,CAAb;IACA,KAAK6B,SAAL,GAAiB,IAAjB,CALyB,CAOzB;;IACA,KAAKC,qBAAL,GAA6B3C,eAAe,CAAC4C,UAAhB,GAA6BC,MAA7B,CAAoC,KAAKtC,eAAzC,CAA7B;IAEA,OAAOR,aAAa,GACjB+C,GADI,CACC,kBAAiBL,WAAY,EAD9B,EAEJM,IAFI,CAEEC,QAAD,IAAmB;MACvB,OAAOjD,aAAa,GACjB+C,GADI,CACC,kBAAiBL,WAAY,aAD9B,EAEJM,IAFI,CAEEjC,UAAD,IAAqB;QACzB,KAAKA,UAAL,GAAkBA,UAAlB;QACA,KAAKkB,QAAL,GAAgBlC,SAAS,CAACmD,YAAV,CAAuBD,QAAQ,CAAChB,QAAhC,CAAhB;QACA,KAAKvB,IAAL;MACD,CANI,CAAP;IAOD,CAVI,CAAP;EAWD;;EAED8B,IAAI,GAAG;IACL,IAAI,CAAC,KAAKG,SAAV,EAAqB;MACnB;IACD;;IAED,KAAK7B,KAAL,GAAa,CAAb;IACA,KAAK6B,SAAL,GAAiB,KAAjB;;IAEA,IAAI,KAAKC,qBAAT,EAAgC;MAC9B,KAAKA,qBAAL;IACD;;IAED,IAAI,KAAKhC,aAAT,EAAwB;MACtBD,YAAY,CAAC,KAAKC,aAAN,CAAZ;IACD;;IAED,IAAIX,eAAe,CAACuB,eAAhB,GAAkCrB,KAAtC,EAA6C;MAC3CF,eAAe,CAACkD,OAAhB,CAAwB;QAAEhD,KAAK,EAAE;MAAT,CAAxB;IACD;EACF;;AAlGsB;AAqGzB,OAAO,MAAMiD,WAAW,GAAG,IAAI9C,WAAJ,EAApB"},"metadata":{},"sourceType":"module"}