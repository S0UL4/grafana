{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Library\nimport React, { PureComponent } from 'react';\nimport tinycolor from 'tinycolor2';\nimport { FALLBACK_COLOR, FieldColorModeId, formattedValueToString, GAUGE_DEFAULT_MAXIMUM, GAUGE_DEFAULT_MINIMUM, getFieldColorMode, ThresholdsMode, VizOrientation } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { calculateFontSize, measureText } from '../../utils/measureText';\nimport { FormattedValueDisplay } from '../FormattedValueDisplay/FormattedValueDisplay';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst MIN_VALUE_HEIGHT = 18;\nconst MAX_VALUE_HEIGHT = 50;\nconst MAX_VALUE_WIDTH = 150;\nconst TITLE_LINE_HEIGHT = 1.5;\nconst VALUE_LINE_HEIGHT = 1;\nconst VALUE_LEFT_PADDING = 10;\nexport let BarGaugeDisplayMode;\n\n(function (BarGaugeDisplayMode) {\n  BarGaugeDisplayMode[\"Basic\"] = \"basic\";\n  BarGaugeDisplayMode[\"Lcd\"] = \"lcd\";\n  BarGaugeDisplayMode[\"Gradient\"] = \"gradient\";\n})(BarGaugeDisplayMode || (BarGaugeDisplayMode = {}));\n\nexport class BarGauge extends PureComponent {\n  render() {\n    const {\n      onClick,\n      className\n    } = this.props;\n    const {\n      title\n    } = this.props.value;\n    const styles = getTitleStyles(this.props);\n\n    if (!title) {\n      return /*#__PURE__*/_jsx(\"div\", {\n        style: styles.wrapper,\n        onClick: onClick,\n        className: className,\n        children: this.renderBarAndValue()\n      });\n    }\n\n    return /*#__PURE__*/_jsxs(\"div\", {\n      style: styles.wrapper,\n      onClick: onClick,\n      className: className,\n      children: [/*#__PURE__*/_jsx(\"div\", {\n        style: styles.title,\n        children: title\n      }), this.renderBarAndValue()]\n    });\n  }\n\n  renderBarAndValue() {\n    switch (this.props.displayMode) {\n      case 'lcd':\n        return this.renderRetroBars();\n\n      case 'basic':\n      case 'gradient':\n      default:\n        return this.renderBasicAndGradientBars();\n    }\n  }\n\n  renderBasicAndGradientBars() {\n    const {\n      value,\n      showUnfilled\n    } = this.props;\n    const styles = getBasicAndGradientStyles(this.props);\n    return /*#__PURE__*/_jsxs(\"div\", {\n      style: styles.wrapper,\n      children: [/*#__PURE__*/_jsx(FormattedValueDisplay, {\n        \"data-testid\": selectors.components.Panels.Visualization.BarGauge.valueV2,\n        value: value,\n        style: styles.value\n      }), showUnfilled && /*#__PURE__*/_jsx(\"div\", {\n        style: styles.emptyBar\n      }), /*#__PURE__*/_jsx(\"div\", {\n        style: styles.bar\n      })]\n    });\n  }\n\n  renderRetroBars() {\n    var _field$min, _field$max;\n\n    const {\n      display,\n      field,\n      value,\n      itemSpacing,\n      alignmentFactors,\n      orientation,\n      lcdCellWidth,\n      text\n    } = this.props;\n    const {\n      valueHeight,\n      valueWidth,\n      maxBarHeight,\n      maxBarWidth,\n      wrapperWidth,\n      wrapperHeight\n    } = calculateBarAndValueDimensions(this.props);\n    const minValue = (_field$min = field.min) !== null && _field$min !== void 0 ? _field$min : GAUGE_DEFAULT_MINIMUM;\n    const maxValue = (_field$max = field.max) !== null && _field$max !== void 0 ? _field$max : GAUGE_DEFAULT_MAXIMUM;\n    const isVert = isVertical(orientation);\n    const valueRange = maxValue - minValue;\n    const maxSize = isVert ? maxBarHeight : maxBarWidth;\n    const cellSpacing = itemSpacing;\n    const cellCount = Math.floor(maxSize / lcdCellWidth);\n    const cellSize = Math.floor((maxSize - cellSpacing * cellCount) / cellCount);\n    const valueColor = getValueColor(this.props);\n    const valueToBaseSizeOn = alignmentFactors ? alignmentFactors : value;\n    const valueStyles = getValueStyles(valueToBaseSizeOn, valueColor, valueWidth, valueHeight, orientation, text);\n    const containerStyles = {\n      width: `${wrapperWidth}px`,\n      height: `${wrapperHeight}px`,\n      display: 'flex'\n    };\n\n    if (isVert) {\n      containerStyles.flexDirection = 'column-reverse';\n      containerStyles.alignItems = 'center';\n    } else {\n      containerStyles.flexDirection = 'row';\n      containerStyles.alignItems = 'center';\n      valueStyles.justifyContent = 'flex-end';\n    }\n\n    const cells = [];\n\n    for (let i = 0; i < cellCount; i++) {\n      const currentValue = minValue + valueRange / cellCount * i;\n      const cellColor = getCellColor(currentValue, value, display);\n      const cellStyles = {\n        borderRadius: '2px'\n      };\n\n      if (cellColor.isLit) {\n        cellStyles.backgroundImage = `radial-gradient(${cellColor.background} 10%, ${cellColor.backgroundShade})`;\n      } else {\n        cellStyles.backgroundColor = cellColor.background;\n      }\n\n      if (isVert) {\n        cellStyles.height = `${cellSize}px`;\n        cellStyles.width = `${maxBarWidth}px`;\n        cellStyles.marginTop = `${cellSpacing}px`;\n      } else {\n        cellStyles.width = `${cellSize}px`;\n        cellStyles.height = `${maxBarHeight}px`;\n        cellStyles.marginRight = `${cellSpacing}px`;\n      }\n\n      cells.push( /*#__PURE__*/_jsx(\"div\", {\n        style: cellStyles\n      }, i.toString()));\n    }\n\n    return /*#__PURE__*/_jsxs(\"div\", {\n      style: containerStyles,\n      children: [cells, /*#__PURE__*/_jsx(FormattedValueDisplay, {\n        \"data-testid\": selectors.components.Panels.Visualization.BarGauge.valueV2,\n        value: value,\n        style: valueStyles\n      })]\n    });\n  }\n\n}\n\n_defineProperty(BarGauge, \"defaultProps\", {\n  lcdCellWidth: 12,\n  value: {\n    text: '100',\n    numeric: 100\n  },\n  displayMode: BarGaugeDisplayMode.Gradient,\n  orientation: VizOrientation.Horizontal,\n  field: {\n    min: 0,\n    max: 100,\n    thresholds: {\n      mode: ThresholdsMode.Absolute,\n      steps: []\n    }\n  },\n  itemSpacing: 8,\n  showUnfilled: true\n});\n\nfunction isVertical(orientation) {\n  return orientation === VizOrientation.Vertical;\n}\n\nfunction calculateTitleDimensions(props) {\n  var _text$titleSize2;\n\n  const {\n    height,\n    width,\n    alignmentFactors,\n    orientation,\n    text\n  } = props;\n  const title = alignmentFactors ? alignmentFactors.title : props.value.title;\n\n  if (!title) {\n    return {\n      fontSize: 0,\n      width: 0,\n      height: 0,\n      placement: 'above'\n    };\n  }\n\n  if (isVertical(orientation)) {\n    var _text$titleSize;\n\n    const fontSize = (_text$titleSize = text === null || text === void 0 ? void 0 : text.titleSize) !== null && _text$titleSize !== void 0 ? _text$titleSize : 14;\n    return {\n      fontSize: fontSize,\n      width: width,\n      height: fontSize * TITLE_LINE_HEIGHT,\n      placement: 'below'\n    };\n  } // if height above 40 put text to above bar\n\n\n  if (height > 40) {\n    if (text !== null && text !== void 0 && text.titleSize) {\n      return {\n        fontSize: text === null || text === void 0 ? void 0 : text.titleSize,\n        width: 0,\n        height: text.titleSize * TITLE_LINE_HEIGHT,\n        placement: 'above'\n      };\n    }\n\n    const maxTitleHeightRatio = 0.45;\n    const titleHeight = Math.max(Math.min(height * maxTitleHeightRatio, MAX_VALUE_HEIGHT), 17);\n    return {\n      fontSize: titleHeight / TITLE_LINE_HEIGHT,\n      width: 0,\n      height: titleHeight,\n      placement: 'above'\n    };\n  } // title to left of bar scenario\n\n\n  const maxTitleHeightRatio = 0.6;\n  const titleHeight = Math.max(height * maxTitleHeightRatio, MIN_VALUE_HEIGHT);\n  const titleFontSize = titleHeight / TITLE_LINE_HEIGHT;\n  const textSize = measureText(title, titleFontSize); // Do not allow title to take up more than 40% width\n\n  const textWidth = Math.min(textSize.width + 15, width * 0.4);\n  return {\n    fontSize: (_text$titleSize2 = text === null || text === void 0 ? void 0 : text.titleSize) !== null && _text$titleSize2 !== void 0 ? _text$titleSize2 : titleFontSize,\n    height: 0,\n    width: textWidth,\n    placement: 'left'\n  };\n}\n\nexport function getTitleStyles(props) {\n  const wrapperStyles = {\n    display: 'flex',\n    overflow: 'hidden',\n    width: '100%'\n  };\n  const titleDim = calculateTitleDimensions(props);\n  const titleStyles = {\n    fontSize: `${titleDim.fontSize}px`,\n    whiteSpace: 'nowrap',\n    overflow: 'hidden',\n    textOverflow: 'ellipsis',\n    width: '100%',\n    alignItems: 'center',\n    alignSelf: 'center'\n  };\n\n  if (isVertical(props.orientation)) {\n    wrapperStyles.flexDirection = 'column-reverse';\n    titleStyles.textAlign = 'center';\n  } else {\n    if (titleDim.placement === 'above') {\n      wrapperStyles.flexDirection = 'column';\n    } else {\n      wrapperStyles.flexDirection = 'row';\n      titleStyles.width = `${titleDim.width}px`;\n      titleStyles.textAlign = 'right';\n      titleStyles.paddingRight = '10px';\n    }\n  }\n\n  return {\n    wrapper: wrapperStyles,\n    title: titleStyles\n  };\n}\n\n/**\n * @internal\n * Only exported for unit tests\n **/\nexport function calculateBarAndValueDimensions(props) {\n  var _text$valueSize;\n\n  const {\n    height,\n    width,\n    orientation,\n    text,\n    alignmentFactors\n  } = props;\n  const titleDim = calculateTitleDimensions(props);\n  const value = alignmentFactors !== null && alignmentFactors !== void 0 ? alignmentFactors : props.value;\n  const valueString = formattedValueToString(value);\n  let maxBarHeight = 0;\n  let maxBarWidth = 0;\n  let valueHeight = 0;\n  let valueWidth = 0;\n  let wrapperWidth = 0;\n  let wrapperHeight = 0; // measure text with title font size or min 14px\n\n  const fontSizeToMeasureWith = (_text$valueSize = text === null || text === void 0 ? void 0 : text.valueSize) !== null && _text$valueSize !== void 0 ? _text$valueSize : Math.max(titleDim.fontSize, 12);\n  const realTextSize = measureText(valueString, fontSizeToMeasureWith);\n  const realValueWidth = realTextSize.width + VALUE_LEFT_PADDING * 2;\n\n  if (isVertical(orientation)) {\n    if (text !== null && text !== void 0 && text.valueSize) {\n      valueHeight = text.valueSize * VALUE_LINE_HEIGHT;\n    } else {\n      valueHeight = Math.min(Math.max(height * 0.1, MIN_VALUE_HEIGHT), MAX_VALUE_HEIGHT);\n    }\n\n    valueWidth = width;\n    maxBarHeight = height - (titleDim.height + valueHeight);\n    maxBarWidth = width;\n    wrapperWidth = width;\n    wrapperHeight = height - titleDim.height;\n  } else {\n    valueHeight = height - titleDim.height;\n    valueWidth = Math.max(Math.min(width * 0.2, MAX_VALUE_WIDTH), realValueWidth);\n    maxBarHeight = height - titleDim.height;\n    maxBarWidth = width - valueWidth - titleDim.width;\n\n    if (titleDim.placement === 'above') {\n      wrapperWidth = width;\n      wrapperHeight = height - titleDim.height;\n    } else {\n      wrapperWidth = width - titleDim.width;\n      wrapperHeight = height;\n    }\n  }\n\n  return {\n    valueWidth,\n    valueHeight,\n    maxBarWidth,\n    maxBarHeight,\n    wrapperHeight,\n    wrapperWidth\n  };\n}\nexport function getCellColor(positionValue, value, display) {\n  if (positionValue === null) {\n    return {\n      background: FALLBACK_COLOR,\n      border: FALLBACK_COLOR\n    };\n  }\n\n  const color = display ? display(positionValue).color : null;\n\n  if (color) {\n    // if we are past real value the cell is not \"on\"\n    if (value === null || isNaN(value.numeric) || positionValue !== null && positionValue > value.numeric) {\n      return {\n        background: tinycolor(color).setAlpha(0.18).toRgbString(),\n        border: 'transparent',\n        isLit: false\n      };\n    } else {\n      return {\n        background: tinycolor(color).setAlpha(0.95).toRgbString(),\n        backgroundShade: tinycolor(color).setAlpha(0.55).toRgbString(),\n        border: tinycolor(color).setAlpha(0.9).toRgbString(),\n        isLit: true\n      };\n    }\n  }\n\n  return {\n    background: FALLBACK_COLOR,\n    border: FALLBACK_COLOR\n  };\n}\nexport function getValuePercent(value, minValue, maxValue) {\n  return Math.min((value - minValue) / (maxValue - minValue), 1);\n}\n/**\n * Only exported to for unit test\n */\n\nexport function getBasicAndGradientStyles(props) {\n  var _field$min2, _field$max2;\n\n  const {\n    displayMode,\n    field,\n    value,\n    alignmentFactors,\n    orientation,\n    theme,\n    text\n  } = props;\n  const {\n    valueWidth,\n    valueHeight,\n    maxBarHeight,\n    maxBarWidth\n  } = calculateBarAndValueDimensions(props);\n  const minValue = (_field$min2 = field.min) !== null && _field$min2 !== void 0 ? _field$min2 : GAUGE_DEFAULT_MINIMUM;\n  const maxValue = (_field$max2 = field.max) !== null && _field$max2 !== void 0 ? _field$max2 : GAUGE_DEFAULT_MAXIMUM;\n  const valuePercent = getValuePercent(value.numeric, minValue, maxValue);\n  const valueColor = getValueColor(props);\n  const valueToBaseSizeOn = alignmentFactors ? alignmentFactors : value;\n  const valueStyles = getValueStyles(valueToBaseSizeOn, valueColor, valueWidth, valueHeight, orientation, text);\n  const isBasic = displayMode === 'basic';\n  const wrapperStyles = {\n    display: 'flex',\n    flexGrow: 1\n  };\n  const barStyles = {\n    borderRadius: '3px',\n    position: 'relative',\n    zIndex: 1\n  };\n  const emptyBar = {\n    background: `rgba(${theme.isDark ? '255,255,255' : '0,0,0'}, 0.07)`,\n    flexGrow: 1,\n    display: 'flex',\n    borderRadius: '3px',\n    position: 'relative'\n  };\n\n  if (isVertical(orientation)) {\n    const barHeight = Math.max(valuePercent * maxBarHeight, 1); // vertical styles\n\n    wrapperStyles.flexDirection = 'column';\n    wrapperStyles.justifyContent = 'flex-end';\n    barStyles.transition = 'height 1s';\n    barStyles.height = `${barHeight}px`;\n    barStyles.width = `${maxBarWidth}px`; // adjust so that filled in bar is at the bottom\n\n    emptyBar.bottom = '-3px'; //adjust empty region to always have same width as colored bar\n\n    emptyBar.width = `${valueWidth}px`;\n\n    if (isBasic) {\n      // Basic styles\n      barStyles.background = `${tinycolor(valueColor).setAlpha(0.35).toRgbString()}`;\n      barStyles.borderTop = `2px solid ${valueColor}`;\n    } else {\n      // Gradient styles\n      barStyles.background = getBarGradient(props, maxBarHeight);\n    }\n  } else {\n    const barWidth = Math.max(valuePercent * maxBarWidth, 1); // Custom styles for horizontal orientation\n\n    wrapperStyles.flexDirection = 'row-reverse';\n    wrapperStyles.justifyContent = 'flex-end';\n    wrapperStyles.alignItems = 'stretch';\n    barStyles.transition = 'width 1s';\n    barStyles.height = `${maxBarHeight}px`;\n    barStyles.width = `${barWidth}px`; // shift empty region back to fill gaps due to border radius\n\n    emptyBar.left = '-3px'; //adjust empty region to always have same height as colored bar\n\n    emptyBar.height = `${valueHeight}px`;\n\n    if (isBasic) {\n      // Basic styles\n      barStyles.background = `${tinycolor(valueColor).setAlpha(0.35).toRgbString()}`;\n      barStyles.borderRight = `2px solid ${valueColor}`;\n    } else {\n      // Gradient styles\n      barStyles.background = getBarGradient(props, maxBarWidth);\n    }\n  }\n\n  return {\n    wrapper: wrapperStyles,\n    bar: barStyles,\n    value: valueStyles,\n    emptyBar\n  };\n}\n/**\n * Only exported to for unit test\n */\n\nexport function getBarGradient(props, maxSize) {\n  var _field$color, _value$color;\n\n  const {\n    field,\n    value,\n    orientation,\n    theme\n  } = props;\n  const cssDirection = isVertical(orientation) ? '0deg' : '90deg';\n  const minValue = field.min;\n  const maxValue = field.max;\n  let gradient = '';\n  let lastpos = 0;\n  let mode = getFieldColorMode((_field$color = field.color) === null || _field$color === void 0 ? void 0 : _field$color.mode);\n\n  if (mode.id === FieldColorModeId.Thresholds) {\n    const thresholds = field.thresholds;\n\n    for (let i = 0; i < thresholds.steps.length; i++) {\n      const threshold = thresholds.steps[i];\n      const color = props.theme.visualization.getColorByName(threshold.color);\n      const valuePercent = thresholds.mode === ThresholdsMode.Percentage ? threshold.value / 100 : getValuePercent(threshold.value, minValue, maxValue);\n      const pos = valuePercent * maxSize;\n      const offset = Math.round(pos - (pos - lastpos) / 2);\n      const thresholdValue = thresholds.mode === ThresholdsMode.Percentage ? minValue + (maxValue - minValue) * valuePercent : threshold.value;\n\n      if (gradient === '') {\n        gradient = `linear-gradient(${cssDirection}, ${color}, ${color}`;\n      } else if (value.numeric < thresholdValue) {\n        break;\n      } else {\n        lastpos = pos;\n        gradient += ` ${offset}px, ${color}`;\n      }\n    }\n\n    return gradient + ')';\n  }\n\n  if (mode.isContinuous && mode.getColors) {\n    const scheme = mode.getColors(theme);\n\n    for (let i = 0; i < scheme.length; i++) {\n      const color = scheme[i];\n\n      if (gradient === '') {\n        gradient = `linear-gradient(${cssDirection}, ${color} 0px`;\n      } else {\n        const valuePercent = i / (scheme.length - 1);\n        const pos = valuePercent * maxSize;\n        gradient += `, ${color} ${pos}px`;\n      }\n    }\n\n    return gradient + ')';\n  }\n\n  return (_value$color = value.color) !== null && _value$color !== void 0 ? _value$color : FALLBACK_COLOR;\n}\n/**\n * Only exported to for unit test\n */\n\nexport function getValueColor(props) {\n  const {\n    value\n  } = props;\n\n  if (value.color) {\n    return value.color;\n  }\n\n  return FALLBACK_COLOR;\n}\n\nfunction getValueStyles(value, color, width, height, orientation, text) {\n  const styles = {\n    color,\n    height: `${height}px`,\n    width: `${width}px`,\n    display: 'flex',\n    alignItems: 'center',\n    lineHeight: VALUE_LINE_HEIGHT\n  }; // how many pixels in wide can the text be?\n\n  let textWidth = width;\n  const formattedValueString = formattedValueToString(value);\n\n  if (isVertical(orientation)) {\n    var _text$valueSize2;\n\n    styles.fontSize = (_text$valueSize2 = text === null || text === void 0 ? void 0 : text.valueSize) !== null && _text$valueSize2 !== void 0 ? _text$valueSize2 : calculateFontSize(formattedValueString, textWidth, height, VALUE_LINE_HEIGHT);\n    styles.justifyContent = `center`;\n  } else {\n    var _text$valueSize3;\n\n    styles.fontSize = (_text$valueSize3 = text === null || text === void 0 ? void 0 : text.valueSize) !== null && _text$valueSize3 !== void 0 ? _text$valueSize3 : calculateFontSize(formattedValueString, textWidth - VALUE_LEFT_PADDING * 2, height, VALUE_LINE_HEIGHT);\n    styles.justifyContent = `flex-end`;\n    styles.paddingLeft = `${VALUE_LEFT_PADDING}px`;\n    styles.paddingRight = `${VALUE_LEFT_PADDING}px`; // Need to remove the left padding from the text width constraints\n\n    textWidth -= VALUE_LEFT_PADDING;\n  }\n\n  return styles;\n}","map":{"version":3,"names":["React","PureComponent","tinycolor","FALLBACK_COLOR","FieldColorModeId","formattedValueToString","GAUGE_DEFAULT_MAXIMUM","GAUGE_DEFAULT_MINIMUM","getFieldColorMode","ThresholdsMode","VizOrientation","selectors","calculateFontSize","measureText","FormattedValueDisplay","MIN_VALUE_HEIGHT","MAX_VALUE_HEIGHT","MAX_VALUE_WIDTH","TITLE_LINE_HEIGHT","VALUE_LINE_HEIGHT","VALUE_LEFT_PADDING","BarGaugeDisplayMode","BarGauge","render","onClick","className","props","title","value","styles","getTitleStyles","wrapper","renderBarAndValue","displayMode","renderRetroBars","renderBasicAndGradientBars","showUnfilled","getBasicAndGradientStyles","components","Panels","Visualization","valueV2","emptyBar","bar","display","field","itemSpacing","alignmentFactors","orientation","lcdCellWidth","text","valueHeight","valueWidth","maxBarHeight","maxBarWidth","wrapperWidth","wrapperHeight","calculateBarAndValueDimensions","minValue","min","maxValue","max","isVert","isVertical","valueRange","maxSize","cellSpacing","cellCount","Math","floor","cellSize","valueColor","getValueColor","valueToBaseSizeOn","valueStyles","getValueStyles","containerStyles","width","height","flexDirection","alignItems","justifyContent","cells","i","currentValue","cellColor","getCellColor","cellStyles","borderRadius","isLit","backgroundImage","background","backgroundShade","backgroundColor","marginTop","marginRight","push","toString","numeric","Gradient","Horizontal","thresholds","mode","Absolute","steps","Vertical","calculateTitleDimensions","fontSize","placement","titleSize","maxTitleHeightRatio","titleHeight","titleFontSize","textSize","textWidth","wrapperStyles","overflow","titleDim","titleStyles","whiteSpace","textOverflow","alignSelf","textAlign","paddingRight","valueString","fontSizeToMeasureWith","valueSize","realTextSize","realValueWidth","positionValue","border","color","isNaN","setAlpha","toRgbString","getValuePercent","theme","valuePercent","isBasic","flexGrow","barStyles","position","zIndex","isDark","barHeight","transition","bottom","borderTop","getBarGradient","barWidth","left","borderRight","cssDirection","gradient","lastpos","id","Thresholds","length","threshold","visualization","getColorByName","Percentage","pos","offset","round","thresholdValue","isContinuous","getColors","scheme","lineHeight","formattedValueString","paddingLeft"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/BarGauge/BarGauge.tsx"],"sourcesContent":["// Library\nimport React, { CSSProperties, PureComponent, ReactNode } from 'react';\nimport tinycolor from 'tinycolor2';\n\nimport {\n  DisplayProcessor,\n  DisplayValue,\n  DisplayValueAlignmentFactors,\n  FALLBACK_COLOR,\n  FieldColorModeId,\n  FieldConfig,\n  FormattedValue,\n  formattedValueToString,\n  GAUGE_DEFAULT_MAXIMUM,\n  GAUGE_DEFAULT_MINIMUM,\n  getFieldColorMode,\n  ThresholdsMode,\n  TimeSeriesValue,\n  VizOrientation,\n} from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { VizTextDisplayOptions } from '@grafana/schema';\n\nimport { Themeable2 } from '../../types';\nimport { calculateFontSize, measureText } from '../../utils/measureText';\nimport { FormattedValueDisplay } from '../FormattedValueDisplay/FormattedValueDisplay';\n\nconst MIN_VALUE_HEIGHT = 18;\nconst MAX_VALUE_HEIGHT = 50;\nconst MAX_VALUE_WIDTH = 150;\nconst TITLE_LINE_HEIGHT = 1.5;\nconst VALUE_LINE_HEIGHT = 1;\nconst VALUE_LEFT_PADDING = 10;\n\nexport interface Props extends Themeable2 {\n  height: number;\n  width: number;\n  field: FieldConfig;\n  display?: DisplayProcessor;\n  value: DisplayValue;\n  orientation: VizOrientation;\n  text?: VizTextDisplayOptions;\n  itemSpacing?: number;\n  lcdCellWidth?: number;\n  displayMode: BarGaugeDisplayMode;\n  onClick?: React.MouseEventHandler<HTMLElement>;\n  className?: string;\n  showUnfilled?: boolean;\n  alignmentFactors?: DisplayValueAlignmentFactors;\n}\n\nexport enum BarGaugeDisplayMode {\n  Basic = 'basic',\n  Lcd = 'lcd',\n  Gradient = 'gradient',\n}\n\nexport class BarGauge extends PureComponent<Props> {\n  static defaultProps: Partial<Props> = {\n    lcdCellWidth: 12,\n    value: {\n      text: '100',\n      numeric: 100,\n    },\n    displayMode: BarGaugeDisplayMode.Gradient,\n    orientation: VizOrientation.Horizontal,\n    field: {\n      min: 0,\n      max: 100,\n      thresholds: {\n        mode: ThresholdsMode.Absolute,\n        steps: [],\n      },\n    },\n    itemSpacing: 8,\n    showUnfilled: true,\n  };\n\n  render() {\n    const { onClick, className } = this.props;\n    const { title } = this.props.value;\n    const styles = getTitleStyles(this.props);\n\n    if (!title) {\n      return (\n        <div style={styles.wrapper} onClick={onClick} className={className}>\n          {this.renderBarAndValue()}\n        </div>\n      );\n    }\n\n    return (\n      <div style={styles.wrapper} onClick={onClick} className={className}>\n        <div style={styles.title}>{title}</div>\n        {this.renderBarAndValue()}\n      </div>\n    );\n  }\n\n  renderBarAndValue() {\n    switch (this.props.displayMode) {\n      case 'lcd':\n        return this.renderRetroBars();\n      case 'basic':\n      case 'gradient':\n      default:\n        return this.renderBasicAndGradientBars();\n    }\n  }\n\n  renderBasicAndGradientBars(): ReactNode {\n    const { value, showUnfilled } = this.props;\n\n    const styles = getBasicAndGradientStyles(this.props);\n\n    return (\n      <div style={styles.wrapper}>\n        <FormattedValueDisplay\n          data-testid={selectors.components.Panels.Visualization.BarGauge.valueV2}\n          value={value}\n          style={styles.value}\n        />\n        {showUnfilled && <div style={styles.emptyBar} />}\n        <div style={styles.bar} />\n      </div>\n    );\n  }\n\n  renderRetroBars(): ReactNode {\n    const { display, field, value, itemSpacing, alignmentFactors, orientation, lcdCellWidth, text } = this.props;\n    const { valueHeight, valueWidth, maxBarHeight, maxBarWidth, wrapperWidth, wrapperHeight } =\n      calculateBarAndValueDimensions(this.props);\n    const minValue = field.min ?? GAUGE_DEFAULT_MINIMUM;\n    const maxValue = field.max ?? GAUGE_DEFAULT_MAXIMUM;\n\n    const isVert = isVertical(orientation);\n    const valueRange = maxValue - minValue;\n    const maxSize = isVert ? maxBarHeight : maxBarWidth;\n    const cellSpacing = itemSpacing!;\n    const cellCount = Math.floor(maxSize / lcdCellWidth!);\n    const cellSize = Math.floor((maxSize - cellSpacing * cellCount) / cellCount);\n    const valueColor = getValueColor(this.props);\n\n    const valueToBaseSizeOn = alignmentFactors ? alignmentFactors : value;\n    const valueStyles = getValueStyles(valueToBaseSizeOn, valueColor, valueWidth, valueHeight, orientation, text);\n\n    const containerStyles: CSSProperties = {\n      width: `${wrapperWidth}px`,\n      height: `${wrapperHeight}px`,\n      display: 'flex',\n    };\n\n    if (isVert) {\n      containerStyles.flexDirection = 'column-reverse';\n      containerStyles.alignItems = 'center';\n    } else {\n      containerStyles.flexDirection = 'row';\n      containerStyles.alignItems = 'center';\n      valueStyles.justifyContent = 'flex-end';\n    }\n\n    const cells: JSX.Element[] = [];\n\n    for (let i = 0; i < cellCount; i++) {\n      const currentValue = minValue + (valueRange / cellCount) * i;\n      const cellColor = getCellColor(currentValue, value, display);\n      const cellStyles: CSSProperties = {\n        borderRadius: '2px',\n      };\n\n      if (cellColor.isLit) {\n        cellStyles.backgroundImage = `radial-gradient(${cellColor.background} 10%, ${cellColor.backgroundShade})`;\n      } else {\n        cellStyles.backgroundColor = cellColor.background;\n      }\n\n      if (isVert) {\n        cellStyles.height = `${cellSize}px`;\n        cellStyles.width = `${maxBarWidth}px`;\n        cellStyles.marginTop = `${cellSpacing}px`;\n      } else {\n        cellStyles.width = `${cellSize}px`;\n        cellStyles.height = `${maxBarHeight}px`;\n        cellStyles.marginRight = `${cellSpacing}px`;\n      }\n\n      cells.push(<div key={i.toString()} style={cellStyles} />);\n    }\n\n    return (\n      <div style={containerStyles}>\n        {cells}\n        <FormattedValueDisplay\n          data-testid={selectors.components.Panels.Visualization.BarGauge.valueV2}\n          value={value}\n          style={valueStyles}\n        />\n      </div>\n    );\n  }\n}\n\ninterface CellColors {\n  background: string;\n  backgroundShade?: string;\n  border: string;\n  isLit?: boolean;\n}\n\ninterface TitleDimensions {\n  fontSize: number;\n  placement: 'above' | 'left' | 'below';\n  width: number;\n  height: number;\n}\n\nfunction isVertical(orientation: VizOrientation) {\n  return orientation === VizOrientation.Vertical;\n}\n\nfunction calculateTitleDimensions(props: Props): TitleDimensions {\n  const { height, width, alignmentFactors, orientation, text } = props;\n  const title = alignmentFactors ? alignmentFactors.title : props.value.title;\n\n  if (!title) {\n    return { fontSize: 0, width: 0, height: 0, placement: 'above' };\n  }\n\n  if (isVertical(orientation)) {\n    const fontSize = text?.titleSize ?? 14;\n    return {\n      fontSize: fontSize,\n      width: width,\n      height: fontSize * TITLE_LINE_HEIGHT,\n      placement: 'below',\n    };\n  }\n\n  // if height above 40 put text to above bar\n  if (height > 40) {\n    if (text?.titleSize) {\n      return {\n        fontSize: text?.titleSize,\n        width: 0,\n        height: text.titleSize * TITLE_LINE_HEIGHT,\n        placement: 'above',\n      };\n    }\n\n    const maxTitleHeightRatio = 0.45;\n    const titleHeight = Math.max(Math.min(height * maxTitleHeightRatio, MAX_VALUE_HEIGHT), 17);\n\n    return {\n      fontSize: titleHeight / TITLE_LINE_HEIGHT,\n      width: 0,\n      height: titleHeight,\n      placement: 'above',\n    };\n  }\n\n  // title to left of bar scenario\n  const maxTitleHeightRatio = 0.6;\n  const titleHeight = Math.max(height * maxTitleHeightRatio, MIN_VALUE_HEIGHT);\n  const titleFontSize = titleHeight / TITLE_LINE_HEIGHT;\n  const textSize = measureText(title, titleFontSize);\n\n  // Do not allow title to take up more than 40% width\n  const textWidth = Math.min(textSize.width + 15, width * 0.4);\n\n  return {\n    fontSize: text?.titleSize ?? titleFontSize,\n    height: 0,\n    width: textWidth,\n    placement: 'left',\n  };\n}\n\nexport function getTitleStyles(props: Props): { wrapper: CSSProperties; title: CSSProperties } {\n  const wrapperStyles: CSSProperties = {\n    display: 'flex',\n    overflow: 'hidden',\n    width: '100%',\n  };\n\n  const titleDim = calculateTitleDimensions(props);\n\n  const titleStyles: CSSProperties = {\n    fontSize: `${titleDim.fontSize}px`,\n    whiteSpace: 'nowrap',\n    overflow: 'hidden',\n    textOverflow: 'ellipsis',\n    width: '100%',\n    alignItems: 'center',\n    alignSelf: 'center',\n  };\n\n  if (isVertical(props.orientation)) {\n    wrapperStyles.flexDirection = 'column-reverse';\n    titleStyles.textAlign = 'center';\n  } else {\n    if (titleDim.placement === 'above') {\n      wrapperStyles.flexDirection = 'column';\n    } else {\n      wrapperStyles.flexDirection = 'row';\n\n      titleStyles.width = `${titleDim.width}px`;\n      titleStyles.textAlign = 'right';\n      titleStyles.paddingRight = '10px';\n    }\n  }\n\n  return {\n    wrapper: wrapperStyles,\n    title: titleStyles,\n  };\n}\n\ninterface BasicAndGradientStyles {\n  wrapper: CSSProperties;\n  bar: CSSProperties;\n  emptyBar: CSSProperties;\n  value: CSSProperties;\n}\n\ninterface BarAndValueDimensions {\n  valueWidth: number;\n  valueHeight: number;\n  maxBarWidth: number;\n  maxBarHeight: number;\n  wrapperHeight: number;\n  wrapperWidth: number;\n}\n\n/**\n * @internal\n * Only exported for unit tests\n **/\nexport function calculateBarAndValueDimensions(props: Props): BarAndValueDimensions {\n  const { height, width, orientation, text, alignmentFactors } = props;\n  const titleDim = calculateTitleDimensions(props);\n  const value = alignmentFactors ?? props.value;\n  const valueString = formattedValueToString(value);\n\n  let maxBarHeight = 0;\n  let maxBarWidth = 0;\n  let valueHeight = 0;\n  let valueWidth = 0;\n  let wrapperWidth = 0;\n  let wrapperHeight = 0;\n\n  // measure text with title font size or min 14px\n  const fontSizeToMeasureWith = text?.valueSize ?? Math.max(titleDim.fontSize, 12);\n  const realTextSize = measureText(valueString, fontSizeToMeasureWith);\n  const realValueWidth = realTextSize.width + VALUE_LEFT_PADDING * 2;\n\n  if (isVertical(orientation)) {\n    if (text?.valueSize) {\n      valueHeight = text.valueSize * VALUE_LINE_HEIGHT;\n    } else {\n      valueHeight = Math.min(Math.max(height * 0.1, MIN_VALUE_HEIGHT), MAX_VALUE_HEIGHT);\n    }\n\n    valueWidth = width;\n    maxBarHeight = height - (titleDim.height + valueHeight);\n    maxBarWidth = width;\n    wrapperWidth = width;\n    wrapperHeight = height - titleDim.height;\n  } else {\n    valueHeight = height - titleDim.height;\n    valueWidth = Math.max(Math.min(width * 0.2, MAX_VALUE_WIDTH), realValueWidth);\n\n    maxBarHeight = height - titleDim.height;\n    maxBarWidth = width - valueWidth - titleDim.width;\n\n    if (titleDim.placement === 'above') {\n      wrapperWidth = width;\n      wrapperHeight = height - titleDim.height;\n    } else {\n      wrapperWidth = width - titleDim.width;\n      wrapperHeight = height;\n    }\n  }\n\n  return {\n    valueWidth,\n    valueHeight,\n    maxBarWidth,\n    maxBarHeight,\n    wrapperHeight,\n    wrapperWidth,\n  };\n}\n\nexport function getCellColor(\n  positionValue: TimeSeriesValue,\n  value: Props['value'],\n  display: Props['display']\n): CellColors {\n  if (positionValue === null) {\n    return {\n      background: FALLBACK_COLOR,\n      border: FALLBACK_COLOR,\n    };\n  }\n\n  const color = display ? display(positionValue).color : null;\n\n  if (color) {\n    // if we are past real value the cell is not \"on\"\n    if (value === null || isNaN(value.numeric) || (positionValue !== null && positionValue > value.numeric)) {\n      return {\n        background: tinycolor(color).setAlpha(0.18).toRgbString(),\n        border: 'transparent',\n        isLit: false,\n      };\n    } else {\n      return {\n        background: tinycolor(color).setAlpha(0.95).toRgbString(),\n        backgroundShade: tinycolor(color).setAlpha(0.55).toRgbString(),\n        border: tinycolor(color).setAlpha(0.9).toRgbString(),\n        isLit: true,\n      };\n    }\n  }\n\n  return {\n    background: FALLBACK_COLOR,\n    border: FALLBACK_COLOR,\n  };\n}\n\nexport function getValuePercent(value: number, minValue: number, maxValue: number): number {\n  return Math.min((value - minValue) / (maxValue - minValue), 1);\n}\n\n/**\n * Only exported to for unit test\n */\nexport function getBasicAndGradientStyles(props: Props): BasicAndGradientStyles {\n  const { displayMode, field, value, alignmentFactors, orientation, theme, text } = props;\n  const { valueWidth, valueHeight, maxBarHeight, maxBarWidth } = calculateBarAndValueDimensions(props);\n\n  const minValue = field.min ?? GAUGE_DEFAULT_MINIMUM;\n  const maxValue = field.max ?? GAUGE_DEFAULT_MAXIMUM;\n  const valuePercent = getValuePercent(value.numeric, minValue, maxValue);\n  const valueColor = getValueColor(props);\n\n  const valueToBaseSizeOn = alignmentFactors ? alignmentFactors : value;\n  const valueStyles = getValueStyles(valueToBaseSizeOn, valueColor, valueWidth, valueHeight, orientation, text);\n\n  const isBasic = displayMode === 'basic';\n  const wrapperStyles: CSSProperties = {\n    display: 'flex',\n    flexGrow: 1,\n  };\n\n  const barStyles: CSSProperties = {\n    borderRadius: '3px',\n    position: 'relative',\n    zIndex: 1,\n  };\n\n  const emptyBar: CSSProperties = {\n    background: `rgba(${theme.isDark ? '255,255,255' : '0,0,0'}, 0.07)`,\n    flexGrow: 1,\n    display: 'flex',\n    borderRadius: '3px',\n    position: 'relative',\n  };\n\n  if (isVertical(orientation)) {\n    const barHeight = Math.max(valuePercent * maxBarHeight, 1);\n\n    // vertical styles\n    wrapperStyles.flexDirection = 'column';\n    wrapperStyles.justifyContent = 'flex-end';\n\n    barStyles.transition = 'height 1s';\n    barStyles.height = `${barHeight}px`;\n    barStyles.width = `${maxBarWidth}px`;\n\n    // adjust so that filled in bar is at the bottom\n    emptyBar.bottom = '-3px';\n\n    //adjust empty region to always have same width as colored bar\n    emptyBar.width = `${valueWidth}px`;\n\n    if (isBasic) {\n      // Basic styles\n      barStyles.background = `${tinycolor(valueColor).setAlpha(0.35).toRgbString()}`;\n      barStyles.borderTop = `2px solid ${valueColor}`;\n    } else {\n      // Gradient styles\n      barStyles.background = getBarGradient(props, maxBarHeight);\n    }\n  } else {\n    const barWidth = Math.max(valuePercent * maxBarWidth, 1);\n\n    // Custom styles for horizontal orientation\n    wrapperStyles.flexDirection = 'row-reverse';\n    wrapperStyles.justifyContent = 'flex-end';\n    wrapperStyles.alignItems = 'stretch';\n\n    barStyles.transition = 'width 1s';\n    barStyles.height = `${maxBarHeight}px`;\n    barStyles.width = `${barWidth}px`;\n\n    // shift empty region back to fill gaps due to border radius\n    emptyBar.left = '-3px';\n\n    //adjust empty region to always have same height as colored bar\n    emptyBar.height = `${valueHeight}px`;\n\n    if (isBasic) {\n      // Basic styles\n      barStyles.background = `${tinycolor(valueColor).setAlpha(0.35).toRgbString()}`;\n      barStyles.borderRight = `2px solid ${valueColor}`;\n    } else {\n      // Gradient styles\n      barStyles.background = getBarGradient(props, maxBarWidth);\n    }\n  }\n\n  return {\n    wrapper: wrapperStyles,\n    bar: barStyles,\n    value: valueStyles,\n    emptyBar,\n  };\n}\n\n/**\n * Only exported to for unit test\n */\nexport function getBarGradient(props: Props, maxSize: number): string {\n  const { field, value, orientation, theme } = props;\n  const cssDirection = isVertical(orientation) ? '0deg' : '90deg';\n  const minValue = field.min!;\n  const maxValue = field.max!;\n\n  let gradient = '';\n  let lastpos = 0;\n  let mode = getFieldColorMode(field.color?.mode);\n\n  if (mode.id === FieldColorModeId.Thresholds) {\n    const thresholds = field.thresholds!;\n\n    for (let i = 0; i < thresholds.steps.length; i++) {\n      const threshold = thresholds.steps[i];\n      const color = props.theme.visualization.getColorByName(threshold.color);\n      const valuePercent =\n        thresholds.mode === ThresholdsMode.Percentage\n          ? threshold.value / 100\n          : getValuePercent(threshold.value, minValue, maxValue);\n      const pos = valuePercent * maxSize;\n      const offset = Math.round(pos - (pos - lastpos) / 2);\n      const thresholdValue =\n        thresholds.mode === ThresholdsMode.Percentage\n          ? minValue + (maxValue - minValue) * valuePercent\n          : threshold.value;\n      if (gradient === '') {\n        gradient = `linear-gradient(${cssDirection}, ${color}, ${color}`;\n      } else if (value.numeric < thresholdValue) {\n        break;\n      } else {\n        lastpos = pos;\n        gradient += ` ${offset}px, ${color}`;\n      }\n    }\n\n    return gradient + ')';\n  }\n\n  if (mode.isContinuous && mode.getColors) {\n    const scheme = mode.getColors(theme);\n\n    for (let i = 0; i < scheme.length; i++) {\n      const color = scheme[i];\n\n      if (gradient === '') {\n        gradient = `linear-gradient(${cssDirection}, ${color} 0px`;\n      } else {\n        const valuePercent = i / (scheme.length - 1);\n        const pos = valuePercent * maxSize;\n        gradient += `, ${color} ${pos}px`;\n      }\n    }\n    return gradient + ')';\n  }\n\n  return value.color ?? FALLBACK_COLOR;\n}\n\n/**\n * Only exported to for unit test\n */\nexport function getValueColor(props: Props): string {\n  const { value } = props;\n  if (value.color) {\n    return value.color;\n  }\n\n  return FALLBACK_COLOR;\n}\n\nfunction getValueStyles(\n  value: FormattedValue,\n  color: string,\n  width: number,\n  height: number,\n  orientation: VizOrientation,\n  text?: VizTextDisplayOptions\n): CSSProperties {\n  const styles: CSSProperties = {\n    color,\n    height: `${height}px`,\n    width: `${width}px`,\n    display: 'flex',\n    alignItems: 'center',\n    lineHeight: VALUE_LINE_HEIGHT,\n  };\n\n  // how many pixels in wide can the text be?\n  let textWidth = width;\n  const formattedValueString = formattedValueToString(value);\n\n  if (isVertical(orientation)) {\n    styles.fontSize = text?.valueSize ?? calculateFontSize(formattedValueString, textWidth, height, VALUE_LINE_HEIGHT);\n    styles.justifyContent = `center`;\n  } else {\n    styles.fontSize =\n      text?.valueSize ??\n      calculateFontSize(formattedValueString, textWidth - VALUE_LEFT_PADDING * 2, height, VALUE_LINE_HEIGHT);\n    styles.justifyContent = `flex-end`;\n    styles.paddingLeft = `${VALUE_LEFT_PADDING}px`;\n    styles.paddingRight = `${VALUE_LEFT_PADDING}px`;\n    // Need to remove the left padding from the text width constraints\n    textWidth -= VALUE_LEFT_PADDING;\n  }\n\n  return styles;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}