{"ast":null,"code":"var _LoadingPlaceholder;\n\nimport { css } from '@emotion/css';\nimport { uniqueId } from 'lodash';\nimport React from 'react';\nimport { dateTimeFormat } from '@grafana/data';\nimport { Alert, LoadingPlaceholder, useStyles } from '@grafana/ui';\nimport { useManagedAlertStateHistory } from '../../hooks/useManagedAlertStateHistory';\nimport { AlertLabel } from '../AlertLabel';\nimport { DynamicTable } from '../DynamicTable';\nimport { AlertStateTag } from './AlertStateTag';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\n\nconst StateHistory = ({\n  alertId\n}) => {\n  const {\n    loading,\n    error,\n    result = []\n  } = useManagedAlertStateHistory(alertId);\n\n  if (loading && !error) {\n    return _LoadingPlaceholder || (_LoadingPlaceholder = /*#__PURE__*/_jsx(LoadingPlaceholder, {\n      text: 'Loading history...'\n    }));\n  }\n\n  if (error && !loading) {\n    return /*#__PURE__*/_jsx(Alert, {\n      title: 'Failed to fetch alert state history',\n      children: error.message\n    });\n  }\n\n  const columns = [{\n    id: 'state',\n    label: 'State',\n    size: 'max-content',\n    renderCell: renderStateCell\n  }, {\n    id: 'value',\n    label: '',\n    size: 'auto',\n    renderCell: renderValueCell\n  }, {\n    id: 'timestamp',\n    label: 'Time',\n    size: 'max-content',\n    renderCell: renderTimestampCell\n  }];\n  const items = result.reduce((acc, item, index) => {\n    acc.push({\n      id: String(item.id),\n      state: item.newState,\n      text: item.text,\n      data: item.data,\n      timestamp: item.updated\n    }); // if the preceding state is not the same, create a separate state entry – this likely means the state was reset\n\n    if (!hasMatchingPrecedingState(index, result)) {\n      acc.push({\n        id: uniqueId(),\n        state: item.prevState\n      });\n    }\n\n    return acc;\n  }, []).map(historyItem => ({\n    id: historyItem.id,\n    data: historyItem\n  }));\n  return /*#__PURE__*/_jsx(DynamicTable, {\n    cols: columns,\n    items: items\n  });\n};\n\nfunction renderValueCell(item) {\n  var _item$data$data$evalM, _item$data$data;\n\n  const matches = (_item$data$data$evalM = (_item$data$data = item.data.data) === null || _item$data$data === void 0 ? void 0 : _item$data$data.evalMatches) !== null && _item$data$data$evalM !== void 0 ? _item$data$data$evalM : [];\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [item.data.text, /*#__PURE__*/_jsx(LabelsWrapper, {\n      children: matches.map(match => /*#__PURE__*/_jsx(AlertLabel, {\n        labelKey: match.metric,\n        value: String(match.value)\n      }, match.metric))\n    })]\n  });\n}\n\nfunction renderStateCell(item) {\n  return /*#__PURE__*/_jsx(AlertStateTag, {\n    state: item.data.state\n  });\n}\n\nfunction renderTimestampCell(item) {\n  return /*#__PURE__*/_jsx(\"div\", {\n    className: TimestampStyle,\n    children: item.data.timestamp && /*#__PURE__*/_jsx(\"span\", {\n      children: dateTimeFormat(item.data.timestamp)\n    })\n  });\n}\n\nconst LabelsWrapper = ({\n  children\n}) => {\n  const {\n    wrapper\n  } = useStyles(getStyles);\n  return /*#__PURE__*/_jsx(\"div\", {\n    className: wrapper,\n    children: children\n  });\n};\n\nconst TimestampStyle = css`\n  display: flex;\n  align-items: flex-end;\n  flex-direction: column;\n`;\n\nconst getStyles = theme => ({\n  wrapper: css`\n    & > * {\n      margin-right: ${theme.spacing.xs};\n    }\n  `\n}); // this function will figure out if a given historyItem has a preceding historyItem where the states match - in other words\n// the newState of the previous historyItem is the same as the prevState of the current historyItem\n\n\nfunction hasMatchingPrecedingState(index, items) {\n  const currentHistoryItem = items[index];\n  const previousHistoryItem = items[index + 1];\n\n  if (!previousHistoryItem) {\n    return false;\n  }\n\n  return previousHistoryItem.newState === currentHistoryItem.prevState;\n}\n\nexport { StateHistory };","map":{"version":3,"names":["css","uniqueId","React","dateTimeFormat","Alert","LoadingPlaceholder","useStyles","useManagedAlertStateHistory","AlertLabel","DynamicTable","AlertStateTag","StateHistory","alertId","loading","error","result","message","columns","id","label","size","renderCell","renderStateCell","renderValueCell","renderTimestampCell","items","reduce","acc","item","index","push","String","state","newState","text","data","timestamp","updated","hasMatchingPrecedingState","prevState","map","historyItem","matches","evalMatches","match","metric","value","TimestampStyle","LabelsWrapper","children","wrapper","getStyles","theme","spacing","xs","currentHistoryItem","previousHistoryItem"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/components/rules/StateHistory.tsx"],"sourcesContent":["import { css } from '@emotion/css';\nimport { uniqueId } from 'lodash';\nimport React, { FC } from 'react';\n\nimport { AlertState, dateTimeFormat, GrafanaTheme } from '@grafana/data';\nimport { Alert, LoadingPlaceholder, useStyles } from '@grafana/ui';\nimport { StateHistoryItem, StateHistoryItemData } from 'app/types/unified-alerting';\nimport { GrafanaAlertStateWithReason, PromAlertingRuleState } from 'app/types/unified-alerting-dto';\n\nimport { useManagedAlertStateHistory } from '../../hooks/useManagedAlertStateHistory';\nimport { AlertLabel } from '../AlertLabel';\nimport { DynamicTable, DynamicTableColumnProps, DynamicTableItemProps } from '../DynamicTable';\n\nimport { AlertStateTag } from './AlertStateTag';\n\ntype StateHistoryRowItem = {\n  id: string;\n  state: PromAlertingRuleState | GrafanaAlertStateWithReason | AlertState;\n  text?: string;\n  data?: StateHistoryItemData;\n  timestamp?: number;\n};\n\ntype StateHistoryRow = DynamicTableItemProps<StateHistoryRowItem>;\n\ninterface RuleStateHistoryProps {\n  alertId: string;\n}\n\nconst StateHistory: FC<RuleStateHistoryProps> = ({ alertId }) => {\n  const { loading, error, result = [] } = useManagedAlertStateHistory(alertId);\n\n  if (loading && !error) {\n    return <LoadingPlaceholder text={'Loading history...'} />;\n  }\n\n  if (error && !loading) {\n    return <Alert title={'Failed to fetch alert state history'}>{error.message}</Alert>;\n  }\n\n  const columns: Array<DynamicTableColumnProps<StateHistoryRowItem>> = [\n    { id: 'state', label: 'State', size: 'max-content', renderCell: renderStateCell },\n    { id: 'value', label: '', size: 'auto', renderCell: renderValueCell },\n    { id: 'timestamp', label: 'Time', size: 'max-content', renderCell: renderTimestampCell },\n  ];\n\n  const items: StateHistoryRow[] = result\n    .reduce((acc: StateHistoryRowItem[], item, index) => {\n      acc.push({\n        id: String(item.id),\n        state: item.newState,\n        text: item.text,\n        data: item.data,\n        timestamp: item.updated,\n      });\n\n      // if the preceding state is not the same, create a separate state entry – this likely means the state was reset\n      if (!hasMatchingPrecedingState(index, result)) {\n        acc.push({ id: uniqueId(), state: item.prevState });\n      }\n\n      return acc;\n    }, [])\n    .map((historyItem) => ({\n      id: historyItem.id,\n      data: historyItem,\n    }));\n\n  return <DynamicTable cols={columns} items={items} />;\n};\n\nfunction renderValueCell(item: StateHistoryRow) {\n  const matches = item.data.data?.evalMatches ?? [];\n\n  return (\n    <>\n      {item.data.text}\n      <LabelsWrapper>\n        {matches.map((match) => (\n          <AlertLabel key={match.metric} labelKey={match.metric} value={String(match.value)} />\n        ))}\n      </LabelsWrapper>\n    </>\n  );\n}\n\nfunction renderStateCell(item: StateHistoryRow) {\n  return <AlertStateTag state={item.data.state} />;\n}\n\nfunction renderTimestampCell(item: StateHistoryRow) {\n  return (\n    <div className={TimestampStyle}>{item.data.timestamp && <span>{dateTimeFormat(item.data.timestamp)}</span>}</div>\n  );\n}\n\nconst LabelsWrapper: FC<{}> = ({ children }) => {\n  const { wrapper } = useStyles(getStyles);\n  return <div className={wrapper}>{children}</div>;\n};\n\nconst TimestampStyle = css`\n  display: flex;\n  align-items: flex-end;\n  flex-direction: column;\n`;\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  wrapper: css`\n    & > * {\n      margin-right: ${theme.spacing.xs};\n    }\n  `,\n});\n\n// this function will figure out if a given historyItem has a preceding historyItem where the states match - in other words\n// the newState of the previous historyItem is the same as the prevState of the current historyItem\nfunction hasMatchingPrecedingState(index: number, items: StateHistoryItem[]): boolean {\n  const currentHistoryItem = items[index];\n  const previousHistoryItem = items[index + 1];\n\n  if (!previousHistoryItem) {\n    return false;\n  }\n\n  return previousHistoryItem.newState === currentHistoryItem.prevState;\n}\n\nexport { StateHistory };\n"],"mappings":";;AAAA,SAASA,GAAT,QAAoB,cAApB;AACA,SAASC,QAAT,QAAyB,QAAzB;AACA,OAAOC,KAAP,MAA0B,OAA1B;AAEA,SAAqBC,cAArB,QAAyD,eAAzD;AACA,SAASC,KAAT,EAAgBC,kBAAhB,EAAoCC,SAApC,QAAqD,aAArD;AAIA,SAASC,2BAAT,QAA4C,yCAA5C;AACA,SAASC,UAAT,QAA2B,eAA3B;AACA,SAASC,YAAT,QAA6E,iBAA7E;AAEA,SAASC,aAAT,QAA8B,iBAA9B;;;;;AAgBA,MAAMC,YAAuC,GAAG,CAAC;EAAEC;AAAF,CAAD,KAAiB;EAC/D,MAAM;IAAEC,OAAF;IAAWC,KAAX;IAAkBC,MAAM,GAAG;EAA3B,IAAkCR,2BAA2B,CAACK,OAAD,CAAnE;;EAEA,IAAIC,OAAO,IAAI,CAACC,KAAhB,EAAuB;IACrB,kEAAO,KAAC,kBAAD;MAAoB,IAAI,EAAE;IAA1B,EAAP;EACD;;EAED,IAAIA,KAAK,IAAI,CAACD,OAAd,EAAuB;IACrB,oBAAO,KAAC,KAAD;MAAO,KAAK,EAAE,qCAAd;MAAA,UAAsDC,KAAK,CAACE;IAA5D,EAAP;EACD;;EAED,MAAMC,OAA4D,GAAG,CACnE;IAAEC,EAAE,EAAE,OAAN;IAAeC,KAAK,EAAE,OAAtB;IAA+BC,IAAI,EAAE,aAArC;IAAoDC,UAAU,EAAEC;EAAhE,CADmE,EAEnE;IAAEJ,EAAE,EAAE,OAAN;IAAeC,KAAK,EAAE,EAAtB;IAA0BC,IAAI,EAAE,MAAhC;IAAwCC,UAAU,EAAEE;EAApD,CAFmE,EAGnE;IAAEL,EAAE,EAAE,WAAN;IAAmBC,KAAK,EAAE,MAA1B;IAAkCC,IAAI,EAAE,aAAxC;IAAuDC,UAAU,EAAEG;EAAnE,CAHmE,CAArE;EAMA,MAAMC,KAAwB,GAAGV,MAAM,CACpCW,MAD8B,CACvB,CAACC,GAAD,EAA6BC,IAA7B,EAAmCC,KAAnC,KAA6C;IACnDF,GAAG,CAACG,IAAJ,CAAS;MACPZ,EAAE,EAAEa,MAAM,CAACH,IAAI,CAACV,EAAN,CADH;MAEPc,KAAK,EAAEJ,IAAI,CAACK,QAFL;MAGPC,IAAI,EAAEN,IAAI,CAACM,IAHJ;MAIPC,IAAI,EAAEP,IAAI,CAACO,IAJJ;MAKPC,SAAS,EAAER,IAAI,CAACS;IALT,CAAT,EADmD,CASnD;;IACA,IAAI,CAACC,yBAAyB,CAACT,KAAD,EAAQd,MAAR,CAA9B,EAA+C;MAC7CY,GAAG,CAACG,IAAJ,CAAS;QAAEZ,EAAE,EAAEjB,QAAQ,EAAd;QAAkB+B,KAAK,EAAEJ,IAAI,CAACW;MAA9B,CAAT;IACD;;IAED,OAAOZ,GAAP;EACD,CAhB8B,EAgB5B,EAhB4B,EAiB9Ba,GAjB8B,CAiBzBC,WAAD,KAAkB;IACrBvB,EAAE,EAAEuB,WAAW,CAACvB,EADK;IAErBiB,IAAI,EAAEM;EAFe,CAAlB,CAjB0B,CAAjC;EAsBA,oBAAO,KAAC,YAAD;IAAc,IAAI,EAAExB,OAApB;IAA6B,KAAK,EAAEQ;EAApC,EAAP;AACD,CAxCD;;AA0CA,SAASF,eAAT,CAAyBK,IAAzB,EAAgD;EAAA;;EAC9C,MAAMc,OAAO,+CAAGd,IAAI,CAACO,IAAL,CAAUA,IAAb,oDAAG,gBAAgBQ,WAAnB,yEAAkC,EAA/C;EAEA,oBACE;IAAA,WACGf,IAAI,CAACO,IAAL,CAAUD,IADb,eAEE,KAAC,aAAD;MAAA,UACGQ,OAAO,CAACF,GAAR,CAAaI,KAAD,iBACX,KAAC,UAAD;QAA+B,QAAQ,EAAEA,KAAK,CAACC,MAA/C;QAAuD,KAAK,EAAEd,MAAM,CAACa,KAAK,CAACE,KAAP;MAApE,GAAiBF,KAAK,CAACC,MAAvB,CADD;IADH,EAFF;EAAA,EADF;AAUD;;AAED,SAASvB,eAAT,CAAyBM,IAAzB,EAAgD;EAC9C,oBAAO,KAAC,aAAD;IAAe,KAAK,EAAEA,IAAI,CAACO,IAAL,CAAUH;EAAhC,EAAP;AACD;;AAED,SAASR,mBAAT,CAA6BI,IAA7B,EAAoD;EAClD,oBACE;IAAK,SAAS,EAAEmB,cAAhB;IAAA,UAAiCnB,IAAI,CAACO,IAAL,CAAUC,SAAV,iBAAuB;MAAA,UAAOjC,cAAc,CAACyB,IAAI,CAACO,IAAL,CAAUC,SAAX;IAArB;EAAxD,EADF;AAGD;;AAED,MAAMY,aAAqB,GAAG,CAAC;EAAEC;AAAF,CAAD,KAAkB;EAC9C,MAAM;IAAEC;EAAF,IAAc5C,SAAS,CAAC6C,SAAD,CAA7B;EACA,oBAAO;IAAK,SAAS,EAAED,OAAhB;IAAA,UAA0BD;EAA1B,EAAP;AACD,CAHD;;AAKA,MAAMF,cAAc,GAAG/C,GAAI;AAC3B;AACA;AACA;AACA,CAJA;;AAMA,MAAMmD,SAAS,GAAIC,KAAD,KAA0B;EAC1CF,OAAO,EAAElD,GAAI;AACf;AACA,sBAAsBoD,KAAK,CAACC,OAAN,CAAcC,EAAG;AACvC;AACA;AAL4C,CAA1B,CAAlB,C,CAQA;AACA;;;AACA,SAAShB,yBAAT,CAAmCT,KAAnC,EAAkDJ,KAAlD,EAAsF;EACpF,MAAM8B,kBAAkB,GAAG9B,KAAK,CAACI,KAAD,CAAhC;EACA,MAAM2B,mBAAmB,GAAG/B,KAAK,CAACI,KAAK,GAAG,CAAT,CAAjC;;EAEA,IAAI,CAAC2B,mBAAL,EAA0B;IACxB,OAAO,KAAP;EACD;;EAED,OAAOA,mBAAmB,CAACvB,QAApB,KAAiCsB,kBAAkB,CAAChB,SAA3D;AACD;;AAED,SAAS5B,YAAT"},"metadata":{},"sourceType":"module"}