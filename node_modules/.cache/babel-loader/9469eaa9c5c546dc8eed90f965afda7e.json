{"ast":null,"code":"import { useCallback } from 'react';\nimport { mapInternalLinkToExplore, getFieldDisplayValuesProxy } from '@grafana/data';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { getLinkSrv } from '../../panel/panellinks/link_srv';\n/**\n * Get links from the field of a dataframe and in addition check if there is associated\n * metadata with datasource in which case we will add onClick to open the link in new split window. This assumes\n * that we just supply datasource name and field value and Explore split window will know how to render that\n * appropriately. This is for example used for transition from log with traceId to trace datasource to show that\n * trace.\n */\n\nexport const getFieldLinksForExplore = options => {\n  const {\n    field,\n    vars,\n    splitOpenFn,\n    range,\n    rowIndex,\n    dataFrame\n  } = options;\n  const scopedVars = Object.assign({}, vars || {});\n  scopedVars['__value'] = {\n    value: {\n      raw: field.values.get(rowIndex)\n    },\n    text: 'Raw value'\n  }; // If we have a dataFrame we can allow referencing other columns and their values in the interpolation.\n\n  if (dataFrame) {\n    scopedVars['__data'] = {\n      value: {\n        name: dataFrame.name,\n        refId: dataFrame.refId,\n        fields: getFieldDisplayValuesProxy({\n          frame: dataFrame,\n          rowIndex\n        })\n      },\n      text: 'Data'\n    };\n  }\n\n  if (field.config.links) {\n    const links = [];\n\n    if (!contextSrv.hasAccessToExplore()) {\n      links.push(...field.config.links.filter(l => !l.internal));\n    } else {\n      links.push(...field.config.links);\n    }\n\n    return links.map(link => {\n      if (!link.internal) {\n        const replace = (value, vars) => getTemplateSrv().replace(value, Object.assign({}, vars, scopedVars));\n\n        const linkModel = getLinkSrv().getDataLinkUIModel(link, replace, field);\n\n        if (!linkModel.title) {\n          linkModel.title = getTitleFromHref(linkModel.href);\n        }\n\n        return linkModel;\n      } else {\n        return mapInternalLinkToExplore({\n          link,\n          internalLink: link.internal,\n          scopedVars: scopedVars,\n          range,\n          field,\n          onClickFn: splitOpenFn,\n          replaceVariables: getTemplateSrv().replace.bind(getTemplateSrv())\n        });\n      }\n    });\n  }\n\n  return [];\n};\n\nfunction getTitleFromHref(href) {\n  // The URL constructor needs the url to have protocol\n  if (href.indexOf('://') < 0) {\n    // Doesn't really matter what protocol we use.\n    href = `http://${href}`;\n  }\n\n  let title;\n\n  try {\n    const parsedUrl = new URL(href);\n    title = parsedUrl.hostname;\n  } catch (_e) {\n    // Should be good enough fallback, user probably did not input valid url.\n    title = href;\n  }\n\n  return title;\n}\n/**\n * Hook that returns a function that can be used to retrieve all the links for a row. This returns all the links from\n * all the fields so is useful for visualisation where the whole row is represented as single clickable item like a\n * service map.\n */\n\n\nexport function useLinks(range, splitOpenFn) {\n  return useCallback((dataFrame, rowIndex) => {\n    return dataFrame.fields.flatMap(f => {\n      var _f$config, _f$config2;\n\n      if ((_f$config = f.config) !== null && _f$config !== void 0 && _f$config.links && (_f$config2 = f.config) !== null && _f$config2 !== void 0 && _f$config2.links.length) {\n        return getFieldLinksForExplore({\n          field: f,\n          rowIndex: rowIndex,\n          range,\n          dataFrame,\n          splitOpenFn\n        });\n      } else {\n        return [];\n      }\n    });\n  }, [range, splitOpenFn]);\n}","map":{"version":3,"names":["useCallback","mapInternalLinkToExplore","getFieldDisplayValuesProxy","getTemplateSrv","contextSrv","getLinkSrv","getFieldLinksForExplore","options","field","vars","splitOpenFn","range","rowIndex","dataFrame","scopedVars","value","raw","values","get","text","name","refId","fields","frame","config","links","hasAccessToExplore","push","filter","l","internal","map","link","replace","linkModel","getDataLinkUIModel","title","getTitleFromHref","href","internalLink","onClickFn","replaceVariables","bind","indexOf","parsedUrl","URL","hostname","_e","useLinks","flatMap","f","length"],"sources":["/home/soula/grafana/public/app/features/explore/utils/links.ts"],"sourcesContent":["import { useCallback } from 'react';\n\nimport {\n  Field,\n  LinkModel,\n  TimeRange,\n  mapInternalLinkToExplore,\n  InterpolateFunction,\n  ScopedVars,\n  DataFrame,\n  getFieldDisplayValuesProxy,\n  SplitOpen,\n} from '@grafana/data';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport { contextSrv } from 'app/core/services/context_srv';\n\nimport { getLinkSrv } from '../../panel/panellinks/link_srv';\n\n/**\n * Get links from the field of a dataframe and in addition check if there is associated\n * metadata with datasource in which case we will add onClick to open the link in new split window. This assumes\n * that we just supply datasource name and field value and Explore split window will know how to render that\n * appropriately. This is for example used for transition from log with traceId to trace datasource to show that\n * trace.\n */\nexport const getFieldLinksForExplore = (options: {\n  field: Field;\n  rowIndex: number;\n  splitOpenFn?: SplitOpen;\n  range: TimeRange;\n  vars?: ScopedVars;\n  dataFrame?: DataFrame;\n}): Array<LinkModel<Field>> => {\n  const { field, vars, splitOpenFn, range, rowIndex, dataFrame } = options;\n  const scopedVars: any = { ...(vars || {}) };\n  scopedVars['__value'] = {\n    value: {\n      raw: field.values.get(rowIndex),\n    },\n    text: 'Raw value',\n  };\n\n  // If we have a dataFrame we can allow referencing other columns and their values in the interpolation.\n  if (dataFrame) {\n    scopedVars['__data'] = {\n      value: {\n        name: dataFrame.name,\n        refId: dataFrame.refId,\n        fields: getFieldDisplayValuesProxy({\n          frame: dataFrame,\n          rowIndex,\n        }),\n      },\n      text: 'Data',\n    };\n  }\n\n  if (field.config.links) {\n    const links = [];\n\n    if (!contextSrv.hasAccessToExplore()) {\n      links.push(...field.config.links.filter((l) => !l.internal));\n    } else {\n      links.push(...field.config.links);\n    }\n\n    return links.map((link) => {\n      if (!link.internal) {\n        const replace: InterpolateFunction = (value, vars) =>\n          getTemplateSrv().replace(value, { ...vars, ...scopedVars });\n\n        const linkModel = getLinkSrv().getDataLinkUIModel(link, replace, field);\n        if (!linkModel.title) {\n          linkModel.title = getTitleFromHref(linkModel.href);\n        }\n        return linkModel;\n      } else {\n        return mapInternalLinkToExplore({\n          link,\n          internalLink: link.internal,\n          scopedVars: scopedVars,\n          range,\n          field,\n          onClickFn: splitOpenFn,\n          replaceVariables: getTemplateSrv().replace.bind(getTemplateSrv()),\n        });\n      }\n    });\n  }\n\n  return [];\n};\n\nfunction getTitleFromHref(href: string): string {\n  // The URL constructor needs the url to have protocol\n  if (href.indexOf('://') < 0) {\n    // Doesn't really matter what protocol we use.\n    href = `http://${href}`;\n  }\n  let title;\n  try {\n    const parsedUrl = new URL(href);\n    title = parsedUrl.hostname;\n  } catch (_e) {\n    // Should be good enough fallback, user probably did not input valid url.\n    title = href;\n  }\n  return title;\n}\n\n/**\n * Hook that returns a function that can be used to retrieve all the links for a row. This returns all the links from\n * all the fields so is useful for visualisation where the whole row is represented as single clickable item like a\n * service map.\n */\nexport function useLinks(range: TimeRange, splitOpenFn?: SplitOpen) {\n  return useCallback(\n    (dataFrame: DataFrame, rowIndex: number) => {\n      return dataFrame.fields.flatMap((f) => {\n        if (f.config?.links && f.config?.links.length) {\n          return getFieldLinksForExplore({\n            field: f,\n            rowIndex: rowIndex,\n            range,\n            dataFrame,\n            splitOpenFn,\n          });\n        } else {\n          return [];\n        }\n      });\n    },\n    [range, splitOpenFn]\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}