{"ast":null,"code":"import { defaultAddOperationHandler } from './shared/operationUtils';\nimport { PromOperationId, PromVisualQueryOperationCategory } from './types';\nexport const binaryScalarDefs = [{\n  id: PromOperationId.Addition,\n  name: 'Add scalar',\n  sign: '+'\n}, {\n  id: PromOperationId.Subtraction,\n  name: 'Subtract scalar',\n  sign: '-'\n}, {\n  id: PromOperationId.MultiplyBy,\n  name: 'Multiply by scalar',\n  sign: '*'\n}, {\n  id: PromOperationId.DivideBy,\n  name: 'Divide by scalar',\n  sign: '/'\n}, {\n  id: PromOperationId.Modulo,\n  name: 'Modulo by scalar',\n  sign: '%'\n}, {\n  id: PromOperationId.Exponent,\n  name: 'Exponent',\n  sign: '^'\n}, {\n  id: PromOperationId.EqualTo,\n  name: 'Equal to',\n  sign: '==',\n  comparison: true\n}, {\n  id: PromOperationId.NotEqualTo,\n  name: 'Not equal to',\n  sign: '!=',\n  comparison: true\n}, {\n  id: PromOperationId.GreaterThan,\n  name: 'Greater than',\n  sign: '>',\n  comparison: true\n}, {\n  id: PromOperationId.LessThan,\n  name: 'Less than',\n  sign: '<',\n  comparison: true\n}, {\n  id: PromOperationId.GreaterOrEqual,\n  name: 'Greater or equal to',\n  sign: '>=',\n  comparison: true\n}, {\n  id: PromOperationId.LessOrEqual,\n  name: 'Less or equal to',\n  sign: '<=',\n  comparison: true\n}];\nexport const binaryScalarOperatorToOperatorName = binaryScalarDefs.reduce((acc, def) => {\n  acc[def.sign] = {\n    id: def.id,\n    comparison: def.comparison\n  };\n  return acc;\n}, {}); // Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies\n// both the operator and the operand in a single input\n\nexport const binaryScalarOperations = binaryScalarDefs.map(opDef => {\n  const params = [{\n    name: 'Value',\n    type: 'number'\n  }];\n  const defaultParams = [2];\n\n  if (opDef.comparison) {\n    params.push({\n      name: 'Bool',\n      type: 'boolean',\n      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.'\n    });\n    defaultParams.push(false);\n  }\n\n  return {\n    id: opDef.id,\n    name: opDef.name,\n    params,\n    defaultParams,\n    alternativesKey: 'binary scalar operations',\n    category: PromVisualQueryOperationCategory.BinaryOps,\n    renderer: getSimpleBinaryRenderer(opDef.sign),\n    addOperationHandler: defaultAddOperationHandler\n  };\n});\n\nfunction getSimpleBinaryRenderer(operator) {\n  return function binaryRenderer(model, def, innerExpr) {\n    let param = model.params[0];\n    let bool = '';\n\n    if (model.params.length === 2) {\n      bool = model.params[1] ? ' bool' : '';\n    }\n\n    return `${innerExpr} ${operator}${bool} ${param}`;\n  };\n}","map":{"version":3,"names":["defaultAddOperationHandler","PromOperationId","PromVisualQueryOperationCategory","binaryScalarDefs","id","Addition","name","sign","Subtraction","MultiplyBy","DivideBy","Modulo","Exponent","EqualTo","comparison","NotEqualTo","GreaterThan","LessThan","GreaterOrEqual","LessOrEqual","binaryScalarOperatorToOperatorName","reduce","acc","def","binaryScalarOperations","map","opDef","params","type","defaultParams","push","description","alternativesKey","category","BinaryOps","renderer","getSimpleBinaryRenderer","addOperationHandler","operator","binaryRenderer","model","innerExpr","param","bool","length"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts"],"sourcesContent":["import { defaultAddOperationHandler } from './shared/operationUtils';\nimport { QueryBuilderOperation, QueryBuilderOperationDef, QueryBuilderOperationParamDef } from './shared/types';\nimport { PromOperationId, PromVisualQueryOperationCategory } from './types';\n\nexport const binaryScalarDefs = [\n  {\n    id: PromOperationId.Addition,\n    name: 'Add scalar',\n    sign: '+',\n  },\n  {\n    id: PromOperationId.Subtraction,\n    name: 'Subtract scalar',\n    sign: '-',\n  },\n  {\n    id: PromOperationId.MultiplyBy,\n    name: 'Multiply by scalar',\n    sign: '*',\n  },\n  {\n    id: PromOperationId.DivideBy,\n    name: 'Divide by scalar',\n    sign: '/',\n  },\n  {\n    id: PromOperationId.Modulo,\n    name: 'Modulo by scalar',\n    sign: '%',\n  },\n  {\n    id: PromOperationId.Exponent,\n    name: 'Exponent',\n    sign: '^',\n  },\n  {\n    id: PromOperationId.EqualTo,\n    name: 'Equal to',\n    sign: '==',\n    comparison: true,\n  },\n  {\n    id: PromOperationId.NotEqualTo,\n    name: 'Not equal to',\n    sign: '!=',\n    comparison: true,\n  },\n  {\n    id: PromOperationId.GreaterThan,\n    name: 'Greater than',\n    sign: '>',\n    comparison: true,\n  },\n  {\n    id: PromOperationId.LessThan,\n    name: 'Less than',\n    sign: '<',\n    comparison: true,\n  },\n  {\n    id: PromOperationId.GreaterOrEqual,\n    name: 'Greater or equal to',\n    sign: '>=',\n    comparison: true,\n  },\n  {\n    id: PromOperationId.LessOrEqual,\n    name: 'Less or equal to',\n    sign: '<=',\n    comparison: true,\n  },\n];\n\nexport const binaryScalarOperatorToOperatorName = binaryScalarDefs.reduce((acc, def) => {\n  acc[def.sign] = {\n    id: def.id,\n    comparison: def.comparison,\n  };\n  return acc;\n}, {} as Record<string, { id: string; comparison?: boolean }>);\n\n// Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies\n// both the operator and the operand in a single input\nexport const binaryScalarOperations: QueryBuilderOperationDef[] = binaryScalarDefs.map((opDef) => {\n  const params: QueryBuilderOperationParamDef[] = [{ name: 'Value', type: 'number' }];\n  const defaultParams: any[] = [2];\n  if (opDef.comparison) {\n    params.push({\n      name: 'Bool',\n      type: 'boolean',\n      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.',\n    });\n    defaultParams.push(false);\n  }\n\n  return {\n    id: opDef.id,\n    name: opDef.name,\n    params,\n    defaultParams,\n    alternativesKey: 'binary scalar operations',\n    category: PromVisualQueryOperationCategory.BinaryOps,\n    renderer: getSimpleBinaryRenderer(opDef.sign),\n    addOperationHandler: defaultAddOperationHandler,\n  };\n});\n\nfunction getSimpleBinaryRenderer(operator: string) {\n  return function binaryRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n    let param = model.params[0];\n    let bool = '';\n    if (model.params.length === 2) {\n      bool = model.params[1] ? ' bool' : '';\n    }\n\n    return `${innerExpr} ${operator}${bool} ${param}`;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}