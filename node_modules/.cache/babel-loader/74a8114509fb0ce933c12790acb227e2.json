{"ast":null,"code":"import { isString } from 'lodash';\nimport { map } from 'rxjs/operators';\nimport { ArrayVector, DataTransformerID, FieldType, getFieldTypeFromValue } from '@grafana/data';\nimport { findField } from 'app/features/dimensions';\nimport { FieldExtractorID, fieldExtractors } from './fieldExtractors';\nexport const extractFieldsTransformer = {\n  id: DataTransformerID.extractFields,\n  name: 'Extract fields',\n  description: 'Parse fields from the contends of another',\n  defaultOptions: {},\n  operator: options => source => source.pipe(map(data => extractFieldsTransformer.transformer(options)(data))),\n  transformer: options => {\n    return data => {\n      return data.map(v => addExtractedFields(v, options));\n    };\n  }\n};\n\nfunction addExtractedFields(frame, options) {\n  var _options$format;\n\n  if (!options.source) {\n    return frame;\n  }\n\n  const source = findField(frame, options.source);\n\n  if (!source) {\n    // this case can happen when there are multiple queries\n    return frame;\n  }\n\n  const ext = fieldExtractors.getIfExists((_options$format = options.format) !== null && _options$format !== void 0 ? _options$format : FieldExtractorID.Auto);\n\n  if (!ext) {\n    throw new Error('unkonwn extractor');\n  }\n\n  const count = frame.length;\n  const names = []; // keep order\n\n  const values = new Map();\n\n  for (let i = 0; i < count; i++) {\n    let obj = source.values.get(i);\n\n    if (isString(obj)) {\n      try {\n        obj = ext.parse(obj);\n      } catch {\n        obj = {}; // empty\n      }\n    }\n\n    for (const [key, val] of Object.entries(obj)) {\n      let buffer = values.get(key);\n\n      if (buffer == null) {\n        buffer = new Array(count);\n        values.set(key, buffer);\n        names.push(key);\n      }\n\n      buffer[i] = val;\n    }\n  }\n\n  const fields = names.map(name => {\n    const buffer = values.get(name);\n    return {\n      name,\n      values: new ArrayVector(buffer),\n      type: buffer ? getFieldTypeFromValue(buffer.find(v => v != null)) : FieldType.other,\n      config: {}\n    };\n  });\n\n  if (!options.replace) {\n    fields.unshift(...frame.fields);\n  }\n\n  return Object.assign({}, frame, {\n    fields\n  });\n}","map":{"version":3,"names":["isString","map","ArrayVector","DataTransformerID","FieldType","getFieldTypeFromValue","findField","FieldExtractorID","fieldExtractors","extractFieldsTransformer","id","extractFields","name","description","defaultOptions","operator","options","source","pipe","data","transformer","v","addExtractedFields","frame","ext","getIfExists","format","Auto","Error","count","length","names","values","Map","i","obj","get","parse","key","val","Object","entries","buffer","Array","set","push","fields","type","find","other","config","replace","unshift"],"sources":["/home/soula/grafana/public/app/features/transformers/extractFields/extractFields.ts"],"sourcesContent":["import { isString } from 'lodash';\nimport { map } from 'rxjs/operators';\n\nimport {\n  ArrayVector,\n  DataFrame,\n  DataTransformerID,\n  Field,\n  FieldType,\n  getFieldTypeFromValue,\n  SynchronousDataTransformerInfo,\n} from '@grafana/data';\nimport { findField } from 'app/features/dimensions';\n\nimport { FieldExtractorID, fieldExtractors } from './fieldExtractors';\n\nexport interface ExtractFieldsOptions {\n  source?: string;\n  format?: FieldExtractorID;\n  replace?: boolean;\n}\n\nexport const extractFieldsTransformer: SynchronousDataTransformerInfo<ExtractFieldsOptions> = {\n  id: DataTransformerID.extractFields,\n  name: 'Extract fields',\n  description: 'Parse fields from the contends of another',\n  defaultOptions: {},\n\n  operator: (options) => (source) => source.pipe(map((data) => extractFieldsTransformer.transformer(options)(data))),\n\n  transformer: (options: ExtractFieldsOptions) => {\n    return (data: DataFrame[]) => {\n      return data.map((v) => addExtractedFields(v, options));\n    };\n  },\n};\n\nfunction addExtractedFields(frame: DataFrame, options: ExtractFieldsOptions): DataFrame {\n  if (!options.source) {\n    return frame;\n  }\n  const source = findField(frame, options.source);\n  if (!source) {\n    // this case can happen when there are multiple queries\n    return frame;\n  }\n\n  const ext = fieldExtractors.getIfExists(options.format ?? FieldExtractorID.Auto);\n  if (!ext) {\n    throw new Error('unkonwn extractor');\n  }\n\n  const count = frame.length;\n  const names: string[] = []; // keep order\n  const values = new Map<string, any[]>();\n\n  for (let i = 0; i < count; i++) {\n    let obj = source.values.get(i);\n    if (isString(obj)) {\n      try {\n        obj = ext.parse(obj);\n      } catch {\n        obj = {}; // empty\n      }\n    }\n    for (const [key, val] of Object.entries(obj)) {\n      let buffer = values.get(key);\n      if (buffer == null) {\n        buffer = new Array(count);\n        values.set(key, buffer);\n        names.push(key);\n      }\n      buffer[i] = val;\n    }\n  }\n\n  const fields = names.map((name) => {\n    const buffer = values.get(name);\n    return {\n      name,\n      values: new ArrayVector(buffer),\n      type: buffer ? getFieldTypeFromValue(buffer.find((v) => v != null)) : FieldType.other,\n      config: {},\n    } as Field;\n  });\n\n  if (!options.replace) {\n    fields.unshift(...frame.fields);\n  }\n  return {\n    ...frame,\n    fields,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}