{"ast":null,"code":"import { NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\nimport { getNonOverlappingDuration, getStats, makeFrames, makeSpanMap } from '../../../core/utils/tracing';\nexport function createGraphFrames(data) {\n  const {\n    nodes,\n    edges\n  } = convertTraceToGraph(data);\n  const [nodesFrame, edgesFrame] = makeFrames();\n\n  for (const node of nodes) {\n    nodesFrame.add(node);\n  }\n\n  for (const edge of edges) {\n    edgesFrame.add(edge);\n  }\n\n  return [nodesFrame, edgesFrame];\n}\n\nfunction convertTraceToGraph(data) {\n  const nodes = [];\n  const edges = [];\n  const traceDuration = findTraceDuration(data.spans);\n  const spanMap = makeSpanMap(index => {\n    var _span$references;\n\n    if (index >= data.spans.length) {\n      return undefined;\n    }\n\n    const span = data.spans[index];\n    return {\n      span,\n      id: span.spanID,\n      parentIds: ((_span$references = span.references) === null || _span$references === void 0 ? void 0 : _span$references.filter(r => r.refType === 'CHILD_OF').map(r => r.spanID)) || []\n    };\n  });\n\n  for (const span of data.spans) {\n    var _process$serviceName, _span$references2, _span$references2$fin;\n\n    const process = data.processes[span.processID];\n    const ranges = spanMap[span.spanID].children.map(c => {\n      const span = spanMap[c].span;\n      return [span.startTime, span.startTime + span.duration];\n    });\n    const childrenDuration = getNonOverlappingDuration(ranges);\n    const selfDuration = span.duration - childrenDuration;\n    const stats = getStats(span.duration / 1000, traceDuration / 1000, selfDuration / 1000);\n    nodes.push({\n      [Fields.id]: span.spanID,\n      [Fields.title]: (_process$serviceName = process === null || process === void 0 ? void 0 : process.serviceName) !== null && _process$serviceName !== void 0 ? _process$serviceName : '',\n      [Fields.subTitle]: span.operationName,\n      [Fields.mainStat]: stats.main,\n      [Fields.secondaryStat]: stats.secondary,\n      [Fields.color]: selfDuration / traceDuration\n    });\n    const parentSpanID = (_span$references2 = span.references) === null || _span$references2 === void 0 ? void 0 : (_span$references2$fin = _span$references2.find(r => r.refType === 'CHILD_OF')) === null || _span$references2$fin === void 0 ? void 0 : _span$references2$fin.spanID; // Sometimes some span can be missing. Don't add edges for those.\n\n    if (parentSpanID && spanMap[parentSpanID].span) {\n      edges.push({\n        [Fields.id]: parentSpanID + '--' + span.spanID,\n        [Fields.target]: span.spanID,\n        [Fields.source]: parentSpanID\n      });\n    }\n  }\n\n  return {\n    nodes,\n    edges\n  };\n}\n/**\n * Get the duration of the whole trace as it isn't a part of the response data.\n * Note: Seems like this should be the same as just longest span, but this is probably safer.\n */\n\n\nfunction findTraceDuration(spans) {\n  let traceEndTime = 0;\n  let traceStartTime = Infinity;\n\n  for (const span of spans) {\n    if (span.startTime < traceStartTime) {\n      traceStartTime = span.startTime;\n    }\n\n    if (span.startTime + span.duration > traceEndTime) {\n      traceEndTime = span.startTime + span.duration;\n    }\n  }\n\n  return traceEndTime - traceStartTime;\n}","map":{"version":3,"names":["NodeGraphDataFrameFieldNames","Fields","getNonOverlappingDuration","getStats","makeFrames","makeSpanMap","createGraphFrames","data","nodes","edges","convertTraceToGraph","nodesFrame","edgesFrame","node","add","edge","traceDuration","findTraceDuration","spans","spanMap","index","length","undefined","span","id","spanID","parentIds","references","filter","r","refType","map","process","processes","processID","ranges","children","c","startTime","duration","childrenDuration","selfDuration","stats","push","title","serviceName","subTitle","operationName","mainStat","main","secondaryStat","secondary","color","parentSpanID","find","target","source","traceEndTime","traceStartTime","Infinity"],"sources":["/home/soula/grafana/public/app/plugins/datasource/jaeger/graphTransform.ts"],"sourcesContent":["import { DataFrame, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\n\nimport { getNonOverlappingDuration, getStats, makeFrames, makeSpanMap } from '../../../core/utils/tracing';\n\nimport { Span, TraceResponse } from './types';\n\ninterface Node {\n  [Fields.id]: string;\n  [Fields.title]: string;\n  [Fields.subTitle]: string;\n  [Fields.mainStat]: string;\n  [Fields.secondaryStat]: string;\n  [Fields.color]: number;\n}\n\ninterface Edge {\n  [Fields.id]: string;\n  [Fields.target]: string;\n  [Fields.source]: string;\n}\n\nexport function createGraphFrames(data: TraceResponse): DataFrame[] {\n  const { nodes, edges } = convertTraceToGraph(data);\n  const [nodesFrame, edgesFrame] = makeFrames();\n\n  for (const node of nodes) {\n    nodesFrame.add(node);\n  }\n\n  for (const edge of edges) {\n    edgesFrame.add(edge);\n  }\n\n  return [nodesFrame, edgesFrame];\n}\n\nfunction convertTraceToGraph(data: TraceResponse): { nodes: Node[]; edges: Edge[] } {\n  const nodes: Node[] = [];\n  const edges: Edge[] = [];\n\n  const traceDuration = findTraceDuration(data.spans);\n\n  const spanMap = makeSpanMap((index) => {\n    if (index >= data.spans.length) {\n      return undefined;\n    }\n    const span = data.spans[index];\n    return {\n      span,\n      id: span.spanID,\n      parentIds: span.references?.filter((r) => r.refType === 'CHILD_OF').map((r) => r.spanID) || [],\n    };\n  });\n\n  for (const span of data.spans) {\n    const process = data.processes[span.processID];\n\n    const ranges: Array<[number, number]> = spanMap[span.spanID].children.map((c) => {\n      const span = spanMap[c].span;\n      return [span.startTime, span.startTime + span.duration];\n    });\n    const childrenDuration = getNonOverlappingDuration(ranges);\n    const selfDuration = span.duration - childrenDuration;\n    const stats = getStats(span.duration / 1000, traceDuration / 1000, selfDuration / 1000);\n\n    nodes.push({\n      [Fields.id]: span.spanID,\n      [Fields.title]: process?.serviceName ?? '',\n      [Fields.subTitle]: span.operationName,\n      [Fields.mainStat]: stats.main,\n      [Fields.secondaryStat]: stats.secondary,\n      [Fields.color]: selfDuration / traceDuration,\n    });\n\n    const parentSpanID = span.references?.find((r) => r.refType === 'CHILD_OF')?.spanID;\n    // Sometimes some span can be missing. Don't add edges for those.\n    if (parentSpanID && spanMap[parentSpanID].span) {\n      edges.push({\n        [Fields.id]: parentSpanID + '--' + span.spanID,\n        [Fields.target]: span.spanID,\n        [Fields.source]: parentSpanID,\n      });\n    }\n  }\n\n  return { nodes, edges };\n}\n\n/**\n * Get the duration of the whole trace as it isn't a part of the response data.\n * Note: Seems like this should be the same as just longest span, but this is probably safer.\n */\nfunction findTraceDuration(spans: Span[]): number {\n  let traceEndTime = 0;\n  let traceStartTime = Infinity;\n\n  for (const span of spans) {\n    if (span.startTime < traceStartTime) {\n      traceStartTime = span.startTime;\n    }\n\n    if (span.startTime + span.duration > traceEndTime) {\n      traceEndTime = span.startTime + span.duration;\n    }\n  }\n\n  return traceEndTime - traceStartTime;\n}\n"],"mappings":"AAAA,SAAoBA,4BAA4B,IAAIC,MAApD,QAAkE,eAAlE;AAEA,SAASC,yBAAT,EAAoCC,QAApC,EAA8CC,UAA9C,EAA0DC,WAA1D,QAA6E,6BAA7E;AAmBA,OAAO,SAASC,iBAAT,CAA2BC,IAA3B,EAA6D;EAClE,MAAM;IAAEC,KAAF;IAASC;EAAT,IAAmBC,mBAAmB,CAACH,IAAD,CAA5C;EACA,MAAM,CAACI,UAAD,EAAaC,UAAb,IAA2BR,UAAU,EAA3C;;EAEA,KAAK,MAAMS,IAAX,IAAmBL,KAAnB,EAA0B;IACxBG,UAAU,CAACG,GAAX,CAAeD,IAAf;EACD;;EAED,KAAK,MAAME,IAAX,IAAmBN,KAAnB,EAA0B;IACxBG,UAAU,CAACE,GAAX,CAAeC,IAAf;EACD;;EAED,OAAO,CAACJ,UAAD,EAAaC,UAAb,CAAP;AACD;;AAED,SAASF,mBAAT,CAA6BH,IAA7B,EAAoF;EAClF,MAAMC,KAAa,GAAG,EAAtB;EACA,MAAMC,KAAa,GAAG,EAAtB;EAEA,MAAMO,aAAa,GAAGC,iBAAiB,CAACV,IAAI,CAACW,KAAN,CAAvC;EAEA,MAAMC,OAAO,GAAGd,WAAW,CAAEe,KAAD,IAAW;IAAA;;IACrC,IAAIA,KAAK,IAAIb,IAAI,CAACW,KAAL,CAAWG,MAAxB,EAAgC;MAC9B,OAAOC,SAAP;IACD;;IACD,MAAMC,IAAI,GAAGhB,IAAI,CAACW,KAAL,CAAWE,KAAX,CAAb;IACA,OAAO;MACLG,IADK;MAELC,EAAE,EAAED,IAAI,CAACE,MAFJ;MAGLC,SAAS,EAAE,qBAAAH,IAAI,CAACI,UAAL,sEAAiBC,MAAjB,CAAyBC,CAAD,IAAOA,CAAC,CAACC,OAAF,KAAc,UAA7C,EAAyDC,GAAzD,CAA8DF,CAAD,IAAOA,CAAC,CAACJ,MAAtE,MAAiF;IAHvF,CAAP;EAKD,CAV0B,CAA3B;;EAYA,KAAK,MAAMF,IAAX,IAAmBhB,IAAI,CAACW,KAAxB,EAA+B;IAAA;;IAC7B,MAAMc,OAAO,GAAGzB,IAAI,CAAC0B,SAAL,CAAeV,IAAI,CAACW,SAApB,CAAhB;IAEA,MAAMC,MAA+B,GAAGhB,OAAO,CAACI,IAAI,CAACE,MAAN,CAAP,CAAqBW,QAArB,CAA8BL,GAA9B,CAAmCM,CAAD,IAAO;MAC/E,MAAMd,IAAI,GAAGJ,OAAO,CAACkB,CAAD,CAAP,CAAWd,IAAxB;MACA,OAAO,CAACA,IAAI,CAACe,SAAN,EAAiBf,IAAI,CAACe,SAAL,GAAiBf,IAAI,CAACgB,QAAvC,CAAP;IACD,CAHuC,CAAxC;IAIA,MAAMC,gBAAgB,GAAGtC,yBAAyB,CAACiC,MAAD,CAAlD;IACA,MAAMM,YAAY,GAAGlB,IAAI,CAACgB,QAAL,GAAgBC,gBAArC;IACA,MAAME,KAAK,GAAGvC,QAAQ,CAACoB,IAAI,CAACgB,QAAL,GAAgB,IAAjB,EAAuBvB,aAAa,GAAG,IAAvC,EAA6CyB,YAAY,GAAG,IAA5D,CAAtB;IAEAjC,KAAK,CAACmC,IAAN,CAAW;MACT,CAAC1C,MAAM,CAACuB,EAAR,GAAaD,IAAI,CAACE,MADT;MAET,CAACxB,MAAM,CAAC2C,KAAR,2BAAgBZ,OAAhB,aAAgBA,OAAhB,uBAAgBA,OAAO,CAAEa,WAAzB,uEAAwC,EAF/B;MAGT,CAAC5C,MAAM,CAAC6C,QAAR,GAAmBvB,IAAI,CAACwB,aAHf;MAIT,CAAC9C,MAAM,CAAC+C,QAAR,GAAmBN,KAAK,CAACO,IAJhB;MAKT,CAAChD,MAAM,CAACiD,aAAR,GAAwBR,KAAK,CAACS,SALrB;MAMT,CAAClD,MAAM,CAACmD,KAAR,GAAgBX,YAAY,GAAGzB;IANtB,CAAX;IASA,MAAMqC,YAAY,wBAAG9B,IAAI,CAACI,UAAR,+EAAG,kBAAiB2B,IAAjB,CAAuBzB,CAAD,IAAOA,CAAC,CAACC,OAAF,KAAc,UAA3C,CAAH,0DAAG,sBAAwDL,MAA7E,CApB6B,CAqB7B;;IACA,IAAI4B,YAAY,IAAIlC,OAAO,CAACkC,YAAD,CAAP,CAAsB9B,IAA1C,EAAgD;MAC9Cd,KAAK,CAACkC,IAAN,CAAW;QACT,CAAC1C,MAAM,CAACuB,EAAR,GAAa6B,YAAY,GAAG,IAAf,GAAsB9B,IAAI,CAACE,MAD/B;QAET,CAACxB,MAAM,CAACsD,MAAR,GAAiBhC,IAAI,CAACE,MAFb;QAGT,CAACxB,MAAM,CAACuD,MAAR,GAAiBH;MAHR,CAAX;IAKD;EACF;;EAED,OAAO;IAAE7C,KAAF;IAASC;EAAT,CAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASQ,iBAAT,CAA2BC,KAA3B,EAAkD;EAChD,IAAIuC,YAAY,GAAG,CAAnB;EACA,IAAIC,cAAc,GAAGC,QAArB;;EAEA,KAAK,MAAMpC,IAAX,IAAmBL,KAAnB,EAA0B;IACxB,IAAIK,IAAI,CAACe,SAAL,GAAiBoB,cAArB,EAAqC;MACnCA,cAAc,GAAGnC,IAAI,CAACe,SAAtB;IACD;;IAED,IAAIf,IAAI,CAACe,SAAL,GAAiBf,IAAI,CAACgB,QAAtB,GAAiCkB,YAArC,EAAmD;MACjDA,YAAY,GAAGlC,IAAI,CAACe,SAAL,GAAiBf,IAAI,CAACgB,QAArC;IACD;EACF;;EAED,OAAOkB,YAAY,GAAGC,cAAtB;AACD"},"metadata":{},"sourceType":"module"}