{"ast":null,"code":"import React, { useState } from 'react';\nimport { toOption } from '@grafana/data';\nimport { Select } from '@grafana/ui';\nimport { promQueryModeller } from '../PromQueryModeller';\nimport { getOperationParamId } from '../shared/operationUtils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function LabelParamEditor({\n  onChange,\n  index,\n  operationIndex,\n  value,\n  query,\n  datasource\n}) {\n  const [state, setState] = useState({});\n  return /*#__PURE__*/_jsx(Select, {\n    inputId: getOperationParamId(operationIndex, index),\n    autoFocus: value === '' ? true : undefined,\n    openMenuOnFocus: true,\n    onOpenMenu: async () => {\n      setState({\n        isLoading: true\n      });\n      const options = await loadGroupByLabels(query, datasource);\n      setState({\n        options,\n        isLoading: undefined\n      });\n    },\n    isLoading: state.isLoading,\n    allowCustomValue: true,\n    noOptionsMessage: \"No labels found\",\n    loadingMessage: \"Loading labels\",\n    options: state.options,\n    value: toOption(value),\n    onChange: value => onChange(index, value.value)\n  });\n}\n\nasync function loadGroupByLabels(query, datasource) {\n  let labels = query.labels; // This function is used by both Prometheus and Loki and this the only difference.\n\n  if (datasource.type === 'prometheus') {\n    labels = [{\n      label: '__name__',\n      op: '=',\n      value: query.metric\n    }, ...query.labels];\n  }\n\n  const expr = promQueryModeller.renderLabels(labels);\n  const result = await datasource.languageProvider.fetchSeriesLabels(expr);\n  return Object.keys(result).map(x => ({\n    label: x,\n    value: x\n  }));\n}","map":{"version":3,"names":["React","useState","toOption","Select","promQueryModeller","getOperationParamId","LabelParamEditor","onChange","index","operationIndex","value","query","datasource","state","setState","undefined","isLoading","options","loadGroupByLabels","labels","type","label","op","metric","expr","renderLabels","result","languageProvider","fetchSeriesLabels","Object","keys","map","x"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx"],"sourcesContent":["import React, { useState } from 'react';\n\nimport { DataSourceApi, SelectableValue, toOption } from '@grafana/data';\nimport { Select } from '@grafana/ui';\n\nimport { promQueryModeller } from '../PromQueryModeller';\nimport { getOperationParamId } from '../shared/operationUtils';\nimport { QueryBuilderLabelFilter, QueryBuilderOperationParamEditorProps } from '../shared/types';\nimport { PromVisualQuery } from '../types';\n\nexport function LabelParamEditor({\n  onChange,\n  index,\n  operationIndex,\n  value,\n  query,\n  datasource,\n}: QueryBuilderOperationParamEditorProps) {\n  const [state, setState] = useState<{\n    options?: Array<SelectableValue<any>>;\n    isLoading?: boolean;\n  }>({});\n\n  return (\n    <Select\n      inputId={getOperationParamId(operationIndex, index)}\n      autoFocus={value === '' ? true : undefined}\n      openMenuOnFocus\n      onOpenMenu={async () => {\n        setState({ isLoading: true });\n        const options = await loadGroupByLabels(query, datasource);\n        setState({ options, isLoading: undefined });\n      }}\n      isLoading={state.isLoading}\n      allowCustomValue\n      noOptionsMessage=\"No labels found\"\n      loadingMessage=\"Loading labels\"\n      options={state.options}\n      value={toOption(value as string)}\n      onChange={(value) => onChange(index, value.value!)}\n    />\n  );\n}\n\nasync function loadGroupByLabels(\n  query: PromVisualQuery,\n  datasource: DataSourceApi\n): Promise<Array<SelectableValue<any>>> {\n  let labels: QueryBuilderLabelFilter[] = query.labels;\n\n  // This function is used by both Prometheus and Loki and this the only difference.\n  if (datasource.type === 'prometheus') {\n    labels = [{ label: '__name__', op: '=', value: query.metric }, ...query.labels];\n  }\n\n  const expr = promQueryModeller.renderLabels(labels);\n  const result = await datasource.languageProvider.fetchSeriesLabels(expr);\n\n  return Object.keys(result).map((x) => ({\n    label: x,\n    value: x,\n  }));\n}\n"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,QAAhB,QAAgC,OAAhC;AAEA,SAAyCC,QAAzC,QAAyD,eAAzD;AACA,SAASC,MAAT,QAAuB,aAAvB;AAEA,SAASC,iBAAT,QAAkC,sBAAlC;AACA,SAASC,mBAAT,QAAoC,0BAApC;;AAIA,OAAO,SAASC,gBAAT,CAA0B;EAC/BC,QAD+B;EAE/BC,KAF+B;EAG/BC,cAH+B;EAI/BC,KAJ+B;EAK/BC,KAL+B;EAM/BC;AAN+B,CAA1B,EAOmC;EACxC,MAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBb,QAAQ,CAG/B,EAH+B,CAAlC;EAKA,oBACE,KAAC,MAAD;IACE,OAAO,EAAEI,mBAAmB,CAACI,cAAD,EAAiBD,KAAjB,CAD9B;IAEE,SAAS,EAAEE,KAAK,KAAK,EAAV,GAAe,IAAf,GAAsBK,SAFnC;IAGE,eAAe,MAHjB;IAIE,UAAU,EAAE,YAAY;MACtBD,QAAQ,CAAC;QAAEE,SAAS,EAAE;MAAb,CAAD,CAAR;MACA,MAAMC,OAAO,GAAG,MAAMC,iBAAiB,CAACP,KAAD,EAAQC,UAAR,CAAvC;MACAE,QAAQ,CAAC;QAAEG,OAAF;QAAWD,SAAS,EAAED;MAAtB,CAAD,CAAR;IACD,CARH;IASE,SAAS,EAAEF,KAAK,CAACG,SATnB;IAUE,gBAAgB,MAVlB;IAWE,gBAAgB,EAAC,iBAXnB;IAYE,cAAc,EAAC,gBAZjB;IAaE,OAAO,EAAEH,KAAK,CAACI,OAbjB;IAcE,KAAK,EAAEf,QAAQ,CAACQ,KAAD,CAdjB;IAeE,QAAQ,EAAGA,KAAD,IAAWH,QAAQ,CAACC,KAAD,EAAQE,KAAK,CAACA,KAAd;EAf/B,EADF;AAmBD;;AAED,eAAeQ,iBAAf,CACEP,KADF,EAEEC,UAFF,EAGwC;EACtC,IAAIO,MAAiC,GAAGR,KAAK,CAACQ,MAA9C,CADsC,CAGtC;;EACA,IAAIP,UAAU,CAACQ,IAAX,KAAoB,YAAxB,EAAsC;IACpCD,MAAM,GAAG,CAAC;MAAEE,KAAK,EAAE,UAAT;MAAqBC,EAAE,EAAE,GAAzB;MAA8BZ,KAAK,EAAEC,KAAK,CAACY;IAA3C,CAAD,EAAsD,GAAGZ,KAAK,CAACQ,MAA/D,CAAT;EACD;;EAED,MAAMK,IAAI,GAAGpB,iBAAiB,CAACqB,YAAlB,CAA+BN,MAA/B,CAAb;EACA,MAAMO,MAAM,GAAG,MAAMd,UAAU,CAACe,gBAAX,CAA4BC,iBAA5B,CAA8CJ,IAA9C,CAArB;EAEA,OAAOK,MAAM,CAACC,IAAP,CAAYJ,MAAZ,EAAoBK,GAApB,CAAyBC,CAAD,KAAQ;IACrCX,KAAK,EAAEW,CAD8B;IAErCtB,KAAK,EAAEsB;EAF8B,CAAR,CAAxB,CAAP;AAID"},"metadata":{},"sourceType":"module"}