{"ast":null,"code":"const _excluded = [\"text\", \"type\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n// Libraries\nimport { isArray, isBoolean, isNumber, isString } from 'lodash'; // Types\n\nimport { isDateTime } from '../datetime/moment_wrapper';\nimport { fieldIndexComparer } from '../field/fieldComparers';\nimport { getFieldDisplayName } from '../field/fieldState';\nimport { FieldType, TIME_SERIES_VALUE_FIELD_NAME, TIME_SERIES_TIME_FIELD_NAME } from '../types/index';\nimport { ArrayVector } from '../vector/ArrayVector';\nimport { SortedVector } from '../vector/SortedVector';\nimport { vectorToArray } from '../vector/vectorToArray';\nimport { ArrayDataFrame } from './ArrayDataFrame';\nimport { dataFrameFromJSON } from './DataFrameJSON';\nimport { MutableDataFrame } from './MutableDataFrame';\n\nfunction convertTableToDataFrame(table) {\n  const fields = table.columns.map(c => {\n    // TODO: should be Column but type does not exists there so not sure whats up here.\n    const _ref = c,\n          {\n      text,\n      type\n    } = _ref,\n          disp = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n    return {\n      name: text !== null && text !== void 0 && text.length ? text : c,\n      // rename 'text' to the 'name' field\n      config: disp || {},\n      values: new ArrayVector(),\n      type: type && Object.values(FieldType).includes(type) ? type : FieldType.other\n    };\n  });\n\n  if (!isArray(table.rows)) {\n    throw new Error(`Expected table rows to be array, got ${typeof table.rows}.`);\n  }\n\n  for (const row of table.rows) {\n    for (let i = 0; i < fields.length; i++) {\n      fields[i].values.buffer.push(row[i]);\n    }\n  }\n\n  for (const f of fields) {\n    if (f.type === FieldType.other) {\n      const t = guessFieldTypeForField(f);\n\n      if (t) {\n        f.type = t;\n      }\n    }\n  }\n\n  return {\n    fields,\n    refId: table.refId,\n    meta: table.meta,\n    name: table.name,\n    length: table.rows.length\n  };\n}\n\nfunction convertTimeSeriesToDataFrame(timeSeries) {\n  const times = [];\n  const values = []; // Sometimes the points are sent as datapoints\n\n  const points = timeSeries.datapoints || timeSeries.points;\n\n  for (const point of points) {\n    values.push(point[0]);\n    times.push(point[1]);\n  }\n\n  const fields = [{\n    name: TIME_SERIES_TIME_FIELD_NAME,\n    type: FieldType.time,\n    config: {},\n    values: new ArrayVector(times)\n  }, {\n    name: TIME_SERIES_VALUE_FIELD_NAME,\n    type: FieldType.number,\n    config: {\n      unit: timeSeries.unit\n    },\n    values: new ArrayVector(values),\n    labels: timeSeries.tags\n  }];\n\n  if (timeSeries.title) {\n    fields[1].config.displayNameFromDS = timeSeries.title;\n  }\n\n  return {\n    name: timeSeries.target || timeSeries.name,\n    refId: timeSeries.refId,\n    meta: timeSeries.meta,\n    fields,\n    length: values.length\n  };\n}\n/**\n * This is added temporarily while we convert the LogsModel\n * to DataFrame.  See: https://github.com/grafana/grafana/issues/18528\n */\n\n\nfunction convertGraphSeriesToDataFrame(graphSeries) {\n  const x = new ArrayVector();\n  const y = new ArrayVector();\n\n  for (let i = 0; i < graphSeries.data.length; i++) {\n    const row = graphSeries.data[i];\n    x.buffer.push(row[1]);\n    y.buffer.push(row[0]);\n  }\n\n  return {\n    name: graphSeries.label,\n    fields: [{\n      name: graphSeries.label || TIME_SERIES_VALUE_FIELD_NAME,\n      type: FieldType.number,\n      config: {},\n      values: x\n    }, {\n      name: TIME_SERIES_TIME_FIELD_NAME,\n      type: FieldType.time,\n      config: {\n        unit: 'dateTimeAsIso'\n      },\n      values: y\n    }],\n    length: x.buffer.length\n  };\n}\n\nfunction convertJSONDocumentDataToDataFrame(timeSeries) {\n  const fields = [{\n    name: timeSeries.target,\n    type: FieldType.other,\n    labels: timeSeries.tags,\n    config: {\n      unit: timeSeries.unit,\n      filterable: timeSeries.filterable\n    },\n    values: new ArrayVector()\n  }];\n\n  for (const point of timeSeries.datapoints) {\n    fields[0].values.buffer.push(point);\n  }\n\n  return {\n    name: timeSeries.target,\n    refId: timeSeries.target,\n    meta: {\n      json: true\n    },\n    fields,\n    length: timeSeries.datapoints.length\n  };\n} // PapaParse Dynamic Typing regex:\n// https://github.com/mholt/PapaParse/blob/master/papaparse.js#L998\n\n\nconst NUMBER = /^\\s*(-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?|NAN)\\s*$/i;\n/**\n * Given a name and value, this will pick a reasonable field type\n */\n\nexport function guessFieldTypeFromNameAndValue(name, v) {\n  if (name) {\n    name = name.toLowerCase();\n\n    if (name === 'date' || name === 'time') {\n      return FieldType.time;\n    }\n  }\n\n  return guessFieldTypeFromValue(v);\n}\n/**\n * Check the field type to see what the contents are\n */\n\nexport function getFieldTypeFromValue(v) {\n  if (v instanceof Date || isDateTime(v)) {\n    return FieldType.time;\n  }\n\n  if (isNumber(v)) {\n    return FieldType.number;\n  }\n\n  if (isString(v)) {\n    return FieldType.string;\n  }\n\n  if (isBoolean(v)) {\n    return FieldType.boolean;\n  }\n\n  return FieldType.other;\n}\n/**\n * Given a value this will guess the best column type\n *\n * NOTE: this is will try to see if string values can be mapped to other types (like number)\n */\n\nexport function guessFieldTypeFromValue(v) {\n  if (v instanceof Date || isDateTime(v)) {\n    return FieldType.time;\n  }\n\n  if (isNumber(v)) {\n    return FieldType.number;\n  }\n\n  if (isString(v)) {\n    if (NUMBER.test(v)) {\n      return FieldType.number;\n    }\n\n    if (v === 'true' || v === 'TRUE' || v === 'True' || v === 'false' || v === 'FALSE' || v === 'False') {\n      return FieldType.boolean;\n    }\n\n    return FieldType.string;\n  }\n\n  if (isBoolean(v)) {\n    return FieldType.boolean;\n  }\n\n  return FieldType.other;\n}\n/**\n * Looks at the data to guess the column type.  This ignores any existing setting\n */\n\nexport function guessFieldTypeForField(field) {\n  // 1. Use the column name to guess\n  if (field.name) {\n    const name = field.name.toLowerCase();\n\n    if (name === 'date' || name === 'time') {\n      return FieldType.time;\n    }\n  } // 2. Check the first non-null value\n\n\n  for (let i = 0; i < field.values.length; i++) {\n    const v = field.values.get(i);\n\n    if (v != null) {\n      return guessFieldTypeFromValue(v);\n    }\n  } // Could not find anything\n\n\n  return undefined;\n}\n/**\n * @returns A copy of the series with the best guess for each field type.\n * If the series already has field types defined, they will be used, unless `guessDefined` is true.\n * @param series The DataFrame whose field's types should be guessed\n * @param guessDefined Whether to guess types of fields with already defined types\n */\n\nexport const guessFieldTypes = (series, guessDefined = false) => {\n  for (const field of series.fields) {\n    if (!field.type || field.type === FieldType.other || guessDefined) {\n      // Something is missing a type, return a modified copy\n      return Object.assign({}, series, {\n        fields: series.fields.map(field => {\n          if (field.type && field.type !== FieldType.other && !guessDefined) {\n            return field;\n          } // Calculate a reasonable schema value\n\n\n          return Object.assign({}, field, {\n            type: guessFieldTypeForField(field) || FieldType.other\n          });\n        })\n      });\n    }\n  } // No changes necessary\n\n\n  return series;\n};\nexport const isTableData = data => data && data.hasOwnProperty('columns');\nexport const isDataFrame = data => data && data.hasOwnProperty('fields');\n/**\n * Inspect any object and return the results as a DataFrame\n */\n\nexport function toDataFrame(data) {\n  if ('fields' in data) {\n    var _data$fields$, _data$fields$$values;\n\n    // DataFrameDTO does not have length\n    if ('length' in data && (_data$fields$ = data.fields[0]) !== null && _data$fields$ !== void 0 && (_data$fields$$values = _data$fields$.values) !== null && _data$fields$$values !== void 0 && _data$fields$$values.get) {\n      return data;\n    } // This will convert the array values into Vectors\n\n\n    return new MutableDataFrame(data);\n  } // Handle legacy docs/json type\n\n\n  if (data.hasOwnProperty('type') && data.type === 'docs') {\n    return convertJSONDocumentDataToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('datapoints') || data.hasOwnProperty('points')) {\n    return convertTimeSeriesToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('data')) {\n    if (data.hasOwnProperty('schema')) {\n      return dataFrameFromJSON(data);\n    }\n\n    return convertGraphSeriesToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('columns')) {\n    return convertTableToDataFrame(data);\n  }\n\n  if (Array.isArray(data)) {\n    return new ArrayDataFrame(data);\n  }\n\n  console.warn('Can not convert', data);\n  throw new Error('Unsupported data format');\n}\nexport const toLegacyResponseData = frame => {\n  const {\n    fields\n  } = frame;\n  const rowCount = frame.length;\n  const rows = [];\n\n  if (fields.length === 2) {\n    const {\n      timeField,\n      timeIndex\n    } = getTimeField(frame);\n\n    if (timeField) {\n      const valueIndex = timeIndex === 0 ? 1 : 0;\n      const valueField = fields[valueIndex];\n      const timeField = fields[timeIndex]; // Make sure it is [value,time]\n\n      for (let i = 0; i < rowCount; i++) {\n        rows.push([valueField.values.get(i), // value\n        timeField.values.get(i) // time\n        ]);\n      }\n\n      return {\n        alias: frame.name,\n        target: getFieldDisplayName(valueField, frame),\n        datapoints: rows,\n        unit: fields[0].config ? fields[0].config.unit : undefined,\n        refId: frame.refId,\n        meta: frame.meta\n      };\n    }\n  }\n\n  for (let i = 0; i < rowCount; i++) {\n    const row = [];\n\n    for (let j = 0; j < fields.length; j++) {\n      row.push(fields[j].values.get(i));\n    }\n\n    rows.push(row);\n  }\n\n  if (frame.meta && frame.meta.json) {\n    return {\n      alias: fields[0].name || frame.name,\n      target: fields[0].name || frame.name,\n      datapoints: fields[0].values.toArray(),\n      filterable: fields[0].config ? fields[0].config.filterable : undefined,\n      type: 'docs'\n    };\n  }\n\n  return {\n    columns: fields.map(f => {\n      const {\n        name,\n        config\n      } = f;\n\n      if (config) {\n        // keep unit etc\n        const column = Object.assign({}, config);\n        column.text = name;\n        return column;\n      }\n\n      return {\n        text: name\n      };\n    }),\n    type: 'table',\n    refId: frame.refId,\n    meta: frame.meta,\n    rows\n  };\n};\nexport function sortDataFrame(data, sortIndex, reverse = false) {\n  const field = data.fields[sortIndex];\n\n  if (!field) {\n    return data;\n  } // Natural order\n\n\n  const index = [];\n\n  for (let i = 0; i < data.length; i++) {\n    index.push(i);\n  }\n\n  const fieldComparer = fieldIndexComparer(field, reverse);\n  index.sort(fieldComparer);\n  return Object.assign({}, data, {\n    fields: data.fields.map(f => {\n      return Object.assign({}, f, {\n        values: new SortedVector(f.values, index)\n      });\n    })\n  });\n}\n/**\n * Returns a copy with all values reversed\n */\n\nexport function reverseDataFrame(data) {\n  return Object.assign({}, data, {\n    fields: data.fields.map(f => {\n      const copy = [...f.values.toArray()];\n      copy.reverse();\n      return Object.assign({}, f, {\n        values: new ArrayVector(copy)\n      });\n    })\n  });\n}\n/**\n * Wrapper to get an array from each field value\n */\n\nexport function getDataFrameRow(data, row) {\n  const values = [];\n\n  for (const field of data.fields) {\n    values.push(field.values.get(row));\n  }\n\n  return values;\n}\n/**\n * Returns a copy that does not include functions\n */\n\nexport function toDataFrameDTO(data) {\n  return toFilteredDataFrameDTO(data);\n}\nexport function toFilteredDataFrameDTO(data, fieldPredicate) {\n  const filteredFields = fieldPredicate ? data.fields.filter(fieldPredicate) : data.fields;\n  const fields = filteredFields.map(f => {\n    let values = f.values.toArray(); // The byte buffers serialize like objects\n\n    if (values instanceof Float64Array) {\n      values = vectorToArray(f.values);\n    }\n\n    return {\n      name: f.name,\n      type: f.type,\n      config: f.config,\n      values,\n      labels: f.labels\n    };\n  });\n  return {\n    fields,\n    refId: data.refId,\n    meta: data.meta,\n    name: data.name\n  };\n}\nexport const getTimeField = series => {\n  for (let i = 0; i < series.fields.length; i++) {\n    if (series.fields[i].type === FieldType.time) {\n      return {\n        timeField: series.fields[i],\n        timeIndex: i\n      };\n    }\n  }\n\n  return {};\n};","map":{"version":3,"names":["isArray","isBoolean","isNumber","isString","isDateTime","fieldIndexComparer","getFieldDisplayName","FieldType","TIME_SERIES_VALUE_FIELD_NAME","TIME_SERIES_TIME_FIELD_NAME","ArrayVector","SortedVector","vectorToArray","ArrayDataFrame","dataFrameFromJSON","MutableDataFrame","convertTableToDataFrame","table","fields","columns","map","c","text","type","disp","name","length","config","values","Object","includes","other","rows","Error","row","i","buffer","push","f","t","guessFieldTypeForField","refId","meta","convertTimeSeriesToDataFrame","timeSeries","times","points","datapoints","point","time","number","unit","labels","tags","title","displayNameFromDS","target","convertGraphSeriesToDataFrame","graphSeries","x","y","data","label","convertJSONDocumentDataToDataFrame","filterable","json","NUMBER","guessFieldTypeFromNameAndValue","v","toLowerCase","guessFieldTypeFromValue","getFieldTypeFromValue","Date","string","boolean","test","field","get","undefined","guessFieldTypes","series","guessDefined","isTableData","hasOwnProperty","isDataFrame","toDataFrame","Array","console","warn","toLegacyResponseData","frame","rowCount","timeField","timeIndex","getTimeField","valueIndex","valueField","alias","j","toArray","column","sortDataFrame","sortIndex","reverse","index","fieldComparer","sort","reverseDataFrame","copy","getDataFrameRow","toDataFrameDTO","toFilteredDataFrameDTO","fieldPredicate","filteredFields","filter","Float64Array"],"sources":["/home/soula/grafana/packages/grafana-data/src/dataframe/processDataFrame.ts"],"sourcesContent":["// Libraries\nimport { isArray, isBoolean, isNumber, isString } from 'lodash';\n\n// Types\nimport { isDateTime } from '../datetime/moment_wrapper';\nimport { fieldIndexComparer } from '../field/fieldComparers';\nimport { getFieldDisplayName } from '../field/fieldState';\nimport {\n  DataFrame,\n  Field,\n  FieldConfig,\n  TimeSeries,\n  FieldType,\n  TableData,\n  Column,\n  GraphSeriesXY,\n  TimeSeriesValue,\n  FieldDTO,\n  DataFrameDTO,\n  TIME_SERIES_VALUE_FIELD_NAME,\n  TIME_SERIES_TIME_FIELD_NAME,\n} from '../types/index';\nimport { ArrayVector } from '../vector/ArrayVector';\nimport { SortedVector } from '../vector/SortedVector';\nimport { vectorToArray } from '../vector/vectorToArray';\n\nimport { ArrayDataFrame } from './ArrayDataFrame';\nimport { dataFrameFromJSON } from './DataFrameJSON';\nimport { MutableDataFrame } from './MutableDataFrame';\n\nfunction convertTableToDataFrame(table: TableData): DataFrame {\n  const fields = table.columns.map((c) => {\n    // TODO: should be Column but type does not exists there so not sure whats up here.\n    const { text, type, ...disp } = c as any;\n    return {\n      name: text?.length ? text : c, // rename 'text' to the 'name' field\n      config: (disp || {}) as FieldConfig,\n      values: new ArrayVector(),\n      type: type && Object.values(FieldType).includes(type as FieldType) ? (type as FieldType) : FieldType.other,\n    };\n  });\n\n  if (!isArray(table.rows)) {\n    throw new Error(`Expected table rows to be array, got ${typeof table.rows}.`);\n  }\n\n  for (const row of table.rows) {\n    for (let i = 0; i < fields.length; i++) {\n      fields[i].values.buffer.push(row[i]);\n    }\n  }\n\n  for (const f of fields) {\n    if (f.type === FieldType.other) {\n      const t = guessFieldTypeForField(f);\n      if (t) {\n        f.type = t;\n      }\n    }\n  }\n\n  return {\n    fields,\n    refId: table.refId,\n    meta: table.meta,\n    name: table.name,\n    length: table.rows.length,\n  };\n}\n\nfunction convertTimeSeriesToDataFrame(timeSeries: TimeSeries): DataFrame {\n  const times: number[] = [];\n  const values: TimeSeriesValue[] = [];\n\n  // Sometimes the points are sent as datapoints\n  const points = timeSeries.datapoints || (timeSeries as any).points;\n  for (const point of points) {\n    values.push(point[0]);\n    times.push(point[1] as number);\n  }\n\n  const fields = [\n    {\n      name: TIME_SERIES_TIME_FIELD_NAME,\n      type: FieldType.time,\n      config: {},\n      values: new ArrayVector<number>(times),\n    },\n    {\n      name: TIME_SERIES_VALUE_FIELD_NAME,\n      type: FieldType.number,\n      config: {\n        unit: timeSeries.unit,\n      },\n      values: new ArrayVector<TimeSeriesValue>(values),\n      labels: timeSeries.tags,\n    },\n  ];\n\n  if (timeSeries.title) {\n    (fields[1].config as FieldConfig).displayNameFromDS = timeSeries.title;\n  }\n\n  return {\n    name: timeSeries.target || (timeSeries as any).name,\n    refId: timeSeries.refId,\n    meta: timeSeries.meta,\n    fields,\n    length: values.length,\n  };\n}\n\n/**\n * This is added temporarily while we convert the LogsModel\n * to DataFrame.  See: https://github.com/grafana/grafana/issues/18528\n */\nfunction convertGraphSeriesToDataFrame(graphSeries: GraphSeriesXY): DataFrame {\n  const x = new ArrayVector();\n  const y = new ArrayVector();\n\n  for (let i = 0; i < graphSeries.data.length; i++) {\n    const row = graphSeries.data[i];\n    x.buffer.push(row[1]);\n    y.buffer.push(row[0]);\n  }\n\n  return {\n    name: graphSeries.label,\n    fields: [\n      {\n        name: graphSeries.label || TIME_SERIES_VALUE_FIELD_NAME,\n        type: FieldType.number,\n        config: {},\n        values: x,\n      },\n      {\n        name: TIME_SERIES_TIME_FIELD_NAME,\n        type: FieldType.time,\n        config: {\n          unit: 'dateTimeAsIso',\n        },\n        values: y,\n      },\n    ],\n    length: x.buffer.length,\n  };\n}\n\nfunction convertJSONDocumentDataToDataFrame(timeSeries: TimeSeries): DataFrame {\n  const fields = [\n    {\n      name: timeSeries.target,\n      type: FieldType.other,\n      labels: timeSeries.tags,\n      config: {\n        unit: timeSeries.unit,\n        filterable: (timeSeries as any).filterable,\n      },\n      values: new ArrayVector(),\n    },\n  ];\n\n  for (const point of timeSeries.datapoints) {\n    fields[0].values.buffer.push(point);\n  }\n\n  return {\n    name: timeSeries.target,\n    refId: timeSeries.target,\n    meta: { json: true },\n    fields,\n    length: timeSeries.datapoints.length,\n  };\n}\n\n// PapaParse Dynamic Typing regex:\n// https://github.com/mholt/PapaParse/blob/master/papaparse.js#L998\nconst NUMBER = /^\\s*(-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?|NAN)\\s*$/i;\n\n/**\n * Given a name and value, this will pick a reasonable field type\n */\nexport function guessFieldTypeFromNameAndValue(name: string, v: any): FieldType {\n  if (name) {\n    name = name.toLowerCase();\n    if (name === 'date' || name === 'time') {\n      return FieldType.time;\n    }\n  }\n  return guessFieldTypeFromValue(v);\n}\n\n/**\n * Check the field type to see what the contents are\n */\nexport function getFieldTypeFromValue(v: any): FieldType {\n  if (v instanceof Date || isDateTime(v)) {\n    return FieldType.time;\n  }\n\n  if (isNumber(v)) {\n    return FieldType.number;\n  }\n\n  if (isString(v)) {\n    return FieldType.string;\n  }\n\n  if (isBoolean(v)) {\n    return FieldType.boolean;\n  }\n\n  return FieldType.other;\n}\n\n/**\n * Given a value this will guess the best column type\n *\n * NOTE: this is will try to see if string values can be mapped to other types (like number)\n */\nexport function guessFieldTypeFromValue(v: any): FieldType {\n  if (v instanceof Date || isDateTime(v)) {\n    return FieldType.time;\n  }\n\n  if (isNumber(v)) {\n    return FieldType.number;\n  }\n\n  if (isString(v)) {\n    if (NUMBER.test(v)) {\n      return FieldType.number;\n    }\n\n    if (v === 'true' || v === 'TRUE' || v === 'True' || v === 'false' || v === 'FALSE' || v === 'False') {\n      return FieldType.boolean;\n    }\n\n    return FieldType.string;\n  }\n\n  if (isBoolean(v)) {\n    return FieldType.boolean;\n  }\n\n  return FieldType.other;\n}\n\n/**\n * Looks at the data to guess the column type.  This ignores any existing setting\n */\nexport function guessFieldTypeForField(field: Field): FieldType | undefined {\n  // 1. Use the column name to guess\n  if (field.name) {\n    const name = field.name.toLowerCase();\n    if (name === 'date' || name === 'time') {\n      return FieldType.time;\n    }\n  }\n\n  // 2. Check the first non-null value\n  for (let i = 0; i < field.values.length; i++) {\n    const v = field.values.get(i);\n    if (v != null) {\n      return guessFieldTypeFromValue(v);\n    }\n  }\n\n  // Could not find anything\n  return undefined;\n}\n\n/**\n * @returns A copy of the series with the best guess for each field type.\n * If the series already has field types defined, they will be used, unless `guessDefined` is true.\n * @param series The DataFrame whose field's types should be guessed\n * @param guessDefined Whether to guess types of fields with already defined types\n */\nexport const guessFieldTypes = (series: DataFrame, guessDefined = false): DataFrame => {\n  for (const field of series.fields) {\n    if (!field.type || field.type === FieldType.other || guessDefined) {\n      // Something is missing a type, return a modified copy\n      return {\n        ...series,\n        fields: series.fields.map((field) => {\n          if (field.type && field.type !== FieldType.other && !guessDefined) {\n            return field;\n          }\n          // Calculate a reasonable schema value\n          return {\n            ...field,\n            type: guessFieldTypeForField(field) || FieldType.other,\n          };\n        }),\n      };\n    }\n  }\n  // No changes necessary\n  return series;\n};\n\nexport const isTableData = (data: any): data is DataFrame => data && data.hasOwnProperty('columns');\n\nexport const isDataFrame = (data: any): data is DataFrame => data && data.hasOwnProperty('fields');\n\n/**\n * Inspect any object and return the results as a DataFrame\n */\nexport function toDataFrame(data: any): DataFrame {\n  if ('fields' in data) {\n    // DataFrameDTO does not have length\n    if ('length' in data && data.fields[0]?.values?.get) {\n      return data as DataFrame;\n    }\n\n    // This will convert the array values into Vectors\n    return new MutableDataFrame(data as DataFrameDTO);\n  }\n\n  // Handle legacy docs/json type\n  if (data.hasOwnProperty('type') && data.type === 'docs') {\n    return convertJSONDocumentDataToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('datapoints') || data.hasOwnProperty('points')) {\n    return convertTimeSeriesToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('data')) {\n    if (data.hasOwnProperty('schema')) {\n      return dataFrameFromJSON(data);\n    }\n    return convertGraphSeriesToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('columns')) {\n    return convertTableToDataFrame(data);\n  }\n\n  if (Array.isArray(data)) {\n    return new ArrayDataFrame(data);\n  }\n\n  console.warn('Can not convert', data);\n  throw new Error('Unsupported data format');\n}\n\nexport const toLegacyResponseData = (frame: DataFrame): TimeSeries | TableData => {\n  const { fields } = frame;\n\n  const rowCount = frame.length;\n  const rows: any[][] = [];\n\n  if (fields.length === 2) {\n    const { timeField, timeIndex } = getTimeField(frame);\n    if (timeField) {\n      const valueIndex = timeIndex === 0 ? 1 : 0;\n      const valueField = fields[valueIndex];\n      const timeField = fields[timeIndex!];\n\n      // Make sure it is [value,time]\n      for (let i = 0; i < rowCount; i++) {\n        rows.push([\n          valueField.values.get(i), // value\n          timeField.values.get(i), // time\n        ]);\n      }\n\n      return {\n        alias: frame.name,\n        target: getFieldDisplayName(valueField, frame),\n        datapoints: rows,\n        unit: fields[0].config ? fields[0].config.unit : undefined,\n        refId: frame.refId,\n        meta: frame.meta,\n      } as TimeSeries;\n    }\n  }\n\n  for (let i = 0; i < rowCount; i++) {\n    const row: any[] = [];\n    for (let j = 0; j < fields.length; j++) {\n      row.push(fields[j].values.get(i));\n    }\n    rows.push(row);\n  }\n\n  if (frame.meta && frame.meta.json) {\n    return {\n      alias: fields[0].name || frame.name,\n      target: fields[0].name || frame.name,\n      datapoints: fields[0].values.toArray(),\n      filterable: fields[0].config ? fields[0].config.filterable : undefined,\n      type: 'docs',\n    } as TimeSeries;\n  }\n\n  return {\n    columns: fields.map((f) => {\n      const { name, config } = f;\n      if (config) {\n        // keep unit etc\n        const { ...column } = config;\n        (column as Column).text = name;\n        return column as Column;\n      }\n      return { text: name };\n    }),\n    type: 'table',\n    refId: frame.refId,\n    meta: frame.meta,\n    rows,\n  };\n};\n\nexport function sortDataFrame(data: DataFrame, sortIndex?: number, reverse = false): DataFrame {\n  const field = data.fields[sortIndex!];\n  if (!field) {\n    return data;\n  }\n\n  // Natural order\n  const index: number[] = [];\n  for (let i = 0; i < data.length; i++) {\n    index.push(i);\n  }\n\n  const fieldComparer = fieldIndexComparer(field, reverse);\n  index.sort(fieldComparer);\n\n  return {\n    ...data,\n    fields: data.fields.map((f) => {\n      return {\n        ...f,\n        values: new SortedVector(f.values, index),\n      };\n    }),\n  };\n}\n\n/**\n * Returns a copy with all values reversed\n */\nexport function reverseDataFrame(data: DataFrame): DataFrame {\n  return {\n    ...data,\n    fields: data.fields.map((f) => {\n      const copy = [...f.values.toArray()];\n      copy.reverse();\n      return {\n        ...f,\n        values: new ArrayVector(copy),\n      };\n    }),\n  };\n}\n\n/**\n * Wrapper to get an array from each field value\n */\nexport function getDataFrameRow(data: DataFrame, row: number): any[] {\n  const values: any[] = [];\n  for (const field of data.fields) {\n    values.push(field.values.get(row));\n  }\n  return values;\n}\n\n/**\n * Returns a copy that does not include functions\n */\nexport function toDataFrameDTO(data: DataFrame): DataFrameDTO {\n  return toFilteredDataFrameDTO(data);\n}\n\nexport function toFilteredDataFrameDTO(data: DataFrame, fieldPredicate?: (f: Field) => boolean): DataFrameDTO {\n  const filteredFields = fieldPredicate ? data.fields.filter(fieldPredicate) : data.fields;\n  const fields: FieldDTO[] = filteredFields.map((f) => {\n    let values = f.values.toArray();\n    // The byte buffers serialize like objects\n    if (values instanceof Float64Array) {\n      values = vectorToArray(f.values);\n    }\n    return {\n      name: f.name,\n      type: f.type,\n      config: f.config,\n      values,\n      labels: f.labels,\n    };\n  });\n\n  return {\n    fields,\n    refId: data.refId,\n    meta: data.meta,\n    name: data.name,\n  };\n}\n\nexport const getTimeField = (series: DataFrame): { timeField?: Field; timeIndex?: number } => {\n  for (let i = 0; i < series.fields.length; i++) {\n    if (series.fields[i].type === FieldType.time) {\n      return {\n        timeField: series.fields[i],\n        timeIndex: i,\n      };\n    }\n  }\n  return {};\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}