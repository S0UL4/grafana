{"ast":null,"code":"import { createAggregationOperation, createAggregationOperationWithParam, getPromAndLokiOperationDisplayName } from '../../prometheus/querybuilder/shared/operationUtils';\nimport { FUNCTIONS } from '../syntax';\nimport { binaryScalarOperations } from './binaryScalarOperations';\nimport { LokiOperationId, LokiOperationOrder, LokiVisualQueryOperationCategory } from './types';\nexport function getOperationDefinitions() {\n  const aggregations = [LokiOperationId.Sum, LokiOperationId.Min, LokiOperationId.Max, LokiOperationId.Avg, LokiOperationId.Stddev, LokiOperationId.Stdvar, LokiOperationId.Count].flatMap(opId => createAggregationOperation(opId, {\n    addOperationHandler: addLokiOperation,\n    orderRank: LokiOperationOrder.Last\n  }));\n  const aggregationsWithParam = [LokiOperationId.TopK, LokiOperationId.BottomK].flatMap(opId => {\n    return createAggregationOperationWithParam(opId, {\n      params: [{\n        name: 'K-value',\n        type: 'number'\n      }],\n      defaultParams: [5]\n    }, {\n      addOperationHandler: addLokiOperation,\n      orderRank: LokiOperationOrder.Last\n    });\n  });\n  const list = [createRangeOperation(LokiOperationId.Rate), createRangeOperation(LokiOperationId.CountOverTime), createRangeOperation(LokiOperationId.SumOverTime), createRangeOperation(LokiOperationId.BytesRate), createRangeOperation(LokiOperationId.BytesOverTime), createRangeOperation(LokiOperationId.AbsentOverTime), createRangeOperation(LokiOperationId.AvgOverTime), createRangeOperation(LokiOperationId.MaxOverTime), createRangeOperation(LokiOperationId.MinOverTime), createRangeOperation(LokiOperationId.FirstOverTime), createRangeOperation(LokiOperationId.LastOverTime), createRangeOperation(LokiOperationId.StdvarOverTime), createRangeOperation(LokiOperationId.StddevOverTime), createRangeOperation(LokiOperationId.QuantileOverTime), ...aggregations, ...aggregationsWithParam, {\n    id: LokiOperationId.Json,\n    name: 'Json',\n    params: [],\n    defaultParams: [],\n    alternativesKey: 'format',\n    category: LokiVisualQueryOperationCategory.Formats,\n    orderRank: LokiOperationOrder.LineFormats,\n    renderer: pipelineRenderer,\n    addOperationHandler: addLokiOperation\n  }, {\n    id: LokiOperationId.Logfmt,\n    name: 'Logfmt',\n    params: [],\n    defaultParams: [],\n    alternativesKey: 'format',\n    category: LokiVisualQueryOperationCategory.Formats,\n    orderRank: LokiOperationOrder.LineFormats,\n    renderer: pipelineRenderer,\n    addOperationHandler: addLokiOperation,\n    explainHandler: () => `This will extract all keys and values from a [logfmt](https://grafana.com/docs/loki/latest/logql/log_queries/#logfmt) formatted log line as labels. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`\n  }, {\n    id: LokiOperationId.Regexp,\n    name: 'Regexp',\n    params: [{\n      name: 'String',\n      type: 'string',\n      hideName: true,\n      placeholder: '<re>',\n      description: 'The regexp expression that matches the structure of a log line.',\n      minWidth: 20\n    }],\n    defaultParams: [''],\n    alternativesKey: 'format',\n    category: LokiVisualQueryOperationCategory.Formats,\n    orderRank: LokiOperationOrder.LineFormats,\n    renderer: (model, def, innerExpr) => `${innerExpr} | regexp \\`${model.params[0]}\\``,\n    addOperationHandler: addLokiOperation,\n    explainHandler: () => `The [regexp parser](https://grafana.com/docs/loki/latest/logql/log_queries/#regular-expression) takes a single parameter | regexp \"<re>\" which is the regular expression using the Golang RE2 syntax. The regular expression must contain a least one named sub-match (e.g (?P<name>re)), each sub-match will extract a different label. The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`\n  }, {\n    id: LokiOperationId.Pattern,\n    name: 'Pattern',\n    params: [{\n      name: 'String',\n      type: 'string',\n      hideName: true,\n      placeholder: '<pattern-expression>',\n      description: 'The expression that matches the structure of a log line.',\n      minWidth: 20\n    }],\n    defaultParams: [''],\n    alternativesKey: 'format',\n    category: LokiVisualQueryOperationCategory.Formats,\n    orderRank: LokiOperationOrder.LineFormats,\n    renderer: (model, def, innerExpr) => `${innerExpr} | pattern \\`${model.params[0]}\\``,\n    addOperationHandler: addLokiOperation,\n    explainHandler: () => `The [pattern parser](https://grafana.com/docs/loki/latest/logql/log_queries/#pattern) allows the explicit extraction of fields from log lines by defining a pattern expression (| pattern \\`<pattern-expression>\\`). The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`\n  }, {\n    id: LokiOperationId.Unpack,\n    name: 'Unpack',\n    params: [],\n    defaultParams: [],\n    alternativesKey: 'format',\n    category: LokiVisualQueryOperationCategory.Formats,\n    orderRank: LokiOperationOrder.LineFormats,\n    renderer: pipelineRenderer,\n    addOperationHandler: addLokiOperation,\n    explainHandler: () => `This will extract all keys and values from a JSON log line, [unpacking](https://grafana.com/docs/loki/latest/logql/log_queries/#unpack) all embedded labels in the pack stage. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`\n  }, {\n    id: LokiOperationId.LineFormat,\n    name: 'Line format',\n    params: [{\n      name: 'String',\n      type: 'string',\n      hideName: true,\n      placeholder: '{{.status_code}}',\n      description: 'A line template that can refer to stream labels and extracted labels.',\n      minWidth: 20\n    }],\n    defaultParams: [''],\n    alternativesKey: 'format',\n    category: LokiVisualQueryOperationCategory.Formats,\n    orderRank: LokiOperationOrder.LineFormats,\n    renderer: (model, def, innerExpr) => `${innerExpr} | line_format \\`${model.params[0]}\\``,\n    addOperationHandler: addLokiOperation,\n    explainHandler: () => `This will replace log line using a specified template. The template can refer to stream labels and extracted labels.\n\n        Example: \\`{{.status_code}} - {{.message}}\\`\n\n        [Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#line-format-expression) for more.\n        `\n  }, {\n    id: LokiOperationId.LabelFormat,\n    name: 'Label format',\n    params: [{\n      name: 'Label',\n      type: 'string'\n    }, {\n      name: 'Rename',\n      type: 'string'\n    }],\n    defaultParams: ['', ''],\n    alternativesKey: 'format',\n    category: LokiVisualQueryOperationCategory.Formats,\n    orderRank: LokiOperationOrder.LineFormats,\n    renderer: (model, def, innerExpr) => `${innerExpr} | label_format ${model.params[1]}=\\`${model.params[0]}\\``,\n    addOperationHandler: addLokiOperation,\n    explainHandler: () => `This will change name of label to desired new label. In the example below, label \"error_level\" will be renamed to \"level\".\n\n        Example: error_level=\\`level\\`\n\n        [Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#labels-format-expression) for more.\n        `\n  }, {\n    id: LokiOperationId.LineContains,\n    name: 'Line contains',\n    params: [{\n      name: 'String',\n      type: 'string',\n      hideName: true,\n      placeholder: 'Text to find',\n      description: 'Find log lines that contains this text',\n      minWidth: 20,\n      runQueryOnEnter: true\n    }],\n    defaultParams: [''],\n    alternativesKey: 'line filter',\n    category: LokiVisualQueryOperationCategory.LineFilters,\n    orderRank: LokiOperationOrder.LineFilters,\n    renderer: getLineFilterRenderer('|='),\n    addOperationHandler: addLokiOperation,\n    explainHandler: op => `Return log lines that contain string \\`${op.params[0]}\\`.`\n  }, {\n    id: LokiOperationId.LineContainsNot,\n    name: 'Line does not contain',\n    params: [{\n      name: 'String',\n      type: 'string',\n      hideName: true,\n      placeholder: 'Text to exclude',\n      description: 'Find log lines that does not contain this text',\n      minWidth: 26,\n      runQueryOnEnter: true\n    }],\n    defaultParams: [''],\n    alternativesKey: 'line filter',\n    category: LokiVisualQueryOperationCategory.LineFilters,\n    orderRank: LokiOperationOrder.LineFilters,\n    renderer: getLineFilterRenderer('!='),\n    addOperationHandler: addLokiOperation,\n    explainHandler: op => `Return log lines that does not contain string \\`${op.params[0]}\\`.`\n  }, {\n    id: LokiOperationId.LineMatchesRegex,\n    name: 'Line contains regex match',\n    params: [{\n      name: 'Regex',\n      type: 'string',\n      hideName: true,\n      placeholder: 'Pattern to match',\n      description: 'Find log lines that match this regex pattern',\n      minWidth: 30,\n      runQueryOnEnter: true\n    }],\n    defaultParams: [''],\n    alternativesKey: 'line filter',\n    category: LokiVisualQueryOperationCategory.LineFilters,\n    orderRank: LokiOperationOrder.LineFilters,\n    renderer: getLineFilterRenderer('|~'),\n    addOperationHandler: addLokiOperation,\n    explainHandler: op => `Return log lines that match regex \\`${op.params[0]}\\`.`\n  }, {\n    id: LokiOperationId.LineMatchesRegexNot,\n    name: 'Line does not match regex',\n    params: [{\n      name: 'Regex',\n      type: 'string',\n      hideName: true,\n      placeholder: 'Pattern to exclude',\n      description: 'Find log lines that does not match this regex pattern',\n      minWidth: 30,\n      runQueryOnEnter: true\n    }],\n    defaultParams: [''],\n    alternativesKey: 'line filter',\n    category: LokiVisualQueryOperationCategory.LineFilters,\n    orderRank: LokiOperationOrder.LineFilters,\n    renderer: getLineFilterRenderer('!~'),\n    addOperationHandler: addLokiOperation,\n    explainHandler: op => `Return log lines that does not match regex \\`${op.params[0]}\\`.`\n  }, {\n    id: LokiOperationId.LabelFilter,\n    name: 'Label filter expression',\n    params: [{\n      name: 'Label',\n      type: 'string'\n    }, {\n      name: 'Operator',\n      type: 'string',\n      options: ['=', '!=', '>', '<', '>=', '<=']\n    }, {\n      name: 'Value',\n      type: 'string'\n    }],\n    defaultParams: ['', '=', ''],\n    category: LokiVisualQueryOperationCategory.LabelFilters,\n    orderRank: LokiOperationOrder.LabelFilters,\n    renderer: labelFilterRenderer,\n    addOperationHandler: addLokiOperation,\n    explainHandler: () => `Label expression filter allows filtering using original and extracted labels.`\n  }, {\n    id: LokiOperationId.LabelFilterNoErrors,\n    name: 'No pipeline errors',\n    params: [],\n    defaultParams: [],\n    category: LokiVisualQueryOperationCategory.LabelFilters,\n    orderRank: LokiOperationOrder.NoErrors,\n    renderer: (model, def, innerExpr) => `${innerExpr} | __error__=\\`\\``,\n    addOperationHandler: addLokiOperation,\n    explainHandler: () => `Filter out all formatting and parsing errors.`\n  }, {\n    id: LokiOperationId.Unwrap,\n    name: 'Unwrap',\n    params: [{\n      name: 'Identifier',\n      type: 'string',\n      hideName: true,\n      minWidth: 16,\n      placeholder: 'Label key'\n    }],\n    defaultParams: [''],\n    category: LokiVisualQueryOperationCategory.Formats,\n    orderRank: LokiOperationOrder.Unwrap,\n    renderer: (op, def, innerExpr) => `${innerExpr} | unwrap ${op.params[0]}`,\n    addOperationHandler: addLokiOperation,\n    explainHandler: op => {\n      let label = String(op.params[0]).length > 0 ? op.params[0] : '<label>';\n      return `Use the extracted label \\`${label}\\` as sample values instead of log lines for the subsequent range aggregation.`;\n    }\n  }, ...binaryScalarOperations, {\n    id: LokiOperationId.NestedQuery,\n    name: 'Binary operation with query',\n    params: [],\n    defaultParams: [],\n    category: LokiVisualQueryOperationCategory.BinaryOps,\n    renderer: (model, def, innerExpr) => innerExpr,\n    addOperationHandler: addNestedQueryHandler\n  }];\n  return list;\n}\n\nfunction createRangeOperation(name) {\n  const params = [getRangeVectorParamDef()];\n  const defaultParams = ['$__interval'];\n  let renderer = operationWithRangeVectorRenderer;\n\n  if (name === LokiOperationId.QuantileOverTime) {\n    defaultParams.push('0.95');\n    params.push({\n      name: 'Quantile',\n      type: 'number'\n    });\n    renderer = operationWithRangeVectorRendererAndParam;\n  }\n\n  return {\n    id: name,\n    name: getPromAndLokiOperationDisplayName(name),\n    params,\n    defaultParams,\n    alternativesKey: 'range function',\n    category: LokiVisualQueryOperationCategory.RangeFunctions,\n    orderRank: LokiOperationOrder.RangeVectorFunction,\n    renderer,\n    addOperationHandler: addLokiOperation,\n    explainHandler: (op, def) => {\n      var _FUNCTIONS$find$docum, _FUNCTIONS$find;\n\n      let opDocs = (_FUNCTIONS$find$docum = (_FUNCTIONS$find = FUNCTIONS.find(x => x.insertText === op.id)) === null || _FUNCTIONS$find === void 0 ? void 0 : _FUNCTIONS$find.documentation) !== null && _FUNCTIONS$find$docum !== void 0 ? _FUNCTIONS$find$docum : '';\n\n      if (op.params[0] === '$__interval') {\n        return `${opDocs} \\`$__interval\\` is variable that will be replaced with a calculated interval based on **Max data points**,  **Min interval** and query time range. You find these options you find under **Query options** at the right of the data source select dropdown.`;\n      } else {\n        return `${opDocs} The [range vector](https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation) is set to \\`${op.params[0]}\\`.`;\n      }\n    }\n  };\n}\n\nfunction getRangeVectorParamDef() {\n  return {\n    name: 'Range',\n    type: 'string',\n    options: ['$__interval', '$__range', '1m', '5m', '10m', '1h', '24h']\n  };\n}\n\nfunction operationWithRangeVectorRenderer(model, def, innerExpr) {\n  var _, _model$params;\n\n  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '$__interval';\n  return `${def.id}(${innerExpr} [${rangeVector}])`;\n}\n\nfunction operationWithRangeVectorRendererAndParam(model, def, innerExpr) {\n  var _model$params2, _params$;\n\n  const params = (_model$params2 = model.params) !== null && _model$params2 !== void 0 ? _model$params2 : [];\n  const rangeVector = (_params$ = params[0]) !== null && _params$ !== void 0 ? _params$ : '$__interval';\n  const param = params[1];\n  return `${def.id}(${param}, ${innerExpr} [${rangeVector}])`;\n}\n\nfunction getLineFilterRenderer(operation) {\n  return function lineFilterRenderer(model, def, innerExpr) {\n    return `${innerExpr} ${operation} \\`${model.params[0]}\\``;\n  };\n}\n\nfunction labelFilterRenderer(model, def, innerExpr) {\n  if (model.params[0] === '') {\n    return innerExpr;\n  }\n\n  if (model.params[1] === '<' || model.params[1] === '>') {\n    return `${innerExpr} | ${model.params[0]} ${model.params[1]} ${model.params[2]}`;\n  }\n\n  return `${innerExpr} | ${model.params[0]}${model.params[1]}\\`${model.params[2]}\\``;\n}\n\nfunction pipelineRenderer(model, def, innerExpr) {\n  return `${innerExpr} | ${model.id}`;\n}\n\nfunction isRangeVectorFunction(def) {\n  return def.category === LokiVisualQueryOperationCategory.RangeFunctions;\n}\n\nfunction getIndexOfOrLast(operations, queryModeller, condition) {\n  const index = operations.findIndex(x => {\n    const opDef = queryModeller.getOperationDef(x.id);\n\n    if (!opDef) {\n      return false;\n    }\n\n    return condition(opDef);\n  });\n  return index === -1 ? operations.length : index;\n}\n\nexport function addLokiOperation(def, query, modeller) {\n  const newOperation = {\n    id: def.id,\n    params: def.defaultParams\n  };\n  const operations = [...query.operations];\n  const existingRangeVectorFunction = operations.find(x => {\n    const opDef = modeller.getOperationDef(x.id);\n\n    if (!opDef) {\n      return false;\n    }\n\n    return isRangeVectorFunction(opDef);\n  });\n\n  switch (def.category) {\n    case LokiVisualQueryOperationCategory.Aggregations:\n    case LokiVisualQueryOperationCategory.Functions:\n      // If we are adding a function but we have not range vector function yet add one\n      if (!existingRangeVectorFunction) {\n        const placeToInsert = getIndexOfOrLast(operations, modeller, def => def.category === LokiVisualQueryOperationCategory.Functions);\n        operations.splice(placeToInsert, 0, {\n          id: LokiOperationId.Rate,\n          params: ['$__interval']\n        });\n      }\n\n      operations.push(newOperation);\n      break;\n\n    case LokiVisualQueryOperationCategory.RangeFunctions:\n      // If adding a range function and range function is already added replace it\n      if (existingRangeVectorFunction) {\n        const index = operations.indexOf(existingRangeVectorFunction);\n        operations[index] = newOperation;\n        break;\n      }\n\n    // Add range functions after any formats, line filters and label filters\n\n    default:\n      const placeToInsert = getIndexOfOrLast(operations, modeller, x => {\n        var _def$orderRank, _x$orderRank;\n\n        return ((_def$orderRank = def.orderRank) !== null && _def$orderRank !== void 0 ? _def$orderRank : 100) < ((_x$orderRank = x.orderRank) !== null && _x$orderRank !== void 0 ? _x$orderRank : 100);\n      });\n      operations.splice(placeToInsert, 0, newOperation);\n      break;\n  }\n\n  return Object.assign({}, query, {\n    operations\n  });\n}\n\nfunction addNestedQueryHandler(def, query) {\n  var _query$binaryQueries;\n\n  return Object.assign({}, query, {\n    binaryQueries: [...((_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : []), {\n      operator: '/',\n      query\n    }]\n  });\n}","map":{"version":3,"names":["createAggregationOperation","createAggregationOperationWithParam","getPromAndLokiOperationDisplayName","FUNCTIONS","binaryScalarOperations","LokiOperationId","LokiOperationOrder","LokiVisualQueryOperationCategory","getOperationDefinitions","aggregations","Sum","Min","Max","Avg","Stddev","Stdvar","Count","flatMap","opId","addOperationHandler","addLokiOperation","orderRank","Last","aggregationsWithParam","TopK","BottomK","params","name","type","defaultParams","list","createRangeOperation","Rate","CountOverTime","SumOverTime","BytesRate","BytesOverTime","AbsentOverTime","AvgOverTime","MaxOverTime","MinOverTime","FirstOverTime","LastOverTime","StdvarOverTime","StddevOverTime","QuantileOverTime","id","Json","alternativesKey","category","Formats","LineFormats","renderer","pipelineRenderer","Logfmt","explainHandler","Regexp","hideName","placeholder","description","minWidth","model","def","innerExpr","Pattern","Unpack","LineFormat","LabelFormat","LineContains","runQueryOnEnter","LineFilters","getLineFilterRenderer","op","LineContainsNot","LineMatchesRegex","LineMatchesRegexNot","LabelFilter","options","LabelFilters","labelFilterRenderer","LabelFilterNoErrors","NoErrors","Unwrap","label","String","length","NestedQuery","BinaryOps","addNestedQueryHandler","getRangeVectorParamDef","operationWithRangeVectorRenderer","push","operationWithRangeVectorRendererAndParam","RangeFunctions","RangeVectorFunction","opDocs","find","x","insertText","documentation","rangeVector","param","operation","lineFilterRenderer","isRangeVectorFunction","getIndexOfOrLast","operations","queryModeller","condition","index","findIndex","opDef","getOperationDef","query","modeller","newOperation","existingRangeVectorFunction","Aggregations","Functions","placeToInsert","splice","indexOf","binaryQueries","operator"],"sources":["/home/soula/grafana/public/app/plugins/datasource/loki/querybuilder/operations.ts"],"sourcesContent":["import {\n  createAggregationOperation,\n  createAggregationOperationWithParam,\n  getPromAndLokiOperationDisplayName,\n} from '../../prometheus/querybuilder/shared/operationUtils';\nimport {\n  QueryBuilderOperation,\n  QueryBuilderOperationDef,\n  QueryBuilderOperationParamDef,\n  VisualQueryModeller,\n} from '../../prometheus/querybuilder/shared/types';\nimport { FUNCTIONS } from '../syntax';\n\nimport { binaryScalarOperations } from './binaryScalarOperations';\nimport { LokiOperationId, LokiOperationOrder, LokiVisualQuery, LokiVisualQueryOperationCategory } from './types';\n\nexport function getOperationDefinitions(): QueryBuilderOperationDef[] {\n  const aggregations = [\n    LokiOperationId.Sum,\n    LokiOperationId.Min,\n    LokiOperationId.Max,\n    LokiOperationId.Avg,\n    LokiOperationId.Stddev,\n    LokiOperationId.Stdvar,\n    LokiOperationId.Count,\n  ].flatMap((opId) =>\n    createAggregationOperation(opId, {\n      addOperationHandler: addLokiOperation,\n      orderRank: LokiOperationOrder.Last,\n    })\n  );\n\n  const aggregationsWithParam = [LokiOperationId.TopK, LokiOperationId.BottomK].flatMap((opId) => {\n    return createAggregationOperationWithParam(\n      opId,\n      {\n        params: [{ name: 'K-value', type: 'number' }],\n        defaultParams: [5],\n      },\n      {\n        addOperationHandler: addLokiOperation,\n        orderRank: LokiOperationOrder.Last,\n      }\n    );\n  });\n\n  const list: QueryBuilderOperationDef[] = [\n    createRangeOperation(LokiOperationId.Rate),\n    createRangeOperation(LokiOperationId.CountOverTime),\n    createRangeOperation(LokiOperationId.SumOverTime),\n    createRangeOperation(LokiOperationId.BytesRate),\n    createRangeOperation(LokiOperationId.BytesOverTime),\n    createRangeOperation(LokiOperationId.AbsentOverTime),\n    createRangeOperation(LokiOperationId.AvgOverTime),\n    createRangeOperation(LokiOperationId.MaxOverTime),\n    createRangeOperation(LokiOperationId.MinOverTime),\n    createRangeOperation(LokiOperationId.FirstOverTime),\n    createRangeOperation(LokiOperationId.LastOverTime),\n    createRangeOperation(LokiOperationId.StdvarOverTime),\n    createRangeOperation(LokiOperationId.StddevOverTime),\n    createRangeOperation(LokiOperationId.QuantileOverTime),\n    ...aggregations,\n    ...aggregationsWithParam,\n    {\n      id: LokiOperationId.Json,\n      name: 'Json',\n      params: [],\n      defaultParams: [],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: pipelineRenderer,\n      addOperationHandler: addLokiOperation,\n    },\n    {\n      id: LokiOperationId.Logfmt,\n      name: 'Logfmt',\n      params: [],\n      defaultParams: [],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: pipelineRenderer,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `This will extract all keys and values from a [logfmt](https://grafana.com/docs/loki/latest/logql/log_queries/#logfmt) formatted log line as labels. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`,\n    },\n    {\n      id: LokiOperationId.Regexp,\n      name: 'Regexp',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: '<re>',\n          description: 'The regexp expression that matches the structure of a log line.',\n          minWidth: 20,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: (model, def, innerExpr) => `${innerExpr} | regexp \\`${model.params[0]}\\``,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `The [regexp parser](https://grafana.com/docs/loki/latest/logql/log_queries/#regular-expression) takes a single parameter | regexp \"<re>\" which is the regular expression using the Golang RE2 syntax. The regular expression must contain a least one named sub-match (e.g (?P<name>re)), each sub-match will extract a different label. The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`,\n    },\n    {\n      id: LokiOperationId.Pattern,\n      name: 'Pattern',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: '<pattern-expression>',\n          description: 'The expression that matches the structure of a log line.',\n          minWidth: 20,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: (model, def, innerExpr) => `${innerExpr} | pattern \\`${model.params[0]}\\``,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `The [pattern parser](https://grafana.com/docs/loki/latest/logql/log_queries/#pattern) allows the explicit extraction of fields from log lines by defining a pattern expression (| pattern \\`<pattern-expression>\\`). The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`,\n    },\n    {\n      id: LokiOperationId.Unpack,\n      name: 'Unpack',\n      params: [],\n      defaultParams: [],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: pipelineRenderer,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `This will extract all keys and values from a JSON log line, [unpacking](https://grafana.com/docs/loki/latest/logql/log_queries/#unpack) all embedded labels in the pack stage. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`,\n    },\n    {\n      id: LokiOperationId.LineFormat,\n      name: 'Line format',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: '{{.status_code}}',\n          description: 'A line template that can refer to stream labels and extracted labels.',\n          minWidth: 20,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: (model, def, innerExpr) => `${innerExpr} | line_format \\`${model.params[0]}\\``,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `This will replace log line using a specified template. The template can refer to stream labels and extracted labels.\n\n        Example: \\`{{.status_code}} - {{.message}}\\`\n\n        [Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#line-format-expression) for more.\n        `,\n    },\n    {\n      id: LokiOperationId.LabelFormat,\n      name: 'Label format',\n      params: [\n        { name: 'Label', type: 'string' },\n        { name: 'Rename', type: 'string' },\n      ],\n      defaultParams: ['', ''],\n      alternativesKey: 'format',\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.LineFormats,\n      renderer: (model, def, innerExpr) => `${innerExpr} | label_format ${model.params[1]}=\\`${model.params[0]}\\``,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () =>\n        `This will change name of label to desired new label. In the example below, label \"error_level\" will be renamed to \"level\".\n\n        Example: error_level=\\`level\\`\n\n        [Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#labels-format-expression) for more.\n        `,\n    },\n\n    {\n      id: LokiOperationId.LineContains,\n      name: 'Line contains',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: 'Text to find',\n          description: 'Find log lines that contains this text',\n          minWidth: 20,\n          runQueryOnEnter: true,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'line filter',\n      category: LokiVisualQueryOperationCategory.LineFilters,\n      orderRank: LokiOperationOrder.LineFilters,\n      renderer: getLineFilterRenderer('|='),\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines that contain string \\`${op.params[0]}\\`.`,\n    },\n    {\n      id: LokiOperationId.LineContainsNot,\n      name: 'Line does not contain',\n      params: [\n        {\n          name: 'String',\n          type: 'string',\n          hideName: true,\n          placeholder: 'Text to exclude',\n          description: 'Find log lines that does not contain this text',\n          minWidth: 26,\n          runQueryOnEnter: true,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'line filter',\n      category: LokiVisualQueryOperationCategory.LineFilters,\n      orderRank: LokiOperationOrder.LineFilters,\n      renderer: getLineFilterRenderer('!='),\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines that does not contain string \\`${op.params[0]}\\`.`,\n    },\n    {\n      id: LokiOperationId.LineMatchesRegex,\n      name: 'Line contains regex match',\n      params: [\n        {\n          name: 'Regex',\n          type: 'string',\n          hideName: true,\n          placeholder: 'Pattern to match',\n          description: 'Find log lines that match this regex pattern',\n          minWidth: 30,\n          runQueryOnEnter: true,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'line filter',\n      category: LokiVisualQueryOperationCategory.LineFilters,\n      orderRank: LokiOperationOrder.LineFilters,\n      renderer: getLineFilterRenderer('|~'),\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines that match regex \\`${op.params[0]}\\`.`,\n    },\n    {\n      id: LokiOperationId.LineMatchesRegexNot,\n      name: 'Line does not match regex',\n      params: [\n        {\n          name: 'Regex',\n          type: 'string',\n          hideName: true,\n          placeholder: 'Pattern to exclude',\n          description: 'Find log lines that does not match this regex pattern',\n          minWidth: 30,\n          runQueryOnEnter: true,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'line filter',\n      category: LokiVisualQueryOperationCategory.LineFilters,\n      orderRank: LokiOperationOrder.LineFilters,\n      renderer: getLineFilterRenderer('!~'),\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => `Return log lines that does not match regex \\`${op.params[0]}\\`.`,\n    },\n    {\n      id: LokiOperationId.LabelFilter,\n      name: 'Label filter expression',\n      params: [\n        { name: 'Label', type: 'string' },\n        { name: 'Operator', type: 'string', options: ['=', '!=', '>', '<', '>=', '<='] },\n        { name: 'Value', type: 'string' },\n      ],\n      defaultParams: ['', '=', ''],\n      category: LokiVisualQueryOperationCategory.LabelFilters,\n      orderRank: LokiOperationOrder.LabelFilters,\n      renderer: labelFilterRenderer,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () => `Label expression filter allows filtering using original and extracted labels.`,\n    },\n    {\n      id: LokiOperationId.LabelFilterNoErrors,\n      name: 'No pipeline errors',\n      params: [],\n      defaultParams: [],\n      category: LokiVisualQueryOperationCategory.LabelFilters,\n      orderRank: LokiOperationOrder.NoErrors,\n      renderer: (model, def, innerExpr) => `${innerExpr} | __error__=\\`\\``,\n      addOperationHandler: addLokiOperation,\n      explainHandler: () => `Filter out all formatting and parsing errors.`,\n    },\n    {\n      id: LokiOperationId.Unwrap,\n      name: 'Unwrap',\n      params: [{ name: 'Identifier', type: 'string', hideName: true, minWidth: 16, placeholder: 'Label key' }],\n      defaultParams: [''],\n      category: LokiVisualQueryOperationCategory.Formats,\n      orderRank: LokiOperationOrder.Unwrap,\n      renderer: (op, def, innerExpr) => `${innerExpr} | unwrap ${op.params[0]}`,\n      addOperationHandler: addLokiOperation,\n      explainHandler: (op) => {\n        let label = String(op.params[0]).length > 0 ? op.params[0] : '<label>';\n        return `Use the extracted label \\`${label}\\` as sample values instead of log lines for the subsequent range aggregation.`;\n      },\n    },\n    ...binaryScalarOperations,\n    {\n      id: LokiOperationId.NestedQuery,\n      name: 'Binary operation with query',\n      params: [],\n      defaultParams: [],\n      category: LokiVisualQueryOperationCategory.BinaryOps,\n      renderer: (model, def, innerExpr) => innerExpr,\n      addOperationHandler: addNestedQueryHandler,\n    },\n  ];\n\n  return list;\n}\n\nfunction createRangeOperation(name: string): QueryBuilderOperationDef {\n  const params = [getRangeVectorParamDef()];\n  const defaultParams = ['$__interval'];\n  let renderer = operationWithRangeVectorRenderer;\n\n  if (name === LokiOperationId.QuantileOverTime) {\n    defaultParams.push('0.95');\n    params.push({\n      name: 'Quantile',\n      type: 'number',\n    });\n    renderer = operationWithRangeVectorRendererAndParam;\n  }\n\n  return {\n    id: name,\n    name: getPromAndLokiOperationDisplayName(name),\n    params,\n    defaultParams,\n    alternativesKey: 'range function',\n    category: LokiVisualQueryOperationCategory.RangeFunctions,\n    orderRank: LokiOperationOrder.RangeVectorFunction,\n    renderer,\n    addOperationHandler: addLokiOperation,\n    explainHandler: (op, def) => {\n      let opDocs = FUNCTIONS.find((x) => x.insertText === op.id)?.documentation ?? '';\n\n      if (op.params[0] === '$__interval') {\n        return `${opDocs} \\`$__interval\\` is variable that will be replaced with a calculated interval based on **Max data points**,  **Min interval** and query time range. You find these options you find under **Query options** at the right of the data source select dropdown.`;\n      } else {\n        return `${opDocs} The [range vector](https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation) is set to \\`${op.params[0]}\\`.`;\n      }\n    },\n  };\n}\n\nfunction getRangeVectorParamDef(): QueryBuilderOperationParamDef {\n  return {\n    name: 'Range',\n    type: 'string',\n    options: ['$__interval', '$__range', '1m', '5m', '10m', '1h', '24h'],\n  };\n}\n\nfunction operationWithRangeVectorRenderer(\n  model: QueryBuilderOperation,\n  def: QueryBuilderOperationDef,\n  innerExpr: string\n) {\n  let rangeVector = (model.params ?? [])[0] ?? '$__interval';\n  return `${def.id}(${innerExpr} [${rangeVector}])`;\n}\n\nfunction operationWithRangeVectorRendererAndParam(\n  model: QueryBuilderOperation,\n  def: QueryBuilderOperationDef,\n  innerExpr: string\n) {\n  const params = model.params ?? [];\n  const rangeVector = params[0] ?? '$__interval';\n  const param = params[1];\n  return `${def.id}(${param}, ${innerExpr} [${rangeVector}])`;\n}\n\nfunction getLineFilterRenderer(operation: string) {\n  return function lineFilterRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n    return `${innerExpr} ${operation} \\`${model.params[0]}\\``;\n  };\n}\n\nfunction labelFilterRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n  if (model.params[0] === '') {\n    return innerExpr;\n  }\n\n  if (model.params[1] === '<' || model.params[1] === '>') {\n    return `${innerExpr} | ${model.params[0]} ${model.params[1]} ${model.params[2]}`;\n  }\n\n  return `${innerExpr} | ${model.params[0]}${model.params[1]}\\`${model.params[2]}\\``;\n}\n\nfunction pipelineRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n  return `${innerExpr} | ${model.id}`;\n}\n\nfunction isRangeVectorFunction(def: QueryBuilderOperationDef) {\n  return def.category === LokiVisualQueryOperationCategory.RangeFunctions;\n}\n\nfunction getIndexOfOrLast(\n  operations: QueryBuilderOperation[],\n  queryModeller: VisualQueryModeller,\n  condition: (def: QueryBuilderOperationDef) => boolean\n) {\n  const index = operations.findIndex((x) => {\n    const opDef = queryModeller.getOperationDef(x.id);\n    if (!opDef) {\n      return false;\n    }\n    return condition(opDef);\n  });\n\n  return index === -1 ? operations.length : index;\n}\n\nexport function addLokiOperation(\n  def: QueryBuilderOperationDef,\n  query: LokiVisualQuery,\n  modeller: VisualQueryModeller\n): LokiVisualQuery {\n  const newOperation: QueryBuilderOperation = {\n    id: def.id,\n    params: def.defaultParams,\n  };\n\n  const operations = [...query.operations];\n\n  const existingRangeVectorFunction = operations.find((x) => {\n    const opDef = modeller.getOperationDef(x.id);\n    if (!opDef) {\n      return false;\n    }\n    return isRangeVectorFunction(opDef);\n  });\n\n  switch (def.category) {\n    case LokiVisualQueryOperationCategory.Aggregations:\n    case LokiVisualQueryOperationCategory.Functions:\n      // If we are adding a function but we have not range vector function yet add one\n      if (!existingRangeVectorFunction) {\n        const placeToInsert = getIndexOfOrLast(\n          operations,\n          modeller,\n          (def) => def.category === LokiVisualQueryOperationCategory.Functions\n        );\n        operations.splice(placeToInsert, 0, { id: LokiOperationId.Rate, params: ['$__interval'] });\n      }\n      operations.push(newOperation);\n      break;\n    case LokiVisualQueryOperationCategory.RangeFunctions:\n      // If adding a range function and range function is already added replace it\n      if (existingRangeVectorFunction) {\n        const index = operations.indexOf(existingRangeVectorFunction);\n        operations[index] = newOperation;\n        break;\n      }\n\n    // Add range functions after any formats, line filters and label filters\n    default:\n      const placeToInsert = getIndexOfOrLast(\n        operations,\n        modeller,\n        (x) => (def.orderRank ?? 100) < (x.orderRank ?? 100)\n      );\n      operations.splice(placeToInsert, 0, newOperation);\n      break;\n  }\n\n  return {\n    ...query,\n    operations,\n  };\n}\n\nfunction addNestedQueryHandler(def: QueryBuilderOperationDef, query: LokiVisualQuery): LokiVisualQuery {\n  return {\n    ...query,\n    binaryQueries: [\n      ...(query.binaryQueries ?? []),\n      {\n        operator: '/',\n        query,\n      },\n    ],\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}