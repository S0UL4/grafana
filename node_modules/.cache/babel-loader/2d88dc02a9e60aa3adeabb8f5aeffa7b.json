{"ast":null,"code":"import { ArrayVector, DashboardCursorSync, DataHoverEvent, DataHoverClearEvent, FALLBACK_COLOR, FieldColorModeId, FieldType, formattedValueToString, getFieldDisplayName, getValueFormat, getActiveThreshold, getFieldConfigWithMinMax, ThresholdsMode } from '@grafana/data';\nimport { AxisPlacement, ScaleDirection, ScaleOrientation } from '@grafana/schema';\nimport { FIXED_UNIT, SeriesVisibilityChangeMode, UPlotConfigBuilder } from '@grafana/ui';\nimport { applyNullInsertThreshold } from '@grafana/ui/src/components/GraphNG/nullInsertThreshold';\nimport { nullToValue } from '@grafana/ui/src/components/GraphNG/nullToValue';\nimport { preparePlotData2, getStackingGroups } from '../../../../../packages/grafana-ui/src/components/uPlot/utils';\nimport { getConfig } from './timeline';\nconst defaultConfig = {\n  lineWidth: 0,\n  fillOpacity: 80\n};\nexport function mapMouseEventToMode(event) {\n  if (event.ctrlKey || event.metaKey || event.shiftKey) {\n    return SeriesVisibilityChangeMode.AppendToSelection;\n  }\n\n  return SeriesVisibilityChangeMode.ToggleSelection;\n}\nexport const preparePlotConfigBuilder = ({\n  frame,\n  theme,\n  timeZone,\n  getTimeRange,\n  mode,\n  eventBus,\n  sync,\n  rowHeight,\n  colWidth,\n  showValue,\n  alignValue,\n  mergeValues,\n  getValueColor\n}) => {\n  const builder = new UPlotConfigBuilder(timeZone);\n  const xScaleUnit = 'time';\n  const xScaleKey = 'x';\n\n  const isDiscrete = field => {\n    var _field$config, _field$config$color;\n\n    const mode = (_field$config = field.config) === null || _field$config === void 0 ? void 0 : (_field$config$color = _field$config.color) === null || _field$config$color === void 0 ? void 0 : _field$config$color.mode;\n    return !(mode && field.display && mode.startsWith('continuous-'));\n  };\n\n  const getValueColorFn = (seriesIdx, value) => {\n    var _field$state, _field$state$origin, _field$state2, _field$state2$origin;\n\n    const field = frame.fields[seriesIdx];\n\n    if (((_field$state = field.state) === null || _field$state === void 0 ? void 0 : (_field$state$origin = _field$state.origin) === null || _field$state$origin === void 0 ? void 0 : _field$state$origin.fieldIndex) !== undefined && ((_field$state2 = field.state) === null || _field$state2 === void 0 ? void 0 : (_field$state2$origin = _field$state2.origin) === null || _field$state2$origin === void 0 ? void 0 : _field$state2$origin.frameIndex) !== undefined && getValueColor) {\n      var _field$state3, _field$state3$origin, _field$state4, _field$state4$origin;\n\n      return getValueColor((_field$state3 = field.state) === null || _field$state3 === void 0 ? void 0 : (_field$state3$origin = _field$state3.origin) === null || _field$state3$origin === void 0 ? void 0 : _field$state3$origin.frameIndex, (_field$state4 = field.state) === null || _field$state4 === void 0 ? void 0 : (_field$state4$origin = _field$state4.origin) === null || _field$state4$origin === void 0 ? void 0 : _field$state4$origin.fieldIndex, value);\n    }\n\n    return FALLBACK_COLOR;\n  };\n\n  const opts = {\n    // should expose in panel config\n    mode: mode,\n    numSeries: frame.fields.length - 1,\n    isDiscrete: seriesIdx => isDiscrete(frame.fields[seriesIdx]),\n    mergeValues,\n    rowHeight: rowHeight,\n    colWidth: colWidth,\n    showValue: showValue,\n    alignValue,\n    theme,\n    label: seriesIdx => getFieldDisplayName(frame.fields[seriesIdx], frame),\n    getFieldConfig: seriesIdx => frame.fields[seriesIdx].config.custom,\n    getValueColor: getValueColorFn,\n    getTimeRange,\n    // hardcoded formatter for state values\n    formatValue: (seriesIdx, value) => formattedValueToString(frame.fields[seriesIdx].display(value)),\n    onHover: (seriesIndex, valueIndex) => {\n      hoveredSeriesIdx = seriesIndex;\n      hoveredDataIdx = valueIndex;\n      shouldChangeHover = true;\n    },\n    onLeave: () => {\n      hoveredSeriesIdx = null;\n      hoveredDataIdx = null;\n      shouldChangeHover = true;\n    }\n  };\n  let shouldChangeHover = false;\n  let hoveredSeriesIdx = null;\n  let hoveredDataIdx = null;\n  const coreConfig = getConfig(opts);\n  const payload = {\n    point: {\n      [xScaleUnit]: null,\n      [FIXED_UNIT]: null\n    },\n    data: frame\n  };\n  builder.addHook('init', coreConfig.init);\n  builder.addHook('drawClear', coreConfig.drawClear);\n  builder.addHook('setCursor', coreConfig.setCursor); // in TooltipPlugin, this gets invoked and the result is bound to a setCursor hook\n  // which fires after the above setCursor hook, so can take advantage of hoveringOver\n  // already set by the above onHover/onLeave callbacks that fire from coreConfig.setCursor\n\n  const interpolateTooltip = (updateActiveSeriesIdx, updateActiveDatapointIdx, updateTooltipPosition) => {\n    if (shouldChangeHover) {\n      if (hoveredSeriesIdx != null) {\n        updateActiveSeriesIdx(hoveredSeriesIdx);\n        updateActiveDatapointIdx(hoveredDataIdx);\n      }\n\n      shouldChangeHover = false;\n    }\n\n    updateTooltipPosition(hoveredSeriesIdx == null);\n  };\n\n  builder.setTooltipInterpolator(interpolateTooltip);\n  builder.setPrepData(frames => preparePlotData2(frames[0], getStackingGroups(frames[0])));\n  builder.setCursor(coreConfig.cursor);\n  builder.addScale({\n    scaleKey: xScaleKey,\n    isTime: true,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    range: coreConfig.xRange\n  });\n  builder.addScale({\n    scaleKey: FIXED_UNIT,\n    // y\n    isTime: false,\n    orientation: ScaleOrientation.Vertical,\n    direction: ScaleDirection.Up,\n    range: coreConfig.yRange\n  });\n  builder.addAxis({\n    scaleKey: xScaleKey,\n    isTime: true,\n    splits: coreConfig.xSplits,\n    placement: AxisPlacement.Bottom,\n    timeZone,\n    theme,\n    grid: {\n      show: true\n    }\n  });\n  builder.addAxis({\n    scaleKey: FIXED_UNIT,\n    // y\n    isTime: false,\n    placement: AxisPlacement.Left,\n    splits: coreConfig.ySplits,\n    values: coreConfig.yValues,\n    grid: {\n      show: false\n    },\n    ticks: {\n      show: false\n    },\n    gap: 16,\n    theme\n  });\n  let seriesIndex = 0;\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    var _customConfig$hideFro, _field$state5;\n\n    if (i === 0) {\n      continue;\n    }\n\n    const field = frame.fields[i];\n    const config = field.config;\n    const customConfig = Object.assign({}, defaultConfig, config.custom);\n    field.state.seriesIndex = seriesIndex++; // const scaleKey = config.unit || FIXED_UNIT;\n    // const colorMode = getFieldColorModeForField(field);\n\n    builder.addSeries({\n      scaleKey: FIXED_UNIT,\n      pathBuilder: coreConfig.drawPaths,\n      pointsBuilder: coreConfig.drawPoints,\n      //colorMode,\n      lineWidth: customConfig.lineWidth,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      show: !((_customConfig$hideFro = customConfig.hideFrom) !== null && _customConfig$hideFro !== void 0 && _customConfig$hideFro.viz),\n      thresholds: config.thresholds,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: (_field$state5 = field.state) === null || _field$state5 === void 0 ? void 0 : _field$state5.origin\n    });\n  }\n\n  if (sync && sync() !== DashboardCursorSync.Off) {\n    let cursor = {};\n    cursor.sync = {\n      key: '__global_',\n      filters: {\n        pub: (type, src, x, y, w, h, dataIdx) => {\n          if (sync && sync() === DashboardCursorSync.Off) {\n            return false;\n          }\n\n          payload.rowIndex = dataIdx;\n\n          if (x < 0 && y < 0) {\n            payload.point[xScaleUnit] = null;\n            payload.point[FIXED_UNIT] = null;\n            eventBus.publish(new DataHoverClearEvent());\n          } else {\n            payload.point[xScaleUnit] = src.posToVal(x, xScaleKey);\n            payload.point.panelRelY = y > 0 ? y / h : 1; // used for old graph panel to position tooltip\n\n            payload.down = undefined;\n            eventBus.publish(new DataHoverEvent(payload));\n          }\n\n          return true;\n        }\n      },\n      //TODO: remove any once https://github.com/leeoniya/uPlot/pull/611 got merged or the typing is fixed\n      scales: [xScaleKey, null]\n    };\n    builder.setSync();\n    builder.setCursor(cursor);\n  }\n\n  return builder;\n};\nexport function getNamesToFieldIndex(frame) {\n  const names = new Map();\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    names.set(getFieldDisplayName(frame.fields[i], frame), i);\n  }\n\n  return names;\n}\n/**\n * If any sequential duplicate values exist, this will return a new array\n * with the future values set to undefined.\n *\n * in:  1,        1,undefined,        1,2,        2,null,2,3\n * out: 1,undefined,undefined,undefined,2,undefined,null,2,3\n */\n\nexport function unsetSameFutureValues(values) {\n  let prevVal = values[0];\n  let clone = undefined;\n\n  for (let i = 1; i < values.length; i++) {\n    let value = values[i];\n\n    if (value === null) {\n      prevVal = null;\n    } else {\n      if (value === prevVal) {\n        if (!clone) {\n          clone = [...values];\n        }\n\n        clone[i] = undefined;\n      } else if (value != null) {\n        prevVal = value;\n      }\n    }\n  }\n\n  return clone;\n}\n\nfunction getSpanNulls(field) {\n  var _field$config$custom;\n\n  let spanNulls = (_field$config$custom = field.config.custom) === null || _field$config$custom === void 0 ? void 0 : _field$config$custom.spanNulls; // magic value for join() to leave nulls alone instead of expanding null ranges\n  // should be set to -1 when spanNulls = null|undefined|false|0, which is \"retain nulls, without expanding\"\n  // Infinity is not optimal here since it causes spanNulls to be more expensive than simply removing all nulls unconditionally\n\n  return !spanNulls ? -1 : spanNulls === true ? Infinity : spanNulls;\n}\n/**\n * Merge values by the threshold\n */\n\n\nexport function mergeThresholdValues(field, theme) {\n  const thresholds = field.config.thresholds;\n\n  if (field.type !== FieldType.number || !thresholds || !thresholds.steps.length) {\n    return undefined;\n  }\n\n  const items = getThresholdItems(field.config, theme);\n\n  if (items.length !== thresholds.steps.length) {\n    return undefined; // should not happen\n  }\n\n  const thresholdToText = new Map();\n  const textToColor = new Map();\n\n  for (let i = 0; i < items.length; i++) {\n    thresholdToText.set(thresholds.steps[i], items[i].label);\n    textToColor.set(items[i].label, items[i].color);\n  }\n\n  let input = field.values.toArray();\n  const vals = new Array(field.values.length);\n\n  if (thresholds.mode === ThresholdsMode.Percentage) {\n    const {\n      min,\n      max\n    } = getFieldConfigWithMinMax(field);\n    const delta = max - min;\n    input = input.map(v => {\n      if (v == null) {\n        return v;\n      }\n\n      return (v - min) / delta * 100;\n    });\n  }\n\n  for (let i = 0; i < vals.length; i++) {\n    const v = input[i];\n\n    if (v == null) {\n      vals[i] = v;\n    } else {\n      vals[i] = thresholdToText.get(getActiveThreshold(v, thresholds.steps));\n    }\n  }\n\n  return Object.assign({}, field, {\n    config: Object.assign({}, field.config, {\n      custom: Object.assign({}, field.config.custom, {\n        spanNulls: getSpanNulls(field)\n      })\n    }),\n    type: FieldType.string,\n    values: new ArrayVector(vals),\n    display: value => ({\n      text: value,\n      color: textToColor.get(value),\n      numeric: NaN\n    })\n  });\n} // This will return a set of frames with only graphable values included\n\nexport function prepareTimelineFields(series, mergeValues, timeRange, theme) {\n  var _field$config$color2;\n\n  if (!(series !== null && series !== void 0 && series.length)) {\n    return {\n      warn: 'No data in response'\n    };\n  }\n\n  let hasTimeseries = false;\n  const frames = [];\n\n  for (let frame of series) {\n    let isTimeseries = false;\n    let changed = false;\n    let nulledFrame = applyNullInsertThreshold({\n      frame,\n      refFieldPseudoMin: timeRange.from.valueOf(),\n      refFieldPseudoMax: timeRange.to.valueOf()\n    });\n\n    if (nulledFrame !== frame) {\n      changed = true;\n    }\n\n    const fields = [];\n\n    for (let field of nullToValue(nulledFrame).fields) {\n      switch (field.type) {\n        case FieldType.time:\n          isTimeseries = true;\n          hasTimeseries = true;\n          fields.push(field);\n          break;\n\n        case FieldType.number:\n          if (mergeValues && ((_field$config$color2 = field.config.color) === null || _field$config$color2 === void 0 ? void 0 : _field$config$color2.mode) === FieldColorModeId.Thresholds) {\n            const f = mergeThresholdValues(field, theme);\n\n            if (f) {\n              fields.push(f);\n              changed = true;\n              continue;\n            }\n          }\n\n        case FieldType.boolean:\n        case FieldType.string:\n          field = Object.assign({}, field, {\n            config: Object.assign({}, field.config, {\n              custom: Object.assign({}, field.config.custom, {\n                spanNulls: getSpanNulls(field)\n              })\n            })\n          });\n          fields.push(field);\n          break;\n\n        default:\n          changed = true;\n      }\n    }\n\n    if (isTimeseries && fields.length > 1) {\n      hasTimeseries = true;\n\n      if (changed) {\n        frames.push(Object.assign({}, frame, {\n          fields\n        }));\n      } else {\n        frames.push(frame);\n      }\n    }\n  }\n\n  if (!hasTimeseries) {\n    return {\n      warn: 'Data does not have a time field'\n    };\n  }\n\n  if (!frames.length) {\n    return {\n      warn: 'No graphable fields'\n    };\n  }\n\n  return {\n    frames\n  };\n}\nexport function getThresholdItems(fieldConfig, theme) {\n  var _fieldConfig$unit;\n\n  const items = [];\n  const thresholds = fieldConfig.thresholds;\n\n  if (!thresholds || !thresholds.steps.length) {\n    return items;\n  }\n\n  const steps = thresholds.steps;\n  const disp = getValueFormat(thresholds.mode === ThresholdsMode.Percentage ? 'percent' : (_fieldConfig$unit = fieldConfig.unit) !== null && _fieldConfig$unit !== void 0 ? _fieldConfig$unit : '');\n\n  const fmt = v => formattedValueToString(disp(v));\n\n  for (let i = 1; i <= steps.length; i++) {\n    const step = steps[i - 1];\n    items.push({\n      label: i === 1 ? `< ${fmt(step.value)}` : `${fmt(step.value)}+`,\n      color: theme.visualization.getColorByName(step.color),\n      yAxis: 1\n    });\n  }\n\n  return items;\n}\nexport function prepareTimelineLegendItems(frames, options, theme) {\n  if (!frames || options.displayMode === 'hidden') {\n    return undefined;\n  }\n\n  return getFieldLegendItem(allNonTimeFields(frames), theme);\n}\nexport function getFieldLegendItem(fields, theme) {\n  var _fieldConfig$color$mo, _fieldConfig$color;\n\n  if (!fields.length) {\n    return undefined;\n  }\n\n  const items = [];\n  const fieldConfig = fields[0].config;\n  const colorMode = (_fieldConfig$color$mo = (_fieldConfig$color = fieldConfig.color) === null || _fieldConfig$color === void 0 ? void 0 : _fieldConfig$color.mode) !== null && _fieldConfig$color$mo !== void 0 ? _fieldConfig$color$mo : FieldColorModeId.Fixed;\n  const thresholds = fieldConfig.thresholds; // If thresholds are enabled show each step in the legend\n\n  if (colorMode === FieldColorModeId.Thresholds && thresholds !== null && thresholds !== void 0 && thresholds.steps && thresholds.steps.length > 1) {\n    return getThresholdItems(fieldConfig, theme);\n  } // If thresholds are enabled show each step in the legend\n\n\n  if (colorMode.startsWith('continuous')) {\n    return undefined; // eventually a color bar\n  }\n\n  let stateColors = new Map();\n  fields.forEach(field => {\n    field.values.toArray().forEach(v => {\n      let state = field.display(v);\n\n      if (state.color) {\n        stateColors.set(state.text, state.color);\n      }\n    });\n  });\n  stateColors.forEach((color, label) => {\n    if (label.length > 0) {\n      items.push({\n        label: label,\n        color: theme.visualization.getColorByName(color !== null && color !== void 0 ? color : FALLBACK_COLOR),\n        yAxis: 1\n      });\n    }\n  });\n  return items;\n}\n\nfunction allNonTimeFields(frames) {\n  const fields = [];\n\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.type !== FieldType.time) {\n        fields.push(field);\n      }\n    }\n  }\n\n  return fields;\n}\n\nexport function findNextStateIndex(field, datapointIdx) {\n  let end;\n  let rightPointer = datapointIdx + 1;\n\n  if (rightPointer >= field.values.length) {\n    return null;\n  }\n\n  const startValue = field.values.get(datapointIdx);\n\n  while (end === undefined) {\n    if (rightPointer >= field.values.length) {\n      return null;\n    }\n\n    const rightValue = field.values.get(rightPointer);\n\n    if (rightValue === undefined || rightValue === startValue) {\n      rightPointer++;\n    } else {\n      end = rightPointer;\n    }\n  }\n\n  return end;\n}\n/**\n * Returns the precise duration of a time range passed in milliseconds.\n * This function calculates with 30 days month and 365 days year.\n * adapted from https://gist.github.com/remino/1563878\n * @param milliSeconds The duration in milliseconds\n * @returns A formated string of the duration\n */\n\nexport function fmtDuration(milliSeconds) {\n  if (milliSeconds < 0 || Number.isNaN(milliSeconds)) {\n    return '';\n  }\n\n  let yr, mo, wk, d, h, m, s, ms;\n  s = Math.floor(milliSeconds / 1000);\n  m = Math.floor(s / 60);\n  s = s % 60;\n  h = Math.floor(m / 60);\n  m = m % 60;\n  d = Math.floor(h / 24);\n  h = h % 24;\n  yr = Math.floor(d / 365);\n\n  if (yr > 0) {\n    d = d % 365;\n  }\n\n  mo = Math.floor(d / 30);\n\n  if (mo > 0) {\n    d = d % 30;\n  }\n\n  wk = Math.floor(d / 7);\n\n  if (wk > 0) {\n    d = d % 7;\n  }\n\n  ms = Math.round(milliSeconds % 1000 * 1000) / 1000;\n  return (yr > 0 ? yr + 'y ' + (mo > 0 ? mo + 'mo ' : '') + (wk > 0 ? wk + 'w ' : '') + (d > 0 ? d + 'd ' : '') : mo > 0 ? mo + 'mo ' + (wk > 0 ? wk + 'w ' : '') + (d > 0 ? d + 'd ' : '') : wk > 0 ? wk + 'w ' + (d > 0 ? d + 'd ' : '') : d > 0 ? d + 'd ' + (h > 0 ? h + 'h ' : '') : h > 0 ? h + 'h ' + (m > 0 ? m + 'm ' : '') : m > 0 ? m + 'm ' + (s > 0 ? s + 's ' : '') : s > 0 ? s + 's ' + (ms > 0 ? ms + 'ms ' : '') : ms > 0 ? ms + 'ms ' : '0').trim();\n}","map":{"version":3,"names":["ArrayVector","DashboardCursorSync","DataHoverEvent","DataHoverClearEvent","FALLBACK_COLOR","FieldColorModeId","FieldType","formattedValueToString","getFieldDisplayName","getValueFormat","getActiveThreshold","getFieldConfigWithMinMax","ThresholdsMode","AxisPlacement","ScaleDirection","ScaleOrientation","FIXED_UNIT","SeriesVisibilityChangeMode","UPlotConfigBuilder","applyNullInsertThreshold","nullToValue","preparePlotData2","getStackingGroups","getConfig","defaultConfig","lineWidth","fillOpacity","mapMouseEventToMode","event","ctrlKey","metaKey","shiftKey","AppendToSelection","ToggleSelection","preparePlotConfigBuilder","frame","theme","timeZone","getTimeRange","mode","eventBus","sync","rowHeight","colWidth","showValue","alignValue","mergeValues","getValueColor","builder","xScaleUnit","xScaleKey","isDiscrete","field","config","color","display","startsWith","getValueColorFn","seriesIdx","value","fields","state","origin","fieldIndex","undefined","frameIndex","opts","numSeries","length","label","getFieldConfig","custom","formatValue","onHover","seriesIndex","valueIndex","hoveredSeriesIdx","hoveredDataIdx","shouldChangeHover","onLeave","coreConfig","payload","point","data","addHook","init","drawClear","setCursor","interpolateTooltip","updateActiveSeriesIdx","updateActiveDatapointIdx","updateTooltipPosition","setTooltipInterpolator","setPrepData","frames","cursor","addScale","scaleKey","isTime","orientation","Horizontal","direction","Right","range","xRange","Vertical","Up","yRange","addAxis","splits","xSplits","placement","Bottom","grid","show","Left","ySplits","values","yValues","ticks","gap","i","customConfig","addSeries","pathBuilder","drawPaths","pointsBuilder","drawPoints","hideFrom","viz","thresholds","dataFrameFieldIndex","Off","key","filters","pub","type","src","x","y","w","h","dataIdx","rowIndex","publish","posToVal","panelRelY","down","scales","setSync","getNamesToFieldIndex","names","Map","set","unsetSameFutureValues","prevVal","clone","getSpanNulls","spanNulls","Infinity","mergeThresholdValues","number","steps","items","getThresholdItems","thresholdToText","textToColor","input","toArray","vals","Array","Percentage","min","max","delta","map","v","get","string","text","numeric","NaN","prepareTimelineFields","series","timeRange","warn","hasTimeseries","isTimeseries","changed","nulledFrame","refFieldPseudoMin","from","valueOf","refFieldPseudoMax","to","time","push","Thresholds","f","boolean","fieldConfig","disp","unit","fmt","step","visualization","getColorByName","yAxis","prepareTimelineLegendItems","options","displayMode","getFieldLegendItem","allNonTimeFields","colorMode","Fixed","stateColors","forEach","findNextStateIndex","datapointIdx","end","rightPointer","startValue","rightValue","fmtDuration","milliSeconds","Number","isNaN","yr","mo","wk","d","m","s","ms","Math","floor","round","trim"],"sources":["/home/soula/grafana/public/app/plugins/panel/state-timeline/utils.ts"],"sourcesContent":["import React from 'react';\nimport uPlot from 'uplot';\n\nimport {\n  ArrayVector,\n  DataFrame,\n  DashboardCursorSync,\n  DataHoverPayload,\n  DataHoverEvent,\n  DataHoverClearEvent,\n  FALLBACK_COLOR,\n  Field,\n  FieldColorModeId,\n  FieldConfig,\n  FieldType,\n  formattedValueToString,\n  getFieldDisplayName,\n  getValueFormat,\n  GrafanaTheme2,\n  getActiveThreshold,\n  Threshold,\n  getFieldConfigWithMinMax,\n  ThresholdsMode,\n  TimeRange,\n} from '@grafana/data';\nimport { VizLegendOptions, AxisPlacement, ScaleDirection, ScaleOrientation } from '@grafana/schema';\nimport {\n  FIXED_UNIT,\n  SeriesVisibilityChangeMode,\n  UPlotConfigBuilder,\n  UPlotConfigPrepFn,\n  VizLegendItem,\n} from '@grafana/ui';\nimport { applyNullInsertThreshold } from '@grafana/ui/src/components/GraphNG/nullInsertThreshold';\nimport { nullToValue } from '@grafana/ui/src/components/GraphNG/nullToValue';\nimport { PlotTooltipInterpolator } from '@grafana/ui/src/components/uPlot/types';\n\nimport { preparePlotData2, getStackingGroups } from '../../../../../packages/grafana-ui/src/components/uPlot/utils';\n\nimport { getConfig, TimelineCoreOptions } from './timeline';\nimport { TimelineFieldConfig, TimelineOptions } from './types';\n\nconst defaultConfig: TimelineFieldConfig = {\n  lineWidth: 0,\n  fillOpacity: 80,\n};\n\nexport function mapMouseEventToMode(event: React.MouseEvent): SeriesVisibilityChangeMode {\n  if (event.ctrlKey || event.metaKey || event.shiftKey) {\n    return SeriesVisibilityChangeMode.AppendToSelection;\n  }\n  return SeriesVisibilityChangeMode.ToggleSelection;\n}\n\nexport const preparePlotConfigBuilder: UPlotConfigPrepFn<TimelineOptions> = ({\n  frame,\n  theme,\n  timeZone,\n  getTimeRange,\n  mode,\n  eventBus,\n  sync,\n  rowHeight,\n  colWidth,\n  showValue,\n  alignValue,\n  mergeValues,\n  getValueColor,\n}) => {\n  const builder = new UPlotConfigBuilder(timeZone);\n\n  const xScaleUnit = 'time';\n  const xScaleKey = 'x';\n\n  const isDiscrete = (field: Field) => {\n    const mode = field.config?.color?.mode;\n    return !(mode && field.display && mode.startsWith('continuous-'));\n  };\n\n  const getValueColorFn = (seriesIdx: number, value: any) => {\n    const field = frame.fields[seriesIdx];\n\n    if (\n      field.state?.origin?.fieldIndex !== undefined &&\n      field.state?.origin?.frameIndex !== undefined &&\n      getValueColor\n    ) {\n      return getValueColor(field.state?.origin?.frameIndex, field.state?.origin?.fieldIndex, value);\n    }\n\n    return FALLBACK_COLOR;\n  };\n\n  const opts: TimelineCoreOptions = {\n    // should expose in panel config\n    mode: mode!,\n    numSeries: frame.fields.length - 1,\n    isDiscrete: (seriesIdx) => isDiscrete(frame.fields[seriesIdx]),\n    mergeValues,\n    rowHeight: rowHeight!,\n    colWidth: colWidth,\n    showValue: showValue!,\n    alignValue,\n    theme,\n    label: (seriesIdx) => getFieldDisplayName(frame.fields[seriesIdx], frame),\n    getFieldConfig: (seriesIdx) => frame.fields[seriesIdx].config.custom,\n    getValueColor: getValueColorFn,\n    getTimeRange,\n    // hardcoded formatter for state values\n    formatValue: (seriesIdx, value) => formattedValueToString(frame.fields[seriesIdx].display!(value)),\n    onHover: (seriesIndex, valueIndex) => {\n      hoveredSeriesIdx = seriesIndex;\n      hoveredDataIdx = valueIndex;\n      shouldChangeHover = true;\n    },\n    onLeave: () => {\n      hoveredSeriesIdx = null;\n      hoveredDataIdx = null;\n      shouldChangeHover = true;\n    },\n  };\n\n  let shouldChangeHover = false;\n  let hoveredSeriesIdx: number | null = null;\n  let hoveredDataIdx: number | null = null;\n\n  const coreConfig = getConfig(opts);\n  const payload: DataHoverPayload = {\n    point: {\n      [xScaleUnit]: null,\n      [FIXED_UNIT]: null,\n    },\n    data: frame,\n  };\n\n  builder.addHook('init', coreConfig.init);\n  builder.addHook('drawClear', coreConfig.drawClear);\n  builder.addHook('setCursor', coreConfig.setCursor);\n\n  // in TooltipPlugin, this gets invoked and the result is bound to a setCursor hook\n  // which fires after the above setCursor hook, so can take advantage of hoveringOver\n  // already set by the above onHover/onLeave callbacks that fire from coreConfig.setCursor\n  const interpolateTooltip: PlotTooltipInterpolator = (\n    updateActiveSeriesIdx,\n    updateActiveDatapointIdx,\n    updateTooltipPosition\n  ) => {\n    if (shouldChangeHover) {\n      if (hoveredSeriesIdx != null) {\n        updateActiveSeriesIdx(hoveredSeriesIdx);\n        updateActiveDatapointIdx(hoveredDataIdx);\n      }\n\n      shouldChangeHover = false;\n    }\n\n    updateTooltipPosition(hoveredSeriesIdx == null);\n  };\n\n  builder.setTooltipInterpolator(interpolateTooltip);\n\n  builder.setPrepData((frames) => preparePlotData2(frames[0], getStackingGroups(frames[0])));\n\n  builder.setCursor(coreConfig.cursor);\n\n  builder.addScale({\n    scaleKey: xScaleKey,\n    isTime: true,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    range: coreConfig.xRange,\n  });\n\n  builder.addScale({\n    scaleKey: FIXED_UNIT, // y\n    isTime: false,\n    orientation: ScaleOrientation.Vertical,\n    direction: ScaleDirection.Up,\n    range: coreConfig.yRange,\n  });\n\n  builder.addAxis({\n    scaleKey: xScaleKey,\n    isTime: true,\n    splits: coreConfig.xSplits!,\n    placement: AxisPlacement.Bottom,\n    timeZone,\n    theme,\n    grid: { show: true },\n  });\n\n  builder.addAxis({\n    scaleKey: FIXED_UNIT, // y\n    isTime: false,\n    placement: AxisPlacement.Left,\n    splits: coreConfig.ySplits,\n    values: coreConfig.yValues,\n    grid: { show: false },\n    ticks: { show: false },\n    gap: 16,\n    theme,\n  });\n\n  let seriesIndex = 0;\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    if (i === 0) {\n      continue;\n    }\n\n    const field = frame.fields[i];\n    const config = field.config as FieldConfig<TimelineFieldConfig>;\n    const customConfig: TimelineFieldConfig = {\n      ...defaultConfig,\n      ...config.custom,\n    };\n\n    field.state!.seriesIndex = seriesIndex++;\n\n    // const scaleKey = config.unit || FIXED_UNIT;\n    // const colorMode = getFieldColorModeForField(field);\n\n    builder.addSeries({\n      scaleKey: FIXED_UNIT,\n      pathBuilder: coreConfig.drawPaths,\n      pointsBuilder: coreConfig.drawPoints,\n      //colorMode,\n      lineWidth: customConfig.lineWidth,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      show: !customConfig.hideFrom?.viz,\n      thresholds: config.thresholds,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: field.state?.origin,\n    });\n  }\n\n  if (sync && sync() !== DashboardCursorSync.Off) {\n    let cursor: Partial<uPlot.Cursor> = {};\n\n    cursor.sync = {\n      key: '__global_',\n      filters: {\n        pub: (type: string, src: uPlot, x: number, y: number, w: number, h: number, dataIdx: number) => {\n          if (sync && sync() === DashboardCursorSync.Off) {\n            return false;\n          }\n          payload.rowIndex = dataIdx;\n          if (x < 0 && y < 0) {\n            payload.point[xScaleUnit] = null;\n            payload.point[FIXED_UNIT] = null;\n            eventBus.publish(new DataHoverClearEvent());\n          } else {\n            payload.point[xScaleUnit] = src.posToVal(x, xScaleKey);\n            payload.point.panelRelY = y > 0 ? y / h : 1; // used for old graph panel to position tooltip\n            payload.down = undefined;\n            eventBus.publish(new DataHoverEvent(payload));\n          }\n          return true;\n        },\n      },\n      //TODO: remove any once https://github.com/leeoniya/uPlot/pull/611 got merged or the typing is fixed\n      scales: [xScaleKey, null as any],\n    };\n    builder.setSync();\n    builder.setCursor(cursor);\n  }\n\n  return builder;\n};\n\nexport function getNamesToFieldIndex(frame: DataFrame): Map<string, number> {\n  const names = new Map<string, number>();\n  for (let i = 0; i < frame.fields.length; i++) {\n    names.set(getFieldDisplayName(frame.fields[i], frame), i);\n  }\n  return names;\n}\n\n/**\n * If any sequential duplicate values exist, this will return a new array\n * with the future values set to undefined.\n *\n * in:  1,        1,undefined,        1,2,        2,null,2,3\n * out: 1,undefined,undefined,undefined,2,undefined,null,2,3\n */\nexport function unsetSameFutureValues(values: any[]): any[] | undefined {\n  let prevVal = values[0];\n  let clone: any[] | undefined = undefined;\n\n  for (let i = 1; i < values.length; i++) {\n    let value = values[i];\n\n    if (value === null) {\n      prevVal = null;\n    } else {\n      if (value === prevVal) {\n        if (!clone) {\n          clone = [...values];\n        }\n        clone[i] = undefined;\n      } else if (value != null) {\n        prevVal = value;\n      }\n    }\n  }\n  return clone;\n}\n\nfunction getSpanNulls(field: Field) {\n  let spanNulls = field.config.custom?.spanNulls;\n\n  // magic value for join() to leave nulls alone instead of expanding null ranges\n  // should be set to -1 when spanNulls = null|undefined|false|0, which is \"retain nulls, without expanding\"\n  // Infinity is not optimal here since it causes spanNulls to be more expensive than simply removing all nulls unconditionally\n  return !spanNulls ? -1 : spanNulls === true ? Infinity : spanNulls;\n}\n\n/**\n * Merge values by the threshold\n */\nexport function mergeThresholdValues(field: Field, theme: GrafanaTheme2): Field | undefined {\n  const thresholds = field.config.thresholds;\n  if (field.type !== FieldType.number || !thresholds || !thresholds.steps.length) {\n    return undefined;\n  }\n\n  const items = getThresholdItems(field.config, theme);\n  if (items.length !== thresholds.steps.length) {\n    return undefined; // should not happen\n  }\n\n  const thresholdToText = new Map<Threshold, string>();\n  const textToColor = new Map<string, string>();\n  for (let i = 0; i < items.length; i++) {\n    thresholdToText.set(thresholds.steps[i], items[i].label);\n    textToColor.set(items[i].label, items[i].color!);\n  }\n\n  let input = field.values.toArray();\n  const vals = new Array<String | undefined>(field.values.length);\n  if (thresholds.mode === ThresholdsMode.Percentage) {\n    const { min, max } = getFieldConfigWithMinMax(field);\n    const delta = max! - min!;\n    input = input.map((v) => {\n      if (v == null) {\n        return v;\n      }\n      return ((v - min!) / delta) * 100;\n    });\n  }\n\n  for (let i = 0; i < vals.length; i++) {\n    const v = input[i];\n    if (v == null) {\n      vals[i] = v;\n    } else {\n      vals[i] = thresholdToText.get(getActiveThreshold(v, thresholds.steps));\n    }\n  }\n\n  return {\n    ...field,\n    config: {\n      ...field.config,\n      custom: {\n        ...field.config.custom,\n        spanNulls: getSpanNulls(field),\n      },\n    },\n    type: FieldType.string,\n    values: new ArrayVector(vals),\n    display: (value: string) => ({\n      text: value,\n      color: textToColor.get(value),\n      numeric: NaN,\n    }),\n  };\n}\n\n// This will return a set of frames with only graphable values included\nexport function prepareTimelineFields(\n  series: DataFrame[] | undefined,\n  mergeValues: boolean,\n  timeRange: TimeRange,\n  theme: GrafanaTheme2\n): { frames?: DataFrame[]; warn?: string } {\n  if (!series?.length) {\n    return { warn: 'No data in response' };\n  }\n  let hasTimeseries = false;\n  const frames: DataFrame[] = [];\n\n  for (let frame of series) {\n    let isTimeseries = false;\n    let changed = false;\n\n    let nulledFrame = applyNullInsertThreshold({\n      frame,\n      refFieldPseudoMin: timeRange.from.valueOf(),\n      refFieldPseudoMax: timeRange.to.valueOf(),\n    });\n\n    if (nulledFrame !== frame) {\n      changed = true;\n    }\n\n    const fields: Field[] = [];\n    for (let field of nullToValue(nulledFrame).fields) {\n      switch (field.type) {\n        case FieldType.time:\n          isTimeseries = true;\n          hasTimeseries = true;\n          fields.push(field);\n          break;\n        case FieldType.number:\n          if (mergeValues && field.config.color?.mode === FieldColorModeId.Thresholds) {\n            const f = mergeThresholdValues(field, theme);\n            if (f) {\n              fields.push(f);\n              changed = true;\n              continue;\n            }\n          }\n\n        case FieldType.boolean:\n        case FieldType.string:\n          field = {\n            ...field,\n            config: {\n              ...field.config,\n              custom: {\n                ...field.config.custom,\n                spanNulls: getSpanNulls(field),\n              },\n            },\n          };\n          fields.push(field);\n          break;\n        default:\n          changed = true;\n      }\n    }\n    if (isTimeseries && fields.length > 1) {\n      hasTimeseries = true;\n      if (changed) {\n        frames.push({\n          ...frame,\n          fields,\n        });\n      } else {\n        frames.push(frame);\n      }\n    }\n  }\n\n  if (!hasTimeseries) {\n    return { warn: 'Data does not have a time field' };\n  }\n  if (!frames.length) {\n    return { warn: 'No graphable fields' };\n  }\n  return { frames };\n}\n\nexport function getThresholdItems(fieldConfig: FieldConfig, theme: GrafanaTheme2): VizLegendItem[] {\n  const items: VizLegendItem[] = [];\n  const thresholds = fieldConfig.thresholds;\n  if (!thresholds || !thresholds.steps.length) {\n    return items;\n  }\n\n  const steps = thresholds.steps;\n  const disp = getValueFormat(thresholds.mode === ThresholdsMode.Percentage ? 'percent' : fieldConfig.unit ?? '');\n\n  const fmt = (v: number) => formattedValueToString(disp(v));\n\n  for (let i = 1; i <= steps.length; i++) {\n    const step = steps[i - 1];\n    items.push({\n      label: i === 1 ? `< ${fmt(step.value)}` : `${fmt(step.value)}+`,\n      color: theme.visualization.getColorByName(step.color),\n      yAxis: 1,\n    });\n  }\n\n  return items;\n}\n\nexport function prepareTimelineLegendItems(\n  frames: DataFrame[] | undefined,\n  options: VizLegendOptions,\n  theme: GrafanaTheme2\n): VizLegendItem[] | undefined {\n  if (!frames || options.displayMode === 'hidden') {\n    return undefined;\n  }\n\n  return getFieldLegendItem(allNonTimeFields(frames), theme);\n}\n\nexport function getFieldLegendItem(fields: Field[], theme: GrafanaTheme2): VizLegendItem[] | undefined {\n  if (!fields.length) {\n    return undefined;\n  }\n\n  const items: VizLegendItem[] = [];\n  const fieldConfig = fields[0].config;\n  const colorMode = fieldConfig.color?.mode ?? FieldColorModeId.Fixed;\n  const thresholds = fieldConfig.thresholds;\n\n  // If thresholds are enabled show each step in the legend\n  if (colorMode === FieldColorModeId.Thresholds && thresholds?.steps && thresholds.steps.length > 1) {\n    return getThresholdItems(fieldConfig, theme);\n  }\n\n  // If thresholds are enabled show each step in the legend\n  if (colorMode.startsWith('continuous')) {\n    return undefined; // eventually a color bar\n  }\n\n  let stateColors: Map<string, string | undefined> = new Map();\n\n  fields.forEach((field) => {\n    field.values.toArray().forEach((v) => {\n      let state = field.display!(v);\n      if (state.color) {\n        stateColors.set(state.text, state.color!);\n      }\n    });\n  });\n\n  stateColors.forEach((color, label) => {\n    if (label.length > 0) {\n      items.push({\n        label: label!,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n  });\n\n  return items;\n}\n\nfunction allNonTimeFields(frames: DataFrame[]): Field[] {\n  const fields: Field[] = [];\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.type !== FieldType.time) {\n        fields.push(field);\n      }\n    }\n  }\n  return fields;\n}\n\nexport function findNextStateIndex(field: Field, datapointIdx: number) {\n  let end;\n  let rightPointer = datapointIdx + 1;\n\n  if (rightPointer >= field.values.length) {\n    return null;\n  }\n\n  const startValue = field.values.get(datapointIdx);\n\n  while (end === undefined) {\n    if (rightPointer >= field.values.length) {\n      return null;\n    }\n    const rightValue = field.values.get(rightPointer);\n\n    if (rightValue === undefined || rightValue === startValue) {\n      rightPointer++;\n    } else {\n      end = rightPointer;\n    }\n  }\n\n  return end;\n}\n\n/**\n * Returns the precise duration of a time range passed in milliseconds.\n * This function calculates with 30 days month and 365 days year.\n * adapted from https://gist.github.com/remino/1563878\n * @param milliSeconds The duration in milliseconds\n * @returns A formated string of the duration\n */\nexport function fmtDuration(milliSeconds: number): string {\n  if (milliSeconds < 0 || Number.isNaN(milliSeconds)) {\n    return '';\n  }\n\n  let yr: number, mo: number, wk: number, d: number, h: number, m: number, s: number, ms: number;\n\n  s = Math.floor(milliSeconds / 1000);\n  m = Math.floor(s / 60);\n  s = s % 60;\n  h = Math.floor(m / 60);\n  m = m % 60;\n  d = Math.floor(h / 24);\n  h = h % 24;\n\n  yr = Math.floor(d / 365);\n  if (yr > 0) {\n    d = d % 365;\n  }\n\n  mo = Math.floor(d / 30);\n  if (mo > 0) {\n    d = d % 30;\n  }\n\n  wk = Math.floor(d / 7);\n\n  if (wk > 0) {\n    d = d % 7;\n  }\n\n  ms = Math.round((milliSeconds % 1000) * 1000) / 1000;\n\n  return (\n    yr > 0\n      ? yr + 'y ' + (mo > 0 ? mo + 'mo ' : '') + (wk > 0 ? wk + 'w ' : '') + (d > 0 ? d + 'd ' : '')\n      : mo > 0\n      ? mo + 'mo ' + (wk > 0 ? wk + 'w ' : '') + (d > 0 ? d + 'd ' : '')\n      : wk > 0\n      ? wk + 'w ' + (d > 0 ? d + 'd ' : '')\n      : d > 0\n      ? d + 'd ' + (h > 0 ? h + 'h ' : '')\n      : h > 0\n      ? h + 'h ' + (m > 0 ? m + 'm ' : '')\n      : m > 0\n      ? m + 'm ' + (s > 0 ? s + 's ' : '')\n      : s > 0\n      ? s + 's ' + (ms > 0 ? ms + 'ms ' : '')\n      : ms > 0\n      ? ms + 'ms '\n      : '0'\n  ).trim();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}