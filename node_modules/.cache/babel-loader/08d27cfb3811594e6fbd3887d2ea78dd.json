{"ast":null,"code":"import { uniqBy } from 'lodash';\nimport { MatcherOperator } from 'app/plugins/datasource/alertmanager/types';\nimport { parseMatcher } from './alertmanager'; // Parses a list of entries like like \"['foo=bar', 'baz=~bad*']\" into SilenceMatcher[]\n\nexport function parseQueryParamMatchers(matcherPairs) {\n  const parsedMatchers = matcherPairs.filter(x => !!x.trim()).map(x => parseMatcher(x.trim())); // Due to migration, old alert rules might have a duplicated alertname label\n  // To handle that case want to filter out duplicates and make sure there are only unique labels\n\n  return uniqBy(parsedMatchers, matcher => matcher.name);\n}\nexport const getMatcherQueryParams = labels => {\n  const validMatcherLabels = Object.entries(labels).filter(([labelKey]) => !(labelKey.startsWith('__') && labelKey.endsWith('__')));\n  const matcherUrlParams = new URLSearchParams();\n  validMatcherLabels.forEach(([labelKey, labelValue]) => matcherUrlParams.append('matcher', `${labelKey}=${labelValue}`));\n  return matcherUrlParams;\n};\nexport const findAlertInstancesWithMatchers = (instances, matchers) => {\n  const hasMatcher = (instance, matcher) => {\n    return Object.entries(instance.labels).some(([key, value]) => {\n      if (!matcher.name || !matcher.value) {\n        return false;\n      }\n\n      if (matcher.operator === MatcherOperator.equal) {\n        return matcher.name === key && matcher.value === value;\n      }\n\n      if (matcher.operator === MatcherOperator.notEqual) {\n        return matcher.name === key && matcher.value !== value;\n      }\n\n      if (matcher.operator === MatcherOperator.regex) {\n        return matcher.name === key && matcher.value.match(value);\n      }\n\n      if (matcher.operator === MatcherOperator.notRegex) {\n        return matcher.name === key && !matcher.value.match(value);\n      }\n\n      return false;\n    });\n  };\n\n  const filteredInstances = instances.filter(instance => {\n    return matchers.every(matcher => hasMatcher(instance, matcher));\n  });\n  const mappedInstances = filteredInstances.map(instance => ({\n    id: `${instance.activeAt}-${instance.value}`,\n    data: {\n      matchedInstance: instance\n    }\n  }));\n  return mappedInstances;\n};","map":{"version":3,"names":["uniqBy","MatcherOperator","parseMatcher","parseQueryParamMatchers","matcherPairs","parsedMatchers","filter","x","trim","map","matcher","name","getMatcherQueryParams","labels","validMatcherLabels","Object","entries","labelKey","startsWith","endsWith","matcherUrlParams","URLSearchParams","forEach","labelValue","append","findAlertInstancesWithMatchers","instances","matchers","hasMatcher","instance","some","key","value","operator","equal","notEqual","regex","match","notRegex","filteredInstances","every","mappedInstances","id","activeAt","data","matchedInstance"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/utils/matchers.ts"],"sourcesContent":["import { uniqBy } from 'lodash';\n\nimport { Labels } from '@grafana/data';\nimport { Matcher, MatcherOperator } from 'app/plugins/datasource/alertmanager/types';\nimport { Alert } from 'app/types/unified-alerting';\n\nimport { MatcherFieldValue } from '../types/silence-form';\n\nimport { parseMatcher } from './alertmanager';\n\n// Parses a list of entries like like \"['foo=bar', 'baz=~bad*']\" into SilenceMatcher[]\nexport function parseQueryParamMatchers(matcherPairs: string[]): Matcher[] {\n  const parsedMatchers = matcherPairs.filter((x) => !!x.trim()).map((x) => parseMatcher(x.trim()));\n\n  // Due to migration, old alert rules might have a duplicated alertname label\n  // To handle that case want to filter out duplicates and make sure there are only unique labels\n  return uniqBy(parsedMatchers, (matcher) => matcher.name);\n}\n\nexport const getMatcherQueryParams = (labels: Labels) => {\n  const validMatcherLabels = Object.entries(labels).filter(\n    ([labelKey]) => !(labelKey.startsWith('__') && labelKey.endsWith('__'))\n  );\n\n  const matcherUrlParams = new URLSearchParams();\n  validMatcherLabels.forEach(([labelKey, labelValue]) =>\n    matcherUrlParams.append('matcher', `${labelKey}=${labelValue}`)\n  );\n\n  return matcherUrlParams;\n};\n\ninterface MatchedInstance {\n  id: string;\n  data: {\n    matchedInstance: Alert;\n  };\n}\n\nexport const findAlertInstancesWithMatchers = (\n  instances: Alert[],\n  matchers: MatcherFieldValue[]\n): MatchedInstance[] => {\n  const hasMatcher = (instance: Alert, matcher: MatcherFieldValue) => {\n    return Object.entries(instance.labels).some(([key, value]) => {\n      if (!matcher.name || !matcher.value) {\n        return false;\n      }\n      if (matcher.operator === MatcherOperator.equal) {\n        return matcher.name === key && matcher.value === value;\n      }\n      if (matcher.operator === MatcherOperator.notEqual) {\n        return matcher.name === key && matcher.value !== value;\n      }\n      if (matcher.operator === MatcherOperator.regex) {\n        return matcher.name === key && matcher.value.match(value);\n      }\n      if (matcher.operator === MatcherOperator.notRegex) {\n        return matcher.name === key && !matcher.value.match(value);\n      }\n      return false;\n    });\n  };\n\n  const filteredInstances = instances.filter((instance) => {\n    return matchers.every((matcher) => hasMatcher(instance, matcher));\n  });\n  const mappedInstances = filteredInstances.map((instance) => ({\n    id: `${instance.activeAt}-${instance.value}`,\n    data: { matchedInstance: instance },\n  }));\n\n  return mappedInstances;\n};\n"],"mappings":"AAAA,SAASA,MAAT,QAAuB,QAAvB;AAGA,SAAkBC,eAAlB,QAAyC,2CAAzC;AAKA,SAASC,YAAT,QAA6B,gBAA7B,C,CAEA;;AACA,OAAO,SAASC,uBAAT,CAAiCC,YAAjC,EAAoE;EACzE,MAAMC,cAAc,GAAGD,YAAY,CAACE,MAAb,CAAqBC,CAAD,IAAO,CAAC,CAACA,CAAC,CAACC,IAAF,EAA7B,EAAuCC,GAAvC,CAA4CF,CAAD,IAAOL,YAAY,CAACK,CAAC,CAACC,IAAF,EAAD,CAA9D,CAAvB,CADyE,CAGzE;EACA;;EACA,OAAOR,MAAM,CAACK,cAAD,EAAkBK,OAAD,IAAaA,OAAO,CAACC,IAAtC,CAAb;AACD;AAED,OAAO,MAAMC,qBAAqB,GAAIC,MAAD,IAAoB;EACvD,MAAMC,kBAAkB,GAAGC,MAAM,CAACC,OAAP,CAAeH,MAAf,EAAuBP,MAAvB,CACzB,CAAC,CAACW,QAAD,CAAD,KAAgB,EAAEA,QAAQ,CAACC,UAAT,CAAoB,IAApB,KAA6BD,QAAQ,CAACE,QAAT,CAAkB,IAAlB,CAA/B,CADS,CAA3B;EAIA,MAAMC,gBAAgB,GAAG,IAAIC,eAAJ,EAAzB;EACAP,kBAAkB,CAACQ,OAAnB,CAA2B,CAAC,CAACL,QAAD,EAAWM,UAAX,CAAD,KACzBH,gBAAgB,CAACI,MAAjB,CAAwB,SAAxB,EAAoC,GAAEP,QAAS,IAAGM,UAAW,EAA7D,CADF;EAIA,OAAOH,gBAAP;AACD,CAXM;AAoBP,OAAO,MAAMK,8BAA8B,GAAG,CAC5CC,SAD4C,EAE5CC,QAF4C,KAGtB;EACtB,MAAMC,UAAU,GAAG,CAACC,QAAD,EAAkBnB,OAAlB,KAAiD;IAClE,OAAOK,MAAM,CAACC,OAAP,CAAea,QAAQ,CAAChB,MAAxB,EAAgCiB,IAAhC,CAAqC,CAAC,CAACC,GAAD,EAAMC,KAAN,CAAD,KAAkB;MAC5D,IAAI,CAACtB,OAAO,CAACC,IAAT,IAAiB,CAACD,OAAO,CAACsB,KAA9B,EAAqC;QACnC,OAAO,KAAP;MACD;;MACD,IAAItB,OAAO,CAACuB,QAAR,KAAqBhC,eAAe,CAACiC,KAAzC,EAAgD;QAC9C,OAAOxB,OAAO,CAACC,IAAR,KAAiBoB,GAAjB,IAAwBrB,OAAO,CAACsB,KAAR,KAAkBA,KAAjD;MACD;;MACD,IAAItB,OAAO,CAACuB,QAAR,KAAqBhC,eAAe,CAACkC,QAAzC,EAAmD;QACjD,OAAOzB,OAAO,CAACC,IAAR,KAAiBoB,GAAjB,IAAwBrB,OAAO,CAACsB,KAAR,KAAkBA,KAAjD;MACD;;MACD,IAAItB,OAAO,CAACuB,QAAR,KAAqBhC,eAAe,CAACmC,KAAzC,EAAgD;QAC9C,OAAO1B,OAAO,CAACC,IAAR,KAAiBoB,GAAjB,IAAwBrB,OAAO,CAACsB,KAAR,CAAcK,KAAd,CAAoBL,KAApB,CAA/B;MACD;;MACD,IAAItB,OAAO,CAACuB,QAAR,KAAqBhC,eAAe,CAACqC,QAAzC,EAAmD;QACjD,OAAO5B,OAAO,CAACC,IAAR,KAAiBoB,GAAjB,IAAwB,CAACrB,OAAO,CAACsB,KAAR,CAAcK,KAAd,CAAoBL,KAApB,CAAhC;MACD;;MACD,OAAO,KAAP;IACD,CAjBM,CAAP;EAkBD,CAnBD;;EAqBA,MAAMO,iBAAiB,GAAGb,SAAS,CAACpB,MAAV,CAAkBuB,QAAD,IAAc;IACvD,OAAOF,QAAQ,CAACa,KAAT,CAAgB9B,OAAD,IAAakB,UAAU,CAACC,QAAD,EAAWnB,OAAX,CAAtC,CAAP;EACD,CAFyB,CAA1B;EAGA,MAAM+B,eAAe,GAAGF,iBAAiB,CAAC9B,GAAlB,CAAuBoB,QAAD,KAAe;IAC3Da,EAAE,EAAG,GAAEb,QAAQ,CAACc,QAAS,IAAGd,QAAQ,CAACG,KAAM,EADgB;IAE3DY,IAAI,EAAE;MAAEC,eAAe,EAAEhB;IAAnB;EAFqD,CAAf,CAAtB,CAAxB;EAKA,OAAOY,eAAP;AACD,CAlCM"},"metadata":{},"sourceType":"module"}