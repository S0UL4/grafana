{"ast":null,"code":"import { useState, useCallback, useMemo } from 'react';\nimport messageFromError from './messageFromError';\nexport default function useLastError() {\n  const [errors, setErrors] = useState([]); // Handles errors from any child components that request data to display their options\n\n  const addError = useCallback((errorSource, error) => {\n    setErrors(errors => {\n      const errorsCopy = [...errors];\n      const index = errors.findIndex(([vSource]) => vSource === errorSource); // If there's already an error, remove it. If we're setting a new error\n      // below, we'll move it to the front\n\n      if (index > -1) {\n        errorsCopy.splice(index, 1);\n      } // And then add the new error to the top of the array. If error is defined, it was already\n      // removed above.\n\n\n      if (error) {\n        errorsCopy.unshift([errorSource, error]);\n      }\n\n      return errorsCopy;\n    });\n  }, []);\n  const errorMessage = useMemo(() => {\n    const recentError = errors[0];\n    return recentError && messageFromError(recentError[1]);\n  }, [errors]);\n  return [errorMessage, addError];\n}","map":{"version":3,"names":["useState","useCallback","useMemo","messageFromError","useLastError","errors","setErrors","addError","errorSource","error","errorsCopy","index","findIndex","vSource","splice","unshift","errorMessage","recentError"],"sources":["/home/soula/grafana/public/app/plugins/datasource/grafana-azure-monitor-datasource/utils/useLastError.ts"],"sourcesContent":["import { useState, useCallback, useMemo } from 'react';\n\nimport { AzureMonitorErrorish } from '../types';\n\nimport messageFromError from './messageFromError';\n\ntype SourcedError = [string, AzureMonitorErrorish];\n\nexport default function useLastError() {\n  const [errors, setErrors] = useState<SourcedError[]>([]);\n\n  // Handles errors from any child components that request data to display their options\n  const addError = useCallback((errorSource: string, error: AzureMonitorErrorish | undefined) => {\n    setErrors((errors) => {\n      const errorsCopy = [...errors];\n      const index = errors.findIndex(([vSource]) => vSource === errorSource);\n\n      // If there's already an error, remove it. If we're setting a new error\n      // below, we'll move it to the front\n      if (index > -1) {\n        errorsCopy.splice(index, 1);\n      }\n\n      // And then add the new error to the top of the array. If error is defined, it was already\n      // removed above.\n      if (error) {\n        errorsCopy.unshift([errorSource, error]);\n      }\n\n      return errorsCopy;\n    });\n  }, []);\n\n  const errorMessage = useMemo(() => {\n    const recentError = errors[0];\n    return recentError && messageFromError(recentError[1]);\n  }, [errors]);\n\n  return [errorMessage, addError] as const;\n}\n"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,WAAnB,EAAgCC,OAAhC,QAA+C,OAA/C;AAIA,OAAOC,gBAAP,MAA6B,oBAA7B;AAIA,eAAe,SAASC,YAAT,GAAwB;EACrC,MAAM,CAACC,MAAD,EAASC,SAAT,IAAsBN,QAAQ,CAAiB,EAAjB,CAApC,CADqC,CAGrC;;EACA,MAAMO,QAAQ,GAAGN,WAAW,CAAC,CAACO,WAAD,EAAsBC,KAAtB,KAAkE;IAC7FH,SAAS,CAAED,MAAD,IAAY;MACpB,MAAMK,UAAU,GAAG,CAAC,GAAGL,MAAJ,CAAnB;MACA,MAAMM,KAAK,GAAGN,MAAM,CAACO,SAAP,CAAiB,CAAC,CAACC,OAAD,CAAD,KAAeA,OAAO,KAAKL,WAA5C,CAAd,CAFoB,CAIpB;MACA;;MACA,IAAIG,KAAK,GAAG,CAAC,CAAb,EAAgB;QACdD,UAAU,CAACI,MAAX,CAAkBH,KAAlB,EAAyB,CAAzB;MACD,CARmB,CAUpB;MACA;;;MACA,IAAIF,KAAJ,EAAW;QACTC,UAAU,CAACK,OAAX,CAAmB,CAACP,WAAD,EAAcC,KAAd,CAAnB;MACD;;MAED,OAAOC,UAAP;IACD,CAjBQ,CAAT;EAkBD,CAnB2B,EAmBzB,EAnByB,CAA5B;EAqBA,MAAMM,YAAY,GAAGd,OAAO,CAAC,MAAM;IACjC,MAAMe,WAAW,GAAGZ,MAAM,CAAC,CAAD,CAA1B;IACA,OAAOY,WAAW,IAAId,gBAAgB,CAACc,WAAW,CAAC,CAAD,CAAZ,CAAtC;EACD,CAH2B,EAGzB,CAACZ,MAAD,CAHyB,CAA5B;EAKA,OAAO,CAACW,YAAD,EAAeT,QAAf,CAAP;AACD"},"metadata":{},"sourceType":"module"}