{"ast":null,"code":"import { parser } from 'lezer-promql';\nimport { PromQueryModeller } from './querybuilder/PromQueryModeller';\nimport { buildVisualQueryFromString } from './querybuilder/parsing';\n\n/**\n * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.\n *\n * It uses PromQL parser to find instances of metric and labels, alters them and then splices them back into the query.\n * Ideally we could use the parse -> change -> render is a simple 3 steps but right now building the visual query\n * object does not support all possible queries.\n *\n * So instead this just operates on substrings of the query with labels and operates just on those. This makes this\n * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.\n * @param query\n * @param key\n * @param value\n * @param operator\n */\nexport function addLabelToQuery(query, key, value, operator = '=') {\n  if (!key || !value) {\n    throw new Error('Need label to add to query.');\n  }\n\n  const vectorSelectorPositions = getVectorSelectorPositions(query);\n\n  if (!vectorSelectorPositions.length) {\n    return query;\n  }\n\n  const filter = toLabelFilter(key, value, operator);\n  return addFilter(query, vectorSelectorPositions, filter);\n}\n\n/**\n * Parse the string and get all VectorSelector positions in the query together with parsed representation of the vector\n * selector.\n * @param query\n */\nfunction getVectorSelectorPositions(query) {\n  const tree = parser.parse(query);\n  const positions = [];\n  tree.iterate({\n    enter: (type, from, to, get) => {\n      if (type.name === 'VectorSelector') {\n        const visQuery = buildVisualQueryFromString(query.substring(from, to));\n        positions.push({\n          query: visQuery.query,\n          from,\n          to\n        });\n        return false;\n      }\n    }\n  });\n  return positions;\n}\n\nfunction toLabelFilter(key, value, operator) {\n  // We need to make sure that we convert the value back to string because it may be a number\n  const transformedValue = value === Infinity ? '+Inf' : value.toString();\n  return {\n    label: key,\n    op: operator,\n    value: transformedValue\n  };\n}\n\nfunction addFilter(query, vectorSelectorPositions, filter) {\n  const modeller = new PromQueryModeller();\n  let newQuery = '';\n  let prev = 0;\n\n  for (let i = 0; i < vectorSelectorPositions.length; i++) {\n    // This is basically just doing splice on a string for each matched vector selector.\n    const match = vectorSelectorPositions[i];\n    const isLast = i === vectorSelectorPositions.length - 1;\n    const start = query.substring(prev, match.from);\n    const end = isLast ? query.substring(match.to) : '';\n\n    if (!labelExists(match.query.labels, filter)) {\n      // We don't want to add duplicate labels.\n      match.query.labels.push(filter);\n    }\n\n    const newLabels = modeller.renderQuery(match.query);\n    newQuery += start + newLabels + end;\n    prev = match.to;\n  }\n\n  return newQuery;\n}\n/**\n * Check if label exists in the list of labels but ignore the operator.\n * @param labels\n * @param filter\n */\n\n\nfunction labelExists(labels, filter) {\n  return labels.find(label => label.label === filter.label && label.value === filter.value);\n}","map":{"version":3,"names":["parser","PromQueryModeller","buildVisualQueryFromString","addLabelToQuery","query","key","value","operator","Error","vectorSelectorPositions","getVectorSelectorPositions","length","filter","toLabelFilter","addFilter","tree","parse","positions","iterate","enter","type","from","to","get","name","visQuery","substring","push","transformedValue","Infinity","toString","label","op","modeller","newQuery","prev","i","match","isLast","start","end","labelExists","labels","newLabels","renderQuery","find"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/add_label_to_query.ts"],"sourcesContent":["import { parser } from 'lezer-promql';\n\nimport { PromQueryModeller } from './querybuilder/PromQueryModeller';\nimport { buildVisualQueryFromString } from './querybuilder/parsing';\nimport { QueryBuilderLabelFilter } from './querybuilder/shared/types';\nimport { PromVisualQuery } from './querybuilder/types';\n\n/**\n * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.\n *\n * It uses PromQL parser to find instances of metric and labels, alters them and then splices them back into the query.\n * Ideally we could use the parse -> change -> render is a simple 3 steps but right now building the visual query\n * object does not support all possible queries.\n *\n * So instead this just operates on substrings of the query with labels and operates just on those. This makes this\n * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.\n * @param query\n * @param key\n * @param value\n * @param operator\n */\nexport function addLabelToQuery(query: string, key: string, value: string | number, operator = '='): string {\n  if (!key || !value) {\n    throw new Error('Need label to add to query.');\n  }\n\n  const vectorSelectorPositions = getVectorSelectorPositions(query);\n  if (!vectorSelectorPositions.length) {\n    return query;\n  }\n\n  const filter = toLabelFilter(key, value, operator);\n  return addFilter(query, vectorSelectorPositions, filter);\n}\n\ntype VectorSelectorPosition = { from: number; to: number; query: PromVisualQuery };\n\n/**\n * Parse the string and get all VectorSelector positions in the query together with parsed representation of the vector\n * selector.\n * @param query\n */\nfunction getVectorSelectorPositions(query: string): VectorSelectorPosition[] {\n  const tree = parser.parse(query);\n  const positions: VectorSelectorPosition[] = [];\n  tree.iterate({\n    enter: (type, from, to, get): false | void => {\n      if (type.name === 'VectorSelector') {\n        const visQuery = buildVisualQueryFromString(query.substring(from, to));\n        positions.push({ query: visQuery.query, from, to });\n        return false;\n      }\n    },\n  });\n  return positions;\n}\n\nfunction toLabelFilter(key: string, value: string | number, operator: string): QueryBuilderLabelFilter {\n  // We need to make sure that we convert the value back to string because it may be a number\n  const transformedValue = value === Infinity ? '+Inf' : value.toString();\n  return { label: key, op: operator, value: transformedValue };\n}\n\nfunction addFilter(\n  query: string,\n  vectorSelectorPositions: VectorSelectorPosition[],\n  filter: QueryBuilderLabelFilter\n): string {\n  const modeller = new PromQueryModeller();\n  let newQuery = '';\n  let prev = 0;\n\n  for (let i = 0; i < vectorSelectorPositions.length; i++) {\n    // This is basically just doing splice on a string for each matched vector selector.\n\n    const match = vectorSelectorPositions[i];\n    const isLast = i === vectorSelectorPositions.length - 1;\n\n    const start = query.substring(prev, match.from);\n    const end = isLast ? query.substring(match.to) : '';\n\n    if (!labelExists(match.query.labels, filter)) {\n      // We don't want to add duplicate labels.\n      match.query.labels.push(filter);\n    }\n    const newLabels = modeller.renderQuery(match.query);\n    newQuery += start + newLabels + end;\n    prev = match.to;\n  }\n  return newQuery;\n}\n\n/**\n * Check if label exists in the list of labels but ignore the operator.\n * @param labels\n * @param filter\n */\nfunction labelExists(labels: QueryBuilderLabelFilter[], filter: QueryBuilderLabelFilter) {\n  return labels.find((label) => label.label === filter.label && label.value === filter.value);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}