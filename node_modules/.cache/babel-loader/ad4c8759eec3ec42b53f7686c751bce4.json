{"ast":null,"code":"import React, { useCallback, useMemo } from 'react';\nimport { FieldType } from '@grafana/data';\nimport { TooltipPlugin, useTheme2, ZoomPlugin, usePanelContext } from '@grafana/ui';\nimport { getLastStreamingDataFramePacket } from 'app/features/live/data/StreamingDataFrame';\nimport { OutsideRangePlugin } from '../timeseries/plugins/OutsideRangePlugin';\nimport { StateTimelineTooltip } from './StateTimelineTooltip';\nimport { TimelineChart } from './TimelineChart';\nimport { TimelineMode } from './types';\nimport { prepareTimelineFields, prepareTimelineLegendItems } from './utils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\n\n/**\n * @alpha\n */\nexport const StateTimelinePanel = ({\n  data,\n  timeRange,\n  timeZone,\n  options,\n  width,\n  height,\n  onChangeTimeRange\n}) => {\n  const theme = useTheme2();\n  const {\n    sync\n  } = usePanelContext();\n  const {\n    frames,\n    warn\n  } = useMemo(() => {\n    var _options$mergeValues;\n\n    return prepareTimelineFields(data === null || data === void 0 ? void 0 : data.series, (_options$mergeValues = options.mergeValues) !== null && _options$mergeValues !== void 0 ? _options$mergeValues : true, timeRange, theme);\n  }, [data, options.mergeValues, timeRange, theme]);\n  const legendItems = useMemo(() => prepareTimelineLegendItems(frames, options.legend, theme), [frames, options.legend, theme]);\n  const renderCustomTooltip = useCallback((alignedData, seriesIdx, datapointIdx) => {\n    var _alignedData$meta, _alignedData$meta$tra;\n\n    const data = frames !== null && frames !== void 0 ? frames : []; // Count value fields in the state-timeline-ready frame\n\n    const valueFieldsCount = data.reduce((acc, frame) => acc + frame.fields.filter(field => field.type !== FieldType.time).length, 0); // Not caring about multi mode in StateTimeline\n\n    if (seriesIdx === null || datapointIdx === null) {\n      return null;\n    }\n    /**\n     * There could be a case when the tooltip shows a data from one of a multiple query and the other query finishes first\n     * from refreshing. This causes data to be out of sync. alignedData - 1 because Time field doesn't count.\n     * Render nothing in this case to prevent error.\n     * See https://github.com/grafana/support-escalations/issues/932\n     */\n\n\n    if (!((_alignedData$meta = alignedData.meta) !== null && _alignedData$meta !== void 0 && (_alignedData$meta$tra = _alignedData$meta.transformations) !== null && _alignedData$meta$tra !== void 0 && _alignedData$meta$tra.length) && alignedData.fields.length - 1 !== valueFieldsCount || !alignedData.fields[seriesIdx]) {\n      return null;\n    }\n\n    return /*#__PURE__*/_jsx(StateTimelineTooltip, {\n      data: data,\n      alignedData: alignedData,\n      seriesIdx: seriesIdx,\n      datapointIdx: datapointIdx,\n      timeZone: timeZone\n    });\n  }, [timeZone, frames]);\n\n  if (!frames || warn) {\n    return /*#__PURE__*/_jsx(\"div\", {\n      className: \"panel-empty\",\n      children: /*#__PURE__*/_jsx(\"p\", {\n        children: warn !== null && warn !== void 0 ? warn : 'No data found in response'\n      })\n    });\n  }\n\n  if (frames.length === 1) {\n    const packet = getLastStreamingDataFramePacket(frames[0]);\n\n    if (packet) {// console.log('STREAM Packet', packet);\n    }\n  }\n\n  return /*#__PURE__*/_jsx(TimelineChart, Object.assign({\n    theme: theme,\n    frames: frames,\n    structureRev: data.structureRev,\n    timeRange: timeRange,\n    timeZone: timeZone,\n    width: width,\n    height: height,\n    legendItems: legendItems\n  }, options, {\n    mode: TimelineMode.Changes,\n    children: (config, alignedFrame) => {\n      return /*#__PURE__*/_jsxs(_Fragment, {\n        children: [/*#__PURE__*/_jsx(ZoomPlugin, {\n          config: config,\n          onZoom: onChangeTimeRange\n        }), /*#__PURE__*/_jsx(TooltipPlugin, {\n          data: alignedFrame,\n          sync: sync,\n          config: config,\n          mode: options.tooltip.mode,\n          timeZone: timeZone,\n          renderTooltip: renderCustomTooltip\n        }), /*#__PURE__*/_jsx(OutsideRangePlugin, {\n          config: config,\n          onChangeTimeRange: onChangeTimeRange\n        })]\n      });\n    }\n  }));\n};","map":{"version":3,"names":["React","useCallback","useMemo","FieldType","TooltipPlugin","useTheme2","ZoomPlugin","usePanelContext","getLastStreamingDataFramePacket","OutsideRangePlugin","StateTimelineTooltip","TimelineChart","TimelineMode","prepareTimelineFields","prepareTimelineLegendItems","StateTimelinePanel","data","timeRange","timeZone","options","width","height","onChangeTimeRange","theme","sync","frames","warn","series","mergeValues","legendItems","legend","renderCustomTooltip","alignedData","seriesIdx","datapointIdx","valueFieldsCount","reduce","acc","frame","fields","filter","field","type","time","length","meta","transformations","packet","structureRev","Changes","config","alignedFrame","tooltip","mode"],"sources":["/home/soula/grafana/public/app/plugins/panel/state-timeline/StateTimelinePanel.tsx"],"sourcesContent":["import React, { useCallback, useMemo } from 'react';\n\nimport { DataFrame, FieldType, PanelProps } from '@grafana/data';\nimport { TooltipPlugin, useTheme2, ZoomPlugin, usePanelContext } from '@grafana/ui';\nimport { getLastStreamingDataFramePacket } from 'app/features/live/data/StreamingDataFrame';\n\nimport { OutsideRangePlugin } from '../timeseries/plugins/OutsideRangePlugin';\n\nimport { StateTimelineTooltip } from './StateTimelineTooltip';\nimport { TimelineChart } from './TimelineChart';\nimport { TimelineMode, TimelineOptions } from './types';\nimport { prepareTimelineFields, prepareTimelineLegendItems } from './utils';\n\ninterface TimelinePanelProps extends PanelProps<TimelineOptions> {}\n\n/**\n * @alpha\n */\nexport const StateTimelinePanel: React.FC<TimelinePanelProps> = ({\n  data,\n  timeRange,\n  timeZone,\n  options,\n  width,\n  height,\n  onChangeTimeRange,\n}) => {\n  const theme = useTheme2();\n  const { sync } = usePanelContext();\n\n  const { frames, warn } = useMemo(\n    () => prepareTimelineFields(data?.series, options.mergeValues ?? true, timeRange, theme),\n    [data, options.mergeValues, timeRange, theme]\n  );\n\n  const legendItems = useMemo(\n    () => prepareTimelineLegendItems(frames, options.legend, theme),\n    [frames, options.legend, theme]\n  );\n\n  const renderCustomTooltip = useCallback(\n    (alignedData: DataFrame, seriesIdx: number | null, datapointIdx: number | null) => {\n      const data = frames ?? [];\n      // Count value fields in the state-timeline-ready frame\n      const valueFieldsCount = data.reduce(\n        (acc, frame) => acc + frame.fields.filter((field) => field.type !== FieldType.time).length,\n        0\n      );\n\n      // Not caring about multi mode in StateTimeline\n      if (seriesIdx === null || datapointIdx === null) {\n        return null;\n      }\n\n      /**\n       * There could be a case when the tooltip shows a data from one of a multiple query and the other query finishes first\n       * from refreshing. This causes data to be out of sync. alignedData - 1 because Time field doesn't count.\n       * Render nothing in this case to prevent error.\n       * See https://github.com/grafana/support-escalations/issues/932\n       */\n      if (\n        (!alignedData.meta?.transformations?.length && alignedData.fields.length - 1 !== valueFieldsCount) ||\n        !alignedData.fields[seriesIdx]\n      ) {\n        return null;\n      }\n\n      return (\n        <StateTimelineTooltip\n          data={data}\n          alignedData={alignedData}\n          seriesIdx={seriesIdx}\n          datapointIdx={datapointIdx}\n          timeZone={timeZone}\n        />\n      );\n    },\n    [timeZone, frames]\n  );\n\n  if (!frames || warn) {\n    return (\n      <div className=\"panel-empty\">\n        <p>{warn ?? 'No data found in response'}</p>\n      </div>\n    );\n  }\n\n  if (frames.length === 1) {\n    const packet = getLastStreamingDataFramePacket(frames[0]);\n    if (packet) {\n      // console.log('STREAM Packet', packet);\n    }\n  }\n\n  return (\n    <TimelineChart\n      theme={theme}\n      frames={frames}\n      structureRev={data.structureRev}\n      timeRange={timeRange}\n      timeZone={timeZone}\n      width={width}\n      height={height}\n      legendItems={legendItems}\n      {...options}\n      mode={TimelineMode.Changes}\n    >\n      {(config, alignedFrame) => {\n        return (\n          <>\n            <ZoomPlugin config={config} onZoom={onChangeTimeRange} />\n            <TooltipPlugin\n              data={alignedFrame}\n              sync={sync}\n              config={config}\n              mode={options.tooltip.mode}\n              timeZone={timeZone}\n              renderTooltip={renderCustomTooltip}\n            />\n            <OutsideRangePlugin config={config} onChangeTimeRange={onChangeTimeRange} />\n          </>\n        );\n      }}\n    </TimelineChart>\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}