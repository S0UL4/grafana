{"ast":null,"code":"// Copyright (c) 2020 The Jaeger Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { memoize } from 'lodash';\nexport function _getTraceNameImpl(spans) {\n  // Use a span with no references to another span in given array\n  // prefering the span with the fewest references\n  // using start time as a tie breaker\n  let candidateSpan;\n  const allIDs = new Set(spans.map(({\n    spanID\n  }) => spanID));\n\n  for (let i = 0; i < spans.length; i++) {\n    const hasInternalRef = spans[i].references && spans[i].references.some(({\n      traceID,\n      spanID\n    }) => traceID === spans[i].traceID && allIDs.has(spanID));\n\n    if (hasInternalRef) {\n      continue;\n    }\n\n    if (!candidateSpan) {\n      candidateSpan = spans[i];\n      continue;\n    }\n\n    const thisRefLength = spans[i].references && spans[i].references.length || 0;\n    const candidateRefLength = candidateSpan.references && candidateSpan.references.length || 0;\n\n    if (thisRefLength < candidateRefLength || thisRefLength === candidateRefLength && spans[i].startTime < candidateSpan.startTime) {\n      candidateSpan = spans[i];\n    }\n  }\n\n  return candidateSpan ? `${candidateSpan.process.serviceName}: ${candidateSpan.operationName}` : '';\n}\nexport const getTraceName = memoize(_getTraceNameImpl, spans => {\n  if (!spans.length) {\n    return 0;\n  }\n\n  return spans[0].traceID;\n});","map":{"version":3,"names":["memoize","_getTraceNameImpl","spans","candidateSpan","allIDs","Set","map","spanID","i","length","hasInternalRef","references","some","traceID","has","thisRefLength","candidateRefLength","startTime","process","serviceName","operationName","getTraceName"],"sources":["/home/soula/grafana/packages/jaeger-ui-components/src/model/trace-viewer.ts"],"sourcesContent":["// Copyright (c) 2020 The Jaeger Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { memoize } from 'lodash';\n\nimport { TraceSpan } from '../types/trace';\n\nexport function _getTraceNameImpl(spans: TraceSpan[]) {\n  // Use a span with no references to another span in given array\n  // prefering the span with the fewest references\n  // using start time as a tie breaker\n  let candidateSpan: TraceSpan | undefined;\n  const allIDs: Set<string> = new Set(spans.map(({ spanID }) => spanID));\n\n  for (let i = 0; i < spans.length; i++) {\n    const hasInternalRef =\n      spans[i].references &&\n      spans[i].references.some(({ traceID, spanID }) => traceID === spans[i].traceID && allIDs.has(spanID));\n    if (hasInternalRef) {\n      continue;\n    }\n\n    if (!candidateSpan) {\n      candidateSpan = spans[i];\n      continue;\n    }\n\n    const thisRefLength = (spans[i].references && spans[i].references.length) || 0;\n    const candidateRefLength = (candidateSpan.references && candidateSpan.references.length) || 0;\n\n    if (\n      thisRefLength < candidateRefLength ||\n      (thisRefLength === candidateRefLength && spans[i].startTime < candidateSpan.startTime)\n    ) {\n      candidateSpan = spans[i];\n    }\n  }\n  return candidateSpan ? `${candidateSpan.process.serviceName}: ${candidateSpan.operationName}` : '';\n}\n\nexport const getTraceName = memoize(_getTraceNameImpl, (spans: TraceSpan[]) => {\n  if (!spans.length) {\n    return 0;\n  }\n  return spans[0].traceID;\n});\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,OAAT,QAAwB,QAAxB;AAIA,OAAO,SAASC,iBAAT,CAA2BC,KAA3B,EAA+C;EACpD;EACA;EACA;EACA,IAAIC,aAAJ;EACA,MAAMC,MAAmB,GAAG,IAAIC,GAAJ,CAAQH,KAAK,CAACI,GAAN,CAAU,CAAC;IAAEC;EAAF,CAAD,KAAgBA,MAA1B,CAAR,CAA5B;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,KAAK,CAACO,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;IACrC,MAAME,cAAc,GAClBR,KAAK,CAACM,CAAD,CAAL,CAASG,UAAT,IACAT,KAAK,CAACM,CAAD,CAAL,CAASG,UAAT,CAAoBC,IAApB,CAAyB,CAAC;MAAEC,OAAF;MAAWN;IAAX,CAAD,KAAyBM,OAAO,KAAKX,KAAK,CAACM,CAAD,CAAL,CAASK,OAArB,IAAgCT,MAAM,CAACU,GAAP,CAAWP,MAAX,CAAlF,CAFF;;IAGA,IAAIG,cAAJ,EAAoB;MAClB;IACD;;IAED,IAAI,CAACP,aAAL,EAAoB;MAClBA,aAAa,GAAGD,KAAK,CAACM,CAAD,CAArB;MACA;IACD;;IAED,MAAMO,aAAa,GAAIb,KAAK,CAACM,CAAD,CAAL,CAASG,UAAT,IAAuBT,KAAK,CAACM,CAAD,CAAL,CAASG,UAAT,CAAoBF,MAA5C,IAAuD,CAA7E;IACA,MAAMO,kBAAkB,GAAIb,aAAa,CAACQ,UAAd,IAA4BR,aAAa,CAACQ,UAAd,CAAyBF,MAAtD,IAAiE,CAA5F;;IAEA,IACEM,aAAa,GAAGC,kBAAhB,IACCD,aAAa,KAAKC,kBAAlB,IAAwCd,KAAK,CAACM,CAAD,CAAL,CAASS,SAAT,GAAqBd,aAAa,CAACc,SAF9E,EAGE;MACAd,aAAa,GAAGD,KAAK,CAACM,CAAD,CAArB;IACD;EACF;;EACD,OAAOL,aAAa,GAAI,GAAEA,aAAa,CAACe,OAAd,CAAsBC,WAAY,KAAIhB,aAAa,CAACiB,aAAc,EAAxE,GAA4E,EAAhG;AACD;AAED,OAAO,MAAMC,YAAY,GAAGrB,OAAO,CAACC,iBAAD,EAAqBC,KAAD,IAAwB;EAC7E,IAAI,CAACA,KAAK,CAACO,MAAX,EAAmB;IACjB,OAAO,CAAP;EACD;;EACD,OAAOP,KAAK,CAAC,CAAD,CAAL,CAASW,OAAhB;AACD,CALkC,CAA5B"},"metadata":{},"sourceType":"module"}