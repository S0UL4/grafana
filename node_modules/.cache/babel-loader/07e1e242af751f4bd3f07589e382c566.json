{"ast":null,"code":"import { v5 as uuidv5 } from 'uuid';\nimport { FieldType, findUniqueLabels } from '@grafana/data';\nconst UUID_NAMESPACE = '6ec946da-0f49-47a8-983a-1d76d17e7c92';\n/**\n * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be\n * a CircularDataFrame creating a fixed size rolling buffer.\n * TODO: Probably could be unified with the logStreamToDataFrame function.\n * @param response\n * @param data Needs to have ts, line, labels, id as fields\n */\n\nexport function appendResponseToBufferedData(response, data) {\n  // Should we do anything with: response.dropped_entries?\n  const streams = response.streams;\n\n  if (!streams || !streams.length) {\n    return;\n  }\n\n  let baseLabels = {};\n\n  for (const f of data.fields) {\n    if (f.type === FieldType.string) {\n      if (f.labels) {\n        baseLabels = f.labels;\n      }\n\n      break;\n    }\n  }\n\n  const labelsField = data.fields[0];\n  const tsField = data.fields[1];\n  const lineField = data.fields[2];\n  const idField = data.fields[3];\n  const tsNsField = data.fields[4]; // We are comparing used ids only within the received stream. This could be a problem if the same line + labels + nanosecond timestamp came in 2 separate batches.\n  // As this is very unlikely, and the result would only affect live-tailing css animation we have decided to not compare all received uids from data param as this would slow down processing.\n\n  const usedUids = {};\n\n  for (const stream of streams) {\n    // Find unique labels\n    const unique = findUniqueLabels(stream.stream, baseLabels);\n    const allLabelsString = Object.entries(stream.stream).map(([key, val]) => `${key}=\"${val}\"`).sort().join(''); // Add each line\n\n    for (const [ts, line] of stream.values) {\n      tsField.values.add(new Date(parseInt(ts.slice(0, -6), 10)).toISOString());\n      tsNsField.values.add(ts);\n      lineField.values.add(line);\n      labelsField.values.add(unique);\n      idField.values.add(createUid(ts, allLabelsString, line, usedUids, data.refId));\n    }\n  }\n}\n\nfunction createUid(ts, labelsString, line, usedUids, refId) {\n  // Generate id as hashed nanosecond timestamp, labels and line (this does not have to be unique)\n  let id = uuidv5(`${ts}_${labelsString}_${line}`, UUID_NAMESPACE); // Check if generated id is unique\n  // If not and we've already used it, append it's count after it\n\n  if (id in usedUids) {\n    // Increase the count\n    const newCount = usedUids[id] + 1;\n    usedUids[id] = newCount; // Append count to generated id to make it unique\n\n    id = `${id}_${newCount}`;\n  } else {\n    // If id is unique and wasn't used, add it to usedUids and start count at 0\n    usedUids[id] = 0;\n  } // Return unique id\n\n\n  if (refId) {\n    return `${id}_${refId}`;\n  }\n\n  return id;\n}","map":{"version":3,"names":["v5","uuidv5","FieldType","findUniqueLabels","UUID_NAMESPACE","appendResponseToBufferedData","response","data","streams","length","baseLabels","f","fields","type","string","labels","labelsField","tsField","lineField","idField","tsNsField","usedUids","stream","unique","allLabelsString","Object","entries","map","key","val","sort","join","ts","line","values","add","Date","parseInt","slice","toISOString","createUid","refId","labelsString","id","newCount"],"sources":["/home/soula/grafana/public/app/plugins/datasource/loki/live_streams_result_transformer.ts"],"sourcesContent":["import { v5 as uuidv5 } from 'uuid';\n\nimport { FieldType, Labels, MutableDataFrame, findUniqueLabels } from '@grafana/data';\n\nimport { LokiStreamResult, LokiTailResponse } from './types';\n\nconst UUID_NAMESPACE = '6ec946da-0f49-47a8-983a-1d76d17e7c92';\n\n/**\n * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be\n * a CircularDataFrame creating a fixed size rolling buffer.\n * TODO: Probably could be unified with the logStreamToDataFrame function.\n * @param response\n * @param data Needs to have ts, line, labels, id as fields\n */\nexport function appendResponseToBufferedData(response: LokiTailResponse, data: MutableDataFrame) {\n  // Should we do anything with: response.dropped_entries?\n\n  const streams: LokiStreamResult[] = response.streams;\n  if (!streams || !streams.length) {\n    return;\n  }\n\n  let baseLabels: Labels = {};\n  for (const f of data.fields) {\n    if (f.type === FieldType.string) {\n      if (f.labels) {\n        baseLabels = f.labels;\n      }\n      break;\n    }\n  }\n\n  const labelsField = data.fields[0];\n  const tsField = data.fields[1];\n  const lineField = data.fields[2];\n  const idField = data.fields[3];\n  const tsNsField = data.fields[4];\n\n  // We are comparing used ids only within the received stream. This could be a problem if the same line + labels + nanosecond timestamp came in 2 separate batches.\n  // As this is very unlikely, and the result would only affect live-tailing css animation we have decided to not compare all received uids from data param as this would slow down processing.\n  const usedUids: { string?: number } = {};\n\n  for (const stream of streams) {\n    // Find unique labels\n    const unique = findUniqueLabels(stream.stream, baseLabels);\n    const allLabelsString = Object.entries(stream.stream)\n      .map(([key, val]) => `${key}=\"${val}\"`)\n      .sort()\n      .join('');\n\n    // Add each line\n    for (const [ts, line] of stream.values) {\n      tsField.values.add(new Date(parseInt(ts.slice(0, -6), 10)).toISOString());\n      tsNsField.values.add(ts);\n      lineField.values.add(line);\n      labelsField.values.add(unique);\n      idField.values.add(createUid(ts, allLabelsString, line, usedUids, data.refId));\n    }\n  }\n}\n\nfunction createUid(ts: string, labelsString: string, line: string, usedUids: any, refId?: string): string {\n  // Generate id as hashed nanosecond timestamp, labels and line (this does not have to be unique)\n  let id = uuidv5(`${ts}_${labelsString}_${line}`, UUID_NAMESPACE);\n\n  // Check if generated id is unique\n  // If not and we've already used it, append it's count after it\n  if (id in usedUids) {\n    // Increase the count\n    const newCount = usedUids[id] + 1;\n    usedUids[id] = newCount;\n    // Append count to generated id to make it unique\n    id = `${id}_${newCount}`;\n  } else {\n    // If id is unique and wasn't used, add it to usedUids and start count at 0\n    usedUids[id] = 0;\n  }\n  // Return unique id\n  if (refId) {\n    return `${id}_${refId}`;\n  }\n  return id;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}