{"ast":null,"code":"/**\n * Normalize the value format to SelectableValue[] | []. Only used for single select\n */\nexport const cleanValue = (value, options) => {\n  if (Array.isArray(value)) {\n    const filtered = value.filter(Boolean);\n    return filtered !== null && filtered !== void 0 && filtered.length ? filtered : undefined;\n  }\n\n  if (typeof value === 'object') {\n    // we want to allow null through into here, so the Select value can be unset\n    return [value];\n  }\n\n  if (typeof value === 'string' || typeof value === 'number') {\n    const selectedValue = findSelectedValue(value, options);\n\n    if (selectedValue) {\n      return [selectedValue];\n    }\n  }\n\n  return undefined;\n};\n/**\n * Find the label for a string|number value inside array of options or optgroups\n */\n\nexport const findSelectedValue = (value, options) => {\n  for (const option of options) {\n    if ('options' in option) {\n      let found = findSelectedValue(value, option.options);\n\n      if (found) {\n        return found;\n      }\n    } else if ('value' in option && option.value === value) {\n      return option;\n    }\n  }\n\n  return null;\n};","map":{"version":3,"names":["cleanValue","value","options","Array","isArray","filtered","filter","Boolean","length","undefined","selectedValue","findSelectedValue","option","found"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/Select/utils.ts"],"sourcesContent":["import { SelectableValue } from '@grafana/data';\n\nimport { SelectableOptGroup } from './types';\n\n/**\n * Normalize the value format to SelectableValue[] | []. Only used for single select\n */\nexport const cleanValue = (value: any, options: Array<SelectableValue | SelectableOptGroup | SelectableOptGroup[]>) => {\n  if (Array.isArray(value)) {\n    const filtered = value.filter(Boolean);\n    return filtered?.length ? filtered : undefined;\n  }\n  if (typeof value === 'object') {\n    // we want to allow null through into here, so the Select value can be unset\n    return [value];\n  }\n  if (typeof value === 'string' || typeof value === 'number') {\n    const selectedValue = findSelectedValue(value, options);\n    if (selectedValue) {\n      return [selectedValue];\n    }\n  }\n  return undefined;\n};\n\n/**\n * Find the label for a string|number value inside array of options or optgroups\n */\nexport const findSelectedValue = (\n  value: string | number,\n  options: Array<SelectableValue | SelectableOptGroup | SelectableOptGroup[]>\n): SelectableValue | null => {\n  for (const option of options) {\n    if ('options' in option) {\n      let found = findSelectedValue(value, option.options);\n      if (found) {\n        return found;\n      }\n    } else if ('value' in option && option.value === value) {\n      return option;\n    }\n  }\n\n  return null;\n};\n"],"mappings":"AAIA;AACA;AACA;AACA,OAAO,MAAMA,UAAU,GAAG,CAACC,KAAD,EAAaC,OAAb,KAA6F;EACrH,IAAIC,KAAK,CAACC,OAAN,CAAcH,KAAd,CAAJ,EAA0B;IACxB,MAAMI,QAAQ,GAAGJ,KAAK,CAACK,MAAN,CAAaC,OAAb,CAAjB;IACA,OAAOF,QAAQ,SAAR,IAAAA,QAAQ,WAAR,IAAAA,QAAQ,CAAEG,MAAV,GAAmBH,QAAnB,GAA8BI,SAArC;EACD;;EACD,IAAI,OAAOR,KAAP,KAAiB,QAArB,EAA+B;IAC7B;IACA,OAAO,CAACA,KAAD,CAAP;EACD;;EACD,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,QAAlD,EAA4D;IAC1D,MAAMS,aAAa,GAAGC,iBAAiB,CAACV,KAAD,EAAQC,OAAR,CAAvC;;IACA,IAAIQ,aAAJ,EAAmB;MACjB,OAAO,CAACA,aAAD,CAAP;IACD;EACF;;EACD,OAAOD,SAAP;AACD,CAhBM;AAkBP;AACA;AACA;;AACA,OAAO,MAAME,iBAAiB,GAAG,CAC/BV,KAD+B,EAE/BC,OAF+B,KAGJ;EAC3B,KAAK,MAAMU,MAAX,IAAqBV,OAArB,EAA8B;IAC5B,IAAI,aAAaU,MAAjB,EAAyB;MACvB,IAAIC,KAAK,GAAGF,iBAAiB,CAACV,KAAD,EAAQW,MAAM,CAACV,OAAf,CAA7B;;MACA,IAAIW,KAAJ,EAAW;QACT,OAAOA,KAAP;MACD;IACF,CALD,MAKO,IAAI,WAAWD,MAAX,IAAqBA,MAAM,CAACX,KAAP,KAAiBA,KAA1C,EAAiD;MACtD,OAAOW,MAAP;IACD;EACF;;EAED,OAAO,IAAP;AACD,CAhBM"},"metadata":{},"sourceType":"module"}