{"ast":null,"code":"import { omit } from 'lodash';\nimport { dateTimeFormat, urlUtil } from '@grafana/data';\nimport { serializeStateToUrlParam } from '@grafana/data/src/utils/url';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { notifyApp } from 'app/core/actions';\nimport { createErrorNotification, createSuccessNotification, createWarningNotification } from 'app/core/copy/appNotification';\nimport { dispatch } from 'app/store/store';\nimport RichHistoryLocalStorage from '../history/RichHistoryLocalStorage';\nimport RichHistoryRemoteStorage from '../history/RichHistoryRemoteStorage';\nimport { RichHistoryServiceError, RichHistoryStorageWarning } from '../history/RichHistoryStorage';\nimport { getRichHistoryStorage } from '../history/richHistoryStorageProvider';\nimport { RichHistorySearchFilters, RichHistorySettings, SortOrder } from './richHistoryTypes';\nexport { RichHistorySearchFilters, RichHistorySettings, SortOrder };\n/*\n * Add queries to rich history. Save only queries within the retention period, or that are starred.\n * Side-effect: store history in local storage\n */\n\nexport async function addToRichHistory(datasourceUid, datasourceName, queries, starred, comment, showQuotaExceededError, showLimitExceededWarning) {\n  /* Save only queries, that are not falsy (e.g. empty object, null, ...) */\n  const newQueriesToSave = queries && queries.filter(query => notEmptyQuery(query));\n\n  if (newQueriesToSave.length > 0) {\n    let richHistoryStorageFull = false;\n    let limitExceeded = false;\n    let warning;\n\n    try {\n      const result = await getRichHistoryStorage().addToRichHistory({\n        datasourceUid: datasourceUid,\n        datasourceName: datasourceName !== null && datasourceName !== void 0 ? datasourceName : '',\n        queries: newQueriesToSave,\n        starred,\n        comment: comment !== null && comment !== void 0 ? comment : ''\n      });\n      warning = result.warning;\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.name === RichHistoryServiceError.StorageFull) {\n          richHistoryStorageFull = true;\n          showQuotaExceededError && dispatch(notifyApp(createErrorNotification(error.message)));\n        } else if (error.name !== RichHistoryServiceError.DuplicatedEntry) {\n          dispatch(notifyApp(createErrorNotification('Rich History update failed', error.message)));\n        }\n      } // Saving failed. Do not add new entry.\n\n\n      return {\n        richHistoryStorageFull,\n        limitExceeded\n      };\n    } // Limit exceeded but new entry was added. Notify that old entries have been removed.\n\n\n    if (warning && warning.type === RichHistoryStorageWarning.LimitExceeded) {\n      limitExceeded = true;\n      showLimitExceededWarning && dispatch(notifyApp(createWarningNotification(warning.message)));\n    }\n\n    return {\n      richHistoryStorageFull,\n      limitExceeded\n    };\n  } // Nothing to change\n\n\n  return {};\n}\nexport async function getRichHistory(filters) {\n  return await getRichHistoryStorage().getRichHistory(filters);\n}\nexport async function updateRichHistorySettings(settings) {\n  await getRichHistoryStorage().updateSettings(settings);\n}\nexport async function getRichHistorySettings() {\n  return await getRichHistoryStorage().getSettings();\n}\nexport async function deleteAllFromRichHistory() {\n  return getRichHistoryStorage().deleteAll();\n}\nexport async function updateStarredInRichHistory(id, starred) {\n  try {\n    return await getRichHistoryStorage().updateStarred(id, starred);\n  } catch (error) {\n    if (error instanceof Error) {\n      dispatch(notifyApp(createErrorNotification('Saving rich history failed', error.message)));\n    }\n\n    return undefined;\n  }\n}\nexport async function updateCommentInRichHistory(id, newComment) {\n  try {\n    return await getRichHistoryStorage().updateComment(id, newComment);\n  } catch (error) {\n    if (error instanceof Error) {\n      dispatch(notifyApp(createErrorNotification('Saving rich history failed', error.message)));\n    }\n\n    return undefined;\n  }\n}\nexport async function deleteQueryInRichHistory(id) {\n  try {\n    await getRichHistoryStorage().deleteRichHistory(id);\n    return id;\n  } catch (error) {\n    if (error instanceof Error) {\n      dispatch(notifyApp(createErrorNotification('Saving rich history failed', error.message)));\n    }\n\n    return undefined;\n  }\n}\nexport let LocalStorageMigrationStatus;\n\n(function (LocalStorageMigrationStatus) {\n  LocalStorageMigrationStatus[\"Successful\"] = \"successful\";\n  LocalStorageMigrationStatus[\"Failed\"] = \"failed\";\n  LocalStorageMigrationStatus[\"NotNeeded\"] = \"not-needed\";\n})(LocalStorageMigrationStatus || (LocalStorageMigrationStatus = {}));\n\nexport async function migrateQueryHistoryFromLocalStorage() {\n  const richHistoryLocalStorage = new RichHistoryLocalStorage();\n  const richHistoryRemoteStorage = new RichHistoryRemoteStorage();\n\n  try {\n    const {\n      richHistory\n    } = await richHistoryLocalStorage.getRichHistory({\n      datasourceFilters: [],\n      from: 0,\n      search: '',\n      sortOrder: SortOrder.Descending,\n      starred: false,\n      to: 14\n    });\n\n    if (richHistory.length === 0) {\n      return {\n        status: LocalStorageMigrationStatus.NotNeeded\n      };\n    }\n\n    await richHistoryRemoteStorage.migrate(richHistory);\n    dispatch(notifyApp(createSuccessNotification('Query history successfully migrated from local storage')));\n    return {\n      status: LocalStorageMigrationStatus.Successful\n    };\n  } catch (error) {\n    const errorToThrow = error instanceof Error ? error : new Error('Uknown error occurred.');\n    dispatch(notifyApp(createWarningNotification(`Query history migration failed. ${errorToThrow.message}`)));\n    return {\n      status: LocalStorageMigrationStatus.Failed,\n      error: errorToThrow\n    };\n  }\n}\nexport const createUrlFromRichHistory = query => {\n  const exploreState = {\n    /* Default range, as we are not saving timerange in rich history */\n    range: {\n      from: 'now-1h',\n      to: 'now'\n    },\n    datasource: query.datasourceName,\n    queries: query.queries,\n    context: 'explore'\n  };\n  const serializedState = serializeStateToUrlParam(exploreState);\n  const baseUrl = /.*(?=\\/explore)/.exec(`${window.location.href}`)[0];\n  const url = urlUtil.renderUrl(`${baseUrl}/explore`, {\n    left: serializedState\n  });\n  return url;\n};\n/* Needed for slider in Rich history to map numerical values to meaningful strings */\n\nexport const mapNumbertoTimeInSlider = num => {\n  let str;\n\n  switch (num) {\n    case 0:\n      str = 'today';\n      break;\n\n    case 1:\n      str = 'yesterday';\n      break;\n\n    case 7:\n      str = 'a week ago';\n      break;\n\n    case 14:\n      str = 'two weeks ago';\n      break;\n\n    default:\n      str = `${num} days ago`;\n  }\n\n  return str;\n};\nexport function createDateStringFromTs(ts) {\n  return dateTimeFormat(ts, {\n    format: 'MMMM D'\n  });\n}\nexport function getQueryDisplayText(query) {\n  /* If datasource doesn't have getQueryDisplayText, create query display text by\n   * stringifying query that was stripped of key, refId and datasource for nicer\n   * formatting and improved readability\n   */\n  const strippedQuery = omit(query, ['key', 'refId', 'datasource']);\n  return JSON.stringify(strippedQuery);\n}\nexport function createQueryHeading(query, sortOrder) {\n  let heading = '';\n\n  if (sortOrder === SortOrder.DatasourceAZ || sortOrder === SortOrder.DatasourceZA) {\n    heading = query.datasourceName;\n  } else {\n    heading = createDateStringFromTs(query.createdAt);\n  }\n\n  return heading;\n}\nexport function createQueryText(query, queryDsInstance) {\n  /* query DatasourceInstance is necessary because we use its getQueryDisplayText method\n   * to format query text\n   */\n  if (queryDsInstance !== null && queryDsInstance !== void 0 && queryDsInstance.getQueryDisplayText) {\n    return queryDsInstance.getQueryDisplayText(query);\n  }\n\n  return getQueryDisplayText(query);\n}\nexport function mapQueriesToHeadings(query, sortOrder) {\n  let mappedQueriesToHeadings = {};\n  query.forEach(q => {\n    let heading = createQueryHeading(q, sortOrder);\n\n    if (!(heading in mappedQueriesToHeadings)) {\n      mappedQueriesToHeadings[heading] = [q];\n    } else {\n      mappedQueriesToHeadings[heading] = [...mappedQueriesToHeadings[heading], q];\n    }\n  });\n  return mappedQueriesToHeadings;\n}\n/*\n * Create a list of all available data sources\n */\n\nexport function createDatasourcesList() {\n  return getDataSourceSrv().getList().map(dsSettings => {\n    return {\n      name: dsSettings.name,\n      uid: dsSettings.uid,\n      imgUrl: dsSettings.meta.info.logos.small\n    };\n  });\n}\nexport function notEmptyQuery(query) {\n  /* Check if query has any other properties besides key, refId and datasource.\n   * If not, then we consider it empty query.\n   */\n  const strippedQuery = omit(query, ['key', 'refId', 'datasource']);\n  const queryKeys = Object.keys(strippedQuery);\n\n  if (queryKeys.length > 0) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"names":["omit","dateTimeFormat","urlUtil","serializeStateToUrlParam","getDataSourceSrv","notifyApp","createErrorNotification","createSuccessNotification","createWarningNotification","dispatch","RichHistoryLocalStorage","RichHistoryRemoteStorage","RichHistoryServiceError","RichHistoryStorageWarning","getRichHistoryStorage","RichHistorySearchFilters","RichHistorySettings","SortOrder","addToRichHistory","datasourceUid","datasourceName","queries","starred","comment","showQuotaExceededError","showLimitExceededWarning","newQueriesToSave","filter","query","notEmptyQuery","length","richHistoryStorageFull","limitExceeded","warning","result","error","Error","name","StorageFull","message","DuplicatedEntry","type","LimitExceeded","getRichHistory","filters","updateRichHistorySettings","settings","updateSettings","getRichHistorySettings","getSettings","deleteAllFromRichHistory","deleteAll","updateStarredInRichHistory","id","updateStarred","undefined","updateCommentInRichHistory","newComment","updateComment","deleteQueryInRichHistory","deleteRichHistory","LocalStorageMigrationStatus","migrateQueryHistoryFromLocalStorage","richHistoryLocalStorage","richHistoryRemoteStorage","richHistory","datasourceFilters","from","search","sortOrder","Descending","to","status","NotNeeded","migrate","Successful","errorToThrow","Failed","createUrlFromRichHistory","exploreState","range","datasource","context","serializedState","baseUrl","exec","window","location","href","url","renderUrl","left","mapNumbertoTimeInSlider","num","str","createDateStringFromTs","ts","format","getQueryDisplayText","strippedQuery","JSON","stringify","createQueryHeading","heading","DatasourceAZ","DatasourceZA","createdAt","createQueryText","queryDsInstance","mapQueriesToHeadings","mappedQueriesToHeadings","forEach","q","createDatasourcesList","getList","map","dsSettings","uid","imgUrl","meta","info","logos","small","queryKeys","Object","keys"],"sources":["/home/soula/grafana/public/app/core/utils/richHistory.ts"],"sourcesContent":["import { omit } from 'lodash';\n\nimport { DataQuery, DataSourceApi, dateTimeFormat, ExploreUrlState, urlUtil } from '@grafana/data';\nimport { serializeStateToUrlParam } from '@grafana/data/src/utils/url';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { notifyApp } from 'app/core/actions';\nimport {\n  createErrorNotification,\n  createSuccessNotification,\n  createWarningNotification,\n} from 'app/core/copy/appNotification';\nimport { dispatch } from 'app/store/store';\nimport { RichHistoryQuery } from 'app/types/explore';\n\nimport RichHistoryLocalStorage from '../history/RichHistoryLocalStorage';\nimport RichHistoryRemoteStorage from '../history/RichHistoryRemoteStorage';\nimport {\n  RichHistoryResults,\n  RichHistoryServiceError,\n  RichHistoryStorageWarning,\n  RichHistoryStorageWarningDetails,\n} from '../history/RichHistoryStorage';\nimport { getRichHistoryStorage } from '../history/richHistoryStorageProvider';\n\nimport { RichHistorySearchFilters, RichHistorySettings, SortOrder } from './richHistoryTypes';\n\nexport { RichHistorySearchFilters, RichHistorySettings, SortOrder };\n\n/*\n * Add queries to rich history. Save only queries within the retention period, or that are starred.\n * Side-effect: store history in local storage\n */\n\nexport async function addToRichHistory(\n  datasourceUid: string,\n  datasourceName: string | null,\n  queries: DataQuery[],\n  starred: boolean,\n  comment: string | null,\n  showQuotaExceededError: boolean,\n  showLimitExceededWarning: boolean\n): Promise<{ richHistoryStorageFull?: boolean; limitExceeded?: boolean }> {\n  /* Save only queries, that are not falsy (e.g. empty object, null, ...) */\n  const newQueriesToSave: DataQuery[] = queries && queries.filter((query) => notEmptyQuery(query));\n\n  if (newQueriesToSave.length > 0) {\n    let richHistoryStorageFull = false;\n    let limitExceeded = false;\n    let warning: RichHistoryStorageWarningDetails | undefined;\n\n    try {\n      const result = await getRichHistoryStorage().addToRichHistory({\n        datasourceUid: datasourceUid,\n        datasourceName: datasourceName ?? '',\n        queries: newQueriesToSave,\n        starred,\n        comment: comment ?? '',\n      });\n      warning = result.warning;\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.name === RichHistoryServiceError.StorageFull) {\n          richHistoryStorageFull = true;\n          showQuotaExceededError && dispatch(notifyApp(createErrorNotification(error.message)));\n        } else if (error.name !== RichHistoryServiceError.DuplicatedEntry) {\n          dispatch(notifyApp(createErrorNotification('Rich History update failed', error.message)));\n        }\n      }\n      // Saving failed. Do not add new entry.\n      return { richHistoryStorageFull, limitExceeded };\n    }\n\n    // Limit exceeded but new entry was added. Notify that old entries have been removed.\n    if (warning && warning.type === RichHistoryStorageWarning.LimitExceeded) {\n      limitExceeded = true;\n      showLimitExceededWarning && dispatch(notifyApp(createWarningNotification(warning.message)));\n    }\n\n    return { richHistoryStorageFull, limitExceeded };\n  }\n\n  // Nothing to change\n  return {};\n}\n\nexport async function getRichHistory(filters: RichHistorySearchFilters): Promise<RichHistoryResults> {\n  return await getRichHistoryStorage().getRichHistory(filters);\n}\n\nexport async function updateRichHistorySettings(settings: RichHistorySettings): Promise<void> {\n  await getRichHistoryStorage().updateSettings(settings);\n}\n\nexport async function getRichHistorySettings(): Promise<RichHistorySettings> {\n  return await getRichHistoryStorage().getSettings();\n}\n\nexport async function deleteAllFromRichHistory(): Promise<void> {\n  return getRichHistoryStorage().deleteAll();\n}\n\nexport async function updateStarredInRichHistory(id: string, starred: boolean) {\n  try {\n    return await getRichHistoryStorage().updateStarred(id, starred);\n  } catch (error) {\n    if (error instanceof Error) {\n      dispatch(notifyApp(createErrorNotification('Saving rich history failed', error.message)));\n    }\n    return undefined;\n  }\n}\n\nexport async function updateCommentInRichHistory(id: string, newComment: string | undefined) {\n  try {\n    return await getRichHistoryStorage().updateComment(id, newComment);\n  } catch (error) {\n    if (error instanceof Error) {\n      dispatch(notifyApp(createErrorNotification('Saving rich history failed', error.message)));\n    }\n    return undefined;\n  }\n}\n\nexport async function deleteQueryInRichHistory(id: string) {\n  try {\n    await getRichHistoryStorage().deleteRichHistory(id);\n    return id;\n  } catch (error) {\n    if (error instanceof Error) {\n      dispatch(notifyApp(createErrorNotification('Saving rich history failed', error.message)));\n    }\n    return undefined;\n  }\n}\n\nexport enum LocalStorageMigrationStatus {\n  Successful = 'successful',\n  Failed = 'failed',\n  NotNeeded = 'not-needed',\n}\n\nexport interface LocalStorageMigrationResult {\n  status: LocalStorageMigrationStatus;\n  error?: Error;\n}\n\nexport async function migrateQueryHistoryFromLocalStorage(): Promise<LocalStorageMigrationResult> {\n  const richHistoryLocalStorage = new RichHistoryLocalStorage();\n  const richHistoryRemoteStorage = new RichHistoryRemoteStorage();\n\n  try {\n    const { richHistory } = await richHistoryLocalStorage.getRichHistory({\n      datasourceFilters: [],\n      from: 0,\n      search: '',\n      sortOrder: SortOrder.Descending,\n      starred: false,\n      to: 14,\n    });\n    if (richHistory.length === 0) {\n      return { status: LocalStorageMigrationStatus.NotNeeded };\n    }\n    await richHistoryRemoteStorage.migrate(richHistory);\n    dispatch(notifyApp(createSuccessNotification('Query history successfully migrated from local storage')));\n    return { status: LocalStorageMigrationStatus.Successful };\n  } catch (error) {\n    const errorToThrow = error instanceof Error ? error : new Error('Uknown error occurred.');\n    dispatch(notifyApp(createWarningNotification(`Query history migration failed. ${errorToThrow.message}`)));\n    return { status: LocalStorageMigrationStatus.Failed, error: errorToThrow };\n  }\n}\n\nexport const createUrlFromRichHistory = (query: RichHistoryQuery) => {\n  const exploreState: ExploreUrlState = {\n    /* Default range, as we are not saving timerange in rich history */\n    range: { from: 'now-1h', to: 'now' },\n    datasource: query.datasourceName,\n    queries: query.queries,\n    context: 'explore',\n  };\n\n  const serializedState = serializeStateToUrlParam(exploreState);\n  const baseUrl = /.*(?=\\/explore)/.exec(`${window.location.href}`)![0];\n  const url = urlUtil.renderUrl(`${baseUrl}/explore`, { left: serializedState });\n  return url;\n};\n\n/* Needed for slider in Rich history to map numerical values to meaningful strings */\nexport const mapNumbertoTimeInSlider = (num: number) => {\n  let str;\n  switch (num) {\n    case 0:\n      str = 'today';\n      break;\n    case 1:\n      str = 'yesterday';\n      break;\n    case 7:\n      str = 'a week ago';\n      break;\n    case 14:\n      str = 'two weeks ago';\n      break;\n    default:\n      str = `${num} days ago`;\n  }\n\n  return str;\n};\n\nexport function createDateStringFromTs(ts: number) {\n  return dateTimeFormat(ts, {\n    format: 'MMMM D',\n  });\n}\n\nexport function getQueryDisplayText(query: DataQuery): string {\n  /* If datasource doesn't have getQueryDisplayText, create query display text by\n   * stringifying query that was stripped of key, refId and datasource for nicer\n   * formatting and improved readability\n   */\n  const strippedQuery = omit(query, ['key', 'refId', 'datasource']);\n  return JSON.stringify(strippedQuery);\n}\n\nexport function createQueryHeading(query: RichHistoryQuery, sortOrder: SortOrder) {\n  let heading = '';\n  if (sortOrder === SortOrder.DatasourceAZ || sortOrder === SortOrder.DatasourceZA) {\n    heading = query.datasourceName;\n  } else {\n    heading = createDateStringFromTs(query.createdAt);\n  }\n  return heading;\n}\n\nexport function createQueryText(query: DataQuery, queryDsInstance: DataSourceApi | undefined) {\n  /* query DatasourceInstance is necessary because we use its getQueryDisplayText method\n   * to format query text\n   */\n  if (queryDsInstance?.getQueryDisplayText) {\n    return queryDsInstance.getQueryDisplayText(query);\n  }\n\n  return getQueryDisplayText(query);\n}\n\nexport function mapQueriesToHeadings(query: RichHistoryQuery[], sortOrder: SortOrder) {\n  let mappedQueriesToHeadings: any = {};\n\n  query.forEach((q) => {\n    let heading = createQueryHeading(q, sortOrder);\n    if (!(heading in mappedQueriesToHeadings)) {\n      mappedQueriesToHeadings[heading] = [q];\n    } else {\n      mappedQueriesToHeadings[heading] = [...mappedQueriesToHeadings[heading], q];\n    }\n  });\n\n  return mappedQueriesToHeadings;\n}\n\n/*\n * Create a list of all available data sources\n */\nexport function createDatasourcesList() {\n  return getDataSourceSrv()\n    .getList()\n    .map((dsSettings) => {\n      return {\n        name: dsSettings.name,\n        uid: dsSettings.uid,\n        imgUrl: dsSettings.meta.info.logos.small,\n      };\n    });\n}\n\nexport function notEmptyQuery(query: DataQuery) {\n  /* Check if query has any other properties besides key, refId and datasource.\n   * If not, then we consider it empty query.\n   */\n  const strippedQuery = omit(query, ['key', 'refId', 'datasource']);\n  const queryKeys = Object.keys(strippedQuery);\n\n  if (queryKeys.length > 0) {\n    return true;\n  }\n\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}