{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { from, map, of, switchMap } from 'rxjs';\nimport { toLiveChannelId } from '@grafana/data';\nimport { toDataQueryResponse } from '@grafana/runtime';\nimport { standardStreamOptionsProvider, toStreamingDataResponse } from '@grafana/runtime/src/utils/DataSourceWithBackend';\nimport { StreamingDataFrame } from './data/StreamingDataFrame';\nimport { isStreamingResponseData, StreamingResponseDataType } from './data/utils';\nexport class GrafanaLiveService {\n  constructor(deps) {\n    _defineProperty(this, \"getConnectionState\", () => {\n      return this.deps.centrifugeSrv.getConnectionState();\n    });\n\n    _defineProperty(this, \"getDataStream\", options => {\n      let buffer;\n\n      const updateBuffer = next => {\n        const data = next.data[0];\n\n        if (!buffer && !isStreamingResponseData(data, StreamingResponseDataType.FullFrame)) {\n          console.warn(`expected first packet to contain a full frame, received ${data === null || data === void 0 ? void 0 : data.type}`);\n          return;\n        }\n\n        switch (data.type) {\n          case StreamingResponseDataType.FullFrame:\n            {\n              buffer = StreamingDataFrame.deserialize(data.frame);\n              return;\n            }\n\n          case StreamingResponseDataType.NewValuesSameSchema:\n            {\n              buffer.pushNewValues(data.values);\n              return;\n            }\n        }\n      };\n\n      return this.deps.centrifugeSrv.getDataStream(options).pipe(map(next => {\n        var _buffer;\n\n        updateBuffer(next);\n        return Object.assign({}, next, {\n          data: [(_buffer = buffer) !== null && _buffer !== void 0 ? _buffer : StreamingDataFrame.empty()]\n        });\n      }));\n    });\n\n    _defineProperty(this, \"getStream\", address => {\n      return this.deps.centrifugeSrv.getStream(address);\n    });\n\n    _defineProperty(this, \"getQueryData\", options => {\n      return from(this.deps.centrifugeSrv.getQueryData(options)).pipe(switchMap(rawResponse => {\n        var _parsedResponse$data;\n\n        const parsedResponse = toDataQueryResponse(rawResponse, options.request.targets);\n        const isSubscribable = ((_parsedResponse$data = parsedResponse.data) === null || _parsedResponse$data === void 0 ? void 0 : _parsedResponse$data.length) && parsedResponse.data.find(f => {\n          var _f$meta;\n\n          return (_f$meta = f.meta) === null || _f$meta === void 0 ? void 0 : _f$meta.channel;\n        });\n        return isSubscribable ? toStreamingDataResponse(parsedResponse, options.request, standardStreamOptionsProvider) : of(parsedResponse);\n      }));\n    });\n\n    _defineProperty(this, \"publish\", async (address, data) => {\n      return this.deps.backendSrv.post(`api/live/publish`, {\n        channel: toLiveChannelId(address),\n        // orgId is from user\n        data\n      });\n    });\n\n    _defineProperty(this, \"getPresence\", address => {\n      return this.deps.centrifugeSrv.getPresence(address);\n    });\n\n    this.deps = deps;\n  }\n  /**\n   * Listen for changes to the connection state\n   */\n\n\n}","map":{"version":3,"names":["from","map","of","switchMap","toLiveChannelId","toDataQueryResponse","standardStreamOptionsProvider","toStreamingDataResponse","StreamingDataFrame","isStreamingResponseData","StreamingResponseDataType","GrafanaLiveService","constructor","deps","centrifugeSrv","getConnectionState","options","buffer","updateBuffer","next","data","FullFrame","console","warn","type","deserialize","frame","NewValuesSameSchema","pushNewValues","values","getDataStream","pipe","empty","address","getStream","getQueryData","rawResponse","parsedResponse","request","targets","isSubscribable","length","find","f","meta","channel","backendSrv","post","getPresence"],"sources":["/home/soula/grafana/public/app/features/live/live.ts"],"sourcesContent":["import { from, map, of, switchMap } from 'rxjs';\n\nimport { DataFrame, toLiveChannelId } from '@grafana/data';\nimport { BackendSrv, GrafanaLiveSrv, toDataQueryResponse } from '@grafana/runtime';\nimport {\n  standardStreamOptionsProvider,\n  toStreamingDataResponse,\n} from '@grafana/runtime/src/utils/DataSourceWithBackend';\n\nimport { CentrifugeSrv, StreamingDataQueryResponse } from './centrifuge/service';\nimport { StreamingDataFrame } from './data/StreamingDataFrame';\nimport { isStreamingResponseData, StreamingResponseDataType } from './data/utils';\n\ntype GrafanaLiveServiceDeps = {\n  centrifugeSrv: CentrifugeSrv;\n  backendSrv: BackendSrv;\n};\n\nexport class GrafanaLiveService implements GrafanaLiveSrv {\n  constructor(private deps: GrafanaLiveServiceDeps) {}\n\n  /**\n   * Listen for changes to the connection state\n   */\n  getConnectionState = () => {\n    return this.deps.centrifugeSrv.getConnectionState();\n  };\n\n  /**\n   * Connect to a channel and return results as DataFrames\n   */\n  getDataStream: GrafanaLiveSrv['getDataStream'] = (options) => {\n    let buffer: StreamingDataFrame;\n\n    const updateBuffer = (next: StreamingDataQueryResponse): void => {\n      const data = next.data[0];\n      if (!buffer && !isStreamingResponseData(data, StreamingResponseDataType.FullFrame)) {\n        console.warn(`expected first packet to contain a full frame, received ${data?.type}`);\n        return;\n      }\n\n      switch (data.type) {\n        case StreamingResponseDataType.FullFrame: {\n          buffer = StreamingDataFrame.deserialize(data.frame);\n          return;\n        }\n        case StreamingResponseDataType.NewValuesSameSchema: {\n          buffer.pushNewValues(data.values);\n          return;\n        }\n      }\n    };\n\n    return this.deps.centrifugeSrv.getDataStream(options).pipe(\n      map((next) => {\n        updateBuffer(next);\n        return {\n          ...next,\n          data: [buffer ?? StreamingDataFrame.empty()],\n        };\n      })\n    );\n  };\n\n  /**\n   * Watch for messages in a channel\n   */\n  getStream: GrafanaLiveSrv['getStream'] = (address) => {\n    return this.deps.centrifugeSrv.getStream(address);\n  };\n\n  /**\n   * Execute a query over the live websocket and potentially subscribe to a live channel.\n   *\n   * Since the initial request and subscription are on the same socket, this will support HA setups\n   */\n  getQueryData: GrafanaLiveSrv['getQueryData'] = (options) => {\n    return from(this.deps.centrifugeSrv.getQueryData(options)).pipe(\n      switchMap((rawResponse) => {\n        const parsedResponse = toDataQueryResponse(rawResponse, options.request.targets);\n\n        const isSubscribable =\n          parsedResponse.data?.length && parsedResponse.data.find((f: DataFrame) => f.meta?.channel);\n\n        return isSubscribable\n          ? toStreamingDataResponse(parsedResponse, options.request, standardStreamOptionsProvider)\n          : of(parsedResponse);\n      })\n    );\n  };\n\n  /**\n   * Publish into a channel\n   *\n   * @alpha -- experimental\n   */\n  publish: GrafanaLiveSrv['publish'] = async (address, data) => {\n    return this.deps.backendSrv.post(`api/live/publish`, {\n      channel: toLiveChannelId(address), // orgId is from user\n      data,\n    });\n  };\n\n  /**\n   * For channels that support presence, this will request the current state from the server.\n   *\n   * Join and leave messages will be sent to the open stream\n   */\n  getPresence: GrafanaLiveSrv['getPresence'] = (address) => {\n    return this.deps.centrifugeSrv.getPresence(address);\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}