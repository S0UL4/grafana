{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexport class Edge {\n  constructor() {\n    _defineProperty(this, \"inputNode\", void 0);\n\n    _defineProperty(this, \"outputNode\", void 0);\n  }\n\n  _linkTo(node, direction) {\n    if (direction <= 0) {\n      node.inputEdges.push(this);\n    }\n\n    if (direction >= 0) {\n      node.outputEdges.push(this);\n    }\n\n    node.edges.push(this);\n  }\n\n  link(inputNode, outputNode) {\n    if (!inputNode) {\n      throw Error('inputNode is required');\n    }\n\n    if (!outputNode) {\n      throw Error('outputNode is required');\n    }\n\n    this.unlink();\n    this.inputNode = inputNode;\n    this.outputNode = outputNode;\n\n    this._linkTo(inputNode, 1);\n\n    this._linkTo(outputNode, -1);\n\n    return this;\n  }\n\n  unlink() {\n    let pos;\n    const inode = this.inputNode;\n    const onode = this.outputNode;\n\n    if (!(inode && onode)) {\n      return;\n    }\n\n    pos = inode.edges.indexOf(this);\n\n    if (pos > -1) {\n      inode.edges.splice(pos, 1);\n    }\n\n    pos = onode.edges.indexOf(this);\n\n    if (pos > -1) {\n      onode.edges.splice(pos, 1);\n    }\n\n    pos = inode.outputEdges.indexOf(this);\n\n    if (pos > -1) {\n      inode.outputEdges.splice(pos, 1);\n    }\n\n    pos = onode.inputEdges.indexOf(this);\n\n    if (pos > -1) {\n      onode.inputEdges.splice(pos, 1);\n    }\n  }\n\n}\nexport class Node {\n  constructor(name) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"edges\", void 0);\n\n    _defineProperty(this, \"inputEdges\", void 0);\n\n    _defineProperty(this, \"outputEdges\", void 0);\n\n    this.name = name;\n    this.edges = [];\n    this.inputEdges = [];\n    this.outputEdges = [];\n  }\n\n  getEdgeFrom(from) {\n    if (!from) {\n      return null;\n    }\n\n    if (typeof from === 'object') {\n      return this.inputEdges.find(e => {\n        var _e$inputNode;\n\n        return ((_e$inputNode = e.inputNode) === null || _e$inputNode === void 0 ? void 0 : _e$inputNode.name) === from.name;\n      });\n    }\n\n    return this.inputEdges.find(e => {\n      var _e$inputNode2;\n\n      return ((_e$inputNode2 = e.inputNode) === null || _e$inputNode2 === void 0 ? void 0 : _e$inputNode2.name) === from;\n    });\n  }\n\n  getEdgeTo(to) {\n    if (!to) {\n      return null;\n    }\n\n    if (typeof to === 'object') {\n      return this.outputEdges.find(e => {\n        var _e$outputNode;\n\n        return ((_e$outputNode = e.outputNode) === null || _e$outputNode === void 0 ? void 0 : _e$outputNode.name) === to.name;\n      });\n    }\n\n    return this.outputEdges.find(e => {\n      var _e$outputNode2;\n\n      return ((_e$outputNode2 = e.outputNode) === null || _e$outputNode2 === void 0 ? void 0 : _e$outputNode2.name) === to;\n    });\n  }\n\n  getOptimizedInputEdges() {\n    const toBeRemoved = [];\n    this.inputEdges.forEach(e => {\n      var _e$inputNode3;\n\n      const inputEdgesNodes = (_e$inputNode3 = e.inputNode) === null || _e$inputNode3 === void 0 ? void 0 : _e$inputNode3.inputEdges.map(e => e.inputNode);\n      inputEdgesNodes === null || inputEdgesNodes === void 0 ? void 0 : inputEdgesNodes.forEach(n => {\n        const edgeToRemove = n === null || n === void 0 ? void 0 : n.getEdgeTo(this.name);\n\n        if (edgeToRemove) {\n          toBeRemoved.push(edgeToRemove);\n        }\n      });\n    });\n    return this.inputEdges.filter(e => toBeRemoved.indexOf(e) === -1);\n  }\n\n}\nexport class Graph {\n  constructor() {\n    _defineProperty(this, \"nodes\", {});\n  }\n\n  createNode(name) {\n    const n = new Node(name);\n    this.nodes[name] = n;\n    return n;\n  }\n\n  createNodes(names) {\n    const nodes = [];\n    names.forEach(name => {\n      nodes.push(this.createNode(name));\n    });\n    return nodes;\n  }\n\n  link(input, output) {\n    let inputArr = [];\n    let outputArr = [];\n    const inputNodes = [];\n    const outputNodes = [];\n\n    if (input instanceof Array) {\n      inputArr = input;\n    } else {\n      inputArr = [input];\n    }\n\n    if (output instanceof Array) {\n      outputArr = output;\n    } else {\n      outputArr = [output];\n    }\n\n    for (let n = 0; n < inputArr.length; n++) {\n      const i = inputArr[n];\n\n      if (typeof i === 'string') {\n        const n = this.getNode(i);\n\n        if (!n) {\n          throw Error(`cannot link input node named ${i} since it doesn't exist in graph`);\n        }\n\n        inputNodes.push(n);\n      } else {\n        inputNodes.push(i);\n      }\n    }\n\n    for (let n = 0; n < outputArr.length; n++) {\n      const i = outputArr[n];\n\n      if (typeof i === 'string') {\n        const n = this.getNode(i);\n\n        if (!n) {\n          throw Error(`cannot link output node named ${i} since it doesn't exist in graph`);\n        }\n\n        outputNodes.push(n);\n      } else {\n        outputNodes.push(i);\n      }\n    }\n\n    const edges = [];\n    inputNodes.forEach(input => {\n      outputNodes.forEach(output => {\n        edges.push(this.createEdge().link(input, output));\n      });\n    });\n    return edges;\n  }\n\n  createEdge() {\n    return new Edge();\n  }\n\n  getNode(name) {\n    return this.nodes[name];\n  }\n\n}\nexport const printGraph = g => {\n  Object.keys(g.nodes).forEach(name => {\n    const n = g.nodes[name];\n    let outputEdges = n.outputEdges.map(e => {\n      var _e$outputNode3;\n\n      return (_e$outputNode3 = e.outputNode) === null || _e$outputNode3 === void 0 ? void 0 : _e$outputNode3.name;\n    }).join(', ');\n\n    if (!outputEdges) {\n      outputEdges = '<none>';\n    }\n\n    let inputEdges = n.inputEdges.map(e => {\n      var _e$inputNode4;\n\n      return (_e$inputNode4 = e.inputNode) === null || _e$inputNode4 === void 0 ? void 0 : _e$inputNode4.name;\n    }).join(', ');\n\n    if (!inputEdges) {\n      inputEdges = '<none>';\n    }\n\n    console.log(`${n.name}:\\n - links to:   ${outputEdges}\\n - links from: ${inputEdges}`);\n  });\n};","map":{"version":3,"names":["Edge","_linkTo","node","direction","inputEdges","push","outputEdges","edges","link","inputNode","outputNode","Error","unlink","pos","inode","onode","indexOf","splice","Node","constructor","name","getEdgeFrom","from","find","e","getEdgeTo","to","getOptimizedInputEdges","toBeRemoved","forEach","inputEdgesNodes","map","n","edgeToRemove","filter","Graph","createNode","nodes","createNodes","names","input","output","inputArr","outputArr","inputNodes","outputNodes","Array","length","i","getNode","createEdge","printGraph","g","Object","keys","join","console","log"],"sources":["/home/soula/grafana/public/app/core/utils/dag.ts"],"sourcesContent":["export class Edge {\n  inputNode?: Node;\n  outputNode?: Node;\n\n  _linkTo(node: Node, direction: number) {\n    if (direction <= 0) {\n      node.inputEdges.push(this);\n    }\n\n    if (direction >= 0) {\n      node.outputEdges.push(this);\n    }\n\n    node.edges.push(this);\n  }\n\n  link(inputNode: Node, outputNode: Node) {\n    if (!inputNode) {\n      throw Error('inputNode is required');\n    }\n\n    if (!outputNode) {\n      throw Error('outputNode is required');\n    }\n\n    this.unlink();\n    this.inputNode = inputNode;\n    this.outputNode = outputNode;\n\n    this._linkTo(inputNode, 1);\n    this._linkTo(outputNode, -1);\n    return this;\n  }\n\n  unlink() {\n    let pos;\n    const inode = this.inputNode;\n    const onode = this.outputNode;\n\n    if (!(inode && onode)) {\n      return;\n    }\n\n    pos = inode.edges.indexOf(this);\n    if (pos > -1) {\n      inode.edges.splice(pos, 1);\n    }\n\n    pos = onode.edges.indexOf(this);\n    if (pos > -1) {\n      onode.edges.splice(pos, 1);\n    }\n\n    pos = inode.outputEdges.indexOf(this);\n    if (pos > -1) {\n      inode.outputEdges.splice(pos, 1);\n    }\n\n    pos = onode.inputEdges.indexOf(this);\n    if (pos > -1) {\n      onode.inputEdges.splice(pos, 1);\n    }\n  }\n}\n\nexport class Node {\n  name: string;\n  edges: Edge[];\n  inputEdges: Edge[];\n  outputEdges: Edge[];\n\n  constructor(name: string) {\n    this.name = name;\n    this.edges = [];\n    this.inputEdges = [];\n    this.outputEdges = [];\n  }\n\n  getEdgeFrom(from: string | Node): Edge | null | undefined {\n    if (!from) {\n      return null;\n    }\n\n    if (typeof from === 'object') {\n      return this.inputEdges.find((e) => e.inputNode?.name === from.name);\n    }\n\n    return this.inputEdges.find((e) => e.inputNode?.name === from);\n  }\n\n  getEdgeTo(to: string | Node): Edge | null | undefined {\n    if (!to) {\n      return null;\n    }\n\n    if (typeof to === 'object') {\n      return this.outputEdges.find((e) => e.outputNode?.name === to.name);\n    }\n\n    return this.outputEdges.find((e) => e.outputNode?.name === to);\n  }\n\n  getOptimizedInputEdges(): Edge[] {\n    const toBeRemoved: any[] = [];\n    this.inputEdges.forEach((e) => {\n      const inputEdgesNodes = e.inputNode?.inputEdges.map((e) => e.inputNode);\n\n      inputEdgesNodes?.forEach((n) => {\n        const edgeToRemove = n?.getEdgeTo(this.name);\n        if (edgeToRemove) {\n          toBeRemoved.push(edgeToRemove);\n        }\n      });\n    });\n\n    return this.inputEdges.filter((e) => toBeRemoved.indexOf(e) === -1);\n  }\n}\n\nexport class Graph {\n  nodes: any = {};\n\n  constructor() {}\n\n  createNode(name: string): Node {\n    const n = new Node(name);\n    this.nodes[name] = n;\n    return n;\n  }\n\n  createNodes(names: string[]): Node[] {\n    const nodes: Node[] = [];\n    names.forEach((name) => {\n      nodes.push(this.createNode(name));\n    });\n    return nodes;\n  }\n\n  link(input: string | string[] | Node | Node[], output: string | string[] | Node | Node[]): Edge[] {\n    let inputArr = [];\n    let outputArr = [];\n    const inputNodes: Node[] = [];\n    const outputNodes: Node[] = [];\n\n    if (input instanceof Array) {\n      inputArr = input;\n    } else {\n      inputArr = [input];\n    }\n\n    if (output instanceof Array) {\n      outputArr = output;\n    } else {\n      outputArr = [output];\n    }\n\n    for (let n = 0; n < inputArr.length; n++) {\n      const i = inputArr[n];\n      if (typeof i === 'string') {\n        const n = this.getNode(i);\n        if (!n) {\n          throw Error(`cannot link input node named ${i} since it doesn't exist in graph`);\n        }\n        inputNodes.push(n);\n      } else {\n        inputNodes.push(i);\n      }\n    }\n\n    for (let n = 0; n < outputArr.length; n++) {\n      const i = outputArr[n];\n      if (typeof i === 'string') {\n        const n = this.getNode(i);\n        if (!n) {\n          throw Error(`cannot link output node named ${i} since it doesn't exist in graph`);\n        }\n        outputNodes.push(n);\n      } else {\n        outputNodes.push(i);\n      }\n    }\n\n    const edges: Edge[] = [];\n    inputNodes.forEach((input) => {\n      outputNodes.forEach((output) => {\n        edges.push(this.createEdge().link(input, output));\n      });\n    });\n    return edges;\n  }\n\n  createEdge(): Edge {\n    return new Edge();\n  }\n\n  getNode(name: string): Node {\n    return this.nodes[name];\n  }\n}\n\nexport const printGraph = (g: Graph) => {\n  Object.keys(g.nodes).forEach((name) => {\n    const n = g.nodes[name];\n    let outputEdges = n.outputEdges.map((e: Edge) => e.outputNode?.name).join(', ');\n    if (!outputEdges) {\n      outputEdges = '<none>';\n    }\n    let inputEdges = n.inputEdges.map((e: Edge) => e.inputNode?.name).join(', ');\n    if (!inputEdges) {\n      inputEdges = '<none>';\n    }\n    console.log(`${n.name}:\\n - links to:   ${outputEdges}\\n - links from: ${inputEdges}`);\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}