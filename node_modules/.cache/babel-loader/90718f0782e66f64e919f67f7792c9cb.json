{"ast":null,"code":"import { parser } from 'lezer-promql';\nimport { binaryScalarOperatorToOperatorName } from './binaryScalarOperations';\nimport { ErrorName, getAllByType, getLeftMostChild, getString, makeBinOp, makeError, replaceVariables } from './shared/parsingUtils';\n\n/**\n * Parses a PromQL query into a visual query model.\n *\n * It traverses the tree and uses sort of state machine to update the query model. The query model is modified\n * during the traversal and sent to each handler as context.\n *\n * @param expr\n */\nexport function buildVisualQueryFromString(expr) {\n  const replacedExpr = replaceVariables(expr);\n  const tree = parser.parse(replacedExpr);\n  const node = tree.topNode; // This will be modified in the handlers.\n\n  const visQuery = {\n    metric: '',\n    labels: [],\n    operations: []\n  };\n  const context = {\n    query: visQuery,\n    errors: []\n  };\n\n  try {\n    handleExpression(replacedExpr, node, context);\n  } catch (err) {\n    // Not ideal to log it here, but otherwise we would lose the stack trace.\n    console.error(err);\n\n    if (err instanceof Error) {\n      context.errors.push({\n        text: err.message\n      });\n    }\n  } // If we have empty query, we want to reset errors\n\n\n  if (isEmptyQuery(context.query)) {\n    context.errors = [];\n  }\n\n  return context;\n}\n\n/**\n * Handler for default state. It will traverse the tree and call the appropriate handler for each node. The node\n * handled here does not necessarily need to be of type == Expr.\n * @param expr\n * @param node\n * @param context\n */\nexport function handleExpression(expr, node, context) {\n  const visQuery = context.query;\n\n  switch (node.name) {\n    case 'MetricIdentifier':\n      {\n        // Expectation is that there is only one of those per query.\n        visQuery.metric = getString(expr, node);\n        break;\n      }\n\n    case 'LabelMatcher':\n      {\n        // Same as MetricIdentifier should be just one per query.\n        visQuery.labels.push(getLabel(expr, node));\n        const err = node.getChild(ErrorName);\n\n        if (err) {\n          context.errors.push(makeError(expr, err));\n        }\n\n        break;\n      }\n\n    case 'FunctionCall':\n      {\n        handleFunction(expr, node, context);\n        break;\n      }\n\n    case 'AggregateExpr':\n      {\n        handleAggregation(expr, node, context);\n        break;\n      }\n\n    case 'BinaryExpr':\n      {\n        handleBinary(expr, node, context);\n        break;\n      }\n\n    case ErrorName:\n      {\n        if (isIntervalVariableError(node)) {\n          break;\n        }\n\n        context.errors.push(makeError(expr, node));\n        break;\n      }\n\n    default:\n      {\n        if (node.name === 'ParenExpr') {\n          // We don't support parenthesis in the query to group expressions. We just report error but go on with the\n          // parsing.\n          context.errors.push(makeError(expr, node));\n        } // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper\n        // nodes that can be skipped.\n        // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to\n        //  detect those and report back.\n\n\n        let child = node.firstChild;\n\n        while (child) {\n          handleExpression(expr, child, context);\n          child = child.nextSibling;\n        }\n      }\n  }\n}\n\nfunction isIntervalVariableError(node) {\n  var _node$prevSibling, _node$prevSibling2, _node$prevSibling2$fi;\n\n  return ((_node$prevSibling = node.prevSibling) === null || _node$prevSibling === void 0 ? void 0 : _node$prevSibling.name) === 'Expr' && ((_node$prevSibling2 = node.prevSibling) === null || _node$prevSibling2 === void 0 ? void 0 : (_node$prevSibling2$fi = _node$prevSibling2.firstChild) === null || _node$prevSibling2$fi === void 0 ? void 0 : _node$prevSibling2$fi.name) === 'VectorSelector';\n}\n\nfunction getLabel(expr, node) {\n  const label = getString(expr, node.getChild('LabelName'));\n  const op = getString(expr, node.getChild('MatchOp'));\n  const value = getString(expr, node.getChild('StringLiteral')).replace(/\"/g, '');\n  return {\n    label,\n    op,\n    value\n  };\n}\n\nconst rangeFunctions = ['changes', 'rate', 'irate', 'increase', 'delta'];\n/**\n * Handle function call which is usually and identifier and its body > arguments.\n * @param expr\n * @param node\n * @param context\n */\n\nfunction handleFunction(expr, node, context) {\n  const visQuery = context.query;\n  const nameNode = node.getChild('FunctionIdentifier');\n  const funcName = getString(expr, nameNode);\n  const body = node.getChild('FunctionCallBody');\n  const callArgs = body.getChild('FunctionCallArgs');\n  const params = [];\n  let interval = ''; // This is a bit of a shortcut to get the interval argument. Reasons are\n  // - interval is not part of the function args per promQL grammar but we model it as argument for the function in\n  //   the query model.\n  // - it is easier to handle template variables this way as template variable is an error for the parser\n\n  if (rangeFunctions.includes(funcName) || funcName.endsWith('_over_time')) {\n    let match = getString(expr, node).match(/\\[(.+)\\]/);\n\n    if (match !== null && match !== void 0 && match[1]) {\n      interval = match[1];\n      params.push(match[1]);\n    }\n  }\n\n  const op = {\n    id: funcName,\n    params\n  }; // We unshift operations to keep the more natural order that we want to have in the visual query editor.\n\n  visQuery.operations.unshift(op);\n\n  if (callArgs) {\n    if (getString(expr, callArgs) === interval + ']') {\n      // This is a special case where we have a function with a single argument and it is the interval.\n      // This happens when you start adding operations in query builder and did not set a metric yet.\n      return;\n    }\n\n    updateFunctionArgs(expr, callArgs, context, op);\n  }\n}\n/**\n * Handle aggregation as they are distinct type from other functions.\n * @param expr\n * @param node\n * @param context\n */\n\n\nfunction handleAggregation(expr, node, context) {\n  const visQuery = context.query;\n  const nameNode = node.getChild('AggregateOp');\n  let funcName = getString(expr, nameNode);\n  const modifier = node.getChild('AggregateModifier');\n  const labels = [];\n\n  if (modifier) {\n    const byModifier = modifier.getChild(`By`);\n\n    if (byModifier && funcName) {\n      funcName = `__${funcName}_by`;\n    }\n\n    const withoutModifier = modifier.getChild(`Without`);\n\n    if (withoutModifier) {\n      funcName = `__${funcName}_without`;\n    }\n\n    labels.push(...getAllByType(expr, modifier, 'GroupingLabel'));\n  }\n\n  const body = node.getChild('FunctionCallBody');\n  const callArgs = body.getChild('FunctionCallArgs');\n  const op = {\n    id: funcName,\n    params: []\n  };\n  visQuery.operations.unshift(op);\n  updateFunctionArgs(expr, callArgs, context, op); // We add labels after params in the visual query editor.\n\n  op.params.push(...labels);\n}\n/**\n * Handle (probably) all types of arguments that function or aggregation can have.\n *\n *  FunctionCallArgs are nested bit weirdly basically its [firstArg, ...rest] where rest is again FunctionCallArgs so\n *  we cannot just get all the children and iterate them as arguments we have to again recursively traverse through\n *  them.\n *\n * @param expr\n * @param node\n * @param context\n * @param op - We need the operation to add the params to as an additional context.\n */\n\n\nfunction updateFunctionArgs(expr, node, context, op) {\n  if (!node) {\n    return;\n  }\n\n  switch (node.name) {\n    // In case we have an expression we don't know what kind so we have to look at the child as it can be anything.\n    case 'Expr': // FunctionCallArgs are nested bit weirdly as mentioned so we have to go one deeper in this case.\n\n    case 'FunctionCallArgs':\n      {\n        let child = node.firstChild;\n\n        while (child) {\n          updateFunctionArgs(expr, child, context, op);\n          child = child.nextSibling;\n        }\n\n        break;\n      }\n\n    case 'NumberLiteral':\n      {\n        op.params.push(parseFloat(getString(expr, node)));\n        break;\n      }\n\n    case 'StringLiteral':\n      {\n        op.params.push(getString(expr, node).replace(/\"/g, ''));\n        break;\n      }\n\n    default:\n      {\n        // Means we get to something that does not seem like simple function arg and is probably nested query so jump\n        // back to main context\n        handleExpression(expr, node, context);\n      }\n  }\n}\n/**\n * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is\n * just operation with scalar or it creates a binaryQuery when it's 2 queries.\n * @param expr\n * @param node\n * @param context\n */\n\n\nfunction handleBinary(expr, node, context) {\n  const visQuery = context.query;\n  const left = node.firstChild;\n  const op = getString(expr, left.nextSibling);\n  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));\n  const right = node.lastChild;\n  const opDef = binaryScalarOperatorToOperatorName[op];\n  const leftNumber = left.getChild('NumberLiteral');\n  const rightNumber = right.getChild('NumberLiteral');\n  const rightBinary = right.getChild('BinaryExpr');\n\n  if (leftNumber) {// TODO: this should be already handled in case parent is binary expression as it has to be added to parent\n    //  if query starts with a number that isn't handled now.\n  } else {\n    // If this is binary we don't really know if there is a query or just chained scalars. So\n    // we have to traverse a bit deeper to know\n    handleExpression(expr, left, context);\n  }\n\n  if (rightNumber) {\n    visQuery.operations.push(makeBinOp(opDef, expr, right, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));\n  } else if (rightBinary) {\n    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which\n    // is a factor for a current binary operation. So we have to add it as an operation now.\n    const leftMostChild = getLeftMostChild(right);\n\n    if ((leftMostChild === null || leftMostChild === void 0 ? void 0 : leftMostChild.name) === 'NumberLiteral') {\n      visQuery.operations.push(makeBinOp(opDef, expr, leftMostChild, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));\n    } // If we added the first number literal as operation here we still can continue and handle the rest as the first\n    // number will be just skipped.\n\n\n    handleExpression(expr, right, context);\n  } else {\n    visQuery.binaryQueries = visQuery.binaryQueries || [];\n    const binQuery = {\n      operator: op,\n      query: {\n        metric: '',\n        labels: [],\n        operations: []\n      }\n    };\n\n    if (binModifier !== null && binModifier !== void 0 && binModifier.isMatcher) {\n      binQuery.vectorMatchesType = binModifier.matchType;\n      binQuery.vectorMatches = binModifier.matches;\n    }\n\n    visQuery.binaryQueries.push(binQuery);\n    handleExpression(expr, right, {\n      query: binQuery.query,\n      errors: context.errors\n    });\n  }\n}\n\nfunction getBinaryModifier(expr, node) {\n  if (!node) {\n    return undefined;\n  }\n\n  if (node.getChild('Bool')) {\n    return {\n      isBool: true,\n      isMatcher: false\n    };\n  } else {\n    var _matcher$getChild;\n\n    const matcher = node.getChild('OnOrIgnoring');\n\n    if (!matcher) {\n      // Not sure what this could be, maybe should be an error.\n      return undefined;\n    }\n\n    const labels = getString(expr, (_matcher$getChild = matcher.getChild('GroupingLabels')) === null || _matcher$getChild === void 0 ? void 0 : _matcher$getChild.getChild('GroupingLabelList'));\n    return {\n      isMatcher: true,\n      isBool: false,\n      matches: labels,\n      matchType: matcher.getChild('On') ? 'on' : 'ignoring'\n    };\n  }\n}\n\nfunction isEmptyQuery(query) {\n  if (query.labels.length === 0 && query.operations.length === 0 && !query.metric) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"names":["parser","binaryScalarOperatorToOperatorName","ErrorName","getAllByType","getLeftMostChild","getString","makeBinOp","makeError","replaceVariables","buildVisualQueryFromString","expr","replacedExpr","tree","parse","node","topNode","visQuery","metric","labels","operations","context","query","errors","handleExpression","err","console","error","Error","push","text","message","isEmptyQuery","name","getLabel","getChild","handleFunction","handleAggregation","handleBinary","isIntervalVariableError","child","firstChild","nextSibling","prevSibling","label","op","value","replace","rangeFunctions","nameNode","funcName","body","callArgs","params","interval","includes","endsWith","match","id","unshift","updateFunctionArgs","modifier","byModifier","withoutModifier","parseFloat","left","binModifier","getBinaryModifier","right","lastChild","opDef","leftNumber","rightNumber","rightBinary","isBool","leftMostChild","binaryQueries","binQuery","operator","isMatcher","vectorMatchesType","matchType","vectorMatches","matches","undefined","matcher","length"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/querybuilder/parsing.ts"],"sourcesContent":["import { SyntaxNode } from '@lezer/common';\nimport { parser } from 'lezer-promql';\n\nimport { binaryScalarOperatorToOperatorName } from './binaryScalarOperations';\nimport {\n  ErrorName,\n  getAllByType,\n  getLeftMostChild,\n  getString,\n  makeBinOp,\n  makeError,\n  replaceVariables,\n} from './shared/parsingUtils';\nimport { QueryBuilderLabelFilter, QueryBuilderOperation } from './shared/types';\nimport { PromVisualQuery, PromVisualQueryBinary } from './types';\n\n/**\n * Parses a PromQL query into a visual query model.\n *\n * It traverses the tree and uses sort of state machine to update the query model. The query model is modified\n * during the traversal and sent to each handler as context.\n *\n * @param expr\n */\nexport function buildVisualQueryFromString(expr: string): Context {\n  const replacedExpr = replaceVariables(expr);\n  const tree = parser.parse(replacedExpr);\n  const node = tree.topNode;\n\n  // This will be modified in the handlers.\n  const visQuery: PromVisualQuery = {\n    metric: '',\n    labels: [],\n    operations: [],\n  };\n  const context: Context = {\n    query: visQuery,\n    errors: [],\n  };\n\n  try {\n    handleExpression(replacedExpr, node, context);\n  } catch (err) {\n    // Not ideal to log it here, but otherwise we would lose the stack trace.\n    console.error(err);\n    if (err instanceof Error) {\n      context.errors.push({\n        text: err.message,\n      });\n    }\n  }\n\n  // If we have empty query, we want to reset errors\n  if (isEmptyQuery(context.query)) {\n    context.errors = [];\n  }\n  return context;\n}\n\ninterface ParsingError {\n  text: string;\n  from?: number;\n  to?: number;\n  parentType?: string;\n}\n\ninterface Context {\n  query: PromVisualQuery;\n  errors: ParsingError[];\n}\n\n/**\n * Handler for default state. It will traverse the tree and call the appropriate handler for each node. The node\n * handled here does not necessarily need to be of type == Expr.\n * @param expr\n * @param node\n * @param context\n */\nexport function handleExpression(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n  switch (node.name) {\n    case 'MetricIdentifier': {\n      // Expectation is that there is only one of those per query.\n      visQuery.metric = getString(expr, node);\n      break;\n    }\n\n    case 'LabelMatcher': {\n      // Same as MetricIdentifier should be just one per query.\n      visQuery.labels.push(getLabel(expr, node));\n      const err = node.getChild(ErrorName);\n      if (err) {\n        context.errors.push(makeError(expr, err));\n      }\n      break;\n    }\n\n    case 'FunctionCall': {\n      handleFunction(expr, node, context);\n      break;\n    }\n\n    case 'AggregateExpr': {\n      handleAggregation(expr, node, context);\n      break;\n    }\n\n    case 'BinaryExpr': {\n      handleBinary(expr, node, context);\n      break;\n    }\n\n    case ErrorName: {\n      if (isIntervalVariableError(node)) {\n        break;\n      }\n      context.errors.push(makeError(expr, node));\n      break;\n    }\n\n    default: {\n      if (node.name === 'ParenExpr') {\n        // We don't support parenthesis in the query to group expressions. We just report error but go on with the\n        // parsing.\n        context.errors.push(makeError(expr, node));\n      }\n      // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper\n      // nodes that can be skipped.\n      // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to\n      //  detect those and report back.\n      let child = node.firstChild;\n      while (child) {\n        handleExpression(expr, child, context);\n        child = child.nextSibling;\n      }\n    }\n  }\n}\n\nfunction isIntervalVariableError(node: SyntaxNode) {\n  return node.prevSibling?.name === 'Expr' && node.prevSibling?.firstChild?.name === 'VectorSelector';\n}\n\nfunction getLabel(expr: string, node: SyntaxNode): QueryBuilderLabelFilter {\n  const label = getString(expr, node.getChild('LabelName'));\n  const op = getString(expr, node.getChild('MatchOp'));\n  const value = getString(expr, node.getChild('StringLiteral')).replace(/\"/g, '');\n  return {\n    label,\n    op,\n    value,\n  };\n}\n\nconst rangeFunctions = ['changes', 'rate', 'irate', 'increase', 'delta'];\n/**\n * Handle function call which is usually and identifier and its body > arguments.\n * @param expr\n * @param node\n * @param context\n */\nfunction handleFunction(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n  const nameNode = node.getChild('FunctionIdentifier');\n  const funcName = getString(expr, nameNode);\n\n  const body = node.getChild('FunctionCallBody');\n  const callArgs = body!.getChild('FunctionCallArgs');\n  const params = [];\n  let interval = '';\n\n  // This is a bit of a shortcut to get the interval argument. Reasons are\n  // - interval is not part of the function args per promQL grammar but we model it as argument for the function in\n  //   the query model.\n  // - it is easier to handle template variables this way as template variable is an error for the parser\n  if (rangeFunctions.includes(funcName) || funcName.endsWith('_over_time')) {\n    let match = getString(expr, node).match(/\\[(.+)\\]/);\n    if (match?.[1]) {\n      interval = match[1];\n      params.push(match[1]);\n    }\n  }\n\n  const op = { id: funcName, params };\n  // We unshift operations to keep the more natural order that we want to have in the visual query editor.\n  visQuery.operations.unshift(op);\n\n  if (callArgs) {\n    if (getString(expr, callArgs) === interval + ']') {\n      // This is a special case where we have a function with a single argument and it is the interval.\n      // This happens when you start adding operations in query builder and did not set a metric yet.\n      return;\n    }\n    updateFunctionArgs(expr, callArgs, context, op);\n  }\n}\n\n/**\n * Handle aggregation as they are distinct type from other functions.\n * @param expr\n * @param node\n * @param context\n */\nfunction handleAggregation(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n  const nameNode = node.getChild('AggregateOp');\n  let funcName = getString(expr, nameNode);\n\n  const modifier = node.getChild('AggregateModifier');\n  const labels = [];\n\n  if (modifier) {\n    const byModifier = modifier.getChild(`By`);\n    if (byModifier && funcName) {\n      funcName = `__${funcName}_by`;\n    }\n\n    const withoutModifier = modifier.getChild(`Without`);\n    if (withoutModifier) {\n      funcName = `__${funcName}_without`;\n    }\n\n    labels.push(...getAllByType(expr, modifier, 'GroupingLabel'));\n  }\n\n  const body = node.getChild('FunctionCallBody');\n  const callArgs = body!.getChild('FunctionCallArgs');\n\n  const op: QueryBuilderOperation = { id: funcName, params: [] };\n  visQuery.operations.unshift(op);\n  updateFunctionArgs(expr, callArgs, context, op);\n  // We add labels after params in the visual query editor.\n  op.params.push(...labels);\n}\n\n/**\n * Handle (probably) all types of arguments that function or aggregation can have.\n *\n *  FunctionCallArgs are nested bit weirdly basically its [firstArg, ...rest] where rest is again FunctionCallArgs so\n *  we cannot just get all the children and iterate them as arguments we have to again recursively traverse through\n *  them.\n *\n * @param expr\n * @param node\n * @param context\n * @param op - We need the operation to add the params to as an additional context.\n */\nfunction updateFunctionArgs(expr: string, node: SyntaxNode | null, context: Context, op: QueryBuilderOperation) {\n  if (!node) {\n    return;\n  }\n  switch (node.name) {\n    // In case we have an expression we don't know what kind so we have to look at the child as it can be anything.\n    case 'Expr':\n    // FunctionCallArgs are nested bit weirdly as mentioned so we have to go one deeper in this case.\n    case 'FunctionCallArgs': {\n      let child = node.firstChild;\n      while (child) {\n        updateFunctionArgs(expr, child, context, op);\n        child = child.nextSibling;\n      }\n      break;\n    }\n\n    case 'NumberLiteral': {\n      op.params.push(parseFloat(getString(expr, node)));\n      break;\n    }\n\n    case 'StringLiteral': {\n      op.params.push(getString(expr, node).replace(/\"/g, ''));\n      break;\n    }\n\n    default: {\n      // Means we get to something that does not seem like simple function arg and is probably nested query so jump\n      // back to main context\n      handleExpression(expr, node, context);\n    }\n  }\n}\n\n/**\n * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is\n * just operation with scalar or it creates a binaryQuery when it's 2 queries.\n * @param expr\n * @param node\n * @param context\n */\nfunction handleBinary(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n  const left = node.firstChild!;\n  const op = getString(expr, left.nextSibling);\n  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));\n\n  const right = node.lastChild!;\n\n  const opDef = binaryScalarOperatorToOperatorName[op];\n\n  const leftNumber = left.getChild('NumberLiteral');\n  const rightNumber = right.getChild('NumberLiteral');\n\n  const rightBinary = right.getChild('BinaryExpr');\n\n  if (leftNumber) {\n    // TODO: this should be already handled in case parent is binary expression as it has to be added to parent\n    //  if query starts with a number that isn't handled now.\n  } else {\n    // If this is binary we don't really know if there is a query or just chained scalars. So\n    // we have to traverse a bit deeper to know\n    handleExpression(expr, left, context);\n  }\n\n  if (rightNumber) {\n    visQuery.operations.push(makeBinOp(opDef, expr, right, !!binModifier?.isBool));\n  } else if (rightBinary) {\n    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which\n    // is a factor for a current binary operation. So we have to add it as an operation now.\n    const leftMostChild = getLeftMostChild(right);\n    if (leftMostChild?.name === 'NumberLiteral') {\n      visQuery.operations.push(makeBinOp(opDef, expr, leftMostChild, !!binModifier?.isBool));\n    }\n\n    // If we added the first number literal as operation here we still can continue and handle the rest as the first\n    // number will be just skipped.\n    handleExpression(expr, right, context);\n  } else {\n    visQuery.binaryQueries = visQuery.binaryQueries || [];\n    const binQuery: PromVisualQueryBinary = {\n      operator: op,\n      query: {\n        metric: '',\n        labels: [],\n        operations: [],\n      },\n    };\n    if (binModifier?.isMatcher) {\n      binQuery.vectorMatchesType = binModifier.matchType;\n      binQuery.vectorMatches = binModifier.matches;\n    }\n    visQuery.binaryQueries.push(binQuery);\n    handleExpression(expr, right, {\n      query: binQuery.query,\n      errors: context.errors,\n    });\n  }\n}\n\nfunction getBinaryModifier(\n  expr: string,\n  node: SyntaxNode | null\n):\n  | { isBool: true; isMatcher: false }\n  | { isBool: false; isMatcher: true; matches: string; matchType: 'ignoring' | 'on' }\n  | undefined {\n  if (!node) {\n    return undefined;\n  }\n  if (node.getChild('Bool')) {\n    return { isBool: true, isMatcher: false };\n  } else {\n    const matcher = node.getChild('OnOrIgnoring');\n    if (!matcher) {\n      // Not sure what this could be, maybe should be an error.\n      return undefined;\n    }\n    const labels = getString(expr, matcher.getChild('GroupingLabels')?.getChild('GroupingLabelList'));\n    return {\n      isMatcher: true,\n      isBool: false,\n      matches: labels,\n      matchType: matcher.getChild('On') ? 'on' : 'ignoring',\n    };\n  }\n}\n\nfunction isEmptyQuery(query: PromVisualQuery) {\n  if (query.labels.length === 0 && query.operations.length === 0 && !query.metric) {\n    return true;\n  }\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}