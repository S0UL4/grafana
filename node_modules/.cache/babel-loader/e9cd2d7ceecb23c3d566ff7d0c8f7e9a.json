{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { DataTransformerID } from './ids';\nexport const orderFieldsTransformer = {\n  id: DataTransformerID.order,\n  name: 'Order fields by name',\n  description: 'Order fields based on configuration given by user',\n  defaultOptions: {\n    indexByName: {}\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: options => source => source.pipe(map(data => {\n    const orderer = createFieldsOrderer(options.indexByName);\n\n    if (!Array.isArray(data) || data.length === 0) {\n      return data;\n    }\n\n    return data.map(frame => Object.assign({}, frame, {\n      fields: orderer(frame.fields, data, frame)\n    }));\n  }))\n};\nexport const createOrderFieldsComparer = indexByName => (a, b) => {\n  return indexOfField(a, indexByName) - indexOfField(b, indexByName);\n};\n\nconst createFieldsOrderer = indexByName => (fields, data, frame) => {\n  if (!Array.isArray(fields) || fields.length === 0) {\n    return fields;\n  }\n\n  if (!indexByName || Object.keys(indexByName).length === 0) {\n    return fields;\n  }\n\n  const comparer = createOrderFieldsComparer(indexByName);\n  return fields.sort((a, b) => comparer(getFieldDisplayName(a, frame, data), getFieldDisplayName(b, frame, data)));\n};\n\nconst indexOfField = (fieldName, indexByName) => {\n  if (Number.isInteger(indexByName[fieldName])) {\n    return indexByName[fieldName];\n  }\n\n  return Number.MAX_SAFE_INTEGER;\n};","map":{"version":3,"names":["map","getFieldDisplayName","DataTransformerID","orderFieldsTransformer","id","order","name","description","defaultOptions","indexByName","operator","options","source","pipe","data","orderer","createFieldsOrderer","Array","isArray","length","frame","fields","createOrderFieldsComparer","a","b","indexOfField","Object","keys","comparer","sort","fieldName","Number","isInteger","MAX_SAFE_INTEGER"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/order.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { DataFrame, Field } from '../../types';\nimport { DataTransformerInfo } from '../../types/transformations';\n\nimport { DataTransformerID } from './ids';\n\nexport interface OrderFieldsTransformerOptions {\n  indexByName: Record<string, number>;\n}\n\nexport const orderFieldsTransformer: DataTransformerInfo<OrderFieldsTransformerOptions> = {\n  id: DataTransformerID.order,\n  name: 'Order fields by name',\n  description: 'Order fields based on configuration given by user',\n  defaultOptions: {\n    indexByName: {},\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        const orderer = createFieldsOrderer(options.indexByName);\n\n        if (!Array.isArray(data) || data.length === 0) {\n          return data;\n        }\n\n        return data.map((frame) => ({\n          ...frame,\n          fields: orderer(frame.fields, data, frame),\n        }));\n      })\n    ),\n};\n\nexport const createOrderFieldsComparer = (indexByName: Record<string, number>) => (a: string, b: string) => {\n  return indexOfField(a, indexByName) - indexOfField(b, indexByName);\n};\n\nconst createFieldsOrderer =\n  (indexByName: Record<string, number>) => (fields: Field[], data: DataFrame[], frame: DataFrame) => {\n    if (!Array.isArray(fields) || fields.length === 0) {\n      return fields;\n    }\n    if (!indexByName || Object.keys(indexByName).length === 0) {\n      return fields;\n    }\n    const comparer = createOrderFieldsComparer(indexByName);\n    return fields.sort((a, b) => comparer(getFieldDisplayName(a, frame, data), getFieldDisplayName(b, frame, data)));\n  };\n\nconst indexOfField = (fieldName: string, indexByName: Record<string, number>) => {\n  if (Number.isInteger(indexByName[fieldName])) {\n    return indexByName[fieldName];\n  }\n  return Number.MAX_SAFE_INTEGER;\n};\n"],"mappings":"AAAA,SAASA,GAAT,QAAoB,gBAApB;AAEA,SAASC,mBAAT,QAAoC,wBAApC;AAIA,SAASC,iBAAT,QAAkC,OAAlC;AAMA,OAAO,MAAMC,sBAA0E,GAAG;EACxFC,EAAE,EAAEF,iBAAiB,CAACG,KADkE;EAExFC,IAAI,EAAE,sBAFkF;EAGxFC,WAAW,EAAE,mDAH2E;EAIxFC,cAAc,EAAE;IACdC,WAAW,EAAE;EADC,CAJwE;;EAQxF;AACF;AACA;AACA;EACEC,QAAQ,EAAGC,OAAD,IAAcC,MAAD,IACrBA,MAAM,CAACC,IAAP,CACEb,GAAG,CAAEc,IAAD,IAAU;IACZ,MAAMC,OAAO,GAAGC,mBAAmB,CAACL,OAAO,CAACF,WAAT,CAAnC;;IAEA,IAAI,CAACQ,KAAK,CAACC,OAAN,CAAcJ,IAAd,CAAD,IAAwBA,IAAI,CAACK,MAAL,KAAgB,CAA5C,EAA+C;MAC7C,OAAOL,IAAP;IACD;;IAED,OAAOA,IAAI,CAACd,GAAL,CAAUoB,KAAD,sBACXA,KADW;MAEdC,MAAM,EAAEN,OAAO,CAACK,KAAK,CAACC,MAAP,EAAeP,IAAf,EAAqBM,KAArB;IAFD,EAAT,CAAP;EAID,CAXE,CADL;AAbsF,CAAnF;AA6BP,OAAO,MAAME,yBAAyB,GAAIb,WAAD,IAAyC,CAACc,CAAD,EAAYC,CAAZ,KAA0B;EAC1G,OAAOC,YAAY,CAACF,CAAD,EAAId,WAAJ,CAAZ,GAA+BgB,YAAY,CAACD,CAAD,EAAIf,WAAJ,CAAlD;AACD,CAFM;;AAIP,MAAMO,mBAAmB,GACtBP,WAAD,IAAyC,CAACY,MAAD,EAAkBP,IAAlB,EAAqCM,KAArC,KAA0D;EACjG,IAAI,CAACH,KAAK,CAACC,OAAN,CAAcG,MAAd,CAAD,IAA0BA,MAAM,CAACF,MAAP,KAAkB,CAAhD,EAAmD;IACjD,OAAOE,MAAP;EACD;;EACD,IAAI,CAACZ,WAAD,IAAgBiB,MAAM,CAACC,IAAP,CAAYlB,WAAZ,EAAyBU,MAAzB,KAAoC,CAAxD,EAA2D;IACzD,OAAOE,MAAP;EACD;;EACD,MAAMO,QAAQ,GAAGN,yBAAyB,CAACb,WAAD,CAA1C;EACA,OAAOY,MAAM,CAACQ,IAAP,CAAY,CAACN,CAAD,EAAIC,CAAJ,KAAUI,QAAQ,CAAC3B,mBAAmB,CAACsB,CAAD,EAAIH,KAAJ,EAAWN,IAAX,CAApB,EAAsCb,mBAAmB,CAACuB,CAAD,EAAIJ,KAAJ,EAAWN,IAAX,CAAzD,CAA9B,CAAP;AACD,CAVH;;AAYA,MAAMW,YAAY,GAAG,CAACK,SAAD,EAAoBrB,WAApB,KAA4D;EAC/E,IAAIsB,MAAM,CAACC,SAAP,CAAiBvB,WAAW,CAACqB,SAAD,CAA5B,CAAJ,EAA8C;IAC5C,OAAOrB,WAAW,CAACqB,SAAD,CAAlB;EACD;;EACD,OAAOC,MAAM,CAACE,gBAAd;AACD,CALD"},"metadata":{},"sourceType":"module"}