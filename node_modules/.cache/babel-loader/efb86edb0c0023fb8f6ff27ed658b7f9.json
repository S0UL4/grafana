{"ast":null,"code":"import { clone } from 'lodash';\nimport { createErrorNotification } from '../../../../core/copy/appNotification';\nimport { notifyApp } from '../../../../core/reducers/appNotification';\nimport { dispatch } from '../../../../store/store';\n\n/**\n * Helpers used by reducers and providers. They modify state object directly so should operate on a copy of the state.\n */\nexport const GRAPHITE_TAG_OPERATORS = ['=', '!=', '=~', '!=~'];\n/**\n * Tag names and metric names are displayed in a single dropdown. This prefix is used to\n * distinguish both in the UI.\n */\n\nexport const TAG_PREFIX = 'tag: ';\n/**\n * Create new AST based on new query.\n * Build segments from parsed metric name and functions.\n */\n\nexport async function parseTarget(state) {\n  state.queryModel.parseTarget();\n  await buildSegments(state);\n}\n/**\n * Create segments out of the current metric path + add \"select metrics\" if it's possible to add more to the path\n */\n\nexport async function buildSegments(state, modifyLastSegment = true) {\n  // Start with a shallow copy from the model, then check if \"select metric\" segment should be added at the end\n  state.segments = clone(state.queryModel.segments);\n  const checkOtherSegmentsIndex = state.queryModel.checkOtherSegmentsIndex || 0;\n  await checkOtherSegments(state, checkOtherSegmentsIndex, modifyLastSegment);\n}\n/**\n * Add \"select metric\" segment at the end\n */\n\nexport function addSelectMetricSegment(state) {\n  state.queryModel.addSelectMetricSegment();\n  state.segments.push({\n    value: 'select metric',\n    fake: true\n  });\n}\n/**\n * Validates the state after adding or changing a segment:\n * - adds \"select metric\" only when more segments can be added to the metric name\n * - check if subsequent segments are still valid if in-between segment changes and\n *   removes invalid segments.\n */\n\nexport async function checkOtherSegments(state, fromIndex, modifyLastSegment = true) {\n  if (state.queryModel.segments.length === 1 && state.queryModel.segments[0].type === 'series-ref') {\n    return;\n  }\n\n  if (fromIndex === 0) {\n    addSelectMetricSegment(state);\n    return;\n  }\n\n  const path = state.queryModel.getSegmentPathUpTo(fromIndex + 1);\n\n  if (path === '') {\n    return;\n  }\n\n  try {\n    const segments = await state.datasource.metricFindQuery(path);\n\n    if (segments.length === 0) {\n      if (path !== '' && modifyLastSegment) {\n        state.queryModel.segments = state.queryModel.segments.splice(0, fromIndex);\n        state.segments = state.segments.splice(0, fromIndex);\n        addSelectMetricSegment(state);\n      }\n    } else if (segments[0].expandable) {\n      if (state.segments.length === fromIndex) {\n        addSelectMetricSegment(state);\n      } else {\n        await checkOtherSegments(state, fromIndex + 1);\n      }\n    }\n  } catch (err) {\n    if (err instanceof Error) {\n      handleMetricsAutoCompleteError(state, err);\n    }\n  }\n}\nexport function spliceSegments(state, index) {\n  state.segments = state.segments.splice(0, index);\n  state.queryModel.segments = state.queryModel.segments.splice(0, index);\n}\nexport function emptySegments(state) {\n  state.queryModel.segments = [];\n  state.segments = [];\n}\n/**\n * When seriesByTag function is added the UI changes it's state and only tags can be added from now.\n */\n\nexport async function addSeriesByTagFunc(state, tag) {\n  const newFunc = state.datasource.createFuncInstance('seriesByTag', {\n    withDefaultParams: false\n  });\n  const tagParam = `${tag}=`;\n  newFunc.params = [tagParam];\n  state.queryModel.addFunction(newFunc);\n  newFunc.added = true;\n  emptySegments(state);\n  handleTargetChanged(state);\n  await parseTarget(state);\n}\nexport function smartlyHandleNewAliasByNode(state, func) {\n  if (func.def.name !== 'aliasByNode') {\n    return;\n  }\n\n  for (let i = 0; i < state.segments.length; i++) {\n    if (state.segments[i].value.indexOf('*') >= 0) {\n      func.params[0] = i;\n      func.added = false;\n      handleTargetChanged(state);\n      return;\n    }\n  }\n}\n/**\n * Pauses running the query to allow selecting tag value. This is to prevent getting errors if the query is run\n * for a tag with no selected value.\n */\n\nexport function pause(state) {\n  state.paused = true;\n}\nexport function removeTagPrefix(value) {\n  return value.replace(TAG_PREFIX, '');\n}\nexport function handleTargetChanged(state) {\n  if (state.queryModel.error) {\n    return;\n  }\n\n  const oldTarget = state.queryModel.target.target; // Interpolate from other queries:\n  // Because of mixed data sources the list may contain queries for non-Graphite data sources. To ensure a valid query\n  // is used for interpolation we should check required properties are passed though in theory it allows to interpolate\n  // with queries that contain \"target\" property as well.\n\n  state.queryModel.updateModelTarget((state.queries || []).filter(query => 'target' in query && typeof query.target === 'string'));\n\n  if (state.queryModel.target.target !== oldTarget && !state.paused) {\n    state.refresh();\n  }\n}\n/**\n * When metrics autocomplete fails - the error is shown, but only once per page view\n */\n\nexport function handleMetricsAutoCompleteError(state, error) {\n  if (!state.metricAutoCompleteErrorShown) {\n    state.metricAutoCompleteErrorShown = true;\n    dispatch(notifyApp(createErrorNotification(`Fetching metrics failed: ${error.message}.`)));\n  }\n\n  return state;\n}\n/**\n * When tags autocomplete fails - the error is shown, but only once per page view\n */\n\nexport function handleTagsAutoCompleteError(state, error) {\n  if (!state.tagsAutoCompleteErrorShown) {\n    state.tagsAutoCompleteErrorShown = true;\n    dispatch(notifyApp(createErrorNotification(`Fetching tags failed: ${error.message}.`)));\n  }\n\n  return state;\n}","map":{"version":3,"names":["clone","createErrorNotification","notifyApp","dispatch","GRAPHITE_TAG_OPERATORS","TAG_PREFIX","parseTarget","state","queryModel","buildSegments","modifyLastSegment","segments","checkOtherSegmentsIndex","checkOtherSegments","addSelectMetricSegment","push","value","fake","fromIndex","length","type","path","getSegmentPathUpTo","datasource","metricFindQuery","splice","expandable","err","Error","handleMetricsAutoCompleteError","spliceSegments","index","emptySegments","addSeriesByTagFunc","tag","newFunc","createFuncInstance","withDefaultParams","tagParam","params","addFunction","added","handleTargetChanged","smartlyHandleNewAliasByNode","func","def","name","i","indexOf","pause","paused","removeTagPrefix","replace","error","oldTarget","target","updateModelTarget","queries","filter","query","refresh","metricAutoCompleteErrorShown","message","handleTagsAutoCompleteError","tagsAutoCompleteErrorShown"],"sources":["/home/soula/grafana/public/app/plugins/datasource/graphite/state/helpers.ts"],"sourcesContent":["import { clone } from 'lodash';\n\nimport { createErrorNotification } from '../../../../core/copy/appNotification';\nimport { notifyApp } from '../../../../core/reducers/appNotification';\nimport { dispatch } from '../../../../store/store';\nimport { FuncInstance } from '../gfunc';\nimport { GraphiteQuery, GraphiteTagOperator } from '../types';\n\nimport { GraphiteQueryEditorState } from './store';\n\n/**\n * Helpers used by reducers and providers. They modify state object directly so should operate on a copy of the state.\n */\n\nexport const GRAPHITE_TAG_OPERATORS: GraphiteTagOperator[] = ['=', '!=', '=~', '!=~'];\n\n/**\n * Tag names and metric names are displayed in a single dropdown. This prefix is used to\n * distinguish both in the UI.\n */\nexport const TAG_PREFIX = 'tag: ';\n\n/**\n * Create new AST based on new query.\n * Build segments from parsed metric name and functions.\n */\nexport async function parseTarget(state: GraphiteQueryEditorState): Promise<void> {\n  state.queryModel.parseTarget();\n  await buildSegments(state);\n}\n\n/**\n * Create segments out of the current metric path + add \"select metrics\" if it's possible to add more to the path\n */\nexport async function buildSegments(state: GraphiteQueryEditorState, modifyLastSegment = true): Promise<void> {\n  // Start with a shallow copy from the model, then check if \"select metric\" segment should be added at the end\n  state.segments = clone(state.queryModel.segments);\n\n  const checkOtherSegmentsIndex = state.queryModel.checkOtherSegmentsIndex || 0;\n\n  await checkOtherSegments(state, checkOtherSegmentsIndex, modifyLastSegment);\n}\n\n/**\n * Add \"select metric\" segment at the end\n */\nexport function addSelectMetricSegment(state: GraphiteQueryEditorState): void {\n  state.queryModel.addSelectMetricSegment();\n  state.segments.push({ value: 'select metric', fake: true });\n}\n\n/**\n * Validates the state after adding or changing a segment:\n * - adds \"select metric\" only when more segments can be added to the metric name\n * - check if subsequent segments are still valid if in-between segment changes and\n *   removes invalid segments.\n */\nexport async function checkOtherSegments(\n  state: GraphiteQueryEditorState,\n  fromIndex: number,\n  modifyLastSegment = true\n): Promise<void> {\n  if (state.queryModel.segments.length === 1 && state.queryModel.segments[0].type === 'series-ref') {\n    return;\n  }\n\n  if (fromIndex === 0) {\n    addSelectMetricSegment(state);\n    return;\n  }\n\n  const path = state.queryModel.getSegmentPathUpTo(fromIndex + 1);\n  if (path === '') {\n    return;\n  }\n\n  try {\n    const segments = await state.datasource.metricFindQuery(path);\n    if (segments.length === 0) {\n      if (path !== '' && modifyLastSegment) {\n        state.queryModel.segments = state.queryModel.segments.splice(0, fromIndex);\n        state.segments = state.segments.splice(0, fromIndex);\n        addSelectMetricSegment(state);\n      }\n    } else if (segments[0].expandable) {\n      if (state.segments.length === fromIndex) {\n        addSelectMetricSegment(state);\n      } else {\n        await checkOtherSegments(state, fromIndex + 1);\n      }\n    }\n  } catch (err) {\n    if (err instanceof Error) {\n      handleMetricsAutoCompleteError(state, err);\n    }\n  }\n}\n\nexport function spliceSegments(state: GraphiteQueryEditorState, index: number): void {\n  state.segments = state.segments.splice(0, index);\n  state.queryModel.segments = state.queryModel.segments.splice(0, index);\n}\n\nexport function emptySegments(state: GraphiteQueryEditorState): void {\n  state.queryModel.segments = [];\n  state.segments = [];\n}\n\n/**\n * When seriesByTag function is added the UI changes it's state and only tags can be added from now.\n */\nexport async function addSeriesByTagFunc(state: GraphiteQueryEditorState, tag: string): Promise<void> {\n  const newFunc = state.datasource.createFuncInstance('seriesByTag', {\n    withDefaultParams: false,\n  });\n  const tagParam = `${tag}=`;\n  newFunc.params = [tagParam];\n  state.queryModel.addFunction(newFunc);\n  newFunc.added = true;\n\n  emptySegments(state);\n  handleTargetChanged(state);\n  await parseTarget(state);\n}\n\nexport function smartlyHandleNewAliasByNode(state: GraphiteQueryEditorState, func: FuncInstance): void {\n  if (func.def.name !== 'aliasByNode') {\n    return;\n  }\n\n  for (let i = 0; i < state.segments.length; i++) {\n    if (state.segments[i].value.indexOf('*') >= 0) {\n      func.params[0] = i;\n      func.added = false;\n      handleTargetChanged(state);\n      return;\n    }\n  }\n}\n\n/**\n * Pauses running the query to allow selecting tag value. This is to prevent getting errors if the query is run\n * for a tag with no selected value.\n */\nexport function pause(state: GraphiteQueryEditorState): void {\n  state.paused = true;\n}\n\nexport function removeTagPrefix(value: string): string {\n  return value.replace(TAG_PREFIX, '');\n}\n\nexport function handleTargetChanged(state: GraphiteQueryEditorState): void {\n  if (state.queryModel.error) {\n    return;\n  }\n\n  const oldTarget = state.queryModel.target.target;\n  // Interpolate from other queries:\n  // Because of mixed data sources the list may contain queries for non-Graphite data sources. To ensure a valid query\n  // is used for interpolation we should check required properties are passed though in theory it allows to interpolate\n  // with queries that contain \"target\" property as well.\n  state.queryModel.updateModelTarget(\n    (state.queries || []).filter((query) => 'target' in query && typeof (query as GraphiteQuery).target === 'string')\n  );\n\n  if (state.queryModel.target.target !== oldTarget && !state.paused) {\n    state.refresh();\n  }\n}\n\n/**\n * When metrics autocomplete fails - the error is shown, but only once per page view\n */\nexport function handleMetricsAutoCompleteError(\n  state: GraphiteQueryEditorState,\n  error: Error\n): GraphiteQueryEditorState {\n  if (!state.metricAutoCompleteErrorShown) {\n    state.metricAutoCompleteErrorShown = true;\n    dispatch(notifyApp(createErrorNotification(`Fetching metrics failed: ${error.message}.`)));\n  }\n  return state;\n}\n\n/**\n * When tags autocomplete fails - the error is shown, but only once per page view\n */\nexport function handleTagsAutoCompleteError(state: GraphiteQueryEditorState, error: Error): GraphiteQueryEditorState {\n  if (!state.tagsAutoCompleteErrorShown) {\n    state.tagsAutoCompleteErrorShown = true;\n    dispatch(notifyApp(createErrorNotification(`Fetching tags failed: ${error.message}.`)));\n  }\n  return state;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}