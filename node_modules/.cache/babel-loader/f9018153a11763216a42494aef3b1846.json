{"ast":null,"code":"import { isEqual } from 'lodash';\nimport React, { useMemo, useState } from 'react';\nimport { EditorList } from '@grafana/experimental';\nimport { FilterItem } from './FilterItem';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst dimensionsToFilterConditions = dimensions => Object.entries(dimensions !== null && dimensions !== void 0 ? dimensions : {}).reduce((acc, [key, value]) => {\n  if (value && typeof value === 'string') {\n    const filter = {\n      key,\n      value,\n      operator: '='\n    };\n    return [...acc, filter];\n  }\n\n  return acc;\n}, []);\n\nconst filterConditionsToDimensions = filters => {\n  return filters.reduce((acc, {\n    key,\n    value\n  }) => {\n    if (key && value) {\n      return Object.assign({}, acc, {\n        [key]: value\n      });\n    }\n\n    return acc;\n  }, {});\n};\n\nexport const Dimensions = ({\n  metricStat,\n  datasource,\n  dimensionKeys,\n  disableExpressions,\n  onChange\n}) => {\n  const dimensionFilters = useMemo(() => dimensionsToFilterConditions(metricStat.dimensions), [metricStat.dimensions]);\n  const [items, setItems] = useState(dimensionFilters);\n\n  const onDimensionsChange = newItems => {\n    setItems(newItems); // The onChange event should only be triggered in the case there is a complete dimension object.\n    // So when a new key is added that does not yet have a value, it should not trigger an onChange event.\n\n    const newDimensions = filterConditionsToDimensions(newItems);\n\n    if (!isEqual(newDimensions, metricStat.dimensions)) {\n      onChange(newDimensions);\n    }\n  };\n\n  return /*#__PURE__*/_jsx(EditorList, {\n    items: items,\n    onChange: onDimensionsChange,\n    renderItem: makeRenderFilter(datasource, metricStat, dimensionKeys, disableExpressions)\n  });\n};\n\nfunction makeRenderFilter(datasource, metricStat, dimensionKeys, disableExpressions) {\n  function renderFilter(item, onChange, onDelete) {\n    return /*#__PURE__*/_jsx(FilterItem, {\n      filter: item,\n      onChange: item => onChange(item),\n      datasource: datasource,\n      metricStat: metricStat,\n      disableExpressions: disableExpressions,\n      dimensionKeys: dimensionKeys,\n      onDelete: onDelete\n    });\n  }\n\n  return renderFilter;\n}","map":{"version":3,"names":["isEqual","React","useMemo","useState","EditorList","FilterItem","dimensionsToFilterConditions","dimensions","Object","entries","reduce","acc","key","value","filter","operator","filterConditionsToDimensions","filters","Dimensions","metricStat","datasource","dimensionKeys","disableExpressions","onChange","dimensionFilters","items","setItems","onDimensionsChange","newItems","newDimensions","makeRenderFilter","renderFilter","item","onDelete"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/components/Dimensions/Dimensions.tsx"],"sourcesContent":["import { isEqual } from 'lodash';\nimport React, { useMemo, useState } from 'react';\n\nimport { SelectableValue } from '@grafana/data';\nimport { EditorList } from '@grafana/experimental';\n\nimport { CloudWatchDatasource } from '../../datasource';\nimport { Dimensions as DimensionsType, MetricStat } from '../../types';\n\nimport { FilterItem } from './FilterItem';\n\nexport interface Props {\n  metricStat: MetricStat;\n  onChange: (dimensions: DimensionsType) => void;\n  datasource: CloudWatchDatasource;\n  dimensionKeys: Array<SelectableValue<string>>;\n  disableExpressions: boolean;\n}\n\nexport interface DimensionFilterCondition {\n  key?: string;\n  operator?: string;\n  value?: string;\n}\n\nconst dimensionsToFilterConditions = (dimensions: DimensionsType | undefined) =>\n  Object.entries(dimensions ?? {}).reduce<DimensionFilterCondition[]>((acc, [key, value]) => {\n    if (value && typeof value === 'string') {\n      const filter = {\n        key,\n        value,\n        operator: '=',\n      };\n      return [...acc, filter];\n    }\n    return acc;\n  }, []);\n\nconst filterConditionsToDimensions = (filters: DimensionFilterCondition[]) => {\n  return filters.reduce<DimensionsType>((acc, { key, value }) => {\n    if (key && value) {\n      return { ...acc, [key]: value };\n    }\n    return acc;\n  }, {});\n};\n\nexport const Dimensions: React.FC<Props> = ({\n  metricStat,\n  datasource,\n  dimensionKeys,\n  disableExpressions,\n  onChange,\n}) => {\n  const dimensionFilters = useMemo(() => dimensionsToFilterConditions(metricStat.dimensions), [metricStat.dimensions]);\n  const [items, setItems] = useState<DimensionFilterCondition[]>(dimensionFilters);\n  const onDimensionsChange = (newItems: Array<Partial<DimensionFilterCondition>>) => {\n    setItems(newItems);\n\n    // The onChange event should only be triggered in the case there is a complete dimension object.\n    // So when a new key is added that does not yet have a value, it should not trigger an onChange event.\n    const newDimensions = filterConditionsToDimensions(newItems);\n    if (!isEqual(newDimensions, metricStat.dimensions)) {\n      onChange(newDimensions);\n    }\n  };\n\n  return (\n    <EditorList\n      items={items}\n      onChange={onDimensionsChange}\n      renderItem={makeRenderFilter(datasource, metricStat, dimensionKeys, disableExpressions)}\n    />\n  );\n};\n\nfunction makeRenderFilter(\n  datasource: CloudWatchDatasource,\n  metricStat: MetricStat,\n  dimensionKeys: Array<SelectableValue<string>>,\n  disableExpressions: boolean\n) {\n  function renderFilter(\n    item: DimensionFilterCondition,\n    onChange: (item: DimensionFilterCondition) => void,\n    onDelete: () => void\n  ) {\n    return (\n      <FilterItem\n        filter={item}\n        onChange={(item) => onChange(item)}\n        datasource={datasource}\n        metricStat={metricStat}\n        disableExpressions={disableExpressions}\n        dimensionKeys={dimensionKeys}\n        onDelete={onDelete}\n      />\n    );\n  }\n\n  return renderFilter;\n}\n"],"mappings":"AAAA,SAASA,OAAT,QAAwB,QAAxB;AACA,OAAOC,KAAP,IAAgBC,OAAhB,EAAyBC,QAAzB,QAAyC,OAAzC;AAGA,SAASC,UAAT,QAA2B,uBAA3B;AAKA,SAASC,UAAT,QAA2B,cAA3B;;;AAgBA,MAAMC,4BAA4B,GAAIC,UAAD,IACnCC,MAAM,CAACC,OAAP,CAAeF,UAAf,aAAeA,UAAf,cAAeA,UAAf,GAA6B,EAA7B,EAAiCG,MAAjC,CAAoE,CAACC,GAAD,EAAM,CAACC,GAAD,EAAMC,KAAN,CAAN,KAAuB;EACzF,IAAIA,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAA9B,EAAwC;IACtC,MAAMC,MAAM,GAAG;MACbF,GADa;MAEbC,KAFa;MAGbE,QAAQ,EAAE;IAHG,CAAf;IAKA,OAAO,CAAC,GAAGJ,GAAJ,EAASG,MAAT,CAAP;EACD;;EACD,OAAOH,GAAP;AACD,CAVD,EAUG,EAVH,CADF;;AAaA,MAAMK,4BAA4B,GAAIC,OAAD,IAAyC;EAC5E,OAAOA,OAAO,CAACP,MAAR,CAA+B,CAACC,GAAD,EAAM;IAAEC,GAAF;IAAOC;EAAP,CAAN,KAAyB;IAC7D,IAAID,GAAG,IAAIC,KAAX,EAAkB;MAChB,yBAAYF,GAAZ;QAAiB,CAACC,GAAD,GAAOC;MAAxB;IACD;;IACD,OAAOF,GAAP;EACD,CALM,EAKJ,EALI,CAAP;AAMD,CAPD;;AASA,OAAO,MAAMO,UAA2B,GAAG,CAAC;EAC1CC,UAD0C;EAE1CC,UAF0C;EAG1CC,aAH0C;EAI1CC,kBAJ0C;EAK1CC;AAL0C,CAAD,KAMrC;EACJ,MAAMC,gBAAgB,GAAGtB,OAAO,CAAC,MAAMI,4BAA4B,CAACa,UAAU,CAACZ,UAAZ,CAAnC,EAA4D,CAACY,UAAU,CAACZ,UAAZ,CAA5D,CAAhC;EACA,MAAM,CAACkB,KAAD,EAAQC,QAAR,IAAoBvB,QAAQ,CAA6BqB,gBAA7B,CAAlC;;EACA,MAAMG,kBAAkB,GAAIC,QAAD,IAAwD;IACjFF,QAAQ,CAACE,QAAD,CAAR,CADiF,CAGjF;IACA;;IACA,MAAMC,aAAa,GAAGb,4BAA4B,CAACY,QAAD,CAAlD;;IACA,IAAI,CAAC5B,OAAO,CAAC6B,aAAD,EAAgBV,UAAU,CAACZ,UAA3B,CAAZ,EAAoD;MAClDgB,QAAQ,CAACM,aAAD,CAAR;IACD;EACF,CATD;;EAWA,oBACE,KAAC,UAAD;IACE,KAAK,EAAEJ,KADT;IAEE,QAAQ,EAAEE,kBAFZ;IAGE,UAAU,EAAEG,gBAAgB,CAACV,UAAD,EAAaD,UAAb,EAAyBE,aAAzB,EAAwCC,kBAAxC;EAH9B,EADF;AAOD,CA3BM;;AA6BP,SAASQ,gBAAT,CACEV,UADF,EAEED,UAFF,EAGEE,aAHF,EAIEC,kBAJF,EAKE;EACA,SAASS,YAAT,CACEC,IADF,EAEET,QAFF,EAGEU,QAHF,EAIE;IACA,oBACE,KAAC,UAAD;MACE,MAAM,EAAED,IADV;MAEE,QAAQ,EAAGA,IAAD,IAAUT,QAAQ,CAACS,IAAD,CAF9B;MAGE,UAAU,EAAEZ,UAHd;MAIE,UAAU,EAAED,UAJd;MAKE,kBAAkB,EAAEG,kBALtB;MAME,aAAa,EAAED,aANjB;MAOE,QAAQ,EAAEY;IAPZ,EADF;EAWD;;EAED,OAAOF,YAAP;AACD"},"metadata":{},"sourceType":"module"}