{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { toUtc, dateTime } from '@grafana/data';\nconst intervalMap = {\n  Hourly: {\n    startOf: 'hour',\n    amount: 'hours'\n  },\n  Daily: {\n    startOf: 'day',\n    amount: 'days'\n  },\n  Weekly: {\n    startOf: 'isoWeek',\n    amount: 'weeks'\n  },\n  Monthly: {\n    startOf: 'month',\n    amount: 'months'\n  },\n  Yearly: {\n    startOf: 'year',\n    amount: 'years'\n  }\n};\nexport class IndexPattern {\n  constructor(pattern, interval) {\n    _defineProperty(this, \"dateLocale\", 'en');\n\n    this.pattern = pattern;\n    this.interval = interval;\n  }\n\n  getIndexForToday() {\n    if (this.interval) {\n      return toUtc().locale(this.dateLocale).format(this.pattern);\n    } else {\n      return this.pattern;\n    }\n  }\n\n  getIndexList(from, to) {\n    // When no `from` or `to` is provided, we request data from 7 subsequent/previous indices\n    // for the provided index pattern.\n    // This is useful when requesting log context where the only time data we have is the log\n    // timestamp.\n    const indexOffset = 7;\n\n    if (!this.interval) {\n      return this.pattern;\n    }\n\n    const intervalInfo = intervalMap[this.interval];\n    const start = dateTime(from || dateTime(to).add(-indexOffset, intervalInfo.amount)).utc().startOf(intervalInfo.startOf);\n    const endEpoch = dateTime(to || dateTime(from).add(indexOffset, intervalInfo.amount)).utc().startOf(intervalInfo.startOf).valueOf();\n    const indexList = [];\n\n    while (start.valueOf() <= endEpoch) {\n      indexList.push(start.locale(this.dateLocale).format(this.pattern));\n      start.add(1, intervalInfo.amount);\n    }\n\n    return indexList;\n  }\n\n}","map":{"version":3,"names":["toUtc","dateTime","intervalMap","Hourly","startOf","amount","Daily","Weekly","Monthly","Yearly","IndexPattern","constructor","pattern","interval","getIndexForToday","locale","dateLocale","format","getIndexList","from","to","indexOffset","intervalInfo","start","add","utc","endEpoch","valueOf","indexList","push"],"sources":["/home/soula/grafana/public/app/plugins/datasource/elasticsearch/index_pattern.ts"],"sourcesContent":["import { toUtc, dateTime, DateTime, DurationUnit } from '@grafana/data';\n\nimport { Interval } from './types';\n\ntype IntervalMap = Record<\n  Interval,\n  {\n    startOf: DurationUnit;\n    amount: DurationUnit;\n  }\n>;\n\nconst intervalMap: IntervalMap = {\n  Hourly: { startOf: 'hour', amount: 'hours' },\n  Daily: { startOf: 'day', amount: 'days' },\n  Weekly: { startOf: 'isoWeek', amount: 'weeks' },\n  Monthly: { startOf: 'month', amount: 'months' },\n  Yearly: { startOf: 'year', amount: 'years' },\n};\n\nexport class IndexPattern {\n  private dateLocale = 'en';\n\n  constructor(private pattern: string, private interval?: keyof typeof intervalMap) {}\n\n  getIndexForToday() {\n    if (this.interval) {\n      return toUtc().locale(this.dateLocale).format(this.pattern);\n    } else {\n      return this.pattern;\n    }\n  }\n\n  getIndexList(from?: DateTime, to?: DateTime) {\n    // When no `from` or `to` is provided, we request data from 7 subsequent/previous indices\n    // for the provided index pattern.\n    // This is useful when requesting log context where the only time data we have is the log\n    // timestamp.\n    const indexOffset = 7;\n    if (!this.interval) {\n      return this.pattern;\n    }\n\n    const intervalInfo = intervalMap[this.interval];\n    const start = dateTime(from || dateTime(to).add(-indexOffset, intervalInfo.amount))\n      .utc()\n      .startOf(intervalInfo.startOf);\n    const endEpoch = dateTime(to || dateTime(from).add(indexOffset, intervalInfo.amount))\n      .utc()\n      .startOf(intervalInfo.startOf)\n      .valueOf();\n    const indexList = [];\n\n    while (start.valueOf() <= endEpoch) {\n      indexList.push(start.locale(this.dateLocale).format(this.pattern));\n      start.add(1, intervalInfo.amount);\n    }\n\n    return indexList;\n  }\n}\n"],"mappings":";;AAAA,SAASA,KAAT,EAAgBC,QAAhB,QAAwD,eAAxD;AAYA,MAAMC,WAAwB,GAAG;EAC/BC,MAAM,EAAE;IAAEC,OAAO,EAAE,MAAX;IAAmBC,MAAM,EAAE;EAA3B,CADuB;EAE/BC,KAAK,EAAE;IAAEF,OAAO,EAAE,KAAX;IAAkBC,MAAM,EAAE;EAA1B,CAFwB;EAG/BE,MAAM,EAAE;IAAEH,OAAO,EAAE,SAAX;IAAsBC,MAAM,EAAE;EAA9B,CAHuB;EAI/BG,OAAO,EAAE;IAAEJ,OAAO,EAAE,OAAX;IAAoBC,MAAM,EAAE;EAA5B,CAJsB;EAK/BI,MAAM,EAAE;IAAEL,OAAO,EAAE,MAAX;IAAmBC,MAAM,EAAE;EAA3B;AALuB,CAAjC;AAQA,OAAO,MAAMK,YAAN,CAAmB;EAGxBC,WAAW,CAASC,OAAT,EAAkCC,QAAlC,EAAuE;IAAA,oCAF7D,IAE6D;;IAAA,KAA9DD,OAA8D,GAA9DA,OAA8D;IAAA,KAArCC,QAAqC,GAArCA,QAAqC;EAAE;;EAEpFC,gBAAgB,GAAG;IACjB,IAAI,KAAKD,QAAT,EAAmB;MACjB,OAAOb,KAAK,GAAGe,MAAR,CAAe,KAAKC,UAApB,EAAgCC,MAAhC,CAAuC,KAAKL,OAA5C,CAAP;IACD,CAFD,MAEO;MACL,OAAO,KAAKA,OAAZ;IACD;EACF;;EAEDM,YAAY,CAACC,IAAD,EAAkBC,EAAlB,EAAiC;IAC3C;IACA;IACA;IACA;IACA,MAAMC,WAAW,GAAG,CAApB;;IACA,IAAI,CAAC,KAAKR,QAAV,EAAoB;MAClB,OAAO,KAAKD,OAAZ;IACD;;IAED,MAAMU,YAAY,GAAGpB,WAAW,CAAC,KAAKW,QAAN,CAAhC;IACA,MAAMU,KAAK,GAAGtB,QAAQ,CAACkB,IAAI,IAAIlB,QAAQ,CAACmB,EAAD,CAAR,CAAaI,GAAb,CAAiB,CAACH,WAAlB,EAA+BC,YAAY,CAACjB,MAA5C,CAAT,CAAR,CACXoB,GADW,GAEXrB,OAFW,CAEHkB,YAAY,CAAClB,OAFV,CAAd;IAGA,MAAMsB,QAAQ,GAAGzB,QAAQ,CAACmB,EAAE,IAAInB,QAAQ,CAACkB,IAAD,CAAR,CAAeK,GAAf,CAAmBH,WAAnB,EAAgCC,YAAY,CAACjB,MAA7C,CAAP,CAAR,CACdoB,GADc,GAEdrB,OAFc,CAENkB,YAAY,CAAClB,OAFP,EAGduB,OAHc,EAAjB;IAIA,MAAMC,SAAS,GAAG,EAAlB;;IAEA,OAAOL,KAAK,CAACI,OAAN,MAAmBD,QAA1B,EAAoC;MAClCE,SAAS,CAACC,IAAV,CAAeN,KAAK,CAACR,MAAN,CAAa,KAAKC,UAAlB,EAA8BC,MAA9B,CAAqC,KAAKL,OAA1C,CAAf;MACAW,KAAK,CAACC,GAAN,CAAU,CAAV,EAAaF,YAAY,CAACjB,MAA1B;IACD;;IAED,OAAOuB,SAAP;EACD;;AAvCuB"},"metadata":{},"sourceType":"module"}