{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { FunctionalVector } from '../vector/FunctionalVector';\nimport { vectorToArray } from '../vector/vectorToArray';\nimport { guessFieldTypeFromNameAndValue, toDataFrameDTO } from './processDataFrame';\n/** @public */\n\nconst NOOP = v => v;\n\nclass ArrayPropertyVector {\n  constructor(source, prop) {\n    _defineProperty(this, \"converter\", NOOP);\n\n    this.source = source;\n    this.prop = prop;\n  }\n\n  get length() {\n    return this.source.length;\n  }\n\n  get(index) {\n    return this.converter(this.source[index][this.prop]);\n  }\n\n  toArray() {\n    return vectorToArray(this);\n  }\n\n  toJSON() {\n    return vectorToArray(this);\n  }\n\n}\n/**\n * The ArrayDataFrame takes an array of objects and presents it as a DataFrame\n *\n * @alpha\n */\n\n\nexport class ArrayDataFrame extends FunctionalVector {\n  constructor(source, names) {\n    super();\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"refId\", void 0);\n\n    _defineProperty(this, \"meta\", void 0);\n\n    _defineProperty(this, \"fields\", []);\n\n    _defineProperty(this, \"length\", 0);\n\n    this.source = source;\n    this.length = source.length;\n    const first = source.length ? source[0] : {};\n\n    if (names) {\n      this.fields = names.map(name => {\n        return {\n          name,\n          type: guessFieldTypeFromNameAndValue(name, first[name]),\n          config: {},\n          values: new ArrayPropertyVector(source, name)\n        };\n      });\n    } else {\n      this.setFieldsFromObject(first);\n    }\n  }\n  /**\n   * Add a field for each property in the object.  This will guess the type\n   */\n\n\n  setFieldsFromObject(obj) {\n    this.fields = Object.keys(obj).map(name => {\n      return {\n        name,\n        type: guessFieldTypeFromNameAndValue(name, obj[name]),\n        config: {},\n        values: new ArrayPropertyVector(this.source, name)\n      };\n    });\n  }\n  /**\n   * Configure how the object property is passed to the data frame\n   */\n\n\n  setFieldType(name, type, converter) {\n    let field = this.fields.find(f => f.name === name);\n\n    if (field) {\n      field.type = type;\n    } else {\n      field = {\n        name,\n        type,\n        config: {},\n        values: new ArrayPropertyVector(this.source, name)\n      };\n      this.fields.push(field);\n    }\n\n    field.values.converter = converter !== null && converter !== void 0 ? converter : NOOP;\n    return field;\n  }\n  /**\n   * Get an object with a property for each field in the DataFrame\n   */\n\n\n  get(idx) {\n    return this.source[idx];\n  }\n  /**\n   * The simplified JSON values used in JSON.stringify()\n   */\n\n\n  toJSON() {\n    return toDataFrameDTO(this);\n  }\n\n}","map":{"version":3,"names":["FunctionalVector","vectorToArray","guessFieldTypeFromNameAndValue","toDataFrameDTO","NOOP","v","ArrayPropertyVector","constructor","source","prop","length","get","index","converter","toArray","toJSON","ArrayDataFrame","names","first","fields","map","name","type","config","values","setFieldsFromObject","obj","Object","keys","setFieldType","field","find","f","push","idx"],"sources":["/home/soula/grafana/packages/grafana-data/src/dataframe/ArrayDataFrame.ts"],"sourcesContent":["import { Vector, QueryResultMeta } from '../types';\nimport { Field, FieldType, DataFrame } from '../types/dataFrame';\nimport { FunctionalVector } from '../vector/FunctionalVector';\nimport { vectorToArray } from '../vector/vectorToArray';\n\nimport { guessFieldTypeFromNameAndValue, toDataFrameDTO } from './processDataFrame';\n\n/** @public */\nexport type ValueConverter<T = any> = (val: any) => T;\n\nconst NOOP: ValueConverter = (v) => v;\n\nclass ArrayPropertyVector<T = any> implements Vector<T> {\n  converter = NOOP;\n\n  constructor(private source: any[], private prop: string) {}\n\n  get length(): number {\n    return this.source.length;\n  }\n\n  get(index: number): T {\n    return this.converter(this.source[index][this.prop]);\n  }\n\n  toArray(): T[] {\n    return vectorToArray(this);\n  }\n\n  toJSON(): T[] {\n    return vectorToArray(this);\n  }\n}\n\n/**\n * The ArrayDataFrame takes an array of objects and presents it as a DataFrame\n *\n * @alpha\n */\nexport class ArrayDataFrame<T = any> extends FunctionalVector<T> implements DataFrame {\n  name?: string;\n  refId?: string;\n  meta?: QueryResultMeta;\n\n  fields: Field[] = [];\n  length = 0;\n\n  constructor(private source: T[], names?: string[]) {\n    super();\n\n    this.length = source.length;\n    const first: any = source.length ? source[0] : {};\n    if (names) {\n      this.fields = names.map((name) => {\n        return {\n          name,\n          type: guessFieldTypeFromNameAndValue(name, first[name]),\n          config: {},\n          values: new ArrayPropertyVector(source, name),\n        };\n      });\n    } else {\n      this.setFieldsFromObject(first);\n    }\n  }\n\n  /**\n   * Add a field for each property in the object.  This will guess the type\n   */\n  setFieldsFromObject(obj: any) {\n    this.fields = Object.keys(obj).map((name) => {\n      return {\n        name,\n        type: guessFieldTypeFromNameAndValue(name, obj[name]),\n        config: {},\n        values: new ArrayPropertyVector(this.source, name),\n      };\n    });\n  }\n\n  /**\n   * Configure how the object property is passed to the data frame\n   */\n  setFieldType(name: string, type: FieldType, converter?: ValueConverter): Field {\n    let field = this.fields.find((f) => f.name === name);\n    if (field) {\n      field.type = type;\n    } else {\n      field = {\n        name,\n        type,\n        config: {},\n        values: new ArrayPropertyVector(this.source, name),\n      };\n      this.fields.push(field);\n    }\n    (field.values as any).converter = converter ?? NOOP;\n    return field;\n  }\n\n  /**\n   * Get an object with a property for each field in the DataFrame\n   */\n  get(idx: number): T {\n    return this.source[idx];\n  }\n\n  /**\n   * The simplified JSON values used in JSON.stringify()\n   */\n  toJSON() {\n    return toDataFrameDTO(this);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}