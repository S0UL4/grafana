{"ast":null,"code":"import { defaults } from 'lodash';\nimport { map } from 'rxjs/operators';\nimport { getTimeField } from '../../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../../field';\nimport { FieldType, NullValueMode } from '../../types';\nimport { BinaryOperationID, binaryOperators } from '../../utils/binaryOperators';\nimport { ArrayVector, BinaryOperationVector, ConstantVector } from '../../vector';\nimport { AsNumberVector } from '../../vector/AsNumberVector';\nimport { RowVector } from '../../vector/RowVector';\nimport { doStandardCalcs, fieldReducers, ReducerID } from '../fieldReducer';\nimport { getFieldMatcher } from '../matchers';\nimport { FieldMatcherID } from '../matchers/ids';\nimport { ensureColumnsTransformer } from './ensureColumns';\nimport { DataTransformerID } from './ids';\nimport { noopTransformer } from './noop';\nexport let CalculateFieldMode;\n\n(function (CalculateFieldMode) {\n  CalculateFieldMode[\"ReduceRow\"] = \"reduceRow\";\n  CalculateFieldMode[\"BinaryOperation\"] = \"binary\";\n})(CalculateFieldMode || (CalculateFieldMode = {}));\n\nconst defaultReduceOptions = {\n  reducer: ReducerID.sum\n};\nconst defaultBinaryOptions = {\n  left: '',\n  operator: BinaryOperationID.Add,\n  right: ''\n};\nexport const calculateFieldTransformer = {\n  id: DataTransformerID.calculateField,\n  name: 'Add field from calculation',\n  description: 'Use the row values to calculate a new field',\n  defaultOptions: {\n    mode: CalculateFieldMode.ReduceRow,\n    reduce: {\n      reducer: ReducerID.sum\n    }\n  },\n  operator: (options, replace) => outerSource => {\n    const operator = options && options.timeSeries !== false ? ensureColumnsTransformer.operator(null) : noopTransformer.operator({});\n    options.alias = replace ? replace(options.alias) : options.alias;\n    return outerSource.pipe(operator, map(data => {\n      var _options$mode;\n\n      const mode = (_options$mode = options.mode) !== null && _options$mode !== void 0 ? _options$mode : CalculateFieldMode.ReduceRow;\n      let creator = undefined;\n\n      if (mode === CalculateFieldMode.ReduceRow) {\n        creator = getReduceRowCreator(defaults(options.reduce, defaultReduceOptions), data);\n      } else if (mode === CalculateFieldMode.BinaryOperation) {\n        var _options$binary, _options$binary2, _options$binary3, _options$binary4;\n\n        const binaryOptions = replace ? Object.assign({}, options.binary, {\n          left: replace ? replace((_options$binary = options.binary) === null || _options$binary === void 0 ? void 0 : _options$binary.left) : (_options$binary2 = options.binary) === null || _options$binary2 === void 0 ? void 0 : _options$binary2.left,\n          right: replace ? replace((_options$binary3 = options.binary) === null || _options$binary3 === void 0 ? void 0 : _options$binary3.right) : (_options$binary4 = options.binary) === null || _options$binary4 === void 0 ? void 0 : _options$binary4.right\n        }) : options.binary;\n        creator = getBinaryCreator(defaults(binaryOptions, defaultBinaryOptions), data);\n      } // Nothing configured\n\n\n      if (!creator) {\n        return data;\n      }\n\n      return data.map(frame => {\n        // delegate field creation to the specific function\n        const values = creator(frame);\n\n        if (!values) {\n          return frame;\n        }\n\n        const field = {\n          name: getNameFromOptions(options),\n          type: FieldType.number,\n          config: {},\n          values\n        };\n        let fields = []; // Replace all fields with the single field\n\n        if (options.replaceFields) {\n          const {\n            timeField\n          } = getTimeField(frame);\n\n          if (timeField && options.timeSeries !== false) {\n            fields = [timeField, field];\n          } else {\n            fields = [field];\n          }\n        } else {\n          fields = [...frame.fields, field];\n        }\n\n        return Object.assign({}, frame, {\n          fields\n        });\n      });\n    }));\n  }\n};\n\nfunction getReduceRowCreator(options, allFrames) {\n  var _info$reduce;\n\n  let matcher = getFieldMatcher({\n    id: FieldMatcherID.numeric\n  });\n\n  if (options.include && options.include.length) {\n    matcher = getFieldMatcher({\n      id: FieldMatcherID.byNames,\n      options: {\n        names: options.include\n      }\n    });\n  }\n\n  const info = fieldReducers.get(options.reducer);\n\n  if (!info) {\n    throw new Error(`Unknown reducer: ${options.reducer}`);\n  }\n\n  const reducer = (_info$reduce = info.reduce) !== null && _info$reduce !== void 0 ? _info$reduce : doStandardCalcs;\n  const ignoreNulls = options.nullValueMode === NullValueMode.Ignore;\n  const nullAsZero = options.nullValueMode === NullValueMode.AsZero;\n  return frame => {\n    // Find the columns that should be examined\n    const columns = [];\n\n    for (const field of frame.fields) {\n      if (matcher(field, frame, allFrames)) {\n        columns.push(field.values);\n      }\n    } // Prepare a \"fake\" field for the row\n\n\n    const iter = new RowVector(columns);\n    const row = {\n      name: 'temp',\n      values: iter,\n      type: FieldType.number,\n      config: {}\n    };\n    const vals = [];\n\n    for (let i = 0; i < frame.length; i++) {\n      iter.rowIndex = i;\n      const val = reducer(row, ignoreNulls, nullAsZero)[options.reducer];\n      vals.push(val);\n    }\n\n    return new ArrayVector(vals);\n  };\n}\n\nfunction findFieldValuesWithNameOrConstant(frame, name, allFrames) {\n  if (!name) {\n    return undefined;\n  }\n\n  for (const f of frame.fields) {\n    if (name === getFieldDisplayName(f, frame, allFrames)) {\n      if (f.type === FieldType.boolean) {\n        return new AsNumberVector(f.values);\n      }\n\n      return f.values;\n    }\n  }\n\n  const v = parseFloat(name);\n\n  if (!isNaN(v)) {\n    return new ConstantVector(v, frame.length);\n  }\n\n  return undefined;\n}\n\nfunction getBinaryCreator(options, allFrames) {\n  const operator = binaryOperators.getIfExists(options.operator);\n  return frame => {\n    const left = findFieldValuesWithNameOrConstant(frame, options.left, allFrames);\n    const right = findFieldValuesWithNameOrConstant(frame, options.right, allFrames);\n\n    if (!left || !right || !operator) {\n      return undefined;\n    }\n\n    return new BinaryOperationVector(left, right, operator.operation);\n  };\n}\n\nexport function getNameFromOptions(options) {\n  var _options$alias;\n\n  if ((_options$alias = options.alias) !== null && _options$alias !== void 0 && _options$alias.length) {\n    return options.alias;\n  }\n\n  if (options.mode === CalculateFieldMode.BinaryOperation) {\n    var _binary$left, _binary$operator, _binary$right;\n\n    const {\n      binary\n    } = options;\n    return `${(_binary$left = binary === null || binary === void 0 ? void 0 : binary.left) !== null && _binary$left !== void 0 ? _binary$left : ''} ${(_binary$operator = binary === null || binary === void 0 ? void 0 : binary.operator) !== null && _binary$operator !== void 0 ? _binary$operator : ''} ${(_binary$right = binary === null || binary === void 0 ? void 0 : binary.right) !== null && _binary$right !== void 0 ? _binary$right : ''}`;\n  }\n\n  if (options.mode === CalculateFieldMode.ReduceRow) {\n    var _options$reduce;\n\n    const r = fieldReducers.getIfExists((_options$reduce = options.reduce) === null || _options$reduce === void 0 ? void 0 : _options$reduce.reducer);\n\n    if (r) {\n      return r.name;\n    }\n  }\n\n  return 'math';\n}","map":{"version":3,"names":["defaults","map","getTimeField","getFieldDisplayName","FieldType","NullValueMode","BinaryOperationID","binaryOperators","ArrayVector","BinaryOperationVector","ConstantVector","AsNumberVector","RowVector","doStandardCalcs","fieldReducers","ReducerID","getFieldMatcher","FieldMatcherID","ensureColumnsTransformer","DataTransformerID","noopTransformer","CalculateFieldMode","defaultReduceOptions","reducer","sum","defaultBinaryOptions","left","operator","Add","right","calculateFieldTransformer","id","calculateField","name","description","defaultOptions","mode","ReduceRow","reduce","options","replace","outerSource","timeSeries","alias","pipe","data","creator","undefined","getReduceRowCreator","BinaryOperation","binaryOptions","binary","getBinaryCreator","frame","values","field","getNameFromOptions","type","number","config","fields","replaceFields","timeField","allFrames","matcher","numeric","include","length","byNames","names","info","get","Error","ignoreNulls","nullValueMode","Ignore","nullAsZero","AsZero","columns","push","iter","row","vals","i","rowIndex","val","findFieldValuesWithNameOrConstant","f","boolean","v","parseFloat","isNaN","getIfExists","operation","r"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/calculateField.ts"],"sourcesContent":["import { defaults } from 'lodash';\nimport { map } from 'rxjs/operators';\n\nimport { getTimeField } from '../../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../../field';\nimport { DataFrame, DataTransformerInfo, Field, FieldType, NullValueMode, Vector } from '../../types';\nimport { BinaryOperationID, binaryOperators } from '../../utils/binaryOperators';\nimport { ArrayVector, BinaryOperationVector, ConstantVector } from '../../vector';\nimport { AsNumberVector } from '../../vector/AsNumberVector';\nimport { RowVector } from '../../vector/RowVector';\nimport { doStandardCalcs, fieldReducers, ReducerID } from '../fieldReducer';\nimport { getFieldMatcher } from '../matchers';\nimport { FieldMatcherID } from '../matchers/ids';\n\nimport { ensureColumnsTransformer } from './ensureColumns';\nimport { DataTransformerID } from './ids';\nimport { noopTransformer } from './noop';\n\nexport enum CalculateFieldMode {\n  ReduceRow = 'reduceRow',\n  BinaryOperation = 'binary',\n}\n\nexport interface ReduceOptions {\n  include?: string[]; // Assume all fields\n  reducer: ReducerID;\n  nullValueMode?: NullValueMode;\n}\n\nexport interface BinaryOptions {\n  left: string;\n  operator: BinaryOperationID;\n  right: string;\n}\n\nconst defaultReduceOptions: ReduceOptions = {\n  reducer: ReducerID.sum,\n};\n\nconst defaultBinaryOptions: BinaryOptions = {\n  left: '',\n  operator: BinaryOperationID.Add,\n  right: '',\n};\n\nexport interface CalculateFieldTransformerOptions {\n  // True/False or auto\n  timeSeries?: boolean;\n  mode: CalculateFieldMode; // defaults to 'reduce'\n\n  // Only one should be filled\n  reduce?: ReduceOptions;\n  binary?: BinaryOptions;\n\n  // Remove other fields\n  replaceFields?: boolean;\n\n  // Output field properties\n  alias?: string; // The output field name\n  // TODO: config?: FieldConfig; or maybe field overrides? since the UI exists\n}\n\ntype ValuesCreator = (data: DataFrame) => Vector;\n\nexport const calculateFieldTransformer: DataTransformerInfo<CalculateFieldTransformerOptions> = {\n  id: DataTransformerID.calculateField,\n  name: 'Add field from calculation',\n  description: 'Use the row values to calculate a new field',\n  defaultOptions: {\n    mode: CalculateFieldMode.ReduceRow,\n    reduce: {\n      reducer: ReducerID.sum,\n    },\n  },\n  operator: (options, replace) => (outerSource) => {\n    const operator =\n      options && options.timeSeries !== false ? ensureColumnsTransformer.operator(null) : noopTransformer.operator({});\n\n    options.alias = replace ? replace(options.alias) : options.alias;\n\n    return outerSource.pipe(\n      operator,\n      map((data) => {\n        const mode = options.mode ?? CalculateFieldMode.ReduceRow;\n        let creator: ValuesCreator | undefined = undefined;\n\n        if (mode === CalculateFieldMode.ReduceRow) {\n          creator = getReduceRowCreator(defaults(options.reduce, defaultReduceOptions), data);\n        } else if (mode === CalculateFieldMode.BinaryOperation) {\n          const binaryOptions = replace\n            ? {\n                ...options.binary,\n                left: replace ? replace(options.binary?.left) : options.binary?.left,\n                right: replace ? replace(options.binary?.right) : options.binary?.right,\n              }\n            : options.binary;\n          creator = getBinaryCreator(defaults(binaryOptions, defaultBinaryOptions), data);\n        }\n\n        // Nothing configured\n        if (!creator) {\n          return data;\n        }\n\n        return data.map((frame) => {\n          // delegate field creation to the specific function\n          const values = creator!(frame);\n          if (!values) {\n            return frame;\n          }\n\n          const field = {\n            name: getNameFromOptions(options),\n            type: FieldType.number,\n            config: {},\n            values,\n          };\n          let fields: Field[] = [];\n\n          // Replace all fields with the single field\n          if (options.replaceFields) {\n            const { timeField } = getTimeField(frame);\n            if (timeField && options.timeSeries !== false) {\n              fields = [timeField, field];\n            } else {\n              fields = [field];\n            }\n          } else {\n            fields = [...frame.fields, field];\n          }\n          return {\n            ...frame,\n            fields,\n          };\n        });\n      })\n    );\n  },\n};\n\nfunction getReduceRowCreator(options: ReduceOptions, allFrames: DataFrame[]): ValuesCreator {\n  let matcher = getFieldMatcher({\n    id: FieldMatcherID.numeric,\n  });\n\n  if (options.include && options.include.length) {\n    matcher = getFieldMatcher({\n      id: FieldMatcherID.byNames,\n      options: {\n        names: options.include,\n      },\n    });\n  }\n\n  const info = fieldReducers.get(options.reducer);\n\n  if (!info) {\n    throw new Error(`Unknown reducer: ${options.reducer}`);\n  }\n\n  const reducer = info.reduce ?? doStandardCalcs;\n  const ignoreNulls = options.nullValueMode === NullValueMode.Ignore;\n  const nullAsZero = options.nullValueMode === NullValueMode.AsZero;\n\n  return (frame: DataFrame) => {\n    // Find the columns that should be examined\n    const columns: Vector[] = [];\n    for (const field of frame.fields) {\n      if (matcher(field, frame, allFrames)) {\n        columns.push(field.values);\n      }\n    }\n\n    // Prepare a \"fake\" field for the row\n    const iter = new RowVector(columns);\n    const row: Field = {\n      name: 'temp',\n      values: iter,\n      type: FieldType.number,\n      config: {},\n    };\n    const vals: number[] = [];\n\n    for (let i = 0; i < frame.length; i++) {\n      iter.rowIndex = i;\n      const val = reducer(row, ignoreNulls, nullAsZero)[options.reducer];\n      vals.push(val);\n    }\n\n    return new ArrayVector(vals);\n  };\n}\n\nfunction findFieldValuesWithNameOrConstant(frame: DataFrame, name: string, allFrames: DataFrame[]): Vector | undefined {\n  if (!name) {\n    return undefined;\n  }\n\n  for (const f of frame.fields) {\n    if (name === getFieldDisplayName(f, frame, allFrames)) {\n      if (f.type === FieldType.boolean) {\n        return new AsNumberVector(f.values);\n      }\n      return f.values;\n    }\n  }\n\n  const v = parseFloat(name);\n  if (!isNaN(v)) {\n    return new ConstantVector(v, frame.length);\n  }\n\n  return undefined;\n}\n\nfunction getBinaryCreator(options: BinaryOptions, allFrames: DataFrame[]): ValuesCreator {\n  const operator = binaryOperators.getIfExists(options.operator);\n\n  return (frame: DataFrame) => {\n    const left = findFieldValuesWithNameOrConstant(frame, options.left, allFrames);\n    const right = findFieldValuesWithNameOrConstant(frame, options.right, allFrames);\n    if (!left || !right || !operator) {\n      return undefined as unknown as Vector;\n    }\n\n    return new BinaryOperationVector(left, right, operator.operation);\n  };\n}\n\nexport function getNameFromOptions(options: CalculateFieldTransformerOptions) {\n  if (options.alias?.length) {\n    return options.alias;\n  }\n\n  if (options.mode === CalculateFieldMode.BinaryOperation) {\n    const { binary } = options;\n    return `${binary?.left ?? ''} ${binary?.operator ?? ''} ${binary?.right ?? ''}`;\n  }\n\n  if (options.mode === CalculateFieldMode.ReduceRow) {\n    const r = fieldReducers.getIfExists(options.reduce?.reducer);\n    if (r) {\n      return r.name;\n    }\n  }\n\n  return 'math';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}