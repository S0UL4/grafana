{"ast":null,"code":"import { css } from '@emotion/css';\nimport { fromPairs } from 'lodash';\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { useAsyncFn, useMount, useMountedState } from 'react-use';\nimport { ButtonCascader, FileDropzone, InlineField, InlineFieldRow, RadioButtonGroup, useTheme2, QueryField, useStyles2 } from '@grafana/ui';\nimport { notifyApp } from 'app/core/actions';\nimport { createErrorNotification } from 'app/core/copy/appNotification';\nimport { dispatch } from 'app/store/store';\nimport { apiPrefix } from './constants';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\n\nconst getStyles = theme => {\n  return {\n    tracesCascader: css({\n      label: 'tracesCascader',\n      marginRight: theme.spacing(1)\n    })\n  };\n};\n\nexport const ZipkinQueryField = ({\n  query,\n  onChange,\n  onRunQuery,\n  datasource\n}) => {\n  const serviceOptions = useServices(datasource);\n  const theme = useTheme2();\n  const styles = useStyles2(getStyles);\n  const {\n    onLoadOptions,\n    allOptions\n  } = useLoadOptions(datasource);\n  const onSelectTrace = useCallback((values, selectedOptions) => {\n    if (selectedOptions.length === 3) {\n      const traceID = selectedOptions[2].value;\n      onChange(Object.assign({}, query, {\n        query: traceID\n      }));\n      onRunQuery();\n    }\n  }, [onChange, onRunQuery, query]);\n\n  const onChangeQuery = value => {\n    const nextQuery = Object.assign({}, query, {\n      query: value\n    });\n    onChange(nextQuery);\n  };\n\n  let cascaderOptions = useMapToCascaderOptions(serviceOptions, allOptions);\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [/*#__PURE__*/_jsx(InlineFieldRow, {\n      children: /*#__PURE__*/_jsx(InlineField, {\n        label: \"Query type\",\n        children: /*#__PURE__*/_jsx(RadioButtonGroup, {\n          options: [{\n            value: 'traceID',\n            label: 'TraceID'\n          }, {\n            value: 'upload',\n            label: 'JSON file'\n          }],\n          value: query.queryType || 'traceID',\n          onChange: v => onChange(Object.assign({}, query, {\n            queryType: v\n          })),\n          size: \"md\"\n        })\n      })\n    }), query.queryType === 'upload' ? /*#__PURE__*/_jsx(\"div\", {\n      className: css({\n        padding: theme.spacing(2)\n      }),\n      children: /*#__PURE__*/_jsx(FileDropzone, {\n        options: {\n          multiple: false\n        },\n        onLoad: result => {\n          datasource.uploadedJson = result;\n          onRunQuery();\n        }\n      })\n    }) : /*#__PURE__*/_jsxs(InlineFieldRow, {\n      children: [/*#__PURE__*/_jsx(ButtonCascader, {\n        options: cascaderOptions,\n        onChange: onSelectTrace,\n        loadData: onLoadOptions,\n        variant: \"secondary\",\n        buttonProps: {\n          className: styles.tracesCascader\n        },\n        children: \"Traces\"\n      }), /*#__PURE__*/_jsx(\"div\", {\n        className: \"gf-form gf-form--grow flex-shrink-1 min-width-15\",\n        children: /*#__PURE__*/_jsx(QueryField, {\n          query: query.query,\n          onChange: onChangeQuery,\n          onRunQuery: onRunQuery,\n          placeholder: 'Insert Trace ID (run with Shift+Enter)',\n          portalOrigin: \"zipkin\"\n        })\n      })]\n    })]\n  });\n}; // Exported for tests\n\nexport function useServices(datasource) {\n  const url = `${apiPrefix}/services`;\n  const [servicesOptions, fetch] = useAsyncFn(async () => {\n    try {\n      const services = await datasource.metadataRequest(url);\n\n      if (services) {\n        return services.sort().map(service => ({\n          label: service,\n          value: service,\n          isLeaf: false\n        }));\n      }\n\n      return [];\n    } catch (error) {\n      const errorToShow = error instanceof Error ? error : 'An unknown error occurred';\n      dispatch(notifyApp(createErrorNotification('Failed to load services from Zipkin', errorToShow)));\n      throw error;\n    }\n  }, [datasource]);\n  useMount(() => {\n    // We should probably call this periodically to get new services after mount.\n    fetch();\n  });\n  return servicesOptions;\n}\n// Exported for tests\nexport function useLoadOptions(datasource) {\n  const isMounted = useMountedState();\n  const [allOptions, setAllOptions] = useState({});\n  const [, fetchSpans] = useAsyncFn(async function findSpans(service) {\n    const url = `${apiPrefix}/spans`;\n\n    try {\n      // The response of this should have been full ZipkinSpan objects based on API docs but is just list\n      // of span names.\n      // TODO: check if this is some issue of version used or something else\n      const response = await datasource.metadataRequest(url, {\n        serviceName: service\n      });\n\n      if (isMounted()) {\n        setAllOptions(state => {\n          const spanOptions = fromPairs(response.map(span => [span, undefined]));\n          return Object.assign({}, state, {\n            [service]: spanOptions\n          });\n        });\n      }\n    } catch (error) {\n      const errorToShow = error instanceof Error ? error : 'An unknown error occurred';\n      dispatch(notifyApp(createErrorNotification('Failed to load spans from Zipkin', errorToShow)));\n      throw error;\n    }\n  }, [datasource, allOptions]);\n  const [, fetchTraces] = useAsyncFn(async function findTraces(serviceName, spanName) {\n    const url = `${apiPrefix}/traces`;\n    const search = {\n      serviceName,\n      spanName // See other params and default here https://zipkin.io/zipkin-api/#/default/get_traces\n\n    };\n\n    try {\n      // This should return just root traces as there isn't any nesting\n      const traces = await datasource.metadataRequest(url, search);\n\n      if (isMounted()) {\n        const newTraces = traces.length ? fromPairs(traces.map(trace => {\n          const rootSpan = trace.find(span => !span.parentId);\n          return [`${rootSpan.name} [${Math.floor(rootSpan.duration / 1000)} ms]`, rootSpan.traceId];\n        })) : noTracesOptions;\n        setAllOptions(state => {\n          const spans = state[serviceName];\n          return Object.assign({}, state, {\n            [serviceName]: Object.assign({}, spans, {\n              [spanName]: newTraces\n            })\n          });\n        });\n      }\n    } catch (error) {\n      const errorToShow = error instanceof Error ? error : 'An unknown error occurred';\n      dispatch(notifyApp(createErrorNotification('Failed to load spans from Zipkin', errorToShow)));\n      throw error;\n    }\n  }, [datasource]);\n  const onLoadOptions = useCallback(selectedOptions => {\n    const service = selectedOptions[0].value;\n\n    if (selectedOptions.length === 1) {\n      fetchSpans(service);\n    } else if (selectedOptions.length === 2) {\n      const spanName = selectedOptions[1].value;\n      fetchTraces(service, spanName);\n    }\n  }, [fetchSpans, fetchTraces]);\n  return {\n    onLoadOptions,\n    allOptions\n  };\n}\n\nfunction useMapToCascaderOptions(services, allOptions) {\n  return useMemo(() => {\n    let cascaderOptions = [];\n\n    if (services.value && services.value.length) {\n      cascaderOptions = services.value.map(services => {\n        return Object.assign({}, services, {\n          children: allOptions[services.value] && Object.keys(allOptions[services.value]).map(spanName => {\n            return {\n              label: spanName,\n              value: spanName,\n              isLeaf: false,\n              children: allOptions[services.value][spanName] && Object.keys(allOptions[services.value][spanName]).map(traceName => {\n                return {\n                  label: traceName,\n                  value: allOptions[services.value][spanName][traceName]\n                };\n              })\n            };\n          })\n        });\n      });\n    } else if (services.value && !services.value.length) {\n      cascaderOptions = noTracesFoundOptions;\n    }\n\n    return cascaderOptions;\n  }, [services, allOptions]);\n}\n\nconst NO_TRACES_KEY = '__NO_TRACES__';\nconst noTracesFoundOptions = [{\n  label: 'No traces found',\n  value: 'no_traces',\n  isLeaf: true // Cannot be disabled because then cascader shows 'loading' for some reason.\n  // disabled: true,\n\n}];\nconst noTracesOptions = {\n  '[No traces in time range]': NO_TRACES_KEY\n};","map":{"version":3,"names":["css","fromPairs","React","useCallback","useMemo","useState","useAsyncFn","useMount","useMountedState","ButtonCascader","FileDropzone","InlineField","InlineFieldRow","RadioButtonGroup","useTheme2","QueryField","useStyles2","notifyApp","createErrorNotification","dispatch","apiPrefix","getStyles","theme","tracesCascader","label","marginRight","spacing","ZipkinQueryField","query","onChange","onRunQuery","datasource","serviceOptions","useServices","styles","onLoadOptions","allOptions","useLoadOptions","onSelectTrace","values","selectedOptions","length","traceID","value","onChangeQuery","nextQuery","cascaderOptions","useMapToCascaderOptions","queryType","v","padding","multiple","result","uploadedJson","className","url","servicesOptions","fetch","services","metadataRequest","sort","map","service","isLeaf","error","errorToShow","Error","isMounted","setAllOptions","fetchSpans","findSpans","response","serviceName","state","spanOptions","span","undefined","fetchTraces","findTraces","spanName","search","traces","newTraces","trace","rootSpan","find","parentId","name","Math","floor","duration","traceId","noTracesOptions","spans","children","Object","keys","traceName","noTracesFoundOptions","NO_TRACES_KEY"],"sources":["/home/soula/grafana/public/app/plugins/datasource/zipkin/QueryField.tsx"],"sourcesContent":["import { css } from '@emotion/css';\nimport { fromPairs } from 'lodash';\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { useAsyncFn, useMount, useMountedState } from 'react-use';\nimport { AsyncState } from 'react-use/lib/useAsyncFn';\n\nimport { GrafanaTheme2, QueryEditorProps } from '@grafana/data';\nimport {\n  ButtonCascader,\n  CascaderOption,\n  FileDropzone,\n  InlineField,\n  InlineFieldRow,\n  RadioButtonGroup,\n  useTheme2,\n  QueryField,\n  useStyles2,\n} from '@grafana/ui';\nimport { notifyApp } from 'app/core/actions';\nimport { createErrorNotification } from 'app/core/copy/appNotification';\nimport { dispatch } from 'app/store/store';\n\nimport { apiPrefix } from './constants';\nimport { ZipkinDatasource } from './datasource';\nimport { ZipkinQuery, ZipkinQueryType, ZipkinSpan } from './types';\n\ntype Props = QueryEditorProps<ZipkinDatasource, ZipkinQuery>;\n\nconst getStyles = (theme: GrafanaTheme2) => {\n  return {\n    tracesCascader: css({\n      label: 'tracesCascader',\n      marginRight: theme.spacing(1),\n    }),\n  };\n};\n\nexport const ZipkinQueryField = ({ query, onChange, onRunQuery, datasource }: Props) => {\n  const serviceOptions = useServices(datasource);\n  const theme = useTheme2();\n  const styles = useStyles2(getStyles);\n  const { onLoadOptions, allOptions } = useLoadOptions(datasource);\n\n  const onSelectTrace = useCallback(\n    (values: string[], selectedOptions: CascaderOption[]) => {\n      if (selectedOptions.length === 3) {\n        const traceID = selectedOptions[2].value;\n        onChange({ ...query, query: traceID });\n        onRunQuery();\n      }\n    },\n    [onChange, onRunQuery, query]\n  );\n\n  const onChangeQuery = (value: string) => {\n    const nextQuery = { ...query, query: value };\n    onChange(nextQuery);\n  };\n\n  let cascaderOptions = useMapToCascaderOptions(serviceOptions, allOptions);\n\n  return (\n    <>\n      <InlineFieldRow>\n        <InlineField label=\"Query type\">\n          <RadioButtonGroup<ZipkinQueryType>\n            options={[\n              { value: 'traceID', label: 'TraceID' },\n              { value: 'upload', label: 'JSON file' },\n            ]}\n            value={query.queryType || 'traceID'}\n            onChange={(v) =>\n              onChange({\n                ...query,\n                queryType: v,\n              })\n            }\n            size=\"md\"\n          />\n        </InlineField>\n      </InlineFieldRow>\n      {query.queryType === 'upload' ? (\n        <div className={css({ padding: theme.spacing(2) })}>\n          <FileDropzone\n            options={{ multiple: false }}\n            onLoad={(result) => {\n              datasource.uploadedJson = result;\n              onRunQuery();\n            }}\n          />\n        </div>\n      ) : (\n        <InlineFieldRow>\n          <ButtonCascader\n            options={cascaderOptions}\n            onChange={onSelectTrace}\n            loadData={onLoadOptions}\n            variant=\"secondary\"\n            buttonProps={{ className: styles.tracesCascader }}\n          >\n            Traces\n          </ButtonCascader>\n          <div className=\"gf-form gf-form--grow flex-shrink-1 min-width-15\">\n            <QueryField\n              query={query.query}\n              onChange={onChangeQuery}\n              onRunQuery={onRunQuery}\n              placeholder={'Insert Trace ID (run with Shift+Enter)'}\n              portalOrigin=\"zipkin\"\n            />\n          </div>\n        </InlineFieldRow>\n      )}\n    </>\n  );\n};\n\n// Exported for tests\nexport function useServices(datasource: ZipkinDatasource): AsyncState<CascaderOption[]> {\n  const url = `${apiPrefix}/services`;\n\n  const [servicesOptions, fetch] = useAsyncFn(async (): Promise<CascaderOption[]> => {\n    try {\n      const services: string[] | null = await datasource.metadataRequest(url);\n      if (services) {\n        return services.sort().map((service) => ({\n          label: service,\n          value: service,\n          isLeaf: false,\n        }));\n      }\n      return [];\n    } catch (error) {\n      const errorToShow = error instanceof Error ? error : 'An unknown error occurred';\n      dispatch(notifyApp(createErrorNotification('Failed to load services from Zipkin', errorToShow)));\n      throw error;\n    }\n  }, [datasource]);\n\n  useMount(() => {\n    // We should probably call this periodically to get new services after mount.\n    fetch();\n  });\n\n  return servicesOptions;\n}\n\ntype OptionsState = {\n  [serviceName: string]: {\n    [spanName: string]: {\n      [traceId: string]: string;\n    };\n  };\n};\n\n// Exported for tests\nexport function useLoadOptions(datasource: ZipkinDatasource) {\n  const isMounted = useMountedState();\n  const [allOptions, setAllOptions] = useState({} as OptionsState);\n\n  const [, fetchSpans] = useAsyncFn(\n    async function findSpans(service: string): Promise<void> {\n      const url = `${apiPrefix}/spans`;\n      try {\n        // The response of this should have been full ZipkinSpan objects based on API docs but is just list\n        // of span names.\n        // TODO: check if this is some issue of version used or something else\n        const response: string[] = await datasource.metadataRequest(url, { serviceName: service });\n        if (isMounted()) {\n          setAllOptions((state) => {\n            const spanOptions = fromPairs(response.map((span: string) => [span, undefined]));\n            return {\n              ...state,\n              [service]: spanOptions as any,\n            };\n          });\n        }\n      } catch (error) {\n        const errorToShow = error instanceof Error ? error : 'An unknown error occurred';\n        dispatch(notifyApp(createErrorNotification('Failed to load spans from Zipkin', errorToShow)));\n        throw error;\n      }\n    },\n    [datasource, allOptions]\n  );\n\n  const [, fetchTraces] = useAsyncFn(\n    async function findTraces(serviceName: string, spanName: string): Promise<void> {\n      const url = `${apiPrefix}/traces`;\n      const search = {\n        serviceName,\n        spanName,\n        // See other params and default here https://zipkin.io/zipkin-api/#/default/get_traces\n      };\n      try {\n        // This should return just root traces as there isn't any nesting\n        const traces: ZipkinSpan[][] = await datasource.metadataRequest(url, search);\n        if (isMounted()) {\n          const newTraces = traces.length\n            ? fromPairs(\n                traces.map((trace) => {\n                  const rootSpan = trace.find((span) => !span.parentId)!;\n\n                  return [`${rootSpan.name} [${Math.floor(rootSpan.duration / 1000)} ms]`, rootSpan.traceId];\n                })\n              )\n            : noTracesOptions;\n\n          setAllOptions((state) => {\n            const spans = state[serviceName];\n            return {\n              ...state,\n              [serviceName]: {\n                ...spans,\n                [spanName]: newTraces,\n              },\n            };\n          });\n        }\n      } catch (error) {\n        const errorToShow = error instanceof Error ? error : 'An unknown error occurred';\n        dispatch(notifyApp(createErrorNotification('Failed to load spans from Zipkin', errorToShow)));\n        throw error;\n      }\n    },\n    [datasource]\n  );\n\n  const onLoadOptions = useCallback(\n    (selectedOptions: CascaderOption[]) => {\n      const service = selectedOptions[0].value;\n      if (selectedOptions.length === 1) {\n        fetchSpans(service);\n      } else if (selectedOptions.length === 2) {\n        const spanName = selectedOptions[1].value;\n        fetchTraces(service, spanName);\n      }\n    },\n    [fetchSpans, fetchTraces]\n  );\n\n  return {\n    onLoadOptions,\n    allOptions,\n  };\n}\n\nfunction useMapToCascaderOptions(services: AsyncState<CascaderOption[]>, allOptions: OptionsState) {\n  return useMemo(() => {\n    let cascaderOptions: CascaderOption[] = [];\n\n    if (services.value && services.value.length) {\n      cascaderOptions = services.value.map((services) => {\n        return {\n          ...services,\n          children:\n            allOptions[services.value] &&\n            Object.keys(allOptions[services.value]).map((spanName) => {\n              return {\n                label: spanName,\n                value: spanName,\n                isLeaf: false,\n                children:\n                  allOptions[services.value][spanName] &&\n                  Object.keys(allOptions[services.value][spanName]).map((traceName) => {\n                    return {\n                      label: traceName,\n                      value: allOptions[services.value][spanName][traceName],\n                    };\n                  }),\n              };\n            }),\n        };\n      });\n    } else if (services.value && !services.value.length) {\n      cascaderOptions = noTracesFoundOptions;\n    }\n\n    return cascaderOptions;\n  }, [services, allOptions]);\n}\n\nconst NO_TRACES_KEY = '__NO_TRACES__';\nconst noTracesFoundOptions = [\n  {\n    label: 'No traces found',\n    value: 'no_traces',\n    isLeaf: true,\n\n    // Cannot be disabled because then cascader shows 'loading' for some reason.\n    // disabled: true,\n  },\n];\n\nconst noTracesOptions = {\n  '[No traces in time range]': NO_TRACES_KEY,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}