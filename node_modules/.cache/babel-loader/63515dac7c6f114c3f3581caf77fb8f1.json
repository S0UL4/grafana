{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { from } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { AlertState } from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { Annotation } from 'app/features/alerting/unified/utils/constants';\nimport { isAlertingRule } from 'app/features/alerting/unified/utils/rules';\nimport { AccessControlAction } from 'app/types';\nimport { PromAlertingRuleState } from 'app/types/unified-alerting-dto';\nimport { emptyResult, handleDashboardQueryRunnerWorkerError } from './utils';\nexport class UnifiedAlertStatesWorker {\n  constructor() {\n    _defineProperty(this, \"hasAlertRules\", {});\n  }\n\n  canWork({\n    dashboard,\n    range\n  }) {\n    if (!dashboard.uid) {\n      return false;\n    }\n\n    if (range.raw.to !== 'now') {\n      return false;\n    }\n\n    if (this.hasAlertRules[dashboard.uid] === false) {\n      return false;\n    }\n\n    const hasRuleReadPermission = contextSrv.hasPermission(AccessControlAction.AlertingRuleRead) && contextSrv.hasPermission(AccessControlAction.AlertingRuleExternalRead);\n\n    if (!hasRuleReadPermission) {\n      return false;\n    }\n\n    return true;\n  }\n\n  work(options) {\n    if (!this.canWork(options)) {\n      return emptyResult();\n    }\n\n    const {\n      dashboard\n    } = options;\n    return from(getBackendSrv().get('/api/prometheus/grafana/api/v1/rules', {\n      dashboard_uid: dashboard.uid\n    }, `dashboard-query-runner-unified-alert-states-${dashboard.id}`)).pipe(map(result => {\n      if (result.status === 'success') {\n        this.hasAlertRules[dashboard.uid] = false;\n        const panelIdToAlertState = {};\n        result.data.groups.forEach(group => group.rules.forEach(rule => {\n          if (isAlertingRule(rule) && rule.annotations && rule.annotations[Annotation.panelID]) {\n            this.hasAlertRules[dashboard.uid] = true;\n            const panelId = Number(rule.annotations[Annotation.panelID]);\n            const state = promAlertStateToAlertState(rule.state); // there can be multiple alerts per panel, so we make sure we get the most severe state:\n            // alerting > pending > ok\n\n            if (!panelIdToAlertState[panelId]) {\n              panelIdToAlertState[panelId] = {\n                state,\n                id: Object.keys(panelIdToAlertState).length,\n                panelId,\n                dashboardId: dashboard.id\n              };\n            } else if (state === AlertState.Alerting && panelIdToAlertState[panelId].state !== AlertState.Alerting) {\n              panelIdToAlertState[panelId].state = AlertState.Alerting;\n            } else if (state === AlertState.Pending && panelIdToAlertState[panelId].state !== AlertState.Alerting && panelIdToAlertState[panelId].state !== AlertState.Pending) {\n              panelIdToAlertState[panelId].state = AlertState.Pending;\n            }\n          }\n        }));\n        return {\n          alertStates: Object.values(panelIdToAlertState),\n          annotations: []\n        };\n      }\n\n      throw new Error(`Unexpected alert rules response.`);\n    }), catchError(handleDashboardQueryRunnerWorkerError));\n  }\n\n}\n\nfunction promAlertStateToAlertState(state) {\n  if (state === PromAlertingRuleState.Firing) {\n    return AlertState.Alerting;\n  } else if (state === PromAlertingRuleState.Pending) {\n    return AlertState.Pending;\n  }\n\n  return AlertState.OK;\n}","map":{"version":3,"names":["from","catchError","map","AlertState","getBackendSrv","contextSrv","Annotation","isAlertingRule","AccessControlAction","PromAlertingRuleState","emptyResult","handleDashboardQueryRunnerWorkerError","UnifiedAlertStatesWorker","canWork","dashboard","range","uid","raw","to","hasAlertRules","hasRuleReadPermission","hasPermission","AlertingRuleRead","AlertingRuleExternalRead","work","options","get","dashboard_uid","id","pipe","result","status","panelIdToAlertState","data","groups","forEach","group","rules","rule","annotations","panelID","panelId","Number","state","promAlertStateToAlertState","Object","keys","length","dashboardId","Alerting","Pending","alertStates","values","Error","Firing","OK"],"sources":["/home/soula/grafana/public/app/features/query/state/DashboardQueryRunner/UnifiedAlertStatesWorker.ts"],"sourcesContent":["import { from, Observable } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\n\nimport { AlertState, AlertStateInfo } from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { Annotation } from 'app/features/alerting/unified/utils/constants';\nimport { isAlertingRule } from 'app/features/alerting/unified/utils/rules';\nimport { AccessControlAction } from 'app/types';\nimport { PromAlertingRuleState, PromRulesResponse } from 'app/types/unified-alerting-dto';\n\nimport { DashboardQueryRunnerOptions, DashboardQueryRunnerWorker, DashboardQueryRunnerWorkerResult } from './types';\nimport { emptyResult, handleDashboardQueryRunnerWorkerError } from './utils';\n\nexport class UnifiedAlertStatesWorker implements DashboardQueryRunnerWorker {\n  // maps dashboard uid to wether it has alert rules.\n  // if it is determined that a dashboard does not have alert rules,\n  // further attempts to get alert states for it will not be made\n  private hasAlertRules: Record<string, boolean> = {};\n\n  canWork({ dashboard, range }: DashboardQueryRunnerOptions): boolean {\n    if (!dashboard.uid) {\n      return false;\n    }\n\n    if (range.raw.to !== 'now') {\n      return false;\n    }\n\n    if (this.hasAlertRules[dashboard.uid] === false) {\n      return false;\n    }\n\n    const hasRuleReadPermission =\n      contextSrv.hasPermission(AccessControlAction.AlertingRuleRead) &&\n      contextSrv.hasPermission(AccessControlAction.AlertingRuleExternalRead);\n\n    if (!hasRuleReadPermission) {\n      return false;\n    }\n\n    return true;\n  }\n\n  work(options: DashboardQueryRunnerOptions): Observable<DashboardQueryRunnerWorkerResult> {\n    if (!this.canWork(options)) {\n      return emptyResult();\n    }\n\n    const { dashboard } = options;\n    return from(\n      getBackendSrv().get(\n        '/api/prometheus/grafana/api/v1/rules',\n        {\n          dashboard_uid: dashboard.uid,\n        },\n        `dashboard-query-runner-unified-alert-states-${dashboard.id}`\n      )\n    ).pipe(\n      map((result: PromRulesResponse) => {\n        if (result.status === 'success') {\n          this.hasAlertRules[dashboard.uid] = false;\n          const panelIdToAlertState: Record<number, AlertStateInfo> = {};\n          result.data.groups.forEach((group) =>\n            group.rules.forEach((rule) => {\n              if (isAlertingRule(rule) && rule.annotations && rule.annotations[Annotation.panelID]) {\n                this.hasAlertRules[dashboard.uid] = true;\n                const panelId = Number(rule.annotations[Annotation.panelID]);\n                const state = promAlertStateToAlertState(rule.state);\n\n                // there can be multiple alerts per panel, so we make sure we get the most severe state:\n                // alerting > pending > ok\n                if (!panelIdToAlertState[panelId]) {\n                  panelIdToAlertState[panelId] = {\n                    state,\n                    id: Object.keys(panelIdToAlertState).length,\n                    panelId,\n                    dashboardId: dashboard.id,\n                  };\n                } else if (\n                  state === AlertState.Alerting &&\n                  panelIdToAlertState[panelId].state !== AlertState.Alerting\n                ) {\n                  panelIdToAlertState[panelId].state = AlertState.Alerting;\n                } else if (\n                  state === AlertState.Pending &&\n                  panelIdToAlertState[panelId].state !== AlertState.Alerting &&\n                  panelIdToAlertState[panelId].state !== AlertState.Pending\n                ) {\n                  panelIdToAlertState[panelId].state = AlertState.Pending;\n                }\n              }\n            })\n          );\n          return { alertStates: Object.values(panelIdToAlertState), annotations: [] };\n        }\n        throw new Error(`Unexpected alert rules response.`);\n      }),\n      catchError(handleDashboardQueryRunnerWorkerError)\n    );\n  }\n}\n\nfunction promAlertStateToAlertState(state: PromAlertingRuleState): AlertState {\n  if (state === PromAlertingRuleState.Firing) {\n    return AlertState.Alerting;\n  } else if (state === PromAlertingRuleState.Pending) {\n    return AlertState.Pending;\n  }\n  return AlertState.OK;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}