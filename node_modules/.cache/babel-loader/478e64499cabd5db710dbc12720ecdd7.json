{"ast":null,"code":"import { FieldType, MutableDataFrame } from '@grafana/data';\nimport { transformTraceData } from '@jaegertracing/jaeger-ui-components';\nexport function createTraceFrame(data) {\n  const spans = data.spans.map(s => toSpanRow(s, data.processes));\n  const frame = new MutableDataFrame({\n    fields: [{\n      name: 'traceID',\n      type: FieldType.string\n    }, {\n      name: 'spanID',\n      type: FieldType.string\n    }, {\n      name: 'parentSpanID',\n      type: FieldType.string\n    }, {\n      name: 'operationName',\n      type: FieldType.string\n    }, {\n      name: 'serviceName',\n      type: FieldType.string\n    }, {\n      name: 'serviceTags',\n      type: FieldType.other\n    }, {\n      name: 'startTime',\n      type: FieldType.number\n    }, {\n      name: 'duration',\n      type: FieldType.number\n    }, {\n      name: 'logs',\n      type: FieldType.other\n    }, {\n      name: 'tags',\n      type: FieldType.other\n    }, {\n      name: 'warnings',\n      type: FieldType.other\n    }, {\n      name: 'stackTraces',\n      type: FieldType.other\n    }],\n    meta: {\n      preferredVisualisationType: 'trace',\n      custom: {\n        traceFormat: 'jaeger'\n      }\n    }\n  });\n\n  for (const span of spans) {\n    frame.add(span);\n  }\n\n  return frame;\n}\n\nfunction toSpanRow(span, processes) {\n  var _span$references, _span$references$find, _span$warnings;\n\n  return {\n    spanID: span.spanID,\n    traceID: span.traceID,\n    parentSpanID: (_span$references = span.references) === null || _span$references === void 0 ? void 0 : (_span$references$find = _span$references.find(r => r.refType === 'CHILD_OF')) === null || _span$references$find === void 0 ? void 0 : _span$references$find.spanID,\n    operationName: span.operationName,\n    // from micro to millis\n    startTime: span.startTime / 1000,\n    duration: span.duration / 1000,\n    logs: span.logs.map(l => Object.assign({}, l, {\n      timestamp: l.timestamp / 1000\n    })),\n    tags: span.tags,\n    warnings: (_span$warnings = span.warnings) !== null && _span$warnings !== void 0 ? _span$warnings : undefined,\n    stackTraces: span.stackTraces,\n    serviceName: processes[span.processID].serviceName,\n    serviceTags: processes[span.processID].tags\n  };\n}\n\nexport function createTableFrame(data, instanceSettings) {\n  const frame = new MutableDataFrame({\n    fields: [{\n      name: 'traceID',\n      type: FieldType.string,\n      config: {\n        unit: 'string',\n        displayNameFromDS: 'Trace ID',\n        links: [{\n          title: 'Trace: ${__value.raw}',\n          url: '',\n          internal: {\n            datasourceUid: instanceSettings.uid,\n            datasourceName: instanceSettings.name,\n            query: {\n              query: '${__value.raw}'\n            }\n          }\n        }]\n      }\n    }, {\n      name: 'traceName',\n      type: FieldType.string,\n      config: {\n        displayNameFromDS: 'Trace name'\n      }\n    }, {\n      name: 'startTime',\n      type: FieldType.time,\n      config: {\n        displayNameFromDS: 'Start time'\n      }\n    }, {\n      name: 'duration',\n      type: FieldType.number,\n      config: {\n        displayNameFromDS: 'Duration',\n        unit: 'µs'\n      }\n    }],\n    meta: {\n      preferredVisualisationType: 'table'\n    }\n  }); // Show the most recent traces\n\n  const traceData = data.map(transformToTraceData).sort((a, b) => (b === null || b === void 0 ? void 0 : b.startTime) - (a === null || a === void 0 ? void 0 : a.startTime));\n\n  for (const trace of traceData) {\n    frame.add(trace);\n  }\n\n  return frame;\n}\n\nfunction transformToTraceData(data) {\n  const traceData = transformTraceData(data);\n\n  if (!traceData) {\n    return;\n  }\n\n  return {\n    traceID: traceData.traceID,\n    startTime: traceData.startTime / 1000,\n    duration: traceData.duration,\n    traceName: traceData.traceName\n  };\n}\n\nexport function transformToJaeger(data) {\n  let traceResponse = {\n    traceID: '',\n    spans: [],\n    processes: {},\n    warnings: null\n  };\n  let processes = [];\n\n  for (let i = 0; i < data.length; i++) {\n    const span = data.get(i); // Set traceID\n\n    if (!traceResponse.traceID) {\n      traceResponse.traceID = span.traceID;\n    } // Create process if doesn't exist\n\n\n    if (!processes.find(p => p === span.serviceName)) {\n      processes.push(span.serviceName);\n      traceResponse.processes[`p${processes.length}`] = {\n        serviceName: span.serviceName,\n        tags: span.serviceTags\n      };\n    } // Create span\n\n\n    traceResponse.spans.push({\n      traceID: span.traceID,\n      spanID: span.spanID,\n      duration: span.duration * 1000,\n      references: span.parentSpanID ? [{\n        refType: 'CHILD_OF',\n        spanID: span.parentSpanID,\n        traceID: span.traceID\n      }] : [],\n      flags: 0,\n      logs: span.logs.map(l => Object.assign({}, l, {\n        timestamp: l.timestamp * 1000\n      })),\n      operationName: span.operationName,\n      processID: Object.keys(traceResponse.processes).find(key => traceResponse.processes[key].serviceName === span.serviceName) || '',\n      startTime: span.startTime * 1000,\n      tags: span.tags,\n      warnings: span.warnings ? span.warnings : null\n    });\n  }\n\n  return {\n    data: [traceResponse],\n    total: 0,\n    limit: 0,\n    offset: 0,\n    errors: null\n  };\n}","map":{"version":3,"names":["FieldType","MutableDataFrame","transformTraceData","createTraceFrame","data","spans","map","s","toSpanRow","processes","frame","fields","name","type","string","other","number","meta","preferredVisualisationType","custom","traceFormat","span","add","spanID","traceID","parentSpanID","references","find","r","refType","operationName","startTime","duration","logs","l","timestamp","tags","warnings","undefined","stackTraces","serviceName","processID","serviceTags","createTableFrame","instanceSettings","config","unit","displayNameFromDS","links","title","url","internal","datasourceUid","uid","datasourceName","query","time","traceData","transformToTraceData","sort","a","b","trace","traceName","transformToJaeger","traceResponse","i","length","get","p","push","flags","Object","keys","key","total","limit","offset","errors"],"sources":["/home/soula/grafana/public/app/plugins/datasource/jaeger/responseTransform.ts"],"sourcesContent":["import {\n  DataFrame,\n  DataSourceInstanceSettings,\n  FieldType,\n  MutableDataFrame,\n  TraceLog,\n  TraceSpanRow,\n} from '@grafana/data';\nimport { transformTraceData } from '@jaegertracing/jaeger-ui-components';\n\nimport { JaegerResponse, Span, TraceProcess, TraceResponse } from './types';\n\nexport function createTraceFrame(data: TraceResponse): DataFrame {\n  const spans = data.spans.map((s) => toSpanRow(s, data.processes));\n\n  const frame = new MutableDataFrame({\n    fields: [\n      { name: 'traceID', type: FieldType.string },\n      { name: 'spanID', type: FieldType.string },\n      { name: 'parentSpanID', type: FieldType.string },\n      { name: 'operationName', type: FieldType.string },\n      { name: 'serviceName', type: FieldType.string },\n      { name: 'serviceTags', type: FieldType.other },\n      { name: 'startTime', type: FieldType.number },\n      { name: 'duration', type: FieldType.number },\n      { name: 'logs', type: FieldType.other },\n      { name: 'tags', type: FieldType.other },\n      { name: 'warnings', type: FieldType.other },\n      { name: 'stackTraces', type: FieldType.other },\n    ],\n    meta: {\n      preferredVisualisationType: 'trace',\n      custom: {\n        traceFormat: 'jaeger',\n      },\n    },\n  });\n\n  for (const span of spans) {\n    frame.add(span);\n  }\n\n  return frame;\n}\n\nfunction toSpanRow(span: Span, processes: Record<string, TraceProcess>): TraceSpanRow {\n  return {\n    spanID: span.spanID,\n    traceID: span.traceID,\n    parentSpanID: span.references?.find((r) => r.refType === 'CHILD_OF')?.spanID,\n    operationName: span.operationName,\n    // from micro to millis\n    startTime: span.startTime / 1000,\n    duration: span.duration / 1000,\n    logs: span.logs.map((l) => ({\n      ...l,\n      timestamp: l.timestamp / 1000,\n    })),\n    tags: span.tags,\n    warnings: span.warnings ?? undefined,\n    stackTraces: span.stackTraces,\n    serviceName: processes[span.processID].serviceName,\n    serviceTags: processes[span.processID].tags,\n  };\n}\n\nexport function createTableFrame(data: TraceResponse[], instanceSettings: DataSourceInstanceSettings): DataFrame {\n  const frame = new MutableDataFrame({\n    fields: [\n      {\n        name: 'traceID',\n        type: FieldType.string,\n        config: {\n          unit: 'string',\n          displayNameFromDS: 'Trace ID',\n          links: [\n            {\n              title: 'Trace: ${__value.raw}',\n              url: '',\n              internal: {\n                datasourceUid: instanceSettings.uid,\n                datasourceName: instanceSettings.name,\n                query: {\n                  query: '${__value.raw}',\n                },\n              },\n            },\n          ],\n        },\n      },\n      { name: 'traceName', type: FieldType.string, config: { displayNameFromDS: 'Trace name' } },\n      { name: 'startTime', type: FieldType.time, config: { displayNameFromDS: 'Start time' } },\n      { name: 'duration', type: FieldType.number, config: { displayNameFromDS: 'Duration', unit: 'µs' } },\n    ],\n    meta: {\n      preferredVisualisationType: 'table',\n    },\n  });\n  // Show the most recent traces\n  const traceData = data.map(transformToTraceData).sort((a, b) => b?.startTime! - a?.startTime!);\n\n  for (const trace of traceData) {\n    frame.add(trace);\n  }\n\n  return frame;\n}\n\nfunction transformToTraceData(data: TraceResponse) {\n  const traceData = transformTraceData(data);\n  if (!traceData) {\n    return;\n  }\n\n  return {\n    traceID: traceData.traceID,\n    startTime: traceData.startTime / 1000,\n    duration: traceData.duration,\n    traceName: traceData.traceName,\n  };\n}\n\nexport function transformToJaeger(data: MutableDataFrame): JaegerResponse {\n  let traceResponse: TraceResponse = {\n    traceID: '',\n    spans: [],\n    processes: {},\n    warnings: null,\n  };\n  let processes: string[] = [];\n\n  for (let i = 0; i < data.length; i++) {\n    const span = data.get(i);\n\n    // Set traceID\n    if (!traceResponse.traceID) {\n      traceResponse.traceID = span.traceID;\n    }\n\n    // Create process if doesn't exist\n    if (!processes.find((p) => p === span.serviceName)) {\n      processes.push(span.serviceName);\n      traceResponse.processes[`p${processes.length}`] = {\n        serviceName: span.serviceName,\n        tags: span.serviceTags,\n      };\n    }\n\n    // Create span\n    traceResponse.spans.push({\n      traceID: span.traceID,\n      spanID: span.spanID,\n      duration: span.duration * 1000,\n      references: span.parentSpanID\n        ? [\n            {\n              refType: 'CHILD_OF',\n              spanID: span.parentSpanID,\n              traceID: span.traceID,\n            },\n          ]\n        : [],\n      flags: 0,\n      logs: span.logs.map((l: TraceLog) => ({\n        ...l,\n        timestamp: l.timestamp * 1000,\n      })),\n      operationName: span.operationName,\n      processID:\n        Object.keys(traceResponse.processes).find(\n          (key) => traceResponse.processes[key].serviceName === span.serviceName\n        ) || '',\n      startTime: span.startTime * 1000,\n      tags: span.tags,\n      warnings: span.warnings ? span.warnings : null,\n    });\n  }\n\n  return { data: [traceResponse], total: 0, limit: 0, offset: 0, errors: null };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}