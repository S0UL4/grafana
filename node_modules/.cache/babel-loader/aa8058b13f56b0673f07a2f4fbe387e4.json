{"ast":null,"code":"import { getTemplateSrv } from '@grafana/runtime';\nimport GraphiteQuery from '../graphite_query';\nimport { actions } from './actions';\nimport { addSeriesByTagFunc, buildSegments, checkOtherSegments, emptySegments, handleTargetChanged, parseTarget, pause, removeTagPrefix, smartlyHandleNewAliasByNode, spliceSegments } from './helpers';\n\nconst reducer = async (action, state) => {\n  state = Object.assign({}, state);\n\n  if (actions.init.match(action)) {\n    const deps = action.payload;\n    deps.target.target = deps.target.target || '';\n    await deps.datasource.waitForFuncDefsLoaded();\n    state = Object.assign({}, state, deps, {\n      queryModel: new GraphiteQuery(deps.datasource, deps.target, getTemplateSrv()),\n      supportsTags: deps.datasource.supportsTags,\n      paused: false,\n      removeTagValue: '-- remove tag --',\n      funcDefs: deps.datasource.funcDefs,\n      queries: deps.queries\n    });\n    await buildSegments(state, false);\n  }\n\n  if (actions.timeRangeChanged.match(action)) {\n    state.range = action.payload;\n  }\n\n  if (actions.queriesChanged.match(action)) {\n    state.queries = action.payload;\n    handleTargetChanged(state);\n  }\n\n  if (actions.queryChanged.match(action)) {\n    state.target.target = action.payload.target || '';\n    await parseTarget(state);\n    handleTargetChanged(state);\n  }\n\n  if (actions.segmentValueChanged.match(action)) {\n    const {\n      segment: segmentOrString,\n      index: segmentIndex\n    } = action.payload;\n    let segment; // is segment was changed to a string - create a new segment\n\n    if (typeof segmentOrString === 'string') {\n      segment = {\n        value: segmentOrString,\n        expandable: true,\n        fake: false\n      };\n    } else {\n      segment = segmentOrString;\n    }\n\n    state.error = null;\n    state.segments[segmentIndex] = segment;\n    state.queryModel.updateSegmentValue(segment, segmentIndex);\n\n    if (state.queryModel.functions.length > 0 && state.queryModel.functions[0].def.fake) {\n      state.queryModel.functions = [];\n    }\n\n    if (segment.type === 'tag') {\n      const tag = removeTagPrefix(segment.value);\n      pause(state);\n      await addSeriesByTagFunc(state, tag);\n      return state;\n    } // if newly selected segment can be expanded -> check if the path is correct\n\n\n    if (segment.expandable) {\n      await checkOtherSegments(state, segmentIndex + 1);\n    } else {\n      // if not expandable -> remove all other segments\n      spliceSegments(state, segmentIndex + 1);\n    }\n\n    handleTargetChanged(state);\n  }\n\n  if (actions.tagChanged.match(action)) {\n    const {\n      tag,\n      index: tagIndex\n    } = action.payload;\n    state.queryModel.updateTag(tag, tagIndex);\n    handleTargetChanged(state);\n\n    if (state.queryModel.tags.length === 0) {\n      await checkOtherSegments(state, 0);\n      state.paused = false;\n    }\n  }\n\n  if (actions.addNewTag.match(action)) {\n    const segment = action.payload.segment;\n    const newTagKey = segment.value;\n    const newTag = {\n      key: newTagKey,\n      operator: '=',\n      value: ''\n    };\n    state.queryModel.addTag(newTag);\n    handleTargetChanged(state);\n  }\n\n  if (actions.unpause.match(action)) {\n    state.paused = false;\n    state.refresh();\n  }\n\n  if (actions.addFunction.match(action)) {\n    const newFunc = state.datasource.createFuncInstance(action.payload.name, {\n      withDefaultParams: true\n    });\n    newFunc.added = true;\n    state.queryModel.addFunction(newFunc);\n    smartlyHandleNewAliasByNode(state, newFunc);\n\n    if (state.segments.length === 1 && state.segments[0].fake) {\n      emptySegments(state);\n    }\n\n    if (!newFunc.params.length && newFunc.added) {\n      handleTargetChanged(state);\n    }\n\n    if (newFunc.def.name === 'seriesByTag') {\n      await parseTarget(state);\n    }\n  }\n\n  if (actions.removeFunction.match(action)) {\n    state.queryModel.removeFunction(action.payload.func);\n    handleTargetChanged(state);\n  }\n\n  if (actions.moveFunction.match(action)) {\n    const {\n      func,\n      offset\n    } = action.payload;\n    state.queryModel.moveFunction(func, offset);\n    handleTargetChanged(state);\n  }\n\n  if (actions.updateFunctionParam.match(action)) {\n    const {\n      func,\n      index,\n      value\n    } = action.payload;\n    func.updateParam(value, index);\n    handleTargetChanged(state);\n  }\n\n  if (actions.updateQuery.match(action)) {\n    state.target.target = action.payload.query;\n    handleTargetChanged(state);\n  }\n\n  if (actions.runQuery.match(action)) {\n    state.refresh();\n  }\n\n  if (actions.toggleEditorMode.match(action)) {\n    state.target.textEditor = !state.target.textEditor;\n    await parseTarget(state);\n  }\n\n  return Object.assign({}, state);\n};\n\nexport const createStore = onChange => {\n  let state = {};\n\n  const dispatch = async action => {\n    state = await reducer(action, state);\n    onChange(state);\n  };\n\n  return dispatch;\n};","map":{"version":3,"names":["getTemplateSrv","GraphiteQuery","actions","addSeriesByTagFunc","buildSegments","checkOtherSegments","emptySegments","handleTargetChanged","parseTarget","pause","removeTagPrefix","smartlyHandleNewAliasByNode","spliceSegments","reducer","action","state","init","match","deps","payload","target","datasource","waitForFuncDefsLoaded","queryModel","supportsTags","paused","removeTagValue","funcDefs","queries","timeRangeChanged","range","queriesChanged","queryChanged","segmentValueChanged","segment","segmentOrString","index","segmentIndex","value","expandable","fake","error","segments","updateSegmentValue","functions","length","def","type","tag","tagChanged","tagIndex","updateTag","tags","addNewTag","newTagKey","newTag","key","operator","addTag","unpause","refresh","addFunction","newFunc","createFuncInstance","name","withDefaultParams","added","params","removeFunction","func","moveFunction","offset","updateFunctionParam","updateParam","updateQuery","query","runQuery","toggleEditorMode","textEditor","createStore","onChange","dispatch"],"sources":["/home/soula/grafana/public/app/plugins/datasource/graphite/state/store.ts"],"sourcesContent":["import { AnyAction } from '@reduxjs/toolkit';\nimport { Action, Dispatch } from 'redux';\n\nimport { DataQuery, TimeRange } from '@grafana/data';\nimport { getTemplateSrv } from '@grafana/runtime';\n\nimport { TemplateSrv } from '../../../../features/templating/template_srv';\nimport { GraphiteDatasource } from '../datasource';\nimport { FuncDefs } from '../gfunc';\nimport GraphiteQuery, { GraphiteTarget } from '../graphite_query';\nimport { GraphiteSegment, GraphiteTagOperator } from '../types';\n\nimport { actions } from './actions';\nimport {\n  addSeriesByTagFunc,\n  buildSegments,\n  checkOtherSegments,\n  emptySegments,\n  handleTargetChanged,\n  parseTarget,\n  pause,\n  removeTagPrefix,\n  smartlyHandleNewAliasByNode,\n  spliceSegments,\n} from './helpers';\n\nexport type GraphiteQueryEditorState = {\n  // external dependencies\n  datasource: GraphiteDatasource;\n  target: GraphiteTarget;\n  refresh: () => void;\n  queries?: DataQuery[];\n  templateSrv: TemplateSrv;\n  range?: TimeRange;\n\n  // internal\n  supportsTags: boolean;\n  paused: boolean;\n  removeTagValue: string;\n  funcDefs: FuncDefs | null;\n  segments: GraphiteSegment[];\n  queryModel: GraphiteQuery;\n  error: Error | null;\n  tagsAutoCompleteErrorShown: boolean;\n  metricAutoCompleteErrorShown: boolean;\n};\n\nconst reducer = async (action: Action, state: GraphiteQueryEditorState): Promise<GraphiteQueryEditorState> => {\n  state = { ...state };\n\n  if (actions.init.match(action)) {\n    const deps = action.payload;\n    deps.target.target = deps.target.target || '';\n\n    await deps.datasource.waitForFuncDefsLoaded();\n\n    state = {\n      ...state,\n      ...deps,\n      queryModel: new GraphiteQuery(deps.datasource, deps.target, getTemplateSrv()),\n      supportsTags: deps.datasource.supportsTags,\n      paused: false,\n      removeTagValue: '-- remove tag --',\n      funcDefs: deps.datasource.funcDefs,\n      queries: deps.queries,\n    };\n\n    await buildSegments(state, false);\n  }\n  if (actions.timeRangeChanged.match(action)) {\n    state.range = action.payload;\n  }\n  if (actions.queriesChanged.match(action)) {\n    state.queries = action.payload;\n    handleTargetChanged(state);\n  }\n  if (actions.queryChanged.match(action)) {\n    state.target.target = action.payload.target || '';\n    await parseTarget(state);\n    handleTargetChanged(state);\n  }\n  if (actions.segmentValueChanged.match(action)) {\n    const { segment: segmentOrString, index: segmentIndex } = action.payload;\n\n    let segment;\n    // is segment was changed to a string - create a new segment\n    if (typeof segmentOrString === 'string') {\n      segment = {\n        value: segmentOrString,\n        expandable: true,\n        fake: false,\n      };\n    } else {\n      segment = segmentOrString as GraphiteSegment;\n    }\n\n    state.error = null;\n    state.segments[segmentIndex] = segment;\n    state.queryModel.updateSegmentValue(segment, segmentIndex);\n\n    if (state.queryModel.functions.length > 0 && state.queryModel.functions[0].def.fake) {\n      state.queryModel.functions = [];\n    }\n\n    if (segment.type === 'tag') {\n      const tag = removeTagPrefix(segment.value);\n      pause(state);\n      await addSeriesByTagFunc(state, tag);\n      return state;\n    }\n\n    // if newly selected segment can be expanded -> check if the path is correct\n    if (segment.expandable) {\n      await checkOtherSegments(state, segmentIndex + 1);\n    } else {\n      // if not expandable -> remove all other segments\n      spliceSegments(state, segmentIndex + 1);\n    }\n\n    handleTargetChanged(state);\n  }\n  if (actions.tagChanged.match(action)) {\n    const { tag, index: tagIndex } = action.payload;\n    state.queryModel.updateTag(tag, tagIndex);\n    handleTargetChanged(state);\n    if (state.queryModel.tags.length === 0) {\n      await checkOtherSegments(state, 0);\n      state.paused = false;\n    }\n  }\n  if (actions.addNewTag.match(action)) {\n    const segment = action.payload.segment;\n    const newTagKey = segment.value;\n    const newTag = { key: newTagKey, operator: '=' as GraphiteTagOperator, value: '' };\n    state.queryModel.addTag(newTag);\n    handleTargetChanged(state);\n  }\n  if (actions.unpause.match(action)) {\n    state.paused = false;\n    state.refresh();\n  }\n  if (actions.addFunction.match(action)) {\n    const newFunc = state.datasource.createFuncInstance(action.payload.name, {\n      withDefaultParams: true,\n    });\n    newFunc.added = true;\n    state.queryModel.addFunction(newFunc);\n    smartlyHandleNewAliasByNode(state, newFunc);\n\n    if (state.segments.length === 1 && state.segments[0].fake) {\n      emptySegments(state);\n    }\n\n    if (!newFunc.params.length && newFunc.added) {\n      handleTargetChanged(state);\n    }\n\n    if (newFunc.def.name === 'seriesByTag') {\n      await parseTarget(state);\n    }\n  }\n  if (actions.removeFunction.match(action)) {\n    state.queryModel.removeFunction(action.payload.func);\n    handleTargetChanged(state);\n  }\n  if (actions.moveFunction.match(action)) {\n    const { func, offset } = action.payload;\n    state.queryModel.moveFunction(func, offset);\n    handleTargetChanged(state);\n  }\n  if (actions.updateFunctionParam.match(action)) {\n    const { func, index, value } = action.payload;\n    func.updateParam(value, index);\n    handleTargetChanged(state);\n  }\n  if (actions.updateQuery.match(action)) {\n    state.target.target = action.payload.query;\n    handleTargetChanged(state);\n  }\n  if (actions.runQuery.match(action)) {\n    state.refresh();\n  }\n  if (actions.toggleEditorMode.match(action)) {\n    state.target.textEditor = !state.target.textEditor;\n    await parseTarget(state);\n  }\n\n  return { ...state };\n};\n\nexport const createStore = (onChange: (state: GraphiteQueryEditorState) => void): Dispatch<AnyAction> => {\n  let state = {} as GraphiteQueryEditorState;\n\n  const dispatch = async (action: AnyAction) => {\n    state = await reducer(action, state);\n    onChange(state);\n  };\n\n  return dispatch as Dispatch<AnyAction>;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}