{"ast":null,"code":"import { getTimeField, sortDataFrame } from '../../dataframe';\nimport { FieldType } from '../../types';\nimport { ArrayVector } from '../../vector';\nimport { fieldMatchers } from '../matchers';\nimport { FieldMatcherID } from '../matchers/ids';\nexport function pickBestJoinField(data) {\n  const {\n    timeField\n  } = getTimeField(data[0]);\n\n  if (timeField) {\n    return fieldMatchers.get(FieldMatcherID.firstTimeField).get({});\n  }\n\n  let common = [];\n\n  for (const f of data[0].fields) {\n    if (f.type === FieldType.number) {\n      common.push(f.name);\n    }\n  }\n\n  for (let i = 1; i < data.length; i++) {\n    const names = [];\n\n    for (const f of data[0].fields) {\n      if (f.type === FieldType.number) {\n        names.push(f.name);\n      }\n    }\n\n    common = common.filter(v => !names.includes(v));\n  }\n\n  return fieldMatchers.get(FieldMatcherID.byName).get(common[0]);\n}\n/**\n * @alpha\n */\n\nfunction getJoinMatcher(options) {\n  var _options$joinBy;\n\n  return (_options$joinBy = options.joinBy) !== null && _options$joinBy !== void 0 ? _options$joinBy : pickBestJoinField(options.frames);\n}\n/**\n * @internal\n */\n\n\nexport function maybeSortFrame(frame, fieldIdx) {\n  if (fieldIdx >= 0) {\n    let sortByField = frame.fields[fieldIdx];\n\n    if (sortByField.type !== FieldType.string && !isLikelyAscendingVector(sortByField.values)) {\n      frame = sortDataFrame(frame, fieldIdx);\n    }\n  }\n\n  return frame;\n}\n/**\n * This will return a single frame joined by the first matching field.  When a join field is not specified,\n * the default will use the first time field\n */\n\nexport function outerJoinDataFrames(options) {\n  var _options$frames;\n\n  if (!((_options$frames = options.frames) !== null && _options$frames !== void 0 && _options$frames.length)) {\n    return;\n  }\n\n  if (options.frames.length === 1) {\n    let frame = options.frames[0];\n    let frameCopy = frame;\n    const joinFieldMatcher = getJoinMatcher(options);\n    let joinIndex = frameCopy.fields.findIndex(f => joinFieldMatcher(f, frameCopy, options.frames));\n\n    if (options.keepOriginIndices) {\n      frameCopy = Object.assign({}, frame, {\n        fields: frame.fields.map((f, fieldIndex) => {\n          const copy = Object.assign({}, f);\n          const origin = {\n            frameIndex: 0,\n            fieldIndex\n          };\n\n          if (copy.state) {\n            copy.state.origin = origin;\n          } else {\n            copy.state = {\n              origin\n            };\n          }\n\n          return copy;\n        })\n      }); // Make sure the join field is first\n\n      if (joinIndex > 0) {\n        const joinField = frameCopy.fields[joinIndex];\n        const fields = frameCopy.fields.filter((f, idx) => idx !== joinIndex);\n        fields.unshift(joinField);\n        frameCopy.fields = fields;\n        joinIndex = 0;\n      }\n    }\n\n    if (joinIndex >= 0) {\n      frameCopy = maybeSortFrame(frameCopy, joinIndex);\n    }\n\n    if (options.keep) {\n      let fields = frameCopy.fields.filter((f, fieldIdx) => fieldIdx === joinIndex || options.keep(f, frameCopy, options.frames)); // mutate already copied frame\n\n      if (frame !== frameCopy) {\n        frameCopy.fields = fields;\n      } else {\n        frameCopy = Object.assign({}, frame, {\n          fields\n        });\n      }\n    }\n\n    return frameCopy;\n  }\n\n  const nullModes = [];\n  const allData = [];\n  const originalFields = [];\n  const joinFieldMatcher = getJoinMatcher(options);\n\n  for (let frameIndex = 0; frameIndex < options.frames.length; frameIndex++) {\n    var _frame$fields;\n\n    const frame = options.frames[frameIndex];\n\n    if (!frame || !((_frame$fields = frame.fields) !== null && _frame$fields !== void 0 && _frame$fields.length)) {\n      continue; // skip the frame\n    }\n\n    const nullModesFrame = [NULL_REMOVE];\n    let join = undefined;\n    let fields = [];\n\n    for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n      const field = frame.fields[fieldIndex];\n      field.state = field.state || {};\n\n      if (!join && joinFieldMatcher(field, frame, options.frames)) {\n        join = field;\n      } else {\n        var _field$config$custom, _field$labels;\n\n        if (options.keep && !options.keep(field, frame, options.frames)) {\n          continue; // skip field\n        } // Support the standard graph span nulls field config\n\n\n        let spanNulls = (_field$config$custom = field.config.custom) === null || _field$config$custom === void 0 ? void 0 : _field$config$custom.spanNulls;\n        nullModesFrame.push(spanNulls === true ? NULL_REMOVE : spanNulls === -1 ? NULL_RETAIN : NULL_EXPAND);\n        let labels = (_field$labels = field.labels) !== null && _field$labels !== void 0 ? _field$labels : {};\n\n        if (frame.name) {\n          labels = Object.assign({}, labels, {\n            name: frame.name\n          });\n        }\n\n        fields.push(Object.assign({}, field, {\n          labels // add the name label from frame\n\n        }));\n      }\n\n      if (options.keepOriginIndices) {\n        field.state.origin = {\n          frameIndex,\n          fieldIndex\n        };\n      }\n    }\n\n    if (!join) {\n      continue; // skip the frame\n    }\n\n    if (originalFields.length === 0) {\n      originalFields.push(join); // first join field\n    }\n\n    nullModes.push(nullModesFrame);\n    const a = [join.values.toArray()]; //\n\n    for (const field of fields) {\n      var _field$state;\n\n      a.push(field.values.toArray());\n      originalFields.push(field); // clear field displayName state\n\n      (_field$state = field.state) === null || _field$state === void 0 ? true : delete _field$state.displayName;\n    }\n\n    allData.push(a);\n  }\n\n  const joined = join(allData, nullModes);\n  return {\n    // ...options.data[0], // keep name, meta?\n    length: joined[0].length,\n    fields: originalFields.map((f, index) => Object.assign({}, f, {\n      values: new ArrayVector(joined[index])\n    }))\n  };\n} //--------------------------------------------------------------------------------\n// Below here is copied from uplot (MIT License)\n// https://github.com/leeoniya/uPlot/blob/master/src/utils.js#L325\n// This avoids needing to import uplot into the data package\n//--------------------------------------------------------------------------------\n// Copied from uplot\n\n// nullModes\nconst NULL_REMOVE = 0; // nulls are converted to undefined (e.g. for spanGaps: true)\n\nconst NULL_RETAIN = 1; // nulls are retained, with alignment artifacts set to undefined (default)\n\nconst NULL_EXPAND = 2; // nulls are expanded to include any adjacent alignment artifacts\n\n// NULL_IGNORE | NULL_RETAIN | NULL_EXPAND;\n// sets undefined values to nulls when adjacent to existing nulls (minesweeper)\nfunction nullExpand(yVals, nullIdxs, alignedLen) {\n  for (let i = 0, xi, lastNullIdx = -1; i < nullIdxs.length; i++) {\n    let nullIdx = nullIdxs[i];\n\n    if (nullIdx > lastNullIdx) {\n      xi = nullIdx - 1;\n\n      while (xi >= 0 && yVals[xi] == null) {\n        yVals[xi--] = null;\n      }\n\n      xi = nullIdx + 1;\n\n      while (xi < alignedLen && yVals[xi] == null) {\n        yVals[lastNullIdx = xi++] = null;\n      }\n    }\n  }\n} // nullModes is a tables-matched array indicating how to treat nulls in each series\n\n\nexport function join(tables, nullModes) {\n  const xVals = new Set();\n\n  for (let ti = 0; ti < tables.length; ti++) {\n    let t = tables[ti];\n    let xs = t[0];\n    let len = xs.length;\n\n    for (let i = 0; i < len; i++) {\n      xVals.add(xs[i]);\n    }\n  }\n\n  let data = [Array.from(xVals).sort((a, b) => a - b)];\n  let alignedLen = data[0].length;\n  let xIdxs = new Map();\n\n  for (let i = 0; i < alignedLen; i++) {\n    xIdxs.set(data[0][i], i);\n  }\n\n  for (let ti = 0; ti < tables.length; ti++) {\n    let t = tables[ti];\n    let xs = t[0];\n\n    for (let si = 1; si < t.length; si++) {\n      let ys = t[si];\n      let yVals = Array(alignedLen).fill(undefined);\n      let nullMode = nullModes ? nullModes[ti][si] : NULL_RETAIN;\n      let nullIdxs = [];\n\n      for (let i = 0; i < ys.length; i++) {\n        let yVal = ys[i];\n        let alignedIdx = xIdxs.get(xs[i]);\n\n        if (yVal === null) {\n          if (nullMode !== NULL_REMOVE) {\n            yVals[alignedIdx] = yVal;\n\n            if (nullMode === NULL_EXPAND) {\n              nullIdxs.push(alignedIdx);\n            }\n          }\n        } else {\n          yVals[alignedIdx] = yVal;\n        }\n      }\n\n      nullExpand(yVals, nullIdxs, alignedLen);\n      data.push(yVals);\n    }\n  }\n\n  return data;\n} // Quick test if the first and last points look to be ascending\n// Only exported for tests\n\nexport function isLikelyAscendingVector(data) {\n  let first = undefined;\n\n  for (let idx = 0; idx < data.length; idx++) {\n    const v = data.get(idx);\n\n    if (v != null) {\n      if (first != null) {\n        if (first > v) {\n          return false; // descending\n        }\n\n        break;\n      }\n\n      first = v;\n    }\n  }\n\n  let idx = data.length - 1;\n\n  while (idx >= 0) {\n    const v = data.get(idx--);\n\n    if (v != null) {\n      if (first > v) {\n        return false;\n      }\n\n      return true;\n    }\n  }\n\n  return true; // only one non-null point\n}","map":{"version":3,"names":["getTimeField","sortDataFrame","FieldType","ArrayVector","fieldMatchers","FieldMatcherID","pickBestJoinField","data","timeField","get","firstTimeField","common","f","fields","type","number","push","name","i","length","names","filter","v","includes","byName","getJoinMatcher","options","joinBy","frames","maybeSortFrame","frame","fieldIdx","sortByField","string","isLikelyAscendingVector","values","outerJoinDataFrames","frameCopy","joinFieldMatcher","joinIndex","findIndex","keepOriginIndices","map","fieldIndex","copy","origin","frameIndex","state","joinField","idx","unshift","keep","nullModes","allData","originalFields","nullModesFrame","NULL_REMOVE","join","undefined","field","spanNulls","config","custom","NULL_RETAIN","NULL_EXPAND","labels","a","toArray","displayName","joined","index","nullExpand","yVals","nullIdxs","alignedLen","xi","lastNullIdx","nullIdx","tables","xVals","Set","ti","t","xs","len","add","Array","from","sort","b","xIdxs","Map","set","si","ys","fill","nullMode","yVal","alignedIdx","first"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/joinDataFrames.ts"],"sourcesContent":["import { getTimeField, sortDataFrame } from '../../dataframe';\nimport { DataFrame, Field, FieldMatcher, FieldType, Vector } from '../../types';\nimport { ArrayVector } from '../../vector';\nimport { fieldMatchers } from '../matchers';\nimport { FieldMatcherID } from '../matchers/ids';\n\nexport function pickBestJoinField(data: DataFrame[]): FieldMatcher {\n  const { timeField } = getTimeField(data[0]);\n  if (timeField) {\n    return fieldMatchers.get(FieldMatcherID.firstTimeField).get({});\n  }\n  let common: string[] = [];\n  for (const f of data[0].fields) {\n    if (f.type === FieldType.number) {\n      common.push(f.name);\n    }\n  }\n\n  for (let i = 1; i < data.length; i++) {\n    const names: string[] = [];\n    for (const f of data[0].fields) {\n      if (f.type === FieldType.number) {\n        names.push(f.name);\n      }\n    }\n    common = common.filter((v) => !names.includes(v));\n  }\n\n  return fieldMatchers.get(FieldMatcherID.byName).get(common[0]);\n}\n\n/**\n * @alpha\n */\nexport interface JoinOptions {\n  /**\n   * The input fields\n   */\n  frames: DataFrame[];\n\n  /**\n   * The field to join -- frames that do not have this field will be droppped\n   */\n  joinBy?: FieldMatcher;\n\n  /**\n   * Optionally filter the non-join fields\n   */\n  keep?: FieldMatcher;\n\n  /**\n   * @internal -- used when we need to keep a reference to the original frame/field index\n   */\n  keepOriginIndices?: boolean;\n}\n\nfunction getJoinMatcher(options: JoinOptions): FieldMatcher {\n  return options.joinBy ?? pickBestJoinField(options.frames);\n}\n\n/**\n * @internal\n */\nexport function maybeSortFrame(frame: DataFrame, fieldIdx: number) {\n  if (fieldIdx >= 0) {\n    let sortByField = frame.fields[fieldIdx];\n\n    if (sortByField.type !== FieldType.string && !isLikelyAscendingVector(sortByField.values)) {\n      frame = sortDataFrame(frame, fieldIdx);\n    }\n  }\n\n  return frame;\n}\n\n/**\n * This will return a single frame joined by the first matching field.  When a join field is not specified,\n * the default will use the first time field\n */\nexport function outerJoinDataFrames(options: JoinOptions): DataFrame | undefined {\n  if (!options.frames?.length) {\n    return;\n  }\n\n  if (options.frames.length === 1) {\n    let frame = options.frames[0];\n    let frameCopy = frame;\n\n    const joinFieldMatcher = getJoinMatcher(options);\n    let joinIndex = frameCopy.fields.findIndex((f) => joinFieldMatcher(f, frameCopy, options.frames));\n\n    if (options.keepOriginIndices) {\n      frameCopy = {\n        ...frame,\n        fields: frame.fields.map((f, fieldIndex) => {\n          const copy = { ...f };\n          const origin = {\n            frameIndex: 0,\n            fieldIndex,\n          };\n          if (copy.state) {\n            copy.state.origin = origin;\n          } else {\n            copy.state = { origin };\n          }\n          return copy;\n        }),\n      };\n\n      // Make sure the join field is first\n      if (joinIndex > 0) {\n        const joinField = frameCopy.fields[joinIndex];\n        const fields = frameCopy.fields.filter((f, idx) => idx !== joinIndex);\n        fields.unshift(joinField);\n        frameCopy.fields = fields;\n        joinIndex = 0;\n      }\n    }\n\n    if (joinIndex >= 0) {\n      frameCopy = maybeSortFrame(frameCopy, joinIndex);\n    }\n\n    if (options.keep) {\n      let fields = frameCopy.fields.filter(\n        (f, fieldIdx) => fieldIdx === joinIndex || options.keep!(f, frameCopy, options.frames)\n      );\n\n      // mutate already copied frame\n      if (frame !== frameCopy) {\n        frameCopy.fields = fields;\n      } else {\n        frameCopy = {\n          ...frame,\n          fields,\n        };\n      }\n    }\n\n    return frameCopy;\n  }\n\n  const nullModes: JoinNullMode[][] = [];\n  const allData: AlignedData[] = [];\n  const originalFields: Field[] = [];\n  const joinFieldMatcher = getJoinMatcher(options);\n\n  for (let frameIndex = 0; frameIndex < options.frames.length; frameIndex++) {\n    const frame = options.frames[frameIndex];\n\n    if (!frame || !frame.fields?.length) {\n      continue; // skip the frame\n    }\n\n    const nullModesFrame: JoinNullMode[] = [NULL_REMOVE];\n    let join: Field | undefined = undefined;\n    let fields: Field[] = [];\n\n    for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n      const field = frame.fields[fieldIndex];\n      field.state = field.state || {};\n\n      if (!join && joinFieldMatcher(field, frame, options.frames)) {\n        join = field;\n      } else {\n        if (options.keep && !options.keep(field, frame, options.frames)) {\n          continue; // skip field\n        }\n\n        // Support the standard graph span nulls field config\n        let spanNulls = field.config.custom?.spanNulls;\n        nullModesFrame.push(spanNulls === true ? NULL_REMOVE : spanNulls === -1 ? NULL_RETAIN : NULL_EXPAND);\n\n        let labels = field.labels ?? {};\n        if (frame.name) {\n          labels = { ...labels, name: frame.name };\n        }\n\n        fields.push({\n          ...field,\n          labels, // add the name label from frame\n        });\n      }\n\n      if (options.keepOriginIndices) {\n        field.state.origin = {\n          frameIndex,\n          fieldIndex,\n        };\n      }\n    }\n\n    if (!join) {\n      continue; // skip the frame\n    }\n\n    if (originalFields.length === 0) {\n      originalFields.push(join); // first join field\n    }\n\n    nullModes.push(nullModesFrame);\n    const a: AlignedData = [join.values.toArray()]; //\n\n    for (const field of fields) {\n      a.push(field.values.toArray());\n      originalFields.push(field);\n      // clear field displayName state\n      delete field.state?.displayName;\n    }\n\n    allData.push(a);\n  }\n\n  const joined = join(allData, nullModes);\n\n  return {\n    // ...options.data[0], // keep name, meta?\n    length: joined[0].length,\n    fields: originalFields.map((f, index) => ({\n      ...f,\n      values: new ArrayVector(joined[index]),\n    })),\n  };\n}\n\n//--------------------------------------------------------------------------------\n// Below here is copied from uplot (MIT License)\n// https://github.com/leeoniya/uPlot/blob/master/src/utils.js#L325\n// This avoids needing to import uplot into the data package\n//--------------------------------------------------------------------------------\n\n// Copied from uplot\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array;\n\nexport type AlignedData = [\n  xValues: number[] | TypedArray,\n  ...yValues: Array<Array<number | null | undefined> | TypedArray>\n];\n\n// nullModes\nconst NULL_REMOVE = 0; // nulls are converted to undefined (e.g. for spanGaps: true)\nconst NULL_RETAIN = 1; // nulls are retained, with alignment artifacts set to undefined (default)\nconst NULL_EXPAND = 2; // nulls are expanded to include any adjacent alignment artifacts\n\ntype JoinNullMode = number; // NULL_IGNORE | NULL_RETAIN | NULL_EXPAND;\n\n// sets undefined values to nulls when adjacent to existing nulls (minesweeper)\nfunction nullExpand(yVals: Array<number | null>, nullIdxs: number[], alignedLen: number) {\n  for (let i = 0, xi, lastNullIdx = -1; i < nullIdxs.length; i++) {\n    let nullIdx = nullIdxs[i];\n\n    if (nullIdx > lastNullIdx) {\n      xi = nullIdx - 1;\n      while (xi >= 0 && yVals[xi] == null) {\n        yVals[xi--] = null;\n      }\n\n      xi = nullIdx + 1;\n      while (xi < alignedLen && yVals[xi] == null) {\n        yVals[(lastNullIdx = xi++)] = null;\n      }\n    }\n  }\n}\n\n// nullModes is a tables-matched array indicating how to treat nulls in each series\nexport function join(tables: AlignedData[], nullModes?: number[][]) {\n  const xVals = new Set<number>();\n\n  for (let ti = 0; ti < tables.length; ti++) {\n    let t = tables[ti];\n    let xs = t[0];\n    let len = xs.length;\n\n    for (let i = 0; i < len; i++) {\n      xVals.add(xs[i]);\n    }\n  }\n\n  let data = [Array.from(xVals).sort((a, b) => a - b)];\n\n  let alignedLen = data[0].length;\n\n  let xIdxs = new Map();\n\n  for (let i = 0; i < alignedLen; i++) {\n    xIdxs.set(data[0][i], i);\n  }\n\n  for (let ti = 0; ti < tables.length; ti++) {\n    let t = tables[ti];\n    let xs = t[0];\n\n    for (let si = 1; si < t.length; si++) {\n      let ys = t[si];\n\n      let yVals = Array(alignedLen).fill(undefined);\n\n      let nullMode = nullModes ? nullModes[ti][si] : NULL_RETAIN;\n\n      let nullIdxs = [];\n\n      for (let i = 0; i < ys.length; i++) {\n        let yVal = ys[i];\n        let alignedIdx = xIdxs.get(xs[i]);\n\n        if (yVal === null) {\n          if (nullMode !== NULL_REMOVE) {\n            yVals[alignedIdx] = yVal;\n\n            if (nullMode === NULL_EXPAND) {\n              nullIdxs.push(alignedIdx);\n            }\n          }\n        } else {\n          yVals[alignedIdx] = yVal;\n        }\n      }\n\n      nullExpand(yVals, nullIdxs, alignedLen);\n\n      data.push(yVals);\n    }\n  }\n\n  return data;\n}\n\n// Quick test if the first and last points look to be ascending\n// Only exported for tests\nexport function isLikelyAscendingVector(data: Vector): boolean {\n  let first: any = undefined;\n\n  for (let idx = 0; idx < data.length; idx++) {\n    const v = data.get(idx);\n    if (v != null) {\n      if (first != null) {\n        if (first > v) {\n          return false; // descending\n        }\n        break;\n      }\n      first = v;\n    }\n  }\n\n  let idx = data.length - 1;\n  while (idx >= 0) {\n    const v = data.get(idx--);\n    if (v != null) {\n      if (first > v) {\n        return false;\n      }\n      return true;\n    }\n  }\n\n  return true; // only one non-null point\n}\n"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,aAAvB,QAA4C,iBAA5C;AACA,SAAyCC,SAAzC,QAAkE,aAAlE;AACA,SAASC,WAAT,QAA4B,cAA5B;AACA,SAASC,aAAT,QAA8B,aAA9B;AACA,SAASC,cAAT,QAA+B,iBAA/B;AAEA,OAAO,SAASC,iBAAT,CAA2BC,IAA3B,EAA4D;EACjE,MAAM;IAAEC;EAAF,IAAgBR,YAAY,CAACO,IAAI,CAAC,CAAD,CAAL,CAAlC;;EACA,IAAIC,SAAJ,EAAe;IACb,OAAOJ,aAAa,CAACK,GAAd,CAAkBJ,cAAc,CAACK,cAAjC,EAAiDD,GAAjD,CAAqD,EAArD,CAAP;EACD;;EACD,IAAIE,MAAgB,GAAG,EAAvB;;EACA,KAAK,MAAMC,CAAX,IAAgBL,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAxB,EAAgC;IAC9B,IAAID,CAAC,CAACE,IAAF,KAAWZ,SAAS,CAACa,MAAzB,EAAiC;MAC/BJ,MAAM,CAACK,IAAP,CAAYJ,CAAC,CAACK,IAAd;IACD;EACF;;EAED,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,IAAI,CAACY,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;IACpC,MAAME,KAAe,GAAG,EAAxB;;IACA,KAAK,MAAMR,CAAX,IAAgBL,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAxB,EAAgC;MAC9B,IAAID,CAAC,CAACE,IAAF,KAAWZ,SAAS,CAACa,MAAzB,EAAiC;QAC/BK,KAAK,CAACJ,IAAN,CAAWJ,CAAC,CAACK,IAAb;MACD;IACF;;IACDN,MAAM,GAAGA,MAAM,CAACU,MAAP,CAAeC,CAAD,IAAO,CAACF,KAAK,CAACG,QAAN,CAAeD,CAAf,CAAtB,CAAT;EACD;;EAED,OAAOlB,aAAa,CAACK,GAAd,CAAkBJ,cAAc,CAACmB,MAAjC,EAAyCf,GAAzC,CAA6CE,MAAM,CAAC,CAAD,CAAnD,CAAP;AACD;AAED;AACA;AACA;;AAuBA,SAASc,cAAT,CAAwBC,OAAxB,EAA4D;EAAA;;EAC1D,0BAAOA,OAAO,CAACC,MAAf,6DAAyBrB,iBAAiB,CAACoB,OAAO,CAACE,MAAT,CAA1C;AACD;AAED;AACA;AACA;;;AACA,OAAO,SAASC,cAAT,CAAwBC,KAAxB,EAA0CC,QAA1C,EAA4D;EACjE,IAAIA,QAAQ,IAAI,CAAhB,EAAmB;IACjB,IAAIC,WAAW,GAAGF,KAAK,CAACjB,MAAN,CAAakB,QAAb,CAAlB;;IAEA,IAAIC,WAAW,CAAClB,IAAZ,KAAqBZ,SAAS,CAAC+B,MAA/B,IAAyC,CAACC,uBAAuB,CAACF,WAAW,CAACG,MAAb,CAArE,EAA2F;MACzFL,KAAK,GAAG7B,aAAa,CAAC6B,KAAD,EAAQC,QAAR,CAArB;IACD;EACF;;EAED,OAAOD,KAAP;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASM,mBAAT,CAA6BV,OAA7B,EAA0E;EAAA;;EAC/E,IAAI,qBAACA,OAAO,CAACE,MAAT,4CAAC,gBAAgBT,MAAjB,CAAJ,EAA6B;IAC3B;EACD;;EAED,IAAIO,OAAO,CAACE,MAAR,CAAeT,MAAf,KAA0B,CAA9B,EAAiC;IAC/B,IAAIW,KAAK,GAAGJ,OAAO,CAACE,MAAR,CAAe,CAAf,CAAZ;IACA,IAAIS,SAAS,GAAGP,KAAhB;IAEA,MAAMQ,gBAAgB,GAAGb,cAAc,CAACC,OAAD,CAAvC;IACA,IAAIa,SAAS,GAAGF,SAAS,CAACxB,MAAV,CAAiB2B,SAAjB,CAA4B5B,CAAD,IAAO0B,gBAAgB,CAAC1B,CAAD,EAAIyB,SAAJ,EAAeX,OAAO,CAACE,MAAvB,CAAlD,CAAhB;;IAEA,IAAIF,OAAO,CAACe,iBAAZ,EAA+B;MAC7BJ,SAAS,qBACJP,KADI;QAEPjB,MAAM,EAAEiB,KAAK,CAACjB,MAAN,CAAa6B,GAAb,CAAiB,CAAC9B,CAAD,EAAI+B,UAAJ,KAAmB;UAC1C,MAAMC,IAAI,qBAAQhC,CAAR,CAAV;UACA,MAAMiC,MAAM,GAAG;YACbC,UAAU,EAAE,CADC;YAEbH;UAFa,CAAf;;UAIA,IAAIC,IAAI,CAACG,KAAT,EAAgB;YACdH,IAAI,CAACG,KAAL,CAAWF,MAAX,GAAoBA,MAApB;UACD,CAFD,MAEO;YACLD,IAAI,CAACG,KAAL,GAAa;cAAEF;YAAF,CAAb;UACD;;UACD,OAAOD,IAAP;QACD,CAZO;MAFD,EAAT,CAD6B,CAkB7B;;MACA,IAAIL,SAAS,GAAG,CAAhB,EAAmB;QACjB,MAAMS,SAAS,GAAGX,SAAS,CAACxB,MAAV,CAAiB0B,SAAjB,CAAlB;QACA,MAAM1B,MAAM,GAAGwB,SAAS,CAACxB,MAAV,CAAiBQ,MAAjB,CAAwB,CAACT,CAAD,EAAIqC,GAAJ,KAAYA,GAAG,KAAKV,SAA5C,CAAf;QACA1B,MAAM,CAACqC,OAAP,CAAeF,SAAf;QACAX,SAAS,CAACxB,MAAV,GAAmBA,MAAnB;QACA0B,SAAS,GAAG,CAAZ;MACD;IACF;;IAED,IAAIA,SAAS,IAAI,CAAjB,EAAoB;MAClBF,SAAS,GAAGR,cAAc,CAACQ,SAAD,EAAYE,SAAZ,CAA1B;IACD;;IAED,IAAIb,OAAO,CAACyB,IAAZ,EAAkB;MAChB,IAAItC,MAAM,GAAGwB,SAAS,CAACxB,MAAV,CAAiBQ,MAAjB,CACX,CAACT,CAAD,EAAImB,QAAJ,KAAiBA,QAAQ,KAAKQ,SAAb,IAA0Bb,OAAO,CAACyB,IAAR,CAAcvC,CAAd,EAAiByB,SAAjB,EAA4BX,OAAO,CAACE,MAApC,CADhC,CAAb,CADgB,CAKhB;;MACA,IAAIE,KAAK,KAAKO,SAAd,EAAyB;QACvBA,SAAS,CAACxB,MAAV,GAAmBA,MAAnB;MACD,CAFD,MAEO;QACLwB,SAAS,qBACJP,KADI;UAEPjB;QAFO,EAAT;MAID;IACF;;IAED,OAAOwB,SAAP;EACD;;EAED,MAAMe,SAA2B,GAAG,EAApC;EACA,MAAMC,OAAsB,GAAG,EAA/B;EACA,MAAMC,cAAuB,GAAG,EAAhC;EACA,MAAMhB,gBAAgB,GAAGb,cAAc,CAACC,OAAD,CAAvC;;EAEA,KAAK,IAAIoB,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGpB,OAAO,CAACE,MAAR,CAAeT,MAArD,EAA6D2B,UAAU,EAAvE,EAA2E;IAAA;;IACzE,MAAMhB,KAAK,GAAGJ,OAAO,CAACE,MAAR,CAAekB,UAAf,CAAd;;IAEA,IAAI,CAAChB,KAAD,IAAU,mBAACA,KAAK,CAACjB,MAAP,0CAAC,cAAcM,MAAf,CAAd,EAAqC;MACnC,SADmC,CACzB;IACX;;IAED,MAAMoC,cAA8B,GAAG,CAACC,WAAD,CAAvC;IACA,IAAIC,IAAuB,GAAGC,SAA9B;IACA,IAAI7C,MAAe,GAAG,EAAtB;;IAEA,KAAK,IAAI8B,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGb,KAAK,CAACjB,MAAN,CAAaM,MAAnD,EAA2DwB,UAAU,EAArE,EAAyE;MACvE,MAAMgB,KAAK,GAAG7B,KAAK,CAACjB,MAAN,CAAa8B,UAAb,CAAd;MACAgB,KAAK,CAACZ,KAAN,GAAcY,KAAK,CAACZ,KAAN,IAAe,EAA7B;;MAEA,IAAI,CAACU,IAAD,IAASnB,gBAAgB,CAACqB,KAAD,EAAQ7B,KAAR,EAAeJ,OAAO,CAACE,MAAvB,CAA7B,EAA6D;QAC3D6B,IAAI,GAAGE,KAAP;MACD,CAFD,MAEO;QAAA;;QACL,IAAIjC,OAAO,CAACyB,IAAR,IAAgB,CAACzB,OAAO,CAACyB,IAAR,CAAaQ,KAAb,EAAoB7B,KAApB,EAA2BJ,OAAO,CAACE,MAAnC,CAArB,EAAiE;UAC/D,SAD+D,CACrD;QACX,CAHI,CAKL;;;QACA,IAAIgC,SAAS,2BAAGD,KAAK,CAACE,MAAN,CAAaC,MAAhB,yDAAG,qBAAqBF,SAArC;QACAL,cAAc,CAACvC,IAAf,CAAoB4C,SAAS,KAAK,IAAd,GAAqBJ,WAArB,GAAmCI,SAAS,KAAK,CAAC,CAAf,GAAmBG,WAAnB,GAAiCC,WAAxF;QAEA,IAAIC,MAAM,oBAAGN,KAAK,CAACM,MAAT,yDAAmB,EAA7B;;QACA,IAAInC,KAAK,CAACb,IAAV,EAAgB;UACdgD,MAAM,qBAAQA,MAAR;YAAgBhD,IAAI,EAAEa,KAAK,CAACb;UAA5B,EAAN;QACD;;QAEDJ,MAAM,CAACG,IAAP,mBACK2C,KADL;UAEEM,MAFF,CAEU;;QAFV;MAID;;MAED,IAAIvC,OAAO,CAACe,iBAAZ,EAA+B;QAC7BkB,KAAK,CAACZ,KAAN,CAAYF,MAAZ,GAAqB;UACnBC,UADmB;UAEnBH;QAFmB,CAArB;MAID;IACF;;IAED,IAAI,CAACc,IAAL,EAAW;MACT,SADS,CACC;IACX;;IAED,IAAIH,cAAc,CAACnC,MAAf,KAA0B,CAA9B,EAAiC;MAC/BmC,cAAc,CAACtC,IAAf,CAAoByC,IAApB,EAD+B,CACJ;IAC5B;;IAEDL,SAAS,CAACpC,IAAV,CAAeuC,cAAf;IACA,MAAMW,CAAc,GAAG,CAACT,IAAI,CAACtB,MAAL,CAAYgC,OAAZ,EAAD,CAAvB,CAtDyE,CAsDzB;;IAEhD,KAAK,MAAMR,KAAX,IAAoB9C,MAApB,EAA4B;MAAA;;MAC1BqD,CAAC,CAAClD,IAAF,CAAO2C,KAAK,CAACxB,MAAN,CAAagC,OAAb,EAAP;MACAb,cAAc,CAACtC,IAAf,CAAoB2C,KAApB,EAF0B,CAG1B;;MACA,gBAAOA,KAAK,CAACZ,KAAb,sDAAO,aAAaqB,WAApB;IACD;;IAEDf,OAAO,CAACrC,IAAR,CAAakD,CAAb;EACD;;EAED,MAAMG,MAAM,GAAGZ,IAAI,CAACJ,OAAD,EAAUD,SAAV,CAAnB;EAEA,OAAO;IACL;IACAjC,MAAM,EAAEkD,MAAM,CAAC,CAAD,CAAN,CAAUlD,MAFb;IAGLN,MAAM,EAAEyC,cAAc,CAACZ,GAAf,CAAmB,CAAC9B,CAAD,EAAI0D,KAAJ,uBACtB1D,CADsB;MAEzBuB,MAAM,EAAE,IAAIhC,WAAJ,CAAgBkE,MAAM,CAACC,KAAD,CAAtB;IAFiB,EAAnB;EAHH,CAAP;AAQD,C,CAED;AACA;AACA;AACA;AACA;AAEA;;AAiBA;AACA,MAAMd,WAAW,GAAG,CAApB,C,CAAuB;;AACvB,MAAMO,WAAW,GAAG,CAApB,C,CAAuB;;AACvB,MAAMC,WAAW,GAAG,CAApB,C,CAAuB;;AAEK;AAE5B;AACA,SAASO,UAAT,CAAoBC,KAApB,EAAiDC,QAAjD,EAAqEC,UAArE,EAAyF;EACvF,KAAK,IAAIxD,CAAC,GAAG,CAAR,EAAWyD,EAAX,EAAeC,WAAW,GAAG,CAAC,CAAnC,EAAsC1D,CAAC,GAAGuD,QAAQ,CAACtD,MAAnD,EAA2DD,CAAC,EAA5D,EAAgE;IAC9D,IAAI2D,OAAO,GAAGJ,QAAQ,CAACvD,CAAD,CAAtB;;IAEA,IAAI2D,OAAO,GAAGD,WAAd,EAA2B;MACzBD,EAAE,GAAGE,OAAO,GAAG,CAAf;;MACA,OAAOF,EAAE,IAAI,CAAN,IAAWH,KAAK,CAACG,EAAD,CAAL,IAAa,IAA/B,EAAqC;QACnCH,KAAK,CAACG,EAAE,EAAH,CAAL,GAAc,IAAd;MACD;;MAEDA,EAAE,GAAGE,OAAO,GAAG,CAAf;;MACA,OAAOF,EAAE,GAAGD,UAAL,IAAmBF,KAAK,CAACG,EAAD,CAAL,IAAa,IAAvC,EAA6C;QAC3CH,KAAK,CAAEI,WAAW,GAAGD,EAAE,EAAlB,CAAL,GAA8B,IAA9B;MACD;IACF;EACF;AACF,C,CAED;;;AACA,OAAO,SAASlB,IAAT,CAAcqB,MAAd,EAAqC1B,SAArC,EAA6D;EAClE,MAAM2B,KAAK,GAAG,IAAIC,GAAJ,EAAd;;EAEA,KAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGH,MAAM,CAAC3D,MAA7B,EAAqC8D,EAAE,EAAvC,EAA2C;IACzC,IAAIC,CAAC,GAAGJ,MAAM,CAACG,EAAD,CAAd;IACA,IAAIE,EAAE,GAAGD,CAAC,CAAC,CAAD,CAAV;IACA,IAAIE,GAAG,GAAGD,EAAE,CAAChE,MAAb;;IAEA,KAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkE,GAApB,EAAyBlE,CAAC,EAA1B,EAA8B;MAC5B6D,KAAK,CAACM,GAAN,CAAUF,EAAE,CAACjE,CAAD,CAAZ;IACD;EACF;;EAED,IAAIX,IAAI,GAAG,CAAC+E,KAAK,CAACC,IAAN,CAAWR,KAAX,EAAkBS,IAAlB,CAAuB,CAACtB,CAAD,EAAIuB,CAAJ,KAAUvB,CAAC,GAAGuB,CAArC,CAAD,CAAX;EAEA,IAAIf,UAAU,GAAGnE,IAAI,CAAC,CAAD,CAAJ,CAAQY,MAAzB;EAEA,IAAIuE,KAAK,GAAG,IAAIC,GAAJ,EAAZ;;EAEA,KAAK,IAAIzE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwD,UAApB,EAAgCxD,CAAC,EAAjC,EAAqC;IACnCwE,KAAK,CAACE,GAAN,CAAUrF,IAAI,CAAC,CAAD,CAAJ,CAAQW,CAAR,CAAV,EAAsBA,CAAtB;EACD;;EAED,KAAK,IAAI+D,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGH,MAAM,CAAC3D,MAA7B,EAAqC8D,EAAE,EAAvC,EAA2C;IACzC,IAAIC,CAAC,GAAGJ,MAAM,CAACG,EAAD,CAAd;IACA,IAAIE,EAAE,GAAGD,CAAC,CAAC,CAAD,CAAV;;IAEA,KAAK,IAAIW,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGX,CAAC,CAAC/D,MAAxB,EAAgC0E,EAAE,EAAlC,EAAsC;MACpC,IAAIC,EAAE,GAAGZ,CAAC,CAACW,EAAD,CAAV;MAEA,IAAIrB,KAAK,GAAGc,KAAK,CAACZ,UAAD,CAAL,CAAkBqB,IAAlB,CAAuBrC,SAAvB,CAAZ;MAEA,IAAIsC,QAAQ,GAAG5C,SAAS,GAAGA,SAAS,CAAC6B,EAAD,CAAT,CAAcY,EAAd,CAAH,GAAuB9B,WAA/C;MAEA,IAAIU,QAAQ,GAAG,EAAf;;MAEA,KAAK,IAAIvD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4E,EAAE,CAAC3E,MAAvB,EAA+BD,CAAC,EAAhC,EAAoC;QAClC,IAAI+E,IAAI,GAAGH,EAAE,CAAC5E,CAAD,CAAb;QACA,IAAIgF,UAAU,GAAGR,KAAK,CAACjF,GAAN,CAAU0E,EAAE,CAACjE,CAAD,CAAZ,CAAjB;;QAEA,IAAI+E,IAAI,KAAK,IAAb,EAAmB;UACjB,IAAID,QAAQ,KAAKxC,WAAjB,EAA8B;YAC5BgB,KAAK,CAAC0B,UAAD,CAAL,GAAoBD,IAApB;;YAEA,IAAID,QAAQ,KAAKhC,WAAjB,EAA8B;cAC5BS,QAAQ,CAACzD,IAAT,CAAckF,UAAd;YACD;UACF;QACF,CARD,MAQO;UACL1B,KAAK,CAAC0B,UAAD,CAAL,GAAoBD,IAApB;QACD;MACF;;MAED1B,UAAU,CAACC,KAAD,EAAQC,QAAR,EAAkBC,UAAlB,CAAV;MAEAnE,IAAI,CAACS,IAAL,CAAUwD,KAAV;IACD;EACF;;EAED,OAAOjE,IAAP;AACD,C,CAED;AACA;;AACA,OAAO,SAAS2B,uBAAT,CAAiC3B,IAAjC,EAAwD;EAC7D,IAAI4F,KAAU,GAAGzC,SAAjB;;EAEA,KAAK,IAAIT,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG1C,IAAI,CAACY,MAA7B,EAAqC8B,GAAG,EAAxC,EAA4C;IAC1C,MAAM3B,CAAC,GAAGf,IAAI,CAACE,GAAL,CAASwC,GAAT,CAAV;;IACA,IAAI3B,CAAC,IAAI,IAAT,EAAe;MACb,IAAI6E,KAAK,IAAI,IAAb,EAAmB;QACjB,IAAIA,KAAK,GAAG7E,CAAZ,EAAe;UACb,OAAO,KAAP,CADa,CACC;QACf;;QACD;MACD;;MACD6E,KAAK,GAAG7E,CAAR;IACD;EACF;;EAED,IAAI2B,GAAG,GAAG1C,IAAI,CAACY,MAAL,GAAc,CAAxB;;EACA,OAAO8B,GAAG,IAAI,CAAd,EAAiB;IACf,MAAM3B,CAAC,GAAGf,IAAI,CAACE,GAAL,CAASwC,GAAG,EAAZ,CAAV;;IACA,IAAI3B,CAAC,IAAI,IAAT,EAAe;MACb,IAAI6E,KAAK,GAAG7E,CAAZ,EAAe;QACb,OAAO,KAAP;MACD;;MACD,OAAO,IAAP;IACD;EACF;;EAED,OAAO,IAAP,CA3B6D,CA2BhD;AACd"},"metadata":{},"sourceType":"module"}