{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { merge } from 'lodash';\nimport uPlot from 'uplot';\nimport { DefaultTimeZone, getTimeZoneInfo } from '@grafana/data';\nimport { AxisPlacement } from '@grafana/schema';\nimport { getStackingBands, pluginLog } from '../utils';\nimport { UPlotAxisBuilder } from './UPlotAxisBuilder';\nimport { UPlotScaleBuilder } from './UPlotScaleBuilder';\nimport { UPlotSeriesBuilder } from './UPlotSeriesBuilder';\nimport { getThresholdsDrawHook } from './UPlotThresholds';\nconst cursorDefaults = {\n  // prevent client-side zoom from triggering at the end of a selection\n  drag: {\n    setScale: false\n  },\n  points: {\n    /*@ts-ignore*/\n    size: (u, seriesIdx) => u.series[seriesIdx].points.size * 2,\n\n    /*@ts-ignore*/\n    width: (u, seriesIdx, size) => size / 4\n  },\n  focus: {\n    prox: 30\n  }\n};\nexport class UPlotConfigBuilder {\n  // to prevent more than one threshold per scale\n  // Custom handler for closest datapoint and series lookup\n  constructor(timeZone = DefaultTimeZone) {\n    var _getTimeZoneInfo;\n\n    _defineProperty(this, \"series\", []);\n\n    _defineProperty(this, \"axes\", {});\n\n    _defineProperty(this, \"scales\", []);\n\n    _defineProperty(this, \"bands\", []);\n\n    _defineProperty(this, \"stackingGroups\", []);\n\n    _defineProperty(this, \"cursor\", void 0);\n\n    _defineProperty(this, \"select\", void 0);\n\n    _defineProperty(this, \"hasLeftAxis\", false);\n\n    _defineProperty(this, \"hooks\", {});\n\n    _defineProperty(this, \"tz\", undefined);\n\n    _defineProperty(this, \"sync\", false);\n\n    _defineProperty(this, \"mode\", 1);\n\n    _defineProperty(this, \"frames\", undefined);\n\n    _defineProperty(this, \"thresholds\", {});\n\n    _defineProperty(this, \"tooltipInterpolator\", undefined);\n\n    _defineProperty(this, \"padding\", undefined);\n\n    _defineProperty(this, \"prepData\", undefined);\n\n    _defineProperty(this, \"scaleKeys\", ['', '']);\n\n    _defineProperty(this, \"tzDate\", ts => {\n      let date = new Date(ts);\n      return this.tz ? uPlot.tzDate(date, this.tz) : date;\n    });\n\n    this.tz = (_getTimeZoneInfo = getTimeZoneInfo(timeZone, Date.now())) === null || _getTimeZoneInfo === void 0 ? void 0 : _getTimeZoneInfo.ianaName;\n  } // Exposed to let the container know the primary scale keys\n\n\n  addHook(type, hook) {\n    pluginLog('UPlotConfigBuilder', false, 'addHook', type);\n\n    if (!this.hooks[type]) {\n      this.hooks[type] = [];\n    }\n\n    this.hooks[type].push(hook);\n  }\n\n  addThresholds(options) {\n    if (!this.thresholds[options.scaleKey]) {\n      this.thresholds[options.scaleKey] = options;\n      this.addHook('drawClear', getThresholdsDrawHook(options));\n    }\n  }\n\n  addAxis(props) {\n    var _props$placement, _props$grid;\n\n    props.placement = (_props$placement = props.placement) !== null && _props$placement !== void 0 ? _props$placement : AxisPlacement.Auto;\n    props.grid = (_props$grid = props.grid) !== null && _props$grid !== void 0 ? _props$grid : {};\n\n    if (this.axes[props.scaleKey]) {\n      this.axes[props.scaleKey].merge(props);\n      return;\n    } // Handle auto placement logic\n\n\n    if (props.placement === AxisPlacement.Auto) {\n      props.placement = this.hasLeftAxis ? AxisPlacement.Right : AxisPlacement.Left;\n    }\n\n    if (props.placement === AxisPlacement.Left) {\n      this.hasLeftAxis = true;\n    }\n\n    if (props.placement === AxisPlacement.Hidden) {\n      props.grid.show = false;\n      props.size = 0;\n    }\n\n    this.axes[props.scaleKey] = new UPlotAxisBuilder(props);\n  }\n\n  getAxisPlacement(scaleKey) {\n    var _ref;\n\n    const axis = this.axes[scaleKey];\n    return (_ref = axis === null || axis === void 0 ? void 0 : axis.props.placement) !== null && _ref !== void 0 ? _ref : AxisPlacement.Left;\n  }\n\n  setCursor(cursor) {\n    this.cursor = merge({}, this.cursor, cursor);\n  }\n\n  setMode(mode) {\n    this.mode = mode;\n  }\n\n  setSelect(select) {\n    this.select = select;\n  }\n\n  addSeries(props) {\n    this.series.push(new UPlotSeriesBuilder(props));\n  }\n\n  getSeries() {\n    return this.series;\n  }\n  /** Add or update the scale with the scale key */\n\n\n  addScale(props) {\n    const current = this.scales.find(v => v.props.scaleKey === props.scaleKey);\n\n    if (current) {\n      current.merge(props);\n      return;\n    }\n\n    this.scales.push(new UPlotScaleBuilder(props));\n  }\n\n  addBand(band) {\n    this.bands.push(band);\n  }\n\n  setStackingGroups(groups) {\n    this.stackingGroups = groups;\n  }\n\n  getStackingGroups() {\n    return this.stackingGroups;\n  }\n\n  setTooltipInterpolator(interpolator) {\n    this.tooltipInterpolator = interpolator;\n  }\n\n  getTooltipInterpolator() {\n    return this.tooltipInterpolator;\n  }\n\n  setPrepData(prepData) {\n    this.prepData = frames => {\n      this.frames = frames;\n      return prepData(frames, this.getStackingGroups());\n    };\n  }\n\n  setSync() {\n    this.sync = true;\n  }\n\n  hasSync() {\n    return this.sync;\n  }\n\n  setPadding(padding) {\n    this.padding = padding;\n  }\n\n  getConfig() {\n    const config = {\n      mode: this.mode,\n      series: [this.mode === 2 ? null : {\n        value: () => ''\n      }]\n    };\n    config.axes = this.ensureNonOverlappingAxes(Object.values(this.axes)).map(a => a.getConfig());\n    config.series = [...config.series, ...this.series.map(s => s.getConfig())];\n    config.scales = this.scales.reduce((acc, s) => {\n      return Object.assign({}, acc, s.getConfig());\n    }, {});\n    config.hooks = this.hooks;\n    config.select = this.select;\n\n    const pointColorFn = (alphaHex = '') => (u, seriesIdx) => {\n      /*@ts-ignore*/\n      let s = u.series[seriesIdx].points._stroke; // interpolate for gradients/thresholds\n\n      if (typeof s !== 'string') {\n        let field = this.frames[0].fields[seriesIdx];\n        s = field.display(field.values.get(u.cursor.idxs[seriesIdx])).color;\n      }\n\n      return s + alphaHex;\n    };\n\n    config.cursor = merge({}, cursorDefaults, {\n      points: {\n        stroke: pointColorFn('80'),\n        fill: pointColorFn()\n      }\n    }, this.cursor);\n    config.tzDate = this.tzDate;\n    config.padding = this.padding;\n\n    if (this.stackingGroups.length) {\n      this.stackingGroups.forEach(group => {\n        getStackingBands(group).forEach(band => {\n          this.addBand(band);\n        });\n      });\n    }\n\n    if (this.bands.length) {\n      config.bands = this.bands;\n    }\n\n    return config;\n  }\n\n  ensureNonOverlappingAxes(axes) {\n    const xAxis = axes.find(a => a.props.scaleKey === 'x');\n    const axesWithoutGridSet = axes.filter(a => {\n      var _a$props$grid;\n\n      return ((_a$props$grid = a.props.grid) === null || _a$props$grid === void 0 ? void 0 : _a$props$grid.show) === undefined;\n    });\n    const firstValueAxisIdx = axesWithoutGridSet.findIndex(a => a.props.placement === AxisPlacement.Left || a.props.placement === AxisPlacement.Bottom && a !== xAxis); // For all axes with no grid set, set the grid automatically (grid only for first left axis )\n\n    for (let i = 0; i < axesWithoutGridSet.length; i++) {\n      if (axesWithoutGridSet[i] === xAxis || i === firstValueAxisIdx) {\n        axesWithoutGridSet[i].props.grid.show = true;\n      } else {\n        axesWithoutGridSet[i].props.grid.show = false;\n      }\n    }\n\n    return axes;\n  }\n\n}","map":{"version":3,"names":["merge","uPlot","DefaultTimeZone","getTimeZoneInfo","AxisPlacement","getStackingBands","pluginLog","UPlotAxisBuilder","UPlotScaleBuilder","UPlotSeriesBuilder","getThresholdsDrawHook","cursorDefaults","drag","setScale","points","size","u","seriesIdx","series","width","focus","prox","UPlotConfigBuilder","constructor","timeZone","undefined","ts","date","Date","tz","tzDate","now","ianaName","addHook","type","hook","hooks","push","addThresholds","options","thresholds","scaleKey","addAxis","props","placement","Auto","grid","axes","hasLeftAxis","Right","Left","Hidden","show","getAxisPlacement","axis","setCursor","cursor","setMode","mode","setSelect","select","addSeries","getSeries","addScale","current","scales","find","v","addBand","band","bands","setStackingGroups","groups","stackingGroups","getStackingGroups","setTooltipInterpolator","interpolator","tooltipInterpolator","getTooltipInterpolator","setPrepData","prepData","frames","setSync","sync","hasSync","setPadding","padding","getConfig","config","value","ensureNonOverlappingAxes","Object","values","map","a","s","reduce","acc","pointColorFn","alphaHex","_stroke","field","fields","display","get","idxs","color","stroke","fill","length","forEach","group","xAxis","axesWithoutGridSet","filter","firstValueAxisIdx","findIndex","Bottom","i"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/uPlot/config/UPlotConfigBuilder.ts"],"sourcesContent":["import { merge } from 'lodash';\nimport uPlot, { Cursor, Band, Hooks, Select, AlignedData, Padding, Series } from 'uplot';\n\nimport {\n  DataFrame,\n  DefaultTimeZone,\n  EventBus,\n  Field,\n  getTimeZoneInfo,\n  GrafanaTheme2,\n  TimeRange,\n  TimeZone,\n} from '@grafana/data';\nimport { AxisPlacement } from '@grafana/schema';\n\nimport { FacetedData, PlotConfig, PlotTooltipInterpolator } from '../types';\nimport { getStackingBands, pluginLog, StackingGroup } from '../utils';\n\nimport { AxisProps, UPlotAxisBuilder } from './UPlotAxisBuilder';\nimport { ScaleProps, UPlotScaleBuilder } from './UPlotScaleBuilder';\nimport { SeriesProps, UPlotSeriesBuilder } from './UPlotSeriesBuilder';\nimport { getThresholdsDrawHook, UPlotThresholdOptions } from './UPlotThresholds';\n\nconst cursorDefaults: Cursor = {\n  // prevent client-side zoom from triggering at the end of a selection\n  drag: { setScale: false },\n  points: {\n    /*@ts-ignore*/\n    size: (u, seriesIdx) => u.series[seriesIdx].points.size * 2,\n    /*@ts-ignore*/\n    width: (u, seriesIdx, size) => size / 4,\n  },\n  focus: {\n    prox: 30,\n  },\n};\n\ntype PrepData = (frames: DataFrame[]) => AlignedData | FacetedData;\ntype PreDataStacked = (frames: DataFrame[], stackingGroups: StackingGroup[]) => AlignedData | FacetedData;\n\nexport class UPlotConfigBuilder {\n  private series: UPlotSeriesBuilder[] = [];\n  private axes: Record<string, UPlotAxisBuilder> = {};\n  private scales: UPlotScaleBuilder[] = [];\n  private bands: Band[] = [];\n  private stackingGroups: StackingGroup[] = [];\n  private cursor: Cursor | undefined;\n  private select: uPlot.Select | undefined;\n  private hasLeftAxis = false;\n  private hooks: Hooks.Arrays = {};\n  private tz: string | undefined = undefined;\n  private sync = false;\n  private mode: uPlot.Mode = 1;\n  private frames: DataFrame[] | undefined = undefined;\n  // to prevent more than one threshold per scale\n  private thresholds: Record<string, UPlotThresholdOptions> = {};\n  // Custom handler for closest datapoint and series lookup\n  private tooltipInterpolator: PlotTooltipInterpolator | undefined = undefined;\n  private padding?: Padding = undefined;\n\n  prepData: PrepData | undefined = undefined;\n\n  constructor(timeZone: TimeZone = DefaultTimeZone) {\n    this.tz = getTimeZoneInfo(timeZone, Date.now())?.ianaName;\n  }\n\n  // Exposed to let the container know the primary scale keys\n  scaleKeys: [string, string] = ['', ''];\n\n  addHook<T extends keyof Hooks.Defs>(type: T, hook: Hooks.Defs[T]) {\n    pluginLog('UPlotConfigBuilder', false, 'addHook', type);\n\n    if (!this.hooks[type]) {\n      this.hooks[type] = [];\n    }\n\n    this.hooks[type]!.push(hook as any);\n  }\n\n  addThresholds(options: UPlotThresholdOptions) {\n    if (!this.thresholds[options.scaleKey]) {\n      this.thresholds[options.scaleKey] = options;\n      this.addHook('drawClear', getThresholdsDrawHook(options));\n    }\n  }\n\n  addAxis(props: AxisProps) {\n    props.placement = props.placement ?? AxisPlacement.Auto;\n    props.grid = props.grid ?? {};\n    if (this.axes[props.scaleKey]) {\n      this.axes[props.scaleKey].merge(props);\n      return;\n    }\n\n    // Handle auto placement logic\n    if (props.placement === AxisPlacement.Auto) {\n      props.placement = this.hasLeftAxis ? AxisPlacement.Right : AxisPlacement.Left;\n    }\n\n    if (props.placement === AxisPlacement.Left) {\n      this.hasLeftAxis = true;\n    }\n\n    if (props.placement === AxisPlacement.Hidden) {\n      props.grid.show = false;\n      props.size = 0;\n    }\n\n    this.axes[props.scaleKey] = new UPlotAxisBuilder(props);\n  }\n\n  getAxisPlacement(scaleKey: string): AxisPlacement {\n    const axis = this.axes[scaleKey];\n    return axis?.props.placement! ?? AxisPlacement.Left;\n  }\n\n  setCursor(cursor?: Cursor) {\n    this.cursor = merge({}, this.cursor, cursor);\n  }\n\n  setMode(mode: uPlot.Mode) {\n    this.mode = mode;\n  }\n\n  setSelect(select: Select) {\n    this.select = select;\n  }\n\n  addSeries(props: SeriesProps) {\n    this.series.push(new UPlotSeriesBuilder(props));\n  }\n\n  getSeries() {\n    return this.series;\n  }\n\n  /** Add or update the scale with the scale key */\n  addScale(props: ScaleProps) {\n    const current = this.scales.find((v) => v.props.scaleKey === props.scaleKey);\n    if (current) {\n      current.merge(props);\n      return;\n    }\n    this.scales.push(new UPlotScaleBuilder(props));\n  }\n\n  addBand(band: Band) {\n    this.bands.push(band);\n  }\n\n  setStackingGroups(groups: StackingGroup[]) {\n    this.stackingGroups = groups;\n  }\n\n  getStackingGroups() {\n    return this.stackingGroups;\n  }\n\n  setTooltipInterpolator(interpolator: PlotTooltipInterpolator) {\n    this.tooltipInterpolator = interpolator;\n  }\n\n  getTooltipInterpolator() {\n    return this.tooltipInterpolator;\n  }\n\n  setPrepData(prepData: PreDataStacked) {\n    this.prepData = (frames) => {\n      this.frames = frames;\n      return prepData(frames, this.getStackingGroups());\n    };\n  }\n\n  setSync() {\n    this.sync = true;\n  }\n\n  hasSync() {\n    return this.sync;\n  }\n\n  setPadding(padding: Padding) {\n    this.padding = padding;\n  }\n\n  getConfig() {\n    const config: PlotConfig = {\n      mode: this.mode,\n      series: [\n        this.mode === 2\n          ? (null as unknown as Series)\n          : {\n              value: () => '',\n            },\n      ],\n    };\n    config.axes = this.ensureNonOverlappingAxes(Object.values(this.axes)).map((a) => a.getConfig());\n    config.series = [...config.series, ...this.series.map((s) => s.getConfig())];\n    config.scales = this.scales.reduce((acc, s) => {\n      return { ...acc, ...s.getConfig() };\n    }, {});\n\n    config.hooks = this.hooks;\n\n    config.select = this.select;\n\n    const pointColorFn =\n      (alphaHex = '') =>\n      (u: uPlot, seriesIdx: number) => {\n        /*@ts-ignore*/\n        let s = u.series[seriesIdx].points._stroke;\n\n        // interpolate for gradients/thresholds\n        if (typeof s !== 'string') {\n          let field = this.frames![0].fields[seriesIdx];\n          s = field.display!(field.values.get(u.cursor.idxs![seriesIdx]!)).color!;\n        }\n\n        return s + alphaHex;\n      };\n\n    config.cursor = merge(\n      {},\n      cursorDefaults,\n      {\n        points: {\n          stroke: pointColorFn('80'),\n          fill: pointColorFn(),\n        },\n      },\n      this.cursor\n    );\n\n    config.tzDate = this.tzDate;\n    config.padding = this.padding;\n\n    if (this.stackingGroups.length) {\n      this.stackingGroups.forEach((group) => {\n        getStackingBands(group).forEach((band) => {\n          this.addBand(band);\n        });\n      });\n    }\n\n    if (this.bands.length) {\n      config.bands = this.bands;\n    }\n\n    return config;\n  }\n\n  private tzDate = (ts: number) => {\n    let date = new Date(ts);\n\n    return this.tz ? uPlot.tzDate(date, this.tz) : date;\n  };\n\n  private ensureNonOverlappingAxes(axes: UPlotAxisBuilder[]): UPlotAxisBuilder[] {\n    const xAxis = axes.find((a) => a.props.scaleKey === 'x');\n    const axesWithoutGridSet = axes.filter((a) => a.props.grid?.show === undefined);\n    const firstValueAxisIdx = axesWithoutGridSet.findIndex(\n      (a) => a.props.placement === AxisPlacement.Left || (a.props.placement === AxisPlacement.Bottom && a !== xAxis)\n    );\n\n    // For all axes with no grid set, set the grid automatically (grid only for first left axis )\n    for (let i = 0; i < axesWithoutGridSet.length; i++) {\n      if (axesWithoutGridSet[i] === xAxis || i === firstValueAxisIdx) {\n        axesWithoutGridSet[i].props.grid!.show = true;\n      } else {\n        axesWithoutGridSet[i].props.grid!.show = false;\n      }\n    }\n\n    return axes;\n  }\n}\n\nexport type Renderers = Array<{\n  fieldMap: Record<string, string>;\n  indicesOnly: string[];\n  init: (config: UPlotConfigBuilder, fieldIndices: Record<string, number>) => void;\n}>;\n\n/** @alpha */\ntype UPlotConfigPrepOpts<T extends Record<string, any> = {}> = {\n  frame: DataFrame;\n  theme: GrafanaTheme2;\n  timeZone: TimeZone;\n  getTimeRange: () => TimeRange;\n  eventBus: EventBus;\n  allFrames: DataFrame[];\n  renderers?: Renderers;\n  tweakScale?: (opts: ScaleProps, forField: Field) => ScaleProps;\n  tweakAxis?: (opts: AxisProps, forField: Field) => AxisProps;\n} & T;\n\n/** @alpha */\nexport type UPlotConfigPrepFn<T extends {} = {}> = (opts: UPlotConfigPrepOpts<T>) => UPlotConfigBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}