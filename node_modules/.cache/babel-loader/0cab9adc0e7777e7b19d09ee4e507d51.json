{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { findIndex } from 'lodash';\nexport default class TableModel {\n  constructor(table) {\n    _defineProperty(this, \"columns\", void 0);\n\n    _defineProperty(this, \"rows\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"columnMap\", void 0);\n\n    _defineProperty(this, \"refId\", void 0);\n\n    _defineProperty(this, \"meta\", void 0);\n\n    this.columns = [];\n    this.columnMap = {};\n    this.rows = [];\n    this.type = 'table';\n\n    if (table) {\n      if (table.columns) {\n        for (const col of table.columns) {\n          this.addColumn(col);\n        }\n      }\n\n      if (table.rows) {\n        for (const row of table.rows) {\n          this.addRow(row);\n        }\n      }\n    }\n  }\n\n  sort(options) {\n    // Since 8.3.0 col property can be also undefined, https://github.com/grafana/grafana/issues/44127\n    if (options.col === null || options.col === undefined || this.columns.length <= options.col) {\n      return;\n    }\n\n    this.rows.sort((a, b) => {\n      a = a[options.col];\n      b = b[options.col]; // Sort null or undefined separately from comparable values\n\n      return +(a == null) - +(b == null) || +(a > b) || -(a < b);\n    });\n\n    if (options.desc) {\n      this.rows.reverse();\n    }\n\n    this.columns[options.col].sort = true;\n    this.columns[options.col].desc = options.desc;\n  }\n\n  addColumn(col) {\n    if (!this.columnMap[col.text]) {\n      this.columns.push(col);\n      this.columnMap[col.text] = col;\n    }\n  }\n\n  addRow(row) {\n    this.rows.push(row);\n  }\n\n} // Returns true if both rows have matching non-empty fields as well as matching\n// indexes where one field is empty and the other is not\n\nfunction areRowsMatching(columns, row, otherRow) {\n  let foundFieldToMatch = false;\n\n  for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\n    if (row[columnIndex] !== undefined && otherRow[columnIndex] !== undefined) {\n      if (row[columnIndex] !== otherRow[columnIndex]) {\n        return false;\n      }\n    } else if (row[columnIndex] === undefined || otherRow[columnIndex] === undefined) {\n      foundFieldToMatch = true;\n    }\n  }\n\n  return foundFieldToMatch;\n}\n\nexport function mergeTablesIntoModel(dst, ...tables) {\n  const model = dst || new TableModel();\n\n  if (arguments.length === 1) {\n    return model;\n  } // Single query returns data columns and rows as is\n\n\n  if (arguments.length === 2) {\n    model.columns = tables[0].hasOwnProperty('columns') ? [...tables[0].columns] : [];\n    model.rows = tables[0].hasOwnProperty('rows') ? [...tables[0].rows] : [];\n    return model;\n  } // Filter out any tables that are not of TableData format\n\n\n  const tableDataTables = tables.filter(table => !!table.columns); // Track column indexes of union: name -> index\n\n  const columnNames = {}; // Union of all non-value columns\n\n  const columnsUnion = tableDataTables.slice().reduce((acc, series) => {\n    series.columns.forEach(col => {\n      const {\n        text\n      } = col;\n\n      if (columnNames[text] === undefined) {\n        columnNames[text] = acc.length;\n        acc.push(col);\n      }\n    });\n    return acc;\n  }, []); // Map old column index to union index per series, e.g.,\n  // given columnNames {A: 0, B: 1} and\n  // data [{columns: [{ text: 'A' }]}, {columns: [{ text: 'B' }]}] => [[0], [1]]\n\n  const columnIndexMapper = tableDataTables.map(series => series.columns.map(col => columnNames[col.text])); // Flatten rows of all series and adjust new column indexes\n\n  const flattenedRows = tableDataTables.reduce((acc, series, seriesIndex) => {\n    const mapper = columnIndexMapper[seriesIndex];\n    series.rows.forEach(row => {\n      const alteredRow = []; // Shifting entries according to index mapper\n\n      mapper.forEach((to, from) => {\n        alteredRow[to] = row[from];\n      });\n      acc.push(alteredRow);\n    });\n    return acc;\n  }, []); // Merge rows that have same values for columns\n\n  const mergedRows = {};\n  const compactedRows = flattenedRows.reduce((acc, row, rowIndex) => {\n    if (!mergedRows[rowIndex]) {\n      // Look from current row onwards\n      let offset = rowIndex + 1; // More than one row can be merged into current row\n\n      while (offset < flattenedRows.length) {\n        // Find next row that could be merged\n        const match = findIndex(flattenedRows, otherRow => areRowsMatching(columnsUnion, row, otherRow), offset);\n\n        if (match > -1) {\n          const matchedRow = flattenedRows[match]; // Merge values from match into current row if there is a gap in the current row\n\n          for (let columnIndex = 0; columnIndex < columnsUnion.length; columnIndex++) {\n            if (row[columnIndex] === undefined && matchedRow[columnIndex] !== undefined) {\n              row[columnIndex] = matchedRow[columnIndex];\n            }\n          } // Don't visit this row again\n\n\n          mergedRows[match] = matchedRow; // Keep looking for more rows to merge\n\n          offset = match + 1;\n        } else {\n          // No match found, stop looking\n          break;\n        }\n      }\n\n      acc.push(row);\n    }\n\n    return acc;\n  }, []);\n  model.columns = columnsUnion;\n  model.rows = compactedRows;\n  return model;\n}","map":{"version":3,"names":["findIndex","TableModel","constructor","table","columns","columnMap","rows","type","col","addColumn","row","addRow","sort","options","undefined","length","a","b","desc","reverse","text","push","areRowsMatching","otherRow","foundFieldToMatch","columnIndex","mergeTablesIntoModel","dst","tables","model","arguments","hasOwnProperty","tableDataTables","filter","columnNames","columnsUnion","slice","reduce","acc","series","forEach","columnIndexMapper","map","flattenedRows","seriesIndex","mapper","alteredRow","to","from","mergedRows","compactedRows","rowIndex","offset","match","matchedRow"],"sources":["/home/soula/grafana/public/app/core/table_model.ts"],"sourcesContent":["import { findIndex } from 'lodash';\n\nimport { Column, TableData, QueryResultMeta } from '@grafana/data';\n\n/**\n * Extends the standard Column class with variables that get\n * mutated in the angular table panel.\n */\nexport interface MutableColumn extends Column {\n  title?: string;\n  sort?: boolean;\n  desc?: boolean;\n  type?: string;\n}\n\nexport default class TableModel implements TableData {\n  columns: MutableColumn[];\n  rows: any[];\n  type: string;\n  columnMap: any;\n  refId?: string;\n  meta?: QueryResultMeta;\n\n  constructor(table?: any) {\n    this.columns = [];\n    this.columnMap = {};\n    this.rows = [];\n    this.type = 'table';\n\n    if (table) {\n      if (table.columns) {\n        for (const col of table.columns) {\n          this.addColumn(col);\n        }\n      }\n      if (table.rows) {\n        for (const row of table.rows) {\n          this.addRow(row);\n        }\n      }\n    }\n  }\n\n  sort(options: { col: number; desc: boolean }) {\n    // Since 8.3.0 col property can be also undefined, https://github.com/grafana/grafana/issues/44127\n    if (options.col === null || options.col === undefined || this.columns.length <= options.col) {\n      return;\n    }\n\n    this.rows.sort((a, b) => {\n      a = a[options.col];\n      b = b[options.col];\n      // Sort null or undefined separately from comparable values\n      return +(a == null) - +(b == null) || +(a > b) || -(a < b);\n    });\n\n    if (options.desc) {\n      this.rows.reverse();\n    }\n\n    this.columns[options.col].sort = true;\n    this.columns[options.col].desc = options.desc;\n  }\n\n  addColumn(col: Column) {\n    if (!this.columnMap[col.text]) {\n      this.columns.push(col);\n      this.columnMap[col.text] = col;\n    }\n  }\n\n  addRow(row: any[]) {\n    this.rows.push(row);\n  }\n}\n\n// Returns true if both rows have matching non-empty fields as well as matching\n// indexes where one field is empty and the other is not\nfunction areRowsMatching(columns: Column[], row: any[], otherRow: any[]) {\n  let foundFieldToMatch = false;\n  for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\n    if (row[columnIndex] !== undefined && otherRow[columnIndex] !== undefined) {\n      if (row[columnIndex] !== otherRow[columnIndex]) {\n        return false;\n      }\n    } else if (row[columnIndex] === undefined || otherRow[columnIndex] === undefined) {\n      foundFieldToMatch = true;\n    }\n  }\n  return foundFieldToMatch;\n}\n\nexport function mergeTablesIntoModel(dst?: TableModel, ...tables: TableModel[]): TableModel {\n  const model = dst || new TableModel();\n\n  if (arguments.length === 1) {\n    return model;\n  }\n  // Single query returns data columns and rows as is\n  if (arguments.length === 2) {\n    model.columns = tables[0].hasOwnProperty('columns') ? [...tables[0].columns] : [];\n    model.rows = tables[0].hasOwnProperty('rows') ? [...tables[0].rows] : [];\n    return model;\n  }\n\n  // Filter out any tables that are not of TableData format\n  const tableDataTables = tables.filter((table) => !!table.columns);\n\n  // Track column indexes of union: name -> index\n  const columnNames: { [key: string]: any } = {};\n\n  // Union of all non-value columns\n  const columnsUnion = tableDataTables.slice().reduce((acc, series) => {\n    series.columns.forEach((col) => {\n      const { text } = col;\n      if (columnNames[text] === undefined) {\n        columnNames[text] = acc.length;\n        acc.push(col);\n      }\n    });\n    return acc;\n  }, [] as MutableColumn[]);\n\n  // Map old column index to union index per series, e.g.,\n  // given columnNames {A: 0, B: 1} and\n  // data [{columns: [{ text: 'A' }]}, {columns: [{ text: 'B' }]}] => [[0], [1]]\n  const columnIndexMapper = tableDataTables.map((series) => series.columns.map((col) => columnNames[col.text]));\n\n  // Flatten rows of all series and adjust new column indexes\n  const flattenedRows = tableDataTables.reduce((acc, series, seriesIndex) => {\n    const mapper = columnIndexMapper[seriesIndex];\n    series.rows.forEach((row) => {\n      const alteredRow: MutableColumn[] = [];\n      // Shifting entries according to index mapper\n      mapper.forEach((to, from) => {\n        alteredRow[to] = row[from];\n      });\n      acc.push(alteredRow);\n    });\n    return acc;\n  }, [] as MutableColumn[][]);\n\n  // Merge rows that have same values for columns\n  const mergedRows: { [key: string]: any } = {};\n\n  const compactedRows = flattenedRows.reduce((acc, row, rowIndex) => {\n    if (!mergedRows[rowIndex]) {\n      // Look from current row onwards\n      let offset = rowIndex + 1;\n      // More than one row can be merged into current row\n      while (offset < flattenedRows.length) {\n        // Find next row that could be merged\n        const match = findIndex(flattenedRows, (otherRow) => areRowsMatching(columnsUnion, row, otherRow), offset);\n        if (match > -1) {\n          const matchedRow = flattenedRows[match];\n          // Merge values from match into current row if there is a gap in the current row\n          for (let columnIndex = 0; columnIndex < columnsUnion.length; columnIndex++) {\n            if (row[columnIndex] === undefined && matchedRow[columnIndex] !== undefined) {\n              row[columnIndex] = matchedRow[columnIndex];\n            }\n          }\n          // Don't visit this row again\n          mergedRows[match] = matchedRow;\n          // Keep looking for more rows to merge\n          offset = match + 1;\n        } else {\n          // No match found, stop looking\n          break;\n        }\n      }\n      acc.push(row);\n    }\n    return acc;\n  }, [] as MutableColumn[][]);\n\n  model.columns = columnsUnion;\n  model.rows = compactedRows;\n  return model;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}