{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { identity, pick, pickBy, groupBy, startCase } from 'lodash';\nimport { EMPTY, from, merge, of, throwError } from 'rxjs';\nimport { catchError, concatMap, map, mergeMap, toArray } from 'rxjs/operators';\nimport { FieldType, isValidGoDuration, LoadingState } from '@grafana/data';\nimport { config, DataSourceWithBackend, getBackendSrv, reportInteraction, getTemplateSrv } from '@grafana/runtime';\nimport { serializeParams } from 'app/core/utils/fetch';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\nimport { failedMetric, histogramMetric, mapPromMetricsToServiceMap, serviceMapMetrics, totalsMetric, rateMetric, durationMetric, errorRateMetric } from './graphTransform';\nimport { transformTrace, transformTraceList, transformFromOTLP as transformFromOTEL, createTableFrameFromSearch } from './resultTransformer'; // search = Loki search, nativeSearch = Tempo search for backwards compatibility\n\nexport const DEFAULT_LIMIT = 20;\nexport class TempoDatasource extends DataSourceWithBackend {\n  constructor(instanceSettings, templateSrv = getTemplateSrv()) {\n    super(instanceSettings);\n\n    _defineProperty(this, \"tracesToLogs\", void 0);\n\n    _defineProperty(this, \"serviceMap\", void 0);\n\n    _defineProperty(this, \"search\", void 0);\n\n    _defineProperty(this, \"nodeGraph\", void 0);\n\n    _defineProperty(this, \"lokiSearch\", void 0);\n\n    _defineProperty(this, \"uploadedJson\", null);\n\n    _defineProperty(this, \"getLokiSearchDS\", () => {\n      var _this$tracesToLogs, _this$tracesToLogs2, _this$lokiSearch$data, _this$lokiSearch;\n\n      const legacyLogsDatasourceUid = ((_this$tracesToLogs = this.tracesToLogs) === null || _this$tracesToLogs === void 0 ? void 0 : _this$tracesToLogs.lokiSearch) !== false && this.lokiSearch === undefined ? (_this$tracesToLogs2 = this.tracesToLogs) === null || _this$tracesToLogs2 === void 0 ? void 0 : _this$tracesToLogs2.datasourceUid : undefined;\n      return (_this$lokiSearch$data = (_this$lokiSearch = this.lokiSearch) === null || _this$lokiSearch === void 0 ? void 0 : _this$lokiSearch.datasourceUid) !== null && _this$lokiSearch$data !== void 0 ? _this$lokiSearch$data : legacyLogsDatasourceUid;\n    });\n\n    this.instanceSettings = instanceSettings;\n    this.templateSrv = templateSrv;\n    this.tracesToLogs = instanceSettings.jsonData.tracesToLogs;\n    this.serviceMap = instanceSettings.jsonData.serviceMap;\n    this.search = instanceSettings.jsonData.search;\n    this.nodeGraph = instanceSettings.jsonData.nodeGraph;\n    this.lokiSearch = instanceSettings.jsonData.lokiSearch;\n  }\n\n  query(options) {\n    var _targets$search, _targets$nativeSearch, _targets$upload, _this$serviceMap, _targets$serviceMap, _targets$traceId;\n\n    const subQueries = [];\n    const filteredTargets = options.targets.filter(target => !target.hide);\n    const targets = groupBy(filteredTargets, t => t.queryType || 'traceId');\n\n    if (targets.clear) {\n      return of({\n        data: [],\n        state: LoadingState.Done\n      });\n    }\n\n    const logsDatasourceUid = this.getLokiSearchDS(); // Run search queries on linked datasource\n\n    if (logsDatasourceUid && ((_targets$search = targets.search) === null || _targets$search === void 0 ? void 0 : _targets$search.length) > 0) {\n      const dsSrv = getDatasourceSrv();\n      subQueries.push(from(dsSrv.get(logsDatasourceUid)).pipe(mergeMap(linkedDatasource => {\n        var _settings$jsonData$de;\n\n        // Wrap linked query into a data request based on original request\n        const linkedRequest = Object.assign({}, options, {\n          targets: targets.search.map(t => t.linkedQuery)\n        }); // Find trace matchers in derived fields of the linked datasource that's identical to this datasource\n\n        const settings = linkedDatasource.instanceSettings;\n        const traceLinkMatcher = ((_settings$jsonData$de = settings.jsonData.derivedFields) === null || _settings$jsonData$de === void 0 ? void 0 : _settings$jsonData$de.filter(field => field.datasourceUid === this.uid && field.matcherRegex).map(field => field.matcherRegex)) || [];\n\n        if (!traceLinkMatcher || traceLinkMatcher.length === 0) {\n          return throwError(() => new Error('No Loki datasource configured for search. Set up Derived Fields for traces in a Loki datasource settings and link it to this Tempo datasource.'));\n        } else {\n          return linkedDatasource.query(linkedRequest).pipe(map(response => response.error ? response : transformTraceList(response, this.uid, this.name, traceLinkMatcher)));\n        }\n      })));\n    }\n\n    if ((_targets$nativeSearch = targets.nativeSearch) !== null && _targets$nativeSearch !== void 0 && _targets$nativeSearch.length) {\n      try {\n        var _options$app, _targets$nativeSearch2, _targets$nativeSearch3, _targets$nativeSearch4, _targets$nativeSearch5;\n\n        reportInteraction('grafana_traces_search_queried', {\n          datasourceType: 'tempo',\n          app: (_options$app = options.app) !== null && _options$app !== void 0 ? _options$app : '',\n          serviceName: (_targets$nativeSearch2 = targets.nativeSearch[0].serviceName) !== null && _targets$nativeSearch2 !== void 0 ? _targets$nativeSearch2 : '',\n          spanName: (_targets$nativeSearch3 = targets.nativeSearch[0].spanName) !== null && _targets$nativeSearch3 !== void 0 ? _targets$nativeSearch3 : '',\n          limit: (_targets$nativeSearch4 = targets.nativeSearch[0].limit) !== null && _targets$nativeSearch4 !== void 0 ? _targets$nativeSearch4 : '',\n          search: (_targets$nativeSearch5 = targets.nativeSearch[0].search) !== null && _targets$nativeSearch5 !== void 0 ? _targets$nativeSearch5 : ''\n        });\n        const timeRange = {\n          startTime: options.range.from.unix(),\n          endTime: options.range.to.unix()\n        };\n        const query = this.applyVariables(targets.nativeSearch[0], options.scopedVars);\n        const searchQuery = this.buildSearchQuery(query, timeRange);\n        subQueries.push(this._request('/api/search', searchQuery).pipe(map(response => {\n          return {\n            data: [createTableFrameFromSearch(response.data.traces, this.instanceSettings)]\n          };\n        }), catchError(error => {\n          return of({\n            error: {\n              message: error.data.message\n            },\n            data: []\n          });\n        })));\n      } catch (error) {\n        return of({\n          error: {\n            message: error instanceof Error ? error.message : 'Unknown error occurred'\n          },\n          data: []\n        });\n      }\n    }\n\n    if ((_targets$upload = targets.upload) !== null && _targets$upload !== void 0 && _targets$upload.length) {\n      if (this.uploadedJson) {\n        const jsonData = JSON.parse(this.uploadedJson);\n        const isTraceData = jsonData.batches;\n        const isServiceGraphData = Array.isArray(jsonData) && jsonData.some(df => {\n          var _df$meta;\n\n          return (df === null || df === void 0 ? void 0 : (_df$meta = df.meta) === null || _df$meta === void 0 ? void 0 : _df$meta.preferredVisualisationType) === 'nodeGraph';\n        });\n\n        if (isTraceData) {\n          var _this$nodeGraph;\n\n          subQueries.push(of(transformFromOTEL(jsonData.batches, (_this$nodeGraph = this.nodeGraph) === null || _this$nodeGraph === void 0 ? void 0 : _this$nodeGraph.enabled)));\n        } else if (isServiceGraphData) {\n          subQueries.push(of({\n            data: jsonData,\n            state: LoadingState.Done\n          }));\n        } else {\n          subQueries.push(of({\n            error: {\n              message: 'Unable to parse uploaded data.'\n            },\n            data: []\n          }));\n        }\n      } else {\n        subQueries.push(of({\n          data: [],\n          state: LoadingState.Done\n        }));\n      }\n    }\n\n    if ((_this$serviceMap = this.serviceMap) !== null && _this$serviceMap !== void 0 && _this$serviceMap.datasourceUid && ((_targets$serviceMap = targets.serviceMap) === null || _targets$serviceMap === void 0 ? void 0 : _targets$serviceMap.length) > 0) {\n      const dsId = this.serviceMap.datasourceUid;\n\n      if (config.featureToggles.tempoApmTable) {\n        subQueries.push(serviceMapQuery(options, dsId, this.name).pipe(concatMap(result => rateQuery(options, result, dsId).pipe(concatMap(result => errorAndDurationQuery(options, result, dsId, this.name))))));\n      } else {\n        subQueries.push(serviceMapQuery(options, dsId, this.name));\n      }\n    }\n\n    if (((_targets$traceId = targets.traceId) === null || _targets$traceId === void 0 ? void 0 : _targets$traceId.length) > 0) {\n      var _options$app2, _targets$traceId$0$qu;\n\n      reportInteraction('grafana_traces_traceID_queried', {\n        datasourceType: 'tempo',\n        app: (_options$app2 = options.app) !== null && _options$app2 !== void 0 ? _options$app2 : '',\n        query: (_targets$traceId$0$qu = targets.traceId[0].query) !== null && _targets$traceId$0$qu !== void 0 ? _targets$traceId$0$qu : ''\n      });\n      subQueries.push(this.handleTraceIdQuery(options, targets.traceId));\n    }\n\n    return merge(...subQueries);\n  }\n\n  applyTemplateVariables(query, scopedVars) {\n    return this.applyVariables(query, scopedVars);\n  }\n\n  interpolateVariablesInQueries(queries, scopedVars) {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    return queries.map(query => {\n      return Object.assign({}, query, {\n        datasource: this.getRef()\n      }, this.applyVariables(query, scopedVars));\n    });\n  }\n\n  applyVariables(query, scopedVars) {\n    var _query$query, _query$search, _query$minDuration, _query$maxDuration;\n\n    const expandedQuery = Object.assign({}, query);\n\n    if (query.linkedQuery) {\n      var _query$linkedQuery$ex, _query$linkedQuery;\n\n      expandedQuery.linkedQuery = Object.assign({}, query.linkedQuery, {\n        expr: this.templateSrv.replace((_query$linkedQuery$ex = (_query$linkedQuery = query.linkedQuery) === null || _query$linkedQuery === void 0 ? void 0 : _query$linkedQuery.expr) !== null && _query$linkedQuery$ex !== void 0 ? _query$linkedQuery$ex : '', scopedVars)\n      });\n    }\n\n    return Object.assign({}, expandedQuery, {\n      query: this.templateSrv.replace((_query$query = query.query) !== null && _query$query !== void 0 ? _query$query : '', scopedVars),\n      search: this.templateSrv.replace((_query$search = query.search) !== null && _query$search !== void 0 ? _query$search : '', scopedVars),\n      minDuration: this.templateSrv.replace((_query$minDuration = query.minDuration) !== null && _query$minDuration !== void 0 ? _query$minDuration : '', scopedVars),\n      maxDuration: this.templateSrv.replace((_query$maxDuration = query.maxDuration) !== null && _query$maxDuration !== void 0 ? _query$maxDuration : '', scopedVars)\n    });\n  }\n  /**\n   * Handles the simplest of the queries where we have just a trace id and return trace data for it.\n   * @param options\n   * @param targets\n   * @private\n   */\n\n\n  handleTraceIdQuery(options, targets) {\n    const validTargets = targets.filter(t => t.query).map(t => Object.assign({}, t, {\n      query: t.query.trim()\n    }));\n\n    if (!validTargets.length) {\n      return EMPTY;\n    }\n\n    const traceRequest = Object.assign({}, options, {\n      targets: validTargets\n    });\n    return super.query(traceRequest).pipe(map(response => {\n      var _this$nodeGraph2;\n\n      if (response.error) {\n        return response;\n      }\n\n      return transformTrace(response, (_this$nodeGraph2 = this.nodeGraph) === null || _this$nodeGraph2 === void 0 ? void 0 : _this$nodeGraph2.enabled);\n    }));\n  }\n\n  async metadataRequest(url, params = {}) {\n    return await this._request(url, params, {\n      method: 'GET',\n      hideFromInspector: true\n    }).toPromise();\n  }\n\n  _request(apiUrl, data, options) {\n    const params = data ? serializeParams(data) : '';\n    const url = `${this.instanceSettings.url}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = Object.assign({}, options, {\n      url\n    });\n    return getBackendSrv().fetch(req);\n  }\n\n  async testDatasource() {\n    const options = {\n      headers: {},\n      method: 'GET',\n      url: `${this.instanceSettings.url}/api/echo`\n    };\n    const response = await getBackendSrv().fetch(options).toPromise();\n\n    if (response !== null && response !== void 0 && response.ok) {\n      return {\n        status: 'success',\n        message: 'Data source is working'\n      };\n    }\n  }\n\n  getQueryDisplayText(query) {\n    if (query.queryType === 'nativeSearch') {\n      let result = [];\n\n      for (const key of ['serviceName', 'spanName', 'search', 'minDuration', 'maxDuration', 'limit']) {\n        if (query.hasOwnProperty(key) && query[key]) {\n          result.push(`${startCase(key)}: ${query[key]}`);\n        }\n      }\n\n      return result.join(', ');\n    }\n\n    return query.query;\n  }\n\n  buildSearchQuery(query, timeRange) {\n    var _query$search2;\n\n    let tags = (_query$search2 = query.search) !== null && _query$search2 !== void 0 ? _query$search2 : '';\n    let tempoQuery = pick(query, ['minDuration', 'maxDuration', 'limit']); // Remove empty properties\n\n    tempoQuery = pickBy(tempoQuery, identity);\n\n    if (query.serviceName) {\n      tags += ` service.name=\"${query.serviceName}\"`;\n    }\n\n    if (query.spanName) {\n      tags += ` name=\"${query.spanName}\"`;\n    } // Set default limit\n\n\n    if (!tempoQuery.limit) {\n      tempoQuery.limit = DEFAULT_LIMIT;\n    } // Validate query inputs and remove spaces if valid\n\n\n    if (tempoQuery.minDuration) {\n      var _tempoQuery$minDurati;\n\n      tempoQuery.minDuration = this.templateSrv.replace((_tempoQuery$minDurati = tempoQuery.minDuration) !== null && _tempoQuery$minDurati !== void 0 ? _tempoQuery$minDurati : '');\n\n      if (!isValidGoDuration(tempoQuery.minDuration)) {\n        throw new Error('Please enter a valid min duration.');\n      }\n\n      tempoQuery.minDuration = tempoQuery.minDuration.replace(/\\s/g, '');\n    }\n\n    if (tempoQuery.maxDuration) {\n      var _tempoQuery$maxDurati;\n\n      tempoQuery.maxDuration = this.templateSrv.replace((_tempoQuery$maxDurati = tempoQuery.maxDuration) !== null && _tempoQuery$maxDurati !== void 0 ? _tempoQuery$maxDurati : '');\n\n      if (!isValidGoDuration(tempoQuery.maxDuration)) {\n        throw new Error('Please enter a valid max duration.');\n      }\n\n      tempoQuery.maxDuration = tempoQuery.maxDuration.replace(/\\s/g, '');\n    }\n\n    if (!Number.isInteger(tempoQuery.limit) || tempoQuery.limit <= 0) {\n      throw new Error('Please enter a valid limit.');\n    }\n\n    let searchQuery = Object.assign({\n      tags\n    }, tempoQuery);\n\n    if (timeRange) {\n      searchQuery.start = timeRange.startTime;\n      searchQuery.end = timeRange.endTime;\n    }\n\n    return searchQuery;\n  }\n\n  async getServiceGraphLabels() {\n    const ds = await getDatasourceSrv().get(this.serviceMap.datasourceUid);\n    return ds.getTagKeys();\n  }\n\n  async getServiceGraphLabelValues(key) {\n    const ds = await getDatasourceSrv().get(this.serviceMap.datasourceUid);\n    return ds.getTagValues({\n      key\n    });\n  } // Get linked loki search datasource. Fall back to legacy loki search/trace to logs config\n\n\n}\n\nfunction queryPrometheus(request, datasourceUid) {\n  return from(getDatasourceSrv().get(datasourceUid)).pipe(mergeMap(ds => {\n    return ds.query(request);\n  }));\n}\n\nfunction serviceMapQuery(request, datasourceUid, tempoDatasourceUid) {\n  const serviceMapRequest = makePromServiceMapRequest(request);\n  return queryPrometheus(serviceMapRequest, datasourceUid).pipe( // Just collect all the responses first before processing into node graph data\n  toArray(), map(responses => {\n    const errorRes = responses.find(res => !!res.error);\n\n    if (errorRes) {\n      throw new Error(errorRes.error.message);\n    }\n\n    const {\n      nodes,\n      edges\n    } = mapPromMetricsToServiceMap(responses, request.range);\n    nodes.fields[0].config = {\n      links: [makePromLink('Request rate', `sum by (client, server)(rate(${totalsMetric}{server=\"\\${__data.fields.id}\"}[$__rate_interval]))`, datasourceUid, false), makePromLink('Request histogram', `histogram_quantile(0.9, sum(rate(${histogramMetric}{server=\"\\${__data.fields.id}\"}[$__rate_interval])) by (le, client, server))`, datasourceUid, false), makePromLink('Failed request rate', `sum by (client, server)(rate(${failedMetric}{server=\"\\${__data.fields.id}\"}[$__rate_interval]))`, datasourceUid, false), makeTempoLink('View traces', `\\${__data.fields[0]}`, '', tempoDatasourceUid)]\n    };\n    return {\n      data: [nodes, edges],\n      state: LoadingState.Done\n    };\n  }));\n}\n\nfunction rateQuery(request, serviceMapResponse, datasourceUid) {\n  const serviceMapRequest = makePromServiceMapRequest(request);\n  serviceMapRequest.targets = makeApmRequest([buildExpr(rateMetric, '', request)]);\n  return queryPrometheus(serviceMapRequest, datasourceUid).pipe(toArray(), map(responses => {\n    var _responses$0$data, _responses$;\n\n    const errorRes = responses.find(res => !!res.error);\n\n    if (errorRes) {\n      throw new Error(errorRes.error.message);\n    }\n\n    return {\n      data: [(_responses$0$data = (_responses$ = responses[0]) === null || _responses$ === void 0 ? void 0 : _responses$.data) !== null && _responses$0$data !== void 0 ? _responses$0$data : [], serviceMapResponse.data[0], serviceMapResponse.data[1]],\n      state: LoadingState.Done\n    };\n  }));\n} // we need the response from the rate query to get the rate span_name(s),\n// -> which determine the errorRate/duration span_name(s) we need to query\n\n\nfunction errorAndDurationQuery(request, rateResponse, datasourceUid, tempoDatasourceUid) {\n  var _rateResponse$data$0$, _rateResponse$data$0$2, _rateResponse$data$0$3;\n\n  let apmMetrics = [];\n  let errorRateBySpanName = '';\n  let durationsBySpanName = [];\n  const spanNames = (_rateResponse$data$0$ = (_rateResponse$data$0$2 = rateResponse.data[0][0]) === null || _rateResponse$data$0$2 === void 0 ? void 0 : (_rateResponse$data$0$3 = _rateResponse$data$0$2.fields[1]) === null || _rateResponse$data$0$3 === void 0 ? void 0 : _rateResponse$data$0$3.values.toArray()) !== null && _rateResponse$data$0$ !== void 0 ? _rateResponse$data$0$ : [];\n\n  if (spanNames.length > 0) {\n    errorRateBySpanName = buildExpr(errorRateMetric, 'span_name=~\"' + spanNames.join('|') + '\"', request);\n    apmMetrics.push(errorRateBySpanName);\n    spanNames.map(name => {\n      const metric = buildExpr(durationMetric, 'span_name=~\"' + name + '\"', request);\n      durationsBySpanName.push(metric);\n      apmMetrics.push(metric);\n    });\n  }\n\n  const serviceMapRequest = makePromServiceMapRequest(request);\n  serviceMapRequest.targets = makeApmRequest(apmMetrics);\n  return queryPrometheus(serviceMapRequest, datasourceUid).pipe( // Just collect all the responses first before processing into node graph data\n  toArray(), map(errorAndDurationResponse => {\n    const errorRes = errorAndDurationResponse.find(res => !!res.error);\n\n    if (errorRes) {\n      throw new Error(errorRes.error.message);\n    }\n\n    const apmTable = getApmTable(request, rateResponse, errorAndDurationResponse[0], errorRateBySpanName, durationsBySpanName, datasourceUid, tempoDatasourceUid);\n\n    if (apmTable.fields.length === 0) {\n      return {\n        data: [rateResponse.data[1], rateResponse.data[2]],\n        state: LoadingState.Done\n      };\n    }\n\n    return {\n      data: [apmTable, rateResponse.data[1], rateResponse.data[2]],\n      state: LoadingState.Done\n    };\n  }));\n}\n\nfunction makePromLink(title, expr, datasourceUid, instant) {\n  return {\n    url: '',\n    title,\n    internal: {\n      query: {\n        expr: expr,\n        range: !instant,\n        exemplar: !instant,\n        instant: instant\n      },\n      datasourceUid,\n      datasourceName: 'Prometheus'\n    }\n  };\n}\n\nexport function makeTempoLink(title, serviceName, spanName, datasourceUid) {\n  let query = {\n    queryType: 'nativeSearch'\n  };\n\n  if (serviceName !== '') {\n    query.serviceName = serviceName;\n  }\n\n  if (spanName !== '') {\n    query.spanName = spanName;\n  }\n\n  return {\n    url: '',\n    title,\n    internal: {\n      query,\n      datasourceUid: datasourceUid,\n      datasourceName: 'Tempo'\n    }\n  };\n}\n\nfunction makePromServiceMapRequest(options) {\n  return Object.assign({}, options, {\n    targets: serviceMapMetrics.map(metric => {\n      return {\n        refId: metric,\n        // options.targets[0] is not correct here, but not sure what should happen if you have multiple queries for\n        // service map at the same time anyway\n        expr: `rate(${metric}${options.targets[0].serviceMapQuery || ''}[$__range])`,\n        instant: true\n      };\n    })\n  });\n}\n\nfunction getApmTable(request, rateResponse, secondResponse, errorRateBySpanName, durationsBySpanName, datasourceUid, tempoDatasourceUid) {\n  var _rateResponse$data$, _rate$0$fields, _errorRate$0$fields, _duration$0$fields;\n\n  let df = {\n    fields: []\n  };\n  const rate = (_rateResponse$data$ = rateResponse.data[0]) === null || _rateResponse$data$ === void 0 ? void 0 : _rateResponse$data$.filter(x => {\n    return x.refId === buildExpr(rateMetric, '', request);\n  });\n  const errorRate = secondResponse.data.filter(x => {\n    return x.refId === errorRateBySpanName;\n  });\n  const duration = secondResponse.data.filter(x => {\n    return durationsBySpanName.includes(x.refId);\n  });\n\n  if (rate.length > 0 && ((_rate$0$fields = rate[0].fields) === null || _rate$0$fields === void 0 ? void 0 : _rate$0$fields.length) > 2) {\n    df.fields.push(Object.assign({}, rate[0].fields[1], {\n      name: 'Name',\n      config: {\n        filterable: false\n      }\n    }));\n    df.fields.push(Object.assign({}, rate[0].fields[2], {\n      name: 'Rate',\n      config: {\n        links: [makePromLink('Rate', buildLinkExpr(buildExpr(rateMetric, 'span_name=\"${__data.fields[0]}\"', request)), datasourceUid, false)],\n        decimals: 2\n      }\n    }));\n    df.fields.push(Object.assign({}, rate[0].fields[2], {\n      name: ' ',\n      labels: null,\n      config: {\n        color: {\n          mode: 'continuous-BlPu'\n        },\n        custom: {\n          displayMode: 'lcd-gauge'\n        },\n        decimals: 3\n      }\n    }));\n  }\n\n  if (errorRate.length > 0 && ((_errorRate$0$fields = errorRate[0].fields) === null || _errorRate$0$fields === void 0 ? void 0 : _errorRate$0$fields.length) > 2) {\n    var _errorRate$0$fields$, _errorRate$0$fields$2, _errorRate$0$fields$3, _errorRate$0$fields$4;\n\n    const errorRateNames = (_errorRate$0$fields$ = (_errorRate$0$fields$2 = errorRate[0].fields[1]) === null || _errorRate$0$fields$2 === void 0 ? void 0 : _errorRate$0$fields$2.values.toArray()) !== null && _errorRate$0$fields$ !== void 0 ? _errorRate$0$fields$ : [];\n    const errorRateValues = (_errorRate$0$fields$3 = (_errorRate$0$fields$4 = errorRate[0].fields[2]) === null || _errorRate$0$fields$4 === void 0 ? void 0 : _errorRate$0$fields$4.values.toArray()) !== null && _errorRate$0$fields$3 !== void 0 ? _errorRate$0$fields$3 : [];\n    let errorRateObj = {};\n    errorRateNames.map((name, index) => {\n      errorRateObj[name] = {\n        name: name,\n        value: errorRateValues[index]\n      };\n    });\n    const values = getRateAlignedValues(rate, errorRateObj);\n    df.fields.push(Object.assign({}, errorRate[0].fields[2], {\n      name: 'Error Rate',\n      values: values,\n      config: {\n        links: [makePromLink('Error Rate', buildLinkExpr(buildExpr(errorRateMetric, 'span_name=\"${__data.fields[0]}\"', request)), datasourceUid, false)],\n        decimals: 2\n      }\n    }));\n    df.fields.push(Object.assign({}, errorRate[0].fields[2], {\n      name: '  ',\n      values: values,\n      labels: null,\n      config: {\n        color: {\n          mode: 'continuous-RdYlGr'\n        },\n        custom: {\n          displayMode: 'lcd-gauge'\n        },\n        decimals: 3\n      }\n    }));\n  }\n\n  if (duration.length > 0 && ((_duration$0$fields = duration[0].fields) === null || _duration$0$fields === void 0 ? void 0 : _duration$0$fields.length) > 1) {\n    let durationObj = {};\n    duration.map(d => {\n      var _d$refId, _d$refId2;\n\n      const delimiter = (_d$refId = d.refId) !== null && _d$refId !== void 0 && _d$refId.includes('span_name=~\"') ? 'span_name=~\"' : 'span_name=\"';\n      const name = (_d$refId2 = d.refId) === null || _d$refId2 === void 0 ? void 0 : _d$refId2.split(delimiter)[1].split('\"}')[0];\n      durationObj[name] = {\n        name: name,\n        value: d.fields[1].values.toArray()[0]\n      };\n    });\n    df.fields.push(Object.assign({}, duration[0].fields[1], {\n      name: 'Duration (p90)',\n      values: getRateAlignedValues(rate, durationObj),\n      config: {\n        links: [makePromLink('Duration', buildLinkExpr(buildExpr(durationMetric, 'span_name=\"${__data.fields[0]}\"', request)), datasourceUid, false)],\n        unit: 's'\n      }\n    }));\n  }\n\n  if (df.fields.length > 0 && df.fields[0].values) {\n    df.fields.push({\n      name: 'Links',\n      type: FieldType.string,\n      values: df.fields[0].values.map(() => {\n        return 'Tempo';\n      }),\n      config: {\n        links: [makeTempoLink('Tempo', '', `\\${__data.fields[0]}`, tempoDatasourceUid)]\n      }\n    });\n  }\n\n  return df;\n}\n\nexport function buildExpr(metric, extraParams, request) {\n  var _request$targets$0$se, _request$targets$, _request$targets$$ser;\n\n  let serviceMapQuery = (_request$targets$0$se = (_request$targets$ = request.targets[0]) === null || _request$targets$ === void 0 ? void 0 : (_request$targets$$ser = _request$targets$.serviceMapQuery) === null || _request$targets$$ser === void 0 ? void 0 : _request$targets$$ser.replace('{', '').replace('}', '')) !== null && _request$targets$0$se !== void 0 ? _request$targets$0$se : ''; // map serviceGraph metric tags to APM metric tags\n\n  serviceMapQuery = serviceMapQuery.replace('client', 'service').replace('server', 'service');\n  const metricParams = serviceMapQuery.includes('span_name') ? metric.params.concat(serviceMapQuery) : metric.params.concat(serviceMapQuery).concat(extraParams).filter(item => item);\n  return metric.expr.replace('{}', '{' + metricParams.join(',') + '}');\n}\nexport function buildLinkExpr(expr) {\n  // don't want top 5 or by span name in links\n  expr = expr.replace('topk(5, ', '').replace(' by (span_name))', '');\n  return expr.replace('__range', '__rate_interval');\n} // query result frames can come back in any order\n// here we align the table col values to the same row name (rateName) across the table\n\nexport function getRateAlignedValues(rateResp, objToAlign) {\n  var _rateResp$0$fields$1$, _rateResp$, _rateResp$$fields$;\n\n  const rateNames = (_rateResp$0$fields$1$ = (_rateResp$ = rateResp[0]) === null || _rateResp$ === void 0 ? void 0 : (_rateResp$$fields$ = _rateResp$.fields[1]) === null || _rateResp$$fields$ === void 0 ? void 0 : _rateResp$$fields$.values.toArray().sort()) !== null && _rateResp$0$fields$1$ !== void 0 ? _rateResp$0$fields$1$ : [];\n  let tempRateNames = rateNames;\n  let values = [];\n  objToAlign = Object.keys(objToAlign).sort().reduce((obj, key) => {\n    obj[key] = objToAlign[key];\n    return obj;\n  }, {});\n\n  for (let i = 0; i < rateNames.length; i++) {\n    if (tempRateNames[i]) {\n      if (tempRateNames[i] === Object.keys(objToAlign)[i]) {\n        values.push(objToAlign[Object.keys(objToAlign)[i]].value);\n      } else {\n        i--;\n        tempRateNames = tempRateNames.slice(1);\n        values.push('0');\n      }\n    }\n  }\n\n  return values;\n}\nexport function makeApmRequest(metrics) {\n  return metrics.map(metric => {\n    return {\n      refId: metric,\n      expr: metric,\n      instant: true\n    };\n  });\n}","map":{"version":3,"names":["identity","pick","pickBy","groupBy","startCase","EMPTY","from","merge","of","throwError","catchError","concatMap","map","mergeMap","toArray","FieldType","isValidGoDuration","LoadingState","config","DataSourceWithBackend","getBackendSrv","reportInteraction","getTemplateSrv","serializeParams","getDatasourceSrv","failedMetric","histogramMetric","mapPromMetricsToServiceMap","serviceMapMetrics","totalsMetric","rateMetric","durationMetric","errorRateMetric","transformTrace","transformTraceList","transformFromOTLP","transformFromOTEL","createTableFrameFromSearch","DEFAULT_LIMIT","TempoDatasource","constructor","instanceSettings","templateSrv","legacyLogsDatasourceUid","tracesToLogs","lokiSearch","undefined","datasourceUid","jsonData","serviceMap","search","nodeGraph","query","options","subQueries","filteredTargets","targets","filter","target","hide","t","queryType","clear","data","state","Done","logsDatasourceUid","getLokiSearchDS","length","dsSrv","push","get","pipe","linkedDatasource","linkedRequest","linkedQuery","settings","traceLinkMatcher","derivedFields","field","uid","matcherRegex","Error","response","error","name","nativeSearch","datasourceType","app","serviceName","spanName","limit","timeRange","startTime","range","unix","endTime","to","applyVariables","scopedVars","searchQuery","buildSearchQuery","_request","traces","message","upload","uploadedJson","JSON","parse","isTraceData","batches","isServiceGraphData","Array","isArray","some","df","meta","preferredVisualisationType","enabled","dsId","featureToggles","tempoApmTable","serviceMapQuery","result","rateQuery","errorAndDurationQuery","traceId","handleTraceIdQuery","applyTemplateVariables","interpolateVariablesInQueries","queries","datasource","getRef","expandedQuery","expr","replace","minDuration","maxDuration","validTargets","trim","traceRequest","metadataRequest","url","params","method","hideFromInspector","toPromise","apiUrl","req","fetch","testDatasource","headers","ok","status","getQueryDisplayText","key","hasOwnProperty","join","tags","tempoQuery","Number","isInteger","start","end","getServiceGraphLabels","ds","getTagKeys","getServiceGraphLabelValues","getTagValues","queryPrometheus","request","tempoDatasourceUid","serviceMapRequest","makePromServiceMapRequest","responses","errorRes","find","res","nodes","edges","fields","links","makePromLink","makeTempoLink","serviceMapResponse","makeApmRequest","buildExpr","rateResponse","apmMetrics","errorRateBySpanName","durationsBySpanName","spanNames","values","metric","errorAndDurationResponse","apmTable","getApmTable","title","instant","internal","exemplar","datasourceName","refId","secondResponse","rate","x","errorRate","duration","includes","filterable","buildLinkExpr","decimals","labels","color","mode","custom","displayMode","errorRateNames","errorRateValues","errorRateObj","index","value","getRateAlignedValues","durationObj","d","delimiter","split","unit","type","string","extraParams","metricParams","concat","item","rateResp","objToAlign","rateNames","sort","tempRateNames","Object","keys","reduce","obj","i","slice","metrics"],"sources":["/home/soula/grafana/public/app/plugins/datasource/tempo/datasource.ts"],"sourcesContent":["import { identity, pick, pickBy, groupBy, startCase } from 'lodash';\nimport { EMPTY, from, merge, Observable, of, throwError } from 'rxjs';\nimport { catchError, concatMap, map, mergeMap, toArray } from 'rxjs/operators';\n\nimport {\n  DataQuery,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataQueryResponseData,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataSourceJsonData,\n  FieldType,\n  isValidGoDuration,\n  LoadingState,\n  ScopedVars,\n} from '@grafana/data';\nimport {\n  config,\n  BackendSrvRequest,\n  DataSourceWithBackend,\n  getBackendSrv,\n  reportInteraction,\n  TemplateSrv,\n  getTemplateSrv,\n} from '@grafana/runtime';\nimport { NodeGraphOptions } from 'app/core/components/NodeGraphSettings';\nimport { TraceToLogsOptions } from 'app/core/components/TraceToLogs/TraceToLogsSettings';\nimport { serializeParams } from 'app/core/utils/fetch';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\n\nimport { LokiOptions, LokiQuery } from '../loki/types';\nimport { PrometheusDatasource } from '../prometheus/datasource';\nimport { PromQuery } from '../prometheus/types';\n\nimport {\n  failedMetric,\n  histogramMetric,\n  mapPromMetricsToServiceMap,\n  serviceMapMetrics,\n  totalsMetric,\n  rateMetric,\n  durationMetric,\n  errorRateMetric,\n} from './graphTransform';\nimport {\n  transformTrace,\n  transformTraceList,\n  transformFromOTLP as transformFromOTEL,\n  createTableFrameFromSearch,\n} from './resultTransformer';\n\n// search = Loki search, nativeSearch = Tempo search for backwards compatibility\nexport type TempoQueryType = 'search' | 'traceId' | 'serviceMap' | 'upload' | 'nativeSearch' | 'clear';\n\nexport interface TempoJsonData extends DataSourceJsonData {\n  tracesToLogs?: TraceToLogsOptions;\n  serviceMap?: {\n    datasourceUid?: string;\n  };\n  search?: {\n    hide?: boolean;\n  };\n  nodeGraph?: NodeGraphOptions;\n  lokiSearch?: {\n    datasourceUid?: string;\n  };\n}\n\nexport interface TempoQuery extends DataQuery {\n  query: string;\n  // Query to find list of traces, e.g., via Loki\n  linkedQuery?: LokiQuery;\n  search: string;\n  queryType: TempoQueryType;\n  serviceName?: string;\n  spanName?: string;\n  minDuration?: string;\n  maxDuration?: string;\n  limit?: number;\n  serviceMapQuery?: string;\n}\n\ninterface SearchQueryParams {\n  minDuration?: string;\n  maxDuration?: string;\n  limit?: number;\n  tags: string;\n  start?: number;\n  end?: number;\n}\n\nexport const DEFAULT_LIMIT = 20;\n\nexport class TempoDatasource extends DataSourceWithBackend<TempoQuery, TempoJsonData> {\n  tracesToLogs?: TraceToLogsOptions;\n  serviceMap?: {\n    datasourceUid?: string;\n  };\n  search?: {\n    hide?: boolean;\n  };\n  nodeGraph?: NodeGraphOptions;\n  lokiSearch?: {\n    datasourceUid?: string;\n  };\n  uploadedJson?: string | ArrayBuffer | null = null;\n\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<TempoJsonData>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv()\n  ) {\n    super(instanceSettings);\n    this.tracesToLogs = instanceSettings.jsonData.tracesToLogs;\n    this.serviceMap = instanceSettings.jsonData.serviceMap;\n    this.search = instanceSettings.jsonData.search;\n    this.nodeGraph = instanceSettings.jsonData.nodeGraph;\n    this.lokiSearch = instanceSettings.jsonData.lokiSearch;\n  }\n\n  query(options: DataQueryRequest<TempoQuery>): Observable<DataQueryResponse> {\n    const subQueries: Array<Observable<DataQueryResponse>> = [];\n    const filteredTargets = options.targets.filter((target) => !target.hide);\n    const targets: { [type: string]: TempoQuery[] } = groupBy(filteredTargets, (t) => t.queryType || 'traceId');\n\n    if (targets.clear) {\n      return of({ data: [], state: LoadingState.Done });\n    }\n\n    const logsDatasourceUid = this.getLokiSearchDS();\n\n    // Run search queries on linked datasource\n    if (logsDatasourceUid && targets.search?.length > 0) {\n      const dsSrv = getDatasourceSrv();\n      subQueries.push(\n        from(dsSrv.get(logsDatasourceUid)).pipe(\n          mergeMap((linkedDatasource: DataSourceApi) => {\n            // Wrap linked query into a data request based on original request\n            const linkedRequest: DataQueryRequest = { ...options, targets: targets.search.map((t) => t.linkedQuery!) };\n            // Find trace matchers in derived fields of the linked datasource that's identical to this datasource\n            const settings: DataSourceInstanceSettings<LokiOptions> = (linkedDatasource as any).instanceSettings;\n            const traceLinkMatcher: string[] =\n              settings.jsonData.derivedFields\n                ?.filter((field) => field.datasourceUid === this.uid && field.matcherRegex)\n                .map((field) => field.matcherRegex) || [];\n\n            if (!traceLinkMatcher || traceLinkMatcher.length === 0) {\n              return throwError(\n                () =>\n                  new Error(\n                    'No Loki datasource configured for search. Set up Derived Fields for traces in a Loki datasource settings and link it to this Tempo datasource.'\n                  )\n              );\n            } else {\n              return (linkedDatasource.query(linkedRequest) as Observable<DataQueryResponse>).pipe(\n                map((response) =>\n                  response.error ? response : transformTraceList(response, this.uid, this.name, traceLinkMatcher)\n                )\n              );\n            }\n          })\n        )\n      );\n    }\n\n    if (targets.nativeSearch?.length) {\n      try {\n        reportInteraction('grafana_traces_search_queried', {\n          datasourceType: 'tempo',\n          app: options.app ?? '',\n          serviceName: targets.nativeSearch[0].serviceName ?? '',\n          spanName: targets.nativeSearch[0].spanName ?? '',\n          limit: targets.nativeSearch[0].limit ?? '',\n          search: targets.nativeSearch[0].search ?? '',\n        });\n\n        const timeRange = { startTime: options.range.from.unix(), endTime: options.range.to.unix() };\n        const query = this.applyVariables(targets.nativeSearch[0], options.scopedVars);\n        const searchQuery = this.buildSearchQuery(query, timeRange);\n        subQueries.push(\n          this._request('/api/search', searchQuery).pipe(\n            map((response) => {\n              return {\n                data: [createTableFrameFromSearch(response.data.traces, this.instanceSettings)],\n              };\n            }),\n            catchError((error) => {\n              return of({ error: { message: error.data.message }, data: [] });\n            })\n          )\n        );\n      } catch (error) {\n        return of({ error: { message: error instanceof Error ? error.message : 'Unknown error occurred' }, data: [] });\n      }\n    }\n\n    if (targets.upload?.length) {\n      if (this.uploadedJson) {\n        const jsonData = JSON.parse(this.uploadedJson as string);\n        const isTraceData = jsonData.batches;\n        const isServiceGraphData =\n          Array.isArray(jsonData) && jsonData.some((df) => df?.meta?.preferredVisualisationType === 'nodeGraph');\n\n        if (isTraceData) {\n          subQueries.push(of(transformFromOTEL(jsonData.batches, this.nodeGraph?.enabled)));\n        } else if (isServiceGraphData) {\n          subQueries.push(of({ data: jsonData, state: LoadingState.Done }));\n        } else {\n          subQueries.push(of({ error: { message: 'Unable to parse uploaded data.' }, data: [] }));\n        }\n      } else {\n        subQueries.push(of({ data: [], state: LoadingState.Done }));\n      }\n    }\n\n    if (this.serviceMap?.datasourceUid && targets.serviceMap?.length > 0) {\n      const dsId = this.serviceMap.datasourceUid;\n      if (config.featureToggles.tempoApmTable) {\n        subQueries.push(\n          serviceMapQuery(options, dsId, this.name).pipe(\n            concatMap((result) =>\n              rateQuery(options, result, dsId).pipe(\n                concatMap((result) => errorAndDurationQuery(options, result, dsId, this.name))\n              )\n            )\n          )\n        );\n      } else {\n        subQueries.push(serviceMapQuery(options, dsId, this.name));\n      }\n    }\n\n    if (targets.traceId?.length > 0) {\n      reportInteraction('grafana_traces_traceID_queried', {\n        datasourceType: 'tempo',\n        app: options.app ?? '',\n        query: targets.traceId[0].query ?? '',\n      });\n\n      subQueries.push(this.handleTraceIdQuery(options, targets.traceId));\n    }\n\n    return merge(...subQueries);\n  }\n\n  applyTemplateVariables(query: TempoQuery, scopedVars: ScopedVars): Record<string, any> {\n    return this.applyVariables(query, scopedVars);\n  }\n\n  interpolateVariablesInQueries(queries: TempoQuery[], scopedVars: ScopedVars): TempoQuery[] {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    return queries.map((query) => {\n      return {\n        ...query,\n        datasource: this.getRef(),\n        ...this.applyVariables(query, scopedVars),\n      };\n    });\n  }\n\n  applyVariables(query: TempoQuery, scopedVars: ScopedVars) {\n    const expandedQuery = { ...query };\n\n    if (query.linkedQuery) {\n      expandedQuery.linkedQuery = {\n        ...query.linkedQuery,\n        expr: this.templateSrv.replace(query.linkedQuery?.expr ?? '', scopedVars),\n      };\n    }\n\n    return {\n      ...expandedQuery,\n      query: this.templateSrv.replace(query.query ?? '', scopedVars),\n      search: this.templateSrv.replace(query.search ?? '', scopedVars),\n      minDuration: this.templateSrv.replace(query.minDuration ?? '', scopedVars),\n      maxDuration: this.templateSrv.replace(query.maxDuration ?? '', scopedVars),\n    };\n  }\n\n  /**\n   * Handles the simplest of the queries where we have just a trace id and return trace data for it.\n   * @param options\n   * @param targets\n   * @private\n   */\n  private handleTraceIdQuery(\n    options: DataQueryRequest<TempoQuery>,\n    targets: TempoQuery[]\n  ): Observable<DataQueryResponse> {\n    const validTargets = targets.filter((t) => t.query).map((t) => ({ ...t, query: t.query.trim() }));\n    if (!validTargets.length) {\n      return EMPTY;\n    }\n\n    const traceRequest: DataQueryRequest<TempoQuery> = { ...options, targets: validTargets };\n    return super.query(traceRequest).pipe(\n      map((response) => {\n        if (response.error) {\n          return response;\n        }\n        return transformTrace(response, this.nodeGraph?.enabled);\n      })\n    );\n  }\n\n  async metadataRequest(url: string, params = {}) {\n    return await this._request(url, params, { method: 'GET', hideFromInspector: true }).toPromise();\n  }\n\n  private _request(apiUrl: string, data?: any, options?: Partial<BackendSrvRequest>): Observable<Record<string, any>> {\n    const params = data ? serializeParams(data) : '';\n    const url = `${this.instanceSettings.url}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = { ...options, url };\n\n    return getBackendSrv().fetch(req);\n  }\n\n  async testDatasource(): Promise<any> {\n    const options: BackendSrvRequest = {\n      headers: {},\n      method: 'GET',\n      url: `${this.instanceSettings.url}/api/echo`,\n    };\n    const response = await getBackendSrv().fetch<any>(options).toPromise();\n\n    if (response?.ok) {\n      return { status: 'success', message: 'Data source is working' };\n    }\n  }\n\n  getQueryDisplayText(query: TempoQuery) {\n    if (query.queryType === 'nativeSearch') {\n      let result = [];\n      for (const key of ['serviceName', 'spanName', 'search', 'minDuration', 'maxDuration', 'limit']) {\n        if (query.hasOwnProperty(key) && query[key as keyof TempoQuery]) {\n          result.push(`${startCase(key)}: ${query[key as keyof TempoQuery]}`);\n        }\n      }\n      return result.join(', ');\n    }\n    return query.query;\n  }\n\n  buildSearchQuery(query: TempoQuery, timeRange?: { startTime: number; endTime?: number }): SearchQueryParams {\n    let tags = query.search ?? '';\n\n    let tempoQuery = pick(query, ['minDuration', 'maxDuration', 'limit']);\n    // Remove empty properties\n    tempoQuery = pickBy(tempoQuery, identity);\n\n    if (query.serviceName) {\n      tags += ` service.name=\"${query.serviceName}\"`;\n    }\n    if (query.spanName) {\n      tags += ` name=\"${query.spanName}\"`;\n    }\n\n    // Set default limit\n    if (!tempoQuery.limit) {\n      tempoQuery.limit = DEFAULT_LIMIT;\n    }\n\n    // Validate query inputs and remove spaces if valid\n    if (tempoQuery.minDuration) {\n      tempoQuery.minDuration = this.templateSrv.replace(tempoQuery.minDuration ?? '');\n      if (!isValidGoDuration(tempoQuery.minDuration)) {\n        throw new Error('Please enter a valid min duration.');\n      }\n      tempoQuery.minDuration = tempoQuery.minDuration.replace(/\\s/g, '');\n    }\n    if (tempoQuery.maxDuration) {\n      tempoQuery.maxDuration = this.templateSrv.replace(tempoQuery.maxDuration ?? '');\n      if (!isValidGoDuration(tempoQuery.maxDuration)) {\n        throw new Error('Please enter a valid max duration.');\n      }\n      tempoQuery.maxDuration = tempoQuery.maxDuration.replace(/\\s/g, '');\n    }\n\n    if (!Number.isInteger(tempoQuery.limit) || tempoQuery.limit <= 0) {\n      throw new Error('Please enter a valid limit.');\n    }\n\n    let searchQuery: SearchQueryParams = { tags, ...tempoQuery };\n\n    if (timeRange) {\n      searchQuery.start = timeRange.startTime;\n      searchQuery.end = timeRange.endTime;\n    }\n\n    return searchQuery;\n  }\n\n  async getServiceGraphLabels() {\n    const ds = await getDatasourceSrv().get(this.serviceMap!.datasourceUid);\n    return ds.getTagKeys!();\n  }\n\n  async getServiceGraphLabelValues(key: string) {\n    const ds = await getDatasourceSrv().get(this.serviceMap!.datasourceUid);\n    return ds.getTagValues!({ key });\n  }\n\n  // Get linked loki search datasource. Fall back to legacy loki search/trace to logs config\n  getLokiSearchDS = (): string | undefined => {\n    const legacyLogsDatasourceUid =\n      this.tracesToLogs?.lokiSearch !== false && this.lokiSearch === undefined\n        ? this.tracesToLogs?.datasourceUid\n        : undefined;\n    return this.lokiSearch?.datasourceUid ?? legacyLogsDatasourceUid;\n  };\n}\n\nfunction queryPrometheus(request: DataQueryRequest<PromQuery>, datasourceUid: string) {\n  return from(getDatasourceSrv().get(datasourceUid)).pipe(\n    mergeMap((ds) => {\n      return (ds as PrometheusDatasource).query(request);\n    })\n  );\n}\n\nfunction serviceMapQuery(request: DataQueryRequest<TempoQuery>, datasourceUid: string, tempoDatasourceUid: string) {\n  const serviceMapRequest = makePromServiceMapRequest(request);\n\n  return queryPrometheus(serviceMapRequest, datasourceUid).pipe(\n    // Just collect all the responses first before processing into node graph data\n    toArray(),\n    map((responses: DataQueryResponse[]) => {\n      const errorRes = responses.find((res) => !!res.error);\n      if (errorRes) {\n        throw new Error(errorRes.error!.message);\n      }\n\n      const { nodes, edges } = mapPromMetricsToServiceMap(responses, request.range);\n      nodes.fields[0].config = {\n        links: [\n          makePromLink(\n            'Request rate',\n            `sum by (client, server)(rate(${totalsMetric}{server=\"\\${__data.fields.id}\"}[$__rate_interval]))`,\n            datasourceUid,\n            false\n          ),\n          makePromLink(\n            'Request histogram',\n            `histogram_quantile(0.9, sum(rate(${histogramMetric}{server=\"\\${__data.fields.id}\"}[$__rate_interval])) by (le, client, server))`,\n            datasourceUid,\n            false\n          ),\n          makePromLink(\n            'Failed request rate',\n            `sum by (client, server)(rate(${failedMetric}{server=\"\\${__data.fields.id}\"}[$__rate_interval]))`,\n            datasourceUid,\n            false\n          ),\n          makeTempoLink('View traces', `\\${__data.fields[0]}`, '', tempoDatasourceUid),\n        ],\n      };\n\n      return {\n        data: [nodes, edges],\n        state: LoadingState.Done,\n      };\n    })\n  );\n}\n\nfunction rateQuery(\n  request: DataQueryRequest<TempoQuery>,\n  serviceMapResponse: DataQueryResponse,\n  datasourceUid: string\n) {\n  const serviceMapRequest = makePromServiceMapRequest(request);\n  serviceMapRequest.targets = makeApmRequest([buildExpr(rateMetric, '', request)]);\n\n  return queryPrometheus(serviceMapRequest, datasourceUid).pipe(\n    toArray(),\n    map((responses: DataQueryResponse[]) => {\n      const errorRes = responses.find((res) => !!res.error);\n      if (errorRes) {\n        throw new Error(errorRes.error!.message);\n      }\n      return {\n        data: [responses[0]?.data ?? [], serviceMapResponse.data[0], serviceMapResponse.data[1]],\n        state: LoadingState.Done,\n      };\n    })\n  );\n}\n\n// we need the response from the rate query to get the rate span_name(s),\n// -> which determine the errorRate/duration span_name(s) we need to query\nfunction errorAndDurationQuery(\n  request: DataQueryRequest<TempoQuery>,\n  rateResponse: DataQueryResponse,\n  datasourceUid: string,\n  tempoDatasourceUid: string\n) {\n  let apmMetrics = [];\n  let errorRateBySpanName = '';\n  let durationsBySpanName: string[] = [];\n  const spanNames = rateResponse.data[0][0]?.fields[1]?.values.toArray() ?? [];\n\n  if (spanNames.length > 0) {\n    errorRateBySpanName = buildExpr(errorRateMetric, 'span_name=~\"' + spanNames.join('|') + '\"', request);\n    apmMetrics.push(errorRateBySpanName);\n    spanNames.map((name: string) => {\n      const metric = buildExpr(durationMetric, 'span_name=~\"' + name + '\"', request);\n      durationsBySpanName.push(metric);\n      apmMetrics.push(metric);\n    });\n  }\n\n  const serviceMapRequest = makePromServiceMapRequest(request);\n  serviceMapRequest.targets = makeApmRequest(apmMetrics);\n\n  return queryPrometheus(serviceMapRequest, datasourceUid).pipe(\n    // Just collect all the responses first before processing into node graph data\n    toArray(),\n    map((errorAndDurationResponse: DataQueryResponse[]) => {\n      const errorRes = errorAndDurationResponse.find((res) => !!res.error);\n      if (errorRes) {\n        throw new Error(errorRes.error!.message);\n      }\n\n      const apmTable = getApmTable(\n        request,\n        rateResponse,\n        errorAndDurationResponse[0],\n        errorRateBySpanName,\n        durationsBySpanName,\n        datasourceUid,\n        tempoDatasourceUid\n      );\n\n      if (apmTable.fields.length === 0) {\n        return {\n          data: [rateResponse.data[1], rateResponse.data[2]],\n          state: LoadingState.Done,\n        };\n      }\n\n      return {\n        data: [apmTable, rateResponse.data[1], rateResponse.data[2]],\n        state: LoadingState.Done,\n      };\n    })\n  );\n}\n\nfunction makePromLink(title: string, expr: string, datasourceUid: string, instant: boolean) {\n  return {\n    url: '',\n    title,\n    internal: {\n      query: {\n        expr: expr,\n        range: !instant,\n        exemplar: !instant,\n        instant: instant,\n      } as PromQuery,\n      datasourceUid,\n      datasourceName: 'Prometheus',\n    },\n  };\n}\n\nexport function makeTempoLink(title: string, serviceName: string, spanName: string, datasourceUid: string) {\n  let query = { queryType: 'nativeSearch' } as TempoQuery;\n  if (serviceName !== '') {\n    query.serviceName = serviceName;\n  }\n  if (spanName !== '') {\n    query.spanName = spanName;\n  }\n\n  return {\n    url: '',\n    title,\n    internal: {\n      query,\n      datasourceUid: datasourceUid,\n      datasourceName: 'Tempo',\n    },\n  };\n}\n\nfunction makePromServiceMapRequest(options: DataQueryRequest<TempoQuery>): DataQueryRequest<PromQuery> {\n  return {\n    ...options,\n    targets: serviceMapMetrics.map((metric) => {\n      return {\n        refId: metric,\n        // options.targets[0] is not correct here, but not sure what should happen if you have multiple queries for\n        // service map at the same time anyway\n        expr: `rate(${metric}${options.targets[0].serviceMapQuery || ''}[$__range])`,\n        instant: true,\n      };\n    }),\n  };\n}\n\nfunction getApmTable(\n  request: DataQueryRequest<TempoQuery>,\n  rateResponse: DataQueryResponse,\n  secondResponse: DataQueryResponse,\n  errorRateBySpanName: string,\n  durationsBySpanName: string[],\n  datasourceUid: string,\n  tempoDatasourceUid: string\n) {\n  let df: any = { fields: [] };\n  const rate = rateResponse.data[0]?.filter((x: { refId: string }) => {\n    return x.refId === buildExpr(rateMetric, '', request);\n  });\n  const errorRate = secondResponse.data.filter((x) => {\n    return x.refId === errorRateBySpanName;\n  });\n  const duration = secondResponse.data.filter((x) => {\n    return durationsBySpanName.includes(x.refId);\n  });\n\n  if (rate.length > 0 && rate[0].fields?.length > 2) {\n    df.fields.push({\n      ...rate[0].fields[1],\n      name: 'Name',\n      config: {\n        filterable: false,\n      },\n    });\n\n    df.fields.push({\n      ...rate[0].fields[2],\n      name: 'Rate',\n      config: {\n        links: [\n          makePromLink(\n            'Rate',\n            buildLinkExpr(buildExpr(rateMetric, 'span_name=\"${__data.fields[0]}\"', request)),\n            datasourceUid,\n            false\n          ),\n        ],\n        decimals: 2,\n      },\n    });\n\n    df.fields.push({\n      ...rate[0].fields[2],\n      name: ' ',\n      labels: null,\n      config: {\n        color: {\n          mode: 'continuous-BlPu',\n        },\n        custom: {\n          displayMode: 'lcd-gauge',\n        },\n        decimals: 3,\n      },\n    });\n  }\n\n  if (errorRate.length > 0 && errorRate[0].fields?.length > 2) {\n    const errorRateNames = errorRate[0].fields[1]?.values.toArray() ?? [];\n    const errorRateValues = errorRate[0].fields[2]?.values.toArray() ?? [];\n    let errorRateObj: any = {};\n    errorRateNames.map((name: string, index: number) => {\n      errorRateObj[name] = { name: name, value: errorRateValues[index] };\n    });\n\n    const values = getRateAlignedValues(rate, errorRateObj);\n\n    df.fields.push({\n      ...errorRate[0].fields[2],\n      name: 'Error Rate',\n      values: values,\n      config: {\n        links: [\n          makePromLink(\n            'Error Rate',\n            buildLinkExpr(buildExpr(errorRateMetric, 'span_name=\"${__data.fields[0]}\"', request)),\n            datasourceUid,\n            false\n          ),\n        ],\n        decimals: 2,\n      },\n    });\n\n    df.fields.push({\n      ...errorRate[0].fields[2],\n      name: '  ',\n      values: values,\n      labels: null,\n      config: {\n        color: {\n          mode: 'continuous-RdYlGr',\n        },\n        custom: {\n          displayMode: 'lcd-gauge',\n        },\n        decimals: 3,\n      },\n    });\n  }\n\n  if (duration.length > 0 && duration[0].fields?.length > 1) {\n    let durationObj: any = {};\n    duration.map((d) => {\n      const delimiter = d.refId?.includes('span_name=~\"') ? 'span_name=~\"' : 'span_name=\"';\n      const name = d.refId?.split(delimiter)[1].split('\"}')[0];\n      durationObj[name] = { name: name, value: d.fields[1].values.toArray()[0] };\n    });\n\n    df.fields.push({\n      ...duration[0].fields[1],\n      name: 'Duration (p90)',\n      values: getRateAlignedValues(rate, durationObj),\n      config: {\n        links: [\n          makePromLink(\n            'Duration',\n            buildLinkExpr(buildExpr(durationMetric, 'span_name=\"${__data.fields[0]}\"', request)),\n            datasourceUid,\n            false\n          ),\n        ],\n        unit: 's',\n      },\n    });\n  }\n\n  if (df.fields.length > 0 && df.fields[0].values) {\n    df.fields.push({\n      name: 'Links',\n      type: FieldType.string,\n      values: df.fields[0].values.map(() => {\n        return 'Tempo';\n      }),\n      config: {\n        links: [makeTempoLink('Tempo', '', `\\${__data.fields[0]}`, tempoDatasourceUid)],\n      },\n    });\n  }\n\n  return df;\n}\n\nexport function buildExpr(\n  metric: { expr: string; params: string[] },\n  extraParams: string,\n  request: DataQueryRequest<TempoQuery>\n) {\n  let serviceMapQuery = request.targets[0]?.serviceMapQuery?.replace('{', '').replace('}', '') ?? '';\n  // map serviceGraph metric tags to APM metric tags\n  serviceMapQuery = serviceMapQuery.replace('client', 'service').replace('server', 'service');\n  const metricParams = serviceMapQuery.includes('span_name')\n    ? metric.params.concat(serviceMapQuery)\n    : metric.params\n        .concat(serviceMapQuery)\n        .concat(extraParams)\n        .filter((item: string) => item);\n  return metric.expr.replace('{}', '{' + metricParams.join(',') + '}');\n}\n\nexport function buildLinkExpr(expr: string) {\n  // don't want top 5 or by span name in links\n  expr = expr.replace('topk(5, ', '').replace(' by (span_name))', '');\n  return expr.replace('__range', '__rate_interval');\n}\n\n// query result frames can come back in any order\n// here we align the table col values to the same row name (rateName) across the table\nexport function getRateAlignedValues(\n  rateResp: DataQueryResponseData[],\n  objToAlign: { [x: string]: { value: string } }\n) {\n  const rateNames = rateResp[0]?.fields[1]?.values.toArray().sort() ?? [];\n  let tempRateNames = rateNames;\n  let values: string[] = [];\n\n  objToAlign = Object.keys(objToAlign)\n    .sort()\n    .reduce((obj: any, key) => {\n      obj[key] = objToAlign[key];\n      return obj;\n    }, {});\n\n  for (let i = 0; i < rateNames.length; i++) {\n    if (tempRateNames[i]) {\n      if (tempRateNames[i] === Object.keys(objToAlign)[i]) {\n        values.push(objToAlign[Object.keys(objToAlign)[i]].value);\n      } else {\n        i--;\n        tempRateNames = tempRateNames.slice(1);\n        values.push('0');\n      }\n    }\n  }\n\n  return values;\n}\n\nexport function makeApmRequest(metrics: any[]) {\n  return metrics.map((metric) => {\n    return {\n      refId: metric,\n      expr: metric,\n      instant: true,\n    };\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}