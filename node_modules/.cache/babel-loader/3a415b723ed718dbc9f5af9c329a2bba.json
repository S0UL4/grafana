{"ast":null,"code":"import { DataFrameType, FieldType, formattedValueToString, getDisplayProcessor, outerJoinDataFrames } from '@grafana/data';\nimport { calculateHeatmapFromData, isHeatmapCellsDense, readHeatmapRowsCustomMeta, rowsToCellsHeatmap } from 'app/features/transformers/calculateHeatmap/heatmap';\nimport { HeatmapCellLayout } from 'app/features/transformers/calculateHeatmap/models.gen';\nimport { boundedMinMax } from './utils';\nexport function prepareHeatmapData(data, options, theme) {\n  var _data$annotations, _frame$meta, _options$yAxis, _options$yAxis2;\n\n  let frames = data.series;\n\n  if (!(frames !== null && frames !== void 0 && frames.length)) {\n    return {};\n  }\n\n  const exemplars = (_data$annotations = data.annotations) === null || _data$annotations === void 0 ? void 0 : _data$annotations.find(f => f.name === 'exemplar');\n\n  if (options.calculate) {\n    var _options$calculation;\n\n    return getDenseHeatmapData(calculateHeatmapFromData(frames, (_options$calculation = options.calculation) !== null && _options$calculation !== void 0 ? _options$calculation : {}), exemplars, options, theme);\n  } // Check for known heatmap types\n\n\n  let rowsHeatmap = undefined;\n\n  for (const frame of frames) {\n    switch ((_frame$meta = frame.meta) === null || _frame$meta === void 0 ? void 0 : _frame$meta.type) {\n      case DataFrameType.HeatmapCells:\n        return isHeatmapCellsDense(frame) ? getDenseHeatmapData(frame, exemplars, options, theme) : getSparseHeatmapData(frame, exemplars, options, theme);\n\n      case DataFrameType.HeatmapRows:\n        rowsHeatmap = frame;\n      // the default format\n    }\n  } // Everything past here assumes a field for each row in the heatmap (buckets)\n\n\n  if (!rowsHeatmap) {\n    if (frames.length > 1) {\n      rowsHeatmap = [outerJoinDataFrames({\n        frames\n      })][0];\n    } else {\n      rowsHeatmap = frames[0];\n    }\n  }\n\n  return getDenseHeatmapData(rowsToCellsHeatmap(Object.assign({\n    unit: (_options$yAxis = options.yAxis) === null || _options$yAxis === void 0 ? void 0 : _options$yAxis.unit,\n    // used to format the ordinal lookup values\n    decimals: (_options$yAxis2 = options.yAxis) === null || _options$yAxis2 === void 0 ? void 0 : _options$yAxis2.decimals\n  }, options.rowsFrame, {\n    frame: rowsHeatmap\n  })), exemplars, options, theme);\n}\n\nconst getSparseHeatmapData = (frame, exemplars, options, theme) => {\n  var _frame$meta2, _options$filterValues, _options$filterValues2;\n\n  if (((_frame$meta2 = frame.meta) === null || _frame$meta2 === void 0 ? void 0 : _frame$meta2.type) !== DataFrameType.HeatmapCells || isHeatmapCellsDense(frame)) {\n    return {\n      warning: 'Expected sparse heatmap format',\n      heatmap: frame\n    };\n  } // y axis tick label display\n\n\n  updateFieldDisplay(frame.fields[1], options.yAxis, theme); // cell value display\n\n  const disp = updateFieldDisplay(frame.fields[3], options.cellValues, theme);\n  let [minValue, maxValue] = boundedMinMax(frame.fields[3].values.toArray(), options.color.min, options.color.max, (_options$filterValues = options.filterValues) === null || _options$filterValues === void 0 ? void 0 : _options$filterValues.le, (_options$filterValues2 = options.filterValues) === null || _options$filterValues2 === void 0 ? void 0 : _options$filterValues2.ge);\n  return {\n    heatmap: frame,\n    minValue,\n    maxValue,\n    exemplars,\n    display: v => formattedValueToString(disp(v))\n  };\n};\n\nconst getDenseHeatmapData = (frame, exemplars, options, theme) => {\n  var _frame$meta3, _options$filterValues3, _options$filterValues4;\n\n  if (((_frame$meta3 = frame.meta) === null || _frame$meta3 === void 0 ? void 0 : _frame$meta3.type) !== DataFrameType.HeatmapCells) {\n    return {\n      warning: 'Expected heatmap scanlines format',\n      heatmap: frame\n    };\n  }\n\n  if (frame.fields.length < 2 || frame.length < 2) {\n    return {\n      heatmap: frame\n    };\n  }\n\n  const meta = readHeatmapRowsCustomMeta(frame);\n  let xName = undefined;\n  let yName = undefined;\n  let valueField = undefined; // validate field display properties\n\n  for (const field of frame.fields) {\n    switch (field.name) {\n      case 'y':\n        yName = field.name;\n\n      case 'yMin':\n      case 'yMax':\n        {\n          if (!yName) {\n            yName = field.name;\n          }\n\n          if (meta.yOrdinalDisplay == null) {\n            updateFieldDisplay(field, options.yAxis, theme);\n          }\n\n          break;\n        }\n\n      case 'x':\n      case 'xMin':\n      case 'xMax':\n        xName = field.name;\n        break;\n\n      default:\n        {\n          if (field.type === FieldType.number && !valueField) {\n            valueField = field;\n          }\n        }\n    }\n  }\n\n  if (!yName) {\n    return {\n      warning: 'Missing Y field',\n      heatmap: frame\n    };\n  }\n\n  if (!yName) {\n    return {\n      warning: 'Missing X field',\n      heatmap: frame\n    };\n  }\n\n  if (!valueField) {\n    return {\n      warning: 'Missing value field',\n      heatmap: frame\n    };\n  }\n\n  const disp = updateFieldDisplay(valueField, options.cellValues, theme); // infer bucket sizes from data (for now)\n  // the 'heatmap-scanlines' dense frame format looks like:\n  // x:      1,1,1,1,2,2,2,2\n  // y:      3,4,5,6,3,4,5,6\n  // count:  0,0,0,7,0,3,0,1\n\n  const xs = frame.fields[0].values.toArray();\n  const ys = frame.fields[1].values.toArray();\n  const dlen = xs.length; // below is literally copy/paste from the pathBuilder code in utils.ts\n  // detect x and y bin qtys by detecting layout repetition in x & y data\n\n  let yBinQty = dlen - ys.lastIndexOf(ys[0]);\n  let xBinQty = dlen / yBinQty;\n  let yBinIncr = ys[1] - ys[0];\n  let xBinIncr = xs[yBinQty] - xs[0];\n  let [minValue, maxValue] = boundedMinMax(valueField.values.toArray(), options.color.min, options.color.max, (_options$filterValues3 = options.filterValues) === null || _options$filterValues3 === void 0 ? void 0 : _options$filterValues3.le, (_options$filterValues4 = options.filterValues) === null || _options$filterValues4 === void 0 ? void 0 : _options$filterValues4.ge);\n  const data = {\n    heatmap: frame,\n    exemplars: exemplars !== null && exemplars !== void 0 && exemplars.length ? exemplars : undefined,\n    xBucketSize: xBinIncr,\n    yBucketSize: yBinIncr,\n    xBucketCount: xBinQty,\n    yBucketCount: yBinQty,\n    minValue,\n    maxValue,\n    // TODO: improve heuristic\n    xLayout: xName === 'xMax' ? HeatmapCellLayout.le : xName === 'xMin' ? HeatmapCellLayout.ge : HeatmapCellLayout.unknown,\n    yLayout: yName === 'yMax' ? HeatmapCellLayout.le : yName === 'yMin' ? HeatmapCellLayout.ge : HeatmapCellLayout.unknown,\n    display: v => formattedValueToString(disp(v))\n  };\n  return data;\n};\n\nfunction updateFieldDisplay(field, opts, theme) {\n  var _opts$unit;\n\n  if (opts !== null && opts !== void 0 && (_opts$unit = opts.unit) !== null && _opts$unit !== void 0 && _opts$unit.length || (opts === null || opts === void 0 ? void 0 : opts.decimals) != null) {\n    const {\n      unit,\n      decimals\n    } = opts;\n    field.display = undefined;\n    field.config = Object.assign({}, field.config);\n\n    if (unit !== null && unit !== void 0 && unit.length) {\n      field.config.unit = unit;\n    }\n\n    if (decimals != null) {\n      field.config.decimals = decimals;\n    }\n  }\n\n  if (!field.display) {\n    field.display = getDisplayProcessor({\n      field,\n      theme\n    });\n  }\n\n  return field.display;\n}","map":{"version":3,"names":["DataFrameType","FieldType","formattedValueToString","getDisplayProcessor","outerJoinDataFrames","calculateHeatmapFromData","isHeatmapCellsDense","readHeatmapRowsCustomMeta","rowsToCellsHeatmap","HeatmapCellLayout","boundedMinMax","prepareHeatmapData","data","options","theme","frames","series","length","exemplars","annotations","find","f","name","calculate","getDenseHeatmapData","calculation","rowsHeatmap","undefined","frame","meta","type","HeatmapCells","getSparseHeatmapData","HeatmapRows","unit","yAxis","decimals","rowsFrame","warning","heatmap","updateFieldDisplay","fields","disp","cellValues","minValue","maxValue","values","toArray","color","min","max","filterValues","le","ge","display","v","xName","yName","valueField","field","yOrdinalDisplay","number","xs","ys","dlen","yBinQty","lastIndexOf","xBinQty","yBinIncr","xBinIncr","xBucketSize","yBucketSize","xBucketCount","yBucketCount","xLayout","unknown","yLayout","opts","config"],"sources":["/home/soula/grafana/public/app/plugins/panel/heatmap/fields.ts"],"sourcesContent":["import {\n  DataFrame,\n  DataFrameType,\n  Field,\n  FieldType,\n  formattedValueToString,\n  getDisplayProcessor,\n  GrafanaTheme2,\n  outerJoinDataFrames,\n  PanelData,\n  ValueFormatter,\n} from '@grafana/data';\nimport {\n  calculateHeatmapFromData,\n  isHeatmapCellsDense,\n  readHeatmapRowsCustomMeta,\n  rowsToCellsHeatmap,\n} from 'app/features/transformers/calculateHeatmap/heatmap';\nimport { HeatmapCellLayout } from 'app/features/transformers/calculateHeatmap/models.gen';\n\nimport { CellValues, PanelOptions } from './models.gen';\nimport { boundedMinMax } from './utils';\n\nexport interface HeatmapData {\n  heatmap?: DataFrame; // data we will render\n  exemplars?: DataFrame; // optionally linked exemplars\n  exemplarColor?: string;\n\n  xBucketSize?: number;\n  yBucketSize?: number;\n\n  xBucketCount?: number;\n  yBucketCount?: number;\n\n  xLayout?: HeatmapCellLayout;\n  yLayout?: HeatmapCellLayout;\n\n  // color scale range\n  minValue?: number;\n  maxValue?: number;\n\n  // Print a heatmap cell value\n  display?: (v: number) => string;\n\n  // Errors\n  warning?: string;\n}\n\nexport function prepareHeatmapData(data: PanelData, options: PanelOptions, theme: GrafanaTheme2): HeatmapData {\n  let frames = data.series;\n  if (!frames?.length) {\n    return {};\n  }\n\n  const exemplars = data.annotations?.find((f) => f.name === 'exemplar');\n\n  if (options.calculate) {\n    return getDenseHeatmapData(calculateHeatmapFromData(frames, options.calculation ?? {}), exemplars, options, theme);\n  }\n\n  // Check for known heatmap types\n  let rowsHeatmap: DataFrame | undefined = undefined;\n  for (const frame of frames) {\n    switch (frame.meta?.type) {\n      case DataFrameType.HeatmapCells:\n        return isHeatmapCellsDense(frame)\n          ? getDenseHeatmapData(frame, exemplars, options, theme)\n          : getSparseHeatmapData(frame, exemplars, options, theme);\n\n      case DataFrameType.HeatmapRows:\n        rowsHeatmap = frame; // the default format\n    }\n  }\n\n  // Everything past here assumes a field for each row in the heatmap (buckets)\n  if (!rowsHeatmap) {\n    if (frames.length > 1) {\n      rowsHeatmap = [\n        outerJoinDataFrames({\n          frames,\n        })!,\n      ][0];\n    } else {\n      rowsHeatmap = frames[0];\n    }\n  }\n\n  return getDenseHeatmapData(\n    rowsToCellsHeatmap({\n      unit: options.yAxis?.unit, // used to format the ordinal lookup values\n      decimals: options.yAxis?.decimals,\n      ...options.rowsFrame,\n      frame: rowsHeatmap,\n    }),\n    exemplars,\n    options,\n    theme\n  );\n}\n\nconst getSparseHeatmapData = (\n  frame: DataFrame,\n  exemplars: DataFrame | undefined,\n  options: PanelOptions,\n  theme: GrafanaTheme2\n): HeatmapData => {\n  if (frame.meta?.type !== DataFrameType.HeatmapCells || isHeatmapCellsDense(frame)) {\n    return {\n      warning: 'Expected sparse heatmap format',\n      heatmap: frame,\n    };\n  }\n\n  // y axis tick label display\n  updateFieldDisplay(frame.fields[1], options.yAxis, theme);\n\n  // cell value display\n  const disp = updateFieldDisplay(frame.fields[3], options.cellValues, theme);\n\n  let [minValue, maxValue] = boundedMinMax(\n    frame.fields[3].values.toArray(),\n    options.color.min,\n    options.color.max,\n    options.filterValues?.le,\n    options.filterValues?.ge\n  );\n\n  return {\n    heatmap: frame,\n    minValue,\n    maxValue,\n    exemplars,\n    display: (v) => formattedValueToString(disp(v)),\n  };\n};\n\nconst getDenseHeatmapData = (\n  frame: DataFrame,\n  exemplars: DataFrame | undefined,\n  options: PanelOptions,\n  theme: GrafanaTheme2\n): HeatmapData => {\n  if (frame.meta?.type !== DataFrameType.HeatmapCells) {\n    return {\n      warning: 'Expected heatmap scanlines format',\n      heatmap: frame,\n    };\n  }\n\n  if (frame.fields.length < 2 || frame.length < 2) {\n    return { heatmap: frame };\n  }\n\n  const meta = readHeatmapRowsCustomMeta(frame);\n  let xName: string | undefined = undefined;\n  let yName: string | undefined = undefined;\n  let valueField: Field | undefined = undefined;\n\n  // validate field display properties\n  for (const field of frame.fields) {\n    switch (field.name) {\n      case 'y':\n        yName = field.name;\n\n      case 'yMin':\n      case 'yMax': {\n        if (!yName) {\n          yName = field.name;\n        }\n        if (meta.yOrdinalDisplay == null) {\n          updateFieldDisplay(field, options.yAxis, theme);\n        }\n        break;\n      }\n\n      case 'x':\n      case 'xMin':\n      case 'xMax':\n        xName = field.name;\n        break;\n\n      default: {\n        if (field.type === FieldType.number && !valueField) {\n          valueField = field;\n        }\n      }\n    }\n  }\n\n  if (!yName) {\n    return { warning: 'Missing Y field', heatmap: frame };\n  }\n  if (!yName) {\n    return { warning: 'Missing X field', heatmap: frame };\n  }\n  if (!valueField) {\n    return { warning: 'Missing value field', heatmap: frame };\n  }\n\n  const disp = updateFieldDisplay(valueField, options.cellValues, theme);\n\n  // infer bucket sizes from data (for now)\n  // the 'heatmap-scanlines' dense frame format looks like:\n  // x:      1,1,1,1,2,2,2,2\n  // y:      3,4,5,6,3,4,5,6\n  // count:  0,0,0,7,0,3,0,1\n\n  const xs = frame.fields[0].values.toArray();\n  const ys = frame.fields[1].values.toArray();\n  const dlen = xs.length;\n\n  // below is literally copy/paste from the pathBuilder code in utils.ts\n  // detect x and y bin qtys by detecting layout repetition in x & y data\n  let yBinQty = dlen - ys.lastIndexOf(ys[0]);\n  let xBinQty = dlen / yBinQty;\n  let yBinIncr = ys[1] - ys[0];\n  let xBinIncr = xs[yBinQty] - xs[0];\n\n  let [minValue, maxValue] = boundedMinMax(\n    valueField.values.toArray(),\n    options.color.min,\n    options.color.max,\n    options.filterValues?.le,\n    options.filterValues?.ge\n  );\n\n  const data: HeatmapData = {\n    heatmap: frame,\n    exemplars: exemplars?.length ? exemplars : undefined,\n    xBucketSize: xBinIncr,\n    yBucketSize: yBinIncr,\n    xBucketCount: xBinQty,\n    yBucketCount: yBinQty,\n\n    minValue,\n    maxValue,\n\n    // TODO: improve heuristic\n    xLayout:\n      xName === 'xMax' ? HeatmapCellLayout.le : xName === 'xMin' ? HeatmapCellLayout.ge : HeatmapCellLayout.unknown,\n    yLayout:\n      yName === 'yMax' ? HeatmapCellLayout.le : yName === 'yMin' ? HeatmapCellLayout.ge : HeatmapCellLayout.unknown,\n\n    display: (v) => formattedValueToString(disp(v)),\n  };\n\n  return data;\n};\n\nfunction updateFieldDisplay(field: Field, opts: CellValues | undefined, theme: GrafanaTheme2): ValueFormatter {\n  if (opts?.unit?.length || opts?.decimals != null) {\n    const { unit, decimals } = opts;\n    field.display = undefined;\n    field.config = { ...field.config };\n    if (unit?.length) {\n      field.config.unit = unit;\n    }\n    if (decimals != null) {\n      field.config.decimals = decimals;\n    }\n  }\n  if (!field.display) {\n    field.display = getDisplayProcessor({ field, theme });\n  }\n  return field.display;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}