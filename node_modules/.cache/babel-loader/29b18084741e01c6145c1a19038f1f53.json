{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { guessFieldTypeForField } from '../../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { FieldType } from '../../types/dataFrame';\nimport { ArrayVector } from '../../vector/ArrayVector';\nimport { reduceField, ReducerID } from '../fieldReducer';\nimport { DataTransformerID } from './ids';\nexport let GroupByOperationID;\n\n(function (GroupByOperationID) {\n  GroupByOperationID[\"aggregate\"] = \"aggregate\";\n  GroupByOperationID[\"groupBy\"] = \"groupby\";\n})(GroupByOperationID || (GroupByOperationID = {}));\n\nexport const groupByTransformer = {\n  id: DataTransformerID.groupBy,\n  name: 'Group by',\n  description: 'Group the data by a field values then process calculations for each group',\n  defaultOptions: {\n    fields: {}\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: options => source => source.pipe(map(data => {\n    const hasValidConfig = Object.keys(options.fields).find(name => options.fields[name].operation === GroupByOperationID.groupBy);\n\n    if (!hasValidConfig) {\n      return data;\n    }\n\n    const processed = [];\n\n    for (const frame of data) {\n      const groupByFields = [];\n\n      for (const field of frame.fields) {\n        if (shouldGroupOnField(field, options)) {\n          groupByFields.push(field);\n        }\n      }\n\n      if (groupByFields.length === 0) {\n        continue; // No group by field in this frame, ignore the frame\n      } // Group the values by fields and groups so we can get all values for a\n      // group for a given field.\n\n\n      const valuesByGroupKey = new Map();\n\n      for (let rowIndex = 0; rowIndex < frame.length; rowIndex++) {\n        var _valuesByGroupKey$get;\n\n        const groupKey = String(groupByFields.map(field => field.values.get(rowIndex)));\n        const valuesByField = (_valuesByGroupKey$get = valuesByGroupKey.get(groupKey)) !== null && _valuesByGroupKey$get !== void 0 ? _valuesByGroupKey$get : {};\n\n        if (!valuesByGroupKey.has(groupKey)) {\n          valuesByGroupKey.set(groupKey, valuesByField);\n        }\n\n        for (let field of frame.fields) {\n          const fieldName = getFieldDisplayName(field);\n\n          if (!valuesByField[fieldName]) {\n            valuesByField[fieldName] = {\n              name: fieldName,\n              type: field.type,\n              config: Object.assign({}, field.config),\n              values: new ArrayVector()\n            };\n          }\n\n          valuesByField[fieldName].values.add(field.values.get(rowIndex));\n        }\n      }\n\n      const fields = [];\n\n      for (const field of groupByFields) {\n        const values = new ArrayVector();\n        const fieldName = getFieldDisplayName(field);\n        valuesByGroupKey.forEach(value => {\n          values.add(value[fieldName].values.get(0));\n        });\n        fields.push({\n          name: field.name,\n          type: field.type,\n          config: Object.assign({}, field.config),\n          values: values\n        });\n      } // Then for each calculations configured, compute and add a new field (column)\n\n\n      for (const field of frame.fields) {\n        if (!shouldCalculateField(field, options)) {\n          continue;\n        }\n\n        const fieldName = getFieldDisplayName(field);\n        const aggregations = options.fields[fieldName].aggregations;\n        const valuesByAggregation = {};\n        valuesByGroupKey.forEach(value => {\n          const fieldWithValuesForGroup = value[fieldName];\n          const results = reduceField({\n            field: fieldWithValuesForGroup,\n            reducers: aggregations\n          });\n\n          for (const aggregation of aggregations) {\n            if (!Array.isArray(valuesByAggregation[aggregation])) {\n              valuesByAggregation[aggregation] = [];\n            }\n\n            valuesByAggregation[aggregation].push(results[aggregation]);\n          }\n        });\n\n        for (const aggregation of aggregations) {\n          const aggregationField = {\n            name: `${fieldName} (${aggregation})`,\n            values: new ArrayVector(valuesByAggregation[aggregation]),\n            type: FieldType.other,\n            config: {}\n          };\n          aggregationField.type = detectFieldType(aggregation, field, aggregationField);\n          fields.push(aggregationField);\n        }\n      }\n\n      processed.push({\n        fields,\n        length: valuesByGroupKey.size\n      });\n    }\n\n    return processed;\n  }))\n};\n\nconst shouldGroupOnField = (field, options) => {\n  var _options$fields$field;\n\n  const fieldName = getFieldDisplayName(field);\n  return (options === null || options === void 0 ? void 0 : (_options$fields$field = options.fields[fieldName]) === null || _options$fields$field === void 0 ? void 0 : _options$fields$field.operation) === GroupByOperationID.groupBy;\n};\n\nconst shouldCalculateField = (field, options) => {\n  var _options$fields$field2;\n\n  const fieldName = getFieldDisplayName(field);\n  return (options === null || options === void 0 ? void 0 : (_options$fields$field2 = options.fields[fieldName]) === null || _options$fields$field2 === void 0 ? void 0 : _options$fields$field2.operation) === GroupByOperationID.aggregate && Array.isArray(options === null || options === void 0 ? void 0 : options.fields[fieldName].aggregations) && (options === null || options === void 0 ? void 0 : options.fields[fieldName].aggregations.length) > 0;\n};\n\nconst detectFieldType = (aggregation, sourceField, targetField) => {\n  var _guessFieldTypeForFie;\n\n  switch (aggregation) {\n    case ReducerID.allIsNull:\n      return FieldType.boolean;\n\n    case ReducerID.last:\n    case ReducerID.lastNotNull:\n    case ReducerID.first:\n    case ReducerID.firstNotNull:\n      return sourceField.type;\n\n    default:\n      return (_guessFieldTypeForFie = guessFieldTypeForField(targetField)) !== null && _guessFieldTypeForFie !== void 0 ? _guessFieldTypeForFie : FieldType.string;\n  }\n};","map":{"version":3,"names":["map","guessFieldTypeForField","getFieldDisplayName","FieldType","ArrayVector","reduceField","ReducerID","DataTransformerID","GroupByOperationID","groupByTransformer","id","groupBy","name","description","defaultOptions","fields","operator","options","source","pipe","data","hasValidConfig","Object","keys","find","operation","processed","frame","groupByFields","field","shouldGroupOnField","push","length","valuesByGroupKey","Map","rowIndex","groupKey","String","values","get","valuesByField","has","set","fieldName","type","config","add","forEach","value","shouldCalculateField","aggregations","valuesByAggregation","fieldWithValuesForGroup","results","reducers","aggregation","Array","isArray","aggregationField","other","detectFieldType","size","aggregate","sourceField","targetField","allIsNull","boolean","last","lastNotNull","first","firstNotNull","string"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/groupBy.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { MutableField } from '../../dataframe/MutableDataFrame';\nimport { guessFieldTypeForField } from '../../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { DataFrame, Field, FieldType } from '../../types/dataFrame';\nimport { DataTransformerInfo } from '../../types/transformations';\nimport { ArrayVector } from '../../vector/ArrayVector';\nimport { reduceField, ReducerID } from '../fieldReducer';\n\nimport { DataTransformerID } from './ids';\n\nexport enum GroupByOperationID {\n  aggregate = 'aggregate',\n  groupBy = 'groupby',\n}\n\nexport interface GroupByFieldOptions {\n  aggregations: ReducerID[];\n  operation: GroupByOperationID | null;\n}\n\nexport interface GroupByTransformerOptions {\n  fields: Record<string, GroupByFieldOptions>;\n}\n\nexport const groupByTransformer: DataTransformerInfo<GroupByTransformerOptions> = {\n  id: DataTransformerID.groupBy,\n  name: 'Group by',\n  description: 'Group the data by a field values then process calculations for each group',\n  defaultOptions: {\n    fields: {},\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        const hasValidConfig = Object.keys(options.fields).find(\n          (name) => options.fields[name].operation === GroupByOperationID.groupBy\n        );\n\n        if (!hasValidConfig) {\n          return data;\n        }\n\n        const processed: DataFrame[] = [];\n\n        for (const frame of data) {\n          const groupByFields: Field[] = [];\n\n          for (const field of frame.fields) {\n            if (shouldGroupOnField(field, options)) {\n              groupByFields.push(field);\n            }\n          }\n\n          if (groupByFields.length === 0) {\n            continue; // No group by field in this frame, ignore the frame\n          }\n\n          // Group the values by fields and groups so we can get all values for a\n          // group for a given field.\n          const valuesByGroupKey = new Map<string, Record<string, MutableField>>();\n          for (let rowIndex = 0; rowIndex < frame.length; rowIndex++) {\n            const groupKey = String(groupByFields.map((field) => field.values.get(rowIndex)));\n            const valuesByField = valuesByGroupKey.get(groupKey) ?? {};\n\n            if (!valuesByGroupKey.has(groupKey)) {\n              valuesByGroupKey.set(groupKey, valuesByField);\n            }\n\n            for (let field of frame.fields) {\n              const fieldName = getFieldDisplayName(field);\n\n              if (!valuesByField[fieldName]) {\n                valuesByField[fieldName] = {\n                  name: fieldName,\n                  type: field.type,\n                  config: { ...field.config },\n                  values: new ArrayVector(),\n                };\n              }\n\n              valuesByField[fieldName].values.add(field.values.get(rowIndex));\n            }\n          }\n\n          const fields: Field[] = [];\n\n          for (const field of groupByFields) {\n            const values = new ArrayVector();\n            const fieldName = getFieldDisplayName(field);\n\n            valuesByGroupKey.forEach((value) => {\n              values.add(value[fieldName].values.get(0));\n            });\n\n            fields.push({\n              name: field.name,\n              type: field.type,\n              config: {\n                ...field.config,\n              },\n              values: values,\n            });\n          }\n\n          // Then for each calculations configured, compute and add a new field (column)\n          for (const field of frame.fields) {\n            if (!shouldCalculateField(field, options)) {\n              continue;\n            }\n\n            const fieldName = getFieldDisplayName(field);\n            const aggregations = options.fields[fieldName].aggregations;\n            const valuesByAggregation: Record<string, any[]> = {};\n\n            valuesByGroupKey.forEach((value) => {\n              const fieldWithValuesForGroup = value[fieldName];\n              const results = reduceField({\n                field: fieldWithValuesForGroup,\n                reducers: aggregations,\n              });\n\n              for (const aggregation of aggregations) {\n                if (!Array.isArray(valuesByAggregation[aggregation])) {\n                  valuesByAggregation[aggregation] = [];\n                }\n                valuesByAggregation[aggregation].push(results[aggregation]);\n              }\n            });\n\n            for (const aggregation of aggregations) {\n              const aggregationField: Field = {\n                name: `${fieldName} (${aggregation})`,\n                values: new ArrayVector(valuesByAggregation[aggregation]),\n                type: FieldType.other,\n                config: {},\n              };\n\n              aggregationField.type = detectFieldType(aggregation, field, aggregationField);\n              fields.push(aggregationField);\n            }\n          }\n\n          processed.push({\n            fields,\n            length: valuesByGroupKey.size,\n          });\n        }\n\n        return processed;\n      })\n    ),\n};\n\nconst shouldGroupOnField = (field: Field, options: GroupByTransformerOptions): boolean => {\n  const fieldName = getFieldDisplayName(field);\n  return options?.fields[fieldName]?.operation === GroupByOperationID.groupBy;\n};\n\nconst shouldCalculateField = (field: Field, options: GroupByTransformerOptions): boolean => {\n  const fieldName = getFieldDisplayName(field);\n  return (\n    options?.fields[fieldName]?.operation === GroupByOperationID.aggregate &&\n    Array.isArray(options?.fields[fieldName].aggregations) &&\n    options?.fields[fieldName].aggregations.length > 0\n  );\n};\n\nconst detectFieldType = (aggregation: string, sourceField: Field, targetField: Field): FieldType => {\n  switch (aggregation) {\n    case ReducerID.allIsNull:\n      return FieldType.boolean;\n    case ReducerID.last:\n    case ReducerID.lastNotNull:\n    case ReducerID.first:\n    case ReducerID.firstNotNull:\n      return sourceField.type;\n    default:\n      return guessFieldTypeForField(targetField) ?? FieldType.string;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}