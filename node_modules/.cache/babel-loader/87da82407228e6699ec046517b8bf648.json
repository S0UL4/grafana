{"ast":null,"code":"import React, { useCallback } from 'react';\nimport { EditorRow } from '@grafana/experimental';\nimport { getMetadataString } from '../../language_provider';\nimport { promQueryModeller } from '../PromQueryModeller';\nimport { LabelFilters } from '../shared/LabelFilters';\nimport { OperationList } from '../shared/OperationList';\nimport { OperationsEditorRow } from '../shared/OperationsEditorRow';\nimport { MetricSelect } from './MetricSelect';\nimport { NestedQueryList } from './NestedQueryList';\nimport { PromQueryBuilderHints } from './PromQueryBuilderHints';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nexport const PromQueryBuilder = /*#__PURE__*/React.memo(({\n  datasource,\n  query,\n  onChange,\n  onRunQuery,\n  data\n}) => {\n  const onChangeLabels = labels => {\n    onChange(Object.assign({}, query, {\n      labels\n    }));\n  };\n  /**\n   * Map metric metadata to SelectableValue for Select component and also adds defined template variables to the list.\n   */\n\n\n  const withTemplateVariableOptions = useCallback(async optionsPromise => {\n    const variables = datasource.getVariables();\n    const options = await optionsPromise;\n    return [...variables.map(value => ({\n      label: value,\n      value\n    })), ...options.map(option => ({\n      label: option.value,\n      value: option.value,\n      title: option.description\n    }))];\n  }, [datasource]);\n\n  const onGetLabelNames = async forLabel => {\n    // If no metric we need to use a different method\n    if (!query.metric) {\n      // Todo add caching but inside language provider!\n      await datasource.languageProvider.fetchLabels();\n      return datasource.languageProvider.getLabelKeys().map(k => ({\n        value: k\n      }));\n    }\n\n    const labelsToConsider = query.labels.filter(x => x !== forLabel);\n    labelsToConsider.push({\n      label: '__name__',\n      op: '=',\n      value: query.metric\n    });\n    const expr = promQueryModeller.renderLabels(labelsToConsider);\n    const labelsIndex = await datasource.languageProvider.fetchSeriesLabels(expr); // filter out already used labels\n\n    return Object.keys(labelsIndex).filter(labelName => !labelsToConsider.find(filter => filter.label === labelName)).map(k => ({\n      value: k\n    }));\n  };\n\n  const onGetLabelValues = async forLabel => {\n    var _result$forLabelInter;\n\n    if (!forLabel.label) {\n      return [];\n    } // If no metric we need to use a different method\n\n\n    if (!query.metric) {\n      return (await datasource.languageProvider.getLabelValues(forLabel.label)).map(v => ({\n        value: v\n      }));\n    }\n\n    const labelsToConsider = query.labels.filter(x => x !== forLabel);\n    labelsToConsider.push({\n      label: '__name__',\n      op: '=',\n      value: query.metric\n    });\n    const expr = promQueryModeller.renderLabels(labelsToConsider);\n    const result = await datasource.languageProvider.fetchSeriesLabels(expr);\n    const forLabelInterpolated = datasource.interpolateString(forLabel.label);\n    return (_result$forLabelInter = result[forLabelInterpolated].map(v => ({\n      value: v\n    }))) !== null && _result$forLabelInter !== void 0 ? _result$forLabelInter : [];\n  };\n\n  const onGetMetrics = useCallback(() => {\n    return withTemplateVariableOptions(getMetrics(datasource, query));\n  }, [datasource, query, withTemplateVariableOptions]);\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [/*#__PURE__*/_jsxs(EditorRow, {\n      children: [/*#__PURE__*/_jsx(MetricSelect, {\n        query: query,\n        onChange: onChange,\n        onGetMetrics: onGetMetrics\n      }), /*#__PURE__*/_jsx(LabelFilters, {\n        labelsFilters: query.labels,\n        onChange: onChangeLabels,\n        onGetLabelNames: forLabel => withTemplateVariableOptions(onGetLabelNames(forLabel)),\n        onGetLabelValues: forLabel => withTemplateVariableOptions(onGetLabelValues(forLabel))\n      })]\n    }), /*#__PURE__*/_jsxs(OperationsEditorRow, {\n      children: [/*#__PURE__*/_jsx(OperationList, {\n        queryModeller: promQueryModeller,\n        datasource: datasource,\n        query: query,\n        onChange: onChange,\n        onRunQuery: onRunQuery\n      }), /*#__PURE__*/_jsx(PromQueryBuilderHints, {\n        datasource: datasource,\n        query: query,\n        onChange: onChange,\n        data: data\n      })]\n    }), query.binaryQueries && query.binaryQueries.length > 0 && /*#__PURE__*/_jsx(NestedQueryList, {\n      query: query,\n      datasource: datasource,\n      onChange: onChange,\n      onRunQuery: onRunQuery\n    })]\n  });\n});\n/**\n * Returns list of metrics, either all or filtered by query param. It also adds description string to each metric if it\n * exists.\n * @param datasource\n * @param query\n */\n\nasync function getMetrics(datasource, query) {\n  // Makes sure we loaded the metadata for metrics. Usually this is done in the start() method of the provider but we\n  // don't use it with the visual builder and there is no need to run all the start() setup anyway.\n  if (!datasource.languageProvider.metricsMetadata) {\n    await datasource.languageProvider.loadMetricsMetadata();\n  }\n\n  let metrics;\n\n  if (query.labels.length > 0) {\n    var _await$datasource$lan;\n\n    const expr = promQueryModeller.renderLabels(query.labels);\n    metrics = (_await$datasource$lan = (await datasource.languageProvider.getSeries(expr, true))['__name__']) !== null && _await$datasource$lan !== void 0 ? _await$datasource$lan : [];\n  } else {\n    var _await$datasource$lan2;\n\n    metrics = (_await$datasource$lan2 = await datasource.languageProvider.getLabelValues('__name__')) !== null && _await$datasource$lan2 !== void 0 ? _await$datasource$lan2 : [];\n  }\n\n  return metrics.map(m => ({\n    value: m,\n    description: getMetadataString(m, datasource.languageProvider.metricsMetadata)\n  }));\n}\n\nPromQueryBuilder.displayName = 'PromQueryBuilder';","map":{"version":3,"names":["React","useCallback","EditorRow","getMetadataString","promQueryModeller","LabelFilters","OperationList","OperationsEditorRow","MetricSelect","NestedQueryList","PromQueryBuilderHints","PromQueryBuilder","memo","datasource","query","onChange","onRunQuery","data","onChangeLabels","labels","withTemplateVariableOptions","optionsPromise","variables","getVariables","options","map","value","label","option","title","description","onGetLabelNames","forLabel","metric","languageProvider","fetchLabels","getLabelKeys","k","labelsToConsider","filter","x","push","op","expr","renderLabels","labelsIndex","fetchSeriesLabels","Object","keys","labelName","find","onGetLabelValues","getLabelValues","v","result","forLabelInterpolated","interpolateString","onGetMetrics","getMetrics","binaryQueries","length","metricsMetadata","loadMetricsMetadata","metrics","getSeries","m","displayName"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilder.tsx"],"sourcesContent":["import React, { useCallback } from 'react';\n\nimport { DataSourceApi, PanelData, SelectableValue } from '@grafana/data';\nimport { EditorRow } from '@grafana/experimental';\n\nimport { PrometheusDatasource } from '../../datasource';\nimport { getMetadataString } from '../../language_provider';\nimport { promQueryModeller } from '../PromQueryModeller';\nimport { LabelFilters } from '../shared/LabelFilters';\nimport { OperationList } from '../shared/OperationList';\nimport { OperationsEditorRow } from '../shared/OperationsEditorRow';\nimport { QueryBuilderLabelFilter } from '../shared/types';\nimport { PromVisualQuery } from '../types';\n\nimport { MetricSelect } from './MetricSelect';\nimport { NestedQueryList } from './NestedQueryList';\nimport { PromQueryBuilderHints } from './PromQueryBuilderHints';\n\nexport interface Props {\n  query: PromVisualQuery;\n  datasource: PrometheusDatasource;\n  onChange: (update: PromVisualQuery) => void;\n  onRunQuery: () => void;\n  nested?: boolean;\n  data?: PanelData;\n}\n\nexport const PromQueryBuilder = React.memo<Props>(({ datasource, query, onChange, onRunQuery, data }) => {\n  const onChangeLabels = (labels: QueryBuilderLabelFilter[]) => {\n    onChange({ ...query, labels });\n  };\n\n  /**\n   * Map metric metadata to SelectableValue for Select component and also adds defined template variables to the list.\n   */\n  const withTemplateVariableOptions = useCallback(\n    async (optionsPromise: Promise<Array<{ value: string; description?: string }>>): Promise<SelectableValue[]> => {\n      const variables = datasource.getVariables();\n      const options = await optionsPromise;\n      return [\n        ...variables.map((value) => ({ label: value, value })),\n        ...options.map((option) => ({ label: option.value, value: option.value, title: option.description })),\n      ];\n    },\n    [datasource]\n  );\n\n  const onGetLabelNames = async (forLabel: Partial<QueryBuilderLabelFilter>): Promise<Array<{ value: string }>> => {\n    // If no metric we need to use a different method\n    if (!query.metric) {\n      // Todo add caching but inside language provider!\n      await datasource.languageProvider.fetchLabels();\n      return datasource.languageProvider.getLabelKeys().map((k) => ({ value: k }));\n    }\n\n    const labelsToConsider = query.labels.filter((x) => x !== forLabel);\n    labelsToConsider.push({ label: '__name__', op: '=', value: query.metric });\n    const expr = promQueryModeller.renderLabels(labelsToConsider);\n    const labelsIndex = await datasource.languageProvider.fetchSeriesLabels(expr);\n\n    // filter out already used labels\n    return Object.keys(labelsIndex)\n      .filter((labelName) => !labelsToConsider.find((filter) => filter.label === labelName))\n      .map((k) => ({ value: k }));\n  };\n\n  const onGetLabelValues = async (forLabel: Partial<QueryBuilderLabelFilter>) => {\n    if (!forLabel.label) {\n      return [];\n    }\n\n    // If no metric we need to use a different method\n    if (!query.metric) {\n      return (await datasource.languageProvider.getLabelValues(forLabel.label)).map((v) => ({ value: v }));\n    }\n\n    const labelsToConsider = query.labels.filter((x) => x !== forLabel);\n    labelsToConsider.push({ label: '__name__', op: '=', value: query.metric });\n    const expr = promQueryModeller.renderLabels(labelsToConsider);\n    const result = await datasource.languageProvider.fetchSeriesLabels(expr);\n    const forLabelInterpolated = datasource.interpolateString(forLabel.label);\n    return result[forLabelInterpolated].map((v) => ({ value: v })) ?? [];\n  };\n\n  const onGetMetrics = useCallback(() => {\n    return withTemplateVariableOptions(getMetrics(datasource, query));\n  }, [datasource, query, withTemplateVariableOptions]);\n\n  return (\n    <>\n      <EditorRow>\n        <MetricSelect query={query} onChange={onChange} onGetMetrics={onGetMetrics} />\n        <LabelFilters\n          labelsFilters={query.labels}\n          onChange={onChangeLabels}\n          onGetLabelNames={(forLabel: Partial<QueryBuilderLabelFilter>) =>\n            withTemplateVariableOptions(onGetLabelNames(forLabel))\n          }\n          onGetLabelValues={(forLabel: Partial<QueryBuilderLabelFilter>) =>\n            withTemplateVariableOptions(onGetLabelValues(forLabel))\n          }\n        />\n      </EditorRow>\n      <OperationsEditorRow>\n        <OperationList<PromVisualQuery>\n          queryModeller={promQueryModeller}\n          datasource={datasource as DataSourceApi}\n          query={query}\n          onChange={onChange}\n          onRunQuery={onRunQuery}\n        />\n        <PromQueryBuilderHints datasource={datasource} query={query} onChange={onChange} data={data} />\n      </OperationsEditorRow>\n      {query.binaryQueries && query.binaryQueries.length > 0 && (\n        <NestedQueryList query={query} datasource={datasource} onChange={onChange} onRunQuery={onRunQuery} />\n      )}\n    </>\n  );\n});\n\n/**\n * Returns list of metrics, either all or filtered by query param. It also adds description string to each metric if it\n * exists.\n * @param datasource\n * @param query\n */\nasync function getMetrics(\n  datasource: PrometheusDatasource,\n  query: PromVisualQuery\n): Promise<Array<{ value: string; description?: string }>> {\n  // Makes sure we loaded the metadata for metrics. Usually this is done in the start() method of the provider but we\n  // don't use it with the visual builder and there is no need to run all the start() setup anyway.\n  if (!datasource.languageProvider.metricsMetadata) {\n    await datasource.languageProvider.loadMetricsMetadata();\n  }\n\n  let metrics;\n  if (query.labels.length > 0) {\n    const expr = promQueryModeller.renderLabels(query.labels);\n    metrics = (await datasource.languageProvider.getSeries(expr, true))['__name__'] ?? [];\n  } else {\n    metrics = (await datasource.languageProvider.getLabelValues('__name__')) ?? [];\n  }\n\n  return metrics.map((m) => ({\n    value: m,\n    description: getMetadataString(m, datasource.languageProvider.metricsMetadata!),\n  }));\n}\n\nPromQueryBuilder.displayName = 'PromQueryBuilder';\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}