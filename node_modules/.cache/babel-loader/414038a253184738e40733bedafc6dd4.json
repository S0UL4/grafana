{"ast":null,"code":"import { isEqual } from 'lodash';\nimport React, { PureComponent } from 'react';\nimport { compareDataFrameStructures, FieldType, getFieldColorModeForField } from '@grafana/data';\nimport { AxisPlacement, GraphDrawStyle, VisibilityMode, ScaleDirection, ScaleOrientation } from '@grafana/schema';\nimport { UPlotChart } from '../uPlot/Plot';\nimport { UPlotConfigBuilder } from '../uPlot/config/UPlotConfigBuilder';\nimport { preparePlotData2, getStackingGroups } from '../uPlot/utils';\nimport { preparePlotFrame } from './utils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst defaultConfig = {\n  drawStyle: GraphDrawStyle.Line,\n  showPoints: VisibilityMode.Auto,\n  axisPlacement: AxisPlacement.Hidden\n};\n/** @internal */\n\nexport class Sparkline extends PureComponent {\n  constructor(props) {\n    super(props);\n    const alignedDataFrame = preparePlotFrame(props.sparkline, props.config);\n    this.state = {\n      data: preparePlotData2(alignedDataFrame, getStackingGroups(alignedDataFrame)),\n      alignedDataFrame,\n      configBuilder: this.prepareConfig(alignedDataFrame)\n    };\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    const frame = preparePlotFrame(props.sparkline, props.config);\n\n    if (!frame) {\n      return Object.assign({}, state);\n    }\n\n    return Object.assign({}, state, {\n      data: preparePlotData2(frame, getStackingGroups(frame)),\n      alignedDataFrame: frame\n    });\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      alignedDataFrame\n    } = this.state;\n\n    if (!alignedDataFrame) {\n      return;\n    }\n\n    let rebuildConfig = false;\n\n    if (prevProps.sparkline !== this.props.sparkline) {\n      rebuildConfig = !compareDataFrameStructures(this.state.alignedDataFrame, prevState.alignedDataFrame);\n    } else {\n      rebuildConfig = !isEqual(prevProps.config, this.props.config);\n    }\n\n    if (rebuildConfig) {\n      this.setState({\n        configBuilder: this.prepareConfig(alignedDataFrame)\n      });\n    }\n  }\n\n  getYRange(field) {\n    var _this$state$alignedDa, _field$config$min, _field$config$max;\n\n    let {\n      min,\n      max\n    } = (_this$state$alignedDa = this.state.alignedDataFrame.fields[1].state) === null || _this$state$alignedDa === void 0 ? void 0 : _this$state$alignedDa.range;\n\n    if (min === max) {\n      if (min === 0) {\n        max = 100;\n      } else {\n        min = 0;\n        max *= 2;\n      }\n    }\n\n    return [Math.max(min, (_field$config$min = field.config.min) !== null && _field$config$min !== void 0 ? _field$config$min : -Infinity), Math.min(max, (_field$config$max = field.config.max) !== null && _field$config$max !== void 0 ? _field$config$max : Infinity)];\n  }\n\n  prepareConfig(data) {\n    const {\n      theme\n    } = this.props;\n    const builder = new UPlotConfigBuilder();\n    builder.setCursor({\n      show: false,\n      x: false,\n      // no crosshairs\n      y: false\n    }); // X is the first field in the alligned frame\n\n    const xField = data.fields[0];\n    builder.addScale({\n      scaleKey: 'x',\n      orientation: ScaleOrientation.Horizontal,\n      direction: ScaleDirection.Right,\n      isTime: false,\n      //xField.type === FieldType.time,\n      range: () => {\n        const {\n          sparkline\n        } = this.props;\n\n        if (sparkline.x) {\n          if (sparkline.timeRange && sparkline.x.type === FieldType.time) {\n            return [sparkline.timeRange.from.valueOf(), sparkline.timeRange.to.valueOf()];\n          }\n\n          const vals = sparkline.x.values;\n          return [vals.get(0), vals.get(vals.length - 1)];\n        }\n\n        return [0, sparkline.y.values.length - 1];\n      }\n    });\n    builder.addAxis({\n      scaleKey: 'x',\n      theme,\n      placement: AxisPlacement.Hidden\n    });\n\n    for (let i = 0; i < data.fields.length; i++) {\n      var _customConfig$lineCol, _customConfig$fillCol;\n\n      const field = data.fields[i];\n      const config = field.config;\n      const customConfig = Object.assign({}, defaultConfig, config.custom);\n\n      if (field === xField || field.type !== FieldType.number) {\n        continue;\n      }\n\n      const scaleKey = config.unit || '__fixed';\n      builder.addScale({\n        scaleKey,\n        orientation: ScaleOrientation.Vertical,\n        direction: ScaleDirection.Up,\n        range: () => this.getYRange(field)\n      });\n      builder.addAxis({\n        scaleKey,\n        theme,\n        placement: AxisPlacement.Hidden\n      });\n      const colorMode = getFieldColorModeForField(field);\n      const seriesColor = colorMode.getCalculator(field, theme)(0, 0);\n      const pointsMode = customConfig.drawStyle === GraphDrawStyle.Points ? VisibilityMode.Always : customConfig.showPoints;\n      builder.addSeries({\n        pxAlign: false,\n        scaleKey,\n        theme,\n        drawStyle: customConfig.drawStyle,\n        lineColor: (_customConfig$lineCol = customConfig.lineColor) !== null && _customConfig$lineCol !== void 0 ? _customConfig$lineCol : seriesColor,\n        lineWidth: customConfig.lineWidth,\n        lineInterpolation: customConfig.lineInterpolation,\n        showPoints: pointsMode,\n        pointSize: customConfig.pointSize,\n        fillOpacity: customConfig.fillOpacity,\n        fillColor: (_customConfig$fillCol = customConfig.fillColor) !== null && _customConfig$fillCol !== void 0 ? _customConfig$fillCol : seriesColor\n      });\n    }\n\n    return builder;\n  }\n\n  render() {\n    const {\n      data,\n      configBuilder\n    } = this.state;\n    const {\n      width,\n      height,\n      sparkline\n    } = this.props;\n    return /*#__PURE__*/_jsx(UPlotChart, {\n      data: data,\n      config: configBuilder,\n      width: width,\n      height: height,\n      timeRange: sparkline.timeRange\n    });\n  }\n\n}","map":{"version":3,"names":["isEqual","React","PureComponent","compareDataFrameStructures","FieldType","getFieldColorModeForField","AxisPlacement","GraphDrawStyle","VisibilityMode","ScaleDirection","ScaleOrientation","UPlotChart","UPlotConfigBuilder","preparePlotData2","getStackingGroups","preparePlotFrame","defaultConfig","drawStyle","Line","showPoints","Auto","axisPlacement","Hidden","Sparkline","constructor","props","alignedDataFrame","sparkline","config","state","data","configBuilder","prepareConfig","getDerivedStateFromProps","frame","componentDidUpdate","prevProps","prevState","rebuildConfig","setState","getYRange","field","min","max","fields","range","Math","Infinity","theme","builder","setCursor","show","x","y","xField","addScale","scaleKey","orientation","Horizontal","direction","Right","isTime","timeRange","type","time","from","valueOf","to","vals","values","get","length","addAxis","placement","i","customConfig","custom","number","unit","Vertical","Up","colorMode","seriesColor","getCalculator","pointsMode","Points","Always","addSeries","pxAlign","lineColor","lineWidth","lineInterpolation","pointSize","fillOpacity","fillColor","render","width","height"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/Sparkline/Sparkline.tsx"],"sourcesContent":["import { isEqual } from 'lodash';\nimport React, { PureComponent } from 'react';\nimport { AlignedData, Range } from 'uplot';\n\nimport {\n  compareDataFrameStructures,\n  DataFrame,\n  Field,\n  FieldConfig,\n  FieldSparkline,\n  FieldType,\n  getFieldColorModeForField,\n} from '@grafana/data';\nimport {\n  AxisPlacement,\n  GraphDrawStyle,\n  GraphFieldConfig,\n  VisibilityMode,\n  ScaleDirection,\n  ScaleOrientation,\n} from '@grafana/schema';\n\nimport { Themeable2 } from '../../types';\nimport { UPlotChart } from '../uPlot/Plot';\nimport { UPlotConfigBuilder } from '../uPlot/config/UPlotConfigBuilder';\nimport { preparePlotData2, getStackingGroups } from '../uPlot/utils';\n\nimport { preparePlotFrame } from './utils';\n\nexport interface SparklineProps extends Themeable2 {\n  width: number;\n  height: number;\n  config?: FieldConfig<GraphFieldConfig>;\n  sparkline: FieldSparkline;\n}\n\ninterface State {\n  data: AlignedData;\n  alignedDataFrame: DataFrame;\n  configBuilder: UPlotConfigBuilder;\n}\n\nconst defaultConfig: GraphFieldConfig = {\n  drawStyle: GraphDrawStyle.Line,\n  showPoints: VisibilityMode.Auto,\n  axisPlacement: AxisPlacement.Hidden,\n};\n\n/** @internal */\nexport class Sparkline extends PureComponent<SparklineProps, State> {\n  constructor(props: SparklineProps) {\n    super(props);\n\n    const alignedDataFrame = preparePlotFrame(props.sparkline, props.config);\n\n    this.state = {\n      data: preparePlotData2(alignedDataFrame, getStackingGroups(alignedDataFrame)),\n      alignedDataFrame,\n      configBuilder: this.prepareConfig(alignedDataFrame),\n    };\n  }\n\n  static getDerivedStateFromProps(props: SparklineProps, state: State) {\n    const frame = preparePlotFrame(props.sparkline, props.config);\n    if (!frame) {\n      return { ...state };\n    }\n\n    return {\n      ...state,\n      data: preparePlotData2(frame, getStackingGroups(frame)),\n      alignedDataFrame: frame,\n    };\n  }\n\n  componentDidUpdate(prevProps: SparklineProps, prevState: State) {\n    const { alignedDataFrame } = this.state;\n\n    if (!alignedDataFrame) {\n      return;\n    }\n\n    let rebuildConfig = false;\n\n    if (prevProps.sparkline !== this.props.sparkline) {\n      rebuildConfig = !compareDataFrameStructures(this.state.alignedDataFrame, prevState.alignedDataFrame);\n    } else {\n      rebuildConfig = !isEqual(prevProps.config, this.props.config);\n    }\n\n    if (rebuildConfig) {\n      this.setState({ configBuilder: this.prepareConfig(alignedDataFrame) });\n    }\n  }\n\n  getYRange(field: Field) {\n    let { min, max } = this.state.alignedDataFrame.fields[1].state?.range!;\n\n    if (min === max) {\n      if (min === 0) {\n        max = 100;\n      } else {\n        min = 0;\n        max! *= 2;\n      }\n    }\n\n    return [\n      Math.max(min!, field.config.min ?? -Infinity),\n      Math.min(max!, field.config.max ?? Infinity),\n    ] as Range.MinMax;\n  }\n\n  prepareConfig(data: DataFrame) {\n    const { theme } = this.props;\n    const builder = new UPlotConfigBuilder();\n\n    builder.setCursor({\n      show: false,\n      x: false, // no crosshairs\n      y: false,\n    });\n\n    // X is the first field in the alligned frame\n    const xField = data.fields[0];\n    builder.addScale({\n      scaleKey: 'x',\n      orientation: ScaleOrientation.Horizontal,\n      direction: ScaleDirection.Right,\n      isTime: false, //xField.type === FieldType.time,\n      range: () => {\n        const { sparkline } = this.props;\n        if (sparkline.x) {\n          if (sparkline.timeRange && sparkline.x.type === FieldType.time) {\n            return [sparkline.timeRange.from.valueOf(), sparkline.timeRange.to.valueOf()];\n          }\n          const vals = sparkline.x.values;\n          return [vals.get(0), vals.get(vals.length - 1)];\n        }\n        return [0, sparkline.y.values.length - 1];\n      },\n    });\n\n    builder.addAxis({\n      scaleKey: 'x',\n      theme,\n      placement: AxisPlacement.Hidden,\n    });\n\n    for (let i = 0; i < data.fields.length; i++) {\n      const field = data.fields[i];\n      const config = field.config as FieldConfig<GraphFieldConfig>;\n      const customConfig: GraphFieldConfig = {\n        ...defaultConfig,\n        ...config.custom,\n      };\n\n      if (field === xField || field.type !== FieldType.number) {\n        continue;\n      }\n\n      const scaleKey = config.unit || '__fixed';\n      builder.addScale({\n        scaleKey,\n        orientation: ScaleOrientation.Vertical,\n        direction: ScaleDirection.Up,\n        range: () => this.getYRange(field),\n      });\n\n      builder.addAxis({\n        scaleKey,\n        theme,\n        placement: AxisPlacement.Hidden,\n      });\n\n      const colorMode = getFieldColorModeForField(field);\n      const seriesColor = colorMode.getCalculator(field, theme)(0, 0);\n      const pointsMode =\n        customConfig.drawStyle === GraphDrawStyle.Points ? VisibilityMode.Always : customConfig.showPoints;\n\n      builder.addSeries({\n        pxAlign: false,\n        scaleKey,\n        theme,\n        drawStyle: customConfig.drawStyle!,\n        lineColor: customConfig.lineColor ?? seriesColor,\n        lineWidth: customConfig.lineWidth,\n        lineInterpolation: customConfig.lineInterpolation,\n        showPoints: pointsMode,\n        pointSize: customConfig.pointSize,\n        fillOpacity: customConfig.fillOpacity,\n        fillColor: customConfig.fillColor ?? seriesColor,\n      });\n    }\n\n    return builder;\n  }\n\n  render() {\n    const { data, configBuilder } = this.state;\n    const { width, height, sparkline } = this.props;\n    return (\n      <UPlotChart data={data} config={configBuilder} width={width} height={height} timeRange={sparkline.timeRange!} />\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}