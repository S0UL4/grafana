{"ast":null,"code":"var _Badge, _Badge2, _Tooltip, _div, _div2;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { cloneDeep, defaults } from 'lodash';\nimport LRU from 'lru-cache';\nimport React from 'react';\nimport { forkJoin, lastValueFrom, merge, of, pipe, throwError } from 'rxjs';\nimport { catchError, filter, map, tap } from 'rxjs/operators';\nimport { CoreApp, dateMath, LoadingState, rangeUtil, dateTime } from '@grafana/data';\nimport { getBackendSrv, DataSourceWithBackend, toDataQueryResponse, isFetchError } from '@grafana/runtime';\nimport { Badge, Tooltip } from '@grafana/ui';\nimport { safeStringifyValue } from 'app/core/utils/explore';\nimport { discoverDataSourceFeatures } from 'app/features/alerting/unified/api/buildInfo';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { getTemplateSrv } from 'app/features/templating/template_srv';\nimport { PromApplication } from 'app/types/unified-alerting-dto';\nimport { addLabelToQuery } from './add_label_to_query';\nimport { AnnotationQueryEditor } from './components/AnnotationQueryEditor';\nimport PrometheusLanguageProvider from './language_provider';\nimport { expandRecordingRules } from './language_utils';\nimport { renderLegendFormat } from './legend';\nimport PrometheusMetricFindQuery from './metric_find_query';\nimport { getInitHints, getQueryHints } from './query_hints';\nimport { getOriginalMetricName, transform, transformV2 } from './result_transformer';\nimport { PromQueryType } from './types';\nimport { PrometheusVariableSupport } from './variables';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nconst ANNOTATION_QUERY_STEP_DEFAULT = '60s';\nconst GET_AND_POST_METADATA_ENDPOINTS = ['api/v1/query', 'api/v1/query_range', 'api/v1/series', 'api/v1/labels'];\nexport class PrometheusDatasource extends DataSourceWithBackend {\n  constructor(instanceSettings, templateSrv = getTemplateSrv(), timeSrv = getTimeSrv(), languageProvider) {\n    var _instanceSettings$jso, _instanceSettings$jso2;\n\n    super(instanceSettings);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"editorSrc\", void 0);\n\n    _defineProperty(this, \"ruleMappings\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"directUrl\", void 0);\n\n    _defineProperty(this, \"access\", void 0);\n\n    _defineProperty(this, \"basicAuth\", void 0);\n\n    _defineProperty(this, \"withCredentials\", void 0);\n\n    _defineProperty(this, \"metricsNameCache\", new LRU({\n      max: 10\n    }));\n\n    _defineProperty(this, \"interval\", void 0);\n\n    _defineProperty(this, \"queryTimeout\", void 0);\n\n    _defineProperty(this, \"httpMethod\", void 0);\n\n    _defineProperty(this, \"languageProvider\", void 0);\n\n    _defineProperty(this, \"exemplarTraceIdDestinations\", void 0);\n\n    _defineProperty(this, \"lookupsDisabled\", void 0);\n\n    _defineProperty(this, \"customQueryParameters\", void 0);\n\n    _defineProperty(this, \"exemplarsAvailable\", void 0);\n\n    _defineProperty(this, \"subType\", void 0);\n\n    _defineProperty(this, \"rulerEnabled\", void 0);\n\n    _defineProperty(this, \"init\", async () => {\n      this.loadRules();\n      this.exemplarsAvailable = await this.areExemplarsAvailable();\n    });\n\n    _defineProperty(this, \"prepareTargets\", (options, start, end) => {\n      const queries = [];\n      const activeTargets = [];\n      const clonedTargets = cloneDeep(options.targets);\n\n      for (const target of clonedTargets) {\n        if (!target.expr || target.hide) {\n          continue;\n        }\n\n        target.requestId = options.panelId + target.refId;\n        const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // In Explore, we run both (instant and range) queries if both are true (selected) or both are undefined (legacy Explore queries)\n\n        if (options.app === CoreApp.Explore && target.range === target.instant) {\n          // Create instant target\n          const instantTarget = cloneDeep(target);\n          instantTarget.format = 'table';\n          instantTarget.instant = true;\n          instantTarget.range = false;\n          instantTarget.valueWithRefId = true;\n          delete instantTarget.maxDataPoints;\n          instantTarget.requestId += '_instant'; // Create range target\n\n          const rangeTarget = cloneDeep(target);\n          rangeTarget.format = 'time_series';\n          rangeTarget.instant = false;\n          instantTarget.range = true; // Create exemplar query\n\n          if (target.exemplar) {\n            // Only create exemplar target for different metric names\n            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {\n              const exemplarTarget = cloneDeep(target);\n              exemplarTarget.instant = false;\n              exemplarTarget.requestId += '_exemplar';\n              queries.push(this.createQuery(exemplarTarget, options, start, end));\n              activeTargets.push(exemplarTarget);\n            }\n\n            instantTarget.exemplar = false;\n            rangeTarget.exemplar = false;\n          } // Add both targets to activeTargets and queries arrays\n\n\n          activeTargets.push(instantTarget, rangeTarget);\n          queries.push(this.createQuery(instantTarget, options, start, end), this.createQuery(rangeTarget, options, start, end)); // If running only instant query in Explore, format as table\n        } else if (target.instant && options.app === CoreApp.Explore) {\n          const instantTarget = cloneDeep(target);\n          instantTarget.format = 'table';\n          queries.push(this.createQuery(instantTarget, options, start, end));\n          activeTargets.push(instantTarget);\n        } else {\n          // It doesn't make sense to query for exemplars in dashboard if only instant is selected\n          if (target.exemplar && !target.instant) {\n            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {\n              const exemplarTarget = cloneDeep(target);\n              exemplarTarget.requestId += '_exemplar';\n              queries.push(this.createQuery(exemplarTarget, options, start, end));\n              activeTargets.push(exemplarTarget);\n            }\n\n            target.exemplar = false;\n          }\n\n          queries.push(this.createQuery(target, options, start, end));\n          activeTargets.push(target);\n        }\n      }\n\n      return {\n        queries,\n        activeTargets\n      };\n    });\n\n    _defineProperty(this, \"handleErrors\", (err, target) => {\n      const error = {\n        message: err && err.statusText || 'Unknown error during query transaction. Please check JS console logs.',\n        refId: target.refId\n      };\n\n      if (err.data) {\n        if (typeof err.data === 'string') {\n          error.message = err.data;\n        } else if (err.data.error) {\n          error.message = safeStringifyValue(err.data.error);\n        }\n      } else if (err.message) {\n        error.message = err.message;\n      } else if (typeof err === 'string') {\n        error.message = err;\n      }\n\n      error.status = err.status;\n      error.statusText = err.statusText;\n      return error;\n    });\n\n    _defineProperty(this, \"processAnnotationResponse\", (options, data) => {\n      const frames = toDataQueryResponse({\n        data: data\n      }).data;\n\n      if (!frames || !frames.length) {\n        return [];\n      }\n\n      const annotation = options.annotation;\n      const {\n        tagKeys = '',\n        titleFormat = '',\n        textFormat = ''\n      } = annotation;\n      const step = rangeUtil.intervalToSeconds(annotation.step || ANNOTATION_QUERY_STEP_DEFAULT) * 1000;\n      const tagKeysArray = tagKeys.split(',');\n      const eventList = [];\n\n      for (const frame of frames) {\n        const timeField = frame.fields[0];\n        const valueField = frame.fields[1];\n        const labels = (valueField === null || valueField === void 0 ? void 0 : valueField.labels) || {};\n        const tags = Object.keys(labels).filter(label => tagKeysArray.includes(label)).map(label => labels[label]);\n        const timeValueTuple = [];\n        let idx = 0;\n        valueField.values.toArray().forEach(value => {\n          let timeStampValue;\n          let valueValue;\n          const time = timeField.values.get(idx); // If we want to use value as a time, we use value as timeStampValue and valueValue will be 1\n\n          if (options.annotation.useValueForTime) {\n            timeStampValue = Math.floor(parseFloat(value));\n            valueValue = 1;\n          } else {\n            timeStampValue = Math.floor(parseFloat(time));\n            valueValue = parseFloat(value);\n          }\n\n          idx++;\n          timeValueTuple.push([timeStampValue, valueValue]);\n        });\n        const activeValues = timeValueTuple.filter(value => value[1] >= 1);\n        const activeValuesTimestamps = activeValues.map(value => value[0]); // Instead of creating singular annotation for each active event we group events into region if they are less\n        // or equal to `step` apart.\n\n        let latestEvent = null;\n\n        for (const timestamp of activeValuesTimestamps) {\n          var _latestEvent$timeEnd;\n\n          // We already have event `open` and we have new event that is inside the `step` so we just update the end.\n          if (latestEvent && ((_latestEvent$timeEnd = latestEvent.timeEnd) !== null && _latestEvent$timeEnd !== void 0 ? _latestEvent$timeEnd : 0) + step >= timestamp) {\n            latestEvent.timeEnd = timestamp;\n            continue;\n          } // Event exists but new one is outside of the `step` so we add it to eventList.\n\n\n          if (latestEvent) {\n            eventList.push(latestEvent);\n          } // We start a new region.\n\n\n          latestEvent = {\n            time: timestamp,\n            timeEnd: timestamp,\n            annotation,\n            title: renderLegendFormat(titleFormat, labels),\n            tags,\n            text: renderLegendFormat(textFormat, labels)\n          };\n        }\n\n        if (latestEvent) {\n          // Finish up last point if we have one\n          latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];\n          eventList.push(latestEvent);\n        }\n      }\n\n      return eventList;\n    });\n\n    this.templateSrv = templateSrv;\n    this.timeSrv = timeSrv;\n    this.type = 'prometheus';\n    this.subType = PromApplication.Prometheus;\n    this.rulerEnabled = false;\n    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';\n    this.id = instanceSettings.id;\n    this.url = instanceSettings.url;\n    this.access = instanceSettings.access;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n    this.queryTimeout = instanceSettings.jsonData.queryTimeout;\n    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET'; // `directUrl` is never undefined, we set it at https://github.com/grafana/grafana/blob/main/pkg/api/frontendsettings.go#L108\n    // here we \"fall back\" to this.url to make typescript happy, but it should never happen\n\n    this.directUrl = (_instanceSettings$jso = instanceSettings.jsonData.directUrl) !== null && _instanceSettings$jso !== void 0 ? _instanceSettings$jso : this.url;\n    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n    this.ruleMappings = {};\n    this.languageProvider = languageProvider !== null && languageProvider !== void 0 ? languageProvider : new PrometheusLanguageProvider(this);\n    this.lookupsDisabled = (_instanceSettings$jso2 = instanceSettings.jsonData.disableMetricsLookup) !== null && _instanceSettings$jso2 !== void 0 ? _instanceSettings$jso2 : false;\n    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n    this.variables = new PrometheusVariableSupport(this, this.templateSrv, this.timeSrv);\n    this.exemplarsAvailable = true; // This needs to be here and cannot be static because of how annotations typing affects casting of data source\n    // objects to DataSourceApi types.\n    // We don't use the default processing for prometheus.\n    // See standardAnnotationSupport.ts/[shouldUseMappingUI|shouldUseLegacyRunner]\n\n    this.annotations = {\n      QueryEditor: AnnotationQueryEditor\n    };\n  }\n\n  getQueryDisplayText(query) {\n    return query.expr;\n  }\n\n  _addTracingHeaders(httpOptions, options) {\n    httpOptions.headers = {};\n    const proxyMode = !this.url.match(/^http/);\n\n    if (proxyMode) {\n      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\n      httpOptions.headers['X-Panel-Id'] = options.panelId;\n    }\n  }\n  /**\n   * Any request done from this data source should go through here as it contains some common processing for the\n   * request. Any processing done here needs to be also copied on the backend as this goes through data source proxy\n   * but not through the same code as alerting.\n   */\n\n\n  _request(url, data, overrides = {}) {\n    data = data || {};\n\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    let queryUrl = this.url + url;\n\n    if (url.startsWith(`/api/datasources/${this.id}`)) {\n      // This url is meant to be a replacement for the whole URL. Replace the entire URL\n      queryUrl = url;\n    }\n\n    const options = defaults(overrides, {\n      url: queryUrl,\n      method: this.httpMethod,\n      headers: {}\n    });\n\n    if (options.method === 'GET') {\n      if (data && Object.keys(data).length) {\n        options.url = options.url + (options.url.search(/\\?/) >= 0 ? '&' : '?') + Object.entries(data).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n      }\n    } else {\n      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.data = data;\n    }\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n\n    if (this.basicAuth) {\n      options.headers.Authorization = this.basicAuth;\n    }\n\n    return getBackendSrv().fetch(options);\n  }\n\n  async importFromAbstractQueries(abstractQueries) {\n    return abstractQueries.map(abstractQuery => this.languageProvider.importFromAbstractQuery(abstractQuery));\n  }\n\n  async exportToAbstractQueries(queries) {\n    return queries.map(query => this.languageProvider.exportToAbstractQuery(query));\n  } // Use this for tab completion features, wont publish response to other components\n\n\n  async metadataRequest(url, params = {}) {\n    // If URL includes endpoint that supports POST and GET method, try to use configured method. This might fail as POST is supported only in v2.10+.\n    if (GET_AND_POST_METADATA_ENDPOINTS.some(endpoint => url.includes(endpoint))) {\n      try {\n        return await lastValueFrom(this._request(`/api/datasources/${this.id}/resources${url}`, params, {\n          method: this.httpMethod,\n          hideFromInspector: true,\n          showErrorAlert: false\n        }));\n      } catch (err) {\n        // If status code of error is Method Not Allowed (405) and HTTP method is POST, retry with GET\n        if (this.httpMethod === 'POST' && isFetchError(err) && (err.status === 405 || err.status === 400)) {\n          console.warn(`Couldn't use configured POST HTTP method for this request. Trying to use GET method instead.`);\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    return await lastValueFrom(this._request(`/api/datasources/${this.id}/resources${url}`, params, {\n      method: 'GET',\n      hideFromInspector: true\n    })); // toPromise until we change getTagValues, getTagKeys to Observable\n  }\n\n  interpolateQueryExpr(value = [], variable) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return prometheusRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return prometheusSpecialRegexEscape(value);\n    }\n\n    const escapedValues = value.map(val => prometheusSpecialRegexEscape(val));\n\n    if (escapedValues.length === 1) {\n      return escapedValues[0];\n    }\n\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  targetContainsTemplate(target) {\n    return this.templateSrv.containsTemplate(target.expr);\n  }\n\n  shouldRunExemplarQuery(target, request) {\n    if (target.exemplar) {\n      // We check all already processed targets and only create exemplar target for not used metric names\n      const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // Remove targets that weren't processed yet (in targets array they are after current target)\n\n      const currentTargetIdx = request.targets.findIndex(t => t.refId === target.refId);\n      const targets = request.targets.slice(0, currentTargetIdx).filter(t => !t.hide);\n\n      if (!metricName || metricName && !targets.some(t => t.expr.includes(metricName))) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return false;\n  }\n\n  processTargetV2(target, request) {\n    const processedTarget = Object.assign({}, target, {\n      queryType: PromQueryType.timeSeriesQuery,\n      exemplar: this.shouldRunExemplarQuery(target, request),\n      requestId: request.panelId + target.refId,\n      // We need to pass utcOffsetSec to backend to calculate aligned range\n      utcOffsetSec: this.timeSrv.timeRange().to.utcOffset() * 60\n    });\n    return processedTarget;\n  }\n\n  query(request) {\n    if (this.access === 'proxy') {\n      const targets = request.targets.map(target => this.processTargetV2(target, request));\n      return super.query(Object.assign({}, request, {\n        targets\n      })).pipe(map(response => transformV2(response, request, {\n        exemplarTraceIdDestinations: this.exemplarTraceIdDestinations\n      }))); // Run queries trough browser/proxy\n    } else {\n      const start = this.getPrometheusTime(request.range.from, false);\n      const end = this.getPrometheusTime(request.range.to, true);\n      const {\n        queries,\n        activeTargets\n      } = this.prepareTargets(request, start, end); // No valid targets, return the empty result to save a round trip.\n\n      if (!queries || !queries.length) {\n        return of({\n          data: [],\n          state: LoadingState.Done\n        });\n      }\n\n      if (request.app === CoreApp.Explore) {\n        return this.exploreQuery(queries, activeTargets, end);\n      }\n\n      return this.panelsQuery(queries, activeTargets, end, request.requestId, request.scopedVars);\n    }\n  }\n\n  exploreQuery(queries, activeTargets, end) {\n    let runningQueriesCount = queries.length;\n    const subQueries = queries.map((query, index) => {\n      const target = activeTargets[index];\n      const filterAndMapResponse = pipe( // Decrease the counter here. We assume that each request returns only single value and then completes\n      // (should hold until there is some streaming requests involved).\n      tap(() => runningQueriesCount--), filter(response => response.cancelled ? false : true), map(response => {\n        const data = transform(response, {\n          query,\n          target,\n          responseListLength: queries.length,\n          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations\n        });\n        return {\n          data,\n          key: query.requestId,\n          state: runningQueriesCount === 0 ? LoadingState.Done : LoadingState.Loading\n        };\n      }));\n      return this.runQuery(query, end, filterAndMapResponse);\n    });\n    return merge(...subQueries);\n  }\n\n  panelsQuery(queries, activeTargets, end, requestId, scopedVars) {\n    const observables = queries.map((query, index) => {\n      const target = activeTargets[index];\n      const filterAndMapResponse = pipe(filter(response => response.cancelled ? false : true), map(response => {\n        const data = transform(response, {\n          query,\n          target,\n          responseListLength: queries.length,\n          scopedVars,\n          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations\n        });\n        return data;\n      }));\n      return this.runQuery(query, end, filterAndMapResponse);\n    });\n    return forkJoin(observables).pipe(map(results => {\n      const data = results.reduce((result, current) => {\n        return [...result, ...current];\n      }, []);\n      return {\n        data,\n        key: requestId,\n        state: LoadingState.Done\n      };\n    }));\n  }\n\n  runQuery(query, end, filter) {\n    if (query.instant) {\n      return this.performInstantQuery(query, end).pipe(filter);\n    }\n\n    if (query.exemplar) {\n      return this.getExemplars(query).pipe(catchError(() => {\n        return of({\n          data: [],\n          state: LoadingState.Done\n        });\n      }), filter);\n    }\n\n    return this.performTimeSeriesQuery(query, query.start, query.end).pipe(filter);\n  }\n\n  createQuery(target, options, start, end) {\n    const query = {\n      hinting: target.hinting,\n      instant: target.instant,\n      exemplar: target.exemplar,\n      step: 0,\n      expr: '',\n      requestId: target.requestId,\n      refId: target.refId,\n      start: 0,\n      end: 0\n    };\n    const range = Math.ceil(end - start); // options.interval is the dynamically calculated interval\n\n    let interval = rangeUtil.intervalToSeconds(options.interval); // Minimum interval (\"Min step\"), if specified for the query, or same as interval otherwise.\n\n    const minInterval = rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval || options.interval, options.scopedVars)); // Scrape interval as specified for the query (\"Min step\") or otherwise taken from the datasource.\n    // Min step field can have template variables in it, make sure to replace it.\n\n    const scrapeInterval = target.interval ? rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval, options.scopedVars)) : rangeUtil.intervalToSeconds(this.interval);\n    const intervalFactor = target.intervalFactor || 1; // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits\n\n    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);\n    let scopedVars = Object.assign({}, options.scopedVars, this.getRangeScopedVars(options.range), this.getRateIntervalScopedVariable(adjustedInterval, scrapeInterval)); // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars\n\n    if (interval !== adjustedInterval) {\n      interval = adjustedInterval;\n      scopedVars = Object.assign({}, options.scopedVars, Object.assign({\n        __interval: {\n          text: interval + 's',\n          value: interval + 's'\n        },\n        __interval_ms: {\n          text: interval * 1000,\n          value: interval * 1000\n        }\n      }, this.getRateIntervalScopedVariable(interval, scrapeInterval), this.getRangeScopedVars(options.range)));\n    }\n\n    query.step = interval;\n    let expr = target.expr; // Apply adhoc filters\n\n    expr = this.enhanceExprWithAdHocFilters(expr); // Only replace vars in expression after having (possibly) updated interval vars\n\n    query.expr = this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr); // Align query interval with step to allow query caching and to ensure\n    // that about-same-time query results look the same.\n\n    const adjusted = alignRange(start, end, query.step, this.timeSrv.timeRange().to.utcOffset() * 60);\n    query.start = adjusted.start;\n    query.end = adjusted.end;\n\n    this._addTracingHeaders(query, options);\n\n    return query;\n  }\n\n  getRateIntervalScopedVariable(interval, scrapeInterval) {\n    // Fall back to the default scrape interval of 15s if scrapeInterval is 0 for some reason.\n    if (scrapeInterval === 0) {\n      scrapeInterval = 15;\n    }\n\n    const rateInterval = Math.max(interval + scrapeInterval, 4 * scrapeInterval);\n    return {\n      __rate_interval: {\n        text: rateInterval + 's',\n        value: rateInterval + 's'\n      }\n    };\n  }\n\n  adjustInterval(interval, minInterval, range, intervalFactor) {\n    // Prometheus will drop queries that might return more than 11000 data points.\n    // Calculate a safe interval as an additional minimum to take into account.\n    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1\n    // If this is the case take the ceil of the value.\n    let safeInterval = range / 11000;\n\n    if (safeInterval > 1) {\n      safeInterval = Math.ceil(safeInterval);\n    }\n\n    return Math.max(interval * intervalFactor, minInterval, safeInterval);\n  }\n\n  performTimeSeriesQuery(query, start, end) {\n    if (start > end) {\n      throw {\n        message: 'Invalid time range'\n      };\n    }\n\n    const url = '/api/v1/query_range';\n    const data = {\n      query: query.expr,\n      start,\n      end,\n      step: query.step\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    return this._request(url, data, {\n      requestId: query.requestId,\n      headers: query.headers\n    }).pipe(catchError(err => {\n      if (err.cancelled) {\n        return of(err);\n      }\n\n      return throwError(this.handleErrors(err, query));\n    }));\n  }\n\n  performInstantQuery(query, time) {\n    const url = '/api/v1/query';\n    const data = {\n      query: query.expr,\n      time\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    return this._request(url, data, {\n      requestId: query.requestId,\n      headers: query.headers\n    }).pipe(catchError(err => {\n      if (err.cancelled) {\n        return of(err);\n      }\n\n      return throwError(this.handleErrors(err, query));\n    }));\n  }\n\n  metricFindQuery(query) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const scopedVars = Object.assign({\n      __interval: {\n        text: this.interval,\n        value: this.interval\n      },\n      __interval_ms: {\n        text: rangeUtil.intervalToMs(this.interval),\n        value: rangeUtil.intervalToMs(this.interval)\n      }\n    }, this.getRangeScopedVars(this.timeSrv.timeRange()));\n    const interpolated = this.templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);\n    const metricFindQuery = new PrometheusMetricFindQuery(this, interpolated);\n    return metricFindQuery.process();\n  }\n\n  getRangeScopedVars(range = this.timeSrv.timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: {\n        text: msRange,\n        value: msRange\n      },\n      __range_s: {\n        text: sRange,\n        value: sRange\n      },\n      __range: {\n        text: sRange + 's',\n        value: sRange + 's'\n      }\n    };\n  }\n\n  async annotationQuery(options) {\n    const annotation = options.annotation;\n    const {\n      expr = ''\n    } = annotation;\n\n    if (!expr) {\n      return Promise.resolve([]);\n    }\n\n    const step = options.annotation.step || ANNOTATION_QUERY_STEP_DEFAULT;\n    const queryModel = {\n      expr,\n      range: true,\n      instant: false,\n      exemplar: false,\n      interval: step,\n      queryType: PromQueryType.timeSeriesQuery,\n      refId: 'X',\n      datasource: this.getRef()\n    };\n    return await lastValueFrom(getBackendSrv().fetch({\n      url: '/api/ds/query',\n      method: 'POST',\n      data: {\n        from: (this.getPrometheusTime(options.range.from, false) * 1000).toString(),\n        to: (this.getPrometheusTime(options.range.to, true) * 1000).toString(),\n        queries: [this.applyTemplateVariables(queryModel, {})]\n      },\n      requestId: `prom-query-${annotation.name}`\n    }).pipe(map(rsp => {\n      return this.processAnnotationResponse(options, rsp.data);\n    })));\n  }\n\n  getExemplars(query) {\n    const url = '/api/v1/query_exemplars';\n    return this._request(url, {\n      query: query.expr,\n      start: query.start.toString(),\n      end: query.end.toString()\n    }, {\n      requestId: query.requestId,\n      headers: query.headers\n    });\n  }\n\n  async getSubtitle() {\n    const buildInfo = await this.getBuildInfo();\n    return buildInfo ? this.getBuildInfoMessage(buildInfo) : null;\n  }\n\n  async getTagKeys(options) {\n    if (options !== null && options !== void 0 && options.series) {\n      // Get tags for the provided series only\n      const seriesLabels = await Promise.all(options.series.map(series => this.languageProvider.fetchSeriesLabels(series))); // Combines tags from all options.series provided\n\n      let tags = [];\n      seriesLabels.map(value => tags = tags.concat(Object.keys(value)));\n      const uniqueLabels = [...new Set(tags)];\n      return uniqueLabels.map(value => ({\n        text: value\n      }));\n    } else {\n      var _result$data$data$map, _result$data, _result$data$data;\n\n      // Get all tags\n      const result = await this.metadataRequest('/api/v1/labels');\n      return (_result$data$data$map = result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : (_result$data$data = _result$data.data) === null || _result$data$data === void 0 ? void 0 : _result$data$data.map(value => ({\n        text: value\n      }))) !== null && _result$data$data$map !== void 0 ? _result$data$data$map : [];\n    }\n  }\n\n  async getTagValues(options = {}) {\n    var _result$data$data$map2, _result$data2, _result$data2$data;\n\n    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);\n    return (_result$data$data$map2 = result === null || result === void 0 ? void 0 : (_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : (_result$data2$data = _result$data2.data) === null || _result$data2$data === void 0 ? void 0 : _result$data2$data.map(value => ({\n      text: value\n    }))) !== null && _result$data$data$map2 !== void 0 ? _result$data$data$map2 : [];\n  }\n\n  async getBuildInfo() {\n    try {\n      const buildInfo = await discoverDataSourceFeatures({\n        url: this.url,\n        name: this.name,\n        type: 'prometheus'\n      });\n      return buildInfo;\n    } catch (error) {\n      // We don't want to break the rest of functionality if build info does not work correctly\n      return undefined;\n    }\n  }\n\n  getBuildInfoMessage(buildInfo) {\n    var _buildInfo$applicatio, _buildInfo$applicatio2;\n\n    const enabled = _Badge || (_Badge = /*#__PURE__*/_jsx(Badge, {\n      color: \"green\",\n      icon: \"check\",\n      text: \"Ruler API enabled\"\n    }));\n\n    const disabled = _Badge2 || (_Badge2 = /*#__PURE__*/_jsx(Badge, {\n      color: \"orange\",\n      icon: \"exclamation-triangle\",\n      text: \"Ruler API not enabled\"\n    }));\n\n    const unsupported = _Tooltip || (_Tooltip = /*#__PURE__*/_jsx(Tooltip, {\n      placement: \"top\",\n      content: \"Prometheus does not allow editing rules, connect to either a Mimir or Cortex datasource to manage alerts via Grafana.\",\n      children: /*#__PURE__*/_jsx(\"div\", {\n        children: /*#__PURE__*/_jsx(Badge, {\n          color: \"red\",\n          icon: \"exclamation-triangle\",\n          text: \"Ruler API not supported\"\n        })\n      })\n    }));\n\n    const LOGOS = {\n      [PromApplication.Lotex]: '/public/app/plugins/datasource/prometheus/img/cortex_logo.svg',\n      [PromApplication.Mimir]: '/public/app/plugins/datasource/prometheus/img/mimir_logo.svg',\n      [PromApplication.Prometheus]: '/public/app/plugins/datasource/prometheus/img/prometheus_logo.svg'\n    };\n    const COLORS = {\n      [PromApplication.Lotex]: 'blue',\n      [PromApplication.Mimir]: 'orange',\n      [PromApplication.Prometheus]: 'red'\n    };\n    const AppDisplayNames = {\n      [PromApplication.Lotex]: 'Cortex',\n      [PromApplication.Mimir]: 'Mimir',\n      [PromApplication.Prometheus]: 'Prometheus'\n    }; // this will inform the user about what \"subtype\" the datasource is; Mimir, Cortex or vanilla Prometheus\n\n    const applicationSubType = /*#__PURE__*/_jsx(Badge, {\n      text: /*#__PURE__*/_jsxs(\"span\", {\n        children: [/*#__PURE__*/_jsx(\"img\", {\n          style: {\n            width: 14,\n            height: 14,\n            verticalAlign: 'text-bottom'\n          },\n          src: LOGOS[(_buildInfo$applicatio = buildInfo.application) !== null && _buildInfo$applicatio !== void 0 ? _buildInfo$applicatio : PromApplication.Prometheus]\n        }), ' ', buildInfo.application ? AppDisplayNames[buildInfo.application] : 'Unknown']\n      }),\n      color: COLORS[(_buildInfo$applicatio2 = buildInfo.application) !== null && _buildInfo$applicatio2 !== void 0 ? _buildInfo$applicatio2 : PromApplication.Prometheus]\n    });\n\n    return /*#__PURE__*/_jsxs(\"div\", {\n      style: {\n        display: 'grid',\n        gridTemplateColumns: 'max-content max-content',\n        rowGap: '0.5rem',\n        columnGap: '2rem',\n        marginTop: '1rem'\n      },\n      children: [_div || (_div = /*#__PURE__*/_jsx(\"div\", {\n        children: \"Type\"\n      })), /*#__PURE__*/_jsx(\"div\", {\n        children: applicationSubType\n      }), /*#__PURE__*/_jsxs(_Fragment, {\n        children: [_div2 || (_div2 = /*#__PURE__*/_jsx(\"div\", {\n          children: \"Ruler API\"\n        })), buildInfo.application === PromApplication.Prometheus && /*#__PURE__*/_jsx(\"div\", {\n          children: unsupported\n        }), buildInfo.application !== PromApplication.Prometheus && /*#__PURE__*/_jsx(\"div\", {\n          children: buildInfo.features.rulerApiEnabled ? enabled : disabled\n        })]\n      })]\n    });\n  }\n\n  async testDatasource() {\n    const now = new Date().getTime();\n    const request = {\n      targets: [{\n        refId: 'test',\n        expr: '1+1',\n        instant: true\n      }],\n      requestId: `${this.id}-health`,\n      scopedVars: {},\n      dashboardId: 0,\n      panelId: 0,\n      interval: '1m',\n      intervalMs: 60000,\n      maxDataPoints: 1,\n      range: {\n        from: dateTime(now - 1000),\n        to: dateTime(now)\n      }\n    };\n    const buildInfo = await this.getBuildInfo();\n    return lastValueFrom(this.query(request)).then(res => {\n      if (!res || !res.data || res.state !== LoadingState.Done) {\n        var _res$error;\n\n        return {\n          status: 'error',\n          message: `Error reading Prometheus: ${res === null || res === void 0 ? void 0 : (_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message}`\n        };\n      } else {\n        return {\n          status: 'success',\n          message: 'Data source is working',\n          details: buildInfo && {\n            verboseMessage: this.getBuildInfoMessage(buildInfo)\n          }\n        };\n      }\n    }).catch(err => {\n      console.error('Prometheus Error', err);\n      return {\n        status: 'error',\n        message: err.message\n      };\n    });\n  }\n\n  interpolateVariablesInQueries(queries, scopedVars) {\n    let expandedQueries = queries;\n\n    if (queries && queries.length) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = Object.assign({}, query, {\n          datasource: this.getRef(),\n          expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n          interval: this.templateSrv.replace(query.interval, scopedVars)\n        });\n        return expandedQuery;\n      });\n    }\n\n    return expandedQueries;\n  }\n\n  getQueryHints(query, result) {\n    var _query$expr;\n\n    return getQueryHints((_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : '', result, this);\n  }\n\n  getInitHints() {\n    return getInitHints(this);\n  }\n\n  async loadRules() {\n    try {\n      var _res$data, _res$data$data;\n\n      const res = await this.metadataRequest('/api/v1/rules');\n      const groups = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : (_res$data$data = _res$data.data) === null || _res$data$data === void 0 ? void 0 : _res$data$data.groups;\n\n      if (groups) {\n        this.ruleMappings = extractRuleMappingFromGroups(groups);\n      }\n    } catch (e) {\n      console.log('Rules API is experimental. Ignore next error.');\n      console.error(e);\n    }\n  }\n\n  async areExemplarsAvailable() {\n    try {\n      const res = await this.getResource('/api/v1/query_exemplars', {\n        query: 'test',\n        start: dateTime().subtract(30, 'minutes').valueOf(),\n        end: dateTime().valueOf()\n      });\n\n      if (res.data.status === 'success') {\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  modifyQuery(query, action) {\n    var _query$expr2;\n\n    let expression = (_query$expr2 = query.expr) !== null && _query$expr2 !== void 0 ? _query$expr2 : '';\n\n    switch (action.type) {\n      case 'ADD_FILTER':\n        {\n          expression = addLabelToQuery(expression, action.key, action.value);\n          break;\n        }\n\n      case 'ADD_FILTER_OUT':\n        {\n          expression = addLabelToQuery(expression, action.key, action.value, '!=');\n          break;\n        }\n\n      case 'ADD_HISTOGRAM_QUANTILE':\n        {\n          expression = `histogram_quantile(0.95, sum(rate(${expression}[$__rate_interval])) by (le))`;\n          break;\n        }\n\n      case 'ADD_RATE':\n        {\n          expression = `rate(${expression}[$__rate_interval])`;\n          break;\n        }\n\n      case 'ADD_SUM':\n        {\n          expression = `sum(${expression.trim()}) by ($1)`;\n          break;\n        }\n\n      case 'EXPAND_RULES':\n        {\n          if (action.mapping) {\n            expression = expandRecordingRules(expression, action.mapping);\n          }\n\n          break;\n        }\n\n      default:\n        break;\n    }\n\n    return Object.assign({}, query, {\n      expr: expression\n    });\n  }\n\n  getPrometheusTime(date, roundUp) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp);\n    }\n\n    return Math.ceil(date.valueOf() / 1000);\n  }\n\n  getTimeRangeParams() {\n    const range = this.timeSrv.timeRange();\n    return {\n      start: this.getPrometheusTime(range.from, false).toString(),\n      end: this.getPrometheusTime(range.to, true).toString()\n    };\n  }\n\n  getOriginalMetricName(labelData) {\n    return getOriginalMetricName(labelData);\n  }\n\n  enhanceExprWithAdHocFilters(expr) {\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    const finalQuery = adhocFilters.reduce((acc, filter) => {\n      const {\n        key,\n        operator\n      } = filter;\n      let {\n        value\n      } = filter;\n\n      if (operator === '=~' || operator === '!~') {\n        value = prometheusRegularEscape(value);\n      }\n\n      return addLabelToQuery(acc, key, value, operator);\n    }, expr);\n    return finalQuery;\n  } // Used when running queries trough backend\n\n\n  filterQuery(query) {\n    if (query.hide || !query.expr) {\n      return false;\n    }\n\n    return true;\n  } // Used when running queries trough backend\n\n\n  applyTemplateVariables(target, scopedVars) {\n    const variables = cloneDeep(scopedVars); // We want to interpolate these variables on backend\n\n    delete variables.__interval;\n    delete variables.__interval_ms; //Add ad hoc filters\n\n    const expr = this.enhanceExprWithAdHocFilters(target.expr);\n    return Object.assign({}, target, {\n      legendFormat: this.templateSrv.replace(target.legendFormat, variables),\n      expr: this.templateSrv.replace(expr, variables, this.interpolateQueryExpr),\n      interval: this.templateSrv.replace(target.interval, variables)\n    });\n  }\n\n  getVariables() {\n    return this.templateSrv.getVariables().map(v => `$${v.name}`);\n  }\n\n  interpolateString(string) {\n    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);\n  }\n\n}\n/**\n * Align query range to step.\n * Rounds start and end down to a multiple of step.\n * @param start Timestamp marking the beginning of the range.\n * @param end Timestamp marking the end of the range.\n * @param step Interval to align start and end with.\n * @param utcOffsetSec Number of seconds current timezone is offset from UTC\n */\n\nexport function alignRange(start, end, step, utcOffsetSec) {\n  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;\n  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;\n  return {\n    end: alignedEnd,\n    start: alignedStart\n  };\n}\nexport function extractRuleMappingFromGroups(groups) {\n  return groups.reduce((mapping, group) => group.rules.filter(rule => rule.type === 'recording').reduce((acc, rule) => Object.assign({}, acc, {\n    [rule.name]: rule.query\n  }), mapping), {});\n} // NOTE: these two functions are very similar to the escapeLabelValueIn* functions\n// in language_utils.ts, but they are not exactly the same algorithm, and we found\n// no way to reuse one in the another or vice versa.\n\nexport function prometheusRegularEscape(value) {\n  return typeof value === 'string' ? value.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\\\\\'\") : value;\n}\nexport function prometheusSpecialRegexEscape(value) {\n  return typeof value === 'string' ? value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]\\'+?.()|]/g, '\\\\\\\\$&') : value;\n}","map":{"version":3,"names":["cloneDeep","defaults","LRU","React","forkJoin","lastValueFrom","merge","of","pipe","throwError","catchError","filter","map","tap","CoreApp","dateMath","LoadingState","rangeUtil","dateTime","getBackendSrv","DataSourceWithBackend","toDataQueryResponse","isFetchError","Badge","Tooltip","safeStringifyValue","discoverDataSourceFeatures","getTimeSrv","getTemplateSrv","PromApplication","addLabelToQuery","AnnotationQueryEditor","PrometheusLanguageProvider","expandRecordingRules","renderLegendFormat","PrometheusMetricFindQuery","getInitHints","getQueryHints","getOriginalMetricName","transform","transformV2","PromQueryType","PrometheusVariableSupport","ANNOTATION_QUERY_STEP_DEFAULT","GET_AND_POST_METADATA_ENDPOINTS","PrometheusDatasource","constructor","instanceSettings","templateSrv","timeSrv","languageProvider","max","loadRules","exemplarsAvailable","areExemplarsAvailable","options","start","end","queries","activeTargets","clonedTargets","targets","target","expr","hide","requestId","panelId","refId","metricName","histogramMetrics","find","m","includes","app","Explore","range","instant","instantTarget","format","valueWithRefId","maxDataPoints","rangeTarget","exemplar","some","activeTarget","exemplarTarget","push","createQuery","err","error","message","statusText","data","status","frames","length","annotation","tagKeys","titleFormat","textFormat","step","intervalToSeconds","tagKeysArray","split","eventList","frame","timeField","fields","valueField","labels","tags","Object","keys","label","timeValueTuple","idx","values","toArray","forEach","value","timeStampValue","valueValue","time","get","useValueForTime","Math","floor","parseFloat","activeValues","activeValuesTimestamps","latestEvent","timestamp","timeEnd","title","text","type","subType","Prometheus","rulerEnabled","editorSrc","id","url","access","basicAuth","withCredentials","interval","jsonData","timeInterval","queryTimeout","httpMethod","directUrl","exemplarTraceIdDestinations","ruleMappings","lookupsDisabled","disableMetricsLookup","customQueryParameters","URLSearchParams","variables","annotations","QueryEditor","getQueryDisplayText","query","_addTracingHeaders","httpOptions","headers","proxyMode","match","dashboardId","_request","overrides","key","queryUrl","startsWith","method","search","entries","k","v","encodeURIComponent","join","Authorization","fetch","importFromAbstractQueries","abstractQueries","abstractQuery","importFromAbstractQuery","exportToAbstractQueries","exportToAbstractQuery","metadataRequest","params","endpoint","hideFromInspector","showErrorAlert","console","warn","interpolateQueryExpr","variable","multi","includeAll","prometheusRegularEscape","prometheusSpecialRegexEscape","escapedValues","val","targetContainsTemplate","containsTemplate","shouldRunExemplarQuery","request","currentTargetIdx","findIndex","t","slice","processTargetV2","processedTarget","queryType","timeSeriesQuery","utcOffsetSec","timeRange","to","utcOffset","response","getPrometheusTime","from","prepareTargets","state","Done","exploreQuery","panelsQuery","scopedVars","runningQueriesCount","subQueries","index","filterAndMapResponse","cancelled","responseListLength","Loading","runQuery","observables","results","reduce","result","current","performInstantQuery","getExemplars","performTimeSeriesQuery","hinting","ceil","minInterval","replace","scrapeInterval","intervalFactor","adjustedInterval","adjustInterval","getRangeScopedVars","getRateIntervalScopedVariable","assign","__interval","__interval_ms","enhanceExprWithAdHocFilters","adjusted","alignRange","rateInterval","__rate_interval","safeInterval","handleErrors","metricFindQuery","Promise","resolve","intervalToMs","interpolated","process","msRange","diff","sRange","round","__range_ms","__range_s","__range","annotationQuery","queryModel","datasource","getRef","toString","applyTemplateVariables","name","rsp","processAnnotationResponse","getSubtitle","buildInfo","getBuildInfo","getBuildInfoMessage","getTagKeys","series","seriesLabels","all","fetchSeriesLabels","concat","uniqueLabels","Set","getTagValues","undefined","enabled","disabled","unsupported","LOGOS","Lotex","Mimir","COLORS","AppDisplayNames","applicationSubType","width","height","verticalAlign","application","display","gridTemplateColumns","rowGap","columnGap","marginTop","features","rulerApiEnabled","testDatasource","now","Date","getTime","intervalMs","then","res","details","verboseMessage","catch","interpolateVariablesInQueries","expandedQueries","expandedQuery","groups","extractRuleMappingFromGroups","e","log","getResource","subtract","valueOf","modifyQuery","action","expression","trim","mapping","date","roundUp","parse","getTimeRangeParams","labelData","adhocFilters","getAdhocFilters","finalQuery","acc","operator","filterQuery","legendFormat","getVariables","interpolateString","string","alignedEnd","alignedStart","group","rules","rule"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/datasource.tsx"],"sourcesContent":["import { cloneDeep, defaults } from 'lodash';\nimport LRU from 'lru-cache';\nimport React from 'react';\nimport { forkJoin, lastValueFrom, merge, Observable, of, OperatorFunction, pipe, throwError } from 'rxjs';\nimport { catchError, filter, map, tap } from 'rxjs/operators';\n\nimport {\n  AnnotationEvent,\n  CoreApp,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n  DataSourceWithQueryExportSupport,\n  DataSourceWithQueryImportSupport,\n  dateMath,\n  DateTime,\n  AbstractQuery,\n  LoadingState,\n  rangeUtil,\n  ScopedVars,\n  TimeRange,\n  DataFrame,\n  dateTime,\n} from '@grafana/data';\nimport {\n  BackendSrvRequest,\n  FetchError,\n  FetchResponse,\n  getBackendSrv,\n  DataSourceWithBackend,\n  BackendDataSourceResponse,\n  toDataQueryResponse,\n  isFetchError,\n} from '@grafana/runtime';\nimport { Badge, BadgeColor, Tooltip } from '@grafana/ui';\nimport { safeStringifyValue } from 'app/core/utils/explore';\nimport { discoverDataSourceFeatures } from 'app/features/alerting/unified/api/buildInfo';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { PromApplication, PromApiFeatures } from 'app/types/unified-alerting-dto';\n\nimport { addLabelToQuery } from './add_label_to_query';\nimport { AnnotationQueryEditor } from './components/AnnotationQueryEditor';\nimport PrometheusLanguageProvider from './language_provider';\nimport { expandRecordingRules } from './language_utils';\nimport { renderLegendFormat } from './legend';\nimport PrometheusMetricFindQuery from './metric_find_query';\nimport { getInitHints, getQueryHints } from './query_hints';\nimport { getOriginalMetricName, transform, transformV2 } from './result_transformer';\nimport {\n  ExemplarTraceIdDestination,\n  PromDataErrorResponse,\n  PromDataSuccessResponse,\n  PromExemplarData,\n  PromMatrixData,\n  PromOptions,\n  PromQuery,\n  PromQueryRequest,\n  PromQueryType,\n  PromScalarData,\n  PromVectorData,\n} from './types';\nimport { PrometheusVariableSupport } from './variables';\n\nconst ANNOTATION_QUERY_STEP_DEFAULT = '60s';\nconst GET_AND_POST_METADATA_ENDPOINTS = ['api/v1/query', 'api/v1/query_range', 'api/v1/series', 'api/v1/labels'];\n\nexport class PrometheusDatasource\n  extends DataSourceWithBackend<PromQuery, PromOptions>\n  implements DataSourceWithQueryImportSupport<PromQuery>, DataSourceWithQueryExportSupport<PromQuery>\n{\n  type: string;\n  editorSrc: string;\n  ruleMappings: { [index: string]: string };\n  url: string;\n  id: number;\n  directUrl: string;\n  access: 'direct' | 'proxy';\n  basicAuth: any;\n  withCredentials: any;\n  metricsNameCache = new LRU<string, string[]>({ max: 10 });\n  interval: string;\n  queryTimeout: string | undefined;\n  httpMethod: string;\n  languageProvider: PrometheusLanguageProvider;\n  exemplarTraceIdDestinations: ExemplarTraceIdDestination[] | undefined;\n  lookupsDisabled: boolean;\n  customQueryParameters: any;\n  exemplarsAvailable: boolean;\n  subType: PromApplication;\n  rulerEnabled: boolean;\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<PromOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv(),\n    languageProvider?: PrometheusLanguageProvider\n  ) {\n    super(instanceSettings);\n\n    this.type = 'prometheus';\n    this.subType = PromApplication.Prometheus;\n    this.rulerEnabled = false;\n    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';\n    this.id = instanceSettings.id;\n    this.url = instanceSettings.url!;\n    this.access = instanceSettings.access;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n    this.queryTimeout = instanceSettings.jsonData.queryTimeout;\n    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n    // `directUrl` is never undefined, we set it at https://github.com/grafana/grafana/blob/main/pkg/api/frontendsettings.go#L108\n    // here we \"fall back\" to this.url to make typescript happy, but it should never happen\n    this.directUrl = instanceSettings.jsonData.directUrl ?? this.url;\n    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n    this.ruleMappings = {};\n    this.languageProvider = languageProvider ?? new PrometheusLanguageProvider(this);\n    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n    this.variables = new PrometheusVariableSupport(this, this.templateSrv, this.timeSrv);\n    this.exemplarsAvailable = true;\n\n    // This needs to be here and cannot be static because of how annotations typing affects casting of data source\n    // objects to DataSourceApi types.\n    // We don't use the default processing for prometheus.\n    // See standardAnnotationSupport.ts/[shouldUseMappingUI|shouldUseLegacyRunner]\n    this.annotations = {\n      QueryEditor: AnnotationQueryEditor,\n    };\n  }\n\n  init = async () => {\n    this.loadRules();\n    this.exemplarsAvailable = await this.areExemplarsAvailable();\n  };\n\n  getQueryDisplayText(query: PromQuery) {\n    return query.expr;\n  }\n\n  _addTracingHeaders(httpOptions: PromQueryRequest, options: DataQueryRequest<PromQuery>) {\n    httpOptions.headers = {};\n    const proxyMode = !this.url.match(/^http/);\n    if (proxyMode) {\n      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\n      httpOptions.headers['X-Panel-Id'] = options.panelId;\n    }\n  }\n\n  /**\n   * Any request done from this data source should go through here as it contains some common processing for the\n   * request. Any processing done here needs to be also copied on the backend as this goes through data source proxy\n   * but not through the same code as alerting.\n   */\n  _request<T = any>(\n    url: string,\n    data: Record<string, string> | null,\n    overrides: Partial<BackendSrvRequest> = {}\n  ): Observable<FetchResponse<T>> {\n    data = data || {};\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    let queryUrl = this.url + url;\n    if (url.startsWith(`/api/datasources/${this.id}`)) {\n      // This url is meant to be a replacement for the whole URL. Replace the entire URL\n      queryUrl = url;\n    }\n\n    const options: BackendSrvRequest = defaults(overrides, {\n      url: queryUrl,\n      method: this.httpMethod,\n      headers: {},\n    });\n\n    if (options.method === 'GET') {\n      if (data && Object.keys(data).length) {\n        options.url =\n          options.url +\n          (options.url.search(/\\?/) >= 0 ? '&' : '?') +\n          Object.entries(data)\n            .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n            .join('&');\n      }\n    } else {\n      options.headers!['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.data = data;\n    }\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n\n    if (this.basicAuth) {\n      options.headers!.Authorization = this.basicAuth;\n    }\n\n    return getBackendSrv().fetch<T>(options);\n  }\n\n  async importFromAbstractQueries(abstractQueries: AbstractQuery[]): Promise<PromQuery[]> {\n    return abstractQueries.map((abstractQuery) => this.languageProvider.importFromAbstractQuery(abstractQuery));\n  }\n\n  async exportToAbstractQueries(queries: PromQuery[]): Promise<AbstractQuery[]> {\n    return queries.map((query) => this.languageProvider.exportToAbstractQuery(query));\n  }\n\n  // Use this for tab completion features, wont publish response to other components\n  async metadataRequest<T = any>(url: string, params = {}) {\n    // If URL includes endpoint that supports POST and GET method, try to use configured method. This might fail as POST is supported only in v2.10+.\n    if (GET_AND_POST_METADATA_ENDPOINTS.some((endpoint) => url.includes(endpoint))) {\n      try {\n        return await lastValueFrom(\n          this._request<T>(`/api/datasources/${this.id}/resources${url}`, params, {\n            method: this.httpMethod,\n            hideFromInspector: true,\n            showErrorAlert: false,\n          })\n        );\n      } catch (err) {\n        // If status code of error is Method Not Allowed (405) and HTTP method is POST, retry with GET\n        if (this.httpMethod === 'POST' && isFetchError(err) && (err.status === 405 || err.status === 400)) {\n          console.warn(`Couldn't use configured POST HTTP method for this request. Trying to use GET method instead.`);\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    return await lastValueFrom(\n      this._request<T>(`/api/datasources/${this.id}/resources${url}`, params, {\n        method: 'GET',\n        hideFromInspector: true,\n      })\n    ); // toPromise until we change getTagValues, getTagKeys to Observable\n  }\n\n  interpolateQueryExpr(value: string | string[] = [], variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return prometheusRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return prometheusSpecialRegexEscape(value);\n    }\n\n    const escapedValues = value.map((val) => prometheusSpecialRegexEscape(val));\n\n    if (escapedValues.length === 1) {\n      return escapedValues[0];\n    }\n\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  targetContainsTemplate(target: PromQuery) {\n    return this.templateSrv.containsTemplate(target.expr);\n  }\n\n  prepareTargets = (options: DataQueryRequest<PromQuery>, start: number, end: number) => {\n    const queries: PromQueryRequest[] = [];\n    const activeTargets: PromQuery[] = [];\n    const clonedTargets = cloneDeep(options.targets);\n\n    for (const target of clonedTargets) {\n      if (!target.expr || target.hide) {\n        continue;\n      }\n\n      target.requestId = options.panelId + target.refId;\n      const metricName = this.languageProvider.histogramMetrics.find((m) => target.expr.includes(m));\n\n      // In Explore, we run both (instant and range) queries if both are true (selected) or both are undefined (legacy Explore queries)\n      if (options.app === CoreApp.Explore && target.range === target.instant) {\n        // Create instant target\n        const instantTarget: any = cloneDeep(target);\n        instantTarget.format = 'table';\n        instantTarget.instant = true;\n        instantTarget.range = false;\n        instantTarget.valueWithRefId = true;\n        delete instantTarget.maxDataPoints;\n        instantTarget.requestId += '_instant';\n\n        // Create range target\n        const rangeTarget: any = cloneDeep(target);\n        rangeTarget.format = 'time_series';\n        rangeTarget.instant = false;\n        instantTarget.range = true;\n\n        // Create exemplar query\n        if (target.exemplar) {\n          // Only create exemplar target for different metric names\n          if (\n            !metricName ||\n            (metricName && !activeTargets.some((activeTarget) => activeTarget.expr.includes(metricName)))\n          ) {\n            const exemplarTarget = cloneDeep(target);\n            exemplarTarget.instant = false;\n            exemplarTarget.requestId += '_exemplar';\n            queries.push(this.createQuery(exemplarTarget, options, start, end));\n            activeTargets.push(exemplarTarget);\n          }\n          instantTarget.exemplar = false;\n          rangeTarget.exemplar = false;\n        }\n\n        // Add both targets to activeTargets and queries arrays\n        activeTargets.push(instantTarget, rangeTarget);\n        queries.push(\n          this.createQuery(instantTarget, options, start, end),\n          this.createQuery(rangeTarget, options, start, end)\n        );\n        // If running only instant query in Explore, format as table\n      } else if (target.instant && options.app === CoreApp.Explore) {\n        const instantTarget: any = cloneDeep(target);\n        instantTarget.format = 'table';\n        queries.push(this.createQuery(instantTarget, options, start, end));\n        activeTargets.push(instantTarget);\n      } else {\n        // It doesn't make sense to query for exemplars in dashboard if only instant is selected\n        if (target.exemplar && !target.instant) {\n          if (\n            !metricName ||\n            (metricName && !activeTargets.some((activeTarget) => activeTarget.expr.includes(metricName)))\n          ) {\n            const exemplarTarget = cloneDeep(target);\n            exemplarTarget.requestId += '_exemplar';\n            queries.push(this.createQuery(exemplarTarget, options, start, end));\n            activeTargets.push(exemplarTarget);\n          }\n          target.exemplar = false;\n        }\n        queries.push(this.createQuery(target, options, start, end));\n        activeTargets.push(target);\n      }\n    }\n\n    return {\n      queries,\n      activeTargets,\n    };\n  };\n\n  shouldRunExemplarQuery(target: PromQuery, request: DataQueryRequest<PromQuery>): boolean {\n    if (target.exemplar) {\n      // We check all already processed targets and only create exemplar target for not used metric names\n      const metricName = this.languageProvider.histogramMetrics.find((m) => target.expr.includes(m));\n      // Remove targets that weren't processed yet (in targets array they are after current target)\n      const currentTargetIdx = request.targets.findIndex((t) => t.refId === target.refId);\n      const targets = request.targets.slice(0, currentTargetIdx).filter((t) => !t.hide);\n\n      if (!metricName || (metricName && !targets.some((t) => t.expr.includes(metricName)))) {\n        return true;\n      }\n      return false;\n    }\n    return false;\n  }\n\n  processTargetV2(target: PromQuery, request: DataQueryRequest<PromQuery>) {\n    const processedTarget = {\n      ...target,\n      queryType: PromQueryType.timeSeriesQuery,\n      exemplar: this.shouldRunExemplarQuery(target, request),\n      requestId: request.panelId + target.refId,\n      // We need to pass utcOffsetSec to backend to calculate aligned range\n      utcOffsetSec: this.timeSrv.timeRange().to.utcOffset() * 60,\n    };\n    return processedTarget;\n  }\n\n  query(request: DataQueryRequest<PromQuery>): Observable<DataQueryResponse> {\n    if (this.access === 'proxy') {\n      const targets = request.targets.map((target) => this.processTargetV2(target, request));\n      return super\n        .query({ ...request, targets })\n        .pipe(\n          map((response) =>\n            transformV2(response, request, { exemplarTraceIdDestinations: this.exemplarTraceIdDestinations })\n          )\n        );\n      // Run queries trough browser/proxy\n    } else {\n      const start = this.getPrometheusTime(request.range.from, false);\n      const end = this.getPrometheusTime(request.range.to, true);\n      const { queries, activeTargets } = this.prepareTargets(request, start, end);\n\n      // No valid targets, return the empty result to save a round trip.\n      if (!queries || !queries.length) {\n        return of({\n          data: [],\n          state: LoadingState.Done,\n        });\n      }\n\n      if (request.app === CoreApp.Explore) {\n        return this.exploreQuery(queries, activeTargets, end);\n      }\n\n      return this.panelsQuery(queries, activeTargets, end, request.requestId, request.scopedVars);\n    }\n  }\n\n  private exploreQuery(queries: PromQueryRequest[], activeTargets: PromQuery[], end: number) {\n    let runningQueriesCount = queries.length;\n\n    const subQueries = queries.map((query, index) => {\n      const target = activeTargets[index];\n\n      const filterAndMapResponse = pipe(\n        // Decrease the counter here. We assume that each request returns only single value and then completes\n        // (should hold until there is some streaming requests involved).\n        tap(() => runningQueriesCount--),\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = transform(response, {\n            query,\n            target,\n            responseListLength: queries.length,\n            exemplarTraceIdDestinations: this.exemplarTraceIdDestinations,\n          });\n          return {\n            data,\n            key: query.requestId,\n            state: runningQueriesCount === 0 ? LoadingState.Done : LoadingState.Loading,\n          } as DataQueryResponse;\n        })\n      );\n\n      return this.runQuery(query, end, filterAndMapResponse);\n    });\n\n    return merge(...subQueries);\n  }\n\n  private panelsQuery(\n    queries: PromQueryRequest[],\n    activeTargets: PromQuery[],\n    end: number,\n    requestId: string,\n    scopedVars: ScopedVars\n  ) {\n    const observables = queries.map((query, index) => {\n      const target = activeTargets[index];\n\n      const filterAndMapResponse = pipe(\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = transform(response, {\n            query,\n            target,\n            responseListLength: queries.length,\n            scopedVars,\n            exemplarTraceIdDestinations: this.exemplarTraceIdDestinations,\n          });\n          return data;\n        })\n      );\n\n      return this.runQuery(query, end, filterAndMapResponse);\n    });\n\n    return forkJoin(observables).pipe(\n      map((results) => {\n        const data = results.reduce((result, current) => {\n          return [...result, ...current];\n        }, []);\n        return {\n          data,\n          key: requestId,\n          state: LoadingState.Done,\n        };\n      })\n    );\n  }\n\n  private runQuery<T>(query: PromQueryRequest, end: number, filter: OperatorFunction<any, T>): Observable<T> {\n    if (query.instant) {\n      return this.performInstantQuery(query, end).pipe(filter);\n    }\n\n    if (query.exemplar) {\n      return this.getExemplars(query).pipe(\n        catchError(() => {\n          return of({\n            data: [],\n            state: LoadingState.Done,\n          });\n        }),\n        filter\n      );\n    }\n\n    return this.performTimeSeriesQuery(query, query.start, query.end).pipe(filter);\n  }\n\n  createQuery(target: PromQuery, options: DataQueryRequest<PromQuery>, start: number, end: number) {\n    const query: PromQueryRequest = {\n      hinting: target.hinting,\n      instant: target.instant,\n      exemplar: target.exemplar,\n      step: 0,\n      expr: '',\n      requestId: target.requestId,\n      refId: target.refId,\n      start: 0,\n      end: 0,\n    };\n    const range = Math.ceil(end - start);\n\n    // options.interval is the dynamically calculated interval\n    let interval: number = rangeUtil.intervalToSeconds(options.interval);\n    // Minimum interval (\"Min step\"), if specified for the query, or same as interval otherwise.\n    const minInterval = rangeUtil.intervalToSeconds(\n      this.templateSrv.replace(target.interval || options.interval, options.scopedVars)\n    );\n    // Scrape interval as specified for the query (\"Min step\") or otherwise taken from the datasource.\n    // Min step field can have template variables in it, make sure to replace it.\n    const scrapeInterval = target.interval\n      ? rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval, options.scopedVars))\n      : rangeUtil.intervalToSeconds(this.interval);\n\n    const intervalFactor = target.intervalFactor || 1;\n    // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits\n    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);\n    let scopedVars = {\n      ...options.scopedVars,\n      ...this.getRangeScopedVars(options.range),\n      ...this.getRateIntervalScopedVariable(adjustedInterval, scrapeInterval),\n    };\n    // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars\n    if (interval !== adjustedInterval) {\n      interval = adjustedInterval;\n      scopedVars = Object.assign({}, options.scopedVars, {\n        __interval: { text: interval + 's', value: interval + 's' },\n        __interval_ms: { text: interval * 1000, value: interval * 1000 },\n        ...this.getRateIntervalScopedVariable(interval, scrapeInterval),\n        ...this.getRangeScopedVars(options.range),\n      });\n    }\n    query.step = interval;\n\n    let expr = target.expr;\n\n    // Apply adhoc filters\n    expr = this.enhanceExprWithAdHocFilters(expr);\n\n    // Only replace vars in expression after having (possibly) updated interval vars\n    query.expr = this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr);\n\n    // Align query interval with step to allow query caching and to ensure\n    // that about-same-time query results look the same.\n    const adjusted = alignRange(start, end, query.step, this.timeSrv.timeRange().to.utcOffset() * 60);\n    query.start = adjusted.start;\n    query.end = adjusted.end;\n    this._addTracingHeaders(query, options);\n\n    return query;\n  }\n\n  getRateIntervalScopedVariable(interval: number, scrapeInterval: number) {\n    // Fall back to the default scrape interval of 15s if scrapeInterval is 0 for some reason.\n    if (scrapeInterval === 0) {\n      scrapeInterval = 15;\n    }\n    const rateInterval = Math.max(interval + scrapeInterval, 4 * scrapeInterval);\n    return { __rate_interval: { text: rateInterval + 's', value: rateInterval + 's' } };\n  }\n\n  adjustInterval(interval: number, minInterval: number, range: number, intervalFactor: number) {\n    // Prometheus will drop queries that might return more than 11000 data points.\n    // Calculate a safe interval as an additional minimum to take into account.\n    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1\n    // If this is the case take the ceil of the value.\n    let safeInterval = range / 11000;\n    if (safeInterval > 1) {\n      safeInterval = Math.ceil(safeInterval);\n    }\n    return Math.max(interval * intervalFactor, minInterval, safeInterval);\n  }\n\n  performTimeSeriesQuery(query: PromQueryRequest, start: number, end: number) {\n    if (start > end) {\n      throw { message: 'Invalid time range' };\n    }\n\n    const url = '/api/v1/query_range';\n    const data: any = {\n      query: query.expr,\n      start,\n      end,\n      step: query.step,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    return this._request<PromDataSuccessResponse<PromMatrixData>>(url, data, {\n      requestId: query.requestId,\n      headers: query.headers,\n    }).pipe(\n      catchError((err: FetchError<PromDataErrorResponse<PromMatrixData>>) => {\n        if (err.cancelled) {\n          return of(err);\n        }\n\n        return throwError(this.handleErrors(err, query));\n      })\n    );\n  }\n\n  performInstantQuery(\n    query: PromQueryRequest,\n    time: number\n  ): Observable<FetchResponse<PromDataSuccessResponse<PromVectorData | PromScalarData>> | FetchError> {\n    const url = '/api/v1/query';\n    const data: any = {\n      query: query.expr,\n      time,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    return this._request<PromDataSuccessResponse<PromVectorData | PromScalarData>>(url, data, {\n      requestId: query.requestId,\n      headers: query.headers,\n    }).pipe(\n      catchError((err: FetchError<PromDataErrorResponse<PromVectorData | PromScalarData>>) => {\n        if (err.cancelled) {\n          return of(err);\n        }\n\n        return throwError(this.handleErrors(err, query));\n      })\n    );\n  }\n\n  handleErrors = (err: any, target: PromQuery) => {\n    const error: DataQueryError = {\n      message: (err && err.statusText) || 'Unknown error during query transaction. Please check JS console logs.',\n      refId: target.refId,\n    };\n\n    if (err.data) {\n      if (typeof err.data === 'string') {\n        error.message = err.data;\n      } else if (err.data.error) {\n        error.message = safeStringifyValue(err.data.error);\n      }\n    } else if (err.message) {\n      error.message = err.message;\n    } else if (typeof err === 'string') {\n      error.message = err;\n    }\n\n    error.status = err.status;\n    error.statusText = err.statusText;\n\n    return error;\n  };\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const scopedVars = {\n      __interval: { text: this.interval, value: this.interval },\n      __interval_ms: { text: rangeUtil.intervalToMs(this.interval), value: rangeUtil.intervalToMs(this.interval) },\n      ...this.getRangeScopedVars(this.timeSrv.timeRange()),\n    };\n    const interpolated = this.templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);\n    const metricFindQuery = new PrometheusMetricFindQuery(this, interpolated);\n    return metricFindQuery.process();\n  }\n\n  getRangeScopedVars(range: TimeRange = this.timeSrv.timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const annotation = options.annotation;\n    const { expr = '' } = annotation;\n\n    if (!expr) {\n      return Promise.resolve([]);\n    }\n\n    const step = options.annotation.step || ANNOTATION_QUERY_STEP_DEFAULT;\n    const queryModel = {\n      expr,\n      range: true,\n      instant: false,\n      exemplar: false,\n      interval: step,\n      queryType: PromQueryType.timeSeriesQuery,\n      refId: 'X',\n      datasource: this.getRef(),\n    };\n\n    return await lastValueFrom(\n      getBackendSrv()\n        .fetch<BackendDataSourceResponse>({\n          url: '/api/ds/query',\n          method: 'POST',\n          data: {\n            from: (this.getPrometheusTime(options.range.from, false) * 1000).toString(),\n            to: (this.getPrometheusTime(options.range.to, true) * 1000).toString(),\n            queries: [this.applyTemplateVariables(queryModel, {})],\n          },\n          requestId: `prom-query-${annotation.name}`,\n        })\n        .pipe(\n          map((rsp: FetchResponse<BackendDataSourceResponse>) => {\n            return this.processAnnotationResponse(options, rsp.data);\n          })\n        )\n    );\n  }\n\n  processAnnotationResponse = (options: any, data: BackendDataSourceResponse) => {\n    const frames: DataFrame[] = toDataQueryResponse({ data: data }).data;\n    if (!frames || !frames.length) {\n      return [];\n    }\n\n    const annotation = options.annotation;\n    const { tagKeys = '', titleFormat = '', textFormat = '' } = annotation;\n\n    const step = rangeUtil.intervalToSeconds(annotation.step || ANNOTATION_QUERY_STEP_DEFAULT) * 1000;\n    const tagKeysArray = tagKeys.split(',');\n\n    const eventList: AnnotationEvent[] = [];\n\n    for (const frame of frames) {\n      const timeField = frame.fields[0];\n      const valueField = frame.fields[1];\n      const labels = valueField?.labels || {};\n\n      const tags = Object.keys(labels)\n        .filter((label) => tagKeysArray.includes(label))\n        .map((label) => labels[label]);\n\n      const timeValueTuple: Array<[number, number]> = [];\n\n      let idx = 0;\n      valueField.values.toArray().forEach((value: string) => {\n        let timeStampValue: number;\n        let valueValue: number;\n        const time = timeField.values.get(idx);\n\n        // If we want to use value as a time, we use value as timeStampValue and valueValue will be 1\n        if (options.annotation.useValueForTime) {\n          timeStampValue = Math.floor(parseFloat(value));\n          valueValue = 1;\n        } else {\n          timeStampValue = Math.floor(parseFloat(time));\n          valueValue = parseFloat(value);\n        }\n\n        idx++;\n        timeValueTuple.push([timeStampValue, valueValue]);\n      });\n\n      const activeValues = timeValueTuple.filter((value) => value[1] >= 1);\n      const activeValuesTimestamps = activeValues.map((value) => value[0]);\n\n      // Instead of creating singular annotation for each active event we group events into region if they are less\n      // or equal to `step` apart.\n      let latestEvent: AnnotationEvent | null = null;\n\n      for (const timestamp of activeValuesTimestamps) {\n        // We already have event `open` and we have new event that is inside the `step` so we just update the end.\n        if (latestEvent && (latestEvent.timeEnd ?? 0) + step >= timestamp) {\n          latestEvent.timeEnd = timestamp;\n          continue;\n        }\n\n        // Event exists but new one is outside of the `step` so we add it to eventList.\n        if (latestEvent) {\n          eventList.push(latestEvent);\n        }\n\n        // We start a new region.\n        latestEvent = {\n          time: timestamp,\n          timeEnd: timestamp,\n          annotation,\n          title: renderLegendFormat(titleFormat, labels),\n          tags,\n          text: renderLegendFormat(textFormat, labels),\n        };\n      }\n\n      if (latestEvent) {\n        // Finish up last point if we have one\n        latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];\n        eventList.push(latestEvent);\n      }\n    }\n\n    return eventList;\n  };\n\n  getExemplars(query: PromQueryRequest) {\n    const url = '/api/v1/query_exemplars';\n    return this._request<PromDataSuccessResponse<PromExemplarData>>(\n      url,\n      { query: query.expr, start: query.start.toString(), end: query.end.toString() },\n      { requestId: query.requestId, headers: query.headers }\n    );\n  }\n\n  async getSubtitle(): Promise<JSX.Element | null> {\n    const buildInfo = await this.getBuildInfo();\n    return buildInfo ? this.getBuildInfoMessage(buildInfo) : null;\n  }\n\n  async getTagKeys(options?: any) {\n    if (options?.series) {\n      // Get tags for the provided series only\n      const seriesLabels: Array<Record<string, string[]>> = await Promise.all(\n        options.series.map((series: string) => this.languageProvider.fetchSeriesLabels(series))\n      );\n      // Combines tags from all options.series provided\n      let tags: string[] = [];\n      seriesLabels.map((value) => (tags = tags.concat(Object.keys(value))));\n      const uniqueLabels = [...new Set(tags)];\n      return uniqueLabels.map((value: any) => ({ text: value }));\n    } else {\n      // Get all tags\n      const result = await this.metadataRequest('/api/v1/labels');\n      return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n    }\n  }\n\n  async getTagValues(options: { key?: string } = {}) {\n    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n  }\n\n  async getBuildInfo() {\n    try {\n      const buildInfo = await discoverDataSourceFeatures({ url: this.url, name: this.name, type: 'prometheus' });\n      return buildInfo;\n    } catch (error) {\n      // We don't want to break the rest of functionality if build info does not work correctly\n      return undefined;\n    }\n  }\n\n  getBuildInfoMessage(buildInfo: PromApiFeatures) {\n    const enabled = <Badge color=\"green\" icon=\"check\" text=\"Ruler API enabled\" />;\n    const disabled = <Badge color=\"orange\" icon=\"exclamation-triangle\" text=\"Ruler API not enabled\" />;\n    const unsupported = (\n      <Tooltip\n        placement=\"top\"\n        content=\"Prometheus does not allow editing rules, connect to either a Mimir or Cortex datasource to manage alerts via Grafana.\"\n      >\n        <div>\n          <Badge color=\"red\" icon=\"exclamation-triangle\" text=\"Ruler API not supported\" />\n        </div>\n      </Tooltip>\n    );\n\n    const LOGOS = {\n      [PromApplication.Lotex]: '/public/app/plugins/datasource/prometheus/img/cortex_logo.svg',\n      [PromApplication.Mimir]: '/public/app/plugins/datasource/prometheus/img/mimir_logo.svg',\n      [PromApplication.Prometheus]: '/public/app/plugins/datasource/prometheus/img/prometheus_logo.svg',\n    };\n\n    const COLORS: Record<PromApplication, BadgeColor> = {\n      [PromApplication.Lotex]: 'blue',\n      [PromApplication.Mimir]: 'orange',\n      [PromApplication.Prometheus]: 'red',\n    };\n\n    const AppDisplayNames: Record<PromApplication, string> = {\n      [PromApplication.Lotex]: 'Cortex',\n      [PromApplication.Mimir]: 'Mimir',\n      [PromApplication.Prometheus]: 'Prometheus',\n    };\n\n    // this will inform the user about what \"subtype\" the datasource is; Mimir, Cortex or vanilla Prometheus\n    const applicationSubType = (\n      <Badge\n        text={\n          <span>\n            <img\n              style={{ width: 14, height: 14, verticalAlign: 'text-bottom' }}\n              src={LOGOS[buildInfo.application ?? PromApplication.Prometheus]}\n            />{' '}\n            {buildInfo.application ? AppDisplayNames[buildInfo.application] : 'Unknown'}\n          </span>\n        }\n        color={COLORS[buildInfo.application ?? PromApplication.Prometheus]}\n      />\n    );\n\n    return (\n      <div\n        style={{\n          display: 'grid',\n          gridTemplateColumns: 'max-content max-content',\n          rowGap: '0.5rem',\n          columnGap: '2rem',\n          marginTop: '1rem',\n        }}\n      >\n        <div>Type</div>\n        <div>{applicationSubType}</div>\n        <>\n          <div>Ruler API</div>\n          {/* Prometheus does not have a Ruler API – so show that it is not supported */}\n          {buildInfo.application === PromApplication.Prometheus && <div>{unsupported}</div>}\n          {buildInfo.application !== PromApplication.Prometheus && (\n            <div>{buildInfo.features.rulerApiEnabled ? enabled : disabled}</div>\n          )}\n        </>\n      </div>\n    );\n  }\n\n  async testDatasource() {\n    const now = new Date().getTime();\n    const request: DataQueryRequest<PromQuery> = {\n      targets: [{ refId: 'test', expr: '1+1', instant: true }],\n      requestId: `${this.id}-health`,\n      scopedVars: {},\n      dashboardId: 0,\n      panelId: 0,\n      interval: '1m',\n      intervalMs: 60000,\n      maxDataPoints: 1,\n      range: {\n        from: dateTime(now - 1000),\n        to: dateTime(now),\n      },\n    } as DataQueryRequest<PromQuery>;\n\n    const buildInfo = await this.getBuildInfo();\n\n    return lastValueFrom(this.query(request))\n      .then((res: DataQueryResponse) => {\n        if (!res || !res.data || res.state !== LoadingState.Done) {\n          return { status: 'error', message: `Error reading Prometheus: ${res?.error?.message}` };\n        } else {\n          return {\n            status: 'success',\n            message: 'Data source is working',\n            details: buildInfo && {\n              verboseMessage: this.getBuildInfoMessage(buildInfo),\n            },\n          };\n        }\n      })\n      .catch((err: any) => {\n        console.error('Prometheus Error', err);\n        return { status: 'error', message: err.message };\n      });\n  }\n\n  interpolateVariablesInQueries(queries: PromQuery[], scopedVars: ScopedVars): PromQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map((query) => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.getRef(),\n          expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n          interval: this.templateSrv.replace(query.interval, scopedVars),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  getQueryHints(query: PromQuery, result: any[]) {\n    return getQueryHints(query.expr ?? '', result, this);\n  }\n\n  getInitHints() {\n    return getInitHints(this);\n  }\n\n  async loadRules() {\n    try {\n      const res = await this.metadataRequest('/api/v1/rules');\n      const groups = res.data?.data?.groups;\n\n      if (groups) {\n        this.ruleMappings = extractRuleMappingFromGroups(groups);\n      }\n    } catch (e) {\n      console.log('Rules API is experimental. Ignore next error.');\n      console.error(e);\n    }\n  }\n\n  async areExemplarsAvailable() {\n    try {\n      const res = await this.getResource('/api/v1/query_exemplars', {\n        query: 'test',\n        start: dateTime().subtract(30, 'minutes').valueOf(),\n        end: dateTime().valueOf(),\n      });\n      if (res.data.status === 'success') {\n        return true;\n      }\n      return false;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  modifyQuery(query: PromQuery, action: any): PromQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = addLabelToQuery(expression, action.key, action.value);\n        break;\n      }\n      case 'ADD_FILTER_OUT': {\n        expression = addLabelToQuery(expression, action.key, action.value, '!=');\n        break;\n      }\n      case 'ADD_HISTOGRAM_QUANTILE': {\n        expression = `histogram_quantile(0.95, sum(rate(${expression}[$__rate_interval])) by (le))`;\n        break;\n      }\n      case 'ADD_RATE': {\n        expression = `rate(${expression}[$__rate_interval])`;\n        break;\n      }\n      case 'ADD_SUM': {\n        expression = `sum(${expression.trim()}) by ($1)`;\n        break;\n      }\n      case 'EXPAND_RULES': {\n        if (action.mapping) {\n          expression = expandRecordingRules(expression, action.mapping);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getPrometheusTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp)!;\n    }\n\n    return Math.ceil(date.valueOf() / 1000);\n  }\n\n  getTimeRangeParams(): { start: string; end: string } {\n    const range = this.timeSrv.timeRange();\n    return {\n      start: this.getPrometheusTime(range.from, false).toString(),\n      end: this.getPrometheusTime(range.to, true).toString(),\n    };\n  }\n\n  getOriginalMetricName(labelData: { [key: string]: string }) {\n    return getOriginalMetricName(labelData);\n  }\n\n  enhanceExprWithAdHocFilters(expr: string) {\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n\n    const finalQuery = adhocFilters.reduce((acc: string, filter: { key?: any; operator?: any; value?: any }) => {\n      const { key, operator } = filter;\n      let { value } = filter;\n      if (operator === '=~' || operator === '!~') {\n        value = prometheusRegularEscape(value);\n      }\n      return addLabelToQuery(acc, key, value, operator);\n    }, expr);\n    return finalQuery;\n  }\n\n  // Used when running queries trough backend\n  filterQuery(query: PromQuery): boolean {\n    if (query.hide || !query.expr) {\n      return false;\n    }\n    return true;\n  }\n\n  // Used when running queries trough backend\n  applyTemplateVariables(target: PromQuery, scopedVars: ScopedVars): Record<string, any> {\n    const variables = cloneDeep(scopedVars);\n\n    // We want to interpolate these variables on backend\n    delete variables.__interval;\n    delete variables.__interval_ms;\n\n    //Add ad hoc filters\n    const expr = this.enhanceExprWithAdHocFilters(target.expr);\n\n    return {\n      ...target,\n      legendFormat: this.templateSrv.replace(target.legendFormat, variables),\n      expr: this.templateSrv.replace(expr, variables, this.interpolateQueryExpr),\n      interval: this.templateSrv.replace(target.interval, variables),\n    };\n  }\n\n  getVariables(): string[] {\n    return this.templateSrv.getVariables().map((v) => `$${v.name}`);\n  }\n\n  interpolateString(string: string) {\n    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);\n  }\n}\n\n/**\n * Align query range to step.\n * Rounds start and end down to a multiple of step.\n * @param start Timestamp marking the beginning of the range.\n * @param end Timestamp marking the end of the range.\n * @param step Interval to align start and end with.\n * @param utcOffsetSec Number of seconds current timezone is offset from UTC\n */\nexport function alignRange(\n  start: number,\n  end: number,\n  step: number,\n  utcOffsetSec: number\n): { end: number; start: number } {\n  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;\n  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;\n  return {\n    end: alignedEnd,\n    start: alignedStart,\n  };\n}\n\nexport function extractRuleMappingFromGroups(groups: any[]) {\n  return groups.reduce(\n    (mapping, group) =>\n      group.rules\n        .filter((rule: any) => rule.type === 'recording')\n        .reduce(\n          (acc: { [key: string]: string }, rule: any) => ({\n            ...acc,\n            [rule.name]: rule.query,\n          }),\n          mapping\n        ),\n    {}\n  );\n}\n\n// NOTE: these two functions are very similar to the escapeLabelValueIn* functions\n// in language_utils.ts, but they are not exactly the same algorithm, and we found\n// no way to reuse one in the another or vice versa.\nexport function prometheusRegularEscape(value: any) {\n  return typeof value === 'string' ? value.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\\\\\'\") : value;\n}\n\nexport function prometheusSpecialRegexEscape(value: any) {\n  return typeof value === 'string' ? value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]\\'+?.()|]/g, '\\\\\\\\$&') : value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}