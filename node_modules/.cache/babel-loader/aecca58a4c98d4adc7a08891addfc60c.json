{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { getFieldDisplayName } from '../..';\nimport { FieldType } from '../../types';\nimport { ArrayVector } from '../../vector';\nimport { DataTransformerID } from './ids';\nexport let LabelsToFieldsMode;\n\n(function (LabelsToFieldsMode) {\n  LabelsToFieldsMode[\"Columns\"] = \"columns\";\n  LabelsToFieldsMode[\"Rows\"] = \"rows\";\n})(LabelsToFieldsMode || (LabelsToFieldsMode = {}));\n\nexport const labelsToFieldsTransformer = {\n  id: DataTransformerID.labelsToFields,\n  name: 'Labels to fields',\n  description: 'Extract time series labels to fields (columns or rows)',\n  defaultOptions: {},\n  operator: options => source => source.pipe(map(data => labelsToFieldsTransformer.transformer(options)(data))),\n  transformer: options => data => {\n    var _options$keepLabels;\n\n    // Show each label as a field row\n    if (options.mode === LabelsToFieldsMode.Rows) {\n      return convertLabelsToRows(data, options.keepLabels);\n    }\n\n    const result = [];\n    const keepLabels = (_options$keepLabels = options.keepLabels) !== null && _options$keepLabels !== void 0 && _options$keepLabels.length ? new Set(options.keepLabels) : undefined;\n\n    for (const frame of data) {\n      const newFields = [];\n      const uniqueLabels = {};\n\n      for (const field of frame.fields) {\n        if (!field.labels) {\n          newFields.push(field);\n          continue;\n        }\n\n        const sansLabels = Object.assign({}, field, {\n          config: Object.assign({}, field.config, {\n            // we need to clear thes for this transform as these can contain label names that we no longer want\n            displayName: undefined,\n            displayNameFromDS: undefined\n          }),\n          labels: undefined\n        });\n        newFields.push(sansLabels);\n\n        for (const labelName of Object.keys(field.labels)) {\n          var _uniqueLabels$labelNa;\n\n          if (keepLabels && !keepLabels.has(labelName)) {\n            continue;\n          } // if we should use this label as the value field name store it and skip adding this as a separate field\n\n\n          if (options.valueLabel === labelName) {\n            sansLabels.name = field.labels[labelName];\n            continue;\n          }\n\n          const uniqueValues = (_uniqueLabels$labelNa = uniqueLabels[labelName]) !== null && _uniqueLabels$labelNa !== void 0 ? _uniqueLabels$labelNa : uniqueLabels[labelName] = new Set(); // (Safari 13.1 lacks ??= support)\n\n          uniqueValues.add(field.labels[labelName]);\n        }\n      }\n\n      for (const name in uniqueLabels) {\n        for (const value of uniqueLabels[name]) {\n          const values = new Array(frame.length).fill(value);\n          newFields.push({\n            name: name,\n            type: FieldType.string,\n            values: new ArrayVector(values),\n            config: {}\n          });\n        }\n      }\n\n      result.push({\n        fields: newFields,\n        length: frame.length\n      });\n    }\n\n    return result;\n  }\n};\n\nfunction convertLabelsToRows(data, keepLabels) {\n  const result = [];\n\n  for (const frame of data) {\n    for (const field of frame.fields) {\n      if (field.labels) {\n        const keys = [];\n        const vals = [];\n\n        if (keepLabels) {\n          for (const key of keepLabels) {\n            keys.push(key);\n            vals.push(field.labels[key]);\n          }\n        } else {\n          for (const [key, val] of Object.entries(field.labels)) {\n            keys.push(key);\n            vals.push(val);\n          }\n        }\n\n        if (vals.length) {\n          result.push(Object.assign({}, frame, {\n            name: getFieldDisplayName(field, frame, data),\n            fields: [{\n              name: 'label',\n              type: FieldType.string,\n              config: {},\n              values: new ArrayVector(keys)\n            }, {\n              name: 'value',\n              type: FieldType.string,\n              config: {},\n              values: new ArrayVector(vals)\n            }],\n            length: vals.length\n          }));\n        }\n      }\n    }\n  }\n\n  return result;\n}","map":{"version":3,"names":["map","getFieldDisplayName","FieldType","ArrayVector","DataTransformerID","LabelsToFieldsMode","labelsToFieldsTransformer","id","labelsToFields","name","description","defaultOptions","operator","options","source","pipe","data","transformer","mode","Rows","convertLabelsToRows","keepLabels","result","length","Set","undefined","frame","newFields","uniqueLabels","field","fields","labels","push","sansLabels","config","displayName","displayNameFromDS","labelName","Object","keys","has","valueLabel","uniqueValues","add","value","values","Array","fill","type","string","vals","key","val","entries"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/labelsToFields.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { getFieldDisplayName } from '../..';\nimport { DataFrame, Field, FieldType, SynchronousDataTransformerInfo } from '../../types';\nimport { ArrayVector } from '../../vector';\n\nimport { DataTransformerID } from './ids';\n\nexport enum LabelsToFieldsMode {\n  Columns = 'columns', // default mode\n  Rows = 'rows',\n}\nexport interface LabelsToFieldsOptions {\n  mode?: LabelsToFieldsMode;\n\n  /** When empty, this will keep all labels, otherise it will keep only labels matching the value */\n  keepLabels?: string[];\n\n  /**\n   * When in column mode and if set this will use this label's value as the value field name.\n   */\n  valueLabel?: string;\n}\n\nexport const labelsToFieldsTransformer: SynchronousDataTransformerInfo<LabelsToFieldsOptions> = {\n  id: DataTransformerID.labelsToFields,\n  name: 'Labels to fields',\n  description: 'Extract time series labels to fields (columns or rows)',\n  defaultOptions: {},\n\n  operator: (options) => (source) => source.pipe(map((data) => labelsToFieldsTransformer.transformer(options)(data))),\n\n  transformer: (options: LabelsToFieldsOptions) => (data: DataFrame[]) => {\n    // Show each label as a field row\n    if (options.mode === LabelsToFieldsMode.Rows) {\n      return convertLabelsToRows(data, options.keepLabels);\n    }\n\n    const result: DataFrame[] = [];\n    const keepLabels = options.keepLabels?.length ? new Set(options.keepLabels) : undefined;\n\n    for (const frame of data) {\n      const newFields: Field[] = [];\n      const uniqueLabels: Record<string, Set<string>> = {};\n      for (const field of frame.fields) {\n        if (!field.labels) {\n          newFields.push(field);\n          continue;\n        }\n\n        const sansLabels = {\n          ...field,\n          config: {\n            ...field.config,\n            // we need to clear thes for this transform as these can contain label names that we no longer want\n            displayName: undefined,\n            displayNameFromDS: undefined,\n          },\n          labels: undefined,\n        };\n        newFields.push(sansLabels);\n\n        for (const labelName of Object.keys(field.labels)) {\n          if (keepLabels && !keepLabels.has(labelName)) {\n            continue;\n          }\n\n          // if we should use this label as the value field name store it and skip adding this as a separate field\n          if (options.valueLabel === labelName) {\n            sansLabels.name = field.labels[labelName];\n            continue;\n          }\n\n          const uniqueValues = uniqueLabels[labelName] ?? (uniqueLabels[labelName] = new Set()); // (Safari 13.1 lacks ??= support)\n          uniqueValues.add(field.labels[labelName]);\n        }\n      }\n\n      for (const name in uniqueLabels) {\n        for (const value of uniqueLabels[name]) {\n          const values = new Array(frame.length).fill(value);\n          newFields.push({\n            name: name,\n            type: FieldType.string,\n            values: new ArrayVector(values),\n            config: {},\n          });\n        }\n      }\n\n      result.push({\n        fields: newFields,\n        length: frame.length,\n      });\n    }\n\n    return result;\n  },\n};\n\nfunction convertLabelsToRows(data: DataFrame[], keepLabels?: string[]): DataFrame[] {\n  const result: DataFrame[] = [];\n  for (const frame of data) {\n    for (const field of frame.fields) {\n      if (field.labels) {\n        const keys: string[] = [];\n        const vals: string[] = [];\n        if (keepLabels) {\n          for (const key of keepLabels) {\n            keys.push(key);\n            vals.push(field.labels[key]);\n          }\n        } else {\n          for (const [key, val] of Object.entries(field.labels)) {\n            keys.push(key);\n            vals.push(val);\n          }\n        }\n        if (vals.length) {\n          result.push({\n            ...frame,\n            name: getFieldDisplayName(field, frame, data),\n            fields: [\n              { name: 'label', type: FieldType.string, config: {}, values: new ArrayVector(keys) },\n              { name: 'value', type: FieldType.string, config: {}, values: new ArrayVector(vals) },\n            ],\n            length: vals.length,\n          });\n        }\n      }\n    }\n  }\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}