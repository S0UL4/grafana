{"ast":null,"code":"import { parser } from '@grafana/lezer-logql';\nimport { LokiQueryModeller } from './querybuilder/LokiQueryModeller';\nimport { buildVisualQueryFromString } from './querybuilder/parsing';\n\n/**\n * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.\n *\n * It uses LogQL parser to find instances of labels, alters them and then splices them back into the query.\n * In a case when we have parser, instead of adding new instance of label it adds label filter after the parser.\n *\n * This operates on substrings of the query with labels and operates just on those. This makes this\n * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.\n *\n * @param query\n * @param key\n * @param value\n * @param operator\n */\nexport function addLabelToQuery(query, key, operator, value) {\n  if (!key || !value) {\n    throw new Error('Need label to add to query.');\n  }\n\n  const streamSelectorPositions = getStreamSelectorPositions(query);\n  const parserPositions = getParserPositions(query);\n\n  if (!streamSelectorPositions.length) {\n    return query;\n  }\n\n  const filter = toLabelFilter(key, value, operator);\n\n  if (!parserPositions.length) {\n    return addFilterToStreamSelector(query, streamSelectorPositions, filter);\n  } else {\n    return addFilterAsLabelFilter(query, parserPositions, filter);\n  }\n}\n\n/**\n * Parse the string and get all Selector positions in the query together with parsed representation of the\n * selector.\n * @param query\n */\nfunction getStreamSelectorPositions(query) {\n  const tree = parser.parse(query);\n  const positions = [];\n  tree.iterate({\n    enter: (type, from, to, get) => {\n      if (type.name === 'Selector') {\n        const visQuery = buildVisualQueryFromString(query.substring(from, to));\n        positions.push({\n          query: visQuery.query,\n          from,\n          to\n        });\n        return false;\n      }\n    }\n  });\n  return positions;\n}\n/**\n * Parse the string and get all LabelParser positions in the query.\n * @param query\n */\n\n\nfunction getParserPositions(query) {\n  const tree = parser.parse(query);\n  const positions = [];\n  tree.iterate({\n    enter: (type, from, to, get) => {\n      if (type.name === 'LabelParser') {\n        positions.push({\n          from,\n          to\n        });\n        return false;\n      }\n    }\n  });\n  return positions;\n}\n\nfunction toLabelFilter(key, value, operator) {\n  // We need to make sure that we convert the value back to string because it may be a number\n  return {\n    label: key,\n    op: operator,\n    value\n  };\n}\n/**\n * Add filter as to stream selectors\n * @param query\n * @param vectorSelectorPositions\n * @param filter\n */\n\n\nfunction addFilterToStreamSelector(query, vectorSelectorPositions, filter) {\n  const modeller = new LokiQueryModeller();\n  let newQuery = '';\n  let prev = 0;\n\n  for (let i = 0; i < vectorSelectorPositions.length; i++) {\n    // This is basically just doing splice on a string for each matched vector selector.\n    const match = vectorSelectorPositions[i];\n    const isLast = i === vectorSelectorPositions.length - 1;\n    const start = query.substring(prev, match.from);\n    const end = isLast ? query.substring(match.to) : '';\n\n    if (!labelExists(match.query.labels, filter)) {\n      // We don't want to add duplicate labels.\n      match.query.labels.push(filter);\n    }\n\n    const newLabels = modeller.renderQuery(match.query);\n    newQuery += start + newLabels + end;\n    prev = match.to;\n  }\n\n  return newQuery;\n}\n/**\n * Add filter as label filter after the parsers\n * @param query\n * @param parserPositions\n * @param filter\n */\n\n\nfunction addFilterAsLabelFilter(query, parserPositions, filter) {\n  let newQuery = '';\n  let prev = 0;\n\n  for (let i = 0; i < parserPositions.length; i++) {\n    // This is basically just doing splice on a string for each matched vector selector.\n    const match = parserPositions[i];\n    const isLast = i === parserPositions.length - 1;\n    const start = query.substring(prev, match.to);\n    const end = isLast ? query.substring(match.to) : '';\n    const labelFilter = ` | ${filter.label}${filter.op}\\`${filter.value}\\``;\n    newQuery += start + labelFilter + end;\n    prev = match.to;\n  }\n\n  return newQuery;\n}\n/**\n * Check if label exists in the list of labels but ignore the operator.\n * @param labels\n * @param filter\n */\n\n\nfunction labelExists(labels, filter) {\n  return labels.find(label => label.label === filter.label && label.value === filter.value);\n}","map":{"version":3,"names":["parser","LokiQueryModeller","buildVisualQueryFromString","addLabelToQuery","query","key","operator","value","Error","streamSelectorPositions","getStreamSelectorPositions","parserPositions","getParserPositions","length","filter","toLabelFilter","addFilterToStreamSelector","addFilterAsLabelFilter","tree","parse","positions","iterate","enter","type","from","to","get","name","visQuery","substring","push","label","op","vectorSelectorPositions","modeller","newQuery","prev","i","match","isLast","start","end","labelExists","labels","newLabels","renderQuery","labelFilter","find"],"sources":["/home/soula/grafana/public/app/plugins/datasource/loki/add_label_to_query.ts"],"sourcesContent":["import { parser } from '@grafana/lezer-logql';\n\nimport { QueryBuilderLabelFilter } from '../prometheus/querybuilder/shared/types';\n\nimport { LokiQueryModeller } from './querybuilder/LokiQueryModeller';\nimport { buildVisualQueryFromString } from './querybuilder/parsing';\nimport { LokiVisualQuery } from './querybuilder/types';\n\n/**\n * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.\n *\n * It uses LogQL parser to find instances of labels, alters them and then splices them back into the query.\n * In a case when we have parser, instead of adding new instance of label it adds label filter after the parser.\n *\n * This operates on substrings of the query with labels and operates just on those. This makes this\n * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.\n *\n * @param query\n * @param key\n * @param value\n * @param operator\n */\nexport function addLabelToQuery(query: string, key: string, operator: string, value: string): string {\n  if (!key || !value) {\n    throw new Error('Need label to add to query.');\n  }\n\n  const streamSelectorPositions = getStreamSelectorPositions(query);\n  const parserPositions = getParserPositions(query);\n  if (!streamSelectorPositions.length) {\n    return query;\n  }\n\n  const filter = toLabelFilter(key, value, operator);\n  if (!parserPositions.length) {\n    return addFilterToStreamSelector(query, streamSelectorPositions, filter);\n  } else {\n    return addFilterAsLabelFilter(query, parserPositions, filter);\n  }\n}\n\ntype StreamSelectorPosition = { from: number; to: number; query: LokiVisualQuery };\ntype PipelineStagePosition = { from: number; to: number };\n\n/**\n * Parse the string and get all Selector positions in the query together with parsed representation of the\n * selector.\n * @param query\n */\nfunction getStreamSelectorPositions(query: string): StreamSelectorPosition[] {\n  const tree = parser.parse(query);\n  const positions: StreamSelectorPosition[] = [];\n  tree.iterate({\n    enter: (type, from, to, get): false | void => {\n      if (type.name === 'Selector') {\n        const visQuery = buildVisualQueryFromString(query.substring(from, to));\n        positions.push({ query: visQuery.query, from, to });\n        return false;\n      }\n    },\n  });\n  return positions;\n}\n\n/**\n * Parse the string and get all LabelParser positions in the query.\n * @param query\n */\nfunction getParserPositions(query: string): PipelineStagePosition[] {\n  const tree = parser.parse(query);\n  const positions: PipelineStagePosition[] = [];\n  tree.iterate({\n    enter: (type, from, to, get): false | void => {\n      if (type.name === 'LabelParser') {\n        positions.push({ from, to });\n        return false;\n      }\n    },\n  });\n  return positions;\n}\n\nfunction toLabelFilter(key: string, value: string, operator: string): QueryBuilderLabelFilter {\n  // We need to make sure that we convert the value back to string because it may be a number\n  return { label: key, op: operator, value };\n}\n\n/**\n * Add filter as to stream selectors\n * @param query\n * @param vectorSelectorPositions\n * @param filter\n */\nfunction addFilterToStreamSelector(\n  query: string,\n  vectorSelectorPositions: StreamSelectorPosition[],\n  filter: QueryBuilderLabelFilter\n): string {\n  const modeller = new LokiQueryModeller();\n  let newQuery = '';\n  let prev = 0;\n\n  for (let i = 0; i < vectorSelectorPositions.length; i++) {\n    // This is basically just doing splice on a string for each matched vector selector.\n\n    const match = vectorSelectorPositions[i];\n    const isLast = i === vectorSelectorPositions.length - 1;\n\n    const start = query.substring(prev, match.from);\n    const end = isLast ? query.substring(match.to) : '';\n\n    if (!labelExists(match.query.labels, filter)) {\n      // We don't want to add duplicate labels.\n      match.query.labels.push(filter);\n    }\n    const newLabels = modeller.renderQuery(match.query);\n    newQuery += start + newLabels + end;\n    prev = match.to;\n  }\n  return newQuery;\n}\n\n/**\n * Add filter as label filter after the parsers\n * @param query\n * @param parserPositions\n * @param filter\n */\nfunction addFilterAsLabelFilter(\n  query: string,\n  parserPositions: PipelineStagePosition[],\n  filter: QueryBuilderLabelFilter\n): string {\n  let newQuery = '';\n  let prev = 0;\n\n  for (let i = 0; i < parserPositions.length; i++) {\n    // This is basically just doing splice on a string for each matched vector selector.\n    const match = parserPositions[i];\n    const isLast = i === parserPositions.length - 1;\n\n    const start = query.substring(prev, match.to);\n    const end = isLast ? query.substring(match.to) : '';\n\n    const labelFilter = ` | ${filter.label}${filter.op}\\`${filter.value}\\``;\n    newQuery += start + labelFilter + end;\n    prev = match.to;\n  }\n  return newQuery;\n}\n\n/**\n * Check if label exists in the list of labels but ignore the operator.\n * @param labels\n * @param filter\n */\nfunction labelExists(labels: QueryBuilderLabelFilter[], filter: QueryBuilderLabelFilter) {\n  return labels.find((label) => label.label === filter.label && label.value === filter.value);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}