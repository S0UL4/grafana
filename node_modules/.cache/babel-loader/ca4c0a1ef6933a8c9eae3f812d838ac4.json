{"ast":null,"code":"import { StatementPosition } from '../../monarch/types';\nimport { MetricMathTokenTypes } from './types';\nexport function getStatementPosition(currentToken) {\n  const previousNonWhiteSpace = currentToken === null || currentToken === void 0 ? void 0 : currentToken.getPreviousNonWhiteSpaceToken();\n\n  if (currentToken && currentToken.isString()) {\n    return StatementPosition.WithinString;\n  }\n\n  if (currentToken && previousNonWhiteSpace) {\n    const currentFunction = currentToken.getPreviousOfType(MetricMathTokenTypes.Function);\n    const isAfterComma = previousNonWhiteSpace.is(MetricMathTokenTypes.Delimiter, ',');\n    const isWithinSearch = currentFunction && currentFunction.value === 'SEARCH';\n    const allTokensAfterStartOfSearch = currentToken.getPreviousUntil(MetricMathTokenTypes.Function, [], 'SEARCH') || [];\n\n    if (isWithinSearch) {\n      // if there's only one ' then we're still within the first arg\n      if (allTokensAfterStartOfSearch.filter(({\n        value\n      }) => value === \"'\").length === 1) {\n        return StatementPosition.WithinString;\n      } // if there was a , before the last , and it happened after the start of SEARCH\n\n\n      const lastComma = previousNonWhiteSpace.getPreviousOfType(MetricMathTokenTypes.Delimiter, ',');\n\n      if (lastComma) {\n        const lastCommaIsAfterSearch = lastComma.range.startColumn > currentFunction.range.startColumn && lastComma.range.startLineNumber >= currentFunction.range.startLineNumber;\n\n        if (lastCommaIsAfterSearch) {\n          return StatementPosition.SearchFuncThirdArg;\n        }\n      } // otherwise assume it's the second arg\n\n\n      return StatementPosition.SearchFuncSecondArg;\n    }\n\n    if (!isWithinSearch && isAfterComma) {\n      return StatementPosition.PredefinedFuncSecondArg;\n    }\n  }\n\n  if (previousNonWhiteSpace !== null && previousNonWhiteSpace !== void 0 && previousNonWhiteSpace.endsWith(')')) {\n    return StatementPosition.AfterFunction;\n  }\n\n  if (!currentToken || !currentToken.isString()) {\n    return StatementPosition.PredefinedFunction;\n  }\n\n  return StatementPosition.Unknown;\n}","map":{"version":3,"names":["StatementPosition","MetricMathTokenTypes","getStatementPosition","currentToken","previousNonWhiteSpace","getPreviousNonWhiteSpaceToken","isString","WithinString","currentFunction","getPreviousOfType","Function","isAfterComma","is","Delimiter","isWithinSearch","value","allTokensAfterStartOfSearch","getPreviousUntil","filter","length","lastComma","lastCommaIsAfterSearch","range","startColumn","startLineNumber","SearchFuncThirdArg","SearchFuncSecondArg","PredefinedFuncSecondArg","endsWith","AfterFunction","PredefinedFunction","Unknown"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/metric-math/completion/statementPosition.ts"],"sourcesContent":["import { LinkedToken } from '../../monarch/LinkedToken';\nimport { StatementPosition } from '../../monarch/types';\n\nimport { MetricMathTokenTypes } from './types';\n\nexport function getStatementPosition(currentToken: LinkedToken | null): StatementPosition {\n  const previousNonWhiteSpace = currentToken?.getPreviousNonWhiteSpaceToken();\n\n  if (currentToken && currentToken.isString()) {\n    return StatementPosition.WithinString;\n  }\n\n  if (currentToken && previousNonWhiteSpace) {\n    const currentFunction = currentToken.getPreviousOfType(MetricMathTokenTypes.Function);\n    const isAfterComma = previousNonWhiteSpace.is(MetricMathTokenTypes.Delimiter, ',');\n    const isWithinSearch = currentFunction && currentFunction.value === 'SEARCH';\n    const allTokensAfterStartOfSearch =\n      currentToken.getPreviousUntil(MetricMathTokenTypes.Function, [], 'SEARCH') || [];\n\n    if (isWithinSearch) {\n      // if there's only one ' then we're still within the first arg\n      if (allTokensAfterStartOfSearch.filter(({ value }) => value === \"'\").length === 1) {\n        return StatementPosition.WithinString;\n      }\n\n      // if there was a , before the last , and it happened after the start of SEARCH\n      const lastComma = previousNonWhiteSpace.getPreviousOfType(MetricMathTokenTypes.Delimiter, ',');\n      if (lastComma) {\n        const lastCommaIsAfterSearch =\n          lastComma.range.startColumn > currentFunction.range.startColumn &&\n          lastComma.range.startLineNumber >= currentFunction.range.startLineNumber;\n        if (lastCommaIsAfterSearch) {\n          return StatementPosition.SearchFuncThirdArg;\n        }\n      }\n\n      // otherwise assume it's the second arg\n      return StatementPosition.SearchFuncSecondArg;\n    }\n\n    if (!isWithinSearch && isAfterComma) {\n      return StatementPosition.PredefinedFuncSecondArg;\n    }\n  }\n\n  if (previousNonWhiteSpace?.endsWith(')')) {\n    return StatementPosition.AfterFunction;\n  }\n\n  if (!currentToken || !currentToken.isString()) {\n    return StatementPosition.PredefinedFunction;\n  }\n\n  return StatementPosition.Unknown;\n}\n"],"mappings":"AACA,SAASA,iBAAT,QAAkC,qBAAlC;AAEA,SAASC,oBAAT,QAAqC,SAArC;AAEA,OAAO,SAASC,oBAAT,CAA8BC,YAA9B,EAAmF;EACxF,MAAMC,qBAAqB,GAAGD,YAAH,aAAGA,YAAH,uBAAGA,YAAY,CAAEE,6BAAd,EAA9B;;EAEA,IAAIF,YAAY,IAAIA,YAAY,CAACG,QAAb,EAApB,EAA6C;IAC3C,OAAON,iBAAiB,CAACO,YAAzB;EACD;;EAED,IAAIJ,YAAY,IAAIC,qBAApB,EAA2C;IACzC,MAAMI,eAAe,GAAGL,YAAY,CAACM,iBAAb,CAA+BR,oBAAoB,CAACS,QAApD,CAAxB;IACA,MAAMC,YAAY,GAAGP,qBAAqB,CAACQ,EAAtB,CAAyBX,oBAAoB,CAACY,SAA9C,EAAyD,GAAzD,CAArB;IACA,MAAMC,cAAc,GAAGN,eAAe,IAAIA,eAAe,CAACO,KAAhB,KAA0B,QAApE;IACA,MAAMC,2BAA2B,GAC/Bb,YAAY,CAACc,gBAAb,CAA8BhB,oBAAoB,CAACS,QAAnD,EAA6D,EAA7D,EAAiE,QAAjE,KAA8E,EADhF;;IAGA,IAAII,cAAJ,EAAoB;MAClB;MACA,IAAIE,2BAA2B,CAACE,MAA5B,CAAmC,CAAC;QAAEH;MAAF,CAAD,KAAeA,KAAK,KAAK,GAA5D,EAAiEI,MAAjE,KAA4E,CAAhF,EAAmF;QACjF,OAAOnB,iBAAiB,CAACO,YAAzB;MACD,CAJiB,CAMlB;;;MACA,MAAMa,SAAS,GAAGhB,qBAAqB,CAACK,iBAAtB,CAAwCR,oBAAoB,CAACY,SAA7D,EAAwE,GAAxE,CAAlB;;MACA,IAAIO,SAAJ,EAAe;QACb,MAAMC,sBAAsB,GAC1BD,SAAS,CAACE,KAAV,CAAgBC,WAAhB,GAA8Bf,eAAe,CAACc,KAAhB,CAAsBC,WAApD,IACAH,SAAS,CAACE,KAAV,CAAgBE,eAAhB,IAAmChB,eAAe,CAACc,KAAhB,CAAsBE,eAF3D;;QAGA,IAAIH,sBAAJ,EAA4B;UAC1B,OAAOrB,iBAAiB,CAACyB,kBAAzB;QACD;MACF,CAfiB,CAiBlB;;;MACA,OAAOzB,iBAAiB,CAAC0B,mBAAzB;IACD;;IAED,IAAI,CAACZ,cAAD,IAAmBH,YAAvB,EAAqC;MACnC,OAAOX,iBAAiB,CAAC2B,uBAAzB;IACD;EACF;;EAED,IAAIvB,qBAAJ,aAAIA,qBAAJ,eAAIA,qBAAqB,CAAEwB,QAAvB,CAAgC,GAAhC,CAAJ,EAA0C;IACxC,OAAO5B,iBAAiB,CAAC6B,aAAzB;EACD;;EAED,IAAI,CAAC1B,YAAD,IAAiB,CAACA,YAAY,CAACG,QAAb,EAAtB,EAA+C;IAC7C,OAAON,iBAAiB,CAAC8B,kBAAzB;EACD;;EAED,OAAO9B,iBAAiB,CAAC+B,OAAzB;AACD"},"metadata":{},"sourceType":"module"}