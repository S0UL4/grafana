{"ast":null,"code":"import { parser } from 'lezer-promql';\nimport { NeverCaseError } from './util';\n\nfunction move(node, direction) {\n  switch (direction) {\n    case 'parent':\n      return node.parent;\n\n    case 'firstChild':\n      return node.firstChild;\n\n    case 'lastChild':\n      return node.lastChild;\n\n    case 'nextSibling':\n      return node.nextSibling;\n\n    default:\n      throw new NeverCaseError(direction);\n  }\n}\n\nfunction walk(node, path) {\n  let current = node;\n\n  for (const [direction, expectedType] of path) {\n    current = move(current, direction);\n\n    if (current === null) {\n      // we could not move in the direction, we stop\n      return null;\n    }\n\n    if (current.type.name !== expectedType) {\n      // the reached node has wrong type, we stop\n      return null;\n    }\n  }\n\n  return current;\n}\n\nfunction getNodeText(node, text) {\n  return text.slice(node.from, node.to);\n}\n\nfunction parsePromQLStringLiteral(text) {\n  // if it is a string-literal, it is inside quotes of some kind\n  const inside = text.slice(1, text.length - 1); // FIXME: support https://prometheus.io/docs/prometheus/latest/querying/basics/#string-literals\n  // FIXME: maybe check other promql code, if all is supported or not\n  // for now we do only some very simple un-escaping\n  // we start with double-quotes\n\n  if (text.startsWith('\"') && text.endsWith('\"')) {\n    // NOTE: this is not 100% perfect, we only unescape the double-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\\"/, '\"');\n  } // then single-quote\n\n\n  if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n    // NOTE: this is not 100% perfect, we only unescape the single-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\'/, \"'\");\n  } // then backticks\n\n\n  if (text.startsWith('`') && text.endsWith('`')) {\n    return inside;\n  }\n\n  throw new Error('FIXME: invalid string literal');\n}\n\nfunction isPathMatch(resolverPath, cursorPath) {\n  return resolverPath.every((item, index) => item === cursorPath[index]);\n}\n\nconst ERROR_NODE_NAME = '⚠'; // this is used as error-name\n\nconst RESOLVERS = [{\n  path: ['LabelMatchers', 'VectorSelector'],\n  fun: resolveLabelKeysWithEquals\n}, {\n  path: ['PromQL'],\n  fun: resolveTopLevel\n}, {\n  path: ['FunctionCallBody'],\n  fun: resolveInFunction\n}, {\n  path: ['StringLiteral', 'LabelMatcher'],\n  fun: resolveLabelMatcher\n}, {\n  path: [ERROR_NODE_NAME, 'LabelMatcher'],\n  fun: resolveLabelMatcher\n}, {\n  path: [ERROR_NODE_NAME, 'MatrixSelector'],\n  fun: resolveDurations\n}, {\n  path: ['GroupingLabels'],\n  fun: resolveLabelsForGrouping\n}];\nconst LABEL_OP_MAP = new Map([['EqlSingle', '='], ['EqlRegex', '=~'], ['Neq', '!='], ['NeqRegex', '!~']]);\n\nfunction getLabelOp(opNode) {\n  var _LABEL_OP_MAP$get;\n\n  const opChild = opNode.firstChild;\n\n  if (opChild === null) {\n    return null;\n  }\n\n  return (_LABEL_OP_MAP$get = LABEL_OP_MAP.get(opChild.name)) !== null && _LABEL_OP_MAP$get !== void 0 ? _LABEL_OP_MAP$get : null;\n}\n\nfunction getLabel(labelMatcherNode, text) {\n  if (labelMatcherNode.type.name !== 'LabelMatcher') {\n    return null;\n  }\n\n  const nameNode = walk(labelMatcherNode, [['firstChild', 'LabelName']]);\n\n  if (nameNode === null) {\n    return null;\n  }\n\n  const opNode = walk(nameNode, [['nextSibling', 'MatchOp']]);\n\n  if (opNode === null) {\n    return null;\n  }\n\n  const op = getLabelOp(opNode);\n\n  if (op === null) {\n    return null;\n  }\n\n  const valueNode = walk(labelMatcherNode, [['lastChild', 'StringLiteral']]);\n\n  if (valueNode === null) {\n    return null;\n  }\n\n  const name = getNodeText(nameNode, text);\n  const value = parsePromQLStringLiteral(getNodeText(valueNode, text));\n  return {\n    name,\n    value,\n    op\n  };\n}\n\nfunction getLabels(labelMatchersNode, text) {\n  if (labelMatchersNode.type.name !== 'LabelMatchers') {\n    return [];\n  }\n\n  let listNode = walk(labelMatchersNode, [['firstChild', 'LabelMatchList']]);\n  const labels = [];\n\n  while (listNode !== null) {\n    const matcherNode = walk(listNode, [['lastChild', 'LabelMatcher']]);\n\n    if (matcherNode === null) {\n      // unexpected, we stop\n      return [];\n    }\n\n    const label = getLabel(matcherNode, text);\n\n    if (label !== null) {\n      labels.push(label);\n    } // there might be more labels\n\n\n    listNode = walk(listNode, [['firstChild', 'LabelMatchList']]);\n  } // our labels-list is last-first, so we reverse it\n\n\n  labels.reverse();\n  return labels;\n}\n\nfunction getNodeChildren(node) {\n  let child = node.firstChild;\n  const children = [];\n\n  while (child !== null) {\n    children.push(child);\n    child = child.nextSibling;\n  }\n\n  return children;\n}\n\nfunction getNodeInSubtree(node, typeName) {\n  // first we try the current node\n  if (node.type.name === typeName) {\n    return node;\n  } // then we try the children\n\n\n  const children = getNodeChildren(node);\n\n  for (const child of children) {\n    const n = getNodeInSubtree(child, typeName);\n\n    if (n !== null) {\n      return n;\n    }\n  }\n\n  return null;\n}\n\nfunction resolveLabelsForGrouping(node, text, pos) {\n  const aggrExpNode = walk(node, [['parent', 'AggregateModifier'], ['parent', 'AggregateExpr']]);\n\n  if (aggrExpNode === null) {\n    return null;\n  }\n\n  const bodyNode = aggrExpNode.getChild('FunctionCallBody');\n\n  if (bodyNode === null) {\n    return null;\n  }\n\n  const metricIdNode = getNodeInSubtree(bodyNode, 'MetricIdentifier');\n\n  if (metricIdNode === null) {\n    return null;\n  }\n\n  const idNode = walk(metricIdNode, [['firstChild', 'Identifier']]);\n\n  if (idNode === null) {\n    return null;\n  }\n\n  const metricName = getNodeText(idNode, text);\n  return {\n    type: 'IN_GROUPING',\n    metricName,\n    otherLabels: []\n  };\n}\n\nfunction resolveLabelMatcher(node, text, pos) {\n  // we can arrive here in two situation. `node` is either:\n  // - a StringNode (like in `{job=\"^\"}`)\n  // - or an error node (like in `{job=^}`)\n  const inStringNode = !node.type.isError;\n  const parent = walk(node, [['parent', 'LabelMatcher']]);\n\n  if (parent === null) {\n    return null;\n  }\n\n  const labelNameNode = walk(parent, [['firstChild', 'LabelName']]);\n\n  if (labelNameNode === null) {\n    return null;\n  }\n\n  const labelName = getNodeText(labelNameNode, text); // now we need to go up, to the parent of LabelMatcher,\n  // there can be one or many `LabelMatchList` parents, we have\n  // to go through all of them\n\n  const firstListNode = walk(parent, [['parent', 'LabelMatchList']]);\n\n  if (firstListNode === null) {\n    return null;\n  }\n\n  let listNode = firstListNode; // we keep going through the parent-nodes\n  // as long as they are LabelMatchList.\n  // as soon as we reawch LabelMatchers, we stop\n\n  let labelMatchersNode = null;\n\n  while (labelMatchersNode === null) {\n    const p = listNode.parent;\n\n    if (p === null) {\n      return null;\n    }\n\n    const {\n      name\n    } = p.type;\n\n    switch (name) {\n      case 'LabelMatchList':\n        //we keep looping\n        listNode = p;\n        continue;\n\n      case 'LabelMatchers':\n        // we reached the end, we can stop the loop\n        labelMatchersNode = p;\n        continue;\n\n      default:\n        // we reached some other node, we stop\n        return null;\n    }\n  } // now we need to find the other names\n\n\n  const allLabels = getLabels(labelMatchersNode, text); // we need to remove \"our\" label from all-labels, if it is in there\n\n  const otherLabels = allLabels.filter(label => label.name !== labelName);\n  const metricNameNode = walk(labelMatchersNode, [['parent', 'VectorSelector'], ['firstChild', 'MetricIdentifier'], ['firstChild', 'Identifier']]);\n\n  if (metricNameNode === null) {\n    // we are probably in a situation without a metric name\n    return {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n      labelName,\n      betweenQuotes: inStringNode,\n      otherLabels\n    };\n  }\n\n  const metricName = getNodeText(metricNameNode, text);\n  return {\n    type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n    metricName,\n    labelName,\n    betweenQuotes: inStringNode,\n    otherLabels\n  };\n}\n\nfunction resolveTopLevel(node, text, pos) {\n  return {\n    type: 'AT_ROOT'\n  };\n}\n\nfunction resolveInFunction(node, text, pos) {\n  return {\n    type: 'IN_FUNCTION'\n  };\n}\n\nfunction resolveDurations(node, text, pos) {\n  return {\n    type: 'IN_DURATION'\n  };\n}\n\nfunction subTreeHasError(node) {\n  return getNodeInSubtree(node, ERROR_NODE_NAME) !== null;\n}\n\nfunction resolveLabelKeysWithEquals(node, text, pos) {\n  // for example `something{^}`\n  // there are some false positives that can end up in this situation, that we want\n  // to eliminate:\n  // `something{a~^}` (if this subtree contains any error-node, we stop)\n  if (subTreeHasError(node)) {\n    return null;\n  } // next false positive:\n  // `something{a=\"1\"^}`\n\n\n  const child = walk(node, [['firstChild', 'LabelMatchList']]);\n\n  if (child !== null) {\n    // means the label-matching part contains at least one label already.\n    //\n    // in this case, we will need to have a `,` character at the end,\n    // to be able to suggest adding the next label.\n    // the area between the end-of-the-child-node and the cursor-pos\n    // must contain a `,` in this case.\n    const textToCheck = text.slice(child.to, pos);\n\n    if (!textToCheck.includes(',')) {\n      return null;\n    }\n  }\n\n  const metricNameNode = walk(node, [['parent', 'VectorSelector'], ['firstChild', 'MetricIdentifier'], ['firstChild', 'Identifier']]);\n  const otherLabels = getLabels(node, text);\n\n  if (metricNameNode === null) {\n    // we are probably in a situation without a metric name.\n    return {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n      otherLabels\n    };\n  }\n\n  const metricName = getNodeText(metricNameNode, text);\n  return {\n    type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n    metricName,\n    otherLabels\n  };\n} // we find the first error-node in the tree that is at the cursor-position.\n// NOTE: this might be too slow, might need to optimize it\n// (ideas: we do not need to go into every subtree, based on from/to)\n// also, only go to places that are in the sub-tree of the node found\n// by default by lezer. problem is, `next()` will go upward too,\n// and we do not want to go higher than our node\n\n\nfunction getErrorNode(tree, pos) {\n  const cur = tree.cursor(pos);\n\n  while (true) {\n    if (cur.from === pos && cur.to === pos) {\n      const {\n        node\n      } = cur;\n\n      if (node.type.isError) {\n        return node;\n      }\n    }\n\n    if (!cur.next()) {\n      break;\n    }\n  }\n\n  return null;\n}\n\nexport function getSituation(text, pos) {\n  // there is a special-case when we are at the start of writing text,\n  // so we handle that case first\n  if (text === '') {\n    return {\n      type: 'EMPTY'\n    };\n  }\n  /*\n  PromQL\n  Expr\n  VectorSelector\n  LabelMatchers\n  */\n\n\n  const tree = parser.parse(text); // if the tree contains error, it is very probable that\n  // our node is one of those error-nodes.\n  // also, if there are errors, the node lezer finds us,\n  // might not be the best node.\n  // so first we check if there is an error-node at the cursor-position\n\n  const maybeErrorNode = getErrorNode(tree, pos);\n  const cur = maybeErrorNode != null ? maybeErrorNode.cursor : tree.cursor(pos);\n  const currentNode = cur.node;\n  const names = [cur.name];\n\n  while (cur.parent()) {\n    names.push(cur.name);\n  }\n\n  for (let resolver of RESOLVERS) {\n    // i do not use a foreach because i want to stop as soon\n    // as i find something\n    if (isPathMatch(resolver.path, names)) {\n      return resolver.fun(currentNode, text, pos);\n    }\n  }\n\n  return null;\n}","map":{"version":3,"names":["parser","NeverCaseError","move","node","direction","parent","firstChild","lastChild","nextSibling","walk","path","current","expectedType","type","name","getNodeText","text","slice","from","to","parsePromQLStringLiteral","inside","length","startsWith","endsWith","replace","Error","isPathMatch","resolverPath","cursorPath","every","item","index","ERROR_NODE_NAME","RESOLVERS","fun","resolveLabelKeysWithEquals","resolveTopLevel","resolveInFunction","resolveLabelMatcher","resolveDurations","resolveLabelsForGrouping","LABEL_OP_MAP","Map","getLabelOp","opNode","opChild","get","getLabel","labelMatcherNode","nameNode","op","valueNode","value","getLabels","labelMatchersNode","listNode","labels","matcherNode","label","push","reverse","getNodeChildren","child","children","getNodeInSubtree","typeName","n","pos","aggrExpNode","bodyNode","getChild","metricIdNode","idNode","metricName","otherLabels","inStringNode","isError","labelNameNode","labelName","firstListNode","p","allLabels","filter","metricNameNode","betweenQuotes","subTreeHasError","textToCheck","includes","getErrorNode","tree","cur","cursor","next","getSituation","parse","maybeErrorNode","currentNode","names","resolver"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/situation.ts"],"sourcesContent":["import type { Tree, SyntaxNode } from '@lezer/common';\nimport { parser } from 'lezer-promql';\n\nimport { NeverCaseError } from './util';\n\ntype Direction = 'parent' | 'firstChild' | 'lastChild' | 'nextSibling';\ntype NodeTypeName =\n  | '⚠' // this is used as error-name\n  | 'AggregateExpr'\n  | 'AggregateModifier'\n  | 'FunctionCallBody'\n  | 'GroupingLabels'\n  | 'Identifier'\n  | 'LabelMatcher'\n  | 'LabelMatchers'\n  | 'LabelMatchList'\n  | 'LabelName'\n  | 'MetricIdentifier'\n  | 'PromQL'\n  | 'StringLiteral'\n  | 'VectorSelector'\n  | 'MatrixSelector'\n  | 'MatchOp'\n  | 'EqlSingle'\n  | 'Neq'\n  | 'EqlRegex'\n  | 'NeqRegex';\n\ntype Path = Array<[Direction, NodeTypeName]>;\n\nfunction move(node: SyntaxNode, direction: Direction): SyntaxNode | null {\n  switch (direction) {\n    case 'parent':\n      return node.parent;\n    case 'firstChild':\n      return node.firstChild;\n    case 'lastChild':\n      return node.lastChild;\n    case 'nextSibling':\n      return node.nextSibling;\n    default:\n      throw new NeverCaseError(direction);\n  }\n}\n\nfunction walk(node: SyntaxNode, path: Path): SyntaxNode | null {\n  let current: SyntaxNode | null = node;\n  for (const [direction, expectedType] of path) {\n    current = move(current, direction);\n    if (current === null) {\n      // we could not move in the direction, we stop\n      return null;\n    }\n    if (current.type.name !== expectedType) {\n      // the reached node has wrong type, we stop\n      return null;\n    }\n  }\n  return current;\n}\n\nfunction getNodeText(node: SyntaxNode, text: string): string {\n  return text.slice(node.from, node.to);\n}\n\nfunction parsePromQLStringLiteral(text: string): string {\n  // if it is a string-literal, it is inside quotes of some kind\n  const inside = text.slice(1, text.length - 1);\n\n  // FIXME: support https://prometheus.io/docs/prometheus/latest/querying/basics/#string-literals\n  // FIXME: maybe check other promql code, if all is supported or not\n\n  // for now we do only some very simple un-escaping\n\n  // we start with double-quotes\n  if (text.startsWith('\"') && text.endsWith('\"')) {\n    // NOTE: this is not 100% perfect, we only unescape the double-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\\"/, '\"');\n  }\n\n  // then single-quote\n  if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n    // NOTE: this is not 100% perfect, we only unescape the single-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\'/, \"'\");\n  }\n\n  // then backticks\n  if (text.startsWith('`') && text.endsWith('`')) {\n    return inside;\n  }\n\n  throw new Error('FIXME: invalid string literal');\n}\n\ntype LabelOperator = '=' | '!=' | '=~' | '!~';\n\nexport type Label = {\n  name: string;\n  value: string;\n  op: LabelOperator;\n};\n\nexport type Situation =\n  | {\n      type: 'IN_FUNCTION';\n    }\n  | {\n      type: 'AT_ROOT';\n    }\n  | {\n      type: 'EMPTY';\n    }\n  | {\n      type: 'IN_DURATION';\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME';\n      metricName?: string;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_GROUPING';\n      metricName: string;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME';\n      metricName?: string;\n      labelName: string;\n      betweenQuotes: boolean;\n      otherLabels: Label[];\n    };\n\ntype Resolver = {\n  path: NodeTypeName[];\n  fun: (node: SyntaxNode, text: string, pos: number) => Situation | null;\n};\n\nfunction isPathMatch(resolverPath: string[], cursorPath: string[]): boolean {\n  return resolverPath.every((item, index) => item === cursorPath[index]);\n}\n\nconst ERROR_NODE_NAME: NodeTypeName = '⚠'; // this is used as error-name\n\nconst RESOLVERS: Resolver[] = [\n  {\n    path: ['LabelMatchers', 'VectorSelector'],\n    fun: resolveLabelKeysWithEquals,\n  },\n  {\n    path: ['PromQL'],\n    fun: resolveTopLevel,\n  },\n  {\n    path: ['FunctionCallBody'],\n    fun: resolveInFunction,\n  },\n  {\n    path: ['StringLiteral', 'LabelMatcher'],\n    fun: resolveLabelMatcher,\n  },\n  {\n    path: [ERROR_NODE_NAME, 'LabelMatcher'],\n    fun: resolveLabelMatcher,\n  },\n  {\n    path: [ERROR_NODE_NAME, 'MatrixSelector'],\n    fun: resolveDurations,\n  },\n  {\n    path: ['GroupingLabels'],\n    fun: resolveLabelsForGrouping,\n  },\n];\n\nconst LABEL_OP_MAP = new Map<string, LabelOperator>([\n  ['EqlSingle', '='],\n  ['EqlRegex', '=~'],\n  ['Neq', '!='],\n  ['NeqRegex', '!~'],\n]);\n\nfunction getLabelOp(opNode: SyntaxNode): LabelOperator | null {\n  const opChild = opNode.firstChild;\n  if (opChild === null) {\n    return null;\n  }\n\n  return LABEL_OP_MAP.get(opChild.name) ?? null;\n}\n\nfunction getLabel(labelMatcherNode: SyntaxNode, text: string): Label | null {\n  if (labelMatcherNode.type.name !== 'LabelMatcher') {\n    return null;\n  }\n\n  const nameNode = walk(labelMatcherNode, [['firstChild', 'LabelName']]);\n\n  if (nameNode === null) {\n    return null;\n  }\n\n  const opNode = walk(nameNode, [['nextSibling', 'MatchOp']]);\n  if (opNode === null) {\n    return null;\n  }\n\n  const op = getLabelOp(opNode);\n  if (op === null) {\n    return null;\n  }\n\n  const valueNode = walk(labelMatcherNode, [['lastChild', 'StringLiteral']]);\n\n  if (valueNode === null) {\n    return null;\n  }\n\n  const name = getNodeText(nameNode, text);\n  const value = parsePromQLStringLiteral(getNodeText(valueNode, text));\n\n  return { name, value, op };\n}\nfunction getLabels(labelMatchersNode: SyntaxNode, text: string): Label[] {\n  if (labelMatchersNode.type.name !== 'LabelMatchers') {\n    return [];\n  }\n\n  let listNode: SyntaxNode | null = walk(labelMatchersNode, [['firstChild', 'LabelMatchList']]);\n\n  const labels: Label[] = [];\n\n  while (listNode !== null) {\n    const matcherNode = walk(listNode, [['lastChild', 'LabelMatcher']]);\n    if (matcherNode === null) {\n      // unexpected, we stop\n      return [];\n    }\n\n    const label = getLabel(matcherNode, text);\n    if (label !== null) {\n      labels.push(label);\n    }\n\n    // there might be more labels\n    listNode = walk(listNode, [['firstChild', 'LabelMatchList']]);\n  }\n\n  // our labels-list is last-first, so we reverse it\n  labels.reverse();\n\n  return labels;\n}\n\nfunction getNodeChildren(node: SyntaxNode): SyntaxNode[] {\n  let child: SyntaxNode | null = node.firstChild;\n  const children: SyntaxNode[] = [];\n  while (child !== null) {\n    children.push(child);\n    child = child.nextSibling;\n  }\n  return children;\n}\n\nfunction getNodeInSubtree(node: SyntaxNode, typeName: NodeTypeName): SyntaxNode | null {\n  // first we try the current node\n  if (node.type.name === typeName) {\n    return node;\n  }\n\n  // then we try the children\n  const children = getNodeChildren(node);\n  for (const child of children) {\n    const n = getNodeInSubtree(child, typeName);\n    if (n !== null) {\n      return n;\n    }\n  }\n\n  return null;\n}\n\nfunction resolveLabelsForGrouping(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const aggrExpNode = walk(node, [\n    ['parent', 'AggregateModifier'],\n    ['parent', 'AggregateExpr'],\n  ]);\n  if (aggrExpNode === null) {\n    return null;\n  }\n  const bodyNode = aggrExpNode.getChild('FunctionCallBody');\n  if (bodyNode === null) {\n    return null;\n  }\n\n  const metricIdNode = getNodeInSubtree(bodyNode, 'MetricIdentifier');\n  if (metricIdNode === null) {\n    return null;\n  }\n\n  const idNode = walk(metricIdNode, [['firstChild', 'Identifier']]);\n  if (idNode === null) {\n    return null;\n  }\n\n  const metricName = getNodeText(idNode, text);\n  return {\n    type: 'IN_GROUPING',\n    metricName,\n    otherLabels: [],\n  };\n}\n\nfunction resolveLabelMatcher(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // we can arrive here in two situation. `node` is either:\n  // - a StringNode (like in `{job=\"^\"}`)\n  // - or an error node (like in `{job=^}`)\n  const inStringNode = !node.type.isError;\n\n  const parent = walk(node, [['parent', 'LabelMatcher']]);\n  if (parent === null) {\n    return null;\n  }\n\n  const labelNameNode = walk(parent, [['firstChild', 'LabelName']]);\n  if (labelNameNode === null) {\n    return null;\n  }\n\n  const labelName = getNodeText(labelNameNode, text);\n\n  // now we need to go up, to the parent of LabelMatcher,\n  // there can be one or many `LabelMatchList` parents, we have\n  // to go through all of them\n\n  const firstListNode = walk(parent, [['parent', 'LabelMatchList']]);\n  if (firstListNode === null) {\n    return null;\n  }\n\n  let listNode = firstListNode;\n\n  // we keep going through the parent-nodes\n  // as long as they are LabelMatchList.\n  // as soon as we reawch LabelMatchers, we stop\n  let labelMatchersNode: SyntaxNode | null = null;\n  while (labelMatchersNode === null) {\n    const p = listNode.parent;\n    if (p === null) {\n      return null;\n    }\n\n    const { name } = p.type;\n\n    switch (name) {\n      case 'LabelMatchList':\n        //we keep looping\n        listNode = p;\n        continue;\n      case 'LabelMatchers':\n        // we reached the end, we can stop the loop\n        labelMatchersNode = p;\n        continue;\n      default:\n        // we reached some other node, we stop\n        return null;\n    }\n  }\n\n  // now we need to find the other names\n  const allLabels = getLabels(labelMatchersNode, text);\n\n  // we need to remove \"our\" label from all-labels, if it is in there\n  const otherLabels = allLabels.filter((label) => label.name !== labelName);\n\n  const metricNameNode = walk(labelMatchersNode, [\n    ['parent', 'VectorSelector'],\n    ['firstChild', 'MetricIdentifier'],\n    ['firstChild', 'Identifier'],\n  ]);\n\n  if (metricNameNode === null) {\n    // we are probably in a situation without a metric name\n    return {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n      labelName,\n      betweenQuotes: inStringNode,\n      otherLabels,\n    };\n  }\n\n  const metricName = getNodeText(metricNameNode, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n    metricName,\n    labelName,\n    betweenQuotes: inStringNode,\n    otherLabels,\n  };\n}\n\nfunction resolveTopLevel(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'AT_ROOT',\n  };\n}\n\nfunction resolveInFunction(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_FUNCTION',\n  };\n}\n\nfunction resolveDurations(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_DURATION',\n  };\n}\n\nfunction subTreeHasError(node: SyntaxNode): boolean {\n  return getNodeInSubtree(node, ERROR_NODE_NAME) !== null;\n}\n\nfunction resolveLabelKeysWithEquals(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // for example `something{^}`\n\n  // there are some false positives that can end up in this situation, that we want\n  // to eliminate:\n  // `something{a~^}` (if this subtree contains any error-node, we stop)\n  if (subTreeHasError(node)) {\n    return null;\n  }\n\n  // next false positive:\n  // `something{a=\"1\"^}`\n  const child = walk(node, [['firstChild', 'LabelMatchList']]);\n  if (child !== null) {\n    // means the label-matching part contains at least one label already.\n    //\n    // in this case, we will need to have a `,` character at the end,\n    // to be able to suggest adding the next label.\n    // the area between the end-of-the-child-node and the cursor-pos\n    // must contain a `,` in this case.\n    const textToCheck = text.slice(child.to, pos);\n\n    if (!textToCheck.includes(',')) {\n      return null;\n    }\n  }\n\n  const metricNameNode = walk(node, [\n    ['parent', 'VectorSelector'],\n    ['firstChild', 'MetricIdentifier'],\n    ['firstChild', 'Identifier'],\n  ]);\n\n  const otherLabels = getLabels(node, text);\n\n  if (metricNameNode === null) {\n    // we are probably in a situation without a metric name.\n    return {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n      otherLabels,\n    };\n  }\n\n  const metricName = getNodeText(metricNameNode, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n    metricName,\n    otherLabels,\n  };\n}\n\n// we find the first error-node in the tree that is at the cursor-position.\n// NOTE: this might be too slow, might need to optimize it\n// (ideas: we do not need to go into every subtree, based on from/to)\n// also, only go to places that are in the sub-tree of the node found\n// by default by lezer. problem is, `next()` will go upward too,\n// and we do not want to go higher than our node\nfunction getErrorNode(tree: Tree, pos: number): SyntaxNode | null {\n  const cur = tree.cursor(pos);\n  while (true) {\n    if (cur.from === pos && cur.to === pos) {\n      const { node } = cur;\n      if (node.type.isError) {\n        return node;\n      }\n    }\n\n    if (!cur.next()) {\n      break;\n    }\n  }\n  return null;\n}\n\nexport function getSituation(text: string, pos: number): Situation | null {\n  // there is a special-case when we are at the start of writing text,\n  // so we handle that case first\n\n  if (text === '') {\n    return {\n      type: 'EMPTY',\n    };\n  }\n\n  /*\n\tPromQL\nExpr\nVectorSelector\nLabelMatchers\n*/\n  const tree = parser.parse(text);\n\n  // if the tree contains error, it is very probable that\n  // our node is one of those error-nodes.\n  // also, if there are errors, the node lezer finds us,\n  // might not be the best node.\n  // so first we check if there is an error-node at the cursor-position\n  const maybeErrorNode = getErrorNode(tree, pos);\n\n  const cur = maybeErrorNode != null ? maybeErrorNode.cursor : tree.cursor(pos);\n  const currentNode = cur.node;\n\n  const names = [cur.name];\n  while (cur.parent()) {\n    names.push(cur.name);\n  }\n\n  for (let resolver of RESOLVERS) {\n    // i do not use a foreach because i want to stop as soon\n    // as i find something\n    if (isPathMatch(resolver.path, names)) {\n      return resolver.fun(currentNode, text, pos);\n    }\n  }\n\n  return null;\n}\n"],"mappings":"AACA,SAASA,MAAT,QAAuB,cAAvB;AAEA,SAASC,cAAT,QAA+B,QAA/B;;AA2BA,SAASC,IAAT,CAAcC,IAAd,EAAgCC,SAAhC,EAAyE;EACvE,QAAQA,SAAR;IACE,KAAK,QAAL;MACE,OAAOD,IAAI,CAACE,MAAZ;;IACF,KAAK,YAAL;MACE,OAAOF,IAAI,CAACG,UAAZ;;IACF,KAAK,WAAL;MACE,OAAOH,IAAI,CAACI,SAAZ;;IACF,KAAK,aAAL;MACE,OAAOJ,IAAI,CAACK,WAAZ;;IACF;MACE,MAAM,IAAIP,cAAJ,CAAmBG,SAAnB,CAAN;EAVJ;AAYD;;AAED,SAASK,IAAT,CAAcN,IAAd,EAAgCO,IAAhC,EAA+D;EAC7D,IAAIC,OAA0B,GAAGR,IAAjC;;EACA,KAAK,MAAM,CAACC,SAAD,EAAYQ,YAAZ,CAAX,IAAwCF,IAAxC,EAA8C;IAC5CC,OAAO,GAAGT,IAAI,CAACS,OAAD,EAAUP,SAAV,CAAd;;IACA,IAAIO,OAAO,KAAK,IAAhB,EAAsB;MACpB;MACA,OAAO,IAAP;IACD;;IACD,IAAIA,OAAO,CAACE,IAAR,CAAaC,IAAb,KAAsBF,YAA1B,EAAwC;MACtC;MACA,OAAO,IAAP;IACD;EACF;;EACD,OAAOD,OAAP;AACD;;AAED,SAASI,WAAT,CAAqBZ,IAArB,EAAuCa,IAAvC,EAA6D;EAC3D,OAAOA,IAAI,CAACC,KAAL,CAAWd,IAAI,CAACe,IAAhB,EAAsBf,IAAI,CAACgB,EAA3B,CAAP;AACD;;AAED,SAASC,wBAAT,CAAkCJ,IAAlC,EAAwD;EACtD;EACA,MAAMK,MAAM,GAAGL,IAAI,CAACC,KAAL,CAAW,CAAX,EAAcD,IAAI,CAACM,MAAL,GAAc,CAA5B,CAAf,CAFsD,CAItD;EACA;EAEA;EAEA;;EACA,IAAIN,IAAI,CAACO,UAAL,CAAgB,GAAhB,KAAwBP,IAAI,CAACQ,QAAL,CAAc,GAAd,CAA5B,EAAgD;IAC9C;IACA;IACA,OAAOH,MAAM,CAACI,OAAP,CAAe,KAAf,EAAsB,GAAtB,CAAP;EACD,CAdqD,CAgBtD;;;EACA,IAAIT,IAAI,CAACO,UAAL,CAAgB,GAAhB,KAAwBP,IAAI,CAACQ,QAAL,CAAc,GAAd,CAA5B,EAAgD;IAC9C;IACA;IACA,OAAOH,MAAM,CAACI,OAAP,CAAe,KAAf,EAAsB,GAAtB,CAAP;EACD,CArBqD,CAuBtD;;;EACA,IAAIT,IAAI,CAACO,UAAL,CAAgB,GAAhB,KAAwBP,IAAI,CAACQ,QAAL,CAAc,GAAd,CAA5B,EAAgD;IAC9C,OAAOH,MAAP;EACD;;EAED,MAAM,IAAIK,KAAJ,CAAU,+BAAV,CAAN;AACD;;AA8CD,SAASC,WAAT,CAAqBC,YAArB,EAA6CC,UAA7C,EAA4E;EAC1E,OAAOD,YAAY,CAACE,KAAb,CAAmB,CAACC,IAAD,EAAOC,KAAP,KAAiBD,IAAI,KAAKF,UAAU,CAACG,KAAD,CAAvD,CAAP;AACD;;AAED,MAAMC,eAA6B,GAAG,GAAtC,C,CAA2C;;AAE3C,MAAMC,SAAqB,GAAG,CAC5B;EACExB,IAAI,EAAE,CAAC,eAAD,EAAkB,gBAAlB,CADR;EAEEyB,GAAG,EAAEC;AAFP,CAD4B,EAK5B;EACE1B,IAAI,EAAE,CAAC,QAAD,CADR;EAEEyB,GAAG,EAAEE;AAFP,CAL4B,EAS5B;EACE3B,IAAI,EAAE,CAAC,kBAAD,CADR;EAEEyB,GAAG,EAAEG;AAFP,CAT4B,EAa5B;EACE5B,IAAI,EAAE,CAAC,eAAD,EAAkB,cAAlB,CADR;EAEEyB,GAAG,EAAEI;AAFP,CAb4B,EAiB5B;EACE7B,IAAI,EAAE,CAACuB,eAAD,EAAkB,cAAlB,CADR;EAEEE,GAAG,EAAEI;AAFP,CAjB4B,EAqB5B;EACE7B,IAAI,EAAE,CAACuB,eAAD,EAAkB,gBAAlB,CADR;EAEEE,GAAG,EAAEK;AAFP,CArB4B,EAyB5B;EACE9B,IAAI,EAAE,CAAC,gBAAD,CADR;EAEEyB,GAAG,EAAEM;AAFP,CAzB4B,CAA9B;AA+BA,MAAMC,YAAY,GAAG,IAAIC,GAAJ,CAA+B,CAClD,CAAC,WAAD,EAAc,GAAd,CADkD,EAElD,CAAC,UAAD,EAAa,IAAb,CAFkD,EAGlD,CAAC,KAAD,EAAQ,IAAR,CAHkD,EAIlD,CAAC,UAAD,EAAa,IAAb,CAJkD,CAA/B,CAArB;;AAOA,SAASC,UAAT,CAAoBC,MAApB,EAA8D;EAAA;;EAC5D,MAAMC,OAAO,GAAGD,MAAM,CAACvC,UAAvB;;EACA,IAAIwC,OAAO,KAAK,IAAhB,EAAsB;IACpB,OAAO,IAAP;EACD;;EAED,4BAAOJ,YAAY,CAACK,GAAb,CAAiBD,OAAO,CAAChC,IAAzB,CAAP,iEAAyC,IAAzC;AACD;;AAED,SAASkC,QAAT,CAAkBC,gBAAlB,EAAgDjC,IAAhD,EAA4E;EAC1E,IAAIiC,gBAAgB,CAACpC,IAAjB,CAAsBC,IAAtB,KAA+B,cAAnC,EAAmD;IACjD,OAAO,IAAP;EACD;;EAED,MAAMoC,QAAQ,GAAGzC,IAAI,CAACwC,gBAAD,EAAmB,CAAC,CAAC,YAAD,EAAe,WAAf,CAAD,CAAnB,CAArB;;EAEA,IAAIC,QAAQ,KAAK,IAAjB,EAAuB;IACrB,OAAO,IAAP;EACD;;EAED,MAAML,MAAM,GAAGpC,IAAI,CAACyC,QAAD,EAAW,CAAC,CAAC,aAAD,EAAgB,SAAhB,CAAD,CAAX,CAAnB;;EACA,IAAIL,MAAM,KAAK,IAAf,EAAqB;IACnB,OAAO,IAAP;EACD;;EAED,MAAMM,EAAE,GAAGP,UAAU,CAACC,MAAD,CAArB;;EACA,IAAIM,EAAE,KAAK,IAAX,EAAiB;IACf,OAAO,IAAP;EACD;;EAED,MAAMC,SAAS,GAAG3C,IAAI,CAACwC,gBAAD,EAAmB,CAAC,CAAC,WAAD,EAAc,eAAd,CAAD,CAAnB,CAAtB;;EAEA,IAAIG,SAAS,KAAK,IAAlB,EAAwB;IACtB,OAAO,IAAP;EACD;;EAED,MAAMtC,IAAI,GAAGC,WAAW,CAACmC,QAAD,EAAWlC,IAAX,CAAxB;EACA,MAAMqC,KAAK,GAAGjC,wBAAwB,CAACL,WAAW,CAACqC,SAAD,EAAYpC,IAAZ,CAAZ,CAAtC;EAEA,OAAO;IAAEF,IAAF;IAAQuC,KAAR;IAAeF;EAAf,CAAP;AACD;;AACD,SAASG,SAAT,CAAmBC,iBAAnB,EAAkDvC,IAAlD,EAAyE;EACvE,IAAIuC,iBAAiB,CAAC1C,IAAlB,CAAuBC,IAAvB,KAAgC,eAApC,EAAqD;IACnD,OAAO,EAAP;EACD;;EAED,IAAI0C,QAA2B,GAAG/C,IAAI,CAAC8C,iBAAD,EAAoB,CAAC,CAAC,YAAD,EAAe,gBAAf,CAAD,CAApB,CAAtC;EAEA,MAAME,MAAe,GAAG,EAAxB;;EAEA,OAAOD,QAAQ,KAAK,IAApB,EAA0B;IACxB,MAAME,WAAW,GAAGjD,IAAI,CAAC+C,QAAD,EAAW,CAAC,CAAC,WAAD,EAAc,cAAd,CAAD,CAAX,CAAxB;;IACA,IAAIE,WAAW,KAAK,IAApB,EAA0B;MACxB;MACA,OAAO,EAAP;IACD;;IAED,MAAMC,KAAK,GAAGX,QAAQ,CAACU,WAAD,EAAc1C,IAAd,CAAtB;;IACA,IAAI2C,KAAK,KAAK,IAAd,EAAoB;MAClBF,MAAM,CAACG,IAAP,CAAYD,KAAZ;IACD,CAVuB,CAYxB;;;IACAH,QAAQ,GAAG/C,IAAI,CAAC+C,QAAD,EAAW,CAAC,CAAC,YAAD,EAAe,gBAAf,CAAD,CAAX,CAAf;EACD,CAvBsE,CAyBvE;;;EACAC,MAAM,CAACI,OAAP;EAEA,OAAOJ,MAAP;AACD;;AAED,SAASK,eAAT,CAAyB3D,IAAzB,EAAyD;EACvD,IAAI4D,KAAwB,GAAG5D,IAAI,CAACG,UAApC;EACA,MAAM0D,QAAsB,GAAG,EAA/B;;EACA,OAAOD,KAAK,KAAK,IAAjB,EAAuB;IACrBC,QAAQ,CAACJ,IAAT,CAAcG,KAAd;IACAA,KAAK,GAAGA,KAAK,CAACvD,WAAd;EACD;;EACD,OAAOwD,QAAP;AACD;;AAED,SAASC,gBAAT,CAA0B9D,IAA1B,EAA4C+D,QAA5C,EAAuF;EACrF;EACA,IAAI/D,IAAI,CAACU,IAAL,CAAUC,IAAV,KAAmBoD,QAAvB,EAAiC;IAC/B,OAAO/D,IAAP;EACD,CAJoF,CAMrF;;;EACA,MAAM6D,QAAQ,GAAGF,eAAe,CAAC3D,IAAD,CAAhC;;EACA,KAAK,MAAM4D,KAAX,IAAoBC,QAApB,EAA8B;IAC5B,MAAMG,CAAC,GAAGF,gBAAgB,CAACF,KAAD,EAAQG,QAAR,CAA1B;;IACA,IAAIC,CAAC,KAAK,IAAV,EAAgB;MACd,OAAOA,CAAP;IACD;EACF;;EAED,OAAO,IAAP;AACD;;AAED,SAAS1B,wBAAT,CAAkCtC,IAAlC,EAAoDa,IAApD,EAAkEoD,GAAlE,EAAiG;EAC/F,MAAMC,WAAW,GAAG5D,IAAI,CAACN,IAAD,EAAO,CAC7B,CAAC,QAAD,EAAW,mBAAX,CAD6B,EAE7B,CAAC,QAAD,EAAW,eAAX,CAF6B,CAAP,CAAxB;;EAIA,IAAIkE,WAAW,KAAK,IAApB,EAA0B;IACxB,OAAO,IAAP;EACD;;EACD,MAAMC,QAAQ,GAAGD,WAAW,CAACE,QAAZ,CAAqB,kBAArB,CAAjB;;EACA,IAAID,QAAQ,KAAK,IAAjB,EAAuB;IACrB,OAAO,IAAP;EACD;;EAED,MAAME,YAAY,GAAGP,gBAAgB,CAACK,QAAD,EAAW,kBAAX,CAArC;;EACA,IAAIE,YAAY,KAAK,IAArB,EAA2B;IACzB,OAAO,IAAP;EACD;;EAED,MAAMC,MAAM,GAAGhE,IAAI,CAAC+D,YAAD,EAAe,CAAC,CAAC,YAAD,EAAe,YAAf,CAAD,CAAf,CAAnB;;EACA,IAAIC,MAAM,KAAK,IAAf,EAAqB;IACnB,OAAO,IAAP;EACD;;EAED,MAAMC,UAAU,GAAG3D,WAAW,CAAC0D,MAAD,EAASzD,IAAT,CAA9B;EACA,OAAO;IACLH,IAAI,EAAE,aADD;IAEL6D,UAFK;IAGLC,WAAW,EAAE;EAHR,CAAP;AAKD;;AAED,SAASpC,mBAAT,CAA6BpC,IAA7B,EAA+Ca,IAA/C,EAA6DoD,GAA7D,EAA4F;EAC1F;EACA;EACA;EACA,MAAMQ,YAAY,GAAG,CAACzE,IAAI,CAACU,IAAL,CAAUgE,OAAhC;EAEA,MAAMxE,MAAM,GAAGI,IAAI,CAACN,IAAD,EAAO,CAAC,CAAC,QAAD,EAAW,cAAX,CAAD,CAAP,CAAnB;;EACA,IAAIE,MAAM,KAAK,IAAf,EAAqB;IACnB,OAAO,IAAP;EACD;;EAED,MAAMyE,aAAa,GAAGrE,IAAI,CAACJ,MAAD,EAAS,CAAC,CAAC,YAAD,EAAe,WAAf,CAAD,CAAT,CAA1B;;EACA,IAAIyE,aAAa,KAAK,IAAtB,EAA4B;IAC1B,OAAO,IAAP;EACD;;EAED,MAAMC,SAAS,GAAGhE,WAAW,CAAC+D,aAAD,EAAgB9D,IAAhB,CAA7B,CAhB0F,CAkB1F;EACA;EACA;;EAEA,MAAMgE,aAAa,GAAGvE,IAAI,CAACJ,MAAD,EAAS,CAAC,CAAC,QAAD,EAAW,gBAAX,CAAD,CAAT,CAA1B;;EACA,IAAI2E,aAAa,KAAK,IAAtB,EAA4B;IAC1B,OAAO,IAAP;EACD;;EAED,IAAIxB,QAAQ,GAAGwB,aAAf,CA3B0F,CA6B1F;EACA;EACA;;EACA,IAAIzB,iBAAoC,GAAG,IAA3C;;EACA,OAAOA,iBAAiB,KAAK,IAA7B,EAAmC;IACjC,MAAM0B,CAAC,GAAGzB,QAAQ,CAACnD,MAAnB;;IACA,IAAI4E,CAAC,KAAK,IAAV,EAAgB;MACd,OAAO,IAAP;IACD;;IAED,MAAM;MAAEnE;IAAF,IAAWmE,CAAC,CAACpE,IAAnB;;IAEA,QAAQC,IAAR;MACE,KAAK,gBAAL;QACE;QACA0C,QAAQ,GAAGyB,CAAX;QACA;;MACF,KAAK,eAAL;QACE;QACA1B,iBAAiB,GAAG0B,CAApB;QACA;;MACF;QACE;QACA,OAAO,IAAP;IAXJ;EAaD,CAtDyF,CAwD1F;;;EACA,MAAMC,SAAS,GAAG5B,SAAS,CAACC,iBAAD,EAAoBvC,IAApB,CAA3B,CAzD0F,CA2D1F;;EACA,MAAM2D,WAAW,GAAGO,SAAS,CAACC,MAAV,CAAkBxB,KAAD,IAAWA,KAAK,CAAC7C,IAAN,KAAeiE,SAA3C,CAApB;EAEA,MAAMK,cAAc,GAAG3E,IAAI,CAAC8C,iBAAD,EAAoB,CAC7C,CAAC,QAAD,EAAW,gBAAX,CAD6C,EAE7C,CAAC,YAAD,EAAe,kBAAf,CAF6C,EAG7C,CAAC,YAAD,EAAe,YAAf,CAH6C,CAApB,CAA3B;;EAMA,IAAI6B,cAAc,KAAK,IAAvB,EAA6B;IAC3B;IACA,OAAO;MACLvE,IAAI,EAAE,mCADD;MAELkE,SAFK;MAGLM,aAAa,EAAET,YAHV;MAILD;IAJK,CAAP;EAMD;;EAED,MAAMD,UAAU,GAAG3D,WAAW,CAACqE,cAAD,EAAiBpE,IAAjB,CAA9B;EAEA,OAAO;IACLH,IAAI,EAAE,mCADD;IAEL6D,UAFK;IAGLK,SAHK;IAILM,aAAa,EAAET,YAJV;IAKLD;EALK,CAAP;AAOD;;AAED,SAAStC,eAAT,CAAyBlC,IAAzB,EAA2Ca,IAA3C,EAAyDoD,GAAzD,EAAiF;EAC/E,OAAO;IACLvD,IAAI,EAAE;EADD,CAAP;AAGD;;AAED,SAASyB,iBAAT,CAA2BnC,IAA3B,EAA6Ca,IAA7C,EAA2DoD,GAA3D,EAAmF;EACjF,OAAO;IACLvD,IAAI,EAAE;EADD,CAAP;AAGD;;AAED,SAAS2B,gBAAT,CAA0BrC,IAA1B,EAA4Ca,IAA5C,EAA0DoD,GAA1D,EAAkF;EAChF,OAAO;IACLvD,IAAI,EAAE;EADD,CAAP;AAGD;;AAED,SAASyE,eAAT,CAAyBnF,IAAzB,EAAoD;EAClD,OAAO8D,gBAAgB,CAAC9D,IAAD,EAAO8B,eAAP,CAAhB,KAA4C,IAAnD;AACD;;AAED,SAASG,0BAAT,CAAoCjC,IAApC,EAAsDa,IAAtD,EAAoEoD,GAApE,EAAmG;EACjG;EAEA;EACA;EACA;EACA,IAAIkB,eAAe,CAACnF,IAAD,CAAnB,EAA2B;IACzB,OAAO,IAAP;EACD,CARgG,CAUjG;EACA;;;EACA,MAAM4D,KAAK,GAAGtD,IAAI,CAACN,IAAD,EAAO,CAAC,CAAC,YAAD,EAAe,gBAAf,CAAD,CAAP,CAAlB;;EACA,IAAI4D,KAAK,KAAK,IAAd,EAAoB;IAClB;IACA;IACA;IACA;IACA;IACA;IACA,MAAMwB,WAAW,GAAGvE,IAAI,CAACC,KAAL,CAAW8C,KAAK,CAAC5C,EAAjB,EAAqBiD,GAArB,CAApB;;IAEA,IAAI,CAACmB,WAAW,CAACC,QAAZ,CAAqB,GAArB,CAAL,EAAgC;MAC9B,OAAO,IAAP;IACD;EACF;;EAED,MAAMJ,cAAc,GAAG3E,IAAI,CAACN,IAAD,EAAO,CAChC,CAAC,QAAD,EAAW,gBAAX,CADgC,EAEhC,CAAC,YAAD,EAAe,kBAAf,CAFgC,EAGhC,CAAC,YAAD,EAAe,YAAf,CAHgC,CAAP,CAA3B;EAMA,MAAMwE,WAAW,GAAGrB,SAAS,CAACnD,IAAD,EAAOa,IAAP,CAA7B;;EAEA,IAAIoE,cAAc,KAAK,IAAvB,EAA6B;IAC3B;IACA,OAAO;MACLvE,IAAI,EAAE,iCADD;MAEL8D;IAFK,CAAP;EAID;;EAED,MAAMD,UAAU,GAAG3D,WAAW,CAACqE,cAAD,EAAiBpE,IAAjB,CAA9B;EAEA,OAAO;IACLH,IAAI,EAAE,iCADD;IAEL6D,UAFK;IAGLC;EAHK,CAAP;AAKD,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASc,YAAT,CAAsBC,IAAtB,EAAkCtB,GAAlC,EAAkE;EAChE,MAAMuB,GAAG,GAAGD,IAAI,CAACE,MAAL,CAAYxB,GAAZ,CAAZ;;EACA,OAAO,IAAP,EAAa;IACX,IAAIuB,GAAG,CAACzE,IAAJ,KAAakD,GAAb,IAAoBuB,GAAG,CAACxE,EAAJ,KAAWiD,GAAnC,EAAwC;MACtC,MAAM;QAAEjE;MAAF,IAAWwF,GAAjB;;MACA,IAAIxF,IAAI,CAACU,IAAL,CAAUgE,OAAd,EAAuB;QACrB,OAAO1E,IAAP;MACD;IACF;;IAED,IAAI,CAACwF,GAAG,CAACE,IAAJ,EAAL,EAAiB;MACf;IACD;EACF;;EACD,OAAO,IAAP;AACD;;AAED,OAAO,SAASC,YAAT,CAAsB9E,IAAtB,EAAoCoD,GAApC,EAAmE;EACxE;EACA;EAEA,IAAIpD,IAAI,KAAK,EAAb,EAAiB;IACf,OAAO;MACLH,IAAI,EAAE;IADD,CAAP;EAGD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACE,MAAM6E,IAAI,GAAG1F,MAAM,CAAC+F,KAAP,CAAa/E,IAAb,CAAb,CAhBwE,CAkBxE;EACA;EACA;EACA;EACA;;EACA,MAAMgF,cAAc,GAAGP,YAAY,CAACC,IAAD,EAAOtB,GAAP,CAAnC;EAEA,MAAMuB,GAAG,GAAGK,cAAc,IAAI,IAAlB,GAAyBA,cAAc,CAACJ,MAAxC,GAAiDF,IAAI,CAACE,MAAL,CAAYxB,GAAZ,CAA7D;EACA,MAAM6B,WAAW,GAAGN,GAAG,CAACxF,IAAxB;EAEA,MAAM+F,KAAK,GAAG,CAACP,GAAG,CAAC7E,IAAL,CAAd;;EACA,OAAO6E,GAAG,CAACtF,MAAJ,EAAP,EAAqB;IACnB6F,KAAK,CAACtC,IAAN,CAAW+B,GAAG,CAAC7E,IAAf;EACD;;EAED,KAAK,IAAIqF,QAAT,IAAqBjE,SAArB,EAAgC;IAC9B;IACA;IACA,IAAIP,WAAW,CAACwE,QAAQ,CAACzF,IAAV,EAAgBwF,KAAhB,CAAf,EAAuC;MACrC,OAAOC,QAAQ,CAAChE,GAAT,CAAa8D,WAAb,EAA0BjF,IAA1B,EAAgCoD,GAAhC,CAAP;IACD;EACF;;EAED,OAAO,IAAP;AACD"},"metadata":{},"sourceType":"module"}