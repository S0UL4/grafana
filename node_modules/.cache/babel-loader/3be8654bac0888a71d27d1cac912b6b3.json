{"ast":null,"code":"const _excluded = [\"values\", \"state\", \"display\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { FieldType } from '../types';\nimport { ArrayVector } from '../vector';\nimport { guessFieldTypeFromNameAndValue } from './processDataFrame';\n/**\n * The JSON transfer object for DataFrames.  Values are stored in simple JSON\n *\n * @alpha\n */\n\nconst ENTITY_MAP = {\n  Inf: Infinity,\n  NegInf: -Infinity,\n  Undef: undefined,\n  NaN: NaN\n};\n/**\n * @internal use locally\n */\n\nexport function decodeFieldValueEntities(lookup, values) {\n  if (!lookup || !values) {\n    return;\n  }\n\n  for (const key in lookup) {\n    const repl = ENTITY_MAP[key];\n\n    for (const idx of lookup[key]) {\n      if (idx < values.length) {\n        values[idx] = repl;\n      }\n    }\n  }\n}\n\nfunction guessFieldType(name, values) {\n  for (const v of values) {\n    if (v != null) {\n      return guessFieldTypeFromNameAndValue(name, v);\n    }\n  }\n\n  return FieldType.other;\n}\n/**\n * NOTE: dto.data.values will be mutated and decoded/inflated using entities,bases,factors,enums\n *\n * @alpha\n */\n\n\nexport function dataFrameFromJSON(dto) {\n  const {\n    schema,\n    data\n  } = dto;\n\n  if (!schema || !schema.fields) {\n    throw new Error('JSON needs a fields definition');\n  } // Find the longest field length\n\n\n  const length = data ? data.values.reduce((max, vals) => Math.max(max, vals.length), 0) : 0;\n  const fields = schema.fields.map((f, index) => {\n    var _f$type, _f$config, _entities;\n\n    let buffer = data ? data.values[index] : [];\n    let origLen = buffer.length;\n\n    if (origLen !== length) {\n      buffer.length = length; // avoid sparse arrays\n\n      buffer.fill(undefined, origLen);\n    }\n\n    let entities;\n\n    if (entities = data && data.entities && data.entities[index]) {\n      decodeFieldValueEntities(entities, buffer);\n    } // TODO: expand arrays further using bases,factors,enums\n\n\n    return Object.assign({}, f, {\n      type: (_f$type = f.type) !== null && _f$type !== void 0 ? _f$type : guessFieldType(f.name, buffer),\n      config: (_f$config = f.config) !== null && _f$config !== void 0 ? _f$config : {},\n      values: new ArrayVector(buffer),\n      // the presence of this prop is an optimization signal & lookup for consumers\n      entities: (_entities = entities) !== null && _entities !== void 0 ? _entities : {}\n    });\n  });\n  return Object.assign({}, schema, {\n    fields,\n    length\n  });\n}\n/**\n * This converts DataFrame to a json representation with distinct schema+data\n *\n * @alpha\n */\n\nexport function dataFrameToJSON(frame) {\n  const data = {\n    values: []\n  };\n  const schema = {\n    refId: frame.refId,\n    meta: frame.meta,\n    name: frame.name,\n    fields: frame.fields.map(f => {\n      const {\n        values\n      } = f,\n            sfield = _objectWithoutPropertiesLoose(f, _excluded);\n\n      delete sfield.entities;\n      data.values.push(values.toArray());\n      return sfield;\n    })\n  };\n  return {\n    schema,\n    data\n  };\n}","map":{"version":3,"names":["FieldType","ArrayVector","guessFieldTypeFromNameAndValue","ENTITY_MAP","Inf","Infinity","NegInf","Undef","undefined","NaN","decodeFieldValueEntities","lookup","values","key","repl","idx","length","guessFieldType","name","v","other","dataFrameFromJSON","dto","schema","data","fields","Error","reduce","max","vals","Math","map","f","index","buffer","origLen","fill","entities","type","config","dataFrameToJSON","frame","refId","meta","sfield","push","toArray"],"sources":["/home/soula/grafana/packages/grafana-data/src/dataframe/DataFrameJSON.ts"],"sourcesContent":["import { DataFrame, FieldType, FieldConfig, Labels, QueryResultMeta } from '../types';\nimport { ArrayVector } from '../vector';\n\nimport { guessFieldTypeFromNameAndValue } from './processDataFrame';\n\n/**\n * The JSON transfer object for DataFrames.  Values are stored in simple JSON\n *\n * @alpha\n */\nexport interface DataFrameJSON {\n  /**\n   * The schema defines the field type and configuration.\n   */\n  schema?: DataFrameSchema;\n\n  /**\n   * The field data\n   */\n  data?: DataFrameData;\n}\n\n/**\n * @alpha\n */\nexport interface DataFrameData {\n  /**\n   * A columnar store that matches fields defined by schema.\n   */\n  values: any[][];\n\n  /**\n   * Since JSON cannot encode NaN, Inf, -Inf, and undefined, these entities\n   * are decoded after JSON.parse() using this struct\n   */\n  entities?: Array<FieldValueEntityLookup | null>;\n\n  /**\n   * Holds value bases per field so we can encode numbers from fixed points\n   * e.g. [1612900958, 1612900959, 1612900960] -> 1612900958 + [0, 1, 2]\n   */\n  bases?: number[];\n\n  /**\n   * Holds value multipliers per field so we can encode large numbers concisely\n   * e.g. [4900000000, 35000000000] -> 1e9 + [4.9, 35]\n   */\n  factors?: number[];\n\n  /**\n   * Holds enums per field so we can encode recurring values as ints\n   * e.g. [\"foo\", \"foo\", \"baz\", \"foo\"] -> [\"foo\", \"baz\"] + [0,0,1,0]\n   */\n  enums?: any[][];\n}\n\n/**\n * The JSON transfer object for DataFrames.  Values are stored in simple JSON\n *\n * @alpha\n */\nexport interface DataFrameSchema {\n  /**\n   * Matches the query target refId\n   */\n  refId?: string;\n\n  /**\n   * Initial response global metadata\n   */\n  meta?: QueryResultMeta;\n\n  /**\n   * Frame name\n   */\n  name?: string;\n\n  /**\n   * Field definition without any metadata\n   */\n  fields: FieldSchema[];\n}\n\n/**\n * Field object passed over JSON\n *\n * @alpha\n */\nexport interface FieldSchema {\n  name: string; // The column name\n  type?: FieldType;\n  config?: FieldConfig;\n  labels?: Labels;\n}\n\n/**\n * Since JSON cannot encode NaN, Inf, -Inf, and undefined, the locations\n * of these entities in field value arrays are stored here for restoration\n * after JSON.parse()\n *\n * @alpha\n */\nexport interface FieldValueEntityLookup {\n  NaN?: number[];\n  Undef?: number[]; // Missing because of absence or join\n  Inf?: number[];\n  NegInf?: number[];\n}\n\nconst ENTITY_MAP: Record<keyof FieldValueEntityLookup, any> = {\n  Inf: Infinity,\n  NegInf: -Infinity,\n  Undef: undefined,\n  NaN: NaN,\n};\n\n/**\n * @internal use locally\n */\nexport function decodeFieldValueEntities(lookup: FieldValueEntityLookup, values: any[]) {\n  if (!lookup || !values) {\n    return;\n  }\n  for (const key in lookup) {\n    const repl = ENTITY_MAP[key as keyof FieldValueEntityLookup];\n    for (const idx of lookup[key as keyof FieldValueEntityLookup]!) {\n      if (idx < values.length) {\n        values[idx] = repl;\n      }\n    }\n  }\n}\n\nfunction guessFieldType(name: string, values: any[]): FieldType {\n  for (const v of values) {\n    if (v != null) {\n      return guessFieldTypeFromNameAndValue(name, v);\n    }\n  }\n  return FieldType.other;\n}\n\n/**\n * NOTE: dto.data.values will be mutated and decoded/inflated using entities,bases,factors,enums\n *\n * @alpha\n */\nexport function dataFrameFromJSON(dto: DataFrameJSON): DataFrame {\n  const { schema, data } = dto;\n\n  if (!schema || !schema.fields) {\n    throw new Error('JSON needs a fields definition');\n  }\n\n  // Find the longest field length\n  const length = data ? data.values.reduce((max, vals) => Math.max(max, vals.length), 0) : 0;\n  const fields = schema.fields.map((f, index) => {\n    let buffer = data ? data.values[index] : [];\n    let origLen = buffer.length;\n\n    if (origLen !== length) {\n      buffer.length = length;\n      // avoid sparse arrays\n      buffer.fill(undefined, origLen);\n    }\n\n    let entities: FieldValueEntityLookup | undefined | null;\n\n    if ((entities = data && data.entities && data.entities[index])) {\n      decodeFieldValueEntities(entities, buffer);\n    }\n\n    // TODO: expand arrays further using bases,factors,enums\n\n    return {\n      ...f,\n      type: f.type ?? guessFieldType(f.name, buffer),\n      config: f.config ?? {},\n      values: new ArrayVector(buffer),\n      // the presence of this prop is an optimization signal & lookup for consumers\n      entities: entities ?? {},\n    };\n  });\n\n  return {\n    ...schema,\n    fields,\n    length,\n  };\n}\n\n/**\n * This converts DataFrame to a json representation with distinct schema+data\n *\n * @alpha\n */\nexport function dataFrameToJSON(frame: DataFrame): DataFrameJSON {\n  const data: DataFrameData = {\n    values: [],\n  };\n  const schema: DataFrameSchema = {\n    refId: frame.refId,\n    meta: frame.meta,\n    name: frame.name,\n    fields: frame.fields.map((f) => {\n      const { values, state, display, ...sfield } = f;\n      delete (sfield as any).entities;\n      data.values.push(values.toArray());\n      return sfield;\n    }),\n  };\n\n  return {\n    schema,\n    data,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}