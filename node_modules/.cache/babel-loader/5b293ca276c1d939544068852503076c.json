{"ast":null,"code":"import { debounce, sortBy } from 'lodash';\nimport React from 'react';\nimport { Typeahead } from '../components/Typeahead/Typeahead';\nimport { makeFragment, SearchFunctionType } from '../utils';\nimport { SearchFunctionMap } from '../utils/searchFunctions';\nimport TOKEN_MARK from './slate-prism/TOKEN_MARK';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nexport const TYPEAHEAD_DEBOUNCE = 250; // Commands added to the editor by this plugin.\n\nexport function SuggestionsPlugin({\n  onTypeahead,\n  cleanText,\n  onWillApplySuggestion,\n  portalOrigin\n}) {\n  let typeaheadRef;\n  let state = {\n    groupedItems: [],\n    typeaheadPrefix: '',\n    typeaheadContext: '',\n    typeaheadText: ''\n  };\n  const handleTypeaheadDebounced = debounce(handleTypeahead, TYPEAHEAD_DEBOUNCE);\n\n  const setState = update => {\n    state = Object.assign({}, state, update);\n  };\n\n  return {\n    onBlur: (event, editor, next) => {\n      state = Object.assign({}, state, {\n        groupedItems: []\n      });\n      return next();\n    },\n    onClick: (event, editor, next) => {\n      state = Object.assign({}, state, {\n        groupedItems: []\n      });\n      return next();\n    },\n    onKeyDown: (event, editor, next) => {\n      const keyEvent = event;\n      const currentSuggestions = state.groupedItems;\n      const hasSuggestions = currentSuggestions.length;\n\n      switch (keyEvent.key) {\n        case 'Escape':\n          {\n            if (hasSuggestions) {\n              keyEvent.preventDefault();\n              state = Object.assign({}, state, {\n                groupedItems: []\n              }); // Bogus edit to re-render editor\n\n              return editor.insertText('');\n            }\n\n            break;\n          }\n\n        case 'ArrowDown':\n        case 'ArrowUp':\n          if (hasSuggestions) {\n            keyEvent.preventDefault();\n            typeaheadRef.moveMenuIndex(keyEvent.key === 'ArrowDown' ? 1 : -1);\n            return;\n          }\n\n          break;\n\n        case 'Enter':\n          {\n            if (!(keyEvent.shiftKey || keyEvent.ctrlKey) && hasSuggestions) {\n              keyEvent.preventDefault();\n              return typeaheadRef.insertSuggestion();\n            }\n\n            break;\n          }\n\n        case 'Tab':\n          {\n            if (hasSuggestions) {\n              keyEvent.preventDefault();\n              return typeaheadRef.insertSuggestion();\n            }\n\n            break;\n          }\n\n        default:\n          {\n            // Don't react on meta keys\n            if (keyEvent.key.length === 1) {\n              handleTypeaheadDebounced(editor, setState, onTypeahead, cleanText);\n            }\n\n            break;\n          }\n      }\n\n      return next();\n    },\n    commands: {\n      selectSuggestion: (editor, suggestion) => {\n        const suggestions = state.groupedItems;\n\n        if (!suggestions || !suggestions.length) {\n          return editor;\n        } // @ts-ignore\n\n\n        const ed = editor.applyTypeahead(suggestion);\n        handleTypeaheadDebounced(editor, setState, onTypeahead, cleanText);\n        return ed;\n      },\n      applyTypeahead: (editor, suggestion) => {\n        let suggestionText = suggestion.insertText || suggestion.label;\n        const preserveSuffix = suggestion.kind === 'function';\n        const move = suggestion.move || 0;\n        const {\n          typeaheadPrefix,\n          typeaheadText,\n          typeaheadContext\n        } = state;\n\n        if (onWillApplySuggestion) {\n          suggestionText = onWillApplySuggestion(suggestionText, {\n            groupedItems: state.groupedItems,\n            typeaheadContext,\n            typeaheadPrefix,\n            typeaheadText\n          });\n        } // Remove the current, incomplete text and replace it with the selected suggestion\n\n\n        const backward = suggestion.deleteBackwards || typeaheadPrefix.length;\n        const text = cleanText ? cleanText(typeaheadText) : typeaheadText;\n        const suffixLength = text.length - typeaheadPrefix.length;\n        const offset = typeaheadText.indexOf(typeaheadPrefix);\n        const midWord = typeaheadPrefix && (suffixLength > 0 && offset > -1 || suggestionText === typeaheadText);\n        const forward = midWord && !preserveSuffix ? suffixLength + offset : 0; // If new-lines, apply suggestion as block\n\n        if (suggestionText.match(/\\n/)) {\n          const fragment = makeFragment(suggestionText);\n          return editor.deleteBackward(backward).deleteForward(forward).insertFragment(fragment).focus();\n        }\n\n        state = Object.assign({}, state, {\n          groupedItems: []\n        });\n        return editor.snapshotSelection().deleteBackward(backward).deleteForward(forward).insertText(suggestionText).moveForward(move).focus();\n      }\n    },\n\n    renderEditor(props, editor, next) {\n      if (editor.value.selection.isExpanded) {\n        return next();\n      }\n\n      const children = next();\n      return /*#__PURE__*/_jsxs(_Fragment, {\n        children: [children, /*#__PURE__*/_jsx(Typeahead, {\n          menuRef: menu => typeaheadRef = menu,\n          origin: portalOrigin,\n          prefix: state.typeaheadPrefix,\n          isOpen: !!state.groupedItems.length,\n          groupedItems: state.groupedItems,\n          onSelectSuggestion: editor.selectSuggestion\n        })]\n      });\n    }\n\n  };\n}\n\nconst handleTypeahead = async (editor, onStateChange, onTypeahead, cleanText) => {\n  if (!onTypeahead) {\n    return;\n  }\n\n  const {\n    value\n  } = editor;\n  const {\n    selection\n  } = value; // Get decorations associated with the current line\n\n  const parentBlock = value.document.getClosestBlock(value.focusBlock.key);\n  const selectionStartOffset = value.selection.start.offset - 1;\n  const decorations = parentBlock && parentBlock.getDecorations(editor);\n  const filteredDecorations = decorations ? decorations.filter(decoration => decoration.start.offset <= selectionStartOffset && decoration.end.offset > selectionStartOffset && decoration.type === TOKEN_MARK).toArray() : []; // Find the first label key to the left of the cursor\n\n  const labelKeyDec = decorations && decorations.filter(decoration => decoration.end.offset <= selectionStartOffset && decoration.type === TOKEN_MARK && decoration.data.get('className').includes('label-key')).last();\n  const labelKey = labelKeyDec && value.focusText.text.slice(labelKeyDec.start.offset, labelKeyDec.end.offset);\n  const wrapperClasses = filteredDecorations.map(decoration => decoration.data.get('className')).join(' ').split(' ').filter(className => className.length);\n  let text = value.focusText.text;\n  let prefix = text.slice(0, selection.focus.offset);\n\n  if (filteredDecorations.length) {\n    text = value.focusText.text.slice(filteredDecorations[0].start.offset, filteredDecorations[0].end.offset);\n    prefix = value.focusText.text.slice(filteredDecorations[0].start.offset, selection.focus.offset);\n  } // Label values could have valid characters erased if `cleanText()` is\n  // blindly applied, which would undesirably interfere with suggestions\n\n\n  const labelValueMatch = prefix.match(/(?:!?=~?\"?|\")(.*)/);\n\n  if (labelValueMatch) {\n    prefix = labelValueMatch[1];\n  } else if (cleanText) {\n    prefix = cleanText(prefix);\n  }\n\n  const {\n    suggestions,\n    context\n  } = await onTypeahead({\n    prefix,\n    text,\n    value,\n    wrapperClasses,\n    labelKey: labelKey || undefined,\n    editor\n  });\n  const filteredSuggestions = suggestions.map(group => {\n    if (!group.items) {\n      return group;\n    } // Falling back to deprecated prefixMatch to support backwards compatibility with plugins using this property\n\n\n    const searchFunctionType = group.searchFunctionType || (group.prefixMatch ? SearchFunctionType.Prefix : SearchFunctionType.Word);\n    const searchFunction = SearchFunctionMap[searchFunctionType];\n    let newGroup = Object.assign({}, group);\n\n    if (prefix) {\n      // Filter groups based on prefix\n      if (!group.skipFilter) {\n        newGroup.items = newGroup.items.filter(c => (c.filterText || c.label).length >= prefix.length);\n        newGroup.items = searchFunction(newGroup.items, prefix);\n      } // Filter out the already typed value (prefix) unless it inserts custom text not matching the prefix\n\n\n      newGroup.items = newGroup.items.filter(c => {\n        var _c$filterText;\n\n        return !(c.insertText === prefix || ((_c$filterText = c.filterText) !== null && _c$filterText !== void 0 ? _c$filterText : c.label) === prefix);\n      });\n    }\n\n    if (!group.skipSort) {\n      newGroup.items = sortBy(newGroup.items, item => {\n        if (item.sortText === undefined) {\n          return item.sortValue !== undefined ? item.sortValue : item.label;\n        } else {\n          // Falling back to deprecated sortText to support backwards compatibility with plugins using this property\n          return item.sortText || item.label;\n        }\n      });\n    }\n\n    return newGroup;\n  }).filter(gr => gr.items && gr.items.length); // Filter out empty groups\n\n  onStateChange({\n    groupedItems: filteredSuggestions,\n    typeaheadPrefix: prefix,\n    typeaheadContext: context,\n    typeaheadText: text\n  }); // Bogus edit to force re-render\n\n  editor.blur().focus();\n};","map":{"version":3,"names":["debounce","sortBy","React","Typeahead","makeFragment","SearchFunctionType","SearchFunctionMap","TOKEN_MARK","TYPEAHEAD_DEBOUNCE","SuggestionsPlugin","onTypeahead","cleanText","onWillApplySuggestion","portalOrigin","typeaheadRef","state","groupedItems","typeaheadPrefix","typeaheadContext","typeaheadText","handleTypeaheadDebounced","handleTypeahead","setState","update","onBlur","event","editor","next","onClick","onKeyDown","keyEvent","currentSuggestions","hasSuggestions","length","key","preventDefault","insertText","moveMenuIndex","shiftKey","ctrlKey","insertSuggestion","commands","selectSuggestion","suggestion","suggestions","ed","applyTypeahead","suggestionText","label","preserveSuffix","kind","move","backward","deleteBackwards","text","suffixLength","offset","indexOf","midWord","forward","match","fragment","deleteBackward","deleteForward","insertFragment","focus","snapshotSelection","moveForward","renderEditor","props","value","selection","isExpanded","children","menu","onStateChange","parentBlock","document","getClosestBlock","focusBlock","selectionStartOffset","start","decorations","getDecorations","filteredDecorations","filter","decoration","end","type","toArray","labelKeyDec","data","get","includes","last","labelKey","focusText","slice","wrapperClasses","map","join","split","className","prefix","labelValueMatch","context","undefined","filteredSuggestions","group","items","searchFunctionType","prefixMatch","Prefix","Word","searchFunction","newGroup","skipFilter","c","filterText","skipSort","item","sortText","sortValue","gr","blur"],"sources":["/home/soula/grafana/packages/grafana-ui/src/slate-plugins/suggestions.tsx"],"sourcesContent":["import { debounce, sortBy } from 'lodash';\nimport React from 'react';\nimport { Editor as CoreEditor } from 'slate';\n\nimport { Plugin as SlatePlugin } from '@grafana/slate-react';\n\nimport { Typeahead } from '../components/Typeahead/Typeahead';\nimport { CompletionItem, SuggestionsState, TypeaheadInput, TypeaheadOutput } from '../types';\nimport { makeFragment, SearchFunctionType } from '../utils';\nimport { SearchFunctionMap } from '../utils/searchFunctions';\n\nimport TOKEN_MARK from './slate-prism/TOKEN_MARK';\n\nexport const TYPEAHEAD_DEBOUNCE = 250;\n\n// Commands added to the editor by this plugin.\ninterface SuggestionsPluginCommands {\n  selectSuggestion: (suggestion: CompletionItem) => CoreEditor;\n  applyTypeahead: (suggestion: CompletionItem) => CoreEditor;\n}\n\nexport function SuggestionsPlugin({\n  onTypeahead,\n  cleanText,\n  onWillApplySuggestion,\n  portalOrigin,\n}: {\n  onTypeahead?: (typeahead: TypeaheadInput) => Promise<TypeaheadOutput>;\n  cleanText?: (text: string) => string;\n  onWillApplySuggestion?: (suggestion: string, state: SuggestionsState) => string;\n  portalOrigin: string;\n}): SlatePlugin {\n  let typeaheadRef: Typeahead;\n  let state: SuggestionsState = {\n    groupedItems: [],\n    typeaheadPrefix: '',\n    typeaheadContext: '',\n    typeaheadText: '',\n  };\n  const handleTypeaheadDebounced = debounce(handleTypeahead, TYPEAHEAD_DEBOUNCE);\n\n  const setState = (update: Partial<SuggestionsState>) => {\n    state = {\n      ...state,\n      ...update,\n    };\n  };\n\n  return {\n    onBlur: (event, editor, next) => {\n      state = {\n        ...state,\n        groupedItems: [],\n      };\n\n      return next();\n    },\n\n    onClick: (event, editor, next) => {\n      state = {\n        ...state,\n        groupedItems: [],\n      };\n\n      return next();\n    },\n\n    onKeyDown: (event: Event, editor, next) => {\n      const keyEvent = event as KeyboardEvent;\n      const currentSuggestions = state.groupedItems;\n\n      const hasSuggestions = currentSuggestions.length;\n\n      switch (keyEvent.key) {\n        case 'Escape': {\n          if (hasSuggestions) {\n            keyEvent.preventDefault();\n\n            state = {\n              ...state,\n              groupedItems: [],\n            };\n\n            // Bogus edit to re-render editor\n            return editor.insertText('');\n          }\n\n          break;\n        }\n\n        case 'ArrowDown':\n        case 'ArrowUp':\n          if (hasSuggestions) {\n            keyEvent.preventDefault();\n            typeaheadRef.moveMenuIndex(keyEvent.key === 'ArrowDown' ? 1 : -1);\n            return;\n          }\n\n          break;\n\n        case 'Enter': {\n          if (!(keyEvent.shiftKey || keyEvent.ctrlKey) && hasSuggestions) {\n            keyEvent.preventDefault();\n            return typeaheadRef.insertSuggestion();\n          }\n\n          break;\n        }\n\n        case 'Tab': {\n          if (hasSuggestions) {\n            keyEvent.preventDefault();\n            return typeaheadRef.insertSuggestion();\n          }\n\n          break;\n        }\n\n        default: {\n          // Don't react on meta keys\n          if (keyEvent.key.length === 1) {\n            handleTypeaheadDebounced(editor, setState, onTypeahead, cleanText);\n          }\n          break;\n        }\n      }\n\n      return next();\n    },\n\n    commands: {\n      selectSuggestion: (editor: CoreEditor, suggestion: CompletionItem): CoreEditor => {\n        const suggestions = state.groupedItems;\n        if (!suggestions || !suggestions.length) {\n          return editor;\n        }\n\n        // @ts-ignore\n        const ed = editor.applyTypeahead(suggestion);\n        handleTypeaheadDebounced(editor, setState, onTypeahead, cleanText);\n        return ed;\n      },\n\n      applyTypeahead: (editor: CoreEditor, suggestion: CompletionItem): CoreEditor => {\n        let suggestionText = suggestion.insertText || suggestion.label;\n\n        const preserveSuffix = suggestion.kind === 'function';\n        const move = suggestion.move || 0;\n\n        const { typeaheadPrefix, typeaheadText, typeaheadContext } = state;\n\n        if (onWillApplySuggestion) {\n          suggestionText = onWillApplySuggestion(suggestionText, {\n            groupedItems: state.groupedItems,\n            typeaheadContext,\n            typeaheadPrefix,\n            typeaheadText,\n          });\n        }\n\n        // Remove the current, incomplete text and replace it with the selected suggestion\n        const backward = suggestion.deleteBackwards || typeaheadPrefix.length;\n        const text = cleanText ? cleanText(typeaheadText) : typeaheadText;\n        const suffixLength = text.length - typeaheadPrefix.length;\n        const offset = typeaheadText.indexOf(typeaheadPrefix);\n        const midWord = typeaheadPrefix && ((suffixLength > 0 && offset > -1) || suggestionText === typeaheadText);\n        const forward = midWord && !preserveSuffix ? suffixLength + offset : 0;\n\n        // If new-lines, apply suggestion as block\n        if (suggestionText.match(/\\n/)) {\n          const fragment = makeFragment(suggestionText);\n          return editor.deleteBackward(backward).deleteForward(forward).insertFragment(fragment).focus();\n        }\n\n        state = {\n          ...state,\n          groupedItems: [],\n        };\n\n        return editor\n          .snapshotSelection()\n          .deleteBackward(backward)\n          .deleteForward(forward)\n          .insertText(suggestionText)\n          .moveForward(move)\n          .focus();\n      },\n    },\n\n    renderEditor(props, editor, next) {\n      if (editor.value.selection.isExpanded) {\n        return next();\n      }\n\n      const children = next();\n\n      return (\n        <>\n          {children}\n          <Typeahead\n            menuRef={(menu: Typeahead) => (typeaheadRef = menu)}\n            origin={portalOrigin}\n            prefix={state.typeaheadPrefix}\n            isOpen={!!state.groupedItems.length}\n            groupedItems={state.groupedItems}\n            onSelectSuggestion={(editor as CoreEditor & SuggestionsPluginCommands).selectSuggestion}\n          />\n        </>\n      );\n    },\n  };\n}\n\nconst handleTypeahead = async (\n  editor: CoreEditor,\n  onStateChange: (state: Partial<SuggestionsState>) => void,\n  onTypeahead?: (typeahead: TypeaheadInput) => Promise<TypeaheadOutput>,\n  cleanText?: (text: string) => string\n): Promise<void> => {\n  if (!onTypeahead) {\n    return;\n  }\n\n  const { value } = editor;\n  const { selection } = value;\n\n  // Get decorations associated with the current line\n  const parentBlock = value.document.getClosestBlock(value.focusBlock.key);\n  const selectionStartOffset = value.selection.start.offset - 1;\n  const decorations = parentBlock && parentBlock.getDecorations(editor as any);\n\n  const filteredDecorations = decorations\n    ? decorations\n        .filter(\n          (decoration) =>\n            decoration!.start.offset <= selectionStartOffset &&\n            decoration!.end.offset > selectionStartOffset &&\n            decoration!.type === TOKEN_MARK\n        )\n        .toArray()\n    : [];\n\n  // Find the first label key to the left of the cursor\n  const labelKeyDec =\n    decorations &&\n    decorations\n      .filter(\n        (decoration) =>\n          decoration!.end.offset <= selectionStartOffset &&\n          decoration!.type === TOKEN_MARK &&\n          decoration!.data.get('className').includes('label-key')\n      )\n      .last();\n\n  const labelKey = labelKeyDec && value.focusText.text.slice(labelKeyDec.start.offset, labelKeyDec.end.offset);\n\n  const wrapperClasses = filteredDecorations\n    .map((decoration) => decoration.data.get('className'))\n    .join(' ')\n    .split(' ')\n    .filter((className) => className.length);\n\n  let text = value.focusText.text;\n  let prefix = text.slice(0, selection.focus.offset);\n\n  if (filteredDecorations.length) {\n    text = value.focusText.text.slice(filteredDecorations[0].start.offset, filteredDecorations[0].end.offset);\n    prefix = value.focusText.text.slice(filteredDecorations[0].start.offset, selection.focus.offset);\n  }\n\n  // Label values could have valid characters erased if `cleanText()` is\n  // blindly applied, which would undesirably interfere with suggestions\n  const labelValueMatch = prefix.match(/(?:!?=~?\"?|\")(.*)/);\n  if (labelValueMatch) {\n    prefix = labelValueMatch[1];\n  } else if (cleanText) {\n    prefix = cleanText(prefix);\n  }\n\n  const { suggestions, context } = await onTypeahead({\n    prefix,\n    text,\n    value,\n    wrapperClasses,\n    labelKey: labelKey || undefined,\n    editor,\n  });\n\n  const filteredSuggestions = suggestions\n    .map((group) => {\n      if (!group.items) {\n        return group;\n      }\n      // Falling back to deprecated prefixMatch to support backwards compatibility with plugins using this property\n      const searchFunctionType =\n        group.searchFunctionType || (group.prefixMatch ? SearchFunctionType.Prefix : SearchFunctionType.Word);\n      const searchFunction = SearchFunctionMap[searchFunctionType];\n      let newGroup = { ...group };\n      if (prefix) {\n        // Filter groups based on prefix\n        if (!group.skipFilter) {\n          newGroup.items = newGroup.items.filter((c) => (c.filterText || c.label).length >= prefix.length);\n          newGroup.items = searchFunction(newGroup.items, prefix);\n        }\n\n        // Filter out the already typed value (prefix) unless it inserts custom text not matching the prefix\n        newGroup.items = newGroup.items.filter(\n          (c) => !(c.insertText === prefix || (c.filterText ?? c.label) === prefix)\n        );\n      }\n\n      if (!group.skipSort) {\n        newGroup.items = sortBy(newGroup.items, (item: CompletionItem) => {\n          if (item.sortText === undefined) {\n            return item.sortValue !== undefined ? item.sortValue : item.label;\n          } else {\n            // Falling back to deprecated sortText to support backwards compatibility with plugins using this property\n            return item.sortText || item.label;\n          }\n        });\n      }\n\n      return newGroup;\n    })\n    .filter((gr) => gr.items && gr.items.length); // Filter out empty groups\n\n  onStateChange({\n    groupedItems: filteredSuggestions,\n    typeaheadPrefix: prefix,\n    typeaheadContext: context,\n    typeaheadText: text,\n  });\n\n  // Bogus edit to force re-render\n  editor.blur().focus();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}