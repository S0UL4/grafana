{"ast":null,"code":"import { createSlice, isAsyncThunkAction } from '@reduxjs/toolkit';\nimport { AppEvents } from '@grafana/data';\nimport { isFetchError } from '@grafana/runtime';\nimport { appEvents } from 'app/core/core';\nexport const initialAsyncRequestState = Object.freeze({\n  loading: false,\n  result: undefined,\n  error: undefined,\n  dispatched: false\n});\n\nfunction requestStateReducer(asyncThunk, state = initialAsyncRequestState, action) {\n  if (asyncThunk.pending.match(action)) {\n    return {\n      result: state.result,\n      loading: true,\n      error: state.error,\n      dispatched: true,\n      requestId: action.meta.requestId\n    };\n  } else if (asyncThunk.fulfilled.match(action)) {\n    if (state.requestId === undefined || state.requestId === action.meta.requestId) {\n      return Object.assign({}, state, {\n        result: action.payload,\n        loading: false,\n        error: undefined\n      });\n    }\n  } else if (asyncThunk.rejected.match(action)) {\n    if (state.requestId === action.meta.requestId) {\n      return Object.assign({}, state, {\n        loading: false,\n        error: action.error\n      });\n    }\n  }\n\n  return state;\n}\n/*\n * createAsyncSlice creates a slice based on a given async action, exposing it's state.\n * takes care to only use state of the latest invocation of the action if there are several in flight.\n */\n\n\nexport function createAsyncSlice(name, asyncThunk) {\n  return createSlice({\n    name,\n    initialState: initialAsyncRequestState,\n    reducers: {},\n    extraReducers: builder => builder.addDefaultCase((state, action) => requestStateReducer(asyncThunk, state, action))\n  });\n}\n/*\n * createAsyncMapSlice creates a slice based on a given async action exposing a map of request states.\n * separate requests are uniquely indentified by result of provided getEntityId function\n * takes care to only use state of the latest invocation of the action if there are several in flight.\n */\n\nexport function createAsyncMapSlice(name, asyncThunk, getEntityId) {\n  return createSlice({\n    name,\n    initialState: {},\n    reducers: {},\n    extraReducers: builder => builder.addDefaultCase((state, action) => {\n      if (isAsyncThunkAction(asyncThunk)(action)) {\n        const asyncAction = action;\n        const entityId = getEntityId(asyncAction.meta.arg);\n        return Object.assign({}, state, {\n          [entityId]: requestStateReducer(asyncThunk, state[entityId], asyncAction)\n        });\n      }\n\n      return state;\n    })\n  });\n} // rethrow promise error in redux serialized format\n\nexport function withSerializedError(p) {\n  return p.catch(e => {\n    const err = {\n      message: messageFromError(e),\n      code: e.statusCode\n    };\n    throw err;\n  });\n}\nexport function withAppEvents(p, options) {\n  return p.then(v => {\n    if (options.successMessage) {\n      appEvents.emit(AppEvents.alertSuccess, [options.successMessage]);\n    }\n\n    return v;\n  }).catch(e => {\n    var _options$errorMessage;\n\n    const msg = messageFromError(e);\n    appEvents.emit(AppEvents.alertError, [`${(_options$errorMessage = options.errorMessage) !== null && _options$errorMessage !== void 0 ? _options$errorMessage : 'Error'}: ${msg}`]);\n    throw e;\n  });\n}\nexport function messageFromError(e) {\n  if (isFetchError(e)) {\n    var _e$data, _e$data$;\n\n    if ((_e$data = e.data) !== null && _e$data !== void 0 && _e$data.message) {\n      var _e$data2, _e$data3;\n\n      let msg = (_e$data2 = e.data) === null || _e$data2 === void 0 ? void 0 : _e$data2.message;\n\n      if (typeof ((_e$data3 = e.data) === null || _e$data3 === void 0 ? void 0 : _e$data3.error) === 'string') {\n        msg += `; ${e.data.error}`;\n      }\n\n      return msg;\n    } else if (Array.isArray(e.data) && e.data.length && (_e$data$ = e.data[0]) !== null && _e$data$ !== void 0 && _e$data$.message) {\n      return e.data.map(d => d === null || d === void 0 ? void 0 : d.message).filter(m => !!m).join(' ');\n    } else if (e.statusText) {\n      return e.statusText;\n    }\n  }\n\n  return (e === null || e === void 0 ? void 0 : e.message) || String(e);\n}\nexport function isAsyncRequestMapSliceFulfilled(slice) {\n  return Object.values(slice).every(isAsyncRequestStateFulfilled);\n}\nexport function isAsyncRequestStateFulfilled(state) {\n  return state.dispatched && !state.loading && !state.error;\n}\nexport function isAsyncRequestMapSlicePending(slice) {\n  return Object.values(slice).some(isAsyncRequestStatePending);\n}\nexport function isAsyncRequestStatePending(state) {\n  return state.dispatched && state.loading;\n}","map":{"version":3,"names":["createSlice","isAsyncThunkAction","AppEvents","isFetchError","appEvents","initialAsyncRequestState","Object","freeze","loading","result","undefined","error","dispatched","requestStateReducer","asyncThunk","state","action","pending","match","requestId","meta","fulfilled","payload","rejected","createAsyncSlice","name","initialState","reducers","extraReducers","builder","addDefaultCase","createAsyncMapSlice","getEntityId","asyncAction","entityId","arg","withSerializedError","p","catch","e","err","message","messageFromError","code","statusCode","withAppEvents","options","then","v","successMessage","emit","alertSuccess","msg","alertError","errorMessage","data","Array","isArray","length","map","d","filter","m","join","statusText","String","isAsyncRequestMapSliceFulfilled","slice","values","every","isAsyncRequestStateFulfilled","isAsyncRequestMapSlicePending","some","isAsyncRequestStatePending"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/utils/redux.ts"],"sourcesContent":["import { AsyncThunk, createSlice, Draft, isAsyncThunkAction, PayloadAction, SerializedError } from '@reduxjs/toolkit';\n\nimport { AppEvents } from '@grafana/data';\nimport { FetchError, isFetchError } from '@grafana/runtime';\nimport { appEvents } from 'app/core/core';\n\nexport interface AsyncRequestState<T> {\n  result?: T;\n  loading: boolean;\n  error?: SerializedError;\n  dispatched: boolean;\n  requestId?: string;\n}\n\nexport const initialAsyncRequestState: Pick<\n  AsyncRequestState<undefined>,\n  'loading' | 'dispatched' | 'result' | 'error'\n> = Object.freeze({\n  loading: false,\n  result: undefined,\n  error: undefined,\n  dispatched: false,\n});\n\nexport type AsyncRequestMapSlice<T> = Record<string, AsyncRequestState<T>>;\n\nexport type AsyncRequestAction<T> = PayloadAction<Draft<T>, string, any, any>;\n\nfunction requestStateReducer<T, ThunkArg = void, ThunkApiConfig = {}>(\n  asyncThunk: AsyncThunk<T, ThunkArg, ThunkApiConfig>,\n  state: Draft<AsyncRequestState<T>> = initialAsyncRequestState,\n  action: AsyncRequestAction<T>\n): Draft<AsyncRequestState<T>> {\n  if (asyncThunk.pending.match(action)) {\n    return {\n      result: state.result,\n      loading: true,\n      error: state.error,\n      dispatched: true,\n      requestId: action.meta.requestId,\n    };\n  } else if (asyncThunk.fulfilled.match(action)) {\n    if (state.requestId === undefined || state.requestId === action.meta.requestId) {\n      return {\n        ...state,\n        result: action.payload,\n        loading: false,\n        error: undefined,\n      };\n    }\n  } else if (asyncThunk.rejected.match(action)) {\n    if (state.requestId === action.meta.requestId) {\n      return {\n        ...state,\n        loading: false,\n        error: action.error,\n      };\n    }\n  }\n  return state;\n}\n\n/*\n * createAsyncSlice creates a slice based on a given async action, exposing it's state.\n * takes care to only use state of the latest invocation of the action if there are several in flight.\n */\nexport function createAsyncSlice<T, ThunkArg = void, ThunkApiConfig = {}>(\n  name: string,\n  asyncThunk: AsyncThunk<T, ThunkArg, ThunkApiConfig>\n) {\n  return createSlice({\n    name,\n    initialState: initialAsyncRequestState as AsyncRequestState<T>,\n    reducers: {},\n    extraReducers: (builder) =>\n      builder.addDefaultCase((state, action) =>\n        requestStateReducer(asyncThunk, state, action as unknown as AsyncRequestAction<T>)\n      ),\n  });\n}\n\n/*\n * createAsyncMapSlice creates a slice based on a given async action exposing a map of request states.\n * separate requests are uniquely indentified by result of provided getEntityId function\n * takes care to only use state of the latest invocation of the action if there are several in flight.\n */\nexport function createAsyncMapSlice<T, ThunkArg = void, ThunkApiConfig = {}>(\n  name: string,\n  asyncThunk: AsyncThunk<T, ThunkArg, ThunkApiConfig>,\n  getEntityId: (arg: ThunkArg) => string\n) {\n  return createSlice({\n    name,\n    initialState: {} as AsyncRequestMapSlice<T>,\n    reducers: {},\n    extraReducers: (builder) =>\n      builder.addDefaultCase((state, action) => {\n        if (isAsyncThunkAction(asyncThunk)(action)) {\n          const asyncAction = action as unknown as AsyncRequestAction<T>;\n          const entityId = getEntityId(asyncAction.meta.arg);\n          return {\n            ...state,\n            [entityId]: requestStateReducer(asyncThunk, state[entityId], asyncAction),\n          };\n        }\n        return state;\n      }),\n  });\n}\n\n// rethrow promise error in redux serialized format\nexport function withSerializedError<T>(p: Promise<T>): Promise<T> {\n  return p.catch((e) => {\n    const err: SerializedError = {\n      message: messageFromError(e),\n      code: e.statusCode,\n    };\n    throw err;\n  });\n}\n\nexport function withAppEvents<T>(\n  p: Promise<T>,\n  options: { successMessage?: string; errorMessage?: string }\n): Promise<T> {\n  return p\n    .then((v) => {\n      if (options.successMessage) {\n        appEvents.emit(AppEvents.alertSuccess, [options.successMessage]);\n      }\n      return v;\n    })\n    .catch((e) => {\n      const msg = messageFromError(e);\n      appEvents.emit(AppEvents.alertError, [`${options.errorMessage ?? 'Error'}: ${msg}`]);\n      throw e;\n    });\n}\n\nexport function messageFromError(e: Error | FetchError | SerializedError): string {\n  if (isFetchError(e)) {\n    if (e.data?.message) {\n      let msg = e.data?.message;\n      if (typeof e.data?.error === 'string') {\n        msg += `; ${e.data.error}`;\n      }\n      return msg;\n    } else if (Array.isArray(e.data) && e.data.length && e.data[0]?.message) {\n      return e.data\n        .map((d) => d?.message)\n        .filter((m) => !!m)\n        .join(' ');\n    } else if (e.statusText) {\n      return e.statusText;\n    }\n  }\n  return (e as Error)?.message || String(e);\n}\n\nexport function isAsyncRequestMapSliceFulfilled<T>(slice: AsyncRequestMapSlice<T>): boolean {\n  return Object.values(slice).every(isAsyncRequestStateFulfilled);\n}\n\nexport function isAsyncRequestStateFulfilled<T>(state: AsyncRequestState<T>): boolean {\n  return state.dispatched && !state.loading && !state.error;\n}\n\nexport function isAsyncRequestMapSlicePending<T>(slice: AsyncRequestMapSlice<T>): boolean {\n  return Object.values(slice).some(isAsyncRequestStatePending);\n}\n\nexport function isAsyncRequestStatePending<T>(state: AsyncRequestState<T>): boolean {\n  return state.dispatched && state.loading;\n}\n"],"mappings":"AAAA,SAAqBA,WAArB,EAAyCC,kBAAzC,QAAmG,kBAAnG;AAEA,SAASC,SAAT,QAA0B,eAA1B;AACA,SAAqBC,YAArB,QAAyC,kBAAzC;AACA,SAASC,SAAT,QAA0B,eAA1B;AAUA,OAAO,MAAMC,wBAGZ,GAAGC,MAAM,CAACC,MAAP,CAAc;EAChBC,OAAO,EAAE,KADO;EAEhBC,MAAM,EAAEC,SAFQ;EAGhBC,KAAK,EAAED,SAHS;EAIhBE,UAAU,EAAE;AAJI,CAAd,CAHG;;AAcP,SAASC,mBAAT,CACEC,UADF,EAEEC,KAAkC,GAAGV,wBAFvC,EAGEW,MAHF,EAI+B;EAC7B,IAAIF,UAAU,CAACG,OAAX,CAAmBC,KAAnB,CAAyBF,MAAzB,CAAJ,EAAsC;IACpC,OAAO;MACLP,MAAM,EAAEM,KAAK,CAACN,MADT;MAELD,OAAO,EAAE,IAFJ;MAGLG,KAAK,EAAEI,KAAK,CAACJ,KAHR;MAILC,UAAU,EAAE,IAJP;MAKLO,SAAS,EAAEH,MAAM,CAACI,IAAP,CAAYD;IALlB,CAAP;EAOD,CARD,MAQO,IAAIL,UAAU,CAACO,SAAX,CAAqBH,KAArB,CAA2BF,MAA3B,CAAJ,EAAwC;IAC7C,IAAID,KAAK,CAACI,SAAN,KAAoBT,SAApB,IAAiCK,KAAK,CAACI,SAAN,KAAoBH,MAAM,CAACI,IAAP,CAAYD,SAArE,EAAgF;MAC9E,yBACKJ,KADL;QAEEN,MAAM,EAAEO,MAAM,CAACM,OAFjB;QAGEd,OAAO,EAAE,KAHX;QAIEG,KAAK,EAAED;MAJT;IAMD;EACF,CATM,MASA,IAAII,UAAU,CAACS,QAAX,CAAoBL,KAApB,CAA0BF,MAA1B,CAAJ,EAAuC;IAC5C,IAAID,KAAK,CAACI,SAAN,KAAoBH,MAAM,CAACI,IAAP,CAAYD,SAApC,EAA+C;MAC7C,yBACKJ,KADL;QAEEP,OAAO,EAAE,KAFX;QAGEG,KAAK,EAAEK,MAAM,CAACL;MAHhB;IAKD;EACF;;EACD,OAAOI,KAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,OAAO,SAASS,gBAAT,CACLC,IADK,EAELX,UAFK,EAGL;EACA,OAAOd,WAAW,CAAC;IACjByB,IADiB;IAEjBC,YAAY,EAAErB,wBAFG;IAGjBsB,QAAQ,EAAE,EAHO;IAIjBC,aAAa,EAAGC,OAAD,IACbA,OAAO,CAACC,cAAR,CAAuB,CAACf,KAAD,EAAQC,MAAR,KACrBH,mBAAmB,CAACC,UAAD,EAAaC,KAAb,EAAoBC,MAApB,CADrB;EALe,CAAD,CAAlB;AASD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASe,mBAAT,CACLN,IADK,EAELX,UAFK,EAGLkB,WAHK,EAIL;EACA,OAAOhC,WAAW,CAAC;IACjByB,IADiB;IAEjBC,YAAY,EAAE,EAFG;IAGjBC,QAAQ,EAAE,EAHO;IAIjBC,aAAa,EAAGC,OAAD,IACbA,OAAO,CAACC,cAAR,CAAuB,CAACf,KAAD,EAAQC,MAAR,KAAmB;MACxC,IAAIf,kBAAkB,CAACa,UAAD,CAAlB,CAA+BE,MAA/B,CAAJ,EAA4C;QAC1C,MAAMiB,WAAW,GAAGjB,MAApB;QACA,MAAMkB,QAAQ,GAAGF,WAAW,CAACC,WAAW,CAACb,IAAZ,CAAiBe,GAAlB,CAA5B;QACA,yBACKpB,KADL;UAEE,CAACmB,QAAD,GAAYrB,mBAAmB,CAACC,UAAD,EAAaC,KAAK,CAACmB,QAAD,CAAlB,EAA8BD,WAA9B;QAFjC;MAID;;MACD,OAAOlB,KAAP;IACD,CAVD;EALe,CAAD,CAAlB;AAiBD,C,CAED;;AACA,OAAO,SAASqB,mBAAT,CAAgCC,CAAhC,EAA2D;EAChE,OAAOA,CAAC,CAACC,KAAF,CAASC,CAAD,IAAO;IACpB,MAAMC,GAAoB,GAAG;MAC3BC,OAAO,EAAEC,gBAAgB,CAACH,CAAD,CADE;MAE3BI,IAAI,EAAEJ,CAAC,CAACK;IAFmB,CAA7B;IAIA,MAAMJ,GAAN;EACD,CANM,CAAP;AAOD;AAED,OAAO,SAASK,aAAT,CACLR,CADK,EAELS,OAFK,EAGO;EACZ,OAAOT,CAAC,CACLU,IADI,CACEC,CAAD,IAAO;IACX,IAAIF,OAAO,CAACG,cAAZ,EAA4B;MAC1B7C,SAAS,CAAC8C,IAAV,CAAehD,SAAS,CAACiD,YAAzB,EAAuC,CAACL,OAAO,CAACG,cAAT,CAAvC;IACD;;IACD,OAAOD,CAAP;EACD,CANI,EAOJV,KAPI,CAOGC,CAAD,IAAO;IAAA;;IACZ,MAAMa,GAAG,GAAGV,gBAAgB,CAACH,CAAD,CAA5B;IACAnC,SAAS,CAAC8C,IAAV,CAAehD,SAAS,CAACmD,UAAzB,EAAqC,CAAE,GAAD,yBAAGP,OAAO,CAACQ,YAAX,yEAA2B,OAAQ,KAAIF,GAAI,EAA5C,CAArC;IACA,MAAMb,CAAN;EACD,CAXI,CAAP;AAYD;AAED,OAAO,SAASG,gBAAT,CAA0BH,CAA1B,EAA2E;EAChF,IAAIpC,YAAY,CAACoC,CAAD,CAAhB,EAAqB;IAAA;;IACnB,eAAIA,CAAC,CAACgB,IAAN,oCAAI,QAAQd,OAAZ,EAAqB;MAAA;;MACnB,IAAIW,GAAG,eAAGb,CAAC,CAACgB,IAAL,6CAAG,SAAQd,OAAlB;;MACA,IAAI,oBAAOF,CAAC,CAACgB,IAAT,6CAAO,SAAQ5C,KAAf,MAAyB,QAA7B,EAAuC;QACrCyC,GAAG,IAAK,KAAIb,CAAC,CAACgB,IAAF,CAAO5C,KAAM,EAAzB;MACD;;MACD,OAAOyC,GAAP;IACD,CAND,MAMO,IAAII,KAAK,CAACC,OAAN,CAAclB,CAAC,CAACgB,IAAhB,KAAyBhB,CAAC,CAACgB,IAAF,CAAOG,MAAhC,gBAA0CnB,CAAC,CAACgB,IAAF,CAAO,CAAP,CAA1C,qCAA0C,SAAWd,OAAzD,EAAkE;MACvE,OAAOF,CAAC,CAACgB,IAAF,CACJI,GADI,CACCC,CAAD,IAAOA,CAAP,aAAOA,CAAP,uBAAOA,CAAC,CAAEnB,OADV,EAEJoB,MAFI,CAEIC,CAAD,IAAO,CAAC,CAACA,CAFZ,EAGJC,IAHI,CAGC,GAHD,CAAP;IAID,CALM,MAKA,IAAIxB,CAAC,CAACyB,UAAN,EAAkB;MACvB,OAAOzB,CAAC,CAACyB,UAAT;IACD;EACF;;EACD,OAAO,CAACzB,CAAD,aAACA,CAAD,uBAACA,CAAD,CAAcE,OAAd,KAAyBwB,MAAM,CAAC1B,CAAD,CAAtC;AACD;AAED,OAAO,SAAS2B,+BAAT,CAA4CC,KAA5C,EAAqF;EAC1F,OAAO7D,MAAM,CAAC8D,MAAP,CAAcD,KAAd,EAAqBE,KAArB,CAA2BC,4BAA3B,CAAP;AACD;AAED,OAAO,SAASA,4BAAT,CAAyCvD,KAAzC,EAA+E;EACpF,OAAOA,KAAK,CAACH,UAAN,IAAoB,CAACG,KAAK,CAACP,OAA3B,IAAsC,CAACO,KAAK,CAACJ,KAApD;AACD;AAED,OAAO,SAAS4D,6BAAT,CAA0CJ,KAA1C,EAAmF;EACxF,OAAO7D,MAAM,CAAC8D,MAAP,CAAcD,KAAd,EAAqBK,IAArB,CAA0BC,0BAA1B,CAAP;AACD;AAED,OAAO,SAASA,0BAAT,CAAuC1D,KAAvC,EAA6E;EAClF,OAAOA,KAAK,CAACH,UAAN,IAAoBG,KAAK,CAACP,OAAjC;AACD"},"metadata":{},"sourceType":"module"}