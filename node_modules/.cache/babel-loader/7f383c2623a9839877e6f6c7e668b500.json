{"ast":null,"code":"const _excluded = [\"meta\"],\n      _excluded2 = [\"data\", \"error\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { isDataFrame, FieldType } from '@grafana/data';\nimport { getDerivedFields } from './getDerivedFields';\nimport { makeTableFrames } from './makeTableFrames';\nimport { formatQuery, getHighlighterExpressionsFromQuery } from './query_utils';\nimport { dataFrameHasLokiError } from './responseUtils';\nimport { LokiQueryType } from './types';\n\nfunction isMetricFrame(frame) {\n  return frame.fields.every(field => field.type === FieldType.time || field.type === FieldType.number);\n} // returns a new frame, with meta shallow merged with it's original meta\n\n\nfunction setFrameMeta(frame, meta) {\n  const {\n    meta: oldMeta\n  } = frame,\n        rest = _objectWithoutPropertiesLoose(frame, _excluded); // meta maybe be undefined, we need to handle that\n\n\n  const newMeta = Object.assign({}, oldMeta, meta);\n  return Object.assign({}, rest, {\n    meta: newMeta\n  });\n}\n\nfunction processStreamFrame(frame, query, derivedFieldConfigs) {\n  var _frame$meta;\n\n  const custom = Object.assign({}, (_frame$meta = frame.meta) === null || _frame$meta === void 0 ? void 0 : _frame$meta.custom, {\n    // keep the original meta.custom\n    // used by logs_model\n    lokiQueryStatKey: 'Summary: total bytes processed'\n  });\n\n  if (dataFrameHasLokiError(frame)) {\n    custom.error = 'Error when parsing some of the logs';\n  }\n\n  const meta = {\n    preferredVisualisationType: 'logs',\n    limit: query === null || query === void 0 ? void 0 : query.maxLines,\n    searchWords: query !== undefined ? getHighlighterExpressionsFromQuery(formatQuery(query.expr)) : undefined,\n    custom\n  };\n  const newFrame = setFrameMeta(frame, meta);\n  const derivedFields = getDerivedFields(newFrame, derivedFieldConfigs);\n  return Object.assign({}, newFrame, {\n    fields: [...newFrame.fields, ...derivedFields]\n  });\n}\n\nfunction processStreamsFrames(frames, queryMap, derivedFieldConfigs) {\n  return frames.map(frame => {\n    const query = frame.refId !== undefined ? queryMap.get(frame.refId) : undefined;\n    return processStreamFrame(frame, query, derivedFieldConfigs);\n  });\n}\n\nfunction processMetricInstantFrames(frames) {\n  return frames.length > 0 ? makeTableFrames(frames) : [];\n}\n\nfunction processMetricRangeFrames(frames) {\n  const meta = {\n    preferredVisualisationType: 'graph'\n  };\n  return frames.map(frame => setFrameMeta(frame, meta));\n} // we split the frames into 3 groups, because we will handle\n// each group slightly differently\n\n\nfunction groupFrames(frames, queryMap) {\n  const streamsFrames = [];\n  const metricInstantFrames = [];\n  const metricRangeFrames = [];\n  frames.forEach(frame => {\n    if (!isMetricFrame(frame)) {\n      streamsFrames.push(frame);\n    } else {\n      var _queryMap$get;\n\n      const isInstantFrame = frame.refId != null && ((_queryMap$get = queryMap.get(frame.refId)) === null || _queryMap$get === void 0 ? void 0 : _queryMap$get.queryType) === LokiQueryType.Instant;\n\n      if (isInstantFrame) {\n        metricInstantFrames.push(frame);\n      } else {\n        metricRangeFrames.push(frame);\n      }\n    }\n  });\n  return {\n    streamsFrames,\n    metricInstantFrames,\n    metricRangeFrames\n  };\n}\n\nfunction improveError(error, queryMap) {\n  // many things are optional in an error-object, we need an error-message to exist,\n  // and we need to find the loki-query, based on the refId in the error-object.\n  if (error === undefined) {\n    return error;\n  }\n\n  const {\n    refId,\n    message\n  } = error;\n\n  if (refId === undefined || message === undefined) {\n    return error;\n  }\n\n  const query = queryMap.get(refId);\n\n  if (query === undefined) {\n    return error;\n  }\n\n  if (message.includes('escape') && query.expr.includes('\\\\')) {\n    return Object.assign({}, error, {\n      message: `${message}. Make sure that all special characters are escaped with \\\\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`\n    });\n  }\n\n  return error;\n}\n\nexport function transformBackendResult(response, queries, derivedFieldConfigs) {\n  const {\n    data,\n    error\n  } = response,\n        rest = _objectWithoutPropertiesLoose(response, _excluded2); // in the typescript type, data is an array of basically anything.\n  // we do know that they have to be dataframes, so we make a quick check,\n  // this way we can be sure, and also typescript is happy.\n\n\n  const dataFrames = data.map(d => {\n    if (!isDataFrame(d)) {\n      throw new Error('transformation only supports dataframe responses');\n    }\n\n    return d;\n  });\n  const queryMap = new Map(queries.map(query => [query.refId, query]));\n  const {\n    streamsFrames,\n    metricInstantFrames,\n    metricRangeFrames\n  } = groupFrames(dataFrames, queryMap);\n  return Object.assign({}, rest, {\n    error: improveError(error, queryMap),\n    data: [...processMetricRangeFrames(metricRangeFrames), ...processMetricInstantFrames(metricInstantFrames), ...processStreamsFrames(streamsFrames, queryMap, derivedFieldConfigs)]\n  });\n}","map":{"version":3,"names":["isDataFrame","FieldType","getDerivedFields","makeTableFrames","formatQuery","getHighlighterExpressionsFromQuery","dataFrameHasLokiError","LokiQueryType","isMetricFrame","frame","fields","every","field","type","time","number","setFrameMeta","meta","oldMeta","rest","newMeta","processStreamFrame","query","derivedFieldConfigs","custom","lokiQueryStatKey","error","preferredVisualisationType","limit","maxLines","searchWords","undefined","expr","newFrame","derivedFields","processStreamsFrames","frames","queryMap","map","refId","get","processMetricInstantFrames","length","processMetricRangeFrames","groupFrames","streamsFrames","metricInstantFrames","metricRangeFrames","forEach","push","isInstantFrame","queryType","Instant","improveError","message","includes","transformBackendResult","response","queries","data","dataFrames","d","Error","Map"],"sources":["/home/soula/grafana/public/app/plugins/datasource/loki/backendResultTransformer.ts"],"sourcesContent":["import { DataQueryResponse, DataFrame, isDataFrame, FieldType, QueryResultMeta, DataQueryError } from '@grafana/data';\n\nimport { getDerivedFields } from './getDerivedFields';\nimport { makeTableFrames } from './makeTableFrames';\nimport { formatQuery, getHighlighterExpressionsFromQuery } from './query_utils';\nimport { dataFrameHasLokiError } from './responseUtils';\nimport { DerivedFieldConfig, LokiQuery, LokiQueryType } from './types';\n\nfunction isMetricFrame(frame: DataFrame): boolean {\n  return frame.fields.every((field) => field.type === FieldType.time || field.type === FieldType.number);\n}\n\n// returns a new frame, with meta shallow merged with it's original meta\nfunction setFrameMeta(frame: DataFrame, meta: QueryResultMeta): DataFrame {\n  const { meta: oldMeta, ...rest } = frame;\n  // meta maybe be undefined, we need to handle that\n  const newMeta = { ...oldMeta, ...meta };\n  return {\n    ...rest,\n    meta: newMeta,\n  };\n}\n\nfunction processStreamFrame(\n  frame: DataFrame,\n  query: LokiQuery | undefined,\n  derivedFieldConfigs: DerivedFieldConfig[]\n): DataFrame {\n  const custom: Record<string, string> = {\n    ...frame.meta?.custom, // keep the original meta.custom\n    // used by logs_model\n    lokiQueryStatKey: 'Summary: total bytes processed',\n  };\n\n  if (dataFrameHasLokiError(frame)) {\n    custom.error = 'Error when parsing some of the logs';\n  }\n\n  const meta: QueryResultMeta = {\n    preferredVisualisationType: 'logs',\n    limit: query?.maxLines,\n    searchWords: query !== undefined ? getHighlighterExpressionsFromQuery(formatQuery(query.expr)) : undefined,\n    custom,\n  };\n\n  const newFrame = setFrameMeta(frame, meta);\n  const derivedFields = getDerivedFields(newFrame, derivedFieldConfigs);\n  return {\n    ...newFrame,\n    fields: [...newFrame.fields, ...derivedFields],\n  };\n}\n\nfunction processStreamsFrames(\n  frames: DataFrame[],\n  queryMap: Map<string, LokiQuery>,\n  derivedFieldConfigs: DerivedFieldConfig[]\n): DataFrame[] {\n  return frames.map((frame) => {\n    const query = frame.refId !== undefined ? queryMap.get(frame.refId) : undefined;\n    return processStreamFrame(frame, query, derivedFieldConfigs);\n  });\n}\n\nfunction processMetricInstantFrames(frames: DataFrame[]): DataFrame[] {\n  return frames.length > 0 ? makeTableFrames(frames) : [];\n}\n\nfunction processMetricRangeFrames(frames: DataFrame[]): DataFrame[] {\n  const meta: QueryResultMeta = { preferredVisualisationType: 'graph' };\n  return frames.map((frame) => setFrameMeta(frame, meta));\n}\n\n// we split the frames into 3 groups, because we will handle\n// each group slightly differently\nfunction groupFrames(\n  frames: DataFrame[],\n  queryMap: Map<string, LokiQuery>\n): {\n  streamsFrames: DataFrame[];\n  metricInstantFrames: DataFrame[];\n  metricRangeFrames: DataFrame[];\n} {\n  const streamsFrames: DataFrame[] = [];\n  const metricInstantFrames: DataFrame[] = [];\n  const metricRangeFrames: DataFrame[] = [];\n\n  frames.forEach((frame) => {\n    if (!isMetricFrame(frame)) {\n      streamsFrames.push(frame);\n    } else {\n      const isInstantFrame = frame.refId != null && queryMap.get(frame.refId)?.queryType === LokiQueryType.Instant;\n      if (isInstantFrame) {\n        metricInstantFrames.push(frame);\n      } else {\n        metricRangeFrames.push(frame);\n      }\n    }\n  });\n\n  return { streamsFrames, metricInstantFrames, metricRangeFrames };\n}\n\nfunction improveError(error: DataQueryError | undefined, queryMap: Map<string, LokiQuery>): DataQueryError | undefined {\n  // many things are optional in an error-object, we need an error-message to exist,\n  // and we need to find the loki-query, based on the refId in the error-object.\n  if (error === undefined) {\n    return error;\n  }\n\n  const { refId, message } = error;\n  if (refId === undefined || message === undefined) {\n    return error;\n  }\n\n  const query = queryMap.get(refId);\n  if (query === undefined) {\n    return error;\n  }\n\n  if (message.includes('escape') && query.expr.includes('\\\\')) {\n    return {\n      ...error,\n      message: `${message}. Make sure that all special characters are escaped with \\\\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`,\n    };\n  }\n\n  return error;\n}\n\nexport function transformBackendResult(\n  response: DataQueryResponse,\n  queries: LokiQuery[],\n  derivedFieldConfigs: DerivedFieldConfig[]\n): DataQueryResponse {\n  const { data, error, ...rest } = response;\n\n  // in the typescript type, data is an array of basically anything.\n  // we do know that they have to be dataframes, so we make a quick check,\n  // this way we can be sure, and also typescript is happy.\n  const dataFrames = data.map((d) => {\n    if (!isDataFrame(d)) {\n      throw new Error('transformation only supports dataframe responses');\n    }\n    return d;\n  });\n\n  const queryMap = new Map(queries.map((query) => [query.refId, query]));\n\n  const { streamsFrames, metricInstantFrames, metricRangeFrames } = groupFrames(dataFrames, queryMap);\n\n  return {\n    ...rest,\n    error: improveError(error, queryMap),\n    data: [\n      ...processMetricRangeFrames(metricRangeFrames),\n      ...processMetricInstantFrames(metricInstantFrames),\n      ...processStreamsFrames(streamsFrames, queryMap, derivedFieldConfigs),\n    ],\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}