{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { PureComponent } from 'react';\nimport { VizOrientation } from '@grafana/data';\nimport { calculateGridDimensions } from '../../utils/squares';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport class VizRepeater extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      values: props.getValues()\n    };\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      renderCounter,\n      source\n    } = this.props;\n\n    if (renderCounter !== prevProps.renderCounter || source !== prevProps.source) {\n      this.setState({\n        values: this.props.getValues()\n      });\n    }\n  }\n\n  getOrientation() {\n    const {\n      orientation,\n      width,\n      height\n    } = this.props;\n\n    if (orientation === VizOrientation.Auto) {\n      if (width > height) {\n        return VizOrientation.Vertical;\n      } else {\n        return VizOrientation.Horizontal;\n      }\n    }\n\n    return orientation;\n  }\n\n  renderGrid() {\n    const {\n      renderValue,\n      height,\n      width,\n      itemSpacing,\n      getAlignmentFactors,\n      orientation\n    } = this.props;\n    const {\n      values\n    } = this.state;\n    const grid = calculateGridDimensions(width, height, itemSpacing, values.length);\n    const alignmentFactors = getAlignmentFactors ? getAlignmentFactors(values, grid.width, grid.height) : {};\n    let xGrid = 0;\n    let yGrid = 0;\n    let items = [];\n\n    for (let i = 0; i < values.length; i++) {\n      const value = values[i];\n      const isLastRow = yGrid === grid.yCount - 1;\n      const itemWidth = isLastRow ? grid.widthOnLastRow : grid.width;\n      const itemHeight = grid.height;\n      const xPos = xGrid * itemWidth + itemSpacing * xGrid;\n      const yPos = yGrid * itemHeight + itemSpacing * yGrid;\n      const itemStyles = {\n        position: 'absolute',\n        left: xPos,\n        top: yPos,\n        width: `${itemWidth}px`,\n        height: `${itemHeight}px`\n      };\n      items.push( /*#__PURE__*/_jsx(\"div\", {\n        style: itemStyles,\n        children: renderValue({\n          value,\n          width: itemWidth,\n          height: itemHeight,\n          alignmentFactors,\n          orientation,\n          count: values.length\n        })\n      }, i));\n      xGrid++;\n\n      if (xGrid === grid.xCount) {\n        xGrid = 0;\n        yGrid++;\n      }\n    }\n\n    return /*#__PURE__*/_jsx(\"div\", {\n      style: {\n        position: 'relative'\n      },\n      children: items\n    });\n  }\n\n  render() {\n    const {\n      renderValue,\n      height,\n      width,\n      itemSpacing,\n      getAlignmentFactors,\n      autoGrid,\n      orientation,\n      minVizWidth,\n      minVizHeight\n    } = this.props;\n    const {\n      values\n    } = this.state;\n\n    if (autoGrid && orientation === VizOrientation.Auto) {\n      return this.renderGrid();\n    }\n\n    const itemStyles = {\n      display: 'flex'\n    };\n    const repeaterStyle = {\n      display: 'flex',\n      overflow: `${minVizWidth ? 'auto' : 'hidden'} ${minVizHeight ? 'auto' : 'hidden'}`\n    };\n    let vizHeight = height;\n    let vizWidth = width;\n    let resolvedOrientation = this.getOrientation();\n\n    switch (resolvedOrientation) {\n      case VizOrientation.Horizontal:\n        repeaterStyle.flexDirection = 'column';\n        repeaterStyle.height = `${height}px`;\n        itemStyles.marginBottom = `${itemSpacing}px`;\n        vizWidth = width;\n        vizHeight = Math.max(height / values.length - itemSpacing + itemSpacing / values.length, minVizHeight !== null && minVizHeight !== void 0 ? minVizHeight : 0);\n        break;\n\n      case VizOrientation.Vertical:\n        repeaterStyle.flexDirection = 'row';\n        repeaterStyle.justifyContent = 'space-between';\n        itemStyles.marginRight = `${itemSpacing}px`;\n        vizHeight = height;\n        vizWidth = Math.max(width / values.length - itemSpacing + itemSpacing / values.length, minVizWidth !== null && minVizWidth !== void 0 ? minVizWidth : 0);\n    }\n\n    itemStyles.width = `${vizWidth}px`;\n    itemStyles.height = `${vizHeight}px`;\n    const alignmentFactors = getAlignmentFactors ? getAlignmentFactors(values, vizWidth, vizHeight) : {};\n    return /*#__PURE__*/_jsx(\"div\", {\n      style: repeaterStyle,\n      children: values.map((value, index) => {\n        return /*#__PURE__*/_jsx(\"div\", {\n          style: getItemStylesForIndex(itemStyles, index, values.length),\n          children: renderValue({\n            value,\n            width: vizWidth,\n            height: vizHeight,\n            alignmentFactors,\n            orientation: resolvedOrientation,\n            count: values.length\n          })\n        }, index);\n      })\n    });\n  }\n\n}\n/*\n * Removes any padding on the last item\n */\n\n_defineProperty(VizRepeater, \"defaultProps\", {\n  itemSpacing: 8\n});\n\nfunction getItemStylesForIndex(itemStyles, index, length) {\n  if (index === length - 1) {\n    return Object.assign({}, itemStyles, {\n      marginRight: 0,\n      marginBottom: 0\n    });\n  }\n\n  return itemStyles;\n}","map":{"version":3,"names":["React","PureComponent","VizOrientation","calculateGridDimensions","VizRepeater","constructor","props","state","values","getValues","componentDidUpdate","prevProps","renderCounter","source","setState","getOrientation","orientation","width","height","Auto","Vertical","Horizontal","renderGrid","renderValue","itemSpacing","getAlignmentFactors","grid","length","alignmentFactors","xGrid","yGrid","items","i","value","isLastRow","yCount","itemWidth","widthOnLastRow","itemHeight","xPos","yPos","itemStyles","position","left","top","push","count","xCount","render","autoGrid","minVizWidth","minVizHeight","display","repeaterStyle","overflow","vizHeight","vizWidth","resolvedOrientation","flexDirection","marginBottom","Math","max","justifyContent","marginRight","map","index","getItemStylesForIndex"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/VizRepeater/VizRepeater.tsx"],"sourcesContent":["import React, { PureComponent, CSSProperties } from 'react';\n\nimport { VizOrientation } from '@grafana/data';\n\nimport { calculateGridDimensions } from '../../utils/squares';\n\ninterface Props<V, D> {\n  /**\n   * Optionally precalculate dimensions to support consistent behavior between repeated\n   * values.  Two typical patterns are:\n   * 1) Calculate raw values like font size etc and pass them to each vis\n   * 2) find the maximum input values and pass that to the vis\n   */\n  getAlignmentFactors?: (values: V[], width: number, height: number) => D;\n\n  /**\n   * Render a single value\n   */\n  renderValue: (props: VizRepeaterRenderValueProps<V, D>) => JSX.Element;\n  height: number;\n  width: number;\n  source: any; // If this changes, new values will be requested\n  getValues: () => V[];\n  renderCounter: number; // force update of values & render\n  orientation: VizOrientation;\n  itemSpacing?: number;\n  /** When orientation is set to auto layout items in a grid */\n  autoGrid?: boolean;\n  minVizWidth?: number;\n  minVizHeight?: number;\n}\n\nexport interface VizRepeaterRenderValueProps<V, D = {}> {\n  value: V;\n  width: number;\n  height: number;\n  orientation: VizOrientation;\n  alignmentFactors: D;\n  /**\n   * Total number of values being shown in repeater\n   */\n  count: number;\n}\n\ninterface DefaultProps {\n  itemSpacing: number;\n}\n\ntype PropsWithDefaults<V, D> = Props<V, D> & DefaultProps;\n\ninterface State<V> {\n  values: V[];\n}\n\nexport class VizRepeater<V, D = {}> extends PureComponent<Props<V, D>, State<V>> {\n  static defaultProps: DefaultProps = {\n    itemSpacing: 8,\n  };\n\n  constructor(props: Props<V, D>) {\n    super(props);\n\n    this.state = {\n      values: props.getValues(),\n    };\n  }\n\n  componentDidUpdate(prevProps: Props<V, D>) {\n    const { renderCounter, source } = this.props;\n    if (renderCounter !== prevProps.renderCounter || source !== prevProps.source) {\n      this.setState({ values: this.props.getValues() });\n    }\n  }\n\n  getOrientation(): VizOrientation {\n    const { orientation, width, height } = this.props;\n\n    if (orientation === VizOrientation.Auto) {\n      if (width > height) {\n        return VizOrientation.Vertical;\n      } else {\n        return VizOrientation.Horizontal;\n      }\n    }\n\n    return orientation;\n  }\n\n  renderGrid() {\n    const { renderValue, height, width, itemSpacing, getAlignmentFactors, orientation } = this\n      .props as PropsWithDefaults<V, D>;\n\n    const { values } = this.state;\n    const grid = calculateGridDimensions(width, height, itemSpacing, values.length);\n    const alignmentFactors = getAlignmentFactors ? getAlignmentFactors(values, grid.width, grid.height) : ({} as D);\n\n    let xGrid = 0;\n    let yGrid = 0;\n    let items: JSX.Element[] = [];\n\n    for (let i = 0; i < values.length; i++) {\n      const value = values[i];\n      const isLastRow = yGrid === grid.yCount - 1;\n\n      const itemWidth = isLastRow ? grid.widthOnLastRow : grid.width;\n      const itemHeight = grid.height;\n\n      const xPos = xGrid * itemWidth + itemSpacing * xGrid;\n      const yPos = yGrid * itemHeight + itemSpacing * yGrid;\n\n      const itemStyles: CSSProperties = {\n        position: 'absolute',\n        left: xPos,\n        top: yPos,\n        width: `${itemWidth}px`,\n        height: `${itemHeight}px`,\n      };\n\n      items.push(\n        <div key={i} style={itemStyles}>\n          {renderValue({\n            value,\n            width: itemWidth,\n            height: itemHeight,\n            alignmentFactors,\n            orientation,\n            count: values.length,\n          })}\n        </div>\n      );\n\n      xGrid++;\n\n      if (xGrid === grid.xCount) {\n        xGrid = 0;\n        yGrid++;\n      }\n    }\n\n    return <div style={{ position: 'relative' }}>{items}</div>;\n  }\n\n  render() {\n    const {\n      renderValue,\n      height,\n      width,\n      itemSpacing,\n      getAlignmentFactors,\n      autoGrid,\n      orientation,\n      minVizWidth,\n      minVizHeight,\n    } = this.props as PropsWithDefaults<V, D>;\n    const { values } = this.state;\n\n    if (autoGrid && orientation === VizOrientation.Auto) {\n      return this.renderGrid();\n    }\n\n    const itemStyles: React.CSSProperties = {\n      display: 'flex',\n    };\n\n    const repeaterStyle: React.CSSProperties = {\n      display: 'flex',\n      overflow: `${minVizWidth ? 'auto' : 'hidden'} ${minVizHeight ? 'auto' : 'hidden'}`,\n    };\n\n    let vizHeight = height;\n    let vizWidth = width;\n\n    let resolvedOrientation = this.getOrientation();\n\n    switch (resolvedOrientation) {\n      case VizOrientation.Horizontal:\n        repeaterStyle.flexDirection = 'column';\n        repeaterStyle.height = `${height}px`;\n        itemStyles.marginBottom = `${itemSpacing}px`;\n        vizWidth = width;\n        vizHeight = Math.max(height / values.length - itemSpacing + itemSpacing / values.length, minVizHeight ?? 0);\n        break;\n      case VizOrientation.Vertical:\n        repeaterStyle.flexDirection = 'row';\n        repeaterStyle.justifyContent = 'space-between';\n        itemStyles.marginRight = `${itemSpacing}px`;\n        vizHeight = height;\n        vizWidth = Math.max(width / values.length - itemSpacing + itemSpacing / values.length, minVizWidth ?? 0);\n    }\n\n    itemStyles.width = `${vizWidth}px`;\n    itemStyles.height = `${vizHeight}px`;\n\n    const alignmentFactors = getAlignmentFactors ? getAlignmentFactors(values, vizWidth, vizHeight) : ({} as D);\n\n    return (\n      <div style={repeaterStyle}>\n        {values.map((value, index) => {\n          return (\n            <div key={index} style={getItemStylesForIndex(itemStyles, index, values.length)}>\n              {renderValue({\n                value,\n                width: vizWidth,\n                height: vizHeight,\n                alignmentFactors,\n                orientation: resolvedOrientation,\n                count: values.length,\n              })}\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n}\n\n/*\n * Removes any padding on the last item\n */\nfunction getItemStylesForIndex(itemStyles: CSSProperties, index: number, length: number): CSSProperties {\n  if (index === length - 1) {\n    return {\n      ...itemStyles,\n      marginRight: 0,\n      marginBottom: 0,\n    };\n  }\n  return itemStyles;\n}\n"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,aAAhB,QAAoD,OAApD;AAEA,SAASC,cAAT,QAA+B,eAA/B;AAEA,SAASC,uBAAT,QAAwC,qBAAxC;;AAkDA,OAAO,MAAMC,WAAN,SAAqCH,aAArC,CAA0E;EAK/EI,WAAW,CAACC,KAAD,EAAqB;IAC9B,MAAMA,KAAN;IAEA,KAAKC,KAAL,GAAa;MACXC,MAAM,EAAEF,KAAK,CAACG,SAAN;IADG,CAAb;EAGD;;EAEDC,kBAAkB,CAACC,SAAD,EAAyB;IACzC,MAAM;MAAEC,aAAF;MAAiBC;IAAjB,IAA4B,KAAKP,KAAvC;;IACA,IAAIM,aAAa,KAAKD,SAAS,CAACC,aAA5B,IAA6CC,MAAM,KAAKF,SAAS,CAACE,MAAtE,EAA8E;MAC5E,KAAKC,QAAL,CAAc;QAAEN,MAAM,EAAE,KAAKF,KAAL,CAAWG,SAAX;MAAV,CAAd;IACD;EACF;;EAEDM,cAAc,GAAmB;IAC/B,MAAM;MAAEC,WAAF;MAAeC,KAAf;MAAsBC;IAAtB,IAAiC,KAAKZ,KAA5C;;IAEA,IAAIU,WAAW,KAAKd,cAAc,CAACiB,IAAnC,EAAyC;MACvC,IAAIF,KAAK,GAAGC,MAAZ,EAAoB;QAClB,OAAOhB,cAAc,CAACkB,QAAtB;MACD,CAFD,MAEO;QACL,OAAOlB,cAAc,CAACmB,UAAtB;MACD;IACF;;IAED,OAAOL,WAAP;EACD;;EAEDM,UAAU,GAAG;IACX,MAAM;MAAEC,WAAF;MAAeL,MAAf;MAAuBD,KAAvB;MAA8BO,WAA9B;MAA2CC,mBAA3C;MAAgET;IAAhE,IAAgF,KACnFV,KADH;IAGA,MAAM;MAAEE;IAAF,IAAa,KAAKD,KAAxB;IACA,MAAMmB,IAAI,GAAGvB,uBAAuB,CAACc,KAAD,EAAQC,MAAR,EAAgBM,WAAhB,EAA6BhB,MAAM,CAACmB,MAApC,CAApC;IACA,MAAMC,gBAAgB,GAAGH,mBAAmB,GAAGA,mBAAmB,CAACjB,MAAD,EAASkB,IAAI,CAACT,KAAd,EAAqBS,IAAI,CAACR,MAA1B,CAAtB,GAA2D,EAAvG;IAEA,IAAIW,KAAK,GAAG,CAAZ;IACA,IAAIC,KAAK,GAAG,CAAZ;IACA,IAAIC,KAAoB,GAAG,EAA3B;;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxB,MAAM,CAACmB,MAA3B,EAAmCK,CAAC,EAApC,EAAwC;MACtC,MAAMC,KAAK,GAAGzB,MAAM,CAACwB,CAAD,CAApB;MACA,MAAME,SAAS,GAAGJ,KAAK,KAAKJ,IAAI,CAACS,MAAL,GAAc,CAA1C;MAEA,MAAMC,SAAS,GAAGF,SAAS,GAAGR,IAAI,CAACW,cAAR,GAAyBX,IAAI,CAACT,KAAzD;MACA,MAAMqB,UAAU,GAAGZ,IAAI,CAACR,MAAxB;MAEA,MAAMqB,IAAI,GAAGV,KAAK,GAAGO,SAAR,GAAoBZ,WAAW,GAAGK,KAA/C;MACA,MAAMW,IAAI,GAAGV,KAAK,GAAGQ,UAAR,GAAqBd,WAAW,GAAGM,KAAhD;MAEA,MAAMW,UAAyB,GAAG;QAChCC,QAAQ,EAAE,UADsB;QAEhCC,IAAI,EAAEJ,IAF0B;QAGhCK,GAAG,EAAEJ,IAH2B;QAIhCvB,KAAK,EAAG,GAAEmB,SAAU,IAJY;QAKhClB,MAAM,EAAG,GAAEoB,UAAW;MALU,CAAlC;MAQAP,KAAK,CAACc,IAAN,eACE;QAAa,KAAK,EAAEJ,UAApB;QAAA,UACGlB,WAAW,CAAC;UACXU,KADW;UAEXhB,KAAK,EAAEmB,SAFI;UAGXlB,MAAM,EAAEoB,UAHG;UAIXV,gBAJW;UAKXZ,WALW;UAMX8B,KAAK,EAAEtC,MAAM,CAACmB;QANH,CAAD;MADd,GAAUK,CAAV,CADF;MAaAH,KAAK;;MAEL,IAAIA,KAAK,KAAKH,IAAI,CAACqB,MAAnB,EAA2B;QACzBlB,KAAK,GAAG,CAAR;QACAC,KAAK;MACN;IACF;;IAED,oBAAO;MAAK,KAAK,EAAE;QAAEY,QAAQ,EAAE;MAAZ,CAAZ;MAAA,UAAuCX;IAAvC,EAAP;EACD;;EAEDiB,MAAM,GAAG;IACP,MAAM;MACJzB,WADI;MAEJL,MAFI;MAGJD,KAHI;MAIJO,WAJI;MAKJC,mBALI;MAMJwB,QANI;MAOJjC,WAPI;MAQJkC,WARI;MASJC;IATI,IAUF,KAAK7C,KAVT;IAWA,MAAM;MAAEE;IAAF,IAAa,KAAKD,KAAxB;;IAEA,IAAI0C,QAAQ,IAAIjC,WAAW,KAAKd,cAAc,CAACiB,IAA/C,EAAqD;MACnD,OAAO,KAAKG,UAAL,EAAP;IACD;;IAED,MAAMmB,UAA+B,GAAG;MACtCW,OAAO,EAAE;IAD6B,CAAxC;IAIA,MAAMC,aAAkC,GAAG;MACzCD,OAAO,EAAE,MADgC;MAEzCE,QAAQ,EAAG,GAAEJ,WAAW,GAAG,MAAH,GAAY,QAAS,IAAGC,YAAY,GAAG,MAAH,GAAY,QAAS;IAFxC,CAA3C;IAKA,IAAII,SAAS,GAAGrC,MAAhB;IACA,IAAIsC,QAAQ,GAAGvC,KAAf;IAEA,IAAIwC,mBAAmB,GAAG,KAAK1C,cAAL,EAA1B;;IAEA,QAAQ0C,mBAAR;MACE,KAAKvD,cAAc,CAACmB,UAApB;QACEgC,aAAa,CAACK,aAAd,GAA8B,QAA9B;QACAL,aAAa,CAACnC,MAAd,GAAwB,GAAEA,MAAO,IAAjC;QACAuB,UAAU,CAACkB,YAAX,GAA2B,GAAEnC,WAAY,IAAzC;QACAgC,QAAQ,GAAGvC,KAAX;QACAsC,SAAS,GAAGK,IAAI,CAACC,GAAL,CAAS3C,MAAM,GAAGV,MAAM,CAACmB,MAAhB,GAAyBH,WAAzB,GAAuCA,WAAW,GAAGhB,MAAM,CAACmB,MAArE,EAA6EwB,YAA7E,aAA6EA,YAA7E,cAA6EA,YAA7E,GAA6F,CAA7F,CAAZ;QACA;;MACF,KAAKjD,cAAc,CAACkB,QAApB;QACEiC,aAAa,CAACK,aAAd,GAA8B,KAA9B;QACAL,aAAa,CAACS,cAAd,GAA+B,eAA/B;QACArB,UAAU,CAACsB,WAAX,GAA0B,GAAEvC,WAAY,IAAxC;QACA+B,SAAS,GAAGrC,MAAZ;QACAsC,QAAQ,GAAGI,IAAI,CAACC,GAAL,CAAS5C,KAAK,GAAGT,MAAM,CAACmB,MAAf,GAAwBH,WAAxB,GAAsCA,WAAW,GAAGhB,MAAM,CAACmB,MAApE,EAA4EuB,WAA5E,aAA4EA,WAA5E,cAA4EA,WAA5E,GAA2F,CAA3F,CAAX;IAbJ;;IAgBAT,UAAU,CAACxB,KAAX,GAAoB,GAAEuC,QAAS,IAA/B;IACAf,UAAU,CAACvB,MAAX,GAAqB,GAAEqC,SAAU,IAAjC;IAEA,MAAM3B,gBAAgB,GAAGH,mBAAmB,GAAGA,mBAAmB,CAACjB,MAAD,EAASgD,QAAT,EAAmBD,SAAnB,CAAtB,GAAuD,EAAnG;IAEA,oBACE;MAAK,KAAK,EAAEF,aAAZ;MAAA,UACG7C,MAAM,CAACwD,GAAP,CAAW,CAAC/B,KAAD,EAAQgC,KAAR,KAAkB;QAC5B,oBACE;UAAiB,KAAK,EAAEC,qBAAqB,CAACzB,UAAD,EAAawB,KAAb,EAAoBzD,MAAM,CAACmB,MAA3B,CAA7C;UAAA,UACGJ,WAAW,CAAC;YACXU,KADW;YAEXhB,KAAK,EAAEuC,QAFI;YAGXtC,MAAM,EAAEqC,SAHG;YAIX3B,gBAJW;YAKXZ,WAAW,EAAEyC,mBALF;YAMXX,KAAK,EAAEtC,MAAM,CAACmB;UANH,CAAD;QADd,GAAUsC,KAAV,CADF;MAYD,CAbA;IADH,EADF;EAkBD;;AA/J8E;AAkKjF;AACA;AACA;;gBApKa7D,W,kBACyB;EAClCoB,WAAW,EAAE;AADqB,C;;AAoKtC,SAAS0C,qBAAT,CAA+BzB,UAA/B,EAA0DwB,KAA1D,EAAyEtC,MAAzE,EAAwG;EACtG,IAAIsC,KAAK,KAAKtC,MAAM,GAAG,CAAvB,EAA0B;IACxB,yBACKc,UADL;MAEEsB,WAAW,EAAE,CAFf;MAGEJ,YAAY,EAAE;IAHhB;EAKD;;EACD,OAAOlB,UAAP;AACD"},"metadata":{},"sourceType":"module"}