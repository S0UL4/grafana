{"ast":null,"code":"import { cx } from '@emotion/css';\nimport React, { useCallback } from 'react';\nimport { satisfies } from 'semver';\nimport { InlineSegmentGroup, Segment, SegmentAsync, useTheme2 } from '@grafana/ui';\nimport { useFields } from '../../../hooks/useFields';\nimport { useDispatch } from '../../../hooks/useStatelessReducer';\nimport { MetricPicker } from '../../MetricPicker';\nimport { useDatasource, useQuery } from '../ElasticsearchQueryContext';\nimport { segmentStyles } from '../styles';\nimport { SettingsEditor } from './SettingsEditor';\nimport { isMetricAggregationWithField, isMetricAggregationWithInlineScript, isMetricAggregationWithSettings, isPipelineAggregation, isPipelineAggregationWithMultipleBucketPaths } from './aggregations';\nimport { changeMetricField, changeMetricType } from './state/actions';\nimport { getStyles } from './styles';\nimport { metricAggregationConfig } from './utils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\n\nconst toOption = metric => ({\n  label: metricAggregationConfig[metric.type].label,\n  value: metric.type\n});\n\n// If a metric is a Pipeline Aggregation (https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline.html)\n// it doesn't make sense to show it in the type picker when there is no non-pipeline-aggregation previously selected\n// as they work on the outputs produced from other aggregations rather than from documents or fields.\n// This means we should filter them out from the type picker if there's no other \"basic\" aggregation before the current one.\nconst isBasicAggregation = metric => !metricAggregationConfig[metric.type].isPipelineAgg;\n\nconst getTypeOptions = (previousMetrics, esVersion, xpack = false) => {\n  // we'll include Pipeline Aggregations only if at least one previous metric is a \"Basic\" one\n  const includePipelineAggregations = previousMetrics.some(isBasicAggregation);\n  return Object.entries(metricAggregationConfig) // Only showing metrics type supported by the configured version of ES\n  .filter(([_, {\n    versionRange = '*'\n  }]) => satisfies(esVersion, versionRange)) // Filtering out Pipeline Aggregations if there's no basic metric selected before\n  .filter(([_, config]) => includePipelineAggregations || !config.isPipelineAgg) // Filtering out X-Pack plugins if X-Pack is disabled\n  .filter(([_, config]) => config.xpack ? xpack : true).map(([key, {\n    label\n  }]) => ({\n    label,\n    value: key\n  }));\n};\n\nexport const MetricEditor = ({\n  value\n}) => {\n  const styles = getStyles(useTheme2(), !!value.hide);\n  const datasource = useDatasource();\n  const query = useQuery();\n  const dispatch = useDispatch();\n  const getFields = useFields(value.type);\n  const loadOptions = useCallback(async () => {\n    const remoteFields = await getFields(); // Metric aggregations that have inline script support don't require a field to be set.\n\n    if (isMetricAggregationWithInlineScript(value)) {\n      return [{\n        label: 'None'\n      }, ...remoteFields];\n    }\n\n    return remoteFields;\n  }, [getFields, value]);\n  const previousMetrics = query.metrics.slice(0, query.metrics.findIndex(m => m.id === value.id));\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [/*#__PURE__*/_jsxs(InlineSegmentGroup, {\n      children: [/*#__PURE__*/_jsx(Segment, {\n        className: cx(styles.color, segmentStyles),\n        options: getTypeOptions(previousMetrics, datasource.esVersion, datasource.xpack),\n        onChange: e => dispatch(changeMetricType({\n          id: value.id,\n          type: e.value\n        })),\n        value: toOption(value)\n      }), isMetricAggregationWithField(value) && !isPipelineAggregation(value) && /*#__PURE__*/_jsx(SegmentAsync, {\n        className: cx(styles.color, segmentStyles),\n        loadOptions: loadOptions,\n        onChange: e => dispatch(changeMetricField({\n          id: value.id,\n          field: e.value\n        })),\n        placeholder: \"Select Field\",\n        value: value.field\n      }), isPipelineAggregation(value) && !isPipelineAggregationWithMultipleBucketPaths(value) && /*#__PURE__*/_jsx(MetricPicker, {\n        className: cx(styles.color, segmentStyles),\n        onChange: e => {\n          var _e$value;\n\n          return dispatch(changeMetricField({\n            id: value.id,\n            field: (_e$value = e.value) === null || _e$value === void 0 ? void 0 : _e$value.id\n          }));\n        },\n        options: previousMetrics,\n        value: value.field\n      })]\n    }), isMetricAggregationWithSettings(value) && /*#__PURE__*/_jsx(SettingsEditor, {\n      metric: value,\n      previousMetrics: previousMetrics\n    })]\n  });\n};","map":{"version":3,"names":["cx","React","useCallback","satisfies","InlineSegmentGroup","Segment","SegmentAsync","useTheme2","useFields","useDispatch","MetricPicker","useDatasource","useQuery","segmentStyles","SettingsEditor","isMetricAggregationWithField","isMetricAggregationWithInlineScript","isMetricAggregationWithSettings","isPipelineAggregation","isPipelineAggregationWithMultipleBucketPaths","changeMetricField","changeMetricType","getStyles","metricAggregationConfig","toOption","metric","label","type","value","isBasicAggregation","isPipelineAgg","getTypeOptions","previousMetrics","esVersion","xpack","includePipelineAggregations","some","Object","entries","filter","_","versionRange","config","map","key","MetricEditor","styles","hide","datasource","query","dispatch","getFields","loadOptions","remoteFields","metrics","slice","findIndex","m","id","color","e","field"],"sources":["/home/soula/grafana/public/app/plugins/datasource/elasticsearch/components/QueryEditor/MetricAggregationsEditor/MetricEditor.tsx"],"sourcesContent":["import { cx } from '@emotion/css';\nimport React, { useCallback } from 'react';\nimport { satisfies } from 'semver';\n\nimport { SelectableValue } from '@grafana/data';\nimport { InlineSegmentGroup, Segment, SegmentAsync, useTheme2 } from '@grafana/ui';\n\nimport { useFields } from '../../../hooks/useFields';\nimport { useDispatch } from '../../../hooks/useStatelessReducer';\nimport { MetricPicker } from '../../MetricPicker';\nimport { useDatasource, useQuery } from '../ElasticsearchQueryContext';\nimport { segmentStyles } from '../styles';\n\nimport { SettingsEditor } from './SettingsEditor';\nimport {\n  isMetricAggregationWithField,\n  isMetricAggregationWithInlineScript,\n  isMetricAggregationWithSettings,\n  isPipelineAggregation,\n  isPipelineAggregationWithMultipleBucketPaths,\n  MetricAggregation,\n  MetricAggregationType,\n} from './aggregations';\nimport { changeMetricField, changeMetricType } from './state/actions';\nimport { getStyles } from './styles';\nimport { metricAggregationConfig } from './utils';\n\nconst toOption = (metric: MetricAggregation) => ({\n  label: metricAggregationConfig[metric.type].label,\n  value: metric.type,\n});\n\ninterface Props {\n  value: MetricAggregation;\n}\n\n// If a metric is a Pipeline Aggregation (https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline.html)\n// it doesn't make sense to show it in the type picker when there is no non-pipeline-aggregation previously selected\n// as they work on the outputs produced from other aggregations rather than from documents or fields.\n// This means we should filter them out from the type picker if there's no other \"basic\" aggregation before the current one.\nconst isBasicAggregation = (metric: MetricAggregation) => !metricAggregationConfig[metric.type].isPipelineAgg;\n\nconst getTypeOptions = (\n  previousMetrics: MetricAggregation[],\n  esVersion: string,\n  xpack = false\n): Array<SelectableValue<MetricAggregationType>> => {\n  // we'll include Pipeline Aggregations only if at least one previous metric is a \"Basic\" one\n  const includePipelineAggregations = previousMetrics.some(isBasicAggregation);\n\n  return (\n    Object.entries(metricAggregationConfig)\n      // Only showing metrics type supported by the configured version of ES\n      .filter(([_, { versionRange = '*' }]) => satisfies(esVersion, versionRange))\n      // Filtering out Pipeline Aggregations if there's no basic metric selected before\n      .filter(([_, config]) => includePipelineAggregations || !config.isPipelineAgg)\n      // Filtering out X-Pack plugins if X-Pack is disabled\n      .filter(([_, config]) => (config.xpack ? xpack : true))\n      .map(([key, { label }]) => ({\n        label,\n        value: key as MetricAggregationType,\n      }))\n  );\n};\n\nexport const MetricEditor = ({ value }: Props) => {\n  const styles = getStyles(useTheme2(), !!value.hide);\n  const datasource = useDatasource();\n  const query = useQuery();\n  const dispatch = useDispatch();\n  const getFields = useFields(value.type);\n\n  const loadOptions = useCallback(async () => {\n    const remoteFields = await getFields();\n\n    // Metric aggregations that have inline script support don't require a field to be set.\n    if (isMetricAggregationWithInlineScript(value)) {\n      return [{ label: 'None' }, ...remoteFields];\n    }\n\n    return remoteFields;\n  }, [getFields, value]);\n\n  const previousMetrics = query.metrics!.slice(\n    0,\n    query.metrics!.findIndex((m) => m.id === value.id)\n  );\n\n  return (\n    <>\n      <InlineSegmentGroup>\n        <Segment\n          className={cx(styles.color, segmentStyles)}\n          options={getTypeOptions(previousMetrics, datasource.esVersion, datasource.xpack)}\n          onChange={(e) => dispatch(changeMetricType({ id: value.id, type: e.value! }))}\n          value={toOption(value)}\n        />\n\n        {isMetricAggregationWithField(value) && !isPipelineAggregation(value) && (\n          <SegmentAsync\n            className={cx(styles.color, segmentStyles)}\n            loadOptions={loadOptions}\n            onChange={(e) => dispatch(changeMetricField({ id: value.id, field: e.value! }))}\n            placeholder=\"Select Field\"\n            value={value.field}\n          />\n        )}\n\n        {isPipelineAggregation(value) && !isPipelineAggregationWithMultipleBucketPaths(value) && (\n          <MetricPicker\n            className={cx(styles.color, segmentStyles)}\n            onChange={(e) => dispatch(changeMetricField({ id: value.id, field: e.value?.id! }))}\n            options={previousMetrics}\n            value={value.field}\n          />\n        )}\n      </InlineSegmentGroup>\n\n      {isMetricAggregationWithSettings(value) && <SettingsEditor metric={value} previousMetrics={previousMetrics} />}\n    </>\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}