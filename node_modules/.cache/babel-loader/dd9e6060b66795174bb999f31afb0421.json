{"ast":null,"code":"function roundMsToMin(milliseconds) {\n  return roundSecToMin(milliseconds / 1000);\n}\n\nfunction roundSecToMin(seconds) {\n  return Math.floor(seconds / 60);\n}\n\nexport function shouldRefreshLabels(range, prevRange) {\n  if (range && prevRange) {\n    const sameMinuteFrom = roundMsToMin(range.from.valueOf()) === roundMsToMin(prevRange.from.valueOf());\n    const sameMinuteTo = roundMsToMin(range.to.valueOf()) === roundMsToMin(prevRange.to.valueOf()); // If both are same, don't need to refresh\n\n    return !(sameMinuteFrom && sameMinuteTo);\n  }\n\n  return false;\n} // Loki regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),\n// so every character that matches something in that list has to be escaped.\n// the list of meta characters is: *+?()|\\.[]{}^$\n// we make a javascript regular expression that matches those characters:\n\nconst RE2_METACHARACTERS = /[*+?()|\\\\.\\[\\]{}^$]/g;\n\nfunction escapeLokiRegexp(value) {\n  return value.replace(RE2_METACHARACTERS, '\\\\$&');\n} // based on the openmetrics-documentation, the 3 symbols we have to handle are:\n// - \\n ... the newline character\n// - \\  ... the backslash character\n// - \"  ... the double-quote character\n\n\nexport function escapeLabelValueInExactSelector(labelValue) {\n  return labelValue.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n').replace(/\"/g, '\\\\\"');\n}\nexport function escapeLabelValueInRegexSelector(labelValue) {\n  return escapeLabelValueInExactSelector(escapeLokiRegexp(labelValue));\n}\nexport function escapeLabelValueInSelector(labelValue, selector) {\n  return isRegexSelector(selector) ? escapeLabelValueInRegexSelector(labelValue) : escapeLabelValueInExactSelector(labelValue);\n}\nexport function isRegexSelector(selector) {\n  if (selector && (selector.includes('=~') || selector.includes('!~'))) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"names":["roundMsToMin","milliseconds","roundSecToMin","seconds","Math","floor","shouldRefreshLabels","range","prevRange","sameMinuteFrom","from","valueOf","sameMinuteTo","to","RE2_METACHARACTERS","escapeLokiRegexp","value","replace","escapeLabelValueInExactSelector","labelValue","escapeLabelValueInRegexSelector","escapeLabelValueInSelector","selector","isRegexSelector","includes"],"sources":["/home/soula/grafana/public/app/plugins/datasource/loki/language_utils.ts"],"sourcesContent":["import { TimeRange } from '@grafana/data';\n\nfunction roundMsToMin(milliseconds: number): number {\n  return roundSecToMin(milliseconds / 1000);\n}\n\nfunction roundSecToMin(seconds: number): number {\n  return Math.floor(seconds / 60);\n}\n\nexport function shouldRefreshLabels(range?: TimeRange, prevRange?: TimeRange): boolean {\n  if (range && prevRange) {\n    const sameMinuteFrom = roundMsToMin(range.from.valueOf()) === roundMsToMin(prevRange.from.valueOf());\n    const sameMinuteTo = roundMsToMin(range.to.valueOf()) === roundMsToMin(prevRange.to.valueOf());\n    // If both are same, don't need to refresh\n    return !(sameMinuteFrom && sameMinuteTo);\n  }\n  return false;\n}\n\n// Loki regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),\n// so every character that matches something in that list has to be escaped.\n// the list of meta characters is: *+?()|\\.[]{}^$\n// we make a javascript regular expression that matches those characters:\nconst RE2_METACHARACTERS = /[*+?()|\\\\.\\[\\]{}^$]/g;\nfunction escapeLokiRegexp(value: string): string {\n  return value.replace(RE2_METACHARACTERS, '\\\\$&');\n}\n\n// based on the openmetrics-documentation, the 3 symbols we have to handle are:\n// - \\n ... the newline character\n// - \\  ... the backslash character\n// - \"  ... the double-quote character\nexport function escapeLabelValueInExactSelector(labelValue: string): string {\n  return labelValue.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n').replace(/\"/g, '\\\\\"');\n}\n\nexport function escapeLabelValueInRegexSelector(labelValue: string): string {\n  return escapeLabelValueInExactSelector(escapeLokiRegexp(labelValue));\n}\n\nexport function escapeLabelValueInSelector(labelValue: string, selector?: string): string {\n  return isRegexSelector(selector)\n    ? escapeLabelValueInRegexSelector(labelValue)\n    : escapeLabelValueInExactSelector(labelValue);\n}\n\nexport function isRegexSelector(selector?: string) {\n  if (selector && (selector.includes('=~') || selector.includes('!~'))) {\n    return true;\n  }\n  return false;\n}\n"],"mappings":"AAEA,SAASA,YAAT,CAAsBC,YAAtB,EAAoD;EAClD,OAAOC,aAAa,CAACD,YAAY,GAAG,IAAhB,CAApB;AACD;;AAED,SAASC,aAAT,CAAuBC,OAAvB,EAAgD;EAC9C,OAAOC,IAAI,CAACC,KAAL,CAAWF,OAAO,GAAG,EAArB,CAAP;AACD;;AAED,OAAO,SAASG,mBAAT,CAA6BC,KAA7B,EAAgDC,SAAhD,EAAgF;EACrF,IAAID,KAAK,IAAIC,SAAb,EAAwB;IACtB,MAAMC,cAAc,GAAGT,YAAY,CAACO,KAAK,CAACG,IAAN,CAAWC,OAAX,EAAD,CAAZ,KAAuCX,YAAY,CAACQ,SAAS,CAACE,IAAV,CAAeC,OAAf,EAAD,CAA1E;IACA,MAAMC,YAAY,GAAGZ,YAAY,CAACO,KAAK,CAACM,EAAN,CAASF,OAAT,EAAD,CAAZ,KAAqCX,YAAY,CAACQ,SAAS,CAACK,EAAV,CAAaF,OAAb,EAAD,CAAtE,CAFsB,CAGtB;;IACA,OAAO,EAAEF,cAAc,IAAIG,YAApB,CAAP;EACD;;EACD,OAAO,KAAP;AACD,C,CAED;AACA;AACA;AACA;;AACA,MAAME,kBAAkB,GAAG,sBAA3B;;AACA,SAASC,gBAAT,CAA0BC,KAA1B,EAAiD;EAC/C,OAAOA,KAAK,CAACC,OAAN,CAAcH,kBAAd,EAAkC,MAAlC,CAAP;AACD,C,CAED;AACA;AACA;AACA;;;AACA,OAAO,SAASI,+BAAT,CAAyCC,UAAzC,EAAqE;EAC1E,OAAOA,UAAU,CAACF,OAAX,CAAmB,KAAnB,EAA0B,MAA1B,EAAkCA,OAAlC,CAA0C,KAA1C,EAAiD,KAAjD,EAAwDA,OAAxD,CAAgE,IAAhE,EAAsE,KAAtE,CAAP;AACD;AAED,OAAO,SAASG,+BAAT,CAAyCD,UAAzC,EAAqE;EAC1E,OAAOD,+BAA+B,CAACH,gBAAgB,CAACI,UAAD,CAAjB,CAAtC;AACD;AAED,OAAO,SAASE,0BAAT,CAAoCF,UAApC,EAAwDG,QAAxD,EAAmF;EACxF,OAAOC,eAAe,CAACD,QAAD,CAAf,GACHF,+BAA+B,CAACD,UAAD,CAD5B,GAEHD,+BAA+B,CAACC,UAAD,CAFnC;AAGD;AAED,OAAO,SAASI,eAAT,CAAyBD,QAAzB,EAA4C;EACjD,IAAIA,QAAQ,KAAKA,QAAQ,CAACE,QAAT,CAAkB,IAAlB,KAA2BF,QAAQ,CAACE,QAAT,CAAkB,IAAlB,CAAhC,CAAZ,EAAsE;IACpE,OAAO,IAAP;EACD;;EACD,OAAO,KAAP;AACD"},"metadata":{},"sourceType":"module"}