{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { each, indexOf, isArray, isString, map as _map } from 'lodash';\nimport { lastValueFrom, of, pipe, throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { DataSourceApi, dateMath, AbstractLabelOperator, toDataFrame } from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { isVersionGtOrEq, SemVersion } from 'app/core/utils/version';\nimport { getTemplateSrv } from 'app/features/templating/template_srv';\nimport { getRollupNotice, getRuntimeConsolidationNotice } from 'app/plugins/datasource/graphite/meta';\nimport { getSearchFilterScopedVar } from '../../../features/variables/utils';\nimport gfunc from './gfunc';\nimport GraphiteQueryModel from './graphite_query'; // Types\n\nimport { GraphiteType } from './types';\nimport { reduceError } from './utils';\nimport { DEFAULT_GRAPHITE_VERSION } from './versions';\nconst GRAPHITE_TAG_COMPARATORS = {\n  '=': AbstractLabelOperator.Equal,\n  '!=': AbstractLabelOperator.NotEqual,\n  '=~': AbstractLabelOperator.EqualRegEx,\n  '!=~': AbstractLabelOperator.NotEqualRegEx\n};\n/**\n * Converts Graphite glob-like pattern to a regular expression\n */\n\nfunction convertGlobToRegEx(text) {\n  if (text.includes('*') || text.includes('{')) {\n    return '^' + text.replace(/\\*/g, '.*').replace(/\\{/g, '(').replace(/}/g, ')').replace(/,/g, '|');\n  } else {\n    return text;\n  }\n}\n\nexport class GraphiteDatasource extends DataSourceApi {\n  constructor(instanceSettings, templateSrv = getTemplateSrv()) {\n    var _instanceSettings$jso, _instanceSettings$jso2;\n\n    super(instanceSettings);\n\n    _defineProperty(this, \"basicAuth\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"graphiteVersion\", void 0);\n\n    _defineProperty(this, \"supportsTags\", void 0);\n\n    _defineProperty(this, \"isMetricTank\", void 0);\n\n    _defineProperty(this, \"rollupIndicatorEnabled\", void 0);\n\n    _defineProperty(this, \"cacheTimeout\", void 0);\n\n    _defineProperty(this, \"withCredentials\", void 0);\n\n    _defineProperty(this, \"funcDefs\", null);\n\n    _defineProperty(this, \"funcDefsPromise\", null);\n\n    _defineProperty(this, \"_seriesRefLetters\", void 0);\n\n    _defineProperty(this, \"metricMappings\", void 0);\n\n    _defineProperty(this, \"convertResponseToDataFrames\", result => {\n      const data = [];\n\n      if (!result || !result.data) {\n        return {\n          data\n        };\n      } // Series are either at the root or under a node called 'series'\n\n\n      const series = result.data.series || result.data;\n\n      if (!isArray(series)) {\n        throw {\n          message: 'Missing series in result',\n          data: result\n        };\n      }\n\n      for (let i = 0; i < series.length; i++) {\n        const s = series[i]; // Disables Grafana own series naming\n\n        s.title = s.target;\n\n        for (let y = 0; y < s.datapoints.length; y++) {\n          s.datapoints[y][1] *= 1000;\n        }\n\n        const frame = toDataFrame(s); // Metrictank metadata\n\n        if (s.meta) {\n          frame.meta = {\n            custom: {\n              requestMetaList: result.data.meta,\n              // info for the whole request\n              seriesMetaList: s.meta // Array of metadata\n\n            }\n          };\n\n          if (this.rollupIndicatorEnabled) {\n            const rollupNotice = getRollupNotice(s.meta);\n            const runtimeNotice = getRuntimeConsolidationNotice(s.meta);\n\n            if (rollupNotice) {\n              frame.meta.notices = [rollupNotice];\n            } else if (runtimeNotice) {\n              frame.meta.notices = [runtimeNotice];\n            }\n          } // only add the request stats to the first frame\n\n\n          if (i === 0 && result.data.meta.stats) {\n            frame.meta.stats = this.getRequestStats(result.data.meta);\n          }\n        }\n\n        data.push(frame);\n      }\n\n      return {\n        data\n      };\n    });\n\n    this.templateSrv = templateSrv;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name; // graphiteVersion is set when a datasource is created but it hadn't been set in the past so we're\n    // still falling back to the default behavior here for backwards compatibility (see also #17429)\n\n    this.graphiteVersion = instanceSettings.jsonData.graphiteVersion || DEFAULT_GRAPHITE_VERSION;\n    this.metricMappings = ((_instanceSettings$jso = instanceSettings.jsonData.importConfiguration) === null || _instanceSettings$jso === void 0 ? void 0 : (_instanceSettings$jso2 = _instanceSettings$jso.loki) === null || _instanceSettings$jso2 === void 0 ? void 0 : _instanceSettings$jso2.mappings) || [];\n    this.isMetricTank = instanceSettings.jsonData.graphiteType === GraphiteType.Metrictank;\n    this.supportsTags = supportsTags(this.graphiteVersion);\n    this.cacheTimeout = instanceSettings.cacheTimeout;\n    this.rollupIndicatorEnabled = instanceSettings.jsonData.rollupIndicatorEnabled;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.funcDefs = null;\n    this.funcDefsPromise = null;\n    this._seriesRefLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  }\n\n  getQueryOptionsInfo() {\n    return {\n      maxDataPoints: true,\n      cacheTimeout: true,\n      links: [{\n        text: 'Help',\n        url: 'http://docs.grafana.org/features/datasources/graphite/#using-graphite-in-grafana'\n      }]\n    };\n  }\n\n  getImportQueryConfiguration() {\n    return {\n      loki: {\n        mappings: this.metricMappings\n      }\n    };\n  }\n\n  async exportToAbstractQueries(queries) {\n    return queries.map(query => this.exportToAbstractQuery(query));\n  }\n\n  exportToAbstractQuery(query) {\n    const graphiteQuery = new GraphiteQueryModel(this, Object.assign({}, query, {\n      target: query.target || '',\n      textEditor: false\n    }), getTemplateSrv());\n    graphiteQuery.parseTarget();\n    let labels = [];\n    const config = this.getImportQueryConfiguration().loki;\n\n    if (graphiteQuery.seriesByTagUsed) {\n      graphiteQuery.tags.forEach(tag => {\n        labels.push({\n          name: tag.key,\n          operator: GRAPHITE_TAG_COMPARATORS[tag.operator],\n          value: tag.value\n        });\n      });\n    } else {\n      const targetNodes = graphiteQuery.segments.map(segment => segment.value);\n      let mappings = config.mappings.filter(mapping => mapping.matchers.length <= targetNodes.length);\n\n      for (let mapping of mappings) {\n        const matchers = mapping.matchers.concat();\n        matchers.every((matcher, index) => {\n          if (matcher.labelName) {\n            let value = targetNodes[index];\n\n            if (value === '*') {\n              return true;\n            }\n\n            const converted = convertGlobToRegEx(value);\n            labels.push({\n              name: matcher.labelName,\n              operator: converted !== value ? AbstractLabelOperator.EqualRegEx : AbstractLabelOperator.Equal,\n              value: converted\n            });\n            return true;\n          }\n\n          return targetNodes[index] === matcher.value || matcher.value === '*';\n        });\n      }\n    }\n\n    return {\n      refId: query.refId,\n      labelMatchers: labels\n    };\n  }\n\n  query(options) {\n    const graphOptions = {\n      from: this.translateTime(options.range.raw.from, false, options.timezone),\n      until: this.translateTime(options.range.raw.to, true, options.timezone),\n      targets: options.targets,\n      format: options.format,\n      cacheTimeout: options.cacheTimeout || this.cacheTimeout,\n      maxDataPoints: options.maxDataPoints\n    };\n    const params = this.buildGraphiteParams(graphOptions, options.scopedVars);\n\n    if (params.length === 0) {\n      return of({\n        data: []\n      });\n    }\n\n    if (this.isMetricTank) {\n      params.push('meta=true');\n    }\n\n    const httpOptions = {\n      method: 'POST',\n      url: '/render',\n      data: params.join('&'),\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    };\n    this.addTracingHeaders(httpOptions, options);\n\n    if (options.panelId) {\n      httpOptions.requestId = this.name + '.panelId.' + options.panelId;\n    }\n\n    return this.doGraphiteRequest(httpOptions).pipe(map(this.convertResponseToDataFrames));\n  }\n\n  addTracingHeaders(httpOptions, options) {\n    const proxyMode = !this.url.match(/^http/);\n\n    if (proxyMode) {\n      if (options.dashboardId) {\n        httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\n      }\n\n      if (options.panelId) {\n        httpOptions.headers['X-Panel-Id'] = options.panelId;\n      }\n    }\n  }\n\n  getRequestStats(meta) {\n    const stats = [];\n\n    for (const key in meta.stats) {\n      let unit = undefined;\n\n      if (key.endsWith('.ms')) {\n        unit = 'ms';\n      }\n\n      stats.push({\n        displayName: key,\n        value: meta.stats[key],\n        unit\n      });\n    }\n\n    return stats;\n  }\n\n  parseTags(tagString) {\n    let tags = [];\n    tags = tagString.split(',');\n\n    if (tags.length === 1) {\n      tags = tagString.split(' ');\n\n      if (tags[0] === '') {\n        tags = [];\n      }\n    }\n\n    return tags;\n  }\n\n  interpolateVariablesInQueries(queries, scopedVars) {\n    let expandedQueries = queries;\n\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map(query => {\n        var _query$target;\n\n        const expandedQuery = Object.assign({}, query, {\n          datasource: this.getRef(),\n          target: this.templateSrv.replace((_query$target = query.target) !== null && _query$target !== void 0 ? _query$target : '', scopedVars)\n        });\n        return expandedQuery;\n      });\n    }\n\n    return expandedQueries;\n  }\n\n  annotationQuery(options) {\n    // Graphite metric as annotation\n    if (options.annotation.target) {\n      const target = this.templateSrv.replace(options.annotation.target, {}, 'glob');\n      const graphiteQuery = {\n        range: options.range,\n        targets: [{\n          target: target\n        }],\n        format: 'json',\n        maxDataPoints: 100\n      };\n      return lastValueFrom(this.query(graphiteQuery).pipe(map(result => {\n        const list = [];\n\n        for (let i = 0; i < result.data.length; i++) {\n          const target = result.data[i];\n\n          for (let y = 0; y < target.length; y++) {\n            const time = target.fields[0].values.get(y);\n            const value = target.fields[1].values.get(y);\n\n            if (!value) {\n              continue;\n            }\n\n            list.push({\n              annotation: options.annotation,\n              time,\n              title: target.name\n            });\n          }\n        }\n\n        return list;\n      })));\n    } else {\n      // Graphite event as annotation\n      const tags = this.templateSrv.replace(options.annotation.tags);\n      return this.events({\n        range: options.range,\n        tags: tags\n      }).then(results => {\n        const list = [];\n\n        if (!isArray(results.data)) {\n          console.error(`Unable to get annotations from ${results.url}.`);\n          return [];\n        }\n\n        for (let i = 0; i < results.data.length; i++) {\n          const e = results.data[i];\n          let tags = e.tags;\n\n          if (isString(e.tags)) {\n            tags = this.parseTags(e.tags);\n          }\n\n          list.push({\n            annotation: options.annotation,\n            time: e.when * 1000,\n            title: e.what,\n            tags: tags,\n            text: e.data\n          });\n        }\n\n        return list;\n      });\n    }\n  }\n\n  events(options) {\n    try {\n      let tags = '';\n\n      if (options.tags) {\n        tags = '&tags=' + options.tags;\n      }\n\n      return lastValueFrom(this.doGraphiteRequest({\n        method: 'GET',\n        url: '/events/get_data?from=' + this.translateTime(options.range.raw.from, false, options.timezone) + '&until=' + this.translateTime(options.range.raw.to, true, options.timezone) + tags\n      }));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  targetContainsTemplate(target) {\n    var _target$target;\n\n    return this.templateSrv.containsTemplate((_target$target = target.target) !== null && _target$target !== void 0 ? _target$target : '');\n  }\n\n  translateTime(date, roundUp, timezone) {\n    if (isString(date)) {\n      if (date === 'now') {\n        return 'now';\n      } else if (date.indexOf('now-') >= 0 && date.indexOf('/') === -1) {\n        date = date.substring(3);\n        date = date.replace('m', 'min');\n        date = date.replace('M', 'mon');\n        return date;\n      }\n\n      date = dateMath.parse(date, roundUp, timezone);\n    } // graphite' s from filter is exclusive\n    // here we step back one minute in order\n    // to guarantee that we get all the data that\n    // exists for the specified range\n\n\n    if (roundUp) {\n      if (date.get('s')) {\n        date.add(1, 's');\n      }\n    } else if (roundUp === false) {\n      if (date.get('s')) {\n        date.subtract(1, 's');\n      }\n    }\n\n    return date.unix();\n  }\n\n  metricFindQuery(query, optionalOptions) {\n    const options = optionalOptions || {}; // First attempt to check for tag-related functions (using empty wildcard for interpolation)\n\n    let interpolatedQuery = this.templateSrv.replace(query, getSearchFilterScopedVar({\n      query,\n      wildcardChar: '',\n      options: optionalOptions\n    })); // special handling for tag_values(<tag>[,<expression>]*), this is used for template variables\n\n    let allParams = interpolatedQuery.match(/^tag_values\\((.*)\\)$/);\n    let expressions = allParams ? allParams[1].split(',').filter(p => !!p) : undefined;\n\n    if (expressions) {\n      options.limit = 10000;\n      return this.getTagValuesAutoComplete(expressions.slice(1), expressions[0], undefined, options);\n    } // special handling for tags(<expression>[,<expression>]*), this is used for template variables\n\n\n    allParams = interpolatedQuery.match(/^tags\\((.*)\\)$/);\n    expressions = allParams ? allParams[1].split(',').filter(p => !!p) : undefined;\n\n    if (expressions) {\n      options.limit = 10000;\n      return this.getTagsAutoComplete(expressions, undefined, options);\n    } // If no tag-related query was found, perform metric-based search (using * as the wildcard for interpolation)\n\n\n    let useExpand = query.match(/^expand\\((.*)\\)$/);\n    query = useExpand ? useExpand[1] : query;\n    interpolatedQuery = this.templateSrv.replace(query, getSearchFilterScopedVar({\n      query,\n      wildcardChar: '*',\n      options: optionalOptions\n    }));\n    let range;\n\n    if (options.range) {\n      range = {\n        from: this.translateTime(options.range.from, false, options.timezone),\n        until: this.translateTime(options.range.to, true, options.timezone)\n      };\n    }\n\n    if (useExpand) {\n      return this.requestMetricExpand(interpolatedQuery, options.requestId, range);\n    } else {\n      return this.requestMetricFind(interpolatedQuery, options.requestId, range);\n    }\n  }\n  /**\n   * Search for metrics matching giving pattern using /metrics/find endpoint. It will\n   * return all possible values at the last level of the query, for example:\n   *\n   * metrics: prod.servers.001.cpu, prod.servers.002.cpu\n   * query: *.servers.*\n   * result: 001, 002\n   *\n   * For more complex searches use requestMetricExpand\n   */\n\n\n  requestMetricFind(query, requestId, range) {\n    const httpOptions = {\n      method: 'POST',\n      url: '/metrics/find',\n      params: {},\n      data: `query=${query}`,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      // for cancellations\n      requestId: requestId\n    };\n\n    if (range) {\n      httpOptions.params.from = range.from;\n      httpOptions.params.until = range.until;\n    }\n\n    return lastValueFrom(this.doGraphiteRequest(httpOptions).pipe(map(results => {\n      return _map(results.data, metric => {\n        return {\n          text: metric.text,\n          expandable: metric.expandable ? true : false\n        };\n      });\n    })));\n  }\n  /**\n   * Search for metrics matching giving pattern using /metrics/expand endpoint.\n   * The result will contain all metrics (with full name) matching provided query.\n   * It's a more flexible version of /metrics/find endpoint (@see requestMetricFind)\n   */\n\n\n  requestMetricExpand(query, requestId, range) {\n    const httpOptions = {\n      method: 'GET',\n      url: '/metrics/expand',\n      params: {\n        query\n      },\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      // for cancellations\n      requestId\n    };\n\n    if (range) {\n      httpOptions.params.from = range.from;\n      httpOptions.params.until = range.until;\n    }\n\n    return lastValueFrom(this.doGraphiteRequest(httpOptions).pipe(map(results => {\n      return _map(results.data.results, metric => {\n        return {\n          text: metric,\n          expandable: false\n        };\n      });\n    })));\n  }\n\n  getTags(optionalOptions) {\n    const options = optionalOptions || {};\n    const httpOptions = {\n      method: 'GET',\n      url: '/tags',\n      // for cancellations\n      requestId: options.requestId\n    };\n\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return lastValueFrom(this.doGraphiteRequest(httpOptions).pipe(map(results => {\n      return _map(results.data, tag => {\n        return {\n          text: tag.tag,\n          id: tag.id\n        };\n      });\n    })));\n  }\n\n  getTagValues(options = {}) {\n    const httpOptions = {\n      method: 'GET',\n      url: '/tags/' + this.templateSrv.replace(options.key),\n      // for cancellations\n      requestId: options.requestId\n    };\n\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return lastValueFrom(this.doGraphiteRequest(httpOptions).pipe(map(results => {\n      if (results.data && results.data.values) {\n        return _map(results.data.values, value => {\n          return {\n            text: value.value,\n            id: value.id\n          };\n        });\n      } else {\n        return [];\n      }\n    })));\n  }\n\n  getTagsAutoComplete(expressions, tagPrefix, optionalOptions) {\n    const options = optionalOptions || {};\n    const httpOptions = {\n      method: 'GET',\n      url: '/tags/autoComplete/tags',\n      params: {\n        expr: _map(expressions, expression => this.templateSrv.replace((expression || '').trim()))\n      },\n      // for cancellations\n      requestId: options.requestId\n    };\n\n    if (tagPrefix) {\n      httpOptions.params.tagPrefix = tagPrefix;\n    }\n\n    if (options.limit) {\n      httpOptions.params.limit = options.limit;\n    }\n\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return lastValueFrom(this.doGraphiteRequest(httpOptions).pipe(mapToTags()));\n  }\n\n  getTagValuesAutoComplete(expressions, tag, valuePrefix, optionalOptions) {\n    const options = optionalOptions || {};\n    const httpOptions = {\n      method: 'GET',\n      url: '/tags/autoComplete/values',\n      params: {\n        expr: _map(expressions, expression => this.templateSrv.replace((expression || '').trim())),\n        tag: this.templateSrv.replace((tag || '').trim())\n      },\n      // for cancellations\n      requestId: options.requestId\n    };\n\n    if (valuePrefix) {\n      httpOptions.params.valuePrefix = valuePrefix;\n    }\n\n    if (options.limit) {\n      httpOptions.params.limit = options.limit;\n    }\n\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return lastValueFrom(this.doGraphiteRequest(httpOptions).pipe(mapToTags()));\n  }\n\n  getVersion(optionalOptions) {\n    const options = optionalOptions || {};\n    const httpOptions = {\n      method: 'GET',\n      url: '/version',\n      requestId: options.requestId\n    };\n    return lastValueFrom(this.doGraphiteRequest(httpOptions).pipe(map(results => {\n      if (results.data) {\n        const semver = new SemVersion(results.data);\n        return semver.isValid() ? results.data : '';\n      }\n\n      return '';\n    }), catchError(() => {\n      return of('');\n    })));\n  }\n\n  createFuncInstance(funcDef, options) {\n    return gfunc.createFuncInstance(funcDef, options, this.funcDefs);\n  }\n\n  getFuncDef(name) {\n    return gfunc.getFuncDef(name, this.funcDefs);\n  }\n\n  waitForFuncDefsLoaded() {\n    return this.getFuncDefs();\n  }\n\n  getFuncDefs() {\n    if (this.funcDefsPromise !== null) {\n      return this.funcDefsPromise;\n    }\n\n    if (!supportsFunctionIndex(this.graphiteVersion)) {\n      this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\n      this.funcDefsPromise = Promise.resolve(this.funcDefs);\n      return this.funcDefsPromise;\n    }\n\n    const httpOptions = {\n      method: 'GET',\n      url: '/functions',\n      // add responseType because if this is not defined,\n      // backend_srv defaults to json\n      responseType: 'text'\n    };\n    return lastValueFrom(this.doGraphiteRequest(httpOptions).pipe(map(results => {\n      // Fix for a Graphite bug: https://github.com/graphite-project/graphite-web/issues/2609\n      // There is a fix for it https://github.com/graphite-project/graphite-web/pull/2612 but\n      // it was merged to master in July 2020 but it has never been released (the last Graphite\n      // release was 1.1.7 - March 2020). The bug was introduced in Graphite 1.1.7, in versions\n      // 1.1.0 - 1.1.6 /functions endpoint returns a valid JSON\n      const fixedData = JSON.parse(results.data.replace(/\"default\": ?Infinity/g, '\"default\": 1e9999'));\n      this.funcDefs = gfunc.parseFuncDefs(fixedData);\n      return this.funcDefs;\n    }), catchError(error => {\n      console.error('Fetching graphite functions error', error);\n      this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\n      return of(this.funcDefs);\n    })));\n  }\n\n  testDatasource() {\n    const query = {\n      panelId: 3,\n      rangeRaw: {\n        from: 'now-1h',\n        to: 'now'\n      },\n      range: {\n        raw: {\n          from: 'now-1h',\n          to: 'now'\n        }\n      },\n      targets: [{\n        target: 'constantLine(100)'\n      }],\n      maxDataPoints: 300\n    };\n    return lastValueFrom(this.query(query)).then(() => ({\n      status: 'success',\n      message: 'Data source is working'\n    }));\n  }\n\n  doGraphiteRequest(options) {\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n\n    if (this.basicAuth) {\n      options.headers = options.headers || {};\n      options.headers.Authorization = this.basicAuth;\n    }\n\n    options.url = this.url + options.url;\n    options.inspect = {\n      type: 'graphite'\n    };\n    return getBackendSrv().fetch(options).pipe(catchError(err => {\n      return throwError(reduceError(err));\n    }));\n  }\n\n  buildGraphiteParams(options, scopedVars) {\n    const graphiteOptions = ['from', 'until', 'rawData', 'format', 'maxDataPoints', 'cacheTimeout'];\n    const cleanOptions = [],\n          targets = {};\n    let target, targetValue, i;\n    const regex = /\\#([A-Z])/g;\n    const intervalFormatFixRegex = /'(\\d+)m'/gi;\n    let hasTargets = false;\n    options['format'] = 'json';\n\n    function fixIntervalFormat(match) {\n      return match.replace('m', 'min').replace('M', 'mon');\n    }\n\n    for (i = 0; i < options.targets.length; i++) {\n      target = options.targets[i];\n\n      if (!target.target) {\n        continue;\n      }\n\n      if (!target.refId) {\n        target.refId = this._seriesRefLetters[i];\n      }\n\n      targetValue = this.templateSrv.replace(target.target, scopedVars);\n      targetValue = targetValue.replace(intervalFormatFixRegex, fixIntervalFormat);\n      targets[target.refId] = targetValue;\n    }\n\n    function nestedSeriesRegexReplacer(match, g1) {\n      return targets[g1] || match;\n    }\n\n    for (i = 0; i < options.targets.length; i++) {\n      target = options.targets[i];\n\n      if (!target.target) {\n        continue;\n      }\n\n      targetValue = targets[target.refId];\n      targetValue = targetValue.replace(regex, nestedSeriesRegexReplacer);\n      targets[target.refId] = targetValue;\n\n      if (!target.hide) {\n        hasTargets = true;\n        cleanOptions.push('target=' + encodeURIComponent(targetValue));\n      }\n    }\n\n    each(options, (value, key) => {\n      if (indexOf(graphiteOptions, key) === -1) {\n        return;\n      }\n\n      if (value) {\n        cleanOptions.push(key + '=' + encodeURIComponent(value));\n      }\n    });\n\n    if (!hasTargets) {\n      return [];\n    }\n\n    return cleanOptions;\n  }\n\n}\n\nfunction supportsTags(version) {\n  return isVersionGtOrEq(version, '1.1');\n}\n\nfunction supportsFunctionIndex(version) {\n  return isVersionGtOrEq(version, '1.1');\n}\n\nfunction mapToTags() {\n  return pipe(map(results => {\n    if (results.data) {\n      return _map(results.data, value => {\n        return {\n          text: value\n        };\n      });\n    } else {\n      return [];\n    }\n  }));\n}","map":{"version":3,"names":["each","indexOf","isArray","isString","map","_map","lastValueFrom","of","pipe","throwError","catchError","DataSourceApi","dateMath","AbstractLabelOperator","toDataFrame","getBackendSrv","isVersionGtOrEq","SemVersion","getTemplateSrv","getRollupNotice","getRuntimeConsolidationNotice","getSearchFilterScopedVar","gfunc","GraphiteQueryModel","GraphiteType","reduceError","DEFAULT_GRAPHITE_VERSION","GRAPHITE_TAG_COMPARATORS","Equal","NotEqual","EqualRegEx","NotEqualRegEx","convertGlobToRegEx","text","includes","replace","GraphiteDatasource","constructor","instanceSettings","templateSrv","result","data","series","message","i","length","s","title","target","y","datapoints","frame","meta","custom","requestMetaList","seriesMetaList","rollupIndicatorEnabled","rollupNotice","runtimeNotice","notices","stats","getRequestStats","push","basicAuth","url","name","graphiteVersion","jsonData","metricMappings","importConfiguration","loki","mappings","isMetricTank","graphiteType","Metrictank","supportsTags","cacheTimeout","withCredentials","funcDefs","funcDefsPromise","_seriesRefLetters","getQueryOptionsInfo","maxDataPoints","links","getImportQueryConfiguration","exportToAbstractQueries","queries","query","exportToAbstractQuery","graphiteQuery","textEditor","parseTarget","labels","config","seriesByTagUsed","tags","forEach","tag","key","operator","value","targetNodes","segments","segment","filter","mapping","matchers","concat","every","matcher","index","labelName","converted","refId","labelMatchers","options","graphOptions","from","translateTime","range","raw","timezone","until","to","targets","format","params","buildGraphiteParams","scopedVars","httpOptions","method","join","headers","addTracingHeaders","panelId","requestId","doGraphiteRequest","convertResponseToDataFrames","proxyMode","match","dashboardId","unit","undefined","endsWith","displayName","parseTags","tagString","split","interpolateVariablesInQueries","expandedQueries","expandedQuery","datasource","getRef","annotationQuery","annotation","list","time","fields","values","get","events","then","results","console","error","e","when","what","err","Promise","reject","targetContainsTemplate","containsTemplate","date","roundUp","substring","parse","add","subtract","unix","metricFindQuery","optionalOptions","interpolatedQuery","wildcardChar","allParams","expressions","p","limit","getTagValuesAutoComplete","slice","getTagsAutoComplete","useExpand","requestMetricExpand","requestMetricFind","metric","expandable","getTags","id","getTagValues","tagPrefix","expr","expression","trim","mapToTags","valuePrefix","getVersion","semver","isValid","createFuncInstance","funcDef","getFuncDef","waitForFuncDefsLoaded","getFuncDefs","supportsFunctionIndex","resolve","responseType","fixedData","JSON","parseFuncDefs","testDatasource","rangeRaw","status","Authorization","inspect","type","fetch","graphiteOptions","cleanOptions","targetValue","regex","intervalFormatFixRegex","hasTargets","fixIntervalFormat","nestedSeriesRegexReplacer","g1","hide","encodeURIComponent","version"],"sources":["/home/soula/grafana/public/app/plugins/datasource/graphite/datasource.ts"],"sourcesContent":["import { each, indexOf, isArray, isString, map as _map } from 'lodash';\nimport { lastValueFrom, Observable, of, OperatorFunction, pipe, throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\n\nimport {\n  DataFrame,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceWithQueryExportSupport,\n  dateMath,\n  AbstractQuery,\n  AbstractLabelOperator,\n  AbstractLabelMatcher,\n  MetricFindValue,\n  QueryResultMetaStat,\n  ScopedVars,\n  TimeRange,\n  toDataFrame,\n} from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { isVersionGtOrEq, SemVersion } from 'app/core/utils/version';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { getRollupNotice, getRuntimeConsolidationNotice } from 'app/plugins/datasource/graphite/meta';\n\nimport { getSearchFilterScopedVar } from '../../../features/variables/utils';\n\nimport gfunc, { FuncDefs, FuncInstance } from './gfunc';\nimport GraphiteQueryModel from './graphite_query';\n// Types\nimport {\n  GraphiteLokiMapping,\n  GraphiteMetricLokiMatcher,\n  GraphiteOptions,\n  GraphiteQuery,\n  GraphiteQueryImportConfiguration,\n  GraphiteType,\n  MetricTankRequestMeta,\n} from './types';\nimport { reduceError } from './utils';\nimport { DEFAULT_GRAPHITE_VERSION } from './versions';\n\nconst GRAPHITE_TAG_COMPARATORS = {\n  '=': AbstractLabelOperator.Equal,\n  '!=': AbstractLabelOperator.NotEqual,\n  '=~': AbstractLabelOperator.EqualRegEx,\n  '!=~': AbstractLabelOperator.NotEqualRegEx,\n};\n\n/**\n * Converts Graphite glob-like pattern to a regular expression\n */\nfunction convertGlobToRegEx(text: string): string {\n  if (text.includes('*') || text.includes('{')) {\n    return '^' + text.replace(/\\*/g, '.*').replace(/\\{/g, '(').replace(/}/g, ')').replace(/,/g, '|');\n  } else {\n    return text;\n  }\n}\n\nexport class GraphiteDatasource\n  extends DataSourceApi<GraphiteQuery, GraphiteOptions, GraphiteQueryImportConfiguration>\n  implements DataSourceWithQueryExportSupport<GraphiteQuery>\n{\n  basicAuth: string;\n  url: string;\n  name: string;\n  graphiteVersion: any;\n  supportsTags: boolean;\n  isMetricTank: boolean;\n  rollupIndicatorEnabled: boolean;\n  cacheTimeout: any;\n  withCredentials: boolean;\n  funcDefs: FuncDefs | null = null;\n  funcDefsPromise: Promise<any> | null = null;\n  _seriesRefLetters: string;\n  private readonly metricMappings: GraphiteLokiMapping[];\n\n  constructor(instanceSettings: any, private readonly templateSrv: TemplateSrv = getTemplateSrv()) {\n    super(instanceSettings);\n    this.basicAuth = instanceSettings.basicAuth;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    // graphiteVersion is set when a datasource is created but it hadn't been set in the past so we're\n    // still falling back to the default behavior here for backwards compatibility (see also #17429)\n    this.graphiteVersion = instanceSettings.jsonData.graphiteVersion || DEFAULT_GRAPHITE_VERSION;\n    this.metricMappings = instanceSettings.jsonData.importConfiguration?.loki?.mappings || [];\n    this.isMetricTank = instanceSettings.jsonData.graphiteType === GraphiteType.Metrictank;\n    this.supportsTags = supportsTags(this.graphiteVersion);\n    this.cacheTimeout = instanceSettings.cacheTimeout;\n    this.rollupIndicatorEnabled = instanceSettings.jsonData.rollupIndicatorEnabled;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.funcDefs = null;\n    this.funcDefsPromise = null;\n    this._seriesRefLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  }\n\n  getQueryOptionsInfo() {\n    return {\n      maxDataPoints: true,\n      cacheTimeout: true,\n      links: [\n        {\n          text: 'Help',\n          url: 'http://docs.grafana.org/features/datasources/graphite/#using-graphite-in-grafana',\n        },\n      ],\n    };\n  }\n\n  getImportQueryConfiguration(): GraphiteQueryImportConfiguration {\n    return {\n      loki: {\n        mappings: this.metricMappings,\n      },\n    };\n  }\n\n  async exportToAbstractQueries(queries: GraphiteQuery[]): Promise<AbstractQuery[]> {\n    return queries.map((query) => this.exportToAbstractQuery(query));\n  }\n\n  exportToAbstractQuery(query: GraphiteQuery): AbstractQuery {\n    const graphiteQuery: GraphiteQueryModel = new GraphiteQueryModel(\n      this,\n      {\n        ...query,\n        target: query.target || '',\n        textEditor: false,\n      },\n      getTemplateSrv()\n    );\n    graphiteQuery.parseTarget();\n\n    let labels: AbstractLabelMatcher[] = [];\n    const config = this.getImportQueryConfiguration().loki;\n\n    if (graphiteQuery.seriesByTagUsed) {\n      graphiteQuery.tags.forEach((tag) => {\n        labels.push({\n          name: tag.key,\n          operator: GRAPHITE_TAG_COMPARATORS[tag.operator],\n          value: tag.value,\n        });\n      });\n    } else {\n      const targetNodes = graphiteQuery.segments.map((segment) => segment.value);\n      let mappings = config.mappings.filter((mapping) => mapping.matchers.length <= targetNodes.length);\n\n      for (let mapping of mappings) {\n        const matchers = mapping.matchers.concat();\n\n        matchers.every((matcher: GraphiteMetricLokiMatcher, index: number) => {\n          if (matcher.labelName) {\n            let value = (targetNodes[index] as string)!;\n\n            if (value === '*') {\n              return true;\n            }\n\n            const converted = convertGlobToRegEx(value);\n            labels.push({\n              name: matcher.labelName,\n              operator: converted !== value ? AbstractLabelOperator.EqualRegEx : AbstractLabelOperator.Equal,\n              value: converted,\n            });\n            return true;\n          }\n          return targetNodes[index] === matcher.value || matcher.value === '*';\n        });\n      }\n    }\n\n    return {\n      refId: query.refId,\n      labelMatchers: labels,\n    };\n  }\n\n  query(options: DataQueryRequest<GraphiteQuery>): Observable<DataQueryResponse> {\n    const graphOptions = {\n      from: this.translateTime(options.range.raw.from, false, options.timezone),\n      until: this.translateTime(options.range.raw.to, true, options.timezone),\n      targets: options.targets,\n      format: (options as any).format,\n      cacheTimeout: options.cacheTimeout || this.cacheTimeout,\n      maxDataPoints: options.maxDataPoints,\n    };\n\n    const params = this.buildGraphiteParams(graphOptions, options.scopedVars);\n    if (params.length === 0) {\n      return of({ data: [] });\n    }\n\n    if (this.isMetricTank) {\n      params.push('meta=true');\n    }\n\n    const httpOptions: any = {\n      method: 'POST',\n      url: '/render',\n      data: params.join('&'),\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n    };\n\n    this.addTracingHeaders(httpOptions, options);\n\n    if (options.panelId) {\n      httpOptions.requestId = this.name + '.panelId.' + options.panelId;\n    }\n\n    return this.doGraphiteRequest(httpOptions).pipe(map(this.convertResponseToDataFrames));\n  }\n\n  addTracingHeaders(httpOptions: { headers: any }, options: { dashboardId?: number; panelId?: number }) {\n    const proxyMode = !this.url.match(/^http/);\n    if (proxyMode) {\n      if (options.dashboardId) {\n        httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\n      }\n      if (options.panelId) {\n        httpOptions.headers['X-Panel-Id'] = options.panelId;\n      }\n    }\n  }\n\n  convertResponseToDataFrames = (result: any): DataQueryResponse => {\n    const data: DataFrame[] = [];\n    if (!result || !result.data) {\n      return { data };\n    }\n\n    // Series are either at the root or under a node called 'series'\n    const series = result.data.series || result.data;\n\n    if (!isArray(series)) {\n      throw { message: 'Missing series in result', data: result };\n    }\n\n    for (let i = 0; i < series.length; i++) {\n      const s = series[i];\n\n      // Disables Grafana own series naming\n      s.title = s.target;\n\n      for (let y = 0; y < s.datapoints.length; y++) {\n        s.datapoints[y][1] *= 1000;\n      }\n\n      const frame = toDataFrame(s);\n\n      // Metrictank metadata\n      if (s.meta) {\n        frame.meta = {\n          custom: {\n            requestMetaList: result.data.meta, // info for the whole request\n            seriesMetaList: s.meta, // Array of metadata\n          },\n        };\n\n        if (this.rollupIndicatorEnabled) {\n          const rollupNotice = getRollupNotice(s.meta);\n          const runtimeNotice = getRuntimeConsolidationNotice(s.meta);\n\n          if (rollupNotice) {\n            frame.meta.notices = [rollupNotice];\n          } else if (runtimeNotice) {\n            frame.meta.notices = [runtimeNotice];\n          }\n        }\n\n        // only add the request stats to the first frame\n        if (i === 0 && result.data.meta.stats) {\n          frame.meta.stats = this.getRequestStats(result.data.meta);\n        }\n      }\n\n      data.push(frame);\n    }\n\n    return { data };\n  };\n\n  getRequestStats(meta: MetricTankRequestMeta): QueryResultMetaStat[] {\n    const stats: QueryResultMetaStat[] = [];\n\n    for (const key in meta.stats) {\n      let unit: string | undefined = undefined;\n\n      if (key.endsWith('.ms')) {\n        unit = 'ms';\n      }\n\n      stats.push({ displayName: key, value: meta.stats[key], unit });\n    }\n\n    return stats;\n  }\n\n  parseTags(tagString: string) {\n    let tags: string[] = [];\n    tags = tagString.split(',');\n    if (tags.length === 1) {\n      tags = tagString.split(' ');\n      if (tags[0] === '') {\n        tags = [];\n      }\n    }\n    return tags;\n  }\n\n  interpolateVariablesInQueries(queries: GraphiteQuery[], scopedVars: ScopedVars): GraphiteQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map((query) => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.getRef(),\n          target: this.templateSrv.replace(query.target ?? '', scopedVars),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  annotationQuery(options: any) {\n    // Graphite metric as annotation\n    if (options.annotation.target) {\n      const target = this.templateSrv.replace(options.annotation.target, {}, 'glob');\n      const graphiteQuery = {\n        range: options.range,\n        targets: [{ target: target }],\n        format: 'json',\n        maxDataPoints: 100,\n      } as unknown as DataQueryRequest<GraphiteQuery>;\n\n      return lastValueFrom(\n        this.query(graphiteQuery).pipe(\n          map((result: any) => {\n            const list = [];\n\n            for (let i = 0; i < result.data.length; i++) {\n              const target = result.data[i];\n\n              for (let y = 0; y < target.length; y++) {\n                const time = target.fields[0].values.get(y);\n                const value = target.fields[1].values.get(y);\n\n                if (!value) {\n                  continue;\n                }\n\n                list.push({\n                  annotation: options.annotation,\n                  time,\n                  title: target.name,\n                });\n              }\n            }\n\n            return list;\n          })\n        )\n      );\n    } else {\n      // Graphite event as annotation\n      const tags = this.templateSrv.replace(options.annotation.tags);\n      return this.events({ range: options.range, tags: tags }).then((results: any) => {\n        const list = [];\n        if (!isArray(results.data)) {\n          console.error(`Unable to get annotations from ${results.url}.`);\n          return [];\n        }\n        for (let i = 0; i < results.data.length; i++) {\n          const e = results.data[i];\n\n          let tags = e.tags;\n          if (isString(e.tags)) {\n            tags = this.parseTags(e.tags);\n          }\n\n          list.push({\n            annotation: options.annotation,\n            time: e.when * 1000,\n            title: e.what,\n            tags: tags,\n            text: e.data,\n          });\n        }\n\n        return list;\n      });\n    }\n  }\n\n  events(options: { range: TimeRange; tags: any; timezone?: any }) {\n    try {\n      let tags = '';\n      if (options.tags) {\n        tags = '&tags=' + options.tags;\n      }\n      return lastValueFrom(\n        this.doGraphiteRequest({\n          method: 'GET',\n          url:\n            '/events/get_data?from=' +\n            this.translateTime(options.range.raw.from, false, options.timezone) +\n            '&until=' +\n            this.translateTime(options.range.raw.to, true, options.timezone) +\n            tags,\n        })\n      );\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  targetContainsTemplate(target: GraphiteQuery) {\n    return this.templateSrv.containsTemplate(target.target ?? '');\n  }\n\n  translateTime(date: any, roundUp: any, timezone: any) {\n    if (isString(date)) {\n      if (date === 'now') {\n        return 'now';\n      } else if (date.indexOf('now-') >= 0 && date.indexOf('/') === -1) {\n        date = date.substring(3);\n        date = date.replace('m', 'min');\n        date = date.replace('M', 'mon');\n        return date;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    // graphite' s from filter is exclusive\n    // here we step back one minute in order\n    // to guarantee that we get all the data that\n    // exists for the specified range\n    if (roundUp) {\n      if (date.get('s')) {\n        date.add(1, 's');\n      }\n    } else if (roundUp === false) {\n      if (date.get('s')) {\n        date.subtract(1, 's');\n      }\n    }\n\n    return date.unix();\n  }\n\n  metricFindQuery(query: string, optionalOptions?: any): Promise<MetricFindValue[]> {\n    const options: any = optionalOptions || {};\n\n    // First attempt to check for tag-related functions (using empty wildcard for interpolation)\n    let interpolatedQuery = this.templateSrv.replace(\n      query,\n      getSearchFilterScopedVar({ query, wildcardChar: '', options: optionalOptions })\n    );\n\n    // special handling for tag_values(<tag>[,<expression>]*), this is used for template variables\n    let allParams = interpolatedQuery.match(/^tag_values\\((.*)\\)$/);\n    let expressions = allParams ? allParams[1].split(',').filter((p) => !!p) : undefined;\n    if (expressions) {\n      options.limit = 10000;\n      return this.getTagValuesAutoComplete(expressions.slice(1), expressions[0], undefined, options);\n    }\n\n    // special handling for tags(<expression>[,<expression>]*), this is used for template variables\n    allParams = interpolatedQuery.match(/^tags\\((.*)\\)$/);\n    expressions = allParams ? allParams[1].split(',').filter((p) => !!p) : undefined;\n    if (expressions) {\n      options.limit = 10000;\n      return this.getTagsAutoComplete(expressions, undefined, options);\n    }\n\n    // If no tag-related query was found, perform metric-based search (using * as the wildcard for interpolation)\n    let useExpand = query.match(/^expand\\((.*)\\)$/);\n    query = useExpand ? useExpand[1] : query;\n\n    interpolatedQuery = this.templateSrv.replace(\n      query,\n      getSearchFilterScopedVar({ query, wildcardChar: '*', options: optionalOptions })\n    );\n\n    let range;\n    if (options.range) {\n      range = {\n        from: this.translateTime(options.range.from, false, options.timezone),\n        until: this.translateTime(options.range.to, true, options.timezone),\n      };\n    }\n\n    if (useExpand) {\n      return this.requestMetricExpand(interpolatedQuery, options.requestId, range);\n    } else {\n      return this.requestMetricFind(interpolatedQuery, options.requestId, range);\n    }\n  }\n\n  /**\n   * Search for metrics matching giving pattern using /metrics/find endpoint. It will\n   * return all possible values at the last level of the query, for example:\n   *\n   * metrics: prod.servers.001.cpu, prod.servers.002.cpu\n   * query: *.servers.*\n   * result: 001, 002\n   *\n   * For more complex searches use requestMetricExpand\n   */\n  private requestMetricFind(\n    query: string,\n    requestId: string,\n    range?: { from: any; until: any }\n  ): Promise<MetricFindValue[]> {\n    const httpOptions: any = {\n      method: 'POST',\n      url: '/metrics/find',\n      params: {},\n      data: `query=${query}`,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      // for cancellations\n      requestId: requestId,\n    };\n\n    if (range) {\n      httpOptions.params.from = range.from;\n      httpOptions.params.until = range.until;\n    }\n\n    return lastValueFrom(\n      this.doGraphiteRequest(httpOptions).pipe(\n        map((results: any) => {\n          return _map(results.data, (metric) => {\n            return {\n              text: metric.text,\n              expandable: metric.expandable ? true : false,\n            };\n          });\n        })\n      )\n    );\n  }\n\n  /**\n   * Search for metrics matching giving pattern using /metrics/expand endpoint.\n   * The result will contain all metrics (with full name) matching provided query.\n   * It's a more flexible version of /metrics/find endpoint (@see requestMetricFind)\n   */\n  private requestMetricExpand(\n    query: string,\n    requestId: string,\n    range?: { from: any; until: any }\n  ): Promise<MetricFindValue[]> {\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/metrics/expand',\n      params: { query },\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      // for cancellations\n      requestId,\n    };\n\n    if (range) {\n      httpOptions.params.from = range.from;\n      httpOptions.params.until = range.until;\n    }\n\n    return lastValueFrom(\n      this.doGraphiteRequest(httpOptions).pipe(\n        map((results: any) => {\n          return _map(results.data.results, (metric) => {\n            return {\n              text: metric,\n              expandable: false,\n            };\n          });\n        })\n      )\n    );\n  }\n\n  getTags(optionalOptions: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags',\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return lastValueFrom(\n      this.doGraphiteRequest(httpOptions).pipe(\n        map((results: any) => {\n          return _map(results.data, (tag) => {\n            return {\n              text: tag.tag,\n              id: tag.id,\n            };\n          });\n        })\n      )\n    );\n  }\n\n  getTagValues(options: any = {}) {\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags/' + this.templateSrv.replace(options.key),\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return lastValueFrom(\n      this.doGraphiteRequest(httpOptions).pipe(\n        map((results: any) => {\n          if (results.data && results.data.values) {\n            return _map(results.data.values, (value) => {\n              return {\n                text: value.value,\n                id: value.id,\n              };\n            });\n          } else {\n            return [];\n          }\n        })\n      )\n    );\n  }\n\n  getTagsAutoComplete(expressions: any[], tagPrefix: any, optionalOptions?: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags/autoComplete/tags',\n      params: {\n        expr: _map(expressions, (expression) => this.templateSrv.replace((expression || '').trim())),\n      },\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (tagPrefix) {\n      httpOptions.params.tagPrefix = tagPrefix;\n    }\n    if (options.limit) {\n      httpOptions.params.limit = options.limit;\n    }\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n    return lastValueFrom(this.doGraphiteRequest(httpOptions).pipe(mapToTags()));\n  }\n\n  getTagValuesAutoComplete(expressions: any[], tag: any, valuePrefix: any, optionalOptions: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags/autoComplete/values',\n      params: {\n        expr: _map(expressions, (expression) => this.templateSrv.replace((expression || '').trim())),\n        tag: this.templateSrv.replace((tag || '').trim()),\n      },\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (valuePrefix) {\n      httpOptions.params.valuePrefix = valuePrefix;\n    }\n    if (options.limit) {\n      httpOptions.params.limit = options.limit;\n    }\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n    return lastValueFrom(this.doGraphiteRequest(httpOptions).pipe(mapToTags()));\n  }\n\n  getVersion(optionalOptions: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions = {\n      method: 'GET',\n      url: '/version',\n      requestId: options.requestId,\n    };\n\n    return lastValueFrom(\n      this.doGraphiteRequest(httpOptions).pipe(\n        map((results: any) => {\n          if (results.data) {\n            const semver = new SemVersion(results.data);\n            return semver.isValid() ? results.data : '';\n          }\n          return '';\n        }),\n        catchError(() => {\n          return of('');\n        })\n      )\n    );\n  }\n\n  createFuncInstance(funcDef: any, options?: any): FuncInstance {\n    return gfunc.createFuncInstance(funcDef, options, this.funcDefs);\n  }\n\n  getFuncDef(name: string) {\n    return gfunc.getFuncDef(name, this.funcDefs);\n  }\n\n  waitForFuncDefsLoaded() {\n    return this.getFuncDefs();\n  }\n\n  getFuncDefs() {\n    if (this.funcDefsPromise !== null) {\n      return this.funcDefsPromise;\n    }\n\n    if (!supportsFunctionIndex(this.graphiteVersion)) {\n      this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\n      this.funcDefsPromise = Promise.resolve(this.funcDefs);\n      return this.funcDefsPromise;\n    }\n\n    const httpOptions = {\n      method: 'GET',\n      url: '/functions',\n      // add responseType because if this is not defined,\n      // backend_srv defaults to json\n      responseType: 'text',\n    };\n\n    return lastValueFrom(\n      this.doGraphiteRequest(httpOptions).pipe(\n        map((results: any) => {\n          // Fix for a Graphite bug: https://github.com/graphite-project/graphite-web/issues/2609\n          // There is a fix for it https://github.com/graphite-project/graphite-web/pull/2612 but\n          // it was merged to master in July 2020 but it has never been released (the last Graphite\n          // release was 1.1.7 - March 2020). The bug was introduced in Graphite 1.1.7, in versions\n          // 1.1.0 - 1.1.6 /functions endpoint returns a valid JSON\n          const fixedData = JSON.parse(results.data.replace(/\"default\": ?Infinity/g, '\"default\": 1e9999'));\n          this.funcDefs = gfunc.parseFuncDefs(fixedData);\n          return this.funcDefs;\n        }),\n        catchError((error: any) => {\n          console.error('Fetching graphite functions error', error);\n          this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\n          return of(this.funcDefs);\n        })\n      )\n    );\n  }\n\n  testDatasource() {\n    const query = {\n      panelId: 3,\n      rangeRaw: { from: 'now-1h', to: 'now' },\n      range: {\n        raw: { from: 'now-1h', to: 'now' },\n      },\n      targets: [{ target: 'constantLine(100)' }],\n      maxDataPoints: 300,\n    } as unknown as DataQueryRequest<GraphiteQuery>;\n\n    return lastValueFrom(this.query(query)).then(() => ({ status: 'success', message: 'Data source is working' }));\n  }\n\n  doGraphiteRequest(options: {\n    method?: string;\n    url: any;\n    requestId?: any;\n    withCredentials?: any;\n    headers?: any;\n    inspect?: any;\n  }) {\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = options.headers || {};\n      options.headers.Authorization = this.basicAuth;\n    }\n\n    options.url = this.url + options.url;\n    options.inspect = { type: 'graphite' };\n\n    return getBackendSrv()\n      .fetch(options)\n      .pipe(\n        catchError((err: any) => {\n          return throwError(reduceError(err));\n        })\n      );\n  }\n\n  buildGraphiteParams(options: any, scopedVars?: ScopedVars): string[] {\n    const graphiteOptions = ['from', 'until', 'rawData', 'format', 'maxDataPoints', 'cacheTimeout'];\n    const cleanOptions = [],\n      targets: any = {};\n    let target, targetValue, i;\n    const regex = /\\#([A-Z])/g;\n    const intervalFormatFixRegex = /'(\\d+)m'/gi;\n    let hasTargets = false;\n\n    options['format'] = 'json';\n\n    function fixIntervalFormat(match: any) {\n      return match.replace('m', 'min').replace('M', 'mon');\n    }\n\n    for (i = 0; i < options.targets.length; i++) {\n      target = options.targets[i];\n      if (!target.target) {\n        continue;\n      }\n\n      if (!target.refId) {\n        target.refId = this._seriesRefLetters[i];\n      }\n\n      targetValue = this.templateSrv.replace(target.target, scopedVars);\n      targetValue = targetValue.replace(intervalFormatFixRegex, fixIntervalFormat);\n      targets[target.refId] = targetValue;\n    }\n\n    function nestedSeriesRegexReplacer(match: any, g1: string | number) {\n      return targets[g1] || match;\n    }\n\n    for (i = 0; i < options.targets.length; i++) {\n      target = options.targets[i];\n      if (!target.target) {\n        continue;\n      }\n\n      targetValue = targets[target.refId];\n      targetValue = targetValue.replace(regex, nestedSeriesRegexReplacer);\n      targets[target.refId] = targetValue;\n\n      if (!target.hide) {\n        hasTargets = true;\n        cleanOptions.push('target=' + encodeURIComponent(targetValue));\n      }\n    }\n\n    each(options, (value, key) => {\n      if (indexOf(graphiteOptions, key) === -1) {\n        return;\n      }\n      if (value) {\n        cleanOptions.push(key + '=' + encodeURIComponent(value));\n      }\n    });\n\n    if (!hasTargets) {\n      return [];\n    }\n\n    return cleanOptions;\n  }\n}\n\nfunction supportsTags(version: string): boolean {\n  return isVersionGtOrEq(version, '1.1');\n}\n\nfunction supportsFunctionIndex(version: string): boolean {\n  return isVersionGtOrEq(version, '1.1');\n}\n\nfunction mapToTags(): OperatorFunction<any, Array<{ text: string }>> {\n  return pipe(\n    map((results: any) => {\n      if (results.data) {\n        return _map(results.data, (value) => {\n          return { text: value };\n        });\n      } else {\n        return [];\n      }\n    })\n  );\n}\n"],"mappings":";;AAAA,SAASA,IAAT,EAAeC,OAAf,EAAwBC,OAAxB,EAAiCC,QAAjC,EAA2CC,GAAG,IAAIC,IAAlD,QAA8D,QAA9D;AACA,SAASC,aAAT,EAAoCC,EAApC,EAA0DC,IAA1D,EAAgEC,UAAhE,QAAkF,MAAlF;AACA,SAASC,UAAT,EAAqBN,GAArB,QAAgC,gBAAhC;AAEA,SAIEO,aAJF,EAMEC,QANF,EAQEC,qBARF,EAcEC,WAdF,QAeO,eAfP;AAgBA,SAASC,aAAT,QAA8B,kBAA9B;AACA,SAASC,eAAT,EAA0BC,UAA1B,QAA4C,wBAA5C;AACA,SAASC,cAAT,QAA4C,sCAA5C;AACA,SAASC,eAAT,EAA0BC,6BAA1B,QAA+D,sCAA/D;AAEA,SAASC,wBAAT,QAAyC,mCAAzC;AAEA,OAAOC,KAAP,MAA8C,SAA9C;AACA,OAAOC,kBAAP,MAA+B,kBAA/B,C,CACA;;AACA,SAMEC,YANF,QAQO,SARP;AASA,SAASC,WAAT,QAA4B,SAA5B;AACA,SAASC,wBAAT,QAAyC,YAAzC;AAEA,MAAMC,wBAAwB,GAAG;EAC/B,KAAKd,qBAAqB,CAACe,KADI;EAE/B,MAAMf,qBAAqB,CAACgB,QAFG;EAG/B,MAAMhB,qBAAqB,CAACiB,UAHG;EAI/B,OAAOjB,qBAAqB,CAACkB;AAJE,CAAjC;AAOA;AACA;AACA;;AACA,SAASC,kBAAT,CAA4BC,IAA5B,EAAkD;EAChD,IAAIA,IAAI,CAACC,QAAL,CAAc,GAAd,KAAsBD,IAAI,CAACC,QAAL,CAAc,GAAd,CAA1B,EAA8C;IAC5C,OAAO,MAAMD,IAAI,CAACE,OAAL,CAAa,KAAb,EAAoB,IAApB,EAA0BA,OAA1B,CAAkC,KAAlC,EAAyC,GAAzC,EAA8CA,OAA9C,CAAsD,IAAtD,EAA4D,GAA5D,EAAiEA,OAAjE,CAAyE,IAAzE,EAA+E,GAA/E,CAAb;EACD,CAFD,MAEO;IACL,OAAOF,IAAP;EACD;AACF;;AAED,OAAO,MAAMG,kBAAN,SACGzB,aADH,CAGP;EAeE0B,WAAW,CAACC,gBAAD,EAAyCC,WAAwB,GAAGrB,cAAc,EAAlF,EAAsF;IAAA;;IAC/F,MAAMoB,gBAAN;;IAD+F;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA,kCALrE,IAKqE;;IAAA,yCAJ1D,IAI0D;;IAAA;;IAAA;;IAAA,qDAsJlEE,MAAD,IAAoC;MAChE,MAAMC,IAAiB,GAAG,EAA1B;;MACA,IAAI,CAACD,MAAD,IAAW,CAACA,MAAM,CAACC,IAAvB,EAA6B;QAC3B,OAAO;UAAEA;QAAF,CAAP;MACD,CAJ+D,CAMhE;;;MACA,MAAMC,MAAM,GAAGF,MAAM,CAACC,IAAP,CAAYC,MAAZ,IAAsBF,MAAM,CAACC,IAA5C;;MAEA,IAAI,CAACvC,OAAO,CAACwC,MAAD,CAAZ,EAAsB;QACpB,MAAM;UAAEC,OAAO,EAAE,0BAAX;UAAuCF,IAAI,EAAED;QAA7C,CAAN;MACD;;MAED,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACG,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;QACtC,MAAME,CAAC,GAAGJ,MAAM,CAACE,CAAD,CAAhB,CADsC,CAGtC;;QACAE,CAAC,CAACC,KAAF,GAAUD,CAAC,CAACE,MAAZ;;QAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACI,UAAF,CAAaL,MAAjC,EAAyCI,CAAC,EAA1C,EAA8C;UAC5CH,CAAC,CAACI,UAAF,CAAaD,CAAb,EAAgB,CAAhB,KAAsB,IAAtB;QACD;;QAED,MAAME,KAAK,GAAGrC,WAAW,CAACgC,CAAD,CAAzB,CAVsC,CAYtC;;QACA,IAAIA,CAAC,CAACM,IAAN,EAAY;UACVD,KAAK,CAACC,IAAN,GAAa;YACXC,MAAM,EAAE;cACNC,eAAe,EAAEd,MAAM,CAACC,IAAP,CAAYW,IADvB;cAC6B;cACnCG,cAAc,EAAET,CAAC,CAACM,IAFZ,CAEkB;;YAFlB;UADG,CAAb;;UAOA,IAAI,KAAKI,sBAAT,EAAiC;YAC/B,MAAMC,YAAY,GAAGtC,eAAe,CAAC2B,CAAC,CAACM,IAAH,CAApC;YACA,MAAMM,aAAa,GAAGtC,6BAA6B,CAAC0B,CAAC,CAACM,IAAH,CAAnD;;YAEA,IAAIK,YAAJ,EAAkB;cAChBN,KAAK,CAACC,IAAN,CAAWO,OAAX,GAAqB,CAACF,YAAD,CAArB;YACD,CAFD,MAEO,IAAIC,aAAJ,EAAmB;cACxBP,KAAK,CAACC,IAAN,CAAWO,OAAX,GAAqB,CAACD,aAAD,CAArB;YACD;UACF,CAjBS,CAmBV;;;UACA,IAAId,CAAC,KAAK,CAAN,IAAWJ,MAAM,CAACC,IAAP,CAAYW,IAAZ,CAAiBQ,KAAhC,EAAuC;YACrCT,KAAK,CAACC,IAAN,CAAWQ,KAAX,GAAmB,KAAKC,eAAL,CAAqBrB,MAAM,CAACC,IAAP,CAAYW,IAAjC,CAAnB;UACD;QACF;;QAEDX,IAAI,CAACqB,IAAL,CAAUX,KAAV;MACD;;MAED,OAAO;QAAEV;MAAF,CAAP;IACD,CA7MgG;;IAAA,KAA7CF,WAA6C,GAA7CA,WAA6C;IAE/F,KAAKwB,SAAL,GAAiBzB,gBAAgB,CAACyB,SAAlC;IACA,KAAKC,GAAL,GAAW1B,gBAAgB,CAAC0B,GAA5B;IACA,KAAKC,IAAL,GAAY3B,gBAAgB,CAAC2B,IAA7B,CAJ+F,CAK/F;IACA;;IACA,KAAKC,eAAL,GAAuB5B,gBAAgB,CAAC6B,QAAjB,CAA0BD,eAA1B,IAA6CxC,wBAApE;IACA,KAAK0C,cAAL,GAAsB,0BAAA9B,gBAAgB,CAAC6B,QAAjB,CAA0BE,mBAA1B,0GAA+CC,IAA/C,kFAAqDC,QAArD,KAAiE,EAAvF;IACA,KAAKC,YAAL,GAAoBlC,gBAAgB,CAAC6B,QAAjB,CAA0BM,YAA1B,KAA2CjD,YAAY,CAACkD,UAA5E;IACA,KAAKC,YAAL,GAAoBA,YAAY,CAAC,KAAKT,eAAN,CAAhC;IACA,KAAKU,YAAL,GAAoBtC,gBAAgB,CAACsC,YAArC;IACA,KAAKpB,sBAAL,GAA8BlB,gBAAgB,CAAC6B,QAAjB,CAA0BX,sBAAxD;IACA,KAAKqB,eAAL,GAAuBvC,gBAAgB,CAACuC,eAAxC;IACA,KAAKC,QAAL,GAAgB,IAAhB;IACA,KAAKC,eAAL,GAAuB,IAAvB;IACA,KAAKC,iBAAL,GAAyB,4BAAzB;EACD;;EAEDC,mBAAmB,GAAG;IACpB,OAAO;MACLC,aAAa,EAAE,IADV;MAELN,YAAY,EAAE,IAFT;MAGLO,KAAK,EAAE,CACL;QACElD,IAAI,EAAE,MADR;QAEE+B,GAAG,EAAE;MAFP,CADK;IAHF,CAAP;EAUD;;EAEDoB,2BAA2B,GAAqC;IAC9D,OAAO;MACLd,IAAI,EAAE;QACJC,QAAQ,EAAE,KAAKH;MADX;IADD,CAAP;EAKD;;EAE4B,MAAvBiB,uBAAuB,CAACC,OAAD,EAAqD;IAChF,OAAOA,OAAO,CAAClF,GAAR,CAAamF,KAAD,IAAW,KAAKC,qBAAL,CAA2BD,KAA3B,CAAvB,CAAP;EACD;;EAEDC,qBAAqB,CAACD,KAAD,EAAsC;IACzD,MAAME,aAAiC,GAAG,IAAIlE,kBAAJ,CACxC,IADwC,oBAGnCgE,KAHmC;MAItCvC,MAAM,EAAEuC,KAAK,CAACvC,MAAN,IAAgB,EAJc;MAKtC0C,UAAU,EAAE;IAL0B,IAOxCxE,cAAc,EAP0B,CAA1C;IASAuE,aAAa,CAACE,WAAd;IAEA,IAAIC,MAA8B,GAAG,EAArC;IACA,MAAMC,MAAM,GAAG,KAAKT,2BAAL,GAAmCd,IAAlD;;IAEA,IAAImB,aAAa,CAACK,eAAlB,EAAmC;MACjCL,aAAa,CAACM,IAAd,CAAmBC,OAAnB,CAA4BC,GAAD,IAAS;QAClCL,MAAM,CAAC9B,IAAP,CAAY;UACVG,IAAI,EAAEgC,GAAG,CAACC,GADA;UAEVC,QAAQ,EAAExE,wBAAwB,CAACsE,GAAG,CAACE,QAAL,CAFxB;UAGVC,KAAK,EAAEH,GAAG,CAACG;QAHD,CAAZ;MAKD,CAND;IAOD,CARD,MAQO;MACL,MAAMC,WAAW,GAAGZ,aAAa,CAACa,QAAd,CAAuBlG,GAAvB,CAA4BmG,OAAD,IAAaA,OAAO,CAACH,KAAhD,CAApB;MACA,IAAI7B,QAAQ,GAAGsB,MAAM,CAACtB,QAAP,CAAgBiC,MAAhB,CAAwBC,OAAD,IAAaA,OAAO,CAACC,QAAR,CAAiB7D,MAAjB,IAA2BwD,WAAW,CAACxD,MAA3E,CAAf;;MAEA,KAAK,IAAI4D,OAAT,IAAoBlC,QAApB,EAA8B;QAC5B,MAAMmC,QAAQ,GAAGD,OAAO,CAACC,QAAR,CAAiBC,MAAjB,EAAjB;QAEAD,QAAQ,CAACE,KAAT,CAAe,CAACC,OAAD,EAAqCC,KAArC,KAAuD;UACpE,IAAID,OAAO,CAACE,SAAZ,EAAuB;YACrB,IAAIX,KAAK,GAAIC,WAAW,CAACS,KAAD,CAAxB;;YAEA,IAAIV,KAAK,KAAK,GAAd,EAAmB;cACjB,OAAO,IAAP;YACD;;YAED,MAAMY,SAAS,GAAGhF,kBAAkB,CAACoE,KAAD,CAApC;YACAR,MAAM,CAAC9B,IAAP,CAAY;cACVG,IAAI,EAAE4C,OAAO,CAACE,SADJ;cAEVZ,QAAQ,EAAEa,SAAS,KAAKZ,KAAd,GAAsBvF,qBAAqB,CAACiB,UAA5C,GAAyDjB,qBAAqB,CAACe,KAF/E;cAGVwE,KAAK,EAAEY;YAHG,CAAZ;YAKA,OAAO,IAAP;UACD;;UACD,OAAOX,WAAW,CAACS,KAAD,CAAX,KAAuBD,OAAO,CAACT,KAA/B,IAAwCS,OAAO,CAACT,KAAR,KAAkB,GAAjE;QACD,CAjBD;MAkBD;IACF;;IAED,OAAO;MACLa,KAAK,EAAE1B,KAAK,CAAC0B,KADR;MAELC,aAAa,EAAEtB;IAFV,CAAP;EAID;;EAEDL,KAAK,CAAC4B,OAAD,EAA0E;IAC7E,MAAMC,YAAY,GAAG;MACnBC,IAAI,EAAE,KAAKC,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcC,GAAd,CAAkBH,IAArC,EAA2C,KAA3C,EAAkDF,OAAO,CAACM,QAA1D,CADa;MAEnBC,KAAK,EAAE,KAAKJ,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcC,GAAd,CAAkBG,EAArC,EAAyC,IAAzC,EAA+CR,OAAO,CAACM,QAAvD,CAFY;MAGnBG,OAAO,EAAET,OAAO,CAACS,OAHE;MAInBC,MAAM,EAAGV,OAAD,CAAiBU,MAJN;MAKnBjD,YAAY,EAAEuC,OAAO,CAACvC,YAAR,IAAwB,KAAKA,YALxB;MAMnBM,aAAa,EAAEiC,OAAO,CAACjC;IANJ,CAArB;IASA,MAAM4C,MAAM,GAAG,KAAKC,mBAAL,CAAyBX,YAAzB,EAAuCD,OAAO,CAACa,UAA/C,CAAf;;IACA,IAAIF,MAAM,CAACjF,MAAP,KAAkB,CAAtB,EAAyB;MACvB,OAAOtC,EAAE,CAAC;QAAEkC,IAAI,EAAE;MAAR,CAAD,CAAT;IACD;;IAED,IAAI,KAAK+B,YAAT,EAAuB;MACrBsD,MAAM,CAAChE,IAAP,CAAY,WAAZ;IACD;;IAED,MAAMmE,WAAgB,GAAG;MACvBC,MAAM,EAAE,MADe;MAEvBlE,GAAG,EAAE,SAFkB;MAGvBvB,IAAI,EAAEqF,MAAM,CAACK,IAAP,CAAY,GAAZ,CAHiB;MAIvBC,OAAO,EAAE;QACP,gBAAgB;MADT;IAJc,CAAzB;IASA,KAAKC,iBAAL,CAAuBJ,WAAvB,EAAoCd,OAApC;;IAEA,IAAIA,OAAO,CAACmB,OAAZ,EAAqB;MACnBL,WAAW,CAACM,SAAZ,GAAwB,KAAKtE,IAAL,GAAY,WAAZ,GAA0BkD,OAAO,CAACmB,OAA1D;IACD;;IAED,OAAO,KAAKE,iBAAL,CAAuBP,WAAvB,EAAoCzH,IAApC,CAAyCJ,GAAG,CAAC,KAAKqI,2BAAN,CAA5C,CAAP;EACD;;EAEDJ,iBAAiB,CAACJ,WAAD,EAAgCd,OAAhC,EAAqF;IACpG,MAAMuB,SAAS,GAAG,CAAC,KAAK1E,GAAL,CAAS2E,KAAT,CAAe,OAAf,CAAnB;;IACA,IAAID,SAAJ,EAAe;MACb,IAAIvB,OAAO,CAACyB,WAAZ,EAAyB;QACvBX,WAAW,CAACG,OAAZ,CAAoB,gBAApB,IAAwCjB,OAAO,CAACyB,WAAhD;MACD;;MACD,IAAIzB,OAAO,CAACmB,OAAZ,EAAqB;QACnBL,WAAW,CAACG,OAAZ,CAAoB,YAApB,IAAoCjB,OAAO,CAACmB,OAA5C;MACD;IACF;EACF;;EA2DDzE,eAAe,CAACT,IAAD,EAAqD;IAClE,MAAMQ,KAA4B,GAAG,EAArC;;IAEA,KAAK,MAAMsC,GAAX,IAAkB9C,IAAI,CAACQ,KAAvB,EAA8B;MAC5B,IAAIiF,IAAwB,GAAGC,SAA/B;;MAEA,IAAI5C,GAAG,CAAC6C,QAAJ,CAAa,KAAb,CAAJ,EAAyB;QACvBF,IAAI,GAAG,IAAP;MACD;;MAEDjF,KAAK,CAACE,IAAN,CAAW;QAAEkF,WAAW,EAAE9C,GAAf;QAAoBE,KAAK,EAAEhD,IAAI,CAACQ,KAAL,CAAWsC,GAAX,CAA3B;QAA4C2C;MAA5C,CAAX;IACD;;IAED,OAAOjF,KAAP;EACD;;EAEDqF,SAAS,CAACC,SAAD,EAAoB;IAC3B,IAAInD,IAAc,GAAG,EAArB;IACAA,IAAI,GAAGmD,SAAS,CAACC,KAAV,CAAgB,GAAhB,CAAP;;IACA,IAAIpD,IAAI,CAAClD,MAAL,KAAgB,CAApB,EAAuB;MACrBkD,IAAI,GAAGmD,SAAS,CAACC,KAAV,CAAgB,GAAhB,CAAP;;MACA,IAAIpD,IAAI,CAAC,CAAD,CAAJ,KAAY,EAAhB,EAAoB;QAClBA,IAAI,GAAG,EAAP;MACD;IACF;;IACD,OAAOA,IAAP;EACD;;EAEDqD,6BAA6B,CAAC9D,OAAD,EAA2B0C,UAA3B,EAAoE;IAC/F,IAAIqB,eAAe,GAAG/D,OAAtB;;IACA,IAAIA,OAAO,IAAIA,OAAO,CAACzC,MAAR,GAAiB,CAAhC,EAAmC;MACjCwG,eAAe,GAAG/D,OAAO,CAAClF,GAAR,CAAamF,KAAD,IAAW;QAAA;;QACvC,MAAM+D,aAAa,qBACd/D,KADc;UAEjBgE,UAAU,EAAE,KAAKC,MAAL,EAFK;UAGjBxG,MAAM,EAAE,KAAKT,WAAL,CAAiBJ,OAAjB,kBAAyBoD,KAAK,CAACvC,MAA/B,yDAAyC,EAAzC,EAA6CgF,UAA7C;QAHS,EAAnB;QAKA,OAAOsB,aAAP;MACD,CAPiB,CAAlB;IAQD;;IACD,OAAOD,eAAP;EACD;;EAEDI,eAAe,CAACtC,OAAD,EAAe;IAC5B;IACA,IAAIA,OAAO,CAACuC,UAAR,CAAmB1G,MAAvB,EAA+B;MAC7B,MAAMA,MAAM,GAAG,KAAKT,WAAL,CAAiBJ,OAAjB,CAAyBgF,OAAO,CAACuC,UAAR,CAAmB1G,MAA5C,EAAoD,EAApD,EAAwD,MAAxD,CAAf;MACA,MAAMyC,aAAa,GAAG;QACpB8B,KAAK,EAAEJ,OAAO,CAACI,KADK;QAEpBK,OAAO,EAAE,CAAC;UAAE5E,MAAM,EAAEA;QAAV,CAAD,CAFW;QAGpB6E,MAAM,EAAE,MAHY;QAIpB3C,aAAa,EAAE;MAJK,CAAtB;MAOA,OAAO5E,aAAa,CAClB,KAAKiF,KAAL,CAAWE,aAAX,EAA0BjF,IAA1B,CACEJ,GAAG,CAAEoC,MAAD,IAAiB;QACnB,MAAMmH,IAAI,GAAG,EAAb;;QAEA,KAAK,IAAI/G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACC,IAAP,CAAYI,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;UAC3C,MAAMI,MAAM,GAAGR,MAAM,CAACC,IAAP,CAAYG,CAAZ,CAAf;;UAEA,KAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAAM,CAACH,MAA3B,EAAmCI,CAAC,EAApC,EAAwC;YACtC,MAAM2G,IAAI,GAAG5G,MAAM,CAAC6G,MAAP,CAAc,CAAd,EAAiBC,MAAjB,CAAwBC,GAAxB,CAA4B9G,CAA5B,CAAb;YACA,MAAMmD,KAAK,GAAGpD,MAAM,CAAC6G,MAAP,CAAc,CAAd,EAAiBC,MAAjB,CAAwBC,GAAxB,CAA4B9G,CAA5B,CAAd;;YAEA,IAAI,CAACmD,KAAL,EAAY;cACV;YACD;;YAEDuD,IAAI,CAAC7F,IAAL,CAAU;cACR4F,UAAU,EAAEvC,OAAO,CAACuC,UADZ;cAERE,IAFQ;cAGR7G,KAAK,EAAEC,MAAM,CAACiB;YAHN,CAAV;UAKD;QACF;;QAED,OAAO0F,IAAP;MACD,CAvBE,CADL,CADkB,CAApB;IA4BD,CArCD,MAqCO;MACL;MACA,MAAM5D,IAAI,GAAG,KAAKxD,WAAL,CAAiBJ,OAAjB,CAAyBgF,OAAO,CAACuC,UAAR,CAAmB3D,IAA5C,CAAb;MACA,OAAO,KAAKiE,MAAL,CAAY;QAAEzC,KAAK,EAAEJ,OAAO,CAACI,KAAjB;QAAwBxB,IAAI,EAAEA;MAA9B,CAAZ,EAAkDkE,IAAlD,CAAwDC,OAAD,IAAkB;QAC9E,MAAMP,IAAI,GAAG,EAAb;;QACA,IAAI,CAACzJ,OAAO,CAACgK,OAAO,CAACzH,IAAT,CAAZ,EAA4B;UAC1B0H,OAAO,CAACC,KAAR,CAAe,kCAAiCF,OAAO,CAAClG,GAAI,GAA5D;UACA,OAAO,EAAP;QACD;;QACD,KAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsH,OAAO,CAACzH,IAAR,CAAaI,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;UAC5C,MAAMyH,CAAC,GAAGH,OAAO,CAACzH,IAAR,CAAaG,CAAb,CAAV;UAEA,IAAImD,IAAI,GAAGsE,CAAC,CAACtE,IAAb;;UACA,IAAI5F,QAAQ,CAACkK,CAAC,CAACtE,IAAH,CAAZ,EAAsB;YACpBA,IAAI,GAAG,KAAKkD,SAAL,CAAeoB,CAAC,CAACtE,IAAjB,CAAP;UACD;;UAED4D,IAAI,CAAC7F,IAAL,CAAU;YACR4F,UAAU,EAAEvC,OAAO,CAACuC,UADZ;YAERE,IAAI,EAAES,CAAC,CAACC,IAAF,GAAS,IAFP;YAGRvH,KAAK,EAAEsH,CAAC,CAACE,IAHD;YAIRxE,IAAI,EAAEA,IAJE;YAKR9D,IAAI,EAAEoI,CAAC,CAAC5H;UALA,CAAV;QAOD;;QAED,OAAOkH,IAAP;MACD,CAxBM,CAAP;IAyBD;EACF;;EAEDK,MAAM,CAAC7C,OAAD,EAA2D;IAC/D,IAAI;MACF,IAAIpB,IAAI,GAAG,EAAX;;MACA,IAAIoB,OAAO,CAACpB,IAAZ,EAAkB;QAChBA,IAAI,GAAG,WAAWoB,OAAO,CAACpB,IAA1B;MACD;;MACD,OAAOzF,aAAa,CAClB,KAAKkI,iBAAL,CAAuB;QACrBN,MAAM,EAAE,KADa;QAErBlE,GAAG,EACD,2BACA,KAAKsD,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcC,GAAd,CAAkBH,IAArC,EAA2C,KAA3C,EAAkDF,OAAO,CAACM,QAA1D,CADA,GAEA,SAFA,GAGA,KAAKH,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcC,GAAd,CAAkBG,EAArC,EAAyC,IAAzC,EAA+CR,OAAO,CAACM,QAAvD,CAHA,GAIA1B;MAPmB,CAAvB,CADkB,CAApB;IAWD,CAhBD,CAgBE,OAAOyE,GAAP,EAAY;MACZ,OAAOC,OAAO,CAACC,MAAR,CAAeF,GAAf,CAAP;IACD;EACF;;EAEDG,sBAAsB,CAAC3H,MAAD,EAAwB;IAAA;;IAC5C,OAAO,KAAKT,WAAL,CAAiBqI,gBAAjB,mBAAkC5H,MAAM,CAACA,MAAzC,2DAAmD,EAAnD,CAAP;EACD;;EAEDsE,aAAa,CAACuD,IAAD,EAAYC,OAAZ,EAA0BrD,QAA1B,EAAyC;IACpD,IAAItH,QAAQ,CAAC0K,IAAD,CAAZ,EAAoB;MAClB,IAAIA,IAAI,KAAK,KAAb,EAAoB;QAClB,OAAO,KAAP;MACD,CAFD,MAEO,IAAIA,IAAI,CAAC5K,OAAL,CAAa,MAAb,KAAwB,CAAxB,IAA6B4K,IAAI,CAAC5K,OAAL,CAAa,GAAb,MAAsB,CAAC,CAAxD,EAA2D;QAChE4K,IAAI,GAAGA,IAAI,CAACE,SAAL,CAAe,CAAf,CAAP;QACAF,IAAI,GAAGA,IAAI,CAAC1I,OAAL,CAAa,GAAb,EAAkB,KAAlB,CAAP;QACA0I,IAAI,GAAGA,IAAI,CAAC1I,OAAL,CAAa,GAAb,EAAkB,KAAlB,CAAP;QACA,OAAO0I,IAAP;MACD;;MACDA,IAAI,GAAGjK,QAAQ,CAACoK,KAAT,CAAeH,IAAf,EAAqBC,OAArB,EAA8BrD,QAA9B,CAAP;IACD,CAXmD,CAapD;IACA;IACA;IACA;;;IACA,IAAIqD,OAAJ,EAAa;MACX,IAAID,IAAI,CAACd,GAAL,CAAS,GAAT,CAAJ,EAAmB;QACjBc,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,GAAZ;MACD;IACF,CAJD,MAIO,IAAIH,OAAO,KAAK,KAAhB,EAAuB;MAC5B,IAAID,IAAI,CAACd,GAAL,CAAS,GAAT,CAAJ,EAAmB;QACjBc,IAAI,CAACK,QAAL,CAAc,CAAd,EAAiB,GAAjB;MACD;IACF;;IAED,OAAOL,IAAI,CAACM,IAAL,EAAP;EACD;;EAEDC,eAAe,CAAC7F,KAAD,EAAgB8F,eAAhB,EAAmE;IAChF,MAAMlE,OAAY,GAAGkE,eAAe,IAAI,EAAxC,CADgF,CAGhF;;IACA,IAAIC,iBAAiB,GAAG,KAAK/I,WAAL,CAAiBJ,OAAjB,CACtBoD,KADsB,EAEtBlE,wBAAwB,CAAC;MAAEkE,KAAF;MAASgG,YAAY,EAAE,EAAvB;MAA2BpE,OAAO,EAAEkE;IAApC,CAAD,CAFF,CAAxB,CAJgF,CAShF;;IACA,IAAIG,SAAS,GAAGF,iBAAiB,CAAC3C,KAAlB,CAAwB,sBAAxB,CAAhB;IACA,IAAI8C,WAAW,GAAGD,SAAS,GAAGA,SAAS,CAAC,CAAD,CAAT,CAAarC,KAAb,CAAmB,GAAnB,EAAwB3C,MAAxB,CAAgCkF,CAAD,IAAO,CAAC,CAACA,CAAxC,CAAH,GAAgD5C,SAA3E;;IACA,IAAI2C,WAAJ,EAAiB;MACftE,OAAO,CAACwE,KAAR,GAAgB,KAAhB;MACA,OAAO,KAAKC,wBAAL,CAA8BH,WAAW,CAACI,KAAZ,CAAkB,CAAlB,CAA9B,EAAoDJ,WAAW,CAAC,CAAD,CAA/D,EAAoE3C,SAApE,EAA+E3B,OAA/E,CAAP;IACD,CAf+E,CAiBhF;;;IACAqE,SAAS,GAAGF,iBAAiB,CAAC3C,KAAlB,CAAwB,gBAAxB,CAAZ;IACA8C,WAAW,GAAGD,SAAS,GAAGA,SAAS,CAAC,CAAD,CAAT,CAAarC,KAAb,CAAmB,GAAnB,EAAwB3C,MAAxB,CAAgCkF,CAAD,IAAO,CAAC,CAACA,CAAxC,CAAH,GAAgD5C,SAAvE;;IACA,IAAI2C,WAAJ,EAAiB;MACftE,OAAO,CAACwE,KAAR,GAAgB,KAAhB;MACA,OAAO,KAAKG,mBAAL,CAAyBL,WAAzB,EAAsC3C,SAAtC,EAAiD3B,OAAjD,CAAP;IACD,CAvB+E,CAyBhF;;;IACA,IAAI4E,SAAS,GAAGxG,KAAK,CAACoD,KAAN,CAAY,kBAAZ,CAAhB;IACApD,KAAK,GAAGwG,SAAS,GAAGA,SAAS,CAAC,CAAD,CAAZ,GAAkBxG,KAAnC;IAEA+F,iBAAiB,GAAG,KAAK/I,WAAL,CAAiBJ,OAAjB,CAClBoD,KADkB,EAElBlE,wBAAwB,CAAC;MAAEkE,KAAF;MAASgG,YAAY,EAAE,GAAvB;MAA4BpE,OAAO,EAAEkE;IAArC,CAAD,CAFN,CAApB;IAKA,IAAI9D,KAAJ;;IACA,IAAIJ,OAAO,CAACI,KAAZ,EAAmB;MACjBA,KAAK,GAAG;QACNF,IAAI,EAAE,KAAKC,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcF,IAAjC,EAAuC,KAAvC,EAA8CF,OAAO,CAACM,QAAtD,CADA;QAENC,KAAK,EAAE,KAAKJ,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcI,EAAjC,EAAqC,IAArC,EAA2CR,OAAO,CAACM,QAAnD;MAFD,CAAR;IAID;;IAED,IAAIsE,SAAJ,EAAe;MACb,OAAO,KAAKC,mBAAL,CAAyBV,iBAAzB,EAA4CnE,OAAO,CAACoB,SAApD,EAA+DhB,KAA/D,CAAP;IACD,CAFD,MAEO;MACL,OAAO,KAAK0E,iBAAL,CAAuBX,iBAAvB,EAA0CnE,OAAO,CAACoB,SAAlD,EAA6DhB,KAA7D,CAAP;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACU0E,iBAAiB,CACvB1G,KADuB,EAEvBgD,SAFuB,EAGvBhB,KAHuB,EAIK;IAC5B,MAAMU,WAAgB,GAAG;MACvBC,MAAM,EAAE,MADe;MAEvBlE,GAAG,EAAE,eAFkB;MAGvB8D,MAAM,EAAE,EAHe;MAIvBrF,IAAI,EAAG,SAAQ8C,KAAM,EAJE;MAKvB6C,OAAO,EAAE;QACP,gBAAgB;MADT,CALc;MAQvB;MACAG,SAAS,EAAEA;IATY,CAAzB;;IAYA,IAAIhB,KAAJ,EAAW;MACTU,WAAW,CAACH,MAAZ,CAAmBT,IAAnB,GAA0BE,KAAK,CAACF,IAAhC;MACAY,WAAW,CAACH,MAAZ,CAAmBJ,KAAnB,GAA2BH,KAAK,CAACG,KAAjC;IACD;;IAED,OAAOpH,aAAa,CAClB,KAAKkI,iBAAL,CAAuBP,WAAvB,EAAoCzH,IAApC,CACEJ,GAAG,CAAE8J,OAAD,IAAkB;MACpB,OAAO7J,IAAI,CAAC6J,OAAO,CAACzH,IAAT,EAAgByJ,MAAD,IAAY;QACpC,OAAO;UACLjK,IAAI,EAAEiK,MAAM,CAACjK,IADR;UAELkK,UAAU,EAAED,MAAM,CAACC,UAAP,GAAoB,IAApB,GAA2B;QAFlC,CAAP;MAID,CALU,CAAX;IAMD,CAPE,CADL,CADkB,CAApB;EAYD;EAED;AACF;AACA;AACA;AACA;;;EACUH,mBAAmB,CACzBzG,KADyB,EAEzBgD,SAFyB,EAGzBhB,KAHyB,EAIG;IAC5B,MAAMU,WAAgB,GAAG;MACvBC,MAAM,EAAE,KADe;MAEvBlE,GAAG,EAAE,iBAFkB;MAGvB8D,MAAM,EAAE;QAAEvC;MAAF,CAHe;MAIvB6C,OAAO,EAAE;QACP,gBAAgB;MADT,CAJc;MAOvB;MACAG;IARuB,CAAzB;;IAWA,IAAIhB,KAAJ,EAAW;MACTU,WAAW,CAACH,MAAZ,CAAmBT,IAAnB,GAA0BE,KAAK,CAACF,IAAhC;MACAY,WAAW,CAACH,MAAZ,CAAmBJ,KAAnB,GAA2BH,KAAK,CAACG,KAAjC;IACD;;IAED,OAAOpH,aAAa,CAClB,KAAKkI,iBAAL,CAAuBP,WAAvB,EAAoCzH,IAApC,CACEJ,GAAG,CAAE8J,OAAD,IAAkB;MACpB,OAAO7J,IAAI,CAAC6J,OAAO,CAACzH,IAAR,CAAayH,OAAd,EAAwBgC,MAAD,IAAY;QAC5C,OAAO;UACLjK,IAAI,EAAEiK,MADD;UAELC,UAAU,EAAE;QAFP,CAAP;MAID,CALU,CAAX;IAMD,CAPE,CADL,CADkB,CAApB;EAYD;;EAEDC,OAAO,CAACf,eAAD,EAAuB;IAC5B,MAAMlE,OAAO,GAAGkE,eAAe,IAAI,EAAnC;IAEA,MAAMpD,WAAgB,GAAG;MACvBC,MAAM,EAAE,KADe;MAEvBlE,GAAG,EAAE,OAFkB;MAGvB;MACAuE,SAAS,EAAEpB,OAAO,CAACoB;IAJI,CAAzB;;IAOA,IAAIpB,OAAO,CAACI,KAAZ,EAAmB;MACjBU,WAAW,CAACH,MAAZ,CAAmBT,IAAnB,GAA0B,KAAKC,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcF,IAAjC,EAAuC,KAAvC,EAA8CF,OAAO,CAACM,QAAtD,CAA1B;MACAQ,WAAW,CAACH,MAAZ,CAAmBJ,KAAnB,GAA2B,KAAKJ,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcI,EAAjC,EAAqC,IAArC,EAA2CR,OAAO,CAACM,QAAnD,CAA3B;IACD;;IAED,OAAOnH,aAAa,CAClB,KAAKkI,iBAAL,CAAuBP,WAAvB,EAAoCzH,IAApC,CACEJ,GAAG,CAAE8J,OAAD,IAAkB;MACpB,OAAO7J,IAAI,CAAC6J,OAAO,CAACzH,IAAT,EAAgBwD,GAAD,IAAS;QACjC,OAAO;UACLhE,IAAI,EAAEgE,GAAG,CAACA,GADL;UAELoG,EAAE,EAAEpG,GAAG,CAACoG;QAFH,CAAP;MAID,CALU,CAAX;IAMD,CAPE,CADL,CADkB,CAApB;EAYD;;EAEDC,YAAY,CAACnF,OAAY,GAAG,EAAhB,EAAoB;IAC9B,MAAMc,WAAgB,GAAG;MACvBC,MAAM,EAAE,KADe;MAEvBlE,GAAG,EAAE,WAAW,KAAKzB,WAAL,CAAiBJ,OAAjB,CAAyBgF,OAAO,CAACjB,GAAjC,CAFO;MAGvB;MACAqC,SAAS,EAAEpB,OAAO,CAACoB;IAJI,CAAzB;;IAOA,IAAIpB,OAAO,CAACI,KAAZ,EAAmB;MACjBU,WAAW,CAACH,MAAZ,CAAmBT,IAAnB,GAA0B,KAAKC,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcF,IAAjC,EAAuC,KAAvC,EAA8CF,OAAO,CAACM,QAAtD,CAA1B;MACAQ,WAAW,CAACH,MAAZ,CAAmBJ,KAAnB,GAA2B,KAAKJ,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcI,EAAjC,EAAqC,IAArC,EAA2CR,OAAO,CAACM,QAAnD,CAA3B;IACD;;IAED,OAAOnH,aAAa,CAClB,KAAKkI,iBAAL,CAAuBP,WAAvB,EAAoCzH,IAApC,CACEJ,GAAG,CAAE8J,OAAD,IAAkB;MACpB,IAAIA,OAAO,CAACzH,IAAR,IAAgByH,OAAO,CAACzH,IAAR,CAAaqH,MAAjC,EAAyC;QACvC,OAAOzJ,IAAI,CAAC6J,OAAO,CAACzH,IAAR,CAAaqH,MAAd,EAAuB1D,KAAD,IAAW;UAC1C,OAAO;YACLnE,IAAI,EAAEmE,KAAK,CAACA,KADP;YAELiG,EAAE,EAAEjG,KAAK,CAACiG;UAFL,CAAP;QAID,CALU,CAAX;MAMD,CAPD,MAOO;QACL,OAAO,EAAP;MACD;IACF,CAXE,CADL,CADkB,CAApB;EAgBD;;EAEDP,mBAAmB,CAACL,WAAD,EAAqBc,SAArB,EAAqClB,eAArC,EAA4D;IAC7E,MAAMlE,OAAO,GAAGkE,eAAe,IAAI,EAAnC;IAEA,MAAMpD,WAAgB,GAAG;MACvBC,MAAM,EAAE,KADe;MAEvBlE,GAAG,EAAE,yBAFkB;MAGvB8D,MAAM,EAAE;QACN0E,IAAI,EAAEnM,IAAI,CAACoL,WAAD,EAAegB,UAAD,IAAgB,KAAKlK,WAAL,CAAiBJ,OAAjB,CAAyB,CAACsK,UAAU,IAAI,EAAf,EAAmBC,IAAnB,EAAzB,CAA9B;MADJ,CAHe;MAMvB;MACAnE,SAAS,EAAEpB,OAAO,CAACoB;IAPI,CAAzB;;IAUA,IAAIgE,SAAJ,EAAe;MACbtE,WAAW,CAACH,MAAZ,CAAmByE,SAAnB,GAA+BA,SAA/B;IACD;;IACD,IAAIpF,OAAO,CAACwE,KAAZ,EAAmB;MACjB1D,WAAW,CAACH,MAAZ,CAAmB6D,KAAnB,GAA2BxE,OAAO,CAACwE,KAAnC;IACD;;IACD,IAAIxE,OAAO,CAACI,KAAZ,EAAmB;MACjBU,WAAW,CAACH,MAAZ,CAAmBT,IAAnB,GAA0B,KAAKC,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcF,IAAjC,EAAuC,KAAvC,EAA8CF,OAAO,CAACM,QAAtD,CAA1B;MACAQ,WAAW,CAACH,MAAZ,CAAmBJ,KAAnB,GAA2B,KAAKJ,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcI,EAAjC,EAAqC,IAArC,EAA2CR,OAAO,CAACM,QAAnD,CAA3B;IACD;;IACD,OAAOnH,aAAa,CAAC,KAAKkI,iBAAL,CAAuBP,WAAvB,EAAoCzH,IAApC,CAAyCmM,SAAS,EAAlD,CAAD,CAApB;EACD;;EAEDf,wBAAwB,CAACH,WAAD,EAAqBxF,GAArB,EAA+B2G,WAA/B,EAAiDvB,eAAjD,EAAuE;IAC7F,MAAMlE,OAAO,GAAGkE,eAAe,IAAI,EAAnC;IAEA,MAAMpD,WAAgB,GAAG;MACvBC,MAAM,EAAE,KADe;MAEvBlE,GAAG,EAAE,2BAFkB;MAGvB8D,MAAM,EAAE;QACN0E,IAAI,EAAEnM,IAAI,CAACoL,WAAD,EAAegB,UAAD,IAAgB,KAAKlK,WAAL,CAAiBJ,OAAjB,CAAyB,CAACsK,UAAU,IAAI,EAAf,EAAmBC,IAAnB,EAAzB,CAA9B,CADJ;QAENzG,GAAG,EAAE,KAAK1D,WAAL,CAAiBJ,OAAjB,CAAyB,CAAC8D,GAAG,IAAI,EAAR,EAAYyG,IAAZ,EAAzB;MAFC,CAHe;MAOvB;MACAnE,SAAS,EAAEpB,OAAO,CAACoB;IARI,CAAzB;;IAWA,IAAIqE,WAAJ,EAAiB;MACf3E,WAAW,CAACH,MAAZ,CAAmB8E,WAAnB,GAAiCA,WAAjC;IACD;;IACD,IAAIzF,OAAO,CAACwE,KAAZ,EAAmB;MACjB1D,WAAW,CAACH,MAAZ,CAAmB6D,KAAnB,GAA2BxE,OAAO,CAACwE,KAAnC;IACD;;IACD,IAAIxE,OAAO,CAACI,KAAZ,EAAmB;MACjBU,WAAW,CAACH,MAAZ,CAAmBT,IAAnB,GAA0B,KAAKC,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcF,IAAjC,EAAuC,KAAvC,EAA8CF,OAAO,CAACM,QAAtD,CAA1B;MACAQ,WAAW,CAACH,MAAZ,CAAmBJ,KAAnB,GAA2B,KAAKJ,aAAL,CAAmBH,OAAO,CAACI,KAAR,CAAcI,EAAjC,EAAqC,IAArC,EAA2CR,OAAO,CAACM,QAAnD,CAA3B;IACD;;IACD,OAAOnH,aAAa,CAAC,KAAKkI,iBAAL,CAAuBP,WAAvB,EAAoCzH,IAApC,CAAyCmM,SAAS,EAAlD,CAAD,CAApB;EACD;;EAEDE,UAAU,CAACxB,eAAD,EAAuB;IAC/B,MAAMlE,OAAO,GAAGkE,eAAe,IAAI,EAAnC;IAEA,MAAMpD,WAAW,GAAG;MAClBC,MAAM,EAAE,KADU;MAElBlE,GAAG,EAAE,UAFa;MAGlBuE,SAAS,EAAEpB,OAAO,CAACoB;IAHD,CAApB;IAMA,OAAOjI,aAAa,CAClB,KAAKkI,iBAAL,CAAuBP,WAAvB,EAAoCzH,IAApC,CACEJ,GAAG,CAAE8J,OAAD,IAAkB;MACpB,IAAIA,OAAO,CAACzH,IAAZ,EAAkB;QAChB,MAAMqK,MAAM,GAAG,IAAI7L,UAAJ,CAAeiJ,OAAO,CAACzH,IAAvB,CAAf;QACA,OAAOqK,MAAM,CAACC,OAAP,KAAmB7C,OAAO,CAACzH,IAA3B,GAAkC,EAAzC;MACD;;MACD,OAAO,EAAP;IACD,CANE,CADL,EAQE/B,UAAU,CAAC,MAAM;MACf,OAAOH,EAAE,CAAC,EAAD,CAAT;IACD,CAFS,CARZ,CADkB,CAApB;EAcD;;EAEDyM,kBAAkB,CAACC,OAAD,EAAe9F,OAAf,EAA4C;IAC5D,OAAO7F,KAAK,CAAC0L,kBAAN,CAAyBC,OAAzB,EAAkC9F,OAAlC,EAA2C,KAAKrC,QAAhD,CAAP;EACD;;EAEDoI,UAAU,CAACjJ,IAAD,EAAe;IACvB,OAAO3C,KAAK,CAAC4L,UAAN,CAAiBjJ,IAAjB,EAAuB,KAAKa,QAA5B,CAAP;EACD;;EAEDqI,qBAAqB,GAAG;IACtB,OAAO,KAAKC,WAAL,EAAP;EACD;;EAEDA,WAAW,GAAG;IACZ,IAAI,KAAKrI,eAAL,KAAyB,IAA7B,EAAmC;MACjC,OAAO,KAAKA,eAAZ;IACD;;IAED,IAAI,CAACsI,qBAAqB,CAAC,KAAKnJ,eAAN,CAA1B,EAAkD;MAChD,KAAKY,QAAL,GAAgBxD,KAAK,CAAC8L,WAAN,CAAkB,KAAKlJ,eAAvB,CAAhB;MACA,KAAKa,eAAL,GAAuB0F,OAAO,CAAC6C,OAAR,CAAgB,KAAKxI,QAArB,CAAvB;MACA,OAAO,KAAKC,eAAZ;IACD;;IAED,MAAMkD,WAAW,GAAG;MAClBC,MAAM,EAAE,KADU;MAElBlE,GAAG,EAAE,YAFa;MAGlB;MACA;MACAuJ,YAAY,EAAE;IALI,CAApB;IAQA,OAAOjN,aAAa,CAClB,KAAKkI,iBAAL,CAAuBP,WAAvB,EAAoCzH,IAApC,CACEJ,GAAG,CAAE8J,OAAD,IAAkB;MACpB;MACA;MACA;MACA;MACA;MACA,MAAMsD,SAAS,GAAGC,IAAI,CAACzC,KAAL,CAAWd,OAAO,CAACzH,IAAR,CAAaN,OAAb,CAAqB,uBAArB,EAA8C,mBAA9C,CAAX,CAAlB;MACA,KAAK2C,QAAL,GAAgBxD,KAAK,CAACoM,aAAN,CAAoBF,SAApB,CAAhB;MACA,OAAO,KAAK1I,QAAZ;IACD,CATE,CADL,EAWEpE,UAAU,CAAE0J,KAAD,IAAgB;MACzBD,OAAO,CAACC,KAAR,CAAc,mCAAd,EAAmDA,KAAnD;MACA,KAAKtF,QAAL,GAAgBxD,KAAK,CAAC8L,WAAN,CAAkB,KAAKlJ,eAAvB,CAAhB;MACA,OAAO3D,EAAE,CAAC,KAAKuE,QAAN,CAAT;IACD,CAJS,CAXZ,CADkB,CAApB;EAmBD;;EAED6I,cAAc,GAAG;IACf,MAAMpI,KAAK,GAAG;MACZ+C,OAAO,EAAE,CADG;MAEZsF,QAAQ,EAAE;QAAEvG,IAAI,EAAE,QAAR;QAAkBM,EAAE,EAAE;MAAtB,CAFE;MAGZJ,KAAK,EAAE;QACLC,GAAG,EAAE;UAAEH,IAAI,EAAE,QAAR;UAAkBM,EAAE,EAAE;QAAtB;MADA,CAHK;MAMZC,OAAO,EAAE,CAAC;QAAE5E,MAAM,EAAE;MAAV,CAAD,CANG;MAOZkC,aAAa,EAAE;IAPH,CAAd;IAUA,OAAO5E,aAAa,CAAC,KAAKiF,KAAL,CAAWA,KAAX,CAAD,CAAb,CAAiC0E,IAAjC,CAAsC,OAAO;MAAE4D,MAAM,EAAE,SAAV;MAAqBlL,OAAO,EAAE;IAA9B,CAAP,CAAtC,CAAP;EACD;;EAED6F,iBAAiB,CAACrB,OAAD,EAOd;IACD,IAAI,KAAKpD,SAAL,IAAkB,KAAKc,eAA3B,EAA4C;MAC1CsC,OAAO,CAACtC,eAAR,GAA0B,IAA1B;IACD;;IACD,IAAI,KAAKd,SAAT,EAAoB;MAClBoD,OAAO,CAACiB,OAAR,GAAkBjB,OAAO,CAACiB,OAAR,IAAmB,EAArC;MACAjB,OAAO,CAACiB,OAAR,CAAgB0F,aAAhB,GAAgC,KAAK/J,SAArC;IACD;;IAEDoD,OAAO,CAACnD,GAAR,GAAc,KAAKA,GAAL,GAAWmD,OAAO,CAACnD,GAAjC;IACAmD,OAAO,CAAC4G,OAAR,GAAkB;MAAEC,IAAI,EAAE;IAAR,CAAlB;IAEA,OAAOjN,aAAa,GACjBkN,KADI,CACE9G,OADF,EAEJ3G,IAFI,CAGHE,UAAU,CAAE8J,GAAD,IAAc;MACvB,OAAO/J,UAAU,CAACgB,WAAW,CAAC+I,GAAD,CAAZ,CAAjB;IACD,CAFS,CAHP,CAAP;EAOD;;EAEDzC,mBAAmB,CAACZ,OAAD,EAAea,UAAf,EAAkD;IACnE,MAAMkG,eAAe,GAAG,CAAC,MAAD,EAAS,OAAT,EAAkB,SAAlB,EAA6B,QAA7B,EAAuC,eAAvC,EAAwD,cAAxD,CAAxB;IACA,MAAMC,YAAY,GAAG,EAArB;IAAA,MACEvG,OAAY,GAAG,EADjB;IAEA,IAAI5E,MAAJ,EAAYoL,WAAZ,EAAyBxL,CAAzB;IACA,MAAMyL,KAAK,GAAG,YAAd;IACA,MAAMC,sBAAsB,GAAG,YAA/B;IACA,IAAIC,UAAU,GAAG,KAAjB;IAEApH,OAAO,CAAC,QAAD,CAAP,GAAoB,MAApB;;IAEA,SAASqH,iBAAT,CAA2B7F,KAA3B,EAAuC;MACrC,OAAOA,KAAK,CAACxG,OAAN,CAAc,GAAd,EAAmB,KAAnB,EAA0BA,OAA1B,CAAkC,GAAlC,EAAuC,KAAvC,CAAP;IACD;;IAED,KAAKS,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGuE,OAAO,CAACS,OAAR,CAAgB/E,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;MAC3CI,MAAM,GAAGmE,OAAO,CAACS,OAAR,CAAgBhF,CAAhB,CAAT;;MACA,IAAI,CAACI,MAAM,CAACA,MAAZ,EAAoB;QAClB;MACD;;MAED,IAAI,CAACA,MAAM,CAACiE,KAAZ,EAAmB;QACjBjE,MAAM,CAACiE,KAAP,GAAe,KAAKjC,iBAAL,CAAuBpC,CAAvB,CAAf;MACD;;MAEDwL,WAAW,GAAG,KAAK7L,WAAL,CAAiBJ,OAAjB,CAAyBa,MAAM,CAACA,MAAhC,EAAwCgF,UAAxC,CAAd;MACAoG,WAAW,GAAGA,WAAW,CAACjM,OAAZ,CAAoBmM,sBAApB,EAA4CE,iBAA5C,CAAd;MACA5G,OAAO,CAAC5E,MAAM,CAACiE,KAAR,CAAP,GAAwBmH,WAAxB;IACD;;IAED,SAASK,yBAAT,CAAmC9F,KAAnC,EAA+C+F,EAA/C,EAAoE;MAClE,OAAO9G,OAAO,CAAC8G,EAAD,CAAP,IAAe/F,KAAtB;IACD;;IAED,KAAK/F,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGuE,OAAO,CAACS,OAAR,CAAgB/E,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;MAC3CI,MAAM,GAAGmE,OAAO,CAACS,OAAR,CAAgBhF,CAAhB,CAAT;;MACA,IAAI,CAACI,MAAM,CAACA,MAAZ,EAAoB;QAClB;MACD;;MAEDoL,WAAW,GAAGxG,OAAO,CAAC5E,MAAM,CAACiE,KAAR,CAArB;MACAmH,WAAW,GAAGA,WAAW,CAACjM,OAAZ,CAAoBkM,KAApB,EAA2BI,yBAA3B,CAAd;MACA7G,OAAO,CAAC5E,MAAM,CAACiE,KAAR,CAAP,GAAwBmH,WAAxB;;MAEA,IAAI,CAACpL,MAAM,CAAC2L,IAAZ,EAAkB;QAChBJ,UAAU,GAAG,IAAb;QACAJ,YAAY,CAACrK,IAAb,CAAkB,YAAY8K,kBAAkB,CAACR,WAAD,CAAhD;MACD;IACF;;IAEDpO,IAAI,CAACmH,OAAD,EAAU,CAACf,KAAD,EAAQF,GAAR,KAAgB;MAC5B,IAAIjG,OAAO,CAACiO,eAAD,EAAkBhI,GAAlB,CAAP,KAAkC,CAAC,CAAvC,EAA0C;QACxC;MACD;;MACD,IAAIE,KAAJ,EAAW;QACT+H,YAAY,CAACrK,IAAb,CAAkBoC,GAAG,GAAG,GAAN,GAAY0I,kBAAkB,CAACxI,KAAD,CAAhD;MACD;IACF,CAPG,CAAJ;;IASA,IAAI,CAACmI,UAAL,EAAiB;MACf,OAAO,EAAP;IACD;;IAED,OAAOJ,YAAP;EACD;;AAtzBH;;AAyzBA,SAASxJ,YAAT,CAAsBkK,OAAtB,EAAgD;EAC9C,OAAO7N,eAAe,CAAC6N,OAAD,EAAU,KAAV,CAAtB;AACD;;AAED,SAASxB,qBAAT,CAA+BwB,OAA/B,EAAyD;EACvD,OAAO7N,eAAe,CAAC6N,OAAD,EAAU,KAAV,CAAtB;AACD;;AAED,SAASlC,SAAT,GAAqE;EACnE,OAAOnM,IAAI,CACTJ,GAAG,CAAE8J,OAAD,IAAkB;IACpB,IAAIA,OAAO,CAACzH,IAAZ,EAAkB;MAChB,OAAOpC,IAAI,CAAC6J,OAAO,CAACzH,IAAT,EAAgB2D,KAAD,IAAW;QACnC,OAAO;UAAEnE,IAAI,EAAEmE;QAAR,CAAP;MACD,CAFU,CAAX;IAGD,CAJD,MAIO;MACL,OAAO,EAAP;IACD;EACF,CARE,CADM,CAAX;AAWD"},"metadata":{},"sourceType":"module"}