{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { uniq } from 'lodash';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport { CompletionItemProvider } from '../../monarch/CompletionItemProvider';\nimport { TRIGGER_SUGGEST } from '../../monarch/commands';\nimport { SuggestionKind, CompletionItemPriority, StatementPosition } from '../../monarch/types';\nimport { BY, FROM, GROUP, LIMIT, ORDER, SCHEMA, SELECT, ASC, DESC, WHERE, COMPARISON_OPERATORS, LOGICAL_OPERATORS, STATISTICS } from '../language';\nimport { getStatementPosition } from './statementPosition';\nimport { getSuggestionKinds } from './suggestionKind';\nimport { getMetricNameToken, getNamespaceToken } from './tokenUtils';\nimport { SQLTokenTypes } from './types';\nexport class SQLCompletionItemProvider extends CompletionItemProvider {\n  constructor(datasource, templateSrv = getTemplateSrv()) {\n    super(datasource, templateSrv);\n\n    _defineProperty(this, \"region\", void 0);\n\n    this.region = datasource.getActualRegion();\n    this.getStatementPosition = getStatementPosition;\n    this.getSuggestionKinds = getSuggestionKinds;\n    this.tokenTypes = SQLTokenTypes;\n  }\n\n  setRegion(region) {\n    this.region = region;\n  }\n\n  async getSuggestions(monaco, currentToken, suggestionKinds, statementPosition, position) {\n    let suggestions = [];\n    const invalidRangeToken = (currentToken === null || currentToken === void 0 ? void 0 : currentToken.isWhiteSpace()) || (currentToken === null || currentToken === void 0 ? void 0 : currentToken.isParenthesis());\n    const range = invalidRangeToken || !(currentToken !== null && currentToken !== void 0 && currentToken.range) ? monaco.Range.fromPositions(position) : currentToken === null || currentToken === void 0 ? void 0 : currentToken.range;\n\n    const toCompletionItem = (value, rest = {}) => {\n      const item = Object.assign({\n        label: value,\n        insertText: value,\n        kind: monaco.languages.CompletionItemKind.Field,\n        range,\n        sortText: CompletionItemPriority.Medium\n      }, rest);\n      return item;\n    };\n\n    function addSuggestion(value, rest = {}) {\n      suggestions = [...suggestions, toCompletionItem(value, rest)];\n    }\n\n    for (const suggestion of suggestionKinds) {\n      switch (suggestion) {\n        case SuggestionKind.SelectKeyword:\n          addSuggestion(SELECT, {\n            insertText: `${SELECT} $0`,\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            kind: monaco.languages.CompletionItemKind.Keyword,\n            command: TRIGGER_SUGGEST\n          });\n          break;\n\n        case SuggestionKind.FunctionsWithArguments:\n          STATISTICS.map(s => addSuggestion(s, {\n            insertText: `${s}($0)`,\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            command: TRIGGER_SUGGEST,\n            kind: monaco.languages.CompletionItemKind.Function\n          }));\n          break;\n\n        case SuggestionKind.FunctionsWithoutArguments:\n          STATISTICS.map(s => addSuggestion(s, {\n            insertText: `${s}() `,\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            command: TRIGGER_SUGGEST,\n            kind: monaco.languages.CompletionItemKind.Function\n          }));\n          break;\n\n        case SuggestionKind.Metrics:\n          {\n            const namespaceToken = getNamespaceToken(currentToken);\n\n            if (namespaceToken !== null && namespaceToken !== void 0 && namespaceToken.value) {\n              // if a namespace is specified, only suggest metrics for the namespace\n              const metrics = await this.datasource.getMetrics(this.templateSrv.replace(namespaceToken === null || namespaceToken === void 0 ? void 0 : namespaceToken.value.replace(/\\\"/g, '')), this.templateSrv.replace(this.region));\n              metrics.map(m => addSuggestion(m.value));\n            } else {\n              // If no namespace is specified in the query, just list all metrics\n              const metrics = await this.datasource.getAllMetrics(this.templateSrv.replace(this.region));\n              uniq(metrics.map(m => m.metricName)).map(m => addSuggestion(m, {\n                insertText: m\n              }));\n            }\n          }\n          break;\n\n        case SuggestionKind.FromKeyword:\n          addSuggestion(FROM, {\n            insertText: `${FROM} `,\n            command: TRIGGER_SUGGEST\n          });\n          break;\n\n        case SuggestionKind.SchemaKeyword:\n          addSuggestion(SCHEMA, {\n            sortText: CompletionItemPriority.High,\n            insertText: `${SCHEMA}($0)`,\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            command: TRIGGER_SUGGEST,\n            kind: monaco.languages.CompletionItemKind.Function\n          });\n          break;\n\n        case SuggestionKind.Namespaces:\n          const metricNameToken = getMetricNameToken(currentToken);\n          let namespaces = [];\n\n          if (metricNameToken !== null && metricNameToken !== void 0 && metricNameToken.value) {\n            // if a metric is specified, only suggest namespaces that actually have that metric\n            const metrics = await this.datasource.getAllMetrics(this.region);\n            const metricName = this.templateSrv.replace(metricNameToken.value);\n            namespaces = metrics.filter(m => m.metricName === metricName).map(m => m.namespace);\n          } else {\n            // if no metric is specified, just suggest all namespaces\n            const ns = await this.datasource.getNamespaces();\n            namespaces = ns.map(n => n.value);\n          }\n\n          namespaces.map(n => addSuggestion(`\"${n}\"`, {\n            insertText: `\"${n}\"`\n          }));\n          break;\n\n        case SuggestionKind.LabelKeys:\n          {\n            const metricNameToken = getMetricNameToken(currentToken);\n            const namespaceToken = getNamespaceToken(currentToken);\n\n            if (namespaceToken !== null && namespaceToken !== void 0 && namespaceToken.value) {\n              var _metricNameToken$valu;\n\n              let dimensionFilter = {};\n              let labelKeyTokens;\n\n              if (statementPosition === StatementPosition.SchemaFuncExtraArgument) {\n                labelKeyTokens = namespaceToken === null || namespaceToken === void 0 ? void 0 : namespaceToken.getNextUntil(this.tokenTypes.Parenthesis, [this.tokenTypes.Delimiter, this.tokenTypes.Whitespace]);\n              } else if (statementPosition === StatementPosition.AfterGroupByKeywords) {\n                labelKeyTokens = currentToken === null || currentToken === void 0 ? void 0 : currentToken.getPreviousUntil(this.tokenTypes.Keyword, [this.tokenTypes.Delimiter, this.tokenTypes.Whitespace]);\n              }\n\n              dimensionFilter = (labelKeyTokens || []).reduce((acc, curr) => {\n                return Object.assign({}, acc, {\n                  [curr.value]: null\n                });\n              }, {});\n              const keys = await this.datasource.getDimensionKeys(this.templateSrv.replace(namespaceToken.value.replace(/\\\"/g, '')), this.templateSrv.replace(this.region), dimensionFilter, (_metricNameToken$valu = metricNameToken === null || metricNameToken === void 0 ? void 0 : metricNameToken.value) !== null && _metricNameToken$valu !== void 0 ? _metricNameToken$valu : '');\n              keys.map(m => {\n                const key = /[\\s\\.-]/.test(m.value) ? `\"${m.value}\"` : m.value;\n                addSuggestion(key);\n              });\n            }\n          }\n          break;\n\n        case SuggestionKind.LabelValues:\n          {\n            var _currentToken$getPrev;\n\n            const namespaceToken = getNamespaceToken(currentToken);\n            const metricNameToken = getMetricNameToken(currentToken);\n            const labelKey = currentToken === null || currentToken === void 0 ? void 0 : (_currentToken$getPrev = currentToken.getPreviousNonWhiteSpaceToken()) === null || _currentToken$getPrev === void 0 ? void 0 : _currentToken$getPrev.getPreviousNonWhiteSpaceToken();\n\n            if (namespaceToken !== null && namespaceToken !== void 0 && namespaceToken.value && labelKey !== null && labelKey !== void 0 && labelKey.value && metricNameToken !== null && metricNameToken !== void 0 && metricNameToken.value) {\n              const values = await this.datasource.getDimensionValues(this.templateSrv.replace(this.region), this.templateSrv.replace(namespaceToken.value.replace(/\\\"/g, '')), this.templateSrv.replace(metricNameToken.value), this.templateSrv.replace(labelKey.value), {});\n              values.map(o => addSuggestion(`'${o.value}'`, {\n                insertText: `'${o.value}' `,\n                command: TRIGGER_SUGGEST\n              }));\n            }\n          }\n          break;\n\n        case SuggestionKind.LogicalOperators:\n          LOGICAL_OPERATORS.map(o => addSuggestion(`${o}`, {\n            insertText: `${o} `,\n            command: TRIGGER_SUGGEST,\n            sortText: CompletionItemPriority.MediumHigh\n          }));\n          break;\n\n        case SuggestionKind.WhereKeyword:\n          addSuggestion(`${WHERE}`, {\n            insertText: `${WHERE} `,\n            command: TRIGGER_SUGGEST,\n            sortText: CompletionItemPriority.High\n          });\n          break;\n\n        case SuggestionKind.ComparisonOperators:\n          COMPARISON_OPERATORS.map(o => addSuggestion(`${o}`, {\n            insertText: `${o} `,\n            command: TRIGGER_SUGGEST\n          }));\n          break;\n\n        case SuggestionKind.GroupByKeywords:\n          addSuggestion(`${GROUP} ${BY}`, {\n            insertText: `${GROUP} ${BY} `,\n            command: TRIGGER_SUGGEST,\n            sortText: CompletionItemPriority.MediumHigh\n          });\n          break;\n\n        case SuggestionKind.OrderByKeywords:\n          addSuggestion(`${ORDER} ${BY}`, {\n            insertText: `${ORDER} ${BY} `,\n            command: TRIGGER_SUGGEST,\n            sortText: CompletionItemPriority.Medium\n          });\n          break;\n\n        case SuggestionKind.LimitKeyword:\n          addSuggestion(LIMIT, {\n            insertText: `${LIMIT} `,\n            sortText: CompletionItemPriority.MediumLow\n          });\n          break;\n\n        case SuggestionKind.SortOrderDirectionKeyword:\n          [ASC, DESC].map(s => addSuggestion(s, {\n            insertText: `${s} `,\n            command: TRIGGER_SUGGEST\n          }));\n          break;\n      }\n    } // always suggest template variables\n\n\n    this.templateVariables.map(v => {\n      addSuggestion(v, {\n        range,\n        label: v,\n        insertText: v,\n        kind: monaco.languages.CompletionItemKind.Variable,\n        sortText: CompletionItemPriority.Low\n      });\n    });\n    return suggestions;\n  }\n\n}","map":{"version":3,"names":["uniq","getTemplateSrv","CompletionItemProvider","TRIGGER_SUGGEST","SuggestionKind","CompletionItemPriority","StatementPosition","BY","FROM","GROUP","LIMIT","ORDER","SCHEMA","SELECT","ASC","DESC","WHERE","COMPARISON_OPERATORS","LOGICAL_OPERATORS","STATISTICS","getStatementPosition","getSuggestionKinds","getMetricNameToken","getNamespaceToken","SQLTokenTypes","SQLCompletionItemProvider","constructor","datasource","templateSrv","region","getActualRegion","tokenTypes","setRegion","getSuggestions","monaco","currentToken","suggestionKinds","statementPosition","position","suggestions","invalidRangeToken","isWhiteSpace","isParenthesis","range","Range","fromPositions","toCompletionItem","value","rest","item","label","insertText","kind","languages","CompletionItemKind","Field","sortText","Medium","addSuggestion","suggestion","SelectKeyword","insertTextRules","CompletionItemInsertTextRule","InsertAsSnippet","Keyword","command","FunctionsWithArguments","map","s","Function","FunctionsWithoutArguments","Metrics","namespaceToken","metrics","getMetrics","replace","m","getAllMetrics","metricName","FromKeyword","SchemaKeyword","High","Namespaces","metricNameToken","namespaces","filter","namespace","ns","getNamespaces","n","LabelKeys","dimensionFilter","labelKeyTokens","SchemaFuncExtraArgument","getNextUntil","Parenthesis","Delimiter","Whitespace","AfterGroupByKeywords","getPreviousUntil","reduce","acc","curr","keys","getDimensionKeys","key","test","LabelValues","labelKey","getPreviousNonWhiteSpaceToken","values","getDimensionValues","o","LogicalOperators","MediumHigh","WhereKeyword","ComparisonOperators","GroupByKeywords","OrderByKeywords","LimitKeyword","MediumLow","SortOrderDirectionKeyword","templateVariables","v","Variable","Low"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/cloudwatch-sql/completion/CompletionItemProvider.ts"],"sourcesContent":["import { uniq } from 'lodash';\n\nimport { getTemplateSrv, TemplateSrv } from '@grafana/runtime';\nimport type { Monaco, monacoTypes } from '@grafana/ui';\n\nimport { CloudWatchDatasource } from '../../datasource';\nimport { CompletionItemProvider } from '../../monarch/CompletionItemProvider';\nimport { LinkedToken } from '../../monarch/LinkedToken';\nimport { TRIGGER_SUGGEST } from '../../monarch/commands';\nimport { SuggestionKind, CompletionItemPriority, StatementPosition } from '../../monarch/types';\nimport {\n  BY,\n  FROM,\n  GROUP,\n  LIMIT,\n  ORDER,\n  SCHEMA,\n  SELECT,\n  ASC,\n  DESC,\n  WHERE,\n  COMPARISON_OPERATORS,\n  LOGICAL_OPERATORS,\n  STATISTICS,\n} from '../language';\n\nimport { getStatementPosition } from './statementPosition';\nimport { getSuggestionKinds } from './suggestionKind';\nimport { getMetricNameToken, getNamespaceToken } from './tokenUtils';\nimport { SQLTokenTypes } from './types';\n\ntype CompletionItem = monacoTypes.languages.CompletionItem;\n\nexport class SQLCompletionItemProvider extends CompletionItemProvider {\n  region: string;\n\n  constructor(datasource: CloudWatchDatasource, templateSrv: TemplateSrv = getTemplateSrv()) {\n    super(datasource, templateSrv);\n    this.region = datasource.getActualRegion();\n    this.getStatementPosition = getStatementPosition;\n    this.getSuggestionKinds = getSuggestionKinds;\n    this.tokenTypes = SQLTokenTypes;\n  }\n\n  setRegion(region: string) {\n    this.region = region;\n  }\n\n  async getSuggestions(\n    monaco: Monaco,\n    currentToken: LinkedToken | null,\n    suggestionKinds: SuggestionKind[],\n    statementPosition: StatementPosition,\n    position: monacoTypes.IPosition\n  ): Promise<CompletionItem[]> {\n    let suggestions: CompletionItem[] = [];\n    const invalidRangeToken = currentToken?.isWhiteSpace() || currentToken?.isParenthesis();\n    const range =\n      invalidRangeToken || !currentToken?.range ? monaco.Range.fromPositions(position) : currentToken?.range;\n\n    const toCompletionItem = (value: string, rest: Partial<CompletionItem> = {}) => {\n      const item: CompletionItem = {\n        label: value,\n        insertText: value,\n        kind: monaco.languages.CompletionItemKind.Field,\n        range,\n        sortText: CompletionItemPriority.Medium,\n        ...rest,\n      };\n      return item;\n    };\n\n    function addSuggestion(value: string, rest: Partial<CompletionItem> = {}) {\n      suggestions = [...suggestions, toCompletionItem(value, rest)];\n    }\n\n    for (const suggestion of suggestionKinds) {\n      switch (suggestion) {\n        case SuggestionKind.SelectKeyword:\n          addSuggestion(SELECT, {\n            insertText: `${SELECT} $0`,\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            kind: monaco.languages.CompletionItemKind.Keyword,\n            command: TRIGGER_SUGGEST,\n          });\n          break;\n\n        case SuggestionKind.FunctionsWithArguments:\n          STATISTICS.map((s) =>\n            addSuggestion(s, {\n              insertText: `${s}($0)`,\n              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n              command: TRIGGER_SUGGEST,\n              kind: monaco.languages.CompletionItemKind.Function,\n            })\n          );\n          break;\n\n        case SuggestionKind.FunctionsWithoutArguments:\n          STATISTICS.map((s) =>\n            addSuggestion(s, {\n              insertText: `${s}() `,\n              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n              command: TRIGGER_SUGGEST,\n              kind: monaco.languages.CompletionItemKind.Function,\n            })\n          );\n          break;\n\n        case SuggestionKind.Metrics:\n          {\n            const namespaceToken = getNamespaceToken(currentToken);\n            if (namespaceToken?.value) {\n              // if a namespace is specified, only suggest metrics for the namespace\n              const metrics = await this.datasource.getMetrics(\n                this.templateSrv.replace(namespaceToken?.value.replace(/\\\"/g, '')),\n                this.templateSrv.replace(this.region)\n              );\n              metrics.map((m) => addSuggestion(m.value));\n            } else {\n              // If no namespace is specified in the query, just list all metrics\n              const metrics = await this.datasource.getAllMetrics(this.templateSrv.replace(this.region));\n              uniq(metrics.map((m) => m.metricName)).map((m) => addSuggestion(m, { insertText: m }));\n            }\n          }\n          break;\n\n        case SuggestionKind.FromKeyword:\n          addSuggestion(FROM, {\n            insertText: `${FROM} `,\n            command: TRIGGER_SUGGEST,\n          });\n          break;\n\n        case SuggestionKind.SchemaKeyword:\n          addSuggestion(SCHEMA, {\n            sortText: CompletionItemPriority.High,\n            insertText: `${SCHEMA}($0)`,\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            command: TRIGGER_SUGGEST,\n            kind: monaco.languages.CompletionItemKind.Function,\n          });\n          break;\n\n        case SuggestionKind.Namespaces:\n          const metricNameToken = getMetricNameToken(currentToken);\n          let namespaces = [];\n          if (metricNameToken?.value) {\n            // if a metric is specified, only suggest namespaces that actually have that metric\n            const metrics = await this.datasource.getAllMetrics(this.region);\n            const metricName = this.templateSrv.replace(metricNameToken.value);\n            namespaces = metrics.filter((m) => m.metricName === metricName).map((m) => m.namespace);\n          } else {\n            // if no metric is specified, just suggest all namespaces\n            const ns = await this.datasource.getNamespaces();\n            namespaces = ns.map((n) => n.value);\n          }\n          namespaces.map((n) => addSuggestion(`\"${n}\"`, { insertText: `\"${n}\"` }));\n          break;\n\n        case SuggestionKind.LabelKeys:\n          {\n            const metricNameToken = getMetricNameToken(currentToken);\n            const namespaceToken = getNamespaceToken(currentToken);\n            if (namespaceToken?.value) {\n              let dimensionFilter = {};\n              let labelKeyTokens;\n              if (statementPosition === StatementPosition.SchemaFuncExtraArgument) {\n                labelKeyTokens = namespaceToken?.getNextUntil(this.tokenTypes.Parenthesis, [\n                  this.tokenTypes.Delimiter,\n                  this.tokenTypes.Whitespace,\n                ]);\n              } else if (statementPosition === StatementPosition.AfterGroupByKeywords) {\n                labelKeyTokens = currentToken?.getPreviousUntil(this.tokenTypes.Keyword, [\n                  this.tokenTypes.Delimiter,\n                  this.tokenTypes.Whitespace,\n                ]);\n              }\n              dimensionFilter = (labelKeyTokens || []).reduce((acc, curr) => {\n                return { ...acc, [curr.value]: null };\n              }, {});\n              const keys = await this.datasource.getDimensionKeys(\n                this.templateSrv.replace(namespaceToken.value.replace(/\\\"/g, '')),\n                this.templateSrv.replace(this.region),\n                dimensionFilter,\n                metricNameToken?.value ?? ''\n              );\n              keys.map((m) => {\n                const key = /[\\s\\.-]/.test(m.value) ? `\"${m.value}\"` : m.value;\n                addSuggestion(key);\n              });\n            }\n          }\n          break;\n\n        case SuggestionKind.LabelValues:\n          {\n            const namespaceToken = getNamespaceToken(currentToken);\n            const metricNameToken = getMetricNameToken(currentToken);\n            const labelKey = currentToken?.getPreviousNonWhiteSpaceToken()?.getPreviousNonWhiteSpaceToken();\n            if (namespaceToken?.value && labelKey?.value && metricNameToken?.value) {\n              const values = await this.datasource.getDimensionValues(\n                this.templateSrv.replace(this.region),\n                this.templateSrv.replace(namespaceToken.value.replace(/\\\"/g, '')),\n                this.templateSrv.replace(metricNameToken.value),\n                this.templateSrv.replace(labelKey.value),\n                {}\n              );\n              values.map((o) =>\n                addSuggestion(`'${o.value}'`, { insertText: `'${o.value}' `, command: TRIGGER_SUGGEST })\n              );\n            }\n          }\n          break;\n\n        case SuggestionKind.LogicalOperators:\n          LOGICAL_OPERATORS.map((o) =>\n            addSuggestion(`${o}`, {\n              insertText: `${o} `,\n              command: TRIGGER_SUGGEST,\n              sortText: CompletionItemPriority.MediumHigh,\n            })\n          );\n          break;\n\n        case SuggestionKind.WhereKeyword:\n          addSuggestion(`${WHERE}`, {\n            insertText: `${WHERE} `,\n            command: TRIGGER_SUGGEST,\n            sortText: CompletionItemPriority.High,\n          });\n          break;\n\n        case SuggestionKind.ComparisonOperators:\n          COMPARISON_OPERATORS.map((o) => addSuggestion(`${o}`, { insertText: `${o} `, command: TRIGGER_SUGGEST }));\n          break;\n\n        case SuggestionKind.GroupByKeywords:\n          addSuggestion(`${GROUP} ${BY}`, {\n            insertText: `${GROUP} ${BY} `,\n            command: TRIGGER_SUGGEST,\n            sortText: CompletionItemPriority.MediumHigh,\n          });\n          break;\n\n        case SuggestionKind.OrderByKeywords:\n          addSuggestion(`${ORDER} ${BY}`, {\n            insertText: `${ORDER} ${BY} `,\n            command: TRIGGER_SUGGEST,\n            sortText: CompletionItemPriority.Medium,\n          });\n          break;\n\n        case SuggestionKind.LimitKeyword:\n          addSuggestion(LIMIT, { insertText: `${LIMIT} `, sortText: CompletionItemPriority.MediumLow });\n          break;\n\n        case SuggestionKind.SortOrderDirectionKeyword:\n          [ASC, DESC].map((s) =>\n            addSuggestion(s, {\n              insertText: `${s} `,\n              command: TRIGGER_SUGGEST,\n            })\n          );\n          break;\n      }\n    }\n\n    // always suggest template variables\n    this.templateVariables.map((v) => {\n      addSuggestion(v, {\n        range,\n        label: v,\n        insertText: v,\n        kind: monaco.languages.CompletionItemKind.Variable,\n        sortText: CompletionItemPriority.Low,\n      });\n    });\n\n    return suggestions;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}