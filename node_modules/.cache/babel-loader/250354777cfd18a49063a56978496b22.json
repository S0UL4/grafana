{"ast":null,"code":"import { useMemo, useRef } from 'react';\nimport { getAllRulesSources, getRulesSourceByName, isCloudRulesSource, isGrafanaRulesSource } from '../utils/datasource';\nimport { isAlertingRule, isAlertingRulerRule, isRecordingRulerRule } from '../utils/rules';\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n// this little monster combines prometheus rules and ruler rules to produce a unified data structure\n// can limit to a single rules source\nexport function useCombinedRuleNamespaces(rulesSourceName) {\n  const promRulesResponses = useUnifiedAlertingSelector(state => state.promRules);\n  const rulerRulesResponses = useUnifiedAlertingSelector(state => state.rulerRules); // cache results per rules source, so we only recalculate those for which results have actually changed\n\n  const cache = useRef({});\n  const rulesSources = useMemo(() => {\n    if (rulesSourceName) {\n      const rulesSource = getRulesSourceByName(rulesSourceName);\n\n      if (!rulesSource) {\n        throw new Error(`Unknown rules source: ${rulesSourceName}`);\n      }\n\n      return [rulesSource];\n    }\n\n    return getAllRulesSources();\n  }, [rulesSourceName]);\n  return useMemo(() => rulesSources.map(rulesSource => {\n    var _promRulesResponses$r, _rulerRulesResponses$;\n\n    const rulesSourceName = isCloudRulesSource(rulesSource) ? rulesSource.name : rulesSource;\n    const promRules = (_promRulesResponses$r = promRulesResponses[rulesSourceName]) === null || _promRulesResponses$r === void 0 ? void 0 : _promRulesResponses$r.result;\n    const rulerRules = (_rulerRulesResponses$ = rulerRulesResponses[rulesSourceName]) === null || _rulerRulesResponses$ === void 0 ? void 0 : _rulerRulesResponses$.result;\n    const cached = cache.current[rulesSourceName];\n\n    if (cached && cached.promRules === promRules && cached.rulerRules === rulerRules) {\n      return cached.result;\n    }\n\n    const namespaces = {}; // first get all the ruler rules in\n\n    Object.entries(rulerRules || {}).forEach(([namespaceName, groups]) => {\n      const namespace = {\n        rulesSource,\n        name: namespaceName,\n        groups: []\n      };\n      namespaces[namespaceName] = namespace;\n      addRulerGroupsToCombinedNamespace(namespace, groups);\n    }); // then correlate with prometheus rules\n\n    promRules === null || promRules === void 0 ? void 0 : promRules.forEach(({\n      name: namespaceName,\n      groups\n    }) => {\n      const ns = namespaces[namespaceName] = namespaces[namespaceName] || {\n        rulesSource,\n        name: namespaceName,\n        groups: []\n      };\n      addPromGroupsToCombinedNamespace(ns, groups);\n    });\n    const result = Object.values(namespaces);\n    cache.current[rulesSourceName] = {\n      promRules,\n      rulerRules,\n      result\n    };\n    return result;\n  }).flat(), [promRulesResponses, rulerRulesResponses, rulesSources]);\n} // merge all groups in case of grafana managed, essentially treating namespaces (folders) as groups\n\nexport function flattenGrafanaManagedRules(namespaces) {\n  return namespaces.map(namespace => {\n    const newNamespace = Object.assign({}, namespace, {\n      groups: []\n    }); // add default group with ungrouped rules\n\n    newNamespace.groups.push({\n      name: 'default',\n      rules: sortRulesByName(namespace.groups.flatMap(group => group.rules))\n    });\n    return newNamespace;\n  });\n}\nexport function sortRulesByName(rules) {\n  return rules.sort((a, b) => a.name.localeCompare(b.name));\n}\n\nfunction addRulerGroupsToCombinedNamespace(namespace, groups) {\n  namespace.groups = groups.map(group => {\n    const combinedGroup = {\n      name: group.name,\n      interval: group.interval,\n      source_tenants: group.source_tenants,\n      rules: []\n    };\n    combinedGroup.rules = group.rules.map(rule => rulerRuleToCombinedRule(rule, namespace, combinedGroup));\n    return combinedGroup;\n  });\n}\n\nfunction addPromGroupsToCombinedNamespace(namespace, groups) {\n  groups.forEach(group => {\n    var _group$rules;\n\n    let combinedGroup = namespace.groups.find(g => g.name === group.name);\n\n    if (!combinedGroup) {\n      combinedGroup = {\n        name: group.name,\n        rules: []\n      };\n      namespace.groups.push(combinedGroup);\n    }\n\n    ((_group$rules = group.rules) !== null && _group$rules !== void 0 ? _group$rules : []).forEach(rule => {\n      const existingRule = getExistingRuleInGroup(rule, combinedGroup, namespace.rulesSource);\n\n      if (existingRule) {\n        existingRule.promRule = rule;\n      } else {\n        combinedGroup.rules.push(promRuleToCombinedRule(rule, namespace, combinedGroup));\n      }\n    });\n  });\n}\n\nfunction promRuleToCombinedRule(rule, namespace, group) {\n  return {\n    name: rule.name,\n    query: rule.query,\n    labels: rule.labels || {},\n    annotations: isAlertingRule(rule) ? rule.annotations || {} : {},\n    promRule: rule,\n    namespace: namespace,\n    group\n  };\n}\n\nfunction rulerRuleToCombinedRule(rule, namespace, group) {\n  return isAlertingRulerRule(rule) ? {\n    name: rule.alert,\n    query: rule.expr,\n    labels: rule.labels || {},\n    annotations: rule.annotations || {},\n    rulerRule: rule,\n    namespace,\n    group\n  } : isRecordingRulerRule(rule) ? {\n    name: rule.record,\n    query: rule.expr,\n    labels: rule.labels || {},\n    annotations: {},\n    rulerRule: rule,\n    namespace,\n    group\n  } : {\n    name: rule.grafana_alert.title,\n    query: '',\n    labels: rule.labels || {},\n    annotations: rule.annotations || {},\n    rulerRule: rule,\n    namespace,\n    group\n  };\n} // find existing rule in group that matches the given prom rule\n\n\nfunction getExistingRuleInGroup(rule, group, rulesSource) {\n  var _rules$find;\n\n  if (isGrafanaRulesSource(rulesSource)) {\n    // assume grafana groups have only the one rule. check name anyway because paranoid\n    return group.rules.find(existingRule => existingRule.name === rule.name);\n  }\n\n  return (// try finding a rule that matches name, labels, annotations and query\n    (_rules$find = group.rules.find(existingRule => !existingRule.promRule && isCombinedRuleEqualToPromRule(existingRule, rule, true))) !== null && _rules$find !== void 0 ? _rules$find : // if that fails, try finding a rule that only matches name, labels and annotations.\n    // loki & prom can sometimes modify the query so it doesnt match, eg `2 > 1` becomes `1`\n    group.rules.find(existingRule => !existingRule.promRule && isCombinedRuleEqualToPromRule(existingRule, rule, false))\n  );\n}\n\nfunction isCombinedRuleEqualToPromRule(combinedRule, rule, checkQuery = true) {\n  if (combinedRule.name === rule.name) {\n    return JSON.stringify([checkQuery ? hashQuery(combinedRule.query) : '', combinedRule.labels, combinedRule.annotations]) === JSON.stringify([checkQuery ? hashQuery(rule.query) : '', rule.labels || {}, isAlertingRule(rule) ? rule.annotations || {} : {}]);\n  }\n\n  return false;\n} // there can be slight differences in how prom & ruler render a query, this will hash them accounting for the differences\n\n\nfunction hashQuery(query) {\n  // one of them might be wrapped in parens\n  if (query.length > 1 && query[0] === '(' && query[query.length - 1] === ')') {\n    query = query.slice(1, -1);\n  } // whitespace could be added or removed\n\n\n  query = query.replace(/\\s|\\n/g, ''); // labels matchers can be reordered, so sort the enitre string, esentially comparing just the character counts\n\n  return query.split('').sort().join('');\n}","map":{"version":3,"names":["useMemo","useRef","getAllRulesSources","getRulesSourceByName","isCloudRulesSource","isGrafanaRulesSource","isAlertingRule","isAlertingRulerRule","isRecordingRulerRule","useUnifiedAlertingSelector","useCombinedRuleNamespaces","rulesSourceName","promRulesResponses","state","promRules","rulerRulesResponses","rulerRules","cache","rulesSources","rulesSource","Error","map","name","result","cached","current","namespaces","Object","entries","forEach","namespaceName","groups","namespace","addRulerGroupsToCombinedNamespace","ns","addPromGroupsToCombinedNamespace","values","flat","flattenGrafanaManagedRules","newNamespace","push","rules","sortRulesByName","flatMap","group","sort","a","b","localeCompare","combinedGroup","interval","source_tenants","rule","rulerRuleToCombinedRule","find","g","existingRule","getExistingRuleInGroup","promRule","promRuleToCombinedRule","query","labels","annotations","alert","expr","rulerRule","record","grafana_alert","title","isCombinedRuleEqualToPromRule","combinedRule","checkQuery","JSON","stringify","hashQuery","length","slice","replace","split","join"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/hooks/useCombinedRuleNamespaces.ts"],"sourcesContent":["import { useMemo, useRef } from 'react';\n\nimport {\n  CombinedRule,\n  CombinedRuleGroup,\n  CombinedRuleNamespace,\n  Rule,\n  RuleGroup,\n  RuleNamespace,\n  RulesSource,\n} from 'app/types/unified-alerting';\nimport { RulerRuleDTO, RulerRuleGroupDTO, RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\n\nimport {\n  getAllRulesSources,\n  getRulesSourceByName,\n  isCloudRulesSource,\n  isGrafanaRulesSource,\n} from '../utils/datasource';\nimport { isAlertingRule, isAlertingRulerRule, isRecordingRulerRule } from '../utils/rules';\n\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\ninterface CacheValue {\n  promRules?: RuleNamespace[];\n  rulerRules?: RulerRulesConfigDTO | null;\n  result: CombinedRuleNamespace[];\n}\n\n// this little monster combines prometheus rules and ruler rules to produce a unified data structure\n// can limit to a single rules source\nexport function useCombinedRuleNamespaces(rulesSourceName?: string): CombinedRuleNamespace[] {\n  const promRulesResponses = useUnifiedAlertingSelector((state) => state.promRules);\n  const rulerRulesResponses = useUnifiedAlertingSelector((state) => state.rulerRules);\n\n  // cache results per rules source, so we only recalculate those for which results have actually changed\n  const cache = useRef<Record<string, CacheValue>>({});\n\n  const rulesSources = useMemo((): RulesSource[] => {\n    if (rulesSourceName) {\n      const rulesSource = getRulesSourceByName(rulesSourceName);\n      if (!rulesSource) {\n        throw new Error(`Unknown rules source: ${rulesSourceName}`);\n      }\n      return [rulesSource];\n    }\n    return getAllRulesSources();\n  }, [rulesSourceName]);\n\n  return useMemo(\n    () =>\n      rulesSources\n        .map((rulesSource): CombinedRuleNamespace[] => {\n          const rulesSourceName = isCloudRulesSource(rulesSource) ? rulesSource.name : rulesSource;\n          const promRules = promRulesResponses[rulesSourceName]?.result;\n          const rulerRules = rulerRulesResponses[rulesSourceName]?.result;\n\n          const cached = cache.current[rulesSourceName];\n          if (cached && cached.promRules === promRules && cached.rulerRules === rulerRules) {\n            return cached.result;\n          }\n          const namespaces: Record<string, CombinedRuleNamespace> = {};\n\n          // first get all the ruler rules in\n          Object.entries(rulerRules || {}).forEach(([namespaceName, groups]) => {\n            const namespace: CombinedRuleNamespace = {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            };\n            namespaces[namespaceName] = namespace;\n            addRulerGroupsToCombinedNamespace(namespace, groups);\n          });\n\n          // then correlate with prometheus rules\n          promRules?.forEach(({ name: namespaceName, groups }) => {\n            const ns = (namespaces[namespaceName] = namespaces[namespaceName] || {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            });\n\n            addPromGroupsToCombinedNamespace(ns, groups);\n          });\n\n          const result = Object.values(namespaces);\n\n          cache.current[rulesSourceName] = { promRules, rulerRules, result };\n          return result;\n        })\n        .flat(),\n    [promRulesResponses, rulerRulesResponses, rulesSources]\n  );\n}\n\n// merge all groups in case of grafana managed, essentially treating namespaces (folders) as groups\nexport function flattenGrafanaManagedRules(namespaces: CombinedRuleNamespace[]) {\n  return namespaces.map((namespace) => {\n    const newNamespace: CombinedRuleNamespace = {\n      ...namespace,\n      groups: [],\n    };\n\n    // add default group with ungrouped rules\n    newNamespace.groups.push({\n      name: 'default',\n      rules: sortRulesByName(namespace.groups.flatMap((group) => group.rules)),\n    });\n\n    return newNamespace;\n  });\n}\n\nexport function sortRulesByName(rules: CombinedRule[]) {\n  return rules.sort((a, b) => a.name.localeCompare(b.name));\n}\n\nfunction addRulerGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RulerRuleGroupDTO[]): void {\n  namespace.groups = groups.map((group) => {\n    const combinedGroup: CombinedRuleGroup = {\n      name: group.name,\n      interval: group.interval,\n      source_tenants: group.source_tenants,\n      rules: [],\n    };\n    combinedGroup.rules = group.rules.map((rule) => rulerRuleToCombinedRule(rule, namespace, combinedGroup));\n    return combinedGroup;\n  });\n}\n\nfunction addPromGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RuleGroup[]): void {\n  groups.forEach((group) => {\n    let combinedGroup = namespace.groups.find((g) => g.name === group.name);\n    if (!combinedGroup) {\n      combinedGroup = {\n        name: group.name,\n        rules: [],\n      };\n      namespace.groups.push(combinedGroup);\n    }\n\n    (group.rules ?? []).forEach((rule) => {\n      const existingRule = getExistingRuleInGroup(rule, combinedGroup!, namespace.rulesSource);\n      if (existingRule) {\n        existingRule.promRule = rule;\n      } else {\n        combinedGroup!.rules.push(promRuleToCombinedRule(rule, namespace, combinedGroup!));\n      }\n    });\n  });\n}\n\nfunction promRuleToCombinedRule(rule: Rule, namespace: CombinedRuleNamespace, group: CombinedRuleGroup): CombinedRule {\n  return {\n    name: rule.name,\n    query: rule.query,\n    labels: rule.labels || {},\n    annotations: isAlertingRule(rule) ? rule.annotations || {} : {},\n    promRule: rule,\n    namespace: namespace,\n    group,\n  };\n}\n\nfunction rulerRuleToCombinedRule(\n  rule: RulerRuleDTO,\n  namespace: CombinedRuleNamespace,\n  group: CombinedRuleGroup\n): CombinedRule {\n  return isAlertingRulerRule(rule)\n    ? {\n        name: rule.alert,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : isRecordingRulerRule(rule)\n    ? {\n        name: rule.record,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : {\n        name: rule.grafana_alert.title,\n        query: '',\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      };\n}\n\n// find existing rule in group that matches the given prom rule\nfunction getExistingRuleInGroup(\n  rule: Rule,\n  group: CombinedRuleGroup,\n  rulesSource: RulesSource\n): CombinedRule | undefined {\n  if (isGrafanaRulesSource(rulesSource)) {\n    // assume grafana groups have only the one rule. check name anyway because paranoid\n    return group!.rules.find((existingRule) => existingRule.name === rule.name);\n  }\n  return (\n    // try finding a rule that matches name, labels, annotations and query\n    group!.rules.find(\n      (existingRule) => !existingRule.promRule && isCombinedRuleEqualToPromRule(existingRule, rule, true)\n    ) ??\n    // if that fails, try finding a rule that only matches name, labels and annotations.\n    // loki & prom can sometimes modify the query so it doesnt match, eg `2 > 1` becomes `1`\n    group!.rules.find(\n      (existingRule) => !existingRule.promRule && isCombinedRuleEqualToPromRule(existingRule, rule, false)\n    )\n  );\n}\n\nfunction isCombinedRuleEqualToPromRule(combinedRule: CombinedRule, rule: Rule, checkQuery = true): boolean {\n  if (combinedRule.name === rule.name) {\n    return (\n      JSON.stringify([\n        checkQuery ? hashQuery(combinedRule.query) : '',\n        combinedRule.labels,\n        combinedRule.annotations,\n      ]) ===\n      JSON.stringify([\n        checkQuery ? hashQuery(rule.query) : '',\n        rule.labels || {},\n        isAlertingRule(rule) ? rule.annotations || {} : {},\n      ])\n    );\n  }\n  return false;\n}\n\n// there can be slight differences in how prom & ruler render a query, this will hash them accounting for the differences\nfunction hashQuery(query: string) {\n  // one of them might be wrapped in parens\n  if (query.length > 1 && query[0] === '(' && query[query.length - 1] === ')') {\n    query = query.slice(1, -1);\n  }\n  // whitespace could be added or removed\n  query = query.replace(/\\s|\\n/g, '');\n  // labels matchers can be reordered, so sort the enitre string, esentially comparing just the character counts\n  return query.split('').sort().join('');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}