{"ast":null,"code":"import { fromPairs, uniq } from 'lodash';\nimport { useMemo } from 'react';\n\n/**\n * Limits the number of nodes by going from the roots breadth first until we have desired number of nodes.\n */\nexport function useNodeLimit(nodes, edges, limit, config, rootId) {\n  // This is pretty expensive also this happens once in the layout code when initializing position but it's a bit\n  // tricky to do it only once and reuse the results because layout directly modifies the nodes.\n  const [edgesMap, nodesMap] = useMemo(() => {\n    // Make sure we don't compute this until we have all the data.\n    if (!(nodes.length && edges.length)) {\n      return [{}, {}];\n    }\n\n    const edgesMap = edges.reduce((acc, e) => {\n      var _acc$e$source$id, _acc$e$target$id;\n\n      acc[e.source.id] = [...((_acc$e$source$id = acc[e.source.id]) !== null && _acc$e$source$id !== void 0 ? _acc$e$source$id : []), e];\n      acc[e.target.id] = [...((_acc$e$target$id = acc[e.target.id]) !== null && _acc$e$target$id !== void 0 ? _acc$e$target$id : []), e];\n      return acc;\n    }, {});\n    const nodesMap = nodes.reduce((acc, node) => {\n      acc[node.id] = node;\n      return acc;\n    }, {});\n    return [edgesMap, nodesMap];\n  }, [edges, nodes]);\n  return useMemo(() => {\n    if (nodes.length <= limit) {\n      return {\n        nodes,\n        edges\n      };\n    }\n\n    if (config.gridLayout) {\n      return limitGridLayout(nodes, limit, rootId);\n    }\n\n    return limitGraphLayout(nodes, edges, nodesMap, edgesMap, limit, rootId);\n  }, [edges, edgesMap, limit, nodes, nodesMap, rootId, config.gridLayout]);\n}\nexport function limitGraphLayout(nodes, edges, nodesMap, edgesMap, limit, rootId) {\n  let roots;\n\n  if (rootId) {\n    roots = [nodesMap[rootId]];\n  } else {\n    roots = nodes.filter(n => n.incoming === 0); // TODO: same code as layout\n\n    if (!roots.length) {\n      roots = [nodes[0]];\n    }\n  }\n\n  const {\n    visibleNodes,\n    markers\n  } = collectVisibleNodes(limit, roots, nodesMap, edgesMap);\n  const markersWithStats = collectMarkerStats(markers, visibleNodes, nodesMap, edgesMap);\n  const markersMap = fromPairs(markersWithStats.map(m => [m.node.id, m]));\n\n  for (const marker of markersWithStats) {\n    if (marker.count === 1) {\n      delete markersMap[marker.node.id];\n      visibleNodes[marker.node.id] = marker.node;\n    }\n  } // Show all edges between visible nodes or placeholder markers\n\n\n  const visibleEdges = edges.filter(e => (visibleNodes[e.source.id] || markersMap[e.source.id]) && (visibleNodes[e.target.id] || markersMap[e.target.id]));\n  return {\n    nodes: Object.values(visibleNodes),\n    edges: visibleEdges,\n    markers: Object.values(markersMap)\n  };\n}\nexport function limitGridLayout(nodes, limit, rootId) {\n  let start = 0;\n  let stop = limit;\n  let markers = [];\n\n  if (rootId) {\n    const index = nodes.findIndex(node => node.id === rootId);\n    const prevLimit = Math.floor(limit / 2);\n    let afterLimit = prevLimit;\n    start = index - prevLimit;\n\n    if (start < 0) {\n      afterLimit += Math.abs(start);\n      start = 0;\n    }\n\n    stop = index + afterLimit + 1;\n\n    if (stop > nodes.length) {\n      if (start > 0) {\n        start = Math.max(0, start - (stop - nodes.length));\n      }\n\n      stop = nodes.length;\n    }\n\n    if (start > 1) {\n      markers.push({\n        node: nodes[start - 1],\n        count: start\n      });\n    }\n\n    if (nodes.length - stop > 1) {\n      markers.push({\n        node: nodes[stop],\n        count: nodes.length - stop\n      });\n    }\n  } else {\n    if (nodes.length - limit > 1) {\n      markers = [{\n        node: nodes[limit],\n        count: nodes.length - limit\n      }];\n    }\n  }\n\n  return {\n    nodes: nodes.slice(start, stop),\n    edges: [],\n    markers\n  };\n}\n/**\n * Breath first traverse of the graph collecting all the nodes until we reach the limit. It also returns markers which\n * are nodes on the edges which did not make it into the limit but can be used as clickable markers for manually\n * expanding the graph.\n * @param limit\n * @param roots - Nodes where to start the traversal. In case of exploration this can be any node that user clicked on.\n * @param nodesMap - Node id to node\n * @param edgesMap - This is a map of node id to a list of edges (both ingoing and outgoing)\n */\n\nfunction collectVisibleNodes(limit, roots, nodesMap, edgesMap) {\n  const visibleNodes = {};\n  let stack = [...roots];\n\n  while (Object.keys(visibleNodes).length < limit && stack.length > 0) {\n    let current = stack.shift(); // We are already showing this node. This can happen because graphs can be cyclic\n\n    if (visibleNodes[current.id]) {\n      continue;\n    } // Show this node\n\n\n    visibleNodes[current.id] = current;\n    const edges = edgesMap[current.id] || []; // Add any nodes that are connected to it on top of the stack to be considered in the next pass\n\n    const connectedNodes = edges.map(e => {\n      // We don't care about direction here. Should not make much difference but argument could be made that with\n      // directed graphs it should walk the graph directionally. Problem is when we focus on a node in the middle of\n      // graph (not going from the \"natural\" root) we also want to show what was \"before\".\n      const id = e.source.id === current.id ? e.target.id : e.source.id;\n      return nodesMap[id];\n    });\n    stack = stack.concat(connectedNodes);\n  } // Right now our stack contains all the nodes which are directly connected to the graph but did not make the cut.\n  // Some of them though can be nodes we already are showing so we have to filter them and then use them as markers.\n\n\n  const markers = uniq(stack.filter(n => !visibleNodes[n.id]));\n  return {\n    visibleNodes,\n    markers\n  };\n}\n\nfunction collectMarkerStats(markers, visibleNodes, nodesMap, edgesMap) {\n  return markers.map(marker => {\n    const nodesToCount = {};\n    let count = 0;\n    let stack = [marker];\n\n    while (stack.length > 0 && count <= 101) {\n      let current = stack.shift(); // We are showing this node so not going to count it as hidden.\n\n      if (visibleNodes[current.id] || nodesToCount[current.id]) {\n        continue;\n      }\n\n      if (!nodesToCount[current.id]) {\n        count++;\n      }\n\n      nodesToCount[current.id] = current;\n      const edges = edgesMap[current.id] || [];\n      const connectedNodes = edges.map(e => {\n        const id = e.source.id === current.id ? e.target.id : e.source.id;\n        return nodesMap[id];\n      });\n      stack = stack.concat(connectedNodes);\n    }\n\n    return {\n      node: marker,\n      count: count\n    };\n  });\n}","map":{"version":3,"names":["fromPairs","uniq","useMemo","useNodeLimit","nodes","edges","limit","config","rootId","edgesMap","nodesMap","length","reduce","acc","e","source","id","target","node","gridLayout","limitGridLayout","limitGraphLayout","roots","filter","n","incoming","visibleNodes","markers","collectVisibleNodes","markersWithStats","collectMarkerStats","markersMap","map","m","marker","count","visibleEdges","Object","values","start","stop","index","findIndex","prevLimit","Math","floor","afterLimit","abs","max","push","slice","stack","keys","current","shift","connectedNodes","concat","nodesToCount"],"sources":["/home/soula/grafana/public/app/plugins/panel/nodeGraph/useNodeLimit.ts"],"sourcesContent":["import { fromPairs, uniq } from 'lodash';\nimport { useMemo } from 'react';\n\nimport { Config } from './layout';\nimport { EdgeDatumLayout, NodeDatum, NodesMarker } from './types';\n\ntype NodesMap = Record<string, NodeDatum>;\ntype EdgesMap = Record<string, EdgeDatumLayout[]>;\n\n/**\n * Limits the number of nodes by going from the roots breadth first until we have desired number of nodes.\n */\nexport function useNodeLimit(\n  nodes: NodeDatum[],\n  edges: EdgeDatumLayout[],\n  limit: number,\n  config: Config,\n  rootId?: string\n): { nodes: NodeDatum[]; edges: EdgeDatumLayout[]; markers?: NodesMarker[] } {\n  // This is pretty expensive also this happens once in the layout code when initializing position but it's a bit\n  // tricky to do it only once and reuse the results because layout directly modifies the nodes.\n  const [edgesMap, nodesMap] = useMemo(() => {\n    // Make sure we don't compute this until we have all the data.\n    if (!(nodes.length && edges.length)) {\n      return [{}, {}];\n    }\n\n    const edgesMap = edges.reduce<EdgesMap>((acc, e) => {\n      acc[e.source.id] = [...(acc[e.source.id] ?? []), e];\n      acc[e.target.id] = [...(acc[e.target.id] ?? []), e];\n      return acc;\n    }, {});\n\n    const nodesMap = nodes.reduce<NodesMap>((acc, node) => {\n      acc[node.id] = node;\n      return acc;\n    }, {});\n    return [edgesMap, nodesMap];\n  }, [edges, nodes]);\n\n  return useMemo(() => {\n    if (nodes.length <= limit) {\n      return { nodes, edges };\n    }\n\n    if (config.gridLayout) {\n      return limitGridLayout(nodes, limit, rootId);\n    }\n\n    return limitGraphLayout(nodes, edges, nodesMap, edgesMap, limit, rootId);\n  }, [edges, edgesMap, limit, nodes, nodesMap, rootId, config.gridLayout]);\n}\n\nexport function limitGraphLayout(\n  nodes: NodeDatum[],\n  edges: EdgeDatumLayout[],\n  nodesMap: NodesMap,\n  edgesMap: EdgesMap,\n  limit: number,\n  rootId?: string\n) {\n  let roots;\n  if (rootId) {\n    roots = [nodesMap[rootId]];\n  } else {\n    roots = nodes.filter((n) => n.incoming === 0);\n    // TODO: same code as layout\n    if (!roots.length) {\n      roots = [nodes[0]];\n    }\n  }\n\n  const { visibleNodes, markers } = collectVisibleNodes(limit, roots, nodesMap, edgesMap);\n\n  const markersWithStats = collectMarkerStats(markers, visibleNodes, nodesMap, edgesMap);\n  const markersMap = fromPairs(markersWithStats.map((m) => [m.node.id, m]));\n\n  for (const marker of markersWithStats) {\n    if (marker.count === 1) {\n      delete markersMap[marker.node.id];\n      visibleNodes[marker.node.id] = marker.node;\n    }\n  }\n\n  // Show all edges between visible nodes or placeholder markers\n  const visibleEdges = edges.filter(\n    (e) =>\n      (visibleNodes[e.source.id] || markersMap[e.source.id]) && (visibleNodes[e.target.id] || markersMap[e.target.id])\n  );\n\n  return {\n    nodes: Object.values(visibleNodes),\n    edges: visibleEdges,\n    markers: Object.values(markersMap),\n  };\n}\n\nexport function limitGridLayout(nodes: NodeDatum[], limit: number, rootId?: string) {\n  let start = 0;\n  let stop = limit;\n  let markers: NodesMarker[] = [];\n\n  if (rootId) {\n    const index = nodes.findIndex((node) => node.id === rootId);\n    const prevLimit = Math.floor(limit / 2);\n    let afterLimit = prevLimit;\n    start = index - prevLimit;\n    if (start < 0) {\n      afterLimit += Math.abs(start);\n      start = 0;\n    }\n    stop = index + afterLimit + 1;\n\n    if (stop > nodes.length) {\n      if (start > 0) {\n        start = Math.max(0, start - (stop - nodes.length));\n      }\n      stop = nodes.length;\n    }\n\n    if (start > 1) {\n      markers.push({ node: nodes[start - 1], count: start });\n    }\n\n    if (nodes.length - stop > 1) {\n      markers.push({ node: nodes[stop], count: nodes.length - stop });\n    }\n  } else {\n    if (nodes.length - limit > 1) {\n      markers = [{ node: nodes[limit], count: nodes.length - limit }];\n    }\n  }\n\n  return {\n    nodes: nodes.slice(start, stop),\n    edges: [],\n    markers,\n  };\n}\n\n/**\n * Breath first traverse of the graph collecting all the nodes until we reach the limit. It also returns markers which\n * are nodes on the edges which did not make it into the limit but can be used as clickable markers for manually\n * expanding the graph.\n * @param limit\n * @param roots - Nodes where to start the traversal. In case of exploration this can be any node that user clicked on.\n * @param nodesMap - Node id to node\n * @param edgesMap - This is a map of node id to a list of edges (both ingoing and outgoing)\n */\nfunction collectVisibleNodes(\n  limit: number,\n  roots: NodeDatum[],\n  nodesMap: Record<string, NodeDatum>,\n  edgesMap: Record<string, EdgeDatumLayout[]>\n): { visibleNodes: Record<string, NodeDatum>; markers: NodeDatum[] } {\n  const visibleNodes: Record<string, NodeDatum> = {};\n  let stack = [...roots];\n\n  while (Object.keys(visibleNodes).length < limit && stack.length > 0) {\n    let current = stack.shift()!;\n\n    // We are already showing this node. This can happen because graphs can be cyclic\n    if (visibleNodes[current!.id]) {\n      continue;\n    }\n\n    // Show this node\n    visibleNodes[current.id] = current;\n    const edges = edgesMap[current.id] || [];\n\n    // Add any nodes that are connected to it on top of the stack to be considered in the next pass\n    const connectedNodes = edges.map((e) => {\n      // We don't care about direction here. Should not make much difference but argument could be made that with\n      // directed graphs it should walk the graph directionally. Problem is when we focus on a node in the middle of\n      // graph (not going from the \"natural\" root) we also want to show what was \"before\".\n      const id = e.source.id === current.id ? e.target.id : e.source.id;\n      return nodesMap[id];\n    });\n    stack = stack.concat(connectedNodes);\n  }\n\n  // Right now our stack contains all the nodes which are directly connected to the graph but did not make the cut.\n  // Some of them though can be nodes we already are showing so we have to filter them and then use them as markers.\n  const markers = uniq(stack.filter((n) => !visibleNodes[n.id]));\n\n  return { visibleNodes, markers };\n}\n\nfunction collectMarkerStats(\n  markers: NodeDatum[],\n  visibleNodes: Record<string, NodeDatum>,\n  nodesMap: Record<string, NodeDatum>,\n  edgesMap: Record<string, EdgeDatumLayout[]>\n): NodesMarker[] {\n  return markers.map((marker) => {\n    const nodesToCount: Record<string, NodeDatum> = {};\n    let count = 0;\n    let stack = [marker];\n    while (stack.length > 0 && count <= 101) {\n      let current = stack.shift()!;\n\n      // We are showing this node so not going to count it as hidden.\n      if (visibleNodes[current.id] || nodesToCount[current.id]) {\n        continue;\n      }\n\n      if (!nodesToCount[current.id]) {\n        count++;\n      }\n      nodesToCount[current.id] = current;\n\n      const edges = edgesMap[current.id] || [];\n\n      const connectedNodes = edges.map((e) => {\n        const id = e.source.id === current.id ? e.target.id : e.source.id;\n        return nodesMap[id];\n      });\n      stack = stack.concat(connectedNodes);\n    }\n\n    return {\n      node: marker,\n      count: count,\n    };\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}