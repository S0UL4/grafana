{"ast":null,"code":"import { LoadingState, toDataFrame, FieldType, dataFrameFromJSON } from '@grafana/data';\nimport { toDataQueryError } from './toDataQueryError';\nexport const cachedResponseNotice = {\n  severity: 'info',\n  text: 'Cached response'\n};\n/**\n * Single response object from a backend data source. Properties are optional but response should contain at least\n * an error or a some data (but can contain both). Main way to send data is with dataframes attribute as series and\n * tables data attributes are legacy formats.\n *\n * @internal\n */\n\n/**\n * Parse the results from /api/ds/query into a DataQueryResponse\n *\n * @param res - the HTTP response data.\n * @param queries - optional DataQuery array that will order the response based on the order of query refId's.\n *\n * @public\n */\nexport function toDataQueryResponse(res, queries) {\n  var _data;\n\n  const rsp = {\n    data: [],\n    state: LoadingState.Done\n  }; // If the response isn't in a correct shape we just ignore the data and pass empty DataQueryResponse.\n\n  if ((_data = res.data) !== null && _data !== void 0 && _data.results) {\n    const results = res.data.results;\n    const refIDs = queries !== null && queries !== void 0 && queries.length ? queries.map(q => q.refId) : Object.keys(results);\n    const cachedResponse = isCachedResponse(res);\n    const data = [];\n\n    for (const refId of refIDs) {\n      const dr = results[refId];\n\n      if (!dr) {\n        continue;\n      }\n\n      dr.refId = refId;\n      data.push(dr);\n    }\n\n    for (const dr of data) {\n      var _dr$frames, _dr$series, _dr$tables;\n\n      if (dr.error) {\n        if (!rsp.error) {\n          rsp.error = {\n            refId: dr.refId,\n            message: dr.error\n          };\n          rsp.state = LoadingState.Error;\n        }\n      }\n\n      if ((_dr$frames = dr.frames) !== null && _dr$frames !== void 0 && _dr$frames.length) {\n        for (let js of dr.frames) {\n          if (cachedResponse) {\n            js = addCacheNotice(js);\n          }\n\n          const df = dataFrameFromJSON(js);\n\n          if (!df.refId) {\n            df.refId = dr.refId;\n          }\n\n          rsp.data.push(df);\n        }\n\n        continue; // the other tests are legacy\n      }\n\n      if ((_dr$series = dr.series) !== null && _dr$series !== void 0 && _dr$series.length) {\n        for (const s of dr.series) {\n          if (!s.refId) {\n            s.refId = dr.refId;\n          }\n\n          rsp.data.push(toDataFrame(s));\n        }\n      }\n\n      if ((_dr$tables = dr.tables) !== null && _dr$tables !== void 0 && _dr$tables.length) {\n        for (const s of dr.tables) {\n          if (!s.refId) {\n            s.refId = dr.refId;\n          }\n\n          rsp.data.push(toDataFrame(s));\n        }\n      }\n    }\n  } // When it is not an OK response, make sure the error gets added\n\n\n  if (res.status && res.status !== 200) {\n    if (rsp.state !== LoadingState.Error) {\n      rsp.state = LoadingState.Error;\n    }\n\n    if (!rsp.error) {\n      rsp.error = toDataQueryError(res);\n    }\n  }\n\n  return rsp;\n}\n\nfunction isCachedResponse(res) {\n  const headers = res === null || res === void 0 ? void 0 : res.headers;\n\n  if (!headers || !headers.get) {\n    return false;\n  }\n\n  return headers.get('X-Cache') === 'HIT';\n}\n\nfunction addCacheNotice(frame) {\n  var _frame$schema$fields, _frame$schema, _frame$schema2, _frame$schema$meta$no, _frame$schema3, _frame$schema3$meta;\n\n  return Object.assign({}, frame, {\n    schema: Object.assign({}, frame.schema, {\n      fields: [...((_frame$schema$fields = (_frame$schema = frame.schema) === null || _frame$schema === void 0 ? void 0 : _frame$schema.fields) !== null && _frame$schema$fields !== void 0 ? _frame$schema$fields : [])],\n      meta: Object.assign({}, (_frame$schema2 = frame.schema) === null || _frame$schema2 === void 0 ? void 0 : _frame$schema2.meta, {\n        notices: [...((_frame$schema$meta$no = (_frame$schema3 = frame.schema) === null || _frame$schema3 === void 0 ? void 0 : (_frame$schema3$meta = _frame$schema3.meta) === null || _frame$schema3$meta === void 0 ? void 0 : _frame$schema3$meta.notices) !== null && _frame$schema$meta$no !== void 0 ? _frame$schema$meta$no : []), cachedResponseNotice],\n        isCachedResponse: true\n      })\n    })\n  });\n}\n/**\n * Data sources using api/ds/query to test data sources can use this function to\n * handle errors and convert them to TestingStatus object.\n *\n * If possible, this should be avoided in favor of implementing /health endpoint\n * and testing data source with DataSourceWithBackend.testDataSource()\n *\n * Re-thrown errors are handled by testDataSource() in public/app/features/datasources/state/actions.ts\n *\n * @returns {TestingStatus}\n */\n\n\nexport function toTestingStatus(err) {\n  var _queryResponse$error, _queryResponse$error$, _queryResponse$error4, _queryResponse$error5;\n\n  const queryResponse = toDataQueryResponse(err); // POST api/ds/query errors returned as { message: string, error: string } objects\n\n  if ((_queryResponse$error = queryResponse.error) !== null && _queryResponse$error !== void 0 && (_queryResponse$error$ = _queryResponse$error.data) !== null && _queryResponse$error$ !== void 0 && _queryResponse$error$.message) {\n    var _queryResponse$error2, _queryResponse$error3;\n\n    return {\n      status: 'error',\n      message: queryResponse.error.data.message,\n      details: (_queryResponse$error2 = queryResponse.error) !== null && _queryResponse$error2 !== void 0 && (_queryResponse$error3 = _queryResponse$error2.data) !== null && _queryResponse$error3 !== void 0 && _queryResponse$error3.error ? {\n        message: queryResponse.error.data.error\n      } : undefined\n    };\n  } // POST api/ds/query errors returned in results object\n  else if ((_queryResponse$error4 = queryResponse.error) !== null && _queryResponse$error4 !== void 0 && _queryResponse$error4.refId && (_queryResponse$error5 = queryResponse.error) !== null && _queryResponse$error5 !== void 0 && _queryResponse$error5.message) {\n    return {\n      status: 'error',\n      message: queryResponse.error.message\n    };\n  }\n\n  throw err;\n}\n/**\n * Return the first string or non-time field as the value\n *\n * @beta\n */\n\nexport function frameToMetricFindValue(frame) {\n  if (!frame || !frame.length) {\n    return [];\n  }\n\n  const values = [];\n  let field = frame.fields.find(f => f.type === FieldType.string);\n\n  if (!field) {\n    field = frame.fields.find(f => f.type !== FieldType.time);\n  }\n\n  if (field) {\n    for (let i = 0; i < field.values.length; i++) {\n      values.push({\n        text: '' + field.values.get(i)\n      });\n    }\n  }\n\n  return values;\n}","map":{"version":3,"names":["LoadingState","toDataFrame","FieldType","dataFrameFromJSON","toDataQueryError","cachedResponseNotice","severity","text","toDataQueryResponse","res","queries","rsp","data","state","Done","results","refIDs","length","map","q","refId","Object","keys","cachedResponse","isCachedResponse","dr","push","error","message","Error","frames","js","addCacheNotice","df","series","s","tables","status","headers","get","frame","schema","fields","meta","notices","toTestingStatus","err","queryResponse","details","undefined","frameToMetricFindValue","values","field","find","f","type","string","time","i"],"sources":["/home/soula/grafana/packages/grafana-runtime/src/utils/queryResponse.ts"],"sourcesContent":["import {\n  DataQueryResponse,\n  KeyValue,\n  LoadingState,\n  DataQueryError,\n  TimeSeries,\n  TableData,\n  toDataFrame,\n  DataFrame,\n  MetricFindValue,\n  FieldType,\n  DataQuery,\n  DataFrameJSON,\n  dataFrameFromJSON,\n  QueryResultMetaNotice,\n} from '@grafana/data';\n\nimport { FetchError, FetchResponse } from '../services';\n\nimport { toDataQueryError } from './toDataQueryError';\n\nexport const cachedResponseNotice: QueryResultMetaNotice = { severity: 'info', text: 'Cached response' };\n\n/**\n * Single response object from a backend data source. Properties are optional but response should contain at least\n * an error or a some data (but can contain both). Main way to send data is with dataframes attribute as series and\n * tables data attributes are legacy formats.\n *\n * @internal\n */\nexport interface DataResponse {\n  error?: string;\n  refId?: string;\n  frames?: DataFrameJSON[];\n\n  // Legacy TSDB format...\n  series?: TimeSeries[];\n  tables?: TableData[];\n}\n\n/**\n * This is the type of response expected form backend datasource.\n *\n * @internal\n */\nexport interface BackendDataSourceResponse {\n  results: KeyValue<DataResponse>;\n}\n\n/**\n * Parse the results from /api/ds/query into a DataQueryResponse\n *\n * @param res - the HTTP response data.\n * @param queries - optional DataQuery array that will order the response based on the order of query refId's.\n *\n * @public\n */\nexport function toDataQueryResponse(\n  res:\n    | { data: BackendDataSourceResponse | undefined }\n    | FetchResponse<BackendDataSourceResponse | undefined>\n    | DataQueryError,\n  queries?: DataQuery[]\n): DataQueryResponse {\n  const rsp: DataQueryResponse = { data: [], state: LoadingState.Done };\n  // If the response isn't in a correct shape we just ignore the data and pass empty DataQueryResponse.\n  if ((res as FetchResponse).data?.results) {\n    const results = (res as FetchResponse).data.results;\n    const refIDs = queries?.length ? queries.map((q) => q.refId) : Object.keys(results);\n    const cachedResponse = isCachedResponse(res as FetchResponse);\n    const data: DataResponse[] = [];\n\n    for (const refId of refIDs) {\n      const dr = results[refId];\n      if (!dr) {\n        continue;\n      }\n      dr.refId = refId;\n      data.push(dr);\n    }\n\n    for (const dr of data) {\n      if (dr.error) {\n        if (!rsp.error) {\n          rsp.error = {\n            refId: dr.refId,\n            message: dr.error,\n          };\n          rsp.state = LoadingState.Error;\n        }\n      }\n\n      if (dr.frames?.length) {\n        for (let js of dr.frames) {\n          if (cachedResponse) {\n            js = addCacheNotice(js);\n          }\n          const df = dataFrameFromJSON(js);\n          if (!df.refId) {\n            df.refId = dr.refId;\n          }\n          rsp.data.push(df);\n        }\n        continue; // the other tests are legacy\n      }\n\n      if (dr.series?.length) {\n        for (const s of dr.series) {\n          if (!s.refId) {\n            s.refId = dr.refId;\n          }\n          rsp.data.push(toDataFrame(s));\n        }\n      }\n\n      if (dr.tables?.length) {\n        for (const s of dr.tables) {\n          if (!s.refId) {\n            s.refId = dr.refId;\n          }\n          rsp.data.push(toDataFrame(s));\n        }\n      }\n    }\n  }\n\n  // When it is not an OK response, make sure the error gets added\n  if ((res as FetchResponse).status && (res as FetchResponse).status !== 200) {\n    if (rsp.state !== LoadingState.Error) {\n      rsp.state = LoadingState.Error;\n    }\n    if (!rsp.error) {\n      rsp.error = toDataQueryError(res as DataQueryError);\n    }\n  }\n\n  return rsp;\n}\n\nfunction isCachedResponse(res: FetchResponse<BackendDataSourceResponse | undefined>): boolean {\n  const headers = res?.headers;\n  if (!headers || !headers.get) {\n    return false;\n  }\n  return headers.get('X-Cache') === 'HIT';\n}\n\nfunction addCacheNotice(frame: DataFrameJSON): DataFrameJSON {\n  return {\n    ...frame,\n    schema: {\n      ...frame.schema,\n      fields: [...(frame.schema?.fields ?? [])],\n      meta: {\n        ...frame.schema?.meta,\n        notices: [...(frame.schema?.meta?.notices ?? []), cachedResponseNotice],\n        isCachedResponse: true,\n      },\n    },\n  };\n}\n\n/**\n * Data sources using api/ds/query to test data sources can use this function to\n * handle errors and convert them to TestingStatus object.\n *\n * If possible, this should be avoided in favor of implementing /health endpoint\n * and testing data source with DataSourceWithBackend.testDataSource()\n *\n * Re-thrown errors are handled by testDataSource() in public/app/features/datasources/state/actions.ts\n *\n * @returns {TestingStatus}\n */\nexport function toTestingStatus(err: FetchError): any {\n  const queryResponse = toDataQueryResponse(err);\n  // POST api/ds/query errors returned as { message: string, error: string } objects\n  if (queryResponse.error?.data?.message) {\n    return {\n      status: 'error',\n      message: queryResponse.error.data.message,\n      details: queryResponse.error?.data?.error ? { message: queryResponse.error.data.error } : undefined,\n    };\n  }\n  // POST api/ds/query errors returned in results object\n  else if (queryResponse.error?.refId && queryResponse.error?.message) {\n    return {\n      status: 'error',\n      message: queryResponse.error.message,\n    };\n  }\n\n  throw err;\n}\n\n/**\n * Return the first string or non-time field as the value\n *\n * @beta\n */\nexport function frameToMetricFindValue(frame: DataFrame): MetricFindValue[] {\n  if (!frame || !frame.length) {\n    return [];\n  }\n\n  const values: MetricFindValue[] = [];\n  let field = frame.fields.find((f) => f.type === FieldType.string);\n  if (!field) {\n    field = frame.fields.find((f) => f.type !== FieldType.time);\n  }\n  if (field) {\n    for (let i = 0; i < field.values.length; i++) {\n      values.push({ text: '' + field.values.get(i) });\n    }\n  }\n  return values;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}