{"ast":null,"code":"import { parser } from '@grafana/lezer-logql';\nimport { ErrorName, getAllByType, getLeftMostChild, getString, makeBinOp, makeError, replaceVariables } from '../../prometheus/querybuilder/shared/parsingUtils';\nimport { binaryScalarDefs } from './binaryScalarOperations';\nexport function buildVisualQueryFromString(expr) {\n  const replacedExpr = replaceVariables(expr);\n  const tree = parser.parse(replacedExpr);\n  const node = tree.topNode; // This will be modified in the handleExpression\n\n  const visQuery = {\n    labels: [],\n    operations: []\n  };\n  const context = {\n    query: visQuery,\n    errors: []\n  };\n\n  try {\n    handleExpression(replacedExpr, node, context);\n  } catch (err) {\n    // Not ideal to log it here, but otherwise we would lose the stack trace.\n    console.error(err);\n\n    if (err instanceof Error) {\n      context.errors.push({\n        text: err.message\n      });\n    }\n  } // If we have empty query, we want to reset errors\n\n\n  if (isEmptyQuery(context.query)) {\n    context.errors = [];\n  }\n\n  return context;\n}\nexport function handleExpression(expr, node, context) {\n  const visQuery = context.query;\n\n  switch (node.name) {\n    case 'Matcher':\n      {\n        visQuery.labels.push(getLabel(expr, node));\n        const err = node.getChild(ErrorName);\n\n        if (err) {\n          context.errors.push(makeError(expr, err));\n        }\n\n        break;\n      }\n\n    case 'LineFilter':\n      {\n        const {\n          operation,\n          error\n        } = getLineFilter(expr, node);\n\n        if (operation) {\n          visQuery.operations.push(operation);\n        } // Show error for query patterns not supported in visual query builder\n\n\n        if (error) {\n          context.errors.push(createNotSupportedError(expr, node, error));\n        }\n\n        break;\n      }\n\n    case 'LabelParser':\n      {\n        visQuery.operations.push(getLabelParser(expr, node));\n        break;\n      }\n\n    case 'LabelFilter':\n      {\n        const {\n          operation,\n          error\n        } = getLabelFilter(expr, node);\n\n        if (operation) {\n          visQuery.operations.push(operation);\n        } // Show error for query patterns not supported in visual query builder\n\n\n        if (error) {\n          context.errors.push(createNotSupportedError(expr, node, error));\n        }\n\n        break;\n      }\n\n    case 'JsonExpressionParser':\n      {\n        // JsonExpressionParser is not supported in query builder\n        const error = 'JsonExpressionParser not supported in visual query builder';\n        context.errors.push(createNotSupportedError(expr, node, error));\n      }\n\n    case 'LineFormatExpr':\n      {\n        visQuery.operations.push(getLineFormat(expr, node));\n        break;\n      }\n\n    case 'LabelFormatMatcher':\n      {\n        visQuery.operations.push(getLabelFormat(expr, node));\n        break;\n      }\n\n    case 'UnwrapExpr':\n      {\n        const {\n          operation,\n          error\n        } = handleUnwrapExpr(expr, node, context);\n\n        if (operation) {\n          visQuery.operations.push(operation);\n        } // Show error for query patterns not supported in visual query builder\n\n\n        if (error) {\n          context.errors.push(createNotSupportedError(expr, node, error));\n        }\n\n        break;\n      }\n\n    case 'RangeAggregationExpr':\n      {\n        visQuery.operations.push(handleRangeAggregation(expr, node, context));\n        break;\n      }\n\n    case 'VectorAggregationExpr':\n      {\n        visQuery.operations.push(handleVectorAggregation(expr, node, context));\n        break;\n      }\n\n    case 'BinOpExpr':\n      {\n        handleBinary(expr, node, context);\n        break;\n      }\n\n    case ErrorName:\n      {\n        if (isIntervalVariableError(node)) {\n          break;\n        }\n\n        context.errors.push(makeError(expr, node));\n        break;\n      }\n\n    default:\n      {\n        // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper\n        // nodes that can be skipped.\n        // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to\n        //  detect those and report back.\n        let child = node.firstChild;\n\n        while (child) {\n          handleExpression(expr, child, context);\n          child = child.nextSibling;\n        }\n      }\n  }\n}\n\nfunction getLabel(expr, node) {\n  const labelNode = node.getChild('Identifier');\n  const label = getString(expr, labelNode);\n  const op = getString(expr, labelNode.nextSibling);\n  const value = getString(expr, node.getChild('String')).replace(/\"/g, '');\n  return {\n    label,\n    op,\n    value\n  };\n}\n\nfunction getLineFilter(expr, node) {\n  // Check for nodes not supported in visual builder and return error\n  const ipLineFilter = getAllByType(expr, node, 'Ip');\n\n  if (ipLineFilter.length > 0) {\n    return {\n      error: 'Matching ip addresses not supported in query builder'\n    };\n  }\n\n  const mapFilter = {\n    '|=': '__line_contains',\n    '!=': '__line_contains_not',\n    '|~': '__line_matches_regex',\n    '!~': '\"__line_matches_regex\"_not'\n  };\n  const filter = getString(expr, node.getChild('Filter'));\n  const filterExpr = handleQuotes(getString(expr, node.getChild('String')));\n  return {\n    operation: {\n      id: mapFilter[filter],\n      params: [filterExpr]\n    }\n  };\n}\n\nfunction getLabelParser(expr, node) {\n  const parserNode = node.firstChild;\n  const parser = getString(expr, parserNode);\n  const string = handleQuotes(getString(expr, node.getChild('String')));\n  const params = !!string ? [string] : [];\n  return {\n    id: parser,\n    params\n  };\n}\n\nfunction getLabelFilter(expr, node) {\n  // Check for nodes not supported in visual builder and return error\n  if (node.getChild('Or') || node.getChild('And') || node.getChild('Comma')) {\n    return {\n      error: 'Label filter with comma, \"and\", \"or\" not supported in query builder'\n    };\n  }\n\n  if (node.firstChild.name === 'IpLabelFilter') {\n    return {\n      error: 'IpLabelFilter not supported in query builder'\n    };\n  }\n\n  const id = '__label_filter';\n\n  if (node.firstChild.name === 'UnitFilter') {\n    const filter = node.firstChild.firstChild;\n    const label = filter.firstChild;\n    const op = label.nextSibling;\n    const value = op.nextSibling;\n    const valueString = handleQuotes(getString(expr, value));\n    return {\n      operation: {\n        id,\n        params: [getString(expr, label), getString(expr, op), valueString]\n      }\n    };\n  } // In this case it is Matcher or NumberFilter\n\n\n  const filter = node.firstChild;\n  const label = filter.firstChild;\n  const op = label.nextSibling;\n  const value = op.nextSibling;\n  const params = [getString(expr, label), getString(expr, op), handleQuotes(getString(expr, value))]; // Special case of pipe filtering - no errors\n\n  if (params.join('') === `__error__=`) {\n    return {\n      operation: {\n        id: '__label_filter_no_errors',\n        params: []\n      }\n    };\n  }\n\n  return {\n    operation: {\n      id,\n      params\n    }\n  };\n}\n\nfunction getLineFormat(expr, node) {\n  const id = 'line_format';\n  const string = handleQuotes(getString(expr, node.getChild('String')));\n  return {\n    id,\n    params: [string]\n  };\n}\n\nfunction getLabelFormat(expr, node) {\n  const id = 'label_format';\n  const identifier = node.getChild('Identifier');\n  const op = identifier.nextSibling;\n  const value = op.nextSibling;\n  let valueString = handleQuotes(getString(expr, value));\n  return {\n    id,\n    params: [getString(expr, identifier), valueString]\n  };\n}\n\nfunction handleUnwrapExpr(expr, node, context) {\n  const unwrapExprChild = node.getChild('UnwrapExpr');\n  const labelFilterChild = node.getChild('LabelFilter');\n  const unwrapChild = node.getChild('Unwrap');\n\n  if (unwrapExprChild) {\n    handleExpression(expr, unwrapExprChild, context);\n  }\n\n  if (labelFilterChild) {\n    handleExpression(expr, labelFilterChild, context);\n  }\n\n  if (unwrapChild) {\n    var _unwrapChild$nextSibl;\n\n    if ((unwrapChild === null || unwrapChild === void 0 ? void 0 : (_unwrapChild$nextSibl = unwrapChild.nextSibling) === null || _unwrapChild$nextSibl === void 0 ? void 0 : _unwrapChild$nextSibl.type.name) === 'ConvOp') {\n      return {\n        error: 'Unwrap with conversion operator not supported in query builder'\n      };\n    }\n\n    return {\n      operation: {\n        id: 'unwrap',\n        params: [getString(expr, unwrapChild === null || unwrapChild === void 0 ? void 0 : unwrapChild.nextSibling)]\n      }\n    };\n  }\n\n  return {};\n}\n\nfunction handleRangeAggregation(expr, node, context) {\n  const nameNode = node.getChild('RangeOp');\n  const funcName = getString(expr, nameNode);\n  const number = node.getChild('Number');\n  const logExpr = node.getChild('LogRangeExpr');\n  const params = number !== null && number !== undefined ? [getString(expr, number)] : [];\n  let match = getString(expr, node).match(/\\[(.+)\\]/);\n\n  if (match !== null && match !== void 0 && match[1]) {\n    params.push(match[1]);\n  }\n\n  const op = {\n    id: funcName,\n    params\n  };\n\n  if (logExpr) {\n    handleExpression(expr, logExpr, context);\n  }\n\n  return op;\n}\n\nfunction handleVectorAggregation(expr, node, context) {\n  const nameNode = node.getChild('VectorOp');\n  let funcName = getString(expr, nameNode);\n  const grouping = node.getChild('Grouping');\n  const params = [];\n  const numberNode = node.getChild('Number');\n\n  if (numberNode) {\n    params.push(Number(getString(expr, numberNode)));\n  }\n\n  if (grouping) {\n    const byModifier = grouping.getChild(`By`);\n\n    if (byModifier && funcName) {\n      funcName = `__${funcName}_by`;\n    }\n\n    const withoutModifier = grouping.getChild(`Without`);\n\n    if (withoutModifier) {\n      funcName = `__${funcName}_without`;\n    }\n\n    params.push(...getAllByType(expr, grouping, 'Identifier'));\n  }\n\n  const metricExpr = node.getChild('MetricExpr');\n  const op = {\n    id: funcName,\n    params\n  };\n\n  if (metricExpr) {\n    handleExpression(expr, metricExpr, context);\n  }\n\n  return op;\n}\n\nconst operatorToOpName = binaryScalarDefs.reduce((acc, def) => {\n  acc[def.sign] = {\n    id: def.id,\n    comparison: def.comparison\n  };\n  return acc;\n}, {});\n/**\n * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is\n * just operation with scalar or it creates a binaryQuery when it's 2 queries.\n * @param expr\n * @param node\n * @param context\n */\n\nfunction handleBinary(expr, node, context) {\n  const visQuery = context.query;\n  const left = node.firstChild;\n  const op = getString(expr, left.nextSibling);\n  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));\n  const right = node.lastChild;\n  const opDef = operatorToOpName[op];\n  const leftNumber = getLastChildWithSelector(left, 'MetricExpr.LiteralExpr.Number');\n  const rightNumber = getLastChildWithSelector(right, 'MetricExpr.LiteralExpr.Number');\n  const rightBinary = right.getChild('BinOpExpr');\n\n  if (leftNumber) {// TODO: this should be already handled in case parent is binary expression as it has to be added to parent\n    //  if query starts with a number that isn't handled now.\n  } else {\n    // If this is binary we don't really know if there is a query or just chained scalars. So\n    // we have to traverse a bit deeper to know\n    handleExpression(expr, left, context);\n  }\n\n  if (rightNumber) {\n    visQuery.operations.push(makeBinOp(opDef, expr, right, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));\n  } else if (rightBinary) {\n    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which\n    // is a factor for a current binary operation. So we have to add it as an operation now.\n    const leftMostChild = getLeftMostChild(right);\n\n    if ((leftMostChild === null || leftMostChild === void 0 ? void 0 : leftMostChild.name) === 'Number') {\n      visQuery.operations.push(makeBinOp(opDef, expr, leftMostChild, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));\n    } // If we added the first number literal as operation here we still can continue and handle the rest as the first\n    // number will be just skipped.\n\n\n    handleExpression(expr, right, context);\n  } else {\n    visQuery.binaryQueries = visQuery.binaryQueries || [];\n    const binQuery = {\n      operator: op,\n      query: {\n        labels: [],\n        operations: []\n      }\n    };\n\n    if (binModifier !== null && binModifier !== void 0 && binModifier.isMatcher) {\n      binQuery.vectorMatchesType = binModifier.matchType;\n      binQuery.vectorMatches = binModifier.matches;\n    }\n\n    visQuery.binaryQueries.push(binQuery);\n    handleExpression(expr, right, {\n      query: binQuery.query,\n      errors: context.errors\n    });\n  }\n}\n\nfunction getBinaryModifier(expr, node) {\n  if (!node) {\n    return undefined;\n  }\n\n  if (node.getChild('Bool')) {\n    return {\n      isBool: true,\n      isMatcher: false\n    };\n  } else {\n    var _matcher$getChild;\n\n    const matcher = node.getChild('OnOrIgnoring');\n\n    if (!matcher) {\n      // Not sure what this could be, maybe should be an error.\n      return undefined;\n    }\n\n    const labels = getString(expr, (_matcher$getChild = matcher.getChild('GroupingLabels')) === null || _matcher$getChild === void 0 ? void 0 : _matcher$getChild.getChild('GroupingLabelList'));\n    return {\n      isMatcher: true,\n      isBool: false,\n      matches: labels,\n      matchType: matcher.getChild('On') ? 'on' : 'ignoring'\n    };\n  }\n}\n\nfunction isIntervalVariableError(node) {\n  var _node$parent;\n\n  return (node === null || node === void 0 ? void 0 : (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name) === 'Range';\n}\n\nfunction handleQuotes(string) {\n  if (string[0] === `\"` && string[string.length - 1] === `\"`) {\n    return string.replace(/\"/g, '').replace(/\\\\\\\\/g, '\\\\');\n  }\n\n  return string.replace(/`/g, '');\n}\n/**\n * Simple helper to traverse the syntax tree. Instead of node.getChild('foo')?.getChild('bar')?.getChild('baz') you\n * can write getChildWithSelector(node, 'foo.bar.baz')\n * @param node\n * @param selector\n */\n\n\nfunction getLastChildWithSelector(node, selector) {\n  let child = node;\n  const children = selector.split('.');\n\n  for (const s of children) {\n    child = child.getChild(s);\n\n    if (!child) {\n      return null;\n    }\n  }\n\n  return child;\n}\n/**\n * Helper function to enrich error text with information that visual query builder doesn't support that logQL\n * @param expr\n * @param node\n * @param error\n */\n\n\nfunction createNotSupportedError(expr, node, error) {\n  const err = makeError(expr, node);\n  err.text = `${error}: ${err.text}`;\n  return err;\n}\n\nfunction isEmptyQuery(query) {\n  if (query.labels.length === 0 && query.operations.length === 0) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"names":["parser","ErrorName","getAllByType","getLeftMostChild","getString","makeBinOp","makeError","replaceVariables","binaryScalarDefs","buildVisualQueryFromString","expr","replacedExpr","tree","parse","node","topNode","visQuery","labels","operations","context","query","errors","handleExpression","err","console","error","Error","push","text","message","isEmptyQuery","name","getLabel","getChild","operation","getLineFilter","createNotSupportedError","getLabelParser","getLabelFilter","getLineFormat","getLabelFormat","handleUnwrapExpr","handleRangeAggregation","handleVectorAggregation","handleBinary","isIntervalVariableError","child","firstChild","nextSibling","labelNode","label","op","value","replace","ipLineFilter","length","mapFilter","filter","filterExpr","handleQuotes","id","params","parserNode","string","valueString","join","identifier","unwrapExprChild","labelFilterChild","unwrapChild","type","nameNode","funcName","number","logExpr","undefined","match","grouping","numberNode","Number","byModifier","withoutModifier","metricExpr","operatorToOpName","reduce","acc","def","sign","comparison","left","binModifier","getBinaryModifier","right","lastChild","opDef","leftNumber","getLastChildWithSelector","rightNumber","rightBinary","isBool","leftMostChild","binaryQueries","binQuery","operator","isMatcher","vectorMatchesType","matchType","vectorMatches","matches","matcher","parent","selector","children","split","s"],"sources":["/home/soula/grafana/public/app/plugins/datasource/loki/querybuilder/parsing.ts"],"sourcesContent":["import { SyntaxNode } from '@lezer/common';\n\nimport { parser } from '@grafana/lezer-logql';\n\nimport {\n  ErrorName,\n  getAllByType,\n  getLeftMostChild,\n  getString,\n  makeBinOp,\n  makeError,\n  replaceVariables,\n} from '../../prometheus/querybuilder/shared/parsingUtils';\nimport { QueryBuilderLabelFilter, QueryBuilderOperation } from '../../prometheus/querybuilder/shared/types';\n\nimport { binaryScalarDefs } from './binaryScalarOperations';\nimport { LokiVisualQuery, LokiVisualQueryBinary } from './types';\n\ninterface Context {\n  query: LokiVisualQuery;\n  errors: ParsingError[];\n}\n\ninterface ParsingError {\n  text: string;\n  from?: number;\n  to?: number;\n  parentType?: string;\n}\n\nexport function buildVisualQueryFromString(expr: string): Context {\n  const replacedExpr = replaceVariables(expr);\n  const tree = parser.parse(replacedExpr);\n  const node = tree.topNode;\n\n  // This will be modified in the handleExpression\n  const visQuery: LokiVisualQuery = {\n    labels: [],\n    operations: [],\n  };\n\n  const context: Context = {\n    query: visQuery,\n    errors: [],\n  };\n\n  try {\n    handleExpression(replacedExpr, node, context);\n  } catch (err) {\n    // Not ideal to log it here, but otherwise we would lose the stack trace.\n    console.error(err);\n    if (err instanceof Error) {\n      context.errors.push({\n        text: err.message,\n      });\n    }\n  }\n\n  // If we have empty query, we want to reset errors\n  if (isEmptyQuery(context.query)) {\n    context.errors = [];\n  }\n  return context;\n}\n\nexport function handleExpression(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n  switch (node.name) {\n    case 'Matcher': {\n      visQuery.labels.push(getLabel(expr, node));\n      const err = node.getChild(ErrorName);\n      if (err) {\n        context.errors.push(makeError(expr, err));\n      }\n      break;\n    }\n\n    case 'LineFilter': {\n      const { operation, error } = getLineFilter(expr, node);\n      if (operation) {\n        visQuery.operations.push(operation);\n      }\n      // Show error for query patterns not supported in visual query builder\n      if (error) {\n        context.errors.push(createNotSupportedError(expr, node, error));\n      }\n      break;\n    }\n\n    case 'LabelParser': {\n      visQuery.operations.push(getLabelParser(expr, node));\n      break;\n    }\n\n    case 'LabelFilter': {\n      const { operation, error } = getLabelFilter(expr, node);\n      if (operation) {\n        visQuery.operations.push(operation);\n      }\n      // Show error for query patterns not supported in visual query builder\n      if (error) {\n        context.errors.push(createNotSupportedError(expr, node, error));\n      }\n      break;\n    }\n\n    case 'JsonExpressionParser': {\n      // JsonExpressionParser is not supported in query builder\n      const error = 'JsonExpressionParser not supported in visual query builder';\n\n      context.errors.push(createNotSupportedError(expr, node, error));\n    }\n\n    case 'LineFormatExpr': {\n      visQuery.operations.push(getLineFormat(expr, node));\n      break;\n    }\n\n    case 'LabelFormatMatcher': {\n      visQuery.operations.push(getLabelFormat(expr, node));\n      break;\n    }\n\n    case 'UnwrapExpr': {\n      const { operation, error } = handleUnwrapExpr(expr, node, context);\n      if (operation) {\n        visQuery.operations.push(operation);\n      }\n      // Show error for query patterns not supported in visual query builder\n      if (error) {\n        context.errors.push(createNotSupportedError(expr, node, error));\n      }\n\n      break;\n    }\n\n    case 'RangeAggregationExpr': {\n      visQuery.operations.push(handleRangeAggregation(expr, node, context));\n      break;\n    }\n\n    case 'VectorAggregationExpr': {\n      visQuery.operations.push(handleVectorAggregation(expr, node, context));\n      break;\n    }\n\n    case 'BinOpExpr': {\n      handleBinary(expr, node, context);\n      break;\n    }\n\n    case ErrorName: {\n      if (isIntervalVariableError(node)) {\n        break;\n      }\n      context.errors.push(makeError(expr, node));\n      break;\n    }\n\n    default: {\n      // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper\n      // nodes that can be skipped.\n      // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to\n      //  detect those and report back.\n      let child = node.firstChild;\n      while (child) {\n        handleExpression(expr, child, context);\n        child = child.nextSibling;\n      }\n    }\n  }\n}\n\nfunction getLabel(expr: string, node: SyntaxNode): QueryBuilderLabelFilter {\n  const labelNode = node.getChild('Identifier');\n  const label = getString(expr, labelNode);\n  const op = getString(expr, labelNode!.nextSibling);\n  const value = getString(expr, node.getChild('String')).replace(/\"/g, '');\n\n  return {\n    label,\n    op,\n    value,\n  };\n}\n\nfunction getLineFilter(expr: string, node: SyntaxNode): { operation?: QueryBuilderOperation; error?: string } {\n  // Check for nodes not supported in visual builder and return error\n  const ipLineFilter = getAllByType(expr, node, 'Ip');\n  if (ipLineFilter.length > 0) {\n    return {\n      error: 'Matching ip addresses not supported in query builder',\n    };\n  }\n\n  const mapFilter: any = {\n    '|=': '__line_contains',\n    '!=': '__line_contains_not',\n    '|~': '__line_matches_regex',\n    '!~': '\"__line_matches_regex\"_not',\n  };\n  const filter = getString(expr, node.getChild('Filter'));\n  const filterExpr = handleQuotes(getString(expr, node.getChild('String')));\n\n  return {\n    operation: {\n      id: mapFilter[filter],\n      params: [filterExpr],\n    },\n  };\n}\n\nfunction getLabelParser(expr: string, node: SyntaxNode): QueryBuilderOperation {\n  const parserNode = node.firstChild;\n  const parser = getString(expr, parserNode);\n\n  const string = handleQuotes(getString(expr, node.getChild('String')));\n  const params = !!string ? [string] : [];\n  return {\n    id: parser,\n    params,\n  };\n}\n\nfunction getLabelFilter(expr: string, node: SyntaxNode): { operation?: QueryBuilderOperation; error?: string } {\n  // Check for nodes not supported in visual builder and return error\n  if (node.getChild('Or') || node.getChild('And') || node.getChild('Comma')) {\n    return {\n      error: 'Label filter with comma, \"and\", \"or\" not supported in query builder',\n    };\n  }\n  if (node.firstChild!.name === 'IpLabelFilter') {\n    return {\n      error: 'IpLabelFilter not supported in query builder',\n    };\n  }\n\n  const id = '__label_filter';\n  if (node.firstChild!.name === 'UnitFilter') {\n    const filter = node.firstChild!.firstChild;\n    const label = filter!.firstChild;\n    const op = label!.nextSibling;\n    const value = op!.nextSibling;\n    const valueString = handleQuotes(getString(expr, value));\n\n    return {\n      operation: {\n        id,\n        params: [getString(expr, label), getString(expr, op), valueString],\n      },\n    };\n  }\n  // In this case it is Matcher or NumberFilter\n  const filter = node.firstChild;\n  const label = filter!.firstChild;\n  const op = label!.nextSibling;\n  const value = op!.nextSibling;\n  const params = [getString(expr, label), getString(expr, op), handleQuotes(getString(expr, value))];\n\n  // Special case of pipe filtering - no errors\n  if (params.join('') === `__error__=`) {\n    return {\n      operation: {\n        id: '__label_filter_no_errors',\n        params: [],\n      },\n    };\n  }\n\n  return {\n    operation: {\n      id,\n      params,\n    },\n  };\n}\n\nfunction getLineFormat(expr: string, node: SyntaxNode): QueryBuilderOperation {\n  const id = 'line_format';\n  const string = handleQuotes(getString(expr, node.getChild('String')));\n\n  return {\n    id,\n    params: [string],\n  };\n}\n\nfunction getLabelFormat(expr: string, node: SyntaxNode): QueryBuilderOperation {\n  const id = 'label_format';\n  const identifier = node.getChild('Identifier');\n  const op = identifier!.nextSibling;\n  const value = op!.nextSibling;\n\n  let valueString = handleQuotes(getString(expr, value));\n\n  return {\n    id,\n    params: [getString(expr, identifier), valueString],\n  };\n}\n\nfunction handleUnwrapExpr(\n  expr: string,\n  node: SyntaxNode,\n  context: Context\n): { operation?: QueryBuilderOperation; error?: string } {\n  const unwrapExprChild = node.getChild('UnwrapExpr');\n  const labelFilterChild = node.getChild('LabelFilter');\n  const unwrapChild = node.getChild('Unwrap');\n\n  if (unwrapExprChild) {\n    handleExpression(expr, unwrapExprChild, context);\n  }\n\n  if (labelFilterChild) {\n    handleExpression(expr, labelFilterChild, context);\n  }\n\n  if (unwrapChild) {\n    if (unwrapChild?.nextSibling?.type.name === 'ConvOp') {\n      return {\n        error: 'Unwrap with conversion operator not supported in query builder',\n      };\n    }\n\n    return {\n      operation: {\n        id: 'unwrap',\n        params: [getString(expr, unwrapChild?.nextSibling)],\n      },\n    };\n  }\n\n  return {};\n}\nfunction handleRangeAggregation(expr: string, node: SyntaxNode, context: Context) {\n  const nameNode = node.getChild('RangeOp');\n  const funcName = getString(expr, nameNode);\n  const number = node.getChild('Number');\n  const logExpr = node.getChild('LogRangeExpr');\n  const params = number !== null && number !== undefined ? [getString(expr, number)] : [];\n\n  let match = getString(expr, node).match(/\\[(.+)\\]/);\n  if (match?.[1]) {\n    params.push(match[1]);\n  }\n\n  const op = {\n    id: funcName,\n    params,\n  };\n\n  if (logExpr) {\n    handleExpression(expr, logExpr, context);\n  }\n\n  return op;\n}\n\nfunction handleVectorAggregation(expr: string, node: SyntaxNode, context: Context) {\n  const nameNode = node.getChild('VectorOp');\n  let funcName = getString(expr, nameNode);\n\n  const grouping = node.getChild('Grouping');\n  const params = [];\n\n  const numberNode = node.getChild('Number');\n\n  if (numberNode) {\n    params.push(Number(getString(expr, numberNode)));\n  }\n\n  if (grouping) {\n    const byModifier = grouping.getChild(`By`);\n    if (byModifier && funcName) {\n      funcName = `__${funcName}_by`;\n    }\n\n    const withoutModifier = grouping.getChild(`Without`);\n    if (withoutModifier) {\n      funcName = `__${funcName}_without`;\n    }\n\n    params.push(...getAllByType(expr, grouping, 'Identifier'));\n  }\n\n  const metricExpr = node.getChild('MetricExpr');\n  const op: QueryBuilderOperation = { id: funcName, params };\n\n  if (metricExpr) {\n    handleExpression(expr, metricExpr, context);\n  }\n\n  return op;\n}\n\nconst operatorToOpName = binaryScalarDefs.reduce((acc, def) => {\n  acc[def.sign] = {\n    id: def.id,\n    comparison: def.comparison,\n  };\n  return acc;\n}, {} as Record<string, { id: string; comparison?: boolean }>);\n\n/**\n * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is\n * just operation with scalar or it creates a binaryQuery when it's 2 queries.\n * @param expr\n * @param node\n * @param context\n */\nfunction handleBinary(expr: string, node: SyntaxNode, context: Context) {\n  const visQuery = context.query;\n  const left = node.firstChild!;\n  const op = getString(expr, left.nextSibling);\n  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));\n\n  const right = node.lastChild!;\n\n  const opDef = operatorToOpName[op];\n\n  const leftNumber = getLastChildWithSelector(left, 'MetricExpr.LiteralExpr.Number');\n  const rightNumber = getLastChildWithSelector(right, 'MetricExpr.LiteralExpr.Number');\n\n  const rightBinary = right.getChild('BinOpExpr');\n\n  if (leftNumber) {\n    // TODO: this should be already handled in case parent is binary expression as it has to be added to parent\n    //  if query starts with a number that isn't handled now.\n  } else {\n    // If this is binary we don't really know if there is a query or just chained scalars. So\n    // we have to traverse a bit deeper to know\n    handleExpression(expr, left, context);\n  }\n\n  if (rightNumber) {\n    visQuery.operations.push(makeBinOp(opDef, expr, right, !!binModifier?.isBool));\n  } else if (rightBinary) {\n    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which\n    // is a factor for a current binary operation. So we have to add it as an operation now.\n    const leftMostChild = getLeftMostChild(right);\n    if (leftMostChild?.name === 'Number') {\n      visQuery.operations.push(makeBinOp(opDef, expr, leftMostChild, !!binModifier?.isBool));\n    }\n\n    // If we added the first number literal as operation here we still can continue and handle the rest as the first\n    // number will be just skipped.\n    handleExpression(expr, right, context);\n  } else {\n    visQuery.binaryQueries = visQuery.binaryQueries || [];\n    const binQuery: LokiVisualQueryBinary = {\n      operator: op,\n      query: {\n        labels: [],\n        operations: [],\n      },\n    };\n    if (binModifier?.isMatcher) {\n      binQuery.vectorMatchesType = binModifier.matchType;\n      binQuery.vectorMatches = binModifier.matches;\n    }\n    visQuery.binaryQueries.push(binQuery);\n    handleExpression(expr, right, {\n      query: binQuery.query,\n      errors: context.errors,\n    });\n  }\n}\n\nfunction getBinaryModifier(\n  expr: string,\n  node: SyntaxNode | null\n):\n  | { isBool: true; isMatcher: false }\n  | { isBool: false; isMatcher: true; matches: string; matchType: 'ignoring' | 'on' }\n  | undefined {\n  if (!node) {\n    return undefined;\n  }\n  if (node.getChild('Bool')) {\n    return { isBool: true, isMatcher: false };\n  } else {\n    const matcher = node.getChild('OnOrIgnoring');\n    if (!matcher) {\n      // Not sure what this could be, maybe should be an error.\n      return undefined;\n    }\n    const labels = getString(expr, matcher.getChild('GroupingLabels')?.getChild('GroupingLabelList'));\n    return {\n      isMatcher: true,\n      isBool: false,\n      matches: labels,\n      matchType: matcher.getChild('On') ? 'on' : 'ignoring',\n    };\n  }\n}\n\nfunction isIntervalVariableError(node: SyntaxNode) {\n  return node?.parent?.name === 'Range';\n}\n\nfunction handleQuotes(string: string) {\n  if (string[0] === `\"` && string[string.length - 1] === `\"`) {\n    return string.replace(/\"/g, '').replace(/\\\\\\\\/g, '\\\\');\n  }\n  return string.replace(/`/g, '');\n}\n\n/**\n * Simple helper to traverse the syntax tree. Instead of node.getChild('foo')?.getChild('bar')?.getChild('baz') you\n * can write getChildWithSelector(node, 'foo.bar.baz')\n * @param node\n * @param selector\n */\nfunction getLastChildWithSelector(node: SyntaxNode, selector: string) {\n  let child: SyntaxNode | null = node;\n  const children = selector.split('.');\n  for (const s of children) {\n    child = child.getChild(s);\n    if (!child) {\n      return null;\n    }\n  }\n  return child;\n}\n\n/**\n * Helper function to enrich error text with information that visual query builder doesn't support that logQL\n * @param expr\n * @param node\n * @param error\n */\nfunction createNotSupportedError(expr: string, node: SyntaxNode, error: string) {\n  const err = makeError(expr, node);\n  err.text = `${error}: ${err.text}`;\n  return err;\n}\n\nfunction isEmptyQuery(query: LokiVisualQuery) {\n  if (query.labels.length === 0 && query.operations.length === 0) {\n    return true;\n  }\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}