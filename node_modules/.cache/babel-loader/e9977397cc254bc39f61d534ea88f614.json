{"ast":null,"code":"import { ArrayVector, FieldType, getFieldDisplayName, outerJoinDataFrames } from '@grafana/data';\nimport { maybeSortFrame } from '@grafana/data/src/transformations/transformers/joinDataFrames';\nimport { findField } from 'app/features/dimensions';\nimport { prepareGraphableFields } from '../timeseries/utils';\nimport { VizDisplayMode } from './models.gen';\nexport const candlestickFieldsInfo = {\n  open: {\n    key: 'open',\n    name: 'Open',\n    defaults: ['open', 'o'],\n    description: 'Value at the start of the period'\n  },\n  high: {\n    key: 'high',\n    name: 'High',\n    defaults: ['high', 'h', 'max'],\n    description: 'Maximum value within the period'\n  },\n  low: {\n    key: 'low',\n    name: 'Low',\n    defaults: ['low', 'l', 'min'],\n    description: 'Minimum value within the period'\n  },\n  close: {\n    key: 'close',\n    name: 'Close',\n    defaults: ['close', 'c'],\n    description: 'Value at the end of the period'\n  },\n  volume: {\n    key: 'volume',\n    name: 'Volume',\n    defaults: ['volume', 'v'],\n    description: 'Sample count within the period'\n  }\n};\n\nfunction findFieldOrAuto(frame, info, options) {\n  const field = findField(frame, options[info.key]);\n\n  if (!field) {\n    for (const field of frame.fields) {\n      const name = getFieldDisplayName(field, frame).toLowerCase();\n\n      if (info.defaults.includes(name) || info.defaults.includes(field.name)) {\n        return field;\n      }\n    }\n  }\n\n  return field;\n}\n\nexport function prepareCandlestickFields(series, options, theme, timeRange) {\n  var _options$fields;\n\n  if (!(series !== null && series !== void 0 && series.length)) {\n    return null;\n  } // All fields\n\n\n  const fieldMap = (_options$fields = options.fields) !== null && _options$fields !== void 0 ? _options$fields : {};\n  const aligned = series.length === 1 ? maybeSortFrame(series[0], series[0].fields.findIndex(f => f.type === FieldType.time)) : outerJoinDataFrames({\n    frames: series\n  });\n\n  if (!(aligned !== null && aligned !== void 0 && aligned.length)) {\n    return null;\n  }\n\n  const data = {\n    aligned,\n    frame: aligned,\n    names: {}\n  }; // Apply same filter as everythign else in timeseries\n\n  const timeSeriesFrames = prepareGraphableFields([aligned], theme, timeRange);\n\n  if (!timeSeriesFrames) {\n    return null;\n  }\n\n  const frame = data.frame = timeSeriesFrames[0];\n  const timeIndex = frame.fields.findIndex(f => f.type === FieldType.time);\n\n  if (timeIndex < 0) {\n    return null;\n  } // Find the known fields\n\n\n  const used = new Set();\n\n  for (const info of Object.values(candlestickFieldsInfo)) {\n    const field = findFieldOrAuto(frame, info, fieldMap);\n\n    if (field) {\n      data[info.key] = field;\n      used.add(field);\n    }\n  } // Use first numeric value as open\n\n\n  if (!data.open && !data.close) {\n    data.open = frame.fields.find(f => f.type === FieldType.number);\n\n    if (data.open) {\n      used.add(data.open);\n    }\n  } // Use next open as 'close' value\n\n\n  if (data.open && !data.close && !fieldMap.close) {\n    const values = data.open.values.toArray().slice(1);\n    values.push(values[values.length - 1]); // duplicate last value\n\n    data.close = Object.assign({}, data.open, {\n      values: new ArrayVector(values),\n      name: 'Next open',\n      state: undefined\n    });\n    used.add(data.close);\n    frame.fields.push(data.close);\n    data.autoOpenClose = true;\n  } // Use previous close as 'open' value\n\n\n  if (data.close && !data.open && !fieldMap.open) {\n    const values = data.close.values.toArray().slice();\n    values.unshift(values[0]); // duplicate first value\n\n    values.length = frame.length;\n    data.open = Object.assign({}, data.close, {\n      values: new ArrayVector(values),\n      name: 'Previous close',\n      state: undefined\n    });\n    used.add(data.open);\n    frame.fields.push(data.open);\n    data.autoOpenClose = true;\n  } // Use the open field for min/max if nothing is set\n\n\n  if (!data.high && !fieldMap.high) {\n    data.high = data.open;\n  }\n\n  if (!data.low && !fieldMap.low) {\n    data.low = data.open;\n  } // unmap low and high fields in volume-only mode, and volume field in candles-only mode\n  // so they fall through to unmapped fields and get appropriate includeAllFields treatment\n\n\n  if (options.mode === VizDisplayMode.Volume) {\n    if (data.high) {\n      if (data.high !== data.open) {\n        used.delete(data.high);\n      }\n\n      data.high = undefined;\n    }\n\n    if (data.low) {\n      if (data.low !== data.open) {\n        used.delete(data.low);\n      }\n\n      data.low = undefined;\n    }\n  } else if (options.mode === VizDisplayMode.Candles) {\n    if (data.volume) {\n      used.delete(data.volume);\n      data.volume = undefined;\n    }\n  } // Register the name of each mapped field\n\n\n  for (const info of Object.values(candlestickFieldsInfo)) {\n    const f = data[info.key];\n\n    if (f) {\n      data.names[info.key] = getFieldDisplayName(f, data.frame);\n    }\n  }\n\n  const timeField = frame.fields[timeIndex]; // Make sure first field is time!\n\n  const fields = [timeField];\n\n  if (!options.includeAllFields) {\n    fields.push(...used);\n  } else {\n    fields.push(...frame.fields.filter(f => f !== timeField));\n  }\n\n  data.frame = Object.assign({}, data.frame, {\n    fields\n  }); // Force update all the indicies\n\n  for (let i = 0; i < data.frame.fields.length; i++) {\n    const field = data.frame.fields[i];\n    field.state = Object.assign({}, field.state, {\n      // time is unused (-1), y series enumerate from 0\n      seriesIndex: i - 1,\n      origin: {\n        fieldIndex: i,\n        frameIndex: 0\n      }\n    });\n  }\n\n  return data;\n}","map":{"version":3,"names":["ArrayVector","FieldType","getFieldDisplayName","outerJoinDataFrames","maybeSortFrame","findField","prepareGraphableFields","VizDisplayMode","candlestickFieldsInfo","open","key","name","defaults","description","high","low","close","volume","findFieldOrAuto","frame","info","options","field","fields","toLowerCase","includes","prepareCandlestickFields","series","theme","timeRange","length","fieldMap","aligned","findIndex","f","type","time","frames","data","names","timeSeriesFrames","timeIndex","used","Set","Object","values","add","find","number","toArray","slice","push","state","undefined","autoOpenClose","unshift","mode","Volume","delete","Candles","timeField","includeAllFields","filter","i","seriesIndex","origin","fieldIndex","frameIndex"],"sources":["/home/soula/grafana/public/app/plugins/panel/candlestick/fields.ts"],"sourcesContent":["import {\n  ArrayVector,\n  DataFrame,\n  Field,\n  FieldType,\n  getFieldDisplayName,\n  GrafanaTheme2,\n  outerJoinDataFrames,\n  TimeRange,\n} from '@grafana/data';\nimport { maybeSortFrame } from '@grafana/data/src/transformations/transformers/joinDataFrames';\nimport { findField } from 'app/features/dimensions';\n\nimport { prepareGraphableFields } from '../timeseries/utils';\n\nimport { CandlestickOptions, CandlestickFieldMap, VizDisplayMode } from './models.gen';\n\nexport interface FieldPickerInfo {\n  /** property name */\n  key: keyof CandlestickFieldMap;\n\n  /** The display name */\n  name: string;\n\n  /** by default pick these fields */\n  defaults: string[];\n\n  /** How is the field used */\n  description: string;\n}\n\nexport const candlestickFieldsInfo: Record<keyof CandlestickFieldMap, FieldPickerInfo> = {\n  open: {\n    key: 'open',\n    name: 'Open',\n    defaults: ['open', 'o'],\n    description: 'Value at the start of the period',\n  },\n  high: {\n    key: 'high',\n    name: 'High',\n    defaults: ['high', 'h', 'max'],\n    description: 'Maximum value within the period',\n  },\n  low: {\n    key: 'low',\n    name: 'Low',\n    defaults: ['low', 'l', 'min'],\n    description: 'Minimum value within the period',\n  },\n  close: {\n    key: 'close',\n    name: 'Close',\n    defaults: ['close', 'c'],\n    description: 'Value at the end of the period',\n  },\n  volume: {\n    key: 'volume',\n    name: 'Volume',\n    defaults: ['volume', 'v'],\n    description: 'Sample count within the period',\n  },\n};\n\nexport interface CandlestickData {\n  autoOpenClose?: boolean;\n\n  // Special fields\n  open?: Field;\n  high?: Field;\n  low?: Field;\n  close?: Field;\n  volume?: Field;\n\n  // All incoming values\n  aligned: DataFrame;\n\n  // The stuff passed to GraphNG\n  frame: DataFrame;\n\n  // The real names used\n  names: CandlestickFieldMap;\n}\n\nfunction findFieldOrAuto(frame: DataFrame, info: FieldPickerInfo, options: CandlestickFieldMap): Field | undefined {\n  const field = findField(frame, options[info.key]);\n  if (!field) {\n    for (const field of frame.fields) {\n      const name = getFieldDisplayName(field, frame).toLowerCase();\n      if (info.defaults.includes(name) || info.defaults.includes(field.name)) {\n        return field;\n      }\n    }\n  }\n  return field;\n}\n\nexport function prepareCandlestickFields(\n  series: DataFrame[] | undefined,\n  options: CandlestickOptions,\n  theme: GrafanaTheme2,\n  timeRange?: TimeRange\n): CandlestickData | null {\n  if (!series?.length) {\n    return null;\n  }\n\n  // All fields\n  const fieldMap = options.fields ?? {};\n  const aligned =\n    series.length === 1\n      ? maybeSortFrame(\n          series[0],\n          series[0].fields.findIndex((f) => f.type === FieldType.time)\n        )\n      : outerJoinDataFrames({ frames: series });\n  if (!aligned?.length) {\n    return null;\n  }\n\n  const data: CandlestickData = { aligned, frame: aligned, names: {} };\n\n  // Apply same filter as everythign else in timeseries\n  const timeSeriesFrames = prepareGraphableFields([aligned], theme, timeRange);\n  if (!timeSeriesFrames) {\n    return null;\n  }\n\n  const frame = (data.frame = timeSeriesFrames[0]);\n  const timeIndex = frame.fields.findIndex((f) => f.type === FieldType.time);\n\n  if (timeIndex < 0) {\n    return null;\n  }\n\n  // Find the known fields\n  const used = new Set<Field>();\n  for (const info of Object.values(candlestickFieldsInfo)) {\n    const field = findFieldOrAuto(frame, info, fieldMap);\n    if (field) {\n      data[info.key] = field;\n      used.add(field);\n    }\n  }\n\n  // Use first numeric value as open\n  if (!data.open && !data.close) {\n    data.open = frame.fields.find((f) => f.type === FieldType.number);\n    if (data.open) {\n      used.add(data.open);\n    }\n  }\n\n  // Use next open as 'close' value\n  if (data.open && !data.close && !fieldMap.close) {\n    const values = data.open.values.toArray().slice(1);\n    values.push(values[values.length - 1]); // duplicate last value\n    data.close = {\n      ...data.open,\n      values: new ArrayVector(values),\n      name: 'Next open',\n      state: undefined,\n    };\n    used.add(data.close);\n    frame.fields.push(data.close);\n    data.autoOpenClose = true;\n  }\n\n  // Use previous close as 'open' value\n  if (data.close && !data.open && !fieldMap.open) {\n    const values = data.close.values.toArray().slice();\n    values.unshift(values[0]); // duplicate first value\n    values.length = frame.length;\n    data.open = {\n      ...data.close,\n      values: new ArrayVector(values),\n      name: 'Previous close',\n      state: undefined,\n    };\n    used.add(data.open);\n    frame.fields.push(data.open);\n    data.autoOpenClose = true;\n  }\n\n  // Use the open field for min/max if nothing is set\n  if (!data.high && !fieldMap.high) {\n    data.high = data.open;\n  }\n  if (!data.low && !fieldMap.low) {\n    data.low = data.open;\n  }\n\n  // unmap low and high fields in volume-only mode, and volume field in candles-only mode\n  // so they fall through to unmapped fields and get appropriate includeAllFields treatment\n  if (options.mode === VizDisplayMode.Volume) {\n    if (data.high) {\n      if (data.high !== data.open) {\n        used.delete(data.high);\n      }\n      data.high = undefined;\n    }\n    if (data.low) {\n      if (data.low !== data.open) {\n        used.delete(data.low);\n      }\n      data.low = undefined;\n    }\n  } else if (options.mode === VizDisplayMode.Candles) {\n    if (data.volume) {\n      used.delete(data.volume);\n      data.volume = undefined;\n    }\n  }\n\n  // Register the name of each mapped field\n  for (const info of Object.values(candlestickFieldsInfo)) {\n    const f = data[info.key];\n    if (f) {\n      data.names[info.key] = getFieldDisplayName(f, data.frame);\n    }\n  }\n\n  const timeField = frame.fields[timeIndex];\n\n  // Make sure first field is time!\n  const fields: Field[] = [timeField];\n\n  if (!options.includeAllFields) {\n    fields.push(...used);\n  } else {\n    fields.push(...frame.fields.filter((f) => f !== timeField));\n  }\n\n  data.frame = {\n    ...data.frame,\n    fields,\n  };\n\n  // Force update all the indicies\n  for (let i = 0; i < data.frame.fields.length; i++) {\n    const field = data.frame.fields[i];\n\n    field.state = {\n      ...field.state,\n\n      // time is unused (-1), y series enumerate from 0\n      seriesIndex: i - 1,\n\n      origin: {\n        fieldIndex: i,\n        frameIndex: 0,\n      },\n    };\n  }\n\n  return data;\n}\n"],"mappings":"AAAA,SACEA,WADF,EAIEC,SAJF,EAKEC,mBALF,EAOEC,mBAPF,QASO,eATP;AAUA,SAASC,cAAT,QAA+B,+DAA/B;AACA,SAASC,SAAT,QAA0B,yBAA1B;AAEA,SAASC,sBAAT,QAAuC,qBAAvC;AAEA,SAAkDC,cAAlD,QAAwE,cAAxE;AAgBA,OAAO,MAAMC,qBAAyE,GAAG;EACvFC,IAAI,EAAE;IACJC,GAAG,EAAE,MADD;IAEJC,IAAI,EAAE,MAFF;IAGJC,QAAQ,EAAE,CAAC,MAAD,EAAS,GAAT,CAHN;IAIJC,WAAW,EAAE;EAJT,CADiF;EAOvFC,IAAI,EAAE;IACJJ,GAAG,EAAE,MADD;IAEJC,IAAI,EAAE,MAFF;IAGJC,QAAQ,EAAE,CAAC,MAAD,EAAS,GAAT,EAAc,KAAd,CAHN;IAIJC,WAAW,EAAE;EAJT,CAPiF;EAavFE,GAAG,EAAE;IACHL,GAAG,EAAE,KADF;IAEHC,IAAI,EAAE,KAFH;IAGHC,QAAQ,EAAE,CAAC,KAAD,EAAQ,GAAR,EAAa,KAAb,CAHP;IAIHC,WAAW,EAAE;EAJV,CAbkF;EAmBvFG,KAAK,EAAE;IACLN,GAAG,EAAE,OADA;IAELC,IAAI,EAAE,OAFD;IAGLC,QAAQ,EAAE,CAAC,OAAD,EAAU,GAAV,CAHL;IAILC,WAAW,EAAE;EAJR,CAnBgF;EAyBvFI,MAAM,EAAE;IACNP,GAAG,EAAE,QADC;IAENC,IAAI,EAAE,QAFA;IAGNC,QAAQ,EAAE,CAAC,QAAD,EAAW,GAAX,CAHJ;IAINC,WAAW,EAAE;EAJP;AAzB+E,CAAlF;;AAqDP,SAASK,eAAT,CAAyBC,KAAzB,EAA2CC,IAA3C,EAAkEC,OAAlE,EAAmH;EACjH,MAAMC,KAAK,GAAGjB,SAAS,CAACc,KAAD,EAAQE,OAAO,CAACD,IAAI,CAACV,GAAN,CAAf,CAAvB;;EACA,IAAI,CAACY,KAAL,EAAY;IACV,KAAK,MAAMA,KAAX,IAAoBH,KAAK,CAACI,MAA1B,EAAkC;MAChC,MAAMZ,IAAI,GAAGT,mBAAmB,CAACoB,KAAD,EAAQH,KAAR,CAAnB,CAAkCK,WAAlC,EAAb;;MACA,IAAIJ,IAAI,CAACR,QAAL,CAAca,QAAd,CAAuBd,IAAvB,KAAgCS,IAAI,CAACR,QAAL,CAAca,QAAd,CAAuBH,KAAK,CAACX,IAA7B,CAApC,EAAwE;QACtE,OAAOW,KAAP;MACD;IACF;EACF;;EACD,OAAOA,KAAP;AACD;;AAED,OAAO,SAASI,wBAAT,CACLC,MADK,EAELN,OAFK,EAGLO,KAHK,EAILC,SAJK,EAKmB;EAAA;;EACxB,IAAI,EAACF,MAAD,aAACA,MAAD,eAACA,MAAM,CAAEG,MAAT,CAAJ,EAAqB;IACnB,OAAO,IAAP;EACD,CAHuB,CAKxB;;;EACA,MAAMC,QAAQ,sBAAGV,OAAO,CAACE,MAAX,6DAAqB,EAAnC;EACA,MAAMS,OAAO,GACXL,MAAM,CAACG,MAAP,KAAkB,CAAlB,GACI1B,cAAc,CACZuB,MAAM,CAAC,CAAD,CADM,EAEZA,MAAM,CAAC,CAAD,CAAN,CAAUJ,MAAV,CAAiBU,SAAjB,CAA4BC,CAAD,IAAOA,CAAC,CAACC,IAAF,KAAWlC,SAAS,CAACmC,IAAvD,CAFY,CADlB,GAKIjC,mBAAmB,CAAC;IAAEkC,MAAM,EAAEV;EAAV,CAAD,CANzB;;EAOA,IAAI,EAACK,OAAD,aAACA,OAAD,eAACA,OAAO,CAAEF,MAAV,CAAJ,EAAsB;IACpB,OAAO,IAAP;EACD;;EAED,MAAMQ,IAAqB,GAAG;IAAEN,OAAF;IAAWb,KAAK,EAAEa,OAAlB;IAA2BO,KAAK,EAAE;EAAlC,CAA9B,CAlBwB,CAoBxB;;EACA,MAAMC,gBAAgB,GAAGlC,sBAAsB,CAAC,CAAC0B,OAAD,CAAD,EAAYJ,KAAZ,EAAmBC,SAAnB,CAA/C;;EACA,IAAI,CAACW,gBAAL,EAAuB;IACrB,OAAO,IAAP;EACD;;EAED,MAAMrB,KAAK,GAAImB,IAAI,CAACnB,KAAL,GAAaqB,gBAAgB,CAAC,CAAD,CAA5C;EACA,MAAMC,SAAS,GAAGtB,KAAK,CAACI,MAAN,CAAaU,SAAb,CAAwBC,CAAD,IAAOA,CAAC,CAACC,IAAF,KAAWlC,SAAS,CAACmC,IAAnD,CAAlB;;EAEA,IAAIK,SAAS,GAAG,CAAhB,EAAmB;IACjB,OAAO,IAAP;EACD,CA/BuB,CAiCxB;;;EACA,MAAMC,IAAI,GAAG,IAAIC,GAAJ,EAAb;;EACA,KAAK,MAAMvB,IAAX,IAAmBwB,MAAM,CAACC,MAAP,CAAcrC,qBAAd,CAAnB,EAAyD;IACvD,MAAMc,KAAK,GAAGJ,eAAe,CAACC,KAAD,EAAQC,IAAR,EAAcW,QAAd,CAA7B;;IACA,IAAIT,KAAJ,EAAW;MACTgB,IAAI,CAAClB,IAAI,CAACV,GAAN,CAAJ,GAAiBY,KAAjB;MACAoB,IAAI,CAACI,GAAL,CAASxB,KAAT;IACD;EACF,CAzCuB,CA2CxB;;;EACA,IAAI,CAACgB,IAAI,CAAC7B,IAAN,IAAc,CAAC6B,IAAI,CAACtB,KAAxB,EAA+B;IAC7BsB,IAAI,CAAC7B,IAAL,GAAYU,KAAK,CAACI,MAAN,CAAawB,IAAb,CAAmBb,CAAD,IAAOA,CAAC,CAACC,IAAF,KAAWlC,SAAS,CAAC+C,MAA9C,CAAZ;;IACA,IAAIV,IAAI,CAAC7B,IAAT,EAAe;MACbiC,IAAI,CAACI,GAAL,CAASR,IAAI,CAAC7B,IAAd;IACD;EACF,CAjDuB,CAmDxB;;;EACA,IAAI6B,IAAI,CAAC7B,IAAL,IAAa,CAAC6B,IAAI,CAACtB,KAAnB,IAA4B,CAACe,QAAQ,CAACf,KAA1C,EAAiD;IAC/C,MAAM6B,MAAM,GAAGP,IAAI,CAAC7B,IAAL,CAAUoC,MAAV,CAAiBI,OAAjB,GAA2BC,KAA3B,CAAiC,CAAjC,CAAf;IACAL,MAAM,CAACM,IAAP,CAAYN,MAAM,CAACA,MAAM,CAACf,MAAP,GAAgB,CAAjB,CAAlB,EAF+C,CAEP;;IACxCQ,IAAI,CAACtB,KAAL,qBACKsB,IAAI,CAAC7B,IADV;MAEEoC,MAAM,EAAE,IAAI7C,WAAJ,CAAgB6C,MAAhB,CAFV;MAGElC,IAAI,EAAE,WAHR;MAIEyC,KAAK,EAAEC;IAJT;IAMAX,IAAI,CAACI,GAAL,CAASR,IAAI,CAACtB,KAAd;IACAG,KAAK,CAACI,MAAN,CAAa4B,IAAb,CAAkBb,IAAI,CAACtB,KAAvB;IACAsB,IAAI,CAACgB,aAAL,GAAqB,IAArB;EACD,CAhEuB,CAkExB;;;EACA,IAAIhB,IAAI,CAACtB,KAAL,IAAc,CAACsB,IAAI,CAAC7B,IAApB,IAA4B,CAACsB,QAAQ,CAACtB,IAA1C,EAAgD;IAC9C,MAAMoC,MAAM,GAAGP,IAAI,CAACtB,KAAL,CAAW6B,MAAX,CAAkBI,OAAlB,GAA4BC,KAA5B,EAAf;IACAL,MAAM,CAACU,OAAP,CAAeV,MAAM,CAAC,CAAD,CAArB,EAF8C,CAEnB;;IAC3BA,MAAM,CAACf,MAAP,GAAgBX,KAAK,CAACW,MAAtB;IACAQ,IAAI,CAAC7B,IAAL,qBACK6B,IAAI,CAACtB,KADV;MAEE6B,MAAM,EAAE,IAAI7C,WAAJ,CAAgB6C,MAAhB,CAFV;MAGElC,IAAI,EAAE,gBAHR;MAIEyC,KAAK,EAAEC;IAJT;IAMAX,IAAI,CAACI,GAAL,CAASR,IAAI,CAAC7B,IAAd;IACAU,KAAK,CAACI,MAAN,CAAa4B,IAAb,CAAkBb,IAAI,CAAC7B,IAAvB;IACA6B,IAAI,CAACgB,aAAL,GAAqB,IAArB;EACD,CAhFuB,CAkFxB;;;EACA,IAAI,CAAChB,IAAI,CAACxB,IAAN,IAAc,CAACiB,QAAQ,CAACjB,IAA5B,EAAkC;IAChCwB,IAAI,CAACxB,IAAL,GAAYwB,IAAI,CAAC7B,IAAjB;EACD;;EACD,IAAI,CAAC6B,IAAI,CAACvB,GAAN,IAAa,CAACgB,QAAQ,CAAChB,GAA3B,EAAgC;IAC9BuB,IAAI,CAACvB,GAAL,GAAWuB,IAAI,CAAC7B,IAAhB;EACD,CAxFuB,CA0FxB;EACA;;;EACA,IAAIY,OAAO,CAACmC,IAAR,KAAiBjD,cAAc,CAACkD,MAApC,EAA4C;IAC1C,IAAInB,IAAI,CAACxB,IAAT,EAAe;MACb,IAAIwB,IAAI,CAACxB,IAAL,KAAcwB,IAAI,CAAC7B,IAAvB,EAA6B;QAC3BiC,IAAI,CAACgB,MAAL,CAAYpB,IAAI,CAACxB,IAAjB;MACD;;MACDwB,IAAI,CAACxB,IAAL,GAAYuC,SAAZ;IACD;;IACD,IAAIf,IAAI,CAACvB,GAAT,EAAc;MACZ,IAAIuB,IAAI,CAACvB,GAAL,KAAauB,IAAI,CAAC7B,IAAtB,EAA4B;QAC1BiC,IAAI,CAACgB,MAAL,CAAYpB,IAAI,CAACvB,GAAjB;MACD;;MACDuB,IAAI,CAACvB,GAAL,GAAWsC,SAAX;IACD;EACF,CAbD,MAaO,IAAIhC,OAAO,CAACmC,IAAR,KAAiBjD,cAAc,CAACoD,OAApC,EAA6C;IAClD,IAAIrB,IAAI,CAACrB,MAAT,EAAiB;MACfyB,IAAI,CAACgB,MAAL,CAAYpB,IAAI,CAACrB,MAAjB;MACAqB,IAAI,CAACrB,MAAL,GAAcoC,SAAd;IACD;EACF,CA9GuB,CAgHxB;;;EACA,KAAK,MAAMjC,IAAX,IAAmBwB,MAAM,CAACC,MAAP,CAAcrC,qBAAd,CAAnB,EAAyD;IACvD,MAAM0B,CAAC,GAAGI,IAAI,CAAClB,IAAI,CAACV,GAAN,CAAd;;IACA,IAAIwB,CAAJ,EAAO;MACLI,IAAI,CAACC,KAAL,CAAWnB,IAAI,CAACV,GAAhB,IAAuBR,mBAAmB,CAACgC,CAAD,EAAII,IAAI,CAACnB,KAAT,CAA1C;IACD;EACF;;EAED,MAAMyC,SAAS,GAAGzC,KAAK,CAACI,MAAN,CAAakB,SAAb,CAAlB,CAxHwB,CA0HxB;;EACA,MAAMlB,MAAe,GAAG,CAACqC,SAAD,CAAxB;;EAEA,IAAI,CAACvC,OAAO,CAACwC,gBAAb,EAA+B;IAC7BtC,MAAM,CAAC4B,IAAP,CAAY,GAAGT,IAAf;EACD,CAFD,MAEO;IACLnB,MAAM,CAAC4B,IAAP,CAAY,GAAGhC,KAAK,CAACI,MAAN,CAAauC,MAAb,CAAqB5B,CAAD,IAAOA,CAAC,KAAK0B,SAAjC,CAAf;EACD;;EAEDtB,IAAI,CAACnB,KAAL,qBACKmB,IAAI,CAACnB,KADV;IAEEI;EAFF,GAnIwB,CAwIxB;;EACA,KAAK,IAAIwC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzB,IAAI,CAACnB,KAAL,CAAWI,MAAX,CAAkBO,MAAtC,EAA8CiC,CAAC,EAA/C,EAAmD;IACjD,MAAMzC,KAAK,GAAGgB,IAAI,CAACnB,KAAL,CAAWI,MAAX,CAAkBwC,CAAlB,CAAd;IAEAzC,KAAK,CAAC8B,KAAN,qBACK9B,KAAK,CAAC8B,KADX;MAGE;MACAY,WAAW,EAAED,CAAC,GAAG,CAJnB;MAMEE,MAAM,EAAE;QACNC,UAAU,EAAEH,CADN;QAENI,UAAU,EAAE;MAFN;IANV;EAWD;;EAED,OAAO7B,IAAP;AACD"},"metadata":{},"sourceType":"module"}