{"ast":null,"code":"// This is used for error type for some reason\nexport const ErrorName = '⚠';\nexport function getLeftMostChild(cur) {\n  return cur.firstChild ? getLeftMostChild(cur.firstChild) : cur;\n}\nexport function makeError(expr, node) {\n  var _node$parent;\n\n  return {\n    text: getString(expr, node),\n    // TODO: this are positions in the string with the replaced variables. Means it cannot be used to show exact\n    //  placement of the error for the user. We need some translation table to positions before the variable\n    //  replace.\n    from: node.from,\n    to: node.to,\n    parentType: (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name\n  };\n} // Taken from template_srv, but copied so to not mess with the regex.index which is manipulated in the service\n\n/*\n * This regex matches 3 types of variable reference with an optional format specifier\n * \\$(\\w+)                          $var1\n * \\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]    [[var2]] or [[var2:fmt2]]\n * \\${(\\w+)(?::(\\w+))?}             ${var3} or ${var3:fmt3}\n */\n\nconst variableRegex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]|\\${(\\w+)(?:\\.([^:^\\}]+))?(?::([^\\}]+))?}/g;\n/**\n * As variables with $ are creating parsing errors, we first replace them with magic string that is parsable and at\n * the same time we can get the variable and it's format back from it.\n * @param expr\n */\n\nexport function replaceVariables(expr) {\n  return expr.replace(variableRegex, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {\n    const fmt = fmt2 || fmt3;\n    let variable = var1;\n    let varType = '0';\n\n    if (var2) {\n      variable = var2;\n      varType = '1';\n    }\n\n    if (var3) {\n      variable = var3;\n      varType = '2';\n    }\n\n    return `__V_${varType}__` + variable + '__V__' + (fmt ? '__F__' + fmt + '__F__' : '');\n  });\n}\nconst varTypeFunc = [(v, f) => `\\$${v}`, (v, f) => `[[${v}${f ? `:${f}` : ''}]]`, (v, f) => `\\$\\{${v}${f ? `:${f}` : ''}\\}`];\n/**\n * Get back the text with variables in their original format.\n * @param expr\n */\n\nfunction returnVariables(expr) {\n  return expr.replace(/__V_(\\d)__(.+?)__V__(?:__F__(\\w+)__F__)?/g, (match, type, v, f) => {\n    return varTypeFunc[parseInt(type, 10)](v, f);\n  });\n}\n/**\n * Get the actual string of the expression. That is not stored in the tree so we have to get the indexes from the node\n * and then based on that get it from the expression.\n * @param expr\n * @param node\n */\n\n\nexport function getString(expr, node) {\n  if (!node) {\n    return '';\n  }\n\n  return returnVariables(expr.substring(node.from, node.to));\n}\n/**\n * Create simple scalar binary op object.\n * @param opDef - definition of the op to be created\n * @param expr\n * @param numberNode - the node for the scalar\n * @param hasBool - whether operation has a bool modifier. Is used only for ops for which it makes sense.\n */\n\nexport function makeBinOp(opDef, expr, numberNode, hasBool) {\n  const params = [parseFloat(getString(expr, numberNode))];\n\n  if (opDef.comparison) {\n    params.push(hasBool);\n  }\n\n  return {\n    id: opDef.id,\n    params\n  };\n}\n/**\n * Get all nodes with type in the tree. This traverses the tree so it is safe only when you know there shouldn't be\n * too much nesting but you just want to skip some of the wrappers. For example getting function args this way would\n * not be safe is it would also find arguments of nested functions.\n * @param expr\n * @param cur\n * @param type\n */\n\nexport function getAllByType(expr, cur, type) {\n  if (cur.name === type) {\n    return [getString(expr, cur)];\n  }\n\n  const values = [];\n  let pos = 0;\n  let child = cur.childAfter(pos);\n\n  while (child) {\n    values.push(...getAllByType(expr, child, type));\n    pos = child.to;\n    child = cur.childAfter(pos);\n  }\n\n  return values;\n} // Debugging function for convenience. Gives you nice output similar to linux tree util.\n// @ts-ignore\n\nexport function log(expr, cur) {\n  if (!cur) {\n    console.log('<empty>');\n    return;\n  }\n\n  const json = toJson(expr, cur);\n  const text = jsonToText(json);\n\n  if (!text) {\n    console.log('<empty>');\n    return;\n  }\n\n  console.log(text);\n}\n\nfunction toJson(expr, cur) {\n  const treeJson = {};\n  const name = nodeToString(expr, cur);\n  const children = [];\n  let pos = 0;\n  let child = cur.childAfter(pos);\n\n  while (child) {\n    children.push(toJson(expr, child));\n    pos = child.to;\n    child = cur.childAfter(pos);\n  }\n\n  treeJson.name = name;\n  treeJson.children = children;\n  return treeJson;\n}\n\nfunction jsonToText(node, context = {\n  lastChild: true,\n  indent: ''\n}) {\n  const name = node.name;\n  const {\n    lastChild,\n    indent\n  } = context;\n  const newIndent = indent !== '' ? indent + (lastChild ? '└─' : '├─') : '';\n  let text = newIndent + name;\n  const children = node.children;\n  children.forEach((child, index) => {\n    const isLastChild = index === children.length - 1;\n    text += '\\n' + jsonToText(child, {\n      lastChild: isLastChild,\n      indent: indent + (lastChild ? '  ' : '│ ')\n    });\n  });\n  return text;\n}\n\nfunction nodeToString(expr, node) {\n  return node.name + ': ' + getString(expr, node);\n}","map":{"version":3,"names":["ErrorName","getLeftMostChild","cur","firstChild","makeError","expr","node","text","getString","from","to","parentType","parent","name","variableRegex","replaceVariables","replace","match","var1","var2","fmt2","var3","fieldPath","fmt3","fmt","variable","varType","varTypeFunc","v","f","returnVariables","type","parseInt","substring","makeBinOp","opDef","numberNode","hasBool","params","parseFloat","comparison","push","id","getAllByType","values","pos","child","childAfter","log","console","json","toJson","jsonToText","treeJson","nodeToString","children","context","lastChild","indent","newIndent","forEach","index","isLastChild","length"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts"],"sourcesContent":["import { SyntaxNode, TreeCursor } from '@lezer/common';\n\nimport { QueryBuilderOperation } from './types';\n\n// This is used for error type for some reason\nexport const ErrorName = '⚠';\n\nexport function getLeftMostChild(cur: SyntaxNode): SyntaxNode {\n  return cur.firstChild ? getLeftMostChild(cur.firstChild) : cur;\n}\n\nexport function makeError(expr: string, node: SyntaxNode) {\n  return {\n    text: getString(expr, node),\n    // TODO: this are positions in the string with the replaced variables. Means it cannot be used to show exact\n    //  placement of the error for the user. We need some translation table to positions before the variable\n    //  replace.\n    from: node.from,\n    to: node.to,\n    parentType: node.parent?.name,\n  };\n}\n\n// Taken from template_srv, but copied so to not mess with the regex.index which is manipulated in the service\n/*\n * This regex matches 3 types of variable reference with an optional format specifier\n * \\$(\\w+)                          $var1\n * \\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]    [[var2]] or [[var2:fmt2]]\n * \\${(\\w+)(?::(\\w+))?}             ${var3} or ${var3:fmt3}\n */\nconst variableRegex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]|\\${(\\w+)(?:\\.([^:^\\}]+))?(?::([^\\}]+))?}/g;\n\n/**\n * As variables with $ are creating parsing errors, we first replace them with magic string that is parsable and at\n * the same time we can get the variable and it's format back from it.\n * @param expr\n */\nexport function replaceVariables(expr: string) {\n  return expr.replace(variableRegex, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {\n    const fmt = fmt2 || fmt3;\n    let variable = var1;\n    let varType = '0';\n\n    if (var2) {\n      variable = var2;\n      varType = '1';\n    }\n\n    if (var3) {\n      variable = var3;\n      varType = '2';\n    }\n\n    return `__V_${varType}__` + variable + '__V__' + (fmt ? '__F__' + fmt + '__F__' : '');\n  });\n}\n\nconst varTypeFunc = [\n  (v: string, f?: string) => `\\$${v}`,\n  (v: string, f?: string) => `[[${v}${f ? `:${f}` : ''}]]`,\n  (v: string, f?: string) => `\\$\\{${v}${f ? `:${f}` : ''}\\}`,\n];\n\n/**\n * Get back the text with variables in their original format.\n * @param expr\n */\nfunction returnVariables(expr: string) {\n  return expr.replace(/__V_(\\d)__(.+?)__V__(?:__F__(\\w+)__F__)?/g, (match, type, v, f) => {\n    return varTypeFunc[parseInt(type, 10)](v, f);\n  });\n}\n\n/**\n * Get the actual string of the expression. That is not stored in the tree so we have to get the indexes from the node\n * and then based on that get it from the expression.\n * @param expr\n * @param node\n */\nexport function getString(expr: string, node: SyntaxNode | TreeCursor | null | undefined) {\n  if (!node) {\n    return '';\n  }\n  return returnVariables(expr.substring(node.from, node.to));\n}\n\n/**\n * Create simple scalar binary op object.\n * @param opDef - definition of the op to be created\n * @param expr\n * @param numberNode - the node for the scalar\n * @param hasBool - whether operation has a bool modifier. Is used only for ops for which it makes sense.\n */\nexport function makeBinOp(\n  opDef: { id: string; comparison?: boolean },\n  expr: string,\n  numberNode: SyntaxNode,\n  hasBool: boolean\n): QueryBuilderOperation {\n  const params: any[] = [parseFloat(getString(expr, numberNode))];\n  if (opDef.comparison) {\n    params.push(hasBool);\n  }\n  return {\n    id: opDef.id,\n    params,\n  };\n}\n\n/**\n * Get all nodes with type in the tree. This traverses the tree so it is safe only when you know there shouldn't be\n * too much nesting but you just want to skip some of the wrappers. For example getting function args this way would\n * not be safe is it would also find arguments of nested functions.\n * @param expr\n * @param cur\n * @param type\n */\nexport function getAllByType(expr: string, cur: SyntaxNode, type: string): string[] {\n  if (cur.name === type) {\n    return [getString(expr, cur)];\n  }\n  const values: string[] = [];\n  let pos = 0;\n  let child = cur.childAfter(pos);\n  while (child) {\n    values.push(...getAllByType(expr, child, type));\n    pos = child.to;\n    child = cur.childAfter(pos);\n  }\n  return values;\n}\n\n// Debugging function for convenience. Gives you nice output similar to linux tree util.\n// @ts-ignore\nexport function log(expr: string, cur?: SyntaxNode) {\n  if (!cur) {\n    console.log('<empty>');\n    return;\n  }\n  const json = toJson(expr, cur);\n  const text = jsonToText(json);\n\n  if (!text) {\n    console.log('<empty>');\n    return;\n  }\n  console.log(text);\n}\n\nfunction toJson(expr: string, cur: SyntaxNode) {\n  const treeJson: any = {};\n  const name = nodeToString(expr, cur);\n  const children = [];\n\n  let pos = 0;\n  let child = cur.childAfter(pos);\n  while (child) {\n    children.push(toJson(expr, child));\n    pos = child.to;\n    child = cur.childAfter(pos);\n  }\n\n  treeJson.name = name;\n  treeJson.children = children;\n  return treeJson;\n}\n\ntype JsonNode = {\n  name: string;\n  children: JsonNode[];\n};\n\nfunction jsonToText(\n  node: JsonNode,\n  context: { lastChild: boolean; indent: string } = {\n    lastChild: true,\n    indent: '',\n  }\n) {\n  const name = node.name;\n  const { lastChild, indent } = context;\n  const newIndent = indent !== '' ? indent + (lastChild ? '└─' : '├─') : '';\n  let text = newIndent + name;\n\n  const children = node.children;\n  children.forEach((child: any, index: number) => {\n    const isLastChild = index === children.length - 1;\n    text +=\n      '\\n' +\n      jsonToText(child, {\n        lastChild: isLastChild,\n        indent: indent + (lastChild ? '  ' : '│ '),\n      });\n  });\n\n  return text;\n}\n\nfunction nodeToString(expr: string, node: SyntaxNode) {\n  return node.name + ': ' + getString(expr, node);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}