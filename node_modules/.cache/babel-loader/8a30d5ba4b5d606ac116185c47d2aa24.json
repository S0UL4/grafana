{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { cloneDeep, extend, isString } from 'lodash';\nimport { dateMath, dateTime, getDefaultTimeRange, isDateTime, rangeUtil, toUtc } from '@grafana/data';\nimport { locationService } from '@grafana/runtime';\nimport appEvents from 'app/core/app_events';\nimport { config } from 'app/core/config';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { getShiftedTimeRange, getZoomedTimeRange } from 'app/core/utils/timePicker';\nimport { AbsoluteTimeEvent, ShiftTimeEvent, ZoomOutEvent } from '../../../types/events';\nimport { getRefreshFromUrl } from '../utils/getRefreshFromUrl';\nexport class TimeSrv {\n  constructor(contextSrv) {\n    _defineProperty(this, \"time\", void 0);\n\n    _defineProperty(this, \"refreshTimer\", void 0);\n\n    _defineProperty(this, \"refresh\", void 0);\n\n    _defineProperty(this, \"previousAutoRefresh\", void 0);\n\n    _defineProperty(this, \"oldRefresh\", void 0);\n\n    _defineProperty(this, \"timeModel\", void 0);\n\n    _defineProperty(this, \"timeAtLoad\", void 0);\n\n    _defineProperty(this, \"autoRefreshBlocked\", void 0);\n\n    _defineProperty(this, \"timeRangeForUrl\", () => {\n      const range = this.timeRange().raw;\n\n      if (isDateTime(range.from)) {\n        range.from = range.from.valueOf().toString();\n      }\n\n      if (isDateTime(range.to)) {\n        range.to = range.to.valueOf().toString();\n      }\n\n      return range;\n    });\n\n    this.contextSrv = contextSrv;\n    // default time\n    this.time = getDefaultTimeRange().raw;\n    this.refreshTimeModel = this.refreshTimeModel.bind(this);\n    appEvents.subscribe(ZoomOutEvent, e => {\n      this.zoomOut(e.payload.scale, e.payload.updateUrl);\n    });\n    appEvents.subscribe(ShiftTimeEvent, e => {\n      this.shiftTime(e.payload.direction, e.payload.updateUrl);\n    });\n    appEvents.subscribe(AbsoluteTimeEvent, () => {\n      this.makeAbsoluteTime();\n    });\n    document.addEventListener('visibilitychange', () => {\n      if (this.autoRefreshBlocked && document.visibilityState === 'visible') {\n        this.autoRefreshBlocked = false;\n        this.refreshTimeModel();\n      }\n    });\n  }\n\n  init(timeModel) {\n    var _this$timeModel, _this$timeModel2;\n\n    this.timeModel = timeModel;\n    this.time = timeModel.time;\n    this.refresh = timeModel.refresh;\n    this.initTimeFromUrl();\n    this.parseTime(); // remember time at load so we can go back to it\n\n    this.timeAtLoad = cloneDeep(this.time);\n    const range = rangeUtil.convertRawToRange(this.time, (_this$timeModel = this.timeModel) === null || _this$timeModel === void 0 ? void 0 : _this$timeModel.getTimezone(), (_this$timeModel2 = this.timeModel) === null || _this$timeModel2 === void 0 ? void 0 : _this$timeModel2.fiscalYearStartMonth);\n\n    if (range.to.isBefore(range.from)) {\n      this.setTime({\n        from: range.raw.to,\n        to: range.raw.from\n      }, false);\n    }\n\n    if (this.refresh) {\n      this.setAutoRefresh(this.refresh);\n    }\n  }\n\n  getValidIntervals(intervals) {\n    if (!this.contextSrv.minRefreshInterval) {\n      return intervals;\n    }\n\n    return intervals.filter(str => str !== '').filter(this.contextSrv.isAllowedInterval);\n  }\n\n  parseTime() {\n    // when absolute time is saved in json it is turned to a string\n    if (isString(this.time.from) && this.time.from.indexOf('Z') >= 0) {\n      this.time.from = dateTime(this.time.from).utc();\n    }\n\n    if (isString(this.time.to) && this.time.to.indexOf('Z') >= 0) {\n      this.time.to = dateTime(this.time.to).utc();\n    }\n  }\n\n  parseUrlParam(value) {\n    if (value.indexOf('now') !== -1) {\n      return value;\n    }\n\n    if (value.length === 8) {\n      const utcValue = toUtc(value, 'YYYYMMDD');\n\n      if (utcValue.isValid()) {\n        return utcValue;\n      }\n    } else if (value.length === 15) {\n      const utcValue = toUtc(value, 'YYYYMMDDTHHmmss');\n\n      if (utcValue.isValid()) {\n        return utcValue;\n      }\n    }\n\n    if (!isNaN(value)) {\n      const epoch = parseInt(value, 10);\n      return toUtc(epoch);\n    }\n\n    return null;\n  }\n\n  getTimeWindow(time, timeWindow) {\n    const valueTime = parseInt(time, 10);\n    let timeWindowMs;\n\n    if (timeWindow.match(/^\\d+$/) && parseInt(timeWindow, 10)) {\n      // when time window specified in ms\n      timeWindowMs = parseInt(timeWindow, 10);\n    } else {\n      timeWindowMs = rangeUtil.intervalToMs(timeWindow);\n    }\n\n    return {\n      from: toUtc(valueTime - timeWindowMs / 2),\n      to: toUtc(valueTime + timeWindowMs / 2)\n    };\n  }\n\n  initTimeFromUrl() {\n    var _this$timeModel3, _this$timeModel3$time, _this$timeModel4, _this$timeModel4$time;\n\n    const params = locationService.getSearch();\n\n    if (params.get('time') && params.get('time.window')) {\n      this.time = this.getTimeWindow(params.get('time'), params.get('time.window'));\n    }\n\n    if (params.get('from')) {\n      this.time.from = this.parseUrlParam(params.get('from')) || this.time.from;\n    }\n\n    if (params.get('to')) {\n      this.time.to = this.parseUrlParam(params.get('to')) || this.time.to;\n    } // if absolute ignore refresh option saved to timeModel\n\n\n    if (params.get('to') && params.get('to').indexOf('now') === -1) {\n      this.refresh = false;\n\n      if (this.timeModel) {\n        this.timeModel.refresh = false;\n      }\n    } // but if refresh explicitly set then use that\n\n\n    this.refresh = getRefreshFromUrl({\n      urlRefresh: params.get('refresh'),\n      currentRefresh: this.refresh,\n      refreshIntervals: Array.isArray((_this$timeModel3 = this.timeModel) === null || _this$timeModel3 === void 0 ? void 0 : (_this$timeModel3$time = _this$timeModel3.timepicker) === null || _this$timeModel3$time === void 0 ? void 0 : _this$timeModel3$time.refresh_intervals) ? (_this$timeModel4 = this.timeModel) === null || _this$timeModel4 === void 0 ? void 0 : (_this$timeModel4$time = _this$timeModel4.timepicker) === null || _this$timeModel4$time === void 0 ? void 0 : _this$timeModel4$time.refresh_intervals : undefined,\n      isAllowedIntervalFn: this.contextSrv.isAllowedInterval,\n      minRefreshInterval: config.minRefreshInterval\n    });\n  }\n\n  updateTimeRangeFromUrl() {\n    const params = locationService.getSearch();\n\n    if (params.get('left')) {\n      return; // explore handles this;\n    }\n\n    const urlRange = this.timeRangeForUrl();\n    const from = params.get('from');\n    const to = params.get('to'); // check if url has time range\n\n    if (from && to) {\n      // is it different from what our current time range?\n      if (from !== urlRange.from || to !== urlRange.to) {\n        // issue update\n        this.initTimeFromUrl();\n        this.setTime(this.time, false);\n      }\n    } else if (this.timeHasChangedSinceLoad()) {\n      this.setTime(this.timeAtLoad, true);\n    }\n  }\n\n  timeHasChangedSinceLoad() {\n    return this.timeAtLoad && (this.timeAtLoad.from !== this.time.from || this.timeAtLoad.to !== this.time.to);\n  }\n\n  setAutoRefresh(interval) {\n    if (this.timeModel) {\n      this.timeModel.refresh = interval;\n    }\n\n    this.stopAutoRefresh();\n    const currentUrlState = locationService.getSearchObject();\n\n    if (!interval) {\n      // Clear URL state\n      if (currentUrlState.refresh) {\n        locationService.partial({\n          refresh: null\n        }, true);\n      }\n\n      return;\n    }\n\n    const validInterval = this.contextSrv.getValidInterval(interval);\n    const intervalMs = rangeUtil.intervalToMs(validInterval);\n    this.refreshTimer = setTimeout(() => {\n      this.startNextRefreshTimer(intervalMs);\n      this.refreshTimeModel();\n    }, intervalMs);\n    const refresh = this.contextSrv.getValidInterval(interval);\n\n    if (currentUrlState.refresh !== refresh) {\n      locationService.partial({\n        refresh\n      }, true);\n    }\n  }\n\n  refreshTimeModel() {\n    var _this$timeModel5;\n\n    (_this$timeModel5 = this.timeModel) === null || _this$timeModel5 === void 0 ? void 0 : _this$timeModel5.timeRangeUpdated(this.timeRange());\n  }\n\n  startNextRefreshTimer(afterMs) {\n    this.refreshTimer = setTimeout(() => {\n      this.startNextRefreshTimer(afterMs);\n\n      if (this.contextSrv.isGrafanaVisible()) {\n        this.refreshTimeModel();\n      } else {\n        this.autoRefreshBlocked = true;\n      }\n    }, afterMs);\n  }\n\n  stopAutoRefresh() {\n    clearTimeout(this.refreshTimer);\n  } // store timeModel refresh value and pause auto-refresh in some places\n  // i.e panel edit\n\n\n  pauseAutoRefresh() {\n    var _this$timeModel6;\n\n    this.previousAutoRefresh = (_this$timeModel6 = this.timeModel) === null || _this$timeModel6 === void 0 ? void 0 : _this$timeModel6.refresh;\n    this.setAutoRefresh('');\n  } // resume auto-refresh based on old dashboard refresh property\n\n\n  resumeAutoRefresh() {\n    this.setAutoRefresh(this.previousAutoRefresh);\n  }\n\n  setTime(time, updateUrl = true) {\n    var _this$timeModel8;\n\n    extend(this.time, time); // disable refresh if zoom in or zoom out\n\n    if (isDateTime(time.to)) {\n      var _this$timeModel7;\n\n      this.oldRefresh = ((_this$timeModel7 = this.timeModel) === null || _this$timeModel7 === void 0 ? void 0 : _this$timeModel7.refresh) || this.oldRefresh;\n      this.setAutoRefresh(false);\n    } else if (this.oldRefresh && this.oldRefresh !== ((_this$timeModel8 = this.timeModel) === null || _this$timeModel8 === void 0 ? void 0 : _this$timeModel8.refresh)) {\n      this.setAutoRefresh(this.oldRefresh);\n      this.oldRefresh = null;\n    }\n\n    if (updateUrl === true) {\n      const urlRange = this.timeRangeForUrl();\n      const urlParams = locationService.getSearchObject();\n\n      if (urlParams.from === urlRange.from.toString() && urlParams.to === urlRange.to.toString()) {\n        return;\n      }\n\n      urlParams.from = urlRange.from.toString();\n      urlParams.to = urlRange.to.toString();\n      locationService.partial(urlParams);\n    }\n\n    this.refreshTimeModel();\n  }\n\n  timeRange() {\n    var _this$timeModel9, _this$timeModel10;\n\n    // make copies if they are moment  (do not want to return out internal moment, because they are mutable!)\n    const raw = {\n      from: isDateTime(this.time.from) ? dateTime(this.time.from) : this.time.from,\n      to: isDateTime(this.time.to) ? dateTime(this.time.to) : this.time.to\n    };\n    const timezone = this.timeModel ? this.timeModel.getTimezone() : undefined;\n    return {\n      from: dateMath.parse(raw.from, false, timezone, (_this$timeModel9 = this.timeModel) === null || _this$timeModel9 === void 0 ? void 0 : _this$timeModel9.fiscalYearStartMonth),\n      to: dateMath.parse(raw.to, true, timezone, (_this$timeModel10 = this.timeModel) === null || _this$timeModel10 === void 0 ? void 0 : _this$timeModel10.fiscalYearStartMonth),\n      raw: raw\n    };\n  }\n\n  zoomOut(factor, updateUrl = true) {\n    const range = this.timeRange();\n    const {\n      from,\n      to\n    } = getZoomedTimeRange(range, factor);\n    this.setTime({\n      from: toUtc(from),\n      to: toUtc(to)\n    }, updateUrl);\n  }\n\n  shiftTime(direction, updateUrl = true) {\n    const range = this.timeRange();\n    const {\n      from,\n      to\n    } = getShiftedTimeRange(direction, range);\n    this.setTime({\n      from: toUtc(from),\n      to: toUtc(to)\n    }, updateUrl);\n  }\n\n  makeAbsoluteTime() {\n    const params = locationService.getSearch();\n\n    if (params.get('left')) {\n      return; // explore handles this;\n    }\n\n    const {\n      from,\n      to\n    } = this.timeRange();\n    this.setTime({\n      from,\n      to\n    }, true);\n  } // isRefreshOutsideThreshold function calculates the difference between last refresh and now\n  // if the difference is outside 5% of the current set time range then the function will return true\n  // if the difference is within 5% of the current set time range then the function will return false\n  // if the current time range is absolute (i.e. not using relative strings like now-5m) then the function will return false\n\n\n  isRefreshOutsideThreshold(lastRefresh, threshold = 0.05) {\n    const timeRange = this.timeRange();\n\n    if (dateMath.isMathString(timeRange.raw.from)) {\n      const totalRange = timeRange.to.diff(timeRange.from);\n      const msSinceLastRefresh = Date.now() - lastRefresh;\n      const msThreshold = totalRange * threshold;\n      return msSinceLastRefresh >= msThreshold;\n    }\n\n    return false;\n  }\n\n}\nlet singleton;\nexport function setTimeSrv(srv) {\n  singleton = srv;\n}\nexport function getTimeSrv() {\n  if (!singleton) {\n    singleton = new TimeSrv(contextSrv);\n  }\n\n  return singleton;\n}","map":{"version":3,"names":["cloneDeep","extend","isString","dateMath","dateTime","getDefaultTimeRange","isDateTime","rangeUtil","toUtc","locationService","appEvents","config","contextSrv","getShiftedTimeRange","getZoomedTimeRange","AbsoluteTimeEvent","ShiftTimeEvent","ZoomOutEvent","getRefreshFromUrl","TimeSrv","constructor","range","timeRange","raw","from","valueOf","toString","to","time","refreshTimeModel","bind","subscribe","e","zoomOut","payload","scale","updateUrl","shiftTime","direction","makeAbsoluteTime","document","addEventListener","autoRefreshBlocked","visibilityState","init","timeModel","refresh","initTimeFromUrl","parseTime","timeAtLoad","convertRawToRange","getTimezone","fiscalYearStartMonth","isBefore","setTime","setAutoRefresh","getValidIntervals","intervals","minRefreshInterval","filter","str","isAllowedInterval","indexOf","utc","parseUrlParam","value","length","utcValue","isValid","isNaN","epoch","parseInt","getTimeWindow","timeWindow","valueTime","timeWindowMs","match","intervalToMs","params","getSearch","get","urlRefresh","currentRefresh","refreshIntervals","Array","isArray","timepicker","refresh_intervals","undefined","isAllowedIntervalFn","updateTimeRangeFromUrl","urlRange","timeRangeForUrl","timeHasChangedSinceLoad","interval","stopAutoRefresh","currentUrlState","getSearchObject","partial","validInterval","getValidInterval","intervalMs","refreshTimer","setTimeout","startNextRefreshTimer","timeRangeUpdated","afterMs","isGrafanaVisible","clearTimeout","pauseAutoRefresh","previousAutoRefresh","resumeAutoRefresh","oldRefresh","urlParams","timezone","parse","factor","isRefreshOutsideThreshold","lastRefresh","threshold","isMathString","totalRange","diff","msSinceLastRefresh","Date","now","msThreshold","singleton","setTimeSrv","srv","getTimeSrv"],"sources":["/home/soula/grafana/public/app/features/dashboard/services/TimeSrv.ts"],"sourcesContent":["import { cloneDeep, extend, isString } from 'lodash';\n\nimport {\n  dateMath,\n  dateTime,\n  getDefaultTimeRange,\n  isDateTime,\n  rangeUtil,\n  RawTimeRange,\n  TimeRange,\n  toUtc,\n} from '@grafana/data';\nimport { locationService } from '@grafana/runtime';\nimport appEvents from 'app/core/app_events';\nimport { config } from 'app/core/config';\nimport { contextSrv, ContextSrv } from 'app/core/services/context_srv';\nimport { getShiftedTimeRange, getZoomedTimeRange } from 'app/core/utils/timePicker';\n\nimport { AbsoluteTimeEvent, ShiftTimeEvent, ShiftTimeEventDirection, ZoomOutEvent } from '../../../types/events';\nimport { TimeModel } from '../state/TimeModel';\nimport { getRefreshFromUrl } from '../utils/getRefreshFromUrl';\n\nexport class TimeSrv {\n  time: any;\n  refreshTimer: any;\n  refresh: any;\n  previousAutoRefresh: any;\n  oldRefresh: string | null | undefined;\n  timeModel?: TimeModel;\n  timeAtLoad: any;\n  private autoRefreshBlocked?: boolean;\n\n  constructor(private contextSrv: ContextSrv) {\n    // default time\n    this.time = getDefaultTimeRange().raw;\n    this.refreshTimeModel = this.refreshTimeModel.bind(this);\n\n    appEvents.subscribe(ZoomOutEvent, (e) => {\n      this.zoomOut(e.payload.scale, e.payload.updateUrl);\n    });\n\n    appEvents.subscribe(ShiftTimeEvent, (e) => {\n      this.shiftTime(e.payload.direction, e.payload.updateUrl);\n    });\n\n    appEvents.subscribe(AbsoluteTimeEvent, () => {\n      this.makeAbsoluteTime();\n    });\n\n    document.addEventListener('visibilitychange', () => {\n      if (this.autoRefreshBlocked && document.visibilityState === 'visible') {\n        this.autoRefreshBlocked = false;\n        this.refreshTimeModel();\n      }\n    });\n  }\n\n  init(timeModel: TimeModel) {\n    this.timeModel = timeModel;\n    this.time = timeModel.time;\n    this.refresh = timeModel.refresh;\n\n    this.initTimeFromUrl();\n    this.parseTime();\n\n    // remember time at load so we can go back to it\n    this.timeAtLoad = cloneDeep(this.time);\n\n    const range = rangeUtil.convertRawToRange(\n      this.time,\n      this.timeModel?.getTimezone(),\n      this.timeModel?.fiscalYearStartMonth\n    );\n\n    if (range.to.isBefore(range.from)) {\n      this.setTime(\n        {\n          from: range.raw.to,\n          to: range.raw.from,\n        },\n        false\n      );\n    }\n\n    if (this.refresh) {\n      this.setAutoRefresh(this.refresh);\n    }\n  }\n\n  getValidIntervals(intervals: string[]): string[] {\n    if (!this.contextSrv.minRefreshInterval) {\n      return intervals;\n    }\n\n    return intervals.filter((str) => str !== '').filter(this.contextSrv.isAllowedInterval);\n  }\n\n  private parseTime() {\n    // when absolute time is saved in json it is turned to a string\n    if (isString(this.time.from) && this.time.from.indexOf('Z') >= 0) {\n      this.time.from = dateTime(this.time.from).utc();\n    }\n    if (isString(this.time.to) && this.time.to.indexOf('Z') >= 0) {\n      this.time.to = dateTime(this.time.to).utc();\n    }\n  }\n\n  private parseUrlParam(value: any) {\n    if (value.indexOf('now') !== -1) {\n      return value;\n    }\n    if (value.length === 8) {\n      const utcValue = toUtc(value, 'YYYYMMDD');\n      if (utcValue.isValid()) {\n        return utcValue;\n      }\n    } else if (value.length === 15) {\n      const utcValue = toUtc(value, 'YYYYMMDDTHHmmss');\n      if (utcValue.isValid()) {\n        return utcValue;\n      }\n    }\n\n    if (!isNaN(value)) {\n      const epoch = parseInt(value, 10);\n      return toUtc(epoch);\n    }\n\n    return null;\n  }\n\n  private getTimeWindow(time: string, timeWindow: string) {\n    const valueTime = parseInt(time, 10);\n    let timeWindowMs;\n\n    if (timeWindow.match(/^\\d+$/) && parseInt(timeWindow, 10)) {\n      // when time window specified in ms\n      timeWindowMs = parseInt(timeWindow, 10);\n    } else {\n      timeWindowMs = rangeUtil.intervalToMs(timeWindow);\n    }\n\n    return {\n      from: toUtc(valueTime - timeWindowMs / 2),\n      to: toUtc(valueTime + timeWindowMs / 2),\n    };\n  }\n\n  private initTimeFromUrl() {\n    const params = locationService.getSearch();\n\n    if (params.get('time') && params.get('time.window')) {\n      this.time = this.getTimeWindow(params.get('time')!, params.get('time.window')!);\n    }\n\n    if (params.get('from')) {\n      this.time.from = this.parseUrlParam(params.get('from')!) || this.time.from;\n    }\n\n    if (params.get('to')) {\n      this.time.to = this.parseUrlParam(params.get('to')!) || this.time.to;\n    }\n\n    // if absolute ignore refresh option saved to timeModel\n    if (params.get('to') && params.get('to')!.indexOf('now') === -1) {\n      this.refresh = false;\n      if (this.timeModel) {\n        this.timeModel.refresh = false;\n      }\n    }\n\n    // but if refresh explicitly set then use that\n    this.refresh = getRefreshFromUrl({\n      urlRefresh: params.get('refresh'),\n      currentRefresh: this.refresh,\n      refreshIntervals: Array.isArray(this.timeModel?.timepicker?.refresh_intervals)\n        ? this.timeModel?.timepicker?.refresh_intervals\n        : undefined,\n      isAllowedIntervalFn: this.contextSrv.isAllowedInterval,\n      minRefreshInterval: config.minRefreshInterval,\n    });\n  }\n\n  updateTimeRangeFromUrl() {\n    const params = locationService.getSearch();\n\n    if (params.get('left')) {\n      return; // explore handles this;\n    }\n\n    const urlRange = this.timeRangeForUrl();\n    const from = params.get('from');\n    const to = params.get('to');\n\n    // check if url has time range\n    if (from && to) {\n      // is it different from what our current time range?\n      if (from !== urlRange.from || to !== urlRange.to) {\n        // issue update\n        this.initTimeFromUrl();\n        this.setTime(this.time, false);\n      }\n    } else if (this.timeHasChangedSinceLoad()) {\n      this.setTime(this.timeAtLoad, true);\n    }\n  }\n\n  private timeHasChangedSinceLoad() {\n    return this.timeAtLoad && (this.timeAtLoad.from !== this.time.from || this.timeAtLoad.to !== this.time.to);\n  }\n\n  setAutoRefresh(interval: any) {\n    if (this.timeModel) {\n      this.timeModel.refresh = interval;\n    }\n\n    this.stopAutoRefresh();\n\n    const currentUrlState = locationService.getSearchObject();\n\n    if (!interval) {\n      // Clear URL state\n      if (currentUrlState.refresh) {\n        locationService.partial({ refresh: null }, true);\n      }\n\n      return;\n    }\n\n    const validInterval = this.contextSrv.getValidInterval(interval);\n    const intervalMs = rangeUtil.intervalToMs(validInterval);\n\n    this.refreshTimer = setTimeout(() => {\n      this.startNextRefreshTimer(intervalMs);\n      this.refreshTimeModel();\n    }, intervalMs);\n\n    const refresh = this.contextSrv.getValidInterval(interval);\n\n    if (currentUrlState.refresh !== refresh) {\n      locationService.partial({ refresh }, true);\n    }\n  }\n\n  refreshTimeModel() {\n    this.timeModel?.timeRangeUpdated(this.timeRange());\n  }\n\n  private startNextRefreshTimer(afterMs: number) {\n    this.refreshTimer = setTimeout(() => {\n      this.startNextRefreshTimer(afterMs);\n      if (this.contextSrv.isGrafanaVisible()) {\n        this.refreshTimeModel();\n      } else {\n        this.autoRefreshBlocked = true;\n      }\n    }, afterMs);\n  }\n\n  stopAutoRefresh() {\n    clearTimeout(this.refreshTimer);\n  }\n\n  // store timeModel refresh value and pause auto-refresh in some places\n  // i.e panel edit\n  pauseAutoRefresh() {\n    this.previousAutoRefresh = this.timeModel?.refresh;\n    this.setAutoRefresh('');\n  }\n\n  // resume auto-refresh based on old dashboard refresh property\n  resumeAutoRefresh() {\n    this.setAutoRefresh(this.previousAutoRefresh);\n  }\n\n  setTime(time: RawTimeRange, updateUrl = true) {\n    extend(this.time, time);\n\n    // disable refresh if zoom in or zoom out\n    if (isDateTime(time.to)) {\n      this.oldRefresh = this.timeModel?.refresh || this.oldRefresh;\n      this.setAutoRefresh(false);\n    } else if (this.oldRefresh && this.oldRefresh !== this.timeModel?.refresh) {\n      this.setAutoRefresh(this.oldRefresh);\n      this.oldRefresh = null;\n    }\n\n    if (updateUrl === true) {\n      const urlRange = this.timeRangeForUrl();\n      const urlParams = locationService.getSearchObject();\n\n      if (urlParams.from === urlRange.from.toString() && urlParams.to === urlRange.to.toString()) {\n        return;\n      }\n\n      urlParams.from = urlRange.from.toString();\n      urlParams.to = urlRange.to.toString();\n\n      locationService.partial(urlParams);\n    }\n\n    this.refreshTimeModel();\n  }\n\n  timeRangeForUrl = () => {\n    const range = this.timeRange().raw;\n\n    if (isDateTime(range.from)) {\n      range.from = range.from.valueOf().toString();\n    }\n    if (isDateTime(range.to)) {\n      range.to = range.to.valueOf().toString();\n    }\n\n    return range;\n  };\n\n  timeRange(): TimeRange {\n    // make copies if they are moment  (do not want to return out internal moment, because they are mutable!)\n    const raw = {\n      from: isDateTime(this.time.from) ? dateTime(this.time.from) : this.time.from,\n      to: isDateTime(this.time.to) ? dateTime(this.time.to) : this.time.to,\n    };\n\n    const timezone = this.timeModel ? this.timeModel.getTimezone() : undefined;\n\n    return {\n      from: dateMath.parse(raw.from, false, timezone, this.timeModel?.fiscalYearStartMonth)!,\n      to: dateMath.parse(raw.to, true, timezone, this.timeModel?.fiscalYearStartMonth)!,\n      raw: raw,\n    };\n  }\n\n  zoomOut(factor: number, updateUrl = true) {\n    const range = this.timeRange();\n    const { from, to } = getZoomedTimeRange(range, factor);\n\n    this.setTime({ from: toUtc(from), to: toUtc(to) }, updateUrl);\n  }\n\n  shiftTime(direction: ShiftTimeEventDirection, updateUrl = true) {\n    const range = this.timeRange();\n    const { from, to } = getShiftedTimeRange(direction, range);\n\n    this.setTime(\n      {\n        from: toUtc(from),\n        to: toUtc(to),\n      },\n      updateUrl\n    );\n  }\n\n  makeAbsoluteTime() {\n    const params = locationService.getSearch();\n    if (params.get('left')) {\n      return; // explore handles this;\n    }\n\n    const { from, to } = this.timeRange();\n    this.setTime({ from, to }, true);\n  }\n\n  // isRefreshOutsideThreshold function calculates the difference between last refresh and now\n  // if the difference is outside 5% of the current set time range then the function will return true\n  // if the difference is within 5% of the current set time range then the function will return false\n  // if the current time range is absolute (i.e. not using relative strings like now-5m) then the function will return false\n  isRefreshOutsideThreshold(lastRefresh: number, threshold = 0.05) {\n    const timeRange = this.timeRange();\n\n    if (dateMath.isMathString(timeRange.raw.from)) {\n      const totalRange = timeRange.to.diff(timeRange.from);\n      const msSinceLastRefresh = Date.now() - lastRefresh;\n      const msThreshold = totalRange * threshold;\n      return msSinceLastRefresh >= msThreshold;\n    }\n\n    return false;\n  }\n}\n\nlet singleton: TimeSrv | undefined;\n\nexport function setTimeSrv(srv: TimeSrv) {\n  singleton = srv;\n}\n\nexport function getTimeSrv(): TimeSrv {\n  if (!singleton) {\n    singleton = new TimeSrv(contextSrv);\n  }\n\n  return singleton;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}