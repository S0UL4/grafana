{"ast":null,"code":"// Libraries\nimport { isString, map as isArray } from 'lodash';\nimport { from, merge, of, timer } from 'rxjs';\nimport { catchError, map, mapTo, share, takeUntil, tap } from 'rxjs/operators'; // Utils & Services\n// Types\n\nimport { DataTopic, dateMath, guessFieldTypes, LoadingState, toDataFrame } from '@grafana/data';\nimport { toDataQueryError } from '@grafana/runtime';\nimport { isExpressionReference } from '@grafana/runtime/src/utils/DataSourceWithBackend';\nimport { backendSrv } from 'app/core/services/backend_srv';\nimport { dataSource as expressionDatasource } from 'app/features/expressions/ExpressionDatasource';\nimport { cancelNetworkRequestsOnUnsubscribe } from './processing/canceler';\nimport { emitDataRequestEvent } from './queryAnalytics';\n\n/*\n * This function should handle composing a PanelData from multiple responses\n */\nexport function processResponsePacket(packet, state) {\n  var _ref, _packet$key, _packet$data, _packet$data$;\n\n  const request = state.panelData.request;\n  const packets = Object.assign({}, state.packets); // updates to the same key will replace previous values\n\n  const key = (_ref = (_packet$key = packet.key) !== null && _packet$key !== void 0 ? _packet$key : (_packet$data = packet.data) === null || _packet$data === void 0 ? void 0 : (_packet$data$ = _packet$data[0]) === null || _packet$data$ === void 0 ? void 0 : _packet$data$.refId) !== null && _ref !== void 0 ? _ref : 'A';\n  packets[key] = packet;\n  let loadingState = packet.state || LoadingState.Done;\n  let error = undefined;\n  const series = [];\n  const annotations = [];\n\n  for (const key in packets) {\n    const packet = packets[key];\n\n    if (packet.error) {\n      loadingState = LoadingState.Error;\n      error = packet.error;\n    }\n\n    if (packet.data && packet.data.length) {\n      for (const dataItem of packet.data) {\n        var _dataItem$meta;\n\n        if (((_dataItem$meta = dataItem.meta) === null || _dataItem$meta === void 0 ? void 0 : _dataItem$meta.dataTopic) === DataTopic.Annotations) {\n          annotations.push(dataItem);\n          continue;\n        }\n\n        series.push(dataItem);\n      }\n    }\n  }\n\n  const timeRange = getRequestTimeRange(request, loadingState);\n  const panelData = {\n    state: loadingState,\n    series,\n    annotations,\n    error,\n    request,\n    timeRange\n  };\n  return {\n    packets,\n    panelData\n  };\n}\n\nfunction getRequestTimeRange(request, loadingState) {\n  const range = request.range;\n\n  if (!isString(range.raw.from) || loadingState !== LoadingState.Streaming) {\n    return range;\n  }\n\n  return Object.assign({}, range, {\n    from: dateMath.parse(range.raw.from, false),\n    to: dateMath.parse(range.raw.to, true)\n  });\n}\n/**\n * This function handles the execution of requests & and processes the single or multiple response packets into\n * a combined PanelData response. It will\n *  Merge multiple responses into a single DataFrame array based on the packet key\n *  Will emit a loading state if no response after 50ms\n *  Cancel any still running network requests on unsubscribe (using request.requestId)\n */\n\n\nexport function runRequest(datasource, request, queryFunction) {\n  let state = {\n    panelData: {\n      state: LoadingState.Loading,\n      series: [],\n      request: request,\n      timeRange: request.range\n    },\n    packets: {}\n  }; // Return early if there are no queries to run\n\n  if (!request.targets.length) {\n    request.endTime = Date.now();\n    state.panelData.state = LoadingState.Done;\n    return of(state.panelData);\n  }\n\n  const dataObservable = callQueryMethod(datasource, request, queryFunction).pipe( // Transform response packets into PanelData with merged results\n  map(packet => {\n    if (!isArray(packet.data)) {\n      throw new Error(`Expected response data to be array, got ${typeof packet.data}.`);\n    }\n\n    request.endTime = Date.now();\n    state = processResponsePacket(packet, state);\n    return state.panelData;\n  }), // handle errors\n  catchError(err => {\n    const errLog = typeof err === 'string' ? err : JSON.stringify(err);\n    console.error('runRequest.catchError', errLog);\n    return of(Object.assign({}, state.panelData, {\n      state: LoadingState.Error,\n      error: toDataQueryError(err)\n    }));\n  }), tap(emitDataRequestEvent(datasource)), // finalize is triggered when subscriber unsubscribes\n  // This makes sure any still running network requests are cancelled\n  cancelNetworkRequestsOnUnsubscribe(backendSrv, request.requestId), // this makes it possible to share this observable in takeUntil\n  share()); // If 50ms without a response emit a loading state\n  // mapTo will translate the timer event into state.panelData (which has state set to loading)\n  // takeUntil will cancel the timer emit when first response packet is received on the dataObservable\n\n  return merge(timer(200).pipe(mapTo(state.panelData), takeUntil(dataObservable)), dataObservable);\n}\nexport function callQueryMethod(datasource, request, queryFunction) {\n  // If any query has an expression, use the expression endpoint\n  for (const target of request.targets) {\n    if (isExpressionReference(target.datasource)) {\n      return expressionDatasource.query(request);\n    }\n  } // Otherwise it is a standard datasource request\n\n\n  const returnVal = queryFunction ? queryFunction(request) : datasource.query(request);\n  return from(returnVal);\n}\n\nfunction getProcessedDataFrame(data) {\n  const dataFrame = guessFieldTypes(toDataFrame(data));\n\n  if (dataFrame.fields && dataFrame.fields.length) {\n    // clear out the cached info\n    for (const field of dataFrame.fields) {\n      field.state = null;\n    }\n  }\n\n  return dataFrame;\n}\n/**\n * All panels will be passed tables that have our best guess at column type set\n *\n * This is also used by PanelChrome for snapshot support\n */\n\n\nexport function getProcessedDataFrames(results) {\n  if (!results || !isArray(results)) {\n    return [];\n  }\n\n  return results.map(data => getProcessedDataFrame(data));\n}\nexport function preProcessPanelData(data, lastResult) {\n  const {\n    series,\n    annotations\n  } = data; //  for loading states with no data, use last result\n\n  if (data.state === LoadingState.Loading && series.length === 0) {\n    if (!lastResult) {\n      lastResult = data;\n    }\n\n    return Object.assign({}, lastResult, {\n      state: LoadingState.Loading,\n      request: data.request\n    });\n  } // Make sure the data frames are properly formatted\n\n\n  const STARTTIME = performance.now();\n  const processedDataFrames = series.map(data => getProcessedDataFrame(data));\n  const annotationsProcessed = getProcessedDataFrames(annotations);\n  const STOPTIME = performance.now();\n  return Object.assign({}, data, {\n    series: processedDataFrames,\n    annotations: annotationsProcessed,\n    timings: {\n      dataProcessingTime: STOPTIME - STARTTIME\n    }\n  });\n}","map":{"version":3,"names":["isString","map","isArray","from","merge","of","timer","catchError","mapTo","share","takeUntil","tap","DataTopic","dateMath","guessFieldTypes","LoadingState","toDataFrame","toDataQueryError","isExpressionReference","backendSrv","dataSource","expressionDatasource","cancelNetworkRequestsOnUnsubscribe","emitDataRequestEvent","processResponsePacket","packet","state","request","panelData","packets","key","data","refId","loadingState","Done","error","undefined","series","annotations","Error","length","dataItem","meta","dataTopic","Annotations","push","timeRange","getRequestTimeRange","range","raw","Streaming","parse","to","runRequest","datasource","queryFunction","Loading","targets","endTime","Date","now","dataObservable","callQueryMethod","pipe","err","errLog","JSON","stringify","console","requestId","target","query","returnVal","getProcessedDataFrame","dataFrame","fields","field","getProcessedDataFrames","results","preProcessPanelData","lastResult","STARTTIME","performance","processedDataFrames","annotationsProcessed","STOPTIME","timings","dataProcessingTime"],"sources":["/home/soula/grafana/public/app/features/query/state/runRequest.ts"],"sourcesContent":["// Libraries\nimport { isString, map as isArray } from 'lodash';\nimport { from, merge, Observable, of, timer } from 'rxjs';\nimport { catchError, map, mapTo, share, takeUntil, tap } from 'rxjs/operators';\n\n// Utils & Services\n// Types\nimport {\n  DataFrame,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataQueryResponseData,\n  DataSourceApi,\n  DataTopic,\n  dateMath,\n  guessFieldTypes,\n  LoadingState,\n  PanelData,\n  TimeRange,\n  toDataFrame,\n} from '@grafana/data';\nimport { toDataQueryError } from '@grafana/runtime';\nimport { isExpressionReference } from '@grafana/runtime/src/utils/DataSourceWithBackend';\nimport { backendSrv } from 'app/core/services/backend_srv';\nimport { dataSource as expressionDatasource } from 'app/features/expressions/ExpressionDatasource';\nimport { ExpressionQuery } from 'app/features/expressions/types';\n\nimport { cancelNetworkRequestsOnUnsubscribe } from './processing/canceler';\nimport { emitDataRequestEvent } from './queryAnalytics';\n\ntype MapOfResponsePackets = { [str: string]: DataQueryResponse };\n\ninterface RunningQueryState {\n  packets: { [key: string]: DataQueryResponse };\n  panelData: PanelData;\n}\n\n/*\n * This function should handle composing a PanelData from multiple responses\n */\nexport function processResponsePacket(packet: DataQueryResponse, state: RunningQueryState): RunningQueryState {\n  const request = state.panelData.request!;\n  const packets: MapOfResponsePackets = {\n    ...state.packets,\n  };\n\n  // updates to the same key will replace previous values\n  const key = packet.key ?? packet.data?.[0]?.refId ?? 'A';\n  packets[key] = packet;\n\n  let loadingState = packet.state || LoadingState.Done;\n  let error: DataQueryError | undefined = undefined;\n\n  const series: DataQueryResponseData[] = [];\n  const annotations: DataQueryResponseData[] = [];\n\n  for (const key in packets) {\n    const packet = packets[key];\n\n    if (packet.error) {\n      loadingState = LoadingState.Error;\n      error = packet.error;\n    }\n\n    if (packet.data && packet.data.length) {\n      for (const dataItem of packet.data) {\n        if (dataItem.meta?.dataTopic === DataTopic.Annotations) {\n          annotations.push(dataItem);\n          continue;\n        }\n\n        series.push(dataItem);\n      }\n    }\n  }\n\n  const timeRange = getRequestTimeRange(request, loadingState);\n\n  const panelData = {\n    state: loadingState,\n    series,\n    annotations,\n    error,\n    request,\n    timeRange,\n  };\n\n  return { packets, panelData };\n}\n\nfunction getRequestTimeRange(request: DataQueryRequest, loadingState: LoadingState): TimeRange {\n  const range = request.range;\n\n  if (!isString(range.raw.from) || loadingState !== LoadingState.Streaming) {\n    return range;\n  }\n\n  return {\n    ...range,\n    from: dateMath.parse(range.raw.from, false)!,\n    to: dateMath.parse(range.raw.to, true)!,\n  };\n}\n\n/**\n * This function handles the execution of requests & and processes the single or multiple response packets into\n * a combined PanelData response. It will\n *  Merge multiple responses into a single DataFrame array based on the packet key\n *  Will emit a loading state if no response after 50ms\n *  Cancel any still running network requests on unsubscribe (using request.requestId)\n */\nexport function runRequest(\n  datasource: DataSourceApi,\n  request: DataQueryRequest,\n  queryFunction?: typeof datasource.query\n): Observable<PanelData> {\n  let state: RunningQueryState = {\n    panelData: {\n      state: LoadingState.Loading,\n      series: [],\n      request: request,\n      timeRange: request.range,\n    },\n    packets: {},\n  };\n\n  // Return early if there are no queries to run\n  if (!request.targets.length) {\n    request.endTime = Date.now();\n    state.panelData.state = LoadingState.Done;\n    return of(state.panelData);\n  }\n\n  const dataObservable = callQueryMethod(datasource, request, queryFunction).pipe(\n    // Transform response packets into PanelData with merged results\n    map((packet: DataQueryResponse) => {\n      if (!isArray(packet.data)) {\n        throw new Error(`Expected response data to be array, got ${typeof packet.data}.`);\n      }\n\n      request.endTime = Date.now();\n\n      state = processResponsePacket(packet, state);\n\n      return state.panelData;\n    }),\n    // handle errors\n    catchError((err) => {\n      const errLog = typeof err === 'string' ? err : JSON.stringify(err);\n      console.error('runRequest.catchError', errLog);\n      return of({\n        ...state.panelData,\n        state: LoadingState.Error,\n        error: toDataQueryError(err),\n      });\n    }),\n    tap(emitDataRequestEvent(datasource)),\n    // finalize is triggered when subscriber unsubscribes\n    // This makes sure any still running network requests are cancelled\n    cancelNetworkRequestsOnUnsubscribe(backendSrv, request.requestId),\n    // this makes it possible to share this observable in takeUntil\n    share()\n  );\n\n  // If 50ms without a response emit a loading state\n  // mapTo will translate the timer event into state.panelData (which has state set to loading)\n  // takeUntil will cancel the timer emit when first response packet is received on the dataObservable\n  return merge(timer(200).pipe(mapTo(state.panelData), takeUntil(dataObservable)), dataObservable);\n}\n\nexport function callQueryMethod(\n  datasource: DataSourceApi,\n  request: DataQueryRequest,\n  queryFunction?: typeof datasource.query\n) {\n  // If any query has an expression, use the expression endpoint\n  for (const target of request.targets) {\n    if (isExpressionReference(target.datasource)) {\n      return expressionDatasource.query(request as DataQueryRequest<ExpressionQuery>);\n    }\n  }\n\n  // Otherwise it is a standard datasource request\n  const returnVal = queryFunction ? queryFunction(request) : datasource.query(request);\n  return from(returnVal);\n}\n\nfunction getProcessedDataFrame(data: DataQueryResponseData): DataFrame {\n  const dataFrame = guessFieldTypes(toDataFrame(data));\n\n  if (dataFrame.fields && dataFrame.fields.length) {\n    // clear out the cached info\n    for (const field of dataFrame.fields) {\n      field.state = null;\n    }\n  }\n\n  return dataFrame;\n}\n\n/**\n * All panels will be passed tables that have our best guess at column type set\n *\n * This is also used by PanelChrome for snapshot support\n */\nexport function getProcessedDataFrames(results?: DataQueryResponseData[]): DataFrame[] {\n  if (!results || !isArray(results)) {\n    return [];\n  }\n\n  return results.map((data) => getProcessedDataFrame(data));\n}\n\nexport function preProcessPanelData(data: PanelData, lastResult?: PanelData): PanelData {\n  const { series, annotations } = data;\n\n  //  for loading states with no data, use last result\n  if (data.state === LoadingState.Loading && series.length === 0) {\n    if (!lastResult) {\n      lastResult = data;\n    }\n\n    return {\n      ...lastResult,\n      state: LoadingState.Loading,\n      request: data.request,\n    };\n  }\n\n  // Make sure the data frames are properly formatted\n  const STARTTIME = performance.now();\n  const processedDataFrames = series.map((data) => getProcessedDataFrame(data));\n  const annotationsProcessed = getProcessedDataFrames(annotations);\n  const STOPTIME = performance.now();\n\n  return {\n    ...data,\n    series: processedDataFrames,\n    annotations: annotationsProcessed,\n    timings: { dataProcessingTime: STOPTIME - STARTTIME },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}