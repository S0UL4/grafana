{"ast":null,"code":"import React from 'react';\nimport uPlot from 'uplot';\nimport { formattedValueToString, getFieldColorModeForField, getFieldSeriesColor } from '@grafana/data';\nimport { histogramBucketSizes, histogramFrameBucketMaxFieldName } from '@grafana/data/src/transformations/transformers/histogram';\nimport { LegendDisplayMode, ScaleDistribution, AxisPlacement, ScaleDirection, ScaleOrientation } from '@grafana/schema';\nimport { UPlotConfigBuilder, UPlotChart, VizLayout, PlotLegend, measureText, UPLOT_AXIS_FONT_SIZE } from '@grafana/ui';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction incrRoundDn(num, incr) {\n  return Math.floor(num / incr) * incr;\n}\n\nfunction incrRoundUp(num, incr) {\n  return Math.ceil(num / incr) * incr;\n}\n\nexport function getBucketSize(frame) {\n  // assumes BucketMin is fields[0] and BucktMax is fields[1]\n  return frame.fields[1].values.get(0) - frame.fields[0].values.get(0);\n}\n\nconst prepConfig = (frame, theme) => {\n  // todo: scan all values in BucketMin and BucketMax fields to assert if uniform bucketSize\n  let builder = new UPlotConfigBuilder(); // assumes BucketMin is fields[0] and BucktMax is fields[1]\n\n  let bucketSize = getBucketSize(frame); // splits shifter, to ensure splits always start at first bucket\n\n  let xSplits = (u, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {\n    /** @ts-ignore */\n    let minSpace = u.axes[axisIdx]._space;\n    let bucketWidth = u.valToPos(u.data[0][0] + bucketSize, 'x') - u.valToPos(u.data[0][0], 'x');\n    let firstSplit = u.data[0][0];\n    let lastSplit = u.data[0][u.data[0].length - 1] + bucketSize;\n    let splits = [];\n    let skip = Math.ceil(minSpace / bucketWidth);\n\n    for (let i = 0, s = firstSplit; s <= lastSplit; i++, s += bucketSize) {\n      !(i % skip) && splits.push(s);\n    }\n\n    return splits;\n  };\n\n  builder.addScale({\n    scaleKey: 'x',\n    // bukkits\n    isTime: false,\n    distribution: ScaleDistribution.Linear,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    range: (u, wantedMin, wantedMax) => {\n      let fullRangeMin = u.data[0][0];\n      let fullRangeMax = u.data[0][u.data[0].length - 1]; // snap to bucket divisors...\n\n      if (wantedMax === fullRangeMax) {\n        wantedMax += bucketSize;\n      } else {\n        wantedMax = incrRoundUp(wantedMax, bucketSize);\n      }\n\n      if (wantedMin > fullRangeMin) {\n        wantedMin = incrRoundDn(wantedMin, bucketSize);\n      }\n\n      return [wantedMin, wantedMax];\n    }\n  });\n  builder.addScale({\n    scaleKey: 'y',\n    // counts\n    isTime: false,\n    distribution: ScaleDistribution.Linear,\n    orientation: ScaleOrientation.Vertical,\n    direction: ScaleDirection.Up\n  });\n  const fmt = frame.fields[0].display;\n\n  const xAxisFormatter = v => {\n    return formattedValueToString(fmt(v));\n  };\n\n  builder.addAxis({\n    scaleKey: 'x',\n    isTime: false,\n    placement: AxisPlacement.Bottom,\n    incrs: histogramBucketSizes,\n    splits: xSplits,\n    values: (u, splits) => {\n      const tickLabels = splits.map(xAxisFormatter);\n      const maxWidth = tickLabels.reduce((curMax, label) => Math.max(measureText(label, UPLOT_AXIS_FONT_SIZE).width, curMax), 0);\n      const labelSpacing = 10;\n      const maxCount = u.bbox.width / ((maxWidth + labelSpacing) * devicePixelRatio);\n      const keepMod = Math.ceil(tickLabels.length / maxCount);\n      return tickLabels.map((label, i) => i % keepMod === 0 ? label : null);\n    },\n    //incrs: () => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((mult) => mult * bucketSize),\n    //splits: config.xSplits,\n    //values: config.xValues,\n    //grid: false,\n    //ticks: false,\n    //gap: 15,\n    theme\n  });\n  builder.addAxis({\n    scaleKey: 'y',\n    isTime: false,\n    placement: AxisPlacement.Left,\n    //splits: config.xSplits,\n    //values: config.xValues,\n    //grid: false,\n    //ticks: false,\n    //gap: 15,\n    theme\n  });\n  builder.setCursor({\n    points: {\n      show: false\n    },\n    drag: {\n      x: true,\n      y: false,\n      setScale: true\n    }\n  });\n  let pathBuilder = uPlot.paths.bars({\n    align: 1,\n    size: [1, Infinity]\n  });\n  let seriesIndex = 0; // assumes BucketMax is [1]\n\n  for (let i = 2; i < frame.fields.length; i++) {\n    var _field$state, _customConfig$hideFro;\n\n    const field = frame.fields[i];\n    field.state = (_field$state = field.state) !== null && _field$state !== void 0 ? _field$state : {};\n    field.state.seriesIndex = seriesIndex++;\n    const customConfig = Object.assign({}, field.config.custom);\n    const scaleKey = 'y';\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n    builder.addSeries({\n      scaleKey,\n      lineWidth: customConfig.lineWidth,\n      lineColor: seriesColor,\n      //lineStyle: customConfig.lineStyle,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      colorMode,\n      pathBuilder,\n      //pointsBuilder: config.drawPoints,\n      show: !((_customConfig$hideFro = customConfig.hideFrom) !== null && _customConfig$hideFro !== void 0 && _customConfig$hideFro.vis),\n      gradientMode: customConfig.gradientMode,\n      thresholds: field.config.thresholds,\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: {\n        fieldIndex: i,\n        frameIndex: 0\n      }\n    });\n  }\n\n  return builder;\n};\n\nconst preparePlotData = frame => {\n  let data = [];\n\n  for (const field of frame.fields) {\n    if (field.name !== histogramFrameBucketMaxFieldName) {\n      data.push(field.values.toArray());\n    }\n  } // uPlot's bars pathBuilder will draw rects even if 0 (to distinguish them from nulls)\n  // but for histograms we want to omit them, so remap 0s -> nulls\n\n\n  for (let i = 1; i < data.length; i++) {\n    let counts = data[i];\n\n    for (let j = 0; j < counts.length; j++) {\n      if (counts[j] === 0) {\n        counts[j] = null;\n      }\n    }\n  }\n\n  return data;\n};\n\nexport class Histogram extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = this.prepState(props);\n  }\n\n  prepState(props, withConfig = true) {\n    let state = null;\n    const {\n      alignedFrame\n    } = props;\n\n    if (alignedFrame) {\n      state = {\n        alignedData: preparePlotData(alignedFrame)\n      };\n\n      if (withConfig) {\n        state.config = prepConfig(alignedFrame, this.props.theme);\n      }\n    }\n\n    return state;\n  }\n\n  renderLegend(config) {\n    const {\n      legend\n    } = this.props;\n\n    if (!config || legend.displayMode === LegendDisplayMode.Hidden) {\n      return null;\n    }\n\n    return /*#__PURE__*/_jsx(PlotLegend, Object.assign({\n      data: [this.props.alignedFrame],\n      config: config,\n      maxHeight: \"35%\",\n      maxWidth: \"60%\"\n    }, legend));\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      structureRev,\n      alignedFrame,\n      bucketSize\n    } = this.props;\n\n    if (alignedFrame !== prevProps.alignedFrame) {\n      let newState = this.prepState(this.props, false);\n\n      if (newState) {\n        const shouldReconfig = bucketSize !== prevProps.bucketSize || this.props.options !== prevProps.options || this.state.config === undefined || structureRev !== prevProps.structureRev || !structureRev;\n\n        if (shouldReconfig) {\n          newState.config = prepConfig(alignedFrame, this.props.theme);\n        }\n      }\n\n      newState && this.setState(newState);\n    }\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      children,\n      alignedFrame\n    } = this.props;\n    const {\n      config\n    } = this.state;\n\n    if (!config) {\n      return null;\n    }\n\n    return /*#__PURE__*/_jsx(VizLayout, {\n      width: width,\n      height: height,\n      legend: this.renderLegend(config),\n      children: (vizWidth, vizHeight) => /*#__PURE__*/_jsx(UPlotChart, {\n        config: this.state.config,\n        data: this.state.alignedData,\n        width: vizWidth,\n        height: vizHeight,\n        timeRange: null,\n        children: children ? children(config, alignedFrame) : null\n      })\n    });\n  }\n\n}","map":{"version":3,"names":["React","uPlot","formattedValueToString","getFieldColorModeForField","getFieldSeriesColor","histogramBucketSizes","histogramFrameBucketMaxFieldName","LegendDisplayMode","ScaleDistribution","AxisPlacement","ScaleDirection","ScaleOrientation","UPlotConfigBuilder","UPlotChart","VizLayout","PlotLegend","measureText","UPLOT_AXIS_FONT_SIZE","incrRoundDn","num","incr","Math","floor","incrRoundUp","ceil","getBucketSize","frame","fields","values","get","prepConfig","theme","builder","bucketSize","xSplits","u","axisIdx","scaleMin","scaleMax","foundIncr","foundSpace","minSpace","axes","_space","bucketWidth","valToPos","data","firstSplit","lastSplit","length","splits","skip","i","s","push","addScale","scaleKey","isTime","distribution","Linear","orientation","Horizontal","direction","Right","range","wantedMin","wantedMax","fullRangeMin","fullRangeMax","Vertical","Up","fmt","display","xAxisFormatter","v","addAxis","placement","Bottom","incrs","tickLabels","map","maxWidth","reduce","curMax","label","max","width","labelSpacing","maxCount","bbox","devicePixelRatio","keepMod","Left","setCursor","points","show","drag","x","y","setScale","pathBuilder","paths","bars","align","size","Infinity","seriesIndex","field","state","customConfig","config","custom","colorMode","scaleColor","seriesColor","color","addSeries","lineWidth","lineColor","fillOpacity","hideFrom","vis","gradientMode","thresholds","hardMin","min","hardMax","softMin","axisSoftMin","softMax","axisSoftMax","dataFrameFieldIndex","fieldIndex","frameIndex","preparePlotData","name","toArray","counts","j","Histogram","Component","constructor","props","prepState","withConfig","alignedFrame","alignedData","renderLegend","legend","displayMode","Hidden","componentDidUpdate","prevProps","structureRev","newState","shouldReconfig","options","undefined","setState","render","height","children","vizWidth","vizHeight"],"sources":["/home/soula/grafana/public/app/plugins/panel/histogram/Histogram.tsx"],"sourcesContent":["import React from 'react';\nimport uPlot, { AlignedData } from 'uplot';\n\nimport {\n  DataFrame,\n  formattedValueToString,\n  getFieldColorModeForField,\n  getFieldSeriesColor,\n  GrafanaTheme2,\n} from '@grafana/data';\nimport {\n  histogramBucketSizes,\n  histogramFrameBucketMaxFieldName,\n} from '@grafana/data/src/transformations/transformers/histogram';\nimport {\n  VizLegendOptions,\n  LegendDisplayMode,\n  ScaleDistribution,\n  AxisPlacement,\n  ScaleDirection,\n  ScaleOrientation,\n} from '@grafana/schema';\nimport {\n  Themeable2,\n  UPlotConfigBuilder,\n  UPlotChart,\n  VizLayout,\n  PlotLegend,\n  measureText,\n  UPLOT_AXIS_FONT_SIZE,\n} from '@grafana/ui';\n\nimport { PanelOptions } from './models.gen';\n\nfunction incrRoundDn(num: number, incr: number) {\n  return Math.floor(num / incr) * incr;\n}\n\nfunction incrRoundUp(num: number, incr: number) {\n  return Math.ceil(num / incr) * incr;\n}\n\nexport interface HistogramProps extends Themeable2 {\n  options: PanelOptions; // used for diff\n  alignedFrame: DataFrame; // This could take HistogramFields\n  bucketSize: number;\n  width: number;\n  height: number;\n  structureRev?: number; // a number that will change when the frames[] structure changes\n  legend: VizLegendOptions;\n  children?: (builder: UPlotConfigBuilder, frame: DataFrame) => React.ReactNode;\n}\n\nexport function getBucketSize(frame: DataFrame) {\n  // assumes BucketMin is fields[0] and BucktMax is fields[1]\n  return frame.fields[1].values.get(0) - frame.fields[0].values.get(0);\n}\n\nconst prepConfig = (frame: DataFrame, theme: GrafanaTheme2) => {\n  // todo: scan all values in BucketMin and BucketMax fields to assert if uniform bucketSize\n\n  let builder = new UPlotConfigBuilder();\n\n  // assumes BucketMin is fields[0] and BucktMax is fields[1]\n  let bucketSize = getBucketSize(frame);\n\n  // splits shifter, to ensure splits always start at first bucket\n  let xSplits: uPlot.Axis.Splits = (u, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {\n    /** @ts-ignore */\n    let minSpace = u.axes[axisIdx]._space;\n    let bucketWidth = u.valToPos(u.data[0][0] + bucketSize, 'x') - u.valToPos(u.data[0][0], 'x');\n\n    let firstSplit = u.data[0][0];\n    let lastSplit = u.data[0][u.data[0].length - 1] + bucketSize;\n\n    let splits = [];\n    let skip = Math.ceil(minSpace / bucketWidth);\n\n    for (let i = 0, s = firstSplit; s <= lastSplit; i++, s += bucketSize) {\n      !(i % skip) && splits.push(s);\n    }\n\n    return splits;\n  };\n\n  builder.addScale({\n    scaleKey: 'x', // bukkits\n    isTime: false,\n    distribution: ScaleDistribution.Linear,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    range: (u, wantedMin, wantedMax) => {\n      let fullRangeMin = u.data[0][0];\n      let fullRangeMax = u.data[0][u.data[0].length - 1];\n\n      // snap to bucket divisors...\n\n      if (wantedMax === fullRangeMax) {\n        wantedMax += bucketSize;\n      } else {\n        wantedMax = incrRoundUp(wantedMax, bucketSize);\n      }\n\n      if (wantedMin > fullRangeMin) {\n        wantedMin = incrRoundDn(wantedMin, bucketSize);\n      }\n\n      return [wantedMin, wantedMax];\n    },\n  });\n\n  builder.addScale({\n    scaleKey: 'y', // counts\n    isTime: false,\n    distribution: ScaleDistribution.Linear,\n    orientation: ScaleOrientation.Vertical,\n    direction: ScaleDirection.Up,\n  });\n\n  const fmt = frame.fields[0].display!;\n  const xAxisFormatter = (v: number) => {\n    return formattedValueToString(fmt(v));\n  };\n\n  builder.addAxis({\n    scaleKey: 'x',\n    isTime: false,\n    placement: AxisPlacement.Bottom,\n    incrs: histogramBucketSizes,\n    splits: xSplits,\n    values: (u: uPlot, splits: any[]) => {\n      const tickLabels = splits.map(xAxisFormatter);\n\n      const maxWidth = tickLabels.reduce(\n        (curMax, label) => Math.max(measureText(label, UPLOT_AXIS_FONT_SIZE).width, curMax),\n        0\n      );\n\n      const labelSpacing = 10;\n      const maxCount = u.bbox.width / ((maxWidth + labelSpacing) * devicePixelRatio);\n      const keepMod = Math.ceil(tickLabels.length / maxCount);\n\n      return tickLabels.map((label, i) => (i % keepMod === 0 ? label : null));\n    },\n    //incrs: () => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((mult) => mult * bucketSize),\n    //splits: config.xSplits,\n    //values: config.xValues,\n    //grid: false,\n    //ticks: false,\n    //gap: 15,\n    theme,\n  });\n\n  builder.addAxis({\n    scaleKey: 'y',\n    isTime: false,\n    placement: AxisPlacement.Left,\n    //splits: config.xSplits,\n    //values: config.xValues,\n    //grid: false,\n    //ticks: false,\n    //gap: 15,\n    theme,\n  });\n\n  builder.setCursor({\n    points: { show: false },\n    drag: {\n      x: true,\n      y: false,\n      setScale: true,\n    },\n  });\n\n  let pathBuilder = uPlot.paths.bars!({ align: 1, size: [1, Infinity] });\n\n  let seriesIndex = 0;\n\n  // assumes BucketMax is [1]\n  for (let i = 2; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n\n    field.state = field.state ?? {};\n    field.state.seriesIndex = seriesIndex++;\n\n    const customConfig = { ...field.config.custom };\n\n    const scaleKey = 'y';\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n\n    builder.addSeries({\n      scaleKey,\n      lineWidth: customConfig.lineWidth,\n      lineColor: seriesColor,\n      //lineStyle: customConfig.lineStyle,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      colorMode,\n      pathBuilder,\n      //pointsBuilder: config.drawPoints,\n      show: !customConfig.hideFrom?.vis,\n      gradientMode: customConfig.gradientMode,\n      thresholds: field.config.thresholds,\n\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: {\n        fieldIndex: i,\n        frameIndex: 0,\n      },\n    });\n  }\n\n  return builder;\n};\n\nconst preparePlotData = (frame: DataFrame) => {\n  let data: AlignedData = [] as any;\n\n  for (const field of frame.fields) {\n    if (field.name !== histogramFrameBucketMaxFieldName) {\n      data.push(field.values.toArray());\n    }\n  }\n\n  // uPlot's bars pathBuilder will draw rects even if 0 (to distinguish them from nulls)\n  // but for histograms we want to omit them, so remap 0s -> nulls\n  for (let i = 1; i < data.length; i++) {\n    let counts = data[i];\n    for (let j = 0; j < counts.length; j++) {\n      if (counts[j] === 0) {\n        counts[j] = null;\n      }\n    }\n  }\n\n  return data;\n};\n\ninterface State {\n  alignedData: AlignedData;\n  config?: UPlotConfigBuilder;\n}\n\nexport class Histogram extends React.Component<HistogramProps, State> {\n  constructor(props: HistogramProps) {\n    super(props);\n    this.state = this.prepState(props);\n  }\n\n  prepState(props: HistogramProps, withConfig = true) {\n    let state: State = null as any;\n\n    const { alignedFrame } = props;\n    if (alignedFrame) {\n      state = {\n        alignedData: preparePlotData(alignedFrame),\n      };\n\n      if (withConfig) {\n        state.config = prepConfig(alignedFrame, this.props.theme);\n      }\n    }\n\n    return state;\n  }\n\n  renderLegend(config: UPlotConfigBuilder) {\n    const { legend } = this.props;\n    if (!config || legend.displayMode === LegendDisplayMode.Hidden) {\n      return null;\n    }\n\n    return <PlotLegend data={[this.props.alignedFrame]} config={config} maxHeight=\"35%\" maxWidth=\"60%\" {...legend} />;\n  }\n\n  componentDidUpdate(prevProps: HistogramProps) {\n    const { structureRev, alignedFrame, bucketSize } = this.props;\n\n    if (alignedFrame !== prevProps.alignedFrame) {\n      let newState = this.prepState(this.props, false);\n\n      if (newState) {\n        const shouldReconfig =\n          bucketSize !== prevProps.bucketSize ||\n          this.props.options !== prevProps.options ||\n          this.state.config === undefined ||\n          structureRev !== prevProps.structureRev ||\n          !structureRev;\n\n        if (shouldReconfig) {\n          newState.config = prepConfig(alignedFrame, this.props.theme);\n        }\n      }\n\n      newState && this.setState(newState);\n    }\n  }\n\n  render() {\n    const { width, height, children, alignedFrame } = this.props;\n    const { config } = this.state;\n\n    if (!config) {\n      return null;\n    }\n\n    return (\n      <VizLayout width={width} height={height} legend={this.renderLegend(config)}>\n        {(vizWidth: number, vizHeight: number) => (\n          <UPlotChart\n            config={this.state.config!}\n            data={this.state.alignedData}\n            width={vizWidth}\n            height={vizHeight}\n            timeRange={null as any}\n          >\n            {children ? children(config, alignedFrame) : null}\n          </UPlotChart>\n        )}\n      </VizLayout>\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}