{"ast":null,"code":"import React, { useMemo } from 'react';\nimport { MultiSelect } from '@grafana/ui';\nimport { INPUT_WIDTH, SYSTEM_LABELS } from '../constants';\nimport { labelsToGroupedOptions } from '../functions';\nimport { Aggregation, QueryEditorRow } from '.';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nexport const GroupBy = ({\n  refId,\n  labels: groupBys = [],\n  query,\n  onChange,\n  variableOptionGroup,\n  metricDescriptor\n}) => {\n  var _query$groupBys, _query$groupBys2;\n\n  const options = useMemo(() => [variableOptionGroup, ...labelsToGroupedOptions([...groupBys, ...SYSTEM_LABELS])], [groupBys, variableOptionGroup]);\n  return /*#__PURE__*/_jsxs(QueryEditorRow, {\n    label: \"Group by\",\n    tooltip: \"You can reduce the amount of data returned for a metric by combining different time series. To combine multiple time series, you can specify a grouping and a function. Grouping is done on the basis of labels. The grouping function is used to combine the time series in the group into a single time series.\",\n    htmlFor: `${refId}-group-by`,\n    children: [/*#__PURE__*/_jsx(MultiSelect, {\n      inputId: `${refId}-group-by`,\n      width: INPUT_WIDTH,\n      placeholder: \"Choose label\",\n      options: options,\n      value: (_query$groupBys = query.groupBys) !== null && _query$groupBys !== void 0 ? _query$groupBys : [],\n      onChange: options => {\n        onChange(Object.assign({}, query, {\n          groupBys: options.map(o => o.value)\n        }));\n      }\n    }), /*#__PURE__*/_jsx(Aggregation, {\n      metricDescriptor: metricDescriptor,\n      templateVariableOptions: variableOptionGroup.options,\n      crossSeriesReducer: query.crossSeriesReducer,\n      groupBys: (_query$groupBys2 = query.groupBys) !== null && _query$groupBys2 !== void 0 ? _query$groupBys2 : [],\n      onChange: crossSeriesReducer => onChange(Object.assign({}, query, {\n        crossSeriesReducer\n      })),\n      refId: refId\n    })]\n  });\n};","map":{"version":3,"names":["React","useMemo","MultiSelect","INPUT_WIDTH","SYSTEM_LABELS","labelsToGroupedOptions","Aggregation","QueryEditorRow","GroupBy","refId","labels","groupBys","query","onChange","variableOptionGroup","metricDescriptor","options","map","o","value","crossSeriesReducer"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloud-monitoring/components/GroupBy.tsx"],"sourcesContent":["import React, { FunctionComponent, useMemo } from 'react';\n\nimport { SelectableValue } from '@grafana/data';\nimport { MultiSelect } from '@grafana/ui';\n\nimport { INPUT_WIDTH, SYSTEM_LABELS } from '../constants';\nimport { labelsToGroupedOptions } from '../functions';\nimport { MetricDescriptor, MetricQuery } from '../types';\n\nimport { Aggregation, QueryEditorRow } from '.';\n\nexport interface Props {\n  refId: string;\n  variableOptionGroup: SelectableValue<string>;\n  labels: string[];\n  metricDescriptor?: MetricDescriptor;\n  onChange: (query: MetricQuery) => void;\n  query: MetricQuery;\n}\n\nexport const GroupBy: FunctionComponent<Props> = ({\n  refId,\n  labels: groupBys = [],\n  query,\n  onChange,\n  variableOptionGroup,\n  metricDescriptor,\n}) => {\n  const options = useMemo(\n    () => [variableOptionGroup, ...labelsToGroupedOptions([...groupBys, ...SYSTEM_LABELS])],\n    [groupBys, variableOptionGroup]\n  );\n\n  return (\n    <QueryEditorRow\n      label=\"Group by\"\n      tooltip=\"You can reduce the amount of data returned for a metric by combining different time series. To combine multiple time series, you can specify a grouping and a function. Grouping is done on the basis of labels. The grouping function is used to combine the time series in the group into a single time series.\"\n      htmlFor={`${refId}-group-by`}\n    >\n      <MultiSelect\n        inputId={`${refId}-group-by`}\n        width={INPUT_WIDTH}\n        placeholder=\"Choose label\"\n        options={options}\n        value={query.groupBys ?? []}\n        onChange={(options) => {\n          onChange({ ...query, groupBys: options.map((o) => o.value!) });\n        }}\n      ></MultiSelect>\n      <Aggregation\n        metricDescriptor={metricDescriptor}\n        templateVariableOptions={variableOptionGroup.options}\n        crossSeriesReducer={query.crossSeriesReducer}\n        groupBys={query.groupBys ?? []}\n        onChange={(crossSeriesReducer) => onChange({ ...query, crossSeriesReducer })}\n        refId={refId}\n      ></Aggregation>\n    </QueryEditorRow>\n  );\n};\n"],"mappings":"AAAA,OAAOA,KAAP,IAAmCC,OAAnC,QAAkD,OAAlD;AAGA,SAASC,WAAT,QAA4B,aAA5B;AAEA,SAASC,WAAT,EAAsBC,aAAtB,QAA2C,cAA3C;AACA,SAASC,sBAAT,QAAuC,cAAvC;AAGA,SAASC,WAAT,EAAsBC,cAAtB,QAA4C,GAA5C;;;AAWA,OAAO,MAAMC,OAAiC,GAAG,CAAC;EAChDC,KADgD;EAEhDC,MAAM,EAAEC,QAAQ,GAAG,EAF6B;EAGhDC,KAHgD;EAIhDC,QAJgD;EAKhDC,mBALgD;EAMhDC;AANgD,CAAD,KAO3C;EAAA;;EACJ,MAAMC,OAAO,GAAGf,OAAO,CACrB,MAAM,CAACa,mBAAD,EAAsB,GAAGT,sBAAsB,CAAC,CAAC,GAAGM,QAAJ,EAAc,GAAGP,aAAjB,CAAD,CAA/C,CADe,EAErB,CAACO,QAAD,EAAWG,mBAAX,CAFqB,CAAvB;EAKA,oBACE,MAAC,cAAD;IACE,KAAK,EAAC,UADR;IAEE,OAAO,EAAC,mTAFV;IAGE,OAAO,EAAG,GAAEL,KAAM,WAHpB;IAAA,wBAKE,KAAC,WAAD;MACE,OAAO,EAAG,GAAEA,KAAM,WADpB;MAEE,KAAK,EAAEN,WAFT;MAGE,WAAW,EAAC,cAHd;MAIE,OAAO,EAAEa,OAJX;MAKE,KAAK,qBAAEJ,KAAK,CAACD,QAAR,6DAAoB,EAL3B;MAME,QAAQ,EAAGK,OAAD,IAAa;QACrBH,QAAQ,mBAAMD,KAAN;UAAaD,QAAQ,EAAEK,OAAO,CAACC,GAAR,CAAaC,CAAD,IAAOA,CAAC,CAACC,KAArB;QAAvB,GAAR;MACD;IARH,EALF,eAeE,KAAC,WAAD;MACE,gBAAgB,EAAEJ,gBADpB;MAEE,uBAAuB,EAAED,mBAAmB,CAACE,OAF/C;MAGE,kBAAkB,EAAEJ,KAAK,CAACQ,kBAH5B;MAIE,QAAQ,sBAAER,KAAK,CAACD,QAAR,+DAAoB,EAJ9B;MAKE,QAAQ,EAAGS,kBAAD,IAAwBP,QAAQ,mBAAMD,KAAN;QAAaQ;MAAb,GAL5C;MAME,KAAK,EAAEX;IANT,EAfF;EAAA,EADF;AA0BD,CAvCM"},"metadata":{},"sourceType":"module"}