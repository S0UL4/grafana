{"ast":null,"code":"import { DataFrameView, FieldColorModeId, MutableDataFrame, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\nimport { getNonOverlappingDuration, getStats, makeFrames, makeSpanMap } from '../../../core/utils/tracing';\n/**\n * Row in a trace dataFrame\n */\n\nexport function createGraphFrames(data) {\n  const {\n    nodes,\n    edges\n  } = convertTraceToGraph(data);\n  const [nodesFrame, edgesFrame] = makeFrames();\n\n  for (const node of nodes) {\n    nodesFrame.add(node);\n  }\n\n  for (const edge of edges) {\n    edgesFrame.add(edge);\n  }\n\n  return [nodesFrame, edgesFrame];\n}\n\nfunction convertTraceToGraph(data) {\n  const nodes = [];\n  const edges = [];\n  const view = new DataFrameView(data);\n  const traceDuration = findTraceDuration(view);\n  const spanMap = makeSpanMap(index => {\n    if (index >= data.length) {\n      return undefined;\n    }\n\n    const span = view.get(index);\n    return {\n      span: Object.assign({}, span),\n      id: span.spanID,\n      parentIds: span.parentSpanID ? [span.parentSpanID] : []\n    };\n  });\n\n  for (let i = 0; i < view.length; i++) {\n    var _row$serviceName;\n\n    const row = view.get(i);\n    const ranges = spanMap[row.spanID].children.map(c => {\n      const span = spanMap[c].span;\n      return [span.startTime, span.startTime + span.duration];\n    });\n    const childrenDuration = getNonOverlappingDuration(ranges);\n    const selfDuration = row.duration - childrenDuration;\n    const stats = getStats(row.duration, traceDuration, selfDuration);\n    nodes.push({\n      [Fields.id]: row.spanID,\n      [Fields.title]: (_row$serviceName = row.serviceName) !== null && _row$serviceName !== void 0 ? _row$serviceName : '',\n      [Fields.subTitle]: row.operationName,\n      [Fields.mainStat]: stats.main,\n      [Fields.secondaryStat]: stats.secondary,\n      [Fields.color]: selfDuration / traceDuration\n    }); // Sometimes some span can be missing. Don't add edges for those.\n\n    if (row.parentSpanID && spanMap[row.parentSpanID].span) {\n      edges.push({\n        [Fields.id]: row.parentSpanID + '--' + row.spanID,\n        [Fields.target]: row.spanID,\n        [Fields.source]: row.parentSpanID\n      });\n    }\n  }\n\n  return {\n    nodes,\n    edges\n  };\n}\n/**\n * Get the duration of the whole trace as it isn't a part of the response data.\n * Note: Seems like this should be the same as just longest span, but this is probably safer.\n */\n\n\nfunction findTraceDuration(view) {\n  let traceEndTime = 0;\n  let traceStartTime = Infinity;\n\n  for (let i = 0; i < view.length; i++) {\n    const row = view.get(i);\n\n    if (row.startTime < traceStartTime) {\n      traceStartTime = row.startTime;\n    }\n\n    if (row.startTime + row.duration > traceEndTime) {\n      traceEndTime = row.startTime + row.duration;\n    }\n  }\n\n  return traceEndTime - traceStartTime;\n}\n\nexport const secondsMetric = 'traces_service_graph_request_server_seconds_sum';\nexport const totalsMetric = 'traces_service_graph_request_total';\nexport const failedMetric = 'traces_service_graph_request_failed_total';\nexport const histogramMetric = 'traces_service_graph_request_server_seconds_bucket';\nexport const rateMetric = {\n  expr: 'topk(5, sum(rate(traces_spanmetrics_calls_total{}[$__range])) by (span_name))',\n  params: []\n};\nexport const errorRateMetric = {\n  expr: 'topk(5, sum(rate(traces_spanmetrics_calls_total{}[$__range])) by (span_name))',\n  params: ['status_code=\"STATUS_CODE_ERROR\"']\n};\nexport const durationMetric = {\n  expr: 'histogram_quantile(.9, sum(rate(traces_spanmetrics_latency_bucket{}[$__range])) by (le))',\n  params: []\n};\nexport const serviceMapMetrics = [secondsMetric, totalsMetric, failedMetric, histogramMetric // These are used for debugging the tempo collection so probably not useful for service map right now.\n// 'traces_service_graph_unpaired_spans_total',\n// 'traces_service_graph_untagged_spans_total',\n];\n/**\n * Map response from multiple prometheus metrics into a node graph data frames with nodes and edges.\n * @param responses\n * @param range\n */\n\nexport function mapPromMetricsToServiceMap(responses, range) {\n  const frames = getMetricFrames(responses); // First just collect data from the metrics into a map with nodes and edges as keys\n\n  const nodesMap = {};\n  const edgesMap = {}; // At this moment we don't have any error/success or other counts so we just use these 2\n\n  collectMetricData(frames[totalsMetric], 'total', totalsMetric, nodesMap, edgesMap);\n  collectMetricData(frames[secondsMetric], 'seconds', secondsMetric, nodesMap, edgesMap);\n  collectMetricData(frames[failedMetric], 'failed', failedMetric, nodesMap, edgesMap);\n  return convertToDataFrames(nodesMap, edgesMap, range);\n}\n\nfunction createServiceMapDataFrames() {\n  function createDF(name, fields) {\n    return new MutableDataFrame({\n      name,\n      fields,\n      meta: {\n        preferredVisualisationType: 'nodeGraph'\n      }\n    });\n  }\n\n  const nodes = createDF('Nodes', [{\n    name: Fields.id\n  }, {\n    name: Fields.title,\n    config: {\n      displayName: 'Service name'\n    }\n  }, {\n    name: Fields.mainStat,\n    config: {\n      unit: 'ms/r',\n      displayName: 'Average response time'\n    }\n  }, {\n    name: Fields.secondaryStat,\n    config: {\n      unit: 'r/sec',\n      displayName: 'Requests per second'\n    }\n  }, {\n    name: Fields.arc + 'success',\n    config: {\n      displayName: 'Success',\n      color: {\n        fixedColor: 'green',\n        mode: FieldColorModeId.Fixed\n      }\n    }\n  }, {\n    name: Fields.arc + 'failed',\n    config: {\n      displayName: 'Failed',\n      color: {\n        fixedColor: 'red',\n        mode: FieldColorModeId.Fixed\n      }\n    }\n  }]);\n  const edges = createDF('Edges', [{\n    name: Fields.id\n  }, {\n    name: Fields.source\n  }, {\n    name: Fields.target\n  }, {\n    name: Fields.mainStat,\n    config: {\n      unit: 'ms/r',\n      displayName: 'Average response time'\n    }\n  }, {\n    name: Fields.secondaryStat,\n    config: {\n      unit: 'r/sec',\n      displayName: 'Requests per second'\n    }\n  }]);\n  return [nodes, edges];\n}\n/**\n * Group frames from response based on ref id which is set the same as the metric name so we know which metric is where\n * and also put it into DataFrameView so it's easier to work with.\n * @param responses\n */\n\n\nfunction getMetricFrames(responses) {\n  return responses[0].data.reduce((acc, frame) => {\n    acc[frame.refId] = new DataFrameView(frame);\n    return acc;\n  }, {});\n}\n\n/**\n * Collect data from a metric into a map of nodes and edges. The metric data is modeled as counts of metric per edge\n * which is a pair of client-server nodes. This means we convert each row of the metric 1-1 to edges and than we assign\n * the metric also to server. We count the stats for server only as we show requests/transactions that particular node\n * processed not those which it generated and other stats like average transaction time then stem from that.\n * @param frame\n * @param stat\n * @param metric\n * @param nodesMap\n * @param edgesMap\n */\nfunction collectMetricData(frame, stat, metric, nodesMap, edgesMap) {\n  if (!frame) {\n    return;\n  } // The name of the value column is in this format\n  // TODO figure out if it can be changed\n\n\n  const valueName = `Value #${metric}`;\n\n  for (let i = 0; i < frame.length; i++) {\n    const row = frame.get(i);\n    const edgeId = `${row.client}_${row.server}`;\n\n    if (!edgesMap[edgeId]) {\n      // Create edge as it does not exist yet\n      edgesMap[edgeId] = {\n        target: row.server,\n        source: row.client,\n        [stat]: row[valueName]\n      };\n    } else {\n      // Add stat to edge\n      // We are adding the values if exists but that should not happen in general as there should be single row for\n      // an edge.\n      edgesMap[edgeId][stat] = (edgesMap[edgeId][stat] || 0) + row[valueName];\n    }\n\n    if (!nodesMap[row.server]) {\n      // Create node for server\n      nodesMap[row.server] = {\n        [stat]: row[valueName]\n      };\n    } else {\n      // Add stat to server node. Sum up values if there are multiple edges targeting this server node.\n      nodesMap[row.server][stat] = (nodesMap[row.server][stat] || 0) + row[valueName];\n    }\n\n    if (!nodesMap[row.client]) {\n      // Create the client node but don't add the stat as edge stats are attributed to the server node. This means for\n      // example that the number of requests in a node show how many requests it handled not how many it generated.\n      nodesMap[row.client] = {\n        [stat]: 0\n      };\n    }\n  }\n}\n\nfunction convertToDataFrames(nodesMap, edgesMap, range) {\n  const rangeMs = range.to.valueOf() - range.from.valueOf();\n  const [nodes, edges] = createServiceMapDataFrames();\n\n  for (const nodeId of Object.keys(nodesMap)) {\n    const node = nodesMap[nodeId];\n    nodes.add({\n      [Fields.id]: nodeId,\n      [Fields.title]: nodeId,\n      // NaN will not be shown in the node graph. This happens for a root client node which did not process\n      // any requests itself.\n      [Fields.mainStat]: node.total ? node.seconds / node.total * 1000 : Number.NaN,\n      // Average response time\n      [Fields.secondaryStat]: node.total ? Math.round(node.total / (rangeMs / 1000) * 100) / 100 : Number.NaN,\n      // Request per second (to 2 decimals)\n      [Fields.arc + 'success']: node.total ? (node.total - Math.min(node.failed || 0, node.total)) / node.total : 1,\n      [Fields.arc + 'failed']: node.total ? Math.min(node.failed || 0, node.total) / node.total : 0\n    });\n  }\n\n  for (const edgeId of Object.keys(edgesMap)) {\n    const edge = edgesMap[edgeId];\n    edges.add({\n      [Fields.id]: edgeId,\n      [Fields.source]: edge.source,\n      [Fields.target]: edge.target,\n      [Fields.mainStat]: edge.total ? edge.seconds / edge.total * 1000 : Number.NaN,\n      // Average response time\n      [Fields.secondaryStat]: edge.total ? Math.round(edge.total / (rangeMs / 1000) * 100) / 100 : Number.NaN // Request per second (to 2 decimals)\n\n    });\n  }\n\n  return {\n    nodes,\n    edges\n  };\n}","map":{"version":3,"names":["DataFrameView","FieldColorModeId","MutableDataFrame","NodeGraphDataFrameFieldNames","Fields","getNonOverlappingDuration","getStats","makeFrames","makeSpanMap","createGraphFrames","data","nodes","edges","convertTraceToGraph","nodesFrame","edgesFrame","node","add","edge","view","traceDuration","findTraceDuration","spanMap","index","length","undefined","span","get","id","spanID","parentIds","parentSpanID","i","row","ranges","children","map","c","startTime","duration","childrenDuration","selfDuration","stats","push","title","serviceName","subTitle","operationName","mainStat","main","secondaryStat","secondary","color","target","source","traceEndTime","traceStartTime","Infinity","secondsMetric","totalsMetric","failedMetric","histogramMetric","rateMetric","expr","params","errorRateMetric","durationMetric","serviceMapMetrics","mapPromMetricsToServiceMap","responses","range","frames","getMetricFrames","nodesMap","edgesMap","collectMetricData","convertToDataFrames","createServiceMapDataFrames","createDF","name","fields","meta","preferredVisualisationType","config","displayName","unit","arc","fixedColor","mode","Fixed","reduce","acc","frame","refId","stat","metric","valueName","edgeId","client","server","rangeMs","to","valueOf","from","nodeId","Object","keys","total","seconds","Number","NaN","Math","round","min","failed"],"sources":["/home/soula/grafana/public/app/plugins/datasource/tempo/graphTransform.ts"],"sourcesContent":["import {\n  DataFrame,\n  DataFrameView,\n  DataQueryResponse,\n  FieldColorModeId,\n  FieldDTO,\n  MutableDataFrame,\n  NodeGraphDataFrameFieldNames as Fields,\n  TimeRange,\n} from '@grafana/data';\n\nimport { getNonOverlappingDuration, getStats, makeFrames, makeSpanMap } from '../../../core/utils/tracing';\n\n/**\n * Row in a trace dataFrame\n */\ninterface Row {\n  traceID: string;\n  spanID: string;\n  parentSpanID: string;\n  operationName: string;\n  serviceName: string;\n  serviceTags: string;\n  startTime: number;\n  duration: number;\n  logs: string;\n  tags: string;\n}\n\ninterface Node {\n  [Fields.id]: string;\n  [Fields.title]: string;\n  [Fields.subTitle]: string;\n  [Fields.mainStat]: string;\n  [Fields.secondaryStat]: string;\n  [Fields.color]: number;\n}\n\ninterface Edge {\n  [Fields.id]: string;\n  [Fields.target]: string;\n  [Fields.source]: string;\n}\n\nexport function createGraphFrames(data: DataFrame): DataFrame[] {\n  const { nodes, edges } = convertTraceToGraph(data);\n  const [nodesFrame, edgesFrame] = makeFrames();\n\n  for (const node of nodes) {\n    nodesFrame.add(node);\n  }\n  for (const edge of edges) {\n    edgesFrame.add(edge);\n  }\n\n  return [nodesFrame, edgesFrame];\n}\n\nfunction convertTraceToGraph(data: DataFrame): { nodes: Node[]; edges: Edge[] } {\n  const nodes: Node[] = [];\n  const edges: Edge[] = [];\n\n  const view = new DataFrameView<Row>(data);\n\n  const traceDuration = findTraceDuration(view);\n  const spanMap = makeSpanMap((index) => {\n    if (index >= data.length) {\n      return undefined;\n    }\n    const span = view.get(index);\n    return {\n      span: { ...span },\n      id: span.spanID,\n      parentIds: span.parentSpanID ? [span.parentSpanID] : [],\n    };\n  });\n\n  for (let i = 0; i < view.length; i++) {\n    const row = view.get(i);\n\n    const ranges: Array<[number, number]> = spanMap[row.spanID].children.map((c) => {\n      const span = spanMap[c].span;\n      return [span.startTime, span.startTime + span.duration];\n    });\n    const childrenDuration = getNonOverlappingDuration(ranges);\n    const selfDuration = row.duration - childrenDuration;\n    const stats = getStats(row.duration, traceDuration, selfDuration);\n\n    nodes.push({\n      [Fields.id]: row.spanID,\n      [Fields.title]: row.serviceName ?? '',\n      [Fields.subTitle]: row.operationName,\n      [Fields.mainStat]: stats.main,\n      [Fields.secondaryStat]: stats.secondary,\n      [Fields.color]: selfDuration / traceDuration,\n    });\n\n    // Sometimes some span can be missing. Don't add edges for those.\n    if (row.parentSpanID && spanMap[row.parentSpanID].span) {\n      edges.push({\n        [Fields.id]: row.parentSpanID + '--' + row.spanID,\n        [Fields.target]: row.spanID,\n        [Fields.source]: row.parentSpanID,\n      });\n    }\n  }\n\n  return { nodes, edges };\n}\n\n/**\n * Get the duration of the whole trace as it isn't a part of the response data.\n * Note: Seems like this should be the same as just longest span, but this is probably safer.\n */\nfunction findTraceDuration(view: DataFrameView<Row>): number {\n  let traceEndTime = 0;\n  let traceStartTime = Infinity;\n\n  for (let i = 0; i < view.length; i++) {\n    const row = view.get(i);\n\n    if (row.startTime < traceStartTime) {\n      traceStartTime = row.startTime;\n    }\n\n    if (row.startTime + row.duration > traceEndTime) {\n      traceEndTime = row.startTime + row.duration;\n    }\n  }\n\n  return traceEndTime - traceStartTime;\n}\n\nexport const secondsMetric = 'traces_service_graph_request_server_seconds_sum';\nexport const totalsMetric = 'traces_service_graph_request_total';\nexport const failedMetric = 'traces_service_graph_request_failed_total';\nexport const histogramMetric = 'traces_service_graph_request_server_seconds_bucket';\n\nexport const rateMetric = {\n  expr: 'topk(5, sum(rate(traces_spanmetrics_calls_total{}[$__range])) by (span_name))',\n  params: [],\n};\nexport const errorRateMetric = {\n  expr: 'topk(5, sum(rate(traces_spanmetrics_calls_total{}[$__range])) by (span_name))',\n  params: ['status_code=\"STATUS_CODE_ERROR\"'],\n};\nexport const durationMetric = {\n  expr: 'histogram_quantile(.9, sum(rate(traces_spanmetrics_latency_bucket{}[$__range])) by (le))',\n  params: [],\n};\n\nexport const serviceMapMetrics = [\n  secondsMetric,\n  totalsMetric,\n  failedMetric,\n  histogramMetric,\n  // These are used for debugging the tempo collection so probably not useful for service map right now.\n  // 'traces_service_graph_unpaired_spans_total',\n  // 'traces_service_graph_untagged_spans_total',\n];\n\n/**\n * Map response from multiple prometheus metrics into a node graph data frames with nodes and edges.\n * @param responses\n * @param range\n */\nexport function mapPromMetricsToServiceMap(\n  responses: DataQueryResponse[],\n  range: TimeRange\n): { nodes: DataFrame; edges: DataFrame } {\n  const frames = getMetricFrames(responses);\n\n  // First just collect data from the metrics into a map with nodes and edges as keys\n  const nodesMap: Record<string, ServiceMapStatistics> = {};\n  const edgesMap: Record<string, EdgeObject> = {};\n  // At this moment we don't have any error/success or other counts so we just use these 2\n  collectMetricData(frames[totalsMetric], 'total', totalsMetric, nodesMap, edgesMap);\n  collectMetricData(frames[secondsMetric], 'seconds', secondsMetric, nodesMap, edgesMap);\n  collectMetricData(frames[failedMetric], 'failed', failedMetric, nodesMap, edgesMap);\n\n  return convertToDataFrames(nodesMap, edgesMap, range);\n}\n\nfunction createServiceMapDataFrames() {\n  function createDF(name: string, fields: FieldDTO[]) {\n    return new MutableDataFrame({ name, fields, meta: { preferredVisualisationType: 'nodeGraph' } });\n  }\n\n  const nodes = createDF('Nodes', [\n    { name: Fields.id },\n    { name: Fields.title, config: { displayName: 'Service name' } },\n    { name: Fields.mainStat, config: { unit: 'ms/r', displayName: 'Average response time' } },\n    {\n      name: Fields.secondaryStat,\n      config: { unit: 'r/sec', displayName: 'Requests per second' },\n    },\n    {\n      name: Fields.arc + 'success',\n      config: { displayName: 'Success', color: { fixedColor: 'green', mode: FieldColorModeId.Fixed } },\n    },\n    {\n      name: Fields.arc + 'failed',\n      config: { displayName: 'Failed', color: { fixedColor: 'red', mode: FieldColorModeId.Fixed } },\n    },\n  ]);\n  const edges = createDF('Edges', [\n    { name: Fields.id },\n    { name: Fields.source },\n    { name: Fields.target },\n    { name: Fields.mainStat, config: { unit: 'ms/r', displayName: 'Average response time' } },\n    { name: Fields.secondaryStat, config: { unit: 'r/sec', displayName: 'Requests per second' } },\n  ]);\n\n  return [nodes, edges];\n}\n\n/**\n * Group frames from response based on ref id which is set the same as the metric name so we know which metric is where\n * and also put it into DataFrameView so it's easier to work with.\n * @param responses\n */\nfunction getMetricFrames(responses: DataQueryResponse[]): Record<string, DataFrameView> {\n  return responses[0].data.reduce<Record<string, DataFrameView>>((acc, frame) => {\n    acc[frame.refId] = new DataFrameView(frame);\n    return acc;\n  }, {});\n}\n\ntype ServiceMapStatistics = {\n  total?: number;\n  seconds?: number;\n  failed?: number;\n};\n\ntype EdgeObject = ServiceMapStatistics & {\n  source: string;\n  target: string;\n};\n\n/**\n * Collect data from a metric into a map of nodes and edges. The metric data is modeled as counts of metric per edge\n * which is a pair of client-server nodes. This means we convert each row of the metric 1-1 to edges and than we assign\n * the metric also to server. We count the stats for server only as we show requests/transactions that particular node\n * processed not those which it generated and other stats like average transaction time then stem from that.\n * @param frame\n * @param stat\n * @param metric\n * @param nodesMap\n * @param edgesMap\n */\nfunction collectMetricData(\n  frame: DataFrameView | undefined,\n  stat: keyof ServiceMapStatistics,\n  metric: string,\n  nodesMap: Record<string, ServiceMapStatistics>,\n  edgesMap: Record<string, EdgeObject>\n) {\n  if (!frame) {\n    return;\n  }\n\n  // The name of the value column is in this format\n  // TODO figure out if it can be changed\n  const valueName = `Value #${metric}`;\n\n  for (let i = 0; i < frame.length; i++) {\n    const row = frame.get(i);\n    const edgeId = `${row.client}_${row.server}`;\n\n    if (!edgesMap[edgeId]) {\n      // Create edge as it does not exist yet\n      edgesMap[edgeId] = {\n        target: row.server,\n        source: row.client,\n        [stat]: row[valueName],\n      };\n    } else {\n      // Add stat to edge\n      // We are adding the values if exists but that should not happen in general as there should be single row for\n      // an edge.\n      edgesMap[edgeId][stat] = (edgesMap[edgeId][stat] || 0) + row[valueName];\n    }\n\n    if (!nodesMap[row.server]) {\n      // Create node for server\n      nodesMap[row.server] = {\n        [stat]: row[valueName],\n      };\n    } else {\n      // Add stat to server node. Sum up values if there are multiple edges targeting this server node.\n      nodesMap[row.server][stat] = (nodesMap[row.server][stat] || 0) + row[valueName];\n    }\n\n    if (!nodesMap[row.client]) {\n      // Create the client node but don't add the stat as edge stats are attributed to the server node. This means for\n      // example that the number of requests in a node show how many requests it handled not how many it generated.\n      nodesMap[row.client] = {\n        [stat]: 0,\n      };\n    }\n  }\n}\n\nfunction convertToDataFrames(\n  nodesMap: Record<string, ServiceMapStatistics>,\n  edgesMap: Record<string, EdgeObject>,\n  range: TimeRange\n): { nodes: DataFrame; edges: DataFrame } {\n  const rangeMs = range.to.valueOf() - range.from.valueOf();\n  const [nodes, edges] = createServiceMapDataFrames();\n  for (const nodeId of Object.keys(nodesMap)) {\n    const node = nodesMap[nodeId];\n    nodes.add({\n      [Fields.id]: nodeId,\n      [Fields.title]: nodeId,\n      // NaN will not be shown in the node graph. This happens for a root client node which did not process\n      // any requests itself.\n      [Fields.mainStat]: node.total ? (node.seconds! / node.total) * 1000 : Number.NaN, // Average response time\n      [Fields.secondaryStat]: node.total ? Math.round((node.total / (rangeMs / 1000)) * 100) / 100 : Number.NaN, // Request per second (to 2 decimals)\n      [Fields.arc + 'success']: node.total ? (node.total - Math.min(node.failed || 0, node.total)) / node.total : 1,\n      [Fields.arc + 'failed']: node.total ? Math.min(node.failed || 0, node.total) / node.total : 0,\n    });\n  }\n  for (const edgeId of Object.keys(edgesMap)) {\n    const edge = edgesMap[edgeId];\n    edges.add({\n      [Fields.id]: edgeId,\n      [Fields.source]: edge.source,\n      [Fields.target]: edge.target,\n      [Fields.mainStat]: edge.total ? (edge.seconds! / edge.total) * 1000 : Number.NaN, // Average response time\n      [Fields.secondaryStat]: edge.total ? Math.round((edge.total / (rangeMs / 1000)) * 100) / 100 : Number.NaN, // Request per second (to 2 decimals)\n    });\n  }\n\n  return { nodes, edges };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}