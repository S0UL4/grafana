{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { ArrayVector, DataFrameView, FieldType, getDisplayProcessor } from '@grafana/data';\nimport { config } from '@grafana/runtime';\nimport { backendSrv } from 'app/core/services/backend_srv';\nimport { replaceCurrentFolderQuery } from './utils';\nexport class SQLSearcher {\n  constructor() {\n    _defineProperty(this, \"locationInfo\", {\n      general: {\n        kind: 'folder',\n        name: 'General',\n        url: '/dashboards',\n        folderId: 0\n      }\n    });\n  }\n\n  // share location info with everyone\n  async search(query) {\n    var _query$facet, _query$limit, _query$query, _query$location;\n\n    if ((_query$facet = query.facet) !== null && _query$facet !== void 0 && _query$facet.length) {\n      throw 'facets not supported!';\n    }\n\n    const q = {\n      limit: (_query$limit = query.limit) !== null && _query$limit !== void 0 ? _query$limit : 1000,\n      // default 1k max values\n      tag: query.tags,\n      sort: query.sort\n    };\n    query = await replaceCurrentFolderQuery(query);\n\n    if (query.query === '*') {\n      var _query$kind;\n\n      if (((_query$kind = query.kind) === null || _query$kind === void 0 ? void 0 : _query$kind.length) === 1 && query.kind[0] === 'folder') {\n        q.type = 'dash-folder';\n      }\n    } else if ((_query$query = query.query) !== null && _query$query !== void 0 && _query$query.length) {\n      q.query = query.query;\n    }\n\n    if (query.uid) {\n      q.dashboardUID = query.uid;\n    } else if ((_query$location = query.location) !== null && _query$location !== void 0 && _query$location.length) {\n      var _info$folderId;\n\n      let info = this.locationInfo[query.location];\n\n      if (!info) {\n        // This will load all folder folders\n        await this.doAPIQuery({\n          type: 'dash-folder',\n          limit: 999\n        });\n        info = this.locationInfo[query.location];\n      }\n\n      q.folderIds = [(_info$folderId = info.folderId) !== null && _info$folderId !== void 0 ? _info$folderId : 0];\n    }\n\n    return this.doAPIQuery(q);\n  } // returns the appropriate sorting options\n\n\n  async getSortOptions() {\n    // {\n    //   \"sortOptions\": [\n    //     {\n    //       \"description\": \"Sort results in an alphabetically ascending order\",\n    //       \"displayName\": \"Alphabetically (A–Z)\",\n    //       \"meta\": \"\",\n    //       \"name\": \"alpha-asc\"\n    //     },\n    //     {\n    //       \"description\": \"Sort results in an alphabetically descending order\",\n    //       \"displayName\": \"Alphabetically (Z–A)\",\n    //       \"meta\": \"\",\n    //       \"name\": \"alpha-desc\"\n    //     }\n    //   ]\n    // }\n    const opts = await backendSrv.get('/api/search/sorting');\n    return opts.sortOptions.map(v => ({\n      value: v.name,\n      label: v.displayName\n    }));\n  } // NOTE: the bluge query will find tags within the current results, the SQL based one does not\n\n\n  async tags(query) {\n    const terms = await backendSrv.get('/api/dashboards/tags');\n    return terms.sort((a, b) => b.count - a.count);\n  }\n\n  async doAPIQuery(query) {\n    var _sortMetaName;\n\n    const rsp = await backendSrv.get('/api/search', query); // Field values (columnar)\n\n    const kind = [];\n    const name = [];\n    const uid = [];\n    const url = [];\n    const tags = [];\n    const location = [];\n    const sortBy = [];\n    let sortMetaName;\n\n    for (let hit of rsp) {\n      var _hit$sortMetaName;\n\n      const k = hit.type === 'dash-folder' ? 'folder' : 'dashboard';\n      kind.push(k);\n      name.push(hit.title);\n      uid.push(hit.uid);\n      url.push(hit.url);\n      tags.push(hit.tags);\n      sortBy.push(hit.sortMeta);\n      let v = hit.folderUid;\n\n      if (!v && k === 'dashboard') {\n        v = 'general';\n      }\n\n      location.push(v);\n\n      if ((_hit$sortMetaName = hit.sortMetaName) !== null && _hit$sortMetaName !== void 0 && _hit$sortMetaName.length) {\n        sortMetaName = hit.sortMetaName;\n      }\n\n      if (hit.folderUid && hit.folderTitle) {\n        this.locationInfo[hit.folderUid] = {\n          kind: 'folder',\n          name: hit.folderTitle,\n          url: hit.folderUrl,\n          folderId: hit.folderId\n        };\n      } else if (k === 'folder') {\n        this.locationInfo[hit.uid] = {\n          kind: k,\n          name: hit.title,\n          url: hit.url,\n          folderId: hit.id\n        };\n      }\n    }\n\n    const data = {\n      fields: [{\n        name: 'kind',\n        type: FieldType.string,\n        config: {},\n        values: new ArrayVector(kind)\n      }, {\n        name: 'name',\n        type: FieldType.string,\n        config: {},\n        values: new ArrayVector(name)\n      }, {\n        name: 'uid',\n        type: FieldType.string,\n        config: {},\n        values: new ArrayVector(uid)\n      }, {\n        name: 'url',\n        type: FieldType.string,\n        config: {},\n        values: new ArrayVector(url)\n      }, {\n        name: 'tags',\n        type: FieldType.other,\n        config: {},\n        values: new ArrayVector(tags)\n      }, {\n        name: 'location',\n        type: FieldType.string,\n        config: {},\n        values: new ArrayVector(location)\n      }],\n      length: name.length,\n      meta: {\n        custom: {\n          count: name.length,\n          max_score: 1,\n          locationInfo: this.locationInfo\n        }\n      }\n    }; // Add enterprise sort fields as a field in the frame\n\n    if ((_sortMetaName = sortMetaName) !== null && _sortMetaName !== void 0 && _sortMetaName.length && sortBy.length) {\n      data.meta.custom.sortBy = sortMetaName;\n      data.fields.push({\n        name: sortMetaName,\n        // Used in display\n        type: FieldType.number,\n        config: {},\n        values: new ArrayVector(sortBy)\n      });\n    }\n\n    for (const field of data.fields) {\n      field.display = getDisplayProcessor({\n        field,\n        theme: config.theme2\n      });\n    }\n\n    const view = new DataFrameView(data);\n    return {\n      totalRows: data.length,\n      view,\n      // Paging not supported with this version\n      loadMoreItems: async (startIndex, stopIndex) => {},\n      isItemLoaded: index => true\n    };\n  }\n\n}","map":{"version":3,"names":["ArrayVector","DataFrameView","FieldType","getDisplayProcessor","config","backendSrv","replaceCurrentFolderQuery","SQLSearcher","general","kind","name","url","folderId","search","query","facet","length","q","limit","tag","tags","sort","type","uid","dashboardUID","location","info","locationInfo","doAPIQuery","folderIds","getSortOptions","opts","get","sortOptions","map","v","value","label","displayName","terms","a","b","count","rsp","sortBy","sortMetaName","hit","k","push","title","sortMeta","folderUid","folderTitle","folderUrl","id","data","fields","string","values","other","meta","custom","max_score","number","field","display","theme","theme2","view","totalRows","loadMoreItems","startIndex","stopIndex","isItemLoaded","index"],"sources":["/home/soula/grafana/public/app/features/search/service/sql.ts"],"sourcesContent":["import { ArrayVector, DataFrame, DataFrameView, FieldType, getDisplayProcessor, SelectableValue } from '@grafana/data';\nimport { config } from '@grafana/runtime';\nimport { TermCount } from 'app/core/components/TagFilter/TagFilter';\nimport { backendSrv } from 'app/core/services/backend_srv';\n\nimport { DashboardSearchHit } from '../types';\n\nimport { LocationInfo } from './types';\nimport { replaceCurrentFolderQuery } from './utils';\n\nimport { DashboardQueryResult, GrafanaSearcher, QueryResponse, SearchQuery } from '.';\n\ninterface APIQuery {\n  query?: string;\n  tag?: string[];\n  limit?: number;\n  page?: number;\n  type?: string;\n  // DashboardIds []int64\n  dashboardUID?: string[];\n  folderIds?: number[];\n  sort?: string;\n}\n\n// Internal object to hold folderId\ninterface LocationInfoEXT extends LocationInfo {\n  folderId?: number;\n}\n\nexport class SQLSearcher implements GrafanaSearcher {\n  locationInfo: Record<string, LocationInfoEXT> = {\n    general: {\n      kind: 'folder',\n      name: 'General',\n      url: '/dashboards',\n      folderId: 0,\n    },\n  }; // share location info with everyone\n\n  async search(query: SearchQuery): Promise<QueryResponse> {\n    if (query.facet?.length) {\n      throw 'facets not supported!';\n    }\n    const q: APIQuery = {\n      limit: query.limit ?? 1000, // default 1k max values\n      tag: query.tags,\n      sort: query.sort,\n    };\n\n    query = await replaceCurrentFolderQuery(query);\n    if (query.query === '*') {\n      if (query.kind?.length === 1 && query.kind[0] === 'folder') {\n        q.type = 'dash-folder';\n      }\n    } else if (query.query?.length) {\n      q.query = query.query;\n    }\n\n    if (query.uid) {\n      q.dashboardUID = query.uid;\n    } else if (query.location?.length) {\n      let info = this.locationInfo[query.location];\n      if (!info) {\n        // This will load all folder folders\n        await this.doAPIQuery({ type: 'dash-folder', limit: 999 });\n        info = this.locationInfo[query.location];\n      }\n      q.folderIds = [info.folderId ?? 0];\n    }\n    return this.doAPIQuery(q);\n  }\n\n  // returns the appropriate sorting options\n  async getSortOptions(): Promise<SelectableValue[]> {\n    // {\n    //   \"sortOptions\": [\n    //     {\n    //       \"description\": \"Sort results in an alphabetically ascending order\",\n    //       \"displayName\": \"Alphabetically (A–Z)\",\n    //       \"meta\": \"\",\n    //       \"name\": \"alpha-asc\"\n    //     },\n    //     {\n    //       \"description\": \"Sort results in an alphabetically descending order\",\n    //       \"displayName\": \"Alphabetically (Z–A)\",\n    //       \"meta\": \"\",\n    //       \"name\": \"alpha-desc\"\n    //     }\n    //   ]\n    // }\n    const opts = await backendSrv.get('/api/search/sorting');\n    return opts.sortOptions.map((v: any) => ({\n      value: v.name,\n      label: v.displayName,\n    }));\n  }\n\n  // NOTE: the bluge query will find tags within the current results, the SQL based one does not\n  async tags(query: SearchQuery): Promise<TermCount[]> {\n    const terms = (await backendSrv.get('/api/dashboards/tags')) as TermCount[];\n    return terms.sort((a, b) => b.count - a.count);\n  }\n\n  async doAPIQuery(query: APIQuery): Promise<QueryResponse> {\n    const rsp = (await backendSrv.get('/api/search', query)) as DashboardSearchHit[];\n\n    // Field values (columnar)\n    const kind: string[] = [];\n    const name: string[] = [];\n    const uid: string[] = [];\n    const url: string[] = [];\n    const tags: string[][] = [];\n    const location: string[] = [];\n    const sortBy: number[] = [];\n    let sortMetaName: string | undefined;\n\n    for (let hit of rsp) {\n      const k = hit.type === 'dash-folder' ? 'folder' : 'dashboard';\n      kind.push(k);\n      name.push(hit.title);\n      uid.push(hit.uid!);\n      url.push(hit.url);\n      tags.push(hit.tags);\n      sortBy.push(hit.sortMeta!);\n\n      let v = hit.folderUid;\n      if (!v && k === 'dashboard') {\n        v = 'general';\n      }\n      location.push(v!);\n\n      if (hit.sortMetaName?.length) {\n        sortMetaName = hit.sortMetaName;\n      }\n\n      if (hit.folderUid && hit.folderTitle) {\n        this.locationInfo[hit.folderUid] = {\n          kind: 'folder',\n          name: hit.folderTitle,\n          url: hit.folderUrl!,\n          folderId: hit.folderId,\n        };\n      } else if (k === 'folder') {\n        this.locationInfo[hit.uid!] = {\n          kind: k,\n          name: hit.title!,\n          url: hit.url,\n          folderId: hit.id,\n        };\n      }\n    }\n\n    const data: DataFrame = {\n      fields: [\n        { name: 'kind', type: FieldType.string, config: {}, values: new ArrayVector(kind) },\n        { name: 'name', type: FieldType.string, config: {}, values: new ArrayVector(name) },\n        { name: 'uid', type: FieldType.string, config: {}, values: new ArrayVector(uid) },\n        { name: 'url', type: FieldType.string, config: {}, values: new ArrayVector(url) },\n        { name: 'tags', type: FieldType.other, config: {}, values: new ArrayVector(tags) },\n        { name: 'location', type: FieldType.string, config: {}, values: new ArrayVector(location) },\n      ],\n      length: name.length,\n      meta: {\n        custom: {\n          count: name.length,\n          max_score: 1,\n          locationInfo: this.locationInfo,\n        },\n      },\n    };\n\n    // Add enterprise sort fields as a field in the frame\n    if (sortMetaName?.length && sortBy.length) {\n      data.meta!.custom!.sortBy = sortMetaName;\n      data.fields.push({\n        name: sortMetaName, // Used in display\n        type: FieldType.number,\n        config: {},\n        values: new ArrayVector(sortBy),\n      });\n    }\n\n    for (const field of data.fields) {\n      field.display = getDisplayProcessor({ field, theme: config.theme2 });\n    }\n\n    const view = new DataFrameView<DashboardQueryResult>(data);\n    return {\n      totalRows: data.length,\n      view,\n\n      // Paging not supported with this version\n      loadMoreItems: async (startIndex: number, stopIndex: number): Promise<void> => {},\n      isItemLoaded: (index: number): boolean => true,\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}