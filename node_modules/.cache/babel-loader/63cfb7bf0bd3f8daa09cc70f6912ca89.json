{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { sortedUniq } from 'lodash';\nimport Prism from 'prismjs';\nimport { lastValueFrom } from 'rxjs';\nimport { LanguageProvider } from '@grafana/data';\nimport { SearchFunctionType } from '@grafana/ui';\nimport syntax, { AGGREGATION_FUNCTIONS_STATS, BOOLEAN_FUNCTIONS, DATETIME_FUNCTIONS, FIELD_AND_FILTER_FUNCTIONS, IP_FUNCTIONS, NUMERIC_OPERATORS, QUERY_COMMANDS, STRING_FUNCTIONS } from './syntax';\nexport class CloudWatchLanguageProvider extends LanguageProvider {\n  constructor(datasource, initialValues) {\n    super();\n\n    _defineProperty(this, \"started\", false);\n\n    _defineProperty(this, \"datasource\", void 0);\n\n    _defineProperty(this, \"cleanText\", s => s.replace(/[()]/g, '').trim());\n\n    _defineProperty(this, \"request\", (url, params) => {\n      return lastValueFrom(this.datasource.awsRequest(url, params));\n    });\n\n    _defineProperty(this, \"start\", () => {\n      if (!this.startTask) {\n        this.startTask = Promise.resolve().then(() => {\n          this.started = true;\n          return [];\n        });\n      }\n\n      return this.startTask;\n    });\n\n    _defineProperty(this, \"fetchedFieldsCache\", void 0);\n\n    _defineProperty(this, \"fetchFields\", async (logGroups, region) => {\n      if (this.fetchedFieldsCache && Date.now() - this.fetchedFieldsCache.time < 30 * 1000 && sortedUniq(this.fetchedFieldsCache.logGroups).join('|') === sortedUniq(logGroups).join('|')) {\n        return this.fetchedFieldsCache.fields;\n      }\n\n      const results = await Promise.all(logGroups.map(logGroup => this.datasource.getLogGroupFields({\n        logGroupName: logGroup,\n        region\n      })));\n      const fields = [...new Set(results.reduce((acc, cur) => {\n        var _cur$logGroupFields;\n\n        return acc.concat((_cur$logGroupFields = cur.logGroupFields) === null || _cur$logGroupFields === void 0 ? void 0 : _cur$logGroupFields.map(f => f.name));\n      }, [])).values()];\n      this.fetchedFieldsCache = {\n        time: Date.now(),\n        logGroups,\n        fields\n      };\n      return fields;\n    });\n\n    _defineProperty(this, \"handleKeyword\", async context => {\n      var _context$logGroupName;\n\n      const suggs = await this.getFieldCompletionItems((_context$logGroupName = context === null || context === void 0 ? void 0 : context.logGroupNames) !== null && _context$logGroupName !== void 0 ? _context$logGroupName : [], (context === null || context === void 0 ? void 0 : context.region) || 'default');\n      const functionSuggestions = [{\n        searchFunctionType: SearchFunctionType.Prefix,\n        label: 'Functions',\n        items: STRING_FUNCTIONS.concat(DATETIME_FUNCTIONS, IP_FUNCTIONS)\n      }];\n      suggs.suggestions.push(...functionSuggestions);\n      return suggs;\n    });\n\n    _defineProperty(this, \"handleCommand\", async (commandToken, curToken, context) => {\n      var _commandToken$next;\n\n      const queryCommand = commandToken.content.toLowerCase();\n      const prevToken = prevNonWhitespaceToken(curToken);\n      const currentTokenIsFirstArg = prevToken === commandToken;\n\n      if (queryCommand === 'sort') {\n        return this.handleSortCommand(currentTokenIsFirstArg, curToken, context);\n      }\n\n      if (queryCommand === 'parse') {\n        if (currentTokenIsFirstArg) {\n          var _context$logGroupName2;\n\n          return await this.getFieldCompletionItems((_context$logGroupName2 = context === null || context === void 0 ? void 0 : context.logGroupNames) !== null && _context$logGroupName2 !== void 0 ? _context$logGroupName2 : [], (context === null || context === void 0 ? void 0 : context.region) || 'default');\n        }\n      }\n\n      const currentTokenIsAfterCommandAndEmpty = isTokenType(commandToken.next, 'whitespace') && !((_commandToken$next = commandToken.next) !== null && _commandToken$next !== void 0 && _commandToken$next.next);\n      const currentTokenIsAfterCommand = currentTokenIsAfterCommandAndEmpty || nextNonWhitespaceToken(commandToken) === curToken;\n      const currentTokenIsComma = isTokenType(curToken, 'punctuation', ',');\n      const currentTokenIsCommaOrAfterComma = currentTokenIsComma || isTokenType(prevToken, 'punctuation', ','); // We only show suggestions if we are after a command or after a comma which is a field separator\n\n      if (!(currentTokenIsAfterCommand || currentTokenIsCommaOrAfterComma)) {\n        return {\n          suggestions: []\n        };\n      }\n\n      if (['display', 'fields'].includes(queryCommand)) {\n        var _context$logGroupName3;\n\n        const typeaheadOutput = await this.getFieldCompletionItems((_context$logGroupName3 = context === null || context === void 0 ? void 0 : context.logGroupNames) !== null && _context$logGroupName3 !== void 0 ? _context$logGroupName3 : [], (context === null || context === void 0 ? void 0 : context.region) || 'default');\n        typeaheadOutput.suggestions.push(...this.getFieldAndFilterFunctionCompletionItems().suggestions);\n        return typeaheadOutput;\n      }\n\n      if (queryCommand === 'stats') {\n        const typeaheadOutput = this.getStatsAggCompletionItems();\n\n        if (currentTokenIsComma || currentTokenIsAfterCommandAndEmpty) {\n          typeaheadOutput === null || typeaheadOutput === void 0 ? void 0 : typeaheadOutput.suggestions.forEach(group => {\n            group.skipFilter = true;\n          });\n        }\n\n        return typeaheadOutput;\n      }\n\n      if (queryCommand === 'filter' && currentTokenIsFirstArg) {\n        var _context$logGroupName4;\n\n        const sugg = await this.getFieldCompletionItems((_context$logGroupName4 = context === null || context === void 0 ? void 0 : context.logGroupNames) !== null && _context$logGroupName4 !== void 0 ? _context$logGroupName4 : [], (context === null || context === void 0 ? void 0 : context.region) || 'default');\n        const boolFuncs = this.getBoolFuncCompletionItems();\n        sugg.suggestions.push(...boolFuncs.suggestions);\n        return sugg;\n      }\n\n      return {\n        suggestions: []\n      };\n    });\n\n    _defineProperty(this, \"handleComparison\", async context => {\n      var _context$logGroupName5;\n\n      const fieldsSuggestions = await this.getFieldCompletionItems((_context$logGroupName5 = context === null || context === void 0 ? void 0 : context.logGroupNames) !== null && _context$logGroupName5 !== void 0 ? _context$logGroupName5 : [], (context === null || context === void 0 ? void 0 : context.region) || 'default');\n      const comparisonSuggestions = this.getComparisonCompletionItems();\n      fieldsSuggestions.suggestions.push(...comparisonSuggestions.suggestions);\n      return fieldsSuggestions;\n    });\n\n    _defineProperty(this, \"getCommandCompletionItems\", () => {\n      return {\n        suggestions: [{\n          searchFunctionType: SearchFunctionType.Prefix,\n          label: 'Commands',\n          items: QUERY_COMMANDS\n        }]\n      };\n    });\n\n    _defineProperty(this, \"getFieldAndFilterFunctionCompletionItems\", () => {\n      return {\n        suggestions: [{\n          searchFunctionType: SearchFunctionType.Prefix,\n          label: 'Functions',\n          items: FIELD_AND_FILTER_FUNCTIONS\n        }]\n      };\n    });\n\n    _defineProperty(this, \"getStatsAggCompletionItems\", () => {\n      return {\n        suggestions: [{\n          searchFunctionType: SearchFunctionType.Prefix,\n          label: 'Functions',\n          items: AGGREGATION_FUNCTIONS_STATS\n        }]\n      };\n    });\n\n    _defineProperty(this, \"getBoolFuncCompletionItems\", () => {\n      return {\n        suggestions: [{\n          searchFunctionType: SearchFunctionType.Prefix,\n          label: 'Functions',\n          items: BOOLEAN_FUNCTIONS\n        }]\n      };\n    });\n\n    _defineProperty(this, \"getComparisonCompletionItems\", () => {\n      return {\n        suggestions: [{\n          searchFunctionType: SearchFunctionType.Prefix,\n          label: 'Functions',\n          items: NUMERIC_OPERATORS.concat(BOOLEAN_FUNCTIONS)\n        }]\n      };\n    });\n\n    _defineProperty(this, \"getFieldCompletionItems\", async (logGroups, region) => {\n      const fields = await this.fetchFields(logGroups, region);\n      return {\n        suggestions: [{\n          label: 'Fields',\n          items: fields.map(field => ({\n            label: field,\n            insertText: field.match(/@?[_a-zA-Z]+[_.0-9a-zA-Z]*/) ? undefined : `\\`${field}\\``\n          }))\n        }]\n      };\n    });\n\n    this.datasource = datasource;\n    Object.assign(this, initialValues);\n  } // Strip syntax chars\n\n\n  getSyntax() {\n    return syntax;\n  }\n\n  isStatsQuery(query) {\n    var _Prism$tokenize;\n\n    const grammar = this.getSyntax();\n    const tokens = (_Prism$tokenize = Prism.tokenize(query, grammar)) !== null && _Prism$tokenize !== void 0 ? _Prism$tokenize : [];\n    return !!tokens.find(token => typeof token !== 'string' && token.content.toString().toLowerCase() === 'stats' && token.type === 'query-command');\n  }\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n\n\n  async provideCompletionItems(input, context) {\n    const {\n      value\n    } = input; // Get tokens\n\n    const tokens = value === null || value === void 0 ? void 0 : value.data.get('tokens');\n\n    if (!tokens || !tokens.length) {\n      return {\n        suggestions: []\n      };\n    }\n\n    const curToken = tokens.filter(token => {\n      var _selection, _selection$start, _selection2, _selection2$start;\n\n      return token.offsets.start <= ((_selection = value.selection) === null || _selection === void 0 ? void 0 : (_selection$start = _selection.start) === null || _selection$start === void 0 ? void 0 : _selection$start.offset) && token.offsets.end >= ((_selection2 = value.selection) === null || _selection2 === void 0 ? void 0 : (_selection2$start = _selection2.start) === null || _selection2$start === void 0 ? void 0 : _selection2$start.offset);\n    })[0];\n    const isFirstToken = !curToken.prev;\n    const prevToken = prevNonWhitespaceToken(curToken);\n    const isCommandStart = isFirstToken || !isFirstToken && (prevToken === null || prevToken === void 0 ? void 0 : prevToken.types.includes('command-separator'));\n\n    if (isCommandStart) {\n      return this.getCommandCompletionItems();\n    }\n\n    if (isInsideFunctionParenthesis(curToken)) {\n      var _context$logGroupName6;\n\n      return await this.getFieldCompletionItems((_context$logGroupName6 = context === null || context === void 0 ? void 0 : context.logGroupNames) !== null && _context$logGroupName6 !== void 0 ? _context$logGroupName6 : [], (context === null || context === void 0 ? void 0 : context.region) || 'default');\n    }\n\n    if (isAfterKeyword('by', curToken)) {\n      return this.handleKeyword(context);\n    }\n\n    if (prevToken !== null && prevToken !== void 0 && prevToken.types.includes('comparison-operator')) {\n      return this.handleComparison(context);\n    }\n\n    const commandToken = previousCommandToken(curToken);\n\n    if (commandToken) {\n      return await this.handleCommand(commandToken, curToken, context);\n    }\n\n    return {\n      suggestions: []\n    };\n  }\n\n  async handleSortCommand(isFirstArgument, curToken, context) {\n    if (isFirstArgument) {\n      var _context$logGroupName7;\n\n      return await this.getFieldCompletionItems((_context$logGroupName7 = context === null || context === void 0 ? void 0 : context.logGroupNames) !== null && _context$logGroupName7 !== void 0 ? _context$logGroupName7 : [], (context === null || context === void 0 ? void 0 : context.region) || 'default');\n    } else if (isTokenType(prevNonWhitespaceToken(curToken), 'field-name')) {\n      // suggest sort options\n      return {\n        suggestions: [{\n          searchFunctionType: SearchFunctionType.Prefix,\n          label: 'Sort Order',\n          items: [{\n            label: 'asc'\n          }, {\n            label: 'desc'\n          }]\n        }]\n      };\n    }\n\n    return {\n      suggestions: []\n    };\n  }\n\n}\n\nfunction nextNonWhitespaceToken(token) {\n  let curToken = token;\n\n  while (curToken.next) {\n    if (curToken.next.types.includes('whitespace')) {\n      curToken = curToken.next;\n    } else {\n      return curToken.next;\n    }\n  }\n\n  return null;\n}\n\nfunction prevNonWhitespaceToken(token) {\n  let curToken = token;\n\n  while (curToken.prev) {\n    if (isTokenType(curToken.prev, 'whitespace')) {\n      curToken = curToken.prev;\n    } else {\n      return curToken.prev;\n    }\n  }\n\n  return null;\n}\n\nfunction previousCommandToken(startToken) {\n  let thisToken = startToken;\n\n  while (!!thisToken.prev) {\n    thisToken = thisToken.prev;\n\n    if (thisToken.types.includes('query-command') && (!thisToken.prev || isTokenType(prevNonWhitespaceToken(thisToken), 'command-separator'))) {\n      return thisToken;\n    }\n  }\n\n  return null;\n}\n\nconst funcsWithFieldArgs = ['avg', 'count', 'count_distinct', 'earliest', 'latest', 'sortsFirst', 'sortsLast', 'max', 'min', 'pct', 'stddev', 'ispresent', 'fromMillis', 'toMillis', 'isempty', 'isblank', 'isValidIp', 'isValidIpV4', 'isValidIpV6', 'isIpInSubnet', 'isIpv4InSubnet', 'isIpv6InSubnet'].map(funcName => funcName.toLowerCase());\n/**\n * Returns true if cursor is currently inside a function parenthesis for example `count(|)` or `count(@mess|)` should\n * return true.\n */\n\nfunction isInsideFunctionParenthesis(curToken) {\n  const prevToken = prevNonWhitespaceToken(curToken);\n\n  if (!prevToken) {\n    return false;\n  }\n\n  const parenthesisToken = curToken.content === '(' ? curToken : prevToken.content === '(' ? prevToken : undefined;\n\n  if (parenthesisToken) {\n    const maybeFunctionToken = prevNonWhitespaceToken(parenthesisToken);\n\n    if (maybeFunctionToken) {\n      return funcsWithFieldArgs.includes(maybeFunctionToken.content.toLowerCase()) && maybeFunctionToken.types.includes('function');\n    }\n  }\n\n  return false;\n}\n\nfunction isAfterKeyword(keyword, token) {\n  const maybeKeyword = getPreviousTokenExcluding(token, ['whitespace', 'function', 'punctuation', 'field-name', 'number']);\n\n  if (isTokenType(maybeKeyword, 'keyword', 'by')) {\n    const prev = getPreviousTokenExcluding(token, ['whitespace']);\n\n    if (prev === maybeKeyword || isTokenType(prev, 'punctuation', ',')) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isTokenType(token, type, content) {\n  if (!(token !== null && token !== void 0 && token.types.includes(type))) {\n    return false;\n  }\n\n  if (content) {\n    if ((token === null || token === void 0 ? void 0 : token.content.toLowerCase()) !== content) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getPreviousTokenExcluding(token, exclude) {\n  let curToken = token.prev;\n\n  main: while (curToken) {\n    for (const item of exclude) {\n      if (typeof item === 'string') {\n        if (curToken.types.includes(item)) {\n          curToken = curToken.prev;\n          continue main;\n        }\n      } else {\n        if (curToken.types.includes(item.type) && curToken.content.toLowerCase() === item.value) {\n          curToken = curToken.prev;\n          continue main;\n        }\n      }\n    }\n\n    break;\n  }\n\n  return curToken;\n}","map":{"version":3,"names":["sortedUniq","Prism","lastValueFrom","LanguageProvider","SearchFunctionType","syntax","AGGREGATION_FUNCTIONS_STATS","BOOLEAN_FUNCTIONS","DATETIME_FUNCTIONS","FIELD_AND_FILTER_FUNCTIONS","IP_FUNCTIONS","NUMERIC_OPERATORS","QUERY_COMMANDS","STRING_FUNCTIONS","CloudWatchLanguageProvider","constructor","datasource","initialValues","s","replace","trim","url","params","awsRequest","startTask","Promise","resolve","then","started","logGroups","region","fetchedFieldsCache","Date","now","time","join","fields","results","all","map","logGroup","getLogGroupFields","logGroupName","Set","reduce","acc","cur","concat","logGroupFields","f","name","values","context","suggs","getFieldCompletionItems","logGroupNames","functionSuggestions","searchFunctionType","Prefix","label","items","suggestions","push","commandToken","curToken","queryCommand","content","toLowerCase","prevToken","prevNonWhitespaceToken","currentTokenIsFirstArg","handleSortCommand","currentTokenIsAfterCommandAndEmpty","isTokenType","next","currentTokenIsAfterCommand","nextNonWhitespaceToken","currentTokenIsComma","currentTokenIsCommaOrAfterComma","includes","typeaheadOutput","getFieldAndFilterFunctionCompletionItems","getStatsAggCompletionItems","forEach","group","skipFilter","sugg","boolFuncs","getBoolFuncCompletionItems","fieldsSuggestions","comparisonSuggestions","getComparisonCompletionItems","fetchFields","field","insertText","match","undefined","Object","assign","getSyntax","isStatsQuery","query","grammar","tokens","tokenize","find","token","toString","type","provideCompletionItems","input","value","data","get","length","filter","offsets","start","selection","offset","end","isFirstToken","prev","isCommandStart","types","getCommandCompletionItems","isInsideFunctionParenthesis","isAfterKeyword","handleKeyword","handleComparison","previousCommandToken","handleCommand","isFirstArgument","startToken","thisToken","funcsWithFieldArgs","funcName","parenthesisToken","maybeFunctionToken","keyword","maybeKeyword","getPreviousTokenExcluding","exclude","main","item"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/language_provider.ts"],"sourcesContent":["import { sortedUniq } from 'lodash';\nimport Prism, { Grammar } from 'prismjs';\nimport { lastValueFrom } from 'rxjs';\n\nimport { AbsoluteTimeRange, HistoryItem, LanguageProvider } from '@grafana/data';\nimport { CompletionItemGroup, SearchFunctionType, Token, TypeaheadInput, TypeaheadOutput } from '@grafana/ui';\n\nimport { CloudWatchDatasource } from './datasource';\nimport syntax, {\n  AGGREGATION_FUNCTIONS_STATS,\n  BOOLEAN_FUNCTIONS,\n  DATETIME_FUNCTIONS,\n  FIELD_AND_FILTER_FUNCTIONS,\n  IP_FUNCTIONS,\n  NUMERIC_OPERATORS,\n  QUERY_COMMANDS,\n  STRING_FUNCTIONS,\n} from './syntax';\nimport { CloudWatchQuery, TSDBResponse } from './types';\n\nexport type CloudWatchHistoryItem = HistoryItem<CloudWatchQuery>;\n\ntype TypeaheadContext = {\n  history?: CloudWatchHistoryItem[];\n  absoluteRange?: AbsoluteTimeRange;\n  logGroupNames?: string[];\n  region: string;\n};\n\nexport class CloudWatchLanguageProvider extends LanguageProvider {\n  started = false;\n  declare initialRange: AbsoluteTimeRange;\n  datasource: CloudWatchDatasource;\n\n  constructor(datasource: CloudWatchDatasource, initialValues?: any) {\n    super();\n\n    this.datasource = datasource;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars\n  cleanText = (s: string) => s.replace(/[()]/g, '').trim();\n\n  getSyntax(): Grammar {\n    return syntax;\n  }\n\n  request = (url: string, params?: any): Promise<TSDBResponse> => {\n    return lastValueFrom(this.datasource.awsRequest(url, params));\n  };\n\n  start = () => {\n    if (!this.startTask) {\n      this.startTask = Promise.resolve().then(() => {\n        this.started = true;\n        return [];\n      });\n    }\n\n    return this.startTask;\n  };\n\n  isStatsQuery(query: string): boolean {\n    const grammar = this.getSyntax();\n    const tokens = Prism.tokenize(query, grammar) ?? [];\n\n    return !!tokens.find(\n      (token) =>\n        typeof token !== 'string' &&\n        token.content.toString().toLowerCase() === 'stats' &&\n        token.type === 'query-command'\n    );\n  }\n\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n  async provideCompletionItems(input: TypeaheadInput, context?: TypeaheadContext): Promise<TypeaheadOutput> {\n    const { value } = input;\n\n    // Get tokens\n    const tokens = value?.data.get('tokens');\n\n    if (!tokens || !tokens.length) {\n      return { suggestions: [] };\n    }\n\n    const curToken: Token = tokens.filter(\n      (token: any) =>\n        token.offsets.start <= value!.selection?.start?.offset && token.offsets.end >= value!.selection?.start?.offset\n    )[0];\n\n    const isFirstToken = !curToken.prev;\n    const prevToken = prevNonWhitespaceToken(curToken);\n\n    const isCommandStart = isFirstToken || (!isFirstToken && prevToken?.types.includes('command-separator'));\n    if (isCommandStart) {\n      return this.getCommandCompletionItems();\n    }\n\n    if (isInsideFunctionParenthesis(curToken)) {\n      return await this.getFieldCompletionItems(context?.logGroupNames ?? [], context?.region || 'default');\n    }\n\n    if (isAfterKeyword('by', curToken)) {\n      return this.handleKeyword(context);\n    }\n\n    if (prevToken?.types.includes('comparison-operator')) {\n      return this.handleComparison(context);\n    }\n\n    const commandToken = previousCommandToken(curToken);\n    if (commandToken) {\n      return await this.handleCommand(commandToken, curToken, context);\n    }\n\n    return {\n      suggestions: [],\n    };\n  }\n\n  private fetchedFieldsCache:\n    | {\n        time: number;\n        logGroups: string[];\n        fields: string[];\n      }\n    | undefined;\n\n  private fetchFields = async (logGroups: string[], region: string): Promise<string[]> => {\n    if (\n      this.fetchedFieldsCache &&\n      Date.now() - this.fetchedFieldsCache.time < 30 * 1000 &&\n      sortedUniq(this.fetchedFieldsCache.logGroups).join('|') === sortedUniq(logGroups).join('|')\n    ) {\n      return this.fetchedFieldsCache.fields;\n    }\n\n    const results = await Promise.all(\n      logGroups.map((logGroup) => this.datasource.getLogGroupFields({ logGroupName: logGroup, region }))\n    );\n\n    const fields = [\n      ...new Set<string>(\n        results.reduce((acc: string[], cur) => acc.concat(cur.logGroupFields?.map((f) => f.name) as string[]), [])\n      ).values(),\n    ];\n\n    this.fetchedFieldsCache = {\n      time: Date.now(),\n      logGroups,\n      fields,\n    };\n\n    return fields;\n  };\n\n  private handleKeyword = async (context?: TypeaheadContext): Promise<TypeaheadOutput> => {\n    const suggs = await this.getFieldCompletionItems(context?.logGroupNames ?? [], context?.region || 'default');\n    const functionSuggestions: CompletionItemGroup[] = [\n      {\n        searchFunctionType: SearchFunctionType.Prefix,\n        label: 'Functions',\n        items: STRING_FUNCTIONS.concat(DATETIME_FUNCTIONS, IP_FUNCTIONS),\n      },\n    ];\n    suggs.suggestions.push(...functionSuggestions);\n\n    return suggs;\n  };\n\n  private handleCommand = async (\n    commandToken: Token,\n    curToken: Token,\n    context?: TypeaheadContext\n  ): Promise<TypeaheadOutput> => {\n    const queryCommand = commandToken.content.toLowerCase();\n    const prevToken = prevNonWhitespaceToken(curToken);\n    const currentTokenIsFirstArg = prevToken === commandToken;\n\n    if (queryCommand === 'sort') {\n      return this.handleSortCommand(currentTokenIsFirstArg, curToken, context);\n    }\n\n    if (queryCommand === 'parse') {\n      if (currentTokenIsFirstArg) {\n        return await this.getFieldCompletionItems(context?.logGroupNames ?? [], context?.region || 'default');\n      }\n    }\n\n    const currentTokenIsAfterCommandAndEmpty = isTokenType(commandToken.next, 'whitespace') && !commandToken.next?.next;\n    const currentTokenIsAfterCommand =\n      currentTokenIsAfterCommandAndEmpty || nextNonWhitespaceToken(commandToken) === curToken;\n\n    const currentTokenIsComma = isTokenType(curToken, 'punctuation', ',');\n    const currentTokenIsCommaOrAfterComma = currentTokenIsComma || isTokenType(prevToken, 'punctuation', ',');\n\n    // We only show suggestions if we are after a command or after a comma which is a field separator\n    if (!(currentTokenIsAfterCommand || currentTokenIsCommaOrAfterComma)) {\n      return { suggestions: [] };\n    }\n\n    if (['display', 'fields'].includes(queryCommand)) {\n      const typeaheadOutput = await this.getFieldCompletionItems(\n        context?.logGroupNames ?? [],\n        context?.region || 'default'\n      );\n      typeaheadOutput.suggestions.push(...this.getFieldAndFilterFunctionCompletionItems().suggestions);\n\n      return typeaheadOutput;\n    }\n\n    if (queryCommand === 'stats') {\n      const typeaheadOutput = this.getStatsAggCompletionItems();\n      if (currentTokenIsComma || currentTokenIsAfterCommandAndEmpty) {\n        typeaheadOutput?.suggestions.forEach((group) => {\n          group.skipFilter = true;\n        });\n      }\n      return typeaheadOutput;\n    }\n\n    if (queryCommand === 'filter' && currentTokenIsFirstArg) {\n      const sugg = await this.getFieldCompletionItems(context?.logGroupNames ?? [], context?.region || 'default');\n      const boolFuncs = this.getBoolFuncCompletionItems();\n      sugg.suggestions.push(...boolFuncs.suggestions);\n      return sugg;\n    }\n    return { suggestions: [] };\n  };\n\n  private async handleSortCommand(\n    isFirstArgument: boolean,\n    curToken: Token,\n    context?: TypeaheadContext\n  ): Promise<TypeaheadOutput> {\n    if (isFirstArgument) {\n      return await this.getFieldCompletionItems(context?.logGroupNames ?? [], context?.region || 'default');\n    } else if (isTokenType(prevNonWhitespaceToken(curToken), 'field-name')) {\n      // suggest sort options\n      return {\n        suggestions: [\n          {\n            searchFunctionType: SearchFunctionType.Prefix,\n            label: 'Sort Order',\n            items: [\n              {\n                label: 'asc',\n              },\n              { label: 'desc' },\n            ],\n          },\n        ],\n      };\n    }\n\n    return { suggestions: [] };\n  }\n\n  private handleComparison = async (context?: TypeaheadContext) => {\n    const fieldsSuggestions = await this.getFieldCompletionItems(\n      context?.logGroupNames ?? [],\n      context?.region || 'default'\n    );\n    const comparisonSuggestions = this.getComparisonCompletionItems();\n    fieldsSuggestions.suggestions.push(...comparisonSuggestions.suggestions);\n    return fieldsSuggestions;\n  };\n\n  private getCommandCompletionItems = (): TypeaheadOutput => {\n    return {\n      suggestions: [{ searchFunctionType: SearchFunctionType.Prefix, label: 'Commands', items: QUERY_COMMANDS }],\n    };\n  };\n\n  private getFieldAndFilterFunctionCompletionItems = (): TypeaheadOutput => {\n    return {\n      suggestions: [\n        { searchFunctionType: SearchFunctionType.Prefix, label: 'Functions', items: FIELD_AND_FILTER_FUNCTIONS },\n      ],\n    };\n  };\n\n  private getStatsAggCompletionItems = (): TypeaheadOutput => {\n    return {\n      suggestions: [\n        { searchFunctionType: SearchFunctionType.Prefix, label: 'Functions', items: AGGREGATION_FUNCTIONS_STATS },\n      ],\n    };\n  };\n\n  private getBoolFuncCompletionItems = (): TypeaheadOutput => {\n    return {\n      suggestions: [\n        {\n          searchFunctionType: SearchFunctionType.Prefix,\n          label: 'Functions',\n          items: BOOLEAN_FUNCTIONS,\n        },\n      ],\n    };\n  };\n\n  private getComparisonCompletionItems = (): TypeaheadOutput => {\n    return {\n      suggestions: [\n        {\n          searchFunctionType: SearchFunctionType.Prefix,\n          label: 'Functions',\n          items: NUMERIC_OPERATORS.concat(BOOLEAN_FUNCTIONS),\n        },\n      ],\n    };\n  };\n\n  private getFieldCompletionItems = async (logGroups: string[], region: string): Promise<TypeaheadOutput> => {\n    const fields = await this.fetchFields(logGroups, region);\n\n    return {\n      suggestions: [\n        {\n          label: 'Fields',\n          items: fields.map((field) => ({\n            label: field,\n            insertText: field.match(/@?[_a-zA-Z]+[_.0-9a-zA-Z]*/) ? undefined : `\\`${field}\\``,\n          })),\n        },\n      ],\n    };\n  };\n}\n\nfunction nextNonWhitespaceToken(token: Token): Token | null {\n  let curToken = token;\n\n  while (curToken.next) {\n    if (curToken.next.types.includes('whitespace')) {\n      curToken = curToken.next;\n    } else {\n      return curToken.next;\n    }\n  }\n\n  return null;\n}\n\nfunction prevNonWhitespaceToken(token: Token): Token | null {\n  let curToken = token;\n\n  while (curToken.prev) {\n    if (isTokenType(curToken.prev, 'whitespace')) {\n      curToken = curToken.prev;\n    } else {\n      return curToken.prev;\n    }\n  }\n\n  return null;\n}\n\nfunction previousCommandToken(startToken: Token): Token | null {\n  let thisToken = startToken;\n  while (!!thisToken.prev) {\n    thisToken = thisToken.prev;\n    if (\n      thisToken.types.includes('query-command') &&\n      (!thisToken.prev || isTokenType(prevNonWhitespaceToken(thisToken), 'command-separator'))\n    ) {\n      return thisToken;\n    }\n  }\n  return null;\n}\n\nconst funcsWithFieldArgs = [\n  'avg',\n  'count',\n  'count_distinct',\n  'earliest',\n  'latest',\n  'sortsFirst',\n  'sortsLast',\n  'max',\n  'min',\n  'pct',\n  'stddev',\n  'ispresent',\n  'fromMillis',\n  'toMillis',\n  'isempty',\n  'isblank',\n  'isValidIp',\n  'isValidIpV4',\n  'isValidIpV6',\n  'isIpInSubnet',\n  'isIpv4InSubnet',\n  'isIpv6InSubnet',\n].map((funcName) => funcName.toLowerCase());\n\n/**\n * Returns true if cursor is currently inside a function parenthesis for example `count(|)` or `count(@mess|)` should\n * return true.\n */\nfunction isInsideFunctionParenthesis(curToken: Token): boolean {\n  const prevToken = prevNonWhitespaceToken(curToken);\n\n  if (!prevToken) {\n    return false;\n  }\n\n  const parenthesisToken = curToken.content === '(' ? curToken : prevToken.content === '(' ? prevToken : undefined;\n  if (parenthesisToken) {\n    const maybeFunctionToken = prevNonWhitespaceToken(parenthesisToken);\n    if (maybeFunctionToken) {\n      return (\n        funcsWithFieldArgs.includes(maybeFunctionToken.content.toLowerCase()) &&\n        maybeFunctionToken.types.includes('function')\n      );\n    }\n  }\n  return false;\n}\n\nfunction isAfterKeyword(keyword: string, token: Token): boolean {\n  const maybeKeyword = getPreviousTokenExcluding(token, [\n    'whitespace',\n    'function',\n    'punctuation',\n    'field-name',\n    'number',\n  ]);\n  if (isTokenType(maybeKeyword, 'keyword', 'by')) {\n    const prev = getPreviousTokenExcluding(token, ['whitespace']);\n    if (prev === maybeKeyword || isTokenType(prev, 'punctuation', ',')) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isTokenType(token: Token | undefined | null, type: string, content?: string): boolean {\n  if (!token?.types.includes(type)) {\n    return false;\n  }\n  if (content) {\n    if (token?.content.toLowerCase() !== content) {\n      return false;\n    }\n  }\n  return true;\n}\n\ntype TokenDef = string | { type: string; value: string };\nfunction getPreviousTokenExcluding(token: Token, exclude: TokenDef[]): Token | undefined | null {\n  let curToken = token.prev;\n  main: while (curToken) {\n    for (const item of exclude) {\n      if (typeof item === 'string') {\n        if (curToken.types.includes(item)) {\n          curToken = curToken.prev;\n          continue main;\n        }\n      } else {\n        if (curToken.types.includes(item.type) && curToken.content.toLowerCase() === item.value) {\n          curToken = curToken.prev;\n          continue main;\n        }\n      }\n    }\n    break;\n  }\n  return curToken;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}