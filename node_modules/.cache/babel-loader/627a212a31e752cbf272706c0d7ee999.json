{"ast":null,"code":"//DOCS: https://prometheus.io/docs/alerting/latest/configuration/\nexport let SilenceState;\n\n(function (SilenceState) {\n  SilenceState[\"Active\"] = \"active\";\n  SilenceState[\"Expired\"] = \"expired\";\n  SilenceState[\"Pending\"] = \"pending\";\n})(SilenceState || (SilenceState = {}));\n\nexport let AlertState;\n\n(function (AlertState) {\n  AlertState[\"Unprocessed\"] = \"unprocessed\";\n  AlertState[\"Active\"] = \"active\";\n  AlertState[\"Suppressed\"] = \"suppressed\";\n})(AlertState || (AlertState = {}));\n\nexport let MatcherOperator;\n\n(function (MatcherOperator) {\n  MatcherOperator[\"equal\"] = \"=\";\n  MatcherOperator[\"notEqual\"] = \"!=\";\n  MatcherOperator[\"regex\"] = \"=~\";\n  MatcherOperator[\"notRegex\"] = \"!~\";\n})(MatcherOperator || (MatcherOperator = {}));\n\nexport let AlertManagerImplementation;\n\n(function (AlertManagerImplementation) {\n  AlertManagerImplementation[\"cortex\"] = \"cortex\";\n  AlertManagerImplementation[\"mimir\"] = \"mimir\";\n  AlertManagerImplementation[\"prometheus\"] = \"prometheus\";\n})(AlertManagerImplementation || (AlertManagerImplementation = {}));","map":{"version":3,"names":["SilenceState","AlertState","MatcherOperator","AlertManagerImplementation"],"sources":["/home/soula/grafana/public/app/plugins/datasource/alertmanager/types.ts"],"sourcesContent":["//DOCS: https://prometheus.io/docs/alerting/latest/configuration/\n\nimport { DataSourceJsonData } from '@grafana/data';\n\nexport type AlertManagerCortexConfig = {\n  template_files: Record<string, string>;\n  alertmanager_config: AlertmanagerConfig;\n  /** { [name]: provenance } */\n  template_file_provenances?: Record<string, string>;\n};\n\nexport type TLSConfig = {\n  ca_file: string;\n  cert_file: string;\n  key_file: string;\n  server_name?: string;\n  insecure_skip_verify?: boolean;\n};\n\nexport type HTTPConfigCommon = {\n  proxy_url?: string;\n  tls_config?: TLSConfig;\n};\n\nexport type HTTPConfigBasicAuth = {\n  basic_auth: {\n    username: string;\n  } & ({ password: string } | { password_file: string });\n};\n\nexport type HTTPConfigBearerToken = {\n  bearer_token: string;\n};\n\nexport type HTTPConfigBearerTokenFile = {\n  bearer_token_file: string;\n};\n\nexport type HTTPConfig = HTTPConfigCommon & (HTTPConfigBasicAuth | HTTPConfigBearerToken | HTTPConfigBearerTokenFile);\n\nexport type EmailConfig = {\n  to: string;\n\n  send_resolved?: string;\n  from?: string;\n  smarthost?: string;\n  hello?: string;\n  auth_username?: string;\n  auth_password?: string;\n  auth_secret?: string;\n  auth_identity?: string;\n  require_tls?: boolean;\n  tls_config?: TLSConfig;\n  html?: string;\n  text?: string;\n  headers?: Record<string, string>;\n};\n\nexport type WebhookConfig = {\n  url: string;\n\n  send_resolved?: boolean;\n  http_config?: HTTPConfig;\n  max_alerts?: number;\n};\n\nexport type GrafanaManagedReceiverConfig = {\n  uid?: string;\n  disableResolveMessage: boolean;\n  secureFields?: Record<string, boolean>;\n  secureSettings?: Record<string, any>;\n  settings: Record<string, any>;\n  type: string;\n  name: string;\n  updated?: string;\n  created?: string;\n  provenance?: string;\n};\n\nexport type Receiver = {\n  name: string;\n\n  email_configs?: EmailConfig[];\n  pagerduty_configs?: any[];\n  pushover_configs?: any[];\n  slack_configs?: any[];\n  opsgenie_configs?: any[];\n  webhook_configs?: WebhookConfig[];\n  victorops_configs?: any[];\n  wechat_configs?: any[];\n  grafana_managed_receiver_configs?: GrafanaManagedReceiverConfig[];\n  [key: string]: any;\n};\n\ntype ObjectMatcher = [name: string, operator: MatcherOperator, value: string];\n\nexport type Route = {\n  receiver?: string;\n  group_by?: string[];\n  continue?: boolean;\n  object_matchers?: ObjectMatcher[];\n  matchers?: string[];\n  /** @deprecated use `object_matchers` */\n  match?: Record<string, string>;\n  /** @deprecated use `object_matchers` */\n  match_re?: Record<string, string>;\n  group_wait?: string;\n  group_interval?: string;\n  repeat_interval?: string;\n  routes?: Route[];\n  mute_time_intervals?: string[];\n  /** only the root policy might have a provenance field defined */\n  provenance?: string;\n};\n\nexport type InhibitRule = {\n  target_match: Record<string, string>;\n  target_match_re: Record<string, string>;\n  source_match: Record<string, string>;\n  source_match_re: Record<string, string>;\n  equal?: string[];\n};\n\nexport type AlertmanagerConfig = {\n  global?: {\n    smtp_from?: string;\n    smtp_smarthost?: string;\n    smtp_hello?: string;\n    smtp_auth_username?: string;\n    smtp_auth_password?: string;\n    smtp_auth_identity?: string;\n    smtp_auth_secret?: string;\n    smtp_require_tls?: boolean;\n    slack_api_url?: string;\n    victorops_api_key?: string;\n    victorops_api_url?: string;\n    pagerduty_url?: string;\n    opsgenie_api_key?: string;\n    opsgenie_api_url?: string;\n    wechat_api_url?: string;\n    wechat_api_secret?: string;\n    wechat_api_corp_id?: string;\n    http_config?: HTTPConfig;\n    resolve_timeout?: string;\n  };\n  templates?: string[];\n  route?: Route;\n  inhibit_rules?: InhibitRule[];\n  receivers?: Receiver[];\n  mute_time_intervals?: MuteTimeInterval[];\n  /** { [name]: provenance } */\n  muteTimeProvenances?: Record<string, string>;\n};\n\nexport type Matcher = {\n  name: string;\n  value: string;\n  isRegex: boolean;\n  isEqual: boolean;\n};\n\nexport enum SilenceState {\n  Active = 'active',\n  Expired = 'expired',\n  Pending = 'pending',\n}\n\nexport enum AlertState {\n  Unprocessed = 'unprocessed',\n  Active = 'active',\n  Suppressed = 'suppressed',\n}\n\nexport enum MatcherOperator {\n  equal = '=',\n  notEqual = '!=',\n  regex = '=~',\n  notRegex = '!~',\n}\n\nexport type Silence = {\n  id: string;\n  matchers?: Matcher[];\n  startsAt: string;\n  endsAt: string;\n  updatedAt: string;\n  createdBy: string;\n  comment: string;\n  status: {\n    state: SilenceState;\n  };\n};\n\nexport type SilenceCreatePayload = {\n  id?: string;\n  matchers?: Matcher[];\n  startsAt: string;\n  endsAt: string;\n  createdBy: string;\n  comment: string;\n};\n\nexport type AlertmanagerAlert = {\n  startsAt: string;\n  updatedAt: string;\n  endsAt: string;\n  generatorURL?: string;\n  labels: { [key: string]: string };\n  annotations: { [key: string]: string };\n  receivers: [\n    {\n      name: string;\n    }\n  ];\n  fingerprint: string;\n  status: {\n    state: AlertState;\n    silencedBy: string[];\n    inhibitedBy: string[];\n  };\n};\n\nexport type AlertmanagerGroup = {\n  labels: { [key: string]: string };\n  receiver: { name: string };\n  alerts: AlertmanagerAlert[];\n};\n\nexport interface AlertmanagerStatus {\n  cluster: {\n    peers: unknown;\n    status: string;\n  };\n  config: AlertmanagerConfig;\n  uptime: string;\n  versionInfo: {\n    branch: string;\n    buildDate: string;\n    buildUser: string;\n    goVersion: string;\n    revision: string;\n    version: string;\n  };\n}\n\nexport type TestReceiversAlert = Pick<AlertmanagerAlert, 'annotations' | 'labels'>;\n\nexport interface TestReceiversPayload {\n  receivers?: Receiver[];\n  alert?: TestReceiversAlert;\n}\n\ninterface TestReceiversResultGrafanaReceiverConfig {\n  name: string;\n  uid?: string;\n  error?: string;\n  status: 'ok' | 'failed';\n}\n\ninterface TestReceiversResultReceiver {\n  name: string;\n  grafana_managed_receiver_configs: TestReceiversResultGrafanaReceiverConfig[];\n}\nexport interface TestReceiversResult {\n  notified_at: string;\n  receivers: TestReceiversResultReceiver[];\n}\n\nexport interface ExternalAlertmanagers {\n  activeAlertManagers: AlertmanagerUrl[];\n  droppedAlertManagers: AlertmanagerUrl[];\n}\n\nexport interface AlertmanagerUrl {\n  url: string;\n}\n\nexport interface ExternalAlertmanagersResponse {\n  data: ExternalAlertmanagers;\n  status: 'string';\n}\n\nexport interface ExternalAlertmanagerConfig {\n  alertmanagers: string[];\n  alertmanagersChoice: string;\n}\n\nexport enum AlertManagerImplementation {\n  cortex = 'cortex',\n  mimir = 'mimir',\n  prometheus = 'prometheus',\n}\n\nexport interface TimeRange {\n  /** Times are in format `HH:MM` in UTC */\n  start_time: string;\n  end_time: string;\n}\nexport interface TimeInterval {\n  times?: TimeRange[];\n  weekdays?: string[];\n  days_of_month?: string[];\n  months?: string[];\n  years?: string[];\n}\n\nexport type MuteTimeInterval = {\n  name: string;\n  time_intervals: TimeInterval[];\n  provenance?: string;\n};\n\nexport type AlertManagerDataSourceJsonData = DataSourceJsonData & { implementation?: AlertManagerImplementation };\n"],"mappings":"AAAA;AAiKA,WAAYA,YAAZ;;WAAYA,Y;EAAAA,Y;EAAAA,Y;EAAAA,Y;GAAAA,Y,KAAAA,Y;;AAMZ,WAAYC,UAAZ;;WAAYA,U;EAAAA,U;EAAAA,U;EAAAA,U;GAAAA,U,KAAAA,U;;AAMZ,WAAYC,eAAZ;;WAAYA,e;EAAAA,e;EAAAA,e;EAAAA,e;EAAAA,e;GAAAA,e,KAAAA,e;;AAkHZ,WAAYC,0BAAZ;;WAAYA,0B;EAAAA,0B;EAAAA,0B;EAAAA,0B;GAAAA,0B,KAAAA,0B"},"metadata":{},"sourceType":"module"}