{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Subject, of, Observable } from 'rxjs';\nimport { LiveChannelEventType, LiveChannelConnectionState, isValidLiveChannelAddress } from '@grafana/data';\n/**\n * Internal class that maps Centrifuge support to GrafanaLive\n */\n\nexport class CentrifugeLiveChannel {\n  // Hold on to the last header with schema\n  constructor(id, addr) {\n    _defineProperty(this, \"currentStatus\", void 0);\n\n    _defineProperty(this, \"opened\", Date.now());\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"addr\", void 0);\n\n    _defineProperty(this, \"stream\", new Subject());\n\n    _defineProperty(this, \"lastMessageWithSchema\", void 0);\n\n    _defineProperty(this, \"subscription\", void 0);\n\n    _defineProperty(this, \"shutdownCallback\", void 0);\n\n    _defineProperty(this, \"initalized\", void 0);\n\n    _defineProperty(this, \"disconnectIfNoListeners\", () => {\n      const count = this.stream.observers.length;\n\n      if (count === 0) {\n        this.disconnect();\n      }\n    });\n\n    this.id = id;\n    this.addr = addr;\n    this.currentStatus = {\n      type: LiveChannelEventType.Status,\n      id,\n      timestamp: this.opened,\n      state: LiveChannelConnectionState.Pending\n    };\n\n    if (!isValidLiveChannelAddress(addr)) {\n      this.currentStatus.state = LiveChannelConnectionState.Invalid;\n      this.currentStatus.error = 'invalid channel address';\n    }\n  } // This should only be called when centrifuge is connected\n\n\n  initalize() {\n    if (this.initalized) {\n      throw new Error('Channel already initalized: ' + this.id);\n    }\n\n    this.initalized = true;\n    const events = {\n      // Called when a message is received from the socket\n      publish: ctx => {\n        try {\n          if (ctx.data) {\n            if (ctx.data.schema) {\n              this.lastMessageWithSchema = ctx.data;\n            }\n\n            this.stream.next({\n              type: LiveChannelEventType.Message,\n              message: ctx.data\n            });\n          } // Clear any error messages\n\n\n          if (this.currentStatus.error) {\n            this.currentStatus.timestamp = Date.now();\n            delete this.currentStatus.error;\n            this.sendStatus();\n          }\n        } catch (err) {\n          console.log('publish error', this.addr, err);\n          this.currentStatus.error = err;\n          this.currentStatus.timestamp = Date.now();\n          this.sendStatus();\n        }\n      },\n      error: ctx => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.error = ctx.message;\n        this.sendStatus();\n      },\n      subscribe: ctx => {\n        var _ctx$data;\n\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connected;\n        delete this.currentStatus.error;\n\n        if ((_ctx$data = ctx.data) !== null && _ctx$data !== void 0 && _ctx$data.schema) {\n          this.lastMessageWithSchema = ctx.data;\n        }\n\n        this.sendStatus(ctx.data);\n      },\n      unsubscribe: ctx => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Disconnected;\n        this.sendStatus();\n      }\n    };\n\n    events.join = ctx => {\n      this.stream.next({\n        type: LiveChannelEventType.Join,\n        user: ctx.info.user\n      });\n    };\n\n    events.leave = ctx => {\n      this.stream.next({\n        type: LiveChannelEventType.Leave,\n        user: ctx.info.user\n      });\n    };\n\n    return events;\n  }\n\n  sendStatus(message) {\n    const copy = Object.assign({}, this.currentStatus);\n\n    if (message) {\n      copy.message = message;\n    }\n\n    this.stream.next(copy);\n  }\n\n  /**\n   * Get the stream of events and\n   */\n  getStream() {\n    return new Observable(subscriber => {\n      var _this$lastMessageWith;\n\n      const initialMessage = Object.assign({}, this.currentStatus);\n\n      if ((_this$lastMessageWith = this.lastMessageWithSchema) !== null && _this$lastMessageWith !== void 0 && _this$lastMessageWith.schema) {\n        var _this$lastMessageWith2;\n\n        // send just schema instead of schema+data to avoid having data gaps\n        initialMessage.message = {\n          schema: (_this$lastMessageWith2 = this.lastMessageWithSchema) === null || _this$lastMessageWith2 === void 0 ? void 0 : _this$lastMessageWith2.schema\n        };\n      }\n\n      subscriber.next(Object.assign({}, this.currentStatus, {\n        message: this.lastMessageWithSchema\n      }));\n      const sub = this.stream.subscribe(subscriber);\n      return () => {\n        sub.unsubscribe();\n        const count = this.stream.observers.length; // Wait 1/4 second to fully disconnect\n\n        if (count === 0) {\n          setTimeout(this.disconnectIfNoListeners, 250);\n        }\n      };\n    });\n  }\n  /**\n   * This is configured by the server when the config supports presence\n   */\n\n\n  async getPresence() {\n    if (!this.subscription) {\n      return Promise.reject('not subscribed');\n    }\n\n    return this.subscription.presence().then(v => {\n      return {\n        users: Object.keys(v.presence)\n      };\n    });\n  }\n  /**\n   * This will close and terminate all streams for this channel\n   */\n\n\n  disconnect() {\n    this.currentStatus.state = LiveChannelConnectionState.Shutdown;\n    this.currentStatus.timestamp = Date.now();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      this.subscription.removeAllListeners(); // they keep all listeners attached after unsubscribe\n\n      this.subscription = undefined;\n    }\n\n    this.stream.complete();\n    this.stream.next(Object.assign({}, this.currentStatus));\n    this.stream.complete();\n\n    if (this.shutdownCallback) {\n      this.shutdownCallback();\n    }\n  }\n\n  shutdownWithError(err) {\n    this.currentStatus.error = err;\n    this.sendStatus();\n    this.disconnect();\n  }\n\n}\nexport function getErrorChannel(msg, id, addr) {\n  return {\n    id,\n    opened: Date.now(),\n    addr,\n    // return an error\n    getStream: () => of({\n      type: LiveChannelEventType.Status,\n      id,\n      timestamp: Date.now(),\n      state: LiveChannelConnectionState.Invalid,\n      error: msg\n    }),\n    // already disconnected\n    disconnect: () => {}\n  };\n}","map":{"version":3,"names":["Subject","of","Observable","LiveChannelEventType","LiveChannelConnectionState","isValidLiveChannelAddress","CentrifugeLiveChannel","constructor","id","addr","Date","now","count","stream","observers","length","disconnect","currentStatus","type","Status","timestamp","opened","state","Pending","Invalid","error","initalize","initalized","Error","events","publish","ctx","data","schema","lastMessageWithSchema","next","Message","message","sendStatus","err","console","log","subscribe","Connected","unsubscribe","Disconnected","join","Join","user","info","leave","Leave","copy","getStream","subscriber","initialMessage","sub","setTimeout","disconnectIfNoListeners","getPresence","subscription","Promise","reject","presence","then","v","users","Object","keys","Shutdown","removeAllListeners","undefined","complete","shutdownCallback","shutdownWithError","getErrorChannel","msg"],"sources":["/home/soula/grafana/public/app/features/live/centrifuge/channel.ts"],"sourcesContent":["import Centrifuge, {\n  JoinLeaveContext,\n  PublicationContext,\n  SubscribeErrorContext,\n  SubscribeSuccessContext,\n  SubscriptionEvents,\n  UnsubscribeContext,\n} from 'centrifuge/dist/centrifuge';\nimport { Subject, of, Observable } from 'rxjs';\n\nimport {\n  LiveChannelStatusEvent,\n  LiveChannelEvent,\n  LiveChannelEventType,\n  LiveChannelConnectionState,\n  LiveChannelPresenceStatus,\n  LiveChannelAddress,\n  DataFrameJSON,\n  isValidLiveChannelAddress,\n} from '@grafana/data';\n\n/**\n * Internal class that maps Centrifuge support to GrafanaLive\n */\nexport class CentrifugeLiveChannel<T = any> {\n  readonly currentStatus: LiveChannelStatusEvent;\n\n  readonly opened = Date.now();\n  readonly id: string;\n  readonly addr: LiveChannelAddress;\n\n  readonly stream = new Subject<LiveChannelEvent<T>>();\n\n  // Hold on to the last header with schema\n  lastMessageWithSchema?: DataFrameJSON;\n\n  subscription?: Centrifuge.Subscription;\n  shutdownCallback?: () => void;\n  initalized?: boolean;\n\n  constructor(id: string, addr: LiveChannelAddress) {\n    this.id = id;\n    this.addr = addr;\n    this.currentStatus = {\n      type: LiveChannelEventType.Status,\n      id,\n      timestamp: this.opened,\n      state: LiveChannelConnectionState.Pending,\n    };\n    if (!isValidLiveChannelAddress(addr)) {\n      this.currentStatus.state = LiveChannelConnectionState.Invalid;\n      this.currentStatus.error = 'invalid channel address';\n    }\n  }\n\n  // This should only be called when centrifuge is connected\n  initalize(): SubscriptionEvents {\n    if (this.initalized) {\n      throw new Error('Channel already initalized: ' + this.id);\n    }\n    this.initalized = true;\n\n    const events: SubscriptionEvents = {\n      // Called when a message is received from the socket\n      publish: (ctx: PublicationContext) => {\n        try {\n          if (ctx.data) {\n            if (ctx.data.schema) {\n              this.lastMessageWithSchema = ctx.data as DataFrameJSON;\n            }\n\n            this.stream.next({\n              type: LiveChannelEventType.Message,\n              message: ctx.data,\n            });\n          }\n\n          // Clear any error messages\n          if (this.currentStatus.error) {\n            this.currentStatus.timestamp = Date.now();\n            delete this.currentStatus.error;\n            this.sendStatus();\n          }\n        } catch (err) {\n          console.log('publish error', this.addr, err);\n          this.currentStatus.error = err;\n          this.currentStatus.timestamp = Date.now();\n          this.sendStatus();\n        }\n      },\n      error: (ctx: SubscribeErrorContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.error = ctx.message;\n        this.sendStatus();\n      },\n      subscribe: (ctx: SubscribeSuccessContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connected;\n        delete this.currentStatus.error;\n\n        if (ctx.data?.schema) {\n          this.lastMessageWithSchema = ctx.data as DataFrameJSON;\n        }\n\n        this.sendStatus(ctx.data);\n      },\n      unsubscribe: (ctx: UnsubscribeContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Disconnected;\n        this.sendStatus();\n      },\n    };\n\n    events.join = (ctx: JoinLeaveContext) => {\n      this.stream.next({ type: LiveChannelEventType.Join, user: ctx.info.user });\n    };\n    events.leave = (ctx: JoinLeaveContext) => {\n      this.stream.next({ type: LiveChannelEventType.Leave, user: ctx.info.user });\n    };\n    return events;\n  }\n\n  private sendStatus(message?: any) {\n    const copy = { ...this.currentStatus };\n    if (message) {\n      copy.message = message;\n    }\n    this.stream.next(copy);\n  }\n\n  disconnectIfNoListeners = () => {\n    const count = this.stream.observers.length;\n    if (count === 0) {\n      this.disconnect();\n    }\n  };\n\n  /**\n   * Get the stream of events and\n   */\n  getStream() {\n    return new Observable((subscriber) => {\n      const initialMessage = { ...this.currentStatus };\n      if (this.lastMessageWithSchema?.schema) {\n        // send just schema instead of schema+data to avoid having data gaps\n        initialMessage.message = { schema: this.lastMessageWithSchema?.schema };\n      }\n\n      subscriber.next({ ...this.currentStatus, message: this.lastMessageWithSchema });\n\n      const sub = this.stream.subscribe(subscriber);\n      return () => {\n        sub.unsubscribe();\n        const count = this.stream.observers.length;\n\n        // Wait 1/4 second to fully disconnect\n        if (count === 0) {\n          setTimeout(this.disconnectIfNoListeners, 250);\n        }\n      };\n    }) as Observable<LiveChannelEvent<T>>;\n  }\n\n  /**\n   * This is configured by the server when the config supports presence\n   */\n  async getPresence(): Promise<LiveChannelPresenceStatus> {\n    if (!this.subscription) {\n      return Promise.reject('not subscribed');\n    }\n\n    return this.subscription!.presence().then((v) => {\n      return {\n        users: Object.keys(v.presence),\n      };\n    });\n  }\n\n  /**\n   * This will close and terminate all streams for this channel\n   */\n  disconnect() {\n    this.currentStatus.state = LiveChannelConnectionState.Shutdown;\n    this.currentStatus.timestamp = Date.now();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      this.subscription.removeAllListeners(); // they keep all listeners attached after unsubscribe\n      this.subscription = undefined;\n    }\n\n    this.stream.complete();\n\n    this.stream.next({ ...this.currentStatus });\n    this.stream.complete();\n\n    if (this.shutdownCallback) {\n      this.shutdownCallback();\n    }\n  }\n\n  shutdownWithError(err: string) {\n    this.currentStatus.error = err;\n    this.sendStatus();\n    this.disconnect();\n  }\n}\n\nexport function getErrorChannel<TMessage>(msg: string, id: string, addr: LiveChannelAddress) {\n  return {\n    id,\n    opened: Date.now(),\n    addr,\n\n    // return an error\n    getStream: () =>\n      of({\n        type: LiveChannelEventType.Status,\n        id,\n        timestamp: Date.now(),\n        state: LiveChannelConnectionState.Invalid,\n        error: msg,\n      }),\n\n    // already disconnected\n    disconnect: () => {},\n  };\n}\n"],"mappings":";;AAQA,SAASA,OAAT,EAAkBC,EAAlB,EAAsBC,UAAtB,QAAwC,MAAxC;AAEA,SAGEC,oBAHF,EAIEC,0BAJF,EAQEC,yBARF,QASO,eATP;AAWA;AACA;AACA;;AACA,OAAO,MAAMC,qBAAN,CAAqC;EAS1C;EAOAC,WAAW,CAACC,EAAD,EAAaC,IAAb,EAAuC;IAAA;;IAAA,gCAbhCC,IAAI,CAACC,GAAL,EAagC;;IAAA;;IAAA;;IAAA,gCAThC,IAAIX,OAAJ,EASgC;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA,iDA0FxB,MAAM;MAC9B,MAAMY,KAAK,GAAG,KAAKC,MAAL,CAAYC,SAAZ,CAAsBC,MAApC;;MACA,IAAIH,KAAK,KAAK,CAAd,EAAiB;QACf,KAAKI,UAAL;MACD;IACF,CA/FiD;;IAChD,KAAKR,EAAL,GAAUA,EAAV;IACA,KAAKC,IAAL,GAAYA,IAAZ;IACA,KAAKQ,aAAL,GAAqB;MACnBC,IAAI,EAAEf,oBAAoB,CAACgB,MADR;MAEnBX,EAFmB;MAGnBY,SAAS,EAAE,KAAKC,MAHG;MAInBC,KAAK,EAAElB,0BAA0B,CAACmB;IAJf,CAArB;;IAMA,IAAI,CAAClB,yBAAyB,CAACI,IAAD,CAA9B,EAAsC;MACpC,KAAKQ,aAAL,CAAmBK,KAAnB,GAA2BlB,0BAA0B,CAACoB,OAAtD;MACA,KAAKP,aAAL,CAAmBQ,KAAnB,GAA2B,yBAA3B;IACD;EACF,CA7ByC,CA+B1C;;;EACAC,SAAS,GAAuB;IAC9B,IAAI,KAAKC,UAAT,EAAqB;MACnB,MAAM,IAAIC,KAAJ,CAAU,iCAAiC,KAAKpB,EAAhD,CAAN;IACD;;IACD,KAAKmB,UAAL,GAAkB,IAAlB;IAEA,MAAME,MAA0B,GAAG;MACjC;MACAC,OAAO,EAAGC,GAAD,IAA6B;QACpC,IAAI;UACF,IAAIA,GAAG,CAACC,IAAR,EAAc;YACZ,IAAID,GAAG,CAACC,IAAJ,CAASC,MAAb,EAAqB;cACnB,KAAKC,qBAAL,GAA6BH,GAAG,CAACC,IAAjC;YACD;;YAED,KAAKnB,MAAL,CAAYsB,IAAZ,CAAiB;cACfjB,IAAI,EAAEf,oBAAoB,CAACiC,OADZ;cAEfC,OAAO,EAAEN,GAAG,CAACC;YAFE,CAAjB;UAID,CAVC,CAYF;;;UACA,IAAI,KAAKf,aAAL,CAAmBQ,KAAvB,EAA8B;YAC5B,KAAKR,aAAL,CAAmBG,SAAnB,GAA+BV,IAAI,CAACC,GAAL,EAA/B;YACA,OAAO,KAAKM,aAAL,CAAmBQ,KAA1B;YACA,KAAKa,UAAL;UACD;QACF,CAlBD,CAkBE,OAAOC,GAAP,EAAY;UACZC,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6B,KAAKhC,IAAlC,EAAwC8B,GAAxC;UACA,KAAKtB,aAAL,CAAmBQ,KAAnB,GAA2Bc,GAA3B;UACA,KAAKtB,aAAL,CAAmBG,SAAnB,GAA+BV,IAAI,CAACC,GAAL,EAA/B;UACA,KAAK2B,UAAL;QACD;MACF,CA3BgC;MA4BjCb,KAAK,EAAGM,GAAD,IAAgC;QACrC,KAAKd,aAAL,CAAmBG,SAAnB,GAA+BV,IAAI,CAACC,GAAL,EAA/B;QACA,KAAKM,aAAL,CAAmBQ,KAAnB,GAA2BM,GAAG,CAACM,OAA/B;QACA,KAAKC,UAAL;MACD,CAhCgC;MAiCjCI,SAAS,EAAGX,GAAD,IAAkC;QAAA;;QAC3C,KAAKd,aAAL,CAAmBG,SAAnB,GAA+BV,IAAI,CAACC,GAAL,EAA/B;QACA,KAAKM,aAAL,CAAmBK,KAAnB,GAA2BlB,0BAA0B,CAACuC,SAAtD;QACA,OAAO,KAAK1B,aAAL,CAAmBQ,KAA1B;;QAEA,iBAAIM,GAAG,CAACC,IAAR,sCAAI,UAAUC,MAAd,EAAsB;UACpB,KAAKC,qBAAL,GAA6BH,GAAG,CAACC,IAAjC;QACD;;QAED,KAAKM,UAAL,CAAgBP,GAAG,CAACC,IAApB;MACD,CA3CgC;MA4CjCY,WAAW,EAAGb,GAAD,IAA6B;QACxC,KAAKd,aAAL,CAAmBG,SAAnB,GAA+BV,IAAI,CAACC,GAAL,EAA/B;QACA,KAAKM,aAAL,CAAmBK,KAAnB,GAA2BlB,0BAA0B,CAACyC,YAAtD;QACA,KAAKP,UAAL;MACD;IAhDgC,CAAnC;;IAmDAT,MAAM,CAACiB,IAAP,GAAef,GAAD,IAA2B;MACvC,KAAKlB,MAAL,CAAYsB,IAAZ,CAAiB;QAAEjB,IAAI,EAAEf,oBAAoB,CAAC4C,IAA7B;QAAmCC,IAAI,EAAEjB,GAAG,CAACkB,IAAJ,CAASD;MAAlD,CAAjB;IACD,CAFD;;IAGAnB,MAAM,CAACqB,KAAP,GAAgBnB,GAAD,IAA2B;MACxC,KAAKlB,MAAL,CAAYsB,IAAZ,CAAiB;QAAEjB,IAAI,EAAEf,oBAAoB,CAACgD,KAA7B;QAAoCH,IAAI,EAAEjB,GAAG,CAACkB,IAAJ,CAASD;MAAnD,CAAjB;IACD,CAFD;;IAGA,OAAOnB,MAAP;EACD;;EAEOS,UAAU,CAACD,OAAD,EAAgB;IAChC,MAAMe,IAAI,qBAAQ,KAAKnC,aAAb,CAAV;;IACA,IAAIoB,OAAJ,EAAa;MACXe,IAAI,CAACf,OAAL,GAAeA,OAAf;IACD;;IACD,KAAKxB,MAAL,CAAYsB,IAAZ,CAAiBiB,IAAjB;EACD;;EASD;AACF;AACA;EACEC,SAAS,GAAG;IACV,OAAO,IAAInD,UAAJ,CAAgBoD,UAAD,IAAgB;MAAA;;MACpC,MAAMC,cAAc,qBAAQ,KAAKtC,aAAb,CAApB;;MACA,6BAAI,KAAKiB,qBAAT,kDAAI,sBAA4BD,MAAhC,EAAwC;QAAA;;QACtC;QACAsB,cAAc,CAAClB,OAAf,GAAyB;UAAEJ,MAAM,4BAAE,KAAKC,qBAAP,2DAAE,uBAA4BD;QAAtC,CAAzB;MACD;;MAEDqB,UAAU,CAACnB,IAAX,mBAAqB,KAAKlB,aAA1B;QAAyCoB,OAAO,EAAE,KAAKH;MAAvD;MAEA,MAAMsB,GAAG,GAAG,KAAK3C,MAAL,CAAY6B,SAAZ,CAAsBY,UAAtB,CAAZ;MACA,OAAO,MAAM;QACXE,GAAG,CAACZ,WAAJ;QACA,MAAMhC,KAAK,GAAG,KAAKC,MAAL,CAAYC,SAAZ,CAAsBC,MAApC,CAFW,CAIX;;QACA,IAAIH,KAAK,KAAK,CAAd,EAAiB;UACf6C,UAAU,CAAC,KAAKC,uBAAN,EAA+B,GAA/B,CAAV;QACD;MACF,CARD;IASD,CAnBM,CAAP;EAoBD;EAED;AACF;AACA;;;EACmB,MAAXC,WAAW,GAAuC;IACtD,IAAI,CAAC,KAAKC,YAAV,EAAwB;MACtB,OAAOC,OAAO,CAACC,MAAR,CAAe,gBAAf,CAAP;IACD;;IAED,OAAO,KAAKF,YAAL,CAAmBG,QAAnB,GAA8BC,IAA9B,CAAoCC,CAAD,IAAO;MAC/C,OAAO;QACLC,KAAK,EAAEC,MAAM,CAACC,IAAP,CAAYH,CAAC,CAACF,QAAd;MADF,CAAP;IAGD,CAJM,CAAP;EAKD;EAED;AACF;AACA;;;EACE/C,UAAU,GAAG;IACX,KAAKC,aAAL,CAAmBK,KAAnB,GAA2BlB,0BAA0B,CAACiE,QAAtD;IACA,KAAKpD,aAAL,CAAmBG,SAAnB,GAA+BV,IAAI,CAACC,GAAL,EAA/B;;IAEA,IAAI,KAAKiD,YAAT,EAAuB;MACrB,KAAKA,YAAL,CAAkBhB,WAAlB;MACA,KAAKgB,YAAL,CAAkBU,kBAAlB,GAFqB,CAEmB;;MACxC,KAAKV,YAAL,GAAoBW,SAApB;IACD;;IAED,KAAK1D,MAAL,CAAY2D,QAAZ;IAEA,KAAK3D,MAAL,CAAYsB,IAAZ,mBAAsB,KAAKlB,aAA3B;IACA,KAAKJ,MAAL,CAAY2D,QAAZ;;IAEA,IAAI,KAAKC,gBAAT,EAA2B;MACzB,KAAKA,gBAAL;IACD;EACF;;EAEDC,iBAAiB,CAACnC,GAAD,EAAc;IAC7B,KAAKtB,aAAL,CAAmBQ,KAAnB,GAA2Bc,GAA3B;IACA,KAAKD,UAAL;IACA,KAAKtB,UAAL;EACD;;AArLyC;AAwL5C,OAAO,SAAS2D,eAAT,CAAmCC,GAAnC,EAAgDpE,EAAhD,EAA4DC,IAA5D,EAAsF;EAC3F,OAAO;IACLD,EADK;IAELa,MAAM,EAAEX,IAAI,CAACC,GAAL,EAFH;IAGLF,IAHK;IAKL;IACA4C,SAAS,EAAE,MACTpD,EAAE,CAAC;MACDiB,IAAI,EAAEf,oBAAoB,CAACgB,MAD1B;MAEDX,EAFC;MAGDY,SAAS,EAAEV,IAAI,CAACC,GAAL,EAHV;MAIDW,KAAK,EAAElB,0BAA0B,CAACoB,OAJjC;MAKDC,KAAK,EAAEmD;IALN,CAAD,CAPC;IAeL;IACA5D,UAAU,EAAE,MAAM,CAAE;EAhBf,CAAP;AAkBD"},"metadata":{},"sourceType":"module"}