{"ast":null,"code":"import { FieldType, getFieldDisplayName } from '@grafana/data';\n// TODO: fix import\nexport let DimensionError;\n\n(function (DimensionError) {\n  DimensionError[DimensionError[\"NoData\"] = 0] = \"NoData\";\n  DimensionError[DimensionError[\"BadFrameSelection\"] = 1] = \"BadFrameSelection\";\n  DimensionError[DimensionError[\"XNotFound\"] = 2] = \"XNotFound\";\n})(DimensionError || (DimensionError = {}));\n\nexport function isGraphable(field) {\n  return field.type === FieldType.number;\n}\nexport function getXYDimensions(cfg, data) {\n  var _cfg$frame;\n\n  if (!data || !data.length) {\n    return {\n      error: DimensionError.NoData\n    };\n  }\n\n  if (!cfg) {\n    cfg = {\n      frame: 0\n    };\n  }\n\n  let frame = data[(_cfg$frame = cfg.frame) !== null && _cfg$frame !== void 0 ? _cfg$frame : 0];\n\n  if (!frame) {\n    return {\n      error: DimensionError.BadFrameSelection\n    };\n  }\n\n  let xIndex = -1;\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    const f = frame.fields[i];\n\n    if (cfg.x && cfg.x === getFieldDisplayName(f, frame, data)) {\n      xIndex = i;\n      break;\n    }\n\n    if (isGraphable(f) && !cfg.x) {\n      xIndex = i;\n      break;\n    }\n  }\n\n  let hasTime = false;\n  const x = frame.fields[xIndex];\n  const fields = [x];\n\n  for (const f of frame.fields) {\n    if (f.type === FieldType.time) {\n      hasTime = true;\n    }\n\n    if (f === x || !isGraphable(f)) {\n      continue;\n    }\n\n    if (cfg.exclude) {\n      const name = getFieldDisplayName(f, frame, data);\n\n      if (cfg.exclude.includes(name)) {\n        continue;\n      }\n    }\n\n    fields.push(f);\n  }\n\n  return {\n    x,\n    fields: {\n      x: getSimpleFieldMatcher(x),\n      y: getSimpleFieldNotMatcher(x) // Not x\n\n    },\n    frame: Object.assign({}, frame, {\n      fields\n    }),\n    hasData: frame.fields.length > 0,\n    hasTime\n  };\n}\n\nfunction getSimpleFieldMatcher(f) {\n  if (!f) {\n    return () => false;\n  } // the field may change if sorted\n\n\n  return field => f === field || !!(f.state && f.state === field.state);\n}\n\nfunction getSimpleFieldNotMatcher(f) {\n  if (!f) {\n    return () => false;\n  }\n\n  const m = getSimpleFieldMatcher(f);\n  return field => !m(field, undefined, undefined);\n}","map":{"version":3,"names":["FieldType","getFieldDisplayName","DimensionError","isGraphable","field","type","number","getXYDimensions","cfg","data","length","error","NoData","frame","BadFrameSelection","xIndex","i","fields","f","x","hasTime","time","exclude","name","includes","push","getSimpleFieldMatcher","y","getSimpleFieldNotMatcher","hasData","state","m","undefined"],"sources":["/home/soula/grafana/public/app/plugins/panel/xychart/dims.ts"],"sourcesContent":["import { DataFrame, Field, FieldMatcher, FieldType, getFieldDisplayName } from '@grafana/data';\nimport { XYFieldMatchers } from '@grafana/ui/src/components/GraphNG/types';\n\nimport { XYDimensionConfig } from './models.gen';\n\n// TODO: fix import\n\nexport enum DimensionError {\n  NoData,\n  BadFrameSelection,\n  XNotFound,\n}\n\nexport interface XYDimensions {\n  frame: DataFrame; // matches order from configs, excluds non-graphable values\n  x: Field;\n  fields: XYFieldMatchers;\n  error?: DimensionError;\n  hasData?: boolean;\n  hasTime?: boolean;\n}\n\nexport function isGraphable(field: Field) {\n  return field.type === FieldType.number;\n}\n\nexport function getXYDimensions(cfg?: XYDimensionConfig, data?: DataFrame[]): XYDimensions {\n  if (!data || !data.length) {\n    return { error: DimensionError.NoData } as XYDimensions;\n  }\n  if (!cfg) {\n    cfg = {\n      frame: 0,\n    };\n  }\n\n  let frame = data[cfg.frame ?? 0];\n  if (!frame) {\n    return { error: DimensionError.BadFrameSelection } as XYDimensions;\n  }\n\n  let xIndex = -1;\n  for (let i = 0; i < frame.fields.length; i++) {\n    const f = frame.fields[i];\n    if (cfg.x && cfg.x === getFieldDisplayName(f, frame, data)) {\n      xIndex = i;\n      break;\n    }\n    if (isGraphable(f) && !cfg.x) {\n      xIndex = i;\n      break;\n    }\n  }\n\n  let hasTime = false;\n  const x = frame.fields[xIndex];\n  const fields: Field[] = [x];\n  for (const f of frame.fields) {\n    if (f.type === FieldType.time) {\n      hasTime = true;\n    }\n    if (f === x || !isGraphable(f)) {\n      continue;\n    }\n    if (cfg.exclude) {\n      const name = getFieldDisplayName(f, frame, data);\n      if (cfg.exclude.includes(name)) {\n        continue;\n      }\n    }\n    fields.push(f);\n  }\n\n  return {\n    x,\n    fields: {\n      x: getSimpleFieldMatcher(x),\n      y: getSimpleFieldNotMatcher(x), // Not x\n    },\n    frame: {\n      ...frame,\n      fields,\n    },\n    hasData: frame.fields.length > 0,\n    hasTime,\n  };\n}\n\nfunction getSimpleFieldMatcher(f: Field): FieldMatcher {\n  if (!f) {\n    return () => false;\n  }\n  // the field may change if sorted\n  return (field) => f === field || !!(f.state && f.state === field.state);\n}\n\nfunction getSimpleFieldNotMatcher(f: Field): FieldMatcher {\n  if (!f) {\n    return () => false;\n  }\n  const m = getSimpleFieldMatcher(f);\n  return (field) => !m(field, undefined as any, undefined as any);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}