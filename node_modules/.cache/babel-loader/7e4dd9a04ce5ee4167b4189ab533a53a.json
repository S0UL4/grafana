{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { dateTimeParse } from '../../datetime';\nimport { FieldType } from '../../types/dataFrame';\nimport { ArrayVector } from '../../vector';\nimport { fieldMatchers } from '../matchers';\nimport { FieldMatcherID } from '../matchers/ids';\nimport { DataTransformerID } from './ids';\nexport const convertFieldTypeTransformer = {\n  id: DataTransformerID.convertFieldType,\n  name: 'Convert field type',\n  description: 'Convert a field to a specified field type',\n  defaultOptions: {\n    fields: {},\n    conversions: [{\n      targetField: undefined,\n      destinationType: undefined,\n      dateFormat: undefined\n    }]\n  },\n  operator: options => source => source.pipe(map(data => convertFieldTypeTransformer.transformer(options)(data))),\n  transformer: options => data => {\n    if (!Array.isArray(data) || data.length === 0) {\n      return data;\n    }\n\n    const timeParsed = convertFieldTypes(options, data);\n\n    if (!timeParsed) {\n      return [];\n    }\n\n    return timeParsed;\n  }\n};\n/**\n * Convert field types for dataframe(s)\n * @param options - field type conversion options\n * @param frames - dataframe(s) with field types to convert\n * @returns dataframe(s) with converted field types\n */\n\nexport function convertFieldTypes(options, frames) {\n  if (!options.conversions.length) {\n    return frames;\n  }\n\n  const framesCopy = frames.map(frame => Object.assign({}, frame));\n\n  for (const conversion of options.conversions) {\n    if (!conversion.targetField) {\n      continue;\n    }\n\n    const matches = fieldMatchers.get(FieldMatcherID.byName).get(conversion.targetField);\n\n    for (const frame of framesCopy) {\n      frame.fields = frame.fields.map(field => {\n        if (matches(field, frame, framesCopy)) {\n          return convertFieldType(field, conversion);\n        }\n\n        return field;\n      });\n    }\n  }\n\n  return framesCopy;\n}\n/**\n * Convert a single field type to specified field type.\n * @param field - field to convert\n * @param opts - field conversion options\n * @returns converted field\n *\n * @internal\n */\n\nexport function convertFieldType(field, opts) {\n  switch (opts.destinationType) {\n    case FieldType.time:\n      return ensureTimeField(field, opts.dateFormat);\n\n    case FieldType.number:\n      return fieldToNumberField(field);\n\n    case FieldType.string:\n      return fieldToStringField(field);\n\n    case FieldType.boolean:\n      return fieldToBooleanField(field);\n\n    case FieldType.other:\n      return fieldToComplexField(field);\n\n    default:\n      return field;\n  }\n} // matches ISO 8601, e.g. 2021-11-11T19:45:00.000Z (float portion optional)\n\nconst iso8601Regex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3})?Z$/;\n/**\n * @internal\n */\n\nexport function fieldToTimeField(field, dateFormat) {\n  let opts = dateFormat ? {\n    format: dateFormat\n  } : undefined;\n  const timeValues = field.values.toArray().slice();\n  let firstDefined = timeValues.find(v => v != null);\n  let isISO8601 = typeof firstDefined === 'string' && iso8601Regex.test(firstDefined);\n\n  for (let t = 0; t < timeValues.length; t++) {\n    if (timeValues[t]) {\n      let parsed = isISO8601 ? Date.parse(timeValues[t]) : dateTimeParse(timeValues[t], opts).valueOf();\n      timeValues[t] = Number.isFinite(parsed) ? parsed : null;\n    } else {\n      timeValues[t] = null;\n    }\n  }\n\n  return Object.assign({}, field, {\n    type: FieldType.time,\n    values: new ArrayVector(timeValues)\n  });\n}\n\nfunction fieldToNumberField(field) {\n  const numValues = field.values.toArray().slice();\n\n  for (let n = 0; n < numValues.length; n++) {\n    const number = +numValues[n];\n    numValues[n] = Number.isFinite(number) ? number : null;\n  }\n\n  return Object.assign({}, field, {\n    type: FieldType.number,\n    values: new ArrayVector(numValues)\n  });\n}\n\nfunction fieldToBooleanField(field) {\n  const booleanValues = field.values.toArray().slice();\n\n  for (let b = 0; b < booleanValues.length; b++) {\n    booleanValues[b] = Boolean(!!booleanValues[b]);\n  }\n\n  return Object.assign({}, field, {\n    type: FieldType.boolean,\n    values: new ArrayVector(booleanValues)\n  });\n}\n\nfunction fieldToStringField(field) {\n  const stringValues = field.values.toArray().slice();\n\n  for (let s = 0; s < stringValues.length; s++) {\n    stringValues[s] = `${stringValues[s]}`;\n  }\n\n  return Object.assign({}, field, {\n    type: FieldType.string,\n    values: new ArrayVector(stringValues)\n  });\n}\n\nfunction fieldToComplexField(field) {\n  const complexValues = field.values.toArray().slice();\n\n  for (let s = 0; s < complexValues.length; s++) {\n    try {\n      complexValues[s] = JSON.parse(complexValues[s]);\n    } catch {\n      complexValues[s] = null;\n    }\n  }\n\n  return Object.assign({}, field, {\n    type: FieldType.other,\n    values: new ArrayVector(complexValues)\n  });\n}\n/**\n * Checks the first value. Assumes any number should be time fieldtype. Otherwise attempts to make the fieldtype time.\n * @param field - field to ensure is a time fieldtype\n * @param dateFormat - date format used to parse a string datetime\n * @returns field as time\n *\n * @public\n */\n\n\nexport function ensureTimeField(field, dateFormat) {\n  const firstValueTypeIsNumber = typeof field.values.get(0) === 'number';\n\n  if (field.type === FieldType.time && firstValueTypeIsNumber) {\n    return field; //already time\n  }\n\n  if (firstValueTypeIsNumber) {\n    return Object.assign({}, field, {\n      type: FieldType.time //assumes it should be time\n\n    });\n  }\n\n  return fieldToTimeField(field, dateFormat);\n}","map":{"version":3,"names":["map","dateTimeParse","FieldType","ArrayVector","fieldMatchers","FieldMatcherID","DataTransformerID","convertFieldTypeTransformer","id","convertFieldType","name","description","defaultOptions","fields","conversions","targetField","undefined","destinationType","dateFormat","operator","options","source","pipe","data","transformer","Array","isArray","length","timeParsed","convertFieldTypes","frames","framesCopy","frame","conversion","matches","get","byName","field","opts","time","ensureTimeField","number","fieldToNumberField","string","fieldToStringField","boolean","fieldToBooleanField","other","fieldToComplexField","iso8601Regex","fieldToTimeField","format","timeValues","values","toArray","slice","firstDefined","find","v","isISO8601","test","t","parsed","Date","parse","valueOf","Number","isFinite","type","numValues","n","booleanValues","b","Boolean","stringValues","s","complexValues","JSON","firstValueTypeIsNumber"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/convertFieldType.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { dateTimeParse } from '../../datetime';\nimport { SynchronousDataTransformerInfo } from '../../types';\nimport { DataFrame, Field, FieldType } from '../../types/dataFrame';\nimport { ArrayVector } from '../../vector';\nimport { fieldMatchers } from '../matchers';\nimport { FieldMatcherID } from '../matchers/ids';\n\nimport { DataTransformerID } from './ids';\n\nexport interface ConvertFieldTypeTransformerOptions {\n  conversions: ConvertFieldTypeOptions[];\n}\n\nexport interface ConvertFieldTypeOptions {\n  /**\n   * The field to convert field type\n   */\n  targetField?: string;\n  /**\n   * The field type to convert to\n   */\n  destinationType?: FieldType;\n  /**\n   * Date format to parse a string datetime\n   */\n  dateFormat?: string;\n}\n\nexport const convertFieldTypeTransformer: SynchronousDataTransformerInfo<ConvertFieldTypeTransformerOptions> = {\n  id: DataTransformerID.convertFieldType,\n  name: 'Convert field type',\n  description: 'Convert a field to a specified field type',\n  defaultOptions: {\n    fields: {},\n    conversions: [{ targetField: undefined, destinationType: undefined, dateFormat: undefined }],\n  },\n\n  operator: (options) => (source) => source.pipe(map((data) => convertFieldTypeTransformer.transformer(options)(data))),\n\n  transformer: (options: ConvertFieldTypeTransformerOptions) => (data: DataFrame[]) => {\n    if (!Array.isArray(data) || data.length === 0) {\n      return data;\n    }\n    const timeParsed = convertFieldTypes(options, data);\n    if (!timeParsed) {\n      return [];\n    }\n    return timeParsed;\n  },\n};\n\n/**\n * Convert field types for dataframe(s)\n * @param options - field type conversion options\n * @param frames - dataframe(s) with field types to convert\n * @returns dataframe(s) with converted field types\n */\nexport function convertFieldTypes(options: ConvertFieldTypeTransformerOptions, frames: DataFrame[]): DataFrame[] {\n  if (!options.conversions.length) {\n    return frames;\n  }\n\n  const framesCopy = frames.map((frame) => ({ ...frame }));\n\n  for (const conversion of options.conversions) {\n    if (!conversion.targetField) {\n      continue;\n    }\n    const matches = fieldMatchers.get(FieldMatcherID.byName).get(conversion.targetField);\n    for (const frame of framesCopy) {\n      frame.fields = frame.fields.map((field) => {\n        if (matches(field, frame, framesCopy)) {\n          return convertFieldType(field, conversion);\n        }\n        return field;\n      });\n    }\n  }\n\n  return framesCopy;\n}\n\n/**\n * Convert a single field type to specified field type.\n * @param field - field to convert\n * @param opts - field conversion options\n * @returns converted field\n *\n * @internal\n */\nexport function convertFieldType(field: Field, opts: ConvertFieldTypeOptions): Field {\n  switch (opts.destinationType) {\n    case FieldType.time:\n      return ensureTimeField(field, opts.dateFormat);\n    case FieldType.number:\n      return fieldToNumberField(field);\n    case FieldType.string:\n      return fieldToStringField(field);\n    case FieldType.boolean:\n      return fieldToBooleanField(field);\n    case FieldType.other:\n      return fieldToComplexField(field);\n    default:\n      return field;\n  }\n}\n\n// matches ISO 8601, e.g. 2021-11-11T19:45:00.000Z (float portion optional)\nconst iso8601Regex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3})?Z$/;\n\n/**\n * @internal\n */\nexport function fieldToTimeField(field: Field, dateFormat?: string): Field {\n  let opts = dateFormat ? { format: dateFormat } : undefined;\n\n  const timeValues = field.values.toArray().slice();\n\n  let firstDefined = timeValues.find((v) => v != null);\n\n  let isISO8601 = typeof firstDefined === 'string' && iso8601Regex.test(firstDefined);\n\n  for (let t = 0; t < timeValues.length; t++) {\n    if (timeValues[t]) {\n      let parsed = isISO8601 ? Date.parse(timeValues[t]) : dateTimeParse(timeValues[t], opts).valueOf();\n      timeValues[t] = Number.isFinite(parsed) ? parsed : null;\n    } else {\n      timeValues[t] = null;\n    }\n  }\n\n  return {\n    ...field,\n    type: FieldType.time,\n    values: new ArrayVector(timeValues),\n  };\n}\n\nfunction fieldToNumberField(field: Field): Field {\n  const numValues = field.values.toArray().slice();\n\n  for (let n = 0; n < numValues.length; n++) {\n    const number = +numValues[n];\n    numValues[n] = Number.isFinite(number) ? number : null;\n  }\n\n  return {\n    ...field,\n    type: FieldType.number,\n    values: new ArrayVector(numValues),\n  };\n}\n\nfunction fieldToBooleanField(field: Field): Field {\n  const booleanValues = field.values.toArray().slice();\n\n  for (let b = 0; b < booleanValues.length; b++) {\n    booleanValues[b] = Boolean(!!booleanValues[b]);\n  }\n\n  return {\n    ...field,\n    type: FieldType.boolean,\n    values: new ArrayVector(booleanValues),\n  };\n}\n\nfunction fieldToStringField(field: Field): Field {\n  const stringValues = field.values.toArray().slice();\n\n  for (let s = 0; s < stringValues.length; s++) {\n    stringValues[s] = `${stringValues[s]}`;\n  }\n\n  return {\n    ...field,\n    type: FieldType.string,\n    values: new ArrayVector(stringValues),\n  };\n}\n\nfunction fieldToComplexField(field: Field): Field {\n  const complexValues = field.values.toArray().slice();\n\n  for (let s = 0; s < complexValues.length; s++) {\n    try {\n      complexValues[s] = JSON.parse(complexValues[s]);\n    } catch {\n      complexValues[s] = null;\n    }\n  }\n\n  return {\n    ...field,\n    type: FieldType.other,\n    values: new ArrayVector(complexValues),\n  };\n}\n\n/**\n * Checks the first value. Assumes any number should be time fieldtype. Otherwise attempts to make the fieldtype time.\n * @param field - field to ensure is a time fieldtype\n * @param dateFormat - date format used to parse a string datetime\n * @returns field as time\n *\n * @public\n */\nexport function ensureTimeField(field: Field, dateFormat?: string): Field {\n  const firstValueTypeIsNumber = typeof field.values.get(0) === 'number';\n  if (field.type === FieldType.time && firstValueTypeIsNumber) {\n    return field; //already time\n  }\n  if (firstValueTypeIsNumber) {\n    return {\n      ...field,\n      type: FieldType.time, //assumes it should be time\n    };\n  }\n  return fieldToTimeField(field, dateFormat);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}