{"ast":null,"code":"import { valid, gte } from 'semver';\nimport { isMetricAggregationWithField } from './components/QueryEditor/MetricAggregationsEditor/aggregations';\nimport { metricAggregationConfig } from './components/QueryEditor/MetricAggregationsEditor/utils';\nexport const describeMetric = metric => {\n  if (!isMetricAggregationWithField(metric)) {\n    return metricAggregationConfig[metric.type].label;\n  } // TODO: field might be undefined\n\n\n  return `${metricAggregationConfig[metric.type].label} ${metric.field}`;\n};\n/**\n * Utility function to clean up aggregations settings objects.\n * It removes nullish values and empty strings, array and objects\n * recursing over nested objects (not arrays).\n * @param obj\n */\n\nexport const removeEmpty = obj => Object.entries(obj).reduce((acc, [key, value]) => {\n  // Removing nullish values (null & undefined)\n  if (value == null) {\n    return Object.assign({}, acc);\n  } // Removing empty arrays (This won't recurse the array)\n\n\n  if (Array.isArray(value) && value.length === 0) {\n    return Object.assign({}, acc);\n  } // Removing empty strings\n\n\n  if ((value === null || value === void 0 ? void 0 : value.length) === 0) {\n    return Object.assign({}, acc);\n  } // Recursing over nested objects\n\n\n  if (!Array.isArray(value) && typeof value === 'object') {\n    const cleanObj = removeEmpty(value);\n\n    if (Object.keys(cleanObj).length === 0) {\n      return Object.assign({}, acc);\n    }\n\n    return Object.assign({}, acc, {\n      [key]: cleanObj\n    });\n  }\n\n  return Object.assign({}, acc, {\n    [key]: value\n  });\n}, {});\n/**\n *  This function converts an order by string to the correct metric id For example,\n *  if the user uses the standard deviation extended stat for the order by,\n *  the value would be \"1[std_deviation]\" and this would return \"1\"\n */\n\nexport const convertOrderByToMetricId = orderBy => {\n  const metricIdMatches = orderBy.match(/^(\\d+)/);\n  return metricIdMatches ? metricIdMatches[1] : void 0;\n};\n/** Gets the actual script value for metrics that support inline scripts.\n *\n *  This is needed because the `script` is a bit polymorphic.\n *  when creating a query with Grafana < 7.4 it was stored as:\n * ```json\n * {\n *    \"settings\": {\n *      \"script\": {\n *        \"inline\": \"value\"\n *      }\n *    }\n * }\n * ```\n *\n * while from 7.4 it's stored as\n * ```json\n * {\n *    \"settings\": {\n *      \"script\": \"value\"\n *    }\n * }\n * ```\n *\n * This allows us to access both formats and support both queries created before 7.4 and after.\n */\n\nexport const getScriptValue = metric => {\n  var _metric$settings, _metric$settings2, _metric$settings2$scr, _metric$settings3;\n\n  return (typeof ((_metric$settings = metric.settings) === null || _metric$settings === void 0 ? void 0 : _metric$settings.script) === 'object' ? (_metric$settings2 = metric.settings) === null || _metric$settings2 === void 0 ? void 0 : (_metric$settings2$scr = _metric$settings2.script) === null || _metric$settings2$scr === void 0 ? void 0 : _metric$settings2$scr.inline : (_metric$settings3 = metric.settings) === null || _metric$settings3 === void 0 ? void 0 : _metric$settings3.script) || '';\n};\n/**\n * Coerces the a version string/number to a valid semver string.\n * It takes care of also converting from the legacy format (numeric) to the new one.\n * @param version\n */\n\nexport const coerceESVersion = version => {\n  if (typeof version === 'string') {\n    return valid(version) || '5.0.0';\n  }\n\n  switch (version) {\n    case 2:\n      return '2.0.0';\n\n    case 56:\n      return '5.6.0';\n\n    case 60:\n      return '6.0.0';\n\n    case 70:\n      return '7.0.0';\n\n    case 5:\n    default:\n      return '5.0.0';\n  }\n};\nexport const isSupportedVersion = version => {\n  if (gte(version, '7.10.0')) {\n    return true;\n  }\n\n  return false;\n};","map":{"version":3,"names":["valid","gte","isMetricAggregationWithField","metricAggregationConfig","describeMetric","metric","type","label","field","removeEmpty","obj","Object","entries","reduce","acc","key","value","Array","isArray","length","cleanObj","keys","convertOrderByToMetricId","orderBy","metricIdMatches","match","getScriptValue","settings","script","inline","coerceESVersion","version","isSupportedVersion"],"sources":["/home/soula/grafana/public/app/plugins/datasource/elasticsearch/utils.ts"],"sourcesContent":["import { valid, gte } from 'semver';\n\nimport {\n  isMetricAggregationWithField,\n  MetricAggregation,\n  MetricAggregationWithInlineScript,\n} from './components/QueryEditor/MetricAggregationsEditor/aggregations';\nimport { metricAggregationConfig } from './components/QueryEditor/MetricAggregationsEditor/utils';\n\nexport const describeMetric = (metric: MetricAggregation) => {\n  if (!isMetricAggregationWithField(metric)) {\n    return metricAggregationConfig[metric.type].label;\n  }\n\n  // TODO: field might be undefined\n  return `${metricAggregationConfig[metric.type].label} ${metric.field}`;\n};\n\n/**\n * Utility function to clean up aggregations settings objects.\n * It removes nullish values and empty strings, array and objects\n * recursing over nested objects (not arrays).\n * @param obj\n */\nexport const removeEmpty = <T>(obj: T): Partial<T> =>\n  Object.entries(obj).reduce((acc, [key, value]) => {\n    // Removing nullish values (null & undefined)\n    if (value == null) {\n      return { ...acc };\n    }\n\n    // Removing empty arrays (This won't recurse the array)\n    if (Array.isArray(value) && value.length === 0) {\n      return { ...acc };\n    }\n\n    // Removing empty strings\n    if (value?.length === 0) {\n      return { ...acc };\n    }\n\n    // Recursing over nested objects\n    if (!Array.isArray(value) && typeof value === 'object') {\n      const cleanObj = removeEmpty(value);\n\n      if (Object.keys(cleanObj).length === 0) {\n        return { ...acc };\n      }\n\n      return { ...acc, [key]: cleanObj };\n    }\n\n    return {\n      ...acc,\n      [key]: value,\n    };\n  }, {});\n\n/**\n *  This function converts an order by string to the correct metric id For example,\n *  if the user uses the standard deviation extended stat for the order by,\n *  the value would be \"1[std_deviation]\" and this would return \"1\"\n */\nexport const convertOrderByToMetricId = (orderBy: string): string | undefined => {\n  const metricIdMatches = orderBy.match(/^(\\d+)/);\n  return metricIdMatches ? metricIdMatches[1] : void 0;\n};\n\n/** Gets the actual script value for metrics that support inline scripts.\n *\n *  This is needed because the `script` is a bit polymorphic.\n *  when creating a query with Grafana < 7.4 it was stored as:\n * ```json\n * {\n *    \"settings\": {\n *      \"script\": {\n *        \"inline\": \"value\"\n *      }\n *    }\n * }\n * ```\n *\n * while from 7.4 it's stored as\n * ```json\n * {\n *    \"settings\": {\n *      \"script\": \"value\"\n *    }\n * }\n * ```\n *\n * This allows us to access both formats and support both queries created before 7.4 and after.\n */\nexport const getScriptValue = (metric: MetricAggregationWithInlineScript) =>\n  (typeof metric.settings?.script === 'object' ? metric.settings?.script?.inline : metric.settings?.script) || '';\n\n/**\n * Coerces the a version string/number to a valid semver string.\n * It takes care of also converting from the legacy format (numeric) to the new one.\n * @param version\n */\nexport const coerceESVersion = (version: string | number): string => {\n  if (typeof version === 'string') {\n    return valid(version) || '5.0.0';\n  }\n\n  switch (version) {\n    case 2:\n      return '2.0.0';\n    case 56:\n      return '5.6.0';\n    case 60:\n      return '6.0.0';\n    case 70:\n      return '7.0.0';\n    case 5:\n    default:\n      return '5.0.0';\n  }\n};\n\nexport const isSupportedVersion = (version: string): boolean => {\n  if (gte(version, '7.10.0')) {\n    return true;\n  }\n\n  return false;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}