{"ast":null,"code":"import { clamp } from 'lodash';\nimport { getCategories } from './categories';\nimport { toDateTimeValueFormatter } from './dateTimeFormatters';\nimport { getOffsetFromSIPrefix, SIPrefix, currency } from './symbolFormatters';\nexport function formattedValueToString(val) {\n  var _val$prefix, _val$suffix;\n\n  return `${(_val$prefix = val.prefix) !== null && _val$prefix !== void 0 ? _val$prefix : ''}${val.text}${(_val$suffix = val.suffix) !== null && _val$suffix !== void 0 ? _val$suffix : ''}`;\n}\n// Globals & formats cache\nlet categories = [];\nconst index = {};\nlet hasBuiltIndex = false;\nexport function toFixed(value, decimals) {\n  if (value === null) {\n    return '';\n  }\n\n  if (value === Number.NEGATIVE_INFINITY || value === Number.POSITIVE_INFINITY) {\n    return value.toLocaleString();\n  }\n\n  if (decimals === null || decimals === undefined) {\n    decimals = getDecimalsForValue(value);\n  }\n\n  if (value === 0) {\n    return value.toFixed(decimals);\n  }\n\n  const factor = decimals ? Math.pow(10, Math.max(0, decimals)) : 1;\n  const formatted = String(Math.round(value * factor) / factor); // if exponent return directly\n\n  if (formatted.indexOf('e') !== -1 || value === 0) {\n    return formatted;\n  }\n\n  const decimalPos = formatted.indexOf('.');\n  const precision = decimalPos === -1 ? 0 : formatted.length - decimalPos - 1;\n\n  if (precision < decimals) {\n    return (precision ? formatted : formatted + '.') + String(factor).slice(1, decimals - precision + 1);\n  }\n\n  return formatted;\n}\n\nfunction getDecimalsForValue(value) {\n  const log10 = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  let dec = -log10 + 1;\n  const magn = Math.pow(10, -dec);\n  const norm = value / magn; // norm is between 1.0 and 10.0\n  // special case for 2.5, requires an extra decimal\n\n  if (norm > 2.25) {\n    ++dec;\n  }\n\n  if (value % 1 === 0) {\n    dec = 0;\n  }\n\n  const decimals = Math.max(0, dec);\n  return decimals;\n}\n\nexport function toFixedScaled(value, decimals, ext) {\n  return {\n    text: toFixed(value, decimals),\n    suffix: ext\n  };\n}\nexport function toFixedUnit(unit, asPrefix) {\n  return (size, decimals) => {\n    if (size === null) {\n      return {\n        text: ''\n      };\n    }\n\n    const text = toFixed(size, decimals);\n\n    if (unit) {\n      if (asPrefix) {\n        return {\n          text,\n          prefix: unit\n        };\n      }\n\n      return {\n        text,\n        suffix: ' ' + unit\n      };\n    }\n\n    return {\n      text\n    };\n  };\n}\nexport function isBooleanUnit(unit) {\n  return unit && unit.startsWith('bool');\n}\nexport function booleanValueFormatter(t, f) {\n  return value => {\n    return {\n      text: value ? t : f\n    };\n  };\n}\n\nconst logb = (b, x) => Math.log10(x) / Math.log10(b);\n\nexport function scaledUnits(factor, extArray, offset = 0) {\n  return (size, decimals) => {\n    if (size === null) {\n      return {\n        text: ''\n      };\n    }\n\n    if (size === Number.NEGATIVE_INFINITY || size === Number.POSITIVE_INFINITY || isNaN(size)) {\n      return {\n        text: size.toLocaleString()\n      };\n    }\n\n    const siIndex = size === 0 ? 0 : Math.floor(logb(factor, Math.abs(size)));\n    const suffix = extArray[clamp(offset + siIndex, 0, extArray.length - 1)];\n    return {\n      text: toFixed(size / factor ** clamp(siIndex, -offset, extArray.length - offset - 1), decimals),\n      suffix\n    };\n  };\n}\nexport function locale(value, decimals) {\n  if (value == null) {\n    return {\n      text: ''\n    };\n  }\n\n  return {\n    text: value.toLocaleString(undefined, {\n      maximumFractionDigits: decimals\n    })\n  };\n}\nexport function simpleCountUnit(symbol) {\n  const units = ['', 'K', 'M', 'B', 'T'];\n  const scaler = scaledUnits(1000, units);\n  return (size, decimals, scaledDecimals) => {\n    if (size === null) {\n      return {\n        text: ''\n      };\n    }\n\n    const v = scaler(size, decimals, scaledDecimals);\n    v.suffix += ' ' + symbol;\n    return v;\n  };\n}\nexport function stringFormater(value) {\n  return {\n    text: `${value}`\n  };\n}\n\nfunction buildFormats() {\n  categories = getCategories();\n\n  for (const cat of categories) {\n    for (const format of cat.formats) {\n      index[format.id] = format.fn;\n    }\n  } // Resolve units pointing to old IDs\n\n\n  [{\n    from: 'farenheit',\n    to: 'fahrenheit'\n  }].forEach(alias => {\n    const f = index[alias.to];\n\n    if (f) {\n      index[alias.from] = f;\n    }\n  });\n  hasBuiltIndex = true;\n}\n\nexport function getValueFormat(id) {\n  if (!id) {\n    return toFixedUnit('');\n  }\n\n  if (!hasBuiltIndex) {\n    buildFormats();\n  }\n\n  const fmt = index[id];\n\n  if (!fmt && id) {\n    let idx = id.indexOf(':');\n\n    if (idx > 0) {\n      const key = id.substring(0, idx);\n      const sub = id.substring(idx + 1);\n\n      if (key === 'prefix') {\n        return toFixedUnit(sub, true);\n      }\n\n      if (key === 'suffix') {\n        return toFixedUnit(sub, false);\n      }\n\n      if (key === 'time') {\n        return toDateTimeValueFormatter(sub);\n      }\n\n      if (key === 'si') {\n        const offset = getOffsetFromSIPrefix(sub.charAt(0));\n        const unit = offset === 0 ? sub : sub.substring(1);\n        return SIPrefix(unit, offset);\n      }\n\n      if (key === 'count') {\n        return simpleCountUnit(sub);\n      }\n\n      if (key === 'currency') {\n        return currency(sub);\n      }\n\n      if (key === 'bool') {\n        idx = sub.indexOf('/');\n\n        if (idx >= 0) {\n          const t = sub.substring(0, idx);\n          const f = sub.substring(idx + 1);\n          return booleanValueFormatter(t, f);\n        }\n\n        return booleanValueFormatter(sub, '-');\n      }\n    }\n\n    return toFixedUnit(id);\n  }\n\n  return fmt;\n}\nexport function getValueFormatterIndex() {\n  if (!hasBuiltIndex) {\n    buildFormats();\n  }\n\n  return index;\n}\nexport function getValueFormats() {\n  if (!hasBuiltIndex) {\n    buildFormats();\n  }\n\n  return categories.map(cat => {\n    return {\n      text: cat.name,\n      submenu: cat.formats.map(format => {\n        return {\n          text: format.name,\n          value: format.id\n        };\n      })\n    };\n  });\n}","map":{"version":3,"names":["clamp","getCategories","toDateTimeValueFormatter","getOffsetFromSIPrefix","SIPrefix","currency","formattedValueToString","val","prefix","text","suffix","categories","index","hasBuiltIndex","toFixed","value","decimals","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","toLocaleString","undefined","getDecimalsForValue","factor","Math","pow","max","formatted","String","round","indexOf","decimalPos","precision","length","slice","log10","floor","log","abs","LN10","dec","magn","norm","toFixedScaled","ext","toFixedUnit","unit","asPrefix","size","isBooleanUnit","startsWith","booleanValueFormatter","t","f","logb","b","x","scaledUnits","extArray","offset","isNaN","siIndex","locale","maximumFractionDigits","simpleCountUnit","symbol","units","scaler","scaledDecimals","v","stringFormater","buildFormats","cat","format","formats","id","fn","from","to","forEach","alias","getValueFormat","fmt","idx","key","substring","sub","charAt","getValueFormatterIndex","getValueFormats","map","name","submenu"],"sources":["/home/soula/grafana/packages/grafana-data/src/valueFormats/valueFormats.ts"],"sourcesContent":["import { clamp } from 'lodash';\n\nimport { TimeZone } from '../types';\nimport { DecimalCount } from '../types/displayValue';\n\nimport { getCategories } from './categories';\nimport { toDateTimeValueFormatter } from './dateTimeFormatters';\nimport { getOffsetFromSIPrefix, SIPrefix, currency } from './symbolFormatters';\n\nexport interface FormattedValue {\n  text: string;\n  prefix?: string;\n  suffix?: string;\n}\n\nexport function formattedValueToString(val: FormattedValue): string {\n  return `${val.prefix ?? ''}${val.text}${val.suffix ?? ''}`;\n}\n\nexport type ValueFormatter = (\n  value: number,\n  decimals?: DecimalCount,\n  scaledDecimals?: DecimalCount,\n  timeZone?: TimeZone,\n  showMs?: boolean\n) => FormattedValue;\n\nexport interface ValueFormat {\n  name: string;\n  id: string;\n  fn: ValueFormatter;\n}\n\nexport interface ValueFormatCategory {\n  name: string;\n  formats: ValueFormat[];\n}\n\nexport interface ValueFormatterIndex {\n  [id: string]: ValueFormatter;\n}\n\n// Globals & formats cache\nlet categories: ValueFormatCategory[] = [];\nconst index: ValueFormatterIndex = {};\nlet hasBuiltIndex = false;\n\nexport function toFixed(value: number, decimals?: DecimalCount): string {\n  if (value === null) {\n    return '';\n  }\n\n  if (value === Number.NEGATIVE_INFINITY || value === Number.POSITIVE_INFINITY) {\n    return value.toLocaleString();\n  }\n\n  if (decimals === null || decimals === undefined) {\n    decimals = getDecimalsForValue(value);\n  }\n\n  if (value === 0) {\n    return value.toFixed(decimals);\n  }\n\n  const factor = decimals ? Math.pow(10, Math.max(0, decimals)) : 1;\n  const formatted = String(Math.round(value * factor) / factor);\n\n  // if exponent return directly\n  if (formatted.indexOf('e') !== -1 || value === 0) {\n    return formatted;\n  }\n\n  const decimalPos = formatted.indexOf('.');\n  const precision = decimalPos === -1 ? 0 : formatted.length - decimalPos - 1;\n  if (precision < decimals) {\n    return (precision ? formatted : formatted + '.') + String(factor).slice(1, decimals - precision + 1);\n  }\n\n  return formatted;\n}\n\nfunction getDecimalsForValue(value: number): number {\n  const log10 = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  let dec = -log10 + 1;\n  const magn = Math.pow(10, -dec);\n  const norm = value / magn; // norm is between 1.0 and 10.0\n\n  // special case for 2.5, requires an extra decimal\n  if (norm > 2.25) {\n    ++dec;\n  }\n\n  if (value % 1 === 0) {\n    dec = 0;\n  }\n\n  const decimals = Math.max(0, dec);\n  return decimals;\n}\n\nexport function toFixedScaled(value: number, decimals: DecimalCount, ext?: string): FormattedValue {\n  return {\n    text: toFixed(value, decimals),\n    suffix: ext,\n  };\n}\n\nexport function toFixedUnit(unit: string, asPrefix?: boolean): ValueFormatter {\n  return (size: number, decimals?: DecimalCount) => {\n    if (size === null) {\n      return { text: '' };\n    }\n    const text = toFixed(size, decimals);\n    if (unit) {\n      if (asPrefix) {\n        return { text, prefix: unit };\n      }\n      return { text, suffix: ' ' + unit };\n    }\n    return { text };\n  };\n}\n\nexport function isBooleanUnit(unit?: string) {\n  return unit && unit.startsWith('bool');\n}\n\nexport function booleanValueFormatter(t: string, f: string): ValueFormatter {\n  return (value: any) => {\n    return { text: value ? t : f };\n  };\n}\n\nconst logb = (b: number, x: number) => Math.log10(x) / Math.log10(b);\n\nexport function scaledUnits(factor: number, extArray: string[], offset = 0): ValueFormatter {\n  return (size: number, decimals?: DecimalCount) => {\n    if (size === null) {\n      return { text: '' };\n    }\n\n    if (size === Number.NEGATIVE_INFINITY || size === Number.POSITIVE_INFINITY || isNaN(size)) {\n      return { text: size.toLocaleString() };\n    }\n\n    const siIndex = size === 0 ? 0 : Math.floor(logb(factor, Math.abs(size)));\n    const suffix = extArray[clamp(offset + siIndex, 0, extArray.length - 1)];\n\n    return {\n      text: toFixed(size / factor ** clamp(siIndex, -offset, extArray.length - offset - 1), decimals),\n      suffix,\n    };\n  };\n}\n\nexport function locale(value: number, decimals: DecimalCount): FormattedValue {\n  if (value == null) {\n    return { text: '' };\n  }\n  return {\n    text: value.toLocaleString(undefined, { maximumFractionDigits: decimals as number }),\n  };\n}\n\nexport function simpleCountUnit(symbol: string): ValueFormatter {\n  const units = ['', 'K', 'M', 'B', 'T'];\n  const scaler = scaledUnits(1000, units);\n  return (size: number, decimals?: DecimalCount, scaledDecimals?: DecimalCount) => {\n    if (size === null) {\n      return { text: '' };\n    }\n    const v = scaler(size, decimals, scaledDecimals);\n    v.suffix += ' ' + symbol;\n    return v;\n  };\n}\n\nexport function stringFormater(value: number): FormattedValue {\n  return { text: `${value}` };\n}\n\nfunction buildFormats() {\n  categories = getCategories();\n\n  for (const cat of categories) {\n    for (const format of cat.formats) {\n      index[format.id] = format.fn;\n    }\n  }\n\n  // Resolve units pointing to old IDs\n  [{ from: 'farenheit', to: 'fahrenheit' }].forEach((alias) => {\n    const f = index[alias.to];\n    if (f) {\n      index[alias.from] = f;\n    }\n  });\n\n  hasBuiltIndex = true;\n}\n\nexport function getValueFormat(id?: string | null): ValueFormatter {\n  if (!id) {\n    return toFixedUnit('');\n  }\n\n  if (!hasBuiltIndex) {\n    buildFormats();\n  }\n\n  const fmt = index[id];\n\n  if (!fmt && id) {\n    let idx = id.indexOf(':');\n\n    if (idx > 0) {\n      const key = id.substring(0, idx);\n      const sub = id.substring(idx + 1);\n\n      if (key === 'prefix') {\n        return toFixedUnit(sub, true);\n      }\n\n      if (key === 'suffix') {\n        return toFixedUnit(sub, false);\n      }\n\n      if (key === 'time') {\n        return toDateTimeValueFormatter(sub);\n      }\n\n      if (key === 'si') {\n        const offset = getOffsetFromSIPrefix(sub.charAt(0));\n        const unit = offset === 0 ? sub : sub.substring(1);\n        return SIPrefix(unit, offset);\n      }\n\n      if (key === 'count') {\n        return simpleCountUnit(sub);\n      }\n\n      if (key === 'currency') {\n        return currency(sub);\n      }\n\n      if (key === 'bool') {\n        idx = sub.indexOf('/');\n        if (idx >= 0) {\n          const t = sub.substring(0, idx);\n          const f = sub.substring(idx + 1);\n          return booleanValueFormatter(t, f);\n        }\n        return booleanValueFormatter(sub, '-');\n      }\n    }\n\n    return toFixedUnit(id);\n  }\n\n  return fmt;\n}\n\nexport function getValueFormatterIndex(): ValueFormatterIndex {\n  if (!hasBuiltIndex) {\n    buildFormats();\n  }\n\n  return index;\n}\n\nexport function getValueFormats() {\n  if (!hasBuiltIndex) {\n    buildFormats();\n  }\n\n  return categories.map((cat) => {\n    return {\n      text: cat.name,\n      submenu: cat.formats.map((format) => {\n        return {\n          text: format.name,\n          value: format.id,\n        };\n      }),\n    };\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}