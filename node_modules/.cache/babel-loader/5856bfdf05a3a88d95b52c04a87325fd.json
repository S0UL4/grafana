{"ast":null,"code":"/**\n * Regexp to extract Prometheus-style labels\n */\nconst labelRegexp = /\\b(\\w+)(!?=~?)\"([^\"\\n]*?)\"/g;\n/**\n * Returns a map of label keys to value from an input selector string.\n *\n * Example: `parseLabels('{job=\"foo\", instance=\"bar\"}) // {job: \"foo\", instance: \"bar\"}`\n */\n\nexport function parseLabels(labels) {\n  const labelsByKey = {};\n  labels.replace(labelRegexp, (_, key, operator, value) => {\n    labelsByKey[key] = value;\n    return '';\n  });\n  return labelsByKey;\n}\n/**\n * Returns a map labels that are common to the given label sets.\n */\n\nexport function findCommonLabels(labelsSets) {\n  return labelsSets.reduce((acc, labels) => {\n    if (!labels) {\n      throw new Error('Need parsed labels to find common labels.');\n    }\n\n    if (!acc) {\n      // Initial set\n      acc = Object.assign({}, labels);\n    } else {\n      // Remove incoming labels that are missing or not matching in value\n      Object.keys(labels).forEach(key => {\n        if (acc[key] === undefined || acc[key] !== labels[key]) {\n          delete acc[key];\n        }\n      }); // Remove common labels that are missing from incoming label set\n\n      Object.keys(acc).forEach(key => {\n        if (labels[key] === undefined) {\n          delete acc[key];\n        }\n      });\n    }\n\n    return acc;\n  }, undefined);\n}\n/**\n * Returns a map of labels that are in `labels`, but not in `commonLabels`.\n */\n\nexport function findUniqueLabels(labels, commonLabels) {\n  const uncommonLabels = Object.assign({}, labels);\n  Object.keys(commonLabels).forEach(key => {\n    delete uncommonLabels[key];\n  });\n  return uncommonLabels;\n}\n/**\n * Check that all labels exist in another set of labels\n */\n\nexport function matchAllLabels(expect, against) {\n  if (!expect) {\n    return true; // nothing to match\n  }\n\n  for (const [key, value] of Object.entries(expect)) {\n    if (!against || against[key] !== value) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Serializes the given labels to a string.\n */\n\nexport function formatLabels(labels, defaultValue = '', withoutBraces) {\n  if (!labels || Object.keys(labels).length === 0) {\n    return defaultValue;\n  }\n\n  const labelKeys = Object.keys(labels).sort();\n  const cleanSelector = labelKeys.map(key => `${key}=\"${labels[key]}\"`).join(', ');\n\n  if (withoutBraces) {\n    return cleanSelector;\n  }\n\n  return ['{', cleanSelector, '}'].join('');\n}","map":{"version":3,"names":["labelRegexp","parseLabels","labels","labelsByKey","replace","_","key","operator","value","findCommonLabels","labelsSets","reduce","acc","Error","Object","keys","forEach","undefined","findUniqueLabels","commonLabels","uncommonLabels","matchAllLabels","expect","against","entries","formatLabels","defaultValue","withoutBraces","length","labelKeys","sort","cleanSelector","map","join"],"sources":["/home/soula/grafana/packages/grafana-data/src/utils/labels.ts"],"sourcesContent":["import { Labels } from '../types/data';\n\n/**\n * Regexp to extract Prometheus-style labels\n */\nconst labelRegexp = /\\b(\\w+)(!?=~?)\"([^\"\\n]*?)\"/g;\n\n/**\n * Returns a map of label keys to value from an input selector string.\n *\n * Example: `parseLabels('{job=\"foo\", instance=\"bar\"}) // {job: \"foo\", instance: \"bar\"}`\n */\nexport function parseLabels(labels: string): Labels {\n  const labelsByKey: Labels = {};\n  labels.replace(labelRegexp, (_, key, operator, value) => {\n    labelsByKey[key] = value;\n    return '';\n  });\n  return labelsByKey;\n}\n\n/**\n * Returns a map labels that are common to the given label sets.\n */\nexport function findCommonLabels(labelsSets: Labels[]): Labels {\n  return labelsSets.reduce((acc, labels) => {\n    if (!labels) {\n      throw new Error('Need parsed labels to find common labels.');\n    }\n    if (!acc) {\n      // Initial set\n      acc = { ...labels };\n    } else {\n      // Remove incoming labels that are missing or not matching in value\n      Object.keys(labels).forEach((key) => {\n        if (acc[key] === undefined || acc[key] !== labels[key]) {\n          delete acc[key];\n        }\n      });\n      // Remove common labels that are missing from incoming label set\n      Object.keys(acc).forEach((key) => {\n        if (labels[key] === undefined) {\n          delete acc[key];\n        }\n      });\n    }\n    return acc;\n  }, undefined as unknown as Labels);\n}\n\n/**\n * Returns a map of labels that are in `labels`, but not in `commonLabels`.\n */\nexport function findUniqueLabels(labels: Labels | undefined, commonLabels: Labels): Labels {\n  const uncommonLabels: Labels = { ...labels };\n  Object.keys(commonLabels).forEach((key) => {\n    delete uncommonLabels[key];\n  });\n  return uncommonLabels;\n}\n\n/**\n * Check that all labels exist in another set of labels\n */\nexport function matchAllLabels(expect: Labels, against?: Labels): boolean {\n  if (!expect) {\n    return true; // nothing to match\n  }\n  for (const [key, value] of Object.entries(expect)) {\n    if (!against || against[key] !== value) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Serializes the given labels to a string.\n */\nexport function formatLabels(labels: Labels, defaultValue = '', withoutBraces?: boolean): string {\n  if (!labels || Object.keys(labels).length === 0) {\n    return defaultValue;\n  }\n  const labelKeys = Object.keys(labels).sort();\n  const cleanSelector = labelKeys.map((key) => `${key}=\"${labels[key]}\"`).join(', ');\n  if (withoutBraces) {\n    return cleanSelector;\n  }\n  return ['{', cleanSelector, '}'].join('');\n}\n"],"mappings":"AAEA;AACA;AACA;AACA,MAAMA,WAAW,GAAG,6BAApB;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,WAAT,CAAqBC,MAArB,EAA6C;EAClD,MAAMC,WAAmB,GAAG,EAA5B;EACAD,MAAM,CAACE,OAAP,CAAeJ,WAAf,EAA4B,CAACK,CAAD,EAAIC,GAAJ,EAASC,QAAT,EAAmBC,KAAnB,KAA6B;IACvDL,WAAW,CAACG,GAAD,CAAX,GAAmBE,KAAnB;IACA,OAAO,EAAP;EACD,CAHD;EAIA,OAAOL,WAAP;AACD;AAED;AACA;AACA;;AACA,OAAO,SAASM,gBAAT,CAA0BC,UAA1B,EAAwD;EAC7D,OAAOA,UAAU,CAACC,MAAX,CAAkB,CAACC,GAAD,EAAMV,MAAN,KAAiB;IACxC,IAAI,CAACA,MAAL,EAAa;MACX,MAAM,IAAIW,KAAJ,CAAU,2CAAV,CAAN;IACD;;IACD,IAAI,CAACD,GAAL,EAAU;MACR;MACAA,GAAG,qBAAQV,MAAR,CAAH;IACD,CAHD,MAGO;MACL;MACAY,MAAM,CAACC,IAAP,CAAYb,MAAZ,EAAoBc,OAApB,CAA6BV,GAAD,IAAS;QACnC,IAAIM,GAAG,CAACN,GAAD,CAAH,KAAaW,SAAb,IAA0BL,GAAG,CAACN,GAAD,CAAH,KAAaJ,MAAM,CAACI,GAAD,CAAjD,EAAwD;UACtD,OAAOM,GAAG,CAACN,GAAD,CAAV;QACD;MACF,CAJD,EAFK,CAOL;;MACAQ,MAAM,CAACC,IAAP,CAAYH,GAAZ,EAAiBI,OAAjB,CAA0BV,GAAD,IAAS;QAChC,IAAIJ,MAAM,CAACI,GAAD,CAAN,KAAgBW,SAApB,EAA+B;UAC7B,OAAOL,GAAG,CAACN,GAAD,CAAV;QACD;MACF,CAJD;IAKD;;IACD,OAAOM,GAAP;EACD,CAtBM,EAsBJK,SAtBI,CAAP;AAuBD;AAED;AACA;AACA;;AACA,OAAO,SAASC,gBAAT,CAA0BhB,MAA1B,EAAsDiB,YAAtD,EAAoF;EACzF,MAAMC,cAAsB,qBAAQlB,MAAR,CAA5B;EACAY,MAAM,CAACC,IAAP,CAAYI,YAAZ,EAA0BH,OAA1B,CAAmCV,GAAD,IAAS;IACzC,OAAOc,cAAc,CAACd,GAAD,CAArB;EACD,CAFD;EAGA,OAAOc,cAAP;AACD;AAED;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAwBC,MAAxB,EAAwCC,OAAxC,EAAmE;EACxE,IAAI,CAACD,MAAL,EAAa;IACX,OAAO,IAAP,CADW,CACE;EACd;;EACD,KAAK,MAAM,CAAChB,GAAD,EAAME,KAAN,CAAX,IAA2BM,MAAM,CAACU,OAAP,CAAeF,MAAf,CAA3B,EAAmD;IACjD,IAAI,CAACC,OAAD,IAAYA,OAAO,CAACjB,GAAD,CAAP,KAAiBE,KAAjC,EAAwC;MACtC,OAAO,KAAP;IACD;EACF;;EACD,OAAO,IAAP;AACD;AAED;AACA;AACA;;AACA,OAAO,SAASiB,YAAT,CAAsBvB,MAAtB,EAAsCwB,YAAY,GAAG,EAArD,EAAyDC,aAAzD,EAA0F;EAC/F,IAAI,CAACzB,MAAD,IAAWY,MAAM,CAACC,IAAP,CAAYb,MAAZ,EAAoB0B,MAApB,KAA+B,CAA9C,EAAiD;IAC/C,OAAOF,YAAP;EACD;;EACD,MAAMG,SAAS,GAAGf,MAAM,CAACC,IAAP,CAAYb,MAAZ,EAAoB4B,IAApB,EAAlB;EACA,MAAMC,aAAa,GAAGF,SAAS,CAACG,GAAV,CAAe1B,GAAD,IAAU,GAAEA,GAAI,KAAIJ,MAAM,CAACI,GAAD,CAAM,GAA9C,EAAkD2B,IAAlD,CAAuD,IAAvD,CAAtB;;EACA,IAAIN,aAAJ,EAAmB;IACjB,OAAOI,aAAP;EACD;;EACD,OAAO,CAAC,GAAD,EAAMA,aAAN,EAAqB,GAArB,EAA0BE,IAA1B,CAA+B,EAA/B,CAAP;AACD"},"metadata":{},"sourceType":"module"}