{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { cloneDeep } from 'lodash';\nimport { of, ReplaySubject } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { applyFieldOverrides, compareArrayValues, compareDataFrameStructures, CoreApp, getDefaultTimeRange, LoadingState, rangeUtil, toDataFrame, transformDataFrame } from '@grafana/data';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport { ExpressionDatasourceRef } from '@grafana/runtime/src/utils/DataSourceWithBackend';\nimport { isStreamingDataFrame } from 'app/features/live/data/utils';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\nimport { isSharedDashboardQuery, runSharedRequest } from '../../../plugins/datasource/dashboard';\nimport { PublicDashboardDataSource } from '../../dashboard/services/PublicDashboardDataSource';\nimport { getDashboardQueryRunner } from './DashboardQueryRunner/DashboardQueryRunner';\nimport { mergePanelAndDashData } from './mergePanelAndDashData';\nimport { preProcessPanelData, runRequest } from './runRequest';\nlet counter = 100;\nexport function getNextRequestId() {\n  return 'Q' + counter++;\n}\nexport class PanelQueryRunner {\n  constructor(dataConfigSource) {\n    _defineProperty(this, \"subject\", void 0);\n\n    _defineProperty(this, \"subscription\", void 0);\n\n    _defineProperty(this, \"lastResult\", void 0);\n\n    _defineProperty(this, \"dataConfigSource\", void 0);\n\n    _defineProperty(this, \"lastRequest\", void 0);\n\n    _defineProperty(this, \"getTransformationsStream\", withTransforms => {\n      return inputStream => inputStream.pipe(mergeMap(data => {\n        if (!withTransforms) {\n          return of(data);\n        }\n\n        const transformations = this.dataConfigSource.getTransformations();\n\n        if (!transformations || transformations.length === 0) {\n          return of(data);\n        }\n\n        const replace = option => {\n          var _data$request;\n\n          return getTemplateSrv().replace(option, data === null || data === void 0 ? void 0 : (_data$request = data.request) === null || _data$request === void 0 ? void 0 : _data$request.scopedVars);\n        };\n\n        transformations.forEach(transform => {\n          transform.replace = replace;\n        });\n        return transformDataFrame(transformations, data.series).pipe(map(series => Object.assign({}, data, {\n          series\n        })));\n      }));\n    });\n\n    _defineProperty(this, \"resendLastResult\", () => {\n      if (this.lastResult) {\n        this.subject.next(this.lastResult);\n      }\n    });\n\n    this.subject = new ReplaySubject(1);\n    this.dataConfigSource = dataConfigSource;\n  }\n  /**\n   * Returns an observable that subscribes to the shared multi-cast subject (that reply last result).\n   */\n\n\n  getData(options) {\n    const {\n      withFieldConfig,\n      withTransforms\n    } = options;\n    let structureRev = 1;\n    let lastData = [];\n    let isFirstPacket = true;\n    let lastConfigRev = -1;\n\n    if (this.dataConfigSource.snapshotData) {\n      const snapshotPanelData = {\n        state: LoadingState.Done,\n        series: this.dataConfigSource.snapshotData.map(v => toDataFrame(v)),\n        timeRange: getDefaultTimeRange() // Don't need real time range for snapshots\n\n      };\n      return of(snapshotPanelData);\n    }\n\n    return this.subject.pipe(this.getTransformationsStream(withTransforms), map(data => {\n      var _data$series;\n\n      let processedData = data;\n      let streamingPacketWithSameSchema = false;\n\n      if (withFieldConfig && (_data$series = data.series) !== null && _data$series !== void 0 && _data$series.length) {\n        if (lastConfigRev === this.dataConfigSource.configRev) {\n          const streamingDataFrame = data.series.find(data => isStreamingDataFrame(data));\n\n          if (streamingDataFrame && !streamingDataFrame.packetInfo.schemaChanged && // TODO: remove the condition below after fixing\n          // https://github.com/grafana/grafana/pull/41492#issuecomment-970281430\n          lastData[0].fields.length === streamingDataFrame.fields.length) {\n            processedData = Object.assign({}, processedData, {\n              series: lastData.map((frame, frameIndex) => Object.assign({}, frame, {\n                length: data.series[frameIndex].length,\n                fields: frame.fields.map((field, fieldIndex) => Object.assign({}, field, {\n                  values: data.series[frameIndex].fields[fieldIndex].values,\n                  state: Object.assign({}, field.state, {\n                    calcs: undefined,\n                    range: undefined\n                  })\n                }))\n              }))\n            });\n            streamingPacketWithSameSchema = true;\n          }\n        } // Apply field defaults and overrides\n\n\n        let fieldConfig = this.dataConfigSource.getFieldOverrideOptions();\n\n        if (fieldConfig != null && (isFirstPacket || !streamingPacketWithSameSchema)) {\n          var _data$request$timezon, _data$request2;\n\n          lastConfigRev = this.dataConfigSource.configRev;\n          processedData = Object.assign({}, processedData, {\n            series: applyFieldOverrides(Object.assign({\n              timeZone: (_data$request$timezon = (_data$request2 = data.request) === null || _data$request2 === void 0 ? void 0 : _data$request2.timezone) !== null && _data$request$timezon !== void 0 ? _data$request$timezon : 'browser',\n              data: processedData.series\n            }, fieldConfig))\n          });\n          isFirstPacket = false;\n        }\n      }\n\n      if (!streamingPacketWithSameSchema && !compareArrayValues(lastData, processedData.series, compareDataFrameStructures)) {\n        structureRev++;\n      }\n\n      lastData = processedData.series;\n      return Object.assign({}, processedData, {\n        structureRev\n      });\n    }));\n  }\n\n  async run(options) {\n    const {\n      queries,\n      timezone,\n      datasource,\n      panelId,\n      dashboardId,\n      publicDashboardAccessToken,\n      timeRange,\n      timeInfo,\n      cacheTimeout,\n      maxDataPoints,\n      scopedVars,\n      minInterval\n    } = options;\n\n    if (isSharedDashboardQuery(datasource)) {\n      this.pipeToSubject(runSharedRequest(options), panelId);\n      return;\n    }\n\n    const request = {\n      app: CoreApp.Dashboard,\n      requestId: getNextRequestId(),\n      timezone,\n      panelId,\n      dashboardId,\n      publicDashboardAccessToken,\n      range: timeRange,\n      timeInfo,\n      interval: '',\n      intervalMs: 0,\n      targets: cloneDeep(queries),\n      maxDataPoints: maxDataPoints,\n      scopedVars: scopedVars || {},\n      cacheTimeout,\n      startTime: Date.now()\n    }; // Add deprecated property\n\n    request.rangeRaw = timeRange.raw;\n\n    try {\n      var _ds$meta;\n\n      const ds = await getDataSource(datasource, request.scopedVars, publicDashboardAccessToken);\n      const isMixedDS = (_ds$meta = ds.meta) === null || _ds$meta === void 0 ? void 0 : _ds$meta.mixed; // Attach the data source to each query\n\n      request.targets = request.targets.map(query => {\n        var _query$datasource;\n\n        const isExpressionQuery = ((_query$datasource = query.datasource) === null || _query$datasource === void 0 ? void 0 : _query$datasource.type) === ExpressionDatasourceRef.type; // When using a data source variable, the panel might have the incorrect datasource\n        // stored, so when running the query make sure it is done with the correct one\n\n        if (!query.datasource || query.datasource.uid !== ds.uid && !isMixedDS && !isExpressionQuery) {\n          query.datasource = ds.getRef();\n        }\n\n        return query;\n      });\n      const lowerIntervalLimit = minInterval ? getTemplateSrv().replace(minInterval, request.scopedVars) : ds.interval;\n      const norm = rangeUtil.calculateInterval(timeRange, maxDataPoints, lowerIntervalLimit); // make shallow copy of scoped vars,\n      // and add built in variables interval and interval_ms\n\n      request.scopedVars = Object.assign({}, request.scopedVars, {\n        __interval: {\n          text: norm.interval,\n          value: norm.interval\n        },\n        __interval_ms: {\n          text: norm.intervalMs.toString(),\n          value: norm.intervalMs\n        }\n      });\n      request.interval = norm.interval;\n      request.intervalMs = norm.intervalMs;\n      this.lastRequest = request;\n      this.pipeToSubject(runRequest(ds, request), panelId);\n    } catch (err) {\n      console.error('PanelQueryRunner Error', err);\n    }\n  }\n\n  pipeToSubject(observable, panelId) {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n\n    let panelData = observable;\n    const dataSupport = this.dataConfigSource.getDataSupport();\n\n    if (dataSupport.alertStates || dataSupport.annotations) {\n      const panel = this.dataConfigSource;\n      panelData = mergePanelAndDashData(observable, getDashboardQueryRunner().getResult(panel.id));\n    }\n\n    this.subscription = panelData.subscribe({\n      next: data => {\n        this.lastResult = preProcessPanelData(data, this.lastResult); // Store preprocessed query results for applying overrides later on in the pipeline\n\n        this.subject.next(this.lastResult);\n      }\n    });\n  }\n\n  cancelQuery() {\n    if (!this.subscription) {\n      return;\n    }\n\n    this.subscription.unsubscribe(); // If we have an old result with loading state, send it with done state\n\n    if (this.lastResult && this.lastResult.state === LoadingState.Loading) {\n      this.subject.next(Object.assign({}, this.lastResult, {\n        state: LoadingState.Done\n      }));\n    }\n  }\n\n  clearLastResult() {\n    this.lastResult = undefined; // A new subject is also needed since it's a replay subject that remembers/sends last value\n\n    this.subject = new ReplaySubject(1);\n  }\n  /**\n   * Called when the panel is closed\n   */\n\n\n  destroy() {\n    // Tell anyone listening that we are done\n    if (this.subject) {\n      this.subject.complete();\n    }\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n\n  useLastResultFrom(runner) {\n    this.lastResult = runner.getLastResult();\n\n    if (this.lastResult) {\n      // The subject is a replay subject so anyone subscribing will get this last result\n      this.subject.next(this.lastResult);\n    }\n  }\n\n  getLastResult() {\n    return this.lastResult;\n  }\n\n  getLastRequest() {\n    return this.lastRequest;\n  }\n\n}\n\nasync function getDataSource(datasource, scopedVars, publicDashboardAccessToken) {\n  if (publicDashboardAccessToken) {\n    return new PublicDashboardDataSource();\n  }\n\n  if (datasource && datasource.query) {\n    return datasource;\n  }\n\n  return await getDatasourceSrv().get(datasource, scopedVars);\n}","map":{"version":3,"names":["cloneDeep","of","ReplaySubject","map","mergeMap","applyFieldOverrides","compareArrayValues","compareDataFrameStructures","CoreApp","getDefaultTimeRange","LoadingState","rangeUtil","toDataFrame","transformDataFrame","getTemplateSrv","ExpressionDatasourceRef","isStreamingDataFrame","getDatasourceSrv","isSharedDashboardQuery","runSharedRequest","PublicDashboardDataSource","getDashboardQueryRunner","mergePanelAndDashData","preProcessPanelData","runRequest","counter","getNextRequestId","PanelQueryRunner","constructor","dataConfigSource","withTransforms","inputStream","pipe","data","transformations","getTransformations","length","replace","option","request","scopedVars","forEach","transform","series","lastResult","subject","next","getData","options","withFieldConfig","structureRev","lastData","isFirstPacket","lastConfigRev","snapshotData","snapshotPanelData","state","Done","v","timeRange","getTransformationsStream","processedData","streamingPacketWithSameSchema","configRev","streamingDataFrame","find","packetInfo","schemaChanged","fields","frame","frameIndex","field","fieldIndex","values","calcs","undefined","range","fieldConfig","getFieldOverrideOptions","timeZone","timezone","run","queries","datasource","panelId","dashboardId","publicDashboardAccessToken","timeInfo","cacheTimeout","maxDataPoints","minInterval","pipeToSubject","app","Dashboard","requestId","interval","intervalMs","targets","startTime","Date","now","rangeRaw","raw","ds","getDataSource","isMixedDS","meta","mixed","query","isExpressionQuery","type","uid","getRef","lowerIntervalLimit","norm","calculateInterval","Object","assign","__interval","text","value","__interval_ms","toString","lastRequest","err","console","error","observable","subscription","unsubscribe","panelData","dataSupport","getDataSupport","alertStates","annotations","panel","getResult","id","subscribe","cancelQuery","Loading","clearLastResult","destroy","complete","useLastResultFrom","runner","getLastResult","getLastRequest","get"],"sources":["/home/soula/grafana/public/app/features/query/state/PanelQueryRunner.ts"],"sourcesContent":["import { cloneDeep } from 'lodash';\nimport { MonoTypeOperatorFunction, Observable, of, ReplaySubject, Unsubscribable } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\n\nimport {\n  applyFieldOverrides,\n  compareArrayValues,\n  compareDataFrameStructures,\n  CoreApp,\n  DataConfigSource,\n  DataFrame,\n  DataQuery,\n  DataQueryRequest,\n  DataSourceApi,\n  DataSourceJsonData,\n  DataSourceRef,\n  DataTransformerConfig,\n  getDefaultTimeRange,\n  LoadingState,\n  PanelData,\n  rangeUtil,\n  ScopedVars,\n  TimeRange,\n  TimeZone,\n  toDataFrame,\n  transformDataFrame,\n} from '@grafana/data';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport { ExpressionDatasourceRef } from '@grafana/runtime/src/utils/DataSourceWithBackend';\nimport { StreamingDataFrame } from 'app/features/live/data/StreamingDataFrame';\nimport { isStreamingDataFrame } from 'app/features/live/data/utils';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\n\nimport { isSharedDashboardQuery, runSharedRequest } from '../../../plugins/datasource/dashboard';\nimport { PublicDashboardDataSource } from '../../dashboard/services/PublicDashboardDataSource';\nimport { PanelModel } from '../../dashboard/state';\n\nimport { getDashboardQueryRunner } from './DashboardQueryRunner/DashboardQueryRunner';\nimport { mergePanelAndDashData } from './mergePanelAndDashData';\nimport { preProcessPanelData, runRequest } from './runRequest';\n\nexport interface QueryRunnerOptions<\n  TQuery extends DataQuery = DataQuery,\n  TOptions extends DataSourceJsonData = DataSourceJsonData\n> {\n  datasource: DataSourceRef | DataSourceApi<TQuery, TOptions> | null;\n  queries: TQuery[];\n  panelId?: number;\n  dashboardId?: number;\n  publicDashboardAccessToken?: string;\n  timezone: TimeZone;\n  timeRange: TimeRange;\n  timeInfo?: string; // String description of time range for display\n  maxDataPoints: number;\n  minInterval: string | undefined | null;\n  scopedVars?: ScopedVars;\n  cacheTimeout?: string | null;\n  transformations?: DataTransformerConfig[];\n}\n\nlet counter = 100;\n\nexport function getNextRequestId() {\n  return 'Q' + counter++;\n}\n\nexport interface GetDataOptions {\n  withTransforms: boolean;\n  withFieldConfig: boolean;\n}\n\nexport class PanelQueryRunner {\n  private subject: ReplaySubject<PanelData>;\n  private subscription?: Unsubscribable;\n  private lastResult?: PanelData;\n  private dataConfigSource: DataConfigSource;\n  private lastRequest?: DataQueryRequest;\n\n  constructor(dataConfigSource: DataConfigSource) {\n    this.subject = new ReplaySubject(1);\n    this.dataConfigSource = dataConfigSource;\n  }\n\n  /**\n   * Returns an observable that subscribes to the shared multi-cast subject (that reply last result).\n   */\n  getData(options: GetDataOptions): Observable<PanelData> {\n    const { withFieldConfig, withTransforms } = options;\n    let structureRev = 1;\n    let lastData: DataFrame[] = [];\n    let isFirstPacket = true;\n    let lastConfigRev = -1;\n\n    if (this.dataConfigSource.snapshotData) {\n      const snapshotPanelData: PanelData = {\n        state: LoadingState.Done,\n        series: this.dataConfigSource.snapshotData.map((v) => toDataFrame(v)),\n        timeRange: getDefaultTimeRange(), // Don't need real time range for snapshots\n      };\n      return of(snapshotPanelData);\n    }\n\n    return this.subject.pipe(\n      this.getTransformationsStream(withTransforms),\n      map((data: PanelData) => {\n        let processedData = data;\n        let streamingPacketWithSameSchema = false;\n\n        if (withFieldConfig && data.series?.length) {\n          if (lastConfigRev === this.dataConfigSource.configRev) {\n            const streamingDataFrame = data.series.find((data) => isStreamingDataFrame(data)) as\n              | StreamingDataFrame\n              | undefined;\n\n            if (\n              streamingDataFrame &&\n              !streamingDataFrame.packetInfo.schemaChanged &&\n              // TODO: remove the condition below after fixing\n              // https://github.com/grafana/grafana/pull/41492#issuecomment-970281430\n              lastData[0].fields.length === streamingDataFrame.fields.length\n            ) {\n              processedData = {\n                ...processedData,\n                series: lastData.map((frame, frameIndex) => ({\n                  ...frame,\n                  length: data.series[frameIndex].length,\n                  fields: frame.fields.map((field, fieldIndex) => ({\n                    ...field,\n                    values: data.series[frameIndex].fields[fieldIndex].values,\n                    state: {\n                      ...field.state,\n                      calcs: undefined,\n                      range: undefined,\n                    },\n                  })),\n                })),\n              };\n\n              streamingPacketWithSameSchema = true;\n            }\n          }\n\n          // Apply field defaults and overrides\n          let fieldConfig = this.dataConfigSource.getFieldOverrideOptions();\n\n          if (fieldConfig != null && (isFirstPacket || !streamingPacketWithSameSchema)) {\n            lastConfigRev = this.dataConfigSource.configRev!;\n            processedData = {\n              ...processedData,\n              series: applyFieldOverrides({\n                timeZone: data.request?.timezone ?? 'browser',\n                data: processedData.series,\n                ...fieldConfig!,\n              }),\n            };\n            isFirstPacket = false;\n          }\n        }\n\n        if (\n          !streamingPacketWithSameSchema &&\n          !compareArrayValues(lastData, processedData.series, compareDataFrameStructures)\n        ) {\n          structureRev++;\n        }\n        lastData = processedData.series;\n\n        return { ...processedData, structureRev };\n      })\n    );\n  }\n\n  private getTransformationsStream = (withTransforms: boolean): MonoTypeOperatorFunction<PanelData> => {\n    return (inputStream) =>\n      inputStream.pipe(\n        mergeMap((data) => {\n          if (!withTransforms) {\n            return of(data);\n          }\n\n          const transformations = this.dataConfigSource.getTransformations();\n\n          if (!transformations || transformations.length === 0) {\n            return of(data);\n          }\n\n          const replace = (option: string): string => {\n            return getTemplateSrv().replace(option, data?.request?.scopedVars);\n          };\n          transformations.forEach((transform: any) => {\n            transform.replace = replace;\n          });\n\n          return transformDataFrame(transformations, data.series).pipe(map((series) => ({ ...data, series })));\n        })\n      );\n  };\n\n  async run(options: QueryRunnerOptions) {\n    const {\n      queries,\n      timezone,\n      datasource,\n      panelId,\n      dashboardId,\n      publicDashboardAccessToken,\n      timeRange,\n      timeInfo,\n      cacheTimeout,\n      maxDataPoints,\n      scopedVars,\n      minInterval,\n    } = options;\n\n    if (isSharedDashboardQuery(datasource)) {\n      this.pipeToSubject(runSharedRequest(options), panelId);\n      return;\n    }\n\n    const request: DataQueryRequest = {\n      app: CoreApp.Dashboard,\n      requestId: getNextRequestId(),\n      timezone,\n      panelId,\n      dashboardId,\n      publicDashboardAccessToken,\n      range: timeRange,\n      timeInfo,\n      interval: '',\n      intervalMs: 0,\n      targets: cloneDeep(queries),\n      maxDataPoints: maxDataPoints,\n      scopedVars: scopedVars || {},\n      cacheTimeout,\n      startTime: Date.now(),\n    };\n\n    // Add deprecated property\n    (request as any).rangeRaw = timeRange.raw;\n\n    try {\n      const ds = await getDataSource(datasource, request.scopedVars, publicDashboardAccessToken);\n      const isMixedDS = ds.meta?.mixed;\n\n      // Attach the data source to each query\n      request.targets = request.targets.map((query) => {\n        const isExpressionQuery = query.datasource?.type === ExpressionDatasourceRef.type;\n        // When using a data source variable, the panel might have the incorrect datasource\n        // stored, so when running the query make sure it is done with the correct one\n        if (!query.datasource || (query.datasource.uid !== ds.uid && !isMixedDS && !isExpressionQuery)) {\n          query.datasource = ds.getRef();\n        }\n        return query;\n      });\n\n      const lowerIntervalLimit = minInterval ? getTemplateSrv().replace(minInterval, request.scopedVars) : ds.interval;\n      const norm = rangeUtil.calculateInterval(timeRange, maxDataPoints, lowerIntervalLimit);\n\n      // make shallow copy of scoped vars,\n      // and add built in variables interval and interval_ms\n      request.scopedVars = Object.assign({}, request.scopedVars, {\n        __interval: { text: norm.interval, value: norm.interval },\n        __interval_ms: { text: norm.intervalMs.toString(), value: norm.intervalMs },\n      });\n\n      request.interval = norm.interval;\n      request.intervalMs = norm.intervalMs;\n\n      this.lastRequest = request;\n\n      this.pipeToSubject(runRequest(ds, request), panelId);\n    } catch (err) {\n      console.error('PanelQueryRunner Error', err);\n    }\n  }\n\n  private pipeToSubject(observable: Observable<PanelData>, panelId?: number) {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n\n    let panelData = observable;\n    const dataSupport = this.dataConfigSource.getDataSupport();\n\n    if (dataSupport.alertStates || dataSupport.annotations) {\n      const panel = this.dataConfigSource as unknown as PanelModel;\n      panelData = mergePanelAndDashData(observable, getDashboardQueryRunner().getResult(panel.id));\n    }\n\n    this.subscription = panelData.subscribe({\n      next: (data) => {\n        this.lastResult = preProcessPanelData(data, this.lastResult);\n        // Store preprocessed query results for applying overrides later on in the pipeline\n        this.subject.next(this.lastResult);\n      },\n    });\n  }\n\n  cancelQuery() {\n    if (!this.subscription) {\n      return;\n    }\n\n    this.subscription.unsubscribe();\n\n    // If we have an old result with loading state, send it with done state\n    if (this.lastResult && this.lastResult.state === LoadingState.Loading) {\n      this.subject.next({\n        ...this.lastResult,\n        state: LoadingState.Done,\n      });\n    }\n  }\n\n  resendLastResult = () => {\n    if (this.lastResult) {\n      this.subject.next(this.lastResult);\n    }\n  };\n\n  clearLastResult() {\n    this.lastResult = undefined;\n    // A new subject is also needed since it's a replay subject that remembers/sends last value\n    this.subject = new ReplaySubject(1);\n  }\n\n  /**\n   * Called when the panel is closed\n   */\n  destroy() {\n    // Tell anyone listening that we are done\n    if (this.subject) {\n      this.subject.complete();\n    }\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n\n  useLastResultFrom(runner: PanelQueryRunner) {\n    this.lastResult = runner.getLastResult();\n\n    if (this.lastResult) {\n      // The subject is a replay subject so anyone subscribing will get this last result\n      this.subject.next(this.lastResult);\n    }\n  }\n\n  getLastResult(): PanelData | undefined {\n    return this.lastResult;\n  }\n\n  getLastRequest(): DataQueryRequest | undefined {\n    return this.lastRequest;\n  }\n}\n\nasync function getDataSource(\n  datasource: DataSourceRef | string | DataSourceApi | null,\n  scopedVars: ScopedVars,\n  publicDashboardAccessToken?: string\n): Promise<DataSourceApi> {\n  if (publicDashboardAccessToken) {\n    return new PublicDashboardDataSource();\n  }\n\n  if (datasource && (datasource as any).query) {\n    return datasource as DataSourceApi;\n  }\n\n  return await getDatasourceSrv().get(datasource as string, scopedVars);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}