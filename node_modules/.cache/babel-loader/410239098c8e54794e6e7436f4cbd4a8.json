{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { gte, lt } from 'semver';\nimport { InternalTimeZones } from '@grafana/data';\nimport { isMetricAggregationWithField, isMetricAggregationWithSettings, isMovingAverageWithModelSettings, isPipelineAggregation, isPipelineAggregationWithMultipleBucketPaths } from './components/QueryEditor/MetricAggregationsEditor/aggregations';\nimport { defaultBucketAgg, defaultMetricAgg, findMetricById, highlightTags } from './query_def';\nimport { convertOrderByToMetricId, getScriptValue } from './utils';\nexport class ElasticQueryBuilder {\n  constructor(options) {\n    _defineProperty(this, \"timeField\", void 0);\n\n    _defineProperty(this, \"esVersion\", void 0);\n\n    this.timeField = options.timeField;\n    this.esVersion = options.esVersion;\n  }\n\n  getRangeFilter() {\n    const filter = {};\n    filter[this.timeField] = {\n      gte: '$timeFrom',\n      lte: '$timeTo',\n      format: 'epoch_millis'\n    };\n    return filter;\n  }\n\n  buildTermsAgg(aggDef, queryNode, target) {\n    var _aggDef$settings;\n\n    queryNode.terms = {\n      field: aggDef.field\n    };\n\n    if (!aggDef.settings) {\n      return queryNode;\n    } // TODO: This default should be somewhere else together with the one used in the UI\n\n\n    const size = (_aggDef$settings = aggDef.settings) !== null && _aggDef$settings !== void 0 && _aggDef$settings.size ? parseInt(aggDef.settings.size, 10) : 500;\n    queryNode.terms.size = size === 0 ? 500 : size;\n\n    if (aggDef.settings.orderBy !== void 0) {\n      queryNode.terms.order = {};\n\n      if (aggDef.settings.orderBy === '_term' && gte(this.esVersion, '6.0.0')) {\n        queryNode.terms.order['_key'] = aggDef.settings.order;\n      } else {\n        queryNode.terms.order[aggDef.settings.orderBy] = aggDef.settings.order;\n      } // if metric ref, look it up and add it to this agg level\n\n\n      const metricId = convertOrderByToMetricId(aggDef.settings.orderBy);\n\n      if (metricId) {\n        for (let metric of target.metrics || []) {\n          if (metric.id === metricId) {\n            if (metric.type === 'count') {\n              queryNode.terms.order = {\n                _count: aggDef.settings.order\n              };\n            } else if (isMetricAggregationWithField(metric)) {\n              queryNode.aggs = {};\n              queryNode.aggs[metric.id] = {\n                [metric.type]: {\n                  field: metric.field\n                }\n              };\n            }\n\n            break;\n          }\n        }\n      }\n    }\n\n    if (aggDef.settings.min_doc_count !== void 0) {\n      queryNode.terms.min_doc_count = parseInt(aggDef.settings.min_doc_count, 10);\n\n      if (isNaN(queryNode.terms.min_doc_count)) {\n        queryNode.terms.min_doc_count = aggDef.settings.min_doc_count;\n      }\n    }\n\n    if (aggDef.settings.missing) {\n      queryNode.terms.missing = aggDef.settings.missing;\n    }\n\n    return queryNode;\n  }\n\n  getDateHistogramAgg(aggDef) {\n    const esAgg = {};\n    const settings = aggDef.settings || {};\n    esAgg.field = aggDef.field || this.timeField;\n    esAgg.min_doc_count = settings.min_doc_count || 0;\n    esAgg.extended_bounds = {\n      min: '$timeFrom',\n      max: '$timeTo'\n    };\n    esAgg.format = 'epoch_millis';\n\n    if (settings.timeZone && settings.timeZone !== InternalTimeZones.utc) {\n      esAgg.time_zone = settings.timeZone;\n    }\n\n    if (settings.offset !== '') {\n      esAgg.offset = settings.offset;\n    }\n\n    const interval = settings.interval === 'auto' ? '$__interval' : settings.interval;\n    esAgg.fixed_interval = interval;\n    return esAgg;\n  }\n\n  getHistogramAgg(aggDef) {\n    const esAgg = {};\n    const settings = aggDef.settings || {};\n    esAgg.interval = settings.interval;\n    esAgg.field = aggDef.field;\n    esAgg.min_doc_count = settings.min_doc_count || 0;\n    return esAgg;\n  }\n\n  getFiltersAgg(aggDef) {\n    const filterObj = {};\n\n    for (let {\n      query,\n      label\n    } of ((_aggDef$settings2 = aggDef.settings) === null || _aggDef$settings2 === void 0 ? void 0 : _aggDef$settings2.filters) || []) {\n      var _aggDef$settings2;\n\n      filterObj[label || query] = {\n        query_string: {\n          query: query,\n          analyze_wildcard: true\n        }\n      };\n    }\n\n    return filterObj;\n  }\n\n  documentQuery(query, size) {\n    query.size = size;\n    query.sort = [{\n      [this.timeField]: {\n        order: 'desc',\n        unmapped_type: 'boolean'\n      }\n    }, {\n      _doc: {\n        order: 'desc'\n      }\n    }]; // fields field not supported on ES 5.x\n\n    if (lt(this.esVersion, '5.0.0')) {\n      query.fields = ['*', '_source'];\n    }\n\n    query.script_fields = {};\n    return query;\n  }\n\n  addAdhocFilters(query, adhocFilters) {\n    if (!adhocFilters) {\n      return;\n    }\n\n    let i, filter, condition, queryCondition;\n\n    for (i = 0; i < adhocFilters.length; i++) {\n      filter = adhocFilters[i];\n      condition = {};\n      condition[filter.key] = filter.value;\n      queryCondition = {};\n      queryCondition[filter.key] = {\n        query: filter.value\n      };\n\n      switch (filter.operator) {\n        case '=':\n          if (!query.query.bool.must) {\n            query.query.bool.must = [];\n          }\n\n          query.query.bool.must.push({\n            match_phrase: queryCondition\n          });\n          break;\n\n        case '!=':\n          if (!query.query.bool.must_not) {\n            query.query.bool.must_not = [];\n          }\n\n          query.query.bool.must_not.push({\n            match_phrase: queryCondition\n          });\n          break;\n\n        case '<':\n          condition[filter.key] = {\n            lt: filter.value\n          };\n          query.query.bool.filter.push({\n            range: condition\n          });\n          break;\n\n        case '>':\n          condition[filter.key] = {\n            gt: filter.value\n          };\n          query.query.bool.filter.push({\n            range: condition\n          });\n          break;\n\n        case '=~':\n          query.query.bool.filter.push({\n            regexp: condition\n          });\n          break;\n\n        case '!~':\n          query.query.bool.filter.push({\n            bool: {\n              must_not: {\n                regexp: condition\n              }\n            }\n          });\n          break;\n      }\n    }\n  }\n\n  build(target, adhocFilters) {\n    var _target$metrics, _target$metrics$, _target$metrics2, _target$metrics2$, _metricAgg, _metricAgg2, _metric$settings2, _metric$settings2$met, _metric$settings3;\n\n    // make sure query has defaults;\n    target.metrics = target.metrics || [defaultMetricAgg()];\n    target.bucketAggs = target.bucketAggs || [defaultBucketAgg()];\n    target.timeField = this.timeField;\n    let metric;\n    let i, j, pv, nestedAggs;\n    const query = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{\n            range: this.getRangeFilter()\n          }]\n        }\n      }\n    };\n\n    if (target.query && target.query !== '') {\n      query.query.bool.filter = [...query.query.bool.filter, {\n        query_string: {\n          analyze_wildcard: true,\n          query: target.query\n        }\n      }];\n    }\n\n    this.addAdhocFilters(query, adhocFilters); // If target doesn't have bucketAggs and type is not raw_document, it is invalid query.\n\n    if (target.bucketAggs.length === 0) {\n      metric = target.metrics[0];\n\n      if (!metric || !(metric.type === 'raw_document' || metric.type === 'raw_data')) {\n        throw {\n          message: 'Invalid query'\n        };\n      }\n    }\n    /* Handle document query:\n     * Check if metric type is raw_document. If metric doesn't have size (or size is 0), update size to 500.\n     * Otherwise it will not be a valid query and error will be thrown.\n     */\n\n\n    if (((_target$metrics = target.metrics) === null || _target$metrics === void 0 ? void 0 : (_target$metrics$ = _target$metrics[0]) === null || _target$metrics$ === void 0 ? void 0 : _target$metrics$.type) === 'raw_document' || ((_target$metrics2 = target.metrics) === null || _target$metrics2 === void 0 ? void 0 : (_target$metrics2$ = _target$metrics2[0]) === null || _target$metrics2$ === void 0 ? void 0 : _target$metrics2$.type) === 'raw_data') {\n      var _metric$settings;\n\n      metric = target.metrics[0]; // TODO: This default should be somewhere else together with the one used in the UI\n\n      const size = (_metric$settings = metric.settings) !== null && _metric$settings !== void 0 && _metric$settings.size ? parseInt(metric.settings.size, 10) : 500;\n      return this.documentQuery(query, size || 500);\n    }\n\n    nestedAggs = query;\n\n    for (i = 0; i < target.bucketAggs.length; i++) {\n      const aggDef = target.bucketAggs[i];\n      const esAgg = {};\n\n      switch (aggDef.type) {\n        case 'date_histogram':\n          {\n            esAgg['date_histogram'] = this.getDateHistogramAgg(aggDef);\n            break;\n          }\n\n        case 'histogram':\n          {\n            esAgg['histogram'] = this.getHistogramAgg(aggDef);\n            break;\n          }\n\n        case 'filters':\n          {\n            esAgg['filters'] = {\n              filters: this.getFiltersAgg(aggDef)\n            };\n            break;\n          }\n\n        case 'terms':\n          {\n            this.buildTermsAgg(aggDef, esAgg, target);\n            break;\n          }\n\n        case 'geohash_grid':\n          {\n            var _aggDef$settings3;\n\n            esAgg['geohash_grid'] = {\n              field: aggDef.field,\n              precision: (_aggDef$settings3 = aggDef.settings) === null || _aggDef$settings3 === void 0 ? void 0 : _aggDef$settings3.precision\n            };\n            break;\n          }\n      }\n\n      nestedAggs.aggs = nestedAggs.aggs || {};\n      nestedAggs.aggs[aggDef.id] = esAgg;\n      nestedAggs = esAgg;\n    }\n\n    nestedAggs.aggs = {};\n\n    for (i = 0; i < target.metrics.length; i++) {\n      metric = target.metrics[i];\n\n      if (metric.type === 'count') {\n        continue;\n      }\n\n      const aggField = {};\n      let metricAgg = {};\n\n      if (isPipelineAggregation(metric)) {\n        if (isPipelineAggregationWithMultipleBucketPaths(metric)) {\n          if (metric.pipelineVariables) {\n            metricAgg = {\n              buckets_path: {}\n            };\n\n            for (j = 0; j < metric.pipelineVariables.length; j++) {\n              pv = metric.pipelineVariables[j];\n\n              if (pv.name && pv.pipelineAgg && /^\\d*$/.test(pv.pipelineAgg)) {\n                const appliedAgg = findMetricById(target.metrics, pv.pipelineAgg);\n\n                if (appliedAgg) {\n                  if (appliedAgg.type === 'count') {\n                    metricAgg.buckets_path[pv.name] = '_count';\n                  } else {\n                    metricAgg.buckets_path[pv.name] = pv.pipelineAgg;\n                  }\n                }\n              }\n            }\n          } else {\n            continue;\n          }\n        } else {\n          if (metric.field && /^\\d*$/.test(metric.field)) {\n            const appliedAgg = findMetricById(target.metrics, metric.field);\n\n            if (appliedAgg) {\n              if (appliedAgg.type === 'count') {\n                metricAgg = {\n                  buckets_path: '_count'\n                };\n              } else {\n                metricAgg = {\n                  buckets_path: metric.field\n                };\n              }\n            }\n          } else {\n            continue;\n          }\n        }\n      } else if (isMetricAggregationWithField(metric)) {\n        metricAgg = {\n          field: metric.field\n        };\n      }\n\n      if (isMetricAggregationWithSettings(metric)) {\n        Object.entries(metric.settings || {}).filter(([_, v]) => v !== null).forEach(([k, v]) => {\n          metricAgg[k] = k === 'script' ? this.buildScript(getScriptValue(metric)) : v;\n        }); // Elasticsearch isn't generally too picky about the data types in the request body,\n        // however some fields are required to be numeric.\n        // Users might have already created some of those with before, where the values were numbers.\n\n        switch (metric.type) {\n          case 'moving_avg':\n            metricAgg = Object.assign({}, metricAgg, ((_metricAgg = metricAgg) === null || _metricAgg === void 0 ? void 0 : _metricAgg.window) !== undefined && {\n              window: this.toNumber(metricAgg.window)\n            }, ((_metricAgg2 = metricAgg) === null || _metricAgg2 === void 0 ? void 0 : _metricAgg2.predict) !== undefined && {\n              predict: this.toNumber(metricAgg.predict)\n            }, isMovingAverageWithModelSettings(metric) && {\n              settings: Object.assign({}, metricAgg.settings, Object.fromEntries(Object.entries(metricAgg.settings || {}) // Only format properties that are required to be numbers\n              .filter(([settingName]) => ['alpha', 'beta', 'gamma', 'period'].includes(settingName)) // omitting undefined\n              .filter(([_, stringValue]) => stringValue !== undefined).map(([_, stringValue]) => [_, this.toNumber(stringValue)])))\n            });\n            break;\n\n          case 'serial_diff':\n            metricAgg = Object.assign({}, metricAgg, metricAgg.lag !== undefined && {\n              lag: this.toNumber(metricAgg.lag)\n            });\n            break;\n\n          case 'top_metrics':\n            metricAgg = {\n              metrics: (_metric$settings2 = metric.settings) === null || _metric$settings2 === void 0 ? void 0 : (_metric$settings2$met = _metric$settings2.metrics) === null || _metric$settings2$met === void 0 ? void 0 : _metric$settings2$met.map(field => ({\n                field\n              })),\n              size: 1\n            };\n\n            if ((_metric$settings3 = metric.settings) !== null && _metric$settings3 !== void 0 && _metric$settings3.orderBy) {\n              var _metric$settings4, _metric$settings5;\n\n              metricAgg.sort = [{\n                [(_metric$settings4 = metric.settings) === null || _metric$settings4 === void 0 ? void 0 : _metric$settings4.orderBy]: (_metric$settings5 = metric.settings) === null || _metric$settings5 === void 0 ? void 0 : _metric$settings5.order\n              }];\n            }\n\n            break;\n        }\n      }\n\n      aggField[metric.type] = metricAgg;\n      nestedAggs.aggs[metric.id] = aggField;\n    }\n\n    return query;\n  }\n\n  buildScript(script) {\n    if (gte(this.esVersion, '5.6.0')) {\n      return script;\n    }\n\n    return {\n      inline: script\n    };\n  }\n\n  toNumber(stringValue) {\n    const parsedValue = parseFloat(`${stringValue}`);\n\n    if (isNaN(parsedValue)) {\n      return stringValue;\n    }\n\n    return parsedValue;\n  }\n\n  getTermsQuery(queryDef) {\n    const query = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{\n            range: this.getRangeFilter()\n          }]\n        }\n      }\n    };\n\n    if (queryDef.query) {\n      query.query.bool.filter.push({\n        query_string: {\n          analyze_wildcard: true,\n          query: queryDef.query\n        }\n      });\n    }\n\n    let size = 500;\n\n    if (queryDef.size) {\n      size = queryDef.size;\n    }\n\n    query.aggs = {\n      '1': {\n        terms: {\n          field: queryDef.field,\n          size: size,\n          order: {}\n        }\n      }\n    }; // Default behaviour is to order results by { _key: asc }\n    // queryDef.order allows selection of asc/desc\n    // queryDef.orderBy allows selection of doc_count ordering (defaults desc)\n\n    const {\n      orderBy = 'key',\n      order = orderBy === 'doc_count' ? 'desc' : 'asc'\n    } = queryDef;\n\n    if (['asc', 'desc'].indexOf(order) < 0) {\n      throw {\n        message: `Invalid query sort order ${order}`\n      };\n    }\n\n    switch (orderBy) {\n      case 'key':\n      case 'term':\n        const keyname = gte(this.esVersion, '6.0.0') ? '_key' : '_term';\n        query.aggs['1'].terms.order[keyname] = order;\n        break;\n\n      case 'doc_count':\n        query.aggs['1'].terms.order['_count'] = order;\n        break;\n\n      default:\n        throw {\n          message: `Invalid query sort type ${orderBy}`\n        };\n    }\n\n    return query;\n  }\n\n  getLogsQuery(target, limit, adhocFilters) {\n    let query = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{\n            range: this.getRangeFilter()\n          }]\n        }\n      }\n    };\n    this.addAdhocFilters(query, adhocFilters);\n\n    if (target.query) {\n      query.query.bool.filter.push({\n        query_string: {\n          analyze_wildcard: true,\n          query: target.query\n        }\n      });\n    }\n\n    query = this.documentQuery(query, limit);\n    return Object.assign({}, query, {\n      aggs: this.build(target, null).aggs,\n      highlight: {\n        fields: {\n          '*': {}\n        },\n        pre_tags: [highlightTags.pre],\n        post_tags: [highlightTags.post],\n        fragment_size: 2147483647\n      }\n    });\n  }\n\n}","map":{"version":3,"names":["gte","lt","InternalTimeZones","isMetricAggregationWithField","isMetricAggregationWithSettings","isMovingAverageWithModelSettings","isPipelineAggregation","isPipelineAggregationWithMultipleBucketPaths","defaultBucketAgg","defaultMetricAgg","findMetricById","highlightTags","convertOrderByToMetricId","getScriptValue","ElasticQueryBuilder","constructor","options","timeField","esVersion","getRangeFilter","filter","lte","format","buildTermsAgg","aggDef","queryNode","target","terms","field","settings","size","parseInt","orderBy","order","metricId","metric","metrics","id","type","_count","aggs","min_doc_count","isNaN","missing","getDateHistogramAgg","esAgg","extended_bounds","min","max","timeZone","utc","time_zone","offset","interval","fixed_interval","getHistogramAgg","getFiltersAgg","filterObj","query","label","filters","query_string","analyze_wildcard","documentQuery","sort","unmapped_type","_doc","fields","script_fields","addAdhocFilters","adhocFilters","i","condition","queryCondition","length","key","value","operator","bool","must","push","match_phrase","must_not","range","gt","regexp","build","bucketAggs","j","pv","nestedAggs","message","precision","aggField","metricAgg","pipelineVariables","buckets_path","name","pipelineAgg","test","appliedAgg","Object","entries","_","v","forEach","k","buildScript","window","undefined","toNumber","predict","fromEntries","settingName","includes","stringValue","map","lag","script","inline","parsedValue","parseFloat","getTermsQuery","queryDef","indexOf","keyname","getLogsQuery","limit","highlight","pre_tags","pre","post_tags","post","fragment_size"],"sources":["/home/soula/grafana/public/app/plugins/datasource/elasticsearch/query_builder.ts"],"sourcesContent":["import { gte, lt } from 'semver';\n\nimport { InternalTimeZones } from '@grafana/data';\n\nimport {\n  Filters,\n  Histogram,\n  DateHistogram,\n  Terms,\n} from './components/QueryEditor/BucketAggregationsEditor/aggregations';\nimport {\n  isMetricAggregationWithField,\n  isMetricAggregationWithSettings,\n  isMovingAverageWithModelSettings,\n  isPipelineAggregation,\n  isPipelineAggregationWithMultipleBucketPaths,\n  MetricAggregation,\n  MetricAggregationWithInlineScript,\n} from './components/QueryEditor/MetricAggregationsEditor/aggregations';\nimport { defaultBucketAgg, defaultMetricAgg, findMetricById, highlightTags } from './query_def';\nimport { ElasticsearchQuery, TermsQuery } from './types';\nimport { convertOrderByToMetricId, getScriptValue } from './utils';\n\nexport class ElasticQueryBuilder {\n  timeField: string;\n  esVersion: string;\n\n  constructor(options: { timeField: string; esVersion: string }) {\n    this.timeField = options.timeField;\n    this.esVersion = options.esVersion;\n  }\n\n  getRangeFilter() {\n    const filter: any = {};\n    filter[this.timeField] = {\n      gte: '$timeFrom',\n      lte: '$timeTo',\n      format: 'epoch_millis',\n    };\n\n    return filter;\n  }\n\n  buildTermsAgg(aggDef: Terms, queryNode: { terms?: any; aggs?: any }, target: ElasticsearchQuery) {\n    queryNode.terms = { field: aggDef.field };\n\n    if (!aggDef.settings) {\n      return queryNode;\n    }\n\n    // TODO: This default should be somewhere else together with the one used in the UI\n    const size = aggDef.settings?.size ? parseInt(aggDef.settings.size, 10) : 500;\n    queryNode.terms.size = size === 0 ? 500 : size;\n\n    if (aggDef.settings.orderBy !== void 0) {\n      queryNode.terms.order = {};\n      if (aggDef.settings.orderBy === '_term' && gte(this.esVersion, '6.0.0')) {\n        queryNode.terms.order['_key'] = aggDef.settings.order;\n      } else {\n        queryNode.terms.order[aggDef.settings.orderBy] = aggDef.settings.order;\n      }\n\n      // if metric ref, look it up and add it to this agg level\n      const metricId = convertOrderByToMetricId(aggDef.settings.orderBy);\n      if (metricId) {\n        for (let metric of target.metrics || []) {\n          if (metric.id === metricId) {\n            if (metric.type === 'count') {\n              queryNode.terms.order = { _count: aggDef.settings.order };\n            } else if (isMetricAggregationWithField(metric)) {\n              queryNode.aggs = {};\n              queryNode.aggs[metric.id] = {\n                [metric.type]: { field: metric.field },\n              };\n            }\n            break;\n          }\n        }\n      }\n    }\n\n    if (aggDef.settings.min_doc_count !== void 0) {\n      queryNode.terms.min_doc_count = parseInt(aggDef.settings.min_doc_count, 10);\n\n      if (isNaN(queryNode.terms.min_doc_count)) {\n        queryNode.terms.min_doc_count = aggDef.settings.min_doc_count;\n      }\n    }\n\n    if (aggDef.settings.missing) {\n      queryNode.terms.missing = aggDef.settings.missing;\n    }\n\n    return queryNode;\n  }\n\n  getDateHistogramAgg(aggDef: DateHistogram) {\n    const esAgg: any = {};\n    const settings = aggDef.settings || {};\n\n    esAgg.field = aggDef.field || this.timeField;\n    esAgg.min_doc_count = settings.min_doc_count || 0;\n    esAgg.extended_bounds = { min: '$timeFrom', max: '$timeTo' };\n    esAgg.format = 'epoch_millis';\n    if (settings.timeZone && settings.timeZone !== InternalTimeZones.utc) {\n      esAgg.time_zone = settings.timeZone;\n    }\n\n    if (settings.offset !== '') {\n      esAgg.offset = settings.offset;\n    }\n\n    const interval = settings.interval === 'auto' ? '$__interval' : settings.interval;\n\n    esAgg.fixed_interval = interval;\n\n    return esAgg;\n  }\n\n  getHistogramAgg(aggDef: Histogram) {\n    const esAgg: any = {};\n    const settings = aggDef.settings || {};\n    esAgg.interval = settings.interval;\n    esAgg.field = aggDef.field;\n    esAgg.min_doc_count = settings.min_doc_count || 0;\n\n    return esAgg;\n  }\n\n  getFiltersAgg(aggDef: Filters) {\n    const filterObj: Record<string, { query_string: { query: string; analyze_wildcard: boolean } }> = {};\n\n    for (let { query, label } of aggDef.settings?.filters || []) {\n      filterObj[label || query] = {\n        query_string: {\n          query: query,\n          analyze_wildcard: true,\n        },\n      };\n    }\n\n    return filterObj;\n  }\n\n  documentQuery(query: any, size: number) {\n    query.size = size;\n    query.sort = [\n      {\n        [this.timeField]: { order: 'desc', unmapped_type: 'boolean' },\n      },\n      {\n        _doc: { order: 'desc' },\n      },\n    ];\n\n    // fields field not supported on ES 5.x\n    if (lt(this.esVersion, '5.0.0')) {\n      query.fields = ['*', '_source'];\n    }\n\n    query.script_fields = {};\n    return query;\n  }\n\n  addAdhocFilters(query: any, adhocFilters: any) {\n    if (!adhocFilters) {\n      return;\n    }\n\n    let i, filter, condition: any, queryCondition: any;\n\n    for (i = 0; i < adhocFilters.length; i++) {\n      filter = adhocFilters[i];\n      condition = {};\n      condition[filter.key] = filter.value;\n      queryCondition = {};\n      queryCondition[filter.key] = { query: filter.value };\n\n      switch (filter.operator) {\n        case '=':\n          if (!query.query.bool.must) {\n            query.query.bool.must = [];\n          }\n          query.query.bool.must.push({ match_phrase: queryCondition });\n          break;\n        case '!=':\n          if (!query.query.bool.must_not) {\n            query.query.bool.must_not = [];\n          }\n          query.query.bool.must_not.push({ match_phrase: queryCondition });\n          break;\n        case '<':\n          condition[filter.key] = { lt: filter.value };\n          query.query.bool.filter.push({ range: condition });\n          break;\n        case '>':\n          condition[filter.key] = { gt: filter.value };\n          query.query.bool.filter.push({ range: condition });\n          break;\n        case '=~':\n          query.query.bool.filter.push({ regexp: condition });\n          break;\n        case '!~':\n          query.query.bool.filter.push({\n            bool: { must_not: { regexp: condition } },\n          });\n          break;\n      }\n    }\n  }\n\n  build(target: ElasticsearchQuery, adhocFilters?: any) {\n    // make sure query has defaults;\n    target.metrics = target.metrics || [defaultMetricAgg()];\n    target.bucketAggs = target.bucketAggs || [defaultBucketAgg()];\n    target.timeField = this.timeField;\n    let metric: MetricAggregation;\n\n    let i, j, pv, nestedAggs;\n    const query: any = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{ range: this.getRangeFilter() }],\n        },\n      },\n    };\n\n    if (target.query && target.query !== '') {\n      query.query.bool.filter = [\n        ...query.query.bool.filter,\n        {\n          query_string: {\n            analyze_wildcard: true,\n            query: target.query,\n          },\n        },\n      ];\n    }\n\n    this.addAdhocFilters(query, adhocFilters);\n\n    // If target doesn't have bucketAggs and type is not raw_document, it is invalid query.\n    if (target.bucketAggs.length === 0) {\n      metric = target.metrics[0];\n\n      if (!metric || !(metric.type === 'raw_document' || metric.type === 'raw_data')) {\n        throw { message: 'Invalid query' };\n      }\n    }\n\n    /* Handle document query:\n     * Check if metric type is raw_document. If metric doesn't have size (or size is 0), update size to 500.\n     * Otherwise it will not be a valid query and error will be thrown.\n     */\n    if (target.metrics?.[0]?.type === 'raw_document' || target.metrics?.[0]?.type === 'raw_data') {\n      metric = target.metrics[0];\n\n      // TODO: This default should be somewhere else together with the one used in the UI\n      const size = metric.settings?.size ? parseInt(metric.settings.size, 10) : 500;\n\n      return this.documentQuery(query, size || 500);\n    }\n\n    nestedAggs = query;\n\n    for (i = 0; i < target.bucketAggs.length; i++) {\n      const aggDef = target.bucketAggs[i];\n      const esAgg: any = {};\n\n      switch (aggDef.type) {\n        case 'date_histogram': {\n          esAgg['date_histogram'] = this.getDateHistogramAgg(aggDef);\n          break;\n        }\n        case 'histogram': {\n          esAgg['histogram'] = this.getHistogramAgg(aggDef);\n          break;\n        }\n        case 'filters': {\n          esAgg['filters'] = { filters: this.getFiltersAgg(aggDef) };\n          break;\n        }\n        case 'terms': {\n          this.buildTermsAgg(aggDef, esAgg, target);\n          break;\n        }\n        case 'geohash_grid': {\n          esAgg['geohash_grid'] = {\n            field: aggDef.field,\n            precision: aggDef.settings?.precision,\n          };\n          break;\n        }\n      }\n\n      nestedAggs.aggs = nestedAggs.aggs || {};\n      nestedAggs.aggs[aggDef.id] = esAgg;\n      nestedAggs = esAgg;\n    }\n\n    nestedAggs.aggs = {};\n\n    for (i = 0; i < target.metrics.length; i++) {\n      metric = target.metrics[i];\n      if (metric.type === 'count') {\n        continue;\n      }\n\n      const aggField: any = {};\n      let metricAgg: any = {};\n\n      if (isPipelineAggregation(metric)) {\n        if (isPipelineAggregationWithMultipleBucketPaths(metric)) {\n          if (metric.pipelineVariables) {\n            metricAgg = {\n              buckets_path: {},\n            };\n\n            for (j = 0; j < metric.pipelineVariables.length; j++) {\n              pv = metric.pipelineVariables[j];\n\n              if (pv.name && pv.pipelineAgg && /^\\d*$/.test(pv.pipelineAgg)) {\n                const appliedAgg = findMetricById(target.metrics, pv.pipelineAgg);\n                if (appliedAgg) {\n                  if (appliedAgg.type === 'count') {\n                    metricAgg.buckets_path[pv.name] = '_count';\n                  } else {\n                    metricAgg.buckets_path[pv.name] = pv.pipelineAgg;\n                  }\n                }\n              }\n            }\n          } else {\n            continue;\n          }\n        } else {\n          if (metric.field && /^\\d*$/.test(metric.field)) {\n            const appliedAgg = findMetricById(target.metrics, metric.field);\n            if (appliedAgg) {\n              if (appliedAgg.type === 'count') {\n                metricAgg = { buckets_path: '_count' };\n              } else {\n                metricAgg = { buckets_path: metric.field };\n              }\n            }\n          } else {\n            continue;\n          }\n        }\n      } else if (isMetricAggregationWithField(metric)) {\n        metricAgg = { field: metric.field };\n      }\n\n      if (isMetricAggregationWithSettings(metric)) {\n        Object.entries(metric.settings || {})\n          .filter(([_, v]) => v !== null)\n          .forEach(([k, v]) => {\n            metricAgg[k] =\n              k === 'script' ? this.buildScript(getScriptValue(metric as MetricAggregationWithInlineScript)) : v;\n          });\n\n        // Elasticsearch isn't generally too picky about the data types in the request body,\n        // however some fields are required to be numeric.\n        // Users might have already created some of those with before, where the values were numbers.\n        switch (metric.type) {\n          case 'moving_avg':\n            metricAgg = {\n              ...metricAgg,\n              ...(metricAgg?.window !== undefined && { window: this.toNumber(metricAgg.window) }),\n              ...(metricAgg?.predict !== undefined && { predict: this.toNumber(metricAgg.predict) }),\n              ...(isMovingAverageWithModelSettings(metric) && {\n                settings: {\n                  ...metricAgg.settings,\n                  ...Object.fromEntries(\n                    Object.entries(metricAgg.settings || {})\n                      // Only format properties that are required to be numbers\n                      .filter(([settingName]) => ['alpha', 'beta', 'gamma', 'period'].includes(settingName))\n                      // omitting undefined\n                      .filter(([_, stringValue]) => stringValue !== undefined)\n                      .map(([_, stringValue]) => [_, this.toNumber(stringValue)])\n                  ),\n                },\n              }),\n            };\n            break;\n\n          case 'serial_diff':\n            metricAgg = {\n              ...metricAgg,\n              ...(metricAgg.lag !== undefined && {\n                lag: this.toNumber(metricAgg.lag),\n              }),\n            };\n            break;\n\n          case 'top_metrics':\n            metricAgg = {\n              metrics: metric.settings?.metrics?.map((field) => ({ field })),\n              size: 1,\n            };\n\n            if (metric.settings?.orderBy) {\n              metricAgg.sort = [{ [metric.settings?.orderBy]: metric.settings?.order }];\n            }\n            break;\n        }\n      }\n\n      aggField[metric.type] = metricAgg;\n      nestedAggs.aggs[metric.id] = aggField;\n    }\n\n    return query;\n  }\n\n  private buildScript(script: string) {\n    if (gte(this.esVersion, '5.6.0')) {\n      return script;\n    }\n\n    return {\n      inline: script,\n    };\n  }\n\n  private toNumber(stringValue: unknown): unknown | number {\n    const parsedValue = parseFloat(`${stringValue}`);\n    if (isNaN(parsedValue)) {\n      return stringValue;\n    }\n\n    return parsedValue;\n  }\n\n  getTermsQuery(queryDef: TermsQuery) {\n    const query: any = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{ range: this.getRangeFilter() }],\n        },\n      },\n    };\n\n    if (queryDef.query) {\n      query.query.bool.filter.push({\n        query_string: {\n          analyze_wildcard: true,\n          query: queryDef.query,\n        },\n      });\n    }\n\n    let size = 500;\n    if (queryDef.size) {\n      size = queryDef.size;\n    }\n\n    query.aggs = {\n      '1': {\n        terms: {\n          field: queryDef.field,\n          size: size,\n          order: {},\n        },\n      },\n    };\n\n    // Default behaviour is to order results by { _key: asc }\n    // queryDef.order allows selection of asc/desc\n    // queryDef.orderBy allows selection of doc_count ordering (defaults desc)\n\n    const { orderBy = 'key', order = orderBy === 'doc_count' ? 'desc' : 'asc' } = queryDef;\n\n    if (['asc', 'desc'].indexOf(order) < 0) {\n      throw { message: `Invalid query sort order ${order}` };\n    }\n\n    switch (orderBy) {\n      case 'key':\n      case 'term':\n        const keyname = gte(this.esVersion, '6.0.0') ? '_key' : '_term';\n        query.aggs['1'].terms.order[keyname] = order;\n        break;\n      case 'doc_count':\n        query.aggs['1'].terms.order['_count'] = order;\n        break;\n      default:\n        throw { message: `Invalid query sort type ${orderBy}` };\n    }\n\n    return query;\n  }\n\n  getLogsQuery(target: ElasticsearchQuery, limit: number, adhocFilters?: any) {\n    let query: any = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{ range: this.getRangeFilter() }],\n        },\n      },\n    };\n\n    this.addAdhocFilters(query, adhocFilters);\n\n    if (target.query) {\n      query.query.bool.filter.push({\n        query_string: {\n          analyze_wildcard: true,\n          query: target.query,\n        },\n      });\n    }\n\n    query = this.documentQuery(query, limit);\n\n    return {\n      ...query,\n      aggs: this.build(target, null).aggs,\n      highlight: {\n        fields: {\n          '*': {},\n        },\n        pre_tags: [highlightTags.pre],\n        post_tags: [highlightTags.post],\n        fragment_size: 2147483647,\n      },\n    };\n  }\n}\n"],"mappings":";;AAAA,SAASA,GAAT,EAAcC,EAAd,QAAwB,QAAxB;AAEA,SAASC,iBAAT,QAAkC,eAAlC;AAQA,SACEC,4BADF,EAEEC,+BAFF,EAGEC,gCAHF,EAIEC,qBAJF,EAKEC,4CALF,QAQO,gEARP;AASA,SAASC,gBAAT,EAA2BC,gBAA3B,EAA6CC,cAA7C,EAA6DC,aAA7D,QAAkF,aAAlF;AAEA,SAASC,wBAAT,EAAmCC,cAAnC,QAAyD,SAAzD;AAEA,OAAO,MAAMC,mBAAN,CAA0B;EAI/BC,WAAW,CAACC,OAAD,EAAoD;IAAA;;IAAA;;IAC7D,KAAKC,SAAL,GAAiBD,OAAO,CAACC,SAAzB;IACA,KAAKC,SAAL,GAAiBF,OAAO,CAACE,SAAzB;EACD;;EAEDC,cAAc,GAAG;IACf,MAAMC,MAAW,GAAG,EAApB;IACAA,MAAM,CAAC,KAAKH,SAAN,CAAN,GAAyB;MACvBjB,GAAG,EAAE,WADkB;MAEvBqB,GAAG,EAAE,SAFkB;MAGvBC,MAAM,EAAE;IAHe,CAAzB;IAMA,OAAOF,MAAP;EACD;;EAEDG,aAAa,CAACC,MAAD,EAAgBC,SAAhB,EAAwDC,MAAxD,EAAoF;IAAA;;IAC/FD,SAAS,CAACE,KAAV,GAAkB;MAAEC,KAAK,EAAEJ,MAAM,CAACI;IAAhB,CAAlB;;IAEA,IAAI,CAACJ,MAAM,CAACK,QAAZ,EAAsB;MACpB,OAAOJ,SAAP;IACD,CAL8F,CAO/F;;;IACA,MAAMK,IAAI,GAAG,oBAAAN,MAAM,CAACK,QAAP,8DAAiBC,IAAjB,GAAwBC,QAAQ,CAACP,MAAM,CAACK,QAAP,CAAgBC,IAAjB,EAAuB,EAAvB,CAAhC,GAA6D,GAA1E;IACAL,SAAS,CAACE,KAAV,CAAgBG,IAAhB,GAAuBA,IAAI,KAAK,CAAT,GAAa,GAAb,GAAmBA,IAA1C;;IAEA,IAAIN,MAAM,CAACK,QAAP,CAAgBG,OAAhB,KAA4B,KAAK,CAArC,EAAwC;MACtCP,SAAS,CAACE,KAAV,CAAgBM,KAAhB,GAAwB,EAAxB;;MACA,IAAIT,MAAM,CAACK,QAAP,CAAgBG,OAAhB,KAA4B,OAA5B,IAAuChC,GAAG,CAAC,KAAKkB,SAAN,EAAiB,OAAjB,CAA9C,EAAyE;QACvEO,SAAS,CAACE,KAAV,CAAgBM,KAAhB,CAAsB,MAAtB,IAAgCT,MAAM,CAACK,QAAP,CAAgBI,KAAhD;MACD,CAFD,MAEO;QACLR,SAAS,CAACE,KAAV,CAAgBM,KAAhB,CAAsBT,MAAM,CAACK,QAAP,CAAgBG,OAAtC,IAAiDR,MAAM,CAACK,QAAP,CAAgBI,KAAjE;MACD,CANqC,CAQtC;;;MACA,MAAMC,QAAQ,GAAGtB,wBAAwB,CAACY,MAAM,CAACK,QAAP,CAAgBG,OAAjB,CAAzC;;MACA,IAAIE,QAAJ,EAAc;QACZ,KAAK,IAAIC,MAAT,IAAmBT,MAAM,CAACU,OAAP,IAAkB,EAArC,EAAyC;UACvC,IAAID,MAAM,CAACE,EAAP,KAAcH,QAAlB,EAA4B;YAC1B,IAAIC,MAAM,CAACG,IAAP,KAAgB,OAApB,EAA6B;cAC3Bb,SAAS,CAACE,KAAV,CAAgBM,KAAhB,GAAwB;gBAAEM,MAAM,EAAEf,MAAM,CAACK,QAAP,CAAgBI;cAA1B,CAAxB;YACD,CAFD,MAEO,IAAI9B,4BAA4B,CAACgC,MAAD,CAAhC,EAA0C;cAC/CV,SAAS,CAACe,IAAV,GAAiB,EAAjB;cACAf,SAAS,CAACe,IAAV,CAAeL,MAAM,CAACE,EAAtB,IAA4B;gBAC1B,CAACF,MAAM,CAACG,IAAR,GAAe;kBAAEV,KAAK,EAAEO,MAAM,CAACP;gBAAhB;cADW,CAA5B;YAGD;;YACD;UACD;QACF;MACF;IACF;;IAED,IAAIJ,MAAM,CAACK,QAAP,CAAgBY,aAAhB,KAAkC,KAAK,CAA3C,EAA8C;MAC5ChB,SAAS,CAACE,KAAV,CAAgBc,aAAhB,GAAgCV,QAAQ,CAACP,MAAM,CAACK,QAAP,CAAgBY,aAAjB,EAAgC,EAAhC,CAAxC;;MAEA,IAAIC,KAAK,CAACjB,SAAS,CAACE,KAAV,CAAgBc,aAAjB,CAAT,EAA0C;QACxChB,SAAS,CAACE,KAAV,CAAgBc,aAAhB,GAAgCjB,MAAM,CAACK,QAAP,CAAgBY,aAAhD;MACD;IACF;;IAED,IAAIjB,MAAM,CAACK,QAAP,CAAgBc,OAApB,EAA6B;MAC3BlB,SAAS,CAACE,KAAV,CAAgBgB,OAAhB,GAA0BnB,MAAM,CAACK,QAAP,CAAgBc,OAA1C;IACD;;IAED,OAAOlB,SAAP;EACD;;EAEDmB,mBAAmB,CAACpB,MAAD,EAAwB;IACzC,MAAMqB,KAAU,GAAG,EAAnB;IACA,MAAMhB,QAAQ,GAAGL,MAAM,CAACK,QAAP,IAAmB,EAApC;IAEAgB,KAAK,CAACjB,KAAN,GAAcJ,MAAM,CAACI,KAAP,IAAgB,KAAKX,SAAnC;IACA4B,KAAK,CAACJ,aAAN,GAAsBZ,QAAQ,CAACY,aAAT,IAA0B,CAAhD;IACAI,KAAK,CAACC,eAAN,GAAwB;MAAEC,GAAG,EAAE,WAAP;MAAoBC,GAAG,EAAE;IAAzB,CAAxB;IACAH,KAAK,CAACvB,MAAN,GAAe,cAAf;;IACA,IAAIO,QAAQ,CAACoB,QAAT,IAAqBpB,QAAQ,CAACoB,QAAT,KAAsB/C,iBAAiB,CAACgD,GAAjE,EAAsE;MACpEL,KAAK,CAACM,SAAN,GAAkBtB,QAAQ,CAACoB,QAA3B;IACD;;IAED,IAAIpB,QAAQ,CAACuB,MAAT,KAAoB,EAAxB,EAA4B;MAC1BP,KAAK,CAACO,MAAN,GAAevB,QAAQ,CAACuB,MAAxB;IACD;;IAED,MAAMC,QAAQ,GAAGxB,QAAQ,CAACwB,QAAT,KAAsB,MAAtB,GAA+B,aAA/B,GAA+CxB,QAAQ,CAACwB,QAAzE;IAEAR,KAAK,CAACS,cAAN,GAAuBD,QAAvB;IAEA,OAAOR,KAAP;EACD;;EAEDU,eAAe,CAAC/B,MAAD,EAAoB;IACjC,MAAMqB,KAAU,GAAG,EAAnB;IACA,MAAMhB,QAAQ,GAAGL,MAAM,CAACK,QAAP,IAAmB,EAApC;IACAgB,KAAK,CAACQ,QAAN,GAAiBxB,QAAQ,CAACwB,QAA1B;IACAR,KAAK,CAACjB,KAAN,GAAcJ,MAAM,CAACI,KAArB;IACAiB,KAAK,CAACJ,aAAN,GAAsBZ,QAAQ,CAACY,aAAT,IAA0B,CAAhD;IAEA,OAAOI,KAAP;EACD;;EAEDW,aAAa,CAAChC,MAAD,EAAkB;IAC7B,MAAMiC,SAAyF,GAAG,EAAlG;;IAEA,KAAK,IAAI;MAAEC,KAAF;MAASC;IAAT,CAAT,IAA6B,sBAAAnC,MAAM,CAACK,QAAP,wEAAiB+B,OAAjB,KAA4B,EAAzD,EAA6D;MAAA;;MAC3DH,SAAS,CAACE,KAAK,IAAID,KAAV,CAAT,GAA4B;QAC1BG,YAAY,EAAE;UACZH,KAAK,EAAEA,KADK;UAEZI,gBAAgB,EAAE;QAFN;MADY,CAA5B;IAMD;;IAED,OAAOL,SAAP;EACD;;EAEDM,aAAa,CAACL,KAAD,EAAa5B,IAAb,EAA2B;IACtC4B,KAAK,CAAC5B,IAAN,GAAaA,IAAb;IACA4B,KAAK,CAACM,IAAN,GAAa,CACX;MACE,CAAC,KAAK/C,SAAN,GAAkB;QAAEgB,KAAK,EAAE,MAAT;QAAiBgC,aAAa,EAAE;MAAhC;IADpB,CADW,EAIX;MACEC,IAAI,EAAE;QAAEjC,KAAK,EAAE;MAAT;IADR,CAJW,CAAb,CAFsC,CAWtC;;IACA,IAAIhC,EAAE,CAAC,KAAKiB,SAAN,EAAiB,OAAjB,CAAN,EAAiC;MAC/BwC,KAAK,CAACS,MAAN,GAAe,CAAC,GAAD,EAAM,SAAN,CAAf;IACD;;IAEDT,KAAK,CAACU,aAAN,GAAsB,EAAtB;IACA,OAAOV,KAAP;EACD;;EAEDW,eAAe,CAACX,KAAD,EAAaY,YAAb,EAAgC;IAC7C,IAAI,CAACA,YAAL,EAAmB;MACjB;IACD;;IAED,IAAIC,CAAJ,EAAOnD,MAAP,EAAeoD,SAAf,EAA+BC,cAA/B;;IAEA,KAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,YAAY,CAACI,MAA7B,EAAqCH,CAAC,EAAtC,EAA0C;MACxCnD,MAAM,GAAGkD,YAAY,CAACC,CAAD,CAArB;MACAC,SAAS,GAAG,EAAZ;MACAA,SAAS,CAACpD,MAAM,CAACuD,GAAR,CAAT,GAAwBvD,MAAM,CAACwD,KAA/B;MACAH,cAAc,GAAG,EAAjB;MACAA,cAAc,CAACrD,MAAM,CAACuD,GAAR,CAAd,GAA6B;QAAEjB,KAAK,EAAEtC,MAAM,CAACwD;MAAhB,CAA7B;;MAEA,QAAQxD,MAAM,CAACyD,QAAf;QACE,KAAK,GAAL;UACE,IAAI,CAACnB,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiBC,IAAtB,EAA4B;YAC1BrB,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiBC,IAAjB,GAAwB,EAAxB;UACD;;UACDrB,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiBC,IAAjB,CAAsBC,IAAtB,CAA2B;YAAEC,YAAY,EAAER;UAAhB,CAA3B;UACA;;QACF,KAAK,IAAL;UACE,IAAI,CAACf,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiBI,QAAtB,EAAgC;YAC9BxB,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiBI,QAAjB,GAA4B,EAA5B;UACD;;UACDxB,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiBI,QAAjB,CAA0BF,IAA1B,CAA+B;YAAEC,YAAY,EAAER;UAAhB,CAA/B;UACA;;QACF,KAAK,GAAL;UACED,SAAS,CAACpD,MAAM,CAACuD,GAAR,CAAT,GAAwB;YAAE1E,EAAE,EAAEmB,MAAM,CAACwD;UAAb,CAAxB;UACAlB,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiB1D,MAAjB,CAAwB4D,IAAxB,CAA6B;YAAEG,KAAK,EAAEX;UAAT,CAA7B;UACA;;QACF,KAAK,GAAL;UACEA,SAAS,CAACpD,MAAM,CAACuD,GAAR,CAAT,GAAwB;YAAES,EAAE,EAAEhE,MAAM,CAACwD;UAAb,CAAxB;UACAlB,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiB1D,MAAjB,CAAwB4D,IAAxB,CAA6B;YAAEG,KAAK,EAAEX;UAAT,CAA7B;UACA;;QACF,KAAK,IAAL;UACEd,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiB1D,MAAjB,CAAwB4D,IAAxB,CAA6B;YAAEK,MAAM,EAAEb;UAAV,CAA7B;UACA;;QACF,KAAK,IAAL;UACEd,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiB1D,MAAjB,CAAwB4D,IAAxB,CAA6B;YAC3BF,IAAI,EAAE;cAAEI,QAAQ,EAAE;gBAAEG,MAAM,EAAEb;cAAV;YAAZ;UADqB,CAA7B;UAGA;MA5BJ;IA8BD;EACF;;EAEDc,KAAK,CAAC5D,MAAD,EAA6B4C,YAA7B,EAAiD;IAAA;;IACpD;IACA5C,MAAM,CAACU,OAAP,GAAiBV,MAAM,CAACU,OAAP,IAAkB,CAAC3B,gBAAgB,EAAjB,CAAnC;IACAiB,MAAM,CAAC6D,UAAP,GAAoB7D,MAAM,CAAC6D,UAAP,IAAqB,CAAC/E,gBAAgB,EAAjB,CAAzC;IACAkB,MAAM,CAACT,SAAP,GAAmB,KAAKA,SAAxB;IACA,IAAIkB,MAAJ;IAEA,IAAIoC,CAAJ,EAAOiB,CAAP,EAAUC,EAAV,EAAcC,UAAd;IACA,MAAMhC,KAAU,GAAG;MACjB5B,IAAI,EAAE,CADW;MAEjB4B,KAAK,EAAE;QACLoB,IAAI,EAAE;UACJ1D,MAAM,EAAE,CAAC;YAAE+D,KAAK,EAAE,KAAKhE,cAAL;UAAT,CAAD;QADJ;MADD;IAFU,CAAnB;;IASA,IAAIO,MAAM,CAACgC,KAAP,IAAgBhC,MAAM,CAACgC,KAAP,KAAiB,EAArC,EAAyC;MACvCA,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiB1D,MAAjB,GAA0B,CACxB,GAAGsC,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiB1D,MADI,EAExB;QACEyC,YAAY,EAAE;UACZC,gBAAgB,EAAE,IADN;UAEZJ,KAAK,EAAEhC,MAAM,CAACgC;QAFF;MADhB,CAFwB,CAA1B;IASD;;IAED,KAAKW,eAAL,CAAqBX,KAArB,EAA4BY,YAA5B,EA7BoD,CA+BpD;;IACA,IAAI5C,MAAM,CAAC6D,UAAP,CAAkBb,MAAlB,KAA6B,CAAjC,EAAoC;MAClCvC,MAAM,GAAGT,MAAM,CAACU,OAAP,CAAe,CAAf,CAAT;;MAEA,IAAI,CAACD,MAAD,IAAW,EAAEA,MAAM,CAACG,IAAP,KAAgB,cAAhB,IAAkCH,MAAM,CAACG,IAAP,KAAgB,UAApD,CAAf,EAAgF;QAC9E,MAAM;UAAEqD,OAAO,EAAE;QAAX,CAAN;MACD;IACF;IAED;AACJ;AACA;AACA;;;IACI,IAAI,oBAAAjE,MAAM,CAACU,OAAP,wFAAiB,CAAjB,uEAAqBE,IAArB,MAA8B,cAA9B,IAAgD,qBAAAZ,MAAM,CAACU,OAAP,2FAAiB,CAAjB,yEAAqBE,IAArB,MAA8B,UAAlF,EAA8F;MAAA;;MAC5FH,MAAM,GAAGT,MAAM,CAACU,OAAP,CAAe,CAAf,CAAT,CAD4F,CAG5F;;MACA,MAAMN,IAAI,GAAG,oBAAAK,MAAM,CAACN,QAAP,8DAAiBC,IAAjB,GAAwBC,QAAQ,CAACI,MAAM,CAACN,QAAP,CAAgBC,IAAjB,EAAuB,EAAvB,CAAhC,GAA6D,GAA1E;MAEA,OAAO,KAAKiC,aAAL,CAAmBL,KAAnB,EAA0B5B,IAAI,IAAI,GAAlC,CAAP;IACD;;IAED4D,UAAU,GAAGhC,KAAb;;IAEA,KAAKa,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG7C,MAAM,CAAC6D,UAAP,CAAkBb,MAAlC,EAA0CH,CAAC,EAA3C,EAA+C;MAC7C,MAAM/C,MAAM,GAAGE,MAAM,CAAC6D,UAAP,CAAkBhB,CAAlB,CAAf;MACA,MAAM1B,KAAU,GAAG,EAAnB;;MAEA,QAAQrB,MAAM,CAACc,IAAf;QACE,KAAK,gBAAL;UAAuB;YACrBO,KAAK,CAAC,gBAAD,CAAL,GAA0B,KAAKD,mBAAL,CAAyBpB,MAAzB,CAA1B;YACA;UACD;;QACD,KAAK,WAAL;UAAkB;YAChBqB,KAAK,CAAC,WAAD,CAAL,GAAqB,KAAKU,eAAL,CAAqB/B,MAArB,CAArB;YACA;UACD;;QACD,KAAK,SAAL;UAAgB;YACdqB,KAAK,CAAC,SAAD,CAAL,GAAmB;cAAEe,OAAO,EAAE,KAAKJ,aAAL,CAAmBhC,MAAnB;YAAX,CAAnB;YACA;UACD;;QACD,KAAK,OAAL;UAAc;YACZ,KAAKD,aAAL,CAAmBC,MAAnB,EAA2BqB,KAA3B,EAAkCnB,MAAlC;YACA;UACD;;QACD,KAAK,cAAL;UAAqB;YAAA;;YACnBmB,KAAK,CAAC,cAAD,CAAL,GAAwB;cACtBjB,KAAK,EAAEJ,MAAM,CAACI,KADQ;cAEtBgE,SAAS,uBAAEpE,MAAM,CAACK,QAAT,sDAAE,kBAAiB+D;YAFN,CAAxB;YAIA;UACD;MAvBH;;MA0BAF,UAAU,CAAClD,IAAX,GAAkBkD,UAAU,CAAClD,IAAX,IAAmB,EAArC;MACAkD,UAAU,CAAClD,IAAX,CAAgBhB,MAAM,CAACa,EAAvB,IAA6BQ,KAA7B;MACA6C,UAAU,GAAG7C,KAAb;IACD;;IAED6C,UAAU,CAAClD,IAAX,GAAkB,EAAlB;;IAEA,KAAK+B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG7C,MAAM,CAACU,OAAP,CAAesC,MAA/B,EAAuCH,CAAC,EAAxC,EAA4C;MAC1CpC,MAAM,GAAGT,MAAM,CAACU,OAAP,CAAemC,CAAf,CAAT;;MACA,IAAIpC,MAAM,CAACG,IAAP,KAAgB,OAApB,EAA6B;QAC3B;MACD;;MAED,MAAMuD,QAAa,GAAG,EAAtB;MACA,IAAIC,SAAc,GAAG,EAArB;;MAEA,IAAIxF,qBAAqB,CAAC6B,MAAD,CAAzB,EAAmC;QACjC,IAAI5B,4CAA4C,CAAC4B,MAAD,CAAhD,EAA0D;UACxD,IAAIA,MAAM,CAAC4D,iBAAX,EAA8B;YAC5BD,SAAS,GAAG;cACVE,YAAY,EAAE;YADJ,CAAZ;;YAIA,KAAKR,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGrD,MAAM,CAAC4D,iBAAP,CAAyBrB,MAAzC,EAAiDc,CAAC,EAAlD,EAAsD;cACpDC,EAAE,GAAGtD,MAAM,CAAC4D,iBAAP,CAAyBP,CAAzB,CAAL;;cAEA,IAAIC,EAAE,CAACQ,IAAH,IAAWR,EAAE,CAACS,WAAd,IAA6B,QAAQC,IAAR,CAAaV,EAAE,CAACS,WAAhB,CAAjC,EAA+D;gBAC7D,MAAME,UAAU,GAAG1F,cAAc,CAACgB,MAAM,CAACU,OAAR,EAAiBqD,EAAE,CAACS,WAApB,CAAjC;;gBACA,IAAIE,UAAJ,EAAgB;kBACd,IAAIA,UAAU,CAAC9D,IAAX,KAAoB,OAAxB,EAAiC;oBAC/BwD,SAAS,CAACE,YAAV,CAAuBP,EAAE,CAACQ,IAA1B,IAAkC,QAAlC;kBACD,CAFD,MAEO;oBACLH,SAAS,CAACE,YAAV,CAAuBP,EAAE,CAACQ,IAA1B,IAAkCR,EAAE,CAACS,WAArC;kBACD;gBACF;cACF;YACF;UACF,CAnBD,MAmBO;YACL;UACD;QACF,CAvBD,MAuBO;UACL,IAAI/D,MAAM,CAACP,KAAP,IAAgB,QAAQuE,IAAR,CAAahE,MAAM,CAACP,KAApB,CAApB,EAAgD;YAC9C,MAAMwE,UAAU,GAAG1F,cAAc,CAACgB,MAAM,CAACU,OAAR,EAAiBD,MAAM,CAACP,KAAxB,CAAjC;;YACA,IAAIwE,UAAJ,EAAgB;cACd,IAAIA,UAAU,CAAC9D,IAAX,KAAoB,OAAxB,EAAiC;gBAC/BwD,SAAS,GAAG;kBAAEE,YAAY,EAAE;gBAAhB,CAAZ;cACD,CAFD,MAEO;gBACLF,SAAS,GAAG;kBAAEE,YAAY,EAAE7D,MAAM,CAACP;gBAAvB,CAAZ;cACD;YACF;UACF,CATD,MASO;YACL;UACD;QACF;MACF,CAtCD,MAsCO,IAAIzB,4BAA4B,CAACgC,MAAD,CAAhC,EAA0C;QAC/C2D,SAAS,GAAG;UAAElE,KAAK,EAAEO,MAAM,CAACP;QAAhB,CAAZ;MACD;;MAED,IAAIxB,+BAA+B,CAAC+B,MAAD,CAAnC,EAA6C;QAC3CkE,MAAM,CAACC,OAAP,CAAenE,MAAM,CAACN,QAAP,IAAmB,EAAlC,EACGT,MADH,CACU,CAAC,CAACmF,CAAD,EAAIC,CAAJ,CAAD,KAAYA,CAAC,KAAK,IAD5B,EAEGC,OAFH,CAEW,CAAC,CAACC,CAAD,EAAIF,CAAJ,CAAD,KAAY;UACnBV,SAAS,CAACY,CAAD,CAAT,GACEA,CAAC,KAAK,QAAN,GAAiB,KAAKC,WAAL,CAAiB9F,cAAc,CAACsB,MAAD,CAA/B,CAAjB,GAAiGqE,CADnG;QAED,CALH,EAD2C,CAQ3C;QACA;QACA;;QACA,QAAQrE,MAAM,CAACG,IAAf;UACE,KAAK,YAAL;YACEwD,SAAS,qBACJA,SADI,EAEH,eAAAA,SAAS,UAAT,gDAAWc,MAAX,MAAsBC,SAAtB,IAAmC;cAAED,MAAM,EAAE,KAAKE,QAAL,CAAchB,SAAS,CAACc,MAAxB;YAAV,CAFhC,EAGH,gBAAAd,SAAS,UAAT,kDAAWiB,OAAX,MAAuBF,SAAvB,IAAoC;cAAEE,OAAO,EAAE,KAAKD,QAAL,CAAchB,SAAS,CAACiB,OAAxB;YAAX,CAHjC,EAIH1G,gCAAgC,CAAC8B,MAAD,CAAhC,IAA4C;cAC9CN,QAAQ,oBACHiE,SAAS,CAACjE,QADP,EAEHwE,MAAM,CAACW,WAAP,CACDX,MAAM,CAACC,OAAP,CAAeR,SAAS,CAACjE,QAAV,IAAsB,EAArC,EACE;cADF,CAEGT,MAFH,CAEU,CAAC,CAAC6F,WAAD,CAAD,KAAmB,CAAC,OAAD,EAAU,MAAV,EAAkB,OAAlB,EAA2B,QAA3B,EAAqCC,QAArC,CAA8CD,WAA9C,CAF7B,EAGE;cAHF,CAIG7F,MAJH,CAIU,CAAC,CAACmF,CAAD,EAAIY,WAAJ,CAAD,KAAsBA,WAAW,KAAKN,SAJhD,EAKGO,GALH,CAKO,CAAC,CAACb,CAAD,EAAIY,WAAJ,CAAD,KAAsB,CAACZ,CAAD,EAAI,KAAKO,QAAL,CAAcK,WAAd,CAAJ,CAL7B,CADC,CAFG;YADsC,CAJzC,CAAT;YAkBA;;UAEF,KAAK,aAAL;YACErB,SAAS,qBACJA,SADI,EAEHA,SAAS,CAACuB,GAAV,KAAkBR,SAAlB,IAA+B;cACjCQ,GAAG,EAAE,KAAKP,QAAL,CAAchB,SAAS,CAACuB,GAAxB;YAD4B,CAF5B,CAAT;YAMA;;UAEF,KAAK,aAAL;YACEvB,SAAS,GAAG;cACV1D,OAAO,uBAAED,MAAM,CAACN,QAAT,+EAAE,kBAAiBO,OAAnB,0DAAE,sBAA0BgF,GAA1B,CAA+BxF,KAAD,KAAY;gBAAEA;cAAF,CAAZ,CAA9B,CADC;cAEVE,IAAI,EAAE;YAFI,CAAZ;;YAKA,yBAAIK,MAAM,CAACN,QAAX,8CAAI,kBAAiBG,OAArB,EAA8B;cAAA;;cAC5B8D,SAAS,CAAC9B,IAAV,GAAiB,CAAC;gBAAE,sBAAC7B,MAAM,CAACN,QAAR,sDAAC,kBAAiBG,OAAlB,wBAA4BG,MAAM,CAACN,QAAnC,sDAA4B,kBAAiBI;cAA/C,CAAD,CAAjB;YACD;;YACD;QAxCJ;MA0CD;;MAED4D,QAAQ,CAAC1D,MAAM,CAACG,IAAR,CAAR,GAAwBwD,SAAxB;MACAJ,UAAU,CAAClD,IAAX,CAAgBL,MAAM,CAACE,EAAvB,IAA6BwD,QAA7B;IACD;;IAED,OAAOnC,KAAP;EACD;;EAEOiD,WAAW,CAACW,MAAD,EAAiB;IAClC,IAAItH,GAAG,CAAC,KAAKkB,SAAN,EAAiB,OAAjB,CAAP,EAAkC;MAChC,OAAOoG,MAAP;IACD;;IAED,OAAO;MACLC,MAAM,EAAED;IADH,CAAP;EAGD;;EAEOR,QAAQ,CAACK,WAAD,EAAyC;IACvD,MAAMK,WAAW,GAAGC,UAAU,CAAE,GAAEN,WAAY,EAAhB,CAA9B;;IACA,IAAIzE,KAAK,CAAC8E,WAAD,CAAT,EAAwB;MACtB,OAAOL,WAAP;IACD;;IAED,OAAOK,WAAP;EACD;;EAEDE,aAAa,CAACC,QAAD,EAAuB;IAClC,MAAMjE,KAAU,GAAG;MACjB5B,IAAI,EAAE,CADW;MAEjB4B,KAAK,EAAE;QACLoB,IAAI,EAAE;UACJ1D,MAAM,EAAE,CAAC;YAAE+D,KAAK,EAAE,KAAKhE,cAAL;UAAT,CAAD;QADJ;MADD;IAFU,CAAnB;;IASA,IAAIwG,QAAQ,CAACjE,KAAb,EAAoB;MAClBA,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiB1D,MAAjB,CAAwB4D,IAAxB,CAA6B;QAC3BnB,YAAY,EAAE;UACZC,gBAAgB,EAAE,IADN;UAEZJ,KAAK,EAAEiE,QAAQ,CAACjE;QAFJ;MADa,CAA7B;IAMD;;IAED,IAAI5B,IAAI,GAAG,GAAX;;IACA,IAAI6F,QAAQ,CAAC7F,IAAb,EAAmB;MACjBA,IAAI,GAAG6F,QAAQ,CAAC7F,IAAhB;IACD;;IAED4B,KAAK,CAAClB,IAAN,GAAa;MACX,KAAK;QACHb,KAAK,EAAE;UACLC,KAAK,EAAE+F,QAAQ,CAAC/F,KADX;UAELE,IAAI,EAAEA,IAFD;UAGLG,KAAK,EAAE;QAHF;MADJ;IADM,CAAb,CAxBkC,CAkClC;IACA;IACA;;IAEA,MAAM;MAAED,OAAO,GAAG,KAAZ;MAAmBC,KAAK,GAAGD,OAAO,KAAK,WAAZ,GAA0B,MAA1B,GAAmC;IAA9D,IAAwE2F,QAA9E;;IAEA,IAAI,CAAC,KAAD,EAAQ,MAAR,EAAgBC,OAAhB,CAAwB3F,KAAxB,IAAiC,CAArC,EAAwC;MACtC,MAAM;QAAE0D,OAAO,EAAG,4BAA2B1D,KAAM;MAA7C,CAAN;IACD;;IAED,QAAQD,OAAR;MACE,KAAK,KAAL;MACA,KAAK,MAAL;QACE,MAAM6F,OAAO,GAAG7H,GAAG,CAAC,KAAKkB,SAAN,EAAiB,OAAjB,CAAH,GAA+B,MAA/B,GAAwC,OAAxD;QACAwC,KAAK,CAAClB,IAAN,CAAW,GAAX,EAAgBb,KAAhB,CAAsBM,KAAtB,CAA4B4F,OAA5B,IAAuC5F,KAAvC;QACA;;MACF,KAAK,WAAL;QACEyB,KAAK,CAAClB,IAAN,CAAW,GAAX,EAAgBb,KAAhB,CAAsBM,KAAtB,CAA4B,QAA5B,IAAwCA,KAAxC;QACA;;MACF;QACE,MAAM;UAAE0D,OAAO,EAAG,2BAA0B3D,OAAQ;QAA9C,CAAN;IAVJ;;IAaA,OAAO0B,KAAP;EACD;;EAEDoE,YAAY,CAACpG,MAAD,EAA6BqG,KAA7B,EAA4CzD,YAA5C,EAAgE;IAC1E,IAAIZ,KAAU,GAAG;MACf5B,IAAI,EAAE,CADS;MAEf4B,KAAK,EAAE;QACLoB,IAAI,EAAE;UACJ1D,MAAM,EAAE,CAAC;YAAE+D,KAAK,EAAE,KAAKhE,cAAL;UAAT,CAAD;QADJ;MADD;IAFQ,CAAjB;IASA,KAAKkD,eAAL,CAAqBX,KAArB,EAA4BY,YAA5B;;IAEA,IAAI5C,MAAM,CAACgC,KAAX,EAAkB;MAChBA,KAAK,CAACA,KAAN,CAAYoB,IAAZ,CAAiB1D,MAAjB,CAAwB4D,IAAxB,CAA6B;QAC3BnB,YAAY,EAAE;UACZC,gBAAgB,EAAE,IADN;UAEZJ,KAAK,EAAEhC,MAAM,CAACgC;QAFF;MADa,CAA7B;IAMD;;IAEDA,KAAK,GAAG,KAAKK,aAAL,CAAmBL,KAAnB,EAA0BqE,KAA1B,CAAR;IAEA,yBACKrE,KADL;MAEElB,IAAI,EAAE,KAAK8C,KAAL,CAAW5D,MAAX,EAAmB,IAAnB,EAAyBc,IAFjC;MAGEwF,SAAS,EAAE;QACT7D,MAAM,EAAE;UACN,KAAK;QADC,CADC;QAIT8D,QAAQ,EAAE,CAACtH,aAAa,CAACuH,GAAf,CAJD;QAKTC,SAAS,EAAE,CAACxH,aAAa,CAACyH,IAAf,CALF;QAMTC,aAAa,EAAE;MANN;IAHb;EAYD;;AA3f8B"},"metadata":{},"sourceType":"module"}