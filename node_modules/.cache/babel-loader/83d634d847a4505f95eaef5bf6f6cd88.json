{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { TIME_SERIES_VALUE_FIELD_NAME } from '../../types/dataFrame';\nimport { ArrayVector } from '../../vector';\nimport { DataTransformerID } from './ids';\nexport let ConcatenateFrameNameMode;\n\n(function (ConcatenateFrameNameMode) {\n  ConcatenateFrameNameMode[\"Drop\"] = \"drop\";\n  ConcatenateFrameNameMode[\"FieldName\"] = \"field\";\n  ConcatenateFrameNameMode[\"Label\"] = \"label\";\n})(ConcatenateFrameNameMode || (ConcatenateFrameNameMode = {}));\n\nexport const concatenateTransformer = {\n  id: DataTransformerID.concatenate,\n  name: 'Concatenate fields',\n  description: 'Combine all fields into a single frame.  Values will be appended with undefined values if not the same length.',\n  defaultOptions: {\n    frameNameMode: ConcatenateFrameNameMode.FieldName,\n    frameNameLabel: 'frame'\n  },\n  operator: options => source => source.pipe(map(dataFrames => {\n    if (!Array.isArray(dataFrames) || dataFrames.length < 2) {\n      return dataFrames; // noop with single frame\n    }\n\n    return [concatenateFields(dataFrames, options)];\n  }))\n};\n/**\n * @internal only exported for tests\n */\n\nexport function concatenateFields(data, opts) {\n  var _opts$frameNameLabel;\n\n  let sameLength = true;\n  let maxLength = data[0].length;\n  const frameNameLabel = (_opts$frameNameLabel = opts.frameNameLabel) !== null && _opts$frameNameLabel !== void 0 ? _opts$frameNameLabel : 'frame';\n  let fields = [];\n\n  for (const frame of data) {\n    if (maxLength !== frame.length) {\n      sameLength = false;\n      maxLength = Math.max(maxLength, frame.length);\n    }\n\n    for (const f of frame.fields) {\n      const copy = Object.assign({}, f);\n      copy.state = undefined;\n\n      if (frame.name) {\n        if (opts.frameNameMode === ConcatenateFrameNameMode.Drop) {// nothing -- skip the name\n        } else if (opts.frameNameMode === ConcatenateFrameNameMode.Label) {\n          copy.labels = Object.assign({}, f.labels);\n          copy.labels[frameNameLabel] = frame.name;\n        } else if (!copy.name || copy.name === TIME_SERIES_VALUE_FIELD_NAME) {\n          copy.name = frame.name;\n        } else {\n          copy.name = `${frame.name} · ${f.name}`;\n        }\n      }\n\n      fields.push(copy);\n    }\n  } // Make sure all fields have the same length\n\n\n  if (!sameLength) {\n    fields = fields.map(f => {\n      if (f.values.length === maxLength) {\n        return f;\n      }\n\n      const values = f.values.toArray();\n      values.length = maxLength;\n      return Object.assign({}, f, {\n        values: new ArrayVector(values)\n      });\n    });\n  }\n\n  return {\n    fields,\n    length: maxLength\n  };\n}","map":{"version":3,"names":["map","TIME_SERIES_VALUE_FIELD_NAME","ArrayVector","DataTransformerID","ConcatenateFrameNameMode","concatenateTransformer","id","concatenate","name","description","defaultOptions","frameNameMode","FieldName","frameNameLabel","operator","options","source","pipe","dataFrames","Array","isArray","length","concatenateFields","data","opts","sameLength","maxLength","fields","frame","Math","max","f","copy","state","undefined","Drop","Label","labels","push","values","toArray"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/concat.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { DataFrame, Field, TIME_SERIES_VALUE_FIELD_NAME } from '../../types/dataFrame';\nimport { DataTransformerInfo } from '../../types/transformations';\nimport { ArrayVector } from '../../vector';\n\nimport { DataTransformerID } from './ids';\n\nexport enum ConcatenateFrameNameMode {\n  /**\n   * Ignore the source frame name when moving to the destination\n   */\n  Drop = 'drop',\n\n  /**\n   * Copy the source frame name to the destination field.  The final field will contain\n   * both the frame and field name\n   */\n  FieldName = 'field',\n\n  /**\n   * Copy the source frame name to a label on the field.  The label key is controlled\n   * by frameNameLabel\n   */\n  Label = 'label',\n}\n\nexport interface ConcatenateTransformerOptions {\n  frameNameMode?: ConcatenateFrameNameMode;\n  frameNameLabel?: string;\n}\n\nexport const concatenateTransformer: DataTransformerInfo<ConcatenateTransformerOptions> = {\n  id: DataTransformerID.concatenate,\n  name: 'Concatenate fields',\n  description:\n    'Combine all fields into a single frame.  Values will be appended with undefined values if not the same length.',\n  defaultOptions: {\n    frameNameMode: ConcatenateFrameNameMode.FieldName,\n    frameNameLabel: 'frame',\n  },\n  operator: (options) => (source) =>\n    source.pipe(\n      map((dataFrames) => {\n        if (!Array.isArray(dataFrames) || dataFrames.length < 2) {\n          return dataFrames; // noop with single frame\n        }\n        return [concatenateFields(dataFrames, options)];\n      })\n    ),\n};\n\n/**\n * @internal only exported for tests\n */\nexport function concatenateFields(data: DataFrame[], opts: ConcatenateTransformerOptions): DataFrame {\n  let sameLength = true;\n  let maxLength = data[0].length;\n  const frameNameLabel = opts.frameNameLabel ?? 'frame';\n  let fields: Field[] = [];\n\n  for (const frame of data) {\n    if (maxLength !== frame.length) {\n      sameLength = false;\n      maxLength = Math.max(maxLength, frame.length);\n    }\n\n    for (const f of frame.fields) {\n      const copy = { ...f };\n      copy.state = undefined;\n      if (frame.name) {\n        if (opts.frameNameMode === ConcatenateFrameNameMode.Drop) {\n          // nothing -- skip the name\n        } else if (opts.frameNameMode === ConcatenateFrameNameMode.Label) {\n          copy.labels = { ...f.labels };\n          copy.labels[frameNameLabel] = frame.name;\n        } else if (!copy.name || copy.name === TIME_SERIES_VALUE_FIELD_NAME) {\n          copy.name = frame.name;\n        } else {\n          copy.name = `${frame.name} · ${f.name}`;\n        }\n      }\n      fields.push(copy);\n    }\n  }\n\n  // Make sure all fields have the same length\n  if (!sameLength) {\n    fields = fields.map((f) => {\n      if (f.values.length === maxLength) {\n        return f;\n      }\n      const values = f.values.toArray();\n      values.length = maxLength;\n      return {\n        ...f,\n        values: new ArrayVector(values),\n      };\n    });\n  }\n\n  return {\n    fields,\n    length: maxLength,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}