{"ast":null,"code":"import { map, defer, mergeMap } from 'rxjs';\nimport { LiveChannelScope, LoadingState } from '@grafana/data';\nimport { getGrafanaLiveSrv } from '@grafana/runtime';\nimport { StreamingDataFrame } from 'app/features/live/data/StreamingDataFrame';\n\n/**\n * Calculate a unique key for the query.  The key is used to pick a channel and should\n * be unique for each distinct query execution plan.  This key is not secure and is only picked to avoid\n * possible collisions\n */\nexport async function getLiveStreamKey(query) {\n  const str = JSON.stringify({\n    expr: query.expr\n  });\n  const msgUint8 = new TextEncoder().encode(str); // encode as (utf-8) Uint8Array\n\n  const hashBuffer = await crypto.subtle.digest('SHA-1', msgUint8); // hash the message\n\n  const hashArray = Array.from(new Uint8Array(hashBuffer.slice(0, 8))); // first 8 bytes\n\n  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n} // This will get both v1 and v2 result formats\n\nexport function doLokiChannelStream(query, ds, options) {\n  var _options$maxDataPoint;\n\n  // maximum time to keep values\n  const range = options.range;\n  const maxDelta = range.to.valueOf() - range.from.valueOf() + 1000;\n  let maxLength = (_options$maxDataPoint = options.maxDataPoints) !== null && _options$maxDataPoint !== void 0 ? _options$maxDataPoint : 1000;\n\n  if (maxLength > 100) {\n    // for small buffers, keep them small\n    maxLength *= 2;\n  }\n\n  let frame = undefined;\n\n  const updateFrame = msg => {\n    if (msg !== null && msg !== void 0 && msg.message) {\n      const p = msg.message;\n\n      if (!frame) {\n        frame = StreamingDataFrame.fromDataFrameJSON(p, {\n          maxLength,\n          maxDelta,\n          displayNameFormat: query.legendFormat\n        });\n      } else {\n        frame.push(p);\n      }\n    }\n\n    return frame;\n  };\n\n  return defer(() => getLiveStreamKey(query)).pipe(mergeMap(key => {\n    return getGrafanaLiveSrv().getStream({\n      scope: LiveChannelScope.DataSource,\n      namespace: ds.uid,\n      path: `tail/${key}`,\n      data: Object.assign({}, query, {\n        timeRange: {\n          from: range.from.valueOf().toString(),\n          to: range.to.valueOf().toString()\n        }\n      })\n    }).pipe(map(evt => {\n      const frame = updateFrame(evt);\n      return {\n        data: frame ? [frame] : [],\n        state: LoadingState.Streaming\n      };\n    }));\n  }));\n}","map":{"version":3,"names":["map","defer","mergeMap","LiveChannelScope","LoadingState","getGrafanaLiveSrv","StreamingDataFrame","getLiveStreamKey","query","str","JSON","stringify","expr","msgUint8","TextEncoder","encode","hashBuffer","crypto","subtle","digest","hashArray","Array","from","Uint8Array","slice","b","toString","padStart","join","doLokiChannelStream","ds","options","range","maxDelta","to","valueOf","maxLength","maxDataPoints","frame","undefined","updateFrame","msg","message","p","fromDataFrameJSON","displayNameFormat","legendFormat","push","pipe","key","getStream","scope","DataSource","namespace","uid","path","data","timeRange","evt","state","Streaming"],"sources":["/home/soula/grafana/public/app/plugins/datasource/loki/streaming.ts"],"sourcesContent":["import { map, Observable, defer, mergeMap } from 'rxjs';\n\nimport { DataFrameJSON, DataQueryRequest, DataQueryResponse, LiveChannelScope, LoadingState } from '@grafana/data';\nimport { getGrafanaLiveSrv } from '@grafana/runtime';\nimport { StreamingDataFrame } from 'app/features/live/data/StreamingDataFrame';\n\nimport { LokiDatasource } from './datasource';\nimport { LokiQuery } from './types';\n\n/**\n * Calculate a unique key for the query.  The key is used to pick a channel and should\n * be unique for each distinct query execution plan.  This key is not secure and is only picked to avoid\n * possible collisions\n */\nexport async function getLiveStreamKey(query: LokiQuery): Promise<string> {\n  const str = JSON.stringify({ expr: query.expr });\n\n  const msgUint8 = new TextEncoder().encode(str); // encode as (utf-8) Uint8Array\n  const hashBuffer = await crypto.subtle.digest('SHA-1', msgUint8); // hash the message\n  const hashArray = Array.from(new Uint8Array(hashBuffer.slice(0, 8))); // first 8 bytes\n  return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n}\n\n// This will get both v1 and v2 result formats\nexport function doLokiChannelStream(\n  query: LokiQuery,\n  ds: LokiDatasource,\n  options: DataQueryRequest<LokiQuery>\n): Observable<DataQueryResponse> {\n  // maximum time to keep values\n  const range = options.range;\n  const maxDelta = range.to.valueOf() - range.from.valueOf() + 1000;\n  let maxLength = options.maxDataPoints ?? 1000;\n  if (maxLength > 100) {\n    // for small buffers, keep them small\n    maxLength *= 2;\n  }\n\n  let frame: StreamingDataFrame | undefined = undefined;\n  const updateFrame = (msg: any) => {\n    if (msg?.message) {\n      const p = msg.message as DataFrameJSON;\n      if (!frame) {\n        frame = StreamingDataFrame.fromDataFrameJSON(p, {\n          maxLength,\n          maxDelta,\n          displayNameFormat: query.legendFormat,\n        });\n      } else {\n        frame.push(p);\n      }\n    }\n    return frame;\n  };\n\n  return defer(() => getLiveStreamKey(query)).pipe(\n    mergeMap((key) => {\n      return getGrafanaLiveSrv()\n        .getStream<any>({\n          scope: LiveChannelScope.DataSource,\n          namespace: ds.uid,\n          path: `tail/${key}`,\n          data: {\n            ...query,\n            timeRange: {\n              from: range.from.valueOf().toString(),\n              to: range.to.valueOf().toString(),\n            },\n          },\n        })\n        .pipe(\n          map((evt) => {\n            const frame = updateFrame(evt);\n            return {\n              data: frame ? [frame] : [],\n              state: LoadingState.Streaming,\n            };\n          })\n        );\n    })\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}