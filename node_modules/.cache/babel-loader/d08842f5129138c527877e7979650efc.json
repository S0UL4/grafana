{"ast":null,"code":"import { omit } from 'lodash';\nimport { map } from 'rxjs/operators';\nimport { MutableDataFrame } from '../../dataframe';\nimport { ArrayVector } from '../../vector/ArrayVector';\nimport { DataTransformerID } from './ids';\nexport const mergeTransformer = {\n  id: DataTransformerID.merge,\n  name: 'Merge series/tables',\n  description: 'Merges multiple series/tables into a single serie/table',\n  defaultOptions: {},\n  operator: options => source => source.pipe(map(dataFrames => {\n    if (!Array.isArray(dataFrames) || dataFrames.length <= 1) {\n      return dataFrames;\n    }\n\n    const data = dataFrames.filter(frame => frame.fields.length > 0);\n\n    if (data.length === 0) {\n      return [dataFrames[0]];\n    }\n\n    const fieldNames = new Set();\n    const fieldIndexByName = {};\n    const fieldNamesForKey = [];\n    const dataFrame = new MutableDataFrame();\n\n    for (let frameIndex = 0; frameIndex < data.length; frameIndex++) {\n      const frame = data[frameIndex];\n\n      for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n        const field = frame.fields[fieldIndex];\n\n        if (!fieldNames.has(field.name)) {\n          dataFrame.addField(copyFieldStructure(field));\n          fieldNames.add(field.name);\n        }\n\n        fieldIndexByName[field.name] = fieldIndexByName[field.name] || {};\n        fieldIndexByName[field.name][frameIndex] = fieldIndex;\n\n        if (data.length - 1 !== frameIndex) {\n          continue;\n        }\n\n        if (fieldExistsInAllFrames(fieldIndexByName, field, data)) {\n          fieldNamesForKey.push(field.name);\n        }\n      }\n    }\n\n    if (fieldNamesForKey.length === 0) {\n      return dataFrames;\n    }\n\n    const valuesByKey = {};\n    const valuesInOrder = [];\n    const keyFactory = createKeyFactory(data, fieldIndexByName, fieldNamesForKey);\n    const valueMapper = createValueMapper(data, fieldNames, fieldIndexByName);\n\n    for (let frameIndex = 0; frameIndex < data.length; frameIndex++) {\n      const frame = data[frameIndex];\n\n      for (let valueIndex = 0; valueIndex < frame.length; valueIndex++) {\n        const key = keyFactory(frameIndex, valueIndex);\n        const value = valueMapper(frameIndex, valueIndex);\n\n        if (!Array.isArray(valuesByKey[key])) {\n          valuesByKey[key] = [value];\n          valuesInOrder.push(createPointer(key, valuesByKey));\n          continue;\n        }\n\n        let valueWasMerged = false;\n        valuesByKey[key] = valuesByKey[key].map(existing => {\n          if (!isMergable(existing, value)) {\n            return existing;\n          }\n\n          valueWasMerged = true;\n          return Object.assign({}, existing, value);\n        });\n\n        if (!valueWasMerged) {\n          valuesByKey[key].push(value);\n          valuesInOrder.push(createPointer(key, valuesByKey));\n        }\n      }\n    }\n\n    for (const pointer of valuesInOrder) {\n      const value = valuesByKey[pointer.key][pointer.index];\n\n      if (value) {\n        dataFrame.add(value);\n      }\n    }\n\n    return [dataFrame];\n  }))\n};\n\nconst copyFieldStructure = field => {\n  return Object.assign({}, omit(field, ['values', 'state', 'labels', 'config']), {\n    values: new ArrayVector(),\n    config: Object.assign({}, omit(field.config, 'displayName'))\n  });\n};\n\nconst createKeyFactory = (data, fieldPointerByName, keyFieldNames) => {\n  const factoryIndex = keyFieldNames.reduce((index, fieldName) => {\n    return Object.keys(fieldPointerByName[fieldName]).reduce((index, frameIndex) => {\n      index[frameIndex] = index[frameIndex] || [];\n      index[frameIndex].push(fieldPointerByName[fieldName][frameIndex]);\n      return index;\n    }, index);\n  }, {});\n  return (frameIndex, valueIndex) => {\n    return factoryIndex[frameIndex].reduce((key, fieldIndex) => {\n      return key + data[frameIndex].fields[fieldIndex].values.get(valueIndex);\n    }, '');\n  };\n};\n\nconst createValueMapper = (data, fieldByName, fieldIndexByName) => {\n  return (frameIndex, valueIndex) => {\n    const value = {};\n    const fieldNames = Array.from(fieldByName);\n\n    for (const fieldName of fieldNames) {\n      const fieldIndexByFrameIndex = fieldIndexByName[fieldName];\n\n      if (!fieldIndexByFrameIndex) {\n        continue;\n      }\n\n      const fieldIndex = fieldIndexByFrameIndex[frameIndex];\n\n      if (typeof fieldIndex !== 'number') {\n        continue;\n      }\n\n      const frame = data[frameIndex];\n\n      if (!frame || !frame.fields) {\n        continue;\n      }\n\n      const field = frame.fields[fieldIndex];\n\n      if (!field || !field.values) {\n        continue;\n      }\n\n      value[fieldName] = field.values.get(valueIndex);\n    }\n\n    return value;\n  };\n};\n\nconst isMergable = (existing, value) => {\n  let mergable = true;\n\n  for (const prop in value) {\n    if (typeof existing[prop] === 'undefined') {\n      continue;\n    }\n\n    if (existing[prop] === null) {\n      continue;\n    }\n\n    if (existing[prop] !== value[prop]) {\n      mergable = false;\n      break;\n    }\n  }\n\n  return mergable;\n};\n\nconst fieldExistsInAllFrames = (fieldIndexByName, field, data) => {\n  return Object.keys(fieldIndexByName[field.name]).length === data.length;\n};\n\nconst createPointer = (key, valuesByKey) => {\n  return {\n    key,\n    index: valuesByKey[key].length - 1\n  };\n};","map":{"version":3,"names":["omit","map","MutableDataFrame","ArrayVector","DataTransformerID","mergeTransformer","id","merge","name","description","defaultOptions","operator","options","source","pipe","dataFrames","Array","isArray","length","data","filter","frame","fields","fieldNames","Set","fieldIndexByName","fieldNamesForKey","dataFrame","frameIndex","fieldIndex","field","has","addField","copyFieldStructure","add","fieldExistsInAllFrames","push","valuesByKey","valuesInOrder","keyFactory","createKeyFactory","valueMapper","createValueMapper","valueIndex","key","value","createPointer","valueWasMerged","existing","isMergable","pointer","index","values","config","fieldPointerByName","keyFieldNames","factoryIndex","reduce","fieldName","Object","keys","get","fieldByName","from","fieldIndexByFrameIndex","mergable","prop"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/merge.ts"],"sourcesContent":["import { omit } from 'lodash';\nimport { map } from 'rxjs/operators';\n\nimport { MutableDataFrame } from '../../dataframe';\nimport { DataFrame, Field } from '../../types/dataFrame';\nimport { DataTransformerInfo } from '../../types/transformations';\nimport { ArrayVector } from '../../vector/ArrayVector';\n\nimport { DataTransformerID } from './ids';\n\ninterface ValuePointer {\n  key: string;\n  index: number;\n}\n\nexport interface MergeTransformerOptions {}\n\nexport const mergeTransformer: DataTransformerInfo<MergeTransformerOptions> = {\n  id: DataTransformerID.merge,\n  name: 'Merge series/tables',\n  description: 'Merges multiple series/tables into a single serie/table',\n  defaultOptions: {},\n  operator: (options) => (source) =>\n    source.pipe(\n      map((dataFrames) => {\n        if (!Array.isArray(dataFrames) || dataFrames.length <= 1) {\n          return dataFrames;\n        }\n\n        const data = dataFrames.filter((frame) => frame.fields.length > 0);\n\n        if (data.length === 0) {\n          return [dataFrames[0]];\n        }\n\n        const fieldNames = new Set<string>();\n        const fieldIndexByName: Record<string, Record<number, number>> = {};\n        const fieldNamesForKey: string[] = [];\n        const dataFrame = new MutableDataFrame();\n\n        for (let frameIndex = 0; frameIndex < data.length; frameIndex++) {\n          const frame = data[frameIndex];\n\n          for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n            const field = frame.fields[fieldIndex];\n\n            if (!fieldNames.has(field.name)) {\n              dataFrame.addField(copyFieldStructure(field));\n              fieldNames.add(field.name);\n            }\n\n            fieldIndexByName[field.name] = fieldIndexByName[field.name] || {};\n            fieldIndexByName[field.name][frameIndex] = fieldIndex;\n\n            if (data.length - 1 !== frameIndex) {\n              continue;\n            }\n\n            if (fieldExistsInAllFrames(fieldIndexByName, field, data)) {\n              fieldNamesForKey.push(field.name);\n            }\n          }\n        }\n\n        if (fieldNamesForKey.length === 0) {\n          return dataFrames;\n        }\n\n        const valuesByKey: Record<string, Array<Record<string, any>>> = {};\n        const valuesInOrder: ValuePointer[] = [];\n        const keyFactory = createKeyFactory(data, fieldIndexByName, fieldNamesForKey);\n        const valueMapper = createValueMapper(data, fieldNames, fieldIndexByName);\n\n        for (let frameIndex = 0; frameIndex < data.length; frameIndex++) {\n          const frame = data[frameIndex];\n\n          for (let valueIndex = 0; valueIndex < frame.length; valueIndex++) {\n            const key = keyFactory(frameIndex, valueIndex);\n            const value = valueMapper(frameIndex, valueIndex);\n\n            if (!Array.isArray(valuesByKey[key])) {\n              valuesByKey[key] = [value];\n              valuesInOrder.push(createPointer(key, valuesByKey));\n              continue;\n            }\n\n            let valueWasMerged = false;\n\n            valuesByKey[key] = valuesByKey[key].map((existing) => {\n              if (!isMergable(existing, value)) {\n                return existing;\n              }\n              valueWasMerged = true;\n              return { ...existing, ...value };\n            });\n\n            if (!valueWasMerged) {\n              valuesByKey[key].push(value);\n              valuesInOrder.push(createPointer(key, valuesByKey));\n            }\n          }\n        }\n\n        for (const pointer of valuesInOrder) {\n          const value = valuesByKey[pointer.key][pointer.index];\n\n          if (value) {\n            dataFrame.add(value);\n          }\n        }\n\n        return [dataFrame];\n      })\n    ),\n};\n\nconst copyFieldStructure = (field: Field): Field => {\n  return {\n    ...omit(field, ['values', 'state', 'labels', 'config']),\n    values: new ArrayVector(),\n    config: {\n      ...omit(field.config, 'displayName'),\n    },\n  };\n};\n\nconst createKeyFactory = (\n  data: DataFrame[],\n  fieldPointerByName: Record<string, Record<string, number>>,\n  keyFieldNames: string[]\n) => {\n  const factoryIndex = keyFieldNames.reduce((index: Record<string, number[]>, fieldName) => {\n    return Object.keys(fieldPointerByName[fieldName]).reduce((index: Record<string, number[]>, frameIndex) => {\n      index[frameIndex] = index[frameIndex] || [];\n      index[frameIndex].push(fieldPointerByName[fieldName][frameIndex]);\n      return index;\n    }, index);\n  }, {});\n\n  return (frameIndex: number, valueIndex: number): string => {\n    return factoryIndex[frameIndex].reduce((key: string, fieldIndex: number) => {\n      return key + data[frameIndex].fields[fieldIndex].values.get(valueIndex);\n    }, '');\n  };\n};\n\nconst createValueMapper = (\n  data: DataFrame[],\n  fieldByName: Set<string>,\n  fieldIndexByName: Record<string, Record<number, number>>\n) => {\n  return (frameIndex: number, valueIndex: number) => {\n    const value: Record<string, any> = {};\n    const fieldNames = Array.from(fieldByName);\n\n    for (const fieldName of fieldNames) {\n      const fieldIndexByFrameIndex = fieldIndexByName[fieldName];\n      if (!fieldIndexByFrameIndex) {\n        continue;\n      }\n\n      const fieldIndex = fieldIndexByFrameIndex[frameIndex];\n      if (typeof fieldIndex !== 'number') {\n        continue;\n      }\n\n      const frame = data[frameIndex];\n      if (!frame || !frame.fields) {\n        continue;\n      }\n\n      const field = frame.fields[fieldIndex];\n      if (!field || !field.values) {\n        continue;\n      }\n\n      value[fieldName] = field.values.get(valueIndex);\n    }\n\n    return value;\n  };\n};\n\nconst isMergable = (existing: Record<string, any>, value: Record<string, any>): boolean => {\n  let mergable = true;\n\n  for (const prop in value) {\n    if (typeof existing[prop] === 'undefined') {\n      continue;\n    }\n\n    if (existing[prop] === null) {\n      continue;\n    }\n\n    if (existing[prop] !== value[prop]) {\n      mergable = false;\n      break;\n    }\n  }\n\n  return mergable;\n};\n\nconst fieldExistsInAllFrames = (\n  fieldIndexByName: Record<string, Record<number, number>>,\n  field: Field,\n  data: DataFrame[]\n) => {\n  return Object.keys(fieldIndexByName[field.name]).length === data.length;\n};\n\nconst createPointer = (key: string, valuesByKey: Record<string, Array<Record<string, any>>>): ValuePointer => {\n  return {\n    key,\n    index: valuesByKey[key].length - 1,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}