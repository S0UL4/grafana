{"ast":null,"code":"import GeoJSON from 'ol/format/GeoJSON';\nimport { ArrayVector, FieldType, getFieldTypeFromValue } from '@grafana/data';\n// http://geojson.xyz/\nexport function frameFromGeoJSON(body) {\n  const data = new GeoJSON().readFeatures(body, {\n    featureProjection: 'EPSG:3857'\n  });\n  const length = data.length;\n  const geo = new Array(length).fill(null);\n  const fieldOrder = [];\n  const lookup = new Map();\n\n  const getField = name => {\n    let f = lookup.get(name);\n\n    if (!f) {\n      f = {\n        types: new Set(),\n        values: new Array(length).fill(null),\n        count: 0\n      };\n      fieldOrder.push(name);\n      lookup.set(name, f);\n    }\n\n    return f;\n  };\n\n  const getBestName = (...names) => {\n    for (const k of names) {\n      if (!lookup.has(k)) {\n        return k;\n      }\n    }\n\n    return '___' + names[0];\n  };\n\n  const idfield = {\n    types: new Set(),\n    values: new Array(length).fill(null),\n    count: 0\n  };\n\n  for (let i = 0; i < length; i++) {\n    const feature = data[i];\n    geo[i] = feature.getGeometry();\n    const id = feature.getId();\n\n    if (id != null) {\n      idfield.values[i] = id;\n      idfield.types.add(getFieldTypeFromValue(id));\n      idfield.count++;\n    }\n\n    for (const key of feature.getKeys()) {\n      const val = feature.get(key);\n\n      if (val === geo[i] || val == null) {\n        continue;\n      }\n\n      const field = getField(key);\n      field.values[i] = val;\n      field.types.add(getFieldTypeFromValue(val));\n      field.count++;\n    }\n  }\n\n  const fields = [];\n\n  if (idfield.count > 0) {\n    const type = ensureSingleType(idfield);\n    fields.push({\n      name: getBestName('id', '_id', '__id'),\n      type,\n      values: new ArrayVector(idfield.values),\n      config: {}\n    });\n  } // Add a geometry field\n\n\n  fields.push({\n    name: getBestName('geo', 'geometry'),\n    type: FieldType.geo,\n    values: new ArrayVector(geo),\n    config: {}\n  });\n\n  for (const name of fieldOrder) {\n    const info = lookup.get(name);\n\n    if (!info) {\n      continue;\n    }\n\n    const type = ensureSingleType(info);\n    fields.push({\n      name,\n      type,\n      values: new ArrayVector(info.values),\n      config: {}\n    });\n  } // Simple frame\n\n\n  return {\n    fields,\n    length\n  };\n}\n\nfunction ensureSingleType(info) {\n  if (info.count < 1) {\n    return FieldType.other;\n  }\n\n  if (info.types.size > 1) {\n    info.values = info.values.map(v => {\n      if (v != null) {\n        return `${v}`;\n      }\n\n      return v;\n    });\n    return FieldType.string;\n  }\n\n  return info.types.values().next().value;\n}","map":{"version":3,"names":["GeoJSON","ArrayVector","FieldType","getFieldTypeFromValue","frameFromGeoJSON","body","data","readFeatures","featureProjection","length","geo","Array","fill","fieldOrder","lookup","Map","getField","name","f","get","types","Set","values","count","push","set","getBestName","names","k","has","idfield","i","feature","getGeometry","id","getId","add","key","getKeys","val","field","fields","type","ensureSingleType","config","info","other","size","map","v","string","next","value"],"sources":["/home/soula/grafana/public/app/features/geo/format/geojson.ts"],"sourcesContent":["import GeoJSON from 'ol/format/GeoJSON';\nimport { Geometry } from 'ol/geom';\n\nimport { ArrayVector, DataFrame, Field, FieldType, getFieldTypeFromValue } from '@grafana/data';\n\ninterface FieldInfo {\n  values: any[];\n  types: Set<FieldType>;\n  count: number;\n}\n\n// http://geojson.xyz/\n\nexport function frameFromGeoJSON(body: Document | Element | Object | string): DataFrame {\n  const data = new GeoJSON().readFeatures(body, { featureProjection: 'EPSG:3857' });\n  const length = data.length;\n\n  const geo: Geometry[] = new Array(length).fill(null);\n\n  const fieldOrder: string[] = [];\n  const lookup = new Map<string, FieldInfo>();\n  const getField = (name: string) => {\n    let f = lookup.get(name);\n    if (!f) {\n      f = {\n        types: new Set<FieldType>(),\n        values: new Array(length).fill(null),\n        count: 0,\n      };\n      fieldOrder.push(name);\n      lookup.set(name, f);\n    }\n    return f;\n  };\n  const getBestName = (...names: string[]) => {\n    for (const k of names) {\n      if (!lookup.has(k)) {\n        return k;\n      }\n    }\n    return '___' + names[0];\n  };\n\n  const idfield: FieldInfo = {\n    types: new Set<FieldType>(),\n    values: new Array(length).fill(null),\n    count: 0,\n  };\n  for (let i = 0; i < length; i++) {\n    const feature = data[i];\n    geo[i] = feature.getGeometry()!;\n\n    const id = feature.getId();\n    if (id != null) {\n      idfield.values[i] = id;\n      idfield.types.add(getFieldTypeFromValue(id));\n      idfield.count++;\n    }\n\n    for (const key of feature.getKeys()) {\n      const val = feature.get(key);\n      if (val === geo[i] || val == null) {\n        continue;\n      }\n      const field = getField(key);\n      field.values[i] = val;\n      field.types.add(getFieldTypeFromValue(val));\n      field.count++;\n    }\n  }\n\n  const fields: Field[] = [];\n  if (idfield.count > 0) {\n    const type = ensureSingleType(idfield);\n    fields.push({\n      name: getBestName('id', '_id', '__id'),\n      type,\n      values: new ArrayVector(idfield.values),\n      config: {},\n    });\n  }\n\n  // Add a geometry field\n  fields.push({\n    name: getBestName('geo', 'geometry'),\n    type: FieldType.geo,\n    values: new ArrayVector(geo),\n    config: {},\n  });\n\n  for (const name of fieldOrder) {\n    const info = lookup.get(name);\n    if (!info) {\n      continue;\n    }\n    const type = ensureSingleType(info);\n    fields.push({\n      name,\n      type,\n      values: new ArrayVector(info.values),\n      config: {},\n    });\n  }\n\n  // Simple frame\n  return {\n    fields,\n    length,\n  };\n}\n\nfunction ensureSingleType(info: FieldInfo): FieldType {\n  if (info.count < 1) {\n    return FieldType.other;\n  }\n  if (info.types.size > 1) {\n    info.values = info.values.map((v) => {\n      if (v != null) {\n        return `${v}`;\n      }\n      return v;\n    });\n    return FieldType.string;\n  }\n  return info.types.values().next().value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}