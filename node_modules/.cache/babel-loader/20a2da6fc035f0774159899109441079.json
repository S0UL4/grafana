{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Libraries\nimport { defaults } from 'lodash';\nimport Papa from 'papaparse'; // Types\n\nimport { MutableDataFrame } from '../dataframe/MutableDataFrame';\nimport { guessFieldTypeFromValue } from '../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../field';\nimport { FieldType } from '../types';\nimport { formattedValueToString } from '../valueFormats';\nexport let CSVHeaderStyle; // Subset of all parse options\n\n(function (CSVHeaderStyle) {\n  CSVHeaderStyle[CSVHeaderStyle[\"full\"] = 0] = \"full\";\n  CSVHeaderStyle[CSVHeaderStyle[\"name\"] = 1] = \"name\";\n  CSVHeaderStyle[CSVHeaderStyle[\"none\"] = 2] = \"none\";\n})(CSVHeaderStyle || (CSVHeaderStyle = {}));\n\nexport function readCSV(csv, options) {\n  return new CSVReader(options).readCSV(csv);\n}\nvar ParseState;\n\n(function (ParseState) {\n  ParseState[ParseState[\"Starting\"] = 0] = \"Starting\";\n  ParseState[ParseState[\"InHeader\"] = 1] = \"InHeader\";\n  ParseState[ParseState[\"ReadingRows\"] = 2] = \"ReadingRows\";\n})(ParseState || (ParseState = {}));\n\nexport class CSVReader {\n  constructor(options) {\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"callback\", void 0);\n\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"data\", void 0);\n\n    _defineProperty(this, \"current\", void 0);\n\n    _defineProperty(this, \"chunk\", (results, parser) => {\n      for (let i = 0; i < results.data.length; i++) {\n        const line = results.data[i];\n\n        if (line.length < 1) {\n          continue;\n        }\n\n        const first = line[0]; // null or value, papaparse does not return ''\n\n        if (first) {\n          // Comment or header queue\n          if (first.startsWith('#')) {\n            // Look for special header column\n            // #{columkey}#a,b,c\n            const idx = first.indexOf('#', 2);\n\n            if (idx > 0) {\n              const k = first.slice(1, idx);\n              const isName = 'name' === k; // Simple object used to check if headers match\n\n              const headerKeys = {\n                unit: '#'\n              }; // Check if it is a known/supported column\n\n              if (isName || headerKeys.hasOwnProperty(k)) {\n                // Starting a new table after reading rows\n                if (this.state === ParseState.ReadingRows) {\n                  this.current = new MutableDataFrame({\n                    fields: []\n                  });\n                  this.data.push(this.current);\n                }\n\n                const v = first.slice(idx + 1);\n\n                if (isName) {\n                  this.current.addFieldFor(undefined, v);\n\n                  for (let j = 1; j < line.length; j++) {\n                    this.current.addFieldFor(undefined, line[j]);\n                  }\n                } else {\n                  const {\n                    fields\n                  } = this.current;\n\n                  for (let j = 0; j < fields.length; j++) {\n                    if (!fields[j].config) {\n                      fields[j].config = {};\n                    }\n\n                    const disp = fields[j].config; // any lets name lookup\n\n                    disp[k] = j === 0 ? v : line[j];\n                  }\n                }\n\n                this.state = ParseState.InHeader;\n                continue;\n              }\n            } else if (this.state === ParseState.Starting) {\n              this.state = ParseState.InHeader;\n              continue;\n            } // Ignore comment lines\n\n\n            continue;\n          }\n\n          if (this.state === ParseState.Starting) {\n            const type = guessFieldTypeFromValue(first);\n\n            if (type === FieldType.string) {\n              for (const s of line) {\n                this.current.addFieldFor(undefined, s);\n              }\n\n              this.state = ParseState.InHeader;\n              continue;\n            }\n\n            this.state = ParseState.InHeader; // fall through to read rows\n          }\n        } // Add the current results to the data\n\n\n        if (this.state !== ParseState.ReadingRows) {// anything???\n        }\n\n        this.state = ParseState.ReadingRows; // Make sure column structure is valid\n\n        if (line.length > this.current.fields.length) {\n          const {\n            fields\n          } = this.current;\n\n          for (let f = fields.length; f < line.length; f++) {\n            this.current.addFieldFor(line[f]);\n          }\n\n          if (this.callback) {\n            this.callback.onHeader(this.current.fields);\n          }\n        }\n\n        this.current.appendRow(line);\n\n        if (this.callback) {\n          // // Send the header after we guess the type\n          // if (this.series.rows.length === 0) {\n          //   this.callback.onHeader(this.series);\n          // }\n          this.callback.onRow(line);\n        }\n      }\n    });\n\n    if (!options) {\n      options = {};\n    }\n\n    this.config = options.config || {};\n    this.callback = options.callback;\n    this.current = new MutableDataFrame({\n      fields: []\n    });\n    this.state = ParseState.Starting;\n    this.data = [];\n  } // PapaParse callback on each line\n\n\n  readCSV(text) {\n    this.current = new MutableDataFrame({\n      fields: []\n    });\n    this.data = [this.current];\n    const papacfg = Object.assign({}, this.config, {\n      dynamicTyping: false,\n      skipEmptyLines: true,\n      comments: false,\n      // Keep comment lines\n      chunk: this.chunk\n    });\n    Papa.parse(text, papacfg);\n    return this.data;\n  }\n\n}\n\nfunction writeValue(value, config) {\n  const str = value.toString();\n\n  if (str.includes('\"')) {\n    // Escape the double quote characters\n    return config.quoteChar + str.replace(/\"/gi, '\"\"') + config.quoteChar;\n  }\n\n  if (str.includes('\\n') || str.includes(config.delimiter)) {\n    return config.quoteChar + str + config.quoteChar;\n  }\n\n  return str;\n}\n\nfunction makeFieldWriter(field, config) {\n  if (field.display) {\n    return value => {\n      const displayValue = field.display(value);\n      return writeValue(formattedValueToString(displayValue), config);\n    };\n  }\n\n  return value => writeValue(value, config);\n}\n\nfunction getHeaderLine(key, fields, config) {\n  const isName = 'name' === key;\n  const isType = 'type' === key;\n\n  for (const f of fields) {\n    const display = f.config;\n\n    if (isName || isType || display && display.hasOwnProperty(key)) {\n      let line = '#' + key + '#';\n\n      for (let i = 0; i < fields.length; i++) {\n        if (i > 0) {\n          line = line + config.delimiter;\n        }\n\n        let v = fields[i].name;\n\n        if (isType) {\n          v = fields[i].type;\n        } else if (isName) {// already name\n        } else {\n          v = fields[i].config[key];\n        }\n\n        if (v) {\n          line = line + writeValue(v, config);\n        }\n      }\n\n      return line + config.newline;\n    }\n  }\n\n  return '';\n}\n\nfunction getLocaleDelimiter() {\n  const arr = ['x', 'y'];\n\n  if (arr.toLocaleString) {\n    return arr.toLocaleString().charAt(1);\n  }\n\n  return ',';\n}\n\nexport function toCSV(data, config) {\n  if (!data) {\n    return '';\n  }\n\n  config = defaults(config, {\n    delimiter: getLocaleDelimiter(),\n    newline: '\\r\\n',\n    quoteChar: '\"',\n    encoding: '',\n    headerStyle: CSVHeaderStyle.name,\n    useExcelHeader: false\n  });\n  let csv = config.useExcelHeader ? `sep=${config.delimiter}${config.newline}` : '';\n\n  for (const series of data) {\n    const {\n      fields\n    } = series; // ignore frames with no fields\n\n    if (fields.length === 0) {\n      continue;\n    }\n\n    if (config.headerStyle === CSVHeaderStyle.full) {\n      csv = csv + getHeaderLine('name', fields, config) + getHeaderLine('type', fields, config) + getHeaderLine('unit', fields, config) + getHeaderLine('dateFormat', fields, config);\n    } else if (config.headerStyle === CSVHeaderStyle.name) {\n      for (let i = 0; i < fields.length; i++) {\n        if (i > 0) {\n          csv += config.delimiter;\n        }\n\n        csv += `\"${getFieldDisplayName(fields[i], series).replace(/\"/g, '\"\"')}\"`;\n      }\n\n      csv += config.newline;\n    }\n\n    const length = fields[0].values.length;\n\n    if (length > 0) {\n      const writers = fields.map(field => makeFieldWriter(field, config));\n\n      for (let i = 0; i < length; i++) {\n        for (let j = 0; j < fields.length; j++) {\n          if (j > 0) {\n            csv = csv + config.delimiter;\n          }\n\n          const v = fields[j].values.get(i);\n\n          if (v !== null) {\n            csv = csv + writers[j](v);\n          }\n        }\n\n        csv = csv + config.newline;\n      }\n    }\n\n    csv = csv + config.newline;\n  }\n\n  return csv;\n}","map":{"version":3,"names":["defaults","Papa","MutableDataFrame","guessFieldTypeFromValue","getFieldDisplayName","FieldType","formattedValueToString","CSVHeaderStyle","readCSV","csv","options","CSVReader","ParseState","constructor","results","parser","i","data","length","line","first","startsWith","idx","indexOf","k","slice","isName","headerKeys","unit","hasOwnProperty","state","ReadingRows","current","fields","push","v","addFieldFor","undefined","j","config","disp","InHeader","Starting","type","string","s","f","callback","onHeader","appendRow","onRow","text","papacfg","dynamicTyping","skipEmptyLines","comments","chunk","parse","writeValue","value","str","toString","includes","quoteChar","replace","delimiter","makeFieldWriter","field","display","displayValue","getHeaderLine","key","isType","name","newline","getLocaleDelimiter","arr","toLocaleString","charAt","toCSV","encoding","headerStyle","useExcelHeader","series","full","values","writers","map","get"],"sources":["/home/soula/grafana/packages/grafana-data/src/utils/csv.ts"],"sourcesContent":["// Libraries\nimport { defaults } from 'lodash';\nimport Papa, { ParseConfig, Parser, ParseResult } from 'papaparse';\n\n// Types\nimport { MutableDataFrame } from '../dataframe/MutableDataFrame';\nimport { guessFieldTypeFromValue } from '../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../field';\nimport { DataFrame, Field, FieldConfig, FieldType } from '../types';\nimport { formattedValueToString } from '../valueFormats';\n\nexport enum CSVHeaderStyle {\n  full,\n  name,\n  none,\n}\n\n// Subset of all parse options\nexport interface CSVConfig {\n  delimiter?: string; // default: \",\"\n  newline?: string; // default: \"\\r\\n\"\n  quoteChar?: string; // default: '\"'\n  encoding?: string; // default: \"\",\n  useExcelHeader?: boolean; // default: false\n  headerStyle?: CSVHeaderStyle;\n}\n\nexport interface CSVParseCallbacks {\n  /**\n   * Get a callback before any rows are processed\n   * This can return a modified table to force any\n   * Column configurations\n   */\n  onHeader: (fields: Field[]) => void;\n\n  // Called after each row is read\n  onRow: (row: any[]) => void;\n}\n\nexport interface CSVOptions {\n  config?: CSVConfig;\n  callback?: CSVParseCallbacks;\n}\n\nexport function readCSV(csv: string, options?: CSVOptions): DataFrame[] {\n  return new CSVReader(options).readCSV(csv);\n}\n\nenum ParseState {\n  Starting,\n  InHeader,\n  ReadingRows,\n}\n\nexport class CSVReader {\n  config: CSVConfig;\n  callback?: CSVParseCallbacks;\n\n  state: ParseState;\n  data: MutableDataFrame[];\n  current: MutableDataFrame;\n\n  constructor(options?: CSVOptions) {\n    if (!options) {\n      options = {};\n    }\n    this.config = options.config || {};\n    this.callback = options.callback;\n\n    this.current = new MutableDataFrame({ fields: [] });\n    this.state = ParseState.Starting;\n    this.data = [];\n  }\n\n  // PapaParse callback on each line\n  private chunk = (results: ParseResult<any>, parser: Parser): void => {\n    for (let i = 0; i < results.data.length; i++) {\n      const line: string[] = results.data[i];\n      if (line.length < 1) {\n        continue;\n      }\n      const first = line[0]; // null or value, papaparse does not return ''\n      if (first) {\n        // Comment or header queue\n        if (first.startsWith('#')) {\n          // Look for special header column\n          // #{columkey}#a,b,c\n          const idx = first.indexOf('#', 2);\n          if (idx > 0) {\n            const k = first.slice(1, idx);\n            const isName = 'name' === k;\n\n            // Simple object used to check if headers match\n            const headerKeys: FieldConfig = {\n              unit: '#',\n            };\n\n            // Check if it is a known/supported column\n            if (isName || headerKeys.hasOwnProperty(k)) {\n              // Starting a new table after reading rows\n              if (this.state === ParseState.ReadingRows) {\n                this.current = new MutableDataFrame({ fields: [] });\n                this.data.push(this.current);\n              }\n\n              const v = first.slice(idx + 1);\n              if (isName) {\n                this.current.addFieldFor(undefined, v);\n                for (let j = 1; j < line.length; j++) {\n                  this.current.addFieldFor(undefined, line[j]);\n                }\n              } else {\n                const { fields } = this.current;\n                for (let j = 0; j < fields.length; j++) {\n                  if (!fields[j].config) {\n                    fields[j].config = {};\n                  }\n                  const disp = fields[j].config as any; // any lets name lookup\n                  disp[k] = j === 0 ? v : line[j];\n                }\n              }\n\n              this.state = ParseState.InHeader;\n              continue;\n            }\n          } else if (this.state === ParseState.Starting) {\n            this.state = ParseState.InHeader;\n            continue;\n          }\n          // Ignore comment lines\n          continue;\n        }\n\n        if (this.state === ParseState.Starting) {\n          const type = guessFieldTypeFromValue(first);\n          if (type === FieldType.string) {\n            for (const s of line) {\n              this.current.addFieldFor(undefined, s);\n            }\n            this.state = ParseState.InHeader;\n            continue;\n          }\n          this.state = ParseState.InHeader; // fall through to read rows\n        }\n      }\n\n      // Add the current results to the data\n      if (this.state !== ParseState.ReadingRows) {\n        // anything???\n      }\n\n      this.state = ParseState.ReadingRows;\n\n      // Make sure column structure is valid\n      if (line.length > this.current.fields.length) {\n        const { fields } = this.current;\n        for (let f = fields.length; f < line.length; f++) {\n          this.current.addFieldFor(line[f]);\n        }\n        if (this.callback) {\n          this.callback.onHeader(this.current.fields);\n        }\n      }\n\n      this.current.appendRow(line);\n      if (this.callback) {\n        // // Send the header after we guess the type\n        // if (this.series.rows.length === 0) {\n        //   this.callback.onHeader(this.series);\n        // }\n        this.callback.onRow(line);\n      }\n    }\n  };\n\n  readCSV(text: string): MutableDataFrame[] {\n    this.current = new MutableDataFrame({ fields: [] });\n    this.data = [this.current];\n\n    const papacfg = {\n      ...this.config,\n      dynamicTyping: false,\n      skipEmptyLines: true,\n      comments: false, // Keep comment lines\n      chunk: this.chunk,\n    } as ParseConfig;\n\n    Papa.parse(text, papacfg);\n\n    return this.data;\n  }\n}\n\ntype FieldWriter = (value: any) => string;\n\nfunction writeValue(value: any, config: CSVConfig): string {\n  const str = value.toString();\n  if (str.includes('\"')) {\n    // Escape the double quote characters\n    return config.quoteChar + str.replace(/\"/gi, '\"\"') + config.quoteChar;\n  }\n  if (str.includes('\\n') || str.includes(config.delimiter)) {\n    return config.quoteChar + str + config.quoteChar;\n  }\n  return str;\n}\n\nfunction makeFieldWriter(field: Field, config: CSVConfig): FieldWriter {\n  if (field.display) {\n    return (value: any) => {\n      const displayValue = field.display!(value);\n      return writeValue(formattedValueToString(displayValue), config);\n    };\n  }\n\n  return (value: any) => writeValue(value, config);\n}\n\nfunction getHeaderLine(key: string, fields: Field[], config: CSVConfig): string {\n  const isName = 'name' === key;\n  const isType = 'type' === key;\n\n  for (const f of fields) {\n    const display = f.config;\n    if (isName || isType || (display && display.hasOwnProperty(key))) {\n      let line = '#' + key + '#';\n      for (let i = 0; i < fields.length; i++) {\n        if (i > 0) {\n          line = line + config.delimiter;\n        }\n\n        let v: any = fields[i].name;\n        if (isType) {\n          v = fields[i].type;\n        } else if (isName) {\n          // already name\n        } else {\n          v = (fields[i].config as any)[key];\n        }\n        if (v) {\n          line = line + writeValue(v, config);\n        }\n      }\n      return line + config.newline;\n    }\n  }\n  return '';\n}\n\nfunction getLocaleDelimiter(): string {\n  const arr = ['x', 'y'];\n  if (arr.toLocaleString) {\n    return arr.toLocaleString().charAt(1);\n  }\n  return ',';\n}\n\nexport function toCSV(data: DataFrame[], config?: CSVConfig): string {\n  if (!data) {\n    return '';\n  }\n\n  config = defaults(config, {\n    delimiter: getLocaleDelimiter(),\n    newline: '\\r\\n',\n    quoteChar: '\"',\n    encoding: '',\n    headerStyle: CSVHeaderStyle.name,\n    useExcelHeader: false,\n  });\n  let csv = config.useExcelHeader ? `sep=${config.delimiter}${config.newline}` : '';\n\n  for (const series of data) {\n    const { fields } = series;\n\n    // ignore frames with no fields\n    if (fields.length === 0) {\n      continue;\n    }\n\n    if (config.headerStyle === CSVHeaderStyle.full) {\n      csv =\n        csv +\n        getHeaderLine('name', fields, config) +\n        getHeaderLine('type', fields, config) +\n        getHeaderLine('unit', fields, config) +\n        getHeaderLine('dateFormat', fields, config);\n    } else if (config.headerStyle === CSVHeaderStyle.name) {\n      for (let i = 0; i < fields.length; i++) {\n        if (i > 0) {\n          csv += config.delimiter;\n        }\n        csv += `\"${getFieldDisplayName(fields[i], series).replace(/\"/g, '\"\"')}\"`;\n      }\n      csv += config.newline;\n    }\n\n    const length = fields[0].values.length;\n\n    if (length > 0) {\n      const writers = fields.map((field) => makeFieldWriter(field, config!));\n      for (let i = 0; i < length; i++) {\n        for (let j = 0; j < fields.length; j++) {\n          if (j > 0) {\n            csv = csv + config.delimiter;\n          }\n\n          const v = fields[j].values.get(i);\n          if (v !== null) {\n            csv = csv + writers[j](v);\n          }\n        }\n        csv = csv + config.newline;\n      }\n    }\n    csv = csv + config.newline;\n  }\n\n  return csv;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}