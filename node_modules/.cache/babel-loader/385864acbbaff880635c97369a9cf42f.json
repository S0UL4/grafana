{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { once, chain, difference } from 'lodash';\nimport LRU from 'lru-cache';\nimport Prism from 'prismjs';\nimport { AbstractLabelOperator, dateTime, LanguageProvider } from '@grafana/data';\nimport { SearchFunctionType } from '@grafana/ui';\nimport { addLimitInfo, extractLabelMatchers, fixSummariesMetadata, parseSelector, processHistogramMetrics, processLabels, roundSecToMin, toPromLikeQuery } from './language_utils';\nimport PromqlSyntax, { FUNCTIONS, RATE_RANGES } from './promql';\nconst DEFAULT_KEYS = ['job', 'instance'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 5;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\n// Max number of items (metrics, labels, values) that we display as suggestions. Prevents from running out of memory.\n\nexport const SUGGESTIONS_LIMIT = 10000;\n\nconst wrapLabel = label => ({\n  label\n});\n\nconst setFunctionKind = suggestion => {\n  suggestion.kind = 'function';\n  return suggestion;\n};\n\nexport function addHistoryMetadata(item, history) {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);\n  const count = historyForItem.length;\n  const recent = historyForItem[0];\n  let hint = `Queried ${count} times in the last 24h.`;\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return Object.assign({}, item, {\n    documentation: hint\n  });\n}\n\nfunction addMetricsMetadata(metric, metadata) {\n  const item = {\n    label: metric\n  };\n\n  if (metadata && metadata[metric]) {\n    item.documentation = getMetadataString(metric, metadata);\n  }\n\n  return item;\n}\n\nexport function getMetadataString(metric, metadata) {\n  if (!metadata[metric]) {\n    return undefined;\n  }\n\n  const {\n    type,\n    help\n  } = metadata[metric];\n  return `${type.toUpperCase()}: ${help}`;\n}\nconst PREFIX_DELIMITER_REGEX = /(=\"|!=\"|=~\"|!~\"|\\{|\\[|\\(|\\+|-|\\/|\\*|%|\\^|\\band\\b|\\bor\\b|\\bunless\\b|==|>=|!=|<=|>|<|=|~|,)/;\nexport default class PromQlLanguageProvider extends LanguageProvider {\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  constructor(datasource, initialValues) {\n    super();\n\n    _defineProperty(this, \"histogramMetrics\", void 0);\n\n    _defineProperty(this, \"timeRange\", void 0);\n\n    _defineProperty(this, \"metrics\", void 0);\n\n    _defineProperty(this, \"metricsMetadata\", void 0);\n\n    _defineProperty(this, \"datasource\", void 0);\n\n    _defineProperty(this, \"labelKeys\", []);\n\n    _defineProperty(this, \"labelsCache\", new LRU({\n      max: 10\n    }));\n\n    _defineProperty(this, \"request\", async (url, defaultValue, params = {}) => {\n      try {\n        const res = await this.datasource.metadataRequest(url, params);\n        return res.data.data;\n      } catch (error) {\n        console.error(error);\n      }\n\n      return defaultValue;\n    });\n\n    _defineProperty(this, \"start\", async () => {\n      if (this.datasource.lookupsDisabled) {\n        return [];\n      } // TODO #33976: make those requests parallel\n\n\n      await this.fetchLabels();\n      this.metrics = (await this.fetchLabelValues('__name__')) || [];\n      await this.loadMetricsMetadata();\n      this.histogramMetrics = processHistogramMetrics(this.metrics).sort();\n      return [];\n    });\n\n    _defineProperty(this, \"provideCompletionItems\", async ({\n      prefix,\n      text,\n      value,\n      labelKey,\n      wrapperClasses\n    }, context = {}) => {\n      const emptyResult = {\n        suggestions: []\n      };\n\n      if (!value) {\n        return emptyResult;\n      } // Local text properties\n\n\n      const empty = value.document.text.length === 0;\n      const selectedLines = value.document.getTextsAtRange(value.selection);\n      const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n      const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null; // Syntax spans have 3 classes by default. More indicate a recognized token\n\n      const tokenRecognized = wrapperClasses.length > 3; // Non-empty prefix, but not inside known token\n\n      const prefixUnrecognized = prefix && !tokenRecognized; // Prevent suggestions in `function(|suffix)`\n\n      const noSuffix = !nextCharacter || nextCharacter === ')'; // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n\n      const safePrefix = prefix && !text.match(/^[\\]})\\s]+$/) && noSuffix; // About to type next operand if preceded by binary operator\n\n      const operatorsPattern = /[+\\-*/^%]/;\n      const isNextOperand = text.match(operatorsPattern); // Determine candidates by CSS context\n\n      if (wrapperClasses.includes('context-range')) {\n        // Suggestions for metric[|]\n        return this.getRangeCompletionItems();\n      } else if (wrapperClasses.includes('context-labels')) {\n        // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}\n        return this.getLabelCompletionItems({\n          prefix,\n          text,\n          value,\n          labelKey,\n          wrapperClasses\n        });\n      } else if (wrapperClasses.includes('context-aggregation')) {\n        // Suggestions for sum(metric) by (|)\n        return this.getAggregationCompletionItems(value);\n      } else if (empty) {\n        // Suggestions for empty query field\n        return this.getEmptyCompletionItems(context);\n      } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n        // Show term suggestions in a couple of scenarios\n        return this.getBeginningCompletionItems(context);\n      } else if (prefixUnrecognized && safePrefix) {\n        // Show term suggestions in a couple of scenarios\n        return this.getTermCompletionItems();\n      }\n\n      return emptyResult;\n    });\n\n    _defineProperty(this, \"getBeginningCompletionItems\", context => {\n      return {\n        suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions]\n      };\n    });\n\n    _defineProperty(this, \"getEmptyCompletionItems\", context => {\n      const {\n        history\n      } = context;\n      const suggestions = [];\n\n      if (history && history.length) {\n        const historyItems = chain(history).map(h => h.query.expr).filter().uniq().take(HISTORY_ITEM_COUNT).map(wrapLabel).map(item => addHistoryMetadata(item, history)).value();\n        suggestions.push({\n          searchFunctionType: SearchFunctionType.Prefix,\n          skipSort: true,\n          label: 'History',\n          items: historyItems\n        });\n      }\n\n      return {\n        suggestions\n      };\n    });\n\n    _defineProperty(this, \"getTermCompletionItems\", () => {\n      const {\n        metrics,\n        metricsMetadata\n      } = this;\n      const suggestions = [];\n      suggestions.push({\n        searchFunctionType: SearchFunctionType.Prefix,\n        label: 'Functions',\n        items: FUNCTIONS.map(setFunctionKind)\n      });\n\n      if (metrics && metrics.length) {\n        suggestions.push({\n          label: 'Metrics',\n          items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),\n          searchFunctionType: SearchFunctionType.Fuzzy\n        });\n      }\n\n      return {\n        suggestions\n      };\n    });\n\n    _defineProperty(this, \"getAggregationCompletionItems\", async value => {\n      const suggestions = []; // Stitch all query lines together to support multi-line queries\n\n      let queryOffset;\n      const queryText = value.document.getBlocks().reduce((text, block) => {\n        if (text === undefined) {\n          return '';\n        }\n\n        if (!block) {\n          return text;\n        }\n\n        const blockText = block === null || block === void 0 ? void 0 : block.getText();\n\n        if (value.anchorBlock.key === block.key) {\n          // Newline characters are not accounted for but this is irrelevant\n          // for the purpose of extracting the selector string\n          queryOffset = value.selection.anchor.offset + text.length;\n        }\n\n        return text + blockText;\n      }, ''); // Try search for selector part on the left-hand side, such as `sum (m) by (l)`\n\n      const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);\n      let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);\n      let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex); // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`\n\n      if (openParensSelectorIndex === -1) {\n        const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);\n        closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);\n        openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);\n      }\n\n      const result = {\n        suggestions,\n        context: 'context-aggregation'\n      }; // Suggestions are useless for alternative aggregation clauses without a selector in context\n\n      if (openParensSelectorIndex === -1) {\n        return result;\n      } // Range vector syntax not accounted for by subsequent parse so discard it if present\n\n\n      const selectorString = queryText.slice(openParensSelectorIndex + 1, closeParensSelectorIndex).replace(/\\[[^\\]]+\\]$/, '');\n      const selector = parseSelector(selectorString, selectorString.length - 2).selector;\n      const series = await this.getSeries(selector);\n      const labelKeys = Object.keys(series);\n\n      if (labelKeys.length > 0) {\n        const limitInfo = addLimitInfo(labelKeys);\n        suggestions.push({\n          label: `Labels${limitInfo}`,\n          items: labelKeys.map(wrapLabel),\n          searchFunctionType: SearchFunctionType.Fuzzy\n        });\n      }\n\n      return result;\n    });\n\n    _defineProperty(this, \"getLabelCompletionItems\", async ({\n      text,\n      wrapperClasses,\n      labelKey,\n      value\n    }) => {\n      if (!value) {\n        return {\n          suggestions: []\n        };\n      }\n\n      const suggestions = [];\n      const line = value.anchorBlock.getText();\n      const cursorOffset = value.selection.anchor.offset;\n      const suffix = line.substr(cursorOffset);\n      const prefix = line.substr(0, cursorOffset);\n      const isValueStart = text.match(/^(=|=~|!=|!~)/);\n      const isValueEnd = suffix.match(/^\"?[,}]|$/); // Detect cursor in front of value, e.g., {key=|\"}\n\n      const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^\"/); // Don't suggest anything at the beginning or inside a value\n\n      const isValueEmpty = isValueStart && isValueEnd;\n      const hasValuePrefix = isValueEnd && !isValueStart;\n\n      if (!isValueEmpty && !hasValuePrefix || isPreValue) {\n        return {\n          suggestions\n        };\n      } // Get normalized selector\n\n\n      let selector;\n      let parsedSelector;\n\n      try {\n        parsedSelector = parseSelector(line, cursorOffset);\n        selector = parsedSelector.selector;\n      } catch {\n        selector = EMPTY_SELECTOR;\n      }\n\n      const containsMetric = selector.includes('__name__=');\n      const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n      let series = {}; // Query labels for selector\n\n      if (selector) {\n        series = await this.getSeries(selector, !containsMetric);\n      }\n\n      if (Object.keys(series).length === 0) {\n        console.warn(`Server did not return any values for selector = ${selector}`);\n        return {\n          suggestions\n        };\n      }\n\n      let context;\n\n      if (text && isValueStart || wrapperClasses.includes('attr-value')) {\n        // Label values\n        if (labelKey && series[labelKey]) {\n          context = 'context-label-values';\n          const limitInfo = addLimitInfo(series[labelKey]);\n          suggestions.push({\n            label: `Label values for \"${labelKey}\"${limitInfo}`,\n            items: series[labelKey].map(wrapLabel),\n            searchFunctionType: SearchFunctionType.Fuzzy\n          });\n        }\n      } else {\n        // Label keys\n        const labelKeys = series ? Object.keys(series) : containsMetric ? null : DEFAULT_KEYS;\n\n        if (labelKeys) {\n          const possibleKeys = difference(labelKeys, existingKeys);\n\n          if (possibleKeys.length) {\n            context = 'context-labels';\n            const newItems = possibleKeys.map(key => ({\n              label: key\n            }));\n            const limitInfo = addLimitInfo(newItems);\n            const newSuggestion = {\n              label: `Labels${limitInfo}`,\n              items: newItems,\n              searchFunctionType: SearchFunctionType.Fuzzy\n            };\n            suggestions.push(newSuggestion);\n          }\n        }\n      }\n\n      return {\n        context,\n        suggestions\n      };\n    });\n\n    _defineProperty(this, \"fetchLabelValues\", async key => {\n      const params = this.datasource.getTimeRangeParams();\n      const url = `/api/v1/label/${this.datasource.interpolateString(key)}/values`;\n      return await this.request(url, [], params);\n    });\n\n    _defineProperty(this, \"fetchSeriesLabels\", async (name, withName) => {\n      const interpolatedName = this.datasource.interpolateString(name);\n      const range = this.datasource.getTimeRangeParams();\n      const urlParams = Object.assign({}, range, {\n        'match[]': interpolatedName\n      });\n      const url = `/api/v1/series`; // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.\n      // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n      // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n      // when user does not the newest values for a minute if already cached.\n\n      const cacheParams = new URLSearchParams({\n        'match[]': interpolatedName,\n        start: roundSecToMin(parseInt(range.start, 10)).toString(),\n        end: roundSecToMin(parseInt(range.end, 10)).toString(),\n        withName: withName ? 'true' : 'false'\n      });\n      const cacheKey = `/api/v1/series?${cacheParams.toString()}`;\n      let value = this.labelsCache.get(cacheKey);\n\n      if (!value) {\n        const data = await this.request(url, [], urlParams);\n        const {\n          values\n        } = processLabels(data, withName);\n        value = values;\n        this.labelsCache.set(cacheKey, value);\n      }\n\n      return value;\n    });\n\n    _defineProperty(this, \"fetchSeries\", async match => {\n      const url = '/api/v1/series';\n      const range = this.datasource.getTimeRangeParams();\n      const params = Object.assign({}, range, {\n        'match[]': match\n      });\n      return await this.request(url, {}, params);\n    });\n\n    _defineProperty(this, \"fetchDefaultSeries\", once(async () => {\n      const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));\n      return DEFAULT_KEYS.reduce((acc, key, i) => Object.assign({}, acc, {\n        [key]: values[i]\n      }), {});\n    }));\n\n    this.datasource = datasource;\n    this.histogramMetrics = [];\n    this.timeRange = {\n      start: 0,\n      end: 0\n    };\n    this.metrics = [];\n    Object.assign(this, initialValues);\n  } // Strip syntax chars so that typeahead suggestions can work on clean inputs\n\n\n  cleanText(s) {\n    const parts = s.split(PREFIX_DELIMITER_REGEX);\n    const last = parts.pop();\n    return last.trimLeft().replace(/\"$/, '').replace(/^\"/, '');\n  }\n\n  get syntax() {\n    return PromqlSyntax;\n  }\n\n  async loadMetricsMetadata() {\n    this.metricsMetadata = fixSummariesMetadata(await this.request('/api/v1/metadata', {}));\n  }\n\n  getLabelKeys() {\n    return this.labelKeys;\n  }\n\n  getRangeCompletionItems() {\n    return {\n      context: 'context-range',\n      suggestions: [{\n        label: 'Range vector',\n        items: [...RATE_RANGES]\n      }]\n    };\n  }\n\n  importFromAbstractQuery(labelBasedQuery) {\n    return toPromLikeQuery(labelBasedQuery);\n  }\n\n  exportToAbstractQuery(query) {\n    const promQuery = query.expr;\n\n    if (!promQuery || promQuery.length === 0) {\n      return {\n        refId: query.refId,\n        labelMatchers: []\n      };\n    }\n\n    const tokens = Prism.tokenize(promQuery, PromqlSyntax);\n    const labelMatchers = extractLabelMatchers(tokens);\n    const nameLabelValue = getNameLabelValue(promQuery, tokens);\n\n    if (nameLabelValue && nameLabelValue.length > 0) {\n      labelMatchers.push({\n        name: '__name__',\n        operator: AbstractLabelOperator.Equal,\n        value: nameLabelValue\n      });\n    }\n\n    return {\n      refId: query.refId,\n      labelMatchers\n    };\n  }\n\n  async getSeries(selector, withName) {\n    if (this.datasource.lookupsDisabled) {\n      return {};\n    }\n\n    try {\n      if (selector === EMPTY_SELECTOR) {\n        return await this.fetchDefaultSeries();\n      } else {\n        return await this.fetchSeriesLabels(selector, withName);\n      }\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return {};\n    }\n  }\n\n  async getLabelValues(key) {\n    return await this.fetchLabelValues(key);\n  }\n  /**\n   * Fetches all label keys\n   */\n\n\n  async fetchLabels() {\n    const url = '/api/v1/labels';\n    const params = this.datasource.getTimeRangeParams();\n    this.labelFetchTs = Date.now().valueOf();\n    const res = await this.request(url, [], params);\n\n    if (Array.isArray(res)) {\n      this.labelKeys = res.slice().sort();\n    }\n\n    return [];\n  }\n  /**\n   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   * @param withName\n   */\n\n\n}\n\nfunction getNameLabelValue(promQuery, tokens) {\n  let nameLabelValue = '';\n\n  for (let prop in tokens) {\n    if (typeof tokens[prop] === 'string') {\n      nameLabelValue = tokens[prop];\n      break;\n    }\n  }\n\n  return nameLabelValue;\n}","map":{"version":3,"names":["once","chain","difference","LRU","Prism","AbstractLabelOperator","dateTime","LanguageProvider","SearchFunctionType","addLimitInfo","extractLabelMatchers","fixSummariesMetadata","parseSelector","processHistogramMetrics","processLabels","roundSecToMin","toPromLikeQuery","PromqlSyntax","FUNCTIONS","RATE_RANGES","DEFAULT_KEYS","EMPTY_SELECTOR","HISTORY_ITEM_COUNT","HISTORY_COUNT_CUTOFF","SUGGESTIONS_LIMIT","wrapLabel","label","setFunctionKind","suggestion","kind","addHistoryMetadata","item","history","cutoffTs","Date","now","historyForItem","filter","h","ts","query","count","length","recent","hint","lastQueried","fromNow","documentation","addMetricsMetadata","metric","metadata","getMetadataString","undefined","type","help","toUpperCase","PREFIX_DELIMITER_REGEX","PromQlLanguageProvider","constructor","datasource","initialValues","max","url","defaultValue","params","res","metadataRequest","data","error","console","lookupsDisabled","fetchLabels","metrics","fetchLabelValues","loadMetricsMetadata","histogramMetrics","sort","prefix","text","value","labelKey","wrapperClasses","context","emptyResult","suggestions","empty","document","selectedLines","getTextsAtRange","selection","currentLine","size","first","getText","nextCharacter","anchor","offset","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","match","operatorsPattern","isNextOperand","includes","getRangeCompletionItems","getLabelCompletionItems","getAggregationCompletionItems","getEmptyCompletionItems","getBeginningCompletionItems","getTermCompletionItems","historyItems","map","expr","uniq","take","push","searchFunctionType","Prefix","skipSort","items","metricsMetadata","m","Fuzzy","queryOffset","queryText","getBlocks","reduce","block","blockText","anchorBlock","key","openParensAggregationIndex","lastIndexOf","openParensSelectorIndex","closeParensSelectorIndex","indexOf","closeParensAggregationIndex","result","selectorString","slice","replace","selector","series","getSeries","labelKeys","Object","keys","limitInfo","line","cursorOffset","suffix","substr","isValueStart","isValueEnd","isPreValue","isValueEmpty","hasValuePrefix","parsedSelector","containsMetric","existingKeys","warn","possibleKeys","newItems","newSuggestion","getTimeRangeParams","interpolateString","request","name","withName","interpolatedName","range","urlParams","cacheParams","URLSearchParams","start","parseInt","toString","end","cacheKey","labelsCache","get","values","set","Promise","all","acc","i","timeRange","assign","cleanText","s","parts","split","last","pop","trimLeft","syntax","getLabelKeys","importFromAbstractQuery","labelBasedQuery","exportToAbstractQuery","promQuery","refId","labelMatchers","tokens","tokenize","nameLabelValue","getNameLabelValue","operator","Equal","fetchDefaultSeries","fetchSeriesLabels","getLabelValues","labelFetchTs","valueOf","Array","isArray","prop"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/language_provider.ts"],"sourcesContent":["import { once, chain, difference } from 'lodash';\nimport LRU from 'lru-cache';\nimport Prism from 'prismjs';\nimport { Value } from 'slate';\n\nimport {\n  AbstractLabelMatcher,\n  AbstractLabelOperator,\n  AbstractQuery,\n  dateTime,\n  HistoryItem,\n  LanguageProvider,\n} from '@grafana/data';\nimport { CompletionItem, CompletionItemGroup, SearchFunctionType, TypeaheadInput, TypeaheadOutput } from '@grafana/ui';\n\nimport { PrometheusDatasource } from './datasource';\nimport {\n  addLimitInfo,\n  extractLabelMatchers,\n  fixSummariesMetadata,\n  parseSelector,\n  processHistogramMetrics,\n  processLabels,\n  roundSecToMin,\n  toPromLikeQuery,\n} from './language_utils';\nimport PromqlSyntax, { FUNCTIONS, RATE_RANGES } from './promql';\nimport { PromMetricsMetadata, PromQuery } from './types';\n\nconst DEFAULT_KEYS = ['job', 'instance'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 5;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\n// Max number of items (metrics, labels, values) that we display as suggestions. Prevents from running out of memory.\nexport const SUGGESTIONS_LIMIT = 10000;\n\nconst wrapLabel = (label: string): CompletionItem => ({ label });\n\nconst setFunctionKind = (suggestion: CompletionItem): CompletionItem => {\n  suggestion.kind = 'function';\n  return suggestion;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: any[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter((h) => h.ts > cutoffTs && h.query === item.label);\n  const count = historyForItem.length;\n  const recent = historyForItem[0];\n  let hint = `Queried ${count} times in the last 24h.`;\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CompletionItem {\n  const item: CompletionItem = { label: metric };\n  if (metadata && metadata[metric]) {\n    item.documentation = getMetadataString(metric, metadata);\n  }\n  return item;\n}\n\nexport function getMetadataString(metric: string, metadata: PromMetricsMetadata): string | undefined {\n  if (!metadata[metric]) {\n    return undefined;\n  }\n  const { type, help } = metadata[metric];\n  return `${type.toUpperCase()}: ${help}`;\n}\n\nconst PREFIX_DELIMITER_REGEX =\n  /(=\"|!=\"|=~\"|!~\"|\\{|\\[|\\(|\\+|-|\\/|\\*|%|\\^|\\band\\b|\\bor\\b|\\bunless\\b|==|>=|!=|<=|>|<|=|~|,)/;\n\ninterface AutocompleteContext {\n  history?: Array<HistoryItem<PromQuery>>;\n}\nexport default class PromQlLanguageProvider extends LanguageProvider {\n  histogramMetrics: string[];\n  timeRange?: { start: number; end: number };\n  metrics: string[];\n  metricsMetadata?: PromMetricsMetadata;\n  declare startTask: Promise<any>;\n  datasource: PrometheusDatasource;\n  labelKeys: string[] = [];\n  declare labelFetchTs: number;\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private labelsCache = new LRU<string, Record<string, string[]>>({ max: 10 });\n\n  constructor(datasource: PrometheusDatasource, initialValues?: Partial<PromQlLanguageProvider>) {\n    super();\n\n    this.datasource = datasource;\n    this.histogramMetrics = [];\n    this.timeRange = { start: 0, end: 0 };\n    this.metrics = [];\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars so that typeahead suggestions can work on clean inputs\n  cleanText(s: string) {\n    const parts = s.split(PREFIX_DELIMITER_REGEX);\n    const last = parts.pop()!;\n    return last.trimLeft().replace(/\"$/, '').replace(/^\"/, '');\n  }\n\n  get syntax() {\n    return PromqlSyntax;\n  }\n\n  request = async (url: string, defaultValue: any, params = {}): Promise<any> => {\n    try {\n      const res = await this.datasource.metadataRequest(url, params);\n      return res.data.data;\n    } catch (error) {\n      console.error(error);\n    }\n\n    return defaultValue;\n  };\n\n  start = async (): Promise<any[]> => {\n    if (this.datasource.lookupsDisabled) {\n      return [];\n    }\n\n    // TODO #33976: make those requests parallel\n    await this.fetchLabels();\n    this.metrics = (await this.fetchLabelValues('__name__')) || [];\n    await this.loadMetricsMetadata();\n    this.histogramMetrics = processHistogramMetrics(this.metrics).sort();\n    return [];\n  };\n\n  async loadMetricsMetadata() {\n    this.metricsMetadata = fixSummariesMetadata(await this.request('/api/v1/metadata', {}));\n  }\n\n  getLabelKeys(): string[] {\n    return this.labelKeys;\n  }\n\n  provideCompletionItems = async (\n    { prefix, text, value, labelKey, wrapperClasses }: TypeaheadInput,\n    context: AutocompleteContext = {}\n  ): Promise<TypeaheadOutput> => {\n    const emptyResult: TypeaheadOutput = { suggestions: [] };\n\n    if (!value) {\n      return emptyResult;\n    }\n\n    // Local text properties\n    const empty = value.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^[\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}\n      return this.getLabelCompletionItems({ prefix, text, value, labelKey, wrapperClasses });\n    } else if (wrapperClasses.includes('context-aggregation')) {\n      // Suggestions for sum(metric) by (|)\n      return this.getAggregationCompletionItems(value);\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  };\n\n  getBeginningCompletionItems = (context: AutocompleteContext): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems = (context: AutocompleteContext): TypeaheadOutput => {\n    const { history } = context;\n    const suggestions: CompletionItemGroup[] = [];\n\n    if (history && history.length) {\n      const historyItems = chain(history)\n        .map((h) => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        searchFunctionType: SearchFunctionType.Prefix,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const { metrics, metricsMetadata } = this;\n    const suggestions: CompletionItemGroup[] = [];\n\n    suggestions.push({\n      searchFunctionType: SearchFunctionType.Prefix,\n      label: 'Functions',\n      items: FUNCTIONS.map(setFunctionKind),\n    });\n\n    if (metrics && metrics.length) {\n      suggestions.push({\n        label: 'Metrics',\n        items: metrics.map((m) => addMetricsMetadata(m, metricsMetadata)),\n        searchFunctionType: SearchFunctionType.Fuzzy,\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  getAggregationCompletionItems = async (value: Value): Promise<TypeaheadOutput> => {\n    const suggestions: CompletionItemGroup[] = [];\n\n    // Stitch all query lines together to support multi-line queries\n    let queryOffset;\n    const queryText = value.document.getBlocks().reduce((text, block) => {\n      if (text === undefined) {\n        return '';\n      }\n      if (!block) {\n        return text;\n      }\n\n      const blockText = block?.getText();\n\n      if (value.anchorBlock.key === block.key) {\n        // Newline characters are not accounted for but this is irrelevant\n        // for the purpose of extracting the selector string\n        queryOffset = value.selection.anchor.offset + text.length;\n      }\n\n      return text + blockText;\n    }, '');\n\n    // Try search for selector part on the left-hand side, such as `sum (m) by (l)`\n    const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);\n    let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);\n    let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex);\n\n    // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`\n    if (openParensSelectorIndex === -1) {\n      const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);\n      closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);\n      openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);\n    }\n\n    const result = {\n      suggestions,\n      context: 'context-aggregation',\n    };\n\n    // Suggestions are useless for alternative aggregation clauses without a selector in context\n    if (openParensSelectorIndex === -1) {\n      return result;\n    }\n\n    // Range vector syntax not accounted for by subsequent parse so discard it if present\n    const selectorString = queryText\n      .slice(openParensSelectorIndex + 1, closeParensSelectorIndex)\n      .replace(/\\[[^\\]]+\\]$/, '');\n\n    const selector = parseSelector(selectorString, selectorString.length - 2).selector;\n\n    const series = await this.getSeries(selector);\n    const labelKeys = Object.keys(series);\n    if (labelKeys.length > 0) {\n      const limitInfo = addLimitInfo(labelKeys);\n      suggestions.push({\n        label: `Labels${limitInfo}`,\n        items: labelKeys.map(wrapLabel),\n        searchFunctionType: SearchFunctionType.Fuzzy,\n      });\n    }\n    return result;\n  };\n\n  getLabelCompletionItems = async ({\n    text,\n    wrapperClasses,\n    labelKey,\n    value,\n  }: TypeaheadInput): Promise<TypeaheadOutput> => {\n    if (!value) {\n      return { suggestions: [] };\n    }\n\n    const suggestions: CompletionItemGroup[] = [];\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const suffix = line.substr(cursorOffset);\n    const prefix = line.substr(0, cursorOffset);\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n    const isValueEnd = suffix.match(/^\"?[,}]|$/);\n    // Detect cursor in front of value, e.g., {key=|\"}\n    const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^\"/);\n\n    // Don't suggest anything at the beginning or inside a value\n    const isValueEmpty = isValueStart && isValueEnd;\n    const hasValuePrefix = isValueEnd && !isValueStart;\n    if ((!isValueEmpty && !hasValuePrefix) || isPreValue) {\n      return { suggestions };\n    }\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    const containsMetric = selector.includes('__name__=');\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let series: Record<string, string[]> = {};\n    // Query labels for selector\n    if (selector) {\n      series = await this.getSeries(selector, !containsMetric);\n    }\n\n    if (Object.keys(series).length === 0) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { suggestions };\n    }\n\n    let context: string | undefined;\n\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && series[labelKey]) {\n        context = 'context-label-values';\n        const limitInfo = addLimitInfo(series[labelKey]);\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"${limitInfo}`,\n          items: series[labelKey].map(wrapLabel),\n          searchFunctionType: SearchFunctionType.Fuzzy,\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = series ? Object.keys(series) : containsMetric ? null : DEFAULT_KEYS;\n\n      if (labelKeys) {\n        const possibleKeys = difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          context = 'context-labels';\n          const newItems = possibleKeys.map((key) => ({ label: key }));\n          const limitInfo = addLimitInfo(newItems);\n          const newSuggestion: CompletionItemGroup = {\n            label: `Labels${limitInfo}`,\n            items: newItems,\n            searchFunctionType: SearchFunctionType.Fuzzy,\n          };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  };\n\n  importFromAbstractQuery(labelBasedQuery: AbstractQuery): PromQuery {\n    return toPromLikeQuery(labelBasedQuery);\n  }\n\n  exportToAbstractQuery(query: PromQuery): AbstractQuery {\n    const promQuery = query.expr;\n    if (!promQuery || promQuery.length === 0) {\n      return { refId: query.refId, labelMatchers: [] };\n    }\n    const tokens = Prism.tokenize(promQuery, PromqlSyntax);\n    const labelMatchers: AbstractLabelMatcher[] = extractLabelMatchers(tokens);\n    const nameLabelValue = getNameLabelValue(promQuery, tokens);\n    if (nameLabelValue && nameLabelValue.length > 0) {\n      labelMatchers.push({\n        name: '__name__',\n        operator: AbstractLabelOperator.Equal,\n        value: nameLabelValue,\n      });\n    }\n\n    return {\n      refId: query.refId,\n      labelMatchers,\n    };\n  }\n\n  async getSeries(selector: string, withName?: boolean): Promise<Record<string, string[]>> {\n    if (this.datasource.lookupsDisabled) {\n      return {};\n    }\n    try {\n      if (selector === EMPTY_SELECTOR) {\n        return await this.fetchDefaultSeries();\n      } else {\n        return await this.fetchSeriesLabels(selector, withName);\n      }\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return {};\n    }\n  }\n\n  fetchLabelValues = async (key: string): Promise<string[]> => {\n    const params = this.datasource.getTimeRangeParams();\n    const url = `/api/v1/label/${this.datasource.interpolateString(key)}/values`;\n    return await this.request(url, [], params);\n  };\n\n  async getLabelValues(key: string): Promise<string[]> {\n    return await this.fetchLabelValues(key);\n  }\n\n  /**\n   * Fetches all label keys\n   */\n  async fetchLabels(): Promise<string[]> {\n    const url = '/api/v1/labels';\n    const params = this.datasource.getTimeRangeParams();\n    this.labelFetchTs = Date.now().valueOf();\n\n    const res = await this.request(url, [], params);\n    if (Array.isArray(res)) {\n      this.labelKeys = res.slice().sort();\n    }\n\n    return [];\n  }\n\n  /**\n   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   * @param withName\n   */\n  fetchSeriesLabels = async (name: string, withName?: boolean): Promise<Record<string, string[]>> => {\n    const interpolatedName = this.datasource.interpolateString(name);\n    const range = this.datasource.getTimeRangeParams();\n    const urlParams = {\n      ...range,\n      'match[]': interpolatedName,\n    };\n    const url = `/api/v1/series`;\n    // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.\n    // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n    // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n    // when user does not the newest values for a minute if already cached.\n    const cacheParams = new URLSearchParams({\n      'match[]': interpolatedName,\n      start: roundSecToMin(parseInt(range.start, 10)).toString(),\n      end: roundSecToMin(parseInt(range.end, 10)).toString(),\n      withName: withName ? 'true' : 'false',\n    });\n\n    const cacheKey = `/api/v1/series?${cacheParams.toString()}`;\n    let value = this.labelsCache.get(cacheKey);\n    if (!value) {\n      const data = await this.request(url, [], urlParams);\n      const { values } = processLabels(data, withName);\n      value = values;\n      this.labelsCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch series for a selector. Use this for raw results. Use fetchSeriesLabels() to get labels.\n   * @param match\n   */\n  fetchSeries = async (match: string): Promise<Array<Record<string, string>>> => {\n    const url = '/api/v1/series';\n    const range = this.datasource.getTimeRangeParams();\n    const params = { ...range, 'match[]': match };\n    return await this.request(url, {}, params);\n  };\n\n  /**\n   * Fetch this only one as we assume this won't change over time. This is cached differently from fetchSeriesLabels\n   * because we can cache more aggressively here and also we do not want to invalidate this cache the same way as in\n   * fetchSeriesLabels.\n   */\n  fetchDefaultSeries = once(async () => {\n    const values = await Promise.all(DEFAULT_KEYS.map((key) => this.fetchLabelValues(key)));\n    return DEFAULT_KEYS.reduce((acc, key, i) => ({ ...acc, [key]: values[i] }), {});\n  });\n}\n\nfunction getNameLabelValue(promQuery: string, tokens: any): string {\n  let nameLabelValue = '';\n  for (let prop in tokens) {\n    if (typeof tokens[prop] === 'string') {\n      nameLabelValue = tokens[prop] as string;\n      break;\n    }\n  }\n  return nameLabelValue;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}