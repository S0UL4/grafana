{"ast":null,"code":"import { createAsyncThunk } from '@reduxjs/toolkit';\nimport { isEmpty } from 'lodash';\nimport { getBackendSrv, locationService } from '@grafana/runtime';\nimport messageFromError from 'app/plugins/datasource/grafana-azure-monitor-datasource/utils/messageFromError';\nimport { PromApplication } from 'app/types/unified-alerting-dto';\nimport { addAlertManagers, createOrUpdateSilence, deleteAlertManagerConfig, expireSilence, fetchAlertGroups, fetchAlertManagerConfig, fetchAlerts, fetchExternalAlertmanagerConfig, fetchExternalAlertmanagers, fetchSilences, fetchStatus, testReceivers, updateAlertManagerConfig } from '../api/alertmanager';\nimport { fetchAnnotations } from '../api/annotations';\nimport { discoverFeatures } from '../api/buildInfo';\nimport { fetchNotifiers } from '../api/grafana';\nimport { fetchRules } from '../api/prometheus';\nimport { deleteNamespace, deleteRulerRulesGroup, fetchRulerRules, setRulerRuleGroup } from '../api/ruler';\nimport { RuleFormType } from '../types/rule-form';\nimport { addDefaultsToAlertmanagerConfig, removeMuteTimingFromRoute } from '../utils/alertmanager';\nimport { getAllRulesSourceNames, getRulesDataSource, getRulesSourceName, GRAFANA_RULES_SOURCE_NAME, isVanillaPrometheusAlertManagerDataSource } from '../utils/datasource';\nimport { makeAMLink, retryWhile } from '../utils/misc';\nimport { withAppEvents, withSerializedError } from '../utils/redux';\nimport * as ruleId from '../utils/rule-id';\nimport { getRulerClient } from '../utils/rulerClient';\nimport { isRulerNotSupportedResponse } from '../utils/rules';\nconst FETCH_CONFIG_RETRY_TIMEOUT = 30 * 1000;\n\nfunction getDataSourceConfig(getState, rulesSourceName) {\n  var _dataSources$rulesSou;\n\n  const dataSources = getState().unifiedAlerting.dataSources;\n  const dsConfig = (_dataSources$rulesSou = dataSources[rulesSourceName]) === null || _dataSources$rulesSou === void 0 ? void 0 : _dataSources$rulesSou.result;\n\n  if (!dsConfig) {\n    throw new Error(`Data source configuration is not available for \"${rulesSourceName}\" data source`);\n  }\n\n  return dsConfig;\n}\n\nfunction getDataSourceRulerConfig(getState, rulesSourceName) {\n  const dsConfig = getDataSourceConfig(getState, rulesSourceName);\n\n  if (!dsConfig.rulerConfig) {\n    throw new Error(`Ruler API is not available for ${rulesSourceName}`);\n  }\n\n  return dsConfig.rulerConfig;\n}\n\nexport const fetchPromRulesAction = createAsyncThunk('unifiedalerting/fetchPromRules', async ({\n  rulesSourceName,\n  filter\n}, thunkAPI) => {\n  await thunkAPI.dispatch(fetchRulesSourceBuildInfoAction({\n    rulesSourceName\n  }));\n  return await withSerializedError(fetchRules(rulesSourceName, filter));\n});\nexport const fetchAlertManagerConfigAction = createAsyncThunk('unifiedalerting/fetchAmConfig', alertManagerSourceName => withSerializedError((async () => {\n  // for vanilla prometheus, there is no config endpoint. Only fetch config from status\n  if (isVanillaPrometheusAlertManagerDataSource(alertManagerSourceName)) {\n    return fetchStatus(alertManagerSourceName).then(status => ({\n      alertmanager_config: status.config,\n      template_files: {}\n    }));\n  }\n\n  return retryWhile(() => fetchAlertManagerConfig(alertManagerSourceName), // if config has been recently deleted, it takes a while for cortex start returning the default one.\n  // retry for a short while instead of failing\n  e => {\n    var _messageFromError;\n\n    return !!((_messageFromError = messageFromError(e)) !== null && _messageFromError !== void 0 && _messageFromError.includes('alertmanager storage object not found'));\n  }, FETCH_CONFIG_RETRY_TIMEOUT).then(result => {\n    // if user config is empty for cortex alertmanager, try to get config from status endpoint\n    if (isEmpty(result.alertmanager_config) && isEmpty(result.template_files) && alertManagerSourceName !== GRAFANA_RULES_SOURCE_NAME) {\n      return fetchStatus(alertManagerSourceName).then(status => ({\n        alertmanager_config: status.config,\n        template_files: {},\n        template_file_provenances: result.template_file_provenances\n      }));\n    }\n\n    return result;\n  });\n})()));\nexport const fetchExternalAlertmanagersAction = createAsyncThunk('unifiedAlerting/fetchExternalAlertmanagers', () => {\n  return withSerializedError(fetchExternalAlertmanagers());\n});\nexport const fetchExternalAlertmanagersConfigAction = createAsyncThunk('unifiedAlerting/fetchExternAlertmanagersConfig', () => {\n  return withSerializedError(fetchExternalAlertmanagerConfig());\n});\nexport const fetchRulerRulesAction = createAsyncThunk('unifiedalerting/fetchRulerRules', async ({\n  rulesSourceName,\n  filter\n}, {\n  dispatch,\n  getState\n}) => {\n  await dispatch(fetchRulesSourceBuildInfoAction({\n    rulesSourceName\n  }));\n  const rulerConfig = getDataSourceRulerConfig(getState, rulesSourceName);\n  return await withSerializedError(fetchRulerRules(rulerConfig, filter));\n});\nexport function fetchPromAndRulerRulesAction({\n  rulesSourceName\n}) {\n  return async (dispatch, getState) => {\n    await dispatch(fetchRulesSourceBuildInfoAction({\n      rulesSourceName\n    }));\n    const dsConfig = getDataSourceConfig(getState, rulesSourceName);\n    await dispatch(fetchPromRulesAction({\n      rulesSourceName\n    }));\n\n    if (dsConfig.rulerConfig) {\n      await dispatch(fetchRulerRulesAction({\n        rulesSourceName\n      }));\n    }\n  };\n}\nexport const fetchSilencesAction = createAsyncThunk('unifiedalerting/fetchSilences', alertManagerSourceName => {\n  return withSerializedError(fetchSilences(alertManagerSourceName));\n}); // this will only trigger ruler rules fetch if rules are not loaded yet and request is not in flight\n\nexport function fetchRulerRulesIfNotFetchedYet(rulesSourceName) {\n  return (dispatch, getStore) => {\n    const {\n      rulerRules\n    } = getStore().unifiedAlerting;\n    const resp = rulerRules[rulesSourceName];\n\n    if (!(resp !== null && resp !== void 0 && resp.result) && !(resp && isRulerNotSupportedResponse(resp)) && !(resp !== null && resp !== void 0 && resp.loading)) {\n      dispatch(fetchRulerRulesAction({\n        rulesSourceName\n      }));\n    }\n  };\n}\nexport function fetchAllPromBuildInfoAction() {\n  return async dispatch => {\n    const allRequests = getAllRulesSourceNames().map(rulesSourceName => dispatch(fetchRulesSourceBuildInfoAction({\n      rulesSourceName\n    })));\n    await Promise.allSettled(allRequests);\n  };\n}\nexport const fetchRulesSourceBuildInfoAction = createAsyncThunk('unifiedalerting/fetchPromBuildinfo', async ({\n  rulesSourceName\n}) => {\n  return withSerializedError((async () => {\n    if (rulesSourceName === GRAFANA_RULES_SOURCE_NAME) {\n      return {\n        name: GRAFANA_RULES_SOURCE_NAME,\n        id: GRAFANA_RULES_SOURCE_NAME,\n        rulerConfig: {\n          dataSourceName: GRAFANA_RULES_SOURCE_NAME,\n          apiVersion: 'legacy'\n        }\n      };\n    }\n\n    const ds = getRulesDataSource(rulesSourceName);\n\n    if (!ds) {\n      throw new Error(`Missing data source configuration for ${rulesSourceName}`);\n    }\n\n    const {\n      id,\n      name\n    } = ds;\n    const buildInfo = await discoverFeatures(name);\n    const rulerConfig = buildInfo.features.rulerApiEnabled ? {\n      dataSourceName: name,\n      apiVersion: buildInfo.application === PromApplication.Lotex ? 'legacy' : 'config'\n    } : undefined;\n    return {\n      name: name,\n      id: id,\n      rulerConfig\n    };\n  })());\n}, {\n  condition: ({\n    rulesSourceName\n  }, {\n    getState\n  }) => {\n    var _dataSources$rulesSou2;\n\n    const dataSources = getState().unifiedAlerting.dataSources;\n    const hasLoaded = Boolean((_dataSources$rulesSou2 = dataSources[rulesSourceName]) === null || _dataSources$rulesSou2 === void 0 ? void 0 : _dataSources$rulesSou2.result);\n    return !hasLoaded;\n  }\n});\nexport function fetchAllPromAndRulerRulesAction(force = false) {\n  return async (dispatch, getStore) => {\n    await dispatch(fetchAllPromBuildInfoAction());\n    const {\n      promRules,\n      rulerRules,\n      dataSources\n    } = getStore().unifiedAlerting;\n    getAllRulesSourceNames().map(rulesSourceName => {\n      var _promRules$rulesSourc, _rulerRules$rulesSour;\n\n      const dataSourceConfig = dataSources[rulesSourceName].result;\n\n      if (!dataSourceConfig) {\n        return;\n      }\n\n      if (force || !((_promRules$rulesSourc = promRules[rulesSourceName]) !== null && _promRules$rulesSourc !== void 0 && _promRules$rulesSourc.loading)) {\n        dispatch(fetchPromRulesAction({\n          rulesSourceName\n        }));\n      }\n\n      if ((force || !((_rulerRules$rulesSour = rulerRules[rulesSourceName]) !== null && _rulerRules$rulesSour !== void 0 && _rulerRules$rulesSour.loading)) && dataSourceConfig.rulerConfig) {\n        dispatch(fetchRulerRulesAction({\n          rulesSourceName\n        }));\n      }\n    });\n  };\n}\nexport function fetchAllPromRulesAction(force = false) {\n  return async (dispatch, getStore) => {\n    const {\n      promRules\n    } = getStore().unifiedAlerting;\n    getAllRulesSourceNames().map(rulesSourceName => {\n      var _promRules$rulesSourc2;\n\n      if (force || !((_promRules$rulesSourc2 = promRules[rulesSourceName]) !== null && _promRules$rulesSourc2 !== void 0 && _promRules$rulesSourc2.loading)) {\n        dispatch(fetchPromRulesAction({\n          rulesSourceName\n        }));\n      }\n    });\n  };\n}\nexport const fetchEditableRuleAction = createAsyncThunk('unifiedalerting/fetchEditableRule', (ruleIdentifier, thunkAPI) => {\n  const rulerConfig = getDataSourceRulerConfig(thunkAPI.getState, ruleIdentifier.ruleSourceName);\n  return withSerializedError(getRulerClient(rulerConfig).findEditableRule(ruleIdentifier));\n});\nexport function deleteRulesGroupAction(namespace, ruleGroup) {\n  return async (dispatch, getState) => {\n    withAppEvents((async () => {\n      const sourceName = getRulesSourceName(namespace.rulesSource);\n      const rulerConfig = getDataSourceRulerConfig(getState, sourceName);\n      await deleteRulerRulesGroup(rulerConfig, namespace.name, ruleGroup.name);\n      await dispatch(fetchPromAndRulerRulesAction({\n        rulesSourceName: sourceName\n      }));\n    })(), {\n      successMessage: 'Group deleted'\n    });\n  };\n}\nexport function deleteRuleAction(ruleIdentifier, options = {}) {\n  /*\n   * fetch the rules group from backend, delete group if it is found and+\n   * reload ruler rules\n   */\n  return async (dispatch, getState) => {\n    withAppEvents((async () => {\n      const rulerConfig = getDataSourceRulerConfig(getState, ruleIdentifier.ruleSourceName);\n      const rulerClient = getRulerClient(rulerConfig);\n      const ruleWithLocation = await rulerClient.findEditableRule(ruleIdentifier);\n\n      if (!ruleWithLocation) {\n        throw new Error('Rule not found.');\n      }\n\n      await rulerClient.deleteRule(ruleWithLocation); // refetch rules for this rules source\n\n      await dispatch(fetchPromAndRulerRulesAction({\n        rulesSourceName: ruleWithLocation.ruleSourceName\n      }));\n\n      if (options.navigateTo) {\n        locationService.replace(options.navigateTo);\n      }\n    })(), {\n      successMessage: 'Rule deleted.'\n    });\n  };\n}\nexport const saveRuleFormAction = createAsyncThunk('unifiedalerting/saveRuleForm', ({\n  values,\n  existing,\n  redirectOnSave\n}, thunkAPI) => withAppEvents(withSerializedError((async () => {\n  const {\n    type\n  } = values; // TODO getRulerConfig should be smart enough to provide proper rulerClient implementation\n  // For the dataSourceName specified\n  // in case of system (cortex/loki)\n\n  let identifier;\n\n  if (type === RuleFormType.cloudAlerting || type === RuleFormType.cloudRecording) {\n    if (!values.dataSourceName) {\n      throw new Error('The Data source has not been defined.');\n    }\n\n    const rulerConfig = getDataSourceRulerConfig(thunkAPI.getState, values.dataSourceName);\n    const rulerClient = getRulerClient(rulerConfig);\n    identifier = await rulerClient.saveLotexRule(values, existing); // in case of grafana managed\n  } else if (type === RuleFormType.grafana) {\n    const rulerConfig = getDataSourceRulerConfig(thunkAPI.getState, GRAFANA_RULES_SOURCE_NAME);\n    const rulerClient = getRulerClient(rulerConfig);\n    identifier = await rulerClient.saveGrafanaRule(values, existing);\n  } else {\n    throw new Error('Unexpected rule form type');\n  }\n\n  if (redirectOnSave) {\n    locationService.push(redirectOnSave);\n  } else {\n    // if the identifier comes up empty (this happens when Grafana managed rule moves to another namespace or group)\n    const stringifiedIdentifier = ruleId.stringifyIdentifier(identifier);\n\n    if (!stringifiedIdentifier) {\n      locationService.push('/alerting/list');\n      return;\n    } // redirect to edit page\n\n\n    const newLocation = `/alerting/${encodeURIComponent(stringifiedIdentifier)}/edit`;\n\n    if (locationService.getLocation().pathname !== newLocation) {\n      locationService.replace(newLocation);\n    } else {\n      // refresh the details of the current editable rule after saving\n      thunkAPI.dispatch(fetchEditableRuleAction(identifier));\n    }\n  }\n})()), {\n  successMessage: existing ? `Rule \"${values.name}\" updated.` : `Rule \"${values.name}\" saved.`,\n  errorMessage: 'Failed to save rule'\n}));\nexport const fetchGrafanaNotifiersAction = createAsyncThunk('unifiedalerting/fetchGrafanaNotifiers', () => withSerializedError(fetchNotifiers()));\nexport const fetchGrafanaAnnotationsAction = createAsyncThunk('unifiedalerting/fetchGrafanaAnnotations', alertId => withSerializedError(fetchAnnotations(alertId)));\nexport const updateAlertManagerConfigAction = createAsyncThunk('unifiedalerting/updateAMConfig', ({\n  alertManagerSourceName,\n  oldConfig,\n  newConfig,\n  successMessage,\n  redirectPath,\n  refetch\n}, thunkAPI) => withAppEvents(withSerializedError((async () => {\n  const latestConfig = await fetchAlertManagerConfig(alertManagerSourceName);\n\n  if (!(isEmpty(latestConfig.alertmanager_config) && isEmpty(latestConfig.template_files)) && JSON.stringify(latestConfig) !== JSON.stringify(oldConfig)) {\n    throw new Error('It seems configuration has been recently updated. Please reload page and try again to make sure that recent changes are not overwritten.');\n  }\n\n  await updateAlertManagerConfig(alertManagerSourceName, addDefaultsToAlertmanagerConfig(newConfig));\n\n  if (refetch) {\n    await thunkAPI.dispatch(fetchAlertManagerConfigAction(alertManagerSourceName));\n  }\n\n  if (redirectPath) {\n    locationService.push(makeAMLink(redirectPath, alertManagerSourceName));\n  }\n})()), {\n  successMessage\n}));\nexport const fetchAmAlertsAction = createAsyncThunk('unifiedalerting/fetchAmAlerts', alertManagerSourceName => withSerializedError(fetchAlerts(alertManagerSourceName, [], true, true, true)));\nexport const expireSilenceAction = (alertManagerSourceName, silenceId) => {\n  return async dispatch => {\n    await withAppEvents(expireSilence(alertManagerSourceName, silenceId), {\n      successMessage: 'Silence expired.'\n    });\n    dispatch(fetchSilencesAction(alertManagerSourceName));\n    dispatch(fetchAmAlertsAction(alertManagerSourceName));\n  };\n};\nexport const createOrUpdateSilenceAction = createAsyncThunk('unifiedalerting/updateSilence', ({\n  alertManagerSourceName,\n  payload,\n  exitOnSave,\n  successMessage\n}) => withAppEvents(withSerializedError((async () => {\n  await createOrUpdateSilence(alertManagerSourceName, payload);\n\n  if (exitOnSave) {\n    locationService.push('/alerting/silences');\n  }\n})()), {\n  successMessage\n}));\nexport const deleteReceiverAction = (receiverName, alertManagerSourceName) => {\n  return (dispatch, getState) => {\n    var _getState$unifiedAler, _getState$unifiedAler2, _config$alertmanager_;\n\n    const config = (_getState$unifiedAler = getState().unifiedAlerting.amConfigs) === null || _getState$unifiedAler === void 0 ? void 0 : (_getState$unifiedAler2 = _getState$unifiedAler[alertManagerSourceName]) === null || _getState$unifiedAler2 === void 0 ? void 0 : _getState$unifiedAler2.result;\n\n    if (!config) {\n      throw new Error(`Config for ${alertManagerSourceName} not found`);\n    }\n\n    if (!((_config$alertmanager_ = config.alertmanager_config.receivers) !== null && _config$alertmanager_ !== void 0 && _config$alertmanager_.find(receiver => receiver.name === receiverName))) {\n      throw new Error(`Cannot delete receiver ${receiverName}: not found in config.`);\n    }\n\n    const newConfig = Object.assign({}, config, {\n      alertmanager_config: Object.assign({}, config.alertmanager_config, {\n        receivers: config.alertmanager_config.receivers.filter(receiver => receiver.name !== receiverName)\n      })\n    });\n    return dispatch(updateAlertManagerConfigAction({\n      newConfig,\n      oldConfig: config,\n      alertManagerSourceName,\n      successMessage: 'Contact point deleted.',\n      refetch: true\n    }));\n  };\n};\nexport const deleteTemplateAction = (templateName, alertManagerSourceName) => {\n  return (dispatch, getState) => {\n    var _getState$unifiedAler3, _getState$unifiedAler4, _config$template_file, _config$alertmanager_2;\n\n    const config = (_getState$unifiedAler3 = getState().unifiedAlerting.amConfigs) === null || _getState$unifiedAler3 === void 0 ? void 0 : (_getState$unifiedAler4 = _getState$unifiedAler3[alertManagerSourceName]) === null || _getState$unifiedAler4 === void 0 ? void 0 : _getState$unifiedAler4.result;\n\n    if (!config) {\n      throw new Error(`Config for ${alertManagerSourceName} not found`);\n    }\n\n    if (typeof ((_config$template_file = config.template_files) === null || _config$template_file === void 0 ? void 0 : _config$template_file[templateName]) !== 'string') {\n      throw new Error(`Cannot delete template ${templateName}: not found in config.`);\n    }\n\n    const newTemplates = Object.assign({}, config.template_files);\n    delete newTemplates[templateName];\n    const newConfig = Object.assign({}, config, {\n      alertmanager_config: Object.assign({}, config.alertmanager_config, {\n        templates: (_config$alertmanager_2 = config.alertmanager_config.templates) === null || _config$alertmanager_2 === void 0 ? void 0 : _config$alertmanager_2.filter(existing => existing !== templateName)\n      }),\n      template_files: newTemplates\n    });\n    return dispatch(updateAlertManagerConfigAction({\n      newConfig,\n      oldConfig: config,\n      alertManagerSourceName,\n      successMessage: 'Template deleted.',\n      refetch: true\n    }));\n  };\n};\nexport const fetchFolderAction = createAsyncThunk('unifiedalerting/fetchFolder', uid => withSerializedError(getBackendSrv().getFolderByUid(uid)));\nexport const fetchFolderIfNotFetchedAction = uid => {\n  return (dispatch, getState) => {\n    var _getState$unifiedAler5;\n\n    if (!((_getState$unifiedAler5 = getState().unifiedAlerting.folders[uid]) !== null && _getState$unifiedAler5 !== void 0 && _getState$unifiedAler5.dispatched)) {\n      dispatch(fetchFolderAction(uid));\n    }\n  };\n};\nexport const fetchAlertGroupsAction = createAsyncThunk('unifiedalerting/fetchAlertGroups', alertManagerSourceName => {\n  return withSerializedError(fetchAlertGroups(alertManagerSourceName));\n});\nexport const deleteAlertManagerConfigAction = createAsyncThunk('unifiedalerting/deleteAlertManagerConfig', async (alertManagerSourceName, thunkAPI) => {\n  return withAppEvents(withSerializedError((async () => {\n    await deleteAlertManagerConfig(alertManagerSourceName);\n    await thunkAPI.dispatch(fetchAlertManagerConfigAction(alertManagerSourceName));\n  })()), {\n    errorMessage: 'Failed to reset Alertmanager configuration',\n    successMessage: 'Alertmanager configuration reset.'\n  });\n});\nexport const deleteMuteTimingAction = (alertManagerSourceName, muteTimingName) => {\n  return async (dispatch, getState) => {\n    var _config$alertmanager_3, _config$alertmanager_4, _config$alertmanager_5;\n\n    const config = getState().unifiedAlerting.amConfigs[alertManagerSourceName].result;\n    const muteIntervals = (_config$alertmanager_3 = config === null || config === void 0 ? void 0 : (_config$alertmanager_4 = config.alertmanager_config) === null || _config$alertmanager_4 === void 0 ? void 0 : (_config$alertmanager_5 = _config$alertmanager_4.mute_time_intervals) === null || _config$alertmanager_5 === void 0 ? void 0 : _config$alertmanager_5.filter(({\n      name\n    }) => name !== muteTimingName)) !== null && _config$alertmanager_3 !== void 0 ? _config$alertmanager_3 : [];\n\n    if (config) {\n      var _config$alertmanager_6;\n\n      withAppEvents(dispatch(updateAlertManagerConfigAction({\n        alertManagerSourceName,\n        oldConfig: config,\n        newConfig: Object.assign({}, config, {\n          alertmanager_config: Object.assign({}, config.alertmanager_config, {\n            route: config.alertmanager_config.route ? removeMuteTimingFromRoute(muteTimingName, (_config$alertmanager_6 = config.alertmanager_config) === null || _config$alertmanager_6 === void 0 ? void 0 : _config$alertmanager_6.route) : undefined,\n            mute_time_intervals: muteIntervals\n          })\n        }),\n        refetch: true\n      })), {\n        successMessage: `Deleted \"${muteTimingName}\" from Alertmanager configuration`,\n        errorMessage: 'Failed to delete mute timing'\n      });\n    }\n  };\n};\nexport const testReceiversAction = createAsyncThunk('unifiedalerting/testReceivers', ({\n  alertManagerSourceName,\n  receivers,\n  alert\n}) => {\n  return withAppEvents(withSerializedError(testReceivers(alertManagerSourceName, receivers, alert)), {\n    errorMessage: 'Failed to send test alert.',\n    successMessage: 'Test alert sent.'\n  });\n});\n// allows renaming namespace, renaming group and changing group interval, all in one go\nexport const updateLotexNamespaceAndGroupAction = createAsyncThunk('unifiedalerting/updateLotexNamespaceAndGroup', async (options, thunkAPI) => {\n  return withAppEvents(withSerializedError((async () => {\n    const {\n      rulesSourceName,\n      namespaceName,\n      groupName,\n      newNamespaceName,\n      newGroupName,\n      groupInterval\n    } = options;\n\n    if (options.rulesSourceName === GRAFANA_RULES_SOURCE_NAME) {\n      throw new Error(`this action does not support Grafana rules`);\n    }\n\n    const rulerConfig = getDataSourceRulerConfig(thunkAPI.getState, rulesSourceName); // fetch rules and perform sanity checks\n\n    const rulesResult = await fetchRulerRules(rulerConfig);\n\n    if (!rulesResult[namespaceName]) {\n      throw new Error(`Namespace \"${namespaceName}\" not found.`);\n    }\n\n    const existingGroup = rulesResult[namespaceName].find(group => group.name === groupName);\n\n    if (!existingGroup) {\n      throw new Error(`Group \"${groupName}\" not found.`);\n    }\n\n    if (newGroupName !== groupName && !!rulesResult[namespaceName].find(group => group.name === newGroupName)) {\n      throw new Error(`Group \"${newGroupName}\" already exists.`);\n    }\n\n    if (newNamespaceName !== namespaceName && !!rulesResult[newNamespaceName]) {\n      throw new Error(`Namespace \"${newNamespaceName}\" already exists.`);\n    }\n\n    if (newNamespaceName === namespaceName && groupName === newGroupName && groupInterval === existingGroup.interval) {\n      throw new Error('Nothing changed.');\n    } // if renaming namespace - make new copies of all groups, then delete old namespace\n\n\n    if (newNamespaceName !== namespaceName) {\n      for (const group of rulesResult[namespaceName]) {\n        await setRulerRuleGroup(rulerConfig, newNamespaceName, group.name === groupName ? Object.assign({}, group, {\n          name: newGroupName,\n          interval: groupInterval\n        }) : group);\n      }\n\n      await deleteNamespace(rulerConfig, namespaceName); // if only modifying group...\n    } else {\n      // save updated group\n      await setRulerRuleGroup(rulerConfig, namespaceName, Object.assign({}, existingGroup, {\n        name: newGroupName,\n        interval: groupInterval\n      })); // if group name was changed, delete old group\n\n      if (newGroupName !== groupName) {\n        await deleteRulerRulesGroup(rulerConfig, namespaceName, groupName);\n      }\n    } // refetch all rules\n\n\n    await thunkAPI.dispatch(fetchRulerRulesAction({\n      rulesSourceName\n    }));\n  })()), {\n    errorMessage: 'Failed to update namespace / group',\n    successMessage: 'Update successful'\n  });\n});\nexport const addExternalAlertmanagersAction = createAsyncThunk('unifiedAlerting/addExternalAlertmanagers', async (alertmanagerConfig, thunkAPI) => {\n  return withAppEvents(withSerializedError((async () => {\n    await addAlertManagers(alertmanagerConfig);\n    thunkAPI.dispatch(fetchExternalAlertmanagersConfigAction());\n  })()), {\n    errorMessage: 'Failed adding alertmanagers',\n    successMessage: 'Alertmanagers updated'\n  });\n});","map":{"version":3,"names":["createAsyncThunk","isEmpty","getBackendSrv","locationService","messageFromError","PromApplication","addAlertManagers","createOrUpdateSilence","deleteAlertManagerConfig","expireSilence","fetchAlertGroups","fetchAlertManagerConfig","fetchAlerts","fetchExternalAlertmanagerConfig","fetchExternalAlertmanagers","fetchSilences","fetchStatus","testReceivers","updateAlertManagerConfig","fetchAnnotations","discoverFeatures","fetchNotifiers","fetchRules","deleteNamespace","deleteRulerRulesGroup","fetchRulerRules","setRulerRuleGroup","RuleFormType","addDefaultsToAlertmanagerConfig","removeMuteTimingFromRoute","getAllRulesSourceNames","getRulesDataSource","getRulesSourceName","GRAFANA_RULES_SOURCE_NAME","isVanillaPrometheusAlertManagerDataSource","makeAMLink","retryWhile","withAppEvents","withSerializedError","ruleId","getRulerClient","isRulerNotSupportedResponse","FETCH_CONFIG_RETRY_TIMEOUT","getDataSourceConfig","getState","rulesSourceName","dataSources","unifiedAlerting","dsConfig","result","Error","getDataSourceRulerConfig","rulerConfig","fetchPromRulesAction","filter","thunkAPI","dispatch","fetchRulesSourceBuildInfoAction","fetchAlertManagerConfigAction","alertManagerSourceName","then","status","alertmanager_config","config","template_files","e","includes","template_file_provenances","fetchExternalAlertmanagersAction","fetchExternalAlertmanagersConfigAction","fetchRulerRulesAction","fetchPromAndRulerRulesAction","fetchSilencesAction","fetchRulerRulesIfNotFetchedYet","getStore","rulerRules","resp","loading","fetchAllPromBuildInfoAction","allRequests","map","Promise","allSettled","name","id","dataSourceName","apiVersion","ds","buildInfo","features","rulerApiEnabled","application","Lotex","undefined","condition","hasLoaded","Boolean","fetchAllPromAndRulerRulesAction","force","promRules","dataSourceConfig","fetchAllPromRulesAction","fetchEditableRuleAction","ruleIdentifier","ruleSourceName","findEditableRule","deleteRulesGroupAction","namespace","ruleGroup","sourceName","rulesSource","successMessage","deleteRuleAction","options","rulerClient","ruleWithLocation","deleteRule","navigateTo","replace","saveRuleFormAction","values","existing","redirectOnSave","type","identifier","cloudAlerting","cloudRecording","saveLotexRule","grafana","saveGrafanaRule","push","stringifiedIdentifier","stringifyIdentifier","newLocation","encodeURIComponent","getLocation","pathname","errorMessage","fetchGrafanaNotifiersAction","fetchGrafanaAnnotationsAction","alertId","updateAlertManagerConfigAction","oldConfig","newConfig","redirectPath","refetch","latestConfig","JSON","stringify","fetchAmAlertsAction","expireSilenceAction","silenceId","createOrUpdateSilenceAction","payload","exitOnSave","deleteReceiverAction","receiverName","amConfigs","receivers","find","receiver","deleteTemplateAction","templateName","newTemplates","templates","fetchFolderAction","uid","getFolderByUid","fetchFolderIfNotFetchedAction","folders","dispatched","fetchAlertGroupsAction","deleteAlertManagerConfigAction","deleteMuteTimingAction","muteTimingName","muteIntervals","mute_time_intervals","route","testReceiversAction","alert","updateLotexNamespaceAndGroupAction","namespaceName","groupName","newNamespaceName","newGroupName","groupInterval","rulesResult","existingGroup","group","interval","addExternalAlertmanagersAction","alertmanagerConfig"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/state/actions.ts"],"sourcesContent":["import { createAsyncThunk } from '@reduxjs/toolkit';\nimport { isEmpty } from 'lodash';\n\nimport { getBackendSrv, locationService } from '@grafana/runtime';\nimport {\n  AlertmanagerAlert,\n  AlertManagerCortexConfig,\n  AlertmanagerGroup,\n  ExternalAlertmanagerConfig,\n  ExternalAlertmanagersResponse,\n  Receiver,\n  Silence,\n  SilenceCreatePayload,\n  TestReceiversAlert,\n} from 'app/plugins/datasource/alertmanager/types';\nimport messageFromError from 'app/plugins/datasource/grafana-azure-monitor-datasource/utils/messageFromError';\nimport { FolderDTO, NotifierDTO, StoreState, ThunkResult } from 'app/types';\nimport {\n  CombinedRuleGroup,\n  CombinedRuleNamespace,\n  PromBasedDataSource,\n  RuleIdentifier,\n  RuleNamespace,\n  RulerDataSourceConfig,\n  RuleWithLocation,\n  StateHistoryItem,\n} from 'app/types/unified-alerting';\nimport { PromApplication, RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\n\nimport {\n  addAlertManagers,\n  createOrUpdateSilence,\n  deleteAlertManagerConfig,\n  expireSilence,\n  fetchAlertGroups,\n  fetchAlertManagerConfig,\n  fetchAlerts,\n  fetchExternalAlertmanagerConfig,\n  fetchExternalAlertmanagers,\n  fetchSilences,\n  fetchStatus,\n  testReceivers,\n  updateAlertManagerConfig,\n} from '../api/alertmanager';\nimport { fetchAnnotations } from '../api/annotations';\nimport { discoverFeatures } from '../api/buildInfo';\nimport { fetchNotifiers } from '../api/grafana';\nimport { FetchPromRulesFilter, fetchRules } from '../api/prometheus';\nimport {\n  deleteNamespace,\n  deleteRulerRulesGroup,\n  fetchRulerRules,\n  FetchRulerRulesFilter,\n  setRulerRuleGroup,\n} from '../api/ruler';\nimport { RuleFormType, RuleFormValues } from '../types/rule-form';\nimport { addDefaultsToAlertmanagerConfig, removeMuteTimingFromRoute } from '../utils/alertmanager';\nimport {\n  getAllRulesSourceNames,\n  getRulesDataSource,\n  getRulesSourceName,\n  GRAFANA_RULES_SOURCE_NAME,\n  isVanillaPrometheusAlertManagerDataSource,\n} from '../utils/datasource';\nimport { makeAMLink, retryWhile } from '../utils/misc';\nimport { AsyncRequestMapSlice, withAppEvents, withSerializedError } from '../utils/redux';\nimport * as ruleId from '../utils/rule-id';\nimport { getRulerClient } from '../utils/rulerClient';\nimport { isRulerNotSupportedResponse } from '../utils/rules';\n\nconst FETCH_CONFIG_RETRY_TIMEOUT = 30 * 1000;\n\nfunction getDataSourceConfig(getState: () => unknown, rulesSourceName: string) {\n  const dataSources = (getState() as StoreState).unifiedAlerting.dataSources;\n  const dsConfig = dataSources[rulesSourceName]?.result;\n  if (!dsConfig) {\n    throw new Error(`Data source configuration is not available for \"${rulesSourceName}\" data source`);\n  }\n\n  return dsConfig;\n}\n\nfunction getDataSourceRulerConfig(getState: () => unknown, rulesSourceName: string) {\n  const dsConfig = getDataSourceConfig(getState, rulesSourceName);\n  if (!dsConfig.rulerConfig) {\n    throw new Error(`Ruler API is not available for ${rulesSourceName}`);\n  }\n\n  return dsConfig.rulerConfig;\n}\n\nexport const fetchPromRulesAction = createAsyncThunk(\n  'unifiedalerting/fetchPromRules',\n  async (\n    { rulesSourceName, filter }: { rulesSourceName: string; filter?: FetchPromRulesFilter },\n    thunkAPI\n  ): Promise<RuleNamespace[]> => {\n    await thunkAPI.dispatch(fetchRulesSourceBuildInfoAction({ rulesSourceName }));\n    return await withSerializedError(fetchRules(rulesSourceName, filter));\n  }\n);\n\nexport const fetchAlertManagerConfigAction = createAsyncThunk(\n  'unifiedalerting/fetchAmConfig',\n  (alertManagerSourceName: string): Promise<AlertManagerCortexConfig> =>\n    withSerializedError(\n      (async () => {\n        // for vanilla prometheus, there is no config endpoint. Only fetch config from status\n        if (isVanillaPrometheusAlertManagerDataSource(alertManagerSourceName)) {\n          return fetchStatus(alertManagerSourceName).then((status) => ({\n            alertmanager_config: status.config,\n            template_files: {},\n          }));\n        }\n\n        return retryWhile(\n          () => fetchAlertManagerConfig(alertManagerSourceName),\n          // if config has been recently deleted, it takes a while for cortex start returning the default one.\n          // retry for a short while instead of failing\n          (e) => !!messageFromError(e)?.includes('alertmanager storage object not found'),\n          FETCH_CONFIG_RETRY_TIMEOUT\n        ).then((result) => {\n          // if user config is empty for cortex alertmanager, try to get config from status endpoint\n          if (\n            isEmpty(result.alertmanager_config) &&\n            isEmpty(result.template_files) &&\n            alertManagerSourceName !== GRAFANA_RULES_SOURCE_NAME\n          ) {\n            return fetchStatus(alertManagerSourceName).then((status) => ({\n              alertmanager_config: status.config,\n              template_files: {},\n              template_file_provenances: result.template_file_provenances,\n            }));\n          }\n          return result;\n        });\n      })()\n    )\n);\n\nexport const fetchExternalAlertmanagersAction = createAsyncThunk(\n  'unifiedAlerting/fetchExternalAlertmanagers',\n  (): Promise<ExternalAlertmanagersResponse> => {\n    return withSerializedError(fetchExternalAlertmanagers());\n  }\n);\n\nexport const fetchExternalAlertmanagersConfigAction = createAsyncThunk(\n  'unifiedAlerting/fetchExternAlertmanagersConfig',\n  (): Promise<ExternalAlertmanagerConfig> => {\n    return withSerializedError(fetchExternalAlertmanagerConfig());\n  }\n);\n\nexport const fetchRulerRulesAction = createAsyncThunk(\n  'unifiedalerting/fetchRulerRules',\n  async (\n    {\n      rulesSourceName,\n      filter,\n    }: {\n      rulesSourceName: string;\n      filter?: FetchRulerRulesFilter;\n    },\n    { dispatch, getState }\n  ): Promise<RulerRulesConfigDTO | null> => {\n    await dispatch(fetchRulesSourceBuildInfoAction({ rulesSourceName }));\n    const rulerConfig = getDataSourceRulerConfig(getState, rulesSourceName);\n    return await withSerializedError(fetchRulerRules(rulerConfig, filter));\n  }\n);\n\nexport function fetchPromAndRulerRulesAction({ rulesSourceName }: { rulesSourceName: string }): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    await dispatch(fetchRulesSourceBuildInfoAction({ rulesSourceName }));\n    const dsConfig = getDataSourceConfig(getState, rulesSourceName);\n\n    await dispatch(fetchPromRulesAction({ rulesSourceName }));\n    if (dsConfig.rulerConfig) {\n      await dispatch(fetchRulerRulesAction({ rulesSourceName }));\n    }\n  };\n}\n\nexport const fetchSilencesAction = createAsyncThunk(\n  'unifiedalerting/fetchSilences',\n  (alertManagerSourceName: string): Promise<Silence[]> => {\n    return withSerializedError(fetchSilences(alertManagerSourceName));\n  }\n);\n\n// this will only trigger ruler rules fetch if rules are not loaded yet and request is not in flight\nexport function fetchRulerRulesIfNotFetchedYet(rulesSourceName: string): ThunkResult<void> {\n  return (dispatch, getStore) => {\n    const { rulerRules } = getStore().unifiedAlerting;\n    const resp = rulerRules[rulesSourceName];\n    if (!resp?.result && !(resp && isRulerNotSupportedResponse(resp)) && !resp?.loading) {\n      dispatch(fetchRulerRulesAction({ rulesSourceName }));\n    }\n  };\n}\n\nexport function fetchAllPromBuildInfoAction(): ThunkResult<Promise<void>> {\n  return async (dispatch) => {\n    const allRequests = getAllRulesSourceNames().map((rulesSourceName) =>\n      dispatch(fetchRulesSourceBuildInfoAction({ rulesSourceName }))\n    );\n\n    await Promise.allSettled(allRequests);\n  };\n}\n\nexport const fetchRulesSourceBuildInfoAction = createAsyncThunk(\n  'unifiedalerting/fetchPromBuildinfo',\n  async ({ rulesSourceName }: { rulesSourceName: string }): Promise<PromBasedDataSource> => {\n    return withSerializedError<PromBasedDataSource>(\n      (async (): Promise<PromBasedDataSource> => {\n        if (rulesSourceName === GRAFANA_RULES_SOURCE_NAME) {\n          return {\n            name: GRAFANA_RULES_SOURCE_NAME,\n            id: GRAFANA_RULES_SOURCE_NAME,\n            rulerConfig: {\n              dataSourceName: GRAFANA_RULES_SOURCE_NAME,\n              apiVersion: 'legacy',\n            },\n          };\n        }\n\n        const ds = getRulesDataSource(rulesSourceName);\n        if (!ds) {\n          throw new Error(`Missing data source configuration for ${rulesSourceName}`);\n        }\n\n        const { id, name } = ds;\n        const buildInfo = await discoverFeatures(name);\n\n        const rulerConfig: RulerDataSourceConfig | undefined = buildInfo.features.rulerApiEnabled\n          ? {\n              dataSourceName: name,\n              apiVersion: buildInfo.application === PromApplication.Lotex ? 'legacy' : 'config',\n            }\n          : undefined;\n\n        return {\n          name: name,\n          id: id,\n          rulerConfig,\n        };\n      })()\n    );\n  },\n  {\n    condition: ({ rulesSourceName }, { getState }) => {\n      const dataSources: AsyncRequestMapSlice<PromBasedDataSource> = (getState() as StoreState).unifiedAlerting\n        .dataSources;\n      const hasLoaded = Boolean(dataSources[rulesSourceName]?.result);\n      return !hasLoaded;\n    },\n  }\n);\n\nexport function fetchAllPromAndRulerRulesAction(force = false): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    await dispatch(fetchAllPromBuildInfoAction());\n\n    const { promRules, rulerRules, dataSources } = getStore().unifiedAlerting;\n\n    getAllRulesSourceNames().map((rulesSourceName) => {\n      const dataSourceConfig = dataSources[rulesSourceName].result;\n      if (!dataSourceConfig) {\n        return;\n      }\n\n      if (force || !promRules[rulesSourceName]?.loading) {\n        dispatch(fetchPromRulesAction({ rulesSourceName }));\n      }\n      if ((force || !rulerRules[rulesSourceName]?.loading) && dataSourceConfig.rulerConfig) {\n        dispatch(fetchRulerRulesAction({ rulesSourceName }));\n      }\n    });\n  };\n}\n\nexport function fetchAllPromRulesAction(force = false): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    const { promRules } = getStore().unifiedAlerting;\n    getAllRulesSourceNames().map((rulesSourceName) => {\n      if (force || !promRules[rulesSourceName]?.loading) {\n        dispatch(fetchPromRulesAction({ rulesSourceName }));\n      }\n    });\n  };\n}\n\nexport const fetchEditableRuleAction = createAsyncThunk(\n  'unifiedalerting/fetchEditableRule',\n  (ruleIdentifier: RuleIdentifier, thunkAPI): Promise<RuleWithLocation | null> => {\n    const rulerConfig = getDataSourceRulerConfig(thunkAPI.getState, ruleIdentifier.ruleSourceName);\n    return withSerializedError(getRulerClient(rulerConfig).findEditableRule(ruleIdentifier));\n  }\n);\n\nexport function deleteRulesGroupAction(\n  namespace: CombinedRuleNamespace,\n  ruleGroup: CombinedRuleGroup\n): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    withAppEvents(\n      (async () => {\n        const sourceName = getRulesSourceName(namespace.rulesSource);\n        const rulerConfig = getDataSourceRulerConfig(getState, sourceName);\n\n        await deleteRulerRulesGroup(rulerConfig, namespace.name, ruleGroup.name);\n        await dispatch(fetchPromAndRulerRulesAction({ rulesSourceName: sourceName }));\n      })(),\n      { successMessage: 'Group deleted' }\n    );\n  };\n}\n\nexport function deleteRuleAction(\n  ruleIdentifier: RuleIdentifier,\n  options: { navigateTo?: string } = {}\n): ThunkResult<void> {\n  /*\n   * fetch the rules group from backend, delete group if it is found and+\n   * reload ruler rules\n   */\n  return async (dispatch, getState) => {\n    withAppEvents(\n      (async () => {\n        const rulerConfig = getDataSourceRulerConfig(getState, ruleIdentifier.ruleSourceName);\n        const rulerClient = getRulerClient(rulerConfig);\n        const ruleWithLocation = await rulerClient.findEditableRule(ruleIdentifier);\n\n        if (!ruleWithLocation) {\n          throw new Error('Rule not found.');\n        }\n        await rulerClient.deleteRule(ruleWithLocation);\n        // refetch rules for this rules source\n        await dispatch(fetchPromAndRulerRulesAction({ rulesSourceName: ruleWithLocation.ruleSourceName }));\n\n        if (options.navigateTo) {\n          locationService.replace(options.navigateTo);\n        }\n      })(),\n      {\n        successMessage: 'Rule deleted.',\n      }\n    );\n  };\n}\n\nexport const saveRuleFormAction = createAsyncThunk(\n  'unifiedalerting/saveRuleForm',\n  (\n    {\n      values,\n      existing,\n      redirectOnSave,\n    }: {\n      values: RuleFormValues;\n      existing?: RuleWithLocation;\n      redirectOnSave?: string;\n    },\n    thunkAPI\n  ): Promise<void> =>\n    withAppEvents(\n      withSerializedError(\n        (async () => {\n          const { type } = values;\n\n          // TODO getRulerConfig should be smart enough to provide proper rulerClient implementation\n          // For the dataSourceName specified\n          // in case of system (cortex/loki)\n          let identifier: RuleIdentifier;\n          if (type === RuleFormType.cloudAlerting || type === RuleFormType.cloudRecording) {\n            if (!values.dataSourceName) {\n              throw new Error('The Data source has not been defined.');\n            }\n            const rulerConfig = getDataSourceRulerConfig(thunkAPI.getState, values.dataSourceName);\n            const rulerClient = getRulerClient(rulerConfig);\n            identifier = await rulerClient.saveLotexRule(values, existing);\n\n            // in case of grafana managed\n          } else if (type === RuleFormType.grafana) {\n            const rulerConfig = getDataSourceRulerConfig(thunkAPI.getState, GRAFANA_RULES_SOURCE_NAME);\n            const rulerClient = getRulerClient(rulerConfig);\n            identifier = await rulerClient.saveGrafanaRule(values, existing);\n          } else {\n            throw new Error('Unexpected rule form type');\n          }\n          if (redirectOnSave) {\n            locationService.push(redirectOnSave);\n          } else {\n            // if the identifier comes up empty (this happens when Grafana managed rule moves to another namespace or group)\n            const stringifiedIdentifier = ruleId.stringifyIdentifier(identifier);\n            if (!stringifiedIdentifier) {\n              locationService.push('/alerting/list');\n              return;\n            }\n            // redirect to edit page\n            const newLocation = `/alerting/${encodeURIComponent(stringifiedIdentifier)}/edit`;\n            if (locationService.getLocation().pathname !== newLocation) {\n              locationService.replace(newLocation);\n            } else {\n              // refresh the details of the current editable rule after saving\n              thunkAPI.dispatch(fetchEditableRuleAction(identifier));\n            }\n          }\n        })()\n      ),\n      {\n        successMessage: existing ? `Rule \"${values.name}\" updated.` : `Rule \"${values.name}\" saved.`,\n        errorMessage: 'Failed to save rule',\n      }\n    )\n);\n\nexport const fetchGrafanaNotifiersAction = createAsyncThunk(\n  'unifiedalerting/fetchGrafanaNotifiers',\n  (): Promise<NotifierDTO[]> => withSerializedError(fetchNotifiers())\n);\n\nexport const fetchGrafanaAnnotationsAction = createAsyncThunk(\n  'unifiedalerting/fetchGrafanaAnnotations',\n  (alertId: string): Promise<StateHistoryItem[]> => withSerializedError(fetchAnnotations(alertId))\n);\n\ninterface UpdateAlertManagerConfigActionOptions {\n  alertManagerSourceName: string;\n  oldConfig: AlertManagerCortexConfig; // it will be checked to make sure it didn't change in the meanwhile\n  newConfig: AlertManagerCortexConfig;\n  successMessage?: string; // show toast on success\n  redirectPath?: string; // where to redirect on success\n  refetch?: boolean; // refetch config on success\n}\n\nexport const updateAlertManagerConfigAction = createAsyncThunk<void, UpdateAlertManagerConfigActionOptions, {}>(\n  'unifiedalerting/updateAMConfig',\n  ({ alertManagerSourceName, oldConfig, newConfig, successMessage, redirectPath, refetch }, thunkAPI): Promise<void> =>\n    withAppEvents(\n      withSerializedError(\n        (async () => {\n          const latestConfig = await fetchAlertManagerConfig(alertManagerSourceName);\n          if (\n            !(isEmpty(latestConfig.alertmanager_config) && isEmpty(latestConfig.template_files)) &&\n            JSON.stringify(latestConfig) !== JSON.stringify(oldConfig)\n          ) {\n            throw new Error(\n              'It seems configuration has been recently updated. Please reload page and try again to make sure that recent changes are not overwritten.'\n            );\n          }\n          await updateAlertManagerConfig(alertManagerSourceName, addDefaultsToAlertmanagerConfig(newConfig));\n          if (refetch) {\n            await thunkAPI.dispatch(fetchAlertManagerConfigAction(alertManagerSourceName));\n          }\n          if (redirectPath) {\n            locationService.push(makeAMLink(redirectPath, alertManagerSourceName));\n          }\n        })()\n      ),\n      {\n        successMessage,\n      }\n    )\n);\n\nexport const fetchAmAlertsAction = createAsyncThunk(\n  'unifiedalerting/fetchAmAlerts',\n  (alertManagerSourceName: string): Promise<AlertmanagerAlert[]> =>\n    withSerializedError(fetchAlerts(alertManagerSourceName, [], true, true, true))\n);\n\nexport const expireSilenceAction = (alertManagerSourceName: string, silenceId: string): ThunkResult<void> => {\n  return async (dispatch) => {\n    await withAppEvents(expireSilence(alertManagerSourceName, silenceId), {\n      successMessage: 'Silence expired.',\n    });\n    dispatch(fetchSilencesAction(alertManagerSourceName));\n    dispatch(fetchAmAlertsAction(alertManagerSourceName));\n  };\n};\n\ntype UpdateSilenceActionOptions = {\n  alertManagerSourceName: string;\n  payload: SilenceCreatePayload;\n  exitOnSave: boolean;\n  successMessage?: string;\n};\n\nexport const createOrUpdateSilenceAction = createAsyncThunk<void, UpdateSilenceActionOptions, {}>(\n  'unifiedalerting/updateSilence',\n  ({ alertManagerSourceName, payload, exitOnSave, successMessage }): Promise<void> =>\n    withAppEvents(\n      withSerializedError(\n        (async () => {\n          await createOrUpdateSilence(alertManagerSourceName, payload);\n          if (exitOnSave) {\n            locationService.push('/alerting/silences');\n          }\n        })()\n      ),\n      {\n        successMessage,\n      }\n    )\n);\n\nexport const deleteReceiverAction = (receiverName: string, alertManagerSourceName: string): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    const config = getState().unifiedAlerting.amConfigs?.[alertManagerSourceName]?.result;\n    if (!config) {\n      throw new Error(`Config for ${alertManagerSourceName} not found`);\n    }\n    if (!config.alertmanager_config.receivers?.find((receiver) => receiver.name === receiverName)) {\n      throw new Error(`Cannot delete receiver ${receiverName}: not found in config.`);\n    }\n    const newConfig: AlertManagerCortexConfig = {\n      ...config,\n      alertmanager_config: {\n        ...config.alertmanager_config,\n        receivers: config.alertmanager_config.receivers.filter((receiver) => receiver.name !== receiverName),\n      },\n    };\n    return dispatch(\n      updateAlertManagerConfigAction({\n        newConfig,\n        oldConfig: config,\n        alertManagerSourceName,\n        successMessage: 'Contact point deleted.',\n        refetch: true,\n      })\n    );\n  };\n};\n\nexport const deleteTemplateAction = (templateName: string, alertManagerSourceName: string): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    const config = getState().unifiedAlerting.amConfigs?.[alertManagerSourceName]?.result;\n    if (!config) {\n      throw new Error(`Config for ${alertManagerSourceName} not found`);\n    }\n    if (typeof config.template_files?.[templateName] !== 'string') {\n      throw new Error(`Cannot delete template ${templateName}: not found in config.`);\n    }\n    const newTemplates = { ...config.template_files };\n    delete newTemplates[templateName];\n    const newConfig: AlertManagerCortexConfig = {\n      ...config,\n      alertmanager_config: {\n        ...config.alertmanager_config,\n        templates: config.alertmanager_config.templates?.filter((existing) => existing !== templateName),\n      },\n      template_files: newTemplates,\n    };\n    return dispatch(\n      updateAlertManagerConfigAction({\n        newConfig,\n        oldConfig: config,\n        alertManagerSourceName,\n        successMessage: 'Template deleted.',\n        refetch: true,\n      })\n    );\n  };\n};\n\nexport const fetchFolderAction = createAsyncThunk(\n  'unifiedalerting/fetchFolder',\n  (uid: string): Promise<FolderDTO> => withSerializedError((getBackendSrv() as any).getFolderByUid(uid))\n);\n\nexport const fetchFolderIfNotFetchedAction = (uid: string): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    if (!getState().unifiedAlerting.folders[uid]?.dispatched) {\n      dispatch(fetchFolderAction(uid));\n    }\n  };\n};\n\nexport const fetchAlertGroupsAction = createAsyncThunk(\n  'unifiedalerting/fetchAlertGroups',\n  (alertManagerSourceName: string): Promise<AlertmanagerGroup[]> => {\n    return withSerializedError(fetchAlertGroups(alertManagerSourceName));\n  }\n);\n\nexport const deleteAlertManagerConfigAction = createAsyncThunk(\n  'unifiedalerting/deleteAlertManagerConfig',\n  async (alertManagerSourceName: string, thunkAPI): Promise<void> => {\n    return withAppEvents(\n      withSerializedError(\n        (async () => {\n          await deleteAlertManagerConfig(alertManagerSourceName);\n          await thunkAPI.dispatch(fetchAlertManagerConfigAction(alertManagerSourceName));\n        })()\n      ),\n      {\n        errorMessage: 'Failed to reset Alertmanager configuration',\n        successMessage: 'Alertmanager configuration reset.',\n      }\n    );\n  }\n);\n\nexport const deleteMuteTimingAction = (alertManagerSourceName: string, muteTimingName: string): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    const config = getState().unifiedAlerting.amConfigs[alertManagerSourceName].result;\n\n    const muteIntervals =\n      config?.alertmanager_config?.mute_time_intervals?.filter(({ name }) => name !== muteTimingName) ?? [];\n\n    if (config) {\n      withAppEvents(\n        dispatch(\n          updateAlertManagerConfigAction({\n            alertManagerSourceName,\n            oldConfig: config,\n            newConfig: {\n              ...config,\n              alertmanager_config: {\n                ...config.alertmanager_config,\n                route: config.alertmanager_config.route\n                  ? removeMuteTimingFromRoute(muteTimingName, config.alertmanager_config?.route)\n                  : undefined,\n                mute_time_intervals: muteIntervals,\n              },\n            },\n            refetch: true,\n          })\n        ),\n        {\n          successMessage: `Deleted \"${muteTimingName}\" from Alertmanager configuration`,\n          errorMessage: 'Failed to delete mute timing',\n        }\n      );\n    }\n  };\n};\n\ninterface TestReceiversOptions {\n  alertManagerSourceName: string;\n  receivers: Receiver[];\n  alert?: TestReceiversAlert;\n}\n\nexport const testReceiversAction = createAsyncThunk(\n  'unifiedalerting/testReceivers',\n  ({ alertManagerSourceName, receivers, alert }: TestReceiversOptions): Promise<void> => {\n    return withAppEvents(withSerializedError(testReceivers(alertManagerSourceName, receivers, alert)), {\n      errorMessage: 'Failed to send test alert.',\n      successMessage: 'Test alert sent.',\n    });\n  }\n);\n\ninterface UpdateNamespaceAndGroupOptions {\n  rulesSourceName: string;\n  namespaceName: string;\n  groupName: string;\n  newNamespaceName: string;\n  newGroupName: string;\n  groupInterval?: string;\n}\n\n// allows renaming namespace, renaming group and changing group interval, all in one go\nexport const updateLotexNamespaceAndGroupAction = createAsyncThunk(\n  'unifiedalerting/updateLotexNamespaceAndGroup',\n  async (options: UpdateNamespaceAndGroupOptions, thunkAPI): Promise<void> => {\n    return withAppEvents(\n      withSerializedError(\n        (async () => {\n          const { rulesSourceName, namespaceName, groupName, newNamespaceName, newGroupName, groupInterval } = options;\n          if (options.rulesSourceName === GRAFANA_RULES_SOURCE_NAME) {\n            throw new Error(`this action does not support Grafana rules`);\n          }\n\n          const rulerConfig = getDataSourceRulerConfig(thunkAPI.getState, rulesSourceName);\n          // fetch rules and perform sanity checks\n          const rulesResult = await fetchRulerRules(rulerConfig);\n          if (!rulesResult[namespaceName]) {\n            throw new Error(`Namespace \"${namespaceName}\" not found.`);\n          }\n          const existingGroup = rulesResult[namespaceName].find((group) => group.name === groupName);\n          if (!existingGroup) {\n            throw new Error(`Group \"${groupName}\" not found.`);\n          }\n          if (newGroupName !== groupName && !!rulesResult[namespaceName].find((group) => group.name === newGroupName)) {\n            throw new Error(`Group \"${newGroupName}\" already exists.`);\n          }\n          if (newNamespaceName !== namespaceName && !!rulesResult[newNamespaceName]) {\n            throw new Error(`Namespace \"${newNamespaceName}\" already exists.`);\n          }\n          if (\n            newNamespaceName === namespaceName &&\n            groupName === newGroupName &&\n            groupInterval === existingGroup.interval\n          ) {\n            throw new Error('Nothing changed.');\n          }\n\n          // if renaming namespace - make new copies of all groups, then delete old namespace\n          if (newNamespaceName !== namespaceName) {\n            for (const group of rulesResult[namespaceName]) {\n              await setRulerRuleGroup(\n                rulerConfig,\n                newNamespaceName,\n                group.name === groupName\n                  ? {\n                      ...group,\n                      name: newGroupName,\n                      interval: groupInterval,\n                    }\n                  : group\n              );\n            }\n            await deleteNamespace(rulerConfig, namespaceName);\n\n            // if only modifying group...\n          } else {\n            // save updated group\n            await setRulerRuleGroup(rulerConfig, namespaceName, {\n              ...existingGroup,\n              name: newGroupName,\n              interval: groupInterval,\n            });\n            // if group name was changed, delete old group\n            if (newGroupName !== groupName) {\n              await deleteRulerRulesGroup(rulerConfig, namespaceName, groupName);\n            }\n          }\n\n          // refetch all rules\n          await thunkAPI.dispatch(fetchRulerRulesAction({ rulesSourceName }));\n        })()\n      ),\n      {\n        errorMessage: 'Failed to update namespace / group',\n        successMessage: 'Update successful',\n      }\n    );\n  }\n);\n\nexport const addExternalAlertmanagersAction = createAsyncThunk(\n  'unifiedAlerting/addExternalAlertmanagers',\n  async (alertmanagerConfig: ExternalAlertmanagerConfig, thunkAPI): Promise<void> => {\n    return withAppEvents(\n      withSerializedError(\n        (async () => {\n          await addAlertManagers(alertmanagerConfig);\n          thunkAPI.dispatch(fetchExternalAlertmanagersConfigAction());\n        })()\n      ),\n      {\n        errorMessage: 'Failed adding alertmanagers',\n        successMessage: 'Alertmanagers updated',\n      }\n    );\n  }\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}