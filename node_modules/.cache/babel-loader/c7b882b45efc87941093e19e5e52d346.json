{"ast":null,"code":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Given a range (`min`, `max`) and factoring in a zoom (`viewStart`, `viewEnd`)\n * a function is created that will find the position of a sub-range (`start`, `end`).\n * The calling the generated method will return the result as a `{ start, end }`\n * object with values ranging in [0, 1].\n *\n * @param  {number} min       The start of the outer range.\n * @param  {number} max       The end of the outer range.\n * @param  {number} viewStart The start of the zoom, on a range of [0, 1],\n *                            relative to the `min`, `max`.\n * @param  {number} viewEnd   The end of the zoom, on a range of [0, 1],\n *                            relative to the `min`, `max`.\n * @returns {(number, number) => Object} Created view bounds function\n */\nexport function createViewedBoundsFunc(viewRange) {\n  const {\n    min,\n    max,\n    viewStart,\n    viewEnd\n  } = viewRange;\n  const duration = max - min;\n  const viewMin = min + viewStart * duration;\n  const viewMax = max - (1 - viewEnd) * duration;\n  const viewWindow = viewMax - viewMin;\n  /**\n   * View bounds function\n   * @param  {number} start     The start of the sub-range.\n   * @param  {number} end       The end of the sub-range.\n   * @returns {Object}           The resultant range.\n   */\n\n  return (start, end) => ({\n    start: (start - viewMin) / viewWindow,\n    end: (end - viewMin) / viewWindow\n  });\n}\n/**\n * Returns `true` if the `span` has a tag matching `key` = `value`.\n *\n * @param  {string} key   The tag key to match on.\n * @param  {any}    value The tag value to match.\n * @param  {{tags}} span  An object with a `tags` property of { key, value }\n *                        items.\n * @returns {boolean}      True if a match was found.\n */\n\nexport function spanHasTag(key, value, span) {\n  if (!Array.isArray(span.tags) || !span.tags.length) {\n    return false;\n  }\n\n  return span.tags.some(tag => tag.key === key && tag.value === value);\n}\nexport const isClientSpan = spanHasTag.bind(null, 'span.kind', 'client');\nexport const isServerSpan = spanHasTag.bind(null, 'span.kind', 'server');\nconst isErrorBool = spanHasTag.bind(null, 'error', true);\nconst isErrorStr = spanHasTag.bind(null, 'error', 'true');\nexport const isErrorSpan = span => isErrorBool(span) || isErrorStr(span);\n/**\n * Returns `true` if at least one of the descendants of the `parentSpanIndex`\n * span contains an error tag.\n *\n * @param      {TraceSpan[]}   spans            The spans for a trace - should be\n *                                         sorted with children following parents.\n * @param      {number}   parentSpanIndex  The index of the parent span - only\n *                                         subsequent spans with depth less than\n *                                         the parent span will be checked.\n * @returns     {boolean}  Returns `true` if a descendant contains an error tag.\n */\n\nexport function spanContainsErredSpan(spans, parentSpanIndex) {\n  const {\n    depth\n  } = spans[parentSpanIndex];\n  let i = parentSpanIndex + 1;\n\n  for (; i < spans.length && spans[i].depth > depth; i++) {\n    if (isErrorSpan(spans[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Expects the first span to be the parent span.\n */\n\nexport function findServerChildSpan(spans) {\n  if (spans.length <= 1 || !isClientSpan(spans[0])) {\n    return false;\n  }\n\n  const span = spans[0];\n  const spanChildDepth = span.depth + 1;\n  let i = 1;\n\n  while (i < spans.length && spans[i].depth === spanChildDepth) {\n    if (isServerSpan(spans[i])) {\n      return spans[i];\n    }\n\n    i++;\n  }\n\n  return null;\n}\nexport const isKindClient = span => span.tags.some(({\n  key,\n  value\n}) => key === 'span.kind' && value === 'client');\nexport { formatDuration } from '../utils/date';","map":{"version":3,"names":["createViewedBoundsFunc","viewRange","min","max","viewStart","viewEnd","duration","viewMin","viewMax","viewWindow","start","end","spanHasTag","key","value","span","Array","isArray","tags","length","some","tag","isClientSpan","bind","isServerSpan","isErrorBool","isErrorStr","isErrorSpan","spanContainsErredSpan","spans","parentSpanIndex","depth","i","findServerChildSpan","spanChildDepth","isKindClient","formatDuration"],"sources":["/home/soula/grafana/packages/jaeger-ui-components/src/TraceTimelineViewer/utils.tsx"],"sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { TraceSpan } from '../types/trace';\n\nexport type ViewedBoundsFunctionType = (start: number, end: number) => { start: number; end: number };\n/**\n * Given a range (`min`, `max`) and factoring in a zoom (`viewStart`, `viewEnd`)\n * a function is created that will find the position of a sub-range (`start`, `end`).\n * The calling the generated method will return the result as a `{ start, end }`\n * object with values ranging in [0, 1].\n *\n * @param  {number} min       The start of the outer range.\n * @param  {number} max       The end of the outer range.\n * @param  {number} viewStart The start of the zoom, on a range of [0, 1],\n *                            relative to the `min`, `max`.\n * @param  {number} viewEnd   The end of the zoom, on a range of [0, 1],\n *                            relative to the `min`, `max`.\n * @returns {(number, number) => Object} Created view bounds function\n */\nexport function createViewedBoundsFunc(viewRange: { min: number; max: number; viewStart: number; viewEnd: number }) {\n  const { min, max, viewStart, viewEnd } = viewRange;\n  const duration = max - min;\n  const viewMin = min + viewStart * duration;\n  const viewMax = max - (1 - viewEnd) * duration;\n  const viewWindow = viewMax - viewMin;\n\n  /**\n   * View bounds function\n   * @param  {number} start     The start of the sub-range.\n   * @param  {number} end       The end of the sub-range.\n   * @returns {Object}           The resultant range.\n   */\n  return (start: number, end: number) => ({\n    start: (start - viewMin) / viewWindow,\n    end: (end - viewMin) / viewWindow,\n  });\n}\n\n/**\n * Returns `true` if the `span` has a tag matching `key` = `value`.\n *\n * @param  {string} key   The tag key to match on.\n * @param  {any}    value The tag value to match.\n * @param  {{tags}} span  An object with a `tags` property of { key, value }\n *                        items.\n * @returns {boolean}      True if a match was found.\n */\nexport function spanHasTag(key: string, value: any, span: TraceSpan) {\n  if (!Array.isArray(span.tags) || !span.tags.length) {\n    return false;\n  }\n  return span.tags.some((tag) => tag.key === key && tag.value === value);\n}\n\nexport const isClientSpan = spanHasTag.bind(null, 'span.kind', 'client');\nexport const isServerSpan = spanHasTag.bind(null, 'span.kind', 'server');\n\nconst isErrorBool = spanHasTag.bind(null, 'error', true);\nconst isErrorStr = spanHasTag.bind(null, 'error', 'true');\nexport const isErrorSpan = (span: TraceSpan) => isErrorBool(span) || isErrorStr(span);\n\n/**\n * Returns `true` if at least one of the descendants of the `parentSpanIndex`\n * span contains an error tag.\n *\n * @param      {TraceSpan[]}   spans            The spans for a trace - should be\n *                                         sorted with children following parents.\n * @param      {number}   parentSpanIndex  The index of the parent span - only\n *                                         subsequent spans with depth less than\n *                                         the parent span will be checked.\n * @returns     {boolean}  Returns `true` if a descendant contains an error tag.\n */\nexport function spanContainsErredSpan(spans: TraceSpan[], parentSpanIndex: number) {\n  const { depth } = spans[parentSpanIndex];\n  let i = parentSpanIndex + 1;\n  for (; i < spans.length && spans[i].depth > depth; i++) {\n    if (isErrorSpan(spans[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Expects the first span to be the parent span.\n */\nexport function findServerChildSpan(spans: TraceSpan[]) {\n  if (spans.length <= 1 || !isClientSpan(spans[0])) {\n    return false;\n  }\n  const span = spans[0];\n  const spanChildDepth = span.depth + 1;\n  let i = 1;\n  while (i < spans.length && spans[i].depth === spanChildDepth) {\n    if (isServerSpan(spans[i])) {\n      return spans[i];\n    }\n    i++;\n  }\n  return null;\n}\n\nexport const isKindClient = (span: TraceSpan): Boolean =>\n  span.tags.some(({ key, value }) => key === 'span.kind' && value === 'client');\n\nexport { formatDuration } from '../utils/date';\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}