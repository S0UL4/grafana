{"ast":null,"code":"import { find, get } from 'lodash';\nimport TimeGrainConverter from '../time_grain_converter';\nexport default class ResponseParser {\n  static parseResponseValues(result, textFieldName, valueFieldName) {\n    const list = [];\n\n    if (!result) {\n      return list;\n    }\n\n    for (let i = 0; i < result.value.length; i++) {\n      if (!find(list, ['value', get(result.value[i], valueFieldName)])) {\n        const value = get(result.value[i], valueFieldName);\n        const text = get(result.value[i], textFieldName, value);\n        list.push({\n          text: text,\n          value: value\n        });\n      }\n    }\n\n    return list;\n  }\n\n  static parseResourceNames(result, metricDefinition) {\n    const list = [];\n\n    if (!result) {\n      return list;\n    }\n\n    for (let i = 0; i < result.value.length; i++) {\n      if (typeof result.value[i].type === 'string' && result.value[i].type.toLocaleLowerCase() === metricDefinition.toLocaleLowerCase()) {\n        list.push({\n          text: result.value[i].name,\n          value: result.value[i].name\n        });\n      }\n    }\n\n    return list;\n  }\n\n  static parseMetadata(result, metricName) {\n    var _metricData$metricAva, _metricData$dimension;\n\n    const defaultAggTypes = ['None', 'Average', 'Minimum', 'Maximum', 'Total', 'Count'];\n    const metricData = result === null || result === void 0 ? void 0 : result.value.find(v => v.name.value === metricName);\n\n    if (!metricData) {\n      return {\n        primaryAggType: '',\n        supportedAggTypes: defaultAggTypes,\n        supportedTimeGrains: [],\n        dimensions: []\n      };\n    }\n\n    return {\n      primaryAggType: metricData.primaryAggregationType,\n      supportedAggTypes: metricData.supportedAggregationTypes || defaultAggTypes,\n      supportedTimeGrains: [{\n        label: 'Auto',\n        value: 'auto'\n      }, ...ResponseParser.parseTimeGrains((_metricData$metricAva = metricData.metricAvailabilities) !== null && _metricData$metricAva !== void 0 ? _metricData$metricAva : [])],\n      dimensions: ResponseParser.parseDimensions((_metricData$dimension = metricData.dimensions) !== null && _metricData$dimension !== void 0 ? _metricData$dimension : [])\n    };\n  }\n\n  static parseTimeGrains(metricAvailabilities) {\n    const timeGrains = [];\n\n    if (!metricAvailabilities) {\n      return timeGrains;\n    }\n\n    metricAvailabilities.forEach(avail => {\n      if (avail.timeGrain) {\n        timeGrains.push({\n          label: TimeGrainConverter.createTimeGrainFromISO8601Duration(avail.timeGrain),\n          value: avail.timeGrain\n        });\n      }\n    });\n    return timeGrains;\n  }\n\n  static parseDimensions(metadataDimensions) {\n    return metadataDimensions.map(dimension => {\n      return {\n        label: dimension.localizedValue || dimension.value,\n        value: dimension.value\n      };\n    });\n  }\n\n  static parseSubscriptions(result) {\n    const list = [];\n\n    if (!result) {\n      return list;\n    }\n\n    const valueFieldName = 'subscriptionId';\n    const textFieldName = 'displayName';\n\n    for (let i = 0; i < result.value.length; i++) {\n      if (!find(list, ['value', get(result.value[i], valueFieldName)])) {\n        list.push({\n          text: `${get(result.value[i], textFieldName)}`,\n          value: get(result.value[i], valueFieldName)\n        });\n      }\n    }\n\n    return list;\n  }\n\n  static parseSubscriptionsForSelect(result) {\n    const list = [];\n\n    if (!result) {\n      return list;\n    }\n\n    const valueFieldName = 'subscriptionId';\n    const textFieldName = 'displayName';\n\n    for (let i = 0; i < result.data.value.length; i++) {\n      if (!find(list, ['value', get(result.data.value[i], valueFieldName)])) {\n        list.push({\n          label: `${get(result.data.value[i], textFieldName)} - ${get(result.data.value[i], valueFieldName)}`,\n          value: get(result.data.value[i], valueFieldName)\n        });\n      }\n    }\n\n    return list;\n  }\n\n  static parseWorkspacesForSelect(result) {\n    const list = [];\n\n    if (!result) {\n      return list;\n    }\n\n    const valueFieldName = 'customerId';\n    const textFieldName = 'name';\n\n    for (let i = 0; i < result.data.value.length; i++) {\n      if (!find(list, ['value', get(result.data.value[i].properties, valueFieldName)])) {\n        list.push({\n          label: get(result.data.value[i], textFieldName),\n          value: get(result.data.value[i].properties, valueFieldName)\n        });\n      }\n    }\n\n    return list;\n  }\n\n}","map":{"version":3,"names":["find","get","TimeGrainConverter","ResponseParser","parseResponseValues","result","textFieldName","valueFieldName","list","i","value","length","text","push","parseResourceNames","metricDefinition","type","toLocaleLowerCase","name","parseMetadata","metricName","defaultAggTypes","metricData","v","primaryAggType","supportedAggTypes","supportedTimeGrains","dimensions","primaryAggregationType","supportedAggregationTypes","label","parseTimeGrains","metricAvailabilities","parseDimensions","timeGrains","forEach","avail","timeGrain","createTimeGrainFromISO8601Duration","metadataDimensions","map","dimension","localizedValue","parseSubscriptions","parseSubscriptionsForSelect","data","parseWorkspacesForSelect","properties"],"sources":["/home/soula/grafana/public/app/plugins/datasource/grafana-azure-monitor-datasource/azure_monitor/response_parser.ts"],"sourcesContent":["import { find, get } from 'lodash';\n\nimport TimeGrainConverter from '../time_grain_converter';\nimport {\n  AzureMonitorLocalizedValue,\n  AzureMonitorMetricAvailabilityMetadata,\n  AzureMonitorMetricsMetadataResponse,\n  AzureMonitorOption,\n} from '../types';\nexport default class ResponseParser {\n  static parseResponseValues(\n    result: any,\n    textFieldName: string,\n    valueFieldName: string\n  ): Array<{ text: string; value: string }> {\n    const list: Array<{ text: string; value: string }> = [];\n\n    if (!result) {\n      return list;\n    }\n\n    for (let i = 0; i < result.value.length; i++) {\n      if (!find(list, ['value', get(result.value[i], valueFieldName)])) {\n        const value = get(result.value[i], valueFieldName);\n        const text = get(result.value[i], textFieldName, value);\n\n        list.push({\n          text: text,\n          value: value,\n        });\n      }\n    }\n    return list;\n  }\n\n  static parseResourceNames(result: any, metricDefinition: string): Array<{ text: string; value: string }> {\n    const list: Array<{ text: string; value: string }> = [];\n\n    if (!result) {\n      return list;\n    }\n\n    for (let i = 0; i < result.value.length; i++) {\n      if (\n        typeof result.value[i].type === 'string' &&\n        result.value[i].type.toLocaleLowerCase() === metricDefinition.toLocaleLowerCase()\n      ) {\n        list.push({\n          text: result.value[i].name,\n          value: result.value[i].name,\n        });\n      }\n    }\n\n    return list;\n  }\n\n  static parseMetadata(result: AzureMonitorMetricsMetadataResponse, metricName: string) {\n    const defaultAggTypes = ['None', 'Average', 'Minimum', 'Maximum', 'Total', 'Count'];\n    const metricData = result?.value.find((v) => v.name.value === metricName);\n\n    if (!metricData) {\n      return {\n        primaryAggType: '',\n        supportedAggTypes: defaultAggTypes,\n        supportedTimeGrains: [],\n        dimensions: [],\n      };\n    }\n\n    return {\n      primaryAggType: metricData.primaryAggregationType,\n      supportedAggTypes: metricData.supportedAggregationTypes || defaultAggTypes,\n\n      supportedTimeGrains: [\n        { label: 'Auto', value: 'auto' },\n        ...ResponseParser.parseTimeGrains(metricData.metricAvailabilities ?? []),\n      ],\n      dimensions: ResponseParser.parseDimensions(metricData.dimensions ?? []),\n    };\n  }\n\n  static parseTimeGrains(metricAvailabilities: AzureMonitorMetricAvailabilityMetadata[]): AzureMonitorOption[] {\n    const timeGrains: AzureMonitorOption[] = [];\n\n    if (!metricAvailabilities) {\n      return timeGrains;\n    }\n\n    metricAvailabilities.forEach((avail) => {\n      if (avail.timeGrain) {\n        timeGrains.push({\n          label: TimeGrainConverter.createTimeGrainFromISO8601Duration(avail.timeGrain),\n          value: avail.timeGrain,\n        });\n      }\n    });\n\n    return timeGrains;\n  }\n\n  static parseDimensions(metadataDimensions: AzureMonitorLocalizedValue[]) {\n    return metadataDimensions.map((dimension) => {\n      return {\n        label: dimension.localizedValue || dimension.value,\n        value: dimension.value,\n      };\n    });\n  }\n\n  static parseSubscriptions(result: any): Array<{ text: string; value: string }> {\n    const list: Array<{ text: string; value: string }> = [];\n\n    if (!result) {\n      return list;\n    }\n\n    const valueFieldName = 'subscriptionId';\n    const textFieldName = 'displayName';\n    for (let i = 0; i < result.value.length; i++) {\n      if (!find(list, ['value', get(result.value[i], valueFieldName)])) {\n        list.push({\n          text: `${get(result.value[i], textFieldName)}`,\n          value: get(result.value[i], valueFieldName),\n        });\n      }\n    }\n\n    return list;\n  }\n\n  static parseSubscriptionsForSelect(result: any): Array<{ label: string; value: string }> {\n    const list: Array<{ label: string; value: string }> = [];\n\n    if (!result) {\n      return list;\n    }\n\n    const valueFieldName = 'subscriptionId';\n    const textFieldName = 'displayName';\n    for (let i = 0; i < result.data.value.length; i++) {\n      if (!find(list, ['value', get(result.data.value[i], valueFieldName)])) {\n        list.push({\n          label: `${get(result.data.value[i], textFieldName)} - ${get(result.data.value[i], valueFieldName)}`,\n          value: get(result.data.value[i], valueFieldName),\n        });\n      }\n    }\n\n    return list;\n  }\n\n  static parseWorkspacesForSelect(result: any): Array<{ label: string; value: string }> {\n    const list: Array<{ label: string; value: string }> = [];\n\n    if (!result) {\n      return list;\n    }\n\n    const valueFieldName = 'customerId';\n    const textFieldName = 'name';\n    for (let i = 0; i < result.data.value.length; i++) {\n      if (!find(list, ['value', get(result.data.value[i].properties, valueFieldName)])) {\n        list.push({\n          label: get(result.data.value[i], textFieldName),\n          value: get(result.data.value[i].properties, valueFieldName),\n        });\n      }\n    }\n\n    return list;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}