{"ast":null,"code":"import { includes, isDate } from 'lodash';\nimport { dateTime, dateTimeForTimeZone, isDateTime, ISO_8601 } from './moment_wrapper';\nconst units = ['y', 'M', 'w', 'd', 'h', 'm', 's', 'Q'];\n/**\n * Determine if a string contains a relative date time.\n * @param text\n */\n\nexport function isMathString(text) {\n  if (!text) {\n    return false;\n  }\n\n  if (typeof text === 'string' && (text.substring(0, 3) === 'now' || text.includes('||'))) {\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\n * Parses different types input to a moment instance. There is a specific formatting language that can be used\n * if text arg is string. See unit tests for examples.\n * @param text\n * @param roundUp See parseDateMath function.\n * @param timezone Only string 'utc' is acceptable here, for anything else, local timezone is used.\n */\n\nexport function parse(text, roundUp, timezone, fiscalYearStartMonth) {\n  if (!text) {\n    return undefined;\n  }\n\n  if (typeof text !== 'string') {\n    if (isDateTime(text)) {\n      return text;\n    }\n\n    if (isDate(text)) {\n      return dateTime(text);\n    } // We got some non string which is not a moment nor Date. TS should be able to check for that but not always.\n\n\n    return undefined;\n  } else {\n    let time;\n    let mathString = '';\n    let index;\n    let parseString;\n\n    if (text.substring(0, 3) === 'now') {\n      time = dateTimeForTimeZone(timezone);\n      mathString = text.substring('now'.length);\n    } else {\n      index = text.indexOf('||');\n\n      if (index === -1) {\n        parseString = text;\n        mathString = ''; // nothing else\n      } else {\n        parseString = text.substring(0, index);\n        mathString = text.substring(index + 2);\n      } // We're going to just require ISO8601 timestamps, k?\n\n\n      time = dateTime(parseString, ISO_8601);\n    }\n\n    if (!mathString.length) {\n      return time;\n    }\n\n    return parseDateMath(mathString, time, roundUp, fiscalYearStartMonth);\n  }\n}\n/**\n * Checks if text is a valid date which in this context means that it is either a Moment instance or it can be parsed\n * by parse function. See parse function to see what is considered acceptable.\n * @param text\n */\n\nexport function isValid(text) {\n  const date = parse(text);\n\n  if (!date) {\n    return false;\n  }\n\n  if (isDateTime(date)) {\n    return date.isValid();\n  }\n\n  return false;\n}\n/**\n * Parses math part of the time string and shifts supplied time according to that math. See unit tests for examples.\n * @param mathString\n * @param time\n * @param roundUp If true it will round the time to endOf time unit, otherwise to startOf time unit.\n */\n// TODO: Had to revert Andrejs `time: moment.Moment` to `time: any`\n\nexport function parseDateMath(mathString, time, roundUp, fiscalYearStartMonth = 0) {\n  const strippedMathString = mathString.replace(/\\s/g, '');\n  const dateTime = time;\n  let i = 0;\n  const len = strippedMathString.length;\n\n  while (i < len) {\n    const c = strippedMathString.charAt(i++);\n    let type;\n    let num;\n    let unit;\n    let isFiscal = false;\n\n    if (c === '/') {\n      type = 0;\n    } else if (c === '+') {\n      type = 1;\n    } else if (c === '-') {\n      type = 2;\n    } else {\n      return undefined;\n    }\n\n    if (isNaN(parseInt(strippedMathString.charAt(i), 10))) {\n      num = 1;\n    } else if (strippedMathString.length === 2) {\n      num = parseInt(strippedMathString.charAt(i), 10);\n    } else {\n      const numFrom = i;\n\n      while (!isNaN(parseInt(strippedMathString.charAt(i), 10))) {\n        i++;\n\n        if (i > 10) {\n          return undefined;\n        }\n      }\n\n      num = parseInt(strippedMathString.substring(numFrom, i), 10);\n    }\n\n    if (type === 0) {\n      // rounding is only allowed on whole, single, units (eg M or 1M, not 0.5M or 2M)\n      if (num !== 1) {\n        return undefined;\n      }\n    }\n\n    unit = strippedMathString.charAt(i++);\n\n    if (unit === 'f') {\n      unit = strippedMathString.charAt(i++);\n      isFiscal = true;\n    }\n\n    if (!includes(units, unit)) {\n      return undefined;\n    } else {\n      if (type === 0) {\n        if (roundUp) {\n          if (isFiscal) {\n            roundToFiscal(fiscalYearStartMonth, dateTime, unit, roundUp);\n          } else {\n            dateTime.endOf(unit);\n          }\n        } else {\n          if (isFiscal) {\n            roundToFiscal(fiscalYearStartMonth, dateTime, unit, roundUp);\n          } else {\n            dateTime.startOf(unit);\n          }\n        }\n      } else if (type === 1) {\n        dateTime.add(num, unit);\n      } else if (type === 2) {\n        dateTime.subtract(num, unit);\n      }\n    }\n  }\n\n  return dateTime;\n}\nexport function roundToFiscal(fyStartMonth, dateTime, unit, roundUp) {\n  switch (unit) {\n    case 'y':\n      if (roundUp) {\n        roundToFiscal(fyStartMonth, dateTime, unit, false).add(11, 'M').endOf('M');\n      } else {\n        dateTime.subtract((dateTime.month() - fyStartMonth + 12) % 12, 'M').startOf('M');\n      }\n\n      return dateTime;\n\n    case 'Q':\n      if (roundUp) {\n        roundToFiscal(fyStartMonth, dateTime, unit, false).add(2, 'M').endOf('M');\n      } else {\n        dateTime.subtract((dateTime.month() - fyStartMonth + 3) % 3, 'M').startOf('M');\n      }\n\n      return dateTime;\n\n    default:\n      return undefined;\n  }\n}","map":{"version":3,"names":["includes","isDate","dateTime","dateTimeForTimeZone","isDateTime","ISO_8601","units","isMathString","text","substring","parse","roundUp","timezone","fiscalYearStartMonth","undefined","time","mathString","index","parseString","length","indexOf","parseDateMath","isValid","date","strippedMathString","replace","i","len","c","charAt","type","num","unit","isFiscal","isNaN","parseInt","numFrom","roundToFiscal","endOf","startOf","add","subtract","fyStartMonth","month"],"sources":["/home/soula/grafana/packages/grafana-data/src/datetime/datemath.ts"],"sourcesContent":["import { includes, isDate } from 'lodash';\n\nimport { TimeZone } from '../types/index';\n\nimport { DateTime, dateTime, dateTimeForTimeZone, DurationUnit, isDateTime, ISO_8601 } from './moment_wrapper';\n\nconst units: DurationUnit[] = ['y', 'M', 'w', 'd', 'h', 'm', 's', 'Q'];\n\n/**\n * Determine if a string contains a relative date time.\n * @param text\n */\nexport function isMathString(text: string | DateTime | Date): boolean {\n  if (!text) {\n    return false;\n  }\n\n  if (typeof text === 'string' && (text.substring(0, 3) === 'now' || text.includes('||'))) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Parses different types input to a moment instance. There is a specific formatting language that can be used\n * if text arg is string. See unit tests for examples.\n * @param text\n * @param roundUp See parseDateMath function.\n * @param timezone Only string 'utc' is acceptable here, for anything else, local timezone is used.\n */\nexport function parse(\n  text?: string | DateTime | Date | null,\n  roundUp?: boolean,\n  timezone?: TimeZone,\n  fiscalYearStartMonth?: number\n): DateTime | undefined {\n  if (!text) {\n    return undefined;\n  }\n\n  if (typeof text !== 'string') {\n    if (isDateTime(text)) {\n      return text;\n    }\n    if (isDate(text)) {\n      return dateTime(text);\n    }\n    // We got some non string which is not a moment nor Date. TS should be able to check for that but not always.\n    return undefined;\n  } else {\n    let time;\n    let mathString = '';\n    let index;\n    let parseString;\n\n    if (text.substring(0, 3) === 'now') {\n      time = dateTimeForTimeZone(timezone);\n      mathString = text.substring('now'.length);\n    } else {\n      index = text.indexOf('||');\n      if (index === -1) {\n        parseString = text;\n        mathString = ''; // nothing else\n      } else {\n        parseString = text.substring(0, index);\n        mathString = text.substring(index + 2);\n      }\n      // We're going to just require ISO8601 timestamps, k?\n      time = dateTime(parseString, ISO_8601);\n    }\n\n    if (!mathString.length) {\n      return time;\n    }\n\n    return parseDateMath(mathString, time, roundUp, fiscalYearStartMonth);\n  }\n}\n\n/**\n * Checks if text is a valid date which in this context means that it is either a Moment instance or it can be parsed\n * by parse function. See parse function to see what is considered acceptable.\n * @param text\n */\nexport function isValid(text: string | DateTime): boolean {\n  const date = parse(text);\n  if (!date) {\n    return false;\n  }\n\n  if (isDateTime(date)) {\n    return date.isValid();\n  }\n\n  return false;\n}\n\n/**\n * Parses math part of the time string and shifts supplied time according to that math. See unit tests for examples.\n * @param mathString\n * @param time\n * @param roundUp If true it will round the time to endOf time unit, otherwise to startOf time unit.\n */\n// TODO: Had to revert Andrejs `time: moment.Moment` to `time: any`\nexport function parseDateMath(\n  mathString: string,\n  time: any,\n  roundUp?: boolean,\n  fiscalYearStartMonth = 0\n): DateTime | undefined {\n  const strippedMathString = mathString.replace(/\\s/g, '');\n  const dateTime = time;\n  let i = 0;\n  const len = strippedMathString.length;\n\n  while (i < len) {\n    const c = strippedMathString.charAt(i++);\n    let type;\n    let num;\n    let unit;\n    let isFiscal = false;\n\n    if (c === '/') {\n      type = 0;\n    } else if (c === '+') {\n      type = 1;\n    } else if (c === '-') {\n      type = 2;\n    } else {\n      return undefined;\n    }\n\n    if (isNaN(parseInt(strippedMathString.charAt(i), 10))) {\n      num = 1;\n    } else if (strippedMathString.length === 2) {\n      num = parseInt(strippedMathString.charAt(i), 10);\n    } else {\n      const numFrom = i;\n      while (!isNaN(parseInt(strippedMathString.charAt(i), 10))) {\n        i++;\n        if (i > 10) {\n          return undefined;\n        }\n      }\n      num = parseInt(strippedMathString.substring(numFrom, i), 10);\n    }\n\n    if (type === 0) {\n      // rounding is only allowed on whole, single, units (eg M or 1M, not 0.5M or 2M)\n      if (num !== 1) {\n        return undefined;\n      }\n    }\n    unit = strippedMathString.charAt(i++);\n\n    if (unit === 'f') {\n      unit = strippedMathString.charAt(i++);\n      isFiscal = true;\n    }\n\n    if (!includes(units, unit)) {\n      return undefined;\n    } else {\n      if (type === 0) {\n        if (roundUp) {\n          if (isFiscal) {\n            roundToFiscal(fiscalYearStartMonth, dateTime, unit, roundUp);\n          } else {\n            dateTime.endOf(unit);\n          }\n        } else {\n          if (isFiscal) {\n            roundToFiscal(fiscalYearStartMonth, dateTime, unit, roundUp);\n          } else {\n            dateTime.startOf(unit);\n          }\n        }\n      } else if (type === 1) {\n        dateTime.add(num, unit);\n      } else if (type === 2) {\n        dateTime.subtract(num, unit);\n      }\n    }\n  }\n  return dateTime;\n}\n\nexport function roundToFiscal(fyStartMonth: number, dateTime: any, unit: string, roundUp: boolean | undefined) {\n  switch (unit) {\n    case 'y':\n      if (roundUp) {\n        roundToFiscal(fyStartMonth, dateTime, unit, false).add(11, 'M').endOf('M');\n      } else {\n        dateTime.subtract((dateTime.month() - fyStartMonth + 12) % 12, 'M').startOf('M');\n      }\n      return dateTime;\n    case 'Q':\n      if (roundUp) {\n        roundToFiscal(fyStartMonth, dateTime, unit, false).add(2, 'M').endOf('M');\n      } else {\n        dateTime.subtract((dateTime.month() - fyStartMonth + 3) % 3, 'M').startOf('M');\n      }\n      return dateTime;\n    default:\n      return undefined;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}