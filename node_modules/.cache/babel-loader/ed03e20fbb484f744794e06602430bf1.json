{"ast":null,"code":"const _excluded = [\"query\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { isString } from 'lodash';\nimport { of } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { AnnotationEventFieldSource, FieldType, getFieldDisplayName, standardTransformers } from '@grafana/data';\nexport const standardAnnotationSupport = {\n  /**\n   * Assume the stored value is standard model.\n   */\n  prepareAnnotation: json => {\n    if (isString(json === null || json === void 0 ? void 0 : json.query)) {\n      const {\n        query\n      } = json,\n            rest = _objectWithoutPropertiesLoose(json, _excluded);\n\n      return Object.assign({}, rest, {\n        target: {\n          refId: 'annotation_query',\n          query\n        },\n        mappings: {}\n      });\n    }\n\n    return json;\n  },\n\n  /**\n   * Default will just return target from the annotation.\n   */\n  prepareQuery: anno => anno.target,\n\n  /**\n   * Provides default processing from dataFrame to annotation events.\n   */\n  processEvents: (anno, data) => {\n    return getAnnotationsFromData(data, anno.mappings);\n  }\n};\n/**\n * Flatten all frames into a single frame with mergeTransformer.\n */\n\nexport function singleFrameFromPanelData() {\n  return source => source.pipe(mergeMap(data => {\n    if (!(data !== null && data !== void 0 && data.length)) {\n      return of(undefined);\n    }\n\n    if (data.length === 1) {\n      return of(data[0]);\n    }\n\n    return of(data).pipe(standardTransformers.mergeTransformer.operator({}), map(d => d[0]));\n  }));\n}\n// These fields get added to the standard UI\nexport const annotationEventNames = [{\n  key: 'time',\n  field: frame => frame.fields.find(f => f.type === FieldType.time),\n  placeholder: 'time, or the first time field'\n}, {\n  key: 'timeEnd',\n  help: 'When this field is defined, the annotation will be treated as a range'\n}, {\n  key: 'title'\n}, {\n  key: 'text',\n  field: frame => frame.fields.find(f => f.type === FieldType.string),\n  placeholder: 'text, or the first text field'\n}, {\n  key: 'tags',\n  split: ',',\n  help: 'The results will be split on comma (,)'\n}, {\n  key: 'id'\n}]; // Given legacy infrastructure, alert events are passed though the same annotation\n// pipeline, but include fields that should not be exposed generally\n\nconst alertEventAndAnnotationFields = [...annotationEventNames, {\n  key: 'userId'\n}, {\n  key: 'login'\n}, {\n  key: 'email'\n}, {\n  key: 'prevState'\n}, {\n  key: 'newState'\n}, {\n  key: 'data'\n}, {\n  key: 'panelId'\n}, {\n  key: 'alertId'\n}, {\n  key: 'dashboardId'\n}];\nexport function getAnnotationsFromData(data, options) {\n  return of(data).pipe(singleFrameFromPanelData(), map(frame => {\n    if (!(frame !== null && frame !== void 0 && frame.length)) {\n      return [];\n    }\n\n    let hasTime = false;\n    let hasText = false;\n    const byName = {};\n\n    for (const f of frame.fields) {\n      const name = getFieldDisplayName(f, frame);\n      byName[name.toLowerCase()] = f;\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const fields = [];\n\n    for (const evts of alertEventAndAnnotationFields) {\n      const opt = options[evts.key] || {}; //AnnotationEventFieldMapping\n\n      if (opt.source === AnnotationEventFieldSource.Skip) {\n        continue;\n      }\n\n      const setter = {\n        key: evts.key,\n        split: evts.split\n      };\n\n      if (opt.source === AnnotationEventFieldSource.Text) {\n        setter.text = opt.value;\n      } else {\n        const lower = (opt.value || evts.key).toLowerCase();\n        setter.field = byName[lower];\n\n        if (!setter.field && evts.field) {\n          setter.field = evts.field(frame);\n        }\n      }\n\n      if (setter.field || setter.text) {\n        fields.push(setter);\n\n        if (setter.key === 'time') {\n          hasTime = true;\n        } else if (setter.key === 'text') {\n          hasText = true;\n        }\n      }\n    }\n\n    if (!hasTime || !hasText) {\n      return []; // throw an error?\n    } // Add each value to the string\n\n\n    const events = [];\n\n    for (let i = 0; i < frame.length; i++) {\n      const anno = {\n        type: 'default',\n        color: 'red'\n      };\n\n      for (const f of fields) {\n        let v = undefined;\n\n        if (f.text) {\n          v = f.text; // TODO support templates!\n        } else if (f.field) {\n          v = f.field.values.get(i);\n\n          if (v !== undefined && f.regex) {\n            const match = f.regex.exec(v);\n\n            if (match) {\n              v = match[1] ? match[1] : match[0];\n            }\n          }\n        }\n\n        if (v !== null && v !== undefined) {\n          if (f.split && typeof v === 'string') {\n            v = v.split(',');\n          }\n\n          anno[f.key] = v;\n        }\n      }\n\n      events.push(anno);\n    }\n\n    return events;\n  }));\n} // These opt outs are here only for quicker and easier migration to react based annotations editors and because\n// annotation support API needs some work to support less \"standard\" editors like prometheus and here it is not\n// polluting public API.\n\nconst legacyRunner = ['prometheus', 'loki', 'elasticsearch', 'grafana-opensearch-datasource' // external\n];\n/**\n * Opt out of using the default mapping functionality on frontend.\n */\n\nexport function shouldUseMappingUI(datasource) {\n  const {\n    type\n  } = datasource;\n  return !(type === 'datasource' || //  ODD behavior for \"-- Grafana --\" datasource\n  legacyRunner.includes(type));\n}\n/**\n * Use legacy runner. Used only as an escape hatch for easier transition to React based annotation editor.\n */\n\nexport function shouldUseLegacyRunner(datasource) {\n  const {\n    type\n  } = datasource;\n  return legacyRunner.includes(type);\n}","map":{"version":3,"names":["isString","of","map","mergeMap","AnnotationEventFieldSource","FieldType","getFieldDisplayName","standardTransformers","standardAnnotationSupport","prepareAnnotation","json","query","rest","target","refId","mappings","prepareQuery","anno","processEvents","data","getAnnotationsFromData","singleFrameFromPanelData","source","pipe","length","undefined","mergeTransformer","operator","d","annotationEventNames","key","field","frame","fields","find","f","type","time","placeholder","help","string","split","alertEventAndAnnotationFields","options","hasTime","hasText","byName","name","toLowerCase","evts","opt","Skip","setter","Text","text","value","lower","push","events","i","color","v","values","get","regex","match","exec","legacyRunner","shouldUseMappingUI","datasource","includes","shouldUseLegacyRunner"],"sources":["/home/soula/grafana/public/app/features/annotations/standardAnnotationSupport.ts"],"sourcesContent":["import { isString } from 'lodash';\nimport { Observable, of, OperatorFunction } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\n\nimport {\n  AnnotationEvent,\n  AnnotationEventFieldSource,\n  AnnotationEventMappings,\n  AnnotationQuery,\n  AnnotationSupport,\n  DataFrame,\n  DataSourceApi,\n  Field,\n  FieldType,\n  getFieldDisplayName,\n  KeyValue,\n  standardTransformers,\n} from '@grafana/data';\n\nexport const standardAnnotationSupport: AnnotationSupport = {\n  /**\n   * Assume the stored value is standard model.\n   */\n  prepareAnnotation: (json: any) => {\n    if (isString(json?.query)) {\n      const { query, ...rest } = json;\n      return {\n        ...rest,\n        target: {\n          refId: 'annotation_query',\n          query,\n        },\n        mappings: {},\n      };\n    }\n    return json as AnnotationQuery;\n  },\n\n  /**\n   * Default will just return target from the annotation.\n   */\n  prepareQuery: (anno: AnnotationQuery) => anno.target,\n\n  /**\n   * Provides default processing from dataFrame to annotation events.\n   */\n  processEvents: (anno: AnnotationQuery, data: DataFrame[]) => {\n    return getAnnotationsFromData(data, anno.mappings);\n  },\n};\n\n/**\n * Flatten all frames into a single frame with mergeTransformer.\n */\n\nexport function singleFrameFromPanelData(): OperatorFunction<DataFrame[], DataFrame | undefined> {\n  return (source) =>\n    source.pipe(\n      mergeMap((data) => {\n        if (!data?.length) {\n          return of(undefined);\n        }\n\n        if (data.length === 1) {\n          return of(data[0]);\n        }\n\n        return of(data).pipe(\n          standardTransformers.mergeTransformer.operator({}),\n          map((d) => d[0])\n        );\n      })\n    );\n}\n\ninterface AnnotationEventFieldSetter {\n  key: keyof AnnotationEvent;\n  field?: Field;\n  text?: string;\n  regex?: RegExp;\n  split?: string; // for tags\n}\n\nexport interface AnnotationFieldInfo {\n  key: keyof AnnotationEvent;\n\n  split?: string;\n  field?: (frame: DataFrame) => Field | undefined;\n  placeholder?: string;\n  help?: string;\n}\n\n// These fields get added to the standard UI\nexport const annotationEventNames: AnnotationFieldInfo[] = [\n  {\n    key: 'time',\n    field: (frame: DataFrame) => frame.fields.find((f) => f.type === FieldType.time),\n    placeholder: 'time, or the first time field',\n  },\n  { key: 'timeEnd', help: 'When this field is defined, the annotation will be treated as a range' },\n  {\n    key: 'title',\n  },\n  {\n    key: 'text',\n    field: (frame: DataFrame) => frame.fields.find((f) => f.type === FieldType.string),\n    placeholder: 'text, or the first text field',\n  },\n  { key: 'tags', split: ',', help: 'The results will be split on comma (,)' },\n  {\n    key: 'id',\n  },\n];\n\n// Given legacy infrastructure, alert events are passed though the same annotation\n// pipeline, but include fields that should not be exposed generally\nconst alertEventAndAnnotationFields: AnnotationFieldInfo[] = [\n  ...annotationEventNames,\n  { key: 'userId' },\n  { key: 'login' },\n  { key: 'email' },\n  { key: 'prevState' },\n  { key: 'newState' },\n  { key: 'data' as any },\n  { key: 'panelId' },\n  { key: 'alertId' },\n  { key: 'dashboardId' },\n];\n\nexport function getAnnotationsFromData(\n  data: DataFrame[],\n  options?: AnnotationEventMappings\n): Observable<AnnotationEvent[]> {\n  return of(data).pipe(\n    singleFrameFromPanelData(),\n    map((frame) => {\n      if (!frame?.length) {\n        return [];\n      }\n\n      let hasTime = false;\n      let hasText = false;\n      const byName: KeyValue<Field> = {};\n\n      for (const f of frame.fields) {\n        const name = getFieldDisplayName(f, frame);\n        byName[name.toLowerCase()] = f;\n      }\n\n      if (!options) {\n        options = {};\n      }\n\n      const fields: AnnotationEventFieldSetter[] = [];\n\n      for (const evts of alertEventAndAnnotationFields) {\n        const opt = options[evts.key] || {}; //AnnotationEventFieldMapping\n\n        if (opt.source === AnnotationEventFieldSource.Skip) {\n          continue;\n        }\n\n        const setter: AnnotationEventFieldSetter = { key: evts.key, split: evts.split };\n\n        if (opt.source === AnnotationEventFieldSource.Text) {\n          setter.text = opt.value;\n        } else {\n          const lower = (opt.value || evts.key).toLowerCase();\n          setter.field = byName[lower];\n\n          if (!setter.field && evts.field) {\n            setter.field = evts.field(frame);\n          }\n        }\n\n        if (setter.field || setter.text) {\n          fields.push(setter);\n          if (setter.key === 'time') {\n            hasTime = true;\n          } else if (setter.key === 'text') {\n            hasText = true;\n          }\n        }\n      }\n\n      if (!hasTime || !hasText) {\n        return []; // throw an error?\n      }\n\n      // Add each value to the string\n      const events: AnnotationEvent[] = [];\n\n      for (let i = 0; i < frame.length; i++) {\n        const anno: AnnotationEvent = {\n          type: 'default',\n          color: 'red',\n        };\n\n        for (const f of fields) {\n          let v: any = undefined;\n\n          if (f.text) {\n            v = f.text; // TODO support templates!\n          } else if (f.field) {\n            v = f.field.values.get(i);\n            if (v !== undefined && f.regex) {\n              const match = f.regex.exec(v);\n              if (match) {\n                v = match[1] ? match[1] : match[0];\n              }\n            }\n          }\n\n          if (v !== null && v !== undefined) {\n            if (f.split && typeof v === 'string') {\n              v = v.split(',');\n            }\n            (anno as any)[f.key] = v;\n          }\n        }\n\n        events.push(anno);\n      }\n\n      return events;\n    })\n  );\n}\n\n// These opt outs are here only for quicker and easier migration to react based annotations editors and because\n// annotation support API needs some work to support less \"standard\" editors like prometheus and here it is not\n// polluting public API.\n\nconst legacyRunner = [\n  'prometheus',\n  'loki',\n  'elasticsearch',\n  'grafana-opensearch-datasource', // external\n];\n\n/**\n * Opt out of using the default mapping functionality on frontend.\n */\nexport function shouldUseMappingUI(datasource: DataSourceApi): boolean {\n  const { type } = datasource;\n  return !(\n    type === 'datasource' || //  ODD behavior for \"-- Grafana --\" datasource\n    legacyRunner.includes(type)\n  );\n}\n\n/**\n * Use legacy runner. Used only as an escape hatch for easier transition to React based annotation editor.\n */\nexport function shouldUseLegacyRunner(datasource: DataSourceApi): boolean {\n  const { type } = datasource;\n  return legacyRunner.includes(type);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}