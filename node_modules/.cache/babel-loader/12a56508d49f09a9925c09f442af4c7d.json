{"ast":null,"code":"var _Alert, _Alert2;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { PureComponent } from 'react';\nimport { dataFrameFromJSON, rangeUtil } from '@grafana/data';\nimport { config, getBackendSrv, getDataSourceSrv } from '@grafana/runtime';\nimport { InlineField, Select, Alert, Input, InlineFieldRow } from '@grafana/ui';\nimport { hasAlphaPanels } from 'app/core/config';\nimport { defaultQuery, GrafanaQueryType } from '../types';\nimport SearchEditor from './SearchEditor';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nconst labelWidth = 12;\nexport class QueryEditor extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"state\", {\n      channels: [],\n      channelFields: {}\n    });\n\n    _defineProperty(this, \"queryTypes\", [{\n      label: 'Random Walk',\n      value: GrafanaQueryType.RandomWalk,\n      description: 'Random signal within the selected time range'\n    }, {\n      label: 'Live Measurements',\n      value: GrafanaQueryType.LiveMeasurements,\n      description: 'Stream real-time measurements from Grafana'\n    }, {\n      label: 'List public files',\n      value: GrafanaQueryType.List,\n      description: 'Show directory listings for public resources'\n    }]);\n\n    _defineProperty(this, \"onQueryTypeChange\", sel => {\n      const {\n        onChange,\n        query,\n        onRunQuery\n      } = this.props;\n      onChange(Object.assign({}, query, {\n        queryType: sel.value\n      }));\n      onRunQuery(); // Reload the channel list\n\n      this.loadChannelInfo();\n    });\n\n    _defineProperty(this, \"onChannelChange\", sel => {\n      const {\n        onChange,\n        query,\n        onRunQuery\n      } = this.props;\n      onChange(Object.assign({}, query, {\n        channel: sel === null || sel === void 0 ? void 0 : sel.value\n      }));\n      onRunQuery();\n    });\n\n    _defineProperty(this, \"onFieldNamesChange\", item => {\n      var _query$filter, _query$filter$fields;\n\n      const {\n        onChange,\n        query,\n        onRunQuery\n      } = this.props;\n      let fields = [];\n\n      if (Array.isArray(item)) {\n        fields = item.map(v => v.value);\n      } else if (item.value) {\n        fields = [item.value];\n      } // When adding the first field, also add time (if it exists)\n\n\n      if (fields.length === 1 && !((_query$filter = query.filter) !== null && _query$filter !== void 0 && (_query$filter$fields = _query$filter.fields) !== null && _query$filter$fields !== void 0 && _query$filter$fields.length) && query.channel) {\n        var _this$state$channelFi;\n\n        const names = (_this$state$channelFi = this.state.channelFields[query.channel]) !== null && _this$state$channelFi !== void 0 ? _this$state$channelFi : [];\n        const tf = names.find(f => f.value === 'time' || f.value === 'Time');\n\n        if (tf && tf.value && tf.value !== fields[0]) {\n          fields = [tf.value, ...fields];\n        }\n      }\n\n      onChange(Object.assign({}, query, {\n        filter: Object.assign({}, query.filter, {\n          fields\n        })\n      }));\n      onRunQuery();\n    });\n\n    _defineProperty(this, \"checkAndUpdateValue\", (key, txt) => {\n      const {\n        onChange,\n        query,\n        onRunQuery\n      } = this.props;\n\n      if (key === 'buffer') {\n        let buffer;\n\n        if (txt) {\n          try {\n            buffer = rangeUtil.intervalToSeconds(txt) * 1000;\n          } catch (err) {\n            console.warn('ERROR', err);\n          }\n        }\n\n        onChange(Object.assign({}, query, {\n          buffer\n        }));\n      } else {\n        onChange(Object.assign({}, query, {\n          [key]: txt\n        }));\n      }\n\n      onRunQuery();\n    });\n\n    _defineProperty(this, \"handleEnterKey\", e => {\n      if (e.key !== 'Enter') {\n        return;\n      }\n\n      this.checkAndUpdateValue('buffer', e.target.value);\n    });\n\n    _defineProperty(this, \"handleBlur\", e => {\n      this.checkAndUpdateValue('buffer', e.target.value);\n    });\n\n    _defineProperty(this, \"onFolderChanged\", sel => {\n      const {\n        onChange,\n        query,\n        onRunQuery\n      } = this.props;\n      onChange(Object.assign({}, query, {\n        path: sel === null || sel === void 0 ? void 0 : sel.value\n      }));\n      onRunQuery();\n    });\n\n    _defineProperty(this, \"onSearchChange\", search => {\n      const {\n        query,\n        onChange,\n        onRunQuery\n      } = this.props;\n      onChange(Object.assign({}, query, {\n        search\n      }));\n      onRunQuery();\n    });\n\n    if (config.featureToggles.panelTitleSearch && hasAlphaPanels) {\n      this.queryTypes.push({\n        label: 'Search',\n        value: GrafanaQueryType.Search,\n        description: 'Search for grafana resources'\n      });\n    }\n  }\n\n  loadChannelInfo() {\n    getBackendSrv().fetch({\n      url: 'api/live/list'\n    }).subscribe({\n      next: v => {\n        var _v$data;\n\n        const channelInfo = (_v$data = v.data) === null || _v$data === void 0 ? void 0 : _v$data.channels;\n\n        if (channelInfo !== null && channelInfo !== void 0 && channelInfo.length) {\n          const channelFields = {};\n          const channels = channelInfo.map(c => {\n            if (c.data) {\n              const distinctFields = new Set();\n              const frame = dataFrameFromJSON(c.data);\n\n              for (const f of frame.fields) {\n                distinctFields.add(f.name);\n              }\n\n              channelFields[c.channel] = Array.from(distinctFields).map(n => ({\n                value: n,\n                label: n\n              }));\n            }\n\n            return {\n              value: c.channel,\n              label: c.channel + ' [' + c.minute_rate + ' msg/min]'\n            };\n          });\n          this.setState({\n            channelFields,\n            channels\n          });\n        }\n      }\n    });\n  }\n\n  loadFolderInfo() {\n    const query = {\n      targets: [{\n        queryType: GrafanaQueryType.List,\n        refId: 'A'\n      }]\n    };\n    getDataSourceSrv().get('-- Grafana --').then(ds => {\n      const gds = ds;\n      gds.query(query).subscribe({\n        next: rsp => {\n          if (rsp.data.length) {\n            const names = rsp.data[0].fields[0];\n            const folders = names.values.toArray().map(v => ({\n              value: v,\n              label: v\n            }));\n            this.setState({\n              folders\n            });\n          }\n        }\n      });\n    });\n  }\n\n  componentDidMount() {\n    this.loadChannelInfo();\n  }\n\n  renderMeasurementsQuery() {\n    var _channelFields$channe;\n\n    let {\n      channel,\n      filter,\n      buffer\n    } = this.props.query;\n    let {\n      channels,\n      channelFields\n    } = this.state;\n    let currentChannel = channels.find(c => c.value === channel);\n\n    if (channel && !currentChannel) {\n      currentChannel = {\n        value: channel,\n        label: channel,\n        description: `Connected to ${channel}`\n      };\n      channels = [currentChannel, ...channels];\n    }\n\n    const distinctFields = new Set();\n    const fields = channel ? (_channelFields$channe = channelFields[channel]) !== null && _channelFields$channe !== void 0 ? _channelFields$channe : [] : []; // if (data && data.series?.length) {\n    //   for (const frame of data.series) {\n    //     for (const field of frame.fields) {\n    //       if (distinctFields.has(field.name) || !field.name) {\n    //         continue;\n    //       }\n    //       fields.push({\n    //         value: field.name,\n    //         label: field.name,\n    //         description: `(${getFrameDisplayName(frame)} / ${field.type})`,\n    //       });\n    //       distinctFields.add(field.name);\n    //     }\n    //   }\n    // }\n\n    if (filter !== null && filter !== void 0 && filter.fields) {\n      for (const f of filter.fields) {\n        if (!distinctFields.has(f)) {\n          fields.push({\n            value: f,\n            label: `${f} (not loaded)`,\n            description: `Configured, but not found in the query results`\n          });\n          distinctFields.add(f);\n        }\n      }\n    }\n\n    let formattedTime = '';\n\n    if (buffer) {\n      formattedTime = rangeUtil.secondsToHms(buffer / 1000);\n    }\n\n    return /*#__PURE__*/_jsxs(_Fragment, {\n      children: [/*#__PURE__*/_jsx(\"div\", {\n        className: \"gf-form\",\n        children: /*#__PURE__*/_jsx(InlineField, {\n          label: \"Channel\",\n          grow: true,\n          labelWidth: labelWidth,\n          children: /*#__PURE__*/_jsx(Select, {\n            options: channels,\n            value: currentChannel || '',\n            onChange: this.onChannelChange,\n            allowCustomValue: true,\n            backspaceRemovesValue: true,\n            placeholder: \"Select measurements channel\",\n            isClearable: true,\n            noOptionsMessage: \"Enter channel name\",\n            formatCreateLabel: input => `Connect to: ${input}`\n          })\n        })\n      }), channel && /*#__PURE__*/_jsxs(\"div\", {\n        className: \"gf-form\",\n        children: [/*#__PURE__*/_jsx(InlineField, {\n          label: \"Fields\",\n          grow: true,\n          labelWidth: labelWidth,\n          children: /*#__PURE__*/_jsx(Select, {\n            options: fields,\n            value: (filter === null || filter === void 0 ? void 0 : filter.fields) || [],\n            onChange: this.onFieldNamesChange,\n            allowCustomValue: true,\n            backspaceRemovesValue: true,\n            placeholder: \"All fields\",\n            isClearable: true,\n            noOptionsMessage: \"Unable to list all fields\",\n            formatCreateLabel: input => `Field: ${input}`,\n            isSearchable: true,\n            isMulti: true\n          })\n        }), /*#__PURE__*/_jsx(InlineField, {\n          label: \"Buffer\",\n          children: /*#__PURE__*/_jsx(Input, {\n            placeholder: \"Auto\",\n            width: 12,\n            defaultValue: formattedTime,\n            onKeyDown: this.handleEnterKey,\n            onBlur: this.handleBlur,\n            spellCheck: false\n          })\n        })]\n      }), _Alert || (_Alert = /*#__PURE__*/_jsx(Alert, {\n        title: \"Grafana Live - Measurements\",\n        severity: \"info\",\n        children: \"This supports real-time event streams in Grafana core. This feature is under heavy development. Expect the interfaces and structures to change as this becomes more production ready.\"\n      }))]\n    });\n  }\n\n  renderListPublicFiles() {\n    let {\n      path\n    } = this.props.query;\n    let {\n      folders\n    } = this.state;\n\n    if (!folders) {\n      folders = [];\n      this.loadFolderInfo();\n    }\n\n    const currentFolder = folders.find(f => f.value === path);\n\n    if (path && !currentFolder) {\n      folders = [...folders, {\n        value: path,\n        label: path\n      }];\n    }\n\n    return /*#__PURE__*/_jsx(InlineFieldRow, {\n      children: /*#__PURE__*/_jsx(InlineField, {\n        label: \"Path\",\n        grow: true,\n        labelWidth: labelWidth,\n        children: /*#__PURE__*/_jsx(Select, {\n          options: folders,\n          value: currentFolder || '',\n          onChange: this.onFolderChanged,\n          allowCustomValue: true,\n          backspaceRemovesValue: true,\n          placeholder: \"Select folder\",\n          isClearable: true,\n          formatCreateLabel: input => `Folder: ${input}`\n        })\n      })\n    });\n  }\n\n  render() {\n    var _query$search;\n\n    const query = Object.assign({}, defaultQuery, this.props.query);\n    const {\n      queryType\n    } = query;\n    return /*#__PURE__*/_jsxs(_Fragment, {\n      children: [queryType === GrafanaQueryType.Search && (_Alert2 || (_Alert2 = /*#__PURE__*/_jsx(Alert, {\n        title: \"Grafana Search\",\n        severity: \"info\",\n        children: \"Using this datasource to call the new search system is experimental, and subject to change at any time without notice.\"\n      }))), /*#__PURE__*/_jsx(InlineFieldRow, {\n        children: /*#__PURE__*/_jsx(InlineField, {\n          label: \"Query type\",\n          grow: true,\n          labelWidth: labelWidth,\n          children: /*#__PURE__*/_jsx(Select, {\n            options: this.queryTypes,\n            value: this.queryTypes.find(v => v.value === queryType) || this.queryTypes[0],\n            onChange: this.onQueryTypeChange\n          })\n        })\n      }), queryType === GrafanaQueryType.LiveMeasurements && this.renderMeasurementsQuery(), queryType === GrafanaQueryType.List && this.renderListPublicFiles(), queryType === GrafanaQueryType.Search && /*#__PURE__*/_jsx(SearchEditor, {\n        value: (_query$search = query.search) !== null && _query$search !== void 0 ? _query$search : {},\n        onChange: this.onSearchChange\n      })]\n    });\n  }\n\n}","map":{"version":3,"names":["React","PureComponent","dataFrameFromJSON","rangeUtil","config","getBackendSrv","getDataSourceSrv","InlineField","Select","Alert","Input","InlineFieldRow","hasAlphaPanels","defaultQuery","GrafanaQueryType","SearchEditor","labelWidth","QueryEditor","constructor","props","channels","channelFields","label","value","RandomWalk","description","LiveMeasurements","List","sel","onChange","query","onRunQuery","queryType","loadChannelInfo","channel","item","fields","Array","isArray","map","v","length","filter","names","state","tf","find","f","key","txt","buffer","intervalToSeconds","err","console","warn","e","checkAndUpdateValue","target","path","search","featureToggles","panelTitleSearch","queryTypes","push","Search","fetch","url","subscribe","next","channelInfo","data","c","distinctFields","Set","frame","add","name","from","n","minute_rate","setState","loadFolderInfo","targets","refId","get","then","ds","gds","rsp","folders","values","toArray","componentDidMount","renderMeasurementsQuery","currentChannel","has","formattedTime","secondsToHms","onChannelChange","input","onFieldNamesChange","handleEnterKey","handleBlur","renderListPublicFiles","currentFolder","onFolderChanged","render","onQueryTypeChange","onSearchChange"],"sources":["/home/soula/grafana/public/app/plugins/datasource/grafana/components/QueryEditor.tsx"],"sourcesContent":["import React, { PureComponent } from 'react';\n\nimport {\n  QueryEditorProps,\n  SelectableValue,\n  dataFrameFromJSON,\n  rangeUtil,\n  DataQueryRequest,\n  DataFrame,\n} from '@grafana/data';\nimport { config, getBackendSrv, getDataSourceSrv } from '@grafana/runtime';\nimport { InlineField, Select, Alert, Input, InlineFieldRow } from '@grafana/ui';\nimport { hasAlphaPanels } from 'app/core/config';\nimport { SearchQuery } from 'app/features/search/service';\n\nimport { GrafanaDatasource } from '../datasource';\nimport { defaultQuery, GrafanaQuery, GrafanaQueryType } from '../types';\n\nimport SearchEditor from './SearchEditor';\n\ntype Props = QueryEditorProps<GrafanaDatasource, GrafanaQuery>;\n\nconst labelWidth = 12;\n\ninterface State {\n  channels: Array<SelectableValue<string>>;\n  channelFields: Record<string, Array<SelectableValue<string>>>;\n  folders?: Array<SelectableValue<string>>;\n}\n\nexport class QueryEditor extends PureComponent<Props, State> {\n  state: State = { channels: [], channelFields: {} };\n\n  queryTypes: Array<SelectableValue<GrafanaQueryType>> = [\n    {\n      label: 'Random Walk',\n      value: GrafanaQueryType.RandomWalk,\n      description: 'Random signal within the selected time range',\n    },\n    {\n      label: 'Live Measurements',\n      value: GrafanaQueryType.LiveMeasurements,\n      description: 'Stream real-time measurements from Grafana',\n    },\n    {\n      label: 'List public files',\n      value: GrafanaQueryType.List,\n      description: 'Show directory listings for public resources',\n    },\n  ];\n\n  constructor(props: Props) {\n    super(props);\n\n    if (config.featureToggles.panelTitleSearch && hasAlphaPanels) {\n      this.queryTypes.push({\n        label: 'Search',\n        value: GrafanaQueryType.Search,\n        description: 'Search for grafana resources',\n      });\n    }\n  }\n\n  loadChannelInfo() {\n    getBackendSrv()\n      .fetch({ url: 'api/live/list' })\n      .subscribe({\n        next: (v: any) => {\n          const channelInfo = v.data?.channels as any[];\n          if (channelInfo?.length) {\n            const channelFields: Record<string, Array<SelectableValue<string>>> = {};\n            const channels: Array<SelectableValue<string>> = channelInfo.map((c) => {\n              if (c.data) {\n                const distinctFields = new Set<string>();\n                const frame = dataFrameFromJSON(c.data);\n                for (const f of frame.fields) {\n                  distinctFields.add(f.name);\n                }\n                channelFields[c.channel] = Array.from(distinctFields).map((n) => ({\n                  value: n,\n                  label: n,\n                }));\n              }\n              return {\n                value: c.channel,\n                label: c.channel + ' [' + c.minute_rate + ' msg/min]',\n              };\n            });\n\n            this.setState({ channelFields, channels });\n          }\n        },\n      });\n  }\n\n  loadFolderInfo() {\n    const query: DataQueryRequest<GrafanaQuery> = {\n      targets: [{ queryType: GrafanaQueryType.List, refId: 'A' }],\n    } as any;\n\n    getDataSourceSrv()\n      .get('-- Grafana --')\n      .then((ds) => {\n        const gds = ds as GrafanaDatasource;\n        gds.query(query).subscribe({\n          next: (rsp) => {\n            if (rsp.data.length) {\n              const names = (rsp.data[0] as DataFrame).fields[0];\n              const folders = names.values.toArray().map((v) => ({\n                value: v,\n                label: v,\n              }));\n              this.setState({ folders });\n            }\n          },\n        });\n      });\n  }\n\n  componentDidMount() {\n    this.loadChannelInfo();\n  }\n\n  onQueryTypeChange = (sel: SelectableValue<GrafanaQueryType>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, queryType: sel.value! });\n    onRunQuery();\n\n    // Reload the channel list\n    this.loadChannelInfo();\n  };\n\n  onChannelChange = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, channel: sel?.value });\n    onRunQuery();\n  };\n\n  onFieldNamesChange = (item: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    let fields: string[] = [];\n    if (Array.isArray(item)) {\n      fields = item.map((v) => v.value);\n    } else if (item.value) {\n      fields = [item.value];\n    }\n\n    // When adding the first field, also add time (if it exists)\n    if (fields.length === 1 && !query.filter?.fields?.length && query.channel) {\n      const names = this.state.channelFields[query.channel] ?? [];\n      const tf = names.find((f) => f.value === 'time' || f.value === 'Time');\n      if (tf && tf.value && tf.value !== fields[0]) {\n        fields = [tf.value, ...fields];\n      }\n    }\n\n    onChange({\n      ...query,\n      filter: {\n        ...query.filter,\n        fields,\n      },\n    });\n    onRunQuery();\n  };\n\n  checkAndUpdateValue = (key: keyof GrafanaQuery, txt: string) => {\n    const { onChange, query, onRunQuery } = this.props;\n    if (key === 'buffer') {\n      let buffer: number | undefined;\n      if (txt) {\n        try {\n          buffer = rangeUtil.intervalToSeconds(txt) * 1000;\n        } catch (err) {\n          console.warn('ERROR', err);\n        }\n      }\n      onChange({\n        ...query,\n        buffer,\n      });\n    } else {\n      onChange({\n        ...query,\n        [key]: txt,\n      });\n    }\n    onRunQuery();\n  };\n\n  handleEnterKey = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key !== 'Enter') {\n      return;\n    }\n    this.checkAndUpdateValue('buffer', (e.target as any).value);\n  };\n\n  handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    this.checkAndUpdateValue('buffer', e.target.value);\n  };\n\n  renderMeasurementsQuery() {\n    let { channel, filter, buffer } = this.props.query;\n    let { channels, channelFields } = this.state;\n    let currentChannel = channels.find((c) => c.value === channel);\n    if (channel && !currentChannel) {\n      currentChannel = {\n        value: channel,\n        label: channel,\n        description: `Connected to ${channel}`,\n      };\n      channels = [currentChannel, ...channels];\n    }\n\n    const distinctFields = new Set<string>();\n    const fields: Array<SelectableValue<string>> = channel ? channelFields[channel] ?? [] : [];\n    // if (data && data.series?.length) {\n    //   for (const frame of data.series) {\n    //     for (const field of frame.fields) {\n    //       if (distinctFields.has(field.name) || !field.name) {\n    //         continue;\n    //       }\n    //       fields.push({\n    //         value: field.name,\n    //         label: field.name,\n    //         description: `(${getFrameDisplayName(frame)} / ${field.type})`,\n    //       });\n    //       distinctFields.add(field.name);\n    //     }\n    //   }\n    // }\n    if (filter?.fields) {\n      for (const f of filter.fields) {\n        if (!distinctFields.has(f)) {\n          fields.push({\n            value: f,\n            label: `${f} (not loaded)`,\n            description: `Configured, but not found in the query results`,\n          });\n          distinctFields.add(f);\n        }\n      }\n    }\n\n    let formattedTime = '';\n    if (buffer) {\n      formattedTime = rangeUtil.secondsToHms(buffer / 1000);\n    }\n\n    return (\n      <>\n        <div className=\"gf-form\">\n          <InlineField label=\"Channel\" grow={true} labelWidth={labelWidth}>\n            <Select\n              options={channels}\n              value={currentChannel || ''}\n              onChange={this.onChannelChange}\n              allowCustomValue={true}\n              backspaceRemovesValue={true}\n              placeholder=\"Select measurements channel\"\n              isClearable={true}\n              noOptionsMessage=\"Enter channel name\"\n              formatCreateLabel={(input: string) => `Connect to: ${input}`}\n            />\n          </InlineField>\n        </div>\n        {channel && (\n          <div className=\"gf-form\">\n            <InlineField label=\"Fields\" grow={true} labelWidth={labelWidth}>\n              <Select\n                options={fields}\n                value={filter?.fields || []}\n                onChange={this.onFieldNamesChange}\n                allowCustomValue={true}\n                backspaceRemovesValue={true}\n                placeholder=\"All fields\"\n                isClearable={true}\n                noOptionsMessage=\"Unable to list all fields\"\n                formatCreateLabel={(input: string) => `Field: ${input}`}\n                isSearchable={true}\n                isMulti={true}\n              />\n            </InlineField>\n            <InlineField label=\"Buffer\">\n              <Input\n                placeholder=\"Auto\"\n                width={12}\n                defaultValue={formattedTime}\n                onKeyDown={this.handleEnterKey}\n                onBlur={this.handleBlur}\n                spellCheck={false}\n              />\n            </InlineField>\n          </div>\n        )}\n\n        <Alert title=\"Grafana Live - Measurements\" severity=\"info\">\n          This supports real-time event streams in Grafana core. This feature is under heavy development. Expect the\n          interfaces and structures to change as this becomes more production ready.\n        </Alert>\n      </>\n    );\n  }\n\n  onFolderChanged = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, path: sel?.value });\n    onRunQuery();\n  };\n\n  renderListPublicFiles() {\n    let { path } = this.props.query;\n    let { folders } = this.state;\n    if (!folders) {\n      folders = [];\n      this.loadFolderInfo();\n    }\n    const currentFolder = folders.find((f) => f.value === path);\n    if (path && !currentFolder) {\n      folders = [\n        ...folders,\n        {\n          value: path,\n          label: path,\n        },\n      ];\n    }\n\n    return (\n      <InlineFieldRow>\n        <InlineField label=\"Path\" grow={true} labelWidth={labelWidth}>\n          <Select\n            options={folders}\n            value={currentFolder || ''}\n            onChange={this.onFolderChanged}\n            allowCustomValue={true}\n            backspaceRemovesValue={true}\n            placeholder=\"Select folder\"\n            isClearable={true}\n            formatCreateLabel={(input: string) => `Folder: ${input}`}\n          />\n        </InlineField>\n      </InlineFieldRow>\n    );\n  }\n\n  onSearchChange = (search: SearchQuery) => {\n    const { query, onChange, onRunQuery } = this.props;\n\n    onChange({\n      ...query,\n      search,\n    });\n    onRunQuery();\n  };\n\n  render() {\n    const query = {\n      ...defaultQuery,\n      ...this.props.query,\n    };\n\n    const { queryType } = query;\n\n    return (\n      <>\n        {queryType === GrafanaQueryType.Search && (\n          <Alert title=\"Grafana Search\" severity=\"info\">\n            Using this datasource to call the new search system is experimental, and subject to change at any time\n            without notice.\n          </Alert>\n        )}\n        <InlineFieldRow>\n          <InlineField label=\"Query type\" grow={true} labelWidth={labelWidth}>\n            <Select\n              options={this.queryTypes}\n              value={this.queryTypes.find((v) => v.value === queryType) || this.queryTypes[0]}\n              onChange={this.onQueryTypeChange}\n            />\n          </InlineField>\n        </InlineFieldRow>\n        {queryType === GrafanaQueryType.LiveMeasurements && this.renderMeasurementsQuery()}\n        {queryType === GrafanaQueryType.List && this.renderListPublicFiles()}\n        {queryType === GrafanaQueryType.Search && (\n          <SearchEditor value={query.search ?? {}} onChange={this.onSearchChange} />\n        )}\n      </>\n    );\n  }\n}\n"],"mappings":";;;;AAAA,OAAOA,KAAP,IAAgBC,aAAhB,QAAqC,OAArC;AAEA,SAGEC,iBAHF,EAIEC,SAJF,QAOO,eAPP;AAQA,SAASC,MAAT,EAAiBC,aAAjB,EAAgCC,gBAAhC,QAAwD,kBAAxD;AACA,SAASC,WAAT,EAAsBC,MAAtB,EAA8BC,KAA9B,EAAqCC,KAArC,EAA4CC,cAA5C,QAAkE,aAAlE;AACA,SAASC,cAAT,QAA+B,iBAA/B;AAIA,SAASC,YAAT,EAAqCC,gBAArC,QAA6D,UAA7D;AAEA,OAAOC,YAAP,MAAyB,gBAAzB;;;;AAIA,MAAMC,UAAU,GAAG,EAAnB;AAQA,OAAO,MAAMC,WAAN,SAA0BhB,aAA1B,CAAsD;EAqB3DiB,WAAW,CAACC,KAAD,EAAe;IACxB,MAAMA,KAAN;;IADwB,+BApBX;MAAEC,QAAQ,EAAE,EAAZ;MAAgBC,aAAa,EAAE;IAA/B,CAoBW;;IAAA,oCAlB6B,CACrD;MACEC,KAAK,EAAE,aADT;MAEEC,KAAK,EAAET,gBAAgB,CAACU,UAF1B;MAGEC,WAAW,EAAE;IAHf,CADqD,EAMrD;MACEH,KAAK,EAAE,mBADT;MAEEC,KAAK,EAAET,gBAAgB,CAACY,gBAF1B;MAGED,WAAW,EAAE;IAHf,CANqD,EAWrD;MACEH,KAAK,EAAE,mBADT;MAEEC,KAAK,EAAET,gBAAgB,CAACa,IAF1B;MAGEF,WAAW,EAAE;IAHf,CAXqD,CAkB7B;;IAAA,2CAwELG,GAAD,IAA4C;MAC9D,MAAM;QAAEC,QAAF;QAAYC,KAAZ;QAAmBC;MAAnB,IAAkC,KAAKZ,KAA7C;MACAU,QAAQ,mBAAMC,KAAN;QAAaE,SAAS,EAAEJ,GAAG,CAACL;MAA5B,GAAR;MACAQ,UAAU,GAHoD,CAK9D;;MACA,KAAKE,eAAL;IACD,CA/EyB;;IAAA,yCAiFPL,GAAD,IAAkC;MAClD,MAAM;QAAEC,QAAF;QAAYC,KAAZ;QAAmBC;MAAnB,IAAkC,KAAKZ,KAA7C;MACAU,QAAQ,mBAAMC,KAAN;QAAaI,OAAO,EAAEN,GAAF,aAAEA,GAAF,uBAAEA,GAAG,CAAEL;MAA3B,GAAR;MACAQ,UAAU;IACX,CArFyB;;IAAA,4CAuFJI,IAAD,IAAmC;MAAA;;MACtD,MAAM;QAAEN,QAAF;QAAYC,KAAZ;QAAmBC;MAAnB,IAAkC,KAAKZ,KAA7C;MACA,IAAIiB,MAAgB,GAAG,EAAvB;;MACA,IAAIC,KAAK,CAACC,OAAN,CAAcH,IAAd,CAAJ,EAAyB;QACvBC,MAAM,GAAGD,IAAI,CAACI,GAAL,CAAUC,CAAD,IAAOA,CAAC,CAACjB,KAAlB,CAAT;MACD,CAFD,MAEO,IAAIY,IAAI,CAACZ,KAAT,EAAgB;QACrBa,MAAM,GAAG,CAACD,IAAI,CAACZ,KAAN,CAAT;MACD,CAPqD,CAStD;;;MACA,IAAIa,MAAM,CAACK,MAAP,KAAkB,CAAlB,IAAuB,mBAACX,KAAK,CAACY,MAAP,kEAAC,cAAcN,MAAf,iDAAC,qBAAsBK,MAAvB,CAAvB,IAAwDX,KAAK,CAACI,OAAlE,EAA2E;QAAA;;QACzE,MAAMS,KAAK,4BAAG,KAAKC,KAAL,CAAWvB,aAAX,CAAyBS,KAAK,CAACI,OAA/B,CAAH,yEAA8C,EAAzD;QACA,MAAMW,EAAE,GAAGF,KAAK,CAACG,IAAN,CAAYC,CAAD,IAAOA,CAAC,CAACxB,KAAF,KAAY,MAAZ,IAAsBwB,CAAC,CAACxB,KAAF,KAAY,MAApD,CAAX;;QACA,IAAIsB,EAAE,IAAIA,EAAE,CAACtB,KAAT,IAAkBsB,EAAE,CAACtB,KAAH,KAAaa,MAAM,CAAC,CAAD,CAAzC,EAA8C;UAC5CA,MAAM,GAAG,CAACS,EAAE,CAACtB,KAAJ,EAAW,GAAGa,MAAd,CAAT;QACD;MACF;;MAEDP,QAAQ,mBACHC,KADG;QAENY,MAAM,oBACDZ,KAAK,CAACY,MADL;UAEJN;QAFI;MAFA,GAAR;MAOAL,UAAU;IACX,CAjHyB;;IAAA,6CAmHJ,CAACiB,GAAD,EAA0BC,GAA1B,KAA0C;MAC9D,MAAM;QAAEpB,QAAF;QAAYC,KAAZ;QAAmBC;MAAnB,IAAkC,KAAKZ,KAA7C;;MACA,IAAI6B,GAAG,KAAK,QAAZ,EAAsB;QACpB,IAAIE,MAAJ;;QACA,IAAID,GAAJ,EAAS;UACP,IAAI;YACFC,MAAM,GAAG/C,SAAS,CAACgD,iBAAV,CAA4BF,GAA5B,IAAmC,IAA5C;UACD,CAFD,CAEE,OAAOG,GAAP,EAAY;YACZC,OAAO,CAACC,IAAR,CAAa,OAAb,EAAsBF,GAAtB;UACD;QACF;;QACDvB,QAAQ,mBACHC,KADG;UAENoB;QAFM,GAAR;MAID,CAbD,MAaO;QACLrB,QAAQ,mBACHC,KADG;UAEN,CAACkB,GAAD,GAAOC;QAFD,GAAR;MAID;;MACDlB,UAAU;IACX,CAzIyB;;IAAA,wCA2IRwB,CAAD,IAA8C;MAC7D,IAAIA,CAAC,CAACP,GAAF,KAAU,OAAd,EAAuB;QACrB;MACD;;MACD,KAAKQ,mBAAL,CAAyB,QAAzB,EAAoCD,CAAC,CAACE,MAAH,CAAkBlC,KAArD;IACD,CAhJyB;;IAAA,oCAkJZgC,CAAD,IAA2C;MACtD,KAAKC,mBAAL,CAAyB,QAAzB,EAAmCD,CAAC,CAACE,MAAF,CAASlC,KAA5C;IACD,CApJyB;;IAAA,yCA6PPK,GAAD,IAAkC;MAClD,MAAM;QAAEC,QAAF;QAAYC,KAAZ;QAAmBC;MAAnB,IAAkC,KAAKZ,KAA7C;MACAU,QAAQ,mBAAMC,KAAN;QAAa4B,IAAI,EAAE9B,GAAF,aAAEA,GAAF,uBAAEA,GAAG,CAAEL;MAAxB,GAAR;MACAQ,UAAU;IACX,CAjQyB;;IAAA,wCAuSR4B,MAAD,IAAyB;MACxC,MAAM;QAAE7B,KAAF;QAASD,QAAT;QAAmBE;MAAnB,IAAkC,KAAKZ,KAA7C;MAEAU,QAAQ,mBACHC,KADG;QAEN6B;MAFM,GAAR;MAIA5B,UAAU;IACX,CA/SyB;;IAGxB,IAAI3B,MAAM,CAACwD,cAAP,CAAsBC,gBAAtB,IAA0CjD,cAA9C,EAA8D;MAC5D,KAAKkD,UAAL,CAAgBC,IAAhB,CAAqB;QACnBzC,KAAK,EAAE,QADY;QAEnBC,KAAK,EAAET,gBAAgB,CAACkD,MAFL;QAGnBvC,WAAW,EAAE;MAHM,CAArB;IAKD;EACF;;EAEDQ,eAAe,GAAG;IAChB5B,aAAa,GACV4D,KADH,CACS;MAAEC,GAAG,EAAE;IAAP,CADT,EAEGC,SAFH,CAEa;MACTC,IAAI,EAAG5B,CAAD,IAAY;QAAA;;QAChB,MAAM6B,WAAW,cAAG7B,CAAC,CAAC8B,IAAL,4CAAG,QAAQlD,QAA5B;;QACA,IAAIiD,WAAJ,aAAIA,WAAJ,eAAIA,WAAW,CAAE5B,MAAjB,EAAyB;UACvB,MAAMpB,aAA6D,GAAG,EAAtE;UACA,MAAMD,QAAwC,GAAGiD,WAAW,CAAC9B,GAAZ,CAAiBgC,CAAD,IAAO;YACtE,IAAIA,CAAC,CAACD,IAAN,EAAY;cACV,MAAME,cAAc,GAAG,IAAIC,GAAJ,EAAvB;cACA,MAAMC,KAAK,GAAGxE,iBAAiB,CAACqE,CAAC,CAACD,IAAH,CAA/B;;cACA,KAAK,MAAMvB,CAAX,IAAgB2B,KAAK,CAACtC,MAAtB,EAA8B;gBAC5BoC,cAAc,CAACG,GAAf,CAAmB5B,CAAC,CAAC6B,IAArB;cACD;;cACDvD,aAAa,CAACkD,CAAC,CAACrC,OAAH,CAAb,GAA2BG,KAAK,CAACwC,IAAN,CAAWL,cAAX,EAA2BjC,GAA3B,CAAgCuC,CAAD,KAAQ;gBAChEvD,KAAK,EAAEuD,CADyD;gBAEhExD,KAAK,EAAEwD;cAFyD,CAAR,CAA/B,CAA3B;YAID;;YACD,OAAO;cACLvD,KAAK,EAAEgD,CAAC,CAACrC,OADJ;cAELZ,KAAK,EAAEiD,CAAC,CAACrC,OAAF,GAAY,IAAZ,GAAmBqC,CAAC,CAACQ,WAArB,GAAmC;YAFrC,CAAP;UAID,CAhBgD,CAAjD;UAkBA,KAAKC,QAAL,CAAc;YAAE3D,aAAF;YAAiBD;UAAjB,CAAd;QACD;MACF;IAzBQ,CAFb;EA6BD;;EAED6D,cAAc,GAAG;IACf,MAAMnD,KAAqC,GAAG;MAC5CoD,OAAO,EAAE,CAAC;QAAElD,SAAS,EAAElB,gBAAgB,CAACa,IAA9B;QAAoCwD,KAAK,EAAE;MAA3C,CAAD;IADmC,CAA9C;IAIA7E,gBAAgB,GACb8E,GADH,CACO,eADP,EAEGC,IAFH,CAESC,EAAD,IAAQ;MACZ,MAAMC,GAAG,GAAGD,EAAZ;MACAC,GAAG,CAACzD,KAAJ,CAAUA,KAAV,EAAiBqC,SAAjB,CAA2B;QACzBC,IAAI,EAAGoB,GAAD,IAAS;UACb,IAAIA,GAAG,CAAClB,IAAJ,CAAS7B,MAAb,EAAqB;YACnB,MAAME,KAAK,GAAI6C,GAAG,CAAClB,IAAJ,CAAS,CAAT,CAAD,CAA2BlC,MAA3B,CAAkC,CAAlC,CAAd;YACA,MAAMqD,OAAO,GAAG9C,KAAK,CAAC+C,MAAN,CAAaC,OAAb,GAAuBpD,GAAvB,CAA4BC,CAAD,KAAQ;cACjDjB,KAAK,EAAEiB,CAD0C;cAEjDlB,KAAK,EAAEkB;YAF0C,CAAR,CAA3B,CAAhB;YAIA,KAAKwC,QAAL,CAAc;cAAES;YAAF,CAAd;UACD;QACF;MAVwB,CAA3B;IAYD,CAhBH;EAiBD;;EAEDG,iBAAiB,GAAG;IAClB,KAAK3D,eAAL;EACD;;EAgFD4D,uBAAuB,GAAG;IAAA;;IACxB,IAAI;MAAE3D,OAAF;MAAWQ,MAAX;MAAmBQ;IAAnB,IAA8B,KAAK/B,KAAL,CAAWW,KAA7C;IACA,IAAI;MAAEV,QAAF;MAAYC;IAAZ,IAA8B,KAAKuB,KAAvC;IACA,IAAIkD,cAAc,GAAG1E,QAAQ,CAAC0B,IAAT,CAAeyB,CAAD,IAAOA,CAAC,CAAChD,KAAF,KAAYW,OAAjC,CAArB;;IACA,IAAIA,OAAO,IAAI,CAAC4D,cAAhB,EAAgC;MAC9BA,cAAc,GAAG;QACfvE,KAAK,EAAEW,OADQ;QAEfZ,KAAK,EAAEY,OAFQ;QAGfT,WAAW,EAAG,gBAAeS,OAAQ;MAHtB,CAAjB;MAKAd,QAAQ,GAAG,CAAC0E,cAAD,EAAiB,GAAG1E,QAApB,CAAX;IACD;;IAED,MAAMoD,cAAc,GAAG,IAAIC,GAAJ,EAAvB;IACA,MAAMrC,MAAsC,GAAGF,OAAO,4BAAGb,aAAa,CAACa,OAAD,CAAhB,yEAA6B,EAA7B,GAAkC,EAAxF,CAdwB,CAexB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACA,IAAIQ,MAAJ,aAAIA,MAAJ,eAAIA,MAAM,CAAEN,MAAZ,EAAoB;MAClB,KAAK,MAAMW,CAAX,IAAgBL,MAAM,CAACN,MAAvB,EAA+B;QAC7B,IAAI,CAACoC,cAAc,CAACuB,GAAf,CAAmBhD,CAAnB,CAAL,EAA4B;UAC1BX,MAAM,CAAC2B,IAAP,CAAY;YACVxC,KAAK,EAAEwB,CADG;YAEVzB,KAAK,EAAG,GAAEyB,CAAE,eAFF;YAGVtB,WAAW,EAAG;UAHJ,CAAZ;UAKA+C,cAAc,CAACG,GAAf,CAAmB5B,CAAnB;QACD;MACF;IACF;;IAED,IAAIiD,aAAa,GAAG,EAApB;;IACA,IAAI9C,MAAJ,EAAY;MACV8C,aAAa,GAAG7F,SAAS,CAAC8F,YAAV,CAAuB/C,MAAM,GAAG,IAAhC,CAAhB;IACD;;IAED,oBACE;MAAA,wBACE;QAAK,SAAS,EAAC,SAAf;QAAA,uBACE,KAAC,WAAD;UAAa,KAAK,EAAC,SAAnB;UAA6B,IAAI,EAAE,IAAnC;UAAyC,UAAU,EAAElC,UAArD;UAAA,uBACE,KAAC,MAAD;YACE,OAAO,EAAEI,QADX;YAEE,KAAK,EAAE0E,cAAc,IAAI,EAF3B;YAGE,QAAQ,EAAE,KAAKI,eAHjB;YAIE,gBAAgB,EAAE,IAJpB;YAKE,qBAAqB,EAAE,IALzB;YAME,WAAW,EAAC,6BANd;YAOE,WAAW,EAAE,IAPf;YAQE,gBAAgB,EAAC,oBARnB;YASE,iBAAiB,EAAGC,KAAD,IAAoB,eAAcA,KAAM;UAT7D;QADF;MADF,EADF,EAgBGjE,OAAO,iBACN;QAAK,SAAS,EAAC,SAAf;QAAA,wBACE,KAAC,WAAD;UAAa,KAAK,EAAC,QAAnB;UAA4B,IAAI,EAAE,IAAlC;UAAwC,UAAU,EAAElB,UAApD;UAAA,uBACE,KAAC,MAAD;YACE,OAAO,EAAEoB,MADX;YAEE,KAAK,EAAE,CAAAM,MAAM,SAAN,IAAAA,MAAM,WAAN,YAAAA,MAAM,CAAEN,MAAR,KAAkB,EAF3B;YAGE,QAAQ,EAAE,KAAKgE,kBAHjB;YAIE,gBAAgB,EAAE,IAJpB;YAKE,qBAAqB,EAAE,IALzB;YAME,WAAW,EAAC,YANd;YAOE,WAAW,EAAE,IAPf;YAQE,gBAAgB,EAAC,2BARnB;YASE,iBAAiB,EAAGD,KAAD,IAAoB,UAASA,KAAM,EATxD;YAUE,YAAY,EAAE,IAVhB;YAWE,OAAO,EAAE;UAXX;QADF,EADF,eAgBE,KAAC,WAAD;UAAa,KAAK,EAAC,QAAnB;UAAA,uBACE,KAAC,KAAD;YACE,WAAW,EAAC,MADd;YAEE,KAAK,EAAE,EAFT;YAGE,YAAY,EAAEH,aAHhB;YAIE,SAAS,EAAE,KAAKK,cAJlB;YAKE,MAAM,EAAE,KAAKC,UALf;YAME,UAAU,EAAE;UANd;QADF,EAhBF;MAAA,EAjBJ,mCA8CE,KAAC,KAAD;QAAO,KAAK,EAAC,6BAAb;QAA2C,QAAQ,EAAC,MAApD;QAAA;MAAA,EA9CF;IAAA,EADF;EAqDD;;EAQDC,qBAAqB,GAAG;IACtB,IAAI;MAAE7C;IAAF,IAAW,KAAKvC,KAAL,CAAWW,KAA1B;IACA,IAAI;MAAE2D;IAAF,IAAc,KAAK7C,KAAvB;;IACA,IAAI,CAAC6C,OAAL,EAAc;MACZA,OAAO,GAAG,EAAV;MACA,KAAKR,cAAL;IACD;;IACD,MAAMuB,aAAa,GAAGf,OAAO,CAAC3C,IAAR,CAAcC,CAAD,IAAOA,CAAC,CAACxB,KAAF,KAAYmC,IAAhC,CAAtB;;IACA,IAAIA,IAAI,IAAI,CAAC8C,aAAb,EAA4B;MAC1Bf,OAAO,GAAG,CACR,GAAGA,OADK,EAER;QACElE,KAAK,EAAEmC,IADT;QAEEpC,KAAK,EAAEoC;MAFT,CAFQ,CAAV;IAOD;;IAED,oBACE,KAAC,cAAD;MAAA,uBACE,KAAC,WAAD;QAAa,KAAK,EAAC,MAAnB;QAA0B,IAAI,EAAE,IAAhC;QAAsC,UAAU,EAAE1C,UAAlD;QAAA,uBACE,KAAC,MAAD;UACE,OAAO,EAAEyE,OADX;UAEE,KAAK,EAAEe,aAAa,IAAI,EAF1B;UAGE,QAAQ,EAAE,KAAKC,eAHjB;UAIE,gBAAgB,EAAE,IAJpB;UAKE,qBAAqB,EAAE,IALzB;UAME,WAAW,EAAC,eANd;UAOE,WAAW,EAAE,IAPf;UAQE,iBAAiB,EAAGN,KAAD,IAAoB,WAAUA,KAAM;QARzD;MADF;IADF,EADF;EAgBD;;EAYDO,MAAM,GAAG;IAAA;;IACP,MAAM5E,KAAK,qBACNjB,YADM,EAEN,KAAKM,KAAL,CAAWW,KAFL,CAAX;IAKA,MAAM;MAAEE;IAAF,IAAgBF,KAAtB;IAEA,oBACE;MAAA,WACGE,SAAS,KAAKlB,gBAAgB,CAACkD,MAA/B,wCACC,KAAC,KAAD;QAAO,KAAK,EAAC,gBAAb;QAA8B,QAAQ,EAAC,MAAvC;QAAA;MAAA,EADD,EADH,eAOE,KAAC,cAAD;QAAA,uBACE,KAAC,WAAD;UAAa,KAAK,EAAC,YAAnB;UAAgC,IAAI,EAAE,IAAtC;UAA4C,UAAU,EAAEhD,UAAxD;UAAA,uBACE,KAAC,MAAD;YACE,OAAO,EAAE,KAAK8C,UADhB;YAEE,KAAK,EAAE,KAAKA,UAAL,CAAgBhB,IAAhB,CAAsBN,CAAD,IAAOA,CAAC,CAACjB,KAAF,KAAYS,SAAxC,KAAsD,KAAK8B,UAAL,CAAgB,CAAhB,CAF/D;YAGE,QAAQ,EAAE,KAAK6C;UAHjB;QADF;MADF,EAPF,EAgBG3E,SAAS,KAAKlB,gBAAgB,CAACY,gBAA/B,IAAmD,KAAKmE,uBAAL,EAhBtD,EAiBG7D,SAAS,KAAKlB,gBAAgB,CAACa,IAA/B,IAAuC,KAAK4E,qBAAL,EAjB1C,EAkBGvE,SAAS,KAAKlB,gBAAgB,CAACkD,MAA/B,iBACC,KAAC,YAAD;QAAc,KAAK,mBAAElC,KAAK,CAAC6B,MAAR,yDAAkB,EAArC;QAAyC,QAAQ,EAAE,KAAKiD;MAAxD,EAnBJ;IAAA,EADF;EAwBD;;AAtW0D"},"metadata":{},"sourceType":"module"}