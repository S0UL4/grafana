{"ast":null,"code":"import { isString } from 'lodash';\nimport { ALIGNMENT_PERIODS, SELECTORS } from './constants';\nimport { extractServicesFromMetricDescriptors, getAggregationOptionsByMetric, getAlignmentOptionsByMetric, getLabelKeys, getMetricTypesByService } from './functions';\nimport { MetricFindQueryTypes } from './types';\nexport default class CloudMonitoringMetricFindQuery {\n  constructor(datasource) {\n    this.datasource = datasource;\n  }\n\n  async execute(query) {\n    try {\n      if (!query.projectName) {\n        query.projectName = this.datasource.getDefaultProject();\n      }\n\n      switch (query.selectedQueryType) {\n        case MetricFindQueryTypes.Projects:\n          return this.handleProjectsQuery();\n\n        case MetricFindQueryTypes.Services:\n          return this.handleServiceQuery(query);\n\n        case MetricFindQueryTypes.MetricTypes:\n          return this.handleMetricTypesQuery(query);\n\n        case MetricFindQueryTypes.LabelKeys:\n          return this.handleLabelKeysQuery(query);\n\n        case MetricFindQueryTypes.LabelValues:\n          return this.handleLabelValuesQuery(query);\n\n        case MetricFindQueryTypes.ResourceTypes:\n          return this.handleResourceTypeQuery(query);\n\n        case MetricFindQueryTypes.Aligners:\n          return this.handleAlignersQuery(query);\n\n        case MetricFindQueryTypes.AlignmentPeriods:\n          return this.handleAlignmentPeriodQuery();\n\n        case MetricFindQueryTypes.Aggregations:\n          return this.handleAggregationQuery(query);\n\n        case MetricFindQueryTypes.SLOServices:\n          return this.handleSLOServicesQuery(query);\n\n        case MetricFindQueryTypes.SLO:\n          return this.handleSLOQuery(query);\n\n        case MetricFindQueryTypes.Selectors:\n          return this.handleSelectorQuery();\n\n        default:\n          return [];\n      }\n    } catch (error) {\n      console.error(`Could not run CloudMonitoringMetricFindQuery ${query}`, error);\n      return [];\n    }\n  }\n\n  async handleProjectsQuery() {\n    const projects = await this.datasource.getProjects();\n    return projects.map(s => ({\n      text: s.label,\n      value: s.value,\n      expandable: true\n    }));\n  }\n\n  async handleServiceQuery({\n    projectName\n  }) {\n    const metricDescriptors = await this.datasource.getMetricTypes(projectName);\n    const services = extractServicesFromMetricDescriptors(metricDescriptors);\n    return services.map(s => ({\n      text: s.serviceShortName,\n      value: s.service,\n      expandable: true\n    }));\n  }\n\n  async handleMetricTypesQuery({\n    selectedService,\n    projectName\n  }) {\n    if (!selectedService) {\n      return [];\n    }\n\n    const metricDescriptors = await this.datasource.getMetricTypes(projectName);\n    return getMetricTypesByService(metricDescriptors, this.datasource.templateSrv.replace(selectedService)).map(s => ({\n      text: s.displayName,\n      value: s.type,\n      expandable: true\n    }));\n  }\n\n  async handleLabelKeysQuery({\n    selectedMetricType,\n    projectName\n  }) {\n    if (!selectedMetricType) {\n      return [];\n    }\n\n    const labelKeys = await getLabelKeys(this.datasource, selectedMetricType, projectName);\n    return labelKeys.map(this.toFindQueryResult);\n  }\n\n  async handleLabelValuesQuery({\n    selectedMetricType,\n    labelKey,\n    projectName\n  }) {\n    if (!selectedMetricType) {\n      return [];\n    }\n\n    const refId = 'handleLabelValuesQuery'; // REDUCE_MEAN is needed so the groupBy is not ignored\n\n    const labels = await this.datasource.getLabels(selectedMetricType, refId, projectName, {\n      groupBys: [labelKey],\n      crossSeriesReducer: 'REDUCE_MEAN'\n    });\n    const interpolatedKey = this.datasource.templateSrv.replace(labelKey);\n    const values = labels.hasOwnProperty(interpolatedKey) ? labels[interpolatedKey] : [];\n    return values.map(this.toFindQueryResult);\n  }\n\n  async handleResourceTypeQuery({\n    selectedMetricType,\n    projectName\n  }) {\n    var _labels$resourceType, _labels$resourceType2;\n\n    if (!selectedMetricType) {\n      return [];\n    }\n\n    const refId = 'handleResourceTypeQueryQueryType';\n    const labels = await this.datasource.getLabels(selectedMetricType, refId, projectName);\n    return (_labels$resourceType = (_labels$resourceType2 = labels['resource.type']) === null || _labels$resourceType2 === void 0 ? void 0 : _labels$resourceType2.map(this.toFindQueryResult)) !== null && _labels$resourceType !== void 0 ? _labels$resourceType : [];\n  }\n\n  async handleAlignersQuery({\n    selectedMetricType,\n    projectName\n  }) {\n    if (!selectedMetricType) {\n      return [];\n    }\n\n    const metricDescriptors = await this.datasource.getMetricTypes(projectName);\n    const descriptor = metricDescriptors.find(m => m.type === this.datasource.templateSrv.replace(selectedMetricType));\n\n    if (!descriptor) {\n      return [];\n    }\n\n    return getAlignmentOptionsByMetric(descriptor.valueType, descriptor.metricKind).map(this.toFindQueryResult);\n  }\n\n  async handleAggregationQuery({\n    selectedMetricType,\n    projectName\n  }) {\n    if (!selectedMetricType) {\n      return [];\n    }\n\n    const metricDescriptors = await this.datasource.getMetricTypes(projectName);\n    const descriptor = metricDescriptors.find(m => m.type === this.datasource.templateSrv.replace(selectedMetricType));\n\n    if (!descriptor) {\n      return [];\n    }\n\n    return getAggregationOptionsByMetric(descriptor.valueType, descriptor.metricKind).map(this.toFindQueryResult);\n  }\n\n  async handleSLOServicesQuery({\n    projectName\n  }) {\n    const services = await this.datasource.getSLOServices(projectName);\n    return services.map(this.toFindQueryResult);\n  }\n\n  async handleSLOQuery({\n    selectedSLOService,\n    projectName\n  }) {\n    const slos = await this.datasource.getServiceLevelObjectives(projectName, selectedSLOService);\n    return slos.map(this.toFindQueryResult);\n  }\n\n  async handleSelectorQuery() {\n    return SELECTORS.map(this.toFindQueryResult);\n  }\n\n  handleAlignmentPeriodQuery() {\n    return ALIGNMENT_PERIODS.map(this.toFindQueryResult);\n  }\n\n  toFindQueryResult(x) {\n    return isString(x) ? {\n      text: x,\n      expandable: true\n    } : Object.assign({}, x, {\n      expandable: true\n    });\n  }\n\n}","map":{"version":3,"names":["isString","ALIGNMENT_PERIODS","SELECTORS","extractServicesFromMetricDescriptors","getAggregationOptionsByMetric","getAlignmentOptionsByMetric","getLabelKeys","getMetricTypesByService","MetricFindQueryTypes","CloudMonitoringMetricFindQuery","constructor","datasource","execute","query","projectName","getDefaultProject","selectedQueryType","Projects","handleProjectsQuery","Services","handleServiceQuery","MetricTypes","handleMetricTypesQuery","LabelKeys","handleLabelKeysQuery","LabelValues","handleLabelValuesQuery","ResourceTypes","handleResourceTypeQuery","Aligners","handleAlignersQuery","AlignmentPeriods","handleAlignmentPeriodQuery","Aggregations","handleAggregationQuery","SLOServices","handleSLOServicesQuery","SLO","handleSLOQuery","Selectors","handleSelectorQuery","error","console","projects","getProjects","map","s","text","label","value","expandable","metricDescriptors","getMetricTypes","services","serviceShortName","service","selectedService","templateSrv","replace","displayName","type","selectedMetricType","labelKeys","toFindQueryResult","labelKey","refId","labels","getLabels","groupBys","crossSeriesReducer","interpolatedKey","values","hasOwnProperty","descriptor","find","m","valueType","metricKind","getSLOServices","selectedSLOService","slos","getServiceLevelObjectives","x"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloud-monitoring/CloudMonitoringMetricFindQuery.ts"],"sourcesContent":["import { isString } from 'lodash';\n\nimport { SelectableValue } from '@grafana/data';\n\nimport { ALIGNMENT_PERIODS, SELECTORS } from './constants';\nimport CloudMonitoringDatasource from './datasource';\nimport {\n  extractServicesFromMetricDescriptors,\n  getAggregationOptionsByMetric,\n  getAlignmentOptionsByMetric,\n  getLabelKeys,\n  getMetricTypesByService,\n} from './functions';\nimport { CloudMonitoringVariableQuery, MetricDescriptor, MetricFindQueryTypes, MetricKind, ValueTypes } from './types';\n\nexport default class CloudMonitoringMetricFindQuery {\n  constructor(private datasource: CloudMonitoringDatasource) {}\n\n  async execute(query: CloudMonitoringVariableQuery) {\n    try {\n      if (!query.projectName) {\n        query.projectName = this.datasource.getDefaultProject();\n      }\n\n      switch (query.selectedQueryType) {\n        case MetricFindQueryTypes.Projects:\n          return this.handleProjectsQuery();\n        case MetricFindQueryTypes.Services:\n          return this.handleServiceQuery(query);\n        case MetricFindQueryTypes.MetricTypes:\n          return this.handleMetricTypesQuery(query);\n        case MetricFindQueryTypes.LabelKeys:\n          return this.handleLabelKeysQuery(query);\n        case MetricFindQueryTypes.LabelValues:\n          return this.handleLabelValuesQuery(query);\n        case MetricFindQueryTypes.ResourceTypes:\n          return this.handleResourceTypeQuery(query);\n        case MetricFindQueryTypes.Aligners:\n          return this.handleAlignersQuery(query);\n        case MetricFindQueryTypes.AlignmentPeriods:\n          return this.handleAlignmentPeriodQuery();\n        case MetricFindQueryTypes.Aggregations:\n          return this.handleAggregationQuery(query);\n        case MetricFindQueryTypes.SLOServices:\n          return this.handleSLOServicesQuery(query);\n        case MetricFindQueryTypes.SLO:\n          return this.handleSLOQuery(query);\n        case MetricFindQueryTypes.Selectors:\n          return this.handleSelectorQuery();\n        default:\n          return [];\n      }\n    } catch (error) {\n      console.error(`Could not run CloudMonitoringMetricFindQuery ${query}`, error);\n      return [];\n    }\n  }\n\n  async handleProjectsQuery() {\n    const projects = await this.datasource.getProjects();\n    return (projects as SelectableValue<string>).map((s: { label: string; value: string }) => ({\n      text: s.label,\n      value: s.value,\n      expandable: true,\n    }));\n  }\n\n  async handleServiceQuery({ projectName }: CloudMonitoringVariableQuery) {\n    const metricDescriptors = await this.datasource.getMetricTypes(projectName);\n    const services: MetricDescriptor[] = extractServicesFromMetricDescriptors(metricDescriptors);\n    return services.map((s) => ({\n      text: s.serviceShortName,\n      value: s.service,\n      expandable: true,\n    }));\n  }\n\n  async handleMetricTypesQuery({ selectedService, projectName }: CloudMonitoringVariableQuery) {\n    if (!selectedService) {\n      return [];\n    }\n    const metricDescriptors = await this.datasource.getMetricTypes(projectName);\n    return getMetricTypesByService(metricDescriptors, this.datasource.templateSrv.replace(selectedService)).map(\n      (s) => ({\n        text: s.displayName,\n        value: s.type,\n        expandable: true,\n      })\n    );\n  }\n\n  async handleLabelKeysQuery({ selectedMetricType, projectName }: CloudMonitoringVariableQuery) {\n    if (!selectedMetricType) {\n      return [];\n    }\n    const labelKeys = await getLabelKeys(this.datasource, selectedMetricType, projectName);\n    return labelKeys.map(this.toFindQueryResult);\n  }\n\n  async handleLabelValuesQuery({ selectedMetricType, labelKey, projectName }: CloudMonitoringVariableQuery) {\n    if (!selectedMetricType) {\n      return [];\n    }\n    const refId = 'handleLabelValuesQuery';\n    // REDUCE_MEAN is needed so the groupBy is not ignored\n    const labels = await this.datasource.getLabels(selectedMetricType, refId, projectName, {\n      groupBys: [labelKey],\n      crossSeriesReducer: 'REDUCE_MEAN',\n    });\n    const interpolatedKey = this.datasource.templateSrv.replace(labelKey);\n    const values = labels.hasOwnProperty(interpolatedKey) ? labels[interpolatedKey] : [];\n    return values.map(this.toFindQueryResult);\n  }\n\n  async handleResourceTypeQuery({ selectedMetricType, projectName }: CloudMonitoringVariableQuery) {\n    if (!selectedMetricType) {\n      return [];\n    }\n    const refId = 'handleResourceTypeQueryQueryType';\n    const labels = await this.datasource.getLabels(selectedMetricType, refId, projectName);\n    return labels['resource.type']?.map(this.toFindQueryResult) ?? [];\n  }\n\n  async handleAlignersQuery({ selectedMetricType, projectName }: CloudMonitoringVariableQuery) {\n    if (!selectedMetricType) {\n      return [];\n    }\n    const metricDescriptors = await this.datasource.getMetricTypes(projectName);\n    const descriptor = metricDescriptors.find(\n      (m) => m.type === this.datasource.templateSrv.replace(selectedMetricType)\n    );\n\n    if (!descriptor) {\n      return [];\n    }\n\n    return getAlignmentOptionsByMetric(descriptor.valueType, descriptor.metricKind).map(this.toFindQueryResult);\n  }\n\n  async handleAggregationQuery({ selectedMetricType, projectName }: CloudMonitoringVariableQuery) {\n    if (!selectedMetricType) {\n      return [];\n    }\n\n    const metricDescriptors = await this.datasource.getMetricTypes(projectName);\n    const descriptor = metricDescriptors.find(\n      (m) => m.type === this.datasource.templateSrv.replace(selectedMetricType)\n    );\n\n    if (!descriptor) {\n      return [];\n    }\n\n    return getAggregationOptionsByMetric(descriptor.valueType as ValueTypes, descriptor.metricKind as MetricKind).map(\n      this.toFindQueryResult\n    );\n  }\n\n  async handleSLOServicesQuery({ projectName }: CloudMonitoringVariableQuery) {\n    const services = await this.datasource.getSLOServices(projectName);\n    return services.map(this.toFindQueryResult);\n  }\n\n  async handleSLOQuery({ selectedSLOService, projectName }: CloudMonitoringVariableQuery) {\n    const slos = await this.datasource.getServiceLevelObjectives(projectName, selectedSLOService);\n    return slos.map(this.toFindQueryResult);\n  }\n\n  async handleSelectorQuery() {\n    return SELECTORS.map(this.toFindQueryResult);\n  }\n\n  handleAlignmentPeriodQuery() {\n    return ALIGNMENT_PERIODS.map(this.toFindQueryResult);\n  }\n\n  toFindQueryResult(x: any) {\n    return isString(x) ? { text: x, expandable: true } : { ...x, expandable: true };\n  }\n}\n"],"mappings":"AAAA,SAASA,QAAT,QAAyB,QAAzB;AAIA,SAASC,iBAAT,EAA4BC,SAA5B,QAA6C,aAA7C;AAEA,SACEC,oCADF,EAEEC,6BAFF,EAGEC,2BAHF,EAIEC,YAJF,EAKEC,uBALF,QAMO,aANP;AAOA,SAAyDC,oBAAzD,QAA6G,SAA7G;AAEA,eAAe,MAAMC,8BAAN,CAAqC;EAClDC,WAAW,CAASC,UAAT,EAAgD;IAAA,KAAvCA,UAAuC,GAAvCA,UAAuC;EAAE;;EAEhD,MAAPC,OAAO,CAACC,KAAD,EAAsC;IACjD,IAAI;MACF,IAAI,CAACA,KAAK,CAACC,WAAX,EAAwB;QACtBD,KAAK,CAACC,WAAN,GAAoB,KAAKH,UAAL,CAAgBI,iBAAhB,EAApB;MACD;;MAED,QAAQF,KAAK,CAACG,iBAAd;QACE,KAAKR,oBAAoB,CAACS,QAA1B;UACE,OAAO,KAAKC,mBAAL,EAAP;;QACF,KAAKV,oBAAoB,CAACW,QAA1B;UACE,OAAO,KAAKC,kBAAL,CAAwBP,KAAxB,CAAP;;QACF,KAAKL,oBAAoB,CAACa,WAA1B;UACE,OAAO,KAAKC,sBAAL,CAA4BT,KAA5B,CAAP;;QACF,KAAKL,oBAAoB,CAACe,SAA1B;UACE,OAAO,KAAKC,oBAAL,CAA0BX,KAA1B,CAAP;;QACF,KAAKL,oBAAoB,CAACiB,WAA1B;UACE,OAAO,KAAKC,sBAAL,CAA4Bb,KAA5B,CAAP;;QACF,KAAKL,oBAAoB,CAACmB,aAA1B;UACE,OAAO,KAAKC,uBAAL,CAA6Bf,KAA7B,CAAP;;QACF,KAAKL,oBAAoB,CAACqB,QAA1B;UACE,OAAO,KAAKC,mBAAL,CAAyBjB,KAAzB,CAAP;;QACF,KAAKL,oBAAoB,CAACuB,gBAA1B;UACE,OAAO,KAAKC,0BAAL,EAAP;;QACF,KAAKxB,oBAAoB,CAACyB,YAA1B;UACE,OAAO,KAAKC,sBAAL,CAA4BrB,KAA5B,CAAP;;QACF,KAAKL,oBAAoB,CAAC2B,WAA1B;UACE,OAAO,KAAKC,sBAAL,CAA4BvB,KAA5B,CAAP;;QACF,KAAKL,oBAAoB,CAAC6B,GAA1B;UACE,OAAO,KAAKC,cAAL,CAAoBzB,KAApB,CAAP;;QACF,KAAKL,oBAAoB,CAAC+B,SAA1B;UACE,OAAO,KAAKC,mBAAL,EAAP;;QACF;UACE,OAAO,EAAP;MA1BJ;IA4BD,CAjCD,CAiCE,OAAOC,KAAP,EAAc;MACdC,OAAO,CAACD,KAAR,CAAe,gDAA+C5B,KAAM,EAApE,EAAuE4B,KAAvE;MACA,OAAO,EAAP;IACD;EACF;;EAEwB,MAAnBvB,mBAAmB,GAAG;IAC1B,MAAMyB,QAAQ,GAAG,MAAM,KAAKhC,UAAL,CAAgBiC,WAAhB,EAAvB;IACA,OAAQD,QAAD,CAAsCE,GAAtC,CAA2CC,CAAD,KAA0C;MACzFC,IAAI,EAAED,CAAC,CAACE,KADiF;MAEzFC,KAAK,EAAEH,CAAC,CAACG,KAFgF;MAGzFC,UAAU,EAAE;IAH6E,CAA1C,CAA1C,CAAP;EAKD;;EAEuB,MAAlB9B,kBAAkB,CAAC;IAAEN;EAAF,CAAD,EAAgD;IACtE,MAAMqC,iBAAiB,GAAG,MAAM,KAAKxC,UAAL,CAAgByC,cAAhB,CAA+BtC,WAA/B,CAAhC;IACA,MAAMuC,QAA4B,GAAGlD,oCAAoC,CAACgD,iBAAD,CAAzE;IACA,OAAOE,QAAQ,CAACR,GAAT,CAAcC,CAAD,KAAQ;MAC1BC,IAAI,EAAED,CAAC,CAACQ,gBADkB;MAE1BL,KAAK,EAAEH,CAAC,CAACS,OAFiB;MAG1BL,UAAU,EAAE;IAHc,CAAR,CAAb,CAAP;EAKD;;EAE2B,MAAtB5B,sBAAsB,CAAC;IAAEkC,eAAF;IAAmB1C;EAAnB,CAAD,EAAiE;IAC3F,IAAI,CAAC0C,eAAL,EAAsB;MACpB,OAAO,EAAP;IACD;;IACD,MAAML,iBAAiB,GAAG,MAAM,KAAKxC,UAAL,CAAgByC,cAAhB,CAA+BtC,WAA/B,CAAhC;IACA,OAAOP,uBAAuB,CAAC4C,iBAAD,EAAoB,KAAKxC,UAAL,CAAgB8C,WAAhB,CAA4BC,OAA5B,CAAoCF,eAApC,CAApB,CAAvB,CAAiGX,GAAjG,CACJC,CAAD,KAAQ;MACNC,IAAI,EAAED,CAAC,CAACa,WADF;MAENV,KAAK,EAAEH,CAAC,CAACc,IAFH;MAGNV,UAAU,EAAE;IAHN,CAAR,CADK,CAAP;EAOD;;EAEyB,MAApB1B,oBAAoB,CAAC;IAAEqC,kBAAF;IAAsB/C;EAAtB,CAAD,EAAoE;IAC5F,IAAI,CAAC+C,kBAAL,EAAyB;MACvB,OAAO,EAAP;IACD;;IACD,MAAMC,SAAS,GAAG,MAAMxD,YAAY,CAAC,KAAKK,UAAN,EAAkBkD,kBAAlB,EAAsC/C,WAAtC,CAApC;IACA,OAAOgD,SAAS,CAACjB,GAAV,CAAc,KAAKkB,iBAAnB,CAAP;EACD;;EAE2B,MAAtBrC,sBAAsB,CAAC;IAAEmC,kBAAF;IAAsBG,QAAtB;IAAgClD;EAAhC,CAAD,EAA8E;IACxG,IAAI,CAAC+C,kBAAL,EAAyB;MACvB,OAAO,EAAP;IACD;;IACD,MAAMI,KAAK,GAAG,wBAAd,CAJwG,CAKxG;;IACA,MAAMC,MAAM,GAAG,MAAM,KAAKvD,UAAL,CAAgBwD,SAAhB,CAA0BN,kBAA1B,EAA8CI,KAA9C,EAAqDnD,WAArD,EAAkE;MACrFsD,QAAQ,EAAE,CAACJ,QAAD,CAD2E;MAErFK,kBAAkB,EAAE;IAFiE,CAAlE,CAArB;IAIA,MAAMC,eAAe,GAAG,KAAK3D,UAAL,CAAgB8C,WAAhB,CAA4BC,OAA5B,CAAoCM,QAApC,CAAxB;IACA,MAAMO,MAAM,GAAGL,MAAM,CAACM,cAAP,CAAsBF,eAAtB,IAAyCJ,MAAM,CAACI,eAAD,CAA/C,GAAmE,EAAlF;IACA,OAAOC,MAAM,CAAC1B,GAAP,CAAW,KAAKkB,iBAAhB,CAAP;EACD;;EAE4B,MAAvBnC,uBAAuB,CAAC;IAAEiC,kBAAF;IAAsB/C;EAAtB,CAAD,EAAoE;IAAA;;IAC/F,IAAI,CAAC+C,kBAAL,EAAyB;MACvB,OAAO,EAAP;IACD;;IACD,MAAMI,KAAK,GAAG,kCAAd;IACA,MAAMC,MAAM,GAAG,MAAM,KAAKvD,UAAL,CAAgBwD,SAAhB,CAA0BN,kBAA1B,EAA8CI,KAA9C,EAAqDnD,WAArD,CAArB;IACA,wDAAOoD,MAAM,CAAC,eAAD,CAAb,0DAAO,sBAAyBrB,GAAzB,CAA6B,KAAKkB,iBAAlC,CAAP,uEAA+D,EAA/D;EACD;;EAEwB,MAAnBjC,mBAAmB,CAAC;IAAE+B,kBAAF;IAAsB/C;EAAtB,CAAD,EAAoE;IAC3F,IAAI,CAAC+C,kBAAL,EAAyB;MACvB,OAAO,EAAP;IACD;;IACD,MAAMV,iBAAiB,GAAG,MAAM,KAAKxC,UAAL,CAAgByC,cAAhB,CAA+BtC,WAA/B,CAAhC;IACA,MAAM2D,UAAU,GAAGtB,iBAAiB,CAACuB,IAAlB,CAChBC,CAAD,IAAOA,CAAC,CAACf,IAAF,KAAW,KAAKjD,UAAL,CAAgB8C,WAAhB,CAA4BC,OAA5B,CAAoCG,kBAApC,CADD,CAAnB;;IAIA,IAAI,CAACY,UAAL,EAAiB;MACf,OAAO,EAAP;IACD;;IAED,OAAOpE,2BAA2B,CAACoE,UAAU,CAACG,SAAZ,EAAuBH,UAAU,CAACI,UAAlC,CAA3B,CAAyEhC,GAAzE,CAA6E,KAAKkB,iBAAlF,CAAP;EACD;;EAE2B,MAAtB7B,sBAAsB,CAAC;IAAE2B,kBAAF;IAAsB/C;EAAtB,CAAD,EAAoE;IAC9F,IAAI,CAAC+C,kBAAL,EAAyB;MACvB,OAAO,EAAP;IACD;;IAED,MAAMV,iBAAiB,GAAG,MAAM,KAAKxC,UAAL,CAAgByC,cAAhB,CAA+BtC,WAA/B,CAAhC;IACA,MAAM2D,UAAU,GAAGtB,iBAAiB,CAACuB,IAAlB,CAChBC,CAAD,IAAOA,CAAC,CAACf,IAAF,KAAW,KAAKjD,UAAL,CAAgB8C,WAAhB,CAA4BC,OAA5B,CAAoCG,kBAApC,CADD,CAAnB;;IAIA,IAAI,CAACY,UAAL,EAAiB;MACf,OAAO,EAAP;IACD;;IAED,OAAOrE,6BAA6B,CAACqE,UAAU,CAACG,SAAZ,EAAqCH,UAAU,CAACI,UAAhD,CAA7B,CAAuGhC,GAAvG,CACL,KAAKkB,iBADA,CAAP;EAGD;;EAE2B,MAAtB3B,sBAAsB,CAAC;IAAEtB;EAAF,CAAD,EAAgD;IAC1E,MAAMuC,QAAQ,GAAG,MAAM,KAAK1C,UAAL,CAAgBmE,cAAhB,CAA+BhE,WAA/B,CAAvB;IACA,OAAOuC,QAAQ,CAACR,GAAT,CAAa,KAAKkB,iBAAlB,CAAP;EACD;;EAEmB,MAAdzB,cAAc,CAAC;IAAEyC,kBAAF;IAAsBjE;EAAtB,CAAD,EAAoE;IACtF,MAAMkE,IAAI,GAAG,MAAM,KAAKrE,UAAL,CAAgBsE,yBAAhB,CAA0CnE,WAA1C,EAAuDiE,kBAAvD,CAAnB;IACA,OAAOC,IAAI,CAACnC,GAAL,CAAS,KAAKkB,iBAAd,CAAP;EACD;;EAEwB,MAAnBvB,mBAAmB,GAAG;IAC1B,OAAOtC,SAAS,CAAC2C,GAAV,CAAc,KAAKkB,iBAAnB,CAAP;EACD;;EAED/B,0BAA0B,GAAG;IAC3B,OAAO/B,iBAAiB,CAAC4C,GAAlB,CAAsB,KAAKkB,iBAA3B,CAAP;EACD;;EAEDA,iBAAiB,CAACmB,CAAD,EAAS;IACxB,OAAOlF,QAAQ,CAACkF,CAAD,CAAR,GAAc;MAAEnC,IAAI,EAAEmC,CAAR;MAAWhC,UAAU,EAAE;IAAvB,CAAd,qBAAmDgC,CAAnD;MAAsDhC,UAAU,EAAE;IAAlE,EAAP;EACD;;AAnKiD"},"metadata":{},"sourceType":"module"}