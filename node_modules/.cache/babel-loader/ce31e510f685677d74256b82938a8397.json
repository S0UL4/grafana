{"ast":null,"code":"import { isEqual } from 'lodash';\nimport React, { useEffect, useState } from 'react';\nimport { EditorList } from '@grafana/experimental';\nimport { MultiFilterItem } from './MultiFilterItem';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst multiFiltersToFilterConditions = filters => Object.keys(filters).map(key => ({\n  key,\n  value: filters[key],\n  operator: '='\n}));\n\nconst filterConditionsToMultiFilters = filters => {\n  const res = {};\n  filters.forEach(({\n    key,\n    value\n  }) => {\n    if (key && value) {\n      res[key] = value;\n    }\n  });\n  return res;\n};\n\nexport const MultiFilter = ({\n  filters,\n  onChange,\n  keyPlaceholder\n}) => {\n  const [items, setItems] = useState([]);\n  useEffect(() => setItems(filters ? multiFiltersToFilterConditions(filters) : []), [filters]);\n\n  const onFiltersChange = newItems => {\n    setItems(newItems); // The onChange event should only be triggered in the case there is a complete dimension object.\n    // So when a new key is added that does not yet have a value, it should not trigger an onChange event.\n\n    const newMultifilters = filterConditionsToMultiFilters(newItems);\n\n    if (!isEqual(newMultifilters, filters)) {\n      onChange(newMultifilters);\n    }\n  };\n\n  return /*#__PURE__*/_jsx(EditorList, {\n    items: items,\n    onChange: onFiltersChange,\n    renderItem: makeRenderFilter(keyPlaceholder)\n  });\n};\n\nfunction makeRenderFilter(keyPlaceholder) {\n  function renderFilter(item, onChange, onDelete) {\n    return /*#__PURE__*/_jsx(MultiFilterItem, {\n      filter: item,\n      onChange: item => onChange(item),\n      onDelete: onDelete,\n      keyPlaceholder: keyPlaceholder\n    });\n  }\n\n  return renderFilter;\n}","map":{"version":3,"names":["isEqual","React","useEffect","useState","EditorList","MultiFilterItem","multiFiltersToFilterConditions","filters","Object","keys","map","key","value","operator","filterConditionsToMultiFilters","res","forEach","MultiFilter","onChange","keyPlaceholder","items","setItems","onFiltersChange","newItems","newMultifilters","makeRenderFilter","renderFilter","item","onDelete"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/components/VariableQueryEditor/MultiFilter.tsx"],"sourcesContent":["import { isEqual } from 'lodash';\nimport React, { useEffect, useState } from 'react';\n\nimport { EditorList } from '@grafana/experimental';\n\nimport { MultiFilters } from '../../types';\n\nimport { MultiFilterItem } from './MultiFilterItem';\n\nexport interface Props {\n  filters?: MultiFilters;\n  onChange: (filters: MultiFilters) => void;\n  keyPlaceholder?: string;\n}\n\nexport interface MultiFilterCondition {\n  key?: string;\n  operator?: string;\n  value?: string[];\n}\n\nconst multiFiltersToFilterConditions = (filters: MultiFilters) =>\n  Object.keys(filters).map((key) => ({ key, value: filters[key], operator: '=' }));\n\nconst filterConditionsToMultiFilters = (filters: MultiFilterCondition[]) => {\n  const res: MultiFilters = {};\n  filters.forEach(({ key, value }) => {\n    if (key && value) {\n      res[key] = value;\n    }\n  });\n  return res;\n};\n\nexport const MultiFilter: React.FC<Props> = ({ filters, onChange, keyPlaceholder }) => {\n  const [items, setItems] = useState<MultiFilterCondition[]>([]);\n  useEffect(() => setItems(filters ? multiFiltersToFilterConditions(filters) : []), [filters]);\n  const onFiltersChange = (newItems: Array<Partial<MultiFilterCondition>>) => {\n    setItems(newItems);\n\n    // The onChange event should only be triggered in the case there is a complete dimension object.\n    // So when a new key is added that does not yet have a value, it should not trigger an onChange event.\n    const newMultifilters = filterConditionsToMultiFilters(newItems);\n    if (!isEqual(newMultifilters, filters)) {\n      onChange(newMultifilters);\n    }\n  };\n\n  return <EditorList items={items} onChange={onFiltersChange} renderItem={makeRenderFilter(keyPlaceholder)} />;\n};\n\nfunction makeRenderFilter(keyPlaceholder?: string) {\n  function renderFilter(\n    item: MultiFilterCondition,\n    onChange: (item: MultiFilterCondition) => void,\n    onDelete: () => void\n  ) {\n    return (\n      <MultiFilterItem\n        filter={item}\n        onChange={(item) => onChange(item)}\n        onDelete={onDelete}\n        keyPlaceholder={keyPlaceholder}\n      />\n    );\n  }\n  return renderFilter;\n}\n"],"mappings":"AAAA,SAASA,OAAT,QAAwB,QAAxB;AACA,OAAOC,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,QAA2C,OAA3C;AAEA,SAASC,UAAT,QAA2B,uBAA3B;AAIA,SAASC,eAAT,QAAgC,mBAAhC;;;AAcA,MAAMC,8BAA8B,GAAIC,OAAD,IACrCC,MAAM,CAACC,IAAP,CAAYF,OAAZ,EAAqBG,GAArB,CAA0BC,GAAD,KAAU;EAAEA,GAAF;EAAOC,KAAK,EAAEL,OAAO,CAACI,GAAD,CAArB;EAA4BE,QAAQ,EAAE;AAAtC,CAAV,CAAzB,CADF;;AAGA,MAAMC,8BAA8B,GAAIP,OAAD,IAAqC;EAC1E,MAAMQ,GAAiB,GAAG,EAA1B;EACAR,OAAO,CAACS,OAAR,CAAgB,CAAC;IAAEL,GAAF;IAAOC;EAAP,CAAD,KAAoB;IAClC,IAAID,GAAG,IAAIC,KAAX,EAAkB;MAChBG,GAAG,CAACJ,GAAD,CAAH,GAAWC,KAAX;IACD;EACF,CAJD;EAKA,OAAOG,GAAP;AACD,CARD;;AAUA,OAAO,MAAME,WAA4B,GAAG,CAAC;EAAEV,OAAF;EAAWW,QAAX;EAAqBC;AAArB,CAAD,KAA2C;EACrF,MAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBlB,QAAQ,CAAyB,EAAzB,CAAlC;EACAD,SAAS,CAAC,MAAMmB,QAAQ,CAACd,OAAO,GAAGD,8BAA8B,CAACC,OAAD,CAAjC,GAA6C,EAArD,CAAf,EAAyE,CAACA,OAAD,CAAzE,CAAT;;EACA,MAAMe,eAAe,GAAIC,QAAD,IAAoD;IAC1EF,QAAQ,CAACE,QAAD,CAAR,CAD0E,CAG1E;IACA;;IACA,MAAMC,eAAe,GAAGV,8BAA8B,CAACS,QAAD,CAAtD;;IACA,IAAI,CAACvB,OAAO,CAACwB,eAAD,EAAkBjB,OAAlB,CAAZ,EAAwC;MACtCW,QAAQ,CAACM,eAAD,CAAR;IACD;EACF,CATD;;EAWA,oBAAO,KAAC,UAAD;IAAY,KAAK,EAAEJ,KAAnB;IAA0B,QAAQ,EAAEE,eAApC;IAAqD,UAAU,EAAEG,gBAAgB,CAACN,cAAD;EAAjF,EAAP;AACD,CAfM;;AAiBP,SAASM,gBAAT,CAA0BN,cAA1B,EAAmD;EACjD,SAASO,YAAT,CACEC,IADF,EAEET,QAFF,EAGEU,QAHF,EAIE;IACA,oBACE,KAAC,eAAD;MACE,MAAM,EAAED,IADV;MAEE,QAAQ,EAAGA,IAAD,IAAUT,QAAQ,CAACS,IAAD,CAF9B;MAGE,QAAQ,EAAEC,QAHZ;MAIE,cAAc,EAAET;IAJlB,EADF;EAQD;;EACD,OAAOO,YAAP;AACD"},"metadata":{},"sourceType":"module"}