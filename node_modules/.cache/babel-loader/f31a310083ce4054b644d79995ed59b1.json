{"ast":null,"code":"// Libraries\nimport { isNumber } from 'lodash';\nimport { NullValueMode, FieldType } from '../types/index';\nimport { Registry } from '../utils/Registry';\nexport let ReducerID; // Internal function\n\n(function (ReducerID) {\n  ReducerID[\"sum\"] = \"sum\";\n  ReducerID[\"max\"] = \"max\";\n  ReducerID[\"min\"] = \"min\";\n  ReducerID[\"logmin\"] = \"logmin\";\n  ReducerID[\"mean\"] = \"mean\";\n  ReducerID[\"last\"] = \"last\";\n  ReducerID[\"first\"] = \"first\";\n  ReducerID[\"count\"] = \"count\";\n  ReducerID[\"range\"] = \"range\";\n  ReducerID[\"diff\"] = \"diff\";\n  ReducerID[\"diffperc\"] = \"diffperc\";\n  ReducerID[\"delta\"] = \"delta\";\n  ReducerID[\"step\"] = \"step\";\n  ReducerID[\"firstNotNull\"] = \"firstNotNull\";\n  ReducerID[\"lastNotNull\"] = \"lastNotNull\";\n  ReducerID[\"changeCount\"] = \"changeCount\";\n  ReducerID[\"distinctCount\"] = \"distinctCount\";\n  ReducerID[\"allIsZero\"] = \"allIsZero\";\n  ReducerID[\"allIsNull\"] = \"allIsNull\";\n  ReducerID[\"allValues\"] = \"allValues\";\n  ReducerID[\"uniqueValues\"] = \"uniqueValues\";\n})(ReducerID || (ReducerID = {}));\n\n/**\n * @returns an object with a key for each selected stat\n * NOTE: This will also modify the 'field.state' object,\n * leaving values in a cache until cleared.\n */\nexport function reduceField(options) {\n  var _field$state;\n\n  const {\n    field,\n    reducers\n  } = options;\n\n  if (!field || !reducers || reducers.length < 1) {\n    return {};\n  }\n\n  if ((_field$state = field.state) !== null && _field$state !== void 0 && _field$state.calcs) {\n    // Find the values we need to calculate\n    const missing = [];\n\n    for (const s of reducers) {\n      if (!field.state.calcs.hasOwnProperty(s)) {\n        missing.push(s);\n      }\n    }\n\n    if (missing.length < 1) {\n      return Object.assign({}, field.state.calcs);\n    }\n  }\n\n  if (!field.state) {\n    field.state = {};\n  }\n\n  const queue = fieldReducers.list(reducers); // Return early for empty series\n  // This lets the concrete implementations assume at least one row\n\n  const data = field.values;\n\n  if (data.length < 1) {\n    const calcs = Object.assign({}, field.state.calcs);\n\n    for (const reducer of queue) {\n      calcs[reducer.id] = reducer.emptyInputResult !== null ? reducer.emptyInputResult : null;\n    }\n\n    return field.state.calcs = calcs;\n  }\n\n  const {\n    nullValueMode\n  } = field.config;\n  const ignoreNulls = nullValueMode === NullValueMode.Ignore;\n  const nullAsZero = nullValueMode === NullValueMode.AsZero; // Avoid calculating all the standard stats if possible\n\n  if (queue.length === 1 && queue[0].reduce) {\n    const values = queue[0].reduce(field, ignoreNulls, nullAsZero);\n    field.state.calcs = Object.assign({}, field.state.calcs, values);\n    return values;\n  } // For now everything can use the standard stats\n\n\n  let values = doStandardCalcs(field, ignoreNulls, nullAsZero);\n\n  for (const reducer of queue) {\n    if (!values.hasOwnProperty(reducer.id) && reducer.reduce) {\n      values = Object.assign({}, values, reducer.reduce(field, ignoreNulls, nullAsZero));\n    }\n  }\n\n  field.state.calcs = Object.assign({}, field.state.calcs, values);\n  return values;\n} // ------------------------------------------------------------------------------\n//\n//  No Exported symbols below here.\n//\n// ------------------------------------------------------------------------------\n\nexport const fieldReducers = new Registry(() => [{\n  id: ReducerID.lastNotNull,\n  name: 'Last *',\n  description: 'Last non-null value',\n  standard: true,\n  aliasIds: ['current'],\n  reduce: calculateLastNotNull\n}, {\n  id: ReducerID.last,\n  name: 'Last',\n  description: 'Last value',\n  standard: true,\n  reduce: calculateLast\n}, {\n  id: ReducerID.firstNotNull,\n  name: 'First *',\n  description: 'First non-null value',\n  standard: true,\n  reduce: calculateFirstNotNull\n}, {\n  id: ReducerID.first,\n  name: 'First',\n  description: 'First Value',\n  standard: true,\n  reduce: calculateFirst\n}, {\n  id: ReducerID.min,\n  name: 'Min',\n  description: 'Minimum Value',\n  standard: true\n}, {\n  id: ReducerID.max,\n  name: 'Max',\n  description: 'Maximum Value',\n  standard: true\n}, {\n  id: ReducerID.mean,\n  name: 'Mean',\n  description: 'Average Value',\n  standard: true,\n  aliasIds: ['avg']\n}, {\n  id: ReducerID.sum,\n  name: 'Total',\n  description: 'The sum of all values',\n  emptyInputResult: 0,\n  standard: true,\n  aliasIds: ['total']\n}, {\n  id: ReducerID.count,\n  name: 'Count',\n  description: 'Number of values in response',\n  emptyInputResult: 0,\n  standard: true\n}, {\n  id: ReducerID.range,\n  name: 'Range',\n  description: 'Difference between minimum and maximum values',\n  standard: true\n}, {\n  id: ReducerID.delta,\n  name: 'Delta',\n  description: 'Cumulative change in value',\n  standard: true\n}, {\n  id: ReducerID.step,\n  name: 'Step',\n  description: 'Minimum interval between values',\n  standard: true\n}, {\n  id: ReducerID.diff,\n  name: 'Difference',\n  description: 'Difference between first and last values',\n  standard: true\n}, {\n  id: ReducerID.logmin,\n  name: 'Min (above zero)',\n  description: 'Used for log min scale',\n  standard: true\n}, {\n  id: ReducerID.allIsZero,\n  name: 'All Zeros',\n  description: 'All values are zero',\n  emptyInputResult: false,\n  standard: true\n}, {\n  id: ReducerID.allIsNull,\n  name: 'All Nulls',\n  description: 'All values are null',\n  emptyInputResult: true,\n  standard: true\n}, {\n  id: ReducerID.changeCount,\n  name: 'Change Count',\n  description: 'Number of times the value changes',\n  standard: false,\n  reduce: calculateChangeCount\n}, {\n  id: ReducerID.distinctCount,\n  name: 'Distinct Count',\n  description: 'Number of distinct values',\n  standard: false,\n  reduce: calculateDistinctCount\n}, {\n  id: ReducerID.diffperc,\n  name: 'Difference percent',\n  description: 'Percentage difference between first and last values',\n  standard: true\n}, {\n  id: ReducerID.allValues,\n  name: 'All values',\n  description: 'Returns an array with all values',\n  standard: false,\n  reduce: field => ({\n    allValues: field.values.toArray()\n  })\n}, {\n  id: ReducerID.uniqueValues,\n  name: 'All unique values',\n  description: 'Returns an array with all unique values',\n  standard: false,\n  reduce: field => ({\n    uniqueValues: [...new Set(field.values.toArray())]\n  })\n}]);\nexport function doStandardCalcs(field, ignoreNulls, nullAsZero) {\n  const calcs = {\n    sum: 0,\n    max: -Number.MAX_VALUE,\n    min: Number.MAX_VALUE,\n    logmin: Number.MAX_VALUE,\n    mean: null,\n    last: null,\n    first: null,\n    lastNotNull: null,\n    firstNotNull: null,\n    count: 0,\n    nonNullCount: 0,\n    allIsNull: true,\n    allIsZero: true,\n    range: null,\n    diff: null,\n    delta: 0,\n    step: Number.MAX_VALUE,\n    diffperc: 0,\n    // Just used for calculations -- not exposed as a stat\n    previousDeltaUp: true\n  };\n  const data = field.values;\n  calcs.count = data.length;\n  const isNumberField = field.type === FieldType.number || FieldType.time;\n\n  for (let i = 0; i < data.length; i++) {\n    let currentValue = data.get(i);\n\n    if (i === 0) {\n      calcs.first = currentValue;\n    }\n\n    calcs.last = currentValue;\n\n    if (currentValue === null) {\n      if (ignoreNulls) {\n        continue;\n      }\n\n      if (nullAsZero) {\n        currentValue = 0;\n      }\n    }\n\n    if (currentValue != null) {\n      // null || undefined\n      const isFirst = calcs.firstNotNull === null;\n\n      if (isFirst) {\n        calcs.firstNotNull = currentValue;\n      }\n\n      if (isNumberField) {\n        calcs.sum += currentValue;\n        calcs.allIsNull = false;\n        calcs.nonNullCount++;\n\n        if (!isFirst) {\n          const step = currentValue - calcs.lastNotNull;\n\n          if (calcs.step > step) {\n            calcs.step = step; // the minimum interval\n          }\n\n          if (calcs.lastNotNull > currentValue) {\n            // counter reset\n            calcs.previousDeltaUp = false;\n\n            if (i === data.length - 1) {\n              // reset on last\n              calcs.delta += currentValue;\n            }\n          } else {\n            if (calcs.previousDeltaUp) {\n              calcs.delta += step; // normal increment\n            } else {\n              calcs.delta += currentValue; // account for counter reset\n            }\n\n            calcs.previousDeltaUp = true;\n          }\n        }\n\n        if (currentValue > calcs.max) {\n          calcs.max = currentValue;\n        }\n\n        if (currentValue < calcs.min) {\n          calcs.min = currentValue;\n        }\n\n        if (currentValue < calcs.logmin && currentValue > 0) {\n          calcs.logmin = currentValue;\n        }\n      }\n\n      if (currentValue !== 0) {\n        calcs.allIsZero = false;\n      }\n\n      calcs.lastNotNull = currentValue;\n    }\n  }\n\n  if (calcs.max === -Number.MAX_VALUE) {\n    calcs.max = null;\n  }\n\n  if (calcs.min === Number.MAX_VALUE) {\n    calcs.min = null;\n  }\n\n  if (calcs.step === Number.MAX_VALUE) {\n    calcs.step = null;\n  }\n\n  if (calcs.nonNullCount > 0) {\n    calcs.mean = calcs.sum / calcs.nonNullCount;\n  }\n\n  if (calcs.allIsNull) {\n    calcs.allIsZero = false;\n  }\n\n  if (calcs.max !== null && calcs.min !== null) {\n    calcs.range = calcs.max - calcs.min;\n  }\n\n  if (isNumber(calcs.firstNotNull) && isNumber(calcs.lastNotNull)) {\n    calcs.diff = calcs.lastNotNull - calcs.firstNotNull;\n  }\n\n  if (isNumber(calcs.firstNotNull) && isNumber(calcs.diff)) {\n    calcs.diffperc = calcs.diff / calcs.firstNotNull;\n  }\n\n  return calcs;\n}\n\nfunction calculateFirst(field, ignoreNulls, nullAsZero) {\n  return {\n    first: field.values.get(0)\n  };\n}\n\nfunction calculateFirstNotNull(field, ignoreNulls, nullAsZero) {\n  const data = field.values;\n\n  for (let idx = 0; idx < data.length; idx++) {\n    const v = data.get(idx);\n\n    if (v != null && v !== undefined) {\n      return {\n        firstNotNull: v\n      };\n    }\n  }\n\n  return {\n    firstNotNull: null\n  };\n}\n\nfunction calculateLast(field, ignoreNulls, nullAsZero) {\n  const data = field.values;\n  return {\n    last: data.get(data.length - 1)\n  };\n}\n\nfunction calculateLastNotNull(field, ignoreNulls, nullAsZero) {\n  const data = field.values;\n  let idx = data.length - 1;\n\n  while (idx >= 0) {\n    const v = data.get(idx--);\n\n    if (v != null && v !== undefined) {\n      return {\n        lastNotNull: v\n      };\n    }\n  }\n\n  return {\n    lastNotNull: null\n  };\n}\n\nfunction calculateChangeCount(field, ignoreNulls, nullAsZero) {\n  const data = field.values;\n  let count = 0;\n  let first = true;\n  let last = null;\n\n  for (let i = 0; i < data.length; i++) {\n    let currentValue = data.get(i);\n\n    if (currentValue === null) {\n      if (ignoreNulls) {\n        continue;\n      }\n\n      if (nullAsZero) {\n        currentValue = 0;\n      }\n    }\n\n    if (!first && last !== currentValue) {\n      count++;\n    }\n\n    first = false;\n    last = currentValue;\n  }\n\n  return {\n    changeCount: count\n  };\n}\n\nfunction calculateDistinctCount(field, ignoreNulls, nullAsZero) {\n  const data = field.values;\n  const distinct = new Set();\n\n  for (let i = 0; i < data.length; i++) {\n    let currentValue = data.get(i);\n\n    if (currentValue === null) {\n      if (ignoreNulls) {\n        continue;\n      }\n\n      if (nullAsZero) {\n        currentValue = 0;\n      }\n    }\n\n    distinct.add(currentValue);\n  }\n\n  return {\n    distinctCount: distinct.size\n  };\n}","map":{"version":3,"names":["isNumber","NullValueMode","FieldType","Registry","ReducerID","reduceField","options","field","reducers","length","state","calcs","missing","s","hasOwnProperty","push","queue","fieldReducers","list","data","values","reducer","id","emptyInputResult","nullValueMode","config","ignoreNulls","Ignore","nullAsZero","AsZero","reduce","doStandardCalcs","lastNotNull","name","description","standard","aliasIds","calculateLastNotNull","last","calculateLast","firstNotNull","calculateFirstNotNull","first","calculateFirst","min","max","mean","sum","count","range","delta","step","diff","logmin","allIsZero","allIsNull","changeCount","calculateChangeCount","distinctCount","calculateDistinctCount","diffperc","allValues","toArray","uniqueValues","Set","Number","MAX_VALUE","nonNullCount","previousDeltaUp","isNumberField","type","number","time","i","currentValue","get","isFirst","idx","v","undefined","distinct","add","size"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/fieldReducer.ts"],"sourcesContent":["// Libraries\nimport { isNumber } from 'lodash';\n\nimport { NullValueMode, Field, FieldState, FieldCalcs, FieldType } from '../types/index';\nimport { Registry, RegistryItem } from '../utils/Registry';\n\nexport enum ReducerID {\n  sum = 'sum',\n  max = 'max',\n  min = 'min',\n  logmin = 'logmin',\n  mean = 'mean',\n  last = 'last',\n  first = 'first',\n  count = 'count',\n  range = 'range',\n  diff = 'diff',\n  diffperc = 'diffperc',\n  delta = 'delta',\n  step = 'step',\n  firstNotNull = 'firstNotNull',\n  lastNotNull = 'lastNotNull',\n  changeCount = 'changeCount',\n  distinctCount = 'distinctCount',\n  allIsZero = 'allIsZero',\n  allIsNull = 'allIsNull',\n  allValues = 'allValues',\n  uniqueValues = 'uniqueValues',\n}\n\n// Internal function\ntype FieldReducer = (field: Field, ignoreNulls: boolean, nullAsZero: boolean) => FieldCalcs;\n\nexport interface FieldReducerInfo extends RegistryItem {\n  // Internal details\n  emptyInputResult?: any; // typically null, but some things like 'count' & 'sum' should be zero\n  standard: boolean; // The most common stats can all be calculated in a single pass\n  reduce?: FieldReducer;\n}\n\ninterface ReduceFieldOptions {\n  field: Field;\n  reducers: string[]; // The stats to calculate\n}\n\n/**\n * @returns an object with a key for each selected stat\n * NOTE: This will also modify the 'field.state' object,\n * leaving values in a cache until cleared.\n */\nexport function reduceField(options: ReduceFieldOptions): FieldCalcs {\n  const { field, reducers } = options;\n\n  if (!field || !reducers || reducers.length < 1) {\n    return {};\n  }\n\n  if (field.state?.calcs) {\n    // Find the values we need to calculate\n    const missing: string[] = [];\n    for (const s of reducers) {\n      if (!field.state.calcs.hasOwnProperty(s)) {\n        missing.push(s);\n      }\n    }\n    if (missing.length < 1) {\n      return {\n        ...field.state.calcs,\n      };\n    }\n  }\n  if (!field.state) {\n    field.state = {} as FieldState;\n  }\n\n  const queue = fieldReducers.list(reducers);\n\n  // Return early for empty series\n  // This lets the concrete implementations assume at least one row\n  const data = field.values;\n  if (data.length < 1) {\n    const calcs = { ...field.state.calcs } as FieldCalcs;\n    for (const reducer of queue) {\n      calcs[reducer.id] = reducer.emptyInputResult !== null ? reducer.emptyInputResult : null;\n    }\n    return (field.state.calcs = calcs);\n  }\n\n  const { nullValueMode } = field.config;\n  const ignoreNulls = nullValueMode === NullValueMode.Ignore;\n  const nullAsZero = nullValueMode === NullValueMode.AsZero;\n\n  // Avoid calculating all the standard stats if possible\n  if (queue.length === 1 && queue[0].reduce) {\n    const values = queue[0].reduce(field, ignoreNulls, nullAsZero);\n    field.state.calcs = {\n      ...field.state.calcs,\n      ...values,\n    };\n    return values;\n  }\n\n  // For now everything can use the standard stats\n  let values = doStandardCalcs(field, ignoreNulls, nullAsZero);\n\n  for (const reducer of queue) {\n    if (!values.hasOwnProperty(reducer.id) && reducer.reduce) {\n      values = {\n        ...values,\n        ...reducer.reduce(field, ignoreNulls, nullAsZero),\n      };\n    }\n  }\n\n  field.state.calcs = {\n    ...field.state.calcs,\n    ...values,\n  };\n  return values;\n}\n\n// ------------------------------------------------------------------------------\n//\n//  No Exported symbols below here.\n//\n// ------------------------------------------------------------------------------\n\nexport const fieldReducers = new Registry<FieldReducerInfo>(() => [\n  {\n    id: ReducerID.lastNotNull,\n    name: 'Last *',\n    description: 'Last non-null value',\n    standard: true,\n    aliasIds: ['current'],\n    reduce: calculateLastNotNull,\n  },\n  {\n    id: ReducerID.last,\n    name: 'Last',\n    description: 'Last value',\n    standard: true,\n    reduce: calculateLast,\n  },\n  {\n    id: ReducerID.firstNotNull,\n    name: 'First *',\n    description: 'First non-null value',\n    standard: true,\n    reduce: calculateFirstNotNull,\n  },\n  { id: ReducerID.first, name: 'First', description: 'First Value', standard: true, reduce: calculateFirst },\n  { id: ReducerID.min, name: 'Min', description: 'Minimum Value', standard: true },\n  { id: ReducerID.max, name: 'Max', description: 'Maximum Value', standard: true },\n  { id: ReducerID.mean, name: 'Mean', description: 'Average Value', standard: true, aliasIds: ['avg'] },\n  {\n    id: ReducerID.sum,\n    name: 'Total',\n    description: 'The sum of all values',\n    emptyInputResult: 0,\n    standard: true,\n    aliasIds: ['total'],\n  },\n  {\n    id: ReducerID.count,\n    name: 'Count',\n    description: 'Number of values in response',\n    emptyInputResult: 0,\n    standard: true,\n  },\n  {\n    id: ReducerID.range,\n    name: 'Range',\n    description: 'Difference between minimum and maximum values',\n    standard: true,\n  },\n  {\n    id: ReducerID.delta,\n    name: 'Delta',\n    description: 'Cumulative change in value',\n    standard: true,\n  },\n  {\n    id: ReducerID.step,\n    name: 'Step',\n    description: 'Minimum interval between values',\n    standard: true,\n  },\n  {\n    id: ReducerID.diff,\n    name: 'Difference',\n    description: 'Difference between first and last values',\n    standard: true,\n  },\n  {\n    id: ReducerID.logmin,\n    name: 'Min (above zero)',\n    description: 'Used for log min scale',\n    standard: true,\n  },\n  {\n    id: ReducerID.allIsZero,\n    name: 'All Zeros',\n    description: 'All values are zero',\n    emptyInputResult: false,\n    standard: true,\n  },\n  {\n    id: ReducerID.allIsNull,\n    name: 'All Nulls',\n    description: 'All values are null',\n    emptyInputResult: true,\n    standard: true,\n  },\n  {\n    id: ReducerID.changeCount,\n    name: 'Change Count',\n    description: 'Number of times the value changes',\n    standard: false,\n    reduce: calculateChangeCount,\n  },\n  {\n    id: ReducerID.distinctCount,\n    name: 'Distinct Count',\n    description: 'Number of distinct values',\n    standard: false,\n    reduce: calculateDistinctCount,\n  },\n  {\n    id: ReducerID.diffperc,\n    name: 'Difference percent',\n    description: 'Percentage difference between first and last values',\n    standard: true,\n  },\n  {\n    id: ReducerID.allValues,\n    name: 'All values',\n    description: 'Returns an array with all values',\n    standard: false,\n    reduce: (field: Field) => ({ allValues: field.values.toArray() }),\n  },\n  {\n    id: ReducerID.uniqueValues,\n    name: 'All unique values',\n    description: 'Returns an array with all unique values',\n    standard: false,\n    reduce: (field: Field) => ({\n      uniqueValues: [...new Set(field.values.toArray())],\n    }),\n  },\n]);\n\nexport function doStandardCalcs(field: Field, ignoreNulls: boolean, nullAsZero: boolean): FieldCalcs {\n  const calcs = {\n    sum: 0,\n    max: -Number.MAX_VALUE,\n    min: Number.MAX_VALUE,\n    logmin: Number.MAX_VALUE,\n    mean: null,\n    last: null,\n    first: null,\n    lastNotNull: null,\n    firstNotNull: null,\n    count: 0,\n    nonNullCount: 0,\n    allIsNull: true,\n    allIsZero: true,\n    range: null,\n    diff: null,\n    delta: 0,\n    step: Number.MAX_VALUE,\n    diffperc: 0,\n\n    // Just used for calculations -- not exposed as a stat\n    previousDeltaUp: true,\n  } as FieldCalcs;\n\n  const data = field.values;\n  calcs.count = data.length;\n\n  const isNumberField = field.type === FieldType.number || FieldType.time;\n\n  for (let i = 0; i < data.length; i++) {\n    let currentValue = data.get(i);\n\n    if (i === 0) {\n      calcs.first = currentValue;\n    }\n\n    calcs.last = currentValue;\n\n    if (currentValue === null) {\n      if (ignoreNulls) {\n        continue;\n      }\n      if (nullAsZero) {\n        currentValue = 0;\n      }\n    }\n\n    if (currentValue != null) {\n      // null || undefined\n      const isFirst = calcs.firstNotNull === null;\n      if (isFirst) {\n        calcs.firstNotNull = currentValue;\n      }\n\n      if (isNumberField) {\n        calcs.sum += currentValue;\n        calcs.allIsNull = false;\n        calcs.nonNullCount++;\n\n        if (!isFirst) {\n          const step = currentValue - calcs.lastNotNull!;\n          if (calcs.step > step) {\n            calcs.step = step; // the minimum interval\n          }\n\n          if (calcs.lastNotNull! > currentValue) {\n            // counter reset\n            calcs.previousDeltaUp = false;\n            if (i === data.length - 1) {\n              // reset on last\n              calcs.delta += currentValue;\n            }\n          } else {\n            if (calcs.previousDeltaUp) {\n              calcs.delta += step; // normal increment\n            } else {\n              calcs.delta += currentValue; // account for counter reset\n            }\n            calcs.previousDeltaUp = true;\n          }\n        }\n\n        if (currentValue > calcs.max) {\n          calcs.max = currentValue;\n        }\n\n        if (currentValue < calcs.min) {\n          calcs.min = currentValue;\n        }\n\n        if (currentValue < calcs.logmin && currentValue > 0) {\n          calcs.logmin = currentValue;\n        }\n      }\n\n      if (currentValue !== 0) {\n        calcs.allIsZero = false;\n      }\n\n      calcs.lastNotNull = currentValue;\n    }\n  }\n\n  if (calcs.max === -Number.MAX_VALUE) {\n    calcs.max = null;\n  }\n\n  if (calcs.min === Number.MAX_VALUE) {\n    calcs.min = null;\n  }\n\n  if (calcs.step === Number.MAX_VALUE) {\n    calcs.step = null;\n  }\n\n  if (calcs.nonNullCount > 0) {\n    calcs.mean = calcs.sum! / calcs.nonNullCount;\n  }\n\n  if (calcs.allIsNull) {\n    calcs.allIsZero = false;\n  }\n\n  if (calcs.max !== null && calcs.min !== null) {\n    calcs.range = calcs.max - calcs.min;\n  }\n\n  if (isNumber(calcs.firstNotNull) && isNumber(calcs.lastNotNull)) {\n    calcs.diff = calcs.lastNotNull - calcs.firstNotNull;\n  }\n\n  if (isNumber(calcs.firstNotNull) && isNumber(calcs.diff)) {\n    calcs.diffperc = calcs.diff / calcs.firstNotNull;\n  }\n  return calcs;\n}\n\nfunction calculateFirst(field: Field, ignoreNulls: boolean, nullAsZero: boolean): FieldCalcs {\n  return { first: field.values.get(0) };\n}\n\nfunction calculateFirstNotNull(field: Field, ignoreNulls: boolean, nullAsZero: boolean): FieldCalcs {\n  const data = field.values;\n  for (let idx = 0; idx < data.length; idx++) {\n    const v = data.get(idx);\n    if (v != null && v !== undefined) {\n      return { firstNotNull: v };\n    }\n  }\n  return { firstNotNull: null };\n}\n\nfunction calculateLast(field: Field, ignoreNulls: boolean, nullAsZero: boolean): FieldCalcs {\n  const data = field.values;\n  return { last: data.get(data.length - 1) };\n}\n\nfunction calculateLastNotNull(field: Field, ignoreNulls: boolean, nullAsZero: boolean): FieldCalcs {\n  const data = field.values;\n  let idx = data.length - 1;\n  while (idx >= 0) {\n    const v = data.get(idx--);\n    if (v != null && v !== undefined) {\n      return { lastNotNull: v };\n    }\n  }\n  return { lastNotNull: null };\n}\n\nfunction calculateChangeCount(field: Field, ignoreNulls: boolean, nullAsZero: boolean): FieldCalcs {\n  const data = field.values;\n  let count = 0;\n  let first = true;\n  let last: any = null;\n  for (let i = 0; i < data.length; i++) {\n    let currentValue = data.get(i);\n    if (currentValue === null) {\n      if (ignoreNulls) {\n        continue;\n      }\n      if (nullAsZero) {\n        currentValue = 0;\n      }\n    }\n    if (!first && last !== currentValue) {\n      count++;\n    }\n    first = false;\n    last = currentValue;\n  }\n\n  return { changeCount: count };\n}\n\nfunction calculateDistinctCount(field: Field, ignoreNulls: boolean, nullAsZero: boolean): FieldCalcs {\n  const data = field.values;\n  const distinct = new Set<any>();\n  for (let i = 0; i < data.length; i++) {\n    let currentValue = data.get(i);\n    if (currentValue === null) {\n      if (ignoreNulls) {\n        continue;\n      }\n      if (nullAsZero) {\n        currentValue = 0;\n      }\n    }\n    distinct.add(currentValue);\n  }\n  return { distinctCount: distinct.size };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}