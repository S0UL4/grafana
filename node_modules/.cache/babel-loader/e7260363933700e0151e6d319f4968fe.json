{"ast":null,"code":"import { isArray } from 'lodash';\nexport function grafanaReceiverToFormValues(receiver, notifiers) {\n  var _receiver$grafana_man, _receiver$grafana_man2;\n\n  const channelMap = {}; // giving each form receiver item a unique id so we can use it to map back to \"original\" items\n  // as well as to use as `key` prop.\n  // @TODO use uid once backend is fixed to provide it. then we can get rid of the GrafanaChannelMap\n\n  let idCounter = 1;\n  const values = {\n    name: receiver.name,\n    items: (_receiver$grafana_man = (_receiver$grafana_man2 = receiver.grafana_managed_receiver_configs) === null || _receiver$grafana_man2 === void 0 ? void 0 : _receiver$grafana_man2.map(channel => {\n      const id = String(idCounter++);\n      channelMap[id] = channel;\n      const notifier = notifiers.find(({\n        type\n      }) => type === channel.type);\n      return grafanaChannelConfigToFormChannelValues(id, channel, notifier);\n    })) !== null && _receiver$grafana_man !== void 0 ? _receiver$grafana_man : []\n  };\n  return [values, channelMap];\n}\nexport function cloudReceiverToFormValues(receiver, notifiers) {\n  const channelMap = {}; // giving each form receiver item a unique id so we can use it to map back to \"original\" items\n\n  let idCounter = 1;\n  const items = Object.entries(receiver) // filter out only config items that are relevant to cloud\n  .filter(([type]) => type.endsWith('_configs') && type !== 'grafana_managed_receiver_configs') // map property names to cloud notifier types by removing the `_config` suffix\n  .map(([type, configs]) => [type.replace('_configs', ''), configs]) // convert channel configs to form values\n  .map(([type, configs]) => configs.map(config => {\n    const id = String(idCounter++);\n    channelMap[id] = {\n      type,\n      config\n    };\n    const notifier = notifiers.find(notifier => notifier.type === type);\n\n    if (!notifier) {\n      throw new Error(`unknown cloud notifier: ${type}`);\n    }\n\n    return cloudChannelConfigToFormChannelValues(id, type, config);\n  })).flat();\n  const values = {\n    name: receiver.name,\n    items\n  };\n  return [values, channelMap];\n}\nexport function formValuesToGrafanaReceiver(values, channelMap, defaultChannelValues) {\n  var _values$items;\n\n  return {\n    name: values.name,\n    grafana_managed_receiver_configs: ((_values$items = values.items) !== null && _values$items !== void 0 ? _values$items : []).map(channelValues => {\n      const existing = channelMap[channelValues.__id];\n      return formChannelValuesToGrafanaChannelConfig(channelValues, defaultChannelValues, values.name, existing);\n    })\n  };\n}\nexport function formValuesToCloudReceiver(values, defaults) {\n  const recv = {\n    name: values.name\n  };\n  values.items.forEach(({\n    __id,\n    type,\n    settings,\n    sendResolved\n  }) => {\n    const channel = omitEmptyValues(Object.assign({}, settings, {\n      send_resolved: sendResolved !== null && sendResolved !== void 0 ? sendResolved : defaults.sendResolved\n    }));\n    const configsKey = `${type}_configs`;\n\n    if (!recv[configsKey]) {\n      recv[configsKey] = [channel];\n    } else {\n      recv[configsKey].push(channel);\n    }\n  });\n  return recv;\n} // will add new receiver, or replace exisitng one\n\nexport function updateConfigWithReceiver(config, receiver, replaceReceiverName) {\n  var _config$alertmanager_;\n\n  const oldReceivers = (_config$alertmanager_ = config.alertmanager_config.receivers) !== null && _config$alertmanager_ !== void 0 ? _config$alertmanager_ : []; // sanity check that name is not duplicated\n\n  if (receiver.name !== replaceReceiverName && !!oldReceivers.find(({\n    name\n  }) => name === receiver.name)) {\n    throw new Error(`Duplicate receiver name ${receiver.name}`);\n  } // sanity check that existing receiver exists\n\n\n  if (replaceReceiverName && !oldReceivers.find(({\n    name\n  }) => name === replaceReceiverName)) {\n    throw new Error(`Expected receiver ${replaceReceiverName} to exist, but did not find it in the config`);\n  }\n\n  const updated = Object.assign({}, config, {\n    alertmanager_config: Object.assign({}, config.alertmanager_config, {\n      receivers: replaceReceiverName ? oldReceivers.map(existingReceiver => existingReceiver.name === replaceReceiverName ? receiver : existingReceiver) : [...oldReceivers, receiver]\n    })\n  }); // if receiver was renamed, rename it in routes as well\n\n  if (updated.alertmanager_config.route && replaceReceiverName && receiver.name !== replaceReceiverName) {\n    updated.alertmanager_config.route = renameReceiverInRoute(updated.alertmanager_config.route, replaceReceiverName, receiver.name);\n  }\n\n  return updated;\n}\n\nfunction renameReceiverInRoute(route, oldName, newName) {\n  const updated = Object.assign({}, route);\n\n  if (updated.receiver === oldName) {\n    updated.receiver = newName;\n  }\n\n  if (updated.routes) {\n    updated.routes = updated.routes.map(route => renameReceiverInRoute(route, oldName, newName));\n  }\n\n  return updated;\n}\n\nfunction cloudChannelConfigToFormChannelValues(id, type, channel) {\n  return {\n    __id: id,\n    type,\n    settings: Object.assign({}, channel),\n    secureFields: {},\n    secureSettings: {},\n    sendResolved: channel.send_resolved\n  };\n}\n\nfunction grafanaChannelConfigToFormChannelValues(id, channel, notifier) {\n  const values = {\n    __id: id,\n    type: channel.type,\n    provenance: channel.provenance,\n    secureSettings: {},\n    settings: Object.assign({}, channel.settings),\n    secureFields: Object.assign({}, channel.secureFields),\n    disableResolveMessage: channel.disableResolveMessage\n  }; // work around https://github.com/grafana/alerting-squad/issues/100\n\n  notifier === null || notifier === void 0 ? void 0 : notifier.options.forEach(option => {\n    if (option.secure && values.settings[option.propertyName]) {\n      delete values.settings[option.propertyName];\n      values.secureFields[option.propertyName] = true;\n    }\n  });\n  return values;\n}\n\nexport function formChannelValuesToGrafanaChannelConfig(values, defaults, name, existing) {\n  var _existing$settings, _values$settings, _values$secureSetting, _ref, _values$disableResolv;\n\n  const channel = {\n    settings: omitEmptyValues(Object.assign({}, existing && existing.type === values.type ? (_existing$settings = existing.settings) !== null && _existing$settings !== void 0 ? _existing$settings : {} : {}, (_values$settings = values.settings) !== null && _values$settings !== void 0 ? _values$settings : {})),\n    secureSettings: (_values$secureSetting = values.secureSettings) !== null && _values$secureSetting !== void 0 ? _values$secureSetting : {},\n    type: values.type,\n    name,\n    disableResolveMessage: (_ref = (_values$disableResolv = values.disableResolveMessage) !== null && _values$disableResolv !== void 0 ? _values$disableResolv : existing === null || existing === void 0 ? void 0 : existing.disableResolveMessage) !== null && _ref !== void 0 ? _ref : defaults.disableResolveMessage\n  };\n\n  if (existing) {\n    channel.uid = existing.uid;\n  }\n\n  return channel;\n} // will remove properties that have empty ('', null, undefined) object properties.\n// traverses nested objects and arrays as well. in place, mutates the object.\n// this is needed because form will submit empty string for not filled in fields,\n// but for cloud alertmanager receiver config to use global default value the property must be omitted entirely\n// this isn't a perfect solution though. No way for user to intentionally provide an empty string. Will need rethinking later\n\nexport function omitEmptyValues(obj) {\n  if (isArray(obj)) {\n    obj.forEach(omitEmptyValues);\n  } else if (typeof obj === 'object' && obj !== null) {\n    Object.entries(obj).forEach(([key, value]) => {\n      if (value === '' || value === null || value === undefined) {\n        delete obj[key];\n      } else {\n        omitEmptyValues(value);\n      }\n    });\n  }\n\n  return obj;\n}","map":{"version":3,"names":["isArray","grafanaReceiverToFormValues","receiver","notifiers","channelMap","idCounter","values","name","items","grafana_managed_receiver_configs","map","channel","id","String","notifier","find","type","grafanaChannelConfigToFormChannelValues","cloudReceiverToFormValues","Object","entries","filter","endsWith","configs","replace","config","Error","cloudChannelConfigToFormChannelValues","flat","formValuesToGrafanaReceiver","defaultChannelValues","channelValues","existing","__id","formChannelValuesToGrafanaChannelConfig","formValuesToCloudReceiver","defaults","recv","forEach","settings","sendResolved","omitEmptyValues","send_resolved","configsKey","push","updateConfigWithReceiver","replaceReceiverName","oldReceivers","alertmanager_config","receivers","updated","existingReceiver","route","renameReceiverInRoute","oldName","newName","routes","secureFields","secureSettings","provenance","disableResolveMessage","options","option","secure","propertyName","uid","obj","key","value","undefined"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/utils/receiver-form.ts"],"sourcesContent":["import { isArray } from 'lodash';\n\nimport {\n  AlertManagerCortexConfig,\n  GrafanaManagedReceiverConfig,\n  Receiver,\n  Route,\n} from 'app/plugins/datasource/alertmanager/types';\nimport { CloudNotifierType, NotifierDTO, NotifierType } from 'app/types';\n\nimport {\n  CloudChannelConfig,\n  CloudChannelMap,\n  CloudChannelValues,\n  GrafanaChannelMap,\n  GrafanaChannelValues,\n  ReceiverFormValues,\n} from '../types/receiver-form';\n\nexport function grafanaReceiverToFormValues(\n  receiver: Receiver,\n  notifiers: NotifierDTO[]\n): [ReceiverFormValues<GrafanaChannelValues>, GrafanaChannelMap] {\n  const channelMap: GrafanaChannelMap = {};\n  // giving each form receiver item a unique id so we can use it to map back to \"original\" items\n  // as well as to use as `key` prop.\n  // @TODO use uid once backend is fixed to provide it. then we can get rid of the GrafanaChannelMap\n  let idCounter = 1;\n  const values = {\n    name: receiver.name,\n    items:\n      receiver.grafana_managed_receiver_configs?.map((channel) => {\n        const id = String(idCounter++);\n        channelMap[id] = channel;\n        const notifier = notifiers.find(({ type }) => type === channel.type);\n        return grafanaChannelConfigToFormChannelValues(id, channel, notifier);\n      }) ?? [],\n  };\n  return [values, channelMap];\n}\n\nexport function cloudReceiverToFormValues(\n  receiver: Receiver,\n  notifiers: NotifierDTO[]\n): [ReceiverFormValues<CloudChannelValues>, CloudChannelMap] {\n  const channelMap: CloudChannelMap = {};\n  // giving each form receiver item a unique id so we can use it to map back to \"original\" items\n  let idCounter = 1;\n  const items: CloudChannelValues[] = Object.entries(receiver)\n    // filter out only config items that are relevant to cloud\n    .filter(([type]) => type.endsWith('_configs') && type !== 'grafana_managed_receiver_configs')\n    // map property names to cloud notifier types by removing the `_config` suffix\n    .map(([type, configs]): [CloudNotifierType, CloudChannelConfig[]] => [\n      type.replace('_configs', '') as CloudNotifierType,\n      configs as CloudChannelConfig[],\n    ])\n    // convert channel configs to form values\n    .map(([type, configs]) =>\n      configs.map((config) => {\n        const id = String(idCounter++);\n        channelMap[id] = { type, config };\n        const notifier = notifiers.find((notifier) => notifier.type === type);\n        if (!notifier) {\n          throw new Error(`unknown cloud notifier: ${type}`);\n        }\n        return cloudChannelConfigToFormChannelValues(id, type, config);\n      })\n    )\n    .flat();\n  const values = {\n    name: receiver.name,\n    items,\n  };\n  return [values, channelMap];\n}\n\nexport function formValuesToGrafanaReceiver(\n  values: ReceiverFormValues<GrafanaChannelValues>,\n  channelMap: GrafanaChannelMap,\n  defaultChannelValues: GrafanaChannelValues\n): Receiver {\n  return {\n    name: values.name,\n    grafana_managed_receiver_configs: (values.items ?? []).map((channelValues) => {\n      const existing: GrafanaManagedReceiverConfig | undefined = channelMap[channelValues.__id];\n      return formChannelValuesToGrafanaChannelConfig(channelValues, defaultChannelValues, values.name, existing);\n    }),\n  };\n}\n\nexport function formValuesToCloudReceiver(\n  values: ReceiverFormValues<CloudChannelValues>,\n  defaults: CloudChannelValues\n): Receiver {\n  const recv: Receiver = {\n    name: values.name,\n  };\n  values.items.forEach(({ __id, type, settings, sendResolved }) => {\n    const channel = omitEmptyValues({\n      ...settings,\n      send_resolved: sendResolved ?? defaults.sendResolved,\n    });\n\n    const configsKey = `${type}_configs`;\n    if (!recv[configsKey]) {\n      recv[configsKey] = [channel];\n    } else {\n      (recv[configsKey] as unknown[]).push(channel);\n    }\n  });\n  return recv;\n}\n\n// will add new receiver, or replace exisitng one\nexport function updateConfigWithReceiver(\n  config: AlertManagerCortexConfig,\n  receiver: Receiver,\n  replaceReceiverName?: string\n): AlertManagerCortexConfig {\n  const oldReceivers = config.alertmanager_config.receivers ?? [];\n\n  // sanity check that name is not duplicated\n  if (receiver.name !== replaceReceiverName && !!oldReceivers.find(({ name }) => name === receiver.name)) {\n    throw new Error(`Duplicate receiver name ${receiver.name}`);\n  }\n\n  // sanity check that existing receiver exists\n  if (replaceReceiverName && !oldReceivers.find(({ name }) => name === replaceReceiverName)) {\n    throw new Error(`Expected receiver ${replaceReceiverName} to exist, but did not find it in the config`);\n  }\n\n  const updated: AlertManagerCortexConfig = {\n    ...config,\n    alertmanager_config: {\n      // @todo rename receiver on routes as necessary\n      ...config.alertmanager_config,\n      receivers: replaceReceiverName\n        ? oldReceivers.map((existingReceiver) =>\n            existingReceiver.name === replaceReceiverName ? receiver : existingReceiver\n          )\n        : [...oldReceivers, receiver],\n    },\n  };\n\n  // if receiver was renamed, rename it in routes as well\n  if (updated.alertmanager_config.route && replaceReceiverName && receiver.name !== replaceReceiverName) {\n    updated.alertmanager_config.route = renameReceiverInRoute(\n      updated.alertmanager_config.route,\n      replaceReceiverName,\n      receiver.name\n    );\n  }\n\n  return updated;\n}\n\nfunction renameReceiverInRoute(route: Route, oldName: string, newName: string) {\n  const updated: Route = {\n    ...route,\n  };\n  if (updated.receiver === oldName) {\n    updated.receiver = newName;\n  }\n  if (updated.routes) {\n    updated.routes = updated.routes.map((route) => renameReceiverInRoute(route, oldName, newName));\n  }\n  return updated;\n}\n\nfunction cloudChannelConfigToFormChannelValues(\n  id: string,\n  type: CloudNotifierType,\n  channel: CloudChannelConfig\n): CloudChannelValues {\n  return {\n    __id: id,\n    type,\n    settings: {\n      ...channel,\n    },\n    secureFields: {},\n    secureSettings: {},\n    sendResolved: channel.send_resolved,\n  };\n}\n\nfunction grafanaChannelConfigToFormChannelValues(\n  id: string,\n  channel: GrafanaManagedReceiverConfig,\n  notifier?: NotifierDTO\n): GrafanaChannelValues {\n  const values: GrafanaChannelValues = {\n    __id: id,\n    type: channel.type as NotifierType,\n    provenance: channel.provenance,\n    secureSettings: {},\n    settings: { ...channel.settings },\n    secureFields: { ...channel.secureFields },\n    disableResolveMessage: channel.disableResolveMessage,\n  };\n\n  // work around https://github.com/grafana/alerting-squad/issues/100\n  notifier?.options.forEach((option) => {\n    if (option.secure && values.settings[option.propertyName]) {\n      delete values.settings[option.propertyName];\n      values.secureFields[option.propertyName] = true;\n    }\n  });\n\n  return values;\n}\n\nexport function formChannelValuesToGrafanaChannelConfig(\n  values: GrafanaChannelValues,\n  defaults: GrafanaChannelValues,\n  name: string,\n  existing?: GrafanaManagedReceiverConfig\n): GrafanaManagedReceiverConfig {\n  const channel: GrafanaManagedReceiverConfig = {\n    settings: omitEmptyValues({\n      ...(existing && existing.type === values.type ? existing.settings ?? {} : {}),\n      ...(values.settings ?? {}),\n    }),\n    secureSettings: values.secureSettings ?? {},\n    type: values.type,\n    name,\n    disableResolveMessage:\n      values.disableResolveMessage ?? existing?.disableResolveMessage ?? defaults.disableResolveMessage,\n  };\n  if (existing) {\n    channel.uid = existing.uid;\n  }\n  return channel;\n}\n\n// will remove properties that have empty ('', null, undefined) object properties.\n// traverses nested objects and arrays as well. in place, mutates the object.\n// this is needed because form will submit empty string for not filled in fields,\n// but for cloud alertmanager receiver config to use global default value the property must be omitted entirely\n// this isn't a perfect solution though. No way for user to intentionally provide an empty string. Will need rethinking later\nexport function omitEmptyValues<T>(obj: T): T {\n  if (isArray(obj)) {\n    obj.forEach(omitEmptyValues);\n  } else if (typeof obj === 'object' && obj !== null) {\n    Object.entries(obj).forEach(([key, value]) => {\n      if (value === '' || value === null || value === undefined) {\n        delete (obj as any)[key];\n      } else {\n        omitEmptyValues(value);\n      }\n    });\n  }\n  return obj;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}