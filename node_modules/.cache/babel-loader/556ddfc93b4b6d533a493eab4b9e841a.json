{"ast":null,"code":"export class LinkedToken {\n  constructor(type, value, range, previous, next, tokenTypes) {\n    this.type = type;\n    this.value = value;\n    this.range = range;\n    this.previous = previous;\n    this.next = next;\n    this.tokenTypes = tokenTypes;\n  }\n\n  isKeyword() {\n    return this.type === this.tokenTypes.Keyword;\n  }\n\n  isWhiteSpace() {\n    return this.type === this.tokenTypes.Whitespace;\n  }\n\n  isParenthesis() {\n    return this.type === this.tokenTypes.Parenthesis;\n  }\n\n  isIdentifier() {\n    return this.type === this.tokenTypes.Identifier;\n  }\n\n  isString() {\n    return this.type === this.tokenTypes.String;\n  }\n\n  isDoubleQuotedString() {\n    return this.type === this.tokenTypes.Type;\n  }\n\n  isVariable() {\n    return this.type === this.tokenTypes.Variable;\n  }\n\n  isFunction() {\n    return this.type === this.tokenTypes.Function;\n  }\n\n  isNumber() {\n    return this.type === this.tokenTypes.Number;\n  }\n\n  is(type, value) {\n    const isType = this.type === type;\n    return value !== undefined ? isType && this.value === value : isType;\n  }\n\n  endsWith(value) {\n    return this.value === value || this.value[this.value.length - 1] === value;\n  }\n\n  getPreviousNonWhiteSpaceToken() {\n    let curr = this.previous;\n\n    while (curr != null) {\n      if (!curr.isWhiteSpace()) {\n        return curr;\n      }\n\n      curr = curr.previous;\n    }\n\n    return null;\n  }\n\n  getPreviousOfType(type, value) {\n    let curr = this.previous;\n\n    while (curr != null) {\n      const isType = curr.type === type;\n\n      if (value !== undefined ? isType && curr.value === value : isType) {\n        return curr;\n      }\n\n      curr = curr.previous;\n    }\n\n    return null;\n  }\n\n  getPreviousUntil(type, ignoreTypes, value) {\n    let tokens = [];\n    let curr = this.previous;\n\n    while (curr != null) {\n      if (ignoreTypes.some(t => {\n        var _curr;\n\n        return t === ((_curr = curr) === null || _curr === void 0 ? void 0 : _curr.type);\n      })) {\n        curr = curr.previous;\n        continue;\n      }\n\n      const isType = curr.type === type;\n\n      if (value !== undefined ? isType && curr.value === value : isType) {\n        return tokens;\n      }\n\n      if (!curr.isWhiteSpace()) {\n        tokens.push(curr);\n      }\n\n      curr = curr.previous;\n    }\n\n    return tokens;\n  }\n\n  getNextUntil(type, ignoreTypes, value) {\n    let tokens = [];\n    let curr = this.next;\n\n    while (curr != null) {\n      if (ignoreTypes.some(t => {\n        var _curr2;\n\n        return t === ((_curr2 = curr) === null || _curr2 === void 0 ? void 0 : _curr2.type);\n      })) {\n        curr = curr.next;\n        continue;\n      }\n\n      const isType = curr.type === type;\n\n      if (value !== undefined ? isType && curr.value === value : isType) {\n        return tokens;\n      }\n\n      if (!curr.isWhiteSpace()) {\n        tokens.push(curr);\n      }\n\n      curr = curr.next;\n    }\n\n    return tokens;\n  }\n\n  getPreviousKeyword() {\n    let curr = this.previous;\n\n    while (curr != null) {\n      if (curr.isKeyword()) {\n        return curr;\n      }\n\n      curr = curr.previous;\n    }\n\n    return null;\n  }\n\n  getNextNonWhiteSpaceToken() {\n    let curr = this.next;\n\n    while (curr != null) {\n      if (!curr.isWhiteSpace()) {\n        return curr;\n      }\n\n      curr = curr.next;\n    }\n\n    return null;\n  }\n\n  getNextOfType(type, value) {\n    let curr = this.next;\n\n    while (curr != null) {\n      const isType = curr.type === type;\n\n      if (value !== undefined ? isType && curr.value === value : isType) {\n        return curr;\n      }\n\n      curr = curr.next;\n    }\n\n    return null;\n  }\n\n}","map":{"version":3,"names":["LinkedToken","constructor","type","value","range","previous","next","tokenTypes","isKeyword","Keyword","isWhiteSpace","Whitespace","isParenthesis","Parenthesis","isIdentifier","Identifier","isString","String","isDoubleQuotedString","Type","isVariable","Variable","isFunction","Function","isNumber","Number","is","isType","undefined","endsWith","length","getPreviousNonWhiteSpaceToken","curr","getPreviousOfType","getPreviousUntil","ignoreTypes","tokens","some","t","push","getNextUntil","getPreviousKeyword","getNextNonWhiteSpaceToken","getNextOfType"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/monarch/LinkedToken.ts"],"sourcesContent":["import { monacoTypes } from '@grafana/ui';\n\nimport { TokenTypes } from './types';\n\nexport class LinkedToken {\n  constructor(\n    public type: string,\n    public value: string,\n    public range: monacoTypes.IRange,\n    public previous: LinkedToken | null,\n    public next: LinkedToken | null,\n    public tokenTypes: TokenTypes\n  ) {}\n\n  isKeyword(): boolean {\n    return this.type === this.tokenTypes.Keyword;\n  }\n\n  isWhiteSpace(): boolean {\n    return this.type === this.tokenTypes.Whitespace;\n  }\n\n  isParenthesis(): boolean {\n    return this.type === this.tokenTypes.Parenthesis;\n  }\n\n  isIdentifier(): boolean {\n    return this.type === this.tokenTypes.Identifier;\n  }\n\n  isString(): boolean {\n    return this.type === this.tokenTypes.String;\n  }\n\n  isDoubleQuotedString(): boolean {\n    return this.type === this.tokenTypes.Type;\n  }\n\n  isVariable(): boolean {\n    return this.type === this.tokenTypes.Variable;\n  }\n\n  isFunction(): boolean {\n    return this.type === this.tokenTypes.Function;\n  }\n\n  isNumber(): boolean {\n    return this.type === this.tokenTypes.Number;\n  }\n\n  is(type: string, value?: string | number | boolean): boolean {\n    const isType = this.type === type;\n    return value !== undefined ? isType && this.value === value : isType;\n  }\n\n  endsWith(value: string | number | boolean): boolean {\n    return this.value === value || this.value[this.value.length - 1] === value;\n  }\n\n  getPreviousNonWhiteSpaceToken(): LinkedToken | null {\n    let curr = this.previous;\n    while (curr != null) {\n      if (!curr.isWhiteSpace()) {\n        return curr;\n      }\n      curr = curr.previous;\n    }\n    return null;\n  }\n\n  getPreviousOfType(type: string, value?: string): LinkedToken | null {\n    let curr = this.previous;\n    while (curr != null) {\n      const isType = curr.type === type;\n      if (value !== undefined ? isType && curr.value === value : isType) {\n        return curr;\n      }\n      curr = curr.previous;\n    }\n    return null;\n  }\n\n  getPreviousUntil(type: string, ignoreTypes: string[], value?: string): LinkedToken[] | null {\n    let tokens: LinkedToken[] = [];\n    let curr = this.previous;\n    while (curr != null) {\n      if (ignoreTypes.some((t) => t === curr?.type)) {\n        curr = curr.previous;\n        continue;\n      }\n\n      const isType = curr.type === type;\n      if (value !== undefined ? isType && curr.value === value : isType) {\n        return tokens;\n      }\n      if (!curr.isWhiteSpace()) {\n        tokens.push(curr);\n      }\n      curr = curr.previous;\n    }\n\n    return tokens;\n  }\n\n  getNextUntil(type: string, ignoreTypes: string[], value?: string): LinkedToken[] | null {\n    let tokens: LinkedToken[] = [];\n    let curr = this.next;\n    while (curr != null) {\n      if (ignoreTypes.some((t) => t === curr?.type)) {\n        curr = curr.next;\n        continue;\n      }\n\n      const isType = curr.type === type;\n      if (value !== undefined ? isType && curr.value === value : isType) {\n        return tokens;\n      }\n      if (!curr.isWhiteSpace()) {\n        tokens.push(curr);\n      }\n      curr = curr.next;\n    }\n\n    return tokens;\n  }\n\n  getPreviousKeyword(): LinkedToken | null {\n    let curr = this.previous;\n    while (curr != null) {\n      if (curr.isKeyword()) {\n        return curr;\n      }\n      curr = curr.previous;\n    }\n    return null;\n  }\n\n  getNextNonWhiteSpaceToken(): LinkedToken | null {\n    let curr = this.next;\n    while (curr != null) {\n      if (!curr.isWhiteSpace()) {\n        return curr;\n      }\n      curr = curr.next;\n    }\n    return null;\n  }\n\n  getNextOfType(type: string, value?: string): LinkedToken | null {\n    let curr = this.next;\n    while (curr != null) {\n      const isType = curr.type === type;\n      if (value !== undefined ? isType && curr.value === value : isType) {\n        return curr;\n      }\n      curr = curr.next;\n    }\n    return null;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}