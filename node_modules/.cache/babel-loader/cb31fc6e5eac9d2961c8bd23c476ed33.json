{"ast":null,"code":"import { ArrayVector, FieldCache, FieldColorModeId, FieldType, MutableDataFrame, NodeGraphDataFrameFieldNames } from '@grafana/data';\n\n/**\n * Makes line shorter while keeping the middle in he same place.\n */\nexport function shortenLine(line, length) {\n  const vx = line.x2 - line.x1;\n  const vy = line.y2 - line.y1;\n  const mag = Math.sqrt(vx * vx + vy * vy);\n  const ratio = Math.max((mag - length) / mag, 0);\n  const vx2 = vx * ratio;\n  const vy2 = vy * ratio;\n  const xDiff = vx - vx2;\n  const yDiff = vy - vy2;\n  const newx1 = line.x1 + xDiff / 2;\n  const newy1 = line.y1 + yDiff / 2;\n  return {\n    x1: newx1,\n    y1: newy1,\n    x2: newx1 + vx2,\n    y2: newy1 + vy2\n  };\n}\nexport function getNodeFields(nodes) {\n  const normalizedFrames = Object.assign({}, nodes, {\n    fields: nodes.fields.map(field => Object.assign({}, field, {\n      name: field.name.toLowerCase()\n    }))\n  });\n  const fieldsCache = new FieldCache(normalizedFrames);\n  return {\n    id: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id.toLowerCase()),\n    title: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.title.toLowerCase()),\n    subTitle: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.subTitle.toLowerCase()),\n    mainStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),\n    secondaryStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),\n    arc: findFieldsByPrefix(nodes, NodeGraphDataFrameFieldNames.arc),\n    details: findFieldsByPrefix(nodes, NodeGraphDataFrameFieldNames.detail),\n    color: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.color)\n  };\n}\nexport function getEdgeFields(edges) {\n  const normalizedFrames = Object.assign({}, edges, {\n    fields: edges.fields.map(field => Object.assign({}, field, {\n      name: field.name.toLowerCase()\n    }))\n  });\n  const fieldsCache = new FieldCache(normalizedFrames);\n  return {\n    id: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id.toLowerCase()),\n    source: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.source.toLowerCase()),\n    target: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.target.toLowerCase()),\n    mainStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),\n    secondaryStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),\n    details: findFieldsByPrefix(edges, NodeGraphDataFrameFieldNames.detail.toLowerCase())\n  };\n}\n\nfunction findFieldsByPrefix(frame, prefix) {\n  return frame.fields.filter(f => f.name.match(new RegExp('^' + prefix)));\n}\n/**\n * Transform nodes and edges dataframes into array of objects that the layout code can then work with.\n */\n\n\nexport function processNodes(nodes, edges, theme) {\n  if (!nodes) {\n    return {\n      nodes: [],\n      edges: []\n    };\n  }\n\n  const nodeFields = getNodeFields(nodes);\n\n  if (!nodeFields.id) {\n    throw new Error('id field is required for nodes data frame.');\n  }\n\n  const nodesMap = nodeFields.id.values.toArray().reduce((acc, id, index) => {\n    var _nodeFields$title;\n\n    acc[id] = {\n      id: id,\n      title: ((_nodeFields$title = nodeFields.title) === null || _nodeFields$title === void 0 ? void 0 : _nodeFields$title.values.get(index)) || '',\n      subTitle: nodeFields.subTitle ? nodeFields.subTitle.values.get(index) : '',\n      dataFrameRowIndex: index,\n      incoming: 0,\n      mainStat: nodeFields.mainStat,\n      secondaryStat: nodeFields.secondaryStat,\n      arcSections: nodeFields.arc,\n      color: nodeFields.color\n    };\n    return acc;\n  }, {}) || {};\n  let edgesMapped = []; // We may not have edges in case of single node\n\n  if (edges) {\n    const edgeFields = getEdgeFields(edges);\n\n    if (!edgeFields.id) {\n      throw new Error('id field is required for edges data frame.');\n    }\n\n    edgesMapped = edgeFields.id.values.toArray().map((id, index) => {\n      var _edgeFields$target, _edgeFields$source;\n\n      const target = (_edgeFields$target = edgeFields.target) === null || _edgeFields$target === void 0 ? void 0 : _edgeFields$target.values.get(index);\n      const source = (_edgeFields$source = edgeFields.source) === null || _edgeFields$source === void 0 ? void 0 : _edgeFields$source.values.get(index); // We are adding incoming edges count so we can later on find out which nodes are the roots\n\n      nodesMap[target].incoming++;\n      return {\n        id,\n        dataFrameRowIndex: index,\n        source,\n        target,\n        mainStat: edgeFields.mainStat ? statToString(edgeFields.mainStat, index) : '',\n        secondaryStat: edgeFields.secondaryStat ? statToString(edgeFields.secondaryStat, index) : ''\n      };\n    });\n  }\n\n  return {\n    nodes: Object.values(nodesMap),\n    edges: edgesMapped || [],\n    legend: nodeFields.arc.map(f => {\n      var _f$config$color$fixed, _f$config$color;\n\n      return {\n        color: (_f$config$color$fixed = (_f$config$color = f.config.color) === null || _f$config$color === void 0 ? void 0 : _f$config$color.fixedColor) !== null && _f$config$color$fixed !== void 0 ? _f$config$color$fixed : '',\n        name: f.config.displayName || f.name\n      };\n    })\n  };\n}\nexport function statToString(field, index) {\n  if (field.type === FieldType.string) {\n    return field.values.get(index);\n  } else {\n    const decimals = field.config.decimals || 2;\n    const val = field.values.get(index);\n\n    if (Number.isFinite(val)) {\n      return field.values.get(index).toFixed(decimals) + (field.config.unit ? ' ' + field.config.unit : '');\n    } else {\n      return '';\n    }\n  }\n}\n/**\n * Utilities mainly for testing\n */\n\nexport function makeNodesDataFrame(count) {\n  const frame = nodesFrame();\n\n  for (let i = 0; i < count; i++) {\n    frame.add(makeNode(i));\n  }\n\n  return frame;\n}\n\nfunction makeNode(index) {\n  return {\n    id: index.toString(),\n    title: `service:${index}`,\n    subtitle: 'service',\n    arc__success: 0.5,\n    arc__errors: 0.5,\n    mainstat: 0.1,\n    secondarystat: 2,\n    color: 0.5\n  };\n}\n\nfunction nodesFrame() {\n  const fields = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    },\n    [NodeGraphDataFrameFieldNames.title]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    },\n    [NodeGraphDataFrameFieldNames.subTitle]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    },\n    [NodeGraphDataFrameFieldNames.mainStat]: {\n      values: new ArrayVector(),\n      type: FieldType.number\n    },\n    [NodeGraphDataFrameFieldNames.secondaryStat]: {\n      values: new ArrayVector(),\n      type: FieldType.number\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'success']: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: {\n        color: {\n          fixedColor: 'green'\n        }\n      }\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'errors']: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: {\n        color: {\n          fixedColor: 'red'\n        }\n      }\n    },\n    [NodeGraphDataFrameFieldNames.color]: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: {\n        color: {\n          mode: 'continuous-GrYlRd'\n        }\n      }\n    }\n  };\n  return new MutableDataFrame({\n    name: 'nodes',\n    fields: Object.keys(fields).map(key => Object.assign({}, fields[key], {\n      name: key\n    }))\n  });\n}\n\nexport function makeEdgesDataFrame(edges) {\n  const frame = edgesFrame();\n\n  for (const edge of edges) {\n    frame.add({\n      id: edge[0] + '--' + edge[1],\n      source: edge[0].toString(),\n      target: edge[1].toString()\n    });\n  }\n\n  return frame;\n}\n\nfunction edgesFrame() {\n  const fields = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    },\n    [NodeGraphDataFrameFieldNames.source]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    },\n    [NodeGraphDataFrameFieldNames.target]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    }\n  };\n  return new MutableDataFrame({\n    name: 'edges',\n    fields: Object.keys(fields).map(key => Object.assign({}, fields[key], {\n      name: key\n    }))\n  });\n}\n\n/**\n * Get bounds of the graph meaning the extent of the nodes in all directions.\n */\nexport function graphBounds(nodes) {\n  if (nodes.length === 0) {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      center: {\n        x: 0,\n        y: 0\n      }\n    };\n  }\n\n  const bounds = nodes.reduce((acc, node) => {\n    if (node.x > acc.right) {\n      acc.right = node.x;\n    }\n\n    if (node.x < acc.left) {\n      acc.left = node.x;\n    }\n\n    if (node.y > acc.bottom) {\n      acc.bottom = node.y;\n    }\n\n    if (node.y < acc.top) {\n      acc.top = node.y;\n    }\n\n    return acc;\n  }, {\n    top: Infinity,\n    right: -Infinity,\n    bottom: -Infinity,\n    left: Infinity\n  });\n  const y = bounds.top + (bounds.bottom - bounds.top) / 2;\n  const x = bounds.left + (bounds.right - bounds.left) / 2;\n  return Object.assign({}, bounds, {\n    center: {\n      x,\n      y\n    }\n  });\n}\nexport function getNodeGraphDataFrames(frames, options) {\n  // TODO: this not in sync with how other types of responses are handled. Other types have a query response\n  //  processing pipeline which ends up populating redux state with proper data. As we move towards more dataFrame\n  //  oriented API it seems like a better direction to move such processing into to visualisations and do minimal\n  //  and lazy processing here. Needs bigger refactor so keeping nodeGraph and Traces as they are for now.\n  let nodeGraphFrames = frames.filter(frame => {\n    var _frame$meta;\n\n    if (((_frame$meta = frame.meta) === null || _frame$meta === void 0 ? void 0 : _frame$meta.preferredVisualisationType) === 'nodeGraph') {\n      return true;\n    }\n\n    if (frame.name === 'nodes' || frame.name === 'edges' || frame.refId === 'nodes' || frame.refId === 'edges') {\n      return true;\n    }\n\n    const fieldsCache = new FieldCache(frame);\n\n    if (fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id)) {\n      return true;\n    }\n\n    return false;\n  }); // If panel options are provided, interpolate their values in to the data frames\n\n  if (options) {\n    nodeGraphFrames = applyOptionsToFrames(nodeGraphFrames, options);\n  }\n\n  return nodeGraphFrames;\n}\nexport const applyOptionsToFrames = (frames, options) => {\n  return frames.map(frame => {\n    const fieldsCache = new FieldCache(frame); // Edges frame has source which can be used to identify nodes vs edges frames\n\n    if (fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.source.toLowerCase())) {\n      var _options$edges, _options$edges2;\n\n      if (options !== null && options !== void 0 && (_options$edges = options.edges) !== null && _options$edges !== void 0 && _options$edges.mainStatUnit) {\n        const field = frame.fields.find(field => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.mainStat);\n\n        if (field) {\n          field.config = Object.assign({}, field.config, {\n            unit: options.edges.mainStatUnit\n          });\n        }\n      }\n\n      if (options !== null && options !== void 0 && (_options$edges2 = options.edges) !== null && _options$edges2 !== void 0 && _options$edges2.secondaryStatUnit) {\n        const field = frame.fields.find(field => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.secondaryStat);\n\n        if (field) {\n          field.config = Object.assign({}, field.config, {\n            unit: options.edges.secondaryStatUnit\n          });\n        }\n      }\n    } else {\n      var _options$nodes, _options$nodes2, _options$nodes3, _options$nodes3$arcs;\n\n      if (options !== null && options !== void 0 && (_options$nodes = options.nodes) !== null && _options$nodes !== void 0 && _options$nodes.mainStatUnit) {\n        const field = frame.fields.find(field => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.mainStat);\n\n        if (field) {\n          field.config = Object.assign({}, field.config, {\n            unit: options.nodes.mainStatUnit\n          });\n        }\n      }\n\n      if (options !== null && options !== void 0 && (_options$nodes2 = options.nodes) !== null && _options$nodes2 !== void 0 && _options$nodes2.secondaryStatUnit) {\n        const field = frame.fields.find(field => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.secondaryStat);\n\n        if (field) {\n          field.config = Object.assign({}, field.config, {\n            unit: options.nodes.secondaryStatUnit\n          });\n        }\n      }\n\n      if (options !== null && options !== void 0 && (_options$nodes3 = options.nodes) !== null && _options$nodes3 !== void 0 && (_options$nodes3$arcs = _options$nodes3.arcs) !== null && _options$nodes3$arcs !== void 0 && _options$nodes3$arcs.length) {\n        for (const arc of options.nodes.arcs) {\n          const field = frame.fields.find(field => field.name.toLowerCase() === arc.field);\n\n          if (field && arc.color) {\n            field.config = Object.assign({}, field.config, {\n              color: {\n                fixedColor: arc.color,\n                mode: FieldColorModeId.Fixed\n              }\n            });\n          }\n        }\n      }\n    }\n\n    return frame;\n  });\n};","map":{"version":3,"names":["ArrayVector","FieldCache","FieldColorModeId","FieldType","MutableDataFrame","NodeGraphDataFrameFieldNames","shortenLine","line","length","vx","x2","x1","vy","y2","y1","mag","Math","sqrt","ratio","max","vx2","vy2","xDiff","yDiff","newx1","newy1","getNodeFields","nodes","normalizedFrames","fields","map","field","name","toLowerCase","fieldsCache","id","getFieldByName","title","subTitle","mainStat","secondaryStat","arc","findFieldsByPrefix","details","detail","color","getEdgeFields","edges","source","target","frame","prefix","filter","f","match","RegExp","processNodes","theme","nodeFields","Error","nodesMap","values","toArray","reduce","acc","index","get","dataFrameRowIndex","incoming","arcSections","edgesMapped","edgeFields","statToString","Object","legend","config","fixedColor","displayName","type","string","decimals","val","Number","isFinite","toFixed","unit","makeNodesDataFrame","count","nodesFrame","i","add","makeNode","toString","subtitle","arc__success","arc__errors","mainstat","secondarystat","number","mode","keys","key","makeEdgesDataFrame","edgesFrame","edge","graphBounds","top","right","bottom","left","center","x","y","bounds","node","Infinity","getNodeGraphDataFrames","frames","options","nodeGraphFrames","meta","preferredVisualisationType","refId","applyOptionsToFrames","mainStatUnit","find","secondaryStatUnit","arcs","Fixed"],"sources":["/home/soula/grafana/public/app/plugins/panel/nodeGraph/utils.ts"],"sourcesContent":["import {\n  ArrayVector,\n  DataFrame,\n  Field,\n  FieldCache,\n  FieldColorModeId,\n  FieldType,\n  GrafanaTheme2,\n  MutableDataFrame,\n  NodeGraphDataFrameFieldNames,\n} from '@grafana/data';\n\nimport { EdgeDatum, NodeDatum, NodeGraphOptions } from './types';\n\ntype Line = { x1: number; y1: number; x2: number; y2: number };\n\n/**\n * Makes line shorter while keeping the middle in he same place.\n */\nexport function shortenLine(line: Line, length: number): Line {\n  const vx = line.x2 - line.x1;\n  const vy = line.y2 - line.y1;\n  const mag = Math.sqrt(vx * vx + vy * vy);\n  const ratio = Math.max((mag - length) / mag, 0);\n  const vx2 = vx * ratio;\n  const vy2 = vy * ratio;\n  const xDiff = vx - vx2;\n  const yDiff = vy - vy2;\n  const newx1 = line.x1 + xDiff / 2;\n  const newy1 = line.y1 + yDiff / 2;\n  return {\n    x1: newx1,\n    y1: newy1,\n    x2: newx1 + vx2,\n    y2: newy1 + vy2,\n  };\n}\n\nexport function getNodeFields(nodes: DataFrame) {\n  const normalizedFrames = {\n    ...nodes,\n    fields: nodes.fields.map((field) => ({ ...field, name: field.name.toLowerCase() })),\n  };\n  const fieldsCache = new FieldCache(normalizedFrames);\n  return {\n    id: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id.toLowerCase()),\n    title: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.title.toLowerCase()),\n    subTitle: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.subTitle.toLowerCase()),\n    mainStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),\n    secondaryStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),\n    arc: findFieldsByPrefix(nodes, NodeGraphDataFrameFieldNames.arc),\n    details: findFieldsByPrefix(nodes, NodeGraphDataFrameFieldNames.detail),\n    color: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.color),\n  };\n}\n\nexport function getEdgeFields(edges: DataFrame) {\n  const normalizedFrames = {\n    ...edges,\n    fields: edges.fields.map((field) => ({ ...field, name: field.name.toLowerCase() })),\n  };\n  const fieldsCache = new FieldCache(normalizedFrames);\n  return {\n    id: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id.toLowerCase()),\n    source: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.source.toLowerCase()),\n    target: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.target.toLowerCase()),\n    mainStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),\n    secondaryStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),\n    details: findFieldsByPrefix(edges, NodeGraphDataFrameFieldNames.detail.toLowerCase()),\n  };\n}\n\nfunction findFieldsByPrefix(frame: DataFrame, prefix: string) {\n  return frame.fields.filter((f) => f.name.match(new RegExp('^' + prefix)));\n}\n\n/**\n * Transform nodes and edges dataframes into array of objects that the layout code can then work with.\n */\nexport function processNodes(\n  nodes: DataFrame | undefined,\n  edges: DataFrame | undefined,\n  theme: GrafanaTheme2\n): {\n  nodes: NodeDatum[];\n  edges: EdgeDatum[];\n  legend?: Array<{\n    color: string;\n    name: string;\n  }>;\n} {\n  if (!nodes) {\n    return { nodes: [], edges: [] };\n  }\n\n  const nodeFields = getNodeFields(nodes);\n  if (!nodeFields.id) {\n    throw new Error('id field is required for nodes data frame.');\n  }\n\n  const nodesMap =\n    nodeFields.id.values.toArray().reduce<{ [id: string]: NodeDatum }>((acc, id, index) => {\n      acc[id] = {\n        id: id,\n        title: nodeFields.title?.values.get(index) || '',\n        subTitle: nodeFields.subTitle ? nodeFields.subTitle.values.get(index) : '',\n        dataFrameRowIndex: index,\n        incoming: 0,\n        mainStat: nodeFields.mainStat,\n        secondaryStat: nodeFields.secondaryStat,\n        arcSections: nodeFields.arc,\n        color: nodeFields.color,\n      };\n      return acc;\n    }, {}) || {};\n\n  let edgesMapped: EdgeDatum[] = [];\n  // We may not have edges in case of single node\n  if (edges) {\n    const edgeFields = getEdgeFields(edges);\n    if (!edgeFields.id) {\n      throw new Error('id field is required for edges data frame.');\n    }\n\n    edgesMapped = edgeFields.id.values.toArray().map((id, index) => {\n      const target = edgeFields.target?.values.get(index);\n      const source = edgeFields.source?.values.get(index);\n      // We are adding incoming edges count so we can later on find out which nodes are the roots\n      nodesMap[target].incoming++;\n\n      return {\n        id,\n        dataFrameRowIndex: index,\n        source,\n        target,\n        mainStat: edgeFields.mainStat ? statToString(edgeFields.mainStat, index) : '',\n        secondaryStat: edgeFields.secondaryStat ? statToString(edgeFields.secondaryStat, index) : '',\n      } as EdgeDatum;\n    });\n  }\n\n  return {\n    nodes: Object.values(nodesMap),\n    edges: edgesMapped || [],\n    legend: nodeFields.arc.map((f) => {\n      return {\n        color: f.config.color?.fixedColor ?? '',\n        name: f.config.displayName || f.name,\n      };\n    }),\n  };\n}\n\nexport function statToString(field: Field, index: number) {\n  if (field.type === FieldType.string) {\n    return field.values.get(index);\n  } else {\n    const decimals = field.config.decimals || 2;\n    const val = field.values.get(index);\n    if (Number.isFinite(val)) {\n      return field.values.get(index).toFixed(decimals) + (field.config.unit ? ' ' + field.config.unit : '');\n    } else {\n      return '';\n    }\n  }\n}\n\n/**\n * Utilities mainly for testing\n */\n\nexport function makeNodesDataFrame(count: number) {\n  const frame = nodesFrame();\n  for (let i = 0; i < count; i++) {\n    frame.add(makeNode(i));\n  }\n\n  return frame;\n}\n\nfunction makeNode(index: number) {\n  return {\n    id: index.toString(),\n    title: `service:${index}`,\n    subtitle: 'service',\n    arc__success: 0.5,\n    arc__errors: 0.5,\n    mainstat: 0.1,\n    secondarystat: 2,\n    color: 0.5,\n  };\n}\n\nfunction nodesFrame() {\n  const fields: any = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.title]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.subTitle]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.mainStat]: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.secondaryStat]: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'success']: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: { color: { fixedColor: 'green' } },\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'errors']: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: { color: { fixedColor: 'red' } },\n    },\n\n    [NodeGraphDataFrameFieldNames.color]: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: { color: { mode: 'continuous-GrYlRd' } },\n    },\n  };\n\n  return new MutableDataFrame({\n    name: 'nodes',\n    fields: Object.keys(fields).map((key) => ({\n      ...fields[key],\n      name: key,\n    })),\n  });\n}\n\nexport function makeEdgesDataFrame(edges: Array<[number, number]>) {\n  const frame = edgesFrame();\n  for (const edge of edges) {\n    frame.add({\n      id: edge[0] + '--' + edge[1],\n      source: edge[0].toString(),\n      target: edge[1].toString(),\n    });\n  }\n\n  return frame;\n}\n\nfunction edgesFrame() {\n  const fields: any = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.source]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.target]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n  };\n\n  return new MutableDataFrame({\n    name: 'edges',\n    fields: Object.keys(fields).map((key) => ({\n      ...fields[key],\n      name: key,\n    })),\n  });\n}\n\nexport interface Bounds {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n  center: {\n    x: number;\n    y: number;\n  };\n}\n\n/**\n * Get bounds of the graph meaning the extent of the nodes in all directions.\n */\nexport function graphBounds(nodes: NodeDatum[]): Bounds {\n  if (nodes.length === 0) {\n    return { top: 0, right: 0, bottom: 0, left: 0, center: { x: 0, y: 0 } };\n  }\n\n  const bounds = nodes.reduce(\n    (acc, node) => {\n      if (node.x! > acc.right) {\n        acc.right = node.x!;\n      }\n      if (node.x! < acc.left) {\n        acc.left = node.x!;\n      }\n      if (node.y! > acc.bottom) {\n        acc.bottom = node.y!;\n      }\n      if (node.y! < acc.top) {\n        acc.top = node.y!;\n      }\n      return acc;\n    },\n    { top: Infinity, right: -Infinity, bottom: -Infinity, left: Infinity }\n  );\n\n  const y = bounds.top + (bounds.bottom - bounds.top) / 2;\n  const x = bounds.left + (bounds.right - bounds.left) / 2;\n\n  return {\n    ...bounds,\n    center: {\n      x,\n      y,\n    },\n  };\n}\n\nexport function getNodeGraphDataFrames(frames: DataFrame[], options?: NodeGraphOptions) {\n  // TODO: this not in sync with how other types of responses are handled. Other types have a query response\n  //  processing pipeline which ends up populating redux state with proper data. As we move towards more dataFrame\n  //  oriented API it seems like a better direction to move such processing into to visualisations and do minimal\n  //  and lazy processing here. Needs bigger refactor so keeping nodeGraph and Traces as they are for now.\n  let nodeGraphFrames = frames.filter((frame) => {\n    if (frame.meta?.preferredVisualisationType === 'nodeGraph') {\n      return true;\n    }\n\n    if (frame.name === 'nodes' || frame.name === 'edges' || frame.refId === 'nodes' || frame.refId === 'edges') {\n      return true;\n    }\n\n    const fieldsCache = new FieldCache(frame);\n    if (fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id)) {\n      return true;\n    }\n\n    return false;\n  });\n\n  // If panel options are provided, interpolate their values in to the data frames\n  if (options) {\n    nodeGraphFrames = applyOptionsToFrames(nodeGraphFrames, options);\n  }\n  return nodeGraphFrames;\n}\n\nexport const applyOptionsToFrames = (frames: DataFrame[], options: NodeGraphOptions): DataFrame[] => {\n  return frames.map((frame) => {\n    const fieldsCache = new FieldCache(frame);\n\n    // Edges frame has source which can be used to identify nodes vs edges frames\n    if (fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.source.toLowerCase())) {\n      if (options?.edges?.mainStatUnit) {\n        const field = frame.fields.find((field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.mainStat);\n        if (field) {\n          field.config = { ...field.config, unit: options.edges.mainStatUnit };\n        }\n      }\n      if (options?.edges?.secondaryStatUnit) {\n        const field = frame.fields.find(\n          (field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.secondaryStat\n        );\n        if (field) {\n          field.config = { ...field.config, unit: options.edges.secondaryStatUnit };\n        }\n      }\n    } else {\n      if (options?.nodes?.mainStatUnit) {\n        const field = frame.fields.find((field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.mainStat);\n        if (field) {\n          field.config = { ...field.config, unit: options.nodes.mainStatUnit };\n        }\n      }\n      if (options?.nodes?.secondaryStatUnit) {\n        const field = frame.fields.find(\n          (field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.secondaryStat\n        );\n        if (field) {\n          field.config = { ...field.config, unit: options.nodes.secondaryStatUnit };\n        }\n      }\n      if (options?.nodes?.arcs?.length) {\n        for (const arc of options.nodes.arcs) {\n          const field = frame.fields.find((field) => field.name.toLowerCase() === arc.field);\n          if (field && arc.color) {\n            field.config = { ...field.config, color: { fixedColor: arc.color, mode: FieldColorModeId.Fixed } };\n          }\n        }\n      }\n    }\n    return frame;\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}