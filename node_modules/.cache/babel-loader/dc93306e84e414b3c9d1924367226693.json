{"ast":null,"code":"const _excluded = [\"ref\"];\n\nvar _Label, _AnnotationsField;\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { css } from '@emotion/css';\nimport classNames from 'classnames';\nimport React, { useCallback } from 'react';\nimport { useFormContext } from 'react-hook-form';\nimport { Stack } from '@grafana/experimental';\nimport { useStyles2, Field, Input, InputControl, Label, Tooltip, Icon } from '@grafana/ui';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { AccessControlAction } from 'app/types';\nimport { RuleFormType } from '../../types/rule-form';\nimport AnnotationsField from './AnnotationsField';\nimport { GroupAndNamespaceFields } from './GroupAndNamespaceFields';\nimport { RuleEditorSection } from './RuleEditorSection';\nimport { RuleFolderPicker } from './RuleFolderPicker';\nimport { checkForPathSeparator } from './util';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst recordingRuleNameValidationPattern = {\n  message: 'Recording rule name must be valid metric name. It may only contain letters, numbers, and colons. It may not contain whitespace.',\n  value: /^[a-zA-Z_:][a-zA-Z0-9_:]*$/\n};\nexport const DetailsStep = ({\n  initialFolder\n}) => {\n  var _errors$name, _errors$name2, _errors$folder, _errors$folder2, _errors$group, _errors$group2;\n\n  const {\n    register,\n    watch,\n    formState: {\n      errors\n    }\n  } = useFormContext();\n  const styles = useStyles2(getStyles);\n  const ruleFormType = watch('type');\n  const dataSourceName = watch('dataSourceName');\n  const type = watch('type');\n  const folderFilter = useRuleFolderFilter(initialFolder);\n  return /*#__PURE__*/_jsxs(RuleEditorSection, {\n    stepNo: type === RuleFormType.cloudRecording ? 2 : 3,\n    title: type === RuleFormType.cloudRecording ? 'Add details for your recording rule' : 'Add details for your alert',\n    description: type === RuleFormType.cloudRecording ? 'Add labels to help you better manage your rules' : 'Write a summary and add labels to help you better manage your alerts',\n    children: [/*#__PURE__*/_jsx(Field, {\n      className: styles.formInput,\n      label: \"Rule name\",\n      error: errors === null || errors === void 0 ? void 0 : (_errors$name = errors.name) === null || _errors$name === void 0 ? void 0 : _errors$name.message,\n      invalid: !!((_errors$name2 = errors.name) !== null && _errors$name2 !== void 0 && _errors$name2.message),\n      children: /*#__PURE__*/_jsx(Input, Object.assign({\n        id: \"name\"\n      }, register('name', {\n        required: {\n          value: true,\n          message: 'Must enter an alert name'\n        },\n        pattern: ruleFormType === RuleFormType.cloudRecording ? recordingRuleNameValidationPattern : undefined,\n        validate: {\n          pathSeparator: value => {\n            // we use the alert rule name as the \"groupname\" for Grafana managed alerts, so we can't allow path separators\n            if (ruleFormType === RuleFormType.grafana) {\n              return checkForPathSeparator(value);\n            }\n\n            return true;\n          }\n        }\n      })))\n    }), (ruleFormType === RuleFormType.cloudRecording || ruleFormType === RuleFormType.cloudAlerting) && dataSourceName && /*#__PURE__*/_jsx(GroupAndNamespaceFields, {\n      rulesSourceName: dataSourceName\n    }), ruleFormType === RuleFormType.grafana && /*#__PURE__*/_jsxs(\"div\", {\n      className: classNames([styles.flexRow, styles.alignBaseline]),\n      children: [/*#__PURE__*/_jsx(Field, {\n        label: _Label || (_Label = /*#__PURE__*/_jsx(Label, {\n          htmlFor: \"folder\",\n          description: 'Select a folder to store your rule.',\n          children: /*#__PURE__*/_jsxs(Stack, {\n            gap: 0.5,\n            children: [\"Folder\", /*#__PURE__*/_jsx(Tooltip, {\n              placement: \"top\",\n              content: /*#__PURE__*/_jsx(\"div\", {\n                children: \"Each folder has unique folder permission. When you store multiple rules in a folder, the folder access permissions get assigned to the rules.\"\n              }),\n              children: /*#__PURE__*/_jsx(Icon, {\n                name: \"info-circle\",\n                size: \"xs\"\n              })\n            })]\n          })\n        })),\n        className: styles.formInput,\n        error: (_errors$folder = errors.folder) === null || _errors$folder === void 0 ? void 0 : _errors$folder.message,\n        invalid: !!((_errors$folder2 = errors.folder) !== null && _errors$folder2 !== void 0 && _errors$folder2.message),\n        \"data-testid\": \"folder-picker\",\n        children: /*#__PURE__*/_jsx(InputControl, {\n          render: _ref => {\n            let {} = _ref,\n                field = _objectWithoutPropertiesLoose(_ref.field, _excluded);\n\n            return /*#__PURE__*/_jsx(RuleFolderPicker, Object.assign({\n              inputId: \"folder\"\n            }, field, {\n              enableCreateNew: contextSrv.hasPermission(AccessControlAction.FoldersCreate),\n              enableReset: true,\n              filter: folderFilter\n            }));\n          },\n          name: \"folder\",\n          rules: {\n            required: {\n              value: true,\n              message: 'Please select a folder'\n            },\n            validate: {\n              pathSeparator: folder => checkForPathSeparator(folder.title)\n            }\n          }\n        })\n      }), /*#__PURE__*/_jsx(Field, {\n        label: \"Group\",\n        \"data-testid\": \"group-picker\",\n        description: \"Rules within the same group are evaluated after the same time interval.\",\n        className: styles.formInput,\n        error: (_errors$group = errors.group) === null || _errors$group === void 0 ? void 0 : _errors$group.message,\n        invalid: !!((_errors$group2 = errors.group) !== null && _errors$group2 !== void 0 && _errors$group2.message),\n        children: /*#__PURE__*/_jsx(Input, Object.assign({\n          id: \"group\"\n        }, register('group', {\n          required: {\n            value: true,\n            message: 'Must enter a group name'\n          }\n        })))\n      })]\n    }), type !== RuleFormType.cloudRecording && (_AnnotationsField || (_AnnotationsField = /*#__PURE__*/_jsx(AnnotationsField, {})))]\n  });\n};\n\nconst useRuleFolderFilter = existingRuleForm => {\n  const isSearchHitAvailable = useCallback(hit => {\n    const rbacDisabledFallback = contextSrv.hasEditPermissionInFolders;\n    const canCreateRuleInFolder = contextSrv.hasAccessInMetadata(AccessControlAction.AlertingRuleCreate, hit, rbacDisabledFallback);\n    const canUpdateInCurrentFolder = existingRuleForm && hit.folderId === existingRuleForm.id && contextSrv.hasAccessInMetadata(AccessControlAction.AlertingRuleUpdate, hit, rbacDisabledFallback);\n    return canCreateRuleInFolder || canUpdateInCurrentFolder;\n  }, [existingRuleForm]);\n  return useCallback(folderHits => folderHits.filter(isSearchHitAvailable), [isSearchHitAvailable]);\n};\n\nconst getStyles = theme => ({\n  alignBaseline: css`\n    align-items: baseline;\n    margin-bottom: ${theme.spacing(3)};\n  `,\n  formInput: css`\n    width: 275px;\n\n    & + & {\n      margin-left: ${theme.spacing(3)};\n    }\n  `,\n  flexRow: css`\n    display: flex;\n    flex-direction: row;\n    justify-content: flex-start;\n    align-items: flex-end;\n  `\n});","map":{"version":3,"names":["css","classNames","React","useCallback","useFormContext","Stack","useStyles2","Field","Input","InputControl","Label","Tooltip","Icon","contextSrv","AccessControlAction","RuleFormType","AnnotationsField","GroupAndNamespaceFields","RuleEditorSection","RuleFolderPicker","checkForPathSeparator","recordingRuleNameValidationPattern","message","value","DetailsStep","initialFolder","register","watch","formState","errors","styles","getStyles","ruleFormType","dataSourceName","type","folderFilter","useRuleFolderFilter","cloudRecording","formInput","name","required","pattern","undefined","validate","pathSeparator","grafana","cloudAlerting","flexRow","alignBaseline","folder","field","hasPermission","FoldersCreate","title","group","existingRuleForm","isSearchHitAvailable","hit","rbacDisabledFallback","hasEditPermissionInFolders","canCreateRuleInFolder","hasAccessInMetadata","AlertingRuleCreate","canUpdateInCurrentFolder","folderId","id","AlertingRuleUpdate","folderHits","filter","theme","spacing"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/components/rule-editor/DetailsStep.tsx"],"sourcesContent":["import { css } from '@emotion/css';\nimport classNames from 'classnames';\nimport React, { useCallback } from 'react';\nimport { useFormContext } from 'react-hook-form';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { Stack } from '@grafana/experimental';\nimport { useStyles2, Field, Input, InputControl, Label, Tooltip, Icon } from '@grafana/ui';\nimport { FolderPickerFilter } from 'app/core/components/Select/FolderPicker';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { DashboardSearchHit } from 'app/features/search/types';\nimport { AccessControlAction } from 'app/types';\n\nimport { RuleForm, RuleFormType, RuleFormValues } from '../../types/rule-form';\n\nimport AnnotationsField from './AnnotationsField';\nimport { GroupAndNamespaceFields } from './GroupAndNamespaceFields';\nimport { RuleEditorSection } from './RuleEditorSection';\nimport { RuleFolderPicker, Folder } from './RuleFolderPicker';\nimport { checkForPathSeparator } from './util';\n\nconst recordingRuleNameValidationPattern = {\n  message:\n    'Recording rule name must be valid metric name. It may only contain letters, numbers, and colons. It may not contain whitespace.',\n  value: /^[a-zA-Z_:][a-zA-Z0-9_:]*$/,\n};\n\ninterface DetailsStepProps {\n  initialFolder: RuleForm | null;\n}\n\nexport const DetailsStep = ({ initialFolder }: DetailsStepProps) => {\n  const {\n    register,\n    watch,\n    formState: { errors },\n  } = useFormContext<RuleFormValues & { location?: string }>();\n\n  const styles = useStyles2(getStyles);\n\n  const ruleFormType = watch('type');\n  const dataSourceName = watch('dataSourceName');\n  const type = watch('type');\n\n  const folderFilter = useRuleFolderFilter(initialFolder);\n\n  return (\n    <RuleEditorSection\n      stepNo={type === RuleFormType.cloudRecording ? 2 : 3}\n      title={\n        type === RuleFormType.cloudRecording ? 'Add details for your recording rule' : 'Add details for your alert'\n      }\n      description={\n        type === RuleFormType.cloudRecording\n          ? 'Add labels to help you better manage your rules'\n          : 'Write a summary and add labels to help you better manage your alerts'\n      }\n    >\n      <Field\n        className={styles.formInput}\n        label=\"Rule name\"\n        error={errors?.name?.message}\n        invalid={!!errors.name?.message}\n      >\n        <Input\n          id=\"name\"\n          {...register('name', {\n            required: { value: true, message: 'Must enter an alert name' },\n            pattern: ruleFormType === RuleFormType.cloudRecording ? recordingRuleNameValidationPattern : undefined,\n            validate: {\n              pathSeparator: (value: string) => {\n                // we use the alert rule name as the \"groupname\" for Grafana managed alerts, so we can't allow path separators\n                if (ruleFormType === RuleFormType.grafana) {\n                  return checkForPathSeparator(value);\n                }\n\n                return true;\n              },\n            },\n          })}\n        />\n      </Field>\n\n      {(ruleFormType === RuleFormType.cloudRecording || ruleFormType === RuleFormType.cloudAlerting) &&\n        dataSourceName && <GroupAndNamespaceFields rulesSourceName={dataSourceName} />}\n\n      {ruleFormType === RuleFormType.grafana && (\n        <div className={classNames([styles.flexRow, styles.alignBaseline])}>\n          <Field\n            label={\n              <Label htmlFor=\"folder\" description={'Select a folder to store your rule.'}>\n                <Stack gap={0.5}>\n                  Folder\n                  <Tooltip\n                    placement=\"top\"\n                    content={\n                      <div>\n                        Each folder has unique folder permission. When you store multiple rules in a folder, the folder\n                        access permissions get assigned to the rules.\n                      </div>\n                    }\n                  >\n                    <Icon name=\"info-circle\" size=\"xs\" />\n                  </Tooltip>\n                </Stack>\n              </Label>\n            }\n            className={styles.formInput}\n            error={errors.folder?.message}\n            invalid={!!errors.folder?.message}\n            data-testid=\"folder-picker\"\n          >\n            <InputControl\n              render={({ field: { ref, ...field } }) => (\n                <RuleFolderPicker\n                  inputId=\"folder\"\n                  {...field}\n                  enableCreateNew={contextSrv.hasPermission(AccessControlAction.FoldersCreate)}\n                  enableReset={true}\n                  filter={folderFilter}\n                />\n              )}\n              name=\"folder\"\n              rules={{\n                required: { value: true, message: 'Please select a folder' },\n                validate: {\n                  pathSeparator: (folder: Folder) => checkForPathSeparator(folder.title),\n                },\n              }}\n            />\n          </Field>\n          <Field\n            label=\"Group\"\n            data-testid=\"group-picker\"\n            description=\"Rules within the same group are evaluated after the same time interval.\"\n            className={styles.formInput}\n            error={errors.group?.message}\n            invalid={!!errors.group?.message}\n          >\n            <Input\n              id=\"group\"\n              {...register('group', {\n                required: { value: true, message: 'Must enter a group name' },\n              })}\n            />\n          </Field>\n        </div>\n      )}\n      {type !== RuleFormType.cloudRecording && <AnnotationsField />}\n    </RuleEditorSection>\n  );\n};\n\nconst useRuleFolderFilter = (existingRuleForm: RuleForm | null) => {\n  const isSearchHitAvailable = useCallback(\n    (hit: DashboardSearchHit) => {\n      const rbacDisabledFallback = contextSrv.hasEditPermissionInFolders;\n\n      const canCreateRuleInFolder = contextSrv.hasAccessInMetadata(\n        AccessControlAction.AlertingRuleCreate,\n        hit,\n        rbacDisabledFallback\n      );\n\n      const canUpdateInCurrentFolder =\n        existingRuleForm &&\n        hit.folderId === existingRuleForm.id &&\n        contextSrv.hasAccessInMetadata(AccessControlAction.AlertingRuleUpdate, hit, rbacDisabledFallback);\n\n      return canCreateRuleInFolder || canUpdateInCurrentFolder;\n    },\n    [existingRuleForm]\n  );\n\n  return useCallback<FolderPickerFilter>(\n    (folderHits) => folderHits.filter(isSearchHitAvailable),\n    [isSearchHitAvailable]\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  alignBaseline: css`\n    align-items: baseline;\n    margin-bottom: ${theme.spacing(3)};\n  `,\n  formInput: css`\n    width: 275px;\n\n    & + & {\n      margin-left: ${theme.spacing(3)};\n    }\n  `,\n  flexRow: css`\n    display: flex;\n    flex-direction: row;\n    justify-content: flex-start;\n    align-items: flex-end;\n  `,\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}