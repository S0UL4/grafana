{"ast":null,"code":"import React from 'react';\nimport { Button, Checkbox, Field, Input } from '@grafana/ui';\nimport { OptionElement } from './OptionElement';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nexport const NotificationChannelOptions = ({\n  control,\n  currentFormValues,\n  errors,\n  selectedChannelOptions,\n  register,\n  onResetSecureField,\n  secureFields\n}) => {\n  return /*#__PURE__*/_jsx(_Fragment, {\n    children: selectedChannelOptions.map((option, index) => {\n      var _errors$settings$opti;\n\n      const key = `${option.label}-${index}`; // Some options can be dependent on other options, this determines what is selected in the dependency options\n      // I think this needs more thought.\n\n      const selectedOptionValue = currentFormValues[`settings.${option.showWhen.field}`] && currentFormValues[`settings.${option.showWhen.field}`].value;\n\n      if (option.showWhen.field && selectedOptionValue !== option.showWhen.is) {\n        return null;\n      }\n\n      if (option.element === 'checkbox') {\n        return /*#__PURE__*/_jsx(Field, {\n          children: /*#__PURE__*/_jsx(Checkbox, Object.assign({}, register(option.secure ? `secureSettings.${option.propertyName}` : `settings.${option.propertyName}`), {\n            label: option.label,\n            description: option.description\n          }))\n        }, key);\n      }\n\n      return /*#__PURE__*/_jsx(Field, {\n        label: option.label,\n        description: option.description,\n        invalid: errors.settings && !!errors.settings[option.propertyName],\n        error: errors.settings && ((_errors$settings$opti = errors.settings[option.propertyName]) === null || _errors$settings$opti === void 0 ? void 0 : _errors$settings$opti.message),\n        children: secureFields && secureFields[option.propertyName] ? /*#__PURE__*/_jsx(Input, {\n          readOnly: true,\n          value: \"Configured\",\n          suffix: /*#__PURE__*/_jsx(Button, {\n            onClick: () => onResetSecureField(option.propertyName),\n            fill: \"text\",\n            type: \"button\",\n            size: \"sm\",\n            children: \"Clear\"\n          })\n        }) : /*#__PURE__*/_jsx(OptionElement, {\n          option: option,\n          register: register,\n          control: control\n        })\n      }, key);\n    })\n  });\n};","map":{"version":3,"names":["React","Button","Checkbox","Field","Input","OptionElement","NotificationChannelOptions","control","currentFormValues","errors","selectedChannelOptions","register","onResetSecureField","secureFields","map","option","index","key","label","selectedOptionValue","showWhen","field","value","is","element","secure","propertyName","description","settings","message"],"sources":["/home/soula/grafana/public/app/features/alerting/components/NotificationChannelOptions.tsx"],"sourcesContent":["import React, { FC } from 'react';\n\nimport { SelectableValue } from '@grafana/data';\nimport { Button, Checkbox, Field, Input } from '@grafana/ui';\n\nimport { NotificationChannelDTO, NotificationChannelOption, NotificationChannelSecureFields } from '../../../types';\n\nimport { NotificationSettingsProps } from './NotificationChannelForm';\nimport { OptionElement } from './OptionElement';\n\ninterface Props extends NotificationSettingsProps {\n  selectedChannelOptions: NotificationChannelOption[];\n  currentFormValues: NotificationChannelDTO;\n  secureFields: NotificationChannelSecureFields;\n\n  onResetSecureField: (key: string) => void;\n}\n\nexport const NotificationChannelOptions: FC<Props> = ({\n  control,\n  currentFormValues,\n  errors,\n  selectedChannelOptions,\n  register,\n  onResetSecureField,\n  secureFields,\n}) => {\n  return (\n    <>\n      {selectedChannelOptions.map((option: NotificationChannelOption, index: number) => {\n        const key = `${option.label}-${index}`;\n        // Some options can be dependent on other options, this determines what is selected in the dependency options\n        // I think this needs more thought.\n        const selectedOptionValue =\n          currentFormValues[`settings.${option.showWhen.field}`] &&\n          (currentFormValues[`settings.${option.showWhen.field}`] as SelectableValue<string>).value;\n\n        if (option.showWhen.field && selectedOptionValue !== option.showWhen.is) {\n          return null;\n        }\n\n        if (option.element === 'checkbox') {\n          return (\n            <Field key={key}>\n              <Checkbox\n                {...register(\n                  option.secure ? `secureSettings.${option.propertyName}` : `settings.${option.propertyName}`\n                )}\n                label={option.label}\n                description={option.description}\n              />\n            </Field>\n          );\n        }\n        return (\n          <Field\n            key={key}\n            label={option.label}\n            description={option.description}\n            invalid={errors.settings && !!errors.settings[option.propertyName]}\n            error={errors.settings && errors.settings[option.propertyName]?.message}\n          >\n            {secureFields && secureFields[option.propertyName] ? (\n              <Input\n                readOnly={true}\n                value=\"Configured\"\n                suffix={\n                  <Button onClick={() => onResetSecureField(option.propertyName)} fill=\"text\" type=\"button\" size=\"sm\">\n                    Clear\n                  </Button>\n                }\n              />\n            ) : (\n              <OptionElement option={option} register={register} control={control} />\n            )}\n          </Field>\n        );\n      })}\n    </>\n  );\n};\n"],"mappings":"AAAA,OAAOA,KAAP,MAA0B,OAA1B;AAGA,SAASC,MAAT,EAAiBC,QAAjB,EAA2BC,KAA3B,EAAkCC,KAAlC,QAA+C,aAA/C;AAKA,SAASC,aAAT,QAA8B,iBAA9B;;;AAUA,OAAO,MAAMC,0BAAqC,GAAG,CAAC;EACpDC,OADoD;EAEpDC,iBAFoD;EAGpDC,MAHoD;EAIpDC,sBAJoD;EAKpDC,QALoD;EAMpDC,kBANoD;EAOpDC;AAPoD,CAAD,KAQ/C;EACJ,oBACE;IAAA,UACGH,sBAAsB,CAACI,GAAvB,CAA2B,CAACC,MAAD,EAAoCC,KAApC,KAAsD;MAAA;;MAChF,MAAMC,GAAG,GAAI,GAAEF,MAAM,CAACG,KAAM,IAAGF,KAAM,EAArC,CADgF,CAEhF;MACA;;MACA,MAAMG,mBAAmB,GACvBX,iBAAiB,CAAE,YAAWO,MAAM,CAACK,QAAP,CAAgBC,KAAM,EAAnC,CAAjB,IACCb,iBAAiB,CAAE,YAAWO,MAAM,CAACK,QAAP,CAAgBC,KAAM,EAAnC,CAAlB,CAAoFC,KAFtF;;MAIA,IAAIP,MAAM,CAACK,QAAP,CAAgBC,KAAhB,IAAyBF,mBAAmB,KAAKJ,MAAM,CAACK,QAAP,CAAgBG,EAArE,EAAyE;QACvE,OAAO,IAAP;MACD;;MAED,IAAIR,MAAM,CAACS,OAAP,KAAmB,UAAvB,EAAmC;QACjC,oBACE,KAAC,KAAD;UAAA,uBACE,KAAC,QAAD,oBACMb,QAAQ,CACVI,MAAM,CAACU,MAAP,GAAiB,kBAAiBV,MAAM,CAACW,YAAa,EAAtD,GAA2D,YAAWX,MAAM,CAACW,YAAa,EADhF,CADd;YAIE,KAAK,EAAEX,MAAM,CAACG,KAJhB;YAKE,WAAW,EAAEH,MAAM,CAACY;UALtB;QADF,GAAYV,GAAZ,CADF;MAWD;;MACD,oBACE,KAAC,KAAD;QAEE,KAAK,EAAEF,MAAM,CAACG,KAFhB;QAGE,WAAW,EAAEH,MAAM,CAACY,WAHtB;QAIE,OAAO,EAAElB,MAAM,CAACmB,QAAP,IAAmB,CAAC,CAACnB,MAAM,CAACmB,QAAP,CAAgBb,MAAM,CAACW,YAAvB,CAJhC;QAKE,KAAK,EAAEjB,MAAM,CAACmB,QAAP,8BAAmBnB,MAAM,CAACmB,QAAP,CAAgBb,MAAM,CAACW,YAAvB,CAAnB,0DAAmB,sBAAsCG,OAAzD,CALT;QAAA,UAOGhB,YAAY,IAAIA,YAAY,CAACE,MAAM,CAACW,YAAR,CAA5B,gBACC,KAAC,KAAD;UACE,QAAQ,EAAE,IADZ;UAEE,KAAK,EAAC,YAFR;UAGE,MAAM,eACJ,KAAC,MAAD;YAAQ,OAAO,EAAE,MAAMd,kBAAkB,CAACG,MAAM,CAACW,YAAR,CAAzC;YAAgE,IAAI,EAAC,MAArE;YAA4E,IAAI,EAAC,QAAjF;YAA0F,IAAI,EAAC,IAA/F;YAAA;UAAA;QAJJ,EADD,gBAWC,KAAC,aAAD;UAAe,MAAM,EAAEX,MAAvB;UAA+B,QAAQ,EAAEJ,QAAzC;UAAmD,OAAO,EAAEJ;QAA5D;MAlBJ,GACOU,GADP,CADF;IAuBD,CAhDA;EADH,EADF;AAqDD,CA9DM"},"metadata":{},"sourceType":"module"}