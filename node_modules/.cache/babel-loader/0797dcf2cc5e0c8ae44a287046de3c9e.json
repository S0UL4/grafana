{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { DataSourceWithBackend } from '@grafana/runtime';\nimport { locationDisplayNames, logsSupportedLocationsKusto, logsResourceTypes, resourceTypeDisplayNames, supportedMetricNamespaces } from '../azureMetadata';\nimport { ResourceRowType } from '../components/ResourcePicker/types';\nimport { addResources, parseResourceURI } from '../components/ResourcePicker/utils';\nimport { routeNames } from '../utils/common';\nconst RESOURCE_GRAPH_URL = '/providers/Microsoft.ResourceGraph/resources?api-version=2021-03-01';\nconst logsSupportedResourceTypesKusto = logsResourceTypes.map(v => `\"${v}\"`).join(',');\nconst supportedMetricNamespacesKusto = supportedMetricNamespaces.map(v => `\"${v.toLocaleLowerCase()}\"`).join(',');\nexport default class ResourcePickerData extends DataSourceWithBackend {\n  constructor(instanceSettings) {\n    super(instanceSettings);\n\n    _defineProperty(this, \"resourcePath\", void 0);\n\n    _defineProperty(this, \"resultLimit\", 200);\n\n    _defineProperty(this, \"search\", async (searchPhrase, searchType) => {\n      let searchQuery = 'resources';\n\n      if (searchType === 'logs') {\n        searchQuery += `\n      | union resourcecontainers`;\n      }\n\n      searchQuery += `\n        | where id contains \"${searchPhrase}\"\n        ${this.filterByType(searchType)}\n        | order by tolower(name) asc\n        | limit ${this.resultLimit}\n      `;\n      const {\n        data: response\n      } = await this.makeResourceGraphRequest(searchQuery);\n      return response.map(item => {\n        const parsedUri = parseResourceURI(item.id);\n\n        if (!parsedUri || !(parsedUri.resource || parsedUri.resourceGroup || parsedUri.subscriptionID)) {\n          throw new Error('unable to fetch resource details');\n        }\n\n        let id = parsedUri.subscriptionID;\n        let type = ResourceRowType.Subscription;\n\n        if (parsedUri.resource) {\n          id = parsedUri.resource;\n          type = ResourceRowType.Resource;\n        } else if (parsedUri.resourceGroup) {\n          id = parsedUri.resourceGroup;\n          type = ResourceRowType.ResourceGroup;\n        }\n\n        return {\n          name: item.name,\n          id,\n          uri: item.id,\n          resourceGroupName: item.resourceGroup,\n          type,\n          typeLabel: resourceTypeDisplayNames[item.type] || item.type,\n          location: locationDisplayNames[item.location] || item.location\n        };\n      });\n    });\n\n    _defineProperty(this, \"filterByType\", t => {\n      return t === 'logs' ? `| where type in (${logsSupportedResourceTypesKusto})` : `| where type in (${supportedMetricNamespacesKusto})`;\n    });\n\n    this.resourcePath = `${routeNames.resourceGraph}`;\n  }\n\n  async fetchInitialRows(type, currentSelection) {\n    const subscriptions = await this.getSubscriptions();\n\n    if (!currentSelection) {\n      return subscriptions;\n    }\n\n    let resources = subscriptions;\n    const parsedURI = parseResourceURI(currentSelection);\n\n    if (parsedURI) {\n      const resourceGroupURI = `/subscriptions/${parsedURI.subscriptionID}/resourceGroups/${parsedURI.resourceGroup}`;\n\n      if (parsedURI.resourceGroup) {\n        const resourceGroups = await this.getResourceGroupsBySubscriptionId(parsedURI.subscriptionID, type);\n        resources = addResources(resources, `/subscriptions/${parsedURI.subscriptionID}`, resourceGroups);\n      }\n\n      if (parsedURI.resource) {\n        const resourcesForResourceGroup = await this.getResourcesForResourceGroup(resourceGroupURI, type);\n        resources = addResources(resources, resourceGroupURI, resourcesForResourceGroup);\n      }\n    }\n\n    return resources;\n  }\n\n  async fetchAndAppendNestedRow(rows, parentRow, type) {\n    const nestedRows = parentRow.type === ResourceRowType.Subscription ? await this.getResourceGroupsBySubscriptionId(parentRow.id, type) : await this.getResourcesForResourceGroup(parentRow.id, type);\n    return addResources(rows, parentRow.uri, nestedRows);\n  }\n\n  // private\n  async getSubscriptions() {\n    const query = `\n    resources\n    | join kind=inner (\n              ResourceContainers\n                | where type == 'microsoft.resources/subscriptions'\n                | project subscriptionName=name, subscriptionURI=id, subscriptionId\n              ) on subscriptionId\n    | summarize count() by subscriptionName, subscriptionURI, subscriptionId\n    | order by subscriptionName desc\n  `;\n    let resources = [];\n    let allFetched = false;\n    let $skipToken = undefined;\n\n    while (!allFetched) {\n      // The response may include several pages\n      let options = {};\n\n      if ($skipToken) {\n        options = {\n          $skipToken\n        };\n      }\n\n      const resourceResponse = await this.makeResourceGraphRequest(query, 1, options);\n\n      if (!resourceResponse.data.length) {\n        throw new Error('No subscriptions were found');\n      }\n\n      resources = resources.concat(resourceResponse.data);\n      $skipToken = resourceResponse.$skipToken;\n      allFetched = !$skipToken;\n    }\n\n    return resources.map(subscription => ({\n      name: subscription.subscriptionName,\n      id: subscription.subscriptionId,\n      uri: `/subscriptions/${subscription.subscriptionId}`,\n      typeLabel: 'Subscription',\n      type: ResourceRowType.Subscription,\n      children: []\n    }));\n  }\n\n  async getResourceGroupsBySubscriptionId(subscriptionId, type) {\n    const query = `\n    resources\n     | join kind=inner (\n       ResourceContainers\n       | where type == 'microsoft.resources/subscriptions/resourcegroups'\n       | project resourceGroupURI=id, resourceGroupName=name, resourceGroup, subscriptionId\n     ) on resourceGroup, subscriptionId\n\n     ${this.filterByType(type)}\n     | where subscriptionId == '${subscriptionId}'\n     | summarize count() by resourceGroupName, resourceGroupURI\n     | order by resourceGroupURI asc`;\n    let resourceGroups = [];\n    let allFetched = false;\n    let $skipToken = undefined;\n\n    while (!allFetched) {\n      // The response may include several pages\n      let options = {};\n\n      if ($skipToken) {\n        options = {\n          $skipToken\n        };\n      }\n\n      const resourceResponse = await this.makeResourceGraphRequest(query, 1, options);\n      resourceGroups = resourceGroups.concat(resourceResponse.data);\n      $skipToken = resourceResponse.$skipToken;\n      allFetched = !$skipToken;\n    }\n\n    return resourceGroups.map(r => {\n      const parsedUri = parseResourceURI(r.resourceGroupURI);\n\n      if (!parsedUri || !parsedUri.resourceGroup) {\n        throw new Error('unable to fetch resource groups');\n      }\n\n      return {\n        name: r.resourceGroupName,\n        uri: r.resourceGroupURI,\n        id: parsedUri.resourceGroup,\n        type: ResourceRowType.ResourceGroup,\n        typeLabel: 'Resource Group',\n        children: []\n      };\n    });\n  }\n\n  async getResourcesForResourceGroup(resourceGroupId, type) {\n    const {\n      data: response\n    } = await this.makeResourceGraphRequest(`\n      resources\n      | where id hasprefix \"${resourceGroupId}\"\n      ${this.filterByType(type)} and location in (${logsSupportedLocationsKusto})\n    `);\n    return response.map(item => {\n      const parsedUri = parseResourceURI(item.id);\n\n      if (!parsedUri || !parsedUri.resource) {\n        throw new Error('unable to fetch resource details');\n      }\n\n      return {\n        name: item.name,\n        id: parsedUri.resource,\n        uri: item.id,\n        resourceGroupName: item.resourceGroup,\n        type: ResourceRowType.Resource,\n        typeLabel: resourceTypeDisplayNames[item.type] || item.type,\n        location: locationDisplayNames[item.location] || item.location\n      };\n    });\n  } // used to make the select resource button that launches the resource picker show a nicer file path to users\n\n\n  async getResourceURIDisplayProperties(resourceURI) {\n    var _parseResourceURI;\n\n    const {\n      subscriptionID,\n      resourceGroup,\n      resource\n    } = (_parseResourceURI = parseResourceURI(resourceURI)) !== null && _parseResourceURI !== void 0 ? _parseResourceURI : {};\n\n    if (!subscriptionID) {\n      throw new Error('Invalid resource URI passed');\n    } // resourceGroupURI and resourceURI could be invalid values, but that's okay because the join\n    // will just silently fail as expected\n\n\n    const subscriptionURI = `/subscriptions/${subscriptionID}`;\n    const resourceGroupURI = `${subscriptionURI}/resourceGroups/${resourceGroup}`;\n    const query = `\n    resourcecontainers\n    | where type == \"microsoft.resources/subscriptions\"\n    | where id =~ \"${subscriptionURI}\"\n    | project subscriptionName=name, subscriptionId\n\n    | join kind=leftouter (\n      resourcecontainers            \n            | where type == \"microsoft.resources/subscriptions/resourcegroups\"\n            | where id =~ \"${resourceGroupURI}\"\n            | project resourceGroupName=name, resourceGroup, subscriptionId\n        ) on subscriptionId\n\n        | join kind=leftouter (\n          resources\n            | where id =~ \"${resourceURI}\"\n            | project resourceName=name, subscriptionId\n        ) on subscriptionId\n\n        | project subscriptionName, resourceGroupName, resourceName\n    `;\n    const {\n      data: response\n    } = await this.makeResourceGraphRequest(query);\n\n    if (!response.length) {\n      throw new Error('unable to fetch resource details');\n    }\n\n    const {\n      subscriptionName,\n      resourceGroupName,\n      resourceName\n    } = response[0]; // if the name is undefined it could be because the id is undefined or because we are using a template variable.\n    // Either way we can use it as a fallback. We don't really want to interpolate these variables because we want\n    // to show the user when they are using template variables `$sub/$rg/$resource`\n\n    return {\n      subscriptionName: subscriptionName || subscriptionID,\n      resourceGroupName: resourceGroupName || resourceGroup,\n      resourceName: resourceName || resource\n    };\n  }\n\n  async getResourceURIFromWorkspace(workspace) {\n    const {\n      data: response\n    } = await this.makeResourceGraphRequest(`\n      resources\n      | where properties['customerId'] == \"${workspace}\"\n      | project id\n    `);\n\n    if (!response.length) {\n      throw new Error('unable to find resource for workspace ' + workspace);\n    }\n\n    return response[0].id;\n  }\n\n  async makeResourceGraphRequest(query, maxRetries = 1, reqOptions) {\n    try {\n      return await this.postResource(this.resourcePath + RESOURCE_GRAPH_URL, {\n        query: query,\n        options: Object.assign({\n          resultFormat: 'objectArray'\n        }, reqOptions)\n      });\n    } catch (error) {\n      if (maxRetries > 0) {\n        return this.makeResourceGraphRequest(query, maxRetries - 1);\n      }\n\n      throw error;\n    }\n  }\n\n}","map":{"version":3,"names":["DataSourceWithBackend","locationDisplayNames","logsSupportedLocationsKusto","logsResourceTypes","resourceTypeDisplayNames","supportedMetricNamespaces","ResourceRowType","addResources","parseResourceURI","routeNames","RESOURCE_GRAPH_URL","logsSupportedResourceTypesKusto","map","v","join","supportedMetricNamespacesKusto","toLocaleLowerCase","ResourcePickerData","constructor","instanceSettings","searchPhrase","searchType","searchQuery","filterByType","resultLimit","data","response","makeResourceGraphRequest","item","parsedUri","id","resource","resourceGroup","subscriptionID","Error","type","Subscription","Resource","ResourceGroup","name","uri","resourceGroupName","typeLabel","location","t","resourcePath","resourceGraph","fetchInitialRows","currentSelection","subscriptions","getSubscriptions","resources","parsedURI","resourceGroupURI","resourceGroups","getResourceGroupsBySubscriptionId","resourcesForResourceGroup","getResourcesForResourceGroup","fetchAndAppendNestedRow","rows","parentRow","nestedRows","query","allFetched","$skipToken","undefined","options","resourceResponse","length","concat","subscription","subscriptionName","subscriptionId","children","r","resourceGroupId","getResourceURIDisplayProperties","resourceURI","subscriptionURI","resourceName","getResourceURIFromWorkspace","workspace","maxRetries","reqOptions","postResource","resultFormat","error"],"sources":["/home/soula/grafana/public/app/plugins/datasource/grafana-azure-monitor-datasource/resourcePicker/resourcePickerData.ts"],"sourcesContent":["import { DataSourceWithBackend } from '@grafana/runtime';\n\nimport { DataSourceInstanceSettings } from '../../../../../../packages/grafana-data/src';\nimport {\n  locationDisplayNames,\n  logsSupportedLocationsKusto,\n  logsResourceTypes,\n  resourceTypeDisplayNames,\n  supportedMetricNamespaces,\n} from '../azureMetadata';\nimport { ResourceRow, ResourceRowGroup, ResourceRowType } from '../components/ResourcePicker/types';\nimport { addResources, parseResourceURI } from '../components/ResourcePicker/utils';\nimport {\n  AzureDataSourceJsonData,\n  AzureGraphResponse,\n  AzureMonitorQuery,\n  AzureResourceGraphOptions,\n  AzureResourceSummaryItem,\n  RawAzureResourceGroupItem,\n  RawAzureResourceItem,\n  RawAzureSubscriptionItem,\n} from '../types';\nimport { routeNames } from '../utils/common';\n\nconst RESOURCE_GRAPH_URL = '/providers/Microsoft.ResourceGraph/resources?api-version=2021-03-01';\n\nconst logsSupportedResourceTypesKusto = logsResourceTypes.map((v) => `\"${v}\"`).join(',');\nconst supportedMetricNamespacesKusto = supportedMetricNamespaces.map((v) => `\"${v.toLocaleLowerCase()}\"`).join(',');\n\nexport type ResourcePickerQueryType = 'logs' | 'metrics';\n\nexport default class ResourcePickerData extends DataSourceWithBackend<AzureMonitorQuery, AzureDataSourceJsonData> {\n  private resourcePath: string;\n  resultLimit = 200;\n\n  constructor(instanceSettings: DataSourceInstanceSettings<AzureDataSourceJsonData>) {\n    super(instanceSettings);\n    this.resourcePath = `${routeNames.resourceGraph}`;\n  }\n\n  async fetchInitialRows(type: ResourcePickerQueryType, currentSelection?: string): Promise<ResourceRowGroup> {\n    const subscriptions = await this.getSubscriptions();\n    if (!currentSelection) {\n      return subscriptions;\n    }\n\n    let resources = subscriptions;\n    const parsedURI = parseResourceURI(currentSelection);\n    if (parsedURI) {\n      const resourceGroupURI = `/subscriptions/${parsedURI.subscriptionID}/resourceGroups/${parsedURI.resourceGroup}`;\n\n      if (parsedURI.resourceGroup) {\n        const resourceGroups = await this.getResourceGroupsBySubscriptionId(parsedURI.subscriptionID, type);\n        resources = addResources(resources, `/subscriptions/${parsedURI.subscriptionID}`, resourceGroups);\n      }\n\n      if (parsedURI.resource) {\n        const resourcesForResourceGroup = await this.getResourcesForResourceGroup(resourceGroupURI, type);\n        resources = addResources(resources, resourceGroupURI, resourcesForResourceGroup);\n      }\n    }\n    return resources;\n  }\n\n  async fetchAndAppendNestedRow(\n    rows: ResourceRowGroup,\n    parentRow: ResourceRow,\n    type: ResourcePickerQueryType\n  ): Promise<ResourceRowGroup> {\n    const nestedRows =\n      parentRow.type === ResourceRowType.Subscription\n        ? await this.getResourceGroupsBySubscriptionId(parentRow.id, type)\n        : await this.getResourcesForResourceGroup(parentRow.id, type);\n\n    return addResources(rows, parentRow.uri, nestedRows);\n  }\n\n  search = async (searchPhrase: string, searchType: ResourcePickerQueryType): Promise<ResourceRowGroup> => {\n    let searchQuery = 'resources';\n    if (searchType === 'logs') {\n      searchQuery += `\n      | union resourcecontainers`;\n    }\n    searchQuery += `\n        | where id contains \"${searchPhrase}\"\n        ${this.filterByType(searchType)}\n        | order by tolower(name) asc\n        | limit ${this.resultLimit}\n      `;\n    const { data: response } = await this.makeResourceGraphRequest<RawAzureResourceItem[]>(searchQuery);\n    return response.map((item) => {\n      const parsedUri = parseResourceURI(item.id);\n      if (!parsedUri || !(parsedUri.resource || parsedUri.resourceGroup || parsedUri.subscriptionID)) {\n        throw new Error('unable to fetch resource details');\n      }\n      let id = parsedUri.subscriptionID;\n      let type = ResourceRowType.Subscription;\n      if (parsedUri.resource) {\n        id = parsedUri.resource;\n        type = ResourceRowType.Resource;\n      } else if (parsedUri.resourceGroup) {\n        id = parsedUri.resourceGroup;\n        type = ResourceRowType.ResourceGroup;\n      }\n      return {\n        name: item.name,\n        id,\n        uri: item.id,\n        resourceGroupName: item.resourceGroup,\n        type,\n        typeLabel: resourceTypeDisplayNames[item.type] || item.type,\n        location: locationDisplayNames[item.location] || item.location,\n      };\n    });\n  };\n\n  // private\n  async getSubscriptions(): Promise<ResourceRowGroup> {\n    const query = `\n    resources\n    | join kind=inner (\n              ResourceContainers\n                | where type == 'microsoft.resources/subscriptions'\n                | project subscriptionName=name, subscriptionURI=id, subscriptionId\n              ) on subscriptionId\n    | summarize count() by subscriptionName, subscriptionURI, subscriptionId\n    | order by subscriptionName desc\n  `;\n\n    let resources: RawAzureSubscriptionItem[] = [];\n\n    let allFetched = false;\n    let $skipToken = undefined;\n    while (!allFetched) {\n      // The response may include several pages\n      let options: Partial<AzureResourceGraphOptions> = {};\n      if ($skipToken) {\n        options = {\n          $skipToken,\n        };\n      }\n      const resourceResponse = await this.makeResourceGraphRequest<RawAzureSubscriptionItem[]>(query, 1, options);\n      if (!resourceResponse.data.length) {\n        throw new Error('No subscriptions were found');\n      }\n      resources = resources.concat(resourceResponse.data);\n      $skipToken = resourceResponse.$skipToken;\n      allFetched = !$skipToken;\n    }\n\n    return resources.map((subscription) => ({\n      name: subscription.subscriptionName,\n      id: subscription.subscriptionId,\n      uri: `/subscriptions/${subscription.subscriptionId}`,\n      typeLabel: 'Subscription',\n      type: ResourceRowType.Subscription,\n      children: [],\n    }));\n  }\n\n  async getResourceGroupsBySubscriptionId(\n    subscriptionId: string,\n    type: ResourcePickerQueryType\n  ): Promise<ResourceRowGroup> {\n    const query = `\n    resources\n     | join kind=inner (\n       ResourceContainers\n       | where type == 'microsoft.resources/subscriptions/resourcegroups'\n       | project resourceGroupURI=id, resourceGroupName=name, resourceGroup, subscriptionId\n     ) on resourceGroup, subscriptionId\n\n     ${this.filterByType(type)}\n     | where subscriptionId == '${subscriptionId}'\n     | summarize count() by resourceGroupName, resourceGroupURI\n     | order by resourceGroupURI asc`;\n\n    let resourceGroups: RawAzureResourceGroupItem[] = [];\n    let allFetched = false;\n    let $skipToken = undefined;\n    while (!allFetched) {\n      // The response may include several pages\n      let options: Partial<AzureResourceGraphOptions> = {};\n      if ($skipToken) {\n        options = {\n          $skipToken,\n        };\n      }\n      const resourceResponse = await this.makeResourceGraphRequest<RawAzureResourceGroupItem[]>(query, 1, options);\n      resourceGroups = resourceGroups.concat(resourceResponse.data);\n      $skipToken = resourceResponse.$skipToken;\n      allFetched = !$skipToken;\n    }\n\n    return resourceGroups.map((r) => {\n      const parsedUri = parseResourceURI(r.resourceGroupURI);\n      if (!parsedUri || !parsedUri.resourceGroup) {\n        throw new Error('unable to fetch resource groups');\n      }\n      return {\n        name: r.resourceGroupName,\n        uri: r.resourceGroupURI,\n        id: parsedUri.resourceGroup,\n        type: ResourceRowType.ResourceGroup,\n        typeLabel: 'Resource Group',\n        children: [],\n      };\n    });\n  }\n\n  async getResourcesForResourceGroup(\n    resourceGroupId: string,\n    type: ResourcePickerQueryType\n  ): Promise<ResourceRowGroup> {\n    const { data: response } = await this.makeResourceGraphRequest<RawAzureResourceItem[]>(`\n      resources\n      | where id hasprefix \"${resourceGroupId}\"\n      ${this.filterByType(type)} and location in (${logsSupportedLocationsKusto})\n    `);\n\n    return response.map((item) => {\n      const parsedUri = parseResourceURI(item.id);\n      if (!parsedUri || !parsedUri.resource) {\n        throw new Error('unable to fetch resource details');\n      }\n      return {\n        name: item.name,\n        id: parsedUri.resource,\n        uri: item.id,\n        resourceGroupName: item.resourceGroup,\n        type: ResourceRowType.Resource,\n        typeLabel: resourceTypeDisplayNames[item.type] || item.type,\n        location: locationDisplayNames[item.location] || item.location,\n      };\n    });\n  }\n\n  // used to make the select resource button that launches the resource picker show a nicer file path to users\n  async getResourceURIDisplayProperties(resourceURI: string): Promise<AzureResourceSummaryItem> {\n    const { subscriptionID, resourceGroup, resource } = parseResourceURI(resourceURI) ?? {};\n\n    if (!subscriptionID) {\n      throw new Error('Invalid resource URI passed');\n    }\n\n    // resourceGroupURI and resourceURI could be invalid values, but that's okay because the join\n    // will just silently fail as expected\n    const subscriptionURI = `/subscriptions/${subscriptionID}`;\n    const resourceGroupURI = `${subscriptionURI}/resourceGroups/${resourceGroup}`;\n\n    const query = `\n    resourcecontainers\n    | where type == \"microsoft.resources/subscriptions\"\n    | where id =~ \"${subscriptionURI}\"\n    | project subscriptionName=name, subscriptionId\n\n    | join kind=leftouter (\n      resourcecontainers            \n            | where type == \"microsoft.resources/subscriptions/resourcegroups\"\n            | where id =~ \"${resourceGroupURI}\"\n            | project resourceGroupName=name, resourceGroup, subscriptionId\n        ) on subscriptionId\n\n        | join kind=leftouter (\n          resources\n            | where id =~ \"${resourceURI}\"\n            | project resourceName=name, subscriptionId\n        ) on subscriptionId\n\n        | project subscriptionName, resourceGroupName, resourceName\n    `;\n\n    const { data: response } = await this.makeResourceGraphRequest<AzureResourceSummaryItem[]>(query);\n\n    if (!response.length) {\n      throw new Error('unable to fetch resource details');\n    }\n\n    const { subscriptionName, resourceGroupName, resourceName } = response[0];\n    // if the name is undefined it could be because the id is undefined or because we are using a template variable.\n    // Either way we can use it as a fallback. We don't really want to interpolate these variables because we want\n    // to show the user when they are using template variables `$sub/$rg/$resource`\n    return {\n      subscriptionName: subscriptionName || subscriptionID,\n      resourceGroupName: resourceGroupName || resourceGroup,\n      resourceName: resourceName || resource,\n    };\n  }\n\n  async getResourceURIFromWorkspace(workspace: string) {\n    const { data: response } = await this.makeResourceGraphRequest<RawAzureResourceItem[]>(`\n      resources\n      | where properties['customerId'] == \"${workspace}\"\n      | project id\n    `);\n\n    if (!response.length) {\n      throw new Error('unable to find resource for workspace ' + workspace);\n    }\n\n    return response[0].id;\n  }\n\n  async makeResourceGraphRequest<T = unknown>(\n    query: string,\n    maxRetries = 1,\n    reqOptions?: Partial<AzureResourceGraphOptions>\n  ): Promise<AzureGraphResponse<T>> {\n    try {\n      return await this.postResource(this.resourcePath + RESOURCE_GRAPH_URL, {\n        query: query,\n        options: {\n          resultFormat: 'objectArray',\n          ...reqOptions,\n        },\n      });\n    } catch (error) {\n      if (maxRetries > 0) {\n        return this.makeResourceGraphRequest(query, maxRetries - 1);\n      }\n\n      throw error;\n    }\n  }\n\n  private filterByType = (t: ResourcePickerQueryType) => {\n    return t === 'logs'\n      ? `| where type in (${logsSupportedResourceTypesKusto})`\n      : `| where type in (${supportedMetricNamespacesKusto})`;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}