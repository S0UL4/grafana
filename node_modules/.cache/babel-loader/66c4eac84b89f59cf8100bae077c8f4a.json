{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { ArrayVector } from '../../vector/ArrayVector';\nimport { getValueMatcher } from '../matchers';\nimport { DataTransformerID } from './ids';\nimport { noopTransformer } from './noop';\nexport let FilterByValueType;\n\n(function (FilterByValueType) {\n  FilterByValueType[\"exclude\"] = \"exclude\";\n  FilterByValueType[\"include\"] = \"include\";\n})(FilterByValueType || (FilterByValueType = {}));\n\nexport let FilterByValueMatch;\n\n(function (FilterByValueMatch) {\n  FilterByValueMatch[\"all\"] = \"all\";\n  FilterByValueMatch[\"any\"] = \"any\";\n})(FilterByValueMatch || (FilterByValueMatch = {}));\n\nexport const filterByValueTransformer = {\n  id: DataTransformerID.filterByValue,\n  name: 'Filter data by values',\n  description: 'select a subset of results based on values',\n  defaultOptions: {\n    filters: [],\n    type: FilterByValueType.include,\n    match: FilterByValueMatch.any\n  },\n  operator: options => source => {\n    const filters = options.filters;\n    const matchAll = options.match === FilterByValueMatch.all;\n    const include = options.type === FilterByValueType.include;\n\n    if (!Array.isArray(filters) || filters.length === 0) {\n      return source.pipe(noopTransformer.operator({}));\n    }\n\n    return source.pipe(map(data => {\n      if (!Array.isArray(data) || data.length === 0) {\n        return data;\n      }\n\n      const rows = new Set();\n\n      for (const frame of data) {\n        const fieldIndexByName = groupFieldIndexByName(frame, data);\n        const matchers = createFilterValueMatchers(filters, fieldIndexByName);\n\n        for (let index = 0; index < frame.length; index++) {\n          if (rows.has(index)) {\n            continue;\n          }\n\n          let matching = true;\n\n          for (const matcher of matchers) {\n            const match = matcher(index, frame, data);\n\n            if (!matchAll && match) {\n              matching = true;\n              break;\n            }\n\n            if (matchAll && !match) {\n              matching = false;\n              break;\n            }\n\n            matching = match;\n          }\n\n          if (matching) {\n            rows.add(index);\n          }\n        }\n      }\n\n      const processed = [];\n      const frameLength = include ? rows.size : data[0].length - rows.size;\n\n      for (const frame of data) {\n        const fields = [];\n\n        for (const field of frame.fields) {\n          const buffer = [];\n\n          for (let index = 0; index < frame.length; index++) {\n            if (include && rows.has(index)) {\n              buffer.push(field.values.get(index));\n              continue;\n            }\n\n            if (!include && !rows.has(index)) {\n              buffer.push(field.values.get(index));\n              continue;\n            }\n          } // We keep field config, but clean the state as it's being recalculated when the field overrides are applied\n\n\n          fields.push(Object.assign({}, field, {\n            values: new ArrayVector(buffer),\n            state: {}\n          }));\n        }\n\n        processed.push(Object.assign({}, frame, {\n          fields: fields,\n          length: frameLength\n        }));\n      }\n\n      return processed;\n    }));\n  }\n};\n\nconst createFilterValueMatchers = (filters, fieldIndexByName) => {\n  const noop = () => false;\n\n  return filters.map(filter => {\n    var _fieldIndexByName$fil;\n\n    const fieldIndex = (_fieldIndexByName$fil = fieldIndexByName[filter.fieldName]) !== null && _fieldIndexByName$fil !== void 0 ? _fieldIndexByName$fil : -1;\n\n    if (fieldIndex < 0) {\n      console.warn(`[FilterByValue] Could not find index for field name: ${filter.fieldName}`);\n      return noop;\n    }\n\n    const matcher = getValueMatcher(filter.config);\n    return (index, frame, data) => matcher(index, frame.fields[fieldIndex], frame, data);\n  });\n};\n\nconst groupFieldIndexByName = (frame, data) => {\n  return frame.fields.reduce((all, field, fieldIndex) => {\n    const fieldName = getFieldDisplayName(field, frame, data);\n    all[fieldName] = fieldIndex;\n    return all;\n  }, {});\n};","map":{"version":3,"names":["map","getFieldDisplayName","ArrayVector","getValueMatcher","DataTransformerID","noopTransformer","FilterByValueType","FilterByValueMatch","filterByValueTransformer","id","filterByValue","name","description","defaultOptions","filters","type","include","match","any","operator","options","source","matchAll","all","Array","isArray","length","pipe","data","rows","Set","frame","fieldIndexByName","groupFieldIndexByName","matchers","createFilterValueMatchers","index","has","matching","matcher","add","processed","frameLength","size","fields","field","buffer","push","values","get","state","noop","filter","fieldIndex","fieldName","console","warn","config","reduce"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/filterByValue.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { DataFrame, Field } from '../../types/dataFrame';\nimport { DataTransformerInfo, MatcherConfig } from '../../types/transformations';\nimport { ArrayVector } from '../../vector/ArrayVector';\nimport { getValueMatcher } from '../matchers';\n\nimport { DataTransformerID } from './ids';\nimport { noopTransformer } from './noop';\n\nexport enum FilterByValueType {\n  exclude = 'exclude',\n  include = 'include',\n}\n\nexport enum FilterByValueMatch {\n  all = 'all',\n  any = 'any',\n}\n\nexport interface FilterByValueFilter {\n  fieldName: string;\n  config: MatcherConfig;\n}\n\nexport interface FilterByValueTransformerOptions {\n  filters: FilterByValueFilter[];\n  type: FilterByValueType;\n  match: FilterByValueMatch;\n}\n\nexport const filterByValueTransformer: DataTransformerInfo<FilterByValueTransformerOptions> = {\n  id: DataTransformerID.filterByValue,\n  name: 'Filter data by values',\n  description: 'select a subset of results based on values',\n  defaultOptions: {\n    filters: [],\n    type: FilterByValueType.include,\n    match: FilterByValueMatch.any,\n  },\n\n  operator: (options) => (source) => {\n    const filters = options.filters;\n    const matchAll = options.match === FilterByValueMatch.all;\n    const include = options.type === FilterByValueType.include;\n\n    if (!Array.isArray(filters) || filters.length === 0) {\n      return source.pipe(noopTransformer.operator({}));\n    }\n\n    return source.pipe(\n      map((data) => {\n        if (!Array.isArray(data) || data.length === 0) {\n          return data;\n        }\n\n        const rows = new Set<number>();\n\n        for (const frame of data) {\n          const fieldIndexByName = groupFieldIndexByName(frame, data);\n          const matchers = createFilterValueMatchers(filters, fieldIndexByName);\n\n          for (let index = 0; index < frame.length; index++) {\n            if (rows.has(index)) {\n              continue;\n            }\n\n            let matching = true;\n\n            for (const matcher of matchers) {\n              const match = matcher(index, frame, data);\n\n              if (!matchAll && match) {\n                matching = true;\n                break;\n              }\n\n              if (matchAll && !match) {\n                matching = false;\n                break;\n              }\n\n              matching = match;\n            }\n\n            if (matching) {\n              rows.add(index);\n            }\n          }\n        }\n\n        const processed: DataFrame[] = [];\n        const frameLength = include ? rows.size : data[0].length - rows.size;\n\n        for (const frame of data) {\n          const fields: Field[] = [];\n\n          for (const field of frame.fields) {\n            const buffer = [];\n\n            for (let index = 0; index < frame.length; index++) {\n              if (include && rows.has(index)) {\n                buffer.push(field.values.get(index));\n                continue;\n              }\n\n              if (!include && !rows.has(index)) {\n                buffer.push(field.values.get(index));\n                continue;\n              }\n            }\n\n            // We keep field config, but clean the state as it's being recalculated when the field overrides are applied\n            fields.push({\n              ...field,\n              values: new ArrayVector(buffer),\n              state: {},\n            });\n          }\n\n          processed.push({\n            ...frame,\n            fields: fields,\n            length: frameLength,\n          });\n        }\n\n        return processed;\n      })\n    );\n  },\n};\n\nconst createFilterValueMatchers = (\n  filters: FilterByValueFilter[],\n  fieldIndexByName: Record<string, number>\n): Array<(index: number, frame: DataFrame, data: DataFrame[]) => boolean> => {\n  const noop = () => false;\n\n  return filters.map((filter) => {\n    const fieldIndex = fieldIndexByName[filter.fieldName] ?? -1;\n\n    if (fieldIndex < 0) {\n      console.warn(`[FilterByValue] Could not find index for field name: ${filter.fieldName}`);\n      return noop;\n    }\n\n    const matcher = getValueMatcher(filter.config);\n    return (index, frame, data) => matcher(index, frame.fields[fieldIndex], frame, data);\n  });\n};\n\nconst groupFieldIndexByName = (frame: DataFrame, data: DataFrame[]): Record<string, number> => {\n  return frame.fields.reduce((all: Record<string, number>, field, fieldIndex) => {\n    const fieldName = getFieldDisplayName(field, frame, data);\n    all[fieldName] = fieldIndex;\n    return all;\n  }, {});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}