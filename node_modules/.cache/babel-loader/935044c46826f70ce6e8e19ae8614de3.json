{"ast":null,"code":"import { orderBy } from 'lodash';\nimport { ArrayVector, FieldType, formattedValueToString, getDisplayProcessor, getFieldColorModeForField, getFieldSeriesColor, outerJoinDataFrames, reduceField, VizOrientation } from '@grafana/data';\nimport { maybeSortFrame } from '@grafana/data/src/transformations/transformers/joinDataFrames';\nimport { AxisPlacement, ScaleDirection, ScaleDistribution, ScaleOrientation, StackingMode } from '@grafana/schema';\nimport { FIXED_UNIT, measureText, UPlotConfigBuilder, UPLOT_AXIS_FONT_SIZE } from '@grafana/ui';\nimport { getStackingGroups } from '@grafana/ui/src/components/uPlot/utils';\nimport { findField } from 'app/features/dimensions';\nimport { getConfig } from './bars';\nimport { defaultBarChartFieldConfig } from './models.gen';\n\nfunction getBarCharScaleOrientation(orientation) {\n  if (orientation === VizOrientation.Vertical) {\n    return {\n      xOri: ScaleOrientation.Horizontal,\n      xDir: ScaleDirection.Right,\n      yOri: ScaleOrientation.Vertical,\n      yDir: ScaleDirection.Up\n    };\n  }\n\n  return {\n    xOri: ScaleOrientation.Vertical,\n    xDir: ScaleDirection.Down,\n    yOri: ScaleOrientation.Horizontal,\n    yDir: ScaleDirection.Right\n  };\n}\n\nexport const preparePlotConfigBuilder = ({\n  frame,\n  theme,\n  orientation,\n  showValue,\n  groupWidth,\n  barWidth,\n  barRadius = 0,\n  stacking,\n  text,\n  rawValue,\n  getColor,\n  fillOpacity,\n  allFrames,\n  xTickLabelRotation,\n  xTickLabelMaxLength,\n  xTickLabelSpacing = 0,\n  legend\n}) => {\n  var _frame$fields$, _frame$fields$0$confi, _frame$fields$0$confi2, _frame$fields$0$confi3, _frame$fields$0$confi4;\n\n  const builder = new UPlotConfigBuilder();\n\n  const defaultValueFormatter = (seriesIdx, value) => {\n    return shortenValue(formattedValueToString(frame.fields[seriesIdx].display(value)), xTickLabelMaxLength);\n  }; // bar orientation -> x scale orientation & direction\n\n\n  const vizOrientation = getBarCharScaleOrientation(orientation);\n  const formatValue = defaultValueFormatter; // Use bar width when only one field\n\n  if (frame.fields.length === 2) {\n    groupWidth = barWidth;\n    barWidth = 1;\n  }\n\n  const opts = {\n    xOri: vizOrientation.xOri,\n    xDir: vizOrientation.xDir,\n    groupWidth,\n    barWidth,\n    barRadius,\n    stacking,\n    rawValue,\n    getColor,\n    fillOpacity,\n    formatValue,\n    text,\n    showValue,\n    legend,\n    xSpacing: xTickLabelSpacing,\n    xTimeAuto: ((_frame$fields$ = frame.fields[0]) === null || _frame$fields$ === void 0 ? void 0 : _frame$fields$.type) === FieldType.time && !((_frame$fields$0$confi = frame.fields[0].config.unit) !== null && _frame$fields$0$confi !== void 0 && _frame$fields$0$confi.startsWith('time:'))\n  };\n  const config = getConfig(opts, theme);\n  builder.setCursor(config.cursor);\n  builder.addHook('init', config.init);\n  builder.addHook('drawClear', config.drawClear);\n  builder.addHook('draw', config.draw);\n  builder.setTooltipInterpolator(config.interpolateTooltip);\n\n  if (vizOrientation.xOri === ScaleOrientation.Horizontal && xTickLabelRotation !== 0) {\n    builder.setPadding(getRotationPadding(frame, xTickLabelRotation, xTickLabelMaxLength));\n  }\n\n  builder.setPrepData(config.prepData);\n  builder.addScale({\n    scaleKey: 'x',\n    isTime: false,\n    range: config.xRange,\n    distribution: ScaleDistribution.Ordinal,\n    orientation: vizOrientation.xOri,\n    direction: vizOrientation.xDir\n  });\n  const xFieldAxisPlacement = ((_frame$fields$0$confi2 = frame.fields[0].config.custom) === null || _frame$fields$0$confi2 === void 0 ? void 0 : _frame$fields$0$confi2.axisPlacement) !== AxisPlacement.Hidden ? vizOrientation.xOri === ScaleOrientation.Horizontal ? AxisPlacement.Bottom : AxisPlacement.Left : AxisPlacement.Hidden;\n  const xFieldAxisShow = ((_frame$fields$0$confi3 = frame.fields[0].config.custom) === null || _frame$fields$0$confi3 === void 0 ? void 0 : _frame$fields$0$confi3.axisPlacement) !== AxisPlacement.Hidden;\n  builder.addAxis({\n    scaleKey: 'x',\n    isTime: false,\n    placement: xFieldAxisPlacement,\n    label: (_frame$fields$0$confi4 = frame.fields[0].config.custom) === null || _frame$fields$0$confi4 === void 0 ? void 0 : _frame$fields$0$confi4.axisLabel,\n    splits: config.xSplits,\n    values: config.xValues,\n    grid: {\n      show: false\n    },\n    ticks: {\n      show: false\n    },\n    gap: 15,\n    tickLabelRotation: xTickLabelRotation * -1,\n    theme,\n    show: xFieldAxisShow\n  });\n  let seriesIndex = 0;\n  const legendOrdered = isLegendOrdered(legend); // iterate the y values\n\n  for (let i = 1; i < frame.fields.length; i++) {\n    var _customConfig$hideFro, _customConfig$scaleDi, _customConfig$scaleDi2;\n\n    const field = frame.fields[i];\n    seriesIndex++;\n    const customConfig = Object.assign({}, defaultBarChartFieldConfig, field.config.custom);\n    const scaleKey = field.config.unit || FIXED_UNIT;\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n    builder.addSeries({\n      scaleKey,\n      pxAlign: true,\n      lineWidth: customConfig.lineWidth,\n      lineColor: seriesColor,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      colorMode,\n      pathBuilder: config.barsBuilder,\n      show: !((_customConfig$hideFro = customConfig.hideFrom) !== null && _customConfig$hideFro !== void 0 && _customConfig$hideFro.viz),\n      gradientMode: customConfig.gradientMode,\n      thresholds: field.config.thresholds,\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      // PlotLegend currently gets unfiltered DataFrame[], so index must be into that field array, not the prepped frame's which we're iterating here\n      dataFrameFieldIndex: {\n        fieldIndex: legendOrdered ? i : allFrames[0].fields.findIndex(f => {\n          var _f$state;\n\n          return f.type === FieldType.number && ((_f$state = f.state) === null || _f$state === void 0 ? void 0 : _f$state.seriesIndex) === seriesIndex - 1;\n        }),\n        frameIndex: 0\n      }\n    }); // The builder will manage unique scaleKeys and combine where appropriate\n\n    builder.addScale({\n      scaleKey,\n      min: field.config.min,\n      max: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n      orientation: vizOrientation.yOri,\n      direction: vizOrientation.yDir,\n      distribution: (_customConfig$scaleDi = customConfig.scaleDistribution) === null || _customConfig$scaleDi === void 0 ? void 0 : _customConfig$scaleDi.type,\n      log: (_customConfig$scaleDi2 = customConfig.scaleDistribution) === null || _customConfig$scaleDi2 === void 0 ? void 0 : _customConfig$scaleDi2.log\n    });\n\n    if (customConfig.axisPlacement !== AxisPlacement.Hidden) {\n      let placement = customConfig.axisPlacement;\n\n      if (!placement || placement === AxisPlacement.Auto) {\n        placement = AxisPlacement.Left;\n      }\n\n      if (vizOrientation.xOri === 1) {\n        if (placement === AxisPlacement.Left) {\n          placement = AxisPlacement.Bottom;\n        }\n\n        if (placement === AxisPlacement.Right) {\n          placement = AxisPlacement.Top;\n        }\n      }\n\n      builder.addAxis({\n        scaleKey,\n        label: customConfig.axisLabel,\n        size: customConfig.axisWidth,\n        placement,\n        formatValue: v => formattedValueToString(field.display(v)),\n        theme,\n        grid: {\n          show: customConfig.axisGridShow\n        }\n      });\n    }\n  }\n\n  let stackingGroups = getStackingGroups(frame);\n  builder.setStackingGroups(stackingGroups);\n  return builder;\n};\n\nfunction shortenValue(value, length) {\n  if (value.length > length) {\n    return value.substring(0, length).concat('...');\n  } else {\n    return value;\n  }\n}\n\nfunction getRotationPadding(frame, rotateLabel, valueMaxLength) {\n  var _frame$fields$0$displ;\n\n  const values = frame.fields[0].values;\n  const fontSize = UPLOT_AXIS_FONT_SIZE;\n  const displayProcessor = (_frame$fields$0$displ = frame.fields[0].display) !== null && _frame$fields$0$displ !== void 0 ? _frame$fields$0$displ : v => v;\n  let maxLength = 0;\n\n  for (let i = 0; i < values.length; i++) {\n    let size = measureText(shortenValue(formattedValueToString(displayProcessor(values.get(i))), valueMaxLength), fontSize);\n    maxLength = size.width > maxLength ? size.width : maxLength;\n  } // Add padding to the right if the labels are rotated in a way that makes the last label extend outside the graph.\n\n\n  const paddingRight = rotateLabel > 0 ? Math.cos(rotateLabel * Math.PI / 180) * measureText(shortenValue(formattedValueToString(displayProcessor(values.get(values.length - 1))), valueMaxLength), fontSize).width : 0; // Add padding to the left if the labels are rotated in a way that makes the first label extend outside the graph.\n\n  const paddingLeft = rotateLabel < 0 ? Math.cos(rotateLabel * -1 * Math.PI / 180) * measureText(shortenValue(formattedValueToString(displayProcessor(values.get(0))), valueMaxLength), fontSize).width : 0; // Add padding to the bottom to avoid clipping the rotated labels.\n\n  const paddingBottom = Math.sin((rotateLabel >= 0 ? rotateLabel : rotateLabel * -1) * Math.PI / 180) * maxLength;\n  return [0, paddingRight, paddingBottom, paddingLeft];\n}\n/** @internal */\n\n\nexport function prepareBarChartDisplayValues(series, theme, options) {\n  if (!(series !== null && series !== void 0 && series.length)) {\n    return {\n      warn: 'No data in response'\n    };\n  } // Bar chart requires a single frame\n\n\n  const frame = series.length === 1 ? maybeSortFrame(series[0], series[0].fields.findIndex(f => f.type === FieldType.time)) : outerJoinDataFrames({\n    frames: series\n  });\n\n  if (!frame) {\n    return {\n      warn: 'Unable to join data'\n    };\n  } // Color by a field different than the input\n\n\n  let colorByField = undefined;\n\n  if (options.colorByField) {\n    colorByField = findField(frame, options.colorByField);\n\n    if (!colorByField) {\n      return {\n        warn: 'Color field not found'\n      };\n    }\n  }\n\n  let xField = undefined;\n\n  if (options.xField) {\n    xField = findField(frame, options.xField);\n\n    if (!xField) {\n      return {\n        warn: 'Configured x field not found'\n      };\n    }\n  }\n\n  let stringField = undefined;\n  let timeField = undefined;\n  let fields = [];\n\n  for (const field of frame.fields) {\n    if (field === xField) {\n      continue;\n    }\n\n    switch (field.type) {\n      case FieldType.string:\n        if (!stringField) {\n          stringField = field;\n        }\n\n        break;\n\n      case FieldType.time:\n        if (!timeField) {\n          timeField = field;\n        }\n\n        break;\n\n      case FieldType.number:\n        {\n          const copy = Object.assign({}, field, {\n            state: Object.assign({}, field.state, {\n              seriesIndex: fields.length // off by one?\n\n            }),\n            config: Object.assign({}, field.config, {\n              custom: Object.assign({}, field.config.custom, {\n                stacking: {\n                  group: '_',\n                  mode: options.stacking\n                }\n              })\n            }),\n            values: new ArrayVector(field.values.toArray().map(v => {\n              if (!(Number.isFinite(v) || v == null)) {\n                return null;\n              }\n\n              return v;\n            }))\n          });\n\n          if (options.stacking === StackingMode.Percent) {\n            copy.config.unit = 'percentunit';\n            copy.display = getDisplayProcessor({\n              field: copy,\n              theme\n            });\n          }\n\n          fields.push(copy);\n        }\n    }\n  }\n\n  let firstField = xField;\n\n  if (!firstField) {\n    firstField = stringField || timeField;\n  }\n\n  if (!firstField) {\n    return {\n      warn: 'Bar charts requires a string or time field'\n    };\n  }\n\n  if (!fields.length) {\n    return {\n      warn: 'No numeric fields found'\n    };\n  } // Show the first number value\n\n\n  if (colorByField && fields.length > 1) {\n    const firstNumber = fields.find(f => f !== colorByField);\n\n    if (firstNumber) {\n      fields = [firstNumber];\n    }\n  }\n\n  if (isLegendOrdered(options.legend)) {\n    var _options$legend$calcs;\n\n    const sortKey = options.legend.sortBy.toLowerCase();\n    const reducers = (_options$legend$calcs = options.legend.calcs) !== null && _options$legend$calcs !== void 0 ? _options$legend$calcs : [sortKey];\n    fields = orderBy(fields, field => {\n      return reduceField({\n        field,\n        reducers\n      })[sortKey];\n    }, options.legend.sortDesc ? 'desc' : 'asc');\n  } // String field is first\n\n\n  fields.unshift(firstField);\n  return {\n    aligned: frame,\n    colorByField,\n    viz: [{\n      length: firstField.values.length,\n      fields: fields // ideally: fields.filter((f) => !Boolean(f.config.custom?.hideFrom?.viz)),\n\n    }]\n  };\n}\nexport const isLegendOrdered = options => Boolean((options === null || options === void 0 ? void 0 : options.sortBy) && options.sortDesc !== null);","map":{"version":3,"names":["orderBy","ArrayVector","FieldType","formattedValueToString","getDisplayProcessor","getFieldColorModeForField","getFieldSeriesColor","outerJoinDataFrames","reduceField","VizOrientation","maybeSortFrame","AxisPlacement","ScaleDirection","ScaleDistribution","ScaleOrientation","StackingMode","FIXED_UNIT","measureText","UPlotConfigBuilder","UPLOT_AXIS_FONT_SIZE","getStackingGroups","findField","getConfig","defaultBarChartFieldConfig","getBarCharScaleOrientation","orientation","Vertical","xOri","Horizontal","xDir","Right","yOri","yDir","Up","Down","preparePlotConfigBuilder","frame","theme","showValue","groupWidth","barWidth","barRadius","stacking","text","rawValue","getColor","fillOpacity","allFrames","xTickLabelRotation","xTickLabelMaxLength","xTickLabelSpacing","legend","builder","defaultValueFormatter","seriesIdx","value","shortenValue","fields","display","vizOrientation","formatValue","length","opts","xSpacing","xTimeAuto","type","time","config","unit","startsWith","setCursor","cursor","addHook","init","drawClear","draw","setTooltipInterpolator","interpolateTooltip","setPadding","getRotationPadding","setPrepData","prepData","addScale","scaleKey","isTime","range","xRange","distribution","Ordinal","direction","xFieldAxisPlacement","custom","axisPlacement","Hidden","Bottom","Left","xFieldAxisShow","addAxis","placement","label","axisLabel","splits","xSplits","values","xValues","grid","show","ticks","gap","tickLabelRotation","seriesIndex","legendOrdered","isLegendOrdered","i","field","customConfig","colorMode","scaleColor","seriesColor","color","addSeries","pxAlign","lineWidth","lineColor","pathBuilder","barsBuilder","hideFrom","viz","gradientMode","thresholds","hardMin","min","hardMax","max","softMin","axisSoftMin","softMax","axisSoftMax","dataFrameFieldIndex","fieldIndex","findIndex","f","number","state","frameIndex","scaleDistribution","log","Auto","Top","size","axisWidth","v","axisGridShow","stackingGroups","setStackingGroups","substring","concat","rotateLabel","valueMaxLength","fontSize","displayProcessor","maxLength","get","width","paddingRight","Math","cos","PI","paddingLeft","paddingBottom","sin","prepareBarChartDisplayValues","series","options","warn","frames","colorByField","undefined","xField","stringField","timeField","string","copy","group","mode","toArray","map","Number","isFinite","Percent","push","firstField","firstNumber","find","sortKey","sortBy","toLowerCase","reducers","calcs","sortDesc","unshift","aligned","Boolean"],"sources":["/home/soula/grafana/public/app/plugins/panel/barchart/utils.ts"],"sourcesContent":["import { orderBy } from 'lodash';\nimport { Padding } from 'uplot';\n\nimport {\n  ArrayVector,\n  DataFrame,\n  Field,\n  FieldType,\n  formattedValueToString,\n  getDisplayProcessor,\n  getFieldColorModeForField,\n  getFieldSeriesColor,\n  GrafanaTheme2,\n  outerJoinDataFrames,\n  reduceField,\n  VizOrientation,\n} from '@grafana/data';\nimport { maybeSortFrame } from '@grafana/data/src/transformations/transformers/joinDataFrames';\nimport {\n  AxisPlacement,\n  ScaleDirection,\n  ScaleDistribution,\n  ScaleOrientation,\n  StackingMode,\n  VizLegendOptions,\n} from '@grafana/schema';\nimport { FIXED_UNIT, measureText, UPlotConfigBuilder, UPlotConfigPrepFn, UPLOT_AXIS_FONT_SIZE } from '@grafana/ui';\nimport { getStackingGroups } from '@grafana/ui/src/components/uPlot/utils';\nimport { findField } from 'app/features/dimensions';\n\nimport { BarsOptions, getConfig } from './bars';\nimport { BarChartFieldConfig, PanelOptions, defaultBarChartFieldConfig } from './models.gen';\nimport { BarChartDisplayValues, BarChartDisplayWarning } from './types';\n\nfunction getBarCharScaleOrientation(orientation: VizOrientation) {\n  if (orientation === VizOrientation.Vertical) {\n    return {\n      xOri: ScaleOrientation.Horizontal,\n      xDir: ScaleDirection.Right,\n      yOri: ScaleOrientation.Vertical,\n      yDir: ScaleDirection.Up,\n    };\n  }\n\n  return {\n    xOri: ScaleOrientation.Vertical,\n    xDir: ScaleDirection.Down,\n    yOri: ScaleOrientation.Horizontal,\n    yDir: ScaleDirection.Right,\n  };\n}\n\nexport interface BarChartOptionsEX extends PanelOptions {\n  rawValue: (seriesIdx: number, valueIdx: number) => number | null;\n  getColor?: (seriesIdx: number, valueIdx: number, value: any) => string | null;\n  fillOpacity?: number;\n}\n\nexport const preparePlotConfigBuilder: UPlotConfigPrepFn<BarChartOptionsEX> = ({\n  frame,\n  theme,\n  orientation,\n  showValue,\n  groupWidth,\n  barWidth,\n  barRadius = 0,\n  stacking,\n  text,\n  rawValue,\n  getColor,\n  fillOpacity,\n  allFrames,\n  xTickLabelRotation,\n  xTickLabelMaxLength,\n  xTickLabelSpacing = 0,\n  legend,\n}) => {\n  const builder = new UPlotConfigBuilder();\n  const defaultValueFormatter = (seriesIdx: number, value: any) => {\n    return shortenValue(formattedValueToString(frame.fields[seriesIdx].display!(value)), xTickLabelMaxLength);\n  };\n\n  // bar orientation -> x scale orientation & direction\n  const vizOrientation = getBarCharScaleOrientation(orientation);\n\n  const formatValue = defaultValueFormatter;\n\n  // Use bar width when only one field\n  if (frame.fields.length === 2) {\n    groupWidth = barWidth;\n    barWidth = 1;\n  }\n\n  const opts: BarsOptions = {\n    xOri: vizOrientation.xOri,\n    xDir: vizOrientation.xDir,\n    groupWidth,\n    barWidth,\n    barRadius,\n    stacking,\n    rawValue,\n    getColor,\n    fillOpacity,\n    formatValue,\n    text,\n    showValue,\n    legend,\n    xSpacing: xTickLabelSpacing,\n    xTimeAuto: frame.fields[0]?.type === FieldType.time && !frame.fields[0].config.unit?.startsWith('time:'),\n  };\n\n  const config = getConfig(opts, theme);\n\n  builder.setCursor(config.cursor);\n\n  builder.addHook('init', config.init);\n  builder.addHook('drawClear', config.drawClear);\n  builder.addHook('draw', config.draw);\n\n  builder.setTooltipInterpolator(config.interpolateTooltip);\n\n  if (vizOrientation.xOri === ScaleOrientation.Horizontal && xTickLabelRotation !== 0) {\n    builder.setPadding(getRotationPadding(frame, xTickLabelRotation, xTickLabelMaxLength));\n  }\n\n  builder.setPrepData(config.prepData);\n\n  builder.addScale({\n    scaleKey: 'x',\n    isTime: false,\n    range: config.xRange,\n    distribution: ScaleDistribution.Ordinal,\n    orientation: vizOrientation.xOri,\n    direction: vizOrientation.xDir,\n  });\n\n  const xFieldAxisPlacement =\n    frame.fields[0].config.custom?.axisPlacement !== AxisPlacement.Hidden\n      ? vizOrientation.xOri === ScaleOrientation.Horizontal\n        ? AxisPlacement.Bottom\n        : AxisPlacement.Left\n      : AxisPlacement.Hidden;\n  const xFieldAxisShow = frame.fields[0].config.custom?.axisPlacement !== AxisPlacement.Hidden;\n\n  builder.addAxis({\n    scaleKey: 'x',\n    isTime: false,\n    placement: xFieldAxisPlacement,\n    label: frame.fields[0].config.custom?.axisLabel,\n    splits: config.xSplits,\n    values: config.xValues,\n    grid: { show: false },\n    ticks: { show: false },\n    gap: 15,\n    tickLabelRotation: xTickLabelRotation * -1,\n    theme,\n    show: xFieldAxisShow,\n  });\n\n  let seriesIndex = 0;\n  const legendOrdered = isLegendOrdered(legend);\n\n  // iterate the y values\n  for (let i = 1; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n\n    seriesIndex++;\n\n    const customConfig: BarChartFieldConfig = { ...defaultBarChartFieldConfig, ...field.config.custom };\n\n    const scaleKey = field.config.unit || FIXED_UNIT;\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n\n    builder.addSeries({\n      scaleKey,\n      pxAlign: true,\n      lineWidth: customConfig.lineWidth,\n      lineColor: seriesColor,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      colorMode,\n      pathBuilder: config.barsBuilder,\n      show: !customConfig.hideFrom?.viz,\n      gradientMode: customConfig.gradientMode,\n      thresholds: field.config.thresholds,\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      // PlotLegend currently gets unfiltered DataFrame[], so index must be into that field array, not the prepped frame's which we're iterating here\n      dataFrameFieldIndex: {\n        fieldIndex: legendOrdered\n          ? i\n          : allFrames[0].fields.findIndex(\n              (f) => f.type === FieldType.number && f.state?.seriesIndex === seriesIndex - 1\n            ),\n        frameIndex: 0,\n      },\n    });\n\n    // The builder will manage unique scaleKeys and combine where appropriate\n    builder.addScale({\n      scaleKey,\n      min: field.config.min,\n      max: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n      orientation: vizOrientation.yOri,\n      direction: vizOrientation.yDir,\n      distribution: customConfig.scaleDistribution?.type,\n      log: customConfig.scaleDistribution?.log,\n    });\n\n    if (customConfig.axisPlacement !== AxisPlacement.Hidden) {\n      let placement = customConfig.axisPlacement;\n      if (!placement || placement === AxisPlacement.Auto) {\n        placement = AxisPlacement.Left;\n      }\n      if (vizOrientation.xOri === 1) {\n        if (placement === AxisPlacement.Left) {\n          placement = AxisPlacement.Bottom;\n        }\n        if (placement === AxisPlacement.Right) {\n          placement = AxisPlacement.Top;\n        }\n      }\n\n      builder.addAxis({\n        scaleKey,\n        label: customConfig.axisLabel,\n        size: customConfig.axisWidth,\n        placement,\n        formatValue: (v) => formattedValueToString(field.display!(v)),\n        theme,\n        grid: { show: customConfig.axisGridShow },\n      });\n    }\n  }\n\n  let stackingGroups = getStackingGroups(frame);\n\n  builder.setStackingGroups(stackingGroups);\n\n  return builder;\n};\n\nfunction shortenValue(value: string, length: number) {\n  if (value.length > length) {\n    return value.substring(0, length).concat('...');\n  } else {\n    return value;\n  }\n}\n\nfunction getRotationPadding(frame: DataFrame, rotateLabel: number, valueMaxLength: number): Padding {\n  const values = frame.fields[0].values;\n  const fontSize = UPLOT_AXIS_FONT_SIZE;\n  const displayProcessor = frame.fields[0].display ?? ((v) => v);\n  let maxLength = 0;\n  for (let i = 0; i < values.length; i++) {\n    let size = measureText(\n      shortenValue(formattedValueToString(displayProcessor(values.get(i))), valueMaxLength),\n      fontSize\n    );\n    maxLength = size.width > maxLength ? size.width : maxLength;\n  }\n\n  // Add padding to the right if the labels are rotated in a way that makes the last label extend outside the graph.\n  const paddingRight =\n    rotateLabel > 0\n      ? Math.cos((rotateLabel * Math.PI) / 180) *\n        measureText(\n          shortenValue(formattedValueToString(displayProcessor(values.get(values.length - 1))), valueMaxLength),\n          fontSize\n        ).width\n      : 0;\n\n  // Add padding to the left if the labels are rotated in a way that makes the first label extend outside the graph.\n  const paddingLeft =\n    rotateLabel < 0\n      ? Math.cos((rotateLabel * -1 * Math.PI) / 180) *\n        measureText(shortenValue(formattedValueToString(displayProcessor(values.get(0))), valueMaxLength), fontSize)\n          .width\n      : 0;\n\n  // Add padding to the bottom to avoid clipping the rotated labels.\n  const paddingBottom = Math.sin(((rotateLabel >= 0 ? rotateLabel : rotateLabel * -1) * Math.PI) / 180) * maxLength;\n\n  return [0, paddingRight, paddingBottom, paddingLeft];\n}\n\n/** @internal */\nexport function prepareBarChartDisplayValues(\n  series: DataFrame[],\n  theme: GrafanaTheme2,\n  options: PanelOptions\n): BarChartDisplayValues | BarChartDisplayWarning {\n  if (!series?.length) {\n    return { warn: 'No data in response' };\n  }\n\n  // Bar chart requires a single frame\n  const frame =\n    series.length === 1\n      ? maybeSortFrame(\n          series[0],\n          series[0].fields.findIndex((f) => f.type === FieldType.time)\n        )\n      : outerJoinDataFrames({ frames: series });\n  if (!frame) {\n    return { warn: 'Unable to join data' };\n  }\n\n  // Color by a field different than the input\n  let colorByField: Field | undefined = undefined;\n  if (options.colorByField) {\n    colorByField = findField(frame, options.colorByField);\n    if (!colorByField) {\n      return { warn: 'Color field not found' };\n    }\n  }\n\n  let xField: Field | undefined = undefined;\n  if (options.xField) {\n    xField = findField(frame, options.xField);\n    if (!xField) {\n      return { warn: 'Configured x field not found' };\n    }\n  }\n\n  let stringField: Field | undefined = undefined;\n  let timeField: Field | undefined = undefined;\n  let fields: Field[] = [];\n  for (const field of frame.fields) {\n    if (field === xField) {\n      continue;\n    }\n\n    switch (field.type) {\n      case FieldType.string:\n        if (!stringField) {\n          stringField = field;\n        }\n        break;\n\n      case FieldType.time:\n        if (!timeField) {\n          timeField = field;\n        }\n        break;\n\n      case FieldType.number: {\n        const copy = {\n          ...field,\n          state: {\n            ...field.state,\n            seriesIndex: fields.length, // off by one?\n          },\n          config: {\n            ...field.config,\n            custom: {\n              ...field.config.custom,\n              stacking: {\n                group: '_',\n                mode: options.stacking,\n              },\n            },\n          },\n          values: new ArrayVector(\n            field.values.toArray().map((v) => {\n              if (!(Number.isFinite(v) || v == null)) {\n                return null;\n              }\n              return v;\n            })\n          ),\n        };\n\n        if (options.stacking === StackingMode.Percent) {\n          copy.config.unit = 'percentunit';\n          copy.display = getDisplayProcessor({ field: copy, theme });\n        }\n\n        fields.push(copy);\n      }\n    }\n  }\n\n  let firstField = xField;\n  if (!firstField) {\n    firstField = stringField || timeField;\n  }\n\n  if (!firstField) {\n    return {\n      warn: 'Bar charts requires a string or time field',\n    };\n  }\n\n  if (!fields.length) {\n    return {\n      warn: 'No numeric fields found',\n    };\n  }\n\n  // Show the first number value\n  if (colorByField && fields.length > 1) {\n    const firstNumber = fields.find((f) => f !== colorByField);\n    if (firstNumber) {\n      fields = [firstNumber];\n    }\n  }\n\n  if (isLegendOrdered(options.legend)) {\n    const sortKey = options.legend.sortBy!.toLowerCase();\n    const reducers = options.legend.calcs ?? [sortKey];\n    fields = orderBy(\n      fields,\n      (field) => {\n        return reduceField({ field, reducers })[sortKey];\n      },\n      options.legend.sortDesc ? 'desc' : 'asc'\n    );\n  }\n\n  // String field is first\n  fields.unshift(firstField);\n\n  return {\n    aligned: frame,\n    colorByField,\n    viz: [\n      {\n        length: firstField.values.length,\n        fields: fields, // ideally: fields.filter((f) => !Boolean(f.config.custom?.hideFrom?.viz)),\n      },\n    ],\n  };\n}\n\nexport const isLegendOrdered = (options: VizLegendOptions) => Boolean(options?.sortBy && options.sortDesc !== null);\n"],"mappings":"AAAA,SAASA,OAAT,QAAwB,QAAxB;AAGA,SACEC,WADF,EAIEC,SAJF,EAKEC,sBALF,EAMEC,mBANF,EAOEC,yBAPF,EAQEC,mBARF,EAUEC,mBAVF,EAWEC,WAXF,EAYEC,cAZF,QAaO,eAbP;AAcA,SAASC,cAAT,QAA+B,+DAA/B;AACA,SACEC,aADF,EAEEC,cAFF,EAGEC,iBAHF,EAIEC,gBAJF,EAKEC,YALF,QAOO,iBAPP;AAQA,SAASC,UAAT,EAAqBC,WAArB,EAAkCC,kBAAlC,EAAyEC,oBAAzE,QAAqG,aAArG;AACA,SAASC,iBAAT,QAAkC,wCAAlC;AACA,SAASC,SAAT,QAA0B,yBAA1B;AAEA,SAAsBC,SAAtB,QAAuC,QAAvC;AACA,SAA4CC,0BAA5C,QAA8E,cAA9E;;AAGA,SAASC,0BAAT,CAAoCC,WAApC,EAAiE;EAC/D,IAAIA,WAAW,KAAKhB,cAAc,CAACiB,QAAnC,EAA6C;IAC3C,OAAO;MACLC,IAAI,EAAEb,gBAAgB,CAACc,UADlB;MAELC,IAAI,EAAEjB,cAAc,CAACkB,KAFhB;MAGLC,IAAI,EAAEjB,gBAAgB,CAACY,QAHlB;MAILM,IAAI,EAAEpB,cAAc,CAACqB;IAJhB,CAAP;EAMD;;EAED,OAAO;IACLN,IAAI,EAAEb,gBAAgB,CAACY,QADlB;IAELG,IAAI,EAAEjB,cAAc,CAACsB,IAFhB;IAGLH,IAAI,EAAEjB,gBAAgB,CAACc,UAHlB;IAILI,IAAI,EAAEpB,cAAc,CAACkB;EAJhB,CAAP;AAMD;;AAQD,OAAO,MAAMK,wBAA8D,GAAG,CAAC;EAC7EC,KAD6E;EAE7EC,KAF6E;EAG7EZ,WAH6E;EAI7Ea,SAJ6E;EAK7EC,UAL6E;EAM7EC,QAN6E;EAO7EC,SAAS,GAAG,CAPiE;EAQ7EC,QAR6E;EAS7EC,IAT6E;EAU7EC,QAV6E;EAW7EC,QAX6E;EAY7EC,WAZ6E;EAa7EC,SAb6E;EAc7EC,kBAd6E;EAe7EC,mBAf6E;EAgB7EC,iBAAiB,GAAG,CAhByD;EAiB7EC;AAjB6E,CAAD,KAkBxE;EAAA;;EACJ,MAAMC,OAAO,GAAG,IAAIlC,kBAAJ,EAAhB;;EACA,MAAMmC,qBAAqB,GAAG,CAACC,SAAD,EAAoBC,KAApB,KAAmC;IAC/D,OAAOC,YAAY,CAACrD,sBAAsB,CAACiC,KAAK,CAACqB,MAAN,CAAaH,SAAb,EAAwBI,OAAxB,CAAiCH,KAAjC,CAAD,CAAvB,EAAkEN,mBAAlE,CAAnB;EACD,CAFD,CAFI,CAMJ;;;EACA,MAAMU,cAAc,GAAGnC,0BAA0B,CAACC,WAAD,CAAjD;EAEA,MAAMmC,WAAW,GAAGP,qBAApB,CATI,CAWJ;;EACA,IAAIjB,KAAK,CAACqB,MAAN,CAAaI,MAAb,KAAwB,CAA5B,EAA+B;IAC7BtB,UAAU,GAAGC,QAAb;IACAA,QAAQ,GAAG,CAAX;EACD;;EAED,MAAMsB,IAAiB,GAAG;IACxBnC,IAAI,EAAEgC,cAAc,CAAChC,IADG;IAExBE,IAAI,EAAE8B,cAAc,CAAC9B,IAFG;IAGxBU,UAHwB;IAIxBC,QAJwB;IAKxBC,SALwB;IAMxBC,QANwB;IAOxBE,QAPwB;IAQxBC,QARwB;IASxBC,WATwB;IAUxBc,WAVwB;IAWxBjB,IAXwB;IAYxBL,SAZwB;IAaxBa,MAbwB;IAcxBY,QAAQ,EAAEb,iBAdc;IAexBc,SAAS,EAAE,mBAAA5B,KAAK,CAACqB,MAAN,CAAa,CAAb,mEAAiBQ,IAAjB,MAA0B/D,SAAS,CAACgE,IAApC,IAA4C,2BAAC9B,KAAK,CAACqB,MAAN,CAAa,CAAb,EAAgBU,MAAhB,CAAuBC,IAAxB,kDAAC,sBAA6BC,UAA7B,CAAwC,OAAxC,CAAD;EAf/B,CAA1B;EAkBA,MAAMF,MAAM,GAAG7C,SAAS,CAACwC,IAAD,EAAOzB,KAAP,CAAxB;EAEAe,OAAO,CAACkB,SAAR,CAAkBH,MAAM,CAACI,MAAzB;EAEAnB,OAAO,CAACoB,OAAR,CAAgB,MAAhB,EAAwBL,MAAM,CAACM,IAA/B;EACArB,OAAO,CAACoB,OAAR,CAAgB,WAAhB,EAA6BL,MAAM,CAACO,SAApC;EACAtB,OAAO,CAACoB,OAAR,CAAgB,MAAhB,EAAwBL,MAAM,CAACQ,IAA/B;EAEAvB,OAAO,CAACwB,sBAAR,CAA+BT,MAAM,CAACU,kBAAtC;;EAEA,IAAIlB,cAAc,CAAChC,IAAf,KAAwBb,gBAAgB,CAACc,UAAzC,IAAuDoB,kBAAkB,KAAK,CAAlF,EAAqF;IACnFI,OAAO,CAAC0B,UAAR,CAAmBC,kBAAkB,CAAC3C,KAAD,EAAQY,kBAAR,EAA4BC,mBAA5B,CAArC;EACD;;EAEDG,OAAO,CAAC4B,WAAR,CAAoBb,MAAM,CAACc,QAA3B;EAEA7B,OAAO,CAAC8B,QAAR,CAAiB;IACfC,QAAQ,EAAE,GADK;IAEfC,MAAM,EAAE,KAFO;IAGfC,KAAK,EAAElB,MAAM,CAACmB,MAHC;IAIfC,YAAY,EAAE1E,iBAAiB,CAAC2E,OAJjB;IAKf/D,WAAW,EAAEkC,cAAc,CAAChC,IALb;IAMf8D,SAAS,EAAE9B,cAAc,CAAC9B;EANX,CAAjB;EASA,MAAM6D,mBAAmB,GACvB,2BAAAtD,KAAK,CAACqB,MAAN,CAAa,CAAb,EAAgBU,MAAhB,CAAuBwB,MAAvB,kFAA+BC,aAA/B,MAAiDjF,aAAa,CAACkF,MAA/D,GACIlC,cAAc,CAAChC,IAAf,KAAwBb,gBAAgB,CAACc,UAAzC,GACEjB,aAAa,CAACmF,MADhB,GAEEnF,aAAa,CAACoF,IAHpB,GAIIpF,aAAa,CAACkF,MALpB;EAMA,MAAMG,cAAc,GAAG,2BAAA5D,KAAK,CAACqB,MAAN,CAAa,CAAb,EAAgBU,MAAhB,CAAuBwB,MAAvB,kFAA+BC,aAA/B,MAAiDjF,aAAa,CAACkF,MAAtF;EAEAzC,OAAO,CAAC6C,OAAR,CAAgB;IACdd,QAAQ,EAAE,GADI;IAEdC,MAAM,EAAE,KAFM;IAGdc,SAAS,EAAER,mBAHG;IAIdS,KAAK,4BAAE/D,KAAK,CAACqB,MAAN,CAAa,CAAb,EAAgBU,MAAhB,CAAuBwB,MAAzB,2DAAE,uBAA+BS,SAJxB;IAKdC,MAAM,EAAElC,MAAM,CAACmC,OALD;IAMdC,MAAM,EAAEpC,MAAM,CAACqC,OAND;IAOdC,IAAI,EAAE;MAAEC,IAAI,EAAE;IAAR,CAPQ;IAQdC,KAAK,EAAE;MAAED,IAAI,EAAE;IAAR,CARO;IASdE,GAAG,EAAE,EATS;IAUdC,iBAAiB,EAAE7D,kBAAkB,GAAG,CAAC,CAV3B;IAWdX,KAXc;IAYdqE,IAAI,EAAEV;EAZQ,CAAhB;EAeA,IAAIc,WAAW,GAAG,CAAlB;EACA,MAAMC,aAAa,GAAGC,eAAe,CAAC7D,MAAD,CAArC,CApFI,CAsFJ;;EACA,KAAK,IAAI8D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7E,KAAK,CAACqB,MAAN,CAAaI,MAAjC,EAAyCoD,CAAC,EAA1C,EAA8C;IAAA;;IAC5C,MAAMC,KAAK,GAAG9E,KAAK,CAACqB,MAAN,CAAawD,CAAb,CAAd;IAEAH,WAAW;IAEX,MAAMK,YAAiC,qBAAQ5F,0BAAR,EAAuC2F,KAAK,CAAC/C,MAAN,CAAawB,MAApD,CAAvC;IAEA,MAAMR,QAAQ,GAAG+B,KAAK,CAAC/C,MAAN,CAAaC,IAAb,IAAqBpD,UAAtC;IACA,MAAMoG,SAAS,GAAG/G,yBAAyB,CAAC6G,KAAD,CAA3C;IACA,MAAMG,UAAU,GAAG/G,mBAAmB,CAAC4G,KAAD,EAAQ7E,KAAR,CAAtC;IACA,MAAMiF,WAAW,GAAGD,UAAU,CAACE,KAA/B;IAEAnE,OAAO,CAACoE,SAAR,CAAkB;MAChBrC,QADgB;MAEhBsC,OAAO,EAAE,IAFO;MAGhBC,SAAS,EAAEP,YAAY,CAACO,SAHR;MAIhBC,SAAS,EAAEL,WAJK;MAKhBxE,WAAW,EAAEqE,YAAY,CAACrE,WALV;MAMhBT,KANgB;MAOhB+E,SAPgB;MAQhBQ,WAAW,EAAEzD,MAAM,CAAC0D,WARJ;MAShBnB,IAAI,EAAE,2BAACS,YAAY,CAACW,QAAd,kDAAC,sBAAuBC,GAAxB,CATU;MAUhBC,YAAY,EAAEb,YAAY,CAACa,YAVX;MAWhBC,UAAU,EAAEf,KAAK,CAAC/C,MAAN,CAAa8D,UAXT;MAYhBC,OAAO,EAAEhB,KAAK,CAAC/C,MAAN,CAAagE,GAZN;MAahBC,OAAO,EAAElB,KAAK,CAAC/C,MAAN,CAAakE,GAbN;MAchBC,OAAO,EAAEnB,YAAY,CAACoB,WAdN;MAehBC,OAAO,EAAErB,YAAY,CAACsB,WAfN;MAiBhB;MACA;MACAC,mBAAmB,EAAE;QACnBC,UAAU,EAAE5B,aAAa,GACrBE,CADqB,GAErBlE,SAAS,CAAC,CAAD,CAAT,CAAaU,MAAb,CAAoBmF,SAApB,CACGC,CAAD;UAAA;;UAAA,OAAOA,CAAC,CAAC5E,IAAF,KAAW/D,SAAS,CAAC4I,MAArB,IAA+B,aAAAD,CAAC,CAACE,KAAF,sDAASjC,WAAT,MAAyBA,WAAW,GAAG,CAA7E;QAAA,CADF,CAHe;QAMnBkC,UAAU,EAAE;MANO;IAnBL,CAAlB,EAZ4C,CAyC5C;;IACA5F,OAAO,CAAC8B,QAAR,CAAiB;MACfC,QADe;MAEfgD,GAAG,EAAEjB,KAAK,CAAC/C,MAAN,CAAagE,GAFH;MAGfE,GAAG,EAAEnB,KAAK,CAAC/C,MAAN,CAAakE,GAHH;MAIfC,OAAO,EAAEnB,YAAY,CAACoB,WAJP;MAKfC,OAAO,EAAErB,YAAY,CAACsB,WALP;MAMfhH,WAAW,EAAEkC,cAAc,CAAC5B,IANb;MAOf0D,SAAS,EAAE9B,cAAc,CAAC3B,IAPX;MAQfuD,YAAY,2BAAE4B,YAAY,CAAC8B,iBAAf,0DAAE,sBAAgChF,IAR/B;MASfiF,GAAG,4BAAE/B,YAAY,CAAC8B,iBAAf,2DAAE,uBAAgCC;IATtB,CAAjB;;IAYA,IAAI/B,YAAY,CAACvB,aAAb,KAA+BjF,aAAa,CAACkF,MAAjD,EAAyD;MACvD,IAAIK,SAAS,GAAGiB,YAAY,CAACvB,aAA7B;;MACA,IAAI,CAACM,SAAD,IAAcA,SAAS,KAAKvF,aAAa,CAACwI,IAA9C,EAAoD;QAClDjD,SAAS,GAAGvF,aAAa,CAACoF,IAA1B;MACD;;MACD,IAAIpC,cAAc,CAAChC,IAAf,KAAwB,CAA5B,EAA+B;QAC7B,IAAIuE,SAAS,KAAKvF,aAAa,CAACoF,IAAhC,EAAsC;UACpCG,SAAS,GAAGvF,aAAa,CAACmF,MAA1B;QACD;;QACD,IAAII,SAAS,KAAKvF,aAAa,CAACmB,KAAhC,EAAuC;UACrCoE,SAAS,GAAGvF,aAAa,CAACyI,GAA1B;QACD;MACF;;MAEDhG,OAAO,CAAC6C,OAAR,CAAgB;QACdd,QADc;QAEdgB,KAAK,EAAEgB,YAAY,CAACf,SAFN;QAGdiD,IAAI,EAAElC,YAAY,CAACmC,SAHL;QAIdpD,SAJc;QAKdtC,WAAW,EAAG2F,CAAD,IAAOpJ,sBAAsB,CAAC+G,KAAK,CAACxD,OAAN,CAAe6F,CAAf,CAAD,CAL5B;QAMdlH,KANc;QAOdoE,IAAI,EAAE;UAAEC,IAAI,EAAES,YAAY,CAACqC;QAArB;MAPQ,CAAhB;IASD;EACF;;EAED,IAAIC,cAAc,GAAGrI,iBAAiB,CAACgB,KAAD,CAAtC;EAEAgB,OAAO,CAACsG,iBAAR,CAA0BD,cAA1B;EAEA,OAAOrG,OAAP;AACD,CA9LM;;AAgMP,SAASI,YAAT,CAAsBD,KAAtB,EAAqCM,MAArC,EAAqD;EACnD,IAAIN,KAAK,CAACM,MAAN,GAAeA,MAAnB,EAA2B;IACzB,OAAON,KAAK,CAACoG,SAAN,CAAgB,CAAhB,EAAmB9F,MAAnB,EAA2B+F,MAA3B,CAAkC,KAAlC,CAAP;EACD,CAFD,MAEO;IACL,OAAOrG,KAAP;EACD;AACF;;AAED,SAASwB,kBAAT,CAA4B3C,KAA5B,EAA8CyH,WAA9C,EAAmEC,cAAnE,EAAoG;EAAA;;EAClG,MAAMvD,MAAM,GAAGnE,KAAK,CAACqB,MAAN,CAAa,CAAb,EAAgB8C,MAA/B;EACA,MAAMwD,QAAQ,GAAG5I,oBAAjB;EACA,MAAM6I,gBAAgB,4BAAG5H,KAAK,CAACqB,MAAN,CAAa,CAAb,EAAgBC,OAAnB,yEAAgC6F,CAAD,IAAOA,CAA5D;EACA,IAAIU,SAAS,GAAG,CAAhB;;EACA,KAAK,IAAIhD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,MAAM,CAAC1C,MAA3B,EAAmCoD,CAAC,EAApC,EAAwC;IACtC,IAAIoC,IAAI,GAAGpI,WAAW,CACpBuC,YAAY,CAACrD,sBAAsB,CAAC6J,gBAAgB,CAACzD,MAAM,CAAC2D,GAAP,CAAWjD,CAAX,CAAD,CAAjB,CAAvB,EAA0D6C,cAA1D,CADQ,EAEpBC,QAFoB,CAAtB;IAIAE,SAAS,GAAGZ,IAAI,CAACc,KAAL,GAAaF,SAAb,GAAyBZ,IAAI,CAACc,KAA9B,GAAsCF,SAAlD;EACD,CAXiG,CAalG;;;EACA,MAAMG,YAAY,GAChBP,WAAW,GAAG,CAAd,GACIQ,IAAI,CAACC,GAAL,CAAUT,WAAW,GAAGQ,IAAI,CAACE,EAApB,GAA0B,GAAnC,IACAtJ,WAAW,CACTuC,YAAY,CAACrD,sBAAsB,CAAC6J,gBAAgB,CAACzD,MAAM,CAAC2D,GAAP,CAAW3D,MAAM,CAAC1C,MAAP,GAAgB,CAA3B,CAAD,CAAjB,CAAvB,EAA0EiG,cAA1E,CADH,EAETC,QAFS,CAAX,CAGEI,KALN,GAMI,CAPN,CAdkG,CAuBlG;;EACA,MAAMK,WAAW,GACfX,WAAW,GAAG,CAAd,GACIQ,IAAI,CAACC,GAAL,CAAUT,WAAW,GAAG,CAAC,CAAf,GAAmBQ,IAAI,CAACE,EAAzB,GAA+B,GAAxC,IACAtJ,WAAW,CAACuC,YAAY,CAACrD,sBAAsB,CAAC6J,gBAAgB,CAACzD,MAAM,CAAC2D,GAAP,CAAW,CAAX,CAAD,CAAjB,CAAvB,EAA0DJ,cAA1D,CAAb,EAAwFC,QAAxF,CAAX,CACGI,KAHP,GAII,CALN,CAxBkG,CA+BlG;;EACA,MAAMM,aAAa,GAAGJ,IAAI,CAACK,GAAL,CAAU,CAACb,WAAW,IAAI,CAAf,GAAmBA,WAAnB,GAAiCA,WAAW,GAAG,CAAC,CAAjD,IAAsDQ,IAAI,CAACE,EAA5D,GAAkE,GAA3E,IAAkFN,SAAxG;EAEA,OAAO,CAAC,CAAD,EAAIG,YAAJ,EAAkBK,aAAlB,EAAiCD,WAAjC,CAAP;AACD;AAED;;;AACA,OAAO,SAASG,4BAAT,CACLC,MADK,EAELvI,KAFK,EAGLwI,OAHK,EAI2C;EAChD,IAAI,EAACD,MAAD,aAACA,MAAD,eAACA,MAAM,CAAE/G,MAAT,CAAJ,EAAqB;IACnB,OAAO;MAAEiH,IAAI,EAAE;IAAR,CAAP;EACD,CAH+C,CAKhD;;;EACA,MAAM1I,KAAK,GACTwI,MAAM,CAAC/G,MAAP,KAAkB,CAAlB,GACInD,cAAc,CACZkK,MAAM,CAAC,CAAD,CADM,EAEZA,MAAM,CAAC,CAAD,CAAN,CAAUnH,MAAV,CAAiBmF,SAAjB,CAA4BC,CAAD,IAAOA,CAAC,CAAC5E,IAAF,KAAW/D,SAAS,CAACgE,IAAvD,CAFY,CADlB,GAKI3D,mBAAmB,CAAC;IAAEwK,MAAM,EAAEH;EAAV,CAAD,CANzB;;EAOA,IAAI,CAACxI,KAAL,EAAY;IACV,OAAO;MAAE0I,IAAI,EAAE;IAAR,CAAP;EACD,CAf+C,CAiBhD;;;EACA,IAAIE,YAA+B,GAAGC,SAAtC;;EACA,IAAIJ,OAAO,CAACG,YAAZ,EAA0B;IACxBA,YAAY,GAAG3J,SAAS,CAACe,KAAD,EAAQyI,OAAO,CAACG,YAAhB,CAAxB;;IACA,IAAI,CAACA,YAAL,EAAmB;MACjB,OAAO;QAAEF,IAAI,EAAE;MAAR,CAAP;IACD;EACF;;EAED,IAAII,MAAyB,GAAGD,SAAhC;;EACA,IAAIJ,OAAO,CAACK,MAAZ,EAAoB;IAClBA,MAAM,GAAG7J,SAAS,CAACe,KAAD,EAAQyI,OAAO,CAACK,MAAhB,CAAlB;;IACA,IAAI,CAACA,MAAL,EAAa;MACX,OAAO;QAAEJ,IAAI,EAAE;MAAR,CAAP;IACD;EACF;;EAED,IAAIK,WAA8B,GAAGF,SAArC;EACA,IAAIG,SAA4B,GAAGH,SAAnC;EACA,IAAIxH,MAAe,GAAG,EAAtB;;EACA,KAAK,MAAMyD,KAAX,IAAoB9E,KAAK,CAACqB,MAA1B,EAAkC;IAChC,IAAIyD,KAAK,KAAKgE,MAAd,EAAsB;MACpB;IACD;;IAED,QAAQhE,KAAK,CAACjD,IAAd;MACE,KAAK/D,SAAS,CAACmL,MAAf;QACE,IAAI,CAACF,WAAL,EAAkB;UAChBA,WAAW,GAAGjE,KAAd;QACD;;QACD;;MAEF,KAAKhH,SAAS,CAACgE,IAAf;QACE,IAAI,CAACkH,SAAL,EAAgB;UACdA,SAAS,GAAGlE,KAAZ;QACD;;QACD;;MAEF,KAAKhH,SAAS,CAAC4I,MAAf;QAAuB;UACrB,MAAMwC,IAAI,qBACLpE,KADK;YAER6B,KAAK,oBACA7B,KAAK,CAAC6B,KADN;cAEHjC,WAAW,EAAErD,MAAM,CAACI,MAFjB,CAEyB;;YAFzB,EAFG;YAMRM,MAAM,oBACD+C,KAAK,CAAC/C,MADL;cAEJwB,MAAM,oBACDuB,KAAK,CAAC/C,MAAN,CAAawB,MADZ;gBAEJjD,QAAQ,EAAE;kBACR6I,KAAK,EAAE,GADC;kBAERC,IAAI,EAAEX,OAAO,CAACnI;gBAFN;cAFN;YAFF,EANE;YAgBR6D,MAAM,EAAE,IAAItG,WAAJ,CACNiH,KAAK,CAACX,MAAN,CAAakF,OAAb,GAAuBC,GAAvB,CAA4BnC,CAAD,IAAO;cAChC,IAAI,EAAEoC,MAAM,CAACC,QAAP,CAAgBrC,CAAhB,KAAsBA,CAAC,IAAI,IAA7B,CAAJ,EAAwC;gBACtC,OAAO,IAAP;cACD;;cACD,OAAOA,CAAP;YACD,CALD,CADM;UAhBA,EAAV;;UA0BA,IAAIsB,OAAO,CAACnI,QAAR,KAAqB3B,YAAY,CAAC8K,OAAtC,EAA+C;YAC7CP,IAAI,CAACnH,MAAL,CAAYC,IAAZ,GAAmB,aAAnB;YACAkH,IAAI,CAAC5H,OAAL,GAAetD,mBAAmB,CAAC;cAAE8G,KAAK,EAAEoE,IAAT;cAAejJ;YAAf,CAAD,CAAlC;UACD;;UAEDoB,MAAM,CAACqI,IAAP,CAAYR,IAAZ;QACD;IA9CH;EAgDD;;EAED,IAAIS,UAAU,GAAGb,MAAjB;;EACA,IAAI,CAACa,UAAL,EAAiB;IACfA,UAAU,GAAGZ,WAAW,IAAIC,SAA5B;EACD;;EAED,IAAI,CAACW,UAAL,EAAiB;IACf,OAAO;MACLjB,IAAI,EAAE;IADD,CAAP;EAGD;;EAED,IAAI,CAACrH,MAAM,CAACI,MAAZ,EAAoB;IAClB,OAAO;MACLiH,IAAI,EAAE;IADD,CAAP;EAGD,CA3G+C,CA6GhD;;;EACA,IAAIE,YAAY,IAAIvH,MAAM,CAACI,MAAP,GAAgB,CAApC,EAAuC;IACrC,MAAMmI,WAAW,GAAGvI,MAAM,CAACwI,IAAP,CAAapD,CAAD,IAAOA,CAAC,KAAKmC,YAAzB,CAApB;;IACA,IAAIgB,WAAJ,EAAiB;MACfvI,MAAM,GAAG,CAACuI,WAAD,CAAT;IACD;EACF;;EAED,IAAIhF,eAAe,CAAC6D,OAAO,CAAC1H,MAAT,CAAnB,EAAqC;IAAA;;IACnC,MAAM+I,OAAO,GAAGrB,OAAO,CAAC1H,MAAR,CAAegJ,MAAf,CAAuBC,WAAvB,EAAhB;IACA,MAAMC,QAAQ,4BAAGxB,OAAO,CAAC1H,MAAR,CAAemJ,KAAlB,yEAA2B,CAACJ,OAAD,CAAzC;IACAzI,MAAM,GAAGzD,OAAO,CACdyD,MADc,EAEbyD,KAAD,IAAW;MACT,OAAO1G,WAAW,CAAC;QAAE0G,KAAF;QAASmF;MAAT,CAAD,CAAX,CAAiCH,OAAjC,CAAP;IACD,CAJa,EAKdrB,OAAO,CAAC1H,MAAR,CAAeoJ,QAAf,GAA0B,MAA1B,GAAmC,KALrB,CAAhB;EAOD,CA/H+C,CAiIhD;;;EACA9I,MAAM,CAAC+I,OAAP,CAAeT,UAAf;EAEA,OAAO;IACLU,OAAO,EAAErK,KADJ;IAEL4I,YAFK;IAGLjD,GAAG,EAAE,CACH;MACElE,MAAM,EAAEkI,UAAU,CAACxF,MAAX,CAAkB1C,MAD5B;MAEEJ,MAAM,EAAEA,MAFV,CAEkB;;IAFlB,CADG;EAHA,CAAP;AAUD;AAED,OAAO,MAAMuD,eAAe,GAAI6D,OAAD,IAA+B6B,OAAO,CAAC,CAAA7B,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEsB,MAAT,KAAmBtB,OAAO,CAAC0B,QAAR,KAAqB,IAAzC,CAA9D"},"metadata":{},"sourceType":"module"}