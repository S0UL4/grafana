{"ast":null,"code":"import { DataLinkBuiltInVars } from '@grafana/data';\nimport { safeStringifyValue } from '../../../core/utils/explore';\nimport { PanelModel } from '../../dashboard/state';\nimport { variableAdapters } from '../adapters';\nimport { isAdHoc } from '../guard';\nimport { containsVariable, variableRegex, variableRegexExec } from '../utils';\nexport const createDependencyNodes = variables => {\n  const nodes = [];\n\n  for (const variable of variables) {\n    nodes.push({\n      id: variable.id,\n      label: `${variable.id}`\n    });\n  }\n\n  return nodes;\n};\nexport const filterNodesWithDependencies = (nodes, edges) => {\n  return nodes.filter(node => edges.some(edge => edge.from === node.id || edge.to === node.id));\n};\nexport const createDependencyEdges = variables => {\n  const edges = [];\n\n  for (const variable of variables) {\n    for (const other of variables) {\n      if (variable === other) {\n        continue;\n      }\n\n      const dependsOn = variableAdapters.get(variable.type).dependsOn(variable, other);\n\n      if (dependsOn) {\n        edges.push({\n          from: variable.id,\n          to: other.id\n        });\n      }\n    }\n  }\n\n  return edges;\n};\n\nfunction getVariableName(expression) {\n  const match = variableRegexExec(expression);\n\n  if (!match) {\n    return null;\n  }\n\n  const variableName = match.slice(1).find(match => match !== undefined);\n  return variableName;\n}\n\nexport const getUnknownVariableStrings = (variables, model) => {\n  variableRegex.lastIndex = 0;\n  const unknownVariableNames = [];\n  const modelAsString = safeStringifyValue(model, 2);\n  const matches = modelAsString.match(variableRegex);\n\n  if (!matches) {\n    return unknownVariableNames;\n  }\n\n  for (const match of matches) {\n    if (!match) {\n      continue;\n    }\n\n    if (match.indexOf('$__') !== -1) {\n      // ignore builtin variables\n      continue;\n    }\n\n    if (match.indexOf('${__') !== -1) {\n      // ignore builtin variables\n      continue;\n    }\n\n    if (match.indexOf('$hashKey') !== -1) {\n      // ignore Angular props\n      continue;\n    }\n\n    const variableName = getVariableName(match);\n\n    if (variables.some(variable => variable.id === variableName)) {\n      // ignore defined variables\n      continue;\n    }\n\n    if (unknownVariableNames.find(name => name === variableName)) {\n      continue;\n    }\n\n    if (variableName) {\n      unknownVariableNames.push(variableName);\n    }\n  }\n\n  return unknownVariableNames;\n};\nconst validVariableNames = {\n  alias: [/^m$/, /^measurement$/, /^col$/, /^tag_(\\w+|\\d+)$/],\n  query: [/^timeFilter$/]\n};\nexport const getPropsWithVariable = (variableId, parent, result) => {\n  const stringValues = Object.keys(parent.value).reduce((all, key) => {\n    const value = parent.value[key];\n\n    if (!value || typeof value !== 'string') {\n      return all;\n    }\n\n    const isValidName = validVariableNames[key] ? validVariableNames[key].find(regex => regex.test(variableId)) : undefined;\n    let hasVariable = containsVariable(value, variableId);\n\n    if (key === 'repeat' && value === variableId) {\n      // repeat stores value without variable format\n      hasVariable = true;\n    }\n\n    if (!isValidName && hasVariable) {\n      all = Object.assign({}, all, {\n        [key]: value\n      });\n    }\n\n    return all;\n  }, {});\n  const objectValues = Object.keys(parent.value).reduce((all, key) => {\n    const value = parent.value[key];\n\n    if (value && typeof value === 'object' && Object.keys(value).length) {\n      let id = value.title || value.name || value.id || key;\n\n      if (Array.isArray(parent.value) && parent.key === 'panels') {\n        id = `${id}[${value.id}]`;\n      }\n\n      const newResult = getPropsWithVariable(variableId, {\n        key,\n        value\n      }, {});\n\n      if (Object.keys(newResult).length) {\n        all = Object.assign({}, all, {\n          [id]: newResult\n        });\n      }\n    }\n\n    return all;\n  }, {});\n\n  if (Object.keys(stringValues).length || Object.keys(objectValues).length) {\n    result = Object.assign({}, result, stringValues, objectValues);\n  }\n\n  return result;\n};\nexport const createUsagesNetwork = (variables, dashboard) => {\n  if (!dashboard) {\n    return {\n      unUsed: [],\n      usages: []\n    };\n  }\n\n  const unUsed = [];\n  let usages = [];\n  const model = dashboard.getSaveModelClone();\n\n  for (const variable of variables) {\n    const variableId = variable.id;\n    const props = getPropsWithVariable(variableId, {\n      key: 'model',\n      value: model\n    }, {});\n\n    if (!Object.keys(props).length && !isAdHoc(variable)) {\n      unUsed.push(variable);\n    }\n\n    if (Object.keys(props).length) {\n      usages.push({\n        variable,\n        tree: props\n      });\n    }\n  }\n\n  return {\n    unUsed,\n    usages\n  };\n};\nexport async function getUnknownsNetwork(variables, dashboard) {\n  return new Promise((resolve, reject) => {\n    // can be an expensive call so we avoid blocking the main thread\n    setTimeout(() => {\n      try {\n        const unknowns = createUnknownsNetwork(variables, dashboard);\n        resolve(transformUsagesToNetwork(unknowns));\n      } catch (e) {\n        reject(e);\n      }\n    }, 200);\n  });\n}\n\nfunction createUnknownsNetwork(variables, dashboard) {\n  if (!dashboard) {\n    return [];\n  }\n\n  let unknown = [];\n  const model = dashboard.getSaveModelClone();\n  const unknownVariables = getUnknownVariableStrings(variables, model);\n\n  for (const unknownVariable of unknownVariables) {\n    const props = getPropsWithVariable(unknownVariable, {\n      key: 'model',\n      value: model\n    }, {});\n\n    if (Object.keys(props).length) {\n      const variable = {\n        id: unknownVariable,\n        name: unknownVariable\n      };\n      unknown.push({\n        variable,\n        tree: props\n      });\n    }\n  }\n\n  return unknown;\n}\n/*\n  getAllAffectedPanelIdsForVariableChange is a function that extracts all the panel ids that are affected by a single variable\n  change. It will traverse all chained variables to identify all cascading changes too.\n\n  This is done entirely by parsing the current dashboard json and doesn't take under consideration a user cancelling\n  a variable query or any faulty variable queries.\n\n  This doesn't take circular dependencies in consideration.\n */\n\n\nexport function getAllAffectedPanelIdsForVariableChange(variableId, variables, panels) {\n  const flattenedPanels = flattenPanels(panels);\n  let affectedPanelIds = getAffectedPanelIdsForVariable(variableId, flattenedPanels);\n  const affectedPanelIdsForAllVariables = getAffectedPanelIdsForVariable(DataLinkBuiltInVars.includeVars, flattenedPanels);\n  affectedPanelIds = [...new Set([...affectedPanelIdsForAllVariables, ...affectedPanelIds])];\n  const dependencies = getDependenciesForVariable(variableId, variables, new Set());\n\n  for (const dependency of dependencies) {\n    const affectedPanelIdsForDependency = getAffectedPanelIdsForVariable(dependency, flattenedPanels);\n    affectedPanelIds = [...new Set([...affectedPanelIdsForDependency, ...affectedPanelIds])];\n  }\n\n  return affectedPanelIds;\n}\nexport function getDependenciesForVariable(variableId, variables, deps) {\n  if (!variables.length) {\n    return deps;\n  }\n\n  for (const variable of variables) {\n    if (variable.name === variableId) {\n      continue;\n    }\n\n    const depends = variableAdapters.get(variable.type).dependsOn(variable, {\n      name: variableId\n    });\n\n    if (!depends) {\n      continue;\n    }\n\n    deps.add(variable.name);\n    deps = getDependenciesForVariable(variable.name, variables, deps);\n  }\n\n  return deps;\n}\nexport function getAffectedPanelIdsForVariable(variableId, panels) {\n  if (!panels.length) {\n    return [];\n  }\n\n  const affectedPanelIds = [];\n  const repeatRegex = new RegExp(`\"repeat\":\"${variableId}\"`);\n\n  for (const panel of panels) {\n    const panelAsJson = safeStringifyValue(panel.getSaveModel()); // check for repeats that don't use variableRegex\n\n    const repeatMatches = panelAsJson.match(repeatRegex);\n\n    if (repeatMatches !== null && repeatMatches !== void 0 && repeatMatches.length) {\n      affectedPanelIds.push(panel.id);\n      continue;\n    }\n\n    const matches = panelAsJson.match(variableRegex);\n\n    if (!matches) {\n      continue;\n    }\n\n    for (const match of matches) {\n      const variableName = getVariableName(match);\n\n      if (variableName === variableId) {\n        affectedPanelIds.push(panel.id);\n        break;\n      }\n    }\n  }\n\n  return affectedPanelIds;\n}\nexport const traverseTree = (usage, parent) => {\n  const {\n    id,\n    value\n  } = parent;\n  const {\n    nodes,\n    edges\n  } = usage;\n\n  if (value && typeof value === 'string') {\n    const leafId = `${parent.id}-${value}`;\n    nodes.push({\n      id: leafId,\n      label: value\n    });\n    edges.push({\n      from: leafId,\n      to: id\n    });\n    return usage;\n  }\n\n  if (value && typeof value === 'object') {\n    const keys = Object.keys(value);\n\n    for (const key of keys) {\n      const leafId = `${parent.id}-${key}`;\n      nodes.push({\n        id: leafId,\n        label: key\n      });\n      edges.push({\n        from: leafId,\n        to: id\n      });\n      usage = traverseTree(usage, {\n        id: leafId,\n        value: value[key]\n      });\n    }\n\n    return usage;\n  }\n\n  return usage;\n};\nexport const transformUsagesToNetwork = usages => {\n  const results = [];\n\n  for (const usage of usages) {\n    const {\n      variable,\n      tree\n    } = usage;\n    const result = {\n      variable,\n      nodes: [{\n        id: 'dashboard',\n        label: 'dashboard'\n      }],\n      edges: [],\n      showGraph: false\n    };\n    results.push(traverseTree(result, {\n      id: 'dashboard',\n      value: tree\n    }));\n  }\n\n  return results;\n};\n\nconst countLeaves = object => {\n  const total = Object.values(object).reduce((count, value) => {\n    if (typeof value === 'object') {\n      return count + countLeaves(value);\n    }\n\n    return count + 1;\n  }, 0);\n  return total;\n};\n\nexport const getVariableUsages = (variableId, usages) => {\n  const usage = usages.find(usage => usage.variable.id === variableId);\n\n  if (!usage) {\n    return 0;\n  }\n\n  return countLeaves(usage.tree);\n};\nexport function flattenPanels(panels) {\n  const result = [];\n\n  for (const panel of panels) {\n    var _panel$panels;\n\n    result.push(panel);\n\n    if ((_panel$panels = panel.panels) !== null && _panel$panels !== void 0 && _panel$panels.length) {\n      result.push(...flattenPanels(panel.panels.map(p => new PanelModel(p))));\n    }\n  }\n\n  return result;\n}","map":{"version":3,"names":["DataLinkBuiltInVars","safeStringifyValue","PanelModel","variableAdapters","isAdHoc","containsVariable","variableRegex","variableRegexExec","createDependencyNodes","variables","nodes","variable","push","id","label","filterNodesWithDependencies","edges","filter","node","some","edge","from","to","createDependencyEdges","other","dependsOn","get","type","getVariableName","expression","match","variableName","slice","find","undefined","getUnknownVariableStrings","model","lastIndex","unknownVariableNames","modelAsString","matches","indexOf","name","validVariableNames","alias","query","getPropsWithVariable","variableId","parent","result","stringValues","Object","keys","value","reduce","all","key","isValidName","regex","test","hasVariable","objectValues","length","title","Array","isArray","newResult","createUsagesNetwork","dashboard","unUsed","usages","getSaveModelClone","props","tree","getUnknownsNetwork","Promise","resolve","reject","setTimeout","unknowns","createUnknownsNetwork","transformUsagesToNetwork","e","unknown","unknownVariables","unknownVariable","getAllAffectedPanelIdsForVariableChange","panels","flattenedPanels","flattenPanels","affectedPanelIds","getAffectedPanelIdsForVariable","affectedPanelIdsForAllVariables","includeVars","Set","dependencies","getDependenciesForVariable","dependency","affectedPanelIdsForDependency","deps","depends","add","repeatRegex","RegExp","panel","panelAsJson","getSaveModel","repeatMatches","traverseTree","usage","leafId","results","showGraph","countLeaves","object","total","values","count","getVariableUsages","map","p"],"sources":["/home/soula/grafana/public/app/features/variables/inspect/utils.ts"],"sourcesContent":["import { DataLinkBuiltInVars } from '@grafana/data';\n\nimport { safeStringifyValue } from '../../../core/utils/explore';\nimport { DashboardModel, PanelModel } from '../../dashboard/state';\nimport { variableAdapters } from '../adapters';\nimport { isAdHoc } from '../guard';\nimport { VariableModel } from '../types';\nimport { containsVariable, variableRegex, variableRegexExec } from '../utils';\n\nexport interface GraphNode {\n  id: string;\n  label: string;\n}\n\nexport interface GraphEdge {\n  from: string;\n  to: string;\n}\n\nexport const createDependencyNodes = (variables: VariableModel[]): GraphNode[] => {\n  const nodes: GraphNode[] = [];\n\n  for (const variable of variables) {\n    nodes.push({ id: variable.id, label: `${variable.id}` });\n  }\n\n  return nodes;\n};\n\nexport const filterNodesWithDependencies = (nodes: GraphNode[], edges: GraphEdge[]): GraphNode[] => {\n  return nodes.filter((node) => edges.some((edge) => edge.from === node.id || edge.to === node.id));\n};\n\nexport const createDependencyEdges = (variables: VariableModel[]): GraphEdge[] => {\n  const edges: GraphEdge[] = [];\n\n  for (const variable of variables) {\n    for (const other of variables) {\n      if (variable === other) {\n        continue;\n      }\n\n      const dependsOn = variableAdapters.get(variable.type).dependsOn(variable, other);\n\n      if (dependsOn) {\n        edges.push({ from: variable.id, to: other.id });\n      }\n    }\n  }\n\n  return edges;\n};\n\nfunction getVariableName(expression: string) {\n  const match = variableRegexExec(expression);\n  if (!match) {\n    return null;\n  }\n  const variableName = match.slice(1).find((match) => match !== undefined);\n  return variableName;\n}\n\nexport const getUnknownVariableStrings = (variables: VariableModel[], model: any) => {\n  variableRegex.lastIndex = 0;\n  const unknownVariableNames: string[] = [];\n  const modelAsString = safeStringifyValue(model, 2);\n  const matches = modelAsString.match(variableRegex);\n\n  if (!matches) {\n    return unknownVariableNames;\n  }\n\n  for (const match of matches) {\n    if (!match) {\n      continue;\n    }\n\n    if (match.indexOf('$__') !== -1) {\n      // ignore builtin variables\n      continue;\n    }\n\n    if (match.indexOf('${__') !== -1) {\n      // ignore builtin variables\n      continue;\n    }\n\n    if (match.indexOf('$hashKey') !== -1) {\n      // ignore Angular props\n      continue;\n    }\n\n    const variableName = getVariableName(match);\n\n    if (variables.some((variable) => variable.id === variableName)) {\n      // ignore defined variables\n      continue;\n    }\n\n    if (unknownVariableNames.find((name) => name === variableName)) {\n      continue;\n    }\n\n    if (variableName) {\n      unknownVariableNames.push(variableName);\n    }\n  }\n\n  return unknownVariableNames;\n};\n\nconst validVariableNames: Record<string, RegExp[]> = {\n  alias: [/^m$/, /^measurement$/, /^col$/, /^tag_(\\w+|\\d+)$/],\n  query: [/^timeFilter$/],\n};\n\nexport const getPropsWithVariable = (variableId: string, parent: { key: string; value: any }, result: any) => {\n  const stringValues = Object.keys(parent.value).reduce((all, key) => {\n    const value = parent.value[key];\n    if (!value || typeof value !== 'string') {\n      return all;\n    }\n\n    const isValidName = validVariableNames[key]\n      ? validVariableNames[key].find((regex: RegExp) => regex.test(variableId))\n      : undefined;\n\n    let hasVariable = containsVariable(value, variableId);\n    if (key === 'repeat' && value === variableId) {\n      // repeat stores value without variable format\n      hasVariable = true;\n    }\n\n    if (!isValidName && hasVariable) {\n      all = {\n        ...all,\n        [key]: value,\n      };\n    }\n\n    return all;\n  }, {} as Record<string, any>);\n\n  const objectValues = Object.keys(parent.value).reduce((all, key) => {\n    const value = parent.value[key];\n    if (value && typeof value === 'object' && Object.keys(value).length) {\n      let id = value.title || value.name || value.id || key;\n      if (Array.isArray(parent.value) && parent.key === 'panels') {\n        id = `${id}[${value.id}]`;\n      }\n\n      const newResult = getPropsWithVariable(variableId, { key, value }, {});\n\n      if (Object.keys(newResult).length) {\n        all = {\n          ...all,\n          [id]: newResult,\n        };\n      }\n    }\n\n    return all;\n  }, {} as Record<string, any>);\n\n  if (Object.keys(stringValues).length || Object.keys(objectValues).length) {\n    result = {\n      ...result,\n      ...stringValues,\n      ...objectValues,\n    };\n  }\n\n  return result;\n};\n\nexport interface VariableUsageTree {\n  variable: VariableModel;\n  tree: any;\n}\n\nexport interface VariableUsages {\n  unUsed: VariableModel[];\n  usages: VariableUsageTree[];\n}\n\nexport const createUsagesNetwork = (variables: VariableModel[], dashboard: DashboardModel | null): VariableUsages => {\n  if (!dashboard) {\n    return { unUsed: [], usages: [] };\n  }\n\n  const unUsed: VariableModel[] = [];\n  let usages: VariableUsageTree[] = [];\n  const model = dashboard.getSaveModelClone();\n\n  for (const variable of variables) {\n    const variableId = variable.id;\n    const props = getPropsWithVariable(variableId, { key: 'model', value: model }, {});\n    if (!Object.keys(props).length && !isAdHoc(variable)) {\n      unUsed.push(variable);\n    }\n\n    if (Object.keys(props).length) {\n      usages.push({ variable, tree: props });\n    }\n  }\n\n  return { unUsed, usages };\n};\n\nexport async function getUnknownsNetwork(\n  variables: VariableModel[],\n  dashboard: DashboardModel | null\n): Promise<UsagesToNetwork[]> {\n  return new Promise((resolve, reject) => {\n    // can be an expensive call so we avoid blocking the main thread\n    setTimeout(() => {\n      try {\n        const unknowns = createUnknownsNetwork(variables, dashboard);\n        resolve(transformUsagesToNetwork(unknowns));\n      } catch (e) {\n        reject(e);\n      }\n    }, 200);\n  });\n}\n\nfunction createUnknownsNetwork(variables: VariableModel[], dashboard: DashboardModel | null): VariableUsageTree[] {\n  if (!dashboard) {\n    return [];\n  }\n\n  let unknown: VariableUsageTree[] = [];\n  const model = dashboard.getSaveModelClone();\n\n  const unknownVariables = getUnknownVariableStrings(variables, model);\n  for (const unknownVariable of unknownVariables) {\n    const props = getPropsWithVariable(unknownVariable, { key: 'model', value: model }, {});\n    if (Object.keys(props).length) {\n      const variable = { id: unknownVariable, name: unknownVariable } as unknown as VariableModel;\n      unknown.push({ variable, tree: props });\n    }\n  }\n\n  return unknown;\n}\n\n/*\n  getAllAffectedPanelIdsForVariableChange is a function that extracts all the panel ids that are affected by a single variable\n  change. It will traverse all chained variables to identify all cascading changes too.\n\n  This is done entirely by parsing the current dashboard json and doesn't take under consideration a user cancelling\n  a variable query or any faulty variable queries.\n\n  This doesn't take circular dependencies in consideration.\n */\nexport function getAllAffectedPanelIdsForVariableChange(\n  variableId: string,\n  variables: VariableModel[],\n  panels: PanelModel[]\n): number[] {\n  const flattenedPanels = flattenPanels(panels);\n  let affectedPanelIds: number[] = getAffectedPanelIdsForVariable(variableId, flattenedPanels);\n  const affectedPanelIdsForAllVariables = getAffectedPanelIdsForVariable(\n    DataLinkBuiltInVars.includeVars,\n    flattenedPanels\n  );\n  affectedPanelIds = [...new Set([...affectedPanelIdsForAllVariables, ...affectedPanelIds])];\n\n  const dependencies = getDependenciesForVariable(variableId, variables, new Set());\n  for (const dependency of dependencies) {\n    const affectedPanelIdsForDependency = getAffectedPanelIdsForVariable(dependency, flattenedPanels);\n    affectedPanelIds = [...new Set([...affectedPanelIdsForDependency, ...affectedPanelIds])];\n  }\n\n  return affectedPanelIds;\n}\n\nexport function getDependenciesForVariable(\n  variableId: string,\n  variables: VariableModel[],\n  deps: Set<string>\n): Set<string> {\n  if (!variables.length) {\n    return deps;\n  }\n\n  for (const variable of variables) {\n    if (variable.name === variableId) {\n      continue;\n    }\n\n    const depends = variableAdapters.get(variable.type).dependsOn(variable, { name: variableId });\n    if (!depends) {\n      continue;\n    }\n\n    deps.add(variable.name);\n    deps = getDependenciesForVariable(variable.name, variables, deps);\n  }\n\n  return deps;\n}\n\nexport function getAffectedPanelIdsForVariable(variableId: string, panels: PanelModel[]): number[] {\n  if (!panels.length) {\n    return [];\n  }\n\n  const affectedPanelIds: number[] = [];\n  const repeatRegex = new RegExp(`\"repeat\":\"${variableId}\"`);\n  for (const panel of panels) {\n    const panelAsJson = safeStringifyValue(panel.getSaveModel());\n\n    // check for repeats that don't use variableRegex\n    const repeatMatches = panelAsJson.match(repeatRegex);\n    if (repeatMatches?.length) {\n      affectedPanelIds.push(panel.id);\n      continue;\n    }\n\n    const matches = panelAsJson.match(variableRegex);\n    if (!matches) {\n      continue;\n    }\n\n    for (const match of matches) {\n      const variableName = getVariableName(match);\n      if (variableName === variableId) {\n        affectedPanelIds.push(panel.id);\n        break;\n      }\n    }\n  }\n\n  return affectedPanelIds;\n}\n\nexport interface UsagesToNetwork {\n  variable: VariableModel;\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n  showGraph: boolean;\n}\n\nexport const traverseTree = (usage: UsagesToNetwork, parent: { id: string; value: any }): UsagesToNetwork => {\n  const { id, value } = parent;\n  const { nodes, edges } = usage;\n\n  if (value && typeof value === 'string') {\n    const leafId = `${parent.id}-${value}`;\n    nodes.push({ id: leafId, label: value });\n    edges.push({ from: leafId, to: id });\n\n    return usage;\n  }\n\n  if (value && typeof value === 'object') {\n    const keys = Object.keys(value);\n    for (const key of keys) {\n      const leafId = `${parent.id}-${key}`;\n      nodes.push({ id: leafId, label: key });\n      edges.push({ from: leafId, to: id });\n      usage = traverseTree(usage, { id: leafId, value: value[key] });\n    }\n\n    return usage;\n  }\n\n  return usage;\n};\n\nexport const transformUsagesToNetwork = (usages: VariableUsageTree[]): UsagesToNetwork[] => {\n  const results: UsagesToNetwork[] = [];\n\n  for (const usage of usages) {\n    const { variable, tree } = usage;\n    const result: UsagesToNetwork = {\n      variable,\n      nodes: [{ id: 'dashboard', label: 'dashboard' }],\n      edges: [],\n      showGraph: false,\n    };\n    results.push(traverseTree(result, { id: 'dashboard', value: tree }));\n  }\n\n  return results;\n};\n\nconst countLeaves = (object: any): number => {\n  const total = Object.values(object).reduce((count: number, value: any) => {\n    if (typeof value === 'object') {\n      return count + countLeaves(value);\n    }\n\n    return count + 1;\n  }, 0);\n\n  return total as unknown as number;\n};\n\nexport const getVariableUsages = (variableId: string, usages: VariableUsageTree[]): number => {\n  const usage = usages.find((usage) => usage.variable.id === variableId);\n  if (!usage) {\n    return 0;\n  }\n\n  return countLeaves(usage.tree);\n};\n\nexport function flattenPanels(panels: PanelModel[]): PanelModel[] {\n  const result: PanelModel[] = [];\n\n  for (const panel of panels) {\n    result.push(panel);\n    if (panel.panels?.length) {\n      result.push(...flattenPanels(panel.panels.map((p: PanelModel) => new PanelModel(p))));\n    }\n  }\n\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}