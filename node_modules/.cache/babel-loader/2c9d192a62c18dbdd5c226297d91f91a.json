{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { sortDataFrame } from '../../dataframe';\nimport { getFieldDisplayName } from '../../field';\nimport { DataTransformerID } from './ids';\nexport const sortByTransformer = {\n  id: DataTransformerID.sortBy,\n  name: 'Sort by',\n  description: 'Sort fields in a frame',\n  defaultOptions: {\n    fields: {}\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: options => source => source.pipe(map(data => {\n    var _options$sort;\n\n    if (!Array.isArray(data) || data.length === 0 || !(options !== null && options !== void 0 && (_options$sort = options.sort) !== null && _options$sort !== void 0 && _options$sort.length)) {\n      return data;\n    }\n\n    return sortDataFrames(data, options.sort);\n  }))\n};\nexport function sortDataFrames(data, sort) {\n  return data.map(frame => {\n    const s = attachFieldIndex(frame, sort);\n\n    if (s.length && s[0].index != null) {\n      return sortDataFrame(frame, s[0].index, s[0].desc);\n    }\n\n    return frame;\n  });\n}\n\nfunction attachFieldIndex(frame, sort) {\n  return sort.map(s => {\n    if (s.index != null) {\n      // null or undefined\n      return s;\n    }\n\n    return Object.assign({}, s, {\n      index: frame.fields.findIndex(f => s.field === getFieldDisplayName(f, frame))\n    });\n  });\n}","map":{"version":3,"names":["map","sortDataFrame","getFieldDisplayName","DataTransformerID","sortByTransformer","id","sortBy","name","description","defaultOptions","fields","operator","options","source","pipe","data","Array","isArray","length","sort","sortDataFrames","frame","s","attachFieldIndex","index","desc","findIndex","f","field"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/sortBy.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { sortDataFrame } from '../../dataframe';\nimport { getFieldDisplayName } from '../../field';\nimport { DataFrame } from '../../types';\nimport { DataTransformerInfo } from '../../types/transformations';\n\nimport { DataTransformerID } from './ids';\n\nexport interface SortByField {\n  field: string;\n  desc?: boolean;\n  index?: number;\n}\n\nexport interface SortByTransformerOptions {\n  // NOTE: this structure supports an array, however only the first entry is used\n  // future versions may support multi-sort options\n  sort: SortByField[];\n}\n\nexport const sortByTransformer: DataTransformerInfo<SortByTransformerOptions> = {\n  id: DataTransformerID.sortBy,\n  name: 'Sort by',\n  description: 'Sort fields in a frame',\n  defaultOptions: {\n    fields: {},\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        if (!Array.isArray(data) || data.length === 0 || !options?.sort?.length) {\n          return data;\n        }\n        return sortDataFrames(data, options.sort);\n      })\n    ),\n};\n\nexport function sortDataFrames(data: DataFrame[], sort: SortByField[]): DataFrame[] {\n  return data.map((frame) => {\n    const s = attachFieldIndex(frame, sort);\n    if (s.length && s[0].index != null) {\n      return sortDataFrame(frame, s[0].index, s[0].desc);\n    }\n    return frame;\n  });\n}\n\nfunction attachFieldIndex(frame: DataFrame, sort: SortByField[]): SortByField[] {\n  return sort.map((s) => {\n    if (s.index != null) {\n      // null or undefined\n      return s;\n    }\n    return {\n      ...s,\n      index: frame.fields.findIndex((f) => s.field === getFieldDisplayName(f, frame)),\n    };\n  });\n}\n"],"mappings":"AAAA,SAASA,GAAT,QAAoB,gBAApB;AAEA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,mBAAT,QAAoC,aAApC;AAIA,SAASC,iBAAT,QAAkC,OAAlC;AAcA,OAAO,MAAMC,iBAAgE,GAAG;EAC9EC,EAAE,EAAEF,iBAAiB,CAACG,MADwD;EAE9EC,IAAI,EAAE,SAFwE;EAG9EC,WAAW,EAAE,wBAHiE;EAI9EC,cAAc,EAAE;IACdC,MAAM,EAAE;EADM,CAJ8D;;EAQ9E;AACF;AACA;AACA;EACEC,QAAQ,EAAGC,OAAD,IAAcC,MAAD,IACrBA,MAAM,CAACC,IAAP,CACEd,GAAG,CAAEe,IAAD,IAAU;IAAA;;IACZ,IAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAD,IAAwBA,IAAI,CAACG,MAAL,KAAgB,CAAxC,IAA6C,EAACN,OAAD,aAACA,OAAD,gCAACA,OAAO,CAAEO,IAAV,0CAAC,cAAeD,MAAhB,CAAjD,EAAyE;MACvE,OAAOH,IAAP;IACD;;IACD,OAAOK,cAAc,CAACL,IAAD,EAAOH,OAAO,CAACO,IAAf,CAArB;EACD,CALE,CADL;AAb4E,CAAzE;AAuBP,OAAO,SAASC,cAAT,CAAwBL,IAAxB,EAA2CI,IAA3C,EAA6E;EAClF,OAAOJ,IAAI,CAACf,GAAL,CAAUqB,KAAD,IAAW;IACzB,MAAMC,CAAC,GAAGC,gBAAgB,CAACF,KAAD,EAAQF,IAAR,CAA1B;;IACA,IAAIG,CAAC,CAACJ,MAAF,IAAYI,CAAC,CAAC,CAAD,CAAD,CAAKE,KAAL,IAAc,IAA9B,EAAoC;MAClC,OAAOvB,aAAa,CAACoB,KAAD,EAAQC,CAAC,CAAC,CAAD,CAAD,CAAKE,KAAb,EAAoBF,CAAC,CAAC,CAAD,CAAD,CAAKG,IAAzB,CAApB;IACD;;IACD,OAAOJ,KAAP;EACD,CANM,CAAP;AAOD;;AAED,SAASE,gBAAT,CAA0BF,KAA1B,EAA4CF,IAA5C,EAAgF;EAC9E,OAAOA,IAAI,CAACnB,GAAL,CAAUsB,CAAD,IAAO;IACrB,IAAIA,CAAC,CAACE,KAAF,IAAW,IAAf,EAAqB;MACnB;MACA,OAAOF,CAAP;IACD;;IACD,yBACKA,CADL;MAEEE,KAAK,EAAEH,KAAK,CAACX,MAAN,CAAagB,SAAb,CAAwBC,CAAD,IAAOL,CAAC,CAACM,KAAF,KAAY1B,mBAAmB,CAACyB,CAAD,EAAIN,KAAJ,CAA7D;IAFT;EAID,CATM,CAAP;AAUD"},"metadata":{},"sourceType":"module"}