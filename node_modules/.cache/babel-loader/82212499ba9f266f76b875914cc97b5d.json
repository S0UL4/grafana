{"ast":null,"code":"import { createAction } from '@reduxjs/toolkit';\nimport { serializeStateToUrlParam } from '@grafana/data';\nimport { getDataSourceSrv, locationService } from '@grafana/runtime';\nimport { stopQueryState } from 'app/core/utils/explore';\nimport { ExploreId } from 'app/types/explore';\nimport { paneReducer } from './explorePane';\nimport { getUrlStateFromPaneState, makeExplorePaneState } from './utils'; //\n// Actions and Payloads\n//\n\nexport const syncTimesAction = createAction('explore/syncTimes');\nexport const richHistoryUpdatedAction = createAction('explore/richHistoryUpdated');\nexport const richHistoryStorageFullAction = createAction('explore/richHistoryStorageFullAction');\nexport const richHistoryLimitExceededAction = createAction('explore/richHistoryLimitExceededAction');\nexport const richHistoryMigrationFailedAction = createAction('explore/richHistoryMigrationFailedAction');\nexport const richHistorySettingsUpdatedAction = createAction('explore/richHistorySettingsUpdated');\nexport const richHistorySearchFiltersUpdatedAction = createAction('explore/richHistorySearchFiltersUpdatedAction');\n/**\n * Resets state for explore.\n */\n\nexport const resetExploreAction = createAction('explore/resetExplore');\n/**\n * Close the split view and save URL state.\n */\n\nexport const splitCloseAction = createAction('explore/splitClose');\n/**\n * Cleans up a pane state. Could seem like this should be in explorePane.ts actions but in case we area closing\n * left pane we need to move right state to the left.\n * Also this may seem redundant as we have splitClose actions which clears up state but that action is not called on\n * URL change.\n */\n\nexport const cleanupPaneAction = createAction('explore/cleanupPane'); //\n// Action creators\n//\n\n/**\n * Save local redux state back to the URL. Should be called when there is some change that should affect the URL.\n * Not all of the redux state is reflected in URL though.\n */\n\nexport const stateSave = options => {\n  return (dispatch, getState) => {\n    const {\n      left,\n      right\n    } = getState().explore;\n    const orgId = getState().user.orgId.toString();\n    const urlStates = {\n      orgId\n    };\n    urlStates.left = serializeStateToUrlParam(getUrlStateFromPaneState(left));\n\n    if (right) {\n      urlStates.right = serializeStateToUrlParam(getUrlStateFromPaneState(right));\n    } else {\n      urlStates.right = null;\n    }\n\n    lastSavedUrl.right = urlStates.right;\n    lastSavedUrl.left = urlStates.left;\n    locationService.partial(Object.assign({}, urlStates), options === null || options === void 0 ? void 0 : options.replace);\n  };\n}; // Store the url we saved last se we are not trying to update local state based on that.\n\nexport const lastSavedUrl = {};\n/**\n * Opens a new right split pane by navigating to appropriate URL. It either copies existing state of the left pane\n * or uses values from options arg. This does only navigation each pane is then responsible for initialization from\n * the URL.\n */\n\nexport const splitOpen = options => {\n  return async (dispatch, getState) => {\n    const leftState = getState().explore[ExploreId.left];\n    const leftUrlState = getUrlStateFromPaneState(leftState);\n    let rightUrlState = leftUrlState;\n\n    if (options) {\n      var _getDataSourceSrv$get;\n\n      const datasourceName = ((_getDataSourceSrv$get = getDataSourceSrv().getInstanceSettings(options.datasourceUid)) === null || _getDataSourceSrv$get === void 0 ? void 0 : _getDataSourceSrv$get.name) || '';\n      rightUrlState = {\n        datasource: datasourceName,\n        queries: [options.query],\n        range: options.range || leftState.range,\n        panelsState: options.panelsState\n      };\n    }\n\n    const urlState = serializeStateToUrlParam(rightUrlState);\n    locationService.partial({\n      right: urlState\n    }, true);\n  };\n};\n/**\n * Close the split view and save URL state. We need to update the state here because when closing we cannot just\n * update the URL and let the components handle it because if we swap panes from right to left it is not easily apparent\n * from the URL.\n */\n\nexport function splitClose(itemId) {\n  return (dispatch, getState) => {\n    dispatch(splitCloseAction({\n      itemId\n    }));\n    dispatch(stateSave());\n  };\n}\nexport const navigateToExplore = (panel, dependencies) => {\n  return async dispatch => {\n    const {\n      getDataSourceSrv,\n      getTimeSrv,\n      getExploreUrl,\n      openInNewWindow\n    } = dependencies;\n    const datasourceSrv = getDataSourceSrv();\n    const path = await getExploreUrl({\n      panel,\n      datasourceSrv,\n      timeSrv: getTimeSrv()\n    });\n\n    if (openInNewWindow && path) {\n      openInNewWindow(path);\n      return;\n    }\n\n    locationService.push(path);\n  };\n};\n/**\n * Global Explore state that handles multiple Explore areas and the split state\n */\n\nconst initialExploreItemState = makeExplorePaneState();\nexport const initialExploreState = {\n  syncedTimes: false,\n  left: initialExploreItemState,\n  right: undefined,\n  richHistoryStorageFull: false,\n  richHistoryLimitExceededWarningShown: false,\n  richHistoryMigrationFailed: false\n};\n/**\n * Global Explore reducer that handles multiple Explore areas (left and right).\n * Actions that have an `exploreId` get routed to the ExploreItemReducer.\n */\n\nexport const exploreReducer = (state = initialExploreState, action) => {\n  if (splitCloseAction.match(action)) {\n    const {\n      itemId\n    } = action.payload;\n    const targetSplit = {\n      left: itemId === ExploreId.left ? state.right : state.left,\n      right: undefined\n    };\n    return Object.assign({}, state, targetSplit);\n  }\n\n  if (cleanupPaneAction.match(action)) {\n    var _state$exploreId;\n\n    const {\n      exploreId\n    } = action.payload; // We want to do this only when we remove single pane not when we are unmounting whole explore.\n    // It needs to be checked like this because in component we don't get new path (which would tell us if we are\n    // navigating out of explore) before the unmount.\n\n    if (!((_state$exploreId = state[exploreId]) !== null && _state$exploreId !== void 0 && _state$exploreId.initialized)) {\n      return state;\n    }\n\n    if (exploreId === ExploreId.left) {\n      return Object.assign({}, state, {\n        [ExploreId.left]: state[ExploreId.right],\n        [ExploreId.right]: undefined\n      });\n    } else {\n      return Object.assign({}, state, {\n        [ExploreId.right]: undefined\n      });\n    }\n  }\n\n  if (syncTimesAction.match(action)) {\n    return Object.assign({}, state, {\n      syncedTimes: action.payload.syncedTimes\n    });\n  }\n\n  if (richHistoryStorageFullAction.match(action)) {\n    return Object.assign({}, state, {\n      richHistoryStorageFull: true\n    });\n  }\n\n  if (richHistoryLimitExceededAction.match(action)) {\n    return Object.assign({}, state, {\n      richHistoryLimitExceededWarningShown: true\n    });\n  }\n\n  if (richHistoryMigrationFailedAction.match(action)) {\n    return Object.assign({}, state, {\n      richHistoryMigrationFailed: true\n    });\n  }\n\n  if (resetExploreAction.match(action)) {\n    const payload = action.payload;\n    const leftState = state[ExploreId.left];\n    const rightState = state[ExploreId.right];\n    stopQueryState(leftState.querySubscription);\n\n    if (rightState) {\n      stopQueryState(rightState.querySubscription);\n    }\n\n    if (payload.force) {\n      return initialExploreState;\n    }\n\n    return Object.assign({}, initialExploreState, {\n      left: Object.assign({}, initialExploreItemState, {\n        queries: state.left.queries\n      })\n    });\n  }\n\n  if (richHistorySettingsUpdatedAction.match(action)) {\n    const richHistorySettings = action.payload;\n    return Object.assign({}, state, {\n      richHistorySettings\n    });\n  }\n\n  if (action.payload) {\n    const {\n      exploreId\n    } = action.payload;\n\n    if (exploreId !== undefined) {\n      // @ts-ignore\n      const explorePaneState = state[exploreId];\n      return Object.assign({}, state, {\n        [exploreId]: paneReducer(explorePaneState, action)\n      });\n    }\n  }\n\n  return state;\n};\nexport default {\n  explore: exploreReducer\n};","map":{"version":3,"names":["createAction","serializeStateToUrlParam","getDataSourceSrv","locationService","stopQueryState","ExploreId","paneReducer","getUrlStateFromPaneState","makeExplorePaneState","syncTimesAction","richHistoryUpdatedAction","richHistoryStorageFullAction","richHistoryLimitExceededAction","richHistoryMigrationFailedAction","richHistorySettingsUpdatedAction","richHistorySearchFiltersUpdatedAction","resetExploreAction","splitCloseAction","cleanupPaneAction","stateSave","options","dispatch","getState","left","right","explore","orgId","user","toString","urlStates","lastSavedUrl","partial","replace","splitOpen","leftState","leftUrlState","rightUrlState","datasourceName","getInstanceSettings","datasourceUid","name","datasource","queries","query","range","panelsState","urlState","splitClose","itemId","navigateToExplore","panel","dependencies","getTimeSrv","getExploreUrl","openInNewWindow","datasourceSrv","path","timeSrv","push","initialExploreItemState","initialExploreState","syncedTimes","undefined","richHistoryStorageFull","richHistoryLimitExceededWarningShown","richHistoryMigrationFailed","exploreReducer","state","action","match","payload","targetSplit","exploreId","initialized","rightState","querySubscription","force","richHistorySettings","explorePaneState"],"sources":["/home/soula/grafana/public/app/features/explore/state/main.ts"],"sourcesContent":["import { createAction } from '@reduxjs/toolkit';\nimport { AnyAction } from 'redux';\n\nimport { ExploreUrlState, serializeStateToUrlParam, SplitOpen, UrlQueryMap } from '@grafana/data';\nimport { DataSourceSrv, getDataSourceSrv, locationService } from '@grafana/runtime';\nimport { GetExploreUrlArguments, stopQueryState } from 'app/core/utils/explore';\nimport { PanelModel } from 'app/features/dashboard/state';\nimport { ExploreId, ExploreItemState, ExploreState } from 'app/types/explore';\n\nimport { RichHistoryResults } from '../../../core/history/RichHistoryStorage';\nimport { RichHistorySearchFilters, RichHistorySettings } from '../../../core/utils/richHistoryTypes';\nimport { ThunkResult } from '../../../types';\nimport { TimeSrv } from '../../dashboard/services/TimeSrv';\n\nimport { paneReducer } from './explorePane';\nimport { getUrlStateFromPaneState, makeExplorePaneState } from './utils';\n\n//\n// Actions and Payloads\n//\n\nexport interface SyncTimesPayload {\n  syncedTimes: boolean;\n}\nexport const syncTimesAction = createAction<SyncTimesPayload>('explore/syncTimes');\n\nexport const richHistoryUpdatedAction = createAction<{ richHistoryResults: RichHistoryResults; exploreId: ExploreId }>(\n  'explore/richHistoryUpdated'\n);\nexport const richHistoryStorageFullAction = createAction('explore/richHistoryStorageFullAction');\nexport const richHistoryLimitExceededAction = createAction('explore/richHistoryLimitExceededAction');\nexport const richHistoryMigrationFailedAction = createAction('explore/richHistoryMigrationFailedAction');\n\nexport const richHistorySettingsUpdatedAction = createAction<RichHistorySettings>('explore/richHistorySettingsUpdated');\nexport const richHistorySearchFiltersUpdatedAction = createAction<{\n  exploreId: ExploreId;\n  filters?: RichHistorySearchFilters;\n}>('explore/richHistorySearchFiltersUpdatedAction');\n\n/**\n * Resets state for explore.\n */\nexport interface ResetExplorePayload {\n  force?: boolean;\n}\nexport const resetExploreAction = createAction<ResetExplorePayload>('explore/resetExplore');\n\n/**\n * Close the split view and save URL state.\n */\nexport interface SplitCloseActionPayload {\n  itemId: ExploreId;\n}\nexport const splitCloseAction = createAction<SplitCloseActionPayload>('explore/splitClose');\n\n/**\n * Cleans up a pane state. Could seem like this should be in explorePane.ts actions but in case we area closing\n * left pane we need to move right state to the left.\n * Also this may seem redundant as we have splitClose actions which clears up state but that action is not called on\n * URL change.\n */\nexport interface CleanupPanePayload {\n  exploreId: ExploreId;\n}\nexport const cleanupPaneAction = createAction<CleanupPanePayload>('explore/cleanupPane');\n\n//\n// Action creators\n//\n\n/**\n * Save local redux state back to the URL. Should be called when there is some change that should affect the URL.\n * Not all of the redux state is reflected in URL though.\n */\nexport const stateSave = (options?: { replace?: boolean }): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    const { left, right } = getState().explore;\n    const orgId = getState().user.orgId.toString();\n    const urlStates: { [index: string]: string | null } = { orgId };\n\n    urlStates.left = serializeStateToUrlParam(getUrlStateFromPaneState(left));\n\n    if (right) {\n      urlStates.right = serializeStateToUrlParam(getUrlStateFromPaneState(right));\n    } else {\n      urlStates.right = null;\n    }\n\n    lastSavedUrl.right = urlStates.right;\n    lastSavedUrl.left = urlStates.left;\n\n    locationService.partial({ ...urlStates }, options?.replace);\n  };\n};\n\n// Store the url we saved last se we are not trying to update local state based on that.\nexport const lastSavedUrl: UrlQueryMap = {};\n\n/**\n * Opens a new right split pane by navigating to appropriate URL. It either copies existing state of the left pane\n * or uses values from options arg. This does only navigation each pane is then responsible for initialization from\n * the URL.\n */\nexport const splitOpen: SplitOpen = (options): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    const leftState: ExploreItemState = getState().explore[ExploreId.left];\n    const leftUrlState = getUrlStateFromPaneState(leftState);\n    let rightUrlState: ExploreUrlState = leftUrlState;\n\n    if (options) {\n      const datasourceName = getDataSourceSrv().getInstanceSettings(options.datasourceUid)?.name || '';\n      rightUrlState = {\n        datasource: datasourceName,\n        queries: [options.query],\n        range: options.range || leftState.range,\n        panelsState: options.panelsState,\n      };\n    }\n\n    const urlState = serializeStateToUrlParam(rightUrlState);\n    locationService.partial({ right: urlState }, true);\n  };\n};\n\n/**\n * Close the split view and save URL state. We need to update the state here because when closing we cannot just\n * update the URL and let the components handle it because if we swap panes from right to left it is not easily apparent\n * from the URL.\n */\nexport function splitClose(itemId: ExploreId): ThunkResult<void> {\n  return (dispatch, getState) => {\n    dispatch(splitCloseAction({ itemId }));\n    dispatch(stateSave());\n  };\n}\n\nexport interface NavigateToExploreDependencies {\n  getDataSourceSrv: () => DataSourceSrv;\n  getTimeSrv: () => TimeSrv;\n  getExploreUrl: (args: GetExploreUrlArguments) => Promise<string | undefined>;\n  openInNewWindow?: (url: string) => void;\n}\n\nexport const navigateToExplore = (\n  panel: PanelModel,\n  dependencies: NavigateToExploreDependencies\n): ThunkResult<void> => {\n  return async (dispatch) => {\n    const { getDataSourceSrv, getTimeSrv, getExploreUrl, openInNewWindow } = dependencies;\n    const datasourceSrv = getDataSourceSrv();\n    const path = await getExploreUrl({\n      panel,\n      datasourceSrv,\n      timeSrv: getTimeSrv(),\n    });\n\n    if (openInNewWindow && path) {\n      openInNewWindow(path);\n      return;\n    }\n\n    locationService.push(path!);\n  };\n};\n\n/**\n * Global Explore state that handles multiple Explore areas and the split state\n */\nconst initialExploreItemState = makeExplorePaneState();\nexport const initialExploreState: ExploreState = {\n  syncedTimes: false,\n  left: initialExploreItemState,\n  right: undefined,\n  richHistoryStorageFull: false,\n  richHistoryLimitExceededWarningShown: false,\n  richHistoryMigrationFailed: false,\n};\n\n/**\n * Global Explore reducer that handles multiple Explore areas (left and right).\n * Actions that have an `exploreId` get routed to the ExploreItemReducer.\n */\nexport const exploreReducer = (state = initialExploreState, action: AnyAction): ExploreState => {\n  if (splitCloseAction.match(action)) {\n    const { itemId } = action.payload as SplitCloseActionPayload;\n    const targetSplit = {\n      left: itemId === ExploreId.left ? state.right! : state.left,\n      right: undefined,\n    };\n    return {\n      ...state,\n      ...targetSplit,\n    };\n  }\n\n  if (cleanupPaneAction.match(action)) {\n    const { exploreId } = action.payload as CleanupPanePayload;\n\n    // We want to do this only when we remove single pane not when we are unmounting whole explore.\n    // It needs to be checked like this because in component we don't get new path (which would tell us if we are\n    // navigating out of explore) before the unmount.\n    if (!state[exploreId]?.initialized) {\n      return state;\n    }\n\n    if (exploreId === ExploreId.left) {\n      return {\n        ...state,\n        [ExploreId.left]: state[ExploreId.right]!,\n        [ExploreId.right]: undefined,\n      };\n    } else {\n      return {\n        ...state,\n        [ExploreId.right]: undefined,\n      };\n    }\n  }\n\n  if (syncTimesAction.match(action)) {\n    return { ...state, syncedTimes: action.payload.syncedTimes };\n  }\n\n  if (richHistoryStorageFullAction.match(action)) {\n    return {\n      ...state,\n      richHistoryStorageFull: true,\n    };\n  }\n\n  if (richHistoryLimitExceededAction.match(action)) {\n    return {\n      ...state,\n      richHistoryLimitExceededWarningShown: true,\n    };\n  }\n\n  if (richHistoryMigrationFailedAction.match(action)) {\n    return {\n      ...state,\n      richHistoryMigrationFailed: true,\n    };\n  }\n\n  if (resetExploreAction.match(action)) {\n    const payload: ResetExplorePayload = action.payload;\n    const leftState = state[ExploreId.left];\n    const rightState = state[ExploreId.right];\n    stopQueryState(leftState.querySubscription);\n    if (rightState) {\n      stopQueryState(rightState.querySubscription);\n    }\n\n    if (payload.force) {\n      return initialExploreState;\n    }\n\n    return {\n      ...initialExploreState,\n      left: {\n        ...initialExploreItemState,\n        queries: state.left.queries,\n      },\n    };\n  }\n\n  if (richHistorySettingsUpdatedAction.match(action)) {\n    const richHistorySettings = action.payload;\n    return {\n      ...state,\n      richHistorySettings,\n    };\n  }\n\n  if (action.payload) {\n    const { exploreId } = action.payload;\n    if (exploreId !== undefined) {\n      // @ts-ignore\n      const explorePaneState = state[exploreId];\n      return { ...state, [exploreId]: paneReducer(explorePaneState, action as any) };\n    }\n  }\n\n  return state;\n};\n\nexport default {\n  explore: exploreReducer,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}