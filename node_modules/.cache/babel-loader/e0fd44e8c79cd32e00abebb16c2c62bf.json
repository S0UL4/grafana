{"ast":null,"code":"import { AnnotationQueryEditor } from './components/AnnotationQueryEditor';\nimport { isCloudWatchAnnotation } from './guards';\nexport const CloudWatchAnnotationSupport = {\n  // converts legacy angular style queries to new format. Also sets the same default values as in the deprecated angular directive\n  prepareAnnotation: query => {\n    if (isCloudWatchAnnotation(query)) {\n      return query;\n    }\n\n    return {\n      // setting AnnotationQuery props explicitly since spreading would incorrectly use props that should be on the target only\n      datasource: query.datasource,\n      enable: query.enable,\n      iconColor: query.iconColor,\n      name: query.name,\n      builtIn: query.builtIn,\n      hide: query.hide,\n      target: Object.assign({}, query.target, query, {\n        statistic: query.statistic || 'Average',\n        region: query.region || 'default',\n        queryMode: 'Annotations',\n        refId: query.refId || 'annotationQuery'\n      })\n    };\n  },\n  // return undefined if query is not complete so that annotation query execution is quietly skipped\n  prepareQuery: anno => {\n    if (!anno.target) {\n      return undefined;\n    }\n\n    const {\n      prefixMatching,\n      actionPrefix,\n      alarmNamePrefix,\n      statistic,\n      namespace,\n      metricName,\n      dimensions = {}\n    } = anno.target;\n    const validPrefixMatchingQuery = !!prefixMatching && !!actionPrefix && !!alarmNamePrefix;\n    const validMetricStatQuery = !prefixMatching && !!namespace && !!metricName && !!statistic && !!Object.values(dimensions).length;\n\n    if (validPrefixMatchingQuery || validMetricStatQuery) {\n      return anno.target;\n    }\n\n    return undefined;\n  },\n  QueryEditor: AnnotationQueryEditor\n};","map":{"version":3,"names":["AnnotationQueryEditor","isCloudWatchAnnotation","CloudWatchAnnotationSupport","prepareAnnotation","query","datasource","enable","iconColor","name","builtIn","hide","target","statistic","region","queryMode","refId","prepareQuery","anno","undefined","prefixMatching","actionPrefix","alarmNamePrefix","namespace","metricName","dimensions","validPrefixMatchingQuery","validMetricStatQuery","Object","values","length","QueryEditor"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/annotationSupport.ts"],"sourcesContent":["import { AnnotationQuery } from '@grafana/data';\n\nimport { AnnotationQueryEditor } from './components/AnnotationQueryEditor';\nimport { isCloudWatchAnnotation } from './guards';\nimport { CloudWatchAnnotationQuery, CloudWatchQuery, LegacyAnnotationQuery } from './types';\n\nexport const CloudWatchAnnotationSupport = {\n  // converts legacy angular style queries to new format. Also sets the same default values as in the deprecated angular directive\n  prepareAnnotation: (\n    query: LegacyAnnotationQuery | AnnotationQuery<CloudWatchAnnotationQuery>\n  ): AnnotationQuery<CloudWatchAnnotationQuery> => {\n    if (isCloudWatchAnnotation(query)) {\n      return query;\n    }\n\n    return {\n      // setting AnnotationQuery props explicitly since spreading would incorrectly use props that should be on the target only\n      datasource: query.datasource,\n      enable: query.enable,\n      iconColor: query.iconColor,\n      name: query.name,\n      builtIn: query.builtIn,\n      hide: query.hide,\n      target: {\n        ...query.target,\n        ...query,\n        statistic: query.statistic || 'Average',\n        region: query.region || 'default',\n        queryMode: 'Annotations',\n        refId: query.refId || 'annotationQuery',\n      },\n    };\n  },\n  // return undefined if query is not complete so that annotation query execution is quietly skipped\n  prepareQuery: (anno: AnnotationQuery<CloudWatchAnnotationQuery>): CloudWatchQuery | undefined => {\n    if (!anno.target) {\n      return undefined;\n    }\n\n    const {\n      prefixMatching,\n      actionPrefix,\n      alarmNamePrefix,\n      statistic,\n      namespace,\n      metricName,\n      dimensions = {},\n    } = anno.target;\n    const validPrefixMatchingQuery = !!prefixMatching && !!actionPrefix && !!alarmNamePrefix;\n    const validMetricStatQuery =\n      !prefixMatching && !!namespace && !!metricName && !!statistic && !!Object.values(dimensions).length;\n\n    if (validPrefixMatchingQuery || validMetricStatQuery) {\n      return anno.target;\n    }\n\n    return undefined;\n  },\n  QueryEditor: AnnotationQueryEditor,\n};\n"],"mappings":"AAEA,SAASA,qBAAT,QAAsC,oCAAtC;AACA,SAASC,sBAAT,QAAuC,UAAvC;AAGA,OAAO,MAAMC,2BAA2B,GAAG;EACzC;EACAC,iBAAiB,EACfC,KADiB,IAE8B;IAC/C,IAAIH,sBAAsB,CAACG,KAAD,CAA1B,EAAmC;MACjC,OAAOA,KAAP;IACD;;IAED,OAAO;MACL;MACAC,UAAU,EAAED,KAAK,CAACC,UAFb;MAGLC,MAAM,EAAEF,KAAK,CAACE,MAHT;MAILC,SAAS,EAAEH,KAAK,CAACG,SAJZ;MAKLC,IAAI,EAAEJ,KAAK,CAACI,IALP;MAMLC,OAAO,EAAEL,KAAK,CAACK,OANV;MAOLC,IAAI,EAAEN,KAAK,CAACM,IAPP;MAQLC,MAAM,oBACDP,KAAK,CAACO,MADL,EAEDP,KAFC;QAGJQ,SAAS,EAAER,KAAK,CAACQ,SAAN,IAAmB,SAH1B;QAIJC,MAAM,EAAET,KAAK,CAACS,MAAN,IAAgB,SAJpB;QAKJC,SAAS,EAAE,aALP;QAMJC,KAAK,EAAEX,KAAK,CAACW,KAAN,IAAe;MANlB;IARD,CAAP;EAiBD,CA1BwC;EA2BzC;EACAC,YAAY,EAAGC,IAAD,IAAmF;IAC/F,IAAI,CAACA,IAAI,CAACN,MAAV,EAAkB;MAChB,OAAOO,SAAP;IACD;;IAED,MAAM;MACJC,cADI;MAEJC,YAFI;MAGJC,eAHI;MAIJT,SAJI;MAKJU,SALI;MAMJC,UANI;MAOJC,UAAU,GAAG;IAPT,IAQFP,IAAI,CAACN,MART;IASA,MAAMc,wBAAwB,GAAG,CAAC,CAACN,cAAF,IAAoB,CAAC,CAACC,YAAtB,IAAsC,CAAC,CAACC,eAAzE;IACA,MAAMK,oBAAoB,GACxB,CAACP,cAAD,IAAmB,CAAC,CAACG,SAArB,IAAkC,CAAC,CAACC,UAApC,IAAkD,CAAC,CAACX,SAApD,IAAiE,CAAC,CAACe,MAAM,CAACC,MAAP,CAAcJ,UAAd,EAA0BK,MAD/F;;IAGA,IAAIJ,wBAAwB,IAAIC,oBAAhC,EAAsD;MACpD,OAAOT,IAAI,CAACN,MAAZ;IACD;;IAED,OAAOO,SAAP;EACD,CAnDwC;EAoDzCY,WAAW,EAAE9B;AApD4B,CAApC"},"metadata":{},"sourceType":"module"}