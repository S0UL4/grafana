{"ast":null,"code":"import { useEffect, useRef, useState } from 'react';\n\n/**\n * Hook that delays changing of boolean switch to prevent too much time spent in \"on\" state. It is kind of a throttle\n * but you can specify different time for on and off throttling so this only allows a boolean values and also prefers\n * to stay \"off\" so turning \"on\" is always delayed while turning \"off\" is throttled.\n *\n * This is useful for showing loading elements to prevent it flashing too much in case of quick loading time or\n * prevent it flash if loaded state comes right after switch to loading.\n */\nexport function useDelayedSwitch(value, options = {}) {\n  const {\n    duration = 250,\n    delay = 250\n  } = options;\n  const [delayedValue, setDelayedValue] = useState(value);\n  const onStartTime = useRef();\n  useEffect(() => {\n    let timeout;\n\n    if (value) {\n      // If toggling to \"on\" state we always setTimeout no matter how long we have been \"off\".\n      timeout = setTimeout(() => {\n        onStartTime.current = new Date();\n        setDelayedValue(value);\n      }, delay);\n    } else {\n      // If toggling to \"off\" state we check how much time we were already \"on\".\n      const timeSpent = onStartTime.current ? Date.now() - onStartTime.current.valueOf() : 0;\n\n      const turnOff = () => {\n        onStartTime.current = undefined;\n        setDelayedValue(value);\n      };\n\n      if (timeSpent >= duration) {\n        // We already spent enough time \"on\" so change right away.\n        turnOff();\n      } else {\n        timeout = setTimeout(turnOff, duration - timeSpent);\n      }\n    }\n\n    return () => {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = undefined;\n      }\n    };\n  }, [value, duration, delay]);\n  return delayedValue;\n}","map":{"version":3,"names":["useEffect","useRef","useState","useDelayedSwitch","value","options","duration","delay","delayedValue","setDelayedValue","onStartTime","timeout","setTimeout","current","Date","timeSpent","now","valueOf","turnOff","undefined","clearTimeout"],"sources":["/home/soula/grafana/packages/grafana-ui/src/utils/useDelayedSwitch.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\ntype DelayOptions = {\n  // Minimal amount of time the switch will be on.\n  duration?: number;\n  // Delay after which switch will turn on.\n  delay?: number;\n};\n\n/**\n * Hook that delays changing of boolean switch to prevent too much time spent in \"on\" state. It is kind of a throttle\n * but you can specify different time for on and off throttling so this only allows a boolean values and also prefers\n * to stay \"off\" so turning \"on\" is always delayed while turning \"off\" is throttled.\n *\n * This is useful for showing loading elements to prevent it flashing too much in case of quick loading time or\n * prevent it flash if loaded state comes right after switch to loading.\n */\nexport function useDelayedSwitch(value: boolean, options: DelayOptions = {}): boolean {\n  const { duration = 250, delay = 250 } = options;\n\n  const [delayedValue, setDelayedValue] = useState(value);\n  const onStartTime = useRef<Date | undefined>();\n\n  useEffect(() => {\n    let timeout: number | undefined;\n    if (value) {\n      // If toggling to \"on\" state we always setTimeout no matter how long we have been \"off\".\n      timeout = setTimeout(() => {\n        onStartTime.current = new Date();\n        setDelayedValue(value);\n      }, delay) as any;\n    } else {\n      // If toggling to \"off\" state we check how much time we were already \"on\".\n      const timeSpent = onStartTime.current ? Date.now() - onStartTime.current.valueOf() : 0;\n      const turnOff = () => {\n        onStartTime.current = undefined;\n        setDelayedValue(value);\n      };\n      if (timeSpent >= duration) {\n        // We already spent enough time \"on\" so change right away.\n        turnOff();\n      } else {\n        timeout = setTimeout(turnOff, duration - timeSpent) as any;\n      }\n    }\n    return () => {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = undefined;\n      }\n    };\n  }, [value, duration, delay]);\n\n  return delayedValue;\n}\n"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,EAA4BC,QAA5B,QAA4C,OAA5C;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAT,CAA0BC,KAA1B,EAA0CC,OAAqB,GAAG,EAAlE,EAA+E;EACpF,MAAM;IAAEC,QAAQ,GAAG,GAAb;IAAkBC,KAAK,GAAG;EAA1B,IAAkCF,OAAxC;EAEA,MAAM,CAACG,YAAD,EAAeC,eAAf,IAAkCP,QAAQ,CAACE,KAAD,CAAhD;EACA,MAAMM,WAAW,GAAGT,MAAM,EAA1B;EAEAD,SAAS,CAAC,MAAM;IACd,IAAIW,OAAJ;;IACA,IAAIP,KAAJ,EAAW;MACT;MACAO,OAAO,GAAGC,UAAU,CAAC,MAAM;QACzBF,WAAW,CAACG,OAAZ,GAAsB,IAAIC,IAAJ,EAAtB;QACAL,eAAe,CAACL,KAAD,CAAf;MACD,CAHmB,EAGjBG,KAHiB,CAApB;IAID,CAND,MAMO;MACL;MACA,MAAMQ,SAAS,GAAGL,WAAW,CAACG,OAAZ,GAAsBC,IAAI,CAACE,GAAL,KAAaN,WAAW,CAACG,OAAZ,CAAoBI,OAApB,EAAnC,GAAmE,CAArF;;MACA,MAAMC,OAAO,GAAG,MAAM;QACpBR,WAAW,CAACG,OAAZ,GAAsBM,SAAtB;QACAV,eAAe,CAACL,KAAD,CAAf;MACD,CAHD;;MAIA,IAAIW,SAAS,IAAIT,QAAjB,EAA2B;QACzB;QACAY,OAAO;MACR,CAHD,MAGO;QACLP,OAAO,GAAGC,UAAU,CAACM,OAAD,EAAUZ,QAAQ,GAAGS,SAArB,CAApB;MACD;IACF;;IACD,OAAO,MAAM;MACX,IAAIJ,OAAJ,EAAa;QACXS,YAAY,CAACT,OAAD,CAAZ;QACAA,OAAO,GAAGQ,SAAV;MACD;IACF,CALD;EAMD,CA5BQ,EA4BN,CAACf,KAAD,EAAQE,QAAR,EAAkBC,KAAlB,CA5BM,CAAT;EA8BA,OAAOC,YAAP;AACD"},"metadata":{},"sourceType":"module"}