{"ast":null,"code":"const _excluded = [\"__interval\", \"__interval_ms\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { cloneDeep, extend, get, groupBy, has, isString, map as _map, omit, pick, reduce } from 'lodash';\nimport { lastValueFrom, of, throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { v4 as uuidv4 } from 'uuid';\nimport { ArrayVector, dateMath, dateTime, FieldType, LoadingState, TIME_SERIES_TIME_FIELD_NAME, TIME_SERIES_VALUE_FIELD_NAME } from '@grafana/data';\nimport { DataSourceWithBackend, frameToMetricFindValue, getBackendSrv } from '@grafana/runtime';\nimport config from 'app/core/config';\nimport { getTemplateSrv } from 'app/features/templating/template_srv';\nimport { FluxQueryEditor } from './components/FluxQueryEditor';\nimport InfluxQueryModel from './influx_query_model';\nimport InfluxSeries from './influx_series';\nimport { buildRawQuery } from './queryUtils';\nimport { InfluxQueryBuilder } from './query_builder';\nimport ResponseParser from './response_parser';\nimport { InfluxVersion } from './types'; // we detect the field type based on the value-array\n\nfunction getFieldType(values) {\n  // the values-array may contain a lot of nulls.\n  // we need the first not-null item\n  const firstNotNull = values.find(v => v !== null);\n\n  if (firstNotNull === undefined) {\n    // we could not find any not-null values\n    return FieldType.number;\n  }\n\n  const valueType = typeof firstNotNull;\n\n  switch (valueType) {\n    case 'string':\n      return FieldType.string;\n\n    case 'boolean':\n      return FieldType.boolean;\n\n    case 'number':\n      return FieldType.number;\n\n    default:\n      // this should never happen, influxql values\n      // can only be numbers, strings and booleans.\n      throw new Error(`InfluxQL: invalid value type ${valueType}`);\n  }\n} // this conversion function is specialized to work with the timeseries\n// data returned by InfluxDatasource.getTimeSeries()\n\n\nfunction timeSeriesToDataFrame(timeSeries) {\n  const times = [];\n  const values = []; // the data we process here is not correctly typed.\n  // the typescript types say every data-point is number|null,\n  // but in fact it can be string or boolean too.\n\n  const points = timeSeries.datapoints;\n\n  for (const point of points) {\n    values.push(point[0]);\n    times.push(point[1]);\n  }\n\n  const timeField = {\n    name: TIME_SERIES_TIME_FIELD_NAME,\n    type: FieldType.time,\n    config: {},\n    values: new ArrayVector(times)\n  };\n  const valueField = {\n    name: TIME_SERIES_VALUE_FIELD_NAME,\n    type: getFieldType(values),\n    config: {\n      displayNameFromDS: timeSeries.title\n    },\n    values: new ArrayVector(values),\n    labels: timeSeries.tags\n  };\n  const fields = [timeField, valueField];\n  return {\n    name: timeSeries.target,\n    refId: timeSeries.refId,\n    meta: timeSeries.meta,\n    fields,\n    length: values.length\n  };\n}\n\nexport default class InfluxDatasource extends DataSourceWithBackend {\n  constructor(instanceSettings, templateSrv = getTemplateSrv()) {\n    var _instanceSettings$url, _instanceSettings$use, _instanceSettings$pas;\n\n    super(instanceSettings);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"urls\", void 0);\n\n    _defineProperty(this, \"username\", void 0);\n\n    _defineProperty(this, \"password\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"database\", void 0);\n\n    _defineProperty(this, \"basicAuth\", void 0);\n\n    _defineProperty(this, \"withCredentials\", void 0);\n\n    _defineProperty(this, \"access\", void 0);\n\n    _defineProperty(this, \"interval\", void 0);\n\n    _defineProperty(this, \"responseParser\", void 0);\n\n    _defineProperty(this, \"httpMode\", void 0);\n\n    _defineProperty(this, \"isFlux\", void 0);\n\n    this.templateSrv = templateSrv;\n    this.type = 'influxdb';\n    this.urls = ((_instanceSettings$url = instanceSettings.url) !== null && _instanceSettings$url !== void 0 ? _instanceSettings$url : '').split(',').map(url => {\n      return url.trim();\n    });\n    this.username = (_instanceSettings$use = instanceSettings.username) !== null && _instanceSettings$use !== void 0 ? _instanceSettings$use : '';\n    this.password = (_instanceSettings$pas = instanceSettings.password) !== null && _instanceSettings$pas !== void 0 ? _instanceSettings$pas : '';\n    this.name = instanceSettings.name;\n    this.database = instanceSettings.database;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.access = instanceSettings.access;\n    const settingsData = instanceSettings.jsonData || {};\n    this.interval = settingsData.timeInterval;\n    this.httpMode = settingsData.httpMode || 'GET';\n    this.responseParser = new ResponseParser();\n    this.isFlux = settingsData.version === InfluxVersion.Flux;\n\n    if (this.isFlux) {\n      // When flux, use an annotation processor rather than the `annotationQuery` lifecycle\n      this.annotations = {\n        QueryEditor: FluxQueryEditor\n      };\n    }\n  }\n\n  query(request) {\n    // for not-flux queries we call `this.classicQuery`, and that\n    // handles the is-hidden situation.\n    // for the flux-case, we do the filtering here\n    const filteredRequest = Object.assign({}, request, {\n      targets: request.targets.filter(t => t.hide !== true)\n    });\n\n    if (this.isFlux) {\n      return super.query(filteredRequest);\n    }\n\n    if (this.isMigrationToggleOnAndIsAccessProxy()) {\n      return super.query(filteredRequest).pipe(map(res => {\n        if (res.error) {\n          throw {\n            message: 'InfluxDB Error: ' + res.error.message,\n            res\n          };\n        }\n\n        const seriesList = [];\n        const groupedFrames = groupBy(res.data, x => x.refId);\n\n        if (Object.keys(groupedFrames).length > 0) {\n          filteredRequest.targets.forEach(target => {\n            var _groupedFrames$target;\n\n            const filteredFrames = (_groupedFrames$target = groupedFrames[target.refId]) !== null && _groupedFrames$target !== void 0 ? _groupedFrames$target : [];\n\n            switch (target.resultFormat) {\n              case 'logs':\n              case 'table':\n                seriesList.push(this.responseParser.getTable(filteredFrames, target, {\n                  preferredVisualisationType: target.resultFormat\n                }));\n                break;\n\n              default:\n                {\n                  for (let i = 0; i < filteredFrames.length; i++) {\n                    seriesList.push(filteredFrames[i]);\n                  }\n\n                  break;\n                }\n            }\n          });\n        }\n\n        return {\n          data: seriesList\n        };\n      }));\n    } // Fallback to classic query support\n\n\n    return this.classicQuery(request);\n  }\n\n  getQueryDisplayText(query) {\n    if (this.isFlux) {\n      return query.query;\n    }\n\n    return new InfluxQueryModel(query).render(false);\n  }\n  /**\n   * Returns false if the query should be skipped\n   */\n\n\n  filterQuery(query) {\n    if (this.isFlux) {\n      return !!query.query;\n    }\n\n    return true;\n  }\n\n  applyTemplateVariables(query, scopedVars) {\n    // We want to interpolate these variables on backend\n    const rest = _objectWithoutPropertiesLoose(scopedVars, _excluded);\n\n    if (this.isFlux) {\n      var _query$query;\n\n      return Object.assign({}, query, {\n        query: this.templateSrv.replace((_query$query = query.query) !== null && _query$query !== void 0 ? _query$query : '', rest) // The raw query text\n\n      });\n    }\n\n    if (config.featureToggles.influxdbBackendMigration && this.access === 'proxy') {\n      query = this.applyVariables(query, scopedVars, rest);\n    }\n\n    return query;\n  }\n  /**\n   * The unchanged pre 7.1 query implementation\n   */\n\n\n  classicQuery(options) {\n    let timeFilter = this.getTimeFilter(options);\n    const scopedVars = options.scopedVars;\n    const targets = cloneDeep(options.targets);\n    const queryTargets = [];\n    let i, y;\n\n    let allQueries = _map(targets, target => {\n      if (target.hide) {\n        return '';\n      }\n\n      queryTargets.push(target); // backward compatibility\n\n      scopedVars.interval = scopedVars.__interval;\n      return new InfluxQueryModel(target, this.templateSrv, scopedVars).render(true);\n    }).reduce((acc, current) => {\n      if (current !== '') {\n        acc += ';' + current;\n      }\n\n      return acc;\n    });\n\n    if (allQueries === '') {\n      return of({\n        data: []\n      });\n    } // add global adhoc filters to timeFilter\n\n\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n\n    if (adhocFilters.length > 0) {\n      const tmpQuery = new InfluxQueryModel({\n        refId: 'A'\n      }, this.templateSrv, scopedVars);\n      timeFilter += ' AND ' + tmpQuery.renderAdhocFilters(adhocFilters);\n    } // replace grafana variables\n\n\n    scopedVars.timeFilter = {\n      value: timeFilter\n    }; // replace templated variables\n\n    allQueries = this.templateSrv.replace(allQueries, scopedVars);\n    return this._seriesQuery(allQueries, options).pipe(map(data => {\n      if (!data || !data.results) {\n        return {\n          data: []\n        };\n      }\n\n      const seriesList = [];\n\n      for (i = 0; i < data.results.length; i++) {\n        const result = data.results[i];\n\n        if (!result || !result.series) {\n          continue;\n        }\n\n        const target = queryTargets[i];\n        let alias = target.alias;\n\n        if (alias) {\n          alias = this.templateSrv.replace(target.alias, options.scopedVars);\n        }\n\n        const meta = {\n          executedQueryString: data.executedQueryString\n        };\n        const influxSeries = new InfluxSeries({\n          refId: target.refId,\n          series: data.results[i].series,\n          alias: alias,\n          meta\n        });\n\n        switch (target.resultFormat) {\n          case 'logs':\n            meta.preferredVisualisationType = 'logs';\n\n          case 'table':\n            {\n              seriesList.push(influxSeries.getTable());\n              break;\n            }\n\n          default:\n            {\n              const timeSeries = influxSeries.getTimeSeries();\n\n              for (y = 0; y < timeSeries.length; y++) {\n                seriesList.push(timeSeriesToDataFrame(timeSeries[y]));\n              }\n\n              break;\n            }\n        }\n      }\n\n      return {\n        data: seriesList\n      };\n    }));\n  }\n\n  async annotationQuery(options) {\n    if (this.isFlux) {\n      return Promise.reject({\n        message: 'Flux requires the standard annotation query'\n      });\n    } // InfluxQL puts a query string on the annotation\n\n\n    if (!options.annotation.query) {\n      return Promise.reject({\n        message: 'Query missing in annotation definition'\n      });\n    }\n\n    if (config.featureToggles.influxdbBackendMigration && this.access === 'proxy') {\n      var _options$annotation$q;\n\n      // We want to send our query to the backend as a raw query\n      const target = {\n        refId: 'metricFindQuery',\n        datasource: this.getRef(),\n        query: this.templateSrv.replace((_options$annotation$q = options.annotation.query) !== null && _options$annotation$q !== void 0 ? _options$annotation$q : ''),\n        rawQuery: true\n      };\n      return lastValueFrom(getBackendSrv().fetch({\n        url: '/api/ds/query',\n        method: 'POST',\n        data: {\n          from: options.range.from.valueOf().toString(),\n          to: options.range.to.valueOf().toString(),\n          queries: [target]\n        },\n        requestId: options.annotation.name\n      }).pipe(map(async res => await this.responseParser.transformAnnotationResponse(options, res, target))));\n    }\n\n    const timeFilter = this.getTimeFilter({\n      rangeRaw: options.rangeRaw,\n      timezone: options.dashboard.timezone\n    });\n    let query = options.annotation.query.replace('$timeFilter', timeFilter);\n    query = this.templateSrv.replace(query, undefined, 'regex');\n    return lastValueFrom(this._seriesQuery(query, options)).then(data => {\n      if (!data || !data.results || !data.results[0]) {\n        throw {\n          message: 'No results in response from InfluxDB'\n        };\n      }\n\n      return new InfluxSeries({\n        series: data.results[0].series,\n        annotation: options.annotation\n      }).getAnnotations();\n    });\n  }\n\n  targetContainsTemplate(target) {\n    // for flux-mode we just take target.query,\n    // for influxql-mode we use InfluxQueryModel to create the text-representation\n    const queryText = this.isFlux ? target.query : buildRawQuery(target);\n    return this.templateSrv.containsTemplate(queryText);\n  }\n\n  interpolateVariablesInQueries(queries, scopedVars) {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    return queries.map(query => {\n      if (this.isFlux) {\n        var _query$query2;\n\n        return Object.assign({}, query, {\n          datasource: this.getRef(),\n          query: this.templateSrv.replace((_query$query2 = query.query) !== null && _query$query2 !== void 0 ? _query$query2 : '', scopedVars) // The raw query text\n\n        });\n      }\n\n      return Object.assign({}, query, {\n        datasource: this.getRef()\n      }, this.applyVariables(query, scopedVars, scopedVars));\n    });\n  }\n\n  applyVariables(query, scopedVars, rest) {\n    var _query$query3, _query$alias, _query$limit$toString, _query$limit, _query$measurement, _query$policy, _query$slimit$toStrin, _query$slimit, _query$tz;\n\n    const expandedQuery = Object.assign({}, query);\n\n    if (query.groupBy) {\n      expandedQuery.groupBy = query.groupBy.map(groupBy => {\n        var _groupBy$params;\n\n        return Object.assign({}, groupBy, {\n          params: (_groupBy$params = groupBy.params) === null || _groupBy$params === void 0 ? void 0 : _groupBy$params.map(param => {\n            return this.templateSrv.replace(param.toString(), undefined, 'regex');\n          })\n        });\n      });\n    }\n\n    if (query.select) {\n      expandedQuery.select = query.select.map(selects => {\n        return selects.map(select => {\n          var _select$params;\n\n          return Object.assign({}, select, {\n            params: (_select$params = select.params) === null || _select$params === void 0 ? void 0 : _select$params.map(param => {\n              return this.templateSrv.replace(param.toString(), undefined, 'regex');\n            })\n          });\n        });\n      });\n    }\n\n    if (query.tags) {\n      expandedQuery.tags = query.tags.map(tag => {\n        return Object.assign({}, tag, {\n          value: this.templateSrv.replace(tag.value, undefined, 'regex')\n        });\n      });\n    }\n\n    return Object.assign({}, expandedQuery, {\n      query: this.templateSrv.replace((_query$query3 = query.query) !== null && _query$query3 !== void 0 ? _query$query3 : '', rest),\n      // The raw query text\n      alias: this.templateSrv.replace((_query$alias = query.alias) !== null && _query$alias !== void 0 ? _query$alias : '', scopedVars),\n      limit: this.templateSrv.replace((_query$limit$toString = (_query$limit = query.limit) === null || _query$limit === void 0 ? void 0 : _query$limit.toString()) !== null && _query$limit$toString !== void 0 ? _query$limit$toString : '', scopedVars, 'regex'),\n      measurement: this.templateSrv.replace((_query$measurement = query.measurement) !== null && _query$measurement !== void 0 ? _query$measurement : '', scopedVars, 'regex'),\n      policy: this.templateSrv.replace((_query$policy = query.policy) !== null && _query$policy !== void 0 ? _query$policy : '', scopedVars, 'regex'),\n      slimit: this.templateSrv.replace((_query$slimit$toStrin = (_query$slimit = query.slimit) === null || _query$slimit === void 0 ? void 0 : _query$slimit.toString()) !== null && _query$slimit$toStrin !== void 0 ? _query$slimit$toStrin : '', scopedVars, 'regex'),\n      tz: this.templateSrv.replace((_query$tz = query.tz) !== null && _query$tz !== void 0 ? _query$tz : '', scopedVars)\n    });\n  }\n\n  async metricFindQuery(query, options) {\n    if (this.isFlux || this.isMigrationToggleOnAndIsAccessProxy()) {\n      const target = {\n        refId: 'metricFindQuery',\n        query,\n        rawQuery: true\n      };\n      return lastValueFrom(super.query(Object.assign({}, options, {\n        // includes 'range'\n        targets: [target]\n      }))).then(rsp => {\n        var _rsp$data;\n\n        if ((_rsp$data = rsp.data) !== null && _rsp$data !== void 0 && _rsp$data.length) {\n          return frameToMetricFindValue(rsp.data[0]);\n        }\n\n        return [];\n      });\n    }\n\n    const interpolated = this.templateSrv.replace(query, undefined, 'regex');\n    return lastValueFrom(this._seriesQuery(interpolated, options)).then(resp => {\n      return this.responseParser.parse(query, resp);\n    });\n  }\n\n  getTagKeys(options = {}) {\n    const queryBuilder = new InfluxQueryBuilder({\n      measurement: options.measurement || '',\n      tags: []\n    }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_KEYS');\n    return this.metricFindQuery(query, options);\n  }\n\n  getTagValues(options = {}) {\n    const queryBuilder = new InfluxQueryBuilder({\n      measurement: options.measurement || '',\n      tags: []\n    }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);\n    return this.metricFindQuery(query, options);\n  }\n\n  _seriesQuery(query, options) {\n    if (!query) {\n      return of({\n        results: []\n      });\n    }\n\n    if (options && options.range) {\n      const timeFilter = this.getTimeFilter({\n        rangeRaw: options.range,\n        timezone: options.timezone\n      });\n      query = query.replace('$timeFilter', timeFilter);\n    }\n\n    return this._influxRequest(this.httpMode, '/query', {\n      q: query,\n      epoch: 'ms'\n    }, options);\n  }\n\n  serializeParams(params) {\n    if (!params) {\n      return '';\n    }\n\n    return reduce(params, (memo, value, key) => {\n      if (value === null || value === undefined) {\n        return memo;\n      }\n\n      memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n      return memo;\n    }, []).join('&');\n  }\n\n  testDatasource() {\n    if (this.isFlux) {\n      // TODO: eventually use the real /health endpoint\n      const request = {\n        targets: [{\n          refId: 'test',\n          query: 'buckets()'\n        }],\n        requestId: `${this.id}-health-${uuidv4()}`,\n        dashboardId: 0,\n        panelId: 0,\n        interval: '1m',\n        intervalMs: 60000,\n        maxDataPoints: 423,\n        range: {\n          from: dateTime(1000),\n          to: dateTime(2000)\n        }\n      };\n      return lastValueFrom(super.query(request)).then(res => {\n        if (!res || !res.data || res.state !== LoadingState.Done) {\n          console.error('InfluxDB Error', res);\n          return {\n            status: 'error',\n            message: 'Error reading InfluxDB'\n          };\n        }\n\n        const first = res.data[0];\n\n        if (first && first.length) {\n          return {\n            status: 'success',\n            message: `${first.length} buckets found`\n          };\n        }\n\n        console.error('InfluxDB Error', res);\n        return {\n          status: 'error',\n          message: 'Error reading buckets'\n        };\n      }).catch(err => {\n        console.error('InfluxDB Error', err);\n        return {\n          status: 'error',\n          message: err.message\n        };\n      });\n    }\n\n    if (this.isMigrationToggleOnAndIsAccessProxy()) {\n      const target = {\n        refId: 'metricFindQuery',\n        query: 'SHOW TAG KEYS',\n        rawQuery: true\n      };\n      return lastValueFrom(super.query({\n        targets: [target]\n      })).then(res => {\n        var _res$data;\n\n        if (!res || !res.data || res.state !== LoadingState.Done) {\n          return {\n            status: 'error',\n            message: 'Error reading InfluxDB.'\n          };\n        }\n\n        if ((_res$data = res.data) !== null && _res$data !== void 0 && _res$data.length) {\n          return {\n            status: 'success',\n            message: 'Data source is working.'\n          };\n        }\n\n        return {\n          status: 'error',\n          message: 'Successfully connected to InfluxDB, but no tags found.'\n        };\n      }).catch(err => {\n        return {\n          status: 'error',\n          message: err.message\n        };\n      });\n    }\n\n    const queryBuilder = new InfluxQueryBuilder({\n      measurement: '',\n      tags: []\n    }, this.database);\n    const query = queryBuilder.buildExploreQuery('RETENTION POLICIES');\n    return lastValueFrom(this._seriesQuery(query)).then(res => {\n      const error = get(res, 'results[0].error');\n\n      if (error) {\n        return {\n          status: 'error',\n          message: error\n        };\n      }\n\n      return {\n        status: 'success',\n        message: 'Data source is working'\n      };\n    }).catch(err => {\n      return {\n        status: 'error',\n        message: err.message\n      };\n    });\n  }\n\n  _influxRequest(method, url, data, options) {\n    const currentUrl = this.urls.shift();\n    this.urls.push(currentUrl);\n    const params = {};\n\n    if (this.username) {\n      params.u = this.username;\n      params.p = this.password;\n    }\n\n    if (options && options.database) {\n      params.db = options.database;\n    } else if (this.database) {\n      params.db = this.database;\n    }\n\n    const {\n      q\n    } = data;\n\n    if (method === 'POST' && has(data, 'q')) {\n      // verb is POST and 'q' param is defined\n      extend(params, omit(data, ['q']));\n      data = this.serializeParams(pick(data, ['q']));\n    } else if (method === 'GET' || method === 'POST') {\n      // verb is GET, or POST without 'q' param\n      extend(params, data);\n      data = null;\n    }\n\n    const req = {\n      method: method,\n      url: currentUrl + url,\n      params: params,\n      data: data,\n      precision: 'ms',\n      inspect: {\n        type: 'influxdb'\n      },\n      paramSerializer: this.serializeParams\n    };\n    req.headers = req.headers || {};\n\n    if (this.basicAuth || this.withCredentials) {\n      req.withCredentials = true;\n    }\n\n    if (this.basicAuth) {\n      req.headers.Authorization = this.basicAuth;\n    }\n\n    if (method === 'POST') {\n      req.headers['Content-type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return getBackendSrv().fetch(req).pipe(map(result => {\n      const {\n        data\n      } = result;\n\n      if (data) {\n        data.executedQueryString = q;\n\n        if (data.results) {\n          const errors = result.data.results.filter(elem => elem.error);\n\n          if (errors.length > 0) {\n            throw {\n              message: 'InfluxDB Error: ' + errors[0].error,\n              data\n            };\n          }\n        }\n      }\n\n      return data;\n    }), catchError(err => {\n      if (err.cancelled) {\n        return of(err);\n      }\n\n      return throwError(this.handleErrors(err));\n    }));\n  }\n\n  handleErrors(err) {\n    const error = {\n      message: err && err.status || err && err.message || 'Unknown error during query transaction. Please check JS console logs.'\n    };\n\n    if (Number.isInteger(err.status) && err.status !== 0 || err.status >= 300) {\n      if (err.data && err.data.error) {\n        error.message = 'InfluxDB Error: ' + err.data.error;\n        error.data = err.data; // @ts-ignore\n\n        error.config = err.config;\n      } else {\n        error.message = 'Network Error: ' + err.statusText + '(' + err.status + ')';\n        error.data = err.data; // @ts-ignore\n\n        error.config = err.config;\n      }\n    }\n\n    return error;\n  }\n\n  getTimeFilter(options) {\n    const from = this.getInfluxTime(options.rangeRaw.from, false, options.timezone);\n    const until = this.getInfluxTime(options.rangeRaw.to, true, options.timezone);\n    return 'time >= ' + from + ' and time <= ' + until;\n  }\n\n  getInfluxTime(date, roundUp, timezone) {\n    if (isString(date)) {\n      if (date === 'now') {\n        return 'now()';\n      }\n\n      const parts = /^now-(\\d+)([dhms])$/.exec(date);\n\n      if (parts) {\n        const amount = parseInt(parts[1], 10);\n        const unit = parts[2];\n        return 'now() - ' + amount + unit;\n      }\n\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    return date.valueOf() + 'ms';\n  }\n\n  isMigrationToggleOnAndIsAccessProxy() {\n    return config.featureToggles.influxdbBackendMigration && this.access === 'proxy';\n  }\n\n}","map":{"version":3,"names":["cloneDeep","extend","get","groupBy","has","isString","map","_map","omit","pick","reduce","lastValueFrom","of","throwError","catchError","v4","uuidv4","ArrayVector","dateMath","dateTime","FieldType","LoadingState","TIME_SERIES_TIME_FIELD_NAME","TIME_SERIES_VALUE_FIELD_NAME","DataSourceWithBackend","frameToMetricFindValue","getBackendSrv","config","getTemplateSrv","FluxQueryEditor","InfluxQueryModel","InfluxSeries","buildRawQuery","InfluxQueryBuilder","ResponseParser","InfluxVersion","getFieldType","values","firstNotNull","find","v","undefined","number","valueType","string","boolean","Error","timeSeriesToDataFrame","timeSeries","times","points","datapoints","point","push","timeField","name","type","time","valueField","displayNameFromDS","title","labels","tags","fields","target","refId","meta","length","InfluxDatasource","constructor","instanceSettings","templateSrv","urls","url","split","trim","username","password","database","basicAuth","withCredentials","access","settingsData","jsonData","interval","timeInterval","httpMode","responseParser","isFlux","version","Flux","annotations","QueryEditor","query","request","filteredRequest","targets","filter","t","hide","isMigrationToggleOnAndIsAccessProxy","pipe","res","error","message","seriesList","groupedFrames","data","x","Object","keys","forEach","filteredFrames","resultFormat","getTable","preferredVisualisationType","i","classicQuery","getQueryDisplayText","render","filterQuery","applyTemplateVariables","scopedVars","rest","replace","featureToggles","influxdbBackendMigration","applyVariables","options","timeFilter","getTimeFilter","queryTargets","y","allQueries","__interval","acc","current","adhocFilters","getAdhocFilters","tmpQuery","renderAdhocFilters","value","_seriesQuery","results","result","series","alias","executedQueryString","influxSeries","getTimeSeries","annotationQuery","Promise","reject","annotation","datasource","getRef","rawQuery","fetch","method","from","range","valueOf","toString","to","queries","requestId","transformAnnotationResponse","rangeRaw","timezone","dashboard","then","getAnnotations","targetContainsTemplate","queryText","containsTemplate","interpolateVariablesInQueries","expandedQuery","params","param","select","selects","tag","limit","measurement","policy","slimit","tz","metricFindQuery","rsp","interpolated","resp","parse","getTagKeys","queryBuilder","buildExploreQuery","getTagValues","key","_influxRequest","q","epoch","serializeParams","memo","encodeURIComponent","join","testDatasource","id","dashboardId","panelId","intervalMs","maxDataPoints","state","Done","console","status","first","catch","err","currentUrl","shift","u","p","db","req","precision","inspect","paramSerializer","headers","Authorization","errors","elem","cancelled","handleErrors","Number","isInteger","statusText","getInfluxTime","until","date","roundUp","parts","exec","amount","parseInt","unit"],"sources":["/home/soula/grafana/public/app/plugins/datasource/influxdb/datasource.ts"],"sourcesContent":["import { cloneDeep, extend, get, groupBy, has, isString, map as _map, omit, pick, reduce } from 'lodash';\nimport { lastValueFrom, Observable, of, throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport {\n  AnnotationEvent,\n  ArrayVector,\n  DataFrame,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n  dateMath,\n  dateTime,\n  FieldType,\n  LoadingState,\n  MetricFindValue,\n  QueryResultMeta,\n  ScopedVars,\n  TIME_SERIES_TIME_FIELD_NAME,\n  TIME_SERIES_VALUE_FIELD_NAME,\n  TimeSeries,\n  AnnotationQueryRequest,\n} from '@grafana/data';\nimport {\n  BackendDataSourceResponse,\n  DataSourceWithBackend,\n  FetchResponse,\n  frameToMetricFindValue,\n  getBackendSrv,\n} from '@grafana/runtime';\nimport config from 'app/core/config';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\n\nimport { FluxQueryEditor } from './components/FluxQueryEditor';\nimport InfluxQueryModel from './influx_query_model';\nimport InfluxSeries from './influx_series';\nimport { buildRawQuery } from './queryUtils';\nimport { InfluxQueryBuilder } from './query_builder';\nimport ResponseParser from './response_parser';\nimport { InfluxOptions, InfluxQuery, InfluxVersion } from './types';\n\n// we detect the field type based on the value-array\nfunction getFieldType(values: unknown[]): FieldType {\n  // the values-array may contain a lot of nulls.\n  // we need the first not-null item\n  const firstNotNull = values.find((v) => v !== null);\n\n  if (firstNotNull === undefined) {\n    // we could not find any not-null values\n    return FieldType.number;\n  }\n\n  const valueType = typeof firstNotNull;\n\n  switch (valueType) {\n    case 'string':\n      return FieldType.string;\n    case 'boolean':\n      return FieldType.boolean;\n    case 'number':\n      return FieldType.number;\n    default:\n      // this should never happen, influxql values\n      // can only be numbers, strings and booleans.\n      throw new Error(`InfluxQL: invalid value type ${valueType}`);\n  }\n}\n\n// this conversion function is specialized to work with the timeseries\n// data returned by InfluxDatasource.getTimeSeries()\nfunction timeSeriesToDataFrame(timeSeries: TimeSeries): DataFrame {\n  const times: number[] = [];\n  const values: unknown[] = [];\n\n  // the data we process here is not correctly typed.\n  // the typescript types say every data-point is number|null,\n  // but in fact it can be string or boolean too.\n\n  const points = timeSeries.datapoints;\n  for (const point of points) {\n    values.push(point[0]);\n    times.push(point[1] as number);\n  }\n\n  const timeField = {\n    name: TIME_SERIES_TIME_FIELD_NAME,\n    type: FieldType.time,\n    config: {},\n    values: new ArrayVector<number>(times),\n  };\n\n  const valueField = {\n    name: TIME_SERIES_VALUE_FIELD_NAME,\n    type: getFieldType(values),\n    config: {\n      displayNameFromDS: timeSeries.title,\n    },\n    values: new ArrayVector<unknown>(values),\n    labels: timeSeries.tags,\n  };\n\n  const fields = [timeField, valueField];\n\n  return {\n    name: timeSeries.target,\n    refId: timeSeries.refId,\n    meta: timeSeries.meta,\n    fields,\n    length: values.length,\n  };\n}\n\nexport default class InfluxDatasource extends DataSourceWithBackend<InfluxQuery, InfluxOptions> {\n  type: string;\n  urls: string[];\n  username: string;\n  password: string;\n  name: string;\n  database: any;\n  basicAuth: any;\n  withCredentials: any;\n  access: 'direct' | 'proxy';\n  interval: any;\n  responseParser: any;\n  httpMode: string;\n  isFlux: boolean;\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<InfluxOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv()\n  ) {\n    super(instanceSettings);\n\n    this.type = 'influxdb';\n    this.urls = (instanceSettings.url ?? '').split(',').map((url) => {\n      return url.trim();\n    });\n\n    this.username = instanceSettings.username ?? '';\n    this.password = instanceSettings.password ?? '';\n    this.name = instanceSettings.name;\n    this.database = instanceSettings.database;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.access = instanceSettings.access;\n    const settingsData = instanceSettings.jsonData || ({} as InfluxOptions);\n    this.interval = settingsData.timeInterval;\n    this.httpMode = settingsData.httpMode || 'GET';\n    this.responseParser = new ResponseParser();\n    this.isFlux = settingsData.version === InfluxVersion.Flux;\n\n    if (this.isFlux) {\n      // When flux, use an annotation processor rather than the `annotationQuery` lifecycle\n      this.annotations = {\n        QueryEditor: FluxQueryEditor,\n      };\n    }\n  }\n\n  query(request: DataQueryRequest<InfluxQuery>): Observable<DataQueryResponse> {\n    // for not-flux queries we call `this.classicQuery`, and that\n    // handles the is-hidden situation.\n    // for the flux-case, we do the filtering here\n    const filteredRequest = {\n      ...request,\n      targets: request.targets.filter((t) => t.hide !== true),\n    };\n\n    if (this.isFlux) {\n      return super.query(filteredRequest);\n    }\n\n    if (this.isMigrationToggleOnAndIsAccessProxy()) {\n      return super.query(filteredRequest).pipe(\n        map((res) => {\n          if (res.error) {\n            throw {\n              message: 'InfluxDB Error: ' + res.error.message,\n              res,\n            };\n          }\n\n          const seriesList: any[] = [];\n\n          const groupedFrames = groupBy(res.data, (x) => x.refId);\n          if (Object.keys(groupedFrames).length > 0) {\n            filteredRequest.targets.forEach((target) => {\n              const filteredFrames = groupedFrames[target.refId] ?? [];\n              switch (target.resultFormat) {\n                case 'logs':\n                case 'table':\n                  seriesList.push(\n                    this.responseParser.getTable(filteredFrames, target, {\n                      preferredVisualisationType: target.resultFormat,\n                    })\n                  );\n                  break;\n                default: {\n                  for (let i = 0; i < filteredFrames.length; i++) {\n                    seriesList.push(filteredFrames[i]);\n                  }\n                  break;\n                }\n              }\n            });\n          }\n\n          return { data: seriesList };\n        })\n      );\n    }\n\n    // Fallback to classic query support\n    return this.classicQuery(request);\n  }\n\n  getQueryDisplayText(query: InfluxQuery) {\n    if (this.isFlux) {\n      return query.query;\n    }\n    return new InfluxQueryModel(query).render(false);\n  }\n\n  /**\n   * Returns false if the query should be skipped\n   */\n  filterQuery(query: InfluxQuery): boolean {\n    if (this.isFlux) {\n      return !!query.query;\n    }\n    return true;\n  }\n\n  applyTemplateVariables(query: InfluxQuery, scopedVars: ScopedVars): Record<string, any> {\n    // We want to interpolate these variables on backend\n    const { __interval, __interval_ms, ...rest } = scopedVars;\n\n    if (this.isFlux) {\n      return {\n        ...query,\n        query: this.templateSrv.replace(query.query ?? '', rest), // The raw query text\n      };\n    }\n\n    if (config.featureToggles.influxdbBackendMigration && this.access === 'proxy') {\n      query = this.applyVariables(query, scopedVars, rest);\n    }\n\n    return query;\n  }\n\n  /**\n   * The unchanged pre 7.1 query implementation\n   */\n  classicQuery(options: any): Observable<DataQueryResponse> {\n    let timeFilter = this.getTimeFilter(options);\n    const scopedVars = options.scopedVars;\n    const targets = cloneDeep(options.targets);\n    const queryTargets: any[] = [];\n\n    let i, y;\n\n    let allQueries = _map(targets, (target) => {\n      if (target.hide) {\n        return '';\n      }\n\n      queryTargets.push(target);\n\n      // backward compatibility\n      scopedVars.interval = scopedVars.__interval;\n\n      return new InfluxQueryModel(target, this.templateSrv, scopedVars).render(true);\n    }).reduce((acc, current) => {\n      if (current !== '') {\n        acc += ';' + current;\n      }\n      return acc;\n    });\n\n    if (allQueries === '') {\n      return of({ data: [] });\n    }\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    if (adhocFilters.length > 0) {\n      const tmpQuery = new InfluxQueryModel({ refId: 'A' }, this.templateSrv, scopedVars);\n      timeFilter += ' AND ' + tmpQuery.renderAdhocFilters(adhocFilters);\n    }\n\n    // replace grafana variables\n    scopedVars.timeFilter = { value: timeFilter };\n\n    // replace templated variables\n    allQueries = this.templateSrv.replace(allQueries, scopedVars);\n\n    return this._seriesQuery(allQueries, options).pipe(\n      map((data: any) => {\n        if (!data || !data.results) {\n          return { data: [] };\n        }\n\n        const seriesList = [];\n        for (i = 0; i < data.results.length; i++) {\n          const result = data.results[i];\n          if (!result || !result.series) {\n            continue;\n          }\n\n          const target = queryTargets[i];\n          let alias = target.alias;\n          if (alias) {\n            alias = this.templateSrv.replace(target.alias, options.scopedVars);\n          }\n\n          const meta: QueryResultMeta = {\n            executedQueryString: data.executedQueryString,\n          };\n\n          const influxSeries = new InfluxSeries({\n            refId: target.refId,\n            series: data.results[i].series,\n            alias: alias,\n            meta,\n          });\n\n          switch (target.resultFormat) {\n            case 'logs':\n              meta.preferredVisualisationType = 'logs';\n            case 'table': {\n              seriesList.push(influxSeries.getTable());\n              break;\n            }\n            default: {\n              const timeSeries = influxSeries.getTimeSeries();\n              for (y = 0; y < timeSeries.length; y++) {\n                seriesList.push(timeSeriesToDataFrame(timeSeries[y]));\n              }\n              break;\n            }\n          }\n        }\n\n        return { data: seriesList };\n      })\n    );\n  }\n\n  async annotationQuery(options: AnnotationQueryRequest<any>): Promise<AnnotationEvent[]> {\n    if (this.isFlux) {\n      return Promise.reject({\n        message: 'Flux requires the standard annotation query',\n      });\n    }\n\n    // InfluxQL puts a query string on the annotation\n    if (!options.annotation.query) {\n      return Promise.reject({\n        message: 'Query missing in annotation definition',\n      });\n    }\n\n    if (config.featureToggles.influxdbBackendMigration && this.access === 'proxy') {\n      // We want to send our query to the backend as a raw query\n      const target: InfluxQuery = {\n        refId: 'metricFindQuery',\n        datasource: this.getRef(),\n        query: this.templateSrv.replace(options.annotation.query ?? ''),\n        rawQuery: true,\n      };\n\n      return lastValueFrom(\n        getBackendSrv()\n          .fetch<BackendDataSourceResponse>({\n            url: '/api/ds/query',\n            method: 'POST',\n            data: {\n              from: options.range.from.valueOf().toString(),\n              to: options.range.to.valueOf().toString(),\n              queries: [target],\n            },\n            requestId: options.annotation.name,\n          })\n          .pipe(\n            map(\n              async (res: FetchResponse<BackendDataSourceResponse>) =>\n                await this.responseParser.transformAnnotationResponse(options, res, target)\n            )\n          )\n      );\n    }\n\n    const timeFilter = this.getTimeFilter({ rangeRaw: options.rangeRaw, timezone: options.dashboard.timezone });\n    let query = options.annotation.query.replace('$timeFilter', timeFilter);\n    query = this.templateSrv.replace(query, undefined, 'regex');\n\n    return lastValueFrom(this._seriesQuery(query, options)).then((data: any) => {\n      if (!data || !data.results || !data.results[0]) {\n        throw { message: 'No results in response from InfluxDB' };\n      }\n      return new InfluxSeries({\n        series: data.results[0].series,\n        annotation: options.annotation,\n      }).getAnnotations();\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    // for flux-mode we just take target.query,\n    // for influxql-mode we use InfluxQueryModel to create the text-representation\n    const queryText = this.isFlux ? target.query : buildRawQuery(target);\n\n    return this.templateSrv.containsTemplate(queryText);\n  }\n\n  interpolateVariablesInQueries(queries: InfluxQuery[], scopedVars: ScopedVars): InfluxQuery[] {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    return queries.map((query) => {\n      if (this.isFlux) {\n        return {\n          ...query,\n          datasource: this.getRef(),\n          query: this.templateSrv.replace(query.query ?? '', scopedVars), // The raw query text\n        };\n      }\n\n      return {\n        ...query,\n        datasource: this.getRef(),\n        ...this.applyVariables(query, scopedVars, scopedVars),\n      };\n    });\n  }\n\n  applyVariables(query: InfluxQuery, scopedVars: ScopedVars, rest: ScopedVars) {\n    const expandedQuery = { ...query };\n    if (query.groupBy) {\n      expandedQuery.groupBy = query.groupBy.map((groupBy) => {\n        return {\n          ...groupBy,\n          params: groupBy.params?.map((param) => {\n            return this.templateSrv.replace(param.toString(), undefined, 'regex');\n          }),\n        };\n      });\n    }\n\n    if (query.select) {\n      expandedQuery.select = query.select.map((selects) => {\n        return selects.map((select: any) => {\n          return {\n            ...select,\n            params: select.params?.map((param: any) => {\n              return this.templateSrv.replace(param.toString(), undefined, 'regex');\n            }),\n          };\n        });\n      });\n    }\n\n    if (query.tags) {\n      expandedQuery.tags = query.tags.map((tag) => {\n        return {\n          ...tag,\n          value: this.templateSrv.replace(tag.value, undefined, 'regex'),\n        };\n      });\n    }\n\n    return {\n      ...expandedQuery,\n      query: this.templateSrv.replace(query.query ?? '', rest), // The raw query text\n      alias: this.templateSrv.replace(query.alias ?? '', scopedVars),\n      limit: this.templateSrv.replace(query.limit?.toString() ?? '', scopedVars, 'regex'),\n      measurement: this.templateSrv.replace(query.measurement ?? '', scopedVars, 'regex'),\n      policy: this.templateSrv.replace(query.policy ?? '', scopedVars, 'regex'),\n      slimit: this.templateSrv.replace(query.slimit?.toString() ?? '', scopedVars, 'regex'),\n      tz: this.templateSrv.replace(query.tz ?? '', scopedVars),\n    };\n  }\n\n  async metricFindQuery(query: string, options?: any): Promise<MetricFindValue[]> {\n    if (this.isFlux || this.isMigrationToggleOnAndIsAccessProxy()) {\n      const target: InfluxQuery = {\n        refId: 'metricFindQuery',\n        query,\n        rawQuery: true,\n      };\n      return lastValueFrom(\n        super.query({\n          ...options, // includes 'range'\n          targets: [target],\n        } as DataQueryRequest)\n      ).then((rsp) => {\n        if (rsp.data?.length) {\n          return frameToMetricFindValue(rsp.data[0]);\n        }\n        return [];\n      });\n    }\n\n    const interpolated = this.templateSrv.replace(query, undefined, 'regex');\n\n    return lastValueFrom(this._seriesQuery(interpolated, options)).then((resp) => {\n      return this.responseParser.parse(query, resp);\n    });\n  }\n\n  getTagKeys(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_KEYS');\n    return this.metricFindQuery(query, options);\n  }\n\n  getTagValues(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);\n    return this.metricFindQuery(query, options);\n  }\n\n  _seriesQuery(query: string, options?: any) {\n    if (!query) {\n      return of({ results: [] });\n    }\n\n    if (options && options.range) {\n      const timeFilter = this.getTimeFilter({ rangeRaw: options.range, timezone: options.timezone });\n      query = query.replace('$timeFilter', timeFilter);\n    }\n\n    return this._influxRequest(this.httpMode, '/query', { q: query, epoch: 'ms' }, options);\n  }\n\n  serializeParams(params: any) {\n    if (!params) {\n      return '';\n    }\n\n    return reduce(\n      params,\n      (memo, value, key) => {\n        if (value === null || value === undefined) {\n          return memo;\n        }\n        memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        return memo;\n      },\n      [] as string[]\n    ).join('&');\n  }\n\n  testDatasource() {\n    if (this.isFlux) {\n      // TODO: eventually use the real /health endpoint\n      const request: DataQueryRequest<InfluxQuery> = {\n        targets: [{ refId: 'test', query: 'buckets()' }],\n        requestId: `${this.id}-health-${uuidv4()}`,\n        dashboardId: 0,\n        panelId: 0,\n        interval: '1m',\n        intervalMs: 60000,\n        maxDataPoints: 423,\n        range: {\n          from: dateTime(1000),\n          to: dateTime(2000),\n        },\n      } as DataQueryRequest<InfluxQuery>;\n\n      return lastValueFrom(super.query(request))\n        .then((res: DataQueryResponse) => {\n          if (!res || !res.data || res.state !== LoadingState.Done) {\n            console.error('InfluxDB Error', res);\n            return { status: 'error', message: 'Error reading InfluxDB' };\n          }\n          const first = res.data[0];\n          if (first && first.length) {\n            return { status: 'success', message: `${first.length} buckets found` };\n          }\n          console.error('InfluxDB Error', res);\n          return { status: 'error', message: 'Error reading buckets' };\n        })\n        .catch((err: any) => {\n          console.error('InfluxDB Error', err);\n          return { status: 'error', message: err.message };\n        });\n    }\n\n    if (this.isMigrationToggleOnAndIsAccessProxy()) {\n      const target: InfluxQuery = {\n        refId: 'metricFindQuery',\n        query: 'SHOW TAG KEYS',\n        rawQuery: true,\n      };\n      return lastValueFrom(super.query({ targets: [target] } as DataQueryRequest))\n        .then((res: DataQueryResponse) => {\n          if (!res || !res.data || res.state !== LoadingState.Done) {\n            return {\n              status: 'error',\n              message: 'Error reading InfluxDB.',\n            };\n          }\n          if (res.data?.length) {\n            return { status: 'success', message: 'Data source is working.' };\n          }\n          return {\n            status: 'error',\n            message: 'Successfully connected to InfluxDB, but no tags found.',\n          };\n        })\n        .catch((err: any) => {\n          return { status: 'error', message: err.message };\n        });\n    }\n\n    const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('RETENTION POLICIES');\n\n    return lastValueFrom(this._seriesQuery(query))\n      .then((res: any) => {\n        const error = get(res, 'results[0].error');\n        if (error) {\n          return { status: 'error', message: error };\n        }\n        return { status: 'success', message: 'Data source is working' };\n      })\n      .catch((err: any) => {\n        return { status: 'error', message: err.message };\n      });\n  }\n\n  _influxRequest(method: string, url: string, data: any, options?: any) {\n    const currentUrl = this.urls.shift()!;\n    this.urls.push(currentUrl);\n\n    const params: any = {};\n\n    if (this.username) {\n      params.u = this.username;\n      params.p = this.password;\n    }\n\n    if (options && options.database) {\n      params.db = options.database;\n    } else if (this.database) {\n      params.db = this.database;\n    }\n\n    const { q } = data;\n\n    if (method === 'POST' && has(data, 'q')) {\n      // verb is POST and 'q' param is defined\n      extend(params, omit(data, ['q']));\n      data = this.serializeParams(pick(data, ['q']));\n    } else if (method === 'GET' || method === 'POST') {\n      // verb is GET, or POST without 'q' param\n      extend(params, data);\n      data = null;\n    }\n\n    const req: any = {\n      method: method,\n      url: currentUrl + url,\n      params: params,\n      data: data,\n      precision: 'ms',\n      inspect: { type: 'influxdb' },\n      paramSerializer: this.serializeParams,\n    };\n\n    req.headers = req.headers || {};\n    if (this.basicAuth || this.withCredentials) {\n      req.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      req.headers.Authorization = this.basicAuth;\n    }\n\n    if (method === 'POST') {\n      req.headers['Content-type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return getBackendSrv()\n      .fetch(req)\n      .pipe(\n        map((result: any) => {\n          const { data } = result;\n          if (data) {\n            data.executedQueryString = q;\n            if (data.results) {\n              const errors = result.data.results.filter((elem: any) => elem.error);\n\n              if (errors.length > 0) {\n                throw {\n                  message: 'InfluxDB Error: ' + errors[0].error,\n                  data,\n                };\n              }\n            }\n          }\n          return data;\n        }),\n        catchError((err) => {\n          if (err.cancelled) {\n            return of(err);\n          }\n\n          return throwError(this.handleErrors(err));\n        })\n      );\n  }\n\n  handleErrors(err: any) {\n    const error: DataQueryError = {\n      message:\n        (err && err.status) ||\n        (err && err.message) ||\n        'Unknown error during query transaction. Please check JS console logs.',\n    };\n\n    if ((Number.isInteger(err.status) && err.status !== 0) || err.status >= 300) {\n      if (err.data && err.data.error) {\n        error.message = 'InfluxDB Error: ' + err.data.error;\n        error.data = err.data;\n        // @ts-ignore\n        error.config = err.config;\n      } else {\n        error.message = 'Network Error: ' + err.statusText + '(' + err.status + ')';\n        error.data = err.data;\n        // @ts-ignore\n        error.config = err.config;\n      }\n    }\n\n    return error;\n  }\n\n  getTimeFilter(options: any) {\n    const from = this.getInfluxTime(options.rangeRaw.from, false, options.timezone);\n    const until = this.getInfluxTime(options.rangeRaw.to, true, options.timezone);\n\n    return 'time >= ' + from + ' and time <= ' + until;\n  }\n\n  getInfluxTime(date: any, roundUp: any, timezone: any) {\n    if (isString(date)) {\n      if (date === 'now') {\n        return 'now()';\n      }\n\n      const parts = /^now-(\\d+)([dhms])$/.exec(date);\n      if (parts) {\n        const amount = parseInt(parts[1], 10);\n        const unit = parts[2];\n        return 'now() - ' + amount + unit;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    return date.valueOf() + 'ms';\n  }\n\n  isMigrationToggleOnAndIsAccessProxy() {\n    return config.featureToggles.influxdbBackendMigration && this.access === 'proxy';\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}