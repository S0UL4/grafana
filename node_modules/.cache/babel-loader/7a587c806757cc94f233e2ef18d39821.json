{"ast":null,"code":"import { size } from 'lodash';\n\n/**\n * Number of time series results needed before starting to suggest sum aggregation hints\n */\nexport const SUM_HINT_THRESHOLD_COUNT = 20;\nexport function getQueryHints(query, series, datasource) {\n  const hints = []; // ..._bucket metric needs a histogram_quantile()\n\n  const histogramMetric = query.trim().match(/^\\w+_bucket$|^\\w+_bucket{.*}$/);\n\n  if (histogramMetric) {\n    const label = 'Selected metric has buckets.';\n    hints.push({\n      type: 'HISTOGRAM_QUANTILE',\n      label,\n      fix: {\n        label: 'Consider calculating aggregated quantile by adding histogram_quantile().',\n        action: {\n          type: 'ADD_HISTOGRAM_QUANTILE',\n          query\n        }\n      }\n    });\n  } // Check for need of rate()\n\n\n  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {\n    var _datasource$languageP, _datasource$languageP2;\n\n    // Use metric metadata for exact types\n    const nameMatch = query.match(/\\b(\\w+_(total|sum|count))\\b/);\n    let counterNameMetric = nameMatch ? nameMatch[1] : '';\n    const metricsMetadata = (_datasource$languageP = datasource === null || datasource === void 0 ? void 0 : (_datasource$languageP2 = datasource.languageProvider) === null || _datasource$languageP2 === void 0 ? void 0 : _datasource$languageP2.metricsMetadata) !== null && _datasource$languageP !== void 0 ? _datasource$languageP : {};\n    const metricMetadataKeys = Object.keys(metricsMetadata);\n    let certain = false;\n\n    if (metricMetadataKeys.length > 0) {\n      var _metricMetadataKeys$f;\n\n      counterNameMetric = (_metricMetadataKeys$f = metricMetadataKeys.find(metricName => {\n        // Only considering first type information, could be non-deterministic\n        const metadata = metricsMetadata[metricName];\n\n        if (metadata.type.toLowerCase() === 'counter') {\n          const metricRegex = new RegExp(`\\\\b${metricName}\\\\b`);\n\n          if (query.match(metricRegex)) {\n            certain = true;\n            return true;\n          }\n        }\n\n        return false;\n      })) !== null && _metricMetadataKeys$f !== void 0 ? _metricMetadataKeys$f : '';\n    }\n\n    if (counterNameMetric) {\n      // FixableQuery consists of metric name and optionally label-value pairs. We are not offering fix for complex queries yet.\n      const fixableQuery = query.trim().match(/^\\w+$|^\\w+{.*}$/);\n      const verb = certain ? 'is' : 'looks like';\n      let label = `Selected metric ${verb} a counter.`;\n      let fix;\n\n      if (fixableQuery) {\n        fix = {\n          label: 'Consider calculating rate of counter by adding rate().',\n          action: {\n            type: 'ADD_RATE',\n            query\n          }\n        };\n      } else {\n        label = `${label} Consider calculating rate of counter by adding rate().`;\n      }\n\n      hints.push({\n        type: 'APPLY_RATE',\n        label,\n        fix\n      });\n    }\n  } // Check for recording rules expansion\n\n\n  if (datasource && datasource.ruleMappings) {\n    const mapping = datasource.ruleMappings;\n    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {\n      if (query.search(ruleName) > -1) {\n        return Object.assign({}, acc, {\n          [ruleName]: mapping[ruleName]\n        });\n      }\n\n      return acc;\n    }, {});\n\n    if (size(mappingForQuery) > 0) {\n      const label = 'Query contains recording rules.';\n      hints.push({\n        type: 'EXPAND_RULES',\n        label,\n        fix: {\n          label: 'Expand rules',\n          action: {\n            type: 'EXPAND_RULES',\n            query,\n            mapping: mappingForQuery\n          }\n        }\n      });\n    }\n  }\n\n  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {\n    const simpleMetric = query.trim().match(/^\\w+$/);\n\n    if (simpleMetric) {\n      hints.push({\n        type: 'ADD_SUM',\n        label: 'Many time series results returned.',\n        fix: {\n          label: 'Consider aggregating with sum().',\n          action: {\n            type: 'ADD_SUM',\n            query: query,\n            preventSubmit: true\n          }\n        }\n      });\n    }\n  }\n\n  return hints;\n}\nexport function getInitHints(datasource) {\n  const hints = []; // Hint if using Loki as Prometheus data source\n\n  if (datasource.directUrl.includes('/loki') && !datasource.languageProvider.metrics.length) {\n    hints.push({\n      label: `Using Loki as a Prometheus data source is no longer supported. You must use the Loki data source for your Loki instance.`,\n      type: 'INFO'\n    });\n  } // Hint for big disabled lookups\n\n\n  if (datasource.lookupsDisabled) {\n    hints.push({\n      label: `Labels and metrics lookup was disabled in data source settings.`,\n      type: 'INFO'\n    });\n  }\n\n  return hints;\n}","map":{"version":3,"names":["size","SUM_HINT_THRESHOLD_COUNT","getQueryHints","query","series","datasource","hints","histogramMetric","trim","match","label","push","type","fix","action","indexOf","nameMatch","counterNameMetric","metricsMetadata","languageProvider","metricMetadataKeys","Object","keys","certain","length","find","metricName","metadata","toLowerCase","metricRegex","RegExp","fixableQuery","verb","ruleMappings","mapping","mappingForQuery","reduce","acc","ruleName","search","simpleMetric","preventSubmit","getInitHints","directUrl","includes","metrics","lookupsDisabled"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/query_hints.ts"],"sourcesContent":["import { size } from 'lodash';\n\nimport { QueryHint, QueryFix } from '@grafana/data';\n\nimport { PrometheusDatasource } from './datasource';\n\n/**\n * Number of time series results needed before starting to suggest sum aggregation hints\n */\nexport const SUM_HINT_THRESHOLD_COUNT = 20;\n\nexport function getQueryHints(query: string, series?: any[], datasource?: PrometheusDatasource): QueryHint[] {\n  const hints = [];\n\n  // ..._bucket metric needs a histogram_quantile()\n  const histogramMetric = query.trim().match(/^\\w+_bucket$|^\\w+_bucket{.*}$/);\n  if (histogramMetric) {\n    const label = 'Selected metric has buckets.';\n    hints.push({\n      type: 'HISTOGRAM_QUANTILE',\n      label,\n      fix: {\n        label: 'Consider calculating aggregated quantile by adding histogram_quantile().',\n        action: {\n          type: 'ADD_HISTOGRAM_QUANTILE',\n          query,\n        },\n      } as QueryFix,\n    });\n  }\n\n  // Check for need of rate()\n  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {\n    // Use metric metadata for exact types\n    const nameMatch = query.match(/\\b(\\w+_(total|sum|count))\\b/);\n    let counterNameMetric = nameMatch ? nameMatch[1] : '';\n    const metricsMetadata = datasource?.languageProvider?.metricsMetadata ?? {};\n    const metricMetadataKeys = Object.keys(metricsMetadata);\n    let certain = false;\n\n    if (metricMetadataKeys.length > 0) {\n      counterNameMetric =\n        metricMetadataKeys.find((metricName) => {\n          // Only considering first type information, could be non-deterministic\n          const metadata = metricsMetadata[metricName];\n          if (metadata.type.toLowerCase() === 'counter') {\n            const metricRegex = new RegExp(`\\\\b${metricName}\\\\b`);\n            if (query.match(metricRegex)) {\n              certain = true;\n              return true;\n            }\n          }\n          return false;\n        }) ?? '';\n    }\n\n    if (counterNameMetric) {\n      // FixableQuery consists of metric name and optionally label-value pairs. We are not offering fix for complex queries yet.\n      const fixableQuery = query.trim().match(/^\\w+$|^\\w+{.*}$/);\n      const verb = certain ? 'is' : 'looks like';\n      let label = `Selected metric ${verb} a counter.`;\n      let fix: QueryFix | undefined;\n\n      if (fixableQuery) {\n        fix = {\n          label: 'Consider calculating rate of counter by adding rate().',\n          action: {\n            type: 'ADD_RATE',\n            query,\n          },\n        };\n      } else {\n        label = `${label} Consider calculating rate of counter by adding rate().`;\n      }\n\n      hints.push({\n        type: 'APPLY_RATE',\n        label,\n        fix,\n      });\n    }\n  }\n\n  // Check for recording rules expansion\n  if (datasource && datasource.ruleMappings) {\n    const mapping = datasource.ruleMappings;\n    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {\n      if (query.search(ruleName) > -1) {\n        return {\n          ...acc,\n          [ruleName]: mapping[ruleName],\n        };\n      }\n      return acc;\n    }, {});\n    if (size(mappingForQuery) > 0) {\n      const label = 'Query contains recording rules.';\n      hints.push({\n        type: 'EXPAND_RULES',\n        label,\n        fix: {\n          label: 'Expand rules',\n          action: {\n            type: 'EXPAND_RULES',\n            query,\n            mapping: mappingForQuery,\n          },\n        } as any as QueryFix,\n      });\n    }\n  }\n\n  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {\n    const simpleMetric = query.trim().match(/^\\w+$/);\n    if (simpleMetric) {\n      hints.push({\n        type: 'ADD_SUM',\n        label: 'Many time series results returned.',\n        fix: {\n          label: 'Consider aggregating with sum().',\n          action: {\n            type: 'ADD_SUM',\n            query: query,\n            preventSubmit: true,\n          },\n        } as QueryFix,\n      });\n    }\n  }\n\n  return hints;\n}\n\nexport function getInitHints(datasource: PrometheusDatasource): QueryHint[] {\n  const hints = [];\n  // Hint if using Loki as Prometheus data source\n  if (datasource.directUrl.includes('/loki') && !datasource.languageProvider.metrics.length) {\n    hints.push({\n      label: `Using Loki as a Prometheus data source is no longer supported. You must use the Loki data source for your Loki instance.`,\n      type: 'INFO',\n    });\n  }\n\n  // Hint for big disabled lookups\n  if (datasource.lookupsDisabled) {\n    hints.push({\n      label: `Labels and metrics lookup was disabled in data source settings.`,\n      type: 'INFO',\n    });\n  }\n\n  return hints;\n}\n"],"mappings":"AAAA,SAASA,IAAT,QAAqB,QAArB;;AAMA;AACA;AACA;AACA,OAAO,MAAMC,wBAAwB,GAAG,EAAjC;AAEP,OAAO,SAASC,aAAT,CAAuBC,KAAvB,EAAsCC,MAAtC,EAAsDC,UAAtD,EAAsG;EAC3G,MAAMC,KAAK,GAAG,EAAd,CAD2G,CAG3G;;EACA,MAAMC,eAAe,GAAGJ,KAAK,CAACK,IAAN,GAAaC,KAAb,CAAmB,+BAAnB,CAAxB;;EACA,IAAIF,eAAJ,EAAqB;IACnB,MAAMG,KAAK,GAAG,8BAAd;IACAJ,KAAK,CAACK,IAAN,CAAW;MACTC,IAAI,EAAE,oBADG;MAETF,KAFS;MAGTG,GAAG,EAAE;QACHH,KAAK,EAAE,0EADJ;QAEHI,MAAM,EAAE;UACNF,IAAI,EAAE,wBADA;UAENT;QAFM;MAFL;IAHI,CAAX;EAWD,CAlB0G,CAoB3G;;;EACA,IAAIA,KAAK,CAACY,OAAN,CAAc,OAAd,MAA2B,CAAC,CAA5B,IAAiCZ,KAAK,CAACY,OAAN,CAAc,WAAd,MAA+B,CAAC,CAArE,EAAwE;IAAA;;IACtE;IACA,MAAMC,SAAS,GAAGb,KAAK,CAACM,KAAN,CAAY,6BAAZ,CAAlB;IACA,IAAIQ,iBAAiB,GAAGD,SAAS,GAAGA,SAAS,CAAC,CAAD,CAAZ,GAAkB,EAAnD;IACA,MAAME,eAAe,4BAAGb,UAAH,aAAGA,UAAH,iDAAGA,UAAU,CAAEc,gBAAf,2DAAG,uBAA8BD,eAAjC,yEAAoD,EAAzE;IACA,MAAME,kBAAkB,GAAGC,MAAM,CAACC,IAAP,CAAYJ,eAAZ,CAA3B;IACA,IAAIK,OAAO,GAAG,KAAd;;IAEA,IAAIH,kBAAkB,CAACI,MAAnB,GAA4B,CAAhC,EAAmC;MAAA;;MACjCP,iBAAiB,4BACfG,kBAAkB,CAACK,IAAnB,CAAyBC,UAAD,IAAgB;QACtC;QACA,MAAMC,QAAQ,GAAGT,eAAe,CAACQ,UAAD,CAAhC;;QACA,IAAIC,QAAQ,CAACf,IAAT,CAAcgB,WAAd,OAAgC,SAApC,EAA+C;UAC7C,MAAMC,WAAW,GAAG,IAAIC,MAAJ,CAAY,MAAKJ,UAAW,KAA5B,CAApB;;UACA,IAAIvB,KAAK,CAACM,KAAN,CAAYoB,WAAZ,CAAJ,EAA8B;YAC5BN,OAAO,GAAG,IAAV;YACA,OAAO,IAAP;UACD;QACF;;QACD,OAAO,KAAP;MACD,CAXD,CADe,yEAYT,EAZR;IAaD;;IAED,IAAIN,iBAAJ,EAAuB;MACrB;MACA,MAAMc,YAAY,GAAG5B,KAAK,CAACK,IAAN,GAAaC,KAAb,CAAmB,iBAAnB,CAArB;MACA,MAAMuB,IAAI,GAAGT,OAAO,GAAG,IAAH,GAAU,YAA9B;MACA,IAAIb,KAAK,GAAI,mBAAkBsB,IAAK,aAApC;MACA,IAAInB,GAAJ;;MAEA,IAAIkB,YAAJ,EAAkB;QAChBlB,GAAG,GAAG;UACJH,KAAK,EAAE,wDADH;UAEJI,MAAM,EAAE;YACNF,IAAI,EAAE,UADA;YAENT;UAFM;QAFJ,CAAN;MAOD,CARD,MAQO;QACLO,KAAK,GAAI,GAAEA,KAAM,yDAAjB;MACD;;MAEDJ,KAAK,CAACK,IAAN,CAAW;QACTC,IAAI,EAAE,YADG;QAETF,KAFS;QAGTG;MAHS,CAAX;IAKD;EACF,CAtE0G,CAwE3G;;;EACA,IAAIR,UAAU,IAAIA,UAAU,CAAC4B,YAA7B,EAA2C;IACzC,MAAMC,OAAO,GAAG7B,UAAU,CAAC4B,YAA3B;IACA,MAAME,eAAe,GAAGd,MAAM,CAACC,IAAP,CAAYY,OAAZ,EAAqBE,MAArB,CAA4B,CAACC,GAAD,EAAMC,QAAN,KAAmB;MACrE,IAAInC,KAAK,CAACoC,MAAN,CAAaD,QAAb,IAAyB,CAAC,CAA9B,EAAiC;QAC/B,yBACKD,GADL;UAEE,CAACC,QAAD,GAAYJ,OAAO,CAACI,QAAD;QAFrB;MAID;;MACD,OAAOD,GAAP;IACD,CARuB,EAQrB,EARqB,CAAxB;;IASA,IAAIrC,IAAI,CAACmC,eAAD,CAAJ,GAAwB,CAA5B,EAA+B;MAC7B,MAAMzB,KAAK,GAAG,iCAAd;MACAJ,KAAK,CAACK,IAAN,CAAW;QACTC,IAAI,EAAE,cADG;QAETF,KAFS;QAGTG,GAAG,EAAE;UACHH,KAAK,EAAE,cADJ;UAEHI,MAAM,EAAE;YACNF,IAAI,EAAE,cADA;YAENT,KAFM;YAGN+B,OAAO,EAAEC;UAHH;QAFL;MAHI,CAAX;IAYD;EACF;;EAED,IAAI/B,MAAM,IAAIA,MAAM,CAACoB,MAAP,IAAiBvB,wBAA/B,EAAyD;IACvD,MAAMuC,YAAY,GAAGrC,KAAK,CAACK,IAAN,GAAaC,KAAb,CAAmB,OAAnB,CAArB;;IACA,IAAI+B,YAAJ,EAAkB;MAChBlC,KAAK,CAACK,IAAN,CAAW;QACTC,IAAI,EAAE,SADG;QAETF,KAAK,EAAE,oCAFE;QAGTG,GAAG,EAAE;UACHH,KAAK,EAAE,kCADJ;UAEHI,MAAM,EAAE;YACNF,IAAI,EAAE,SADA;YAENT,KAAK,EAAEA,KAFD;YAGNsC,aAAa,EAAE;UAHT;QAFL;MAHI,CAAX;IAYD;EACF;;EAED,OAAOnC,KAAP;AACD;AAED,OAAO,SAASoC,YAAT,CAAsBrC,UAAtB,EAAqE;EAC1E,MAAMC,KAAK,GAAG,EAAd,CAD0E,CAE1E;;EACA,IAAID,UAAU,CAACsC,SAAX,CAAqBC,QAArB,CAA8B,OAA9B,KAA0C,CAACvC,UAAU,CAACc,gBAAX,CAA4B0B,OAA5B,CAAoCrB,MAAnF,EAA2F;IACzFlB,KAAK,CAACK,IAAN,CAAW;MACTD,KAAK,EAAG,0HADC;MAETE,IAAI,EAAE;IAFG,CAAX;EAID,CARyE,CAU1E;;;EACA,IAAIP,UAAU,CAACyC,eAAf,EAAgC;IAC9BxC,KAAK,CAACK,IAAN,CAAW;MACTD,KAAK,EAAG,iEADC;MAETE,IAAI,EAAE;IAFG,CAAX;EAID;;EAED,OAAON,KAAP;AACD"},"metadata":{},"sourceType":"module"}