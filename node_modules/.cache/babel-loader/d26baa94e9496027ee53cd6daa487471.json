{"ast":null,"code":"import { DataHoverEvent, DataHoverClearEvent, PluginState } from '@grafana/data';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport { Fill, Stroke, Style, Circle } from 'ol/style';\nimport { Group as LayerGroup } from 'ol/layer';\nimport Feature from 'ol/Feature';\nimport Point from 'ol/geom/Point';\nimport DayNight from 'ol-ext/source/DayNight';\nimport { fromLonLat } from 'ol/proj';\nimport { Subscription } from 'rxjs';\nimport { MultiLineString } from 'ol/geom';\nexport let ShowTime; // Configuration options for Circle overlays\n\n(function (ShowTime) {\n  ShowTime[\"From\"] = \"from\";\n  ShowTime[\"To\"] = \"to\";\n})(ShowTime || (ShowTime = {}));\n\nconst defaultConfig = {\n  show: ShowTime.To,\n  sun: false,\n  nightColor: '#a7a6ba4D'\n};\nexport const DAY_NIGHT_LAYER_ID = 'dayNight'; // Used by default when nothing is configured\n\nexport const defaultDayNightConfig = {\n  type: DAY_NIGHT_LAYER_ID,\n  name: '',\n  // will get replaced\n  config: defaultConfig,\n  tooltip: true\n};\n/**\n * Map layer configuration for circle overlay\n */\n\nexport const dayNightLayer = {\n  id: DAY_NIGHT_LAYER_ID,\n  name: 'Night / Day',\n  description: 'Show day and night regions',\n  isBaseMap: false,\n  state: PluginState.alpha,\n\n  /**\n   * Function that configures transformation and returns a transformer\n   * @param map\n   * @param options\n   * @param theme\n   */\n  create: async (map, options, eventBus, theme) => {\n    // Assert default values\n    const config = Object.assign({}, defaultConfig, options === null || options === void 0 ? void 0 : options.config); // DayNight source\n\n    const source = new DayNight({});\n    const sourceMethods = Object.getPrototypeOf(source);\n    const sourceLine = new DayNight({});\n    const sourceLineMethods = Object.getPrototypeOf(sourceLine); // Night polygon\n\n    const vectorLayer = new VectorLayer({\n      source,\n      style: new Style({\n        fill: new Fill({\n          color: theme.visualization.getColorByName(config.nightColor)\n        })\n      })\n    }); // Night line (for crosshair sharing)\n\n    const nightLineLayer = new VectorLayer({\n      source: new VectorSource({\n        features: []\n      }),\n      style: new Style({\n        stroke: new Stroke({\n          color: '#607D8B',\n          width: 1.5,\n          lineDash: [2, 3]\n        })\n      })\n    }); // Sun circle\n\n    const sunFeature = new Feature({\n      geometry: new Point([])\n    });\n    const sunLayer = new VectorLayer({\n      source: new VectorSource({\n        features: [sunFeature]\n      }),\n      style: new Style({\n        image: new Circle({\n          radius: 13,\n          fill: new Fill({\n            color: 'rgb(253,184,19)'\n          })\n        })\n      })\n    }); // Sun line (for crosshair sharing)\n\n    const sunLineFeature = new Feature({\n      geometry: new Point([])\n    });\n    const sunLineStyle = new Style({\n      image: new Circle({\n        radius: 13,\n        stroke: new Stroke({\n          color: 'rgb(253,184,19)',\n          width: 1.5\n        })\n      })\n    });\n    const sunLineStyleDash = new Style({\n      image: new Circle({\n        radius: 15,\n        stroke: new Stroke({\n          color: '#607D8B',\n          width: 1.5,\n          lineDash: [2, 3]\n        })\n      })\n    });\n    const sunLineLayer = new VectorLayer({\n      source: new VectorSource({\n        features: [sunLineFeature]\n      }),\n      style: [sunLineStyleDash, sunLineStyle]\n    }); // Build group of layers\n    // TODO: add blended night region to \"connect\" current night region to lines\n\n    const layer = new LayerGroup({\n      layers: config.sun ? [vectorLayer, sunLayer, sunLineLayer, nightLineLayer] : [vectorLayer, nightLineLayer]\n    }); // Crosshair sharing subscriptions\n\n    const subscriptions = new Subscription();\n\n    if (false) {\n      subscriptions.add(eventBus.subscribe(DataHoverEvent, event => {\n        var _event$payload, _event$payload$point;\n\n        const time = (_event$payload = event.payload) === null || _event$payload === void 0 ? void 0 : (_event$payload$point = _event$payload.point) === null || _event$payload$point === void 0 ? void 0 : _event$payload$point.time;\n\n        if (time) {\n          var _nightLineLayer$getSo, _nightLineLayer$getSo2, _sunLineFeature$getGe;\n\n          const lineTime = new Date(time);\n          const nightLinePoints = sourceLine.getCoordinates(lineTime.toString(), 'line');\n          (_nightLineLayer$getSo = nightLineLayer.getSource()) === null || _nightLineLayer$getSo === void 0 ? void 0 : _nightLineLayer$getSo.clear();\n          const lineStringArray = [];\n\n          for (let l = 0; l < nightLinePoints.length - 1; l++) {\n            const x1 = Object.values(nightLinePoints[l])[0];\n            const y1 = Object.values(nightLinePoints[l])[1];\n            const x2 = Object.values(nightLinePoints[l + 1])[0];\n            const y2 = Object.values(nightLinePoints[l + 1])[1];\n            const lineString = [fromLonLat([x1, y1]), fromLonLat([x2, y2])];\n            lineStringArray.push(lineString);\n          }\n\n          (_nightLineLayer$getSo2 = nightLineLayer.getSource()) === null || _nightLineLayer$getSo2 === void 0 ? void 0 : _nightLineLayer$getSo2.addFeature(new Feature({\n            geometry: new MultiLineString(lineStringArray)\n          }));\n          let sunLinePos = [];\n          sunLinePos = sourceLineMethods.getSunPosition(lineTime);\n          (_sunLineFeature$getGe = sunLineFeature.getGeometry()) === null || _sunLineFeature$getGe === void 0 ? void 0 : _sunLineFeature$getGe.setCoordinates(fromLonLat(sunLinePos));\n          sunLineFeature.setStyle([sunLineStyle, sunLineStyleDash]);\n        }\n      }));\n      subscriptions.add(eventBus.subscribe(DataHoverClearEvent, event => {\n        var _nightLineLayer$getSo3;\n\n        (_nightLineLayer$getSo3 = nightLineLayer.getSource()) === null || _nightLineLayer$getSo3 === void 0 ? void 0 : _nightLineLayer$getSo3.clear();\n        sunLineFeature.setStyle(new Style({}));\n      }));\n    }\n\n    return {\n      init: () => layer,\n      dispose: () => subscriptions.unsubscribe(),\n      update: data => {\n        const from = new Date(data.timeRange.from.valueOf());\n        const to = new Date(data.timeRange.to.valueOf());\n        let selectedTime = new Date();\n        let sunPos = []; // TODO: add option for \"Both\"\n\n        if (config.show === ShowTime.From) {\n          selectedTime = from;\n        } else {\n          selectedTime = to;\n        }\n\n        source.setTime(selectedTime);\n\n        if (config.sun) {\n          var _sunFeature$getGeomet;\n\n          sunPos = sourceMethods.getSunPosition(selectedTime);\n          (_sunFeature$getGeomet = sunFeature.getGeometry()) === null || _sunFeature$getGeomet === void 0 ? void 0 : _sunFeature$getGeomet.setCoordinates(fromLonLat(sunPos));\n        }\n      },\n      // Marker overlay options\n      registerOptionsUI: builder => {\n        var _options$config;\n\n        if (!((_options$config = options.config) !== null && _options$config !== void 0 && _options$config.nightColor)) {\n          options.config = Object.assign({}, defaultConfig, options.config);\n        }\n\n        builder.addRadio({\n          path: 'config.show',\n          name: 'Show',\n          settings: {\n            options: [{\n              label: 'From',\n              value: ShowTime.From\n            }, {\n              label: 'To',\n              value: ShowTime.To\n            }]\n          },\n          defaultValue: defaultConfig.show\n        });\n        builder.addColorPicker({\n          path: 'config.nightColor',\n          name: 'Night region color',\n          description: 'Pick color of night region',\n          defaultValue: defaultConfig.nightColor,\n          settings: [{\n            enableNamedColors: false\n          }]\n        });\n        builder.addBooleanSwitch({\n          path: 'config.sun',\n          name: 'Display sun',\n          description: 'Show the sun',\n          defaultValue: defaultConfig.sun\n        });\n      }\n    };\n  },\n  // fill in the default values\n  defaultOptions: defaultConfig\n};","map":{"version":3,"names":["DataHoverEvent","DataHoverClearEvent","PluginState","VectorLayer","VectorSource","Fill","Stroke","Style","Circle","Group","LayerGroup","Feature","Point","DayNight","fromLonLat","Subscription","MultiLineString","ShowTime","defaultConfig","show","To","sun","nightColor","DAY_NIGHT_LAYER_ID","defaultDayNightConfig","type","name","config","tooltip","dayNightLayer","id","description","isBaseMap","state","alpha","create","map","options","eventBus","theme","source","sourceMethods","Object","getPrototypeOf","sourceLine","sourceLineMethods","vectorLayer","style","fill","color","visualization","getColorByName","nightLineLayer","features","stroke","width","lineDash","sunFeature","geometry","sunLayer","image","radius","sunLineFeature","sunLineStyle","sunLineStyleDash","sunLineLayer","layer","layers","subscriptions","add","subscribe","event","time","payload","point","lineTime","Date","nightLinePoints","getCoordinates","toString","getSource","clear","lineStringArray","l","length","x1","values","y1","x2","y2","lineString","push","addFeature","sunLinePos","getSunPosition","getGeometry","setCoordinates","setStyle","init","dispose","unsubscribe","update","data","from","timeRange","valueOf","to","selectedTime","sunPos","From","setTime","registerOptionsUI","builder","addRadio","path","settings","label","value","defaultValue","addColorPicker","enableNamedColors","addBooleanSwitch","defaultOptions"],"sources":["/home/soula/grafana/public/app/plugins/panel/geomap/layers/data/dayNightLayer.tsx"],"sourcesContent":["import {\n  MapLayerRegistryItem,\n  MapLayerOptions,\n  PanelData,\n  GrafanaTheme2,\n  EventBus,\n  DataHoverEvent,\n  DataHoverClearEvent,\n  PluginState,\n} from '@grafana/data';\nimport Map from 'ol/Map';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport { Fill, Stroke, Style, Circle } from 'ol/style';\nimport {Group as LayerGroup} from 'ol/layer';\nimport Feature from 'ol/Feature';\nimport Point from 'ol/geom/Point';\n\nimport DayNight from 'ol-ext/source/DayNight';\nimport { fromLonLat } from 'ol/proj';\nimport { Subscription } from 'rxjs';\nimport { MultiLineString } from 'ol/geom';\nimport { Coordinate } from 'ol/coordinate';\n\nexport enum ShowTime {\n  From = 'from',\n  To = 'to',\n}\n\n// Configuration options for Circle overlays\nexport interface DayNightConfig {\n  show: ShowTime;\n  sun: boolean;\n  nightColor: string;\n}\n\nconst defaultConfig: DayNightConfig = {\n  show: ShowTime.To,\n  sun: false,\n  nightColor: '#a7a6ba4D'\n};\n\nexport const DAY_NIGHT_LAYER_ID = 'dayNight';\n\n// Used by default when nothing is configured\nexport const defaultDayNightConfig: MapLayerOptions<DayNightConfig> = {\n  type: DAY_NIGHT_LAYER_ID,\n  name: '', // will get replaced\n  config: defaultConfig,\n  tooltip: true,\n};\n\n/**\n * Map layer configuration for circle overlay\n */\nexport const dayNightLayer: MapLayerRegistryItem<DayNightConfig> = {\n  id: DAY_NIGHT_LAYER_ID,\n  name: 'Night / Day',\n  description: 'Show day and night regions',\n  isBaseMap: false,\n  state: PluginState.alpha,\n\n  /**\n   * Function that configures transformation and returns a transformer\n   * @param map\n   * @param options\n   * @param theme\n   */\n  create: async (map: Map, options: MapLayerOptions<DayNightConfig>, eventBus: EventBus, theme: GrafanaTheme2) => {\n    // Assert default values\n    const config = {\n      ...defaultConfig,\n      ...options?.config,\n    };\n\n    // DayNight source\n    const source = new DayNight({ });\n    const sourceMethods = Object.getPrototypeOf(source);\n    const sourceLine = new DayNight({ });\n    const sourceLineMethods = Object.getPrototypeOf(sourceLine);\n\n    // Night polygon\n    const vectorLayer = new VectorLayer({\n      source,\n      style: new Style({\n        fill: new Fill({\n          color: theme.visualization.getColorByName(config.nightColor)\n        })\n      })\n    });\n\n    // Night line (for crosshair sharing)\n    const nightLineLayer = new VectorLayer({\n      source: new VectorSource({\n        features: [],\n      }),\n      style: new Style ({\n        stroke: new Stroke({\n          color: '#607D8B',\n          width: 1.5,\n          lineDash: [2, 3],\n        })\n      }),\n    });\n    \n    // Sun circle\n    const sunFeature = new Feature({\n      geometry: new Point([]),\n    });\n\n    const sunLayer = new VectorLayer({\n      source: new VectorSource({\n        features: [sunFeature],\n      }),\n      style: new Style({\n        image: new Circle({\n          radius: 13,\n          fill: new Fill({color: 'rgb(253,184,19)'}),\n        })\n      }),\n    });\n\n    // Sun line (for crosshair sharing)\n    const sunLineFeature = new Feature({\n      geometry: new Point([]),\n    });\n\n    const sunLineStyle = new Style({\n      image: new Circle({\n        radius: 13,\n        stroke: new Stroke({\n          color: 'rgb(253,184,19)',\n          width: 1.5\n        })\n      })\n    });\n\n    const sunLineStyleDash = new Style({\n      image: new Circle({\n        radius: 15,\n        stroke: new Stroke({\n          color: '#607D8B',\n          width: 1.5,\n          lineDash: [2,3]\n        })\n      })\n    });\n\n    const sunLineLayer = new VectorLayer({\n      source: new VectorSource({\n        features: [sunLineFeature],\n      }),\n      style: [sunLineStyleDash, sunLineStyle],\n    });\n\n    // Build group of layers\n    // TODO: add blended night region to \"connect\" current night region to lines\n    const layer = new LayerGroup({\n      layers: config.sun? [vectorLayer, sunLayer, sunLineLayer, nightLineLayer] : [vectorLayer, nightLineLayer]\n    });\n\n    // Crosshair sharing subscriptions\n    const subscriptions = new Subscription();\n\n    if (false) {\n      subscriptions.add(\n        eventBus.subscribe(DataHoverEvent, (event) => {\n          const time = event.payload?.point?.time as number;\n          if (time) {\n            const lineTime = new Date(time);\n            const nightLinePoints = sourceLine.getCoordinates(lineTime.toString(), 'line');\n            nightLineLayer.getSource()?.clear();\n            const lineStringArray:Coordinate[][] = [];\n            for (let l = 0; l < nightLinePoints.length - 1; l++){\n              const x1:number = Object.values(nightLinePoints[l])[0];\n              const y1:number = Object.values(nightLinePoints[l])[1];\n              const x2:number = Object.values(nightLinePoints[l+1])[0];\n              const y2:number = Object.values(nightLinePoints[l+1])[1];\n              const lineString = [fromLonLat([x1, y1]),fromLonLat([x2, y2])];\n              lineStringArray.push(lineString);\n            }\n            nightLineLayer.getSource()?.addFeature(new Feature({\n                geometry: new MultiLineString(lineStringArray),\n              }))\n\n            let sunLinePos: number[] = [];\n            sunLinePos = sourceLineMethods.getSunPosition(lineTime);\n            sunLineFeature.getGeometry()?.setCoordinates(fromLonLat(sunLinePos));\n            sunLineFeature.setStyle([sunLineStyle, sunLineStyleDash]);\n          }\n        })\n      );\n\n      subscriptions.add(\n        eventBus.subscribe(DataHoverClearEvent, (event) => {\n          nightLineLayer.getSource()?.clear();\n          sunLineFeature.setStyle(new Style({}));\n        })\n      );\n    }\n\n    return {\n      init: () => layer,\n      dispose: () => subscriptions.unsubscribe(),\n      update: (data: PanelData) => {\n        const from = new Date(data.timeRange.from.valueOf());\n        const to = new Date(data.timeRange.to.valueOf());\n        let selectedTime: Date = new Date();\n        let sunPos: number[] = [];\n        // TODO: add option for \"Both\"\n        if (config.show === ShowTime.From){\n          selectedTime = from;\n        } else {\n          selectedTime = to;\n        }\n\n        source.setTime(selectedTime);\n        if (config.sun){\n          sunPos = sourceMethods.getSunPosition(selectedTime);\n          sunFeature.getGeometry()?.setCoordinates(fromLonLat(sunPos));\n        }\n      },\n\n      // Marker overlay options\n      registerOptionsUI: (builder) => {\n        if(!options.config?.nightColor) {\n          options.config = { ...defaultConfig, ...options.config}\n        }\n\n        builder\n          .addRadio({\n            path: 'config.show',\n            name: 'Show',\n            settings: {\n              options: [\n                { label: 'From', value: ShowTime.From },\n                { label: 'To', value: ShowTime.To },\n              ],\n            },\n            defaultValue: defaultConfig.show,\n          });\n        builder.addColorPicker({\n          path: 'config.nightColor',\n          name: 'Night region color',\n          description: 'Pick color of night region',\n          defaultValue: defaultConfig.nightColor,\n          settings: [{enableNamedColors: false}],\n        });\n        builder.addBooleanSwitch({\n          path: 'config.sun',\n          name: 'Display sun',\n          description: 'Show the sun',\n          defaultValue: defaultConfig.sun,\n        });\n      },\n    };\n  },\n\n  // fill in the default values\n  defaultOptions: defaultConfig,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}