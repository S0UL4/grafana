{"ast":null,"code":"// this thing here is a workaround in a way.\n// what we want to achieve, is that when the autocomplete-window\n// opens, the \"second, extra popup\" with the extra help,\n// also opens automatically.\n// but there is no API to achieve it.\n// the way to do it is to implement the `storageService`\n// interface, and provide our custom implementation,\n// which will default to `true` for the correct string-key.\n// unfortunately, while the typescript-interface exists,\n// it is not exported from monaco-editor,\n// so we cannot rely on typescript to make sure\n// we do it right. all we can do is to manually\n// lookup the interface, and make sure we code our code right.\n// our code is a \"best effort\" approach,\n// i am not 100% how the `scope` and `target` things work,\n// but so far it seems to work ok.\n// i would use an another approach, if there was one available.\nfunction makeStorageService() {\n  // we need to return an object that fulfills this interface:\n  // https://github.com/microsoft/vscode/blob/ff1e16eebb93af79fd6d7af1356c4003a120c563/src/vs/platform/storage/common/storage.ts#L37\n  // unfortunately it is not export from monaco-editor\n  const strings = new Map(); // we want this to be true by default\n\n  strings.set('expandSuggestionDocs', true.toString());\n  return {\n    // we do not implement the on* handlers\n    onDidChangeValue: data => undefined,\n    onDidChangeTarget: data => undefined,\n    onWillSaveState: data => undefined,\n    get: (key, scope, fallbackValue) => {\n      var _strings$get;\n\n      return (_strings$get = strings.get(key)) !== null && _strings$get !== void 0 ? _strings$get : fallbackValue;\n    },\n    getBoolean: (key, scope, fallbackValue) => {\n      const val = strings.get(key);\n\n      if (val !== undefined) {\n        // the interface-docs say the value will be converted\n        // to a boolean but do not specify how, so we improvise\n        return val === 'true';\n      } else {\n        return fallbackValue;\n      }\n    },\n    getNumber: (key, scope, fallbackValue) => {\n      const val = strings.get(key);\n\n      if (val !== undefined) {\n        return parseInt(val, 10);\n      } else {\n        return fallbackValue;\n      }\n    },\n    store: (key, value, scope, target) => {\n      // the interface-docs say if the value is nullish, it should act as delete\n      if (value === null || value === undefined) {\n        strings.delete(key);\n      } else {\n        strings.set(key, value.toString());\n      }\n    },\n    remove: (key, scope) => {\n      strings.delete(key);\n    },\n    keys: (scope, target) => {\n      return Array.from(strings.keys());\n    },\n    logStorage: () => {\n      console.log('logStorage: not implemented');\n    },\n    migrate: () => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n    isNew: scope => {\n      // we create a new storage for every session, we do not persist it,\n      // so we return `true`.\n      return true;\n    },\n    flush: reason => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    }\n  };\n}\n\nlet overrideServices = null;\nexport function getOverrideServices() {\n  // only have one instance of this for every query editor\n  if (overrideServices === null) {\n    overrideServices = {\n      storageService: makeStorageService()\n    };\n  }\n\n  return overrideServices;\n}","map":{"version":3,"names":["makeStorageService","strings","Map","set","toString","onDidChangeValue","data","undefined","onDidChangeTarget","onWillSaveState","get","key","scope","fallbackValue","getBoolean","val","getNumber","parseInt","store","value","target","delete","remove","keys","Array","from","logStorage","console","log","migrate","Promise","resolve","isNew","flush","reason","overrideServices","getOverrideServices","storageService"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/components/monaco-query-field/getOverrideServices.ts"],"sourcesContent":["import { monacoTypes } from '@grafana/ui';\n\n// this thing here is a workaround in a way.\n// what we want to achieve, is that when the autocomplete-window\n// opens, the \"second, extra popup\" with the extra help,\n// also opens automatically.\n// but there is no API to achieve it.\n// the way to do it is to implement the `storageService`\n// interface, and provide our custom implementation,\n// which will default to `true` for the correct string-key.\n// unfortunately, while the typescript-interface exists,\n// it is not exported from monaco-editor,\n// so we cannot rely on typescript to make sure\n// we do it right. all we can do is to manually\n// lookup the interface, and make sure we code our code right.\n// our code is a \"best effort\" approach,\n// i am not 100% how the `scope` and `target` things work,\n// but so far it seems to work ok.\n// i would use an another approach, if there was one available.\n\nfunction makeStorageService() {\n  // we need to return an object that fulfills this interface:\n  // https://github.com/microsoft/vscode/blob/ff1e16eebb93af79fd6d7af1356c4003a120c563/src/vs/platform/storage/common/storage.ts#L37\n  // unfortunately it is not export from monaco-editor\n\n  const strings = new Map<string, string>();\n\n  // we want this to be true by default\n  strings.set('expandSuggestionDocs', true.toString());\n\n  return {\n    // we do not implement the on* handlers\n    onDidChangeValue: (data: unknown): void => undefined,\n    onDidChangeTarget: (data: unknown): void => undefined,\n    onWillSaveState: (data: unknown): void => undefined,\n\n    get: (key: string, scope: unknown, fallbackValue?: string): string | undefined => {\n      return strings.get(key) ?? fallbackValue;\n    },\n\n    getBoolean: (key: string, scope: unknown, fallbackValue?: boolean): boolean | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        // the interface-docs say the value will be converted\n        // to a boolean but do not specify how, so we improvise\n        return val === 'true';\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    getNumber: (key: string, scope: unknown, fallbackValue?: number): number | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        return parseInt(val, 10);\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    store: (\n      key: string,\n      value: string | boolean | number | undefined | null,\n      scope: unknown,\n      target: unknown\n    ): void => {\n      // the interface-docs say if the value is nullish, it should act as delete\n      if (value === null || value === undefined) {\n        strings.delete(key);\n      } else {\n        strings.set(key, value.toString());\n      }\n    },\n\n    remove: (key: string, scope: unknown): void => {\n      strings.delete(key);\n    },\n\n    keys: (scope: unknown, target: unknown): string[] => {\n      return Array.from(strings.keys());\n    },\n\n    logStorage: (): void => {\n      console.log('logStorage: not implemented');\n    },\n\n    migrate: (): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n\n    isNew: (scope: unknown): boolean => {\n      // we create a new storage for every session, we do not persist it,\n      // so we return `true`.\n      return true;\n    },\n\n    flush: (reason?: unknown): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n  };\n}\n\nlet overrideServices: monacoTypes.editor.IEditorOverrideServices | null = null;\n\nexport function getOverrideServices(): monacoTypes.editor.IEditorOverrideServices {\n  // only have one instance of this for every query editor\n  if (overrideServices === null) {\n    overrideServices = {\n      storageService: makeStorageService(),\n    };\n  }\n\n  return overrideServices;\n}\n"],"mappings":"AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,kBAAT,GAA8B;EAC5B;EACA;EACA;EAEA,MAAMC,OAAO,GAAG,IAAIC,GAAJ,EAAhB,CAL4B,CAO5B;;EACAD,OAAO,CAACE,GAAR,CAAY,sBAAZ,EAAoC,KAAKC,QAAL,EAApC;EAEA,OAAO;IACL;IACAC,gBAAgB,EAAGC,IAAD,IAAyBC,SAFtC;IAGLC,iBAAiB,EAAGF,IAAD,IAAyBC,SAHvC;IAILE,eAAe,EAAGH,IAAD,IAAyBC,SAJrC;IAMLG,GAAG,EAAE,CAACC,GAAD,EAAcC,KAAd,EAA8BC,aAA9B,KAA6E;MAAA;;MAChF,uBAAOZ,OAAO,CAACS,GAAR,CAAYC,GAAZ,CAAP,uDAA2BE,aAA3B;IACD,CARI;IAULC,UAAU,EAAE,CAACH,GAAD,EAAcC,KAAd,EAA8BC,aAA9B,KAA+E;MACzF,MAAME,GAAG,GAAGd,OAAO,CAACS,GAAR,CAAYC,GAAZ,CAAZ;;MACA,IAAII,GAAG,KAAKR,SAAZ,EAAuB;QACrB;QACA;QACA,OAAOQ,GAAG,KAAK,MAAf;MACD,CAJD,MAIO;QACL,OAAOF,aAAP;MACD;IACF,CAnBI;IAqBLG,SAAS,EAAE,CAACL,GAAD,EAAcC,KAAd,EAA8BC,aAA9B,KAA6E;MACtF,MAAME,GAAG,GAAGd,OAAO,CAACS,GAAR,CAAYC,GAAZ,CAAZ;;MACA,IAAII,GAAG,KAAKR,SAAZ,EAAuB;QACrB,OAAOU,QAAQ,CAACF,GAAD,EAAM,EAAN,CAAf;MACD,CAFD,MAEO;QACL,OAAOF,aAAP;MACD;IACF,CA5BI;IA8BLK,KAAK,EAAE,CACLP,GADK,EAELQ,KAFK,EAGLP,KAHK,EAILQ,MAJK,KAKI;MACT;MACA,IAAID,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKZ,SAAhC,EAA2C;QACzCN,OAAO,CAACoB,MAAR,CAAeV,GAAf;MACD,CAFD,MAEO;QACLV,OAAO,CAACE,GAAR,CAAYQ,GAAZ,EAAiBQ,KAAK,CAACf,QAAN,EAAjB;MACD;IACF,CA1CI;IA4CLkB,MAAM,EAAE,CAACX,GAAD,EAAcC,KAAd,KAAuC;MAC7CX,OAAO,CAACoB,MAAR,CAAeV,GAAf;IACD,CA9CI;IAgDLY,IAAI,EAAE,CAACX,KAAD,EAAiBQ,MAAjB,KAA+C;MACnD,OAAOI,KAAK,CAACC,IAAN,CAAWxB,OAAO,CAACsB,IAAR,EAAX,CAAP;IACD,CAlDI;IAoDLG,UAAU,EAAE,MAAY;MACtBC,OAAO,CAACC,GAAR,CAAY,6BAAZ;IACD,CAtDI;IAwDLC,OAAO,EAAE,MAAqB;MAC5B;MACA,OAAOC,OAAO,CAACC,OAAR,CAAgBxB,SAAhB,CAAP;IACD,CA3DI;IA6DLyB,KAAK,EAAGpB,KAAD,IAA6B;MAClC;MACA;MACA,OAAO,IAAP;IACD,CAjEI;IAmELqB,KAAK,EAAGC,MAAD,IAAqC;MAC1C;MACA,OAAOJ,OAAO,CAACC,OAAR,CAAgBxB,SAAhB,CAAP;IACD;EAtEI,CAAP;AAwED;;AAED,IAAI4B,gBAAmE,GAAG,IAA1E;AAEA,OAAO,SAASC,mBAAT,GAA2E;EAChF;EACA,IAAID,gBAAgB,KAAK,IAAzB,EAA+B;IAC7BA,gBAAgB,GAAG;MACjBE,cAAc,EAAErC,kBAAkB;IADjB,CAAnB;EAGD;;EAED,OAAOmC,gBAAP;AACD"},"metadata":{},"sourceType":"module"}