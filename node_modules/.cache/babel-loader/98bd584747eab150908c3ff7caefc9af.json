{"ast":null,"code":"var _ConditionSegment;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { PureComponent } from 'react';\nimport { AdHocFilterBuilder } from './AdHocFilterBuilder';\nimport { REMOVE_FILTER_KEY } from './AdHocFilterKey';\nimport { AdHocFilterRenderer } from './AdHocFilterRenderer';\nimport { ConditionSegment } from './ConditionSegment';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\n\n/**\n * Simple filtering component that automatically uses datasource APIs to get available labels and it's values, for\n * dynamic visual filtering without need for much setup. Instead of having single onChange prop this reports all the\n * change events with separate props so it is usable with AdHocPicker.\n *\n * Note: There isn't API on datasource to suggest the operators here so that is hardcoded to use prometheus style\n * operators. Also filters are assumed to be joined with `AND` operator, which is also hardcoded.\n */\nexport class AdHocFilter extends PureComponent {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"onChange\", (index, prop) => key => {\n      const {\n        filters\n      } = this.props;\n      const {\n        value\n      } = key;\n\n      if (key.value === REMOVE_FILTER_KEY) {\n        return this.props.removeFilter(index);\n      }\n\n      return this.props.changeFilter(index, Object.assign({}, filters[index], {\n        [prop]: value\n      }));\n    });\n\n    _defineProperty(this, \"appendFilterToVariable\", filter => {\n      this.props.addFilter(filter);\n    });\n  }\n\n  render() {\n    const {\n      filters\n    } = this.props;\n    return /*#__PURE__*/_jsxs(\"div\", {\n      className: \"gf-form-inline\",\n      children: [this.renderFilters(filters), /*#__PURE__*/_jsx(AdHocFilterBuilder, {\n        datasource: this.props.datasource,\n        appendBefore: filters.length > 0 ? _ConditionSegment || (_ConditionSegment = /*#__PURE__*/_jsx(ConditionSegment, {\n          label: \"AND\"\n        })) : null,\n        onCompleted: this.appendFilterToVariable,\n        getTagKeysOptions: this.props.getTagKeysOptions\n      })]\n    });\n  }\n\n  renderFilters(filters) {\n    return filters.reduce((segments, filter, index) => {\n      if (segments.length > 0) {\n        segments.push( /*#__PURE__*/_jsx(ConditionSegment, {\n          label: \"AND\"\n        }, `condition-${index}`));\n      }\n\n      segments.push(this.renderFilterSegments(filter, index));\n      return segments;\n    }, []);\n  }\n\n  renderFilterSegments(filter, index) {\n    return /*#__PURE__*/_jsx(React.Fragment, {\n      children: /*#__PURE__*/_jsx(AdHocFilterRenderer, {\n        datasource: this.props.datasource,\n        filter: filter,\n        onKeyChange: this.onChange(index, 'key'),\n        onOperatorChange: this.onChange(index, 'operator'),\n        onValueChange: this.onChange(index, 'value'),\n        getTagKeysOptions: this.props.getTagKeysOptions\n      })\n    }, `filter-${index}`);\n  }\n\n}","map":{"version":3,"names":["React","PureComponent","AdHocFilterBuilder","REMOVE_FILTER_KEY","AdHocFilterRenderer","ConditionSegment","AdHocFilter","index","prop","key","filters","props","value","removeFilter","changeFilter","filter","addFilter","render","renderFilters","datasource","length","appendFilterToVariable","getTagKeysOptions","reduce","segments","push","renderFilterSegments","onChange"],"sources":["/home/soula/grafana/public/app/features/variables/adhoc/picker/AdHocFilter.tsx"],"sourcesContent":["import React, { PureComponent, ReactNode } from 'react';\n\nimport { DataSourceRef, SelectableValue } from '@grafana/data';\nimport { AdHocVariableFilter } from 'app/features/variables/types';\n\nimport { AdHocFilterBuilder } from './AdHocFilterBuilder';\nimport { REMOVE_FILTER_KEY } from './AdHocFilterKey';\nimport { AdHocFilterRenderer } from './AdHocFilterRenderer';\nimport { ConditionSegment } from './ConditionSegment';\n\ninterface Props {\n  datasource: DataSourceRef | null;\n  filters: AdHocVariableFilter[];\n  addFilter: (filter: AdHocVariableFilter) => void;\n  removeFilter: (index: number) => void;\n  changeFilter: (index: number, newFilter: AdHocVariableFilter) => void;\n  // Passes options to the datasources getTagKeys(options?: any) method\n  // which is called to fetch the available filter key options in AdHocFilterKey.tsx\n  getTagKeysOptions?: any;\n}\n\n/**\n * Simple filtering component that automatically uses datasource APIs to get available labels and it's values, for\n * dynamic visual filtering without need for much setup. Instead of having single onChange prop this reports all the\n * change events with separate props so it is usable with AdHocPicker.\n *\n * Note: There isn't API on datasource to suggest the operators here so that is hardcoded to use prometheus style\n * operators. Also filters are assumed to be joined with `AND` operator, which is also hardcoded.\n */\nexport class AdHocFilter extends PureComponent<Props> {\n  onChange = (index: number, prop: string) => (key: SelectableValue<string | null>) => {\n    const { filters } = this.props;\n    const { value } = key;\n\n    if (key.value === REMOVE_FILTER_KEY) {\n      return this.props.removeFilter(index);\n    }\n\n    return this.props.changeFilter(index, {\n      ...filters[index],\n      [prop]: value,\n    });\n  };\n\n  appendFilterToVariable = (filter: AdHocVariableFilter) => {\n    this.props.addFilter(filter);\n  };\n\n  render() {\n    const { filters } = this.props;\n\n    return (\n      <div className=\"gf-form-inline\">\n        {this.renderFilters(filters)}\n        <AdHocFilterBuilder\n          datasource={this.props.datasource!}\n          appendBefore={filters.length > 0 ? <ConditionSegment label=\"AND\" /> : null}\n          onCompleted={this.appendFilterToVariable}\n          getTagKeysOptions={this.props.getTagKeysOptions}\n        />\n      </div>\n    );\n  }\n\n  renderFilters(filters: AdHocVariableFilter[]) {\n    return filters.reduce((segments: ReactNode[], filter, index) => {\n      if (segments.length > 0) {\n        segments.push(<ConditionSegment label=\"AND\" key={`condition-${index}`} />);\n      }\n      segments.push(this.renderFilterSegments(filter, index));\n      return segments;\n    }, []);\n  }\n\n  renderFilterSegments(filter: AdHocVariableFilter, index: number) {\n    return (\n      <React.Fragment key={`filter-${index}`}>\n        <AdHocFilterRenderer\n          datasource={this.props.datasource!}\n          filter={filter}\n          onKeyChange={this.onChange(index, 'key')}\n          onOperatorChange={this.onChange(index, 'operator')}\n          onValueChange={this.onChange(index, 'value')}\n          getTagKeysOptions={this.props.getTagKeysOptions}\n        />\n      </React.Fragment>\n    );\n  }\n}\n"],"mappings":";;;;AAAA,OAAOA,KAAP,IAAgBC,aAAhB,QAAgD,OAAhD;AAKA,SAASC,kBAAT,QAAmC,sBAAnC;AACA,SAASC,iBAAT,QAAkC,kBAAlC;AACA,SAASC,mBAAT,QAAoC,uBAApC;AACA,SAASC,gBAAT,QAAiC,oBAAjC;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAN,SAA0BL,aAA1B,CAA+C;EAAA;IAAA;;IAAA,kCACzC,CAACM,KAAD,EAAgBC,IAAhB,KAAkCC,GAAD,IAAyC;MACnF,MAAM;QAAEC;MAAF,IAAc,KAAKC,KAAzB;MACA,MAAM;QAAEC;MAAF,IAAYH,GAAlB;;MAEA,IAAIA,GAAG,CAACG,KAAJ,KAAcT,iBAAlB,EAAqC;QACnC,OAAO,KAAKQ,KAAL,CAAWE,YAAX,CAAwBN,KAAxB,CAAP;MACD;;MAED,OAAO,KAAKI,KAAL,CAAWG,YAAX,CAAwBP,KAAxB,oBACFG,OAAO,CAACH,KAAD,CADL;QAEL,CAACC,IAAD,GAAQI;MAFH,GAAP;IAID,CAbmD;;IAAA,gDAe1BG,MAAD,IAAiC;MACxD,KAAKJ,KAAL,CAAWK,SAAX,CAAqBD,MAArB;IACD,CAjBmD;EAAA;;EAmBpDE,MAAM,GAAG;IACP,MAAM;MAAEP;IAAF,IAAc,KAAKC,KAAzB;IAEA,oBACE;MAAK,SAAS,EAAC,gBAAf;MAAA,WACG,KAAKO,aAAL,CAAmBR,OAAnB,CADH,eAEE,KAAC,kBAAD;QACE,UAAU,EAAE,KAAKC,KAAL,CAAWQ,UADzB;QAEE,YAAY,EAAET,OAAO,CAACU,MAAR,GAAiB,CAAjB,0DAAqB,KAAC,gBAAD;UAAkB,KAAK,EAAC;QAAxB,EAArB,IAAwD,IAFxE;QAGE,WAAW,EAAE,KAAKC,sBAHpB;QAIE,iBAAiB,EAAE,KAAKV,KAAL,CAAWW;MAJhC,EAFF;IAAA,EADF;EAWD;;EAEDJ,aAAa,CAACR,OAAD,EAAiC;IAC5C,OAAOA,OAAO,CAACa,MAAR,CAAe,CAACC,QAAD,EAAwBT,MAAxB,EAAgCR,KAAhC,KAA0C;MAC9D,IAAIiB,QAAQ,CAACJ,MAAT,GAAkB,CAAtB,EAAyB;QACvBI,QAAQ,CAACC,IAAT,eAAc,KAAC,gBAAD;UAAkB,KAAK,EAAC;QAAxB,GAAoC,aAAYlB,KAAM,EAAtD,CAAd;MACD;;MACDiB,QAAQ,CAACC,IAAT,CAAc,KAAKC,oBAAL,CAA0BX,MAA1B,EAAkCR,KAAlC,CAAd;MACA,OAAOiB,QAAP;IACD,CANM,EAMJ,EANI,CAAP;EAOD;;EAEDE,oBAAoB,CAACX,MAAD,EAA8BR,KAA9B,EAA6C;IAC/D,oBACE,KAAC,KAAD,CAAO,QAAP;MAAA,uBACE,KAAC,mBAAD;QACE,UAAU,EAAE,KAAKI,KAAL,CAAWQ,UADzB;QAEE,MAAM,EAAEJ,MAFV;QAGE,WAAW,EAAE,KAAKY,QAAL,CAAcpB,KAAd,EAAqB,KAArB,CAHf;QAIE,gBAAgB,EAAE,KAAKoB,QAAL,CAAcpB,KAAd,EAAqB,UAArB,CAJpB;QAKE,aAAa,EAAE,KAAKoB,QAAL,CAAcpB,KAAd,EAAqB,OAArB,CALjB;QAME,iBAAiB,EAAE,KAAKI,KAAL,CAAWW;MANhC;IADF,GAAsB,UAASf,KAAM,EAArC,CADF;EAYD;;AA1DmD"},"metadata":{},"sourceType":"module"}