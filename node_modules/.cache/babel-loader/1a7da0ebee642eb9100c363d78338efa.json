{"ast":null,"code":"// Copyright (c) 2017 The Jaeger Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { uniq as _uniq } from 'lodash';\nimport memoize from 'lru-memoize';\nimport { getConfigValue } from '../utils/config/get-config';\nimport { getParent } from './span';\nconst parameterRegExp = /#\\{([^{}]*)\\}/g;\n\nfunction getParamNames(str) {\n  const names = new Set();\n  str.replace(parameterRegExp, (match, name) => {\n    names.add(name);\n    return match;\n  });\n  return Array.from(names);\n}\n\nfunction stringSupplant(str, encodeFn, map) {\n  return str.replace(parameterRegExp, (_, name) => {\n    const value = map[name];\n    return value == null ? '' : encodeFn(value);\n  });\n}\n\nexport function processTemplate(template, encodeFn) {\n  if (typeof template !== 'string') {\n    /*\n     // kept on ice until #123 is implemented:\n    if (template && Array.isArray(template.parameters) && (typeof template.template === 'function')) {\n      return template;\n    }\n     */\n    throw new Error('Invalid template');\n  }\n\n  return {\n    parameters: getParamNames(template),\n    template: stringSupplant.bind(null, template, encodeFn)\n  };\n}\nexport function createTestFunction(entry) {\n  if (typeof entry === 'string') {\n    return arg => arg === entry;\n  }\n\n  if (Array.isArray(entry)) {\n    return arg => entry.indexOf(arg) > -1;\n  }\n  /*\n   // kept on ice until #123 is implemented:\n  if (entry instanceof RegExp) {\n    return (arg: any) => entry.test(arg);\n  }\n  if (typeof entry === 'function') {\n    return entry;\n  }\n   */\n\n\n  if (entry == null) {\n    return () => true;\n  }\n\n  throw new Error(`Invalid value: ${entry}`);\n}\n\nconst identity = a => a;\n\nexport function processLinkPattern(pattern) {\n  try {\n    const url = processTemplate(pattern.url, encodeURIComponent);\n    const text = processTemplate(pattern.text, identity);\n    return {\n      object: pattern,\n      type: createTestFunction(pattern.type),\n      key: createTestFunction(pattern.key),\n      value: createTestFunction(pattern.value),\n      url,\n      text,\n      parameters: _uniq(url.parameters.concat(text.parameters))\n    };\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error(`Ignoring invalid link pattern: ${error}`, pattern);\n    return null;\n  }\n}\nexport function getParameterInArray(name, array) {\n  if (array) {\n    return array.find(entry => entry.key === name);\n  }\n\n  return undefined;\n}\nexport function getParameterInAncestor(name, span) {\n  let currentSpan = span;\n\n  while (currentSpan) {\n    const result = getParameterInArray(name, currentSpan.tags) || getParameterInArray(name, currentSpan.process.tags);\n\n    if (result) {\n      return result;\n    }\n\n    currentSpan = getParent(currentSpan);\n  }\n\n  return undefined;\n}\n\nfunction callTemplate(template, data) {\n  return template.template(data);\n}\n\nexport function computeTraceLink(linkPatterns, trace) {\n  const result = [];\n  const validKeys = Object.keys(trace).filter(key => typeof trace[key] === 'string' || trace[key] === 'number');\n  linkPatterns.filter(pattern => pattern.type('traces')).forEach(pattern => {\n    const parameterValues = {};\n    const allParameters = pattern.parameters.every(parameter => {\n      const key = parameter;\n\n      if (validKeys.includes(key)) {\n        // At this point is safe to access to trace object using parameter variable because\n        // we validated parameter against validKeys, this implies that parameter a keyof Trace.\n        parameterValues[parameter] = trace[key];\n        return true;\n      }\n\n      return false;\n    });\n\n    if (allParameters) {\n      result.push({\n        url: callTemplate(pattern.url, parameterValues),\n        text: callTemplate(pattern.text, parameterValues)\n      });\n    }\n  });\n  return result;\n}\nexport function computeLinks(linkPatterns, span, items, itemIndex) {\n  const item = items[itemIndex];\n  let type = 'logs';\n  const processTags = span.process.tags === items;\n\n  if (processTags) {\n    type = 'process';\n  }\n\n  const spanTags = span.tags === items;\n\n  if (spanTags) {\n    type = 'tags';\n  }\n\n  const result = [];\n  linkPatterns.forEach(pattern => {\n    if (pattern.type(type) && pattern.key(item.key) && pattern.value(item.value)) {\n      const parameterValues = {};\n      const allParameters = pattern.parameters.every(parameter => {\n        let entry = getParameterInArray(parameter, items);\n\n        if (!entry && !processTags) {\n          // do not look in ancestors for process tags because the same object may appear in different places in the hierarchy\n          // and the cache in getLinks uses that object as a key\n          entry = getParameterInAncestor(parameter, span);\n        }\n\n        if (entry) {\n          parameterValues[parameter] = entry.value;\n          return true;\n        } // eslint-disable-next-line no-console\n\n\n        console.warn(`Skipping link pattern, missing parameter ${parameter} for key ${item.key} in ${type}.`, pattern.object);\n        return false;\n      });\n\n      if (allParameters) {\n        result.push({\n          url: callTemplate(pattern.url, parameterValues),\n          text: callTemplate(pattern.text, parameterValues)\n        });\n      }\n    }\n  });\n  return result;\n}\nexport function createGetLinks(linkPatterns, cache) {\n  return (span, items, itemIndex) => {\n    if (linkPatterns.length === 0) {\n      return [];\n    }\n\n    const item = items[itemIndex];\n    let result = cache.get(item);\n\n    if (!result) {\n      result = computeLinks(linkPatterns, span, items, itemIndex);\n      cache.set(item, result);\n    }\n\n    return result;\n  };\n}\nconst processedLinks = (getConfigValue('linkPatterns') || []).map(processLinkPattern).filter(Boolean);\nexport const getTraceLinks = memoize(10)(trace => {\n  const result = [];\n\n  if (!trace) {\n    return result;\n  }\n\n  return computeTraceLink(processedLinks, trace);\n});\nexport default createGetLinks(processedLinks, new WeakMap());","map":{"version":3,"names":["uniq","_uniq","memoize","getConfigValue","getParent","parameterRegExp","getParamNames","str","names","Set","replace","match","name","add","Array","from","stringSupplant","encodeFn","map","_","value","processTemplate","template","Error","parameters","bind","createTestFunction","entry","arg","isArray","indexOf","identity","a","processLinkPattern","pattern","url","encodeURIComponent","text","object","type","key","concat","error","console","getParameterInArray","array","find","undefined","getParameterInAncestor","span","currentSpan","result","tags","process","callTemplate","data","computeTraceLink","linkPatterns","trace","validKeys","Object","keys","filter","forEach","parameterValues","allParameters","every","parameter","includes","push","computeLinks","items","itemIndex","item","processTags","spanTags","warn","createGetLinks","cache","length","get","set","processedLinks","Boolean","getTraceLinks","WeakMap"],"sources":["/home/soula/grafana/packages/jaeger-ui-components/src/model/link-patterns.tsx"],"sourcesContent":["// Copyright (c) 2017 The Jaeger Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { uniq as _uniq } from 'lodash';\nimport memoize from 'lru-memoize';\n\nimport { TNil } from '../types';\nimport { TraceSpan, TraceLink, TraceKeyValuePair, Trace } from '../types/trace';\nimport { getConfigValue } from '../utils/config/get-config';\n\nimport { getParent } from './span';\n\nconst parameterRegExp = /#\\{([^{}]*)\\}/g;\n\ntype ProcessedTemplate = {\n  parameters: string[];\n  template: (template: { [key: string]: any }) => string;\n};\n\ntype ProcessedLinkPattern = {\n  object: any;\n  type: (link: string) => boolean;\n  key: (link: string) => boolean;\n  value: (value: any) => boolean;\n  url: ProcessedTemplate;\n  text: ProcessedTemplate;\n  parameters: string[];\n};\n\ntype TLinksRV = Array<{ url: string; text: string }>;\n\nfunction getParamNames(str: string) {\n  const names = new Set<string>();\n  str.replace(parameterRegExp, (match, name) => {\n    names.add(name);\n    return match;\n  });\n  return Array.from(names);\n}\n\nfunction stringSupplant(str: string, encodeFn: (unencoded: any) => string, map: Record<string, any>) {\n  return str.replace(parameterRegExp, (_, name) => {\n    const value = map[name];\n    return value == null ? '' : encodeFn(value);\n  });\n}\n\nexport function processTemplate(template: any, encodeFn: (unencoded: any) => string): ProcessedTemplate {\n  if (typeof template !== 'string') {\n    /*\n\n    // kept on ice until #123 is implemented:\n    if (template && Array.isArray(template.parameters) && (typeof template.template === 'function')) {\n      return template;\n    }\n\n    */\n    throw new Error('Invalid template');\n  }\n  return {\n    parameters: getParamNames(template),\n    template: stringSupplant.bind(null, template, encodeFn),\n  };\n}\n\nexport function createTestFunction(entry: any) {\n  if (typeof entry === 'string') {\n    return (arg: any) => arg === entry;\n  }\n  if (Array.isArray(entry)) {\n    return (arg: any) => entry.indexOf(arg) > -1;\n  }\n  /*\n\n  // kept on ice until #123 is implemented:\n  if (entry instanceof RegExp) {\n    return (arg: any) => entry.test(arg);\n  }\n  if (typeof entry === 'function') {\n    return entry;\n  }\n\n  */\n  if (entry == null) {\n    return () => true;\n  }\n  throw new Error(`Invalid value: ${entry}`);\n}\n\nconst identity = (a: any): typeof a => a;\n\nexport function processLinkPattern(pattern: any): ProcessedLinkPattern | TNil {\n  try {\n    const url = processTemplate(pattern.url, encodeURIComponent);\n    const text = processTemplate(pattern.text, identity);\n    return {\n      object: pattern,\n      type: createTestFunction(pattern.type),\n      key: createTestFunction(pattern.key),\n      value: createTestFunction(pattern.value),\n      url,\n      text,\n      parameters: _uniq(url.parameters.concat(text.parameters)),\n    };\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error(`Ignoring invalid link pattern: ${error}`, pattern);\n    return null;\n  }\n}\n\nexport function getParameterInArray(name: string, array: TraceKeyValuePair[]) {\n  if (array) {\n    return array.find((entry) => entry.key === name);\n  }\n  return undefined;\n}\n\nexport function getParameterInAncestor(name: string, span: TraceSpan) {\n  let currentSpan: TraceSpan | TNil = span;\n  while (currentSpan) {\n    const result = getParameterInArray(name, currentSpan.tags) || getParameterInArray(name, currentSpan.process.tags);\n    if (result) {\n      return result;\n    }\n    currentSpan = getParent(currentSpan);\n  }\n  return undefined;\n}\n\nfunction callTemplate(template: ProcessedTemplate, data: any) {\n  return template.template(data);\n}\n\nexport function computeTraceLink(linkPatterns: ProcessedLinkPattern[], trace: Trace) {\n  const result: TLinksRV = [];\n  const validKeys = (Object.keys(trace) as Array<keyof Trace>).filter(\n    (key) => typeof trace[key] === 'string' || trace[key] === 'number'\n  );\n\n  linkPatterns\n    .filter((pattern) => pattern.type('traces'))\n    .forEach((pattern) => {\n      const parameterValues: Record<string, any> = {};\n      const allParameters = pattern.parameters.every((parameter) => {\n        const key = parameter as keyof Trace;\n        if (validKeys.includes(key)) {\n          // At this point is safe to access to trace object using parameter variable because\n          // we validated parameter against validKeys, this implies that parameter a keyof Trace.\n          parameterValues[parameter] = trace[key];\n          return true;\n        }\n        return false;\n      });\n      if (allParameters) {\n        result.push({\n          url: callTemplate(pattern.url, parameterValues),\n          text: callTemplate(pattern.text, parameterValues),\n        });\n      }\n    });\n\n  return result;\n}\n\nexport function computeLinks(\n  linkPatterns: ProcessedLinkPattern[],\n  span: TraceSpan,\n  items: TraceKeyValuePair[],\n  itemIndex: number\n) {\n  const item = items[itemIndex];\n  let type = 'logs';\n  const processTags = span.process.tags === items;\n  if (processTags) {\n    type = 'process';\n  }\n  const spanTags = span.tags === items;\n  if (spanTags) {\n    type = 'tags';\n  }\n  const result: Array<{ url: string; text: string }> = [];\n  linkPatterns.forEach((pattern) => {\n    if (pattern.type(type) && pattern.key(item.key) && pattern.value(item.value)) {\n      const parameterValues: Record<string, any> = {};\n      const allParameters = pattern.parameters.every((parameter) => {\n        let entry = getParameterInArray(parameter, items);\n        if (!entry && !processTags) {\n          // do not look in ancestors for process tags because the same object may appear in different places in the hierarchy\n          // and the cache in getLinks uses that object as a key\n          entry = getParameterInAncestor(parameter, span);\n        }\n        if (entry) {\n          parameterValues[parameter] = entry.value;\n          return true;\n        }\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Skipping link pattern, missing parameter ${parameter} for key ${item.key} in ${type}.`,\n          pattern.object\n        );\n        return false;\n      });\n      if (allParameters) {\n        result.push({\n          url: callTemplate(pattern.url, parameterValues),\n          text: callTemplate(pattern.text, parameterValues),\n        });\n      }\n    }\n  });\n  return result;\n}\n\nexport function createGetLinks(linkPatterns: ProcessedLinkPattern[], cache: WeakMap<TraceKeyValuePair, TraceLink[]>) {\n  return (span: TraceSpan, items: TraceKeyValuePair[], itemIndex: number) => {\n    if (linkPatterns.length === 0) {\n      return [];\n    }\n    const item = items[itemIndex];\n    let result = cache.get(item);\n    if (!result) {\n      result = computeLinks(linkPatterns, span, items, itemIndex);\n      cache.set(item, result);\n    }\n    return result;\n  };\n}\n\nconst processedLinks: ProcessedLinkPattern[] = (getConfigValue('linkPatterns') || [])\n  .map(processLinkPattern)\n  .filter(Boolean);\n\nexport const getTraceLinks: (trace: Trace | undefined) => TLinksRV = memoize(10)((trace: Trace | undefined) => {\n  const result: TLinksRV = [];\n  if (!trace) {\n    return result;\n  }\n  return computeTraceLink(processedLinks, trace);\n});\n\nexport default createGetLinks(processedLinks, new WeakMap());\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}