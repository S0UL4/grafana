{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { ArrayVector, decodeFieldValueEntities, FieldType, guessFieldTypeFromValue, parseLabels, toFilteredDataFrameDTO } from '@grafana/data';\nimport { join } from '@grafana/data/src/transformations/transformers/joinDataFrames';\nimport { StreamingFrameAction } from '@grafana/runtime/src/services/live';\nimport { renderLegendFormat } from 'app/plugins/datasource/prometheus/legend';\nconst PROM_STYLE_METRIC_LABEL = '__name__';\nvar PushMode;\n\n(function (PushMode) {\n  PushMode[PushMode[\"wide\"] = 0] = \"wide\";\n  PushMode[PushMode[\"labels\"] = 1] = \"labels\";\n})(PushMode || (PushMode = {}));\n\n/**\n * Unlike a circular buffer, this will append and periodically slice the front\n */\nexport class StreamingDataFrame {\n  // current labels\n  constructor(_options) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"refId\", void 0);\n\n    _defineProperty(this, \"meta\", {});\n\n    _defineProperty(this, \"fields\", []);\n\n    _defineProperty(this, \"length\", 0);\n\n    _defineProperty(this, \"schemaFields\", []);\n\n    _defineProperty(this, \"timeFieldIndex\", -1);\n\n    _defineProperty(this, \"pushMode\", PushMode.wide);\n\n    _defineProperty(this, \"labels\", new Set());\n\n    _defineProperty(this, \"packetInfo\", {\n      schemaChanged: true,\n      number: 0,\n      action: StreamingFrameAction.Replace,\n      length: 0\n    });\n\n    _defineProperty(this, \"serialize\", (fieldPredicate, optionsOverride, trimValues) => {\n      const options = optionsOverride ? Object.assign({}, Object.assign({}, this.options, optionsOverride)) : this.options;\n      const dataFrameDTO = toFilteredDataFrameDTO(this, fieldPredicate);\n      const numberOfItemsToRemove = getNumberOfItemsToRemove(dataFrameDTO.fields.map(f => f.values), typeof (trimValues === null || trimValues === void 0 ? void 0 : trimValues.maxLength) === 'number' ? Math.min(trimValues.maxLength, options.maxLength) : options.maxLength, this.timeFieldIndex, options.maxDelta);\n      dataFrameDTO.fields = dataFrameDTO.fields.map(f => Object.assign({}, f, {\n        values: f.values.slice(numberOfItemsToRemove)\n      }));\n      return Object.assign({}, dataFrameDTO, {\n        // TODO: Labels and schema are not filtered by field\n        labels: this.labels,\n        schemaFields: this.schemaFields,\n        name: this.name,\n        refId: this.refId,\n        meta: this.meta,\n        length: this.length,\n        timeFieldIndex: this.timeFieldIndex,\n        pushMode: this.pushMode,\n        packetInfo: this.packetInfo,\n        options\n      });\n    });\n\n    _defineProperty(this, \"initFromSerialized\", serialized => {\n      this.name = serialized.name;\n      this.refId = serialized.refId;\n      this.meta = serialized.meta;\n      this.length = serialized.length;\n      this.labels = serialized.labels;\n      this.schemaFields = serialized.schemaFields;\n      this.timeFieldIndex = serialized.timeFieldIndex;\n      this.pushMode = serialized.pushMode;\n      this.packetInfo.length = serialized.packetInfo.length;\n      this.packetInfo.number = serialized.packetInfo.number;\n      this.packetInfo.action = StreamingFrameAction.Replace;\n      this.packetInfo.schemaChanged = true;\n      this.fields = serialized.fields.map(f => {\n        var _f$type, _f$config;\n\n        return Object.assign({}, f, {\n          type: (_f$type = f.type) !== null && _f$type !== void 0 ? _f$type : FieldType.other,\n          config: (_f$config = f.config) !== null && _f$config !== void 0 ? _f$config : {},\n          values: Array.isArray(f.values) ? new ArrayVector(f.values) : new ArrayVector()\n        });\n      });\n      assureValuesAreWithinLengthLimit(this.fields.map(f => f.values.buffer), this.options.maxLength, this.timeFieldIndex, this.options.maxDelta);\n    });\n\n    _defineProperty(this, \"needsResizing\", ({\n      maxLength,\n      maxDelta\n    }) => {\n      const needsMoreLength = maxLength && this.options.maxLength < maxLength;\n      const needsBiggerDelta = maxDelta && this.options.maxDelta < maxDelta;\n      const needsToOverrideDefaultInfinityDelta = maxDelta && this.options.maxDelta === Infinity;\n      return Boolean(needsMoreLength || needsBiggerDelta || needsToOverrideDefaultInfinityDelta);\n    });\n\n    _defineProperty(this, \"resize\", ({\n      maxLength,\n      maxDelta\n    }) => {\n      if (maxDelta) {\n        if (this.options.maxDelta === Infinity) {\n          this.options.maxDelta = maxDelta;\n        } else {\n          this.options.maxDelta = Math.max(maxDelta, this.options.maxDelta);\n        }\n      }\n\n      this.options.maxLength = Math.max(this.options.maxLength, maxLength !== null && maxLength !== void 0 ? maxLength : 0);\n    });\n\n    _defineProperty(this, \"pushNewValues\", values => {\n      var _this$fields, _this$fields$, _this$fields$$values, _this$fields$$values$;\n\n      if (!(values !== null && values !== void 0 && values.length)) {\n        return;\n      }\n\n      this.packetInfo.action = this.options.action;\n      this.packetInfo.number++;\n      this.packetInfo.length = values[0].length;\n      this.packetInfo.schemaChanged = false;\n\n      if (this.options.action === StreamingFrameAction.Append) {\n        circPush(this.fields.map(f => f.values.buffer), values, this.options.maxLength, this.timeFieldIndex, this.options.maxDelta);\n      } else {\n        values.forEach((v, i) => {\n          var _this$fields$i;\n\n          if ((_this$fields$i = this.fields[i]) !== null && _this$fields$i !== void 0 && _this$fields$i.values) {\n            this.fields[i].values.buffer = v;\n          }\n        });\n        assureValuesAreWithinLengthLimit(this.fields.map(f => f.values.buffer), this.options.maxLength, this.timeFieldIndex, this.options.maxDelta);\n      }\n\n      const newLength = (_this$fields = this.fields) === null || _this$fields === void 0 ? void 0 : (_this$fields$ = _this$fields[0]) === null || _this$fields$ === void 0 ? void 0 : (_this$fields$$values = _this$fields$.values) === null || _this$fields$$values === void 0 ? void 0 : (_this$fields$$values$ = _this$fields$$values.buffer) === null || _this$fields$$values$ === void 0 ? void 0 : _this$fields$$values$.length;\n\n      if (newLength !== undefined) {\n        this.length = newLength;\n      }\n    });\n\n    _defineProperty(this, \"resetStateCalculations\", () => {\n      this.fields.forEach(f => {\n        var _f$state;\n\n        f.state = Object.assign({}, (_f$state = f.state) !== null && _f$state !== void 0 ? _f$state : {}, {\n          calcs: undefined,\n          range: undefined\n        });\n      });\n    });\n\n    _defineProperty(this, \"getMatchingFieldIndexes\", fieldPredicate => this.fields.map((f, index) => fieldPredicate(f) ? index : undefined).filter(val => val !== undefined));\n\n    _defineProperty(this, \"getValuesFromLastPacket\", () => this.fields.map(f => {\n      const values = f.values.buffer;\n      return values.slice(Math.max(values.length - this.packetInfo.length));\n    }));\n\n    _defineProperty(this, \"hasAtLeastOnePacket\", () => Boolean(this.packetInfo.length));\n\n    _defineProperty(this, \"getOptions\", () => this.options);\n\n    this.options = _options;\n    // Get Length to show up if you use spread\n    Object.defineProperty(this, 'length', {\n      enumerable: true\n    }); // Get fields to show up if you use spread\n\n    Object.defineProperty(this, 'fields', {\n      enumerable: true\n    });\n  }\n\n  get alwaysReplace() {\n    return this.options.action === StreamingFrameAction.Replace;\n  }\n\n  /**\n   * apply the new message to the existing data.  This will replace the existing schema\n   * if a new schema is included in the message, or append data matching the current schema\n   */\n  push(msg) {\n    const {\n      schema,\n      data\n    } = msg;\n    this.packetInfo.number++;\n    this.packetInfo.length = 0;\n    this.packetInfo.schemaChanged = false;\n\n    if (schema) {\n      this.pushMode = PushMode.wide;\n      this.timeFieldIndex = schema.fields.findIndex(f => f.type === FieldType.time);\n      const firstField = schema.fields[0];\n\n      if (this.timeFieldIndex === 1 && firstField.type === FieldType.string && (firstField.name === 'labels' || firstField.name === 'Labels')) {\n        this.pushMode = PushMode.labels;\n        this.timeFieldIndex = 0; // after labels are removed!\n      }\n\n      const niceSchemaFields = this.pushMode === PushMode.labels ? schema.fields.slice(1) : schema.fields;\n      this.refId = schema.refId;\n\n      if (schema.meta) {\n        this.meta = Object.assign({}, schema.meta);\n      }\n\n      const {\n        displayNameFormat\n      } = this.options;\n\n      if (hasSameStructure(this.schemaFields, niceSchemaFields)) {\n        const len = niceSchemaFields.length;\n        this.fields.forEach((f, idx) => {\n          var _sf$config;\n\n          const sf = niceSchemaFields[idx % len];\n          f.config = (_sf$config = sf.config) !== null && _sf$config !== void 0 ? _sf$config : {};\n          f.labels = sf.labels;\n        });\n\n        if (displayNameFormat) {\n          this.fields.forEach(f => {\n            const labels = Object.assign({\n              [PROM_STYLE_METRIC_LABEL]: f.name\n            }, f.labels);\n            f.config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n          });\n        }\n      } else {\n        this.packetInfo.schemaChanged = true;\n        const isWide = this.pushMode === PushMode.wide;\n        this.fields = niceSchemaFields.map(f => {\n          var _f$config2, _f$type2, _this$fields$find$val, _this$fields$find;\n\n          const config = (_f$config2 = f.config) !== null && _f$config2 !== void 0 ? _f$config2 : {};\n\n          if (displayNameFormat) {\n            const labels = Object.assign({\n              [PROM_STYLE_METRIC_LABEL]: f.name\n            }, f.labels);\n            config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n          }\n\n          return {\n            config,\n            name: f.name,\n            labels: f.labels,\n            type: (_f$type2 = f.type) !== null && _f$type2 !== void 0 ? _f$type2 : FieldType.other,\n            // transfer old values by type & name, unless we relied on labels to match fields\n            values: isWide ? (_this$fields$find$val = (_this$fields$find = this.fields.find(of => of.name === f.name && f.type === of.type)) === null || _this$fields$find === void 0 ? void 0 : _this$fields$find.values) !== null && _this$fields$find$val !== void 0 ? _this$fields$find$val : new ArrayVector(Array(this.length).fill(undefined)) : new ArrayVector()\n          };\n        });\n      }\n\n      this.schemaFields = niceSchemaFields;\n    }\n\n    if (data && data.values.length && data.values[0].length) {\n      let {\n        values,\n        entities\n      } = data;\n\n      if (entities) {\n        entities.forEach((ents, i) => {\n          if (ents) {\n            decodeFieldValueEntities(ents, values[i]); // TODO: append replacements to field\n          }\n        });\n      }\n\n      if (this.pushMode === PushMode.labels) {\n        // augment and transform data to match current schema for standard circPush() path\n        const labeledTables = transpose(values); // make sure fields are initalized for each label\n\n        for (const label of labeledTables.keys()) {\n          if (!this.labels.has(label)) {\n            this.packetInfo.schemaChanged = true;\n            this.addLabel(label);\n          }\n        } // TODO: cache higher up\n\n\n        let dummyTable = Array(this.schemaFields.length).fill([]);\n        let tables = [];\n        this.labels.forEach(label => {\n          var _labeledTables$get;\n\n          tables.push((_labeledTables$get = labeledTables.get(label)) !== null && _labeledTables$get !== void 0 ? _labeledTables$get : dummyTable);\n        });\n        values = join(tables);\n      }\n\n      if (values.length !== this.fields.length) {\n        if (this.fields.length) {\n          throw new Error(`push message mismatch.  Expected: ${this.fields.length}, received: ${values.length} (labels=${this.pushMode === PushMode.labels})`);\n        }\n\n        this.fields = values.map((vals, idx) => {\n          let name = `Field ${idx}`;\n          let type = guessFieldTypeFromValue(vals[0]);\n          const isTime = idx === 0 && type === FieldType.number && vals[0] > 1600016688632;\n\n          if (isTime) {\n            type = FieldType.time;\n            name = 'Time';\n          }\n\n          return {\n            name,\n            type,\n            config: {},\n            values: new ArrayVector([])\n          };\n        });\n      }\n\n      let appended = values;\n      this.packetInfo.length = values[0].length;\n\n      if (this.alwaysReplace || !this.length) {\n        this.packetInfo.action = StreamingFrameAction.Replace;\n      } else {\n        this.packetInfo.action = StreamingFrameAction.Append; // mutates appended\n\n        appended = this.fields.map(f => f.values.buffer);\n        circPush(appended, values, this.options.maxLength, this.timeFieldIndex, this.options.maxDelta);\n      }\n\n      appended.forEach((v, i) => {\n        const {\n          state,\n          values\n        } = this.fields[i];\n        values.buffer = v;\n\n        if (state) {\n          state.calcs = undefined;\n        }\n      }); // Update the frame length\n\n      this.length = appended[0].length;\n    }\n\n    return Object.assign({}, this.packetInfo);\n  }\n\n  // adds a set of fields for a new label\n  addLabel(label) {\n    const {\n      displayNameFormat\n    } = this.options;\n    const labelCount = this.labels.size; // parse labels\n\n    const parsedLabels = parseLabelsFromField(label);\n\n    if (labelCount === 0) {\n      // mutate existing fields and add labels\n      this.fields.forEach((f, i) => {\n        if (i > 0) {\n          f.labels = parsedLabels;\n\n          if (displayNameFormat) {\n            const labels = Object.assign({\n              [PROM_STYLE_METRIC_LABEL]: f.name\n            }, parsedLabels);\n            f.config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n          }\n        }\n      });\n    } else {\n      for (let i = 1; i < this.schemaFields.length; i++) {\n        var _proto$config;\n\n        let proto = this.schemaFields[i];\n        const config = (_proto$config = proto.config) !== null && _proto$config !== void 0 ? _proto$config : {};\n\n        if (displayNameFormat) {\n          const labels = Object.assign({\n            [PROM_STYLE_METRIC_LABEL]: proto.name\n          }, parsedLabels);\n          config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n        }\n\n        this.fields.push(Object.assign({}, proto, {\n          config,\n          labels: parsedLabels,\n          values: new ArrayVector(Array(this.length).fill(undefined))\n        }));\n      }\n    }\n\n    this.labels.add(label);\n  }\n\n}\n\n_defineProperty(StreamingDataFrame, \"deserialize\", serialized => {\n  const frame = new StreamingDataFrame(serialized.options);\n  frame.initFromSerialized(serialized);\n  return frame;\n});\n\n_defineProperty(StreamingDataFrame, \"empty\", opts => new StreamingDataFrame(getStreamingFrameOptions(opts)));\n\n_defineProperty(StreamingDataFrame, \"fromDataFrameJSON\", (frame, opts) => {\n  const streamingDataFrame = new StreamingDataFrame(getStreamingFrameOptions(opts));\n  streamingDataFrame.push(frame);\n  return streamingDataFrame;\n});\n\nexport function getStreamingFrameOptions(opts) {\n  var _opts$maxLength, _opts$maxDelta, _opts$action;\n\n  return {\n    maxLength: (_opts$maxLength = opts === null || opts === void 0 ? void 0 : opts.maxLength) !== null && _opts$maxLength !== void 0 ? _opts$maxLength : 1000,\n    maxDelta: (_opts$maxDelta = opts === null || opts === void 0 ? void 0 : opts.maxDelta) !== null && _opts$maxDelta !== void 0 ? _opts$maxDelta : Infinity,\n    action: (_opts$action = opts === null || opts === void 0 ? void 0 : opts.action) !== null && _opts$action !== void 0 ? _opts$action : StreamingFrameAction.Append,\n    displayNameFormat: opts === null || opts === void 0 ? void 0 : opts.displayNameFormat\n  };\n} // converts vertical insertion records with table keys in [0] and column values in [1...N]\n// to join()-able tables with column arrays\n\nexport function transpose(vrecs) {\n  let tableKeys = new Set(vrecs[0]);\n  let tables = new Map();\n  tableKeys.forEach(key => {\n    let cols = Array(vrecs.length - 1).fill(null).map(() => []);\n    tables.set(key, cols);\n  });\n\n  for (let r = 0; r < vrecs[0].length; r++) {\n    let table = tables.get(vrecs[0][r]);\n\n    for (let c = 1; c < vrecs.length; c++) {\n      table[c - 1].push(vrecs[c][r]);\n    }\n  }\n\n  return tables;\n} // binary search for index of closest value\n\nexport function closestIdx(num, arr, lo, hi) {\n  let mid;\n  lo = lo || 0;\n  hi = hi || arr.length - 1;\n  let bitwise = hi <= 2147483647;\n\n  while (hi - lo > 1) {\n    mid = bitwise ? lo + hi >> 1 : Math.floor((lo + hi) / 2);\n\n    if (arr[mid] < num) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  if (num - arr[lo] <= arr[hi] - num) {\n    return lo;\n  }\n\n  return hi;\n}\nexport function parseLabelsFromField(str) {\n  if (!str.length) {\n    return {};\n  }\n\n  if (str.charAt(0) === '{') {\n    return parseLabels(str);\n  }\n\n  const parsedLabels = {};\n  str.split(',').forEach(kv => {\n    const [key, val] = kv.trim().split('=');\n    parsedLabels[key] = val;\n  });\n  return parsedLabels;\n}\n/**\n * @internal // not exported in yet\n */\n\nexport function getLastStreamingDataFramePacket(frame) {\n  const pi = frame.packetInfo;\n  return pi !== null && pi !== void 0 && pi.action ? pi : undefined;\n} // mutable circular push\n\nfunction circPush(data, newData, maxLength = Infinity, deltaIdx = 0, maxDelta = Infinity) {\n  for (let i = 0; i < data.length; i++) {\n    for (let k = 0; k < newData[i].length; k++) {\n      data[i].push(newData[i][k]);\n    }\n  }\n\n  return assureValuesAreWithinLengthLimit(data, maxLength, deltaIdx, maxDelta);\n}\n\nfunction assureValuesAreWithinLengthLimit(data, maxLength = Infinity, deltaIdx = 0, maxDelta = Infinity) {\n  const count = getNumberOfItemsToRemove(data, maxLength, deltaIdx, maxDelta);\n\n  if (count) {\n    for (let i = 0; i < data.length; i++) {\n      data[i].splice(0, count);\n    }\n  }\n\n  return count;\n}\n\nfunction getNumberOfItemsToRemove(data, maxLength = Infinity, deltaIdx = 0, maxDelta = Infinity) {\n  var _data$;\n\n  if (!((_data$ = data[0]) !== null && _data$ !== void 0 && _data$.length)) {\n    return 0;\n  }\n\n  const nlen = data[0].length;\n  let sliceIdx = 0;\n\n  if (nlen > maxLength) {\n    sliceIdx = nlen - maxLength;\n  }\n\n  if (maxDelta !== Infinity && deltaIdx >= 0) {\n    const deltaLookup = data[deltaIdx];\n    const low = deltaLookup[sliceIdx];\n    const high = deltaLookup[nlen - 1];\n\n    if (high - low > maxDelta) {\n      sliceIdx = closestIdx(high - maxDelta, deltaLookup, sliceIdx);\n    }\n  }\n\n  return sliceIdx;\n}\n\nfunction hasSameStructure(a, b) {\n  if ((a === null || a === void 0 ? void 0 : a.length) !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    const fA = a[i];\n    const fB = b[i];\n\n    if (fA.name !== fB.name || fA.type !== fB.type) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"names":["ArrayVector","decodeFieldValueEntities","FieldType","guessFieldTypeFromValue","parseLabels","toFilteredDataFrameDTO","join","StreamingFrameAction","renderLegendFormat","PROM_STYLE_METRIC_LABEL","PushMode","StreamingDataFrame","constructor","options","wide","Set","schemaChanged","number","action","Replace","length","fieldPredicate","optionsOverride","trimValues","Object","assign","dataFrameDTO","numberOfItemsToRemove","getNumberOfItemsToRemove","fields","map","f","values","maxLength","Math","min","timeFieldIndex","maxDelta","slice","labels","schemaFields","name","refId","meta","pushMode","packetInfo","serialized","type","other","config","Array","isArray","assureValuesAreWithinLengthLimit","buffer","needsMoreLength","needsBiggerDelta","needsToOverrideDefaultInfinityDelta","Infinity","Boolean","max","Append","circPush","forEach","v","i","newLength","undefined","state","calcs","range","index","filter","val","defineProperty","enumerable","alwaysReplace","push","msg","schema","data","findIndex","time","firstField","string","niceSchemaFields","displayNameFormat","hasSameStructure","len","idx","sf","displayNameFromDS","isWide","find","of","fill","entities","ents","labeledTables","transpose","label","keys","has","addLabel","dummyTable","tables","get","Error","vals","isTime","appended","labelCount","size","parsedLabels","parseLabelsFromField","proto","add","frame","initFromSerialized","opts","getStreamingFrameOptions","streamingDataFrame","vrecs","tableKeys","Map","key","cols","set","r","table","c","closestIdx","num","arr","lo","hi","mid","bitwise","floor","str","charAt","split","kv","trim","getLastStreamingDataFramePacket","pi","newData","deltaIdx","k","count","splice","nlen","sliceIdx","deltaLookup","low","high","a","b","fA","fB"],"sources":["/home/soula/grafana/public/app/features/live/data/StreamingDataFrame.ts"],"sourcesContent":["import {\n  ArrayVector,\n  DataFrame,\n  DataFrameJSON,\n  decodeFieldValueEntities,\n  Field,\n  FieldDTO,\n  FieldSchema,\n  FieldType,\n  guessFieldTypeFromValue,\n  Labels,\n  parseLabels,\n  QueryResultMeta,\n  toFilteredDataFrameDTO,\n} from '@grafana/data';\nimport { join } from '@grafana/data/src/transformations/transformers/joinDataFrames';\nimport { StreamingFrameAction, StreamingFrameOptions } from '@grafana/runtime/src/services/live';\nimport { renderLegendFormat } from 'app/plugins/datasource/prometheus/legend';\nimport { AlignedData } from 'uplot';\n\n/**\n * Stream packet info is attached to StreamingDataFrames and indicate how many\n * rows were added to the end of the frame.  The number of discarded rows can be\n * calculated from previous state\n */\nexport interface StreamPacketInfo {\n  number: number;\n  action: StreamingFrameAction;\n  length: number;\n  schemaChanged: boolean;\n}\n\nconst PROM_STYLE_METRIC_LABEL = '__name__';\n\nenum PushMode {\n  wide,\n  labels,\n  // long\n}\n\nexport type SerializedStreamingDataFrame = {\n  name?: string;\n  fields: FieldDTO[];\n  refId?: string;\n  meta: QueryResultMeta;\n  schemaFields: FieldSchema[];\n  timeFieldIndex: number;\n  pushMode: PushMode;\n  length: number;\n  packetInfo: StreamPacketInfo;\n  options: StreamingFrameOptions;\n  labels: Set<string>;\n};\n\n/**\n * Unlike a circular buffer, this will append and periodically slice the front\n */\nexport class StreamingDataFrame implements DataFrame {\n  name?: string;\n  refId?: string;\n  meta: QueryResultMeta = {};\n\n  fields: Array<Field<any, ArrayVector<any>>> = [];\n  length = 0;\n\n  private schemaFields: FieldSchema[] = [];\n  private timeFieldIndex = -1;\n  private pushMode = PushMode.wide;\n\n  // current labels\n  private labels: Set<string> = new Set();\n  readonly packetInfo: StreamPacketInfo = {\n    schemaChanged: true,\n    number: 0,\n    action: StreamingFrameAction.Replace,\n    length: 0,\n  };\n\n  private constructor(public options: StreamingFrameOptions) {\n    // Get Length to show up if you use spread\n    Object.defineProperty(this, 'length', {\n      enumerable: true,\n    });\n\n    // Get fields to show up if you use spread\n    Object.defineProperty(this, 'fields', {\n      enumerable: true,\n    });\n  }\n\n  serialize = (\n    fieldPredicate?: (f: Field) => boolean,\n    optionsOverride?: Partial<StreamingFrameOptions>,\n    trimValues?: {\n      maxLength?: number;\n    }\n  ): SerializedStreamingDataFrame => {\n    const options = optionsOverride ? Object.assign({}, { ...this.options, ...optionsOverride }) : this.options;\n    const dataFrameDTO = toFilteredDataFrameDTO(this, fieldPredicate);\n\n    const numberOfItemsToRemove = getNumberOfItemsToRemove(\n      dataFrameDTO.fields.map((f) => f.values) as unknown[][],\n      typeof trimValues?.maxLength === 'number' ? Math.min(trimValues.maxLength, options.maxLength) : options.maxLength,\n      this.timeFieldIndex,\n      options.maxDelta\n    );\n\n    dataFrameDTO.fields = dataFrameDTO.fields.map((f) => ({\n      ...f,\n      values: (f.values as unknown[]).slice(numberOfItemsToRemove),\n    }));\n\n    return {\n      ...dataFrameDTO,\n      // TODO: Labels and schema are not filtered by field\n      labels: this.labels,\n      schemaFields: this.schemaFields,\n\n      name: this.name,\n      refId: this.refId,\n      meta: this.meta,\n      length: this.length,\n      timeFieldIndex: this.timeFieldIndex,\n      pushMode: this.pushMode,\n      packetInfo: this.packetInfo,\n      options,\n    };\n  };\n\n  private initFromSerialized = (serialized: Omit<SerializedStreamingDataFrame, 'options'>) => {\n    this.name = serialized.name;\n    this.refId = serialized.refId;\n    this.meta = serialized.meta;\n    this.length = serialized.length;\n    this.labels = serialized.labels;\n    this.schemaFields = serialized.schemaFields;\n    this.timeFieldIndex = serialized.timeFieldIndex;\n    this.pushMode = serialized.pushMode;\n    this.packetInfo.length = serialized.packetInfo.length;\n    this.packetInfo.number = serialized.packetInfo.number;\n    this.packetInfo.action = StreamingFrameAction.Replace;\n    this.packetInfo.schemaChanged = true;\n    this.fields = serialized.fields.map((f) => ({\n      ...f,\n      type: f.type ?? FieldType.other,\n      config: f.config ?? {},\n      values: Array.isArray(f.values) ? new ArrayVector(f.values) : new ArrayVector(),\n    }));\n\n    assureValuesAreWithinLengthLimit(\n      this.fields.map((f) => f.values.buffer),\n      this.options.maxLength,\n      this.timeFieldIndex,\n      this.options.maxDelta\n    );\n  };\n\n  static deserialize = (serialized: SerializedStreamingDataFrame) => {\n    const frame = new StreamingDataFrame(serialized.options);\n    frame.initFromSerialized(serialized);\n    return frame;\n  };\n\n  static empty = (opts?: Partial<StreamingFrameOptions>): StreamingDataFrame =>\n    new StreamingDataFrame(getStreamingFrameOptions(opts));\n\n  static fromDataFrameJSON = (frame: DataFrameJSON, opts?: Partial<StreamingFrameOptions>): StreamingDataFrame => {\n    const streamingDataFrame = new StreamingDataFrame(getStreamingFrameOptions(opts));\n    streamingDataFrame.push(frame);\n    return streamingDataFrame;\n  };\n\n  private get alwaysReplace() {\n    return this.options.action === StreamingFrameAction.Replace;\n  }\n\n  needsResizing = ({ maxLength, maxDelta }: StreamingFrameOptions) => {\n    const needsMoreLength = maxLength && this.options.maxLength < maxLength;\n    const needsBiggerDelta = maxDelta && this.options.maxDelta < maxDelta;\n    const needsToOverrideDefaultInfinityDelta = maxDelta && this.options.maxDelta === Infinity;\n    return Boolean(needsMoreLength || needsBiggerDelta || needsToOverrideDefaultInfinityDelta);\n  };\n\n  resize = ({ maxLength, maxDelta }: Partial<StreamingFrameOptions>) => {\n    if (maxDelta) {\n      if (this.options.maxDelta === Infinity) {\n        this.options.maxDelta = maxDelta;\n      } else {\n        this.options.maxDelta = Math.max(maxDelta, this.options.maxDelta);\n      }\n    }\n    this.options.maxLength = Math.max(this.options.maxLength, maxLength ?? 0);\n  };\n\n  /**\n   * apply the new message to the existing data.  This will replace the existing schema\n   * if a new schema is included in the message, or append data matching the current schema\n   */\n  push(msg: DataFrameJSON): StreamPacketInfo {\n    const { schema, data } = msg;\n\n    this.packetInfo.number++;\n    this.packetInfo.length = 0;\n    this.packetInfo.schemaChanged = false;\n\n    if (schema) {\n      this.pushMode = PushMode.wide;\n      this.timeFieldIndex = schema.fields.findIndex((f) => f.type === FieldType.time);\n      const firstField = schema.fields[0];\n      if (\n        this.timeFieldIndex === 1 &&\n        firstField.type === FieldType.string &&\n        (firstField.name === 'labels' || firstField.name === 'Labels')\n      ) {\n        this.pushMode = PushMode.labels;\n        this.timeFieldIndex = 0; // after labels are removed!\n      }\n\n      const niceSchemaFields = this.pushMode === PushMode.labels ? schema.fields.slice(1) : schema.fields;\n\n      this.refId = schema.refId;\n      if (schema.meta) {\n        this.meta = { ...schema.meta };\n      }\n\n      const { displayNameFormat } = this.options;\n      if (hasSameStructure(this.schemaFields, niceSchemaFields)) {\n        const len = niceSchemaFields.length;\n        this.fields.forEach((f, idx) => {\n          const sf = niceSchemaFields[idx % len];\n          f.config = sf.config ?? {};\n          f.labels = sf.labels;\n        });\n        if (displayNameFormat) {\n          this.fields.forEach((f) => {\n            const labels = { [PROM_STYLE_METRIC_LABEL]: f.name, ...f.labels };\n            f.config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n          });\n        }\n      } else {\n        this.packetInfo.schemaChanged = true;\n        const isWide = this.pushMode === PushMode.wide;\n        this.fields = niceSchemaFields.map((f) => {\n          const config = f.config ?? {};\n          if (displayNameFormat) {\n            const labels = { [PROM_STYLE_METRIC_LABEL]: f.name, ...f.labels };\n            config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n          }\n          return {\n            config,\n            name: f.name,\n            labels: f.labels,\n            type: f.type ?? FieldType.other,\n            // transfer old values by type & name, unless we relied on labels to match fields\n            values: isWide\n              ? this.fields.find((of) => of.name === f.name && f.type === of.type)?.values ??\n                new ArrayVector(Array(this.length).fill(undefined))\n              : new ArrayVector(),\n          };\n        });\n      }\n\n      this.schemaFields = niceSchemaFields;\n    }\n\n    if (data && data.values.length && data.values[0].length) {\n      let { values, entities } = data;\n\n      if (entities) {\n        entities.forEach((ents, i) => {\n          if (ents) {\n            decodeFieldValueEntities(ents, values[i]);\n            // TODO: append replacements to field\n          }\n        });\n      }\n\n      if (this.pushMode === PushMode.labels) {\n        // augment and transform data to match current schema for standard circPush() path\n        const labeledTables = transpose(values);\n\n        // make sure fields are initalized for each label\n        for (const label of labeledTables.keys()) {\n          if (!this.labels.has(label)) {\n            this.packetInfo.schemaChanged = true;\n            this.addLabel(label);\n          }\n        }\n\n        // TODO: cache higher up\n        let dummyTable = Array(this.schemaFields.length).fill([]);\n\n        let tables: AlignedData[] = [];\n        this.labels.forEach((label) => {\n          tables.push(labeledTables.get(label) ?? dummyTable);\n        });\n\n        values = join(tables);\n      }\n\n      if (values.length !== this.fields.length) {\n        if (this.fields.length) {\n          throw new Error(\n            `push message mismatch.  Expected: ${this.fields.length}, received: ${values.length} (labels=${\n              this.pushMode === PushMode.labels\n            })`\n          );\n        }\n\n        this.fields = values.map((vals, idx) => {\n          let name = `Field ${idx}`;\n          let type = guessFieldTypeFromValue(vals[0]);\n          const isTime = idx === 0 && type === FieldType.number && vals[0] > 1600016688632;\n          if (isTime) {\n            type = FieldType.time;\n            name = 'Time';\n          }\n\n          return {\n            name,\n            type,\n            config: {},\n            values: new ArrayVector([]),\n          };\n        });\n      }\n\n      let appended = values;\n      this.packetInfo.length = values[0].length;\n\n      if (this.alwaysReplace || !this.length) {\n        this.packetInfo.action = StreamingFrameAction.Replace;\n      } else {\n        this.packetInfo.action = StreamingFrameAction.Append;\n\n        // mutates appended\n        appended = this.fields.map((f) => f.values.buffer);\n        circPush(appended, values, this.options.maxLength, this.timeFieldIndex, this.options.maxDelta);\n      }\n\n      appended.forEach((v, i) => {\n        const { state, values } = this.fields[i];\n        values.buffer = v;\n        if (state) {\n          state.calcs = undefined;\n        }\n      });\n\n      // Update the frame length\n      this.length = appended[0].length;\n    }\n\n    return {\n      ...this.packetInfo,\n    };\n  }\n\n  pushNewValues = (values: unknown[][]) => {\n    if (!values?.length) {\n      return;\n    }\n\n    this.packetInfo.action = this.options.action;\n    this.packetInfo.number++;\n    this.packetInfo.length = values[0].length;\n    this.packetInfo.schemaChanged = false;\n\n    if (this.options.action === StreamingFrameAction.Append) {\n      circPush(\n        this.fields.map((f) => f.values.buffer),\n        values,\n        this.options.maxLength,\n        this.timeFieldIndex,\n        this.options.maxDelta\n      );\n    } else {\n      values.forEach((v, i) => {\n        if (this.fields[i]?.values) {\n          this.fields[i].values.buffer = v;\n        }\n      });\n\n      assureValuesAreWithinLengthLimit(\n        this.fields.map((f) => f.values.buffer),\n        this.options.maxLength,\n        this.timeFieldIndex,\n        this.options.maxDelta\n      );\n    }\n    const newLength = this.fields?.[0]?.values?.buffer?.length;\n    if (newLength !== undefined) {\n      this.length = newLength;\n    }\n  };\n\n  resetStateCalculations = () => {\n    this.fields.forEach((f) => {\n      f.state = {\n        ...(f.state ?? {}),\n        calcs: undefined,\n        range: undefined,\n      };\n    });\n  };\n\n  getMatchingFieldIndexes = (fieldPredicate: (f: Field) => boolean): number[] =>\n    this.fields\n      .map((f, index) => (fieldPredicate(f) ? index : undefined))\n      .filter((val) => val !== undefined) as number[];\n\n  getValuesFromLastPacket = (): unknown[][] =>\n    this.fields.map((f) => {\n      const values = f.values.buffer;\n      return values.slice(Math.max(values.length - this.packetInfo.length));\n    });\n\n  hasAtLeastOnePacket = () => Boolean(this.packetInfo.length);\n\n  // adds a set of fields for a new label\n  private addLabel(label: string) {\n    const { displayNameFormat } = this.options;\n    const labelCount = this.labels.size;\n\n    // parse labels\n    const parsedLabels = parseLabelsFromField(label);\n\n    if (labelCount === 0) {\n      // mutate existing fields and add labels\n      this.fields.forEach((f, i) => {\n        if (i > 0) {\n          f.labels = parsedLabels;\n          if (displayNameFormat) {\n            const labels = { [PROM_STYLE_METRIC_LABEL]: f.name, ...parsedLabels };\n            f.config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n          }\n        }\n      });\n    } else {\n      for (let i = 1; i < this.schemaFields.length; i++) {\n        let proto = this.schemaFields[i] as Field;\n        const config = proto.config ?? {};\n        if (displayNameFormat) {\n          const labels = { [PROM_STYLE_METRIC_LABEL]: proto.name, ...parsedLabels };\n          config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n        }\n        this.fields.push({\n          ...proto,\n          config,\n          labels: parsedLabels,\n          values: new ArrayVector(Array(this.length).fill(undefined)),\n        });\n      }\n    }\n\n    this.labels.add(label);\n  }\n\n  getOptions = (): Readonly<StreamingFrameOptions> => this.options;\n}\n\nexport function getStreamingFrameOptions(opts?: Partial<StreamingFrameOptions>): StreamingFrameOptions {\n  return {\n    maxLength: opts?.maxLength ?? 1000,\n    maxDelta: opts?.maxDelta ?? Infinity,\n    action: opts?.action ?? StreamingFrameAction.Append,\n    displayNameFormat: opts?.displayNameFormat,\n  };\n}\n\n// converts vertical insertion records with table keys in [0] and column values in [1...N]\n// to join()-able tables with column arrays\nexport function transpose(vrecs: any[][]) {\n  let tableKeys = new Set(vrecs[0]);\n  let tables = new Map();\n\n  tableKeys.forEach((key) => {\n    let cols = Array(vrecs.length - 1)\n      .fill(null)\n      .map(() => []);\n\n    tables.set(key, cols);\n  });\n\n  for (let r = 0; r < vrecs[0].length; r++) {\n    let table = tables.get(vrecs[0][r]);\n    for (let c = 1; c < vrecs.length; c++) {\n      table[c - 1].push(vrecs[c][r]);\n    }\n  }\n\n  return tables;\n}\n\n// binary search for index of closest value\nexport function closestIdx(num: number, arr: number[], lo?: number, hi?: number) {\n  let mid;\n  lo = lo || 0;\n  hi = hi || arr.length - 1;\n  let bitwise = hi <= 2147483647;\n\n  while (hi - lo > 1) {\n    mid = bitwise ? (lo + hi) >> 1 : Math.floor((lo + hi) / 2);\n\n    if (arr[mid] < num) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  if (num - arr[lo] <= arr[hi] - num) {\n    return lo;\n  }\n\n  return hi;\n}\n\nexport function parseLabelsFromField(str: string): Labels {\n  if (!str.length) {\n    return {};\n  }\n  if (str.charAt(0) === '{') {\n    return parseLabels(str);\n  }\n  const parsedLabels: Labels = {};\n  str.split(',').forEach((kv) => {\n    const [key, val] = kv.trim().split('=');\n    parsedLabels[key] = val;\n  });\n  return parsedLabels;\n}\n\n/**\n * @internal // not exported in yet\n */\nexport function getLastStreamingDataFramePacket(frame: DataFrame) {\n  const pi = (frame as StreamingDataFrame).packetInfo;\n  return pi?.action ? pi : undefined;\n}\n\n// mutable circular push\nfunction circPush(data: unknown[][], newData: unknown[][], maxLength = Infinity, deltaIdx = 0, maxDelta = Infinity) {\n  for (let i = 0; i < data.length; i++) {\n    for (let k = 0; k < newData[i].length; k++) {\n      data[i].push(newData[i][k]);\n    }\n  }\n\n  return assureValuesAreWithinLengthLimit(data, maxLength, deltaIdx, maxDelta);\n}\n\nfunction assureValuesAreWithinLengthLimit(data: unknown[][], maxLength = Infinity, deltaIdx = 0, maxDelta = Infinity) {\n  const count = getNumberOfItemsToRemove(data, maxLength, deltaIdx, maxDelta);\n\n  if (count) {\n    for (let i = 0; i < data.length; i++) {\n      data[i].splice(0, count);\n    }\n  }\n\n  return count;\n}\n\nfunction getNumberOfItemsToRemove(data: unknown[][], maxLength = Infinity, deltaIdx = 0, maxDelta = Infinity) {\n  if (!data[0]?.length) {\n    return 0;\n  }\n\n  const nlen = data[0].length;\n\n  let sliceIdx = 0;\n\n  if (nlen > maxLength) {\n    sliceIdx = nlen - maxLength;\n  }\n\n  if (maxDelta !== Infinity && deltaIdx >= 0) {\n    const deltaLookup = data[deltaIdx] as number[];\n\n    const low = deltaLookup[sliceIdx];\n    const high = deltaLookup[nlen - 1];\n\n    if (high - low > maxDelta) {\n      sliceIdx = closestIdx(high - maxDelta, deltaLookup, sliceIdx);\n    }\n  }\n\n  return sliceIdx;\n}\n\nfunction hasSameStructure(a: FieldSchema[], b: FieldSchema[]): boolean {\n  if (a?.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    const fA = a[i];\n    const fB = b[i];\n    if (fA.name !== fB.name || fA.type !== fB.type) {\n      return false;\n    }\n  }\n  return true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}