{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport angular from 'angular';\nimport { clone, compact, each, every, filter, findIndex, has, includes, isArray, isEmpty, map as _map, toPairs } from 'lodash';\nimport { lastValueFrom, of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { DataSourceApi, dateMath } from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { getTemplateSrv } from 'app/features/templating/template_srv';\nexport default class OpenTsDatasource extends DataSourceApi {\n  constructor(instanceSettings, templateSrv = getTemplateSrv()) {\n    super(instanceSettings);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"withCredentials\", void 0);\n\n    _defineProperty(this, \"basicAuth\", void 0);\n\n    _defineProperty(this, \"tsdbVersion\", void 0);\n\n    _defineProperty(this, \"tsdbResolution\", void 0);\n\n    _defineProperty(this, \"lookupLimit\", void 0);\n\n    _defineProperty(this, \"tagKeys\", void 0);\n\n    _defineProperty(this, \"aggregatorsPromise\", void 0);\n\n    _defineProperty(this, \"filterTypesPromise\", void 0);\n\n    this.templateSrv = templateSrv;\n    this.type = 'opentsdb';\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.basicAuth = instanceSettings.basicAuth;\n    instanceSettings.jsonData = instanceSettings.jsonData || {};\n    this.tsdbVersion = instanceSettings.jsonData.tsdbVersion || 1;\n    this.tsdbResolution = instanceSettings.jsonData.tsdbResolution || 1;\n    this.lookupLimit = instanceSettings.jsonData.lookupLimit || 1000;\n    this.tagKeys = {};\n    this.aggregatorsPromise = null;\n    this.filterTypesPromise = null;\n  } // Called once per panel (graph)\n\n\n  query(options) {\n    const start = this.convertToTSDBTime(options.range.raw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.range.raw.to, true, options.timezone);\n    const qs = [];\n    each(options.targets, target => {\n      if (!target.metric) {\n        return;\n      }\n\n      qs.push(this.convertTargetToQuery(target, options, this.tsdbVersion));\n    });\n    const queries = compact(qs); // No valid targets, return the empty result to save a round trip.\n\n    if (isEmpty(queries)) {\n      return of({\n        data: []\n      });\n    }\n\n    const groupByTags = {};\n    each(queries, query => {\n      if (query.filters && query.filters.length > 0) {\n        each(query.filters, val => {\n          groupByTags[val.tagk] = true;\n        });\n      } else {\n        each(query.tags, (val, key) => {\n          groupByTags[key] = true;\n        });\n      }\n    });\n    options.targets = filter(options.targets, query => {\n      return query.hide !== true;\n    });\n    return this.performTimeSeriesQuery(queries, start, end).pipe(catchError(err => {\n      var _err$data, _err$data$error;\n\n      // Throw the error message here instead of the whole object to workaround the error parsing error.\n      throw (err === null || err === void 0 ? void 0 : (_err$data = err.data) === null || _err$data === void 0 ? void 0 : (_err$data$error = _err$data.error) === null || _err$data$error === void 0 ? void 0 : _err$data$error.message) || 'Error performing time series query.';\n    }), map(response => {\n      const metricToTargetMapping = this.mapMetricsToTargets(response.data, options, this.tsdbVersion);\n\n      const result = _map(response.data, (metricData, index) => {\n        index = metricToTargetMapping[index];\n\n        if (index === -1) {\n          index = 0;\n        }\n\n        this._saveTagKeys(metricData);\n\n        return this.transformMetricData(metricData, groupByTags, options.targets[index], options, this.tsdbResolution);\n      });\n\n      return {\n        data: result\n      };\n    }));\n  }\n\n  annotationQuery(options) {\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\n    const qs = [];\n    const eventList = [];\n    qs.push({\n      aggregator: 'sum',\n      metric: options.annotation.target\n    });\n    const queries = compact(qs);\n    return lastValueFrom(this.performTimeSeriesQuery(queries, start, end).pipe(map(results => {\n      if (results.data[0]) {\n        let annotationObject = results.data[0].annotations;\n\n        if (options.annotation.isGlobal) {\n          annotationObject = results.data[0].globalAnnotations;\n        }\n\n        if (annotationObject) {\n          each(annotationObject, annotation => {\n            const event = {\n              text: annotation.description,\n              time: Math.floor(annotation.startTime) * 1000,\n              annotation: options.annotation\n            };\n            eventList.push(event);\n          });\n        }\n      }\n\n      return eventList;\n    })));\n  }\n\n  targetContainsTemplate(target) {\n    if (target.filters && target.filters.length > 0) {\n      for (let i = 0; i < target.filters.length; i++) {\n        if (this.templateSrv.containsTemplate(target.filters[i].filter)) {\n          return true;\n        }\n      }\n    }\n\n    if (target.tags && Object.keys(target.tags).length > 0) {\n      for (const tagKey in target.tags) {\n        if (this.templateSrv.containsTemplate(target.tags[tagKey])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  performTimeSeriesQuery(queries, start, end) {\n    let msResolution = false;\n\n    if (this.tsdbResolution === 2) {\n      msResolution = true;\n    }\n\n    const reqBody = {\n      start: start,\n      queries: queries,\n      msResolution: msResolution,\n      globalAnnotations: true\n    };\n\n    if (this.tsdbVersion === 3) {\n      reqBody.showQuery = true;\n    } // Relative queries (e.g. last hour) don't include an end time\n\n\n    if (end) {\n      reqBody.end = end;\n    }\n\n    const options = {\n      method: 'POST',\n      url: this.url + '/api/query',\n      data: reqBody\n    };\n\n    this._addCredentialOptions(options);\n\n    return getBackendSrv().fetch(options);\n  }\n\n  suggestTagKeys(metric) {\n    return Promise.resolve(this.tagKeys[metric] || []);\n  }\n\n  _saveTagKeys(metricData) {\n    const tagKeys = Object.keys(metricData.tags);\n    each(metricData.aggregateTags, tag => {\n      tagKeys.push(tag);\n    });\n    this.tagKeys[metricData.metric] = tagKeys;\n  }\n\n  _performSuggestQuery(query, type) {\n    return this._get('/api/suggest', {\n      type,\n      q: query,\n      max: this.lookupLimit\n    }).pipe(map(result => {\n      return result.data;\n    }));\n  }\n\n  _performMetricKeyValueLookup(metric, keys) {\n    if (!metric || !keys) {\n      return of([]);\n    }\n\n    const keysArray = keys.split(',').map(key => {\n      return key.trim();\n    });\n    const key = keysArray[0];\n    let keysQuery = key + '=*';\n\n    if (keysArray.length > 1) {\n      keysQuery += ',' + keysArray.splice(1).join(',');\n    }\n\n    const m = metric + '{' + keysQuery + '}';\n    return this._get('/api/search/lookup', {\n      m: m,\n      limit: this.lookupLimit\n    }).pipe(map(result => {\n      result = result.data.results;\n      const tagvs = [];\n      each(result, r => {\n        if (tagvs.indexOf(r.tags[key]) === -1) {\n          tagvs.push(r.tags[key]);\n        }\n      });\n      return tagvs;\n    }));\n  }\n\n  _performMetricKeyLookup(metric) {\n    if (!metric) {\n      return of([]);\n    }\n\n    return this._get('/api/search/lookup', {\n      m: metric,\n      limit: 1000\n    }).pipe(map(result => {\n      result = result.data.results;\n      const tagks = [];\n      each(result, r => {\n        each(r.tags, (tagv, tagk) => {\n          if (tagks.indexOf(tagk) === -1) {\n            tagks.push(tagk);\n          }\n        });\n      });\n      return tagks;\n    }));\n  }\n\n  _get(relativeUrl, params) {\n    const options = {\n      method: 'GET',\n      url: this.url + relativeUrl,\n      params: params\n    };\n\n    this._addCredentialOptions(options);\n\n    return getBackendSrv().fetch(options);\n  }\n\n  _addCredentialOptions(options) {\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n\n    if (this.basicAuth) {\n      options.headers = {\n        Authorization: this.basicAuth\n      };\n    }\n  }\n\n  metricFindQuery(query) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    let interpolated;\n\n    try {\n      interpolated = this.templateSrv.replace(query, {}, 'distributed');\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    const responseTransform = result => {\n      return _map(result, value => {\n        return {\n          text: value\n        };\n      });\n    };\n\n    const metricsRegex = /metrics\\((.*)\\)/;\n    const tagNamesRegex = /tag_names\\((.*)\\)/;\n    const tagValuesRegex = /tag_values\\((.*?),\\s?(.*)\\)/;\n    const tagNamesSuggestRegex = /suggest_tagk\\((.*)\\)/;\n    const tagValuesSuggestRegex = /suggest_tagv\\((.*)\\)/;\n    const metricsQuery = interpolated.match(metricsRegex);\n\n    if (metricsQuery) {\n      return lastValueFrom(this._performSuggestQuery(metricsQuery[1], 'metrics').pipe(map(responseTransform)));\n    }\n\n    const tagNamesQuery = interpolated.match(tagNamesRegex);\n\n    if (tagNamesQuery) {\n      return lastValueFrom(this._performMetricKeyLookup(tagNamesQuery[1]).pipe(map(responseTransform)));\n    }\n\n    const tagValuesQuery = interpolated.match(tagValuesRegex);\n\n    if (tagValuesQuery) {\n      return lastValueFrom(this._performMetricKeyValueLookup(tagValuesQuery[1], tagValuesQuery[2]).pipe(map(responseTransform)));\n    }\n\n    const tagNamesSuggestQuery = interpolated.match(tagNamesSuggestRegex);\n\n    if (tagNamesSuggestQuery) {\n      return lastValueFrom(this._performSuggestQuery(tagNamesSuggestQuery[1], 'tagk').pipe(map(responseTransform)));\n    }\n\n    const tagValuesSuggestQuery = interpolated.match(tagValuesSuggestRegex);\n\n    if (tagValuesSuggestQuery) {\n      return lastValueFrom(this._performSuggestQuery(tagValuesSuggestQuery[1], 'tagv').pipe(map(responseTransform)));\n    }\n\n    return Promise.resolve([]);\n  }\n\n  testDatasource() {\n    return lastValueFrom(this._performSuggestQuery('cpu', 'metrics').pipe(map(() => {\n      return {\n        status: 'success',\n        message: 'Data source is working'\n      };\n    })));\n  }\n\n  getAggregators() {\n    if (this.aggregatorsPromise) {\n      return this.aggregatorsPromise;\n    }\n\n    this.aggregatorsPromise = lastValueFrom(this._get('/api/aggregators').pipe(map(result => {\n      if (result.data && isArray(result.data)) {\n        return result.data.sort();\n      }\n\n      return [];\n    })));\n    return this.aggregatorsPromise;\n  }\n\n  getFilterTypes() {\n    if (this.filterTypesPromise) {\n      return this.filterTypesPromise;\n    }\n\n    this.filterTypesPromise = lastValueFrom(this._get('/api/config/filters').pipe(map(result => {\n      if (result.data) {\n        return Object.keys(result.data).sort();\n      }\n\n      return [];\n    })));\n    return this.filterTypesPromise;\n  }\n\n  transformMetricData(md, groupByTags, target, options, tsdbResolution) {\n    const metricLabel = this.createMetricLabel(md, target, groupByTags, options);\n    const dps = []; // TSDB returns datapoints has a hash of ts => value.\n    // Can't use pairs(invert()) because it stringifies keys/values\n\n    each(md.dps, (v, k) => {\n      if (tsdbResolution === 2) {\n        dps.push([v, k * 1]);\n      } else {\n        dps.push([v, k * 1000]);\n      }\n    });\n    return {\n      target: metricLabel,\n      datapoints: dps\n    };\n  }\n\n  createMetricLabel(md, target, groupByTags, options) {\n    if (target.alias) {\n      const scopedVars = clone(options.scopedVars || {});\n      each(md.tags, (value, key) => {\n        scopedVars['tag_' + key] = {\n          value: value\n        };\n      });\n      return this.templateSrv.replace(target.alias, scopedVars);\n    }\n\n    let label = md.metric;\n    const tagData = [];\n\n    if (!isEmpty(md.tags)) {\n      each(toPairs(md.tags), tag => {\n        if (has(groupByTags, tag[0])) {\n          tagData.push(tag[0] + '=' + tag[1]);\n        }\n      });\n    }\n\n    if (!isEmpty(tagData)) {\n      label += '{' + tagData.join(', ') + '}';\n    }\n\n    return label;\n  }\n\n  convertTargetToQuery(target, options, tsdbVersion) {\n    if (!target.metric || target.hide) {\n      return null;\n    }\n\n    const query = {\n      metric: this.templateSrv.replace(target.metric, options.scopedVars, 'pipe'),\n      aggregator: 'avg'\n    };\n\n    if (target.aggregator) {\n      query.aggregator = this.templateSrv.replace(target.aggregator);\n    }\n\n    if (target.shouldComputeRate) {\n      query.rate = true;\n      query.rateOptions = {\n        counter: !!target.isCounter\n      };\n\n      if (target.counterMax && target.counterMax.length) {\n        query.rateOptions.counterMax = parseInt(target.counterMax, 10);\n      }\n\n      if (target.counterResetValue && target.counterResetValue.length) {\n        query.rateOptions.resetValue = parseInt(target.counterResetValue, 10);\n      }\n\n      if (tsdbVersion >= 2) {\n        query.rateOptions.dropResets = !query.rateOptions.counterMax && (!query.rateOptions.ResetValue || query.rateOptions.ResetValue === 0);\n      }\n    }\n\n    if (!target.disableDownsampling) {\n      let interval = this.templateSrv.replace(target.downsampleInterval || options.interval);\n\n      if (interval.match(/\\.[0-9]+s/)) {\n        interval = parseFloat(interval) * 1000 + 'ms';\n      }\n\n      query.downsample = interval + '-' + target.downsampleAggregator;\n\n      if (target.downsampleFillPolicy && target.downsampleFillPolicy !== 'none') {\n        query.downsample += '-' + target.downsampleFillPolicy;\n      }\n    }\n\n    if (target.filters && target.filters.length > 0) {\n      query.filters = angular.copy(target.filters);\n\n      if (query.filters) {\n        for (const filterKey in query.filters) {\n          query.filters[filterKey].filter = this.templateSrv.replace(query.filters[filterKey].filter, options.scopedVars, 'pipe');\n        }\n      }\n    } else {\n      query.tags = angular.copy(target.tags);\n\n      if (query.tags) {\n        for (const tagKey in query.tags) {\n          query.tags[tagKey] = this.templateSrv.replace(query.tags[tagKey], options.scopedVars, 'pipe');\n        }\n      }\n    }\n\n    if (target.explicitTags) {\n      query.explicitTags = true;\n    }\n\n    return query;\n  }\n\n  mapMetricsToTargets(metrics, options, tsdbVersion) {\n    let interpolatedTagValue, arrTagV;\n    return _map(metrics, metricData => {\n      if (tsdbVersion === 3) {\n        return metricData.query.index;\n      } else {\n        return findIndex(options.targets, target => {\n          if (target.filters && target.filters.length > 0) {\n            return target.metric === metricData.metric;\n          } else {\n            return target.metric === metricData.metric && every(target.tags, (tagV, tagK) => {\n              interpolatedTagValue = this.templateSrv.replace(tagV, options.scopedVars, 'pipe');\n              arrTagV = interpolatedTagValue.split('|');\n              return includes(arrTagV, metricData.tags[tagK]) || interpolatedTagValue === '*';\n            });\n          }\n        });\n      }\n    });\n  }\n\n  interpolateVariablesInQueries(queries, scopedVars) {\n    if (!queries.length) {\n      return queries;\n    }\n\n    return queries.map(query => Object.assign({}, query, {\n      metric: this.templateSrv.replace(query.metric, scopedVars)\n    }));\n  }\n\n  convertToTSDBTime(date, roundUp, timezone) {\n    if (date === 'now') {\n      return null;\n    }\n\n    date = dateMath.parse(date, roundUp, timezone);\n    return date.valueOf();\n  }\n\n}","map":{"version":3,"names":["angular","clone","compact","each","every","filter","findIndex","has","includes","isArray","isEmpty","map","_map","toPairs","lastValueFrom","of","catchError","DataSourceApi","dateMath","getBackendSrv","getTemplateSrv","OpenTsDatasource","constructor","instanceSettings","templateSrv","type","url","name","withCredentials","basicAuth","jsonData","tsdbVersion","tsdbResolution","lookupLimit","tagKeys","aggregatorsPromise","filterTypesPromise","query","options","start","convertToTSDBTime","range","raw","from","timezone","end","to","qs","targets","target","metric","push","convertTargetToQuery","queries","data","groupByTags","filters","length","val","tagk","tags","key","hide","performTimeSeriesQuery","pipe","err","error","message","response","metricToTargetMapping","mapMetricsToTargets","result","metricData","index","_saveTagKeys","transformMetricData","annotationQuery","rangeRaw","eventList","aggregator","annotation","results","annotationObject","annotations","isGlobal","globalAnnotations","event","text","description","time","Math","floor","startTime","targetContainsTemplate","i","containsTemplate","Object","keys","tagKey","msResolution","reqBody","showQuery","method","_addCredentialOptions","fetch","suggestTagKeys","Promise","resolve","aggregateTags","tag","_performSuggestQuery","_get","q","max","_performMetricKeyValueLookup","keysArray","split","trim","keysQuery","splice","join","m","limit","tagvs","r","indexOf","_performMetricKeyLookup","tagks","tagv","relativeUrl","params","headers","Authorization","metricFindQuery","interpolated","replace","reject","responseTransform","value","metricsRegex","tagNamesRegex","tagValuesRegex","tagNamesSuggestRegex","tagValuesSuggestRegex","metricsQuery","match","tagNamesQuery","tagValuesQuery","tagNamesSuggestQuery","tagValuesSuggestQuery","testDatasource","status","getAggregators","sort","getFilterTypes","md","metricLabel","createMetricLabel","dps","v","k","datapoints","alias","scopedVars","label","tagData","shouldComputeRate","rate","rateOptions","counter","isCounter","counterMax","parseInt","counterResetValue","resetValue","dropResets","ResetValue","disableDownsampling","interval","downsampleInterval","parseFloat","downsample","downsampleAggregator","downsampleFillPolicy","copy","filterKey","explicitTags","metrics","interpolatedTagValue","arrTagV","tagV","tagK","interpolateVariablesInQueries","date","roundUp","parse","valueOf"],"sources":["/home/soula/grafana/public/app/plugins/datasource/opentsdb/datasource.ts"],"sourcesContent":["import angular from 'angular';\nimport {\n  clone,\n  compact,\n  each,\n  every,\n  filter,\n  findIndex,\n  has,\n  includes,\n  isArray,\n  isEmpty,\n  map as _map,\n  toPairs,\n} from 'lodash';\nimport { lastValueFrom, Observable, of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\n\nimport {\n  AnnotationEvent,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  dateMath,\n  ScopedVars,\n} from '@grafana/data';\nimport { FetchResponse, getBackendSrv } from '@grafana/runtime';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\n\nimport { OpenTsdbOptions, OpenTsdbQuery } from './types';\n\nexport default class OpenTsDatasource extends DataSourceApi<OpenTsdbQuery, OpenTsdbOptions> {\n  type: any;\n  url: any;\n  name: any;\n  withCredentials: any;\n  basicAuth: any;\n  tsdbVersion: any;\n  tsdbResolution: any;\n  lookupLimit: any;\n  tagKeys: any;\n\n  aggregatorsPromise: any;\n  filterTypesPromise: any;\n\n  constructor(instanceSettings: any, private readonly templateSrv: TemplateSrv = getTemplateSrv()) {\n    super(instanceSettings);\n    this.type = 'opentsdb';\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.basicAuth = instanceSettings.basicAuth;\n    instanceSettings.jsonData = instanceSettings.jsonData || {};\n    this.tsdbVersion = instanceSettings.jsonData.tsdbVersion || 1;\n    this.tsdbResolution = instanceSettings.jsonData.tsdbResolution || 1;\n    this.lookupLimit = instanceSettings.jsonData.lookupLimit || 1000;\n    this.tagKeys = {};\n\n    this.aggregatorsPromise = null;\n    this.filterTypesPromise = null;\n  }\n\n  // Called once per panel (graph)\n  query(options: DataQueryRequest<OpenTsdbQuery>): Observable<DataQueryResponse> {\n    const start = this.convertToTSDBTime(options.range.raw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.range.raw.to, true, options.timezone);\n    const qs: any[] = [];\n\n    each(options.targets, (target) => {\n      if (!target.metric) {\n        return;\n      }\n      qs.push(this.convertTargetToQuery(target, options, this.tsdbVersion));\n    });\n\n    const queries = compact(qs);\n\n    // No valid targets, return the empty result to save a round trip.\n    if (isEmpty(queries)) {\n      return of({ data: [] });\n    }\n\n    const groupByTags: any = {};\n    each(queries, (query) => {\n      if (query.filters && query.filters.length > 0) {\n        each(query.filters, (val) => {\n          groupByTags[val.tagk] = true;\n        });\n      } else {\n        each(query.tags, (val, key) => {\n          groupByTags[key] = true;\n        });\n      }\n    });\n\n    options.targets = filter(options.targets, (query) => {\n      return query.hide !== true;\n    });\n\n    return this.performTimeSeriesQuery(queries, start, end).pipe(\n      catchError((err) => {\n        // Throw the error message here instead of the whole object to workaround the error parsing error.\n        throw err?.data?.error?.message || 'Error performing time series query.';\n      }),\n      map((response) => {\n        const metricToTargetMapping = this.mapMetricsToTargets(response.data, options, this.tsdbVersion);\n        const result = _map(response.data, (metricData: any, index: number) => {\n          index = metricToTargetMapping[index];\n          if (index === -1) {\n            index = 0;\n          }\n          this._saveTagKeys(metricData);\n\n          return this.transformMetricData(\n            metricData,\n            groupByTags,\n            options.targets[index],\n            options,\n            this.tsdbResolution\n          );\n        });\n        return { data: result };\n      })\n    );\n  }\n\n  annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\n    const qs = [];\n    const eventList: any[] = [];\n\n    qs.push({ aggregator: 'sum', metric: options.annotation.target });\n\n    const queries = compact(qs);\n\n    return lastValueFrom(\n      this.performTimeSeriesQuery(queries, start, end).pipe(\n        map((results) => {\n          if (results.data[0]) {\n            let annotationObject = results.data[0].annotations;\n            if (options.annotation.isGlobal) {\n              annotationObject = results.data[0].globalAnnotations;\n            }\n            if (annotationObject) {\n              each(annotationObject, (annotation) => {\n                const event = {\n                  text: annotation.description,\n                  time: Math.floor(annotation.startTime) * 1000,\n                  annotation: options.annotation,\n                };\n\n                eventList.push(event);\n              });\n            }\n          }\n          return eventList;\n        })\n      )\n    );\n  }\n\n  targetContainsTemplate(target: any) {\n    if (target.filters && target.filters.length > 0) {\n      for (let i = 0; i < target.filters.length; i++) {\n        if (this.templateSrv.containsTemplate(target.filters[i].filter)) {\n          return true;\n        }\n      }\n    }\n\n    if (target.tags && Object.keys(target.tags).length > 0) {\n      for (const tagKey in target.tags) {\n        if (this.templateSrv.containsTemplate(target.tags[tagKey])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  performTimeSeriesQuery(queries: any[], start: any, end: any): Observable<FetchResponse> {\n    let msResolution = false;\n    if (this.tsdbResolution === 2) {\n      msResolution = true;\n    }\n    const reqBody: any = {\n      start: start,\n      queries: queries,\n      msResolution: msResolution,\n      globalAnnotations: true,\n    };\n    if (this.tsdbVersion === 3) {\n      reqBody.showQuery = true;\n    }\n\n    // Relative queries (e.g. last hour) don't include an end time\n    if (end) {\n      reqBody.end = end;\n    }\n\n    const options = {\n      method: 'POST',\n      url: this.url + '/api/query',\n      data: reqBody,\n    };\n\n    this._addCredentialOptions(options);\n    return getBackendSrv().fetch(options);\n  }\n\n  suggestTagKeys(metric: string | number) {\n    return Promise.resolve(this.tagKeys[metric] || []);\n  }\n\n  _saveTagKeys(metricData: { tags: {}; aggregateTags: any; metric: string | number }) {\n    const tagKeys = Object.keys(metricData.tags);\n    each(metricData.aggregateTags, (tag) => {\n      tagKeys.push(tag);\n    });\n\n    this.tagKeys[metricData.metric] = tagKeys;\n  }\n\n  _performSuggestQuery(query: string, type: string): Observable<any> {\n    return this._get('/api/suggest', { type, q: query, max: this.lookupLimit }).pipe(\n      map((result: any) => {\n        return result.data;\n      })\n    );\n  }\n\n  _performMetricKeyValueLookup(metric: string, keys: any): Observable<any[]> {\n    if (!metric || !keys) {\n      return of([]);\n    }\n\n    const keysArray = keys.split(',').map((key: any) => {\n      return key.trim();\n    });\n    const key = keysArray[0];\n    let keysQuery = key + '=*';\n\n    if (keysArray.length > 1) {\n      keysQuery += ',' + keysArray.splice(1).join(',');\n    }\n\n    const m = metric + '{' + keysQuery + '}';\n\n    return this._get('/api/search/lookup', { m: m, limit: this.lookupLimit }).pipe(\n      map((result: any) => {\n        result = result.data.results;\n        const tagvs: any[] = [];\n        each(result, (r) => {\n          if (tagvs.indexOf(r.tags[key]) === -1) {\n            tagvs.push(r.tags[key]);\n          }\n        });\n        return tagvs;\n      })\n    );\n  }\n\n  _performMetricKeyLookup(metric: any): Observable<any[]> {\n    if (!metric) {\n      return of([]);\n    }\n\n    return this._get('/api/search/lookup', { m: metric, limit: 1000 }).pipe(\n      map((result: any) => {\n        result = result.data.results;\n        const tagks: any[] = [];\n        each(result, (r) => {\n          each(r.tags, (tagv, tagk) => {\n            if (tagks.indexOf(tagk) === -1) {\n              tagks.push(tagk);\n            }\n          });\n        });\n        return tagks;\n      })\n    );\n  }\n\n  _get(\n    relativeUrl: string,\n    params?: { type?: string; q?: string; max?: number; m?: any; limit?: number }\n  ): Observable<FetchResponse> {\n    const options = {\n      method: 'GET',\n      url: this.url + relativeUrl,\n      params: params,\n    };\n\n    this._addCredentialOptions(options);\n\n    return getBackendSrv().fetch(options);\n  }\n\n  _addCredentialOptions(options: any) {\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = { Authorization: this.basicAuth };\n    }\n  }\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    let interpolated;\n    try {\n      interpolated = this.templateSrv.replace(query, {}, 'distributed');\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    const responseTransform = (result: any) => {\n      return _map(result, (value) => {\n        return { text: value };\n      });\n    };\n\n    const metricsRegex = /metrics\\((.*)\\)/;\n    const tagNamesRegex = /tag_names\\((.*)\\)/;\n    const tagValuesRegex = /tag_values\\((.*?),\\s?(.*)\\)/;\n    const tagNamesSuggestRegex = /suggest_tagk\\((.*)\\)/;\n    const tagValuesSuggestRegex = /suggest_tagv\\((.*)\\)/;\n\n    const metricsQuery = interpolated.match(metricsRegex);\n    if (metricsQuery) {\n      return lastValueFrom(this._performSuggestQuery(metricsQuery[1], 'metrics').pipe(map(responseTransform)));\n    }\n\n    const tagNamesQuery = interpolated.match(tagNamesRegex);\n    if (tagNamesQuery) {\n      return lastValueFrom(this._performMetricKeyLookup(tagNamesQuery[1]).pipe(map(responseTransform)));\n    }\n\n    const tagValuesQuery = interpolated.match(tagValuesRegex);\n    if (tagValuesQuery) {\n      return lastValueFrom(\n        this._performMetricKeyValueLookup(tagValuesQuery[1], tagValuesQuery[2]).pipe(map(responseTransform))\n      );\n    }\n\n    const tagNamesSuggestQuery = interpolated.match(tagNamesSuggestRegex);\n    if (tagNamesSuggestQuery) {\n      return lastValueFrom(this._performSuggestQuery(tagNamesSuggestQuery[1], 'tagk').pipe(map(responseTransform)));\n    }\n\n    const tagValuesSuggestQuery = interpolated.match(tagValuesSuggestRegex);\n    if (tagValuesSuggestQuery) {\n      return lastValueFrom(this._performSuggestQuery(tagValuesSuggestQuery[1], 'tagv').pipe(map(responseTransform)));\n    }\n\n    return Promise.resolve([]);\n  }\n\n  testDatasource() {\n    return lastValueFrom(\n      this._performSuggestQuery('cpu', 'metrics').pipe(\n        map(() => {\n          return { status: 'success', message: 'Data source is working' };\n        })\n      )\n    );\n  }\n\n  getAggregators() {\n    if (this.aggregatorsPromise) {\n      return this.aggregatorsPromise;\n    }\n\n    this.aggregatorsPromise = lastValueFrom(\n      this._get('/api/aggregators').pipe(\n        map((result: any) => {\n          if (result.data && isArray(result.data)) {\n            return result.data.sort();\n          }\n          return [];\n        })\n      )\n    );\n    return this.aggregatorsPromise;\n  }\n\n  getFilterTypes() {\n    if (this.filterTypesPromise) {\n      return this.filterTypesPromise;\n    }\n\n    this.filterTypesPromise = lastValueFrom(\n      this._get('/api/config/filters').pipe(\n        map((result: any) => {\n          if (result.data) {\n            return Object.keys(result.data).sort();\n          }\n          return [];\n        })\n      )\n    );\n    return this.filterTypesPromise;\n  }\n\n  transformMetricData(md: { dps: any }, groupByTags: any, target: any, options: any, tsdbResolution: number) {\n    const metricLabel = this.createMetricLabel(md, target, groupByTags, options);\n    const dps: any[] = [];\n\n    // TSDB returns datapoints has a hash of ts => value.\n    // Can't use pairs(invert()) because it stringifies keys/values\n    each(md.dps, (v: any, k: number) => {\n      if (tsdbResolution === 2) {\n        dps.push([v, k * 1]);\n      } else {\n        dps.push([v, k * 1000]);\n      }\n    });\n\n    return { target: metricLabel, datapoints: dps };\n  }\n\n  createMetricLabel(\n    md: { dps?: any; tags?: any; metric?: any },\n    target: { alias: string },\n    groupByTags: any,\n    options: { scopedVars: any }\n  ) {\n    if (target.alias) {\n      const scopedVars = clone(options.scopedVars || {});\n      each(md.tags, (value, key) => {\n        scopedVars['tag_' + key] = { value: value };\n      });\n      return this.templateSrv.replace(target.alias, scopedVars);\n    }\n\n    let label = md.metric;\n    const tagData: any[] = [];\n\n    if (!isEmpty(md.tags)) {\n      each(toPairs(md.tags), (tag) => {\n        if (has(groupByTags, tag[0])) {\n          tagData.push(tag[0] + '=' + tag[1]);\n        }\n      });\n    }\n\n    if (!isEmpty(tagData)) {\n      label += '{' + tagData.join(', ') + '}';\n    }\n\n    return label;\n  }\n\n  convertTargetToQuery(target: any, options: any, tsdbVersion: number) {\n    if (!target.metric || target.hide) {\n      return null;\n    }\n\n    const query: any = {\n      metric: this.templateSrv.replace(target.metric, options.scopedVars, 'pipe'),\n      aggregator: 'avg',\n    };\n\n    if (target.aggregator) {\n      query.aggregator = this.templateSrv.replace(target.aggregator);\n    }\n\n    if (target.shouldComputeRate) {\n      query.rate = true;\n      query.rateOptions = {\n        counter: !!target.isCounter,\n      };\n\n      if (target.counterMax && target.counterMax.length) {\n        query.rateOptions.counterMax = parseInt(target.counterMax, 10);\n      }\n\n      if (target.counterResetValue && target.counterResetValue.length) {\n        query.rateOptions.resetValue = parseInt(target.counterResetValue, 10);\n      }\n\n      if (tsdbVersion >= 2) {\n        query.rateOptions.dropResets =\n          !query.rateOptions.counterMax && (!query.rateOptions.ResetValue || query.rateOptions.ResetValue === 0);\n      }\n    }\n\n    if (!target.disableDownsampling) {\n      let interval = this.templateSrv.replace(target.downsampleInterval || options.interval);\n\n      if (interval.match(/\\.[0-9]+s/)) {\n        interval = parseFloat(interval) * 1000 + 'ms';\n      }\n\n      query.downsample = interval + '-' + target.downsampleAggregator;\n\n      if (target.downsampleFillPolicy && target.downsampleFillPolicy !== 'none') {\n        query.downsample += '-' + target.downsampleFillPolicy;\n      }\n    }\n\n    if (target.filters && target.filters.length > 0) {\n      query.filters = angular.copy(target.filters);\n      if (query.filters) {\n        for (const filterKey in query.filters) {\n          query.filters[filterKey].filter = this.templateSrv.replace(\n            query.filters[filterKey].filter,\n            options.scopedVars,\n            'pipe'\n          );\n        }\n      }\n    } else {\n      query.tags = angular.copy(target.tags);\n      if (query.tags) {\n        for (const tagKey in query.tags) {\n          query.tags[tagKey] = this.templateSrv.replace(query.tags[tagKey], options.scopedVars, 'pipe');\n        }\n      }\n    }\n\n    if (target.explicitTags) {\n      query.explicitTags = true;\n    }\n\n    return query;\n  }\n\n  mapMetricsToTargets(metrics: any, options: any, tsdbVersion: number) {\n    let interpolatedTagValue, arrTagV;\n    return _map(metrics, (metricData) => {\n      if (tsdbVersion === 3) {\n        return metricData.query.index;\n      } else {\n        return findIndex(options.targets as any[], (target) => {\n          if (target.filters && target.filters.length > 0) {\n            return target.metric === metricData.metric;\n          } else {\n            return (\n              target.metric === metricData.metric &&\n              every(target.tags, (tagV, tagK) => {\n                interpolatedTagValue = this.templateSrv.replace(tagV, options.scopedVars, 'pipe');\n                arrTagV = interpolatedTagValue.split('|');\n                return includes(arrTagV, metricData.tags[tagK]) || interpolatedTagValue === '*';\n              })\n            );\n          }\n        });\n      }\n    });\n  }\n\n  interpolateVariablesInQueries(queries: OpenTsdbQuery[], scopedVars: ScopedVars): OpenTsdbQuery[] {\n    if (!queries.length) {\n      return queries;\n    }\n\n    return queries.map((query) => ({\n      ...query,\n      metric: this.templateSrv.replace(query.metric, scopedVars),\n    }));\n  }\n\n  convertToTSDBTime(date: any, roundUp: any, timezone: any) {\n    if (date === 'now') {\n      return null;\n    }\n\n    date = dateMath.parse(date, roundUp, timezone);\n    return date.valueOf();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}