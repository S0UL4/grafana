{"ast":null,"code":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { isEqual as _isEqual } from 'lodash'; // @ts-ignore\n\nimport { getTraceSpanIdsAsTree } from '../selectors/trace';\nimport { getConfigValue } from '../utils/config/get-config';\nimport { getTraceName } from './trace-viewer'; // exported for tests\n\nexport function deduplicateTags(spanTags) {\n  const warningsHash = new Map();\n  const tags = spanTags.reduce((uniqueTags, tag) => {\n    if (!uniqueTags.some(t => t.key === tag.key && t.value === tag.value)) {\n      uniqueTags.push(tag);\n    } else {\n      warningsHash.set(`${tag.key}:${tag.value}`, `Duplicate tag \"${tag.key}:${tag.value}\"`);\n    }\n\n    return uniqueTags;\n  }, []);\n  const warnings = Array.from(warningsHash.values());\n  return {\n    tags,\n    warnings\n  };\n} // exported for tests\n\nexport function orderTags(spanTags, topPrefixes) {\n  var _spanTags$slice;\n\n  const orderedTags = (_spanTags$slice = spanTags === null || spanTags === void 0 ? void 0 : spanTags.slice()) !== null && _spanTags$slice !== void 0 ? _spanTags$slice : [];\n  const tp = (topPrefixes || []).map(p => p.toLowerCase());\n  orderedTags.sort((a, b) => {\n    const aKey = a.key.toLowerCase();\n    const bKey = b.key.toLowerCase();\n\n    for (let i = 0; i < tp.length; i++) {\n      const p = tp[i];\n\n      if (aKey.startsWith(p) && !bKey.startsWith(p)) {\n        return -1;\n      }\n\n      if (!aKey.startsWith(p) && bKey.startsWith(p)) {\n        return 1;\n      }\n    }\n\n    if (aKey > bKey) {\n      return 1;\n    }\n\n    if (aKey < bKey) {\n      return -1;\n    }\n\n    return 0;\n  });\n  return orderedTags;\n}\n/**\n * NOTE: Mutates `data` - Transform the HTTP response data into the form the app\n * generally requires.\n */\n\nexport default function transformTraceData(data) {\n  if (!(data !== null && data !== void 0 && data.traceID)) {\n    return null;\n  }\n\n  const traceID = data.traceID.toLowerCase();\n  let traceEndTime = 0;\n  let traceStartTime = Number.MAX_SAFE_INTEGER;\n  const spanIdCounts = new Map();\n  const spanMap = new Map(); // filter out spans with empty start times\n  // eslint-disable-next-line no-param-reassign\n\n  data.spans = data.spans.filter(span => Boolean(span.startTime)); // Sort process tags\n\n  data.processes = Object.entries(data.processes).reduce((processes, [id, process]) => {\n    processes[id] = Object.assign({}, process, {\n      tags: orderTags(process.tags)\n    });\n    return processes;\n  }, {});\n  const max = data.spans.length;\n\n  for (let i = 0; i < max; i++) {\n    const span = data.spans[i];\n    const {\n      startTime,\n      duration,\n      processID\n    } = span;\n    let spanID = span.spanID; // check for start / end time for the trace\n\n    if (startTime < traceStartTime) {\n      traceStartTime = startTime;\n    }\n\n    if (startTime + duration > traceEndTime) {\n      traceEndTime = startTime + duration;\n    } // make sure span IDs are unique\n\n\n    const idCount = spanIdCounts.get(spanID);\n\n    if (idCount != null) {\n      // eslint-disable-next-line no-console\n      console.warn(`Dupe spanID, ${idCount + 1} x ${spanID}`, span, spanMap.get(spanID));\n\n      if (_isEqual(span, spanMap.get(spanID))) {\n        // eslint-disable-next-line no-console\n        console.warn('\\t two spans with same ID have `isEqual(...) === true`');\n      }\n\n      spanIdCounts.set(spanID, idCount + 1);\n      spanID = `${spanID}_${idCount}`;\n      span.spanID = spanID;\n    } else {\n      spanIdCounts.set(spanID, 1);\n    }\n\n    span.process = data.processes[processID];\n    spanMap.set(spanID, span);\n  } // tree is necessary to sort the spans, so children follow parents, and\n  // siblings are sorted by start time\n\n\n  const tree = getTraceSpanIdsAsTree(data);\n  const spans = [];\n  const svcCounts = {}; // Eslint complains about number type not needed but then TS complains it is implicitly any.\n  // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n\n  tree.walk((spanID, node, depth = 0) => {\n    if (spanID === '__root__') {\n      return;\n    }\n\n    const span = spanMap.get(spanID);\n\n    if (!span) {\n      return;\n    }\n\n    const {\n      serviceName\n    } = span.process;\n    svcCounts[serviceName] = (svcCounts[serviceName] || 0) + 1;\n    span.relativeStartTime = span.startTime - traceStartTime;\n    span.depth = depth - 1;\n    span.hasChildren = node.children.length > 0;\n    span.childSpanCount = node.children.length;\n    span.warnings = span.warnings || [];\n    span.tags = span.tags || [];\n    span.references = span.references || [];\n    const tagsInfo = deduplicateTags(span.tags);\n    span.tags = orderTags(tagsInfo.tags, getConfigValue('topTagPrefixes'));\n    span.warnings = span.warnings.concat(tagsInfo.warnings);\n    span.references.forEach((ref, index) => {\n      const refSpan = spanMap.get(ref.spanID);\n\n      if (refSpan) {\n        // eslint-disable-next-line no-param-reassign\n        ref.span = refSpan;\n\n        if (index > 0) {\n          // Don't take into account the parent, just other references.\n          refSpan.subsidiarilyReferencedBy = refSpan.subsidiarilyReferencedBy || [];\n          refSpan.subsidiarilyReferencedBy.push({\n            spanID,\n            traceID,\n            span,\n            refType: ref.refType\n          });\n        }\n      }\n    });\n    spans.push(span);\n  });\n  const traceName = getTraceName(spans);\n  const services = Object.keys(svcCounts).map(name => ({\n    name,\n    numberOfSpans: svcCounts[name]\n  }));\n  return {\n    services,\n    spans,\n    traceID,\n    traceName,\n    // can't use spread operator for intersection types\n    // repl: https://goo.gl/4Z23MJ\n    // issue: https://github.com/facebook/flow/issues/1511\n    processes: data.processes,\n    duration: traceEndTime - traceStartTime,\n    startTime: traceStartTime,\n    endTime: traceEndTime\n  };\n}","map":{"version":3,"names":["isEqual","_isEqual","getTraceSpanIdsAsTree","getConfigValue","getTraceName","deduplicateTags","spanTags","warningsHash","Map","tags","reduce","uniqueTags","tag","some","t","key","value","push","set","warnings","Array","from","values","orderTags","topPrefixes","orderedTags","slice","tp","map","p","toLowerCase","sort","a","b","aKey","bKey","i","length","startsWith","transformTraceData","data","traceID","traceEndTime","traceStartTime","Number","MAX_SAFE_INTEGER","spanIdCounts","spanMap","spans","filter","span","Boolean","startTime","processes","Object","entries","id","process","max","duration","processID","spanID","idCount","get","console","warn","tree","svcCounts","walk","node","depth","serviceName","relativeStartTime","hasChildren","children","childSpanCount","references","tagsInfo","concat","forEach","ref","index","refSpan","subsidiarilyReferencedBy","refType","traceName","services","keys","name","numberOfSpans","endTime"],"sources":["/home/soula/grafana/packages/jaeger-ui-components/src/model/transform-trace-data.tsx"],"sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { isEqual as _isEqual } from 'lodash';\n\n// @ts-ignore\nimport { getTraceSpanIdsAsTree } from '../selectors/trace';\nimport { TraceKeyValuePair, TraceSpan, Trace, TraceResponse, TraceProcess } from '../types/trace';\n// @ts-ignore\nimport TreeNode from '../utils/TreeNode';\nimport { getConfigValue } from '../utils/config/get-config';\n\nimport { getTraceName } from './trace-viewer';\n\n// exported for tests\nexport function deduplicateTags(spanTags: TraceKeyValuePair[]) {\n  const warningsHash: Map<string, string> = new Map<string, string>();\n  const tags: TraceKeyValuePair[] = spanTags.reduce<TraceKeyValuePair[]>((uniqueTags, tag) => {\n    if (!uniqueTags.some((t) => t.key === tag.key && t.value === tag.value)) {\n      uniqueTags.push(tag);\n    } else {\n      warningsHash.set(`${tag.key}:${tag.value}`, `Duplicate tag \"${tag.key}:${tag.value}\"`);\n    }\n    return uniqueTags;\n  }, []);\n  const warnings = Array.from(warningsHash.values());\n  return { tags, warnings };\n}\n\n// exported for tests\nexport function orderTags(spanTags: TraceKeyValuePair[], topPrefixes?: string[]) {\n  const orderedTags: TraceKeyValuePair[] = spanTags?.slice() ?? [];\n  const tp = (topPrefixes || []).map((p: string) => p.toLowerCase());\n\n  orderedTags.sort((a, b) => {\n    const aKey = a.key.toLowerCase();\n    const bKey = b.key.toLowerCase();\n\n    for (let i = 0; i < tp.length; i++) {\n      const p = tp[i];\n      if (aKey.startsWith(p) && !bKey.startsWith(p)) {\n        return -1;\n      }\n      if (!aKey.startsWith(p) && bKey.startsWith(p)) {\n        return 1;\n      }\n    }\n\n    if (aKey > bKey) {\n      return 1;\n    }\n    if (aKey < bKey) {\n      return -1;\n    }\n    return 0;\n  });\n\n  return orderedTags;\n}\n\n/**\n * NOTE: Mutates `data` - Transform the HTTP response data into the form the app\n * generally requires.\n */\nexport default function transformTraceData(data: TraceResponse | undefined): Trace | null {\n  if (!data?.traceID) {\n    return null;\n  }\n  const traceID = data.traceID.toLowerCase();\n\n  let traceEndTime = 0;\n  let traceStartTime = Number.MAX_SAFE_INTEGER;\n  const spanIdCounts = new Map();\n  const spanMap = new Map<string, TraceSpan>();\n  // filter out spans with empty start times\n  // eslint-disable-next-line no-param-reassign\n  data.spans = data.spans.filter((span) => Boolean(span.startTime));\n\n  // Sort process tags\n  data.processes = Object.entries(data.processes).reduce<Record<string, TraceProcess>>((processes, [id, process]) => {\n    processes[id] = {\n      ...process,\n      tags: orderTags(process.tags),\n    };\n    return processes;\n  }, {});\n\n  const max = data.spans.length;\n  for (let i = 0; i < max; i++) {\n    const span: TraceSpan = data.spans[i] as TraceSpan;\n    const { startTime, duration, processID } = span;\n\n    let spanID = span.spanID;\n    // check for start / end time for the trace\n    if (startTime < traceStartTime) {\n      traceStartTime = startTime;\n    }\n    if (startTime + duration > traceEndTime) {\n      traceEndTime = startTime + duration;\n    }\n    // make sure span IDs are unique\n    const idCount = spanIdCounts.get(spanID);\n    if (idCount != null) {\n      // eslint-disable-next-line no-console\n      console.warn(`Dupe spanID, ${idCount + 1} x ${spanID}`, span, spanMap.get(spanID));\n      if (_isEqual(span, spanMap.get(spanID))) {\n        // eslint-disable-next-line no-console\n        console.warn('\\t two spans with same ID have `isEqual(...) === true`');\n      }\n      spanIdCounts.set(spanID, idCount + 1);\n      spanID = `${spanID}_${idCount}`;\n      span.spanID = spanID;\n    } else {\n      spanIdCounts.set(spanID, 1);\n    }\n    span.process = data.processes[processID];\n    spanMap.set(spanID, span);\n  }\n  // tree is necessary to sort the spans, so children follow parents, and\n  // siblings are sorted by start time\n  const tree = getTraceSpanIdsAsTree(data);\n  const spans: TraceSpan[] = [];\n  const svcCounts: Record<string, number> = {};\n\n  // Eslint complains about number type not needed but then TS complains it is implicitly any.\n  // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n  tree.walk((spanID: string, node: TreeNode, depth: number = 0) => {\n    if (spanID === '__root__') {\n      return;\n    }\n    const span = spanMap.get(spanID) as TraceSpan;\n    if (!span) {\n      return;\n    }\n    const { serviceName } = span.process;\n    svcCounts[serviceName] = (svcCounts[serviceName] || 0) + 1;\n    span.relativeStartTime = span.startTime - traceStartTime;\n    span.depth = depth - 1;\n    span.hasChildren = node.children.length > 0;\n    span.childSpanCount = node.children.length;\n    span.warnings = span.warnings || [];\n    span.tags = span.tags || [];\n    span.references = span.references || [];\n    const tagsInfo = deduplicateTags(span.tags);\n    span.tags = orderTags(tagsInfo.tags, getConfigValue('topTagPrefixes'));\n    span.warnings = span.warnings.concat(tagsInfo.warnings);\n    span.references.forEach((ref, index) => {\n      const refSpan = spanMap.get(ref.spanID) as TraceSpan;\n      if (refSpan) {\n        // eslint-disable-next-line no-param-reassign\n        ref.span = refSpan;\n        if (index > 0) {\n          // Don't take into account the parent, just other references.\n          refSpan.subsidiarilyReferencedBy = refSpan.subsidiarilyReferencedBy || [];\n          refSpan.subsidiarilyReferencedBy.push({\n            spanID,\n            traceID,\n            span,\n            refType: ref.refType,\n          });\n        }\n      }\n    });\n    spans.push(span);\n  });\n  const traceName = getTraceName(spans);\n  const services = Object.keys(svcCounts).map((name) => ({ name, numberOfSpans: svcCounts[name] }));\n  return {\n    services,\n    spans,\n    traceID,\n    traceName,\n    // can't use spread operator for intersection types\n    // repl: https://goo.gl/4Z23MJ\n    // issue: https://github.com/facebook/flow/issues/1511\n    processes: data.processes,\n    duration: traceEndTime - traceStartTime,\n    startTime: traceStartTime,\n    endTime: traceEndTime,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}