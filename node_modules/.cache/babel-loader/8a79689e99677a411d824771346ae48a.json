{"ast":null,"code":"import uPlot from 'uplot';\nimport { FieldColorModeId, fieldColorModeRegistry, getDisplayProcessor, getFieldColorModeForField, getFieldDisplayName, getFieldSeriesColor } from '@grafana/data';\nimport { alpha } from '@grafana/data/src/themes/colorManipulator';\nimport { config } from '@grafana/runtime';\nimport { AxisPlacement, ScaleDirection, ScaleOrientation, VisibilityMode } from '@grafana/schema';\nimport { UPlotConfigBuilder } from '@grafana/ui';\nimport { findFieldIndex, getScaledDimensionForField, ScaleDimensionMode } from 'app/features/dimensions';\nimport { pointWithin, Quadtree } from '../barchart/quadtree';\nimport { isGraphable } from './dims';\nimport { defaultScatterConfig, ScatterLineMode } from './models.gen';\n\n/**\n * This is called when options or structure rev changes\n */\nexport function prepScatter(options, getData, theme, ttip) {\n  let series;\n  let builder;\n\n  try {\n    series = prepSeries(options, getData());\n    builder = prepConfig(getData, series, theme, ttip);\n  } catch (e) {\n    console.log('prepScatter ERROR', e);\n    const errorMessage = e instanceof Error ? e.message : 'Unknown error in prepScatter';\n    return {\n      error: errorMessage,\n      series: []\n    };\n  }\n\n  return {\n    series,\n    builder\n  };\n}\n\nfunction getScatterSeries(seriesIndex, frames, frameIndex, xIndex, yIndex, dims) {\n  var _y$state, _ref, _dims$pointSizeConfig, _dims$pointSizeConfig2, _y$config$custom, _y$config$custom$poin, _fieldConfig$line, _fieldConfig$lineWidt;\n\n  const frame = frames[frameIndex];\n  const y = frame.fields[yIndex];\n  let state = (_y$state = y.state) !== null && _y$state !== void 0 ? _y$state : {};\n  state.seriesIndex = seriesIndex;\n  y.state = state; // Color configs\n  //----------------\n\n  let seriesColor = dims.pointColorFixed ? config.theme2.visualization.getColorByName(dims.pointColorFixed) : getFieldSeriesColor(y, config.theme2).color;\n\n  let pointColor = () => seriesColor;\n\n  const fieldConfig = Object.assign({}, defaultScatterConfig, y.config.custom);\n  let pointColorMode = fieldColorModeRegistry.get(FieldColorModeId.PaletteClassic);\n\n  if (dims.pointColorIndex) {\n    const f = frames[frameIndex].fields[dims.pointColorIndex];\n\n    if (f) {\n      var _f$display;\n\n      const disp = (_f$display = f.display) !== null && _f$display !== void 0 ? _f$display : getDisplayProcessor({\n        field: f,\n        theme: config.theme2\n      });\n      pointColorMode = getFieldColorModeForField(y);\n\n      if (pointColorMode.isByValue) {\n        const index = dims.pointColorIndex;\n\n        pointColor = frame => {\n          // Yes we can improve this later\n          return frame.fields[index].values.toArray().map(v => disp(v).color);\n        };\n      } else {\n        seriesColor = pointColorMode.getCalculator(f, config.theme2)(f.values.get(0), 1);\n\n        pointColor = () => seriesColor;\n      }\n    }\n  } // Size configs\n  //----------------\n\n\n  let pointSizeHints = dims.pointSizeConfig;\n  let pointSizeFixed = (_ref = (_dims$pointSizeConfig = (_dims$pointSizeConfig2 = dims.pointSizeConfig) === null || _dims$pointSizeConfig2 === void 0 ? void 0 : _dims$pointSizeConfig2.fixed) !== null && _dims$pointSizeConfig !== void 0 ? _dims$pointSizeConfig : (_y$config$custom = y.config.custom) === null || _y$config$custom === void 0 ? void 0 : (_y$config$custom$poin = _y$config$custom.pointSizeConfig) === null || _y$config$custom$poin === void 0 ? void 0 : _y$config$custom$poin.fixed) !== null && _ref !== void 0 ? _ref : 5;\n\n  let pointSize = () => pointSizeFixed;\n\n  if (dims.pointSizeIndex) {\n    pointSize = frame => {\n      const s = getScaledDimensionForField(frame.fields[dims.pointSizeIndex], dims.pointSizeConfig, ScaleDimensionMode.Quadratic);\n      const vals = Array(frame.length);\n\n      for (let i = 0; i < frame.length; i++) {\n        vals[i] = s.get(i);\n      }\n\n      return vals;\n    };\n  } else {\n    pointSizeHints = {\n      fixed: pointSizeFixed,\n      min: pointSizeFixed,\n      max: pointSizeFixed\n    };\n  } // Series config\n  //----------------\n\n\n  const name = getFieldDisplayName(y, frame, frames);\n  return {\n    name,\n    frame: frames => frames[frameIndex],\n    x: frame => frame.fields[xIndex],\n    y: frame => frame.fields[yIndex],\n    legend: frame => {\n      return [{\n        label: name,\n        color: seriesColor,\n        // single color for series?\n        getItemKey: () => name,\n        yAxis: yIndex // << but not used\n\n      }];\n    },\n    line: (_fieldConfig$line = fieldConfig.line) !== null && _fieldConfig$line !== void 0 ? _fieldConfig$line : ScatterLineMode.None,\n    lineWidth: (_fieldConfig$lineWidt = fieldConfig.lineWidth) !== null && _fieldConfig$lineWidt !== void 0 ? _fieldConfig$lineWidt : 2,\n    lineStyle: fieldConfig.lineStyle,\n    lineColor: () => seriesColor,\n    point: fieldConfig.point,\n    pointSize,\n    pointColor,\n    pointSymbol: (frame, from) => 'circle',\n    // single field, multiple symbols.... kinda equals multiple series ðŸ¤”\n    label: VisibilityMode.Never,\n    labelValue: () => '',\n    hints: {\n      pointSize: pointSizeHints,\n      pointColor: {\n        mode: pointColorMode\n      }\n    }\n  };\n}\n\nfunction prepSeries(options, frames) {\n  var _options$dims, _dims$frame;\n\n  let seriesIndex = 0;\n\n  if (!frames.length) {\n    throw 'missing data';\n  }\n\n  if (options.mode === 'explicit') {\n    var _options$series;\n\n    if ((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.length) {\n      for (const series of options.series) {\n        if (!(series !== null && series !== void 0 && series.x)) {\n          throw 'Select X dimension';\n        }\n\n        if (!(series !== null && series !== void 0 && series.y)) {\n          throw 'Select Y dimension';\n        }\n\n        for (let frameIndex = 0; frameIndex < frames.length; frameIndex++) {\n          const frame = frames[frameIndex];\n          const xIndex = findFieldIndex(frame, series.x);\n\n          if (xIndex != null) {\n            var _series$pointColor, _series$pointColor2, _series$pointSize;\n\n            // TODO: this should find multiple y fields\n            const yIndex = findFieldIndex(frame, series.y);\n\n            if (yIndex == null) {\n              throw 'Y must be in the same frame as X';\n            }\n\n            const dims = {\n              pointColorFixed: (_series$pointColor = series.pointColor) === null || _series$pointColor === void 0 ? void 0 : _series$pointColor.fixed,\n              pointColorIndex: findFieldIndex(frame, (_series$pointColor2 = series.pointColor) === null || _series$pointColor2 === void 0 ? void 0 : _series$pointColor2.field),\n              pointSizeConfig: series.pointSize,\n              pointSizeIndex: findFieldIndex(frame, (_series$pointSize = series.pointSize) === null || _series$pointSize === void 0 ? void 0 : _series$pointSize.field)\n            };\n            return [getScatterSeries(seriesIndex++, frames, frameIndex, xIndex, yIndex, dims)];\n          }\n        }\n      }\n    }\n  } // Default behavior\n\n\n  const dims = (_options$dims = options.dims) !== null && _options$dims !== void 0 ? _options$dims : {};\n  const frameIndex = (_dims$frame = dims.frame) !== null && _dims$frame !== void 0 ? _dims$frame : 0;\n  const frame = frames[frameIndex];\n  const numericIndicies = [];\n  let xIndex = findFieldIndex(frame, dims.x);\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    if (isGraphable(frame.fields[i])) {\n      if (xIndex == null || i === xIndex) {\n        xIndex = i;\n        continue;\n      }\n\n      if (dims.exclude && dims.exclude.includes(getFieldDisplayName(frame.fields[i], frame, frames))) {\n        continue; // skip\n      }\n\n      numericIndicies.push(i);\n    }\n  }\n\n  if (xIndex == null) {\n    throw 'Missing X dimension';\n  }\n\n  if (!numericIndicies.length) {\n    throw 'No Y values';\n  }\n\n  return numericIndicies.map(yIndex => getScatterSeries(seriesIndex++, frames, frameIndex, xIndex, yIndex, {}));\n}\n\n//const prepConfig: UPlotConfigPrepFnXY<XYChartOptions> = ({ frames, series, theme }) => {\nconst prepConfig = (getData, scatterSeries, theme, ttip) => {\n  var _xField$config$custom, _xField$config$custom2;\n\n  let qt;\n  let hRect;\n\n  function drawBubblesFactory(opts) {\n    const drawBubbles = (u, seriesIdx, idx0, idx1) => {\n      uPlot.orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim, moveTo, lineTo, rect, arc) => {\n        var _pointHints$max;\n\n        const scatterInfo = scatterSeries[seriesIdx - 1];\n        let d = u.data[seriesIdx];\n        let showLine = scatterInfo.line !== ScatterLineMode.None;\n        let showPoints = scatterInfo.point === VisibilityMode.Always;\n\n        if (!showPoints && scatterInfo.point === VisibilityMode.Auto) {\n          showPoints = d[0].length < 1000;\n        } // always show something\n\n\n        if (!showPoints && !showLine) {\n          showLine = true;\n        }\n\n        let strokeWidth = 1;\n        u.ctx.save();\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        u.ctx.fillStyle = series.fill(); // assumes constant\n\n        u.ctx.strokeStyle = series.stroke();\n        u.ctx.lineWidth = strokeWidth;\n        let deg360 = 2 * Math.PI;\n        let xKey = scaleX.key;\n        let yKey = scaleY.key;\n        let pointHints = scatterInfo.hints.pointSize;\n        const colorByValue = scatterInfo.hints.pointColor.mode.isByValue;\n        let maxSize = ((_pointHints$max = pointHints.max) !== null && _pointHints$max !== void 0 ? _pointHints$max : pointHints.fixed) * devicePixelRatio; // todo: this depends on direction & orientation\n        // todo: calc once per redraw, not per path\n\n        let filtLft = u.posToVal(-maxSize / 2, xKey);\n        let filtRgt = u.posToVal(u.bbox.width / devicePixelRatio + maxSize / 2, xKey);\n        let filtBtm = u.posToVal(u.bbox.height / devicePixelRatio + maxSize / 2, yKey);\n        let filtTop = u.posToVal(-maxSize / 2, yKey);\n        let sizes = opts.disp.size.values(u, seriesIdx);\n        let pointColors = opts.disp.color.values(u, seriesIdx);\n        let pointAlpha = opts.disp.color.alpha(u, seriesIdx);\n        let linePath = showLine ? new Path2D() : null;\n\n        for (let i = 0; i < d[0].length; i++) {\n          let xVal = d[0][i];\n          let yVal = d[1][i];\n          let size = sizes[i] * devicePixelRatio;\n\n          if (xVal >= filtLft && xVal <= filtRgt && yVal >= filtBtm && yVal <= filtTop) {\n            let cx = valToPosX(xVal, scaleX, xDim, xOff);\n            let cy = valToPosY(yVal, scaleY, yDim, yOff);\n\n            if (showLine) {\n              linePath.lineTo(cx, cy);\n            }\n\n            if (showPoints) {\n              u.ctx.moveTo(cx + size / 2, cy);\n              u.ctx.beginPath();\n              u.ctx.arc(cx, cy, size / 2, 0, deg360);\n\n              if (colorByValue) {\n                u.ctx.fillStyle = pointAlpha[i];\n                u.ctx.strokeStyle = pointColors[i];\n              }\n\n              u.ctx.fill();\n              u.ctx.stroke();\n              opts.each(u, seriesIdx, i, cx - size / 2 - strokeWidth / 2, cy - size / 2 - strokeWidth / 2, size + strokeWidth, size + strokeWidth);\n            }\n          }\n        }\n\n        if (showLine) {\n          let frame = scatterInfo.frame(getData());\n          u.ctx.strokeStyle = scatterInfo.lineColor(frame);\n          u.ctx.lineWidth = scatterInfo.lineWidth * devicePixelRatio;\n          const {\n            lineStyle\n          } = scatterInfo;\n\n          if (lineStyle && lineStyle.fill !== 'solid') {\n            var _lineStyle$dash;\n\n            if (lineStyle.fill === 'dot') {\n              u.ctx.lineCap = 'round';\n            }\n\n            u.ctx.setLineDash((_lineStyle$dash = lineStyle.dash) !== null && _lineStyle$dash !== void 0 ? _lineStyle$dash : [10, 10]);\n          }\n\n          u.ctx.stroke(linePath);\n        }\n\n        u.ctx.restore();\n      });\n      return null;\n    };\n\n    return drawBubbles;\n  }\n\n  let drawBubbles = drawBubblesFactory({\n    disp: {\n      size: {\n        //unit: 3, // raw CSS pixels\n        values: (u, seriesIdx) => {\n          return u.data[seriesIdx][2]; // already contains final pixel geometry\n          //let [minValue, maxValue] = getSizeMinMax(u);\n          //return u.data[seriesIdx][2].map(v => getSize(v, minValue, maxValue));\n        }\n      },\n      color: {\n        // string values\n        values: (u, seriesIdx) => {\n          return u.data[seriesIdx][3];\n        },\n        alpha: (u, seriesIdx) => {\n          return u.data[seriesIdx][4];\n        }\n      }\n    },\n    each: (u, seriesIdx, dataIdx, lft, top, wid, hgt) => {\n      // we get back raw canvas coords (included axes & padding). translate to the plotting area origin\n      lft -= u.bbox.left;\n      top -= u.bbox.top;\n      qt.add({\n        x: lft,\n        y: top,\n        w: wid,\n        h: hgt,\n        sidx: seriesIdx,\n        didx: dataIdx\n      });\n    }\n  });\n  const builder = new UPlotConfigBuilder();\n  builder.setCursor({\n    drag: {\n      setScale: true\n    },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        hRect = null;\n        let dist = Infinity;\n        let cx = u.cursor.left * devicePixelRatio;\n        let cy = u.cursor.top * devicePixelRatio;\n        qt.get(cx, cy, 1, 1, o => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            let ocx = o.x + o.w / 2;\n            let ocy = o.y + o.h / 2;\n            let dx = ocx - cx;\n            let dy = ocy - cy;\n            let d = Math.sqrt(dx ** 2 + dy ** 2); // test against radius for actual hover\n\n            if (d <= o.w / 2) {\n              // only hover bbox with closest distance\n              if (d <= dist) {\n                dist = d;\n                hRect = o;\n              }\n            }\n          }\n        });\n      }\n\n      return hRect && seriesIdx === hRect.sidx ? hRect.didx : null;\n    },\n    points: {\n      size: (u, seriesIdx) => {\n        return hRect && seriesIdx === hRect.sidx ? hRect.w / devicePixelRatio : 0;\n      },\n      fill: (u, seriesIdx) => 'rgba(255,255,255,0.4)'\n    }\n  }); // clip hover points/bubbles to plotting area\n\n  builder.addHook('init', (u, r) => {\n    u.over.style.overflow = 'hidden';\n  });\n  let rect; // rect of .u-over (grid area)\n\n  builder.addHook('syncRect', (u, r) => {\n    rect = r;\n  });\n  builder.addHook('setLegend', u => {\n    // console.log('TTIP???', u.cursor.idxs);\n    if (u.cursor.idxs != null) {\n      for (let i = 0; i < u.cursor.idxs.length; i++) {\n        const sel = u.cursor.idxs[i];\n\n        if (sel != null) {\n          ttip({\n            scatterIndex: i - 1,\n            xIndex: sel,\n            pageX: rect.left + u.cursor.left,\n            pageY: rect.top + u.cursor.top\n          });\n          return; // only show the first one\n        }\n      }\n    }\n\n    ttip(undefined);\n  });\n  builder.addHook('drawClear', u => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n    qt.clear(); // force-clear the path cache to cause drawBars() to rebuild new quadtree\n\n    u.series.forEach((s, i) => {\n      if (i > 0) {\n        // @ts-ignore\n        s._paths = null;\n      }\n    });\n  });\n  builder.setMode(2);\n  const frames = getData();\n  let xField = scatterSeries[0].x(scatterSeries[0].frame(frames));\n  builder.addScale({\n    scaleKey: 'x',\n    isTime: false,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    range: (u, min, max) => [min, max]\n  });\n  builder.addAxis({\n    scaleKey: 'x',\n    placement: ((_xField$config$custom = xField.config.custom) === null || _xField$config$custom === void 0 ? void 0 : _xField$config$custom.axisPlacement) !== AxisPlacement.Hidden ? AxisPlacement.Bottom : AxisPlacement.Hidden,\n    show: ((_xField$config$custom2 = xField.config.custom) === null || _xField$config$custom2 === void 0 ? void 0 : _xField$config$custom2.axisPlacement) !== AxisPlacement.Hidden,\n    theme,\n    label: xField.config.custom.axisLabel\n  });\n  scatterSeries.forEach(s => {\n    var _field$config$unit, _field$config$custom;\n\n    let frame = s.frame(frames);\n    let field = s.y(frame);\n    const lineColor = s.lineColor(frame);\n    const pointColor = asSingleValue(frame, s.pointColor); //const lineColor = s.lineColor(frame);\n    //const lineWidth = s.lineWidth;\n\n    let scaleKey = (_field$config$unit = field.config.unit) !== null && _field$config$unit !== void 0 ? _field$config$unit : 'y';\n    builder.addScale({\n      scaleKey,\n      orientation: ScaleOrientation.Vertical,\n      direction: ScaleDirection.Up,\n      range: (u, min, max) => [min, max]\n    });\n\n    if (((_field$config$custom = field.config.custom) === null || _field$config$custom === void 0 ? void 0 : _field$config$custom.axisPlacement) !== AxisPlacement.Hidden) {\n      var _field$config$custom2;\n\n      builder.addAxis({\n        scaleKey,\n        theme,\n        placement: (_field$config$custom2 = field.config.custom) === null || _field$config$custom2 === void 0 ? void 0 : _field$config$custom2.axisPlacement,\n        label: field.config.custom.axisLabel,\n        values: (u, splits) => splits.map(s => field.display(s).text)\n      });\n    }\n\n    builder.addSeries({\n      facets: [{\n        scale: 'x',\n        auto: true\n      }, {\n        scale: scaleKey,\n        auto: true\n      }],\n      pathBuilder: drawBubbles,\n      // drawBubbles({disp: {size: {values: () => }}})\n      theme,\n      scaleKey: '',\n      // facets' scales used (above)\n      lineColor: lineColor,\n      fillColor: alpha(pointColor, 0.5)\n    });\n  });\n  /*\n  builder.setPrepData((frames) => {\n    let seriesData = lookup.fieldMaps.flatMap((f, i) => {\n      let { fields } = frames[i];\n       return f.y.map((yIndex, frameSeriesIndex) => {\n        let xValues = fields[f.x[frameSeriesIndex]].values.toArray();\n        let yValues = fields[f.y[frameSeriesIndex]].values.toArray();\n        let sizeValues = f.size![frameSeriesIndex](frames[i]);\n         if (!Array.isArray(sizeValues)) {\n          sizeValues = Array(xValues.length).fill(sizeValues);\n        }\n         return [xValues, yValues, sizeValues];\n      });\n    });\n     return [null, ...seriesData];\n  });\n  */\n\n  return builder;\n};\n/**\n * This is called everytime the data changes\n *\n * from?  is this where we would support that?  -- need the previous values\n */\n\n\nexport function prepData(info, data, from) {\n  if (info.error) {\n    return [null];\n  }\n\n  return [null, ...info.series.map((s, idx) => {\n    const frame = s.frame(data);\n    let colorValues;\n    let colorAlphaValues;\n    const r = s.pointColor(frame);\n\n    if (Array.isArray(r)) {\n      colorValues = r;\n      colorAlphaValues = r.map(c => alpha(c, 0.5));\n    } else {\n      colorValues = Array(frame.length).fill(r);\n      colorAlphaValues = Array(frame.length).fill(alpha(r, 0.5));\n    }\n\n    return [s.x(frame).values.toArray(), // X\n    s.y(frame).values.toArray(), // Y\n    asArray(frame, s.pointSize), colorValues, colorAlphaValues];\n  })];\n}\n\nfunction asArray(frame, lookup) {\n  const r = lookup(frame);\n\n  if (Array.isArray(r)) {\n    return r;\n  }\n\n  return Array(frame.length).fill(r);\n}\n\nfunction asSingleValue(frame, lookup) {\n  const r = lookup(frame);\n\n  if (Array.isArray(r)) {\n    return r[0];\n  }\n\n  return r;\n}","map":{"version":3,"names":["uPlot","FieldColorModeId","fieldColorModeRegistry","getDisplayProcessor","getFieldColorModeForField","getFieldDisplayName","getFieldSeriesColor","alpha","config","AxisPlacement","ScaleDirection","ScaleOrientation","VisibilityMode","UPlotConfigBuilder","findFieldIndex","getScaledDimensionForField","ScaleDimensionMode","pointWithin","Quadtree","isGraphable","defaultScatterConfig","ScatterLineMode","prepScatter","options","getData","theme","ttip","series","builder","prepSeries","prepConfig","e","console","log","errorMessage","Error","message","error","getScatterSeries","seriesIndex","frames","frameIndex","xIndex","yIndex","dims","frame","y","fields","state","seriesColor","pointColorFixed","theme2","visualization","getColorByName","color","pointColor","fieldConfig","custom","pointColorMode","get","PaletteClassic","pointColorIndex","f","disp","display","field","isByValue","index","values","toArray","map","v","getCalculator","pointSizeHints","pointSizeConfig","pointSizeFixed","fixed","pointSize","pointSizeIndex","s","Quadratic","vals","Array","length","i","min","max","name","x","legend","label","getItemKey","yAxis","line","None","lineWidth","lineStyle","lineColor","point","pointSymbol","from","Never","labelValue","hints","mode","numericIndicies","exclude","includes","push","scatterSeries","qt","hRect","drawBubblesFactory","opts","drawBubbles","u","seriesIdx","idx0","idx1","orient","dataX","dataY","scaleX","scaleY","valToPosX","valToPosY","xOff","yOff","xDim","yDim","moveTo","lineTo","rect","arc","scatterInfo","d","data","showLine","showPoints","Always","Auto","strokeWidth","ctx","save","bbox","left","top","width","height","clip","fillStyle","fill","strokeStyle","stroke","deg360","Math","PI","xKey","key","yKey","pointHints","colorByValue","maxSize","devicePixelRatio","filtLft","posToVal","filtRgt","filtBtm","filtTop","sizes","size","pointColors","pointAlpha","linePath","Path2D","xVal","yVal","cx","cy","beginPath","each","lineCap","setLineDash","dash","restore","dataIdx","lft","wid","hgt","add","w","h","sidx","didx","setCursor","drag","setScale","dist","Infinity","cursor","o","ocx","ocy","dx","dy","sqrt","points","addHook","r","over","style","overflow","idxs","sel","scatterIndex","pageX","pageY","undefined","clear","forEach","_paths","setMode","xField","addScale","scaleKey","isTime","orientation","Horizontal","direction","Right","range","addAxis","placement","axisPlacement","Hidden","Bottom","show","axisLabel","asSingleValue","unit","Vertical","Up","splits","text","addSeries","facets","scale","auto","pathBuilder","fillColor","prepData","info","idx","colorValues","colorAlphaValues","isArray","c","asArray","lookup"],"sources":["/home/soula/grafana/public/app/plugins/panel/xychart/scatter.ts"],"sourcesContent":["import uPlot from 'uplot';\n\nimport {\n  DataFrame,\n  FieldColorModeId,\n  fieldColorModeRegistry,\n  getDisplayProcessor,\n  getFieldColorModeForField,\n  getFieldDisplayName,\n  getFieldSeriesColor,\n  GrafanaTheme2,\n} from '@grafana/data';\nimport { alpha } from '@grafana/data/src/themes/colorManipulator';\nimport { config } from '@grafana/runtime';\nimport { AxisPlacement, ScaleDirection, ScaleOrientation, VisibilityMode } from '@grafana/schema';\nimport { UPlotConfigBuilder } from '@grafana/ui';\nimport { FacetedData, FacetSeries } from '@grafana/ui/src/components/uPlot/types';\nimport {\n  findFieldIndex,\n  getScaledDimensionForField,\n  ScaleDimensionConfig,\n  ScaleDimensionMode,\n} from 'app/features/dimensions';\n\nimport { pointWithin, Quadtree, Rect } from '../barchart/quadtree';\n\nimport { isGraphable } from './dims';\nimport { defaultScatterConfig, ScatterFieldConfig, ScatterLineMode, XYChartOptions } from './models.gen';\nimport { DimensionValues, ScatterHoverCallback, ScatterSeries } from './types';\n\nexport interface ScatterPanelInfo {\n  error?: string;\n  series: ScatterSeries[];\n  builder?: UPlotConfigBuilder;\n}\n\n/**\n * This is called when options or structure rev changes\n */\nexport function prepScatter(\n  options: XYChartOptions,\n  getData: () => DataFrame[],\n  theme: GrafanaTheme2,\n  ttip: ScatterHoverCallback\n): ScatterPanelInfo {\n  let series: ScatterSeries[];\n  let builder: UPlotConfigBuilder;\n\n  try {\n    series = prepSeries(options, getData());\n    builder = prepConfig(getData, series, theme, ttip);\n  } catch (e) {\n    console.log('prepScatter ERROR', e);\n    const errorMessage = e instanceof Error ? e.message : 'Unknown error in prepScatter';\n    return {\n      error: errorMessage,\n      series: [],\n    };\n  }\n\n  return {\n    series,\n    builder,\n  };\n}\n\ninterface Dims {\n  pointColorIndex?: number;\n  pointColorFixed?: string;\n\n  pointSizeIndex?: number;\n  pointSizeConfig?: ScaleDimensionConfig;\n}\n\nfunction getScatterSeries(\n  seriesIndex: number,\n  frames: DataFrame[],\n  frameIndex: number,\n  xIndex: number,\n  yIndex: number,\n  dims: Dims\n): ScatterSeries {\n  const frame = frames[frameIndex];\n  const y = frame.fields[yIndex];\n  let state = y.state ?? {};\n  state.seriesIndex = seriesIndex;\n  y.state = state;\n\n  // Color configs\n  //----------------\n  let seriesColor = dims.pointColorFixed\n    ? config.theme2.visualization.getColorByName(dims.pointColorFixed)\n    : getFieldSeriesColor(y, config.theme2).color;\n  let pointColor: DimensionValues<string> = () => seriesColor;\n  const fieldConfig: ScatterFieldConfig = { ...defaultScatterConfig, ...y.config.custom };\n  let pointColorMode = fieldColorModeRegistry.get(FieldColorModeId.PaletteClassic);\n  if (dims.pointColorIndex) {\n    const f = frames[frameIndex].fields[dims.pointColorIndex];\n    if (f) {\n      const disp =\n        f.display ??\n        getDisplayProcessor({\n          field: f,\n          theme: config.theme2,\n        });\n      pointColorMode = getFieldColorModeForField(y);\n      if (pointColorMode.isByValue) {\n        const index = dims.pointColorIndex;\n        pointColor = (frame: DataFrame) => {\n          // Yes we can improve this later\n          return frame.fields[index].values.toArray().map((v) => disp(v).color!);\n        };\n      } else {\n        seriesColor = pointColorMode.getCalculator(f, config.theme2)(f.values.get(0), 1);\n        pointColor = () => seriesColor;\n      }\n    }\n  }\n\n  // Size configs\n  //----------------\n  let pointSizeHints = dims.pointSizeConfig;\n  let pointSizeFixed = dims.pointSizeConfig?.fixed ?? y.config.custom?.pointSizeConfig?.fixed ?? 5;\n  let pointSize: DimensionValues<number> = () => pointSizeFixed;\n  if (dims.pointSizeIndex) {\n    pointSize = (frame) => {\n      const s = getScaledDimensionForField(\n        frame.fields[dims.pointSizeIndex!],\n        dims.pointSizeConfig!,\n        ScaleDimensionMode.Quadratic\n      );\n      const vals = Array(frame.length);\n      for (let i = 0; i < frame.length; i++) {\n        vals[i] = s.get(i);\n      }\n      return vals;\n    };\n  } else {\n    pointSizeHints = {\n      fixed: pointSizeFixed,\n      min: pointSizeFixed,\n      max: pointSizeFixed,\n    };\n  }\n\n  // Series config\n  //----------------\n  const name = getFieldDisplayName(y, frame, frames);\n  return {\n    name,\n\n    frame: (frames) => frames[frameIndex],\n\n    x: (frame) => frame.fields[xIndex],\n    y: (frame) => frame.fields[yIndex],\n    legend: (frame) => {\n      return [\n        {\n          label: name,\n          color: seriesColor, // single color for series?\n          getItemKey: () => name,\n          yAxis: yIndex, // << but not used\n        },\n      ];\n    },\n\n    line: fieldConfig.line ?? ScatterLineMode.None,\n    lineWidth: fieldConfig.lineWidth ?? 2,\n    lineStyle: fieldConfig.lineStyle!,\n    lineColor: () => seriesColor,\n\n    point: fieldConfig.point!,\n    pointSize,\n    pointColor,\n    pointSymbol: (frame: DataFrame, from?: number) => 'circle', // single field, multiple symbols.... kinda equals multiple series ðŸ¤”\n\n    label: VisibilityMode.Never,\n    labelValue: () => '',\n\n    hints: {\n      pointSize: pointSizeHints!,\n      pointColor: {\n        mode: pointColorMode,\n      },\n    },\n  };\n}\n\nfunction prepSeries(options: XYChartOptions, frames: DataFrame[]): ScatterSeries[] {\n  let seriesIndex = 0;\n  if (!frames.length) {\n    throw 'missing data';\n  }\n\n  if (options.mode === 'explicit') {\n    if (options.series?.length) {\n      for (const series of options.series) {\n        if (!series?.x) {\n          throw 'Select X dimension';\n        }\n\n        if (!series?.y) {\n          throw 'Select Y dimension';\n        }\n\n        for (let frameIndex = 0; frameIndex < frames.length; frameIndex++) {\n          const frame = frames[frameIndex];\n          const xIndex = findFieldIndex(frame, series.x);\n\n          if (xIndex != null) {\n            // TODO: this should find multiple y fields\n            const yIndex = findFieldIndex(frame, series.y);\n\n            if (yIndex == null) {\n              throw 'Y must be in the same frame as X';\n            }\n\n            const dims: Dims = {\n              pointColorFixed: series.pointColor?.fixed,\n              pointColorIndex: findFieldIndex(frame, series.pointColor?.field),\n              pointSizeConfig: series.pointSize,\n              pointSizeIndex: findFieldIndex(frame, series.pointSize?.field),\n            };\n            return [getScatterSeries(seriesIndex++, frames, frameIndex, xIndex, yIndex, dims)];\n          }\n        }\n      }\n    }\n  }\n\n  // Default behavior\n  const dims = options.dims ?? {};\n  const frameIndex = dims.frame ?? 0;\n  const frame = frames[frameIndex];\n  const numericIndicies: number[] = [];\n\n  let xIndex = findFieldIndex(frame, dims.x);\n  for (let i = 0; i < frame.fields.length; i++) {\n    if (isGraphable(frame.fields[i])) {\n      if (xIndex == null || i === xIndex) {\n        xIndex = i;\n        continue;\n      }\n      if (dims.exclude && dims.exclude.includes(getFieldDisplayName(frame.fields[i], frame, frames))) {\n        continue; // skip\n      }\n\n      numericIndicies.push(i);\n    }\n  }\n\n  if (xIndex == null) {\n    throw 'Missing X dimension';\n  }\n\n  if (!numericIndicies.length) {\n    throw 'No Y values';\n  }\n  return numericIndicies.map((yIndex) => getScatterSeries(seriesIndex++, frames, frameIndex, xIndex!, yIndex, {}));\n}\n\ninterface DrawBubblesOpts {\n  each: (u: uPlot, seriesIdx: number, dataIdx: number, lft: number, top: number, wid: number, hgt: number) => void;\n  disp: {\n    //unit: 3,\n    size: {\n      values: (u: uPlot, seriesIdx: number) => number[];\n    };\n    color: {\n      values: (u: uPlot, seriesIdx: number) => string[];\n      alpha: (u: uPlot, seriesIdx: number) => string[];\n    };\n  };\n}\n\n//const prepConfig: UPlotConfigPrepFnXY<XYChartOptions> = ({ frames, series, theme }) => {\nconst prepConfig = (\n  getData: () => DataFrame[],\n  scatterSeries: ScatterSeries[],\n  theme: GrafanaTheme2,\n  ttip: ScatterHoverCallback\n) => {\n  let qt: Quadtree;\n  let hRect: Rect | null;\n\n  function drawBubblesFactory(opts: DrawBubblesOpts) {\n    const drawBubbles: uPlot.Series.PathBuilder = (u, seriesIdx, idx0, idx1) => {\n      uPlot.orient(\n        u,\n        seriesIdx,\n        (\n          series,\n          dataX,\n          dataY,\n          scaleX,\n          scaleY,\n          valToPosX,\n          valToPosY,\n          xOff,\n          yOff,\n          xDim,\n          yDim,\n          moveTo,\n          lineTo,\n          rect,\n          arc\n        ) => {\n          const scatterInfo = scatterSeries[seriesIdx - 1];\n          let d = u.data[seriesIdx] as unknown as FacetSeries;\n\n          let showLine = scatterInfo.line !== ScatterLineMode.None;\n          let showPoints = scatterInfo.point === VisibilityMode.Always;\n          if (!showPoints && scatterInfo.point === VisibilityMode.Auto) {\n            showPoints = d[0].length < 1000;\n          }\n\n          // always show something\n          if (!showPoints && !showLine) {\n            showLine = true;\n          }\n\n          let strokeWidth = 1;\n\n          u.ctx.save();\n\n          u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n          u.ctx.clip();\n\n          u.ctx.fillStyle = (series.fill as any)(); // assumes constant\n          u.ctx.strokeStyle = (series.stroke as any)();\n          u.ctx.lineWidth = strokeWidth;\n\n          let deg360 = 2 * Math.PI;\n\n          let xKey = scaleX.key!;\n          let yKey = scaleY.key!;\n\n          let pointHints = scatterInfo.hints.pointSize;\n          const colorByValue = scatterInfo.hints.pointColor.mode.isByValue;\n\n          let maxSize = (pointHints.max ?? pointHints.fixed) * devicePixelRatio;\n\n          // todo: this depends on direction & orientation\n          // todo: calc once per redraw, not per path\n          let filtLft = u.posToVal(-maxSize / 2, xKey);\n          let filtRgt = u.posToVal(u.bbox.width / devicePixelRatio + maxSize / 2, xKey);\n          let filtBtm = u.posToVal(u.bbox.height / devicePixelRatio + maxSize / 2, yKey);\n          let filtTop = u.posToVal(-maxSize / 2, yKey);\n\n          let sizes = opts.disp.size.values(u, seriesIdx);\n          let pointColors = opts.disp.color.values(u, seriesIdx);\n          let pointAlpha = opts.disp.color.alpha(u, seriesIdx);\n\n          let linePath: Path2D | null = showLine ? new Path2D() : null;\n\n          for (let i = 0; i < d[0].length; i++) {\n            let xVal = d[0][i];\n            let yVal = d[1][i];\n            let size = sizes[i] * devicePixelRatio;\n\n            if (xVal >= filtLft && xVal <= filtRgt && yVal >= filtBtm && yVal <= filtTop) {\n              let cx = valToPosX(xVal, scaleX, xDim, xOff);\n              let cy = valToPosY(yVal, scaleY, yDim, yOff);\n\n              if (showLine) {\n                linePath!.lineTo(cx, cy);\n              }\n\n              if (showPoints) {\n                u.ctx.moveTo(cx + size / 2, cy);\n                u.ctx.beginPath();\n                u.ctx.arc(cx, cy, size / 2, 0, deg360);\n\n                if (colorByValue) {\n                  u.ctx.fillStyle = pointAlpha[i];\n                  u.ctx.strokeStyle = pointColors[i];\n                }\n\n                u.ctx.fill();\n                u.ctx.stroke();\n                opts.each(\n                  u,\n                  seriesIdx,\n                  i,\n                  cx - size / 2 - strokeWidth / 2,\n                  cy - size / 2 - strokeWidth / 2,\n                  size + strokeWidth,\n                  size + strokeWidth\n                );\n              }\n            }\n          }\n\n          if (showLine) {\n            let frame = scatterInfo.frame(getData());\n            u.ctx.strokeStyle = scatterInfo.lineColor(frame);\n            u.ctx.lineWidth = scatterInfo.lineWidth * devicePixelRatio;\n\n            const { lineStyle } = scatterInfo;\n            if (lineStyle && lineStyle.fill !== 'solid') {\n              if (lineStyle.fill === 'dot') {\n                u.ctx.lineCap = 'round';\n              }\n              u.ctx.setLineDash(lineStyle.dash ?? [10, 10]);\n            }\n\n            u.ctx.stroke(linePath!);\n          }\n\n          u.ctx.restore();\n        }\n      );\n\n      return null;\n    };\n\n    return drawBubbles;\n  }\n\n  let drawBubbles = drawBubblesFactory({\n    disp: {\n      size: {\n        //unit: 3, // raw CSS pixels\n        values: (u, seriesIdx) => {\n          return u.data[seriesIdx][2] as any; // already contains final pixel geometry\n          //let [minValue, maxValue] = getSizeMinMax(u);\n          //return u.data[seriesIdx][2].map(v => getSize(v, minValue, maxValue));\n        },\n      },\n      color: {\n        // string values\n        values: (u, seriesIdx) => {\n          return u.data[seriesIdx][3] as any;\n        },\n        alpha: (u, seriesIdx) => {\n          return u.data[seriesIdx][4] as any;\n        },\n      },\n    },\n    each: (u, seriesIdx, dataIdx, lft, top, wid, hgt) => {\n      // we get back raw canvas coords (included axes & padding). translate to the plotting area origin\n      lft -= u.bbox.left;\n      top -= u.bbox.top;\n      qt.add({ x: lft, y: top, w: wid, h: hgt, sidx: seriesIdx, didx: dataIdx });\n    },\n  });\n\n  const builder = new UPlotConfigBuilder();\n\n  builder.setCursor({\n    drag: { setScale: true },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        hRect = null;\n\n        let dist = Infinity;\n        let cx = u.cursor.left! * devicePixelRatio;\n        let cy = u.cursor.top! * devicePixelRatio;\n\n        qt.get(cx, cy, 1, 1, (o) => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            let ocx = o.x + o.w / 2;\n            let ocy = o.y + o.h / 2;\n\n            let dx = ocx - cx;\n            let dy = ocy - cy;\n\n            let d = Math.sqrt(dx ** 2 + dy ** 2);\n\n            // test against radius for actual hover\n            if (d <= o.w / 2) {\n              // only hover bbox with closest distance\n              if (d <= dist) {\n                dist = d;\n                hRect = o;\n              }\n            }\n          }\n        });\n      }\n\n      return hRect && seriesIdx === hRect.sidx ? hRect.didx : null;\n    },\n    points: {\n      size: (u, seriesIdx) => {\n        return hRect && seriesIdx === hRect.sidx ? hRect.w / devicePixelRatio : 0;\n      },\n      fill: (u, seriesIdx) => 'rgba(255,255,255,0.4)',\n    },\n  });\n\n  // clip hover points/bubbles to plotting area\n  builder.addHook('init', (u, r) => {\n    u.over.style.overflow = 'hidden';\n  });\n\n  let rect: DOMRect;\n\n  // rect of .u-over (grid area)\n  builder.addHook('syncRect', (u, r) => {\n    rect = r;\n  });\n\n  builder.addHook('setLegend', (u) => {\n    // console.log('TTIP???', u.cursor.idxs);\n    if (u.cursor.idxs != null) {\n      for (let i = 0; i < u.cursor.idxs.length; i++) {\n        const sel = u.cursor.idxs[i];\n        if (sel != null) {\n          ttip({\n            scatterIndex: i - 1,\n            xIndex: sel,\n            pageX: rect.left + u.cursor.left!,\n            pageY: rect.top + u.cursor.top!,\n          });\n          return; // only show the first one\n        }\n      }\n    }\n    ttip(undefined);\n  });\n\n  builder.addHook('drawClear', (u) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n\n    qt.clear();\n\n    // force-clear the path cache to cause drawBars() to rebuild new quadtree\n    u.series.forEach((s, i) => {\n      if (i > 0) {\n        // @ts-ignore\n        s._paths = null;\n      }\n    });\n  });\n\n  builder.setMode(2);\n\n  const frames = getData();\n  let xField = scatterSeries[0].x(scatterSeries[0].frame(frames));\n\n  builder.addScale({\n    scaleKey: 'x',\n    isTime: false,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    range: (u, min, max) => [min, max],\n  });\n\n  builder.addAxis({\n    scaleKey: 'x',\n    placement:\n      xField.config.custom?.axisPlacement !== AxisPlacement.Hidden ? AxisPlacement.Bottom : AxisPlacement.Hidden,\n    show: xField.config.custom?.axisPlacement !== AxisPlacement.Hidden,\n    theme,\n    label: xField.config.custom.axisLabel,\n  });\n\n  scatterSeries.forEach((s) => {\n    let frame = s.frame(frames);\n    let field = s.y(frame);\n\n    const lineColor = s.lineColor(frame);\n    const pointColor = asSingleValue(frame, s.pointColor) as string;\n    //const lineColor = s.lineColor(frame);\n    //const lineWidth = s.lineWidth;\n\n    let scaleKey = field.config.unit ?? 'y';\n\n    builder.addScale({\n      scaleKey,\n      orientation: ScaleOrientation.Vertical,\n      direction: ScaleDirection.Up,\n      range: (u, min, max) => [min, max],\n    });\n\n    if (field.config.custom?.axisPlacement !== AxisPlacement.Hidden) {\n      builder.addAxis({\n        scaleKey,\n        theme,\n        placement: field.config.custom?.axisPlacement,\n        label: field.config.custom.axisLabel,\n        values: (u, splits) => splits.map((s) => field.display!(s).text),\n      });\n    }\n\n    builder.addSeries({\n      facets: [\n        {\n          scale: 'x',\n          auto: true,\n        },\n        {\n          scale: scaleKey,\n          auto: true,\n        },\n      ],\n      pathBuilder: drawBubbles, // drawBubbles({disp: {size: {values: () => }}})\n      theme,\n      scaleKey: '', // facets' scales used (above)\n      lineColor: lineColor as string,\n      fillColor: alpha(pointColor, 0.5),\n    });\n  });\n\n  /*\n  builder.setPrepData((frames) => {\n    let seriesData = lookup.fieldMaps.flatMap((f, i) => {\n      let { fields } = frames[i];\n\n      return f.y.map((yIndex, frameSeriesIndex) => {\n        let xValues = fields[f.x[frameSeriesIndex]].values.toArray();\n        let yValues = fields[f.y[frameSeriesIndex]].values.toArray();\n        let sizeValues = f.size![frameSeriesIndex](frames[i]);\n\n        if (!Array.isArray(sizeValues)) {\n          sizeValues = Array(xValues.length).fill(sizeValues);\n        }\n\n        return [xValues, yValues, sizeValues];\n      });\n    });\n\n    return [null, ...seriesData];\n  });\n  */\n\n  return builder;\n};\n\n/**\n * This is called everytime the data changes\n *\n * from?  is this where we would support that?  -- need the previous values\n */\nexport function prepData(info: ScatterPanelInfo, data: DataFrame[], from?: number): FacetedData {\n  if (info.error) {\n    return [null];\n  }\n  return [\n    null,\n    ...info.series.map((s, idx) => {\n      const frame = s.frame(data);\n\n      let colorValues;\n      let colorAlphaValues;\n      const r = s.pointColor(frame);\n      if (Array.isArray(r)) {\n        colorValues = r;\n        colorAlphaValues = r.map((c) => alpha(c as string, 0.5));\n      } else {\n        colorValues = Array(frame.length).fill(r);\n        colorAlphaValues = Array(frame.length).fill(alpha(r as string, 0.5));\n      }\n      return [\n        s.x(frame).values.toArray(), // X\n        s.y(frame).values.toArray(), // Y\n        asArray(frame, s.pointSize),\n        colorValues,\n        colorAlphaValues,\n      ];\n    }),\n  ];\n}\n\nfunction asArray<T>(frame: DataFrame, lookup: DimensionValues<T>): T[] {\n  const r = lookup(frame);\n  if (Array.isArray(r)) {\n    return r;\n  }\n  return Array(frame.length).fill(r);\n}\n\nfunction asSingleValue<T>(frame: DataFrame, lookup: DimensionValues<T>): T {\n  const r = lookup(frame);\n  if (Array.isArray(r)) {\n    return r[0];\n  }\n  return r;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}