{"ast":null,"code":"import { NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\nimport { getNonOverlappingDuration, getStats, makeFrames, makeSpanMap } from '../../../../core/utils/tracing';\nexport function createGraphFrames(data) {\n  const {\n    nodes,\n    edges\n  } = convertTraceToGraph(data);\n  const [nodesFrame, edgesFrame] = makeFrames();\n\n  for (const node of nodes) {\n    nodesFrame.add(node);\n  }\n\n  for (const edge of edges) {\n    edgesFrame.add(edge);\n  }\n\n  return [nodesFrame, edgesFrame];\n}\n\nfunction convertTraceToGraph(spans) {\n  const nodes = [];\n  const edges = [];\n  const traceDuration = findTraceDuration(spans);\n  const spanMap = makeSpanMap(index => {\n    if (index >= spans.length) {\n      return undefined;\n    }\n\n    return {\n      span: spans[index],\n      id: spans[index].id,\n      parentIds: spans[index].parentId ? [spans[index].parentId] : []\n    };\n  });\n\n  for (const span of spans) {\n    var _span$localEndpoint, _span$remoteEndpoint;\n\n    const ranges = spanMap[span.id].children.map(c => {\n      const span = spanMap[c].span;\n      return [span.timestamp, span.timestamp + span.duration];\n    });\n    const childrenDuration = getNonOverlappingDuration(ranges);\n    const selfDuration = span.duration - childrenDuration;\n    const stats = getStats(span.duration / 1000, traceDuration / 1000, selfDuration / 1000);\n    nodes.push({\n      [Fields.id]: span.id,\n      [Fields.title]: ((_span$localEndpoint = span.localEndpoint) === null || _span$localEndpoint === void 0 ? void 0 : _span$localEndpoint.serviceName) || ((_span$remoteEndpoint = span.remoteEndpoint) === null || _span$remoteEndpoint === void 0 ? void 0 : _span$remoteEndpoint.serviceName) || 'unknown',\n      [Fields.subTitle]: span.name,\n      [Fields.mainStat]: stats.main,\n      [Fields.secondaryStat]: stats.secondary,\n      [Fields.color]: selfDuration / traceDuration\n    });\n\n    if (span.parentId && spanMap[span.parentId].span) {\n      edges.push({\n        [Fields.id]: span.parentId + '--' + span.id,\n        [Fields.target]: span.id,\n        [Fields.source]: span.parentId\n      });\n    }\n  }\n\n  return {\n    nodes,\n    edges\n  };\n}\n/**\n * Get the duration of the whole trace as it isn't a part of the response data.\n * Note: Seems like this should be the same as just longest span, but this is probably safer.\n */\n\n\nfunction findTraceDuration(spans) {\n  let traceEndTime = 0;\n  let traceStartTime = Infinity;\n\n  for (const span of spans) {\n    if (span.timestamp < traceStartTime) {\n      traceStartTime = span.timestamp;\n    }\n\n    if (span.timestamp + span.duration > traceEndTime) {\n      traceEndTime = span.timestamp + span.duration;\n    }\n  }\n\n  return traceEndTime - traceStartTime;\n}","map":{"version":3,"names":["NodeGraphDataFrameFieldNames","Fields","getNonOverlappingDuration","getStats","makeFrames","makeSpanMap","createGraphFrames","data","nodes","edges","convertTraceToGraph","nodesFrame","edgesFrame","node","add","edge","spans","traceDuration","findTraceDuration","spanMap","index","length","undefined","span","id","parentIds","parentId","ranges","children","map","c","timestamp","duration","childrenDuration","selfDuration","stats","push","title","localEndpoint","serviceName","remoteEndpoint","subTitle","name","mainStat","main","secondaryStat","secondary","color","target","source","traceEndTime","traceStartTime","Infinity"],"sources":["/home/soula/grafana/public/app/plugins/datasource/zipkin/utils/graphTransform.ts"],"sourcesContent":["import { DataFrame, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\n\nimport { getNonOverlappingDuration, getStats, makeFrames, makeSpanMap } from '../../../../core/utils/tracing';\nimport { ZipkinSpan } from '../types';\n\ninterface Node {\n  [Fields.id]: string;\n  [Fields.title]: string;\n  [Fields.subTitle]: string;\n  [Fields.mainStat]: string;\n  [Fields.secondaryStat]: string;\n  [Fields.color]: number;\n}\n\ninterface Edge {\n  [Fields.id]: string;\n  [Fields.target]: string;\n  [Fields.source]: string;\n}\n\nexport function createGraphFrames(data: ZipkinSpan[]): DataFrame[] {\n  const { nodes, edges } = convertTraceToGraph(data);\n  const [nodesFrame, edgesFrame] = makeFrames();\n\n  for (const node of nodes) {\n    nodesFrame.add(node);\n  }\n\n  for (const edge of edges) {\n    edgesFrame.add(edge);\n  }\n\n  return [nodesFrame, edgesFrame];\n}\n\nfunction convertTraceToGraph(spans: ZipkinSpan[]): { nodes: Node[]; edges: Edge[] } {\n  const nodes: Node[] = [];\n  const edges: Edge[] = [];\n\n  const traceDuration = findTraceDuration(spans);\n  const spanMap = makeSpanMap((index) => {\n    if (index >= spans.length) {\n      return undefined;\n    }\n    return {\n      span: spans[index],\n      id: spans[index].id,\n      parentIds: spans[index].parentId ? [spans[index].parentId!] : [],\n    };\n  });\n\n  for (const span of spans) {\n    const ranges: Array<[number, number]> = spanMap[span.id].children.map((c) => {\n      const span = spanMap[c].span;\n      return [span.timestamp, span.timestamp + span.duration];\n    });\n    const childrenDuration = getNonOverlappingDuration(ranges);\n    const selfDuration = span.duration - childrenDuration;\n    const stats = getStats(span.duration / 1000, traceDuration / 1000, selfDuration / 1000);\n\n    nodes.push({\n      [Fields.id]: span.id,\n      [Fields.title]: span.localEndpoint?.serviceName || span.remoteEndpoint?.serviceName || 'unknown',\n      [Fields.subTitle]: span.name,\n      [Fields.mainStat]: stats.main,\n      [Fields.secondaryStat]: stats.secondary,\n      [Fields.color]: selfDuration / traceDuration,\n    });\n\n    if (span.parentId && spanMap[span.parentId].span) {\n      edges.push({\n        [Fields.id]: span.parentId + '--' + span.id,\n        [Fields.target]: span.id,\n        [Fields.source]: span.parentId,\n      });\n    }\n  }\n\n  return { nodes, edges };\n}\n\n/**\n * Get the duration of the whole trace as it isn't a part of the response data.\n * Note: Seems like this should be the same as just longest span, but this is probably safer.\n */\nfunction findTraceDuration(spans: ZipkinSpan[]): number {\n  let traceEndTime = 0;\n  let traceStartTime = Infinity;\n\n  for (const span of spans) {\n    if (span.timestamp < traceStartTime) {\n      traceStartTime = span.timestamp;\n    }\n\n    if (span.timestamp + span.duration > traceEndTime) {\n      traceEndTime = span.timestamp + span.duration;\n    }\n  }\n  return traceEndTime - traceStartTime;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}