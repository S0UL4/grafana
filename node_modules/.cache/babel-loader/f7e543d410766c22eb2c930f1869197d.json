{"ast":null,"code":"import uPlot from 'uplot';\nimport { alpha } from '@grafana/data/src/themes/colorManipulator';\nimport { VisibilityMode } from '@grafana/schema';\nimport { FIXED_UNIT } from '@grafana/ui/src/components/GraphNG/GraphNG';\nimport { distribute, SPACE_BETWEEN } from 'app/plugins/panel/barchart/distribute';\nimport { pointWithin, Quadtree } from 'app/plugins/panel/barchart/quadtree';\nimport { TimelineMode } from './types';\nconst {\n  round,\n  min,\n  ceil\n} = Math;\nconst textPadding = 2;\nconst pxRatio = devicePixelRatio;\nconst laneDistr = SPACE_BETWEEN;\n\nfunction walk(rowHeight, yIdx, count, dim, draw) {\n  distribute(count, rowHeight, laneDistr, yIdx, (i, offPct, dimPct) => {\n    let laneOffPx = dim * offPct;\n    let laneWidPx = dim * dimPct;\n    draw(i, laneOffPx, laneWidPx);\n  });\n}\n\n/**\n * @internal\n */\nexport function getConfig(opts) {\n  var _size$;\n\n  const {\n    mode,\n    numSeries,\n    isDiscrete,\n    rowHeight = 0,\n    colWidth = 0,\n    showValue,\n    mergeValues = false,\n    theme,\n    label,\n    formatValue,\n    alignValue = 'left',\n    getTimeRange,\n    getValueColor,\n    getFieldConfig,\n    onHover,\n    onLeave\n  } = opts;\n  let qt;\n  const hoverMarks = Array(numSeries).fill(null).map(() => {\n    let mark = document.createElement('div');\n    mark.classList.add('bar-mark');\n    mark.style.position = 'absolute';\n    mark.style.background = 'rgba(255,255,255,0.2)';\n    return mark;\n  }); // Needed for to calculate text positions\n\n  let boxRectsBySeries;\n\n  const resetBoxRectsBySeries = count => {\n    boxRectsBySeries = Array(numSeries).fill(null).map(v => Array(count).fill(null));\n  };\n\n  const font = `500 ${Math.round(12 * devicePixelRatio)}px ${theme.typography.fontFamily}`;\n  const hovered = Array(numSeries).fill(null);\n  const size = [colWidth, Infinity];\n  const gapFactor = 1 - size[0];\n  const maxWidth = ((_size$ = size[1]) !== null && _size$ !== void 0 ? _size$ : Infinity) * pxRatio;\n  const fillPaths = new Map();\n  const strokePaths = new Map();\n\n  function drawBoxes(ctx) {\n    fillPaths.forEach((fillPath, fillStyle) => {\n      ctx.fillStyle = fillStyle;\n      ctx.fill(fillPath);\n    });\n    strokePaths.forEach((strokePath, strokeStyle) => {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke(strokePath);\n    });\n    fillPaths.clear();\n    strokePaths.clear();\n  }\n\n  function putBox(ctx, rect, xOff, yOff, left, top, boxWidth, boxHeight, strokeWidth, seriesIdx, valueIdx, value, discrete) {\n    // do not render super small boxes\n    if (boxWidth < 1) {\n      return;\n    }\n\n    const valueColor = getValueColor(seriesIdx + 1, value);\n    const fieldConfig = getFieldConfig(seriesIdx);\n    const fillColor = getFillColor(fieldConfig, valueColor);\n    boxRectsBySeries[seriesIdx][valueIdx] = {\n      x: round(left - xOff),\n      y: round(top - yOff),\n      w: boxWidth,\n      h: boxHeight,\n      sidx: seriesIdx + 1,\n      didx: valueIdx,\n      // for computing label contrast\n      fillColor\n    };\n\n    if (discrete) {\n      let fillStyle = fillColor;\n      let fillPath = fillPaths.get(fillStyle);\n\n      if (fillPath == null) {\n        fillPaths.set(fillStyle, fillPath = new Path2D());\n      }\n\n      rect(fillPath, left, top, boxWidth, boxHeight);\n\n      if (strokeWidth) {\n        let strokeStyle = valueColor;\n        let strokePath = strokePaths.get(strokeStyle);\n\n        if (strokePath == null) {\n          strokePaths.set(strokeStyle, strokePath = new Path2D());\n        }\n\n        rect(strokePath, left + strokeWidth / 2, top + strokeWidth / 2, boxWidth - strokeWidth, boxHeight - strokeWidth);\n      }\n    } else {\n      ctx.beginPath();\n      rect(ctx, left, top, boxWidth, boxHeight);\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n\n      if (strokeWidth) {\n        ctx.beginPath();\n        rect(ctx, left + strokeWidth / 2, top + strokeWidth / 2, boxWidth - strokeWidth, boxHeight - strokeWidth);\n        ctx.strokeStyle = valueColor;\n        ctx.lineWidth = strokeWidth;\n        ctx.stroke();\n      }\n    }\n  }\n\n  const drawPaths = (u, sidx, idx0, idx1) => {\n    uPlot.orient(u, sidx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim, moveTo, lineTo, rect) => {\n      let strokeWidth = round((series.width || 0) * pxRatio);\n      let discrete = isDiscrete(sidx);\n      u.ctx.save();\n      rect(u.ctx, u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n      u.ctx.clip();\n      walk(rowHeight, sidx - 1, numSeries, yDim, (iy, y0, height) => {\n        if (mode === TimelineMode.Changes) {\n          for (let ix = 0; ix < dataY.length; ix++) {\n            let yVal = dataY[ix];\n\n            if (yVal != null) {\n              let left = Math.round(valToPosX(dataX[ix], scaleX, xDim, xOff));\n              let nextIx = ix;\n\n              while (++nextIx < dataY.length && (dataY[nextIx] === undefined || mergeValues && dataY[nextIx] === yVal)) {} // to now (not to end of chart)\n\n\n              let right = nextIx === dataY.length ? xOff + xDim + strokeWidth : Math.round(valToPosX(dataX[nextIx], scaleX, xDim, xOff));\n              putBox(u.ctx, rect, xOff, yOff, left, round(yOff + y0), right - left, round(height), strokeWidth, iy, ix, yVal, discrete);\n              ix = nextIx - 1;\n            }\n          }\n        } else if (mode === TimelineMode.Samples) {\n          let colWid = valToPosX(dataX[1], scaleX, xDim, xOff) - valToPosX(dataX[0], scaleX, xDim, xOff);\n          let gapWid = colWid * gapFactor;\n          let barWid = round(min(maxWidth, colWid - gapWid) - strokeWidth);\n          let xShift = barWid / 2; //let xShift = align === 1 ? 0 : align === -1 ? barWid : barWid / 2;\n\n          for (let ix = idx0; ix <= idx1; ix++) {\n            if (dataY[ix] != null) {\n              // TODO: all xPos can be pre-computed once for all series in aligned set\n              let left = valToPosX(dataX[ix], scaleX, xDim, xOff);\n              putBox(u.ctx, rect, xOff, yOff, round(left - xShift), round(yOff + y0), barWid, round(height), strokeWidth, iy, ix, dataY[ix], discrete);\n            }\n          }\n        }\n      });\n\n      if (discrete) {\n        u.ctx.lineWidth = strokeWidth;\n        drawBoxes(u.ctx);\n      }\n\n      u.ctx.restore();\n    });\n    return null;\n  };\n\n  const drawPoints = formatValue == null || showValue === VisibilityMode.Never ? false : (u, sidx, i0, i1) => {\n    u.ctx.save();\n    u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n    u.ctx.clip();\n    u.ctx.font = font;\n    u.ctx.textAlign = mode === TimelineMode.Changes ? alignValue : 'center';\n    u.ctx.textBaseline = 'middle';\n    uPlot.orient(u, sidx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n      let strokeWidth = round((series.width || 0) * pxRatio);\n      let y = round(yOff + yMids[sidx - 1]);\n\n      for (let ix = 0; ix < dataY.length; ix++) {\n        if (dataY[ix] != null) {\n          const boxRect = boxRectsBySeries[sidx - 1][ix]; // Todo refine this to better know when to not render text (when values do not fit)\n\n          if (!boxRect || showValue === VisibilityMode.Auto && boxRect.w < 25) {\n            continue;\n          }\n\n          if (boxRect.x >= xDim) {\n            continue; // out of view\n          } // center-aligned\n\n\n          let x = round(boxRect.x + xOff + boxRect.w / 2);\n          const txt = formatValue(sidx, dataY[ix]);\n\n          if (mode === TimelineMode.Changes) {\n            if (alignValue === 'left') {\n              x = round(boxRect.x + xOff + strokeWidth + textPadding);\n            } else if (alignValue === 'right') {\n              x = round(boxRect.x + xOff + boxRect.w - strokeWidth - textPadding);\n            }\n          } // TODO: cache by fillColor to avoid setting ctx for label\n\n\n          u.ctx.fillStyle = theme.colors.getContrastText(boxRect.fillColor, 3);\n          u.ctx.fillText(txt, x, y);\n        }\n      }\n    });\n    u.ctx.restore();\n    return false;\n  };\n\n  const init = u => {\n    let over = u.over;\n    over.style.overflow = 'hidden';\n    hoverMarks.forEach(m => {\n      over.appendChild(m);\n    });\n  };\n\n  const drawClear = u => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n    qt.clear();\n    resetBoxRectsBySeries(u.data[0].length); // force-clear the path cache to cause drawBars() to rebuild new quadtree\n\n    u.series.forEach(s => {\n      // @ts-ignore\n      s._paths = null;\n    });\n  };\n\n  function setHoverMark(i, o) {\n    let h = hoverMarks[i];\n\n    if (o) {\n      h.style.display = '';\n      h.style.left = round(o.x / pxRatio) + 'px';\n      h.style.top = round(o.y / pxRatio) + 'px';\n      h.style.width = round(o.w / pxRatio) + 'px';\n      h.style.height = round(o.h / pxRatio) + 'px';\n    } else {\n      h.style.display = 'none';\n    }\n\n    hovered[i] = o;\n  }\n\n  let hoveredAtCursor;\n\n  function hoverMulti(cx, cy) {\n    let foundAtCursor;\n\n    for (let i = 0; i < numSeries; i++) {\n      let found;\n\n      if (cx >= 0) {\n        let cy2 = yMids[i];\n        qt.get(cx, cy2, 1, 1, o => {\n          if (pointWithin(cx, cy2, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            found = o;\n\n            if (Math.abs(cy - cy2) <= o.h / 2) {\n              foundAtCursor = o;\n            }\n          }\n        });\n      }\n\n      if (found) {\n        if (found !== hovered[i]) {\n          setHoverMark(i, found);\n        }\n      } else if (hovered[i] != null) {\n        setHoverMark(i, null);\n      }\n    }\n\n    if (foundAtCursor) {\n      if (foundAtCursor !== hoveredAtCursor) {\n        hoveredAtCursor = foundAtCursor;\n        onHover(foundAtCursor.sidx, foundAtCursor.didx, foundAtCursor);\n      }\n    } else if (hoveredAtCursor) {\n      hoveredAtCursor = undefined;\n      onLeave();\n    }\n  }\n\n  function hoverOne(cx, cy) {\n    let foundAtCursor;\n    qt.get(cx, cy, 1, 1, o => {\n      if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n        foundAtCursor = o;\n      }\n    });\n\n    if (foundAtCursor) {\n      setHoverMark(0, foundAtCursor);\n\n      if (foundAtCursor !== hoveredAtCursor) {\n        hoveredAtCursor = foundAtCursor;\n        onHover(foundAtCursor.sidx, foundAtCursor.didx, foundAtCursor);\n      }\n    } else if (hoveredAtCursor) {\n      setHoverMark(0, null);\n      hoveredAtCursor = undefined;\n      onLeave();\n    }\n  }\n\n  const doHover = mode === TimelineMode.Changes ? hoverMulti : hoverOne;\n\n  const setCursor = u => {\n    let cx = round(u.cursor.left * pxRatio);\n    let cy = round(u.cursor.top * pxRatio); // if quadtree is empty, fill it\n\n    if (!qt.o.length && qt.q == null) {\n      for (const seriesRects of boxRectsBySeries) {\n        for (const rect of seriesRects) {\n          rect && qt.add(rect);\n        }\n      }\n    }\n\n    doHover(cx, cy);\n  }; // hide y crosshair & hover points\n\n\n  const cursor = {\n    y: false,\n    x: mode === TimelineMode.Changes,\n    points: {\n      show: false\n    }\n  };\n  const yMids = Array(numSeries).fill(0);\n  const ySplits = Array(numSeries).fill(0);\n  return {\n    cursor,\n    xSplits: mode === TimelineMode.Samples ? (u, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {\n      let splits = [];\n      let dataIncr = u.data[0][1] - u.data[0][0];\n      let skipFactor = ceil(foundIncr / dataIncr);\n\n      for (let i = 0; i < u.data[0].length; i += skipFactor) {\n        let v = u.data[0][i];\n\n        if (v >= scaleMin && v <= scaleMax) {\n          splits.push(v);\n        }\n      }\n\n      return splits;\n    } : null,\n    xRange: u => {\n      const r = getTimeRange();\n      let min = r.from.valueOf();\n      let max = r.to.valueOf();\n\n      if (mode === TimelineMode.Samples) {\n        let colWid = u.data[0][1] - u.data[0][0];\n        let scalePad = colWid / 2;\n\n        if (min <= u.data[0][0]) {\n          min = u.data[0][0] - scalePad;\n        }\n\n        let lastIdx = u.data[0].length - 1;\n\n        if (max >= u.data[0][lastIdx]) {\n          max = u.data[0][lastIdx] + scalePad;\n        }\n      }\n\n      return [min, max];\n    },\n    ySplits: u => {\n      walk(rowHeight, null, numSeries, u.bbox.height, (iy, y0, hgt) => {\n        // vertical midpoints of each series' timeline (stored relative to .u-over)\n        yMids[iy] = round(y0 + hgt / 2);\n        ySplits[iy] = u.posToVal(yMids[iy] / pxRatio, FIXED_UNIT);\n      });\n      return ySplits;\n    },\n    yValues: (u, splits) => splits.map((v, i) => label(i + 1)),\n    yRange: [0, 1],\n    // pathbuilders\n    drawPaths,\n    drawPoints,\n    // hooks\n    init,\n    drawClear,\n    setCursor\n  };\n}\n\nfunction getFillColor(fieldConfig, color) {\n  var _fieldConfig$fillOpac;\n\n  // if #rgba with pre-existing alpha. ignore fieldConfig.fillOpacity\n  // e.g. thresholds with opacity\n  if (color[0] === '#' && color.length === 9) {\n    return color;\n  }\n\n  const opacityPercent = ((_fieldConfig$fillOpac = fieldConfig.fillOpacity) !== null && _fieldConfig$fillOpac !== void 0 ? _fieldConfig$fillOpac : 100) / 100;\n  return alpha(color, opacityPercent);\n}","map":{"version":3,"names":["uPlot","alpha","VisibilityMode","FIXED_UNIT","distribute","SPACE_BETWEEN","pointWithin","Quadtree","TimelineMode","round","min","ceil","Math","textPadding","pxRatio","devicePixelRatio","laneDistr","walk","rowHeight","yIdx","count","dim","draw","i","offPct","dimPct","laneOffPx","laneWidPx","getConfig","opts","mode","numSeries","isDiscrete","colWidth","showValue","mergeValues","theme","label","formatValue","alignValue","getTimeRange","getValueColor","getFieldConfig","onHover","onLeave","qt","hoverMarks","Array","fill","map","mark","document","createElement","classList","add","style","position","background","boxRectsBySeries","resetBoxRectsBySeries","v","font","typography","fontFamily","hovered","size","Infinity","gapFactor","maxWidth","fillPaths","Map","strokePaths","drawBoxes","ctx","forEach","fillPath","fillStyle","strokePath","strokeStyle","stroke","clear","putBox","rect","xOff","yOff","left","top","boxWidth","boxHeight","strokeWidth","seriesIdx","valueIdx","value","discrete","valueColor","fieldConfig","fillColor","getFillColor","x","y","w","h","sidx","didx","get","set","Path2D","beginPath","lineWidth","drawPaths","u","idx0","idx1","orient","series","dataX","dataY","scaleX","scaleY","valToPosX","valToPosY","xDim","yDim","moveTo","lineTo","width","save","bbox","height","clip","iy","y0","Changes","ix","length","yVal","nextIx","undefined","right","Samples","colWid","gapWid","barWid","xShift","restore","drawPoints","Never","i0","i1","textAlign","textBaseline","yMids","boxRect","Auto","txt","colors","getContrastText","fillText","init","over","overflow","m","appendChild","drawClear","data","s","_paths","setHoverMark","o","display","hoveredAtCursor","hoverMulti","cx","cy","foundAtCursor","found","cy2","abs","hoverOne","doHover","setCursor","cursor","q","seriesRects","points","show","ySplits","xSplits","axisIdx","scaleMin","scaleMax","foundIncr","foundSpace","splits","dataIncr","skipFactor","push","xRange","r","from","valueOf","max","to","scalePad","lastIdx","hgt","posToVal","yValues","yRange","color","opacityPercent","fillOpacity"],"sources":["/home/soula/grafana/public/app/plugins/panel/state-timeline/timeline.ts"],"sourcesContent":["import uPlot, { Cursor, Series } from 'uplot';\n\nimport { GrafanaTheme2, TimeRange } from '@grafana/data';\nimport { alpha } from '@grafana/data/src/themes/colorManipulator';\nimport { VisibilityMode } from '@grafana/schema';\nimport { FIXED_UNIT } from '@grafana/ui/src/components/GraphNG/GraphNG';\nimport { distribute, SPACE_BETWEEN } from 'app/plugins/panel/barchart/distribute';\nimport { pointWithin, Quadtree, Rect } from 'app/plugins/panel/barchart/quadtree';\n\nimport { TimelineFieldConfig, TimelineMode, TimelineValueAlignment } from './types';\n\nconst { round, min, ceil } = Math;\n\nconst textPadding = 2;\n\nconst pxRatio = devicePixelRatio;\n\nconst laneDistr = SPACE_BETWEEN;\n\ntype WalkCb = (idx: number, offPx: number, dimPx: number) => void;\n\nfunction walk(rowHeight: number, yIdx: number | null, count: number, dim: number, draw: WalkCb) {\n  distribute(count, rowHeight, laneDistr, yIdx, (i, offPct, dimPct) => {\n    let laneOffPx = dim * offPct;\n    let laneWidPx = dim * dimPct;\n\n    draw(i, laneOffPx, laneWidPx);\n  });\n}\n\ninterface TimelineBoxRect extends Rect {\n  fillColor: string;\n}\n\n/**\n * @internal\n */\nexport interface TimelineCoreOptions {\n  mode: TimelineMode;\n  alignValue?: TimelineValueAlignment;\n  numSeries: number;\n  rowHeight: number;\n  colWidth?: number;\n  theme: GrafanaTheme2;\n  showValue: VisibilityMode;\n  mergeValues?: boolean;\n  isDiscrete: (seriesIdx: number) => boolean;\n  getValueColor: (seriesIdx: number, value: any) => string;\n  label: (seriesIdx: number) => string;\n  getTimeRange: () => TimeRange;\n  formatValue?: (seriesIdx: number, value: any) => string;\n  getFieldConfig: (seriesIdx: number) => TimelineFieldConfig;\n  onHover: (seriesIdx: number, valueIdx: number, rect: Rect) => void;\n  onLeave: () => void;\n}\n\n/**\n * @internal\n */\nexport function getConfig(opts: TimelineCoreOptions) {\n  const {\n    mode,\n    numSeries,\n    isDiscrete,\n    rowHeight = 0,\n    colWidth = 0,\n    showValue,\n    mergeValues = false,\n    theme,\n    label,\n    formatValue,\n    alignValue = 'left',\n    getTimeRange,\n    getValueColor,\n    getFieldConfig,\n    onHover,\n    onLeave,\n  } = opts;\n\n  let qt: Quadtree;\n\n  const hoverMarks = Array(numSeries)\n    .fill(null)\n    .map(() => {\n      let mark = document.createElement('div');\n      mark.classList.add('bar-mark');\n      mark.style.position = 'absolute';\n      mark.style.background = 'rgba(255,255,255,0.2)';\n      return mark;\n    });\n\n  // Needed for to calculate text positions\n  let boxRectsBySeries: TimelineBoxRect[][];\n\n  const resetBoxRectsBySeries = (count: number) => {\n    boxRectsBySeries = Array(numSeries)\n      .fill(null)\n      .map((v) => Array(count).fill(null));\n  };\n\n  const font = `500 ${Math.round(12 * devicePixelRatio)}px ${theme.typography.fontFamily}`;\n  const hovered: Array<Rect | null> = Array(numSeries).fill(null);\n\n  const size = [colWidth, Infinity];\n  const gapFactor = 1 - size[0];\n  const maxWidth = (size[1] ?? Infinity) * pxRatio;\n\n  const fillPaths: Map<CanvasRenderingContext2D['fillStyle'], Path2D> = new Map();\n  const strokePaths: Map<CanvasRenderingContext2D['strokeStyle'], Path2D> = new Map();\n\n  function drawBoxes(ctx: CanvasRenderingContext2D) {\n    fillPaths.forEach((fillPath, fillStyle) => {\n      ctx.fillStyle = fillStyle;\n      ctx.fill(fillPath);\n    });\n\n    strokePaths.forEach((strokePath, strokeStyle) => {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke(strokePath);\n    });\n\n    fillPaths.clear();\n    strokePaths.clear();\n  }\n\n  function putBox(\n    ctx: CanvasRenderingContext2D,\n    rect: uPlot.RectH,\n    xOff: number,\n    yOff: number,\n    left: number,\n    top: number,\n    boxWidth: number,\n    boxHeight: number,\n    strokeWidth: number,\n    seriesIdx: number,\n    valueIdx: number,\n    value: any,\n    discrete: boolean\n  ) {\n    // do not render super small boxes\n    if (boxWidth < 1) {\n      return;\n    }\n\n    const valueColor = getValueColor(seriesIdx + 1, value);\n    const fieldConfig = getFieldConfig(seriesIdx);\n    const fillColor = getFillColor(fieldConfig, valueColor);\n\n    boxRectsBySeries[seriesIdx][valueIdx] = {\n      x: round(left - xOff),\n      y: round(top - yOff),\n      w: boxWidth,\n      h: boxHeight,\n      sidx: seriesIdx + 1,\n      didx: valueIdx,\n      // for computing label contrast\n      fillColor,\n    };\n\n    if (discrete) {\n      let fillStyle = fillColor;\n      let fillPath = fillPaths.get(fillStyle);\n\n      if (fillPath == null) {\n        fillPaths.set(fillStyle, (fillPath = new Path2D()));\n      }\n\n      rect(fillPath, left, top, boxWidth, boxHeight);\n\n      if (strokeWidth) {\n        let strokeStyle = valueColor;\n        let strokePath = strokePaths.get(strokeStyle);\n\n        if (strokePath == null) {\n          strokePaths.set(strokeStyle, (strokePath = new Path2D()));\n        }\n\n        rect(\n          strokePath,\n          left + strokeWidth / 2,\n          top + strokeWidth / 2,\n          boxWidth - strokeWidth,\n          boxHeight - strokeWidth\n        );\n      }\n    } else {\n      ctx.beginPath();\n      rect(ctx, left, top, boxWidth, boxHeight);\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n\n      if (strokeWidth) {\n        ctx.beginPath();\n        rect(ctx, left + strokeWidth / 2, top + strokeWidth / 2, boxWidth - strokeWidth, boxHeight - strokeWidth);\n        ctx.strokeStyle = valueColor;\n        ctx.lineWidth = strokeWidth;\n        ctx.stroke();\n      }\n    }\n  }\n\n  const drawPaths: Series.PathBuilder = (u, sidx, idx0, idx1) => {\n    uPlot.orient(\n      u,\n      sidx,\n      (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim, moveTo, lineTo, rect) => {\n        let strokeWidth = round((series.width || 0) * pxRatio);\n\n        let discrete = isDiscrete(sidx);\n\n        u.ctx.save();\n        rect(u.ctx, u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n\n        walk(rowHeight, sidx - 1, numSeries, yDim, (iy, y0, height) => {\n          if (mode === TimelineMode.Changes) {\n            for (let ix = 0; ix < dataY.length; ix++) {\n              let yVal = dataY[ix];\n\n              if (yVal != null) {\n                let left = Math.round(valToPosX(dataX[ix], scaleX, xDim, xOff));\n\n                let nextIx = ix;\n                while (\n                  ++nextIx < dataY.length &&\n                  (dataY[nextIx] === undefined || (mergeValues && dataY[nextIx] === yVal))\n                ) {}\n\n                // to now (not to end of chart)\n                let right =\n                  nextIx === dataY.length\n                    ? xOff + xDim + strokeWidth\n                    : Math.round(valToPosX(dataX[nextIx], scaleX, xDim, xOff));\n\n                putBox(\n                  u.ctx,\n                  rect,\n                  xOff,\n                  yOff,\n                  left,\n                  round(yOff + y0),\n                  right - left,\n                  round(height),\n                  strokeWidth,\n                  iy,\n                  ix,\n                  yVal,\n                  discrete\n                );\n\n                ix = nextIx - 1;\n              }\n            }\n          } else if (mode === TimelineMode.Samples) {\n            let colWid = valToPosX(dataX[1], scaleX, xDim, xOff) - valToPosX(dataX[0], scaleX, xDim, xOff);\n            let gapWid = colWid * gapFactor;\n            let barWid = round(min(maxWidth, colWid - gapWid) - strokeWidth);\n            let xShift = barWid / 2;\n            //let xShift = align === 1 ? 0 : align === -1 ? barWid : barWid / 2;\n\n            for (let ix = idx0; ix <= idx1; ix++) {\n              if (dataY[ix] != null) {\n                // TODO: all xPos can be pre-computed once for all series in aligned set\n                let left = valToPosX(dataX[ix], scaleX, xDim, xOff);\n\n                putBox(\n                  u.ctx,\n                  rect,\n                  xOff,\n                  yOff,\n                  round(left - xShift),\n                  round(yOff + y0),\n                  barWid,\n                  round(height),\n                  strokeWidth,\n                  iy,\n                  ix,\n                  dataY[ix],\n                  discrete\n                );\n              }\n            }\n          }\n        });\n\n        if (discrete) {\n          u.ctx.lineWidth = strokeWidth;\n          drawBoxes(u.ctx);\n        }\n\n        u.ctx.restore();\n      }\n    );\n\n    return null;\n  };\n\n  const drawPoints: Series.Points.Show =\n    formatValue == null || showValue === VisibilityMode.Never\n      ? false\n      : (u, sidx, i0, i1) => {\n          u.ctx.save();\n          u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n          u.ctx.clip();\n\n          u.ctx.font = font;\n          u.ctx.textAlign = mode === TimelineMode.Changes ? alignValue : 'center';\n          u.ctx.textBaseline = 'middle';\n\n          uPlot.orient(\n            u,\n            sidx,\n            (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n              let strokeWidth = round((series.width || 0) * pxRatio);\n\n              let y = round(yOff + yMids[sidx - 1]);\n\n              for (let ix = 0; ix < dataY.length; ix++) {\n                if (dataY[ix] != null) {\n                  const boxRect = boxRectsBySeries[sidx - 1][ix];\n\n                  // Todo refine this to better know when to not render text (when values do not fit)\n                  if (!boxRect || (showValue === VisibilityMode.Auto && boxRect.w < 25)) {\n                    continue;\n                  }\n\n                  if (boxRect.x >= xDim) {\n                    continue; // out of view\n                  }\n\n                  // center-aligned\n                  let x = round(boxRect.x + xOff + boxRect.w / 2);\n                  const txt = formatValue(sidx, dataY[ix]);\n\n                  if (mode === TimelineMode.Changes) {\n                    if (alignValue === 'left') {\n                      x = round(boxRect.x + xOff + strokeWidth + textPadding);\n                    } else if (alignValue === 'right') {\n                      x = round(boxRect.x + xOff + boxRect.w - strokeWidth - textPadding);\n                    }\n                  }\n\n                  // TODO: cache by fillColor to avoid setting ctx for label\n                  u.ctx.fillStyle = theme.colors.getContrastText(boxRect.fillColor, 3);\n                  u.ctx.fillText(txt, x, y);\n                }\n              }\n            }\n          );\n\n          u.ctx.restore();\n\n          return false;\n        };\n\n  const init = (u: uPlot) => {\n    let over = u.over;\n    over.style.overflow = 'hidden';\n    hoverMarks.forEach((m) => {\n      over.appendChild(m);\n    });\n  };\n\n  const drawClear = (u: uPlot) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n\n    qt.clear();\n    resetBoxRectsBySeries(u.data[0].length);\n\n    // force-clear the path cache to cause drawBars() to rebuild new quadtree\n    u.series.forEach((s) => {\n      // @ts-ignore\n      s._paths = null;\n    });\n  };\n\n  function setHoverMark(i: number, o: Rect | null) {\n    let h = hoverMarks[i];\n\n    if (o) {\n      h.style.display = '';\n      h.style.left = round(o.x / pxRatio) + 'px';\n      h.style.top = round(o.y / pxRatio) + 'px';\n      h.style.width = round(o.w / pxRatio) + 'px';\n      h.style.height = round(o.h / pxRatio) + 'px';\n    } else {\n      h.style.display = 'none';\n    }\n\n    hovered[i] = o;\n  }\n\n  let hoveredAtCursor: Rect | undefined;\n\n  function hoverMulti(cx: number, cy: number) {\n    let foundAtCursor: Rect | undefined;\n\n    for (let i = 0; i < numSeries; i++) {\n      let found: Rect | undefined;\n\n      if (cx >= 0) {\n        let cy2 = yMids[i];\n\n        qt.get(cx, cy2, 1, 1, (o) => {\n          if (pointWithin(cx, cy2, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            found = o;\n\n            if (Math.abs(cy - cy2) <= o.h / 2) {\n              foundAtCursor = o;\n            }\n          }\n        });\n      }\n\n      if (found) {\n        if (found !== hovered[i]) {\n          setHoverMark(i, found);\n        }\n      } else if (hovered[i] != null) {\n        setHoverMark(i, null);\n      }\n    }\n\n    if (foundAtCursor) {\n      if (foundAtCursor !== hoveredAtCursor) {\n        hoveredAtCursor = foundAtCursor;\n        onHover(foundAtCursor.sidx, foundAtCursor.didx, foundAtCursor);\n      }\n    } else if (hoveredAtCursor) {\n      hoveredAtCursor = undefined;\n      onLeave();\n    }\n  }\n\n  function hoverOne(cx: number, cy: number) {\n    let foundAtCursor: Rect | undefined;\n\n    qt.get(cx, cy, 1, 1, (o) => {\n      if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n        foundAtCursor = o;\n      }\n    });\n\n    if (foundAtCursor) {\n      setHoverMark(0, foundAtCursor);\n\n      if (foundAtCursor !== hoveredAtCursor) {\n        hoveredAtCursor = foundAtCursor;\n        onHover(foundAtCursor.sidx, foundAtCursor.didx, foundAtCursor);\n      }\n    } else if (hoveredAtCursor) {\n      setHoverMark(0, null);\n      hoveredAtCursor = undefined;\n      onLeave();\n    }\n  }\n\n  const doHover = mode === TimelineMode.Changes ? hoverMulti : hoverOne;\n\n  const setCursor = (u: uPlot) => {\n    let cx = round(u.cursor.left! * pxRatio);\n    let cy = round(u.cursor.top! * pxRatio);\n\n    // if quadtree is empty, fill it\n    if (!qt.o.length && qt.q == null) {\n      for (const seriesRects of boxRectsBySeries) {\n        for (const rect of seriesRects) {\n          rect && qt.add(rect);\n        }\n      }\n    }\n\n    doHover(cx, cy);\n  };\n\n  // hide y crosshair & hover points\n  const cursor: Partial<Cursor> = {\n    y: false,\n    x: mode === TimelineMode.Changes,\n    points: { show: false },\n  };\n\n  const yMids: number[] = Array(numSeries).fill(0);\n  const ySplits: number[] = Array(numSeries).fill(0);\n\n  return {\n    cursor,\n\n    xSplits:\n      mode === TimelineMode.Samples\n        ? (u: uPlot, axisIdx: number, scaleMin: number, scaleMax: number, foundIncr: number, foundSpace: number) => {\n            let splits = [];\n\n            let dataIncr = u.data[0][1] - u.data[0][0];\n            let skipFactor = ceil(foundIncr / dataIncr);\n\n            for (let i = 0; i < u.data[0].length; i += skipFactor) {\n              let v = u.data[0][i];\n\n              if (v >= scaleMin && v <= scaleMax) {\n                splits.push(v);\n              }\n            }\n\n            return splits;\n          }\n        : null,\n\n    xRange: (u: uPlot) => {\n      const r = getTimeRange();\n\n      let min = r.from.valueOf();\n      let max = r.to.valueOf();\n\n      if (mode === TimelineMode.Samples) {\n        let colWid = u.data[0][1] - u.data[0][0];\n        let scalePad = colWid / 2;\n\n        if (min <= u.data[0][0]) {\n          min = u.data[0][0] - scalePad;\n        }\n\n        let lastIdx = u.data[0].length - 1;\n\n        if (max >= u.data[0][lastIdx]) {\n          max = u.data[0][lastIdx] + scalePad;\n        }\n      }\n\n      return [min, max] as uPlot.Range.MinMax;\n    },\n\n    ySplits: (u: uPlot) => {\n      walk(rowHeight, null, numSeries, u.bbox.height, (iy, y0, hgt) => {\n        // vertical midpoints of each series' timeline (stored relative to .u-over)\n        yMids[iy] = round(y0 + hgt / 2);\n        ySplits[iy] = u.posToVal(yMids[iy] / pxRatio, FIXED_UNIT);\n      });\n\n      return ySplits;\n    },\n\n    yValues: (u: uPlot, splits: number[]) => splits.map((v, i) => label(i + 1)),\n    yRange: [0, 1] as uPlot.Range.MinMax,\n\n    // pathbuilders\n    drawPaths,\n    drawPoints,\n\n    // hooks\n    init,\n    drawClear,\n    setCursor,\n  };\n}\n\nfunction getFillColor(fieldConfig: TimelineFieldConfig, color: string) {\n  // if #rgba with pre-existing alpha. ignore fieldConfig.fillOpacity\n  // e.g. thresholds with opacity\n  if (color[0] === '#' && color.length === 9) {\n    return color;\n  }\n\n  const opacityPercent = (fieldConfig.fillOpacity ?? 100) / 100;\n  return alpha(color, opacityPercent);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}