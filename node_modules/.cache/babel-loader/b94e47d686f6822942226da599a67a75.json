{"ast":null,"code":"import { lastValueFrom } from 'rxjs';\nimport { isBucketAggregationType } from '../components/QueryEditor/BucketAggregationsEditor/aggregations';\nimport { useDatasource, useRange } from '../components/QueryEditor/ElasticsearchQueryContext';\nimport { isMetricAggregationType } from '../components/QueryEditor/MetricAggregationsEditor/aggregations';\n\nconst getFilter = type => {\n  if (isMetricAggregationType(type)) {\n    switch (type) {\n      case 'cardinality':\n        return [];\n\n      case 'top_metrics':\n        // top_metrics was introduced in 7.7 where `metrics` only supported number:\n        // https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-metrics-top-metrics.html#_metrics\n        // TODO: starting from 7.11 it supports ips and keywords as well:\n        // https://www.elastic.co/guide/en/elasticsearch/reference/7.11/search-aggregations-metrics-top-metrics.html#_metrics\n        return ['number'];\n\n      default:\n        return ['number'];\n    }\n  }\n\n  if (isBucketAggregationType(type)) {\n    switch (type) {\n      case 'date_histogram':\n        return ['date'];\n\n      case 'geohash_grid':\n        return ['geo_point'];\n\n      case 'histogram':\n        return ['number'];\n\n      default:\n        return [];\n    }\n  }\n\n  return [];\n};\n\nconst toSelectableValue = ({\n  text\n}) => ({\n  label: text,\n  value: text\n});\n/**\n * Returns a function to query the configured datasource for autocomplete values for the specified aggregation type or data types.\n * Each aggregation can be run on different types, for example avg only operates on numeric fields, geohash_grid only on geo_point fields.\n * If an aggregation type is provided, the promise will resolve with all fields suitable to be used as a field for the given aggregation.\n * If an array of types is providem the promise will resolve with all the fields matching the provided types.\n * @param aggregationType the type of aggregation to get fields for\n */\n\n\nexport const useFields = type => {\n  const datasource = useDatasource();\n  const range = useRange();\n  const filter = Array.isArray(type) ? type : getFilter(type);\n  let rawFields;\n  return async q => {\n    // _mapping doesn't support filtering, we avoid sending a request everytime q changes\n    if (!rawFields) {\n      rawFields = await lastValueFrom(datasource.getFields(filter, range));\n    }\n\n    return rawFields.filter(({\n      text\n    }) => q === undefined || text.includes(q)).map(toSelectableValue);\n  };\n};","map":{"version":3,"names":["lastValueFrom","isBucketAggregationType","useDatasource","useRange","isMetricAggregationType","getFilter","type","toSelectableValue","text","label","value","useFields","datasource","range","filter","Array","isArray","rawFields","q","getFields","undefined","includes","map"],"sources":["/home/soula/grafana/public/app/plugins/datasource/elasticsearch/hooks/useFields.ts"],"sourcesContent":["import { lastValueFrom } from 'rxjs';\n\nimport { MetricFindValue, SelectableValue } from '@grafana/data';\n\nimport {\n  BucketAggregationType,\n  isBucketAggregationType,\n} from '../components/QueryEditor/BucketAggregationsEditor/aggregations';\nimport { useDatasource, useRange } from '../components/QueryEditor/ElasticsearchQueryContext';\nimport {\n  isMetricAggregationType,\n  MetricAggregationType,\n} from '../components/QueryEditor/MetricAggregationsEditor/aggregations';\n\ntype AggregationType = BucketAggregationType | MetricAggregationType;\n\nconst getFilter = (type: AggregationType) => {\n  if (isMetricAggregationType(type)) {\n    switch (type) {\n      case 'cardinality':\n        return [];\n      case 'top_metrics':\n        // top_metrics was introduced in 7.7 where `metrics` only supported number:\n        // https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-metrics-top-metrics.html#_metrics\n        // TODO: starting from 7.11 it supports ips and keywords as well:\n        // https://www.elastic.co/guide/en/elasticsearch/reference/7.11/search-aggregations-metrics-top-metrics.html#_metrics\n        return ['number'];\n      default:\n        return ['number'];\n    }\n  }\n\n  if (isBucketAggregationType(type)) {\n    switch (type) {\n      case 'date_histogram':\n        return ['date'];\n      case 'geohash_grid':\n        return ['geo_point'];\n      case 'histogram':\n        return ['number'];\n      default:\n        return [];\n    }\n  }\n\n  return [];\n};\n\nconst toSelectableValue = ({ text }: MetricFindValue): SelectableValue<string> => ({\n  label: text,\n  value: text,\n});\n\n/**\n * Returns a function to query the configured datasource for autocomplete values for the specified aggregation type or data types.\n * Each aggregation can be run on different types, for example avg only operates on numeric fields, geohash_grid only on geo_point fields.\n * If an aggregation type is provided, the promise will resolve with all fields suitable to be used as a field for the given aggregation.\n * If an array of types is providem the promise will resolve with all the fields matching the provided types.\n * @param aggregationType the type of aggregation to get fields for\n */\nexport const useFields = (type: AggregationType | string[]) => {\n  const datasource = useDatasource();\n  const range = useRange();\n  const filter = Array.isArray(type) ? type : getFilter(type);\n  let rawFields: MetricFindValue[];\n\n  return async (q?: string) => {\n    // _mapping doesn't support filtering, we avoid sending a request everytime q changes\n    if (!rawFields) {\n      rawFields = await lastValueFrom(datasource.getFields(filter, range));\n    }\n\n    return rawFields.filter(({ text }) => q === undefined || text.includes(q)).map(toSelectableValue);\n  };\n};\n"],"mappings":"AAAA,SAASA,aAAT,QAA8B,MAA9B;AAIA,SAEEC,uBAFF,QAGO,iEAHP;AAIA,SAASC,aAAT,EAAwBC,QAAxB,QAAwC,qDAAxC;AACA,SACEC,uBADF,QAGO,iEAHP;;AAOA,MAAMC,SAAS,GAAIC,IAAD,IAA2B;EAC3C,IAAIF,uBAAuB,CAACE,IAAD,CAA3B,EAAmC;IACjC,QAAQA,IAAR;MACE,KAAK,aAAL;QACE,OAAO,EAAP;;MACF,KAAK,aAAL;QACE;QACA;QACA;QACA;QACA,OAAO,CAAC,QAAD,CAAP;;MACF;QACE,OAAO,CAAC,QAAD,CAAP;IAVJ;EAYD;;EAED,IAAIL,uBAAuB,CAACK,IAAD,CAA3B,EAAmC;IACjC,QAAQA,IAAR;MACE,KAAK,gBAAL;QACE,OAAO,CAAC,MAAD,CAAP;;MACF,KAAK,cAAL;QACE,OAAO,CAAC,WAAD,CAAP;;MACF,KAAK,WAAL;QACE,OAAO,CAAC,QAAD,CAAP;;MACF;QACE,OAAO,EAAP;IARJ;EAUD;;EAED,OAAO,EAAP;AACD,CA9BD;;AAgCA,MAAMC,iBAAiB,GAAG,CAAC;EAAEC;AAAF,CAAD,MAAyD;EACjFC,KAAK,EAAED,IAD0E;EAEjFE,KAAK,EAAEF;AAF0E,CAAzD,CAA1B;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMG,SAAS,GAAIL,IAAD,IAAsC;EAC7D,MAAMM,UAAU,GAAGV,aAAa,EAAhC;EACA,MAAMW,KAAK,GAAGV,QAAQ,EAAtB;EACA,MAAMW,MAAM,GAAGC,KAAK,CAACC,OAAN,CAAcV,IAAd,IAAsBA,IAAtB,GAA6BD,SAAS,CAACC,IAAD,CAArD;EACA,IAAIW,SAAJ;EAEA,OAAO,MAAOC,CAAP,IAAsB;IAC3B;IACA,IAAI,CAACD,SAAL,EAAgB;MACdA,SAAS,GAAG,MAAMjB,aAAa,CAACY,UAAU,CAACO,SAAX,CAAqBL,MAArB,EAA6BD,KAA7B,CAAD,CAA/B;IACD;;IAED,OAAOI,SAAS,CAACH,MAAV,CAAiB,CAAC;MAAEN;IAAF,CAAD,KAAcU,CAAC,KAAKE,SAAN,IAAmBZ,IAAI,CAACa,QAAL,CAAcH,CAAd,CAAlD,EAAoEI,GAApE,CAAwEf,iBAAxE,CAAP;EACD,CAPD;AAQD,CAdM"},"metadata":{},"sourceType":"module"}