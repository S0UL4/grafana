{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { identity, omit, pick, pickBy } from 'lodash';\nimport { lastValueFrom, of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { DataSourceApi, dateMath, FieldType, MutableDataFrame } from '@grafana/data';\nimport { getBackendSrv, getTemplateSrv } from '@grafana/runtime';\nimport { serializeParams } from 'app/core/utils/fetch';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { ALL_OPERATIONS_KEY } from './components/SearchForm';\nimport { createGraphFrames } from './graphTransform';\nimport { createTableFrame, createTraceFrame } from './responseTransform';\nimport { convertTagsLogfmt } from './util';\nexport class JaegerDatasource extends DataSourceApi {\n  constructor(instanceSettings, timeSrv = getTimeSrv(), templateSrv = getTemplateSrv()) {\n    super(instanceSettings);\n\n    _defineProperty(this, \"uploadedJson\", null);\n\n    _defineProperty(this, \"nodeGraph\", void 0);\n\n    this.instanceSettings = instanceSettings;\n    this.timeSrv = timeSrv;\n    this.templateSrv = templateSrv;\n    this.nodeGraph = instanceSettings.jsonData.nodeGraph;\n  }\n\n  async metadataRequest(url, params) {\n    const res = await lastValueFrom(this._request(url, params, {\n      hideFromInspector: true\n    }));\n    return res.data.data;\n  }\n\n  query(options) {\n    // At this moment we expect only one target. In case we somehow change the UI to be able to show multiple\n    // traces at one we need to change this.\n    const target = options.targets[0];\n\n    if (!target) {\n      return of({\n        data: [emptyTraceDataFrame]\n      });\n    }\n\n    if (target.queryType !== 'search' && target.query) {\n      return this._request(`/api/traces/${encodeURIComponent(this.templateSrv.replace(target.query, options.scopedVars))}`).pipe(map(response => {\n        var _response$data, _response$data$data, _this$nodeGraph;\n\n        const traceData = response === null || response === void 0 ? void 0 : (_response$data = response.data) === null || _response$data === void 0 ? void 0 : (_response$data$data = _response$data.data) === null || _response$data$data === void 0 ? void 0 : _response$data$data[0];\n\n        if (!traceData) {\n          return {\n            data: [emptyTraceDataFrame]\n          };\n        }\n\n        let data = [createTraceFrame(traceData)];\n\n        if ((_this$nodeGraph = this.nodeGraph) !== null && _this$nodeGraph !== void 0 && _this$nodeGraph.enabled) {\n          data.push(...createGraphFrames(traceData));\n        }\n\n        return {\n          data\n        };\n      }));\n    }\n\n    if (target.queryType === 'upload') {\n      if (!this.uploadedJson) {\n        return of({\n          data: []\n        });\n      }\n\n      try {\n        var _this$nodeGraph2;\n\n        const traceData = JSON.parse(this.uploadedJson).data[0];\n        let data = [createTraceFrame(traceData)];\n\n        if ((_this$nodeGraph2 = this.nodeGraph) !== null && _this$nodeGraph2 !== void 0 && _this$nodeGraph2.enabled) {\n          data.push(...createGraphFrames(traceData));\n        }\n\n        return of({\n          data\n        });\n      } catch (error) {\n        return of({\n          error: {\n            message: 'JSON is not valid Jaeger format'\n          },\n          data: []\n        });\n      }\n    }\n\n    let jaegerInterpolated = pick(this.applyVariables(target, options.scopedVars), ['service', 'operation', 'tags', 'minDuration', 'maxDuration', 'limit']); // remove empty properties\n\n    let jaegerQuery = pickBy(jaegerInterpolated, identity);\n\n    if (jaegerQuery.operation === ALL_OPERATIONS_KEY) {\n      jaegerQuery = omit(jaegerQuery, 'operation');\n    }\n\n    if (jaegerQuery.tags) {\n      jaegerQuery = Object.assign({}, jaegerQuery, {\n        tags: convertTagsLogfmt(jaegerQuery.tags.toString())\n      });\n    } // TODO: this api is internal, used in jaeger ui. Officially they have gRPC api that should be used.\n\n\n    return this._request(`/api/traces`, Object.assign({}, jaegerQuery, this.getTimeRange(), {\n      lookback: 'custom'\n    })).pipe(map(response => {\n      return {\n        data: [createTableFrame(response.data.data, this.instanceSettings)]\n      };\n    }));\n  }\n\n  interpolateVariablesInQueries(queries, scopedVars) {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    return queries.map(query => {\n      return Object.assign({}, query, {\n        datasource: this.getRef()\n      }, this.applyVariables(query, scopedVars));\n    });\n  }\n\n  applyVariables(query, scopedVars) {\n    var _query$service, _query$operation, _query$minDuration, _query$maxDuration;\n\n    let expandedQuery = Object.assign({}, query);\n\n    if (query.tags && this.templateSrv.containsTemplate(query.tags)) {\n      expandedQuery = Object.assign({}, query, {\n        tags: this.templateSrv.replace(query.tags, scopedVars)\n      });\n    }\n\n    return Object.assign({}, expandedQuery, {\n      service: this.templateSrv.replace((_query$service = query.service) !== null && _query$service !== void 0 ? _query$service : '', scopedVars),\n      operation: this.templateSrv.replace((_query$operation = query.operation) !== null && _query$operation !== void 0 ? _query$operation : '', scopedVars),\n      minDuration: this.templateSrv.replace((_query$minDuration = query.minDuration) !== null && _query$minDuration !== void 0 ? _query$minDuration : '', scopedVars),\n      maxDuration: this.templateSrv.replace((_query$maxDuration = query.maxDuration) !== null && _query$maxDuration !== void 0 ? _query$maxDuration : '', scopedVars)\n    });\n  }\n\n  async testDatasource() {\n    return lastValueFrom(this._request('/api/services').pipe(map(res => {\n      var _res$data;\n\n      const values = (res === null || res === void 0 ? void 0 : (_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.data) || [];\n      const testResult = values.length > 0 ? {\n        status: 'success',\n        message: 'Data source connected and services found.'\n      } : {\n        status: 'error',\n        message: 'Data source connected, but no services received. Verify that Jaeger is configured properly.'\n      };\n      return testResult;\n    }), catchError(err => {\n      let message = 'Jaeger: ';\n\n      if (err.statusText) {\n        message += err.statusText;\n      } else {\n        message += 'Cannot connect to Jaeger';\n      }\n\n      if (err.status) {\n        message += `. ${err.status}`;\n      }\n\n      if (err.data && err.data.message) {\n        message += `. ${err.data.message}`;\n      } else if (err.data) {\n        message += `. ${JSON.stringify(err.data)}`;\n      }\n\n      return of({\n        status: 'error',\n        message: message\n      });\n    })));\n  }\n\n  getTimeRange() {\n    const range = this.timeSrv.timeRange();\n    return {\n      start: getTime(range.from, false),\n      end: getTime(range.to, true)\n    };\n  }\n\n  getQueryDisplayText(query) {\n    return query.query || '';\n  }\n\n  _request(apiUrl, data, options) {\n    const params = data ? serializeParams(data) : '';\n    const url = `${this.instanceSettings.url}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = Object.assign({}, options, {\n      url\n    });\n    return getBackendSrv().fetch(req);\n  }\n\n}\n\nfunction getTime(date, roundUp) {\n  if (typeof date === 'string') {\n    date = dateMath.parse(date, roundUp);\n  }\n\n  return date.valueOf() * 1000;\n}\n\nconst emptyTraceDataFrame = new MutableDataFrame({\n  fields: [{\n    name: 'trace',\n    type: FieldType.trace,\n    values: []\n  }],\n  meta: {\n    preferredVisualisationType: 'trace',\n    custom: {\n      traceFormat: 'jaeger'\n    }\n  }\n});","map":{"version":3,"names":["identity","omit","pick","pickBy","lastValueFrom","of","catchError","map","DataSourceApi","dateMath","FieldType","MutableDataFrame","getBackendSrv","getTemplateSrv","serializeParams","getTimeSrv","ALL_OPERATIONS_KEY","createGraphFrames","createTableFrame","createTraceFrame","convertTagsLogfmt","JaegerDatasource","constructor","instanceSettings","timeSrv","templateSrv","nodeGraph","jsonData","metadataRequest","url","params","res","_request","hideFromInspector","data","query","options","target","targets","emptyTraceDataFrame","queryType","encodeURIComponent","replace","scopedVars","pipe","response","traceData","enabled","push","uploadedJson","JSON","parse","error","message","jaegerInterpolated","applyVariables","jaegerQuery","operation","tags","toString","getTimeRange","lookback","interpolateVariablesInQueries","queries","length","datasource","getRef","expandedQuery","containsTemplate","service","minDuration","maxDuration","testDatasource","values","testResult","status","err","statusText","stringify","range","timeRange","start","getTime","from","end","to","getQueryDisplayText","apiUrl","req","fetch","date","roundUp","valueOf","fields","name","type","trace","meta","preferredVisualisationType","custom","traceFormat"],"sources":["/home/soula/grafana/public/app/plugins/datasource/jaeger/datasource.ts"],"sourcesContent":["import { identity, omit, pick, pickBy } from 'lodash';\nimport { lastValueFrom, Observable, of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\n\nimport {\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataSourceJsonData,\n  dateMath,\n  DateTime,\n  FieldType,\n  MutableDataFrame,\n  ScopedVars,\n} from '@grafana/data';\nimport { BackendSrvRequest, getBackendSrv, getTemplateSrv, TemplateSrv } from '@grafana/runtime';\nimport { NodeGraphOptions } from 'app/core/components/NodeGraphSettings';\nimport { serializeParams } from 'app/core/utils/fetch';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\n\nimport { ALL_OPERATIONS_KEY } from './components/SearchForm';\nimport { createGraphFrames } from './graphTransform';\nimport { createTableFrame, createTraceFrame } from './responseTransform';\nimport { JaegerQuery } from './types';\nimport { convertTagsLogfmt } from './util';\n\nexport interface JaegerJsonData extends DataSourceJsonData {\n  nodeGraph?: NodeGraphOptions;\n}\n\nexport class JaegerDatasource extends DataSourceApi<JaegerQuery, JaegerJsonData> {\n  uploadedJson: string | ArrayBuffer | null = null;\n  nodeGraph?: NodeGraphOptions;\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<JaegerJsonData>,\n    private readonly timeSrv: TimeSrv = getTimeSrv(),\n    private readonly templateSrv: TemplateSrv = getTemplateSrv()\n  ) {\n    super(instanceSettings);\n    this.nodeGraph = instanceSettings.jsonData.nodeGraph;\n  }\n\n  async metadataRequest(url: string, params?: Record<string, any>): Promise<any> {\n    const res = await lastValueFrom(this._request(url, params, { hideFromInspector: true }));\n    return res.data.data;\n  }\n\n  query(options: DataQueryRequest<JaegerQuery>): Observable<DataQueryResponse> {\n    // At this moment we expect only one target. In case we somehow change the UI to be able to show multiple\n    // traces at one we need to change this.\n    const target: JaegerQuery = options.targets[0];\n    if (!target) {\n      return of({ data: [emptyTraceDataFrame] });\n    }\n\n    if (target.queryType !== 'search' && target.query) {\n      return this._request(\n        `/api/traces/${encodeURIComponent(this.templateSrv.replace(target.query, options.scopedVars))}`\n      ).pipe(\n        map((response) => {\n          const traceData = response?.data?.data?.[0];\n          if (!traceData) {\n            return { data: [emptyTraceDataFrame] };\n          }\n          let data = [createTraceFrame(traceData)];\n          if (this.nodeGraph?.enabled) {\n            data.push(...createGraphFrames(traceData));\n          }\n          return {\n            data,\n          };\n        })\n      );\n    }\n\n    if (target.queryType === 'upload') {\n      if (!this.uploadedJson) {\n        return of({ data: [] });\n      }\n\n      try {\n        const traceData = JSON.parse(this.uploadedJson as string).data[0];\n        let data = [createTraceFrame(traceData)];\n        if (this.nodeGraph?.enabled) {\n          data.push(...createGraphFrames(traceData));\n        }\n        return of({ data });\n      } catch (error) {\n        return of({ error: { message: 'JSON is not valid Jaeger format' }, data: [] });\n      }\n    }\n\n    let jaegerInterpolated = pick(this.applyVariables(target, options.scopedVars), [\n      'service',\n      'operation',\n      'tags',\n      'minDuration',\n      'maxDuration',\n      'limit',\n    ]);\n    // remove empty properties\n    let jaegerQuery = pickBy(jaegerInterpolated, identity);\n\n    if (jaegerQuery.operation === ALL_OPERATIONS_KEY) {\n      jaegerQuery = omit(jaegerQuery, 'operation');\n    }\n\n    if (jaegerQuery.tags) {\n      jaegerQuery = {\n        ...jaegerQuery,\n        tags: convertTagsLogfmt(jaegerQuery.tags.toString()),\n      };\n    }\n\n    // TODO: this api is internal, used in jaeger ui. Officially they have gRPC api that should be used.\n    return this._request(`/api/traces`, {\n      ...jaegerQuery,\n      ...this.getTimeRange(),\n      lookback: 'custom',\n    }).pipe(\n      map((response) => {\n        return {\n          data: [createTableFrame(response.data.data, this.instanceSettings)],\n        };\n      })\n    );\n  }\n\n  interpolateVariablesInQueries(queries: JaegerQuery[], scopedVars: ScopedVars): JaegerQuery[] {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    return queries.map((query) => {\n      return {\n        ...query,\n        datasource: this.getRef(),\n        ...this.applyVariables(query, scopedVars),\n      };\n    });\n  }\n\n  applyVariables(query: JaegerQuery, scopedVars: ScopedVars) {\n    let expandedQuery = { ...query };\n\n    if (query.tags && this.templateSrv.containsTemplate(query.tags)) {\n      expandedQuery = {\n        ...query,\n        tags: this.templateSrv.replace(query.tags, scopedVars),\n      };\n    }\n\n    return {\n      ...expandedQuery,\n      service: this.templateSrv.replace(query.service ?? '', scopedVars),\n      operation: this.templateSrv.replace(query.operation ?? '', scopedVars),\n      minDuration: this.templateSrv.replace(query.minDuration ?? '', scopedVars),\n      maxDuration: this.templateSrv.replace(query.maxDuration ?? '', scopedVars),\n    };\n  }\n\n  async testDatasource(): Promise<any> {\n    return lastValueFrom(\n      this._request('/api/services').pipe(\n        map((res) => {\n          const values: any[] = res?.data?.data || [];\n          const testResult =\n            values.length > 0\n              ? { status: 'success', message: 'Data source connected and services found.' }\n              : {\n                  status: 'error',\n                  message:\n                    'Data source connected, but no services received. Verify that Jaeger is configured properly.',\n                };\n          return testResult;\n        }),\n        catchError((err: any) => {\n          let message = 'Jaeger: ';\n          if (err.statusText) {\n            message += err.statusText;\n          } else {\n            message += 'Cannot connect to Jaeger';\n          }\n\n          if (err.status) {\n            message += `. ${err.status}`;\n          }\n\n          if (err.data && err.data.message) {\n            message += `. ${err.data.message}`;\n          } else if (err.data) {\n            message += `. ${JSON.stringify(err.data)}`;\n          }\n          return of({ status: 'error', message: message });\n        })\n      )\n    );\n  }\n\n  getTimeRange(): { start: number; end: number } {\n    const range = this.timeSrv.timeRange();\n    return {\n      start: getTime(range.from, false),\n      end: getTime(range.to, true),\n    };\n  }\n\n  getQueryDisplayText(query: JaegerQuery) {\n    return query.query || '';\n  }\n\n  private _request(apiUrl: string, data?: any, options?: Partial<BackendSrvRequest>): Observable<Record<string, any>> {\n    const params = data ? serializeParams(data) : '';\n    const url = `${this.instanceSettings.url}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return getBackendSrv().fetch(req);\n  }\n}\n\nfunction getTime(date: string | DateTime, roundUp: boolean) {\n  if (typeof date === 'string') {\n    date = dateMath.parse(date, roundUp)!;\n  }\n  return date.valueOf() * 1000;\n}\n\nconst emptyTraceDataFrame = new MutableDataFrame({\n  fields: [\n    {\n      name: 'trace',\n      type: FieldType.trace,\n      values: [],\n    },\n  ],\n  meta: {\n    preferredVisualisationType: 'trace',\n    custom: {\n      traceFormat: 'jaeger',\n    },\n  },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}