{"ast":null,"code":"const _excluded = [\"keepLabels\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { useMemo } from 'react';\nimport { DataTransformerID, standardTransformers } from '@grafana/data';\nimport { LabelsToFieldsMode } from '@grafana/data/src/transformations/transformers/labelsToFields';\nimport { Stack } from '@grafana/experimental';\nimport { InlineField, InlineFieldRow, RadioButtonGroup, Select, FilterPill } from '@grafana/ui';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst modes = [{\n  value: LabelsToFieldsMode.Columns,\n  label: 'Columns'\n}, {\n  value: LabelsToFieldsMode.Rows,\n  label: 'Rows'\n}];\nexport const LabelsAsFieldsTransformerEditor = ({\n  input,\n  options,\n  onChange\n}) => {\n  var _options$mode;\n\n  const labelWidth = 20;\n  const {\n    labelNames,\n    selected\n  } = useMemo(() => {\n    var _options$keepLabels;\n\n    let labelNames = [];\n    let uniqueLabels = {};\n\n    for (const frame of input) {\n      for (const field of frame.fields) {\n        if (!field.labels) {\n          continue;\n        }\n\n        for (const labelName of Object.keys(field.labels)) {\n          if (!uniqueLabels[labelName]) {\n            labelNames.push({\n              value: labelName,\n              label: labelName\n            });\n            uniqueLabels[labelName] = true;\n          }\n        }\n      }\n    }\n\n    const selected = new Set((_options$keepLabels = options.keepLabels) !== null && _options$keepLabels !== void 0 && _options$keepLabels.length ? options.keepLabels : Object.keys(uniqueLabels));\n    return {\n      labelNames,\n      selected\n    };\n  }, [options.keepLabels, input]);\n\n  const onValueLabelChange = value => {\n    onChange(Object.assign({}, options, {\n      valueLabel: value === null || value === void 0 ? void 0 : value.value\n    }));\n  };\n\n  const onToggleSelection = v => {\n    if (selected.has(v)) {\n      selected.delete(v);\n    } else {\n      selected.add(v);\n    }\n\n    if (selected.size === labelNames.length || !selected.size) {\n      const rest = _objectWithoutPropertiesLoose(options, _excluded);\n\n      onChange(rest);\n    } else {\n      onChange(Object.assign({}, options, {\n        keepLabels: [...selected]\n      }));\n    }\n  };\n\n  return /*#__PURE__*/_jsxs(\"div\", {\n    children: [/*#__PURE__*/_jsx(InlineFieldRow, {\n      children: /*#__PURE__*/_jsx(InlineField, {\n        label: 'Mode',\n        labelWidth: labelWidth,\n        children: /*#__PURE__*/_jsx(RadioButtonGroup, {\n          options: modes,\n          value: (_options$mode = options.mode) !== null && _options$mode !== void 0 ? _options$mode : LabelsToFieldsMode.Columns,\n          onChange: v => onChange(Object.assign({}, options, {\n            mode: v\n          }))\n        })\n      })\n    }), /*#__PURE__*/_jsx(InlineFieldRow, {\n      children: /*#__PURE__*/_jsx(InlineField, {\n        label: 'Labels',\n        labelWidth: labelWidth,\n        children: /*#__PURE__*/_jsx(Stack, {\n          gap: 1,\n          wrap: true,\n          children: labelNames.map((o, i) => {\n            const label = o.label;\n            return /*#__PURE__*/_jsx(FilterPill, {\n              onClick: () => onToggleSelection(label),\n              label: label,\n              selected: selected.has(label)\n            }, `${label}/${i}`);\n          })\n        })\n      })\n    }), options.mode !== LabelsToFieldsMode.Rows && /*#__PURE__*/_jsx(InlineFieldRow, {\n      children: /*#__PURE__*/_jsx(InlineField, {\n        label: 'Value field name',\n        labelWidth: labelWidth,\n        tooltip: \"Replace the value field name with a label\",\n        htmlFor: \"labels-to-fields-as-name\",\n        children: /*#__PURE__*/_jsx(Select, {\n          inputId: \"labels-to-fields-as-name\",\n          isClearable: true,\n          allowCustomValue: false,\n          placeholder: \"(Optional) Select label\",\n          options: labelNames,\n          value: options === null || options === void 0 ? void 0 : options.valueLabel,\n          onChange: onValueLabelChange,\n          className: \"min-width-16\"\n        })\n      })\n    })]\n  });\n};\nexport const labelsToFieldsTransformerRegistryItem = {\n  id: DataTransformerID.labelsToFields,\n  editor: LabelsAsFieldsTransformerEditor,\n  transformation: standardTransformers.labelsToFieldsTransformer,\n  name: 'Labels to fields',\n  description: `Groups series by time and return labels or tags as fields.\n                Useful for showing time series with labels in a table where each label key becomes a separate column`\n};","map":{"version":3,"names":["React","useMemo","DataTransformerID","standardTransformers","LabelsToFieldsMode","Stack","InlineField","InlineFieldRow","RadioButtonGroup","Select","FilterPill","modes","value","Columns","label","Rows","LabelsAsFieldsTransformerEditor","input","options","onChange","labelWidth","labelNames","selected","uniqueLabels","frame","field","fields","labels","labelName","Object","keys","push","Set","keepLabels","length","onValueLabelChange","valueLabel","onToggleSelection","v","has","delete","add","size","rest","mode","map","o","i","labelsToFieldsTransformerRegistryItem","id","labelsToFields","editor","transformation","labelsToFieldsTransformer","name","description"],"sources":["/home/soula/grafana/public/app/features/transformers/editors/LabelsToFieldsTransformerEditor.tsx"],"sourcesContent":["import React, { useMemo } from 'react';\n\nimport {\n  DataTransformerID,\n  SelectableValue,\n  standardTransformers,\n  TransformerRegistryItem,\n  TransformerUIProps,\n} from '@grafana/data';\nimport {\n  LabelsToFieldsMode,\n  LabelsToFieldsOptions,\n} from '@grafana/data/src/transformations/transformers/labelsToFields';\nimport { Stack } from '@grafana/experimental';\nimport { InlineField, InlineFieldRow, RadioButtonGroup, Select, FilterPill } from '@grafana/ui';\n\nconst modes: Array<SelectableValue<LabelsToFieldsMode>> = [\n  { value: LabelsToFieldsMode.Columns, label: 'Columns' },\n  { value: LabelsToFieldsMode.Rows, label: 'Rows' },\n];\n\nexport const LabelsAsFieldsTransformerEditor: React.FC<TransformerUIProps<LabelsToFieldsOptions>> = ({\n  input,\n  options,\n  onChange,\n}) => {\n  const labelWidth = 20;\n\n  const { labelNames, selected } = useMemo(() => {\n    let labelNames: Array<SelectableValue<string>> = [];\n    let uniqueLabels: Record<string, boolean> = {};\n\n    for (const frame of input) {\n      for (const field of frame.fields) {\n        if (!field.labels) {\n          continue;\n        }\n\n        for (const labelName of Object.keys(field.labels)) {\n          if (!uniqueLabels[labelName]) {\n            labelNames.push({ value: labelName, label: labelName });\n            uniqueLabels[labelName] = true;\n          }\n        }\n      }\n    }\n\n    const selected = new Set(options.keepLabels?.length ? options.keepLabels : Object.keys(uniqueLabels));\n    return { labelNames, selected };\n  }, [options.keepLabels, input]);\n\n  const onValueLabelChange = (value: SelectableValue<string> | null) => {\n    onChange({ ...options, valueLabel: value?.value });\n  };\n\n  const onToggleSelection = (v: string) => {\n    if (selected.has(v)) {\n      selected.delete(v);\n    } else {\n      selected.add(v);\n    }\n    if (selected.size === labelNames.length || !selected.size) {\n      const { keepLabels, ...rest } = options;\n      onChange(rest);\n    } else {\n      onChange({ ...options, keepLabels: [...selected] });\n    }\n  };\n\n  return (\n    <div>\n      <InlineFieldRow>\n        <InlineField label={'Mode'} labelWidth={labelWidth}>\n          <RadioButtonGroup\n            options={modes}\n            value={options.mode ?? LabelsToFieldsMode.Columns}\n            onChange={(v) => onChange({ ...options, mode: v })}\n          />\n        </InlineField>\n      </InlineFieldRow>\n      <InlineFieldRow>\n        <InlineField label={'Labels'} labelWidth={labelWidth}>\n          <Stack gap={1} wrap>\n            {labelNames.map((o, i) => {\n              const label = o.label!;\n              return (\n                <FilterPill\n                  key={`${label}/${i}`}\n                  onClick={() => onToggleSelection(label)}\n                  label={label}\n                  selected={selected.has(label)}\n                />\n              );\n            })}\n          </Stack>\n        </InlineField>\n      </InlineFieldRow>\n      {options.mode !== LabelsToFieldsMode.Rows && (\n        <InlineFieldRow>\n          <InlineField\n            label={'Value field name'}\n            labelWidth={labelWidth}\n            tooltip=\"Replace the value field name with a label\"\n            htmlFor=\"labels-to-fields-as-name\"\n          >\n            <Select\n              inputId=\"labels-to-fields-as-name\"\n              isClearable={true}\n              allowCustomValue={false}\n              placeholder=\"(Optional) Select label\"\n              options={labelNames}\n              value={options?.valueLabel}\n              onChange={onValueLabelChange}\n              className=\"min-width-16\"\n            />\n          </InlineField>\n        </InlineFieldRow>\n      )}\n    </div>\n  );\n};\n\nexport const labelsToFieldsTransformerRegistryItem: TransformerRegistryItem<LabelsToFieldsOptions> = {\n  id: DataTransformerID.labelsToFields,\n  editor: LabelsAsFieldsTransformerEditor,\n  transformation: standardTransformers.labelsToFieldsTransformer,\n  name: 'Labels to fields',\n  description: `Groups series by time and return labels or tags as fields.\n                Useful for showing time series with labels in a table where each label key becomes a separate column`,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}