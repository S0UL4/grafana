{"ast":null,"code":"/**\n * Get non overlapping duration of the ranges as they can overlap or have gaps.\n */\nimport { FieldType, MutableDataFrame, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\nexport function getNonOverlappingDuration(ranges) {\n  ranges.sort((a, b) => a[0] - b[0]);\n  const mergedRanges = ranges.reduce((acc, range) => {\n    if (!acc.length) {\n      return [range];\n    }\n\n    const tail = acc.slice(-1)[0];\n    const [prevStart, prevEnd] = tail;\n    const [start, end] = range;\n\n    if (end < prevEnd) {\n      // In this case the range is completely inside the prev range so we can just ignore it.\n      return acc;\n    }\n\n    if (start > prevEnd) {\n      // There is no overlap so we can just add it to stack\n      return [...acc, range];\n    } // We know there is overlap and current range ends later than previous so we can just extend the range\n\n\n    return [...acc.slice(0, -1), [prevStart, end]];\n  }, []);\n  return mergedRanges.reduce((acc, range) => {\n    return acc + (range[1] - range[0]);\n  }, 0);\n}\n/**\n * Returns a map of the spans with children array for easier processing. It will also contain empty spans in case\n * span is missing but other spans are it's children. This is more generic because it needs to allow iterating over\n * both arrays and dataframe views.\n */\n\nexport function makeSpanMap(getSpan) {\n  const spanMap = {};\n  let span;\n\n  for (let index = 0; span = getSpan(index), !!span; index++) {\n    if (!spanMap[span.id]) {\n      spanMap[span.id] = {\n        span: span.span,\n        children: []\n      };\n    } else {\n      spanMap[span.id].span = span.span;\n    }\n\n    for (const parentId of span.parentIds) {\n      if (parentId) {\n        if (!spanMap[parentId]) {\n          spanMap[parentId] = {\n            span: undefined,\n            children: [span.id]\n          };\n        } else {\n          spanMap[parentId].children.push(span.id);\n        }\n      }\n    }\n  }\n\n  return spanMap;\n}\nexport function getStats(duration, traceDuration, selfDuration) {\n  return {\n    main: `${toFixedNoTrailingZeros(duration)}ms (${toFixedNoTrailingZeros(duration / traceDuration * 100)}%)`,\n    secondary: `${toFixedNoTrailingZeros(selfDuration)}ms (${toFixedNoTrailingZeros(selfDuration / duration * 100)}%)`\n  };\n}\n\nfunction toFixedNoTrailingZeros(n) {\n  return parseFloat(n.toFixed(2));\n}\n/**\n * Create default frames used when returning data for node graph.\n */\n\n\nexport function makeFrames() {\n  const nodesFrame = new MutableDataFrame({\n    fields: [{\n      name: Fields.id,\n      type: FieldType.string\n    }, {\n      name: Fields.title,\n      type: FieldType.string\n    }, {\n      name: Fields.subTitle,\n      type: FieldType.string\n    }, {\n      name: Fields.mainStat,\n      type: FieldType.string,\n      config: {\n        displayName: 'Total time (% of trace)'\n      }\n    }, {\n      name: Fields.secondaryStat,\n      type: FieldType.string,\n      config: {\n        displayName: 'Self time (% of total)'\n      }\n    }, {\n      name: Fields.color,\n      type: FieldType.number,\n      config: {\n        color: {\n          mode: 'continuous-GrYlRd'\n        },\n        displayName: 'Self time / Trace duration'\n      }\n    }],\n    meta: {\n      preferredVisualisationType: 'nodeGraph'\n    }\n  });\n  const edgesFrame = new MutableDataFrame({\n    fields: [{\n      name: Fields.id,\n      type: FieldType.string\n    }, {\n      name: Fields.target,\n      type: FieldType.string\n    }, {\n      name: Fields.source,\n      type: FieldType.string\n    }],\n    meta: {\n      preferredVisualisationType: 'nodeGraph'\n    }\n  });\n  return [nodesFrame, edgesFrame];\n}","map":{"version":3,"names":["FieldType","MutableDataFrame","NodeGraphDataFrameFieldNames","Fields","getNonOverlappingDuration","ranges","sort","a","b","mergedRanges","reduce","acc","range","length","tail","slice","prevStart","prevEnd","start","end","makeSpanMap","getSpan","spanMap","span","index","id","children","parentId","parentIds","undefined","push","getStats","duration","traceDuration","selfDuration","main","toFixedNoTrailingZeros","secondary","n","parseFloat","toFixed","makeFrames","nodesFrame","fields","name","type","string","title","subTitle","mainStat","config","displayName","secondaryStat","color","number","mode","meta","preferredVisualisationType","edgesFrame","target","source"],"sources":["/home/soula/grafana/public/app/core/utils/tracing.ts"],"sourcesContent":["/**\n * Get non overlapping duration of the ranges as they can overlap or have gaps.\n */\nimport { FieldType, MutableDataFrame, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\n\nexport function getNonOverlappingDuration(ranges: Array<[number, number]>): number {\n  ranges.sort((a, b) => a[0] - b[0]);\n  const mergedRanges = ranges.reduce((acc, range) => {\n    if (!acc.length) {\n      return [range];\n    }\n    const tail = acc.slice(-1)[0];\n    const [prevStart, prevEnd] = tail;\n    const [start, end] = range;\n    if (end < prevEnd) {\n      // In this case the range is completely inside the prev range so we can just ignore it.\n      return acc;\n    }\n\n    if (start > prevEnd) {\n      // There is no overlap so we can just add it to stack\n      return [...acc, range];\n    }\n\n    // We know there is overlap and current range ends later than previous so we can just extend the range\n    return [...acc.slice(0, -1), [prevStart, end]] as Array<[number, number]>;\n  }, [] as Array<[number, number]>);\n\n  return mergedRanges.reduce((acc, range) => {\n    return acc + (range[1] - range[0]);\n  }, 0);\n}\n\n/**\n * Returns a map of the spans with children array for easier processing. It will also contain empty spans in case\n * span is missing but other spans are it's children. This is more generic because it needs to allow iterating over\n * both arrays and dataframe views.\n */\nexport function makeSpanMap<T>(getSpan: (index: number) => { span: T; id: string; parentIds: string[] } | undefined): {\n  [id: string]: { span: T; children: string[] };\n} {\n  const spanMap: { [id: string]: { span?: T; children: string[] } } = {};\n\n  let span;\n  for (let index = 0; (span = getSpan(index)), !!span; index++) {\n    if (!spanMap[span.id]) {\n      spanMap[span.id] = {\n        span: span.span,\n        children: [],\n      };\n    } else {\n      spanMap[span.id].span = span.span;\n    }\n\n    for (const parentId of span.parentIds) {\n      if (parentId) {\n        if (!spanMap[parentId]) {\n          spanMap[parentId] = {\n            span: undefined,\n            children: [span.id],\n          };\n        } else {\n          spanMap[parentId].children.push(span.id);\n        }\n      }\n    }\n  }\n  return spanMap as { [id: string]: { span: T; children: string[] } };\n}\n\nexport function getStats(duration: number, traceDuration: number, selfDuration: number) {\n  return {\n    main: `${toFixedNoTrailingZeros(duration)}ms (${toFixedNoTrailingZeros((duration / traceDuration) * 100)}%)`,\n    secondary: `${toFixedNoTrailingZeros(selfDuration)}ms (${toFixedNoTrailingZeros(\n      (selfDuration / duration) * 100\n    )}%)`,\n  };\n}\n\nfunction toFixedNoTrailingZeros(n: number) {\n  return parseFloat(n.toFixed(2));\n}\n\n/**\n * Create default frames used when returning data for node graph.\n */\nexport function makeFrames() {\n  const nodesFrame = new MutableDataFrame({\n    fields: [\n      { name: Fields.id, type: FieldType.string },\n      { name: Fields.title, type: FieldType.string },\n      { name: Fields.subTitle, type: FieldType.string },\n      { name: Fields.mainStat, type: FieldType.string, config: { displayName: 'Total time (% of trace)' } },\n      { name: Fields.secondaryStat, type: FieldType.string, config: { displayName: 'Self time (% of total)' } },\n      {\n        name: Fields.color,\n        type: FieldType.number,\n        config: { color: { mode: 'continuous-GrYlRd' }, displayName: 'Self time / Trace duration' },\n      },\n    ],\n    meta: {\n      preferredVisualisationType: 'nodeGraph',\n    },\n  });\n\n  const edgesFrame = new MutableDataFrame({\n    fields: [\n      { name: Fields.id, type: FieldType.string },\n      { name: Fields.target, type: FieldType.string },\n      { name: Fields.source, type: FieldType.string },\n    ],\n    meta: {\n      preferredVisualisationType: 'nodeGraph',\n    },\n  });\n\n  return [nodesFrame, edgesFrame];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}