{"ast":null,"code":"import { getPanelOptionsWithDefaults } from 'app/features/dashboard/state/getPanelOptionsWithDefaults';\nimport { toPanelModelLibraryPanel } from 'app/features/library-panels/utils';\nimport { getPanelPluginNotFound } from 'app/features/panel/components/PanelPluginError';\nimport { loadPanelPlugin } from 'app/features/plugins/admin/state/actions';\nimport { PanelOptionsChangedEvent, PanelQueriesChangedEvent } from 'app/types/events';\nimport { changePanelKey, cleanUpAngularComponent, panelModelAndPluginReady, removePanel, removePanels } from './reducers';\nexport function initPanelState(panel) {\n  return async (dispatch, getStore) => {\n    let pluginToLoad = panel.type;\n    let plugin = getStore().plugins.panels[pluginToLoad];\n\n    if (!plugin) {\n      try {\n        plugin = await dispatch(loadPanelPlugin(pluginToLoad));\n      } catch (e) {\n        // When plugin not found\n        plugin = getPanelPluginNotFound(pluginToLoad, pluginToLoad === 'row');\n      }\n    }\n\n    if (!panel.plugin) {\n      panel.pluginLoaded(plugin);\n    }\n\n    dispatch(panelModelAndPluginReady({\n      key: panel.key,\n      plugin\n    }));\n  };\n}\nexport function cleanUpPanelState(panelKey) {\n  return (dispatch, getStore) => {\n    const store = getStore().panels;\n    cleanUpAngularComponent(store[panelKey]);\n    dispatch(removePanel({\n      key: panelKey\n    }));\n  };\n}\nexport function cleanAndRemoveMany(panelKeys) {\n  return (dispatch, getStore) => {\n    const store = getStore().panels;\n\n    for (const key of panelKeys) {\n      cleanUpAngularComponent(store[key]);\n    }\n\n    dispatch(removePanels({\n      keys: panelKeys\n    }));\n  };\n}\nexport function changePanelPlugin({\n  panel,\n  pluginId,\n  options,\n  fieldConfig\n}) {\n  return async (dispatch, getStore) => {\n    // ignore action is no change\n    if (panel.type === pluginId && !options && !fieldConfig) {\n      return;\n    }\n\n    const store = getStore();\n    let plugin = store.plugins.panels[pluginId];\n\n    if (!plugin) {\n      plugin = await dispatch(loadPanelPlugin(pluginId));\n    }\n\n    let cleanUpKey = panel.key;\n\n    if (panel.type !== pluginId) {\n      panel.changePlugin(plugin);\n    }\n\n    if (options || fieldConfig) {\n      const newOptions = getPanelOptionsWithDefaults({\n        plugin,\n        currentOptions: options || panel.options,\n        currentFieldConfig: fieldConfig || panel.fieldConfig,\n        isAfterPluginChange: false\n      });\n      panel.options = newOptions.options;\n      panel.fieldConfig = newOptions.fieldConfig;\n      panel.configRev++;\n    }\n\n    panel.generateNewKey();\n    dispatch(panelModelAndPluginReady({\n      key: panel.key,\n      plugin,\n      cleanUpKey\n    }));\n  };\n}\nexport function changeToLibraryPanel(panel, libraryPanel) {\n  return async (dispatch, getStore) => {\n    const newPluginId = libraryPanel.model.type;\n    const oldType = panel.type; // Update model but preserve gridPos & id\n\n    panel.restoreModel(Object.assign({}, libraryPanel.model, {\n      gridPos: panel.gridPos,\n      id: panel.id,\n      libraryPanel: toPanelModelLibraryPanel(libraryPanel)\n    })); // a new library panel usually means new queries, clear any current result\n\n    panel.getQueryRunner().clearLastResult(); // Handle plugin change\n\n    if (oldType !== newPluginId) {\n      const store = getStore();\n      let plugin = store.plugins.panels[newPluginId];\n\n      if (!plugin) {\n        plugin = await dispatch(loadPanelPlugin(newPluginId));\n      }\n\n      const oldKey = panel.key;\n      panel.pluginLoaded(plugin);\n      panel.generateNewKey();\n      await dispatch(panelModelAndPluginReady({\n        key: panel.key,\n        plugin,\n        cleanUpKey: oldKey\n      }));\n    } else {\n      // Even if the plugin is the same, we want to change the key\n      // to force a rerender\n      const oldKey = panel.key;\n      panel.generateNewKey();\n      dispatch(changePanelKey({\n        oldKey,\n        newKey: panel.key\n      }));\n    }\n\n    panel.configRev = 0;\n    panel.refresh();\n    panel.events.publish(PanelQueriesChangedEvent);\n    panel.events.publish(PanelOptionsChangedEvent);\n  };\n}","map":{"version":3,"names":["getPanelOptionsWithDefaults","toPanelModelLibraryPanel","getPanelPluginNotFound","loadPanelPlugin","PanelOptionsChangedEvent","PanelQueriesChangedEvent","changePanelKey","cleanUpAngularComponent","panelModelAndPluginReady","removePanel","removePanels","initPanelState","panel","dispatch","getStore","pluginToLoad","type","plugin","plugins","panels","e","pluginLoaded","key","cleanUpPanelState","panelKey","store","cleanAndRemoveMany","panelKeys","keys","changePanelPlugin","pluginId","options","fieldConfig","cleanUpKey","changePlugin","newOptions","currentOptions","currentFieldConfig","isAfterPluginChange","configRev","generateNewKey","changeToLibraryPanel","libraryPanel","newPluginId","model","oldType","restoreModel","gridPos","id","getQueryRunner","clearLastResult","oldKey","newKey","refresh","events","publish"],"sources":["/home/soula/grafana/public/app/features/panel/state/actions.ts"],"sourcesContent":["import { DataTransformerConfig, FieldConfigSource } from '@grafana/data';\nimport { PanelModel } from 'app/features/dashboard/state/PanelModel';\nimport { getPanelOptionsWithDefaults } from 'app/features/dashboard/state/getPanelOptionsWithDefaults';\nimport { LibraryElementDTO } from 'app/features/library-panels/types';\nimport { toPanelModelLibraryPanel } from 'app/features/library-panels/utils';\nimport { getPanelPluginNotFound } from 'app/features/panel/components/PanelPluginError';\nimport { loadPanelPlugin } from 'app/features/plugins/admin/state/actions';\nimport { ThunkResult } from 'app/types';\nimport { PanelOptionsChangedEvent, PanelQueriesChangedEvent } from 'app/types/events';\n\nimport {\n  changePanelKey,\n  cleanUpAngularComponent,\n  panelModelAndPluginReady,\n  removePanel,\n  removePanels,\n} from './reducers';\n\nexport function initPanelState(panel: PanelModel): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    let pluginToLoad = panel.type;\n    let plugin = getStore().plugins.panels[pluginToLoad];\n\n    if (!plugin) {\n      try {\n        plugin = await dispatch(loadPanelPlugin(pluginToLoad));\n      } catch (e) {\n        // When plugin not found\n        plugin = getPanelPluginNotFound(pluginToLoad, pluginToLoad === 'row');\n      }\n    }\n\n    if (!panel.plugin) {\n      panel.pluginLoaded(plugin);\n    }\n\n    dispatch(panelModelAndPluginReady({ key: panel.key, plugin }));\n  };\n}\n\nexport function cleanUpPanelState(panelKey: string): ThunkResult<void> {\n  return (dispatch, getStore) => {\n    const store = getStore().panels;\n    cleanUpAngularComponent(store[panelKey]);\n    dispatch(removePanel({ key: panelKey }));\n  };\n}\n\nexport function cleanAndRemoveMany(panelKeys: string[]): ThunkResult<void> {\n  return (dispatch, getStore) => {\n    const store = getStore().panels;\n    for (const key of panelKeys) {\n      cleanUpAngularComponent(store[key]);\n    }\n    dispatch(removePanels({ keys: panelKeys }));\n  };\n}\n\nexport interface ChangePanelPluginAndOptionsArgs {\n  panel: PanelModel;\n  pluginId: string;\n  options?: any;\n  fieldConfig?: FieldConfigSource;\n  transformations?: DataTransformerConfig[];\n}\n\nexport function changePanelPlugin({\n  panel,\n  pluginId,\n  options,\n  fieldConfig,\n}: ChangePanelPluginAndOptionsArgs): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    // ignore action is no change\n    if (panel.type === pluginId && !options && !fieldConfig) {\n      return;\n    }\n\n    const store = getStore();\n    let plugin = store.plugins.panels[pluginId];\n\n    if (!plugin) {\n      plugin = await dispatch(loadPanelPlugin(pluginId));\n    }\n\n    let cleanUpKey = panel.key;\n\n    if (panel.type !== pluginId) {\n      panel.changePlugin(plugin);\n    }\n\n    if (options || fieldConfig) {\n      const newOptions = getPanelOptionsWithDefaults({\n        plugin,\n        currentOptions: options || panel.options,\n        currentFieldConfig: fieldConfig || panel.fieldConfig,\n        isAfterPluginChange: false,\n      });\n\n      panel.options = newOptions.options;\n      panel.fieldConfig = newOptions.fieldConfig;\n      panel.configRev++;\n    }\n\n    panel.generateNewKey();\n\n    dispatch(panelModelAndPluginReady({ key: panel.key, plugin, cleanUpKey }));\n  };\n}\n\nexport function changeToLibraryPanel(panel: PanelModel, libraryPanel: LibraryElementDTO): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    const newPluginId = libraryPanel.model.type;\n    const oldType = panel.type;\n\n    // Update model but preserve gridPos & id\n    panel.restoreModel({\n      ...libraryPanel.model,\n      gridPos: panel.gridPos,\n      id: panel.id,\n      libraryPanel: toPanelModelLibraryPanel(libraryPanel),\n    });\n\n    // a new library panel usually means new queries, clear any current result\n    panel.getQueryRunner().clearLastResult();\n\n    // Handle plugin change\n    if (oldType !== newPluginId) {\n      const store = getStore();\n      let plugin = store.plugins.panels[newPluginId];\n\n      if (!plugin) {\n        plugin = await dispatch(loadPanelPlugin(newPluginId));\n      }\n\n      const oldKey = panel.key;\n\n      panel.pluginLoaded(plugin);\n      panel.generateNewKey();\n\n      await dispatch(panelModelAndPluginReady({ key: panel.key, plugin, cleanUpKey: oldKey }));\n    } else {\n      // Even if the plugin is the same, we want to change the key\n      // to force a rerender\n      const oldKey = panel.key;\n      panel.generateNewKey();\n      dispatch(changePanelKey({ oldKey, newKey: panel.key }));\n    }\n\n    panel.configRev = 0;\n    panel.refresh();\n\n    panel.events.publish(PanelQueriesChangedEvent);\n    panel.events.publish(PanelOptionsChangedEvent);\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}