{"ast":null,"code":"import { pick } from 'lodash';\nimport store from 'app/core/store';\nimport { cleanUpPanelState, initPanelState } from 'app/features/panel/state/actions';\nimport { panelModelAndPluginReady } from 'app/features/panel/state/reducers';\nimport { closeEditor, PANEL_EDITOR_UI_STATE_STORAGE_KEY, setDiscardChanges, setPanelEditorUIState, updateEditorInitState } from './reducers';\nexport function initPanelEditor(sourcePanel, dashboard) {\n  return async dispatch => {\n    const panel = dashboard.initEditPanel(sourcePanel);\n    await dispatch(initPanelState(panel));\n    dispatch(updateEditorInitState({\n      panel,\n      sourcePanel\n    }));\n  };\n}\nexport function discardPanelChanges() {\n  return async (dispatch, getStore) => {\n    const {\n      getPanel\n    } = getStore().panelEditor;\n    getPanel().configRev = 0;\n    dispatch(setDiscardChanges(true));\n  };\n}\nexport function updateDuplicateLibraryPanels(modifiedPanel, dashboard) {\n  return dispatch => {\n    var _modifiedPanel$librar;\n\n    if (((_modifiedPanel$librar = modifiedPanel.libraryPanel) === null || _modifiedPanel$librar === void 0 ? void 0 : _modifiedPanel$librar.uid) === undefined || !dashboard) {\n      return;\n    }\n\n    const modifiedSaveModel = modifiedPanel.getSaveModel();\n\n    for (const panel of dashboard.panels) {\n      var _panel$plugin, _modifiedPanel$plugin;\n\n      if (skipPanelUpdate(modifiedPanel, panel)) {\n        continue;\n      }\n\n      panel.restoreModel(Object.assign({}, modifiedSaveModel, pick(panel, 'gridPos', 'id'))); // Loaded plugin is not included in the persisted properties\n      // So is not handled by restoreModel\n\n      const pluginChanged = ((_panel$plugin = panel.plugin) === null || _panel$plugin === void 0 ? void 0 : _panel$plugin.meta.id) !== ((_modifiedPanel$plugin = modifiedPanel.plugin) === null || _modifiedPanel$plugin === void 0 ? void 0 : _modifiedPanel$plugin.meta.id);\n      panel.plugin = modifiedPanel.plugin;\n      panel.configRev++;\n\n      if (pluginChanged) {\n        const cleanUpKey = panel.key;\n        panel.generateNewKey();\n        dispatch(panelModelAndPluginReady({\n          key: panel.key,\n          plugin: panel.plugin,\n          cleanUpKey\n        }));\n      } // Resend last query result on source panel query runner\n      // But do this after the panel edit editor exit process has completed\n\n\n      setTimeout(() => {\n        panel.getQueryRunner().useLastResultFrom(modifiedPanel.getQueryRunner());\n      }, 20);\n    }\n\n    if (modifiedPanel.repeat) {\n      // We skip any repeated library panels so we need to update them by calling processRepeats\n      // But do this after the panel edit editor exit process has completed\n      setTimeout(() => dashboard.processRepeats(), 20);\n    }\n  };\n}\nexport function skipPanelUpdate(modifiedPanel, panelToUpdate) {\n  var _panelToUpdate$librar;\n\n  // don't update library panels that aren't of the same type\n  if (((_panelToUpdate$librar = panelToUpdate.libraryPanel) === null || _panelToUpdate$librar === void 0 ? void 0 : _panelToUpdate$librar.uid) !== modifiedPanel.libraryPanel.uid) {\n    return true;\n  } // don't update the modifiedPanel twice\n\n\n  if (panelToUpdate.id && panelToUpdate.id === modifiedPanel.id) {\n    return true;\n  } // don't update library panels that are repeated\n\n\n  if (panelToUpdate.repeatPanelId) {\n    return true;\n  }\n\n  return false;\n}\nexport function exitPanelEditor() {\n  return async (dispatch, getStore) => {\n    const dashboard = getStore().dashboard.getModel();\n    const {\n      getPanel,\n      getSourcePanel,\n      shouldDiscardChanges\n    } = getStore().panelEditor;\n    const panel = getPanel();\n\n    if (dashboard) {\n      dashboard.exitPanelEditor();\n    }\n\n    if (!shouldDiscardChanges) {\n      const modifiedSaveModel = panel.getSaveModel();\n      const sourcePanel = getSourcePanel();\n      const panelTypeChanged = sourcePanel.type !== panel.type;\n      dispatch(updateDuplicateLibraryPanels(panel, dashboard));\n      sourcePanel.restoreModel(modifiedSaveModel);\n      sourcePanel.configRev++; // force check the configs\n\n      if (panelTypeChanged) {\n        // Loaded plugin is not included in the persisted properties so is not handled by restoreModel\n        sourcePanel.plugin = panel.plugin;\n        const cleanUpKey = sourcePanel.key;\n        sourcePanel.generateNewKey();\n        await dispatch(panelModelAndPluginReady({\n          key: sourcePanel.key,\n          plugin: panel.plugin,\n          cleanUpKey\n        }));\n      } // Resend last query result on source panel query runner\n      // But do this after the panel edit editor exit process has completed\n\n\n      setTimeout(() => {\n        sourcePanel.getQueryRunner().useLastResultFrom(panel.getQueryRunner());\n        sourcePanel.render();\n      }, 20);\n    }\n\n    dispatch(cleanUpPanelState(panel.key));\n    dispatch(closeEditor());\n  };\n}\nexport function updatePanelEditorUIState(uiState) {\n  return (dispatch, getStore) => {\n    const nextState = Object.assign({}, getStore().panelEditor.ui, uiState);\n    dispatch(setPanelEditorUIState(nextState));\n\n    try {\n      store.setObject(PANEL_EDITOR_UI_STATE_STORAGE_KEY, nextState);\n    } catch (error) {\n      console.error(error);\n    }\n  };\n}","map":{"version":3,"names":["pick","store","cleanUpPanelState","initPanelState","panelModelAndPluginReady","closeEditor","PANEL_EDITOR_UI_STATE_STORAGE_KEY","setDiscardChanges","setPanelEditorUIState","updateEditorInitState","initPanelEditor","sourcePanel","dashboard","dispatch","panel","initEditPanel","discardPanelChanges","getStore","getPanel","panelEditor","configRev","updateDuplicateLibraryPanels","modifiedPanel","libraryPanel","uid","undefined","modifiedSaveModel","getSaveModel","panels","skipPanelUpdate","restoreModel","pluginChanged","plugin","meta","id","cleanUpKey","key","generateNewKey","setTimeout","getQueryRunner","useLastResultFrom","repeat","processRepeats","panelToUpdate","repeatPanelId","exitPanelEditor","getModel","getSourcePanel","shouldDiscardChanges","panelTypeChanged","type","render","updatePanelEditorUIState","uiState","nextState","ui","setObject","error","console"],"sources":["/home/soula/grafana/public/app/features/dashboard/components/PanelEditor/state/actions.ts"],"sourcesContent":["import { pick } from 'lodash';\n\nimport store from 'app/core/store';\nimport { cleanUpPanelState, initPanelState } from 'app/features/panel/state/actions';\nimport { panelModelAndPluginReady } from 'app/features/panel/state/reducers';\nimport { ThunkResult } from 'app/types';\n\nimport { DashboardModel, PanelModel } from '../../../state';\n\nimport {\n  closeEditor,\n  PANEL_EDITOR_UI_STATE_STORAGE_KEY,\n  PanelEditorUIState,\n  setDiscardChanges,\n  setPanelEditorUIState,\n  updateEditorInitState,\n} from './reducers';\n\nexport function initPanelEditor(sourcePanel: PanelModel, dashboard: DashboardModel): ThunkResult<void> {\n  return async (dispatch) => {\n    const panel = dashboard.initEditPanel(sourcePanel);\n\n    await dispatch(initPanelState(panel));\n\n    dispatch(\n      updateEditorInitState({\n        panel,\n        sourcePanel,\n      })\n    );\n  };\n}\n\nexport function discardPanelChanges(): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    const { getPanel } = getStore().panelEditor;\n    getPanel().configRev = 0;\n    dispatch(setDiscardChanges(true));\n  };\n}\n\nexport function updateDuplicateLibraryPanels(\n  modifiedPanel: PanelModel,\n  dashboard: DashboardModel | null\n): ThunkResult<void> {\n  return (dispatch) => {\n    if (modifiedPanel.libraryPanel?.uid === undefined || !dashboard) {\n      return;\n    }\n\n    const modifiedSaveModel = modifiedPanel.getSaveModel();\n    for (const panel of dashboard.panels) {\n      if (skipPanelUpdate(modifiedPanel, panel)) {\n        continue;\n      }\n\n      panel.restoreModel({\n        ...modifiedSaveModel,\n        ...pick(panel, 'gridPos', 'id'),\n      });\n\n      // Loaded plugin is not included in the persisted properties\n      // So is not handled by restoreModel\n      const pluginChanged = panel.plugin?.meta.id !== modifiedPanel.plugin?.meta.id;\n      panel.plugin = modifiedPanel.plugin;\n      panel.configRev++;\n\n      if (pluginChanged) {\n        const cleanUpKey = panel.key;\n        panel.generateNewKey();\n\n        dispatch(panelModelAndPluginReady({ key: panel.key, plugin: panel.plugin!, cleanUpKey }));\n      }\n\n      // Resend last query result on source panel query runner\n      // But do this after the panel edit editor exit process has completed\n      setTimeout(() => {\n        panel.getQueryRunner().useLastResultFrom(modifiedPanel.getQueryRunner());\n      }, 20);\n    }\n\n    if (modifiedPanel.repeat) {\n      // We skip any repeated library panels so we need to update them by calling processRepeats\n      // But do this after the panel edit editor exit process has completed\n      setTimeout(() => dashboard.processRepeats(), 20);\n    }\n  };\n}\n\nexport function skipPanelUpdate(modifiedPanel: PanelModel, panelToUpdate: PanelModel): boolean {\n  // don't update library panels that aren't of the same type\n  if (panelToUpdate.libraryPanel?.uid !== modifiedPanel.libraryPanel!.uid) {\n    return true;\n  }\n\n  // don't update the modifiedPanel twice\n  if (panelToUpdate.id && panelToUpdate.id === modifiedPanel.id) {\n    return true;\n  }\n\n  // don't update library panels that are repeated\n  if (panelToUpdate.repeatPanelId) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function exitPanelEditor(): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    const dashboard = getStore().dashboard.getModel();\n    const { getPanel, getSourcePanel, shouldDiscardChanges } = getStore().panelEditor;\n    const panel = getPanel();\n\n    if (dashboard) {\n      dashboard.exitPanelEditor();\n    }\n\n    if (!shouldDiscardChanges) {\n      const modifiedSaveModel = panel.getSaveModel();\n      const sourcePanel = getSourcePanel();\n      const panelTypeChanged = sourcePanel.type !== panel.type;\n\n      dispatch(updateDuplicateLibraryPanels(panel, dashboard));\n\n      sourcePanel.restoreModel(modifiedSaveModel);\n      sourcePanel.configRev++; // force check the configs\n\n      if (panelTypeChanged) {\n        // Loaded plugin is not included in the persisted properties so is not handled by restoreModel\n        sourcePanel.plugin = panel.plugin;\n        const cleanUpKey = sourcePanel.key;\n        sourcePanel.generateNewKey();\n\n        await dispatch(panelModelAndPluginReady({ key: sourcePanel.key, plugin: panel.plugin!, cleanUpKey }));\n      }\n\n      // Resend last query result on source panel query runner\n      // But do this after the panel edit editor exit process has completed\n      setTimeout(() => {\n        sourcePanel.getQueryRunner().useLastResultFrom(panel.getQueryRunner());\n        sourcePanel.render();\n      }, 20);\n    }\n\n    dispatch(cleanUpPanelState(panel.key));\n    dispatch(closeEditor());\n  };\n}\n\nexport function updatePanelEditorUIState(uiState: Partial<PanelEditorUIState>): ThunkResult<void> {\n  return (dispatch, getStore) => {\n    const nextState = { ...getStore().panelEditor.ui, ...uiState };\n    dispatch(setPanelEditorUIState(nextState));\n    try {\n      store.setObject(PANEL_EDITOR_UI_STATE_STORAGE_KEY, nextState);\n    } catch (error) {\n      console.error(error);\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}