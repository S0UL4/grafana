{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { DataFrameType, FieldType, DataTransformerID, outerJoinDataFrames, fieldMatchers, FieldMatcherID, MutableDataFrame, ArrayVector } from '@grafana/data';\n\n/**\n * There is currently an effort to figure out consistent names\n * for the various formats/types we produce and use.\n *\n * This transformer will eventually include the required metadata that can assert\n * a DataFrame[] is of a given type\n *\n * @internal -- TBD\n */\nexport let timeSeriesFormat;\n\n(function (timeSeriesFormat) {\n  timeSeriesFormat[\"TimeSeriesWide\"] = \"wide\";\n  timeSeriesFormat[\"TimeSeriesMany\"] = \"many\";\n  timeSeriesFormat[\"TimeSeriesLong\"] = \"long\";\n})(timeSeriesFormat || (timeSeriesFormat = {}));\n\n/**\n * Convert to [][time,number]\n */\nexport function toTimeSeriesMany(data) {\n  if (!Array.isArray(data) || data.length === 0) {\n    return data;\n  }\n\n  const result = [];\n\n  for (const frame of toTimeSeriesLong(data)) {\n    const timeField = frame.fields[0];\n\n    if (!timeField || timeField.type !== FieldType.time) {\n      continue;\n    }\n\n    const valueFields = [];\n    const labelFields = [];\n\n    for (const field of frame.fields) {\n      switch (field.type) {\n        case FieldType.number:\n        case FieldType.boolean:\n          valueFields.push(field);\n          break;\n\n        case FieldType.string:\n          labelFields.push(field);\n          break;\n      }\n    }\n\n    for (const field of valueFields) {\n      if (labelFields.length) {\n        // new frame for each label key\n        const builders = new Map();\n\n        for (let i = 0; i < frame.length; i++) {\n          const time = timeField.values.get(i);\n          const value = field.values.get(i);\n\n          if (value === undefined || time == null) {\n            continue; // skip values left over from join\n          }\n\n          const key = labelFields.map(f => f.values.get(i)).join('/');\n          let builder = builders.get(key);\n\n          if (!builder) {\n            builder = {\n              key,\n              time: [],\n              value: [],\n              labels: {}\n            };\n\n            for (const label of labelFields) {\n              builder.labels[label.name] = label.values.get(i);\n            }\n\n            builders.set(key, builder);\n          }\n\n          builder.time.push(time);\n          builder.value.push(value);\n        } // Add a frame for each distinct value\n\n\n        for (const b of builders.values()) {\n          result.push({\n            name: frame.name,\n            refId: frame.refId,\n            meta: Object.assign({}, frame.meta, {\n              type: DataFrameType.TimeSeriesMany\n            }),\n            fields: [Object.assign({}, timeField, {\n              values: new ArrayVector(b.time)\n            }), Object.assign({}, field, {\n              values: new ArrayVector(b.value),\n              labels: b.labels\n            })],\n            length: b.time.length\n          });\n        }\n      } else {\n        result.push({\n          name: frame.name,\n          refId: frame.refId,\n          meta: Object.assign({}, frame.meta, {\n            type: DataFrameType.TimeSeriesMany\n          }),\n          fields: [timeField, field],\n          length: frame.length\n        });\n      }\n    }\n  }\n\n  return result;\n}\nexport function toTimeSeriesLong(data) {\n  if (!Array.isArray(data) || data.length === 0) {\n    return data;\n  }\n\n  const result = [];\n\n  for (const frame of data) {\n    let timeField;\n    const uniqueValueNames = [];\n    const uniqueValueNamesToType = {};\n    const uniqueLabelKeys = {};\n    const labelKeyToWideIndices = {};\n    const uniqueFactorNamesToWideIndex = {};\n\n    for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n      const field = frame.fields[fieldIndex];\n\n      switch (field.type) {\n        case FieldType.string:\n        case FieldType.boolean:\n          if (field.name in uniqueFactorNamesToWideIndex) {// TODO error?\n          } else {\n            uniqueFactorNamesToWideIndex[field.name] = fieldIndex;\n            uniqueLabelKeys[field.name] = true;\n          }\n\n          break;\n\n        case FieldType.time:\n          if (!timeField) {\n            timeField = field;\n            break;\n          }\n\n        default:\n          if (field.name in uniqueValueNamesToType) {\n            const type = uniqueValueNamesToType[field.name];\n\n            if (field.type !== type) {\n              // TODO error?\n              continue;\n            }\n          } else {\n            uniqueValueNamesToType[field.name] = field.type;\n            uniqueValueNames.push(field.name);\n          }\n\n          const tKey = JSON.stringify(field.labels);\n          const wideIndices = labelKeyToWideIndices[tKey];\n\n          if (wideIndices !== undefined) {\n            wideIndices.push(fieldIndex);\n          } else {\n            labelKeyToWideIndices[tKey] = [fieldIndex];\n          }\n\n          if (field.labels != null) {\n            for (const labelKey in field.labels) {\n              uniqueLabelKeys[labelKey] = true;\n            }\n          }\n\n      }\n    }\n\n    if (!timeField) {\n      continue;\n    }\n\n    const sortedTimeRowIndices = [];\n    const sortedUniqueLabelKeys = [];\n    const uniqueFactorNames = [];\n    const uniqueFactorNamesWithWideIndices = [];\n\n    for (let wideRowIndex = 0; wideRowIndex < frame.length; wideRowIndex++) {\n      sortedTimeRowIndices.push({\n        time: timeField.values.get(wideRowIndex),\n        wideRowIndex: wideRowIndex\n      });\n    }\n\n    for (const labelKeys in labelKeyToWideIndices) {\n      sortedUniqueLabelKeys.push(labelKeys);\n    }\n\n    for (const labelKey in uniqueLabelKeys) {\n      uniqueFactorNames.push(labelKey);\n    }\n\n    for (const name in uniqueFactorNamesToWideIndex) {\n      uniqueFactorNamesWithWideIndices.push(name);\n    }\n\n    sortedTimeRowIndices.sort((a, b) => a.time - b.time);\n    sortedUniqueLabelKeys.sort();\n    uniqueFactorNames.sort();\n    uniqueValueNames.sort();\n    const longFrame = new MutableDataFrame(Object.assign({}, frame, {\n      meta: Object.assign({}, frame.meta, {\n        type: DataFrameType.TimeSeriesLong\n      }),\n      fields: [{\n        name: timeField.name,\n        type: timeField.type\n      }]\n    }));\n\n    for (const name of uniqueValueNames) {\n      longFrame.addField({\n        name: name,\n        type: uniqueValueNamesToType[name]\n      });\n    }\n\n    for (const name of uniqueFactorNames) {\n      longFrame.addField({\n        name: name,\n        type: FieldType.string\n      });\n    }\n\n    for (const timeWideRowIndex of sortedTimeRowIndices) {\n      const {\n        time,\n        wideRowIndex\n      } = timeWideRowIndex;\n\n      for (const labelKeys of sortedUniqueLabelKeys) {\n        const rowValues = {};\n\n        for (const name of uniqueFactorNamesWithWideIndices) {\n          rowValues[name] = frame.fields[uniqueFactorNamesToWideIndex[name]].values.get(wideRowIndex);\n        }\n\n        let index = 0;\n\n        for (const wideFieldIndex of labelKeyToWideIndices[labelKeys]) {\n          const wideField = frame.fields[wideFieldIndex];\n\n          if (index++ === 0 && wideField.labels != null) {\n            for (const labelKey in wideField.labels) {\n              rowValues[labelKey] = wideField.labels[labelKey];\n            }\n          }\n\n          rowValues[wideField.name] = wideField.values.get(wideRowIndex);\n        }\n\n        rowValues[timeField.name] = time;\n        longFrame.add(rowValues);\n      }\n    }\n\n    result.push(longFrame);\n  }\n\n  return result;\n}\nexport const prepareTimeSeriesTransformer = {\n  id: DataTransformerID.prepareTimeSeries,\n  name: 'Prepare time series',\n  description: `Will stretch data frames from the wide format into the long format. This is really helpful to be able to keep backwards compatibility for panels not supporting the new wide format.`,\n  defaultOptions: {},\n  operator: options => source => source.pipe(map(data => prepareTimeSeriesTransformer.transformer(options)(data))),\n  transformer: options => {\n    var _options$format;\n\n    const format = (_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : timeSeriesFormat.TimeSeriesWide;\n\n    if (format === timeSeriesFormat.TimeSeriesMany) {\n      return toTimeSeriesMany;\n    } else if (format === timeSeriesFormat.TimeSeriesLong) {\n      return toTimeSeriesLong;\n    }\n\n    return data => {\n      // Join by the first frame\n      const frame = outerJoinDataFrames({\n        frames: data,\n        joinBy: fieldMatchers.get(FieldMatcherID.firstTimeField).get({}),\n        keepOriginIndices: true\n      });\n      return frame ? [frame] : [];\n    };\n  }\n};","map":{"version":3,"names":["map","DataFrameType","FieldType","DataTransformerID","outerJoinDataFrames","fieldMatchers","FieldMatcherID","MutableDataFrame","ArrayVector","timeSeriesFormat","toTimeSeriesMany","data","Array","isArray","length","result","frame","toTimeSeriesLong","timeField","fields","type","time","valueFields","labelFields","field","number","boolean","push","string","builders","Map","i","values","get","value","undefined","key","f","join","builder","labels","label","name","set","b","refId","meta","TimeSeriesMany","uniqueValueNames","uniqueValueNamesToType","uniqueLabelKeys","labelKeyToWideIndices","uniqueFactorNamesToWideIndex","fieldIndex","tKey","JSON","stringify","wideIndices","labelKey","sortedTimeRowIndices","sortedUniqueLabelKeys","uniqueFactorNames","uniqueFactorNamesWithWideIndices","wideRowIndex","labelKeys","sort","a","longFrame","TimeSeriesLong","addField","timeWideRowIndex","rowValues","index","wideFieldIndex","wideField","add","prepareTimeSeriesTransformer","id","prepareTimeSeries","description","defaultOptions","operator","options","source","pipe","transformer","format","TimeSeriesWide","frames","joinBy","firstTimeField","keepOriginIndices"],"sources":["/home/soula/grafana/public/app/features/transformers/prepareTimeSeries/prepareTimeSeries.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport {\n  SynchronousDataTransformerInfo,\n  DataFrame,\n  DataFrameType,\n  FieldType,\n  DataTransformerID,\n  outerJoinDataFrames,\n  fieldMatchers,\n  FieldMatcherID,\n  Field,\n  MutableDataFrame,\n  ArrayVector,\n} from '@grafana/data';\nimport { Labels } from 'app/types/unified-alerting-dto';\n\n/**\n * There is currently an effort to figure out consistent names\n * for the various formats/types we produce and use.\n *\n * This transformer will eventually include the required metadata that can assert\n * a DataFrame[] is of a given type\n *\n * @internal -- TBD\n */\nexport enum timeSeriesFormat {\n  TimeSeriesWide = 'wide', // [time,...values]\n  TimeSeriesMany = 'many', // All frames have [time,number]\n  TimeSeriesLong = 'long',\n}\n\nexport type PrepareTimeSeriesOptions = {\n  format: timeSeriesFormat;\n};\n\n/**\n * Convert to [][time,number]\n */\nexport function toTimeSeriesMany(data: DataFrame[]): DataFrame[] {\n  if (!Array.isArray(data) || data.length === 0) {\n    return data;\n  }\n\n  const result: DataFrame[] = [];\n  for (const frame of toTimeSeriesLong(data)) {\n    const timeField = frame.fields[0];\n    if (!timeField || timeField.type !== FieldType.time) {\n      continue;\n    }\n    const valueFields: Field[] = [];\n    const labelFields: Field[] = [];\n    for (const field of frame.fields) {\n      switch (field.type) {\n        case FieldType.number:\n        case FieldType.boolean:\n          valueFields.push(field);\n          break;\n        case FieldType.string:\n          labelFields.push(field);\n          break;\n      }\n    }\n\n    for (const field of valueFields) {\n      if (labelFields.length) {\n        // new frame for each label key\n        type frameBuilder = {\n          time: number[];\n          value: number[];\n          key: string;\n          labels: Labels;\n        };\n        const builders = new Map<string, frameBuilder>();\n        for (let i = 0; i < frame.length; i++) {\n          const time = timeField.values.get(i);\n          const value = field.values.get(i);\n          if (value === undefined || time == null) {\n            continue; // skip values left over from join\n          }\n\n          const key = labelFields.map((f) => f.values.get(i)).join('/');\n          let builder = builders.get(key);\n          if (!builder) {\n            builder = {\n              key,\n              time: [],\n              value: [],\n              labels: {},\n            };\n            for (const label of labelFields) {\n              builder.labels[label.name] = label.values.get(i);\n            }\n            builders.set(key, builder);\n          }\n          builder.time.push(time);\n          builder.value.push(value);\n        }\n\n        // Add a frame for each distinct value\n        for (const b of builders.values()) {\n          result.push({\n            name: frame.name,\n            refId: frame.refId,\n            meta: {\n              ...frame.meta,\n              type: DataFrameType.TimeSeriesMany,\n            },\n            fields: [\n              {\n                ...timeField,\n                values: new ArrayVector(b.time),\n              },\n              {\n                ...field,\n                values: new ArrayVector(b.value),\n                labels: b.labels,\n              },\n            ],\n            length: b.time.length,\n          });\n        }\n      } else {\n        result.push({\n          name: frame.name,\n          refId: frame.refId,\n          meta: {\n            ...frame.meta,\n            type: DataFrameType.TimeSeriesMany,\n          },\n          fields: [timeField, field],\n          length: frame.length,\n        });\n      }\n    }\n  }\n  return result;\n}\n\nexport function toTimeSeriesLong(data: DataFrame[]): DataFrame[] {\n  if (!Array.isArray(data) || data.length === 0) {\n    return data;\n  }\n\n  const result: DataFrame[] = [];\n  for (const frame of data) {\n    let timeField: Field | undefined;\n    const uniqueValueNames: string[] = [];\n    const uniqueValueNamesToType: Record<string, FieldType> = {};\n    const uniqueLabelKeys: Record<string, boolean> = {};\n    const labelKeyToWideIndices: Record<string, number[]> = {};\n    const uniqueFactorNamesToWideIndex: Record<string, number> = {};\n\n    for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n      const field = frame.fields[fieldIndex];\n\n      switch (field.type) {\n        case FieldType.string:\n        case FieldType.boolean:\n          if (field.name in uniqueFactorNamesToWideIndex) {\n            // TODO error?\n          } else {\n            uniqueFactorNamesToWideIndex[field.name] = fieldIndex;\n            uniqueLabelKeys[field.name] = true;\n          }\n          break;\n        case FieldType.time:\n          if (!timeField) {\n            timeField = field;\n            break;\n          }\n        default:\n          if (field.name in uniqueValueNamesToType) {\n            const type = uniqueValueNamesToType[field.name];\n\n            if (field.type !== type) {\n              // TODO error?\n              continue;\n            }\n          } else {\n            uniqueValueNamesToType[field.name] = field.type;\n            uniqueValueNames.push(field.name);\n          }\n\n          const tKey = JSON.stringify(field.labels);\n          const wideIndices = labelKeyToWideIndices[tKey];\n\n          if (wideIndices !== undefined) {\n            wideIndices.push(fieldIndex);\n          } else {\n            labelKeyToWideIndices[tKey] = [fieldIndex];\n          }\n\n          if (field.labels != null) {\n            for (const labelKey in field.labels) {\n              uniqueLabelKeys[labelKey] = true;\n            }\n          }\n      }\n    }\n\n    if (!timeField) {\n      continue;\n    }\n\n    type TimeWideRowIndex = {\n      time: any;\n      wideRowIndex: number;\n    };\n    const sortedTimeRowIndices: TimeWideRowIndex[] = [];\n    const sortedUniqueLabelKeys: string[] = [];\n    const uniqueFactorNames: string[] = [];\n    const uniqueFactorNamesWithWideIndices: string[] = [];\n\n    for (let wideRowIndex = 0; wideRowIndex < frame.length; wideRowIndex++) {\n      sortedTimeRowIndices.push({ time: timeField.values.get(wideRowIndex), wideRowIndex: wideRowIndex });\n    }\n\n    for (const labelKeys in labelKeyToWideIndices) {\n      sortedUniqueLabelKeys.push(labelKeys);\n    }\n    for (const labelKey in uniqueLabelKeys) {\n      uniqueFactorNames.push(labelKey);\n    }\n    for (const name in uniqueFactorNamesToWideIndex) {\n      uniqueFactorNamesWithWideIndices.push(name);\n    }\n\n    sortedTimeRowIndices.sort((a, b) => a.time - b.time);\n    sortedUniqueLabelKeys.sort();\n    uniqueFactorNames.sort();\n    uniqueValueNames.sort();\n\n    const longFrame = new MutableDataFrame({\n      ...frame,\n      meta: { ...frame.meta, type: DataFrameType.TimeSeriesLong },\n      fields: [{ name: timeField.name, type: timeField.type }],\n    });\n\n    for (const name of uniqueValueNames) {\n      longFrame.addField({ name: name, type: uniqueValueNamesToType[name] });\n    }\n\n    for (const name of uniqueFactorNames) {\n      longFrame.addField({ name: name, type: FieldType.string });\n    }\n\n    for (const timeWideRowIndex of sortedTimeRowIndices) {\n      const { time, wideRowIndex } = timeWideRowIndex;\n\n      for (const labelKeys of sortedUniqueLabelKeys) {\n        const rowValues: Record<string, any> = {};\n\n        for (const name of uniqueFactorNamesWithWideIndices) {\n          rowValues[name] = frame.fields[uniqueFactorNamesToWideIndex[name]].values.get(wideRowIndex);\n        }\n\n        let index = 0;\n\n        for (const wideFieldIndex of labelKeyToWideIndices[labelKeys]) {\n          const wideField = frame.fields[wideFieldIndex];\n\n          if (index++ === 0 && wideField.labels != null) {\n            for (const labelKey in wideField.labels) {\n              rowValues[labelKey] = wideField.labels[labelKey];\n            }\n          }\n\n          rowValues[wideField.name] = wideField.values.get(wideRowIndex);\n        }\n\n        rowValues[timeField.name] = time;\n        longFrame.add(rowValues);\n      }\n    }\n\n    result.push(longFrame);\n  }\n\n  return result;\n}\n\nexport const prepareTimeSeriesTransformer: SynchronousDataTransformerInfo<PrepareTimeSeriesOptions> = {\n  id: DataTransformerID.prepareTimeSeries,\n  name: 'Prepare time series',\n  description: `Will stretch data frames from the wide format into the long format. This is really helpful to be able to keep backwards compatibility for panels not supporting the new wide format.`,\n  defaultOptions: {},\n\n  operator: (options) => (source) =>\n    source.pipe(map((data) => prepareTimeSeriesTransformer.transformer(options)(data))),\n\n  transformer: (options: PrepareTimeSeriesOptions) => {\n    const format = options?.format ?? timeSeriesFormat.TimeSeriesWide;\n    if (format === timeSeriesFormat.TimeSeriesMany) {\n      return toTimeSeriesMany;\n    } else if (format === timeSeriesFormat.TimeSeriesLong) {\n      return toTimeSeriesLong;\n    }\n\n    return (data: DataFrame[]) => {\n      // Join by the first frame\n      const frame = outerJoinDataFrames({\n        frames: data,\n        joinBy: fieldMatchers.get(FieldMatcherID.firstTimeField).get({}),\n        keepOriginIndices: true,\n      });\n      return frame ? [frame] : [];\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}