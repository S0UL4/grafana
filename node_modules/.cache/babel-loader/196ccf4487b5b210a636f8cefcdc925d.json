{"ast":null,"code":"import { mergeMap, from } from 'rxjs';\nimport { ArrayVector, DataTransformerID, FieldType } from '@grafana/data';\nimport { createGeometryCollection, createLineBetween } from 'app/features/geo/format/utils';\nimport { getGeometryField, getLocationMatchers } from 'app/features/geo/utils/location';\nimport { SpatialOperation, SpatialAction } from './models.gen';\nimport { doGeomeryCalculation, toLineString } from './utils';\nexport const spatialTransformer = {\n  id: DataTransformerID.spatial,\n  name: 'Spatial operations',\n  description: 'Apply spatial operations to query results',\n  defaultOptions: {},\n  operator: options => source => source.pipe(mergeMap(data => from(doSetGeometry(data, options))))\n};\nexport function isLineBuilderOption(options) {\n  var _options$modify;\n\n  return options.action === SpatialAction.Modify && ((_options$modify = options.modify) === null || _options$modify === void 0 ? void 0 : _options$modify.op) === SpatialOperation.LineBuilder;\n}\n\nasync function doSetGeometry(frames, options) {\n  const location = await getLocationMatchers(options.source);\n\n  if (isLineBuilderOption(options)) {\n    var _options$modify2;\n\n    const targetLocation = await getLocationMatchers((_options$modify2 = options.modify) === null || _options$modify2 === void 0 ? void 0 : _options$modify2.target);\n    return frames.map(frame => {\n      const src = getGeometryField(frame, location);\n      const target = getGeometryField(frame, targetLocation);\n\n      if (src.field && target.field) {\n        const fields = [...frame.fields];\n        const line = createLineBetween(src.field, target.field);\n        const first = fields[0];\n\n        if (first.type === FieldType.geo && first !== src.field && first !== target.field) {\n          fields[0] = createGeometryCollection(first, line); //\n        } else {\n          fields.unshift(line);\n        }\n\n        return Object.assign({}, frame, {\n          fields\n        });\n      }\n\n      return frame;\n    });\n  }\n\n  return frames.map(frame => {\n    var _options$modify3;\n\n    let info = getGeometryField(frame, location);\n\n    if (info.field) {\n      if (options.action === SpatialAction.Modify) {\n        switch ((_options$modify3 = options.modify) === null || _options$modify3 === void 0 ? void 0 : _options$modify3.op) {\n          // SOON: extent, convex hull, etc\n          case SpatialOperation.AsLine:\n            let name = info.field.name;\n\n            if (!name || name === 'Point') {\n              name = 'Line';\n            }\n\n            return Object.assign({}, frame, {\n              length: 1,\n              fields: [Object.assign({}, info.field, {\n                name,\n                type: FieldType.geo,\n                values: new ArrayVector([toLineString(info.field)])\n              })]\n            });\n        }\n\n        return frame;\n      }\n\n      const fields = info.derived ? [info.field, ...frame.fields] : frame.fields.slice(0);\n\n      if (options.action === SpatialAction.Calculate) {\n        var _options$calculate;\n\n        fields.push(doGeomeryCalculation(info.field, (_options$calculate = options.calculate) !== null && _options$calculate !== void 0 ? _options$calculate : {}));\n        info.derived = true;\n      }\n\n      if (info.derived) {\n        return Object.assign({}, frame, {\n          fields\n        });\n      }\n    }\n\n    return frame;\n  });\n}","map":{"version":3,"names":["mergeMap","from","ArrayVector","DataTransformerID","FieldType","createGeometryCollection","createLineBetween","getGeometryField","getLocationMatchers","SpatialOperation","SpatialAction","doGeomeryCalculation","toLineString","spatialTransformer","id","spatial","name","description","defaultOptions","operator","options","source","pipe","data","doSetGeometry","isLineBuilderOption","action","Modify","modify","op","LineBuilder","frames","location","targetLocation","target","map","frame","src","field","fields","line","first","type","geo","unshift","info","AsLine","length","values","derived","slice","Calculate","push","calculate"],"sources":["/home/soula/grafana/public/app/features/transformers/spatial/spatialTransformer.ts"],"sourcesContent":["import { mergeMap, from } from 'rxjs';\n\nimport { ArrayVector, DataFrame, DataTransformerID, DataTransformerInfo, FieldType } from '@grafana/data';\nimport { createGeometryCollection, createLineBetween } from 'app/features/geo/format/utils';\nimport { getGeometryField, getLocationMatchers } from 'app/features/geo/utils/location';\n\nimport { SpatialOperation, SpatialAction, SpatialTransformOptions } from './models.gen';\nimport { doGeomeryCalculation, toLineString } from './utils';\n\nexport const spatialTransformer: DataTransformerInfo<SpatialTransformOptions> = {\n  id: DataTransformerID.spatial,\n  name: 'Spatial operations',\n  description: 'Apply spatial operations to query results',\n  defaultOptions: {},\n\n  operator: (options) => (source) => source.pipe(mergeMap((data) => from(doSetGeometry(data, options)))),\n};\n\nexport function isLineBuilderOption(options: SpatialTransformOptions): boolean {\n  return options.action === SpatialAction.Modify && options.modify?.op === SpatialOperation.LineBuilder;\n}\n\nasync function doSetGeometry(frames: DataFrame[], options: SpatialTransformOptions): Promise<DataFrame[]> {\n  const location = await getLocationMatchers(options.source);\n  if (isLineBuilderOption(options)) {\n    const targetLocation = await getLocationMatchers(options.modify?.target);\n    return frames.map((frame) => {\n      const src = getGeometryField(frame, location);\n      const target = getGeometryField(frame, targetLocation);\n      if (src.field && target.field) {\n        const fields = [...frame.fields];\n        const line = createLineBetween(src.field, target.field);\n        const first = fields[0];\n        if (first.type === FieldType.geo && first !== src.field && first !== target.field) {\n          fields[0] = createGeometryCollection(first, line); //\n        } else {\n          fields.unshift(line);\n        }\n        return {\n          ...frame,\n          fields,\n        };\n      }\n      return frame;\n    });\n  }\n\n  return frames.map((frame) => {\n    let info = getGeometryField(frame, location);\n    if (info.field) {\n      if (options.action === SpatialAction.Modify) {\n        switch (options.modify?.op) {\n          // SOON: extent, convex hull, etc\n          case SpatialOperation.AsLine:\n            let name = info.field.name;\n            if (!name || name === 'Point') {\n              name = 'Line';\n            }\n            return {\n              ...frame,\n              length: 1,\n              fields: [\n                {\n                  ...info.field,\n                  name,\n                  type: FieldType.geo,\n                  values: new ArrayVector([toLineString(info.field)]),\n                },\n              ],\n            };\n        }\n        return frame;\n      }\n\n      const fields = info.derived ? [info.field, ...frame.fields] : frame.fields.slice(0);\n      if (options.action === SpatialAction.Calculate) {\n        fields.push(doGeomeryCalculation(info.field, options.calculate ?? {}));\n        info.derived = true;\n      }\n\n      if (info.derived) {\n        return {\n          ...frame,\n          fields,\n        };\n      }\n    }\n    return frame;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}