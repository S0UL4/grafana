{"ast":null,"code":"import React, { memo, useMemo, useCallback } from 'react';\nimport { FieldMatcherID, fieldMatchers, FieldType } from '@grafana/data';\nimport { Select } from '../Select/Select';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const FieldTypeMatcherEditor = /*#__PURE__*/memo(props => {\n  const {\n    data,\n    options,\n    onChange: onChangeFromProps,\n    id\n  } = props;\n  const counts = useFieldCounts(data);\n  const selectOptions = useSelectOptions(counts, options);\n  const onChange = useCallback(selection => {\n    return onChangeFromProps(selection.value);\n  }, [onChangeFromProps]);\n  const selectedOption = selectOptions.find(v => v.value === options);\n  return /*#__PURE__*/_jsx(Select, {\n    inputId: id,\n    value: selectedOption,\n    options: selectOptions,\n    onChange: onChange\n  });\n});\nFieldTypeMatcherEditor.displayName = 'FieldTypeMatcherEditor';\nconst allTypes = [{\n  value: FieldType.number,\n  label: 'Numeric'\n}, {\n  value: FieldType.string,\n  label: 'String'\n}, {\n  value: FieldType.time,\n  label: 'Time'\n}, {\n  value: FieldType.boolean,\n  label: 'Boolean'\n}, {\n  value: FieldType.trace,\n  label: 'Traces'\n}, {\n  value: FieldType.other,\n  label: 'Other'\n}];\n\nconst useFieldCounts = data => {\n  return useMemo(() => {\n    const counts = new Map();\n\n    for (const t of allTypes) {\n      counts.set(t.value, 0);\n    }\n\n    for (const frame of data) {\n      for (const field of frame.fields) {\n        const key = field.type || FieldType.other;\n        let v = counts.get(key);\n\n        if (!v) {\n          v = 0;\n        }\n\n        counts.set(key, v + 1);\n      }\n    }\n\n    return counts;\n  }, [data]);\n};\n\nconst useSelectOptions = (counts, opt) => {\n  return useMemo(() => {\n    let found = false;\n    const options = [];\n\n    for (const t of allTypes) {\n      const count = counts.get(t.value);\n      const match = opt === t.value;\n\n      if (count || match) {\n        options.push(Object.assign({}, t, {\n          label: `${t.label} (${counts.get(t.value)})`\n        }));\n      }\n\n      if (match) {\n        found = true;\n      }\n    }\n\n    if (opt && !found) {\n      options.push({\n        value: opt,\n        label: `${opt} (No matches)`\n      });\n    }\n\n    return options;\n  }, [counts, opt]);\n};\n\nexport const fieldTypeMatcherItem = {\n  id: FieldMatcherID.byType,\n  component: FieldTypeMatcherEditor,\n  matcher: fieldMatchers.get(FieldMatcherID.byType),\n  name: 'Fields with type',\n  description: 'Set properties for fields of a specific type (number, string, boolean)',\n  optionsToLabel: options => options\n};","map":{"version":3,"names":["React","memo","useMemo","useCallback","FieldMatcherID","fieldMatchers","FieldType","Select","FieldTypeMatcherEditor","props","data","options","onChange","onChangeFromProps","id","counts","useFieldCounts","selectOptions","useSelectOptions","selection","value","selectedOption","find","v","displayName","allTypes","number","label","string","time","boolean","trace","other","Map","t","set","frame","field","fields","key","type","get","opt","found","count","match","push","fieldTypeMatcherItem","byType","component","matcher","name","description","optionsToLabel"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/MatchersUI/FieldTypeMatcherEditor.tsx"],"sourcesContent":["import React, { memo, useMemo, useCallback } from 'react';\n\nimport { FieldMatcherID, fieldMatchers, SelectableValue, FieldType, DataFrame } from '@grafana/data';\n\nimport { Select } from '../Select/Select';\n\nimport { MatcherUIProps, FieldMatcherUIRegistryItem } from './types';\n\nexport const FieldTypeMatcherEditor = memo<MatcherUIProps<string>>((props) => {\n  const { data, options, onChange: onChangeFromProps, id } = props;\n  const counts = useFieldCounts(data);\n  const selectOptions = useSelectOptions(counts, options);\n\n  const onChange = useCallback(\n    (selection: SelectableValue<string>) => {\n      return onChangeFromProps(selection.value!);\n    },\n    [onChangeFromProps]\n  );\n\n  const selectedOption = selectOptions.find((v) => v.value === options);\n  return <Select inputId={id} value={selectedOption} options={selectOptions} onChange={onChange} />;\n});\nFieldTypeMatcherEditor.displayName = 'FieldTypeMatcherEditor';\n\nconst allTypes: Array<SelectableValue<FieldType>> = [\n  { value: FieldType.number, label: 'Numeric' },\n  { value: FieldType.string, label: 'String' },\n  { value: FieldType.time, label: 'Time' },\n  { value: FieldType.boolean, label: 'Boolean' },\n  { value: FieldType.trace, label: 'Traces' },\n  { value: FieldType.other, label: 'Other' },\n];\n\nconst useFieldCounts = (data: DataFrame[]): Map<FieldType, number> => {\n  return useMemo(() => {\n    const counts: Map<FieldType, number> = new Map();\n    for (const t of allTypes) {\n      counts.set(t.value!, 0);\n    }\n    for (const frame of data) {\n      for (const field of frame.fields) {\n        const key = field.type || FieldType.other;\n        let v = counts.get(key);\n        if (!v) {\n          v = 0;\n        }\n        counts.set(key, v + 1);\n      }\n    }\n    return counts;\n  }, [data]);\n};\n\nconst useSelectOptions = (counts: Map<string, number>, opt?: string): Array<SelectableValue<string>> => {\n  return useMemo(() => {\n    let found = false;\n    const options: Array<SelectableValue<string>> = [];\n    for (const t of allTypes) {\n      const count = counts.get(t.value!);\n      const match = opt === t.value;\n      if (count || match) {\n        options.push({\n          ...t,\n          label: `${t.label} (${counts.get(t.value!)})`,\n        });\n      }\n      if (match) {\n        found = true;\n      }\n    }\n    if (opt && !found) {\n      options.push({\n        value: opt,\n        label: `${opt} (No matches)`,\n      });\n    }\n    return options;\n  }, [counts, opt]);\n};\n\nexport const fieldTypeMatcherItem: FieldMatcherUIRegistryItem<string> = {\n  id: FieldMatcherID.byType,\n  component: FieldTypeMatcherEditor,\n  matcher: fieldMatchers.get(FieldMatcherID.byType),\n  name: 'Fields with type',\n  description: 'Set properties for fields of a specific type (number, string, boolean)',\n  optionsToLabel: (options) => options,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}