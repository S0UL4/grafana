{"ast":null,"code":"import { useCallback, useState } from 'react';\n\n/**\n * Children state means whether spans are collapsed or not. Also provides some functions to manipulate that state.\n */\nexport function useChildrenState() {\n  const [childrenHiddenIDs, setChildrenHiddenIDs] = useState(new Set());\n  const expandOne = useCallback(function expandOne(spans) {\n    if (childrenHiddenIDs.size === 0) {\n      return;\n    }\n\n    let prevExpandedDepth = -1;\n    let expandNextHiddenSpan = true;\n    const newChildrenHiddenIDs = spans.reduce((res, s) => {\n      if (s.depth <= prevExpandedDepth) {\n        expandNextHiddenSpan = true;\n      }\n\n      if (expandNextHiddenSpan && res.has(s.spanID)) {\n        res.delete(s.spanID);\n        expandNextHiddenSpan = false;\n        prevExpandedDepth = s.depth;\n      }\n\n      return res;\n    }, new Set(childrenHiddenIDs));\n    setChildrenHiddenIDs(newChildrenHiddenIDs);\n  }, [childrenHiddenIDs]);\n  const collapseOne = useCallback(function collapseOne(spans) {\n    if (shouldDisableCollapse(spans, childrenHiddenIDs)) {\n      return;\n    }\n\n    let nearestCollapsedAncestor;\n    const newChildrenHiddenIDs = spans.reduce((res, curSpan) => {\n      if (nearestCollapsedAncestor && curSpan.depth <= nearestCollapsedAncestor.depth) {\n        res.add(nearestCollapsedAncestor.spanID);\n\n        if (curSpan.hasChildren) {\n          nearestCollapsedAncestor = curSpan;\n        }\n      } else if (curSpan.hasChildren && !res.has(curSpan.spanID)) {\n        nearestCollapsedAncestor = curSpan;\n      }\n\n      return res;\n    }, new Set(childrenHiddenIDs)); // The last one\n\n    if (nearestCollapsedAncestor) {\n      newChildrenHiddenIDs.add(nearestCollapsedAncestor.spanID);\n    }\n\n    setChildrenHiddenIDs(newChildrenHiddenIDs);\n  }, [childrenHiddenIDs]);\n  const expandAll = useCallback(function expandAll() {\n    setChildrenHiddenIDs(new Set());\n  }, []);\n  const collapseAll = useCallback(function collapseAll(spans) {\n    if (shouldDisableCollapse(spans, childrenHiddenIDs)) {\n      return;\n    }\n\n    const newChildrenHiddenIDs = spans.reduce((res, s) => {\n      if (s.hasChildren) {\n        res.add(s.spanID);\n      }\n\n      return res;\n    }, new Set());\n    setChildrenHiddenIDs(newChildrenHiddenIDs);\n  }, [childrenHiddenIDs]);\n  const childrenToggle = useCallback(function childrenToggle(spanID) {\n    const newChildrenHiddenIDs = new Set(childrenHiddenIDs);\n\n    if (childrenHiddenIDs.has(spanID)) {\n      newChildrenHiddenIDs.delete(spanID);\n    } else {\n      newChildrenHiddenIDs.add(spanID);\n    }\n\n    setChildrenHiddenIDs(newChildrenHiddenIDs);\n  }, [childrenHiddenIDs]);\n  return {\n    childrenHiddenIDs,\n    expandOne,\n    collapseOne,\n    expandAll,\n    collapseAll,\n    childrenToggle\n  };\n}\n\nfunction shouldDisableCollapse(allSpans, hiddenSpansIds) {\n  const allParentSpans = allSpans.filter(s => s.hasChildren);\n  return allParentSpans.length === hiddenSpansIds.size;\n}","map":{"version":3,"names":["useCallback","useState","useChildrenState","childrenHiddenIDs","setChildrenHiddenIDs","Set","expandOne","spans","size","prevExpandedDepth","expandNextHiddenSpan","newChildrenHiddenIDs","reduce","res","s","depth","has","spanID","delete","collapseOne","shouldDisableCollapse","nearestCollapsedAncestor","curSpan","add","hasChildren","expandAll","collapseAll","childrenToggle","allSpans","hiddenSpansIds","allParentSpans","filter","length"],"sources":["/home/soula/grafana/public/app/features/explore/TraceView/useChildrenState.ts"],"sourcesContent":["import { useCallback, useState } from 'react';\n\nimport { TraceSpan } from '@jaegertracing/jaeger-ui-components';\n\n/**\n * Children state means whether spans are collapsed or not. Also provides some functions to manipulate that state.\n */\nexport function useChildrenState() {\n  const [childrenHiddenIDs, setChildrenHiddenIDs] = useState(new Set<string>());\n\n  const expandOne = useCallback(\n    function expandOne(spans: TraceSpan[]) {\n      if (childrenHiddenIDs.size === 0) {\n        return;\n      }\n      let prevExpandedDepth = -1;\n      let expandNextHiddenSpan = true;\n      const newChildrenHiddenIDs = spans.reduce((res, s) => {\n        if (s.depth <= prevExpandedDepth) {\n          expandNextHiddenSpan = true;\n        }\n        if (expandNextHiddenSpan && res.has(s.spanID)) {\n          res.delete(s.spanID);\n          expandNextHiddenSpan = false;\n          prevExpandedDepth = s.depth;\n        }\n        return res;\n      }, new Set(childrenHiddenIDs));\n      setChildrenHiddenIDs(newChildrenHiddenIDs);\n    },\n    [childrenHiddenIDs]\n  );\n\n  const collapseOne = useCallback(\n    function collapseOne(spans: TraceSpan[]) {\n      if (shouldDisableCollapse(spans, childrenHiddenIDs)) {\n        return;\n      }\n      let nearestCollapsedAncestor: TraceSpan | undefined;\n      const newChildrenHiddenIDs = spans.reduce((res, curSpan) => {\n        if (nearestCollapsedAncestor && curSpan.depth <= nearestCollapsedAncestor.depth) {\n          res.add(nearestCollapsedAncestor.spanID);\n          if (curSpan.hasChildren) {\n            nearestCollapsedAncestor = curSpan;\n          }\n        } else if (curSpan.hasChildren && !res.has(curSpan.spanID)) {\n          nearestCollapsedAncestor = curSpan;\n        }\n        return res;\n      }, new Set(childrenHiddenIDs));\n      // The last one\n      if (nearestCollapsedAncestor) {\n        newChildrenHiddenIDs.add(nearestCollapsedAncestor.spanID);\n      }\n      setChildrenHiddenIDs(newChildrenHiddenIDs);\n    },\n    [childrenHiddenIDs]\n  );\n\n  const expandAll = useCallback(function expandAll() {\n    setChildrenHiddenIDs(new Set<string>());\n  }, []);\n\n  const collapseAll = useCallback(\n    function collapseAll(spans: TraceSpan[]) {\n      if (shouldDisableCollapse(spans, childrenHiddenIDs)) {\n        return;\n      }\n      const newChildrenHiddenIDs = spans.reduce((res, s) => {\n        if (s.hasChildren) {\n          res.add(s.spanID);\n        }\n        return res;\n      }, new Set<string>());\n\n      setChildrenHiddenIDs(newChildrenHiddenIDs);\n    },\n    [childrenHiddenIDs]\n  );\n\n  const childrenToggle = useCallback(\n    function childrenToggle(spanID: string) {\n      const newChildrenHiddenIDs = new Set(childrenHiddenIDs);\n      if (childrenHiddenIDs.has(spanID)) {\n        newChildrenHiddenIDs.delete(spanID);\n      } else {\n        newChildrenHiddenIDs.add(spanID);\n      }\n      setChildrenHiddenIDs(newChildrenHiddenIDs);\n    },\n    [childrenHiddenIDs]\n  );\n\n  return {\n    childrenHiddenIDs,\n    expandOne,\n    collapseOne,\n    expandAll,\n    collapseAll,\n    childrenToggle,\n  };\n}\n\nfunction shouldDisableCollapse(allSpans: TraceSpan[], hiddenSpansIds: Set<string>) {\n  const allParentSpans = allSpans.filter((s) => s.hasChildren);\n  return allParentSpans.length === hiddenSpansIds.size;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}