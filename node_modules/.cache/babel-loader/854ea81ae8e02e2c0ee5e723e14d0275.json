{"ast":null,"code":"import { defaults } from 'lodash';\nimport { Observable } from 'rxjs';\nimport { FieldType, CircularDataFrame, CSVReader, LoadingState } from '@grafana/data';\nimport { liveTimer } from 'app/features/dashboard/dashgrid/liveTimer';\nimport { StreamingDataFrame } from 'app/features/live/data/StreamingDataFrame';\nimport { getRandomLine } from './LogIpsum';\nexport const defaultStreamQuery = {\n  type: 'signal',\n  speed: 250,\n  // ms\n  spread: 3.5,\n  noise: 2.2,\n  bands: 1\n};\nexport function runStream(target, req) {\n  const query = defaults(target.stream, defaultStreamQuery);\n\n  if ('signal' === query.type) {\n    return runSignalStream(target, query, req);\n  }\n\n  if ('logs' === query.type) {\n    return runLogsStream(target, query, req);\n  }\n\n  if ('fetch' === query.type) {\n    return runFetchStream(target, query, req);\n  }\n\n  throw new Error(`Unknown Stream Type: ${query.type}`);\n}\nexport function runSignalStream(target, query, req) {\n  return new Observable(subscriber => {\n    var _target$alias;\n\n    const streamId = `signal-${req.panelId}-${target.refId}`;\n    const maxDataPoints = req.maxDataPoints || 1000;\n    const schema = {\n      refId: target.refId,\n      fields: [{\n        name: 'time',\n        type: FieldType.time\n      }, {\n        name: (_target$alias = target.alias) !== null && _target$alias !== void 0 ? _target$alias : 'value',\n        type: FieldType.number\n      }]\n    };\n    const {\n      spread,\n      speed,\n      bands = 0,\n      noise\n    } = query;\n\n    for (let i = 0; i < bands; i++) {\n      const suffix = bands > 1 ? ` ${i + 1}` : '';\n      schema.fields.push({\n        name: 'Min' + suffix,\n        type: FieldType.number\n      });\n      schema.fields.push({\n        name: 'Max' + suffix,\n        type: FieldType.number\n      });\n    }\n\n    const frame = StreamingDataFrame.fromDataFrameJSON({\n      schema\n    }, {\n      maxLength: maxDataPoints\n    });\n    let value = Math.random() * 100;\n    let timeoutId = null;\n    let lastSent = -1;\n\n    const addNextRow = time => {\n      value += (Math.random() - 0.5) * spread;\n      const data = {\n        values: [[time], [value]]\n      };\n      let min = value;\n      let max = value;\n\n      for (let i = 0; i < bands; i++) {\n        min = min - Math.random() * noise;\n        max = max + Math.random() * noise;\n        data.values.push([min]);\n        data.values.push([max]);\n      }\n\n      const event = {\n        data\n      };\n      return frame.push(event);\n    }; // Fill the buffer on init\n\n\n    if (true) {\n      let time = Date.now() - maxDataPoints * speed;\n\n      for (let i = 0; i < maxDataPoints; i++) {\n        addNextRow(time);\n        time += speed;\n      }\n    }\n\n    const pushNextEvent = () => {\n      addNextRow(Date.now());\n      const elapsed = liveTimer.lastUpdate - lastSent;\n\n      if (elapsed > 1000 || liveTimer.ok) {\n        subscriber.next({\n          data: [frame],\n          key: streamId,\n          state: LoadingState.Streaming\n        });\n        lastSent = liveTimer.lastUpdate;\n      }\n\n      timeoutId = setTimeout(pushNextEvent, speed);\n    }; // Send first event in 5ms\n\n\n    setTimeout(pushNextEvent, 5);\n    return () => {\n      console.log('unsubscribing to stream ' + streamId);\n      clearTimeout(timeoutId);\n    };\n  });\n}\nexport function runLogsStream(target, query, req) {\n  return new Observable(subscriber => {\n    const streamId = `logs-${req.panelId}-${target.refId}`;\n    const maxDataPoints = req.maxDataPoints || 1000;\n    const data = new CircularDataFrame({\n      append: 'tail',\n      capacity: maxDataPoints\n    });\n    data.refId = target.refId;\n    data.name = target.alias || 'Logs ' + target.refId;\n    data.addField({\n      name: 'line',\n      type: FieldType.string\n    });\n    data.addField({\n      name: 'time',\n      type: FieldType.time\n    });\n    data.meta = {\n      preferredVisualisationType: 'logs'\n    };\n    const {\n      speed\n    } = query;\n    let timeoutId = null;\n\n    const pushNextEvent = () => {\n      data.fields[0].values.add(Date.now());\n      data.fields[1].values.add(getRandomLine());\n      subscriber.next({\n        data: [data],\n        key: streamId\n      });\n      timeoutId = setTimeout(pushNextEvent, speed);\n    }; // Send first event in 5ms\n\n\n    setTimeout(pushNextEvent, 5);\n    return () => {\n      console.log('unsubscribing to stream ' + streamId);\n      clearTimeout(timeoutId);\n    };\n  });\n}\nexport function runFetchStream(target, query, req) {\n  return new Observable(subscriber => {\n    const streamId = `fetch-${req.panelId}-${target.refId}`;\n    const maxDataPoints = req.maxDataPoints || 1000;\n    let data = new CircularDataFrame({\n      append: 'tail',\n      capacity: maxDataPoints\n    });\n    data.refId = target.refId;\n    data.name = target.alias || 'Fetch ' + target.refId;\n    let reader;\n    const csv = new CSVReader({\n      callback: {\n        onHeader: fields => {\n          // Clear any existing fields\n          if (data.fields.length) {\n            data = new CircularDataFrame({\n              append: 'tail',\n              capacity: maxDataPoints\n            });\n            data.refId = target.refId;\n            data.name = 'Fetch ' + target.refId;\n          }\n\n          for (const field of fields) {\n            data.addField(field);\n          }\n        },\n        onRow: row => {\n          data.add(row);\n        }\n      }\n    });\n\n    const processChunk = value => {\n      if (value.value) {\n        const text = new TextDecoder().decode(value.value);\n        csv.readCSV(text);\n      }\n\n      subscriber.next({\n        data: [data],\n        key: streamId,\n        state: value.done ? LoadingState.Done : LoadingState.Streaming\n      });\n\n      if (value.done) {\n        console.log('Finished stream');\n        subscriber.complete(); // necessary?\n\n        return;\n      }\n\n      return reader.read().then(processChunk);\n    };\n\n    if (!query.url) {\n      throw new Error('query.url is not defined');\n    }\n\n    fetch(new Request(query.url)).then(response => {\n      if (response.body) {\n        reader = response.body.getReader();\n        reader.read().then(processChunk);\n      }\n    });\n    return () => {\n      // Cancel fetch?\n      console.log('unsubscribing to stream ' + streamId);\n    };\n  });\n}","map":{"version":3,"names":["defaults","Observable","FieldType","CircularDataFrame","CSVReader","LoadingState","liveTimer","StreamingDataFrame","getRandomLine","defaultStreamQuery","type","speed","spread","noise","bands","runStream","target","req","query","stream","runSignalStream","runLogsStream","runFetchStream","Error","subscriber","streamId","panelId","refId","maxDataPoints","schema","fields","name","time","alias","number","i","suffix","push","frame","fromDataFrameJSON","maxLength","value","Math","random","timeoutId","lastSent","addNextRow","data","values","min","max","event","Date","now","pushNextEvent","elapsed","lastUpdate","ok","next","key","state","Streaming","setTimeout","console","log","clearTimeout","append","capacity","addField","string","meta","preferredVisualisationType","add","reader","csv","callback","onHeader","length","field","onRow","row","processChunk","text","TextDecoder","decode","readCSV","done","Done","complete","read","then","url","fetch","Request","response","body","getReader"],"sources":["/home/soula/grafana/public/app/plugins/datasource/testdata/runStreams.ts"],"sourcesContent":["import { defaults } from 'lodash';\nimport { Observable } from 'rxjs';\n\nimport {\n  DataQueryRequest,\n  DataQueryResponse,\n  FieldType,\n  CircularDataFrame,\n  CSVReader,\n  Field,\n  LoadingState,\n  DataFrameSchema,\n  DataFrameData,\n} from '@grafana/data';\nimport { liveTimer } from 'app/features/dashboard/dashgrid/liveTimer';\nimport { StreamingDataFrame } from 'app/features/live/data/StreamingDataFrame';\n\nimport { getRandomLine } from './LogIpsum';\nimport { TestDataQuery, StreamingQuery } from './types';\n\nexport const defaultStreamQuery: StreamingQuery = {\n  type: 'signal',\n  speed: 250, // ms\n  spread: 3.5,\n  noise: 2.2,\n  bands: 1,\n};\n\nexport function runStream(target: TestDataQuery, req: DataQueryRequest<TestDataQuery>): Observable<DataQueryResponse> {\n  const query = defaults(target.stream, defaultStreamQuery);\n  if ('signal' === query.type) {\n    return runSignalStream(target, query, req);\n  }\n  if ('logs' === query.type) {\n    return runLogsStream(target, query, req);\n  }\n  if ('fetch' === query.type) {\n    return runFetchStream(target, query, req);\n  }\n  throw new Error(`Unknown Stream Type: ${query.type}`);\n}\n\nexport function runSignalStream(\n  target: TestDataQuery,\n  query: StreamingQuery,\n  req: DataQueryRequest<TestDataQuery>\n): Observable<DataQueryResponse> {\n  return new Observable<DataQueryResponse>((subscriber) => {\n    const streamId = `signal-${req.panelId}-${target.refId}`;\n    const maxDataPoints = req.maxDataPoints || 1000;\n\n    const schema: DataFrameSchema = {\n      refId: target.refId,\n      fields: [\n        { name: 'time', type: FieldType.time },\n        { name: target.alias ?? 'value', type: FieldType.number },\n      ],\n    };\n\n    const { spread, speed, bands = 0, noise } = query;\n    for (let i = 0; i < bands; i++) {\n      const suffix = bands > 1 ? ` ${i + 1}` : '';\n      schema.fields.push({ name: 'Min' + suffix, type: FieldType.number });\n      schema.fields.push({ name: 'Max' + suffix, type: FieldType.number });\n    }\n\n    const frame = StreamingDataFrame.fromDataFrameJSON({ schema }, { maxLength: maxDataPoints });\n\n    let value = Math.random() * 100;\n    let timeoutId: any = null;\n    let lastSent = -1;\n\n    const addNextRow = (time: number) => {\n      value += (Math.random() - 0.5) * spread;\n\n      const data: DataFrameData = {\n        values: [[time], [value]],\n      };\n\n      let min = value;\n      let max = value;\n\n      for (let i = 0; i < bands; i++) {\n        min = min - Math.random() * noise;\n        max = max + Math.random() * noise;\n\n        data.values.push([min]);\n        data.values.push([max]);\n      }\n\n      const event = { data };\n      return frame.push(event);\n    };\n\n    // Fill the buffer on init\n    if (true) {\n      let time = Date.now() - maxDataPoints * speed;\n      for (let i = 0; i < maxDataPoints; i++) {\n        addNextRow(time);\n        time += speed;\n      }\n    }\n\n    const pushNextEvent = () => {\n      addNextRow(Date.now());\n\n      const elapsed = liveTimer.lastUpdate - lastSent;\n      if (elapsed > 1000 || liveTimer.ok) {\n        subscriber.next({\n          data: [frame],\n          key: streamId,\n          state: LoadingState.Streaming,\n        });\n        lastSent = liveTimer.lastUpdate;\n      }\n\n      timeoutId = setTimeout(pushNextEvent, speed);\n    };\n\n    // Send first event in 5ms\n    setTimeout(pushNextEvent, 5);\n\n    return () => {\n      console.log('unsubscribing to stream ' + streamId);\n      clearTimeout(timeoutId);\n    };\n  });\n}\n\nexport function runLogsStream(\n  target: TestDataQuery,\n  query: StreamingQuery,\n  req: DataQueryRequest<TestDataQuery>\n): Observable<DataQueryResponse> {\n  return new Observable<DataQueryResponse>((subscriber) => {\n    const streamId = `logs-${req.panelId}-${target.refId}`;\n    const maxDataPoints = req.maxDataPoints || 1000;\n\n    const data = new CircularDataFrame({\n      append: 'tail',\n      capacity: maxDataPoints,\n    });\n    data.refId = target.refId;\n    data.name = target.alias || 'Logs ' + target.refId;\n    data.addField({ name: 'line', type: FieldType.string });\n    data.addField({ name: 'time', type: FieldType.time });\n    data.meta = { preferredVisualisationType: 'logs' };\n\n    const { speed } = query;\n\n    let timeoutId: any = null;\n\n    const pushNextEvent = () => {\n      data.fields[0].values.add(Date.now());\n      data.fields[1].values.add(getRandomLine());\n\n      subscriber.next({\n        data: [data],\n        key: streamId,\n      });\n\n      timeoutId = setTimeout(pushNextEvent, speed);\n    };\n\n    // Send first event in 5ms\n    setTimeout(pushNextEvent, 5);\n\n    return () => {\n      console.log('unsubscribing to stream ' + streamId);\n      clearTimeout(timeoutId);\n    };\n  });\n}\n\nexport function runFetchStream(\n  target: TestDataQuery,\n  query: StreamingQuery,\n  req: DataQueryRequest<TestDataQuery>\n): Observable<DataQueryResponse> {\n  return new Observable<DataQueryResponse>((subscriber) => {\n    const streamId = `fetch-${req.panelId}-${target.refId}`;\n    const maxDataPoints = req.maxDataPoints || 1000;\n\n    let data = new CircularDataFrame({\n      append: 'tail',\n      capacity: maxDataPoints,\n    });\n    data.refId = target.refId;\n    data.name = target.alias || 'Fetch ' + target.refId;\n\n    let reader: ReadableStreamReader<Uint8Array>;\n    const csv = new CSVReader({\n      callback: {\n        onHeader: (fields: Field[]) => {\n          // Clear any existing fields\n          if (data.fields.length) {\n            data = new CircularDataFrame({\n              append: 'tail',\n              capacity: maxDataPoints,\n            });\n            data.refId = target.refId;\n            data.name = 'Fetch ' + target.refId;\n          }\n          for (const field of fields) {\n            data.addField(field);\n          }\n        },\n        onRow: (row: any[]) => {\n          data.add(row);\n        },\n      },\n    });\n\n    const processChunk = (value: ReadableStreamDefaultReadResult<Uint8Array>): any => {\n      if (value.value) {\n        const text = new TextDecoder().decode(value.value);\n        csv.readCSV(text);\n      }\n\n      subscriber.next({\n        data: [data],\n        key: streamId,\n        state: value.done ? LoadingState.Done : LoadingState.Streaming,\n      });\n\n      if (value.done) {\n        console.log('Finished stream');\n        subscriber.complete(); // necessary?\n        return;\n      }\n\n      return reader.read().then(processChunk);\n    };\n\n    if (!query.url) {\n      throw new Error('query.url is not defined');\n    }\n\n    fetch(new Request(query.url)).then((response) => {\n      if (response.body) {\n        reader = response.body.getReader();\n        reader.read().then(processChunk);\n      }\n    });\n\n    return () => {\n      // Cancel fetch?\n      console.log('unsubscribing to stream ' + streamId);\n    };\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}