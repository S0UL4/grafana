{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { isString } from 'lodash';\nimport { FieldType } from '../types/dataFrame';\nimport { makeFieldParser } from '../utils/fieldParser';\nimport { ArrayVector } from '../vector/ArrayVector';\nimport { FunctionalVector } from '../vector/FunctionalVector';\nimport { guessFieldTypeFromValue, guessFieldTypeForField, toDataFrameDTO } from './processDataFrame';\nexport const MISSING_VALUE = undefined; // Treated as connected in new graph panel\n\nexport class MutableDataFrame extends FunctionalVector {\n  constructor(source, creator) {\n    super(); // This creates the underlying storage buffers\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"refId\", void 0);\n\n    _defineProperty(this, \"meta\", void 0);\n\n    _defineProperty(this, \"fields\", []);\n\n    _defineProperty(this, \"first\", new ArrayVector());\n\n    _defineProperty(this, \"creator\", void 0);\n\n    _defineProperty(this, \"parsers\", undefined);\n\n    this.creator = creator ? creator : buffer => {\n      return new ArrayVector(buffer);\n    }; // Copy values from\n\n    if (source) {\n      const {\n        name,\n        refId,\n        meta,\n        fields\n      } = source;\n\n      if (name) {\n        this.name = name;\n      }\n\n      if (refId) {\n        this.refId = refId;\n      }\n\n      if (meta) {\n        this.meta = meta;\n      }\n\n      if (fields) {\n        for (const f of fields) {\n          this.addField(f);\n        }\n      }\n    } // Get Length to show up if you use spread\n\n\n    Object.defineProperty(this, 'length', {\n      enumerable: true,\n      get: () => {\n        return this.first.length;\n      }\n    });\n  } // Defined for Vector interface\n\n\n  get length() {\n    return this.first.length;\n  }\n\n  addFieldFor(value, name) {\n    return this.addField({\n      name: name || '',\n      // Will be filled in\n      type: guessFieldTypeFromValue(value)\n    });\n  }\n\n  addField(f, startLength) {\n    let buffer = undefined;\n\n    if (f.values) {\n      if (Array.isArray(f.values)) {\n        buffer = f.values;\n      } else {\n        buffer = f.values.toArray();\n      }\n    }\n\n    let type = f.type;\n\n    if (!type && ('time' === f.name || 'Time' === f.name)) {\n      type = FieldType.time;\n    } else {\n      if (!type && buffer && buffer.length) {\n        type = guessFieldTypeFromValue(buffer[0]);\n      }\n\n      if (!type) {\n        type = FieldType.other;\n      }\n    } // Make sure it has a name\n\n\n    let name = f.name;\n\n    if (!name) {\n      name = `Field ${this.fields.length + 1}`;\n    }\n\n    const field = Object.assign({}, f, {\n      name,\n      type,\n      config: f.config || {},\n      values: this.creator(buffer)\n    });\n\n    if (type === FieldType.other) {\n      type = guessFieldTypeForField(field);\n\n      if (type) {\n        field.type = type;\n      }\n    }\n\n    this.fields.push(field);\n    this.first = this.fields[0].values; // Make sure the field starts with a given length\n\n    if (startLength) {\n      while (field.values.length < startLength) {\n        field.values.add(MISSING_VALUE);\n      }\n    } else {\n      this.validate();\n    }\n\n    return field;\n  }\n\n  validate() {\n    // Make sure all arrays are the same length\n    const length = this.fields.reduce((v, f) => {\n      return Math.max(v, f.values.length);\n    }, 0); // Add empty elements until everything matches\n\n    for (const field of this.fields) {\n      while (field.values.length !== length) {\n        field.values.add(MISSING_VALUE);\n      }\n    }\n  }\n  /**\n   * Reverse all values\n   */\n\n\n  reverse() {\n    for (const f of this.fields) {\n      f.values.reverse();\n    }\n  }\n\n  /**\n   * @deprecated unclear if this is actually used\n   */\n  setParser(field, parser) {\n    if (!this.parsers) {\n      this.parsers = new Map();\n    }\n\n    this.parsers.set(field, parser);\n    return parser;\n  }\n\n  parseValue(field, v) {\n    var _this$parsers;\n\n    let p = (_this$parsers = this.parsers) === null || _this$parsers === void 0 ? void 0 : _this$parsers.get(field);\n\n    if (!p) {\n      p = this.setParser(field, makeFieldParser(v, field));\n    }\n\n    return p(v);\n  }\n  /**\n   * This will add each value to the corresponding column\n   */\n\n\n  appendRow(row) {\n    // Add any extra columns\n    for (let i = this.fields.length; i < row.length; i++) {\n      this.addField({\n        name: `Field ${i + 1}`,\n        type: guessFieldTypeFromValue(row[i])\n      });\n    } // The first line may change the field types\n\n\n    if (this.length < 1) {\n      for (let i = 0; i < this.fields.length; i++) {\n        const f = this.fields[i];\n\n        if (!f.type || f.type === FieldType.other) {\n          f.type = guessFieldTypeFromValue(row[i]);\n        }\n      }\n    }\n\n    for (let i = 0; i < this.fields.length; i++) {\n      const f = this.fields[i];\n      let v = row[i];\n\n      if (f.type !== FieldType.string && isString(v)) {\n        v = this.parseValue(f, v);\n      }\n\n      f.values.add(v);\n    }\n  }\n  /**\n   * Add values from an object to corresponding fields. Similar to appendRow but does not create new fields.\n   */\n\n\n  add(value) {\n    // Will add one value for every field\n    const obj = value;\n\n    for (const field of this.fields) {\n      let val = obj[field.name];\n\n      if (field.type !== FieldType.string && isString(val)) {\n        val = this.parseValue(field, val);\n      }\n\n      if (val === undefined) {\n        val = MISSING_VALUE;\n      }\n\n      field.values.add(val);\n    }\n  }\n\n  set(index, value) {\n    if (index > this.length) {\n      throw new Error('Unable ot set value beyond current length');\n    }\n\n    const obj = value || {};\n\n    for (const field of this.fields) {\n      field.values.set(index, obj[field.name]);\n    }\n  }\n  /**\n   * Get an object with a property for each field in the DataFrame\n   */\n\n\n  get(idx) {\n    const v = {};\n\n    for (const field of this.fields) {\n      v[field.name] = field.values.get(idx);\n    }\n\n    return v;\n  }\n  /**\n   * The simplified JSON values used in JSON.stringify()\n   */\n\n\n  toJSON() {\n    return toDataFrameDTO(this);\n  }\n\n}","map":{"version":3,"names":["isString","FieldType","makeFieldParser","ArrayVector","FunctionalVector","guessFieldTypeFromValue","guessFieldTypeForField","toDataFrameDTO","MISSING_VALUE","undefined","MutableDataFrame","constructor","source","creator","buffer","name","refId","meta","fields","f","addField","Object","defineProperty","enumerable","get","first","length","addFieldFor","value","type","startLength","values","Array","isArray","toArray","time","other","field","config","push","add","validate","reduce","v","Math","max","reverse","setParser","parser","parsers","Map","set","parseValue","p","appendRow","row","i","string","obj","val","index","Error","idx","toJSON"],"sources":["/home/soula/grafana/packages/grafana-data/src/dataframe/MutableDataFrame.ts"],"sourcesContent":["import { isString } from 'lodash';\n\nimport { QueryResultMeta } from '../types/data';\nimport { Field, DataFrame, DataFrameDTO, FieldDTO, FieldType } from '../types/dataFrame';\nimport { MutableVector, Vector } from '../types/vector';\nimport { makeFieldParser } from '../utils/fieldParser';\nimport { ArrayVector } from '../vector/ArrayVector';\nimport { FunctionalVector } from '../vector/FunctionalVector';\n\nimport { guessFieldTypeFromValue, guessFieldTypeForField, toDataFrameDTO } from './processDataFrame';\n\nexport type MutableField<T = any> = Field<T, MutableVector<T>>;\n\ntype MutableVectorCreator = (buffer?: any[]) => MutableVector;\n\nexport const MISSING_VALUE: any = undefined; // Treated as connected in new graph panel\n\nexport class MutableDataFrame<T = any> extends FunctionalVector<T> implements DataFrame, MutableVector<T> {\n  name?: string;\n  refId?: string;\n  meta?: QueryResultMeta;\n  fields: MutableField[] = [];\n\n  private first: Vector = new ArrayVector();\n  private creator: MutableVectorCreator;\n\n  constructor(source?: DataFrame | DataFrameDTO, creator?: MutableVectorCreator) {\n    super();\n\n    // This creates the underlying storage buffers\n    this.creator = creator\n      ? creator\n      : (buffer?: any[]) => {\n          return new ArrayVector(buffer);\n        };\n\n    // Copy values from\n    if (source) {\n      const { name, refId, meta, fields } = source;\n      if (name) {\n        this.name = name;\n      }\n      if (refId) {\n        this.refId = refId;\n      }\n      if (meta) {\n        this.meta = meta;\n      }\n      if (fields) {\n        for (const f of fields) {\n          this.addField(f);\n        }\n      }\n    }\n\n    // Get Length to show up if you use spread\n    Object.defineProperty(this, 'length', {\n      enumerable: true,\n      get: () => {\n        return this.first.length;\n      },\n    });\n  }\n\n  // Defined for Vector interface\n  get length() {\n    return this.first.length;\n  }\n\n  addFieldFor(value: any, name?: string): MutableField {\n    return this.addField({\n      name: name || '', // Will be filled in\n      type: guessFieldTypeFromValue(value),\n    });\n  }\n\n  addField(f: Field | FieldDTO, startLength?: number): MutableField {\n    let buffer: any[] | undefined = undefined;\n\n    if (f.values) {\n      if (Array.isArray(f.values)) {\n        buffer = f.values as any[];\n      } else {\n        buffer = (f.values as Vector).toArray();\n      }\n    }\n\n    let type = f.type;\n\n    if (!type && ('time' === f.name || 'Time' === f.name)) {\n      type = FieldType.time;\n    } else {\n      if (!type && buffer && buffer.length) {\n        type = guessFieldTypeFromValue(buffer[0]);\n      }\n      if (!type) {\n        type = FieldType.other;\n      }\n    }\n\n    // Make sure it has a name\n    let name = f.name;\n    if (!name) {\n      name = `Field ${this.fields.length + 1}`;\n    }\n\n    const field: MutableField = {\n      ...f,\n      name,\n      type,\n      config: f.config || {},\n      values: this.creator(buffer),\n    };\n\n    if (type === FieldType.other) {\n      type = guessFieldTypeForField(field);\n      if (type) {\n        field.type = type;\n      }\n    }\n\n    this.fields.push(field);\n    this.first = this.fields[0].values;\n\n    // Make sure the field starts with a given length\n    if (startLength) {\n      while (field.values.length < startLength) {\n        field.values.add(MISSING_VALUE);\n      }\n    } else {\n      this.validate();\n    }\n\n    return field;\n  }\n\n  validate() {\n    // Make sure all arrays are the same length\n    const length = this.fields.reduce((v: number, f) => {\n      return Math.max(v, f.values.length);\n    }, 0);\n\n    // Add empty elements until everything matches\n    for (const field of this.fields) {\n      while (field.values.length !== length) {\n        field.values.add(MISSING_VALUE);\n      }\n    }\n  }\n\n  /**\n   * Reverse all values\n   */\n  reverse() {\n    for (const f of this.fields) {\n      f.values.reverse();\n    }\n  }\n\n  private parsers: Map<Field, (v: string) => any> | undefined = undefined;\n\n  /**\n   * @deprecated unclear if this is actually used\n   */\n  setParser(field: Field, parser: (v: string) => any) {\n    if (!this.parsers) {\n      this.parsers = new Map<Field, (v: string) => any>();\n    }\n    this.parsers.set(field, parser);\n    return parser;\n  }\n\n  private parseValue(field: Field, v: any): any {\n    let p = this.parsers?.get(field);\n    if (!p) {\n      p = this.setParser(field, makeFieldParser(v, field));\n    }\n    return p(v);\n  }\n\n  /**\n   * This will add each value to the corresponding column\n   */\n  appendRow(row: any[]) {\n    // Add any extra columns\n    for (let i = this.fields.length; i < row.length; i++) {\n      this.addField({\n        name: `Field ${i + 1}`,\n        type: guessFieldTypeFromValue(row[i]),\n      });\n    }\n\n    // The first line may change the field types\n    if (this.length < 1) {\n      for (let i = 0; i < this.fields.length; i++) {\n        const f = this.fields[i];\n        if (!f.type || f.type === FieldType.other) {\n          f.type = guessFieldTypeFromValue(row[i]);\n        }\n      }\n    }\n\n    for (let i = 0; i < this.fields.length; i++) {\n      const f = this.fields[i];\n      let v = row[i];\n      if (f.type !== FieldType.string && isString(v)) {\n        v = this.parseValue(f, v);\n      }\n      f.values.add(v);\n    }\n  }\n\n  /**\n   * Add values from an object to corresponding fields. Similar to appendRow but does not create new fields.\n   */\n  add(value: T) {\n    // Will add one value for every field\n    const obj = value as any;\n    for (const field of this.fields) {\n      let val = obj[field.name];\n\n      if (field.type !== FieldType.string && isString(val)) {\n        val = this.parseValue(field, val);\n      }\n\n      if (val === undefined) {\n        val = MISSING_VALUE;\n      }\n\n      field.values.add(val);\n    }\n  }\n\n  set(index: number, value: T) {\n    if (index > this.length) {\n      throw new Error('Unable ot set value beyond current length');\n    }\n\n    const obj = (value as any) || {};\n    for (const field of this.fields) {\n      field.values.set(index, obj[field.name]);\n    }\n  }\n\n  /**\n   * Get an object with a property for each field in the DataFrame\n   */\n  get(idx: number): T {\n    const v: any = {};\n    for (const field of this.fields) {\n      v[field.name] = field.values.get(idx);\n    }\n    return v as T;\n  }\n\n  /**\n   * The simplified JSON values used in JSON.stringify()\n   */\n  toJSON() {\n    return toDataFrameDTO(this);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}