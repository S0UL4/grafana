{"ast":null,"code":"import { get as lodashGet } from 'lodash';\nimport { canvasElementRegistry, DEFAULT_CANVAS_ELEMENT_CONFIG } from 'app/features/canvas';\nimport { setOptionImmutably } from 'app/features/dashboard/components/PanelEditor/utils';\nimport { PlacementEditor } from './PlacementEditor';\nimport { optionBuilder } from './options';\nexport function getElementEditor(opts) {\n  return {\n    category: opts.category,\n    path: '--',\n    // not used!\n    // Note that canvas editor writes things to the scene!\n    values: parent => ({\n      getValue: path => {\n        return lodashGet(opts.element.options, path);\n      },\n      onChange: (path, value) => {\n        let options = opts.element.options;\n\n        if (path === 'type' && value) {\n          const layer = canvasElementRegistry.getIfExists(value);\n\n          if (!layer) {\n            console.warn('layer does not exist', value);\n            return;\n          }\n\n          options = Object.assign({}, options, layer.getNewOptions(options), {\n            type: layer.id\n          });\n        } else {\n          options = setOptionImmutably(options, path, value);\n        }\n\n        opts.element.onChange(options);\n        opts.element.updateData(opts.scene.context);\n      }\n    }),\n    // Dynamically fill the selected element\n    build: (builder, context) => {\n      var _options$type;\n\n      const {\n        options\n      } = opts.element;\n      const layerTypes = canvasElementRegistry.selectOptions(options !== null && options !== void 0 && options.type // the selected value\n      ? [options.type] // as an array\n      : [DEFAULT_CANVAS_ELEMENT_CONFIG.type]);\n      builder.addSelect({\n        path: 'type',\n        name: undefined,\n        // required, but hide space\n        settings: {\n          options: layerTypes.options\n        }\n      }); // force clean layer configuration\n\n      const layer = canvasElementRegistry.getIfExists((_options$type = options === null || options === void 0 ? void 0 : options.type) !== null && _options$type !== void 0 ? _options$type : DEFAULT_CANVAS_ELEMENT_CONFIG.type);\n      let currentOptions = options;\n\n      if (!currentOptions) {\n        currentOptions = Object.assign({}, layer.getNewOptions(options), {\n          type: layer.id,\n          name: `Element ${Date.now()}.${Math.floor(Math.random() * 100)}`\n        });\n      }\n\n      const ctx = Object.assign({}, context, {\n        options: currentOptions\n      });\n\n      if (layer !== null && layer !== void 0 && layer.registerOptionsUI) {\n        layer.registerOptionsUI(builder, ctx);\n      }\n\n      optionBuilder.addBackground(builder, ctx);\n      optionBuilder.addBorder(builder, ctx);\n      builder.addCustomEditor({\n        category: ['Layout'],\n        id: 'content',\n        path: '__',\n        // not used\n        name: 'Quick placement',\n        editor: PlacementEditor,\n        settings: opts\n      });\n    }\n  };\n}","map":{"version":3,"names":["get","lodashGet","canvasElementRegistry","DEFAULT_CANVAS_ELEMENT_CONFIG","setOptionImmutably","PlacementEditor","optionBuilder","getElementEditor","opts","category","path","values","parent","getValue","element","options","onChange","value","layer","getIfExists","console","warn","getNewOptions","type","id","updateData","scene","context","build","builder","layerTypes","selectOptions","addSelect","name","undefined","settings","currentOptions","Date","now","Math","floor","random","ctx","registerOptionsUI","addBackground","addBorder","addCustomEditor","editor"],"sources":["/home/soula/grafana/public/app/plugins/panel/canvas/editor/elementEditor.tsx"],"sourcesContent":["import { get as lodashGet } from 'lodash';\n\nimport { NestedPanelOptions, NestedValueAccess } from '@grafana/data/src/utils/OptionsUIBuilders';\nimport { CanvasElementOptions, canvasElementRegistry, DEFAULT_CANVAS_ELEMENT_CONFIG } from 'app/features/canvas';\nimport { ElementState } from 'app/features/canvas/runtime/element';\nimport { Scene } from 'app/features/canvas/runtime/scene';\nimport { setOptionImmutably } from 'app/features/dashboard/components/PanelEditor/utils';\n\nimport { PlacementEditor } from './PlacementEditor';\nimport { optionBuilder } from './options';\n\nexport interface CanvasEditorOptions {\n  element: ElementState;\n  scene: Scene;\n  category?: string[];\n}\n\nexport function getElementEditor(opts: CanvasEditorOptions): NestedPanelOptions<CanvasElementOptions> {\n  return {\n    category: opts.category,\n    path: '--', // not used!\n\n    // Note that canvas editor writes things to the scene!\n    values: (parent: NestedValueAccess) => ({\n      getValue: (path: string) => {\n        return lodashGet(opts.element.options, path);\n      },\n      onChange: (path: string, value: any) => {\n        let options = opts.element.options;\n        if (path === 'type' && value) {\n          const layer = canvasElementRegistry.getIfExists(value);\n          if (!layer) {\n            console.warn('layer does not exist', value);\n            return;\n          }\n          options = {\n            ...options,\n            ...layer.getNewOptions(options),\n            type: layer.id,\n          };\n        } else {\n          options = setOptionImmutably(options, path, value);\n        }\n        opts.element.onChange(options);\n        opts.element.updateData(opts.scene.context);\n      },\n    }),\n\n    // Dynamically fill the selected element\n    build: (builder, context) => {\n      const { options } = opts.element;\n      const layerTypes = canvasElementRegistry.selectOptions(\n        options?.type // the selected value\n          ? [options.type] // as an array\n          : [DEFAULT_CANVAS_ELEMENT_CONFIG.type]\n      );\n\n      builder.addSelect({\n        path: 'type',\n        name: undefined as any, // required, but hide space\n        settings: {\n          options: layerTypes.options,\n        },\n      });\n\n      // force clean layer configuration\n      const layer = canvasElementRegistry.getIfExists(options?.type ?? DEFAULT_CANVAS_ELEMENT_CONFIG.type)!;\n      let currentOptions = options;\n      if (!currentOptions) {\n        currentOptions = {\n          ...layer.getNewOptions(options),\n          type: layer.id,\n          name: `Element ${Date.now()}.${Math.floor(Math.random() * 100)}`,\n        };\n      }\n      const ctx = { ...context, options: currentOptions };\n\n      if (layer?.registerOptionsUI) {\n        layer.registerOptionsUI(builder, ctx);\n      }\n\n      optionBuilder.addBackground(builder, ctx);\n      optionBuilder.addBorder(builder, ctx);\n\n      builder.addCustomEditor({\n        category: ['Layout'],\n        id: 'content',\n        path: '__', // not used\n        name: 'Quick placement',\n        editor: PlacementEditor,\n        settings: opts,\n      });\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}