{"ast":null,"code":"import { lastValueFrom } from 'rxjs';\nimport { DataFrameView, getDisplayProcessor } from '@grafana/data';\nimport { config, getDataSourceSrv } from '@grafana/runtime';\nimport { GrafanaQueryType } from 'app/plugins/datasource/grafana/types';\nimport { replaceCurrentFolderQuery } from './utils';\nexport class BlugeSearcher {\n  async search(query) {\n    var _query$facet;\n\n    if ((_query$facet = query.facet) !== null && _query$facet !== void 0 && _query$facet.length) {\n      throw 'facets not supported!';\n    }\n\n    return doSearchQuery(query);\n  }\n\n  async tags(query) {\n    var _query$query;\n\n    const ds = await getDataSourceSrv().get('-- Grafana --');\n    const target = {\n      refId: 'TagsQuery',\n      queryType: GrafanaQueryType.Search,\n      search: Object.assign({}, query, {\n        query: (_query$query = query.query) !== null && _query$query !== void 0 ? _query$query : '*',\n        sort: undefined,\n        // no need to sort the initial query results (not used)\n        facet: [{\n          field: 'tag'\n        }],\n        limit: 1 // 0 would be better, but is ignored by the backend\n\n      })\n    };\n    const data = (await lastValueFrom(ds.query({\n      targets: [target]\n    }))).data;\n\n    for (const frame of data) {\n      if (frame.fields[0].name === 'tag') {\n        return getTermCountsFrom(frame);\n      }\n    }\n\n    return [];\n  } // This should eventually be filled by an API call, but hardcoded is a good start\n\n\n  getSortOptions() {\n    const opts = [{\n      value: 'name_sort',\n      label: 'Alphabetically (A-Z)'\n    }, {\n      value: '-name_sort',\n      label: 'Alphabetically (Z-A)'\n    }];\n\n    if (config.licenseInfo.enabledFeatures.analytics) {\n      for (const sf of sortFields) {\n        opts.push({\n          value: `-${sf.name}`,\n          label: `${sf.display} (most)`\n        });\n        opts.push({\n          value: `${sf.name}`,\n          label: `${sf.display} (least)`\n        });\n      }\n    }\n\n    return Promise.resolve(opts);\n  }\n\n}\nconst firstPageSize = 50;\nconst nextPageSizes = 100;\n\nasync function doSearchQuery(query) {\n  var _query$query2, _query$limit, _ref, _rsp$data, _first$meta, _meta$sortBy, _meta$count;\n\n  query = await replaceCurrentFolderQuery(query);\n  const ds = await getDataSourceSrv().get('-- Grafana --');\n  const target = {\n    refId: 'Search',\n    queryType: GrafanaQueryType.Search,\n    search: Object.assign({}, query, {\n      query: (_query$query2 = query.query) !== null && _query$query2 !== void 0 ? _query$query2 : '*',\n      limit: (_query$limit = query.limit) !== null && _query$limit !== void 0 ? _query$limit : firstPageSize\n    })\n  };\n  const rsp = await lastValueFrom(ds.query({\n    targets: [target]\n  }));\n  const first = (_ref = (_rsp$data = rsp.data) === null || _rsp$data === void 0 ? void 0 : _rsp$data[0]) !== null && _ref !== void 0 ? _ref : {\n    fields: [],\n    length: 0\n  };\n\n  for (const field of first.fields) {\n    field.display = getDisplayProcessor({\n      field,\n      theme: config.theme2\n    });\n  } // Make sure the object exists\n\n\n  if (!((_first$meta = first.meta) !== null && _first$meta !== void 0 && _first$meta.custom)) {\n    first.meta = Object.assign({}, first.meta, {\n      custom: {\n        count: first.length,\n        max_score: 1\n      }\n    });\n  }\n\n  const meta = first.meta.custom;\n\n  if (!meta.locationInfo) {\n    meta.locationInfo = {}; // always set it so we can append\n  } // Set the field name to a better display name\n\n\n  if ((_meta$sortBy = meta.sortBy) !== null && _meta$sortBy !== void 0 && _meta$sortBy.length) {\n    const field = first.fields.find(f => f.name === meta.sortBy);\n\n    if (field) {\n      const name = getSortFieldDisplayName(field.name);\n      meta.sortBy = name;\n      field.name = name; // make it look nicer\n    }\n  }\n\n  const view = new DataFrameView(first);\n  return {\n    totalRows: (_meta$count = meta.count) !== null && _meta$count !== void 0 ? _meta$count : first.length,\n    view,\n    loadMoreItems: async (startIndex, stopIndex) => {\n      var _await$lastValueFrom$, _target$search, _frame$meta;\n\n      console.log('LOAD NEXT PAGE', {\n        startIndex,\n        stopIndex,\n        length: view.dataFrame.length\n      });\n      const from = view.dataFrame.length;\n      const limit = stopIndex - from;\n\n      if (limit < 0) {\n        return;\n      }\n\n      const frame = (_await$lastValueFrom$ = (await lastValueFrom(ds.query({\n        targets: [Object.assign({}, target, {\n          search: Object.assign({}, (_target$search = target === null || target === void 0 ? void 0 : target.search) !== null && _target$search !== void 0 ? _target$search : {}, {\n            from,\n            limit: Math.max(limit, nextPageSizes)\n          }),\n          refId: 'Page',\n          facet: undefined\n        })]\n      }))).data) === null || _await$lastValueFrom$ === void 0 ? void 0 : _await$lastValueFrom$[0];\n\n      if (!frame) {\n        console.log('no results', frame);\n        return;\n      }\n\n      if (frame.fields.length !== view.dataFrame.fields.length) {\n        console.log('invalid shape', frame, view.dataFrame);\n        return;\n      } // Append the raw values to the same array buffer\n\n\n      const length = frame.length + view.dataFrame.length;\n\n      for (let i = 0; i < frame.fields.length; i++) {\n        const values = view.dataFrame.fields[i].values.buffer;\n        values.push(...frame.fields[i].values.toArray());\n      }\n\n      view.dataFrame.length = length; // Add all the location lookup info\n\n      const submeta = (_frame$meta = frame.meta) === null || _frame$meta === void 0 ? void 0 : _frame$meta.custom;\n\n      if (submeta !== null && submeta !== void 0 && submeta.locationInfo && meta) {\n        for (const [key, value] of Object.entries(submeta.locationInfo)) {\n          meta.locationInfo[key] = value;\n        }\n      }\n\n      return;\n    },\n    isItemLoaded: index => {\n      return index < view.dataFrame.length;\n    }\n  };\n}\n\nfunction getTermCountsFrom(frame) {\n  const keys = frame.fields[0].values;\n  const vals = frame.fields[1].values;\n  const counts = [];\n\n  for (let i = 0; i < frame.length; i++) {\n    counts.push({\n      term: keys.get(i),\n      count: vals.get(i)\n    });\n  }\n\n  return counts;\n} // Enterprise only sort field values for dashboards\n\n\nconst sortFields = [{\n  name: 'views_total',\n  display: 'Views total'\n}, {\n  name: 'views_last_30_days',\n  display: 'Views 30 days'\n}, {\n  name: 'errors_total',\n  display: 'Errors total'\n}, {\n  name: 'errors_last_30_days',\n  display: 'Errors 30 days'\n}];\n/** Given the internal field name, this gives a reasonable display name for the table colum header */\n\nfunction getSortFieldDisplayName(name) {\n  for (const sf of sortFields) {\n    if (sf.name === name) {\n      return sf.display;\n    }\n  }\n\n  return name;\n}","map":{"version":3,"names":["lastValueFrom","DataFrameView","getDisplayProcessor","config","getDataSourceSrv","GrafanaQueryType","replaceCurrentFolderQuery","BlugeSearcher","search","query","facet","length","doSearchQuery","tags","ds","get","target","refId","queryType","Search","sort","undefined","field","limit","data","targets","frame","fields","name","getTermCountsFrom","getSortOptions","opts","value","label","licenseInfo","enabledFeatures","analytics","sf","sortFields","push","display","Promise","resolve","firstPageSize","nextPageSizes","rsp","first","theme","theme2","meta","custom","count","max_score","locationInfo","sortBy","find","f","getSortFieldDisplayName","view","totalRows","loadMoreItems","startIndex","stopIndex","console","log","dataFrame","from","Math","max","i","values","buffer","toArray","submeta","key","Object","entries","isItemLoaded","index","keys","vals","counts","term"],"sources":["/home/soula/grafana/public/app/features/search/service/bluge.ts"],"sourcesContent":["import { lastValueFrom } from 'rxjs';\n\nimport { ArrayVector, DataFrame, DataFrameView, getDisplayProcessor, SelectableValue } from '@grafana/data';\nimport { config, getDataSourceSrv } from '@grafana/runtime';\nimport { TermCount } from 'app/core/components/TagFilter/TagFilter';\nimport { GrafanaDatasource } from 'app/plugins/datasource/grafana/datasource';\nimport { GrafanaQueryType } from 'app/plugins/datasource/grafana/types';\n\nimport { replaceCurrentFolderQuery } from './utils';\n\nimport { DashboardQueryResult, GrafanaSearcher, QueryResponse, SearchQuery, SearchResultMeta } from '.';\n\nexport class BlugeSearcher implements GrafanaSearcher {\n  async search(query: SearchQuery): Promise<QueryResponse> {\n    if (query.facet?.length) {\n      throw 'facets not supported!';\n    }\n    return doSearchQuery(query);\n  }\n\n  async tags(query: SearchQuery): Promise<TermCount[]> {\n    const ds = (await getDataSourceSrv().get('-- Grafana --')) as GrafanaDatasource;\n    const target = {\n      refId: 'TagsQuery',\n      queryType: GrafanaQueryType.Search,\n      search: {\n        ...query,\n        query: query.query ?? '*',\n        sort: undefined, // no need to sort the initial query results (not used)\n        facet: [{ field: 'tag' }],\n        limit: 1, // 0 would be better, but is ignored by the backend\n      },\n    };\n\n    const data = (\n      await lastValueFrom(\n        ds.query({\n          targets: [target],\n        } as any)\n      )\n    ).data as DataFrame[];\n    for (const frame of data) {\n      if (frame.fields[0].name === 'tag') {\n        return getTermCountsFrom(frame);\n      }\n    }\n    return [];\n  }\n\n  // This should eventually be filled by an API call, but hardcoded is a good start\n  getSortOptions(): Promise<SelectableValue[]> {\n    const opts: SelectableValue[] = [\n      { value: 'name_sort', label: 'Alphabetically (A-Z)' },\n      { value: '-name_sort', label: 'Alphabetically (Z-A)' },\n    ];\n\n    if (config.licenseInfo.enabledFeatures.analytics) {\n      for (const sf of sortFields) {\n        opts.push({ value: `-${sf.name}`, label: `${sf.display} (most)` });\n        opts.push({ value: `${sf.name}`, label: `${sf.display} (least)` });\n      }\n    }\n\n    return Promise.resolve(opts);\n  }\n}\n\nconst firstPageSize = 50;\nconst nextPageSizes = 100;\n\nasync function doSearchQuery(query: SearchQuery): Promise<QueryResponse> {\n  query = await replaceCurrentFolderQuery(query);\n  const ds = (await getDataSourceSrv().get('-- Grafana --')) as GrafanaDatasource;\n  const target = {\n    refId: 'Search',\n    queryType: GrafanaQueryType.Search,\n    search: {\n      ...query,\n      query: query.query ?? '*',\n      limit: query.limit ?? firstPageSize,\n    },\n  };\n  const rsp = await lastValueFrom(\n    ds.query({\n      targets: [target],\n    } as any)\n  );\n\n  const first = (rsp.data?.[0] as DataFrame) ?? { fields: [], length: 0 };\n  for (const field of first.fields) {\n    field.display = getDisplayProcessor({ field, theme: config.theme2 });\n  }\n\n  // Make sure the object exists\n  if (!first.meta?.custom) {\n    first.meta = {\n      ...first.meta,\n      custom: {\n        count: first.length,\n        max_score: 1,\n      },\n    };\n  }\n\n  const meta = first.meta.custom as SearchResultMeta;\n  if (!meta.locationInfo) {\n    meta.locationInfo = {}; // always set it so we can append\n  }\n\n  // Set the field name to a better display name\n  if (meta.sortBy?.length) {\n    const field = first.fields.find((f) => f.name === meta.sortBy);\n    if (field) {\n      const name = getSortFieldDisplayName(field.name);\n      meta.sortBy = name;\n      field.name = name; // make it look nicer\n    }\n  }\n\n  const view = new DataFrameView<DashboardQueryResult>(first);\n  return {\n    totalRows: meta.count ?? first.length,\n    view,\n    loadMoreItems: async (startIndex: number, stopIndex: number): Promise<void> => {\n      console.log('LOAD NEXT PAGE', { startIndex, stopIndex, length: view.dataFrame.length });\n      const from = view.dataFrame.length;\n      const limit = stopIndex - from;\n      if (limit < 0) {\n        return;\n      }\n      const frame = (\n        await lastValueFrom(\n          ds.query({\n            targets: [\n              {\n                ...target,\n                search: {\n                  ...(target?.search ?? {}),\n                  from,\n                  limit: Math.max(limit, nextPageSizes),\n                },\n                refId: 'Page',\n                facet: undefined,\n              },\n            ],\n          } as any)\n        )\n      ).data?.[0] as DataFrame;\n\n      if (!frame) {\n        console.log('no results', frame);\n        return;\n      }\n      if (frame.fields.length !== view.dataFrame.fields.length) {\n        console.log('invalid shape', frame, view.dataFrame);\n        return;\n      }\n\n      // Append the raw values to the same array buffer\n      const length = frame.length + view.dataFrame.length;\n      for (let i = 0; i < frame.fields.length; i++) {\n        const values = (view.dataFrame.fields[i].values as ArrayVector).buffer;\n        values.push(...frame.fields[i].values.toArray());\n      }\n      view.dataFrame.length = length;\n\n      // Add all the location lookup info\n      const submeta = frame.meta?.custom as SearchResultMeta;\n      if (submeta?.locationInfo && meta) {\n        for (const [key, value] of Object.entries(submeta.locationInfo)) {\n          meta.locationInfo[key] = value;\n        }\n      }\n      return;\n    },\n    isItemLoaded: (index: number): boolean => {\n      return index < view.dataFrame.length;\n    },\n  };\n}\n\nfunction getTermCountsFrom(frame: DataFrame): TermCount[] {\n  const keys = frame.fields[0].values;\n  const vals = frame.fields[1].values;\n  const counts: TermCount[] = [];\n  for (let i = 0; i < frame.length; i++) {\n    counts.push({ term: keys.get(i), count: vals.get(i) });\n  }\n  return counts;\n}\n\n// Enterprise only sort field values for dashboards\nconst sortFields = [\n  { name: 'views_total', display: 'Views total' },\n  { name: 'views_last_30_days', display: 'Views 30 days' },\n  { name: 'errors_total', display: 'Errors total' },\n  { name: 'errors_last_30_days', display: 'Errors 30 days' },\n];\n\n/** Given the internal field name, this gives a reasonable display name for the table colum header */\nfunction getSortFieldDisplayName(name: string) {\n  for (const sf of sortFields) {\n    if (sf.name === name) {\n      return sf.display;\n    }\n  }\n  return name;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}