{"ast":null,"code":"import { ExpressionQueryType } from '../../../expressions/types';\nconst FALL_BACK_TIME_RANGE = {\n  from: 21600,\n  to: 0\n};\nexport const getTimeRangeForExpression = (query, queries) => {\n  const referencedRefIds = getReferencedIds(query, queries);\n\n  if (!referencedRefIds) {\n    return FALL_BACK_TIME_RANGE;\n  }\n\n  const {\n    from,\n    to\n  } = getTimeRanges(referencedRefIds, queries);\n\n  if (!from.length && !to.length) {\n    return FALL_BACK_TIME_RANGE;\n  }\n\n  return {\n    from: Math.max(...from),\n    to: Math.min(...to)\n  };\n};\n\nconst getReferencedIds = (model, queries) => {\n  switch (model.type) {\n    case ExpressionQueryType.classic:\n      return getReferencedIdsForClassicCondition(model);\n\n    case ExpressionQueryType.math:\n      return getReferencedIdsForMath(model, queries);\n\n    case ExpressionQueryType.resample:\n    case ExpressionQueryType.reduce:\n      return getReferencedIdsForReduce(model);\n  }\n};\n\nconst getReferencedIdsForClassicCondition = model => {\n  var _model$conditions;\n\n  return (_model$conditions = model.conditions) === null || _model$conditions === void 0 ? void 0 : _model$conditions.map(condition => {\n    return condition.query.params[0];\n  });\n};\n\nconst getTimeRanges = (referencedRefIds, queries) => {\n  let from = [];\n  let to = [FALL_BACK_TIME_RANGE.to];\n\n  for (const referencedRefIdsKey of referencedRefIds) {\n    const query = queries.find(query => query.refId === referencedRefIdsKey);\n\n    if (!query || !query.relativeTimeRange) {\n      continue;\n    }\n\n    from.push(query.relativeTimeRange.from);\n    to.push(query.relativeTimeRange.to);\n  }\n\n  return {\n    from,\n    to\n  };\n};\n\nconst getReferencedIdsForMath = (model, queries) => {\n  return queries // filter queries of type query and filter expression on if it includes any refIds\n  .filter(q => {\n    var _model$expression;\n\n    return q.queryType === 'query' && ((_model$expression = model.expression) === null || _model$expression === void 0 ? void 0 : _model$expression.includes(q.refId));\n  }).map(q => {\n    return q.refId;\n  });\n};\n\nconst getReferencedIdsForReduce = model => {\n  return model.expression ? [model.expression] : undefined;\n};","map":{"version":3,"names":["ExpressionQueryType","FALL_BACK_TIME_RANGE","from","to","getTimeRangeForExpression","query","queries","referencedRefIds","getReferencedIds","getTimeRanges","length","Math","max","min","model","type","classic","getReferencedIdsForClassicCondition","math","getReferencedIdsForMath","resample","reduce","getReferencedIdsForReduce","conditions","map","condition","params","referencedRefIdsKey","find","refId","relativeTimeRange","push","filter","q","queryType","expression","includes","undefined"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/utils/timeRange.ts"],"sourcesContent":["import { RelativeTimeRange } from '@grafana/data';\nimport { AlertQuery } from 'app/types/unified-alerting-dto';\n\nimport { ExpressionQuery, ExpressionQueryType } from '../../../expressions/types';\n\nconst FALL_BACK_TIME_RANGE = { from: 21600, to: 0 };\n\nexport const getTimeRangeForExpression = (query: ExpressionQuery, queries: AlertQuery[]): RelativeTimeRange => {\n  const referencedRefIds: string[] | undefined = getReferencedIds(query, queries);\n\n  if (!referencedRefIds) {\n    return FALL_BACK_TIME_RANGE;\n  }\n\n  const { from, to } = getTimeRanges(referencedRefIds, queries);\n\n  if (!from.length && !to.length) {\n    return FALL_BACK_TIME_RANGE;\n  }\n\n  return {\n    from: Math.max(...from),\n    to: Math.min(...to),\n  };\n};\n\nconst getReferencedIds = (model: ExpressionQuery, queries: AlertQuery[]): string[] | undefined => {\n  switch (model.type) {\n    case ExpressionQueryType.classic:\n      return getReferencedIdsForClassicCondition(model);\n    case ExpressionQueryType.math:\n      return getReferencedIdsForMath(model, queries);\n    case ExpressionQueryType.resample:\n    case ExpressionQueryType.reduce:\n      return getReferencedIdsForReduce(model);\n  }\n};\n\nconst getReferencedIdsForClassicCondition = (model: ExpressionQuery) => {\n  return model.conditions?.map((condition) => {\n    return condition.query.params[0];\n  });\n};\n\nconst getTimeRanges = (referencedRefIds: string[], queries: AlertQuery[]) => {\n  let from: number[] = [];\n  let to = [FALL_BACK_TIME_RANGE.to];\n  for (const referencedRefIdsKey of referencedRefIds) {\n    const query = queries.find((query) => query.refId === referencedRefIdsKey);\n\n    if (!query || !query.relativeTimeRange) {\n      continue;\n    }\n    from.push(query.relativeTimeRange.from);\n    to.push(query.relativeTimeRange.to);\n  }\n\n  return {\n    from,\n    to,\n  };\n};\n\nconst getReferencedIdsForMath = (model: ExpressionQuery, queries: AlertQuery[]) => {\n  return (\n    queries\n      // filter queries of type query and filter expression on if it includes any refIds\n      .filter((q) => q.queryType === 'query' && model.expression?.includes(q.refId))\n      .map((q) => {\n        return q.refId;\n      })\n  );\n};\n\nconst getReferencedIdsForReduce = (model: ExpressionQuery) => {\n  return model.expression ? [model.expression] : undefined;\n};\n"],"mappings":"AAGA,SAA0BA,mBAA1B,QAAqD,4BAArD;AAEA,MAAMC,oBAAoB,GAAG;EAAEC,IAAI,EAAE,KAAR;EAAeC,EAAE,EAAE;AAAnB,CAA7B;AAEA,OAAO,MAAMC,yBAAyB,GAAG,CAACC,KAAD,EAAyBC,OAAzB,KAAsE;EAC7G,MAAMC,gBAAsC,GAAGC,gBAAgB,CAACH,KAAD,EAAQC,OAAR,CAA/D;;EAEA,IAAI,CAACC,gBAAL,EAAuB;IACrB,OAAON,oBAAP;EACD;;EAED,MAAM;IAAEC,IAAF;IAAQC;EAAR,IAAeM,aAAa,CAACF,gBAAD,EAAmBD,OAAnB,CAAlC;;EAEA,IAAI,CAACJ,IAAI,CAACQ,MAAN,IAAgB,CAACP,EAAE,CAACO,MAAxB,EAAgC;IAC9B,OAAOT,oBAAP;EACD;;EAED,OAAO;IACLC,IAAI,EAAES,IAAI,CAACC,GAAL,CAAS,GAAGV,IAAZ,CADD;IAELC,EAAE,EAAEQ,IAAI,CAACE,GAAL,CAAS,GAAGV,EAAZ;EAFC,CAAP;AAID,CAjBM;;AAmBP,MAAMK,gBAAgB,GAAG,CAACM,KAAD,EAAyBR,OAAzB,KAAyE;EAChG,QAAQQ,KAAK,CAACC,IAAd;IACE,KAAKf,mBAAmB,CAACgB,OAAzB;MACE,OAAOC,mCAAmC,CAACH,KAAD,CAA1C;;IACF,KAAKd,mBAAmB,CAACkB,IAAzB;MACE,OAAOC,uBAAuB,CAACL,KAAD,EAAQR,OAAR,CAA9B;;IACF,KAAKN,mBAAmB,CAACoB,QAAzB;IACA,KAAKpB,mBAAmB,CAACqB,MAAzB;MACE,OAAOC,yBAAyB,CAACR,KAAD,CAAhC;EAPJ;AASD,CAVD;;AAYA,MAAMG,mCAAmC,GAAIH,KAAD,IAA4B;EAAA;;EACtE,4BAAOA,KAAK,CAACS,UAAb,sDAAO,kBAAkBC,GAAlB,CAAuBC,SAAD,IAAe;IAC1C,OAAOA,SAAS,CAACpB,KAAV,CAAgBqB,MAAhB,CAAuB,CAAvB,CAAP;EACD,CAFM,CAAP;AAGD,CAJD;;AAMA,MAAMjB,aAAa,GAAG,CAACF,gBAAD,EAA6BD,OAA7B,KAAuD;EAC3E,IAAIJ,IAAc,GAAG,EAArB;EACA,IAAIC,EAAE,GAAG,CAACF,oBAAoB,CAACE,EAAtB,CAAT;;EACA,KAAK,MAAMwB,mBAAX,IAAkCpB,gBAAlC,EAAoD;IAClD,MAAMF,KAAK,GAAGC,OAAO,CAACsB,IAAR,CAAcvB,KAAD,IAAWA,KAAK,CAACwB,KAAN,KAAgBF,mBAAxC,CAAd;;IAEA,IAAI,CAACtB,KAAD,IAAU,CAACA,KAAK,CAACyB,iBAArB,EAAwC;MACtC;IACD;;IACD5B,IAAI,CAAC6B,IAAL,CAAU1B,KAAK,CAACyB,iBAAN,CAAwB5B,IAAlC;IACAC,EAAE,CAAC4B,IAAH,CAAQ1B,KAAK,CAACyB,iBAAN,CAAwB3B,EAAhC;EACD;;EAED,OAAO;IACLD,IADK;IAELC;EAFK,CAAP;AAID,CAjBD;;AAmBA,MAAMgB,uBAAuB,GAAG,CAACL,KAAD,EAAyBR,OAAzB,KAAmD;EACjF,OACEA,OAAO,CACL;EADK,CAEJ0B,MAFH,CAEWC,CAAD;IAAA;;IAAA,OAAOA,CAAC,CAACC,SAAF,KAAgB,OAAhB,0BAA2BpB,KAAK,CAACqB,UAAjC,sDAA2B,kBAAkBC,QAAlB,CAA2BH,CAAC,CAACJ,KAA7B,CAA3B,CAAP;EAAA,CAFV,EAGGL,GAHH,CAGQS,CAAD,IAAO;IACV,OAAOA,CAAC,CAACJ,KAAT;EACD,CALH,CADF;AAQD,CATD;;AAWA,MAAMP,yBAAyB,GAAIR,KAAD,IAA4B;EAC5D,OAAOA,KAAK,CAACqB,UAAN,GAAmB,CAACrB,KAAK,CAACqB,UAAP,CAAnB,GAAwCE,SAA/C;AACD,CAFD"},"metadata":{},"sourceType":"module"}