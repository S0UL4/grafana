{"ast":null,"code":"import { ArrayVector, FieldType, outerJoinDataFrames } from '@grafana/data';\nimport { AxisPlacement, GraphDrawStyle, ScaleDistribution } from '@grafana/schema';\nimport { FIXED_UNIT } from './GraphNG';\nimport { applyNullInsertThreshold } from './nullInsertThreshold';\nimport { nullToUndefThreshold } from './nullToUndefThreshold';\n\nfunction isVisibleBarField(f) {\n  var _f$config$custom, _f$config$custom2, _f$config$custom2$hid;\n\n  return f.type === FieldType.number && ((_f$config$custom = f.config.custom) === null || _f$config$custom === void 0 ? void 0 : _f$config$custom.drawStyle) === GraphDrawStyle.Bars && !((_f$config$custom2 = f.config.custom) !== null && _f$config$custom2 !== void 0 && (_f$config$custom2$hid = _f$config$custom2.hideFrom) !== null && _f$config$custom2$hid !== void 0 && _f$config$custom2$hid.viz);\n} // will mutate the DataFrame's fields' values\n\n\nfunction applySpanNullsThresholds(frame) {\n  let refField = frame.fields.find(field => field.type === FieldType.time); // this doesnt need to be time, just any numeric/asc join field\n\n  let refValues = refField === null || refField === void 0 ? void 0 : refField.values.toArray();\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    var _field$config$custom;\n\n    let field = frame.fields[i];\n\n    if (field === refField || isVisibleBarField(field)) {\n      continue;\n    }\n\n    let spanNulls = (_field$config$custom = field.config.custom) === null || _field$config$custom === void 0 ? void 0 : _field$config$custom.spanNulls;\n\n    if (typeof spanNulls === 'number') {\n      if (spanNulls !== -1) {\n        field.values = new ArrayVector(nullToUndefThreshold(refValues, field.values.toArray(), spanNulls));\n      }\n    }\n  }\n\n  return frame;\n}\n\nexport function preparePlotFrame(frames, dimFields, timeRange) {\n  // apply null insertions at interval\n  frames = frames.map(frame => {\n    var _frame$fields$0$state;\n\n    if (!((_frame$fields$0$state = frame.fields[0].state) !== null && _frame$fields$0$state !== void 0 && _frame$fields$0$state.nullThresholdApplied)) {\n      return applyNullInsertThreshold({\n        frame,\n        refFieldName: null,\n        refFieldPseudoMin: timeRange === null || timeRange === void 0 ? void 0 : timeRange.from.valueOf(),\n        refFieldPseudoMax: timeRange === null || timeRange === void 0 ? void 0 : timeRange.to.valueOf()\n      });\n    } else {\n      return frame;\n    }\n  });\n  let numBarSeries = 0;\n  frames.forEach(frame => {\n    frame.fields.forEach(f => {\n      if (isVisibleBarField(f)) {\n        // prevent minesweeper-expansion of nulls (gaps) when joining bars\n        // since bar width is determined from the minimum distance between non-undefined values\n        // (this strategy will still retain any original pre-join nulls, though)\n        f.config.custom = Object.assign({}, f.config.custom, {\n          spanNulls: -1\n        });\n        numBarSeries++;\n      }\n    });\n  }); // to make bar widths of all series uniform (equal to narrowest bar series), find smallest distance between x points\n\n  let minXDelta = Infinity;\n\n  if (numBarSeries > 1) {\n    frames.forEach(frame => {\n      if (!frame.fields.some(isVisibleBarField)) {\n        return;\n      }\n\n      const xVals = frame.fields[0].values.toArray();\n\n      for (let i = 0; i < xVals.length; i++) {\n        if (i > 0) {\n          minXDelta = Math.min(minXDelta, xVals[i] - xVals[i - 1]);\n        }\n      }\n    });\n  }\n\n  let alignedFrame = outerJoinDataFrames({\n    frames,\n    joinBy: dimFields.x,\n    keep: dimFields.y,\n    keepOriginIndices: true\n  });\n\n  if (alignedFrame) {\n    alignedFrame = applySpanNullsThresholds(alignedFrame); // append 2 null vals at minXDelta to bar series\n\n    if (minXDelta !== Infinity) {\n      alignedFrame.fields.forEach((f, fi) => {\n        let vals = f.values.toArray();\n\n        if (fi === 0) {\n          let lastVal = vals[vals.length - 1];\n          vals.push(lastVal + minXDelta, lastVal + 2 * minXDelta);\n        } else if (isVisibleBarField(f)) {\n          vals.push(null, null);\n        } else {\n          vals.push(undefined, undefined);\n        }\n      });\n      alignedFrame.length += 2;\n    }\n\n    return alignedFrame;\n  }\n\n  return null;\n}\nexport function buildScaleKey(config) {\n  var _config$custom, _config$custom2, _config$custom3, _config$custom4, _config$unit, _config$custom5, _config$custom6;\n\n  const defaultPart = 'na';\n  const scaleRange = `${config.min !== undefined ? config.min : defaultPart}-${config.max !== undefined ? config.max : defaultPart}`;\n  const scaleSoftRange = `${((_config$custom = config.custom) === null || _config$custom === void 0 ? void 0 : _config$custom.axisSoftMin) !== undefined ? config.custom.axisSoftMin : defaultPart}-${((_config$custom2 = config.custom) === null || _config$custom2 === void 0 ? void 0 : _config$custom2.axisSoftMax) !== undefined ? config.custom.axisSoftMax : defaultPart}`;\n  const scalePlacement = `${((_config$custom3 = config.custom) === null || _config$custom3 === void 0 ? void 0 : _config$custom3.axisPlacement) !== undefined ? (_config$custom4 = config.custom) === null || _config$custom4 === void 0 ? void 0 : _config$custom4.axisPlacement : AxisPlacement.Auto}`;\n  const scaleUnit = (_config$unit = config.unit) !== null && _config$unit !== void 0 ? _config$unit : FIXED_UNIT;\n  const scaleDistribution = (_config$custom5 = config.custom) !== null && _config$custom5 !== void 0 && _config$custom5.scaleDistribution ? getScaleDistributionPart(config.custom.scaleDistribution) : ScaleDistribution.Linear;\n  const scaleLabel = Boolean((_config$custom6 = config.custom) === null || _config$custom6 === void 0 ? void 0 : _config$custom6.axisLabel) ? config.custom.axisLabel : defaultPart;\n  return `${scaleUnit}/${scaleRange}/${scaleSoftRange}/${scalePlacement}/${scaleDistribution}/${scaleLabel}`;\n}\n\nfunction getScaleDistributionPart(config) {\n  if (config.type === ScaleDistribution.Log) {\n    return `${config.type}${config.log}`;\n  }\n\n  return config.type;\n}","map":{"version":3,"names":["ArrayVector","FieldType","outerJoinDataFrames","AxisPlacement","GraphDrawStyle","ScaleDistribution","FIXED_UNIT","applyNullInsertThreshold","nullToUndefThreshold","isVisibleBarField","f","type","number","config","custom","drawStyle","Bars","hideFrom","viz","applySpanNullsThresholds","frame","refField","fields","find","field","time","refValues","values","toArray","i","length","spanNulls","preparePlotFrame","frames","dimFields","timeRange","map","state","nullThresholdApplied","refFieldName","refFieldPseudoMin","from","valueOf","refFieldPseudoMax","to","numBarSeries","forEach","minXDelta","Infinity","some","xVals","Math","min","alignedFrame","joinBy","x","keep","y","keepOriginIndices","fi","vals","lastVal","push","undefined","buildScaleKey","defaultPart","scaleRange","max","scaleSoftRange","axisSoftMin","axisSoftMax","scalePlacement","axisPlacement","Auto","scaleUnit","unit","scaleDistribution","getScaleDistributionPart","Linear","scaleLabel","Boolean","axisLabel","Log","log"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/GraphNG/utils.ts"],"sourcesContent":["import { ArrayVector, DataFrame, Field, FieldConfig, FieldType, outerJoinDataFrames, TimeRange } from '@grafana/data';\nimport {\n  AxisPlacement,\n  GraphDrawStyle,\n  GraphFieldConfig,\n  ScaleDistribution,\n  ScaleDistributionConfig,\n} from '@grafana/schema';\n\nimport { FIXED_UNIT } from './GraphNG';\nimport { applyNullInsertThreshold } from './nullInsertThreshold';\nimport { nullToUndefThreshold } from './nullToUndefThreshold';\nimport { XYFieldMatchers } from './types';\n\nfunction isVisibleBarField(f: Field) {\n  return (\n    f.type === FieldType.number && f.config.custom?.drawStyle === GraphDrawStyle.Bars && !f.config.custom?.hideFrom?.viz\n  );\n}\n\n// will mutate the DataFrame's fields' values\nfunction applySpanNullsThresholds(frame: DataFrame) {\n  let refField = frame.fields.find((field) => field.type === FieldType.time); // this doesnt need to be time, just any numeric/asc join field\n  let refValues = refField?.values.toArray() as any[];\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    let field = frame.fields[i];\n\n    if (field === refField || isVisibleBarField(field)) {\n      continue;\n    }\n\n    let spanNulls = field.config.custom?.spanNulls;\n\n    if (typeof spanNulls === 'number') {\n      if (spanNulls !== -1) {\n        field.values = new ArrayVector(nullToUndefThreshold(refValues, field.values.toArray(), spanNulls));\n      }\n    }\n  }\n\n  return frame;\n}\n\nexport function preparePlotFrame(frames: DataFrame[], dimFields: XYFieldMatchers, timeRange?: TimeRange | null) {\n  // apply null insertions at interval\n  frames = frames.map((frame) => {\n    if (!frame.fields[0].state?.nullThresholdApplied) {\n      return applyNullInsertThreshold({\n        frame,\n        refFieldName: null,\n        refFieldPseudoMin: timeRange?.from.valueOf(),\n        refFieldPseudoMax: timeRange?.to.valueOf(),\n      });\n    } else {\n      return frame;\n    }\n  });\n\n  let numBarSeries = 0;\n\n  frames.forEach((frame) => {\n    frame.fields.forEach((f) => {\n      if (isVisibleBarField(f)) {\n        // prevent minesweeper-expansion of nulls (gaps) when joining bars\n        // since bar width is determined from the minimum distance between non-undefined values\n        // (this strategy will still retain any original pre-join nulls, though)\n        f.config.custom = {\n          ...f.config.custom,\n          spanNulls: -1,\n        };\n\n        numBarSeries++;\n      }\n    });\n  });\n\n  // to make bar widths of all series uniform (equal to narrowest bar series), find smallest distance between x points\n  let minXDelta = Infinity;\n\n  if (numBarSeries > 1) {\n    frames.forEach((frame) => {\n      if (!frame.fields.some(isVisibleBarField)) {\n        return;\n      }\n\n      const xVals = frame.fields[0].values.toArray();\n\n      for (let i = 0; i < xVals.length; i++) {\n        if (i > 0) {\n          minXDelta = Math.min(minXDelta, xVals[i] - xVals[i - 1]);\n        }\n      }\n    });\n  }\n\n  let alignedFrame = outerJoinDataFrames({\n    frames,\n    joinBy: dimFields.x,\n    keep: dimFields.y,\n    keepOriginIndices: true,\n  });\n\n  if (alignedFrame) {\n    alignedFrame = applySpanNullsThresholds(alignedFrame);\n\n    // append 2 null vals at minXDelta to bar series\n    if (minXDelta !== Infinity) {\n      alignedFrame.fields.forEach((f, fi) => {\n        let vals = f.values.toArray();\n\n        if (fi === 0) {\n          let lastVal = vals[vals.length - 1];\n          vals.push(lastVal + minXDelta, lastVal + 2 * minXDelta);\n        } else if (isVisibleBarField(f)) {\n          vals.push(null, null);\n        } else {\n          vals.push(undefined, undefined);\n        }\n      });\n\n      alignedFrame.length += 2;\n    }\n\n    return alignedFrame;\n  }\n\n  return null;\n}\n\nexport function buildScaleKey(config: FieldConfig<GraphFieldConfig>) {\n  const defaultPart = 'na';\n\n  const scaleRange = `${config.min !== undefined ? config.min : defaultPart}-${\n    config.max !== undefined ? config.max : defaultPart\n  }`;\n\n  const scaleSoftRange = `${config.custom?.axisSoftMin !== undefined ? config.custom.axisSoftMin : defaultPart}-${\n    config.custom?.axisSoftMax !== undefined ? config.custom.axisSoftMax : defaultPart\n  }`;\n\n  const scalePlacement = `${\n    config.custom?.axisPlacement !== undefined ? config.custom?.axisPlacement : AxisPlacement.Auto\n  }`;\n\n  const scaleUnit = config.unit ?? FIXED_UNIT;\n\n  const scaleDistribution = config.custom?.scaleDistribution\n    ? getScaleDistributionPart(config.custom.scaleDistribution)\n    : ScaleDistribution.Linear;\n\n  const scaleLabel = Boolean(config.custom?.axisLabel) ? config.custom!.axisLabel : defaultPart;\n\n  return `${scaleUnit}/${scaleRange}/${scaleSoftRange}/${scalePlacement}/${scaleDistribution}/${scaleLabel}`;\n}\n\nfunction getScaleDistributionPart(config: ScaleDistributionConfig) {\n  if (config.type === ScaleDistribution.Log) {\n    return `${config.type}${config.log}`;\n  }\n  return config.type;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}