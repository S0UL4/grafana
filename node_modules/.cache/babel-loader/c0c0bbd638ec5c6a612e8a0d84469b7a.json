{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport * as React from 'react';\nimport Positions from './Positions';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DEFAULT_INITIAL_DRAW = 100;\n/**\n * Virtualized list view component, for the most part, only renders the window\n * of items that are in-view with some buffer before and after. Listens for\n * scroll events and updates which items are rendered. See react-virtualized\n * for a suite of components with similar, but generalized, functionality.\n * https://github.com/bvaughn/react-virtualized\n *\n * Note: Presently, ListView cannot be a PureComponent. This is because ListView\n * is sensitive to the underlying state that drives the list items, but it\n * doesn't actually receive that state. So, a render may still be required even\n * if ListView's props are unchanged.\n *\n * @export\n * @class ListView\n */\n\nexport default class ListView extends React.Component {\n  /**\n   * Keeps track of the height and y-value of items, by item index, in the\n   * ListView.\n   */\n\n  /**\n   * Keep track of the known / measured heights of the rendered items; populated\n   * with values through observation and keyed on the item key, not the item\n   * index.\n   */\n\n  /**\n   * The start index of the items currently drawn.\n   */\n\n  /**\n   * The end index of the items currently drawn.\n   */\n\n  /**\n   * The start index of the items currently in view.\n   */\n\n  /**\n   * The end index of the items currently in view.\n   */\n\n  /**\n   * Height of the visual window, e.g. height of the scroller element.\n   */\n\n  /**\n   * `scrollTop` of the current scroll position.\n   */\n\n  /**\n   * Used to keep track of whether or not a re-calculation of what should be\n   * drawn / viewable has been scheduled.\n   */\n\n  /**\n   * If `windowScroller` is true, this notes how far down the page the scroller\n   * is located. (Note: repositioning and below-the-fold views are untested)\n   */\n\n  /**\n   * Element holding the scroller.\n   */\n\n  /**\n   * HTMLElement holding the rendered items.\n   */\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"_yPositions\", void 0);\n\n    _defineProperty(this, \"_knownHeights\", void 0);\n\n    _defineProperty(this, \"_startIndexDrawn\", void 0);\n\n    _defineProperty(this, \"_endIndexDrawn\", void 0);\n\n    _defineProperty(this, \"_startIndex\", void 0);\n\n    _defineProperty(this, \"_endIndex\", void 0);\n\n    _defineProperty(this, \"_viewHeight\", void 0);\n\n    _defineProperty(this, \"_scrollTop\", void 0);\n\n    _defineProperty(this, \"_isScrolledOrResized\", void 0);\n\n    _defineProperty(this, \"_htmlTopOffset\", void 0);\n\n    _defineProperty(this, \"_windowScrollListenerAdded\", void 0);\n\n    _defineProperty(this, \"_htmlElm\", void 0);\n\n    _defineProperty(this, \"_wrapperElm\", void 0);\n\n    _defineProperty(this, \"_itemHolderElm\", void 0);\n\n    _defineProperty(this, \"getViewHeight\", () => this._viewHeight);\n\n    _defineProperty(this, \"getBottomVisibleIndex\", () => {\n      const bottomY = this._scrollTop + this._viewHeight;\n      return this._yPositions.findFloorIndex(bottomY, this._getHeight);\n    });\n\n    _defineProperty(this, \"getTopVisibleIndex\", () => this._yPositions.findFloorIndex(this._scrollTop, this._getHeight));\n\n    _defineProperty(this, \"getRowPosition\", index => this._yPositions.getRowPosition(index, this._getHeight));\n\n    _defineProperty(this, \"scrollToIndex\", index => {\n      var _this$_itemHolderElm, _this$props$scrollEle;\n\n      // calculate the position of the list view relative to the scroll parent\n      const {\n        scrollElement\n      } = this.props;\n      const scrollElementTop = (scrollElement === null || scrollElement === void 0 ? void 0 : scrollElement.getBoundingClientRect().top) || 0;\n      const listViewTop = ((scrollElement === null || scrollElement === void 0 ? void 0 : scrollElement.scrollTop) || 0) + (((_this$_itemHolderElm = this._itemHolderElm) === null || _this$_itemHolderElm === void 0 ? void 0 : _this$_itemHolderElm.getBoundingClientRect().top) || 0);\n      const listViewOffset = listViewTop - scrollElementTop;\n      const itemOffset = this.getRowPosition(index).y; // hard code a small offset to leave a little bit of space above the focused span, so it is visually clear\n      // that there is content above\n\n      (_this$props$scrollEle = this.props.scrollElement) === null || _this$props$scrollEle === void 0 ? void 0 : _this$props$scrollEle.scrollTo({\n        top: itemOffset + listViewOffset - 80\n      });\n    });\n\n    _defineProperty(this, \"_onScroll\", () => {\n      if (!this._isScrolledOrResized) {\n        this._isScrolledOrResized = true;\n        window.requestAnimationFrame(this._positionList);\n      }\n    });\n\n    _defineProperty(this, \"_positionList\", () => {\n      this._isScrolledOrResized = false;\n\n      if (!this._wrapperElm) {\n        return;\n      }\n\n      this._calcViewIndexes(); // indexes drawn should be padded by at least props.viewBufferMin\n\n\n      const maxStart = this.props.viewBufferMin > this._startIndex ? 0 : this._startIndex - this.props.viewBufferMin;\n      const minEnd = this.props.viewBufferMin < this.props.dataLength - this._endIndex ? this._endIndex + this.props.viewBufferMin : this.props.dataLength - 1;\n\n      if (maxStart < this._startIndexDrawn || minEnd > this._endIndexDrawn) {\n        this.forceUpdate();\n      }\n    });\n\n    _defineProperty(this, \"_initWrapper\", elm => {\n      if (!this.props.windowScroller) {\n        return;\n      }\n\n      this._wrapperElm = elm;\n\n      if (elm) {\n        this._viewHeight = elm.clientHeight;\n      }\n    });\n\n    _defineProperty(this, \"_initItemHolder\", elm => {\n      this._itemHolderElm = elm;\n\n      this._scanItemHeights();\n    });\n\n    _defineProperty(this, \"_scanItemHeights\", () => {\n      const getIndexFromKey = this.props.getIndexFromKey;\n\n      if (!this._itemHolderElm) {\n        return;\n      } // note the keys for the first and last altered heights, the `yPositions`\n      // needs to be updated\n\n\n      let lowDirtyKey = null;\n      let highDirtyKey = null;\n      let isDirty = false; // iterating childNodes is faster than children\n      // https://jsperf.com/large-htmlcollection-vs-large-nodelist\n\n      const nodes = this._itemHolderElm.childNodes;\n      const max = nodes.length;\n\n      for (let i = 0; i < max; i++) {\n        const node = nodes[i]; // use `.getAttribute(...)` instead of `.dataset` for jest / JSDOM\n\n        const itemKey = node.getAttribute('data-item-key');\n\n        if (!itemKey) {\n          // eslint-disable-next-line no-console\n          console.warn('itemKey not found');\n          continue;\n        } // measure the first child, if it's available, otherwise the node itself\n        // (likely not transferable to other contexts, and instead is specific to\n        // how we have the items rendered)\n\n\n        const measureSrc = node.firstElementChild || node;\n        const observed = measureSrc.clientHeight;\n\n        const known = this._knownHeights.get(itemKey);\n\n        if (observed !== known) {\n          this._knownHeights.set(itemKey, observed);\n\n          if (!isDirty) {\n            isDirty = true; // eslint-disable-next-line no-multi-assign\n\n            lowDirtyKey = highDirtyKey = itemKey;\n          } else {\n            highDirtyKey = itemKey;\n          }\n        }\n      }\n\n      if (lowDirtyKey != null && highDirtyKey != null) {\n        // update yPositions, then redraw\n        const imin = getIndexFromKey(lowDirtyKey);\n        const imax = highDirtyKey === lowDirtyKey ? imin : getIndexFromKey(highDirtyKey);\n\n        this._yPositions.calcHeights(imax, this._getHeight, imin);\n\n        this.forceUpdate();\n      }\n    });\n\n    _defineProperty(this, \"_getHeight\", i => {\n      const key = this.props.getKeyFromIndex(i);\n\n      const known = this._knownHeights.get(key); // known !== known iff known is NaN\n      // eslint-disable-next-line no-self-compare\n\n\n      if (known != null && known === known) {\n        return known;\n      }\n\n      return this.props.itemHeightGetter(i, key);\n    });\n\n    this._yPositions = new Positions(200); // _knownHeights is (item-key -> observed height) of list items\n\n    this._knownHeights = new Map();\n    this._startIndexDrawn = 2 ** 20;\n    this._endIndexDrawn = -(2 ** 20);\n    this._startIndex = 0;\n    this._endIndex = 0;\n    this._viewHeight = -1;\n    this._scrollTop = -1;\n    this._isScrolledOrResized = false;\n    this._htmlTopOffset = -1;\n    this._windowScrollListenerAdded = false; // _htmlElm is only relevant if props.windowScroller is true\n\n    this._htmlElm = document.documentElement;\n    this._wrapperElm = undefined;\n    this._itemHolderElm = undefined;\n  }\n\n  componentDidMount() {\n    if (this.props.windowScroller) {\n      if (this._wrapperElm) {\n        const {\n          top\n        } = this._wrapperElm.getBoundingClientRect();\n\n        this._htmlTopOffset = top + this._htmlElm.scrollTop;\n      }\n\n      window.addEventListener('scroll', this._onScroll);\n      this._windowScrollListenerAdded = true;\n    } else {\n      var _this$_wrapperElm;\n\n      // The wrapper element should be the one that handles the scrolling. Once we are not using scroll-canvas we can remove this.\n      this._wrapperElm = this.props.scrollElement;\n      (_this$_wrapperElm = this._wrapperElm) === null || _this$_wrapperElm === void 0 ? void 0 : _this$_wrapperElm.addEventListener('scroll', this._onScroll);\n    }\n  }\n\n  componentDidUpdate() {\n    if (this._itemHolderElm) {\n      this._scanItemHeights();\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._windowScrollListenerAdded) {\n      window.removeEventListener('scroll', this._onScroll);\n    } else {\n      var _this$_wrapperElm2;\n\n      (_this$_wrapperElm2 = this._wrapperElm) === null || _this$_wrapperElm2 === void 0 ? void 0 : _this$_wrapperElm2.removeEventListener('scroll', this._onScroll);\n    }\n  }\n\n  /**\n   * Returns true is the view height (scroll window) or scroll position have\n   * changed.\n   */\n  _isViewChanged() {\n    if (!this._wrapperElm) {\n      return false;\n    }\n\n    const useRoot = this.props.windowScroller;\n    const clientHeight = useRoot ? this._htmlElm.clientHeight : this._wrapperElm.clientHeight;\n    const scrollTop = useRoot ? this._htmlElm.scrollTop : this._wrapperElm.scrollTop;\n    return clientHeight !== this._viewHeight || scrollTop !== this._scrollTop;\n  }\n  /**\n   * Recalculate _startIndex and _endIndex, e.g. which items are in view.\n   */\n\n\n  _calcViewIndexes() {\n    const useRoot = this.props.windowScroller; // funky if statement is to satisfy flow\n\n    if (!useRoot) {\n      /* istanbul ignore next */\n      if (!this._wrapperElm) {\n        this._viewHeight = -1;\n        this._startIndex = 0;\n        this._endIndex = 0;\n        return;\n      }\n\n      this._viewHeight = this._wrapperElm.clientHeight;\n      this._scrollTop = this._wrapperElm.scrollTop;\n    } else {\n      this._viewHeight = window.innerHeight - this._htmlTopOffset;\n      this._scrollTop = window.scrollY;\n    }\n\n    const yStart = this._scrollTop;\n    const yEnd = this._scrollTop + this._viewHeight;\n    this._startIndex = this._yPositions.findFloorIndex(yStart, this._getHeight);\n    this._endIndex = this._yPositions.findFloorIndex(yEnd, this._getHeight);\n  }\n  /**\n   * Checked to see if the currently rendered items are sufficient, if not,\n   * force an update to trigger more items to be rendered.\n   */\n\n\n  render() {\n    const {\n      dataLength,\n      getKeyFromIndex,\n      initialDraw = DEFAULT_INITIAL_DRAW,\n      itemRenderer,\n      viewBuffer,\n      viewBufferMin\n    } = this.props;\n    const heightGetter = this._getHeight;\n    const items = [];\n    let start;\n    let end;\n\n    this._yPositions.profileData(dataLength);\n\n    if (!this._wrapperElm) {\n      start = 0;\n      end = (initialDraw < dataLength ? initialDraw : dataLength) - 1;\n    } else {\n      if (this._isViewChanged()) {\n        this._calcViewIndexes();\n      }\n\n      const maxStart = viewBufferMin > this._startIndex ? 0 : this._startIndex - viewBufferMin;\n      const minEnd = viewBufferMin < dataLength - this._endIndex ? this._endIndex + viewBufferMin : dataLength - 1;\n\n      if (maxStart < this._startIndexDrawn || minEnd > this._endIndexDrawn) {\n        start = viewBuffer > this._startIndex ? 0 : this._startIndex - viewBuffer;\n        end = this._endIndex + viewBuffer;\n\n        if (end >= dataLength) {\n          end = dataLength - 1;\n        }\n      } else {\n        start = this._startIndexDrawn;\n        end = this._endIndexDrawn > dataLength - 1 ? dataLength - 1 : this._endIndexDrawn;\n      }\n    }\n\n    this._yPositions.calcHeights(end, heightGetter, start || -1);\n\n    this._startIndexDrawn = start;\n    this._endIndexDrawn = end;\n    items.length = end - start + 1;\n\n    for (let i = start; i <= end; i++) {\n      const {\n        y: top,\n        height\n      } = this._yPositions.getRowPosition(i, heightGetter);\n\n      const style = {\n        height,\n        top,\n        position: 'absolute'\n      };\n      const itemKey = getKeyFromIndex(i);\n      const attrs = {\n        'data-item-key': itemKey\n      };\n      items.push(itemRenderer(itemKey, style, i, attrs));\n    }\n\n    const wrapperProps = {\n      style: {\n        position: 'relative'\n      },\n      ref: this._initWrapper\n    };\n\n    if (!this.props.windowScroller) {\n      wrapperProps.onScroll = this._onScroll;\n      wrapperProps.style.height = '100%';\n      wrapperProps.style.overflowY = 'auto';\n    }\n\n    const scrollerStyle = {\n      position: 'relative',\n      height: this._yPositions.getEstimatedHeight()\n    };\n    return /*#__PURE__*/_jsx(\"div\", Object.assign({}, wrapperProps, {\n      children: /*#__PURE__*/_jsx(\"div\", {\n        style: scrollerStyle,\n        children: /*#__PURE__*/_jsx(\"div\", {\n          style: {\n            position: 'absolute',\n            top: 0,\n            margin: 0,\n            padding: 0\n          },\n          className: this.props.itemsWrapperClassName,\n          ref: this._initItemHolder,\n          children: items\n        })\n      })\n    }));\n  }\n\n}\n\n_defineProperty(ListView, \"defaultProps\", {\n  initialDraw: DEFAULT_INITIAL_DRAW,\n  itemsWrapperClassName: '',\n  windowScroller: false\n});","map":{"version":3,"names":["React","Positions","DEFAULT_INITIAL_DRAW","ListView","Component","constructor","props","_viewHeight","bottomY","_scrollTop","_yPositions","findFloorIndex","_getHeight","index","getRowPosition","scrollElement","scrollElementTop","getBoundingClientRect","top","listViewTop","scrollTop","_itemHolderElm","listViewOffset","itemOffset","y","scrollTo","_isScrolledOrResized","window","requestAnimationFrame","_positionList","_wrapperElm","_calcViewIndexes","maxStart","viewBufferMin","_startIndex","minEnd","dataLength","_endIndex","_startIndexDrawn","_endIndexDrawn","forceUpdate","elm","windowScroller","clientHeight","_scanItemHeights","getIndexFromKey","lowDirtyKey","highDirtyKey","isDirty","nodes","childNodes","max","length","i","node","itemKey","getAttribute","console","warn","measureSrc","firstElementChild","observed","known","_knownHeights","get","set","imin","imax","calcHeights","key","getKeyFromIndex","itemHeightGetter","Map","_htmlTopOffset","_windowScrollListenerAdded","_htmlElm","document","documentElement","undefined","componentDidMount","addEventListener","_onScroll","componentDidUpdate","componentWillUnmount","removeEventListener","_isViewChanged","useRoot","innerHeight","scrollY","yStart","yEnd","render","initialDraw","itemRenderer","viewBuffer","heightGetter","items","start","end","profileData","height","style","position","attrs","push","wrapperProps","ref","_initWrapper","onScroll","overflowY","scrollerStyle","getEstimatedHeight","margin","padding","itemsWrapperClassName","_initItemHolder"],"sources":["/home/soula/grafana/packages/jaeger-ui-components/src/TraceTimelineViewer/ListView/index.tsx"],"sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport * as React from 'react';\n\nimport { TNil } from '../../types';\n\nimport Positions from './Positions';\n\ntype TWrapperProps = {\n  style: React.CSSProperties;\n  ref: (elm: HTMLDivElement) => void;\n  onScroll?: () => void;\n};\n\n/**\n * @typedef\n */\ntype TListViewProps = {\n  /**\n   * Number of elements in the list.\n   */\n  dataLength: number;\n  /**\n   * Convert item index (number) to the key (string). ListView uses both indexes\n   * and keys to handle the addition of new rows.\n   */\n  getIndexFromKey: (key: string) => number;\n  /**\n   * Convert item key (string) to the index (number). ListView uses both indexes\n   * and keys to handle the addition of new rows.\n   */\n  getKeyFromIndex: (index: number) => string;\n  /**\n   * Number of items to draw and add to the DOM, initially.\n   */\n  initialDraw?: number;\n  /**\n   * The parent provides fallback height measurements when there is not a\n   * rendered element to measure.\n   */\n  itemHeightGetter: (index: number, key: string) => number;\n  /**\n   * Function that renders an item; rendered items are added directly to the\n   * DOM, they are not wrapped in list item wrapper HTMLElement.\n   */\n  // itemRenderer(itemKey, style, i, attrs)\n  itemRenderer: (\n    itemKey: string,\n    style: Record<string, string | number>,\n    index: number,\n    attributes: Record<string, string>\n  ) => React.ReactNode;\n  /**\n   * `className` for the HTMLElement that holds the items.\n   */\n  itemsWrapperClassName?: string;\n  /**\n   * When adding new items to the DOM, this is the number of items to add above\n   * and below the current view. E.g. if list is 100 items and is scrolled\n   * halfway down (so items [46, 55] are in view), then when a new range of\n   * items is rendered, it will render items `46 - viewBuffer` to\n   * `55 + viewBuffer`.\n   */\n  viewBuffer: number;\n  /**\n   * The minimum number of items offscreen in either direction; e.g. at least\n   * `viewBuffer` number of items must be off screen above and below the\n   * current view, or more items will be rendered.\n   */\n  viewBufferMin: number;\n  /**\n   * When `true`, expect `_wrapperElm` to have `overflow: visible` and to,\n   * essentially, be tall to the point the entire page will will end up\n   * scrolling as a result of the ListView. Similar to react-virtualized\n   * window scroller.\n   *\n   * - Ref: https://bvaughn.github.io/react-virtualized/#/components/WindowScroller\n   * - Ref:https://github.com/bvaughn/react-virtualized/blob/497e2a1942529560681d65a9ef9f5e9c9c9a49ba/docs/WindowScroller.md\n   */\n  windowScroller?: boolean;\n  /**\n   * You need to pass in scrollElement when windowScroller is set to false.\n   * This element is responsible for tracking scrolling for lazy loading.\n   */\n  scrollElement?: Element;\n};\n\nconst DEFAULT_INITIAL_DRAW = 100;\n\n/**\n * Virtualized list view component, for the most part, only renders the window\n * of items that are in-view with some buffer before and after. Listens for\n * scroll events and updates which items are rendered. See react-virtualized\n * for a suite of components with similar, but generalized, functionality.\n * https://github.com/bvaughn/react-virtualized\n *\n * Note: Presently, ListView cannot be a PureComponent. This is because ListView\n * is sensitive to the underlying state that drives the list items, but it\n * doesn't actually receive that state. So, a render may still be required even\n * if ListView's props are unchanged.\n *\n * @export\n * @class ListView\n */\nexport default class ListView extends React.Component<TListViewProps> {\n  /**\n   * Keeps track of the height and y-value of items, by item index, in the\n   * ListView.\n   */\n  _yPositions: Positions;\n  /**\n   * Keep track of the known / measured heights of the rendered items; populated\n   * with values through observation and keyed on the item key, not the item\n   * index.\n   */\n  _knownHeights: Map<string, number>;\n  /**\n   * The start index of the items currently drawn.\n   */\n  _startIndexDrawn: number;\n  /**\n   * The end index of the items currently drawn.\n   */\n  _endIndexDrawn: number;\n  /**\n   * The start index of the items currently in view.\n   */\n  _startIndex: number;\n  /**\n   * The end index of the items currently in view.\n   */\n  _endIndex: number;\n  /**\n   * Height of the visual window, e.g. height of the scroller element.\n   */\n  _viewHeight: number;\n  /**\n   * `scrollTop` of the current scroll position.\n   */\n  _scrollTop: number;\n  /**\n   * Used to keep track of whether or not a re-calculation of what should be\n   * drawn / viewable has been scheduled.\n   */\n  _isScrolledOrResized: boolean;\n  /**\n   * If `windowScroller` is true, this notes how far down the page the scroller\n   * is located. (Note: repositioning and below-the-fold views are untested)\n   */\n  _htmlTopOffset: number;\n  _windowScrollListenerAdded: boolean;\n  _htmlElm: HTMLElement;\n  /**\n   * Element holding the scroller.\n   */\n  _wrapperElm: Element | TNil;\n  /**\n   * HTMLElement holding the rendered items.\n   */\n  _itemHolderElm: HTMLElement | TNil;\n\n  static defaultProps = {\n    initialDraw: DEFAULT_INITIAL_DRAW,\n    itemsWrapperClassName: '',\n    windowScroller: false,\n  };\n\n  constructor(props: TListViewProps) {\n    super(props);\n\n    this._yPositions = new Positions(200);\n    // _knownHeights is (item-key -> observed height) of list items\n    this._knownHeights = new Map();\n\n    this._startIndexDrawn = 2 ** 20;\n    this._endIndexDrawn = -(2 ** 20);\n    this._startIndex = 0;\n    this._endIndex = 0;\n    this._viewHeight = -1;\n    this._scrollTop = -1;\n    this._isScrolledOrResized = false;\n\n    this._htmlTopOffset = -1;\n    this._windowScrollListenerAdded = false;\n    // _htmlElm is only relevant if props.windowScroller is true\n    this._htmlElm = document.documentElement as any;\n    this._wrapperElm = undefined;\n    this._itemHolderElm = undefined;\n  }\n\n  componentDidMount() {\n    if (this.props.windowScroller) {\n      if (this._wrapperElm) {\n        const { top } = this._wrapperElm.getBoundingClientRect();\n        this._htmlTopOffset = top + this._htmlElm.scrollTop;\n      }\n      window.addEventListener('scroll', this._onScroll);\n      this._windowScrollListenerAdded = true;\n    } else {\n      // The wrapper element should be the one that handles the scrolling. Once we are not using scroll-canvas we can remove this.\n      this._wrapperElm = this.props.scrollElement;\n      this._wrapperElm?.addEventListener('scroll', this._onScroll);\n    }\n  }\n\n  componentDidUpdate() {\n    if (this._itemHolderElm) {\n      this._scanItemHeights();\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._windowScrollListenerAdded) {\n      window.removeEventListener('scroll', this._onScroll);\n    } else {\n      this._wrapperElm?.removeEventListener('scroll', this._onScroll);\n    }\n  }\n\n  getViewHeight = () => this._viewHeight;\n\n  /**\n   * Get the index of the item at the bottom of the current view.\n   */\n  getBottomVisibleIndex = (): number => {\n    const bottomY = this._scrollTop + this._viewHeight;\n    return this._yPositions.findFloorIndex(bottomY, this._getHeight);\n  };\n\n  /**\n   * Get the index of the item at the top of the current view.\n   */\n  getTopVisibleIndex = (): number => this._yPositions.findFloorIndex(this._scrollTop, this._getHeight);\n\n  getRowPosition = (index: number): { height: number; y: number } =>\n    this._yPositions.getRowPosition(index, this._getHeight);\n\n  scrollToIndex = (index: number) => {\n    // calculate the position of the list view relative to the scroll parent\n    const { scrollElement } = this.props;\n    const scrollElementTop = scrollElement?.getBoundingClientRect().top || 0;\n    const listViewTop = (scrollElement?.scrollTop || 0) + (this._itemHolderElm?.getBoundingClientRect().top || 0);\n    const listViewOffset = listViewTop - scrollElementTop;\n\n    const itemOffset = this.getRowPosition(index).y;\n\n    // hard code a small offset to leave a little bit of space above the focused span, so it is visually clear\n    // that there is content above\n    this.props.scrollElement?.scrollTo({ top: itemOffset + listViewOffset - 80 });\n  };\n\n  /**\n   * Scroll event listener that schedules a remeasuring of which items should be\n   * rendered.\n   */\n  _onScroll = () => {\n    if (!this._isScrolledOrResized) {\n      this._isScrolledOrResized = true;\n      window.requestAnimationFrame(this._positionList);\n    }\n  };\n\n  /**\n   * Returns true is the view height (scroll window) or scroll position have\n   * changed.\n   */\n  _isViewChanged() {\n    if (!this._wrapperElm) {\n      return false;\n    }\n    const useRoot = this.props.windowScroller;\n    const clientHeight = useRoot ? this._htmlElm.clientHeight : this._wrapperElm.clientHeight;\n    const scrollTop = useRoot ? this._htmlElm.scrollTop : this._wrapperElm.scrollTop;\n    return clientHeight !== this._viewHeight || scrollTop !== this._scrollTop;\n  }\n\n  /**\n   * Recalculate _startIndex and _endIndex, e.g. which items are in view.\n   */\n  _calcViewIndexes() {\n    const useRoot = this.props.windowScroller;\n    // funky if statement is to satisfy flow\n    if (!useRoot) {\n      /* istanbul ignore next */\n      if (!this._wrapperElm) {\n        this._viewHeight = -1;\n        this._startIndex = 0;\n        this._endIndex = 0;\n        return;\n      }\n      this._viewHeight = this._wrapperElm.clientHeight;\n      this._scrollTop = this._wrapperElm.scrollTop;\n    } else {\n      this._viewHeight = window.innerHeight - this._htmlTopOffset;\n      this._scrollTop = window.scrollY;\n    }\n    const yStart = this._scrollTop;\n    const yEnd = this._scrollTop + this._viewHeight;\n    this._startIndex = this._yPositions.findFloorIndex(yStart, this._getHeight);\n    this._endIndex = this._yPositions.findFloorIndex(yEnd, this._getHeight);\n  }\n\n  /**\n   * Checked to see if the currently rendered items are sufficient, if not,\n   * force an update to trigger more items to be rendered.\n   */\n  _positionList = () => {\n    this._isScrolledOrResized = false;\n    if (!this._wrapperElm) {\n      return;\n    }\n    this._calcViewIndexes();\n    // indexes drawn should be padded by at least props.viewBufferMin\n    const maxStart = this.props.viewBufferMin > this._startIndex ? 0 : this._startIndex - this.props.viewBufferMin;\n    const minEnd =\n      this.props.viewBufferMin < this.props.dataLength - this._endIndex\n        ? this._endIndex + this.props.viewBufferMin\n        : this.props.dataLength - 1;\n    if (maxStart < this._startIndexDrawn || minEnd > this._endIndexDrawn) {\n      this.forceUpdate();\n    }\n  };\n\n  _initWrapper = (elm: HTMLElement | TNil) => {\n    if (!this.props.windowScroller) {\n      return;\n    }\n    this._wrapperElm = elm;\n    if (elm) {\n      this._viewHeight = elm.clientHeight;\n    }\n  };\n\n  _initItemHolder = (elm: HTMLElement | TNil) => {\n    this._itemHolderElm = elm;\n    this._scanItemHeights();\n  };\n\n  /**\n   * Go through all items that are rendered and save their height based on their\n   * item-key (which is on a data-* attribute). If any new or adjusted heights\n   * are found, re-measure the current known y-positions (via .yPositions).\n   */\n  _scanItemHeights = () => {\n    const getIndexFromKey = this.props.getIndexFromKey;\n    if (!this._itemHolderElm) {\n      return;\n    }\n    // note the keys for the first and last altered heights, the `yPositions`\n    // needs to be updated\n    let lowDirtyKey = null;\n    let highDirtyKey = null;\n    let isDirty = false;\n    // iterating childNodes is faster than children\n    // https://jsperf.com/large-htmlcollection-vs-large-nodelist\n    const nodes = this._itemHolderElm.childNodes;\n    const max = nodes.length;\n    for (let i = 0; i < max; i++) {\n      const node: HTMLElement = nodes[i] as any;\n      // use `.getAttribute(...)` instead of `.dataset` for jest / JSDOM\n      const itemKey = node.getAttribute('data-item-key');\n      if (!itemKey) {\n        // eslint-disable-next-line no-console\n        console.warn('itemKey not found');\n        continue;\n      }\n      // measure the first child, if it's available, otherwise the node itself\n      // (likely not transferable to other contexts, and instead is specific to\n      // how we have the items rendered)\n      const measureSrc: Element = node.firstElementChild || node;\n      const observed = measureSrc.clientHeight;\n      const known = this._knownHeights.get(itemKey);\n      if (observed !== known) {\n        this._knownHeights.set(itemKey, observed);\n        if (!isDirty) {\n          isDirty = true;\n          // eslint-disable-next-line no-multi-assign\n          lowDirtyKey = highDirtyKey = itemKey;\n        } else {\n          highDirtyKey = itemKey;\n        }\n      }\n    }\n    if (lowDirtyKey != null && highDirtyKey != null) {\n      // update yPositions, then redraw\n      const imin = getIndexFromKey(lowDirtyKey);\n      const imax = highDirtyKey === lowDirtyKey ? imin : getIndexFromKey(highDirtyKey);\n      this._yPositions.calcHeights(imax, this._getHeight, imin);\n      this.forceUpdate();\n    }\n  };\n\n  /**\n   * Get the height of the element at index `i`; first check the known heights,\n   * fallback to `.props.itemHeightGetter(...)`.\n   */\n  _getHeight = (i: number) => {\n    const key = this.props.getKeyFromIndex(i);\n    const known = this._knownHeights.get(key);\n    // known !== known iff known is NaN\n    // eslint-disable-next-line no-self-compare\n    if (known != null && known === known) {\n      return known;\n    }\n    return this.props.itemHeightGetter(i, key);\n  };\n\n  render() {\n    const {\n      dataLength,\n      getKeyFromIndex,\n      initialDraw = DEFAULT_INITIAL_DRAW,\n      itemRenderer,\n      viewBuffer,\n      viewBufferMin,\n    } = this.props;\n    const heightGetter = this._getHeight;\n    const items = [];\n    let start;\n    let end;\n\n    this._yPositions.profileData(dataLength);\n\n    if (!this._wrapperElm) {\n      start = 0;\n      end = (initialDraw < dataLength ? initialDraw : dataLength) - 1;\n    } else {\n      if (this._isViewChanged()) {\n        this._calcViewIndexes();\n      }\n      const maxStart = viewBufferMin > this._startIndex ? 0 : this._startIndex - viewBufferMin;\n      const minEnd = viewBufferMin < dataLength - this._endIndex ? this._endIndex + viewBufferMin : dataLength - 1;\n      if (maxStart < this._startIndexDrawn || minEnd > this._endIndexDrawn) {\n        start = viewBuffer > this._startIndex ? 0 : this._startIndex - viewBuffer;\n        end = this._endIndex + viewBuffer;\n        if (end >= dataLength) {\n          end = dataLength - 1;\n        }\n      } else {\n        start = this._startIndexDrawn;\n        end = this._endIndexDrawn > dataLength - 1 ? dataLength - 1 : this._endIndexDrawn;\n      }\n    }\n\n    this._yPositions.calcHeights(end, heightGetter, start || -1);\n    this._startIndexDrawn = start;\n    this._endIndexDrawn = end;\n\n    items.length = end - start + 1;\n    for (let i = start; i <= end; i++) {\n      const { y: top, height } = this._yPositions.getRowPosition(i, heightGetter);\n      const style = {\n        height,\n        top,\n        position: 'absolute',\n      };\n      const itemKey = getKeyFromIndex(i);\n      const attrs = { 'data-item-key': itemKey };\n      items.push(itemRenderer(itemKey, style, i, attrs));\n    }\n    const wrapperProps: TWrapperProps = {\n      style: { position: 'relative' },\n      ref: this._initWrapper,\n    };\n    if (!this.props.windowScroller) {\n      wrapperProps.onScroll = this._onScroll;\n      wrapperProps.style.height = '100%';\n      wrapperProps.style.overflowY = 'auto';\n    }\n    const scrollerStyle = {\n      position: 'relative' as 'relative',\n      height: this._yPositions.getEstimatedHeight(),\n    };\n    return (\n      <div {...wrapperProps}>\n        <div style={scrollerStyle}>\n          <div\n            style={{\n              position: 'absolute',\n              top: 0,\n              margin: 0,\n              padding: 0,\n            }}\n            className={this.props.itemsWrapperClassName}\n            ref={this._initItemHolder}\n          >\n            {items}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAIA,OAAOC,SAAP,MAAsB,aAAtB;;AAiFA,MAAMC,oBAAoB,GAAG,GAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,QAAN,SAAuBH,KAAK,CAACI,SAA7B,CAAuD;EACpE;AACF;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;;EAEE;AACF;AACA;;EAEE;AACF;AACA;;EAEE;AACF;AACA;;EAEE;AACF;AACA;;EAEE;AACF;AACA;;EAEE;AACF;AACA;AACA;;EAEE;AACF;AACA;AACA;;EAIE;AACF;AACA;;EAEE;AACF;AACA;EASEC,WAAW,CAACC,KAAD,EAAwB;IACjC,MAAMA,KAAN;;IADiC;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA,uCAoDnB,MAAM,KAAKC,WApDQ;;IAAA,+CAyDX,MAAc;MACpC,MAAMC,OAAO,GAAG,KAAKC,UAAL,GAAkB,KAAKF,WAAvC;MACA,OAAO,KAAKG,WAAL,CAAiBC,cAAjB,CAAgCH,OAAhC,EAAyC,KAAKI,UAA9C,CAAP;IACD,CA5DkC;;IAAA,4CAiEd,MAAc,KAAKF,WAAL,CAAiBC,cAAjB,CAAgC,KAAKF,UAArC,EAAiD,KAAKG,UAAtD,CAjEA;;IAAA,wCAmEjBC,KAAD,IACf,KAAKH,WAAL,CAAiBI,cAAjB,CAAgCD,KAAhC,EAAuC,KAAKD,UAA5C,CApEiC;;IAAA,uCAsElBC,KAAD,IAAmB;MAAA;;MACjC;MACA,MAAM;QAAEE;MAAF,IAAoB,KAAKT,KAA/B;MACA,MAAMU,gBAAgB,GAAG,CAAAD,aAAa,SAAb,IAAAA,aAAa,WAAb,YAAAA,aAAa,CAAEE,qBAAf,GAAuCC,GAAvC,KAA8C,CAAvE;MACA,MAAMC,WAAW,GAAG,CAAC,CAAAJ,aAAa,SAAb,IAAAA,aAAa,WAAb,YAAAA,aAAa,CAAEK,SAAf,KAA4B,CAA7B,KAAmC,8BAAKC,cAAL,8EAAqBJ,qBAArB,GAA6CC,GAA7C,KAAoD,CAAvF,CAApB;MACA,MAAMI,cAAc,GAAGH,WAAW,GAAGH,gBAArC;MAEA,MAAMO,UAAU,GAAG,KAAKT,cAAL,CAAoBD,KAApB,EAA2BW,CAA9C,CAPiC,CASjC;MACA;;MACA,8BAAKlB,KAAL,CAAWS,aAAX,gFAA0BU,QAA1B,CAAmC;QAAEP,GAAG,EAAEK,UAAU,GAAGD,cAAb,GAA8B;MAArC,CAAnC;IACD,CAlFkC;;IAAA,mCAwFvB,MAAM;MAChB,IAAI,CAAC,KAAKI,oBAAV,EAAgC;QAC9B,KAAKA,oBAAL,GAA4B,IAA5B;QACAC,MAAM,CAACC,qBAAP,CAA6B,KAAKC,aAAlC;MACD;IACF,CA7FkC;;IAAA,uCA2InB,MAAM;MACpB,KAAKH,oBAAL,GAA4B,KAA5B;;MACA,IAAI,CAAC,KAAKI,WAAV,EAAuB;QACrB;MACD;;MACD,KAAKC,gBAAL,GALoB,CAMpB;;;MACA,MAAMC,QAAQ,GAAG,KAAK1B,KAAL,CAAW2B,aAAX,GAA2B,KAAKC,WAAhC,GAA8C,CAA9C,GAAkD,KAAKA,WAAL,GAAmB,KAAK5B,KAAL,CAAW2B,aAAjG;MACA,MAAME,MAAM,GACV,KAAK7B,KAAL,CAAW2B,aAAX,GAA2B,KAAK3B,KAAL,CAAW8B,UAAX,GAAwB,KAAKC,SAAxD,GACI,KAAKA,SAAL,GAAiB,KAAK/B,KAAL,CAAW2B,aADhC,GAEI,KAAK3B,KAAL,CAAW8B,UAAX,GAAwB,CAH9B;;MAIA,IAAIJ,QAAQ,GAAG,KAAKM,gBAAhB,IAAoCH,MAAM,GAAG,KAAKI,cAAtD,EAAsE;QACpE,KAAKC,WAAL;MACD;IACF,CA1JkC;;IAAA,sCA4JnBC,GAAD,IAA6B;MAC1C,IAAI,CAAC,KAAKnC,KAAL,CAAWoC,cAAhB,EAAgC;QAC9B;MACD;;MACD,KAAKZ,WAAL,GAAmBW,GAAnB;;MACA,IAAIA,GAAJ,EAAS;QACP,KAAKlC,WAAL,GAAmBkC,GAAG,CAACE,YAAvB;MACD;IACF,CApKkC;;IAAA,yCAsKhBF,GAAD,IAA6B;MAC7C,KAAKpB,cAAL,GAAsBoB,GAAtB;;MACA,KAAKG,gBAAL;IACD,CAzKkC;;IAAA,0CAgLhB,MAAM;MACvB,MAAMC,eAAe,GAAG,KAAKvC,KAAL,CAAWuC,eAAnC;;MACA,IAAI,CAAC,KAAKxB,cAAV,EAA0B;QACxB;MACD,CAJsB,CAKvB;MACA;;;MACA,IAAIyB,WAAW,GAAG,IAAlB;MACA,IAAIC,YAAY,GAAG,IAAnB;MACA,IAAIC,OAAO,GAAG,KAAd,CATuB,CAUvB;MACA;;MACA,MAAMC,KAAK,GAAG,KAAK5B,cAAL,CAAoB6B,UAAlC;MACA,MAAMC,GAAG,GAAGF,KAAK,CAACG,MAAlB;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,EAA1B,EAA8B;QAC5B,MAAMC,IAAiB,GAAGL,KAAK,CAACI,CAAD,CAA/B,CAD4B,CAE5B;;QACA,MAAME,OAAO,GAAGD,IAAI,CAACE,YAAL,CAAkB,eAAlB,CAAhB;;QACA,IAAI,CAACD,OAAL,EAAc;UACZ;UACAE,OAAO,CAACC,IAAR,CAAa,mBAAb;UACA;QACD,CAR2B,CAS5B;QACA;QACA;;;QACA,MAAMC,UAAmB,GAAGL,IAAI,CAACM,iBAAL,IAA0BN,IAAtD;QACA,MAAMO,QAAQ,GAAGF,UAAU,CAAChB,YAA5B;;QACA,MAAMmB,KAAK,GAAG,KAAKC,aAAL,CAAmBC,GAAnB,CAAuBT,OAAvB,CAAd;;QACA,IAAIM,QAAQ,KAAKC,KAAjB,EAAwB;UACtB,KAAKC,aAAL,CAAmBE,GAAnB,CAAuBV,OAAvB,EAAgCM,QAAhC;;UACA,IAAI,CAACb,OAAL,EAAc;YACZA,OAAO,GAAG,IAAV,CADY,CAEZ;;YACAF,WAAW,GAAGC,YAAY,GAAGQ,OAA7B;UACD,CAJD,MAIO;YACLR,YAAY,GAAGQ,OAAf;UACD;QACF;MACF;;MACD,IAAIT,WAAW,IAAI,IAAf,IAAuBC,YAAY,IAAI,IAA3C,EAAiD;QAC/C;QACA,MAAMmB,IAAI,GAAGrB,eAAe,CAACC,WAAD,CAA5B;QACA,MAAMqB,IAAI,GAAGpB,YAAY,KAAKD,WAAjB,GAA+BoB,IAA/B,GAAsCrB,eAAe,CAACE,YAAD,CAAlE;;QACA,KAAKrC,WAAL,CAAiB0D,WAAjB,CAA6BD,IAA7B,EAAmC,KAAKvD,UAAxC,EAAoDsD,IAApD;;QACA,KAAK1B,WAAL;MACD;IACF,CA/NkC;;IAAA,oCAqOrBa,CAAD,IAAe;MAC1B,MAAMgB,GAAG,GAAG,KAAK/D,KAAL,CAAWgE,eAAX,CAA2BjB,CAA3B,CAAZ;;MACA,MAAMS,KAAK,GAAG,KAAKC,aAAL,CAAmBC,GAAnB,CAAuBK,GAAvB,CAAd,CAF0B,CAG1B;MACA;;;MACA,IAAIP,KAAK,IAAI,IAAT,IAAiBA,KAAK,KAAKA,KAA/B,EAAsC;QACpC,OAAOA,KAAP;MACD;;MACD,OAAO,KAAKxD,KAAL,CAAWiE,gBAAX,CAA4BlB,CAA5B,EAA+BgB,GAA/B,CAAP;IACD,CA9OkC;;IAGjC,KAAK3D,WAAL,GAAmB,IAAIT,SAAJ,CAAc,GAAd,CAAnB,CAHiC,CAIjC;;IACA,KAAK8D,aAAL,GAAqB,IAAIS,GAAJ,EAArB;IAEA,KAAKlC,gBAAL,GAAwB,KAAK,EAA7B;IACA,KAAKC,cAAL,GAAsB,EAAE,KAAK,EAAP,CAAtB;IACA,KAAKL,WAAL,GAAmB,CAAnB;IACA,KAAKG,SAAL,GAAiB,CAAjB;IACA,KAAK9B,WAAL,GAAmB,CAAC,CAApB;IACA,KAAKE,UAAL,GAAkB,CAAC,CAAnB;IACA,KAAKiB,oBAAL,GAA4B,KAA5B;IAEA,KAAK+C,cAAL,GAAsB,CAAC,CAAvB;IACA,KAAKC,0BAAL,GAAkC,KAAlC,CAhBiC,CAiBjC;;IACA,KAAKC,QAAL,GAAgBC,QAAQ,CAACC,eAAzB;IACA,KAAK/C,WAAL,GAAmBgD,SAAnB;IACA,KAAKzD,cAAL,GAAsByD,SAAtB;EACD;;EAEDC,iBAAiB,GAAG;IAClB,IAAI,KAAKzE,KAAL,CAAWoC,cAAf,EAA+B;MAC7B,IAAI,KAAKZ,WAAT,EAAsB;QACpB,MAAM;UAAEZ;QAAF,IAAU,KAAKY,WAAL,CAAiBb,qBAAjB,EAAhB;;QACA,KAAKwD,cAAL,GAAsBvD,GAAG,GAAG,KAAKyD,QAAL,CAAcvD,SAA1C;MACD;;MACDO,MAAM,CAACqD,gBAAP,CAAwB,QAAxB,EAAkC,KAAKC,SAAvC;MACA,KAAKP,0BAAL,GAAkC,IAAlC;IACD,CAPD,MAOO;MAAA;;MACL;MACA,KAAK5C,WAAL,GAAmB,KAAKxB,KAAL,CAAWS,aAA9B;MACA,0BAAKe,WAAL,wEAAkBkD,gBAAlB,CAAmC,QAAnC,EAA6C,KAAKC,SAAlD;IACD;EACF;;EAEDC,kBAAkB,GAAG;IACnB,IAAI,KAAK7D,cAAT,EAAyB;MACvB,KAAKuB,gBAAL;IACD;EACF;;EAEDuC,oBAAoB,GAAG;IACrB,IAAI,KAAKT,0BAAT,EAAqC;MACnC/C,MAAM,CAACyD,mBAAP,CAA2B,QAA3B,EAAqC,KAAKH,SAA1C;IACD,CAFD,MAEO;MAAA;;MACL,2BAAKnD,WAAL,0EAAkBsD,mBAAlB,CAAsC,QAAtC,EAAgD,KAAKH,SAArD;IACD;EACF;;EA6CD;AACF;AACA;AACA;EACEI,cAAc,GAAG;IACf,IAAI,CAAC,KAAKvD,WAAV,EAAuB;MACrB,OAAO,KAAP;IACD;;IACD,MAAMwD,OAAO,GAAG,KAAKhF,KAAL,CAAWoC,cAA3B;IACA,MAAMC,YAAY,GAAG2C,OAAO,GAAG,KAAKX,QAAL,CAAchC,YAAjB,GAAgC,KAAKb,WAAL,CAAiBa,YAA7E;IACA,MAAMvB,SAAS,GAAGkE,OAAO,GAAG,KAAKX,QAAL,CAAcvD,SAAjB,GAA6B,KAAKU,WAAL,CAAiBV,SAAvE;IACA,OAAOuB,YAAY,KAAK,KAAKpC,WAAtB,IAAqCa,SAAS,KAAK,KAAKX,UAA/D;EACD;EAED;AACF;AACA;;;EACEsB,gBAAgB,GAAG;IACjB,MAAMuD,OAAO,GAAG,KAAKhF,KAAL,CAAWoC,cAA3B,CADiB,CAEjB;;IACA,IAAI,CAAC4C,OAAL,EAAc;MACZ;MACA,IAAI,CAAC,KAAKxD,WAAV,EAAuB;QACrB,KAAKvB,WAAL,GAAmB,CAAC,CAApB;QACA,KAAK2B,WAAL,GAAmB,CAAnB;QACA,KAAKG,SAAL,GAAiB,CAAjB;QACA;MACD;;MACD,KAAK9B,WAAL,GAAmB,KAAKuB,WAAL,CAAiBa,YAApC;MACA,KAAKlC,UAAL,GAAkB,KAAKqB,WAAL,CAAiBV,SAAnC;IACD,CAVD,MAUO;MACL,KAAKb,WAAL,GAAmBoB,MAAM,CAAC4D,WAAP,GAAqB,KAAKd,cAA7C;MACA,KAAKhE,UAAL,GAAkBkB,MAAM,CAAC6D,OAAzB;IACD;;IACD,MAAMC,MAAM,GAAG,KAAKhF,UAApB;IACA,MAAMiF,IAAI,GAAG,KAAKjF,UAAL,GAAkB,KAAKF,WAApC;IACA,KAAK2B,WAAL,GAAmB,KAAKxB,WAAL,CAAiBC,cAAjB,CAAgC8E,MAAhC,EAAwC,KAAK7E,UAA7C,CAAnB;IACA,KAAKyB,SAAL,GAAiB,KAAK3B,WAAL,CAAiBC,cAAjB,CAAgC+E,IAAhC,EAAsC,KAAK9E,UAA3C,CAAjB;EACD;EAED;AACF;AACA;AACA;;;EAsGE+E,MAAM,GAAG;IACP,MAAM;MACJvD,UADI;MAEJkC,eAFI;MAGJsB,WAAW,GAAG1F,oBAHV;MAIJ2F,YAJI;MAKJC,UALI;MAMJ7D;IANI,IAOF,KAAK3B,KAPT;IAQA,MAAMyF,YAAY,GAAG,KAAKnF,UAA1B;IACA,MAAMoF,KAAK,GAAG,EAAd;IACA,IAAIC,KAAJ;IACA,IAAIC,GAAJ;;IAEA,KAAKxF,WAAL,CAAiByF,WAAjB,CAA6B/D,UAA7B;;IAEA,IAAI,CAAC,KAAKN,WAAV,EAAuB;MACrBmE,KAAK,GAAG,CAAR;MACAC,GAAG,GAAG,CAACN,WAAW,GAAGxD,UAAd,GAA2BwD,WAA3B,GAAyCxD,UAA1C,IAAwD,CAA9D;IACD,CAHD,MAGO;MACL,IAAI,KAAKiD,cAAL,EAAJ,EAA2B;QACzB,KAAKtD,gBAAL;MACD;;MACD,MAAMC,QAAQ,GAAGC,aAAa,GAAG,KAAKC,WAArB,GAAmC,CAAnC,GAAuC,KAAKA,WAAL,GAAmBD,aAA3E;MACA,MAAME,MAAM,GAAGF,aAAa,GAAGG,UAAU,GAAG,KAAKC,SAAlC,GAA8C,KAAKA,SAAL,GAAiBJ,aAA/D,GAA+EG,UAAU,GAAG,CAA3G;;MACA,IAAIJ,QAAQ,GAAG,KAAKM,gBAAhB,IAAoCH,MAAM,GAAG,KAAKI,cAAtD,EAAsE;QACpE0D,KAAK,GAAGH,UAAU,GAAG,KAAK5D,WAAlB,GAAgC,CAAhC,GAAoC,KAAKA,WAAL,GAAmB4D,UAA/D;QACAI,GAAG,GAAG,KAAK7D,SAAL,GAAiByD,UAAvB;;QACA,IAAII,GAAG,IAAI9D,UAAX,EAAuB;UACrB8D,GAAG,GAAG9D,UAAU,GAAG,CAAnB;QACD;MACF,CAND,MAMO;QACL6D,KAAK,GAAG,KAAK3D,gBAAb;QACA4D,GAAG,GAAG,KAAK3D,cAAL,GAAsBH,UAAU,GAAG,CAAnC,GAAuCA,UAAU,GAAG,CAApD,GAAwD,KAAKG,cAAnE;MACD;IACF;;IAED,KAAK7B,WAAL,CAAiB0D,WAAjB,CAA6B8B,GAA7B,EAAkCH,YAAlC,EAAgDE,KAAK,IAAI,CAAC,CAA1D;;IACA,KAAK3D,gBAAL,GAAwB2D,KAAxB;IACA,KAAK1D,cAAL,GAAsB2D,GAAtB;IAEAF,KAAK,CAAC5C,MAAN,GAAe8C,GAAG,GAAGD,KAAN,GAAc,CAA7B;;IACA,KAAK,IAAI5C,CAAC,GAAG4C,KAAb,EAAoB5C,CAAC,IAAI6C,GAAzB,EAA8B7C,CAAC,EAA/B,EAAmC;MACjC,MAAM;QAAE7B,CAAC,EAAEN,GAAL;QAAUkF;MAAV,IAAqB,KAAK1F,WAAL,CAAiBI,cAAjB,CAAgCuC,CAAhC,EAAmC0C,YAAnC,CAA3B;;MACA,MAAMM,KAAK,GAAG;QACZD,MADY;QAEZlF,GAFY;QAGZoF,QAAQ,EAAE;MAHE,CAAd;MAKA,MAAM/C,OAAO,GAAGe,eAAe,CAACjB,CAAD,CAA/B;MACA,MAAMkD,KAAK,GAAG;QAAE,iBAAiBhD;MAAnB,CAAd;MACAyC,KAAK,CAACQ,IAAN,CAAWX,YAAY,CAACtC,OAAD,EAAU8C,KAAV,EAAiBhD,CAAjB,EAAoBkD,KAApB,CAAvB;IACD;;IACD,MAAME,YAA2B,GAAG;MAClCJ,KAAK,EAAE;QAAEC,QAAQ,EAAE;MAAZ,CAD2B;MAElCI,GAAG,EAAE,KAAKC;IAFwB,CAApC;;IAIA,IAAI,CAAC,KAAKrG,KAAL,CAAWoC,cAAhB,EAAgC;MAC9B+D,YAAY,CAACG,QAAb,GAAwB,KAAK3B,SAA7B;MACAwB,YAAY,CAACJ,KAAb,CAAmBD,MAAnB,GAA4B,MAA5B;MACAK,YAAY,CAACJ,KAAb,CAAmBQ,SAAnB,GAA+B,MAA/B;IACD;;IACD,MAAMC,aAAa,GAAG;MACpBR,QAAQ,EAAE,UADU;MAEpBF,MAAM,EAAE,KAAK1F,WAAL,CAAiBqG,kBAAjB;IAFY,CAAtB;IAIA,oBACE,8BAASN,YAAT;MAAA,uBACE;QAAK,KAAK,EAAEK,aAAZ;QAAA,uBACE;UACE,KAAK,EAAE;YACLR,QAAQ,EAAE,UADL;YAELpF,GAAG,EAAE,CAFA;YAGL8F,MAAM,EAAE,CAHH;YAILC,OAAO,EAAE;UAJJ,CADT;UAOE,SAAS,EAAE,KAAK3G,KAAL,CAAW4G,qBAPxB;UAQE,GAAG,EAAE,KAAKC,eARZ;UAAA,UAUGnB;QAVH;MADF;IADF,GADF;EAkBD;;AAnYmE;;gBAAjD7F,Q,kBAyDG;EACpByF,WAAW,EAAE1F,oBADO;EAEpBgH,qBAAqB,EAAE,EAFH;EAGpBxE,cAAc,EAAE;AAHI,C"},"metadata":{},"sourceType":"module"}