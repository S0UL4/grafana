{"ast":null,"code":"import { getMinMaxAndDelta } from '../../../../packages/grafana-data/src/field/scale';\nimport { findField, getLastNotNullFieldValue } from './utils';\nimport { ScaleDimensionMode } from '.'; //---------------------------------------------------------\n// Scale dimension\n//---------------------------------------------------------\n\nexport function getScaledDimension(frame, config) {\n  return getScaledDimensionForField(findField(frame, config === null || config === void 0 ? void 0 : config.field), config);\n}\nexport function getScaledDimensionForField(field, config, mode) {\n  if (!field) {\n    var _config$fixed, _config$field;\n\n    const v = (_config$fixed = config.fixed) !== null && _config$fixed !== void 0 ? _config$fixed : 0;\n    return {\n      isAssumed: Boolean((_config$field = config.field) === null || _config$field === void 0 ? void 0 : _config$field.length) || !config.fixed,\n      fixed: v,\n      value: () => v,\n      get: () => v\n    };\n  }\n\n  const info = getMinMaxAndDelta(field);\n  const delta = config.max - config.min;\n  const values = field.values;\n\n  if (values.length < 1 || delta <= 0 || info.delta <= 0) {\n    return {\n      fixed: config.min,\n      value: () => config.min,\n      get: () => config.min\n    };\n  }\n\n  let scaled = percent => config.min + percent * delta;\n\n  if (mode === ScaleDimensionMode.Quadratic) {\n    const maxArea = Math.PI * (config.max / 2) ** 2;\n    const minArea = Math.PI * (config.min / 2) ** 2;\n    const deltaArea = maxArea - minArea; // quadratic scaling (px area)\n\n    scaled = percent => {\n      let area = minArea + deltaArea * percent;\n      return Math.sqrt(area / Math.PI) * 2;\n    };\n  }\n\n  const get = i => {\n    const value = field.values.get(i);\n    let percent = 0;\n\n    if (value !== -Infinity) {\n      percent = (value - info.min) / info.delta;\n    }\n\n    if (percent > 1) {\n      percent = 1;\n    } else if (percent < 0) {\n      percent = 0;\n    }\n\n    return scaled(percent);\n  };\n\n  return {\n    get,\n    value: () => get(getLastNotNullFieldValue(field)),\n    field\n  };\n} // This will mutate options\n\nexport function validateScaleOptions(options) {\n  if (!options) {\n    options = {\n      min: 0,\n      max: 1\n    };\n  }\n\n  if (options.min == null) {\n    options.min = 0;\n  }\n\n  if (options.max == null) {\n    options.max = 1;\n  }\n\n  return options;\n}\n/** Mutates and will return a valid version */\n\nexport function validateScaleConfig(copy, options) {\n  let {\n    min,\n    max\n  } = validateScaleOptions(options);\n\n  if (!copy) {\n    copy = {};\n  }\n\n  if (copy.max == null) {\n    copy.max = max;\n  }\n\n  if (copy.min == null) {\n    copy.min = min;\n  } // Make sure the order is right\n\n\n  if (copy.min > copy.max) {\n    const tmp = copy.max;\n    copy.max = copy.min;\n    copy.min = tmp;\n  } // Validate range\n\n\n  if (copy.min < min) {\n    copy.min = min;\n  }\n\n  if (copy.max > max) {\n    copy.max = max;\n  }\n\n  if (copy.fixed == null) {\n    copy.fixed = copy.min + (copy.max - copy.min) / 2.0;\n  } // Make sure the field value is within the absolute range\n\n\n  if (!copy.field) {\n    if (copy.fixed > max) {\n      copy.fixed = max;\n    } else if (copy.fixed < min) {\n      copy.fixed = min;\n    }\n  }\n\n  return copy;\n}","map":{"version":3,"names":["getMinMaxAndDelta","findField","getLastNotNullFieldValue","ScaleDimensionMode","getScaledDimension","frame","config","getScaledDimensionForField","field","mode","v","fixed","isAssumed","Boolean","length","value","get","info","delta","max","min","values","scaled","percent","Quadratic","maxArea","Math","PI","minArea","deltaArea","area","sqrt","i","Infinity","validateScaleOptions","options","validateScaleConfig","copy","tmp"],"sources":["/home/soula/grafana/public/app/features/dimensions/scale.ts"],"sourcesContent":["import { DataFrame, Field } from '@grafana/data';\n\nimport { getMinMaxAndDelta } from '../../../../packages/grafana-data/src/field/scale';\n\nimport { ScaleDimensionConfig, DimensionSupplier, ScaleDimensionOptions } from './types';\nimport { findField, getLastNotNullFieldValue } from './utils';\n\nimport { ScaleDimensionMode } from '.';\n\n//---------------------------------------------------------\n// Scale dimension\n//---------------------------------------------------------\n\nexport function getScaledDimension(\n  frame: DataFrame | undefined,\n  config: ScaleDimensionConfig\n): DimensionSupplier<number> {\n  return getScaledDimensionForField(findField(frame, config?.field), config);\n}\n\nexport function getScaledDimensionForField(\n  field: Field | undefined,\n  config: ScaleDimensionConfig,\n  mode?: ScaleDimensionMode\n): DimensionSupplier<number> {\n  if (!field) {\n    const v = config.fixed ?? 0;\n    return {\n      isAssumed: Boolean(config.field?.length) || !config.fixed,\n      fixed: v,\n      value: () => v,\n      get: () => v,\n    };\n  }\n  const info = getMinMaxAndDelta(field);\n  const delta = config.max - config.min;\n  const values = field.values;\n  if (values.length < 1 || delta <= 0 || info.delta <= 0) {\n    return {\n      fixed: config.min,\n      value: () => config.min,\n      get: () => config.min,\n    };\n  }\n\n  let scaled = (percent: number) => config.min + percent * delta;\n  if (mode === ScaleDimensionMode.Quadratic) {\n    const maxArea = Math.PI * (config.max / 2) ** 2;\n    const minArea = Math.PI * (config.min / 2) ** 2;\n    const deltaArea = maxArea - minArea;\n\n    // quadratic scaling (px area)\n    scaled = (percent: number) => {\n      let area = minArea + deltaArea * percent;\n      return Math.sqrt(area / Math.PI) * 2;\n    };\n  }\n\n  const get = (i: number) => {\n    const value = field.values.get(i);\n    let percent = 0;\n    if (value !== -Infinity) {\n      percent = (value - info.min!) / info.delta;\n    }\n    if (percent > 1) {\n      percent = 1;\n    } else if (percent < 0) {\n      percent = 0;\n    }\n    return scaled(percent);\n  };\n\n  return {\n    get,\n    value: () => get(getLastNotNullFieldValue(field)),\n    field,\n  };\n}\n\n// This will mutate options\nexport function validateScaleOptions(options?: ScaleDimensionOptions): ScaleDimensionOptions {\n  if (!options) {\n    options = { min: 0, max: 1 };\n  }\n  if (options.min == null) {\n    options.min = 0;\n  }\n  if (options.max == null) {\n    options.max = 1;\n  }\n\n  return options;\n}\n\n/** Mutates and will return a valid version */\nexport function validateScaleConfig(copy: ScaleDimensionConfig, options: ScaleDimensionOptions): ScaleDimensionConfig {\n  let { min, max } = validateScaleOptions(options);\n  if (!copy) {\n    copy = {} as any;\n  }\n\n  if (copy.max == null) {\n    copy.max = max;\n  }\n  if (copy.min == null) {\n    copy.min = min;\n  }\n  // Make sure the order is right\n  if (copy.min > copy.max) {\n    const tmp = copy.max;\n    copy.max = copy.min;\n    copy.min = tmp;\n  }\n  // Validate range\n  if (copy.min < min) {\n    copy.min = min;\n  }\n  if (copy.max > max) {\n    copy.max = max;\n  }\n\n  if (copy.fixed == null) {\n    copy.fixed = copy.min + (copy.max - copy.min) / 2.0;\n  }\n\n  // Make sure the field value is within the absolute range\n  if (!copy.field) {\n    if (copy.fixed > max) {\n      copy.fixed = max;\n    } else if (copy.fixed < min) {\n      copy.fixed = min;\n    }\n  }\n  return copy;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}