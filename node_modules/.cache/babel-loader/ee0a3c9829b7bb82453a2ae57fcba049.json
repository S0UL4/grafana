{"ast":null,"code":"import { isArray } from 'lodash';\nimport { anyToNumber, FieldColorModeId, getFieldDisplayName, MappingType, ReducerID, ThresholdsMode, FieldType } from '@grafana/data';\n\n/**\n * Transforms a frame with fields to a map of field configs\n *\n * Input\n * | Unit        | Min | Max |\n * --------------------------------\n * | Temperature |  0  | 30  |\n * | Pressure    |  0  | 100 |\n *\n * Outputs\n * {\n    { min: 0, max: 100 },\n * }\n */\nexport function getFieldConfigFromFrame(frame, rowIndex, evaluatedMappings) {\n  const config = {};\n  const context = {};\n\n  for (const field of frame.fields) {\n    const fieldName = getFieldDisplayName(field, frame);\n    const mapping = evaluatedMappings.index[fieldName];\n    const handler = mapping.handler;\n\n    if (!handler) {\n      continue;\n    }\n\n    const configValue = field.values.get(rowIndex);\n\n    if (configValue === null || configValue === undefined) {\n      continue;\n    }\n\n    const newValue = handler.processor(configValue, config, context);\n\n    if (newValue != null) {\n      var _handler$targetProper;\n\n      config[(_handler$targetProper = handler.targetProperty) !== null && _handler$targetProper !== void 0 ? _handler$targetProper : handler.key] = newValue;\n    }\n  }\n\n  if (context.mappingValues) {\n    config.mappings = combineValueMappings(context);\n  }\n\n  return config;\n}\nexport let FieldConfigHandlerKey;\n\n(function (FieldConfigHandlerKey) {\n  FieldConfigHandlerKey[\"Name\"] = \"field.name\";\n  FieldConfigHandlerKey[\"Value\"] = \"field.value\";\n  FieldConfigHandlerKey[\"Label\"] = \"field.label\";\n  FieldConfigHandlerKey[\"Ignore\"] = \"__ignore\";\n})(FieldConfigHandlerKey || (FieldConfigHandlerKey = {}));\n\nexport const configMapHandlers = [{\n  key: FieldConfigHandlerKey.Name,\n  name: 'Field name',\n  processor: () => {}\n}, {\n  key: FieldConfigHandlerKey.Value,\n  name: 'Field value',\n  processor: () => {}\n}, {\n  key: FieldConfigHandlerKey.Label,\n  name: 'Field label',\n  processor: () => {}\n}, {\n  key: FieldConfigHandlerKey.Ignore,\n  name: 'Ignore',\n  processor: () => {}\n}, {\n  key: 'max',\n  processor: toNumericOrUndefined\n}, {\n  key: 'min',\n  processor: toNumericOrUndefined\n}, {\n  key: 'unit',\n  processor: value => value.toString()\n}, {\n  key: 'decimals',\n  processor: toNumericOrUndefined\n}, {\n  key: 'displayName',\n  name: 'Display name',\n  processor: value => value.toString()\n}, {\n  key: 'color',\n  processor: value => ({\n    fixedColor: value,\n    mode: FieldColorModeId.Fixed\n  })\n}, {\n  key: 'threshold1',\n  targetProperty: 'thresholds',\n  processor: (value, config) => {\n    const numeric = anyToNumber(value);\n\n    if (isNaN(numeric)) {\n      return;\n    }\n\n    if (!config.thresholds) {\n      config.thresholds = {\n        mode: ThresholdsMode.Absolute,\n        steps: [{\n          value: -Infinity,\n          color: 'green'\n        }]\n      };\n    }\n\n    config.thresholds.steps.push({\n      value: numeric,\n      color: 'red'\n    });\n    return config.thresholds;\n  }\n}, {\n  key: 'mappings.value',\n  name: 'Value mappings / Value',\n  targetProperty: 'mappings',\n  defaultReducer: ReducerID.allValues,\n  processor: (value, config, context) => {\n    if (!isArray(value)) {\n      return;\n    }\n\n    context.mappingValues = value;\n    return config.mappings;\n  }\n}, {\n  key: 'mappings.color',\n  name: 'Value mappings / Color',\n  targetProperty: 'mappings',\n  defaultReducer: ReducerID.allValues,\n  processor: (value, config, context) => {\n    if (!isArray(value)) {\n      return;\n    }\n\n    context.mappingColors = value;\n    return config.mappings;\n  }\n}, {\n  key: 'mappings.text',\n  name: 'Value mappings / Display text',\n  targetProperty: 'mappings',\n  defaultReducer: ReducerID.allValues,\n  processor: (value, config, context) => {\n    if (!isArray(value)) {\n      return;\n    }\n\n    context.mappingTexts = value;\n    return config.mappings;\n  }\n}];\n\nfunction combineValueMappings(context) {\n  const valueMap = {\n    type: MappingType.ValueToText,\n    options: {}\n  };\n\n  if (!context.mappingValues) {\n    return [];\n  }\n\n  for (let i = 0; i < context.mappingValues.length; i++) {\n    const value = context.mappingValues[i];\n\n    if (value != null) {\n      valueMap.options[value.toString()] = {\n        color: context.mappingColors && context.mappingColors[i],\n        text: context.mappingTexts && context.mappingTexts[i],\n        index: i\n      };\n    }\n  }\n\n  return [valueMap];\n}\n\nlet configMapHandlersIndex = null;\nexport function getConfigMapHandlersIndex() {\n  if (configMapHandlersIndex === null) {\n    configMapHandlersIndex = {};\n\n    for (const def of configMapHandlers) {\n      configMapHandlersIndex[def.key] = def;\n    }\n  }\n\n  return configMapHandlersIndex;\n}\n\nfunction toNumericOrUndefined(value) {\n  const numeric = anyToNumber(value);\n\n  if (isNaN(numeric)) {\n    return;\n  }\n\n  return numeric;\n}\n\nexport function getConfigHandlerKeyForField(fieldName, mappings) {\n  for (const map of mappings) {\n    if (fieldName === map.fieldName) {\n      return map.handlerKey;\n    }\n  }\n\n  return fieldName.toLowerCase();\n}\nexport function lookUpConfigHandler(key) {\n  if (!key) {\n    return null;\n  }\n\n  return getConfigMapHandlersIndex()[key];\n}\nexport function evaluteFieldMappings(frame, mappings, withNameAndValue) {\n  const result = {\n    index: {}\n  }; // Look up name and value field in mappings\n\n  let nameFieldMappping = mappings.find(x => x.handlerKey === FieldConfigHandlerKey.Name);\n  let valueFieldMapping = mappings.find(x => x.handlerKey === FieldConfigHandlerKey.Value);\n\n  for (const field of frame.fields) {\n    var _ref, _mapping$reducerId, _handler;\n\n    const fieldName = getFieldDisplayName(field, frame);\n    const mapping = mappings.find(x => x.fieldName === fieldName);\n    const key = mapping ? mapping.handlerKey : fieldName.toLowerCase();\n    let handler = lookUpConfigHandler(key); // Name and value handlers are a special as their auto logic is based on first matching criteria\n\n    if (withNameAndValue) {\n      // If we have a handler it means manually specified field\n      if (handler) {\n        if (handler.key === FieldConfigHandlerKey.Name) {\n          result.nameField = field;\n        }\n\n        if (handler.key === FieldConfigHandlerKey.Value) {\n          result.valueField = field;\n        }\n      } else if (!mapping) {\n        // We have no name field and no mapping for it, pick first string\n        if (!result.nameField && !nameFieldMappping && field.type === FieldType.string) {\n          result.nameField = field;\n          handler = lookUpConfigHandler(FieldConfigHandlerKey.Name);\n        }\n\n        if (!result.valueField && !valueFieldMapping && field.type === FieldType.number) {\n          result.valueField = field;\n          handler = lookUpConfigHandler(FieldConfigHandlerKey.Value);\n        }\n      }\n    } // If no handle and when in name and value mode (Rows to fields) default to labels\n\n\n    if (!handler && withNameAndValue) {\n      handler = lookUpConfigHandler(FieldConfigHandlerKey.Label);\n    }\n\n    result.index[fieldName] = {\n      automatic: !mapping,\n      handler: handler,\n      reducerId: (_ref = (_mapping$reducerId = mapping === null || mapping === void 0 ? void 0 : mapping.reducerId) !== null && _mapping$reducerId !== void 0 ? _mapping$reducerId : (_handler = handler) === null || _handler === void 0 ? void 0 : _handler.defaultReducer) !== null && _ref !== void 0 ? _ref : ReducerID.lastNotNull\n    };\n  }\n\n  return result;\n}","map":{"version":3,"names":["isArray","anyToNumber","FieldColorModeId","getFieldDisplayName","MappingType","ReducerID","ThresholdsMode","FieldType","getFieldConfigFromFrame","frame","rowIndex","evaluatedMappings","config","context","field","fields","fieldName","mapping","index","handler","configValue","values","get","undefined","newValue","processor","targetProperty","key","mappingValues","mappings","combineValueMappings","FieldConfigHandlerKey","configMapHandlers","Name","name","Value","Label","Ignore","toNumericOrUndefined","value","toString","fixedColor","mode","Fixed","numeric","isNaN","thresholds","Absolute","steps","Infinity","color","push","defaultReducer","allValues","mappingColors","mappingTexts","valueMap","type","ValueToText","options","i","length","text","configMapHandlersIndex","getConfigMapHandlersIndex","def","getConfigHandlerKeyForField","map","handlerKey","toLowerCase","lookUpConfigHandler","evaluteFieldMappings","withNameAndValue","result","nameFieldMappping","find","x","valueFieldMapping","nameField","valueField","string","number","automatic","reducerId","lastNotNull"],"sources":["/home/soula/grafana/public/app/features/transformers/fieldToConfigMapping/fieldToConfigMapping.ts"],"sourcesContent":["import { isArray } from 'lodash';\n\nimport {\n  anyToNumber,\n  DataFrame,\n  FieldColorModeId,\n  FieldConfig,\n  getFieldDisplayName,\n  MappingType,\n  ReducerID,\n  ThresholdsMode,\n  ValueMapping,\n  ValueMap,\n  Field,\n  FieldType,\n} from '@grafana/data';\n\nexport interface FieldToConfigMapping {\n  fieldName: string;\n  reducerId?: ReducerID;\n  handlerKey: string | null;\n}\n\n/**\n * Transforms a frame with fields to a map of field configs\n *\n * Input\n * | Unit        | Min | Max |\n * --------------------------------\n * | Temperature |  0  | 30  |\n * | Pressure    |  0  | 100 |\n *\n * Outputs\n * {\n    { min: 0, max: 100 },\n * }\n */\n\nexport function getFieldConfigFromFrame(\n  frame: DataFrame,\n  rowIndex: number,\n  evaluatedMappings: EvaluatedMappingResult\n): FieldConfig {\n  const config: FieldConfig = {};\n  const context: FieldToConfigContext = {};\n\n  for (const field of frame.fields) {\n    const fieldName = getFieldDisplayName(field, frame);\n    const mapping = evaluatedMappings.index[fieldName];\n    const handler = mapping.handler;\n\n    if (!handler) {\n      continue;\n    }\n\n    const configValue = field.values.get(rowIndex);\n\n    if (configValue === null || configValue === undefined) {\n      continue;\n    }\n\n    const newValue = handler.processor(configValue, config, context);\n    if (newValue != null) {\n      (config as any)[handler.targetProperty ?? handler.key] = newValue;\n    }\n  }\n\n  if (context.mappingValues) {\n    config.mappings = combineValueMappings(context);\n  }\n\n  return config;\n}\n\ninterface FieldToConfigContext {\n  mappingValues?: any[];\n  mappingColors?: string[];\n  mappingTexts?: string[];\n}\n\ntype FieldToConfigMapHandlerProcessor = (value: any, config: FieldConfig, context: FieldToConfigContext) => any;\n\nexport interface FieldToConfigMapHandler {\n  key: string;\n  targetProperty?: string;\n  name?: string;\n  processor: FieldToConfigMapHandlerProcessor;\n  defaultReducer?: ReducerID;\n}\n\nexport enum FieldConfigHandlerKey {\n  Name = 'field.name',\n  Value = 'field.value',\n  Label = 'field.label',\n  Ignore = '__ignore',\n}\n\nexport const configMapHandlers: FieldToConfigMapHandler[] = [\n  {\n    key: FieldConfigHandlerKey.Name,\n    name: 'Field name',\n    processor: () => {},\n  },\n  {\n    key: FieldConfigHandlerKey.Value,\n    name: 'Field value',\n    processor: () => {},\n  },\n  {\n    key: FieldConfigHandlerKey.Label,\n    name: 'Field label',\n    processor: () => {},\n  },\n  {\n    key: FieldConfigHandlerKey.Ignore,\n    name: 'Ignore',\n    processor: () => {},\n  },\n  {\n    key: 'max',\n    processor: toNumericOrUndefined,\n  },\n  {\n    key: 'min',\n    processor: toNumericOrUndefined,\n  },\n  {\n    key: 'unit',\n    processor: (value) => value.toString(),\n  },\n  {\n    key: 'decimals',\n    processor: toNumericOrUndefined,\n  },\n  {\n    key: 'displayName',\n    name: 'Display name',\n    processor: (value: any) => value.toString(),\n  },\n  {\n    key: 'color',\n    processor: (value) => ({ fixedColor: value, mode: FieldColorModeId.Fixed }),\n  },\n  {\n    key: 'threshold1',\n    targetProperty: 'thresholds',\n    processor: (value, config) => {\n      const numeric = anyToNumber(value);\n\n      if (isNaN(numeric)) {\n        return;\n      }\n\n      if (!config.thresholds) {\n        config.thresholds = {\n          mode: ThresholdsMode.Absolute,\n          steps: [{ value: -Infinity, color: 'green' }],\n        };\n      }\n\n      config.thresholds.steps.push({\n        value: numeric,\n        color: 'red',\n      });\n\n      return config.thresholds;\n    },\n  },\n  {\n    key: 'mappings.value',\n    name: 'Value mappings / Value',\n    targetProperty: 'mappings',\n    defaultReducer: ReducerID.allValues,\n    processor: (value, config, context) => {\n      if (!isArray(value)) {\n        return;\n      }\n\n      context.mappingValues = value;\n      return config.mappings;\n    },\n  },\n  {\n    key: 'mappings.color',\n    name: 'Value mappings / Color',\n    targetProperty: 'mappings',\n    defaultReducer: ReducerID.allValues,\n    processor: (value, config, context) => {\n      if (!isArray(value)) {\n        return;\n      }\n\n      context.mappingColors = value;\n      return config.mappings;\n    },\n  },\n  {\n    key: 'mappings.text',\n    name: 'Value mappings / Display text',\n    targetProperty: 'mappings',\n    defaultReducer: ReducerID.allValues,\n    processor: (value, config, context) => {\n      if (!isArray(value)) {\n        return;\n      }\n\n      context.mappingTexts = value;\n      return config.mappings;\n    },\n  },\n];\n\nfunction combineValueMappings(context: FieldToConfigContext): ValueMapping[] {\n  const valueMap: ValueMap = {\n    type: MappingType.ValueToText,\n    options: {},\n  };\n\n  if (!context.mappingValues) {\n    return [];\n  }\n\n  for (let i = 0; i < context.mappingValues.length; i++) {\n    const value = context.mappingValues[i];\n    if (value != null) {\n      valueMap.options[value.toString()] = {\n        color: context.mappingColors && context.mappingColors[i],\n        text: context.mappingTexts && context.mappingTexts[i],\n        index: i,\n      };\n    }\n  }\n\n  return [valueMap];\n}\n\nlet configMapHandlersIndex: Record<string, FieldToConfigMapHandler> | null = null;\n\nexport function getConfigMapHandlersIndex() {\n  if (configMapHandlersIndex === null) {\n    configMapHandlersIndex = {};\n    for (const def of configMapHandlers) {\n      configMapHandlersIndex[def.key] = def;\n    }\n  }\n\n  return configMapHandlersIndex;\n}\n\nfunction toNumericOrUndefined(value: any) {\n  const numeric = anyToNumber(value);\n\n  if (isNaN(numeric)) {\n    return;\n  }\n\n  return numeric;\n}\n\nexport function getConfigHandlerKeyForField(fieldName: string, mappings: FieldToConfigMapping[]) {\n  for (const map of mappings) {\n    if (fieldName === map.fieldName) {\n      return map.handlerKey;\n    }\n  }\n\n  return fieldName.toLowerCase();\n}\n\nexport function lookUpConfigHandler(key: string | null): FieldToConfigMapHandler | null {\n  if (!key) {\n    return null;\n  }\n\n  return getConfigMapHandlersIndex()[key];\n}\n\nexport interface EvaluatedMapping {\n  automatic: boolean;\n  handler: FieldToConfigMapHandler | null;\n  reducerId: ReducerID;\n}\nexport interface EvaluatedMappingResult {\n  index: Record<string, EvaluatedMapping>;\n  nameField?: Field;\n  valueField?: Field;\n}\n\nexport function evaluteFieldMappings(\n  frame: DataFrame,\n  mappings: FieldToConfigMapping[],\n  withNameAndValue?: boolean\n): EvaluatedMappingResult {\n  const result: EvaluatedMappingResult = {\n    index: {},\n  };\n\n  // Look up name and value field in mappings\n  let nameFieldMappping = mappings.find((x) => x.handlerKey === FieldConfigHandlerKey.Name);\n  let valueFieldMapping = mappings.find((x) => x.handlerKey === FieldConfigHandlerKey.Value);\n\n  for (const field of frame.fields) {\n    const fieldName = getFieldDisplayName(field, frame);\n    const mapping = mappings.find((x) => x.fieldName === fieldName);\n    const key = mapping ? mapping.handlerKey : fieldName.toLowerCase();\n    let handler = lookUpConfigHandler(key);\n\n    // Name and value handlers are a special as their auto logic is based on first matching criteria\n    if (withNameAndValue) {\n      // If we have a handler it means manually specified field\n      if (handler) {\n        if (handler.key === FieldConfigHandlerKey.Name) {\n          result.nameField = field;\n        }\n        if (handler.key === FieldConfigHandlerKey.Value) {\n          result.valueField = field;\n        }\n      } else if (!mapping) {\n        // We have no name field and no mapping for it, pick first string\n        if (!result.nameField && !nameFieldMappping && field.type === FieldType.string) {\n          result.nameField = field;\n          handler = lookUpConfigHandler(FieldConfigHandlerKey.Name);\n        }\n\n        if (!result.valueField && !valueFieldMapping && field.type === FieldType.number) {\n          result.valueField = field;\n          handler = lookUpConfigHandler(FieldConfigHandlerKey.Value);\n        }\n      }\n    }\n\n    // If no handle and when in name and value mode (Rows to fields) default to labels\n    if (!handler && withNameAndValue) {\n      handler = lookUpConfigHandler(FieldConfigHandlerKey.Label);\n    }\n\n    result.index[fieldName] = {\n      automatic: !mapping,\n      handler: handler,\n      reducerId: mapping?.reducerId ?? handler?.defaultReducer ?? ReducerID.lastNotNull,\n    };\n  }\n\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}