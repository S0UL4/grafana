{"ast":null,"code":"graphDirective.$inject = [\"timeSrv\", \"popoverSrv\", \"contextSrv\"];\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport 'vendor/flot/jquery.flot';\nimport 'vendor/flot/jquery.flot.selection';\nimport 'vendor/flot/jquery.flot.time';\nimport 'vendor/flot/jquery.flot.stack';\nimport 'vendor/flot/jquery.flot.stackpercent';\nimport 'vendor/flot/jquery.flot.fillbelow';\nimport 'vendor/flot/jquery.flot.crosshair';\nimport 'vendor/flot/jquery.flot.dashes';\nimport './jquery.flot.events';\nimport $ from 'jquery';\nimport { clone, find, flatten, isUndefined, map, max as _max, min as _min, sortBy as _sortBy, toNumber } from 'lodash';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { DataFrameView, DataHoverClearEvent, DataHoverEvent, FieldType, formattedValueToString, getDisplayProcessor, getFlotPairsConstant, getTimeField, getValueFormat, hasLinks, LegacyGraphHoverClearEvent, LegacyGraphHoverEvent, PanelEvents, toUtc } from '@grafana/data';\nimport { graphTickFormatter, graphTimeFormat } from '@grafana/ui';\nimport { coreModule } from 'app/angular/core_module';\nimport config from 'app/core/config';\nimport { updateLegendValues } from 'app/core/core';\nimport { provideTheme } from 'app/core/utils/ConfigProvider';\nimport { tickStep } from 'app/core/utils/ticks';\nimport { getFieldLinksSupplier } from 'app/features/panel/panellinks/linkSuppliers';\nimport { Legend } from './Legend/Legend';\nimport { alignYLevel } from './align_yaxes';\nimport { EventManager } from './event_manager';\nimport GraphTooltip from './graph_tooltip';\nimport { convertToHistogramData } from './histogram';\nimport { ThresholdManager } from './threshold_manager';\nimport { TimeRegionManager } from './time_region_manager';\nimport { isLegacyGraphHoverEvent } from './utils';\nconst LegendWithThemeProvider = provideTheme(Legend);\n\nclass GraphElement {\n  constructor(scope, elem, timeSrv) {\n    _defineProperty(this, \"ctrl\", void 0);\n\n    _defineProperty(this, \"contextMenu\", void 0);\n\n    _defineProperty(this, \"tooltip\", void 0);\n\n    _defineProperty(this, \"dashboard\", void 0);\n\n    _defineProperty(this, \"annotations\", void 0);\n\n    _defineProperty(this, \"panel\", void 0);\n\n    _defineProperty(this, \"plot\", void 0);\n\n    _defineProperty(this, \"sortedSeries\", void 0);\n\n    _defineProperty(this, \"data\", []);\n\n    _defineProperty(this, \"panelWidth\", void 0);\n\n    _defineProperty(this, \"eventManager\", void 0);\n\n    _defineProperty(this, \"thresholdManager\", void 0);\n\n    _defineProperty(this, \"timeRegionManager\", void 0);\n\n    _defineProperty(this, \"getContextMenuItemsSupplier\", (flotPosition, linksSupplier) => {\n      return () => {\n        // Fixed context menu items\n        const items = this.dashboard.canAddAnnotations() ? [{\n          items: [{\n            label: 'Add annotation',\n            ariaLabel: 'Add annotation',\n            icon: 'comment-alt',\n            onClick: () => this.eventManager.updateTime({\n              from: flotPosition.x,\n              to: null\n            })\n          }]\n        }] : [];\n\n        if (!linksSupplier) {\n          return items;\n        }\n\n        const dataLinks = [{\n          items: linksSupplier.getLinks(this.panel.replaceVariables).map(link => {\n            return {\n              label: link.title,\n              ariaLabel: link.title,\n              url: link.href,\n              target: link.target,\n              icon: `${link.target === '_self' ? 'link' : 'external-link-alt'}`,\n              onClick: link.onClick\n            };\n          })\n        }];\n        return [...items, ...dataLinks];\n      };\n    });\n\n    this.scope = scope;\n    this.elem = elem;\n    this.timeSrv = timeSrv;\n    this.ctrl = scope.ctrl;\n    this.contextMenu = scope.ctrl.contextMenuCtrl;\n    this.dashboard = this.ctrl.dashboard;\n    this.panel = this.ctrl.panel;\n    this.annotations = [];\n    this.panelWidth = 0;\n    this.eventManager = new EventManager(this.ctrl);\n    this.thresholdManager = new ThresholdManager(this.ctrl);\n    this.timeRegionManager = new TimeRegionManager(this.ctrl); // @ts-ignore\n\n    this.tooltip = new GraphTooltip(this.elem, this.ctrl.dashboard, this.scope, () => {\n      return this.sortedSeries;\n    }); // panel events\n\n    this.ctrl.events.on(PanelEvents.panelTeardown, this.onPanelTeardown.bind(this));\n    this.ctrl.events.on(PanelEvents.render, this.onRender.bind(this)); // global events\n    // Using old way here to use the scope unsubscribe model as the new $on function does not take scope\n\n    this.ctrl.dashboard.events.on(LegacyGraphHoverEvent.type, this.onGraphHover.bind(this), this.scope);\n    this.ctrl.dashboard.events.on(LegacyGraphHoverClearEvent.type, this.onGraphHoverClear.bind(this), this.scope);\n    this.ctrl.dashboard.events.on(DataHoverEvent.type, this.onGraphHover.bind(this), this.scope);\n    this.ctrl.dashboard.events.on(DataHoverClearEvent.type, this.onGraphHoverClear.bind(this), this.scope); // plot events\n\n    this.elem.bind('plotselected', this.onPlotSelected.bind(this));\n    this.elem.bind('plotclick', this.onPlotClick.bind(this)); // get graph legend element\n\n    if (this.elem && this.elem.parent) {\n      this.legendElem = this.elem.parent().find('.graph-legend')[0];\n    }\n  }\n\n  onRender(renderData) {\n    this.data = renderData || this.data;\n\n    if (!this.data) {\n      return;\n    }\n\n    this.annotations = this.ctrl.annotations || [];\n    this.buildFlotPairs(this.data);\n    const graphHeight = this.ctrl.height;\n    updateLegendValues(this.data, this.panel, graphHeight);\n\n    if (!this.panel.legend.show) {\n      if (this.legendElem.hasChildNodes()) {\n        ReactDOM.unmountComponentAtNode(this.legendElem);\n      }\n\n      this.renderPanel();\n      return;\n    }\n\n    const {\n      values,\n      min,\n      max,\n      avg,\n      current,\n      total\n    } = this.panel.legend;\n    const {\n      alignAsTable,\n      rightSide,\n      sideWidth,\n      sort,\n      sortDesc,\n      hideEmpty,\n      hideZero\n    } = this.panel.legend;\n    const legendOptions = {\n      alignAsTable,\n      rightSide,\n      sideWidth,\n      sort,\n      sortDesc,\n      hideEmpty,\n      hideZero\n    };\n    const valueOptions = {\n      values,\n      min,\n      max,\n      avg,\n      current,\n      total\n    };\n    const legendProps = Object.assign({\n      seriesList: this.data,\n      hiddenSeries: this.ctrl.hiddenSeries\n    }, legendOptions, valueOptions, {\n      onToggleSeries: this.ctrl.onToggleSeries,\n      onToggleSort: this.ctrl.onToggleSort,\n      onColorChange: this.ctrl.onColorChange,\n      onToggleAxis: this.ctrl.onToggleAxis\n    });\n    const legendReactElem = /*#__PURE__*/React.createElement(LegendWithThemeProvider, legendProps);\n    ReactDOM.render(legendReactElem, this.legendElem, () => this.renderPanel());\n  }\n\n  onGraphHover(evt) {\n    var _evt$point, _evt$point$panelRelY;\n\n    // ignore other graph hover events if shared tooltip is disabled\n    if (!this.dashboard.sharedTooltipModeEnabled()) {\n      return;\n    }\n\n    if (isLegacyGraphHoverEvent(evt)) {\n      var _evt$panel;\n\n      // ignore if we are the emitter\n      if (!this.plot || ((_evt$panel = evt.panel) === null || _evt$panel === void 0 ? void 0 : _evt$panel.id) === this.panel.id || this.ctrl.otherPanelInFullscreenMode()) {\n        return;\n      }\n\n      this.tooltip.show(evt.pos);\n    } // DataHoverEvent can come from multiple panels that doesn't include x position\n\n\n    if (!((_evt$point = evt.point) !== null && _evt$point !== void 0 && _evt$point.time)) {\n      return;\n    }\n\n    this.tooltip.show({\n      x: evt.point.time,\n      panelRelY: (_evt$point$panelRelY = evt.point.panelRelY) !== null && _evt$point$panelRelY !== void 0 ? _evt$point$panelRelY : 1\n    });\n  }\n\n  onPanelTeardown() {\n    if (this.plot) {\n      this.plot.destroy();\n      this.plot = null;\n    }\n\n    this.tooltip.destroy();\n    this.elem.off();\n    this.elem.remove();\n    ReactDOM.unmountComponentAtNode(this.legendElem);\n  }\n\n  onGraphHoverClear(handler) {\n    if (this.plot) {\n      this.tooltip.clear(this.plot);\n    }\n  }\n\n  onPlotSelected(event, ranges) {\n    if (this.panel.xaxis.mode !== 'time') {\n      // Skip if panel in histogram or series mode\n      this.plot.clearSelection();\n      return;\n    }\n\n    if ((ranges.ctrlKey || ranges.metaKey) && this.dashboard.canAddAnnotations()) {\n      // Add annotation\n      setTimeout(() => {\n        this.eventManager.updateTime(ranges.xaxis);\n      }, 100);\n    } else {\n      this.scope.$apply(() => {\n        this.timeSrv.setTime({\n          from: toUtc(ranges.xaxis.from),\n          to: toUtc(ranges.xaxis.to)\n        });\n      });\n    }\n  }\n\n  onPlotClick(event, pos, item) {\n    const scrollContextElement = this.elem.closest('.view') ? this.elem.closest('.view').get()[0] : null;\n    const contextMenuSourceItem = item;\n\n    if (this.panel.xaxis.mode !== 'time') {\n      // Skip if panel in histogram or series mode\n      return;\n    }\n\n    if (pos.ctrlKey || pos.metaKey) {\n      // Skip if range selected (added in \"plotselected\" event handler)\n      if (pos.x !== pos.x1) {\n        return;\n      } // skip if dashboard is not saved yet (exists in db) or user cannot edit\n\n\n      if (!this.dashboard.id || !this.dashboard.canAddAnnotations()) {\n        return;\n      }\n\n      setTimeout(() => {\n        this.eventManager.updateTime({\n          from: pos.x,\n          to: null\n        });\n      }, 100);\n      return;\n    } else {\n      this.tooltip.clear(this.plot);\n      let linksSupplier;\n\n      if (item) {\n        // pickup y-axis index to know which field's config to apply\n        const yAxisConfig = this.panel.yaxes[item.series.yaxis.n === 2 ? 1 : 0];\n        const dataFrame = this.ctrl.dataList[item.series.dataFrameIndex];\n        const field = dataFrame.fields[item.series.fieldIndex];\n        const dataIndex = this.getDataIndexWithNullValuesCorrection(item, dataFrame);\n        let links = this.panel.options.dataLinks || [];\n        const hasLinksValue = hasLinks(field);\n\n        if (hasLinksValue) {\n          // Append the configured links to the panel datalinks\n          links = [...links, ...field.config.links];\n        }\n\n        const fieldConfig = {\n          decimals: yAxisConfig.decimals,\n          links\n        };\n        const fieldDisplay = getDisplayProcessor({\n          field: {\n            config: fieldConfig,\n            type: FieldType.number\n          },\n          theme: config.theme2,\n          timeZone: this.dashboard.getTimezone()\n        })(field.values.get(dataIndex));\n        linksSupplier = links.length ? getFieldLinksSupplier({\n          display: fieldDisplay,\n          name: field.name,\n          view: new DataFrameView(dataFrame),\n          rowIndex: dataIndex,\n          colIndex: item.series.fieldIndex,\n          field: fieldConfig,\n          hasLinks: hasLinksValue\n        }) : undefined;\n      }\n\n      this.scope.$apply(() => {\n        // Setting nearest CustomScrollbar element as a scroll context for graph context menu\n        this.contextMenu.setScrollContextElement(scrollContextElement);\n        this.contextMenu.setSource(contextMenuSourceItem);\n        this.contextMenu.setMenuItemsSupplier(this.getContextMenuItemsSupplier(pos, linksSupplier));\n        this.contextMenu.toggleMenu(pos);\n      });\n    }\n  }\n\n  getDataIndexWithNullValuesCorrection(item, dataFrame) {\n    /** This is one added to handle the scenario where we have null values in\n     *  the time series data and the: \"visualization options -> null value\"\n     *  set to \"connected\". In this scenario we will get the wrong dataIndex.\n     *\n     *  https://github.com/grafana/grafana/issues/22651\n     */\n    const {\n      datapoint,\n      dataIndex\n    } = item;\n\n    if (!Array.isArray(datapoint) || datapoint.length === 0) {\n      return dataIndex;\n    }\n\n    const ts = datapoint[0];\n    const {\n      timeField\n    } = getTimeField(dataFrame);\n\n    if (!timeField || !timeField.values) {\n      return dataIndex;\n    }\n\n    const field = timeField.values.get(dataIndex);\n\n    if (field === ts) {\n      return dataIndex;\n    }\n\n    const correctIndex = timeField.values.toArray().findIndex(value => value === ts);\n    return correctIndex > -1 ? correctIndex : dataIndex;\n  }\n\n  shouldAbortRender() {\n    if (!this.data) {\n      return true;\n    }\n\n    if (this.panelWidth === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  drawHook(plot) {\n    // add left axis labels\n    if (this.panel.yaxes[0].label && this.panel.yaxes[0].show) {\n      $(\"<div class='axisLabel left-yaxis-label flot-temp-elem'></div>\").text(this.panel.yaxes[0].label).appendTo(this.elem);\n    } // add right axis labels\n\n\n    if (this.panel.yaxes[1].label && this.panel.yaxes[1].show) {\n      $(\"<div class='axisLabel right-yaxis-label flot-temp-elem'></div>\").text(this.panel.yaxes[1].label).appendTo(this.elem);\n    }\n\n    const {\n      dataWarning\n    } = this.ctrl;\n\n    if (dataWarning) {\n      const msg = $(`<div class=\"datapoints-warning flot-temp-elem\">${dataWarning.title}</div>`);\n\n      if (dataWarning.action) {\n        $(`<button class=\"btn btn-secondary\">${dataWarning.actionText}</button>`).click(dataWarning.action).appendTo(msg);\n      }\n\n      msg.appendTo(this.elem);\n    }\n\n    this.thresholdManager.draw(plot);\n    this.timeRegionManager.draw(plot);\n  }\n\n  processOffsetHook(plot, gridMargin) {\n    const left = this.panel.yaxes[0];\n    const right = this.panel.yaxes[1];\n\n    if (left.show && left.label) {\n      gridMargin.left = 20;\n    }\n\n    if (right.show && right.label) {\n      gridMargin.right = 20;\n    } // apply y-axis min/max options\n\n\n    const yaxis = plot.getYAxes();\n\n    for (let i = 0; i < yaxis.length; i++) {\n      const axis = yaxis[i];\n      const panelOptions = this.panel.yaxes[i];\n      axis.options.max = axis.options.max !== null ? axis.options.max : panelOptions.max;\n      axis.options.min = axis.options.min !== null ? axis.options.min : panelOptions.min;\n    }\n  }\n\n  processRangeHook(plot) {\n    const yAxes = plot.getYAxes();\n    const align = this.panel.yaxis.align || false;\n\n    if (yAxes.length > 1 && align === true) {\n      const level = this.panel.yaxis.alignLevel || 0;\n      alignYLevel(yAxes, parseFloat(level));\n    }\n  } // Series could have different timeSteps,\n  // let's find the smallest one so that bars are correctly rendered.\n  // In addition, only take series which are rendered as bars for this.\n\n\n  getMinTimeStepOfSeries(data) {\n    let min = Number.MAX_VALUE;\n\n    for (let i = 0; i < data.length; i++) {\n      if (!data[i].stats.timeStep) {\n        continue;\n      }\n\n      if (this.panel.bars) {\n        if (data[i].bars && data[i].bars.show === false) {\n          continue;\n        }\n      } else {\n        if (typeof data[i].bars === 'undefined' || typeof data[i].bars.show === 'undefined' || !data[i].bars.show) {\n          continue;\n        }\n      }\n\n      if (data[i].stats.timeStep < min) {\n        min = data[i].stats.timeStep;\n      }\n    }\n\n    return min;\n  } // Function for rendering panel\n\n\n  renderPanel() {\n    var _this$elem$width;\n\n    this.panelWidth = (_this$elem$width = this.elem.width()) !== null && _this$elem$width !== void 0 ? _this$elem$width : 0;\n\n    if (this.shouldAbortRender()) {\n      return;\n    } // give space to alert editing\n\n\n    this.thresholdManager.prepare(this.elem, this.data); // un-check dashes if lines are unchecked\n\n    this.panel.dashes = this.panel.lines ? this.panel.dashes : false; // Populate element\n\n    const options = this.buildFlotOptions(this.panel);\n    this.prepareXAxis(options, this.panel);\n    this.configureYAxisOptions(this.data, options);\n    this.thresholdManager.addFlotOptions(options, this.panel);\n    this.timeRegionManager.addFlotOptions(options, this.panel);\n    this.eventManager.addFlotEvents(this.annotations, options);\n    this.sortedSeries = this.sortSeries(this.data, this.panel);\n    this.callPlot(options, true);\n  }\n\n  buildFlotPairs(data) {\n    for (let i = 0; i < data.length; i++) {\n      const series = data[i];\n      series.data = series.getFlotPairs(series.nullPointMode || this.panel.nullPointMode);\n\n      if (series.transform === 'constant') {\n        series.data = getFlotPairsConstant(series.data, this.ctrl.range);\n      } // if hidden remove points and disable stack\n\n\n      if (this.ctrl.hiddenSeries[series.alias]) {\n        series.data = [];\n        series.stack = false;\n      }\n    }\n  }\n\n  prepareXAxis(options, panel) {\n    switch (panel.xaxis.mode) {\n      case 'series':\n        {\n          options.series.bars.barWidth = 0.7;\n          options.series.bars.align = 'center';\n\n          for (let i = 0; i < this.data.length; i++) {\n            const series = this.data[i];\n            series.data = [[i + 1, series.stats[panel.xaxis.values[0]]]];\n          }\n\n          this.addXSeriesAxis(options);\n          break;\n        }\n\n      case 'histogram':\n        {\n          let bucketSize;\n\n          if (this.data.length) {\n            let histMin = _min(map(this.data, s => s.stats.min));\n\n            let histMax = _max(map(this.data, s => s.stats.max));\n\n            const ticks = panel.xaxis.buckets || this.panelWidth / 50;\n\n            if (panel.xaxis.min != null) {\n              const isInvalidXaxisMin = tickStep(panel.xaxis.min, histMax, ticks) <= 0;\n              histMin = isInvalidXaxisMin ? histMin : panel.xaxis.min;\n            }\n\n            if (panel.xaxis.max != null) {\n              const isInvalidXaxisMax = tickStep(histMin, panel.xaxis.max, ticks) <= 0;\n              histMax = isInvalidXaxisMax ? histMax : panel.xaxis.max;\n            }\n\n            bucketSize = tickStep(histMin, histMax, ticks);\n            options.series.bars.barWidth = bucketSize * 0.8;\n            this.data = convertToHistogramData(this.data, bucketSize, this.ctrl.hiddenSeries, histMin, histMax);\n          } else {\n            bucketSize = 0;\n          }\n\n          this.addXHistogramAxis(options, bucketSize);\n          break;\n        }\n\n      case 'table':\n        {\n          options.series.bars.barWidth = 0.7;\n          options.series.bars.align = 'center';\n          this.addXTableAxis(options);\n          break;\n        }\n\n      default:\n        {\n          options.series.bars.barWidth = this.getMinTimeStepOfSeries(this.data) / 1.5;\n          this.addTimeAxis(options);\n          break;\n        }\n    }\n  }\n\n  callPlot(options, incrementRenderCounter) {\n    try {\n      this.plot = $.plot(this.elem, this.sortedSeries, options);\n\n      if (this.ctrl.renderError) {\n        delete this.ctrl.error;\n      }\n    } catch (e) {\n      console.error('flotcharts error', e);\n      this.ctrl.error = e instanceof Error ? e.message : 'Render Error';\n      this.ctrl.renderError = true;\n    }\n\n    if (incrementRenderCounter) {\n      this.ctrl.renderingCompleted();\n    }\n  }\n\n  buildFlotOptions(panel) {\n    let gridColor = '#c8c8c8';\n\n    if (config.bootData.user.lightTheme === true) {\n      gridColor = '#a1a1a1';\n    }\n\n    const stack = panel.stack ? true : null;\n    const options = {\n      hooks: {\n        draw: [this.drawHook.bind(this)],\n        processOffset: [this.processOffsetHook.bind(this)],\n        processRange: [this.processRangeHook.bind(this)]\n      },\n      legend: {\n        show: false\n      },\n      series: {\n        stackpercent: panel.stack ? panel.percentage : false,\n        stack: panel.percentage ? null : stack,\n        lines: {\n          show: panel.lines,\n          zero: false,\n          fill: this.translateFillOption(panel.fill),\n          fillColor: this.getFillGradient(panel.fillGradient),\n          lineWidth: panel.dashes ? 0 : panel.linewidth,\n          steps: panel.steppedLine\n        },\n        dashes: {\n          show: panel.dashes,\n          lineWidth: panel.linewidth,\n          dashLength: [panel.dashLength, panel.spaceLength]\n        },\n        bars: {\n          show: panel.bars,\n          fill: 1,\n          barWidth: 1,\n          zero: false,\n          lineWidth: 0\n        },\n        points: {\n          show: panel.points,\n          fill: 1,\n          fillColor: false,\n          radius: panel.points ? panel.pointradius : 2\n        },\n        shadowSize: 0\n      },\n      yaxes: [],\n      xaxis: {},\n      grid: {\n        minBorderMargin: 0,\n        markings: [],\n        backgroundColor: null,\n        borderWidth: 0,\n        hoverable: true,\n        clickable: true,\n        color: gridColor,\n        margin: {\n          left: 0,\n          right: 0\n        },\n        labelMarginX: 0,\n        mouseActiveRadius: 30\n      },\n      selection: {\n        mode: 'x',\n        color: '#666'\n      },\n      crosshair: {\n        mode: 'x'\n      }\n    };\n    return options;\n  }\n\n  sortSeries(series, panel) {\n    const sortBy = panel.legend.sort;\n    const sortOrder = panel.legend.sortDesc;\n    const haveSortBy = sortBy !== null && sortBy !== undefined && panel.legend[sortBy];\n    const haveSortOrder = sortOrder !== null && sortOrder !== undefined;\n    const shouldSortBy = panel.stack && haveSortBy && haveSortOrder && panel.legend.alignAsTable;\n    const sortDesc = panel.legend.sortDesc === true ? -1 : 1;\n\n    if (shouldSortBy) {\n      return _sortBy(series, s => s.stats[sortBy] * sortDesc);\n    } else {\n      return _sortBy(series, s => s.zindex);\n    }\n  }\n\n  getFillGradient(amount) {\n    if (!amount) {\n      return null;\n    }\n\n    return {\n      colors: [{\n        opacity: 0.0\n      }, {\n        opacity: amount / 10\n      }]\n    };\n  }\n\n  translateFillOption(fill) {\n    if (this.panel.percentage && this.panel.stack) {\n      return fill === 0 ? 0.001 : fill / 10;\n    } else {\n      return fill / 10;\n    }\n  }\n\n  addTimeAxis(options) {\n    const ticks = this.panelWidth / 100;\n    const min = isUndefined(this.ctrl.range.from) ? null : this.ctrl.range.from.valueOf();\n    const max = isUndefined(this.ctrl.range.to) ? null : this.ctrl.range.to.valueOf();\n    options.xaxis = {\n      timezone: this.dashboard.getTimezone(),\n      show: this.panel.xaxis.show,\n      mode: 'time',\n      min: min,\n      max: max,\n      label: 'Datetime',\n      ticks: ticks,\n      timeformat: graphTimeFormat(ticks, min, max),\n      tickFormatter: graphTickFormatter\n    };\n  }\n\n  addXSeriesAxis(options) {\n    const ticks = map(this.data, (series, index) => {\n      return [index + 1, series.alias];\n    });\n    options.xaxis = {\n      timezone: this.dashboard.getTimezone(),\n      show: this.panel.xaxis.show,\n      mode: null,\n      min: 0,\n      max: ticks.length + 1,\n      label: 'Datetime',\n      ticks: ticks\n    };\n  }\n\n  addXHistogramAxis(options, bucketSize) {\n    let ticks;\n    let min;\n    let max;\n    const defaultTicks = this.panelWidth / 50;\n\n    if (this.data.length && bucketSize) {\n      const tickValues = [];\n\n      for (const d of this.data) {\n        for (const point of d.data) {\n          tickValues[point[0]] = true;\n        }\n      }\n\n      ticks = Object.keys(tickValues).map(v => Number(v));\n      min = _min(ticks);\n      max = _max(ticks); // Adjust tick step\n\n      let tickStep = bucketSize;\n      let ticksNum = Math.floor((max - min) / tickStep);\n\n      while (ticksNum > defaultTicks) {\n        tickStep = tickStep * 2;\n        ticksNum = Math.ceil((max - min) / tickStep);\n      } // Expand ticks for pretty view\n\n\n      min = Math.floor(min / tickStep) * tickStep; // 1.01 is 101% - ensure we have enough space for last bar\n\n      max = Math.ceil(max * 1.01 / tickStep) * tickStep;\n      ticks = [];\n\n      for (let i = min; i <= max; i += tickStep) {\n        ticks.push(i);\n      }\n    } else {\n      // Set defaults if no data\n      ticks = defaultTicks / 2;\n      min = 0;\n      max = 1;\n    }\n\n    options.xaxis = {\n      timezone: this.dashboard.getTimezone(),\n      show: this.panel.xaxis.show,\n      mode: null,\n      min: min,\n      max: max,\n      label: 'Histogram',\n      ticks: ticks\n    }; // Use 'short' format for histogram values\n\n    this.configureAxisMode(options.xaxis, 'short', null);\n  }\n\n  addXTableAxis(options) {\n    let ticks = map(this.data, (series, seriesIndex) => {\n      return map(series.datapoints, (point, pointIndex) => {\n        const tickIndex = seriesIndex * series.datapoints.length + pointIndex;\n        return [tickIndex + 1, point[1]];\n      });\n    }); // @ts-ignore, potential bug? is this flattenDeep?\n\n    ticks = flatten(ticks, true);\n    options.xaxis = {\n      timezone: this.dashboard.getTimezone(),\n      show: this.panel.xaxis.show,\n      mode: null,\n      min: 0,\n      max: ticks.length + 1,\n      label: 'Datetime',\n      ticks: ticks\n    };\n  }\n\n  configureYAxisOptions(data, options) {\n    const defaults = {\n      position: 'left',\n      show: this.panel.yaxes[0].show,\n      index: 1,\n      logBase: this.panel.yaxes[0].logBase || 1,\n      min: this.parseNumber(this.panel.yaxes[0].min),\n      max: this.parseNumber(this.panel.yaxes[0].max),\n      tickDecimals: this.panel.yaxes[0].decimals\n    };\n    options.yaxes.push(defaults);\n\n    if (find(data, {\n      yaxis: 2\n    })) {\n      const secondY = clone(defaults);\n      secondY.index = 2;\n      secondY.show = this.panel.yaxes[1].show;\n      secondY.logBase = this.panel.yaxes[1].logBase || 1;\n      secondY.position = 'right';\n      secondY.min = this.parseNumber(this.panel.yaxes[1].min);\n      secondY.max = this.parseNumber(this.panel.yaxes[1].max);\n      secondY.tickDecimals = this.panel.yaxes[1].decimals;\n      options.yaxes.push(secondY);\n      this.applyLogScale(options.yaxes[1], data);\n      this.configureAxisMode(options.yaxes[1], this.panel.percentage && this.panel.stack ? 'percent' : this.panel.yaxes[1].format, this.panel.yaxes[1].decimals);\n    }\n\n    this.applyLogScale(options.yaxes[0], data);\n    this.configureAxisMode(options.yaxes[0], this.panel.percentage && this.panel.stack ? 'percent' : this.panel.yaxes[0].format, this.panel.yaxes[0].decimals);\n  }\n\n  parseNumber(value) {\n    if (value === null || typeof value === 'undefined') {\n      return null;\n    }\n\n    return toNumber(value);\n  }\n\n  applyLogScale(axis, data) {\n    if (axis.logBase === 1) {\n      return;\n    }\n\n    const minSetToZero = axis.min === 0;\n\n    if (axis.min < Number.MIN_VALUE) {\n      axis.min = null;\n    }\n\n    if (axis.max < Number.MIN_VALUE) {\n      axis.max = null;\n    }\n\n    let series, i;\n    let max = axis.max,\n        min = axis.min;\n\n    for (i = 0; i < data.length; i++) {\n      series = data[i];\n\n      if (series.yaxis === axis.index) {\n        if (!max || max < series.stats.max) {\n          max = series.stats.max;\n        }\n\n        if (!min || min > series.stats.logmin) {\n          min = series.stats.logmin;\n        }\n      }\n    }\n\n    axis.transform = v => {\n      return v < Number.MIN_VALUE ? null : Math.log(v) / Math.log(axis.logBase);\n    };\n\n    axis.inverseTransform = v => {\n      return Math.pow(axis.logBase, v);\n    };\n\n    if (!max && !min) {\n      max = axis.inverseTransform(+2);\n      min = axis.inverseTransform(-2);\n    } else if (!max) {\n      max = min * axis.inverseTransform(+4);\n    } else if (!min) {\n      min = max * axis.inverseTransform(-4);\n    }\n\n    if (axis.min) {\n      min = axis.inverseTransform(Math.ceil(axis.transform(axis.min)));\n    } else {\n      min = axis.min = axis.inverseTransform(Math.floor(axis.transform(min)));\n    }\n\n    if (axis.max) {\n      max = axis.inverseTransform(Math.floor(axis.transform(axis.max)));\n    } else {\n      max = axis.max = axis.inverseTransform(Math.ceil(axis.transform(max)));\n    }\n\n    if (!min || min < Number.MIN_VALUE || !max || max < Number.MIN_VALUE) {\n      return;\n    }\n\n    if (Number.isFinite(min) && Number.isFinite(max)) {\n      if (minSetToZero) {\n        axis.min = 0.1;\n        min = 1;\n      }\n\n      axis.ticks = this.generateTicksForLogScaleYAxis(min, max, axis.logBase);\n\n      if (minSetToZero) {\n        axis.ticks.unshift(0.1);\n      }\n\n      if (axis.ticks[axis.ticks.length - 1] > axis.max) {\n        axis.max = axis.ticks[axis.ticks.length - 1];\n      }\n    } else {\n      axis.ticks = [1, 2];\n      delete axis.min;\n      delete axis.max;\n    }\n  }\n\n  generateTicksForLogScaleYAxis(min, max, logBase) {\n    let ticks = [];\n    let nextTick;\n\n    for (nextTick = min; nextTick <= max; nextTick *= logBase) {\n      ticks.push(nextTick);\n    }\n\n    const maxNumTicks = Math.ceil(this.ctrl.height / 25);\n    const numTicks = ticks.length;\n\n    if (numTicks > maxNumTicks) {\n      const factor = Math.ceil(numTicks / maxNumTicks) * logBase;\n      ticks = [];\n\n      for (nextTick = min; nextTick <= max * factor; nextTick *= factor) {\n        ticks.push(nextTick);\n      }\n    }\n\n    return ticks;\n  }\n\n  configureAxisMode(axis, format, decimals) {\n    axis.tickFormatter = (val, axis) => {\n      const formatter = getValueFormat(format);\n\n      if (!formatter) {\n        throw new Error(`Unit '${format}' is not supported`);\n      }\n\n      return formattedValueToString(formatter(val, decimals));\n    };\n  }\n\n}\n/** @ngInject */\n\n\nfunction graphDirective(timeSrv, popoverSrv, contextSrv) {\n  return {\n    restrict: 'A',\n    template: '',\n    link: (scope, elem) => {\n      return new GraphElement(scope, elem, timeSrv);\n    }\n  };\n}\n\ncoreModule.directive('grafanaGraph', graphDirective);\nexport { GraphElement, graphDirective };","map":{"version":3,"names":["$","clone","find","flatten","isUndefined","map","max","_max","min","_min","sortBy","_sortBy","toNumber","React","ReactDOM","DataFrameView","DataHoverClearEvent","DataHoverEvent","FieldType","formattedValueToString","getDisplayProcessor","getFlotPairsConstant","getTimeField","getValueFormat","hasLinks","LegacyGraphHoverClearEvent","LegacyGraphHoverEvent","PanelEvents","toUtc","graphTickFormatter","graphTimeFormat","coreModule","config","updateLegendValues","provideTheme","tickStep","getFieldLinksSupplier","Legend","alignYLevel","EventManager","GraphTooltip","convertToHistogramData","ThresholdManager","TimeRegionManager","isLegacyGraphHoverEvent","LegendWithThemeProvider","GraphElement","constructor","scope","elem","timeSrv","flotPosition","linksSupplier","items","dashboard","canAddAnnotations","label","ariaLabel","icon","onClick","eventManager","updateTime","from","x","to","dataLinks","getLinks","panel","replaceVariables","link","title","url","href","target","ctrl","contextMenu","contextMenuCtrl","annotations","panelWidth","thresholdManager","timeRegionManager","tooltip","sortedSeries","events","on","panelTeardown","onPanelTeardown","bind","render","onRender","type","onGraphHover","onGraphHoverClear","onPlotSelected","onPlotClick","parent","legendElem","renderData","data","buildFlotPairs","graphHeight","height","legend","show","hasChildNodes","unmountComponentAtNode","renderPanel","values","avg","current","total","alignAsTable","rightSide","sideWidth","sort","sortDesc","hideEmpty","hideZero","legendOptions","valueOptions","legendProps","seriesList","hiddenSeries","onToggleSeries","onToggleSort","onColorChange","onToggleAxis","legendReactElem","createElement","evt","sharedTooltipModeEnabled","plot","id","otherPanelInFullscreenMode","pos","point","time","panelRelY","destroy","off","remove","handler","clear","event","ranges","xaxis","mode","clearSelection","ctrlKey","metaKey","setTimeout","$apply","setTime","item","scrollContextElement","closest","get","contextMenuSourceItem","x1","yAxisConfig","yaxes","series","yaxis","n","dataFrame","dataList","dataFrameIndex","field","fields","fieldIndex","dataIndex","getDataIndexWithNullValuesCorrection","links","options","hasLinksValue","fieldConfig","decimals","fieldDisplay","number","theme","theme2","timeZone","getTimezone","length","display","name","view","rowIndex","colIndex","undefined","setScrollContextElement","setSource","setMenuItemsSupplier","getContextMenuItemsSupplier","toggleMenu","datapoint","Array","isArray","ts","timeField","correctIndex","toArray","findIndex","value","shouldAbortRender","drawHook","text","appendTo","dataWarning","msg","action","actionText","click","draw","processOffsetHook","gridMargin","left","right","getYAxes","i","axis","panelOptions","processRangeHook","yAxes","align","level","alignLevel","parseFloat","getMinTimeStepOfSeries","Number","MAX_VALUE","stats","timeStep","bars","width","prepare","dashes","lines","buildFlotOptions","prepareXAxis","configureYAxisOptions","addFlotOptions","addFlotEvents","sortSeries","callPlot","getFlotPairs","nullPointMode","transform","range","alias","stack","barWidth","addXSeriesAxis","bucketSize","histMin","s","histMax","ticks","buckets","isInvalidXaxisMin","isInvalidXaxisMax","addXHistogramAxis","addXTableAxis","addTimeAxis","incrementRenderCounter","renderError","error","e","console","Error","message","renderingCompleted","gridColor","bootData","user","lightTheme","hooks","processOffset","processRange","stackpercent","percentage","zero","fill","translateFillOption","fillColor","getFillGradient","fillGradient","lineWidth","linewidth","steps","steppedLine","dashLength","spaceLength","points","radius","pointradius","shadowSize","grid","minBorderMargin","markings","backgroundColor","borderWidth","hoverable","clickable","color","margin","labelMarginX","mouseActiveRadius","selection","crosshair","sortOrder","haveSortBy","haveSortOrder","shouldSortBy","zindex","amount","colors","opacity","valueOf","timezone","timeformat","tickFormatter","index","defaultTicks","tickValues","d","Object","keys","v","ticksNum","Math","floor","ceil","push","configureAxisMode","seriesIndex","datapoints","pointIndex","tickIndex","defaults","position","logBase","parseNumber","tickDecimals","secondY","applyLogScale","format","minSetToZero","MIN_VALUE","logmin","log","inverseTransform","pow","isFinite","generateTicksForLogScaleYAxis","unshift","nextTick","maxNumTicks","numTicks","factor","val","formatter","graphDirective","popoverSrv","contextSrv","restrict","template","directive"],"sources":["/home/soula/grafana/public/app/plugins/panel/graph/graph.ts"],"sourcesContent":["import 'vendor/flot/jquery.flot';\nimport 'vendor/flot/jquery.flot.selection';\nimport 'vendor/flot/jquery.flot.time';\nimport 'vendor/flot/jquery.flot.stack';\nimport 'vendor/flot/jquery.flot.stackpercent';\nimport 'vendor/flot/jquery.flot.fillbelow';\nimport 'vendor/flot/jquery.flot.crosshair';\nimport 'vendor/flot/jquery.flot.dashes';\nimport './jquery.flot.events';\n\nimport $ from 'jquery';\nimport { clone, find, flatten, isUndefined, map, max as _max, min as _min, sortBy as _sortBy, toNumber } from 'lodash';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport {\n  DataFrame,\n  DataFrameView,\n  DataHoverClearEvent,\n  DataHoverEvent,\n  DataHoverPayload,\n  FieldDisplay,\n  FieldType,\n  formattedValueToString,\n  getDisplayProcessor,\n  getFlotPairsConstant,\n  getTimeField,\n  getValueFormat,\n  hasLinks,\n  LegacyEventHandler,\n  LegacyGraphHoverClearEvent,\n  LegacyGraphHoverEvent,\n  LegacyGraphHoverEventPayload,\n  LinkModelSupplier,\n  PanelEvents,\n  toUtc,\n} from '@grafana/data';\nimport { graphTickFormatter, graphTimeFormat, IconName, MenuItemProps, MenuItemsGroup } from '@grafana/ui';\nimport { coreModule } from 'app/angular/core_module';\nimport config from 'app/core/config';\nimport { updateLegendValues } from 'app/core/core';\nimport { ContextSrv } from 'app/core/services/context_srv';\nimport { provideTheme } from 'app/core/utils/ConfigProvider';\nimport { tickStep } from 'app/core/utils/ticks';\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { getFieldLinksSupplier } from 'app/features/panel/panellinks/linkSuppliers';\n\nimport { DashboardModel } from '../../../features/dashboard/state';\n\nimport { GraphContextMenuCtrl } from './GraphContextMenuCtrl';\nimport { GraphLegendProps, Legend } from './Legend/Legend';\nimport { alignYLevel } from './align_yaxes';\nimport { EventManager } from './event_manager';\nimport GraphTooltip from './graph_tooltip';\nimport { convertToHistogramData } from './histogram';\nimport { GraphCtrl } from './module';\nimport { ThresholdManager } from './threshold_manager';\nimport { TimeRegionManager } from './time_region_manager';\nimport { isLegacyGraphHoverEvent } from './utils';\n\nconst LegendWithThemeProvider = provideTheme(Legend);\n\nclass GraphElement {\n  ctrl: GraphCtrl;\n  contextMenu: GraphContextMenuCtrl;\n  tooltip: any;\n  dashboard: DashboardModel;\n  annotations: object[];\n  panel: any;\n  plot: any;\n  sortedSeries?: any[];\n  data: any[] = [];\n  panelWidth: number;\n  eventManager: EventManager;\n  thresholdManager: ThresholdManager;\n  timeRegionManager: TimeRegionManager;\n  declare legendElem: HTMLElement;\n\n  constructor(\n    private scope: any,\n    private elem: JQuery & {\n      bind(eventType: string, handler: (eventObject: JQueryEventObject, ...args: any[]) => any): JQuery; // need to extend with Plot\n    },\n    private timeSrv: TimeSrv\n  ) {\n    this.ctrl = scope.ctrl;\n    this.contextMenu = scope.ctrl.contextMenuCtrl;\n    this.dashboard = this.ctrl.dashboard;\n    this.panel = this.ctrl.panel;\n    this.annotations = [];\n\n    this.panelWidth = 0;\n    this.eventManager = new EventManager(this.ctrl);\n    this.thresholdManager = new ThresholdManager(this.ctrl);\n    this.timeRegionManager = new TimeRegionManager(this.ctrl);\n    // @ts-ignore\n    this.tooltip = new GraphTooltip(this.elem, this.ctrl.dashboard, this.scope, () => {\n      return this.sortedSeries;\n    });\n\n    // panel events\n    this.ctrl.events.on(PanelEvents.panelTeardown, this.onPanelTeardown.bind(this));\n    this.ctrl.events.on(PanelEvents.render, this.onRender.bind(this));\n\n    // global events\n    // Using old way here to use the scope unsubscribe model as the new $on function does not take scope\n    this.ctrl.dashboard.events.on(LegacyGraphHoverEvent.type, this.onGraphHover.bind(this), this.scope);\n    this.ctrl.dashboard.events.on(LegacyGraphHoverClearEvent.type, this.onGraphHoverClear.bind(this), this.scope);\n\n    this.ctrl.dashboard.events.on(DataHoverEvent.type, this.onGraphHover.bind(this), this.scope);\n    this.ctrl.dashboard.events.on(DataHoverClearEvent.type, this.onGraphHoverClear.bind(this), this.scope);\n\n    // plot events\n    this.elem.bind('plotselected', this.onPlotSelected.bind(this));\n    this.elem.bind('plotclick', this.onPlotClick.bind(this));\n\n    // get graph legend element\n    if (this.elem && this.elem.parent) {\n      this.legendElem = this.elem.parent().find('.graph-legend')[0];\n    }\n  }\n\n  onRender(renderData: any[]) {\n    this.data = renderData || this.data;\n    if (!this.data) {\n      return;\n    }\n\n    this.annotations = this.ctrl.annotations || [];\n    this.buildFlotPairs(this.data);\n    const graphHeight = this.ctrl.height;\n    updateLegendValues(this.data, this.panel, graphHeight);\n\n    if (!this.panel.legend.show) {\n      if (this.legendElem.hasChildNodes()) {\n        ReactDOM.unmountComponentAtNode(this.legendElem);\n      }\n      this.renderPanel();\n      return;\n    }\n\n    const { values, min, max, avg, current, total } = this.panel.legend;\n    const { alignAsTable, rightSide, sideWidth, sort, sortDesc, hideEmpty, hideZero } = this.panel.legend;\n    const legendOptions = { alignAsTable, rightSide, sideWidth, sort, sortDesc, hideEmpty, hideZero };\n    const valueOptions = { values, min, max, avg, current, total };\n    const legendProps: GraphLegendProps = {\n      seriesList: this.data,\n      hiddenSeries: this.ctrl.hiddenSeries,\n      ...legendOptions,\n      ...valueOptions,\n      onToggleSeries: this.ctrl.onToggleSeries,\n      onToggleSort: this.ctrl.onToggleSort,\n      onColorChange: this.ctrl.onColorChange,\n      onToggleAxis: this.ctrl.onToggleAxis,\n    };\n\n    const legendReactElem = React.createElement(LegendWithThemeProvider, legendProps);\n    ReactDOM.render(legendReactElem, this.legendElem, () => this.renderPanel());\n  }\n\n  onGraphHover(evt: LegacyGraphHoverEventPayload | DataHoverPayload) {\n    // ignore other graph hover events if shared tooltip is disabled\n    if (!this.dashboard.sharedTooltipModeEnabled()) {\n      return;\n    }\n\n    if (isLegacyGraphHoverEvent(evt)) {\n      // ignore if we are the emitter\n      if (!this.plot || evt.panel?.id === this.panel.id || this.ctrl.otherPanelInFullscreenMode()) {\n        return;\n      }\n\n      this.tooltip.show(evt.pos);\n    }\n\n    // DataHoverEvent can come from multiple panels that doesn't include x position\n    if (!evt.point?.time) {\n      return;\n    }\n\n    this.tooltip.show({ x: evt.point.time, panelRelY: evt.point.panelRelY ?? 1 });\n  }\n\n  onPanelTeardown() {\n    if (this.plot) {\n      this.plot.destroy();\n      this.plot = null;\n    }\n\n    this.tooltip.destroy();\n    this.elem.off();\n    this.elem.remove();\n\n    ReactDOM.unmountComponentAtNode(this.legendElem);\n  }\n\n  onGraphHoverClear(handler: LegacyEventHandler<any>) {\n    if (this.plot) {\n      this.tooltip.clear(this.plot);\n    }\n  }\n\n  onPlotSelected(event: JQueryEventObject, ranges: any) {\n    if (this.panel.xaxis.mode !== 'time') {\n      // Skip if panel in histogram or series mode\n      this.plot.clearSelection();\n      return;\n    }\n\n    if ((ranges.ctrlKey || ranges.metaKey) && this.dashboard.canAddAnnotations()) {\n      // Add annotation\n      setTimeout(() => {\n        this.eventManager.updateTime(ranges.xaxis);\n      }, 100);\n    } else {\n      this.scope.$apply(() => {\n        this.timeSrv.setTime({\n          from: toUtc(ranges.xaxis.from),\n          to: toUtc(ranges.xaxis.to),\n        });\n      });\n    }\n  }\n\n  getContextMenuItemsSupplier = (\n    flotPosition: { x: number; y: number },\n    linksSupplier?: LinkModelSupplier<FieldDisplay>\n  ): (() => MenuItemsGroup[]) => {\n    return () => {\n      // Fixed context menu items\n      const items: MenuItemsGroup[] = this.dashboard.canAddAnnotations()\n        ? [\n            {\n              items: [\n                {\n                  label: 'Add annotation',\n                  ariaLabel: 'Add annotation',\n                  icon: 'comment-alt',\n                  onClick: () => this.eventManager.updateTime({ from: flotPosition.x, to: null }),\n                },\n              ],\n            },\n          ]\n        : [];\n\n      if (!linksSupplier) {\n        return items;\n      }\n\n      const dataLinks = [\n        {\n          items: linksSupplier.getLinks(this.panel.replaceVariables).map<MenuItemProps>((link) => {\n            return {\n              label: link.title,\n              ariaLabel: link.title,\n              url: link.href,\n              target: link.target,\n              icon: `${link.target === '_self' ? 'link' : 'external-link-alt'}` as IconName,\n              onClick: link.onClick,\n            };\n          }),\n        },\n      ];\n\n      return [...items, ...dataLinks];\n    };\n  };\n\n  onPlotClick(event: JQueryEventObject, pos: any, item: any) {\n    const scrollContextElement = this.elem.closest('.view') ? this.elem.closest('.view').get()[0] : null;\n    const contextMenuSourceItem = item;\n\n    if (this.panel.xaxis.mode !== 'time') {\n      // Skip if panel in histogram or series mode\n      return;\n    }\n\n    if (pos.ctrlKey || pos.metaKey) {\n      // Skip if range selected (added in \"plotselected\" event handler)\n      if (pos.x !== pos.x1) {\n        return;\n      }\n\n      // skip if dashboard is not saved yet (exists in db) or user cannot edit\n      if (!this.dashboard.id || !this.dashboard.canAddAnnotations()) {\n        return;\n      }\n\n      setTimeout(() => {\n        this.eventManager.updateTime({ from: pos.x, to: null });\n      }, 100);\n      return;\n    } else {\n      this.tooltip.clear(this.plot);\n      let linksSupplier: LinkModelSupplier<FieldDisplay> | undefined;\n\n      if (item) {\n        // pickup y-axis index to know which field's config to apply\n        const yAxisConfig = this.panel.yaxes[item.series.yaxis.n === 2 ? 1 : 0];\n        const dataFrame = this.ctrl.dataList[item.series.dataFrameIndex];\n        const field = dataFrame.fields[item.series.fieldIndex];\n        const dataIndex = this.getDataIndexWithNullValuesCorrection(item, dataFrame);\n\n        let links: any[] = this.panel.options.dataLinks || [];\n        const hasLinksValue = hasLinks(field);\n        if (hasLinksValue) {\n          // Append the configured links to the panel datalinks\n          links = [...links, ...field.config.links!];\n        }\n        const fieldConfig = {\n          decimals: yAxisConfig.decimals,\n          links,\n        };\n        const fieldDisplay = getDisplayProcessor({\n          field: { config: fieldConfig, type: FieldType.number },\n          theme: config.theme2,\n          timeZone: this.dashboard.getTimezone(),\n        })(field.values.get(dataIndex));\n        linksSupplier = links.length\n          ? getFieldLinksSupplier({\n              display: fieldDisplay,\n              name: field.name,\n              view: new DataFrameView(dataFrame),\n              rowIndex: dataIndex,\n              colIndex: item.series.fieldIndex,\n              field: fieldConfig,\n              hasLinks: hasLinksValue,\n            })\n          : undefined;\n      }\n\n      this.scope.$apply(() => {\n        // Setting nearest CustomScrollbar element as a scroll context for graph context menu\n        this.contextMenu.setScrollContextElement(scrollContextElement);\n        this.contextMenu.setSource(contextMenuSourceItem);\n        this.contextMenu.setMenuItemsSupplier(this.getContextMenuItemsSupplier(pos, linksSupplier) as any);\n        this.contextMenu.toggleMenu(pos);\n      });\n    }\n  }\n\n  getDataIndexWithNullValuesCorrection(item: any, dataFrame: DataFrame): number {\n    /** This is one added to handle the scenario where we have null values in\n     *  the time series data and the: \"visualization options -> null value\"\n     *  set to \"connected\". In this scenario we will get the wrong dataIndex.\n     *\n     *  https://github.com/grafana/grafana/issues/22651\n     */\n    const { datapoint, dataIndex } = item;\n\n    if (!Array.isArray(datapoint) || datapoint.length === 0) {\n      return dataIndex;\n    }\n\n    const ts = datapoint[0];\n    const { timeField } = getTimeField(dataFrame);\n\n    if (!timeField || !timeField.values) {\n      return dataIndex;\n    }\n\n    const field = timeField.values.get(dataIndex);\n\n    if (field === ts) {\n      return dataIndex;\n    }\n\n    const correctIndex = timeField.values.toArray().findIndex((value) => value === ts);\n    return correctIndex > -1 ? correctIndex : dataIndex;\n  }\n\n  shouldAbortRender() {\n    if (!this.data) {\n      return true;\n    }\n\n    if (this.panelWidth === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  drawHook(plot: any) {\n    // add left axis labels\n    if (this.panel.yaxes[0].label && this.panel.yaxes[0].show) {\n      $(\"<div class='axisLabel left-yaxis-label flot-temp-elem'></div>\")\n        .text(this.panel.yaxes[0].label)\n        .appendTo(this.elem);\n    }\n\n    // add right axis labels\n    if (this.panel.yaxes[1].label && this.panel.yaxes[1].show) {\n      $(\"<div class='axisLabel right-yaxis-label flot-temp-elem'></div>\")\n        .text(this.panel.yaxes[1].label)\n        .appendTo(this.elem);\n    }\n\n    const { dataWarning } = this.ctrl;\n    if (dataWarning) {\n      const msg = $(`<div class=\"datapoints-warning flot-temp-elem\">${dataWarning.title}</div>`);\n      if (dataWarning.action) {\n        $(`<button class=\"btn btn-secondary\">${dataWarning.actionText}</button>`)\n          .click(dataWarning.action)\n          .appendTo(msg);\n      }\n      msg.appendTo(this.elem);\n    }\n    this.thresholdManager.draw(plot);\n    this.timeRegionManager.draw(plot);\n  }\n\n  processOffsetHook(plot: any, gridMargin: { left: number; right: number }) {\n    const left = this.panel.yaxes[0];\n    const right = this.panel.yaxes[1];\n    if (left.show && left.label) {\n      gridMargin.left = 20;\n    }\n    if (right.show && right.label) {\n      gridMargin.right = 20;\n    }\n\n    // apply y-axis min/max options\n    const yaxis = plot.getYAxes();\n    for (let i = 0; i < yaxis.length; i++) {\n      const axis: any = yaxis[i];\n      const panelOptions = this.panel.yaxes[i];\n      axis.options.max = axis.options.max !== null ? axis.options.max : panelOptions.max;\n      axis.options.min = axis.options.min !== null ? axis.options.min : panelOptions.min;\n    }\n  }\n\n  processRangeHook(plot: any) {\n    const yAxes = plot.getYAxes();\n    const align = this.panel.yaxis.align || false;\n\n    if (yAxes.length > 1 && align === true) {\n      const level = this.panel.yaxis.alignLevel || 0;\n      alignYLevel(yAxes, parseFloat(level));\n    }\n  }\n\n  // Series could have different timeSteps,\n  // let's find the smallest one so that bars are correctly rendered.\n  // In addition, only take series which are rendered as bars for this.\n  getMinTimeStepOfSeries(data: any[]) {\n    let min = Number.MAX_VALUE;\n\n    for (let i = 0; i < data.length; i++) {\n      if (!data[i].stats.timeStep) {\n        continue;\n      }\n      if (this.panel.bars) {\n        if (data[i].bars && data[i].bars.show === false) {\n          continue;\n        }\n      } else {\n        if (typeof data[i].bars === 'undefined' || typeof data[i].bars.show === 'undefined' || !data[i].bars.show) {\n          continue;\n        }\n      }\n\n      if (data[i].stats.timeStep < min) {\n        min = data[i].stats.timeStep;\n      }\n    }\n\n    return min;\n  }\n\n  // Function for rendering panel\n  renderPanel() {\n    this.panelWidth = this.elem.width() ?? 0;\n\n    if (this.shouldAbortRender()) {\n      return;\n    }\n\n    // give space to alert editing\n    this.thresholdManager.prepare(this.elem, this.data);\n\n    // un-check dashes if lines are unchecked\n    this.panel.dashes = this.panel.lines ? this.panel.dashes : false;\n\n    // Populate element\n    const options: any = this.buildFlotOptions(this.panel);\n    this.prepareXAxis(options, this.panel);\n    this.configureYAxisOptions(this.data, options);\n    this.thresholdManager.addFlotOptions(options, this.panel);\n    this.timeRegionManager.addFlotOptions(options, this.panel);\n    this.eventManager.addFlotEvents(this.annotations, options);\n    this.sortedSeries = this.sortSeries(this.data, this.panel);\n    this.callPlot(options, true);\n  }\n\n  buildFlotPairs(data: any) {\n    for (let i = 0; i < data.length; i++) {\n      const series = data[i];\n      series.data = series.getFlotPairs(series.nullPointMode || this.panel.nullPointMode);\n\n      if (series.transform === 'constant') {\n        series.data = getFlotPairsConstant(series.data, this.ctrl.range!);\n      }\n\n      // if hidden remove points and disable stack\n      if (this.ctrl.hiddenSeries[series.alias]) {\n        series.data = [];\n        series.stack = false;\n      }\n    }\n  }\n\n  prepareXAxis(options: any, panel: any) {\n    switch (panel.xaxis.mode) {\n      case 'series': {\n        options.series.bars.barWidth = 0.7;\n        options.series.bars.align = 'center';\n\n        for (let i = 0; i < this.data.length; i++) {\n          const series = this.data[i];\n          series.data = [[i + 1, series.stats[panel.xaxis.values[0]]]];\n        }\n\n        this.addXSeriesAxis(options);\n        break;\n      }\n      case 'histogram': {\n        let bucketSize: number;\n\n        if (this.data.length) {\n          let histMin = _min(map(this.data, (s) => s.stats.min));\n          let histMax = _max(map(this.data, (s) => s.stats.max));\n          const ticks = panel.xaxis.buckets || this.panelWidth / 50;\n          if (panel.xaxis.min != null) {\n            const isInvalidXaxisMin = tickStep(panel.xaxis.min, histMax, ticks) <= 0;\n            histMin = isInvalidXaxisMin ? histMin : panel.xaxis.min;\n          }\n          if (panel.xaxis.max != null) {\n            const isInvalidXaxisMax = tickStep(histMin, panel.xaxis.max, ticks) <= 0;\n            histMax = isInvalidXaxisMax ? histMax : panel.xaxis.max;\n          }\n          bucketSize = tickStep(histMin, histMax, ticks);\n          options.series.bars.barWidth = bucketSize * 0.8;\n          this.data = convertToHistogramData(this.data, bucketSize, this.ctrl.hiddenSeries, histMin, histMax);\n        } else {\n          bucketSize = 0;\n        }\n\n        this.addXHistogramAxis(options, bucketSize);\n        break;\n      }\n      case 'table': {\n        options.series.bars.barWidth = 0.7;\n        options.series.bars.align = 'center';\n        this.addXTableAxis(options);\n        break;\n      }\n      default: {\n        options.series.bars.barWidth = this.getMinTimeStepOfSeries(this.data) / 1.5;\n        this.addTimeAxis(options);\n        break;\n      }\n    }\n  }\n\n  callPlot(options: any, incrementRenderCounter: boolean) {\n    try {\n      this.plot = $.plot(this.elem, this.sortedSeries, options);\n      if (this.ctrl.renderError) {\n        delete this.ctrl.error;\n      }\n    } catch (e) {\n      console.error('flotcharts error', e);\n      this.ctrl.error = e instanceof Error ? e.message : 'Render Error';\n      this.ctrl.renderError = true;\n    }\n\n    if (incrementRenderCounter) {\n      this.ctrl.renderingCompleted();\n    }\n  }\n\n  buildFlotOptions(panel: any) {\n    let gridColor = '#c8c8c8';\n    if (config.bootData.user.lightTheme === true) {\n      gridColor = '#a1a1a1';\n    }\n    const stack = panel.stack ? true : null;\n    const options: any = {\n      hooks: {\n        draw: [this.drawHook.bind(this)],\n        processOffset: [this.processOffsetHook.bind(this)],\n        processRange: [this.processRangeHook.bind(this)],\n      },\n      legend: { show: false },\n      series: {\n        stackpercent: panel.stack ? panel.percentage : false,\n        stack: panel.percentage ? null : stack,\n        lines: {\n          show: panel.lines,\n          zero: false,\n          fill: this.translateFillOption(panel.fill),\n          fillColor: this.getFillGradient(panel.fillGradient),\n          lineWidth: panel.dashes ? 0 : panel.linewidth,\n          steps: panel.steppedLine,\n        },\n        dashes: {\n          show: panel.dashes,\n          lineWidth: panel.linewidth,\n          dashLength: [panel.dashLength, panel.spaceLength],\n        },\n        bars: {\n          show: panel.bars,\n          fill: 1,\n          barWidth: 1,\n          zero: false,\n          lineWidth: 0,\n        },\n        points: {\n          show: panel.points,\n          fill: 1,\n          fillColor: false,\n          radius: panel.points ? panel.pointradius : 2,\n        },\n        shadowSize: 0,\n      },\n      yaxes: [],\n      xaxis: {},\n      grid: {\n        minBorderMargin: 0,\n        markings: [],\n        backgroundColor: null,\n        borderWidth: 0,\n        hoverable: true,\n        clickable: true,\n        color: gridColor,\n        margin: { left: 0, right: 0 },\n        labelMarginX: 0,\n        mouseActiveRadius: 30,\n      },\n      selection: {\n        mode: 'x',\n        color: '#666',\n      },\n      crosshair: {\n        mode: 'x',\n      },\n    };\n    return options;\n  }\n\n  sortSeries(series: any, panel: any) {\n    const sortBy = panel.legend.sort;\n    const sortOrder = panel.legend.sortDesc;\n    const haveSortBy = sortBy !== null && sortBy !== undefined && panel.legend[sortBy];\n    const haveSortOrder = sortOrder !== null && sortOrder !== undefined;\n    const shouldSortBy = panel.stack && haveSortBy && haveSortOrder && panel.legend.alignAsTable;\n    const sortDesc = panel.legend.sortDesc === true ? -1 : 1;\n\n    if (shouldSortBy) {\n      return _sortBy(series, (s) => s.stats[sortBy] * sortDesc);\n    } else {\n      return _sortBy(series, (s) => s.zindex);\n    }\n  }\n\n  getFillGradient(amount: number) {\n    if (!amount) {\n      return null;\n    }\n\n    return {\n      colors: [{ opacity: 0.0 }, { opacity: amount / 10 }],\n    };\n  }\n\n  translateFillOption(fill: number) {\n    if (this.panel.percentage && this.panel.stack) {\n      return fill === 0 ? 0.001 : fill / 10;\n    } else {\n      return fill / 10;\n    }\n  }\n\n  addTimeAxis(options: any) {\n    const ticks = this.panelWidth / 100;\n    const min = isUndefined(this.ctrl.range!.from) ? null : this.ctrl.range!.from.valueOf();\n    const max = isUndefined(this.ctrl.range!.to) ? null : this.ctrl.range!.to.valueOf();\n\n    options.xaxis = {\n      timezone: this.dashboard.getTimezone(),\n      show: this.panel.xaxis.show,\n      mode: 'time',\n      min: min,\n      max: max,\n      label: 'Datetime',\n      ticks: ticks,\n      timeformat: graphTimeFormat(ticks, min, max),\n      tickFormatter: graphTickFormatter,\n    };\n  }\n\n  addXSeriesAxis(options: any) {\n    const ticks = map(this.data, (series, index) => {\n      return [index + 1, series.alias];\n    });\n\n    options.xaxis = {\n      timezone: this.dashboard.getTimezone(),\n      show: this.panel.xaxis.show,\n      mode: null,\n      min: 0,\n      max: ticks.length + 1,\n      label: 'Datetime',\n      ticks: ticks,\n    };\n  }\n\n  addXHistogramAxis(options: any, bucketSize: number) {\n    let ticks: number | number[];\n    let min: number | undefined;\n    let max: number | undefined;\n\n    const defaultTicks = this.panelWidth / 50;\n\n    if (this.data.length && bucketSize) {\n      const tickValues = [];\n\n      for (const d of this.data) {\n        for (const point of d.data) {\n          tickValues[point[0]] = true;\n        }\n      }\n\n      ticks = Object.keys(tickValues).map((v) => Number(v));\n      min = _min(ticks)!;\n      max = _max(ticks)!;\n\n      // Adjust tick step\n      let tickStep = bucketSize;\n      let ticksNum = Math.floor((max - min) / tickStep);\n      while (ticksNum > defaultTicks) {\n        tickStep = tickStep * 2;\n        ticksNum = Math.ceil((max - min) / tickStep);\n      }\n\n      // Expand ticks for pretty view\n      min = Math.floor(min / tickStep) * tickStep;\n      // 1.01 is 101% - ensure we have enough space for last bar\n      max = Math.ceil((max * 1.01) / tickStep) * tickStep;\n\n      ticks = [];\n      for (let i = min; i <= max; i += tickStep) {\n        ticks.push(i);\n      }\n    } else {\n      // Set defaults if no data\n      ticks = defaultTicks / 2;\n      min = 0;\n      max = 1;\n    }\n\n    options.xaxis = {\n      timezone: this.dashboard.getTimezone(),\n      show: this.panel.xaxis.show,\n      mode: null,\n      min: min,\n      max: max,\n      label: 'Histogram',\n      ticks: ticks,\n    };\n\n    // Use 'short' format for histogram values\n    this.configureAxisMode(options.xaxis, 'short', null);\n  }\n\n  addXTableAxis(options: any) {\n    let ticks = map(this.data, (series, seriesIndex) => {\n      return map(series.datapoints, (point, pointIndex) => {\n        const tickIndex = seriesIndex * series.datapoints.length + pointIndex;\n        return [tickIndex + 1, point[1]];\n      });\n    });\n    // @ts-ignore, potential bug? is this flattenDeep?\n    ticks = flatten(ticks, true);\n\n    options.xaxis = {\n      timezone: this.dashboard.getTimezone(),\n      show: this.panel.xaxis.show,\n      mode: null,\n      min: 0,\n      max: ticks.length + 1,\n      label: 'Datetime',\n      ticks: ticks,\n    };\n  }\n\n  configureYAxisOptions(data: any, options: any) {\n    const defaults = {\n      position: 'left',\n      show: this.panel.yaxes[0].show,\n      index: 1,\n      logBase: this.panel.yaxes[0].logBase || 1,\n      min: this.parseNumber(this.panel.yaxes[0].min),\n      max: this.parseNumber(this.panel.yaxes[0].max),\n      tickDecimals: this.panel.yaxes[0].decimals,\n    };\n\n    options.yaxes.push(defaults);\n\n    if (find(data, { yaxis: 2 })) {\n      const secondY = clone(defaults);\n      secondY.index = 2;\n      secondY.show = this.panel.yaxes[1].show;\n      secondY.logBase = this.panel.yaxes[1].logBase || 1;\n      secondY.position = 'right';\n      secondY.min = this.parseNumber(this.panel.yaxes[1].min);\n      secondY.max = this.parseNumber(this.panel.yaxes[1].max);\n      secondY.tickDecimals = this.panel.yaxes[1].decimals;\n      options.yaxes.push(secondY);\n\n      this.applyLogScale(options.yaxes[1], data);\n      this.configureAxisMode(\n        options.yaxes[1],\n        this.panel.percentage && this.panel.stack ? 'percent' : this.panel.yaxes[1].format,\n        this.panel.yaxes[1].decimals\n      );\n    }\n    this.applyLogScale(options.yaxes[0], data);\n    this.configureAxisMode(\n      options.yaxes[0],\n      this.panel.percentage && this.panel.stack ? 'percent' : this.panel.yaxes[0].format,\n      this.panel.yaxes[0].decimals\n    );\n  }\n\n  parseNumber(value: any) {\n    if (value === null || typeof value === 'undefined') {\n      return null;\n    }\n\n    return toNumber(value);\n  }\n\n  applyLogScale(axis: any, data: any) {\n    if (axis.logBase === 1) {\n      return;\n    }\n\n    const minSetToZero = axis.min === 0;\n\n    if (axis.min < Number.MIN_VALUE) {\n      axis.min = null;\n    }\n    if (axis.max < Number.MIN_VALUE) {\n      axis.max = null;\n    }\n\n    let series, i;\n    let max = axis.max,\n      min = axis.min;\n\n    for (i = 0; i < data.length; i++) {\n      series = data[i];\n      if (series.yaxis === axis.index) {\n        if (!max || max < series.stats.max) {\n          max = series.stats.max;\n        }\n        if (!min || min > series.stats.logmin) {\n          min = series.stats.logmin;\n        }\n      }\n    }\n\n    axis.transform = (v: number) => {\n      return v < Number.MIN_VALUE ? null : Math.log(v) / Math.log(axis.logBase);\n    };\n    axis.inverseTransform = (v: any) => {\n      return Math.pow(axis.logBase, v);\n    };\n\n    if (!max && !min) {\n      max = axis.inverseTransform(+2);\n      min = axis.inverseTransform(-2);\n    } else if (!max) {\n      max = min * axis.inverseTransform(+4);\n    } else if (!min) {\n      min = max * axis.inverseTransform(-4);\n    }\n\n    if (axis.min) {\n      min = axis.inverseTransform(Math.ceil(axis.transform(axis.min)));\n    } else {\n      min = axis.min = axis.inverseTransform(Math.floor(axis.transform(min)));\n    }\n    if (axis.max) {\n      max = axis.inverseTransform(Math.floor(axis.transform(axis.max)));\n    } else {\n      max = axis.max = axis.inverseTransform(Math.ceil(axis.transform(max)));\n    }\n\n    if (!min || min < Number.MIN_VALUE || !max || max < Number.MIN_VALUE) {\n      return;\n    }\n\n    if (Number.isFinite(min) && Number.isFinite(max)) {\n      if (minSetToZero) {\n        axis.min = 0.1;\n        min = 1;\n      }\n\n      axis.ticks = this.generateTicksForLogScaleYAxis(min, max, axis.logBase);\n      if (minSetToZero) {\n        axis.ticks.unshift(0.1);\n      }\n      if (axis.ticks[axis.ticks.length - 1] > axis.max) {\n        axis.max = axis.ticks[axis.ticks.length - 1];\n      }\n    } else {\n      axis.ticks = [1, 2];\n      delete axis.min;\n      delete axis.max;\n    }\n  }\n\n  generateTicksForLogScaleYAxis(min: any, max: number, logBase: number) {\n    let ticks = [];\n\n    let nextTick;\n    for (nextTick = min; nextTick <= max; nextTick *= logBase) {\n      ticks.push(nextTick);\n    }\n\n    const maxNumTicks = Math.ceil(this.ctrl.height / 25);\n    const numTicks = ticks.length;\n    if (numTicks > maxNumTicks) {\n      const factor = Math.ceil(numTicks / maxNumTicks) * logBase;\n      ticks = [];\n\n      for (nextTick = min; nextTick <= max * factor; nextTick *= factor) {\n        ticks.push(nextTick);\n      }\n    }\n\n    return ticks;\n  }\n\n  configureAxisMode(\n    axis: { tickFormatter: (val: any, axis: any) => string },\n    format: string,\n    decimals?: number | null\n  ) {\n    axis.tickFormatter = (val, axis) => {\n      const formatter = getValueFormat(format);\n\n      if (!formatter) {\n        throw new Error(`Unit '${format}' is not supported`);\n      }\n\n      return formattedValueToString(formatter(val, decimals));\n    };\n  }\n}\n\n/** @ngInject */\nfunction graphDirective(timeSrv: TimeSrv, popoverSrv: any, contextSrv: ContextSrv) {\n  return {\n    restrict: 'A',\n    template: '',\n    link: (scope: any, elem: JQuery) => {\n      return new GraphElement(scope, elem, timeSrv);\n    },\n  };\n}\n\ncoreModule.directive('grafanaGraph', graphDirective);\nexport { GraphElement, graphDirective };\n"],"mappings":";;;;AAAA,OAAO,yBAAP;AACA,OAAO,mCAAP;AACA,OAAO,8BAAP;AACA,OAAO,+BAAP;AACA,OAAO,sCAAP;AACA,OAAO,mCAAP;AACA,OAAO,mCAAP;AACA,OAAO,gCAAP;AACA,OAAO,sBAAP;AAEA,OAAOA,CAAP,MAAc,QAAd;AACA,SAASC,KAAT,EAAgBC,IAAhB,EAAsBC,OAAtB,EAA+BC,WAA/B,EAA4CC,GAA5C,EAAiDC,GAAG,IAAIC,IAAxD,EAA8DC,GAAG,IAAIC,IAArE,EAA2EC,MAAM,IAAIC,OAArF,EAA8FC,QAA9F,QAA8G,QAA9G;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,QAAP,MAAqB,WAArB;AAEA,SAEEC,aAFF,EAGEC,mBAHF,EAIEC,cAJF,EAOEC,SAPF,EAQEC,sBARF,EASEC,mBATF,EAUEC,oBAVF,EAWEC,YAXF,EAYEC,cAZF,EAaEC,QAbF,EAeEC,0BAfF,EAgBEC,qBAhBF,EAmBEC,WAnBF,EAoBEC,KApBF,QAqBO,eArBP;AAsBA,SAASC,kBAAT,EAA6BC,eAA7B,QAA6F,aAA7F;AACA,SAASC,UAAT,QAA2B,yBAA3B;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AACA,SAASC,kBAAT,QAAmC,eAAnC;AAEA,SAASC,YAAT,QAA6B,+BAA7B;AACA,SAASC,QAAT,QAAyB,sBAAzB;AAEA,SAASC,qBAAT,QAAsC,6CAAtC;AAKA,SAA2BC,MAA3B,QAAyC,iBAAzC;AACA,SAASC,WAAT,QAA4B,eAA5B;AACA,SAASC,YAAT,QAA6B,iBAA7B;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,SAASC,sBAAT,QAAuC,aAAvC;AAEA,SAASC,gBAAT,QAAiC,qBAAjC;AACA,SAASC,iBAAT,QAAkC,uBAAlC;AACA,SAASC,uBAAT,QAAwC,SAAxC;AAEA,MAAMC,uBAAuB,GAAGX,YAAY,CAACG,MAAD,CAA5C;;AAEA,MAAMS,YAAN,CAAmB;EAgBjBC,WAAW,CACDC,KADC,EAEDC,IAFC,EAKDC,OALC,EAMT;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA,8BAbY,EAaZ;;IAAA;;IAAA;;IAAA;;IAAA;;IAAA,qDA4I4B,CAC5BC,YAD4B,EAE5BC,aAF4B,KAGC;MAC7B,OAAO,MAAM;QACX;QACA,MAAMC,KAAuB,GAAG,KAAKC,SAAL,CAAeC,iBAAf,KAC5B,CACE;UACEF,KAAK,EAAE,CACL;YACEG,KAAK,EAAE,gBADT;YAEEC,SAAS,EAAE,gBAFb;YAGEC,IAAI,EAAE,aAHR;YAIEC,OAAO,EAAE,MAAM,KAAKC,YAAL,CAAkBC,UAAlB,CAA6B;cAAEC,IAAI,EAAEX,YAAY,CAACY,CAArB;cAAwBC,EAAE,EAAE;YAA5B,CAA7B;UAJjB,CADK;QADT,CADF,CAD4B,GAa5B,EAbJ;;QAeA,IAAI,CAACZ,aAAL,EAAoB;UAClB,OAAOC,KAAP;QACD;;QAED,MAAMY,SAAS,GAAG,CAChB;UACEZ,KAAK,EAAED,aAAa,CAACc,QAAd,CAAuB,KAAKC,KAAL,CAAWC,gBAAlC,EAAoD/D,GAApD,CAAwEgE,IAAD,IAAU;YACtF,OAAO;cACLb,KAAK,EAAEa,IAAI,CAACC,KADP;cAELb,SAAS,EAAEY,IAAI,CAACC,KAFX;cAGLC,GAAG,EAAEF,IAAI,CAACG,IAHL;cAILC,MAAM,EAAEJ,IAAI,CAACI,MAJR;cAKLf,IAAI,EAAG,GAAEW,IAAI,CAACI,MAAL,KAAgB,OAAhB,GAA0B,MAA1B,GAAmC,mBAAoB,EAL3D;cAMLd,OAAO,EAAEU,IAAI,CAACV;YANT,CAAP;UAQD,CATM;QADT,CADgB,CAAlB;QAeA,OAAO,CAAC,GAAGN,KAAJ,EAAW,GAAGY,SAAd,CAAP;MACD,CArCD;IAsCD,CAtLC;;IAAA,KALQjB,KAKR,GALQA,KAKR;IAAA,KAJQC,IAIR,GAJQA,IAIR;IAAA,KADQC,OACR,GADQA,OACR;IACA,KAAKwB,IAAL,GAAY1B,KAAK,CAAC0B,IAAlB;IACA,KAAKC,WAAL,GAAmB3B,KAAK,CAAC0B,IAAN,CAAWE,eAA9B;IACA,KAAKtB,SAAL,GAAiB,KAAKoB,IAAL,CAAUpB,SAA3B;IACA,KAAKa,KAAL,GAAa,KAAKO,IAAL,CAAUP,KAAvB;IACA,KAAKU,WAAL,GAAmB,EAAnB;IAEA,KAAKC,UAAL,GAAkB,CAAlB;IACA,KAAKlB,YAAL,GAAoB,IAAIrB,YAAJ,CAAiB,KAAKmC,IAAtB,CAApB;IACA,KAAKK,gBAAL,GAAwB,IAAIrC,gBAAJ,CAAqB,KAAKgC,IAA1B,CAAxB;IACA,KAAKM,iBAAL,GAAyB,IAAIrC,iBAAJ,CAAsB,KAAK+B,IAA3B,CAAzB,CAVA,CAWA;;IACA,KAAKO,OAAL,GAAe,IAAIzC,YAAJ,CAAiB,KAAKS,IAAtB,EAA4B,KAAKyB,IAAL,CAAUpB,SAAtC,EAAiD,KAAKN,KAAtD,EAA6D,MAAM;MAChF,OAAO,KAAKkC,YAAZ;IACD,CAFc,CAAf,CAZA,CAgBA;;IACA,KAAKR,IAAL,CAAUS,MAAV,CAAiBC,EAAjB,CAAoBzD,WAAW,CAAC0D,aAAhC,EAA+C,KAAKC,eAAL,CAAqBC,IAArB,CAA0B,IAA1B,CAA/C;IACA,KAAKb,IAAL,CAAUS,MAAV,CAAiBC,EAAjB,CAAoBzD,WAAW,CAAC6D,MAAhC,EAAwC,KAAKC,QAAL,CAAcF,IAAd,CAAmB,IAAnB,CAAxC,EAlBA,CAoBA;IACA;;IACA,KAAKb,IAAL,CAAUpB,SAAV,CAAoB6B,MAApB,CAA2BC,EAA3B,CAA8B1D,qBAAqB,CAACgE,IAApD,EAA0D,KAAKC,YAAL,CAAkBJ,IAAlB,CAAuB,IAAvB,CAA1D,EAAwF,KAAKvC,KAA7F;IACA,KAAK0B,IAAL,CAAUpB,SAAV,CAAoB6B,MAApB,CAA2BC,EAA3B,CAA8B3D,0BAA0B,CAACiE,IAAzD,EAA+D,KAAKE,iBAAL,CAAuBL,IAAvB,CAA4B,IAA5B,CAA/D,EAAkG,KAAKvC,KAAvG;IAEA,KAAK0B,IAAL,CAAUpB,SAAV,CAAoB6B,MAApB,CAA2BC,EAA3B,CAA8BnE,cAAc,CAACyE,IAA7C,EAAmD,KAAKC,YAAL,CAAkBJ,IAAlB,CAAuB,IAAvB,CAAnD,EAAiF,KAAKvC,KAAtF;IACA,KAAK0B,IAAL,CAAUpB,SAAV,CAAoB6B,MAApB,CAA2BC,EAA3B,CAA8BpE,mBAAmB,CAAC0E,IAAlD,EAAwD,KAAKE,iBAAL,CAAuBL,IAAvB,CAA4B,IAA5B,CAAxD,EAA2F,KAAKvC,KAAhG,EA1BA,CA4BA;;IACA,KAAKC,IAAL,CAAUsC,IAAV,CAAe,cAAf,EAA+B,KAAKM,cAAL,CAAoBN,IAApB,CAAyB,IAAzB,CAA/B;IACA,KAAKtC,IAAL,CAAUsC,IAAV,CAAe,WAAf,EAA4B,KAAKO,WAAL,CAAiBP,IAAjB,CAAsB,IAAtB,CAA5B,EA9BA,CAgCA;;IACA,IAAI,KAAKtC,IAAL,IAAa,KAAKA,IAAL,CAAU8C,MAA3B,EAAmC;MACjC,KAAKC,UAAL,GAAkB,KAAK/C,IAAL,CAAU8C,MAAV,GAAmB7F,IAAnB,CAAwB,eAAxB,EAAyC,CAAzC,CAAlB;IACD;EACF;;EAEDuF,QAAQ,CAACQ,UAAD,EAAoB;IAC1B,KAAKC,IAAL,GAAYD,UAAU,IAAI,KAAKC,IAA/B;;IACA,IAAI,CAAC,KAAKA,IAAV,EAAgB;MACd;IACD;;IAED,KAAKrB,WAAL,GAAmB,KAAKH,IAAL,CAAUG,WAAV,IAAyB,EAA5C;IACA,KAAKsB,cAAL,CAAoB,KAAKD,IAAzB;IACA,MAAME,WAAW,GAAG,KAAK1B,IAAL,CAAU2B,MAA9B;IACApE,kBAAkB,CAAC,KAAKiE,IAAN,EAAY,KAAK/B,KAAjB,EAAwBiC,WAAxB,CAAlB;;IAEA,IAAI,CAAC,KAAKjC,KAAL,CAAWmC,MAAX,CAAkBC,IAAvB,EAA6B;MAC3B,IAAI,KAAKP,UAAL,CAAgBQ,aAAhB,EAAJ,EAAqC;QACnC1F,QAAQ,CAAC2F,sBAAT,CAAgC,KAAKT,UAArC;MACD;;MACD,KAAKU,WAAL;MACA;IACD;;IAED,MAAM;MAAEC,MAAF;MAAUnG,GAAV;MAAeF,GAAf;MAAoBsG,GAApB;MAAyBC,OAAzB;MAAkCC;IAAlC,IAA4C,KAAK3C,KAAL,CAAWmC,MAA7D;IACA,MAAM;MAAES,YAAF;MAAgBC,SAAhB;MAA2BC,SAA3B;MAAsCC,IAAtC;MAA4CC,QAA5C;MAAsDC,SAAtD;MAAiEC;IAAjE,IAA8E,KAAKlD,KAAL,CAAWmC,MAA/F;IACA,MAAMgB,aAAa,GAAG;MAAEP,YAAF;MAAgBC,SAAhB;MAA2BC,SAA3B;MAAsCC,IAAtC;MAA4CC,QAA5C;MAAsDC,SAAtD;MAAiEC;IAAjE,CAAtB;IACA,MAAME,YAAY,GAAG;MAAEZ,MAAF;MAAUnG,GAAV;MAAeF,GAAf;MAAoBsG,GAApB;MAAyBC,OAAzB;MAAkCC;IAAlC,CAArB;IACA,MAAMU,WAA6B;MACjCC,UAAU,EAAE,KAAKvB,IADgB;MAEjCwB,YAAY,EAAE,KAAKhD,IAAL,CAAUgD;IAFS,GAG9BJ,aAH8B,EAI9BC,YAJ8B;MAKjCI,cAAc,EAAE,KAAKjD,IAAL,CAAUiD,cALO;MAMjCC,YAAY,EAAE,KAAKlD,IAAL,CAAUkD,YANS;MAOjCC,aAAa,EAAE,KAAKnD,IAAL,CAAUmD,aAPQ;MAQjCC,YAAY,EAAE,KAAKpD,IAAL,CAAUoD;IARS,EAAnC;IAWA,MAAMC,eAAe,gBAAGlH,KAAK,CAACmH,aAAN,CAAoBnF,uBAApB,EAA6C2E,WAA7C,CAAxB;IACA1G,QAAQ,CAAC0E,MAAT,CAAgBuC,eAAhB,EAAiC,KAAK/B,UAAtC,EAAkD,MAAM,KAAKU,WAAL,EAAxD;EACD;;EAEDf,YAAY,CAACsC,GAAD,EAAuD;IAAA;;IACjE;IACA,IAAI,CAAC,KAAK3E,SAAL,CAAe4E,wBAAf,EAAL,EAAgD;MAC9C;IACD;;IAED,IAAItF,uBAAuB,CAACqF,GAAD,CAA3B,EAAkC;MAAA;;MAChC;MACA,IAAI,CAAC,KAAKE,IAAN,IAAc,eAAAF,GAAG,CAAC9D,KAAJ,0DAAWiE,EAAX,MAAkB,KAAKjE,KAAL,CAAWiE,EAA3C,IAAiD,KAAK1D,IAAL,CAAU2D,0BAAV,EAArD,EAA6F;QAC3F;MACD;;MAED,KAAKpD,OAAL,CAAasB,IAAb,CAAkB0B,GAAG,CAACK,GAAtB;IACD,CAbgE,CAejE;;;IACA,IAAI,gBAACL,GAAG,CAACM,KAAL,uCAAC,WAAWC,IAAZ,CAAJ,EAAsB;MACpB;IACD;;IAED,KAAKvD,OAAL,CAAasB,IAAb,CAAkB;MAAExC,CAAC,EAAEkE,GAAG,CAACM,KAAJ,CAAUC,IAAf;MAAqBC,SAAS,0BAAER,GAAG,CAACM,KAAJ,CAAUE,SAAZ,uEAAyB;IAAvD,CAAlB;EACD;;EAEDnD,eAAe,GAAG;IAChB,IAAI,KAAK6C,IAAT,EAAe;MACb,KAAKA,IAAL,CAAUO,OAAV;MACA,KAAKP,IAAL,GAAY,IAAZ;IACD;;IAED,KAAKlD,OAAL,CAAayD,OAAb;IACA,KAAKzF,IAAL,CAAU0F,GAAV;IACA,KAAK1F,IAAL,CAAU2F,MAAV;IAEA9H,QAAQ,CAAC2F,sBAAT,CAAgC,KAAKT,UAArC;EACD;;EAEDJ,iBAAiB,CAACiD,OAAD,EAAmC;IAClD,IAAI,KAAKV,IAAT,EAAe;MACb,KAAKlD,OAAL,CAAa6D,KAAb,CAAmB,KAAKX,IAAxB;IACD;EACF;;EAEDtC,cAAc,CAACkD,KAAD,EAA2BC,MAA3B,EAAwC;IACpD,IAAI,KAAK7E,KAAL,CAAW8E,KAAX,CAAiBC,IAAjB,KAA0B,MAA9B,EAAsC;MACpC;MACA,KAAKf,IAAL,CAAUgB,cAAV;MACA;IACD;;IAED,IAAI,CAACH,MAAM,CAACI,OAAP,IAAkBJ,MAAM,CAACK,OAA1B,KAAsC,KAAK/F,SAAL,CAAeC,iBAAf,EAA1C,EAA8E;MAC5E;MACA+F,UAAU,CAAC,MAAM;QACf,KAAK1F,YAAL,CAAkBC,UAAlB,CAA6BmF,MAAM,CAACC,KAApC;MACD,CAFS,EAEP,GAFO,CAAV;IAGD,CALD,MAKO;MACL,KAAKjG,KAAL,CAAWuG,MAAX,CAAkB,MAAM;QACtB,KAAKrG,OAAL,CAAasG,OAAb,CAAqB;UACnB1F,IAAI,EAAElC,KAAK,CAACoH,MAAM,CAACC,KAAP,CAAanF,IAAd,CADQ;UAEnBE,EAAE,EAAEpC,KAAK,CAACoH,MAAM,CAACC,KAAP,CAAajF,EAAd;QAFU,CAArB;MAID,CALD;IAMD;EACF;;EA8CD8B,WAAW,CAACiD,KAAD,EAA2BT,GAA3B,EAAqCmB,IAArC,EAAgD;IACzD,MAAMC,oBAAoB,GAAG,KAAKzG,IAAL,CAAU0G,OAAV,CAAkB,OAAlB,IAA6B,KAAK1G,IAAL,CAAU0G,OAAV,CAAkB,OAAlB,EAA2BC,GAA3B,GAAiC,CAAjC,CAA7B,GAAmE,IAAhG;IACA,MAAMC,qBAAqB,GAAGJ,IAA9B;;IAEA,IAAI,KAAKtF,KAAL,CAAW8E,KAAX,CAAiBC,IAAjB,KAA0B,MAA9B,EAAsC;MACpC;MACA;IACD;;IAED,IAAIZ,GAAG,CAACc,OAAJ,IAAed,GAAG,CAACe,OAAvB,EAAgC;MAC9B;MACA,IAAIf,GAAG,CAACvE,CAAJ,KAAUuE,GAAG,CAACwB,EAAlB,EAAsB;QACpB;MACD,CAJ6B,CAM9B;;;MACA,IAAI,CAAC,KAAKxG,SAAL,CAAe8E,EAAhB,IAAsB,CAAC,KAAK9E,SAAL,CAAeC,iBAAf,EAA3B,EAA+D;QAC7D;MACD;;MAED+F,UAAU,CAAC,MAAM;QACf,KAAK1F,YAAL,CAAkBC,UAAlB,CAA6B;UAAEC,IAAI,EAAEwE,GAAG,CAACvE,CAAZ;UAAeC,EAAE,EAAE;QAAnB,CAA7B;MACD,CAFS,EAEP,GAFO,CAAV;MAGA;IACD,CAfD,MAeO;MACL,KAAKiB,OAAL,CAAa6D,KAAb,CAAmB,KAAKX,IAAxB;MACA,IAAI/E,aAAJ;;MAEA,IAAIqG,IAAJ,EAAU;QACR;QACA,MAAMM,WAAW,GAAG,KAAK5F,KAAL,CAAW6F,KAAX,CAAiBP,IAAI,CAACQ,MAAL,CAAYC,KAAZ,CAAkBC,CAAlB,KAAwB,CAAxB,GAA4B,CAA5B,GAAgC,CAAjD,CAApB;QACA,MAAMC,SAAS,GAAG,KAAK1F,IAAL,CAAU2F,QAAV,CAAmBZ,IAAI,CAACQ,MAAL,CAAYK,cAA/B,CAAlB;QACA,MAAMC,KAAK,GAAGH,SAAS,CAACI,MAAV,CAAiBf,IAAI,CAACQ,MAAL,CAAYQ,UAA7B,CAAd;QACA,MAAMC,SAAS,GAAG,KAAKC,oCAAL,CAA0ClB,IAA1C,EAAgDW,SAAhD,CAAlB;QAEA,IAAIQ,KAAY,GAAG,KAAKzG,KAAL,CAAW0G,OAAX,CAAmB5G,SAAnB,IAAgC,EAAnD;QACA,MAAM6G,aAAa,GAAGtJ,QAAQ,CAAC+I,KAAD,CAA9B;;QACA,IAAIO,aAAJ,EAAmB;UACjB;UACAF,KAAK,GAAG,CAAC,GAAGA,KAAJ,EAAW,GAAGL,KAAK,CAACvI,MAAN,CAAa4I,KAA3B,CAAR;QACD;;QACD,MAAMG,WAAW,GAAG;UAClBC,QAAQ,EAAEjB,WAAW,CAACiB,QADJ;UAElBJ;QAFkB,CAApB;QAIA,MAAMK,YAAY,GAAG7J,mBAAmB,CAAC;UACvCmJ,KAAK,EAAE;YAAEvI,MAAM,EAAE+I,WAAV;YAAuBrF,IAAI,EAAExE,SAAS,CAACgK;UAAvC,CADgC;UAEvCC,KAAK,EAAEnJ,MAAM,CAACoJ,MAFyB;UAGvCC,QAAQ,EAAE,KAAK/H,SAAL,CAAegI,WAAf;QAH6B,CAAD,CAAnB,CAIlBf,KAAK,CAAC5D,MAAN,CAAaiD,GAAb,CAAiBc,SAAjB,CAJkB,CAArB;QAKAtH,aAAa,GAAGwH,KAAK,CAACW,MAAN,GACZnJ,qBAAqB,CAAC;UACpBoJ,OAAO,EAAEP,YADW;UAEpBQ,IAAI,EAAElB,KAAK,CAACkB,IAFQ;UAGpBC,IAAI,EAAE,IAAI3K,aAAJ,CAAkBqJ,SAAlB,CAHc;UAIpBuB,QAAQ,EAAEjB,SAJU;UAKpBkB,QAAQ,EAAEnC,IAAI,CAACQ,MAAL,CAAYQ,UALF;UAMpBF,KAAK,EAAEQ,WANa;UAOpBvJ,QAAQ,EAAEsJ;QAPU,CAAD,CADT,GAUZe,SAVJ;MAWD;;MAED,KAAK7I,KAAL,CAAWuG,MAAX,CAAkB,MAAM;QACtB;QACA,KAAK5E,WAAL,CAAiBmH,uBAAjB,CAAyCpC,oBAAzC;QACA,KAAK/E,WAAL,CAAiBoH,SAAjB,CAA2BlC,qBAA3B;QACA,KAAKlF,WAAL,CAAiBqH,oBAAjB,CAAsC,KAAKC,2BAAL,CAAiC3D,GAAjC,EAAsClF,aAAtC,CAAtC;QACA,KAAKuB,WAAL,CAAiBuH,UAAjB,CAA4B5D,GAA5B;MACD,CAND;IAOD;EACF;;EAEDqC,oCAAoC,CAAClB,IAAD,EAAYW,SAAZ,EAA0C;IAC5E;AACJ;AACA;AACA;AACA;AACA;IACI,MAAM;MAAE+B,SAAF;MAAazB;IAAb,IAA2BjB,IAAjC;;IAEA,IAAI,CAAC2C,KAAK,CAACC,OAAN,CAAcF,SAAd,CAAD,IAA6BA,SAAS,CAACZ,MAAV,KAAqB,CAAtD,EAAyD;MACvD,OAAOb,SAAP;IACD;;IAED,MAAM4B,EAAE,GAAGH,SAAS,CAAC,CAAD,CAApB;IACA,MAAM;MAAEI;IAAF,IAAgBjL,YAAY,CAAC8I,SAAD,CAAlC;;IAEA,IAAI,CAACmC,SAAD,IAAc,CAACA,SAAS,CAAC5F,MAA7B,EAAqC;MACnC,OAAO+D,SAAP;IACD;;IAED,MAAMH,KAAK,GAAGgC,SAAS,CAAC5F,MAAV,CAAiBiD,GAAjB,CAAqBc,SAArB,CAAd;;IAEA,IAAIH,KAAK,KAAK+B,EAAd,EAAkB;MAChB,OAAO5B,SAAP;IACD;;IAED,MAAM8B,YAAY,GAAGD,SAAS,CAAC5F,MAAV,CAAiB8F,OAAjB,GAA2BC,SAA3B,CAAsCC,KAAD,IAAWA,KAAK,KAAKL,EAA1D,CAArB;IACA,OAAOE,YAAY,GAAG,CAAC,CAAhB,GAAoBA,YAApB,GAAmC9B,SAA1C;EACD;;EAEDkC,iBAAiB,GAAG;IAClB,IAAI,CAAC,KAAK1G,IAAV,EAAgB;MACd,OAAO,IAAP;IACD;;IAED,IAAI,KAAKpB,UAAL,KAAoB,CAAxB,EAA2B;MACzB,OAAO,IAAP;IACD;;IAED,OAAO,KAAP;EACD;;EAED+H,QAAQ,CAAC1E,IAAD,EAAY;IAClB;IACA,IAAI,KAAKhE,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBxG,KAApB,IAA6B,KAAKW,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBzD,IAArD,EAA2D;MACzDvG,CAAC,CAAC,+DAAD,CAAD,CACG8M,IADH,CACQ,KAAK3I,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBxG,KAD5B,EAEGuJ,QAFH,CAEY,KAAK9J,IAFjB;IAGD,CANiB,CAQlB;;;IACA,IAAI,KAAKkB,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBxG,KAApB,IAA6B,KAAKW,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBzD,IAArD,EAA2D;MACzDvG,CAAC,CAAC,gEAAD,CAAD,CACG8M,IADH,CACQ,KAAK3I,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBxG,KAD5B,EAEGuJ,QAFH,CAEY,KAAK9J,IAFjB;IAGD;;IAED,MAAM;MAAE+J;IAAF,IAAkB,KAAKtI,IAA7B;;IACA,IAAIsI,WAAJ,EAAiB;MACf,MAAMC,GAAG,GAAGjN,CAAC,CAAE,kDAAiDgN,WAAW,CAAC1I,KAAM,QAArE,CAAb;;MACA,IAAI0I,WAAW,CAACE,MAAhB,EAAwB;QACtBlN,CAAC,CAAE,qCAAoCgN,WAAW,CAACG,UAAW,WAA7D,CAAD,CACGC,KADH,CACSJ,WAAW,CAACE,MADrB,EAEGH,QAFH,CAEYE,GAFZ;MAGD;;MACDA,GAAG,CAACF,QAAJ,CAAa,KAAK9J,IAAlB;IACD;;IACD,KAAK8B,gBAAL,CAAsBsI,IAAtB,CAA2BlF,IAA3B;IACA,KAAKnD,iBAAL,CAAuBqI,IAAvB,CAA4BlF,IAA5B;EACD;;EAEDmF,iBAAiB,CAACnF,IAAD,EAAYoF,UAAZ,EAAyD;IACxE,MAAMC,IAAI,GAAG,KAAKrJ,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,CAAb;IACA,MAAMyD,KAAK,GAAG,KAAKtJ,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,CAAd;;IACA,IAAIwD,IAAI,CAACjH,IAAL,IAAaiH,IAAI,CAAChK,KAAtB,EAA6B;MAC3B+J,UAAU,CAACC,IAAX,GAAkB,EAAlB;IACD;;IACD,IAAIC,KAAK,CAAClH,IAAN,IAAckH,KAAK,CAACjK,KAAxB,EAA+B;MAC7B+J,UAAU,CAACE,KAAX,GAAmB,EAAnB;IACD,CARuE,CAUxE;;;IACA,MAAMvD,KAAK,GAAG/B,IAAI,CAACuF,QAAL,EAAd;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzD,KAAK,CAACqB,MAA1B,EAAkCoC,CAAC,EAAnC,EAAuC;MACrC,MAAMC,IAAS,GAAG1D,KAAK,CAACyD,CAAD,CAAvB;MACA,MAAME,YAAY,GAAG,KAAK1J,KAAL,CAAW6F,KAAX,CAAiB2D,CAAjB,CAArB;MACAC,IAAI,CAAC/C,OAAL,CAAavK,GAAb,GAAmBsN,IAAI,CAAC/C,OAAL,CAAavK,GAAb,KAAqB,IAArB,GAA4BsN,IAAI,CAAC/C,OAAL,CAAavK,GAAzC,GAA+CuN,YAAY,CAACvN,GAA/E;MACAsN,IAAI,CAAC/C,OAAL,CAAarK,GAAb,GAAmBoN,IAAI,CAAC/C,OAAL,CAAarK,GAAb,KAAqB,IAArB,GAA4BoN,IAAI,CAAC/C,OAAL,CAAarK,GAAzC,GAA+CqN,YAAY,CAACrN,GAA/E;IACD;EACF;;EAEDsN,gBAAgB,CAAC3F,IAAD,EAAY;IAC1B,MAAM4F,KAAK,GAAG5F,IAAI,CAACuF,QAAL,EAAd;IACA,MAAMM,KAAK,GAAG,KAAK7J,KAAL,CAAW+F,KAAX,CAAiB8D,KAAjB,IAA0B,KAAxC;;IAEA,IAAID,KAAK,CAACxC,MAAN,GAAe,CAAf,IAAoByC,KAAK,KAAK,IAAlC,EAAwC;MACtC,MAAMC,KAAK,GAAG,KAAK9J,KAAL,CAAW+F,KAAX,CAAiBgE,UAAjB,IAA+B,CAA7C;MACA5L,WAAW,CAACyL,KAAD,EAAQI,UAAU,CAACF,KAAD,CAAlB,CAAX;IACD;EACF,CA1XgB,CA4XjB;EACA;EACA;;;EACAG,sBAAsB,CAAClI,IAAD,EAAc;IAClC,IAAI1F,GAAG,GAAG6N,MAAM,CAACC,SAAjB;;IAEA,KAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzH,IAAI,CAACqF,MAAzB,EAAiCoC,CAAC,EAAlC,EAAsC;MACpC,IAAI,CAACzH,IAAI,CAACyH,CAAD,CAAJ,CAAQY,KAAR,CAAcC,QAAnB,EAA6B;QAC3B;MACD;;MACD,IAAI,KAAKrK,KAAL,CAAWsK,IAAf,EAAqB;QACnB,IAAIvI,IAAI,CAACyH,CAAD,CAAJ,CAAQc,IAAR,IAAgBvI,IAAI,CAACyH,CAAD,CAAJ,CAAQc,IAAR,CAAalI,IAAb,KAAsB,KAA1C,EAAiD;UAC/C;QACD;MACF,CAJD,MAIO;QACL,IAAI,OAAOL,IAAI,CAACyH,CAAD,CAAJ,CAAQc,IAAf,KAAwB,WAAxB,IAAuC,OAAOvI,IAAI,CAACyH,CAAD,CAAJ,CAAQc,IAAR,CAAalI,IAApB,KAA6B,WAApE,IAAmF,CAACL,IAAI,CAACyH,CAAD,CAAJ,CAAQc,IAAR,CAAalI,IAArG,EAA2G;UACzG;QACD;MACF;;MAED,IAAIL,IAAI,CAACyH,CAAD,CAAJ,CAAQY,KAAR,CAAcC,QAAd,GAAyBhO,GAA7B,EAAkC;QAChCA,GAAG,GAAG0F,IAAI,CAACyH,CAAD,CAAJ,CAAQY,KAAR,CAAcC,QAApB;MACD;IACF;;IAED,OAAOhO,GAAP;EACD,CAtZgB,CAwZjB;;;EACAkG,WAAW,GAAG;IAAA;;IACZ,KAAK5B,UAAL,uBAAkB,KAAK7B,IAAL,CAAUyL,KAAV,EAAlB,+DAAuC,CAAvC;;IAEA,IAAI,KAAK9B,iBAAL,EAAJ,EAA8B;MAC5B;IACD,CALW,CAOZ;;;IACA,KAAK7H,gBAAL,CAAsB4J,OAAtB,CAA8B,KAAK1L,IAAnC,EAAyC,KAAKiD,IAA9C,EARY,CAUZ;;IACA,KAAK/B,KAAL,CAAWyK,MAAX,GAAoB,KAAKzK,KAAL,CAAW0K,KAAX,GAAmB,KAAK1K,KAAL,CAAWyK,MAA9B,GAAuC,KAA3D,CAXY,CAaZ;;IACA,MAAM/D,OAAY,GAAG,KAAKiE,gBAAL,CAAsB,KAAK3K,KAA3B,CAArB;IACA,KAAK4K,YAAL,CAAkBlE,OAAlB,EAA2B,KAAK1G,KAAhC;IACA,KAAK6K,qBAAL,CAA2B,KAAK9I,IAAhC,EAAsC2E,OAAtC;IACA,KAAK9F,gBAAL,CAAsBkK,cAAtB,CAAqCpE,OAArC,EAA8C,KAAK1G,KAAnD;IACA,KAAKa,iBAAL,CAAuBiK,cAAvB,CAAsCpE,OAAtC,EAA+C,KAAK1G,KAApD;IACA,KAAKP,YAAL,CAAkBsL,aAAlB,CAAgC,KAAKrK,WAArC,EAAkDgG,OAAlD;IACA,KAAK3F,YAAL,GAAoB,KAAKiK,UAAL,CAAgB,KAAKjJ,IAArB,EAA2B,KAAK/B,KAAhC,CAApB;IACA,KAAKiL,QAAL,CAAcvE,OAAd,EAAuB,IAAvB;EACD;;EAED1E,cAAc,CAACD,IAAD,EAAY;IACxB,KAAK,IAAIyH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzH,IAAI,CAACqF,MAAzB,EAAiCoC,CAAC,EAAlC,EAAsC;MACpC,MAAM1D,MAAM,GAAG/D,IAAI,CAACyH,CAAD,CAAnB;MACA1D,MAAM,CAAC/D,IAAP,GAAc+D,MAAM,CAACoF,YAAP,CAAoBpF,MAAM,CAACqF,aAAP,IAAwB,KAAKnL,KAAL,CAAWmL,aAAvD,CAAd;;MAEA,IAAIrF,MAAM,CAACsF,SAAP,KAAqB,UAAzB,EAAqC;QACnCtF,MAAM,CAAC/D,IAAP,GAAc7E,oBAAoB,CAAC4I,MAAM,CAAC/D,IAAR,EAAc,KAAKxB,IAAL,CAAU8K,KAAxB,CAAlC;MACD,CANmC,CAQpC;;;MACA,IAAI,KAAK9K,IAAL,CAAUgD,YAAV,CAAuBuC,MAAM,CAACwF,KAA9B,CAAJ,EAA0C;QACxCxF,MAAM,CAAC/D,IAAP,GAAc,EAAd;QACA+D,MAAM,CAACyF,KAAP,GAAe,KAAf;MACD;IACF;EACF;;EAEDX,YAAY,CAAClE,OAAD,EAAe1G,KAAf,EAA2B;IACrC,QAAQA,KAAK,CAAC8E,KAAN,CAAYC,IAApB;MACE,KAAK,QAAL;QAAe;UACb2B,OAAO,CAACZ,MAAR,CAAewE,IAAf,CAAoBkB,QAApB,GAA+B,GAA/B;UACA9E,OAAO,CAACZ,MAAR,CAAewE,IAAf,CAAoBT,KAApB,GAA4B,QAA5B;;UAEA,KAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKzH,IAAL,CAAUqF,MAA9B,EAAsCoC,CAAC,EAAvC,EAA2C;YACzC,MAAM1D,MAAM,GAAG,KAAK/D,IAAL,CAAUyH,CAAV,CAAf;YACA1D,MAAM,CAAC/D,IAAP,GAAc,CAAC,CAACyH,CAAC,GAAG,CAAL,EAAQ1D,MAAM,CAACsE,KAAP,CAAapK,KAAK,CAAC8E,KAAN,CAAYtC,MAAZ,CAAmB,CAAnB,CAAb,CAAR,CAAD,CAAd;UACD;;UAED,KAAKiJ,cAAL,CAAoB/E,OAApB;UACA;QACD;;MACD,KAAK,WAAL;QAAkB;UAChB,IAAIgF,UAAJ;;UAEA,IAAI,KAAK3J,IAAL,CAAUqF,MAAd,EAAsB;YACpB,IAAIuE,OAAO,GAAGrP,IAAI,CAACJ,GAAG,CAAC,KAAK6F,IAAN,EAAa6J,CAAD,IAAOA,CAAC,CAACxB,KAAF,CAAQ/N,GAA3B,CAAJ,CAAlB;;YACA,IAAIwP,OAAO,GAAGzP,IAAI,CAACF,GAAG,CAAC,KAAK6F,IAAN,EAAa6J,CAAD,IAAOA,CAAC,CAACxB,KAAF,CAAQjO,GAA3B,CAAJ,CAAlB;;YACA,MAAM2P,KAAK,GAAG9L,KAAK,CAAC8E,KAAN,CAAYiH,OAAZ,IAAuB,KAAKpL,UAAL,GAAkB,EAAvD;;YACA,IAAIX,KAAK,CAAC8E,KAAN,CAAYzI,GAAZ,IAAmB,IAAvB,EAA6B;cAC3B,MAAM2P,iBAAiB,GAAGhO,QAAQ,CAACgC,KAAK,CAAC8E,KAAN,CAAYzI,GAAb,EAAkBwP,OAAlB,EAA2BC,KAA3B,CAAR,IAA6C,CAAvE;cACAH,OAAO,GAAGK,iBAAiB,GAAGL,OAAH,GAAa3L,KAAK,CAAC8E,KAAN,CAAYzI,GAApD;YACD;;YACD,IAAI2D,KAAK,CAAC8E,KAAN,CAAY3I,GAAZ,IAAmB,IAAvB,EAA6B;cAC3B,MAAM8P,iBAAiB,GAAGjO,QAAQ,CAAC2N,OAAD,EAAU3L,KAAK,CAAC8E,KAAN,CAAY3I,GAAtB,EAA2B2P,KAA3B,CAAR,IAA6C,CAAvE;cACAD,OAAO,GAAGI,iBAAiB,GAAGJ,OAAH,GAAa7L,KAAK,CAAC8E,KAAN,CAAY3I,GAApD;YACD;;YACDuP,UAAU,GAAG1N,QAAQ,CAAC2N,OAAD,EAAUE,OAAV,EAAmBC,KAAnB,CAArB;YACApF,OAAO,CAACZ,MAAR,CAAewE,IAAf,CAAoBkB,QAApB,GAA+BE,UAAU,GAAG,GAA5C;YACA,KAAK3J,IAAL,GAAYzD,sBAAsB,CAAC,KAAKyD,IAAN,EAAY2J,UAAZ,EAAwB,KAAKnL,IAAL,CAAUgD,YAAlC,EAAgDoI,OAAhD,EAAyDE,OAAzD,CAAlC;UACD,CAfD,MAeO;YACLH,UAAU,GAAG,CAAb;UACD;;UAED,KAAKQ,iBAAL,CAAuBxF,OAAvB,EAAgCgF,UAAhC;UACA;QACD;;MACD,KAAK,OAAL;QAAc;UACZhF,OAAO,CAACZ,MAAR,CAAewE,IAAf,CAAoBkB,QAApB,GAA+B,GAA/B;UACA9E,OAAO,CAACZ,MAAR,CAAewE,IAAf,CAAoBT,KAApB,GAA4B,QAA5B;UACA,KAAKsC,aAAL,CAAmBzF,OAAnB;UACA;QACD;;MACD;QAAS;UACPA,OAAO,CAACZ,MAAR,CAAewE,IAAf,CAAoBkB,QAApB,GAA+B,KAAKvB,sBAAL,CAA4B,KAAKlI,IAAjC,IAAyC,GAAxE;UACA,KAAKqK,WAAL,CAAiB1F,OAAjB;UACA;QACD;IAhDH;EAkDD;;EAEDuE,QAAQ,CAACvE,OAAD,EAAe2F,sBAAf,EAAgD;IACtD,IAAI;MACF,KAAKrI,IAAL,GAAYnI,CAAC,CAACmI,IAAF,CAAO,KAAKlF,IAAZ,EAAkB,KAAKiC,YAAvB,EAAqC2F,OAArC,CAAZ;;MACA,IAAI,KAAKnG,IAAL,CAAU+L,WAAd,EAA2B;QACzB,OAAO,KAAK/L,IAAL,CAAUgM,KAAjB;MACD;IACF,CALD,CAKE,OAAOC,CAAP,EAAU;MACVC,OAAO,CAACF,KAAR,CAAc,kBAAd,EAAkCC,CAAlC;MACA,KAAKjM,IAAL,CAAUgM,KAAV,GAAkBC,CAAC,YAAYE,KAAb,GAAqBF,CAAC,CAACG,OAAvB,GAAiC,cAAnD;MACA,KAAKpM,IAAL,CAAU+L,WAAV,GAAwB,IAAxB;IACD;;IAED,IAAID,sBAAJ,EAA4B;MAC1B,KAAK9L,IAAL,CAAUqM,kBAAV;IACD;EACF;;EAEDjC,gBAAgB,CAAC3K,KAAD,EAAa;IAC3B,IAAI6M,SAAS,GAAG,SAAhB;;IACA,IAAIhP,MAAM,CAACiP,QAAP,CAAgBC,IAAhB,CAAqBC,UAArB,KAAoC,IAAxC,EAA8C;MAC5CH,SAAS,GAAG,SAAZ;IACD;;IACD,MAAMtB,KAAK,GAAGvL,KAAK,CAACuL,KAAN,GAAc,IAAd,GAAqB,IAAnC;IACA,MAAM7E,OAAY,GAAG;MACnBuG,KAAK,EAAE;QACL/D,IAAI,EAAE,CAAC,KAAKR,QAAL,CAActH,IAAd,CAAmB,IAAnB,CAAD,CADD;QAEL8L,aAAa,EAAE,CAAC,KAAK/D,iBAAL,CAAuB/H,IAAvB,CAA4B,IAA5B,CAAD,CAFV;QAGL+L,YAAY,EAAE,CAAC,KAAKxD,gBAAL,CAAsBvI,IAAtB,CAA2B,IAA3B,CAAD;MAHT,CADY;MAMnBe,MAAM,EAAE;QAAEC,IAAI,EAAE;MAAR,CANW;MAOnB0D,MAAM,EAAE;QACNsH,YAAY,EAAEpN,KAAK,CAACuL,KAAN,GAAcvL,KAAK,CAACqN,UAApB,GAAiC,KADzC;QAEN9B,KAAK,EAAEvL,KAAK,CAACqN,UAAN,GAAmB,IAAnB,GAA0B9B,KAF3B;QAGNb,KAAK,EAAE;UACLtI,IAAI,EAAEpC,KAAK,CAAC0K,KADP;UAEL4C,IAAI,EAAE,KAFD;UAGLC,IAAI,EAAE,KAAKC,mBAAL,CAAyBxN,KAAK,CAACuN,IAA/B,CAHD;UAILE,SAAS,EAAE,KAAKC,eAAL,CAAqB1N,KAAK,CAAC2N,YAA3B,CAJN;UAKLC,SAAS,EAAE5N,KAAK,CAACyK,MAAN,GAAe,CAAf,GAAmBzK,KAAK,CAAC6N,SAL/B;UAMLC,KAAK,EAAE9N,KAAK,CAAC+N;QANR,CAHD;QAWNtD,MAAM,EAAE;UACNrI,IAAI,EAAEpC,KAAK,CAACyK,MADN;UAENmD,SAAS,EAAE5N,KAAK,CAAC6N,SAFX;UAGNG,UAAU,EAAE,CAAChO,KAAK,CAACgO,UAAP,EAAmBhO,KAAK,CAACiO,WAAzB;QAHN,CAXF;QAgBN3D,IAAI,EAAE;UACJlI,IAAI,EAAEpC,KAAK,CAACsK,IADR;UAEJiD,IAAI,EAAE,CAFF;UAGJ/B,QAAQ,EAAE,CAHN;UAIJ8B,IAAI,EAAE,KAJF;UAKJM,SAAS,EAAE;QALP,CAhBA;QAuBNM,MAAM,EAAE;UACN9L,IAAI,EAAEpC,KAAK,CAACkO,MADN;UAENX,IAAI,EAAE,CAFA;UAGNE,SAAS,EAAE,KAHL;UAINU,MAAM,EAAEnO,KAAK,CAACkO,MAAN,GAAelO,KAAK,CAACoO,WAArB,GAAmC;QAJrC,CAvBF;QA6BNC,UAAU,EAAE;MA7BN,CAPW;MAsCnBxI,KAAK,EAAE,EAtCY;MAuCnBf,KAAK,EAAE,EAvCY;MAwCnBwJ,IAAI,EAAE;QACJC,eAAe,EAAE,CADb;QAEJC,QAAQ,EAAE,EAFN;QAGJC,eAAe,EAAE,IAHb;QAIJC,WAAW,EAAE,CAJT;QAKJC,SAAS,EAAE,IALP;QAMJC,SAAS,EAAE,IANP;QAOJC,KAAK,EAAEhC,SAPH;QAQJiC,MAAM,EAAE;UAAEzF,IAAI,EAAE,CAAR;UAAWC,KAAK,EAAE;QAAlB,CARJ;QASJyF,YAAY,EAAE,CATV;QAUJC,iBAAiB,EAAE;MAVf,CAxCa;MAoDnBC,SAAS,EAAE;QACTlK,IAAI,EAAE,GADG;QAET8J,KAAK,EAAE;MAFE,CApDQ;MAwDnBK,SAAS,EAAE;QACTnK,IAAI,EAAE;MADG;IAxDQ,CAArB;IA4DA,OAAO2B,OAAP;EACD;;EAEDsE,UAAU,CAAClF,MAAD,EAAc9F,KAAd,EAA0B;IAClC,MAAMzD,MAAM,GAAGyD,KAAK,CAACmC,MAAN,CAAaY,IAA5B;IACA,MAAMoM,SAAS,GAAGnP,KAAK,CAACmC,MAAN,CAAaa,QAA/B;IACA,MAAMoM,UAAU,GAAG7S,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKmL,SAA9B,IAA2C1H,KAAK,CAACmC,MAAN,CAAa5F,MAAb,CAA9D;IACA,MAAM8S,aAAa,GAAGF,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKzH,SAA1D;IACA,MAAM4H,YAAY,GAAGtP,KAAK,CAACuL,KAAN,IAAe6D,UAAf,IAA6BC,aAA7B,IAA8CrP,KAAK,CAACmC,MAAN,CAAaS,YAAhF;IACA,MAAMI,QAAQ,GAAGhD,KAAK,CAACmC,MAAN,CAAaa,QAAb,KAA0B,IAA1B,GAAiC,CAAC,CAAlC,GAAsC,CAAvD;;IAEA,IAAIsM,YAAJ,EAAkB;MAChB,OAAO9S,OAAO,CAACsJ,MAAD,EAAU8F,CAAD,IAAOA,CAAC,CAACxB,KAAF,CAAQ7N,MAAR,IAAkByG,QAAlC,CAAd;IACD,CAFD,MAEO;MACL,OAAOxG,OAAO,CAACsJ,MAAD,EAAU8F,CAAD,IAAOA,CAAC,CAAC2D,MAAlB,CAAd;IACD;EACF;;EAED7B,eAAe,CAAC8B,MAAD,EAAiB;IAC9B,IAAI,CAACA,MAAL,EAAa;MACX,OAAO,IAAP;IACD;;IAED,OAAO;MACLC,MAAM,EAAE,CAAC;QAAEC,OAAO,EAAE;MAAX,CAAD,EAAmB;QAAEA,OAAO,EAAEF,MAAM,GAAG;MAApB,CAAnB;IADH,CAAP;EAGD;;EAEDhC,mBAAmB,CAACD,IAAD,EAAe;IAChC,IAAI,KAAKvN,KAAL,CAAWqN,UAAX,IAAyB,KAAKrN,KAAL,CAAWuL,KAAxC,EAA+C;MAC7C,OAAOgC,IAAI,KAAK,CAAT,GAAa,KAAb,GAAqBA,IAAI,GAAG,EAAnC;IACD,CAFD,MAEO;MACL,OAAOA,IAAI,GAAG,EAAd;IACD;EACF;;EAEDnB,WAAW,CAAC1F,OAAD,EAAe;IACxB,MAAMoF,KAAK,GAAG,KAAKnL,UAAL,GAAkB,GAAhC;IACA,MAAMtE,GAAG,GAAGJ,WAAW,CAAC,KAAKsE,IAAL,CAAU8K,KAAV,CAAiB1L,IAAlB,CAAX,GAAqC,IAArC,GAA4C,KAAKY,IAAL,CAAU8K,KAAV,CAAiB1L,IAAjB,CAAsBgQ,OAAtB,EAAxD;IACA,MAAMxT,GAAG,GAAGF,WAAW,CAAC,KAAKsE,IAAL,CAAU8K,KAAV,CAAiBxL,EAAlB,CAAX,GAAmC,IAAnC,GAA0C,KAAKU,IAAL,CAAU8K,KAAV,CAAiBxL,EAAjB,CAAoB8P,OAApB,EAAtD;IAEAjJ,OAAO,CAAC5B,KAAR,GAAgB;MACd8K,QAAQ,EAAE,KAAKzQ,SAAL,CAAegI,WAAf,EADI;MAEd/E,IAAI,EAAE,KAAKpC,KAAL,CAAW8E,KAAX,CAAiB1C,IAFT;MAGd2C,IAAI,EAAE,MAHQ;MAId1I,GAAG,EAAEA,GAJS;MAKdF,GAAG,EAAEA,GALS;MAMdkD,KAAK,EAAE,UANO;MAOdyM,KAAK,EAAEA,KAPO;MAQd+D,UAAU,EAAElS,eAAe,CAACmO,KAAD,EAAQzP,GAAR,EAAaF,GAAb,CARb;MASd2T,aAAa,EAAEpS;IATD,CAAhB;EAWD;;EAED+N,cAAc,CAAC/E,OAAD,EAAe;IAC3B,MAAMoF,KAAK,GAAG5P,GAAG,CAAC,KAAK6F,IAAN,EAAY,CAAC+D,MAAD,EAASiK,KAAT,KAAmB;MAC9C,OAAO,CAACA,KAAK,GAAG,CAAT,EAAYjK,MAAM,CAACwF,KAAnB,CAAP;IACD,CAFgB,CAAjB;IAIA5E,OAAO,CAAC5B,KAAR,GAAgB;MACd8K,QAAQ,EAAE,KAAKzQ,SAAL,CAAegI,WAAf,EADI;MAEd/E,IAAI,EAAE,KAAKpC,KAAL,CAAW8E,KAAX,CAAiB1C,IAFT;MAGd2C,IAAI,EAAE,IAHQ;MAId1I,GAAG,EAAE,CAJS;MAKdF,GAAG,EAAE2P,KAAK,CAAC1E,MAAN,GAAe,CALN;MAMd/H,KAAK,EAAE,UANO;MAOdyM,KAAK,EAAEA;IAPO,CAAhB;EASD;;EAEDI,iBAAiB,CAACxF,OAAD,EAAegF,UAAf,EAAmC;IAClD,IAAII,KAAJ;IACA,IAAIzP,GAAJ;IACA,IAAIF,GAAJ;IAEA,MAAM6T,YAAY,GAAG,KAAKrP,UAAL,GAAkB,EAAvC;;IAEA,IAAI,KAAKoB,IAAL,CAAUqF,MAAV,IAAoBsE,UAAxB,EAAoC;MAClC,MAAMuE,UAAU,GAAG,EAAnB;;MAEA,KAAK,MAAMC,CAAX,IAAgB,KAAKnO,IAArB,EAA2B;QACzB,KAAK,MAAMqC,KAAX,IAAoB8L,CAAC,CAACnO,IAAtB,EAA4B;UAC1BkO,UAAU,CAAC7L,KAAK,CAAC,CAAD,CAAN,CAAV,GAAuB,IAAvB;QACD;MACF;;MAED0H,KAAK,GAAGqE,MAAM,CAACC,IAAP,CAAYH,UAAZ,EAAwB/T,GAAxB,CAA6BmU,CAAD,IAAOnG,MAAM,CAACmG,CAAD,CAAzC,CAAR;MACAhU,GAAG,GAAGC,IAAI,CAACwP,KAAD,CAAV;MACA3P,GAAG,GAAGC,IAAI,CAAC0P,KAAD,CAAV,CAXkC,CAalC;;MACA,IAAI9N,QAAQ,GAAG0N,UAAf;MACA,IAAI4E,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACrU,GAAG,GAAGE,GAAP,IAAc2B,QAAzB,CAAf;;MACA,OAAOsS,QAAQ,GAAGN,YAAlB,EAAgC;QAC9BhS,QAAQ,GAAGA,QAAQ,GAAG,CAAtB;QACAsS,QAAQ,GAAGC,IAAI,CAACE,IAAL,CAAU,CAACtU,GAAG,GAAGE,GAAP,IAAc2B,QAAxB,CAAX;MACD,CAnBiC,CAqBlC;;;MACA3B,GAAG,GAAGkU,IAAI,CAACC,KAAL,CAAWnU,GAAG,GAAG2B,QAAjB,IAA6BA,QAAnC,CAtBkC,CAuBlC;;MACA7B,GAAG,GAAGoU,IAAI,CAACE,IAAL,CAAWtU,GAAG,GAAG,IAAP,GAAe6B,QAAzB,IAAqCA,QAA3C;MAEA8N,KAAK,GAAG,EAAR;;MACA,KAAK,IAAItC,CAAC,GAAGnN,GAAb,EAAkBmN,CAAC,IAAIrN,GAAvB,EAA4BqN,CAAC,IAAIxL,QAAjC,EAA2C;QACzC8N,KAAK,CAAC4E,IAAN,CAAWlH,CAAX;MACD;IACF,CA9BD,MA8BO;MACL;MACAsC,KAAK,GAAGkE,YAAY,GAAG,CAAvB;MACA3T,GAAG,GAAG,CAAN;MACAF,GAAG,GAAG,CAAN;IACD;;IAEDuK,OAAO,CAAC5B,KAAR,GAAgB;MACd8K,QAAQ,EAAE,KAAKzQ,SAAL,CAAegI,WAAf,EADI;MAEd/E,IAAI,EAAE,KAAKpC,KAAL,CAAW8E,KAAX,CAAiB1C,IAFT;MAGd2C,IAAI,EAAE,IAHQ;MAId1I,GAAG,EAAEA,GAJS;MAKdF,GAAG,EAAEA,GALS;MAMdkD,KAAK,EAAE,WANO;MAOdyM,KAAK,EAAEA;IAPO,CAAhB,CA5CkD,CAsDlD;;IACA,KAAK6E,iBAAL,CAAuBjK,OAAO,CAAC5B,KAA/B,EAAsC,OAAtC,EAA+C,IAA/C;EACD;;EAEDqH,aAAa,CAACzF,OAAD,EAAe;IAC1B,IAAIoF,KAAK,GAAG5P,GAAG,CAAC,KAAK6F,IAAN,EAAY,CAAC+D,MAAD,EAAS8K,WAAT,KAAyB;MAClD,OAAO1U,GAAG,CAAC4J,MAAM,CAAC+K,UAAR,EAAoB,CAACzM,KAAD,EAAQ0M,UAAR,KAAuB;QACnD,MAAMC,SAAS,GAAGH,WAAW,GAAG9K,MAAM,CAAC+K,UAAP,CAAkBzJ,MAAhC,GAAyC0J,UAA3D;QACA,OAAO,CAACC,SAAS,GAAG,CAAb,EAAgB3M,KAAK,CAAC,CAAD,CAArB,CAAP;MACD,CAHS,CAAV;IAID,CALc,CAAf,CAD0B,CAO1B;;IACA0H,KAAK,GAAG9P,OAAO,CAAC8P,KAAD,EAAQ,IAAR,CAAf;IAEApF,OAAO,CAAC5B,KAAR,GAAgB;MACd8K,QAAQ,EAAE,KAAKzQ,SAAL,CAAegI,WAAf,EADI;MAEd/E,IAAI,EAAE,KAAKpC,KAAL,CAAW8E,KAAX,CAAiB1C,IAFT;MAGd2C,IAAI,EAAE,IAHQ;MAId1I,GAAG,EAAE,CAJS;MAKdF,GAAG,EAAE2P,KAAK,CAAC1E,MAAN,GAAe,CALN;MAMd/H,KAAK,EAAE,UANO;MAOdyM,KAAK,EAAEA;IAPO,CAAhB;EASD;;EAEDjB,qBAAqB,CAAC9I,IAAD,EAAY2E,OAAZ,EAA0B;IAC7C,MAAMsK,QAAQ,GAAG;MACfC,QAAQ,EAAE,MADK;MAEf7O,IAAI,EAAE,KAAKpC,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBzD,IAFX;MAGf2N,KAAK,EAAE,CAHQ;MAIfmB,OAAO,EAAE,KAAKlR,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBqL,OAApB,IAA+B,CAJzB;MAKf7U,GAAG,EAAE,KAAK8U,WAAL,CAAiB,KAAKnR,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBxJ,GAArC,CALU;MAMfF,GAAG,EAAE,KAAKgV,WAAL,CAAiB,KAAKnR,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoB1J,GAArC,CANU;MAOfiV,YAAY,EAAE,KAAKpR,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBgB;IAPnB,CAAjB;IAUAH,OAAO,CAACb,KAAR,CAAc6K,IAAd,CAAmBM,QAAnB;;IAEA,IAAIjV,IAAI,CAACgG,IAAD,EAAO;MAAEgE,KAAK,EAAE;IAAT,CAAP,CAAR,EAA8B;MAC5B,MAAMsL,OAAO,GAAGvV,KAAK,CAACkV,QAAD,CAArB;MACAK,OAAO,CAACtB,KAAR,GAAgB,CAAhB;MACAsB,OAAO,CAACjP,IAAR,GAAe,KAAKpC,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBzD,IAAnC;MACAiP,OAAO,CAACH,OAAR,GAAkB,KAAKlR,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBqL,OAApB,IAA+B,CAAjD;MACAG,OAAO,CAACJ,QAAR,GAAmB,OAAnB;MACAI,OAAO,CAAChV,GAAR,GAAc,KAAK8U,WAAL,CAAiB,KAAKnR,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBxJ,GAArC,CAAd;MACAgV,OAAO,CAAClV,GAAR,GAAc,KAAKgV,WAAL,CAAiB,KAAKnR,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoB1J,GAArC,CAAd;MACAkV,OAAO,CAACD,YAAR,GAAuB,KAAKpR,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBgB,QAA3C;MACAH,OAAO,CAACb,KAAR,CAAc6K,IAAd,CAAmBW,OAAnB;MAEA,KAAKC,aAAL,CAAmB5K,OAAO,CAACb,KAAR,CAAc,CAAd,CAAnB,EAAqC9D,IAArC;MACA,KAAK4O,iBAAL,CACEjK,OAAO,CAACb,KAAR,CAAc,CAAd,CADF,EAEE,KAAK7F,KAAL,CAAWqN,UAAX,IAAyB,KAAKrN,KAAL,CAAWuL,KAApC,GAA4C,SAA5C,GAAwD,KAAKvL,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoB0L,MAF9E,EAGE,KAAKvR,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBgB,QAHtB;IAKD;;IACD,KAAKyK,aAAL,CAAmB5K,OAAO,CAACb,KAAR,CAAc,CAAd,CAAnB,EAAqC9D,IAArC;IACA,KAAK4O,iBAAL,CACEjK,OAAO,CAACb,KAAR,CAAc,CAAd,CADF,EAEE,KAAK7F,KAAL,CAAWqN,UAAX,IAAyB,KAAKrN,KAAL,CAAWuL,KAApC,GAA4C,SAA5C,GAAwD,KAAKvL,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoB0L,MAF9E,EAGE,KAAKvR,KAAL,CAAW6F,KAAX,CAAiB,CAAjB,EAAoBgB,QAHtB;EAKD;;EAEDsK,WAAW,CAAC3I,KAAD,EAAa;IACtB,IAAIA,KAAK,KAAK,IAAV,IAAkB,OAAOA,KAAP,KAAiB,WAAvC,EAAoD;MAClD,OAAO,IAAP;IACD;;IAED,OAAO/L,QAAQ,CAAC+L,KAAD,CAAf;EACD;;EAED8I,aAAa,CAAC7H,IAAD,EAAY1H,IAAZ,EAAuB;IAClC,IAAI0H,IAAI,CAACyH,OAAL,KAAiB,CAArB,EAAwB;MACtB;IACD;;IAED,MAAMM,YAAY,GAAG/H,IAAI,CAACpN,GAAL,KAAa,CAAlC;;IAEA,IAAIoN,IAAI,CAACpN,GAAL,GAAW6N,MAAM,CAACuH,SAAtB,EAAiC;MAC/BhI,IAAI,CAACpN,GAAL,GAAW,IAAX;IACD;;IACD,IAAIoN,IAAI,CAACtN,GAAL,GAAW+N,MAAM,CAACuH,SAAtB,EAAiC;MAC/BhI,IAAI,CAACtN,GAAL,GAAW,IAAX;IACD;;IAED,IAAI2J,MAAJ,EAAY0D,CAAZ;IACA,IAAIrN,GAAG,GAAGsN,IAAI,CAACtN,GAAf;IAAA,IACEE,GAAG,GAAGoN,IAAI,CAACpN,GADb;;IAGA,KAAKmN,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGzH,IAAI,CAACqF,MAArB,EAA6BoC,CAAC,EAA9B,EAAkC;MAChC1D,MAAM,GAAG/D,IAAI,CAACyH,CAAD,CAAb;;MACA,IAAI1D,MAAM,CAACC,KAAP,KAAiB0D,IAAI,CAACsG,KAA1B,EAAiC;QAC/B,IAAI,CAAC5T,GAAD,IAAQA,GAAG,GAAG2J,MAAM,CAACsE,KAAP,CAAajO,GAA/B,EAAoC;UAClCA,GAAG,GAAG2J,MAAM,CAACsE,KAAP,CAAajO,GAAnB;QACD;;QACD,IAAI,CAACE,GAAD,IAAQA,GAAG,GAAGyJ,MAAM,CAACsE,KAAP,CAAasH,MAA/B,EAAuC;UACrCrV,GAAG,GAAGyJ,MAAM,CAACsE,KAAP,CAAasH,MAAnB;QACD;MACF;IACF;;IAEDjI,IAAI,CAAC2B,SAAL,GAAkBiF,CAAD,IAAe;MAC9B,OAAOA,CAAC,GAAGnG,MAAM,CAACuH,SAAX,GAAuB,IAAvB,GAA8BlB,IAAI,CAACoB,GAAL,CAAStB,CAAT,IAAcE,IAAI,CAACoB,GAAL,CAASlI,IAAI,CAACyH,OAAd,CAAnD;IACD,CAFD;;IAGAzH,IAAI,CAACmI,gBAAL,GAAyBvB,CAAD,IAAY;MAClC,OAAOE,IAAI,CAACsB,GAAL,CAASpI,IAAI,CAACyH,OAAd,EAAuBb,CAAvB,CAAP;IACD,CAFD;;IAIA,IAAI,CAAClU,GAAD,IAAQ,CAACE,GAAb,EAAkB;MAChBF,GAAG,GAAGsN,IAAI,CAACmI,gBAAL,CAAsB,CAAC,CAAvB,CAAN;MACAvV,GAAG,GAAGoN,IAAI,CAACmI,gBAAL,CAAsB,CAAC,CAAvB,CAAN;IACD,CAHD,MAGO,IAAI,CAACzV,GAAL,EAAU;MACfA,GAAG,GAAGE,GAAG,GAAGoN,IAAI,CAACmI,gBAAL,CAAsB,CAAC,CAAvB,CAAZ;IACD,CAFM,MAEA,IAAI,CAACvV,GAAL,EAAU;MACfA,GAAG,GAAGF,GAAG,GAAGsN,IAAI,CAACmI,gBAAL,CAAsB,CAAC,CAAvB,CAAZ;IACD;;IAED,IAAInI,IAAI,CAACpN,GAAT,EAAc;MACZA,GAAG,GAAGoN,IAAI,CAACmI,gBAAL,CAAsBrB,IAAI,CAACE,IAAL,CAAUhH,IAAI,CAAC2B,SAAL,CAAe3B,IAAI,CAACpN,GAApB,CAAV,CAAtB,CAAN;IACD,CAFD,MAEO;MACLA,GAAG,GAAGoN,IAAI,CAACpN,GAAL,GAAWoN,IAAI,CAACmI,gBAAL,CAAsBrB,IAAI,CAACC,KAAL,CAAW/G,IAAI,CAAC2B,SAAL,CAAe/O,GAAf,CAAX,CAAtB,CAAjB;IACD;;IACD,IAAIoN,IAAI,CAACtN,GAAT,EAAc;MACZA,GAAG,GAAGsN,IAAI,CAACmI,gBAAL,CAAsBrB,IAAI,CAACC,KAAL,CAAW/G,IAAI,CAAC2B,SAAL,CAAe3B,IAAI,CAACtN,GAApB,CAAX,CAAtB,CAAN;IACD,CAFD,MAEO;MACLA,GAAG,GAAGsN,IAAI,CAACtN,GAAL,GAAWsN,IAAI,CAACmI,gBAAL,CAAsBrB,IAAI,CAACE,IAAL,CAAUhH,IAAI,CAAC2B,SAAL,CAAejP,GAAf,CAAV,CAAtB,CAAjB;IACD;;IAED,IAAI,CAACE,GAAD,IAAQA,GAAG,GAAG6N,MAAM,CAACuH,SAArB,IAAkC,CAACtV,GAAnC,IAA0CA,GAAG,GAAG+N,MAAM,CAACuH,SAA3D,EAAsE;MACpE;IACD;;IAED,IAAIvH,MAAM,CAAC4H,QAAP,CAAgBzV,GAAhB,KAAwB6N,MAAM,CAAC4H,QAAP,CAAgB3V,GAAhB,CAA5B,EAAkD;MAChD,IAAIqV,YAAJ,EAAkB;QAChB/H,IAAI,CAACpN,GAAL,GAAW,GAAX;QACAA,GAAG,GAAG,CAAN;MACD;;MAEDoN,IAAI,CAACqC,KAAL,GAAa,KAAKiG,6BAAL,CAAmC1V,GAAnC,EAAwCF,GAAxC,EAA6CsN,IAAI,CAACyH,OAAlD,CAAb;;MACA,IAAIM,YAAJ,EAAkB;QAChB/H,IAAI,CAACqC,KAAL,CAAWkG,OAAX,CAAmB,GAAnB;MACD;;MACD,IAAIvI,IAAI,CAACqC,KAAL,CAAWrC,IAAI,CAACqC,KAAL,CAAW1E,MAAX,GAAoB,CAA/B,IAAoCqC,IAAI,CAACtN,GAA7C,EAAkD;QAChDsN,IAAI,CAACtN,GAAL,GAAWsN,IAAI,CAACqC,KAAL,CAAWrC,IAAI,CAACqC,KAAL,CAAW1E,MAAX,GAAoB,CAA/B,CAAX;MACD;IACF,CAbD,MAaO;MACLqC,IAAI,CAACqC,KAAL,GAAa,CAAC,CAAD,EAAI,CAAJ,CAAb;MACA,OAAOrC,IAAI,CAACpN,GAAZ;MACA,OAAOoN,IAAI,CAACtN,GAAZ;IACD;EACF;;EAED4V,6BAA6B,CAAC1V,GAAD,EAAWF,GAAX,EAAwB+U,OAAxB,EAAyC;IACpE,IAAIpF,KAAK,GAAG,EAAZ;IAEA,IAAImG,QAAJ;;IACA,KAAKA,QAAQ,GAAG5V,GAAhB,EAAqB4V,QAAQ,IAAI9V,GAAjC,EAAsC8V,QAAQ,IAAIf,OAAlD,EAA2D;MACzDpF,KAAK,CAAC4E,IAAN,CAAWuB,QAAX;IACD;;IAED,MAAMC,WAAW,GAAG3B,IAAI,CAACE,IAAL,CAAU,KAAKlQ,IAAL,CAAU2B,MAAV,GAAmB,EAA7B,CAApB;IACA,MAAMiQ,QAAQ,GAAGrG,KAAK,CAAC1E,MAAvB;;IACA,IAAI+K,QAAQ,GAAGD,WAAf,EAA4B;MAC1B,MAAME,MAAM,GAAG7B,IAAI,CAACE,IAAL,CAAU0B,QAAQ,GAAGD,WAArB,IAAoChB,OAAnD;MACApF,KAAK,GAAG,EAAR;;MAEA,KAAKmG,QAAQ,GAAG5V,GAAhB,EAAqB4V,QAAQ,IAAI9V,GAAG,GAAGiW,MAAvC,EAA+CH,QAAQ,IAAIG,MAA3D,EAAmE;QACjEtG,KAAK,CAAC4E,IAAN,CAAWuB,QAAX;MACD;IACF;;IAED,OAAOnG,KAAP;EACD;;EAED6E,iBAAiB,CACflH,IADe,EAEf8H,MAFe,EAGf1K,QAHe,EAIf;IACA4C,IAAI,CAACqG,aAAL,GAAqB,CAACuC,GAAD,EAAM5I,IAAN,KAAe;MAClC,MAAM6I,SAAS,GAAGlV,cAAc,CAACmU,MAAD,CAAhC;;MAEA,IAAI,CAACe,SAAL,EAAgB;QACd,MAAM,IAAI5F,KAAJ,CAAW,SAAQ6E,MAAO,oBAA1B,CAAN;MACD;;MAED,OAAOvU,sBAAsB,CAACsV,SAAS,CAACD,GAAD,EAAMxL,QAAN,CAAV,CAA7B;IACD,CARD;EASD;;AAn4BgB;AAs4BnB;;;AACA,SAAS0L,cAAT,CAAwBxT,OAAxB,EAA0CyT,UAA1C,EAA2DC,UAA3D,EAAmF;EACjF,OAAO;IACLC,QAAQ,EAAE,GADL;IAELC,QAAQ,EAAE,EAFL;IAGLzS,IAAI,EAAE,CAACrB,KAAD,EAAaC,IAAb,KAA8B;MAClC,OAAO,IAAIH,YAAJ,CAAiBE,KAAjB,EAAwBC,IAAxB,EAA8BC,OAA9B,CAAP;IACD;EALI,CAAP;AAOD;;AAEDnB,UAAU,CAACgV,SAAX,CAAqB,cAArB,EAAqCL,cAArC;AACA,SAAS5T,YAAT,EAAuB4T,cAAvB"},"metadata":{},"sourceType":"module"}