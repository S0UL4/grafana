{"ast":null,"code":"import { includes, filter } from 'lodash';\nimport { rangeUtil } from '@grafana/data';\nexport default class TimeGrainConverter {\n  static createISO8601Duration(timeGrain, timeGrainUnit) {\n    const timeIntervals = ['hour', 'minute', 'h', 'm'];\n\n    if (includes(timeIntervals, timeGrainUnit)) {\n      return `PT${timeGrain}${timeGrainUnit[0].toUpperCase()}`;\n    }\n\n    return `P${timeGrain}${timeGrainUnit[0].toUpperCase()}`;\n  }\n\n  static createISO8601DurationFromInterval(interval) {\n    const timeGrain = +interval.slice(0, interval.length - 1);\n    const unit = interval[interval.length - 1];\n\n    if (interval.indexOf('ms') > -1) {\n      return TimeGrainConverter.createISO8601Duration(1, 'm');\n    }\n\n    if (interval[interval.length - 1] === 's') {\n      let toMinutes = timeGrain * 60 % 60;\n\n      if (toMinutes < 1) {\n        toMinutes = 1;\n      }\n\n      return TimeGrainConverter.createISO8601Duration(toMinutes, 'm');\n    }\n\n    return TimeGrainConverter.createISO8601Duration(timeGrain, unit);\n  }\n\n  static findClosestTimeGrain(interval, allowedTimeGrains) {\n    const timeGrains = filter(allowedTimeGrains, o => o !== 'auto');\n    let closest = timeGrains[0];\n    const intervalMs = rangeUtil.intervalToMs(interval);\n\n    for (let i = 0; i < timeGrains.length; i++) {\n      // abs (num - val) < abs (num - curr):\n      if (intervalMs > rangeUtil.intervalToMs(timeGrains[i])) {\n        if (i + 1 < timeGrains.length) {\n          closest = timeGrains[i + 1];\n        } else {\n          closest = timeGrains[i];\n        }\n      }\n    }\n\n    return closest;\n  }\n\n  static createTimeGrainFromISO8601Duration(duration) {\n    let offset = 1;\n\n    if (duration.substring(0, 2) === 'PT') {\n      offset = 2;\n    }\n\n    const value = duration.substring(offset, duration.length - 1);\n    const unit = duration.substring(duration.length - 1);\n    return value + ' ' + TimeGrainConverter.timeUnitToText(+value, unit);\n  }\n\n  static timeUnitToText(value, unit) {\n    let text = '';\n\n    if (unit === 'S') {\n      text = 'second';\n    }\n\n    if (unit === 'M') {\n      text = 'minute';\n    }\n\n    if (unit === 'H') {\n      text = 'hour';\n    }\n\n    if (unit === 'D') {\n      text = 'day';\n    }\n\n    if (value > 1) {\n      return text + 's';\n    }\n\n    return text;\n  }\n\n  static createKbnUnitFromISO8601Duration(duration) {\n    if (duration === 'auto') {\n      return 'auto';\n    }\n\n    let offset = 1;\n\n    if (duration.substring(0, 2) === 'PT') {\n      offset = 2;\n    }\n\n    const value = duration.substring(offset, duration.length - 1);\n    const unit = duration.substring(duration.length - 1);\n    return value + TimeGrainConverter.timeUnitToKbn(+value, unit);\n  }\n\n  static timeUnitToKbn(value, unit) {\n    if (unit === 'S') {\n      return 's';\n    }\n\n    if (unit === 'M') {\n      return 'm';\n    }\n\n    if (unit === 'H') {\n      return 'h';\n    }\n\n    if (unit === 'D') {\n      return 'd';\n    }\n\n    return '';\n  }\n\n}","map":{"version":3,"names":["includes","filter","rangeUtil","TimeGrainConverter","createISO8601Duration","timeGrain","timeGrainUnit","timeIntervals","toUpperCase","createISO8601DurationFromInterval","interval","slice","length","unit","indexOf","toMinutes","findClosestTimeGrain","allowedTimeGrains","timeGrains","o","closest","intervalMs","intervalToMs","i","createTimeGrainFromISO8601Duration","duration","offset","substring","value","timeUnitToText","text","createKbnUnitFromISO8601Duration","timeUnitToKbn"],"sources":["/home/soula/grafana/public/app/plugins/datasource/grafana-azure-monitor-datasource/time_grain_converter.ts"],"sourcesContent":["import { includes, filter } from 'lodash';\n\nimport { rangeUtil } from '@grafana/data';\n\nexport default class TimeGrainConverter {\n  static createISO8601Duration(timeGrain: string | number, timeGrainUnit: any) {\n    const timeIntervals = ['hour', 'minute', 'h', 'm'];\n    if (includes(timeIntervals, timeGrainUnit)) {\n      return `PT${timeGrain}${timeGrainUnit[0].toUpperCase()}`;\n    }\n\n    return `P${timeGrain}${timeGrainUnit[0].toUpperCase()}`;\n  }\n\n  static createISO8601DurationFromInterval(interval: string) {\n    const timeGrain = +interval.slice(0, interval.length - 1);\n    const unit = interval[interval.length - 1];\n\n    if (interval.indexOf('ms') > -1) {\n      return TimeGrainConverter.createISO8601Duration(1, 'm');\n    }\n\n    if (interval[interval.length - 1] === 's') {\n      let toMinutes = (timeGrain * 60) % 60;\n\n      if (toMinutes < 1) {\n        toMinutes = 1;\n      }\n\n      return TimeGrainConverter.createISO8601Duration(toMinutes, 'm');\n    }\n\n    return TimeGrainConverter.createISO8601Duration(timeGrain, unit);\n  }\n\n  static findClosestTimeGrain(interval: any, allowedTimeGrains: string[]) {\n    const timeGrains = filter(allowedTimeGrains, (o) => o !== 'auto');\n\n    let closest = timeGrains[0];\n    const intervalMs = rangeUtil.intervalToMs(interval);\n\n    for (let i = 0; i < timeGrains.length; i++) {\n      // abs (num - val) < abs (num - curr):\n      if (intervalMs > rangeUtil.intervalToMs(timeGrains[i])) {\n        if (i + 1 < timeGrains.length) {\n          closest = timeGrains[i + 1];\n        } else {\n          closest = timeGrains[i];\n        }\n      }\n    }\n\n    return closest;\n  }\n\n  static createTimeGrainFromISO8601Duration(duration: string) {\n    let offset = 1;\n    if (duration.substring(0, 2) === 'PT') {\n      offset = 2;\n    }\n\n    const value = duration.substring(offset, duration.length - 1);\n    const unit = duration.substring(duration.length - 1);\n\n    return value + ' ' + TimeGrainConverter.timeUnitToText(+value, unit);\n  }\n\n  static timeUnitToText(value: number, unit: string) {\n    let text = '';\n\n    if (unit === 'S') {\n      text = 'second';\n    }\n    if (unit === 'M') {\n      text = 'minute';\n    }\n    if (unit === 'H') {\n      text = 'hour';\n    }\n    if (unit === 'D') {\n      text = 'day';\n    }\n\n    if (value > 1) {\n      return text + 's';\n    }\n\n    return text;\n  }\n\n  static createKbnUnitFromISO8601Duration(duration: string) {\n    if (duration === 'auto') {\n      return 'auto';\n    }\n\n    let offset = 1;\n    if (duration.substring(0, 2) === 'PT') {\n      offset = 2;\n    }\n\n    const value = duration.substring(offset, duration.length - 1);\n    const unit = duration.substring(duration.length - 1);\n\n    return value + TimeGrainConverter.timeUnitToKbn(+value, unit);\n  }\n\n  static timeUnitToKbn(value: number, unit: string) {\n    if (unit === 'S') {\n      return 's';\n    }\n    if (unit === 'M') {\n      return 'm';\n    }\n    if (unit === 'H') {\n      return 'h';\n    }\n    if (unit === 'D') {\n      return 'd';\n    }\n\n    return '';\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}