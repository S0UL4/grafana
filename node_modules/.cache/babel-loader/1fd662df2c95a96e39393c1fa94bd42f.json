{"ast":null,"code":"import { castArray, isEqual } from 'lodash';\nimport { getDataSourceRef, isDataSourceRef, LoadingState } from '@grafana/data';\nimport { locationService } from '@grafana/runtime';\nimport { notifyApp } from 'app/core/actions';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { store } from 'app/store/store';\nimport { createErrorNotification } from '../../../core/copy/appNotification';\nimport { appEvents } from '../../../core/core';\nimport { getBackendSrv } from '../../../core/services/backend_srv';\nimport { Graph } from '../../../core/utils/dag';\nimport { getDatasourceSrv } from '../../plugins/datasource_srv';\nimport { getTemplateSrv } from '../../templating/template_srv';\nimport { variableAdapters } from '../adapters';\nimport { ALL_VARIABLE_TEXT, ALL_VARIABLE_VALUE } from '../constants';\nimport { cleanEditorState } from '../editor/reducer';\nimport { hasCurrent, hasLegacyVariableSupport, hasOptions, hasStandardVariableSupport, isAdHoc, isConstant, isMulti, isQuery } from '../guard';\nimport { getAllAffectedPanelIdsForVariableChange } from '../inspect/utils';\nimport { cleanPickerState } from '../pickers/OptionsPicker/reducer';\nimport { alignCurrentWithMulti } from '../shared/multiOptions';\nimport { initialVariableModelState, TransactionStatus, VariableHide, VariableRefresh, VariablesChanged, VariablesChangedInUrl, VariablesTimeRangeProcessDone } from '../types';\nimport { ensureStringValues, getCurrentText, getVariableRefresh, hasOngoingTransaction, toKeyedVariableIdentifier, toStateKey, toVariablePayload } from '../utils';\nimport { toKeyedAction } from './keyedVariablesReducer';\nimport { getIfExistsLastKey, getVariable, getVariablesByKey, getVariablesState } from './selectors';\nimport { addVariable, changeVariableProp, setCurrentVariableValue, variableStateCompleted, variableStateFailed, variableStateFetching, variableStateNotStarted } from './sharedReducer';\nimport { variablesClearTransaction, variablesCompleteTransaction, variablesInitTransaction } from './transactionReducer';\nimport { cleanVariables } from './variablesReducer'; // process flow queryVariable\n// thunk => processVariables\n//    adapter => setValueFromUrl\n//      thunk => setOptionFromUrl\n//        adapter => updateOptions\n//          thunk => updateQueryVariableOptions\n//            action => updateVariableOptions\n//            action => updateVariableTags\n//            thunk => validateVariableSelectionState\n//              adapter => setValue\n//                thunk => setOptionAsCurrent\n//                  action => setCurrentVariableValue\n//                  thunk => variableUpdated\n//                    adapter => updateOptions for dependent nodes\n//        adapter => setValue\n//          thunk => setOptionAsCurrent\n//            action => setCurrentVariableValue\n//            thunk => variableUpdated\n//              adapter => updateOptions for dependent nodes\n//    adapter => updateOptions\n//      thunk => updateQueryVariableOptions\n//        action => updateVariableOptions\n//        action => updateVariableTags\n//        thunk => validateVariableSelectionState\n//          adapter => setValue\n//            thunk => setOptionAsCurrent\n//              action => setCurrentVariableValue\n//              thunk => variableUpdated\n//                adapter => updateOptions for dependent nodes\n\nexport const initDashboardTemplating = (key, dashboard) => {\n  return (dispatch, getState) => {\n    let orderIndex = 0;\n    const list = dashboard.templating.list;\n\n    for (let index = 0; index < list.length; index++) {\n      const model = fixSelectedInconsistency(list[index]);\n      model.rootStateKey = key;\n\n      if (!variableAdapters.getIfExists(model.type)) {\n        continue;\n      }\n\n      dispatch(toKeyedAction(key, addVariable(toVariablePayload(model, {\n        global: false,\n        index: orderIndex++,\n        model\n      }))));\n    }\n\n    getTemplateSrv().updateTimeRange(getTimeSrv().timeRange());\n    const variables = getVariablesByKey(key, getState());\n\n    for (const variable of variables) {\n      dispatch(toKeyedAction(key, variableStateNotStarted(toVariablePayload(variable))));\n    }\n  };\n};\nexport function fixSelectedInconsistency(model) {\n  if (!hasOptions(model)) {\n    return model;\n  }\n\n  let found = false;\n\n  for (const option of model.options) {\n    option.selected = false;\n\n    if (Array.isArray(model.current.value)) {\n      for (const value of model.current.value) {\n        if (option.value === value) {\n          option.selected = found = true;\n        }\n      }\n    } else if (option.value === model.current.value) {\n      option.selected = found = true;\n    }\n  }\n\n  if (!found && model.options.length) {\n    model.options[0].selected = true;\n  }\n\n  return model;\n}\nexport const addSystemTemplateVariables = (key, dashboard) => {\n  return dispatch => {\n    const dashboardModel = Object.assign({}, initialVariableModelState, {\n      id: '__dashboard',\n      name: '__dashboard',\n      type: 'system',\n      index: -3,\n      skipUrlSync: true,\n      hide: VariableHide.hideVariable,\n      current: {\n        value: {\n          name: dashboard.title,\n          uid: dashboard.uid,\n          toString: () => dashboard.title\n        }\n      }\n    });\n    dispatch(toKeyedAction(key, addVariable(toVariablePayload(dashboardModel, {\n      global: dashboardModel.global,\n      index: dashboardModel.index,\n      model: dashboardModel\n    }))));\n    const orgModel = Object.assign({}, initialVariableModelState, {\n      id: '__org',\n      name: '__org',\n      type: 'system',\n      index: -2,\n      skipUrlSync: true,\n      hide: VariableHide.hideVariable,\n      current: {\n        value: {\n          name: contextSrv.user.orgName,\n          id: contextSrv.user.orgId,\n          toString: () => contextSrv.user.orgId.toString()\n        }\n      }\n    });\n    dispatch(toKeyedAction(key, addVariable(toVariablePayload(orgModel, {\n      global: orgModel.global,\n      index: orgModel.index,\n      model: orgModel\n    }))));\n    const userModel = Object.assign({}, initialVariableModelState, {\n      id: '__user',\n      name: '__user',\n      type: 'system',\n      index: -1,\n      skipUrlSync: true,\n      hide: VariableHide.hideVariable,\n      current: {\n        value: {\n          login: contextSrv.user.login,\n          id: contextSrv.user.id,\n          email: contextSrv.user.email,\n          toString: () => contextSrv.user.id.toString()\n        }\n      }\n    });\n    dispatch(toKeyedAction(key, addVariable(toVariablePayload(userModel, {\n      global: userModel.global,\n      index: userModel.index,\n      model: userModel\n    }))));\n  };\n};\nexport const changeVariableMultiValue = (identifier, multi) => {\n  return (dispatch, getState) => {\n    const {\n      rootStateKey: key\n    } = identifier;\n    const variable = getVariable(identifier, getState());\n    const current = alignCurrentWithMulti(variable.current, multi);\n    dispatch(toKeyedAction(key, changeVariableProp(toVariablePayload(identifier, {\n      propName: 'multi',\n      propValue: multi\n    }))));\n    dispatch(toKeyedAction(key, changeVariableProp(toVariablePayload(identifier, {\n      propName: 'current',\n      propValue: current\n    }))));\n  };\n};\nexport const processVariableDependencies = async (variable, state) => {\n  if (!variable.rootStateKey) {\n    throw new Error(`rootStateKey not found for variable with id:${variable.id}`);\n  }\n\n  if (isDependencyGraphCircular(variable, state)) {\n    throw new Error('Circular dependency in dashboard variables detected. Dashboard may not work as expected.');\n  }\n\n  const dependencies = getDirectDependencies(variable, state);\n\n  if (!isWaitingForDependencies(variable.rootStateKey, dependencies, state)) {\n    return;\n  }\n\n  await new Promise(resolve => {\n    const unsubscribe = store.subscribe(() => {\n      if (!variable.rootStateKey) {\n        throw new Error(`rootStateKey not found for variable with id:${variable.id}`);\n      }\n\n      if (!isWaitingForDependencies(variable.rootStateKey, dependencies, store.getState())) {\n        unsubscribe();\n        resolve();\n      }\n    });\n  });\n};\n\nconst isDependencyGraphCircular = (variable, state, encounteredDependencyIds = new Set()) => {\n  if (encounteredDependencyIds.has(variable.id)) {\n    return true;\n  }\n\n  encounteredDependencyIds = new Set([...encounteredDependencyIds, variable.id]);\n  return getDirectDependencies(variable, state).some(dependency => {\n    return isDependencyGraphCircular(dependency, state, encounteredDependencyIds);\n  });\n};\n\nconst getDirectDependencies = (variable, state) => {\n  if (!variable.rootStateKey) {\n    return [];\n  }\n\n  const directDependencies = [];\n\n  for (const otherVariable of getVariablesByKey(variable.rootStateKey, state)) {\n    if (variable === otherVariable) {\n      continue;\n    }\n\n    if (variableAdapters.getIfExists(variable.type)) {\n      if (variableAdapters.get(variable.type).dependsOn(variable, otherVariable)) {\n        directDependencies.push(otherVariable);\n      }\n    }\n  }\n\n  return directDependencies;\n};\n\nconst isWaitingForDependencies = (key, dependencies, state) => {\n  if (dependencies.length === 0) {\n    return false;\n  }\n\n  const variables = getVariablesByKey(key, state);\n  const notCompletedDependencies = dependencies.filter(d => variables.some(v => v.id === d.id && (v.state === LoadingState.NotStarted || v.state === LoadingState.Loading)));\n  return notCompletedDependencies.length > 0;\n};\n\nexport const processVariable = (identifier, queryParams) => {\n  return async (dispatch, getState) => {\n    const variable = getVariable(identifier, getState());\n    await processVariableDependencies(variable, getState());\n    const urlValue = queryParams['var-' + variable.name];\n\n    if (urlValue !== void 0) {\n      const stringUrlValue = ensureStringValues(urlValue);\n      await variableAdapters.get(variable.type).setValueFromUrl(variable, stringUrlValue);\n      return;\n    }\n\n    if (variable.hasOwnProperty('refresh')) {\n      const refreshableVariable = variable;\n\n      if (refreshableVariable.refresh === VariableRefresh.onDashboardLoad || refreshableVariable.refresh === VariableRefresh.onTimeRangeChanged) {\n        await dispatch(updateOptions(toKeyedVariableIdentifier(refreshableVariable)));\n        return;\n      }\n    } // for variables that aren't updated via URL or refresh, let's simulate the same state changes\n\n\n    dispatch(completeVariableLoading(identifier));\n  };\n};\nexport const processVariables = key => {\n  return async (dispatch, getState) => {\n    const queryParams = locationService.getSearchObject();\n    const promises = getVariablesByKey(key, getState()).map(async variable => await dispatch(processVariable(toKeyedVariableIdentifier(variable), queryParams)));\n    await Promise.all(promises);\n  };\n};\nexport const setOptionFromUrl = (identifier, urlValue) => {\n  return async (dispatch, getState) => {\n    const stringUrlValue = ensureStringValues(urlValue);\n    const variable = getVariable(identifier, getState());\n\n    if (getVariableRefresh(variable) !== VariableRefresh.never) {\n      // updates options\n      await dispatch(updateOptions(toKeyedVariableIdentifier(variable)));\n    } // get variable from state\n\n\n    const variableFromState = getVariable(toKeyedVariableIdentifier(variable), getState());\n\n    if (!variableFromState) {\n      throw new Error(`Couldn't find variable with name: ${variable.name}`);\n    } // Simple case. Value in URL matches existing options text or value.\n\n\n    let option = variableFromState.options.find(op => {\n      return op.text === stringUrlValue || op.value === stringUrlValue;\n    });\n\n    if (!option && isMulti(variableFromState)) {\n      if (variableFromState.allValue && stringUrlValue === variableFromState.allValue) {\n        option = {\n          text: ALL_VARIABLE_TEXT,\n          value: ALL_VARIABLE_VALUE,\n          selected: false\n        };\n      }\n    }\n\n    if (!option) {\n      let defaultText = stringUrlValue;\n      const defaultValue = stringUrlValue;\n\n      if (Array.isArray(stringUrlValue)) {\n        // Multiple values in the url. We construct text as a list of texts from all matched options.\n        defaultText = stringUrlValue.reduce((acc, item) => {\n          const foundOption = variableFromState.options.find(o => o.value === item);\n\n          if (!foundOption) {\n            // @ts-ignore according to strict null errors this can never happen\n            // TODO: investigate this further or refactor code\n            return [].concat(acc, [item]);\n          } // @ts-ignore according to strict null errors this can never happen\n          // TODO: investigate this further or refactor code\n\n\n          return [].concat(acc, [foundOption.text]);\n        }, []);\n      } // It is possible that we did not match the value to any existing option. In that case the URL value will be\n      // used anyway for both text and value.\n\n\n      option = {\n        text: defaultText,\n        value: defaultValue,\n        selected: false\n      };\n    }\n\n    if (isMulti(variableFromState)) {\n      // In case variable is multiple choice, we cast to array to preserve the same behavior as when selecting\n      // the option directly, which will return even single value in an array.\n      option = alignCurrentWithMulti({\n        text: castArray(option.text),\n        value: castArray(option.value),\n        selected: false\n      }, variableFromState.multi);\n    }\n\n    await variableAdapters.get(variable.type).setValue(variableFromState, option);\n  };\n};\nexport const selectOptionsForCurrentValue = variable => {\n  let i, y, value, option;\n  const selected = [];\n\n  for (i = 0; i < variable.options.length; i++) {\n    option = Object.assign({}, variable.options[i]);\n    option.selected = false;\n\n    if (Array.isArray(variable.current.value)) {\n      for (y = 0; y < variable.current.value.length; y++) {\n        value = variable.current.value[y];\n\n        if (option.value === value) {\n          option.selected = true;\n          selected.push(option);\n        }\n      }\n    } else if (option.value === variable.current.value) {\n      option.selected = true;\n      selected.push(option);\n    }\n  }\n\n  return selected;\n};\nexport const validateVariableSelectionState = (identifier, defaultValue) => {\n  return (dispatch, getState) => {\n    var _variableInState$opti;\n\n    const variableInState = getVariable(identifier, getState());\n    const current = variableInState.current || {};\n    const setValue = variableAdapters.get(variableInState.type).setValue;\n\n    if (Array.isArray(current.value)) {\n      const selected = selectOptionsForCurrentValue(variableInState); // if none pick first\n\n      if (selected.length === 0) {\n        const option = variableInState.options[0];\n        return setValue(variableInState, option);\n      }\n\n      const option = {\n        value: selected.map(v => v.value),\n        text: selected.map(v => v.text),\n        selected: true\n      };\n      return setValue(variableInState, option);\n    }\n\n    let option = null; // 1. find the current value\n\n    const text = getCurrentText(variableInState);\n    option = (_variableInState$opti = variableInState.options) === null || _variableInState$opti === void 0 ? void 0 : _variableInState$opti.find(v => v.text === text);\n\n    if (option) {\n      return setValue(variableInState, option);\n    } // 2. find the default value\n\n\n    if (defaultValue) {\n      var _variableInState$opti2;\n\n      option = (_variableInState$opti2 = variableInState.options) === null || _variableInState$opti2 === void 0 ? void 0 : _variableInState$opti2.find(v => v.text === defaultValue);\n\n      if (option) {\n        return setValue(variableInState, option);\n      }\n    } // 3. use the first value\n\n\n    if (variableInState.options) {\n      const option = variableInState.options[0];\n\n      if (option) {\n        return setValue(variableInState, option);\n      }\n    } // 4... give up\n\n\n    return Promise.resolve();\n  };\n};\nexport const setOptionAsCurrent = (identifier, current, emitChanges) => {\n  return async dispatch => {\n    const {\n      rootStateKey: key\n    } = identifier;\n    dispatch(toKeyedAction(key, setCurrentVariableValue(toVariablePayload(identifier, {\n      option: current\n    }))));\n    return await dispatch(variableUpdated(identifier, emitChanges));\n  };\n};\n\nconst createGraph = variables => {\n  const g = new Graph();\n  variables.forEach(v => {\n    g.createNode(v.name);\n  });\n  variables.forEach(v1 => {\n    variables.forEach(v2 => {\n      if (v1 === v2) {\n        return;\n      }\n\n      if (variableAdapters.get(v1.type).dependsOn(v1, v2)) {\n        g.link(v1.name, v2.name);\n      }\n    });\n  });\n  return g;\n};\n\nexport const variableUpdated = (identifier, emitChangeEvents, events = appEvents) => {\n  return async (dispatch, getState) => {\n    var _state$dashboard$getM, _state$dashboard, _state$dashboard$getM2;\n\n    const state = getState();\n    const {\n      rootStateKey\n    } = identifier;\n    const variableInState = getVariable(identifier, state); // if we're initializing variables ignore cascading update because we are in a boot up scenario\n\n    if (getVariablesState(rootStateKey, state).transaction.status === TransactionStatus.Fetching) {\n      if (getVariableRefresh(variableInState) === VariableRefresh.never) {\n        // for variable types with updates that go the setValueFromUrl path in the update let's make sure their state is set to Done.\n        await dispatch(upgradeLegacyQueries(toKeyedVariableIdentifier(variableInState)));\n        dispatch(completeVariableLoading(identifier));\n      }\n\n      return Promise.resolve();\n    }\n\n    const variables = getVariablesByKey(rootStateKey, state);\n    const g = createGraph(variables);\n    const panels = (_state$dashboard$getM = (_state$dashboard = state.dashboard) === null || _state$dashboard === void 0 ? void 0 : (_state$dashboard$getM2 = _state$dashboard.getModel()) === null || _state$dashboard$getM2 === void 0 ? void 0 : _state$dashboard$getM2.panels) !== null && _state$dashboard$getM !== void 0 ? _state$dashboard$getM : [];\n    const event = isAdHoc(variableInState) ? {\n      refreshAll: true,\n      panelIds: []\n    } // for adhoc variables we don't know which panels that will be impacted\n    : {\n      refreshAll: false,\n      panelIds: getAllAffectedPanelIdsForVariableChange(variableInState.id, variables, panels)\n    };\n    const node = g.getNode(variableInState.name);\n    let promises = [];\n\n    if (node) {\n      promises = node.getOptimizedInputEdges().map(e => {\n        const variable = variables.find(v => {\n          var _e$inputNode;\n\n          return v.name === ((_e$inputNode = e.inputNode) === null || _e$inputNode === void 0 ? void 0 : _e$inputNode.name);\n        });\n\n        if (!variable) {\n          return Promise.resolve();\n        }\n\n        return dispatch(updateOptions(toKeyedVariableIdentifier(variable)));\n      });\n    }\n\n    return Promise.all(promises).then(() => {\n      if (emitChangeEvents) {\n        events.publish(new VariablesChanged(event));\n        locationService.partial(getQueryWithVariables(rootStateKey, getState));\n      }\n    });\n  };\n};\nexport const onTimeRangeUpdated = (key, timeRange, dependencies = {\n  templateSrv: getTemplateSrv(),\n  events: appEvents\n}) => async (dispatch, getState) => {\n  dependencies.templateSrv.updateTimeRange(timeRange);\n  const variablesThatNeedRefresh = getVariablesByKey(key, getState()).filter(variable => {\n    if (variable.hasOwnProperty('refresh') && variable.hasOwnProperty('options')) {\n      const variableWithRefresh = variable;\n      return variableWithRefresh.refresh === VariableRefresh.onTimeRangeChanged;\n    }\n\n    return false;\n  });\n  const variableIds = variablesThatNeedRefresh.map(variable => variable.id);\n  const promises = variablesThatNeedRefresh.map(variable => dispatch(timeRangeUpdated(toKeyedVariableIdentifier(variable))));\n\n  try {\n    await Promise.all(promises);\n    dependencies.events.publish(new VariablesTimeRangeProcessDone({\n      variableIds\n    }));\n  } catch (error) {\n    console.error(error);\n    dispatch(notifyApp(createVariableErrorNotification('Template variable service failed', error)));\n  }\n};\n\nconst timeRangeUpdated = identifier => async (dispatch, getState) => {\n  const variableInState = getVariable(identifier, getState());\n  const previousOptions = variableInState.options.slice();\n  await dispatch(updateOptions(toKeyedVariableIdentifier(variableInState), true));\n  const updatedVariable = getVariable(identifier, getState());\n  const updatedOptions = updatedVariable.options;\n\n  if (JSON.stringify(previousOptions) !== JSON.stringify(updatedOptions)) {\n    const dashboard = getState().dashboard.getModel();\n    dashboard === null || dashboard === void 0 ? void 0 : dashboard.templateVariableValueUpdated();\n  }\n};\n\nexport const templateVarsChangedInUrl = (key, vars, events = appEvents) => async (dispatch, getState) => {\n  const update = [];\n  const dashboard = getState().dashboard.getModel();\n  const panelIds = new Set();\n  const variables = getVariablesByKey(key, getState());\n\n  for (const variable of variables) {\n    const key = `var-${variable.name}`;\n\n    if (!vars.hasOwnProperty(key)) {\n      // key not found quick exit\n      continue;\n    }\n\n    if (!isVariableUrlValueDifferentFromCurrent(variable, vars[key].value)) {\n      // variable values doesn't differ quick exit\n      continue;\n    }\n\n    let value = vars[key].value; // as the default the value is set to the value passed into templateVarsChangedInUrl\n\n    if (vars[key].removed) {\n      // for some reason (panel|data link without variable) the variable url value (var-xyz) has been removed from the url\n      // so we need to revert the value to the value stored in dashboard json\n      const variableInModel = dashboard === null || dashboard === void 0 ? void 0 : dashboard.templating.list.find(v => v.name === variable.name);\n\n      if (variableInModel && hasCurrent(variableInModel)) {\n        value = variableInModel.current.value; // revert value to the value stored in dashboard json\n      }\n\n      if (variableInModel && isConstant(variableInModel)) {\n        value = variableInModel.query; // revert value to the value stored in dashboard json, constants don't store current values in dashboard json\n      }\n    } // for adhoc variables we don't know which panels that will be impacted\n\n\n    if (!isAdHoc(variable)) {\n      var _dashboard$panels;\n\n      getAllAffectedPanelIdsForVariableChange(variable.id, variables, (_dashboard$panels = dashboard === null || dashboard === void 0 ? void 0 : dashboard.panels) !== null && _dashboard$panels !== void 0 ? _dashboard$panels : []).forEach(id => panelIds.add(id));\n    }\n\n    const promise = variableAdapters.get(variable.type).setValueFromUrl(variable, value);\n    update.push(promise);\n  }\n\n  if (update.length) {\n    await Promise.all(update);\n    events.publish(new VariablesChangedInUrl({\n      refreshAll: panelIds.size === 0,\n      panelIds: Array.from(panelIds)\n    }));\n  }\n};\nexport function isVariableUrlValueDifferentFromCurrent(variable, urlValue) {\n  const variableValue = variableAdapters.get(variable.type).getValueForUrl(variable);\n  let stringUrlValue = ensureStringValues(urlValue);\n\n  if (Array.isArray(variableValue) && !Array.isArray(stringUrlValue)) {\n    stringUrlValue = [stringUrlValue];\n  } // lodash isEqual handles array of value equality checks as well\n\n\n  return !isEqual(variableValue, stringUrlValue);\n}\n\nconst getQueryWithVariables = (key, getState) => {\n  const queryParams = locationService.getSearchObject();\n  const queryParamsNew = Object.keys(queryParams).filter(key => key.indexOf('var-') === -1).reduce((obj, key) => {\n    obj[key] = queryParams[key];\n    return obj;\n  }, {});\n\n  for (const variable of getVariablesByKey(key, getState())) {\n    if (variable.skipUrlSync) {\n      continue;\n    }\n\n    const adapter = variableAdapters.get(variable.type);\n    queryParamsNew['var-' + variable.name] = adapter.getValueForUrl(variable);\n  }\n\n  return queryParamsNew;\n};\n\nexport const initVariablesTransaction = (urlUid, dashboard) => async (dispatch, getState) => {\n  try {\n    const uid = toStateKey(urlUid);\n    const state = getState();\n    const lastKey = getIfExistsLastKey(state);\n\n    if (lastKey) {\n      const transactionState = getVariablesState(lastKey, state).transaction;\n\n      if (transactionState.status === TransactionStatus.Fetching) {\n        // previous dashboard is still fetching variables, cancel all requests\n        dispatch(cancelVariables(lastKey));\n      }\n    } // Start init transaction\n\n\n    dispatch(toKeyedAction(uid, variablesInitTransaction({\n      uid\n    }))); // Add system variables like __dashboard and __user\n\n    dispatch(addSystemTemplateVariables(uid, dashboard)); // Load all variables into redux store\n\n    dispatch(initDashboardTemplating(uid, dashboard)); // Migrate data source name to ref\n\n    dispatch(migrateVariablesDatasourceNameToRef(uid)); // Process all variable updates\n\n    await dispatch(processVariables(uid)); // Set transaction as complete\n\n    dispatch(toKeyedAction(uid, variablesCompleteTransaction({\n      uid\n    })));\n  } catch (err) {\n    dispatch(notifyApp(createVariableErrorNotification('Templating init failed', err)));\n    console.error(err);\n  }\n};\nexport function migrateVariablesDatasourceNameToRef(key, getDatasourceSrvFunc = getDatasourceSrv) {\n  return (dispatch, getState) => {\n    const variables = getVariablesByKey(key, getState());\n\n    for (const variable of variables) {\n      if (!isAdHoc(variable) && !isQuery(variable)) {\n        continue;\n      }\n\n      const {\n        datasource: nameOrRef\n      } = variable;\n\n      if (isDataSourceRef(nameOrRef)) {\n        continue;\n      } // the call to getInstanceSettings needs to be done after initDashboardTemplating because we might have\n      // datasource variables that need to be resolved\n\n\n      const ds = getDatasourceSrvFunc().getInstanceSettings(nameOrRef);\n      const dsRef = ds ? getDataSourceRef(ds) : {\n        uid: nameOrRef\n      };\n      dispatch(toKeyedAction(key, changeVariableProp(toVariablePayload(variable, {\n        propName: 'datasource',\n        propValue: dsRef\n      }))));\n    }\n  };\n}\nexport const cleanUpVariables = key => dispatch => {\n  dispatch(toKeyedAction(key, cleanVariables()));\n  dispatch(toKeyedAction(key, cleanEditorState()));\n  dispatch(toKeyedAction(key, cleanPickerState()));\n  dispatch(toKeyedAction(key, variablesClearTransaction()));\n};\nexport const cancelVariables = (key, dependencies = {\n  getBackendSrv: getBackendSrv\n}) => dispatch => {\n  dependencies.getBackendSrv().cancelAllInFlightRequests();\n  dispatch(cleanUpVariables(key));\n};\nexport const updateOptions = (identifier, rethrow = false) => async (dispatch, getState) => {\n  const {\n    rootStateKey\n  } = identifier;\n\n  try {\n    if (!hasOngoingTransaction(rootStateKey, getState())) {\n      // we might have cancelled a batch so then variable state is removed\n      return;\n    }\n\n    const variableInState = getVariable(identifier, getState());\n    dispatch(toKeyedAction(rootStateKey, variableStateFetching(toVariablePayload(variableInState))));\n    await dispatch(upgradeLegacyQueries(toKeyedVariableIdentifier(variableInState)));\n    await variableAdapters.get(variableInState.type).updateOptions(variableInState);\n    dispatch(completeVariableLoading(identifier));\n  } catch (error) {\n    dispatch(toKeyedAction(rootStateKey, variableStateFailed(toVariablePayload(identifier, {\n      error\n    }))));\n\n    if (!rethrow) {\n      console.error(error);\n      dispatch(notifyApp(createVariableErrorNotification('Error updating options:', error, identifier)));\n    }\n\n    if (rethrow) {\n      throw error;\n    }\n  }\n};\nexport const createVariableErrorNotification = (message, error, identifier) => createErrorNotification(`${identifier ? `Templating [${identifier.id}]` : 'Templating'}`, `${message} ${error.message}`);\nexport const completeVariableLoading = identifier => (dispatch, getState) => {\n  const {\n    rootStateKey\n  } = identifier;\n\n  if (!hasOngoingTransaction(rootStateKey, getState())) {\n    // we might have cancelled a batch so then variable state is removed\n    return;\n  }\n\n  const variableInState = getVariable(identifier, getState());\n\n  if (variableInState.state !== LoadingState.Done) {\n    dispatch(toKeyedAction(identifier.rootStateKey, variableStateCompleted(toVariablePayload(variableInState))));\n  }\n};\nexport function upgradeLegacyQueries(identifier, getDatasourceSrvFunc = getDatasourceSrv) {\n  return async function (dispatch, getState) {\n    const {\n      id,\n      rootStateKey\n    } = identifier;\n\n    if (!hasOngoingTransaction(rootStateKey, getState())) {\n      // we might have cancelled a batch so then variable state is removed\n      return;\n    }\n\n    const variable = getVariable(identifier, getState());\n\n    if (!isQuery(variable)) {\n      return;\n    }\n\n    try {\n      var _variable$datasource;\n\n      const datasource = await getDatasourceSrvFunc().get((_variable$datasource = variable.datasource) !== null && _variable$datasource !== void 0 ? _variable$datasource : '');\n\n      if (hasLegacyVariableSupport(datasource)) {\n        return;\n      }\n\n      if (!hasStandardVariableSupport(datasource)) {\n        return;\n      }\n\n      if (isDataQueryType(variable.query)) {\n        return;\n      }\n\n      const query = {\n        refId: `${datasource.name}-${id}-Variable-Query`,\n        query: variable.query\n      };\n      dispatch(toKeyedAction(rootStateKey, changeVariableProp(toVariablePayload(identifier, {\n        propName: 'query',\n        propValue: query\n      }))));\n    } catch (err) {\n      dispatch(notifyApp(createVariableErrorNotification('Failed to upgrade legacy queries', err)));\n      console.error(err);\n    }\n  };\n}\n\nfunction isDataQueryType(query) {\n  if (!query) {\n    return false;\n  }\n\n  return query.hasOwnProperty('refId') && typeof query.refId === 'string';\n}","map":{"version":3,"names":["castArray","isEqual","getDataSourceRef","isDataSourceRef","LoadingState","locationService","notifyApp","contextSrv","getTimeSrv","store","createErrorNotification","appEvents","getBackendSrv","Graph","getDatasourceSrv","getTemplateSrv","variableAdapters","ALL_VARIABLE_TEXT","ALL_VARIABLE_VALUE","cleanEditorState","hasCurrent","hasLegacyVariableSupport","hasOptions","hasStandardVariableSupport","isAdHoc","isConstant","isMulti","isQuery","getAllAffectedPanelIdsForVariableChange","cleanPickerState","alignCurrentWithMulti","initialVariableModelState","TransactionStatus","VariableHide","VariableRefresh","VariablesChanged","VariablesChangedInUrl","VariablesTimeRangeProcessDone","ensureStringValues","getCurrentText","getVariableRefresh","hasOngoingTransaction","toKeyedVariableIdentifier","toStateKey","toVariablePayload","toKeyedAction","getIfExistsLastKey","getVariable","getVariablesByKey","getVariablesState","addVariable","changeVariableProp","setCurrentVariableValue","variableStateCompleted","variableStateFailed","variableStateFetching","variableStateNotStarted","variablesClearTransaction","variablesCompleteTransaction","variablesInitTransaction","cleanVariables","initDashboardTemplating","key","dashboard","dispatch","getState","orderIndex","list","templating","index","length","model","fixSelectedInconsistency","rootStateKey","getIfExists","type","global","updateTimeRange","timeRange","variables","variable","found","option","options","selected","Array","isArray","current","value","addSystemTemplateVariables","dashboardModel","id","name","skipUrlSync","hide","hideVariable","title","uid","toString","orgModel","user","orgName","orgId","userModel","login","email","changeVariableMultiValue","identifier","multi","propName","propValue","processVariableDependencies","state","Error","isDependencyGraphCircular","dependencies","getDirectDependencies","isWaitingForDependencies","Promise","resolve","unsubscribe","subscribe","encounteredDependencyIds","Set","has","some","dependency","directDependencies","otherVariable","get","dependsOn","push","notCompletedDependencies","filter","d","v","NotStarted","Loading","processVariable","queryParams","urlValue","stringUrlValue","setValueFromUrl","hasOwnProperty","refreshableVariable","refresh","onDashboardLoad","onTimeRangeChanged","updateOptions","completeVariableLoading","processVariables","getSearchObject","promises","map","all","setOptionFromUrl","never","variableFromState","find","op","text","allValue","defaultText","defaultValue","reduce","acc","item","foundOption","o","concat","setValue","selectOptionsForCurrentValue","i","y","validateVariableSelectionState","variableInState","setOptionAsCurrent","emitChanges","variableUpdated","createGraph","g","forEach","createNode","v1","v2","link","emitChangeEvents","events","transaction","status","Fetching","upgradeLegacyQueries","panels","getModel","event","refreshAll","panelIds","node","getNode","getOptimizedInputEdges","e","inputNode","then","publish","partial","getQueryWithVariables","onTimeRangeUpdated","templateSrv","variablesThatNeedRefresh","variableWithRefresh","variableIds","timeRangeUpdated","error","console","createVariableErrorNotification","previousOptions","slice","updatedVariable","updatedOptions","JSON","stringify","templateVariableValueUpdated","templateVarsChangedInUrl","vars","update","isVariableUrlValueDifferentFromCurrent","removed","variableInModel","query","add","promise","size","from","variableValue","getValueForUrl","queryParamsNew","Object","keys","indexOf","obj","adapter","initVariablesTransaction","urlUid","lastKey","transactionState","cancelVariables","migrateVariablesDatasourceNameToRef","err","getDatasourceSrvFunc","datasource","nameOrRef","ds","getInstanceSettings","dsRef","cleanUpVariables","cancelAllInFlightRequests","rethrow","message","Done","isDataQueryType","refId"],"sources":["/home/soula/grafana/public/app/features/variables/state/actions.ts"],"sourcesContent":["import { castArray, isEqual } from 'lodash';\n\nimport {\n  DataQuery,\n  getDataSourceRef,\n  isDataSourceRef,\n  LoadingState,\n  TimeRange,\n  UrlQueryMap,\n  UrlQueryValue,\n} from '@grafana/data';\nimport { locationService } from '@grafana/runtime';\nimport { notifyApp } from 'app/core/actions';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { DashboardModel } from 'app/features/dashboard/state';\nimport { store } from 'app/store/store';\n\nimport { createErrorNotification } from '../../../core/copy/appNotification';\nimport { appEvents } from '../../../core/core';\nimport { getBackendSrv } from '../../../core/services/backend_srv';\nimport { Graph } from '../../../core/utils/dag';\nimport { AppNotification, StoreState, ThunkResult } from '../../../types';\nimport { getDatasourceSrv } from '../../plugins/datasource_srv';\nimport { getTemplateSrv, TemplateSrv } from '../../templating/template_srv';\nimport { variableAdapters } from '../adapters';\nimport { ALL_VARIABLE_TEXT, ALL_VARIABLE_VALUE } from '../constants';\nimport { cleanEditorState } from '../editor/reducer';\nimport {\n  hasCurrent,\n  hasLegacyVariableSupport,\n  hasOptions,\n  hasStandardVariableSupport,\n  isAdHoc,\n  isConstant,\n  isMulti,\n  isQuery,\n} from '../guard';\nimport { getAllAffectedPanelIdsForVariableChange } from '../inspect/utils';\nimport { cleanPickerState } from '../pickers/OptionsPicker/reducer';\nimport { alignCurrentWithMulti } from '../shared/multiOptions';\nimport {\n  DashboardVariableModel,\n  initialVariableModelState,\n  OrgVariableModel,\n  QueryVariableModel,\n  TransactionStatus,\n  UserVariableModel,\n  VariableHide,\n  VariableModel,\n  VariableOption,\n  VariableRefresh,\n  VariablesChanged,\n  VariablesChangedEvent,\n  VariablesChangedInUrl,\n  VariablesTimeRangeProcessDone,\n  VariableWithMultiSupport,\n  VariableWithOptions,\n} from '../types';\nimport {\n  ensureStringValues,\n  ExtendedUrlQueryMap,\n  getCurrentText,\n  getVariableRefresh,\n  hasOngoingTransaction,\n  toKeyedVariableIdentifier,\n  toStateKey,\n  toVariablePayload,\n} from '../utils';\n\nimport { toKeyedAction } from './keyedVariablesReducer';\nimport { getIfExistsLastKey, getVariable, getVariablesByKey, getVariablesState } from './selectors';\nimport {\n  addVariable,\n  changeVariableProp,\n  setCurrentVariableValue,\n  variableStateCompleted,\n  variableStateFailed,\n  variableStateFetching,\n  variableStateNotStarted,\n} from './sharedReducer';\nimport {\n  variablesClearTransaction,\n  variablesCompleteTransaction,\n  variablesInitTransaction,\n} from './transactionReducer';\nimport { KeyedVariableIdentifier } from './types';\nimport { cleanVariables } from './variablesReducer';\n\n// process flow queryVariable\n// thunk => processVariables\n//    adapter => setValueFromUrl\n//      thunk => setOptionFromUrl\n//        adapter => updateOptions\n//          thunk => updateQueryVariableOptions\n//            action => updateVariableOptions\n//            action => updateVariableTags\n//            thunk => validateVariableSelectionState\n//              adapter => setValue\n//                thunk => setOptionAsCurrent\n//                  action => setCurrentVariableValue\n//                  thunk => variableUpdated\n//                    adapter => updateOptions for dependent nodes\n//        adapter => setValue\n//          thunk => setOptionAsCurrent\n//            action => setCurrentVariableValue\n//            thunk => variableUpdated\n//              adapter => updateOptions for dependent nodes\n//    adapter => updateOptions\n//      thunk => updateQueryVariableOptions\n//        action => updateVariableOptions\n//        action => updateVariableTags\n//        thunk => validateVariableSelectionState\n//          adapter => setValue\n//            thunk => setOptionAsCurrent\n//              action => setCurrentVariableValue\n//              thunk => variableUpdated\n//                adapter => updateOptions for dependent nodes\n\nexport const initDashboardTemplating = (key: string, dashboard: DashboardModel): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    let orderIndex = 0;\n    const list = dashboard.templating.list;\n    for (let index = 0; index < list.length; index++) {\n      const model = fixSelectedInconsistency(list[index]);\n      model.rootStateKey = key;\n      if (!variableAdapters.getIfExists(model.type)) {\n        continue;\n      }\n\n      dispatch(\n        toKeyedAction(key, addVariable(toVariablePayload(model, { global: false, index: orderIndex++, model })))\n      );\n    }\n\n    getTemplateSrv().updateTimeRange(getTimeSrv().timeRange());\n\n    const variables = getVariablesByKey(key, getState());\n    for (const variable of variables) {\n      dispatch(toKeyedAction(key, variableStateNotStarted(toVariablePayload(variable))));\n    }\n  };\n};\n\nexport function fixSelectedInconsistency(model: VariableModel): VariableModel | VariableWithOptions {\n  if (!hasOptions(model)) {\n    return model;\n  }\n\n  let found = false;\n  for (const option of model.options) {\n    option.selected = false;\n    if (Array.isArray(model.current.value)) {\n      for (const value of model.current.value) {\n        if (option.value === value) {\n          option.selected = found = true;\n        }\n      }\n    } else if (option.value === model.current.value) {\n      option.selected = found = true;\n    }\n  }\n\n  if (!found && model.options.length) {\n    model.options[0].selected = true;\n  }\n\n  return model;\n}\n\nexport const addSystemTemplateVariables = (key: string, dashboard: DashboardModel): ThunkResult<void> => {\n  return (dispatch) => {\n    const dashboardModel: DashboardVariableModel = {\n      ...initialVariableModelState,\n      id: '__dashboard',\n      name: '__dashboard',\n      type: 'system',\n      index: -3,\n      skipUrlSync: true,\n      hide: VariableHide.hideVariable,\n      current: {\n        value: {\n          name: dashboard.title,\n          uid: dashboard.uid,\n          toString: () => dashboard.title,\n        },\n      },\n    };\n\n    dispatch(\n      toKeyedAction(\n        key,\n        addVariable(\n          toVariablePayload(dashboardModel, {\n            global: dashboardModel.global,\n            index: dashboardModel.index,\n            model: dashboardModel,\n          })\n        )\n      )\n    );\n\n    const orgModel: OrgVariableModel = {\n      ...initialVariableModelState,\n      id: '__org',\n      name: '__org',\n      type: 'system',\n      index: -2,\n      skipUrlSync: true,\n      hide: VariableHide.hideVariable,\n      current: {\n        value: {\n          name: contextSrv.user.orgName,\n          id: contextSrv.user.orgId,\n          toString: () => contextSrv.user.orgId.toString(),\n        },\n      },\n    };\n\n    dispatch(\n      toKeyedAction(\n        key,\n        addVariable(toVariablePayload(orgModel, { global: orgModel.global, index: orgModel.index, model: orgModel }))\n      )\n    );\n\n    const userModel: UserVariableModel = {\n      ...initialVariableModelState,\n      id: '__user',\n      name: '__user',\n      type: 'system',\n      index: -1,\n      skipUrlSync: true,\n      hide: VariableHide.hideVariable,\n      current: {\n        value: {\n          login: contextSrv.user.login,\n          id: contextSrv.user.id,\n          email: contextSrv.user.email,\n          toString: () => contextSrv.user.id.toString(),\n        },\n      },\n    };\n\n    dispatch(\n      toKeyedAction(\n        key,\n        addVariable(\n          toVariablePayload(userModel, { global: userModel.global, index: userModel.index, model: userModel })\n        )\n      )\n    );\n  };\n};\n\nexport const changeVariableMultiValue = (identifier: KeyedVariableIdentifier, multi: boolean): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    const { rootStateKey: key } = identifier;\n    const variable = getVariable<VariableWithMultiSupport>(identifier, getState());\n    const current = alignCurrentWithMulti(variable.current, multi);\n\n    dispatch(\n      toKeyedAction(key, changeVariableProp(toVariablePayload(identifier, { propName: 'multi', propValue: multi })))\n    );\n    dispatch(\n      toKeyedAction(key, changeVariableProp(toVariablePayload(identifier, { propName: 'current', propValue: current })))\n    );\n  };\n};\n\nexport const processVariableDependencies = async (variable: VariableModel, state: StoreState) => {\n  if (!variable.rootStateKey) {\n    throw new Error(`rootStateKey not found for variable with id:${variable.id}`);\n  }\n\n  if (isDependencyGraphCircular(variable, state)) {\n    throw new Error('Circular dependency in dashboard variables detected. Dashboard may not work as expected.');\n  }\n\n  const dependencies = getDirectDependencies(variable, state);\n\n  if (!isWaitingForDependencies(variable.rootStateKey, dependencies, state)) {\n    return;\n  }\n\n  await new Promise<void>((resolve) => {\n    const unsubscribe = store.subscribe(() => {\n      if (!variable.rootStateKey) {\n        throw new Error(`rootStateKey not found for variable with id:${variable.id}`);\n      }\n\n      if (!isWaitingForDependencies(variable.rootStateKey, dependencies, store.getState())) {\n        unsubscribe();\n        resolve();\n      }\n    });\n  });\n};\n\nconst isDependencyGraphCircular = (\n  variable: VariableModel,\n  state: StoreState,\n  encounteredDependencyIds: Set<string> = new Set()\n): boolean => {\n  if (encounteredDependencyIds.has(variable.id)) {\n    return true;\n  }\n\n  encounteredDependencyIds = new Set([...encounteredDependencyIds, variable.id]);\n\n  return getDirectDependencies(variable, state).some((dependency) => {\n    return isDependencyGraphCircular(dependency, state, encounteredDependencyIds);\n  });\n};\n\nconst getDirectDependencies = (variable: VariableModel, state: StoreState) => {\n  if (!variable.rootStateKey) {\n    return [];\n  }\n\n  const directDependencies: VariableModel[] = [];\n\n  for (const otherVariable of getVariablesByKey(variable.rootStateKey, state)) {\n    if (variable === otherVariable) {\n      continue;\n    }\n\n    if (variableAdapters.getIfExists(variable.type)) {\n      if (variableAdapters.get(variable.type).dependsOn(variable, otherVariable)) {\n        directDependencies.push(otherVariable);\n      }\n    }\n  }\n\n  return directDependencies;\n};\n\nconst isWaitingForDependencies = (key: string, dependencies: VariableModel[], state: StoreState): boolean => {\n  if (dependencies.length === 0) {\n    return false;\n  }\n\n  const variables = getVariablesByKey(key, state);\n  const notCompletedDependencies = dependencies.filter((d) =>\n    variables.some((v) => v.id === d.id && (v.state === LoadingState.NotStarted || v.state === LoadingState.Loading))\n  );\n\n  return notCompletedDependencies.length > 0;\n};\n\nexport const processVariable = (\n  identifier: KeyedVariableIdentifier,\n  queryParams: UrlQueryMap\n): ThunkResult<Promise<void>> => {\n  return async (dispatch, getState) => {\n    const variable = getVariable(identifier, getState());\n    await processVariableDependencies(variable, getState());\n\n    const urlValue = queryParams['var-' + variable.name];\n    if (urlValue !== void 0) {\n      const stringUrlValue = ensureStringValues(urlValue);\n      await variableAdapters.get(variable.type).setValueFromUrl(variable, stringUrlValue);\n      return;\n    }\n\n    if (variable.hasOwnProperty('refresh')) {\n      const refreshableVariable = variable as QueryVariableModel;\n      if (\n        refreshableVariable.refresh === VariableRefresh.onDashboardLoad ||\n        refreshableVariable.refresh === VariableRefresh.onTimeRangeChanged\n      ) {\n        await dispatch(updateOptions(toKeyedVariableIdentifier(refreshableVariable)));\n        return;\n      }\n    }\n\n    // for variables that aren't updated via URL or refresh, let's simulate the same state changes\n    dispatch(completeVariableLoading(identifier));\n  };\n};\n\nexport const processVariables = (key: string): ThunkResult<Promise<void>> => {\n  return async (dispatch, getState) => {\n    const queryParams = locationService.getSearchObject();\n    const promises = getVariablesByKey(key, getState()).map(\n      async (variable: VariableModel) =>\n        await dispatch(processVariable(toKeyedVariableIdentifier(variable), queryParams))\n    );\n\n    await Promise.all(promises);\n  };\n};\n\nexport const setOptionFromUrl = (\n  identifier: KeyedVariableIdentifier,\n  urlValue: UrlQueryValue\n): ThunkResult<Promise<void>> => {\n  return async (dispatch, getState) => {\n    const stringUrlValue = ensureStringValues(urlValue);\n    const variable = getVariable(identifier, getState());\n    if (getVariableRefresh(variable) !== VariableRefresh.never) {\n      // updates options\n      await dispatch(updateOptions(toKeyedVariableIdentifier(variable)));\n    }\n\n    // get variable from state\n    const variableFromState = getVariable<VariableWithOptions>(toKeyedVariableIdentifier(variable), getState());\n    if (!variableFromState) {\n      throw new Error(`Couldn't find variable with name: ${variable.name}`);\n    }\n    // Simple case. Value in URL matches existing options text or value.\n    let option = variableFromState.options.find((op) => {\n      return op.text === stringUrlValue || op.value === stringUrlValue;\n    });\n\n    if (!option && isMulti(variableFromState)) {\n      if (variableFromState.allValue && stringUrlValue === variableFromState.allValue) {\n        option = { text: ALL_VARIABLE_TEXT, value: ALL_VARIABLE_VALUE, selected: false };\n      }\n    }\n\n    if (!option) {\n      let defaultText = stringUrlValue;\n      const defaultValue = stringUrlValue;\n\n      if (Array.isArray(stringUrlValue)) {\n        // Multiple values in the url. We construct text as a list of texts from all matched options.\n        defaultText = stringUrlValue.reduce((acc: string[], item: string) => {\n          const foundOption = variableFromState.options.find((o) => o.value === item);\n          if (!foundOption) {\n            // @ts-ignore according to strict null errors this can never happen\n            // TODO: investigate this further or refactor code\n            return [].concat(acc, [item]);\n          }\n\n          // @ts-ignore according to strict null errors this can never happen\n          // TODO: investigate this further or refactor code\n          return [].concat(acc, [foundOption.text]);\n        }, []);\n      }\n\n      // It is possible that we did not match the value to any existing option. In that case the URL value will be\n      // used anyway for both text and value.\n      option = { text: defaultText, value: defaultValue, selected: false };\n    }\n\n    if (isMulti(variableFromState)) {\n      // In case variable is multiple choice, we cast to array to preserve the same behavior as when selecting\n      // the option directly, which will return even single value in an array.\n      option = alignCurrentWithMulti(\n        { text: castArray(option.text), value: castArray(option.value), selected: false },\n        variableFromState.multi\n      );\n    }\n\n    await variableAdapters.get(variable.type).setValue(variableFromState, option);\n  };\n};\n\nexport const selectOptionsForCurrentValue = (variable: VariableWithOptions): VariableOption[] => {\n  let i, y, value, option;\n  const selected: VariableOption[] = [];\n\n  for (i = 0; i < variable.options.length; i++) {\n    option = { ...variable.options[i] };\n    option.selected = false;\n    if (Array.isArray(variable.current.value)) {\n      for (y = 0; y < variable.current.value.length; y++) {\n        value = variable.current.value[y];\n        if (option.value === value) {\n          option.selected = true;\n          selected.push(option);\n        }\n      }\n    } else if (option.value === variable.current.value) {\n      option.selected = true;\n      selected.push(option);\n    }\n  }\n\n  return selected;\n};\n\nexport const validateVariableSelectionState = (\n  identifier: KeyedVariableIdentifier,\n  defaultValue?: string\n): ThunkResult<Promise<void>> => {\n  return (dispatch, getState) => {\n    const variableInState = getVariable<VariableWithOptions>(identifier, getState());\n    const current = variableInState.current || ({} as unknown as VariableOption);\n    const setValue = variableAdapters.get(variableInState.type).setValue;\n\n    if (Array.isArray(current.value)) {\n      const selected = selectOptionsForCurrentValue(variableInState);\n\n      // if none pick first\n      if (selected.length === 0) {\n        const option = variableInState.options[0];\n        return setValue(variableInState, option);\n      }\n\n      const option: VariableOption = {\n        value: selected.map((v) => v.value) as string[],\n        text: selected.map((v) => v.text) as string[],\n        selected: true,\n      };\n      return setValue(variableInState, option);\n    }\n\n    let option: VariableOption | undefined | null = null;\n\n    // 1. find the current value\n    const text = getCurrentText(variableInState);\n    option = variableInState.options?.find((v) => v.text === text);\n    if (option) {\n      return setValue(variableInState, option);\n    }\n\n    // 2. find the default value\n    if (defaultValue) {\n      option = variableInState.options?.find((v) => v.text === defaultValue);\n      if (option) {\n        return setValue(variableInState, option);\n      }\n    }\n\n    // 3. use the first value\n    if (variableInState.options) {\n      const option = variableInState.options[0];\n      if (option) {\n        return setValue(variableInState, option);\n      }\n    }\n\n    // 4... give up\n    return Promise.resolve();\n  };\n};\n\nexport const setOptionAsCurrent = (\n  identifier: KeyedVariableIdentifier,\n  current: VariableOption,\n  emitChanges: boolean\n): ThunkResult<Promise<void>> => {\n  return async (dispatch) => {\n    const { rootStateKey: key } = identifier;\n    dispatch(toKeyedAction(key, setCurrentVariableValue(toVariablePayload(identifier, { option: current }))));\n    return await dispatch(variableUpdated(identifier, emitChanges));\n  };\n};\n\nconst createGraph = (variables: VariableModel[]) => {\n  const g = new Graph();\n\n  variables.forEach((v) => {\n    g.createNode(v.name);\n  });\n\n  variables.forEach((v1) => {\n    variables.forEach((v2) => {\n      if (v1 === v2) {\n        return;\n      }\n\n      if (variableAdapters.get(v1.type).dependsOn(v1, v2)) {\n        g.link(v1.name, v2.name);\n      }\n    });\n  });\n\n  return g;\n};\n\nexport const variableUpdated = (\n  identifier: KeyedVariableIdentifier,\n  emitChangeEvents: boolean,\n  events: typeof appEvents = appEvents\n): ThunkResult<Promise<void>> => {\n  return async (dispatch, getState) => {\n    const state = getState();\n    const { rootStateKey } = identifier;\n    const variableInState = getVariable(identifier, state);\n\n    // if we're initializing variables ignore cascading update because we are in a boot up scenario\n    if (getVariablesState(rootStateKey, state).transaction.status === TransactionStatus.Fetching) {\n      if (getVariableRefresh(variableInState) === VariableRefresh.never) {\n        // for variable types with updates that go the setValueFromUrl path in the update let's make sure their state is set to Done.\n        await dispatch(upgradeLegacyQueries(toKeyedVariableIdentifier(variableInState)));\n        dispatch(completeVariableLoading(identifier));\n      }\n      return Promise.resolve();\n    }\n\n    const variables = getVariablesByKey(rootStateKey, state);\n    const g = createGraph(variables);\n    const panels = state.dashboard?.getModel()?.panels ?? [];\n    const event: VariablesChangedEvent = isAdHoc(variableInState)\n      ? { refreshAll: true, panelIds: [] } // for adhoc variables we don't know which panels that will be impacted\n      : { refreshAll: false, panelIds: getAllAffectedPanelIdsForVariableChange(variableInState.id, variables, panels) };\n\n    const node = g.getNode(variableInState.name);\n    let promises: Array<Promise<any>> = [];\n    if (node) {\n      promises = node.getOptimizedInputEdges().map((e) => {\n        const variable = variables.find((v) => v.name === e.inputNode?.name);\n        if (!variable) {\n          return Promise.resolve();\n        }\n\n        return dispatch(updateOptions(toKeyedVariableIdentifier(variable)));\n      });\n    }\n\n    return Promise.all(promises).then(() => {\n      if (emitChangeEvents) {\n        events.publish(new VariablesChanged(event));\n        locationService.partial(getQueryWithVariables(rootStateKey, getState));\n      }\n    });\n  };\n};\n\nexport interface OnTimeRangeUpdatedDependencies {\n  templateSrv: TemplateSrv;\n  events: typeof appEvents;\n}\n\nexport const onTimeRangeUpdated =\n  (\n    key: string,\n    timeRange: TimeRange,\n    dependencies: OnTimeRangeUpdatedDependencies = { templateSrv: getTemplateSrv(), events: appEvents }\n  ): ThunkResult<Promise<void>> =>\n  async (dispatch, getState) => {\n    dependencies.templateSrv.updateTimeRange(timeRange);\n    const variablesThatNeedRefresh = getVariablesByKey(key, getState()).filter((variable) => {\n      if (variable.hasOwnProperty('refresh') && variable.hasOwnProperty('options')) {\n        const variableWithRefresh = variable as unknown as QueryVariableModel;\n        return variableWithRefresh.refresh === VariableRefresh.onTimeRangeChanged;\n      }\n\n      return false;\n    }) as VariableWithOptions[];\n\n    const variableIds = variablesThatNeedRefresh.map((variable) => variable.id);\n    const promises = variablesThatNeedRefresh.map((variable: VariableWithOptions) =>\n      dispatch(timeRangeUpdated(toKeyedVariableIdentifier(variable)))\n    );\n\n    try {\n      await Promise.all(promises);\n      dependencies.events.publish(new VariablesTimeRangeProcessDone({ variableIds }));\n    } catch (error) {\n      console.error(error);\n      dispatch(notifyApp(createVariableErrorNotification('Template variable service failed', error)));\n    }\n  };\n\nconst timeRangeUpdated =\n  (identifier: KeyedVariableIdentifier): ThunkResult<Promise<void>> =>\n  async (dispatch, getState) => {\n    const variableInState = getVariable<VariableWithOptions>(identifier, getState());\n    const previousOptions = variableInState.options.slice();\n\n    await dispatch(updateOptions(toKeyedVariableIdentifier(variableInState), true));\n\n    const updatedVariable = getVariable<VariableWithOptions>(identifier, getState());\n    const updatedOptions = updatedVariable.options;\n\n    if (JSON.stringify(previousOptions) !== JSON.stringify(updatedOptions)) {\n      const dashboard = getState().dashboard.getModel();\n      dashboard?.templateVariableValueUpdated();\n    }\n  };\n\nexport const templateVarsChangedInUrl =\n  (key: string, vars: ExtendedUrlQueryMap, events: typeof appEvents = appEvents): ThunkResult<void> =>\n  async (dispatch, getState) => {\n    const update: Array<Promise<any>> = [];\n    const dashboard = getState().dashboard.getModel();\n    const panelIds = new Set<number>();\n    const variables = getVariablesByKey(key, getState());\n    for (const variable of variables) {\n      const key = `var-${variable.name}`;\n      if (!vars.hasOwnProperty(key)) {\n        // key not found quick exit\n        continue;\n      }\n\n      if (!isVariableUrlValueDifferentFromCurrent(variable, vars[key].value)) {\n        // variable values doesn't differ quick exit\n        continue;\n      }\n\n      let value = vars[key].value; // as the default the value is set to the value passed into templateVarsChangedInUrl\n      if (vars[key].removed) {\n        // for some reason (panel|data link without variable) the variable url value (var-xyz) has been removed from the url\n        // so we need to revert the value to the value stored in dashboard json\n        const variableInModel = dashboard?.templating.list.find((v) => v.name === variable.name);\n        if (variableInModel && hasCurrent(variableInModel)) {\n          value = variableInModel.current.value; // revert value to the value stored in dashboard json\n        }\n\n        if (variableInModel && isConstant(variableInModel)) {\n          value = variableInModel.query; // revert value to the value stored in dashboard json, constants don't store current values in dashboard json\n        }\n      }\n\n      // for adhoc variables we don't know which panels that will be impacted\n      if (!isAdHoc(variable)) {\n        getAllAffectedPanelIdsForVariableChange(variable.id, variables, dashboard?.panels ?? []).forEach((id) =>\n          panelIds.add(id)\n        );\n      }\n\n      const promise = variableAdapters.get(variable.type).setValueFromUrl(variable, value);\n      update.push(promise);\n    }\n\n    if (update.length) {\n      await Promise.all(update);\n\n      events.publish(\n        new VariablesChangedInUrl({\n          refreshAll: panelIds.size === 0,\n          panelIds: Array.from(panelIds),\n        })\n      );\n    }\n  };\n\nexport function isVariableUrlValueDifferentFromCurrent(variable: VariableModel, urlValue: any): boolean {\n  const variableValue = variableAdapters.get(variable.type).getValueForUrl(variable);\n  let stringUrlValue = ensureStringValues(urlValue);\n  if (Array.isArray(variableValue) && !Array.isArray(stringUrlValue)) {\n    stringUrlValue = [stringUrlValue];\n  }\n  // lodash isEqual handles array of value equality checks as well\n  return !isEqual(variableValue, stringUrlValue);\n}\n\nconst getQueryWithVariables = (key: string, getState: () => StoreState): UrlQueryMap => {\n  const queryParams = locationService.getSearchObject();\n\n  const queryParamsNew = Object.keys(queryParams)\n    .filter((key) => key.indexOf('var-') === -1)\n    .reduce((obj, key) => {\n      obj[key] = queryParams[key];\n      return obj;\n    }, {} as UrlQueryMap);\n\n  for (const variable of getVariablesByKey(key, getState())) {\n    if (variable.skipUrlSync) {\n      continue;\n    }\n\n    const adapter = variableAdapters.get(variable.type);\n    queryParamsNew['var-' + variable.name] = adapter.getValueForUrl(variable);\n  }\n\n  return queryParamsNew;\n};\n\nexport const initVariablesTransaction =\n  (urlUid: string, dashboard: DashboardModel): ThunkResult<Promise<void>> =>\n  async (dispatch, getState) => {\n    try {\n      const uid = toStateKey(urlUid);\n      const state = getState();\n      const lastKey = getIfExistsLastKey(state);\n      if (lastKey) {\n        const transactionState = getVariablesState(lastKey, state).transaction;\n        if (transactionState.status === TransactionStatus.Fetching) {\n          // previous dashboard is still fetching variables, cancel all requests\n          dispatch(cancelVariables(lastKey));\n        }\n      }\n\n      // Start init transaction\n      dispatch(toKeyedAction(uid, variablesInitTransaction({ uid })));\n      // Add system variables like __dashboard and __user\n      dispatch(addSystemTemplateVariables(uid, dashboard));\n      // Load all variables into redux store\n      dispatch(initDashboardTemplating(uid, dashboard));\n      // Migrate data source name to ref\n      dispatch(migrateVariablesDatasourceNameToRef(uid));\n      // Process all variable updates\n      await dispatch(processVariables(uid));\n      // Set transaction as complete\n      dispatch(toKeyedAction(uid, variablesCompleteTransaction({ uid })));\n    } catch (err) {\n      dispatch(notifyApp(createVariableErrorNotification('Templating init failed', err)));\n      console.error(err);\n    }\n  };\n\nexport function migrateVariablesDatasourceNameToRef(\n  key: string,\n  getDatasourceSrvFunc = getDatasourceSrv\n): ThunkResult<void> {\n  return (dispatch, getState) => {\n    const variables = getVariablesByKey(key, getState());\n    for (const variable of variables) {\n      if (!isAdHoc(variable) && !isQuery(variable)) {\n        continue;\n      }\n\n      const { datasource: nameOrRef } = variable;\n\n      if (isDataSourceRef(nameOrRef)) {\n        continue;\n      }\n\n      // the call to getInstanceSettings needs to be done after initDashboardTemplating because we might have\n      // datasource variables that need to be resolved\n      const ds = getDatasourceSrvFunc().getInstanceSettings(nameOrRef);\n      const dsRef = ds ? getDataSourceRef(ds) : { uid: nameOrRef };\n      dispatch(\n        toKeyedAction(\n          key,\n          changeVariableProp(toVariablePayload(variable, { propName: 'datasource', propValue: dsRef }))\n        )\n      );\n    }\n  };\n}\n\nexport const cleanUpVariables =\n  (key: string): ThunkResult<void> =>\n  (dispatch) => {\n    dispatch(toKeyedAction(key, cleanVariables()));\n    dispatch(toKeyedAction(key, cleanEditorState()));\n    dispatch(toKeyedAction(key, cleanPickerState()));\n    dispatch(toKeyedAction(key, variablesClearTransaction()));\n  };\n\ntype CancelVariablesDependencies = { getBackendSrv: typeof getBackendSrv };\nexport const cancelVariables =\n  (key: string, dependencies: CancelVariablesDependencies = { getBackendSrv: getBackendSrv }): ThunkResult<void> =>\n  (dispatch) => {\n    dependencies.getBackendSrv().cancelAllInFlightRequests();\n    dispatch(cleanUpVariables(key));\n  };\n\nexport const updateOptions =\n  (identifier: KeyedVariableIdentifier, rethrow = false): ThunkResult<Promise<void>> =>\n  async (dispatch, getState) => {\n    const { rootStateKey } = identifier;\n    try {\n      if (!hasOngoingTransaction(rootStateKey, getState())) {\n        // we might have cancelled a batch so then variable state is removed\n        return;\n      }\n\n      const variableInState = getVariable(identifier, getState());\n      dispatch(toKeyedAction(rootStateKey, variableStateFetching(toVariablePayload(variableInState))));\n      await dispatch(upgradeLegacyQueries(toKeyedVariableIdentifier(variableInState)));\n      await variableAdapters.get(variableInState.type).updateOptions(variableInState);\n      dispatch(completeVariableLoading(identifier));\n    } catch (error) {\n      dispatch(toKeyedAction(rootStateKey, variableStateFailed(toVariablePayload(identifier, { error }))));\n\n      if (!rethrow) {\n        console.error(error);\n        dispatch(notifyApp(createVariableErrorNotification('Error updating options:', error, identifier)));\n      }\n\n      if (rethrow) {\n        throw error;\n      }\n    }\n  };\n\nexport const createVariableErrorNotification = (\n  message: string,\n  error: any,\n  identifier?: KeyedVariableIdentifier\n): AppNotification =>\n  createErrorNotification(\n    `${identifier ? `Templating [${identifier.id}]` : 'Templating'}`,\n    `${message} ${error.message}`\n  );\n\nexport const completeVariableLoading =\n  (identifier: KeyedVariableIdentifier): ThunkResult<void> =>\n  (dispatch, getState) => {\n    const { rootStateKey } = identifier;\n    if (!hasOngoingTransaction(rootStateKey, getState())) {\n      // we might have cancelled a batch so then variable state is removed\n      return;\n    }\n\n    const variableInState = getVariable(identifier, getState());\n\n    if (variableInState.state !== LoadingState.Done) {\n      dispatch(toKeyedAction(identifier.rootStateKey, variableStateCompleted(toVariablePayload(variableInState))));\n    }\n  };\n\nexport function upgradeLegacyQueries(\n  identifier: KeyedVariableIdentifier,\n  getDatasourceSrvFunc: typeof getDatasourceSrv = getDatasourceSrv\n): ThunkResult<void> {\n  return async function (dispatch, getState) {\n    const { id, rootStateKey } = identifier;\n    if (!hasOngoingTransaction(rootStateKey, getState())) {\n      // we might have cancelled a batch so then variable state is removed\n      return;\n    }\n\n    const variable = getVariable<QueryVariableModel>(identifier, getState());\n\n    if (!isQuery(variable)) {\n      return;\n    }\n\n    try {\n      const datasource = await getDatasourceSrvFunc().get(variable.datasource ?? '');\n\n      if (hasLegacyVariableSupport(datasource)) {\n        return;\n      }\n\n      if (!hasStandardVariableSupport(datasource)) {\n        return;\n      }\n\n      if (isDataQueryType(variable.query)) {\n        return;\n      }\n\n      const query = {\n        refId: `${datasource.name}-${id}-Variable-Query`,\n        query: variable.query,\n      };\n\n      dispatch(\n        toKeyedAction(\n          rootStateKey,\n          changeVariableProp(toVariablePayload(identifier, { propName: 'query', propValue: query }))\n        )\n      );\n    } catch (err) {\n      dispatch(notifyApp(createVariableErrorNotification('Failed to upgrade legacy queries', err)));\n      console.error(err);\n    }\n  };\n}\n\nfunction isDataQueryType(query: any): query is DataQuery {\n  if (!query) {\n    return false;\n  }\n\n  return query.hasOwnProperty('refId') && typeof query.refId === 'string';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}