{"ast":null,"code":"import { SpanStatusCode } from '@opentelemetry/api';\nimport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';\nimport differenceInHours from 'date-fns/differenceInHours';\nimport formatDistance from 'date-fns/formatDistance';\nimport { ArrayVector, FieldType, MutableDataFrame, dateTimeFormat } from '@grafana/data';\nimport { createGraphFrames } from './graphTransform';\nexport function createTableFrame(logsFrame, datasourceUid, datasourceName, traceRegexs) {\n  const tableFrame = new MutableDataFrame({\n    fields: [{\n      name: 'Time',\n      type: FieldType.time,\n      config: {\n        custom: {\n          width: 150\n        }\n      }\n    }, {\n      name: 'traceID',\n      type: FieldType.string,\n      config: {\n        displayNameFromDS: 'Trace ID',\n        custom: {\n          width: 300\n        },\n        links: [{\n          title: 'Click to open trace ${__value.raw}',\n          url: '',\n          internal: {\n            datasourceUid,\n            datasourceName,\n            query: {\n              query: '${__value.raw}'\n            }\n          }\n        }]\n      }\n    }, {\n      name: 'Message',\n      type: FieldType.string\n    }],\n    meta: {\n      preferredVisualisationType: 'table'\n    }\n  });\n\n  if (!logsFrame || traceRegexs.length === 0) {\n    return tableFrame;\n  }\n\n  const timeField = logsFrame.fields.find(f => f.type === FieldType.time); // Going through all string fields to look for trace IDs\n\n  for (let field of logsFrame.fields) {\n    let hasMatch = false;\n\n    if (field.type === FieldType.string) {\n      const values = field.values.toArray();\n\n      for (let i = 0; i < values.length; i++) {\n        const line = values[i];\n\n        if (line) {\n          for (let traceRegex of traceRegexs) {\n            const match = line.match(traceRegex);\n\n            if (match) {\n              const traceId = match[1];\n              const time = timeField ? timeField.values.get(i) : null;\n              tableFrame.fields[0].values.add(time);\n              tableFrame.fields[1].values.add(traceId);\n              tableFrame.fields[2].values.add(line);\n              hasMatch = true;\n            }\n          }\n        }\n      }\n    }\n\n    if (hasMatch) {\n      break;\n    }\n  }\n\n  return tableFrame;\n}\nexport function transformTraceList(response, datasourceId, datasourceName, traceRegexs) {\n  response.data.forEach((data, index) => {\n    const frame = createTableFrame(data, datasourceId, datasourceName, traceRegexs);\n    response.data[index] = frame;\n  });\n  return response;\n} // Don't forget to change the backend code when the id representation changed\n\nfunction transformBase64IDToHexString(base64) {\n  const raw = atob(base64);\n  let result = '';\n\n  for (let i = 0; i < raw.length; i++) {\n    const hex = raw.charCodeAt(i).toString(16);\n    result += hex.length === 2 ? hex : '0' + hex;\n  }\n\n  return result.length > 16 ? result.slice(16) : result;\n}\n\nfunction transformHexStringToBase64ID(hex) {\n  const hexArray = hex.match(/\\w{2}/g) || [];\n  return btoa(hexArray.map(function (a) {\n    return String.fromCharCode(parseInt(a, 16));\n  }).join(''));\n}\n\nfunction getAttributeValue(value) {\n  if (value.stringValue) {\n    return value.stringValue;\n  }\n\n  if (value.boolValue !== undefined) {\n    return Boolean(value.boolValue);\n  }\n\n  if (value.intValue !== undefined) {\n    return Number.parseInt(value.intValue, 10);\n  }\n\n  if (value.doubleValue) {\n    return Number.parseFloat(value.doubleValue);\n  }\n\n  if (value.arrayValue) {\n    const arrayValue = [];\n\n    for (const arValue of value.arrayValue.values) {\n      arrayValue.push(getAttributeValue(arValue));\n    }\n\n    return arrayValue;\n  }\n\n  return '';\n}\n\nfunction resourceToProcess(resource) {\n  const serviceTags = [];\n  let serviceName = 'OTLPResourceNoServiceName';\n\n  if (!resource) {\n    return {\n      serviceName,\n      serviceTags\n    };\n  }\n\n  for (const attribute of resource.attributes) {\n    if (attribute.key === SemanticResourceAttributes.SERVICE_NAME) {\n      serviceName = attribute.value.stringValue || serviceName;\n    }\n\n    serviceTags.push({\n      key: attribute.key,\n      value: getAttributeValue(attribute.value)\n    });\n  }\n\n  return {\n    serviceName,\n    serviceTags\n  };\n}\n\nfunction getSpanTags(span, instrumentationLibrary) {\n  const spanTags = [];\n\n  if (instrumentationLibrary) {\n    if (instrumentationLibrary.name) {\n      spanTags.push({\n        key: 'otel.library.name',\n        value: instrumentationLibrary.name\n      });\n    }\n\n    if (instrumentationLibrary.version) {\n      spanTags.push({\n        key: 'otel.library.version',\n        value: instrumentationLibrary.version\n      });\n    }\n  }\n\n  if (span.attributes) {\n    for (const attribute of span.attributes) {\n      spanTags.push({\n        key: attribute.key,\n        value: getAttributeValue(attribute.value)\n      });\n    }\n  }\n\n  if (span.status) {\n    if (span.status.code && span.status.code !== SpanStatusCode.UNSET) {\n      spanTags.push({\n        key: 'otel.status_code',\n        value: SpanStatusCode[span.status.code]\n      });\n\n      if (span.status.message) {\n        spanTags.push({\n          key: 'otel.status_description',\n          value: span.status.message\n        });\n      }\n    }\n\n    if (span.status.code === SpanStatusCode.ERROR) {\n      spanTags.push({\n        key: 'error',\n        value: true\n      });\n    }\n  }\n\n  if (span.kind !== undefined) {\n    const split = span.kind.toString().toLowerCase().split('_');\n    spanTags.push({\n      key: 'span.kind',\n      value: split.length ? split[split.length - 1] : span.kind.toString()\n    });\n  }\n\n  return spanTags;\n}\n\nfunction getReferences(span) {\n  const references = [];\n\n  if (span.links) {\n    for (const link of span.links) {\n      const {\n        traceId,\n        spanId\n      } = link;\n      const tags = [];\n\n      if (link.attributes) {\n        for (const attribute of link.attributes) {\n          tags.push({\n            key: attribute.key,\n            value: getAttributeValue(attribute.value)\n          });\n        }\n      }\n\n      references.push({\n        traceID: traceId,\n        spanID: spanId,\n        tags\n      });\n    }\n  }\n\n  return references;\n}\n\nfunction getLogs(span) {\n  const logs = [];\n\n  if (span.events) {\n    for (const event of span.events) {\n      const fields = [];\n\n      if (event.attributes) {\n        for (const attribute of event.attributes) {\n          fields.push({\n            key: attribute.key,\n            value: getAttributeValue(attribute.value)\n          });\n        }\n      }\n\n      logs.push({\n        fields,\n        timestamp: event.timeUnixNano / 1000000\n      });\n    }\n  }\n\n  return logs;\n}\n\nexport function transformFromOTLP(traceData, nodeGraph = false) {\n  const frame = new MutableDataFrame({\n    fields: [{\n      name: 'traceID',\n      type: FieldType.string\n    }, {\n      name: 'spanID',\n      type: FieldType.string\n    }, {\n      name: 'parentSpanID',\n      type: FieldType.string\n    }, {\n      name: 'operationName',\n      type: FieldType.string\n    }, {\n      name: 'serviceName',\n      type: FieldType.string\n    }, {\n      name: 'serviceTags',\n      type: FieldType.other\n    }, {\n      name: 'startTime',\n      type: FieldType.number\n    }, {\n      name: 'duration',\n      type: FieldType.number\n    }, {\n      name: 'logs',\n      type: FieldType.other\n    }, {\n      name: 'references',\n      type: FieldType.other\n    }, {\n      name: 'tags',\n      type: FieldType.other\n    }],\n    meta: {\n      preferredVisualisationType: 'trace',\n      custom: {\n        traceFormat: 'otlp'\n      }\n    }\n  });\n\n  try {\n    for (const data of traceData) {\n      const {\n        serviceName,\n        serviceTags\n      } = resourceToProcess(data.resource);\n\n      for (const librarySpan of data.instrumentationLibrarySpans) {\n        for (const span of librarySpan.spans) {\n          frame.add({\n            traceID: transformBase64IDToHexString(span.traceId),\n            spanID: transformBase64IDToHexString(span.spanId),\n            parentSpanID: transformBase64IDToHexString(span.parentSpanId || ''),\n            operationName: span.name || '',\n            serviceName,\n            serviceTags,\n            startTime: span.startTimeUnixNano / 1000000,\n            duration: (span.endTimeUnixNano - span.startTimeUnixNano) / 1000000,\n            tags: getSpanTags(span, librarySpan.instrumentationLibrary),\n            logs: getLogs(span),\n            references: getReferences(span)\n          });\n        }\n      }\n    }\n  } catch (error) {\n    console.error(error);\n    return {\n      error: {\n        message: 'JSON is not valid OpenTelemetry format: ' + error\n      },\n      data: []\n    };\n  }\n\n  let data = [frame];\n\n  if (nodeGraph) {\n    data.push(...createGraphFrames(frame));\n  }\n\n  return {\n    data\n  };\n}\n/**\n * Transforms trace dataframes to the OpenTelemetry format\n */\n\nexport function transformToOTLP(data) {\n  let result = {\n    batches: []\n  }; // Lookup object to see which batch contains spans for which services\n\n  let services = {};\n\n  for (let i = 0; i < data.length; i++) {\n    const span = data.get(i); // Group spans based on service\n\n    if (!services[span.serviceName]) {\n      services[span.serviceName] = result.batches.length;\n      result.batches.push({\n        resource: {\n          attributes: [],\n          droppedAttributesCount: 0\n        },\n        instrumentationLibrarySpans: [{\n          spans: []\n        }]\n      });\n    }\n\n    let batchIndex = services[span.serviceName]; // Populate resource attributes from service tags\n\n    if (result.batches[batchIndex].resource.attributes.length === 0) {\n      result.batches[batchIndex].resource.attributes = tagsToAttributes(span.serviceTags);\n    } // Populate instrumentation library if it exists\n\n\n    if (!result.batches[batchIndex].instrumentationLibrarySpans[0].instrumentationLibrary) {\n      var _span$tags$find;\n\n      let libraryName = (_span$tags$find = span.tags.find(t => t.key === 'otel.library.name')) === null || _span$tags$find === void 0 ? void 0 : _span$tags$find.value;\n\n      if (libraryName) {\n        var _span$tags$find2;\n\n        result.batches[batchIndex].instrumentationLibrarySpans[0].instrumentationLibrary = {\n          name: libraryName,\n          version: (_span$tags$find2 = span.tags.find(t => t.key === 'otel.library.version')) === null || _span$tags$find2 === void 0 ? void 0 : _span$tags$find2.value\n        };\n      }\n    }\n\n    result.batches[batchIndex].instrumentationLibrarySpans[0].spans.push({\n      traceId: transformHexStringToBase64ID(span.traceID.padStart(32, '0')),\n      spanId: transformHexStringToBase64ID(span.spanID),\n      traceState: '',\n      parentSpanId: transformHexStringToBase64ID(span.parentSpanID || ''),\n      name: span.operationName,\n      kind: getOTLPSpanKind(span.tags),\n      startTimeUnixNano: span.startTime * 1000000,\n      endTimeUnixNano: (span.startTime + span.duration) * 1000000,\n      attributes: tagsToAttributes(span.tags),\n      droppedAttributesCount: 0,\n      droppedEventsCount: 0,\n      droppedLinksCount: 0,\n      status: getOTLPStatus(span.tags),\n      events: getOTLPEvents(span.logs),\n      links: getOTLPReferences(span.references)\n    });\n  }\n\n  return result;\n}\n\nfunction getOTLPSpanKind(tags) {\n  var _tags$find;\n\n  let spanKind = undefined;\n  const spanKindTagValue = (_tags$find = tags.find(t => t.key === 'span.kind')) === null || _tags$find === void 0 ? void 0 : _tags$find.value;\n\n  switch (spanKindTagValue) {\n    case 'server':\n      spanKind = 'SPAN_KIND_SERVER';\n      break;\n\n    case 'client':\n      spanKind = 'SPAN_KIND_CLIENT';\n      break;\n\n    case 'producer':\n      spanKind = 'SPAN_KIND_PRODUCER';\n      break;\n\n    case 'consumer':\n      spanKind = 'SPAN_KIND_CONSUMER';\n      break;\n  }\n\n  return spanKind;\n}\n/**\n * Converts key-value tags to OTLP attributes and removes tags added by Grafana\n */\n\n\nfunction tagsToAttributes(tags) {\n  return tags.filter(t => !['span.kind', 'otel.library.name', 'otel.libary.version', 'otel.status_description', 'otel.status_code'].includes(t.key)).reduce((attributes, tag) => [...attributes, {\n    key: tag.key,\n    value: toAttributeValue(tag)\n  }], []);\n}\n/**\n * Returns the correct OTLP AnyValue based on the value of the tag value\n */\n\n\nfunction toAttributeValue(tag) {\n  if (typeof tag.value === 'string') {\n    return {\n      stringValue: tag.value\n    };\n  } else if (typeof tag.value === 'boolean') {\n    return {\n      boolValue: tag.value\n    };\n  } else if (typeof tag.value === 'number') {\n    if (tag.value % 1 === 0) {\n      return {\n        intValue: tag.value\n      };\n    } else {\n      return {\n        doubleValue: tag.value\n      };\n    }\n  } else if (typeof tag.value === 'object') {\n    if (Array.isArray(tag.value)) {\n      const values = [];\n\n      for (const val of tag.value) {\n        values.push(toAttributeValue(val));\n      }\n\n      return {\n        arrayValue: {\n          values\n        }\n      };\n    }\n  }\n\n  return {\n    stringValue: tag.value\n  };\n}\n\nfunction getOTLPStatus(tags) {\n  let status = undefined;\n  const statusCodeTag = tags.find(t => t.key === 'otel.status_code');\n\n  if (statusCodeTag) {\n    var _tags$find2;\n\n    status = {\n      code: statusCodeTag.value,\n      message: (_tags$find2 = tags.find(t => t.key === 'otel_status_description')) === null || _tags$find2 === void 0 ? void 0 : _tags$find2.value\n    };\n  }\n\n  return status;\n}\n\nfunction getOTLPEvents(logs) {\n  if (!logs || !logs.length) {\n    return undefined;\n  }\n\n  let events = [];\n\n  for (const log of logs) {\n    let event = {\n      timeUnixNano: log.timestamp * 1000000,\n      attributes: [],\n      droppedAttributesCount: 0,\n      name: ''\n    };\n\n    for (const field of log.fields) {\n      event.attributes.push({\n        key: field.key,\n        value: toAttributeValue(field)\n      });\n    }\n\n    events.push(event);\n  }\n\n  return events;\n}\n\nfunction getOTLPReferences(references) {\n  if (!references || !references.length) {\n    return undefined;\n  }\n\n  let links = [];\n\n  for (const ref of references) {\n    var _ref$tags;\n\n    let link = {\n      traceId: ref.traceID,\n      spanId: ref.spanID,\n      attributes: [],\n      droppedAttributesCount: 0\n    };\n\n    if ((_ref$tags = ref.tags) !== null && _ref$tags !== void 0 && _ref$tags.length) {\n      for (const tag of ref.tags) {\n        var _link$attributes;\n\n        (_link$attributes = link.attributes) === null || _link$attributes === void 0 ? void 0 : _link$attributes.push({\n          key: tag.key,\n          value: toAttributeValue(tag)\n        });\n      }\n    }\n\n    links.push(link);\n  }\n\n  return links;\n}\n\nexport function transformTrace(response, nodeGraph = false) {\n  // We need to parse some of the fields which contain stringified json.\n  // Seems like we can't just map the values as the frame we got from backend has some default processing\n  // and will stringify the json back when we try to set it. So we create a new field and swap it instead.\n  const frame = response.data[0];\n\n  if (!frame) {\n    return emptyDataQueryResponse;\n  }\n\n  try {\n    parseJsonFields(frame);\n  } catch (error) {\n    console.error(error);\n    return {\n      error: {\n        message: 'Unable to parse trace response: ' + error\n      },\n      data: []\n    };\n  }\n\n  let data = [...response.data];\n\n  if (nodeGraph) {\n    data.push(...createGraphFrames(frame));\n  }\n\n  return Object.assign({}, response, {\n    data\n  });\n}\n/**\n * Change fields which are json string into JS objects. Modifies the frame in place.\n */\n\nfunction parseJsonFields(frame) {\n  for (const fieldName of ['serviceTags', 'logs', 'tags', 'references']) {\n    const field = frame.fields.find(f => f.name === fieldName);\n\n    if (field) {\n      const fieldIndex = frame.fields.indexOf(field);\n      const values = new ArrayVector();\n      const newField = Object.assign({}, field, {\n        values,\n        type: FieldType.other\n      });\n\n      for (let i = 0; i < field.values.length; i++) {\n        const value = field.values.get(i);\n        values.set(i, value === '' ? undefined : JSON.parse(value));\n      }\n\n      frame.fields[fieldIndex] = newField;\n    }\n  }\n}\n\nexport function createTableFrameFromSearch(data, instanceSettings) {\n  const frame = new MutableDataFrame({\n    fields: [{\n      name: 'traceID',\n      type: FieldType.string,\n      config: {\n        unit: 'string',\n        displayNameFromDS: 'Trace ID',\n        links: [{\n          title: 'Trace: ${__value.raw}',\n          url: '',\n          internal: {\n            datasourceUid: instanceSettings.uid,\n            datasourceName: instanceSettings.name,\n            query: {\n              query: '${__value.raw}',\n              queryType: 'traceId'\n            }\n          }\n        }]\n      }\n    }, {\n      name: 'traceName',\n      type: FieldType.string,\n      config: {\n        displayNameFromDS: 'Trace name'\n      }\n    }, {\n      name: 'startTime',\n      type: FieldType.string,\n      config: {\n        displayNameFromDS: 'Start time'\n      }\n    }, {\n      name: 'duration',\n      type: FieldType.number,\n      config: {\n        displayNameFromDS: 'Duration',\n        unit: 'ms'\n      }\n    }],\n    meta: {\n      preferredVisualisationType: 'table'\n    }\n  });\n\n  if (!(data !== null && data !== void 0 && data.length)) {\n    return frame;\n  } // Show the most recent traces\n\n\n  const traceData = data.sort((a, b) => parseInt(b === null || b === void 0 ? void 0 : b.startTimeUnixNano, 10) / 1000000 - parseInt(a === null || a === void 0 ? void 0 : a.startTimeUnixNano, 10) / 1000000).map(transformToTraceData);\n\n  for (const trace of traceData) {\n    frame.add(trace);\n  }\n\n  return frame;\n}\n\nfunction transformToTraceData(data) {\n  let traceName = '';\n\n  if (data.rootServiceName) {\n    traceName += data.rootServiceName + ' ';\n  }\n\n  if (data.rootTraceName) {\n    traceName += data.rootTraceName;\n  }\n\n  const traceStartTime = parseInt(data.startTimeUnixNano, 10) / 1000000;\n  let startTime = dateTimeFormat(traceStartTime);\n\n  if (Math.abs(differenceInHours(new Date(traceStartTime), Date.now())) <= 1) {\n    startTime = formatDistance(new Date(traceStartTime), Date.now(), {\n      addSuffix: true,\n      includeSeconds: true\n    });\n  }\n\n  return {\n    traceID: data.traceID,\n    startTime: startTime,\n    duration: data.durationMs,\n    traceName\n  };\n}\n\nconst emptyDataQueryResponse = {\n  data: [new MutableDataFrame({\n    fields: [{\n      name: 'trace',\n      type: FieldType.trace,\n      values: []\n    }],\n    meta: {\n      preferredVisualisationType: 'trace',\n      custom: {\n        traceFormat: 'otlp'\n      }\n    }\n  })]\n};","map":{"version":3,"names":["SpanStatusCode","SemanticResourceAttributes","differenceInHours","formatDistance","ArrayVector","FieldType","MutableDataFrame","dateTimeFormat","createGraphFrames","createTableFrame","logsFrame","datasourceUid","datasourceName","traceRegexs","tableFrame","fields","name","type","time","config","custom","width","string","displayNameFromDS","links","title","url","internal","query","meta","preferredVisualisationType","length","timeField","find","f","field","hasMatch","values","toArray","i","line","traceRegex","match","traceId","get","add","transformTraceList","response","datasourceId","data","forEach","index","frame","transformBase64IDToHexString","base64","raw","atob","result","hex","charCodeAt","toString","slice","transformHexStringToBase64ID","hexArray","btoa","map","a","String","fromCharCode","parseInt","join","getAttributeValue","value","stringValue","boolValue","undefined","Boolean","intValue","Number","doubleValue","parseFloat","arrayValue","arValue","push","resourceToProcess","resource","serviceTags","serviceName","attribute","attributes","key","SERVICE_NAME","getSpanTags","span","instrumentationLibrary","spanTags","version","status","code","UNSET","message","ERROR","kind","split","toLowerCase","getReferences","references","link","spanId","tags","traceID","spanID","getLogs","logs","events","event","timestamp","timeUnixNano","transformFromOTLP","traceData","nodeGraph","other","number","traceFormat","librarySpan","instrumentationLibrarySpans","spans","parentSpanID","parentSpanId","operationName","startTime","startTimeUnixNano","duration","endTimeUnixNano","error","console","transformToOTLP","batches","services","droppedAttributesCount","batchIndex","tagsToAttributes","libraryName","t","padStart","traceState","getOTLPSpanKind","droppedEventsCount","droppedLinksCount","getOTLPStatus","getOTLPEvents","getOTLPReferences","spanKind","spanKindTagValue","filter","includes","reduce","tag","toAttributeValue","Array","isArray","val","statusCodeTag","log","ref","transformTrace","emptyDataQueryResponse","parseJsonFields","fieldName","fieldIndex","indexOf","newField","set","JSON","parse","createTableFrameFromSearch","instanceSettings","unit","uid","queryType","sort","b","transformToTraceData","trace","traceName","rootServiceName","rootTraceName","traceStartTime","Math","abs","Date","now","addSuffix","includeSeconds","durationMs"],"sources":["/home/soula/grafana/public/app/plugins/datasource/tempo/resultTransformer.ts"],"sourcesContent":["import { SpanStatus, SpanStatusCode } from '@opentelemetry/api';\nimport { collectorTypes } from '@opentelemetry/exporter-collector';\nimport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';\nimport differenceInHours from 'date-fns/differenceInHours';\nimport formatDistance from 'date-fns/formatDistance';\n\nimport {\n  ArrayVector,\n  DataFrame,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n  Field,\n  FieldType,\n  MutableDataFrame,\n  TraceKeyValuePair,\n  TraceLog,\n  TraceSpanReference,\n  TraceSpanRow,\n  dateTimeFormat,\n} from '@grafana/data';\n\nimport { createGraphFrames } from './graphTransform';\n\nexport function createTableFrame(\n  logsFrame: DataFrame,\n  datasourceUid: string,\n  datasourceName: string,\n  traceRegexs: string[]\n): DataFrame {\n  const tableFrame = new MutableDataFrame({\n    fields: [\n      {\n        name: 'Time',\n        type: FieldType.time,\n        config: {\n          custom: {\n            width: 150,\n          },\n        },\n      },\n      {\n        name: 'traceID',\n        type: FieldType.string,\n        config: {\n          displayNameFromDS: 'Trace ID',\n          custom: { width: 300 },\n          links: [\n            {\n              title: 'Click to open trace ${__value.raw}',\n              url: '',\n              internal: {\n                datasourceUid,\n                datasourceName,\n                query: {\n                  query: '${__value.raw}',\n                },\n              },\n            },\n          ],\n        },\n      },\n      {\n        name: 'Message',\n        type: FieldType.string,\n      },\n    ],\n    meta: {\n      preferredVisualisationType: 'table',\n    },\n  });\n\n  if (!logsFrame || traceRegexs.length === 0) {\n    return tableFrame;\n  }\n\n  const timeField = logsFrame.fields.find((f) => f.type === FieldType.time);\n\n  // Going through all string fields to look for trace IDs\n  for (let field of logsFrame.fields) {\n    let hasMatch = false;\n    if (field.type === FieldType.string) {\n      const values = field.values.toArray();\n      for (let i = 0; i < values.length; i++) {\n        const line = values[i];\n        if (line) {\n          for (let traceRegex of traceRegexs) {\n            const match = (line as string).match(traceRegex);\n            if (match) {\n              const traceId = match[1];\n              const time = timeField ? timeField.values.get(i) : null;\n              tableFrame.fields[0].values.add(time);\n              tableFrame.fields[1].values.add(traceId);\n              tableFrame.fields[2].values.add(line);\n              hasMatch = true;\n            }\n          }\n        }\n      }\n    }\n    if (hasMatch) {\n      break;\n    }\n  }\n\n  return tableFrame;\n}\n\nexport function transformTraceList(\n  response: DataQueryResponse,\n  datasourceId: string,\n  datasourceName: string,\n  traceRegexs: string[]\n): DataQueryResponse {\n  response.data.forEach((data, index) => {\n    const frame = createTableFrame(data, datasourceId, datasourceName, traceRegexs);\n    response.data[index] = frame;\n  });\n  return response;\n}\n\n// Don't forget to change the backend code when the id representation changed\nfunction transformBase64IDToHexString(base64: string) {\n  const raw = atob(base64);\n  let result = '';\n  for (let i = 0; i < raw.length; i++) {\n    const hex = raw.charCodeAt(i).toString(16);\n    result += hex.length === 2 ? hex : '0' + hex;\n  }\n\n  return result.length > 16 ? result.slice(16) : result;\n}\n\nfunction transformHexStringToBase64ID(hex: string) {\n  const hexArray = hex.match(/\\w{2}/g) || [];\n  return btoa(\n    hexArray\n      .map(function (a) {\n        return String.fromCharCode(parseInt(a, 16));\n      })\n      .join('')\n  );\n}\n\nfunction getAttributeValue(value: collectorTypes.opentelemetryProto.common.v1.AnyValue): any {\n  if (value.stringValue) {\n    return value.stringValue;\n  }\n\n  if (value.boolValue !== undefined) {\n    return Boolean(value.boolValue);\n  }\n\n  if (value.intValue !== undefined) {\n    return Number.parseInt(value.intValue as any, 10);\n  }\n\n  if (value.doubleValue) {\n    return Number.parseFloat(value.doubleValue as any);\n  }\n\n  if (value.arrayValue) {\n    const arrayValue = [];\n    for (const arValue of value.arrayValue.values) {\n      arrayValue.push(getAttributeValue(arValue));\n    }\n    return arrayValue;\n  }\n\n  return '';\n}\n\nfunction resourceToProcess(resource: collectorTypes.opentelemetryProto.resource.v1.Resource | undefined) {\n  const serviceTags: TraceKeyValuePair[] = [];\n  let serviceName = 'OTLPResourceNoServiceName';\n  if (!resource) {\n    return { serviceName, serviceTags };\n  }\n\n  for (const attribute of resource.attributes) {\n    if (attribute.key === SemanticResourceAttributes.SERVICE_NAME) {\n      serviceName = attribute.value.stringValue || serviceName;\n    }\n    serviceTags.push({ key: attribute.key, value: getAttributeValue(attribute.value) });\n  }\n\n  return { serviceName, serviceTags };\n}\n\nfunction getSpanTags(\n  span: collectorTypes.opentelemetryProto.trace.v1.Span,\n  instrumentationLibrary?: collectorTypes.opentelemetryProto.common.v1.InstrumentationLibrary\n): TraceKeyValuePair[] {\n  const spanTags: TraceKeyValuePair[] = [];\n\n  if (instrumentationLibrary) {\n    if (instrumentationLibrary.name) {\n      spanTags.push({ key: 'otel.library.name', value: instrumentationLibrary.name });\n    }\n    if (instrumentationLibrary.version) {\n      spanTags.push({ key: 'otel.library.version', value: instrumentationLibrary.version });\n    }\n  }\n\n  if (span.attributes) {\n    for (const attribute of span.attributes) {\n      spanTags.push({ key: attribute.key, value: getAttributeValue(attribute.value) });\n    }\n  }\n\n  if (span.status) {\n    if (span.status.code && (span.status.code as any) !== SpanStatusCode.UNSET) {\n      spanTags.push({\n        key: 'otel.status_code',\n        value: SpanStatusCode[span.status.code],\n      });\n      if (span.status.message) {\n        spanTags.push({ key: 'otel.status_description', value: span.status.message });\n      }\n    }\n    if (span.status.code === SpanStatusCode.ERROR) {\n      spanTags.push({ key: 'error', value: true });\n    }\n  }\n\n  if (span.kind !== undefined) {\n    const split = span.kind.toString().toLowerCase().split('_');\n    spanTags.push({\n      key: 'span.kind',\n      value: split.length ? split[split.length - 1] : span.kind.toString(),\n    });\n  }\n\n  return spanTags;\n}\n\nfunction getReferences(span: collectorTypes.opentelemetryProto.trace.v1.Span) {\n  const references: TraceSpanReference[] = [];\n  if (span.links) {\n    for (const link of span.links) {\n      const { traceId, spanId } = link;\n      const tags: TraceKeyValuePair[] = [];\n      if (link.attributes) {\n        for (const attribute of link.attributes) {\n          tags.push({ key: attribute.key, value: getAttributeValue(attribute.value) });\n        }\n      }\n      references.push({ traceID: traceId, spanID: spanId, tags });\n    }\n  }\n\n  return references;\n}\n\nfunction getLogs(span: collectorTypes.opentelemetryProto.trace.v1.Span) {\n  const logs: TraceLog[] = [];\n  if (span.events) {\n    for (const event of span.events) {\n      const fields: TraceKeyValuePair[] = [];\n      if (event.attributes) {\n        for (const attribute of event.attributes) {\n          fields.push({ key: attribute.key, value: getAttributeValue(attribute.value) });\n        }\n      }\n      logs.push({ fields, timestamp: event.timeUnixNano / 1000000 });\n    }\n  }\n\n  return logs;\n}\n\nexport function transformFromOTLP(\n  traceData: collectorTypes.opentelemetryProto.trace.v1.ResourceSpans[],\n  nodeGraph = false\n): DataQueryResponse {\n  const frame = new MutableDataFrame({\n    fields: [\n      { name: 'traceID', type: FieldType.string },\n      { name: 'spanID', type: FieldType.string },\n      { name: 'parentSpanID', type: FieldType.string },\n      { name: 'operationName', type: FieldType.string },\n      { name: 'serviceName', type: FieldType.string },\n      { name: 'serviceTags', type: FieldType.other },\n      { name: 'startTime', type: FieldType.number },\n      { name: 'duration', type: FieldType.number },\n      { name: 'logs', type: FieldType.other },\n      { name: 'references', type: FieldType.other },\n      { name: 'tags', type: FieldType.other },\n    ],\n    meta: {\n      preferredVisualisationType: 'trace',\n      custom: {\n        traceFormat: 'otlp',\n      },\n    },\n  });\n  try {\n    for (const data of traceData) {\n      const { serviceName, serviceTags } = resourceToProcess(data.resource);\n      for (const librarySpan of data.instrumentationLibrarySpans) {\n        for (const span of librarySpan.spans) {\n          frame.add({\n            traceID: transformBase64IDToHexString(span.traceId),\n            spanID: transformBase64IDToHexString(span.spanId),\n            parentSpanID: transformBase64IDToHexString(span.parentSpanId || ''),\n            operationName: span.name || '',\n            serviceName,\n            serviceTags,\n            startTime: span.startTimeUnixNano! / 1000000,\n            duration: (span.endTimeUnixNano! - span.startTimeUnixNano!) / 1000000,\n            tags: getSpanTags(span, librarySpan.instrumentationLibrary),\n            logs: getLogs(span),\n            references: getReferences(span),\n          } as TraceSpanRow);\n        }\n      }\n    }\n  } catch (error) {\n    console.error(error);\n    return { error: { message: 'JSON is not valid OpenTelemetry format: ' + error }, data: [] };\n  }\n\n  let data = [frame];\n  if (nodeGraph) {\n    data.push(...(createGraphFrames(frame) as MutableDataFrame[]));\n  }\n\n  return { data };\n}\n\n/**\n * Transforms trace dataframes to the OpenTelemetry format\n */\nexport function transformToOTLP(data: MutableDataFrame): {\n  batches: collectorTypes.opentelemetryProto.trace.v1.ResourceSpans[];\n} {\n  let result: { batches: collectorTypes.opentelemetryProto.trace.v1.ResourceSpans[] } = {\n    batches: [],\n  };\n\n  // Lookup object to see which batch contains spans for which services\n  let services: { [key: string]: number } = {};\n\n  for (let i = 0; i < data.length; i++) {\n    const span = data.get(i);\n\n    // Group spans based on service\n    if (!services[span.serviceName]) {\n      services[span.serviceName] = result.batches.length;\n      result.batches.push({\n        resource: {\n          attributes: [],\n          droppedAttributesCount: 0,\n        },\n        instrumentationLibrarySpans: [\n          {\n            spans: [],\n          },\n        ],\n      });\n    }\n\n    let batchIndex = services[span.serviceName];\n\n    // Populate resource attributes from service tags\n    if (result.batches[batchIndex].resource!.attributes.length === 0) {\n      result.batches[batchIndex].resource!.attributes = tagsToAttributes(span.serviceTags);\n    }\n\n    // Populate instrumentation library if it exists\n    if (!result.batches[batchIndex].instrumentationLibrarySpans[0].instrumentationLibrary) {\n      let libraryName = span.tags.find((t: TraceKeyValuePair) => t.key === 'otel.library.name')?.value;\n      if (libraryName) {\n        result.batches[batchIndex].instrumentationLibrarySpans[0].instrumentationLibrary = {\n          name: libraryName,\n          version: span.tags.find((t: TraceKeyValuePair) => t.key === 'otel.library.version')?.value,\n        };\n      }\n    }\n\n    result.batches[batchIndex].instrumentationLibrarySpans[0].spans.push({\n      traceId: transformHexStringToBase64ID(span.traceID.padStart(32, '0')),\n      spanId: transformHexStringToBase64ID(span.spanID),\n      traceState: '',\n      parentSpanId: transformHexStringToBase64ID(span.parentSpanID || ''),\n      name: span.operationName,\n      kind: getOTLPSpanKind(span.tags) as any,\n      startTimeUnixNano: span.startTime * 1000000,\n      endTimeUnixNano: (span.startTime + span.duration) * 1000000,\n      attributes: tagsToAttributes(span.tags),\n      droppedAttributesCount: 0,\n      droppedEventsCount: 0,\n      droppedLinksCount: 0,\n      status: getOTLPStatus(span.tags),\n      events: getOTLPEvents(span.logs),\n      links: getOTLPReferences(span.references),\n    });\n  }\n\n  return result;\n}\n\nfunction getOTLPSpanKind(tags: TraceKeyValuePair[]): string | undefined {\n  let spanKind = undefined;\n  const spanKindTagValue = tags.find((t) => t.key === 'span.kind')?.value;\n  switch (spanKindTagValue) {\n    case 'server':\n      spanKind = 'SPAN_KIND_SERVER';\n      break;\n    case 'client':\n      spanKind = 'SPAN_KIND_CLIENT';\n      break;\n    case 'producer':\n      spanKind = 'SPAN_KIND_PRODUCER';\n      break;\n    case 'consumer':\n      spanKind = 'SPAN_KIND_CONSUMER';\n      break;\n  }\n\n  return spanKind;\n}\n\n/**\n * Converts key-value tags to OTLP attributes and removes tags added by Grafana\n */\nfunction tagsToAttributes(tags: TraceKeyValuePair[]): collectorTypes.opentelemetryProto.common.v1.KeyValue[] {\n  return tags\n    .filter(\n      (t) =>\n        ![\n          'span.kind',\n          'otel.library.name',\n          'otel.libary.version',\n          'otel.status_description',\n          'otel.status_code',\n        ].includes(t.key)\n    )\n    .reduce<collectorTypes.opentelemetryProto.common.v1.KeyValue[]>(\n      (attributes, tag) => [...attributes, { key: tag.key, value: toAttributeValue(tag) }],\n      []\n    );\n}\n\n/**\n * Returns the correct OTLP AnyValue based on the value of the tag value\n */\nfunction toAttributeValue(tag: TraceKeyValuePair): collectorTypes.opentelemetryProto.common.v1.AnyValue {\n  if (typeof tag.value === 'string') {\n    return { stringValue: tag.value };\n  } else if (typeof tag.value === 'boolean') {\n    return { boolValue: tag.value };\n  } else if (typeof tag.value === 'number') {\n    if (tag.value % 1 === 0) {\n      return { intValue: tag.value };\n    } else {\n      return { doubleValue: tag.value };\n    }\n  } else if (typeof tag.value === 'object') {\n    if (Array.isArray(tag.value)) {\n      const values: collectorTypes.opentelemetryProto.common.v1.AnyValue[] = [];\n      for (const val of tag.value) {\n        values.push(toAttributeValue(val));\n      }\n\n      return { arrayValue: { values } };\n    }\n  }\n  return { stringValue: tag.value };\n}\n\nfunction getOTLPStatus(tags: TraceKeyValuePair[]): SpanStatus | undefined {\n  let status = undefined;\n  const statusCodeTag = tags.find((t) => t.key === 'otel.status_code');\n  if (statusCodeTag) {\n    status = {\n      code: statusCodeTag.value,\n      message: tags.find((t) => t.key === 'otel_status_description')?.value,\n    };\n  }\n\n  return status;\n}\n\nfunction getOTLPEvents(logs: TraceLog[]): collectorTypes.opentelemetryProto.trace.v1.Span.Event[] | undefined {\n  if (!logs || !logs.length) {\n    return undefined;\n  }\n\n  let events: collectorTypes.opentelemetryProto.trace.v1.Span.Event[] = [];\n  for (const log of logs) {\n    let event: collectorTypes.opentelemetryProto.trace.v1.Span.Event = {\n      timeUnixNano: log.timestamp * 1000000,\n      attributes: [],\n      droppedAttributesCount: 0,\n      name: '',\n    };\n    for (const field of log.fields) {\n      event.attributes!.push({\n        key: field.key,\n        value: toAttributeValue(field),\n      });\n    }\n    events.push(event);\n  }\n  return events;\n}\n\nfunction getOTLPReferences(\n  references: TraceSpanReference[]\n): collectorTypes.opentelemetryProto.trace.v1.Span.Link[] | undefined {\n  if (!references || !references.length) {\n    return undefined;\n  }\n\n  let links: collectorTypes.opentelemetryProto.trace.v1.Span.Link[] = [];\n  for (const ref of references) {\n    let link: collectorTypes.opentelemetryProto.trace.v1.Span.Link = {\n      traceId: ref.traceID,\n      spanId: ref.spanID,\n      attributes: [],\n      droppedAttributesCount: 0,\n    };\n    if (ref.tags?.length) {\n      for (const tag of ref.tags) {\n        link.attributes?.push({\n          key: tag.key,\n          value: toAttributeValue(tag),\n        });\n      }\n    }\n    links.push(link);\n  }\n  return links;\n}\n\nexport function transformTrace(response: DataQueryResponse, nodeGraph = false): DataQueryResponse {\n  // We need to parse some of the fields which contain stringified json.\n  // Seems like we can't just map the values as the frame we got from backend has some default processing\n  // and will stringify the json back when we try to set it. So we create a new field and swap it instead.\n  const frame: DataFrame = response.data[0];\n\n  if (!frame) {\n    return emptyDataQueryResponse;\n  }\n\n  try {\n    parseJsonFields(frame);\n  } catch (error) {\n    console.error(error);\n    return { error: { message: 'Unable to parse trace response: ' + error }, data: [] };\n  }\n\n  let data = [...response.data];\n  if (nodeGraph) {\n    data.push(...createGraphFrames(frame));\n  }\n\n  return {\n    ...response,\n    data,\n  };\n}\n\n/**\n * Change fields which are json string into JS objects. Modifies the frame in place.\n */\nfunction parseJsonFields(frame: DataFrame) {\n  for (const fieldName of ['serviceTags', 'logs', 'tags', 'references']) {\n    const field = frame.fields.find((f) => f.name === fieldName);\n    if (field) {\n      const fieldIndex = frame.fields.indexOf(field);\n      const values = new ArrayVector();\n      const newField: Field = {\n        ...field,\n        values,\n        type: FieldType.other,\n      };\n\n      for (let i = 0; i < field.values.length; i++) {\n        const value = field.values.get(i);\n        values.set(i, value === '' ? undefined : JSON.parse(value));\n      }\n      frame.fields[fieldIndex] = newField;\n    }\n  }\n}\n\nexport type SearchResponse = {\n  traceID: string;\n  rootServiceName: string;\n  rootTraceName: string;\n  startTimeUnixNano: string;\n  durationMs: number;\n};\n\nexport function createTableFrameFromSearch(data: SearchResponse[], instanceSettings: DataSourceInstanceSettings) {\n  const frame = new MutableDataFrame({\n    fields: [\n      {\n        name: 'traceID',\n        type: FieldType.string,\n        config: {\n          unit: 'string',\n          displayNameFromDS: 'Trace ID',\n          links: [\n            {\n              title: 'Trace: ${__value.raw}',\n              url: '',\n              internal: {\n                datasourceUid: instanceSettings.uid,\n                datasourceName: instanceSettings.name,\n                query: {\n                  query: '${__value.raw}',\n                  queryType: 'traceId',\n                },\n              },\n            },\n          ],\n        },\n      },\n      { name: 'traceName', type: FieldType.string, config: { displayNameFromDS: 'Trace name' } },\n      { name: 'startTime', type: FieldType.string, config: { displayNameFromDS: 'Start time' } },\n      { name: 'duration', type: FieldType.number, config: { displayNameFromDS: 'Duration', unit: 'ms' } },\n    ],\n    meta: {\n      preferredVisualisationType: 'table',\n    },\n  });\n  if (!data?.length) {\n    return frame;\n  }\n  // Show the most recent traces\n  const traceData = data\n    .sort((a, b) => parseInt(b?.startTimeUnixNano!, 10) / 1000000 - parseInt(a?.startTimeUnixNano!, 10) / 1000000)\n    .map(transformToTraceData);\n\n  for (const trace of traceData) {\n    frame.add(trace);\n  }\n\n  return frame;\n}\n\nfunction transformToTraceData(data: SearchResponse) {\n  let traceName = '';\n  if (data.rootServiceName) {\n    traceName += data.rootServiceName + ' ';\n  }\n  if (data.rootTraceName) {\n    traceName += data.rootTraceName;\n  }\n\n  const traceStartTime = parseInt(data.startTimeUnixNano!, 10) / 1000000;\n\n  let startTime = dateTimeFormat(traceStartTime);\n\n  if (Math.abs(differenceInHours(new Date(traceStartTime), Date.now())) <= 1) {\n    startTime = formatDistance(new Date(traceStartTime), Date.now(), {\n      addSuffix: true,\n      includeSeconds: true,\n    });\n  }\n\n  return {\n    traceID: data.traceID,\n    startTime: startTime,\n    duration: data.durationMs,\n    traceName,\n  };\n}\n\nconst emptyDataQueryResponse = {\n  data: [\n    new MutableDataFrame({\n      fields: [\n        {\n          name: 'trace',\n          type: FieldType.trace,\n          values: [],\n        },\n      ],\n      meta: {\n        preferredVisualisationType: 'trace',\n        custom: {\n          traceFormat: 'otlp',\n        },\n      },\n    }),\n  ],\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}