{"ast":null,"code":"import { capitalize } from 'lodash';\nimport pluralize from 'pluralize';\nimport { LabelParamEditor } from '../components/LabelParamEditor';\nimport { PromVisualQueryOperationCategory } from '../types';\nexport function functionRendererLeft(model, def, innerExpr) {\n  const params = renderParams(model, def, innerExpr);\n  const str = model.id + '(';\n\n  if (innerExpr) {\n    params.push(innerExpr);\n  }\n\n  return str + params.join(', ') + ')';\n}\nexport function functionRendererRight(model, def, innerExpr) {\n  const params = renderParams(model, def, innerExpr);\n  const str = model.id + '(';\n\n  if (innerExpr) {\n    params.unshift(innerExpr);\n  }\n\n  return str + params.join(', ') + ')';\n}\n\nfunction rangeRendererWithParams(model, def, innerExpr, renderLeft) {\n  var _, _model$params;\n\n  if (def.params.length < 2) {\n    throw `Cannot render a function with params of length [${def.params.length}]`;\n  }\n\n  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m'; // Next frame the remaining parameters, but get rid of the first one because it's used to move the\n  // instant vector into a range vector.\n\n  const params = renderParams(Object.assign({}, model, {\n    params: model.params.slice(1)\n  }), Object.assign({}, def, {\n    params: def.params.slice(1),\n    defaultParams: def.defaultParams.slice(1)\n  }), innerExpr);\n  const str = model.id + '('; // Depending on the renderLeft variable, render parameters to the left or right\n  // renderLeft === true (renderLeft) => (param1, param2, rangeVector[...])\n  // renderLeft === false (renderRight) => (rangeVector[...], param1, param2)\n\n  if (innerExpr) {\n    renderLeft ? params.push(`${innerExpr}[${rangeVector}]`) : params.unshift(`${innerExpr}[${rangeVector}]`);\n  } // stick everything together\n\n\n  return str + params.join(', ') + ')';\n}\n\nexport function rangeRendererRightWithParams(model, def, innerExpr) {\n  return rangeRendererWithParams(model, def, innerExpr, false);\n}\nexport function rangeRendererLeftWithParams(model, def, innerExpr) {\n  return rangeRendererWithParams(model, def, innerExpr, true);\n}\n\nfunction renderParams(model, def, innerExpr) {\n  var _model$params2;\n\n  return ((_model$params2 = model.params) !== null && _model$params2 !== void 0 ? _model$params2 : []).map((value, index) => {\n    const paramDef = def.params[index];\n\n    if (paramDef.type === 'string') {\n      return '\"' + value + '\"';\n    }\n\n    return value;\n  });\n}\n\nexport function defaultAddOperationHandler(def, query) {\n  const newOperation = {\n    id: def.id,\n    params: def.defaultParams\n  };\n  return Object.assign({}, query, {\n    operations: [...query.operations, newOperation]\n  });\n}\nexport function getPromAndLokiOperationDisplayName(funcName) {\n  return capitalize(funcName.replace(/_/g, ' '));\n}\nexport function getOperationParamId(operationIndex, paramIndex) {\n  return `operations.${operationIndex}.param.${paramIndex}`;\n}\nexport function getRangeVectorParamDef(withRateInterval = false) {\n  const param = {\n    name: 'Range',\n    type: 'string',\n    options: [{\n      label: '$__interval',\n      value: '$__interval' // tooltip: 'Dynamic interval based on max data points, scrape and min interval',\n\n    }, {\n      label: '1m',\n      value: '1m'\n    }, {\n      label: '5m',\n      value: '5m'\n    }, {\n      label: '10m',\n      value: '10m'\n    }, {\n      label: '1h',\n      value: '1h'\n    }, {\n      label: '24h',\n      value: '24h'\n    }]\n  };\n\n  if (withRateInterval) {\n    param.options.unshift({\n      label: '$__rate_interval',\n      value: '$__rate_interval' // tooltip: 'Always above 4x scrape interval',\n\n    });\n  }\n\n  return param;\n}\n/**\n * This function is shared between Prometheus and Loki variants\n */\n\nexport function createAggregationOperation(name, overrides = {}) {\n  const operations = [Object.assign({\n    id: name,\n    name: getPromAndLokiOperationDisplayName(name),\n    params: [{\n      name: 'By label',\n      type: 'string',\n      restParam: true,\n      optional: true\n    }],\n    defaultParams: [],\n    alternativesKey: 'plain aggregations',\n    category: PromVisualQueryOperationCategory.Aggregations,\n    renderer: functionRendererLeft,\n    paramChangedHandler: getOnLabelAddedHandler(`__${name}_by`),\n    explainHandler: getAggregationExplainer(name, ''),\n    addOperationHandler: defaultAddOperationHandler\n  }, overrides), Object.assign({\n    id: `__${name}_by`,\n    name: `${getPromAndLokiOperationDisplayName(name)} by`,\n    params: [{\n      name: 'Label',\n      type: 'string',\n      restParam: true,\n      optional: true,\n      editor: LabelParamEditor\n    }],\n    defaultParams: [''],\n    alternativesKey: 'aggregations by',\n    category: PromVisualQueryOperationCategory.Aggregations,\n    renderer: getAggregationByRenderer(name),\n    paramChangedHandler: getLastLabelRemovedHandler(name),\n    explainHandler: getAggregationExplainer(name, 'by'),\n    addOperationHandler: defaultAddOperationHandler,\n    hideFromList: true\n  }, overrides), Object.assign({\n    id: `__${name}_without`,\n    name: `${getPromAndLokiOperationDisplayName(name)} without`,\n    params: [{\n      name: 'Label',\n      type: 'string',\n      restParam: true,\n      optional: true,\n      editor: LabelParamEditor\n    }],\n    defaultParams: [''],\n    alternativesKey: 'aggregations by',\n    category: PromVisualQueryOperationCategory.Aggregations,\n    renderer: getAggregationWithoutRenderer(name),\n    paramChangedHandler: getLastLabelRemovedHandler(name),\n    explainHandler: getAggregationExplainer(name, 'without'),\n    addOperationHandler: defaultAddOperationHandler,\n    hideFromList: true\n  }, overrides)];\n  return operations;\n}\nexport function createAggregationOperationWithParam(name, paramsDef, overrides = {}) {\n  const operations = createAggregationOperation(name, overrides);\n  operations[0].params.unshift(...paramsDef.params);\n  operations[1].params.unshift(...paramsDef.params);\n  operations[2].params.unshift(...paramsDef.params);\n  operations[0].defaultParams = paramsDef.defaultParams;\n  operations[1].defaultParams = [...paramsDef.defaultParams, ''];\n  operations[2].defaultParams = [...paramsDef.defaultParams, ''];\n  operations[1].renderer = getAggregationByRendererWithParameter(name);\n  operations[2].renderer = getAggregationByRendererWithParameter(name);\n  return operations;\n}\n\nfunction getAggregationByRenderer(aggregation) {\n  return function aggregationRenderer(model, def, innerExpr) {\n    return `${aggregation} by(${model.params.join(', ')}) (${innerExpr})`;\n  };\n}\n\nfunction getAggregationWithoutRenderer(aggregation) {\n  return function aggregationRenderer(model, def, innerExpr) {\n    return `${aggregation} without(${model.params.join(', ')}) (${innerExpr})`;\n  };\n}\n/**\n * Very simple poc implementation, needs to be modified to support all aggregation operators\n */\n\n\nfunction getAggregationExplainer(aggregationName, mode) {\n  return function aggregationExplainer(model) {\n    const labels = model.params.map(label => `\\`${label}\\``).join(' and ');\n    const labelWord = pluralize('label', model.params.length);\n\n    switch (mode) {\n      case 'by':\n        return `Calculates ${aggregationName} over dimensions while preserving ${labelWord} ${labels}.`;\n\n      case 'without':\n        return `Calculates ${aggregationName} over the dimensions ${labels}. All other labels are preserved.`;\n\n      default:\n        return `Calculates ${aggregationName} over the dimensions.`;\n    }\n  };\n}\n\nfunction getAggregationByRendererWithParameter(aggregation) {\n  return function aggregationRenderer(model, def, innerExpr) {\n    function mapType(p) {\n      if (typeof p === 'string') {\n        return `\\\"${p}\\\"`;\n      }\n\n      return p;\n    }\n\n    const params = model.params.slice(0, -1);\n    const restParams = model.params.slice(1);\n    return `${aggregation} by(${restParams.join(', ')}) (${params.map(mapType).join(', ')}, ${innerExpr})`;\n  };\n}\n/**\n * This function will transform operations without labels to their plan aggregation operation\n */\n\n\nfunction getLastLabelRemovedHandler(changeToOperationId) {\n  return function onParamChanged(index, op, def) {\n    // If definition has more params then is defined there are no optional rest params anymore.\n    // We then transform this operation into a different one\n    if (op.params.length < def.params.length) {\n      return Object.assign({}, op, {\n        id: changeToOperationId\n      });\n    }\n\n    return op;\n  };\n}\n\nfunction getOnLabelAddedHandler(changeToOperationId) {\n  return function onParamChanged(index, op, def) {\n    // Check if we actually have the label param. As it's optional the aggregation can have one less, which is the\n    // case of just simple aggregation without label. When user adds the label it now has the same number of params\n    // as it's definition, and now we can change it to it's `_by` variant.\n    if (op.params.length === def.params.length) {\n      return Object.assign({}, op, {\n        id: changeToOperationId\n      });\n    }\n\n    return op;\n  };\n}","map":{"version":3,"names":["capitalize","pluralize","LabelParamEditor","PromVisualQueryOperationCategory","functionRendererLeft","model","def","innerExpr","params","renderParams","str","id","push","join","functionRendererRight","unshift","rangeRendererWithParams","renderLeft","length","rangeVector","slice","defaultParams","rangeRendererRightWithParams","rangeRendererLeftWithParams","map","value","index","paramDef","type","defaultAddOperationHandler","query","newOperation","operations","getPromAndLokiOperationDisplayName","funcName","replace","getOperationParamId","operationIndex","paramIndex","getRangeVectorParamDef","withRateInterval","param","name","options","label","createAggregationOperation","overrides","restParam","optional","alternativesKey","category","Aggregations","renderer","paramChangedHandler","getOnLabelAddedHandler","explainHandler","getAggregationExplainer","addOperationHandler","editor","getAggregationByRenderer","getLastLabelRemovedHandler","hideFromList","getAggregationWithoutRenderer","createAggregationOperationWithParam","paramsDef","getAggregationByRendererWithParameter","aggregation","aggregationRenderer","aggregationName","mode","aggregationExplainer","labels","labelWord","mapType","p","restParams","changeToOperationId","onParamChanged","op"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts"],"sourcesContent":["import { capitalize } from 'lodash';\nimport pluralize from 'pluralize';\n\nimport { SelectableValue } from '@grafana/data/src';\n\nimport { LabelParamEditor } from '../components/LabelParamEditor';\nimport { PromVisualQueryOperationCategory } from '../types';\n\nimport {\n  QueryBuilderOperation,\n  QueryBuilderOperationDef,\n  QueryBuilderOperationParamDef,\n  QueryBuilderOperationParamValue,\n  QueryWithOperations,\n} from './types';\n\nexport function functionRendererLeft(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n  const params = renderParams(model, def, innerExpr);\n  const str = model.id + '(';\n\n  if (innerExpr) {\n    params.push(innerExpr);\n  }\n\n  return str + params.join(', ') + ')';\n}\n\nexport function functionRendererRight(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n  const params = renderParams(model, def, innerExpr);\n  const str = model.id + '(';\n\n  if (innerExpr) {\n    params.unshift(innerExpr);\n  }\n\n  return str + params.join(', ') + ')';\n}\n\nfunction rangeRendererWithParams(\n  model: QueryBuilderOperation,\n  def: QueryBuilderOperationDef,\n  innerExpr: string,\n  renderLeft: boolean\n) {\n  if (def.params.length < 2) {\n    throw `Cannot render a function with params of length [${def.params.length}]`;\n  }\n\n  let rangeVector = (model.params ?? [])[0] ?? '5m';\n\n  // Next frame the remaining parameters, but get rid of the first one because it's used to move the\n  // instant vector into a range vector.\n  const params = renderParams(\n    {\n      ...model,\n      params: model.params.slice(1),\n    },\n    {\n      ...def,\n      params: def.params.slice(1),\n      defaultParams: def.defaultParams.slice(1),\n    },\n    innerExpr\n  );\n\n  const str = model.id + '(';\n\n  // Depending on the renderLeft variable, render parameters to the left or right\n  // renderLeft === true (renderLeft) => (param1, param2, rangeVector[...])\n  // renderLeft === false (renderRight) => (rangeVector[...], param1, param2)\n  if (innerExpr) {\n    renderLeft ? params.push(`${innerExpr}[${rangeVector}]`) : params.unshift(`${innerExpr}[${rangeVector}]`);\n  }\n\n  // stick everything together\n  return str + params.join(', ') + ')';\n}\n\nexport function rangeRendererRightWithParams(\n  model: QueryBuilderOperation,\n  def: QueryBuilderOperationDef,\n  innerExpr: string\n) {\n  return rangeRendererWithParams(model, def, innerExpr, false);\n}\n\nexport function rangeRendererLeftWithParams(\n  model: QueryBuilderOperation,\n  def: QueryBuilderOperationDef,\n  innerExpr: string\n) {\n  return rangeRendererWithParams(model, def, innerExpr, true);\n}\n\nfunction renderParams(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n  return (model.params ?? []).map((value, index) => {\n    const paramDef = def.params[index];\n    if (paramDef.type === 'string') {\n      return '\"' + value + '\"';\n    }\n\n    return value;\n  });\n}\n\nexport function defaultAddOperationHandler<T extends QueryWithOperations>(def: QueryBuilderOperationDef, query: T) {\n  const newOperation: QueryBuilderOperation = {\n    id: def.id,\n    params: def.defaultParams,\n  };\n\n  return {\n    ...query,\n    operations: [...query.operations, newOperation],\n  };\n}\n\nexport function getPromAndLokiOperationDisplayName(funcName: string) {\n  return capitalize(funcName.replace(/_/g, ' '));\n}\n\nexport function getOperationParamId(operationIndex: number, paramIndex: number) {\n  return `operations.${operationIndex}.param.${paramIndex}`;\n}\n\nexport function getRangeVectorParamDef(withRateInterval = false): QueryBuilderOperationParamDef {\n  const param: QueryBuilderOperationParamDef = {\n    name: 'Range',\n    type: 'string',\n    options: [\n      {\n        label: '$__interval',\n        value: '$__interval',\n        // tooltip: 'Dynamic interval based on max data points, scrape and min interval',\n      },\n      { label: '1m', value: '1m' },\n      { label: '5m', value: '5m' },\n      { label: '10m', value: '10m' },\n      { label: '1h', value: '1h' },\n      { label: '24h', value: '24h' },\n    ],\n  };\n\n  if (withRateInterval) {\n    (param.options as Array<SelectableValue<string>>).unshift({\n      label: '$__rate_interval',\n      value: '$__rate_interval',\n      // tooltip: 'Always above 4x scrape interval',\n    });\n  }\n\n  return param;\n}\n\n/**\n * This function is shared between Prometheus and Loki variants\n */\nexport function createAggregationOperation<T extends QueryWithOperations>(\n  name: string,\n  overrides: Partial<QueryBuilderOperationDef> = {}\n): QueryBuilderOperationDef[] {\n  const operations: QueryBuilderOperationDef[] = [\n    {\n      id: name,\n      name: getPromAndLokiOperationDisplayName(name),\n      params: [\n        {\n          name: 'By label',\n          type: 'string',\n          restParam: true,\n          optional: true,\n        },\n      ],\n      defaultParams: [],\n      alternativesKey: 'plain aggregations',\n      category: PromVisualQueryOperationCategory.Aggregations,\n      renderer: functionRendererLeft,\n      paramChangedHandler: getOnLabelAddedHandler(`__${name}_by`),\n      explainHandler: getAggregationExplainer(name, ''),\n      addOperationHandler: defaultAddOperationHandler,\n      ...overrides,\n    },\n    {\n      id: `__${name}_by`,\n      name: `${getPromAndLokiOperationDisplayName(name)} by`,\n      params: [\n        {\n          name: 'Label',\n          type: 'string',\n          restParam: true,\n          optional: true,\n          editor: LabelParamEditor,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'aggregations by',\n      category: PromVisualQueryOperationCategory.Aggregations,\n      renderer: getAggregationByRenderer(name),\n      paramChangedHandler: getLastLabelRemovedHandler(name),\n      explainHandler: getAggregationExplainer(name, 'by'),\n      addOperationHandler: defaultAddOperationHandler,\n      hideFromList: true,\n      ...overrides,\n    },\n    {\n      id: `__${name}_without`,\n      name: `${getPromAndLokiOperationDisplayName(name)} without`,\n      params: [\n        {\n          name: 'Label',\n          type: 'string',\n          restParam: true,\n          optional: true,\n          editor: LabelParamEditor,\n        },\n      ],\n      defaultParams: [''],\n      alternativesKey: 'aggregations by',\n      category: PromVisualQueryOperationCategory.Aggregations,\n      renderer: getAggregationWithoutRenderer(name),\n      paramChangedHandler: getLastLabelRemovedHandler(name),\n      explainHandler: getAggregationExplainer(name, 'without'),\n      addOperationHandler: defaultAddOperationHandler,\n      hideFromList: true,\n      ...overrides,\n    },\n  ];\n\n  return operations;\n}\n\nexport function createAggregationOperationWithParam(\n  name: string,\n  paramsDef: { params: QueryBuilderOperationParamDef[]; defaultParams: QueryBuilderOperationParamValue[] },\n  overrides: Partial<QueryBuilderOperationDef> = {}\n): QueryBuilderOperationDef[] {\n  const operations = createAggregationOperation(name, overrides);\n  operations[0].params.unshift(...paramsDef.params);\n  operations[1].params.unshift(...paramsDef.params);\n  operations[2].params.unshift(...paramsDef.params);\n  operations[0].defaultParams = paramsDef.defaultParams;\n  operations[1].defaultParams = [...paramsDef.defaultParams, ''];\n  operations[2].defaultParams = [...paramsDef.defaultParams, ''];\n  operations[1].renderer = getAggregationByRendererWithParameter(name);\n  operations[2].renderer = getAggregationByRendererWithParameter(name);\n  return operations;\n}\n\nfunction getAggregationByRenderer(aggregation: string) {\n  return function aggregationRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n    return `${aggregation} by(${model.params.join(', ')}) (${innerExpr})`;\n  };\n}\n\nfunction getAggregationWithoutRenderer(aggregation: string) {\n  return function aggregationRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n    return `${aggregation} without(${model.params.join(', ')}) (${innerExpr})`;\n  };\n}\n\n/**\n * Very simple poc implementation, needs to be modified to support all aggregation operators\n */\nfunction getAggregationExplainer(aggregationName: string, mode: 'by' | 'without' | '') {\n  return function aggregationExplainer(model: QueryBuilderOperation) {\n    const labels = model.params.map((label) => `\\`${label}\\``).join(' and ');\n    const labelWord = pluralize('label', model.params.length);\n\n    switch (mode) {\n      case 'by':\n        return `Calculates ${aggregationName} over dimensions while preserving ${labelWord} ${labels}.`;\n      case 'without':\n        return `Calculates ${aggregationName} over the dimensions ${labels}. All other labels are preserved.`;\n      default:\n        return `Calculates ${aggregationName} over the dimensions.`;\n    }\n  };\n}\n\nfunction getAggregationByRendererWithParameter(aggregation: string) {\n  return function aggregationRenderer(model: QueryBuilderOperation, def: QueryBuilderOperationDef, innerExpr: string) {\n    function mapType(p: QueryBuilderOperationParamValue) {\n      if (typeof p === 'string') {\n        return `\\\"${p}\\\"`;\n      }\n      return p;\n    }\n    const params = model.params.slice(0, -1);\n    const restParams = model.params.slice(1);\n    return `${aggregation} by(${restParams.join(', ')}) (${params.map(mapType).join(', ')}, ${innerExpr})`;\n  };\n}\n\n/**\n * This function will transform operations without labels to their plan aggregation operation\n */\nfunction getLastLabelRemovedHandler(changeToOperationId: string) {\n  return function onParamChanged(index: number, op: QueryBuilderOperation, def: QueryBuilderOperationDef) {\n    // If definition has more params then is defined there are no optional rest params anymore.\n    // We then transform this operation into a different one\n    if (op.params.length < def.params.length) {\n      return {\n        ...op,\n        id: changeToOperationId,\n      };\n    }\n\n    return op;\n  };\n}\n\nfunction getOnLabelAddedHandler(changeToOperationId: string) {\n  return function onParamChanged(index: number, op: QueryBuilderOperation, def: QueryBuilderOperationDef) {\n    // Check if we actually have the label param. As it's optional the aggregation can have one less, which is the\n    // case of just simple aggregation without label. When user adds the label it now has the same number of params\n    // as it's definition, and now we can change it to it's `_by` variant.\n    if (op.params.length === def.params.length) {\n      return {\n        ...op,\n        id: changeToOperationId,\n      };\n    }\n    return op;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}