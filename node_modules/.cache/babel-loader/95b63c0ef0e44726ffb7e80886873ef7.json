{"ast":null,"code":"import { useState, useEffect } from 'react';\nimport useAsync from 'react-use/lib/useAsync';\nimport { toDataFrame, FieldCache, LogsSortOrder } from '@grafana/data';\nexport const getRowContexts = async (getRowContext, row, limit, logsSortOrder) => {\n  const promises = [getRowContext(row, {\n    limit\n  }), getRowContext(row, {\n    // The start time is inclusive so we will get the one row we are using as context entry\n    limit: limit + 1,\n    direction: 'FORWARD'\n  })];\n  const results = await Promise.all(promises.map(p => p.catch(e => e)));\n  const data = results.map(result => {\n    const dataResult = result;\n\n    if (!dataResult.data) {\n      return [];\n    }\n\n    const data = [];\n\n    for (let index = 0; index < dataResult.data.length; index++) {\n      const dataFrame = toDataFrame(dataResult.data[index]);\n      const fieldCache = new FieldCache(dataFrame);\n      const timestampField = fieldCache.getFieldByName('ts');\n      const idField = fieldCache.getFieldByName('id');\n\n      for (let fieldIndex = 0; fieldIndex < timestampField.values.length; fieldIndex++) {\n        // TODO: this filtering is datasource dependant so it will make sense to move it there so the API is\n        //  to return correct list of lines handling inclusive ranges or how to filter the correct line on the\n        //  datasource.\n        // Filter out the row that is the one used as a focal point for the context as we will get it in one of the\n        // requests.\n        if (idField) {\n          // For Loki this means we filter only the one row. Issue is we could have other rows logged at the same\n          // ns which came before but they come in the response that search for logs after. This means right now\n          // we will show those as if they came after. This is not strictly correct but seems better than losing them\n          // and making this correct would mean quite a bit of complexity to shuffle things around and messing up\n          //counts.\n          if (idField.values.get(fieldIndex) === row.uid) {\n            continue;\n          }\n        } else {\n          // Fallback to timestamp. This should not happen right now as this feature is implemented only for loki\n          // and that has ID. Later this branch could be used in other DS but mind that this could also filter out\n          // logs which were logged in the same timestamp and that can be a problem depending on the precision.\n          if (parseInt(timestampField.values.get(fieldIndex), 10) === row.timeEpochMs) {\n            continue;\n          }\n        }\n\n        const lineField = dataFrame.fields.filter(field => field.name === 'line')[0];\n        const line = lineField.values.get(fieldIndex); // assuming that both fields have same length\n\n        data.push(line);\n      }\n    }\n\n    return logsSortOrder === LogsSortOrder.Ascending ? data.reverse() : data;\n  });\n  const errors = results.map(result => {\n    const errorResult = result;\n\n    if (!errorResult.message) {\n      return '';\n    }\n\n    return errorResult.message;\n  });\n  return {\n    data: logsSortOrder === LogsSortOrder.Ascending ? data.reverse() : data,\n    errors: logsSortOrder === LogsSortOrder.Ascending ? errors.reverse() : errors\n  };\n};\nexport const LogRowContextProvider = ({\n  getRowContext,\n  row,\n  children,\n  logsSortOrder\n}) => {\n  // React Hook that creates a number state value called limit to component state and a setter function called setLimit\n  // The initial value for limit is 10\n  // Used for the number of rows to retrieve from backend from a specific point in time\n  const [limit, setLimit] = useState(10); // React Hook that creates an object state value called result to component state and a setter function called setResult\n  // The initial value for result is null\n  // Used for sorting the response from backend\n\n  const [result, setResult] = useState(null); // React Hook that creates an object state value called hasMoreContextRows to component state and a setter function called setHasMoreContextRows\n  // The initial value for hasMoreContextRows is {before: true, after: true}\n  // Used for indicating in UI if there are more rows to load in a given direction\n\n  const [hasMoreContextRows, setHasMoreContextRows] = useState({\n    before: true,\n    after: true\n  }); // React Hook that resolves two promises every time the limit prop changes\n  // First promise fetches limit number of rows backwards in time from a specific point in time\n  // Second promise fetches limit number of rows forwards in time from a specific point in time\n\n  const {\n    value\n  } = useAsync(async () => {\n    return await getRowContexts(getRowContext, row, limit, logsSortOrder); // Moved it to a separate function for debugging purposes\n  }, [limit]); // React Hook that performs a side effect every time the value (from useAsync hook) prop changes\n  // The side effect changes the result state with the response from the useAsync hook\n  // The side effect changes the hasMoreContextRows state if there are more context rows before or after the current result\n\n  useEffect(() => {\n    if (value) {\n      setResult(currentResult => {\n        let hasMoreLogsBefore = true,\n            hasMoreLogsAfter = true;\n        const currentResultBefore = currentResult === null || currentResult === void 0 ? void 0 : currentResult.data[0];\n        const currentResultAfter = currentResult === null || currentResult === void 0 ? void 0 : currentResult.data[1];\n        const valueBefore = value.data[0];\n        const valueAfter = value.data[1]; // checks if there are more log rows in a given direction\n        // if after fetching additional rows the length of result is the same,\n        // we can assume there are no logs in that direction within a given time range\n\n        if (currentResult && (!valueBefore || currentResultBefore.length === valueBefore.length)) {\n          hasMoreLogsBefore = false;\n        }\n\n        if (currentResult && (!valueAfter || currentResultAfter.length === valueAfter.length)) {\n          hasMoreLogsAfter = false;\n        }\n\n        setHasMoreContextRows({\n          before: hasMoreLogsBefore,\n          after: hasMoreLogsAfter\n        });\n        return value;\n      });\n    }\n  }, [value]);\n  return children({\n    result: {\n      before: result ? result.data[0] : [],\n      after: result ? result.data[1] : []\n    },\n    errors: {\n      before: result ? result.errors[0] : undefined,\n      after: result ? result.errors[1] : undefined\n    },\n    hasMoreContextRows,\n    updateLimit: () => setLimit(limit + 10),\n    limit\n  });\n};","map":{"version":3,"names":["useState","useEffect","useAsync","toDataFrame","FieldCache","LogsSortOrder","getRowContexts","getRowContext","row","limit","logsSortOrder","promises","direction","results","Promise","all","map","p","catch","e","data","result","dataResult","index","length","dataFrame","fieldCache","timestampField","getFieldByName","idField","fieldIndex","values","get","uid","parseInt","timeEpochMs","lineField","fields","filter","field","name","line","push","Ascending","reverse","errors","errorResult","message","LogRowContextProvider","children","setLimit","setResult","hasMoreContextRows","setHasMoreContextRows","before","after","value","currentResult","hasMoreLogsBefore","hasMoreLogsAfter","currentResultBefore","currentResultAfter","valueBefore","valueAfter","undefined","updateLimit"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/Logs/LogRowContextProvider.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport useAsync from 'react-use/lib/useAsync';\n\nimport {\n  LogRowModel,\n  toDataFrame,\n  Field,\n  FieldCache,\n  LogsSortOrder,\n  DataQueryResponse,\n  DataQueryError,\n} from '@grafana/data';\n\nexport interface RowContextOptions {\n  direction?: 'BACKWARD' | 'FORWARD';\n  limit?: number;\n}\n\nexport interface LogRowContextRows {\n  before?: string[];\n  after?: string[];\n}\nexport interface LogRowContextQueryErrors {\n  before?: string;\n  after?: string;\n}\n\nexport interface HasMoreContextRows {\n  before: boolean;\n  after: boolean;\n}\n\ninterface ResultType {\n  data: string[][];\n  errors: string[];\n}\n\ninterface LogRowContextProviderProps {\n  row: LogRowModel;\n  logsSortOrder?: LogsSortOrder | null;\n  getRowContext: (row: LogRowModel, options?: RowContextOptions) => Promise<DataQueryResponse>;\n  children: (props: {\n    result: LogRowContextRows;\n    errors: LogRowContextQueryErrors;\n    hasMoreContextRows: HasMoreContextRows;\n    updateLimit: () => void;\n    limit: number;\n  }) => JSX.Element;\n}\n\nexport const getRowContexts = async (\n  getRowContext: (row: LogRowModel, options?: RowContextOptions) => Promise<DataQueryResponse>,\n  row: LogRowModel,\n  limit: number,\n  logsSortOrder?: LogsSortOrder | null\n) => {\n  const promises = [\n    getRowContext(row, {\n      limit,\n    }),\n    getRowContext(row, {\n      // The start time is inclusive so we will get the one row we are using as context entry\n      limit: limit + 1,\n      direction: 'FORWARD',\n    }),\n  ];\n\n  const results: Array<DataQueryResponse | DataQueryError> = await Promise.all(promises.map((p) => p.catch((e) => e)));\n\n  const data = results.map((result) => {\n    const dataResult: DataQueryResponse = result as DataQueryResponse;\n    if (!dataResult.data) {\n      return [];\n    }\n\n    const data: any[] = [];\n    for (let index = 0; index < dataResult.data.length; index++) {\n      const dataFrame = toDataFrame(dataResult.data[index]);\n      const fieldCache = new FieldCache(dataFrame);\n      const timestampField: Field<string> = fieldCache.getFieldByName('ts')!;\n      const idField: Field<string> | undefined = fieldCache.getFieldByName('id');\n\n      for (let fieldIndex = 0; fieldIndex < timestampField.values.length; fieldIndex++) {\n        // TODO: this filtering is datasource dependant so it will make sense to move it there so the API is\n        //  to return correct list of lines handling inclusive ranges or how to filter the correct line on the\n        //  datasource.\n\n        // Filter out the row that is the one used as a focal point for the context as we will get it in one of the\n        // requests.\n        if (idField) {\n          // For Loki this means we filter only the one row. Issue is we could have other rows logged at the same\n          // ns which came before but they come in the response that search for logs after. This means right now\n          // we will show those as if they came after. This is not strictly correct but seems better than losing them\n          // and making this correct would mean quite a bit of complexity to shuffle things around and messing up\n          //counts.\n          if (idField.values.get(fieldIndex) === row.uid) {\n            continue;\n          }\n        } else {\n          // Fallback to timestamp. This should not happen right now as this feature is implemented only for loki\n          // and that has ID. Later this branch could be used in other DS but mind that this could also filter out\n          // logs which were logged in the same timestamp and that can be a problem depending on the precision.\n          if (parseInt(timestampField.values.get(fieldIndex), 10) === row.timeEpochMs) {\n            continue;\n          }\n        }\n\n        const lineField: Field<string> = dataFrame.fields.filter((field) => field.name === 'line')[0];\n        const line = lineField.values.get(fieldIndex); // assuming that both fields have same length\n\n        data.push(line);\n      }\n    }\n\n    return logsSortOrder === LogsSortOrder.Ascending ? data.reverse() : data;\n  });\n\n  const errors = results.map((result) => {\n    const errorResult: DataQueryError = result as DataQueryError;\n    if (!errorResult.message) {\n      return '';\n    }\n\n    return errorResult.message;\n  });\n\n  return {\n    data: logsSortOrder === LogsSortOrder.Ascending ? data.reverse() : data,\n    errors: logsSortOrder === LogsSortOrder.Ascending ? errors.reverse() : errors,\n  };\n};\n\nexport const LogRowContextProvider: React.FunctionComponent<LogRowContextProviderProps> = ({\n  getRowContext,\n  row,\n  children,\n  logsSortOrder,\n}) => {\n  // React Hook that creates a number state value called limit to component state and a setter function called setLimit\n  // The initial value for limit is 10\n  // Used for the number of rows to retrieve from backend from a specific point in time\n  const [limit, setLimit] = useState(10);\n\n  // React Hook that creates an object state value called result to component state and a setter function called setResult\n  // The initial value for result is null\n  // Used for sorting the response from backend\n  const [result, setResult] = useState<ResultType>(null as any as ResultType);\n\n  // React Hook that creates an object state value called hasMoreContextRows to component state and a setter function called setHasMoreContextRows\n  // The initial value for hasMoreContextRows is {before: true, after: true}\n  // Used for indicating in UI if there are more rows to load in a given direction\n  const [hasMoreContextRows, setHasMoreContextRows] = useState({\n    before: true,\n    after: true,\n  });\n\n  // React Hook that resolves two promises every time the limit prop changes\n  // First promise fetches limit number of rows backwards in time from a specific point in time\n  // Second promise fetches limit number of rows forwards in time from a specific point in time\n  const { value } = useAsync(async () => {\n    return await getRowContexts(getRowContext, row, limit, logsSortOrder); // Moved it to a separate function for debugging purposes\n  }, [limit]);\n\n  // React Hook that performs a side effect every time the value (from useAsync hook) prop changes\n  // The side effect changes the result state with the response from the useAsync hook\n  // The side effect changes the hasMoreContextRows state if there are more context rows before or after the current result\n  useEffect(() => {\n    if (value) {\n      setResult((currentResult: any) => {\n        let hasMoreLogsBefore = true,\n          hasMoreLogsAfter = true;\n\n        const currentResultBefore = currentResult?.data[0];\n        const currentResultAfter = currentResult?.data[1];\n        const valueBefore = value.data[0];\n        const valueAfter = value.data[1];\n\n        // checks if there are more log rows in a given direction\n        // if after fetching additional rows the length of result is the same,\n        // we can assume there are no logs in that direction within a given time range\n        if (currentResult && (!valueBefore || currentResultBefore.length === valueBefore.length)) {\n          hasMoreLogsBefore = false;\n        }\n\n        if (currentResult && (!valueAfter || currentResultAfter.length === valueAfter.length)) {\n          hasMoreLogsAfter = false;\n        }\n\n        setHasMoreContextRows({\n          before: hasMoreLogsBefore,\n          after: hasMoreLogsAfter,\n        });\n\n        return value;\n      });\n    }\n  }, [value]);\n\n  return children({\n    result: {\n      before: result ? result.data[0] : [],\n      after: result ? result.data[1] : [],\n    },\n    errors: {\n      before: result ? result.errors[0] : undefined,\n      after: result ? result.errors[1] : undefined,\n    },\n    hasMoreContextRows,\n    updateLimit: () => setLimit(limit + 10),\n    limit,\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}