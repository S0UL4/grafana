{"ast":null,"code":"import { contextSrv } from 'app/core/services/context_srv';\nimport { getRulesPermissions } from '../utils/access-control';\nimport { isGrafanaRulerRule } from '../utils/rules';\nimport { useFolder } from './useFolder';\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\nexport function useIsRuleEditable(rulesSourceName, rule) {\n  var _dataSources$rulesSou, _dataSources$rulesSou2, _dataSources$rulesSou3;\n\n  const dataSources = useUnifiedAlertingSelector(state => state.dataSources);\n  const folderUID = rule && isGrafanaRulerRule(rule) ? rule.grafana_alert.namespace_uid : undefined;\n  const rulePermission = getRulesPermissions(rulesSourceName);\n  const {\n    folder,\n    loading\n  } = useFolder(folderUID);\n\n  if (!rule) {\n    return {\n      isEditable: false,\n      isRemovable: false,\n      loading: false\n    };\n  } // Grafana rules can be edited if user can edit the folder they're in\n  // When RBAC is disabled access to a folder is the only requirement for managing rules\n  // When RBAC is enabled the appropriate alerting permissions need to be met\n\n\n  if (isGrafanaRulerRule(rule)) {\n    var _folder$canSave, _folder$canSave2;\n\n    if (!folderUID) {\n      throw new Error(`Rule ${rule.grafana_alert.title} does not have a folder uid, cannot determine if it is editable.`);\n    }\n\n    const canEditGrafanaRules = contextSrv.hasAccess(rulePermission.update, (_folder$canSave = folder === null || folder === void 0 ? void 0 : folder.canSave) !== null && _folder$canSave !== void 0 ? _folder$canSave : false);\n    const canRemoveGrafanaRules = contextSrv.hasAccess(rulePermission.delete, (_folder$canSave2 = folder === null || folder === void 0 ? void 0 : folder.canSave) !== null && _folder$canSave2 !== void 0 ? _folder$canSave2 : false);\n    return {\n      isEditable: canEditGrafanaRules,\n      isRemovable: canRemoveGrafanaRules,\n      loading\n    };\n  } // prom rules are only editable by users with Editor role and only if rules source supports editing\n\n\n  const isRulerAvailable = Boolean((_dataSources$rulesSou = dataSources[rulesSourceName]) === null || _dataSources$rulesSou === void 0 ? void 0 : (_dataSources$rulesSou2 = _dataSources$rulesSou.result) === null || _dataSources$rulesSou2 === void 0 ? void 0 : _dataSources$rulesSou2.rulerConfig);\n  const canEditCloudRules = contextSrv.hasAccess(rulePermission.update, contextSrv.isEditor);\n  const canRemoveCloudRules = contextSrv.hasAccess(rulePermission.delete, contextSrv.isEditor);\n  return {\n    isEditable: canEditCloudRules && isRulerAvailable,\n    isRemovable: canRemoveCloudRules && isRulerAvailable,\n    loading: (_dataSources$rulesSou3 = dataSources[rulesSourceName]) === null || _dataSources$rulesSou3 === void 0 ? void 0 : _dataSources$rulesSou3.loading\n  };\n}","map":{"version":3,"names":["contextSrv","getRulesPermissions","isGrafanaRulerRule","useFolder","useUnifiedAlertingSelector","useIsRuleEditable","rulesSourceName","rule","dataSources","state","folderUID","grafana_alert","namespace_uid","undefined","rulePermission","folder","loading","isEditable","isRemovable","Error","title","canEditGrafanaRules","hasAccess","update","canSave","canRemoveGrafanaRules","delete","isRulerAvailable","Boolean","result","rulerConfig","canEditCloudRules","isEditor","canRemoveCloudRules"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/hooks/useIsRuleEditable.ts"],"sourcesContent":["import { contextSrv } from 'app/core/services/context_srv';\nimport { RulerRuleDTO } from 'app/types/unified-alerting-dto';\n\nimport { getRulesPermissions } from '../utils/access-control';\nimport { isGrafanaRulerRule } from '../utils/rules';\n\nimport { useFolder } from './useFolder';\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\ninterface ResultBag {\n  isEditable?: boolean;\n  isRemovable?: boolean;\n  loading: boolean;\n}\n\nexport function useIsRuleEditable(rulesSourceName: string, rule?: RulerRuleDTO): ResultBag {\n  const dataSources = useUnifiedAlertingSelector((state) => state.dataSources);\n  const folderUID = rule && isGrafanaRulerRule(rule) ? rule.grafana_alert.namespace_uid : undefined;\n\n  const rulePermission = getRulesPermissions(rulesSourceName);\n\n  const { folder, loading } = useFolder(folderUID);\n\n  if (!rule) {\n    return { isEditable: false, isRemovable: false, loading: false };\n  }\n\n  // Grafana rules can be edited if user can edit the folder they're in\n  // When RBAC is disabled access to a folder is the only requirement for managing rules\n  // When RBAC is enabled the appropriate alerting permissions need to be met\n  if (isGrafanaRulerRule(rule)) {\n    if (!folderUID) {\n      throw new Error(\n        `Rule ${rule.grafana_alert.title} does not have a folder uid, cannot determine if it is editable.`\n      );\n    }\n\n    const canEditGrafanaRules = contextSrv.hasAccess(rulePermission.update, folder?.canSave ?? false);\n    const canRemoveGrafanaRules = contextSrv.hasAccess(rulePermission.delete, folder?.canSave ?? false);\n\n    return {\n      isEditable: canEditGrafanaRules,\n      isRemovable: canRemoveGrafanaRules,\n      loading,\n    };\n  }\n\n  // prom rules are only editable by users with Editor role and only if rules source supports editing\n  const isRulerAvailable = Boolean(dataSources[rulesSourceName]?.result?.rulerConfig);\n  const canEditCloudRules = contextSrv.hasAccess(rulePermission.update, contextSrv.isEditor);\n  const canRemoveCloudRules = contextSrv.hasAccess(rulePermission.delete, contextSrv.isEditor);\n\n  return {\n    isEditable: canEditCloudRules && isRulerAvailable,\n    isRemovable: canRemoveCloudRules && isRulerAvailable,\n    loading: dataSources[rulesSourceName]?.loading,\n  };\n}\n"],"mappings":"AAAA,SAASA,UAAT,QAA2B,+BAA3B;AAGA,SAASC,mBAAT,QAAoC,yBAApC;AACA,SAASC,kBAAT,QAAmC,gBAAnC;AAEA,SAASC,SAAT,QAA0B,aAA1B;AACA,SAASC,0BAAT,QAA2C,8BAA3C;AAQA,OAAO,SAASC,iBAAT,CAA2BC,eAA3B,EAAoDC,IAApD,EAAoF;EAAA;;EACzF,MAAMC,WAAW,GAAGJ,0BAA0B,CAAEK,KAAD,IAAWA,KAAK,CAACD,WAAlB,CAA9C;EACA,MAAME,SAAS,GAAGH,IAAI,IAAIL,kBAAkB,CAACK,IAAD,CAA1B,GAAmCA,IAAI,CAACI,aAAL,CAAmBC,aAAtD,GAAsEC,SAAxF;EAEA,MAAMC,cAAc,GAAGb,mBAAmB,CAACK,eAAD,CAA1C;EAEA,MAAM;IAAES,MAAF;IAAUC;EAAV,IAAsBb,SAAS,CAACO,SAAD,CAArC;;EAEA,IAAI,CAACH,IAAL,EAAW;IACT,OAAO;MAAEU,UAAU,EAAE,KAAd;MAAqBC,WAAW,EAAE,KAAlC;MAAyCF,OAAO,EAAE;IAAlD,CAAP;EACD,CAVwF,CAYzF;EACA;EACA;;;EACA,IAAId,kBAAkB,CAACK,IAAD,CAAtB,EAA8B;IAAA;;IAC5B,IAAI,CAACG,SAAL,EAAgB;MACd,MAAM,IAAIS,KAAJ,CACH,QAAOZ,IAAI,CAACI,aAAL,CAAmBS,KAAM,kEAD7B,CAAN;IAGD;;IAED,MAAMC,mBAAmB,GAAGrB,UAAU,CAACsB,SAAX,CAAqBR,cAAc,CAACS,MAApC,qBAA4CR,MAA5C,aAA4CA,MAA5C,uBAA4CA,MAAM,CAAES,OAApD,6DAA+D,KAA/D,CAA5B;IACA,MAAMC,qBAAqB,GAAGzB,UAAU,CAACsB,SAAX,CAAqBR,cAAc,CAACY,MAApC,sBAA4CX,MAA5C,aAA4CA,MAA5C,uBAA4CA,MAAM,CAAES,OAApD,+DAA+D,KAA/D,CAA9B;IAEA,OAAO;MACLP,UAAU,EAAEI,mBADP;MAELH,WAAW,EAAEO,qBAFR;MAGLT;IAHK,CAAP;EAKD,CA9BwF,CAgCzF;;;EACA,MAAMW,gBAAgB,GAAGC,OAAO,0BAACpB,WAAW,CAACF,eAAD,CAAZ,oFAAC,sBAA8BuB,MAA/B,2DAAC,uBAAsCC,WAAvC,CAAhC;EACA,MAAMC,iBAAiB,GAAG/B,UAAU,CAACsB,SAAX,CAAqBR,cAAc,CAACS,MAApC,EAA4CvB,UAAU,CAACgC,QAAvD,CAA1B;EACA,MAAMC,mBAAmB,GAAGjC,UAAU,CAACsB,SAAX,CAAqBR,cAAc,CAACY,MAApC,EAA4C1B,UAAU,CAACgC,QAAvD,CAA5B;EAEA,OAAO;IACLf,UAAU,EAAEc,iBAAiB,IAAIJ,gBAD5B;IAELT,WAAW,EAAEe,mBAAmB,IAAIN,gBAF/B;IAGLX,OAAO,4BAAER,WAAW,CAACF,eAAD,CAAb,2DAAE,uBAA8BU;EAHlC,CAAP;AAKD"},"metadata":{},"sourceType":"module"}