{"ast":null,"code":"export let ExploreId;\n\n(function (ExploreId) {\n  ExploreId[\"left\"] = \"left\";\n  ExploreId[\"right\"] = \"right\";\n})(ExploreId || (ExploreId = {}));\n\nexport const EXPLORE_GRAPH_STYLES = ['lines', 'bars', 'points', 'stacked_lines', 'stacked_bars'];","map":{"version":3,"names":["ExploreId","EXPLORE_GRAPH_STYLES"],"sources":["/home/soula/grafana/public/app/types/explore.ts"],"sourcesContent":["import { Observable, SubscriptionLike, Unsubscribable } from 'rxjs';\n\nimport {\n  AbsoluteTimeRange,\n  DataFrame,\n  DataQuery,\n  DataQueryRequest,\n  DataSourceApi,\n  HistoryItem,\n  LogsModel,\n  PanelData,\n  QueryHint,\n  RawTimeRange,\n  TimeRange,\n  EventBusExtended,\n  DataQueryResponse,\n  ExplorePanelsState,\n} from '@grafana/data';\nimport { RichHistorySearchFilters, RichHistorySettings } from 'app/core/utils/richHistoryTypes';\n\nexport enum ExploreId {\n  left = 'left',\n  right = 'right',\n}\n\nexport type ExploreQueryParams = {\n  left: string;\n  right: string;\n};\n\n/**\n * Global Explore state\n */\nexport interface ExploreState {\n  /**\n   * True if time interval for panels are synced. Only possible with split mode.\n   */\n  syncedTimes: boolean;\n  /**\n   * Explore state of the left split (left is default in non-split view).\n   */\n  left: ExploreItemState;\n  /**\n   * Explore state of the right area in split view.\n   */\n  right?: ExploreItemState;\n\n  /**\n   * Settings for rich history (note: filters are stored per each pane separately)\n   */\n  richHistorySettings?: RichHistorySettings;\n\n  /**\n   * True if local storage quota was exceeded when a rich history item was added. This is to prevent showing\n   * multiple errors when local storage is full.\n   */\n  richHistoryStorageFull: boolean;\n\n  /**\n   * True if a warning message of hitting the exceeded number of items has been shown already.\n   */\n  richHistoryLimitExceededWarningShown: boolean;\n\n  /**\n   * True if a warning message about failed rich history has been shown already in this session.\n   */\n  richHistoryMigrationFailed: boolean;\n}\n\nexport const EXPLORE_GRAPH_STYLES = ['lines', 'bars', 'points', 'stacked_lines', 'stacked_bars'] as const;\nexport type ExploreGraphStyle = typeof EXPLORE_GRAPH_STYLES[number];\n\nexport interface ExploreItemState {\n  /**\n   * Width used for calculating the graph interval (can't have more datapoints than pixels)\n   */\n  containerWidth: number;\n  /**\n   * Datasource instance that has been selected. Datasource-specific logic can be run on this object.\n   */\n  datasourceInstance?: DataSourceApi | null;\n  /**\n   * True if there is no datasource to be selected.\n   */\n  datasourceMissing: boolean;\n  /**\n   * Emitter to send events to the rest of Grafana.\n   */\n  eventBridge: EventBusExtended;\n  /**\n   * List of timeseries to be shown in the Explore graph result viewer.\n   */\n  graphResult: DataFrame[] | null;\n  /**\n   * History of recent queries. Datasource-specific and initialized via localStorage.\n   */\n  history: HistoryItem[];\n  /**\n   * Queries for this Explore, e.g., set via URL. Each query will be\n   * converted to a query row.\n   */\n  queries: DataQuery[];\n  /**\n   * True if this Explore area has been initialized.\n   * Used to distinguish URL state injection versus split view state injection.\n   */\n  initialized: boolean;\n  /**\n   * Log query result to be displayed in the logs result viewer.\n   */\n  logsResult: LogsModel | null;\n\n  /**\n   * Time range for this Explore. Managed by the time picker and used by all query runs.\n   */\n  range: TimeRange;\n\n  absoluteRange: AbsoluteTimeRange;\n  /**\n   * True if scanning for more results is active.\n   */\n  scanning: boolean;\n  /**\n   * Current scanning range to be shown to the user while scanning is active.\n   */\n  scanRange?: RawTimeRange;\n\n  loading: boolean;\n  /**\n   * Table model that combines all query table results into a single table.\n   */\n  tableResult: DataFrame | null;\n\n  /**\n   * React keys for rendering of QueryRows\n   */\n  queryKeys: string[];\n\n  /**\n   * How often query should be refreshed\n   */\n  refreshInterval?: string;\n\n  /**\n   * If true, the view is in live tailing mode.\n   */\n  isLive: boolean;\n\n  /**\n   * If true, the live tailing view is paused.\n   */\n  isPaused: boolean;\n\n  querySubscription?: Unsubscribable;\n\n  queryResponse: ExplorePanelData;\n\n  showLogs?: boolean;\n  showMetrics?: boolean;\n  showTable?: boolean;\n  showTrace?: boolean;\n  showNodeGraph?: boolean;\n\n  /**\n   * History of all queries\n   */\n  richHistory: RichHistoryQuery[];\n  richHistorySearchFilters?: RichHistorySearchFilters;\n  richHistoryTotal?: number;\n\n  /**\n   * We are using caching to store query responses of queries run from logs navigation.\n   * In logs navigation, we do pagination and we don't want our users to unnecessarily run the same queries that they've run just moments before.\n   * We are currently caching last 5 query responses.\n   */\n  cache: Array<{ key: string; value: ExplorePanelData }>;\n\n  // properties below should be more generic if we add more providers\n  // see also: DataSourceWithLogsVolumeSupport\n  logsVolumeDataProvider?: Observable<DataQueryResponse>;\n  logsVolumeDataSubscription?: SubscriptionLike;\n  logsVolumeData?: DataQueryResponse;\n\n  /* explore graph style */\n  graphStyle: ExploreGraphStyle;\n  panelsState: ExplorePanelsState;\n}\n\nexport interface ExploreUpdateState {\n  datasource: boolean;\n  queries: boolean;\n  range: boolean;\n  mode: boolean;\n}\n\nexport interface QueryOptions {\n  minInterval?: string;\n  maxDataPoints?: number;\n  liveStreaming?: boolean;\n}\n\nexport interface QueryTransaction {\n  id: string;\n  done: boolean;\n  error?: string | JSX.Element;\n  hints?: QueryHint[];\n  request: DataQueryRequest;\n  queries: DataQuery[];\n  result?: any; // Table model / Timeseries[] / Logs\n  scanning?: boolean;\n}\n\nexport type RichHistoryQuery<T extends DataQuery = DataQuery> = {\n  id: string;\n  createdAt: number;\n  datasourceUid: string;\n  datasourceName: string;\n  starred: boolean;\n  comment: string;\n  queries: T[];\n};\n\nexport interface ExplorePanelData extends PanelData {\n  graphFrames: DataFrame[];\n  tableFrames: DataFrame[];\n  logsFrames: DataFrame[];\n  traceFrames: DataFrame[];\n  nodeGraphFrames: DataFrame[];\n  graphResult: DataFrame[] | null;\n  tableResult: DataFrame | null;\n  logsResult: LogsModel | null;\n}\n"],"mappings":"AAoBA,WAAYA,SAAZ;;WAAYA,S;EAAAA,S;EAAAA,S;GAAAA,S,KAAAA,S;;AAiDZ,OAAO,MAAMC,oBAAoB,GAAG,CAAC,OAAD,EAAU,MAAV,EAAkB,QAAlB,EAA4B,eAA5B,EAA6C,cAA7C,CAA7B"},"metadata":{},"sourceType":"module"}