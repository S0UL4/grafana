{"ast":null,"code":"import { getFieldDisplayName } from '../../field/fieldState';\nimport { stringToJsRegex } from '../../text/string';\nimport { FieldMatcherID, FrameMatcherID } from './ids';\n\n/**\n * Mode to be able to toggle if the names matcher should match fields in provided\n * list or all except provided names.\n * @public\n */\nexport let ByNamesMatcherMode;\n/**\n * Options to instruct the by names matcher to either match all fields in given list\n * or all except the fields in the list.\n * @public\n */\n\n(function (ByNamesMatcherMode) {\n  ByNamesMatcherMode[\"exclude\"] = \"exclude\";\n  ByNamesMatcherMode[\"include\"] = \"include\";\n})(ByNamesMatcherMode || (ByNamesMatcherMode = {}));\n\n// General Field matcher\nconst fieldNameMatcher = {\n  id: FieldMatcherID.byName,\n  name: 'Field Name',\n  description: 'match the field name',\n  defaultOptions: '',\n  get: name => {\n    return (field, frame, allFrames) => {\n      return name === field.name || getFieldDisplayName(field, frame, allFrames) === name;\n    };\n  },\n  getOptionsDisplayText: name => {\n    return `Field name: ${name}`;\n  }\n};\nconst multipleFieldNamesMatcher = {\n  id: FieldMatcherID.byNames,\n  name: 'Field Names',\n  description: 'match any of the given the field names',\n  defaultOptions: {\n    mode: ByNamesMatcherMode.include,\n    names: []\n  },\n  get: options => {\n    const {\n      names,\n      mode = ByNamesMatcherMode.include\n    } = options;\n    const uniqueNames = new Set(names !== null && names !== void 0 ? names : []);\n\n    const matcher = (field, frame, frames) => {\n      return uniqueNames.has(field.name) || uniqueNames.has(getFieldDisplayName(field, frame, frames));\n    };\n\n    if (mode === ByNamesMatcherMode.exclude) {\n      return (field, frame, frames) => {\n        return !matcher(field, frame, frames);\n      };\n    }\n\n    return matcher;\n  },\n  getOptionsDisplayText: options => {\n    const {\n      names,\n      mode\n    } = options;\n    const displayText = (names !== null && names !== void 0 ? names : []).join(', ');\n\n    if (mode === ByNamesMatcherMode.exclude) {\n      return `All except: ${displayText}`;\n    }\n\n    return `All of: ${displayText}`;\n  }\n};\nconst regexpFieldNameMatcher = {\n  id: FieldMatcherID.byRegexp,\n  name: 'Field Name by Regexp',\n  description: 'match the field name by a given regexp pattern',\n  defaultOptions: '/.*/',\n  get: pattern => {\n    const regexp = patternToRegex(pattern);\n    return (field, frame, allFrames) => {\n      const displayName = getFieldDisplayName(field, frame, allFrames);\n      return !!regexp && regexp.test(displayName);\n    };\n  },\n  getOptionsDisplayText: pattern => {\n    return `Field name by pattern: ${pattern}`;\n  }\n};\n/**\n * Field matcher that will match all fields that exists in a\n * data frame with configured refId.\n * @public\n */\n\nconst fieldsInFrameMatcher = {\n  id: FieldMatcherID.byFrameRefID,\n  name: 'Fields by frame refId',\n  description: 'match all fields returned in data frame with refId.',\n  defaultOptions: '',\n  get: refId => {\n    return (field, frame, allFrames) => {\n      return frame.refId === refId;\n    };\n  },\n  getOptionsDisplayText: refId => {\n    return `Math all fields returned by query with reference ID: ${refId}`;\n  }\n};\nconst regexpOrMultipleNamesMatcher = {\n  id: FieldMatcherID.byRegexpOrNames,\n  name: 'Field Name by Regexp or Names',\n  description: 'match the field name by a given regexp pattern or given names',\n  defaultOptions: {\n    pattern: '/.*/',\n    names: []\n  },\n  get: options => {\n    var _options$names;\n\n    const regexpMatcher = regexpFieldNameMatcher.get((options === null || options === void 0 ? void 0 : options.pattern) || '');\n    const namesMatcher = multipleFieldNamesMatcher.get({\n      mode: ByNamesMatcherMode.include,\n      names: (_options$names = options === null || options === void 0 ? void 0 : options.names) !== null && _options$names !== void 0 ? _options$names : []\n    });\n    return (field, frame, allFrames) => {\n      return namesMatcher(field, frame, allFrames) || regexpMatcher(field, frame, allFrames);\n    };\n  },\n  getOptionsDisplayText: options => {\n    var _options$pattern, _options$names$join, _options$names2;\n\n    const pattern = (_options$pattern = options === null || options === void 0 ? void 0 : options.pattern) !== null && _options$pattern !== void 0 ? _options$pattern : '';\n    const names = (_options$names$join = options === null || options === void 0 ? void 0 : (_options$names2 = options.names) === null || _options$names2 === void 0 ? void 0 : _options$names2.join(',')) !== null && _options$names$join !== void 0 ? _options$names$join : '';\n    return `Field name by pattern: ${pattern} or names: ${names}`;\n  }\n};\n\nconst patternToRegex = pattern => {\n  if (!pattern) {\n    return undefined;\n  }\n\n  try {\n    return stringToJsRegex(pattern);\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n}; // General Frame matcher\n\n\nconst frameNameMatcher = {\n  id: FrameMatcherID.byName,\n  name: 'Frame Name',\n  description: 'match the frame name',\n  defaultOptions: '/.*/',\n  get: pattern => {\n    const regex = stringToJsRegex(pattern);\n    return frame => {\n      return regex.test(frame.name || '');\n    };\n  },\n  getOptionsDisplayText: pattern => {\n    return `Frame name: ${pattern}`;\n  }\n};\n/**\n * Registry Initialization\n */\n\nexport function getFieldNameMatchers() {\n  return [fieldNameMatcher, regexpFieldNameMatcher, multipleFieldNamesMatcher, regexpOrMultipleNamesMatcher, fieldsInFrameMatcher];\n}\nexport function getFrameNameMatchers() {\n  return [frameNameMatcher];\n}","map":{"version":3,"names":["getFieldDisplayName","stringToJsRegex","FieldMatcherID","FrameMatcherID","ByNamesMatcherMode","fieldNameMatcher","id","byName","name","description","defaultOptions","get","field","frame","allFrames","getOptionsDisplayText","multipleFieldNamesMatcher","byNames","mode","include","names","options","uniqueNames","Set","matcher","frames","has","exclude","displayText","join","regexpFieldNameMatcher","byRegexp","pattern","regexp","patternToRegex","displayName","test","fieldsInFrameMatcher","byFrameRefID","refId","regexpOrMultipleNamesMatcher","byRegexpOrNames","regexpMatcher","namesMatcher","undefined","error","console","frameNameMatcher","regex","getFieldNameMatchers","getFrameNameMatchers"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/matchers/nameMatcher.ts"],"sourcesContent":["import { getFieldDisplayName } from '../../field/fieldState';\nimport { stringToJsRegex } from '../../text/string';\nimport { Field, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo, FrameMatcherInfo, FieldMatcher } from '../../types/transformations';\n\nimport { FieldMatcherID, FrameMatcherID } from './ids';\n\nexport interface RegexpOrNamesMatcherOptions {\n  pattern?: string;\n  names?: string[];\n}\n\n/**\n * Mode to be able to toggle if the names matcher should match fields in provided\n * list or all except provided names.\n * @public\n */\nexport enum ByNamesMatcherMode {\n  exclude = 'exclude',\n  include = 'include',\n}\n\n/**\n * Options to instruct the by names matcher to either match all fields in given list\n * or all except the fields in the list.\n * @public\n */\nexport interface ByNamesMatcherOptions {\n  mode?: ByNamesMatcherMode;\n  names?: string[];\n  readOnly?: boolean;\n  prefix?: string;\n}\n\n// General Field matcher\nconst fieldNameMatcher: FieldMatcherInfo<string> = {\n  id: FieldMatcherID.byName,\n  name: 'Field Name',\n  description: 'match the field name',\n  defaultOptions: '',\n\n  get: (name: string): FieldMatcher => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return name === field.name || getFieldDisplayName(field, frame, allFrames) === name;\n    };\n  },\n\n  getOptionsDisplayText: (name: string) => {\n    return `Field name: ${name}`;\n  },\n};\n\nconst multipleFieldNamesMatcher: FieldMatcherInfo<ByNamesMatcherOptions> = {\n  id: FieldMatcherID.byNames,\n  name: 'Field Names',\n  description: 'match any of the given the field names',\n  defaultOptions: {\n    mode: ByNamesMatcherMode.include,\n    names: [],\n  },\n\n  get: (options: ByNamesMatcherOptions): FieldMatcher => {\n    const { names, mode = ByNamesMatcherMode.include } = options;\n    const uniqueNames = new Set<string>(names ?? []);\n\n    const matcher = (field: Field, frame: DataFrame, frames: DataFrame[]) => {\n      return uniqueNames.has(field.name) || uniqueNames.has(getFieldDisplayName(field, frame, frames));\n    };\n\n    if (mode === ByNamesMatcherMode.exclude) {\n      return (field: Field, frame: DataFrame, frames: DataFrame[]) => {\n        return !matcher(field, frame, frames);\n      };\n    }\n    return matcher;\n  },\n\n  getOptionsDisplayText: (options: ByNamesMatcherOptions): string => {\n    const { names, mode } = options;\n    const displayText = (names ?? []).join(', ');\n    if (mode === ByNamesMatcherMode.exclude) {\n      return `All except: ${displayText}`;\n    }\n    return `All of: ${displayText}`;\n  },\n};\n\nconst regexpFieldNameMatcher: FieldMatcherInfo<string> = {\n  id: FieldMatcherID.byRegexp,\n  name: 'Field Name by Regexp',\n  description: 'match the field name by a given regexp pattern',\n  defaultOptions: '/.*/',\n\n  get: (pattern: string): FieldMatcher => {\n    const regexp = patternToRegex(pattern);\n\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      const displayName = getFieldDisplayName(field, frame, allFrames);\n      return !!regexp && regexp.test(displayName);\n    };\n  },\n\n  getOptionsDisplayText: (pattern: string): string => {\n    return `Field name by pattern: ${pattern}`;\n  },\n};\n\n/**\n * Field matcher that will match all fields that exists in a\n * data frame with configured refId.\n * @public\n */\nconst fieldsInFrameMatcher: FieldMatcherInfo<string> = {\n  id: FieldMatcherID.byFrameRefID,\n  name: 'Fields by frame refId',\n  description: 'match all fields returned in data frame with refId.',\n  defaultOptions: '',\n\n  get: (refId: string): FieldMatcher => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return frame.refId === refId;\n    };\n  },\n\n  getOptionsDisplayText: (refId: string): string => {\n    return `Math all fields returned by query with reference ID: ${refId}`;\n  },\n};\n\nconst regexpOrMultipleNamesMatcher: FieldMatcherInfo<RegexpOrNamesMatcherOptions> = {\n  id: FieldMatcherID.byRegexpOrNames,\n  name: 'Field Name by Regexp or Names',\n  description: 'match the field name by a given regexp pattern or given names',\n  defaultOptions: {\n    pattern: '/.*/',\n    names: [],\n  },\n\n  get: (options: RegexpOrNamesMatcherOptions): FieldMatcher => {\n    const regexpMatcher = regexpFieldNameMatcher.get(options?.pattern || '');\n    const namesMatcher = multipleFieldNamesMatcher.get({\n      mode: ByNamesMatcherMode.include,\n      names: options?.names ?? [],\n    });\n\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return namesMatcher(field, frame, allFrames) || regexpMatcher(field, frame, allFrames);\n    };\n  },\n\n  getOptionsDisplayText: (options: RegexpOrNamesMatcherOptions): string => {\n    const pattern = options?.pattern ?? '';\n    const names = options?.names?.join(',') ?? '';\n    return `Field name by pattern: ${pattern} or names: ${names}`;\n  },\n};\n\nconst patternToRegex = (pattern?: string): RegExp | undefined => {\n  if (!pattern) {\n    return undefined;\n  }\n\n  try {\n    return stringToJsRegex(pattern);\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n};\n\n// General Frame matcher\nconst frameNameMatcher: FrameMatcherInfo<string> = {\n  id: FrameMatcherID.byName,\n  name: 'Frame Name',\n  description: 'match the frame name',\n  defaultOptions: '/.*/',\n\n  get: (pattern: string) => {\n    const regex = stringToJsRegex(pattern);\n    return (frame: DataFrame) => {\n      return regex.test(frame.name || '');\n    };\n  },\n\n  getOptionsDisplayText: (pattern: string) => {\n    return `Frame name: ${pattern}`;\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getFieldNameMatchers(): FieldMatcherInfo[] {\n  return [\n    fieldNameMatcher,\n    regexpFieldNameMatcher,\n    multipleFieldNamesMatcher,\n    regexpOrMultipleNamesMatcher,\n    fieldsInFrameMatcher,\n  ];\n}\n\nexport function getFrameNameMatchers(): FrameMatcherInfo[] {\n  return [frameNameMatcher];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}