{"ast":null,"code":"/**\n * The channel id is defined as:\n *\n *   ${scope}/${namespace}/${path}\n *\n * The scope drives how the namespace is used and controlled\n *\n * @alpha\n */\nexport let LiveChannelScope;\n/**\n * The type of data to expect in a given channel\n *\n * @alpha\n */\n\n(function (LiveChannelScope) {\n  LiveChannelScope[\"DataSource\"] = \"ds\";\n  LiveChannelScope[\"Plugin\"] = \"plugin\";\n  LiveChannelScope[\"Grafana\"] = \"grafana\";\n  LiveChannelScope[\"Stream\"] = \"stream\";\n})(LiveChannelScope || (LiveChannelScope = {}));\n\nexport let LiveChannelType;\n\n(function (LiveChannelType) {\n  LiveChannelType[\"DataStream\"] = \"stream\";\n  LiveChannelType[\"DataFrame\"] = \"frame\";\n  LiveChannelType[\"JSON\"] = \"json\";\n})(LiveChannelType || (LiveChannelType = {}));\n\nexport let LiveChannelConnectionState;\n\n(function (LiveChannelConnectionState) {\n  LiveChannelConnectionState[\"Pending\"] = \"pending\";\n  LiveChannelConnectionState[\"Connected\"] = \"connected\";\n  LiveChannelConnectionState[\"Disconnected\"] = \"disconnected\";\n  LiveChannelConnectionState[\"Shutdown\"] = \"shutdown\";\n  LiveChannelConnectionState[\"Invalid\"] = \"invalid\";\n})(LiveChannelConnectionState || (LiveChannelConnectionState = {}));\n\nexport let LiveChannelEventType;\n/**\n * @alpha -- experimental\n */\n\n(function (LiveChannelEventType) {\n  LiveChannelEventType[\"Status\"] = \"status\";\n  LiveChannelEventType[\"Join\"] = \"join\";\n  LiveChannelEventType[\"Leave\"] = \"leave\";\n  LiveChannelEventType[\"Message\"] = \"message\";\n})(LiveChannelEventType || (LiveChannelEventType = {}));\n\nexport function isLiveChannelStatusEvent(evt) {\n  return evt.type === LiveChannelEventType.Status;\n}\nexport function isLiveChannelJoinEvent(evt) {\n  return evt.type === LiveChannelEventType.Join;\n}\nexport function isLiveChannelLeaveEvent(evt) {\n  return evt.type === LiveChannelEventType.Leave;\n}\nexport function isLiveChannelMessageEvent(evt) {\n  return evt.type === LiveChannelEventType.Message;\n}\n/**\n * @alpha -- experimental\n */\n\n/**\n * Return an address from a string\n *\n * @alpha -- experimental\n */\nexport function parseLiveChannelAddress(id) {\n  if (id !== null && id !== void 0 && id.length) {\n    let parts = id.trim().split('/');\n\n    if (parts.length >= 3) {\n      return {\n        scope: parts[0],\n        namespace: parts[1],\n        path: parts.slice(2).join('/')\n      };\n    }\n  }\n\n  return undefined;\n}\n/**\n * Check if the address has a scope, namespace, and path\n *\n * @alpha -- experimental\n */\n\nexport function isValidLiveChannelAddress(addr) {\n  return !!(addr !== null && addr !== void 0 && addr.path && addr.namespace && addr.scope);\n}\n/**\n * Convert the address to an explicit channel path\n *\n * @alpha -- experimental\n */\n\nexport function toLiveChannelId(addr) {\n  if (!addr.scope) {\n    return '';\n  }\n\n  let id = addr.scope;\n\n  if (!addr.namespace) {\n    return id;\n  }\n\n  id += '/' + addr.namespace;\n\n  if (!addr.path) {\n    return id;\n  }\n\n  return id + '/' + addr.path;\n}","map":{"version":3,"names":["LiveChannelScope","LiveChannelType","LiveChannelConnectionState","LiveChannelEventType","isLiveChannelStatusEvent","evt","type","Status","isLiveChannelJoinEvent","Join","isLiveChannelLeaveEvent","Leave","isLiveChannelMessageEvent","Message","parseLiveChannelAddress","id","length","parts","trim","split","scope","namespace","path","slice","join","undefined","isValidLiveChannelAddress","addr","toLiveChannelId"],"sources":["/home/soula/grafana/packages/grafana-data/src/types/live.ts"],"sourcesContent":["/**\n * The channel id is defined as:\n *\n *   ${scope}/${namespace}/${path}\n *\n * The scope drives how the namespace is used and controlled\n *\n * @alpha\n */\nexport enum LiveChannelScope {\n  DataSource = 'ds', // namespace = data source ID\n  Plugin = 'plugin', // namespace = plugin name (singleton works for apps too)\n  Grafana = 'grafana', // namespace = feature\n  Stream = 'stream', // namespace = id for the managed data stream\n}\n\n/**\n * The type of data to expect in a given channel\n *\n * @alpha\n */\nexport enum LiveChannelType {\n  DataStream = 'stream', // each message contains a batch of rows that will be appened to previous values\n  DataFrame = 'frame', // each message is an entire data frame and should *replace* previous content\n  JSON = 'json', // arbitray json message\n}\n\nexport enum LiveChannelConnectionState {\n  /** The connection is not yet established */\n  Pending = 'pending',\n  /** Connected to the channel */\n  Connected = 'connected',\n  /** Disconnected from the channel.  The channel will reconnect when possible */\n  Disconnected = 'disconnected',\n  /** Was at some point connected, and will not try to reconnect */\n  Shutdown = 'shutdown',\n  /** Channel configuraiton was invalid and will not connect */\n  Invalid = 'invalid',\n}\n\nexport enum LiveChannelEventType {\n  Status = 'status',\n  Join = 'join',\n  Leave = 'leave',\n  Message = 'message',\n}\n\n/**\n * @alpha -- experimental\n */\nexport interface LiveChannelStatusEvent {\n  type: LiveChannelEventType.Status;\n\n  /**\n   * {scope}/{namespace}/{path}\n   */\n  id: string;\n\n  /**\n   * unix millies timestamp for the last status change\n   */\n  timestamp: number;\n\n  /**\n   * flag if the channel is actively connected to the channel.\n   * This may be false while the connections get established or if the network is lost\n   * As long as the `shutdown` flag is not set, the connection will try to reestablish\n   */\n  state: LiveChannelConnectionState;\n\n  /**\n   * When joining a channel, there may be an initial packet in the subscribe method\n   */\n  message?: any;\n\n  /**\n   * The last error.\n   *\n   * This will remain in the status until a new message is successfully received from the channel\n   */\n  error?: any;\n}\n\nexport interface LiveChannelJoinEvent {\n  type: LiveChannelEventType.Join;\n  user: any; // @alpha -- experimental -- will be filled in when we improve the UI\n}\n\nexport interface LiveChannelLeaveEvent {\n  type: LiveChannelEventType.Leave;\n  user: any; // @alpha -- experimental -- will be filled in when we improve the UI\n}\n\nexport interface LiveChannelMessageEvent<T> {\n  type: LiveChannelEventType.Message;\n  message: T;\n}\n\nexport type LiveChannelEvent<T = any> =\n  | LiveChannelStatusEvent\n  | LiveChannelJoinEvent\n  | LiveChannelLeaveEvent\n  | LiveChannelMessageEvent<T>;\n\nexport function isLiveChannelStatusEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelStatusEvent {\n  return evt.type === LiveChannelEventType.Status;\n}\n\nexport function isLiveChannelJoinEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelJoinEvent {\n  return evt.type === LiveChannelEventType.Join;\n}\n\nexport function isLiveChannelLeaveEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelLeaveEvent {\n  return evt.type === LiveChannelEventType.Leave;\n}\n\nexport function isLiveChannelMessageEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelMessageEvent<T> {\n  return evt.type === LiveChannelEventType.Message;\n}\n\n/**\n * @alpha -- experimental\n */\nexport interface LiveChannelPresenceStatus {\n  users: any; // @alpha -- experimental -- will be filled in when we improve the UI\n}\n\n/**\n * @alpha -- experimental\n */\nexport type LiveChannelId = string;\n\n/**\n * @alpha -- experimental\n */\nexport interface LiveChannelAddress {\n  scope: LiveChannelScope;\n  namespace: string; // depends on the scope\n  path: string;\n\n  /**\n   * Additional metadata passed to a channel.  The backend will propigate this JSON object to\n   * each OnSubscribe and RunStream calls.  This value should be constant across multiple requests\n   * to the same channel path\n   */\n  data?: any;\n}\n\n/**\n * Return an address from a string\n *\n * @alpha -- experimental\n */\nexport function parseLiveChannelAddress(id?: string): LiveChannelAddress | undefined {\n  if (id?.length) {\n    let parts = id.trim().split('/');\n    if (parts.length >= 3) {\n      return {\n        scope: parts[0] as LiveChannelScope,\n        namespace: parts[1],\n        path: parts.slice(2).join('/'),\n      };\n    }\n  }\n  return undefined;\n}\n\n/**\n * Check if the address has a scope, namespace, and path\n *\n * @alpha -- experimental\n */\nexport function isValidLiveChannelAddress(addr?: LiveChannelAddress): addr is LiveChannelAddress {\n  return !!(addr?.path && addr.namespace && addr.scope);\n}\n\n/**\n * Convert the address to an explicit channel path\n *\n * @alpha -- experimental\n */\nexport function toLiveChannelId(addr: LiveChannelAddress): LiveChannelId {\n  if (!addr.scope) {\n    return '';\n  }\n  let id = addr.scope as string;\n  if (!addr.namespace) {\n    return id;\n  }\n  id += '/' + addr.namespace;\n  if (!addr.path) {\n    return id;\n  }\n  return id + '/' + addr.path;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAYA,gBAAZ;AAOA;AACA;AACA;AACA;AACA;;WAXYA,gB;EAAAA,gB;EAAAA,gB;EAAAA,gB;EAAAA,gB;GAAAA,gB,KAAAA,gB;;AAYZ,WAAYC,eAAZ;;WAAYA,e;EAAAA,e;EAAAA,e;EAAAA,e;GAAAA,e,KAAAA,e;;AAMZ,WAAYC,0BAAZ;;WAAYA,0B;EAAAA,0B;EAAAA,0B;EAAAA,0B;EAAAA,0B;EAAAA,0B;GAAAA,0B,KAAAA,0B;;AAaZ,WAAYC,oBAAZ;AAOA;AACA;AACA;;WATYA,oB;EAAAA,oB;EAAAA,oB;EAAAA,oB;EAAAA,oB;GAAAA,oB,KAAAA,oB;;AAgEZ,OAAO,SAASC,wBAAT,CAAqCC,GAArC,EAA8F;EACnG,OAAOA,GAAG,CAACC,IAAJ,KAAaH,oBAAoB,CAACI,MAAzC;AACD;AAED,OAAO,SAASC,sBAAT,CAAmCH,GAAnC,EAA0F;EAC/F,OAAOA,GAAG,CAACC,IAAJ,KAAaH,oBAAoB,CAACM,IAAzC;AACD;AAED,OAAO,SAASC,uBAAT,CAAoCL,GAApC,EAA4F;EACjG,OAAOA,GAAG,CAACC,IAAJ,KAAaH,oBAAoB,CAACQ,KAAzC;AACD;AAED,OAAO,SAASC,yBAAT,CAAsCP,GAAtC,EAAmG;EACxG,OAAOA,GAAG,CAACC,IAAJ,KAAaH,oBAAoB,CAACU,OAAzC;AACD;AAED;AACA;AACA;;AA0BA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,uBAAT,CAAiCC,EAAjC,EAA8E;EACnF,IAAIA,EAAJ,aAAIA,EAAJ,eAAIA,EAAE,CAAEC,MAAR,EAAgB;IACd,IAAIC,KAAK,GAAGF,EAAE,CAACG,IAAH,GAAUC,KAAV,CAAgB,GAAhB,CAAZ;;IACA,IAAIF,KAAK,CAACD,MAAN,IAAgB,CAApB,EAAuB;MACrB,OAAO;QACLI,KAAK,EAAEH,KAAK,CAAC,CAAD,CADP;QAELI,SAAS,EAAEJ,KAAK,CAAC,CAAD,CAFX;QAGLK,IAAI,EAAEL,KAAK,CAACM,KAAN,CAAY,CAAZ,EAAeC,IAAf,CAAoB,GAApB;MAHD,CAAP;IAKD;EACF;;EACD,OAAOC,SAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,yBAAT,CAAmCC,IAAnC,EAA0F;EAC/F,OAAO,CAAC,EAAEA,IAAI,SAAJ,IAAAA,IAAI,WAAJ,IAAAA,IAAI,CAAEL,IAAN,IAAcK,IAAI,CAACN,SAAnB,IAAgCM,IAAI,CAACP,KAAvC,CAAR;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASQ,eAAT,CAAyBD,IAAzB,EAAkE;EACvE,IAAI,CAACA,IAAI,CAACP,KAAV,EAAiB;IACf,OAAO,EAAP;EACD;;EACD,IAAIL,EAAE,GAAGY,IAAI,CAACP,KAAd;;EACA,IAAI,CAACO,IAAI,CAACN,SAAV,EAAqB;IACnB,OAAON,EAAP;EACD;;EACDA,EAAE,IAAI,MAAMY,IAAI,CAACN,SAAjB;;EACA,IAAI,CAACM,IAAI,CAACL,IAAV,EAAgB;IACd,OAAOP,EAAP;EACD;;EACD,OAAOA,EAAE,GAAG,GAAL,GAAWY,IAAI,CAACL,IAAvB;AACD"},"metadata":{},"sourceType":"module"}