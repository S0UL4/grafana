{"ast":null,"code":"const _excluded = [\"__name__\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { descending, deviation } from 'd3';\nimport { groupBy, partition } from 'lodash';\nimport { ArrayDataFrame, ArrayVector, CoreApp, DataFrameType, DataTopic, FieldType, formatLabels, getDisplayProcessor, TIME_SERIES_TIME_FIELD_NAME, TIME_SERIES_VALUE_FIELD_NAME } from '@grafana/data';\nimport { getDataSourceSrv, getTemplateSrv } from '@grafana/runtime';\nimport { renderLegendFormat } from './legend';\nimport { isExemplarData, isMatrixData } from './types'; // handles case-insensitive Inf, +Inf, -Inf (with optional \"inity\" suffix)\n\nconst INFINITY_SAMPLE_REGEX = /^[+-]?inf(?:inity)?$/i;\n\nconst isTableResult = (dataFrame, options) => {\n  var _dataFrame$meta, _dataFrame$meta$custo, _dataFrame$meta2, _dataFrame$meta2$cust;\n\n  // We want to process vector and scalar results in Explore as table\n  if (options.app === CoreApp.Explore && (((_dataFrame$meta = dataFrame.meta) === null || _dataFrame$meta === void 0 ? void 0 : (_dataFrame$meta$custo = _dataFrame$meta.custom) === null || _dataFrame$meta$custo === void 0 ? void 0 : _dataFrame$meta$custo.resultType) === 'vector' || ((_dataFrame$meta2 = dataFrame.meta) === null || _dataFrame$meta2 === void 0 ? void 0 : (_dataFrame$meta2$cust = _dataFrame$meta2.custom) === null || _dataFrame$meta2$cust === void 0 ? void 0 : _dataFrame$meta2$cust.resultType) === 'scalar')) {\n    return true;\n  } // We want to process all dataFrames with target.format === 'table' as table\n\n\n  const target = options.targets.find(target => target.refId === dataFrame.refId);\n  return (target === null || target === void 0 ? void 0 : target.format) === 'table';\n};\n\nconst isHeatmapResult = (dataFrame, options) => {\n  const target = options.targets.find(target => target.refId === dataFrame.refId);\n  return (target === null || target === void 0 ? void 0 : target.format) === 'heatmap';\n}; // V2 result trasnformer used to transform query results from queries that were run trough prometheus backend\n\n\nexport function transformV2(response, request, options) {\n  const [tableFrames, framesWithoutTable] = partition(response.data, df => isTableResult(df, request));\n  const processedTableFrames = transformDFToTable(tableFrames);\n  const [exemplarFrames, framesWithoutTableAndExemplars] = partition(framesWithoutTable, df => {\n    var _df$meta, _df$meta$custom;\n\n    return ((_df$meta = df.meta) === null || _df$meta === void 0 ? void 0 : (_df$meta$custom = _df$meta.custom) === null || _df$meta$custom === void 0 ? void 0 : _df$meta$custom.resultType) === 'exemplar';\n  }); // EXEMPLAR FRAMES: We enrich exemplar frames with data links and add dataTopic meta info\n\n  const {\n    exemplarTraceIdDestinations: destinations\n  } = options;\n  const processedExemplarFrames = exemplarFrames.map(dataFrame => {\n    if (destinations !== null && destinations !== void 0 && destinations.length) {\n      for (const exemplarTraceIdDestination of destinations) {\n        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);\n\n        if (traceIDField) {\n          var _traceIDField$config$;\n\n          const links = getDataLinks(exemplarTraceIdDestination);\n          traceIDField.config.links = (_traceIDField$config$ = traceIDField.config.links) !== null && _traceIDField$config$ !== void 0 && _traceIDField$config$.length ? [...traceIDField.config.links, ...links] : links;\n        }\n      }\n    }\n\n    return Object.assign({}, dataFrame, {\n      meta: Object.assign({}, dataFrame.meta, {\n        dataTopic: DataTopic.Annotations\n      })\n    });\n  });\n  const [heatmapResults, framesWithoutTableHeatmapsAndExemplars] = partition(framesWithoutTableAndExemplars, df => isHeatmapResult(df, request));\n  const processedHeatmapFrames = mergeHeatmapFrames(transformToHistogramOverTime(heatmapResults.sort(sortSeriesByLabel))); // Everything else is processed as time_series result and graph preferredVisualisationType\n\n  const otherFrames = framesWithoutTableHeatmapsAndExemplars.map(dataFrame => {\n    const df = Object.assign({}, dataFrame, {\n      meta: Object.assign({}, dataFrame.meta, {\n        preferredVisualisationType: 'graph'\n      })\n    });\n    return df;\n  });\n  return Object.assign({}, response, {\n    data: [...otherFrames, ...processedTableFrames, ...processedHeatmapFrames, ...processedExemplarFrames]\n  });\n}\nexport function transformDFToTable(dfs) {\n  // If no dataFrames or if 1 dataFrames with no values, return original dataFrame\n  if (dfs.length === 0 || dfs.length === 1 && dfs[0].length === 0) {\n    return dfs;\n  } // Group results by refId and process dataFrames with the same refId as 1 dataFrame\n\n\n  const dataFramesByRefId = groupBy(dfs, 'refId');\n  const refIds = Object.keys(dataFramesByRefId);\n  const frames = refIds.map(refId => {\n    // Create timeField, valueField and labelFields\n    const valueText = getValueText(refIds.length, refId);\n    const valueField = getValueField({\n      data: [],\n      valueName: valueText\n    });\n    const timeField = getTimeField([]);\n    const labelFields = []; // Fill labelsFields with labels from dataFrames\n\n    dataFramesByRefId[refId].forEach(df => {\n      var _frameValueField$labe;\n\n      const frameValueField = df.fields[1];\n      const promLabels = (_frameValueField$labe = frameValueField.labels) !== null && _frameValueField$labe !== void 0 ? _frameValueField$labe : {};\n      Object.keys(promLabels).sort().forEach(label => {\n        // If we don't have label in labelFields, add it\n        if (!labelFields.some(l => l.name === label)) {\n          const numberField = label === 'le';\n          labelFields.push({\n            name: label,\n            config: {\n              filterable: true\n            },\n            type: numberField ? FieldType.number : FieldType.string,\n            values: new ArrayVector()\n          });\n        }\n      });\n    }); // Fill valueField, timeField and labelFields with values\n\n    dataFramesByRefId[refId].forEach(df => {\n      df.fields[0].values.toArray().forEach(value => timeField.values.add(value));\n      df.fields[1].values.toArray().forEach(value => {\n        var _df$fields$1$labels;\n\n        valueField.values.add(parseSampleValue(value));\n        const labelsForField = (_df$fields$1$labels = df.fields[1].labels) !== null && _df$fields$1$labels !== void 0 ? _df$fields$1$labels : {};\n        labelFields.forEach(field => field.values.add(getLabelValue(labelsForField, field.name)));\n      });\n    });\n    const fields = [timeField, ...labelFields, valueField];\n    return {\n      refId,\n      fields,\n      meta: Object.assign({}, dfs[0].meta, {\n        preferredVisualisationType: 'table'\n      }),\n      length: timeField.values.length\n    };\n  });\n  return frames;\n}\n\nfunction getValueText(responseLength, refId = '') {\n  return responseLength > 1 ? `Value #${refId}` : 'Value';\n}\n\nexport function transform(response, transformOptions) {\n  // Create options object from transformOptions\n  const options = {\n    format: transformOptions.target.format,\n    step: transformOptions.query.step,\n    legendFormat: transformOptions.target.legendFormat,\n    start: transformOptions.query.start,\n    end: transformOptions.query.end,\n    query: transformOptions.query.expr,\n    responseListLength: transformOptions.responseListLength,\n    scopedVars: transformOptions.scopedVars,\n    refId: transformOptions.target.refId,\n    valueWithRefId: transformOptions.target.valueWithRefId,\n    meta: {\n      // Fix for showing of Prometheus results in Explore table\n      preferredVisualisationType: transformOptions.query.instant ? 'table' : 'graph'\n    }\n  };\n  const prometheusResult = response.data.data;\n\n  if (isExemplarData(prometheusResult)) {\n    var _transformOptions$exe;\n\n    const events = [];\n    prometheusResult.forEach(exemplarData => {\n      const data = exemplarData.exemplars.map(exemplar => {\n        return Object.assign({\n          [TIME_SERIES_TIME_FIELD_NAME]: exemplar.timestamp * 1000,\n          [TIME_SERIES_VALUE_FIELD_NAME]: exemplar.value\n        }, exemplar.labels, exemplarData.seriesLabels);\n      });\n      events.push(...data);\n    }); // Grouping exemplars by step\n\n    const sampledExemplars = sampleExemplars(events, options);\n    const dataFrame = new ArrayDataFrame(sampledExemplars);\n    dataFrame.meta = {\n      dataTopic: DataTopic.Annotations\n    }; // Add data links if configured\n\n    if ((_transformOptions$exe = transformOptions.exemplarTraceIdDestinations) !== null && _transformOptions$exe !== void 0 && _transformOptions$exe.length) {\n      for (const exemplarTraceIdDestination of transformOptions.exemplarTraceIdDestinations) {\n        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);\n\n        if (traceIDField) {\n          var _traceIDField$config$2;\n\n          const links = getDataLinks(exemplarTraceIdDestination);\n          traceIDField.config.links = (_traceIDField$config$2 = traceIDField.config.links) !== null && _traceIDField$config$2 !== void 0 && _traceIDField$config$2.length ? [...traceIDField.config.links, ...links] : links;\n        }\n      }\n    }\n\n    return [dataFrame];\n  }\n\n  if (!(prometheusResult !== null && prometheusResult !== void 0 && prometheusResult.result)) {\n    return [];\n  } // Return early if result type is scalar\n\n\n  if (prometheusResult.resultType === 'scalar') {\n    return [{\n      meta: options.meta,\n      refId: options.refId,\n      length: 1,\n      fields: [getTimeField([prometheusResult.result]), getValueField({\n        data: [prometheusResult.result]\n      })]\n    }];\n  } // Return early again if the format is table, this needs special transformation.\n\n\n  if (options.format === 'table') {\n    const tableData = transformMetricDataToTable(prometheusResult.result, options);\n    return [tableData];\n  } // Process matrix and vector results to DataFrame\n\n\n  const dataFrame = [];\n  prometheusResult.result.forEach(data => dataFrame.push(transformToDataFrame(data, options))); // When format is heatmap use the already created data frames and transform it more\n\n  if (options.format === 'heatmap') {\n    return mergeHeatmapFrames(transformToHistogramOverTime(dataFrame.sort(sortSeriesByLabel)));\n  } // Return matrix or vector result as DataFrame[]\n\n\n  return dataFrame;\n}\n\nfunction getDataLinks(options) {\n  const dataLinks = [];\n\n  if (options.datasourceUid) {\n    const dataSourceSrv = getDataSourceSrv();\n    const dsSettings = dataSourceSrv.getInstanceSettings(options.datasourceUid); // dsSettings is undefined because of the reasons below:\n    // - permissions issues (probably most likely)\n    // - deleted datasource\n    // - misconfiguration\n\n    if (dsSettings) {\n      var _dsSettings$name;\n\n      dataLinks.push({\n        title: options.urlDisplayLabel || `Query with ${dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name}`,\n        url: '',\n        internal: {\n          query: {\n            query: '${__value.raw}',\n            queryType: 'traceId'\n          },\n          datasourceUid: options.datasourceUid,\n          datasourceName: (_dsSettings$name = dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name) !== null && _dsSettings$name !== void 0 ? _dsSettings$name : 'Data source not found'\n        }\n      });\n    }\n  }\n\n  if (options.url) {\n    dataLinks.push({\n      title: options.urlDisplayLabel || `Go to ${options.url}`,\n      url: options.url,\n      targetBlank: true\n    });\n  }\n\n  return dataLinks;\n}\n/**\n * Reduce the density of the exemplars by making sure that the highest value exemplar is included\n * and then only the ones that are 2 times the standard deviation of the all the values.\n * This makes sure not to show too many dots near each other.\n */\n\n\nfunction sampleExemplars(events, options) {\n  const step = options.step || 15;\n  const bucketedExemplars = {};\n  const values = [];\n\n  for (const exemplar of events) {\n    // Align exemplar timestamp to nearest step second\n    const alignedTs = String(Math.floor(exemplar[TIME_SERIES_TIME_FIELD_NAME] / 1000 / step) * step * 1000);\n\n    if (!bucketedExemplars[alignedTs]) {\n      // New bucket found\n      bucketedExemplars[alignedTs] = [];\n    }\n\n    bucketedExemplars[alignedTs].push(exemplar);\n    values.push(exemplar[TIME_SERIES_VALUE_FIELD_NAME]);\n  } // Getting exemplars from each bucket\n\n\n  const standardDeviation = deviation(values);\n  const sampledBuckets = Object.keys(bucketedExemplars).sort();\n  const sampledExemplars = [];\n\n  for (const ts of sampledBuckets) {\n    const exemplarsInBucket = bucketedExemplars[ts];\n\n    if (exemplarsInBucket.length === 1) {\n      sampledExemplars.push(exemplarsInBucket[0]);\n    } else {\n      // Choose which values to sample\n      const bucketValues = exemplarsInBucket.map(ex => ex[TIME_SERIES_VALUE_FIELD_NAME]).sort(descending);\n      const sampledBucketValues = bucketValues.reduce((acc, curr) => {\n        if (acc.length === 0) {\n          // First value is max and is always added\n          acc.push(curr);\n        } else {\n          // Then take values only when at least 2 standard deviation distance to previously taken value\n          const prev = acc[acc.length - 1];\n\n          if (standardDeviation && prev - curr >= 2 * standardDeviation) {\n            acc.push(curr);\n          }\n        }\n\n        return acc;\n      }, []); // Find the exemplars for the sampled values\n\n      sampledExemplars.push(...sampledBucketValues.map(value => exemplarsInBucket.find(ex => ex[TIME_SERIES_VALUE_FIELD_NAME] === value)));\n    }\n  }\n\n  return sampledExemplars;\n}\n/**\n * Transforms matrix and vector result from Prometheus result to DataFrame\n */\n\n\nfunction transformToDataFrame(data, options) {\n  const {\n    name,\n    labels\n  } = createLabelInfo(data.metric, options);\n  const fields = [];\n\n  if (isMatrixData(data)) {\n    const stepMs = options.step ? options.step * 1000 : NaN;\n    let baseTimestamp = options.start * 1000;\n    const dps = [];\n\n    for (const value of data.values) {\n      let dpValue = parseSampleValue(value[1]);\n\n      if (isNaN(dpValue)) {\n        dpValue = null;\n      }\n\n      const timestamp = value[0] * 1000;\n\n      for (let t = baseTimestamp; t < timestamp; t += stepMs) {\n        dps.push([t, null]);\n      }\n\n      baseTimestamp = timestamp + stepMs;\n      dps.push([timestamp, dpValue]);\n    }\n\n    const endTimestamp = options.end * 1000;\n\n    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {\n      dps.push([t, null]);\n    }\n\n    fields.push(getTimeField(dps, true));\n    fields.push(getValueField({\n      data: dps,\n      parseValue: false,\n      labels,\n      displayNameFromDS: name\n    }));\n  } else {\n    fields.push(getTimeField([data.value]));\n    fields.push(getValueField({\n      data: [data.value],\n      labels,\n      displayNameFromDS: name\n    }));\n  }\n\n  return {\n    meta: options.meta,\n    refId: options.refId,\n    length: fields[0].values.length,\n    fields,\n    name\n  };\n}\n\nfunction transformMetricDataToTable(md, options) {\n  if (!md || md.length === 0) {\n    return {\n      meta: options.meta,\n      refId: options.refId,\n      length: 0,\n      fields: []\n    };\n  }\n\n  const valueText = options.responseListLength > 1 || options.valueWithRefId ? `Value #${options.refId}` : 'Value';\n  const timeField = getTimeField([]);\n  const metricFields = Object.keys(md.reduce((acc, series) => Object.assign({}, acc, series.metric), {})).sort().map(label => {\n    // Labels have string field type, otherwise table tries to figure out the type which can result in unexpected results\n    // Only \"le\" label has a number field type\n    const numberField = label === 'le';\n    return {\n      name: label,\n      config: {\n        filterable: true\n      },\n      type: numberField ? FieldType.number : FieldType.string,\n      values: new ArrayVector()\n    };\n  });\n  const valueField = getValueField({\n    data: [],\n    valueName: valueText\n  });\n  md.forEach(d => {\n    if (isMatrixData(d)) {\n      d.values.forEach(val => {\n        timeField.values.add(val[0] * 1000);\n        metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));\n        valueField.values.add(parseSampleValue(val[1]));\n      });\n    } else {\n      timeField.values.add(d.value[0] * 1000);\n      metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));\n      valueField.values.add(parseSampleValue(d.value[1]));\n    }\n  });\n  return {\n    meta: options.meta,\n    refId: options.refId,\n    length: timeField.values.length,\n    fields: [timeField, ...metricFields, valueField]\n  };\n}\n\nfunction getLabelValue(metric, label) {\n  if (metric.hasOwnProperty(label)) {\n    if (label === 'le') {\n      return parseSampleValue(metric[label]);\n    }\n\n    return metric[label];\n  }\n\n  return '';\n}\n\nfunction getTimeField(data, isMs = false) {\n  return {\n    name: TIME_SERIES_TIME_FIELD_NAME,\n    type: FieldType.time,\n    config: {},\n    values: new ArrayVector(data.map(val => isMs ? val[0] : val[0] * 1000))\n  };\n}\n\nfunction getValueField({\n  data,\n  valueName = TIME_SERIES_VALUE_FIELD_NAME,\n  parseValue = true,\n  labels,\n  displayNameFromDS\n}) {\n  return {\n    name: valueName,\n    type: FieldType.number,\n    display: getDisplayProcessor(),\n    config: {\n      displayNameFromDS\n    },\n    labels,\n    values: new ArrayVector(data.map(val => parseValue ? parseSampleValue(val[1]) : val[1]))\n  };\n}\n\nfunction createLabelInfo(labels, options) {\n  if (options !== null && options !== void 0 && options.legendFormat) {\n    const title = renderLegendFormat(getTemplateSrv().replace(options.legendFormat, options === null || options === void 0 ? void 0 : options.scopedVars), labels);\n    return {\n      name: title,\n      labels\n    };\n  }\n\n  const {\n    __name__\n  } = labels,\n        labelsWithoutName = _objectWithoutPropertiesLoose(labels, _excluded);\n\n  const labelPart = formatLabels(labelsWithoutName);\n  let title = `${__name__ !== null && __name__ !== void 0 ? __name__ : ''}${labelPart}`;\n\n  if (!title) {\n    title = options.query;\n  }\n\n  return {\n    name: title,\n    labels: labelsWithoutName\n  };\n}\n\nexport function getOriginalMetricName(labelData) {\n  const metricName = labelData.__name__ || '';\n  delete labelData.__name__;\n  const labelPart = Object.entries(labelData).map(label => `${label[0]}=\"${label[1]}\"`).join(',');\n  return `${metricName}{${labelPart}}`;\n}\n\nfunction mergeHeatmapFrames(frames) {\n  if (frames.length === 0) {\n    return [];\n  }\n\n  const timeField = frames[0].fields.find(field => field.type === FieldType.time);\n  const countFields = frames.map(frame => {\n    let field = frame.fields.find(field => field.type === FieldType.number);\n    return Object.assign({}, field, {\n      name: field.config.displayNameFromDS\n    });\n  });\n  return [Object.assign({}, frames[0], {\n    meta: Object.assign({}, frames[0].meta, {\n      type: DataFrameType.HeatmapRows\n    }),\n    fields: [timeField, ...countFields]\n  })];\n}\n\nfunction transformToHistogramOverTime(seriesList) {\n  /*      t1 = timestamp1, t2 = timestamp2 etc.\n            t1  t2  t3          t1  t2  t3\n    le10    10  10  0     =>    10  10  0\n    le20    20  10  30    =>    10  0   30\n    le30    30  10  35    =>    10  0   5\n    */\n  for (let i = seriesList.length - 1; i > 0; i--) {\n    const topSeries = seriesList[i].fields.find(s => s.name === TIME_SERIES_VALUE_FIELD_NAME);\n    const bottomSeries = seriesList[i - 1].fields.find(s => s.name === TIME_SERIES_VALUE_FIELD_NAME);\n\n    if (!topSeries || !bottomSeries) {\n      throw new Error('Prometheus heatmap transform error: data should be a time series');\n    }\n\n    for (let j = 0; j < topSeries.values.length; j++) {\n      const bottomPoint = bottomSeries.values.get(j) || [0];\n      topSeries.values.toArray()[j] -= bottomPoint;\n    }\n  }\n\n  return seriesList;\n}\n\nfunction sortSeriesByLabel(s1, s2) {\n  let le1, le2;\n\n  try {\n    var _s1$name, _s2$name;\n\n    // fail if not integer. might happen with bad queries\n    le1 = parseSampleValue((_s1$name = s1.name) !== null && _s1$name !== void 0 ? _s1$name : '');\n    le2 = parseSampleValue((_s2$name = s2.name) !== null && _s2$name !== void 0 ? _s2$name : '');\n  } catch (err) {\n    console.error(err);\n    return 0;\n  }\n\n  if (le1 > le2) {\n    return 1;\n  }\n\n  if (le1 < le2) {\n    return -1;\n  }\n\n  return 0;\n}\n/** @internal */\n\n\nexport function parseSampleValue(value) {\n  if (INFINITY_SAMPLE_REGEX.test(value)) {\n    return value[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  }\n\n  return parseFloat(value);\n}","map":{"version":3,"names":["descending","deviation","groupBy","partition","ArrayDataFrame","ArrayVector","CoreApp","DataFrameType","DataTopic","FieldType","formatLabels","getDisplayProcessor","TIME_SERIES_TIME_FIELD_NAME","TIME_SERIES_VALUE_FIELD_NAME","getDataSourceSrv","getTemplateSrv","renderLegendFormat","isExemplarData","isMatrixData","INFINITY_SAMPLE_REGEX","isTableResult","dataFrame","options","app","Explore","meta","custom","resultType","target","targets","find","refId","format","isHeatmapResult","transformV2","response","request","tableFrames","framesWithoutTable","data","df","processedTableFrames","transformDFToTable","exemplarFrames","framesWithoutTableAndExemplars","exemplarTraceIdDestinations","destinations","processedExemplarFrames","map","length","exemplarTraceIdDestination","traceIDField","fields","field","name","links","getDataLinks","config","dataTopic","Annotations","heatmapResults","framesWithoutTableHeatmapsAndExemplars","processedHeatmapFrames","mergeHeatmapFrames","transformToHistogramOverTime","sort","sortSeriesByLabel","otherFrames","preferredVisualisationType","dfs","dataFramesByRefId","refIds","Object","keys","frames","valueText","getValueText","valueField","getValueField","valueName","timeField","getTimeField","labelFields","forEach","frameValueField","promLabels","labels","label","some","l","numberField","push","filterable","type","number","string","values","toArray","value","add","parseSampleValue","labelsForField","getLabelValue","responseLength","transform","transformOptions","step","query","legendFormat","start","end","expr","responseListLength","scopedVars","valueWithRefId","instant","prometheusResult","events","exemplarData","exemplars","exemplar","timestamp","seriesLabels","sampledExemplars","sampleExemplars","result","tableData","transformMetricDataToTable","transformToDataFrame","dataLinks","datasourceUid","dataSourceSrv","dsSettings","getInstanceSettings","title","urlDisplayLabel","url","internal","queryType","datasourceName","targetBlank","bucketedExemplars","alignedTs","String","Math","floor","standardDeviation","sampledBuckets","ts","exemplarsInBucket","bucketValues","ex","sampledBucketValues","reduce","acc","curr","prev","createLabelInfo","metric","stepMs","NaN","baseTimestamp","dps","dpValue","isNaN","t","endTimestamp","parseValue","displayNameFromDS","md","metricFields","series","d","val","metricField","hasOwnProperty","isMs","time","display","replace","__name__","labelsWithoutName","labelPart","getOriginalMetricName","labelData","metricName","entries","join","countFields","frame","HeatmapRows","seriesList","i","topSeries","s","bottomSeries","Error","j","bottomPoint","get","s1","s2","le1","le2","err","console","error","test","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","parseFloat"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/result_transformer.ts"],"sourcesContent":["import { descending, deviation } from 'd3';\nimport { groupBy, partition } from 'lodash';\n\nimport {\n  ArrayDataFrame,\n  ArrayVector,\n  CoreApp,\n  DataFrame,\n  DataFrameType,\n  DataLink,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataTopic,\n  Field,\n  FieldType,\n  formatLabels,\n  getDisplayProcessor,\n  Labels,\n  MutableField,\n  PreferredVisualisationType,\n  ScopedVars,\n  TIME_SERIES_TIME_FIELD_NAME,\n  TIME_SERIES_VALUE_FIELD_NAME,\n} from '@grafana/data';\nimport { FetchResponse, getDataSourceSrv, getTemplateSrv } from '@grafana/runtime';\n\nimport { renderLegendFormat } from './legend';\nimport {\n  ExemplarTraceIdDestination,\n  isExemplarData,\n  isMatrixData,\n  MatrixOrVectorResult,\n  PromDataSuccessResponse,\n  PromMetric,\n  PromQuery,\n  PromQueryRequest,\n  PromValue,\n  TransformOptions,\n} from './types';\n\n// handles case-insensitive Inf, +Inf, -Inf (with optional \"inity\" suffix)\nconst INFINITY_SAMPLE_REGEX = /^[+-]?inf(?:inity)?$/i;\n\ninterface TimeAndValue {\n  [TIME_SERIES_TIME_FIELD_NAME]: number;\n  [TIME_SERIES_VALUE_FIELD_NAME]: number;\n}\n\nconst isTableResult = (dataFrame: DataFrame, options: DataQueryRequest<PromQuery>): boolean => {\n  // We want to process vector and scalar results in Explore as table\n  if (\n    options.app === CoreApp.Explore &&\n    (dataFrame.meta?.custom?.resultType === 'vector' || dataFrame.meta?.custom?.resultType === 'scalar')\n  ) {\n    return true;\n  }\n\n  // We want to process all dataFrames with target.format === 'table' as table\n  const target = options.targets.find((target) => target.refId === dataFrame.refId);\n  return target?.format === 'table';\n};\n\nconst isHeatmapResult = (dataFrame: DataFrame, options: DataQueryRequest<PromQuery>): boolean => {\n  const target = options.targets.find((target) => target.refId === dataFrame.refId);\n  return target?.format === 'heatmap';\n};\n\n// V2 result trasnformer used to transform query results from queries that were run trough prometheus backend\nexport function transformV2(\n  response: DataQueryResponse,\n  request: DataQueryRequest<PromQuery>,\n  options: { exemplarTraceIdDestinations?: ExemplarTraceIdDestination[] }\n) {\n  const [tableFrames, framesWithoutTable] = partition<DataFrame>(response.data, (df) => isTableResult(df, request));\n  const processedTableFrames = transformDFToTable(tableFrames);\n\n  const [exemplarFrames, framesWithoutTableAndExemplars] = partition<DataFrame>(\n    framesWithoutTable,\n    (df) => df.meta?.custom?.resultType === 'exemplar'\n  );\n\n  // EXEMPLAR FRAMES: We enrich exemplar frames with data links and add dataTopic meta info\n  const { exemplarTraceIdDestinations: destinations } = options;\n  const processedExemplarFrames = exemplarFrames.map((dataFrame) => {\n    if (destinations?.length) {\n      for (const exemplarTraceIdDestination of destinations) {\n        const traceIDField = dataFrame.fields.find((field) => field.name === exemplarTraceIdDestination.name);\n        if (traceIDField) {\n          const links = getDataLinks(exemplarTraceIdDestination);\n          traceIDField.config.links = traceIDField.config.links?.length\n            ? [...traceIDField.config.links, ...links]\n            : links;\n        }\n      }\n    }\n\n    return { ...dataFrame, meta: { ...dataFrame.meta, dataTopic: DataTopic.Annotations } };\n  });\n\n  const [heatmapResults, framesWithoutTableHeatmapsAndExemplars] = partition<DataFrame>(\n    framesWithoutTableAndExemplars,\n    (df) => isHeatmapResult(df, request)\n  );\n\n  const processedHeatmapFrames = mergeHeatmapFrames(\n    transformToHistogramOverTime(heatmapResults.sort(sortSeriesByLabel))\n  );\n\n  // Everything else is processed as time_series result and graph preferredVisualisationType\n  const otherFrames = framesWithoutTableHeatmapsAndExemplars.map((dataFrame) => {\n    const df = {\n      ...dataFrame,\n      meta: {\n        ...dataFrame.meta,\n        preferredVisualisationType: 'graph',\n      },\n    } as DataFrame;\n    return df;\n  });\n\n  return {\n    ...response,\n    data: [...otherFrames, ...processedTableFrames, ...processedHeatmapFrames, ...processedExemplarFrames],\n  };\n}\n\nexport function transformDFToTable(dfs: DataFrame[]): DataFrame[] {\n  // If no dataFrames or if 1 dataFrames with no values, return original dataFrame\n  if (dfs.length === 0 || (dfs.length === 1 && dfs[0].length === 0)) {\n    return dfs;\n  }\n\n  // Group results by refId and process dataFrames with the same refId as 1 dataFrame\n  const dataFramesByRefId = groupBy(dfs, 'refId');\n  const refIds = Object.keys(dataFramesByRefId);\n\n  const frames = refIds.map((refId) => {\n    // Create timeField, valueField and labelFields\n    const valueText = getValueText(refIds.length, refId);\n    const valueField = getValueField({ data: [], valueName: valueText });\n    const timeField = getTimeField([]);\n    const labelFields: MutableField[] = [];\n\n    // Fill labelsFields with labels from dataFrames\n    dataFramesByRefId[refId].forEach((df) => {\n      const frameValueField = df.fields[1];\n      const promLabels = frameValueField.labels ?? {};\n\n      Object.keys(promLabels)\n        .sort()\n        .forEach((label) => {\n          // If we don't have label in labelFields, add it\n          if (!labelFields.some((l) => l.name === label)) {\n            const numberField = label === 'le';\n            labelFields.push({\n              name: label,\n              config: { filterable: true },\n              type: numberField ? FieldType.number : FieldType.string,\n              values: new ArrayVector(),\n            });\n          }\n        });\n    });\n\n    // Fill valueField, timeField and labelFields with values\n    dataFramesByRefId[refId].forEach((df) => {\n      df.fields[0].values.toArray().forEach((value) => timeField.values.add(value));\n      df.fields[1].values.toArray().forEach((value) => {\n        valueField.values.add(parseSampleValue(value));\n        const labelsForField = df.fields[1].labels ?? {};\n        labelFields.forEach((field) => field.values.add(getLabelValue(labelsForField, field.name)));\n      });\n    });\n\n    const fields = [timeField, ...labelFields, valueField];\n    return {\n      refId,\n      fields,\n      meta: { ...dfs[0].meta, preferredVisualisationType: 'table' as PreferredVisualisationType },\n      length: timeField.values.length,\n    };\n  });\n  return frames;\n}\n\nfunction getValueText(responseLength: number, refId = '') {\n  return responseLength > 1 ? `Value #${refId}` : 'Value';\n}\n\nexport function transform(\n  response: FetchResponse<PromDataSuccessResponse>,\n  transformOptions: {\n    query: PromQueryRequest;\n    exemplarTraceIdDestinations?: ExemplarTraceIdDestination[];\n    target: PromQuery;\n    responseListLength: number;\n    scopedVars?: ScopedVars;\n  }\n) {\n  // Create options object from transformOptions\n  const options: TransformOptions = {\n    format: transformOptions.target.format,\n    step: transformOptions.query.step,\n    legendFormat: transformOptions.target.legendFormat,\n    start: transformOptions.query.start,\n    end: transformOptions.query.end,\n    query: transformOptions.query.expr,\n    responseListLength: transformOptions.responseListLength,\n    scopedVars: transformOptions.scopedVars,\n    refId: transformOptions.target.refId,\n    valueWithRefId: transformOptions.target.valueWithRefId,\n    meta: {\n      // Fix for showing of Prometheus results in Explore table\n      preferredVisualisationType: transformOptions.query.instant ? 'table' : 'graph',\n    },\n  };\n  const prometheusResult = response.data.data;\n\n  if (isExemplarData(prometheusResult)) {\n    const events: TimeAndValue[] = [];\n    prometheusResult.forEach((exemplarData) => {\n      const data = exemplarData.exemplars.map((exemplar) => {\n        return {\n          [TIME_SERIES_TIME_FIELD_NAME]: exemplar.timestamp * 1000,\n          [TIME_SERIES_VALUE_FIELD_NAME]: exemplar.value,\n          ...exemplar.labels,\n          ...exemplarData.seriesLabels,\n        };\n      });\n      events.push(...data);\n    });\n\n    // Grouping exemplars by step\n    const sampledExemplars = sampleExemplars(events, options);\n\n    const dataFrame = new ArrayDataFrame(sampledExemplars);\n    dataFrame.meta = { dataTopic: DataTopic.Annotations };\n\n    // Add data links if configured\n    if (transformOptions.exemplarTraceIdDestinations?.length) {\n      for (const exemplarTraceIdDestination of transformOptions.exemplarTraceIdDestinations) {\n        const traceIDField = dataFrame.fields.find((field) => field.name === exemplarTraceIdDestination.name);\n        if (traceIDField) {\n          const links = getDataLinks(exemplarTraceIdDestination);\n          traceIDField.config.links = traceIDField.config.links?.length\n            ? [...traceIDField.config.links, ...links]\n            : links;\n        }\n      }\n    }\n    return [dataFrame];\n  }\n\n  if (!prometheusResult?.result) {\n    return [];\n  }\n\n  // Return early if result type is scalar\n  if (prometheusResult.resultType === 'scalar') {\n    return [\n      {\n        meta: options.meta,\n        refId: options.refId,\n        length: 1,\n        fields: [getTimeField([prometheusResult.result]), getValueField({ data: [prometheusResult.result] })],\n      },\n    ];\n  }\n\n  // Return early again if the format is table, this needs special transformation.\n  if (options.format === 'table') {\n    const tableData = transformMetricDataToTable(prometheusResult.result, options);\n    return [tableData];\n  }\n\n  // Process matrix and vector results to DataFrame\n  const dataFrame: DataFrame[] = [];\n  prometheusResult.result.forEach((data: MatrixOrVectorResult) => dataFrame.push(transformToDataFrame(data, options)));\n\n  // When format is heatmap use the already created data frames and transform it more\n  if (options.format === 'heatmap') {\n    return mergeHeatmapFrames(transformToHistogramOverTime(dataFrame.sort(sortSeriesByLabel)));\n  }\n\n  // Return matrix or vector result as DataFrame[]\n  return dataFrame;\n}\n\nfunction getDataLinks(options: ExemplarTraceIdDestination): DataLink[] {\n  const dataLinks: DataLink[] = [];\n\n  if (options.datasourceUid) {\n    const dataSourceSrv = getDataSourceSrv();\n    const dsSettings = dataSourceSrv.getInstanceSettings(options.datasourceUid);\n\n    // dsSettings is undefined because of the reasons below:\n    // - permissions issues (probably most likely)\n    // - deleted datasource\n    // - misconfiguration\n    if (dsSettings) {\n      dataLinks.push({\n        title: options.urlDisplayLabel || `Query with ${dsSettings?.name}`,\n        url: '',\n        internal: {\n          query: { query: '${__value.raw}', queryType: 'traceId' },\n          datasourceUid: options.datasourceUid,\n          datasourceName: dsSettings?.name ?? 'Data source not found',\n        },\n      });\n    }\n  }\n\n  if (options.url) {\n    dataLinks.push({\n      title: options.urlDisplayLabel || `Go to ${options.url}`,\n      url: options.url,\n      targetBlank: true,\n    });\n  }\n  return dataLinks;\n}\n\n/**\n * Reduce the density of the exemplars by making sure that the highest value exemplar is included\n * and then only the ones that are 2 times the standard deviation of the all the values.\n * This makes sure not to show too many dots near each other.\n */\nfunction sampleExemplars(events: TimeAndValue[], options: TransformOptions) {\n  const step = options.step || 15;\n  const bucketedExemplars: { [ts: string]: TimeAndValue[] } = {};\n  const values: number[] = [];\n  for (const exemplar of events) {\n    // Align exemplar timestamp to nearest step second\n    const alignedTs = String(Math.floor(exemplar[TIME_SERIES_TIME_FIELD_NAME] / 1000 / step) * step * 1000);\n    if (!bucketedExemplars[alignedTs]) {\n      // New bucket found\n      bucketedExemplars[alignedTs] = [];\n    }\n    bucketedExemplars[alignedTs].push(exemplar);\n    values.push(exemplar[TIME_SERIES_VALUE_FIELD_NAME]);\n  }\n\n  // Getting exemplars from each bucket\n  const standardDeviation = deviation(values);\n  const sampledBuckets = Object.keys(bucketedExemplars).sort();\n  const sampledExemplars = [];\n  for (const ts of sampledBuckets) {\n    const exemplarsInBucket = bucketedExemplars[ts];\n    if (exemplarsInBucket.length === 1) {\n      sampledExemplars.push(exemplarsInBucket[0]);\n    } else {\n      // Choose which values to sample\n      const bucketValues = exemplarsInBucket.map((ex) => ex[TIME_SERIES_VALUE_FIELD_NAME]).sort(descending);\n      const sampledBucketValues = bucketValues.reduce((acc: number[], curr) => {\n        if (acc.length === 0) {\n          // First value is max and is always added\n          acc.push(curr);\n        } else {\n          // Then take values only when at least 2 standard deviation distance to previously taken value\n          const prev = acc[acc.length - 1];\n          if (standardDeviation && prev - curr >= 2 * standardDeviation) {\n            acc.push(curr);\n          }\n        }\n        return acc;\n      }, []);\n      // Find the exemplars for the sampled values\n      sampledExemplars.push(\n        ...sampledBucketValues.map(\n          (value) => exemplarsInBucket.find((ex) => ex[TIME_SERIES_VALUE_FIELD_NAME] === value)!\n        )\n      );\n    }\n  }\n  return sampledExemplars;\n}\n\n/**\n * Transforms matrix and vector result from Prometheus result to DataFrame\n */\nfunction transformToDataFrame(data: MatrixOrVectorResult, options: TransformOptions): DataFrame {\n  const { name, labels } = createLabelInfo(data.metric, options);\n\n  const fields: Field[] = [];\n\n  if (isMatrixData(data)) {\n    const stepMs = options.step ? options.step * 1000 : NaN;\n    let baseTimestamp = options.start * 1000;\n    const dps: PromValue[] = [];\n\n    for (const value of data.values) {\n      let dpValue: number | null = parseSampleValue(value[1]);\n\n      if (isNaN(dpValue)) {\n        dpValue = null;\n      }\n\n      const timestamp = value[0] * 1000;\n      for (let t = baseTimestamp; t < timestamp; t += stepMs) {\n        dps.push([t, null]);\n      }\n      baseTimestamp = timestamp + stepMs;\n      dps.push([timestamp, dpValue]);\n    }\n\n    const endTimestamp = options.end * 1000;\n    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {\n      dps.push([t, null]);\n    }\n    fields.push(getTimeField(dps, true));\n    fields.push(getValueField({ data: dps, parseValue: false, labels, displayNameFromDS: name }));\n  } else {\n    fields.push(getTimeField([data.value]));\n    fields.push(getValueField({ data: [data.value], labels, displayNameFromDS: name }));\n  }\n\n  return {\n    meta: options.meta,\n    refId: options.refId,\n    length: fields[0].values.length,\n    fields,\n    name,\n  };\n}\n\nfunction transformMetricDataToTable(md: MatrixOrVectorResult[], options: TransformOptions): DataFrame {\n  if (!md || md.length === 0) {\n    return {\n      meta: options.meta,\n      refId: options.refId,\n      length: 0,\n      fields: [],\n    };\n  }\n\n  const valueText = options.responseListLength > 1 || options.valueWithRefId ? `Value #${options.refId}` : 'Value';\n\n  const timeField = getTimeField([]);\n  const metricFields = Object.keys(md.reduce((acc, series) => ({ ...acc, ...series.metric }), {}))\n    .sort()\n    .map((label) => {\n      // Labels have string field type, otherwise table tries to figure out the type which can result in unexpected results\n      // Only \"le\" label has a number field type\n      const numberField = label === 'le';\n      return {\n        name: label,\n        config: { filterable: true },\n        type: numberField ? FieldType.number : FieldType.string,\n        values: new ArrayVector(),\n      };\n    });\n  const valueField = getValueField({ data: [], valueName: valueText });\n\n  md.forEach((d) => {\n    if (isMatrixData(d)) {\n      d.values.forEach((val) => {\n        timeField.values.add(val[0] * 1000);\n        metricFields.forEach((metricField) => metricField.values.add(getLabelValue(d.metric, metricField.name)));\n        valueField.values.add(parseSampleValue(val[1]));\n      });\n    } else {\n      timeField.values.add(d.value[0] * 1000);\n      metricFields.forEach((metricField) => metricField.values.add(getLabelValue(d.metric, metricField.name)));\n      valueField.values.add(parseSampleValue(d.value[1]));\n    }\n  });\n\n  return {\n    meta: options.meta,\n    refId: options.refId,\n    length: timeField.values.length,\n    fields: [timeField, ...metricFields, valueField],\n  };\n}\n\nfunction getLabelValue(metric: PromMetric, label: string): string | number {\n  if (metric.hasOwnProperty(label)) {\n    if (label === 'le') {\n      return parseSampleValue(metric[label]);\n    }\n    return metric[label];\n  }\n  return '';\n}\n\nfunction getTimeField(data: PromValue[], isMs = false): MutableField {\n  return {\n    name: TIME_SERIES_TIME_FIELD_NAME,\n    type: FieldType.time,\n    config: {},\n    values: new ArrayVector<number>(data.map((val) => (isMs ? val[0] : val[0] * 1000))),\n  };\n}\n\ntype ValueFieldOptions = {\n  data: PromValue[];\n  valueName?: string;\n  parseValue?: boolean;\n  labels?: Labels;\n  displayNameFromDS?: string;\n};\n\nfunction getValueField({\n  data,\n  valueName = TIME_SERIES_VALUE_FIELD_NAME,\n  parseValue = true,\n  labels,\n  displayNameFromDS,\n}: ValueFieldOptions): MutableField {\n  return {\n    name: valueName,\n    type: FieldType.number,\n    display: getDisplayProcessor(),\n    config: {\n      displayNameFromDS,\n    },\n    labels,\n    values: new ArrayVector<number | null>(data.map((val) => (parseValue ? parseSampleValue(val[1]) : val[1]))),\n  };\n}\n\nfunction createLabelInfo(labels: { [key: string]: string }, options: TransformOptions) {\n  if (options?.legendFormat) {\n    const title = renderLegendFormat(getTemplateSrv().replace(options.legendFormat, options?.scopedVars), labels);\n    return { name: title, labels };\n  }\n\n  const { __name__, ...labelsWithoutName } = labels;\n  const labelPart = formatLabels(labelsWithoutName);\n  let title = `${__name__ ?? ''}${labelPart}`;\n\n  if (!title) {\n    title = options.query;\n  }\n\n  return { name: title, labels: labelsWithoutName };\n}\n\nexport function getOriginalMetricName(labelData: { [key: string]: string }) {\n  const metricName = labelData.__name__ || '';\n  delete labelData.__name__;\n  const labelPart = Object.entries(labelData)\n    .map((label) => `${label[0]}=\"${label[1]}\"`)\n    .join(',');\n  return `${metricName}{${labelPart}}`;\n}\n\nfunction mergeHeatmapFrames(frames: DataFrame[]): DataFrame[] {\n  if (frames.length === 0) {\n    return [];\n  }\n\n  const timeField = frames[0].fields.find((field) => field.type === FieldType.time)!;\n  const countFields = frames.map((frame) => {\n    let field = frame.fields.find((field) => field.type === FieldType.number)!;\n\n    return {\n      ...field,\n      name: field.config.displayNameFromDS!,\n    };\n  });\n\n  return [\n    {\n      ...frames[0],\n      meta: {\n        ...frames[0].meta,\n        type: DataFrameType.HeatmapRows,\n      },\n      fields: [timeField!, ...countFields],\n    },\n  ];\n}\n\nfunction transformToHistogramOverTime(seriesList: DataFrame[]) {\n  /*      t1 = timestamp1, t2 = timestamp2 etc.\n            t1  t2  t3          t1  t2  t3\n    le10    10  10  0     =>    10  10  0\n    le20    20  10  30    =>    10  0   30\n    le30    30  10  35    =>    10  0   5\n    */\n  for (let i = seriesList.length - 1; i > 0; i--) {\n    const topSeries = seriesList[i].fields.find((s) => s.name === TIME_SERIES_VALUE_FIELD_NAME);\n    const bottomSeries = seriesList[i - 1].fields.find((s) => s.name === TIME_SERIES_VALUE_FIELD_NAME);\n    if (!topSeries || !bottomSeries) {\n      throw new Error('Prometheus heatmap transform error: data should be a time series');\n    }\n\n    for (let j = 0; j < topSeries.values.length; j++) {\n      const bottomPoint = bottomSeries.values.get(j) || [0];\n      topSeries.values.toArray()[j] -= bottomPoint;\n    }\n  }\n\n  return seriesList;\n}\n\nfunction sortSeriesByLabel(s1: DataFrame, s2: DataFrame): number {\n  let le1, le2;\n\n  try {\n    // fail if not integer. might happen with bad queries\n    le1 = parseSampleValue(s1.name ?? '');\n    le2 = parseSampleValue(s2.name ?? '');\n  } catch (err) {\n    console.error(err);\n    return 0;\n  }\n\n  if (le1 > le2) {\n    return 1;\n  }\n\n  if (le1 < le2) {\n    return -1;\n  }\n\n  return 0;\n}\n\n/** @internal */\nexport function parseSampleValue(value: string): number {\n  if (INFINITY_SAMPLE_REGEX.test(value)) {\n    return value[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  }\n  return parseFloat(value);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}