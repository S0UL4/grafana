{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { merge, ReplaySubject, Subject, Subscription, timer } from 'rxjs';\nimport { finalize, map, mapTo, mergeAll, reduce, share, takeUntil } from 'rxjs/operators';\nimport { RefreshEvent } from '@grafana/runtime';\nimport { config } from 'app/core/config';\nimport { dedupAnnotations } from 'app/features/annotations/events_processing';\nimport { getTimeSrv } from '../../../dashboard/services/TimeSrv';\nimport { AlertStatesWorker } from './AlertStatesWorker';\nimport { AnnotationsWorker } from './AnnotationsWorker';\nimport { SnapshotWorker } from './SnapshotWorker';\nimport { UnifiedAlertStatesWorker } from './UnifiedAlertStatesWorker';\nimport { getAnnotationsByPanelId } from './utils';\n\nclass DashboardQueryRunnerImpl {\n  constructor(dashboard, timeSrv = getTimeSrv(), workers = [config.unifiedAlertingEnabled ? new UnifiedAlertStatesWorker() : new AlertStatesWorker(), new SnapshotWorker(), new AnnotationsWorker()]) {\n    _defineProperty(this, \"results\", void 0);\n\n    _defineProperty(this, \"runs\", void 0);\n\n    _defineProperty(this, \"cancellationStream\", void 0);\n\n    _defineProperty(this, \"runsSubscription\", void 0);\n\n    _defineProperty(this, \"eventsSubscription\", void 0);\n\n    this.dashboard = dashboard;\n    this.timeSrv = timeSrv;\n    this.workers = workers;\n    this.run = this.run.bind(this);\n    this.getResult = this.getResult.bind(this);\n    this.cancel = this.cancel.bind(this);\n    this.destroy = this.destroy.bind(this);\n    this.executeRun = this.executeRun.bind(this);\n    this.results = new ReplaySubject(1);\n    this.runs = new Subject();\n    this.cancellationStream = new Subject();\n    this.runsSubscription = this.runs.subscribe(options => this.executeRun(options));\n    this.eventsSubscription = dashboard.events.subscribe(RefreshEvent, event => {\n      this.run({\n        dashboard: this.dashboard,\n        range: this.timeSrv.timeRange()\n      });\n    });\n  }\n\n  run(options) {\n    this.runs.next(options);\n  }\n\n  getResult(panelId) {\n    return this.results.asObservable().pipe(map(result => {\n      const annotations = getAnnotationsByPanelId(result.annotations, panelId);\n      const alertState = result.alertStates.find(res => Boolean(panelId) && res.panelId === panelId);\n      return {\n        annotations: dedupAnnotations(annotations),\n        alertState\n      };\n    }));\n  }\n\n  executeRun(options) {\n    const workers = this.workers.filter(w => w.canWork(options));\n    const workerObservables = workers.map(w => w.work(options));\n    const resultSubscription = new Subscription();\n    const resultObservable = merge(workerObservables).pipe(takeUntil(this.runs.asObservable()), mergeAll(), reduce((acc, value) => {\n      // console.log({ acc: acc.annotations.length, value: value.annotations.length });\n      // should we use scan or reduce here\n      // reduce will only emit when all observables are completed\n      // scan will emit when any observable is completed\n      // choosing reduce to minimize re-renders\n      acc.annotations = acc.annotations.concat(value.annotations);\n      acc.alertStates = acc.alertStates.concat(value.alertStates);\n      return acc;\n    }), finalize(() => {\n      resultSubscription.unsubscribe(); // important to avoid memory leaks\n    }), share() // shared because we're using it in takeUntil below\n    );\n    const timerSubscription = new Subscription();\n    const timerObservable = timer(200).pipe(mapTo({\n      annotations: [],\n      alertStates: []\n    }), takeUntil(resultObservable), finalize(() => {\n      timerSubscription.unsubscribe(); // important to avoid memory leaks\n    })); // if the result takes longer than 200ms we just publish an empty result\n\n    timerSubscription.add(timerObservable.subscribe(result => {\n      this.results.next(result);\n    }));\n    resultSubscription.add(resultObservable.subscribe(result => {\n      this.results.next(result);\n    }));\n  }\n\n  cancel(annotation) {\n    this.cancellationStream.next(annotation);\n  }\n\n  cancellations() {\n    return this.cancellationStream.asObservable().pipe(share());\n  }\n\n  destroy() {\n    this.results.complete();\n    this.runs.complete();\n    this.cancellationStream.complete();\n    this.runsSubscription.unsubscribe();\n    this.eventsSubscription.unsubscribe();\n  }\n\n}\n\nlet dashboardQueryRunner;\n\nfunction setDashboardQueryRunner(runner) {\n  if (dashboardQueryRunner) {\n    dashboardQueryRunner.destroy();\n  }\n\n  dashboardQueryRunner = runner;\n}\n\nexport function getDashboardQueryRunner() {\n  if (!dashboardQueryRunner) {\n    throw new Error('getDashboardQueryRunner can only be used after Grafana instance has started.');\n  }\n\n  return dashboardQueryRunner;\n}\nlet factory;\nexport function setDashboardQueryRunnerFactory(instance) {\n  factory = instance;\n}\nexport function createDashboardQueryRunner(args) {\n  if (!factory) {\n    factory = ({\n      dashboard,\n      timeSrv,\n      workers\n    }) => new DashboardQueryRunnerImpl(dashboard, timeSrv, workers);\n  }\n\n  const runner = factory(args);\n  setDashboardQueryRunner(runner);\n  return runner;\n}","map":{"version":3,"names":["merge","ReplaySubject","Subject","Subscription","timer","finalize","map","mapTo","mergeAll","reduce","share","takeUntil","RefreshEvent","config","dedupAnnotations","getTimeSrv","AlertStatesWorker","AnnotationsWorker","SnapshotWorker","UnifiedAlertStatesWorker","getAnnotationsByPanelId","DashboardQueryRunnerImpl","constructor","dashboard","timeSrv","workers","unifiedAlertingEnabled","run","bind","getResult","cancel","destroy","executeRun","results","runs","cancellationStream","runsSubscription","subscribe","options","eventsSubscription","events","event","range","timeRange","next","panelId","asObservable","pipe","result","annotations","alertState","alertStates","find","res","Boolean","filter","w","canWork","workerObservables","work","resultSubscription","resultObservable","acc","value","concat","unsubscribe","timerSubscription","timerObservable","add","annotation","cancellations","complete","dashboardQueryRunner","setDashboardQueryRunner","runner","getDashboardQueryRunner","Error","factory","setDashboardQueryRunnerFactory","instance","createDashboardQueryRunner","args"],"sources":["/home/soula/grafana/public/app/features/query/state/DashboardQueryRunner/DashboardQueryRunner.ts"],"sourcesContent":["import { merge, Observable, ReplaySubject, Subject, Subscription, timer, Unsubscribable } from 'rxjs';\nimport { finalize, map, mapTo, mergeAll, reduce, share, takeUntil } from 'rxjs/operators';\n\nimport { AnnotationQuery } from '@grafana/data';\nimport { RefreshEvent } from '@grafana/runtime';\nimport { config } from 'app/core/config';\nimport { dedupAnnotations } from 'app/features/annotations/events_processing';\n\nimport { getTimeSrv, TimeSrv } from '../../../dashboard/services/TimeSrv';\nimport { DashboardModel } from '../../../dashboard/state';\n\nimport { AlertStatesWorker } from './AlertStatesWorker';\nimport { AnnotationsWorker } from './AnnotationsWorker';\nimport { SnapshotWorker } from './SnapshotWorker';\nimport { UnifiedAlertStatesWorker } from './UnifiedAlertStatesWorker';\nimport {\n  DashboardQueryRunner,\n  DashboardQueryRunnerOptions,\n  DashboardQueryRunnerResult,\n  DashboardQueryRunnerWorker,\n  DashboardQueryRunnerWorkerResult,\n} from './types';\nimport { getAnnotationsByPanelId } from './utils';\n\nclass DashboardQueryRunnerImpl implements DashboardQueryRunner {\n  private readonly results: ReplaySubject<DashboardQueryRunnerWorkerResult>;\n  private readonly runs: Subject<DashboardQueryRunnerOptions>;\n  private readonly cancellationStream: Subject<AnnotationQuery>;\n  private readonly runsSubscription: Unsubscribable;\n  private readonly eventsSubscription: Unsubscribable;\n\n  constructor(\n    private readonly dashboard: DashboardModel,\n    private readonly timeSrv: TimeSrv = getTimeSrv(),\n    private readonly workers: DashboardQueryRunnerWorker[] = [\n      config.unifiedAlertingEnabled ? new UnifiedAlertStatesWorker() : new AlertStatesWorker(),\n      new SnapshotWorker(),\n      new AnnotationsWorker(),\n    ]\n  ) {\n    this.run = this.run.bind(this);\n    this.getResult = this.getResult.bind(this);\n    this.cancel = this.cancel.bind(this);\n    this.destroy = this.destroy.bind(this);\n    this.executeRun = this.executeRun.bind(this);\n    this.results = new ReplaySubject<DashboardQueryRunnerWorkerResult>(1);\n    this.runs = new Subject<DashboardQueryRunnerOptions>();\n    this.cancellationStream = new Subject<any>();\n    this.runsSubscription = this.runs.subscribe((options) => this.executeRun(options));\n    this.eventsSubscription = dashboard.events.subscribe(RefreshEvent, (event) => {\n      this.run({ dashboard: this.dashboard, range: this.timeSrv.timeRange() });\n    });\n  }\n\n  run(options: DashboardQueryRunnerOptions): void {\n    this.runs.next(options);\n  }\n\n  getResult(panelId?: number): Observable<DashboardQueryRunnerResult> {\n    return this.results.asObservable().pipe(\n      map((result) => {\n        const annotations = getAnnotationsByPanelId(result.annotations, panelId);\n        const alertState = result.alertStates.find((res) => Boolean(panelId) && res.panelId === panelId);\n        return { annotations: dedupAnnotations(annotations), alertState };\n      })\n    );\n  }\n\n  private executeRun(options: DashboardQueryRunnerOptions) {\n    const workers = this.workers.filter((w) => w.canWork(options));\n    const workerObservables = workers.map((w) => w.work(options));\n\n    const resultSubscription = new Subscription();\n    const resultObservable = merge(workerObservables).pipe(\n      takeUntil(this.runs.asObservable()),\n      mergeAll(),\n      reduce((acc: DashboardQueryRunnerWorkerResult, value: DashboardQueryRunnerWorkerResult) => {\n        // console.log({ acc: acc.annotations.length, value: value.annotations.length });\n        // should we use scan or reduce here\n        // reduce will only emit when all observables are completed\n        // scan will emit when any observable is completed\n        // choosing reduce to minimize re-renders\n        acc.annotations = acc.annotations.concat(value.annotations);\n        acc.alertStates = acc.alertStates.concat(value.alertStates);\n        return acc;\n      }),\n      finalize(() => {\n        resultSubscription.unsubscribe(); // important to avoid memory leaks\n      }),\n      share() // shared because we're using it in takeUntil below\n    );\n\n    const timerSubscription = new Subscription();\n    const timerObservable = timer(200).pipe(\n      mapTo({ annotations: [], alertStates: [] }),\n      takeUntil(resultObservable),\n      finalize(() => {\n        timerSubscription.unsubscribe(); // important to avoid memory leaks\n      })\n    );\n\n    // if the result takes longer than 200ms we just publish an empty result\n    timerSubscription.add(\n      timerObservable.subscribe((result) => {\n        this.results.next(result);\n      })\n    );\n\n    resultSubscription.add(\n      resultObservable.subscribe((result: DashboardQueryRunnerWorkerResult) => {\n        this.results.next(result);\n      })\n    );\n  }\n\n  cancel(annotation: AnnotationQuery): void {\n    this.cancellationStream.next(annotation);\n  }\n\n  cancellations(): Observable<AnnotationQuery> {\n    return this.cancellationStream.asObservable().pipe(share());\n  }\n\n  destroy(): void {\n    this.results.complete();\n    this.runs.complete();\n    this.cancellationStream.complete();\n    this.runsSubscription.unsubscribe();\n    this.eventsSubscription.unsubscribe();\n  }\n}\n\nlet dashboardQueryRunner: DashboardQueryRunner | undefined;\n\nfunction setDashboardQueryRunner(runner: DashboardQueryRunner): void {\n  if (dashboardQueryRunner) {\n    dashboardQueryRunner.destroy();\n  }\n  dashboardQueryRunner = runner;\n}\n\nexport function getDashboardQueryRunner(): DashboardQueryRunner {\n  if (!dashboardQueryRunner) {\n    throw new Error('getDashboardQueryRunner can only be used after Grafana instance has started.');\n  }\n  return dashboardQueryRunner;\n}\n\nexport interface DashboardQueryRunnerFactoryArgs {\n  dashboard: DashboardModel;\n  timeSrv?: TimeSrv;\n  workers?: DashboardQueryRunnerWorker[];\n}\n\nexport type DashboardQueryRunnerFactory = (args: DashboardQueryRunnerFactoryArgs) => DashboardQueryRunner;\n\nlet factory: DashboardQueryRunnerFactory | undefined;\n\nexport function setDashboardQueryRunnerFactory(instance: DashboardQueryRunnerFactory) {\n  factory = instance;\n}\n\nexport function createDashboardQueryRunner(args: DashboardQueryRunnerFactoryArgs): DashboardQueryRunner {\n  if (!factory) {\n    factory = ({ dashboard, timeSrv, workers }: DashboardQueryRunnerFactoryArgs) =>\n      new DashboardQueryRunnerImpl(dashboard, timeSrv, workers);\n  }\n\n  const runner = factory(args);\n  setDashboardQueryRunner(runner);\n  return runner;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}