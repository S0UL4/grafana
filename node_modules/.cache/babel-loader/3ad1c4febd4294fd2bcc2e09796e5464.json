{"ast":null,"code":"import { catchError, of, switchMap } from 'rxjs';\nimport { DataSourceApi } from '@grafana/data';\nimport { getBackendSrv, toDataQueryResponse } from '@grafana/runtime';\nexport class PublicDashboardDataSource extends DataSourceApi {\n  constructor() {\n    super({\n      name: 'public-ds',\n      id: 1,\n      type: 'public-ds',\n      meta: {},\n      uid: '1',\n      jsonData: {},\n      access: 'proxy'\n    });\n  }\n  /**\n   * Ideally final -- any other implementation may not work as expected\n   */\n\n\n  query(request) {\n    const {\n      intervalMs,\n      maxDataPoints,\n      range,\n      requestId,\n      publicDashboardAccessToken,\n      panelId\n    } = request;\n    let targets = request.targets;\n    const queries = targets.map(q => {\n      return Object.assign({}, q, {\n        publicDashboardAccessToken,\n        intervalMs,\n        maxDataPoints\n      });\n    }); // Return early if no queries exist\n\n    if (!queries.length) {\n      return of({\n        data: []\n      });\n    }\n\n    const body = {\n      queries,\n      publicDashboardAccessToken,\n      panelId\n    };\n\n    if (range) {\n      body.range = range;\n      body.from = range.from.valueOf().toString();\n      body.to = range.to.valueOf().toString();\n    }\n\n    return getBackendSrv().fetch({\n      url: `/api/public/dashboards/${publicDashboardAccessToken}/panels/${panelId}/query`,\n      method: 'POST',\n      data: body,\n      requestId\n    }).pipe(switchMap(raw => {\n      return of(toDataQueryResponse(raw, queries));\n    }), catchError(err => {\n      return of(toDataQueryResponse(err));\n    }));\n  }\n\n  testDatasource() {\n    return Promise.resolve(null);\n  }\n\n}","map":{"version":3,"names":["catchError","of","switchMap","DataSourceApi","getBackendSrv","toDataQueryResponse","PublicDashboardDataSource","constructor","name","id","type","meta","uid","jsonData","access","query","request","intervalMs","maxDataPoints","range","requestId","publicDashboardAccessToken","panelId","targets","queries","map","q","length","data","body","from","valueOf","toString","to","fetch","url","method","pipe","raw","err","testDatasource","Promise","resolve"],"sources":["/home/soula/grafana/public/app/features/dashboard/services/PublicDashboardDataSource.ts"],"sourcesContent":["import { catchError, Observable, of, switchMap } from 'rxjs';\n\nimport { DataQuery, DataQueryRequest, DataQueryResponse, DataSourceApi, PluginMeta } from '@grafana/data';\nimport { BackendDataSourceResponse, getBackendSrv, toDataQueryResponse } from '@grafana/runtime';\n\nexport class PublicDashboardDataSource extends DataSourceApi<any> {\n  constructor() {\n    super({\n      name: 'public-ds',\n      id: 1,\n      type: 'public-ds',\n      meta: {} as PluginMeta,\n      uid: '1',\n      jsonData: {},\n      access: 'proxy',\n    });\n  }\n\n  /**\n   * Ideally final -- any other implementation may not work as expected\n   */\n  query(request: DataQueryRequest<any>): Observable<DataQueryResponse> {\n    const { intervalMs, maxDataPoints, range, requestId, publicDashboardAccessToken, panelId } = request;\n    let targets = request.targets;\n\n    const queries = targets.map((q) => {\n      return {\n        ...q,\n        publicDashboardAccessToken,\n        intervalMs,\n        maxDataPoints,\n      };\n    });\n\n    // Return early if no queries exist\n    if (!queries.length) {\n      return of({ data: [] });\n    }\n\n    const body: any = { queries, publicDashboardAccessToken, panelId };\n\n    if (range) {\n      body.range = range;\n      body.from = range.from.valueOf().toString();\n      body.to = range.to.valueOf().toString();\n    }\n\n    return getBackendSrv()\n      .fetch<BackendDataSourceResponse>({\n        url: `/api/public/dashboards/${publicDashboardAccessToken}/panels/${panelId}/query`,\n        method: 'POST',\n        data: body,\n        requestId,\n      })\n      .pipe(\n        switchMap((raw) => {\n          return of(toDataQueryResponse(raw, queries as DataQuery[]));\n        }),\n        catchError((err) => {\n          return of(toDataQueryResponse(err));\n        })\n      );\n  }\n\n  testDatasource(): Promise<any> {\n    return Promise.resolve(null);\n  }\n}\n"],"mappings":"AAAA,SAASA,UAAT,EAAiCC,EAAjC,EAAqCC,SAArC,QAAsD,MAAtD;AAEA,SAAyDC,aAAzD,QAA0F,eAA1F;AACA,SAAoCC,aAApC,EAAmDC,mBAAnD,QAA8E,kBAA9E;AAEA,OAAO,MAAMC,yBAAN,SAAwCH,aAAxC,CAA2D;EAChEI,WAAW,GAAG;IACZ,MAAM;MACJC,IAAI,EAAE,WADF;MAEJC,EAAE,EAAE,CAFA;MAGJC,IAAI,EAAE,WAHF;MAIJC,IAAI,EAAE,EAJF;MAKJC,GAAG,EAAE,GALD;MAMJC,QAAQ,EAAE,EANN;MAOJC,MAAM,EAAE;IAPJ,CAAN;EASD;EAED;AACF;AACA;;;EACEC,KAAK,CAACC,OAAD,EAAgE;IACnE,MAAM;MAAEC,UAAF;MAAcC,aAAd;MAA6BC,KAA7B;MAAoCC,SAApC;MAA+CC,0BAA/C;MAA2EC;IAA3E,IAAuFN,OAA7F;IACA,IAAIO,OAAO,GAAGP,OAAO,CAACO,OAAtB;IAEA,MAAMC,OAAO,GAAGD,OAAO,CAACE,GAAR,CAAaC,CAAD,IAAO;MACjC,yBACKA,CADL;QAEEL,0BAFF;QAGEJ,UAHF;QAIEC;MAJF;IAMD,CAPe,CAAhB,CAJmE,CAanE;;IACA,IAAI,CAACM,OAAO,CAACG,MAAb,EAAqB;MACnB,OAAO1B,EAAE,CAAC;QAAE2B,IAAI,EAAE;MAAR,CAAD,CAAT;IACD;;IAED,MAAMC,IAAS,GAAG;MAAEL,OAAF;MAAWH,0BAAX;MAAuCC;IAAvC,CAAlB;;IAEA,IAAIH,KAAJ,EAAW;MACTU,IAAI,CAACV,KAAL,GAAaA,KAAb;MACAU,IAAI,CAACC,IAAL,GAAYX,KAAK,CAACW,IAAN,CAAWC,OAAX,GAAqBC,QAArB,EAAZ;MACAH,IAAI,CAACI,EAAL,GAAUd,KAAK,CAACc,EAAN,CAASF,OAAT,GAAmBC,QAAnB,EAAV;IACD;;IAED,OAAO5B,aAAa,GACjB8B,KADI,CAC6B;MAChCC,GAAG,EAAG,0BAAyBd,0BAA2B,WAAUC,OAAQ,QAD5C;MAEhCc,MAAM,EAAE,MAFwB;MAGhCR,IAAI,EAAEC,IAH0B;MAIhCT;IAJgC,CAD7B,EAOJiB,IAPI,CAQHnC,SAAS,CAAEoC,GAAD,IAAS;MACjB,OAAOrC,EAAE,CAACI,mBAAmB,CAACiC,GAAD,EAAMd,OAAN,CAApB,CAAT;IACD,CAFQ,CARN,EAWHxB,UAAU,CAAEuC,GAAD,IAAS;MAClB,OAAOtC,EAAE,CAACI,mBAAmB,CAACkC,GAAD,CAApB,CAAT;IACD,CAFS,CAXP,CAAP;EAeD;;EAEDC,cAAc,GAAiB;IAC7B,OAAOC,OAAO,CAACC,OAAR,CAAgB,IAAhB,CAAP;EACD;;AA7D+D"},"metadata":{},"sourceType":"module"}