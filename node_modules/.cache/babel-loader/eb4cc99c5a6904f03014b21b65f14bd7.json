{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { FieldType, guessFieldTypeForField } from '../index';\nexport class FieldCache {\n  constructor(data) {\n    _defineProperty(this, \"fields\", []);\n\n    _defineProperty(this, \"fieldByName\", {});\n\n    _defineProperty(this, \"fieldByType\", {});\n\n    this.fields = data.fields.map((field, idx) => Object.assign({}, field, {\n      index: idx\n    }));\n\n    for (let i = 0; i < data.fields.length; i++) {\n      const field = data.fields[i]; // Make sure it has a type\n\n      if (field.type === FieldType.other) {\n        const t = guessFieldTypeForField(field);\n\n        if (t) {\n          field.type = t;\n        }\n      }\n\n      if (!this.fieldByType[field.type]) {\n        this.fieldByType[field.type] = [];\n      }\n\n      this.fieldByType[field.type].push(Object.assign({}, field, {\n        index: i\n      }));\n\n      if (this.fieldByName[field.name]) {\n        console.warn('Duplicate field names in DataFrame: ', field.name);\n      } else {\n        this.fieldByName[field.name] = Object.assign({}, field, {\n          index: i\n        });\n      }\n    }\n  }\n\n  getFields(type) {\n    if (!type) {\n      return [...this.fields]; // All fields\n    }\n\n    const fields = this.fieldByType[type];\n\n    if (fields) {\n      return [...fields];\n    }\n\n    return [];\n  }\n\n  hasFieldOfType(type) {\n    const types = this.fieldByType[type];\n    return types && types.length > 0;\n  }\n\n  getFirstFieldOfType(type, includeHidden = false) {\n    const fields = this.fieldByType[type];\n    const firstField = fields.find(field => {\n      var _field$config$custom;\n\n      return includeHidden || !((_field$config$custom = field.config.custom) !== null && _field$config$custom !== void 0 && _field$config$custom.hidden);\n    });\n    return firstField;\n  }\n\n  hasFieldNamed(name) {\n    return !!this.fieldByName[name];\n  }\n\n  hasFieldWithNameAndType(name, type) {\n    return !!this.fieldByName[name] && this.fieldByType[type].filter(field => field.name === name).length > 0;\n  }\n  /**\n   * Returns the first field with the given name.\n   */\n\n\n  getFieldByName(name) {\n    return this.fieldByName[name];\n  }\n  /**\n   * Returns the fields with the given label.\n   */\n\n\n  getFieldsByLabel(label, value) {\n    return Object.values(this.fieldByName).filter(f => {\n      return f.labels && f.labels[label] === value;\n    });\n  }\n\n}","map":{"version":3,"names":["FieldType","guessFieldTypeForField","FieldCache","constructor","data","fields","map","field","idx","index","i","length","type","other","t","fieldByType","push","fieldByName","name","console","warn","getFields","hasFieldOfType","types","getFirstFieldOfType","includeHidden","firstField","find","config","custom","hidden","hasFieldNamed","hasFieldWithNameAndType","filter","getFieldByName","getFieldsByLabel","label","value","Object","values","f","labels"],"sources":["/home/soula/grafana/packages/grafana-data/src/dataframe/FieldCache.ts"],"sourcesContent":["import { Field, DataFrame, FieldType, guessFieldTypeForField } from '../index';\n\nexport interface FieldWithIndex extends Field {\n  index: number;\n}\n\nexport class FieldCache {\n  fields: FieldWithIndex[] = [];\n\n  private fieldByName: { [key: string]: FieldWithIndex } = {};\n  private fieldByType: { [key: string]: FieldWithIndex[] } = {};\n\n  constructor(data: DataFrame) {\n    this.fields = data.fields.map((field, idx) => ({\n      ...field,\n      index: idx,\n    }));\n\n    for (let i = 0; i < data.fields.length; i++) {\n      const field = data.fields[i];\n      // Make sure it has a type\n      if (field.type === FieldType.other) {\n        const t = guessFieldTypeForField(field);\n        if (t) {\n          field.type = t;\n        }\n      }\n      if (!this.fieldByType[field.type]) {\n        this.fieldByType[field.type] = [];\n      }\n      this.fieldByType[field.type].push({\n        ...field,\n        index: i,\n      });\n\n      if (this.fieldByName[field.name]) {\n        console.warn('Duplicate field names in DataFrame: ', field.name);\n      } else {\n        this.fieldByName[field.name] = { ...field, index: i };\n      }\n    }\n  }\n\n  getFields(type?: FieldType): FieldWithIndex[] {\n    if (!type) {\n      return [...this.fields]; // All fields\n    }\n    const fields = this.fieldByType[type];\n    if (fields) {\n      return [...fields];\n    }\n    return [];\n  }\n\n  hasFieldOfType(type: FieldType): boolean {\n    const types = this.fieldByType[type];\n    return types && types.length > 0;\n  }\n\n  getFirstFieldOfType(type: FieldType, includeHidden = false): FieldWithIndex | undefined {\n    const fields = this.fieldByType[type];\n    const firstField = fields.find((field) => includeHidden || !field.config.custom?.hidden);\n    return firstField;\n  }\n\n  hasFieldNamed(name: string): boolean {\n    return !!this.fieldByName[name];\n  }\n\n  hasFieldWithNameAndType(name: string, type: FieldType): boolean {\n    return !!this.fieldByName[name] && this.fieldByType[type].filter((field) => field.name === name).length > 0;\n  }\n\n  /**\n   * Returns the first field with the given name.\n   */\n  getFieldByName(name: string): FieldWithIndex | undefined {\n    return this.fieldByName[name];\n  }\n\n  /**\n   * Returns the fields with the given label.\n   */\n  getFieldsByLabel(label: string, value: string): FieldWithIndex[] {\n    return Object.values(this.fieldByName).filter((f) => {\n      return f.labels && f.labels[label] === value;\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}