{"ast":null,"code":"var _Spinner, _EdgeArrowMarker, _Icon;\n\nimport { css } from '@emotion/css';\nimport cx from 'classnames';\nimport React, { memo, useCallback, useMemo, useState } from 'react';\nimport useMeasure from 'react-use/lib/useMeasure';\nimport { Icon, Spinner, useStyles2, useTheme2 } from '@grafana/ui';\nimport { Edge } from './Edge';\nimport { EdgeArrowMarker } from './EdgeArrowMarker';\nimport { EdgeLabel } from './EdgeLabel';\nimport { Legend } from './Legend';\nimport { Marker } from './Marker';\nimport { Node } from './Node';\nimport { ViewControls } from './ViewControls';\nimport { defaultConfig, useLayout } from './layout';\nimport { useCategorizeFrames } from './useCategorizeFrames';\nimport { useContextMenu } from './useContextMenu';\nimport { useFocusPositionOnLayout } from './useFocusPositionOnLayout';\nimport { useHighlight } from './useHighlight';\nimport { usePanning } from './usePanning';\nimport { useZoom } from './useZoom';\nimport { processNodes } from './utils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\n\nconst getStyles = theme => ({\n  wrapper: css`\n    label: wrapper;\n    height: 100%;\n    width: 100%;\n    overflow: hidden;\n    position: relative;\n  `,\n  svg: css`\n    label: svg;\n    height: 100%;\n    width: 100%;\n    overflow: visible;\n    font-size: 10px;\n    cursor: move;\n  `,\n  svgPanning: css`\n    label: svgPanning;\n    user-select: none;\n  `,\n  noDataMsg: css`\n    height: 100%;\n    width: 100%;\n    display: grid;\n    place-items: center;\n    font-size: ${theme.typography.h4.fontSize};\n    color: ${theme.colors.text.secondary};\n  `,\n  mainGroup: css`\n    label: mainGroup;\n    will-change: transform;\n  `,\n  viewControls: css`\n    label: viewControls;\n    position: absolute;\n    left: 2px;\n    bottom: 3px;\n    right: 0;\n    display: flex;\n    align-items: flex-end;\n    justify-content: space-between;\n    pointer-events: none;\n  `,\n  legend: css`\n    label: legend;\n    background: ${theme.colors.background.secondary};\n    box-shadow: ${theme.shadows.z1};\n    padding-bottom: 5px;\n    margin-right: 10px;\n  `,\n  viewControlsWrapper: css`\n    margin-left: auto;\n  `,\n  alert: css`\n    label: alert;\n    padding: 5px 8px;\n    font-size: 10px;\n    text-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);\n    border-radius: ${theme.shape.borderRadius()};\n    align-items: center;\n    position: absolute;\n    top: 0;\n    right: 0;\n    background: ${theme.colors.warning.main};\n    color: ${theme.colors.warning.contrastText};\n  `,\n  loadingWrapper: css`\n    label: loadingWrapper;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  `\n}); // Limits the number of visible nodes, mainly for performance reasons. Nodes above the limit are accessible by expanding\n// parts of the graph. The specific number is arbitrary but should be a number of nodes where panning, zooming and other\n// interactions will be without any lag for most users.\n\n\nconst defaultNodeCountLimit = 200;\nexport function NodeGraph({\n  getLinks,\n  dataFrames,\n  nodeLimit\n}) {\n  const nodeCountLimit = nodeLimit || defaultNodeCountLimit;\n  const {\n    edges: edgesDataFrames,\n    nodes: nodesDataFrames\n  } = useCategorizeFrames(dataFrames);\n  const [measureRef, {\n    width,\n    height\n  }] = useMeasure();\n  const [config, setConfig] = useState(defaultConfig); // We need hover state here because for nodes we also highlight edges and for edges have labels separate to make\n  // sure they are visible on top of everything else\n\n  const {\n    nodeHover,\n    setNodeHover,\n    clearNodeHover,\n    edgeHover,\n    setEdgeHover,\n    clearEdgeHover\n  } = useHover();\n  const firstNodesDataFrame = nodesDataFrames[0];\n  const firstEdgesDataFrame = edgesDataFrames[0];\n  const theme = useTheme2(); // TODO we should be able to allow multiple dataframes for both edges and nodes, could be issue with node ids which in\n  //  that case should be unique or figure a way to link edges and nodes dataframes together.\n\n  const processed = useMemo(() => processNodes(firstNodesDataFrame, firstEdgesDataFrame, theme), [firstEdgesDataFrame, firstNodesDataFrame, theme]); // This is used for navigation from grid to graph view. This node will be centered and briefly highlighted.\n\n  const [focusedNodeId, setFocusedNodeId] = useState();\n  const setFocused = useCallback((e, m) => setFocusedNodeId(m.node.id), [setFocusedNodeId]); // May seem weird that we do layout first and then limit the nodes shown but the problem is we want to keep the node\n  // position stable which means we need the full layout first and then just visually hide the nodes. As hiding/showing\n  // nodes should not have effect on layout it should not be recalculated.\n\n  const {\n    nodes,\n    edges,\n    markers,\n    bounds,\n    hiddenNodesCount,\n    loading\n  } = useLayout(processed.nodes, processed.edges, config, nodeCountLimit, width, focusedNodeId); // If we move from grid to graph layout and we have focused node lets get it's position to center there. We want do\n  // do it specifically only in that case.\n\n  const focusPosition = useFocusPositionOnLayout(config, nodes, focusedNodeId);\n  const {\n    panRef,\n    zoomRef,\n    onStepUp,\n    onStepDown,\n    isPanning,\n    position,\n    scale,\n    isMaxZoom,\n    isMinZoom\n  } = usePanAndZoom(bounds, focusPosition);\n  const {\n    onEdgeOpen,\n    onNodeOpen,\n    MenuComponent\n  } = useContextMenu(getLinks, firstNodesDataFrame, firstEdgesDataFrame, config, setConfig, setFocusedNodeId);\n  const styles = useStyles2(getStyles); // This cannot be inline func or it will create infinite render cycle.\n\n  const topLevelRef = useCallback(r => {\n    measureRef(r);\n    zoomRef.current = r;\n  }, [measureRef, zoomRef]);\n  const highlightId = useHighlight(focusedNodeId);\n  return /*#__PURE__*/_jsxs(\"div\", {\n    ref: topLevelRef,\n    className: styles.wrapper,\n    children: [loading ? /*#__PURE__*/_jsxs(\"div\", {\n      className: styles.loadingWrapper,\n      children: [\"Computing layout\\xA0\", _Spinner || (_Spinner = /*#__PURE__*/_jsx(Spinner, {}))]\n    }) : null, dataFrames.length && processed.nodes.length ? /*#__PURE__*/_jsx(\"svg\", {\n      ref: panRef,\n      viewBox: `${-(width / 2)} ${-(height / 2)} ${width} ${height}`,\n      className: cx(styles.svg, isPanning && styles.svgPanning),\n      children: /*#__PURE__*/_jsxs(\"g\", {\n        className: styles.mainGroup,\n        style: {\n          transform: `scale(${scale}) translate(${Math.floor(position.x)}px, ${Math.floor(position.y)}px)`\n        },\n        children: [_EdgeArrowMarker || (_EdgeArrowMarker = /*#__PURE__*/_jsx(EdgeArrowMarker, {})), !config.gridLayout && /*#__PURE__*/_jsx(Edges, {\n          edges: edges,\n          nodeHoveringId: nodeHover,\n          edgeHoveringId: edgeHover,\n          onClick: onEdgeOpen,\n          onMouseEnter: setEdgeHover,\n          onMouseLeave: clearEdgeHover\n        }), /*#__PURE__*/_jsx(Nodes, {\n          nodes: nodes,\n          onMouseEnter: setNodeHover,\n          onMouseLeave: clearNodeHover,\n          onClick: onNodeOpen,\n          hoveringId: nodeHover || highlightId\n        }), /*#__PURE__*/_jsx(Markers, {\n          markers: markers || [],\n          onClick: setFocused\n        }), !config.gridLayout && /*#__PURE__*/_jsx(EdgeLabels, {\n          edges: edges,\n          nodeHoveringId: nodeHover,\n          edgeHoveringId: edgeHover\n        })]\n      })\n    }) : /*#__PURE__*/_jsx(\"div\", {\n      className: styles.noDataMsg,\n      children: \"No data\"\n    }), /*#__PURE__*/_jsxs(\"div\", {\n      className: styles.viewControls,\n      children: [nodes.length ? /*#__PURE__*/_jsx(\"div\", {\n        className: styles.legend,\n        children: /*#__PURE__*/_jsx(Legend, {\n          sortable: config.gridLayout,\n          nodes: nodes,\n          sort: config.sort,\n          onSort: sort => {\n            setConfig(Object.assign({}, config, {\n              sort: sort\n            }));\n          }\n        })\n      }) : null, /*#__PURE__*/_jsx(\"div\", {\n        className: styles.viewControlsWrapper,\n        children: /*#__PURE__*/_jsx(ViewControls, {\n          config: config,\n          onConfigChange: cfg => {\n            if (cfg.gridLayout !== config.gridLayout) {\n              setFocusedNodeId(undefined);\n            }\n\n            setConfig(cfg);\n          },\n          onMinus: onStepDown,\n          onPlus: onStepUp,\n          scale: scale,\n          disableZoomIn: isMaxZoom,\n          disableZoomOut: isMinZoom\n        })\n      })]\n    }), hiddenNodesCount > 0 && /*#__PURE__*/_jsxs(\"div\", {\n      className: styles.alert,\n      \"aria-label\": 'Nodes hidden warning',\n      children: [_Icon || (_Icon = /*#__PURE__*/_jsx(Icon, {\n        size: \"sm\",\n        name: 'info-circle'\n      })), \" \", hiddenNodesCount, \" nodes are hidden for performance reasons.\"]\n    }), MenuComponent]\n  });\n} // These components are here as a perf optimisation to prevent going through all nodes and edges on every pan/zoom.\n\nconst Nodes = /*#__PURE__*/memo(function Nodes(props) {\n  return /*#__PURE__*/_jsx(_Fragment, {\n    children: props.nodes.map(n => /*#__PURE__*/_jsx(Node, {\n      node: n,\n      onMouseEnter: props.onMouseEnter,\n      onMouseLeave: props.onMouseLeave,\n      onClick: props.onClick,\n      hovering: props.hoveringId === n.id\n    }, n.id))\n  });\n});\nconst Markers = /*#__PURE__*/memo(function Nodes(props) {\n  return /*#__PURE__*/_jsx(_Fragment, {\n    children: props.markers.map(m => /*#__PURE__*/_jsx(Marker, {\n      marker: m,\n      onClick: props.onClick\n    }, 'marker-' + m.node.id))\n  });\n});\nconst Edges = /*#__PURE__*/memo(function Edges(props) {\n  return /*#__PURE__*/_jsx(_Fragment, {\n    children: props.edges.map(e => /*#__PURE__*/_jsx(Edge, {\n      edge: e,\n      hovering: e.source.id === props.nodeHoveringId || e.target.id === props.nodeHoveringId || props.edgeHoveringId === e.id,\n      onClick: props.onClick,\n      onMouseEnter: props.onMouseEnter,\n      onMouseLeave: props.onMouseLeave\n    }, e.id))\n  });\n});\nconst EdgeLabels = /*#__PURE__*/memo(function EdgeLabels(props) {\n  return /*#__PURE__*/_jsx(_Fragment, {\n    children: props.edges.map((e, index) => {\n      const shouldShow = e.source.id === props.nodeHoveringId || e.target.id === props.nodeHoveringId || props.edgeHoveringId === e.id;\n      const hasStats = e.mainStat || e.secondaryStat;\n      return shouldShow && hasStats && /*#__PURE__*/_jsx(EdgeLabel, {\n        edge: e\n      }, e.id);\n    })\n  });\n});\n\nfunction usePanAndZoom(bounds, focus) {\n  const {\n    scale,\n    onStepDown,\n    onStepUp,\n    ref,\n    isMax,\n    isMin\n  } = useZoom();\n  const {\n    state: panningState,\n    ref: panRef\n  } = usePanning({\n    scale,\n    bounds,\n    focus\n  });\n  const {\n    position,\n    isPanning\n  } = panningState;\n  return {\n    zoomRef: ref,\n    panRef,\n    position,\n    isPanning,\n    scale,\n    onStepDown,\n    onStepUp,\n    isMaxZoom: isMax,\n    isMinZoom: isMin\n  };\n}\n\nfunction useHover() {\n  const [nodeHover, setNodeHover] = useState(undefined);\n  const clearNodeHover = useCallback(() => setNodeHover(undefined), [setNodeHover]);\n  const [edgeHover, setEdgeHover] = useState(undefined);\n  const clearEdgeHover = useCallback(() => setEdgeHover(undefined), [setEdgeHover]);\n  return {\n    nodeHover,\n    setNodeHover,\n    clearNodeHover,\n    edgeHover,\n    setEdgeHover,\n    clearEdgeHover\n  };\n}","map":{"version":3,"names":["css","cx","React","memo","useCallback","useMemo","useState","useMeasure","Icon","Spinner","useStyles2","useTheme2","Edge","EdgeArrowMarker","EdgeLabel","Legend","Marker","Node","ViewControls","defaultConfig","useLayout","useCategorizeFrames","useContextMenu","useFocusPositionOnLayout","useHighlight","usePanning","useZoom","processNodes","getStyles","theme","wrapper","svg","svgPanning","noDataMsg","typography","h4","fontSize","colors","text","secondary","mainGroup","viewControls","legend","background","shadows","z1","viewControlsWrapper","alert","shape","borderRadius","warning","main","contrastText","loadingWrapper","defaultNodeCountLimit","NodeGraph","getLinks","dataFrames","nodeLimit","nodeCountLimit","edges","edgesDataFrames","nodes","nodesDataFrames","measureRef","width","height","config","setConfig","nodeHover","setNodeHover","clearNodeHover","edgeHover","setEdgeHover","clearEdgeHover","useHover","firstNodesDataFrame","firstEdgesDataFrame","processed","focusedNodeId","setFocusedNodeId","setFocused","e","m","node","id","markers","bounds","hiddenNodesCount","loading","focusPosition","panRef","zoomRef","onStepUp","onStepDown","isPanning","position","scale","isMaxZoom","isMinZoom","usePanAndZoom","onEdgeOpen","onNodeOpen","MenuComponent","styles","topLevelRef","r","current","highlightId","length","transform","Math","floor","x","y","gridLayout","sort","cfg","undefined","Nodes","props","map","n","onMouseEnter","onMouseLeave","onClick","hoveringId","Markers","Edges","source","nodeHoveringId","target","edgeHoveringId","EdgeLabels","index","shouldShow","hasStats","mainStat","secondaryStat","focus","ref","isMax","isMin","state","panningState"],"sources":["/home/soula/grafana/public/app/plugins/panel/nodeGraph/NodeGraph.tsx"],"sourcesContent":["import { css } from '@emotion/css';\nimport cx from 'classnames';\nimport React, { memo, MouseEvent, MutableRefObject, useCallback, useMemo, useState } from 'react';\nimport useMeasure from 'react-use/lib/useMeasure';\n\nimport { DataFrame, GrafanaTheme2, LinkModel } from '@grafana/data';\nimport { Icon, Spinner, useStyles2, useTheme2 } from '@grafana/ui';\n\nimport { Edge } from './Edge';\nimport { EdgeArrowMarker } from './EdgeArrowMarker';\nimport { EdgeLabel } from './EdgeLabel';\nimport { Legend } from './Legend';\nimport { Marker } from './Marker';\nimport { Node } from './Node';\nimport { ViewControls } from './ViewControls';\nimport { Config, defaultConfig, useLayout } from './layout';\nimport { EdgeDatum, NodeDatum, NodesMarker } from './types';\nimport { useCategorizeFrames } from './useCategorizeFrames';\nimport { useContextMenu } from './useContextMenu';\nimport { useFocusPositionOnLayout } from './useFocusPositionOnLayout';\nimport { useHighlight } from './useHighlight';\nimport { usePanning } from './usePanning';\nimport { useZoom } from './useZoom';\nimport { processNodes, Bounds } from './utils';\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css`\n    label: wrapper;\n    height: 100%;\n    width: 100%;\n    overflow: hidden;\n    position: relative;\n  `,\n\n  svg: css`\n    label: svg;\n    height: 100%;\n    width: 100%;\n    overflow: visible;\n    font-size: 10px;\n    cursor: move;\n  `,\n\n  svgPanning: css`\n    label: svgPanning;\n    user-select: none;\n  `,\n\n  noDataMsg: css`\n    height: 100%;\n    width: 100%;\n    display: grid;\n    place-items: center;\n    font-size: ${theme.typography.h4.fontSize};\n    color: ${theme.colors.text.secondary};\n  `,\n\n  mainGroup: css`\n    label: mainGroup;\n    will-change: transform;\n  `,\n\n  viewControls: css`\n    label: viewControls;\n    position: absolute;\n    left: 2px;\n    bottom: 3px;\n    right: 0;\n    display: flex;\n    align-items: flex-end;\n    justify-content: space-between;\n    pointer-events: none;\n  `,\n  legend: css`\n    label: legend;\n    background: ${theme.colors.background.secondary};\n    box-shadow: ${theme.shadows.z1};\n    padding-bottom: 5px;\n    margin-right: 10px;\n  `,\n  viewControlsWrapper: css`\n    margin-left: auto;\n  `,\n  alert: css`\n    label: alert;\n    padding: 5px 8px;\n    font-size: 10px;\n    text-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);\n    border-radius: ${theme.shape.borderRadius()};\n    align-items: center;\n    position: absolute;\n    top: 0;\n    right: 0;\n    background: ${theme.colors.warning.main};\n    color: ${theme.colors.warning.contrastText};\n  `,\n  loadingWrapper: css`\n    label: loadingWrapper;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  `,\n});\n\n// Limits the number of visible nodes, mainly for performance reasons. Nodes above the limit are accessible by expanding\n// parts of the graph. The specific number is arbitrary but should be a number of nodes where panning, zooming and other\n// interactions will be without any lag for most users.\nconst defaultNodeCountLimit = 200;\n\ninterface Props {\n  dataFrames: DataFrame[];\n  getLinks: (dataFrame: DataFrame, rowIndex: number) => LinkModel[];\n  nodeLimit?: number;\n}\nexport function NodeGraph({ getLinks, dataFrames, nodeLimit }: Props) {\n  const nodeCountLimit = nodeLimit || defaultNodeCountLimit;\n  const { edges: edgesDataFrames, nodes: nodesDataFrames } = useCategorizeFrames(dataFrames);\n\n  const [measureRef, { width, height }] = useMeasure();\n  const [config, setConfig] = useState<Config>(defaultConfig);\n\n  // We need hover state here because for nodes we also highlight edges and for edges have labels separate to make\n  // sure they are visible on top of everything else\n  const { nodeHover, setNodeHover, clearNodeHover, edgeHover, setEdgeHover, clearEdgeHover } = useHover();\n\n  const firstNodesDataFrame = nodesDataFrames[0];\n  const firstEdgesDataFrame = edgesDataFrames[0];\n\n  const theme = useTheme2();\n\n  // TODO we should be able to allow multiple dataframes for both edges and nodes, could be issue with node ids which in\n  //  that case should be unique or figure a way to link edges and nodes dataframes together.\n  const processed = useMemo(\n    () => processNodes(firstNodesDataFrame, firstEdgesDataFrame, theme),\n    [firstEdgesDataFrame, firstNodesDataFrame, theme]\n  );\n\n  // This is used for navigation from grid to graph view. This node will be centered and briefly highlighted.\n  const [focusedNodeId, setFocusedNodeId] = useState<string>();\n  const setFocused = useCallback((e: MouseEvent, m: NodesMarker) => setFocusedNodeId(m.node.id), [setFocusedNodeId]);\n\n  // May seem weird that we do layout first and then limit the nodes shown but the problem is we want to keep the node\n  // position stable which means we need the full layout first and then just visually hide the nodes. As hiding/showing\n  // nodes should not have effect on layout it should not be recalculated.\n  const { nodes, edges, markers, bounds, hiddenNodesCount, loading } = useLayout(\n    processed.nodes,\n    processed.edges,\n    config,\n    nodeCountLimit,\n    width,\n    focusedNodeId\n  );\n\n  // If we move from grid to graph layout and we have focused node lets get it's position to center there. We want do\n  // do it specifically only in that case.\n  const focusPosition = useFocusPositionOnLayout(config, nodes, focusedNodeId);\n  const { panRef, zoomRef, onStepUp, onStepDown, isPanning, position, scale, isMaxZoom, isMinZoom } = usePanAndZoom(\n    bounds,\n    focusPosition\n  );\n\n  const { onEdgeOpen, onNodeOpen, MenuComponent } = useContextMenu(\n    getLinks,\n    firstNodesDataFrame,\n    firstEdgesDataFrame,\n    config,\n    setConfig,\n    setFocusedNodeId\n  );\n  const styles = useStyles2(getStyles);\n\n  // This cannot be inline func or it will create infinite render cycle.\n  const topLevelRef = useCallback(\n    (r) => {\n      measureRef(r);\n      (zoomRef as MutableRefObject<HTMLElement | null>).current = r;\n    },\n    [measureRef, zoomRef]\n  );\n\n  const highlightId = useHighlight(focusedNodeId);\n\n  return (\n    <div ref={topLevelRef} className={styles.wrapper}>\n      {loading ? (\n        <div className={styles.loadingWrapper}>\n          Computing layout&nbsp;\n          <Spinner />\n        </div>\n      ) : null}\n\n      {dataFrames.length && processed.nodes.length ? (\n        <svg\n          ref={panRef}\n          viewBox={`${-(width / 2)} ${-(height / 2)} ${width} ${height}`}\n          className={cx(styles.svg, isPanning && styles.svgPanning)}\n        >\n          <g\n            className={styles.mainGroup}\n            style={{ transform: `scale(${scale}) translate(${Math.floor(position.x)}px, ${Math.floor(position.y)}px)` }}\n          >\n            <EdgeArrowMarker />\n            {!config.gridLayout && (\n              <Edges\n                edges={edges}\n                nodeHoveringId={nodeHover}\n                edgeHoveringId={edgeHover}\n                onClick={onEdgeOpen}\n                onMouseEnter={setEdgeHover}\n                onMouseLeave={clearEdgeHover}\n              />\n            )}\n            <Nodes\n              nodes={nodes}\n              onMouseEnter={setNodeHover}\n              onMouseLeave={clearNodeHover}\n              onClick={onNodeOpen}\n              hoveringId={nodeHover || highlightId}\n            />\n\n            <Markers markers={markers || []} onClick={setFocused} />\n            {/*We split the labels from edges so that they are shown on top of everything else*/}\n            {!config.gridLayout && <EdgeLabels edges={edges} nodeHoveringId={nodeHover} edgeHoveringId={edgeHover} />}\n          </g>\n        </svg>\n      ) : (\n        <div className={styles.noDataMsg}>No data</div>\n      )}\n\n      <div className={styles.viewControls}>\n        {nodes.length ? (\n          <div className={styles.legend}>\n            <Legend\n              sortable={config.gridLayout}\n              nodes={nodes}\n              sort={config.sort}\n              onSort={(sort) => {\n                setConfig({\n                  ...config,\n                  sort: sort,\n                });\n              }}\n            />\n          </div>\n        ) : null}\n\n        <div className={styles.viewControlsWrapper}>\n          <ViewControls<Config>\n            config={config}\n            onConfigChange={(cfg) => {\n              if (cfg.gridLayout !== config.gridLayout) {\n                setFocusedNodeId(undefined);\n              }\n              setConfig(cfg);\n            }}\n            onMinus={onStepDown}\n            onPlus={onStepUp}\n            scale={scale}\n            disableZoomIn={isMaxZoom}\n            disableZoomOut={isMinZoom}\n          />\n        </div>\n      </div>\n\n      {hiddenNodesCount > 0 && (\n        <div className={styles.alert} aria-label={'Nodes hidden warning'}>\n          <Icon size=\"sm\" name={'info-circle'} /> {hiddenNodesCount} nodes are hidden for performance reasons.\n        </div>\n      )}\n\n      {MenuComponent}\n    </div>\n  );\n}\n\n// These components are here as a perf optimisation to prevent going through all nodes and edges on every pan/zoom.\n\ninterface NodesProps {\n  nodes: NodeDatum[];\n  onMouseEnter: (id: string) => void;\n  onMouseLeave: (id: string) => void;\n  onClick: (event: MouseEvent<SVGElement>, node: NodeDatum) => void;\n  hoveringId?: string;\n}\nconst Nodes = memo(function Nodes(props: NodesProps) {\n  return (\n    <>\n      {props.nodes.map((n) => (\n        <Node\n          key={n.id}\n          node={n}\n          onMouseEnter={props.onMouseEnter}\n          onMouseLeave={props.onMouseLeave}\n          onClick={props.onClick}\n          hovering={props.hoveringId === n.id}\n        />\n      ))}\n    </>\n  );\n});\n\ninterface MarkersProps {\n  markers: NodesMarker[];\n  onClick: (event: MouseEvent<SVGElement>, marker: NodesMarker) => void;\n}\nconst Markers = memo(function Nodes(props: MarkersProps) {\n  return (\n    <>\n      {props.markers.map((m) => (\n        <Marker key={'marker-' + m.node.id} marker={m} onClick={props.onClick} />\n      ))}\n    </>\n  );\n});\n\ninterface EdgesProps {\n  edges: EdgeDatum[];\n  nodeHoveringId?: string;\n  edgeHoveringId?: string;\n  onClick: (event: MouseEvent<SVGElement>, link: EdgeDatum) => void;\n  onMouseEnter: (id: string) => void;\n  onMouseLeave: (id: string) => void;\n}\nconst Edges = memo(function Edges(props: EdgesProps) {\n  return (\n    <>\n      {props.edges.map((e) => (\n        <Edge\n          key={e.id}\n          edge={e}\n          hovering={\n            (e.source as NodeDatum).id === props.nodeHoveringId ||\n            (e.target as NodeDatum).id === props.nodeHoveringId ||\n            props.edgeHoveringId === e.id\n          }\n          onClick={props.onClick}\n          onMouseEnter={props.onMouseEnter}\n          onMouseLeave={props.onMouseLeave}\n        />\n      ))}\n    </>\n  );\n});\n\ninterface EdgeLabelsProps {\n  edges: EdgeDatum[];\n  nodeHoveringId?: string;\n  edgeHoveringId?: string;\n}\nconst EdgeLabels = memo(function EdgeLabels(props: EdgeLabelsProps) {\n  return (\n    <>\n      {props.edges.map((e, index) => {\n        const shouldShow =\n          (e.source as NodeDatum).id === props.nodeHoveringId ||\n          (e.target as NodeDatum).id === props.nodeHoveringId ||\n          props.edgeHoveringId === e.id;\n        const hasStats = e.mainStat || e.secondaryStat;\n        return shouldShow && hasStats && <EdgeLabel key={e.id} edge={e} />;\n      })}\n    </>\n  );\n});\n\nfunction usePanAndZoom(bounds: Bounds, focus?: { x: number; y: number }) {\n  const { scale, onStepDown, onStepUp, ref, isMax, isMin } = useZoom();\n  const { state: panningState, ref: panRef } = usePanning<SVGSVGElement>({\n    scale,\n    bounds,\n    focus,\n  });\n  const { position, isPanning } = panningState;\n  return { zoomRef: ref, panRef, position, isPanning, scale, onStepDown, onStepUp, isMaxZoom: isMax, isMinZoom: isMin };\n}\n\nfunction useHover() {\n  const [nodeHover, setNodeHover] = useState<string | undefined>(undefined);\n  const clearNodeHover = useCallback(() => setNodeHover(undefined), [setNodeHover]);\n  const [edgeHover, setEdgeHover] = useState<string | undefined>(undefined);\n  const clearEdgeHover = useCallback(() => setEdgeHover(undefined), [setEdgeHover]);\n\n  return { nodeHover, setNodeHover, clearNodeHover, edgeHover, setEdgeHover, clearEdgeHover };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}