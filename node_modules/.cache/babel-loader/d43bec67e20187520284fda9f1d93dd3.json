{"ast":null,"code":"import { getCenter } from 'ol/extent';\nimport { Point } from 'ol/geom';\nimport { FieldType, toDataFrame } from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { frameFromGeoJSON } from '../format/geojson';\nimport { pointFieldFromLonLat, pointFieldFromGeohash } from '../format/utils';\nimport { loadWorldmapPoints } from './worldmap';\n// Without knowing the datatype pick a good lookup function\nexport function loadGazetteer(path, data) {\n  // try loading geojson\n  let frame = undefined;\n\n  if (Array.isArray(data)) {\n    const first = data[0]; // Check for legacy worldmap syntax\n\n    if (first.latitude && first.longitude && (first.key || first.keys)) {\n      return loadWorldmapPoints(path, data);\n    }\n  } else {\n    if (Array.isArray(data === null || data === void 0 ? void 0 : data.features) && (data === null || data === void 0 ? void 0 : data.type) === 'FeatureCollection') {\n      frame = frameFromGeoJSON(data);\n    }\n  }\n\n  if (!frame) {\n    try {\n      frame = toDataFrame(data);\n    } catch (ex) {\n      return {\n        path,\n        error: `${ex}`,\n        find: k => undefined,\n        examples: v => []\n      };\n    }\n  }\n\n  return frameAsGazetter(frame, {\n    path\n  });\n}\nexport function frameAsGazetter(frame, opts) {\n  const keys = [];\n  let geo = undefined;\n  let lat = undefined;\n  let lng = undefined;\n  let geohash = undefined;\n  let firstString = undefined;\n\n  for (const f of frame.fields) {\n    if (f.type === FieldType.geo) {\n      geo = f;\n    }\n\n    if (!firstString && f.type === FieldType.string) {\n      firstString = f;\n    }\n\n    if (f.name) {\n      if (opts.keys && opts.keys.includes(f.name)) {\n        keys.push(f);\n      }\n\n      const name = f.name.toUpperCase();\n\n      switch (name) {\n        case 'LAT':\n        case 'LATITUTE':\n          lat = f;\n          break;\n\n        case 'LON':\n        case 'LNG':\n        case 'LONG':\n        case 'LONGITUE':\n          lng = f;\n          break;\n\n        case 'GEOHASH':\n          geohash = f;\n          break;\n\n        case 'ID':\n        case 'UID':\n        case 'KEY':\n        case 'CODE':\n          if (!opts.keys) {\n            keys.push(f);\n          }\n\n          break;\n\n        default:\n          {\n            if (!opts.keys) {\n              if (name.endsWith('_ID') || name.endsWith('_CODE')) {\n                keys.push(f);\n              }\n            }\n          }\n      }\n    }\n  } // Use the first string field\n\n\n  if (!keys.length && firstString) {\n    keys.push(firstString);\n  }\n\n  let isPoint = false; // Create a geo field from lat+lng\n\n  if (!geo) {\n    if (geohash) {\n      geo = pointFieldFromGeohash(geohash);\n      isPoint = true;\n    } else if (lat && lng) {\n      geo = pointFieldFromLonLat(lng, lat);\n      isPoint = true;\n    }\n  } else {\n    isPoint = geo.values.get(0).getType() === 'Point';\n  }\n\n  const lookup = new Map();\n  keys.forEach(f => {\n    f.values.toArray().forEach((k, idx) => {\n      const str = `${k}`;\n      lookup.set(str.toUpperCase(), idx);\n      lookup.set(str, idx);\n    });\n  });\n  return {\n    path: opts.path,\n    find: k => {\n      const index = lookup.get(k);\n\n      if (index != null) {\n        var _geo;\n\n        const g = (_geo = geo) === null || _geo === void 0 ? void 0 : _geo.values.get(index);\n        return {\n          frame,\n          index,\n          point: () => {\n            if (!g || isPoint) {\n              return g;\n            }\n\n            return new Point(getCenter(g.getExtent()));\n          },\n          geometry: () => g\n        };\n      }\n\n      return undefined;\n    },\n    examples: v => {\n      const ex = [];\n\n      for (let k of lookup.keys()) {\n        ex.push(k);\n\n        if (ex.length > v) {\n          break;\n        }\n      }\n\n      return ex;\n    },\n    frame: () => frame,\n    count: frame.length\n  };\n}\nconst registry = {};\nexport const COUNTRIES_GAZETTEER_PATH = 'public/gazetteer/countries.json';\n/**\n * Given a path to a file return a cached lookup function\n */\n\nexport async function getGazetteer(path) {\n  // When not specified, use the default path\n  if (!path) {\n    path = COUNTRIES_GAZETTEER_PATH;\n  }\n\n  let lookup = registry[path];\n\n  if (!lookup) {\n    try {\n      // block the async function\n      const data = await getBackendSrv().get(path);\n      lookup = loadGazetteer(path, data);\n    } catch (err) {\n      console.warn('Error loading placename lookup', path, err);\n      lookup = {\n        path,\n        error: 'Error loading URL',\n        find: k => undefined,\n        examples: v => []\n      };\n    }\n\n    registry[path] = lookup;\n  }\n\n  return lookup;\n}","map":{"version":3,"names":["getCenter","Point","FieldType","toDataFrame","getBackendSrv","frameFromGeoJSON","pointFieldFromLonLat","pointFieldFromGeohash","loadWorldmapPoints","loadGazetteer","path","data","frame","undefined","Array","isArray","first","latitude","longitude","key","keys","features","type","ex","error","find","k","examples","v","frameAsGazetter","opts","geo","lat","lng","geohash","firstString","f","fields","string","name","includes","push","toUpperCase","endsWith","length","isPoint","values","get","getType","lookup","Map","forEach","toArray","idx","str","set","index","g","point","getExtent","geometry","count","registry","COUNTRIES_GAZETTEER_PATH","getGazetteer","err","console","warn"],"sources":["/home/soula/grafana/public/app/features/geo/gazetteer/gazetteer.ts"],"sourcesContent":["import { getCenter } from 'ol/extent';\nimport { Geometry, Point } from 'ol/geom';\n\nimport { DataFrame, Field, FieldType, KeyValue, toDataFrame } from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\n\nimport { frameFromGeoJSON } from '../format/geojson';\nimport { pointFieldFromLonLat, pointFieldFromGeohash } from '../format/utils';\n\nimport { loadWorldmapPoints } from './worldmap';\n\nexport interface PlacenameInfo {\n  point: () => Point | undefined; // lon, lat (WGS84)\n  geometry: () => Geometry | undefined;\n  frame?: DataFrame;\n  index?: number;\n}\n\nexport interface Gazetteer {\n  path: string;\n  error?: string;\n  find: (key: string) => PlacenameInfo | undefined;\n  examples: (count: number) => string[];\n  frame?: () => DataFrame;\n  count?: number;\n}\n\n// Without knowing the datatype pick a good lookup function\nexport function loadGazetteer(path: string, data: any): Gazetteer {\n  // try loading geojson\n  let frame: DataFrame | undefined = undefined;\n\n  if (Array.isArray(data)) {\n    const first = data[0] as any;\n    // Check for legacy worldmap syntax\n    if (first.latitude && first.longitude && (first.key || first.keys)) {\n      return loadWorldmapPoints(path, data);\n    }\n  } else {\n    if (Array.isArray(data?.features) && data?.type === 'FeatureCollection') {\n      frame = frameFromGeoJSON(data);\n    }\n  }\n\n  if (!frame) {\n    try {\n      frame = toDataFrame(data);\n    } catch (ex) {\n      return {\n        path,\n        error: `${ex}`,\n        find: (k) => undefined,\n        examples: (v) => [],\n      };\n    }\n  }\n\n  return frameAsGazetter(frame, { path });\n}\n\nexport function frameAsGazetter(frame: DataFrame, opts: { path: string; keys?: string[] }): Gazetteer {\n  const keys: Field[] = [];\n  let geo: Field<Geometry> | undefined = undefined;\n  let lat: Field | undefined = undefined;\n  let lng: Field | undefined = undefined;\n  let geohash: Field | undefined = undefined;\n  let firstString: Field | undefined = undefined;\n  for (const f of frame.fields) {\n    if (f.type === FieldType.geo) {\n      geo = f;\n    }\n    if (!firstString && f.type === FieldType.string) {\n      firstString = f;\n    }\n    if (f.name) {\n      if (opts.keys && opts.keys.includes(f.name)) {\n        keys.push(f);\n      }\n\n      const name = f.name.toUpperCase();\n      switch (name) {\n        case 'LAT':\n        case 'LATITUTE':\n          lat = f;\n          break;\n\n        case 'LON':\n        case 'LNG':\n        case 'LONG':\n        case 'LONGITUE':\n          lng = f;\n          break;\n\n        case 'GEOHASH':\n          geohash = f;\n          break;\n\n        case 'ID':\n        case 'UID':\n        case 'KEY':\n        case 'CODE':\n          if (!opts.keys) {\n            keys.push(f);\n          }\n          break;\n\n        default: {\n          if (!opts.keys) {\n            if (name.endsWith('_ID') || name.endsWith('_CODE')) {\n              keys.push(f);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Use the first string field\n  if (!keys.length && firstString) {\n    keys.push(firstString);\n  }\n\n  let isPoint = false;\n\n  // Create a geo field from lat+lng\n  if (!geo) {\n    if (geohash) {\n      geo = pointFieldFromGeohash(geohash);\n      isPoint = true;\n    } else if (lat && lng) {\n      geo = pointFieldFromLonLat(lng, lat);\n      isPoint = true;\n    }\n  } else {\n    isPoint = geo.values.get(0).getType() === 'Point';\n  }\n\n  const lookup = new Map<string, number>();\n  keys.forEach((f) => {\n    f.values.toArray().forEach((k, idx) => {\n      const str = `${k}`;\n      lookup.set(str.toUpperCase(), idx);\n      lookup.set(str, idx);\n    });\n  });\n\n  return {\n    path: opts.path,\n    find: (k) => {\n      const index = lookup.get(k);\n      if (index != null) {\n        const g = geo?.values.get(index);\n        return {\n          frame,\n          index,\n          point: () => {\n            if (!g || isPoint) {\n              return g as Point;\n            }\n            return new Point(getCenter(g.getExtent()));\n          },\n          geometry: () => g,\n        };\n      }\n      return undefined;\n    },\n    examples: (v) => {\n      const ex: string[] = [];\n      for (let k of lookup.keys()) {\n        ex.push(k);\n        if (ex.length > v) {\n          break;\n        }\n      }\n      return ex;\n    },\n    frame: () => frame,\n    count: frame.length,\n  };\n}\n\nconst registry: KeyValue<Gazetteer> = {};\n\nexport const COUNTRIES_GAZETTEER_PATH = 'public/gazetteer/countries.json';\n\n/**\n * Given a path to a file return a cached lookup function\n */\nexport async function getGazetteer(path?: string): Promise<Gazetteer> {\n  // When not specified, use the default path\n  if (!path) {\n    path = COUNTRIES_GAZETTEER_PATH;\n  }\n\n  let lookup = registry[path];\n  if (!lookup) {\n    try {\n      // block the async function\n      const data = await getBackendSrv().get(path!);\n      lookup = loadGazetteer(path, data);\n    } catch (err) {\n      console.warn('Error loading placename lookup', path, err);\n      lookup = {\n        path,\n        error: 'Error loading URL',\n        find: (k) => undefined,\n        examples: (v) => [],\n      };\n    }\n    registry[path] = lookup;\n  }\n  return lookup;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}