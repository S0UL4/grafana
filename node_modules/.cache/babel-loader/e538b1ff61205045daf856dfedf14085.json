{"ast":null,"code":"import { chunk, initial, startCase, uniqBy } from 'lodash';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport { AGGREGATIONS, ALIGNMENTS, SYSTEM_LABELS } from './constants';\nimport { AlignmentTypes, MetricKind, PreprocessorType, ValueTypes } from './types';\nconst templateSrv = getTemplateSrv();\nexport const extractServicesFromMetricDescriptors = metricDescriptors => uniqBy(metricDescriptors, 'service');\nexport const getMetricTypesByService = (metricDescriptors, service) => metricDescriptors.filter(m => m.service === service);\nexport const getMetricTypes = (metricDescriptors, metricType, interpolatedMetricType, selectedService) => {\n  const metricTypes = getMetricTypesByService(metricDescriptors, selectedService).map(m => ({\n    value: m.type,\n    name: m.displayName\n  }));\n  const metricTypeExistInArray = metricTypes.some(m => m.value === interpolatedMetricType);\n  const metricTypeByService = metricTypes.length ? metricTypes[0].value : '';\n  const selectedMetricType = metricTypeExistInArray ? metricType : metricTypeByService;\n  return {\n    metricTypes,\n    selectedMetricType\n  };\n};\nexport const getAlignmentOptionsByMetric = (metricValueType, metricKind, preprocessor) => {\n  if (preprocessor && preprocessor === PreprocessorType.Rate) {\n    metricKind = MetricKind.GAUGE;\n  }\n\n  return !metricValueType ? [] : ALIGNMENTS.filter(i => {\n    return i.valueTypes.indexOf(metricValueType) !== -1 && i.metricKinds.indexOf(metricKind) !== -1;\n  });\n};\nexport const getAggregationOptionsByMetric = (valueType, metricKind) => {\n  return !metricKind ? [] : AGGREGATIONS.filter(i => {\n    return i.valueTypes.indexOf(valueType) !== -1 && i.metricKinds.indexOf(metricKind) !== -1;\n  });\n};\nexport const getLabelKeys = async (datasource, selectedMetricType, projectName) => {\n  const refId = 'handleLabelKeysQuery';\n  const labels = await datasource.getLabels(selectedMetricType, refId, projectName);\n  return [...Object.keys(labels), ...SYSTEM_LABELS];\n};\nexport const getAlignmentPickerData = (valueType = ValueTypes.DOUBLE, metricKind = MetricKind.GAUGE, perSeriesAligner = AlignmentTypes.ALIGN_MEAN, preprocessor) => {\n  const alignOptions = getAlignmentOptionsByMetric(valueType, metricKind, preprocessor).map(option => Object.assign({}, option, {\n    label: option.text\n  }));\n\n  if (!alignOptions.some(o => o.value === templateSrv.replace(perSeriesAligner))) {\n    perSeriesAligner = alignOptions.length > 0 ? alignOptions[0].value : AlignmentTypes.ALIGN_MEAN;\n  }\n\n  return {\n    alignOptions,\n    perSeriesAligner\n  };\n};\nexport const labelsToGroupedOptions = groupBys => {\n  const groups = groupBys.reduce((acc, curr) => {\n    const arr = curr.split('.').map(startCase);\n    const group = (arr.length === 2 ? arr : initial(arr)).join(' ');\n    const option = {\n      value: curr,\n      label: curr\n    };\n\n    if (acc[group]) {\n      acc[group] = [...acc[group], option];\n    } else {\n      acc[group] = [option];\n    }\n\n    return acc;\n  }, {});\n  return Object.entries(groups).map(([label, options]) => ({\n    label,\n    options,\n    expanded: true\n  }), []);\n};\nexport const stringArrayToFilters = filterArray => chunk(filterArray, 4).map(([key, operator, value, condition = 'AND']) => ({\n  key,\n  operator,\n  value,\n  condition\n}));","map":{"version":3,"names":["chunk","initial","startCase","uniqBy","getTemplateSrv","AGGREGATIONS","ALIGNMENTS","SYSTEM_LABELS","AlignmentTypes","MetricKind","PreprocessorType","ValueTypes","templateSrv","extractServicesFromMetricDescriptors","metricDescriptors","getMetricTypesByService","service","filter","m","getMetricTypes","metricType","interpolatedMetricType","selectedService","metricTypes","map","value","type","name","displayName","metricTypeExistInArray","some","metricTypeByService","length","selectedMetricType","getAlignmentOptionsByMetric","metricValueType","metricKind","preprocessor","Rate","GAUGE","i","valueTypes","indexOf","metricKinds","getAggregationOptionsByMetric","valueType","getLabelKeys","datasource","projectName","refId","labels","getLabels","Object","keys","getAlignmentPickerData","DOUBLE","perSeriesAligner","ALIGN_MEAN","alignOptions","option","label","text","o","replace","labelsToGroupedOptions","groupBys","groups","reduce","acc","curr","arr","split","group","join","entries","options","expanded","stringArrayToFilters","filterArray","key","operator","condition"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloud-monitoring/functions.ts"],"sourcesContent":["import { chunk, initial, startCase, uniqBy } from 'lodash';\n\nimport { getTemplateSrv, TemplateSrv } from '@grafana/runtime';\n\nimport { AGGREGATIONS, ALIGNMENTS, SYSTEM_LABELS } from './constants';\nimport CloudMonitoringDatasource from './datasource';\nimport { AlignmentTypes, MetricDescriptor, MetricKind, PreprocessorType, ValueTypes } from './types';\n\nconst templateSrv: TemplateSrv = getTemplateSrv();\n\nexport const extractServicesFromMetricDescriptors = (metricDescriptors: MetricDescriptor[]) =>\n  uniqBy(metricDescriptors, 'service');\n\nexport const getMetricTypesByService = (metricDescriptors: MetricDescriptor[], service: string) =>\n  metricDescriptors.filter((m: MetricDescriptor) => m.service === service);\n\nexport const getMetricTypes = (\n  metricDescriptors: MetricDescriptor[],\n  metricType: string,\n  interpolatedMetricType: string,\n  selectedService: string\n) => {\n  const metricTypes = getMetricTypesByService(metricDescriptors, selectedService).map((m) => ({\n    value: m.type,\n    name: m.displayName,\n  }));\n  const metricTypeExistInArray = metricTypes.some(\n    (m: { value: string; name: string }) => m.value === interpolatedMetricType\n  );\n  const metricTypeByService = metricTypes.length ? metricTypes[0].value : '';\n  const selectedMetricType = metricTypeExistInArray ? metricType : metricTypeByService;\n  return {\n    metricTypes,\n    selectedMetricType,\n  };\n};\n\nexport const getAlignmentOptionsByMetric = (\n  metricValueType: string,\n  metricKind: string,\n  preprocessor?: PreprocessorType\n) => {\n  if (preprocessor && preprocessor === PreprocessorType.Rate) {\n    metricKind = MetricKind.GAUGE;\n  }\n\n  return !metricValueType\n    ? []\n    : ALIGNMENTS.filter((i) => {\n        return (\n          i.valueTypes.indexOf(metricValueType as ValueTypes) !== -1 &&\n          i.metricKinds.indexOf(metricKind as MetricKind) !== -1\n        );\n      });\n};\n\nexport const getAggregationOptionsByMetric = (valueType: ValueTypes, metricKind: MetricKind) => {\n  return !metricKind\n    ? []\n    : AGGREGATIONS.filter((i) => {\n        return i.valueTypes.indexOf(valueType) !== -1 && i.metricKinds.indexOf(metricKind) !== -1;\n      });\n};\n\nexport const getLabelKeys = async (\n  datasource: CloudMonitoringDatasource,\n  selectedMetricType: string,\n  projectName: string\n) => {\n  const refId = 'handleLabelKeysQuery';\n  const labels = await datasource.getLabels(selectedMetricType, refId, projectName);\n  return [...Object.keys(labels), ...SYSTEM_LABELS];\n};\n\nexport const getAlignmentPickerData = (\n  valueType: string | undefined = ValueTypes.DOUBLE,\n  metricKind: string | undefined = MetricKind.GAUGE,\n  perSeriesAligner: string | undefined = AlignmentTypes.ALIGN_MEAN,\n  preprocessor?: PreprocessorType\n) => {\n  const alignOptions = getAlignmentOptionsByMetric(valueType!, metricKind!, preprocessor!).map((option) => ({\n    ...option,\n    label: option.text,\n  }));\n  if (!alignOptions.some((o: { value: string }) => o.value === templateSrv.replace(perSeriesAligner))) {\n    perSeriesAligner = alignOptions.length > 0 ? alignOptions[0].value : AlignmentTypes.ALIGN_MEAN;\n  }\n  return { alignOptions, perSeriesAligner };\n};\n\nexport const labelsToGroupedOptions = (groupBys: string[]) => {\n  const groups = groupBys.reduce((acc: any, curr: string) => {\n    const arr = curr.split('.').map(startCase);\n    const group = (arr.length === 2 ? arr : initial(arr)).join(' ');\n    const option = {\n      value: curr,\n      label: curr,\n    };\n    if (acc[group]) {\n      acc[group] = [...acc[group], option];\n    } else {\n      acc[group] = [option];\n    }\n    return acc;\n  }, {});\n  return Object.entries(groups).map(([label, options]) => ({ label, options, expanded: true }), []);\n};\n\nexport const stringArrayToFilters = (filterArray: string[]) =>\n  chunk(filterArray, 4).map(([key, operator, value, condition = 'AND']) => ({\n    key,\n    operator,\n    value,\n    condition,\n  }));\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}