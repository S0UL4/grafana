{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { of, ReplaySubject } from 'rxjs';\nimport { catchError, map, share } from 'rxjs/operators';\nimport { v4 as uuidv4 } from 'uuid';\nimport { dataFrameFromJSON, getDefaultTimeRange, LoadingState, rangeUtil, withLoadingIndicator } from '@grafana/data';\nimport { getDataSourceSrv, toDataQueryError } from '@grafana/runtime';\nimport { getBackendSrv } from 'app/core/services/backend_srv';\nimport { isExpressionQuery } from 'app/features/expressions/guards';\nimport { cancelNetworkRequestsOnUnsubscribe } from 'app/features/query/state/processing/canceler';\nimport { setStructureRevision } from 'app/features/query/state/processing/revision';\nimport { preProcessPanelData } from 'app/features/query/state/runRequest';\nimport { getTimeRangeForExpression } from '../utils/timeRange';\nexport class AlertingQueryRunner {\n  constructor(backendSrv = getBackendSrv(), dataSourceSrv = getDataSourceSrv()) {\n    _defineProperty(this, \"subject\", void 0);\n\n    _defineProperty(this, \"subscription\", void 0);\n\n    _defineProperty(this, \"lastResult\", void 0);\n\n    this.backendSrv = backendSrv;\n    this.dataSourceSrv = dataSourceSrv;\n    this.subject = new ReplaySubject(1);\n    this.lastResult = {};\n  }\n\n  get() {\n    return this.subject.asObservable();\n  }\n\n  async run(queries) {\n    if (queries.length === 0) {\n      const empty = initialState(queries, LoadingState.Done);\n      return this.subject.next(empty);\n    } // do not execute if one more of the queries are not runnable,\n    // for example not completely configured\n\n\n    for (const query of queries) {\n      if (!isExpressionQuery(query.model)) {\n        const ds = await this.dataSourceSrv.get(query.datasourceUid);\n\n        if (ds.filterQuery && !ds.filterQuery(query.model)) {\n          const empty = initialState(queries, LoadingState.Done);\n          return this.subject.next(empty);\n        }\n      }\n    }\n\n    this.subscription = runRequest(this.backendSrv, queries).subscribe({\n      next: dataPerQuery => {\n        const nextResult = applyChange(dataPerQuery, (refId, data) => {\n          const previous = this.lastResult[refId];\n          const preProcessed = preProcessPanelData(data, previous);\n          return setStructureRevision(preProcessed, previous);\n        });\n        this.lastResult = nextResult;\n        this.subject.next(this.lastResult);\n      },\n      error: error => {\n        this.lastResult = mapErrorToPanelData(this.lastResult, error);\n        this.subject.next(this.lastResult);\n      }\n    });\n  }\n\n  cancel() {\n    if (!this.subscription) {\n      return;\n    }\n\n    this.subscription.unsubscribe();\n    let requestIsRunning = false;\n    const nextResult = applyChange(this.lastResult, (refId, data) => {\n      if (data.state === LoadingState.Loading) {\n        requestIsRunning = true;\n      }\n\n      return Object.assign({}, data, {\n        state: LoadingState.Done\n      });\n    });\n\n    if (requestIsRunning) {\n      this.subject.next(nextResult);\n    }\n  }\n\n  destroy() {\n    if (this.subject) {\n      this.subject.complete();\n    }\n\n    this.cancel();\n  }\n\n}\n\nconst runRequest = (backendSrv, queries) => {\n  const initial = initialState(queries, LoadingState.Loading);\n  const request = {\n    data: {\n      data: queries\n    },\n    url: '/api/v1/eval',\n    method: 'POST',\n    requestId: uuidv4()\n  };\n  return withLoadingIndicator({\n    whileLoading: initial,\n    source: backendSrv.fetch(request).pipe(mapToPanelData(initial), catchError(error => of(mapErrorToPanelData(initial, error))), cancelNetworkRequestsOnUnsubscribe(backendSrv, request.requestId), share())\n  });\n};\n\nconst initialState = (queries, state) => {\n  return queries.reduce((dataByQuery, query) => {\n    dataByQuery[query.refId] = {\n      state,\n      series: [],\n      timeRange: getTimeRange(query, queries)\n    };\n    return dataByQuery;\n  }, {});\n};\n\nconst getTimeRange = (query, queries) => {\n  if (isExpressionQuery(query.model)) {\n    const relative = getTimeRangeForExpression(query.model, queries);\n    return rangeUtil.relativeToTimeRange(relative);\n  }\n\n  if (!query.relativeTimeRange) {\n    console.warn(`Query with refId: ${query.refId} did not have any relative time range, using default.`);\n    return getDefaultTimeRange();\n  }\n\n  return rangeUtil.relativeToTimeRange(query.relativeTimeRange);\n};\n\nconst mapToPanelData = dataByQuery => {\n  return map(response => {\n    const {\n      data\n    } = response;\n    const results = {};\n\n    for (const [refId, result] of Object.entries(data.results)) {\n      results[refId] = {\n        timeRange: dataByQuery[refId].timeRange,\n        state: LoadingState.Done,\n        series: result.frames.map(dataFrameFromJSON)\n      };\n    }\n\n    return results;\n  });\n};\n\nconst mapErrorToPanelData = (lastResult, error) => {\n  const queryError = toDataQueryError(error);\n  return applyChange(lastResult, (refId, data) => {\n    return Object.assign({}, data, {\n      state: LoadingState.Error,\n      error: queryError\n    });\n  });\n};\n\nconst applyChange = (initial, change) => {\n  const nextResult = {};\n\n  for (const [refId, data] of Object.entries(initial)) {\n    nextResult[refId] = change(refId, data);\n  }\n\n  return nextResult;\n};","map":{"version":3,"names":["of","ReplaySubject","catchError","map","share","v4","uuidv4","dataFrameFromJSON","getDefaultTimeRange","LoadingState","rangeUtil","withLoadingIndicator","getDataSourceSrv","toDataQueryError","getBackendSrv","isExpressionQuery","cancelNetworkRequestsOnUnsubscribe","setStructureRevision","preProcessPanelData","getTimeRangeForExpression","AlertingQueryRunner","constructor","backendSrv","dataSourceSrv","subject","lastResult","get","asObservable","run","queries","length","empty","initialState","Done","next","query","model","ds","datasourceUid","filterQuery","subscription","runRequest","subscribe","dataPerQuery","nextResult","applyChange","refId","data","previous","preProcessed","error","mapErrorToPanelData","cancel","unsubscribe","requestIsRunning","state","Loading","destroy","complete","initial","request","url","method","requestId","whileLoading","source","fetch","pipe","mapToPanelData","reduce","dataByQuery","series","timeRange","getTimeRange","relative","relativeToTimeRange","relativeTimeRange","console","warn","response","results","result","Object","entries","frames","queryError","Error","change"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/state/AlertingQueryRunner.ts"],"sourcesContent":["import { Observable, of, OperatorFunction, ReplaySubject, Unsubscribable } from 'rxjs';\nimport { catchError, map, share } from 'rxjs/operators';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport {\n  dataFrameFromJSON,\n  DataFrameJSON,\n  getDefaultTimeRange,\n  LoadingState,\n  PanelData,\n  rangeUtil,\n  TimeRange,\n  withLoadingIndicator,\n} from '@grafana/data';\nimport { FetchResponse, getDataSourceSrv, toDataQueryError } from '@grafana/runtime';\nimport { BackendSrv, getBackendSrv } from 'app/core/services/backend_srv';\nimport { isExpressionQuery } from 'app/features/expressions/guards';\nimport { cancelNetworkRequestsOnUnsubscribe } from 'app/features/query/state/processing/canceler';\nimport { setStructureRevision } from 'app/features/query/state/processing/revision';\nimport { preProcessPanelData } from 'app/features/query/state/runRequest';\nimport { AlertQuery } from 'app/types/unified-alerting-dto';\n\nimport { getTimeRangeForExpression } from '../utils/timeRange';\n\nexport interface AlertingQueryResult {\n  frames: DataFrameJSON[];\n}\n\nexport interface AlertingQueryResponse {\n  results: Record<string, AlertingQueryResult>;\n}\nexport class AlertingQueryRunner {\n  private subject: ReplaySubject<Record<string, PanelData>>;\n  private subscription?: Unsubscribable;\n  private lastResult: Record<string, PanelData>;\n\n  constructor(private backendSrv = getBackendSrv(), private dataSourceSrv = getDataSourceSrv()) {\n    this.subject = new ReplaySubject(1);\n    this.lastResult = {};\n  }\n\n  get(): Observable<Record<string, PanelData>> {\n    return this.subject.asObservable();\n  }\n\n  async run(queries: AlertQuery[]) {\n    if (queries.length === 0) {\n      const empty = initialState(queries, LoadingState.Done);\n      return this.subject.next(empty);\n    }\n\n    // do not execute if one more of the queries are not runnable,\n    // for example not completely configured\n    for (const query of queries) {\n      if (!isExpressionQuery(query.model)) {\n        const ds = await this.dataSourceSrv.get(query.datasourceUid);\n        if (ds.filterQuery && !ds.filterQuery(query.model)) {\n          const empty = initialState(queries, LoadingState.Done);\n          return this.subject.next(empty);\n        }\n      }\n    }\n\n    this.subscription = runRequest(this.backendSrv, queries).subscribe({\n      next: (dataPerQuery) => {\n        const nextResult = applyChange(dataPerQuery, (refId, data) => {\n          const previous = this.lastResult[refId];\n          const preProcessed = preProcessPanelData(data, previous);\n          return setStructureRevision(preProcessed, previous);\n        });\n\n        this.lastResult = nextResult;\n        this.subject.next(this.lastResult);\n      },\n\n      error: (error: Error) => {\n        this.lastResult = mapErrorToPanelData(this.lastResult, error);\n        this.subject.next(this.lastResult);\n      },\n    });\n  }\n\n  cancel() {\n    if (!this.subscription) {\n      return;\n    }\n    this.subscription.unsubscribe();\n\n    let requestIsRunning = false;\n\n    const nextResult = applyChange(this.lastResult, (refId, data) => {\n      if (data.state === LoadingState.Loading) {\n        requestIsRunning = true;\n      }\n\n      return {\n        ...data,\n        state: LoadingState.Done,\n      };\n    });\n\n    if (requestIsRunning) {\n      this.subject.next(nextResult);\n    }\n  }\n\n  destroy() {\n    if (this.subject) {\n      this.subject.complete();\n    }\n\n    this.cancel();\n  }\n}\n\nconst runRequest = (backendSrv: BackendSrv, queries: AlertQuery[]): Observable<Record<string, PanelData>> => {\n  const initial = initialState(queries, LoadingState.Loading);\n  const request = {\n    data: { data: queries },\n    url: '/api/v1/eval',\n    method: 'POST',\n    requestId: uuidv4(),\n  };\n\n  return withLoadingIndicator({\n    whileLoading: initial,\n    source: backendSrv.fetch<AlertingQueryResponse>(request).pipe(\n      mapToPanelData(initial),\n      catchError((error) => of(mapErrorToPanelData(initial, error))),\n      cancelNetworkRequestsOnUnsubscribe(backendSrv, request.requestId),\n      share()\n    ),\n  });\n};\n\nconst initialState = (queries: AlertQuery[], state: LoadingState): Record<string, PanelData> => {\n  return queries.reduce((dataByQuery: Record<string, PanelData>, query) => {\n    dataByQuery[query.refId] = {\n      state,\n      series: [],\n      timeRange: getTimeRange(query, queries),\n    };\n\n    return dataByQuery;\n  }, {});\n};\n\nconst getTimeRange = (query: AlertQuery, queries: AlertQuery[]): TimeRange => {\n  if (isExpressionQuery(query.model)) {\n    const relative = getTimeRangeForExpression(query.model, queries);\n    return rangeUtil.relativeToTimeRange(relative);\n  }\n\n  if (!query.relativeTimeRange) {\n    console.warn(`Query with refId: ${query.refId} did not have any relative time range, using default.`);\n    return getDefaultTimeRange();\n  }\n\n  return rangeUtil.relativeToTimeRange(query.relativeTimeRange);\n};\n\nconst mapToPanelData = (\n  dataByQuery: Record<string, PanelData>\n): OperatorFunction<FetchResponse<AlertingQueryResponse>, Record<string, PanelData>> => {\n  return map((response) => {\n    const { data } = response;\n    const results: Record<string, PanelData> = {};\n\n    for (const [refId, result] of Object.entries(data.results)) {\n      results[refId] = {\n        timeRange: dataByQuery[refId].timeRange,\n        state: LoadingState.Done,\n        series: result.frames.map(dataFrameFromJSON),\n      };\n    }\n\n    return results;\n  });\n};\n\nconst mapErrorToPanelData = (lastResult: Record<string, PanelData>, error: Error): Record<string, PanelData> => {\n  const queryError = toDataQueryError(error);\n\n  return applyChange(lastResult, (refId, data) => {\n    return {\n      ...data,\n      state: LoadingState.Error,\n      error: queryError,\n    };\n  });\n};\n\nconst applyChange = (\n  initial: Record<string, PanelData>,\n  change: (refId: string, data: PanelData) => PanelData\n): Record<string, PanelData> => {\n  const nextResult: Record<string, PanelData> = {};\n\n  for (const [refId, data] of Object.entries(initial)) {\n    nextResult[refId] = change(refId, data);\n  }\n\n  return nextResult;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}