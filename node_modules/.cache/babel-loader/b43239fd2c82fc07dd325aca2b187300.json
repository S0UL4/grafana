{"ast":null,"code":"import { Observable, asyncScheduler } from 'rxjs';\n/**\n * Creates an Observable that emits sequential numbers after increasing intervals of time\n * starting with `startPeriod`, ending with `endPeriod` and incrementing by `step`.\n */\n\nexport const increasingInterval = ({\n  startPeriod = 0,\n  endPeriod = 5000,\n  step = 1000\n}, scheduler = asyncScheduler) => {\n  return new Observable(subscriber => {\n    const state = {\n      subscriber,\n      counter: 0,\n      period: startPeriod,\n      step,\n      endPeriod\n    };\n    subscriber.add(scheduler.schedule(dispatch, startPeriod, state));\n    return subscriber;\n  });\n};\n\nfunction dispatch(state) {\n  if (!state) {\n    return;\n  }\n\n  const {\n    subscriber,\n    counter,\n    period,\n    step,\n    endPeriod\n  } = state;\n  subscriber.next(counter);\n  const newPeriod = Math.min(period + step, endPeriod);\n  this.schedule({\n    subscriber,\n    counter: counter + 1,\n    period: newPeriod,\n    step,\n    endPeriod\n  }, newPeriod);\n}","map":{"version":3,"names":["Observable","asyncScheduler","increasingInterval","startPeriod","endPeriod","step","scheduler","subscriber","state","counter","period","add","schedule","dispatch","next","newPeriod","Math","min"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/utils/rxjs/increasingInterval.ts"],"sourcesContent":["import { SchedulerLike, Observable, SchedulerAction, Subscriber, asyncScheduler } from 'rxjs';\n\n/**\n * Creates an Observable that emits sequential numbers after increasing intervals of time\n * starting with `startPeriod`, ending with `endPeriod` and incrementing by `step`.\n */\nexport const increasingInterval = (\n  { startPeriod = 0, endPeriod = 5000, step = 1000 },\n  scheduler: SchedulerLike = asyncScheduler\n): Observable<number> => {\n  return new Observable<number>((subscriber) => {\n    const state: IntervalState = {\n      subscriber,\n      counter: 0,\n      period: startPeriod,\n      step,\n      endPeriod,\n    };\n\n    subscriber.add(scheduler.schedule(dispatch, startPeriod, state));\n    return subscriber;\n  });\n};\n\nfunction dispatch(this: SchedulerAction<IntervalState>, state?: IntervalState) {\n  if (!state) {\n    return;\n  }\n  const { subscriber, counter, period, step, endPeriod } = state;\n  subscriber.next(counter);\n  const newPeriod = Math.min(period + step, endPeriod);\n  this.schedule({ subscriber, counter: counter + 1, period: newPeriod, step, endPeriod }, newPeriod);\n}\n\ninterface IntervalState {\n  subscriber: Subscriber<number>;\n  counter: number;\n  period: number;\n  endPeriod: number;\n  step: number;\n}\n"],"mappings":"AAAA,SAAwBA,UAAxB,EAAiEC,cAAjE,QAAuF,MAAvF;AAEA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,kBAAkB,GAAG,CAChC;EAAEC,WAAW,GAAG,CAAhB;EAAmBC,SAAS,GAAG,IAA/B;EAAqCC,IAAI,GAAG;AAA5C,CADgC,EAEhCC,SAAwB,GAAGL,cAFK,KAGT;EACvB,OAAO,IAAID,UAAJ,CAAwBO,UAAD,IAAgB;IAC5C,MAAMC,KAAoB,GAAG;MAC3BD,UAD2B;MAE3BE,OAAO,EAAE,CAFkB;MAG3BC,MAAM,EAAEP,WAHmB;MAI3BE,IAJ2B;MAK3BD;IAL2B,CAA7B;IAQAG,UAAU,CAACI,GAAX,CAAeL,SAAS,CAACM,QAAV,CAAmBC,QAAnB,EAA6BV,WAA7B,EAA0CK,KAA1C,CAAf;IACA,OAAOD,UAAP;EACD,CAXM,CAAP;AAYD,CAhBM;;AAkBP,SAASM,QAAT,CAAwDL,KAAxD,EAA+E;EAC7E,IAAI,CAACA,KAAL,EAAY;IACV;EACD;;EACD,MAAM;IAAED,UAAF;IAAcE,OAAd;IAAuBC,MAAvB;IAA+BL,IAA/B;IAAqCD;EAArC,IAAmDI,KAAzD;EACAD,UAAU,CAACO,IAAX,CAAgBL,OAAhB;EACA,MAAMM,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGL,IAAlB,EAAwBD,SAAxB,CAAlB;EACA,KAAKQ,QAAL,CAAc;IAAEL,UAAF;IAAcE,OAAO,EAAEA,OAAO,GAAG,CAAjC;IAAoCC,MAAM,EAAEK,SAA5C;IAAuDV,IAAvD;IAA6DD;EAA7D,CAAd,EAAwFW,SAAxF;AACD"},"metadata":{},"sourceType":"module"}