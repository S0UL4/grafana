{"ast":null,"code":"import { each, find } from 'lodash';\nimport React, { useContext, useEffect, useState } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { Prompt } from 'react-router-dom';\nimport { locationService } from '@grafana/runtime';\nimport { ModalsContext } from '@grafana/ui';\nimport { appEvents } from 'app/core/app_events';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { SaveLibraryPanelModal } from 'app/features/library-panels/components/SaveLibraryPanelModal/SaveLibraryPanelModal';\nimport { DashboardSavedEvent } from 'app/types/events';\nimport { DashboardModel } from '../../state/DashboardModel';\nimport { discardPanelChanges, exitPanelEditor } from '../PanelEditor/state/actions';\nimport { UnsavedChangesModal } from '../SaveDashboard/UnsavedChangesModal';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const DashboardPrompt = /*#__PURE__*/React.memo(({\n  dashboard\n}) => {\n  const [state, setState] = useState({\n    original: null\n  });\n  const dispatch = useDispatch();\n  const {\n    original,\n    originalPath\n  } = state;\n  const {\n    showModal,\n    hideModal\n  } = useContext(ModalsContext);\n  useEffect(() => {\n    // This timeout delay is to wait for panels to load and migrate scheme before capturing the original state\n    // This is to minimize unsaved changes warnings due to automatic schema migrations\n    const timeoutId = setTimeout(() => {\n      const originalPath = locationService.getLocation().pathname;\n      const original = dashboard.getSaveModelClone();\n      setState({\n        originalPath,\n        original\n      });\n    }, 1000);\n    const savedEventUnsub = appEvents.subscribe(DashboardSavedEvent, () => {\n      const original = dashboard.getSaveModelClone();\n      setState({\n        originalPath,\n        original\n      });\n    });\n    return () => {\n      clearTimeout(timeoutId);\n      savedEventUnsub.unsubscribe();\n    };\n  }, [dashboard, originalPath]);\n  useEffect(() => {\n    const handleUnload = event => {\n      if (ignoreChanges(dashboard, original)) {\n        return;\n      }\n\n      if (hasChanges(dashboard, original)) {\n        event.preventDefault(); // No browser actually displays this message anymore.\n        // But Chrome requires it to be defined else the popup won't show.\n\n        event.returnValue = '';\n      }\n    };\n\n    window.addEventListener('beforeunload', handleUnload);\n    return () => window.removeEventListener('beforeunload', handleUnload);\n  }, [dashboard, original]);\n\n  const onHistoryBlock = location => {\n    const panelInEdit = dashboard.panelInEdit;\n    const search = new URLSearchParams(location.search); // Are we leaving panel edit & library panel?\n\n    if (panelInEdit && panelInEdit.libraryPanel && panelInEdit.hasChanged && !search.has('editPanel')) {\n      showModal(SaveLibraryPanelModal, {\n        isUnsavedPrompt: true,\n        panel: dashboard.panelInEdit,\n        folderId: dashboard.meta.folderId,\n        onConfirm: () => {\n          hideModal();\n          moveToBlockedLocationAfterReactStateUpdate(location);\n        },\n        onDiscard: () => {\n          dispatch(discardPanelChanges());\n          moveToBlockedLocationAfterReactStateUpdate(location);\n          hideModal();\n        },\n        onDismiss: hideModal\n      });\n      return false;\n    } // Are we still on the same dashboard?\n\n\n    if (originalPath === location.pathname || !original) {\n      // This is here due to timing reasons we want the exit panel editor state changes to happen before router update\n      if (panelInEdit && !search.has('editPanel')) {\n        dispatch(exitPanelEditor());\n      }\n\n      return true;\n    }\n\n    if (ignoreChanges(dashboard, original)) {\n      return true;\n    }\n\n    if (!hasChanges(dashboard, original)) {\n      return true;\n    }\n\n    showModal(UnsavedChangesModal, {\n      dashboard: dashboard,\n      onSaveSuccess: () => {\n        hideModal();\n        moveToBlockedLocationAfterReactStateUpdate(location);\n      },\n      onDiscard: () => {\n        setState(Object.assign({}, state, {\n          original: null\n        }));\n        hideModal();\n        moveToBlockedLocationAfterReactStateUpdate(location);\n      },\n      onDismiss: hideModal\n    });\n    return false;\n  };\n\n  return /*#__PURE__*/_jsx(Prompt, {\n    when: true,\n    message: onHistoryBlock\n  });\n});\nDashboardPrompt.displayName = 'DashboardPrompt';\n\nfunction moveToBlockedLocationAfterReactStateUpdate(location) {\n  if (location) {\n    setTimeout(() => locationService.push(location), 10);\n  }\n}\n/**\n * For some dashboards and users changes should be ignored *\n */\n\n\nexport function ignoreChanges(current, original) {\n  if (!original) {\n    return true;\n  } // Ignore changes if the user has been signed out\n\n\n  if (!contextSrv.isSignedIn) {\n    return true;\n  }\n\n  if (!current || !current.meta) {\n    return true;\n  }\n\n  const {\n    canSave,\n    fromScript,\n    fromFile\n  } = current.meta;\n\n  if (!contextSrv.isEditor && !canSave) {\n    return true;\n  }\n\n  return !canSave || fromScript || fromFile;\n}\n/**\n * Remove stuff that should not count in diff\n */\n\nfunction cleanDashboardFromIgnoredChanges(dashData) {\n  // need to new up the domain model class to get access to expand / collapse row logic\n  const model = new DashboardModel(dashData); // Expand all rows before making comparison. This is required because row expand / collapse\n  // change order of panel array and panel positions.\n\n  model.expandRows();\n  const dash = model.getSaveModelClone(); // ignore time and refresh\n\n  dash.time = 0;\n  dash.refresh = 0;\n  dash.schemaVersion = 0;\n  dash.timezone = 0; // ignore iteration property\n\n  delete dash.iteration;\n  dash.panels = []; // ignore template variable values\n\n  each(dash.getVariables(), variable => {\n    variable.current = null;\n    variable.options = null;\n    variable.filters = null;\n  });\n  return dash;\n}\n\nexport function hasChanges(current, original) {\n  if (current.hasUnsavedChanges()) {\n    return true;\n  }\n\n  const currentClean = cleanDashboardFromIgnoredChanges(current.getSaveModelClone());\n  const originalClean = cleanDashboardFromIgnoredChanges(original);\n  const currentTimepicker = find(currentClean.nav, {\n    type: 'timepicker'\n  });\n  const originalTimepicker = find(originalClean.nav, {\n    type: 'timepicker'\n  });\n\n  if (currentTimepicker && originalTimepicker) {\n    currentTimepicker.now = originalTimepicker.now;\n  }\n\n  const currentJson = JSON.stringify(currentClean, null);\n  const originalJson = JSON.stringify(originalClean, null);\n  return currentJson !== originalJson;\n}","map":{"version":3,"names":["each","find","React","useContext","useEffect","useState","useDispatch","Prompt","locationService","ModalsContext","appEvents","contextSrv","SaveLibraryPanelModal","DashboardSavedEvent","DashboardModel","discardPanelChanges","exitPanelEditor","UnsavedChangesModal","DashboardPrompt","memo","dashboard","state","setState","original","dispatch","originalPath","showModal","hideModal","timeoutId","setTimeout","getLocation","pathname","getSaveModelClone","savedEventUnsub","subscribe","clearTimeout","unsubscribe","handleUnload","event","ignoreChanges","hasChanges","preventDefault","returnValue","window","addEventListener","removeEventListener","onHistoryBlock","location","panelInEdit","search","URLSearchParams","libraryPanel","hasChanged","has","isUnsavedPrompt","panel","folderId","meta","onConfirm","moveToBlockedLocationAfterReactStateUpdate","onDiscard","onDismiss","onSaveSuccess","displayName","push","current","isSignedIn","canSave","fromScript","fromFile","isEditor","cleanDashboardFromIgnoredChanges","dashData","model","expandRows","dash","time","refresh","schemaVersion","timezone","iteration","panels","getVariables","variable","options","filters","hasUnsavedChanges","currentClean","originalClean","currentTimepicker","nav","type","originalTimepicker","now","currentJson","JSON","stringify","originalJson"],"sources":["/home/soula/grafana/public/app/features/dashboard/components/DashboardPrompt/DashboardPrompt.tsx"],"sourcesContent":["import * as H from 'history';\nimport { each, find } from 'lodash';\nimport React, { useContext, useEffect, useState } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { Prompt } from 'react-router-dom';\n\nimport { locationService } from '@grafana/runtime';\nimport { ModalsContext } from '@grafana/ui';\nimport { appEvents } from 'app/core/app_events';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { SaveLibraryPanelModal } from 'app/features/library-panels/components/SaveLibraryPanelModal/SaveLibraryPanelModal';\nimport { PanelModelWithLibraryPanel } from 'app/features/library-panels/types';\nimport { DashboardSavedEvent } from 'app/types/events';\n\nimport { DashboardModel } from '../../state/DashboardModel';\nimport { discardPanelChanges, exitPanelEditor } from '../PanelEditor/state/actions';\nimport { UnsavedChangesModal } from '../SaveDashboard/UnsavedChangesModal';\n\nexport interface Props {\n  dashboard: DashboardModel;\n}\n\ninterface State {\n  original: object | null;\n  originalPath?: string;\n}\n\nexport const DashboardPrompt = React.memo(({ dashboard }: Props) => {\n  const [state, setState] = useState<State>({ original: null });\n  const dispatch = useDispatch();\n  const { original, originalPath } = state;\n  const { showModal, hideModal } = useContext(ModalsContext);\n\n  useEffect(() => {\n    // This timeout delay is to wait for panels to load and migrate scheme before capturing the original state\n    // This is to minimize unsaved changes warnings due to automatic schema migrations\n    const timeoutId = setTimeout(() => {\n      const originalPath = locationService.getLocation().pathname;\n      const original = dashboard.getSaveModelClone();\n      setState({ originalPath, original });\n    }, 1000);\n\n    const savedEventUnsub = appEvents.subscribe(DashboardSavedEvent, () => {\n      const original = dashboard.getSaveModelClone();\n      setState({ originalPath, original });\n    });\n\n    return () => {\n      clearTimeout(timeoutId);\n      savedEventUnsub.unsubscribe();\n    };\n  }, [dashboard, originalPath]);\n\n  useEffect(() => {\n    const handleUnload = (event: BeforeUnloadEvent) => {\n      if (ignoreChanges(dashboard, original)) {\n        return;\n      }\n      if (hasChanges(dashboard, original)) {\n        event.preventDefault();\n        // No browser actually displays this message anymore.\n        // But Chrome requires it to be defined else the popup won't show.\n        event.returnValue = '';\n      }\n    };\n    window.addEventListener('beforeunload', handleUnload);\n    return () => window.removeEventListener('beforeunload', handleUnload);\n  }, [dashboard, original]);\n\n  const onHistoryBlock = (location: H.Location) => {\n    const panelInEdit = dashboard.panelInEdit;\n    const search = new URLSearchParams(location.search);\n\n    // Are we leaving panel edit & library panel?\n    if (panelInEdit && panelInEdit.libraryPanel && panelInEdit.hasChanged && !search.has('editPanel')) {\n      showModal(SaveLibraryPanelModal, {\n        isUnsavedPrompt: true,\n        panel: dashboard.panelInEdit as PanelModelWithLibraryPanel,\n        folderId: dashboard.meta.folderId as number,\n        onConfirm: () => {\n          hideModal();\n          moveToBlockedLocationAfterReactStateUpdate(location);\n        },\n        onDiscard: () => {\n          dispatch(discardPanelChanges());\n          moveToBlockedLocationAfterReactStateUpdate(location);\n          hideModal();\n        },\n        onDismiss: hideModal,\n      });\n      return false;\n    }\n\n    // Are we still on the same dashboard?\n    if (originalPath === location.pathname || !original) {\n      // This is here due to timing reasons we want the exit panel editor state changes to happen before router update\n      if (panelInEdit && !search.has('editPanel')) {\n        dispatch(exitPanelEditor());\n      }\n\n      return true;\n    }\n\n    if (ignoreChanges(dashboard, original)) {\n      return true;\n    }\n\n    if (!hasChanges(dashboard, original)) {\n      return true;\n    }\n\n    showModal(UnsavedChangesModal, {\n      dashboard: dashboard,\n      onSaveSuccess: () => {\n        hideModal();\n        moveToBlockedLocationAfterReactStateUpdate(location);\n      },\n      onDiscard: () => {\n        setState({ ...state, original: null });\n        hideModal();\n        moveToBlockedLocationAfterReactStateUpdate(location);\n      },\n      onDismiss: hideModal,\n    });\n\n    return false;\n  };\n\n  return <Prompt when={true} message={onHistoryBlock} />;\n});\n\nDashboardPrompt.displayName = 'DashboardPrompt';\n\nfunction moveToBlockedLocationAfterReactStateUpdate(location?: H.Location | null) {\n  if (location) {\n    setTimeout(() => locationService.push(location), 10);\n  }\n}\n\n/**\n * For some dashboards and users changes should be ignored *\n */\nexport function ignoreChanges(current: DashboardModel, original: object | null) {\n  if (!original) {\n    return true;\n  }\n\n  // Ignore changes if the user has been signed out\n  if (!contextSrv.isSignedIn) {\n    return true;\n  }\n\n  if (!current || !current.meta) {\n    return true;\n  }\n\n  const { canSave, fromScript, fromFile } = current.meta;\n  if (!contextSrv.isEditor && !canSave) {\n    return true;\n  }\n\n  return !canSave || fromScript || fromFile;\n}\n\n/**\n * Remove stuff that should not count in diff\n */\nfunction cleanDashboardFromIgnoredChanges(dashData: any) {\n  // need to new up the domain model class to get access to expand / collapse row logic\n  const model = new DashboardModel(dashData);\n\n  // Expand all rows before making comparison. This is required because row expand / collapse\n  // change order of panel array and panel positions.\n  model.expandRows();\n\n  const dash = model.getSaveModelClone();\n\n  // ignore time and refresh\n  dash.time = 0;\n  dash.refresh = 0;\n  dash.schemaVersion = 0;\n  dash.timezone = 0;\n\n  // ignore iteration property\n  delete dash.iteration;\n\n  dash.panels = [];\n\n  // ignore template variable values\n  each(dash.getVariables(), (variable: any) => {\n    variable.current = null;\n    variable.options = null;\n    variable.filters = null;\n  });\n\n  return dash;\n}\n\nexport function hasChanges(current: DashboardModel, original: any) {\n  if (current.hasUnsavedChanges()) {\n    return true;\n  }\n\n  const currentClean = cleanDashboardFromIgnoredChanges(current.getSaveModelClone());\n  const originalClean = cleanDashboardFromIgnoredChanges(original);\n\n  const currentTimepicker: any = find((currentClean as any).nav, { type: 'timepicker' });\n  const originalTimepicker: any = find((originalClean as any).nav, { type: 'timepicker' });\n\n  if (currentTimepicker && originalTimepicker) {\n    currentTimepicker.now = originalTimepicker.now;\n  }\n\n  const currentJson = JSON.stringify(currentClean, null);\n  const originalJson = JSON.stringify(originalClean, null);\n\n  return currentJson !== originalJson;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}