{"ast":null,"code":"import Prism from 'prismjs';\nimport { Block } from 'slate';\nimport TOKEN_MARK from './TOKEN_MARK';\nimport Options from './options';\n\n/**\n * A Slate plugin to highlight code syntax.\n */\nexport function SlatePrism(optsParam = {}, prismLanguages = Prism.languages) {\n  const opts = new Options(optsParam);\n  return {\n    decorateNode: (node, editor, next) => {\n      if (!opts.onlyIn(node)) {\n        return next();\n      }\n\n      const block = Block.create(node);\n      const grammarName = opts.getSyntax(block);\n      const grammar = prismLanguages[grammarName];\n\n      if (!grammar) {\n        // Grammar not loaded\n        return [];\n      } // Tokenize the whole block text\n\n\n      const texts = block.getTexts();\n      const blockText = texts.map(text => text && text.getText()).join('\\n');\n      const tokens = Prism.tokenize(blockText, grammar);\n      const flattened = flattenTokens(tokens);\n      const newData = editor.value.data.set('tokens', flattened);\n      editor.setData(newData);\n      return decorateNode(opts, tokens, block);\n    },\n    renderDecoration: (props, editor, next) => opts.renderDecoration({\n      children: props.children,\n      decoration: props.decoration\n    }, editor, next)\n  };\n}\n/**\n * Returns the decoration for a node\n */\n\nfunction decorateNode(opts, tokens, block) {\n  const texts = block.getTexts(); // The list of decorations to return\n\n  const decorations = [];\n  let textStart = 0;\n  let textEnd = 0;\n  texts.forEach(text => {\n    textEnd = textStart + text.getText().length;\n    let offset = 0;\n\n    function processToken(token, accu) {\n      if (typeof token === 'string') {\n        if (accu) {\n          const decoration = createDecoration({\n            text: text,\n            textStart,\n            textEnd,\n            start: offset,\n            end: offset + token.length,\n            className: `prism-token token ${accu}`,\n            block\n          });\n\n          if (decoration) {\n            decorations.push(decoration);\n          }\n        }\n\n        offset += token.length;\n      } else {\n        accu = `${accu} ${token.type}`;\n\n        if (token.alias) {\n          accu += ' ' + token.alias;\n        }\n\n        if (typeof token.content === 'string') {\n          const decoration = createDecoration({\n            text: text,\n            textStart,\n            textEnd,\n            start: offset,\n            end: offset + token.content.length,\n            className: `prism-token token ${accu}`,\n            block\n          });\n\n          if (decoration) {\n            decorations.push(decoration);\n          }\n\n          offset += token.content.length;\n        } else {\n          // When using token.content instead of token.matchedStr, token can be deep\n          for (let i = 0; i < token.content.length; i += 1) {\n            // @ts-ignore\n            processToken(token.content[i], accu);\n          }\n        }\n      }\n    }\n\n    tokens.forEach(processToken);\n    textStart = textEnd + 1; // account for added `\\n`\n  });\n  return decorations;\n}\n/**\n * Return a decoration range for the given text.\n */\n\n\nfunction createDecoration({\n  text,\n  textStart,\n  textEnd,\n  start,\n  end,\n  className,\n  block\n}) {\n  if (start >= textEnd || end <= textStart) {\n    // Ignore, the token is not in the text\n    return null;\n  } // Shrink to this text boundaries\n\n\n  start = Math.max(start, textStart);\n  end = Math.min(end, textEnd); // Now shift offsets to be relative to this text\n\n  start -= textStart;\n  end -= textStart;\n  const myDec = block.createDecoration({\n    object: 'decoration',\n    anchor: {\n      key: text.key,\n      offset: start,\n      object: 'point'\n    },\n    focus: {\n      key: text.key,\n      offset: end,\n      object: 'point'\n    },\n    type: TOKEN_MARK,\n    data: {\n      className\n    }\n  });\n  return myDec;\n}\n\nfunction flattenToken(token) {\n  if (typeof token === 'string') {\n    return [{\n      content: token,\n      types: [],\n      aliases: []\n    }];\n  } else if (Array.isArray(token)) {\n    return token.flatMap(t => flattenToken(t));\n  } else if (token instanceof Prism.Token) {\n    return flattenToken(token.content).flatMap(t => {\n      let aliases = [];\n\n      if (typeof token.alias === 'string') {\n        aliases = [token.alias];\n      } else {\n        var _token$alias;\n\n        aliases = (_token$alias = token.alias) !== null && _token$alias !== void 0 ? _token$alias : [];\n      }\n\n      return {\n        content: t.content,\n        types: [token.type, ...t.types],\n        aliases: [...aliases, ...t.aliases]\n      };\n    });\n  }\n\n  return [];\n}\n\nexport function flattenTokens(token) {\n  const tokens = flattenToken(token);\n\n  if (!tokens.length) {\n    return [];\n  }\n\n  const firstToken = tokens[0];\n  firstToken.prev = null;\n  firstToken.next = tokens.length >= 2 ? tokens[1] : null;\n  firstToken.offsets = {\n    start: 0,\n    end: firstToken.content.length\n  };\n\n  for (let i = 1; i < tokens.length - 1; i++) {\n    tokens[i].prev = tokens[i - 1];\n    tokens[i].next = tokens[i + 1];\n    tokens[i].offsets = {\n      start: tokens[i - 1].offsets.end,\n      end: tokens[i - 1].offsets.end + tokens[i].content.length\n    };\n  }\n\n  const lastToken = tokens[tokens.length - 1];\n  lastToken.prev = tokens.length >= 2 ? tokens[tokens.length - 2] : null;\n  lastToken.next = null;\n  lastToken.offsets = {\n    start: tokens.length >= 2 ? tokens[tokens.length - 2].offsets.end : 0,\n    end: tokens.length >= 2 ? tokens[tokens.length - 2].offsets.end + lastToken.content.length : lastToken.content.length\n  };\n  return tokens;\n}","map":{"version":3,"names":["Prism","Block","TOKEN_MARK","Options","SlatePrism","optsParam","prismLanguages","languages","opts","decorateNode","node","editor","next","onlyIn","block","create","grammarName","getSyntax","grammar","texts","getTexts","blockText","map","text","getText","join","tokens","tokenize","flattened","flattenTokens","newData","value","data","set","setData","renderDecoration","props","children","decoration","decorations","textStart","textEnd","forEach","length","offset","processToken","token","accu","createDecoration","start","end","className","push","type","alias","content","i","Math","max","min","myDec","object","anchor","key","focus","flattenToken","types","aliases","Array","isArray","flatMap","t","Token","firstToken","prev","offsets","lastToken"],"sources":["/home/soula/grafana/packages/grafana-ui/src/slate-plugins/slate-prism/index.ts"],"sourcesContent":["import Prism, { LanguageMap } from 'prismjs';\nimport { Block, Text, Decoration } from 'slate';\n\nimport { Plugin } from '@grafana/slate-react';\n\nimport TOKEN_MARK from './TOKEN_MARK';\nimport Options, { OptionsFormat } from './options';\n\nexport interface Token {\n  content: string;\n  offsets?: {\n    start: number;\n    end: number;\n  };\n  types: string[];\n  aliases: string[];\n  prev?: Token | null;\n  next?: Token | null;\n}\n\n/**\n * A Slate plugin to highlight code syntax.\n */\nexport function SlatePrism(optsParam: OptionsFormat = {}, prismLanguages = Prism.languages as LanguageMap): Plugin {\n  const opts: Options = new Options(optsParam);\n\n  return {\n    decorateNode: (node, editor, next) => {\n      if (!opts.onlyIn(node)) {\n        return next();\n      }\n\n      const block = Block.create(node as Block);\n      const grammarName = opts.getSyntax(block);\n      const grammar = prismLanguages[grammarName];\n\n      if (!grammar) {\n        // Grammar not loaded\n        return [];\n      }\n\n      // Tokenize the whole block text\n      const texts = block.getTexts();\n      const blockText = texts.map((text) => text && text.getText()).join('\\n');\n      const tokens = Prism.tokenize(blockText, grammar);\n      const flattened = flattenTokens(tokens);\n\n      const newData = editor.value.data.set('tokens', flattened);\n      editor.setData(newData);\n      return decorateNode(opts, tokens, block);\n    },\n\n    renderDecoration: (props, editor, next) =>\n      opts.renderDecoration(\n        {\n          children: props.children,\n          decoration: props.decoration,\n        },\n        editor as any,\n        next\n      ),\n  };\n}\n\n/**\n * Returns the decoration for a node\n */\nfunction decorateNode(opts: Options, tokens: Array<string | Prism.Token>, block: Block) {\n  const texts = block.getTexts();\n\n  // The list of decorations to return\n  const decorations: Decoration[] = [];\n  let textStart = 0;\n  let textEnd = 0;\n\n  texts.forEach((text) => {\n    textEnd = textStart + text!.getText().length;\n\n    let offset = 0;\n    function processToken(token: string | Prism.Token, accu?: string | number) {\n      if (typeof token === 'string') {\n        if (accu) {\n          const decoration = createDecoration({\n            text: text!,\n            textStart,\n            textEnd,\n            start: offset,\n            end: offset + token.length,\n            className: `prism-token token ${accu}`,\n            block,\n          });\n\n          if (decoration) {\n            decorations.push(decoration);\n          }\n        }\n        offset += token.length;\n      } else {\n        accu = `${accu} ${token.type}`;\n        if (token.alias) {\n          accu += ' ' + token.alias;\n        }\n\n        if (typeof token.content === 'string') {\n          const decoration = createDecoration({\n            text: text!,\n            textStart,\n            textEnd,\n            start: offset,\n            end: offset + token.content.length,\n            className: `prism-token token ${accu}`,\n            block,\n          });\n\n          if (decoration) {\n            decorations.push(decoration);\n          }\n\n          offset += token.content.length;\n        } else {\n          // When using token.content instead of token.matchedStr, token can be deep\n          for (let i = 0; i < token.content.length; i += 1) {\n            // @ts-ignore\n            processToken(token.content[i], accu);\n          }\n        }\n      }\n    }\n\n    tokens.forEach(processToken);\n    textStart = textEnd + 1; // account for added `\\n`\n  });\n\n  return decorations;\n}\n\n/**\n * Return a decoration range for the given text.\n */\nfunction createDecoration({\n  text,\n  textStart,\n  textEnd,\n  start,\n  end,\n  className,\n  block,\n}: {\n  text: Text; // The text being decorated\n  textStart: number; // Its start position in the whole text\n  textEnd: number; // Its end position in the whole text\n  start: number; // The position in the whole text where the token starts\n  end: number; // The position in the whole text where the token ends\n  className: string; // The prism token classname\n  block: Block;\n}): Decoration | null {\n  if (start >= textEnd || end <= textStart) {\n    // Ignore, the token is not in the text\n    return null;\n  }\n\n  // Shrink to this text boundaries\n  start = Math.max(start, textStart);\n  end = Math.min(end, textEnd);\n\n  // Now shift offsets to be relative to this text\n  start -= textStart;\n  end -= textStart;\n\n  const myDec = block.createDecoration({\n    object: 'decoration',\n    anchor: {\n      key: text.key,\n      offset: start,\n      object: 'point',\n    },\n    focus: {\n      key: text.key,\n      offset: end,\n      object: 'point',\n    },\n    type: TOKEN_MARK,\n    data: { className },\n  });\n\n  return myDec;\n}\n\nfunction flattenToken(token: string | Prism.Token | Array<string | Prism.Token>): Token[] {\n  if (typeof token === 'string') {\n    return [\n      {\n        content: token,\n        types: [],\n        aliases: [],\n      },\n    ];\n  } else if (Array.isArray(token)) {\n    return token.flatMap((t) => flattenToken(t));\n  } else if (token instanceof Prism.Token) {\n    return flattenToken(token.content).flatMap((t) => {\n      let aliases: string[] = [];\n      if (typeof token.alias === 'string') {\n        aliases = [token.alias];\n      } else {\n        aliases = token.alias ?? [];\n      }\n\n      return {\n        content: t.content,\n        types: [token.type, ...t.types],\n        aliases: [...aliases, ...t.aliases],\n      };\n    });\n  }\n\n  return [];\n}\n\nexport function flattenTokens(token: string | Prism.Token | Array<string | Prism.Token>) {\n  const tokens = flattenToken(token);\n\n  if (!tokens.length) {\n    return [];\n  }\n\n  const firstToken = tokens[0];\n  firstToken.prev = null;\n  firstToken.next = tokens.length >= 2 ? tokens[1] : null;\n  firstToken.offsets = {\n    start: 0,\n    end: firstToken.content.length,\n  };\n\n  for (let i = 1; i < tokens.length - 1; i++) {\n    tokens[i].prev = tokens[i - 1];\n    tokens[i].next = tokens[i + 1];\n\n    tokens[i].offsets = {\n      start: tokens[i - 1].offsets!.end,\n      end: tokens[i - 1].offsets!.end + tokens[i].content.length,\n    };\n  }\n\n  const lastToken = tokens[tokens.length - 1];\n  lastToken.prev = tokens.length >= 2 ? tokens[tokens.length - 2] : null;\n  lastToken.next = null;\n  lastToken.offsets = {\n    start: tokens.length >= 2 ? tokens[tokens.length - 2].offsets!.end : 0,\n    end:\n      tokens.length >= 2 ? tokens[tokens.length - 2].offsets!.end + lastToken.content.length : lastToken.content.length,\n  };\n\n  return tokens;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}