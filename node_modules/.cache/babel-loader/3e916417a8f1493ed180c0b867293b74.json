{"ast":null,"code":"import { FROM, SCHEMA, SELECT } from '../language';\nimport { SQLTokenTypes } from './types';\nexport const getSelectToken = currentToken => {\n  var _currentToken$getPrev;\n\n  return (_currentToken$getPrev = currentToken === null || currentToken === void 0 ? void 0 : currentToken.getPreviousOfType(SQLTokenTypes.Keyword, SELECT)) !== null && _currentToken$getPrev !== void 0 ? _currentToken$getPrev : null;\n};\nexport const getSelectStatisticToken = currentToken => {\n  var _getSelectToken;\n\n  const assumedStatisticToken = (_getSelectToken = getSelectToken(currentToken)) === null || _getSelectToken === void 0 ? void 0 : _getSelectToken.getNextNonWhiteSpaceToken();\n  return assumedStatisticToken !== null && assumedStatisticToken !== void 0 && assumedStatisticToken.isVariable() || assumedStatisticToken !== null && assumedStatisticToken !== void 0 && assumedStatisticToken.isFunction() ? assumedStatisticToken : null;\n};\nexport const getMetricNameToken = currentToken => {\n  var _getSelectStatisticTo, _getSelectStatisticTo2;\n\n  // statistic function is followed by `(` and then an argument\n  const assumedMetricNameToken = (_getSelectStatisticTo = getSelectStatisticToken(currentToken)) === null || _getSelectStatisticTo === void 0 ? void 0 : (_getSelectStatisticTo2 = _getSelectStatisticTo.next) === null || _getSelectStatisticTo2 === void 0 ? void 0 : _getSelectStatisticTo2.next;\n  return assumedMetricNameToken !== null && assumedMetricNameToken !== void 0 && assumedMetricNameToken.isVariable() || assumedMetricNameToken !== null && assumedMetricNameToken !== void 0 && assumedMetricNameToken.isIdentifier() ? assumedMetricNameToken : null;\n};\nexport const getFromKeywordToken = currentToken => {\n  const selectToken = getSelectToken(currentToken);\n  return selectToken === null || selectToken === void 0 ? void 0 : selectToken.getNextOfType(SQLTokenTypes.Keyword, FROM);\n};\nexport const getNamespaceToken = currentToken => {\n  var _nextNonWhiteSpace$ne;\n\n  const fromToken = getFromKeywordToken(currentToken);\n  const nextNonWhiteSpace = fromToken === null || fromToken === void 0 ? void 0 : fromToken.getNextNonWhiteSpaceToken();\n\n  if (nextNonWhiteSpace !== null && nextNonWhiteSpace !== void 0 && nextNonWhiteSpace.isDoubleQuotedString() || nextNonWhiteSpace !== null && nextNonWhiteSpace !== void 0 && nextNonWhiteSpace.isVariable() && (nextNonWhiteSpace === null || nextNonWhiteSpace === void 0 ? void 0 : nextNonWhiteSpace.value.toUpperCase()) !== SCHEMA) {\n    // schema is not used\n    return nextNonWhiteSpace;\n  } else if (nextNonWhiteSpace !== null && nextNonWhiteSpace !== void 0 && nextNonWhiteSpace.isKeyword() && (_nextNonWhiteSpace$ne = nextNonWhiteSpace.next) !== null && _nextNonWhiteSpace$ne !== void 0 && _nextNonWhiteSpace$ne.is(SQLTokenTypes.Parenthesis, '(')) {\n    var _nextNonWhiteSpace$ne2;\n\n    // schema is specified\n    const assumedNamespaceToken = (_nextNonWhiteSpace$ne2 = nextNonWhiteSpace.next) === null || _nextNonWhiteSpace$ne2 === void 0 ? void 0 : _nextNonWhiteSpace$ne2.next;\n\n    if (assumedNamespaceToken !== null && assumedNamespaceToken !== void 0 && assumedNamespaceToken.isDoubleQuotedString() || assumedNamespaceToken !== null && assumedNamespaceToken !== void 0 && assumedNamespaceToken.isVariable()) {\n      return assumedNamespaceToken;\n    }\n  }\n\n  return null;\n};","map":{"version":3,"names":["FROM","SCHEMA","SELECT","SQLTokenTypes","getSelectToken","currentToken","getPreviousOfType","Keyword","getSelectStatisticToken","assumedStatisticToken","getNextNonWhiteSpaceToken","isVariable","isFunction","getMetricNameToken","assumedMetricNameToken","next","isIdentifier","getFromKeywordToken","selectToken","getNextOfType","getNamespaceToken","fromToken","nextNonWhiteSpace","isDoubleQuotedString","value","toUpperCase","isKeyword","is","Parenthesis","assumedNamespaceToken"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/cloudwatch-sql/completion/tokenUtils.ts"],"sourcesContent":["import { LinkedToken } from '../../monarch/LinkedToken';\nimport { FROM, SCHEMA, SELECT } from '../language';\n\nimport { SQLTokenTypes } from './types';\n\nexport const getSelectToken = (currentToken: LinkedToken | null) =>\n  currentToken?.getPreviousOfType(SQLTokenTypes.Keyword, SELECT) ?? null;\n\nexport const getSelectStatisticToken = (currentToken: LinkedToken | null) => {\n  const assumedStatisticToken = getSelectToken(currentToken)?.getNextNonWhiteSpaceToken();\n  return assumedStatisticToken?.isVariable() || assumedStatisticToken?.isFunction() ? assumedStatisticToken : null;\n};\n\nexport const getMetricNameToken = (currentToken: LinkedToken | null) => {\n  // statistic function is followed by `(` and then an argument\n  const assumedMetricNameToken = getSelectStatisticToken(currentToken)?.next?.next;\n  return assumedMetricNameToken?.isVariable() || assumedMetricNameToken?.isIdentifier() ? assumedMetricNameToken : null;\n};\n\nexport const getFromKeywordToken = (currentToken: LinkedToken | null) => {\n  const selectToken = getSelectToken(currentToken);\n  return selectToken?.getNextOfType(SQLTokenTypes.Keyword, FROM);\n};\n\nexport const getNamespaceToken = (currentToken: LinkedToken | null) => {\n  const fromToken = getFromKeywordToken(currentToken);\n  const nextNonWhiteSpace = fromToken?.getNextNonWhiteSpaceToken();\n  if (\n    nextNonWhiteSpace?.isDoubleQuotedString() ||\n    (nextNonWhiteSpace?.isVariable() && nextNonWhiteSpace?.value.toUpperCase() !== SCHEMA)\n  ) {\n    // schema is not used\n    return nextNonWhiteSpace;\n  } else if (nextNonWhiteSpace?.isKeyword() && nextNonWhiteSpace.next?.is(SQLTokenTypes.Parenthesis, '(')) {\n    // schema is specified\n    const assumedNamespaceToken = nextNonWhiteSpace.next?.next;\n    if (assumedNamespaceToken?.isDoubleQuotedString() || assumedNamespaceToken?.isVariable()) {\n      return assumedNamespaceToken;\n    }\n  }\n  return null;\n};\n"],"mappings":"AACA,SAASA,IAAT,EAAeC,MAAf,EAAuBC,MAAvB,QAAqC,aAArC;AAEA,SAASC,aAAT,QAA8B,SAA9B;AAEA,OAAO,MAAMC,cAAc,GAAIC,YAAD;EAAA;;EAAA,gCAC5BA,YAD4B,aAC5BA,YAD4B,uBAC5BA,YAAY,CAAEC,iBAAd,CAAgCH,aAAa,CAACI,OAA9C,EAAuDL,MAAvD,CAD4B,yEACsC,IADtC;AAAA,CAAvB;AAGP,OAAO,MAAMM,uBAAuB,GAAIH,YAAD,IAAsC;EAAA;;EAC3E,MAAMI,qBAAqB,sBAAGL,cAAc,CAACC,YAAD,CAAjB,oDAAG,gBAA8BK,yBAA9B,EAA9B;EACA,OAAOD,qBAAqB,SAArB,IAAAA,qBAAqB,WAArB,IAAAA,qBAAqB,CAAEE,UAAvB,MAAuCF,qBAAvC,aAAuCA,qBAAvC,eAAuCA,qBAAqB,CAAEG,UAAvB,EAAvC,GAA6EH,qBAA7E,GAAqG,IAA5G;AACD,CAHM;AAKP,OAAO,MAAMI,kBAAkB,GAAIR,YAAD,IAAsC;EAAA;;EACtE;EACA,MAAMS,sBAAsB,4BAAGN,uBAAuB,CAACH,YAAD,CAA1B,oFAAG,sBAAuCU,IAA1C,2DAAG,uBAA6CA,IAA5E;EACA,OAAOD,sBAAsB,SAAtB,IAAAA,sBAAsB,WAAtB,IAAAA,sBAAsB,CAAEH,UAAxB,MAAwCG,sBAAxC,aAAwCA,sBAAxC,eAAwCA,sBAAsB,CAAEE,YAAxB,EAAxC,GAAiFF,sBAAjF,GAA0G,IAAjH;AACD,CAJM;AAMP,OAAO,MAAMG,mBAAmB,GAAIZ,YAAD,IAAsC;EACvE,MAAMa,WAAW,GAAGd,cAAc,CAACC,YAAD,CAAlC;EACA,OAAOa,WAAP,aAAOA,WAAP,uBAAOA,WAAW,CAAEC,aAAb,CAA2BhB,aAAa,CAACI,OAAzC,EAAkDP,IAAlD,CAAP;AACD,CAHM;AAKP,OAAO,MAAMoB,iBAAiB,GAAIf,YAAD,IAAsC;EAAA;;EACrE,MAAMgB,SAAS,GAAGJ,mBAAmB,CAACZ,YAAD,CAArC;EACA,MAAMiB,iBAAiB,GAAGD,SAAH,aAAGA,SAAH,uBAAGA,SAAS,CAAEX,yBAAX,EAA1B;;EACA,IACEY,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,IAAAA,iBAAiB,CAAEC,oBAAnB,MACCD,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,IAAAA,iBAAiB,CAAEX,UAAnB,MAAmC,CAAAW,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,YAAAA,iBAAiB,CAAEE,KAAnB,CAAyBC,WAAzB,QAA2CxB,MAFjF,EAGE;IACA;IACA,OAAOqB,iBAAP;EACD,CAND,MAMO,IAAIA,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,IAAAA,iBAAiB,CAAEI,SAAnB,+BAAkCJ,iBAAiB,CAACP,IAApD,kDAAkC,sBAAwBY,EAAxB,CAA2BxB,aAAa,CAACyB,WAAzC,EAAsD,GAAtD,CAAtC,EAAkG;IAAA;;IACvG;IACA,MAAMC,qBAAqB,6BAAGP,iBAAiB,CAACP,IAArB,2DAAG,uBAAwBA,IAAtD;;IACA,IAAIc,qBAAqB,SAArB,IAAAA,qBAAqB,WAArB,IAAAA,qBAAqB,CAAEN,oBAAvB,MAAiDM,qBAAjD,aAAiDA,qBAAjD,eAAiDA,qBAAqB,CAAElB,UAAvB,EAArD,EAA0F;MACxF,OAAOkB,qBAAP;IACD;EACF;;EACD,OAAO,IAAP;AACD,CAjBM"},"metadata":{},"sourceType":"module"}