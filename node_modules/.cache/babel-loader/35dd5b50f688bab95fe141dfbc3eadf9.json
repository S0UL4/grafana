{"ast":null,"code":"import { useMemo } from 'react';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { useQueryParams } from 'app/core/hooks/useQueryParams';\nimport { PromRuleType } from 'app/types/unified-alerting-dto';\nimport { labelsMatchMatchers, parseMatchers } from '../utils/alertmanager';\nimport { isCloudRulesSource } from '../utils/datasource';\nimport { getFiltersFromUrlParams } from '../utils/misc';\nimport { isAlertingRule, isGrafanaRulerRule } from '../utils/rules';\nexport const useFilteredRules = namespaces => {\n  const [queryParams] = useQueryParams();\n  const filters = getFiltersFromUrlParams(queryParams);\n  return useMemo(() => {\n    const filteredNamespaces = namespaces // Filter by data source\n    // TODO: filter by multiple data sources for grafana-managed alerts\n    .filter(({\n      rulesSource\n    }) => filters.dataSource && isCloudRulesSource(rulesSource) ? rulesSource.name === filters.dataSource : true) // If a namespace and group have rules that match the rules filters then keep them.\n    .reduce(reduceNamespaces(filters), []);\n    return filteredNamespaces;\n  }, [namespaces, filters]);\n};\n\nconst reduceNamespaces = filters => {\n  return (namespaceAcc, namespace) => {\n    const groups = namespace.groups.reduce(reduceGroups(filters), []);\n\n    if (groups.length) {\n      namespaceAcc.push(Object.assign({}, namespace, {\n        groups\n      }));\n    }\n\n    return namespaceAcc;\n  };\n}; // Reduces groups to only groups that have rules matching the filters\n\n\nconst reduceGroups = filters => {\n  return (groupAcc, group) => {\n    const rules = group.rules.filter(rule => {\n      var _rule$promRule;\n\n      if (filters.ruleType && filters.ruleType !== ((_rule$promRule = rule.promRule) === null || _rule$promRule === void 0 ? void 0 : _rule$promRule.type)) {\n        return false;\n      }\n\n      if (filters.dataSource && isGrafanaRulerRule(rule.rulerRule) && !isQueryingDataSource(rule.rulerRule, filters)) {\n        return false;\n      } // Query strings can match alert name, label keys, and label values\n\n\n      if (filters.queryString) {\n        var _rule$name;\n\n        const normalizedQueryString = filters.queryString.toLocaleLowerCase();\n        const doesNameContainsQueryString = (_rule$name = rule.name) === null || _rule$name === void 0 ? void 0 : _rule$name.toLocaleLowerCase().includes(normalizedQueryString);\n        const matchers = parseMatchers(filters.queryString);\n        const doRuleLabelsMatchQuery = labelsMatchMatchers(rule.labels, matchers);\n        const doAlertsContainMatchingLabels = rule.promRule && rule.promRule.type === PromRuleType.Alerting && rule.promRule.alerts && rule.promRule.alerts.some(alert => labelsMatchMatchers(alert.labels, matchers));\n\n        if (!(doesNameContainsQueryString || doRuleLabelsMatchQuery || doAlertsContainMatchingLabels)) {\n          return false;\n        }\n      }\n\n      if (filters.alertState && !(rule.promRule && isAlertingRule(rule.promRule) && rule.promRule.state === filters.alertState)) {\n        return false;\n      }\n\n      return true;\n    }); // Add rules to the group that match the rule list filters\n\n    if (rules.length) {\n      groupAcc.push(Object.assign({}, group, {\n        rules\n      }));\n    }\n\n    return groupAcc;\n  };\n};\n\nconst isQueryingDataSource = (rulerRule, filter) => {\n  if (!filter.dataSource) {\n    return true;\n  }\n\n  return !!rulerRule.grafana_alert.data.find(query => {\n    if (!query.datasourceUid) {\n      return false;\n    }\n\n    const ds = getDataSourceSrv().getInstanceSettings(query.datasourceUid);\n    return (ds === null || ds === void 0 ? void 0 : ds.name) === filter.dataSource;\n  });\n};","map":{"version":3,"names":["useMemo","getDataSourceSrv","useQueryParams","PromRuleType","labelsMatchMatchers","parseMatchers","isCloudRulesSource","getFiltersFromUrlParams","isAlertingRule","isGrafanaRulerRule","useFilteredRules","namespaces","queryParams","filters","filteredNamespaces","filter","rulesSource","dataSource","name","reduce","reduceNamespaces","namespaceAcc","namespace","groups","reduceGroups","length","push","groupAcc","group","rules","rule","ruleType","promRule","type","rulerRule","isQueryingDataSource","queryString","normalizedQueryString","toLocaleLowerCase","doesNameContainsQueryString","includes","matchers","doRuleLabelsMatchQuery","labels","doAlertsContainMatchingLabels","Alerting","alerts","some","alert","alertState","state","grafana_alert","data","find","query","datasourceUid","ds","getInstanceSettings"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/hooks/useFilteredRules.ts"],"sourcesContent":["import { useMemo } from 'react';\n\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { useQueryParams } from 'app/core/hooks/useQueryParams';\nimport { CombinedRuleGroup, CombinedRuleNamespace, FilterState } from 'app/types/unified-alerting';\nimport { PromRuleType, RulerGrafanaRuleDTO } from 'app/types/unified-alerting-dto';\n\nimport { labelsMatchMatchers, parseMatchers } from '../utils/alertmanager';\nimport { isCloudRulesSource } from '../utils/datasource';\nimport { getFiltersFromUrlParams } from '../utils/misc';\nimport { isAlertingRule, isGrafanaRulerRule } from '../utils/rules';\n\nexport const useFilteredRules = (namespaces: CombinedRuleNamespace[]) => {\n  const [queryParams] = useQueryParams();\n  const filters = getFiltersFromUrlParams(queryParams);\n\n  return useMemo(() => {\n    const filteredNamespaces = namespaces\n      // Filter by data source\n      // TODO: filter by multiple data sources for grafana-managed alerts\n      .filter(({ rulesSource }) =>\n        filters.dataSource && isCloudRulesSource(rulesSource) ? rulesSource.name === filters.dataSource : true\n      )\n      // If a namespace and group have rules that match the rules filters then keep them.\n      .reduce(reduceNamespaces(filters), [] as CombinedRuleNamespace[]);\n    return filteredNamespaces;\n  }, [namespaces, filters]);\n};\n\nconst reduceNamespaces = (filters: FilterState) => {\n  return (namespaceAcc: CombinedRuleNamespace[], namespace: CombinedRuleNamespace) => {\n    const groups = namespace.groups.reduce(reduceGroups(filters), [] as CombinedRuleGroup[]);\n\n    if (groups.length) {\n      namespaceAcc.push({\n        ...namespace,\n        groups,\n      });\n    }\n\n    return namespaceAcc;\n  };\n};\n\n// Reduces groups to only groups that have rules matching the filters\nconst reduceGroups = (filters: FilterState) => {\n  return (groupAcc: CombinedRuleGroup[], group: CombinedRuleGroup) => {\n    const rules = group.rules.filter((rule) => {\n      if (filters.ruleType && filters.ruleType !== rule.promRule?.type) {\n        return false;\n      }\n      if (filters.dataSource && isGrafanaRulerRule(rule.rulerRule) && !isQueryingDataSource(rule.rulerRule, filters)) {\n        return false;\n      }\n      // Query strings can match alert name, label keys, and label values\n      if (filters.queryString) {\n        const normalizedQueryString = filters.queryString.toLocaleLowerCase();\n        const doesNameContainsQueryString = rule.name?.toLocaleLowerCase().includes(normalizedQueryString);\n        const matchers = parseMatchers(filters.queryString);\n\n        const doRuleLabelsMatchQuery = labelsMatchMatchers(rule.labels, matchers);\n        const doAlertsContainMatchingLabels =\n          rule.promRule &&\n          rule.promRule.type === PromRuleType.Alerting &&\n          rule.promRule.alerts &&\n          rule.promRule.alerts.some((alert) => labelsMatchMatchers(alert.labels, matchers));\n\n        if (!(doesNameContainsQueryString || doRuleLabelsMatchQuery || doAlertsContainMatchingLabels)) {\n          return false;\n        }\n      }\n      if (\n        filters.alertState &&\n        !(rule.promRule && isAlertingRule(rule.promRule) && rule.promRule.state === filters.alertState)\n      ) {\n        return false;\n      }\n      return true;\n    });\n    // Add rules to the group that match the rule list filters\n    if (rules.length) {\n      groupAcc.push({\n        ...group,\n        rules,\n      });\n    }\n    return groupAcc;\n  };\n};\n\nconst isQueryingDataSource = (rulerRule: RulerGrafanaRuleDTO, filter: FilterState): boolean => {\n  if (!filter.dataSource) {\n    return true;\n  }\n\n  return !!rulerRule.grafana_alert.data.find((query) => {\n    if (!query.datasourceUid) {\n      return false;\n    }\n    const ds = getDataSourceSrv().getInstanceSettings(query.datasourceUid);\n    return ds?.name === filter.dataSource;\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}