{"ast":null,"code":"import { css } from '@emotion/css';\nimport React, { useMemo } from 'react';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport { InlineLabel, SegmentSection, useStyles2 } from '@grafana/ui';\nimport { getAllMeasurementsForTags, getAllPolicies, getFieldKeysForMeasurement, getTagKeysForMeasurementAndTags, getTagValues } from '../../influxQLMetadataQuery';\nimport { normalizeQuery, addNewSelectPart, removeSelectPart, addNewGroupByPart, removeGroupByPart, changeSelectPart, changeGroupByPart } from '../../queryUtils';\nimport { DEFAULT_RESULT_FORMAT } from '../constants';\nimport { useUniqueId } from '../useUniqueId';\nimport { FormatAsSection } from './FormatAsSection';\nimport { FromSection } from './FromSection';\nimport { InputSection } from './InputSection';\nimport { OrderByTimeSection } from './OrderByTimeSection';\nimport { PartListSection } from './PartListSection';\nimport { TagsSection } from './TagsSection';\nimport { getNewSelectPartOptions, getNewGroupByPartOptions, makePartList } from './partListUtils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\n\nfunction getTemplateVariableOptions() {\n  return getTemplateSrv().getVariables() // we make them regex-params, i'm not 100% sure why.\n  // probably because this way multi-value variables work ok too.\n  .map(v => `/^$${v.name}$/`);\n} // helper function to make it easy to call this from the widget-render-code\n\n\nfunction withTemplateVariableOptions(optionsPromise) {\n  return optionsPromise.then(options => [...getTemplateVariableOptions(), ...options]);\n} // it is possible to add fields into the `InfluxQueryTag` structures, and they do work,\n// but in some cases, when we do metadata queries, we have to remove them from the queries.\n\n\nfunction filterTags(parts, allTagKeys) {\n  return parts.filter(t => allTagKeys.has(t.key));\n}\n\nexport const Editor = props => {\n  var _query$tags3, _query$limit, _query$slimit, _query$resultFormat;\n\n  const uniqueId = useUniqueId();\n  const formatAsId = `influxdb-qe-format-as-${uniqueId}`;\n  const orderByTimeId = `influxdb-qe-order-by${uniqueId}`;\n  const styles = useStyles2(getStyles);\n  const query = normalizeQuery(props.query);\n  const {\n    datasource\n  } = props;\n  const {\n    measurement,\n    policy\n  } = query;\n  const allTagKeys = useMemo(() => {\n    return getTagKeysForMeasurementAndTags(measurement, policy, [], datasource).then(tags => {\n      return new Set(tags);\n    });\n  }, [measurement, policy, datasource]);\n  const selectLists = useMemo(() => {\n    var _query$select;\n\n    const dynamicSelectPartOptions = new Map([['field_0', () => {\n      return measurement !== undefined ? getFieldKeysForMeasurement(measurement, policy, datasource) : Promise.resolve([]);\n    }]]);\n    return ((_query$select = query.select) !== null && _query$select !== void 0 ? _query$select : []).map(sel => makePartList(sel, dynamicSelectPartOptions));\n  }, [measurement, policy, query.select, datasource]); // the following function is not complicated enough to memoize, but it's result\n  // is used in both memoized and un-memoized parts, so we have no choice\n\n  const getTagKeys = useMemo(() => {\n    return () => allTagKeys.then(keys => {\n      var _query$tags;\n\n      return getTagKeysForMeasurementAndTags(measurement, policy, filterTags((_query$tags = query.tags) !== null && _query$tags !== void 0 ? _query$tags : [], keys), datasource);\n    });\n  }, [measurement, policy, query.tags, datasource, allTagKeys]);\n  const groupByList = useMemo(() => {\n    var _query$groupBy;\n\n    const dynamicGroupByPartOptions = new Map([['tag_0', getTagKeys]]);\n    return makePartList((_query$groupBy = query.groupBy) !== null && _query$groupBy !== void 0 ? _query$groupBy : [], dynamicGroupByPartOptions);\n  }, [getTagKeys, query.groupBy]);\n\n  const onAppliedChange = newQuery => {\n    props.onChange(newQuery);\n    props.onRunQuery();\n  };\n\n  const handleFromSectionChange = (p, m) => {\n    onAppliedChange(Object.assign({}, query, {\n      policy: p,\n      measurement: m\n    }));\n  };\n\n  const handleTagsSectionChange = tags => {\n    // we set empty-arrays to undefined\n    onAppliedChange(Object.assign({}, query, {\n      tags: tags.length === 0 ? undefined : tags\n    }));\n  };\n\n  return /*#__PURE__*/_jsxs(\"div\", {\n    children: [/*#__PURE__*/_jsxs(SegmentSection, {\n      label: \"FROM\",\n      fill: true,\n      children: [/*#__PURE__*/_jsx(FromSection, {\n        policy: policy,\n        measurement: measurement,\n        getPolicyOptions: () => getAllPolicies(datasource),\n        getMeasurementOptions: filter => withTemplateVariableOptions(allTagKeys.then(keys => {\n          var _query$tags2;\n\n          return getAllMeasurementsForTags(filter === '' ? undefined : filter, filterTags((_query$tags2 = query.tags) !== null && _query$tags2 !== void 0 ? _query$tags2 : [], keys), datasource);\n        })),\n        onChange: handleFromSectionChange\n      }), /*#__PURE__*/_jsx(InlineLabel, {\n        width: \"auto\",\n        className: styles.inlineLabel,\n        children: \"WHERE\"\n      }), /*#__PURE__*/_jsx(TagsSection, {\n        tags: (_query$tags3 = query.tags) !== null && _query$tags3 !== void 0 ? _query$tags3 : [],\n        onChange: handleTagsSectionChange,\n        getTagKeyOptions: getTagKeys,\n        getTagValueOptions: key => withTemplateVariableOptions(allTagKeys.then(keys => {\n          var _query$tags4;\n\n          return getTagValues(key, measurement, policy, filterTags((_query$tags4 = query.tags) !== null && _query$tags4 !== void 0 ? _query$tags4 : [], keys), datasource);\n        }))\n      })]\n    }), selectLists.map((sel, index) => /*#__PURE__*/_jsx(SegmentSection, {\n      label: index === 0 ? 'SELECT' : '',\n      fill: true,\n      children: /*#__PURE__*/_jsx(PartListSection, {\n        parts: sel,\n        getNewPartOptions: () => Promise.resolve(getNewSelectPartOptions()),\n        onChange: (partIndex, newParams) => {\n          const newQuery = changeSelectPart(query, index, partIndex, newParams);\n          onAppliedChange(newQuery);\n        },\n        onAddNewPart: type => {\n          onAppliedChange(addNewSelectPart(query, type, index));\n        },\n        onRemovePart: partIndex => {\n          onAppliedChange(removeSelectPart(query, partIndex, index));\n        }\n      })\n    }, index)), /*#__PURE__*/_jsx(SegmentSection, {\n      label: \"GROUP BY\",\n      fill: true,\n      children: /*#__PURE__*/_jsx(PartListSection, {\n        parts: groupByList,\n        getNewPartOptions: () => getNewGroupByPartOptions(query, getTagKeys),\n        onChange: (partIndex, newParams) => {\n          const newQuery = changeGroupByPart(query, partIndex, newParams);\n          onAppliedChange(newQuery);\n        },\n        onAddNewPart: type => {\n          onAppliedChange(addNewGroupByPart(query, type));\n        },\n        onRemovePart: partIndex => {\n          onAppliedChange(removeGroupByPart(query, partIndex));\n        }\n      })\n    }), /*#__PURE__*/_jsxs(SegmentSection, {\n      label: \"TIMEZONE\",\n      fill: true,\n      children: [/*#__PURE__*/_jsx(InputSection, {\n        placeholder: \"(optional)\",\n        value: query.tz,\n        onChange: tz => {\n          onAppliedChange(Object.assign({}, query, {\n            tz\n          }));\n        }\n      }), /*#__PURE__*/_jsx(InlineLabel, {\n        htmlFor: orderByTimeId,\n        width: \"auto\",\n        className: styles.inlineLabel,\n        children: \"ORDER BY TIME\"\n      }), /*#__PURE__*/_jsx(OrderByTimeSection, {\n        inputId: orderByTimeId,\n        value: query.orderByTime === 'DESC' ? 'DESC' : 'ASC'\n        /* FIXME: make this shared with influx_query_model */\n        ,\n        onChange: v => {\n          onAppliedChange(Object.assign({}, query, {\n            orderByTime: v\n          }));\n        }\n      })]\n    }), /*#__PURE__*/_jsxs(SegmentSection, {\n      label: \"LIMIT\",\n      fill: true,\n      children: [/*#__PURE__*/_jsx(InputSection, {\n        placeholder: \"(optional)\",\n        value: (_query$limit = query.limit) === null || _query$limit === void 0 ? void 0 : _query$limit.toString(),\n        onChange: limit => {\n          onAppliedChange(Object.assign({}, query, {\n            limit\n          }));\n        }\n      }), /*#__PURE__*/_jsx(InlineLabel, {\n        width: \"auto\",\n        className: styles.inlineLabel,\n        children: \"SLIMIT\"\n      }), /*#__PURE__*/_jsx(InputSection, {\n        placeholder: \"(optional)\",\n        value: (_query$slimit = query.slimit) === null || _query$slimit === void 0 ? void 0 : _query$slimit.toString(),\n        onChange: slimit => {\n          onAppliedChange(Object.assign({}, query, {\n            slimit\n          }));\n        }\n      })]\n    }), /*#__PURE__*/_jsxs(SegmentSection, {\n      htmlFor: formatAsId,\n      label: \"FORMAT AS\",\n      fill: true,\n      children: [/*#__PURE__*/_jsx(FormatAsSection, {\n        inputId: formatAsId,\n        format: (_query$resultFormat = query.resultFormat) !== null && _query$resultFormat !== void 0 ? _query$resultFormat : DEFAULT_RESULT_FORMAT,\n        onChange: format => {\n          onAppliedChange(Object.assign({}, query, {\n            resultFormat: format\n          }));\n        }\n      }), query.resultFormat !== 'table' && /*#__PURE__*/_jsxs(_Fragment, {\n        children: [/*#__PURE__*/_jsx(InlineLabel, {\n          width: \"auto\",\n          className: styles.inlineLabel,\n          children: \"ALIAS\"\n        }), /*#__PURE__*/_jsx(InputSection, {\n          isWide: true,\n          placeholder: \"Naming pattern\",\n          value: query.alias,\n          onChange: alias => {\n            onAppliedChange(Object.assign({}, query, {\n              alias\n            }));\n          }\n        })]\n      })]\n    })]\n  });\n};\n\nfunction getStyles(theme) {\n  return {\n    inlineLabel: css`\n      color: ${theme.colors.primary.text};\n    `\n  };\n}","map":{"version":3,"names":["css","React","useMemo","getTemplateSrv","InlineLabel","SegmentSection","useStyles2","getAllMeasurementsForTags","getAllPolicies","getFieldKeysForMeasurement","getTagKeysForMeasurementAndTags","getTagValues","normalizeQuery","addNewSelectPart","removeSelectPart","addNewGroupByPart","removeGroupByPart","changeSelectPart","changeGroupByPart","DEFAULT_RESULT_FORMAT","useUniqueId","FormatAsSection","FromSection","InputSection","OrderByTimeSection","PartListSection","TagsSection","getNewSelectPartOptions","getNewGroupByPartOptions","makePartList","getTemplateVariableOptions","getVariables","map","v","name","withTemplateVariableOptions","optionsPromise","then","options","filterTags","parts","allTagKeys","filter","t","has","key","Editor","props","uniqueId","formatAsId","orderByTimeId","styles","getStyles","query","datasource","measurement","policy","tags","Set","selectLists","dynamicSelectPartOptions","Map","undefined","Promise","resolve","select","sel","getTagKeys","keys","groupByList","dynamicGroupByPartOptions","groupBy","onAppliedChange","newQuery","onChange","onRunQuery","handleFromSectionChange","p","m","handleTagsSectionChange","length","inlineLabel","index","partIndex","newParams","type","tz","orderByTime","limit","toString","slimit","resultFormat","format","alias","theme","colors","primary","text"],"sources":["/home/soula/grafana/public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/Editor.tsx"],"sourcesContent":["import { css } from '@emotion/css';\nimport React, { useMemo } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport { InlineLabel, SegmentSection, useStyles2 } from '@grafana/ui';\n\nimport InfluxDatasource from '../../datasource';\nimport {\n  getAllMeasurementsForTags,\n  getAllPolicies,\n  getFieldKeysForMeasurement,\n  getTagKeysForMeasurementAndTags,\n  getTagValues,\n} from '../../influxQLMetadataQuery';\nimport {\n  normalizeQuery,\n  addNewSelectPart,\n  removeSelectPart,\n  addNewGroupByPart,\n  removeGroupByPart,\n  changeSelectPart,\n  changeGroupByPart,\n} from '../../queryUtils';\nimport { InfluxQuery, InfluxQueryTag } from '../../types';\nimport { DEFAULT_RESULT_FORMAT } from '../constants';\nimport { useUniqueId } from '../useUniqueId';\n\nimport { FormatAsSection } from './FormatAsSection';\nimport { FromSection } from './FromSection';\nimport { InputSection } from './InputSection';\nimport { OrderByTimeSection } from './OrderByTimeSection';\nimport { PartListSection } from './PartListSection';\nimport { TagsSection } from './TagsSection';\nimport { getNewSelectPartOptions, getNewGroupByPartOptions, makePartList } from './partListUtils';\n\ntype Props = {\n  query: InfluxQuery;\n  onChange: (query: InfluxQuery) => void;\n  onRunQuery: () => void;\n  datasource: InfluxDatasource;\n};\n\nfunction getTemplateVariableOptions() {\n  return (\n    getTemplateSrv()\n      .getVariables()\n      // we make them regex-params, i'm not 100% sure why.\n      // probably because this way multi-value variables work ok too.\n      .map((v) => `/^$${v.name}$/`)\n  );\n}\n\n// helper function to make it easy to call this from the widget-render-code\nfunction withTemplateVariableOptions(optionsPromise: Promise<string[]>): Promise<string[]> {\n  return optionsPromise.then((options) => [...getTemplateVariableOptions(), ...options]);\n}\n\n// it is possible to add fields into the `InfluxQueryTag` structures, and they do work,\n// but in some cases, when we do metadata queries, we have to remove them from the queries.\nfunction filterTags(parts: InfluxQueryTag[], allTagKeys: Set<string>): InfluxQueryTag[] {\n  return parts.filter((t) => allTagKeys.has(t.key));\n}\n\nexport const Editor = (props: Props): JSX.Element => {\n  const uniqueId = useUniqueId();\n  const formatAsId = `influxdb-qe-format-as-${uniqueId}`;\n  const orderByTimeId = `influxdb-qe-order-by${uniqueId}`;\n\n  const styles = useStyles2(getStyles);\n  const query = normalizeQuery(props.query);\n  const { datasource } = props;\n  const { measurement, policy } = query;\n\n  const allTagKeys = useMemo(() => {\n    return getTagKeysForMeasurementAndTags(measurement, policy, [], datasource).then((tags) => {\n      return new Set(tags);\n    });\n  }, [measurement, policy, datasource]);\n\n  const selectLists = useMemo(() => {\n    const dynamicSelectPartOptions = new Map([\n      [\n        'field_0',\n        () => {\n          return measurement !== undefined\n            ? getFieldKeysForMeasurement(measurement, policy, datasource)\n            : Promise.resolve([]);\n        },\n      ],\n    ]);\n    return (query.select ?? []).map((sel) => makePartList(sel, dynamicSelectPartOptions));\n  }, [measurement, policy, query.select, datasource]);\n\n  // the following function is not complicated enough to memoize, but it's result\n  // is used in both memoized and un-memoized parts, so we have no choice\n  const getTagKeys = useMemo(() => {\n    return () =>\n      allTagKeys.then((keys) =>\n        getTagKeysForMeasurementAndTags(measurement, policy, filterTags(query.tags ?? [], keys), datasource)\n      );\n  }, [measurement, policy, query.tags, datasource, allTagKeys]);\n\n  const groupByList = useMemo(() => {\n    const dynamicGroupByPartOptions = new Map([['tag_0', getTagKeys]]);\n\n    return makePartList(query.groupBy ?? [], dynamicGroupByPartOptions);\n  }, [getTagKeys, query.groupBy]);\n\n  const onAppliedChange = (newQuery: InfluxQuery) => {\n    props.onChange(newQuery);\n    props.onRunQuery();\n  };\n  const handleFromSectionChange = (p: string | undefined, m: string | undefined) => {\n    onAppliedChange({\n      ...query,\n      policy: p,\n      measurement: m,\n    });\n  };\n\n  const handleTagsSectionChange = (tags: InfluxQueryTag[]) => {\n    // we set empty-arrays to undefined\n    onAppliedChange({\n      ...query,\n      tags: tags.length === 0 ? undefined : tags,\n    });\n  };\n\n  return (\n    <div>\n      <SegmentSection label=\"FROM\" fill={true}>\n        <FromSection\n          policy={policy}\n          measurement={measurement}\n          getPolicyOptions={() => getAllPolicies(datasource)}\n          getMeasurementOptions={(filter) =>\n            withTemplateVariableOptions(\n              allTagKeys.then((keys) =>\n                getAllMeasurementsForTags(\n                  filter === '' ? undefined : filter,\n                  filterTags(query.tags ?? [], keys),\n                  datasource\n                )\n              )\n            )\n          }\n          onChange={handleFromSectionChange}\n        />\n        <InlineLabel width=\"auto\" className={styles.inlineLabel}>\n          WHERE\n        </InlineLabel>\n        <TagsSection\n          tags={query.tags ?? []}\n          onChange={handleTagsSectionChange}\n          getTagKeyOptions={getTagKeys}\n          getTagValueOptions={(key: string) =>\n            withTemplateVariableOptions(\n              allTagKeys.then((keys) =>\n                getTagValues(key, measurement, policy, filterTags(query.tags ?? [], keys), datasource)\n              )\n            )\n          }\n        />\n      </SegmentSection>\n      {selectLists.map((sel, index) => (\n        <SegmentSection key={index} label={index === 0 ? 'SELECT' : ''} fill={true}>\n          <PartListSection\n            parts={sel}\n            getNewPartOptions={() => Promise.resolve(getNewSelectPartOptions())}\n            onChange={(partIndex, newParams) => {\n              const newQuery = changeSelectPart(query, index, partIndex, newParams);\n              onAppliedChange(newQuery);\n            }}\n            onAddNewPart={(type) => {\n              onAppliedChange(addNewSelectPart(query, type, index));\n            }}\n            onRemovePart={(partIndex) => {\n              onAppliedChange(removeSelectPart(query, partIndex, index));\n            }}\n          />\n        </SegmentSection>\n      ))}\n      <SegmentSection label=\"GROUP BY\" fill={true}>\n        <PartListSection\n          parts={groupByList}\n          getNewPartOptions={() => getNewGroupByPartOptions(query, getTagKeys)}\n          onChange={(partIndex, newParams) => {\n            const newQuery = changeGroupByPart(query, partIndex, newParams);\n            onAppliedChange(newQuery);\n          }}\n          onAddNewPart={(type) => {\n            onAppliedChange(addNewGroupByPart(query, type));\n          }}\n          onRemovePart={(partIndex) => {\n            onAppliedChange(removeGroupByPart(query, partIndex));\n          }}\n        />\n      </SegmentSection>\n      <SegmentSection label=\"TIMEZONE\" fill={true}>\n        <InputSection\n          placeholder=\"(optional)\"\n          value={query.tz}\n          onChange={(tz) => {\n            onAppliedChange({ ...query, tz });\n          }}\n        />\n        <InlineLabel htmlFor={orderByTimeId} width=\"auto\" className={styles.inlineLabel}>\n          ORDER BY TIME\n        </InlineLabel>\n        <OrderByTimeSection\n          inputId={orderByTimeId}\n          value={query.orderByTime === 'DESC' ? 'DESC' : 'ASC' /* FIXME: make this shared with influx_query_model */}\n          onChange={(v) => {\n            onAppliedChange({ ...query, orderByTime: v });\n          }}\n        />\n      </SegmentSection>\n      {/* query.fill is ignored in the query-editor, and it is deleted whenever\n          query-editor changes. the influx_query_model still handles it, but the new\n          approach seem to be to handle \"fill\" inside query.groupBy. so, if you\n          have a panel where in the json you have query.fill, it will be applied,\n          as long as you do not edit that query. */}\n      <SegmentSection label=\"LIMIT\" fill={true}>\n        <InputSection\n          placeholder=\"(optional)\"\n          value={query.limit?.toString()}\n          onChange={(limit) => {\n            onAppliedChange({ ...query, limit });\n          }}\n        />\n        <InlineLabel width=\"auto\" className={styles.inlineLabel}>\n          SLIMIT\n        </InlineLabel>\n        <InputSection\n          placeholder=\"(optional)\"\n          value={query.slimit?.toString()}\n          onChange={(slimit) => {\n            onAppliedChange({ ...query, slimit });\n          }}\n        />\n      </SegmentSection>\n      <SegmentSection htmlFor={formatAsId} label=\"FORMAT AS\" fill={true}>\n        <FormatAsSection\n          inputId={formatAsId}\n          format={query.resultFormat ?? DEFAULT_RESULT_FORMAT}\n          onChange={(format) => {\n            onAppliedChange({ ...query, resultFormat: format });\n          }}\n        />\n        {query.resultFormat !== 'table' && (\n          <>\n            <InlineLabel width=\"auto\" className={styles.inlineLabel}>\n              ALIAS\n            </InlineLabel>\n            <InputSection\n              isWide\n              placeholder=\"Naming pattern\"\n              value={query.alias}\n              onChange={(alias) => {\n                onAppliedChange({ ...query, alias });\n              }}\n            />\n          </>\n        )}\n      </SegmentSection>\n    </div>\n  );\n};\n\nfunction getStyles(theme: GrafanaTheme2) {\n  return {\n    inlineLabel: css`\n      color: ${theme.colors.primary.text};\n    `,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}