{"ast":null,"code":"import { ReducerID } from '@grafana/data';\nexport let ExpressionQueryType;\n\n(function (ExpressionQueryType) {\n  ExpressionQueryType[\"math\"] = \"math\";\n  ExpressionQueryType[\"reduce\"] = \"reduce\";\n  ExpressionQueryType[\"resample\"] = \"resample\";\n  ExpressionQueryType[\"classic\"] = \"classic_conditions\";\n})(ExpressionQueryType || (ExpressionQueryType = {}));\n\nexport const gelTypes = [{\n  value: ExpressionQueryType.math,\n  label: 'Math'\n}, {\n  value: ExpressionQueryType.reduce,\n  label: 'Reduce'\n}, {\n  value: ExpressionQueryType.resample,\n  label: 'Resample'\n}, {\n  value: ExpressionQueryType.classic,\n  label: 'Classic condition'\n}];\nexport const reducerTypes = [{\n  value: ReducerID.min,\n  label: 'Min',\n  description: 'Get the minimum value'\n}, {\n  value: ReducerID.max,\n  label: 'Max',\n  description: 'Get the maximum value'\n}, {\n  value: ReducerID.mean,\n  label: 'Mean',\n  description: 'Get the average value'\n}, {\n  value: ReducerID.sum,\n  label: 'Sum',\n  description: 'Get the sum of all values'\n}, {\n  value: ReducerID.count,\n  label: 'Count',\n  description: 'Get the number of values'\n}, {\n  value: ReducerID.last,\n  label: 'Last',\n  description: 'Get the last value'\n}];\nexport let ReducerMode;\n\n(function (ReducerMode) {\n  ReducerMode[\"Strict\"] = \"\";\n  ReducerMode[\"ReplaceNonNumbers\"] = \"replaceNN\";\n  ReducerMode[\"DropNonNumbers\"] = \"dropNN\";\n})(ReducerMode || (ReducerMode = {}));\n\nexport const reducerMode = [{\n  value: ReducerMode.Strict,\n  label: 'Strict',\n  description: 'Result can be NaN if series contains non-numeric data'\n}, {\n  value: ReducerMode.DropNonNumbers,\n  label: 'Drop Non-numeric Values',\n  description: 'Drop NaN, +/-Inf and null from input series before reducing'\n}, {\n  value: ReducerMode.ReplaceNonNumbers,\n  label: 'Replace Non-numeric Values',\n  description: 'Replace NaN, +/-Inf and null with a constant value before reducing'\n}];\nexport const downsamplingTypes = [{\n  value: ReducerID.min,\n  label: 'Min',\n  description: 'Fill with the minimum value'\n}, {\n  value: ReducerID.max,\n  label: 'Max',\n  description: 'Fill with the maximum value'\n}, {\n  value: ReducerID.mean,\n  label: 'Mean',\n  description: 'Fill with the average value'\n}, {\n  value: ReducerID.sum,\n  label: 'Sum',\n  description: 'Fill with the sum of all values'\n}];\nexport const upsamplingTypes = [{\n  value: 'pad',\n  label: 'pad',\n  description: 'fill with the last known value'\n}, {\n  value: 'backfilling',\n  label: 'backfilling',\n  description: 'fill with the next known value'\n}, {\n  value: 'fillna',\n  label: 'fillna',\n  description: 'Fill with NaNs'\n}];\n/**\n * For now this is a single object to cover all the types.... would likely\n * want to split this up by type as the complexity increases\n */","map":{"version":3,"names":["ReducerID","ExpressionQueryType","gelTypes","value","math","label","reduce","resample","classic","reducerTypes","min","description","max","mean","sum","count","last","ReducerMode","reducerMode","Strict","DropNonNumbers","ReplaceNonNumbers","downsamplingTypes","upsamplingTypes"],"sources":["/home/soula/grafana/public/app/features/expressions/types.ts"],"sourcesContent":["import { DataQuery, ReducerID, SelectableValue } from '@grafana/data';\n\nimport { EvalFunction } from '../alerting/state/alertDef';\n\nexport enum ExpressionQueryType {\n  math = 'math',\n  reduce = 'reduce',\n  resample = 'resample',\n  classic = 'classic_conditions',\n}\n\nexport const gelTypes: Array<SelectableValue<ExpressionQueryType>> = [\n  { value: ExpressionQueryType.math, label: 'Math' },\n  { value: ExpressionQueryType.reduce, label: 'Reduce' },\n  { value: ExpressionQueryType.resample, label: 'Resample' },\n  { value: ExpressionQueryType.classic, label: 'Classic condition' },\n];\n\nexport const reducerTypes: Array<SelectableValue<string>> = [\n  { value: ReducerID.min, label: 'Min', description: 'Get the minimum value' },\n  { value: ReducerID.max, label: 'Max', description: 'Get the maximum value' },\n  { value: ReducerID.mean, label: 'Mean', description: 'Get the average value' },\n  { value: ReducerID.sum, label: 'Sum', description: 'Get the sum of all values' },\n  { value: ReducerID.count, label: 'Count', description: 'Get the number of values' },\n  { value: ReducerID.last, label: 'Last', description: 'Get the last value' },\n];\n\nexport enum ReducerMode {\n  Strict = '', // backend API wants an empty string to support \"strict\" mode\n  ReplaceNonNumbers = 'replaceNN',\n  DropNonNumbers = 'dropNN',\n}\n\nexport const reducerMode: Array<SelectableValue<ReducerMode>> = [\n  {\n    value: ReducerMode.Strict,\n    label: 'Strict',\n    description: 'Result can be NaN if series contains non-numeric data',\n  },\n  {\n    value: ReducerMode.DropNonNumbers,\n    label: 'Drop Non-numeric Values',\n    description: 'Drop NaN, +/-Inf and null from input series before reducing',\n  },\n  {\n    value: ReducerMode.ReplaceNonNumbers,\n    label: 'Replace Non-numeric Values',\n    description: 'Replace NaN, +/-Inf and null with a constant value before reducing',\n  },\n];\n\nexport const downsamplingTypes: Array<SelectableValue<string>> = [\n  { value: ReducerID.min, label: 'Min', description: 'Fill with the minimum value' },\n  { value: ReducerID.max, label: 'Max', description: 'Fill with the maximum value' },\n  { value: ReducerID.mean, label: 'Mean', description: 'Fill with the average value' },\n  { value: ReducerID.sum, label: 'Sum', description: 'Fill with the sum of all values' },\n];\n\nexport const upsamplingTypes: Array<SelectableValue<string>> = [\n  { value: 'pad', label: 'pad', description: 'fill with the last known value' },\n  { value: 'backfilling', label: 'backfilling', description: 'fill with the next known value' },\n  { value: 'fillna', label: 'fillna', description: 'Fill with NaNs' },\n];\n\n/**\n * For now this is a single object to cover all the types.... would likely\n * want to split this up by type as the complexity increases\n */\nexport interface ExpressionQuery extends DataQuery {\n  type: ExpressionQueryType;\n  reducer?: string;\n  expression?: string;\n  window?: string;\n  downsampler?: string;\n  upsampler?: string;\n  conditions?: ClassicCondition[];\n  settings?: ExpressionQuerySettings;\n}\n\nexport interface ExpressionQuerySettings {\n  mode?: ReducerMode;\n  replaceWithValue?: number;\n}\n\nexport interface ClassicCondition {\n  evaluator: {\n    params: number[];\n    type: EvalFunction;\n  };\n  operator?: {\n    type: string;\n  };\n  query: {\n    params: string[];\n  };\n  reducer: {\n    params: [];\n    type: ReducerType;\n  };\n  type: 'query';\n}\n\nexport type ReducerType =\n  | 'avg'\n  | 'min'\n  | 'max'\n  | 'sum'\n  | 'count'\n  | 'last'\n  | 'median'\n  | 'diff'\n  | 'diff_abs'\n  | 'percent_diff'\n  | 'percent_diff_abs'\n  | 'count_non_null';\n"],"mappings":"AAAA,SAAoBA,SAApB,QAAsD,eAAtD;AAIA,WAAYC,mBAAZ;;WAAYA,mB;EAAAA,mB;EAAAA,mB;EAAAA,mB;EAAAA,mB;GAAAA,mB,KAAAA,mB;;AAOZ,OAAO,MAAMC,QAAqD,GAAG,CACnE;EAAEC,KAAK,EAAEF,mBAAmB,CAACG,IAA7B;EAAmCC,KAAK,EAAE;AAA1C,CADmE,EAEnE;EAAEF,KAAK,EAAEF,mBAAmB,CAACK,MAA7B;EAAqCD,KAAK,EAAE;AAA5C,CAFmE,EAGnE;EAAEF,KAAK,EAAEF,mBAAmB,CAACM,QAA7B;EAAuCF,KAAK,EAAE;AAA9C,CAHmE,EAInE;EAAEF,KAAK,EAAEF,mBAAmB,CAACO,OAA7B;EAAsCH,KAAK,EAAE;AAA7C,CAJmE,CAA9D;AAOP,OAAO,MAAMI,YAA4C,GAAG,CAC1D;EAAEN,KAAK,EAAEH,SAAS,CAACU,GAAnB;EAAwBL,KAAK,EAAE,KAA/B;EAAsCM,WAAW,EAAE;AAAnD,CAD0D,EAE1D;EAAER,KAAK,EAAEH,SAAS,CAACY,GAAnB;EAAwBP,KAAK,EAAE,KAA/B;EAAsCM,WAAW,EAAE;AAAnD,CAF0D,EAG1D;EAAER,KAAK,EAAEH,SAAS,CAACa,IAAnB;EAAyBR,KAAK,EAAE,MAAhC;EAAwCM,WAAW,EAAE;AAArD,CAH0D,EAI1D;EAAER,KAAK,EAAEH,SAAS,CAACc,GAAnB;EAAwBT,KAAK,EAAE,KAA/B;EAAsCM,WAAW,EAAE;AAAnD,CAJ0D,EAK1D;EAAER,KAAK,EAAEH,SAAS,CAACe,KAAnB;EAA0BV,KAAK,EAAE,OAAjC;EAA0CM,WAAW,EAAE;AAAvD,CAL0D,EAM1D;EAAER,KAAK,EAAEH,SAAS,CAACgB,IAAnB;EAAyBX,KAAK,EAAE,MAAhC;EAAwCM,WAAW,EAAE;AAArD,CAN0D,CAArD;AASP,WAAYM,WAAZ;;WAAYA,W;EAAAA,W;EAAAA,W;EAAAA,W;GAAAA,W,KAAAA,W;;AAMZ,OAAO,MAAMC,WAAgD,GAAG,CAC9D;EACEf,KAAK,EAAEc,WAAW,CAACE,MADrB;EAEEd,KAAK,EAAE,QAFT;EAGEM,WAAW,EAAE;AAHf,CAD8D,EAM9D;EACER,KAAK,EAAEc,WAAW,CAACG,cADrB;EAEEf,KAAK,EAAE,yBAFT;EAGEM,WAAW,EAAE;AAHf,CAN8D,EAW9D;EACER,KAAK,EAAEc,WAAW,CAACI,iBADrB;EAEEhB,KAAK,EAAE,4BAFT;EAGEM,WAAW,EAAE;AAHf,CAX8D,CAAzD;AAkBP,OAAO,MAAMW,iBAAiD,GAAG,CAC/D;EAAEnB,KAAK,EAAEH,SAAS,CAACU,GAAnB;EAAwBL,KAAK,EAAE,KAA/B;EAAsCM,WAAW,EAAE;AAAnD,CAD+D,EAE/D;EAAER,KAAK,EAAEH,SAAS,CAACY,GAAnB;EAAwBP,KAAK,EAAE,KAA/B;EAAsCM,WAAW,EAAE;AAAnD,CAF+D,EAG/D;EAAER,KAAK,EAAEH,SAAS,CAACa,IAAnB;EAAyBR,KAAK,EAAE,MAAhC;EAAwCM,WAAW,EAAE;AAArD,CAH+D,EAI/D;EAAER,KAAK,EAAEH,SAAS,CAACc,GAAnB;EAAwBT,KAAK,EAAE,KAA/B;EAAsCM,WAAW,EAAE;AAAnD,CAJ+D,CAA1D;AAOP,OAAO,MAAMY,eAA+C,GAAG,CAC7D;EAAEpB,KAAK,EAAE,KAAT;EAAgBE,KAAK,EAAE,KAAvB;EAA8BM,WAAW,EAAE;AAA3C,CAD6D,EAE7D;EAAER,KAAK,EAAE,aAAT;EAAwBE,KAAK,EAAE,aAA/B;EAA8CM,WAAW,EAAE;AAA3D,CAF6D,EAG7D;EAAER,KAAK,EAAE,QAAT;EAAmBE,KAAK,EAAE,QAA1B;EAAoCM,WAAW,EAAE;AAAjD,CAH6D,CAAxD;AAMP;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}