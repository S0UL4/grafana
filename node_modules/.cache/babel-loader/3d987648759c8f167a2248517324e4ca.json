{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { chain, difference } from 'lodash';\nimport LRU from 'lru-cache';\nimport Prism from 'prismjs';\nimport { dateTime, LanguageProvider } from '@grafana/data';\nimport { extractLabelMatchers, parseSelector, processLabels, toPromLikeExpr } from 'app/plugins/datasource/prometheus/language_utils';\nimport syntax, { FUNCTIONS, PIPE_PARSERS, PIPE_OPERATORS } from './syntax';\nimport { LokiQueryType } from './types';\nconst DEFAULT_KEYS = ['job', 'namespace'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 10;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\n\nconst NS_IN_MS = 1000000; // When changing RATE_RANGES, check if Prometheus/PromQL ranges should be changed too\n// @see public/app/plugins/datasource/prometheus/promql.ts\n\nconst RATE_RANGES = [{\n  label: '$__interval',\n  sortValue: '$__interval'\n}, {\n  label: '$__range',\n  sortValue: '$__range'\n}, {\n  label: '1m',\n  sortValue: '00:01:00'\n}, {\n  label: '5m',\n  sortValue: '00:05:00'\n}, {\n  label: '10m',\n  sortValue: '00:10:00'\n}, {\n  label: '30m',\n  sortValue: '00:30:00'\n}, {\n  label: '1h',\n  sortValue: '01:00:00'\n}, {\n  label: '1d',\n  sortValue: '24:00:00'\n}];\nexport const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec\n\nconst wrapLabel = label => ({\n  label,\n  filterText: `\\\"${label}\\\"`\n});\n\nexport function addHistoryMetadata(item, history) {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query.expr === item.label);\n  let hint = `Queried ${historyForItem.length} times in the last 24h.`;\n  const recent = historyForItem[0];\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return Object.assign({}, item, {\n    documentation: hint\n  });\n}\nexport default class LokiLanguageProvider extends LanguageProvider {\n  // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  constructor(datasource, initialValues) {\n    super();\n\n    _defineProperty(this, \"labelKeys\", void 0);\n\n    _defineProperty(this, \"labelFetchTs\", void 0);\n\n    _defineProperty(this, \"started\", false);\n\n    _defineProperty(this, \"datasource\", void 0);\n\n    _defineProperty(this, \"lookupsDisabled\", false);\n\n    _defineProperty(this, \"seriesCache\", new LRU({\n      max: 10\n    }));\n\n    _defineProperty(this, \"labelsCache\", new LRU({\n      max: 10\n    }));\n\n    _defineProperty(this, \"cleanText\", s => s.replace(/[{}[\\]=\"(),!~+\\-*/^%\\|]/g, '').trim());\n\n    _defineProperty(this, \"request\", async (url, params) => {\n      try {\n        return await this.datasource.metadataRequest(url, params);\n      } catch (error) {\n        console.error(error);\n      }\n\n      return undefined;\n    });\n\n    _defineProperty(this, \"start\", () => {\n      if (!this.startTask) {\n        this.startTask = this.fetchLabels().then(() => {\n          this.started = true;\n          return [];\n        });\n      }\n\n      return this.startTask;\n    });\n\n    _defineProperty(this, \"getBeginningCompletionItems\", context => {\n      return {\n        suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions]\n      };\n    });\n\n    _defineProperty(this, \"getTermCompletionItems\", () => {\n      const suggestions = [];\n      suggestions.push({\n        prefixMatch: true,\n        label: 'Functions',\n        items: FUNCTIONS.map(suggestion => Object.assign({}, suggestion, {\n          kind: 'function'\n        }))\n      });\n      return {\n        suggestions\n      };\n    });\n\n    _defineProperty(this, \"getPipeCompletionItem\", () => {\n      const suggestions = [];\n      suggestions.push({\n        label: 'Operators',\n        items: PIPE_OPERATORS.map(suggestion => Object.assign({}, suggestion, {\n          kind: 'operators'\n        }))\n      });\n      suggestions.push({\n        label: 'Parsers',\n        items: PIPE_PARSERS.map(suggestion => Object.assign({}, suggestion, {\n          kind: 'parsers'\n        }))\n      });\n      return {\n        suggestions\n      };\n    });\n\n    _defineProperty(this, \"fetchSeriesLabels\", async match => {\n      const interpolatedMatch = this.datasource.interpolateString(match);\n      const url = 'series';\n      const {\n        start,\n        end\n      } = this.datasource.getTimeRangeParams();\n      const cacheKey = this.generateCacheKey(url, start, end, interpolatedMatch);\n      let value = this.seriesCache.get(cacheKey);\n\n      if (!value) {\n        // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n        this.seriesCache.set(cacheKey, {});\n        const params = {\n          'match[]': interpolatedMatch,\n          start,\n          end\n        };\n        const data = await this.request(url, params);\n        const {\n          values\n        } = processLabels(data);\n        value = values;\n        this.seriesCache.set(cacheKey, value);\n      }\n\n      return value;\n    });\n\n    _defineProperty(this, \"fetchSeries\", async match => {\n      const url = 'series';\n      const {\n        start,\n        end\n      } = this.datasource.getTimeRangeParams();\n      const params = {\n        'match[]': match,\n        start,\n        end\n      };\n      return await this.request(url, params);\n    });\n\n    this.datasource = datasource;\n    this.labelKeys = [];\n    this.labelFetchTs = 0;\n    Object.assign(this, initialValues);\n  } // Strip syntax chars\n\n\n  getSyntax() {\n    return syntax;\n  }\n\n  getLabelKeys() {\n    return this.labelKeys;\n  }\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n\n\n  async provideCompletionItems(input, context) {\n    const {\n      wrapperClasses,\n      value,\n      prefix,\n      text\n    } = input;\n    const emptyResult = {\n      suggestions: []\n    };\n\n    if (!value) {\n      return emptyResult;\n    } // Local text properties\n\n\n    const empty = (value === null || value === void 0 ? void 0 : value.document.text.length) === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null; // Syntax spans have 3 classes by default. More indicate a recognized token\n\n    const tokenRecognized = wrapperClasses.length > 3; // Non-empty prefix, but not inside known token\n\n    const prefixUnrecognized = prefix && !tokenRecognized; // Prevent suggestions in `function(|suffix)`\n\n    const noSuffix = !nextCharacter || nextCharacter === ')'; // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n\n    const safePrefix = prefix && !text.match(/^['\"~=\\]})\\s]+$/) && noSuffix; // About to type next operand if preceded by binary operator\n\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern); // Determine candidates by CSS context\n\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for {|} and {foo=|}\n      return await this.getLabelCompletionItems(input);\n    } else if (wrapperClasses.includes('context-pipe')) {\n      return this.getPipeCompletionItem();\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  }\n\n  getEmptyCompletionItems(context) {\n    const history = context === null || context === void 0 ? void 0 : context.history;\n    const suggestions = [];\n\n    if (history !== null && history !== void 0 && history.length) {\n      const historyItems = chain(history).map(h => h.query.expr).filter().uniq().take(HISTORY_ITEM_COUNT).map(wrapLabel).map(item => addHistoryMetadata(item, history)).value();\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems\n      });\n    }\n\n    return {\n      suggestions\n    };\n  }\n\n  getRangeCompletionItems() {\n    return {\n      context: 'context-range',\n      suggestions: [{\n        label: 'Range vector',\n        items: [...RATE_RANGES]\n      }]\n    };\n  }\n\n  async getLabelCompletionItems({\n    text,\n    wrapperClasses,\n    labelKey,\n    value\n  }) {\n    let context = 'context-labels';\n    const suggestions = [];\n\n    if (!value) {\n      return {\n        context,\n        suggestions: []\n      };\n    }\n\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const isValueStart = text.match(/^(=|=~|!=|!~)/); // Get normalized selector\n\n    let selector;\n    let parsedSelector;\n\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    if (!labelKey && selector === EMPTY_SELECTOR) {\n      // start task gets all labels\n      await this.start();\n      const allLabels = this.getLabelKeys();\n      return {\n        context,\n        suggestions: [{\n          label: `Labels`,\n          items: allLabels.map(wrapLabel)\n        }]\n      };\n    }\n\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n    let labelValues; // Query labels for selector\n\n    if (selector) {\n      if (selector === EMPTY_SELECTOR && labelKey) {\n        const labelValuesForKey = await this.getLabelValues(labelKey);\n        labelValues = {\n          [labelKey]: labelValuesForKey\n        };\n      } else {\n        labelValues = await this.getSeriesLabels(selector);\n      }\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return {\n        context,\n        suggestions\n      };\n    }\n\n    if (text && isValueStart || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          // Filter to prevent previously selected values from being repeatedly suggested\n          items: labelValues[labelKey].map(wrapLabel).filter(({\n            filterText\n          }) => filterText !== text)\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : DEFAULT_KEYS;\n\n      if (labelKeys) {\n        const possibleKeys = difference(labelKeys, existingKeys);\n\n        if (possibleKeys.length) {\n          const newItems = possibleKeys.map(key => ({\n            label: key\n          }));\n          const newSuggestion = {\n            label: `Labels`,\n            items: newItems\n          };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return {\n      context,\n      suggestions\n    };\n  }\n\n  importFromAbstractQuery(labelBasedQuery) {\n    return {\n      refId: labelBasedQuery.refId,\n      expr: toPromLikeExpr(labelBasedQuery),\n      queryType: LokiQueryType.Range\n    };\n  }\n\n  exportToAbstractQuery(query) {\n    const lokiQuery = query.expr;\n\n    if (!lokiQuery || lokiQuery.length === 0) {\n      return {\n        refId: query.refId,\n        labelMatchers: []\n      };\n    }\n\n    const tokens = Prism.tokenize(lokiQuery, syntax);\n    return {\n      refId: query.refId,\n      labelMatchers: extractLabelMatchers(tokens)\n    };\n  }\n\n  async getSeriesLabels(selector) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n\n    try {\n      return await this.fetchSeriesLabels(selector);\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n  /**\n   * Fetches all label keys\n   */\n\n\n  async fetchLabels() {\n    const url = 'labels';\n    const timeRange = this.datasource.getTimeRangeParams();\n    this.labelFetchTs = Date.now().valueOf();\n    const res = await this.request(url, timeRange);\n\n    if (Array.isArray(res)) {\n      const labels = res.slice().sort().filter(label => label !== '__name__');\n      this.labelKeys = labels;\n    }\n\n    return [];\n  }\n\n  async refreshLogLabels(forceRefresh) {\n    if (this.labelKeys && Date.now().valueOf() - this.labelFetchTs > LABEL_REFRESH_INTERVAL || forceRefresh) {\n      await this.fetchLabels();\n    }\n  }\n  /**\n   * Fetch labels for a selector. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   */\n\n\n  // Cache key is a bit different here. We round up to a minute the intervals.\n  // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n  // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n  // when user does not the newest values for a minute if already cached.\n  generateCacheKey(url, start, end, param) {\n    return [url, this.roundTime(start), this.roundTime(end), param].join();\n  } // Round nanos epoch to nearest 5 minute interval\n\n\n  roundTime(nanos) {\n    return nanos ? Math.floor(nanos / NS_IN_MS / 1000 / 60 / 5) : 0;\n  }\n\n  async getLabelValues(key) {\n    return await this.fetchLabelValues(key);\n  }\n\n  async fetchLabelValues(key) {\n    var _labelValues;\n\n    const interpolatedKey = encodeURIComponent(this.datasource.interpolateString(key));\n    const url = `label/${interpolatedKey}/values`;\n    const rangeParams = this.datasource.getTimeRangeParams();\n    const {\n      start,\n      end\n    } = rangeParams;\n    const cacheKey = this.generateCacheKey(url, start, end, interpolatedKey);\n    const params = {\n      start,\n      end\n    };\n    let labelValues = this.labelsCache.get(cacheKey);\n\n    if (!labelValues) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.labelsCache.set(cacheKey, []);\n      const res = await this.request(url, params);\n\n      if (Array.isArray(res)) {\n        labelValues = res.slice().sort();\n        this.labelsCache.set(cacheKey, labelValues);\n      }\n    }\n\n    return (_labelValues = labelValues) !== null && _labelValues !== void 0 ? _labelValues : [];\n  }\n\n}","map":{"version":3,"names":["chain","difference","LRU","Prism","dateTime","LanguageProvider","extractLabelMatchers","parseSelector","processLabels","toPromLikeExpr","syntax","FUNCTIONS","PIPE_PARSERS","PIPE_OPERATORS","LokiQueryType","DEFAULT_KEYS","EMPTY_SELECTOR","HISTORY_ITEM_COUNT","HISTORY_COUNT_CUTOFF","NS_IN_MS","RATE_RANGES","label","sortValue","LABEL_REFRESH_INTERVAL","wrapLabel","filterText","addHistoryMetadata","item","history","cutoffTs","Date","now","historyForItem","filter","h","ts","query","expr","hint","length","recent","lastQueried","fromNow","documentation","LokiLanguageProvider","constructor","datasource","initialValues","max","s","replace","trim","url","params","metadataRequest","error","console","undefined","startTask","fetchLabels","then","started","context","suggestions","getEmptyCompletionItems","getTermCompletionItems","push","prefixMatch","items","map","suggestion","kind","match","interpolatedMatch","interpolateString","start","end","getTimeRangeParams","cacheKey","generateCacheKey","value","seriesCache","get","set","data","request","values","labelKeys","labelFetchTs","Object","assign","getSyntax","getLabelKeys","provideCompletionItems","input","wrapperClasses","prefix","text","emptyResult","empty","document","selectedLines","getTextsAtRange","selection","currentLine","size","first","getText","nextCharacter","anchor","offset","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","operatorsPattern","isNextOperand","includes","getRangeCompletionItems","getLabelCompletionItems","getPipeCompletionItem","getBeginningCompletionItems","historyItems","uniq","take","skipSort","labelKey","line","anchorBlock","cursorOffset","isValueStart","selector","parsedSelector","allLabels","existingKeys","labelValues","labelValuesForKey","getLabelValues","getSeriesLabels","warn","keys","possibleKeys","newItems","key","newSuggestion","importFromAbstractQuery","labelBasedQuery","refId","queryType","Range","exportToAbstractQuery","lokiQuery","labelMatchers","tokens","tokenize","lookupsDisabled","fetchSeriesLabels","timeRange","valueOf","res","Array","isArray","labels","slice","sort","refreshLogLabels","forceRefresh","param","roundTime","join","nanos","Math","floor","fetchLabelValues","interpolatedKey","encodeURIComponent","rangeParams","labelsCache"],"sources":["/home/soula/grafana/public/app/plugins/datasource/loki/language_provider.ts"],"sourcesContent":["import { chain, difference } from 'lodash';\nimport LRU from 'lru-cache';\nimport Prism, { Grammar } from 'prismjs';\n\nimport { dateTime, AbsoluteTimeRange, LanguageProvider, HistoryItem, AbstractQuery } from '@grafana/data';\nimport { CompletionItem, TypeaheadInput, TypeaheadOutput, CompletionItemGroup } from '@grafana/ui';\nimport {\n  extractLabelMatchers,\n  parseSelector,\n  processLabels,\n  toPromLikeExpr,\n} from 'app/plugins/datasource/prometheus/language_utils';\n\nimport { LokiDatasource } from './datasource';\nimport syntax, { FUNCTIONS, PIPE_PARSERS, PIPE_OPERATORS } from './syntax';\nimport { LokiQuery, LokiQueryType } from './types';\n\nconst DEFAULT_KEYS = ['job', 'namespace'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 10;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nconst NS_IN_MS = 1000000;\n\n// When changing RATE_RANGES, check if Prometheus/PromQL ranges should be changed too\n// @see public/app/plugins/datasource/prometheus/promql.ts\nconst RATE_RANGES: CompletionItem[] = [\n  { label: '$__interval', sortValue: '$__interval' },\n  { label: '$__range', sortValue: '$__range' },\n  { label: '1m', sortValue: '00:01:00' },\n  { label: '5m', sortValue: '00:05:00' },\n  { label: '10m', sortValue: '00:10:00' },\n  { label: '30m', sortValue: '00:30:00' },\n  { label: '1h', sortValue: '01:00:00' },\n  { label: '1d', sortValue: '24:00:00' },\n];\n\nexport const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec\n\nconst wrapLabel = (label: string) => ({ label, filterText: `\\\"${label}\\\"` });\n\nexport type LokiHistoryItem = HistoryItem<LokiQuery>;\n\ntype TypeaheadContext = {\n  history?: LokiHistoryItem[];\n  absoluteRange?: AbsoluteTimeRange;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: LokiHistoryItem[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter((h) => h.ts > cutoffTs && h.query.expr === item.label);\n  let hint = `Queried ${historyForItem.length} times in the last 24h.`;\n  const recent = historyForItem[0];\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nexport default class LokiLanguageProvider extends LanguageProvider {\n  labelKeys: string[];\n  labelFetchTs: number;\n  started = false;\n  datasource: LokiDatasource;\n  lookupsDisabled = false; // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private seriesCache = new LRU<string, Record<string, string[]>>({ max: 10 });\n  private labelsCache = new LRU<string, string[]>({ max: 10 });\n\n  constructor(datasource: LokiDatasource, initialValues?: any) {\n    super();\n\n    this.datasource = datasource;\n    this.labelKeys = [];\n    this.labelFetchTs = 0;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars\n  cleanText = (s: string) => s.replace(/[{}[\\]=\"(),!~+\\-*/^%\\|]/g, '').trim();\n\n  getSyntax(): Grammar {\n    return syntax;\n  }\n\n  request = async (url: string, params?: any): Promise<any> => {\n    try {\n      return await this.datasource.metadataRequest(url, params);\n    } catch (error) {\n      console.error(error);\n    }\n\n    return undefined;\n  };\n\n  /**\n   * Initialise the language provider by fetching set of labels. Without this initialisation the provider would return\n   * just a set of hardcoded default labels on provideCompletionItems or a recent queries from history.\n   */\n  start = () => {\n    if (!this.startTask) {\n      this.startTask = this.fetchLabels().then(() => {\n        this.started = true;\n        return [];\n      });\n    }\n\n    return this.startTask;\n  };\n\n  getLabelKeys(): string[] {\n    return this.labelKeys;\n  }\n\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n  async provideCompletionItems(input: TypeaheadInput, context?: TypeaheadContext): Promise<TypeaheadOutput> {\n    const { wrapperClasses, value, prefix, text } = input;\n    const emptyResult: TypeaheadOutput = { suggestions: [] };\n\n    if (!value) {\n      return emptyResult;\n    }\n\n    // Local text properties\n    const empty = value?.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^['\"~=\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for {|} and {foo=|}\n      return await this.getLabelCompletionItems(input);\n    } else if (wrapperClasses.includes('context-pipe')) {\n      return this.getPipeCompletionItem();\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  }\n\n  getBeginningCompletionItems = (context?: TypeaheadContext): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems(context?: TypeaheadContext): TypeaheadOutput {\n    const history = context?.history;\n    const suggestions = [];\n\n    if (history?.length) {\n      const historyItems = chain(history)\n        .map((h) => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  }\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map((suggestion) => ({ ...suggestion, kind: 'function' })),\n    });\n\n    return { suggestions };\n  };\n\n  getPipeCompletionItem = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      label: 'Operators',\n      items: PIPE_OPERATORS.map((suggestion) => ({ ...suggestion, kind: 'operators' })),\n    });\n\n    suggestions.push({\n      label: 'Parsers',\n      items: PIPE_PARSERS.map((suggestion) => ({ ...suggestion, kind: 'parsers' })),\n    });\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  async getLabelCompletionItems({ text, wrapperClasses, labelKey, value }: TypeaheadInput): Promise<TypeaheadOutput> {\n    let context = 'context-labels';\n    const suggestions: CompletionItemGroup[] = [];\n    if (!value) {\n      return { context, suggestions: [] };\n    }\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    if (!labelKey && selector === EMPTY_SELECTOR) {\n      // start task gets all labels\n      await this.start();\n      const allLabels = this.getLabelKeys();\n      return { context, suggestions: [{ label: `Labels`, items: allLabels.map(wrapLabel) }] };\n    }\n\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      if (selector === EMPTY_SELECTOR && labelKey) {\n        const labelValuesForKey = await this.getLabelValues(labelKey);\n        labelValues = { [labelKey]: labelValuesForKey };\n      } else {\n        labelValues = await this.getSeriesLabels(selector);\n      }\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { context, suggestions };\n    }\n\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          // Filter to prevent previously selected values from being repeatedly suggested\n          items: labelValues[labelKey].map(wrapLabel).filter(({ filterText }) => filterText !== text),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : DEFAULT_KEYS;\n      if (labelKeys) {\n        const possibleKeys = difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          const newItems = possibleKeys.map((key) => ({ label: key }));\n          const newSuggestion: CompletionItemGroup = { label: `Labels`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  }\n\n  importFromAbstractQuery(labelBasedQuery: AbstractQuery): LokiQuery {\n    return {\n      refId: labelBasedQuery.refId,\n      expr: toPromLikeExpr(labelBasedQuery),\n      queryType: LokiQueryType.Range,\n    };\n  }\n\n  exportToAbstractQuery(query: LokiQuery): AbstractQuery {\n    const lokiQuery = query.expr;\n    if (!lokiQuery || lokiQuery.length === 0) {\n      return { refId: query.refId, labelMatchers: [] };\n    }\n    const tokens = Prism.tokenize(lokiQuery, syntax);\n    return {\n      refId: query.refId,\n      labelMatchers: extractLabelMatchers(tokens),\n    };\n  }\n\n  async getSeriesLabels(selector: string) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      return await this.fetchSeriesLabels(selector);\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Fetches all label keys\n   */\n  async fetchLabels(): Promise<string[]> {\n    const url = 'labels';\n    const timeRange = this.datasource.getTimeRangeParams();\n    this.labelFetchTs = Date.now().valueOf();\n\n    const res = await this.request(url, timeRange);\n    if (Array.isArray(res)) {\n      const labels = res\n        .slice()\n        .sort()\n        .filter((label) => label !== '__name__');\n      this.labelKeys = labels;\n    }\n\n    return [];\n  }\n\n  async refreshLogLabels(forceRefresh?: boolean) {\n    if ((this.labelKeys && Date.now().valueOf() - this.labelFetchTs > LABEL_REFRESH_INTERVAL) || forceRefresh) {\n      await this.fetchLabels();\n    }\n  }\n\n  /**\n   * Fetch labels for a selector. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   */\n  fetchSeriesLabels = async (match: string): Promise<Record<string, string[]>> => {\n    const interpolatedMatch = this.datasource.interpolateString(match);\n    const url = 'series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n\n    const cacheKey = this.generateCacheKey(url, start, end, interpolatedMatch);\n    let value = this.seriesCache.get(cacheKey);\n    if (!value) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.seriesCache.set(cacheKey, {});\n      const params = { 'match[]': interpolatedMatch, start, end };\n      const data = await this.request(url, params);\n      const { values } = processLabels(data);\n      value = values;\n      this.seriesCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch series for a selector. Use this for raw results. Use fetchSeriesLabels() to get labels.\n   * @param match\n   */\n  fetchSeries = async (match: string): Promise<Array<Record<string, string>>> => {\n    const url = 'series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n    const params = { 'match[]': match, start, end };\n    return await this.request(url, params);\n  };\n\n  // Cache key is a bit different here. We round up to a minute the intervals.\n  // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n  // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n  // when user does not the newest values for a minute if already cached.\n  generateCacheKey(url: string, start: number, end: number, param: string): string {\n    return [url, this.roundTime(start), this.roundTime(end), param].join();\n  }\n\n  // Round nanos epoch to nearest 5 minute interval\n  roundTime(nanos: number): number {\n    return nanos ? Math.floor(nanos / NS_IN_MS / 1000 / 60 / 5) : 0;\n  }\n\n  async getLabelValues(key: string): Promise<string[]> {\n    return await this.fetchLabelValues(key);\n  }\n\n  async fetchLabelValues(key: string): Promise<string[]> {\n    const interpolatedKey = encodeURIComponent(this.datasource.interpolateString(key));\n\n    const url = `label/${interpolatedKey}/values`;\n    const rangeParams = this.datasource.getTimeRangeParams();\n    const { start, end } = rangeParams;\n\n    const cacheKey = this.generateCacheKey(url, start, end, interpolatedKey);\n    const params = { start, end };\n\n    let labelValues = this.labelsCache.get(cacheKey);\n    if (!labelValues) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.labelsCache.set(cacheKey, []);\n      const res = await this.request(url, params);\n      if (Array.isArray(res)) {\n        labelValues = res.slice().sort();\n        this.labelsCache.set(cacheKey, labelValues);\n      }\n    }\n\n    return labelValues ?? [];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}