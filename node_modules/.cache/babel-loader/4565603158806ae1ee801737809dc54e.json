{"ast":null,"code":"import { Subscription } from 'rxjs';\nimport { getDataSourceSrv, toDataQueryError } from '@grafana/runtime';\nimport { getVariableQueryEditor } from '../editor/getVariableQueryEditor';\nimport { addVariableEditorError, changeVariableEditorExtended, removeVariableEditorError } from '../editor/reducer';\nimport { getQueryVariableEditorState } from '../editor/selectors';\nimport { updateOptions } from '../state/actions';\nimport { toKeyedAction } from '../state/keyedVariablesReducer';\nimport { getVariable, getVariablesState } from '../state/selectors';\nimport { changeVariableProp } from '../state/sharedReducer';\nimport { hasOngoingTransaction, toKeyedVariableIdentifier, toVariablePayload } from '../utils';\nimport { getVariableQueryRunner } from './VariableQueryRunner';\nimport { variableQueryObserver } from './variableQueryObserver';\nexport const updateQueryVariableOptions = (identifier, searchFilter) => {\n  return async (dispatch, getState) => {\n    try {\n      var _variableInState$data;\n\n      const {\n        rootStateKey\n      } = identifier;\n\n      if (!hasOngoingTransaction(rootStateKey, getState())) {\n        // we might have cancelled a batch so then variable state is removed\n        return;\n      }\n\n      const variableInState = getVariable(identifier, getState());\n\n      if (getVariablesState(rootStateKey, getState()).editor.id === variableInState.id) {\n        dispatch(toKeyedAction(rootStateKey, removeVariableEditorError({\n          errorProp: 'update'\n        })));\n      }\n\n      const datasource = await getDataSourceSrv().get((_variableInState$data = variableInState.datasource) !== null && _variableInState$data !== void 0 ? _variableInState$data : ''); // We need to await the result from variableQueryRunner before moving on otherwise variables dependent on this\n      // variable will have the wrong current value as input\n\n      await new Promise((resolve, reject) => {\n        const subscription = new Subscription();\n        const observer = variableQueryObserver(resolve, reject, subscription);\n        const responseSubscription = getVariableQueryRunner().getResponse(identifier).subscribe(observer);\n        subscription.add(responseSubscription);\n        getVariableQueryRunner().queueRequest({\n          identifier,\n          datasource,\n          searchFilter\n        });\n      });\n    } catch (err) {\n      if (err instanceof Error) {\n        const error = toDataQueryError(err);\n        const {\n          rootStateKey\n        } = identifier;\n\n        if (getVariablesState(rootStateKey, getState()).editor.id === identifier.id) {\n          dispatch(toKeyedAction(rootStateKey, addVariableEditorError({\n            errorProp: 'update',\n            errorText: error.message\n          })));\n        }\n\n        throw error;\n      }\n    }\n  };\n};\nexport const initQueryVariableEditor = identifier => async (dispatch, getState) => {\n  const variable = getVariable(identifier, getState());\n  await dispatch(changeQueryVariableDataSource(toKeyedVariableIdentifier(variable), variable.datasource));\n};\nexport const changeQueryVariableDataSource = (identifier, name) => {\n  return async (dispatch, getState) => {\n    try {\n      const {\n        rootStateKey\n      } = identifier;\n      const {\n        editor\n      } = getVariablesState(rootStateKey, getState());\n      const extendedEditorState = getQueryVariableEditorState(editor);\n      const previousDatasource = extendedEditorState === null || extendedEditorState === void 0 ? void 0 : extendedEditorState.dataSource;\n      const dataSource = await getDataSourceSrv().get(name !== null && name !== void 0 ? name : '');\n\n      if (previousDatasource && previousDatasource.type !== (dataSource === null || dataSource === void 0 ? void 0 : dataSource.type)) {\n        dispatch(toKeyedAction(rootStateKey, changeVariableProp(toVariablePayload(identifier, {\n          propName: 'query',\n          propValue: ''\n        }))));\n      }\n\n      const VariableQueryEditor = await getVariableQueryEditor(dataSource);\n      dispatch(toKeyedAction(rootStateKey, changeVariableEditorExtended({\n        dataSource,\n        VariableQueryEditor\n      })));\n    } catch (err) {\n      console.error(err);\n    }\n  };\n};\nexport const changeQueryVariableQuery = (identifier, query, definition) => async (dispatch, getState) => {\n  const {\n    rootStateKey\n  } = identifier;\n  const variableInState = getVariable(identifier, getState());\n\n  if (hasSelfReferencingQuery(variableInState.name, query)) {\n    const errorText = 'Query cannot contain a reference to itself. Variable: $' + variableInState.name;\n    dispatch(toKeyedAction(rootStateKey, addVariableEditorError({\n      errorProp: 'query',\n      errorText\n    })));\n    return;\n  }\n\n  dispatch(toKeyedAction(rootStateKey, removeVariableEditorError({\n    errorProp: 'query'\n  })));\n  dispatch(toKeyedAction(rootStateKey, changeVariableProp(toVariablePayload(identifier, {\n    propName: 'query',\n    propValue: query\n  }))));\n\n  if (definition) {\n    dispatch(toKeyedAction(rootStateKey, changeVariableProp(toVariablePayload(identifier, {\n      propName: 'definition',\n      propValue: definition\n    }))));\n  } else if (typeof query === 'string') {\n    dispatch(toKeyedAction(rootStateKey, changeVariableProp(toVariablePayload(identifier, {\n      propName: 'definition',\n      propValue: query\n    }))));\n  }\n\n  await dispatch(updateOptions(identifier));\n};\nexport function hasSelfReferencingQuery(name, query) {\n  if (typeof query === 'string' && query.match(new RegExp('\\\\$' + name + '(/| |$)'))) {\n    return true;\n  }\n\n  const flattened = flattenQuery(query);\n\n  for (let prop in flattened) {\n    if (flattened.hasOwnProperty(prop)) {\n      const value = flattened[prop];\n\n      if (typeof value === 'string' && value.match(new RegExp('\\\\$' + name + '(/| |$)'))) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/*\n * Function that takes any object and flattens all props into one level deep object\n * */\n\nexport function flattenQuery(query) {\n  if (typeof query !== 'object') {\n    return {\n      query\n    };\n  }\n\n  const keys = Object.keys(query);\n  const flattened = keys.reduce((all, key) => {\n    const value = query[key];\n\n    if (typeof value !== 'object') {\n      all[key] = value;\n      return all;\n    }\n\n    const result = flattenQuery(value);\n\n    for (let childProp in result) {\n      if (result.hasOwnProperty(childProp)) {\n        all[`${key}_${childProp}`] = result[childProp];\n      }\n    }\n\n    return all;\n  }, {});\n  return flattened;\n}","map":{"version":3,"names":["Subscription","getDataSourceSrv","toDataQueryError","getVariableQueryEditor","addVariableEditorError","changeVariableEditorExtended","removeVariableEditorError","getQueryVariableEditorState","updateOptions","toKeyedAction","getVariable","getVariablesState","changeVariableProp","hasOngoingTransaction","toKeyedVariableIdentifier","toVariablePayload","getVariableQueryRunner","variableQueryObserver","updateQueryVariableOptions","identifier","searchFilter","dispatch","getState","rootStateKey","variableInState","editor","id","errorProp","datasource","get","Promise","resolve","reject","subscription","observer","responseSubscription","getResponse","subscribe","add","queueRequest","err","Error","error","errorText","message","initQueryVariableEditor","variable","changeQueryVariableDataSource","name","extendedEditorState","previousDatasource","dataSource","type","propName","propValue","VariableQueryEditor","console","changeQueryVariableQuery","query","definition","hasSelfReferencingQuery","match","RegExp","flattened","flattenQuery","prop","hasOwnProperty","value","keys","Object","reduce","all","key","result","childProp"],"sources":["/home/soula/grafana/public/app/features/variables/query/actions.ts"],"sourcesContent":["import { Subscription } from 'rxjs';\n\nimport { DataSourceRef } from '@grafana/data';\nimport { getDataSourceSrv, toDataQueryError } from '@grafana/runtime';\n\nimport { ThunkResult } from '../../../types';\nimport { getVariableQueryEditor } from '../editor/getVariableQueryEditor';\nimport { addVariableEditorError, changeVariableEditorExtended, removeVariableEditorError } from '../editor/reducer';\nimport { getQueryVariableEditorState } from '../editor/selectors';\nimport { updateOptions } from '../state/actions';\nimport { toKeyedAction } from '../state/keyedVariablesReducer';\nimport { getVariable, getVariablesState } from '../state/selectors';\nimport { changeVariableProp } from '../state/sharedReducer';\nimport { KeyedVariableIdentifier } from '../state/types';\nimport { QueryVariableModel } from '../types';\nimport { hasOngoingTransaction, toKeyedVariableIdentifier, toVariablePayload } from '../utils';\n\nimport { getVariableQueryRunner } from './VariableQueryRunner';\nimport { variableQueryObserver } from './variableQueryObserver';\n\nexport const updateQueryVariableOptions = (\n  identifier: KeyedVariableIdentifier,\n  searchFilter?: string\n): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    try {\n      const { rootStateKey } = identifier;\n      if (!hasOngoingTransaction(rootStateKey, getState())) {\n        // we might have cancelled a batch so then variable state is removed\n        return;\n      }\n\n      const variableInState = getVariable<QueryVariableModel>(identifier, getState());\n      if (getVariablesState(rootStateKey, getState()).editor.id === variableInState.id) {\n        dispatch(toKeyedAction(rootStateKey, removeVariableEditorError({ errorProp: 'update' })));\n      }\n      const datasource = await getDataSourceSrv().get(variableInState.datasource ?? '');\n\n      // We need to await the result from variableQueryRunner before moving on otherwise variables dependent on this\n      // variable will have the wrong current value as input\n      await new Promise((resolve, reject) => {\n        const subscription: Subscription = new Subscription();\n        const observer = variableQueryObserver(resolve, reject, subscription);\n        const responseSubscription = getVariableQueryRunner().getResponse(identifier).subscribe(observer);\n        subscription.add(responseSubscription);\n\n        getVariableQueryRunner().queueRequest({ identifier, datasource, searchFilter });\n      });\n    } catch (err) {\n      if (err instanceof Error) {\n        const error = toDataQueryError(err);\n        const { rootStateKey } = identifier;\n        if (getVariablesState(rootStateKey, getState()).editor.id === identifier.id) {\n          dispatch(\n            toKeyedAction(rootStateKey, addVariableEditorError({ errorProp: 'update', errorText: error.message }))\n          );\n        }\n\n        throw error;\n      }\n    }\n  };\n};\n\nexport const initQueryVariableEditor =\n  (identifier: KeyedVariableIdentifier): ThunkResult<void> =>\n  async (dispatch, getState) => {\n    const variable = getVariable<QueryVariableModel>(identifier, getState());\n    await dispatch(changeQueryVariableDataSource(toKeyedVariableIdentifier(variable), variable.datasource));\n  };\n\nexport const changeQueryVariableDataSource = (\n  identifier: KeyedVariableIdentifier,\n  name: DataSourceRef | null\n): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    try {\n      const { rootStateKey } = identifier;\n      const { editor } = getVariablesState(rootStateKey, getState());\n      const extendedEditorState = getQueryVariableEditorState(editor);\n      const previousDatasource = extendedEditorState?.dataSource;\n      const dataSource = await getDataSourceSrv().get(name ?? '');\n\n      if (previousDatasource && previousDatasource.type !== dataSource?.type) {\n        dispatch(\n          toKeyedAction(\n            rootStateKey,\n            changeVariableProp(toVariablePayload(identifier, { propName: 'query', propValue: '' }))\n          )\n        );\n      }\n\n      const VariableQueryEditor = await getVariableQueryEditor(dataSource);\n\n      dispatch(\n        toKeyedAction(\n          rootStateKey,\n          changeVariableEditorExtended({\n            dataSource,\n            VariableQueryEditor,\n          })\n        )\n      );\n    } catch (err) {\n      console.error(err);\n    }\n  };\n};\n\nexport const changeQueryVariableQuery =\n  (identifier: KeyedVariableIdentifier, query: any, definition?: string): ThunkResult<void> =>\n  async (dispatch, getState) => {\n    const { rootStateKey } = identifier;\n    const variableInState = getVariable<QueryVariableModel>(identifier, getState());\n    if (hasSelfReferencingQuery(variableInState.name, query)) {\n      const errorText = 'Query cannot contain a reference to itself. Variable: $' + variableInState.name;\n      dispatch(toKeyedAction(rootStateKey, addVariableEditorError({ errorProp: 'query', errorText })));\n      return;\n    }\n\n    dispatch(toKeyedAction(rootStateKey, removeVariableEditorError({ errorProp: 'query' })));\n    dispatch(\n      toKeyedAction(\n        rootStateKey,\n        changeVariableProp(toVariablePayload(identifier, { propName: 'query', propValue: query }))\n      )\n    );\n\n    if (definition) {\n      dispatch(\n        toKeyedAction(\n          rootStateKey,\n          changeVariableProp(toVariablePayload(identifier, { propName: 'definition', propValue: definition }))\n        )\n      );\n    } else if (typeof query === 'string') {\n      dispatch(\n        toKeyedAction(\n          rootStateKey,\n          changeVariableProp(toVariablePayload(identifier, { propName: 'definition', propValue: query }))\n        )\n      );\n    }\n\n    await dispatch(updateOptions(identifier));\n  };\n\nexport function hasSelfReferencingQuery(name: string, query: any): boolean {\n  if (typeof query === 'string' && query.match(new RegExp('\\\\$' + name + '(/| |$)'))) {\n    return true;\n  }\n\n  const flattened = flattenQuery(query);\n\n  for (let prop in flattened) {\n    if (flattened.hasOwnProperty(prop)) {\n      const value = flattened[prop];\n      if (typeof value === 'string' && value.match(new RegExp('\\\\$' + name + '(/| |$)'))) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/*\n * Function that takes any object and flattens all props into one level deep object\n * */\nexport function flattenQuery(query: any): any {\n  if (typeof query !== 'object') {\n    return { query };\n  }\n\n  const keys = Object.keys(query);\n  const flattened = keys.reduce((all, key) => {\n    const value = query[key];\n    if (typeof value !== 'object') {\n      all[key] = value;\n      return all;\n    }\n\n    const result = flattenQuery(value);\n    for (let childProp in result) {\n      if (result.hasOwnProperty(childProp)) {\n        all[`${key}_${childProp}`] = result[childProp];\n      }\n    }\n\n    return all;\n  }, {} as Record<string, any>);\n\n  return flattened;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}