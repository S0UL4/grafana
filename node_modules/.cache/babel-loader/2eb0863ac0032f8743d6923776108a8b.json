{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { getFieldMatcher, getFrameMatchers } from '../matchers';\nimport { DataTransformerID } from './ids';\nimport { noopTransformer } from './noop';\nexport const filterFieldsTransformer = {\n  id: DataTransformerID.filterFields,\n  name: 'Filter Fields',\n  description: 'select a subset of fields',\n  defaultOptions: {},\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: options => source => {\n    if (!options.include && !options.exclude) {\n      return source.pipe(noopTransformer.operator({}));\n    }\n\n    return source.pipe(map(data => {\n      const include = options.include ? getFieldMatcher(options.include) : null;\n      const exclude = options.exclude ? getFieldMatcher(options.exclude) : null;\n      const processed = [];\n\n      for (const series of data) {\n        // Find the matching field indexes\n        const fields = [];\n\n        for (let i = 0; i < series.fields.length; i++) {\n          const field = series.fields[i];\n\n          if (exclude) {\n            if (exclude(field, series, data)) {\n              continue;\n            }\n\n            if (!include) {\n              fields.push(field);\n            }\n          }\n\n          if (include && include(field, series, data)) {\n            fields.push(field);\n          }\n        }\n\n        if (!fields.length) {\n          continue;\n        }\n\n        const copy = Object.assign({}, series, {\n          // all the other properties\n          fields // but a different set of fields\n\n        });\n        processed.push(copy);\n      }\n\n      return processed;\n    }));\n  }\n};\nexport const filterFramesTransformer = {\n  id: DataTransformerID.filterFrames,\n  name: 'Filter Frames',\n  description: 'select a subset of frames',\n  defaultOptions: {},\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: options => source => {\n    if (!options.include && !options.exclude) {\n      return source.pipe(noopTransformer.operator({}));\n    }\n\n    return source.pipe(map(data => {\n      const include = options.include ? getFrameMatchers(options.include) : null;\n      const exclude = options.exclude ? getFrameMatchers(options.exclude) : null;\n      const processed = [];\n\n      for (const series of data) {\n        if (exclude) {\n          if (exclude(series)) {\n            continue;\n          }\n\n          if (!include) {\n            processed.push(series);\n          }\n        }\n\n        if (include && include(series)) {\n          processed.push(series);\n        }\n      }\n\n      return processed;\n    }));\n  }\n};","map":{"version":3,"names":["map","getFieldMatcher","getFrameMatchers","DataTransformerID","noopTransformer","filterFieldsTransformer","id","filterFields","name","description","defaultOptions","operator","options","source","include","exclude","pipe","data","processed","series","fields","i","length","field","push","copy","filterFramesTransformer","filterFrames"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/filter.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { DataFrame, Field } from '../../types/dataFrame';\nimport { DataTransformerInfo, MatcherConfig } from '../../types/transformations';\nimport { getFieldMatcher, getFrameMatchers } from '../matchers';\n\nimport { DataTransformerID } from './ids';\nimport { noopTransformer } from './noop';\n\nexport interface FilterOptions {\n  include?: MatcherConfig;\n  exclude?: MatcherConfig;\n}\n\nexport const filterFieldsTransformer: DataTransformerInfo<FilterOptions> = {\n  id: DataTransformerID.filterFields,\n  name: 'Filter Fields',\n  description: 'select a subset of fields',\n  defaultOptions: {},\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options: FilterOptions) => (source) => {\n    if (!options.include && !options.exclude) {\n      return source.pipe(noopTransformer.operator({}));\n    }\n\n    return source.pipe(\n      map((data) => {\n        const include = options.include ? getFieldMatcher(options.include) : null;\n        const exclude = options.exclude ? getFieldMatcher(options.exclude) : null;\n\n        const processed: DataFrame[] = [];\n        for (const series of data) {\n          // Find the matching field indexes\n          const fields: Field[] = [];\n          for (let i = 0; i < series.fields.length; i++) {\n            const field = series.fields[i];\n\n            if (exclude) {\n              if (exclude(field, series, data)) {\n                continue;\n              }\n              if (!include) {\n                fields.push(field);\n              }\n            }\n            if (include && include(field, series, data)) {\n              fields.push(field);\n            }\n          }\n\n          if (!fields.length) {\n            continue;\n          }\n          const copy = {\n            ...series, // all the other properties\n            fields, // but a different set of fields\n          };\n          processed.push(copy);\n        }\n        return processed;\n      })\n    );\n  },\n};\n\nexport const filterFramesTransformer: DataTransformerInfo<FilterOptions> = {\n  id: DataTransformerID.filterFrames,\n  name: 'Filter Frames',\n  description: 'select a subset of frames',\n  defaultOptions: {},\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) => {\n    if (!options.include && !options.exclude) {\n      return source.pipe(noopTransformer.operator({}));\n    }\n\n    return source.pipe(\n      map((data) => {\n        const include = options.include ? getFrameMatchers(options.include) : null;\n        const exclude = options.exclude ? getFrameMatchers(options.exclude) : null;\n\n        const processed: DataFrame[] = [];\n        for (const series of data) {\n          if (exclude) {\n            if (exclude(series)) {\n              continue;\n            }\n            if (!include) {\n              processed.push(series);\n            }\n          }\n          if (include && include(series)) {\n            processed.push(series);\n          }\n        }\n        return processed;\n      })\n    );\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}