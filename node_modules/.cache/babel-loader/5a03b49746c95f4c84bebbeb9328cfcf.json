{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { defaultsDeep } from 'lodash';\nimport { FieldType } from './dataFrame';\nexport let VizOrientation;\n\n(function (VizOrientation) {\n  VizOrientation[\"Auto\"] = \"auto\";\n  VizOrientation[\"Vertical\"] = \"vertical\";\n  VizOrientation[\"Horizontal\"] = \"horizontal\";\n})(VizOrientation || (VizOrientation = {}));\n\n/**\n * @alpha\n */\nexport let VisualizationSuggestionScore;\n/**\n * @alpha\n */\n\n(function (VisualizationSuggestionScore) {\n  VisualizationSuggestionScore[VisualizationSuggestionScore[\"Best\"] = 100] = \"Best\";\n  VisualizationSuggestionScore[VisualizationSuggestionScore[\"Good\"] = 70] = \"Good\";\n  VisualizationSuggestionScore[VisualizationSuggestionScore[\"OK\"] = 50] = \"OK\";\n})(VisualizationSuggestionScore || (VisualizationSuggestionScore = {}));\n\n/**\n * @alpha\n */\nexport class VisualizationSuggestionsBuilder {\n  /** Current data */\n\n  /** Current panel & options */\n\n  /** Summary stats for current data */\n  constructor(data, panel) {\n    _defineProperty(this, \"data\", void 0);\n\n    _defineProperty(this, \"panel\", void 0);\n\n    _defineProperty(this, \"dataSummary\", void 0);\n\n    _defineProperty(this, \"list\", []);\n\n    this.data = data;\n    this.panel = panel;\n    this.dataSummary = this.computeDataSummary();\n  }\n\n  getListAppender(defaults) {\n    return new VisualizationSuggestionsListAppender(this.list, defaults);\n  }\n\n  computeDataSummary() {\n    var _this$data;\n\n    const frames = ((_this$data = this.data) === null || _this$data === void 0 ? void 0 : _this$data.series) || [];\n    let numberFieldCount = 0;\n    let timeFieldCount = 0;\n    let stringFieldCount = 0;\n    let rowCountTotal = 0;\n    let rowCountMax = 0;\n    let fieldCount = 0;\n    let preferredVisualisationType;\n\n    for (const frame of frames) {\n      var _frame$meta;\n\n      rowCountTotal += frame.length;\n\n      if ((_frame$meta = frame.meta) !== null && _frame$meta !== void 0 && _frame$meta.preferredVisualisationType) {\n        preferredVisualisationType = frame.meta.preferredVisualisationType;\n      }\n\n      for (const field of frame.fields) {\n        fieldCount++;\n\n        switch (field.type) {\n          case FieldType.number:\n            numberFieldCount += 1;\n            break;\n\n          case FieldType.time:\n            timeFieldCount += 1;\n            break;\n\n          case FieldType.string:\n            stringFieldCount += 1;\n            break;\n        }\n      }\n\n      if (frame.length > rowCountMax) {\n        rowCountMax = frame.length;\n      }\n    }\n\n    return {\n      numberFieldCount,\n      timeFieldCount,\n      stringFieldCount,\n      rowCountTotal,\n      rowCountMax,\n      fieldCount,\n      preferredVisualisationType,\n      frameCount: frames.length,\n      hasData: rowCountTotal > 0,\n      hasTimeField: timeFieldCount > 0,\n      hasNumberField: numberFieldCount > 0,\n      hasStringField: stringFieldCount > 0\n    };\n  }\n\n  getList() {\n    return this.list;\n  }\n\n}\n/**\n * @alpha\n */\n\n/**\n * Helps with typings and defaults\n * @alpha\n */\nexport class VisualizationSuggestionsListAppender {\n  constructor(list, defaults) {\n    this.list = list;\n    this.defaults = defaults;\n  }\n\n  append(overrides) {\n    this.list.push(defaultsDeep(overrides, this.defaults));\n  }\n\n}","map":{"version":3,"names":["defaultsDeep","FieldType","VizOrientation","VisualizationSuggestionScore","VisualizationSuggestionsBuilder","constructor","data","panel","dataSummary","computeDataSummary","getListAppender","defaults","VisualizationSuggestionsListAppender","list","frames","series","numberFieldCount","timeFieldCount","stringFieldCount","rowCountTotal","rowCountMax","fieldCount","preferredVisualisationType","frame","length","meta","field","fields","type","number","time","string","frameCount","hasData","hasTimeField","hasNumberField","hasStringField","getList","append","overrides","push"],"sources":["/home/soula/grafana/packages/grafana-data/src/types/panel.ts"],"sourcesContent":["import { defaultsDeep } from 'lodash';\n\nimport { EventBus } from '../events';\nimport { StandardEditorProps } from '../field';\nimport { Registry } from '../utils';\n\nimport { OptionsEditorItem } from './OptionsUIRegistryBuilder';\nimport { ScopedVars } from './ScopedVars';\nimport { AlertStateInfo } from './alerts';\nimport { PanelModel } from './dashboard';\nimport { LoadingState, PreferredVisualisationType } from './data';\nimport { DataFrame, FieldType } from './dataFrame';\nimport { DataQueryError, DataQueryRequest, DataQueryTimings } from './datasource';\nimport { FieldConfigSource } from './fieldOverrides';\nimport { OptionEditorConfig } from './options';\nimport { PluginMeta } from './plugin';\nimport { AbsoluteTimeRange, TimeRange, TimeZone } from './time';\nimport { DataTransformerConfig } from './transformations';\n\nexport type InterpolateFunction = (value: string, scopedVars?: ScopedVars, format?: string | Function) => string;\n\nexport interface PanelPluginMeta extends PluginMeta {\n  /** Indicates that panel does not issue queries */\n  skipDataQuery?: boolean;\n  /** Indicates that panel should not be available in visualisation picker */\n  hideFromList?: boolean;\n  /** Sort order */\n  sort: number;\n}\n\nexport interface PanelData {\n  /** State of the data (loading, done, error, streaming) */\n  state: LoadingState;\n\n  /** Contains data frames with field overrides applied */\n  series: DataFrame[];\n\n  /**\n   * This is a key that will change when the DataFrame[] structure changes.\n   * The revision is a useful way to know if only data has changed or data+structure\n   */\n  structureRev?: number;\n\n  /** A list of annotation items */\n  annotations?: DataFrame[];\n\n  /**\n   * @internal\n   */\n  alertState?: AlertStateInfo;\n\n  /** Request contains the queries and properties sent to the datasource */\n  request?: DataQueryRequest;\n\n  /** Timing measurements */\n  timings?: DataQueryTimings;\n\n  /** Any query errors */\n  error?: DataQueryError;\n\n  /** Contains the range from the request or a shifted time range if a request uses relative time */\n  timeRange: TimeRange;\n}\n\nexport interface PanelProps<T = any> {\n  /** ID of the panel within the current dashboard */\n  id: number;\n\n  /** Result set of panel queries */\n  data: PanelData;\n\n  /** Time range of the current dashboard */\n  timeRange: TimeRange;\n\n  /** Time zone of the current dashboard */\n  timeZone: TimeZone;\n\n  /** Panel options */\n  options: T;\n\n  /** Indicates whether or not panel should be rendered transparent */\n  transparent: boolean;\n\n  /** Current width of the panel */\n  width: number;\n\n  /** Current height of the panel */\n  height: number;\n\n  /** Field options configuration */\n  fieldConfig: FieldConfigSource;\n\n  /** @internal */\n  renderCounter: number;\n\n  /** Panel title */\n  title: string;\n\n  /** EventBus  */\n  eventBus: EventBus;\n\n  /** Panel options change handler */\n  onOptionsChange: (options: T) => void;\n\n  /** Field config change handler */\n  onFieldConfigChange: (config: FieldConfigSource) => void;\n\n  /** Template variables interpolation function */\n  replaceVariables: InterpolateFunction;\n\n  /** Time range change handler */\n  onChangeTimeRange: (timeRange: AbsoluteTimeRange) => void;\n}\n\nexport interface PanelEditorProps<T = any> {\n  /** Panel options */\n  options: T;\n  /** Panel options change handler */\n  onOptionsChange: (\n    options: T,\n    // callback can be used to run something right after update.\n    callback?: () => void\n  ) => void;\n  /** Result set of panel queries */\n  data?: PanelData;\n}\n\n/**\n * Called when a panel is first loaded with current panel model\n */\nexport type PanelMigrationHandler<TOptions = any> = (panel: PanelModel<TOptions>) => Partial<TOptions>;\n\n/**\n * Called before a panel is initialized. Allows panel inspection for any updates before changing the panel type.\n */\nexport type PanelTypeChangedHandler<TOptions = any> = (\n  panel: PanelModel<TOptions>,\n  prevPluginId: string,\n  prevOptions: Record<string, any>,\n  prevFieldConfig: FieldConfigSource\n) => Partial<TOptions>;\n\nexport type PanelOptionEditorsRegistry = Registry<PanelOptionsEditorItem>;\n\nexport interface PanelOptionsEditorProps<TValue> extends StandardEditorProps<TValue> {}\n\nexport interface PanelOptionsEditorItem<TOptions = any, TValue = any, TSettings = any>\n  extends OptionsEditorItem<TOptions, TSettings, PanelOptionsEditorProps<TValue>, TValue> {}\n\nexport interface PanelOptionsEditorConfig<TOptions, TSettings = any, TValue = any>\n  extends OptionEditorConfig<TOptions, TSettings, TValue> {}\n\n/**\n * @internal\n */\nexport interface PanelMenuItem {\n  type?: 'submenu' | 'divider';\n  text: string;\n  iconClassName?: string;\n  onClick?: (event: React.MouseEvent<any>) => void;\n  shortcut?: string;\n  href?: string;\n  subMenu?: PanelMenuItem[];\n}\n\n/**\n * @internal\n */\nexport interface AngularPanelMenuItem {\n  click: Function;\n  icon: string;\n  href: string;\n  divider: boolean;\n  text: string;\n  shortcut: string;\n  submenu: any[];\n}\n\nexport enum VizOrientation {\n  Auto = 'auto',\n  Vertical = 'vertical',\n  Horizontal = 'horizontal',\n}\n\nexport interface PanelPluginDataSupport {\n  annotations: boolean;\n  alertStates: boolean;\n}\n\n/**\n * @alpha\n */\nexport interface VisualizationSuggestion<TOptions = any, TFieldConfig = any> {\n  /** Name of suggestion */\n  name: string;\n  /** Description */\n  description?: string;\n  /** Panel plugin id */\n  pluginId: string;\n  /** Panel plugin options */\n  options?: Partial<TOptions>;\n  /** Panel plugin field options */\n  fieldConfig?: FieldConfigSource<Partial<TFieldConfig>>;\n  /** Data transformations */\n  transformations?: DataTransformerConfig[];\n  /** Options for how to render suggestion card */\n  cardOptions?: {\n    /** Tweak for small preview */\n    previewModifier?: (suggestion: VisualizationSuggestion) => void;\n    icon?: string;\n    imgSrc?: string;\n  };\n  /** A value between 0-100 how suitable suggestion is */\n  score?: VisualizationSuggestionScore;\n}\n\n/**\n * @alpha\n */\nexport enum VisualizationSuggestionScore {\n  /** We are pretty sure this is the best possible option */\n  Best = 100,\n  /** Should be a really good option */\n  Good = 70,\n  /** Can be visualized but there are likely better options. If no score is set this score is assumed */\n  OK = 50,\n}\n\n/**\n * @alpha\n */\nexport interface PanelDataSummary {\n  hasData?: boolean;\n  rowCountTotal: number;\n  rowCountMax: number;\n  frameCount: number;\n  fieldCount: number;\n  numberFieldCount: number;\n  timeFieldCount: number;\n  stringFieldCount: number;\n  hasNumberField?: boolean;\n  hasTimeField?: boolean;\n  hasStringField?: boolean;\n  /** The first frame that set's this value */\n  preferredVisualisationType?: PreferredVisualisationType;\n}\n\n/**\n * @alpha\n */\nexport class VisualizationSuggestionsBuilder {\n  /** Current data */\n  data?: PanelData;\n  /** Current panel & options */\n  panel?: PanelModel;\n  /** Summary stats for current data */\n  dataSummary: PanelDataSummary;\n\n  private list: VisualizationSuggestion[] = [];\n\n  constructor(data?: PanelData, panel?: PanelModel) {\n    this.data = data;\n    this.panel = panel;\n    this.dataSummary = this.computeDataSummary();\n  }\n\n  getListAppender<TOptions, TFieldConfig>(defaults: VisualizationSuggestion<TOptions, TFieldConfig>) {\n    return new VisualizationSuggestionsListAppender<TOptions, TFieldConfig>(this.list, defaults);\n  }\n\n  private computeDataSummary() {\n    const frames = this.data?.series || [];\n\n    let numberFieldCount = 0;\n    let timeFieldCount = 0;\n    let stringFieldCount = 0;\n    let rowCountTotal = 0;\n    let rowCountMax = 0;\n    let fieldCount = 0;\n    let preferredVisualisationType: PreferredVisualisationType | undefined;\n\n    for (const frame of frames) {\n      rowCountTotal += frame.length;\n\n      if (frame.meta?.preferredVisualisationType) {\n        preferredVisualisationType = frame.meta.preferredVisualisationType;\n      }\n\n      for (const field of frame.fields) {\n        fieldCount++;\n\n        switch (field.type) {\n          case FieldType.number:\n            numberFieldCount += 1;\n            break;\n          case FieldType.time:\n            timeFieldCount += 1;\n            break;\n          case FieldType.string:\n            stringFieldCount += 1;\n            break;\n        }\n      }\n\n      if (frame.length > rowCountMax) {\n        rowCountMax = frame.length;\n      }\n    }\n\n    return {\n      numberFieldCount,\n      timeFieldCount,\n      stringFieldCount,\n      rowCountTotal,\n      rowCountMax,\n      fieldCount,\n      preferredVisualisationType,\n      frameCount: frames.length,\n      hasData: rowCountTotal > 0,\n      hasTimeField: timeFieldCount > 0,\n      hasNumberField: numberFieldCount > 0,\n      hasStringField: stringFieldCount > 0,\n    };\n  }\n\n  getList() {\n    return this.list;\n  }\n}\n\n/**\n * @alpha\n */\nexport type VisualizationSuggestionsSupplier = {\n  /**\n   * Adds good suitable suggestions for the current data\n   */\n  getSuggestionsForData: (builder: VisualizationSuggestionsBuilder) => void;\n};\n\n/**\n * Helps with typings and defaults\n * @alpha\n */\nexport class VisualizationSuggestionsListAppender<TOptions, TFieldConfig> {\n  constructor(\n    private list: VisualizationSuggestion[],\n    private defaults: VisualizationSuggestion<TOptions, TFieldConfig>\n  ) {}\n\n  append(overrides: Partial<VisualizationSuggestion<TOptions, TFieldConfig>>) {\n    this.list.push(defaultsDeep(overrides, this.defaults));\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}