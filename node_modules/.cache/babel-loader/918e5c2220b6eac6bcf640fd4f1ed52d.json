{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { isNumber, isFinite, escape } from 'lodash';\nimport { formattedValueToString, getValueFormat, stringToJsRegex } from '@grafana/data';\n\nfunction matchSeriesOverride(aliasOrRegex, seriesAlias) {\n  if (!aliasOrRegex) {\n    return false;\n  }\n\n  if (aliasOrRegex[0] === '/') {\n    const regex = stringToJsRegex(aliasOrRegex);\n    return seriesAlias.match(regex) != null;\n  }\n\n  return aliasOrRegex === seriesAlias;\n}\n\nfunction translateFillOption(fill) {\n  return fill === 0 ? 0.001 : fill / 10;\n}\n\nfunction getFillGradient(amount) {\n  if (!amount) {\n    return null;\n  }\n\n  return {\n    colors: [{\n      opacity: 0.0\n    }, {\n      opacity: amount / 10\n    }]\n  };\n}\n/**\n * Calculate decimals for legend and update values for each series.\n * @param data series data\n * @param panel\n * @param height\n */\n\n\nexport function updateLegendValues(data, panel, height) {\n  for (let i = 0; i < data.length; i++) {\n    const series = data[i];\n    const yaxes = panel.yaxes;\n    const seriesYAxis = series.yaxis || 1;\n    const axis = yaxes[seriesYAxis - 1];\n    const formatter = getValueFormat(axis.format); // decimal override\n\n    if (isNumber(panel.decimals)) {\n      series.updateLegendValues(formatter, panel.decimals);\n    } else if (isNumber(axis.decimals)) {\n      series.updateLegendValues(formatter, axis.decimals + 1);\n    } else {\n      series.updateLegendValues(formatter, null);\n    }\n  }\n}\n/**\n * @deprecated: This class should not be used in new panels\n *\n * Use DataFrame and helpers instead\n */\n\nexport default class TimeSeries {\n  // Represents index of original data frame in the quey response\n  // Represents index of field in the data frame\n  constructor(opts) {\n    _defineProperty(this, \"datapoints\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"dataFrameIndex\", void 0);\n\n    _defineProperty(this, \"fieldIndex\", void 0);\n\n    _defineProperty(this, \"label\", void 0);\n\n    _defineProperty(this, \"alias\", void 0);\n\n    _defineProperty(this, \"aliasEscaped\", void 0);\n\n    _defineProperty(this, \"color\", void 0);\n\n    _defineProperty(this, \"valueFormater\", void 0);\n\n    _defineProperty(this, \"stats\", void 0);\n\n    _defineProperty(this, \"legend\", void 0);\n\n    _defineProperty(this, \"hideTooltip\", void 0);\n\n    _defineProperty(this, \"allIsNull\", void 0);\n\n    _defineProperty(this, \"allIsZero\", void 0);\n\n    _defineProperty(this, \"decimals\", void 0);\n\n    _defineProperty(this, \"hasMsResolution\", void 0);\n\n    _defineProperty(this, \"isOutsideRange\", void 0);\n\n    _defineProperty(this, \"lines\", void 0);\n\n    _defineProperty(this, \"hiddenSeries\", void 0);\n\n    _defineProperty(this, \"dashes\", void 0);\n\n    _defineProperty(this, \"bars\", void 0);\n\n    _defineProperty(this, \"points\", void 0);\n\n    _defineProperty(this, \"yaxis\", void 0);\n\n    _defineProperty(this, \"zindex\", void 0);\n\n    _defineProperty(this, \"stack\", void 0);\n\n    _defineProperty(this, \"nullPointMode\", void 0);\n\n    _defineProperty(this, \"fillBelowTo\", void 0);\n\n    _defineProperty(this, \"transform\", void 0);\n\n    _defineProperty(this, \"flotpairs\", void 0);\n\n    _defineProperty(this, \"unit\", void 0);\n\n    this.datapoints = opts.datapoints;\n    this.label = opts.alias;\n    this.id = opts.alias;\n    this.alias = opts.alias;\n    this.aliasEscaped = escape(opts.alias);\n    this.color = opts.color;\n    this.bars = {\n      fillColor: opts.color\n    };\n    this.valueFormater = getValueFormat('none');\n    this.stats = {};\n    this.legend = true;\n    this.unit = opts.unit;\n    this.dataFrameIndex = opts.dataFrameIndex;\n    this.fieldIndex = opts.fieldIndex;\n    this.hasMsResolution = this.isMsResolutionNeeded();\n  }\n\n  applySeriesOverrides(overrides) {\n    this.lines = {};\n    this.dashes = {\n      dashLength: []\n    };\n    this.points = {};\n    this.yaxis = 1;\n    this.zindex = 0;\n    this.nullPointMode = null;\n    delete this.stack;\n    delete this.bars.show;\n\n    for (let i = 0; i < overrides.length; i++) {\n      const override = overrides[i];\n\n      if (!matchSeriesOverride(override.alias, this.alias)) {\n        continue;\n      }\n\n      if (override.lines !== void 0) {\n        this.lines.show = override.lines;\n      }\n\n      if (override.dashes !== void 0) {\n        this.dashes.show = override.dashes;\n        this.lines.lineWidth = 0;\n      }\n\n      if (override.points !== void 0) {\n        this.points.show = override.points;\n      }\n\n      if (override.bars !== void 0) {\n        this.bars.show = override.bars;\n      }\n\n      if (override.fill !== void 0) {\n        this.lines.fill = translateFillOption(override.fill);\n      }\n\n      if (override.fillGradient !== void 0) {\n        this.lines.fillColor = getFillGradient(override.fillGradient);\n      }\n\n      if (override.stack !== void 0) {\n        this.stack = override.stack;\n      }\n\n      if (override.linewidth !== void 0) {\n        this.lines.lineWidth = this.dashes.show ? 0 : override.linewidth;\n        this.dashes.lineWidth = override.linewidth;\n      }\n\n      if (override.dashLength !== void 0) {\n        this.dashes.dashLength[0] = override.dashLength;\n      }\n\n      if (override.spaceLength !== void 0) {\n        this.dashes.dashLength[1] = override.spaceLength;\n      }\n\n      if (override.nullPointMode !== void 0) {\n        this.nullPointMode = override.nullPointMode;\n      }\n\n      if (override.pointradius !== void 0) {\n        this.points.radius = override.pointradius;\n      }\n\n      if (override.steppedLine !== void 0) {\n        this.lines.steps = override.steppedLine;\n      }\n\n      if (override.zindex !== void 0) {\n        this.zindex = override.zindex;\n      }\n\n      if (override.fillBelowTo !== void 0) {\n        this.fillBelowTo = override.fillBelowTo;\n      }\n\n      if (override.color !== void 0) {\n        this.setColor(override.color);\n      }\n\n      if (override.transform !== void 0) {\n        this.transform = override.transform;\n      }\n\n      if (override.legend !== void 0) {\n        this.legend = override.legend;\n      }\n\n      if (override.hideTooltip !== void 0) {\n        this.hideTooltip = override.hideTooltip;\n      }\n\n      if (override.yaxis !== void 0) {\n        this.yaxis = override.yaxis;\n      }\n\n      if (override.hiddenSeries !== void 0) {\n        this.hiddenSeries = override.hiddenSeries;\n      }\n    }\n  }\n\n  getFlotPairs(fillStyle) {\n    const result = [];\n    this.stats.total = 0;\n    this.stats.max = -Number.MAX_VALUE;\n    this.stats.min = Number.MAX_VALUE;\n    this.stats.logmin = Number.MAX_VALUE;\n    this.stats.avg = null;\n    this.stats.current = null;\n    this.stats.first = null;\n    this.stats.delta = 0;\n    this.stats.diff = null;\n    this.stats.diffperc = 0;\n    this.stats.range = null;\n    this.stats.timeStep = Number.MAX_VALUE;\n    this.allIsNull = true;\n    this.allIsZero = true;\n    const ignoreNulls = fillStyle === 'connected';\n    const nullAsZero = fillStyle === 'null as zero';\n    let currentTime;\n    let currentValue;\n    let nonNulls = 0;\n    let previousTime;\n    let previousValue = 0;\n    let previousDeltaUp = true;\n\n    for (let i = 0; i < this.datapoints.length; i++) {\n      currentValue = this.datapoints[i][0];\n      currentTime = this.datapoints[i][1]; // Due to missing values we could have different timeStep all along the series\n      // so we have to find the minimum one (could occur with aggregators such as ZimSum)\n\n      if (previousTime !== undefined) {\n        const timeStep = currentTime - previousTime;\n\n        if (timeStep < this.stats.timeStep) {\n          this.stats.timeStep = timeStep;\n        }\n      }\n\n      previousTime = currentTime;\n\n      if (currentValue === null) {\n        if (ignoreNulls) {\n          continue;\n        }\n\n        if (nullAsZero) {\n          currentValue = 0;\n        }\n      }\n\n      if (currentValue !== null) {\n        if (isNumber(currentValue)) {\n          this.stats.total += currentValue;\n          this.allIsNull = false;\n          nonNulls++;\n        }\n\n        if (currentValue > this.stats.max) {\n          this.stats.max = currentValue;\n        }\n\n        if (currentValue < this.stats.min) {\n          this.stats.min = currentValue;\n        }\n\n        if (this.stats.first === null) {\n          this.stats.first = currentValue;\n        } else {\n          if (previousValue > currentValue) {\n            // counter reset\n            previousDeltaUp = false;\n\n            if (i === this.datapoints.length - 1) {\n              // reset on last\n              this.stats.delta += currentValue;\n            }\n          } else {\n            if (previousDeltaUp) {\n              this.stats.delta += currentValue - previousValue; // normal increment\n            } else {\n              this.stats.delta += currentValue; // account for counter reset\n            }\n\n            previousDeltaUp = true;\n          }\n        }\n\n        previousValue = currentValue;\n\n        if (currentValue < this.stats.logmin && currentValue > 0) {\n          this.stats.logmin = currentValue;\n        }\n\n        if (currentValue !== 0) {\n          this.allIsZero = false;\n        }\n      }\n\n      result.push([currentTime, currentValue]);\n    }\n\n    if (this.stats.max === -Number.MAX_VALUE) {\n      this.stats.max = null;\n    }\n\n    if (this.stats.min === Number.MAX_VALUE) {\n      this.stats.min = null;\n    }\n\n    if (result.length && !this.allIsNull) {\n      this.stats.avg = this.stats.total / nonNulls;\n      this.stats.current = result[result.length - 1][1];\n\n      if (this.stats.current === null && result.length > 1) {\n        this.stats.current = result[result.length - 2][1];\n      }\n    }\n\n    if (this.stats.max !== null && this.stats.min !== null) {\n      this.stats.range = this.stats.max - this.stats.min;\n    }\n\n    if (this.stats.current !== null && this.stats.first !== null) {\n      this.stats.diff = this.stats.current - this.stats.first;\n      this.stats.diffperc = this.stats.diff / this.stats.first;\n    }\n\n    this.stats.count = result.length;\n    return result;\n  }\n\n  updateLegendValues(formater, decimals) {\n    this.valueFormater = formater;\n    this.decimals = decimals;\n  }\n\n  formatValue(value) {\n    if (!isFinite(value)) {\n      value = null; // Prevent NaN formatting\n    }\n\n    return formattedValueToString(this.valueFormater(value, this.decimals));\n  }\n\n  isMsResolutionNeeded() {\n    for (let i = 0; i < this.datapoints.length; i++) {\n      if (this.datapoints[i][1] !== null && this.datapoints[i][1] !== undefined) {\n        const timestamp = this.datapoints[i][1].toString();\n\n        if (timestamp.length === 13 && timestamp % 1000 !== 0) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  hideFromLegend(options) {\n    if (options.hideEmpty && this.allIsNull) {\n      return true;\n    } // ignore series excluded via override\n\n\n    if (!this.legend) {\n      return true;\n    } // ignore zero series\n\n\n    if (options.hideZero && this.allIsZero) {\n      return true;\n    }\n\n    return false;\n  }\n\n  setColor(color) {\n    this.color = color;\n    this.bars.fillColor = color;\n  }\n\n}","map":{"version":3,"names":["isNumber","isFinite","escape","formattedValueToString","getValueFormat","stringToJsRegex","matchSeriesOverride","aliasOrRegex","seriesAlias","regex","match","translateFillOption","fill","getFillGradient","amount","colors","opacity","updateLegendValues","data","panel","height","i","length","series","yaxes","seriesYAxis","yaxis","axis","formatter","format","decimals","TimeSeries","constructor","opts","datapoints","label","alias","id","aliasEscaped","color","bars","fillColor","valueFormater","stats","legend","unit","dataFrameIndex","fieldIndex","hasMsResolution","isMsResolutionNeeded","applySeriesOverrides","overrides","lines","dashes","dashLength","points","zindex","nullPointMode","stack","show","override","lineWidth","fillGradient","linewidth","spaceLength","pointradius","radius","steppedLine","steps","fillBelowTo","setColor","transform","hideTooltip","hiddenSeries","getFlotPairs","fillStyle","result","total","max","Number","MAX_VALUE","min","logmin","avg","current","first","delta","diff","diffperc","range","timeStep","allIsNull","allIsZero","ignoreNulls","nullAsZero","currentTime","currentValue","nonNulls","previousTime","previousValue","previousDeltaUp","undefined","push","count","formater","formatValue","value","timestamp","toString","hideFromLegend","options","hideEmpty","hideZero"],"sources":["/home/soula/grafana/public/app/core/time_series2.ts"],"sourcesContent":["import { isNumber, isFinite, escape } from 'lodash';\n\nimport { DecimalCount, formattedValueToString, getValueFormat, stringToJsRegex, ValueFormatter } from '@grafana/data';\n\nfunction matchSeriesOverride(aliasOrRegex: string, seriesAlias: string) {\n  if (!aliasOrRegex) {\n    return false;\n  }\n\n  if (aliasOrRegex[0] === '/') {\n    const regex = stringToJsRegex(aliasOrRegex);\n    return seriesAlias.match(regex) != null;\n  }\n\n  return aliasOrRegex === seriesAlias;\n}\n\nfunction translateFillOption(fill: number) {\n  return fill === 0 ? 0.001 : fill / 10;\n}\n\nfunction getFillGradient(amount: number) {\n  if (!amount) {\n    return null;\n  }\n\n  return {\n    colors: [{ opacity: 0.0 }, { opacity: amount / 10 }],\n  };\n}\n\n/**\n * Calculate decimals for legend and update values for each series.\n * @param data series data\n * @param panel\n * @param height\n */\nexport function updateLegendValues(data: TimeSeries[], panel: any, height: number) {\n  for (let i = 0; i < data.length; i++) {\n    const series = data[i];\n    const yaxes = panel.yaxes;\n    const seriesYAxis = series.yaxis || 1;\n    const axis = yaxes[seriesYAxis - 1];\n    const formatter = getValueFormat(axis.format);\n\n    // decimal override\n    if (isNumber(panel.decimals)) {\n      series.updateLegendValues(formatter, panel.decimals);\n    } else if (isNumber(axis.decimals)) {\n      series.updateLegendValues(formatter, axis.decimals + 1);\n    } else {\n      series.updateLegendValues(formatter, null);\n    }\n  }\n}\n\n/**\n * @deprecated: This class should not be used in new panels\n *\n * Use DataFrame and helpers instead\n */\nexport default class TimeSeries {\n  datapoints: any;\n  id: string;\n  // Represents index of original data frame in the quey response\n  dataFrameIndex: number;\n  // Represents index of field in the data frame\n  fieldIndex: number;\n  label: string;\n  alias: string;\n  aliasEscaped: string;\n  color?: string;\n  valueFormater: any;\n  stats: any;\n  legend: boolean;\n  hideTooltip?: boolean;\n  allIsNull?: boolean;\n  allIsZero?: boolean;\n  decimals: DecimalCount;\n  hasMsResolution: boolean;\n  isOutsideRange?: boolean;\n\n  lines: any;\n  hiddenSeries?: boolean;\n  dashes: any;\n  bars: any;\n  points: any;\n  yaxis: any;\n  zindex: any;\n  stack: any;\n  nullPointMode: any;\n  fillBelowTo: any;\n  transform: any;\n  flotpairs: any;\n  unit: any;\n\n  constructor(opts: any) {\n    this.datapoints = opts.datapoints;\n    this.label = opts.alias;\n    this.id = opts.alias;\n    this.alias = opts.alias;\n    this.aliasEscaped = escape(opts.alias);\n    this.color = opts.color;\n    this.bars = { fillColor: opts.color };\n    this.valueFormater = getValueFormat('none');\n    this.stats = {};\n    this.legend = true;\n    this.unit = opts.unit;\n    this.dataFrameIndex = opts.dataFrameIndex;\n    this.fieldIndex = opts.fieldIndex;\n    this.hasMsResolution = this.isMsResolutionNeeded();\n  }\n\n  applySeriesOverrides(overrides: any[]) {\n    this.lines = {};\n    this.dashes = {\n      dashLength: [],\n    };\n    this.points = {};\n    this.yaxis = 1;\n    this.zindex = 0;\n    this.nullPointMode = null;\n    delete this.stack;\n    delete this.bars.show;\n\n    for (let i = 0; i < overrides.length; i++) {\n      const override = overrides[i];\n      if (!matchSeriesOverride(override.alias, this.alias)) {\n        continue;\n      }\n      if (override.lines !== void 0) {\n        this.lines.show = override.lines;\n      }\n      if (override.dashes !== void 0) {\n        this.dashes.show = override.dashes;\n        this.lines.lineWidth = 0;\n      }\n      if (override.points !== void 0) {\n        this.points.show = override.points;\n      }\n      if (override.bars !== void 0) {\n        this.bars.show = override.bars;\n      }\n      if (override.fill !== void 0) {\n        this.lines.fill = translateFillOption(override.fill);\n      }\n      if (override.fillGradient !== void 0) {\n        this.lines.fillColor = getFillGradient(override.fillGradient);\n      }\n      if (override.stack !== void 0) {\n        this.stack = override.stack;\n      }\n      if (override.linewidth !== void 0) {\n        this.lines.lineWidth = this.dashes.show ? 0 : override.linewidth;\n        this.dashes.lineWidth = override.linewidth;\n      }\n      if (override.dashLength !== void 0) {\n        this.dashes.dashLength[0] = override.dashLength;\n      }\n      if (override.spaceLength !== void 0) {\n        this.dashes.dashLength[1] = override.spaceLength;\n      }\n      if (override.nullPointMode !== void 0) {\n        this.nullPointMode = override.nullPointMode;\n      }\n      if (override.pointradius !== void 0) {\n        this.points.radius = override.pointradius;\n      }\n      if (override.steppedLine !== void 0) {\n        this.lines.steps = override.steppedLine;\n      }\n      if (override.zindex !== void 0) {\n        this.zindex = override.zindex;\n      }\n      if (override.fillBelowTo !== void 0) {\n        this.fillBelowTo = override.fillBelowTo;\n      }\n      if (override.color !== void 0) {\n        this.setColor(override.color);\n      }\n      if (override.transform !== void 0) {\n        this.transform = override.transform;\n      }\n      if (override.legend !== void 0) {\n        this.legend = override.legend;\n      }\n      if (override.hideTooltip !== void 0) {\n        this.hideTooltip = override.hideTooltip;\n      }\n\n      if (override.yaxis !== void 0) {\n        this.yaxis = override.yaxis;\n      }\n      if (override.hiddenSeries !== void 0) {\n        this.hiddenSeries = override.hiddenSeries;\n      }\n    }\n  }\n\n  getFlotPairs(fillStyle: string) {\n    const result = [];\n\n    this.stats.total = 0;\n    this.stats.max = -Number.MAX_VALUE;\n    this.stats.min = Number.MAX_VALUE;\n    this.stats.logmin = Number.MAX_VALUE;\n    this.stats.avg = null;\n    this.stats.current = null;\n    this.stats.first = null;\n    this.stats.delta = 0;\n    this.stats.diff = null;\n    this.stats.diffperc = 0;\n    this.stats.range = null;\n    this.stats.timeStep = Number.MAX_VALUE;\n    this.allIsNull = true;\n    this.allIsZero = true;\n\n    const ignoreNulls = fillStyle === 'connected';\n    const nullAsZero = fillStyle === 'null as zero';\n    let currentTime;\n    let currentValue;\n    let nonNulls = 0;\n    let previousTime;\n    let previousValue = 0;\n    let previousDeltaUp = true;\n\n    for (let i = 0; i < this.datapoints.length; i++) {\n      currentValue = this.datapoints[i][0];\n      currentTime = this.datapoints[i][1];\n\n      // Due to missing values we could have different timeStep all along the series\n      // so we have to find the minimum one (could occur with aggregators such as ZimSum)\n      if (previousTime !== undefined) {\n        const timeStep = currentTime - previousTime;\n        if (timeStep < this.stats.timeStep) {\n          this.stats.timeStep = timeStep;\n        }\n      }\n      previousTime = currentTime;\n\n      if (currentValue === null) {\n        if (ignoreNulls) {\n          continue;\n        }\n        if (nullAsZero) {\n          currentValue = 0;\n        }\n      }\n\n      if (currentValue !== null) {\n        if (isNumber(currentValue)) {\n          this.stats.total += currentValue;\n          this.allIsNull = false;\n          nonNulls++;\n        }\n\n        if (currentValue > this.stats.max) {\n          this.stats.max = currentValue;\n        }\n\n        if (currentValue < this.stats.min) {\n          this.stats.min = currentValue;\n        }\n\n        if (this.stats.first === null) {\n          this.stats.first = currentValue;\n        } else {\n          if (previousValue > currentValue) {\n            // counter reset\n            previousDeltaUp = false;\n            if (i === this.datapoints.length - 1) {\n              // reset on last\n              this.stats.delta += currentValue;\n            }\n          } else {\n            if (previousDeltaUp) {\n              this.stats.delta += currentValue - previousValue; // normal increment\n            } else {\n              this.stats.delta += currentValue; // account for counter reset\n            }\n            previousDeltaUp = true;\n          }\n        }\n        previousValue = currentValue;\n\n        if (currentValue < this.stats.logmin && currentValue > 0) {\n          this.stats.logmin = currentValue;\n        }\n\n        if (currentValue !== 0) {\n          this.allIsZero = false;\n        }\n      }\n\n      result.push([currentTime, currentValue]);\n    }\n\n    if (this.stats.max === -Number.MAX_VALUE) {\n      this.stats.max = null;\n    }\n    if (this.stats.min === Number.MAX_VALUE) {\n      this.stats.min = null;\n    }\n\n    if (result.length && !this.allIsNull) {\n      this.stats.avg = this.stats.total / nonNulls;\n      this.stats.current = result[result.length - 1][1];\n      if (this.stats.current === null && result.length > 1) {\n        this.stats.current = result[result.length - 2][1];\n      }\n    }\n    if (this.stats.max !== null && this.stats.min !== null) {\n      this.stats.range = this.stats.max - this.stats.min;\n    }\n    if (this.stats.current !== null && this.stats.first !== null) {\n      this.stats.diff = this.stats.current - this.stats.first;\n      this.stats.diffperc = this.stats.diff / this.stats.first;\n    }\n\n    this.stats.count = result.length;\n    return result;\n  }\n\n  updateLegendValues(formater: ValueFormatter, decimals: DecimalCount) {\n    this.valueFormater = formater;\n    this.decimals = decimals;\n  }\n\n  formatValue(value: number | null) {\n    if (!isFinite(value)) {\n      value = null; // Prevent NaN formatting\n    }\n    return formattedValueToString(this.valueFormater(value, this.decimals));\n  }\n\n  isMsResolutionNeeded() {\n    for (let i = 0; i < this.datapoints.length; i++) {\n      if (this.datapoints[i][1] !== null && this.datapoints[i][1] !== undefined) {\n        const timestamp = this.datapoints[i][1].toString();\n        if (timestamp.length === 13 && timestamp % 1000 !== 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  hideFromLegend(options: any) {\n    if (options.hideEmpty && this.allIsNull) {\n      return true;\n    }\n    // ignore series excluded via override\n    if (!this.legend) {\n      return true;\n    }\n\n    // ignore zero series\n    if (options.hideZero && this.allIsZero) {\n      return true;\n    }\n\n    return false;\n  }\n\n  setColor(color: string) {\n    this.color = color;\n    this.bars.fillColor = color;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}