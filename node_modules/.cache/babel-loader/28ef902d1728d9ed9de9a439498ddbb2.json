{"ast":null,"code":"import { colorManipulator } from '@grafana/data';\nimport { VizDisplayMode, ColorStrategy, CandleStyle } from './models.gen';\nconst {\n  alpha\n} = colorManipulator;\nexport function drawMarkers(opts) {\n  let {\n    mode,\n    candleStyle,\n    fields,\n    colorStrategy,\n    upColor,\n    downColor,\n    flatColor,\n    volumeAlpha,\n    flatAsUp = true\n  } = opts;\n  const drawPrice = mode !== VizDisplayMode.Volume && fields.high != null && fields.low != null;\n  const asCandles = drawPrice && candleStyle === CandleStyle.Candles;\n  const drawVolume = mode !== VizDisplayMode.Candles && fields.volume != null;\n\n  function selectPath(priceDir, flatPath, upPath, downPath, flatAsUp) {\n    return priceDir > 0 ? upPath : priceDir < 0 ? downPath : flatAsUp ? upPath : flatPath;\n  }\n\n  let tIdx = 0,\n      oIdx = fields.open,\n      hIdx = fields.high,\n      lIdx = fields.low,\n      cIdx = fields.close,\n      vIdx = fields.volume;\n  return u => {\n    // split by discrete color to reduce draw calls\n    let downPath, upPath, flatPath; // with adjusted reduced\n\n    let downPathVol, upPathVol, flatPathVol;\n\n    if (drawPrice) {\n      flatPath = new Path2D();\n      upPath = new Path2D();\n      downPath = new Path2D();\n    }\n\n    if (drawVolume) {\n      downPathVol = new Path2D();\n      upPathVol = new Path2D();\n      flatPathVol = new Path2D();\n    }\n\n    let hollowPath = new Path2D();\n    let ctx = u.ctx;\n    let tData = u.data[tIdx];\n    let oData = u.data[oIdx];\n    let cData = u.data[cIdx];\n    let hData = drawPrice ? u.data[hIdx] : null;\n    let lData = drawPrice ? u.data[lIdx] : null;\n    let vData = drawVolume ? u.data[vIdx] : null;\n    let zeroPx = vIdx != null ? Math.round(u.valToPos(0, u.series[vIdx].scale, true)) : null;\n    let [idx0, idx1] = u.series[0].idxs;\n    let dataX = u.data[0];\n    let dataY = oData;\n    let colWidth = u.bbox.width;\n\n    if (dataX.length > 1) {\n      // prior index with non-undefined y data\n      let prevIdx = null; // scan full dataset for smallest adjacent delta\n      // will not work properly for non-linear x scales, since does not do expensive valToPosX calcs till end\n\n      for (let i = 0, minDelta = Infinity; i < dataX.length; i++) {\n        if (dataY[i] !== undefined) {\n          if (prevIdx != null) {\n            let delta = Math.abs(dataX[i] - dataX[prevIdx]);\n\n            if (delta < minDelta) {\n              minDelta = delta;\n              colWidth = Math.abs(u.valToPos(dataX[i], 'x') - u.valToPos(dataX[prevIdx], 'x'));\n            }\n          }\n\n          prevIdx = i;\n        }\n      }\n    }\n\n    let barWidth = Math.round(0.6 * colWidth);\n    let stickWidth = 2;\n    let outlineWidth = 2;\n\n    if (barWidth <= 12) {\n      stickWidth = outlineWidth = 1;\n    }\n\n    let halfWidth = Math.floor(barWidth / 2);\n\n    for (let i = idx0; i <= idx1; i++) {\n      let tPx = Math.round(u.valToPos(tData[i], 'x', true)); // current close vs prior close\n\n      let interDir = i === idx0 ? 0 : Math.sign(cData[i] - cData[i - 1]); // current close vs current open\n\n      let intraDir = Math.sign(cData[i] - oData[i]); // volume\n\n      if (drawVolume) {\n        let outerPath = selectPath(colorStrategy === ColorStrategy.CloseClose ? interDir : intraDir, flatPathVol, upPathVol, downPathVol, i === idx0 && ColorStrategy.CloseClose ? false : flatAsUp);\n        let vPx = Math.round(u.valToPos(vData[i], u.series[vIdx].scale, true));\n        outerPath.rect(tPx - halfWidth, vPx, barWidth, zeroPx - vPx);\n      }\n\n      if (drawPrice) {\n        let outerPath = selectPath(colorStrategy === ColorStrategy.CloseClose ? interDir : intraDir, flatPath, upPath, downPath, i === idx0 && ColorStrategy.CloseClose ? false : flatAsUp); // stick\n\n        let hPx = Math.round(u.valToPos(hData[i], u.series[hIdx].scale, true));\n        let lPx = Math.round(u.valToPos(lData[i], u.series[lIdx].scale, true));\n        outerPath.rect(tPx - Math.floor(stickWidth / 2), hPx, stickWidth, lPx - hPx);\n        let oPx = Math.round(u.valToPos(oData[i], u.series[oIdx].scale, true));\n        let cPx = Math.round(u.valToPos(cData[i], u.series[cIdx].scale, true));\n\n        if (asCandles) {\n          // rect\n          let top = Math.min(oPx, cPx);\n          let btm = Math.max(oPx, cPx);\n          let hgt = Math.max(1, btm - top);\n          outerPath.rect(tPx - halfWidth, top, barWidth, hgt);\n\n          if (colorStrategy === ColorStrategy.CloseClose) {\n            if (intraDir >= 0 && hgt > outlineWidth * 2) {\n              hollowPath.rect(tPx - halfWidth + outlineWidth, top + outlineWidth, barWidth - outlineWidth * 2, hgt - outlineWidth * 2);\n            }\n          }\n        } else {\n          outerPath.rect(tPx - halfWidth, oPx, halfWidth, stickWidth);\n          outerPath.rect(tPx, cPx, halfWidth, stickWidth);\n        }\n      }\n    }\n\n    ctx.save();\n    ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n    ctx.clip();\n\n    if (drawVolume) {\n      ctx.fillStyle = alpha(upColor, volumeAlpha);\n      ctx.fill(upPathVol);\n      ctx.fillStyle = alpha(downColor, volumeAlpha);\n      ctx.fill(downPathVol);\n      ctx.fillStyle = alpha(flatColor, volumeAlpha);\n      ctx.fill(flatPathVol);\n    }\n\n    if (drawPrice) {\n      ctx.fillStyle = upColor;\n      ctx.fill(upPath);\n      ctx.fillStyle = downColor;\n      ctx.fill(downPath);\n      ctx.fillStyle = flatColor;\n      ctx.fill(flatPath);\n      ctx.globalCompositeOperation = 'destination-out';\n      ctx.fill(hollowPath);\n    }\n\n    ctx.restore();\n  };\n}","map":{"version":3,"names":["colorManipulator","VizDisplayMode","ColorStrategy","CandleStyle","alpha","drawMarkers","opts","mode","candleStyle","fields","colorStrategy","upColor","downColor","flatColor","volumeAlpha","flatAsUp","drawPrice","Volume","high","low","asCandles","Candles","drawVolume","volume","selectPath","priceDir","flatPath","upPath","downPath","tIdx","oIdx","open","hIdx","lIdx","cIdx","close","vIdx","u","downPathVol","upPathVol","flatPathVol","Path2D","hollowPath","ctx","tData","data","oData","cData","hData","lData","vData","zeroPx","Math","round","valToPos","series","scale","idx0","idx1","idxs","dataX","dataY","colWidth","bbox","width","length","prevIdx","i","minDelta","Infinity","undefined","delta","abs","barWidth","stickWidth","outlineWidth","halfWidth","floor","tPx","interDir","sign","intraDir","outerPath","CloseClose","vPx","rect","hPx","lPx","oPx","cPx","top","min","btm","max","hgt","save","left","height","clip","fillStyle","fill","globalCompositeOperation","restore"],"sources":["/home/soula/grafana/public/app/plugins/panel/candlestick/utils.ts"],"sourcesContent":["import uPlot from 'uplot';\n\nimport { colorManipulator } from '@grafana/data';\n\nimport { VizDisplayMode, ColorStrategy, CandleStyle } from './models.gen';\n\nconst { alpha } = colorManipulator;\n\nexport type FieldIndices = Record<string, number>;\n\ninterface RendererOpts {\n  mode: VizDisplayMode;\n  candleStyle: CandleStyle;\n  fields: FieldIndices;\n  colorStrategy: ColorStrategy;\n  upColor: string;\n  downColor: string;\n  flatColor: string;\n  volumeAlpha: number;\n  flatAsUp: boolean;\n}\n\nexport function drawMarkers(opts: RendererOpts) {\n  let { mode, candleStyle, fields, colorStrategy, upColor, downColor, flatColor, volumeAlpha, flatAsUp = true } = opts;\n\n  const drawPrice = mode !== VizDisplayMode.Volume && fields.high != null && fields.low != null;\n  const asCandles = drawPrice && candleStyle === CandleStyle.Candles;\n  const drawVolume = mode !== VizDisplayMode.Candles && fields.volume != null;\n\n  function selectPath(priceDir: number, flatPath: Path2D, upPath: Path2D, downPath: Path2D, flatAsUp: boolean) {\n    return priceDir > 0 ? upPath : priceDir < 0 ? downPath : flatAsUp ? upPath : flatPath;\n  }\n\n  let tIdx = 0,\n    oIdx = fields.open,\n    hIdx = fields.high,\n    lIdx = fields.low,\n    cIdx = fields.close,\n    vIdx = fields.volume;\n\n  return (u: uPlot) => {\n    // split by discrete color to reduce draw calls\n    let downPath, upPath, flatPath;\n    // with adjusted reduced\n    let downPathVol, upPathVol, flatPathVol;\n\n    if (drawPrice) {\n      flatPath = new Path2D();\n      upPath = new Path2D();\n      downPath = new Path2D();\n    }\n\n    if (drawVolume) {\n      downPathVol = new Path2D();\n      upPathVol = new Path2D();\n      flatPathVol = new Path2D();\n    }\n\n    let hollowPath = new Path2D();\n\n    let ctx = u.ctx;\n\n    let tData = u.data[tIdx!];\n\n    let oData = u.data[oIdx!];\n    let cData = u.data[cIdx!];\n\n    let hData = drawPrice ? u.data[hIdx!] : null;\n    let lData = drawPrice ? u.data[lIdx!] : null;\n    let vData = drawVolume ? u.data[vIdx!] : null;\n\n    let zeroPx = vIdx != null ? Math.round(u.valToPos(0, u.series[vIdx!].scale!, true)) : null;\n\n    let [idx0, idx1] = u.series[0].idxs!;\n\n    let dataX = u.data[0];\n    let dataY = oData;\n\n    let colWidth = u.bbox.width;\n\n    if (dataX.length > 1) {\n      // prior index with non-undefined y data\n      let prevIdx = null;\n\n      // scan full dataset for smallest adjacent delta\n      // will not work properly for non-linear x scales, since does not do expensive valToPosX calcs till end\n      for (let i = 0, minDelta = Infinity; i < dataX.length; i++) {\n        if (dataY[i] !== undefined) {\n          if (prevIdx != null) {\n            let delta = Math.abs(dataX[i] - dataX[prevIdx]);\n\n            if (delta < minDelta) {\n              minDelta = delta;\n              colWidth = Math.abs(u.valToPos(dataX[i], 'x') - u.valToPos(dataX[prevIdx], 'x'));\n            }\n          }\n\n          prevIdx = i;\n        }\n      }\n    }\n\n    let barWidth = Math.round(0.6 * colWidth);\n\n    let stickWidth = 2;\n    let outlineWidth = 2;\n\n    if (barWidth <= 12) {\n      stickWidth = outlineWidth = 1;\n    }\n\n    let halfWidth = Math.floor(barWidth / 2);\n\n    for (let i = idx0; i <= idx1; i++) {\n      let tPx = Math.round(u.valToPos(tData[i]!, 'x', true));\n\n      // current close vs prior close\n      let interDir = i === idx0 ? 0 : Math.sign(cData[i]! - cData[i - 1]!);\n      // current close vs current open\n      let intraDir = Math.sign(cData[i]! - oData[i]!);\n\n      // volume\n      if (drawVolume) {\n        let outerPath = selectPath(\n          colorStrategy === ColorStrategy.CloseClose ? interDir : intraDir,\n          flatPathVol as Path2D,\n          upPathVol as Path2D,\n          downPathVol as Path2D,\n          i === idx0 && ColorStrategy.CloseClose ? false : flatAsUp\n        );\n\n        let vPx = Math.round(u.valToPos(vData![i]!, u.series[vIdx!].scale!, true));\n        outerPath.rect(tPx - halfWidth, vPx, barWidth, zeroPx! - vPx);\n      }\n\n      if (drawPrice) {\n        let outerPath = selectPath(\n          colorStrategy === ColorStrategy.CloseClose ? interDir : intraDir,\n          flatPath as Path2D,\n          upPath as Path2D,\n          downPath as Path2D,\n          i === idx0 && ColorStrategy.CloseClose ? false : flatAsUp\n        );\n\n        // stick\n        let hPx = Math.round(u.valToPos(hData![i]!, u.series[hIdx!].scale!, true));\n        let lPx = Math.round(u.valToPos(lData![i]!, u.series[lIdx!].scale!, true));\n        outerPath.rect(tPx - Math.floor(stickWidth / 2), hPx, stickWidth, lPx - hPx);\n\n        let oPx = Math.round(u.valToPos(oData[i]!, u.series[oIdx!].scale!, true));\n        let cPx = Math.round(u.valToPos(cData[i]!, u.series[cIdx!].scale!, true));\n\n        if (asCandles) {\n          // rect\n          let top = Math.min(oPx, cPx);\n          let btm = Math.max(oPx, cPx);\n          let hgt = Math.max(1, btm - top);\n          outerPath.rect(tPx - halfWidth, top, barWidth, hgt);\n\n          if (colorStrategy === ColorStrategy.CloseClose) {\n            if (intraDir >= 0 && hgt > outlineWidth * 2) {\n              hollowPath.rect(\n                tPx - halfWidth + outlineWidth,\n                top + outlineWidth,\n                barWidth - outlineWidth * 2,\n                hgt - outlineWidth * 2\n              );\n            }\n          }\n        } else {\n          outerPath.rect(tPx - halfWidth, oPx, halfWidth, stickWidth);\n          outerPath.rect(tPx, cPx, halfWidth, stickWidth);\n        }\n      }\n    }\n\n    ctx.save();\n\n    ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n    ctx.clip();\n\n    if (drawVolume) {\n      ctx.fillStyle = alpha(upColor, volumeAlpha);\n      ctx.fill(upPathVol as Path2D);\n\n      ctx.fillStyle = alpha(downColor, volumeAlpha);\n      ctx.fill(downPathVol as Path2D);\n\n      ctx.fillStyle = alpha(flatColor, volumeAlpha);\n      ctx.fill(flatPathVol as Path2D);\n    }\n\n    if (drawPrice) {\n      ctx.fillStyle = upColor;\n      ctx.fill(upPath as Path2D);\n\n      ctx.fillStyle = downColor;\n      ctx.fill(downPath as Path2D);\n\n      ctx.fillStyle = flatColor;\n      ctx.fill(flatPath as Path2D);\n\n      ctx.globalCompositeOperation = 'destination-out';\n      ctx.fill(hollowPath);\n    }\n\n    ctx.restore();\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}