{"ast":null,"code":"import { createAction } from '@reduxjs/toolkit';\nimport { isEqual } from 'lodash';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { keybindingSrv } from 'app/core/services/keybindingSrv';\nimport { DEFAULT_RANGE, getQueryKeys, parseUrlState, ensureQueries, generateNewKeyAndAddRefIdIfMissing, getTimeRangeFromUrl } from 'app/core/utils/explore';\nimport { getFiscalYearStartMonth, getTimeZone } from 'app/features/profile/state/selectors';\nimport { datasourceReducer } from './datasource';\nimport { historyReducer } from './history';\nimport { richHistorySearchFiltersUpdatedAction, richHistoryUpdatedAction, stateSave } from './main';\nimport { queryReducer, runQueries, setQueriesAction } from './query';\nimport { timeReducer, updateTime } from './time';\nimport { makeExplorePaneState, loadAndInitDatasource, createEmptyQueryResponse, getUrlStateFromPaneState, storeGraphStyle } from './utils'; // Types\n//\n// Actions and Payloads\n//\n\n/**\n * Keep track of the Explore container size, in particular the width.\n * The width will be used to calculate graph intervals (number of datapoints).\n */\n\nexport const changeSizeAction = createAction('explore/changeSize');\n/**\n * Tracks the state of explore panels that gets synced with the url.\n */\n\nconst changePanelsStateAction = createAction('explore/changePanels');\nexport function changePanelState(exploreId, panel, panelState) {\n  return async (dispatch, getState) => {\n    const exploreItem = getState().explore[exploreId];\n\n    if (exploreItem === undefined) {\n      return;\n    }\n\n    const {\n      panelsState\n    } = exploreItem;\n    dispatch(changePanelsStateAction({\n      exploreId,\n      panelsState: Object.assign({}, panelsState, {\n        [panel]: panelState\n      })\n    }));\n    dispatch(stateSave());\n  };\n}\n/**\n * Initialize Explore state with state from the URL and the React component.\n * Call this only on components for with the Explore state has not been initialized.\n */\n\nexport const initializeExploreAction = createAction('explore/initializeExplore');\nexport const setUrlReplacedAction = createAction('explore/setUrlReplaced');\n/**\n * Keep track of the Explore container size, in particular the width.\n * The width will be used to calculate graph intervals (number of datapoints).\n */\n\nexport function changeSize(exploreId, {\n  height,\n  width\n}) {\n  return changeSizeAction({\n    exploreId,\n    height,\n    width\n  });\n}\nconst changeGraphStyleAction = createAction('explore/changeGraphStyle');\nexport function changeGraphStyle(exploreId, graphStyle) {\n  return async (dispatch, getState) => {\n    storeGraphStyle(graphStyle);\n    dispatch(changeGraphStyleAction({\n      exploreId,\n      graphStyle\n    }));\n  };\n}\n/**\n * Initialize Explore state with state from the URL and the React component.\n * Call this only on components for with the Explore state has not been initialized.\n */\n\nexport function initializeExplore(exploreId, datasourceNameOrUid, queries, range, containerWidth, eventBridge, panelsState) {\n  return async (dispatch, getState) => {\n    const exploreDatasources = getDataSourceSrv().getList();\n    let instance = undefined;\n    let history = [];\n\n    if (exploreDatasources.length >= 1) {\n      const orgId = getState().user.orgId;\n      const loadResult = await loadAndInitDatasource(orgId, datasourceNameOrUid);\n      instance = loadResult.instance;\n      history = loadResult.history;\n    }\n\n    dispatch(initializeExploreAction({\n      exploreId,\n      containerWidth,\n      eventBridge,\n      queries,\n      range,\n      datasourceInstance: instance,\n      history\n    }));\n\n    if (panelsState !== undefined) {\n      dispatch(changePanelsStateAction({\n        exploreId,\n        panelsState\n      }));\n    }\n\n    dispatch(updateTime({\n      exploreId\n    }));\n    keybindingSrv.setupTimeRangeBindings(false);\n\n    if (instance) {\n      // We do not want to add the url to browser history on init because when the pane is initialised it's because\n      // we already have something in the url. Adding basically the same state as additional history item prevents\n      // user to go back to previous url.\n      dispatch(runQueries(exploreId, {\n        replaceUrl: true\n      }));\n    }\n  };\n}\n/**\n * Reacts to changes in URL state that we need to sync back to our redux state. Computes diff of newUrlQuery vs current\n * state and runs update actions for relevant parts.\n */\n\nexport function refreshExplore(exploreId, newUrlQuery) {\n  return async (dispatch, getState) => {\n    const itemState = getState().explore[exploreId];\n\n    if (!itemState.initialized) {\n      return;\n    } // Get diff of what should be updated\n\n\n    const newUrlState = parseUrlState(newUrlQuery);\n    const update = urlDiff(newUrlState, getUrlStateFromPaneState(itemState));\n    const {\n      containerWidth,\n      eventBridge\n    } = itemState;\n    const {\n      datasource,\n      queries,\n      range: urlRange,\n      panelsState\n    } = newUrlState;\n    const refreshQueries = [];\n\n    for (let index = 0; index < queries.length; index++) {\n      const query = queries[index];\n      refreshQueries.push(generateNewKeyAndAddRefIdIfMissing(query, refreshQueries, index));\n    }\n\n    const timeZone = getTimeZone(getState().user);\n    const fiscalYearStartMonth = getFiscalYearStartMonth(getState().user);\n    const range = getTimeRangeFromUrl(urlRange, timeZone, fiscalYearStartMonth); // commit changes based on the diff of new url vs old url\n\n    if (update.datasource) {\n      const initialQueries = ensureQueries(queries);\n      await dispatch(initializeExplore(exploreId, datasource, initialQueries, range, containerWidth, eventBridge, panelsState));\n      return;\n    }\n\n    if (update.range) {\n      dispatch(updateTime({\n        exploreId,\n        rawRange: range.raw\n      }));\n    }\n\n    if (update.queries) {\n      dispatch(setQueriesAction({\n        exploreId,\n        queries: refreshQueries\n      }));\n    }\n\n    if (update.panelsState && panelsState !== undefined) {\n      dispatch(changePanelsStateAction({\n        exploreId,\n        panelsState\n      }));\n    } // always run queries when refresh is needed\n\n\n    if (update.queries || update.range) {\n      dispatch(runQueries(exploreId));\n    }\n  };\n}\n/**\n * Reducer for an Explore area, to be used by the global Explore reducer.\n */\n// Redux Toolkit uses ImmerJs as part of their solution to ensure that state objects are not mutated.\n// ImmerJs has an autoFreeze option that freezes objects from change which means this reducer can't be migrated to createSlice\n// because the state would become frozen and during run time we would get errors because flot (Graph lib) would try to mutate\n// the frozen state.\n// https://github.com/reduxjs/redux-toolkit/issues/242\n\nexport const paneReducer = (state = makeExplorePaneState(), action) => {\n  state = queryReducer(state, action);\n  state = datasourceReducer(state, action);\n  state = timeReducer(state, action);\n  state = historyReducer(state, action);\n\n  if (richHistoryUpdatedAction.match(action)) {\n    const {\n      richHistory,\n      total\n    } = action.payload.richHistoryResults;\n    return Object.assign({}, state, {\n      richHistory,\n      richHistoryTotal: total\n    });\n  }\n\n  if (richHistorySearchFiltersUpdatedAction.match(action)) {\n    const richHistorySearchFilters = action.payload.filters;\n    return Object.assign({}, state, {\n      richHistorySearchFilters\n    });\n  }\n\n  if (changeSizeAction.match(action)) {\n    const containerWidth = action.payload.width;\n    return Object.assign({}, state, {\n      containerWidth\n    });\n  }\n\n  if (changeGraphStyleAction.match(action)) {\n    const {\n      graphStyle\n    } = action.payload;\n    return Object.assign({}, state, {\n      graphStyle\n    });\n  }\n\n  if (changePanelsStateAction.match(action)) {\n    const {\n      panelsState\n    } = action.payload;\n    return Object.assign({}, state, {\n      panelsState\n    });\n  }\n\n  if (initializeExploreAction.match(action)) {\n    const {\n      containerWidth,\n      eventBridge,\n      queries,\n      range,\n      datasourceInstance,\n      history\n    } = action.payload;\n    return Object.assign({}, state, {\n      containerWidth,\n      eventBridge,\n      range,\n      queries,\n      initialized: true,\n      queryKeys: getQueryKeys(queries, datasourceInstance),\n      datasourceInstance,\n      history,\n      datasourceMissing: !datasourceInstance,\n      queryResponse: createEmptyQueryResponse(),\n      cache: []\n    });\n  }\n\n  return state;\n};\n/**\n * Compare 2 explore urls and return a map of what changed. Used to update the local state with all the\n * side effects needed.\n */\n\nexport const urlDiff = (oldUrlState, currentUrlState) => {\n  const datasource = !isEqual(currentUrlState === null || currentUrlState === void 0 ? void 0 : currentUrlState.datasource, oldUrlState === null || oldUrlState === void 0 ? void 0 : oldUrlState.datasource);\n  const queries = !isEqual(currentUrlState === null || currentUrlState === void 0 ? void 0 : currentUrlState.queries, oldUrlState === null || oldUrlState === void 0 ? void 0 : oldUrlState.queries);\n  const range = !isEqual((currentUrlState === null || currentUrlState === void 0 ? void 0 : currentUrlState.range) || DEFAULT_RANGE, (oldUrlState === null || oldUrlState === void 0 ? void 0 : oldUrlState.range) || DEFAULT_RANGE);\n  const panelsState = !isEqual(currentUrlState === null || currentUrlState === void 0 ? void 0 : currentUrlState.panelsState, oldUrlState === null || oldUrlState === void 0 ? void 0 : oldUrlState.panelsState);\n  return {\n    datasource,\n    queries,\n    range,\n    panelsState\n  };\n};","map":{"version":3,"names":["createAction","isEqual","getDataSourceSrv","keybindingSrv","DEFAULT_RANGE","getQueryKeys","parseUrlState","ensureQueries","generateNewKeyAndAddRefIdIfMissing","getTimeRangeFromUrl","getFiscalYearStartMonth","getTimeZone","datasourceReducer","historyReducer","richHistorySearchFiltersUpdatedAction","richHistoryUpdatedAction","stateSave","queryReducer","runQueries","setQueriesAction","timeReducer","updateTime","makeExplorePaneState","loadAndInitDatasource","createEmptyQueryResponse","getUrlStateFromPaneState","storeGraphStyle","changeSizeAction","changePanelsStateAction","changePanelState","exploreId","panel","panelState","dispatch","getState","exploreItem","explore","undefined","panelsState","initializeExploreAction","setUrlReplacedAction","changeSize","height","width","changeGraphStyleAction","changeGraphStyle","graphStyle","initializeExplore","datasourceNameOrUid","queries","range","containerWidth","eventBridge","exploreDatasources","getList","instance","history","length","orgId","user","loadResult","datasourceInstance","setupTimeRangeBindings","replaceUrl","refreshExplore","newUrlQuery","itemState","initialized","newUrlState","update","urlDiff","datasource","urlRange","refreshQueries","index","query","push","timeZone","fiscalYearStartMonth","initialQueries","rawRange","raw","paneReducer","state","action","match","richHistory","total","payload","richHistoryResults","richHistoryTotal","richHistorySearchFilters","filters","queryKeys","datasourceMissing","queryResponse","cache","oldUrlState","currentUrlState"],"sources":["/home/soula/grafana/public/app/features/explore/state/explorePane.ts"],"sourcesContent":["import { createAction, PayloadAction } from '@reduxjs/toolkit';\nimport { isEqual } from 'lodash';\nimport { AnyAction } from 'redux';\n\nimport {\n  EventBusExtended,\n  DataQuery,\n  ExploreUrlState,\n  TimeRange,\n  HistoryItem,\n  DataSourceApi,\n  ExplorePanelsState,\n  PreferredVisualisationType,\n} from '@grafana/data';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { keybindingSrv } from 'app/core/services/keybindingSrv';\nimport {\n  DEFAULT_RANGE,\n  getQueryKeys,\n  parseUrlState,\n  ensureQueries,\n  generateNewKeyAndAddRefIdIfMissing,\n  getTimeRangeFromUrl,\n} from 'app/core/utils/explore';\nimport { getFiscalYearStartMonth, getTimeZone } from 'app/features/profile/state/selectors';\nimport { ThunkResult } from 'app/types';\nimport { ExploreGraphStyle, ExploreId, ExploreItemState } from 'app/types/explore';\n\nimport { datasourceReducer } from './datasource';\nimport { historyReducer } from './history';\nimport { richHistorySearchFiltersUpdatedAction, richHistoryUpdatedAction, stateSave } from './main';\nimport { queryReducer, runQueries, setQueriesAction } from './query';\nimport { timeReducer, updateTime } from './time';\nimport {\n  makeExplorePaneState,\n  loadAndInitDatasource,\n  createEmptyQueryResponse,\n  getUrlStateFromPaneState,\n  storeGraphStyle,\n} from './utils';\n// Types\n\n//\n// Actions and Payloads\n//\n\n/**\n * Keep track of the Explore container size, in particular the width.\n * The width will be used to calculate graph intervals (number of datapoints).\n */\nexport interface ChangeSizePayload {\n  exploreId: ExploreId;\n  width: number;\n  height: number;\n}\nexport const changeSizeAction = createAction<ChangeSizePayload>('explore/changeSize');\n\n/**\n * Tracks the state of explore panels that gets synced with the url.\n */\ninterface ChangePanelsState {\n  exploreId: ExploreId;\n  panelsState: ExplorePanelsState;\n}\nconst changePanelsStateAction = createAction<ChangePanelsState>('explore/changePanels');\nexport function changePanelState(\n  exploreId: ExploreId,\n  panel: PreferredVisualisationType,\n  panelState: ExplorePanelsState[PreferredVisualisationType]\n): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    const exploreItem = getState().explore[exploreId];\n    if (exploreItem === undefined) {\n      return;\n    }\n    const { panelsState } = exploreItem;\n    dispatch(\n      changePanelsStateAction({\n        exploreId,\n        panelsState: {\n          ...panelsState,\n          [panel]: panelState,\n        },\n      })\n    );\n    dispatch(stateSave());\n  };\n}\n\n/**\n * Initialize Explore state with state from the URL and the React component.\n * Call this only on components for with the Explore state has not been initialized.\n */\nexport interface InitializeExplorePayload {\n  exploreId: ExploreId;\n  containerWidth: number;\n  eventBridge: EventBusExtended;\n  queries: DataQuery[];\n  range: TimeRange;\n  history: HistoryItem[];\n  datasourceInstance?: DataSourceApi;\n}\nexport const initializeExploreAction = createAction<InitializeExplorePayload>('explore/initializeExplore');\n\nexport interface SetUrlReplacedPayload {\n  exploreId: ExploreId;\n}\nexport const setUrlReplacedAction = createAction<SetUrlReplacedPayload>('explore/setUrlReplaced');\n\n/**\n * Keep track of the Explore container size, in particular the width.\n * The width will be used to calculate graph intervals (number of datapoints).\n */\nexport function changeSize(\n  exploreId: ExploreId,\n  { height, width }: { height: number; width: number }\n): PayloadAction<ChangeSizePayload> {\n  return changeSizeAction({ exploreId, height, width });\n}\n\ninterface ChangeGraphStylePayload {\n  exploreId: ExploreId;\n  graphStyle: ExploreGraphStyle;\n}\n\nconst changeGraphStyleAction = createAction<ChangeGraphStylePayload>('explore/changeGraphStyle');\n\nexport function changeGraphStyle(exploreId: ExploreId, graphStyle: ExploreGraphStyle): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    storeGraphStyle(graphStyle);\n    dispatch(changeGraphStyleAction({ exploreId, graphStyle }));\n  };\n}\n\n/**\n * Initialize Explore state with state from the URL and the React component.\n * Call this only on components for with the Explore state has not been initialized.\n */\nexport function initializeExplore(\n  exploreId: ExploreId,\n  datasourceNameOrUid: string,\n  queries: DataQuery[],\n  range: TimeRange,\n  containerWidth: number,\n  eventBridge: EventBusExtended,\n  panelsState?: ExplorePanelsState\n): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    const exploreDatasources = getDataSourceSrv().getList();\n    let instance = undefined;\n    let history: HistoryItem[] = [];\n\n    if (exploreDatasources.length >= 1) {\n      const orgId = getState().user.orgId;\n      const loadResult = await loadAndInitDatasource(orgId, datasourceNameOrUid);\n      instance = loadResult.instance;\n      history = loadResult.history;\n    }\n\n    dispatch(\n      initializeExploreAction({\n        exploreId,\n        containerWidth,\n        eventBridge,\n        queries,\n        range,\n        datasourceInstance: instance,\n        history,\n      })\n    );\n    if (panelsState !== undefined) {\n      dispatch(changePanelsStateAction({ exploreId, panelsState }));\n    }\n    dispatch(updateTime({ exploreId }));\n\n    keybindingSrv.setupTimeRangeBindings(false);\n\n    if (instance) {\n      // We do not want to add the url to browser history on init because when the pane is initialised it's because\n      // we already have something in the url. Adding basically the same state as additional history item prevents\n      // user to go back to previous url.\n      dispatch(runQueries(exploreId, { replaceUrl: true }));\n    }\n  };\n}\n\n/**\n * Reacts to changes in URL state that we need to sync back to our redux state. Computes diff of newUrlQuery vs current\n * state and runs update actions for relevant parts.\n */\nexport function refreshExplore(exploreId: ExploreId, newUrlQuery: string): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    const itemState = getState().explore[exploreId]!;\n    if (!itemState.initialized) {\n      return;\n    }\n\n    // Get diff of what should be updated\n    const newUrlState = parseUrlState(newUrlQuery);\n    const update = urlDiff(newUrlState, getUrlStateFromPaneState(itemState));\n\n    const { containerWidth, eventBridge } = itemState;\n\n    const { datasource, queries, range: urlRange, panelsState } = newUrlState;\n    const refreshQueries: DataQuery[] = [];\n\n    for (let index = 0; index < queries.length; index++) {\n      const query = queries[index];\n      refreshQueries.push(generateNewKeyAndAddRefIdIfMissing(query, refreshQueries, index));\n    }\n\n    const timeZone = getTimeZone(getState().user);\n    const fiscalYearStartMonth = getFiscalYearStartMonth(getState().user);\n    const range = getTimeRangeFromUrl(urlRange, timeZone, fiscalYearStartMonth);\n\n    // commit changes based on the diff of new url vs old url\n\n    if (update.datasource) {\n      const initialQueries = ensureQueries(queries);\n      await dispatch(\n        initializeExplore(exploreId, datasource, initialQueries, range, containerWidth, eventBridge, panelsState)\n      );\n      return;\n    }\n\n    if (update.range) {\n      dispatch(updateTime({ exploreId, rawRange: range.raw }));\n    }\n\n    if (update.queries) {\n      dispatch(setQueriesAction({ exploreId, queries: refreshQueries }));\n    }\n\n    if (update.panelsState && panelsState !== undefined) {\n      dispatch(changePanelsStateAction({ exploreId, panelsState }));\n    }\n\n    // always run queries when refresh is needed\n    if (update.queries || update.range) {\n      dispatch(runQueries(exploreId));\n    }\n  };\n}\n\n/**\n * Reducer for an Explore area, to be used by the global Explore reducer.\n */\n// Redux Toolkit uses ImmerJs as part of their solution to ensure that state objects are not mutated.\n// ImmerJs has an autoFreeze option that freezes objects from change which means this reducer can't be migrated to createSlice\n// because the state would become frozen and during run time we would get errors because flot (Graph lib) would try to mutate\n// the frozen state.\n// https://github.com/reduxjs/redux-toolkit/issues/242\nexport const paneReducer = (state: ExploreItemState = makeExplorePaneState(), action: AnyAction): ExploreItemState => {\n  state = queryReducer(state, action);\n  state = datasourceReducer(state, action);\n  state = timeReducer(state, action);\n  state = historyReducer(state, action);\n\n  if (richHistoryUpdatedAction.match(action)) {\n    const { richHistory, total } = action.payload.richHistoryResults;\n    return {\n      ...state,\n      richHistory,\n      richHistoryTotal: total,\n    };\n  }\n\n  if (richHistorySearchFiltersUpdatedAction.match(action)) {\n    const richHistorySearchFilters = action.payload.filters;\n    return {\n      ...state,\n      richHistorySearchFilters,\n    };\n  }\n\n  if (changeSizeAction.match(action)) {\n    const containerWidth = action.payload.width;\n    return { ...state, containerWidth };\n  }\n\n  if (changeGraphStyleAction.match(action)) {\n    const { graphStyle } = action.payload;\n    return { ...state, graphStyle };\n  }\n\n  if (changePanelsStateAction.match(action)) {\n    const { panelsState } = action.payload;\n    return { ...state, panelsState };\n  }\n\n  if (initializeExploreAction.match(action)) {\n    const { containerWidth, eventBridge, queries, range, datasourceInstance, history } = action.payload;\n\n    return {\n      ...state,\n      containerWidth,\n      eventBridge,\n      range,\n      queries,\n      initialized: true,\n      queryKeys: getQueryKeys(queries, datasourceInstance),\n      datasourceInstance,\n      history,\n      datasourceMissing: !datasourceInstance,\n      queryResponse: createEmptyQueryResponse(),\n      cache: [],\n    };\n  }\n\n  return state;\n};\n\n/**\n * Compare 2 explore urls and return a map of what changed. Used to update the local state with all the\n * side effects needed.\n */\nexport const urlDiff = (\n  oldUrlState: ExploreUrlState | undefined,\n  currentUrlState: ExploreUrlState | undefined\n): {\n  datasource: boolean;\n  queries: boolean;\n  range: boolean;\n  panelsState: boolean;\n} => {\n  const datasource = !isEqual(currentUrlState?.datasource, oldUrlState?.datasource);\n  const queries = !isEqual(currentUrlState?.queries, oldUrlState?.queries);\n  const range = !isEqual(currentUrlState?.range || DEFAULT_RANGE, oldUrlState?.range || DEFAULT_RANGE);\n  const panelsState = !isEqual(currentUrlState?.panelsState, oldUrlState?.panelsState);\n\n  return {\n    datasource,\n    queries,\n    range,\n    panelsState,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}