{"ast":null,"code":"const _excluded = [\"value\", \"existingKeys\", \"aria-label\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { useMemo } from 'react';\nimport { Annotation, annotationLabels } from '../../utils/constants';\nimport { SelectWithAdd } from './SelectWIthAdd';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const AnnotationKeyInput = _ref => {\n  let {\n    value,\n    existingKeys,\n    'aria-label': ariaLabel\n  } = _ref,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  const annotationOptions = useMemo(() => Object.values(Annotation).filter(key => !existingKeys.includes(key)) // remove keys already taken in other annotations\n  .map(key => ({\n    value: key,\n    label: annotationLabels[key]\n  })), [existingKeys]);\n  return /*#__PURE__*/_jsx(SelectWithAdd, Object.assign({\n    \"aria-label\": ariaLabel,\n    value: value,\n    options: annotationOptions,\n    custom: !!value && !Object.values(Annotation).includes(value)\n  }, rest));\n};","map":{"version":3,"names":["React","useMemo","Annotation","annotationLabels","SelectWithAdd","AnnotationKeyInput","value","existingKeys","ariaLabel","rest","annotationOptions","Object","values","filter","key","includes","map","label"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/components/rule-editor/AnnotationKeyInput.tsx"],"sourcesContent":["import React, { FC, useMemo } from 'react';\n\nimport { SelectableValue } from '@grafana/data';\n\nimport { Annotation, annotationLabels } from '../../utils/constants';\n\nimport { SelectWithAdd } from './SelectWIthAdd';\n\ninterface Props {\n  onChange: (value: string) => void;\n  existingKeys: string[];\n\n  value?: string;\n  width?: number;\n  className?: string;\n  'aria-label'?: string;\n}\n\nexport const AnnotationKeyInput: FC<Props> = ({ value, existingKeys, 'aria-label': ariaLabel, ...rest }) => {\n  const annotationOptions = useMemo(\n    (): SelectableValue[] =>\n      Object.values(Annotation)\n        .filter((key) => !existingKeys.includes(key)) // remove keys already taken in other annotations\n        .map((key) => ({ value: key, label: annotationLabels[key] })),\n    [existingKeys]\n  );\n\n  return (\n    <SelectWithAdd\n      aria-label={ariaLabel}\n      value={value}\n      options={annotationOptions}\n      custom={!!value && !(Object.values(Annotation) as string[]).includes(value)}\n      {...rest}\n    />\n  );\n};\n"],"mappings":";;;;AAAA,OAAOA,KAAP,IAAoBC,OAApB,QAAmC,OAAnC;AAIA,SAASC,UAAT,EAAqBC,gBAArB,QAA6C,uBAA7C;AAEA,SAASC,aAAT,QAA8B,iBAA9B;;AAYA,OAAO,MAAMC,kBAA6B,GAAG,QAA+D;EAAA,IAA9D;IAAEC,KAAF;IAASC,YAAT;IAAuB,cAAcC;EAArC,CAA8D;EAAA,IAAXC,IAAW;;EAC1G,MAAMC,iBAAiB,GAAGT,OAAO,CAC/B,MACEU,MAAM,CAACC,MAAP,CAAcV,UAAd,EACGW,MADH,CACWC,GAAD,IAAS,CAACP,YAAY,CAACQ,QAAb,CAAsBD,GAAtB,CADpB,EACgD;EADhD,CAEGE,GAFH,CAEQF,GAAD,KAAU;IAAER,KAAK,EAAEQ,GAAT;IAAcG,KAAK,EAAEd,gBAAgB,CAACW,GAAD;EAArC,CAAV,CAFP,CAF6B,EAK/B,CAACP,YAAD,CAL+B,CAAjC;EAQA,oBACE,KAAC,aAAD;IACE,cAAYC,SADd;IAEE,KAAK,EAAEF,KAFT;IAGE,OAAO,EAAEI,iBAHX;IAIE,MAAM,EAAE,CAAC,CAACJ,KAAF,IAAW,CAAEK,MAAM,CAACC,MAAP,CAAcV,UAAd,CAAD,CAAwCa,QAAxC,CAAiDT,KAAjD;EAJtB,GAKMG,IALN,EADF;AASD,CAlBM"},"metadata":{},"sourceType":"module"}