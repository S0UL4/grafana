{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { escape, isString, property } from 'lodash';\nimport { deprecationWarning } from '@grafana/data';\nimport { getDataSourceSrv, setTemplateSrv } from '@grafana/runtime';\nimport { variableAdapters } from '../variables/adapters';\nimport { ALL_VARIABLE_TEXT, ALL_VARIABLE_VALUE } from '../variables/constants';\nimport { isAdHoc } from '../variables/guard';\nimport { getFilteredVariables, getVariables, getVariableWithName } from '../variables/state/selectors';\nimport { variableRegex } from '../variables/utils';\nimport { formatRegistry, FormatRegistryID } from './formatRegistry';\nconst runtimeDependencies = {\n  getFilteredVariables,\n  getVariables,\n  getVariableWithName\n};\nexport class TemplateSrv {\n  constructor(dependencies = runtimeDependencies) {\n    _defineProperty(this, \"_variables\", void 0);\n\n    _defineProperty(this, \"regex\", variableRegex);\n\n    _defineProperty(this, \"index\", {});\n\n    _defineProperty(this, \"grafanaVariables\", {});\n\n    _defineProperty(this, \"timeRange\", null);\n\n    _defineProperty(this, \"fieldAccessorCache\", {});\n\n    this.dependencies = dependencies;\n    this._variables = [];\n  }\n\n  init(variables, timeRange) {\n    this._variables = variables;\n    this.timeRange = timeRange;\n    this.updateIndex();\n  }\n  /**\n   * @deprecated: this instance variable should not be used and will be removed in future releases\n   *\n   * Use getVariables function instead\n   */\n\n\n  get variables() {\n    deprecationWarning('template_srv.ts', 'variables', 'getVariables');\n    return this.getVariables();\n  }\n\n  getVariables() {\n    return this.dependencies.getVariables();\n  }\n\n  updateIndex() {\n    const existsOrEmpty = value => value || value === '';\n\n    this.index = this._variables.reduce((acc, currentValue) => {\n      if (currentValue.current && (currentValue.current.isNone || existsOrEmpty(currentValue.current.value))) {\n        acc[currentValue.name] = currentValue;\n      }\n\n      return acc;\n    }, {});\n\n    if (this.timeRange) {\n      const from = this.timeRange.from.valueOf().toString();\n      const to = this.timeRange.to.valueOf().toString();\n      this.index = Object.assign({}, this.index, {\n        ['__from']: {\n          current: {\n            value: from,\n            text: from\n          }\n        },\n        ['__to']: {\n          current: {\n            value: to,\n            text: to\n          }\n        }\n      });\n    }\n  }\n\n  updateTimeRange(timeRange) {\n    this.timeRange = timeRange;\n    this.updateIndex();\n  }\n\n  variableInitialized(variable) {\n    this.index[variable.name] = variable;\n  }\n\n  getAdhocFilters(datasourceName) {\n    let filters = [];\n    let ds = getDataSourceSrv().getInstanceSettings(datasourceName);\n\n    if (!ds) {\n      return [];\n    }\n\n    for (const variable of this.getAdHocVariables()) {\n      var _variable$datasource;\n\n      const variableUid = (_variable$datasource = variable.datasource) === null || _variable$datasource === void 0 ? void 0 : _variable$datasource.uid;\n\n      if (variableUid === ds.uid) {\n        filters = filters.concat(variable.filters);\n      } else if ((variableUid === null || variableUid === void 0 ? void 0 : variableUid.indexOf('$')) === 0) {\n        if (this.replace(variableUid) === datasourceName) {\n          filters = filters.concat(variable.filters);\n        }\n      }\n    }\n\n    return filters;\n  }\n\n  formatValue(value, format, variable, text) {\n    // for some scopedVars there is no variable\n    variable = variable || {};\n\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    if (isAdHoc(variable) && format !== FormatRegistryID.queryParam) {\n      return '';\n    } // if it's an object transform value to string\n\n\n    if (!Array.isArray(value) && typeof value === 'object') {\n      value = `${value}`;\n    }\n\n    if (typeof format === 'function') {\n      return format(value, variable, this.formatValue);\n    }\n\n    if (!format) {\n      format = FormatRegistryID.glob;\n    } // some formats have arguments that come after ':' character\n\n\n    let args = format.split(':');\n\n    if (args.length > 1) {\n      format = args[0];\n      args = args.slice(1);\n    } else {\n      args = [];\n    }\n\n    let formatItem = formatRegistry.getIfExists(format);\n\n    if (!formatItem) {\n      console.error(`Variable format ${format} not found. Using glob format as fallback.`);\n      formatItem = formatRegistry.get(FormatRegistryID.glob);\n    }\n\n    const options = {\n      value,\n      args,\n      text: text !== null && text !== void 0 ? text : value\n    };\n    return formatItem.formatter(options, variable);\n  }\n\n  setGrafanaVariable(name, value) {\n    this.grafanaVariables[name] = value;\n  }\n  /**\n   * @deprecated: setGlobalVariable function should not be used and will be removed in future releases\n   *\n   * Use addVariable action to add variables to Redux instead\n   */\n\n\n  setGlobalVariable(name, variable) {\n    deprecationWarning('template_srv.ts', 'setGlobalVariable', '');\n    this.index = Object.assign({}, this.index, {\n      [name]: {\n        current: variable\n      }\n    });\n  }\n\n  getVariableName(expression) {\n    this.regex.lastIndex = 0;\n    const match = this.regex.exec(expression);\n\n    if (!match) {\n      return null;\n    }\n\n    const variableName = match.slice(1).find(match => match !== undefined);\n    return variableName;\n  }\n\n  containsTemplate(target) {\n    if (!target) {\n      return false;\n    }\n\n    const name = this.getVariableName(target);\n    const variable = name && this.getVariableAtIndex(name);\n    return variable !== null && variable !== undefined;\n  }\n\n  variableExists(expression) {\n    deprecationWarning('template_srv.ts', 'variableExists', 'containsTemplate');\n    return this.containsTemplate(expression);\n  }\n\n  highlightVariablesAsHtml(str) {\n    if (!str || !isString(str)) {\n      return str;\n    }\n\n    str = escape(str);\n    this.regex.lastIndex = 0;\n    return str.replace(this.regex, (match, var1, var2, fmt2, var3) => {\n      if (this.getVariableAtIndex(var1 || var2 || var3)) {\n        return '<span class=\"template-variable\">' + match + '</span>';\n      }\n\n      return match;\n    });\n  }\n\n  getAllValue(variable) {\n    if (variable.allValue) {\n      return variable.allValue;\n    }\n\n    const values = [];\n\n    for (let i = 1; i < variable.options.length; i++) {\n      values.push(variable.options[i].value);\n    }\n\n    return values;\n  }\n\n  getFieldAccessor(fieldPath) {\n    const accessor = this.fieldAccessorCache[fieldPath];\n\n    if (accessor) {\n      return accessor;\n    }\n\n    return this.fieldAccessorCache[fieldPath] = property(fieldPath);\n  }\n\n  getVariableValue(variableName, fieldPath, scopedVars) {\n    const scopedVar = scopedVars[variableName];\n\n    if (!scopedVar) {\n      return null;\n    }\n\n    if (fieldPath) {\n      return this.getFieldAccessor(fieldPath)(scopedVar.value);\n    }\n\n    return scopedVar.value;\n  }\n\n  getVariableText(variableName, value, scopedVars) {\n    const scopedVar = scopedVars[variableName];\n\n    if (!scopedVar) {\n      return null;\n    }\n\n    if (scopedVar.value === value || typeof value !== 'string') {\n      return scopedVar.text;\n    }\n\n    return value;\n  }\n\n  replace(target, scopedVars, format) {\n    if (!target) {\n      return target !== null && target !== void 0 ? target : '';\n    }\n\n    this.regex.lastIndex = 0;\n    return target.replace(this.regex, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {\n      const variableName = var1 || var2 || var3;\n      const variable = this.getVariableAtIndex(variableName);\n      const fmt = fmt2 || fmt3 || format;\n\n      if (scopedVars) {\n        const value = this.getVariableValue(variableName, fieldPath, scopedVars);\n        const text = this.getVariableText(variableName, value, scopedVars);\n\n        if (value !== null && value !== undefined) {\n          return this.formatValue(value, fmt, variable, text);\n        }\n      }\n\n      if (!variable) {\n        return match;\n      }\n\n      if (fmt === FormatRegistryID.queryParam || isAdHoc(variable)) {\n        const value = variableAdapters.get(variable.type).getValueForUrl(variable);\n        const text = isAdHoc(variable) ? variable.id : variable.current.text;\n        return this.formatValue(value, fmt, variable, text);\n      }\n\n      const systemValue = this.grafanaVariables[variable.current.value];\n\n      if (systemValue) {\n        return this.formatValue(systemValue, fmt, variable);\n      }\n\n      let value = variable.current.value;\n      let text = variable.current.text;\n\n      if (this.isAllValue(value)) {\n        value = this.getAllValue(variable);\n        text = ALL_VARIABLE_TEXT; // skip formatting of custom all values\n\n        if (variable.allValue && fmt !== FormatRegistryID.text) {\n          return this.replace(value);\n        }\n      }\n\n      if (fieldPath) {\n        const fieldValue = this.getVariableValue(variableName, fieldPath, {\n          [variableName]: {\n            value,\n            text\n          }\n        });\n\n        if (fieldValue !== null && fieldValue !== undefined) {\n          return this.formatValue(fieldValue, fmt, variable, text);\n        }\n      }\n\n      const res = this.formatValue(value, fmt, variable, text);\n      return res;\n    });\n  }\n\n  isAllValue(value) {\n    return value === ALL_VARIABLE_VALUE || Array.isArray(value) && value[0] === ALL_VARIABLE_VALUE;\n  }\n\n  replaceWithText(target, scopedVars) {\n    deprecationWarning('template_srv.ts', 'replaceWithText()', 'replace(), and specify the :text format');\n    return this.replace(target, scopedVars, 'text');\n  }\n\n  getVariableAtIndex(name) {\n    if (!name) {\n      return;\n    }\n\n    if (!this.index[name]) {\n      return this.dependencies.getVariableWithName(name);\n    }\n\n    return this.index[name];\n  }\n\n  getAdHocVariables() {\n    return this.dependencies.getFilteredVariables(isAdHoc);\n  }\n\n} // Expose the template srv\n\nconst srv = new TemplateSrv();\nsetTemplateSrv(srv);\nexport const getTemplateSrv = () => srv;","map":{"version":3,"names":["escape","isString","property","deprecationWarning","getDataSourceSrv","setTemplateSrv","variableAdapters","ALL_VARIABLE_TEXT","ALL_VARIABLE_VALUE","isAdHoc","getFilteredVariables","getVariables","getVariableWithName","variableRegex","formatRegistry","FormatRegistryID","runtimeDependencies","TemplateSrv","constructor","dependencies","_variables","init","variables","timeRange","updateIndex","existsOrEmpty","value","index","reduce","acc","currentValue","current","isNone","name","from","valueOf","toString","to","text","updateTimeRange","variableInitialized","variable","getAdhocFilters","datasourceName","filters","ds","getInstanceSettings","getAdHocVariables","variableUid","datasource","uid","concat","indexOf","replace","formatValue","format","undefined","queryParam","Array","isArray","glob","args","split","length","slice","formatItem","getIfExists","console","error","get","options","formatter","setGrafanaVariable","grafanaVariables","setGlobalVariable","getVariableName","expression","regex","lastIndex","match","exec","variableName","find","containsTemplate","target","getVariableAtIndex","variableExists","highlightVariablesAsHtml","str","var1","var2","fmt2","var3","getAllValue","allValue","values","i","push","getFieldAccessor","fieldPath","accessor","fieldAccessorCache","getVariableValue","scopedVars","scopedVar","getVariableText","fmt3","fmt","type","getValueForUrl","id","systemValue","isAllValue","fieldValue","res","replaceWithText","srv","getTemplateSrv"],"sources":["/home/soula/grafana/public/app/features/templating/template_srv.ts"],"sourcesContent":["import { escape, isString, property } from 'lodash';\n\nimport { deprecationWarning, ScopedVars, TimeRange } from '@grafana/data';\nimport { getDataSourceSrv, setTemplateSrv, TemplateSrv as BaseTemplateSrv } from '@grafana/runtime';\n\nimport { variableAdapters } from '../variables/adapters';\nimport { ALL_VARIABLE_TEXT, ALL_VARIABLE_VALUE } from '../variables/constants';\nimport { isAdHoc } from '../variables/guard';\nimport { getFilteredVariables, getVariables, getVariableWithName } from '../variables/state/selectors';\nimport { AdHocVariableFilter, AdHocVariableModel, VariableModel } from '../variables/types';\nimport { variableRegex } from '../variables/utils';\n\nimport { FormatOptions, formatRegistry, FormatRegistryID } from './formatRegistry';\n\ninterface FieldAccessorCache {\n  [key: string]: (obj: any) => any;\n}\n\nexport interface TemplateSrvDependencies {\n  getFilteredVariables: typeof getFilteredVariables;\n  getVariables: typeof getVariables;\n  getVariableWithName: typeof getVariableWithName;\n}\n\nconst runtimeDependencies: TemplateSrvDependencies = {\n  getFilteredVariables,\n  getVariables,\n  getVariableWithName,\n};\n\nexport class TemplateSrv implements BaseTemplateSrv {\n  private _variables: any[];\n  private regex = variableRegex;\n  private index: any = {};\n  private grafanaVariables: any = {};\n  private timeRange?: TimeRange | null = null;\n  private fieldAccessorCache: FieldAccessorCache = {};\n\n  constructor(private dependencies: TemplateSrvDependencies = runtimeDependencies) {\n    this._variables = [];\n  }\n\n  init(variables: any, timeRange?: TimeRange) {\n    this._variables = variables;\n    this.timeRange = timeRange;\n    this.updateIndex();\n  }\n\n  /**\n   * @deprecated: this instance variable should not be used and will be removed in future releases\n   *\n   * Use getVariables function instead\n   */\n  get variables(): any[] {\n    deprecationWarning('template_srv.ts', 'variables', 'getVariables');\n    return this.getVariables();\n  }\n\n  getVariables(): VariableModel[] {\n    return this.dependencies.getVariables();\n  }\n\n  updateIndex() {\n    const existsOrEmpty = (value: any) => value || value === '';\n\n    this.index = this._variables.reduce((acc, currentValue) => {\n      if (currentValue.current && (currentValue.current.isNone || existsOrEmpty(currentValue.current.value))) {\n        acc[currentValue.name] = currentValue;\n      }\n      return acc;\n    }, {});\n\n    if (this.timeRange) {\n      const from = this.timeRange.from.valueOf().toString();\n      const to = this.timeRange.to.valueOf().toString();\n\n      this.index = {\n        ...this.index,\n        ['__from']: {\n          current: { value: from, text: from },\n        },\n        ['__to']: {\n          current: { value: to, text: to },\n        },\n      };\n    }\n  }\n\n  updateTimeRange(timeRange: TimeRange) {\n    this.timeRange = timeRange;\n    this.updateIndex();\n  }\n\n  variableInitialized(variable: any) {\n    this.index[variable.name] = variable;\n  }\n\n  getAdhocFilters(datasourceName: string): AdHocVariableFilter[] {\n    let filters: any = [];\n    let ds = getDataSourceSrv().getInstanceSettings(datasourceName);\n\n    if (!ds) {\n      return [];\n    }\n\n    for (const variable of this.getAdHocVariables()) {\n      const variableUid = variable.datasource?.uid;\n\n      if (variableUid === ds.uid) {\n        filters = filters.concat(variable.filters);\n      } else if (variableUid?.indexOf('$') === 0) {\n        if (this.replace(variableUid) === datasourceName) {\n          filters = filters.concat(variable.filters);\n        }\n      }\n    }\n\n    return filters;\n  }\n\n  formatValue(value: any, format: any, variable: any, text?: string): string {\n    // for some scopedVars there is no variable\n    variable = variable || {};\n\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    if (isAdHoc(variable) && format !== FormatRegistryID.queryParam) {\n      return '';\n    }\n\n    // if it's an object transform value to string\n    if (!Array.isArray(value) && typeof value === 'object') {\n      value = `${value}`;\n    }\n\n    if (typeof format === 'function') {\n      return format(value, variable, this.formatValue);\n    }\n\n    if (!format) {\n      format = FormatRegistryID.glob;\n    }\n\n    // some formats have arguments that come after ':' character\n    let args = format.split(':');\n    if (args.length > 1) {\n      format = args[0];\n      args = args.slice(1);\n    } else {\n      args = [];\n    }\n\n    let formatItem = formatRegistry.getIfExists(format);\n\n    if (!formatItem) {\n      console.error(`Variable format ${format} not found. Using glob format as fallback.`);\n      formatItem = formatRegistry.get(FormatRegistryID.glob);\n    }\n\n    const options: FormatOptions = { value, args, text: text ?? value };\n    return formatItem.formatter(options, variable);\n  }\n\n  setGrafanaVariable(name: string, value: any) {\n    this.grafanaVariables[name] = value;\n  }\n\n  /**\n   * @deprecated: setGlobalVariable function should not be used and will be removed in future releases\n   *\n   * Use addVariable action to add variables to Redux instead\n   */\n  setGlobalVariable(name: string, variable: any) {\n    deprecationWarning('template_srv.ts', 'setGlobalVariable', '');\n    this.index = {\n      ...this.index,\n      [name]: {\n        current: variable,\n      },\n    };\n  }\n\n  getVariableName(expression: string) {\n    this.regex.lastIndex = 0;\n    const match = this.regex.exec(expression);\n    if (!match) {\n      return null;\n    }\n    const variableName = match.slice(1).find((match) => match !== undefined);\n    return variableName;\n  }\n\n  containsTemplate(target: string | undefined): boolean {\n    if (!target) {\n      return false;\n    }\n    const name = this.getVariableName(target);\n    const variable = name && this.getVariableAtIndex(name);\n    return variable !== null && variable !== undefined;\n  }\n\n  variableExists(expression: string): boolean {\n    deprecationWarning('template_srv.ts', 'variableExists', 'containsTemplate');\n    return this.containsTemplate(expression);\n  }\n\n  highlightVariablesAsHtml(str: string) {\n    if (!str || !isString(str)) {\n      return str;\n    }\n\n    str = escape(str);\n    this.regex.lastIndex = 0;\n    return str.replace(this.regex, (match, var1, var2, fmt2, var3) => {\n      if (this.getVariableAtIndex(var1 || var2 || var3)) {\n        return '<span class=\"template-variable\">' + match + '</span>';\n      }\n      return match;\n    });\n  }\n\n  getAllValue(variable: any) {\n    if (variable.allValue) {\n      return variable.allValue;\n    }\n    const values = [];\n    for (let i = 1; i < variable.options.length; i++) {\n      values.push(variable.options[i].value);\n    }\n    return values;\n  }\n\n  private getFieldAccessor(fieldPath: string) {\n    const accessor = this.fieldAccessorCache[fieldPath];\n    if (accessor) {\n      return accessor;\n    }\n\n    return (this.fieldAccessorCache[fieldPath] = property(fieldPath));\n  }\n\n  private getVariableValue(variableName: string, fieldPath: string | undefined, scopedVars: ScopedVars) {\n    const scopedVar = scopedVars[variableName];\n    if (!scopedVar) {\n      return null;\n    }\n\n    if (fieldPath) {\n      return this.getFieldAccessor(fieldPath)(scopedVar.value);\n    }\n\n    return scopedVar.value;\n  }\n\n  private getVariableText(variableName: string, value: any, scopedVars: ScopedVars) {\n    const scopedVar = scopedVars[variableName];\n\n    if (!scopedVar) {\n      return null;\n    }\n\n    if (scopedVar.value === value || typeof value !== 'string') {\n      return scopedVar.text;\n    }\n\n    return value;\n  }\n\n  replace(target?: string, scopedVars?: ScopedVars, format?: string | Function): string {\n    if (!target) {\n      return target ?? '';\n    }\n\n    this.regex.lastIndex = 0;\n\n    return target.replace(this.regex, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {\n      const variableName = var1 || var2 || var3;\n      const variable = this.getVariableAtIndex(variableName);\n      const fmt = fmt2 || fmt3 || format;\n\n      if (scopedVars) {\n        const value = this.getVariableValue(variableName, fieldPath, scopedVars);\n        const text = this.getVariableText(variableName, value, scopedVars);\n\n        if (value !== null && value !== undefined) {\n          return this.formatValue(value, fmt, variable, text);\n        }\n      }\n\n      if (!variable) {\n        return match;\n      }\n\n      if (fmt === FormatRegistryID.queryParam || isAdHoc(variable)) {\n        const value = variableAdapters.get(variable.type).getValueForUrl(variable);\n        const text = isAdHoc(variable) ? variable.id : variable.current.text;\n\n        return this.formatValue(value, fmt, variable, text);\n      }\n\n      const systemValue = this.grafanaVariables[variable.current.value];\n      if (systemValue) {\n        return this.formatValue(systemValue, fmt, variable);\n      }\n\n      let value = variable.current.value;\n      let text = variable.current.text;\n\n      if (this.isAllValue(value)) {\n        value = this.getAllValue(variable);\n        text = ALL_VARIABLE_TEXT;\n        // skip formatting of custom all values\n        if (variable.allValue && fmt !== FormatRegistryID.text) {\n          return this.replace(value);\n        }\n      }\n\n      if (fieldPath) {\n        const fieldValue = this.getVariableValue(variableName, fieldPath, {\n          [variableName]: { value, text },\n        });\n        if (fieldValue !== null && fieldValue !== undefined) {\n          return this.formatValue(fieldValue, fmt, variable, text);\n        }\n      }\n\n      const res = this.formatValue(value, fmt, variable, text);\n      return res;\n    });\n  }\n\n  isAllValue(value: any) {\n    return value === ALL_VARIABLE_VALUE || (Array.isArray(value) && value[0] === ALL_VARIABLE_VALUE);\n  }\n\n  replaceWithText(target: string, scopedVars?: ScopedVars) {\n    deprecationWarning('template_srv.ts', 'replaceWithText()', 'replace(), and specify the :text format');\n    return this.replace(target, scopedVars, 'text');\n  }\n\n  private getVariableAtIndex(name: string) {\n    if (!name) {\n      return;\n    }\n\n    if (!this.index[name]) {\n      return this.dependencies.getVariableWithName(name);\n    }\n\n    return this.index[name];\n  }\n\n  private getAdHocVariables(): AdHocVariableModel[] {\n    return this.dependencies.getFilteredVariables(isAdHoc) as AdHocVariableModel[];\n  }\n}\n\n// Expose the template srv\nconst srv = new TemplateSrv();\n\nsetTemplateSrv(srv);\n\nexport const getTemplateSrv = () => srv;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}