{"ast":null,"code":"import { lastValueFrom } from 'rxjs';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { RULER_NOT_SUPPORTED_MSG } from '../utils/constants';\nimport { getDatasourceAPIUid, GRAFANA_RULES_SOURCE_NAME } from '../utils/datasource';\nimport { prepareRulesFilterQueryParams } from './prometheus';\nexport function rulerUrlBuilder(rulerConfig) {\n  const grafanaServerPath = `/api/ruler/${getDatasourceAPIUid(rulerConfig.dataSourceName)}`;\n  const rulerPath = `${grafanaServerPath}/api/v1/rules`;\n  const rulerSearchParams = new URLSearchParams();\n  rulerSearchParams.set('subtype', rulerConfig.apiVersion === 'legacy' ? 'cortex' : 'mimir');\n  return {\n    rules: filter => {\n      const params = prepareRulesFilterQueryParams(rulerSearchParams, filter);\n      return {\n        path: `${rulerPath}`,\n        params: params\n      };\n    },\n    namespace: namespace => ({\n      path: `${rulerPath}/${encodeURIComponent(namespace)}`,\n      params: Object.fromEntries(rulerSearchParams)\n    }),\n    namespaceGroup: (namespace, group) => ({\n      path: `${rulerPath}/${encodeURIComponent(namespace)}/${encodeURIComponent(group)}`,\n      params: Object.fromEntries(rulerSearchParams)\n    })\n  };\n} // upsert a rule group. use this to update rule\n\nexport async function setRulerRuleGroup(rulerConfig, namespace, group) {\n  const {\n    path,\n    params\n  } = rulerUrlBuilder(rulerConfig).namespace(namespace);\n  await lastValueFrom(getBackendSrv().fetch({\n    method: 'POST',\n    url: path,\n    data: group,\n    showErrorAlert: false,\n    showSuccessAlert: false,\n    params\n  }));\n}\n// fetch all ruler rule namespaces and included groups\nexport async function fetchRulerRules(rulerConfig, filter) {\n  if (filter !== null && filter !== void 0 && filter.dashboardUID && rulerConfig.dataSourceName !== GRAFANA_RULES_SOURCE_NAME) {\n    throw new Error('Filtering by dashboard UID is only supported by Grafana.');\n  } // TODO Move params creation to the rules function\n\n\n  const {\n    path: url,\n    params\n  } = rulerUrlBuilder(rulerConfig).rules(filter);\n  return rulerGetRequest(url, {}, params);\n} // fetch rule groups for a particular namespace\n// will throw with { status: 404 } if namespace does not exist\n\nexport async function fetchRulerRulesNamespace(rulerConfig, namespace) {\n  const {\n    path,\n    params\n  } = rulerUrlBuilder(rulerConfig).namespace(namespace);\n  const result = await rulerGetRequest(path, {}, params);\n  return result[namespace] || [];\n} // fetch a particular rule group\n// will throw with { status: 404 } if rule group does not exist\n\nexport async function fetchTestRulerRulesGroup(dataSourceName) {\n  return rulerGetRequest(`/api/ruler/${getDatasourceAPIUid(dataSourceName)}/api/v1/rules/test/test`, null);\n}\nexport async function fetchRulerRulesGroup(rulerConfig, namespace, group) {\n  const {\n    path,\n    params\n  } = rulerUrlBuilder(rulerConfig).namespaceGroup(namespace, group);\n  return rulerGetRequest(path, null, params);\n}\nexport async function deleteRulerRulesGroup(rulerConfig, namespace, groupName) {\n  const {\n    path,\n    params\n  } = rulerUrlBuilder(rulerConfig).namespaceGroup(namespace, groupName);\n  await lastValueFrom(getBackendSrv().fetch({\n    url: path,\n    method: 'DELETE',\n    showSuccessAlert: false,\n    showErrorAlert: false,\n    params\n  }));\n} // false in case ruler is not supported. this is weird, but we'll work on it\n\nasync function rulerGetRequest(url, empty, params) {\n  try {\n    const response = await lastValueFrom(getBackendSrv().fetch({\n      url,\n      showErrorAlert: false,\n      showSuccessAlert: false,\n      params\n    }));\n    return response.data;\n  } catch (error) {\n    if (!isResponseError(error)) {\n      throw error;\n    }\n\n    if (isCortexErrorResponse(error)) {\n      return empty;\n    } else if (isRulerNotSupported(error)) {\n      // assert if the endoint is not supported at all\n      throw Object.assign({}, error, {\n        data: Object.assign({}, error.data, {\n          message: RULER_NOT_SUPPORTED_MSG\n        })\n      });\n    }\n\n    throw error;\n  }\n}\n\nfunction isResponseError(error) {\n  const hasErrorMessage = error.data != null;\n  const hasErrorCode = Number.isFinite(error.status);\n  return hasErrorCode && hasErrorMessage;\n}\n\nfunction isRulerNotSupported(error) {\n  var _error$data$message;\n\n  return error.status === 404 || error.status === 500 && ((_error$data$message = error.data.message) === null || _error$data$message === void 0 ? void 0 : _error$data$message.includes('unexpected content type from upstream. expected YAML, got text/html'));\n}\n\nfunction isCortexErrorResponse(error) {\n  var _error$data$message2, _error$data$message3;\n\n  return error.status === 404 && (((_error$data$message2 = error.data.message) === null || _error$data$message2 === void 0 ? void 0 : _error$data$message2.includes('group does not exist')) || ((_error$data$message3 = error.data.message) === null || _error$data$message3 === void 0 ? void 0 : _error$data$message3.includes('no rule groups found')));\n}\n\nexport async function deleteNamespace(rulerConfig, namespace) {\n  const {\n    path,\n    params\n  } = rulerUrlBuilder(rulerConfig).namespace(namespace);\n  await lastValueFrom(getBackendSrv().fetch({\n    method: 'DELETE',\n    url: path,\n    showErrorAlert: false,\n    showSuccessAlert: false,\n    params\n  }));\n}","map":{"version":3,"names":["lastValueFrom","getBackendSrv","RULER_NOT_SUPPORTED_MSG","getDatasourceAPIUid","GRAFANA_RULES_SOURCE_NAME","prepareRulesFilterQueryParams","rulerUrlBuilder","rulerConfig","grafanaServerPath","dataSourceName","rulerPath","rulerSearchParams","URLSearchParams","set","apiVersion","rules","filter","params","path","namespace","encodeURIComponent","Object","fromEntries","namespaceGroup","group","setRulerRuleGroup","fetch","method","url","data","showErrorAlert","showSuccessAlert","fetchRulerRules","dashboardUID","Error","rulerGetRequest","fetchRulerRulesNamespace","result","fetchTestRulerRulesGroup","fetchRulerRulesGroup","deleteRulerRulesGroup","groupName","empty","response","error","isResponseError","isCortexErrorResponse","isRulerNotSupported","message","hasErrorMessage","hasErrorCode","Number","isFinite","status","includes","deleteNamespace"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/api/ruler.ts"],"sourcesContent":["import { lastValueFrom } from 'rxjs';\n\nimport { FetchResponse, getBackendSrv } from '@grafana/runtime';\nimport { RulerDataSourceConfig } from 'app/types/unified-alerting';\nimport { PostableRulerRuleGroupDTO, RulerRuleGroupDTO, RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\n\nimport { RULER_NOT_SUPPORTED_MSG } from '../utils/constants';\nimport { getDatasourceAPIUid, GRAFANA_RULES_SOURCE_NAME } from '../utils/datasource';\n\nimport { prepareRulesFilterQueryParams } from './prometheus';\n\ninterface ErrorResponseMessage {\n  message?: string;\n  error?: string;\n}\n\nexport interface RulerRequestUrl {\n  path: string;\n  params?: Record<string, string>;\n}\n\nexport function rulerUrlBuilder(rulerConfig: RulerDataSourceConfig) {\n  const grafanaServerPath = `/api/ruler/${getDatasourceAPIUid(rulerConfig.dataSourceName)}`;\n\n  const rulerPath = `${grafanaServerPath}/api/v1/rules`;\n  const rulerSearchParams = new URLSearchParams();\n\n  rulerSearchParams.set('subtype', rulerConfig.apiVersion === 'legacy' ? 'cortex' : 'mimir');\n\n  return {\n    rules: (filter?: FetchRulerRulesFilter): RulerRequestUrl => {\n      const params = prepareRulesFilterQueryParams(rulerSearchParams, filter);\n\n      return {\n        path: `${rulerPath}`,\n        params: params,\n      };\n    },\n    namespace: (namespace: string): RulerRequestUrl => ({\n      path: `${rulerPath}/${encodeURIComponent(namespace)}`,\n      params: Object.fromEntries(rulerSearchParams),\n    }),\n    namespaceGroup: (namespace: string, group: string): RulerRequestUrl => ({\n      path: `${rulerPath}/${encodeURIComponent(namespace)}/${encodeURIComponent(group)}`,\n      params: Object.fromEntries(rulerSearchParams),\n    }),\n  };\n}\n\n// upsert a rule group. use this to update rule\nexport async function setRulerRuleGroup(\n  rulerConfig: RulerDataSourceConfig,\n  namespace: string,\n  group: PostableRulerRuleGroupDTO\n): Promise<void> {\n  const { path, params } = rulerUrlBuilder(rulerConfig).namespace(namespace);\n  await lastValueFrom(\n    getBackendSrv().fetch<unknown>({\n      method: 'POST',\n      url: path,\n      data: group,\n      showErrorAlert: false,\n      showSuccessAlert: false,\n      params,\n    })\n  );\n}\n\nexport interface FetchRulerRulesFilter {\n  dashboardUID: string;\n  panelId?: number;\n}\n\n// fetch all ruler rule namespaces and included groups\nexport async function fetchRulerRules(rulerConfig: RulerDataSourceConfig, filter?: FetchRulerRulesFilter) {\n  if (filter?.dashboardUID && rulerConfig.dataSourceName !== GRAFANA_RULES_SOURCE_NAME) {\n    throw new Error('Filtering by dashboard UID is only supported by Grafana.');\n  }\n\n  // TODO Move params creation to the rules function\n  const { path: url, params } = rulerUrlBuilder(rulerConfig).rules(filter);\n  return rulerGetRequest<RulerRulesConfigDTO>(url, {}, params);\n}\n\n// fetch rule groups for a particular namespace\n// will throw with { status: 404 } if namespace does not exist\nexport async function fetchRulerRulesNamespace(rulerConfig: RulerDataSourceConfig, namespace: string) {\n  const { path, params } = rulerUrlBuilder(rulerConfig).namespace(namespace);\n  const result = await rulerGetRequest<Record<string, RulerRuleGroupDTO[]>>(path, {}, params);\n  return result[namespace] || [];\n}\n\n// fetch a particular rule group\n// will throw with { status: 404 } if rule group does not exist\nexport async function fetchTestRulerRulesGroup(dataSourceName: string): Promise<RulerRuleGroupDTO | null> {\n  return rulerGetRequest<RulerRuleGroupDTO | null>(\n    `/api/ruler/${getDatasourceAPIUid(dataSourceName)}/api/v1/rules/test/test`,\n    null\n  );\n}\n\nexport async function fetchRulerRulesGroup(\n  rulerConfig: RulerDataSourceConfig,\n  namespace: string,\n  group: string\n): Promise<RulerRuleGroupDTO | null> {\n  const { path, params } = rulerUrlBuilder(rulerConfig).namespaceGroup(namespace, group);\n  return rulerGetRequest<RulerRuleGroupDTO | null>(path, null, params);\n}\n\nexport async function deleteRulerRulesGroup(rulerConfig: RulerDataSourceConfig, namespace: string, groupName: string) {\n  const { path, params } = rulerUrlBuilder(rulerConfig).namespaceGroup(namespace, groupName);\n  await lastValueFrom(\n    getBackendSrv().fetch({\n      url: path,\n      method: 'DELETE',\n      showSuccessAlert: false,\n      showErrorAlert: false,\n      params,\n    })\n  );\n}\n\n// false in case ruler is not supported. this is weird, but we'll work on it\nasync function rulerGetRequest<T>(url: string, empty: T, params?: Record<string, string>): Promise<T> {\n  try {\n    const response = await lastValueFrom(\n      getBackendSrv().fetch<T>({\n        url,\n        showErrorAlert: false,\n        showSuccessAlert: false,\n        params,\n      })\n    );\n    return response.data;\n  } catch (error) {\n    if (!isResponseError(error)) {\n      throw error;\n    }\n\n    if (isCortexErrorResponse(error)) {\n      return empty;\n    } else if (isRulerNotSupported(error)) {\n      // assert if the endoint is not supported at all\n      throw {\n        ...error,\n        data: {\n          ...error.data,\n          message: RULER_NOT_SUPPORTED_MSG,\n        },\n      };\n    }\n    throw error;\n  }\n}\n\nfunction isResponseError(error: unknown): error is FetchResponse<ErrorResponseMessage> {\n  const hasErrorMessage = (error as FetchResponse<ErrorResponseMessage>).data != null;\n  const hasErrorCode = Number.isFinite((error as FetchResponse<ErrorResponseMessage>).status);\n  return hasErrorCode && hasErrorMessage;\n}\n\nfunction isRulerNotSupported(error: FetchResponse<ErrorResponseMessage>) {\n  return (\n    error.status === 404 ||\n    (error.status === 500 &&\n      error.data.message?.includes('unexpected content type from upstream. expected YAML, got text/html'))\n  );\n}\n\nfunction isCortexErrorResponse(error: FetchResponse<ErrorResponseMessage>) {\n  return (\n    error.status === 404 &&\n    (error.data.message?.includes('group does not exist') || error.data.message?.includes('no rule groups found'))\n  );\n}\n\nexport async function deleteNamespace(rulerConfig: RulerDataSourceConfig, namespace: string): Promise<void> {\n  const { path, params } = rulerUrlBuilder(rulerConfig).namespace(namespace);\n  await lastValueFrom(\n    getBackendSrv().fetch<unknown>({\n      method: 'DELETE',\n      url: path,\n      showErrorAlert: false,\n      showSuccessAlert: false,\n      params,\n    })\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}