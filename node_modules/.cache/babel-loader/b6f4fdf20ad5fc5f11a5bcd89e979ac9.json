{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { ArrayVector, DataTransformerID, FieldMatcherID, getFieldDisplayName, getFieldMatcher, reduceField } from '@grafana/data';\nimport { getFieldConfigFromFrame, evaluteFieldMappings } from '../fieldToConfigMapping/fieldToConfigMapping';\nexport function extractConfigFromQuery(options, data) {\n  var _options$mappings;\n\n  let configFrame = null;\n\n  for (const frame of data) {\n    if (frame.refId === options.configRefId) {\n      configFrame = frame;\n      break;\n    }\n  }\n\n  if (!configFrame) {\n    return data;\n  }\n\n  const reducedConfigFrame = {\n    fields: [],\n    length: 1\n  };\n  const mappingResult = evaluteFieldMappings(configFrame, (_options$mappings = options.mappings) !== null && _options$mappings !== void 0 ? _options$mappings : [], false); // reduce config frame\n\n  for (const field of configFrame.fields) {\n    const newField = Object.assign({}, field);\n    const fieldName = getFieldDisplayName(field, configFrame);\n    const fieldMapping = mappingResult.index[fieldName];\n    const result = reduceField({\n      field,\n      reducers: [fieldMapping.reducerId]\n    });\n    newField.values = new ArrayVector([result[fieldMapping.reducerId]]);\n    reducedConfigFrame.fields.push(newField);\n  }\n\n  const output = [];\n  const matcher = getFieldMatcher(options.applyTo || {\n    id: FieldMatcherID.numeric\n  });\n\n  for (const frame of data) {\n    // Skip config frame in output\n    if (frame === configFrame && data.length > 1) {\n      continue;\n    }\n\n    const outputFrame = {\n      fields: [],\n      length: frame.length\n    };\n\n    for (const field of frame.fields) {\n      if (matcher(field, frame, data)) {\n        const dataConfig = getFieldConfigFromFrame(reducedConfigFrame, 0, mappingResult);\n        outputFrame.fields.push(Object.assign({}, field, {\n          config: Object.assign({}, field.config, dataConfig)\n        }));\n      } else {\n        outputFrame.fields.push(field);\n      }\n    }\n\n    output.push(outputFrame);\n  }\n\n  return output;\n}\nexport const configFromDataTransformer = {\n  id: DataTransformerID.configFromData,\n  name: 'Config from query results',\n  description: 'Set unit, min, max and more from data',\n  defaultOptions: {\n    configRefId: 'config',\n    mappings: []\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: options => source => source.pipe(map(data => extractConfigFromQuery(options, data)))\n};","map":{"version":3,"names":["map","ArrayVector","DataTransformerID","FieldMatcherID","getFieldDisplayName","getFieldMatcher","reduceField","getFieldConfigFromFrame","evaluteFieldMappings","extractConfigFromQuery","options","data","configFrame","frame","refId","configRefId","reducedConfigFrame","fields","length","mappingResult","mappings","field","newField","fieldName","fieldMapping","index","result","reducers","reducerId","values","push","output","matcher","applyTo","id","numeric","outputFrame","dataConfig","config","configFromDataTransformer","configFromData","name","description","defaultOptions","operator","source","pipe"],"sources":["/home/soula/grafana/public/app/features/transformers/configFromQuery/configFromQuery.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport {\n  ArrayVector,\n  DataFrame,\n  DataTransformerID,\n  DataTransformerInfo,\n  FieldMatcherID,\n  getFieldDisplayName,\n  getFieldMatcher,\n  MatcherConfig,\n  reduceField,\n} from '@grafana/data';\n\nimport {\n  getFieldConfigFromFrame,\n  FieldToConfigMapping,\n  evaluteFieldMappings,\n} from '../fieldToConfigMapping/fieldToConfigMapping';\n\nexport interface ConfigFromQueryTransformOptions {\n  configRefId?: string;\n  mappings: FieldToConfigMapping[];\n  applyTo?: MatcherConfig;\n}\n\nexport function extractConfigFromQuery(options: ConfigFromQueryTransformOptions, data: DataFrame[]) {\n  let configFrame: DataFrame | null = null;\n\n  for (const frame of data) {\n    if (frame.refId === options.configRefId) {\n      configFrame = frame;\n      break;\n    }\n  }\n\n  if (!configFrame) {\n    return data;\n  }\n\n  const reducedConfigFrame: DataFrame = {\n    fields: [],\n    length: 1,\n  };\n\n  const mappingResult = evaluteFieldMappings(configFrame, options.mappings ?? [], false);\n\n  // reduce config frame\n  for (const field of configFrame.fields) {\n    const newField = { ...field };\n    const fieldName = getFieldDisplayName(field, configFrame);\n    const fieldMapping = mappingResult.index[fieldName];\n    const result = reduceField({ field, reducers: [fieldMapping.reducerId] });\n    newField.values = new ArrayVector([result[fieldMapping.reducerId]]);\n    reducedConfigFrame.fields.push(newField);\n  }\n\n  const output: DataFrame[] = [];\n  const matcher = getFieldMatcher(options.applyTo || { id: FieldMatcherID.numeric });\n\n  for (const frame of data) {\n    // Skip config frame in output\n    if (frame === configFrame && data.length > 1) {\n      continue;\n    }\n\n    const outputFrame: DataFrame = {\n      fields: [],\n      length: frame.length,\n    };\n\n    for (const field of frame.fields) {\n      if (matcher(field, frame, data)) {\n        const dataConfig = getFieldConfigFromFrame(reducedConfigFrame, 0, mappingResult);\n        outputFrame.fields.push({\n          ...field,\n          config: {\n            ...field.config,\n            ...dataConfig,\n          },\n        });\n      } else {\n        outputFrame.fields.push(field);\n      }\n    }\n\n    output.push(outputFrame);\n  }\n\n  return output;\n}\n\nexport const configFromDataTransformer: DataTransformerInfo<ConfigFromQueryTransformOptions> = {\n  id: DataTransformerID.configFromData,\n  name: 'Config from query results',\n  description: 'Set unit, min, max and more from data',\n  defaultOptions: {\n    configRefId: 'config',\n    mappings: [],\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) => source.pipe(map((data) => extractConfigFromQuery(options, data))),\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}