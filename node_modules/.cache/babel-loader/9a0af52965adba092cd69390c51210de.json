{"ast":null,"code":"const _excluded = [\"fields\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { SortedVector } from '@grafana/data';\n\n// creates the `index` for the sorting.\n// this is needed by the `SortedVector`.\n// the index is an array of numbers, and it defines an order.\n// at every slot in the index the values is the position of\n// the sorted item.\n// for example, an index of [3,1,2] means that\n// in the dataframe, that has 3 rows, after sorting:\n// - the third row will become the first\n// - the first row will become the second\n// - the second row will become the third\nfunction makeIndex(field, dir) {\n  const fieldValues = field.values.toArray(); // we first build an array which is [0,1,2,3....]\n\n  const index = Array(fieldValues.length);\n\n  for (let i = 0; i < index.length; i++) {\n    index[i] = i;\n  }\n\n  const isAsc = dir === 'ASCENDING';\n  index.sort((a, b) => {\n    // we need to answer this question:\n    // in the field-used-for-sorting, how would we compare value-at-index-a to value-at-index-b?\n    const valA = fieldValues[a];\n    const valB = fieldValues[b];\n\n    if (valA < valB) {\n      return isAsc ? -1 : 1;\n    }\n\n    if (valA > valB) {\n      return isAsc ? 1 : -1;\n    }\n\n    return 0;\n  });\n  return index;\n} // sort a dataframe that is in the Loki format ascending or descending,\n// based on the nanosecond-timestamp\n\n\nexport function sortDataFrameByTime(frame, dir) {\n  const {\n    fields\n  } = frame,\n        rest = _objectWithoutPropertiesLoose(frame, _excluded); // we use the approach used in @grafana/data/sortDataframe.\n  // we cannot use it directly, because our tsNs field has a type=time,\n  // so we have to build the `index` manually.\n\n\n  const tsNsField = fields.find(field => field.name === 'tsNs');\n\n  if (tsNsField === undefined) {\n    throw new Error('missing nanosecond-timestamp field. should never happen');\n  }\n\n  const index = makeIndex(tsNsField, dir);\n  return Object.assign({}, rest, {\n    fields: fields.map(field => Object.assign({}, field, {\n      values: new SortedVector(field.values, index)\n    }))\n  });\n  return frame;\n}","map":{"version":3,"names":["SortedVector","makeIndex","field","dir","fieldValues","values","toArray","index","Array","length","i","isAsc","sort","a","b","valA","valB","sortDataFrameByTime","frame","fields","rest","tsNsField","find","name","undefined","Error","map"],"sources":["/home/soula/grafana/public/app/plugins/datasource/loki/sortDataFrame.ts"],"sourcesContent":["import { DataFrame, Field, SortedVector } from '@grafana/data';\n\ntype SortDirection = 'ASCENDING' | 'DESCENDING';\n\n// creates the `index` for the sorting.\n// this is needed by the `SortedVector`.\n// the index is an array of numbers, and it defines an order.\n// at every slot in the index the values is the position of\n// the sorted item.\n// for example, an index of [3,1,2] means that\n// in the dataframe, that has 3 rows, after sorting:\n// - the third row will become the first\n// - the first row will become the second\n// - the second row will become the third\nfunction makeIndex(field: Field<string>, dir: SortDirection): number[] {\n  const fieldValues: string[] = field.values.toArray();\n\n  // we first build an array which is [0,1,2,3....]\n  const index = Array(fieldValues.length);\n  for (let i = 0; i < index.length; i++) {\n    index[i] = i;\n  }\n\n  const isAsc = dir === 'ASCENDING';\n\n  index.sort((a: number, b: number): number => {\n    // we need to answer this question:\n    // in the field-used-for-sorting, how would we compare value-at-index-a to value-at-index-b?\n    const valA = fieldValues[a];\n    const valB = fieldValues[b];\n    if (valA < valB) {\n      return isAsc ? -1 : 1;\n    }\n\n    if (valA > valB) {\n      return isAsc ? 1 : -1;\n    }\n\n    return 0;\n  });\n\n  return index;\n}\n\n// sort a dataframe that is in the Loki format ascending or descending,\n// based on the nanosecond-timestamp\nexport function sortDataFrameByTime(frame: DataFrame, dir: SortDirection): DataFrame {\n  const { fields, ...rest } = frame;\n\n  // we use the approach used in @grafana/data/sortDataframe.\n  // we cannot use it directly, because our tsNs field has a type=time,\n  // so we have to build the `index` manually.\n\n  const tsNsField = fields.find((field) => field.name === 'tsNs');\n  if (tsNsField === undefined) {\n    throw new Error('missing nanosecond-timestamp field. should never happen');\n  }\n\n  const index = makeIndex(tsNsField, dir);\n\n  return {\n    ...rest,\n    fields: fields.map((field) => ({\n      ...field,\n      values: new SortedVector(field.values, index),\n    })),\n  };\n\n  return frame;\n}\n"],"mappings":";;;;AAAA,SAA2BA,YAA3B,QAA+C,eAA/C;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAAT,CAAmBC,KAAnB,EAAyCC,GAAzC,EAAuE;EACrE,MAAMC,WAAqB,GAAGF,KAAK,CAACG,MAAN,CAAaC,OAAb,EAA9B,CADqE,CAGrE;;EACA,MAAMC,KAAK,GAAGC,KAAK,CAACJ,WAAW,CAACK,MAAb,CAAnB;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACE,MAA1B,EAAkCC,CAAC,EAAnC,EAAuC;IACrCH,KAAK,CAACG,CAAD,CAAL,GAAWA,CAAX;EACD;;EAED,MAAMC,KAAK,GAAGR,GAAG,KAAK,WAAtB;EAEAI,KAAK,CAACK,IAAN,CAAW,CAACC,CAAD,EAAYC,CAAZ,KAAkC;IAC3C;IACA;IACA,MAAMC,IAAI,GAAGX,WAAW,CAACS,CAAD,CAAxB;IACA,MAAMG,IAAI,GAAGZ,WAAW,CAACU,CAAD,CAAxB;;IACA,IAAIC,IAAI,GAAGC,IAAX,EAAiB;MACf,OAAOL,KAAK,GAAG,CAAC,CAAJ,GAAQ,CAApB;IACD;;IAED,IAAII,IAAI,GAAGC,IAAX,EAAiB;MACf,OAAOL,KAAK,GAAG,CAAH,GAAO,CAAC,CAApB;IACD;;IAED,OAAO,CAAP;EACD,CAdD;EAgBA,OAAOJ,KAAP;AACD,C,CAED;AACA;;;AACA,OAAO,SAASU,mBAAT,CAA6BC,KAA7B,EAA+Cf,GAA/C,EAA8E;EACnF,MAAM;IAAEgB;EAAF,IAAsBD,KAA5B;EAAA,MAAmBE,IAAnB,iCAA4BF,KAA5B,aADmF,CAGnF;EACA;EACA;;;EAEA,MAAMG,SAAS,GAAGF,MAAM,CAACG,IAAP,CAAapB,KAAD,IAAWA,KAAK,CAACqB,IAAN,KAAe,MAAtC,CAAlB;;EACA,IAAIF,SAAS,KAAKG,SAAlB,EAA6B;IAC3B,MAAM,IAAIC,KAAJ,CAAU,yDAAV,CAAN;EACD;;EAED,MAAMlB,KAAK,GAAGN,SAAS,CAACoB,SAAD,EAAYlB,GAAZ,CAAvB;EAEA,yBACKiB,IADL;IAEED,MAAM,EAAEA,MAAM,CAACO,GAAP,CAAYxB,KAAD,sBACdA,KADc;MAEjBG,MAAM,EAAE,IAAIL,YAAJ,CAAiBE,KAAK,CAACG,MAAvB,EAA+BE,KAA/B;IAFS,EAAX;EAFV;EAQA,OAAOW,KAAP;AACD"},"metadata":{},"sourceType":"module"}