{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst MAX_OBJECTS = 10;\nconst MAX_LEVELS = 4;\n\n/**\n * @internal\n */\nexport function pointWithin(px, py, rlft, rtop, rrgt, rbtm) {\n  return px >= rlft && px <= rrgt && py >= rtop && py <= rbtm;\n}\n/**\n * @internal\n *\n * Determines if r2 is intersected by r1.\n */\n\nexport function intersects(r1, r2) {\n  return r1.x <= r2.x + r2.w && r1.x + r1.w >= r2.x && r1.y + r1.h >= r2.y && r1.y <= r2.y + r2.h;\n}\n/**\n * @internal\n */\n\nexport class Quadtree {\n  constructor(x, y, w, h, l = 0) {\n    _defineProperty(this, \"o\", void 0);\n\n    _defineProperty(this, \"q\", void 0);\n\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n    this.l = l;\n    this.o = [];\n    this.q = null;\n  }\n\n  split() {\n    let t = this,\n        x = t.x,\n        y = t.y,\n        w = t.w / 2,\n        h = t.h / 2,\n        l = t.l + 1;\n    t.q = [// top right\n    new Quadtree(x + w, y, w, h, l), // top left\n    new Quadtree(x, y, w, h, l), // bottom left\n    new Quadtree(x, y + h, w, h, l), // bottom right\n    new Quadtree(x + w, y + h, w, h, l)];\n  } // invokes callback with index of each overlapping quad\n\n\n  quads(x, y, w, h, cb) {\n    let t = this,\n        q = t.q,\n        hzMid = t.x + t.w / 2,\n        vtMid = t.y + t.h / 2,\n        startIsNorth = y < vtMid,\n        startIsWest = x < hzMid,\n        endIsEast = x + w > hzMid,\n        endIsSouth = y + h > vtMid; // top-right quad\n\n    startIsNorth && endIsEast && cb(q[0]); // top-left quad\n\n    startIsWest && startIsNorth && cb(q[1]); // bottom-left quad\n\n    startIsWest && endIsSouth && cb(q[2]); // bottom-right quad\n\n    endIsEast && endIsSouth && cb(q[3]);\n  }\n\n  add(o) {\n    let t = this;\n\n    if (t.q != null) {\n      t.quads(o.x, o.y, o.w, o.h, q => {\n        q.add(o);\n      });\n    } else {\n      let os = t.o;\n      os.push(o);\n\n      if (os.length > MAX_OBJECTS && t.l < MAX_LEVELS) {\n        t.split();\n\n        for (let i = 0; i < os.length; i++) {\n          let oi = os[i];\n          t.quads(oi.x, oi.y, oi.w, oi.h, q => {\n            q.add(oi);\n          });\n        }\n\n        t.o.length = 0;\n      }\n    }\n  }\n\n  get(x, y, w, h, cb) {\n    let t = this;\n    let os = t.o;\n\n    for (let i = 0; i < os.length; i++) {\n      cb(os[i]);\n    }\n\n    if (t.q != null) {\n      t.quads(x, y, w, h, q => {\n        q.get(x, y, w, h, cb);\n      });\n    }\n  }\n\n  clear() {\n    this.o.length = 0;\n    this.q = null;\n  }\n\n}","map":{"version":3,"names":["MAX_OBJECTS","MAX_LEVELS","pointWithin","px","py","rlft","rtop","rrgt","rbtm","intersects","r1","r2","x","w","y","h","Quadtree","constructor","l","o","q","split","t","quads","cb","hzMid","vtMid","startIsNorth","startIsWest","endIsEast","endIsSouth","add","os","push","length","i","oi","get","clear"],"sources":["/home/soula/grafana/public/app/plugins/panel/barchart/quadtree.ts"],"sourcesContent":["const MAX_OBJECTS = 10;\nconst MAX_LEVELS = 4;\n\nexport type Quads = [Quadtree, Quadtree, Quadtree, Quadtree];\nexport type Rect = { x: number; y: number; w: number; h: number; [_: string]: any };\n\n/**\n * @internal\n */\nexport function pointWithin(px: number, py: number, rlft: number, rtop: number, rrgt: number, rbtm: number) {\n  return px >= rlft && px <= rrgt && py >= rtop && py <= rbtm;\n}\n\n/**\n * @internal\n *\n * Determines if r2 is intersected by r1.\n */\nexport function intersects(r1: Rect, r2: Rect) {\n  return r1.x <= r2.x + r2.w && r1.x + r1.w >= r2.x && r1.y + r1.h >= r2.y && r1.y <= r2.y + r2.h;\n}\n\n/**\n * @internal\n */\nexport class Quadtree {\n  o: Rect[];\n  q: Quads | null;\n\n  constructor(public x: number, public y: number, public w: number, public h: number, public l: number = 0) {\n    this.o = [];\n    this.q = null;\n  }\n\n  split() {\n    let t = this,\n      x = t.x,\n      y = t.y,\n      w = t.w / 2,\n      h = t.h / 2,\n      l = t.l + 1;\n\n    t.q = [\n      // top right\n      new Quadtree(x + w, y, w, h, l),\n      // top left\n      new Quadtree(x, y, w, h, l),\n      // bottom left\n      new Quadtree(x, y + h, w, h, l),\n      // bottom right\n      new Quadtree(x + w, y + h, w, h, l),\n    ];\n  }\n\n  // invokes callback with index of each overlapping quad\n  quads(x: number, y: number, w: number, h: number, cb: (q: Quadtree) => void) {\n    let t = this,\n      q = t.q!,\n      hzMid = t.x + t.w / 2,\n      vtMid = t.y + t.h / 2,\n      startIsNorth = y < vtMid,\n      startIsWest = x < hzMid,\n      endIsEast = x + w > hzMid,\n      endIsSouth = y + h > vtMid;\n\n    // top-right quad\n    startIsNorth && endIsEast && cb(q[0]);\n    // top-left quad\n    startIsWest && startIsNorth && cb(q[1]);\n    // bottom-left quad\n    startIsWest && endIsSouth && cb(q[2]);\n    // bottom-right quad\n    endIsEast && endIsSouth && cb(q[3]);\n  }\n\n  add(o: Rect) {\n    let t = this;\n\n    if (t.q != null) {\n      t.quads(o.x, o.y, o.w, o.h, (q) => {\n        q.add(o);\n      });\n    } else {\n      let os = t.o;\n\n      os.push(o);\n\n      if (os.length > MAX_OBJECTS && t.l < MAX_LEVELS) {\n        t.split();\n\n        for (let i = 0; i < os.length; i++) {\n          let oi = os[i];\n\n          t.quads(oi.x, oi.y, oi.w, oi.h, (q) => {\n            q.add(oi);\n          });\n        }\n\n        t.o.length = 0;\n      }\n    }\n  }\n\n  get(x: number, y: number, w: number, h: number, cb: (o: Rect) => void) {\n    let t = this;\n    let os = t.o;\n\n    for (let i = 0; i < os.length; i++) {\n      cb(os[i]);\n    }\n\n    if (t.q != null) {\n      t.quads(x, y, w, h, (q) => {\n        q.get(x, y, w, h, cb);\n      });\n    }\n  }\n\n  clear() {\n    this.o.length = 0;\n    this.q = null;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}