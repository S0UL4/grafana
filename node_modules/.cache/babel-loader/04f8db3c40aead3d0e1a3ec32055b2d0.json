{"ast":null,"code":"import uPlot from 'uplot';\nimport { alpha } from '@grafana/data/src/themes/colorManipulator';\nimport { StackingMode, VisibilityMode, ScaleOrientation } from '@grafana/schema';\nimport { measureText } from '@grafana/ui';\nimport { formatTime } from '@grafana/ui/src/components/uPlot/config/UPlotAxisBuilder';\nimport { preparePlotData2 } from '../../../../../packages/grafana-ui/src/components/uPlot/utils';\nimport { distribute, SPACE_BETWEEN } from './distribute';\nimport { intersects, pointWithin, Quadtree } from './quadtree';\nconst groupDistr = SPACE_BETWEEN;\nconst barDistr = SPACE_BETWEEN; // min.max font size for value label\n\nconst VALUE_MIN_FONT_SIZE = 8;\nconst VALUE_MAX_FONT_SIZE = 30; // % of width/height of the bar that value should fit in when measuring size\n\nconst BAR_FONT_SIZE_RATIO = 0.65; // distance between label and a bar in % of bar width\n\nconst LABEL_OFFSET_FACTOR_VT = 0.1;\nconst LABEL_OFFSET_FACTOR_HZ = 0.15; // max distance\n\nconst LABEL_OFFSET_MAX_VT = 5;\nconst LABEL_OFFSET_MAX_HZ = 10; // text baseline middle runs through the middle of lowercase letters\n// since bar values are numbers and uppercase-like, we want the middle of uppercase\n// this is a cheap fudge factor that skips expensive and inconsistent cross-browser measuring\n\nconst MIDDLE_BASELINE_SHIFT = 0.1;\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nfunction calculateFontSizeWithMetrics(text, width, height, lineHeight, maxSize) {\n  // calculate width in 14px\n  const textSize = measureText(text, 14); // how much bigger than 14px can we make it while staying within our width constraints\n\n  const fontSizeBasedOnWidth = width / (textSize.width + 2) * 14;\n  const fontSizeBasedOnHeight = height / lineHeight; // final fontSize\n\n  const optimalSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);\n  return {\n    fontSize: Math.min(optimalSize, maxSize !== null && maxSize !== void 0 ? maxSize : optimalSize),\n    textMetrics: textSize\n  };\n}\n/**\n * @internal\n */\n\n\nexport function getConfig(opts, theme) {\n  var _opts$text, _opts$text$valueSize, _opts$text2;\n\n  const {\n    xOri,\n    xDir: dir,\n    rawValue,\n    getColor,\n    formatValue,\n    fillOpacity = 1,\n    showValue,\n    xSpacing = 0\n  } = opts;\n  const isXHorizontal = xOri === ScaleOrientation.Horizontal;\n  const hasAutoValueSize = !Boolean((_opts$text = opts.text) === null || _opts$text === void 0 ? void 0 : _opts$text.valueSize);\n  const isStacked = opts.stacking !== StackingMode.None;\n  const pctStacked = opts.stacking === StackingMode.Percent;\n  let {\n    groupWidth,\n    barWidth,\n    barRadius = 0\n  } = opts;\n\n  if (isStacked) {\n    [groupWidth, barWidth] = [barWidth, groupWidth];\n  }\n\n  let qt;\n  let hRect;\n\n  const xSplits = u => {\n    const dim = isXHorizontal ? u.bbox.width : u.bbox.height;\n\n    const _dir = dir * (isXHorizontal ? 1 : -1);\n\n    let dataLen = u.data[0].length;\n    let lastIdx = dataLen - 1;\n    let skipMod = 0;\n\n    if (xSpacing !== 0) {\n      let cssDim = dim / devicePixelRatio;\n      let maxTicks = Math.abs(Math.floor(cssDim / xSpacing));\n      skipMod = dataLen < maxTicks ? 0 : Math.ceil(dataLen / maxTicks);\n    }\n\n    let splits = []; // for distr: 2 scales, the splits array should contain indices into data[0] rather than values\n\n    u.data[0].forEach((v, i) => {\n      let shouldSkip = skipMod !== 0 && (xSpacing > 0 ? i : lastIdx - i) % skipMod > 0;\n\n      if (!shouldSkip) {\n        splits.push(i);\n      }\n    });\n    return _dir === 1 ? splits : splits.reverse();\n  }; // the splits passed into here are data[0] values looked up by the indices returned from splits()\n\n\n  const xValues = (u, splits, axisIdx, foundSpace, foundIncr) => {\n    if (opts.xTimeAuto) {\n      // bit of a hack:\n      // temporarily set x scale range to temporal (as expected by formatTime()) rather than ordinal\n      let xScale = u.scales.x;\n      let oMin = xScale.min;\n      let oMax = xScale.max;\n      xScale.min = u.data[0][0];\n      xScale.max = u.data[0][u.data[0].length - 1];\n      let vals = formatTime(u, splits, axisIdx, foundSpace, foundIncr); // revert\n\n      xScale.min = oMin;\n      xScale.max = oMax;\n      return vals;\n    }\n\n    return splits.map(v => formatValue(0, v));\n  }; // this expands the distr: 2 scale so that the indicies of each data[0] land at the proper justified positions\n\n\n  const xRange = (u, min, max) => {\n    min = 0;\n    max = Math.max(1, u.data[0].length - 1);\n    let pctOffset = 0; // how far in is the first tick in % of full dimension\n\n    distribute(u.data[0].length, groupWidth, groupDistr, 0, (di, lftPct, widPct) => {\n      pctOffset = lftPct + widPct / 2;\n    }); // expand scale range by equal amounts on both ends\n\n    let rn = max - min;\n\n    if (pctOffset === 0.5) {\n      min -= rn;\n    } else {\n      let upScale = 1 / (1 - pctOffset * 2);\n      let offset = (upScale * rn - rn) / 2;\n      min -= offset;\n      max += offset;\n    }\n\n    return [min, max];\n  };\n\n  let distrTwo = (groupCount, barCount) => {\n    let out = Array.from({\n      length: barCount\n    }, () => ({\n      offs: Array(groupCount).fill(0),\n      size: Array(groupCount).fill(0)\n    }));\n    distribute(groupCount, groupWidth, groupDistr, null, (groupIdx, groupOffPct, groupDimPct) => {\n      distribute(barCount, barWidth, barDistr, null, (barIdx, barOffPct, barDimPct) => {\n        out[barIdx].offs[groupIdx] = groupOffPct + groupDimPct * barOffPct;\n        out[barIdx].size[groupIdx] = groupDimPct * barDimPct;\n      });\n    });\n    return out;\n  };\n\n  let distrOne = (groupCount, barCount) => {\n    let out = Array.from({\n      length: barCount\n    }, () => ({\n      offs: Array(groupCount).fill(0),\n      size: Array(groupCount).fill(0)\n    }));\n    distribute(groupCount, groupWidth, groupDistr, null, (groupIdx, groupOffPct, groupDimPct) => {\n      distribute(barCount, barWidth, barDistr, null, (barIdx, barOffPct, barDimPct) => {\n        out[barIdx].offs[groupIdx] = groupOffPct;\n        out[barIdx].size[groupIdx] = groupDimPct;\n      });\n    });\n    return out;\n  };\n\n  const LABEL_OFFSET_FACTOR = isXHorizontal ? LABEL_OFFSET_FACTOR_VT : LABEL_OFFSET_FACTOR_HZ;\n  const LABEL_OFFSET_MAX = isXHorizontal ? LABEL_OFFSET_MAX_VT : LABEL_OFFSET_MAX_HZ;\n  let barsPctLayout = [];\n  let barsColors = [];\n  let scaleFactor = 1;\n  let labels = {};\n  let fontSize = (_opts$text$valueSize = (_opts$text2 = opts.text) === null || _opts$text2 === void 0 ? void 0 : _opts$text2.valueSize) !== null && _opts$text$valueSize !== void 0 ? _opts$text$valueSize : VALUE_MAX_FONT_SIZE;\n  let labelOffset = LABEL_OFFSET_MAX; // minimum available space for labels between bar end and plotting area bound (in canvas pixels)\n\n  let vSpace = Infinity;\n  let hSpace = Infinity;\n  let useMappedColors = getColor != null;\n  let mappedColorDisp = useMappedColors ? {\n    fill: {\n      unit: 3,\n      values: (u, seriesIdx) => barsColors[seriesIdx].fill\n    },\n    stroke: {\n      unit: 3,\n      values: (u, seriesIdx) => barsColors[seriesIdx].stroke\n    }\n  } : {};\n  let barsBuilder = uPlot.paths.bars({\n    radius: barRadius,\n    disp: Object.assign({\n      x0: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx].offs\n      },\n      size: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx].size\n      }\n    }, mappedColorDisp),\n    // collect rendered bar geometry\n    each: (u, seriesIdx, dataIdx, lft, top, wid, hgt) => {\n      // we get back raw canvas coords (included axes & padding)\n      // translate to the plotting area origin\n      lft -= u.bbox.left;\n      top -= u.bbox.top;\n      let val = u.data[seriesIdx][dataIdx]; // accum min space abvailable for labels\n\n      if (isXHorizontal) {\n        vSpace = Math.min(vSpace, val < 0 ? u.bbox.height - (top + hgt) : top);\n        hSpace = wid;\n      } else {\n        vSpace = hgt;\n        hSpace = Math.min(hSpace, val < 0 ? lft : u.bbox.width - (lft + wid));\n      }\n\n      let barRect = {\n        x: lft,\n        y: top,\n        w: wid,\n        h: hgt,\n        sidx: seriesIdx,\n        didx: dataIdx\n      };\n      qt.add(barRect);\n\n      if (showValue !== VisibilityMode.Never) {\n        // Format Values and calculate label offsets\n        const text = formatValue(seriesIdx, rawValue(seriesIdx, dataIdx) / (pctStacked ? alignedTotals[seriesIdx][dataIdx] : 1));\n        labelOffset = Math.min(labelOffset, Math.round(LABEL_OFFSET_FACTOR * (isXHorizontal ? wid : hgt)));\n\n        if (labels[dataIdx] === undefined) {\n          labels[dataIdx] = {};\n        }\n\n        labels[dataIdx][seriesIdx] = {\n          text: text,\n          value: rawValue(seriesIdx, dataIdx),\n          hidden: false\n        }; // Calculate font size when it's set to be automatic\n\n        if (hasAutoValueSize) {\n          const {\n            fontSize: calculatedSize,\n            textMetrics\n          } = calculateFontSizeWithMetrics(labels[dataIdx][seriesIdx].text, hSpace * (isXHorizontal ? BAR_FONT_SIZE_RATIO : 1) - (isXHorizontal ? 0 : labelOffset), vSpace * (isXHorizontal ? 1 : BAR_FONT_SIZE_RATIO) - (isXHorizontal ? labelOffset : 0), 1); // Save text metrics\n\n          labels[dataIdx][seriesIdx].textMetrics = textMetrics; // Retrieve the new font size and use it\n\n          let autoFontSize = Math.round(Math.min(fontSize, VALUE_MAX_FONT_SIZE, calculatedSize)); // Calculate the scaling factor for bouding boxes\n          // Take into account the fact that calculateFontSize\n          // uses 14px measurement so we need to adjust the scale factor\n\n          scaleFactor = autoFontSize / fontSize * (autoFontSize / 14); // Update the end font-size\n\n          fontSize = autoFontSize;\n        } else {\n          labels[dataIdx][seriesIdx].textMetrics = measureText(labels[dataIdx][seriesIdx].text, fontSize);\n        }\n\n        let middleShift = isXHorizontal ? 0 : -Math.round(MIDDLE_BASELINE_SHIFT * fontSize);\n        let value = rawValue(seriesIdx, dataIdx);\n\n        if (value != null) {\n          // Calculate final co-ordinates for text position\n          const x = u.bbox.left + (isXHorizontal ? lft + wid / 2 : value < 0 ? lft - labelOffset : lft + wid + labelOffset);\n          const y = u.bbox.top + (isXHorizontal ? value < 0 ? top + hgt + labelOffset : top - labelOffset : top + hgt / 2 - middleShift); // Retrieve textMetrics with necessary default values\n          // These _shouldn't_ be undefined at this point\n          // but they _could_ be.\n\n          const {\n            textMetrics = {\n              width: 1,\n              actualBoundingBoxAscent: 1,\n              actualBoundingBoxDescent: 1\n            }\n          } = labels[dataIdx][seriesIdx]; // Adjust bounding boxes based on text scale\n          // factor and orientation (which changes the baseline)\n\n          let xAdjust = 0,\n              yAdjust = 0;\n\n          if (isXHorizontal) {\n            // Adjust for baseline which is \"top\" in this case\n            xAdjust = textMetrics.width * scaleFactor / 2; // yAdjust only matters when when the value isn't negative\n\n            yAdjust = value > 0 ? (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor : 0;\n          } else {\n            // Adjust from the baseline which is \"middle\" in this case\n            yAdjust = (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor / 2; // Adjust for baseline being \"right\" in the x direction\n\n            xAdjust = value < 0 ? textMetrics.width * scaleFactor : 0;\n          } // Construct final bounding box for the label text\n\n\n          labels[dataIdx][seriesIdx].x = x;\n          labels[dataIdx][seriesIdx].y = y;\n          labels[dataIdx][seriesIdx].bbox = {\n            x: x - xAdjust,\n            y: y - yAdjust,\n            w: textMetrics.width * scaleFactor,\n            h: (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor\n          };\n        }\n      }\n    }\n  });\n\n  const init = u => {\n    let over = u.over;\n    over.style.overflow = 'hidden';\n    u.root.querySelectorAll('.u-cursor-pt').forEach(el => {\n      el.style.borderRadius = '0';\n    });\n  };\n\n  const cursor = {\n    x: false,\n    y: false,\n    drag: {\n      x: false,\n      y: false\n    },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        hRect = null;\n        let cx = u.cursor.left * devicePixelRatio;\n        let cy = u.cursor.top * devicePixelRatio;\n        qt.get(cx, cy, 1, 1, o => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            hRect = o;\n          }\n        });\n      }\n\n      return hRect && seriesIdx === hRect.sidx ? hRect.didx : null;\n    },\n    points: {\n      fill: 'rgba(255,255,255,0.4)',\n      bbox: (u, seriesIdx) => {\n        let isHovered = hRect && seriesIdx === hRect.sidx;\n        return {\n          left: isHovered ? hRect.x / devicePixelRatio : -10,\n          top: isHovered ? hRect.y / devicePixelRatio : -10,\n          width: isHovered ? hRect.w / devicePixelRatio : 0,\n          height: isHovered ? hRect.h / devicePixelRatio : 0\n        };\n      }\n    }\n  }; // Build bars\n\n  const drawClear = u => {\n    var _opts$text$valueSize2, _opts$text3;\n\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n    qt.clear(); // clear the path cache to force drawBars() to rebuild new quadtree\n\n    u.series.forEach(s => {\n      // @ts-ignore\n      s._paths = null;\n    });\n\n    if (isStacked) {\n      //barsPctLayout = [null as any].concat(distrOne(u.data.length - 1, u.data[0].length));\n      barsPctLayout = [null].concat(distrOne(u.data[0].length, u.data.length - 1));\n    } else {\n      barsPctLayout = [null].concat(distrTwo(u.data[0].length, u.data.length - 1));\n    }\n\n    if (useMappedColors) {\n      barsColors = [null]; // map per-bar colors\n\n      for (let i = 1; i < u.data.length; i++) {\n        let colors = u.data[i].map((value, valueIdx) => {\n          if (value != null) {\n            return getColor(i, valueIdx, value);\n          }\n\n          return null;\n        });\n        barsColors.push({\n          fill: fillOpacity < 1 ? colors.map(c => c != null ? alpha(c, fillOpacity) : null) : colors,\n          stroke: colors\n        });\n      }\n    }\n\n    labels = {};\n    fontSize = (_opts$text$valueSize2 = (_opts$text3 = opts.text) === null || _opts$text3 === void 0 ? void 0 : _opts$text3.valueSize) !== null && _opts$text$valueSize2 !== void 0 ? _opts$text$valueSize2 : VALUE_MAX_FONT_SIZE;\n    labelOffset = LABEL_OFFSET_MAX;\n    vSpace = hSpace = Infinity;\n  }; // uPlot hook to draw the labels on the bar chart.\n\n\n  const draw = u => {\n    if (showValue === VisibilityMode.Never || fontSize < VALUE_MIN_FONT_SIZE) {\n      return;\n    }\n\n    u.ctx.save();\n    u.ctx.fillStyle = theme.colors.text.primary;\n    u.ctx.font = `${fontSize}px ${theme.typography.fontFamily}`;\n    let curAlign = undefined,\n        curBaseline = undefined;\n\n    for (const didx in labels) {\n      for (const sidx in labels[didx]) {\n        const {\n          text,\n          value,\n          x = 0,\n          y = 0,\n          bbox = {\n            x: 0,\n            y: 0,\n            w: 1,\n            h: 1\n          }\n        } = labels[didx][sidx];\n        let align = isXHorizontal ? 'center' : value !== null && value < 0 ? 'right' : 'left';\n        let baseline = isXHorizontal ? value !== null && value < 0 ? 'top' : 'alphabetic' : 'middle';\n\n        if (align !== curAlign) {\n          u.ctx.textAlign = curAlign = align;\n        }\n\n        if (baseline !== curBaseline) {\n          u.ctx.textBaseline = curBaseline = baseline;\n        }\n\n        if (showValue === VisibilityMode.Always) {\n          u.ctx.fillText(text, x, y);\n        } else if (showValue === VisibilityMode.Auto) {\n          let intersectsLabel = false; // Test for any collisions\n\n          for (const subsidx in labels[didx]) {\n            const r = labels[didx][subsidx].bbox;\n\n            if (!labels[didx][subsidx].hidden && sidx !== subsidx && intersects(bbox, r)) {\n              intersectsLabel = true;\n              labels[didx][sidx].hidden = true;\n              break;\n            }\n          }\n\n          !intersectsLabel && u.ctx.fillText(text, x, y);\n        }\n      }\n    }\n\n    u.ctx.restore();\n  }; // handle hover interaction with quadtree probing\n\n\n  const interpolateTooltip = (updateActiveSeriesIdx, updateActiveDatapointIdx, updateTooltipPosition, u) => {\n    if (hRect) {\n      updateActiveSeriesIdx(hRect.sidx);\n      updateActiveDatapointIdx(hRect.didx);\n      updateTooltipPosition();\n    } else {\n      updateTooltipPosition(true);\n    }\n  };\n\n  let alignedTotals = null;\n\n  function prepData(frames, stackingGroups) {\n    alignedTotals = null;\n    return preparePlotData2(frames[0], stackingGroups, ({\n      totals\n    }) => {\n      alignedTotals = totals;\n    });\n  }\n\n  return {\n    cursor,\n    // scale & axis opts\n    xRange,\n    xValues,\n    xSplits,\n    barsBuilder,\n    // hooks\n    init,\n    drawClear,\n    draw,\n    interpolateTooltip,\n    prepData\n  };\n}","map":{"version":3,"names":["uPlot","alpha","StackingMode","VisibilityMode","ScaleOrientation","measureText","formatTime","preparePlotData2","distribute","SPACE_BETWEEN","intersects","pointWithin","Quadtree","groupDistr","barDistr","VALUE_MIN_FONT_SIZE","VALUE_MAX_FONT_SIZE","BAR_FONT_SIZE_RATIO","LABEL_OFFSET_FACTOR_VT","LABEL_OFFSET_FACTOR_HZ","LABEL_OFFSET_MAX_VT","LABEL_OFFSET_MAX_HZ","MIDDLE_BASELINE_SHIFT","calculateFontSizeWithMetrics","text","width","height","lineHeight","maxSize","textSize","fontSizeBasedOnWidth","fontSizeBasedOnHeight","optimalSize","Math","min","fontSize","textMetrics","getConfig","opts","theme","xOri","xDir","dir","rawValue","getColor","formatValue","fillOpacity","showValue","xSpacing","isXHorizontal","Horizontal","hasAutoValueSize","Boolean","valueSize","isStacked","stacking","None","pctStacked","Percent","groupWidth","barWidth","barRadius","qt","hRect","xSplits","u","dim","bbox","_dir","dataLen","data","length","lastIdx","skipMod","cssDim","devicePixelRatio","maxTicks","abs","floor","ceil","splits","forEach","v","i","shouldSkip","push","reverse","xValues","axisIdx","foundSpace","foundIncr","xTimeAuto","xScale","scales","x","oMin","oMax","max","vals","map","xRange","pctOffset","di","lftPct","widPct","rn","upScale","offset","distrTwo","groupCount","barCount","out","Array","from","offs","fill","size","groupIdx","groupOffPct","groupDimPct","barIdx","barOffPct","barDimPct","distrOne","LABEL_OFFSET_FACTOR","LABEL_OFFSET_MAX","barsPctLayout","barsColors","scaleFactor","labels","labelOffset","vSpace","Infinity","hSpace","useMappedColors","mappedColorDisp","unit","values","seriesIdx","stroke","barsBuilder","paths","bars","radius","disp","x0","each","dataIdx","lft","top","wid","hgt","left","val","barRect","y","w","h","sidx","didx","add","Never","alignedTotals","round","undefined","value","hidden","calculatedSize","autoFontSize","middleShift","actualBoundingBoxAscent","actualBoundingBoxDescent","xAdjust","yAdjust","init","over","style","overflow","root","querySelectorAll","el","borderRadius","cursor","drag","cx","cy","get","o","points","isHovered","drawClear","clear","series","s","_paths","concat","colors","valueIdx","c","draw","ctx","save","fillStyle","primary","font","typography","fontFamily","curAlign","curBaseline","align","baseline","textAlign","textBaseline","Always","fillText","Auto","intersectsLabel","subsidx","r","restore","interpolateTooltip","updateActiveSeriesIdx","updateActiveDatapointIdx","updateTooltipPosition","prepData","frames","stackingGroups","totals"],"sources":["/home/soula/grafana/public/app/plugins/panel/barchart/bars.ts"],"sourcesContent":["import uPlot, { Axis, AlignedData, Scale } from 'uplot';\n\nimport { DataFrame, GrafanaTheme2 } from '@grafana/data';\nimport { alpha } from '@grafana/data/src/themes/colorManipulator';\nimport {\n  StackingMode,\n  VisibilityMode,\n  ScaleDirection,\n  ScaleOrientation,\n  VizTextDisplayOptions,\n  VizLegendOptions,\n} from '@grafana/schema';\nimport { measureText, PlotTooltipInterpolator } from '@grafana/ui';\nimport { formatTime } from '@grafana/ui/src/components/uPlot/config/UPlotAxisBuilder';\n\nimport { preparePlotData2, StackingGroup } from '../../../../../packages/grafana-ui/src/components/uPlot/utils';\n\nimport { distribute, SPACE_BETWEEN } from './distribute';\nimport { intersects, pointWithin, Quadtree, Rect } from './quadtree';\n\nconst groupDistr = SPACE_BETWEEN;\nconst barDistr = SPACE_BETWEEN;\n// min.max font size for value label\nconst VALUE_MIN_FONT_SIZE = 8;\nconst VALUE_MAX_FONT_SIZE = 30;\n// % of width/height of the bar that value should fit in when measuring size\nconst BAR_FONT_SIZE_RATIO = 0.65;\n// distance between label and a bar in % of bar width\nconst LABEL_OFFSET_FACTOR_VT = 0.1;\nconst LABEL_OFFSET_FACTOR_HZ = 0.15;\n// max distance\nconst LABEL_OFFSET_MAX_VT = 5;\nconst LABEL_OFFSET_MAX_HZ = 10;\n\n// text baseline middle runs through the middle of lowercase letters\n// since bar values are numbers and uppercase-like, we want the middle of uppercase\n// this is a cheap fudge factor that skips expensive and inconsistent cross-browser measuring\nconst MIDDLE_BASELINE_SHIFT = 0.1;\n\n/**\n * @internal\n */\nexport interface BarsOptions {\n  xOri: ScaleOrientation;\n  xDir: ScaleDirection;\n  groupWidth: number;\n  barWidth: number;\n  barRadius: number;\n  showValue: VisibilityMode;\n  stacking: StackingMode;\n  rawValue: (seriesIdx: number, valueIdx: number) => number | null;\n  getColor?: (seriesIdx: number, valueIdx: number, value: any) => string | null;\n  fillOpacity?: number;\n  formatValue: (seriesIdx: number, value: any) => string;\n  text?: VizTextDisplayOptions;\n  onHover?: (seriesIdx: number, valueIdx: number) => void;\n  onLeave?: (seriesIdx: number, valueIdx: number) => void;\n  legend?: VizLegendOptions;\n  xSpacing?: number;\n  xTimeAuto?: boolean;\n}\n\n/**\n * @internal\n */\ninterface ValueLabelTable {\n  [index: number]: ValueLabelArray;\n}\n\n/**\n * @internal\n */\ninterface ValueLabelArray {\n  [index: number]: ValueLabel;\n}\n\n/**\n * @internal\n */\ninterface ValueLabel {\n  text: string;\n  value: number | null;\n  hidden: boolean;\n  bbox?: Rect;\n  textMetrics?: TextMetrics;\n  x?: number;\n  y?: number;\n}\n\n/**\n * @internal\n */\nfunction calculateFontSizeWithMetrics(\n  text: string,\n  width: number,\n  height: number,\n  lineHeight: number,\n  maxSize?: number\n) {\n  // calculate width in 14px\n  const textSize = measureText(text, 14);\n  // how much bigger than 14px can we make it while staying within our width constraints\n  const fontSizeBasedOnWidth = (width / (textSize.width + 2)) * 14;\n  const fontSizeBasedOnHeight = height / lineHeight;\n\n  // final fontSize\n  const optimalSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);\n  return {\n    fontSize: Math.min(optimalSize, maxSize ?? optimalSize),\n    textMetrics: textSize,\n  };\n}\n\n/**\n * @internal\n */\nexport function getConfig(opts: BarsOptions, theme: GrafanaTheme2) {\n  const { xOri, xDir: dir, rawValue, getColor, formatValue, fillOpacity = 1, showValue, xSpacing = 0 } = opts;\n  const isXHorizontal = xOri === ScaleOrientation.Horizontal;\n  const hasAutoValueSize = !Boolean(opts.text?.valueSize);\n  const isStacked = opts.stacking !== StackingMode.None;\n  const pctStacked = opts.stacking === StackingMode.Percent;\n\n  let { groupWidth, barWidth, barRadius = 0 } = opts;\n\n  if (isStacked) {\n    [groupWidth, barWidth] = [barWidth, groupWidth];\n  }\n\n  let qt: Quadtree;\n  let hRect: Rect | null;\n\n  const xSplits: Axis.Splits = (u: uPlot) => {\n    const dim = isXHorizontal ? u.bbox.width : u.bbox.height;\n    const _dir = dir * (isXHorizontal ? 1 : -1);\n\n    let dataLen = u.data[0].length;\n    let lastIdx = dataLen - 1;\n\n    let skipMod = 0;\n\n    if (xSpacing !== 0) {\n      let cssDim = dim / devicePixelRatio;\n      let maxTicks = Math.abs(Math.floor(cssDim / xSpacing));\n\n      skipMod = dataLen < maxTicks ? 0 : Math.ceil(dataLen / maxTicks);\n    }\n\n    let splits: number[] = [];\n\n    // for distr: 2 scales, the splits array should contain indices into data[0] rather than values\n    u.data[0].forEach((v, i) => {\n      let shouldSkip = skipMod !== 0 && (xSpacing > 0 ? i : lastIdx - i) % skipMod > 0;\n\n      if (!shouldSkip) {\n        splits.push(i);\n      }\n    });\n\n    return _dir === 1 ? splits : splits.reverse();\n  };\n\n  // the splits passed into here are data[0] values looked up by the indices returned from splits()\n  const xValues: Axis.Values = (u, splits, axisIdx, foundSpace, foundIncr) => {\n    if (opts.xTimeAuto) {\n      // bit of a hack:\n      // temporarily set x scale range to temporal (as expected by formatTime()) rather than ordinal\n      let xScale = u.scales.x;\n      let oMin = xScale.min;\n      let oMax = xScale.max;\n\n      xScale.min = u.data[0][0];\n      xScale.max = u.data[0][u.data[0].length - 1];\n\n      let vals = formatTime(u, splits, axisIdx, foundSpace, foundIncr);\n\n      // revert\n      xScale.min = oMin;\n      xScale.max = oMax;\n\n      return vals;\n    }\n\n    return splits.map((v) => formatValue(0, v));\n  };\n\n  // this expands the distr: 2 scale so that the indicies of each data[0] land at the proper justified positions\n  const xRange: Scale.Range = (u, min, max) => {\n    min = 0;\n    max = Math.max(1, u.data[0].length - 1);\n\n    let pctOffset = 0;\n\n    // how far in is the first tick in % of full dimension\n    distribute(u.data[0].length, groupWidth, groupDistr, 0, (di, lftPct, widPct) => {\n      pctOffset = lftPct + widPct / 2;\n    });\n\n    // expand scale range by equal amounts on both ends\n    let rn = max - min;\n\n    if (pctOffset === 0.5) {\n      min -= rn;\n    } else {\n      let upScale = 1 / (1 - pctOffset * 2);\n      let offset = (upScale * rn - rn) / 2;\n\n      min -= offset;\n      max += offset;\n    }\n\n    return [min, max];\n  };\n\n  let distrTwo = (groupCount: number, barCount: number) => {\n    let out = Array.from({ length: barCount }, () => ({\n      offs: Array(groupCount).fill(0),\n      size: Array(groupCount).fill(0),\n    }));\n\n    distribute(groupCount, groupWidth, groupDistr, null, (groupIdx, groupOffPct, groupDimPct) => {\n      distribute(barCount, barWidth, barDistr, null, (barIdx, barOffPct, barDimPct) => {\n        out[barIdx].offs[groupIdx] = groupOffPct + groupDimPct * barOffPct;\n        out[barIdx].size[groupIdx] = groupDimPct * barDimPct;\n      });\n    });\n\n    return out;\n  };\n\n  let distrOne = (groupCount: number, barCount: number) => {\n    let out = Array.from({ length: barCount }, () => ({\n      offs: Array(groupCount).fill(0),\n      size: Array(groupCount).fill(0),\n    }));\n\n    distribute(groupCount, groupWidth, groupDistr, null, (groupIdx, groupOffPct, groupDimPct) => {\n      distribute(barCount, barWidth, barDistr, null, (barIdx, barOffPct, barDimPct) => {\n        out[barIdx].offs[groupIdx] = groupOffPct;\n        out[barIdx].size[groupIdx] = groupDimPct;\n      });\n    });\n\n    return out;\n  };\n\n  const LABEL_OFFSET_FACTOR = isXHorizontal ? LABEL_OFFSET_FACTOR_VT : LABEL_OFFSET_FACTOR_HZ;\n  const LABEL_OFFSET_MAX = isXHorizontal ? LABEL_OFFSET_MAX_VT : LABEL_OFFSET_MAX_HZ;\n\n  let barsPctLayout: Array<null | { offs: number[]; size: number[] }> = [];\n  let barsColors: Array<null | { fill: Array<string | null>; stroke: Array<string | null> }> = [];\n  let scaleFactor = 1;\n  let labels: ValueLabelTable = {};\n  let fontSize = opts.text?.valueSize ?? VALUE_MAX_FONT_SIZE;\n  let labelOffset = LABEL_OFFSET_MAX;\n\n  // minimum available space for labels between bar end and plotting area bound (in canvas pixels)\n  let vSpace = Infinity;\n  let hSpace = Infinity;\n\n  let useMappedColors = getColor != null;\n\n  let mappedColorDisp = useMappedColors\n    ? {\n        fill: {\n          unit: 3,\n          values: (u: uPlot, seriesIdx: number) => barsColors[seriesIdx]!.fill,\n        },\n        stroke: {\n          unit: 3,\n          values: (u: uPlot, seriesIdx: number) => barsColors[seriesIdx]!.stroke,\n        },\n      }\n    : {};\n\n  let barsBuilder = uPlot.paths.bars!({\n    radius: barRadius,\n    disp: {\n      x0: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx]!.offs,\n      },\n      size: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx]!.size,\n      },\n      ...mappedColorDisp,\n    },\n    // collect rendered bar geometry\n    each: (u, seriesIdx, dataIdx, lft, top, wid, hgt) => {\n      // we get back raw canvas coords (included axes & padding)\n      // translate to the plotting area origin\n      lft -= u.bbox.left;\n      top -= u.bbox.top;\n\n      let val = u.data[seriesIdx][dataIdx]!;\n      // accum min space abvailable for labels\n      if (isXHorizontal) {\n        vSpace = Math.min(vSpace, val < 0 ? u.bbox.height - (top + hgt) : top);\n        hSpace = wid;\n      } else {\n        vSpace = hgt;\n        hSpace = Math.min(hSpace, val < 0 ? lft : u.bbox.width - (lft + wid));\n      }\n\n      let barRect = { x: lft, y: top, w: wid, h: hgt, sidx: seriesIdx, didx: dataIdx };\n      qt.add(barRect);\n\n      if (showValue !== VisibilityMode.Never) {\n        // Format Values and calculate label offsets\n        const text = formatValue(\n          seriesIdx,\n          rawValue(seriesIdx, dataIdx)! / (pctStacked ? alignedTotals![seriesIdx][dataIdx]! : 1)\n        );\n        labelOffset = Math.min(labelOffset, Math.round(LABEL_OFFSET_FACTOR * (isXHorizontal ? wid : hgt)));\n\n        if (labels[dataIdx] === undefined) {\n          labels[dataIdx] = {};\n        }\n        labels[dataIdx][seriesIdx] = { text: text, value: rawValue(seriesIdx, dataIdx), hidden: false };\n\n        // Calculate font size when it's set to be automatic\n        if (hasAutoValueSize) {\n          const { fontSize: calculatedSize, textMetrics } = calculateFontSizeWithMetrics(\n            labels[dataIdx][seriesIdx].text,\n            hSpace * (isXHorizontal ? BAR_FONT_SIZE_RATIO : 1) - (isXHorizontal ? 0 : labelOffset),\n            vSpace * (isXHorizontal ? 1 : BAR_FONT_SIZE_RATIO) - (isXHorizontal ? labelOffset : 0),\n            1\n          );\n\n          // Save text metrics\n          labels[dataIdx][seriesIdx].textMetrics = textMetrics;\n\n          // Retrieve the new font size and use it\n          let autoFontSize = Math.round(Math.min(fontSize, VALUE_MAX_FONT_SIZE, calculatedSize));\n\n          // Calculate the scaling factor for bouding boxes\n          // Take into account the fact that calculateFontSize\n          // uses 14px measurement so we need to adjust the scale factor\n          scaleFactor = (autoFontSize / fontSize) * (autoFontSize / 14);\n\n          // Update the end font-size\n          fontSize = autoFontSize;\n        } else {\n          labels[dataIdx][seriesIdx].textMetrics = measureText(labels[dataIdx][seriesIdx].text, fontSize);\n        }\n\n        let middleShift = isXHorizontal ? 0 : -Math.round(MIDDLE_BASELINE_SHIFT * fontSize);\n        let value = rawValue(seriesIdx, dataIdx);\n\n        if (value != null) {\n          // Calculate final co-ordinates for text position\n          const x =\n            u.bbox.left + (isXHorizontal ? lft + wid / 2 : value < 0 ? lft - labelOffset : lft + wid + labelOffset);\n          const y =\n            u.bbox.top +\n            (isXHorizontal ? (value < 0 ? top + hgt + labelOffset : top - labelOffset) : top + hgt / 2 - middleShift);\n\n          // Retrieve textMetrics with necessary default values\n          // These _shouldn't_ be undefined at this point\n          // but they _could_ be.\n          const {\n            textMetrics = {\n              width: 1,\n              actualBoundingBoxAscent: 1,\n              actualBoundingBoxDescent: 1,\n            },\n          } = labels[dataIdx][seriesIdx];\n\n          // Adjust bounding boxes based on text scale\n          // factor and orientation (which changes the baseline)\n          let xAdjust = 0,\n            yAdjust = 0;\n\n          if (isXHorizontal) {\n            // Adjust for baseline which is \"top\" in this case\n            xAdjust = (textMetrics.width * scaleFactor) / 2;\n\n            // yAdjust only matters when when the value isn't negative\n            yAdjust =\n              value > 0\n                ? (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor\n                : 0;\n          } else {\n            // Adjust from the baseline which is \"middle\" in this case\n            yAdjust = ((textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor) / 2;\n\n            // Adjust for baseline being \"right\" in the x direction\n            xAdjust = value < 0 ? textMetrics.width * scaleFactor : 0;\n          }\n\n          // Construct final bounding box for the label text\n          labels[dataIdx][seriesIdx].x = x;\n          labels[dataIdx][seriesIdx].y = y;\n          labels[dataIdx][seriesIdx].bbox = {\n            x: x - xAdjust,\n            y: y - yAdjust,\n            w: textMetrics.width * scaleFactor,\n            h: (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor,\n          };\n        }\n      }\n    },\n  });\n\n  const init = (u: uPlot) => {\n    let over = u.over;\n    over.style.overflow = 'hidden';\n    u.root.querySelectorAll('.u-cursor-pt').forEach((el) => {\n      (el as HTMLElement).style.borderRadius = '0';\n    });\n  };\n\n  const cursor: uPlot.Cursor = {\n    x: false,\n    y: false,\n    drag: {\n      x: false,\n      y: false,\n    },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        hRect = null;\n\n        let cx = u.cursor.left! * devicePixelRatio;\n        let cy = u.cursor.top! * devicePixelRatio;\n\n        qt.get(cx, cy, 1, 1, (o) => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            hRect = o;\n          }\n        });\n      }\n\n      return hRect && seriesIdx === hRect.sidx ? hRect.didx : null;\n    },\n    points: {\n      fill: 'rgba(255,255,255,0.4)',\n      bbox: (u, seriesIdx) => {\n        let isHovered = hRect && seriesIdx === hRect.sidx;\n\n        return {\n          left: isHovered ? hRect!.x / devicePixelRatio : -10,\n          top: isHovered ? hRect!.y / devicePixelRatio : -10,\n          width: isHovered ? hRect!.w / devicePixelRatio : 0,\n          height: isHovered ? hRect!.h / devicePixelRatio : 0,\n        };\n      },\n    },\n  };\n\n  // Build bars\n  const drawClear = (u: uPlot) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n    qt.clear();\n\n    // clear the path cache to force drawBars() to rebuild new quadtree\n    u.series.forEach((s) => {\n      // @ts-ignore\n      s._paths = null;\n    });\n\n    if (isStacked) {\n      //barsPctLayout = [null as any].concat(distrOne(u.data.length - 1, u.data[0].length));\n      barsPctLayout = [null as any].concat(distrOne(u.data[0].length, u.data.length - 1));\n    } else {\n      barsPctLayout = [null as any].concat(distrTwo(u.data[0].length, u.data.length - 1));\n    }\n\n    if (useMappedColors) {\n      barsColors = [null];\n\n      // map per-bar colors\n      for (let i = 1; i < u.data.length; i++) {\n        let colors = (u.data[i] as Array<number | null>).map((value, valueIdx) => {\n          if (value != null) {\n            return getColor!(i, valueIdx, value);\n          }\n\n          return null;\n        });\n\n        barsColors.push({\n          fill: fillOpacity < 1 ? colors.map((c) => (c != null ? alpha(c, fillOpacity) : null)) : colors,\n          stroke: colors,\n        });\n      }\n    }\n\n    labels = {};\n    fontSize = opts.text?.valueSize ?? VALUE_MAX_FONT_SIZE;\n    labelOffset = LABEL_OFFSET_MAX;\n    vSpace = hSpace = Infinity;\n  };\n\n  // uPlot hook to draw the labels on the bar chart.\n  const draw = (u: uPlot) => {\n    if (showValue === VisibilityMode.Never || fontSize < VALUE_MIN_FONT_SIZE) {\n      return;\n    }\n\n    u.ctx.save();\n    u.ctx.fillStyle = theme.colors.text.primary;\n    u.ctx.font = `${fontSize}px ${theme.typography.fontFamily}`;\n\n    let curAlign: CanvasTextAlign | undefined = undefined,\n      curBaseline: CanvasTextBaseline | undefined = undefined;\n\n    for (const didx in labels) {\n      for (const sidx in labels[didx]) {\n        const { text, value, x = 0, y = 0, bbox = { x: 0, y: 0, w: 1, h: 1 } } = labels[didx][sidx];\n\n        let align: CanvasTextAlign = isXHorizontal ? 'center' : value !== null && value < 0 ? 'right' : 'left';\n        let baseline: CanvasTextBaseline = isXHorizontal\n          ? value !== null && value < 0\n            ? 'top'\n            : 'alphabetic'\n          : 'middle';\n\n        if (align !== curAlign) {\n          u.ctx.textAlign = curAlign = align;\n        }\n\n        if (baseline !== curBaseline) {\n          u.ctx.textBaseline = curBaseline = baseline;\n        }\n\n        if (showValue === VisibilityMode.Always) {\n          u.ctx.fillText(text, x, y);\n        } else if (showValue === VisibilityMode.Auto) {\n          let intersectsLabel = false;\n\n          // Test for any collisions\n          for (const subsidx in labels[didx]) {\n            const r = labels[didx][subsidx].bbox!;\n\n            if (!labels[didx][subsidx].hidden && sidx !== subsidx && intersects(bbox, r)) {\n              intersectsLabel = true;\n              labels[didx][sidx].hidden = true;\n              break;\n            }\n          }\n\n          !intersectsLabel && u.ctx.fillText(text, x, y);\n        }\n      }\n    }\n\n    u.ctx.restore();\n  };\n\n  // handle hover interaction with quadtree probing\n  const interpolateTooltip: PlotTooltipInterpolator = (\n    updateActiveSeriesIdx,\n    updateActiveDatapointIdx,\n    updateTooltipPosition,\n    u\n  ) => {\n    if (hRect) {\n      updateActiveSeriesIdx(hRect.sidx);\n      updateActiveDatapointIdx(hRect.didx);\n      updateTooltipPosition();\n    } else {\n      updateTooltipPosition(true);\n    }\n  };\n\n  let alignedTotals: AlignedData | null = null;\n\n  function prepData(frames: DataFrame[], stackingGroups: StackingGroup[]) {\n    alignedTotals = null;\n    return preparePlotData2(frames[0], stackingGroups, ({ totals }) => {\n      alignedTotals = totals;\n    });\n  }\n\n  return {\n    cursor,\n    // scale & axis opts\n    xRange,\n    xValues,\n    xSplits,\n\n    barsBuilder,\n\n    // hooks\n    init,\n    drawClear,\n    draw,\n    interpolateTooltip,\n    prepData,\n  };\n}\n"],"mappings":"AAAA,OAAOA,KAAP,MAAgD,OAAhD;AAGA,SAASC,KAAT,QAAsB,2CAAtB;AACA,SACEC,YADF,EAEEC,cAFF,EAIEC,gBAJF,QAOO,iBAPP;AAQA,SAASC,WAAT,QAAqD,aAArD;AACA,SAASC,UAAT,QAA2B,0DAA3B;AAEA,SAASC,gBAAT,QAAgD,+DAAhD;AAEA,SAASC,UAAT,EAAqBC,aAArB,QAA0C,cAA1C;AACA,SAASC,UAAT,EAAqBC,WAArB,EAAkCC,QAAlC,QAAwD,YAAxD;AAEA,MAAMC,UAAU,GAAGJ,aAAnB;AACA,MAAMK,QAAQ,GAAGL,aAAjB,C,CACA;;AACA,MAAMM,mBAAmB,GAAG,CAA5B;AACA,MAAMC,mBAAmB,GAAG,EAA5B,C,CACA;;AACA,MAAMC,mBAAmB,GAAG,IAA5B,C,CACA;;AACA,MAAMC,sBAAsB,GAAG,GAA/B;AACA,MAAMC,sBAAsB,GAAG,IAA/B,C,CACA;;AACA,MAAMC,mBAAmB,GAAG,CAA5B;AACA,MAAMC,mBAAmB,GAAG,EAA5B,C,CAEA;AACA;AACA;;AACA,MAAMC,qBAAqB,GAAG,GAA9B;AAEA;AACA;AACA;;AAgDA;AACA;AACA;AACA,SAASC,4BAAT,CACEC,IADF,EAEEC,KAFF,EAGEC,MAHF,EAIEC,UAJF,EAKEC,OALF,EAME;EACA;EACA,MAAMC,QAAQ,GAAGxB,WAAW,CAACmB,IAAD,EAAO,EAAP,CAA5B,CAFA,CAGA;;EACA,MAAMM,oBAAoB,GAAIL,KAAK,IAAII,QAAQ,CAACJ,KAAT,GAAiB,CAArB,CAAN,GAAiC,EAA9D;EACA,MAAMM,qBAAqB,GAAGL,MAAM,GAAGC,UAAvC,CALA,CAOA;;EACA,MAAMK,WAAW,GAAGC,IAAI,CAACC,GAAL,CAASH,qBAAT,EAAgCD,oBAAhC,CAApB;EACA,OAAO;IACLK,QAAQ,EAAEF,IAAI,CAACC,GAAL,CAASF,WAAT,EAAsBJ,OAAtB,aAAsBA,OAAtB,cAAsBA,OAAtB,GAAiCI,WAAjC,CADL;IAELI,WAAW,EAAEP;EAFR,CAAP;AAID;AAED;AACA;AACA;;;AACA,OAAO,SAASQ,SAAT,CAAmBC,IAAnB,EAAsCC,KAAtC,EAA4D;EAAA;;EACjE,MAAM;IAAEC,IAAF;IAAQC,IAAI,EAAEC,GAAd;IAAmBC,QAAnB;IAA6BC,QAA7B;IAAuCC,WAAvC;IAAoDC,WAAW,GAAG,CAAlE;IAAqEC,SAArE;IAAgFC,QAAQ,GAAG;EAA3F,IAAiGV,IAAvG;EACA,MAAMW,aAAa,GAAGT,IAAI,KAAKpC,gBAAgB,CAAC8C,UAAhD;EACA,MAAMC,gBAAgB,GAAG,CAACC,OAAO,eAACd,IAAI,CAACd,IAAN,+CAAC,WAAW6B,SAAZ,CAAjC;EACA,MAAMC,SAAS,GAAGhB,IAAI,CAACiB,QAAL,KAAkBrD,YAAY,CAACsD,IAAjD;EACA,MAAMC,UAAU,GAAGnB,IAAI,CAACiB,QAAL,KAAkBrD,YAAY,CAACwD,OAAlD;EAEA,IAAI;IAAEC,UAAF;IAAcC,QAAd;IAAwBC,SAAS,GAAG;EAApC,IAA0CvB,IAA9C;;EAEA,IAAIgB,SAAJ,EAAe;IACb,CAACK,UAAD,EAAaC,QAAb,IAAyB,CAACA,QAAD,EAAWD,UAAX,CAAzB;EACD;;EAED,IAAIG,EAAJ;EACA,IAAIC,KAAJ;;EAEA,MAAMC,OAAoB,GAAIC,CAAD,IAAc;IACzC,MAAMC,GAAG,GAAGjB,aAAa,GAAGgB,CAAC,CAACE,IAAF,CAAO1C,KAAV,GAAkBwC,CAAC,CAACE,IAAF,CAAOzC,MAAlD;;IACA,MAAM0C,IAAI,GAAG1B,GAAG,IAAIO,aAAa,GAAG,CAAH,GAAO,CAAC,CAAzB,CAAhB;;IAEA,IAAIoB,OAAO,GAAGJ,CAAC,CAACK,IAAF,CAAO,CAAP,EAAUC,MAAxB;IACA,IAAIC,OAAO,GAAGH,OAAO,GAAG,CAAxB;IAEA,IAAII,OAAO,GAAG,CAAd;;IAEA,IAAIzB,QAAQ,KAAK,CAAjB,EAAoB;MAClB,IAAI0B,MAAM,GAAGR,GAAG,GAAGS,gBAAnB;MACA,IAAIC,QAAQ,GAAG3C,IAAI,CAAC4C,GAAL,CAAS5C,IAAI,CAAC6C,KAAL,CAAWJ,MAAM,GAAG1B,QAApB,CAAT,CAAf;MAEAyB,OAAO,GAAGJ,OAAO,GAAGO,QAAV,GAAqB,CAArB,GAAyB3C,IAAI,CAAC8C,IAAL,CAAUV,OAAO,GAAGO,QAApB,CAAnC;IACD;;IAED,IAAII,MAAgB,GAAG,EAAvB,CAhByC,CAkBzC;;IACAf,CAAC,CAACK,IAAF,CAAO,CAAP,EAAUW,OAAV,CAAkB,CAACC,CAAD,EAAIC,CAAJ,KAAU;MAC1B,IAAIC,UAAU,GAAGX,OAAO,KAAK,CAAZ,IAAiB,CAACzB,QAAQ,GAAG,CAAX,GAAemC,CAAf,GAAmBX,OAAO,GAAGW,CAA9B,IAAmCV,OAAnC,GAA6C,CAA/E;;MAEA,IAAI,CAACW,UAAL,EAAiB;QACfJ,MAAM,CAACK,IAAP,CAAYF,CAAZ;MACD;IACF,CAND;IAQA,OAAOf,IAAI,KAAK,CAAT,GAAaY,MAAb,GAAsBA,MAAM,CAACM,OAAP,EAA7B;EACD,CA5BD,CAhBiE,CA8CjE;;;EACA,MAAMC,OAAoB,GAAG,CAACtB,CAAD,EAAIe,MAAJ,EAAYQ,OAAZ,EAAqBC,UAArB,EAAiCC,SAAjC,KAA+C;IAC1E,IAAIpD,IAAI,CAACqD,SAAT,EAAoB;MAClB;MACA;MACA,IAAIC,MAAM,GAAG3B,CAAC,CAAC4B,MAAF,CAASC,CAAtB;MACA,IAAIC,IAAI,GAAGH,MAAM,CAAC1D,GAAlB;MACA,IAAI8D,IAAI,GAAGJ,MAAM,CAACK,GAAlB;MAEAL,MAAM,CAAC1D,GAAP,GAAa+B,CAAC,CAACK,IAAF,CAAO,CAAP,EAAU,CAAV,CAAb;MACAsB,MAAM,CAACK,GAAP,GAAahC,CAAC,CAACK,IAAF,CAAO,CAAP,EAAUL,CAAC,CAACK,IAAF,CAAO,CAAP,EAAUC,MAAV,GAAmB,CAA7B,CAAb;MAEA,IAAI2B,IAAI,GAAG5F,UAAU,CAAC2D,CAAD,EAAIe,MAAJ,EAAYQ,OAAZ,EAAqBC,UAArB,EAAiCC,SAAjC,CAArB,CAVkB,CAYlB;;MACAE,MAAM,CAAC1D,GAAP,GAAa6D,IAAb;MACAH,MAAM,CAACK,GAAP,GAAaD,IAAb;MAEA,OAAOE,IAAP;IACD;;IAED,OAAOlB,MAAM,CAACmB,GAAP,CAAYjB,CAAD,IAAOrC,WAAW,CAAC,CAAD,EAAIqC,CAAJ,CAA7B,CAAP;EACD,CArBD,CA/CiE,CAsEjE;;;EACA,MAAMkB,MAAmB,GAAG,CAACnC,CAAD,EAAI/B,GAAJ,EAAS+D,GAAT,KAAiB;IAC3C/D,GAAG,GAAG,CAAN;IACA+D,GAAG,GAAGhE,IAAI,CAACgE,GAAL,CAAS,CAAT,EAAYhC,CAAC,CAACK,IAAF,CAAO,CAAP,EAAUC,MAAV,GAAmB,CAA/B,CAAN;IAEA,IAAI8B,SAAS,GAAG,CAAhB,CAJ2C,CAM3C;;IACA7F,UAAU,CAACyD,CAAC,CAACK,IAAF,CAAO,CAAP,EAAUC,MAAX,EAAmBZ,UAAnB,EAA+B9C,UAA/B,EAA2C,CAA3C,EAA8C,CAACyF,EAAD,EAAKC,MAAL,EAAaC,MAAb,KAAwB;MAC9EH,SAAS,GAAGE,MAAM,GAAGC,MAAM,GAAG,CAA9B;IACD,CAFS,CAAV,CAP2C,CAW3C;;IACA,IAAIC,EAAE,GAAGR,GAAG,GAAG/D,GAAf;;IAEA,IAAImE,SAAS,KAAK,GAAlB,EAAuB;MACrBnE,GAAG,IAAIuE,EAAP;IACD,CAFD,MAEO;MACL,IAAIC,OAAO,GAAG,KAAK,IAAIL,SAAS,GAAG,CAArB,CAAd;MACA,IAAIM,MAAM,GAAG,CAACD,OAAO,GAAGD,EAAV,GAAeA,EAAhB,IAAsB,CAAnC;MAEAvE,GAAG,IAAIyE,MAAP;MACAV,GAAG,IAAIU,MAAP;IACD;;IAED,OAAO,CAACzE,GAAD,EAAM+D,GAAN,CAAP;EACD,CAzBD;;EA2BA,IAAIW,QAAQ,GAAG,CAACC,UAAD,EAAqBC,QAArB,KAA0C;IACvD,IAAIC,GAAG,GAAGC,KAAK,CAACC,IAAN,CAAW;MAAE1C,MAAM,EAAEuC;IAAV,CAAX,EAAiC,OAAO;MAChDI,IAAI,EAAEF,KAAK,CAACH,UAAD,CAAL,CAAkBM,IAAlB,CAAuB,CAAvB,CAD0C;MAEhDC,IAAI,EAAEJ,KAAK,CAACH,UAAD,CAAL,CAAkBM,IAAlB,CAAuB,CAAvB;IAF0C,CAAP,CAAjC,CAAV;IAKA3G,UAAU,CAACqG,UAAD,EAAalD,UAAb,EAAyB9C,UAAzB,EAAqC,IAArC,EAA2C,CAACwG,QAAD,EAAWC,WAAX,EAAwBC,WAAxB,KAAwC;MAC3F/G,UAAU,CAACsG,QAAD,EAAWlD,QAAX,EAAqB9C,QAArB,EAA+B,IAA/B,EAAqC,CAAC0G,MAAD,EAASC,SAAT,EAAoBC,SAApB,KAAkC;QAC/EX,GAAG,CAACS,MAAD,CAAH,CAAYN,IAAZ,CAAiBG,QAAjB,IAA6BC,WAAW,GAAGC,WAAW,GAAGE,SAAzD;QACAV,GAAG,CAACS,MAAD,CAAH,CAAYJ,IAAZ,CAAiBC,QAAjB,IAA6BE,WAAW,GAAGG,SAA3C;MACD,CAHS,CAAV;IAID,CALS,CAAV;IAOA,OAAOX,GAAP;EACD,CAdD;;EAgBA,IAAIY,QAAQ,GAAG,CAACd,UAAD,EAAqBC,QAArB,KAA0C;IACvD,IAAIC,GAAG,GAAGC,KAAK,CAACC,IAAN,CAAW;MAAE1C,MAAM,EAAEuC;IAAV,CAAX,EAAiC,OAAO;MAChDI,IAAI,EAAEF,KAAK,CAACH,UAAD,CAAL,CAAkBM,IAAlB,CAAuB,CAAvB,CAD0C;MAEhDC,IAAI,EAAEJ,KAAK,CAACH,UAAD,CAAL,CAAkBM,IAAlB,CAAuB,CAAvB;IAF0C,CAAP,CAAjC,CAAV;IAKA3G,UAAU,CAACqG,UAAD,EAAalD,UAAb,EAAyB9C,UAAzB,EAAqC,IAArC,EAA2C,CAACwG,QAAD,EAAWC,WAAX,EAAwBC,WAAxB,KAAwC;MAC3F/G,UAAU,CAACsG,QAAD,EAAWlD,QAAX,EAAqB9C,QAArB,EAA+B,IAA/B,EAAqC,CAAC0G,MAAD,EAASC,SAAT,EAAoBC,SAApB,KAAkC;QAC/EX,GAAG,CAACS,MAAD,CAAH,CAAYN,IAAZ,CAAiBG,QAAjB,IAA6BC,WAA7B;QACAP,GAAG,CAACS,MAAD,CAAH,CAAYJ,IAAZ,CAAiBC,QAAjB,IAA6BE,WAA7B;MACD,CAHS,CAAV;IAID,CALS,CAAV;IAOA,OAAOR,GAAP;EACD,CAdD;;EAgBA,MAAMa,mBAAmB,GAAG3E,aAAa,GAAG/B,sBAAH,GAA4BC,sBAArE;EACA,MAAM0G,gBAAgB,GAAG5E,aAAa,GAAG7B,mBAAH,GAAyBC,mBAA/D;EAEA,IAAIyG,aAA+D,GAAG,EAAtE;EACA,IAAIC,UAAsF,GAAG,EAA7F;EACA,IAAIC,WAAW,GAAG,CAAlB;EACA,IAAIC,MAAuB,GAAG,EAA9B;EACA,IAAI9F,QAAQ,0CAAGG,IAAI,CAACd,IAAR,gDAAG,YAAW6B,SAAd,uEAA2BrC,mBAAvC;EACA,IAAIkH,WAAW,GAAGL,gBAAlB,CA1IiE,CA4IjE;;EACA,IAAIM,MAAM,GAAGC,QAAb;EACA,IAAIC,MAAM,GAAGD,QAAb;EAEA,IAAIE,eAAe,GAAG1F,QAAQ,IAAI,IAAlC;EAEA,IAAI2F,eAAe,GAAGD,eAAe,GACjC;IACEnB,IAAI,EAAE;MACJqB,IAAI,EAAE,CADF;MAEJC,MAAM,EAAE,CAACxE,CAAD,EAAWyE,SAAX,KAAiCX,UAAU,CAACW,SAAD,CAAV,CAAuBvB;IAF5D,CADR;IAKEwB,MAAM,EAAE;MACNH,IAAI,EAAE,CADA;MAENC,MAAM,EAAE,CAACxE,CAAD,EAAWyE,SAAX,KAAiCX,UAAU,CAACW,SAAD,CAAV,CAAuBC;IAF1D;EALV,CADiC,GAWjC,EAXJ;EAaA,IAAIC,WAAW,GAAG5I,KAAK,CAAC6I,KAAN,CAAYC,IAAZ,CAAkB;IAClCC,MAAM,EAAElF,SAD0B;IAElCmF,IAAI;MACFC,EAAE,EAAE;QACFT,IAAI,EAAE,CADJ;QAEFC,MAAM,EAAE,CAACxE,CAAD,EAAIyE,SAAJ,KAAkBZ,aAAa,CAACY,SAAD,CAAb,CAA0BxB;MAFlD,CADF;MAKFE,IAAI,EAAE;QACJoB,IAAI,EAAE,CADF;QAEJC,MAAM,EAAE,CAACxE,CAAD,EAAIyE,SAAJ,KAAkBZ,aAAa,CAACY,SAAD,CAAb,CAA0BtB;MAFhD;IALJ,GASCmB,eATD,CAF8B;IAalC;IACAW,IAAI,EAAE,CAACjF,CAAD,EAAIyE,SAAJ,EAAeS,OAAf,EAAwBC,GAAxB,EAA6BC,GAA7B,EAAkCC,GAAlC,EAAuCC,GAAvC,KAA+C;MACnD;MACA;MACAH,GAAG,IAAInF,CAAC,CAACE,IAAF,CAAOqF,IAAd;MACAH,GAAG,IAAIpF,CAAC,CAACE,IAAF,CAAOkF,GAAd;MAEA,IAAII,GAAG,GAAGxF,CAAC,CAACK,IAAF,CAAOoE,SAAP,EAAkBS,OAAlB,CAAV,CANmD,CAOnD;;MACA,IAAIlG,aAAJ,EAAmB;QACjBkF,MAAM,GAAGlG,IAAI,CAACC,GAAL,CAASiG,MAAT,EAAiBsB,GAAG,GAAG,CAAN,GAAUxF,CAAC,CAACE,IAAF,CAAOzC,MAAP,IAAiB2H,GAAG,GAAGE,GAAvB,CAAV,GAAwCF,GAAzD,CAAT;QACAhB,MAAM,GAAGiB,GAAT;MACD,CAHD,MAGO;QACLnB,MAAM,GAAGoB,GAAT;QACAlB,MAAM,GAAGpG,IAAI,CAACC,GAAL,CAASmG,MAAT,EAAiBoB,GAAG,GAAG,CAAN,GAAUL,GAAV,GAAgBnF,CAAC,CAACE,IAAF,CAAO1C,KAAP,IAAgB2H,GAAG,GAAGE,GAAtB,CAAjC,CAAT;MACD;;MAED,IAAII,OAAO,GAAG;QAAE5D,CAAC,EAAEsD,GAAL;QAAUO,CAAC,EAAEN,GAAb;QAAkBO,CAAC,EAAEN,GAArB;QAA0BO,CAAC,EAAEN,GAA7B;QAAkCO,IAAI,EAAEpB,SAAxC;QAAmDqB,IAAI,EAAEZ;MAAzD,CAAd;MACArF,EAAE,CAACkG,GAAH,CAAON,OAAP;;MAEA,IAAI3G,SAAS,KAAK5C,cAAc,CAAC8J,KAAjC,EAAwC;QACtC;QACA,MAAMzI,IAAI,GAAGqB,WAAW,CACtB6F,SADsB,EAEtB/F,QAAQ,CAAC+F,SAAD,EAAYS,OAAZ,CAAR,IAAiC1F,UAAU,GAAGyG,aAAa,CAAExB,SAAF,CAAb,CAA0BS,OAA1B,CAAH,GAAyC,CAApF,CAFsB,CAAxB;QAIAjB,WAAW,GAAGjG,IAAI,CAACC,GAAL,CAASgG,WAAT,EAAsBjG,IAAI,CAACkI,KAAL,CAAWvC,mBAAmB,IAAI3E,aAAa,GAAGqG,GAAH,GAASC,GAA1B,CAA9B,CAAtB,CAAd;;QAEA,IAAItB,MAAM,CAACkB,OAAD,CAAN,KAAoBiB,SAAxB,EAAmC;UACjCnC,MAAM,CAACkB,OAAD,CAAN,GAAkB,EAAlB;QACD;;QACDlB,MAAM,CAACkB,OAAD,CAAN,CAAgBT,SAAhB,IAA6B;UAAElH,IAAI,EAAEA,IAAR;UAAc6I,KAAK,EAAE1H,QAAQ,CAAC+F,SAAD,EAAYS,OAAZ,CAA7B;UAAmDmB,MAAM,EAAE;QAA3D,CAA7B,CAXsC,CAatC;;QACA,IAAInH,gBAAJ,EAAsB;UACpB,MAAM;YAAEhB,QAAQ,EAAEoI,cAAZ;YAA4BnI;UAA5B,IAA4Cb,4BAA4B,CAC5E0G,MAAM,CAACkB,OAAD,CAAN,CAAgBT,SAAhB,EAA2BlH,IADiD,EAE5E6G,MAAM,IAAIpF,aAAa,GAAGhC,mBAAH,GAAyB,CAA1C,CAAN,IAAsDgC,aAAa,GAAG,CAAH,GAAOiF,WAA1E,CAF4E,EAG5EC,MAAM,IAAIlF,aAAa,GAAG,CAAH,GAAOhC,mBAAxB,CAAN,IAAsDgC,aAAa,GAAGiF,WAAH,GAAiB,CAApF,CAH4E,EAI5E,CAJ4E,CAA9E,CADoB,CAQpB;;UACAD,MAAM,CAACkB,OAAD,CAAN,CAAgBT,SAAhB,EAA2BtG,WAA3B,GAAyCA,WAAzC,CAToB,CAWpB;;UACA,IAAIoI,YAAY,GAAGvI,IAAI,CAACkI,KAAL,CAAWlI,IAAI,CAACC,GAAL,CAASC,QAAT,EAAmBnB,mBAAnB,EAAwCuJ,cAAxC,CAAX,CAAnB,CAZoB,CAcpB;UACA;UACA;;UACAvC,WAAW,GAAIwC,YAAY,GAAGrI,QAAhB,IAA6BqI,YAAY,GAAG,EAA5C,CAAd,CAjBoB,CAmBpB;;UACArI,QAAQ,GAAGqI,YAAX;QACD,CArBD,MAqBO;UACLvC,MAAM,CAACkB,OAAD,CAAN,CAAgBT,SAAhB,EAA2BtG,WAA3B,GAAyC/B,WAAW,CAAC4H,MAAM,CAACkB,OAAD,CAAN,CAAgBT,SAAhB,EAA2BlH,IAA5B,EAAkCW,QAAlC,CAApD;QACD;;QAED,IAAIsI,WAAW,GAAGxH,aAAa,GAAG,CAAH,GAAO,CAAChB,IAAI,CAACkI,KAAL,CAAW7I,qBAAqB,GAAGa,QAAnC,CAAvC;QACA,IAAIkI,KAAK,GAAG1H,QAAQ,CAAC+F,SAAD,EAAYS,OAAZ,CAApB;;QAEA,IAAIkB,KAAK,IAAI,IAAb,EAAmB;UACjB;UACA,MAAMvE,CAAC,GACL7B,CAAC,CAACE,IAAF,CAAOqF,IAAP,IAAevG,aAAa,GAAGmG,GAAG,GAAGE,GAAG,GAAG,CAAf,GAAmBe,KAAK,GAAG,CAAR,GAAYjB,GAAG,GAAGlB,WAAlB,GAAgCkB,GAAG,GAAGE,GAAN,GAAYpB,WAA3F,CADF;UAEA,MAAMyB,CAAC,GACL1F,CAAC,CAACE,IAAF,CAAOkF,GAAP,IACCpG,aAAa,GAAIoH,KAAK,GAAG,CAAR,GAAYhB,GAAG,GAAGE,GAAN,GAAYrB,WAAxB,GAAsCmB,GAAG,GAAGnB,WAAhD,GAA+DmB,GAAG,GAAGE,GAAG,GAAG,CAAZ,GAAgBkB,WAD7F,CADF,CAJiB,CAQjB;UACA;UACA;;UACA,MAAM;YACJrI,WAAW,GAAG;cACZX,KAAK,EAAE,CADK;cAEZiJ,uBAAuB,EAAE,CAFb;cAGZC,wBAAwB,EAAE;YAHd;UADV,IAMF1C,MAAM,CAACkB,OAAD,CAAN,CAAgBT,SAAhB,CANJ,CAXiB,CAmBjB;UACA;;UACA,IAAIkC,OAAO,GAAG,CAAd;UAAA,IACEC,OAAO,GAAG,CADZ;;UAGA,IAAI5H,aAAJ,EAAmB;YACjB;YACA2H,OAAO,GAAIxI,WAAW,CAACX,KAAZ,GAAoBuG,WAArB,GAAoC,CAA9C,CAFiB,CAIjB;;YACA6C,OAAO,GACLR,KAAK,GAAG,CAAR,GACI,CAACjI,WAAW,CAACsI,uBAAZ,GAAsCtI,WAAW,CAACuI,wBAAnD,IAA+E3C,WADnF,GAEI,CAHN;UAID,CATD,MASO;YACL;YACA6C,OAAO,GAAI,CAACzI,WAAW,CAACsI,uBAAZ,GAAsCtI,WAAW,CAACuI,wBAAnD,IAA+E3C,WAAhF,GAA+F,CAAzG,CAFK,CAIL;;YACA4C,OAAO,GAAGP,KAAK,GAAG,CAAR,GAAYjI,WAAW,CAACX,KAAZ,GAAoBuG,WAAhC,GAA8C,CAAxD;UACD,CAvCgB,CAyCjB;;;UACAC,MAAM,CAACkB,OAAD,CAAN,CAAgBT,SAAhB,EAA2B5C,CAA3B,GAA+BA,CAA/B;UACAmC,MAAM,CAACkB,OAAD,CAAN,CAAgBT,SAAhB,EAA2BiB,CAA3B,GAA+BA,CAA/B;UACA1B,MAAM,CAACkB,OAAD,CAAN,CAAgBT,SAAhB,EAA2BvE,IAA3B,GAAkC;YAChC2B,CAAC,EAAEA,CAAC,GAAG8E,OADyB;YAEhCjB,CAAC,EAAEA,CAAC,GAAGkB,OAFyB;YAGhCjB,CAAC,EAAExH,WAAW,CAACX,KAAZ,GAAoBuG,WAHS;YAIhC6B,CAAC,EAAE,CAACzH,WAAW,CAACsI,uBAAZ,GAAsCtI,WAAW,CAACuI,wBAAnD,IAA+E3C;UAJlD,CAAlC;QAMD;MACF;IACF;EA/HiC,CAAlB,CAAlB;;EAkIA,MAAM8C,IAAI,GAAI7G,CAAD,IAAc;IACzB,IAAI8G,IAAI,GAAG9G,CAAC,CAAC8G,IAAb;IACAA,IAAI,CAACC,KAAL,CAAWC,QAAX,GAAsB,QAAtB;IACAhH,CAAC,CAACiH,IAAF,CAAOC,gBAAP,CAAwB,cAAxB,EAAwClG,OAAxC,CAAiDmG,EAAD,IAAQ;MACrDA,EAAD,CAAoBJ,KAApB,CAA0BK,YAA1B,GAAyC,GAAzC;IACD,CAFD;EAGD,CAND;;EAQA,MAAMC,MAAoB,GAAG;IAC3BxF,CAAC,EAAE,KADwB;IAE3B6D,CAAC,EAAE,KAFwB;IAG3B4B,IAAI,EAAE;MACJzF,CAAC,EAAE,KADC;MAEJ6D,CAAC,EAAE;IAFC,CAHqB;IAO3BR,OAAO,EAAE,CAAClF,CAAD,EAAIyE,SAAJ,KAAkB;MACzB,IAAIA,SAAS,KAAK,CAAlB,EAAqB;QACnB3E,KAAK,GAAG,IAAR;QAEA,IAAIyH,EAAE,GAAGvH,CAAC,CAACqH,MAAF,CAAS9B,IAAT,GAAiB7E,gBAA1B;QACA,IAAI8G,EAAE,GAAGxH,CAAC,CAACqH,MAAF,CAASjC,GAAT,GAAgB1E,gBAAzB;QAEAb,EAAE,CAAC4H,GAAH,CAAOF,EAAP,EAAWC,EAAX,EAAe,CAAf,EAAkB,CAAlB,EAAsBE,CAAD,IAAO;UAC1B,IAAIhL,WAAW,CAAC6K,EAAD,EAAKC,EAAL,EAASE,CAAC,CAAC7F,CAAX,EAAc6F,CAAC,CAAChC,CAAhB,EAAmBgC,CAAC,CAAC7F,CAAF,GAAM6F,CAAC,CAAC/B,CAA3B,EAA8B+B,CAAC,CAAChC,CAAF,GAAMgC,CAAC,CAAC9B,CAAtC,CAAf,EAAyD;YACvD9F,KAAK,GAAG4H,CAAR;UACD;QACF,CAJD;MAKD;;MAED,OAAO5H,KAAK,IAAI2E,SAAS,KAAK3E,KAAK,CAAC+F,IAA7B,GAAoC/F,KAAK,CAACgG,IAA1C,GAAiD,IAAxD;IACD,CAtB0B;IAuB3B6B,MAAM,EAAE;MACNzE,IAAI,EAAE,uBADA;MAENhD,IAAI,EAAE,CAACF,CAAD,EAAIyE,SAAJ,KAAkB;QACtB,IAAImD,SAAS,GAAG9H,KAAK,IAAI2E,SAAS,KAAK3E,KAAK,CAAC+F,IAA7C;QAEA,OAAO;UACLN,IAAI,EAAEqC,SAAS,GAAG9H,KAAK,CAAE+B,CAAP,GAAWnB,gBAAd,GAAiC,CAAC,EAD5C;UAEL0E,GAAG,EAAEwC,SAAS,GAAG9H,KAAK,CAAE4F,CAAP,GAAWhF,gBAAd,GAAiC,CAAC,EAF3C;UAGLlD,KAAK,EAAEoK,SAAS,GAAG9H,KAAK,CAAE6F,CAAP,GAAWjF,gBAAd,GAAiC,CAH5C;UAILjD,MAAM,EAAEmK,SAAS,GAAG9H,KAAK,CAAE8F,CAAP,GAAWlF,gBAAd,GAAiC;QAJ7C,CAAP;MAMD;IAXK;EAvBmB,CAA7B,CAzSiE,CA+UjE;;EACA,MAAMmH,SAAS,GAAI7H,CAAD,IAAc;IAAA;;IAC9BH,EAAE,GAAGA,EAAE,IAAI,IAAIlD,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmBqD,CAAC,CAACE,IAAF,CAAO1C,KAA1B,EAAiCwC,CAAC,CAACE,IAAF,CAAOzC,MAAxC,CAAX;IACAoC,EAAE,CAACiI,KAAH,GAF8B,CAI9B;;IACA9H,CAAC,CAAC+H,MAAF,CAAS/G,OAAT,CAAkBgH,CAAD,IAAO;MACtB;MACAA,CAAC,CAACC,MAAF,GAAW,IAAX;IACD,CAHD;;IAKA,IAAI5I,SAAJ,EAAe;MACb;MACAwE,aAAa,GAAG,CAAC,IAAD,EAAcqE,MAAd,CAAqBxE,QAAQ,CAAC1D,CAAC,CAACK,IAAF,CAAO,CAAP,EAAUC,MAAX,EAAmBN,CAAC,CAACK,IAAF,CAAOC,MAAP,GAAgB,CAAnC,CAA7B,CAAhB;IACD,CAHD,MAGO;MACLuD,aAAa,GAAG,CAAC,IAAD,EAAcqE,MAAd,CAAqBvF,QAAQ,CAAC3C,CAAC,CAACK,IAAF,CAAO,CAAP,EAAUC,MAAX,EAAmBN,CAAC,CAACK,IAAF,CAAOC,MAAP,GAAgB,CAAnC,CAA7B,CAAhB;IACD;;IAED,IAAI+D,eAAJ,EAAqB;MACnBP,UAAU,GAAG,CAAC,IAAD,CAAb,CADmB,CAGnB;;MACA,KAAK,IAAI5C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlB,CAAC,CAACK,IAAF,CAAOC,MAA3B,EAAmCY,CAAC,EAApC,EAAwC;QACtC,IAAIiH,MAAM,GAAInI,CAAC,CAACK,IAAF,CAAOa,CAAP,CAAD,CAAoCgB,GAApC,CAAwC,CAACkE,KAAD,EAAQgC,QAAR,KAAqB;UACxE,IAAIhC,KAAK,IAAI,IAAb,EAAmB;YACjB,OAAOzH,QAAQ,CAAEuC,CAAF,EAAKkH,QAAL,EAAehC,KAAf,CAAf;UACD;;UAED,OAAO,IAAP;QACD,CANY,CAAb;QAQAtC,UAAU,CAAC1C,IAAX,CAAgB;UACd8B,IAAI,EAAErE,WAAW,GAAG,CAAd,GAAkBsJ,MAAM,CAACjG,GAAP,CAAYmG,CAAD,IAAQA,CAAC,IAAI,IAAL,GAAYrM,KAAK,CAACqM,CAAD,EAAIxJ,WAAJ,CAAjB,GAAoC,IAAvD,CAAlB,GAAkFsJ,MAD1E;UAEdzD,MAAM,EAAEyD;QAFM,CAAhB;MAID;IACF;;IAEDnE,MAAM,GAAG,EAAT;IACA9F,QAAQ,2CAAGG,IAAI,CAACd,IAAR,gDAAG,YAAW6B,SAAd,yEAA2BrC,mBAAnC;IACAkH,WAAW,GAAGL,gBAAd;IACAM,MAAM,GAAGE,MAAM,GAAGD,QAAlB;EACD,CAzCD,CAhViE,CA2XjE;;;EACA,MAAMmE,IAAI,GAAItI,CAAD,IAAc;IACzB,IAAIlB,SAAS,KAAK5C,cAAc,CAAC8J,KAA7B,IAAsC9H,QAAQ,GAAGpB,mBAArD,EAA0E;MACxE;IACD;;IAEDkD,CAAC,CAACuI,GAAF,CAAMC,IAAN;IACAxI,CAAC,CAACuI,GAAF,CAAME,SAAN,GAAkBnK,KAAK,CAAC6J,MAAN,CAAa5K,IAAb,CAAkBmL,OAApC;IACA1I,CAAC,CAACuI,GAAF,CAAMI,IAAN,GAAc,GAAEzK,QAAS,MAAKI,KAAK,CAACsK,UAAN,CAAiBC,UAAW,EAA1D;IAEA,IAAIC,QAAqC,GAAG3C,SAA5C;IAAA,IACE4C,WAA2C,GAAG5C,SADhD;;IAGA,KAAK,MAAML,IAAX,IAAmB9B,MAAnB,EAA2B;MACzB,KAAK,MAAM6B,IAAX,IAAmB7B,MAAM,CAAC8B,IAAD,CAAzB,EAAiC;QAC/B,MAAM;UAAEvI,IAAF;UAAQ6I,KAAR;UAAevE,CAAC,GAAG,CAAnB;UAAsB6D,CAAC,GAAG,CAA1B;UAA6BxF,IAAI,GAAG;YAAE2B,CAAC,EAAE,CAAL;YAAQ6D,CAAC,EAAE,CAAX;YAAcC,CAAC,EAAE,CAAjB;YAAoBC,CAAC,EAAE;UAAvB;QAApC,IAAmE5B,MAAM,CAAC8B,IAAD,CAAN,CAAaD,IAAb,CAAzE;QAEA,IAAImD,KAAsB,GAAGhK,aAAa,GAAG,QAAH,GAAcoH,KAAK,KAAK,IAAV,IAAkBA,KAAK,GAAG,CAA1B,GAA8B,OAA9B,GAAwC,MAAhG;QACA,IAAI6C,QAA4B,GAAGjK,aAAa,GAC5CoH,KAAK,KAAK,IAAV,IAAkBA,KAAK,GAAG,CAA1B,GACE,KADF,GAEE,YAH0C,GAI5C,QAJJ;;QAMA,IAAI4C,KAAK,KAAKF,QAAd,EAAwB;UACtB9I,CAAC,CAACuI,GAAF,CAAMW,SAAN,GAAkBJ,QAAQ,GAAGE,KAA7B;QACD;;QAED,IAAIC,QAAQ,KAAKF,WAAjB,EAA8B;UAC5B/I,CAAC,CAACuI,GAAF,CAAMY,YAAN,GAAqBJ,WAAW,GAAGE,QAAnC;QACD;;QAED,IAAInK,SAAS,KAAK5C,cAAc,CAACkN,MAAjC,EAAyC;UACvCpJ,CAAC,CAACuI,GAAF,CAAMc,QAAN,CAAe9L,IAAf,EAAqBsE,CAArB,EAAwB6D,CAAxB;QACD,CAFD,MAEO,IAAI5G,SAAS,KAAK5C,cAAc,CAACoN,IAAjC,EAAuC;UAC5C,IAAIC,eAAe,GAAG,KAAtB,CAD4C,CAG5C;;UACA,KAAK,MAAMC,OAAX,IAAsBxF,MAAM,CAAC8B,IAAD,CAA5B,EAAoC;YAClC,MAAM2D,CAAC,GAAGzF,MAAM,CAAC8B,IAAD,CAAN,CAAa0D,OAAb,EAAsBtJ,IAAhC;;YAEA,IAAI,CAAC8D,MAAM,CAAC8B,IAAD,CAAN,CAAa0D,OAAb,EAAsBnD,MAAvB,IAAiCR,IAAI,KAAK2D,OAA1C,IAAqD/M,UAAU,CAACyD,IAAD,EAAOuJ,CAAP,CAAnE,EAA8E;cAC5EF,eAAe,GAAG,IAAlB;cACAvF,MAAM,CAAC8B,IAAD,CAAN,CAAaD,IAAb,EAAmBQ,MAAnB,GAA4B,IAA5B;cACA;YACD;UACF;;UAED,CAACkD,eAAD,IAAoBvJ,CAAC,CAACuI,GAAF,CAAMc,QAAN,CAAe9L,IAAf,EAAqBsE,CAArB,EAAwB6D,CAAxB,CAApB;QACD;MACF;IACF;;IAED1F,CAAC,CAACuI,GAAF,CAAMmB,OAAN;EACD,CArDD,CA5XiE,CAmbjE;;;EACA,MAAMC,kBAA2C,GAAG,CAClDC,qBADkD,EAElDC,wBAFkD,EAGlDC,qBAHkD,EAIlD9J,CAJkD,KAK/C;IACH,IAAIF,KAAJ,EAAW;MACT8J,qBAAqB,CAAC9J,KAAK,CAAC+F,IAAP,CAArB;MACAgE,wBAAwB,CAAC/J,KAAK,CAACgG,IAAP,CAAxB;MACAgE,qBAAqB;IACtB,CAJD,MAIO;MACLA,qBAAqB,CAAC,IAAD,CAArB;IACD;EACF,CAbD;;EAeA,IAAI7D,aAAiC,GAAG,IAAxC;;EAEA,SAAS8D,QAAT,CAAkBC,MAAlB,EAAuCC,cAAvC,EAAwE;IACtEhE,aAAa,GAAG,IAAhB;IACA,OAAO3J,gBAAgB,CAAC0N,MAAM,CAAC,CAAD,CAAP,EAAYC,cAAZ,EAA4B,CAAC;MAAEC;IAAF,CAAD,KAAgB;MACjEjE,aAAa,GAAGiE,MAAhB;IACD,CAFsB,CAAvB;EAGD;;EAED,OAAO;IACL7C,MADK;IAEL;IACAlF,MAHK;IAILb,OAJK;IAKLvB,OALK;IAOL4E,WAPK;IASL;IACAkC,IAVK;IAWLgB,SAXK;IAYLS,IAZK;IAaLqB,kBAbK;IAcLI;EAdK,CAAP;AAgBD"},"metadata":{},"sourceType":"module"}