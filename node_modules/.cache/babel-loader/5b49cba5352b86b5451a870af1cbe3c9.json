{"ast":null,"code":"import { capitalize } from 'lodash';\nimport { AlertState } from '@grafana/data';\nimport { GrafanaAlertState, mapStateWithReasonToBaseState, PromAlertingRuleState, PromRuleType } from 'app/types/unified-alerting-dto';\nimport { RULER_NOT_SUPPORTED_MSG } from './constants';\nexport function isAlertingRule(rule) {\n  return typeof rule === 'object' && rule.type === PromRuleType.Alerting;\n}\nexport function isRecordingRule(rule) {\n  return rule.type === PromRuleType.Recording;\n}\nexport function isAlertingRulerRule(rule) {\n  return typeof rule === 'object' && 'alert' in rule;\n}\nexport function isRecordingRulerRule(rule) {\n  return typeof rule === 'object' && 'record' in rule;\n}\nexport function isGrafanaRulerRule(rule) {\n  return typeof rule === 'object' && 'grafana_alert' in rule;\n}\nexport function alertInstanceKey(alert) {\n  return JSON.stringify(alert.labels);\n}\nexport function isRulerNotSupportedResponse(resp) {\n  var _resp$error, _resp$error$message;\n\n  return resp.error && ((_resp$error = resp.error) === null || _resp$error === void 0 ? void 0 : (_resp$error$message = _resp$error.message) === null || _resp$error$message === void 0 ? void 0 : _resp$error$message.includes(RULER_NOT_SUPPORTED_MSG));\n}\nexport function isGrafanaRuleIdentifier(identifier) {\n  return 'uid' in identifier;\n}\nexport function isCloudRuleIdentifier(identifier) {\n  return 'rulerRuleHash' in identifier;\n}\nexport function isPrometheusRuleIdentifier(identifier) {\n  return 'ruleHash' in identifier;\n}\nexport function alertStateToReadable(state) {\n  if (state === PromAlertingRuleState.Inactive) {\n    return 'Normal';\n  }\n\n  return capitalize(state);\n}\nexport const flattenRules = rules => {\n  return rules.reduce((acc, {\n    dataSourceName,\n    name: namespaceName,\n    groups\n  }) => {\n    groups.forEach(({\n      name: groupName,\n      rules\n    }) => {\n      rules.forEach(rule => {\n        if (isAlertingRule(rule)) {\n          acc.push({\n            dataSourceName,\n            namespaceName,\n            groupName,\n            rule\n          });\n        }\n      });\n    });\n    return acc;\n  }, []);\n};\nexport function alertStateToState(state) {\n  let key;\n\n  if (Object.values(AlertState).includes(state)) {\n    key = state;\n  } else {\n    key = mapStateWithReasonToBaseState(state);\n  }\n\n  return alertStateToStateMap[key];\n}\nconst alertStateToStateMap = {\n  [PromAlertingRuleState.Inactive]: 'good',\n  [PromAlertingRuleState.Firing]: 'bad',\n  [PromAlertingRuleState.Pending]: 'warning',\n  [GrafanaAlertState.Alerting]: 'bad',\n  [GrafanaAlertState.Error]: 'bad',\n  [GrafanaAlertState.NoData]: 'info',\n  [GrafanaAlertState.Normal]: 'good',\n  [GrafanaAlertState.Pending]: 'warning',\n  [AlertState.NoData]: 'info',\n  [AlertState.Paused]: 'warning',\n  [AlertState.Alerting]: 'bad',\n  [AlertState.OK]: 'good',\n  [AlertState.Pending]: 'warning',\n  [AlertState.Unknown]: 'info'\n};\nexport function getFirstActiveAt(promRule) {\n  if (!promRule.alerts) {\n    return null;\n  }\n\n  return promRule.alerts.reduce((prev, alert) => {\n    const isNotNormal = mapStateWithReasonToBaseState(alert.state) !== GrafanaAlertState.Normal;\n\n    if (alert.activeAt && isNotNormal) {\n      const activeAt = new Date(alert.activeAt);\n\n      if (prev === null || prev.getTime() > activeAt.getTime()) {\n        return activeAt;\n      }\n    }\n\n    return prev;\n  }, null);\n}\n/**\n * A rule group is \"federated\" when it has at least one \"source_tenants\" entry, federated rule groups will evaluate rules in multiple tenants\n * Non-federated rules do not have this property\n *\n * see https://grafana.com/docs/metrics-enterprise/latest/tenant-management/tenant-federation/#cross-tenant-alerting-and-recording-rule-federation\n */\n\nexport function isFederatedRuleGroup(group) {\n  return Array.isArray(group.source_tenants);\n}","map":{"version":3,"names":["capitalize","AlertState","GrafanaAlertState","mapStateWithReasonToBaseState","PromAlertingRuleState","PromRuleType","RULER_NOT_SUPPORTED_MSG","isAlertingRule","rule","type","Alerting","isRecordingRule","Recording","isAlertingRulerRule","isRecordingRulerRule","isGrafanaRulerRule","alertInstanceKey","alert","JSON","stringify","labels","isRulerNotSupportedResponse","resp","error","message","includes","isGrafanaRuleIdentifier","identifier","isCloudRuleIdentifier","isPrometheusRuleIdentifier","alertStateToReadable","state","Inactive","flattenRules","rules","reduce","acc","dataSourceName","name","namespaceName","groups","forEach","groupName","push","alertStateToState","key","Object","values","alertStateToStateMap","Firing","Pending","Error","NoData","Normal","Paused","OK","Unknown","getFirstActiveAt","promRule","alerts","prev","isNotNormal","activeAt","Date","getTime","isFederatedRuleGroup","group","Array","isArray","source_tenants"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/utils/rules.ts"],"sourcesContent":["import { capitalize } from 'lodash';\n\nimport { AlertState } from '@grafana/data';\nimport {\n  Alert,\n  AlertingRule,\n  CloudRuleIdentifier,\n  CombinedRuleGroup,\n  GrafanaRuleIdentifier,\n  PrometheusRuleIdentifier,\n  PromRuleWithLocation,\n  RecordingRule,\n  Rule,\n  RuleIdentifier,\n  RuleNamespace,\n} from 'app/types/unified-alerting';\nimport {\n  GrafanaAlertState,\n  GrafanaAlertStateWithReason,\n  mapStateWithReasonToBaseState,\n  PromAlertingRuleState,\n  PromRuleType,\n  RulerAlertingRuleDTO,\n  RulerGrafanaRuleDTO,\n  RulerRecordingRuleDTO,\n  RulerRuleDTO,\n} from 'app/types/unified-alerting-dto';\n\nimport { State } from '../components/StateTag';\n\nimport { RULER_NOT_SUPPORTED_MSG } from './constants';\nimport { AsyncRequestState } from './redux';\n\nexport function isAlertingRule(rule: Rule | undefined): rule is AlertingRule {\n  return typeof rule === 'object' && rule.type === PromRuleType.Alerting;\n}\n\nexport function isRecordingRule(rule: Rule): rule is RecordingRule {\n  return rule.type === PromRuleType.Recording;\n}\n\nexport function isAlertingRulerRule(rule?: RulerRuleDTO): rule is RulerAlertingRuleDTO {\n  return typeof rule === 'object' && 'alert' in rule;\n}\n\nexport function isRecordingRulerRule(rule?: RulerRuleDTO): rule is RulerRecordingRuleDTO {\n  return typeof rule === 'object' && 'record' in rule;\n}\n\nexport function isGrafanaRulerRule(rule?: RulerRuleDTO): rule is RulerGrafanaRuleDTO {\n  return typeof rule === 'object' && 'grafana_alert' in rule;\n}\n\nexport function alertInstanceKey(alert: Alert): string {\n  return JSON.stringify(alert.labels);\n}\n\nexport function isRulerNotSupportedResponse(resp: AsyncRequestState<any>) {\n  return resp.error && resp.error?.message?.includes(RULER_NOT_SUPPORTED_MSG);\n}\n\nexport function isGrafanaRuleIdentifier(identifier: RuleIdentifier): identifier is GrafanaRuleIdentifier {\n  return 'uid' in identifier;\n}\n\nexport function isCloudRuleIdentifier(identifier: RuleIdentifier): identifier is CloudRuleIdentifier {\n  return 'rulerRuleHash' in identifier;\n}\n\nexport function isPrometheusRuleIdentifier(identifier: RuleIdentifier): identifier is PrometheusRuleIdentifier {\n  return 'ruleHash' in identifier;\n}\n\nexport function alertStateToReadable(state: PromAlertingRuleState | GrafanaAlertStateWithReason | AlertState): string {\n  if (state === PromAlertingRuleState.Inactive) {\n    return 'Normal';\n  }\n  return capitalize(state);\n}\n\nexport const flattenRules = (rules: RuleNamespace[]) => {\n  return rules.reduce<PromRuleWithLocation[]>((acc, { dataSourceName, name: namespaceName, groups }) => {\n    groups.forEach(({ name: groupName, rules }) => {\n      rules.forEach((rule) => {\n        if (isAlertingRule(rule)) {\n          acc.push({ dataSourceName, namespaceName, groupName, rule });\n        }\n      });\n    });\n    return acc;\n  }, []);\n};\n\nexport function alertStateToState(state: PromAlertingRuleState | GrafanaAlertStateWithReason | AlertState): State {\n  let key: PromAlertingRuleState | GrafanaAlertState | AlertState;\n  if (Object.values(AlertState).includes(state as AlertState)) {\n    key = state as AlertState;\n  } else {\n    key = mapStateWithReasonToBaseState(state as GrafanaAlertStateWithReason | PromAlertingRuleState);\n  }\n\n  return alertStateToStateMap[key];\n}\n\nconst alertStateToStateMap: Record<PromAlertingRuleState | GrafanaAlertState | AlertState, State> = {\n  [PromAlertingRuleState.Inactive]: 'good',\n  [PromAlertingRuleState.Firing]: 'bad',\n  [PromAlertingRuleState.Pending]: 'warning',\n  [GrafanaAlertState.Alerting]: 'bad',\n  [GrafanaAlertState.Error]: 'bad',\n  [GrafanaAlertState.NoData]: 'info',\n  [GrafanaAlertState.Normal]: 'good',\n  [GrafanaAlertState.Pending]: 'warning',\n  [AlertState.NoData]: 'info',\n  [AlertState.Paused]: 'warning',\n  [AlertState.Alerting]: 'bad',\n  [AlertState.OK]: 'good',\n  [AlertState.Pending]: 'warning',\n  [AlertState.Unknown]: 'info',\n};\n\nexport function getFirstActiveAt(promRule: AlertingRule) {\n  if (!promRule.alerts) {\n    return null;\n  }\n  return promRule.alerts.reduce((prev, alert) => {\n    const isNotNormal =\n      mapStateWithReasonToBaseState(alert.state as GrafanaAlertStateWithReason) !== GrafanaAlertState.Normal;\n    if (alert.activeAt && isNotNormal) {\n      const activeAt = new Date(alert.activeAt);\n      if (prev === null || prev.getTime() > activeAt.getTime()) {\n        return activeAt;\n      }\n    }\n    return prev;\n  }, null as Date | null);\n}\n\n/**\n * A rule group is \"federated\" when it has at least one \"source_tenants\" entry, federated rule groups will evaluate rules in multiple tenants\n * Non-federated rules do not have this property\n *\n * see https://grafana.com/docs/metrics-enterprise/latest/tenant-management/tenant-federation/#cross-tenant-alerting-and-recording-rule-federation\n */\nexport function isFederatedRuleGroup(group: CombinedRuleGroup) {\n  return Array.isArray(group.source_tenants);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}