{"ast":null,"code":"import { map } from 'rxjs';\nimport { ArrayVector, DataTransformerID, FieldType, incrRoundUp, incrRoundDn, DataFrameType, getFieldDisplayName, getValueFormat, formattedValueToString, durationToMilliseconds, parseDuration } from '@grafana/data';\nimport { ScaleDistribution } from '@grafana/schema';\nimport { HeatmapCellLayout, HeatmapCalculationMode } from './models.gen';\nimport { niceLinearIncrs, niceTimeIncrs } from './utils';\nexport const heatmapTransformer = {\n  id: DataTransformerID.heatmap,\n  name: 'Create heatmap',\n  description: 'calculate heatmap from source data',\n  defaultOptions: {},\n  operator: options => source => source.pipe(map(data => heatmapTransformer.transformer(options)(data))),\n  transformer: options => {\n    return data => {\n      const v = calculateHeatmapFromData(data, options);\n\n      if (options.keepOriginalData) {\n        return [v, ...data];\n      }\n\n      return [v];\n    };\n  }\n};\n\nfunction parseNumeric(v) {\n  return v === '+Inf' ? Infinity : v === '-Inf' ? -Infinity : +(v !== null && v !== void 0 ? v : 0);\n}\n\nexport function sortAscStrInf(aName, bName) {\n  return parseNumeric(aName) - parseNumeric(bName);\n}\n\n/** simple utility to get heatmap metadata from a frame */\nexport function readHeatmapRowsCustomMeta(frame) {\n  var _frame$meta$custom, _frame$meta;\n\n  return (_frame$meta$custom = frame === null || frame === void 0 ? void 0 : (_frame$meta = frame.meta) === null || _frame$meta === void 0 ? void 0 : _frame$meta.custom) !== null && _frame$meta$custom !== void 0 ? _frame$meta$custom : {};\n}\nexport function isHeatmapCellsDense(frame) {\n  let foundY = false;\n\n  for (let field of frame.fields) {\n    // dense heatmap frames can only have one of these fields\n    switch (field.name) {\n      case 'y':\n      case 'yMin':\n      case 'yMax':\n        if (foundY) {\n          return false;\n        }\n\n        foundY = true;\n    }\n  }\n\n  return foundY;\n}\n\n/** Given existing buckets, create a values style frame */\n// Assumes frames have already been sorted ASC and de-accumulated.\nexport function rowsToCellsHeatmap(opts) {\n  var _yFields$0$labels, _yFields$0$labels2, _opts$unit, _opts$value;\n\n  // TODO: handle null-filling w/ fields[0].config.interval?\n  const xField = opts.frame.fields[0];\n  const xValues = xField.values.toArray();\n  const yFields = opts.frame.fields.filter((f, idx) => f.type === FieldType.number && idx > 0); // similar to initBins() below\n\n  const len = xValues.length * yFields.length;\n  const xs = new Array(len);\n  const ys = new Array(len);\n  const counts2 = new Array(len);\n  const counts = yFields.map(field => field.values.toArray().slice()); // transpose\n\n  counts.forEach((bucketCounts, bi) => {\n    for (let i = 0; i < bucketCounts.length; i++) {\n      counts2[counts.length * i + bi] = bucketCounts[i];\n    }\n  });\n  const bucketBounds = Array.from({\n    length: yFields.length\n  }, (v, i) => i); // fill flat/repeating array\n\n  for (let i = 0, yi = 0, xi = 0; i < len; yi = ++i % bucketBounds.length) {\n    ys[i] = bucketBounds[yi];\n\n    if (yi === 0 && i >= bucketBounds.length) {\n      xi++;\n    }\n\n    xs[i] = xValues[xi];\n  } // this name determines whether cells are drawn above, below, or centered on the values\n\n\n  let ordinalFieldName = ((_yFields$0$labels = yFields[0].labels) === null || _yFields$0$labels === void 0 ? void 0 : _yFields$0$labels.le) != null ? 'yMax' : 'y';\n\n  switch (opts.layout) {\n    case HeatmapCellLayout.le:\n      ordinalFieldName = 'yMax';\n      break;\n\n    case HeatmapCellLayout.ge:\n      ordinalFieldName = 'yMin';\n      break;\n\n    case HeatmapCellLayout.unknown:\n      ordinalFieldName = 'y';\n      break;\n  }\n\n  const custom = {\n    yOrdinalDisplay: yFields.map(f => getFieldDisplayName(f, opts.frame)),\n    yMatchWithLabel: Object.keys((_yFields$0$labels2 = yFields[0].labels) !== null && _yFields$0$labels2 !== void 0 ? _yFields$0$labels2 : {})[0]\n  };\n\n  if (custom.yMatchWithLabel) {\n    custom.yOrdinalLabel = yFields.map(f => {\n      var _f$labels, _f$labels2;\n\n      return (_f$labels = (_f$labels2 = f.labels) === null || _f$labels2 === void 0 ? void 0 : _f$labels2[custom.yMatchWithLabel]) !== null && _f$labels !== void 0 ? _f$labels : '';\n    });\n\n    if (custom.yMatchWithLabel === 'le') {\n      custom.yMinDisplay = '0.0';\n    }\n  } // Format the labels as a value\n  // TODO: this leaves the internally prepended '0.0' without this formatting treatment\n\n\n  if ((_opts$unit = opts.unit) !== null && _opts$unit !== void 0 && _opts$unit.length || opts.decimals != null) {\n    var _opts$unit2;\n\n    const fmt = getValueFormat((_opts$unit2 = opts.unit) !== null && _opts$unit2 !== void 0 ? _opts$unit2 : 'short');\n\n    if (custom.yMinDisplay) {\n      custom.yMinDisplay = formattedValueToString(fmt(0, opts.decimals));\n    }\n\n    custom.yOrdinalDisplay = custom.yOrdinalDisplay.map(name => {\n      let num = +name;\n\n      if (!Number.isNaN(num)) {\n        return formattedValueToString(fmt(num, opts.decimals));\n      }\n\n      return name;\n    });\n  }\n\n  return {\n    length: xs.length,\n    refId: opts.frame.refId,\n    meta: {\n      type: DataFrameType.HeatmapCells,\n      custom\n    },\n    fields: [{\n      name: 'xMax',\n      type: xField.type,\n      values: new ArrayVector(xs),\n      config: xField.config\n    }, {\n      name: ordinalFieldName,\n      type: FieldType.number,\n      values: new ArrayVector(ys),\n      config: {\n        unit: 'short' // ordinal lookup\n\n      }\n    }, {\n      name: (_opts$value = opts.value) !== null && _opts$value !== void 0 && _opts$value.length ? opts.value : 'Value',\n      type: FieldType.number,\n      values: new ArrayVector(counts2),\n      config: yFields[0].config,\n      display: yFields[0].display\n    }]\n  };\n} // Sorts frames ASC by numeric bucket name and de-accumulates values in each frame's Value field [1]\n// similar to Prometheus result_transformer.ts -> transformToHistogramOverTime()\n\nexport function prepBucketFrames(frames) {\n  frames = frames.slice(); // sort ASC by frame.name (Prometheus bucket bound)\n  // or use frame.fields[1].config.displayNameFromDS ?\n\n  frames.sort((a, b) => sortAscStrInf(a.name, b.name)); // cumulative counts\n\n  const counts = frames.map(frame => frame.fields[1].values.toArray().slice()); // de-accumulate\n\n  counts.reverse();\n  counts.forEach((bucketCounts, bi) => {\n    if (bi < counts.length - 1) {\n      for (let i = 0; i < bucketCounts.length; i++) {\n        bucketCounts[i] -= counts[bi + 1][i];\n      }\n    }\n  });\n  counts.reverse();\n  return frames.map((frame, i) => Object.assign({}, frame, {\n    fields: [frame.fields[0], Object.assign({}, frame.fields[1], {\n      values: new ArrayVector(counts[i])\n    })]\n  }));\n}\nexport function calculateHeatmapFromData(frames, options) {\n  var _options$xBuckets, _options$yBuckets, _xBucketsCfg$scale, _options$yBuckets$sca, _options$yBuckets2, _xBucketsCfg$value;\n\n  //console.time('calculateHeatmapFromData');\n  let xs = [];\n  let ys = []; // optimization\n  //let xMin = Infinity;\n  //let xMax = -Infinity;\n\n  let xField = undefined;\n  let yField = undefined;\n\n  for (let frame of frames) {\n    // TODO: assumes numeric timestamps, ordered asc, without nulls\n    const x = frame.fields.find(f => f.type === FieldType.time);\n\n    if (!x) {\n      continue;\n    }\n\n    if (!xField) {\n      xField = x; // the first X\n    }\n\n    const xValues = x.values.toArray();\n\n    for (let field of frame.fields) {\n      if (field !== x && field.type === FieldType.number) {\n        xs = xs.concat(xValues);\n        ys = ys.concat(field.values.toArray());\n\n        if (!yField) {\n          yField = field;\n        }\n      }\n    }\n  }\n\n  if (!xField || !yField) {\n    throw 'no heatmap fields found';\n  }\n\n  if (!xs.length || !ys.length) {\n    throw 'no values found';\n  }\n\n  const xBucketsCfg = (_options$xBuckets = options.xBuckets) !== null && _options$xBuckets !== void 0 ? _options$xBuckets : {};\n  const yBucketsCfg = (_options$yBuckets = options.yBuckets) !== null && _options$yBuckets !== void 0 ? _options$yBuckets : {};\n\n  if (((_xBucketsCfg$scale = xBucketsCfg.scale) === null || _xBucketsCfg$scale === void 0 ? void 0 : _xBucketsCfg$scale.type) === ScaleDistribution.Log) {\n    throw 'X axis only supports linear buckets';\n  }\n\n  const scaleDistribution = (_options$yBuckets$sca = (_options$yBuckets2 = options.yBuckets) === null || _options$yBuckets2 === void 0 ? void 0 : _options$yBuckets2.scale) !== null && _options$yBuckets$sca !== void 0 ? _options$yBuckets$sca : {\n    type: ScaleDistribution.Linear\n  };\n  const heat2d = heatmap(xs, ys, {\n    xSorted: true,\n    xTime: xField.type === FieldType.time,\n    xMode: xBucketsCfg.mode,\n    xSize: durationToMilliseconds(parseDuration((_xBucketsCfg$value = xBucketsCfg.value) !== null && _xBucketsCfg$value !== void 0 ? _xBucketsCfg$value : '')),\n    yMode: yBucketsCfg.mode,\n    ySize: yBucketsCfg.value ? +yBucketsCfg.value : undefined,\n    yLog: (scaleDistribution === null || scaleDistribution === void 0 ? void 0 : scaleDistribution.type) === ScaleDistribution.Log ? scaleDistribution === null || scaleDistribution === void 0 ? void 0 : scaleDistribution.log : undefined\n  });\n  const frame = {\n    length: heat2d.x.length,\n    name: getFieldDisplayName(yField),\n    meta: {\n      type: DataFrameType.HeatmapCells\n    },\n    fields: [{\n      name: 'xMin',\n      type: xField.type,\n      values: new ArrayVector(heat2d.x),\n      config: xField.config\n    }, {\n      name: 'yMin',\n      type: FieldType.number,\n      values: new ArrayVector(heat2d.y),\n      config: Object.assign({}, yField.config, {\n        // keep units from the original source\n        custom: {\n          scaleDistribution\n        }\n      })\n    }, {\n      name: 'Count',\n      type: FieldType.number,\n      values: new ArrayVector(heat2d.count),\n      config: {\n        unit: 'short' // always integer\n\n      }\n    }]\n  }; //console.timeEnd('calculateHeatmapFromData');\n\n  return frame;\n}\n\n// TODO: handle NaN, Inf, -Inf, null, undefined values in xs & ys\nfunction heatmap(xs, ys, opts) {\n  var _opts$xSorted, _opts$ySorted, _opts$xSize, _opts$ySize;\n\n  let len = xs.length;\n  let xSorted = (_opts$xSorted = opts === null || opts === void 0 ? void 0 : opts.xSorted) !== null && _opts$xSorted !== void 0 ? _opts$xSorted : false;\n  let ySorted = (_opts$ySorted = opts === null || opts === void 0 ? void 0 : opts.ySorted) !== null && _opts$ySorted !== void 0 ? _opts$ySorted : false; // find x and y limits to pre-compute buckets struct\n\n  let minX = xSorted ? xs[0] : Infinity;\n  let minY = ySorted ? ys[0] : Infinity;\n  let maxX = xSorted ? xs[len - 1] : -Infinity;\n  let maxY = ySorted ? ys[len - 1] : -Infinity;\n  let yExp = opts === null || opts === void 0 ? void 0 : opts.yLog;\n\n  for (let i = 0; i < len; i++) {\n    if (!xSorted) {\n      minX = Math.min(minX, xs[i]);\n      maxX = Math.max(maxX, xs[i]);\n    }\n\n    if (!ySorted) {\n      if (!yExp || ys[i] > 0) {\n        minY = Math.min(minY, ys[i]);\n        maxY = Math.max(maxY, ys[i]);\n      }\n    }\n  } //let scaleX = opts?.xLog === 10 ? Math.log10 : opts?.xLog === 2 ? Math.log2 : (v: number) => v;\n  //let scaleY = opts?.yLog === 10 ? Math.log10 : opts?.yLog === 2 ? Math.log2 : (v: number) => v;\n\n\n  let xBinIncr = (_opts$xSize = opts === null || opts === void 0 ? void 0 : opts.xSize) !== null && _opts$xSize !== void 0 ? _opts$xSize : 0;\n  let yBinIncr = (_opts$ySize = opts === null || opts === void 0 ? void 0 : opts.ySize) !== null && _opts$ySize !== void 0 ? _opts$ySize : 0;\n  let xMode = opts === null || opts === void 0 ? void 0 : opts.xMode;\n  let yMode = opts === null || opts === void 0 ? void 0 : opts.yMode; // fall back to 10 buckets if invalid settings\n\n  if (!Number.isFinite(xBinIncr) || xBinIncr <= 0) {\n    xMode = HeatmapCalculationMode.Count;\n    xBinIncr = 20;\n  }\n\n  if (!Number.isFinite(yBinIncr) || yBinIncr <= 0) {\n    yMode = HeatmapCalculationMode.Count;\n    yBinIncr = 10;\n  }\n\n  if (xMode === HeatmapCalculationMode.Count) {\n    // TODO: optionally use view range min/max instead of data range for bucket sizing\n    let approx = (maxX - minX) / Math.max(xBinIncr - 1, 1); // nice-ify\n\n    let xIncrs = opts !== null && opts !== void 0 && opts.xTime ? niceTimeIncrs : niceLinearIncrs;\n    let xIncrIdx = xIncrs.findIndex(bucketSize => bucketSize > approx) - 1;\n    xBinIncr = xIncrs[Math.max(xIncrIdx, 0)];\n  }\n\n  if (yMode === HeatmapCalculationMode.Count) {\n    // TODO: optionally use view range min/max instead of data range for bucket sizing\n    let approx = (maxY - minY) / Math.max(yBinIncr - 1, 1); // nice-ify\n\n    let yIncrs = opts !== null && opts !== void 0 && opts.yTime ? niceTimeIncrs : niceLinearIncrs;\n    let yIncrIdx = yIncrs.findIndex(bucketSize => bucketSize > approx) - 1;\n    yBinIncr = yIncrs[Math.max(yIncrIdx, 0)];\n  } // console.log({\n  //   yBinIncr,\n  //   xBinIncr,\n  // });\n\n\n  let binX = opts !== null && opts !== void 0 && opts.xCeil ? v => incrRoundUp(v, xBinIncr) : v => incrRoundDn(v, xBinIncr);\n  let binY = opts !== null && opts !== void 0 && opts.yCeil ? v => incrRoundUp(v, yBinIncr) : v => incrRoundDn(v, yBinIncr);\n\n  if (yExp) {\n    var _opts$ySize2;\n\n    yBinIncr = 1 / ((_opts$ySize2 = opts === null || opts === void 0 ? void 0 : opts.ySize) !== null && _opts$ySize2 !== void 0 ? _opts$ySize2 : 1); // sub-divides log exponents\n\n    let yLog = yExp === 2 ? Math.log2 : Math.log10;\n    binY = opts !== null && opts !== void 0 && opts.yCeil ? v => incrRoundUp(yLog(v), yBinIncr) : v => incrRoundDn(yLog(v), yBinIncr);\n  }\n\n  let minXBin = binX(minX);\n  let maxXBin = binX(maxX);\n  let minYBin = binY(minY);\n  let maxYBin = binY(maxY);\n  let xBinQty = Math.round((maxXBin - minXBin) / xBinIncr) + 1;\n  let yBinQty = Math.round((maxYBin - minYBin) / yBinIncr) + 1;\n  let [xs2, ys2, counts] = initBins(xBinQty, yBinQty, minXBin, xBinIncr, minYBin, yBinIncr, yExp);\n\n  for (let i = 0; i < len; i++) {\n    if (yExp && ys[i] <= 0) {\n      continue;\n    }\n\n    const xi = (binX(xs[i]) - minXBin) / xBinIncr;\n    const yi = (binY(ys[i]) - minYBin) / yBinIncr;\n    const ci = xi * yBinQty + yi;\n    counts[ci]++;\n  }\n\n  return {\n    x: xs2,\n    y: ys2,\n    count: counts\n  };\n}\n\nfunction initBins(xQty, yQty, xMin, xIncr, yMin, yIncr, yExp) {\n  const len = xQty * yQty;\n  const xs = new Array(len);\n  const ys = new Array(len);\n  const counts = new Array(len);\n\n  for (let i = 0, yi = 0, x = xMin; i < len; yi = ++i % yQty) {\n    counts[i] = 0;\n\n    if (yExp) {\n      ys[i] = yExp ** (yMin + yi * yIncr);\n    } else {\n      ys[i] = yMin + yi * yIncr;\n    }\n\n    if (yi === 0 && i >= yQty) {\n      x += xIncr;\n    }\n\n    xs[i] = x;\n  }\n\n  return [xs, ys, counts];\n}","map":{"version":3,"names":["map","ArrayVector","DataTransformerID","FieldType","incrRoundUp","incrRoundDn","DataFrameType","getFieldDisplayName","getValueFormat","formattedValueToString","durationToMilliseconds","parseDuration","ScaleDistribution","HeatmapCellLayout","HeatmapCalculationMode","niceLinearIncrs","niceTimeIncrs","heatmapTransformer","id","heatmap","name","description","defaultOptions","operator","options","source","pipe","data","transformer","v","calculateHeatmapFromData","keepOriginalData","parseNumeric","Infinity","sortAscStrInf","aName","bName","readHeatmapRowsCustomMeta","frame","meta","custom","isHeatmapCellsDense","foundY","field","fields","rowsToCellsHeatmap","opts","xField","xValues","values","toArray","yFields","filter","f","idx","type","number","len","length","xs","Array","ys","counts2","counts","slice","forEach","bucketCounts","bi","i","bucketBounds","from","yi","xi","ordinalFieldName","labels","le","layout","ge","unknown","yOrdinalDisplay","yMatchWithLabel","Object","keys","yOrdinalLabel","yMinDisplay","unit","decimals","fmt","num","Number","isNaN","refId","HeatmapCells","config","value","display","prepBucketFrames","frames","sort","a","b","reverse","undefined","yField","x","find","time","concat","xBucketsCfg","xBuckets","yBucketsCfg","yBuckets","scale","Log","scaleDistribution","Linear","heat2d","xSorted","xTime","xMode","mode","xSize","yMode","ySize","yLog","log","y","count","ySorted","minX","minY","maxX","maxY","yExp","Math","min","max","xBinIncr","yBinIncr","isFinite","Count","approx","xIncrs","xIncrIdx","findIndex","bucketSize","yIncrs","yTime","yIncrIdx","binX","xCeil","binY","yCeil","log2","log10","minXBin","maxXBin","minYBin","maxYBin","xBinQty","round","yBinQty","xs2","ys2","initBins","ci","xQty","yQty","xMin","xIncr","yMin","yIncr"],"sources":["/home/soula/grafana/public/app/features/transformers/calculateHeatmap/heatmap.ts"],"sourcesContent":["import { map } from 'rxjs';\n\nimport {\n  ArrayVector,\n  DataFrame,\n  DataTransformerID,\n  FieldType,\n  incrRoundUp,\n  incrRoundDn,\n  SynchronousDataTransformerInfo,\n  DataFrameType,\n  getFieldDisplayName,\n  Field,\n  getValueFormat,\n  formattedValueToString,\n  durationToMilliseconds,\n  parseDuration,\n} from '@grafana/data';\nimport { ScaleDistribution } from '@grafana/schema';\n\nimport { HeatmapCellLayout, HeatmapCalculationMode, HeatmapCalculationOptions } from './models.gen';\nimport { niceLinearIncrs, niceTimeIncrs } from './utils';\n\nexport interface HeatmapTransformerOptions extends HeatmapCalculationOptions {\n  /** the raw values will still exist in results after transformation */\n  keepOriginalData?: boolean;\n}\n\nexport const heatmapTransformer: SynchronousDataTransformerInfo<HeatmapTransformerOptions> = {\n  id: DataTransformerID.heatmap,\n  name: 'Create heatmap',\n  description: 'calculate heatmap from source data',\n  defaultOptions: {},\n\n  operator: (options) => (source) => source.pipe(map((data) => heatmapTransformer.transformer(options)(data))),\n\n  transformer: (options: HeatmapTransformerOptions) => {\n    return (data: DataFrame[]) => {\n      const v = calculateHeatmapFromData(data, options);\n      if (options.keepOriginalData) {\n        return [v, ...data];\n      }\n      return [v];\n    };\n  },\n};\n\nfunction parseNumeric(v?: string | null) {\n  return v === '+Inf' ? Infinity : v === '-Inf' ? -Infinity : +(v ?? 0);\n}\n\nexport function sortAscStrInf(aName?: string | null, bName?: string | null) {\n  return parseNumeric(aName) - parseNumeric(bName);\n}\n\nexport interface HeatmapRowsCustomMeta {\n  /** This provides the lookup values */\n  yOrdinalDisplay: string[];\n  yOrdinalLabel?: string[];\n  yMatchWithLabel?: string;\n  yMinDisplay?: string;\n}\n\n/** simple utility to get heatmap metadata from a frame */\nexport function readHeatmapRowsCustomMeta(frame?: DataFrame): HeatmapRowsCustomMeta {\n  return (frame?.meta?.custom ?? {}) as HeatmapRowsCustomMeta;\n}\n\nexport function isHeatmapCellsDense(frame: DataFrame) {\n  let foundY = false;\n\n  for (let field of frame.fields) {\n    // dense heatmap frames can only have one of these fields\n    switch (field.name) {\n      case 'y':\n      case 'yMin':\n      case 'yMax':\n        if (foundY) {\n          return false;\n        }\n\n        foundY = true;\n    }\n  }\n\n  return foundY;\n}\n\nexport interface RowsHeatmapOptions {\n  frame: DataFrame;\n  value?: string; // the field value name\n  unit?: string;\n  decimals?: number;\n  layout?: HeatmapCellLayout;\n}\n\n/** Given existing buckets, create a values style frame */\n// Assumes frames have already been sorted ASC and de-accumulated.\nexport function rowsToCellsHeatmap(opts: RowsHeatmapOptions): DataFrame {\n  // TODO: handle null-filling w/ fields[0].config.interval?\n  const xField = opts.frame.fields[0];\n  const xValues = xField.values.toArray();\n  const yFields = opts.frame.fields.filter((f, idx) => f.type === FieldType.number && idx > 0);\n\n  // similar to initBins() below\n  const len = xValues.length * yFields.length;\n  const xs = new Array(len);\n  const ys = new Array(len);\n  const counts2 = new Array(len);\n\n  const counts = yFields.map((field) => field.values.toArray().slice());\n\n  // transpose\n  counts.forEach((bucketCounts, bi) => {\n    for (let i = 0; i < bucketCounts.length; i++) {\n      counts2[counts.length * i + bi] = bucketCounts[i];\n    }\n  });\n\n  const bucketBounds = Array.from({ length: yFields.length }, (v, i) => i);\n\n  // fill flat/repeating array\n  for (let i = 0, yi = 0, xi = 0; i < len; yi = ++i % bucketBounds.length) {\n    ys[i] = bucketBounds[yi];\n\n    if (yi === 0 && i >= bucketBounds.length) {\n      xi++;\n    }\n\n    xs[i] = xValues[xi];\n  }\n\n  // this name determines whether cells are drawn above, below, or centered on the values\n  let ordinalFieldName = yFields[0].labels?.le != null ? 'yMax' : 'y';\n  switch (opts.layout) {\n    case HeatmapCellLayout.le:\n      ordinalFieldName = 'yMax';\n      break;\n    case HeatmapCellLayout.ge:\n      ordinalFieldName = 'yMin';\n      break;\n    case HeatmapCellLayout.unknown:\n      ordinalFieldName = 'y';\n      break;\n  }\n\n  const custom: HeatmapRowsCustomMeta = {\n    yOrdinalDisplay: yFields.map((f) => getFieldDisplayName(f, opts.frame)),\n    yMatchWithLabel: Object.keys(yFields[0].labels ?? {})[0],\n  };\n  if (custom.yMatchWithLabel) {\n    custom.yOrdinalLabel = yFields.map((f) => f.labels?.[custom.yMatchWithLabel!] ?? '');\n    if (custom.yMatchWithLabel === 'le') {\n      custom.yMinDisplay = '0.0';\n    }\n  }\n\n  // Format the labels as a value\n  // TODO: this leaves the internally prepended '0.0' without this formatting treatment\n  if (opts.unit?.length || opts.decimals != null) {\n    const fmt = getValueFormat(opts.unit ?? 'short');\n    if (custom.yMinDisplay) {\n      custom.yMinDisplay = formattedValueToString(fmt(0, opts.decimals));\n    }\n    custom.yOrdinalDisplay = custom.yOrdinalDisplay.map((name) => {\n      let num = +name;\n\n      if (!Number.isNaN(num)) {\n        return formattedValueToString(fmt(num, opts.decimals));\n      }\n\n      return name;\n    });\n  }\n\n  return {\n    length: xs.length,\n    refId: opts.frame.refId,\n    meta: {\n      type: DataFrameType.HeatmapCells,\n      custom,\n    },\n    fields: [\n      {\n        name: 'xMax',\n        type: xField.type,\n        values: new ArrayVector(xs),\n        config: xField.config,\n      },\n      {\n        name: ordinalFieldName,\n        type: FieldType.number,\n        values: new ArrayVector(ys),\n        config: {\n          unit: 'short', // ordinal lookup\n        },\n      },\n      {\n        name: opts.value?.length ? opts.value : 'Value',\n        type: FieldType.number,\n        values: new ArrayVector(counts2),\n        config: yFields[0].config,\n        display: yFields[0].display,\n      },\n    ],\n  };\n}\n\n// Sorts frames ASC by numeric bucket name and de-accumulates values in each frame's Value field [1]\n// similar to Prometheus result_transformer.ts -> transformToHistogramOverTime()\nexport function prepBucketFrames(frames: DataFrame[]): DataFrame[] {\n  frames = frames.slice();\n\n  // sort ASC by frame.name (Prometheus bucket bound)\n  // or use frame.fields[1].config.displayNameFromDS ?\n  frames.sort((a, b) => sortAscStrInf(a.name, b.name));\n\n  // cumulative counts\n  const counts = frames.map((frame) => frame.fields[1].values.toArray().slice());\n\n  // de-accumulate\n  counts.reverse();\n  counts.forEach((bucketCounts, bi) => {\n    if (bi < counts.length - 1) {\n      for (let i = 0; i < bucketCounts.length; i++) {\n        bucketCounts[i] -= counts[bi + 1][i];\n      }\n    }\n  });\n  counts.reverse();\n\n  return frames.map((frame, i) => ({\n    ...frame,\n    fields: [\n      frame.fields[0],\n      {\n        ...frame.fields[1],\n        values: new ArrayVector(counts[i]),\n      },\n    ],\n  }));\n}\n\nexport function calculateHeatmapFromData(frames: DataFrame[], options: HeatmapCalculationOptions): DataFrame {\n  //console.time('calculateHeatmapFromData');\n\n  let xs: number[] = [];\n  let ys: number[] = [];\n\n  // optimization\n  //let xMin = Infinity;\n  //let xMax = -Infinity;\n\n  let xField: Field | undefined = undefined;\n  let yField: Field | undefined = undefined;\n\n  for (let frame of frames) {\n    // TODO: assumes numeric timestamps, ordered asc, without nulls\n    const x = frame.fields.find((f) => f.type === FieldType.time);\n    if (!x) {\n      continue;\n    }\n\n    if (!xField) {\n      xField = x; // the first X\n    }\n\n    const xValues = x.values.toArray();\n    for (let field of frame.fields) {\n      if (field !== x && field.type === FieldType.number) {\n        xs = xs.concat(xValues);\n        ys = ys.concat(field.values.toArray());\n\n        if (!yField) {\n          yField = field;\n        }\n      }\n    }\n  }\n\n  if (!xField || !yField) {\n    throw 'no heatmap fields found';\n  }\n\n  if (!xs.length || !ys.length) {\n    throw 'no values found';\n  }\n\n  const xBucketsCfg = options.xBuckets ?? {};\n  const yBucketsCfg = options.yBuckets ?? {};\n\n  if (xBucketsCfg.scale?.type === ScaleDistribution.Log) {\n    throw 'X axis only supports linear buckets';\n  }\n\n  const scaleDistribution = options.yBuckets?.scale ?? {\n    type: ScaleDistribution.Linear,\n  };\n\n  const heat2d = heatmap(xs, ys, {\n    xSorted: true,\n    xTime: xField.type === FieldType.time,\n    xMode: xBucketsCfg.mode,\n    xSize: durationToMilliseconds(parseDuration(xBucketsCfg.value ?? '')),\n    yMode: yBucketsCfg.mode,\n    ySize: yBucketsCfg.value ? +yBucketsCfg.value : undefined,\n    yLog: scaleDistribution?.type === ScaleDistribution.Log ? (scaleDistribution?.log as any) : undefined,\n  });\n\n  const frame = {\n    length: heat2d.x.length,\n    name: getFieldDisplayName(yField),\n    meta: {\n      type: DataFrameType.HeatmapCells,\n    },\n    fields: [\n      {\n        name: 'xMin',\n        type: xField.type,\n        values: new ArrayVector(heat2d.x),\n        config: xField.config,\n      },\n      {\n        name: 'yMin',\n        type: FieldType.number,\n        values: new ArrayVector(heat2d.y),\n        config: {\n          ...yField.config, // keep units from the original source\n          custom: {\n            scaleDistribution,\n          },\n        },\n      },\n      {\n        name: 'Count',\n        type: FieldType.number,\n        values: new ArrayVector(heat2d.count),\n        config: {\n          unit: 'short', // always integer\n        },\n      },\n    ],\n  };\n\n  //console.timeEnd('calculateHeatmapFromData');\n  return frame;\n}\n\ninterface HeatmapOpts {\n  // default is 10% of data range, snapped to a \"nice\" increment\n  xMode?: HeatmapCalculationMode;\n  yMode?: HeatmapCalculationMode;\n  xSize?: number;\n  ySize?: number;\n\n  // use Math.ceil instead of Math.floor for bucketing\n  xCeil?: boolean;\n  yCeil?: boolean;\n\n  // log2 or log10 buckets\n  xLog?: 2 | 10;\n  yLog?: 2 | 10;\n\n  xTime?: boolean;\n  yTime?: boolean;\n\n  // optimization hints for known data ranges (sorted, pre-scanned, etc)\n  xMin?: number;\n  xMax?: number;\n  yMin?: number;\n  yMax?: number;\n\n  xSorted?: boolean;\n  ySorted?: boolean;\n}\n\n// TODO: handle NaN, Inf, -Inf, null, undefined values in xs & ys\nfunction heatmap(xs: number[], ys: number[], opts?: HeatmapOpts) {\n  let len = xs.length;\n\n  let xSorted = opts?.xSorted ?? false;\n  let ySorted = opts?.ySorted ?? false;\n\n  // find x and y limits to pre-compute buckets struct\n  let minX = xSorted ? xs[0] : Infinity;\n  let minY = ySorted ? ys[0] : Infinity;\n  let maxX = xSorted ? xs[len - 1] : -Infinity;\n  let maxY = ySorted ? ys[len - 1] : -Infinity;\n\n  let yExp = opts?.yLog;\n\n  for (let i = 0; i < len; i++) {\n    if (!xSorted) {\n      minX = Math.min(minX, xs[i]);\n      maxX = Math.max(maxX, xs[i]);\n    }\n\n    if (!ySorted) {\n      if (!yExp || ys[i] > 0) {\n        minY = Math.min(minY, ys[i]);\n        maxY = Math.max(maxY, ys[i]);\n      }\n    }\n  }\n\n  //let scaleX = opts?.xLog === 10 ? Math.log10 : opts?.xLog === 2 ? Math.log2 : (v: number) => v;\n  //let scaleY = opts?.yLog === 10 ? Math.log10 : opts?.yLog === 2 ? Math.log2 : (v: number) => v;\n\n  let xBinIncr = opts?.xSize ?? 0;\n  let yBinIncr = opts?.ySize ?? 0;\n  let xMode = opts?.xMode;\n  let yMode = opts?.yMode;\n\n  // fall back to 10 buckets if invalid settings\n  if (!Number.isFinite(xBinIncr) || xBinIncr <= 0) {\n    xMode = HeatmapCalculationMode.Count;\n    xBinIncr = 20;\n  }\n  if (!Number.isFinite(yBinIncr) || yBinIncr <= 0) {\n    yMode = HeatmapCalculationMode.Count;\n    yBinIncr = 10;\n  }\n\n  if (xMode === HeatmapCalculationMode.Count) {\n    // TODO: optionally use view range min/max instead of data range for bucket sizing\n    let approx = (maxX - minX) / Math.max(xBinIncr - 1, 1);\n    // nice-ify\n    let xIncrs = opts?.xTime ? niceTimeIncrs : niceLinearIncrs;\n    let xIncrIdx = xIncrs.findIndex((bucketSize) => bucketSize > approx) - 1;\n    xBinIncr = xIncrs[Math.max(xIncrIdx, 0)];\n  }\n\n  if (yMode === HeatmapCalculationMode.Count) {\n    // TODO: optionally use view range min/max instead of data range for bucket sizing\n    let approx = (maxY - minY) / Math.max(yBinIncr - 1, 1);\n    // nice-ify\n    let yIncrs = opts?.yTime ? niceTimeIncrs : niceLinearIncrs;\n    let yIncrIdx = yIncrs.findIndex((bucketSize) => bucketSize > approx) - 1;\n    yBinIncr = yIncrs[Math.max(yIncrIdx, 0)];\n  }\n\n  // console.log({\n  //   yBinIncr,\n  //   xBinIncr,\n  // });\n\n  let binX = opts?.xCeil ? (v: number) => incrRoundUp(v, xBinIncr) : (v: number) => incrRoundDn(v, xBinIncr);\n  let binY = opts?.yCeil ? (v: number) => incrRoundUp(v, yBinIncr) : (v: number) => incrRoundDn(v, yBinIncr);\n\n  if (yExp) {\n    yBinIncr = 1 / (opts?.ySize ?? 1); // sub-divides log exponents\n    let yLog = yExp === 2 ? Math.log2 : Math.log10;\n    binY = opts?.yCeil ? (v: number) => incrRoundUp(yLog(v), yBinIncr) : (v: number) => incrRoundDn(yLog(v), yBinIncr);\n  }\n\n  let minXBin = binX(minX);\n  let maxXBin = binX(maxX);\n  let minYBin = binY(minY);\n  let maxYBin = binY(maxY);\n\n  let xBinQty = Math.round((maxXBin - minXBin) / xBinIncr) + 1;\n  let yBinQty = Math.round((maxYBin - minYBin) / yBinIncr) + 1;\n\n  let [xs2, ys2, counts] = initBins(xBinQty, yBinQty, minXBin, xBinIncr, minYBin, yBinIncr, yExp);\n\n  for (let i = 0; i < len; i++) {\n    if (yExp && ys[i] <= 0) {\n      continue;\n    }\n\n    const xi = (binX(xs[i]) - minXBin) / xBinIncr;\n    const yi = (binY(ys[i]) - minYBin) / yBinIncr;\n    const ci = xi * yBinQty + yi;\n\n    counts[ci]++;\n  }\n\n  return {\n    x: xs2,\n    y: ys2,\n    count: counts,\n  };\n}\n\nfunction initBins(xQty: number, yQty: number, xMin: number, xIncr: number, yMin: number, yIncr: number, yExp?: number) {\n  const len = xQty * yQty;\n  const xs = new Array<number>(len);\n  const ys = new Array<number>(len);\n  const counts = new Array<number>(len);\n\n  for (let i = 0, yi = 0, x = xMin; i < len; yi = ++i % yQty) {\n    counts[i] = 0;\n\n    if (yExp) {\n      ys[i] = yExp ** (yMin + yi * yIncr);\n    } else {\n      ys[i] = yMin + yi * yIncr;\n    }\n\n    if (yi === 0 && i >= yQty) {\n      x += xIncr;\n    }\n\n    xs[i] = x;\n  }\n\n  return [xs, ys, counts];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}