{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { each, map, includes, flatten, keys } from 'lodash';\nimport { FieldType } from '@grafana/data';\nimport TableModel from 'app/core/table_model';\nexport default class InfluxSeries {\n  constructor(options) {\n    _defineProperty(this, \"refId\", void 0);\n\n    _defineProperty(this, \"series\", void 0);\n\n    _defineProperty(this, \"alias\", void 0);\n\n    _defineProperty(this, \"annotation\", void 0);\n\n    _defineProperty(this, \"meta\", void 0);\n\n    this.series = options.series;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n    this.meta = options.meta;\n    this.refId = options.refId;\n  }\n\n  getTimeSeries() {\n    const output = [];\n    let i, j;\n\n    if (this.series.length === 0) {\n      return output;\n    }\n\n    each(this.series, series => {\n      const columns = series.columns.length;\n      const tags = map(series.tags, (value, key) => {\n        return key + ': ' + value;\n      });\n\n      for (j = 1; j < columns; j++) {\n        let seriesName = series.name;\n        const columnName = series.columns[j];\n\n        if (columnName !== 'value') {\n          seriesName = seriesName + '.' + columnName;\n        }\n\n        if (this.alias) {\n          seriesName = this._getSeriesName(series, j);\n        } else if (series.tags) {\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\n        }\n\n        const datapoints = [];\n\n        if (series.values) {\n          for (i = 0; i < series.values.length; i++) {\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\n          }\n        }\n\n        output.push({\n          title: seriesName,\n          target: seriesName,\n          datapoints: datapoints,\n          tags: series.tags,\n          meta: this.meta,\n          refId: this.refId\n        });\n      }\n    });\n    return output;\n  }\n\n  _getSeriesName(series, index) {\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    const segments = series.name.split('.');\n    return this.alias.replace(regex, (match, g1, g2) => {\n      const group = g1 || g2;\n      const segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return series.name;\n      }\n\n      if (group === 'col') {\n        return series.columns[index];\n      }\n\n      if (!isNaN(segIndex)) {\n        var _segments$segIndex;\n\n        return (_segments$segIndex = segments[segIndex]) !== null && _segments$segIndex !== void 0 ? _segments$segIndex : match;\n      }\n\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      const tag = group.replace('tag_', '');\n\n      if (!series.tags) {\n        return match;\n      }\n\n      return series.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    const list = [];\n    each(this.series, series => {\n      let titleCol = null;\n      let timeCol = null;\n      let timeEndCol = null;\n      const tagsCol = [];\n      let textCol = null;\n      each(series.columns, (column, index) => {\n        if (column === 'time') {\n          timeCol = index;\n          return;\n        }\n\n        if (column === 'sequence_number') {\n          return;\n        }\n\n        if (column === this.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n\n        if (includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n          tagsCol.push(index);\n          return;\n        }\n\n        if (column === this.annotation.textColumn) {\n          textCol = index;\n          return;\n        }\n\n        if (column === this.annotation.timeEndColumn) {\n          timeEndCol = index;\n          return;\n        } // legacy case\n\n\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n      each(series.values, value => {\n        const data = {\n          annotation: this.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          timeEnd: value[timeEndCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: flatten(tagsCol.filter(t => {\n            return value[t];\n          }).map(t => {\n            return value[t].split(',');\n          })),\n          text: value[textCol]\n        };\n        list.push(data);\n      });\n    });\n    return list;\n  }\n\n  getTable() {\n    const table = new TableModel();\n    let i, j;\n    table.refId = this.refId;\n    table.meta = this.meta;\n\n    if (this.series.length === 0) {\n      return table;\n    } // the order is:\n    // - first the first item from the value-array (this is often (always?) the timestamp)\n    // - then all the tag-values\n    // - then the rest of the value-array\n    //\n    // we have to keep this order both in table.columns and table.rows\n\n\n    each(this.series, (series, seriesIndex) => {\n      if (seriesIndex === 0) {\n        const firstCol = series.columns[0]; // Check the first column's name, if it is `time`, we\n        // mark it as having the type time\n\n        const firstTableCol = firstCol === 'time' ? {\n          text: 'Time',\n          type: FieldType.time\n        } : {\n          text: firstCol\n        };\n        table.columns.push(firstTableCol);\n        each(keys(series.tags), key => {\n          table.columns.push({\n            text: key\n          });\n        });\n\n        for (j = 1; j < series.columns.length; j++) {\n          table.columns.push({\n            text: series.columns[j]\n          });\n        }\n      }\n\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered = [values[0]];\n\n          if (series.tags) {\n            for (const key in series.tags) {\n              if (series.tags.hasOwnProperty(key)) {\n                reordered.push(series.tags[key]);\n              }\n            }\n          }\n\n          for (j = 1; j < values.length; j++) {\n            reordered.push(values[j]);\n          }\n\n          table.rows.push(reordered);\n        }\n      }\n    });\n    return table;\n  }\n\n}","map":{"version":3,"names":["each","map","includes","flatten","keys","FieldType","TableModel","InfluxSeries","constructor","options","series","alias","annotation","meta","refId","getTimeSeries","output","i","j","length","columns","tags","value","key","seriesName","name","columnName","_getSeriesName","join","datapoints","values","push","title","target","index","regex","segments","split","replace","match","g1","g2","group","segIndex","parseInt","isNaN","indexOf","tag","getAnnotations","list","titleCol","timeCol","timeEndCol","tagsCol","textCol","column","titleColumn","tagsColumn","textColumn","timeEndColumn","data","time","Date","timeEnd","filter","t","text","getTable","table","seriesIndex","firstCol","firstTableCol","type","reordered","hasOwnProperty","rows"],"sources":["/home/soula/grafana/public/app/plugins/datasource/influxdb/influx_series.ts"],"sourcesContent":["import { each, map, includes, flatten, keys } from 'lodash';\n\nimport { FieldType, QueryResultMeta, TimeSeries, TableData } from '@grafana/data';\nimport TableModel from 'app/core/table_model';\n\nexport default class InfluxSeries {\n  refId?: string;\n  series: any;\n  alias: any;\n  annotation: any;\n  meta?: QueryResultMeta;\n\n  constructor(options: { series: any; alias?: any; annotation?: any; meta?: QueryResultMeta; refId?: string }) {\n    this.series = options.series;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n    this.meta = options.meta;\n    this.refId = options.refId;\n  }\n\n  getTimeSeries(): TimeSeries[] {\n    const output: TimeSeries[] = [];\n    let i, j;\n\n    if (this.series.length === 0) {\n      return output;\n    }\n\n    each(this.series, (series) => {\n      const columns = series.columns.length;\n      const tags = map(series.tags, (value, key) => {\n        return key + ': ' + value;\n      });\n\n      for (j = 1; j < columns; j++) {\n        let seriesName = series.name;\n        const columnName = series.columns[j];\n        if (columnName !== 'value') {\n          seriesName = seriesName + '.' + columnName;\n        }\n\n        if (this.alias) {\n          seriesName = this._getSeriesName(series, j);\n        } else if (series.tags) {\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\n        }\n\n        const datapoints = [];\n        if (series.values) {\n          for (i = 0; i < series.values.length; i++) {\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\n          }\n        }\n\n        output.push({\n          title: seriesName,\n          target: seriesName,\n          datapoints: datapoints,\n          tags: series.tags,\n          meta: this.meta,\n          refId: this.refId,\n        });\n      }\n    });\n\n    return output;\n  }\n\n  _getSeriesName(series: any, index: number) {\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    const segments = series.name.split('.');\n\n    return this.alias.replace(regex, (match: any, g1: any, g2: any) => {\n      const group = g1 || g2;\n      const segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return series.name;\n      }\n      if (group === 'col') {\n        return series.columns[index];\n      }\n      if (!isNaN(segIndex)) {\n        return segments[segIndex] ?? match;\n      }\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      const tag = group.replace('tag_', '');\n      if (!series.tags) {\n        return match;\n      }\n      return series.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    const list: any[] = [];\n\n    each(this.series, (series) => {\n      let titleCol: any = null;\n      let timeCol: any = null;\n      let timeEndCol: any = null;\n      const tagsCol: any = [];\n      let textCol: any = null;\n\n      each(series.columns, (column, index) => {\n        if (column === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column === 'sequence_number') {\n          return;\n        }\n        if (column === this.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column === this.annotation.textColumn) {\n          textCol = index;\n          return;\n        }\n        if (column === this.annotation.timeEndColumn) {\n          timeEndCol = index;\n          return;\n        }\n        // legacy case\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n\n      each(series.values, (value) => {\n        const data = {\n          annotation: this.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          timeEnd: value[timeEndCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: flatten(\n            tagsCol\n              .filter((t: any) => {\n                return value[t];\n              })\n              .map((t: any) => {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n    });\n\n    return list;\n  }\n\n  getTable(): TableData {\n    const table = new TableModel();\n    let i, j;\n\n    table.refId = this.refId;\n    table.meta = this.meta;\n\n    if (this.series.length === 0) {\n      return table;\n    }\n\n    // the order is:\n    // - first the first item from the value-array (this is often (always?) the timestamp)\n    // - then all the tag-values\n    // - then the rest of the value-array\n    //\n    // we have to keep this order both in table.columns and table.rows\n\n    each(this.series, (series: any, seriesIndex: number) => {\n      if (seriesIndex === 0) {\n        const firstCol = series.columns[0];\n        // Check the first column's name, if it is `time`, we\n        // mark it as having the type time\n        const firstTableCol = firstCol === 'time' ? { text: 'Time', type: FieldType.time } : { text: firstCol };\n        table.columns.push(firstTableCol);\n        each(keys(series.tags), (key) => {\n          table.columns.push({ text: key });\n        });\n        for (j = 1; j < series.columns.length; j++) {\n          table.columns.push({ text: series.columns[j] });\n        }\n      }\n\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered = [values[0]];\n          if (series.tags) {\n            for (const key in series.tags) {\n              if (series.tags.hasOwnProperty(key)) {\n                reordered.push(series.tags[key]);\n              }\n            }\n          }\n          for (j = 1; j < values.length; j++) {\n            reordered.push(values[j]);\n          }\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}