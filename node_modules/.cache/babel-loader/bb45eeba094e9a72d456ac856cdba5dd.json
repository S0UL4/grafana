{"ast":null,"code":"import { formattedValueToString, getFieldDisplayName, dateTimeFormat, systemDateFormats } from '@grafana/data';\n/**\n * Returns index of the closest datapoint BEFORE hover position\n *\n * @param posX\n * @param series\n */\n\nexport const findHoverIndexFromData = (xAxisDimension, xPos) => {\n  let lower = 0;\n  let upper = xAxisDimension.values.length - 1;\n  let middle;\n\n  while (true) {\n    if (lower > upper) {\n      return Math.max(upper, 0);\n    }\n\n    middle = Math.floor((lower + upper) / 2);\n    const xPosition = xAxisDimension.values.get(middle);\n\n    if (xPosition === xPos) {\n      return middle;\n    } else if (xPosition && xPosition < xPos) {\n      lower = middle + 1;\n    } else {\n      upper = middle - 1;\n    }\n  }\n};\n\n/**\n * Returns information about closest datapoints when hovering over a Graph\n *\n * @param seriesList list of series visible on the Graph\n * @param pos mouse cursor position, based on jQuery.flot position\n */\nexport const getMultiSeriesGraphHoverInfo = (yAxisDimensions, xAxisDimensions, xAxisPosition, timeZone) => {\n  let i, field, hoverIndex, hoverDistance, pointTime;\n  const results = [];\n  let minDistance, minTime;\n\n  for (i = 0; i < yAxisDimensions.length; i++) {\n    field = yAxisDimensions[i];\n    const time = xAxisDimensions[i];\n    hoverIndex = findHoverIndexFromData(time, xAxisPosition);\n    hoverDistance = xAxisPosition - time.values.get(hoverIndex);\n    pointTime = time.values.get(hoverIndex); // Take the closest point before the cursor, or if it does not exist, the closest after\n\n    if (minDistance === undefined || hoverDistance >= 0 && (hoverDistance < minDistance || minDistance < 0) || hoverDistance < 0 && hoverDistance > minDistance) {\n      minDistance = hoverDistance;\n      minTime = time.display ? formattedValueToString(time.display(pointTime)) : pointTime;\n    }\n\n    const disp = field.display(field.values.get(hoverIndex));\n    results.push({\n      value: formattedValueToString(disp),\n      datapointIndex: hoverIndex,\n      seriesIndex: i,\n      color: disp.color,\n      label: getFieldDisplayName(field),\n      time: time.display ? formattedValueToString(time.display(pointTime)) : pointTime\n    });\n  }\n\n  return {\n    results,\n    time: minTime\n  };\n};\nexport const graphTickFormatter = (epoch, axis) => {\n  var _axis$options, _axis$options2;\n\n  return dateTimeFormat(epoch, {\n    format: axis === null || axis === void 0 ? void 0 : (_axis$options = axis.options) === null || _axis$options === void 0 ? void 0 : _axis$options.timeformat,\n    timeZone: axis === null || axis === void 0 ? void 0 : (_axis$options2 = axis.options) === null || _axis$options2 === void 0 ? void 0 : _axis$options2.timezone\n  });\n};\nexport const graphTimeFormat = (ticks, min, max) => {\n  if (min && max && ticks) {\n    const range = max - min;\n    const secPerTick = range / ticks / 1000; // Need have 10 millisecond margin on the day range\n    // As sometimes last 24 hour dashboard evaluates to more than 86400000\n\n    const oneDay = 86400010;\n    const oneYear = 31536000000;\n\n    if (secPerTick <= 45) {\n      return systemDateFormats.interval.second;\n    }\n\n    if (range <= oneDay) {\n      return systemDateFormats.interval.minute;\n    }\n\n    if (secPerTick <= 80000) {\n      return systemDateFormats.interval.hour;\n    }\n\n    if (range <= oneYear) {\n      return systemDateFormats.interval.day;\n    }\n\n    if (secPerTick <= 31536000) {\n      return systemDateFormats.interval.month;\n    }\n\n    return systemDateFormats.interval.year;\n  }\n\n  return systemDateFormats.interval.minute;\n};","map":{"version":3,"names":["formattedValueToString","getFieldDisplayName","dateTimeFormat","systemDateFormats","findHoverIndexFromData","xAxisDimension","xPos","lower","upper","values","length","middle","Math","max","floor","xPosition","get","getMultiSeriesGraphHoverInfo","yAxisDimensions","xAxisDimensions","xAxisPosition","timeZone","i","field","hoverIndex","hoverDistance","pointTime","results","minDistance","minTime","time","undefined","display","disp","push","value","datapointIndex","seriesIndex","color","label","graphTickFormatter","epoch","axis","format","options","timeformat","timezone","graphTimeFormat","ticks","min","range","secPerTick","oneDay","oneYear","interval","second","minute","hour","day","month","year"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/Graph/utils.ts"],"sourcesContent":["import {\n  GraphSeriesValue,\n  Field,\n  formattedValueToString,\n  getFieldDisplayName,\n  TimeZone,\n  dateTimeFormat,\n  systemDateFormats,\n} from '@grafana/data';\n\n/**\n * Returns index of the closest datapoint BEFORE hover position\n *\n * @param posX\n * @param series\n */\nexport const findHoverIndexFromData = (xAxisDimension: Field, xPos: number) => {\n  let lower = 0;\n  let upper = xAxisDimension.values.length - 1;\n  let middle;\n\n  while (true) {\n    if (lower > upper) {\n      return Math.max(upper, 0);\n    }\n    middle = Math.floor((lower + upper) / 2);\n    const xPosition = xAxisDimension.values.get(middle);\n\n    if (xPosition === xPos) {\n      return middle;\n    } else if (xPosition && xPosition < xPos) {\n      lower = middle + 1;\n    } else {\n      upper = middle - 1;\n    }\n  }\n};\n\ninterface MultiSeriesHoverInfo {\n  value: string;\n  time: string;\n  datapointIndex: number;\n  seriesIndex: number;\n  label?: string;\n  color?: string;\n}\n\n/**\n * Returns information about closest datapoints when hovering over a Graph\n *\n * @param seriesList list of series visible on the Graph\n * @param pos mouse cursor position, based on jQuery.flot position\n */\nexport const getMultiSeriesGraphHoverInfo = (\n  // x and y axis dimensions order is aligned\n  yAxisDimensions: Field[],\n  xAxisDimensions: Field[],\n  /** Well, time basically */\n  xAxisPosition: number,\n  timeZone?: TimeZone\n): {\n  results: MultiSeriesHoverInfo[];\n  time?: GraphSeriesValue;\n} => {\n  let i, field, hoverIndex, hoverDistance, pointTime;\n\n  const results: MultiSeriesHoverInfo[] = [];\n\n  let minDistance, minTime;\n\n  for (i = 0; i < yAxisDimensions.length; i++) {\n    field = yAxisDimensions[i];\n    const time = xAxisDimensions[i];\n    hoverIndex = findHoverIndexFromData(time, xAxisPosition);\n    hoverDistance = xAxisPosition - time.values.get(hoverIndex);\n    pointTime = time.values.get(hoverIndex);\n    // Take the closest point before the cursor, or if it does not exist, the closest after\n    if (\n      minDistance === undefined ||\n      (hoverDistance >= 0 && (hoverDistance < minDistance || minDistance < 0)) ||\n      (hoverDistance < 0 && hoverDistance > minDistance)\n    ) {\n      minDistance = hoverDistance;\n      minTime = time.display ? formattedValueToString(time.display(pointTime)) : pointTime;\n    }\n\n    const disp = field.display!(field.values.get(hoverIndex));\n\n    results.push({\n      value: formattedValueToString(disp),\n      datapointIndex: hoverIndex,\n      seriesIndex: i,\n      color: disp.color,\n      label: getFieldDisplayName(field),\n      time: time.display ? formattedValueToString(time.display(pointTime)) : pointTime,\n    });\n  }\n\n  return {\n    results,\n    time: minTime,\n  };\n};\n\nexport const graphTickFormatter = (epoch: number, axis: any) => {\n  return dateTimeFormat(epoch, {\n    format: axis?.options?.timeformat,\n    timeZone: axis?.options?.timezone,\n  });\n};\n\nexport const graphTimeFormat = (ticks: number | null, min: number | null, max: number | null): string => {\n  if (min && max && ticks) {\n    const range = max - min;\n    const secPerTick = range / ticks / 1000;\n    // Need have 10 millisecond margin on the day range\n    // As sometimes last 24 hour dashboard evaluates to more than 86400000\n    const oneDay = 86400010;\n    const oneYear = 31536000000;\n\n    if (secPerTick <= 45) {\n      return systemDateFormats.interval.second;\n    }\n    if (range <= oneDay) {\n      return systemDateFormats.interval.minute;\n    }\n    if (secPerTick <= 80000) {\n      return systemDateFormats.interval.hour;\n    }\n    if (range <= oneYear) {\n      return systemDateFormats.interval.day;\n    }\n    if (secPerTick <= 31536000) {\n      return systemDateFormats.interval.month;\n    }\n    return systemDateFormats.interval.year;\n  }\n\n  return systemDateFormats.interval.minute;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}