{"ast":null,"code":"import { TIME_SERIES_VALUE_FIELD_NAME, FieldType, TIME_SERIES_TIME_FIELD_NAME } from '../types';\nimport { formatLabels } from '../utils/labels';\n/**\n * Get an appropriate display title\n */\n\nexport function getFrameDisplayName(frame, index) {\n  if (frame.name) {\n    return frame.name;\n  } // Single field with tags\n\n\n  const valuesWithLabels = [];\n\n  for (const field of frame.fields) {\n    if (field.labels && Object.keys(field.labels).length > 0) {\n      valuesWithLabels.push(field);\n    }\n  }\n\n  if (valuesWithLabels.length === 1) {\n    return formatLabels(valuesWithLabels[0].labels);\n  } // list all the\n\n\n  if (index === undefined) {\n    return frame.fields.filter(f => f.type !== FieldType.time).map(f => getFieldDisplayName(f, frame)).join(', ');\n  }\n\n  if (frame.refId) {\n    return `Series (${frame.refId})`;\n  }\n\n  return `Series (${index})`;\n}\nexport function getFieldDisplayName(field, frame, allFrames) {\n  var _field$state, _field$state2;\n\n  const existingTitle = (_field$state = field.state) === null || _field$state === void 0 ? void 0 : _field$state.displayName;\n  const multipleFrames = Boolean(allFrames && allFrames.length > 1);\n\n  if (existingTitle && multipleFrames === ((_field$state2 = field.state) === null || _field$state2 === void 0 ? void 0 : _field$state2.multipleFrames)) {\n    return existingTitle;\n  }\n\n  const displayName = calculateFieldDisplayName(field, frame, allFrames);\n  field.state = field.state || {};\n  field.state.displayName = displayName;\n  field.state.multipleFrames = multipleFrames;\n  return displayName;\n}\n/**\n * Get an appropriate display name. If the 'displayName' field config is set, use that.\n */\n\nfunction calculateFieldDisplayName(field, frame, allFrames) {\n  var _field$config, _field$config2, _field$config3;\n\n  const hasConfigTitle = ((_field$config = field.config) === null || _field$config === void 0 ? void 0 : _field$config.displayName) && ((_field$config2 = field.config) === null || _field$config2 === void 0 ? void 0 : _field$config2.displayName.length);\n  let displayName = hasConfigTitle ? field.config.displayName : field.name;\n\n  if (hasConfigTitle) {\n    return displayName;\n  }\n\n  if (frame && (_field$config3 = field.config) !== null && _field$config3 !== void 0 && _field$config3.displayNameFromDS) {\n    return field.config.displayNameFromDS;\n  } // This is an ugly exception for time field\n  // For time series we should normally treat time field with same name\n  // But in case it has a join source we should handle it as normal field\n\n\n  if (field.type === FieldType.time && !field.labels) {\n    var _displayName;\n\n    return (_displayName = displayName) !== null && _displayName !== void 0 ? _displayName : TIME_SERIES_TIME_FIELD_NAME;\n  }\n\n  let parts = [];\n  let frameNamesDiffer = false;\n\n  if (allFrames && allFrames.length > 1) {\n    for (let i = 1; i < allFrames.length; i++) {\n      const frame = allFrames[i];\n\n      if (frame.name !== allFrames[i - 1].name) {\n        frameNamesDiffer = true;\n        break;\n      }\n    }\n  }\n\n  let frameNameAdded = false;\n  let labelsAdded = false;\n\n  if (frameNamesDiffer && frame !== null && frame !== void 0 && frame.name) {\n    parts.push(frame.name);\n    frameNameAdded = true;\n  }\n\n  if (field.name && field.name !== TIME_SERIES_VALUE_FIELD_NAME) {\n    parts.push(field.name);\n  }\n\n  if (field.labels && frame) {\n    let singleLabelName = getSingleLabelName(allFrames !== null && allFrames !== void 0 ? allFrames : [frame]);\n\n    if (!singleLabelName) {\n      let allLabels = formatLabels(field.labels);\n\n      if (allLabels) {\n        parts.push(allLabels);\n        labelsAdded = true;\n      }\n    } else if (field.labels[singleLabelName]) {\n      parts.push(field.labels[singleLabelName]);\n      labelsAdded = true;\n    }\n  } // if we have not added frame name and no labels, and field name = Value, we should add frame name\n\n\n  if (frame && !frameNameAdded && !labelsAdded && field.name === TIME_SERIES_VALUE_FIELD_NAME) {\n    if (frame.name && frame.name.length > 0) {\n      parts.push(frame.name);\n      frameNameAdded = true;\n    }\n  }\n\n  if (parts.length) {\n    displayName = parts.join(' ');\n  } else if (field.name) {\n    displayName = field.name;\n  } else {\n    displayName = TIME_SERIES_VALUE_FIELD_NAME;\n  } // Ensure unique field name\n\n\n  if (displayName === field.name) {\n    displayName = getUniqueFieldName(field, frame);\n  }\n\n  return displayName;\n}\n\nfunction getUniqueFieldName(field, frame) {\n  let dupeCount = 0;\n  let foundSelf = false;\n\n  if (frame) {\n    for (let i = 0; i < frame.fields.length; i++) {\n      const otherField = frame.fields[i];\n\n      if (field === otherField) {\n        foundSelf = true;\n\n        if (dupeCount > 0) {\n          dupeCount++;\n          break;\n        }\n      } else if (field.name === otherField.name) {\n        dupeCount++;\n\n        if (foundSelf) {\n          break;\n        }\n      }\n    }\n  }\n\n  if (dupeCount) {\n    return `${field.name} ${dupeCount}`;\n  }\n\n  return field.name;\n}\n/**\n * Checks all data frames and return name of label if there is only one label name in all frames\n */\n\n\nfunction getSingleLabelName(frames) {\n  let singleName = null;\n\n  for (let i = 0; i < frames.length; i++) {\n    const frame = frames[i];\n\n    for (const field of frame.fields) {\n      if (!field.labels) {\n        continue;\n      } // yes this should be in!\n\n\n      for (const labelKey in field.labels) {\n        if (singleName === null) {\n          singleName = labelKey;\n        } else if (labelKey !== singleName) {\n          return null;\n        }\n      }\n    }\n  }\n\n  return singleName;\n}","map":{"version":3,"names":["TIME_SERIES_VALUE_FIELD_NAME","FieldType","TIME_SERIES_TIME_FIELD_NAME","formatLabels","getFrameDisplayName","frame","index","name","valuesWithLabels","field","fields","labels","Object","keys","length","push","undefined","filter","f","type","time","map","getFieldDisplayName","join","refId","allFrames","existingTitle","state","displayName","multipleFrames","Boolean","calculateFieldDisplayName","hasConfigTitle","config","displayNameFromDS","parts","frameNamesDiffer","i","frameNameAdded","labelsAdded","singleLabelName","getSingleLabelName","allLabels","getUniqueFieldName","dupeCount","foundSelf","otherField","frames","singleName","labelKey"],"sources":["/home/soula/grafana/packages/grafana-data/src/field/fieldState.ts"],"sourcesContent":["import { DataFrame, Field, TIME_SERIES_VALUE_FIELD_NAME, FieldType, TIME_SERIES_TIME_FIELD_NAME } from '../types';\nimport { formatLabels } from '../utils/labels';\n\n/**\n * Get an appropriate display title\n */\nexport function getFrameDisplayName(frame: DataFrame, index?: number) {\n  if (frame.name) {\n    return frame.name;\n  }\n\n  // Single field with tags\n  const valuesWithLabels: Field[] = [];\n  for (const field of frame.fields) {\n    if (field.labels && Object.keys(field.labels).length > 0) {\n      valuesWithLabels.push(field);\n    }\n  }\n\n  if (valuesWithLabels.length === 1) {\n    return formatLabels(valuesWithLabels[0].labels!);\n  }\n\n  // list all the\n  if (index === undefined) {\n    return frame.fields\n      .filter((f) => f.type !== FieldType.time)\n      .map((f) => getFieldDisplayName(f, frame))\n      .join(', ');\n  }\n\n  if (frame.refId) {\n    return `Series (${frame.refId})`;\n  }\n\n  return `Series (${index})`;\n}\n\nexport function getFieldDisplayName(field: Field, frame?: DataFrame, allFrames?: DataFrame[]): string {\n  const existingTitle = field.state?.displayName;\n  const multipleFrames = Boolean(allFrames && allFrames.length > 1);\n\n  if (existingTitle && multipleFrames === field.state?.multipleFrames) {\n    return existingTitle;\n  }\n\n  const displayName = calculateFieldDisplayName(field, frame, allFrames);\n  field.state = field.state || {};\n  field.state.displayName = displayName;\n  field.state.multipleFrames = multipleFrames;\n\n  return displayName;\n}\n\n/**\n * Get an appropriate display name. If the 'displayName' field config is set, use that.\n */\nfunction calculateFieldDisplayName(field: Field, frame?: DataFrame, allFrames?: DataFrame[]): string {\n  const hasConfigTitle = field.config?.displayName && field.config?.displayName.length;\n\n  let displayName = hasConfigTitle ? field.config!.displayName! : field.name;\n\n  if (hasConfigTitle) {\n    return displayName;\n  }\n\n  if (frame && field.config?.displayNameFromDS) {\n    return field.config.displayNameFromDS;\n  }\n\n  // This is an ugly exception for time field\n  // For time series we should normally treat time field with same name\n  // But in case it has a join source we should handle it as normal field\n  if (field.type === FieldType.time && !field.labels) {\n    return displayName ?? TIME_SERIES_TIME_FIELD_NAME;\n  }\n\n  let parts: string[] = [];\n  let frameNamesDiffer = false;\n\n  if (allFrames && allFrames.length > 1) {\n    for (let i = 1; i < allFrames.length; i++) {\n      const frame = allFrames[i];\n      if (frame.name !== allFrames[i - 1].name) {\n        frameNamesDiffer = true;\n        break;\n      }\n    }\n  }\n\n  let frameNameAdded = false;\n  let labelsAdded = false;\n\n  if (frameNamesDiffer && frame?.name) {\n    parts.push(frame.name);\n    frameNameAdded = true;\n  }\n\n  if (field.name && field.name !== TIME_SERIES_VALUE_FIELD_NAME) {\n    parts.push(field.name);\n  }\n\n  if (field.labels && frame) {\n    let singleLabelName = getSingleLabelName(allFrames ?? [frame]);\n\n    if (!singleLabelName) {\n      let allLabels = formatLabels(field.labels);\n      if (allLabels) {\n        parts.push(allLabels);\n        labelsAdded = true;\n      }\n    } else if (field.labels[singleLabelName]) {\n      parts.push(field.labels[singleLabelName]);\n      labelsAdded = true;\n    }\n  }\n\n  // if we have not added frame name and no labels, and field name = Value, we should add frame name\n  if (frame && !frameNameAdded && !labelsAdded && field.name === TIME_SERIES_VALUE_FIELD_NAME) {\n    if (frame.name && frame.name.length > 0) {\n      parts.push(frame.name);\n      frameNameAdded = true;\n    }\n  }\n\n  if (parts.length) {\n    displayName = parts.join(' ');\n  } else if (field.name) {\n    displayName = field.name;\n  } else {\n    displayName = TIME_SERIES_VALUE_FIELD_NAME;\n  }\n\n  // Ensure unique field name\n  if (displayName === field.name) {\n    displayName = getUniqueFieldName(field, frame);\n  }\n\n  return displayName;\n}\n\nfunction getUniqueFieldName(field: Field, frame?: DataFrame) {\n  let dupeCount = 0;\n  let foundSelf = false;\n\n  if (frame) {\n    for (let i = 0; i < frame.fields.length; i++) {\n      const otherField = frame.fields[i];\n\n      if (field === otherField) {\n        foundSelf = true;\n\n        if (dupeCount > 0) {\n          dupeCount++;\n          break;\n        }\n      } else if (field.name === otherField.name) {\n        dupeCount++;\n\n        if (foundSelf) {\n          break;\n        }\n      }\n    }\n  }\n\n  if (dupeCount) {\n    return `${field.name} ${dupeCount}`;\n  }\n\n  return field.name;\n}\n\n/**\n * Checks all data frames and return name of label if there is only one label name in all frames\n */\nfunction getSingleLabelName(frames: DataFrame[]): string | null {\n  let singleName: string | null = null;\n\n  for (let i = 0; i < frames.length; i++) {\n    const frame = frames[i];\n\n    for (const field of frame.fields) {\n      if (!field.labels) {\n        continue;\n      }\n\n      // yes this should be in!\n      for (const labelKey in field.labels) {\n        if (singleName === null) {\n          singleName = labelKey;\n        } else if (labelKey !== singleName) {\n          return null;\n        }\n      }\n    }\n  }\n\n  return singleName;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}