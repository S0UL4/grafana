{"ast":null,"code":"import { isExpressionQuery } from 'app/features/expressions/guards';\nexport function queriesWithUpdatedReferences(queries, previousRefId, newRefId) {\n  return queries.map(query => {\n    if (previousRefId === newRefId) {\n      return query;\n    }\n\n    if (!isExpressionQuery(query.model)) {\n      return query;\n    }\n\n    const isMathExpression = query.model.type === 'math';\n    const isReduceExpression = query.model.type === 'reduce';\n    const isResampleExpression = query.model.type === 'resample';\n    const isClassicExpression = query.model.type === 'classic_conditions';\n\n    if (isMathExpression) {\n      var _query$model$expressi;\n\n      return Object.assign({}, query, {\n        model: Object.assign({}, query.model, {\n          expression: updateMathExpressionRefs((_query$model$expressi = query.model.expression) !== null && _query$model$expressi !== void 0 ? _query$model$expressi : '', previousRefId, newRefId)\n        })\n      });\n    }\n\n    if (isResampleExpression || isReduceExpression) {\n      const isReferencing = query.model.expression === previousRefId;\n      return Object.assign({}, query, {\n        model: Object.assign({}, query.model, {\n          expression: isReferencing ? newRefId : query.model.expression\n        })\n      });\n    }\n\n    if (isClassicExpression) {\n      var _query$model$conditio;\n\n      const conditions = (_query$model$conditio = query.model.conditions) === null || _query$model$conditio === void 0 ? void 0 : _query$model$conditio.map(condition => Object.assign({}, condition, {\n        query: Object.assign({}, condition.query, {\n          params: condition.query.params.map(param => param === previousRefId ? newRefId : param)\n        })\n      }));\n      return Object.assign({}, query, {\n        model: Object.assign({}, query.model, {\n          conditions\n        })\n      });\n    }\n\n    return query;\n  });\n}\nexport function updateMathExpressionRefs(expression, previousRefId, newRefId) {\n  const oldExpression = new RegExp('(\\\\$' + previousRefId + '\\\\b)|(\\\\${' + previousRefId + '})', 'gm');\n  const newExpression = '${' + newRefId + '}';\n  return expression.replace(oldExpression, newExpression);\n} // some gateways (like Istio) will decode \"/\" and \"\\\" characters – this will cause 404 errors for any API call\n// that includes these values in the URL (ie. /my/path%2fto/resource -> /my/path/to/resource)\n//\n// see https://istio.io/latest/docs/ops/best-practices/security/#customize-your-system-on-path-normalization\n\nexport function checkForPathSeparator(value) {\n  const containsPathSeparator = value.includes('/') || value.includes('\\\\');\n\n  if (containsPathSeparator) {\n    return 'Cannot contain \"/\" or \"\\\\\" characters';\n  }\n\n  return true;\n}","map":{"version":3,"names":["isExpressionQuery","queriesWithUpdatedReferences","queries","previousRefId","newRefId","map","query","model","isMathExpression","type","isReduceExpression","isResampleExpression","isClassicExpression","expression","updateMathExpressionRefs","isReferencing","conditions","condition","params","param","oldExpression","RegExp","newExpression","replace","checkForPathSeparator","value","containsPathSeparator","includes"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/components/rule-editor/util.ts"],"sourcesContent":["import { ValidateResult } from 'react-hook-form';\n\nimport { isExpressionQuery } from 'app/features/expressions/guards';\nimport { AlertQuery } from 'app/types/unified-alerting-dto';\n\nexport function queriesWithUpdatedReferences(\n  queries: AlertQuery[],\n  previousRefId: string,\n  newRefId: string\n): AlertQuery[] {\n  return queries.map((query) => {\n    if (previousRefId === newRefId) {\n      return query;\n    }\n\n    if (!isExpressionQuery(query.model)) {\n      return query;\n    }\n\n    const isMathExpression = query.model.type === 'math';\n    const isReduceExpression = query.model.type === 'reduce';\n    const isResampleExpression = query.model.type === 'resample';\n    const isClassicExpression = query.model.type === 'classic_conditions';\n\n    if (isMathExpression) {\n      return {\n        ...query,\n        model: {\n          ...query.model,\n          expression: updateMathExpressionRefs(query.model.expression ?? '', previousRefId, newRefId),\n        },\n      };\n    }\n\n    if (isResampleExpression || isReduceExpression) {\n      const isReferencing = query.model.expression === previousRefId;\n\n      return {\n        ...query,\n        model: {\n          ...query.model,\n          expression: isReferencing ? newRefId : query.model.expression,\n        },\n      };\n    }\n\n    if (isClassicExpression) {\n      const conditions = query.model.conditions?.map((condition) => ({\n        ...condition,\n        query: {\n          ...condition.query,\n          params: condition.query.params.map((param: string) => (param === previousRefId ? newRefId : param)),\n        },\n      }));\n\n      return { ...query, model: { ...query.model, conditions } };\n    }\n\n    return query;\n  });\n}\n\nexport function updateMathExpressionRefs(expression: string, previousRefId: string, newRefId: string): string {\n  const oldExpression = new RegExp('(\\\\$' + previousRefId + '\\\\b)|(\\\\${' + previousRefId + '})', 'gm');\n  const newExpression = '${' + newRefId + '}';\n\n  return expression.replace(oldExpression, newExpression);\n}\n\n// some gateways (like Istio) will decode \"/\" and \"\\\" characters – this will cause 404 errors for any API call\n// that includes these values in the URL (ie. /my/path%2fto/resource -> /my/path/to/resource)\n//\n// see https://istio.io/latest/docs/ops/best-practices/security/#customize-your-system-on-path-normalization\nexport function checkForPathSeparator(value: string): ValidateResult {\n  const containsPathSeparator = value.includes('/') || value.includes('\\\\');\n  if (containsPathSeparator) {\n    return 'Cannot contain \"/\" or \"\\\\\" characters';\n  }\n\n  return true;\n}\n"],"mappings":"AAEA,SAASA,iBAAT,QAAkC,iCAAlC;AAGA,OAAO,SAASC,4BAAT,CACLC,OADK,EAELC,aAFK,EAGLC,QAHK,EAIS;EACd,OAAOF,OAAO,CAACG,GAAR,CAAaC,KAAD,IAAW;IAC5B,IAAIH,aAAa,KAAKC,QAAtB,EAAgC;MAC9B,OAAOE,KAAP;IACD;;IAED,IAAI,CAACN,iBAAiB,CAACM,KAAK,CAACC,KAAP,CAAtB,EAAqC;MACnC,OAAOD,KAAP;IACD;;IAED,MAAME,gBAAgB,GAAGF,KAAK,CAACC,KAAN,CAAYE,IAAZ,KAAqB,MAA9C;IACA,MAAMC,kBAAkB,GAAGJ,KAAK,CAACC,KAAN,CAAYE,IAAZ,KAAqB,QAAhD;IACA,MAAME,oBAAoB,GAAGL,KAAK,CAACC,KAAN,CAAYE,IAAZ,KAAqB,UAAlD;IACA,MAAMG,mBAAmB,GAAGN,KAAK,CAACC,KAAN,CAAYE,IAAZ,KAAqB,oBAAjD;;IAEA,IAAID,gBAAJ,EAAsB;MAAA;;MACpB,yBACKF,KADL;QAEEC,KAAK,oBACAD,KAAK,CAACC,KADN;UAEHM,UAAU,EAAEC,wBAAwB,0BAACR,KAAK,CAACC,KAAN,CAAYM,UAAb,yEAA2B,EAA3B,EAA+BV,aAA/B,EAA8CC,QAA9C;QAFjC;MAFP;IAOD;;IAED,IAAIO,oBAAoB,IAAID,kBAA5B,EAAgD;MAC9C,MAAMK,aAAa,GAAGT,KAAK,CAACC,KAAN,CAAYM,UAAZ,KAA2BV,aAAjD;MAEA,yBACKG,KADL;QAEEC,KAAK,oBACAD,KAAK,CAACC,KADN;UAEHM,UAAU,EAAEE,aAAa,GAAGX,QAAH,GAAcE,KAAK,CAACC,KAAN,CAAYM;QAFhD;MAFP;IAOD;;IAED,IAAID,mBAAJ,EAAyB;MAAA;;MACvB,MAAMI,UAAU,4BAAGV,KAAK,CAACC,KAAN,CAAYS,UAAf,0DAAG,sBAAwBX,GAAxB,CAA6BY,SAAD,sBAC1CA,SAD0C;QAE7CX,KAAK,oBACAW,SAAS,CAACX,KADV;UAEHY,MAAM,EAAED,SAAS,CAACX,KAAV,CAAgBY,MAAhB,CAAuBb,GAAvB,CAA4Bc,KAAD,IAAoBA,KAAK,KAAKhB,aAAV,GAA0BC,QAA1B,GAAqCe,KAApF;QAFL;MAFwC,EAA5B,CAAnB;MAQA,yBAAYb,KAAZ;QAAmBC,KAAK,oBAAOD,KAAK,CAACC,KAAb;UAAoBS;QAApB;MAAxB;IACD;;IAED,OAAOV,KAAP;EACD,CAjDM,CAAP;AAkDD;AAED,OAAO,SAASQ,wBAAT,CAAkCD,UAAlC,EAAsDV,aAAtD,EAA6EC,QAA7E,EAAuG;EAC5G,MAAMgB,aAAa,GAAG,IAAIC,MAAJ,CAAW,SAASlB,aAAT,GAAyB,YAAzB,GAAwCA,aAAxC,GAAwD,IAAnE,EAAyE,IAAzE,CAAtB;EACA,MAAMmB,aAAa,GAAG,OAAOlB,QAAP,GAAkB,GAAxC;EAEA,OAAOS,UAAU,CAACU,OAAX,CAAmBH,aAAnB,EAAkCE,aAAlC,CAAP;AACD,C,CAED;AACA;AACA;AACA;;AACA,OAAO,SAASE,qBAAT,CAA+BC,KAA/B,EAA8D;EACnE,MAAMC,qBAAqB,GAAGD,KAAK,CAACE,QAAN,CAAe,GAAf,KAAuBF,KAAK,CAACE,QAAN,CAAe,IAAf,CAArD;;EACA,IAAID,qBAAJ,EAA2B;IACzB,OAAO,uCAAP;EACD;;EAED,OAAO,IAAP;AACD"},"metadata":{},"sourceType":"module"}