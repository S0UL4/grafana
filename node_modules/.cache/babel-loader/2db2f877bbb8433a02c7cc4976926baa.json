{"ast":null,"code":"import { defaultMetricAgg } from '../../../../query_def';\nimport { removeEmpty } from '../../../../utils';\nimport { initQuery } from '../../state';\nimport { isMetricAggregationWithMeta, isMetricAggregationWithSettings, isPipelineAggregation } from '../aggregations';\nimport { getChildren, metricAggregationConfig } from '../utils';\nimport { addMetric, changeMetricAttribute, changeMetricField, changeMetricMeta, changeMetricSetting, changeMetricType, removeMetric, toggleMetricVisibility } from './actions';\nexport const reducer = (state, action) => {\n  if (addMetric.match(action)) {\n    return [...state, defaultMetricAgg(action.payload)];\n  }\n\n  if (removeMetric.match(action)) {\n    const metricToRemove = state.find(m => m.id === action.payload);\n    const metricsToRemove = [metricToRemove, ...getChildren(metricToRemove, state)];\n    const resultingMetrics = state.filter(metric => !metricsToRemove.some(toRemove => toRemove.id === metric.id));\n\n    if (resultingMetrics.length === 0) {\n      return [defaultMetricAgg('1')];\n    }\n\n    return resultingMetrics;\n  }\n\n  if (changeMetricType.match(action)) {\n    return state.filter(metric => // When the new metric type is `isSingleMetric` we remove all other metrics from the query\n    // leaving only the current one.\n    !!metricAggregationConfig[action.payload.type].isSingleMetric ? metric.id === action.payload.id : true).map(metric => {\n      if (metric.id !== action.payload.id) {\n        return metric;\n      }\n      /*\n      TODO: The previous version of the query editor was keeping some of the old metric's configurations\n      in the new selected one (such as field or some settings).\n      It the future would be nice to have the same behavior but it's hard without a proper definition,\n      as Elasticsearch will error sometimes if some settings are not compatible.\n      */\n\n\n      return Object.assign({\n        id: metric.id,\n        type: action.payload.type\n      }, metricAggregationConfig[action.payload.type].defaults);\n    });\n  }\n\n  if (changeMetricField.match(action)) {\n    return state.map(metric => {\n      if (metric.id !== action.payload.id) {\n        return metric;\n      }\n\n      const newMetric = Object.assign({}, metric, {\n        field: action.payload.field\n      });\n\n      if (isPipelineAggregation(metric)) {\n        return Object.assign({}, newMetric, {\n          pipelineAgg: action.payload.field\n        });\n      }\n\n      return newMetric;\n    });\n  }\n\n  if (toggleMetricVisibility.match(action)) {\n    return state.map(metric => {\n      if (metric.id !== action.payload) {\n        return metric;\n      }\n\n      return Object.assign({}, metric, {\n        hide: !metric.hide\n      });\n    });\n  }\n\n  if (changeMetricSetting.match(action)) {\n    return state.map(metric => {\n      if (metric.id !== action.payload.metric.id) {\n        return metric;\n      } // TODO: Here, instead of this if statement, we should assert that metric is MetricAggregationWithSettings\n\n\n      if (isMetricAggregationWithSettings(metric)) {\n        const newSettings = removeEmpty(Object.assign({}, metric.settings, {\n          [action.payload.settingName]: action.payload.newValue\n        }));\n        return Object.assign({}, metric, {\n          settings: Object.assign({}, newSettings)\n        });\n      } // This should never happen.\n\n\n      return metric;\n    });\n  }\n\n  if (changeMetricMeta.match(action)) {\n    return state.map(metric => {\n      if (metric.id !== action.payload.metric.id) {\n        return metric;\n      } // TODO: Here, instead of this if statement, we should assert that metric is MetricAggregationWithMeta\n\n\n      if (isMetricAggregationWithMeta(metric)) {\n        return Object.assign({}, metric, {\n          meta: Object.assign({}, metric.meta, {\n            [action.payload.meta]: action.payload.newValue\n          })\n        });\n      } // This should never happen.\n\n\n      return metric;\n    });\n  }\n\n  if (changeMetricAttribute.match(action)) {\n    return state.map(metric => {\n      if (metric.id !== action.payload.metric.id) {\n        return metric;\n      }\n\n      return Object.assign({}, metric, {\n        [action.payload.attribute]: action.payload.newValue\n      });\n    });\n  }\n\n  if (initQuery.match(action)) {\n    if (state !== null && state !== void 0 && state.length || 0 > 0) {\n      return state;\n    }\n\n    return [defaultMetricAgg('1')];\n  }\n\n  return state;\n};","map":{"version":3,"names":["defaultMetricAgg","removeEmpty","initQuery","isMetricAggregationWithMeta","isMetricAggregationWithSettings","isPipelineAggregation","getChildren","metricAggregationConfig","addMetric","changeMetricAttribute","changeMetricField","changeMetricMeta","changeMetricSetting","changeMetricType","removeMetric","toggleMetricVisibility","reducer","state","action","match","payload","metricToRemove","find","m","id","metricsToRemove","resultingMetrics","filter","metric","some","toRemove","length","type","isSingleMetric","map","defaults","newMetric","field","pipelineAgg","hide","newSettings","settings","settingName","newValue","meta","attribute"],"sources":["/home/soula/grafana/public/app/plugins/datasource/elasticsearch/components/QueryEditor/MetricAggregationsEditor/state/reducer.ts"],"sourcesContent":["import { Action } from '@reduxjs/toolkit';\n\nimport { defaultMetricAgg } from '../../../../query_def';\nimport { ElasticsearchQuery } from '../../../../types';\nimport { removeEmpty } from '../../../../utils';\nimport { initQuery } from '../../state';\nimport {\n  isMetricAggregationWithMeta,\n  isMetricAggregationWithSettings,\n  isPipelineAggregation,\n  MetricAggregation,\n} from '../aggregations';\nimport { getChildren, metricAggregationConfig } from '../utils';\n\nimport {\n  addMetric,\n  changeMetricAttribute,\n  changeMetricField,\n  changeMetricMeta,\n  changeMetricSetting,\n  changeMetricType,\n  removeMetric,\n  toggleMetricVisibility,\n} from './actions';\n\nexport const reducer = (state: ElasticsearchQuery['metrics'], action: Action): ElasticsearchQuery['metrics'] => {\n  if (addMetric.match(action)) {\n    return [...state!, defaultMetricAgg(action.payload)];\n  }\n\n  if (removeMetric.match(action)) {\n    const metricToRemove = state!.find((m) => m.id === action.payload)!;\n    const metricsToRemove = [metricToRemove, ...getChildren(metricToRemove, state!)];\n    const resultingMetrics = state!.filter((metric) => !metricsToRemove.some((toRemove) => toRemove.id === metric.id));\n    if (resultingMetrics.length === 0) {\n      return [defaultMetricAgg('1')];\n    }\n    return resultingMetrics;\n  }\n\n  if (changeMetricType.match(action)) {\n    return state!\n      .filter((metric) =>\n        // When the new metric type is `isSingleMetric` we remove all other metrics from the query\n        // leaving only the current one.\n        !!metricAggregationConfig[action.payload.type].isSingleMetric ? metric.id === action.payload.id : true\n      )\n      .map((metric) => {\n        if (metric.id !== action.payload.id) {\n          return metric;\n        }\n\n        /*\n        TODO: The previous version of the query editor was keeping some of the old metric's configurations\n        in the new selected one (such as field or some settings).\n        It the future would be nice to have the same behavior but it's hard without a proper definition,\n        as Elasticsearch will error sometimes if some settings are not compatible.\n      */\n        return {\n          id: metric.id,\n          type: action.payload.type,\n          ...metricAggregationConfig[action.payload.type].defaults,\n        } as MetricAggregation;\n      });\n  }\n\n  if (changeMetricField.match(action)) {\n    return state!.map((metric) => {\n      if (metric.id !== action.payload.id) {\n        return metric;\n      }\n\n      const newMetric = {\n        ...metric,\n        field: action.payload.field,\n      };\n\n      if (isPipelineAggregation(metric)) {\n        return { ...newMetric, pipelineAgg: action.payload.field };\n      }\n\n      return newMetric;\n    });\n  }\n\n  if (toggleMetricVisibility.match(action)) {\n    return state!.map((metric) => {\n      if (metric.id !== action.payload) {\n        return metric;\n      }\n\n      return {\n        ...metric,\n        hide: !metric.hide,\n      };\n    });\n  }\n\n  if (changeMetricSetting.match(action)) {\n    return state!.map((metric) => {\n      if (metric.id !== action.payload.metric.id) {\n        return metric;\n      }\n\n      // TODO: Here, instead of this if statement, we should assert that metric is MetricAggregationWithSettings\n      if (isMetricAggregationWithSettings(metric)) {\n        const newSettings = removeEmpty({\n          ...metric.settings,\n          [action.payload.settingName]: action.payload.newValue,\n        });\n\n        return {\n          ...metric,\n          settings: {\n            ...newSettings,\n          },\n        };\n      }\n\n      // This should never happen.\n      return metric;\n    });\n  }\n\n  if (changeMetricMeta.match(action)) {\n    return state!.map((metric) => {\n      if (metric.id !== action.payload.metric.id) {\n        return metric;\n      }\n\n      // TODO: Here, instead of this if statement, we should assert that metric is MetricAggregationWithMeta\n      if (isMetricAggregationWithMeta(metric)) {\n        return {\n          ...metric,\n          meta: {\n            ...metric.meta,\n            [action.payload.meta]: action.payload.newValue,\n          },\n        };\n      }\n\n      // This should never happen.\n      return metric;\n    });\n  }\n\n  if (changeMetricAttribute.match(action)) {\n    return state!.map((metric) => {\n      if (metric.id !== action.payload.metric.id) {\n        return metric;\n      }\n\n      return {\n        ...metric,\n        [action.payload.attribute]: action.payload.newValue,\n      };\n    });\n  }\n\n  if (initQuery.match(action)) {\n    if (state?.length || 0 > 0) {\n      return state;\n    }\n    return [defaultMetricAgg('1')];\n  }\n\n  return state;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}