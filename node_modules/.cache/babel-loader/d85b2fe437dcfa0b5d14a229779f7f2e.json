{"ast":null,"code":"import { GRAFANA_RULES_SOURCE_NAME } from './datasource';\nimport { isAlertingRule, isAlertingRulerRule, isCloudRuleIdentifier, isGrafanaRuleIdentifier, isGrafanaRulerRule, isPrometheusRuleIdentifier, isRecordingRule, isRecordingRulerRule } from './rules';\nexport function fromRulerRule(ruleSourceName, namespace, groupName, rule) {\n  if (isGrafanaRulerRule(rule)) {\n    return {\n      uid: rule.grafana_alert.uid,\n      ruleSourceName: 'grafana'\n    };\n  }\n\n  return {\n    ruleSourceName,\n    namespace,\n    groupName,\n    rulerRuleHash: hashRulerRule(rule)\n  };\n}\nexport function fromRule(ruleSourceName, namespace, groupName, rule) {\n  return {\n    ruleSourceName,\n    namespace,\n    groupName,\n    ruleHash: hashRule(rule)\n  };\n}\nexport function fromCombinedRule(ruleSourceName, rule) {\n  const namespaceName = rule.namespace.name;\n  const groupName = rule.group.name;\n\n  if (rule.rulerRule) {\n    return fromRulerRule(ruleSourceName, namespaceName, groupName, rule.rulerRule);\n  }\n\n  if (rule.promRule) {\n    return fromRule(ruleSourceName, namespaceName, groupName, rule.promRule);\n  }\n\n  throw new Error('Could not create an id for a rule that is missing both `rulerRule` and `promRule`.');\n}\nexport function fromRuleWithLocation(rule) {\n  return fromRulerRule(rule.ruleSourceName, rule.namespace, rule.group.name, rule.rule);\n}\nexport function equal(a, b) {\n  if (isGrafanaRuleIdentifier(a) && isGrafanaRuleIdentifier(b)) {\n    return a.uid === b.uid;\n  }\n\n  if (isCloudRuleIdentifier(a) && isCloudRuleIdentifier(b)) {\n    return a.groupName === b.groupName && a.namespace === b.namespace && a.rulerRuleHash === b.rulerRuleHash && a.ruleSourceName === b.ruleSourceName;\n  }\n\n  if (isPrometheusRuleIdentifier(a) && isPrometheusRuleIdentifier(b)) {\n    return a.groupName === b.groupName && a.namespace === b.namespace && a.ruleHash === b.ruleHash && a.ruleSourceName === b.ruleSourceName;\n  }\n\n  return false;\n}\nconst cloudRuleIdentifierPrefix = 'cri';\nconst prometheusRuleIdentifierPrefix = 'pri';\n\nfunction escapeDollars(value) {\n  return value.replace(/\\$/g, '_DOLLAR_');\n}\n\nfunction unesacapeDollars(value) {\n  return value.replace(/\\_DOLLAR\\_/g, '$');\n}\n\nexport function parse(value, decodeFromUri = false) {\n  const source = decodeFromUri ? decodeURIComponent(value) : value;\n  const parts = source.split('$');\n\n  if (parts.length === 1) {\n    return {\n      uid: value,\n      ruleSourceName: 'grafana'\n    };\n  }\n\n  if (parts.length === 5) {\n    const [prefix, ruleSourceName, namespace, groupName, hash] = parts.map(unesacapeDollars);\n\n    if (prefix === cloudRuleIdentifierPrefix) {\n      return {\n        ruleSourceName,\n        namespace,\n        groupName,\n        rulerRuleHash: Number(hash)\n      };\n    }\n\n    if (prefix === prometheusRuleIdentifierPrefix) {\n      return {\n        ruleSourceName,\n        namespace,\n        groupName,\n        ruleHash: Number(hash)\n      };\n    }\n  }\n\n  throw new Error(`Failed to parse rule location: ${value}`);\n}\nexport function tryParse(value, decodeFromUri = false) {\n  if (!value) {\n    return;\n  }\n\n  try {\n    return parse(value, decodeFromUri);\n  } catch (error) {\n    return;\n  }\n}\nexport function stringifyIdentifier(identifier) {\n  if (isGrafanaRuleIdentifier(identifier)) {\n    return identifier.uid;\n  }\n\n  if (isCloudRuleIdentifier(identifier)) {\n    return [cloudRuleIdentifierPrefix, identifier.ruleSourceName, identifier.namespace, identifier.groupName, identifier.rulerRuleHash].map(String).map(escapeDollars).join('$');\n  }\n\n  return [prometheusRuleIdentifierPrefix, identifier.ruleSourceName, identifier.namespace, identifier.groupName, identifier.ruleHash].map(String).map(escapeDollars).join('$');\n}\n\nfunction hash(value) {\n  let hash = 0;\n\n  if (value.length === 0) {\n    return hash;\n  }\n\n  for (var i = 0; i < value.length; i++) {\n    var char = value.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n\n  return hash;\n} // this is used to identify lotex rules, as they do not have a unique identifier\n\n\nfunction hashRulerRule(rule) {\n  if (isRecordingRulerRule(rule)) {\n    return hash(JSON.stringify([rule.record, rule.expr, hashLabelsOrAnnotations(rule.labels)]));\n  } else if (isAlertingRulerRule(rule)) {\n    return hash(JSON.stringify([rule.alert, rule.expr, hashLabelsOrAnnotations(rule.annotations), hashLabelsOrAnnotations(rule.labels)]));\n  } else {\n    throw new Error('only recording and alerting ruler rules can be hashed');\n  }\n}\n\nfunction hashRule(rule) {\n  if (isRecordingRule(rule)) {\n    return hash(JSON.stringify([rule.type, rule.query, hashLabelsOrAnnotations(rule.labels)]));\n  }\n\n  if (isAlertingRule(rule)) {\n    return hash(JSON.stringify([rule.type, rule.query, hashLabelsOrAnnotations(rule.annotations), hashLabelsOrAnnotations(rule.labels)]));\n  }\n\n  throw new Error('only recording and alerting rules can be hashed');\n}\n\nfunction hashLabelsOrAnnotations(item) {\n  return JSON.stringify(Object.entries(item || {}).sort((a, b) => a[0].localeCompare(b[0])));\n}\n\nexport function ruleIdentifierToRuleSourceName(identifier) {\n  return isGrafanaRuleIdentifier(identifier) ? GRAFANA_RULES_SOURCE_NAME : identifier.ruleSourceName;\n}","map":{"version":3,"names":["GRAFANA_RULES_SOURCE_NAME","isAlertingRule","isAlertingRulerRule","isCloudRuleIdentifier","isGrafanaRuleIdentifier","isGrafanaRulerRule","isPrometheusRuleIdentifier","isRecordingRule","isRecordingRulerRule","fromRulerRule","ruleSourceName","namespace","groupName","rule","uid","grafana_alert","rulerRuleHash","hashRulerRule","fromRule","ruleHash","hashRule","fromCombinedRule","namespaceName","name","group","rulerRule","promRule","Error","fromRuleWithLocation","equal","a","b","cloudRuleIdentifierPrefix","prometheusRuleIdentifierPrefix","escapeDollars","value","replace","unesacapeDollars","parse","decodeFromUri","source","decodeURIComponent","parts","split","length","prefix","hash","map","Number","tryParse","error","stringifyIdentifier","identifier","String","join","i","char","charCodeAt","JSON","stringify","record","expr","hashLabelsOrAnnotations","labels","alert","annotations","type","query","item","Object","entries","sort","localeCompare","ruleIdentifierToRuleSourceName"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/utils/rule-id.ts"],"sourcesContent":["import { CombinedRule, Rule, RuleIdentifier, RuleWithLocation } from 'app/types/unified-alerting';\nimport { Annotations, Labels, RulerRuleDTO } from 'app/types/unified-alerting-dto';\n\nimport { GRAFANA_RULES_SOURCE_NAME } from './datasource';\nimport {\n  isAlertingRule,\n  isAlertingRulerRule,\n  isCloudRuleIdentifier,\n  isGrafanaRuleIdentifier,\n  isGrafanaRulerRule,\n  isPrometheusRuleIdentifier,\n  isRecordingRule,\n  isRecordingRulerRule,\n} from './rules';\n\nexport function fromRulerRule(\n  ruleSourceName: string,\n  namespace: string,\n  groupName: string,\n  rule: RulerRuleDTO\n): RuleIdentifier {\n  if (isGrafanaRulerRule(rule)) {\n    return { uid: rule.grafana_alert.uid!, ruleSourceName: 'grafana' };\n  }\n  return {\n    ruleSourceName,\n    namespace,\n    groupName,\n    rulerRuleHash: hashRulerRule(rule),\n  };\n}\n\nexport function fromRule(ruleSourceName: string, namespace: string, groupName: string, rule: Rule): RuleIdentifier {\n  return {\n    ruleSourceName,\n    namespace,\n    groupName,\n    ruleHash: hashRule(rule),\n  };\n}\n\nexport function fromCombinedRule(ruleSourceName: string, rule: CombinedRule): RuleIdentifier {\n  const namespaceName = rule.namespace.name;\n  const groupName = rule.group.name;\n\n  if (rule.rulerRule) {\n    return fromRulerRule(ruleSourceName, namespaceName, groupName, rule.rulerRule);\n  }\n\n  if (rule.promRule) {\n    return fromRule(ruleSourceName, namespaceName, groupName, rule.promRule);\n  }\n\n  throw new Error('Could not create an id for a rule that is missing both `rulerRule` and `promRule`.');\n}\n\nexport function fromRuleWithLocation(rule: RuleWithLocation): RuleIdentifier {\n  return fromRulerRule(rule.ruleSourceName, rule.namespace, rule.group.name, rule.rule);\n}\n\nexport function equal(a: RuleIdentifier, b: RuleIdentifier) {\n  if (isGrafanaRuleIdentifier(a) && isGrafanaRuleIdentifier(b)) {\n    return a.uid === b.uid;\n  }\n\n  if (isCloudRuleIdentifier(a) && isCloudRuleIdentifier(b)) {\n    return (\n      a.groupName === b.groupName &&\n      a.namespace === b.namespace &&\n      a.rulerRuleHash === b.rulerRuleHash &&\n      a.ruleSourceName === b.ruleSourceName\n    );\n  }\n\n  if (isPrometheusRuleIdentifier(a) && isPrometheusRuleIdentifier(b)) {\n    return (\n      a.groupName === b.groupName &&\n      a.namespace === b.namespace &&\n      a.ruleHash === b.ruleHash &&\n      a.ruleSourceName === b.ruleSourceName\n    );\n  }\n\n  return false;\n}\n\nconst cloudRuleIdentifierPrefix = 'cri';\nconst prometheusRuleIdentifierPrefix = 'pri';\n\nfunction escapeDollars(value: string): string {\n  return value.replace(/\\$/g, '_DOLLAR_');\n}\n\nfunction unesacapeDollars(value: string): string {\n  return value.replace(/\\_DOLLAR\\_/g, '$');\n}\n\nexport function parse(value: string, decodeFromUri = false): RuleIdentifier {\n  const source = decodeFromUri ? decodeURIComponent(value) : value;\n  const parts = source.split('$');\n\n  if (parts.length === 1) {\n    return { uid: value, ruleSourceName: 'grafana' };\n  }\n\n  if (parts.length === 5) {\n    const [prefix, ruleSourceName, namespace, groupName, hash] = parts.map(unesacapeDollars);\n\n    if (prefix === cloudRuleIdentifierPrefix) {\n      return { ruleSourceName, namespace, groupName, rulerRuleHash: Number(hash) };\n    }\n\n    if (prefix === prometheusRuleIdentifierPrefix) {\n      return { ruleSourceName, namespace, groupName, ruleHash: Number(hash) };\n    }\n  }\n\n  throw new Error(`Failed to parse rule location: ${value}`);\n}\n\nexport function tryParse(value: string | undefined, decodeFromUri = false): RuleIdentifier | undefined {\n  if (!value) {\n    return;\n  }\n\n  try {\n    return parse(value, decodeFromUri);\n  } catch (error) {\n    return;\n  }\n}\n\nexport function stringifyIdentifier(identifier: RuleIdentifier): string {\n  if (isGrafanaRuleIdentifier(identifier)) {\n    return identifier.uid;\n  }\n\n  if (isCloudRuleIdentifier(identifier)) {\n    return [\n      cloudRuleIdentifierPrefix,\n      identifier.ruleSourceName,\n      identifier.namespace,\n      identifier.groupName,\n      identifier.rulerRuleHash,\n    ]\n      .map(String)\n      .map(escapeDollars)\n      .join('$');\n  }\n\n  return [\n    prometheusRuleIdentifierPrefix,\n    identifier.ruleSourceName,\n    identifier.namespace,\n    identifier.groupName,\n    identifier.ruleHash,\n  ]\n    .map(String)\n    .map(escapeDollars)\n    .join('$');\n}\n\nfunction hash(value: string): number {\n  let hash = 0;\n  if (value.length === 0) {\n    return hash;\n  }\n  for (var i = 0; i < value.length; i++) {\n    var char = value.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash;\n}\n\n// this is used to identify lotex rules, as they do not have a unique identifier\nfunction hashRulerRule(rule: RulerRuleDTO): number {\n  if (isRecordingRulerRule(rule)) {\n    return hash(JSON.stringify([rule.record, rule.expr, hashLabelsOrAnnotations(rule.labels)]));\n  } else if (isAlertingRulerRule(rule)) {\n    return hash(\n      JSON.stringify([\n        rule.alert,\n        rule.expr,\n        hashLabelsOrAnnotations(rule.annotations),\n        hashLabelsOrAnnotations(rule.labels),\n      ])\n    );\n  } else {\n    throw new Error('only recording and alerting ruler rules can be hashed');\n  }\n}\n\nfunction hashRule(rule: Rule): number {\n  if (isRecordingRule(rule)) {\n    return hash(JSON.stringify([rule.type, rule.query, hashLabelsOrAnnotations(rule.labels)]));\n  }\n\n  if (isAlertingRule(rule)) {\n    return hash(\n      JSON.stringify([\n        rule.type,\n        rule.query,\n        hashLabelsOrAnnotations(rule.annotations),\n        hashLabelsOrAnnotations(rule.labels),\n      ])\n    );\n  }\n\n  throw new Error('only recording and alerting rules can be hashed');\n}\n\nfunction hashLabelsOrAnnotations(item: Labels | Annotations | undefined): string {\n  return JSON.stringify(Object.entries(item || {}).sort((a, b) => a[0].localeCompare(b[0])));\n}\n\nexport function ruleIdentifierToRuleSourceName(identifier: RuleIdentifier): string {\n  return isGrafanaRuleIdentifier(identifier) ? GRAFANA_RULES_SOURCE_NAME : identifier.ruleSourceName;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}