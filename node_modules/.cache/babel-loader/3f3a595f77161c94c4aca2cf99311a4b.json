{"ast":null,"code":"import { metricAggregationConfig } from './utils';\nexport const isEWMAMovingAverage = metric => {\n  var _metric$settings;\n\n  return ((_metric$settings = metric.settings) === null || _metric$settings === void 0 ? void 0 : _metric$settings.model) === 'ewma';\n};\nexport const isHoltMovingAverage = metric => {\n  var _metric$settings2;\n\n  return ((_metric$settings2 = metric.settings) === null || _metric$settings2 === void 0 ? void 0 : _metric$settings2.model) === 'holt';\n};\nexport const isHoltWintersMovingAverage = metric => {\n  var _metric$settings3;\n\n  return ((_metric$settings3 = metric.settings) === null || _metric$settings3 === void 0 ? void 0 : _metric$settings3.model) === 'holt_winters';\n};\nexport const isMovingAverageWithModelSettings = metric => {\n  var _metric$settings4;\n\n  return ['holt', 'ewma', 'holt_winters'].includes(((_metric$settings4 = metric.settings) === null || _metric$settings4 === void 0 ? void 0 : _metric$settings4.model) || '');\n};\n// Guards\n// Given the structure of the aggregations (ie. `settings` field being always optional) we cannot\n// determine types based solely on objects' properties, therefore we use `metricAggregationConfig` as the\n// source of truth.\n\n/**\n * Checks if `metric` requires a field (either referring to a document or another aggregation)\n * @param metric\n */\nexport const isMetricAggregationWithField = metric => metricAggregationConfig[metric.type].requiresField;\nexport const isPipelineAggregation = metric => metricAggregationConfig[metric.type].isPipelineAgg;\nexport const isPipelineAggregationWithMultipleBucketPaths = metric => metricAggregationConfig[metric.type].supportsMultipleBucketPaths;\nexport const isMetricAggregationWithMissingSupport = metric => metricAggregationConfig[metric.type].supportsMissing;\nexport const isMetricAggregationWithSettings = metric => metricAggregationConfig[metric.type].hasSettings;\nexport const isMetricAggregationWithMeta = metric => metricAggregationConfig[metric.type].hasMeta;\nexport const isMetricAggregationWithInlineScript = metric => metricAggregationConfig[metric.type].supportsInlineScript;\nexport const METRIC_AGGREGATION_TYPES = ['count', 'avg', 'sum', 'min', 'max', 'extended_stats', 'percentiles', 'cardinality', 'raw_document', 'raw_data', 'logs', 'moving_avg', 'moving_fn', 'derivative', 'serial_diff', 'cumulative_sum', 'bucket_script', 'rate', 'top_metrics'];\nexport const isMetricAggregationType = s => METRIC_AGGREGATION_TYPES.includes(s);","map":{"version":3,"names":["metricAggregationConfig","isEWMAMovingAverage","metric","settings","model","isHoltMovingAverage","isHoltWintersMovingAverage","isMovingAverageWithModelSettings","includes","isMetricAggregationWithField","type","requiresField","isPipelineAggregation","isPipelineAgg","isPipelineAggregationWithMultipleBucketPaths","supportsMultipleBucketPaths","isMetricAggregationWithMissingSupport","supportsMissing","isMetricAggregationWithSettings","hasSettings","isMetricAggregationWithMeta","hasMeta","isMetricAggregationWithInlineScript","supportsInlineScript","METRIC_AGGREGATION_TYPES","isMetricAggregationType","s"],"sources":["/home/soula/grafana/public/app/plugins/datasource/elasticsearch/components/QueryEditor/MetricAggregationsEditor/aggregations.ts"],"sourcesContent":["import { metricAggregationConfig } from './utils';\n\nexport type PipelineMetricAggregationType =\n  | 'moving_avg'\n  | 'moving_fn'\n  | 'derivative'\n  | 'serial_diff'\n  | 'cumulative_sum'\n  | 'bucket_script';\n\nexport type MetricAggregationType =\n  | 'count'\n  | 'avg'\n  | 'sum'\n  | 'min'\n  | 'max'\n  | 'extended_stats'\n  | 'percentiles'\n  | 'cardinality'\n  | 'raw_document'\n  | 'raw_data'\n  | 'logs'\n  | 'rate'\n  | 'top_metrics'\n  | PipelineMetricAggregationType;\n\ninterface BaseMetricAggregation {\n  id: string;\n  type: MetricAggregationType;\n  hide?: boolean;\n}\n\nexport interface PipelineVariable {\n  name: string;\n  pipelineAgg: string;\n}\n\nexport interface MetricAggregationWithField extends BaseMetricAggregation {\n  field?: string;\n}\n\nexport interface MetricAggregationWithMissingSupport extends BaseMetricAggregation {\n  settings?: {\n    missing?: string;\n  };\n}\n\ntype InlineScript = string | { inline?: string };\nexport interface MetricAggregationWithInlineScript extends BaseMetricAggregation {\n  settings?: {\n    script?: InlineScript;\n  };\n}\n\nexport interface Count extends BaseMetricAggregation {\n  type: 'count';\n}\n\nexport interface Average\n  extends MetricAggregationWithField,\n    MetricAggregationWithMissingSupport,\n    MetricAggregationWithInlineScript {\n  type: 'avg';\n  settings?: {\n    script?: InlineScript;\n    missing?: string;\n  };\n}\n\nexport interface Sum extends MetricAggregationWithField, MetricAggregationWithInlineScript {\n  type: 'sum';\n  settings?: {\n    script?: InlineScript;\n    missing?: string;\n  };\n}\n\nexport interface Max extends MetricAggregationWithField, MetricAggregationWithInlineScript {\n  type: 'max';\n  settings?: {\n    script?: InlineScript;\n    missing?: string;\n  };\n}\n\nexport interface Min extends MetricAggregationWithField, MetricAggregationWithInlineScript {\n  type: 'min';\n  settings?: {\n    script?: InlineScript;\n    missing?: string;\n  };\n}\n\nexport type ExtendedStatMetaType =\n  | 'avg'\n  | 'min'\n  | 'max'\n  | 'sum'\n  | 'count'\n  | 'std_deviation'\n  | 'std_deviation_bounds_upper'\n  | 'std_deviation_bounds_lower';\nexport interface ExtendedStat {\n  label: string;\n  value: ExtendedStatMetaType;\n}\n\nexport interface ExtendedStats extends MetricAggregationWithField, MetricAggregationWithInlineScript {\n  type: 'extended_stats';\n  settings?: {\n    script?: InlineScript;\n    missing?: string;\n    sigma?: string;\n  };\n  meta?: {\n    [P in ExtendedStatMetaType]?: boolean;\n  };\n}\n\nexport interface Percentiles extends MetricAggregationWithField, MetricAggregationWithInlineScript {\n  type: 'percentiles';\n  settings?: {\n    percents?: string[];\n    script?: InlineScript;\n    missing?: string;\n  };\n}\n\nexport interface UniqueCount extends MetricAggregationWithField {\n  type: 'cardinality';\n  settings?: {\n    precision_threshold?: string;\n    missing?: string;\n  };\n}\n\nexport interface RawDocument extends BaseMetricAggregation {\n  type: 'raw_document';\n  settings?: {\n    size?: string;\n  };\n}\n\nexport interface RawData extends BaseMetricAggregation {\n  type: 'raw_data';\n  settings?: {\n    size?: string;\n  };\n}\n\nexport interface Logs extends BaseMetricAggregation {\n  type: 'logs';\n  settings?: {\n    limit?: string;\n  };\n}\n\nexport interface Rate extends MetricAggregationWithField {\n  type: 'rate';\n  settings?: {\n    unit?: string;\n    mode?: string;\n  };\n}\n\nexport interface BasePipelineMetricAggregation extends MetricAggregationWithField {\n  type: PipelineMetricAggregationType;\n  pipelineAgg?: string;\n}\n\nexport interface PipelineMetricAggregationWithMultipleBucketPaths extends BaseMetricAggregation {\n  type: PipelineMetricAggregationType;\n  pipelineVariables?: PipelineVariable[];\n}\n\nexport type MovingAverageModel = 'simple' | 'linear' | 'ewma' | 'holt' | 'holt_winters';\n\nexport interface MovingAverageModelOption {\n  label: string;\n  value: MovingAverageModel;\n}\n\nexport interface BaseMovingAverageModelSettings {\n  model: MovingAverageModel;\n  window: string;\n  predict: string;\n}\n\nexport interface MovingAverageSimpleModelSettings extends BaseMovingAverageModelSettings {\n  model: 'simple';\n}\n\nexport interface MovingAverageLinearModelSettings extends BaseMovingAverageModelSettings {\n  model: 'linear';\n}\n\nexport interface MovingAverageEWMAModelSettings extends BaseMovingAverageModelSettings {\n  model: 'ewma';\n  settings?: {\n    alpha?: string;\n  };\n  minimize: boolean;\n}\n\nexport interface MovingAverageHoltModelSettings extends BaseMovingAverageModelSettings {\n  model: 'holt';\n  settings: {\n    alpha?: string;\n    beta?: string;\n  };\n  minimize: boolean;\n}\n\nexport interface MovingAverageHoltWintersModelSettings extends BaseMovingAverageModelSettings {\n  model: 'holt_winters';\n  settings: {\n    alpha?: string;\n    beta?: string;\n    gamma?: string;\n    period?: string;\n    pad?: boolean;\n  };\n  minimize: boolean;\n}\n\nexport type MovingAverageModelSettings<T extends MovingAverageModel = MovingAverageModel> = Partial<\n  Extract<\n    | MovingAverageSimpleModelSettings\n    | MovingAverageLinearModelSettings\n    | MovingAverageEWMAModelSettings\n    | MovingAverageHoltModelSettings\n    | MovingAverageHoltWintersModelSettings,\n    { model: T }\n  >\n>;\n\nexport interface MovingAverage<T extends MovingAverageModel = MovingAverageModel>\n  extends BasePipelineMetricAggregation {\n  type: 'moving_avg';\n  settings?: MovingAverageModelSettings<T>;\n}\n\nexport const isEWMAMovingAverage = (metric: MovingAverage | MovingAverage<'ewma'>): metric is MovingAverage<'ewma'> =>\n  metric.settings?.model === 'ewma';\n\nexport const isHoltMovingAverage = (metric: MovingAverage | MovingAverage<'holt'>): metric is MovingAverage<'holt'> =>\n  metric.settings?.model === 'holt';\n\nexport const isHoltWintersMovingAverage = (\n  metric: MovingAverage | MovingAverage<'holt_winters'>\n): metric is MovingAverage<'holt_winters'> => metric.settings?.model === 'holt_winters';\n\nexport const isMovingAverageWithModelSettings = (\n  metric: MovingAverage\n): metric is MovingAverage<'ewma'> | MovingAverage<'holt'> | MovingAverage<'holt_winters'> =>\n  ['holt', 'ewma', 'holt_winters'].includes(metric.settings?.model || '');\n\nexport interface MovingFunction extends BasePipelineMetricAggregation {\n  type: 'moving_fn';\n  settings?: {\n    window?: string;\n    script?: InlineScript;\n    shift?: string;\n  };\n}\n\nexport interface Derivative extends BasePipelineMetricAggregation {\n  type: 'derivative';\n  settings?: {\n    unit?: string;\n  };\n}\n\nexport interface SerialDiff extends BasePipelineMetricAggregation {\n  type: 'serial_diff';\n  settings?: {\n    lag?: string;\n  };\n}\n\nexport interface CumulativeSum extends BasePipelineMetricAggregation {\n  type: 'cumulative_sum';\n  settings?: {\n    format?: string;\n  };\n}\n\nexport interface BucketScript extends PipelineMetricAggregationWithMultipleBucketPaths {\n  type: 'bucket_script';\n  settings?: {\n    script?: InlineScript;\n  };\n}\n\nexport interface TopMetrics extends BaseMetricAggregation {\n  type: 'top_metrics';\n  settings?: {\n    order?: string;\n    orderBy?: string;\n    metrics?: string[];\n  };\n}\n\ntype PipelineMetricAggregation = MovingAverage | Derivative | CumulativeSum | BucketScript;\n\nexport type MetricAggregationWithSettings =\n  | BucketScript\n  | CumulativeSum\n  | Derivative\n  | SerialDiff\n  | RawData\n  | RawDocument\n  | UniqueCount\n  | Percentiles\n  | ExtendedStats\n  | Min\n  | Max\n  | Sum\n  | Average\n  | MovingAverage\n  | MovingFunction\n  | Logs\n  | Rate\n  | TopMetrics;\n\nexport type MetricAggregationWithMeta = ExtendedStats;\n\nexport type MetricAggregation = Count | PipelineMetricAggregation | MetricAggregationWithSettings;\n\n// Guards\n// Given the structure of the aggregations (ie. `settings` field being always optional) we cannot\n// determine types based solely on objects' properties, therefore we use `metricAggregationConfig` as the\n// source of truth.\n\n/**\n * Checks if `metric` requires a field (either referring to a document or another aggregation)\n * @param metric\n */\nexport const isMetricAggregationWithField = (\n  metric: BaseMetricAggregation | MetricAggregationWithField\n): metric is MetricAggregationWithField => metricAggregationConfig[metric.type].requiresField;\n\nexport const isPipelineAggregation = (\n  metric: BaseMetricAggregation | PipelineMetricAggregation\n): metric is PipelineMetricAggregation => metricAggregationConfig[metric.type].isPipelineAgg;\n\nexport const isPipelineAggregationWithMultipleBucketPaths = (\n  metric: BaseMetricAggregation | PipelineMetricAggregationWithMultipleBucketPaths\n): metric is PipelineMetricAggregationWithMultipleBucketPaths =>\n  metricAggregationConfig[metric.type].supportsMultipleBucketPaths;\n\nexport const isMetricAggregationWithMissingSupport = (\n  metric: BaseMetricAggregation | MetricAggregationWithMissingSupport\n): metric is MetricAggregationWithMissingSupport => metricAggregationConfig[metric.type].supportsMissing;\n\nexport const isMetricAggregationWithSettings = (\n  metric: BaseMetricAggregation | MetricAggregationWithSettings\n): metric is MetricAggregationWithSettings => metricAggregationConfig[metric.type].hasSettings;\n\nexport const isMetricAggregationWithMeta = (\n  metric: BaseMetricAggregation | MetricAggregationWithMeta\n): metric is MetricAggregationWithMeta => metricAggregationConfig[metric.type].hasMeta;\n\nexport const isMetricAggregationWithInlineScript = (\n  metric: BaseMetricAggregation | MetricAggregationWithInlineScript\n): metric is MetricAggregationWithInlineScript => metricAggregationConfig[metric.type].supportsInlineScript;\n\nexport const METRIC_AGGREGATION_TYPES: MetricAggregationType[] = [\n  'count',\n  'avg',\n  'sum',\n  'min',\n  'max',\n  'extended_stats',\n  'percentiles',\n  'cardinality',\n  'raw_document',\n  'raw_data',\n  'logs',\n  'moving_avg',\n  'moving_fn',\n  'derivative',\n  'serial_diff',\n  'cumulative_sum',\n  'bucket_script',\n  'rate',\n  'top_metrics',\n];\n\nexport const isMetricAggregationType = (s: MetricAggregationType | string): s is MetricAggregationType =>\n  METRIC_AGGREGATION_TYPES.includes(s as MetricAggregationType);\n"],"mappings":"AAAA,SAASA,uBAAT,QAAwC,SAAxC;AAkPA,OAAO,MAAMC,mBAAmB,GAAIC,MAAD;EAAA;;EAAA,OACjC,qBAAAA,MAAM,CAACC,QAAP,sEAAiBC,KAAjB,MAA2B,MADM;AAAA,CAA5B;AAGP,OAAO,MAAMC,mBAAmB,GAAIH,MAAD;EAAA;;EAAA,OACjC,sBAAAA,MAAM,CAACC,QAAP,wEAAiBC,KAAjB,MAA2B,MADM;AAAA,CAA5B;AAGP,OAAO,MAAME,0BAA0B,GACrCJ,MADwC;EAAA;;EAAA,OAEI,sBAAAA,MAAM,CAACC,QAAP,wEAAiBC,KAAjB,MAA2B,cAF/B;AAAA,CAAnC;AAIP,OAAO,MAAMG,gCAAgC,GAC3CL,MAD8C;EAAA;;EAAA,OAG9C,CAAC,MAAD,EAAS,MAAT,EAAiB,cAAjB,EAAiCM,QAAjC,CAA0C,sBAAAN,MAAM,CAACC,QAAP,wEAAiBC,KAAjB,KAA0B,EAApE,CAH8C;AAAA,CAAzC;AA6EP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMK,4BAA4B,GACvCP,MAD0C,IAEDF,uBAAuB,CAACE,MAAM,CAACQ,IAAR,CAAvB,CAAqCC,aAFzE;AAIP,OAAO,MAAMC,qBAAqB,GAChCV,MADmC,IAEKF,uBAAuB,CAACE,MAAM,CAACQ,IAAR,CAAvB,CAAqCG,aAFxE;AAIP,OAAO,MAAMC,4CAA4C,GACvDZ,MAD0D,IAG1DF,uBAAuB,CAACE,MAAM,CAACQ,IAAR,CAAvB,CAAqCK,2BAHhC;AAKP,OAAO,MAAMC,qCAAqC,GAChDd,MADmD,IAEDF,uBAAuB,CAACE,MAAM,CAACQ,IAAR,CAAvB,CAAqCO,eAFlF;AAIP,OAAO,MAAMC,+BAA+B,GAC1ChB,MAD6C,IAEDF,uBAAuB,CAACE,MAAM,CAACQ,IAAR,CAAvB,CAAqCS,WAF5E;AAIP,OAAO,MAAMC,2BAA2B,GACtClB,MADyC,IAEDF,uBAAuB,CAACE,MAAM,CAACQ,IAAR,CAAvB,CAAqCW,OAFxE;AAIP,OAAO,MAAMC,mCAAmC,GAC9CpB,MADiD,IAEDF,uBAAuB,CAACE,MAAM,CAACQ,IAAR,CAAvB,CAAqCa,oBAFhF;AAIP,OAAO,MAAMC,wBAAiD,GAAG,CAC/D,OAD+D,EAE/D,KAF+D,EAG/D,KAH+D,EAI/D,KAJ+D,EAK/D,KAL+D,EAM/D,gBAN+D,EAO/D,aAP+D,EAQ/D,aAR+D,EAS/D,cAT+D,EAU/D,UAV+D,EAW/D,MAX+D,EAY/D,YAZ+D,EAa/D,WAb+D,EAc/D,YAd+D,EAe/D,aAf+D,EAgB/D,gBAhB+D,EAiB/D,eAjB+D,EAkB/D,MAlB+D,EAmB/D,aAnB+D,CAA1D;AAsBP,OAAO,MAAMC,uBAAuB,GAAIC,CAAD,IACrCF,wBAAwB,CAAChB,QAAzB,CAAkCkB,CAAlC,CADK"},"metadata":{},"sourceType":"module"}