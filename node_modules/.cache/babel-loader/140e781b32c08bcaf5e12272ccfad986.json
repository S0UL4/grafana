{"ast":null,"code":"import { countBy, chain, escapeRegExp } from 'lodash';\nimport { FieldType } from '../types/index';\nimport { LogLevel, LogsSortOrder } from '../types/logs';\nimport { ArrayVector } from '../vector/ArrayVector'; // This matches:\n// first a label from start of the string or first white space, then any word chars until \"=\"\n// second either an empty quotes, or anything that starts with quote and ends with unescaped quote,\n// or any non whitespace chars that do not start with quote\n\nconst LOGFMT_REGEXP = /(?:^|\\s)([\\w\\(\\)\\[\\]\\{\\}]+)=(\"\"|(?:\".*?[^\\\\]\"|[^\"\\s]\\S*))/;\n/**\n * Returns the log level of a log line.\n * Parse the line for level words. If no level is found, it returns `LogLevel.unknown`.\n *\n * Example: `getLogLevel('WARN 1999-12-31 this is great') // LogLevel.warn`\n */\n\nexport function getLogLevel(line) {\n  if (!line) {\n    return LogLevel.unknown;\n  }\n\n  let level = LogLevel.unknown;\n  let currentIndex = undefined;\n\n  for (const key of Object.keys(LogLevel)) {\n    const regexp = new RegExp(`\\\\b${key}\\\\b`, 'i');\n    const result = regexp.exec(line);\n\n    if (result) {\n      if (currentIndex === undefined || result.index < currentIndex) {\n        level = LogLevel[key];\n        currentIndex = result.index;\n      }\n    }\n  }\n\n  return level;\n}\nexport function getLogLevelFromKey(key) {\n  const level = LogLevel[key.toString().toLowerCase()];\n\n  if (level) {\n    return level;\n  }\n\n  return LogLevel.unknown;\n}\nexport function addLogLevelToSeries(series, lineIndex) {\n  const levels = new ArrayVector();\n  const lines = series.fields[lineIndex];\n\n  for (let i = 0; i < lines.values.length; i++) {\n    const line = lines.values.get(lineIndex);\n    levels.buffer.push(getLogLevel(line));\n  }\n\n  return Object.assign({}, series, {\n    // Keeps Tags, RefID etc\n    fields: [...series.fields, {\n      name: 'LogLevel',\n      type: FieldType.string,\n      values: levels,\n      config: {}\n    }]\n  });\n}\nexport const LogsParsers = {\n  JSON: {\n    buildMatcher: label => new RegExp(`(?:{|,)\\\\s*\"${label}\"\\\\s*:\\\\s*\"?([\\\\d\\\\.]+|[^\"]*)\"?`),\n    getFields: line => {\n      try {\n        const parsed = JSON.parse(line);\n        return Object.keys(parsed).map(key => {\n          return `\"${key}\":${JSON.stringify(parsed[key])}`;\n        });\n      } catch {}\n\n      return [];\n    },\n    getLabelFromField: field => (field.match(/^\"([^\"]+)\"\\s*:/) || [])[1],\n    getValueFromField: field => (field.match(/:\\s*(.*)$/) || [])[1],\n    test: line => {\n      let parsed;\n\n      try {\n        parsed = JSON.parse(line);\n      } catch (error) {} // The JSON parser should only be used for log lines that are valid serialized JSON objects.\n      // If it would be used for a string, detected fields would include each letter as a separate field.\n\n\n      return typeof parsed === 'object';\n    }\n  },\n  logfmt: {\n    buildMatcher: label => new RegExp(`(?:^|\\\\s)${escapeRegExp(label)}=(\"[^\"]*\"|\\\\S+)`),\n    getFields: line => {\n      const fields = [];\n      line.replace(new RegExp(LOGFMT_REGEXP, 'g'), substring => {\n        fields.push(substring.trim());\n        return '';\n      });\n      return fields;\n    },\n    getLabelFromField: field => (field.match(LOGFMT_REGEXP) || [])[1],\n    getValueFromField: field => (field.match(LOGFMT_REGEXP) || [])[2],\n    test: line => LOGFMT_REGEXP.test(line)\n  }\n};\nexport function calculateFieldStats(rows, extractor) {\n  // Consider only rows that satisfy the matcher\n  const rowsWithField = rows.filter(row => extractor.test(row.entry));\n  const rowCount = rowsWithField.length; // Get field value counts for eligible rows\n\n  const countsByValue = countBy(rowsWithField, r => {\n    const row = r;\n    const match = row.entry.match(extractor);\n    return match ? match[1] : null;\n  });\n  return getSortedCounts(countsByValue, rowCount);\n}\nexport function calculateLogsLabelStats(rows, label) {\n  // Consider only rows that have the given label\n  const rowsWithLabel = rows.filter(row => row.labels[label] !== undefined);\n  const rowCount = rowsWithLabel.length; // Get label value counts for eligible rows\n\n  const countsByValue = countBy(rowsWithLabel, row => row.labels[label]);\n  return getSortedCounts(countsByValue, rowCount);\n}\nexport function calculateStats(values) {\n  const nonEmptyValues = values.filter(value => value !== undefined && value !== null);\n  const countsByValue = countBy(nonEmptyValues);\n  return getSortedCounts(countsByValue, nonEmptyValues.length);\n}\n\nconst getSortedCounts = (countsByValue, rowCount) => {\n  return chain(countsByValue).map((count, value) => ({\n    count,\n    value,\n    proportion: count / rowCount\n  })).sortBy('count').reverse().value();\n};\n\nexport function getParser(line) {\n  let parser;\n\n  try {\n    if (LogsParsers.JSON.test(line)) {\n      parser = LogsParsers.JSON;\n    }\n  } catch (error) {}\n\n  if (!parser && LogsParsers.logfmt.test(line)) {\n    parser = LogsParsers.logfmt;\n  }\n\n  return parser;\n}\nexport const sortInAscendingOrder = (a, b) => {\n  // compare milliseconds\n  if (a.timeEpochMs < b.timeEpochMs) {\n    return -1;\n  }\n\n  if (a.timeEpochMs > b.timeEpochMs) {\n    return 1;\n  } // if milliseconds are equal, compare nanoseconds\n\n\n  if (a.timeEpochNs < b.timeEpochNs) {\n    return -1;\n  }\n\n  if (a.timeEpochNs > b.timeEpochNs) {\n    return 1;\n  }\n\n  return 0;\n};\nexport const sortInDescendingOrder = (a, b) => {\n  // compare milliseconds\n  if (a.timeEpochMs > b.timeEpochMs) {\n    return -1;\n  }\n\n  if (a.timeEpochMs < b.timeEpochMs) {\n    return 1;\n  } // if milliseconds are equal, compare nanoseconds\n\n\n  if (a.timeEpochNs > b.timeEpochNs) {\n    return -1;\n  }\n\n  if (a.timeEpochNs < b.timeEpochNs) {\n    return 1;\n  }\n\n  return 0;\n};\nexport const sortLogsResult = (logsResult, sortOrder) => {\n  const rows = logsResult ? sortLogRows(logsResult.rows, sortOrder) : [];\n  return logsResult ? Object.assign({}, logsResult, {\n    rows\n  }) : {\n    hasUniqueLabels: false,\n    rows\n  };\n};\nexport const sortLogRows = (logRows, sortOrder) => sortOrder === LogsSortOrder.Ascending ? logRows.sort(sortInAscendingOrder) : logRows.sort(sortInDescendingOrder); // Currently supports only error condition in Loki logs\n\nexport const checkLogsError = logRow => {\n  if (logRow.labels.__error__) {\n    return {\n      hasError: true,\n      errorMessage: logRow.labels.__error__\n    };\n  }\n\n  return {\n    hasError: false\n  };\n};\nexport const escapeUnescapedString = string => string.replace(/\\\\r\\\\n|\\\\n|\\\\t|\\\\r/g, match => match.slice(1) === 't' ? '\\t' : '\\n');","map":{"version":3,"names":["countBy","chain","escapeRegExp","FieldType","LogLevel","LogsSortOrder","ArrayVector","LOGFMT_REGEXP","getLogLevel","line","unknown","level","currentIndex","undefined","key","Object","keys","regexp","RegExp","result","exec","index","getLogLevelFromKey","toString","toLowerCase","addLogLevelToSeries","series","lineIndex","levels","lines","fields","i","values","length","get","buffer","push","name","type","string","config","LogsParsers","JSON","buildMatcher","label","getFields","parsed","parse","map","stringify","getLabelFromField","field","match","getValueFromField","test","error","logfmt","replace","substring","trim","calculateFieldStats","rows","extractor","rowsWithField","filter","row","entry","rowCount","countsByValue","r","getSortedCounts","calculateLogsLabelStats","rowsWithLabel","labels","calculateStats","nonEmptyValues","value","count","proportion","sortBy","reverse","getParser","parser","sortInAscendingOrder","a","b","timeEpochMs","timeEpochNs","sortInDescendingOrder","sortLogsResult","logsResult","sortOrder","sortLogRows","hasUniqueLabels","logRows","Ascending","sort","checkLogsError","logRow","__error__","hasError","errorMessage","escapeUnescapedString","slice"],"sources":["/home/soula/grafana/packages/grafana-data/src/utils/logs.ts"],"sourcesContent":["import { countBy, chain, escapeRegExp } from 'lodash';\n\nimport { DataFrame, FieldType } from '../types/index';\nimport { LogLevel, LogRowModel, LogLabelStatsModel, LogsParser, LogsModel, LogsSortOrder } from '../types/logs';\nimport { ArrayVector } from '../vector/ArrayVector';\n\n// This matches:\n// first a label from start of the string or first white space, then any word chars until \"=\"\n// second either an empty quotes, or anything that starts with quote and ends with unescaped quote,\n// or any non whitespace chars that do not start with quote\nconst LOGFMT_REGEXP = /(?:^|\\s)([\\w\\(\\)\\[\\]\\{\\}]+)=(\"\"|(?:\".*?[^\\\\]\"|[^\"\\s]\\S*))/;\n\n/**\n * Returns the log level of a log line.\n * Parse the line for level words. If no level is found, it returns `LogLevel.unknown`.\n *\n * Example: `getLogLevel('WARN 1999-12-31 this is great') // LogLevel.warn`\n */\nexport function getLogLevel(line: string): LogLevel {\n  if (!line) {\n    return LogLevel.unknown;\n  }\n  let level = LogLevel.unknown;\n  let currentIndex: number | undefined = undefined;\n\n  for (const key of Object.keys(LogLevel)) {\n    const regexp = new RegExp(`\\\\b${key}\\\\b`, 'i');\n    const result = regexp.exec(line);\n\n    if (result) {\n      if (currentIndex === undefined || result.index < currentIndex) {\n        level = (LogLevel as any)[key];\n        currentIndex = result.index;\n      }\n    }\n  }\n  return level;\n}\n\nexport function getLogLevelFromKey(key: string | number): LogLevel {\n  const level = (LogLevel as any)[key.toString().toLowerCase()];\n  if (level) {\n    return level;\n  }\n\n  return LogLevel.unknown;\n}\n\nexport function addLogLevelToSeries(series: DataFrame, lineIndex: number): DataFrame {\n  const levels = new ArrayVector<LogLevel>();\n  const lines = series.fields[lineIndex];\n  for (let i = 0; i < lines.values.length; i++) {\n    const line = lines.values.get(lineIndex);\n    levels.buffer.push(getLogLevel(line));\n  }\n\n  return {\n    ...series, // Keeps Tags, RefID etc\n    fields: [\n      ...series.fields,\n      {\n        name: 'LogLevel',\n        type: FieldType.string,\n        values: levels,\n        config: {},\n      },\n    ],\n  };\n}\n\nexport const LogsParsers: { [name: string]: LogsParser } = {\n  JSON: {\n    buildMatcher: (label) => new RegExp(`(?:{|,)\\\\s*\"${label}\"\\\\s*:\\\\s*\"?([\\\\d\\\\.]+|[^\"]*)\"?`),\n    getFields: (line) => {\n      try {\n        const parsed = JSON.parse(line);\n        return Object.keys(parsed).map((key) => {\n          return `\"${key}\":${JSON.stringify(parsed[key])}`;\n        });\n      } catch {}\n      return [];\n    },\n    getLabelFromField: (field) => (field.match(/^\"([^\"]+)\"\\s*:/) || [])[1],\n    getValueFromField: (field) => (field.match(/:\\s*(.*)$/) || [])[1],\n    test: (line) => {\n      let parsed;\n      try {\n        parsed = JSON.parse(line);\n      } catch (error) {}\n      // The JSON parser should only be used for log lines that are valid serialized JSON objects.\n      // If it would be used for a string, detected fields would include each letter as a separate field.\n      return typeof parsed === 'object';\n    },\n  },\n\n  logfmt: {\n    buildMatcher: (label) => new RegExp(`(?:^|\\\\s)${escapeRegExp(label)}=(\"[^\"]*\"|\\\\S+)`),\n    getFields: (line) => {\n      const fields: string[] = [];\n      line.replace(new RegExp(LOGFMT_REGEXP, 'g'), (substring) => {\n        fields.push(substring.trim());\n        return '';\n      });\n      return fields;\n    },\n    getLabelFromField: (field) => (field.match(LOGFMT_REGEXP) || [])[1],\n    getValueFromField: (field) => (field.match(LOGFMT_REGEXP) || [])[2],\n    test: (line) => LOGFMT_REGEXP.test(line),\n  },\n};\n\nexport function calculateFieldStats(rows: LogRowModel[], extractor: RegExp): LogLabelStatsModel[] {\n  // Consider only rows that satisfy the matcher\n  const rowsWithField = rows.filter((row) => extractor.test(row.entry));\n  const rowCount = rowsWithField.length;\n\n  // Get field value counts for eligible rows\n  const countsByValue = countBy(rowsWithField, (r) => {\n    const row: LogRowModel = r;\n    const match = row.entry.match(extractor);\n\n    return match ? match[1] : null;\n  });\n  return getSortedCounts(countsByValue, rowCount);\n}\n\nexport function calculateLogsLabelStats(rows: LogRowModel[], label: string): LogLabelStatsModel[] {\n  // Consider only rows that have the given label\n  const rowsWithLabel = rows.filter((row) => row.labels[label] !== undefined);\n  const rowCount = rowsWithLabel.length;\n\n  // Get label value counts for eligible rows\n  const countsByValue = countBy(rowsWithLabel, (row) => (row as LogRowModel).labels[label]);\n  return getSortedCounts(countsByValue, rowCount);\n}\n\nexport function calculateStats(values: any[]): LogLabelStatsModel[] {\n  const nonEmptyValues = values.filter((value) => value !== undefined && value !== null);\n  const countsByValue = countBy(nonEmptyValues);\n  return getSortedCounts(countsByValue, nonEmptyValues.length);\n}\n\nconst getSortedCounts = (countsByValue: { [value: string]: number }, rowCount: number) => {\n  return chain(countsByValue)\n    .map((count, value) => ({ count, value, proportion: count / rowCount }))\n    .sortBy('count')\n    .reverse()\n    .value();\n};\n\nexport function getParser(line: string): LogsParser | undefined {\n  let parser;\n  try {\n    if (LogsParsers.JSON.test(line)) {\n      parser = LogsParsers.JSON;\n    }\n  } catch (error) {}\n\n  if (!parser && LogsParsers.logfmt.test(line)) {\n    parser = LogsParsers.logfmt;\n  }\n\n  return parser;\n}\n\nexport const sortInAscendingOrder = (a: LogRowModel, b: LogRowModel) => {\n  // compare milliseconds\n  if (a.timeEpochMs < b.timeEpochMs) {\n    return -1;\n  }\n\n  if (a.timeEpochMs > b.timeEpochMs) {\n    return 1;\n  }\n\n  // if milliseconds are equal, compare nanoseconds\n  if (a.timeEpochNs < b.timeEpochNs) {\n    return -1;\n  }\n\n  if (a.timeEpochNs > b.timeEpochNs) {\n    return 1;\n  }\n\n  return 0;\n};\n\nexport const sortInDescendingOrder = (a: LogRowModel, b: LogRowModel) => {\n  // compare milliseconds\n  if (a.timeEpochMs > b.timeEpochMs) {\n    return -1;\n  }\n\n  if (a.timeEpochMs < b.timeEpochMs) {\n    return 1;\n  }\n\n  // if milliseconds are equal, compare nanoseconds\n  if (a.timeEpochNs > b.timeEpochNs) {\n    return -1;\n  }\n\n  if (a.timeEpochNs < b.timeEpochNs) {\n    return 1;\n  }\n\n  return 0;\n};\n\nexport const sortLogsResult = (logsResult: LogsModel | null, sortOrder: LogsSortOrder): LogsModel => {\n  const rows = logsResult ? sortLogRows(logsResult.rows, sortOrder) : [];\n  return logsResult ? { ...logsResult, rows } : { hasUniqueLabels: false, rows };\n};\n\nexport const sortLogRows = (logRows: LogRowModel[], sortOrder: LogsSortOrder) =>\n  sortOrder === LogsSortOrder.Ascending ? logRows.sort(sortInAscendingOrder) : logRows.sort(sortInDescendingOrder);\n\n// Currently supports only error condition in Loki logs\nexport const checkLogsError = (logRow: LogRowModel): { hasError: boolean; errorMessage?: string } => {\n  if (logRow.labels.__error__) {\n    return {\n      hasError: true,\n      errorMessage: logRow.labels.__error__,\n    };\n  }\n  return {\n    hasError: false,\n  };\n};\n\nexport const escapeUnescapedString = (string: string) =>\n  string.replace(/\\\\r\\\\n|\\\\n|\\\\t|\\\\r/g, (match: string) => (match.slice(1) === 't' ? '\\t' : '\\n'));\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}