{"ast":null,"code":"/* eslint-disable id-blacklist, no-restricted-imports, @typescript-eslint/ban-types */\nimport { lowerCase } from 'lodash';\nimport moment from 'moment-timezone';\nimport { getTimeZone } from './common';\nimport { parse, isValid } from './datemath';\nimport { systemDateFormats } from './formats';\nimport { isDateTime } from './moment_wrapper';\n/**\n * The type that describes options that can be passed when parsing a date and time value.\n * @public\n */\n\n/**\n * Helper function to parse a number, text or Date to a DateTime value. If a timeZone is supplied the incoming value\n * is parsed with that timeZone as a base. The only exception to this is if the passed value is in a UTC-based\n * format. Then it will use UTC as the base. If no format is specified the current system format will be assumed.\n *\n * It can also parse the Grafana quick date and time format, e.g. now-6h will be parsed as Date.now() - 6 hours and\n * returned as a valid DateTime value.\n *\n * If no options are supplied, then default values are used. For more details please see {@link DateTimeOptions}.\n *\n * @param value - should be a parsable date and time value\n * @param options\n *\n * @public\n */\nexport const dateTimeParse = (value, options) => {\n  if (isDateTime(value)) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return parseString(value, options);\n  }\n\n  return parseOthers(value, options);\n};\n\nconst parseString = (value, options) => {\n  var _options$format;\n\n  if (value.indexOf('now') !== -1) {\n    if (!isValid(value)) {\n      return moment();\n    }\n\n    const parsed = parse(value, options === null || options === void 0 ? void 0 : options.roundUp, options === null || options === void 0 ? void 0 : options.timeZone, options === null || options === void 0 ? void 0 : options.fiscalYearStartMonth);\n    return parsed || moment();\n  }\n\n  const timeZone = getTimeZone(options);\n  const zone = moment.tz.zone(timeZone);\n  const format = (_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : systemDateFormats.fullDate;\n\n  if (zone && zone.name) {\n    return moment.tz(value, format, zone.name);\n  }\n\n  switch (lowerCase(timeZone)) {\n    case 'utc':\n      return moment.utc(value, format);\n\n    default:\n      return moment(value, format);\n  }\n};\n\nconst parseOthers = (value, options) => {\n  const date = value;\n  const timeZone = getTimeZone(options);\n  const zone = moment.tz.zone(timeZone);\n\n  if (zone && zone.name) {\n    return moment.tz(date, zone.name);\n  }\n\n  switch (lowerCase(timeZone)) {\n    case 'utc':\n      return moment.utc(date);\n\n    default:\n      return moment(date);\n  }\n};","map":{"version":3,"names":["lowerCase","moment","getTimeZone","parse","isValid","systemDateFormats","isDateTime","dateTimeParse","value","options","parseString","parseOthers","indexOf","parsed","roundUp","timeZone","fiscalYearStartMonth","zone","tz","format","fullDate","name","utc","date"],"sources":["/home/soula/grafana/packages/grafana-data/src/datetime/parser.ts"],"sourcesContent":["/* eslint-disable id-blacklist, no-restricted-imports, @typescript-eslint/ban-types */\nimport { lowerCase } from 'lodash';\nimport moment, { MomentInput } from 'moment-timezone';\n\nimport { DateTimeOptions, getTimeZone } from './common';\nimport { parse, isValid } from './datemath';\nimport { systemDateFormats } from './formats';\nimport { DateTimeInput, DateTime, isDateTime } from './moment_wrapper';\n\n/**\n * The type that describes options that can be passed when parsing a date and time value.\n * @public\n */\nexport interface DateTimeOptionsWhenParsing extends DateTimeOptions {\n  /**\n   * If the input is a Grafana quick date, e.g. now-6h, then you can specify this to control\n   * whether the last part of the date and time value is included or excluded.\n   *\n   * Example: now-6h and the current time is 12:20:00 if roundUp is set to true\n   * the returned DateTime value will be 06:00:00.\n   */\n  roundUp?: boolean;\n  fiscalYearStartMonth?: number;\n}\n\ntype DateTimeParser<T extends DateTimeOptions = DateTimeOptions> = (value: DateTimeInput, options?: T) => DateTime;\n\n/**\n * Helper function to parse a number, text or Date to a DateTime value. If a timeZone is supplied the incoming value\n * is parsed with that timeZone as a base. The only exception to this is if the passed value is in a UTC-based\n * format. Then it will use UTC as the base. If no format is specified the current system format will be assumed.\n *\n * It can also parse the Grafana quick date and time format, e.g. now-6h will be parsed as Date.now() - 6 hours and\n * returned as a valid DateTime value.\n *\n * If no options are supplied, then default values are used. For more details please see {@link DateTimeOptions}.\n *\n * @param value - should be a parsable date and time value\n * @param options\n *\n * @public\n */\nexport const dateTimeParse: DateTimeParser<DateTimeOptionsWhenParsing> = (value, options?): DateTime => {\n  if (isDateTime(value)) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return parseString(value, options);\n  }\n\n  return parseOthers(value, options);\n};\n\nconst parseString = (value: string, options?: DateTimeOptionsWhenParsing): DateTime => {\n  if (value.indexOf('now') !== -1) {\n    if (!isValid(value)) {\n      return moment() as DateTime;\n    }\n\n    const parsed = parse(value, options?.roundUp, options?.timeZone, options?.fiscalYearStartMonth);\n    return parsed || (moment() as DateTime);\n  }\n\n  const timeZone = getTimeZone(options);\n  const zone = moment.tz.zone(timeZone);\n  const format = options?.format ?? systemDateFormats.fullDate;\n\n  if (zone && zone.name) {\n    return moment.tz(value, format, zone.name) as DateTime;\n  }\n\n  switch (lowerCase(timeZone)) {\n    case 'utc':\n      return moment.utc(value, format) as DateTime;\n    default:\n      return moment(value, format) as DateTime;\n  }\n};\n\nconst parseOthers = (value: DateTimeInput, options?: DateTimeOptionsWhenParsing): DateTime => {\n  const date = value as MomentInput;\n  const timeZone = getTimeZone(options);\n  const zone = moment.tz.zone(timeZone);\n\n  if (zone && zone.name) {\n    return moment.tz(date, zone.name) as DateTime;\n  }\n\n  switch (lowerCase(timeZone)) {\n    case 'utc':\n      return moment.utc(date) as DateTime;\n    default:\n      return moment(date) as DateTime;\n  }\n};\n"],"mappings":"AAAA;AACA,SAASA,SAAT,QAA0B,QAA1B;AACA,OAAOC,MAAP,MAAoC,iBAApC;AAEA,SAA0BC,WAA1B,QAA6C,UAA7C;AACA,SAASC,KAAT,EAAgBC,OAAhB,QAA+B,YAA/B;AACA,SAASC,iBAAT,QAAkC,WAAlC;AACA,SAAkCC,UAAlC,QAAoD,kBAApD;AAEA;AACA;AACA;AACA;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAyD,GAAG,CAACC,KAAD,EAAQC,OAAR,KAA+B;EACtG,IAAIH,UAAU,CAACE,KAAD,CAAd,EAAuB;IACrB,OAAOA,KAAP;EACD;;EAED,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;IAC7B,OAAOE,WAAW,CAACF,KAAD,EAAQC,OAAR,CAAlB;EACD;;EAED,OAAOE,WAAW,CAACH,KAAD,EAAQC,OAAR,CAAlB;AACD,CAVM;;AAYP,MAAMC,WAAW,GAAG,CAACF,KAAD,EAAgBC,OAAhB,KAAmE;EAAA;;EACrF,IAAID,KAAK,CAACI,OAAN,CAAc,KAAd,MAAyB,CAAC,CAA9B,EAAiC;IAC/B,IAAI,CAACR,OAAO,CAACI,KAAD,CAAZ,EAAqB;MACnB,OAAOP,MAAM,EAAb;IACD;;IAED,MAAMY,MAAM,GAAGV,KAAK,CAACK,KAAD,EAAQC,OAAR,aAAQA,OAAR,uBAAQA,OAAO,CAAEK,OAAjB,EAA0BL,OAA1B,aAA0BA,OAA1B,uBAA0BA,OAAO,CAAEM,QAAnC,EAA6CN,OAA7C,aAA6CA,OAA7C,uBAA6CA,OAAO,CAAEO,oBAAtD,CAApB;IACA,OAAOH,MAAM,IAAKZ,MAAM,EAAxB;EACD;;EAED,MAAMc,QAAQ,GAAGb,WAAW,CAACO,OAAD,CAA5B;EACA,MAAMQ,IAAI,GAAGhB,MAAM,CAACiB,EAAP,CAAUD,IAAV,CAAeF,QAAf,CAAb;EACA,MAAMI,MAAM,sBAAGV,OAAH,aAAGA,OAAH,uBAAGA,OAAO,CAAEU,MAAZ,6DAAsBd,iBAAiB,CAACe,QAApD;;EAEA,IAAIH,IAAI,IAAIA,IAAI,CAACI,IAAjB,EAAuB;IACrB,OAAOpB,MAAM,CAACiB,EAAP,CAAUV,KAAV,EAAiBW,MAAjB,EAAyBF,IAAI,CAACI,IAA9B,CAAP;EACD;;EAED,QAAQrB,SAAS,CAACe,QAAD,CAAjB;IACE,KAAK,KAAL;MACE,OAAOd,MAAM,CAACqB,GAAP,CAAWd,KAAX,EAAkBW,MAAlB,CAAP;;IACF;MACE,OAAOlB,MAAM,CAACO,KAAD,EAAQW,MAAR,CAAb;EAJJ;AAMD,CAxBD;;AA0BA,MAAMR,WAAW,GAAG,CAACH,KAAD,EAAuBC,OAAvB,KAA0E;EAC5F,MAAMc,IAAI,GAAGf,KAAb;EACA,MAAMO,QAAQ,GAAGb,WAAW,CAACO,OAAD,CAA5B;EACA,MAAMQ,IAAI,GAAGhB,MAAM,CAACiB,EAAP,CAAUD,IAAV,CAAeF,QAAf,CAAb;;EAEA,IAAIE,IAAI,IAAIA,IAAI,CAACI,IAAjB,EAAuB;IACrB,OAAOpB,MAAM,CAACiB,EAAP,CAAUK,IAAV,EAAgBN,IAAI,CAACI,IAArB,CAAP;EACD;;EAED,QAAQrB,SAAS,CAACe,QAAD,CAAjB;IACE,KAAK,KAAL;MACE,OAAOd,MAAM,CAACqB,GAAP,CAAWC,IAAX,CAAP;;IACF;MACE,OAAOtB,MAAM,CAACsB,IAAD,CAAb;EAJJ;AAMD,CAfD"},"metadata":{},"sourceType":"module"}