{"ast":null,"code":"import { toNumber } from 'lodash';\nimport { formattedValueToString } from '../valueFormats';\nimport { getDisplayProcessor } from './displayProcessor';\n/**\n * Creates a proxy object that allows accessing fields on dataFrame through various means and then returns it's\n * display value. This is mainly useful for example in data links interpolation where you can easily create a scoped\n * variable that will allow you to access dataFrame data with ${__data.fields.fieldName}.\n * Allows accessing fields by name, index, displayName or 'name' label\n *\n * @param options\n * @internal\n */\n\nexport function getFieldDisplayValuesProxy(options) {\n  return new Proxy({}, {\n    get: (obj, key) => {\n      var _field$display;\n\n      // 1. Match the name\n      let field = options.frame.fields.find(f => key === f.name);\n\n      if (!field) {\n        // 2. Match the array index\n        const k = toNumber(key);\n        field = options.frame.fields[k];\n      }\n\n      if (!field) {\n        // 3. Match the config displayName\n        field = options.frame.fields.find(f => key === f.config.displayName);\n      }\n\n      if (!field) {\n        // 4. Match the name label\n        field = options.frame.fields.find(f => {\n          if (f.labels) {\n            return key === f.labels.name;\n          }\n\n          return false;\n        });\n      }\n\n      if (!field) {\n        return undefined;\n      } // TODO: we could supply the field here for the getDisplayProcessor fallback but we would also need theme which\n      //  we do not have access to here\n\n\n      const displayProcessor = (_field$display = field.display) !== null && _field$display !== void 0 ? _field$display : getDisplayProcessor();\n      const raw = field.values.get(options.rowIndex);\n      const disp = displayProcessor(raw);\n\n      disp.toString = () => formattedValueToString(disp);\n\n      return disp;\n    }\n  });\n}","map":{"version":3,"names":["toNumber","formattedValueToString","getDisplayProcessor","getFieldDisplayValuesProxy","options","Proxy","get","obj","key","field","frame","fields","find","f","name","k","config","displayName","labels","undefined","displayProcessor","display","raw","values","rowIndex","disp","toString"],"sources":["/home/soula/grafana/packages/grafana-data/src/field/getFieldDisplayValuesProxy.ts"],"sourcesContent":["import { toNumber } from 'lodash';\n\nimport { DataFrame, DisplayValue, TimeZone } from '../types';\nimport { formattedValueToString } from '../valueFormats';\n\nimport { getDisplayProcessor } from './displayProcessor';\n\n/**\n * Creates a proxy object that allows accessing fields on dataFrame through various means and then returns it's\n * display value. This is mainly useful for example in data links interpolation where you can easily create a scoped\n * variable that will allow you to access dataFrame data with ${__data.fields.fieldName}.\n * Allows accessing fields by name, index, displayName or 'name' label\n *\n * @param options\n * @internal\n */\nexport function getFieldDisplayValuesProxy(options: {\n  frame: DataFrame;\n  rowIndex: number;\n  timeZone?: TimeZone;\n}): Record<string, DisplayValue> {\n  return new Proxy({} as Record<string, DisplayValue>, {\n    get: (obj: any, key: string): DisplayValue | undefined => {\n      // 1. Match the name\n      let field = options.frame.fields.find((f) => key === f.name);\n      if (!field) {\n        // 2. Match the array index\n        const k = toNumber(key);\n        field = options.frame.fields[k];\n      }\n      if (!field) {\n        // 3. Match the config displayName\n        field = options.frame.fields.find((f) => key === f.config.displayName);\n      }\n      if (!field) {\n        // 4. Match the name label\n        field = options.frame.fields.find((f) => {\n          if (f.labels) {\n            return key === f.labels.name;\n          }\n          return false;\n        });\n      }\n      if (!field) {\n        return undefined;\n      }\n      // TODO: we could supply the field here for the getDisplayProcessor fallback but we would also need theme which\n      //  we do not have access to here\n      const displayProcessor = field.display ?? getDisplayProcessor();\n      const raw = field.values.get(options.rowIndex);\n      const disp = displayProcessor(raw);\n      disp.toString = () => formattedValueToString(disp);\n      return disp;\n    },\n  });\n}\n"],"mappings":"AAAA,SAASA,QAAT,QAAyB,QAAzB;AAGA,SAASC,sBAAT,QAAuC,iBAAvC;AAEA,SAASC,mBAAT,QAAoC,oBAApC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,0BAAT,CAAoCC,OAApC,EAI0B;EAC/B,OAAO,IAAIC,KAAJ,CAAU,EAAV,EAA8C;IACnDC,GAAG,EAAE,CAACC,GAAD,EAAWC,GAAX,KAAqD;MAAA;;MACxD;MACA,IAAIC,KAAK,GAAGL,OAAO,CAACM,KAAR,CAAcC,MAAd,CAAqBC,IAArB,CAA2BC,CAAD,IAAOL,GAAG,KAAKK,CAAC,CAACC,IAA3C,CAAZ;;MACA,IAAI,CAACL,KAAL,EAAY;QACV;QACA,MAAMM,CAAC,GAAGf,QAAQ,CAACQ,GAAD,CAAlB;QACAC,KAAK,GAAGL,OAAO,CAACM,KAAR,CAAcC,MAAd,CAAqBI,CAArB,CAAR;MACD;;MACD,IAAI,CAACN,KAAL,EAAY;QACV;QACAA,KAAK,GAAGL,OAAO,CAACM,KAAR,CAAcC,MAAd,CAAqBC,IAArB,CAA2BC,CAAD,IAAOL,GAAG,KAAKK,CAAC,CAACG,MAAF,CAASC,WAAlD,CAAR;MACD;;MACD,IAAI,CAACR,KAAL,EAAY;QACV;QACAA,KAAK,GAAGL,OAAO,CAACM,KAAR,CAAcC,MAAd,CAAqBC,IAArB,CAA2BC,CAAD,IAAO;UACvC,IAAIA,CAAC,CAACK,MAAN,EAAc;YACZ,OAAOV,GAAG,KAAKK,CAAC,CAACK,MAAF,CAASJ,IAAxB;UACD;;UACD,OAAO,KAAP;QACD,CALO,CAAR;MAMD;;MACD,IAAI,CAACL,KAAL,EAAY;QACV,OAAOU,SAAP;MACD,CAvBuD,CAwBxD;MACA;;;MACA,MAAMC,gBAAgB,qBAAGX,KAAK,CAACY,OAAT,2DAAoBnB,mBAAmB,EAA7D;MACA,MAAMoB,GAAG,GAAGb,KAAK,CAACc,MAAN,CAAajB,GAAb,CAAiBF,OAAO,CAACoB,QAAzB,CAAZ;MACA,MAAMC,IAAI,GAAGL,gBAAgB,CAACE,GAAD,CAA7B;;MACAG,IAAI,CAACC,QAAL,GAAgB,MAAMzB,sBAAsB,CAACwB,IAAD,CAA5C;;MACA,OAAOA,IAAP;IACD;EAhCkD,CAA9C,CAAP;AAkCD"},"metadata":{},"sourceType":"module"}