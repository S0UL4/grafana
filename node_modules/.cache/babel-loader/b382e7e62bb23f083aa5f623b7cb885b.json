{"ast":null,"code":"const _excluded = [\"datasource\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { createAction } from '@reduxjs/toolkit';\nimport deepEqual from 'fast-deep-equal';\nimport { identity, of } from 'rxjs';\nimport { mergeMap, throttleTime } from 'rxjs/operators';\nimport { CoreApp, DataQueryErrorType, hasLogsVolumeSupport, hasQueryExportSupport, hasQueryImportSupport, LoadingState, PanelEvents, toLegacyResponseData } from '@grafana/data';\nimport { config, reportInteraction } from '@grafana/runtime';\nimport { buildQueryTransaction, ensureQueries, generateEmptyQuery, generateNewKeyAndAddRefIdIfMissing, getQueryKeys, hasNonEmptyQuery, stopQueryState, updateHistory } from 'app/core/utils/explore';\nimport { getShiftedTimeRange } from 'app/core/utils/timePicker';\nimport { getTimeZone } from 'app/features/profile/state/selectors';\nimport { ExploreId } from 'app/types/explore';\nimport { notifyApp } from '../../../core/actions';\nimport { createErrorNotification } from '../../../core/copy/appNotification';\nimport { runRequest } from '../../query/state/runRequest';\nimport { decorateData } from '../utils/decorators';\nimport { addHistoryItem, historyUpdatedAction, loadRichHistory } from './history';\nimport { stateSave } from './main';\nimport { updateTime } from './time';\nimport { createCacheKey, getResultsFromCache } from './utils'; //\n// Actions and Payloads\n//\n\n/**\n * Adds a query row after the row with the given index.\n */\n\nexport const addQueryRowAction = createAction('explore/addQueryRow');\n/**\n * Query change handler for the query row with the given index.\n * If `override` is reset the query modifications and run the queries. Use this to set queries via a link.\n */\n\nexport const changeQueriesAction = createAction('explore/changeQueries');\n/**\n * Cancel running queries.\n */\n\nexport const cancelQueriesAction = createAction('explore/cancelQueries');\nexport const queriesImportedAction = createAction('explore/queriesImported');\n/**\n * Action to modify a query given a datasource-specific modifier action.\n * @param exploreId Explore area\n * @param modification Action object with a type, e.g., ADD_FILTER\n * @param index Optional query row index. If omitted, the modification is applied to all query rows.\n * @param modifier Function that executes the modification, typically `datasourceInstance.modifyQueries`.\n */\n\nexport const modifyQueriesAction = createAction('explore/modifyQueries');\nexport const queryStoreSubscriptionAction = createAction('explore/queryStoreSubscription');\n\n/**\n * Stores available logs volume provider after running the query. Used internally by runQueries().\n */\nexport const storeLogsVolumeDataProviderAction = createAction('explore/storeLogsVolumeDataProviderAction');\nexport const cleanLogsVolumeAction = createAction('explore/cleanLogsVolumeAction');\n\n/**\n * Stores current logs volume subscription for given explore pane.\n */\nconst storeLogsVolumeDataSubscriptionAction = createAction('explore/storeLogsVolumeDataSubscriptionAction');\n/**\n * Stores data returned by the provider. Used internally by loadLogsVolumeData().\n */\n\nconst updateLogsVolumeDataAction = createAction('explore/updateLogsVolumeDataAction');\nexport const queryStreamUpdatedAction = createAction('explore/queryStreamUpdated');\n/**\n * Reset queries to the given queries. Any modifications will be discarded.\n * Use this action for clicks on query examples. Triggers a query run.\n */\n\nexport const setQueriesAction = createAction('explore/setQueries');\nexport const changeLoadingStateAction = createAction('changeLoadingState');\nexport const setPausedStateAction = createAction('explore/setPausedState');\n/**\n * Start a scan for more results using the given scanner.\n * @param exploreId Explore area\n * @param scanner Function that a) returns a new time range and b) triggers a query run for the new range\n */\n\nexport const scanStartAction = createAction('explore/scanStart');\n/**\n * Stop any scanning for more results.\n */\n\nexport const scanStopAction = createAction('explore/scanStop');\n/**\n * Adds query results to cache.\n * This is currently used to cache last 5 query results for log queries run from logs navigation (pagination).\n */\n\nexport const addResultsToCacheAction = createAction('explore/addResultsToCache');\n/**\n *  Clears cache.\n */\n\nexport const clearCacheAction = createAction('explore/clearCache'); //\n// Action creators\n//\n\n/**\n * Adds a query row after the row with the given index.\n */\n\nexport function addQueryRow(exploreId, index, datasource) {\n  return (dispatch, getState) => {\n    var _datasource$getDefaul;\n\n    const queries = getState().explore[exploreId].queries;\n    const query = Object.assign({}, datasource === null || datasource === void 0 ? void 0 : (_datasource$getDefaul = datasource.getDefaultQuery) === null || _datasource$getDefaul === void 0 ? void 0 : _datasource$getDefaul.call(datasource, CoreApp.Explore), generateEmptyQuery(queries, index));\n    dispatch(addQueryRowAction({\n      exploreId,\n      index,\n      query\n    }));\n  };\n}\n/**\n * Cancel running queries\n */\n\nexport function cancelQueries(exploreId) {\n  return (dispatch, getState) => {\n    var _logsVolumeData;\n\n    dispatch(scanStopAction({\n      exploreId\n    }));\n    dispatch(cancelQueriesAction({\n      exploreId\n    }));\n    dispatch(storeLogsVolumeDataProviderAction({\n      exploreId,\n      logsVolumeDataProvider: undefined\n    })); // clear any incomplete data\n\n    if (((_logsVolumeData = getState().explore[exploreId].logsVolumeData) === null || _logsVolumeData === void 0 ? void 0 : _logsVolumeData.state) !== LoadingState.Done) {\n      dispatch(cleanLogsVolumeAction({\n        exploreId\n      }));\n    }\n\n    dispatch(stateSave());\n  };\n}\n/**\n * Import queries from previous datasource if possible eg Loki and Prometheus have similar query language so the\n * labels part can be reused to get similar data.\n * @param exploreId\n * @param queries\n * @param sourceDataSource\n * @param targetDataSource\n */\n\nexport const importQueries = (exploreId, queries, sourceDataSource, targetDataSource) => {\n  return async dispatch => {\n    var _sourceDataSource$met, _targetDataSource$met;\n\n    if (!sourceDataSource) {\n      // explore not initialized\n      dispatch(queriesImportedAction({\n        exploreId,\n        queries\n      }));\n      return;\n    }\n\n    let importedQueries = queries; // Check if queries can be imported from previously selected datasource\n\n    if (((_sourceDataSource$met = sourceDataSource.meta) === null || _sourceDataSource$met === void 0 ? void 0 : _sourceDataSource$met.id) === ((_targetDataSource$met = targetDataSource.meta) === null || _targetDataSource$met === void 0 ? void 0 : _targetDataSource$met.id)) {\n      // Keep same queries if same type of datasource, but delete datasource query property to prevent mismatch of new and old data source instance\n      importedQueries = queries.map(_ref => {\n        let query = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n        return query;\n      });\n    } else if (hasQueryExportSupport(sourceDataSource) && hasQueryImportSupport(targetDataSource)) {\n      const abstractQueries = await sourceDataSource.exportToAbstractQueries(queries);\n      importedQueries = await targetDataSource.importFromAbstractQueries(abstractQueries);\n    } else if (targetDataSource.importQueries) {\n      // Datasource-specific importers\n      importedQueries = await targetDataSource.importQueries(queries, sourceDataSource);\n    } else {\n      // Default is blank queries\n      importedQueries = ensureQueries();\n    }\n\n    const nextQueries = ensureQueries(importedQueries);\n    dispatch(queriesImportedAction({\n      exploreId,\n      queries: nextQueries\n    }));\n  };\n};\n/**\n * Action to modify a query given a datasource-specific modifier action.\n * @param exploreId Explore area\n * @param modification Action object with a type, e.g., ADD_FILTER\n * @param index Optional query row index. If omitted, the modification is applied to all query rows.\n * @param modifier Function that executes the modification, typically `datasourceInstance.modifyQueries`.\n */\n\nexport function modifyQueries(exploreId, modification, modifier, index) {\n  return dispatch => {\n    dispatch(modifyQueriesAction({\n      exploreId,\n      modification,\n      index,\n      modifier\n    }));\n\n    if (!modification.preventSubmit) {\n      dispatch(runQueries(exploreId));\n    }\n  };\n}\n\nasync function handleHistory(dispatch, state, history, datasource, queries, exploreId) {\n  const datasourceId = datasource.meta.id;\n  const nextHistory = updateHistory(history, datasourceId, queries);\n  dispatch(historyUpdatedAction({\n    exploreId,\n    history: nextHistory\n  }));\n  dispatch(addHistoryItem(datasource.uid, datasource.name, queries)); // Because filtering happens in the backend we cannot add a new entry without checking if it matches currently\n  // used filters. Instead, we refresh the query history list.\n  // TODO: run only if Query History list is opened (#47252)\n\n  await dispatch(loadRichHistory(ExploreId.left));\n  await dispatch(loadRichHistory(ExploreId.right));\n}\n/**\n * Main action to run queries and dispatches sub-actions based on which result viewers are active\n */\n\n\nexport const runQueries = (exploreId, options) => {\n  return (dispatch, getState) => {\n    dispatch(updateTime({\n      exploreId\n    })); // We always want to clear cache unless we explicitly pass preserveCache parameter\n\n    const preserveCache = (options === null || options === void 0 ? void 0 : options.preserveCache) === true;\n\n    if (!preserveCache) {\n      dispatch(clearCache(exploreId));\n    }\n\n    const exploreItemState = getState().explore[exploreId];\n    const {\n      datasourceInstance,\n      containerWidth,\n      isLive: live,\n      range,\n      scanning,\n      queryResponse,\n      querySubscription,\n      refreshInterval,\n      absoluteRange,\n      cache\n    } = exploreItemState;\n    let newQuerySub;\n    const queries = exploreItemState.queries.map(query => Object.assign({}, query, {\n      datasource: query.datasource || (datasourceInstance === null || datasourceInstance === void 0 ? void 0 : datasourceInstance.getRef())\n    }));\n\n    if (datasourceInstance != null) {\n      handleHistory(dispatch, getState().explore, exploreItemState.history, datasourceInstance, queries, exploreId);\n    }\n\n    dispatch(stateSave({\n      replace: options === null || options === void 0 ? void 0 : options.replaceUrl\n    }));\n    const cachedValue = getResultsFromCache(cache, absoluteRange); // If we have results saved in cache, we are going to use those results instead of running queries\n\n    if (cachedValue) {\n      newQuerySub = of(cachedValue).pipe(mergeMap(data => decorateData(data, queryResponse, absoluteRange, refreshInterval, queries, datasourceInstance != null && hasLogsVolumeSupport(datasourceInstance)))).subscribe(data => {\n        if (!data.error) {\n          dispatch(stateSave());\n        }\n\n        dispatch(queryStreamUpdatedAction({\n          exploreId,\n          response: data\n        }));\n      }); // If we don't have results saved in cache, run new queries\n    } else {\n      if (!hasNonEmptyQuery(queries)) {\n        dispatch(stateSave({\n          replace: options === null || options === void 0 ? void 0 : options.replaceUrl\n        })); // Remember to save to state and update location\n\n        return;\n      }\n\n      if (!datasourceInstance) {\n        return;\n      } // Some datasource's query builders allow per-query interval limits,\n      // but we're using the datasource interval limit for now\n\n\n      const minInterval = datasourceInstance === null || datasourceInstance === void 0 ? void 0 : datasourceInstance.interval;\n      stopQueryState(querySubscription);\n      const queryOptions = {\n        minInterval,\n        // maxDataPoints is used in:\n        // Loki - used for logs streaming for buffer size, with undefined it falls back to datasource config if it supports that.\n        // Elastic - limits the number of datapoints for the counts query and for logs it has hardcoded limit.\n        // Influx - used to correctly display logs in graph\n        // TODO:unification\n        // maxDataPoints: mode === ExploreMode.Logs && datasourceId === 'loki' ? undefined : containerWidth,\n        maxDataPoints: containerWidth,\n        liveStreaming: live\n      };\n      const timeZone = getTimeZone(getState().user);\n      const transaction = buildQueryTransaction(exploreId, queries, queryOptions, range, scanning, timeZone);\n      dispatch(changeLoadingStateAction({\n        exploreId,\n        loadingState: LoadingState.Loading\n      }));\n      newQuerySub = runRequest(datasourceInstance, transaction.request).pipe( // Simple throttle for live tailing, in case of > 1000 rows per interval we spend about 200ms on processing and\n      // rendering. In case this is optimized this can be tweaked, but also it should be only as fast as user\n      // actually can see what is happening.\n      live ? throttleTime(500) : identity, mergeMap(data => decorateData(data, queryResponse, absoluteRange, refreshInterval, queries, datasourceInstance != null && hasLogsVolumeSupport(datasourceInstance)))).subscribe({\n        next(data) {\n          if (data.logsResult !== null) {\n            reportInteraction('grafana_explore_logs_result_displayed', {\n              datasourceType: datasourceInstance.type\n            });\n          }\n\n          dispatch(queryStreamUpdatedAction({\n            exploreId,\n            response: data\n          })); // Keep scanning for results if this was the last scanning transaction\n\n          if (getState().explore[exploreId].scanning) {\n            if (data.state === LoadingState.Done && data.series.length === 0) {\n              const range = getShiftedTimeRange(-1, getState().explore[exploreId].range);\n              dispatch(updateTime({\n                exploreId,\n                absoluteRange: range\n              }));\n              dispatch(runQueries(exploreId));\n            } else {\n              // We can stop scanning if we have a result\n              dispatch(scanStopAction({\n                exploreId\n              }));\n            }\n          }\n        },\n\n        error(error) {\n          dispatch(notifyApp(createErrorNotification('Query processing error', error)));\n          dispatch(changeLoadingStateAction({\n            exploreId,\n            loadingState: LoadingState.Error\n          }));\n          console.error(error);\n        },\n\n        complete() {\n          // In case we don't get any response at all but the observable completed, make sure we stop loading state.\n          // This is for cases when some queries are noop like running first query after load but we don't have any\n          // actual query input.\n          if (getState().explore[exploreId].queryResponse.state === LoadingState.Loading) {\n            dispatch(changeLoadingStateAction({\n              exploreId,\n              loadingState: LoadingState.Done\n            }));\n          }\n        }\n\n      });\n\n      if (live) {\n        dispatch(storeLogsVolumeDataProviderAction({\n          exploreId,\n          logsVolumeDataProvider: undefined\n        }));\n        dispatch(cleanLogsVolumeAction({\n          exploreId\n        }));\n      } else if (hasLogsVolumeSupport(datasourceInstance)) {\n        const sourceRequest = Object.assign({}, transaction.request, {\n          requestId: transaction.request.requestId + '_log_volume'\n        });\n        const logsVolumeDataProvider = datasourceInstance.getLogsVolumeDataProvider(sourceRequest);\n        dispatch(storeLogsVolumeDataProviderAction({\n          exploreId,\n          logsVolumeDataProvider\n        }));\n        const {\n          logsVolumeData,\n          absoluteRange\n        } = getState().explore[exploreId];\n\n        if (!canReuseLogsVolumeData(logsVolumeData, queries, absoluteRange)) {\n          dispatch(cleanLogsVolumeAction({\n            exploreId\n          }));\n          dispatch(loadLogsVolumeData(exploreId));\n        }\n      } else {\n        dispatch(storeLogsVolumeDataProviderAction({\n          exploreId,\n          logsVolumeDataProvider: undefined\n        }));\n      }\n    }\n\n    dispatch(queryStoreSubscriptionAction({\n      exploreId,\n      querySubscription: newQuerySub\n    }));\n  };\n};\n/**\n * Checks if after changing the time range the existing data can be used to show logs volume.\n * It can happen if queries are the same and new time range is within existing data time range.\n */\n\nfunction canReuseLogsVolumeData(logsVolumeData, queries, selectedTimeRange) {\n  if (logsVolumeData && logsVolumeData.data[0]) {\n    var _logsVolumeData$data$, _logsVolumeData$data$2, _logsVolumeData$data$3, _logsVolumeData$data$4;\n\n    // check if queries are the same\n    if (!deepEqual((_logsVolumeData$data$ = logsVolumeData.data[0].meta) === null || _logsVolumeData$data$ === void 0 ? void 0 : (_logsVolumeData$data$2 = _logsVolumeData$data$.custom) === null || _logsVolumeData$data$2 === void 0 ? void 0 : _logsVolumeData$data$2.targets, queries)) {\n      return false;\n    }\n\n    const dataRange = logsVolumeData && logsVolumeData.data[0] && ((_logsVolumeData$data$3 = logsVolumeData.data[0].meta) === null || _logsVolumeData$data$3 === void 0 ? void 0 : (_logsVolumeData$data$4 = _logsVolumeData$data$3.custom) === null || _logsVolumeData$data$4 === void 0 ? void 0 : _logsVolumeData$data$4.absoluteRange); // if selected range is within loaded logs volume\n\n    if (dataRange && dataRange.from <= selectedTimeRange.from && selectedTimeRange.to <= dataRange.to) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Reset queries to the given queries. Any modifications will be discarded.\n * Use this action for clicks on query examples. Triggers a query run.\n */\n\n\nexport function setQueries(exploreId, rawQueries) {\n  return (dispatch, getState) => {\n    // Inject react keys into query objects\n    const queries = getState().explore[exploreId].queries;\n    const nextQueries = rawQueries.map((query, index) => generateNewKeyAndAddRefIdIfMissing(query, queries, index));\n    dispatch(setQueriesAction({\n      exploreId,\n      queries: nextQueries\n    }));\n    dispatch(runQueries(exploreId));\n  };\n}\n/**\n * Start a scan for more results using the given scanner.\n * @param exploreId Explore area\n * @param scanner Function that a) returns a new time range and b) triggers a query run for the new range\n */\n\nexport function scanStart(exploreId) {\n  return (dispatch, getState) => {\n    // Register the scanner\n    dispatch(scanStartAction({\n      exploreId\n    })); // Scanning must trigger query run, and return the new range\n\n    const range = getShiftedTimeRange(-1, getState().explore[exploreId].range); // Set the new range to be displayed\n\n    dispatch(updateTime({\n      exploreId,\n      absoluteRange: range\n    }));\n    dispatch(runQueries(exploreId));\n  };\n}\nexport function addResultsToCache(exploreId) {\n  return (dispatch, getState) => {\n    const queryResponse = getState().explore[exploreId].queryResponse;\n    const absoluteRange = getState().explore[exploreId].absoluteRange;\n    const cacheKey = createCacheKey(absoluteRange); // Save results to cache only when all results recived and loading is done\n\n    if (queryResponse.state === LoadingState.Done) {\n      dispatch(addResultsToCacheAction({\n        exploreId,\n        cacheKey,\n        queryResponse\n      }));\n    }\n  };\n}\nexport function clearCache(exploreId) {\n  return (dispatch, getState) => {\n    dispatch(clearCacheAction({\n      exploreId\n    }));\n  };\n}\n/**\n * Initializes loading logs volume data and stores emitted value.\n */\n\nexport function loadLogsVolumeData(exploreId) {\n  return (dispatch, getState) => {\n    const {\n      logsVolumeDataProvider\n    } = getState().explore[exploreId];\n\n    if (logsVolumeDataProvider) {\n      const logsVolumeDataSubscription = logsVolumeDataProvider.subscribe({\n        next: logsVolumeData => {\n          dispatch(updateLogsVolumeDataAction({\n            exploreId,\n            logsVolumeData\n          }));\n        }\n      });\n      dispatch(storeLogsVolumeDataSubscriptionAction({\n        exploreId,\n        logsVolumeDataSubscription\n      }));\n    }\n  };\n} //\n// Reducer\n//\n// Redux Toolkit uses ImmerJs as part of their solution to ensure that state objects are not mutated.\n// ImmerJs has an autoFreeze option that freezes objects from change which means this reducer can't be migrated to createSlice\n// because the state would become frozen and during run time we would get errors because flot (Graph lib) would try to mutate\n// the frozen state.\n// https://github.com/reduxjs/redux-toolkit/issues/242\n\nexport const queryReducer = (state, action) => {\n  if (addQueryRowAction.match(action)) {\n    const {\n      queries\n    } = state;\n    const {\n      index,\n      query\n    } = action.payload; // Add to queries, which will cause a new row to be rendered\n\n    const nextQueries = [...queries.slice(0, index + 1), Object.assign({}, query), ...queries.slice(index + 1)];\n    return Object.assign({}, state, {\n      queries: nextQueries,\n      queryKeys: getQueryKeys(nextQueries, state.datasourceInstance)\n    });\n  }\n\n  if (changeQueriesAction.match(action)) {\n    const {\n      queries\n    } = action.payload;\n    return Object.assign({}, state, {\n      queries\n    });\n  }\n\n  if (cancelQueriesAction.match(action)) {\n    stopQueryState(state.querySubscription);\n    return Object.assign({}, state, {\n      loading: false\n    });\n  }\n\n  if (modifyQueriesAction.match(action)) {\n    const {\n      queries\n    } = state;\n    const {\n      modification,\n      index,\n      modifier\n    } = action.payload;\n    let nextQueries;\n\n    if (index === undefined) {\n      // Modify all queries\n      nextQueries = queries.map((query, i) => {\n        const nextQuery = modifier(Object.assign({}, query), modification);\n        return generateNewKeyAndAddRefIdIfMissing(nextQuery, queries, i);\n      });\n    } else {\n      // Modify query only at index\n      nextQueries = queries.map((query, i) => {\n        if (i === index) {\n          const nextQuery = modifier(Object.assign({}, query), modification);\n          return generateNewKeyAndAddRefIdIfMissing(nextQuery, queries, i);\n        }\n\n        return query;\n      });\n    }\n\n    return Object.assign({}, state, {\n      queries: nextQueries,\n      queryKeys: getQueryKeys(nextQueries, state.datasourceInstance)\n    });\n  }\n\n  if (setQueriesAction.match(action)) {\n    const {\n      queries\n    } = action.payload;\n    return Object.assign({}, state, {\n      queries: queries.slice(),\n      queryKeys: getQueryKeys(queries, state.datasourceInstance)\n    });\n  }\n\n  if (queriesImportedAction.match(action)) {\n    const {\n      queries\n    } = action.payload;\n    return Object.assign({}, state, {\n      queries,\n      queryKeys: getQueryKeys(queries, state.datasourceInstance)\n    });\n  }\n\n  if (queryStoreSubscriptionAction.match(action)) {\n    const {\n      querySubscription\n    } = action.payload;\n    return Object.assign({}, state, {\n      querySubscription\n    });\n  }\n\n  if (storeLogsVolumeDataProviderAction.match(action)) {\n    let {\n      logsVolumeDataProvider\n    } = action.payload;\n\n    if (state.logsVolumeDataSubscription) {\n      state.logsVolumeDataSubscription.unsubscribe();\n    }\n\n    return Object.assign({}, state, {\n      logsVolumeDataProvider,\n      logsVolumeDataSubscription: undefined\n    });\n  }\n\n  if (cleanLogsVolumeAction.match(action)) {\n    return Object.assign({}, state, {\n      logsVolumeData: undefined\n    });\n  }\n\n  if (storeLogsVolumeDataSubscriptionAction.match(action)) {\n    const {\n      logsVolumeDataSubscription\n    } = action.payload;\n    return Object.assign({}, state, {\n      logsVolumeDataSubscription\n    });\n  }\n\n  if (updateLogsVolumeDataAction.match(action)) {\n    let {\n      logsVolumeData\n    } = action.payload;\n    return Object.assign({}, state, {\n      logsVolumeData\n    });\n  }\n\n  if (queryStreamUpdatedAction.match(action)) {\n    return processQueryResponse(state, action);\n  }\n\n  if (queriesImportedAction.match(action)) {\n    const {\n      queries\n    } = action.payload;\n    return Object.assign({}, state, {\n      queries,\n      queryKeys: getQueryKeys(queries, state.datasourceInstance)\n    });\n  }\n\n  if (changeLoadingStateAction.match(action)) {\n    const {\n      loadingState\n    } = action.payload;\n    return Object.assign({}, state, {\n      queryResponse: Object.assign({}, state.queryResponse, {\n        state: loadingState\n      }),\n      loading: loadingState === LoadingState.Loading || loadingState === LoadingState.Streaming\n    });\n  }\n\n  if (setPausedStateAction.match(action)) {\n    const {\n      isPaused\n    } = action.payload;\n    return Object.assign({}, state, {\n      isPaused: isPaused\n    });\n  }\n\n  if (scanStartAction.match(action)) {\n    return Object.assign({}, state, {\n      scanning: true\n    });\n  }\n\n  if (scanStopAction.match(action)) {\n    return Object.assign({}, state, {\n      scanning: false,\n      scanRange: undefined\n    });\n  }\n\n  if (addResultsToCacheAction.match(action)) {\n    const CACHE_LIMIT = 5;\n    const {\n      cache\n    } = state;\n    const {\n      queryResponse,\n      cacheKey\n    } = action.payload;\n    let newCache = [...cache];\n    const isDuplicateKey = newCache.some(c => c.key === cacheKey);\n\n    if (!isDuplicateKey) {\n      const newCacheItem = {\n        key: cacheKey,\n        value: queryResponse\n      };\n      newCache = [newCacheItem, ...newCache].slice(0, CACHE_LIMIT);\n    }\n\n    return Object.assign({}, state, {\n      cache: newCache\n    });\n  }\n\n  if (clearCacheAction.match(action)) {\n    return Object.assign({}, state, {\n      cache: []\n    });\n  }\n\n  return state;\n};\nexport const processQueryResponse = (state, action) => {\n  var _state$datasourceInst3, _state$datasourceInst4;\n\n  const {\n    response\n  } = action.payload;\n  const {\n    request,\n    state: loadingState,\n    series,\n    error,\n    graphResult,\n    logsResult,\n    tableResult,\n    traceFrames,\n    nodeGraphFrames\n  } = response;\n\n  if (error) {\n    var _state$datasourceInst, _state$datasourceInst2;\n\n    if (error.type === DataQueryErrorType.Timeout) {\n      return Object.assign({}, state, {\n        queryResponse: response,\n        loading: loadingState === LoadingState.Loading || loadingState === LoadingState.Streaming\n      });\n    } else if (error.type === DataQueryErrorType.Cancelled) {\n      return state;\n    } // Send error to Angular editors\n    // When angularSupportEnabled is removed we can remove this code and all references to eventBridge\n\n\n    if (config.angularSupportEnabled && (_state$datasourceInst = state.datasourceInstance) !== null && _state$datasourceInst !== void 0 && (_state$datasourceInst2 = _state$datasourceInst.components) !== null && _state$datasourceInst2 !== void 0 && _state$datasourceInst2.QueryCtrl) {\n      state.eventBridge.emit(PanelEvents.dataError, error);\n    }\n  }\n\n  if (!request) {\n    return Object.assign({}, state);\n  } // Send legacy data to Angular editors\n  // When angularSupportEnabled is removed we can remove this code and all references to eventBridge\n\n\n  if (config.angularSupportEnabled && (_state$datasourceInst3 = state.datasourceInstance) !== null && _state$datasourceInst3 !== void 0 && (_state$datasourceInst4 = _state$datasourceInst3.components) !== null && _state$datasourceInst4 !== void 0 && _state$datasourceInst4.QueryCtrl) {\n    const legacy = series.map(v => toLegacyResponseData(v));\n    state.eventBridge.emit(PanelEvents.dataReceived, legacy);\n  }\n\n  return Object.assign({}, state, {\n    queryResponse: response,\n    graphResult,\n    tableResult,\n    logsResult,\n    loading: loadingState === LoadingState.Loading || loadingState === LoadingState.Streaming,\n    showLogs: !!logsResult,\n    showMetrics: !!graphResult,\n    showTable: !!tableResult,\n    showTrace: !!traceFrames.length,\n    showNodeGraph: !!nodeGraphFrames.length\n  });\n};","map":{"version":3,"names":["createAction","deepEqual","identity","of","mergeMap","throttleTime","CoreApp","DataQueryErrorType","hasLogsVolumeSupport","hasQueryExportSupport","hasQueryImportSupport","LoadingState","PanelEvents","toLegacyResponseData","config","reportInteraction","buildQueryTransaction","ensureQueries","generateEmptyQuery","generateNewKeyAndAddRefIdIfMissing","getQueryKeys","hasNonEmptyQuery","stopQueryState","updateHistory","getShiftedTimeRange","getTimeZone","ExploreId","notifyApp","createErrorNotification","runRequest","decorateData","addHistoryItem","historyUpdatedAction","loadRichHistory","stateSave","updateTime","createCacheKey","getResultsFromCache","addQueryRowAction","changeQueriesAction","cancelQueriesAction","queriesImportedAction","modifyQueriesAction","queryStoreSubscriptionAction","storeLogsVolumeDataProviderAction","cleanLogsVolumeAction","storeLogsVolumeDataSubscriptionAction","updateLogsVolumeDataAction","queryStreamUpdatedAction","setQueriesAction","changeLoadingStateAction","setPausedStateAction","scanStartAction","scanStopAction","addResultsToCacheAction","clearCacheAction","addQueryRow","exploreId","index","datasource","dispatch","getState","queries","explore","query","getDefaultQuery","Explore","cancelQueries","logsVolumeDataProvider","undefined","logsVolumeData","state","Done","importQueries","sourceDataSource","targetDataSource","importedQueries","meta","id","map","abstractQueries","exportToAbstractQueries","importFromAbstractQueries","nextQueries","modifyQueries","modification","modifier","preventSubmit","runQueries","handleHistory","history","datasourceId","nextHistory","uid","name","left","right","options","preserveCache","clearCache","exploreItemState","datasourceInstance","containerWidth","isLive","live","range","scanning","queryResponse","querySubscription","refreshInterval","absoluteRange","cache","newQuerySub","getRef","replace","replaceUrl","cachedValue","pipe","data","subscribe","error","response","minInterval","interval","queryOptions","maxDataPoints","liveStreaming","timeZone","user","transaction","loadingState","Loading","request","next","logsResult","datasourceType","type","series","length","Error","console","complete","sourceRequest","requestId","getLogsVolumeDataProvider","canReuseLogsVolumeData","loadLogsVolumeData","selectedTimeRange","custom","targets","dataRange","from","to","setQueries","rawQueries","scanStart","addResultsToCache","cacheKey","logsVolumeDataSubscription","queryReducer","action","match","payload","slice","queryKeys","loading","i","nextQuery","unsubscribe","processQueryResponse","Streaming","isPaused","scanRange","CACHE_LIMIT","newCache","isDuplicateKey","some","c","key","newCacheItem","value","graphResult","tableResult","traceFrames","nodeGraphFrames","Timeout","Cancelled","angularSupportEnabled","components","QueryCtrl","eventBridge","emit","dataError","legacy","v","dataReceived","showLogs","showMetrics","showTable","showTrace","showNodeGraph"],"sources":["/home/soula/grafana/public/app/features/explore/state/query.ts"],"sourcesContent":["import { AnyAction, createAction, PayloadAction } from '@reduxjs/toolkit';\nimport deepEqual from 'fast-deep-equal';\nimport { identity, Observable, of, SubscriptionLike, Unsubscribable } from 'rxjs';\nimport { mergeMap, throttleTime } from 'rxjs/operators';\n\nimport {\n  AbsoluteTimeRange,\n  CoreApp,\n  DataQuery,\n  DataQueryErrorType,\n  DataQueryResponse,\n  DataSourceApi,\n  hasLogsVolumeSupport,\n  hasQueryExportSupport,\n  hasQueryImportSupport,\n  HistoryItem,\n  LoadingState,\n  PanelData,\n  PanelEvents,\n  QueryFixAction,\n  toLegacyResponseData,\n} from '@grafana/data';\nimport { config, reportInteraction } from '@grafana/runtime';\nimport {\n  buildQueryTransaction,\n  ensureQueries,\n  generateEmptyQuery,\n  generateNewKeyAndAddRefIdIfMissing,\n  getQueryKeys,\n  hasNonEmptyQuery,\n  stopQueryState,\n  updateHistory,\n} from 'app/core/utils/explore';\nimport { getShiftedTimeRange } from 'app/core/utils/timePicker';\nimport { getTimeZone } from 'app/features/profile/state/selectors';\nimport { ExploreItemState, ExplorePanelData, ThunkDispatch, ThunkResult } from 'app/types';\nimport { ExploreId, ExploreState, QueryOptions } from 'app/types/explore';\n\nimport { notifyApp } from '../../../core/actions';\nimport { createErrorNotification } from '../../../core/copy/appNotification';\nimport { runRequest } from '../../query/state/runRequest';\nimport { decorateData } from '../utils/decorators';\n\nimport { addHistoryItem, historyUpdatedAction, loadRichHistory } from './history';\nimport { stateSave } from './main';\nimport { updateTime } from './time';\nimport { createCacheKey, getResultsFromCache } from './utils';\n\n//\n// Actions and Payloads\n//\n\n/**\n * Adds a query row after the row with the given index.\n */\nexport interface AddQueryRowPayload {\n  exploreId: ExploreId;\n  index: number;\n  query: DataQuery;\n}\nexport const addQueryRowAction = createAction<AddQueryRowPayload>('explore/addQueryRow');\n\n/**\n * Query change handler for the query row with the given index.\n * If `override` is reset the query modifications and run the queries. Use this to set queries via a link.\n */\nexport interface ChangeQueriesPayload {\n  exploreId: ExploreId;\n  queries: DataQuery[];\n}\nexport const changeQueriesAction = createAction<ChangeQueriesPayload>('explore/changeQueries');\n\n/**\n * Cancel running queries.\n */\nexport interface CancelQueriesPayload {\n  exploreId: ExploreId;\n}\nexport const cancelQueriesAction = createAction<CancelQueriesPayload>('explore/cancelQueries');\n\nexport interface QueriesImportedPayload {\n  exploreId: ExploreId;\n  queries: DataQuery[];\n}\nexport const queriesImportedAction = createAction<QueriesImportedPayload>('explore/queriesImported');\n\n/**\n * Action to modify a query given a datasource-specific modifier action.\n * @param exploreId Explore area\n * @param modification Action object with a type, e.g., ADD_FILTER\n * @param index Optional query row index. If omitted, the modification is applied to all query rows.\n * @param modifier Function that executes the modification, typically `datasourceInstance.modifyQueries`.\n */\nexport interface ModifyQueriesPayload {\n  exploreId: ExploreId;\n  modification: QueryFixAction;\n  index?: number;\n  modifier: (query: DataQuery, modification: QueryFixAction) => DataQuery;\n}\nexport const modifyQueriesAction = createAction<ModifyQueriesPayload>('explore/modifyQueries');\n\nexport interface QueryStoreSubscriptionPayload {\n  exploreId: ExploreId;\n  querySubscription: Unsubscribable;\n}\n\nexport const queryStoreSubscriptionAction = createAction<QueryStoreSubscriptionPayload>(\n  'explore/queryStoreSubscription'\n);\n\nexport interface StoreLogsVolumeDataProvider {\n  exploreId: ExploreId;\n  logsVolumeDataProvider?: Observable<DataQueryResponse>;\n}\n\n/**\n * Stores available logs volume provider after running the query. Used internally by runQueries().\n */\nexport const storeLogsVolumeDataProviderAction = createAction<StoreLogsVolumeDataProvider>(\n  'explore/storeLogsVolumeDataProviderAction'\n);\n\nexport const cleanLogsVolumeAction = createAction<{ exploreId: ExploreId }>('explore/cleanLogsVolumeAction');\n\nexport interface StoreLogsVolumeDataSubscriptionPayload {\n  exploreId: ExploreId;\n  logsVolumeDataSubscription?: SubscriptionLike;\n}\n\n/**\n * Stores current logs volume subscription for given explore pane.\n */\nconst storeLogsVolumeDataSubscriptionAction = createAction<StoreLogsVolumeDataSubscriptionPayload>(\n  'explore/storeLogsVolumeDataSubscriptionAction'\n);\n\n/**\n * Stores data returned by the provider. Used internally by loadLogsVolumeData().\n */\nconst updateLogsVolumeDataAction = createAction<{\n  exploreId: ExploreId;\n  logsVolumeData: DataQueryResponse;\n}>('explore/updateLogsVolumeDataAction');\n\nexport interface QueryEndedPayload {\n  exploreId: ExploreId;\n  response: ExplorePanelData;\n}\nexport const queryStreamUpdatedAction = createAction<QueryEndedPayload>('explore/queryStreamUpdated');\n\n/**\n * Reset queries to the given queries. Any modifications will be discarded.\n * Use this action for clicks on query examples. Triggers a query run.\n */\nexport interface SetQueriesPayload {\n  exploreId: ExploreId;\n  queries: DataQuery[];\n}\nexport const setQueriesAction = createAction<SetQueriesPayload>('explore/setQueries');\n\nexport interface ChangeLoadingStatePayload {\n  exploreId: ExploreId;\n  loadingState: LoadingState;\n}\nexport const changeLoadingStateAction = createAction<ChangeLoadingStatePayload>('changeLoadingState');\n\nexport interface SetPausedStatePayload {\n  exploreId: ExploreId;\n  isPaused: boolean;\n}\nexport const setPausedStateAction = createAction<SetPausedStatePayload>('explore/setPausedState');\n\n/**\n * Start a scan for more results using the given scanner.\n * @param exploreId Explore area\n * @param scanner Function that a) returns a new time range and b) triggers a query run for the new range\n */\nexport interface ScanStartPayload {\n  exploreId: ExploreId;\n}\nexport const scanStartAction = createAction<ScanStartPayload>('explore/scanStart');\n\n/**\n * Stop any scanning for more results.\n */\nexport interface ScanStopPayload {\n  exploreId: ExploreId;\n}\nexport const scanStopAction = createAction<ScanStopPayload>('explore/scanStop');\n\n/**\n * Adds query results to cache.\n * This is currently used to cache last 5 query results for log queries run from logs navigation (pagination).\n */\nexport interface AddResultsToCachePayload {\n  exploreId: ExploreId;\n  cacheKey: string;\n  queryResponse: ExplorePanelData;\n}\nexport const addResultsToCacheAction = createAction<AddResultsToCachePayload>('explore/addResultsToCache');\n\n/**\n *  Clears cache.\n */\nexport interface ClearCachePayload {\n  exploreId: ExploreId;\n}\nexport const clearCacheAction = createAction<ClearCachePayload>('explore/clearCache');\n\n//\n// Action creators\n//\n\n/**\n * Adds a query row after the row with the given index.\n */\nexport function addQueryRow(\n  exploreId: ExploreId,\n  index: number,\n  datasource: DataSourceApi | undefined | null\n): ThunkResult<void> {\n  return (dispatch, getState) => {\n    const queries = getState().explore[exploreId]!.queries;\n    const query = {\n      ...datasource?.getDefaultQuery?.(CoreApp.Explore),\n      ...generateEmptyQuery(queries, index),\n    };\n\n    dispatch(addQueryRowAction({ exploreId, index, query }));\n  };\n}\n\n/**\n * Cancel running queries\n */\nexport function cancelQueries(exploreId: ExploreId): ThunkResult<void> {\n  return (dispatch, getState) => {\n    dispatch(scanStopAction({ exploreId }));\n    dispatch(cancelQueriesAction({ exploreId }));\n    dispatch(\n      storeLogsVolumeDataProviderAction({\n        exploreId,\n        logsVolumeDataProvider: undefined,\n      })\n    );\n    // clear any incomplete data\n    if (getState().explore[exploreId]!.logsVolumeData?.state !== LoadingState.Done) {\n      dispatch(cleanLogsVolumeAction({ exploreId }));\n    }\n    dispatch(stateSave());\n  };\n}\n\n/**\n * Import queries from previous datasource if possible eg Loki and Prometheus have similar query language so the\n * labels part can be reused to get similar data.\n * @param exploreId\n * @param queries\n * @param sourceDataSource\n * @param targetDataSource\n */\nexport const importQueries = (\n  exploreId: ExploreId,\n  queries: DataQuery[],\n  sourceDataSource: DataSourceApi | undefined | null,\n  targetDataSource: DataSourceApi\n): ThunkResult<void> => {\n  return async (dispatch) => {\n    if (!sourceDataSource) {\n      // explore not initialized\n      dispatch(queriesImportedAction({ exploreId, queries }));\n      return;\n    }\n\n    let importedQueries = queries;\n    // Check if queries can be imported from previously selected datasource\n    if (sourceDataSource.meta?.id === targetDataSource.meta?.id) {\n      // Keep same queries if same type of datasource, but delete datasource query property to prevent mismatch of new and old data source instance\n      importedQueries = queries.map(({ datasource, ...query }) => query);\n    } else if (hasQueryExportSupport(sourceDataSource) && hasQueryImportSupport(targetDataSource)) {\n      const abstractQueries = await sourceDataSource.exportToAbstractQueries(queries);\n      importedQueries = await targetDataSource.importFromAbstractQueries(abstractQueries);\n    } else if (targetDataSource.importQueries) {\n      // Datasource-specific importers\n      importedQueries = await targetDataSource.importQueries(queries, sourceDataSource);\n    } else {\n      // Default is blank queries\n      importedQueries = ensureQueries();\n    }\n\n    const nextQueries = ensureQueries(importedQueries);\n\n    dispatch(queriesImportedAction({ exploreId, queries: nextQueries }));\n  };\n};\n\n/**\n * Action to modify a query given a datasource-specific modifier action.\n * @param exploreId Explore area\n * @param modification Action object with a type, e.g., ADD_FILTER\n * @param index Optional query row index. If omitted, the modification is applied to all query rows.\n * @param modifier Function that executes the modification, typically `datasourceInstance.modifyQueries`.\n */\nexport function modifyQueries(\n  exploreId: ExploreId,\n  modification: QueryFixAction,\n  modifier: any,\n  index?: number\n): ThunkResult<void> {\n  return (dispatch) => {\n    dispatch(modifyQueriesAction({ exploreId, modification, index, modifier }));\n    if (!modification.preventSubmit) {\n      dispatch(runQueries(exploreId));\n    }\n  };\n}\n\nasync function handleHistory(\n  dispatch: ThunkDispatch,\n  state: ExploreState,\n  history: Array<HistoryItem<DataQuery>>,\n  datasource: DataSourceApi,\n  queries: DataQuery[],\n  exploreId: ExploreId\n) {\n  const datasourceId = datasource.meta.id;\n  const nextHistory = updateHistory(history, datasourceId, queries);\n  dispatch(historyUpdatedAction({ exploreId, history: nextHistory }));\n\n  dispatch(addHistoryItem(datasource.uid, datasource.name, queries));\n\n  // Because filtering happens in the backend we cannot add a new entry without checking if it matches currently\n  // used filters. Instead, we refresh the query history list.\n  // TODO: run only if Query History list is opened (#47252)\n  await dispatch(loadRichHistory(ExploreId.left));\n  await dispatch(loadRichHistory(ExploreId.right));\n}\n\n/**\n * Main action to run queries and dispatches sub-actions based on which result viewers are active\n */\nexport const runQueries = (\n  exploreId: ExploreId,\n  options?: { replaceUrl?: boolean; preserveCache?: boolean }\n): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    dispatch(updateTime({ exploreId }));\n\n    // We always want to clear cache unless we explicitly pass preserveCache parameter\n    const preserveCache = options?.preserveCache === true;\n    if (!preserveCache) {\n      dispatch(clearCache(exploreId));\n    }\n\n    const exploreItemState = getState().explore[exploreId]!;\n    const {\n      datasourceInstance,\n      containerWidth,\n      isLive: live,\n      range,\n      scanning,\n      queryResponse,\n      querySubscription,\n      refreshInterval,\n      absoluteRange,\n      cache,\n    } = exploreItemState;\n    let newQuerySub;\n\n    const queries = exploreItemState.queries.map((query) => ({\n      ...query,\n      datasource: query.datasource || datasourceInstance?.getRef(),\n    }));\n\n    if (datasourceInstance != null) {\n      handleHistory(dispatch, getState().explore, exploreItemState.history, datasourceInstance, queries, exploreId);\n    }\n\n    dispatch(stateSave({ replace: options?.replaceUrl }));\n\n    const cachedValue = getResultsFromCache(cache, absoluteRange);\n\n    // If we have results saved in cache, we are going to use those results instead of running queries\n    if (cachedValue) {\n      newQuerySub = of(cachedValue)\n        .pipe(\n          mergeMap((data: PanelData) =>\n            decorateData(\n              data,\n              queryResponse,\n              absoluteRange,\n              refreshInterval,\n              queries,\n              datasourceInstance != null && hasLogsVolumeSupport(datasourceInstance)\n            )\n          )\n        )\n        .subscribe((data) => {\n          if (!data.error) {\n            dispatch(stateSave());\n          }\n\n          dispatch(queryStreamUpdatedAction({ exploreId, response: data }));\n        });\n\n      // If we don't have results saved in cache, run new queries\n    } else {\n      if (!hasNonEmptyQuery(queries)) {\n        dispatch(stateSave({ replace: options?.replaceUrl })); // Remember to save to state and update location\n        return;\n      }\n\n      if (!datasourceInstance) {\n        return;\n      }\n\n      // Some datasource's query builders allow per-query interval limits,\n      // but we're using the datasource interval limit for now\n      const minInterval = datasourceInstance?.interval;\n\n      stopQueryState(querySubscription);\n\n      const queryOptions: QueryOptions = {\n        minInterval,\n        // maxDataPoints is used in:\n        // Loki - used for logs streaming for buffer size, with undefined it falls back to datasource config if it supports that.\n        // Elastic - limits the number of datapoints for the counts query and for logs it has hardcoded limit.\n        // Influx - used to correctly display logs in graph\n        // TODO:unification\n        // maxDataPoints: mode === ExploreMode.Logs && datasourceId === 'loki' ? undefined : containerWidth,\n        maxDataPoints: containerWidth,\n        liveStreaming: live,\n      };\n\n      const timeZone = getTimeZone(getState().user);\n      const transaction = buildQueryTransaction(exploreId, queries, queryOptions, range, scanning, timeZone);\n\n      dispatch(changeLoadingStateAction({ exploreId, loadingState: LoadingState.Loading }));\n\n      newQuerySub = runRequest(datasourceInstance, transaction.request)\n        .pipe(\n          // Simple throttle for live tailing, in case of > 1000 rows per interval we spend about 200ms on processing and\n          // rendering. In case this is optimized this can be tweaked, but also it should be only as fast as user\n          // actually can see what is happening.\n          live ? throttleTime(500) : identity,\n          mergeMap((data: PanelData) =>\n            decorateData(\n              data,\n              queryResponse,\n              absoluteRange,\n              refreshInterval,\n              queries,\n              datasourceInstance != null && hasLogsVolumeSupport(datasourceInstance)\n            )\n          )\n        )\n        .subscribe({\n          next(data) {\n            if (data.logsResult !== null) {\n              reportInteraction('grafana_explore_logs_result_displayed', {\n                datasourceType: datasourceInstance.type,\n              });\n            }\n            dispatch(queryStreamUpdatedAction({ exploreId, response: data }));\n\n            // Keep scanning for results if this was the last scanning transaction\n            if (getState().explore[exploreId]!.scanning) {\n              if (data.state === LoadingState.Done && data.series.length === 0) {\n                const range = getShiftedTimeRange(-1, getState().explore[exploreId]!.range);\n                dispatch(updateTime({ exploreId, absoluteRange: range }));\n                dispatch(runQueries(exploreId));\n              } else {\n                // We can stop scanning if we have a result\n                dispatch(scanStopAction({ exploreId }));\n              }\n            }\n          },\n          error(error) {\n            dispatch(notifyApp(createErrorNotification('Query processing error', error)));\n            dispatch(changeLoadingStateAction({ exploreId, loadingState: LoadingState.Error }));\n            console.error(error);\n          },\n          complete() {\n            // In case we don't get any response at all but the observable completed, make sure we stop loading state.\n            // This is for cases when some queries are noop like running first query after load but we don't have any\n            // actual query input.\n            if (getState().explore[exploreId]!.queryResponse.state === LoadingState.Loading) {\n              dispatch(changeLoadingStateAction({ exploreId, loadingState: LoadingState.Done }));\n            }\n          },\n        });\n\n      if (live) {\n        dispatch(\n          storeLogsVolumeDataProviderAction({\n            exploreId,\n            logsVolumeDataProvider: undefined,\n          })\n        );\n        dispatch(cleanLogsVolumeAction({ exploreId }));\n      } else if (hasLogsVolumeSupport(datasourceInstance)) {\n        const sourceRequest = {\n          ...transaction.request,\n          requestId: transaction.request.requestId + '_log_volume',\n        };\n        const logsVolumeDataProvider = datasourceInstance.getLogsVolumeDataProvider(sourceRequest);\n        dispatch(\n          storeLogsVolumeDataProviderAction({\n            exploreId,\n            logsVolumeDataProvider,\n          })\n        );\n        const { logsVolumeData, absoluteRange } = getState().explore[exploreId]!;\n        if (!canReuseLogsVolumeData(logsVolumeData, queries, absoluteRange)) {\n          dispatch(cleanLogsVolumeAction({ exploreId }));\n          dispatch(loadLogsVolumeData(exploreId));\n        }\n      } else {\n        dispatch(\n          storeLogsVolumeDataProviderAction({\n            exploreId,\n            logsVolumeDataProvider: undefined,\n          })\n        );\n      }\n    }\n\n    dispatch(queryStoreSubscriptionAction({ exploreId, querySubscription: newQuerySub }));\n  };\n};\n\n/**\n * Checks if after changing the time range the existing data can be used to show logs volume.\n * It can happen if queries are the same and new time range is within existing data time range.\n */\nfunction canReuseLogsVolumeData(\n  logsVolumeData: DataQueryResponse | undefined,\n  queries: DataQuery[],\n  selectedTimeRange: AbsoluteTimeRange\n): boolean {\n  if (logsVolumeData && logsVolumeData.data[0]) {\n    // check if queries are the same\n    if (!deepEqual(logsVolumeData.data[0].meta?.custom?.targets, queries)) {\n      return false;\n    }\n    const dataRange = logsVolumeData && logsVolumeData.data[0] && logsVolumeData.data[0].meta?.custom?.absoluteRange;\n    // if selected range is within loaded logs volume\n    if (dataRange && dataRange.from <= selectedTimeRange.from && selectedTimeRange.to <= dataRange.to) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Reset queries to the given queries. Any modifications will be discarded.\n * Use this action for clicks on query examples. Triggers a query run.\n */\nexport function setQueries(exploreId: ExploreId, rawQueries: DataQuery[]): ThunkResult<void> {\n  return (dispatch, getState) => {\n    // Inject react keys into query objects\n    const queries = getState().explore[exploreId]!.queries;\n    const nextQueries = rawQueries.map((query, index) => generateNewKeyAndAddRefIdIfMissing(query, queries, index));\n    dispatch(setQueriesAction({ exploreId, queries: nextQueries }));\n    dispatch(runQueries(exploreId));\n  };\n}\n\n/**\n * Start a scan for more results using the given scanner.\n * @param exploreId Explore area\n * @param scanner Function that a) returns a new time range and b) triggers a query run for the new range\n */\nexport function scanStart(exploreId: ExploreId): ThunkResult<void> {\n  return (dispatch, getState) => {\n    // Register the scanner\n    dispatch(scanStartAction({ exploreId }));\n    // Scanning must trigger query run, and return the new range\n    const range = getShiftedTimeRange(-1, getState().explore[exploreId]!.range);\n    // Set the new range to be displayed\n    dispatch(updateTime({ exploreId, absoluteRange: range }));\n    dispatch(runQueries(exploreId));\n  };\n}\n\nexport function addResultsToCache(exploreId: ExploreId): ThunkResult<void> {\n  return (dispatch, getState) => {\n    const queryResponse = getState().explore[exploreId]!.queryResponse;\n    const absoluteRange = getState().explore[exploreId]!.absoluteRange;\n    const cacheKey = createCacheKey(absoluteRange);\n\n    // Save results to cache only when all results recived and loading is done\n    if (queryResponse.state === LoadingState.Done) {\n      dispatch(addResultsToCacheAction({ exploreId, cacheKey, queryResponse }));\n    }\n  };\n}\n\nexport function clearCache(exploreId: ExploreId): ThunkResult<void> {\n  return (dispatch, getState) => {\n    dispatch(clearCacheAction({ exploreId }));\n  };\n}\n\n/**\n * Initializes loading logs volume data and stores emitted value.\n */\nexport function loadLogsVolumeData(exploreId: ExploreId): ThunkResult<void> {\n  return (dispatch, getState) => {\n    const { logsVolumeDataProvider } = getState().explore[exploreId]!;\n    if (logsVolumeDataProvider) {\n      const logsVolumeDataSubscription = logsVolumeDataProvider.subscribe({\n        next: (logsVolumeData: DataQueryResponse) => {\n          dispatch(updateLogsVolumeDataAction({ exploreId, logsVolumeData }));\n        },\n      });\n      dispatch(storeLogsVolumeDataSubscriptionAction({ exploreId, logsVolumeDataSubscription }));\n    }\n  };\n}\n\n//\n// Reducer\n//\n\n// Redux Toolkit uses ImmerJs as part of their solution to ensure that state objects are not mutated.\n// ImmerJs has an autoFreeze option that freezes objects from change which means this reducer can't be migrated to createSlice\n// because the state would become frozen and during run time we would get errors because flot (Graph lib) would try to mutate\n// the frozen state.\n// https://github.com/reduxjs/redux-toolkit/issues/242\nexport const queryReducer = (state: ExploreItemState, action: AnyAction): ExploreItemState => {\n  if (addQueryRowAction.match(action)) {\n    const { queries } = state;\n    const { index, query } = action.payload;\n\n    // Add to queries, which will cause a new row to be rendered\n    const nextQueries = [...queries.slice(0, index + 1), { ...query }, ...queries.slice(index + 1)];\n\n    return {\n      ...state,\n      queries: nextQueries,\n      queryKeys: getQueryKeys(nextQueries, state.datasourceInstance),\n    };\n  }\n\n  if (changeQueriesAction.match(action)) {\n    const { queries } = action.payload;\n\n    return {\n      ...state,\n      queries,\n    };\n  }\n\n  if (cancelQueriesAction.match(action)) {\n    stopQueryState(state.querySubscription);\n\n    return {\n      ...state,\n      loading: false,\n    };\n  }\n\n  if (modifyQueriesAction.match(action)) {\n    const { queries } = state;\n    const { modification, index, modifier } = action.payload;\n    let nextQueries: DataQuery[];\n    if (index === undefined) {\n      // Modify all queries\n      nextQueries = queries.map((query, i) => {\n        const nextQuery = modifier({ ...query }, modification);\n        return generateNewKeyAndAddRefIdIfMissing(nextQuery, queries, i);\n      });\n    } else {\n      // Modify query only at index\n      nextQueries = queries.map((query, i) => {\n        if (i === index) {\n          const nextQuery = modifier({ ...query }, modification);\n          return generateNewKeyAndAddRefIdIfMissing(nextQuery, queries, i);\n        }\n\n        return query;\n      });\n    }\n    return {\n      ...state,\n      queries: nextQueries,\n      queryKeys: getQueryKeys(nextQueries, state.datasourceInstance),\n    };\n  }\n\n  if (setQueriesAction.match(action)) {\n    const { queries } = action.payload;\n    return {\n      ...state,\n      queries: queries.slice(),\n      queryKeys: getQueryKeys(queries, state.datasourceInstance),\n    };\n  }\n\n  if (queriesImportedAction.match(action)) {\n    const { queries } = action.payload;\n    return {\n      ...state,\n      queries,\n      queryKeys: getQueryKeys(queries, state.datasourceInstance),\n    };\n  }\n\n  if (queryStoreSubscriptionAction.match(action)) {\n    const { querySubscription } = action.payload;\n    return {\n      ...state,\n      querySubscription,\n    };\n  }\n\n  if (storeLogsVolumeDataProviderAction.match(action)) {\n    let { logsVolumeDataProvider } = action.payload;\n    if (state.logsVolumeDataSubscription) {\n      state.logsVolumeDataSubscription.unsubscribe();\n    }\n    return {\n      ...state,\n      logsVolumeDataProvider,\n      logsVolumeDataSubscription: undefined,\n    };\n  }\n\n  if (cleanLogsVolumeAction.match(action)) {\n    return {\n      ...state,\n      logsVolumeData: undefined,\n    };\n  }\n\n  if (storeLogsVolumeDataSubscriptionAction.match(action)) {\n    const { logsVolumeDataSubscription } = action.payload;\n    return {\n      ...state,\n      logsVolumeDataSubscription,\n    };\n  }\n\n  if (updateLogsVolumeDataAction.match(action)) {\n    let { logsVolumeData } = action.payload;\n\n    return {\n      ...state,\n      logsVolumeData,\n    };\n  }\n\n  if (queryStreamUpdatedAction.match(action)) {\n    return processQueryResponse(state, action);\n  }\n\n  if (queriesImportedAction.match(action)) {\n    const { queries } = action.payload;\n    return {\n      ...state,\n      queries,\n      queryKeys: getQueryKeys(queries, state.datasourceInstance),\n    };\n  }\n\n  if (changeLoadingStateAction.match(action)) {\n    const { loadingState } = action.payload;\n    return {\n      ...state,\n      queryResponse: {\n        ...state.queryResponse,\n        state: loadingState,\n      },\n      loading: loadingState === LoadingState.Loading || loadingState === LoadingState.Streaming,\n    };\n  }\n\n  if (setPausedStateAction.match(action)) {\n    const { isPaused } = action.payload;\n    return {\n      ...state,\n      isPaused: isPaused,\n    };\n  }\n\n  if (scanStartAction.match(action)) {\n    return { ...state, scanning: true };\n  }\n\n  if (scanStopAction.match(action)) {\n    return {\n      ...state,\n      scanning: false,\n      scanRange: undefined,\n    };\n  }\n\n  if (addResultsToCacheAction.match(action)) {\n    const CACHE_LIMIT = 5;\n    const { cache } = state;\n    const { queryResponse, cacheKey } = action.payload;\n\n    let newCache = [...cache];\n    const isDuplicateKey = newCache.some((c) => c.key === cacheKey);\n\n    if (!isDuplicateKey) {\n      const newCacheItem = { key: cacheKey, value: queryResponse };\n      newCache = [newCacheItem, ...newCache].slice(0, CACHE_LIMIT);\n    }\n\n    return {\n      ...state,\n      cache: newCache,\n    };\n  }\n\n  if (clearCacheAction.match(action)) {\n    return {\n      ...state,\n      cache: [],\n    };\n  }\n\n  return state;\n};\n\nexport const processQueryResponse = (\n  state: ExploreItemState,\n  action: PayloadAction<QueryEndedPayload>\n): ExploreItemState => {\n  const { response } = action.payload;\n  const {\n    request,\n    state: loadingState,\n    series,\n    error,\n    graphResult,\n    logsResult,\n    tableResult,\n    traceFrames,\n    nodeGraphFrames,\n  } = response;\n\n  if (error) {\n    if (error.type === DataQueryErrorType.Timeout) {\n      return {\n        ...state,\n        queryResponse: response,\n        loading: loadingState === LoadingState.Loading || loadingState === LoadingState.Streaming,\n      };\n    } else if (error.type === DataQueryErrorType.Cancelled) {\n      return state;\n    }\n\n    // Send error to Angular editors\n    // When angularSupportEnabled is removed we can remove this code and all references to eventBridge\n    if (config.angularSupportEnabled && state.datasourceInstance?.components?.QueryCtrl) {\n      state.eventBridge.emit(PanelEvents.dataError, error);\n    }\n  }\n\n  if (!request) {\n    return { ...state };\n  }\n\n  // Send legacy data to Angular editors\n  // When angularSupportEnabled is removed we can remove this code and all references to eventBridge\n  if (config.angularSupportEnabled && state.datasourceInstance?.components?.QueryCtrl) {\n    const legacy = series.map((v) => toLegacyResponseData(v));\n    state.eventBridge.emit(PanelEvents.dataReceived, legacy);\n  }\n\n  return {\n    ...state,\n    queryResponse: response,\n    graphResult,\n    tableResult,\n    logsResult,\n    loading: loadingState === LoadingState.Loading || loadingState === LoadingState.Streaming,\n    showLogs: !!logsResult,\n    showMetrics: !!graphResult,\n    showTable: !!tableResult,\n    showTrace: !!traceFrames.length,\n    showNodeGraph: !!nodeGraphFrames.length,\n  };\n};\n"],"mappings":";;;;AAAA,SAAoBA,YAApB,QAAuD,kBAAvD;AACA,OAAOC,SAAP,MAAsB,iBAAtB;AACA,SAASC,QAAT,EAA+BC,EAA/B,QAA2E,MAA3E;AACA,SAASC,QAAT,EAAmBC,YAAnB,QAAuC,gBAAvC;AAEA,SAEEC,OAFF,EAIEC,kBAJF,EAOEC,oBAPF,EAQEC,qBARF,EASEC,qBATF,EAWEC,YAXF,EAaEC,WAbF,EAeEC,oBAfF,QAgBO,eAhBP;AAiBA,SAASC,MAAT,EAAiBC,iBAAjB,QAA0C,kBAA1C;AACA,SACEC,qBADF,EAEEC,aAFF,EAGEC,kBAHF,EAIEC,kCAJF,EAKEC,YALF,EAMEC,gBANF,EAOEC,cAPF,EAQEC,aARF,QASO,wBATP;AAUA,SAASC,mBAAT,QAAoC,2BAApC;AACA,SAASC,WAAT,QAA4B,sCAA5B;AAEA,SAASC,SAAT,QAAsD,mBAAtD;AAEA,SAASC,SAAT,QAA0B,uBAA1B;AACA,SAASC,uBAAT,QAAwC,oCAAxC;AACA,SAASC,UAAT,QAA2B,8BAA3B;AACA,SAASC,YAAT,QAA6B,qBAA7B;AAEA,SAASC,cAAT,EAAyBC,oBAAzB,EAA+CC,eAA/C,QAAsE,WAAtE;AACA,SAASC,SAAT,QAA0B,QAA1B;AACA,SAASC,UAAT,QAA2B,QAA3B;AACA,SAASC,cAAT,EAAyBC,mBAAzB,QAAoD,SAApD,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;;AAMA,OAAO,MAAMC,iBAAiB,GAAGtC,YAAY,CAAqB,qBAArB,CAAtC;AAEP;AACA;AACA;AACA;;AAKA,OAAO,MAAMuC,mBAAmB,GAAGvC,YAAY,CAAuB,uBAAvB,CAAxC;AAEP;AACA;AACA;;AAIA,OAAO,MAAMwC,mBAAmB,GAAGxC,YAAY,CAAuB,uBAAvB,CAAxC;AAMP,OAAO,MAAMyC,qBAAqB,GAAGzC,YAAY,CAAyB,yBAAzB,CAA1C;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAOA,OAAO,MAAM0C,mBAAmB,GAAG1C,YAAY,CAAuB,uBAAvB,CAAxC;AAOP,OAAO,MAAM2C,4BAA4B,GAAG3C,YAAY,CACtD,gCADsD,CAAjD;;AASP;AACA;AACA;AACA,OAAO,MAAM4C,iCAAiC,GAAG5C,YAAY,CAC3D,2CAD2D,CAAtD;AAIP,OAAO,MAAM6C,qBAAqB,GAAG7C,YAAY,CAA2B,+BAA3B,CAA1C;;AAOP;AACA;AACA;AACA,MAAM8C,qCAAqC,GAAG9C,YAAY,CACxD,+CADwD,CAA1D;AAIA;AACA;AACA;;AACA,MAAM+C,0BAA0B,GAAG/C,YAAY,CAG5C,oCAH4C,CAA/C;AASA,OAAO,MAAMgD,wBAAwB,GAAGhD,YAAY,CAAoB,4BAApB,CAA7C;AAEP;AACA;AACA;AACA;;AAKA,OAAO,MAAMiD,gBAAgB,GAAGjD,YAAY,CAAoB,oBAApB,CAArC;AAMP,OAAO,MAAMkD,wBAAwB,GAAGlD,YAAY,CAA4B,oBAA5B,CAA7C;AAMP,OAAO,MAAMmD,oBAAoB,GAAGnD,YAAY,CAAwB,wBAAxB,CAAzC;AAEP;AACA;AACA;AACA;AACA;;AAIA,OAAO,MAAMoD,eAAe,GAAGpD,YAAY,CAAmB,mBAAnB,CAApC;AAEP;AACA;AACA;;AAIA,OAAO,MAAMqD,cAAc,GAAGrD,YAAY,CAAkB,kBAAlB,CAAnC;AAEP;AACA;AACA;AACA;;AAMA,OAAO,MAAMsD,uBAAuB,GAAGtD,YAAY,CAA2B,2BAA3B,CAA5C;AAEP;AACA;AACA;;AAIA,OAAO,MAAMuD,gBAAgB,GAAGvD,YAAY,CAAoB,oBAApB,CAArC,C,CAEP;AACA;AACA;;AAEA;AACA;AACA;;AACA,OAAO,SAASwD,WAAT,CACLC,SADK,EAELC,KAFK,EAGLC,UAHK,EAIc;EACnB,OAAO,CAACC,QAAD,EAAWC,QAAX,KAAwB;IAAA;;IAC7B,MAAMC,OAAO,GAAGD,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,EAA+BK,OAA/C;IACA,MAAME,KAAK,qBACNL,UADM,aACNA,UADM,gDACNA,UAAU,CAAEM,eADN,0DACN,2BAAAN,UAAU,EAAoBrD,OAAO,CAAC4D,OAA5B,CADJ,EAENhD,kBAAkB,CAAC4C,OAAD,EAAUJ,KAAV,CAFZ,CAAX;IAKAE,QAAQ,CAACtB,iBAAiB,CAAC;MAAEmB,SAAF;MAAaC,KAAb;MAAoBM;IAApB,CAAD,CAAlB,CAAR;EACD,CARD;AASD;AAED;AACA;AACA;;AACA,OAAO,SAASG,aAAT,CAAuBV,SAAvB,EAAgE;EACrE,OAAO,CAACG,QAAD,EAAWC,QAAX,KAAwB;IAAA;;IAC7BD,QAAQ,CAACP,cAAc,CAAC;MAAEI;IAAF,CAAD,CAAf,CAAR;IACAG,QAAQ,CAACpB,mBAAmB,CAAC;MAAEiB;IAAF,CAAD,CAApB,CAAR;IACAG,QAAQ,CACNhB,iCAAiC,CAAC;MAChCa,SADgC;MAEhCW,sBAAsB,EAAEC;IAFQ,CAAD,CAD3B,CAAR,CAH6B,CAS7B;;IACA,IAAI,oBAAAR,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,EAA+Ba,cAA/B,oEAA+CC,KAA/C,MAAyD5D,YAAY,CAAC6D,IAA1E,EAAgF;MAC9EZ,QAAQ,CAACf,qBAAqB,CAAC;QAAEY;MAAF,CAAD,CAAtB,CAAR;IACD;;IACDG,QAAQ,CAAC1B,SAAS,EAAV,CAAR;EACD,CAdD;AAeD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMuC,aAAa,GAAG,CAC3BhB,SAD2B,EAE3BK,OAF2B,EAG3BY,gBAH2B,EAI3BC,gBAJ2B,KAKL;EACtB,OAAO,MAAOf,QAAP,IAAoB;IAAA;;IACzB,IAAI,CAACc,gBAAL,EAAuB;MACrB;MACAd,QAAQ,CAACnB,qBAAqB,CAAC;QAAEgB,SAAF;QAAaK;MAAb,CAAD,CAAtB,CAAR;MACA;IACD;;IAED,IAAIc,eAAe,GAAGd,OAAtB,CAPyB,CAQzB;;IACA,IAAI,0BAAAY,gBAAgB,CAACG,IAAjB,gFAAuBC,EAAvB,gCAA8BH,gBAAgB,CAACE,IAA/C,0DAA8B,sBAAuBC,EAArD,CAAJ,EAA6D;MAC3D;MACAF,eAAe,GAAGd,OAAO,CAACiB,GAAR,CAAY;QAAA,IAAkBf,KAAlB;;QAAA,OAA8BA,KAA9B;MAAA,CAAZ,CAAlB;IACD,CAHD,MAGO,IAAIvD,qBAAqB,CAACiE,gBAAD,CAArB,IAA2ChE,qBAAqB,CAACiE,gBAAD,CAApE,EAAwF;MAC7F,MAAMK,eAAe,GAAG,MAAMN,gBAAgB,CAACO,uBAAjB,CAAyCnB,OAAzC,CAA9B;MACAc,eAAe,GAAG,MAAMD,gBAAgB,CAACO,yBAAjB,CAA2CF,eAA3C,CAAxB;IACD,CAHM,MAGA,IAAIL,gBAAgB,CAACF,aAArB,EAAoC;MACzC;MACAG,eAAe,GAAG,MAAMD,gBAAgB,CAACF,aAAjB,CAA+BX,OAA/B,EAAwCY,gBAAxC,CAAxB;IACD,CAHM,MAGA;MACL;MACAE,eAAe,GAAG3D,aAAa,EAA/B;IACD;;IAED,MAAMkE,WAAW,GAAGlE,aAAa,CAAC2D,eAAD,CAAjC;IAEAhB,QAAQ,CAACnB,qBAAqB,CAAC;MAAEgB,SAAF;MAAaK,OAAO,EAAEqB;IAAtB,CAAD,CAAtB,CAAR;EACD,CA1BD;AA2BD,CAjCM;AAmCP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,aAAT,CACL3B,SADK,EAEL4B,YAFK,EAGLC,QAHK,EAIL5B,KAJK,EAKc;EACnB,OAAQE,QAAD,IAAc;IACnBA,QAAQ,CAAClB,mBAAmB,CAAC;MAAEe,SAAF;MAAa4B,YAAb;MAA2B3B,KAA3B;MAAkC4B;IAAlC,CAAD,CAApB,CAAR;;IACA,IAAI,CAACD,YAAY,CAACE,aAAlB,EAAiC;MAC/B3B,QAAQ,CAAC4B,UAAU,CAAC/B,SAAD,CAAX,CAAR;IACD;EACF,CALD;AAMD;;AAED,eAAegC,aAAf,CACE7B,QADF,EAEEW,KAFF,EAGEmB,OAHF,EAIE/B,UAJF,EAKEG,OALF,EAMEL,SANF,EAOE;EACA,MAAMkC,YAAY,GAAGhC,UAAU,CAACkB,IAAX,CAAgBC,EAArC;EACA,MAAMc,WAAW,GAAGrE,aAAa,CAACmE,OAAD,EAAUC,YAAV,EAAwB7B,OAAxB,CAAjC;EACAF,QAAQ,CAAC5B,oBAAoB,CAAC;IAAEyB,SAAF;IAAaiC,OAAO,EAAEE;EAAtB,CAAD,CAArB,CAAR;EAEAhC,QAAQ,CAAC7B,cAAc,CAAC4B,UAAU,CAACkC,GAAZ,EAAiBlC,UAAU,CAACmC,IAA5B,EAAkChC,OAAlC,CAAf,CAAR,CALA,CAOA;EACA;EACA;;EACA,MAAMF,QAAQ,CAAC3B,eAAe,CAACP,SAAS,CAACqE,IAAX,CAAhB,CAAd;EACA,MAAMnC,QAAQ,CAAC3B,eAAe,CAACP,SAAS,CAACsE,KAAX,CAAhB,CAAd;AACD;AAED;AACA;AACA;;;AACA,OAAO,MAAMR,UAAU,GAAG,CACxB/B,SADwB,EAExBwC,OAFwB,KAGF;EACtB,OAAO,CAACrC,QAAD,EAAWC,QAAX,KAAwB;IAC7BD,QAAQ,CAACzB,UAAU,CAAC;MAAEsB;IAAF,CAAD,CAAX,CAAR,CAD6B,CAG7B;;IACA,MAAMyC,aAAa,GAAG,CAAAD,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEC,aAAT,MAA2B,IAAjD;;IACA,IAAI,CAACA,aAAL,EAAoB;MAClBtC,QAAQ,CAACuC,UAAU,CAAC1C,SAAD,CAAX,CAAR;IACD;;IAED,MAAM2C,gBAAgB,GAAGvC,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,CAAzB;IACA,MAAM;MACJ4C,kBADI;MAEJC,cAFI;MAGJC,MAAM,EAAEC,IAHJ;MAIJC,KAJI;MAKJC,QALI;MAMJC,aANI;MAOJC,iBAPI;MAQJC,eARI;MASJC,aATI;MAUJC;IAVI,IAWFX,gBAXJ;IAYA,IAAIY,WAAJ;IAEA,MAAMlD,OAAO,GAAGsC,gBAAgB,CAACtC,OAAjB,CAAyBiB,GAAzB,CAA8Bf,KAAD,sBACxCA,KADwC;MAE3CL,UAAU,EAAEK,KAAK,CAACL,UAAN,KAAoB0C,kBAApB,aAAoBA,kBAApB,uBAAoBA,kBAAkB,CAAEY,MAApB,EAApB;IAF+B,EAA7B,CAAhB;;IAKA,IAAIZ,kBAAkB,IAAI,IAA1B,EAAgC;MAC9BZ,aAAa,CAAC7B,QAAD,EAAWC,QAAQ,GAAGE,OAAtB,EAA+BqC,gBAAgB,CAACV,OAAhD,EAAyDW,kBAAzD,EAA6EvC,OAA7E,EAAsFL,SAAtF,CAAb;IACD;;IAEDG,QAAQ,CAAC1B,SAAS,CAAC;MAAEgF,OAAO,EAAEjB,OAAF,aAAEA,OAAF,uBAAEA,OAAO,CAAEkB;IAApB,CAAD,CAAV,CAAR;IAEA,MAAMC,WAAW,GAAG/E,mBAAmB,CAAC0E,KAAD,EAAQD,aAAR,CAAvC,CAnC6B,CAqC7B;;IACA,IAAIM,WAAJ,EAAiB;MACfJ,WAAW,GAAG7G,EAAE,CAACiH,WAAD,CAAF,CACXC,IADW,CAEVjH,QAAQ,CAAEkH,IAAD,IACPxF,YAAY,CACVwF,IADU,EAEVX,aAFU,EAGVG,aAHU,EAIVD,eAJU,EAKV/C,OALU,EAMVuC,kBAAkB,IAAI,IAAtB,IAA8B7F,oBAAoB,CAAC6F,kBAAD,CANxC,CADN,CAFE,EAaXkB,SAbW,CAaAD,IAAD,IAAU;QACnB,IAAI,CAACA,IAAI,CAACE,KAAV,EAAiB;UACf5D,QAAQ,CAAC1B,SAAS,EAAV,CAAR;QACD;;QAED0B,QAAQ,CAACZ,wBAAwB,CAAC;UAAES,SAAF;UAAagE,QAAQ,EAAEH;QAAvB,CAAD,CAAzB,CAAR;MACD,CAnBW,CAAd,CADe,CAsBf;IACD,CAvBD,MAuBO;MACL,IAAI,CAACjG,gBAAgB,CAACyC,OAAD,CAArB,EAAgC;QAC9BF,QAAQ,CAAC1B,SAAS,CAAC;UAAEgF,OAAO,EAAEjB,OAAF,aAAEA,OAAF,uBAAEA,OAAO,CAAEkB;QAApB,CAAD,CAAV,CAAR,CAD8B,CACyB;;QACvD;MACD;;MAED,IAAI,CAACd,kBAAL,EAAyB;QACvB;MACD,CARI,CAUL;MACA;;;MACA,MAAMqB,WAAW,GAAGrB,kBAAH,aAAGA,kBAAH,uBAAGA,kBAAkB,CAAEsB,QAAxC;MAEArG,cAAc,CAACsF,iBAAD,CAAd;MAEA,MAAMgB,YAA0B,GAAG;QACjCF,WADiC;QAEjC;QACA;QACA;QACA;QACA;QACA;QACAG,aAAa,EAAEvB,cARkB;QASjCwB,aAAa,EAAEtB;MATkB,CAAnC;MAYA,MAAMuB,QAAQ,GAAGtG,WAAW,CAACoC,QAAQ,GAAGmE,IAAZ,CAA5B;MACA,MAAMC,WAAW,GAAGjH,qBAAqB,CAACyC,SAAD,EAAYK,OAAZ,EAAqB8D,YAArB,EAAmCnB,KAAnC,EAA0CC,QAA1C,EAAoDqB,QAApD,CAAzC;MAEAnE,QAAQ,CAACV,wBAAwB,CAAC;QAAEO,SAAF;QAAayE,YAAY,EAAEvH,YAAY,CAACwH;MAAxC,CAAD,CAAzB,CAAR;MAEAnB,WAAW,GAAGnF,UAAU,CAACwE,kBAAD,EAAqB4B,WAAW,CAACG,OAAjC,CAAV,CACXf,IADW,EAEV;MACA;MACA;MACAb,IAAI,GAAGnG,YAAY,CAAC,GAAD,CAAf,GAAuBH,QALjB,EAMVE,QAAQ,CAAEkH,IAAD,IACPxF,YAAY,CACVwF,IADU,EAEVX,aAFU,EAGVG,aAHU,EAIVD,eAJU,EAKV/C,OALU,EAMVuC,kBAAkB,IAAI,IAAtB,IAA8B7F,oBAAoB,CAAC6F,kBAAD,CANxC,CADN,CANE,EAiBXkB,SAjBW,CAiBD;QACTc,IAAI,CAACf,IAAD,EAAO;UACT,IAAIA,IAAI,CAACgB,UAAL,KAAoB,IAAxB,EAA8B;YAC5BvH,iBAAiB,CAAC,uCAAD,EAA0C;cACzDwH,cAAc,EAAElC,kBAAkB,CAACmC;YADsB,CAA1C,CAAjB;UAGD;;UACD5E,QAAQ,CAACZ,wBAAwB,CAAC;YAAES,SAAF;YAAagE,QAAQ,EAAEH;UAAvB,CAAD,CAAzB,CAAR,CANS,CAQT;;UACA,IAAIzD,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,EAA+BiD,QAAnC,EAA6C;YAC3C,IAAIY,IAAI,CAAC/C,KAAL,KAAe5D,YAAY,CAAC6D,IAA5B,IAAoC8C,IAAI,CAACmB,MAAL,CAAYC,MAAZ,KAAuB,CAA/D,EAAkE;cAChE,MAAMjC,KAAK,GAAGjF,mBAAmB,CAAC,CAAC,CAAF,EAAKqC,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,EAA+BgD,KAApC,CAAjC;cACA7C,QAAQ,CAACzB,UAAU,CAAC;gBAAEsB,SAAF;gBAAaqD,aAAa,EAAEL;cAA5B,CAAD,CAAX,CAAR;cACA7C,QAAQ,CAAC4B,UAAU,CAAC/B,SAAD,CAAX,CAAR;YACD,CAJD,MAIO;cACL;cACAG,QAAQ,CAACP,cAAc,CAAC;gBAAEI;cAAF,CAAD,CAAf,CAAR;YACD;UACF;QACF,CApBQ;;QAqBT+D,KAAK,CAACA,KAAD,EAAQ;UACX5D,QAAQ,CAACjC,SAAS,CAACC,uBAAuB,CAAC,wBAAD,EAA2B4F,KAA3B,CAAxB,CAAV,CAAR;UACA5D,QAAQ,CAACV,wBAAwB,CAAC;YAAEO,SAAF;YAAayE,YAAY,EAAEvH,YAAY,CAACgI;UAAxC,CAAD,CAAzB,CAAR;UACAC,OAAO,CAACpB,KAAR,CAAcA,KAAd;QACD,CAzBQ;;QA0BTqB,QAAQ,GAAG;UACT;UACA;UACA;UACA,IAAIhF,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,EAA+BkD,aAA/B,CAA6CpC,KAA7C,KAAuD5D,YAAY,CAACwH,OAAxE,EAAiF;YAC/EvE,QAAQ,CAACV,wBAAwB,CAAC;cAAEO,SAAF;cAAayE,YAAY,EAAEvH,YAAY,CAAC6D;YAAxC,CAAD,CAAzB,CAAR;UACD;QACF;;MAjCQ,CAjBC,CAAd;;MAqDA,IAAIgC,IAAJ,EAAU;QACR5C,QAAQ,CACNhB,iCAAiC,CAAC;UAChCa,SADgC;UAEhCW,sBAAsB,EAAEC;QAFQ,CAAD,CAD3B,CAAR;QAMAT,QAAQ,CAACf,qBAAqB,CAAC;UAAEY;QAAF,CAAD,CAAtB,CAAR;MACD,CARD,MAQO,IAAIjD,oBAAoB,CAAC6F,kBAAD,CAAxB,EAA8C;QACnD,MAAMyC,aAAa,qBACdb,WAAW,CAACG,OADE;UAEjBW,SAAS,EAAEd,WAAW,CAACG,OAAZ,CAAoBW,SAApB,GAAgC;QAF1B,EAAnB;QAIA,MAAM3E,sBAAsB,GAAGiC,kBAAkB,CAAC2C,yBAAnB,CAA6CF,aAA7C,CAA/B;QACAlF,QAAQ,CACNhB,iCAAiC,CAAC;UAChCa,SADgC;UAEhCW;QAFgC,CAAD,CAD3B,CAAR;QAMA,MAAM;UAAEE,cAAF;UAAkBwC;QAAlB,IAAoCjD,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,CAA1C;;QACA,IAAI,CAACwF,sBAAsB,CAAC3E,cAAD,EAAiBR,OAAjB,EAA0BgD,aAA1B,CAA3B,EAAqE;UACnElD,QAAQ,CAACf,qBAAqB,CAAC;YAAEY;UAAF,CAAD,CAAtB,CAAR;UACAG,QAAQ,CAACsF,kBAAkB,CAACzF,SAAD,CAAnB,CAAR;QACD;MACF,CAjBM,MAiBA;QACLG,QAAQ,CACNhB,iCAAiC,CAAC;UAChCa,SADgC;UAEhCW,sBAAsB,EAAEC;QAFQ,CAAD,CAD3B,CAAR;MAMD;IACF;;IAEDT,QAAQ,CAACjB,4BAA4B,CAAC;MAAEc,SAAF;MAAamD,iBAAiB,EAAEI;IAAhC,CAAD,CAA7B,CAAR;EACD,CAvLD;AAwLD,CA5LM;AA8LP;AACA;AACA;AACA;;AACA,SAASiC,sBAAT,CACE3E,cADF,EAEER,OAFF,EAGEqF,iBAHF,EAIW;EACT,IAAI7E,cAAc,IAAIA,cAAc,CAACgD,IAAf,CAAoB,CAApB,CAAtB,EAA8C;IAAA;;IAC5C;IACA,IAAI,CAACrH,SAAS,0BAACqE,cAAc,CAACgD,IAAf,CAAoB,CAApB,EAAuBzC,IAAxB,oFAAC,sBAA6BuE,MAA9B,2DAAC,uBAAqCC,OAAtC,EAA+CvF,OAA/C,CAAd,EAAuE;MACrE,OAAO,KAAP;IACD;;IACD,MAAMwF,SAAS,GAAGhF,cAAc,IAAIA,cAAc,CAACgD,IAAf,CAAoB,CAApB,CAAlB,+BAA4ChD,cAAc,CAACgD,IAAf,CAAoB,CAApB,EAAuBzC,IAAnE,qFAA4C,uBAA6BuE,MAAzE,2DAA4C,uBAAqCtC,aAAjF,CAAlB,CAL4C,CAM5C;;IACA,IAAIwC,SAAS,IAAIA,SAAS,CAACC,IAAV,IAAkBJ,iBAAiB,CAACI,IAAjD,IAAyDJ,iBAAiB,CAACK,EAAlB,IAAwBF,SAAS,CAACE,EAA/F,EAAmG;MACjG,OAAO,IAAP;IACD;EACF;;EACD,OAAO,KAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,OAAO,SAASC,UAAT,CAAoBhG,SAApB,EAA0CiG,UAA1C,EAAsF;EAC3F,OAAO,CAAC9F,QAAD,EAAWC,QAAX,KAAwB;IAC7B;IACA,MAAMC,OAAO,GAAGD,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,EAA+BK,OAA/C;IACA,MAAMqB,WAAW,GAAGuE,UAAU,CAAC3E,GAAX,CAAe,CAACf,KAAD,EAAQN,KAAR,KAAkBvC,kCAAkC,CAAC6C,KAAD,EAAQF,OAAR,EAAiBJ,KAAjB,CAAnE,CAApB;IACAE,QAAQ,CAACX,gBAAgB,CAAC;MAAEQ,SAAF;MAAaK,OAAO,EAAEqB;IAAtB,CAAD,CAAjB,CAAR;IACAvB,QAAQ,CAAC4B,UAAU,CAAC/B,SAAD,CAAX,CAAR;EACD,CAND;AAOD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASkG,SAAT,CAAmBlG,SAAnB,EAA4D;EACjE,OAAO,CAACG,QAAD,EAAWC,QAAX,KAAwB;IAC7B;IACAD,QAAQ,CAACR,eAAe,CAAC;MAAEK;IAAF,CAAD,CAAhB,CAAR,CAF6B,CAG7B;;IACA,MAAMgD,KAAK,GAAGjF,mBAAmB,CAAC,CAAC,CAAF,EAAKqC,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,EAA+BgD,KAApC,CAAjC,CAJ6B,CAK7B;;IACA7C,QAAQ,CAACzB,UAAU,CAAC;MAAEsB,SAAF;MAAaqD,aAAa,EAAEL;IAA5B,CAAD,CAAX,CAAR;IACA7C,QAAQ,CAAC4B,UAAU,CAAC/B,SAAD,CAAX,CAAR;EACD,CARD;AASD;AAED,OAAO,SAASmG,iBAAT,CAA2BnG,SAA3B,EAAoE;EACzE,OAAO,CAACG,QAAD,EAAWC,QAAX,KAAwB;IAC7B,MAAM8C,aAAa,GAAG9C,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,EAA+BkD,aAArD;IACA,MAAMG,aAAa,GAAGjD,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,EAA+BqD,aAArD;IACA,MAAM+C,QAAQ,GAAGzH,cAAc,CAAC0E,aAAD,CAA/B,CAH6B,CAK7B;;IACA,IAAIH,aAAa,CAACpC,KAAd,KAAwB5D,YAAY,CAAC6D,IAAzC,EAA+C;MAC7CZ,QAAQ,CAACN,uBAAuB,CAAC;QAAEG,SAAF;QAAaoG,QAAb;QAAuBlD;MAAvB,CAAD,CAAxB,CAAR;IACD;EACF,CATD;AAUD;AAED,OAAO,SAASR,UAAT,CAAoB1C,SAApB,EAA6D;EAClE,OAAO,CAACG,QAAD,EAAWC,QAAX,KAAwB;IAC7BD,QAAQ,CAACL,gBAAgB,CAAC;MAAEE;IAAF,CAAD,CAAjB,CAAR;EACD,CAFD;AAGD;AAED;AACA;AACA;;AACA,OAAO,SAASyF,kBAAT,CAA4BzF,SAA5B,EAAqE;EAC1E,OAAO,CAACG,QAAD,EAAWC,QAAX,KAAwB;IAC7B,MAAM;MAAEO;IAAF,IAA6BP,QAAQ,GAAGE,OAAX,CAAmBN,SAAnB,CAAnC;;IACA,IAAIW,sBAAJ,EAA4B;MAC1B,MAAM0F,0BAA0B,GAAG1F,sBAAsB,CAACmD,SAAvB,CAAiC;QAClEc,IAAI,EAAG/D,cAAD,IAAuC;UAC3CV,QAAQ,CAACb,0BAA0B,CAAC;YAAEU,SAAF;YAAaa;UAAb,CAAD,CAA3B,CAAR;QACD;MAHiE,CAAjC,CAAnC;MAKAV,QAAQ,CAACd,qCAAqC,CAAC;QAAEW,SAAF;QAAaqG;MAAb,CAAD,CAAtC,CAAR;IACD;EACF,CAVD;AAWD,C,CAED;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,YAAY,GAAG,CAACxF,KAAD,EAA0ByF,MAA1B,KAAkE;EAC5F,IAAI1H,iBAAiB,CAAC2H,KAAlB,CAAwBD,MAAxB,CAAJ,EAAqC;IACnC,MAAM;MAAElG;IAAF,IAAcS,KAApB;IACA,MAAM;MAAEb,KAAF;MAASM;IAAT,IAAmBgG,MAAM,CAACE,OAAhC,CAFmC,CAInC;;IACA,MAAM/E,WAAW,GAAG,CAAC,GAAGrB,OAAO,CAACqG,KAAR,CAAc,CAAd,EAAiBzG,KAAK,GAAG,CAAzB,CAAJ,oBAAsCM,KAAtC,GAA+C,GAAGF,OAAO,CAACqG,KAAR,CAAczG,KAAK,GAAG,CAAtB,CAAlD,CAApB;IAEA,yBACKa,KADL;MAEET,OAAO,EAAEqB,WAFX;MAGEiF,SAAS,EAAEhJ,YAAY,CAAC+D,WAAD,EAAcZ,KAAK,CAAC8B,kBAApB;IAHzB;EAKD;;EAED,IAAI9D,mBAAmB,CAAC0H,KAApB,CAA0BD,MAA1B,CAAJ,EAAuC;IACrC,MAAM;MAAElG;IAAF,IAAckG,MAAM,CAACE,OAA3B;IAEA,yBACK3F,KADL;MAEET;IAFF;EAID;;EAED,IAAItB,mBAAmB,CAACyH,KAApB,CAA0BD,MAA1B,CAAJ,EAAuC;IACrC1I,cAAc,CAACiD,KAAK,CAACqC,iBAAP,CAAd;IAEA,yBACKrC,KADL;MAEE8F,OAAO,EAAE;IAFX;EAID;;EAED,IAAI3H,mBAAmB,CAACuH,KAApB,CAA0BD,MAA1B,CAAJ,EAAuC;IACrC,MAAM;MAAElG;IAAF,IAAcS,KAApB;IACA,MAAM;MAAEc,YAAF;MAAgB3B,KAAhB;MAAuB4B;IAAvB,IAAoC0E,MAAM,CAACE,OAAjD;IACA,IAAI/E,WAAJ;;IACA,IAAIzB,KAAK,KAAKW,SAAd,EAAyB;MACvB;MACAc,WAAW,GAAGrB,OAAO,CAACiB,GAAR,CAAY,CAACf,KAAD,EAAQsG,CAAR,KAAc;QACtC,MAAMC,SAAS,GAAGjF,QAAQ,mBAAMtB,KAAN,GAAeqB,YAAf,CAA1B;QACA,OAAOlE,kCAAkC,CAACoJ,SAAD,EAAYzG,OAAZ,EAAqBwG,CAArB,CAAzC;MACD,CAHa,CAAd;IAID,CAND,MAMO;MACL;MACAnF,WAAW,GAAGrB,OAAO,CAACiB,GAAR,CAAY,CAACf,KAAD,EAAQsG,CAAR,KAAc;QACtC,IAAIA,CAAC,KAAK5G,KAAV,EAAiB;UACf,MAAM6G,SAAS,GAAGjF,QAAQ,mBAAMtB,KAAN,GAAeqB,YAAf,CAA1B;UACA,OAAOlE,kCAAkC,CAACoJ,SAAD,EAAYzG,OAAZ,EAAqBwG,CAArB,CAAzC;QACD;;QAED,OAAOtG,KAAP;MACD,CAPa,CAAd;IAQD;;IACD,yBACKO,KADL;MAEET,OAAO,EAAEqB,WAFX;MAGEiF,SAAS,EAAEhJ,YAAY,CAAC+D,WAAD,EAAcZ,KAAK,CAAC8B,kBAApB;IAHzB;EAKD;;EAED,IAAIpD,gBAAgB,CAACgH,KAAjB,CAAuBD,MAAvB,CAAJ,EAAoC;IAClC,MAAM;MAAElG;IAAF,IAAckG,MAAM,CAACE,OAA3B;IACA,yBACK3F,KADL;MAEET,OAAO,EAAEA,OAAO,CAACqG,KAAR,EAFX;MAGEC,SAAS,EAAEhJ,YAAY,CAAC0C,OAAD,EAAUS,KAAK,CAAC8B,kBAAhB;IAHzB;EAKD;;EAED,IAAI5D,qBAAqB,CAACwH,KAAtB,CAA4BD,MAA5B,CAAJ,EAAyC;IACvC,MAAM;MAAElG;IAAF,IAAckG,MAAM,CAACE,OAA3B;IACA,yBACK3F,KADL;MAEET,OAFF;MAGEsG,SAAS,EAAEhJ,YAAY,CAAC0C,OAAD,EAAUS,KAAK,CAAC8B,kBAAhB;IAHzB;EAKD;;EAED,IAAI1D,4BAA4B,CAACsH,KAA7B,CAAmCD,MAAnC,CAAJ,EAAgD;IAC9C,MAAM;MAAEpD;IAAF,IAAwBoD,MAAM,CAACE,OAArC;IACA,yBACK3F,KADL;MAEEqC;IAFF;EAID;;EAED,IAAIhE,iCAAiC,CAACqH,KAAlC,CAAwCD,MAAxC,CAAJ,EAAqD;IACnD,IAAI;MAAE5F;IAAF,IAA6B4F,MAAM,CAACE,OAAxC;;IACA,IAAI3F,KAAK,CAACuF,0BAAV,EAAsC;MACpCvF,KAAK,CAACuF,0BAAN,CAAiCU,WAAjC;IACD;;IACD,yBACKjG,KADL;MAEEH,sBAFF;MAGE0F,0BAA0B,EAAEzF;IAH9B;EAKD;;EAED,IAAIxB,qBAAqB,CAACoH,KAAtB,CAA4BD,MAA5B,CAAJ,EAAyC;IACvC,yBACKzF,KADL;MAEED,cAAc,EAAED;IAFlB;EAID;;EAED,IAAIvB,qCAAqC,CAACmH,KAAtC,CAA4CD,MAA5C,CAAJ,EAAyD;IACvD,MAAM;MAAEF;IAAF,IAAiCE,MAAM,CAACE,OAA9C;IACA,yBACK3F,KADL;MAEEuF;IAFF;EAID;;EAED,IAAI/G,0BAA0B,CAACkH,KAA3B,CAAiCD,MAAjC,CAAJ,EAA8C;IAC5C,IAAI;MAAE1F;IAAF,IAAqB0F,MAAM,CAACE,OAAhC;IAEA,yBACK3F,KADL;MAEED;IAFF;EAID;;EAED,IAAItB,wBAAwB,CAACiH,KAAzB,CAA+BD,MAA/B,CAAJ,EAA4C;IAC1C,OAAOS,oBAAoB,CAAClG,KAAD,EAAQyF,MAAR,CAA3B;EACD;;EAED,IAAIvH,qBAAqB,CAACwH,KAAtB,CAA4BD,MAA5B,CAAJ,EAAyC;IACvC,MAAM;MAAElG;IAAF,IAAckG,MAAM,CAACE,OAA3B;IACA,yBACK3F,KADL;MAEET,OAFF;MAGEsG,SAAS,EAAEhJ,YAAY,CAAC0C,OAAD,EAAUS,KAAK,CAAC8B,kBAAhB;IAHzB;EAKD;;EAED,IAAInD,wBAAwB,CAAC+G,KAAzB,CAA+BD,MAA/B,CAAJ,EAA4C;IAC1C,MAAM;MAAE9B;IAAF,IAAmB8B,MAAM,CAACE,OAAhC;IACA,yBACK3F,KADL;MAEEoC,aAAa,oBACRpC,KAAK,CAACoC,aADE;QAEXpC,KAAK,EAAE2D;MAFI,EAFf;MAMEmC,OAAO,EAAEnC,YAAY,KAAKvH,YAAY,CAACwH,OAA9B,IAAyCD,YAAY,KAAKvH,YAAY,CAAC+J;IANlF;EAQD;;EAED,IAAIvH,oBAAoB,CAAC8G,KAArB,CAA2BD,MAA3B,CAAJ,EAAwC;IACtC,MAAM;MAAEW;IAAF,IAAeX,MAAM,CAACE,OAA5B;IACA,yBACK3F,KADL;MAEEoG,QAAQ,EAAEA;IAFZ;EAID;;EAED,IAAIvH,eAAe,CAAC6G,KAAhB,CAAsBD,MAAtB,CAAJ,EAAmC;IACjC,yBAAYzF,KAAZ;MAAmBmC,QAAQ,EAAE;IAA7B;EACD;;EAED,IAAIrD,cAAc,CAAC4G,KAAf,CAAqBD,MAArB,CAAJ,EAAkC;IAChC,yBACKzF,KADL;MAEEmC,QAAQ,EAAE,KAFZ;MAGEkE,SAAS,EAAEvG;IAHb;EAKD;;EAED,IAAIf,uBAAuB,CAAC2G,KAAxB,CAA8BD,MAA9B,CAAJ,EAA2C;IACzC,MAAMa,WAAW,GAAG,CAApB;IACA,MAAM;MAAE9D;IAAF,IAAYxC,KAAlB;IACA,MAAM;MAAEoC,aAAF;MAAiBkD;IAAjB,IAA8BG,MAAM,CAACE,OAA3C;IAEA,IAAIY,QAAQ,GAAG,CAAC,GAAG/D,KAAJ,CAAf;IACA,MAAMgE,cAAc,GAAGD,QAAQ,CAACE,IAAT,CAAeC,CAAD,IAAOA,CAAC,CAACC,GAAF,KAAUrB,QAA/B,CAAvB;;IAEA,IAAI,CAACkB,cAAL,EAAqB;MACnB,MAAMI,YAAY,GAAG;QAAED,GAAG,EAAErB,QAAP;QAAiBuB,KAAK,EAAEzE;MAAxB,CAArB;MACAmE,QAAQ,GAAG,CAACK,YAAD,EAAe,GAAGL,QAAlB,EAA4BX,KAA5B,CAAkC,CAAlC,EAAqCU,WAArC,CAAX;IACD;;IAED,yBACKtG,KADL;MAEEwC,KAAK,EAAE+D;IAFT;EAID;;EAED,IAAIvH,gBAAgB,CAAC0G,KAAjB,CAAuBD,MAAvB,CAAJ,EAAoC;IAClC,yBACKzF,KADL;MAEEwC,KAAK,EAAE;IAFT;EAID;;EAED,OAAOxC,KAAP;AACD,CAnMM;AAqMP,OAAO,MAAMkG,oBAAoB,GAAG,CAClClG,KADkC,EAElCyF,MAFkC,KAGb;EAAA;;EACrB,MAAM;IAAEvC;EAAF,IAAeuC,MAAM,CAACE,OAA5B;EACA,MAAM;IACJ9B,OADI;IAEJ7D,KAAK,EAAE2D,YAFH;IAGJO,MAHI;IAIJjB,KAJI;IAKJ6D,WALI;IAMJ/C,UANI;IAOJgD,WAPI;IAQJC,WARI;IASJC;EATI,IAUF/D,QAVJ;;EAYA,IAAID,KAAJ,EAAW;IAAA;;IACT,IAAIA,KAAK,CAACgB,IAAN,KAAejI,kBAAkB,CAACkL,OAAtC,EAA+C;MAC7C,yBACKlH,KADL;QAEEoC,aAAa,EAAEc,QAFjB;QAGE4C,OAAO,EAAEnC,YAAY,KAAKvH,YAAY,CAACwH,OAA9B,IAAyCD,YAAY,KAAKvH,YAAY,CAAC+J;MAHlF;IAKD,CAND,MAMO,IAAIlD,KAAK,CAACgB,IAAN,KAAejI,kBAAkB,CAACmL,SAAtC,EAAiD;MACtD,OAAOnH,KAAP;IACD,CATQ,CAWT;IACA;;;IACA,IAAIzD,MAAM,CAAC6K,qBAAP,6BAAgCpH,KAAK,CAAC8B,kBAAtC,4EAAgC,sBAA0BuF,UAA1D,mDAAgC,uBAAsCC,SAA1E,EAAqF;MACnFtH,KAAK,CAACuH,WAAN,CAAkBC,IAAlB,CAAuBnL,WAAW,CAACoL,SAAnC,EAA8CxE,KAA9C;IACD;EACF;;EAED,IAAI,CAACY,OAAL,EAAc;IACZ,yBAAY7D,KAAZ;EACD,CAlCoB,CAoCrB;EACA;;;EACA,IAAIzD,MAAM,CAAC6K,qBAAP,8BAAgCpH,KAAK,CAAC8B,kBAAtC,6EAAgC,uBAA0BuF,UAA1D,mDAAgC,uBAAsCC,SAA1E,EAAqF;IACnF,MAAMI,MAAM,GAAGxD,MAAM,CAAC1D,GAAP,CAAYmH,CAAD,IAAOrL,oBAAoB,CAACqL,CAAD,CAAtC,CAAf;IACA3H,KAAK,CAACuH,WAAN,CAAkBC,IAAlB,CAAuBnL,WAAW,CAACuL,YAAnC,EAAiDF,MAAjD;EACD;;EAED,yBACK1H,KADL;IAEEoC,aAAa,EAAEc,QAFjB;IAGE4D,WAHF;IAIEC,WAJF;IAKEhD,UALF;IAME+B,OAAO,EAAEnC,YAAY,KAAKvH,YAAY,CAACwH,OAA9B,IAAyCD,YAAY,KAAKvH,YAAY,CAAC+J,SANlF;IAOE0B,QAAQ,EAAE,CAAC,CAAC9D,UAPd;IAQE+D,WAAW,EAAE,CAAC,CAAChB,WARjB;IASEiB,SAAS,EAAE,CAAC,CAAChB,WATf;IAUEiB,SAAS,EAAE,CAAC,CAAChB,WAAW,CAAC7C,MAV3B;IAWE8D,aAAa,EAAE,CAAC,CAAChB,eAAe,CAAC9C;EAXnC;AAaD,CA3DM"},"metadata":{},"sourceType":"module"}