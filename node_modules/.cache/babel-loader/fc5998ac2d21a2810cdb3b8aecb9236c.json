{"ast":null,"code":"import { useEffect, useMemo, useRef, useState } from 'react';\nimport { useUnmount } from 'react-use';\nimport useMountedState from 'react-use/lib/useMountedState';\nimport { createWorker } from './createLayoutWorker';\nimport { useNodeLimit } from './useNodeLimit';\nimport { graphBounds } from './utils';\n// Config mainly for the layout but also some other parts like current layout. The layout variables can be changed only\n// if you programmatically enable the config editor (for development only) see ViewControls. These could be moved to\n// panel configuration at some point (apart from gridLayout as that can be switched be user right now.).\nexport const defaultConfig = {\n  linkDistance: 150,\n  linkStrength: 0.5,\n  forceX: 2000,\n  forceXStrength: 0.02,\n  forceCollide: 100,\n  tick: 300,\n  gridLayout: false\n};\n/**\n * This will return copy of the nods and edges with x,y positions filled in. Also the layout changes source/target props\n * in edges from string ids to actual nodes.\n */\n\nexport function useLayout(rawNodes, rawEdges, config = defaultConfig, nodeCountLimit, width, rootNodeId) {\n  const [nodesGraph, setNodesGraph] = useState([]);\n  const [edgesGraph, setEdgesGraph] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const isMounted = useMountedState();\n  const layoutWorkerCancelRef = useRef();\n  useUnmount(() => {\n    if (layoutWorkerCancelRef.current) {\n      layoutWorkerCancelRef.current();\n    }\n  }); // Also we compute both layouts here. Grid layout should not add much time and we can more easily just cache both\n  // so this should happen only once for a given response data.\n  //\n  // Also important note is that right now this works on all the nodes even if they are not visible. This means that\n  // the node position is stable even when expanding different parts of graph. It seems like a reasonable thing but\n  // implications are that:\n  // - limiting visible nodes count does not have a positive perf effect\n  // - graphs with high node count can seem weird (very sparse or spread out) when we show only some nodes but layout\n  //   is done for thousands of nodes but we also do this only once in the graph lifecycle.\n  // We could re-layout this on visible nodes change but this may need smaller visible node limit to keep the perf\n  // (as we would run layout on every click) and also would be very weird without any animation to understand what is\n  // happening as already visible nodes would change positions.\n\n  useEffect(() => {\n    if (rawNodes.length === 0) {\n      setNodesGraph([]);\n      setEdgesGraph([]);\n      setLoading(false);\n      return;\n    }\n\n    setLoading(true); // This is async but as I wanted to still run the sync grid layout and you cannot return promise from effect so\n    // having callback seems ok here.\n\n    const cancel = defaultLayout(rawNodes, rawEdges, ({\n      nodes,\n      edges\n    }) => {\n      if (isMounted()) {\n        setNodesGraph(nodes);\n        setEdgesGraph(edges);\n        setLoading(false);\n      }\n    });\n    layoutWorkerCancelRef.current = cancel;\n    return cancel;\n  }, [rawNodes, rawEdges, isMounted]); // Compute grid separately as it is sync and do not need to be inside effect. Also it is dependant on width while\n  // default layout does not care and we don't want to recalculate that on panel resize.\n\n  const [nodesGrid, edgesGrid] = useMemo(() => {\n    if (rawNodes.length === 0) {\n      return [[], []];\n    }\n\n    const rawNodesCopy = rawNodes.map(n => Object.assign({}, n));\n    const rawEdgesCopy = rawEdges.map(e => Object.assign({}, e));\n    gridLayout(rawNodesCopy, width, config.sort);\n    return [rawNodesCopy, rawEdgesCopy];\n  }, [config.sort, rawNodes, rawEdges, width]); // Limit the nodes so we don't show all for performance reasons. Here we don't compute both at the same time so\n  // changing the layout can trash internal memoization at the moment.\n\n  const {\n    nodes: nodesWithLimit,\n    edges: edgesWithLimit,\n    markers\n  } = useNodeLimit(config.gridLayout ? nodesGrid : nodesGraph, config.gridLayout ? edgesGrid : edgesGraph, nodeCountLimit, config, rootNodeId); // Get bounds based on current limited number of nodes.\n\n  const bounds = useMemo(() => graphBounds([...nodesWithLimit, ...(markers || []).map(m => m.node)]), [nodesWithLimit, markers]);\n  return {\n    nodes: nodesWithLimit,\n    edges: edgesWithLimit,\n    markers,\n    bounds,\n    hiddenNodesCount: rawNodes.length - nodesWithLimit.length,\n    loading\n  };\n}\n/**\n * Wraps the layout code in a worker as it can take long and we don't want to block the main thread.\n * Returns a cancel function to terminate the worker.\n */\n\nfunction defaultLayout(nodes, edges, done) {\n  const worker = createWorker();\n\n  worker.onmessage = event => {\n    for (let i = 0; i < nodes.length; i++) {\n      // These stats needs to be Field class but the data is stringified over the worker boundary\n      event.data.nodes[i] = Object.assign({}, nodes[i], event.data.nodes[i]);\n    }\n\n    done(event.data);\n  };\n\n  worker.postMessage({\n    nodes: nodes.map(n => ({\n      id: n.id,\n      incoming: n.incoming\n    })),\n    edges,\n    config: defaultConfig\n  });\n  return () => {\n    worker.terminate();\n  };\n}\n/**\n * Set the nodes in simple grid layout sorted by some stat.\n */\n\n\nfunction gridLayout(nodes, width, sort) {\n  const spacingVertical = 140;\n  const spacingHorizontal = 120;\n  const padding = spacingHorizontal / 2;\n  const perRow = Math.min(Math.floor((width - padding * 2) / spacingVertical), nodes.length);\n  const midPoint = Math.floor((perRow - 1) * spacingHorizontal / 2);\n\n  if (sort) {\n    nodes.sort((node1, node2) => {\n      const val1 = sort.field.values.get(node1.dataFrameRowIndex);\n      const val2 = sort.field.values.get(node2.dataFrameRowIndex); // Lets pretend we don't care about type of the stats for a while (they can be strings)\n\n      return sort.ascending ? val1 - val2 : val2 - val1;\n    });\n  }\n\n  for (const [index, node] of nodes.entries()) {\n    const row = Math.floor(index / perRow);\n    const column = index % perRow;\n    node.x = column * spacingHorizontal - midPoint;\n    node.y = -60 + row * spacingVertical;\n  }\n}","map":{"version":3,"names":["useEffect","useMemo","useRef","useState","useUnmount","useMountedState","createWorker","useNodeLimit","graphBounds","defaultConfig","linkDistance","linkStrength","forceX","forceXStrength","forceCollide","tick","gridLayout","useLayout","rawNodes","rawEdges","config","nodeCountLimit","width","rootNodeId","nodesGraph","setNodesGraph","edgesGraph","setEdgesGraph","loading","setLoading","isMounted","layoutWorkerCancelRef","current","length","cancel","defaultLayout","nodes","edges","nodesGrid","edgesGrid","rawNodesCopy","map","n","rawEdgesCopy","e","sort","nodesWithLimit","edgesWithLimit","markers","bounds","m","node","hiddenNodesCount","done","worker","onmessage","event","i","data","postMessage","id","incoming","terminate","spacingVertical","spacingHorizontal","padding","perRow","Math","min","floor","midPoint","node1","node2","val1","field","values","get","dataFrameRowIndex","val2","ascending","index","entries","row","column","x","y"],"sources":["/home/soula/grafana/public/app/plugins/panel/nodeGraph/layout.ts"],"sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\nimport { useUnmount } from 'react-use';\nimport useMountedState from 'react-use/lib/useMountedState';\n\nimport { Field } from '@grafana/data';\n\nimport { createWorker } from './createLayoutWorker';\nimport { EdgeDatum, EdgeDatumLayout, NodeDatum } from './types';\nimport { useNodeLimit } from './useNodeLimit';\nimport { graphBounds } from './utils';\n\nexport interface Config {\n  linkDistance: number;\n  linkStrength: number;\n  forceX: number;\n  forceXStrength: number;\n  forceCollide: number;\n  tick: number;\n  gridLayout: boolean;\n  sort?: {\n    // Either a arc field or stats field\n    field: Field;\n    ascending: boolean;\n  };\n}\n\n// Config mainly for the layout but also some other parts like current layout. The layout variables can be changed only\n// if you programmatically enable the config editor (for development only) see ViewControls. These could be moved to\n// panel configuration at some point (apart from gridLayout as that can be switched be user right now.).\nexport const defaultConfig: Config = {\n  linkDistance: 150,\n  linkStrength: 0.5,\n  forceX: 2000,\n  forceXStrength: 0.02,\n  forceCollide: 100,\n  tick: 300,\n  gridLayout: false,\n};\n\n/**\n * This will return copy of the nods and edges with x,y positions filled in. Also the layout changes source/target props\n * in edges from string ids to actual nodes.\n */\nexport function useLayout(\n  rawNodes: NodeDatum[],\n  rawEdges: EdgeDatum[],\n  config: Config = defaultConfig,\n  nodeCountLimit: number,\n  width: number,\n  rootNodeId?: string\n) {\n  const [nodesGraph, setNodesGraph] = useState<NodeDatum[]>([]);\n  const [edgesGraph, setEdgesGraph] = useState<EdgeDatumLayout[]>([]);\n\n  const [loading, setLoading] = useState(false);\n\n  const isMounted = useMountedState();\n  const layoutWorkerCancelRef = useRef<(() => void) | undefined>();\n\n  useUnmount(() => {\n    if (layoutWorkerCancelRef.current) {\n      layoutWorkerCancelRef.current();\n    }\n  });\n\n  // Also we compute both layouts here. Grid layout should not add much time and we can more easily just cache both\n  // so this should happen only once for a given response data.\n  //\n  // Also important note is that right now this works on all the nodes even if they are not visible. This means that\n  // the node position is stable even when expanding different parts of graph. It seems like a reasonable thing but\n  // implications are that:\n  // - limiting visible nodes count does not have a positive perf effect\n  // - graphs with high node count can seem weird (very sparse or spread out) when we show only some nodes but layout\n  //   is done for thousands of nodes but we also do this only once in the graph lifecycle.\n  // We could re-layout this on visible nodes change but this may need smaller visible node limit to keep the perf\n  // (as we would run layout on every click) and also would be very weird without any animation to understand what is\n  // happening as already visible nodes would change positions.\n  useEffect(() => {\n    if (rawNodes.length === 0) {\n      setNodesGraph([]);\n      setEdgesGraph([]);\n      setLoading(false);\n      return;\n    }\n\n    setLoading(true);\n\n    // This is async but as I wanted to still run the sync grid layout and you cannot return promise from effect so\n    // having callback seems ok here.\n    const cancel = defaultLayout(rawNodes, rawEdges, ({ nodes, edges }) => {\n      if (isMounted()) {\n        setNodesGraph(nodes);\n        setEdgesGraph(edges as EdgeDatumLayout[]);\n        setLoading(false);\n      }\n    });\n    layoutWorkerCancelRef.current = cancel;\n    return cancel;\n  }, [rawNodes, rawEdges, isMounted]);\n\n  // Compute grid separately as it is sync and do not need to be inside effect. Also it is dependant on width while\n  // default layout does not care and we don't want to recalculate that on panel resize.\n  const [nodesGrid, edgesGrid] = useMemo(() => {\n    if (rawNodes.length === 0) {\n      return [[], []];\n    }\n\n    const rawNodesCopy = rawNodes.map((n) => ({ ...n }));\n    const rawEdgesCopy = rawEdges.map((e) => ({ ...e }));\n    gridLayout(rawNodesCopy, width, config.sort);\n\n    return [rawNodesCopy, rawEdgesCopy as EdgeDatumLayout[]];\n  }, [config.sort, rawNodes, rawEdges, width]);\n\n  // Limit the nodes so we don't show all for performance reasons. Here we don't compute both at the same time so\n  // changing the layout can trash internal memoization at the moment.\n  const {\n    nodes: nodesWithLimit,\n    edges: edgesWithLimit,\n    markers,\n  } = useNodeLimit(\n    config.gridLayout ? nodesGrid : nodesGraph,\n    config.gridLayout ? edgesGrid : edgesGraph,\n    nodeCountLimit,\n    config,\n    rootNodeId\n  );\n\n  // Get bounds based on current limited number of nodes.\n  const bounds = useMemo(\n    () => graphBounds([...nodesWithLimit, ...(markers || []).map((m) => m.node)]),\n    [nodesWithLimit, markers]\n  );\n\n  return {\n    nodes: nodesWithLimit,\n    edges: edgesWithLimit,\n    markers,\n    bounds,\n    hiddenNodesCount: rawNodes.length - nodesWithLimit.length,\n    loading,\n  };\n}\n\n/**\n * Wraps the layout code in a worker as it can take long and we don't want to block the main thread.\n * Returns a cancel function to terminate the worker.\n */\nfunction defaultLayout(\n  nodes: NodeDatum[],\n  edges: EdgeDatum[],\n  done: (data: { nodes: NodeDatum[]; edges: EdgeDatum[] }) => void\n) {\n  const worker = createWorker();\n  worker.onmessage = (event: MessageEvent<{ nodes: NodeDatum[]; edges: EdgeDatumLayout[] }>) => {\n    for (let i = 0; i < nodes.length; i++) {\n      // These stats needs to be Field class but the data is stringified over the worker boundary\n      event.data.nodes[i] = {\n        ...nodes[i],\n        ...event.data.nodes[i],\n      };\n    }\n    done(event.data);\n  };\n\n  worker.postMessage({\n    nodes: nodes.map((n) => ({\n      id: n.id,\n      incoming: n.incoming,\n    })),\n    edges,\n    config: defaultConfig,\n  });\n\n  return () => {\n    worker.terminate();\n  };\n}\n\n/**\n * Set the nodes in simple grid layout sorted by some stat.\n */\nfunction gridLayout(\n  nodes: NodeDatum[],\n  width: number,\n  sort?: {\n    field: Field;\n    ascending: boolean;\n  }\n) {\n  const spacingVertical = 140;\n  const spacingHorizontal = 120;\n  const padding = spacingHorizontal / 2;\n  const perRow = Math.min(Math.floor((width - padding * 2) / spacingVertical), nodes.length);\n  const midPoint = Math.floor(((perRow - 1) * spacingHorizontal) / 2);\n\n  if (sort) {\n    nodes.sort((node1, node2) => {\n      const val1 = sort!.field.values.get(node1.dataFrameRowIndex);\n      const val2 = sort!.field.values.get(node2.dataFrameRowIndex);\n\n      // Lets pretend we don't care about type of the stats for a while (they can be strings)\n      return sort!.ascending ? val1 - val2 : val2 - val1;\n    });\n  }\n\n  for (const [index, node] of nodes.entries()) {\n    const row = Math.floor(index / perRow);\n    const column = index % perRow;\n    node.x = column * spacingHorizontal - midPoint;\n    node.y = -60 + row * spacingVertical;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}