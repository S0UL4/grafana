{"ast":null,"code":"import React, { createContext, useContext, useEffect, useMemo, useState } from 'react';\nimport { usePrevious } from 'react-use';\nimport { getTemplateSrv } from 'app/features/templating/template_srv';\nimport { actions } from './actions';\nimport { createStore } from './store';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DispatchContext = /*#__PURE__*/createContext({});\nconst GraphiteStateContext = /*#__PURE__*/createContext({});\nexport const useDispatch = () => {\n  return useContext(DispatchContext);\n};\nexport const useGraphiteState = () => {\n  return useContext(GraphiteStateContext);\n};\nexport const GraphiteQueryEditorContext = ({\n  datasource,\n  onRunQuery,\n  onChange,\n  query,\n  queries,\n  range,\n  children\n}) => {\n  const [state, setState] = useState();\n  const [needsRefresh, setNeedsRefresh] = useState(false);\n  const dispatch = useMemo(() => {\n    return createStore(state => {\n      setState(state);\n    });\n  }, []); // synchronise changes provided in props with editor's state\n\n  const previousRange = usePrevious(range);\n  useEffect(() => {\n    if ((previousRange === null || previousRange === void 0 ? void 0 : previousRange.raw) !== (range === null || range === void 0 ? void 0 : range.raw)) {\n      dispatch(actions.timeRangeChanged(range));\n    }\n  }, [dispatch, range, previousRange]);\n  useEffect(() => {\n    if (state) {\n      dispatch(actions.queriesChanged(queries));\n    }\n  }, // adding state to dependencies causes infinite loops\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [dispatch, queries]);\n  useEffect(() => {\n    var _state$target;\n\n    if (state && ((_state$target = state.target) === null || _state$target === void 0 ? void 0 : _state$target.target) !== query.target) {\n      dispatch(actions.queryChanged(query));\n    }\n  }, // adding state to dependencies causes infinite loops\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [dispatch, query]);\n  useEffect(() => {\n    if (needsRefresh && state) {\n      setNeedsRefresh(false);\n      onChange(Object.assign({}, query, {\n        target: state.target.target\n      }));\n      onRunQuery();\n    }\n  }, // adding state to dependencies causes infinite loops\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [needsRefresh, onChange, onRunQuery, query]);\n\n  if (!state) {\n    dispatch(actions.init({\n      target: query,\n      datasource: datasource,\n      range: range,\n      templateSrv: getTemplateSrv(),\n      // list of queries is passed only when the editor is in Dashboards. This is to allow interpolation\n      // of sub-queries which are stored in \"targetFull\" property used by alerting in the backend.\n      queries: queries || [],\n      refresh: () => {\n        // do not run onChange/onRunQuery straight away to ensure the internal state gets updated first\n        // to avoid race conditions (onChange could update props before the reducer action finishes)\n        setNeedsRefresh(true);\n      }\n    }));\n    return null;\n  } else {\n    return /*#__PURE__*/_jsx(GraphiteStateContext.Provider, {\n      value: state,\n      children: /*#__PURE__*/_jsx(DispatchContext.Provider, {\n        value: dispatch,\n        children: children\n      })\n    });\n  }\n};","map":{"version":3,"names":["React","createContext","useContext","useEffect","useMemo","useState","usePrevious","getTemplateSrv","actions","createStore","DispatchContext","GraphiteStateContext","useDispatch","useGraphiteState","GraphiteQueryEditorContext","datasource","onRunQuery","onChange","query","queries","range","children","state","setState","needsRefresh","setNeedsRefresh","dispatch","previousRange","raw","timeRangeChanged","queriesChanged","target","queryChanged","init","templateSrv","refresh"],"sources":["/home/soula/grafana/public/app/plugins/datasource/graphite/state/context.tsx"],"sourcesContent":["import { AnyAction } from '@reduxjs/toolkit';\nimport React, { createContext, Dispatch, PropsWithChildren, useContext, useEffect, useMemo, useState } from 'react';\nimport { usePrevious } from 'react-use';\n\nimport { QueryEditorProps } from '@grafana/data';\nimport { getTemplateSrv } from 'app/features/templating/template_srv';\n\nimport { GraphiteDatasource } from '../datasource';\nimport { GraphiteOptions, GraphiteQuery } from '../types';\n\nimport { actions } from './actions';\nimport { createStore, GraphiteQueryEditorState } from './store';\n\nconst DispatchContext = createContext<Dispatch<AnyAction>>({} as Dispatch<AnyAction>);\nconst GraphiteStateContext = createContext<GraphiteQueryEditorState>({} as GraphiteQueryEditorState);\n\nexport const useDispatch = () => {\n  return useContext(DispatchContext);\n};\n\nexport const useGraphiteState = () => {\n  return useContext(GraphiteStateContext);\n};\n\nexport type GraphiteQueryEditorProps = QueryEditorProps<GraphiteDatasource, GraphiteQuery, GraphiteOptions>;\n\nexport const GraphiteQueryEditorContext = ({\n  datasource,\n  onRunQuery,\n  onChange,\n  query,\n  queries,\n  range,\n  children,\n}: PropsWithChildren<GraphiteQueryEditorProps>) => {\n  const [state, setState] = useState<GraphiteQueryEditorState>();\n  const [needsRefresh, setNeedsRefresh] = useState<boolean>(false);\n\n  const dispatch = useMemo(() => {\n    return createStore((state) => {\n      setState(state);\n    });\n  }, []);\n\n  // synchronise changes provided in props with editor's state\n  const previousRange = usePrevious(range);\n  useEffect(() => {\n    if (previousRange?.raw !== range?.raw) {\n      dispatch(actions.timeRangeChanged(range));\n    }\n  }, [dispatch, range, previousRange]);\n\n  useEffect(\n    () => {\n      if (state) {\n        dispatch(actions.queriesChanged(queries));\n      }\n    },\n    // adding state to dependencies causes infinite loops\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [dispatch, queries]\n  );\n\n  useEffect(\n    () => {\n      if (state && state.target?.target !== query.target) {\n        dispatch(actions.queryChanged(query));\n      }\n    },\n    // adding state to dependencies causes infinite loops\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [dispatch, query]\n  );\n\n  useEffect(\n    () => {\n      if (needsRefresh && state) {\n        setNeedsRefresh(false);\n        onChange({ ...query, target: state.target.target });\n        onRunQuery();\n      }\n    },\n    // adding state to dependencies causes infinite loops\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [needsRefresh, onChange, onRunQuery, query]\n  );\n\n  if (!state) {\n    dispatch(\n      actions.init({\n        target: query,\n        datasource: datasource,\n        range: range,\n        templateSrv: getTemplateSrv(),\n        // list of queries is passed only when the editor is in Dashboards. This is to allow interpolation\n        // of sub-queries which are stored in \"targetFull\" property used by alerting in the backend.\n        queries: queries || [],\n        refresh: () => {\n          // do not run onChange/onRunQuery straight away to ensure the internal state gets updated first\n          // to avoid race conditions (onChange could update props before the reducer action finishes)\n          setNeedsRefresh(true);\n        },\n      })\n    );\n    return null;\n  } else {\n    return (\n      <GraphiteStateContext.Provider value={state}>\n        <DispatchContext.Provider value={dispatch}>{children}</DispatchContext.Provider>\n      </GraphiteStateContext.Provider>\n    );\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}