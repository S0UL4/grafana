{"ast":null,"code":"import { getCompletions } from './completions';\nimport { getSituation } from './situation';\nimport { NeverCaseError } from './util';\nexport function getSuggestOptions() {\n  return {\n    // monaco-editor sometimes provides suggestions automatically, i am not\n    // sure based on what, seems to be by analyzing the words already\n    // written.\n    // to try it out:\n    // - enter `go_goroutines{job~`\n    // - have the cursor at the end of the string\n    // - press ctrl-enter\n    // - you will get two suggestions\n    // those were not provided by grafana, they are offered automatically.\n    // i want to remove those. the only way i found is:\n    // - every suggestion-item has a `kind` attribute,\n    //   that controls the icon to the left of the suggestion.\n    // - items auto-generated by monaco have `kind` set to `text`.\n    // - we make sure grafana-provided suggestions do not have `kind` set to `text`.\n    // - and then we tell monaco not to show suggestions of kind `text`\n    showWords: false\n  };\n}\n\nfunction getMonacoCompletionItemKind(type, monaco) {\n  switch (type) {\n    case 'DURATION':\n      return monaco.languages.CompletionItemKind.Unit;\n\n    case 'FUNCTION':\n      return monaco.languages.CompletionItemKind.Variable;\n\n    case 'HISTORY':\n      return monaco.languages.CompletionItemKind.Snippet;\n\n    case 'LABEL_NAME':\n      return monaco.languages.CompletionItemKind.Enum;\n\n    case 'LABEL_VALUE':\n      return monaco.languages.CompletionItemKind.EnumMember;\n\n    case 'METRIC_NAME':\n      return monaco.languages.CompletionItemKind.Constructor;\n\n    default:\n      throw new NeverCaseError(type);\n  }\n}\n\nexport function getCompletionProvider(monaco, dataProvider) {\n  const provideCompletionItems = (model, position) => {\n    const word = model.getWordAtPosition(position);\n    const range = word != null ? monaco.Range.lift({\n      startLineNumber: position.lineNumber,\n      endLineNumber: position.lineNumber,\n      startColumn: word.startColumn,\n      endColumn: word.endColumn\n    }) : monaco.Range.fromPositions(position); // documentation says `position` will be \"adjusted\" in `getOffsetAt`\n    // i don't know what that means, to be sure i clone it\n\n    const positionClone = {\n      column: position.column,\n      lineNumber: position.lineNumber\n    };\n    const offset = model.getOffsetAt(positionClone);\n    const situation = getSituation(model.getValue(), offset);\n    const completionsPromise = situation != null ? getCompletions(situation, dataProvider) : Promise.resolve([]);\n    return completionsPromise.then(items => {\n      // monaco by-default alphabetically orders the items.\n      // to stop it, we use a number-as-string sortkey,\n      // so that monaco keeps the order we use\n      const maxIndexDigits = items.length.toString().length;\n      const suggestions = items.map((item, index) => ({\n        kind: getMonacoCompletionItemKind(item.type, monaco),\n        label: item.label,\n        insertText: item.insertText,\n        detail: item.detail,\n        documentation: item.documentation,\n        sortText: index.toString().padStart(maxIndexDigits, '0'),\n        // to force the order we have\n        range,\n        command: item.triggerOnInsert ? {\n          id: 'editor.action.triggerSuggest',\n          title: ''\n        } : undefined\n      }));\n      return {\n        suggestions\n      };\n    });\n  };\n\n  return {\n    triggerCharacters: ['{', ',', '[', '(', '=', '~', ' ', '\"'],\n    provideCompletionItems\n  };\n}","map":{"version":3,"names":["getCompletions","getSituation","NeverCaseError","getSuggestOptions","showWords","getMonacoCompletionItemKind","type","monaco","languages","CompletionItemKind","Unit","Variable","Snippet","Enum","EnumMember","Constructor","getCompletionProvider","dataProvider","provideCompletionItems","model","position","word","getWordAtPosition","range","Range","lift","startLineNumber","lineNumber","endLineNumber","startColumn","endColumn","fromPositions","positionClone","column","offset","getOffsetAt","situation","getValue","completionsPromise","Promise","resolve","then","items","maxIndexDigits","length","toString","suggestions","map","item","index","kind","label","insertText","detail","documentation","sortText","padStart","command","triggerOnInsert","id","title","undefined","triggerCharacters"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/index.ts"],"sourcesContent":["import type { Monaco, monacoTypes } from '@grafana/ui';\n\nimport { getCompletions, DataProvider, CompletionType } from './completions';\nimport { getSituation } from './situation';\nimport { NeverCaseError } from './util';\n\nexport function getSuggestOptions(): monacoTypes.editor.ISuggestOptions {\n  return {\n    // monaco-editor sometimes provides suggestions automatically, i am not\n    // sure based on what, seems to be by analyzing the words already\n    // written.\n    // to try it out:\n    // - enter `go_goroutines{job~`\n    // - have the cursor at the end of the string\n    // - press ctrl-enter\n    // - you will get two suggestions\n    // those were not provided by grafana, they are offered automatically.\n    // i want to remove those. the only way i found is:\n    // - every suggestion-item has a `kind` attribute,\n    //   that controls the icon to the left of the suggestion.\n    // - items auto-generated by monaco have `kind` set to `text`.\n    // - we make sure grafana-provided suggestions do not have `kind` set to `text`.\n    // - and then we tell monaco not to show suggestions of kind `text`\n    showWords: false,\n  };\n}\n\nfunction getMonacoCompletionItemKind(type: CompletionType, monaco: Monaco): monacoTypes.languages.CompletionItemKind {\n  switch (type) {\n    case 'DURATION':\n      return monaco.languages.CompletionItemKind.Unit;\n    case 'FUNCTION':\n      return monaco.languages.CompletionItemKind.Variable;\n    case 'HISTORY':\n      return monaco.languages.CompletionItemKind.Snippet;\n    case 'LABEL_NAME':\n      return monaco.languages.CompletionItemKind.Enum;\n    case 'LABEL_VALUE':\n      return monaco.languages.CompletionItemKind.EnumMember;\n    case 'METRIC_NAME':\n      return monaco.languages.CompletionItemKind.Constructor;\n    default:\n      throw new NeverCaseError(type);\n  }\n}\nexport function getCompletionProvider(\n  monaco: Monaco,\n  dataProvider: DataProvider\n): monacoTypes.languages.CompletionItemProvider {\n  const provideCompletionItems = (\n    model: monacoTypes.editor.ITextModel,\n    position: monacoTypes.Position\n  ): monacoTypes.languages.ProviderResult<monacoTypes.languages.CompletionList> => {\n    const word = model.getWordAtPosition(position);\n    const range =\n      word != null\n        ? monaco.Range.lift({\n            startLineNumber: position.lineNumber,\n            endLineNumber: position.lineNumber,\n            startColumn: word.startColumn,\n            endColumn: word.endColumn,\n          })\n        : monaco.Range.fromPositions(position);\n    // documentation says `position` will be \"adjusted\" in `getOffsetAt`\n    // i don't know what that means, to be sure i clone it\n    const positionClone = {\n      column: position.column,\n      lineNumber: position.lineNumber,\n    };\n    const offset = model.getOffsetAt(positionClone);\n    const situation = getSituation(model.getValue(), offset);\n    const completionsPromise = situation != null ? getCompletions(situation, dataProvider) : Promise.resolve([]);\n    return completionsPromise.then((items) => {\n      // monaco by-default alphabetically orders the items.\n      // to stop it, we use a number-as-string sortkey,\n      // so that monaco keeps the order we use\n      const maxIndexDigits = items.length.toString().length;\n      const suggestions: monacoTypes.languages.CompletionItem[] = items.map((item, index) => ({\n        kind: getMonacoCompletionItemKind(item.type, monaco),\n        label: item.label,\n        insertText: item.insertText,\n        detail: item.detail,\n        documentation: item.documentation,\n        sortText: index.toString().padStart(maxIndexDigits, '0'), // to force the order we have\n        range,\n        command: item.triggerOnInsert\n          ? {\n              id: 'editor.action.triggerSuggest',\n              title: '',\n            }\n          : undefined,\n      }));\n      return { suggestions };\n    });\n  };\n\n  return {\n    triggerCharacters: ['{', ',', '[', '(', '=', '~', ' ', '\"'],\n    provideCompletionItems,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}