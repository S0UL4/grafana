{"ast":null,"code":"import { concat, find, flattenDeep, forEach, get, map } from 'lodash';\nimport { dateTime } from '@grafana/data';\nexport default class ResponseParser {\n  constructor(results) {\n    this.results = results;\n  }\n\n  parseQueryResult() {\n    let data = [];\n    let columns = [];\n\n    for (let i = 0; i < this.results.length; i++) {\n      if (this.results[i].result.tables.length === 0) {\n        continue;\n      }\n\n      columns = this.results[i].result.tables[0].columns;\n      const rows = this.results[i].result.tables[0].rows;\n\n      if (this.results[i].query.resultFormat === 'time_series') {\n        data = concat(data, this.parseTimeSeriesResult(this.results[i].query, columns, rows));\n      } else {\n        data = concat(data, this.parseTableResult(this.results[i].query, columns, rows));\n      }\n    }\n\n    return data;\n  }\n\n  parseTimeSeriesResult(query, columns, rows) {\n    const data = [];\n    let timeIndex = -1;\n    let metricIndex = -1;\n    let valueIndex = -1;\n\n    for (let i = 0; i < columns.length; i++) {\n      if (timeIndex === -1 && columns[i].type === 'datetime') {\n        timeIndex = i;\n      }\n\n      if (metricIndex === -1 && columns[i].type === 'string') {\n        metricIndex = i;\n      }\n\n      if (valueIndex === -1 && ['int', 'long', 'real', 'double'].indexOf(columns[i].type) > -1) {\n        valueIndex = i;\n      }\n    }\n\n    if (timeIndex === -1) {\n      throw new Error('No datetime column found in the result. The Time Series format requires a time column.');\n    }\n\n    forEach(rows, row => {\n      const epoch = ResponseParser.dateTimeToEpoch(row[timeIndex]);\n      const metricName = metricIndex > -1 ? row[metricIndex] : columns[valueIndex].name;\n      const bucket = ResponseParser.findOrCreateBucket(data, metricName);\n      bucket.datapoints.push([row[valueIndex], epoch]);\n      bucket.refId = query.refId;\n      bucket.meta = {\n        executedQueryString: query.query\n      };\n    });\n    return data;\n  }\n\n  parseTableResult(query, columns, rows) {\n    const tableResult = {\n      type: 'table',\n      columns: map(columns, col => {\n        return {\n          text: col.name,\n          type: col.type\n        };\n      }),\n      rows: rows,\n      refId: query.refId,\n      meta: {\n        executedQueryString: query.query\n      }\n    };\n    return tableResult;\n  }\n\n  parseToVariables() {\n    const queryResult = this.parseQueryResult();\n    const variables = [];\n    forEach(queryResult, result => {\n      forEach(flattenDeep(result.rows), row => {\n        variables.push({\n          text: row,\n          value: row\n        });\n      });\n    });\n    return variables;\n  }\n\n  transformToAnnotations(options) {\n    const queryResult = this.parseQueryResult();\n    const list = [];\n    forEach(queryResult, result => {\n      let timeIndex = -1;\n      let textIndex = -1;\n      let tagsIndex = -1;\n\n      for (let i = 0; i < result.columns.length; i++) {\n        if (timeIndex === -1 && result.columns[i].type === 'datetime') {\n          timeIndex = i;\n        }\n\n        if (textIndex === -1 && result.columns[i].text.toLowerCase() === 'text') {\n          textIndex = i;\n        }\n\n        if (tagsIndex === -1 && result.columns[i].text.toLowerCase() === 'tags') {\n          tagsIndex = i;\n        }\n      }\n\n      forEach(result.rows, row => {\n        list.push({\n          annotation: options.annotation,\n          time: Math.floor(ResponseParser.dateTimeToEpoch(row[timeIndex])),\n          text: row[textIndex] ? row[textIndex].toString() : '',\n          tags: row[tagsIndex] ? row[tagsIndex].trim().split(/\\s*,\\s*/) : []\n        });\n      });\n    });\n    return list;\n  }\n\n  static findOrCreateBucket(data, target) {\n    let dataTarget = find(data, ['target', target]);\n\n    if (!dataTarget) {\n      dataTarget = {\n        target: target,\n        datapoints: [],\n        refId: '',\n        query: ''\n      };\n      data.push(dataTarget);\n    }\n\n    return dataTarget;\n  }\n\n  static dateTimeToEpoch(dateTimeValue) {\n    return dateTime(dateTimeValue).valueOf();\n  }\n\n  static parseSubscriptions(result) {\n    const list = [];\n\n    if (!result) {\n      return list;\n    }\n\n    const valueFieldName = 'subscriptionId';\n    const textFieldName = 'displayName';\n\n    for (let i = 0; i < result.value.length; i++) {\n      if (!find(list, ['value', get(result.value[i], valueFieldName)])) {\n        list.push({\n          text: `${get(result.value[i], textFieldName)}`,\n          value: get(result.value[i], valueFieldName)\n        });\n      }\n    }\n\n    return list;\n  }\n\n} // matches (name):(type) = (defaultValue)\n// e.g. fromRangeStart:datetime = datetime(null)\n//  - name: fromRangeStart\n//  - type: datetime\n//  - defaultValue: datetime(null)\n\nconst METADATA_FUNCTION_PARAMS = /([\\w\\W]+):([\\w]+)(?:\\s?=\\s?([\\w\\W]+))?/;\n\nfunction transformMetadataFunction(sourceSchema) {\n  if (!sourceSchema.functions) {\n    return [];\n  }\n\n  return sourceSchema.functions.map(fn => {\n    const params = fn.parameters && fn.parameters.split(', ').map(arg => {\n      const match = arg.match(METADATA_FUNCTION_PARAMS);\n\n      if (!match) {\n        return;\n      }\n\n      const [, name, type, defaultValue] = match;\n      return {\n        name,\n        type,\n        defaultValue,\n        cslDefaultValue: defaultValue\n      };\n    }).filter(v => !!v);\n    return {\n      name: fn.name,\n      body: fn.body,\n      inputParameters: params || []\n    };\n  });\n}\n\nexport function transformMetadataToKustoSchema(sourceSchema, nameOrIdOrSomething, templateVariables) {\n  const database = {\n    name: nameOrIdOrSomething,\n    tables: sourceSchema.tables,\n    functions: transformMetadataFunction(sourceSchema),\n    majorVersion: 0,\n    minorVersion: 0\n  }; // Adding macros as known functions\n\n  database.functions.push({\n    name: '$__timeFilter',\n    body: '{ true }',\n    inputParameters: [{\n      name: 'timeColumn',\n      type: 'System.String',\n      defaultValue: '\"\"',\n      cslDefaultValue: '\"\"'\n    }]\n  }, {\n    name: '$__timeFrom',\n    body: '{ datetime(2018-06-05T18:09:58.907Z) }',\n    inputParameters: []\n  }, {\n    name: '$__timeTo',\n    body: '{ datetime(2018-06-05T20:09:58.907Z) }',\n    inputParameters: []\n  }, {\n    name: '$__escapeMulti',\n    body: `{ @'\\\\grafana-vm\\Network(eth0)\\Total', @'\\\\hello!'}`,\n    inputParameters: [{\n      name: '$myVar',\n      type: 'System.String',\n      defaultValue: '$myVar',\n      cslDefaultValue: '$myVar'\n    }]\n  }, {\n    name: '$__contains',\n    body: `{ colName in ('value1','value2') }`,\n    inputParameters: [{\n      name: 'colName',\n      type: 'System.String',\n      defaultValue: 'colName',\n      cslDefaultValue: 'colName'\n    }, {\n      name: '$myVar',\n      type: 'System.String',\n      defaultValue: '$myVar',\n      cslDefaultValue: '$myVar'\n    }]\n  }); // Adding macros as global parameters\n\n  const globalParameters = templateVariables.map(v => {\n    return {\n      name: `$${v.name}`,\n      type: 'dynamic'\n    };\n  });\n  return {\n    clusterType: 'Engine',\n    cluster: {\n      connectionString: nameOrIdOrSomething,\n      databases: [database]\n    },\n    database: database,\n    globalParameters\n  };\n}","map":{"version":3,"names":["concat","find","flattenDeep","forEach","get","map","dateTime","ResponseParser","constructor","results","parseQueryResult","data","columns","i","length","result","tables","rows","query","resultFormat","parseTimeSeriesResult","parseTableResult","timeIndex","metricIndex","valueIndex","type","indexOf","Error","row","epoch","dateTimeToEpoch","metricName","name","bucket","findOrCreateBucket","datapoints","push","refId","meta","executedQueryString","tableResult","col","text","parseToVariables","queryResult","variables","value","transformToAnnotations","options","list","textIndex","tagsIndex","toLowerCase","annotation","time","Math","floor","toString","tags","trim","split","target","dataTarget","dateTimeValue","valueOf","parseSubscriptions","valueFieldName","textFieldName","METADATA_FUNCTION_PARAMS","transformMetadataFunction","sourceSchema","functions","fn","params","parameters","arg","match","defaultValue","cslDefaultValue","filter","v","body","inputParameters","transformMetadataToKustoSchema","nameOrIdOrSomething","templateVariables","database","majorVersion","minorVersion","globalParameters","clusterType","cluster","connectionString","databases"],"sources":["/home/soula/grafana/public/app/plugins/datasource/grafana-azure-monitor-datasource/azure_log_analytics/response_parser.ts"],"sourcesContent":["import { concat, find, flattenDeep, forEach, get, map } from 'lodash';\n\nimport { AnnotationEvent, dateTime, TimeSeries, VariableModel } from '@grafana/data';\n\nimport { AzureLogsTableData, AzureLogsVariable } from '../types';\nimport { AzureLogAnalyticsMetadata } from '../types/logAnalyticsMetadata';\n\nexport default class ResponseParser {\n  declare columns: string[];\n  constructor(private results: any) {}\n\n  parseQueryResult(): any {\n    let data: any[] = [];\n    let columns: any[] = [];\n    for (let i = 0; i < this.results.length; i++) {\n      if (this.results[i].result.tables.length === 0) {\n        continue;\n      }\n      columns = this.results[i].result.tables[0].columns;\n      const rows = this.results[i].result.tables[0].rows;\n\n      if (this.results[i].query.resultFormat === 'time_series') {\n        data = concat(data, this.parseTimeSeriesResult(this.results[i].query, columns, rows));\n      } else {\n        data = concat(data, this.parseTableResult(this.results[i].query, columns, rows));\n      }\n    }\n\n    return data;\n  }\n\n  parseTimeSeriesResult(query: { refId: string; query: any }, columns: any[], rows: any): TimeSeries[] {\n    const data: TimeSeries[] = [];\n    let timeIndex = -1;\n    let metricIndex = -1;\n    let valueIndex = -1;\n\n    for (let i = 0; i < columns.length; i++) {\n      if (timeIndex === -1 && columns[i].type === 'datetime') {\n        timeIndex = i;\n      }\n\n      if (metricIndex === -1 && columns[i].type === 'string') {\n        metricIndex = i;\n      }\n\n      if (valueIndex === -1 && ['int', 'long', 'real', 'double'].indexOf(columns[i].type) > -1) {\n        valueIndex = i;\n      }\n    }\n\n    if (timeIndex === -1) {\n      throw new Error('No datetime column found in the result. The Time Series format requires a time column.');\n    }\n\n    forEach(rows, (row) => {\n      const epoch = ResponseParser.dateTimeToEpoch(row[timeIndex]);\n      const metricName = metricIndex > -1 ? row[metricIndex] : columns[valueIndex].name;\n      const bucket = ResponseParser.findOrCreateBucket(data, metricName);\n      bucket.datapoints.push([row[valueIndex], epoch]);\n      bucket.refId = query.refId;\n      bucket.meta = {\n        executedQueryString: query.query,\n      };\n    });\n\n    return data;\n  }\n\n  parseTableResult(query: { refId: string; query: string }, columns: any[], rows: any[]): AzureLogsTableData {\n    const tableResult: AzureLogsTableData = {\n      type: 'table',\n      columns: map(columns, (col) => {\n        return { text: col.name, type: col.type };\n      }),\n      rows: rows,\n      refId: query.refId,\n      meta: {\n        executedQueryString: query.query,\n      },\n    };\n\n    return tableResult;\n  }\n\n  parseToVariables(): AzureLogsVariable[] {\n    const queryResult = this.parseQueryResult();\n\n    const variables: AzureLogsVariable[] = [];\n    forEach(queryResult, (result) => {\n      forEach(flattenDeep(result.rows), (row) => {\n        variables.push({\n          text: row,\n          value: row,\n        } as AzureLogsVariable);\n      });\n    });\n\n    return variables;\n  }\n\n  transformToAnnotations(options: any) {\n    const queryResult = this.parseQueryResult();\n\n    const list: AnnotationEvent[] = [];\n\n    forEach(queryResult, (result) => {\n      let timeIndex = -1;\n      let textIndex = -1;\n      let tagsIndex = -1;\n\n      for (let i = 0; i < result.columns.length; i++) {\n        if (timeIndex === -1 && result.columns[i].type === 'datetime') {\n          timeIndex = i;\n        }\n\n        if (textIndex === -1 && result.columns[i].text.toLowerCase() === 'text') {\n          textIndex = i;\n        }\n\n        if (tagsIndex === -1 && result.columns[i].text.toLowerCase() === 'tags') {\n          tagsIndex = i;\n        }\n      }\n\n      forEach(result.rows, (row) => {\n        list.push({\n          annotation: options.annotation,\n          time: Math.floor(ResponseParser.dateTimeToEpoch(row[timeIndex])),\n          text: row[textIndex] ? row[textIndex].toString() : '',\n          tags: row[tagsIndex] ? row[tagsIndex].trim().split(/\\s*,\\s*/) : [],\n        });\n      });\n    });\n\n    return list;\n  }\n\n  static findOrCreateBucket(data: TimeSeries[], target: any): TimeSeries {\n    let dataTarget: any = find(data, ['target', target]);\n    if (!dataTarget) {\n      dataTarget = { target: target, datapoints: [], refId: '', query: '' };\n      data.push(dataTarget);\n    }\n\n    return dataTarget;\n  }\n\n  static dateTimeToEpoch(dateTimeValue: any) {\n    return dateTime(dateTimeValue).valueOf();\n  }\n\n  static parseSubscriptions(result: any): Array<{ text: string; value: string }> {\n    const list: Array<{ text: string; value: string }> = [];\n\n    if (!result) {\n      return list;\n    }\n\n    const valueFieldName = 'subscriptionId';\n    const textFieldName = 'displayName';\n    for (let i = 0; i < result.value.length; i++) {\n      if (!find(list, ['value', get(result.value[i], valueFieldName)])) {\n        list.push({\n          text: `${get(result.value[i], textFieldName)}`,\n          value: get(result.value[i], valueFieldName),\n        });\n      }\n    }\n\n    return list;\n  }\n}\n\n// matches (name):(type) = (defaultValue)\n// e.g. fromRangeStart:datetime = datetime(null)\n//  - name: fromRangeStart\n//  - type: datetime\n//  - defaultValue: datetime(null)\nconst METADATA_FUNCTION_PARAMS = /([\\w\\W]+):([\\w]+)(?:\\s?=\\s?([\\w\\W]+))?/;\n\nfunction transformMetadataFunction(sourceSchema: AzureLogAnalyticsMetadata) {\n  if (!sourceSchema.functions) {\n    return [];\n  }\n\n  return sourceSchema.functions.map((fn) => {\n    const params =\n      fn.parameters &&\n      fn.parameters\n        .split(', ')\n        .map((arg) => {\n          const match = arg.match(METADATA_FUNCTION_PARAMS);\n          if (!match) {\n            return;\n          }\n\n          const [, name, type, defaultValue] = match;\n\n          return {\n            name,\n            type,\n            defaultValue,\n            cslDefaultValue: defaultValue,\n          };\n        })\n        .filter(<T>(v: T): v is Exclude<T, undefined> => !!v);\n\n    return {\n      name: fn.name,\n      body: fn.body,\n      inputParameters: params || [],\n    };\n  });\n}\n\nexport function transformMetadataToKustoSchema(\n  sourceSchema: AzureLogAnalyticsMetadata,\n  nameOrIdOrSomething: string,\n  templateVariables: VariableModel[]\n) {\n  const database = {\n    name: nameOrIdOrSomething,\n    tables: sourceSchema.tables,\n    functions: transformMetadataFunction(sourceSchema),\n    majorVersion: 0,\n    minorVersion: 0,\n  };\n\n  // Adding macros as known functions\n  database.functions.push(\n    {\n      name: '$__timeFilter',\n      body: '{ true }',\n      inputParameters: [\n        {\n          name: 'timeColumn',\n          type: 'System.String',\n          defaultValue: '\"\"',\n          cslDefaultValue: '\"\"',\n        },\n      ],\n    },\n    {\n      name: '$__timeFrom',\n      body: '{ datetime(2018-06-05T18:09:58.907Z) }',\n      inputParameters: [],\n    },\n    {\n      name: '$__timeTo',\n      body: '{ datetime(2018-06-05T20:09:58.907Z) }',\n      inputParameters: [],\n    },\n    {\n      name: '$__escapeMulti',\n      body: `{ @'\\\\grafana-vm\\Network(eth0)\\Total', @'\\\\hello!'}`,\n      inputParameters: [\n        {\n          name: '$myVar',\n          type: 'System.String',\n          defaultValue: '$myVar',\n          cslDefaultValue: '$myVar',\n        },\n      ],\n    },\n    {\n      name: '$__contains',\n      body: `{ colName in ('value1','value2') }`,\n      inputParameters: [\n        {\n          name: 'colName',\n          type: 'System.String',\n          defaultValue: 'colName',\n          cslDefaultValue: 'colName',\n        },\n        {\n          name: '$myVar',\n          type: 'System.String',\n          defaultValue: '$myVar',\n          cslDefaultValue: '$myVar',\n        },\n      ],\n    }\n  );\n\n  // Adding macros as global parameters\n  const globalParameters = templateVariables.map((v) => {\n    return {\n      name: `$${v.name}`,\n      type: 'dynamic',\n    };\n  });\n\n  return {\n    clusterType: 'Engine',\n    cluster: {\n      connectionString: nameOrIdOrSomething,\n      databases: [database],\n    },\n    database: database,\n    globalParameters,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}