{"ast":null,"code":"import { Registry } from '@grafana/data';\nexport let FieldExtractorID;\n\n(function (FieldExtractorID) {\n  FieldExtractorID[\"JSON\"] = \"json\";\n  FieldExtractorID[\"KeyValues\"] = \"kvp\";\n  FieldExtractorID[\"Auto\"] = \"auto\";\n})(FieldExtractorID || (FieldExtractorID = {}));\n\nconst extJSON = {\n  id: FieldExtractorID.JSON,\n  name: 'JSON',\n  description: 'Parse JSON string',\n  parse: v => {\n    return JSON.parse(v);\n  }\n};\n\nfunction parseKeyValuePairs(raw) {\n  const buff = []; // array of characters\n\n  let esc = '';\n  let key = '';\n  const obj = {};\n\n  for (let i = 0; i < raw.length; i++) {\n    let c = raw[i];\n\n    if (c === esc) {\n      esc = '';\n      c = raw[++i];\n    }\n\n    const isEscaped = c === '\\\\';\n\n    if (isEscaped) {\n      c = raw[++i];\n    } // When escaped just append\n\n\n    if (isEscaped || esc.length) {\n      buff.push(c);\n      continue;\n    }\n\n    if (c === `\"` || c === `'`) {\n      esc = c;\n    }\n\n    switch (c) {\n      case ':':\n      case '=':\n        if (buff.length) {\n          if (key) {\n            obj[key] = '';\n          }\n\n          key = buff.join('');\n          buff.length = 0; // clear values\n        }\n\n        break;\n      // escape chars\n\n      case `\"`:\n      case `'`: // whitespace\n\n      case ` `:\n      case `\\n`:\n      case `\\t`:\n      case `\\r`:\n      case `\\n`:\n        if (buff.length && key === '') {\n          obj[buff.join('')] = '';\n          buff.length = 0;\n        }\n\n      // seperators\n\n      case ',':\n      case ';':\n      case '&':\n      case '{':\n      case '}':\n        if (buff.length) {\n          const val = buff.join('');\n\n          if (key.length) {\n            obj[key] = val;\n            key = '';\n          } else {\n            key = val;\n          }\n\n          buff.length = 0; // clear values\n        }\n\n        break;\n      // append our buffer\n\n      default:\n        buff.push(c);\n\n        if (i === raw.length - 1) {\n          if (key === '' && buff.length) {\n            obj[buff.join('')] = '';\n            buff.length = 0;\n          }\n        }\n\n    }\n  }\n\n  if (key.length) {\n    obj[key] = buff.join('');\n  }\n\n  return obj;\n}\n\nconst extLabels = {\n  id: FieldExtractorID.KeyValues,\n  name: 'Key+value pairs',\n  description: 'Look for a=b, c: d values in the line',\n  parse: parseKeyValuePairs\n};\nconst fmts = [extJSON, extLabels];\nconst extAuto = {\n  id: FieldExtractorID.Auto,\n  name: 'Auto',\n  description: 'parse new fields automatically',\n  parse: v => {\n    for (const f of fmts) {\n      try {\n        const r = f.parse(v);\n\n        if (r != null) {\n          return r;\n        }\n      } catch {} // ignore errors\n\n    }\n\n    return undefined;\n  }\n};\nexport const fieldExtractors = new Registry(() => [...fmts, extAuto]);","map":{"version":3,"names":["Registry","FieldExtractorID","extJSON","id","JSON","name","description","parse","v","parseKeyValuePairs","raw","buff","esc","key","obj","i","length","c","isEscaped","push","join","val","extLabels","KeyValues","fmts","extAuto","Auto","f","r","undefined","fieldExtractors"],"sources":["/home/soula/grafana/public/app/features/transformers/extractFields/fieldExtractors.ts"],"sourcesContent":["import { Registry, RegistryItem } from '@grafana/data';\n\nexport enum FieldExtractorID {\n  JSON = 'json',\n  KeyValues = 'kvp',\n  Auto = 'auto',\n}\n\nexport interface FieldExtractor extends RegistryItem {\n  parse: (v: string) => Record<string, any> | undefined;\n}\n\nconst extJSON: FieldExtractor = {\n  id: FieldExtractorID.JSON,\n  name: 'JSON',\n  description: 'Parse JSON string',\n  parse: (v: string) => {\n    return JSON.parse(v);\n  },\n};\n\nfunction parseKeyValuePairs(raw: string): Record<string, string> {\n  const buff: string[] = []; // array of characters\n  let esc = '';\n  let key = '';\n  const obj: Record<string, string> = {};\n  for (let i = 0; i < raw.length; i++) {\n    let c = raw[i];\n    if (c === esc) {\n      esc = '';\n      c = raw[++i];\n    }\n\n    const isEscaped = c === '\\\\';\n    if (isEscaped) {\n      c = raw[++i];\n    }\n\n    // When escaped just append\n    if (isEscaped || esc.length) {\n      buff.push(c);\n      continue;\n    }\n\n    if (c === `\"` || c === `'`) {\n      esc = c;\n    }\n\n    switch (c) {\n      case ':':\n      case '=':\n        if (buff.length) {\n          if (key) {\n            obj[key] = '';\n          }\n          key = buff.join('');\n          buff.length = 0; // clear values\n        }\n        break;\n\n      // escape chars\n      case `\"`:\n      case `'`:\n      // whitespace\n      case ` `:\n      case `\\n`:\n      case `\\t`:\n      case `\\r`:\n      case `\\n`:\n        if (buff.length && key === '') {\n          obj[buff.join('')] = '';\n          buff.length = 0;\n        }\n      // seperators\n      case ',':\n      case ';':\n      case '&':\n      case '{':\n      case '}':\n        if (buff.length) {\n          const val = buff.join('');\n          if (key.length) {\n            obj[key] = val;\n            key = '';\n          } else {\n            key = val;\n          }\n          buff.length = 0; // clear values\n        }\n        break;\n\n      // append our buffer\n      default:\n        buff.push(c);\n        if (i === raw.length - 1) {\n          if (key === '' && buff.length) {\n            obj[buff.join('')] = '';\n            buff.length = 0;\n          }\n        }\n    }\n  }\n\n  if (key.length) {\n    obj[key] = buff.join('');\n  }\n  return obj;\n}\n\nconst extLabels: FieldExtractor = {\n  id: FieldExtractorID.KeyValues,\n  name: 'Key+value pairs',\n  description: 'Look for a=b, c: d values in the line',\n  parse: parseKeyValuePairs,\n};\n\nconst fmts = [extJSON, extLabels];\n\nconst extAuto: FieldExtractor = {\n  id: FieldExtractorID.Auto,\n  name: 'Auto',\n  description: 'parse new fields automatically',\n  parse: (v: string) => {\n    for (const f of fmts) {\n      try {\n        const r = f.parse(v);\n        if (r != null) {\n          return r;\n        }\n      } catch {} // ignore errors\n    }\n    return undefined;\n  },\n};\n\nexport const fieldExtractors = new Registry<FieldExtractor>(() => [...fmts, extAuto]);\n"],"mappings":"AAAA,SAASA,QAAT,QAAuC,eAAvC;AAEA,WAAYC,gBAAZ;;WAAYA,gB;EAAAA,gB;EAAAA,gB;EAAAA,gB;GAAAA,gB,KAAAA,gB;;AAUZ,MAAMC,OAAuB,GAAG;EAC9BC,EAAE,EAAEF,gBAAgB,CAACG,IADS;EAE9BC,IAAI,EAAE,MAFwB;EAG9BC,WAAW,EAAE,mBAHiB;EAI9BC,KAAK,EAAGC,CAAD,IAAe;IACpB,OAAOJ,IAAI,CAACG,KAAL,CAAWC,CAAX,CAAP;EACD;AAN6B,CAAhC;;AASA,SAASC,kBAAT,CAA4BC,GAA5B,EAAiE;EAC/D,MAAMC,IAAc,GAAG,EAAvB,CAD+D,CACpC;;EAC3B,IAAIC,GAAG,GAAG,EAAV;EACA,IAAIC,GAAG,GAAG,EAAV;EACA,MAAMC,GAA2B,GAAG,EAApC;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAAG,CAACM,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;IACnC,IAAIE,CAAC,GAAGP,GAAG,CAACK,CAAD,CAAX;;IACA,IAAIE,CAAC,KAAKL,GAAV,EAAe;MACbA,GAAG,GAAG,EAAN;MACAK,CAAC,GAAGP,GAAG,CAAC,EAAEK,CAAH,CAAP;IACD;;IAED,MAAMG,SAAS,GAAGD,CAAC,KAAK,IAAxB;;IACA,IAAIC,SAAJ,EAAe;MACbD,CAAC,GAAGP,GAAG,CAAC,EAAEK,CAAH,CAAP;IACD,CAVkC,CAYnC;;;IACA,IAAIG,SAAS,IAAIN,GAAG,CAACI,MAArB,EAA6B;MAC3BL,IAAI,CAACQ,IAAL,CAAUF,CAAV;MACA;IACD;;IAED,IAAIA,CAAC,KAAM,GAAP,IAAaA,CAAC,KAAM,GAAxB,EAA4B;MAC1BL,GAAG,GAAGK,CAAN;IACD;;IAED,QAAQA,CAAR;MACE,KAAK,GAAL;MACA,KAAK,GAAL;QACE,IAAIN,IAAI,CAACK,MAAT,EAAiB;UACf,IAAIH,GAAJ,EAAS;YACPC,GAAG,CAACD,GAAD,CAAH,GAAW,EAAX;UACD;;UACDA,GAAG,GAAGF,IAAI,CAACS,IAAL,CAAU,EAAV,CAAN;UACAT,IAAI,CAACK,MAAL,GAAc,CAAd,CALe,CAKE;QAClB;;QACD;MAEF;;MACA,KAAM,GAAN;MACA,KAAM,GAAN,CAdF,CAeE;;MACA,KAAM,GAAN;MACA,KAAM,IAAN;MACA,KAAM,IAAN;MACA,KAAM,IAAN;MACA,KAAM,IAAN;QACE,IAAIL,IAAI,CAACK,MAAL,IAAeH,GAAG,KAAK,EAA3B,EAA+B;UAC7BC,GAAG,CAACH,IAAI,CAACS,IAAL,CAAU,EAAV,CAAD,CAAH,GAAqB,EAArB;UACAT,IAAI,CAACK,MAAL,GAAc,CAAd;QACD;;MACH;;MACA,KAAK,GAAL;MACA,KAAK,GAAL;MACA,KAAK,GAAL;MACA,KAAK,GAAL;MACA,KAAK,GAAL;QACE,IAAIL,IAAI,CAACK,MAAT,EAAiB;UACf,MAAMK,GAAG,GAAGV,IAAI,CAACS,IAAL,CAAU,EAAV,CAAZ;;UACA,IAAIP,GAAG,CAACG,MAAR,EAAgB;YACdF,GAAG,CAACD,GAAD,CAAH,GAAWQ,GAAX;YACAR,GAAG,GAAG,EAAN;UACD,CAHD,MAGO;YACLA,GAAG,GAAGQ,GAAN;UACD;;UACDV,IAAI,CAACK,MAAL,GAAc,CAAd,CARe,CAQE;QAClB;;QACD;MAEF;;MACA;QACEL,IAAI,CAACQ,IAAL,CAAUF,CAAV;;QACA,IAAIF,CAAC,KAAKL,GAAG,CAACM,MAAJ,GAAa,CAAvB,EAA0B;UACxB,IAAIH,GAAG,KAAK,EAAR,IAAcF,IAAI,CAACK,MAAvB,EAA+B;YAC7BF,GAAG,CAACH,IAAI,CAACS,IAAL,CAAU,EAAV,CAAD,CAAH,GAAqB,EAArB;YACAT,IAAI,CAACK,MAAL,GAAc,CAAd;UACD;QACF;;IAnDL;EAqDD;;EAED,IAAIH,GAAG,CAACG,MAAR,EAAgB;IACdF,GAAG,CAACD,GAAD,CAAH,GAAWF,IAAI,CAACS,IAAL,CAAU,EAAV,CAAX;EACD;;EACD,OAAON,GAAP;AACD;;AAED,MAAMQ,SAAyB,GAAG;EAChCnB,EAAE,EAAEF,gBAAgB,CAACsB,SADW;EAEhClB,IAAI,EAAE,iBAF0B;EAGhCC,WAAW,EAAE,uCAHmB;EAIhCC,KAAK,EAAEE;AAJyB,CAAlC;AAOA,MAAMe,IAAI,GAAG,CAACtB,OAAD,EAAUoB,SAAV,CAAb;AAEA,MAAMG,OAAuB,GAAG;EAC9BtB,EAAE,EAAEF,gBAAgB,CAACyB,IADS;EAE9BrB,IAAI,EAAE,MAFwB;EAG9BC,WAAW,EAAE,gCAHiB;EAI9BC,KAAK,EAAGC,CAAD,IAAe;IACpB,KAAK,MAAMmB,CAAX,IAAgBH,IAAhB,EAAsB;MACpB,IAAI;QACF,MAAMI,CAAC,GAAGD,CAAC,CAACpB,KAAF,CAAQC,CAAR,CAAV;;QACA,IAAIoB,CAAC,IAAI,IAAT,EAAe;UACb,OAAOA,CAAP;QACD;MACF,CALD,CAKE,MAAM,CAAE,CANU,CAMT;;IACZ;;IACD,OAAOC,SAAP;EACD;AAd6B,CAAhC;AAiBA,OAAO,MAAMC,eAAe,GAAG,IAAI9B,QAAJ,CAA6B,MAAM,CAAC,GAAGwB,IAAJ,EAAUC,OAAV,CAAnC,CAAxB"},"metadata":{},"sourceType":"module"}