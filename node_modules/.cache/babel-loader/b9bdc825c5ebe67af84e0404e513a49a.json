{"ast":null,"code":"import { createAction } from '@reduxjs/toolkit';\nimport { config, logError } from '@grafana/runtime';\nimport { RICH_HISTORY_SETTING_KEYS } from 'app/core/history/richHistoryLocalStorageUtils';\nimport store from 'app/core/store';\nimport { addToRichHistory, deleteAllFromRichHistory, deleteQueryInRichHistory, getRichHistory, getRichHistorySettings, LocalStorageMigrationStatus, migrateQueryHistoryFromLocalStorage, updateCommentInRichHistory, updateRichHistorySettings, updateStarredInRichHistory } from 'app/core/utils/richHistory';\nimport { ExploreId } from 'app/types';\nimport { supportedFeatures } from '../../../core/history/richHistoryStorageProvider';\nimport { richHistoryLimitExceededAction, richHistoryMigrationFailedAction, richHistorySearchFiltersUpdatedAction, richHistorySettingsUpdatedAction, richHistoryStorageFullAction, richHistoryUpdatedAction } from './main'; //\n// Actions and Payloads\n//\n\nexport const historyUpdatedAction = createAction('explore/historyUpdated'); //\n// Action creators\n//\n\n/**\n * Updates current state in both Explore panes after changing or deleting a query history item\n */\nconst updateRichHistoryState = ({\n  updatedQuery,\n  deletedId\n}) => {\n  return async (dispatch, getState) => {\n    forEachExplorePane(getState().explore, (item, exploreId) => {\n      const newRichHistory = item.richHistory // update\n      .map(query => query.id === (updatedQuery === null || updatedQuery === void 0 ? void 0 : updatedQuery.id) ? updatedQuery : query) // or remove\n      .filter(query => query.id !== deletedId);\n      const deletedItems = item.richHistory.length - newRichHistory.length;\n      dispatch(richHistoryUpdatedAction({\n        richHistoryResults: {\n          richHistory: newRichHistory,\n          total: item.richHistoryTotal - deletedItems\n        },\n        exploreId\n      }));\n    });\n  };\n};\n\nconst forEachExplorePane = (state, callback) => {\n  callback(state.left, ExploreId.left);\n  state.right && callback(state.right, ExploreId.right);\n};\n\nexport const addHistoryItem = (datasourceUid, datasourceName, queries) => {\n  return async (dispatch, getState) => {\n    const {\n      richHistoryStorageFull,\n      limitExceeded\n    } = await addToRichHistory(datasourceUid, datasourceName, queries, false, '', !getState().explore.richHistoryStorageFull, !getState().explore.richHistoryLimitExceededWarningShown);\n\n    if (richHistoryStorageFull) {\n      dispatch(richHistoryStorageFullAction());\n    }\n\n    if (limitExceeded) {\n      dispatch(richHistoryLimitExceededAction());\n    }\n  };\n};\nexport const starHistoryItem = (id, starred) => {\n  return async (dispatch, getState) => {\n    const updatedQuery = await updateStarredInRichHistory(id, starred);\n    dispatch(updateRichHistoryState({\n      updatedQuery\n    }));\n  };\n};\nexport const commentHistoryItem = (id, comment) => {\n  return async dispatch => {\n    const updatedQuery = await updateCommentInRichHistory(id, comment);\n    dispatch(updateRichHistoryState({\n      updatedQuery\n    }));\n  };\n};\nexport const deleteHistoryItem = id => {\n  return async dispatch => {\n    const deletedId = await deleteQueryInRichHistory(id);\n    dispatch(updateRichHistoryState({\n      deletedId\n    }));\n  };\n};\nexport const deleteRichHistory = () => {\n  return async dispatch => {\n    await deleteAllFromRichHistory();\n    dispatch(richHistoryUpdatedAction({\n      richHistoryResults: {\n        richHistory: [],\n        total: 0\n      },\n      exploreId: ExploreId.left\n    }));\n    dispatch(richHistoryUpdatedAction({\n      richHistoryResults: {\n        richHistory: [],\n        total: 0\n      },\n      exploreId: ExploreId.right\n    }));\n  };\n};\nexport const loadRichHistory = exploreId => {\n  return async (dispatch, getState) => {\n    var _exploreId;\n\n    const filters = (_exploreId = getState().explore[exploreId]) === null || _exploreId === void 0 ? void 0 : _exploreId.richHistorySearchFilters;\n\n    if (filters) {\n      const richHistoryResults = await getRichHistory(filters);\n      dispatch(richHistoryUpdatedAction({\n        richHistoryResults,\n        exploreId\n      }));\n    }\n  };\n};\nexport const loadMoreRichHistory = exploreId => {\n  return async (dispatch, getState) => {\n    var _exploreId2, _exploreId3;\n\n    const currentFilters = (_exploreId2 = getState().explore[exploreId]) === null || _exploreId2 === void 0 ? void 0 : _exploreId2.richHistorySearchFilters;\n    const currentRichHistory = (_exploreId3 = getState().explore[exploreId]) === null || _exploreId3 === void 0 ? void 0 : _exploreId3.richHistory;\n\n    if (currentFilters && currentRichHistory) {\n      const nextFilters = Object.assign({}, currentFilters, {\n        page: ((currentFilters === null || currentFilters === void 0 ? void 0 : currentFilters.page) || 1) + 1\n      });\n      const moreRichHistory = await getRichHistory(nextFilters);\n      const richHistory = [...currentRichHistory, ...moreRichHistory.richHistory];\n      dispatch(richHistorySearchFiltersUpdatedAction({\n        filters: nextFilters,\n        exploreId\n      }));\n      dispatch(richHistoryUpdatedAction({\n        richHistoryResults: {\n          richHistory,\n          total: moreRichHistory.total\n        },\n        exploreId\n      }));\n    }\n  };\n};\nexport const clearRichHistoryResults = exploreId => {\n  return async dispatch => {\n    dispatch(richHistorySearchFiltersUpdatedAction({\n      filters: undefined,\n      exploreId\n    }));\n    dispatch(richHistoryUpdatedAction({\n      richHistoryResults: {\n        richHistory: [],\n        total: 0\n      },\n      exploreId\n    }));\n  };\n};\n/**\n * Initialize query history pane. To load history it requires settings to be loaded first\n * (but only once per session). Filters are initialised by the tab (starred or home).\n */\n\nexport const initRichHistory = () => {\n  return async (dispatch, getState) => {\n    const queriesMigrated = store.getBool(RICH_HISTORY_SETTING_KEYS.migrated, false);\n    const migrationFailedDuringThisSession = getState().explore.richHistoryMigrationFailed; // Query history migration should always be successful, but in case of unexpected errors we ensure\n    // the migration attempt happens only once per session, and the user is informed about the failure\n    // in a way that can help with potential investigation.\n\n    if (config.queryHistoryEnabled && !queriesMigrated && !migrationFailedDuringThisSession) {\n      const migrationResult = await migrateQueryHistoryFromLocalStorage();\n\n      if (migrationResult.status === LocalStorageMigrationStatus.Failed) {\n        dispatch(richHistoryMigrationFailedAction());\n        logError(migrationResult.error, {\n          explore: {\n            event: 'QueryHistoryMigrationFailed'\n          }\n        });\n      } else {\n        store.set(RICH_HISTORY_SETTING_KEYS.migrated, true);\n      }\n    }\n\n    let settings = getState().explore.richHistorySettings;\n\n    if (!settings) {\n      settings = await getRichHistorySettings();\n      dispatch(richHistorySettingsUpdatedAction(settings));\n    }\n  };\n};\nexport const updateHistorySettings = settings => {\n  return async dispatch => {\n    dispatch(richHistorySettingsUpdatedAction(settings));\n    await updateRichHistorySettings(settings);\n  };\n};\n/**\n * Assumed this can be called only when settings and filters are initialised\n */\n\nexport const updateHistorySearchFilters = (exploreId, filters) => {\n  return async (dispatch, getState) => {\n    await dispatch(richHistorySearchFiltersUpdatedAction({\n      exploreId,\n      filters: Object.assign({}, filters)\n    }));\n    const currentSettings = getState().explore.richHistorySettings;\n\n    if (supportedFeatures().lastUsedDataSourcesAvailable) {\n      await dispatch(updateHistorySettings(Object.assign({}, currentSettings, {\n        lastUsedDatasourceFilters: filters.datasourceFilters\n      })));\n    }\n  };\n};\nexport const historyReducer = (state, action) => {\n  if (historyUpdatedAction.match(action)) {\n    return Object.assign({}, state, {\n      history: action.payload.history\n    });\n  }\n\n  return state;\n};","map":{"version":3,"names":["createAction","config","logError","RICH_HISTORY_SETTING_KEYS","store","addToRichHistory","deleteAllFromRichHistory","deleteQueryInRichHistory","getRichHistory","getRichHistorySettings","LocalStorageMigrationStatus","migrateQueryHistoryFromLocalStorage","updateCommentInRichHistory","updateRichHistorySettings","updateStarredInRichHistory","ExploreId","supportedFeatures","richHistoryLimitExceededAction","richHistoryMigrationFailedAction","richHistorySearchFiltersUpdatedAction","richHistorySettingsUpdatedAction","richHistoryStorageFullAction","richHistoryUpdatedAction","historyUpdatedAction","updateRichHistoryState","updatedQuery","deletedId","dispatch","getState","forEachExplorePane","explore","item","exploreId","newRichHistory","richHistory","map","query","id","filter","deletedItems","length","richHistoryResults","total","richHistoryTotal","state","callback","left","right","addHistoryItem","datasourceUid","datasourceName","queries","richHistoryStorageFull","limitExceeded","richHistoryLimitExceededWarningShown","starHistoryItem","starred","commentHistoryItem","comment","deleteHistoryItem","deleteRichHistory","loadRichHistory","filters","richHistorySearchFilters","loadMoreRichHistory","currentFilters","currentRichHistory","nextFilters","page","moreRichHistory","clearRichHistoryResults","undefined","initRichHistory","queriesMigrated","getBool","migrated","migrationFailedDuringThisSession","richHistoryMigrationFailed","queryHistoryEnabled","migrationResult","status","Failed","error","event","set","settings","richHistorySettings","updateHistorySettings","updateHistorySearchFilters","currentSettings","lastUsedDataSourcesAvailable","lastUsedDatasourceFilters","datasourceFilters","historyReducer","action","match","history","payload"],"sources":["/home/soula/grafana/public/app/features/explore/state/history.ts"],"sourcesContent":["import { AnyAction, createAction } from '@reduxjs/toolkit';\n\nimport { DataQuery, HistoryItem } from '@grafana/data';\nimport { config, logError } from '@grafana/runtime';\nimport { RICH_HISTORY_SETTING_KEYS } from 'app/core/history/richHistoryLocalStorageUtils';\nimport store from 'app/core/store';\nimport {\n  addToRichHistory,\n  deleteAllFromRichHistory,\n  deleteQueryInRichHistory,\n  getRichHistory,\n  getRichHistorySettings,\n  LocalStorageMigrationStatus,\n  migrateQueryHistoryFromLocalStorage,\n  updateCommentInRichHistory,\n  updateRichHistorySettings,\n  updateStarredInRichHistory,\n} from 'app/core/utils/richHistory';\nimport { ExploreId, ExploreItemState, ExploreState, RichHistoryQuery, ThunkResult } from 'app/types';\n\nimport { supportedFeatures } from '../../../core/history/richHistoryStorageProvider';\nimport { RichHistorySearchFilters, RichHistorySettings } from '../../../core/utils/richHistoryTypes';\n\nimport {\n  richHistoryLimitExceededAction,\n  richHistoryMigrationFailedAction,\n  richHistorySearchFiltersUpdatedAction,\n  richHistorySettingsUpdatedAction,\n  richHistoryStorageFullAction,\n  richHistoryUpdatedAction,\n} from './main';\n\n//\n// Actions and Payloads\n//\n\nexport interface HistoryUpdatedPayload {\n  exploreId: ExploreId;\n  history: HistoryItem[];\n}\nexport const historyUpdatedAction = createAction<HistoryUpdatedPayload>('explore/historyUpdated');\n\n//\n// Action creators\n//\n\ntype SyncHistoryUpdatesOptions = {\n  updatedQuery?: RichHistoryQuery;\n  deletedId?: string;\n};\n\n/**\n * Updates current state in both Explore panes after changing or deleting a query history item\n */\nconst updateRichHistoryState = ({ updatedQuery, deletedId }: SyncHistoryUpdatesOptions): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    forEachExplorePane(getState().explore, (item, exploreId) => {\n      const newRichHistory = item.richHistory\n        // update\n        .map((query) => (query.id === updatedQuery?.id ? updatedQuery : query))\n        // or remove\n        .filter((query) => query.id !== deletedId);\n      const deletedItems = item.richHistory.length - newRichHistory.length;\n      dispatch(\n        richHistoryUpdatedAction({\n          richHistoryResults: { richHistory: newRichHistory, total: item.richHistoryTotal! - deletedItems },\n          exploreId,\n        })\n      );\n    });\n  };\n};\n\nconst forEachExplorePane = (state: ExploreState, callback: (item: ExploreItemState, exploreId: ExploreId) => void) => {\n  callback(state.left, ExploreId.left);\n  state.right && callback(state.right, ExploreId.right);\n};\n\nexport const addHistoryItem = (\n  datasourceUid: string,\n  datasourceName: string,\n  queries: DataQuery[]\n): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    const { richHistoryStorageFull, limitExceeded } = await addToRichHistory(\n      datasourceUid,\n      datasourceName,\n      queries,\n      false,\n      '',\n      !getState().explore.richHistoryStorageFull,\n      !getState().explore.richHistoryLimitExceededWarningShown\n    );\n    if (richHistoryStorageFull) {\n      dispatch(richHistoryStorageFullAction());\n    }\n    if (limitExceeded) {\n      dispatch(richHistoryLimitExceededAction());\n    }\n  };\n};\n\nexport const starHistoryItem = (id: string, starred: boolean): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    const updatedQuery = await updateStarredInRichHistory(id, starred);\n    dispatch(updateRichHistoryState({ updatedQuery }));\n  };\n};\n\nexport const commentHistoryItem = (id: string, comment?: string): ThunkResult<void> => {\n  return async (dispatch) => {\n    const updatedQuery = await updateCommentInRichHistory(id, comment);\n    dispatch(updateRichHistoryState({ updatedQuery }));\n  };\n};\n\nexport const deleteHistoryItem = (id: string): ThunkResult<void> => {\n  return async (dispatch) => {\n    const deletedId = await deleteQueryInRichHistory(id);\n    dispatch(updateRichHistoryState({ deletedId }));\n  };\n};\n\nexport const deleteRichHistory = (): ThunkResult<void> => {\n  return async (dispatch) => {\n    await deleteAllFromRichHistory();\n    dispatch(\n      richHistoryUpdatedAction({ richHistoryResults: { richHistory: [], total: 0 }, exploreId: ExploreId.left })\n    );\n    dispatch(\n      richHistoryUpdatedAction({ richHistoryResults: { richHistory: [], total: 0 }, exploreId: ExploreId.right })\n    );\n  };\n};\n\nexport const loadRichHistory = (exploreId: ExploreId): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    const filters = getState().explore![exploreId]?.richHistorySearchFilters;\n    if (filters) {\n      const richHistoryResults = await getRichHistory(filters);\n      dispatch(richHistoryUpdatedAction({ richHistoryResults, exploreId }));\n    }\n  };\n};\n\nexport const loadMoreRichHistory = (exploreId: ExploreId): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    const currentFilters = getState().explore![exploreId]?.richHistorySearchFilters;\n    const currentRichHistory = getState().explore![exploreId]?.richHistory;\n    if (currentFilters && currentRichHistory) {\n      const nextFilters = { ...currentFilters, page: (currentFilters?.page || 1) + 1 };\n      const moreRichHistory = await getRichHistory(nextFilters);\n      const richHistory = [...currentRichHistory, ...moreRichHistory.richHistory];\n      dispatch(richHistorySearchFiltersUpdatedAction({ filters: nextFilters, exploreId }));\n      dispatch(\n        richHistoryUpdatedAction({ richHistoryResults: { richHistory, total: moreRichHistory.total }, exploreId })\n      );\n    }\n  };\n};\n\nexport const clearRichHistoryResults = (exploreId: ExploreId): ThunkResult<void> => {\n  return async (dispatch) => {\n    dispatch(richHistorySearchFiltersUpdatedAction({ filters: undefined, exploreId }));\n    dispatch(richHistoryUpdatedAction({ richHistoryResults: { richHistory: [], total: 0 }, exploreId }));\n  };\n};\n\n/**\n * Initialize query history pane. To load history it requires settings to be loaded first\n * (but only once per session). Filters are initialised by the tab (starred or home).\n */\nexport const initRichHistory = (): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    const queriesMigrated = store.getBool(RICH_HISTORY_SETTING_KEYS.migrated, false);\n    const migrationFailedDuringThisSession = getState().explore.richHistoryMigrationFailed;\n\n    // Query history migration should always be successful, but in case of unexpected errors we ensure\n    // the migration attempt happens only once per session, and the user is informed about the failure\n    // in a way that can help with potential investigation.\n    if (config.queryHistoryEnabled && !queriesMigrated && !migrationFailedDuringThisSession) {\n      const migrationResult = await migrateQueryHistoryFromLocalStorage();\n      if (migrationResult.status === LocalStorageMigrationStatus.Failed) {\n        dispatch(richHistoryMigrationFailedAction());\n        logError(migrationResult.error!, { explore: { event: 'QueryHistoryMigrationFailed' } });\n      } else {\n        store.set(RICH_HISTORY_SETTING_KEYS.migrated, true);\n      }\n    }\n    let settings = getState().explore.richHistorySettings;\n    if (!settings) {\n      settings = await getRichHistorySettings();\n      dispatch(richHistorySettingsUpdatedAction(settings));\n    }\n  };\n};\n\nexport const updateHistorySettings = (settings: RichHistorySettings): ThunkResult<void> => {\n  return async (dispatch) => {\n    dispatch(richHistorySettingsUpdatedAction(settings));\n    await updateRichHistorySettings(settings);\n  };\n};\n\n/**\n * Assumed this can be called only when settings and filters are initialised\n */\nexport const updateHistorySearchFilters = (\n  exploreId: ExploreId,\n  filters: RichHistorySearchFilters\n): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    await dispatch(richHistorySearchFiltersUpdatedAction({ exploreId, filters: { ...filters } }));\n    const currentSettings = getState().explore.richHistorySettings!;\n    if (supportedFeatures().lastUsedDataSourcesAvailable) {\n      await dispatch(\n        updateHistorySettings({\n          ...currentSettings,\n          lastUsedDatasourceFilters: filters.datasourceFilters,\n        })\n      );\n    }\n  };\n};\n\nexport const historyReducer = (state: ExploreItemState, action: AnyAction): ExploreItemState => {\n  if (historyUpdatedAction.match(action)) {\n    return {\n      ...state,\n      history: action.payload.history,\n    };\n  }\n  return state;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}