{"ast":null,"code":"import { ArrayVector, FieldColorModeId, FieldType, MutableDataFrame, NodeGraphDataFrameFieldNames } from '@grafana/data';\nimport { nodes, edges } from './testData/serviceMapResponse';\nexport function generateRandomNodes(count = 10) {\n  const nodes = [];\n  const root = {\n    id: '0',\n    title: 'root',\n    subTitle: 'client',\n    success: 1,\n    error: 0,\n    stat1: Math.random(),\n    stat2: Math.random(),\n    edges: []\n  };\n  nodes.push(root);\n  const nodesWithoutMaxEdges = [root];\n  const maxEdges = 3;\n\n  for (let i = 1; i < count; i++) {\n    const node = makeRandomNode(i);\n    nodes.push(node);\n    const sourceIndex = Math.floor(Math.random() * Math.floor(nodesWithoutMaxEdges.length - 1));\n    const source = nodesWithoutMaxEdges[sourceIndex];\n    source.edges.push(node.id);\n\n    if (source.edges.length >= maxEdges) {\n      nodesWithoutMaxEdges.splice(sourceIndex, 1);\n    }\n\n    nodesWithoutMaxEdges.push(node);\n  } // Add some random edges to create possible cycle\n\n\n  const additionalEdges = Math.floor(count / 2);\n\n  for (let i = 0; i <= additionalEdges; i++) {\n    const sourceIndex = Math.floor(Math.random() * Math.floor(nodes.length - 1));\n    const targetIndex = Math.floor(Math.random() * Math.floor(nodes.length - 1));\n\n    if (sourceIndex === targetIndex || nodes[sourceIndex].id === '0' || nodes[sourceIndex].id === '0') {\n      continue;\n    }\n\n    nodes[sourceIndex].edges.push(nodes[sourceIndex].id);\n  }\n\n  const nodeFields = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    },\n    [NodeGraphDataFrameFieldNames.title]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    },\n    [NodeGraphDataFrameFieldNames.subTitle]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    },\n    [NodeGraphDataFrameFieldNames.mainStat]: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: {\n        displayName: 'Transactions per second'\n      }\n    },\n    [NodeGraphDataFrameFieldNames.secondaryStat]: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: {\n        displayName: 'Average duration'\n      }\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'success']: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: {\n        color: {\n          fixedColor: 'green',\n          mode: FieldColorModeId.Fixed\n        },\n        displayName: 'Success'\n      }\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'errors']: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: {\n        color: {\n          fixedColor: 'red',\n          mode: FieldColorModeId.Fixed\n        },\n        displayName: 'Errors'\n      }\n    }\n  };\n  const nodeFrame = new MutableDataFrame({\n    name: 'nodes',\n    fields: Object.keys(nodeFields).map(key => Object.assign({}, nodeFields[key], {\n      name: key\n    })),\n    meta: {\n      preferredVisualisationType: 'nodeGraph'\n    }\n  });\n  const edgeFields = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    },\n    [NodeGraphDataFrameFieldNames.source]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    },\n    [NodeGraphDataFrameFieldNames.target]: {\n      values: new ArrayVector(),\n      type: FieldType.string\n    }\n  };\n  const edgesFrame = new MutableDataFrame({\n    name: 'edges',\n    fields: Object.keys(edgeFields).map(key => Object.assign({}, edgeFields[key], {\n      name: key\n    })),\n    meta: {\n      preferredVisualisationType: 'nodeGraph'\n    }\n  });\n  const edgesSet = new Set();\n\n  for (const node of nodes) {\n    nodeFields.id.values.add(node.id);\n    nodeFields.title.values.add(node.title);\n    nodeFields.subTitle.values.add(node.subTitle);\n    nodeFields.mainStat.values.add(node.stat1);\n    nodeFields.secondaryStat.values.add(node.stat2);\n    nodeFields.arc__success.values.add(node.success);\n    nodeFields.arc__errors.values.add(node.error);\n\n    for (const edge of node.edges) {\n      const id = `${node.id}--${edge}`; // We can have duplicate edges when we added some more by random\n\n      if (edgesSet.has(id)) {\n        continue;\n      }\n\n      edgesSet.add(id);\n      edgeFields.id.values.add(`${node.id}--${edge}`);\n      edgeFields.source.values.add(node.id);\n      edgeFields.target.values.add(edge);\n    }\n  }\n\n  return [nodeFrame, edgesFrame];\n}\n\nfunction makeRandomNode(index) {\n  const success = Math.random();\n  const error = 1 - success;\n  return {\n    id: index.toString(),\n    title: `service:${index}`,\n    subTitle: 'service',\n    success,\n    error,\n    stat1: Math.random(),\n    stat2: Math.random(),\n    edges: []\n  };\n}\n\nexport function savedNodesResponse() {\n  return [new MutableDataFrame(nodes), new MutableDataFrame(edges)];\n}","map":{"version":3,"names":["ArrayVector","FieldColorModeId","FieldType","MutableDataFrame","NodeGraphDataFrameFieldNames","nodes","edges","generateRandomNodes","count","root","id","title","subTitle","success","error","stat1","Math","random","stat2","push","nodesWithoutMaxEdges","maxEdges","i","node","makeRandomNode","sourceIndex","floor","length","source","splice","additionalEdges","targetIndex","nodeFields","values","type","string","mainStat","number","config","displayName","secondaryStat","arc","color","fixedColor","mode","Fixed","nodeFrame","name","fields","Object","keys","map","key","meta","preferredVisualisationType","edgeFields","target","edgesFrame","edgesSet","Set","add","arc__success","arc__errors","edge","has","index","toString","savedNodesResponse"],"sources":["/home/soula/grafana/public/app/plugins/datasource/testdata/nodeGraphUtils.ts"],"sourcesContent":["import {\n  ArrayVector,\n  FieldColorModeId,\n  FieldDTO,\n  FieldType,\n  MutableDataFrame,\n  NodeGraphDataFrameFieldNames,\n} from '@grafana/data';\n\nimport { nodes, edges } from './testData/serviceMapResponse';\n\nexport function generateRandomNodes(count = 10) {\n  const nodes = [];\n\n  const root = {\n    id: '0',\n    title: 'root',\n    subTitle: 'client',\n    success: 1,\n    error: 0,\n    stat1: Math.random(),\n    stat2: Math.random(),\n    edges: [] as any[],\n  };\n  nodes.push(root);\n  const nodesWithoutMaxEdges = [root];\n\n  const maxEdges = 3;\n\n  for (let i = 1; i < count; i++) {\n    const node = makeRandomNode(i);\n    nodes.push(node);\n    const sourceIndex = Math.floor(Math.random() * Math.floor(nodesWithoutMaxEdges.length - 1));\n    const source = nodesWithoutMaxEdges[sourceIndex];\n    source.edges.push(node.id);\n    if (source.edges.length >= maxEdges) {\n      nodesWithoutMaxEdges.splice(sourceIndex, 1);\n    }\n    nodesWithoutMaxEdges.push(node);\n  }\n\n  // Add some random edges to create possible cycle\n  const additionalEdges = Math.floor(count / 2);\n  for (let i = 0; i <= additionalEdges; i++) {\n    const sourceIndex = Math.floor(Math.random() * Math.floor(nodes.length - 1));\n    const targetIndex = Math.floor(Math.random() * Math.floor(nodes.length - 1));\n    if (sourceIndex === targetIndex || nodes[sourceIndex].id === '0' || nodes[sourceIndex].id === '0') {\n      continue;\n    }\n\n    nodes[sourceIndex].edges.push(nodes[sourceIndex].id);\n  }\n\n  const nodeFields: Record<string, Omit<FieldDTO, 'name'> & { values: ArrayVector }> = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.title]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.subTitle]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.mainStat]: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: { displayName: 'Transactions per second' },\n    },\n    [NodeGraphDataFrameFieldNames.secondaryStat]: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: { displayName: 'Average duration' },\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'success']: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: { color: { fixedColor: 'green', mode: FieldColorModeId.Fixed }, displayName: 'Success' },\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'errors']: {\n      values: new ArrayVector(),\n      type: FieldType.number,\n      config: { color: { fixedColor: 'red', mode: FieldColorModeId.Fixed }, displayName: 'Errors' },\n    },\n  };\n\n  const nodeFrame = new MutableDataFrame({\n    name: 'nodes',\n    fields: Object.keys(nodeFields).map((key) => ({\n      ...nodeFields[key],\n      name: key,\n    })),\n    meta: { preferredVisualisationType: 'nodeGraph' },\n  });\n\n  const edgeFields: any = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.source]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.target]: {\n      values: new ArrayVector(),\n      type: FieldType.string,\n    },\n  };\n\n  const edgesFrame = new MutableDataFrame({\n    name: 'edges',\n    fields: Object.keys(edgeFields).map((key) => ({\n      ...edgeFields[key],\n      name: key,\n    })),\n    meta: { preferredVisualisationType: 'nodeGraph' },\n  });\n\n  const edgesSet = new Set();\n  for (const node of nodes) {\n    nodeFields.id.values.add(node.id);\n    nodeFields.title.values.add(node.title);\n    nodeFields.subTitle.values.add(node.subTitle);\n    nodeFields.mainStat.values.add(node.stat1);\n    nodeFields.secondaryStat.values.add(node.stat2);\n    nodeFields.arc__success.values.add(node.success);\n    nodeFields.arc__errors.values.add(node.error);\n    for (const edge of node.edges) {\n      const id = `${node.id}--${edge}`;\n      // We can have duplicate edges when we added some more by random\n      if (edgesSet.has(id)) {\n        continue;\n      }\n      edgesSet.add(id);\n      edgeFields.id.values.add(`${node.id}--${edge}`);\n      edgeFields.source.values.add(node.id);\n      edgeFields.target.values.add(edge);\n    }\n  }\n\n  return [nodeFrame, edgesFrame];\n}\n\nfunction makeRandomNode(index: number) {\n  const success = Math.random();\n  const error = 1 - success;\n  return {\n    id: index.toString(),\n    title: `service:${index}`,\n    subTitle: 'service',\n    success,\n    error,\n    stat1: Math.random(),\n    stat2: Math.random(),\n    edges: [],\n  };\n}\n\nexport function savedNodesResponse(): any {\n  return [new MutableDataFrame(nodes), new MutableDataFrame(edges)];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}