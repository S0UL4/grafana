{"ast":null,"code":"import { mergeWith, isArray, isObject, unset, isEqual } from 'lodash';\nimport { FieldColorModeId, fieldColorModeRegistry, FieldConfigProperty, ThresholdsMode } from '@grafana/data';\nexport function getPanelOptionsWithDefaults({\n  plugin,\n  currentOptions,\n  currentFieldConfig,\n  isAfterPluginChange\n}) {\n  const optionsWithDefaults = mergeWith({}, plugin.defaults, currentOptions || {}, (objValue, srcValue) => {\n    if (isArray(srcValue)) {\n      return srcValue;\n    }\n  });\n  const fieldConfigWithDefaults = applyFieldConfigDefaults(currentFieldConfig, plugin);\n  const fieldConfigWithOptimalColorMode = adaptFieldColorMode(plugin, fieldConfigWithDefaults, isAfterPluginChange);\n  return {\n    options: optionsWithDefaults,\n    fieldConfig: fieldConfigWithOptimalColorMode\n  };\n}\n\nfunction applyFieldConfigDefaults(existingFieldConfig, plugin) {\n  var _existingFieldConfig$;\n\n  const pluginDefaults = plugin.fieldConfigDefaults;\n  const result = {\n    defaults: mergeWith({}, pluginDefaults.defaults, existingFieldConfig ? existingFieldConfig.defaults : {}, (objValue, srcValue) => {\n      if (isArray(srcValue)) {\n        return srcValue;\n      }\n    }),\n    overrides: (_existingFieldConfig$ = existingFieldConfig === null || existingFieldConfig === void 0 ? void 0 : existingFieldConfig.overrides) !== null && _existingFieldConfig$ !== void 0 ? _existingFieldConfig$ : []\n  };\n  cleanProperties(result.defaults, '', plugin.fieldConfigRegistry); // Thresholds base values are null in JSON but need to be converted to -Infinity\n\n  if (result.defaults.thresholds) {\n    fixThresholds(result.defaults.thresholds);\n  } // Filter out overrides for properties that cannot be found in registry\n\n\n  result.overrides = filterFieldConfigOverrides(result.overrides, prop => {\n    return plugin.fieldConfigRegistry.getIfExists(prop.id) !== undefined;\n  });\n\n  for (const override of result.overrides) {\n    for (const property of override.properties) {\n      if (property.id === 'thresholds') {\n        fixThresholds(property.value);\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function filterFieldConfigOverrides(overrides, condition) {\n  return overrides.map(x => {\n    const properties = x.properties.filter(condition);\n    return Object.assign({}, x, {\n      properties\n    });\n  }).filter(x => x.properties.length > 0);\n}\n\nfunction cleanProperties(obj, parentPath, fieldConfigRegistry) {\n  let found = false;\n\n  for (const propName of Object.keys(obj)) {\n    const value = obj[propName];\n    const fullPath = `${parentPath}${propName}`;\n    const existsInRegistry = !!fieldConfigRegistry.getIfExists(fullPath); // need to check early here as some standard properties have nested properies\n\n    if (existsInRegistry) {\n      found = true;\n      continue;\n    }\n\n    if (isArray(value) || !isObject(value)) {\n      if (!existsInRegistry) {\n        unset(obj, propName);\n      }\n    } else {\n      const childPropFound = cleanProperties(value, `${fullPath}.`, fieldConfigRegistry); // If no child props found unset the main object\n\n      if (!childPropFound) {\n        unset(obj, propName);\n      }\n    }\n  }\n\n  return found;\n}\n\nfunction adaptFieldColorMode(plugin, fieldConfig, isAfterPluginChange) {\n  if (!isAfterPluginChange) {\n    return fieldConfig;\n  } // adjust to prefered field color setting if needed\n\n\n  const color = plugin.fieldConfigRegistry.getIfExists(FieldConfigProperty.Color);\n\n  if (color && color.settings) {\n    var _fieldConfig$defaults;\n\n    const colorSettings = color.settings;\n    const mode = fieldColorModeRegistry.getIfExists((_fieldConfig$defaults = fieldConfig.defaults.color) === null || _fieldConfig$defaults === void 0 ? void 0 : _fieldConfig$defaults.mode); // When no support fo value colors, use classic palette\n\n    if (!colorSettings.byValueSupport) {\n      if (!mode || mode.isByValue) {\n        fieldConfig.defaults.color = {\n          mode: FieldColorModeId.PaletteClassic\n        };\n        return fieldConfig;\n      }\n    } // When supporting value colors and prefering thresholds, use Thresholds mode.\n    // Otherwise keep current mode\n\n\n    if (colorSettings.byValueSupport && colorSettings.preferThresholdsMode && (mode === null || mode === void 0 ? void 0 : mode.id) !== FieldColorModeId.Fixed) {\n      if (!mode || !mode.isByValue) {\n        fieldConfig.defaults.color = {\n          mode: FieldColorModeId.Thresholds\n        };\n        return fieldConfig;\n      }\n    } // If panel support bySeries then we should default to that when switching to this panel as that is most likely\n    // what users will expect. Example scenario a user who has a graph panel (time series) and switches to Gauge and\n    // then back to time series we want the graph panel color mode to reset to classic palette and not preserve the\n    // Gauge prefered thresholds mode.\n\n\n    if (colorSettings.bySeriesSupport && mode !== null && mode !== void 0 && mode.isByValue) {\n      fieldConfig.defaults.color = {\n        mode: FieldColorModeId.PaletteClassic\n      };\n      return fieldConfig;\n    }\n  }\n\n  return fieldConfig;\n}\n\nfunction fixThresholds(thresholds) {\n  if (!thresholds.mode) {\n    thresholds.mode = ThresholdsMode.Absolute;\n  }\n\n  if (!thresholds.steps) {\n    thresholds.steps = [];\n  } else if (thresholds.steps.length) {\n    // First value is always -Infinity\n    // JSON saves it as null\n    thresholds.steps[0].value = -Infinity;\n  }\n}\n\nexport function restoreCustomOverrideRules(current, old) {\n  const result = {\n    defaults: Object.assign({}, current.defaults, {\n      custom: old.defaults.custom\n    }),\n    overrides: [...current.overrides]\n  };\n\n  for (const override of old.overrides) {\n    for (const prop of override.properties) {\n      if (isCustomFieldProp(prop)) {\n        const currentOverride = result.overrides.find(o => isEqual(o.matcher, override.matcher));\n\n        if (currentOverride) {\n          if (currentOverride !== override) {\n            currentOverride.properties.push(prop);\n          }\n        } else {\n          result.overrides.push(override);\n        }\n      }\n    }\n  }\n\n  return result;\n}\nexport function isCustomFieldProp(prop) {\n  return prop.id.startsWith('custom.');\n}\nexport function isStandardFieldProp(prop) {\n  return !isCustomFieldProp(prop);\n}","map":{"version":3,"names":["mergeWith","isArray","isObject","unset","isEqual","FieldColorModeId","fieldColorModeRegistry","FieldConfigProperty","ThresholdsMode","getPanelOptionsWithDefaults","plugin","currentOptions","currentFieldConfig","isAfterPluginChange","optionsWithDefaults","defaults","objValue","srcValue","fieldConfigWithDefaults","applyFieldConfigDefaults","fieldConfigWithOptimalColorMode","adaptFieldColorMode","options","fieldConfig","existingFieldConfig","pluginDefaults","fieldConfigDefaults","result","overrides","cleanProperties","fieldConfigRegistry","thresholds","fixThresholds","filterFieldConfigOverrides","prop","getIfExists","id","undefined","override","property","properties","value","condition","map","x","filter","length","obj","parentPath","found","propName","Object","keys","fullPath","existsInRegistry","childPropFound","color","Color","settings","colorSettings","mode","byValueSupport","isByValue","PaletteClassic","preferThresholdsMode","Fixed","Thresholds","bySeriesSupport","Absolute","steps","Infinity","restoreCustomOverrideRules","current","old","custom","isCustomFieldProp","currentOverride","find","o","matcher","push","startsWith","isStandardFieldProp"],"sources":["/home/soula/grafana/public/app/features/dashboard/state/getPanelOptionsWithDefaults.ts"],"sourcesContent":["import { mergeWith, isArray, isObject, unset, isEqual } from 'lodash';\n\nimport {\n  ConfigOverrideRule,\n  DynamicConfigValue,\n  FieldColorConfigSettings,\n  FieldColorModeId,\n  fieldColorModeRegistry,\n  FieldConfigOptionsRegistry,\n  FieldConfigProperty,\n  FieldConfigSource,\n  PanelPlugin,\n  ThresholdsConfig,\n  ThresholdsMode,\n} from '@grafana/data';\n\nexport interface Props {\n  plugin: PanelPlugin;\n  currentFieldConfig: FieldConfigSource;\n  currentOptions: Record<string, any>;\n  isAfterPluginChange: boolean;\n}\n\nexport interface OptionDefaults {\n  options: any;\n  fieldConfig: FieldConfigSource;\n}\n\nexport function getPanelOptionsWithDefaults({\n  plugin,\n  currentOptions,\n  currentFieldConfig,\n  isAfterPluginChange,\n}: Props): OptionDefaults {\n  const optionsWithDefaults = mergeWith(\n    {},\n    plugin.defaults,\n    currentOptions || {},\n    (objValue: any, srcValue: any): any => {\n      if (isArray(srcValue)) {\n        return srcValue;\n      }\n    }\n  );\n\n  const fieldConfigWithDefaults = applyFieldConfigDefaults(currentFieldConfig, plugin);\n  const fieldConfigWithOptimalColorMode = adaptFieldColorMode(plugin, fieldConfigWithDefaults, isAfterPluginChange);\n\n  return { options: optionsWithDefaults, fieldConfig: fieldConfigWithOptimalColorMode };\n}\n\nfunction applyFieldConfigDefaults(existingFieldConfig: FieldConfigSource, plugin: PanelPlugin): FieldConfigSource {\n  const pluginDefaults = plugin.fieldConfigDefaults;\n\n  const result: FieldConfigSource = {\n    defaults: mergeWith(\n      {},\n      pluginDefaults.defaults,\n      existingFieldConfig ? existingFieldConfig.defaults : {},\n      (objValue: any, srcValue: any): any => {\n        if (isArray(srcValue)) {\n          return srcValue;\n        }\n      }\n    ),\n    overrides: existingFieldConfig?.overrides ?? [],\n  };\n\n  cleanProperties(result.defaults, '', plugin.fieldConfigRegistry);\n\n  // Thresholds base values are null in JSON but need to be converted to -Infinity\n  if (result.defaults.thresholds) {\n    fixThresholds(result.defaults.thresholds);\n  }\n\n  // Filter out overrides for properties that cannot be found in registry\n  result.overrides = filterFieldConfigOverrides(result.overrides, (prop) => {\n    return plugin.fieldConfigRegistry.getIfExists(prop.id) !== undefined;\n  });\n\n  for (const override of result.overrides) {\n    for (const property of override.properties) {\n      if (property.id === 'thresholds') {\n        fixThresholds(property.value as ThresholdsConfig);\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function filterFieldConfigOverrides(\n  overrides: ConfigOverrideRule[],\n  condition: (value: DynamicConfigValue) => boolean\n): ConfigOverrideRule[] {\n  return overrides\n    .map((x) => {\n      const properties = x.properties.filter(condition);\n\n      return {\n        ...x,\n        properties,\n      };\n    })\n    .filter((x) => x.properties.length > 0);\n}\n\nfunction cleanProperties(obj: any, parentPath: string, fieldConfigRegistry: FieldConfigOptionsRegistry) {\n  let found = false;\n\n  for (const propName of Object.keys(obj)) {\n    const value = obj[propName];\n    const fullPath = `${parentPath}${propName}`;\n    const existsInRegistry = !!fieldConfigRegistry.getIfExists(fullPath);\n\n    // need to check early here as some standard properties have nested properies\n    if (existsInRegistry) {\n      found = true;\n      continue;\n    }\n\n    if (isArray(value) || !isObject(value)) {\n      if (!existsInRegistry) {\n        unset(obj, propName);\n      }\n    } else {\n      const childPropFound = cleanProperties(value, `${fullPath}.`, fieldConfigRegistry);\n      // If no child props found unset the main object\n      if (!childPropFound) {\n        unset(obj, propName);\n      }\n    }\n  }\n\n  return found;\n}\n\nfunction adaptFieldColorMode(\n  plugin: PanelPlugin,\n  fieldConfig: FieldConfigSource,\n  isAfterPluginChange: boolean\n): FieldConfigSource {\n  if (!isAfterPluginChange) {\n    return fieldConfig;\n  }\n\n  // adjust to prefered field color setting if needed\n  const color = plugin.fieldConfigRegistry.getIfExists(FieldConfigProperty.Color);\n\n  if (color && color.settings) {\n    const colorSettings = color.settings as FieldColorConfigSettings;\n    const mode = fieldColorModeRegistry.getIfExists(fieldConfig.defaults.color?.mode);\n\n    // When no support fo value colors, use classic palette\n    if (!colorSettings.byValueSupport) {\n      if (!mode || mode.isByValue) {\n        fieldConfig.defaults.color = { mode: FieldColorModeId.PaletteClassic };\n        return fieldConfig;\n      }\n    }\n\n    // When supporting value colors and prefering thresholds, use Thresholds mode.\n    // Otherwise keep current mode\n    if (colorSettings.byValueSupport && colorSettings.preferThresholdsMode && mode?.id !== FieldColorModeId.Fixed) {\n      if (!mode || !mode.isByValue) {\n        fieldConfig.defaults.color = { mode: FieldColorModeId.Thresholds };\n        return fieldConfig;\n      }\n    }\n\n    // If panel support bySeries then we should default to that when switching to this panel as that is most likely\n    // what users will expect. Example scenario a user who has a graph panel (time series) and switches to Gauge and\n    // then back to time series we want the graph panel color mode to reset to classic palette and not preserve the\n    // Gauge prefered thresholds mode.\n    if (colorSettings.bySeriesSupport && mode?.isByValue) {\n      fieldConfig.defaults.color = { mode: FieldColorModeId.PaletteClassic };\n      return fieldConfig;\n    }\n  }\n  return fieldConfig;\n}\n\nfunction fixThresholds(thresholds: ThresholdsConfig) {\n  if (!thresholds.mode) {\n    thresholds.mode = ThresholdsMode.Absolute;\n  }\n\n  if (!thresholds.steps) {\n    thresholds.steps = [];\n  } else if (thresholds.steps.length) {\n    // First value is always -Infinity\n    // JSON saves it as null\n    thresholds.steps[0].value = -Infinity;\n  }\n}\n\nexport function restoreCustomOverrideRules(current: FieldConfigSource, old: FieldConfigSource): FieldConfigSource {\n  const result = {\n    defaults: {\n      ...current.defaults,\n      custom: old.defaults.custom,\n    },\n    overrides: [...current.overrides],\n  };\n\n  for (const override of old.overrides) {\n    for (const prop of override.properties) {\n      if (isCustomFieldProp(prop)) {\n        const currentOverride = result.overrides.find((o) => isEqual(o.matcher, override.matcher));\n        if (currentOverride) {\n          if (currentOverride !== override) {\n            currentOverride.properties.push(prop);\n          }\n        } else {\n          result.overrides.push(override);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function isCustomFieldProp(prop: DynamicConfigValue): boolean {\n  return prop.id.startsWith('custom.');\n}\n\nexport function isStandardFieldProp(prop: DynamicConfigValue): boolean {\n  return !isCustomFieldProp(prop);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}