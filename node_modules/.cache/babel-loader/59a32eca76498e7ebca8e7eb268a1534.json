{"ast":null,"code":"import { lastValueFrom } from 'rxjs';\nimport { locationUtil } from '@grafana/data';\nimport { DataSourceWithBackend, HealthCheckError, isFetchError, locationService } from '@grafana/runtime';\nimport { updateNavIndex } from 'app/core/actions';\nimport { getBackendSrv } from 'app/core/services/backend_srv';\nimport { accessControlQueryParam } from 'app/core/utils/accessControl';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\nimport { getPluginSettings } from 'app/features/plugins/pluginSettings';\nimport { importDataSourcePlugin } from 'app/features/plugins/plugin_loader';\nimport { contextSrv } from '../../../core/services/context_srv';\nimport { buildCategories } from './buildCategories';\nimport { buildNavModel } from './navModel';\nimport { dataSourceLoaded, dataSourceMetaLoaded, dataSourcePluginsLoad, dataSourcePluginsLoaded, dataSourcesLoaded, initDataSourceSettingsFailed, initDataSourceSettingsSucceeded, testDataSourceFailed, testDataSourceStarting, testDataSourceSucceeded } from './reducers';\nimport { getDataSource, getDataSourceMeta } from './selectors';\nexport const initDataSourceSettings = (pageId, dependencies = {\n  loadDataSource,\n  loadDataSourceMeta,\n  getDataSource,\n  getDataSourceMeta,\n  importDataSourcePlugin\n}) => {\n  return async (dispatch, getState) => {\n    if (!pageId) {\n      dispatch(initDataSourceSettingsFailed(new Error('Invalid ID')));\n      return;\n    }\n\n    try {\n      const loadedDataSource = await dispatch(dependencies.loadDataSource(pageId));\n      await dispatch(dependencies.loadDataSourceMeta(loadedDataSource)); // have we already loaded the plugin then we can skip the steps below?\n\n      if (getState().dataSourceSettings.plugin) {\n        return;\n      }\n\n      const dataSource = dependencies.getDataSource(getState().dataSources, pageId);\n      const dataSourceMeta = dependencies.getDataSourceMeta(getState().dataSources, dataSource.type);\n      const importedPlugin = await dependencies.importDataSourcePlugin(dataSourceMeta);\n      dispatch(initDataSourceSettingsSucceeded(importedPlugin));\n    } catch (err) {\n      if (err instanceof Error) {\n        dispatch(initDataSourceSettingsFailed(err));\n      }\n    }\n  };\n};\nexport const testDataSource = (dataSourceName, dependencies = {\n  getDatasourceSrv,\n  getBackendSrv\n}) => {\n  return async (dispatch, getState) => {\n    const dsApi = await dependencies.getDatasourceSrv().get(dataSourceName);\n\n    if (!dsApi.testDatasource) {\n      return;\n    }\n\n    dispatch(testDataSourceStarting());\n    dependencies.getBackendSrv().withNoBackendCache(async () => {\n      try {\n        const result = await dsApi.testDatasource();\n        dispatch(testDataSourceSucceeded(result));\n      } catch (err) {\n        let message;\n        let details;\n\n        if (err instanceof HealthCheckError) {\n          message = err.message;\n          details = err.details;\n        } else if (isFetchError(err)) {\n          var _err$data$message;\n\n          message = (_err$data$message = err.data.message) !== null && _err$data$message !== void 0 ? _err$data$message : `HTTP error ${err.statusText}`;\n        } else if (err instanceof Error) {\n          message = err.message;\n        }\n\n        dispatch(testDataSourceFailed({\n          message,\n          details\n        }));\n      }\n    });\n  };\n};\nexport function loadDataSources() {\n  return async dispatch => {\n    const response = await getBackendSrv().get('/api/datasources');\n    dispatch(dataSourcesLoaded(response));\n  };\n}\nexport function loadDataSource(uid) {\n  return async dispatch => {\n    const dataSource = await getDataSourceUsingUidOrId(uid);\n    dispatch(dataSourceLoaded(dataSource));\n    return dataSource;\n  };\n}\nexport function loadDataSourceMeta(dataSource) {\n  return async dispatch => {\n    const pluginInfo = await getPluginSettings(dataSource.type);\n    const plugin = await importDataSourcePlugin(pluginInfo);\n    const isBackend = plugin.DataSourceClass.prototype instanceof DataSourceWithBackend;\n    const meta = Object.assign({}, pluginInfo, {\n      isBackend: pluginInfo.backend || isBackend\n    });\n    dispatch(dataSourceMetaLoaded(meta));\n    plugin.meta = meta;\n    dispatch(updateNavIndex(buildNavModel(dataSource, plugin)));\n  };\n}\n/**\n * Get data source by uid or id, if old id detected handles redirect\n */\n\nexport async function getDataSourceUsingUidOrId(uid) {\n  // Try first with uid api\n  try {\n    const byUid = await lastValueFrom(getBackendSrv().fetch({\n      method: 'GET',\n      url: `/api/datasources/uid/${uid}`,\n      params: accessControlQueryParam(),\n      showErrorAlert: false\n    }));\n\n    if (byUid.ok) {\n      return byUid.data;\n    }\n  } catch (err) {\n    console.log('Failed to lookup data source by uid', err);\n  } // try lookup by old db id\n\n\n  const id = typeof uid === 'string' ? parseInt(uid, 10) : uid;\n\n  if (!Number.isNaN(id)) {\n    const response = await lastValueFrom(getBackendSrv().fetch({\n      method: 'GET',\n      url: `/api/datasources/${id}`,\n      params: accessControlQueryParam(),\n      showErrorAlert: false\n    })); // If the uid is a number, then this is a refresh on one of the settings tabs\n    // and we can return the response data\n\n    if (response.ok && typeof uid === 'number' && response.data.id === uid) {\n      return response.data;\n    } // Not ideal to do a full page reload here but so tricky to handle this\n    // otherwise We can update the location using react router, but need to\n    // fully reload the route as the nav model page index is not matching with\n    // the url in that case. And react router has no way to unmount remount a\n    // route\n\n\n    if (response.ok && response.data.id.toString() === uid) {\n      window.location.href = locationUtil.assureBaseUrl(`/datasources/edit/${response.data.uid}`);\n      return {}; // avoids flashing an error\n    }\n  }\n\n  throw Error('Could not find data source');\n}\nexport function addDataSource(plugin) {\n  return async (dispatch, getStore) => {\n    await dispatch(loadDataSources());\n    const dataSources = getStore().dataSources.dataSources;\n    const newInstance = {\n      name: plugin.name,\n      type: plugin.id,\n      access: 'proxy',\n      isDefault: dataSources.length === 0\n    };\n\n    if (nameExits(dataSources, newInstance.name)) {\n      newInstance.name = findNewName(dataSources, newInstance.name);\n    }\n\n    const result = await getBackendSrv().post('/api/datasources', newInstance);\n    await getDatasourceSrv().reload();\n    await contextSrv.fetchUserPermissions();\n    locationService.push(`/datasources/edit/${result.datasource.uid}`);\n  };\n}\nexport function loadDataSourcePlugins() {\n  return async dispatch => {\n    dispatch(dataSourcePluginsLoad());\n    const plugins = await getBackendSrv().get('/api/plugins', {\n      enabled: 1,\n      type: 'datasource'\n    });\n    const categories = buildCategories(plugins);\n    dispatch(dataSourcePluginsLoaded({\n      plugins,\n      categories\n    }));\n  };\n}\nexport function updateDataSource(dataSource) {\n  return async dispatch => {\n    await getBackendSrv().put(`/api/datasources/${dataSource.id}`, dataSource); // by UID not yet supported\n\n    await getDatasourceSrv().reload();\n    return dispatch(loadDataSource(dataSource.uid));\n  };\n}\nexport function deleteDataSource() {\n  return async (dispatch, getStore) => {\n    const dataSource = getStore().dataSources.dataSource;\n    await getBackendSrv().delete(`/api/datasources/${dataSource.id}`);\n    await getDatasourceSrv().reload();\n    locationService.push('/datasources');\n  };\n}\nexport function nameExits(dataSources, name) {\n  return dataSources.filter(dataSource => {\n    return dataSource.name.toLowerCase() === name.toLowerCase();\n  }).length > 0;\n}\nexport function findNewName(dataSources, name) {\n  // Need to loop through current data sources to make sure\n  // the name doesn't exist\n  while (nameExits(dataSources, name)) {\n    // If there's a duplicate name that doesn't end with '-x'\n    // we can add -1 to the name and be done.\n    if (!nameHasSuffix(name)) {\n      name = `${name}-1`;\n    } else {\n      // if there's a duplicate name that ends with '-x'\n      // we can try to increment the last digit until the name is unique\n      // remove the 'x' part and replace it with the new number\n      name = `${getNewName(name)}${incrementLastDigit(getLastDigit(name))}`;\n    }\n  }\n\n  return name;\n}\n\nfunction nameHasSuffix(name) {\n  return name.endsWith('-', name.length - 1);\n}\n\nfunction getLastDigit(name) {\n  return parseInt(name.slice(-1), 10);\n}\n\nfunction incrementLastDigit(digit) {\n  return isNaN(digit) ? 1 : digit + 1;\n}\n\nfunction getNewName(name) {\n  return name.slice(0, name.length - 1);\n}","map":{"version":3,"names":["lastValueFrom","locationUtil","DataSourceWithBackend","HealthCheckError","isFetchError","locationService","updateNavIndex","getBackendSrv","accessControlQueryParam","getDatasourceSrv","getPluginSettings","importDataSourcePlugin","contextSrv","buildCategories","buildNavModel","dataSourceLoaded","dataSourceMetaLoaded","dataSourcePluginsLoad","dataSourcePluginsLoaded","dataSourcesLoaded","initDataSourceSettingsFailed","initDataSourceSettingsSucceeded","testDataSourceFailed","testDataSourceStarting","testDataSourceSucceeded","getDataSource","getDataSourceMeta","initDataSourceSettings","pageId","dependencies","loadDataSource","loadDataSourceMeta","dispatch","getState","Error","loadedDataSource","dataSourceSettings","plugin","dataSource","dataSources","dataSourceMeta","type","importedPlugin","err","testDataSource","dataSourceName","dsApi","get","testDatasource","withNoBackendCache","result","message","details","data","statusText","loadDataSources","response","uid","getDataSourceUsingUidOrId","pluginInfo","isBackend","DataSourceClass","prototype","meta","backend","byUid","fetch","method","url","params","showErrorAlert","ok","console","log","id","parseInt","Number","isNaN","toString","window","location","href","assureBaseUrl","addDataSource","getStore","newInstance","name","access","isDefault","length","nameExits","findNewName","post","reload","fetchUserPermissions","push","datasource","loadDataSourcePlugins","plugins","enabled","categories","updateDataSource","put","deleteDataSource","delete","filter","toLowerCase","nameHasSuffix","getNewName","incrementLastDigit","getLastDigit","endsWith","slice","digit"],"sources":["/home/soula/grafana/public/app/features/datasources/state/actions.ts"],"sourcesContent":["import { lastValueFrom } from 'rxjs';\n\nimport { DataSourcePluginMeta, DataSourceSettings, locationUtil } from '@grafana/data';\nimport {\n  DataSourceWithBackend,\n  getDataSourceSrv,\n  HealthCheckError,\n  HealthCheckResultDetails,\n  isFetchError,\n  locationService,\n} from '@grafana/runtime';\nimport { updateNavIndex } from 'app/core/actions';\nimport { getBackendSrv } from 'app/core/services/backend_srv';\nimport { accessControlQueryParam } from 'app/core/utils/accessControl';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\nimport { getPluginSettings } from 'app/features/plugins/pluginSettings';\nimport { importDataSourcePlugin } from 'app/features/plugins/plugin_loader';\nimport { DataSourcePluginCategory, ThunkDispatch, ThunkResult } from 'app/types';\n\nimport { contextSrv } from '../../../core/services/context_srv';\n\nimport { buildCategories } from './buildCategories';\nimport { buildNavModel } from './navModel';\nimport {\n  dataSourceLoaded,\n  dataSourceMetaLoaded,\n  dataSourcePluginsLoad,\n  dataSourcePluginsLoaded,\n  dataSourcesLoaded,\n  initDataSourceSettingsFailed,\n  initDataSourceSettingsSucceeded,\n  testDataSourceFailed,\n  testDataSourceStarting,\n  testDataSourceSucceeded,\n} from './reducers';\nimport { getDataSource, getDataSourceMeta } from './selectors';\n\nexport interface DataSourceTypesLoadedPayload {\n  plugins: DataSourcePluginMeta[];\n  categories: DataSourcePluginCategory[];\n}\n\nexport interface InitDataSourceSettingDependencies {\n  loadDataSource: typeof loadDataSource;\n  loadDataSourceMeta: typeof loadDataSourceMeta;\n  getDataSource: typeof getDataSource;\n  getDataSourceMeta: typeof getDataSourceMeta;\n  importDataSourcePlugin: typeof importDataSourcePlugin;\n}\n\nexport interface TestDataSourceDependencies {\n  getDatasourceSrv: typeof getDataSourceSrv;\n  getBackendSrv: typeof getBackendSrv;\n}\n\nexport const initDataSourceSettings = (\n  pageId: string,\n  dependencies: InitDataSourceSettingDependencies = {\n    loadDataSource,\n    loadDataSourceMeta,\n    getDataSource,\n    getDataSourceMeta,\n    importDataSourcePlugin,\n  }\n): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    if (!pageId) {\n      dispatch(initDataSourceSettingsFailed(new Error('Invalid ID')));\n      return;\n    }\n\n    try {\n      const loadedDataSource = await dispatch(dependencies.loadDataSource(pageId));\n      await dispatch(dependencies.loadDataSourceMeta(loadedDataSource));\n\n      // have we already loaded the plugin then we can skip the steps below?\n      if (getState().dataSourceSettings.plugin) {\n        return;\n      }\n\n      const dataSource = dependencies.getDataSource(getState().dataSources, pageId);\n      const dataSourceMeta = dependencies.getDataSourceMeta(getState().dataSources, dataSource!.type);\n      const importedPlugin = await dependencies.importDataSourcePlugin(dataSourceMeta);\n\n      dispatch(initDataSourceSettingsSucceeded(importedPlugin));\n    } catch (err) {\n      if (err instanceof Error) {\n        dispatch(initDataSourceSettingsFailed(err));\n      }\n    }\n  };\n};\n\nexport const testDataSource = (\n  dataSourceName: string,\n  dependencies: TestDataSourceDependencies = {\n    getDatasourceSrv,\n    getBackendSrv,\n  }\n): ThunkResult<void> => {\n  return async (dispatch: ThunkDispatch, getState) => {\n    const dsApi = await dependencies.getDatasourceSrv().get(dataSourceName);\n\n    if (!dsApi.testDatasource) {\n      return;\n    }\n\n    dispatch(testDataSourceStarting());\n\n    dependencies.getBackendSrv().withNoBackendCache(async () => {\n      try {\n        const result = await dsApi.testDatasource();\n\n        dispatch(testDataSourceSucceeded(result));\n      } catch (err) {\n        let message: string | undefined;\n        let details: HealthCheckResultDetails;\n\n        if (err instanceof HealthCheckError) {\n          message = err.message;\n          details = err.details;\n        } else if (isFetchError(err)) {\n          message = err.data.message ?? `HTTP error ${err.statusText}`;\n        } else if (err instanceof Error) {\n          message = err.message;\n        }\n\n        dispatch(testDataSourceFailed({ message, details }));\n      }\n    });\n  };\n};\n\nexport function loadDataSources(): ThunkResult<void> {\n  return async (dispatch) => {\n    const response = await getBackendSrv().get('/api/datasources');\n    dispatch(dataSourcesLoaded(response));\n  };\n}\n\nexport function loadDataSource(uid: string): ThunkResult<Promise<DataSourceSettings>> {\n  return async (dispatch) => {\n    const dataSource = await getDataSourceUsingUidOrId(uid);\n\n    dispatch(dataSourceLoaded(dataSource));\n    return dataSource;\n  };\n}\n\nexport function loadDataSourceMeta(dataSource: DataSourceSettings): ThunkResult<void> {\n  return async (dispatch) => {\n    const pluginInfo = (await getPluginSettings(dataSource.type)) as DataSourcePluginMeta;\n    const plugin = await importDataSourcePlugin(pluginInfo);\n    const isBackend = plugin.DataSourceClass.prototype instanceof DataSourceWithBackend;\n    const meta = {\n      ...pluginInfo,\n      isBackend: pluginInfo.backend || isBackend,\n    };\n\n    dispatch(dataSourceMetaLoaded(meta));\n\n    plugin.meta = meta;\n    dispatch(updateNavIndex(buildNavModel(dataSource, plugin)));\n  };\n}\n\n/**\n * Get data source by uid or id, if old id detected handles redirect\n */\nexport async function getDataSourceUsingUidOrId(uid: string | number): Promise<DataSourceSettings> {\n  // Try first with uid api\n  try {\n    const byUid = await lastValueFrom(\n      getBackendSrv().fetch<DataSourceSettings>({\n        method: 'GET',\n        url: `/api/datasources/uid/${uid}`,\n        params: accessControlQueryParam(),\n        showErrorAlert: false,\n      })\n    );\n\n    if (byUid.ok) {\n      return byUid.data;\n    }\n  } catch (err) {\n    console.log('Failed to lookup data source by uid', err);\n  }\n\n  // try lookup by old db id\n  const id = typeof uid === 'string' ? parseInt(uid, 10) : uid;\n  if (!Number.isNaN(id)) {\n    const response = await lastValueFrom(\n      getBackendSrv().fetch<DataSourceSettings>({\n        method: 'GET',\n        url: `/api/datasources/${id}`,\n        params: accessControlQueryParam(),\n        showErrorAlert: false,\n      })\n    );\n\n    // If the uid is a number, then this is a refresh on one of the settings tabs\n    // and we can return the response data\n    if (response.ok && typeof uid === 'number' && response.data.id === uid) {\n      return response.data;\n    }\n\n    // Not ideal to do a full page reload here but so tricky to handle this\n    // otherwise We can update the location using react router, but need to\n    // fully reload the route as the nav model page index is not matching with\n    // the url in that case. And react router has no way to unmount remount a\n    // route\n    if (response.ok && response.data.id.toString() === uid) {\n      window.location.href = locationUtil.assureBaseUrl(`/datasources/edit/${response.data.uid}`);\n      return {} as DataSourceSettings; // avoids flashing an error\n    }\n  }\n\n  throw Error('Could not find data source');\n}\n\nexport function addDataSource(plugin: DataSourcePluginMeta): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    await dispatch(loadDataSources());\n\n    const dataSources = getStore().dataSources.dataSources;\n\n    const newInstance = {\n      name: plugin.name,\n      type: plugin.id,\n      access: 'proxy',\n      isDefault: dataSources.length === 0,\n    };\n\n    if (nameExits(dataSources, newInstance.name)) {\n      newInstance.name = findNewName(dataSources, newInstance.name);\n    }\n\n    const result = await getBackendSrv().post('/api/datasources', newInstance);\n    await getDatasourceSrv().reload();\n\n    await contextSrv.fetchUserPermissions();\n\n    locationService.push(`/datasources/edit/${result.datasource.uid}`);\n  };\n}\n\nexport function loadDataSourcePlugins(): ThunkResult<void> {\n  return async (dispatch) => {\n    dispatch(dataSourcePluginsLoad());\n    const plugins = await getBackendSrv().get('/api/plugins', { enabled: 1, type: 'datasource' });\n    const categories = buildCategories(plugins);\n    dispatch(dataSourcePluginsLoaded({ plugins, categories }));\n  };\n}\n\nexport function updateDataSource(dataSource: DataSourceSettings): ThunkResult<void> {\n  return async (dispatch) => {\n    await getBackendSrv().put(`/api/datasources/${dataSource.id}`, dataSource); // by UID not yet supported\n    await getDatasourceSrv().reload();\n    return dispatch(loadDataSource(dataSource.uid));\n  };\n}\n\nexport function deleteDataSource(): ThunkResult<void> {\n  return async (dispatch, getStore) => {\n    const dataSource = getStore().dataSources.dataSource;\n\n    await getBackendSrv().delete(`/api/datasources/${dataSource.id}`);\n    await getDatasourceSrv().reload();\n\n    locationService.push('/datasources');\n  };\n}\n\ninterface ItemWithName {\n  name: string;\n}\n\nexport function nameExits(dataSources: ItemWithName[], name: string) {\n  return (\n    dataSources.filter((dataSource) => {\n      return dataSource.name.toLowerCase() === name.toLowerCase();\n    }).length > 0\n  );\n}\n\nexport function findNewName(dataSources: ItemWithName[], name: string) {\n  // Need to loop through current data sources to make sure\n  // the name doesn't exist\n  while (nameExits(dataSources, name)) {\n    // If there's a duplicate name that doesn't end with '-x'\n    // we can add -1 to the name and be done.\n    if (!nameHasSuffix(name)) {\n      name = `${name}-1`;\n    } else {\n      // if there's a duplicate name that ends with '-x'\n      // we can try to increment the last digit until the name is unique\n\n      // remove the 'x' part and replace it with the new number\n      name = `${getNewName(name)}${incrementLastDigit(getLastDigit(name))}`;\n    }\n  }\n\n  return name;\n}\n\nfunction nameHasSuffix(name: string) {\n  return name.endsWith('-', name.length - 1);\n}\n\nfunction getLastDigit(name: string) {\n  return parseInt(name.slice(-1), 10);\n}\n\nfunction incrementLastDigit(digit: number) {\n  return isNaN(digit) ? 1 : digit + 1;\n}\n\nfunction getNewName(name: string) {\n  return name.slice(0, name.length - 1);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}