{"ast":null,"code":"import { LoadingState, CoreApp, urlUtil } from '@grafana/data';\nimport { reportMetaAnalytics, MetaAnalyticsEventName } from '@grafana/runtime';\nimport { getDashboardSrv } from '../../dashboard/services/DashboardSrv';\nexport function emitDataRequestEvent(datasource) {\n  let done = false;\n  return data => {\n    if (!data.request || done || data.request.app === CoreApp.Explore) {\n      return;\n    }\n\n    const params = urlUtil.getUrlSearchParams();\n\n    if (params.editPanel != null) {\n      return;\n    }\n\n    if (data.state !== LoadingState.Done && data.state !== LoadingState.Error) {\n      return;\n    }\n\n    const queryCacheStatus = {};\n\n    for (let i = 0; i < data.series.length; i++) {\n      const refId = data.series[i].refId;\n\n      if (refId && !queryCacheStatus[refId]) {\n        var _data$series$i$meta$i, _data$series$i$meta;\n\n        queryCacheStatus[refId] = (_data$series$i$meta$i = (_data$series$i$meta = data.series[i].meta) === null || _data$series$i$meta === void 0 ? void 0 : _data$series$i$meta.isCachedResponse) !== null && _data$series$i$meta$i !== void 0 ? _data$series$i$meta$i : false;\n      }\n    }\n\n    const totalQueries = Object.keys(queryCacheStatus).length;\n    const cachedQueries = Object.values(queryCacheStatus).filter(val => val === true).length;\n    const eventData = {\n      eventName: MetaAnalyticsEventName.DataRequest,\n      datasourceName: datasource.name,\n      datasourceId: datasource.id,\n      datasourceType: datasource.type,\n      panelId: data.request.panelId,\n      dashboardId: data.request.dashboardId,\n      dataSize: 0,\n      duration: data.request.endTime - data.request.startTime,\n      totalQueries,\n      cachedQueries\n    }; // enrich with dashboard info\n\n    const dashboard = getDashboardSrv().getCurrent();\n\n    if (dashboard) {\n      eventData.dashboardId = dashboard.id;\n      eventData.dashboardName = dashboard.title;\n      eventData.dashboardUid = dashboard.uid;\n      eventData.folderName = dashboard.meta.folderTitle;\n    }\n\n    if (data.series && data.series.length > 0) {\n      // estimate size\n      eventData.dataSize = data.series.length;\n    }\n\n    if (data.error) {\n      eventData.error = data.error.message;\n    }\n\n    reportMetaAnalytics(eventData); // this done check is to make sure we do not double emit events in case\n    // there are multiple responses with done state\n\n    done = true;\n  };\n}","map":{"version":3,"names":["LoadingState","CoreApp","urlUtil","reportMetaAnalytics","MetaAnalyticsEventName","getDashboardSrv","emitDataRequestEvent","datasource","done","data","request","app","Explore","params","getUrlSearchParams","editPanel","state","Done","Error","queryCacheStatus","i","series","length","refId","meta","isCachedResponse","totalQueries","Object","keys","cachedQueries","values","filter","val","eventData","eventName","DataRequest","datasourceName","name","datasourceId","id","datasourceType","type","panelId","dashboardId","dataSize","duration","endTime","startTime","dashboard","getCurrent","dashboardName","title","dashboardUid","uid","folderName","folderTitle","error","message"],"sources":["/home/soula/grafana/public/app/features/query/state/queryAnalytics.ts"],"sourcesContent":["import { PanelData, LoadingState, DataSourceApi, CoreApp, urlUtil } from '@grafana/data';\nimport { reportMetaAnalytics, MetaAnalyticsEventName, DataRequestEventPayload } from '@grafana/runtime';\n\nimport { getDashboardSrv } from '../../dashboard/services/DashboardSrv';\n\nexport function emitDataRequestEvent(datasource: DataSourceApi) {\n  let done = false;\n\n  return (data: PanelData) => {\n    if (!data.request || done || data.request.app === CoreApp.Explore) {\n      return;\n    }\n\n    const params = urlUtil.getUrlSearchParams();\n    if (params.editPanel != null) {\n      return;\n    }\n\n    if (data.state !== LoadingState.Done && data.state !== LoadingState.Error) {\n      return;\n    }\n\n    const queryCacheStatus: { [key: string]: boolean } = {};\n    for (let i = 0; i < data.series.length; i++) {\n      const refId = data.series[i].refId;\n      if (refId && !queryCacheStatus[refId]) {\n        queryCacheStatus[refId] = data.series[i].meta?.isCachedResponse ?? false;\n      }\n    }\n    const totalQueries = Object.keys(queryCacheStatus).length;\n    const cachedQueries = Object.values(queryCacheStatus).filter((val) => val === true).length;\n\n    const eventData: DataRequestEventPayload = {\n      eventName: MetaAnalyticsEventName.DataRequest,\n      datasourceName: datasource.name,\n      datasourceId: datasource.id,\n      datasourceType: datasource.type,\n      panelId: data.request.panelId,\n      dashboardId: data.request.dashboardId,\n      dataSize: 0,\n      duration: data.request.endTime! - data.request.startTime,\n      totalQueries,\n      cachedQueries,\n    };\n\n    // enrich with dashboard info\n    const dashboard = getDashboardSrv().getCurrent();\n    if (dashboard) {\n      eventData.dashboardId = dashboard.id;\n      eventData.dashboardName = dashboard.title;\n      eventData.dashboardUid = dashboard.uid;\n      eventData.folderName = dashboard.meta.folderTitle;\n    }\n\n    if (data.series && data.series.length > 0) {\n      // estimate size\n      eventData.dataSize = data.series.length;\n    }\n\n    if (data.error) {\n      eventData.error = data.error.message;\n    }\n\n    reportMetaAnalytics(eventData);\n\n    // this done check is to make sure we do not double emit events in case\n    // there are multiple responses with done state\n    done = true;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}