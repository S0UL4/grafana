{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { cloneDeep, find, findLast, isEmpty, isString, set } from 'lodash';\nimport React from 'react';\nimport { from, lastValueFrom, merge, Observable, of, throwError, zip } from 'rxjs';\nimport { catchError, concatMap, finalize, map, mergeMap, repeat, scan, share, takeWhile, tap } from 'rxjs/operators';\nimport { DataQueryErrorType, dateMath, dateTimeFormat, FieldType, LoadingState, rangeUtil } from '@grafana/data';\nimport { DataSourceWithBackend, getBackendSrv, toDataQueryResponse } from '@grafana/runtime';\nimport { notifyApp } from 'app/core/actions';\nimport { config } from 'app/core/config';\nimport { createErrorNotification } from 'app/core/copy/appNotification';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { getTemplateSrv } from 'app/features/templating/template_srv';\nimport { store } from 'app/store/store';\nimport { AppNotificationTimeout } from 'app/types';\nimport { CloudWatchAnnotationSupport } from './annotationSupport';\nimport { SQLCompletionItemProvider } from './cloudwatch-sql/completion/CompletionItemProvider';\nimport { ThrottlingErrorMessage } from './components/ThrottlingErrorMessage';\nimport { isCloudWatchAnnotationQuery, isCloudWatchLogsQuery, isCloudWatchMetricsQuery } from './guards';\nimport { CloudWatchLanguageProvider } from './language_provider';\nimport memoizedDebounce from './memoizedDebounce';\nimport { MetricMathCompletionItemProvider } from './metric-math/completion/CompletionItemProvider';\nimport { migrateMetricQuery } from './migrations/metricQueryMigrations';\nimport { CloudWatchLogsQueryStatus, MetricEditorMode, MetricQueryType } from './types';\nimport { addDataLinksToLogsResponse } from './utils/datalinks';\nimport { runWithRetry } from './utils/logsRetry';\nimport { increasingInterval } from './utils/rxjs/increasingInterval';\nimport { CloudWatchVariableSupport } from './variables';\nconst DS_QUERY_ENDPOINT = '/api/ds/query'; // Constants also defined in tsdb/cloudwatch/cloudwatch.go\n\nconst LOG_IDENTIFIER_INTERNAL = '__log__grafana_internal__';\nconst LOGSTREAM_IDENTIFIER_INTERNAL = '__logstream__grafana_internal__';\n\nconst displayAlert = (datasourceName, region) => store.dispatch(notifyApp(createErrorNotification(`CloudWatch request limit reached in ${region} for data source ${datasourceName}`, '', undefined, /*#__PURE__*/React.createElement(ThrottlingErrorMessage, {\n  region\n}, null))));\n\nconst displayCustomError = (title, message) => store.dispatch(notifyApp(createErrorNotification(title, message)));\n\nexport class CloudWatchDatasource extends DataSourceWithBackend {\n  constructor(instanceSettings, templateSrv = getTemplateSrv(), timeSrv = getTimeSrv()) {\n    super(instanceSettings);\n\n    _defineProperty(this, \"proxyUrl\", void 0);\n\n    _defineProperty(this, \"defaultRegion\", void 0);\n\n    _defineProperty(this, \"datasourceName\", void 0);\n\n    _defineProperty(this, \"languageProvider\", void 0);\n\n    _defineProperty(this, \"sqlCompletionItemProvider\", void 0);\n\n    _defineProperty(this, \"metricMathCompletionItemProvider\", void 0);\n\n    _defineProperty(this, \"tracingDataSourceUid\", void 0);\n\n    _defineProperty(this, \"logsTimeout\", void 0);\n\n    _defineProperty(this, \"type\", 'cloudwatch');\n\n    _defineProperty(this, \"standardStatistics\", ['Average', 'Maximum', 'Minimum', 'Sum', 'SampleCount']);\n\n    _defineProperty(this, \"debouncedAlert\", memoizedDebounce(displayAlert, AppNotificationTimeout.Error));\n\n    _defineProperty(this, \"debouncedCustomAlert\", memoizedDebounce(displayCustomError, AppNotificationTimeout.Error));\n\n    _defineProperty(this, \"logQueries\", {});\n\n    _defineProperty(this, \"handleLogQueries\", (logQueries, options) => {\n      const validLogQueries = logQueries.filter(item => {\n        var _item$logGroupNames;\n\n        return (_item$logGroupNames = item.logGroupNames) === null || _item$logGroupNames === void 0 ? void 0 : _item$logGroupNames.length;\n      });\n\n      if (logQueries.length > validLogQueries.length) {\n        return of({\n          data: [],\n          error: {\n            message: 'Log group is required'\n          }\n        });\n      } // No valid targets, return the empty result to save a round trip.\n\n\n      if (isEmpty(validLogQueries)) {\n        return of({\n          data: [],\n          state: LoadingState.Done\n        });\n      }\n\n      const queryParams = logQueries.map(target => ({\n        queryString: target.expression || '',\n        refId: target.refId,\n        logGroupNames: target.logGroupNames,\n        region: this.replace(this.getActualRegion(target.region), options.scopedVars, true, 'region')\n      }));\n      const startTime = new Date();\n\n      const timeoutFunc = () => {\n        return Date.now() >= startTime.valueOf() + rangeUtil.intervalToMs(this.logsTimeout);\n      };\n\n      return runWithRetry(targets => {\n        return this.makeLogActionRequest('StartQuery', targets, {\n          makeReplacements: true,\n          scopedVars: options.scopedVars,\n          skipCache: true\n        });\n      }, queryParams, timeoutFunc).pipe(mergeMap(({\n        frames,\n        error\n      }) => // This queries for the results\n      this.logsQuery(frames.map(dataFrame => {\n        var _dataFrame$meta$custo, _dataFrame$meta, _dataFrame$meta$custo2;\n\n        return {\n          queryId: dataFrame.fields[0].values.get(0),\n          region: (_dataFrame$meta$custo = (_dataFrame$meta = dataFrame.meta) === null || _dataFrame$meta === void 0 ? void 0 : (_dataFrame$meta$custo2 = _dataFrame$meta.custom) === null || _dataFrame$meta$custo2 === void 0 ? void 0 : _dataFrame$meta$custo2['Region']) !== null && _dataFrame$meta$custo !== void 0 ? _dataFrame$meta$custo : 'default',\n          refId: dataFrame.refId,\n          statsGroups: logQueries.find(target => target.refId === dataFrame.refId).statsGroups\n        };\n      }), timeoutFunc).pipe(map(response => {\n        if (!response.error && error) {\n          response.error = error;\n        }\n\n        return response;\n      }))), mergeMap(dataQueryResponse => {\n        return from((async () => {\n          await addDataLinksToLogsResponse(dataQueryResponse, options, this.timeSrv.timeRange(), this.replace.bind(this), this.expandVariableToArray.bind(this), this.getActualRegion.bind(this), this.tracingDataSourceUid);\n          return dataQueryResponse;\n        })());\n      }));\n    });\n\n    _defineProperty(this, \"handleMetricQueries\", (metricQueries, options) => {\n      var _options$range, _options$range2;\n\n      const timezoneUTCOffset = dateTimeFormat(Date.now(), {\n        timeZone: options.timezone,\n        format: 'Z'\n      }).replace(':', '');\n      const validMetricsQueries = metricQueries.filter(this.filterMetricQuery).map(q => {\n        const migratedQuery = migrateMetricQuery(q);\n        const migratedAndIterpolatedQuery = this.replaceMetricQueryVars(migratedQuery, options);\n        return Object.assign({\n          timezoneUTCOffset,\n          intervalMs: options.intervalMs,\n          maxDataPoints: options.maxDataPoints\n        }, migratedAndIterpolatedQuery, {\n          type: 'timeSeriesQuery',\n          datasource: this.getRef()\n        });\n      }); // No valid targets, return the empty result to save a round trip.\n\n      if (isEmpty(validMetricsQueries)) {\n        return of({\n          data: []\n        });\n      }\n\n      const request = {\n        from: options === null || options === void 0 ? void 0 : (_options$range = options.range) === null || _options$range === void 0 ? void 0 : _options$range.from.valueOf().toString(),\n        to: options === null || options === void 0 ? void 0 : (_options$range2 = options.range) === null || _options$range2 === void 0 ? void 0 : _options$range2.to.valueOf().toString(),\n        queries: validMetricsQueries\n      };\n      return this.performTimeSeriesQuery(request, options.range);\n    });\n\n    _defineProperty(this, \"getLogRowContext\", async (row, {\n      limit = 10,\n      direction = 'BACKWARD'\n    } = {}) => {\n      let logStreamField = null;\n      let logField = null;\n\n      for (const field of row.dataFrame.fields) {\n        if (field.name === LOGSTREAM_IDENTIFIER_INTERNAL) {\n          logStreamField = field;\n\n          if (logField !== null) {\n            break;\n          }\n        } else if (field.name === LOG_IDENTIFIER_INTERNAL) {\n          logField = field;\n\n          if (logStreamField !== null) {\n            break;\n          }\n        }\n      }\n\n      const requestParams = {\n        limit,\n        startFromHead: direction !== 'BACKWARD',\n        logGroupName: parseLogGroupName(logField.values.get(row.rowIndex)),\n        logStreamName: logStreamField.values.get(row.rowIndex)\n      };\n\n      if (direction === 'BACKWARD') {\n        requestParams.endTime = row.timeEpochMs;\n      } else {\n        requestParams.startTime = row.timeEpochMs;\n      }\n\n      const dataFrames = await lastValueFrom(this.makeLogActionRequest('GetLogEvents', [requestParams]));\n      return {\n        data: dataFrames\n      };\n    });\n\n    _defineProperty(this, \"getTargetsByQueryMode\", targets => {\n      const logQueries = [];\n      const metricsQueries = [];\n      const annotationQueries = [];\n      targets.forEach(query => {\n        if (isCloudWatchAnnotationQuery(query)) {\n          annotationQueries.push(query);\n        } else if (isCloudWatchLogsQuery(query)) {\n          logQueries.push(query);\n        } else {\n          metricsQueries.push(query);\n        }\n      });\n      return {\n        logQueries,\n        metricsQueries,\n        annotationQueries\n      };\n    });\n\n    this.templateSrv = templateSrv;\n    this.timeSrv = timeSrv;\n    this.proxyUrl = instanceSettings.url;\n    this.defaultRegion = instanceSettings.jsonData.defaultRegion;\n    this.datasourceName = instanceSettings.name;\n    this.languageProvider = new CloudWatchLanguageProvider(this);\n    this.tracingDataSourceUid = instanceSettings.jsonData.tracingDatasourceUid;\n    this.logsTimeout = instanceSettings.jsonData.logsTimeout || '15m';\n    this.sqlCompletionItemProvider = new SQLCompletionItemProvider(this, this.templateSrv);\n    this.metricMathCompletionItemProvider = new MetricMathCompletionItemProvider(this, this.templateSrv);\n    this.variables = new CloudWatchVariableSupport(this);\n    this.annotations = CloudWatchAnnotationSupport;\n  }\n\n  filterQuery(query) {\n    return query.hide !== true || isCloudWatchMetricsQuery(query) && query.id !== '';\n  }\n\n  query(options) {\n    options = cloneDeep(options);\n    let queries = options.targets.filter(this.filterQuery);\n    const {\n      logQueries,\n      metricsQueries,\n      annotationQueries\n    } = this.getTargetsByQueryMode(queries);\n    const dataQueryResponses = [];\n\n    if (logQueries.length > 0) {\n      dataQueryResponses.push(this.handleLogQueries(logQueries, options));\n    }\n\n    if (metricsQueries.length > 0) {\n      dataQueryResponses.push(this.handleMetricQueries(metricsQueries, options));\n    }\n\n    if (annotationQueries.length > 0) {\n      dataQueryResponses.push(this.handleAnnotationQuery(annotationQueries, options));\n    } // No valid targets, return the empty result to save a round trip.\n\n\n    if (isEmpty(dataQueryResponses)) {\n      return of({\n        data: [],\n        state: LoadingState.Done\n      });\n    }\n\n    return merge(...dataQueryResponses);\n  }\n  /**\n   * Handle log query. The log query works by starting the query on the CloudWatch and then periodically polling for\n   * results.\n   * @param logQueries\n   * @param options\n   */\n\n\n  filterMetricQuery(query) {\n    const {\n      region,\n      metricQueryType,\n      metricEditorMode,\n      expression,\n      metricName,\n      namespace,\n      sqlExpression,\n      statistic\n    } = query;\n\n    if (!region) {\n      return false;\n    }\n\n    if (metricQueryType === MetricQueryType.Search && metricEditorMode === MetricEditorMode.Builder) {\n      return !!namespace && !!metricName && !!statistic;\n    } else if (metricQueryType === MetricQueryType.Search && metricEditorMode === MetricEditorMode.Code) {\n      return !!expression;\n    } else if (metricQueryType === MetricQueryType.Query) {\n      // still TBD how to validate the visual query builder for SQL\n      return !!sqlExpression;\n    }\n\n    throw new Error('invalid metric editor mode');\n  }\n\n  replaceMetricQueryVars(query, options) {\n    var _query$dimensions;\n\n    query.region = this.templateSrv.replace(this.getActualRegion(query.region), options.scopedVars);\n    query.namespace = this.replace(query.namespace, options.scopedVars, true, 'namespace');\n    query.metricName = this.replace(query.metricName, options.scopedVars, true, 'metric name');\n    query.dimensions = this.convertDimensionFormat((_query$dimensions = query.dimensions) !== null && _query$dimensions !== void 0 ? _query$dimensions : {}, options.scopedVars);\n    query.statistic = this.templateSrv.replace(query.statistic, options.scopedVars);\n    query.period = String(this.getPeriod(query, options)); // use string format for period in graph query, and alerting\n\n    query.id = this.templateSrv.replace(query.id, options.scopedVars);\n    query.expression = this.templateSrv.replace(query.expression, options.scopedVars);\n    query.sqlExpression = this.templateSrv.replace(query.sqlExpression, options.scopedVars, 'raw');\n    return query;\n  }\n\n  handleAnnotationQuery(queries, options) {\n    return this.awsRequest(DS_QUERY_ENDPOINT, {\n      from: options.range.from.valueOf().toString(),\n      to: options.range.to.valueOf().toString(),\n      queries: queries.map(query => {\n        var _query$dimensions2, _query$actionPrefix, _query$alarmNamePrefi;\n\n        return Object.assign({}, query, {\n          statistic: this.templateSrv.replace(query.statistic),\n          region: this.templateSrv.replace(this.getActualRegion(query.region)),\n          namespace: this.templateSrv.replace(query.namespace),\n          metricName: this.templateSrv.replace(query.metricName),\n          dimensions: this.convertDimensionFormat((_query$dimensions2 = query.dimensions) !== null && _query$dimensions2 !== void 0 ? _query$dimensions2 : {}, {}),\n          period: query.period ? parseInt(query.period, 10) : 300,\n          actionPrefix: (_query$actionPrefix = query.actionPrefix) !== null && _query$actionPrefix !== void 0 ? _query$actionPrefix : '',\n          alarmNamePrefix: (_query$alarmNamePrefi = query.alarmNamePrefix) !== null && _query$alarmNamePrefi !== void 0 ? _query$alarmNamePrefi : '',\n          type: 'annotationQuery',\n          datasource: this.getRef()\n        });\n      })\n    }).pipe(map(r => {\n      const frames = toDataQueryResponse({\n        data: r\n      }).data;\n      return {\n        data: frames\n      };\n    }));\n  }\n  /**\n   * Checks progress and polls data of a started logs query with some retry logic.\n   * @param queryParams\n   */\n\n\n  logsQuery(queryParams, timeoutFunc) {\n    this.logQueries = {};\n    queryParams.forEach(param => {\n      var _ref, _param$statsGroups$le, _param$statsGroups;\n\n      this.logQueries[param.refId] = {\n        id: param.queryId,\n        region: param.region,\n        statsQuery: (_ref = ((_param$statsGroups$le = (_param$statsGroups = param.statsGroups) === null || _param$statsGroups === void 0 ? void 0 : _param$statsGroups.length) !== null && _param$statsGroups$le !== void 0 ? _param$statsGroups$le : 0) > 0) !== null && _ref !== void 0 ? _ref : false\n      };\n    });\n    const dataFrames = increasingInterval({\n      startPeriod: 100,\n      endPeriod: 1000,\n      step: 300\n    }).pipe(concatMap(_ => this.makeLogActionRequest('GetQueryResults', queryParams, {\n      skipCache: true\n    })), repeat(), share());\n    const consecutiveFailedAttempts = dataFrames.pipe(scan(({\n      failures,\n      prevRecordsMatched\n    }, frames) => {\n      failures++;\n\n      for (const frame of frames) {\n        var _frame$meta, _frame$meta$stats, _frame$meta$stats$fin, _prevRecordsMatched;\n\n        const recordsMatched = (_frame$meta = frame.meta) === null || _frame$meta === void 0 ? void 0 : (_frame$meta$stats = _frame$meta.stats) === null || _frame$meta$stats === void 0 ? void 0 : (_frame$meta$stats$fin = _frame$meta$stats.find(stat => stat.displayName === 'Records scanned')) === null || _frame$meta$stats$fin === void 0 ? void 0 : _frame$meta$stats$fin.value;\n\n        if (recordsMatched > ((_prevRecordsMatched = prevRecordsMatched[frame.refId]) !== null && _prevRecordsMatched !== void 0 ? _prevRecordsMatched : 0)) {\n          failures = 0;\n        }\n\n        prevRecordsMatched[frame.refId] = recordsMatched;\n      }\n\n      return {\n        failures,\n        prevRecordsMatched\n      };\n    }, {\n      failures: 0,\n      prevRecordsMatched: {}\n    }), map(({\n      failures\n    }) => failures), share());\n    const queryResponse = zip(dataFrames, consecutiveFailedAttempts).pipe(tap(([dataFrames]) => {\n      for (const frame of dataFrames) {\n        var _frame$meta2, _frame$meta2$custom;\n\n        if ([CloudWatchLogsQueryStatus.Complete, CloudWatchLogsQueryStatus.Cancelled, CloudWatchLogsQueryStatus.Failed].includes((_frame$meta2 = frame.meta) === null || _frame$meta2 === void 0 ? void 0 : (_frame$meta2$custom = _frame$meta2.custom) === null || _frame$meta2$custom === void 0 ? void 0 : _frame$meta2$custom['Status']) && this.logQueries.hasOwnProperty(frame.refId)) {\n          delete this.logQueries[frame.refId];\n        }\n      }\n    }), map(([dataFrames, failedAttempts]) => {\n      if (timeoutFunc()) {\n        for (const frame of dataFrames) {\n          set(frame, 'meta.custom.Status', CloudWatchLogsQueryStatus.Cancelled);\n        }\n      }\n\n      return {\n        data: dataFrames,\n        key: 'test-key',\n        state: dataFrames.every(dataFrame => {\n          var _dataFrame$meta2, _dataFrame$meta2$cust;\n\n          return [CloudWatchLogsQueryStatus.Complete, CloudWatchLogsQueryStatus.Cancelled, CloudWatchLogsQueryStatus.Failed].includes((_dataFrame$meta2 = dataFrame.meta) === null || _dataFrame$meta2 === void 0 ? void 0 : (_dataFrame$meta2$cust = _dataFrame$meta2.custom) === null || _dataFrame$meta2$cust === void 0 ? void 0 : _dataFrame$meta2$cust['Status']);\n        }) ? LoadingState.Done : LoadingState.Loading,\n        error: timeoutFunc() ? {\n          message: `error: query timed out after ${failedAttempts} attempts`,\n          type: DataQueryErrorType.Timeout\n        } : undefined\n      };\n    }), takeWhile(({\n      state\n    }) => state !== LoadingState.Error && state !== LoadingState.Done, true));\n    return withTeardown(queryResponse, () => this.stopQueries());\n  }\n\n  stopQueries() {\n    if (Object.keys(this.logQueries).length > 0) {\n      this.makeLogActionRequest('StopQuery', Object.values(this.logQueries).map(logQuery => ({\n        queryId: logQuery.id,\n        region: logQuery.region\n      })), {\n        makeReplacements: false,\n        skipCache: true\n      }).pipe(finalize(() => {\n        this.logQueries = {};\n      }));\n    }\n  }\n\n  async describeLogGroups(params) {\n    var _dataFrames$0$fields$, _dataFrames$, _dataFrames$$fields$;\n\n    const dataFrames = await lastValueFrom(this.makeLogActionRequest('DescribeLogGroups', [params]));\n    const logGroupNames = (_dataFrames$0$fields$ = (_dataFrames$ = dataFrames[0]) === null || _dataFrames$ === void 0 ? void 0 : (_dataFrames$$fields$ = _dataFrames$.fields[0]) === null || _dataFrames$$fields$ === void 0 ? void 0 : _dataFrames$$fields$.values.toArray()) !== null && _dataFrames$0$fields$ !== void 0 ? _dataFrames$0$fields$ : [];\n    return logGroupNames;\n  }\n\n  async getLogGroupFields(params) {\n    var _fieldNames$map;\n\n    const dataFrames = await lastValueFrom(this.makeLogActionRequest('GetLogGroupFields', [params]));\n    const fieldNames = dataFrames[0].fields[0].values.toArray();\n    const fieldPercentages = dataFrames[0].fields[1].values.toArray();\n    const getLogGroupFieldsResponse = {\n      logGroupFields: (_fieldNames$map = fieldNames.map((val, i) => ({\n        name: val,\n        percent: fieldPercentages[i]\n      }))) !== null && _fieldNames$map !== void 0 ? _fieldNames$map : []\n    };\n    return getLogGroupFieldsResponse;\n  }\n\n  getVariables() {\n    return this.templateSrv.getVariables().map(v => `$${v.name}`);\n  }\n\n  getPeriod(target, options) {\n    let period = this.templateSrv.replace(target.period, options.scopedVars);\n\n    if (period && period.toLowerCase() !== 'auto') {\n      if (/^\\d+$/.test(period)) {\n        period = parseInt(period, 10);\n      } else {\n        period = rangeUtil.intervalToSeconds(period);\n      }\n\n      if (period < 1) {\n        period = 1;\n      }\n    }\n\n    return period || '';\n  }\n\n  performTimeSeriesQuery(request, {\n    from,\n    to\n  }) {\n    return this.awsRequest(DS_QUERY_ENDPOINT, request).pipe(map(res => {\n      const dataframes = toDataQueryResponse({\n        data: res\n      }).data;\n\n      if (!dataframes || dataframes.length <= 0) {\n        return {\n          data: []\n        };\n      }\n\n      const lastError = findLast(res.results, v => !!v.error);\n      dataframes.forEach(frame => {\n        frame.fields.forEach(field => {\n          if (field.type === FieldType.time) {\n            var _frame$meta3, _frame$meta3$custom;\n\n            // field.config.interval is populated in order for Grafana to fill in null values at frame intervals\n            field.config.interval = ((_frame$meta3 = frame.meta) === null || _frame$meta3 === void 0 ? void 0 : (_frame$meta3$custom = _frame$meta3.custom) === null || _frame$meta3$custom === void 0 ? void 0 : _frame$meta3$custom.period) * 1000;\n          }\n        });\n      });\n      return {\n        data: dataframes,\n        error: lastError ? {\n          message: lastError.error\n        } : null\n      };\n    }), catchError(err => {\n      const isFrameError = err.data.results; // Error is not frame specific\n\n      if (!isFrameError && err.data && err.data.message === 'Metric request error' && err.data.error) {\n        err.message = err.data.error;\n        return throwError(() => err);\n      } // The error is either for a specific frame or for all the frames\n\n\n      const results = Object.values(err.data.results);\n      const firstErrorResult = results.find(r => r.error);\n\n      if (firstErrorResult) {\n        err.message = firstErrorResult.error;\n      }\n\n      if (results.some(r => r.error && /^Throttling:.*/.test(r.error))) {\n        const failedRedIds = Object.keys(err.data.results);\n        const regionsAffected = Object.values(request.queries).reduce((res, {\n          refId,\n          region\n        }) => refId && !failedRedIds.includes(refId) || res.includes(region) ? res : [...res, region], []);\n        regionsAffected.forEach(region => {\n          const actualRegion = this.getActualRegion(region);\n\n          if (actualRegion) {\n            this.debouncedAlert(this.datasourceName, actualRegion);\n          }\n        });\n      }\n\n      return throwError(() => err);\n    }));\n  }\n\n  doMetricResourceRequest(subtype, parameters) {\n    return this.getResource(subtype, parameters);\n  }\n\n  makeLogActionRequest(subtype, queryParams, options = {\n    makeReplacements: true,\n    skipCache: false\n  }) {\n    const range = this.timeSrv.timeRange();\n    const requestParams = {\n      from: range.from.valueOf().toString(),\n      to: range.to.valueOf().toString(),\n      queries: queryParams.map(param => Object.assign({\n        refId: param.refId || 'A',\n        intervalMs: 1,\n        // dummy\n        maxDataPoints: 1,\n        // dummy\n        datasource: this.getRef(),\n        type: 'logAction',\n        subtype: subtype\n      }, param))\n    };\n\n    if (options.makeReplacements) {\n      requestParams.queries.forEach(query => {\n        const fieldsToReplace = ['queryString', 'logGroupNames', 'logGroupName', 'logGroupNamePrefix'];\n        const anyQuery = query;\n\n        for (const fieldName of fieldsToReplace) {\n          if (query.hasOwnProperty(fieldName)) {\n            if (Array.isArray(anyQuery[fieldName])) {\n              anyQuery[fieldName] = anyQuery[fieldName].flatMap(val => {\n                if (fieldName === 'logGroupNames') {\n                  return this.expandVariableToArray(val, options.scopedVars || {});\n                }\n\n                return this.replace(val, options.scopedVars, true, fieldName);\n              });\n            } else {\n              anyQuery[fieldName] = this.replace(anyQuery[fieldName], options.scopedVars, true, fieldName);\n            }\n          }\n        } // TODO: seems to be some sort of bug that we don't really send region with all queries. This means\n        //  if you select different than default region in editor you will get results for autocomplete from wrong\n        //  region.\n\n\n        if (anyQuery.region) {\n          anyQuery.region = this.replace(anyQuery.region, options.scopedVars, true, 'region');\n          anyQuery.region = this.getActualRegion(anyQuery.region);\n        }\n      });\n    }\n\n    const resultsToDataFrames = val => toDataQueryResponse(val).data || [];\n\n    let headers = {};\n\n    if (options.skipCache) {\n      headers = {\n        'X-Cache-Skip': true\n      };\n    }\n\n    return this.awsRequest(DS_QUERY_ENDPOINT, requestParams, headers).pipe(map(response => resultsToDataFrames({\n      data: response\n    })), catchError(err => {\n      var _err$data, _err$data2;\n\n      if (config.featureToggles.datasourceQueryMultiStatus && err.status === 207) {\n        throw err;\n      }\n\n      if (err.status === 400) {\n        throw err;\n      }\n\n      if ((_err$data = err.data) !== null && _err$data !== void 0 && _err$data.error) {\n        throw err.data.error;\n      } else if ((_err$data2 = err.data) !== null && _err$data2 !== void 0 && _err$data2.message) {\n        // In PROD we do not supply .error\n        throw err.data.message;\n      }\n\n      throw err;\n    }));\n  }\n\n  getRegions() {\n    return this.doMetricResourceRequest('regions').then(regions => [{\n      label: 'default',\n      value: 'default',\n      text: 'default'\n    }, ...regions]);\n  }\n\n  getNamespaces() {\n    return this.doMetricResourceRequest('namespaces');\n  }\n\n  async getMetrics(namespace, region) {\n    if (!namespace) {\n      return [];\n    }\n\n    return this.doMetricResourceRequest('metrics', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      namespace: this.templateSrv.replace(namespace)\n    });\n  }\n\n  async getAllMetrics(region) {\n    const values = await this.doMetricResourceRequest('all-metrics', {\n      region: this.templateSrv.replace(this.getActualRegion(region))\n    });\n    return values.map(v => ({\n      metricName: v.value,\n      namespace: v.text\n    }));\n  }\n\n  async getDimensionKeys(namespace, region, dimensionFilters = {}, metricName = '') {\n    if (!namespace) {\n      return [];\n    }\n\n    return this.doMetricResourceRequest('dimension-keys', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      namespace: this.templateSrv.replace(namespace),\n      dimensionFilters: JSON.stringify(this.convertDimensionFormat(dimensionFilters, {})),\n      metricName\n    });\n  }\n\n  async getDimensionValues(region, namespace, metricName, dimensionKey, filterDimensions) {\n    if (!namespace || !metricName) {\n      return [];\n    }\n\n    const values = await this.doMetricResourceRequest('dimension-values', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      namespace: this.templateSrv.replace(namespace),\n      metricName: this.templateSrv.replace(metricName.trim()),\n      dimensionKey: this.templateSrv.replace(dimensionKey),\n      dimensions: JSON.stringify(this.convertDimensionFormat(filterDimensions, {}))\n    });\n    return values;\n  }\n\n  getEbsVolumeIds(region, instanceId) {\n    return this.doMetricResourceRequest('ebs-volume-ids', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      instanceId: this.templateSrv.replace(instanceId)\n    });\n  }\n\n  getEc2InstanceAttribute(region, attributeName, filters) {\n    return this.doMetricResourceRequest('ec2-instance-attribute', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      attributeName: this.templateSrv.replace(attributeName),\n      filters: JSON.stringify(this.convertMultiFilterFormat(filters, 'filter key'))\n    });\n  }\n\n  getResourceARNs(region, resourceType, tags) {\n    return this.doMetricResourceRequest('resource-arns', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      resourceType: this.templateSrv.replace(resourceType),\n      tags: JSON.stringify(this.convertMultiFilterFormat(tags, 'tag name'))\n    });\n  }\n\n  targetContainsTemplate(target) {\n    var _target$logGroupNames;\n\n    return this.templateSrv.containsTemplate(target.region) || this.templateSrv.containsTemplate(target.namespace) || this.templateSrv.containsTemplate(target.metricName) || this.templateSrv.containsTemplate(target.expression) || ((_target$logGroupNames = target.logGroupNames) === null || _target$logGroupNames === void 0 ? void 0 : _target$logGroupNames.some(logGroup => this.templateSrv.containsTemplate(logGroup))) || find(target.dimensions, (v, k) => this.templateSrv.containsTemplate(k) || this.templateSrv.containsTemplate(v));\n  }\n\n  awsRequest(url, data, headers = {}) {\n    const options = {\n      method: 'POST',\n      url,\n      data,\n      headers\n    };\n    return getBackendSrv().fetch(options).pipe(map(result => result.data));\n  }\n\n  getDefaultRegion() {\n    return this.defaultRegion;\n  }\n\n  getActualRegion(region) {\n    if (region === 'default' || region === undefined || region === '') {\n      return this.getDefaultRegion();\n    }\n\n    return region;\n  }\n\n  showContextToggle() {\n    return true;\n  }\n\n  convertToCloudWatchTime(date, roundUp) {\n    if (isString(date)) {\n      date = dateMath.parse(date, roundUp);\n    }\n\n    return Math.round(date.valueOf() / 1000);\n  }\n\n  convertDimensionFormat(dimensions, scopedVars) {\n    return Object.entries(dimensions).reduce((result, [key, value]) => {\n      key = this.replace(key, scopedVars, true, 'dimension keys');\n\n      if (Array.isArray(value)) {\n        return Object.assign({}, result, {\n          [key]: value\n        });\n      }\n\n      if (!value) {\n        return Object.assign({}, result, {\n          [key]: null\n        });\n      }\n\n      const newValues = this.expandVariableToArray(value, scopedVars);\n      return Object.assign({}, result, {\n        [key]: newValues\n      });\n    }, {});\n  } // get the value for a given template variable\n\n\n  expandVariableToArray(value, scopedVars) {\n    const variableName = this.templateSrv.getVariableName(value);\n    const valueVar = this.templateSrv.getVariables().find(({\n      name\n    }) => {\n      return name === variableName;\n    });\n\n    if (variableName && valueVar) {\n      if (valueVar.multi) {\n        return this.templateSrv.replace(value, scopedVars, 'pipe').split('|');\n      }\n\n      return [this.templateSrv.replace(value, scopedVars)];\n    }\n\n    return [value];\n  }\n\n  convertMultiFilterFormat(multiFilters, fieldName) {\n    return Object.entries(multiFilters).reduce((result, [key, values]) => {\n      key = this.replace(key, {}, true, fieldName);\n\n      if (!values) {\n        return Object.assign({}, result, {\n          [key]: null\n        });\n      }\n\n      const initialVal = [];\n      const newValues = values.reduce((result, value) => {\n        const vals = this.expandVariableToArray(value, {});\n        return [...result, ...vals];\n      }, initialVal);\n      return Object.assign({}, result, {\n        [key]: newValues\n      });\n    }, {});\n  }\n\n  replace(target, scopedVars, displayErrorIfIsMultiTemplateVariable, fieldName) {\n    if (displayErrorIfIsMultiTemplateVariable && !!target) {\n      const variable = this.templateSrv.getVariables().find(({\n        name\n      }) => name === this.templateSrv.getVariableName(target));\n\n      if (variable && variable.multi) {\n        this.debouncedCustomAlert('CloudWatch templating error', `Multi template variables are not supported for ${fieldName || target}`);\n      }\n    }\n\n    return this.templateSrv.replace(target, scopedVars);\n  }\n\n  getQueryDisplayText(query) {\n    if (query.queryMode === 'Logs') {\n      var _query$expression;\n\n      return (_query$expression = query.expression) !== null && _query$expression !== void 0 ? _query$expression : '';\n    } else {\n      return JSON.stringify(query);\n    }\n  }\n\n  interpolateVariablesInQueries(queries, scopedVars) {\n    if (!queries.length) {\n      return queries;\n    }\n\n    return queries.map(query => Object.assign({}, query, {\n      region: this.getActualRegion(this.replace(query.region, scopedVars))\n    }, isCloudWatchMetricsQuery(query) && this.interpolateMetricsQueryVariables(query, scopedVars)));\n  }\n\n  interpolateMetricsQueryVariables(query, scopedVars) {\n    var _query$dimensions3;\n\n    return {\n      alias: this.replace(query.alias, scopedVars),\n      metricName: this.replace(query.metricName, scopedVars),\n      namespace: this.replace(query.namespace, scopedVars),\n      period: this.replace(query.period, scopedVars),\n      sqlExpression: this.replace(query.sqlExpression, scopedVars),\n      dimensions: this.convertDimensionFormat((_query$dimensions3 = query.dimensions) !== null && _query$dimensions3 !== void 0 ? _query$dimensions3 : {}, scopedVars)\n    };\n  }\n\n}\n\nfunction withTeardown(observable, onUnsubscribe) {\n  return new Observable(subscriber => {\n    const innerSub = observable.subscribe({\n      next: val => subscriber.next(val),\n      error: err => subscriber.next(err),\n      complete: () => subscriber.complete()\n    });\n    return () => {\n      innerSub.unsubscribe();\n      onUnsubscribe();\n    };\n  });\n}\n\nfunction parseLogGroupName(logIdentifier) {\n  const colonIndex = logIdentifier.lastIndexOf(':');\n  return logIdentifier.slice(colonIndex + 1);\n}","map":{"version":3,"names":["cloneDeep","find","findLast","isEmpty","isString","set","React","from","lastValueFrom","merge","Observable","of","throwError","zip","catchError","concatMap","finalize","map","mergeMap","repeat","scan","share","takeWhile","tap","DataQueryErrorType","dateMath","dateTimeFormat","FieldType","LoadingState","rangeUtil","DataSourceWithBackend","getBackendSrv","toDataQueryResponse","notifyApp","config","createErrorNotification","getTimeSrv","getTemplateSrv","store","AppNotificationTimeout","CloudWatchAnnotationSupport","SQLCompletionItemProvider","ThrottlingErrorMessage","isCloudWatchAnnotationQuery","isCloudWatchLogsQuery","isCloudWatchMetricsQuery","CloudWatchLanguageProvider","memoizedDebounce","MetricMathCompletionItemProvider","migrateMetricQuery","CloudWatchLogsQueryStatus","MetricEditorMode","MetricQueryType","addDataLinksToLogsResponse","runWithRetry","increasingInterval","CloudWatchVariableSupport","DS_QUERY_ENDPOINT","LOG_IDENTIFIER_INTERNAL","LOGSTREAM_IDENTIFIER_INTERNAL","displayAlert","datasourceName","region","dispatch","undefined","createElement","displayCustomError","title","message","CloudWatchDatasource","constructor","instanceSettings","templateSrv","timeSrv","Error","logQueries","options","validLogQueries","filter","item","logGroupNames","length","data","error","state","Done","queryParams","target","queryString","expression","refId","replace","getActualRegion","scopedVars","startTime","Date","timeoutFunc","now","valueOf","intervalToMs","logsTimeout","targets","makeLogActionRequest","makeReplacements","skipCache","pipe","frames","logsQuery","dataFrame","queryId","fields","values","get","meta","custom","statsGroups","response","dataQueryResponse","timeRange","bind","expandVariableToArray","tracingDataSourceUid","metricQueries","timezoneUTCOffset","timeZone","timezone","format","validMetricsQueries","filterMetricQuery","q","migratedQuery","migratedAndIterpolatedQuery","replaceMetricQueryVars","intervalMs","maxDataPoints","type","datasource","getRef","request","range","toString","to","queries","performTimeSeriesQuery","row","limit","direction","logStreamField","logField","field","name","requestParams","startFromHead","logGroupName","parseLogGroupName","rowIndex","logStreamName","endTime","timeEpochMs","dataFrames","metricsQueries","annotationQueries","forEach","query","push","proxyUrl","url","defaultRegion","jsonData","languageProvider","tracingDatasourceUid","sqlCompletionItemProvider","metricMathCompletionItemProvider","variables","annotations","filterQuery","hide","id","getTargetsByQueryMode","dataQueryResponses","handleLogQueries","handleMetricQueries","handleAnnotationQuery","metricQueryType","metricEditorMode","metricName","namespace","sqlExpression","statistic","Search","Builder","Code","Query","dimensions","convertDimensionFormat","period","String","getPeriod","awsRequest","parseInt","actionPrefix","alarmNamePrefix","r","param","statsQuery","startPeriod","endPeriod","step","_","consecutiveFailedAttempts","failures","prevRecordsMatched","frame","recordsMatched","stats","stat","displayName","value","queryResponse","Complete","Cancelled","Failed","includes","hasOwnProperty","failedAttempts","key","every","Loading","Timeout","withTeardown","stopQueries","Object","keys","logQuery","describeLogGroups","params","toArray","getLogGroupFields","fieldNames","fieldPercentages","getLogGroupFieldsResponse","logGroupFields","val","i","percent","getVariables","v","toLowerCase","test","intervalToSeconds","res","dataframes","lastError","results","time","interval","err","isFrameError","firstErrorResult","some","failedRedIds","regionsAffected","reduce","actualRegion","debouncedAlert","doMetricResourceRequest","subtype","parameters","getResource","fieldsToReplace","anyQuery","fieldName","Array","isArray","flatMap","resultsToDataFrames","headers","featureToggles","datasourceQueryMultiStatus","status","getRegions","then","regions","label","text","getNamespaces","getMetrics","getAllMetrics","getDimensionKeys","dimensionFilters","JSON","stringify","getDimensionValues","dimensionKey","filterDimensions","trim","getEbsVolumeIds","instanceId","getEc2InstanceAttribute","attributeName","filters","convertMultiFilterFormat","getResourceARNs","resourceType","tags","targetContainsTemplate","containsTemplate","logGroup","k","method","fetch","result","getDefaultRegion","showContextToggle","convertToCloudWatchTime","date","roundUp","parse","Math","round","entries","newValues","variableName","getVariableName","valueVar","multi","split","multiFilters","initialVal","vals","displayErrorIfIsMultiTemplateVariable","variable","debouncedCustomAlert","getQueryDisplayText","queryMode","interpolateVariablesInQueries","interpolateMetricsQueryVariables","alias","observable","onUnsubscribe","subscriber","innerSub","subscribe","next","complete","unsubscribe","logIdentifier","colonIndex","lastIndexOf","slice"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/datasource.ts"],"sourcesContent":["import { cloneDeep, find, findLast, isEmpty, isString, set } from 'lodash';\nimport React from 'react';\nimport { from, lastValueFrom, merge, Observable, of, throwError, zip } from 'rxjs';\nimport { catchError, concatMap, finalize, map, mergeMap, repeat, scan, share, takeWhile, tap } from 'rxjs/operators';\n\nimport {\n  DataFrame,\n  DataQueryError,\n  DataQueryErrorType,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n  DataSourceWithLogsContextSupport,\n  dateMath,\n  dateTimeFormat,\n  FieldType,\n  LoadingState,\n  LogRowModel,\n  rangeUtil,\n  ScopedVars,\n  TimeRange,\n} from '@grafana/data';\nimport { DataSourceWithBackend, FetchError, getBackendSrv, toDataQueryResponse } from '@grafana/runtime';\nimport { RowContextOptions } from '@grafana/ui/src/components/Logs/LogRowContextProvider';\nimport { notifyApp } from 'app/core/actions';\nimport { config } from 'app/core/config';\nimport { createErrorNotification } from 'app/core/copy/appNotification';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { VariableWithMultiSupport } from 'app/features/variables/types';\nimport { store } from 'app/store/store';\nimport { AppNotificationTimeout } from 'app/types';\n\nimport { CloudWatchAnnotationSupport } from './annotationSupport';\nimport { SQLCompletionItemProvider } from './cloudwatch-sql/completion/CompletionItemProvider';\nimport { ThrottlingErrorMessage } from './components/ThrottlingErrorMessage';\nimport { isCloudWatchAnnotationQuery, isCloudWatchLogsQuery, isCloudWatchMetricsQuery } from './guards';\nimport { CloudWatchLanguageProvider } from './language_provider';\nimport memoizedDebounce from './memoizedDebounce';\nimport { MetricMathCompletionItemProvider } from './metric-math/completion/CompletionItemProvider';\nimport { migrateMetricQuery } from './migrations/metricQueryMigrations';\nimport {\n  CloudWatchAnnotationQuery,\n  CloudWatchJsonData,\n  CloudWatchLogsQuery,\n  CloudWatchLogsQueryStatus,\n  CloudWatchLogsRequest,\n  CloudWatchMetricsQuery,\n  CloudWatchQuery,\n  DescribeLogGroupsRequest,\n  Dimensions,\n  GetLogEventsRequest,\n  GetLogGroupFieldsRequest,\n  GetLogGroupFieldsResponse,\n  LogAction,\n  MetricEditorMode,\n  MetricQuery,\n  MetricQueryType,\n  MetricRequest,\n  MultiFilters,\n  StartQueryRequest,\n  TSDBResponse,\n} from './types';\nimport { addDataLinksToLogsResponse } from './utils/datalinks';\nimport { runWithRetry } from './utils/logsRetry';\nimport { increasingInterval } from './utils/rxjs/increasingInterval';\nimport { CloudWatchVariableSupport } from './variables';\n\nconst DS_QUERY_ENDPOINT = '/api/ds/query';\n\n// Constants also defined in tsdb/cloudwatch/cloudwatch.go\nconst LOG_IDENTIFIER_INTERNAL = '__log__grafana_internal__';\nconst LOGSTREAM_IDENTIFIER_INTERNAL = '__logstream__grafana_internal__';\n\nconst displayAlert = (datasourceName: string, region: string) =>\n  store.dispatch(\n    notifyApp(\n      createErrorNotification(\n        `CloudWatch request limit reached in ${region} for data source ${datasourceName}`,\n        '',\n        undefined,\n        React.createElement(ThrottlingErrorMessage, { region }, null)\n      )\n    )\n  );\n\nconst displayCustomError = (title: string, message: string) =>\n  store.dispatch(notifyApp(createErrorNotification(title, message)));\n\nexport class CloudWatchDatasource\n  extends DataSourceWithBackend<CloudWatchQuery, CloudWatchJsonData>\n  implements DataSourceWithLogsContextSupport\n{\n  proxyUrl: any;\n  defaultRegion: any;\n  datasourceName: string;\n  languageProvider: CloudWatchLanguageProvider;\n  sqlCompletionItemProvider: SQLCompletionItemProvider;\n\n  metricMathCompletionItemProvider: MetricMathCompletionItemProvider;\n\n  tracingDataSourceUid?: string;\n  logsTimeout: string;\n\n  type = 'cloudwatch';\n  standardStatistics = ['Average', 'Maximum', 'Minimum', 'Sum', 'SampleCount'];\n\n  debouncedAlert: (datasourceName: string, region: string) => void = memoizedDebounce(\n    displayAlert,\n    AppNotificationTimeout.Error\n  );\n  debouncedCustomAlert: (title: string, message: string) => void = memoizedDebounce(\n    displayCustomError,\n    AppNotificationTimeout.Error\n  );\n  logQueries: Record<string, { id: string; region: string; statsQuery: boolean }> = {};\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<CloudWatchJsonData>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super(instanceSettings);\n    this.proxyUrl = instanceSettings.url;\n    this.defaultRegion = instanceSettings.jsonData.defaultRegion;\n    this.datasourceName = instanceSettings.name;\n    this.languageProvider = new CloudWatchLanguageProvider(this);\n    this.tracingDataSourceUid = instanceSettings.jsonData.tracingDatasourceUid;\n    this.logsTimeout = instanceSettings.jsonData.logsTimeout || '15m';\n    this.sqlCompletionItemProvider = new SQLCompletionItemProvider(this, this.templateSrv);\n    this.metricMathCompletionItemProvider = new MetricMathCompletionItemProvider(this, this.templateSrv);\n    this.variables = new CloudWatchVariableSupport(this);\n    this.annotations = CloudWatchAnnotationSupport;\n  }\n\n  filterQuery(query: CloudWatchQuery) {\n    return query.hide !== true || (isCloudWatchMetricsQuery(query) && query.id !== '');\n  }\n\n  query(options: DataQueryRequest<CloudWatchQuery>): Observable<DataQueryResponse> {\n    options = cloneDeep(options);\n\n    let queries = options.targets.filter(this.filterQuery);\n    const { logQueries, metricsQueries, annotationQueries } = this.getTargetsByQueryMode(queries);\n\n    const dataQueryResponses: Array<Observable<DataQueryResponse>> = [];\n    if (logQueries.length > 0) {\n      dataQueryResponses.push(this.handleLogQueries(logQueries, options));\n    }\n\n    if (metricsQueries.length > 0) {\n      dataQueryResponses.push(this.handleMetricQueries(metricsQueries, options));\n    }\n\n    if (annotationQueries.length > 0) {\n      dataQueryResponses.push(this.handleAnnotationQuery(annotationQueries, options));\n    }\n    // No valid targets, return the empty result to save a round trip.\n    if (isEmpty(dataQueryResponses)) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    return merge(...dataQueryResponses);\n  }\n\n  /**\n   * Handle log query. The log query works by starting the query on the CloudWatch and then periodically polling for\n   * results.\n   * @param logQueries\n   * @param options\n   */\n  handleLogQueries = (\n    logQueries: CloudWatchLogsQuery[],\n    options: DataQueryRequest<CloudWatchQuery>\n  ): Observable<DataQueryResponse> => {\n    const validLogQueries = logQueries.filter((item) => item.logGroupNames?.length);\n    if (logQueries.length > validLogQueries.length) {\n      return of({ data: [], error: { message: 'Log group is required' } });\n    }\n\n    // No valid targets, return the empty result to save a round trip.\n    if (isEmpty(validLogQueries)) {\n      return of({ data: [], state: LoadingState.Done });\n    }\n\n    const queryParams = logQueries.map((target: CloudWatchLogsQuery) => ({\n      queryString: target.expression || '',\n      refId: target.refId,\n      logGroupNames: target.logGroupNames,\n      region: this.replace(this.getActualRegion(target.region), options.scopedVars, true, 'region'),\n    }));\n\n    const startTime = new Date();\n    const timeoutFunc = () => {\n      return Date.now() >= startTime.valueOf() + rangeUtil.intervalToMs(this.logsTimeout);\n    };\n\n    return runWithRetry(\n      (targets: StartQueryRequest[]) => {\n        return this.makeLogActionRequest('StartQuery', targets, {\n          makeReplacements: true,\n          scopedVars: options.scopedVars,\n          skipCache: true,\n        });\n      },\n      queryParams,\n      timeoutFunc\n    ).pipe(\n      mergeMap(({ frames, error }: { frames: DataFrame[]; error?: DataQueryError }) =>\n        // This queries for the results\n        this.logsQuery(\n          frames.map((dataFrame) => ({\n            queryId: dataFrame.fields[0].values.get(0),\n            region: dataFrame.meta?.custom?.['Region'] ?? 'default',\n            refId: dataFrame.refId!,\n            statsGroups: (logQueries.find((target) => target.refId === dataFrame.refId)! as CloudWatchLogsQuery)\n              .statsGroups,\n          })),\n          timeoutFunc\n        ).pipe(\n          map((response: DataQueryResponse) => {\n            if (!response.error && error) {\n              response.error = error;\n            }\n            return response;\n          })\n        )\n      ),\n      mergeMap((dataQueryResponse) => {\n        return from(\n          (async () => {\n            await addDataLinksToLogsResponse(\n              dataQueryResponse,\n              options,\n              this.timeSrv.timeRange(),\n              this.replace.bind(this),\n              this.expandVariableToArray.bind(this),\n              this.getActualRegion.bind(this),\n              this.tracingDataSourceUid\n            );\n\n            return dataQueryResponse;\n          })()\n        );\n      })\n    );\n  };\n\n  filterMetricQuery(query: CloudWatchMetricsQuery): boolean {\n    const { region, metricQueryType, metricEditorMode, expression, metricName, namespace, sqlExpression, statistic } =\n      query;\n    if (!region) {\n      return false;\n    }\n    if (metricQueryType === MetricQueryType.Search && metricEditorMode === MetricEditorMode.Builder) {\n      return !!namespace && !!metricName && !!statistic;\n    } else if (metricQueryType === MetricQueryType.Search && metricEditorMode === MetricEditorMode.Code) {\n      return !!expression;\n    } else if (metricQueryType === MetricQueryType.Query) {\n      // still TBD how to validate the visual query builder for SQL\n      return !!sqlExpression;\n    }\n\n    throw new Error('invalid metric editor mode');\n  }\n\n  replaceMetricQueryVars(\n    query: CloudWatchMetricsQuery,\n    options: DataQueryRequest<CloudWatchQuery>\n  ): CloudWatchMetricsQuery {\n    query.region = this.templateSrv.replace(this.getActualRegion(query.region), options.scopedVars);\n    query.namespace = this.replace(query.namespace, options.scopedVars, true, 'namespace');\n    query.metricName = this.replace(query.metricName, options.scopedVars, true, 'metric name');\n    query.dimensions = this.convertDimensionFormat(query.dimensions ?? {}, options.scopedVars);\n    query.statistic = this.templateSrv.replace(query.statistic, options.scopedVars);\n    query.period = String(this.getPeriod(query, options)); // use string format for period in graph query, and alerting\n    query.id = this.templateSrv.replace(query.id, options.scopedVars);\n    query.expression = this.templateSrv.replace(query.expression, options.scopedVars);\n    query.sqlExpression = this.templateSrv.replace(query.sqlExpression, options.scopedVars, 'raw');\n\n    return query;\n  }\n\n  handleMetricQueries = (\n    metricQueries: CloudWatchMetricsQuery[],\n    options: DataQueryRequest<CloudWatchQuery>\n  ): Observable<DataQueryResponse> => {\n    const timezoneUTCOffset = dateTimeFormat(Date.now(), {\n      timeZone: options.timezone,\n      format: 'Z',\n    }).replace(':', '');\n\n    const validMetricsQueries = metricQueries\n      .filter(this.filterMetricQuery)\n      .map((q: CloudWatchMetricsQuery): MetricQuery => {\n        const migratedQuery = migrateMetricQuery(q);\n        const migratedAndIterpolatedQuery = this.replaceMetricQueryVars(migratedQuery, options);\n\n        return {\n          timezoneUTCOffset,\n          intervalMs: options.intervalMs,\n          maxDataPoints: options.maxDataPoints,\n          ...migratedAndIterpolatedQuery,\n          type: 'timeSeriesQuery',\n          datasource: this.getRef(),\n        };\n      });\n\n    // No valid targets, return the empty result to save a round trip.\n    if (isEmpty(validMetricsQueries)) {\n      return of({ data: [] });\n    }\n\n    const request = {\n      from: options?.range?.from.valueOf().toString(),\n      to: options?.range?.to.valueOf().toString(),\n      queries: validMetricsQueries,\n    };\n\n    return this.performTimeSeriesQuery(request, options.range);\n  };\n\n  handleAnnotationQuery(\n    queries: CloudWatchAnnotationQuery[],\n    options: DataQueryRequest<CloudWatchQuery>\n  ): Observable<DataQueryResponse> {\n    return this.awsRequest(DS_QUERY_ENDPOINT, {\n      from: options.range.from.valueOf().toString(),\n      to: options.range.to.valueOf().toString(),\n      queries: queries.map((query) => ({\n        ...query,\n        statistic: this.templateSrv.replace(query.statistic),\n        region: this.templateSrv.replace(this.getActualRegion(query.region)),\n        namespace: this.templateSrv.replace(query.namespace),\n        metricName: this.templateSrv.replace(query.metricName),\n        dimensions: this.convertDimensionFormat(query.dimensions ?? {}, {}),\n        period: query.period ? parseInt(query.period, 10) : 300,\n        actionPrefix: query.actionPrefix ?? '',\n        alarmNamePrefix: query.alarmNamePrefix ?? '',\n        type: 'annotationQuery',\n        datasource: this.getRef(),\n      })),\n    }).pipe(\n      map((r) => {\n        const frames = toDataQueryResponse({ data: r }).data as DataFrame[];\n        return { data: frames };\n      })\n    );\n  }\n\n  /**\n   * Checks progress and polls data of a started logs query with some retry logic.\n   * @param queryParams\n   */\n  logsQuery(\n    queryParams: Array<{\n      queryId: string;\n      refId: string;\n      limit?: number;\n      region: string;\n      statsGroups?: string[];\n    }>,\n    timeoutFunc: () => boolean\n  ): Observable<DataQueryResponse> {\n    this.logQueries = {};\n    queryParams.forEach((param) => {\n      this.logQueries[param.refId] = {\n        id: param.queryId,\n        region: param.region,\n        statsQuery: (param.statsGroups?.length ?? 0) > 0 ?? false,\n      };\n    });\n\n    const dataFrames = increasingInterval({ startPeriod: 100, endPeriod: 1000, step: 300 }).pipe(\n      concatMap((_) => this.makeLogActionRequest('GetQueryResults', queryParams, { skipCache: true })),\n      repeat(),\n      share()\n    );\n\n    const consecutiveFailedAttempts = dataFrames.pipe(\n      scan(\n        ({ failures, prevRecordsMatched }, frames) => {\n          failures++;\n          for (const frame of frames) {\n            const recordsMatched = frame.meta?.stats?.find((stat) => stat.displayName === 'Records scanned')?.value!;\n            if (recordsMatched > (prevRecordsMatched[frame.refId!] ?? 0)) {\n              failures = 0;\n            }\n            prevRecordsMatched[frame.refId!] = recordsMatched;\n          }\n\n          return { failures, prevRecordsMatched };\n        },\n        { failures: 0, prevRecordsMatched: {} as Record<string, number> }\n      ),\n      map(({ failures }) => failures),\n      share()\n    );\n\n    const queryResponse: Observable<DataQueryResponse> = zip(dataFrames, consecutiveFailedAttempts).pipe(\n      tap(([dataFrames]) => {\n        for (const frame of dataFrames) {\n          if (\n            [\n              CloudWatchLogsQueryStatus.Complete,\n              CloudWatchLogsQueryStatus.Cancelled,\n              CloudWatchLogsQueryStatus.Failed,\n            ].includes(frame.meta?.custom?.['Status']) &&\n            this.logQueries.hasOwnProperty(frame.refId!)\n          ) {\n            delete this.logQueries[frame.refId!];\n          }\n        }\n      }),\n      map(([dataFrames, failedAttempts]) => {\n        if (timeoutFunc()) {\n          for (const frame of dataFrames) {\n            set(frame, 'meta.custom.Status', CloudWatchLogsQueryStatus.Cancelled);\n          }\n        }\n\n        return {\n          data: dataFrames,\n          key: 'test-key',\n          state: dataFrames.every((dataFrame) =>\n            [\n              CloudWatchLogsQueryStatus.Complete,\n              CloudWatchLogsQueryStatus.Cancelled,\n              CloudWatchLogsQueryStatus.Failed,\n            ].includes(dataFrame.meta?.custom?.['Status'])\n          )\n            ? LoadingState.Done\n            : LoadingState.Loading,\n          error: timeoutFunc()\n            ? {\n                message: `error: query timed out after ${failedAttempts} attempts`,\n                type: DataQueryErrorType.Timeout,\n              }\n            : undefined,\n        };\n      }),\n      takeWhile(({ state }) => state !== LoadingState.Error && state !== LoadingState.Done, true)\n    );\n\n    return withTeardown(queryResponse, () => this.stopQueries());\n  }\n\n  stopQueries() {\n    if (Object.keys(this.logQueries).length > 0) {\n      this.makeLogActionRequest(\n        'StopQuery',\n        Object.values(this.logQueries).map((logQuery) => ({ queryId: logQuery.id, region: logQuery.region })),\n        {\n          makeReplacements: false,\n          skipCache: true,\n        }\n      ).pipe(\n        finalize(() => {\n          this.logQueries = {};\n        })\n      );\n    }\n  }\n\n  async describeLogGroups(params: DescribeLogGroupsRequest): Promise<string[]> {\n    const dataFrames = await lastValueFrom(this.makeLogActionRequest('DescribeLogGroups', [params]));\n\n    const logGroupNames = dataFrames[0]?.fields[0]?.values.toArray() ?? [];\n    return logGroupNames;\n  }\n\n  async getLogGroupFields(params: GetLogGroupFieldsRequest): Promise<GetLogGroupFieldsResponse> {\n    const dataFrames = await lastValueFrom(this.makeLogActionRequest('GetLogGroupFields', [params]));\n\n    const fieldNames = dataFrames[0].fields[0].values.toArray();\n    const fieldPercentages = dataFrames[0].fields[1].values.toArray();\n    const getLogGroupFieldsResponse = {\n      logGroupFields: fieldNames.map((val, i) => ({ name: val, percent: fieldPercentages[i] })) ?? [],\n    };\n\n    return getLogGroupFieldsResponse;\n  }\n\n  getLogRowContext = async (\n    row: LogRowModel,\n    { limit = 10, direction = 'BACKWARD' }: RowContextOptions = {}\n  ): Promise<{ data: DataFrame[] }> => {\n    let logStreamField = null;\n    let logField = null;\n\n    for (const field of row.dataFrame.fields) {\n      if (field.name === LOGSTREAM_IDENTIFIER_INTERNAL) {\n        logStreamField = field;\n        if (logField !== null) {\n          break;\n        }\n      } else if (field.name === LOG_IDENTIFIER_INTERNAL) {\n        logField = field;\n        if (logStreamField !== null) {\n          break;\n        }\n      }\n    }\n\n    const requestParams: GetLogEventsRequest = {\n      limit,\n      startFromHead: direction !== 'BACKWARD',\n      logGroupName: parseLogGroupName(logField!.values.get(row.rowIndex)),\n      logStreamName: logStreamField!.values.get(row.rowIndex),\n    };\n\n    if (direction === 'BACKWARD') {\n      requestParams.endTime = row.timeEpochMs;\n    } else {\n      requestParams.startTime = row.timeEpochMs;\n    }\n\n    const dataFrames = await lastValueFrom(this.makeLogActionRequest('GetLogEvents', [requestParams]));\n\n    return {\n      data: dataFrames,\n    };\n  };\n\n  getVariables() {\n    return this.templateSrv.getVariables().map((v) => `$${v.name}`);\n  }\n\n  getPeriod(target: CloudWatchMetricsQuery, options: any) {\n    let period = this.templateSrv.replace(target.period, options.scopedVars) as any;\n    if (period && period.toLowerCase() !== 'auto') {\n      if (/^\\d+$/.test(period)) {\n        period = parseInt(period, 10);\n      } else {\n        period = rangeUtil.intervalToSeconds(period);\n      }\n\n      if (period < 1) {\n        period = 1;\n      }\n    }\n\n    return period || '';\n  }\n\n  performTimeSeriesQuery(request: MetricRequest, { from, to }: TimeRange): Observable<any> {\n    return this.awsRequest(DS_QUERY_ENDPOINT, request).pipe(\n      map((res) => {\n        const dataframes: DataFrame[] = toDataQueryResponse({ data: res }).data;\n        if (!dataframes || dataframes.length <= 0) {\n          return { data: [] };\n        }\n\n        const lastError = findLast(res.results, (v) => !!v.error);\n\n        dataframes.forEach((frame) => {\n          frame.fields.forEach((field) => {\n            if (field.type === FieldType.time) {\n              // field.config.interval is populated in order for Grafana to fill in null values at frame intervals\n              field.config.interval = frame.meta?.custom?.period * 1000;\n            }\n          });\n        });\n\n        return {\n          data: dataframes,\n          error: lastError ? { message: lastError.error } : null,\n        };\n      }),\n      catchError((err) => {\n        const isFrameError = err.data.results;\n\n        // Error is not frame specific\n        if (!isFrameError && err.data && err.data.message === 'Metric request error' && err.data.error) {\n          err.message = err.data.error;\n          return throwError(() => err);\n        }\n\n        // The error is either for a specific frame or for all the frames\n        const results: Array<{ error?: string }> = Object.values(err.data.results);\n        const firstErrorResult = results.find((r) => r.error);\n        if (firstErrorResult) {\n          err.message = firstErrorResult.error;\n        }\n\n        if (results.some((r) => r.error && /^Throttling:.*/.test(r.error))) {\n          const failedRedIds = Object.keys(err.data.results);\n          const regionsAffected = Object.values(request.queries).reduce(\n            (res: string[], { refId, region }) =>\n              (refId && !failedRedIds.includes(refId)) || res.includes(region) ? res : [...res, region],\n            []\n          ) as string[];\n          regionsAffected.forEach((region) => {\n            const actualRegion = this.getActualRegion(region);\n            if (actualRegion) {\n              this.debouncedAlert(this.datasourceName, actualRegion);\n            }\n          });\n        }\n\n        return throwError(() => err);\n      })\n    );\n  }\n\n  doMetricResourceRequest(subtype: string, parameters?: any): Promise<Array<{ text: any; label: any; value: any }>> {\n    return this.getResource(subtype, parameters);\n  }\n\n  makeLogActionRequest(\n    subtype: LogAction,\n    queryParams: CloudWatchLogsRequest[],\n    options: {\n      scopedVars?: ScopedVars;\n      makeReplacements?: boolean;\n      skipCache?: boolean;\n    } = {\n      makeReplacements: true,\n      skipCache: false,\n    }\n  ): Observable<DataFrame[]> {\n    const range = this.timeSrv.timeRange();\n\n    const requestParams = {\n      from: range.from.valueOf().toString(),\n      to: range.to.valueOf().toString(),\n      queries: queryParams.map((param: CloudWatchLogsRequest) => ({\n        refId: (param as StartQueryRequest).refId || 'A',\n        intervalMs: 1, // dummy\n        maxDataPoints: 1, // dummy\n        datasource: this.getRef(),\n        type: 'logAction',\n        subtype: subtype,\n        ...param,\n      })),\n    };\n\n    if (options.makeReplacements) {\n      requestParams.queries.forEach((query: CloudWatchLogsRequest) => {\n        const fieldsToReplace: Array<\n          keyof (GetLogEventsRequest & StartQueryRequest & DescribeLogGroupsRequest & GetLogGroupFieldsRequest)\n        > = ['queryString', 'logGroupNames', 'logGroupName', 'logGroupNamePrefix'];\n\n        const anyQuery: any = query;\n        for (const fieldName of fieldsToReplace) {\n          if (query.hasOwnProperty(fieldName)) {\n            if (Array.isArray(anyQuery[fieldName])) {\n              anyQuery[fieldName] = anyQuery[fieldName].flatMap((val: string) => {\n                if (fieldName === 'logGroupNames') {\n                  return this.expandVariableToArray(val, options.scopedVars || {});\n                }\n                return this.replace(val, options.scopedVars, true, fieldName);\n              });\n            } else {\n              anyQuery[fieldName] = this.replace(anyQuery[fieldName], options.scopedVars, true, fieldName);\n            }\n          }\n        }\n        // TODO: seems to be some sort of bug that we don't really send region with all queries. This means\n        //  if you select different than default region in editor you will get results for autocomplete from wrong\n        //  region.\n        if (anyQuery.region) {\n          anyQuery.region = this.replace(anyQuery.region, options.scopedVars, true, 'region');\n          anyQuery.region = this.getActualRegion(anyQuery.region);\n        }\n      });\n    }\n\n    const resultsToDataFrames = (val: any): DataFrame[] => toDataQueryResponse(val).data || [];\n    let headers = {};\n    if (options.skipCache) {\n      headers = {\n        'X-Cache-Skip': true,\n      };\n    }\n\n    return this.awsRequest(DS_QUERY_ENDPOINT, requestParams, headers).pipe(\n      map((response) => resultsToDataFrames({ data: response })),\n      catchError((err: FetchError) => {\n        if (config.featureToggles.datasourceQueryMultiStatus && err.status === 207) {\n          throw err;\n        }\n\n        if (err.status === 400) {\n          throw err;\n        }\n\n        if (err.data?.error) {\n          throw err.data.error;\n        } else if (err.data?.message) {\n          // In PROD we do not supply .error\n          throw err.data.message;\n        }\n\n        throw err;\n      })\n    );\n  }\n\n  getRegions(): Promise<Array<{ label: string; value: string; text: string }>> {\n    return this.doMetricResourceRequest('regions').then((regions: any) => [\n      { label: 'default', value: 'default', text: 'default' },\n      ...regions,\n    ]);\n  }\n\n  getNamespaces() {\n    return this.doMetricResourceRequest('namespaces');\n  }\n\n  async getMetrics(namespace: string | undefined, region?: string) {\n    if (!namespace) {\n      return [];\n    }\n\n    return this.doMetricResourceRequest('metrics', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      namespace: this.templateSrv.replace(namespace),\n    });\n  }\n\n  async getAllMetrics(region: string): Promise<Array<{ metricName: string; namespace: string }>> {\n    const values = await this.doMetricResourceRequest('all-metrics', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n    });\n\n    return values.map((v) => ({ metricName: v.value, namespace: v.text }));\n  }\n\n  async getDimensionKeys(\n    namespace: string | undefined,\n    region: string,\n    dimensionFilters: Dimensions = {},\n    metricName = ''\n  ) {\n    if (!namespace) {\n      return [];\n    }\n\n    return this.doMetricResourceRequest('dimension-keys', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      namespace: this.templateSrv.replace(namespace),\n      dimensionFilters: JSON.stringify(this.convertDimensionFormat(dimensionFilters, {})),\n      metricName,\n    });\n  }\n\n  async getDimensionValues(\n    region: string,\n    namespace: string | undefined,\n    metricName: string | undefined,\n    dimensionKey: string,\n    filterDimensions: {}\n  ) {\n    if (!namespace || !metricName) {\n      return [];\n    }\n\n    const values = await this.doMetricResourceRequest('dimension-values', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      namespace: this.templateSrv.replace(namespace),\n      metricName: this.templateSrv.replace(metricName.trim()),\n      dimensionKey: this.templateSrv.replace(dimensionKey),\n      dimensions: JSON.stringify(this.convertDimensionFormat(filterDimensions, {})),\n    });\n\n    return values;\n  }\n\n  getEbsVolumeIds(region: string, instanceId: string) {\n    return this.doMetricResourceRequest('ebs-volume-ids', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      instanceId: this.templateSrv.replace(instanceId),\n    });\n  }\n\n  getEc2InstanceAttribute(region: string, attributeName: string, filters: any) {\n    return this.doMetricResourceRequest('ec2-instance-attribute', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      attributeName: this.templateSrv.replace(attributeName),\n      filters: JSON.stringify(this.convertMultiFilterFormat(filters, 'filter key')),\n    });\n  }\n\n  getResourceARNs(region: string, resourceType: string, tags: any) {\n    return this.doMetricResourceRequest('resource-arns', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      resourceType: this.templateSrv.replace(resourceType),\n      tags: JSON.stringify(this.convertMultiFilterFormat(tags, 'tag name')),\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    return (\n      this.templateSrv.containsTemplate(target.region) ||\n      this.templateSrv.containsTemplate(target.namespace) ||\n      this.templateSrv.containsTemplate(target.metricName) ||\n      this.templateSrv.containsTemplate(target.expression!) ||\n      target.logGroupNames?.some((logGroup: string) => this.templateSrv.containsTemplate(logGroup)) ||\n      find(target.dimensions, (v, k) => this.templateSrv.containsTemplate(k) || this.templateSrv.containsTemplate(v))\n    );\n  }\n\n  awsRequest(url: string, data: MetricRequest, headers: Record<string, any> = {}): Observable<TSDBResponse> {\n    const options = {\n      method: 'POST',\n      url,\n      data,\n      headers,\n    };\n\n    return getBackendSrv()\n      .fetch<TSDBResponse>(options)\n      .pipe(map((result) => result.data));\n  }\n\n  getDefaultRegion() {\n    return this.defaultRegion;\n  }\n\n  getActualRegion(region?: string) {\n    if (region === 'default' || region === undefined || region === '') {\n      return this.getDefaultRegion();\n    }\n    return region;\n  }\n\n  showContextToggle() {\n    return true;\n  }\n\n  convertToCloudWatchTime(date: any, roundUp: any) {\n    if (isString(date)) {\n      date = dateMath.parse(date, roundUp);\n    }\n    return Math.round(date.valueOf() / 1000);\n  }\n\n  convertDimensionFormat(dimensions: Dimensions, scopedVars: ScopedVars) {\n    return Object.entries(dimensions).reduce((result, [key, value]) => {\n      key = this.replace(key, scopedVars, true, 'dimension keys');\n\n      if (Array.isArray(value)) {\n        return { ...result, [key]: value };\n      }\n\n      if (!value) {\n        return { ...result, [key]: null };\n      }\n\n      const newValues = this.expandVariableToArray(value, scopedVars);\n      return { ...result, [key]: newValues };\n    }, {});\n  }\n\n  // get the value for a given template variable\n  expandVariableToArray(value: string, scopedVars: ScopedVars): string[] {\n    const variableName = this.templateSrv.getVariableName(value);\n    const valueVar = this.templateSrv.getVariables().find(({ name }) => {\n      return name === variableName;\n    });\n    if (variableName && valueVar) {\n      if ((valueVar as unknown as VariableWithMultiSupport).multi) {\n        return this.templateSrv.replace(value, scopedVars, 'pipe').split('|');\n      }\n      return [this.templateSrv.replace(value, scopedVars)];\n    }\n    return [value];\n  }\n\n  convertMultiFilterFormat(multiFilters: MultiFilters, fieldName?: string) {\n    return Object.entries(multiFilters).reduce((result, [key, values]) => {\n      key = this.replace(key, {}, true, fieldName);\n      if (!values) {\n        return { ...result, [key]: null };\n      }\n      const initialVal: string[] = [];\n      const newValues = values.reduce((result, value) => {\n        const vals = this.expandVariableToArray(value, {});\n        return [...result, ...vals];\n      }, initialVal);\n      return { ...result, [key]: newValues };\n    }, {});\n  }\n\n  replace(\n    target?: string,\n    scopedVars?: ScopedVars,\n    displayErrorIfIsMultiTemplateVariable?: boolean,\n    fieldName?: string\n  ) {\n    if (displayErrorIfIsMultiTemplateVariable && !!target) {\n      const variable = this.templateSrv\n        .getVariables()\n        .find(({ name }) => name === this.templateSrv.getVariableName(target));\n      if (variable && (variable as unknown as VariableWithMultiSupport).multi) {\n        this.debouncedCustomAlert(\n          'CloudWatch templating error',\n          `Multi template variables are not supported for ${fieldName || target}`\n        );\n      }\n    }\n\n    return this.templateSrv.replace(target, scopedVars);\n  }\n\n  getQueryDisplayText(query: CloudWatchQuery) {\n    if (query.queryMode === 'Logs') {\n      return query.expression ?? '';\n    } else {\n      return JSON.stringify(query);\n    }\n  }\n\n  getTargetsByQueryMode = (targets: CloudWatchQuery[]) => {\n    const logQueries: CloudWatchLogsQuery[] = [];\n    const metricsQueries: CloudWatchMetricsQuery[] = [];\n    const annotationQueries: CloudWatchAnnotationQuery[] = [];\n\n    targets.forEach((query) => {\n      if (isCloudWatchAnnotationQuery(query)) {\n        annotationQueries.push(query);\n      } else if (isCloudWatchLogsQuery(query)) {\n        logQueries.push(query);\n      } else {\n        metricsQueries.push(query);\n      }\n    });\n\n    return {\n      logQueries,\n      metricsQueries,\n      annotationQueries,\n    };\n  };\n\n  interpolateVariablesInQueries(queries: CloudWatchQuery[], scopedVars: ScopedVars): CloudWatchQuery[] {\n    if (!queries.length) {\n      return queries;\n    }\n\n    return queries.map((query) => ({\n      ...query,\n      region: this.getActualRegion(this.replace(query.region, scopedVars)),\n      ...(isCloudWatchMetricsQuery(query) && this.interpolateMetricsQueryVariables(query, scopedVars)),\n    }));\n  }\n\n  interpolateMetricsQueryVariables(\n    query: CloudWatchMetricsQuery,\n    scopedVars: ScopedVars\n  ): Pick<CloudWatchMetricsQuery, 'alias' | 'metricName' | 'namespace' | 'period' | 'dimensions' | 'sqlExpression'> {\n    return {\n      alias: this.replace(query.alias, scopedVars),\n      metricName: this.replace(query.metricName, scopedVars),\n      namespace: this.replace(query.namespace, scopedVars),\n      period: this.replace(query.period, scopedVars),\n      sqlExpression: this.replace(query.sqlExpression, scopedVars),\n      dimensions: this.convertDimensionFormat(query.dimensions ?? {}, scopedVars),\n    };\n  }\n}\n\nfunction withTeardown<T = any>(observable: Observable<T>, onUnsubscribe: () => void): Observable<T> {\n  return new Observable<T>((subscriber) => {\n    const innerSub = observable.subscribe({\n      next: (val) => subscriber.next(val),\n      error: (err) => subscriber.next(err),\n      complete: () => subscriber.complete(),\n    });\n\n    return () => {\n      innerSub.unsubscribe();\n      onUnsubscribe();\n    };\n  });\n}\n\nfunction parseLogGroupName(logIdentifier: string): string {\n  const colonIndex = logIdentifier.lastIndexOf(':');\n  return logIdentifier.slice(colonIndex + 1);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}